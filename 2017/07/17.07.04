00:01:26 <EvanR> you can get a length from a path
00:01:57 <The_Kinaesthetic> Not the way I created the path
00:02:22 <The_Kinaesthetic> Anyway it's 3 am, thanks for the help, but I'm going to have to work on it tomorrow and then potentially come back.
00:02:32 <EvanR> o/
00:02:44 <The_Kinaesthetic> Thanks again everyone, bye
00:49:57 <merijn> hmmm, so someone on the mailing list is suggesting that passing GHC RTS options to use a bigger allocation area can dramatically speed up compile times. Anyone got experience with that?
00:52:37 <kuribas> I found this: http://ghc.readthedocs.io/en/8.0.1/sooner.html
00:54:11 <merijn> Maybe I should just write a GHC wrapper that simply always sets a way bigger allocation area
01:14:01 <Lokathor> just give it all your RAM always
01:16:43 <merijn> Lokathor: Well, yes, that was kinda the idea :p
01:17:08 <Lokathor> what makes me sad about haskell is the embarassingly large binaries
01:17:17 <hanna> Lokathor: then use dynamic linking
01:17:27 <Lokathor> welllll :P
01:17:37 <osa1> nix somehow manages to produce small haskell binaries. I'm not sure what it's doing but I think it maybe be --split-sections or similar flags
01:17:50 <osa1> downside is compilation takes much longer
01:18:27 <merijn> Lokathor: Why?
01:19:00 <Lokathor> merijn, because those C and Rust folks have smaller binaries! :P
01:19:15 <merijn> Binary size is basically completely unimportant unless you're somehow shipping on disk limited devices, and even phones have gigabytes of storage now
01:19:26 <osa1> you can't compete with C binary sizes probably
01:19:29 <mniip> I-cache?
01:19:38 <mniip> osa1, you can by writing assembly
01:19:40 <hanna> static haskell hello world: 2.8 MB; dynamic haskell hello world: 21 kB
01:19:41 <merijn> mniip: binary size is irrelevant for I-cache
01:19:48 <osa1> mniip: I meant in Haskell
01:19:54 <merijn> mniip: The actual code running matters
01:20:03 <merijn> mniip: You only ever load parts of the binary into I-cache
01:20:16 <merijn> hanna: Except the RTS still has to be on your machine...
01:20:17 <mniip> right
01:20:24 <mniip> but there is'nt much in a binary other than code and data
01:20:25 <Cale> We almost ran into an issue with binary size on one of our mobile apps, but then managed to find a way to convince Apple's checker that we really only care about running on newer phones.
01:20:33 <hanna> dynamic C hello world: 11 kB, static C hello world: 49 MB
01:20:56 <Cale> Still, it would be nice if the dead code elimination was working better -- I find it hard to believe that all the code in our generated binary is really live.
01:21:10 <hanna> merijn: yes, and libc has to be on your machine for your dynamically linked C program to avoid pulling in 49 MB worth of libc
01:21:24 <hanna> (we're comparing apples against apples, right?)
01:21:27 <Lokathor> i wonder if LLVM and LTO could do more than the GHC native generator?
01:21:37 <mniip> hanna, ummm
01:21:42 <kuribas> wasn't there a problem in a distribution that used dynamic linking?
01:21:45 <mniip> static hello world is 69KB over here
01:21:57 <Lokathor> still far less than 2.8mb
01:21:59 <mniip> oops
01:22:05 <yushyin> kuribas: arch switched to dynamic linking
01:22:06 <mniip> 3.4MB
01:22:09 <mniip> stated the wrong file
01:22:19 <kuribas> yushyin: yes, and there were many complaints about it.
01:22:28 <hanna> mniip: oh, sorry, I'm off my an order of 10
01:22:30 <hanna> 4.9 MB
01:22:46 <mniip> heh
01:23:39 <hanna> my point is that if you want to avoid large binary size to do redundant copies of code, you use dynamic linking
01:23:47 <hanna> this is a technique that has existed for decades partially for this exact reason
01:24:22 <merijn> hanna: And it's a terrible idea in C too :)
01:24:29 <hanna> (the other one being ABI-compatible updates, but this is mostly irrelevant for GHC because the minor version is part of the soname)
01:24:49 <merijn> Dynamic linking of "static" (i.e., not dlopen'ed at runtime) libraries has only ever given me pain
01:26:43 <yushyin> kuribas: yes, because people don‚Äôt know how to handle the sudden change. Me is using stack for my dev stuff and no problems so far. But yes ghc stuff is not quite suitable for dynamic linking anyways because of the ABI issues (hanna mentioned that)
01:26:50 <yushyin> :(
01:28:08 <hanna> gentoo uses dynamic linking for haskell, but gentoo also has a package manager
01:28:19 <hanna> (one that's capable of tracking reverse dependencies and sonames)
01:29:50 <hanna> personally I dislike static binaries and would prefer everything be dynamic, partly because it helps debugging, and partly because despite being a gentoo user I don't want to recompile every program every day
01:30:08 <hanna> (although binary distros suffer more from that than source distros)
01:30:24 <yushyin> hanna: nice feature of gentoo‚Äôs package manager
01:31:18 <merijn> hanna: How does it help debugging?
01:31:41 <hanna> merijn: I can `ldd` a binary to see what libraries it uses, and I can break on imported symbols in gdb even without debugging symbols
01:32:15 <hanna> (but I'll cede that with debugging symbols, which you should have anyway, the difference is less pronounced)
01:32:32 <cocreature> hanna: for Haskell you need to recompile anyway no? I don‚Äôt think GHC makes any guarantees about the changes you can make to a library without breaking users of the library
01:33:45 <hanna> for haskell you need to recompile the entire reverse dependency tree, yes
01:34:06 <hanna> whether you use dynamic or static linking
01:34:17 <hanna> so at that point both are just a question of representational efficiency vs ease of distribution
01:34:32 <hanna> for GHC I should say
01:43:31 <dramforever> Anyone here has experience on axiom (the transient thingy)?
01:44:25 <dramforever> I can't seem to get this to work: https://github.com/transient-haskell/transient-examples/blob/master/webapp.hs#L81
01:44:32 <dramforever> the stream killing isn't working at all
01:56:23 <heebo> how can i pass a type to a function so that the function can infer the correct typeclass instance to use?
01:56:43 <merijn> heebo: Normally you use Proxy for that
01:57:41 <heebo> merijn: Proxy? can you point me at an example?
01:57:56 <merijn> heebo: So instead of having "class Foo a where myFun :: Bool -> String" where GHC can't infer which instance you use, you'd use "myFun :: Proxy a -> Bool -> String" or "myFun :: proxy a -> Bool -> String"
01:58:23 <merijn> heebo: https://hackage.haskell.org/package/base-4.9.1.0/docs/Data-Proxy.html
01:58:26 <heebo> oooh thanks 
01:58:42 <merijn> heebo: So you can write "myFun (Proxy :: Proxy Int)" to make it work
01:59:07 <dramforever> You can also use TypeApplications but GHC 7.10 and 7.8 users will kill you
01:59:32 <merijn> heebo: Normally you use "proxy a" (proxy being a type variable) so people don't have to use Proxy explicitly. If you happen to have a "Maybe Int" you can pass that in (GHC will infer 'proxy = Maybe')
01:59:38 <heebo> aha , i was looking at type families but it didnt fit because they are driven by Types and not values (...I think)
01:59:44 <merijn> heebo: Right
01:59:57 <merijn> heebo: TypeFamilies are for doing the opposite of what you want :)
02:00:13 <heebo> heebo: aha yes
02:00:30 <heebo> merijn: yes
02:00:46 <heebo> haskell has got me talking to myself
02:23:56 <hanna> ‚Äúproxy‚Äù (as a variable) also carries a strong property: you *know* the code can't do anything with the value you pass other than to use it as a type reference, and this is independent of the definition of any particular type
02:24:16 <hanna> hmm of course that's not true because you can still `seq` it
02:24:20 <hanna> stupid haskell
02:25:58 <hanna> either way, `seq` aside, this lets you ‚Äúsafely‚Äù use e.g. proxy :: proxy t; proxy = error "proxy"
02:26:06 <hanna> and that way you don't have to ever bother with even defining data Proxy
02:32:01 <merijn> Is there a convenient "Handle -> IO [String]" anywhere or should I simply use hGetContents and lines?
02:32:55 <hanna> define ‚Äúconvenient‚Äù
02:33:08 <hanna> what property are you looking for? bounded memory usage -> use iterators
02:33:17 <merijn> I don't care
02:33:23 <hanna> ease of API -> can't get much easier than fmap lines . hGetContents
02:33:24 <merijn> I'm looking for no dependencies
02:33:32 <hanna> well there's your answer :p
02:33:43 <johnw> the opposite of dependency injection is clearly dependency rejection
02:33:47 <merijn> Well, hGetContents is lazy IO, so that means catching errors is a pain in the neck
02:33:48 <hanna> there's also hGetLine which you could iterate over in a loop 
02:34:04 <merijn> hanna: Right, except I don't wanna write the loop if I don't have to :p
02:36:09 <hanna> merijn: if you want to avoid lazy I/O then how about Data.Text.hGetContents 
02:36:09 <merijn> johnw: More dependencies = more uphill struggle to get shit merged upstream, sadly
02:36:13 <hanna> which afaik doesn't involve lazy I/O
02:36:23 <johnw> merijn: oh, I hear you
02:36:29 <merijn> Yeah, I was thinking about that too, but then I need to unwrap all the Text to String
02:36:42 <johnw> merijn: I'm avoiding a dependency right now on a project that I'm really struggling not to give in to
02:37:20 <hanna> in the time it took you to look this up you could have written ‚ÄúhGetLines h = lines . T.unpack <$> T.hGetContents h‚Äù :p
02:37:33 <EvanR> text is a dependency
02:37:37 <merijn> hanna: Except I was writing other things in the meantime :)
02:38:36 <EvanR> haskell is a great module importation algebra, if only it had a nice programming language
02:38:56 <merijn> EvanR: ;)
02:40:22 <hanna> although note that I would expect `hGetLines` to use lazy I/O
02:40:54 <hanna> I struggle coming up with a use case where I would want to non-lazily read in the entire contents of a file as a Text, let alone a String
02:41:19 <merijn> Eh, if files are small you always wanna do it strict
02:41:29 <merijn> hanna: Lazy IO leaks handles everywhere
02:41:54 <EvanR> i often want a strict full file read
02:41:55 <hanna> well what's the use case? if I'm writing a ‚Äúreal‚Äù program that processes text files, I'm either doing so with constant space (iterators) or using a real parsing abstraction
02:42:02 <hanna> (e.g. pipes-attoparsec)
02:42:05 <merijn> If you wanna read in a 1,000 text files of a few kb, you can easily fit them into memory as strict Text, but you'll run out of file descriptors with lazy IO
02:42:22 <EvanR> if your files have a consistent upperbound in size, its constant space! :)
02:42:29 <hanna> usually when I'm reading in Strings it's inside ghci, or otherwise it's for a quick and dirty test program or proof of concept or something :p
02:42:44 <merijn> hanna: All my code is dirty tests and proof of concepts
02:42:46 <hanna> where I don't care about neither lazy I/O nor efficiency nor exceptions
02:42:50 <hanna> hehe
02:42:54 <hanna> excellent answer
02:43:00 <merijn> hmm, no, some of my code is hacky fixes to tooling too
02:43:30 <merijn> like the stuff I'm writing now
02:43:32 <hanna> and of course, if I want the whole file in memory, I'd just type ‚Äúlength it‚Äù :D
02:43:49 <Cale> There are a lot of programs where you don't necessarily have to worry so much about the number of handles you're using. If your program opens a couple of files and streams a bunch of stuff out of them, plain lazy I/O is probably fine.
02:44:41 <hanna> My main issue with hGetContents for anything other than testing or development is the use of String
02:44:43 <EvanR> reading the whole file in as a String though, that doesnt make too much sense
02:44:45 <hanna> not the use of lazy I/O
02:45:07 <merijn> hanna: createProcess and many other APIs demand String
02:45:09 <Cale> Well, there's hGetContents for Text and ByteString too (including the lazy variants of those)
02:45:11 <merijn> hanna: So kinda stuck with that
02:45:42 <EvanR> it still makes efficiency sense to load it as (lazy perhaps) Text
02:45:54 <EvanR> then feed an unpacking to the those APIs
02:46:05 <EvanR> so you dont have a giant list of Chars in memory
02:47:50 <EvanR> as embarassing as the discrepancy between APIs is
02:53:33 <whald> does anyone here have some experience with fast-logger? i'm having trouble with this snippet: http://lpaste.net/356667
02:54:19 <hanna> Cale: yeah, I'd be perfectly happy using Data.Text.Lazy.hGetContents in a ‚Äúserious‚Äù program for example
02:54:56 <hanna> (my litmus test for this is usually: if I use some sort of fancy iterator library, am I going to handle e.g. I/O errors in any way other than ‚Äúerror‚Äù? if not, there's no point)
02:55:00 <Rembane> whald: What does it do, what do you want it to do?
02:55:15 <whald> when trying to log to a file, there it struggles badly when logging from multiple threads, it seems most threads do not log at all but get stuck when emitting their first log message. isn't fast-logger supposed to work w/ multiple threads?
02:57:32 <whald> Rembane, looking at the code of fast-logger, IIUC care is taken that the file rotations logic is executed by only one thread and that's about it. i'm unsure if this is sufficient, but other than probably garbage output i don't see what possibly could go wrong. and my problem is i don't get any output at all, except for the first few messages emitted from the main thread.
02:57:37 <Rembane> whald: I don't know if fastlogger is thread safe, what happens if you create one thread that takes care of the logging?
02:58:37 * hackagebot async-refresh-tokens 0.2.0.0 ‚Äì Package implementing core logic for refreshing of expiring access tokens ‚Äì https://hackage.haskell.org/package/async-refresh-tokens
02:59:20 <whald> Rembane, i could certainly do that, but reading the module description of fast-logger: "This module provides a fast logging system which scales on multicore environments" i think i shouldn't have to. that's why i ask here. :-)
02:59:54 <Rembane> whald: That's a very valid point indeed. 
03:07:47 <Rembane> whald: To be totally honest I only use fast logger in one thread since old habits die hard. But I hope somebody else here has some experience with fast logger.
03:08:39 <whald> Rembane, thanks for having a look!
03:11:49 <Rembane> whald: No worries. Good luck!
03:18:17 <zomg> What's the correct way to run two parsers with Aeson? I have `parseEither (parseFoo v <|> parseBar v) v` which seems a bit clunky
03:18:37 <zomg> Every function that runs parsers seems to expect them in a format of Value -> Parser a, but that doesn't work with <|>
03:20:40 <zomg> (essentially I have something like data Thing = ThingFoo | ThingBar where the JSON is so random it seems easier to deal with manual parsing)
03:22:03 <renzhi> is there a more reliable stackage mirror? My connection to https://s3.amazonaws.com/hackage.fpcomplete.com/ times out all the time.
03:36:55 <srhb> renzhi: Isn't s3 usually quite reliable? Are you sure it isn't a problem on your end?
03:55:39 <merijn> zomg: how about just "(,) <$> parseFoo <*> parseBar"?
03:55:59 <quchen> That parses Foo*Bar, not Foo+Bar
03:56:54 <merijn> I misread what he wanted, then
03:57:30 <zomg> let me clarify that, basically `v` can be a number of different things, some of which will parse using parseFoo, others will parse with parseBar
03:58:03 <zomg> so one of the parsers will fail for any given `v` and one should succeed
03:58:39 <merijn> zomg: Don't you just want "many $ (Left <$> parseFoo) <|> (Right <$> parseBar)"?
04:00:27 <zomg> Doesn't that produce a list?
04:01:32 <merijn> zomg: You really need to write a less vague explanation of what you want, because right now you're just having us guess about a really ill-specified example
04:02:23 <zomg> ok sorry, I didn't realize it was that vague :)
04:02:58 <zomg> so I have data Thing = ThingFoo | ThingBar (which have fields but that's just a detail of how it gets parsed)
04:03:35 <zomg> and I have some v :: Value which comes out of Aeson, which I want to parse into a Thing
04:04:18 <zomg> parseFoo is Value -> Thing and produces a ThingFoo, and parseBar is Value -> Thing and produces a ThingBar
04:04:28 <zomg> sorry, they are Value -> Parser Thing
04:05:12 <zomg> so right now I have `parseEither (const (parseFoo v <|> parseBar v)) v` which works but as you can see it's pretty clunky :P
04:06:15 <zomg> Does it make any more sense now?
04:06:45 <merijn> I don't think you can make it much nicer, except writing like a small helper
04:07:53 <zomg> Ok, i thought it was a bit odd to have to pass v into both the parsers and parseEither, so I thought maybe I was missing some trick :)
04:08:17 <zomg> but yeah all funcs that produce something useful out of a Parser seem to always be Value -> Parser a
04:09:05 <zomg> or rather, always require a Value -> Parser a as a parameter
04:22:37 <felixphew> me again, more silly questions
04:22:59 <felixphew> what's the easiest way to make an int into a byte array (big-endian)?
04:23:24 <felixphew> sorry, autocorrect
04:23:32 <merijn> felixphew: That really depends on what you're trying to do
04:23:33 <felixphew> that should be an Integer to a ByteArray
04:24:09 <felixphew> I have an Integer and I need to encrypt it, and the encryption function takes anything that's a member of ByteArray
04:24:29 <merijn> felixphew: I would serialise to ByteString and encrypt that
04:24:41 <felixphew> sounds good
04:24:53 <felixphew> is there a constructor for ByteString that will eat an Integer?
04:25:11 <felixphew> or do I have to write a little thing to do that
04:25:25 <merijn> felixphew: Have a look at the Binary package
04:25:43 <merijn> felixphew: That should cover all binary serialisation needs you ever have :)
04:25:58 <felixphew> thanks!
04:29:39 <dmiles> Hets is amzing ..has anyone here used it or developed for it?
04:33:23 <osa1> what is hets?
04:34:06 <dmiles> https://github.com/spechub/Hets
04:35:13 <dmiles> it allows one to hook into theorem provers and inference engines
04:35:44 <zomg> Is it bad I have no freaking clue what that could possibly be useful for in the realm of writing software? =)
04:35:49 <zomg> well, in any realm really...
04:36:16 <Sylph-DS> This particular framework or formal verification in general?
04:36:30 <dmiles> I for example would use it for the content managment of a MUD written in first order logic
04:37:10 <dmiles> Or translate english sentences into it's Comon Logic impl in order to use it as an expert system that can be spoken with in english
04:37:55 <dmiles> That expert system could for instance field programming questions
04:38:11 <dmiles> (about specific hackage packages)
04:39:53 <dmiles> Its logical database can be used to create a typessystem where much code is infered
04:40:30 <dmiles> I am very proficient in use of its logical database :P just new to Haskell
04:41:09 <dmiles> Trying to get a sense if it is mostly unheard of or if it is used as much as matlab
04:42:59 <dmiles> well i suppose i'll make sure i can build it and things .. whatever version I am using seems a little buggy
04:44:20 <dmiles> (just buggy in that things like hardcoded pathnames and things might ahve been moved)
04:46:36 <dmiles> oh yes Sylph-DS, This particular framework allows one to do formal verification as well as the uses i mentioned
04:46:59 <rgrinberg> is there a way to log with turtle to stderr?
04:48:50 <Sylph-DS> dmiles, that's what I gleaned from the github page. My question was in respoonse to zomg's question of what it would be useful for. Anyway, I had never heard of HETS, though I think I have heard of some of the tools incorporated in it (e.g minisat). I may not be the best person to ask though, my interest in formal verification and such is kinda sideways and only relatively recent.
04:52:18 <dmiles> Sylph-DS: dont worry :) my interest in software that does formal verification hasnt happened yet.  When i studying things like minisat it was to implement faster smarter AI planners
04:57:46 <merijn> Any stack users willing to spend a few minutes to test a few things for me?
04:58:50 <quchen> merijn: Shoot
04:59:47 <merijn> quchen: So first of all, can you check which flags "stack repl" accepts? Most importantly whether it supports "--with-ghc=path/to/exe"
05:02:57 <quchen> merijn: http://lpaste.net/8246338123148034048
05:03:13 <quchen> merijn: --with-ghc is supported
05:03:24 <merijn> quchen: Off too a good start :)
05:04:20 <merijn> quchen: I have a tiny program I'd like you to build and then run "stack repl --with-ghc=program" in some stack project and show me the output (if it works): http://lpaste.net/356670
05:06:16 <quchen> merijn: http://lpaste.net/356671
05:06:20 <quchen> Seems to work
05:06:34 <quchen> Well, exit code 1
05:06:37 <quchen> 0
05:07:22 <quchen> You‚Äôre trying to MITM GHC? :-D
05:07:28 <whald> sorry if i'm boring you guy with my logging problems, but here i go again. so i had this http://lpaste.net/356667 which would block threads in their logging calls after some (short) time. i did not make any progress on this front so i thought it would be a good idea to do the file writing myself, bypassing fast-logger. this gives http://lpaste.net/356669
05:08:30 <merijn> quchen: Yeah, it seems to exit code 1 here too occasionally, that's...a work in progress :p
05:08:41 <quchen> merijn: That was just a typo
05:08:44 <quchen> Exit code is 0
05:08:50 <whald> fun fact: this also blocks after a few lines were written, for no obvious reason. but _only_ when the threaded runtime is used. this reminds me of https://ghc.haskell.org/trac/ghc/ticket/13903 -- except it's on linux this time. does anyone have an idea what's going wrong? :-/
05:09:10 <merijn> quchen: Well, I ran into an issue with hdevtools not supporting "cabal new-build", and since the control flow is fundamentally different it's hard to port the current hdevtools code to work with it
05:09:37 <merijn> quchen: So ezyang gave me the idea of hijacking the "cabal repl" interface to have cabal simply TELL me the flags I need compile code. Which seems to work
05:10:30 <merijn> quchen: But if largely the same workflow works with stack I can basically rip out the entire Cabal dependency of hdevtools, simplify 100s of lines of code to a few invocations of cabal/stack and get hdevtools working for cabal, sandboxes, new-build, and stack in one fell swoop :)
05:11:53 <merijn> The only downsides are: Might not support REALLY old cabal-install versions and the interface is a bit brittle, but cabal is going to get a nicer (stable) interface for this "Soon (TM)" and I hope stack will end up copying that
05:13:41 <merijn> quchen: ah, hmm, looks like stack repl dumps it's info into a tempfile...could you show the contents of that "/tmp/ghci4518/ghci-script" if it still exists?
05:24:13 <funcslam> On GHCi, what's the difference between  ":load ModuleName" and "import ModuleName"?
05:25:25 <merijn> funcslam: ":load" read in the entire file, which mean non-exported functions are in scope
05:25:32 <merijn> import only brings exported functions in scope, afaik
05:30:21 <slack1256> also, import can reuse the typical import syntax for "qualified,as" etc
05:32:16 <slack1256> How would you guys profile a GUI program? Cli ones you have intended behaviour on inputs. For gui, how do you script?
05:34:14 <merijn> slack1256: What do you mean "profile"?
05:35:30 <slack1256> checking +RTS options as -A -H -n -qg etc to see a good default
05:36:01 <slack1256> currently, I am launching by hand different combinations of the gui program and recording the results, because I don't know how to script mouse interaction 
05:36:28 <slack1256> maybe people write test for modules they want to test and check those?
05:37:37 <merijn> slack1256: I personally think all applications should basically be libraries with as thin as possible layer of "application" around it. So yes, move all of the functionality into the library, profile that, and make your GUI a wrapper for the library
05:40:57 <zomg> I've not really done any threading stuff in haskell beyond some basic things with Async so have a question regarding some of this..
05:41:23 <zomg> I'm working with something where I'd most likely have one thread that receives messages, and another thread which would process them
05:42:03 <zomg> I guess a TChan could be an option for communicating between the two - however, the processing thread might occasionally take a while, and messages could pile up in the TChan
05:42:34 <merijn> zomg: ANd you wanna limit the sender?
05:42:35 <zomg> in such a case the program would only care about the latest message and the rest could be ignored - in this case, I guess you can just read until the channel is empty? Or is there some better method for this?
05:42:57 <merijn> zomg: You only care about the very last message?
05:43:15 <slack1256> if you care about the last message, why not use a MVar?
05:43:44 <slack1256> you can replace it with just the last value. Also make the receiving thread "read" and not "take" the MVar
05:43:45 <zomg> merijn: yep, they're ticker values for cryptocoins basically and at least in this instance only the latest value is useful :)
05:44:08 <joehh> what is the best way to debug a "thread blocked indefinitely in an STM/MVar transaction"
05:44:13 <merijn> zomg: I'd use an MVar/TMVar
05:44:20 <zomg> slack1256: could this not potentially cause an issue where the same value is read repeatedly if no new value is added?
05:44:22 <merijn> joehh: Thinking long and hard, sadly
05:44:49 <joehh> :) :(
05:45:07 <joehh> Is there any way to identify which thread is blocked?
05:45:44 <merijn> joehh: If you compile with profiling + rtsopt you can run the program with "+RTS -xc" and you should get a stack trace
05:45:53 <zomg> merijn: yeah that would make sense in a case where only the latest is relevant I guess. I could always use take to avoid reading the same value several times I guess, and to have the processing thread to wait for a new value if it processes the current value quickly enough
05:46:11 <slack1256> zomg: it could. Take the MVar then.
05:46:44 <zomg> slack1256: ok, seems reasonable :) I might eventually want something where all the values matter, but I think I'll start with an MVar 
05:46:48 <zomg> thanks guys
05:47:29 <joehh> merijn: I've tried that, but am getting link errors when compiling - not sure how to debug from there
05:47:47 <merijn> joehh: Link errors? How are you building the program?
05:48:17 <joehh> building using nixos with a package overrides for enabling profiling
05:48:28 <merijn> no clue how Nix works, tbh :)
05:48:34 <joehh> BUT, looks like it has worked this time 
05:48:43 <joehh> left it alone for 6 hours
05:48:58 <joehh> I suspect the difference is I'm only using --enable-profiling
05:49:10 <joehh> rather than library and executable profiling
05:49:53 <merijn> quchen: Could you try this variation of the program with "stack repl"? http://lpaste.net/356672
05:50:16 <merijn> quchen: Also, does it support something like "-v0" to silence the "configuring packages" line?
05:51:11 <slack1256> if you built all your dependencies with profiling enabled (haskellPackages.override and friends) and you are building inside such environment (by nix-shell or nix-build the project) then you shouldn't have problems
05:51:29 <slack1256> also, cabal2nix is your friend
05:52:39 <quchen> http://lpaste.net/356673 merijn ‚Äì exit code 1 (one)
05:53:09 <merijn> hmm...that's odd
05:53:15 <merijn> oh...
05:53:17 <merijn> I'm dumb
05:53:44 <merijn> I should probably stip off the prefix :p
05:54:07 <quchen> merijn: Here is a funny idea, you could install Stack to test this! :-)
05:54:16 <joehh> slack1256: as far as I'm aware - that is what I've done
05:54:32 <merijn> quchen: I was overly optimistic about it working the 1st time :p
05:55:34 <merijn> quchen: I don't like installing things whose install method is "random shellscript from the interweb" :)
05:55:36 <joehh> using nix-shell with a shell.nix to pick up the enableLibraryProfiling = true
05:55:53 <yuhun> I'm new to haskell. Where do I start learning it?
05:56:04 <slack1256> joehnn: inside the environment, did you pass --library-profiling and --executable-profiling to cabal?
05:56:16 <slack1256> if so, could you upload a paste of the output?
05:56:21 <slack1256> @whereis lyah
05:56:22 <lambdabot> Maybe you meant: where+ where
05:56:24 <slack1256> @where lyah
05:56:25 <lambdabot> http://www.learnyouahaskell.com/
05:56:43 <slack1256> yuhun: I would start by that book. I did it and I liked a lot 
05:56:45 <joehh> I ran "cabal configure --enable-profiling --enable-library-profiling"
05:57:16 <yuhun> thanks, I'll
05:57:29 <slack1256> nice, then it should work. Could you show me the errors (if long, maybe in lpaste)?
05:57:36 <merijn> quchen: Actually, I have a machine with stack, but that's a windows box, so it still wouldn't work :p
05:58:51 <joehh> http://lpaste.net/2338657693226500096
05:59:01 <quchen> The trick is using an operating system
05:59:52 <joehh> mop-qa is a local library that mop-processor depends on
05:59:55 <merijn> quchen: People get cranky if you replace their OS and it's not my own machine ;)
06:00:58 <slack1256> joehh: inside the nix environment, are you launching maybe with nix-shell and the --pure option?
06:02:05 <joehh> not the pure option
06:02:42 <slack1256> with the normal haskellPackages environment, everything works?
06:02:52 <joehh> yes
06:03:16 <slack1256> are you comping anything else outside haskellPackages? maybe on the cabal sandbox ?
06:03:47 <joehh> this is my .config/nix/config.nix
06:03:48 <joehh> http://lpaste.net/2479846166032809984
06:03:55 <joehh> I don't think so
06:05:14 <joehh> pretty much just nix-shell -> cabal clean -> cabal configure (--enable-profiling --enable-library-profiling) -> cabal build
06:09:13 * hackagebot easytensor 0.3.0.0 ‚Äì Pure, type-indexed haskell vector, matrix, and tensor library. ‚Äì https://hackage.haskell.org/package/easytensor
06:09:13 * hackagebot dimensions 0.3.0.0 ‚Äì Safe type-level dimensionality for multidimensional data. ‚Äì https://hackage.haskell.org/package/dimensions
06:09:32 <joehh> so running with --pure, I get an error about cabal not being installed
06:10:05 <Franciman> Hello
06:10:08 <slack1256> on the config.nix, those modules that you redefined, do they depend on each others?
06:10:37 <Franciman> https://pastebin.com/TWq9dZHU I get this error when compiling with ghc. (I'm on arch linux and I installed ghc from pacman). How can I solve this?
06:10:40 <joehh> not sure exactly what you mean, but not in a circular manner
06:10:58 <joehh> ie mop-processor depends on mop-qa which depends on mop-rawlogs
06:11:11 <joehh> but no circular deps
06:11:37 <slack1256> yeah, I don't mean circularity at haskell level. I mean at nix callPackage level
06:12:42 <slack1256> if you override { A , B , C } on nix but B depends of C, at the moment of callPackaging B in the override, it will not get the new C that you overrode, you will link to the C that was before on the set
06:14:00 <duairc> If I have a header file with some CPP macros that I use througout a package, is there any way to "export" that header file so that it can be included by other Haskell packages?
06:14:02 <slack1256> I don't express myself correctly
06:14:58 <duairc> Or is there something like /usr/include but specifically for Haskell? Is there any way to configure global "include" dir(s) for cabal?
06:15:14 <slack1256> the thing is that, when you override B, it will depend on the old version of C on the set instead of the new one that you are putting. This is because it uses self.callPackage when maybe it should user super.callPackage
06:15:28 <joehh> ahhh
06:15:37 <trigone> quick poll: best library/method to handle command line argument parsing?
06:15:55 <slack1256> and that is probably why are you getting undefined symbols. 
06:15:56 <joehh> tyring that now
06:16:05 <quchen> optparse-applicative if you have anything beyond 5 flags, trigone 
06:16:12 <cocreature> trigone: optparse-applicative
06:16:15 <cocreature> even for 5 flags imho
06:16:19 <quchen> trigone: If it‚Äôs smaller, look at GetOpt in base
06:16:30 <merijn> optparse-applicative is <3
06:16:43 <slack1256> joehh: I don't know the dependencies between those projects, but I woold argue that it goes on that line
06:17:29 <slack1256> joehh: https://elvishjerricco.github.io/2017/04/01/nix-style-configs-in-haskell.html I understood this by this blogpost
06:17:33 <joehh> I suspect you are right - doing a clean rebuild now and feeling lucky :)
06:18:05 <slack1256> it explain the difference on the super and self parameter and the general problem
06:18:30 <joehh> hasn't work yet, but starting to read post - I reckon you are right, I just need to adjust my config to match
06:18:36 <joehh> thanks very much :)
06:19:09 <trigone> thanks all, optparse-appli seems perfect :)
06:19:46 <codedmart> Is it stupid to use a TVar inside of Reader?
06:20:29 <slack1256> codedmart: if it works...
06:20:36 <merijn> codedmart: It Depends (TM) :p
06:20:45 <merijn> codedmart: It doesn't sound a priori stupid
06:21:16 <MarcelineVQ> you did this
06:21:20 <codedmart> Fair enough. More of a general question right now.
06:21:30 <trigone> are we being spammed? or is there some server breakdown?
06:21:56 <hpc> this happened yesterday, matrix.org is just spotty
06:21:57 <amx> codedmart: https://www.fpcomplete.com/blog/2017/06/readert-design-pattern
06:22:02 <merijn> trigone: probably a netsplit if there's a large number of parts/joins, I usually hide them here
06:22:08 <trigone> hpc: spotty?
06:22:23 <MarcelineVQ> it's not all matrix, but whatever node matrix was using I guess
06:22:27 <trigone> merijn: i wish i could but apparently you can't on webchat.freenode.net
06:22:28 <ongy> going up and down. and if you have join/part visible it's a bit spammy
06:23:11 <codedmart> amx: Thanks I thought I saw that somewhere.
06:23:16 <codedmart> Couldn't remember
06:37:48 <Unhammer> can ghc error on incomplete-patterns (but warn on the rest of -Wall)?
06:39:54 <quchen> Unhammer: I don‚Äôt think it can, but 8.2 will be able to
06:40:08 <quchen> -Wall -Werror=incomplete-patterns
06:40:11 <quchen> Something like that
06:40:54 <tsahyt> should I expect any weirdness from building a monad stack with reactive-banana's MomentIO at the bottom? I need database access and I'm using persistent, so it'd be a few layers of readers and resourcet I think
06:41:25 <Unhammer> oh
06:41:32 <Unhammer> thanks quchen 
06:55:45 * hackagebot singnal 0.1.1.0 ‚Äì Singnal ‚Äì https://hackage.haskell.org/package/singnal
06:55:45 * hackagebot data-basic 0.2.0.2 ‚Äì A database library with a focus on ease of use, type safety and useful error‚Ä¶ ‚Äì https://hackage.haskell.org/package/data-basic
07:08:54 * hackagebot dlist 0.8.0.3 ‚Äì Difference lists ‚Äì https://hackage.haskell.org/package/dlist
07:18:00 * hackagebot data-basic 0.2.0.3 ‚Äì A database library with a focus on ease of use, type safety and useful error‚Ä¶ ‚Äì https://hackage.haskell.org/package/data-basic
07:19:59 <slack1256> how are ghc_worker threads different from normal Tasks?
07:23:38 <vaibhavsagar> how do I enter a nix-shell with test dependencies for a haskell project?
07:24:53 <slack1256> you need to put the test dependencies on the shell.nix file
07:26:29 <vaibhavsagar> so cabal2nix --shell will create the shell file?
07:27:09 <slack1256> yep, but read that file, check if all the dependencies are declared as needed
07:28:10 * hackagebot ngx-export 0.4.1.0 ‚Äì Helper module for Nginx haskell module ‚Äì https://hackage.haskell.org/package/ngx-export
07:28:36 <vaibhavsagar> that seems to work, thanks slack1256!
07:28:54 <vaibhavsagar> why doesn't cabal2nix generate a shell file by default?
07:29:06 <merijn> I forgot: Was there a memory issue when recursively calling some monad stack or was that just for stacks that didn't have IO as base?
07:29:40 <fosskers> hi all, quick question about phase control. If I have `{-# INLINE [2] foo #-}` and `{-# INLINE [0] bar #-}`, foo will be inlined _before_ bar? as in, phase number counts down to 0 from some N?
07:30:09 <fosskers> And this would give the correct inlining behaviour if say, foo were called inside bar?
07:30:22 <fosskers> thus foo would be "double inlined" per se?
07:30:28 <vaibhavsagar> based on the talk I watched today, yes it counts down fosskers
07:30:56 <fosskers> vaibhavsagar, do you know what N it counts down from?
07:30:57 <vaibhavsagar> not sure about your second question though
07:31:02 <vaibhavsagar> 3
07:31:09 <vaibhavsagar> phases are 3, 2, 1, 0
07:31:16 <fosskers> ah, cool
07:31:34 <vaibhavsagar> talk is at https://www.youtube.com/watch?v=KiWVuFQLHeE
07:31:44 <vaibhavsagar> excellent power to weight ratio with this one
07:32:01 <fosskers> oh excellent, I'm going to watch that right now
07:32:04 <quchen> fosskers: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#phase-control
07:32:21 <fosskers> quchen, yeah, I've read through that but still had questions. 
07:36:24 <quchen> Ah ok
07:39:11 <vaibhavsagar> fosskers: I could be wrong about the number of phases, but IIRC 4 is what I heard from the talk
07:44:08 <vaibhavsagar> according to http://ghc.readthedocs.io/en/8.0.2/using-optimisation.html the default is two, which means 3 simplifier phases
07:44:26 <vaibhavsagar> i.e. 2,1,0
07:45:42 <fosskers> so we can use those phase numbers to control nested inlining
07:46:11 <fosskers> like if I had foo and bar, where both foo and bar are used frequently, and foo is also called within bar
07:46:28 <fosskers> I should want to inline foo sooner, i.e. give it a higher phase number
08:12:31 <fosskers> vaibhavsagar, fantastic video
08:12:55 <vaibhavsagar> I agree :)
08:13:12 <vaibhavsagar> I want to put rewrite rules in all my things now :)
08:20:19 <bollu> vaibhavsagar what's the video?
08:21:09 <Sh4rPEYE> Hello. I'm having some difficulties using STRefs. COuld somebody help me?
08:21:39 <Sh4rPEYE> Teh code: http://lpaste.net/2608605591895015424
08:22:35 <Sh4rPEYE> I want to substitute the underscore. I tried runST $ runST . readSTRef <$> do ...
08:22:48 <Sh4rPEYE> But it didn't typecheck (surprisingly)
08:22:52 <Cale> Maybe replace the return with readSTRef a
08:23:06 <Sh4rPEYE> Oh, yeah. The exercise is set like this
08:23:12 <Sh4rPEYE> Forgot to mention that.
08:23:13 <Cale> oh, well, fine
08:24:39 <Sh4rPEYE> Oh well, it also might not be possible to do this. This code is what I got after some tinkering... If it's not possible, I have the var defined wrong
08:26:14 <monochrom> You can load that code into GHCi already. It will tell you the type needed for the blank.
08:26:47 <Sh4rPEYE> Yeah I know the type. That's how I came to runST $ runST . readSTRef <$> do. Didn't work anyway, though.
08:27:21 <monochrom> Two runST's? I doubt it.
08:27:24 <Cale> You can write runST . (readSTRef =<<)
08:27:25 <Sh4rPEYE> Saying: Couldn't match type ëST s Integerí with ëforall s1. ST s1 Integerí
08:27:25 <Sh4rPEYE>                      with ëforall s1. ST s1 Integer
08:27:26 <Cale> but it will fail
08:27:54 <Cale> Because the type variables in (.) can't be automatically instantiated with polymorphic types
08:28:21 <Cale> I suppose we might sidestep the problem by writing a lambda with an explicit higher rank type signature
08:29:28 <Sh4rPEYE> Oh, well... WHat about this?
08:29:29 <Sh4rPEYE> TheMostImperativeFunctionalLanguage.two
08:29:52 <Sh4rPEYE> Sorry. Look at the lpaste again.
08:30:10 <Sh4rPEYE> It's your version, just without chaining. ANd it typechcecks and works.
08:30:36 <Cale> ((\x -> runST (do r <- x; readSTRef r)) :: (forall s. ST s (STRef s a)) -> a)
08:30:44 <Cale> That will go in the hole and typecheck
08:31:44 * hackagebot fltkhs 0.5.3.4 ‚Äì FLTK bindings ‚Äì https://hackage.haskell.org/package/fltkhs
08:32:08 <Cale> If you're allowed to define something separately, moving the function to the top level would also help
08:32:37 <Cale> I don't really understand the point of this exercise, apart from being frustrating and unnatural.
08:33:07 <Sh4rPEYE> It's just a part of a bigger exerise. Implemeting imperative programming in HAskell.
08:33:42 <Sh4rPEYE> This is a piece which I use to test "var" and "def", two of the imerative constructs
08:38:58 <chase1> so i'm quite new to programming and want to get into web development but js just doesn't appeal to me at all. that led me to Elm, but now I'm seeing stuff like Miso for Haskell. 
08:39:15 <chase1> do you think learning haskell and it's ability to do web development is going to be too much for a beginner?
08:39:31 <chase1> is there a better beginner haskell channel for these questions?
08:41:33 <Tuplanolla> I don't know about better, but there is #haskell-beginners, chase1.
08:53:23 <Ferdirand>  /win 4
08:53:27 <Ferdirand> oops
08:54:27 * hackagebot teardown 0.1.0.1 ‚Äì Build composable, idempotent & transparent application cleanup sub-routines ‚Äì https://hackage.haskell.org/package/teardown
08:54:28 * hackagebot pg-store 0.4.3 ‚Äì Simple storage interface to PostgreSQL ‚Äì https://hackage.haskell.org/package/pg-store
09:01:46 <The_Kinaesthetic> Is it possible to get the result of an unfinished recursion?
09:01:51 <The_Kinaesthetic> Minus the function calling part?
09:09:17 <The_Kinaesthetic> YESSS
09:09:31 <The_Kinaesthetic> God bless if then statements
09:17:19 <tsahyt> When building a GUI application using FRP with a database backend (pretty much a CRUD application), what would be the best way to leverage FRP for keeping the data displayed in sync with the database? e.g. the user adds some data, some FRP happens and I can write it into the database and update the corresponding views, but that seems like just a fancy way to do event-driven programming. I'd rather have the
09:17:21 <tsahyt> data as a Behavior and the view taking stuff from said Behavior. what are my options here?
09:18:08 <jp_rider> f
09:22:38 <The_Kinaesthetic> Anyone here who was helping me with the function acting on a tree last night?
09:23:32 <The_Kinaesthetic> I figured out one way that will definitely work but it involves a recursion where a number gets incremented every time
09:23:34 <The_Kinaesthetic> http://lpaste.net/4813449116543614976
09:23:46 <The_Kinaesthetic> not sure how to actually do it
09:27:31 <freeside> happy to think it through with you, but you'd have to explain it to me from scratch
09:28:13 * freeside puts on the rubber duck costume
09:34:44 <The_Kinaesthetic> :freeside Let me know if anythings not clear
09:34:45 <The_Kinaesthetic> http://lpaste.net/933481055539691520
09:37:18 <The_Kinaesthetic> "twist" is just an example tree for testing
09:38:41 * hackagebot cabal-debian 4.35.8 ‚Äì Create a Debianization for a Cabal package ‚Äì https://hackage.haskell.org/package/cabal-debian
09:41:10 <The_Kinaesthetic> :freeside Here, this picture might help (hopefully you can view...) https://awwapp.com/s/65eb9ef4-899e-4428-98cc-8b497b32df1f/
10:02:11 <freeside> The_Kinaesthetic: lol ok
10:03:14 <freeside> love the drawing
10:03:58 <unclechu> hey guys, is there a tutorial about how to write haskell shared library using cabal?
10:04:46 <freeside> have you looked at https://www.haskell.org/cabal/users-guide/installing-packages.html?
10:04:58 <Tuplanolla> As an aside you might want to start writing spaces after comment tokens, The_Kinaesthetic.
10:06:07 <freeside> oops dinner brb
10:06:27 <dmwit> ?tell wrengr Yeah, my email didn't go through. You should tell me a better place to send logfloat patches. =)
10:06:27 <lambdabot> Consider it noted.
10:06:34 <Tuplanolla> > let this --* not = a comment in here
10:06:36 <lambdabot>  error:
10:06:36 <lambdabot>      Ambiguous occurrence ‚Äòa‚Äô
10:06:36 <lambdabot>      It could refer to either ‚ÄòDebug.SimpleReflect.a‚Äô,
10:06:46 <Tuplanolla> > let this --* not = L.a comment in here
10:06:48 <lambdabot>  ()
10:09:55 <dmwit> "let this not be a comment in here"
10:10:03 <dmwit> GHC: I gotchu fam
10:12:23 <DearlyBeloved> is there any good reading on haskell's connection/allusions to mathematics?
10:13:04 <dmwit> Yes, plenty, and you should probably focus the question to some points of interest to you.
10:13:55 <dmwit> e.g. the Curry-Howard isomorphism is one direction to go; the abstract algebra concepts we make into typeclasses is another; using type theory as a basis for doing mathematics is another; computability and lambda calculus is yet another...
10:16:12 <The_Kinaesthetic> :freeside What do you think?
10:16:19 <The_Kinaesthetic> Or anyone really
10:16:34 <The_Kinaesthetic> This has been killing me. I've amassed over 5 hours on this already.
10:16:48 <dmwit> You put your colons in a funny place. =)
10:16:51 <dmwit> What is "this"?
10:17:40 <dmwit> (Also: five hours isn't a terribly big number for programming projects. So don't lose hope just from that.)
10:27:27 <The_Kinaesthetic> I know but it's such a simple function
10:27:32 <The_Kinaesthetic> I haven't even gotten to parsing yet
10:27:40 <The_Kinaesthetic> which is my ultimate goal
10:28:25 <dmwit> I'd be happy to help. But you're going to have to send along a few details. The usual format is "I tried X, expecting Y, but got Z instead.". If there's code, include it, but not in-channel; e.g. lpaste.net is a good place for that.
10:29:43 <The_Kinaesthetic> Do you have the log? I posted a lot above
10:29:46 <The_Kinaesthetic> Or I can just repost
10:30:05 <The_Kinaesthetic> here: http://lpaste.net/933481055539691520
10:30:11 <The_Kinaesthetic> https://awwapp.com/s/65eb9ef4-899e-4428-98cc-8b497b32df1f/
10:30:47 <The_Kinaesthetic> Explanations are in the comments. Pls ask questions for clarification if needed.
10:31:02 <The_Kinaesthetic> The picture is the visual understanding of what I'm trying to get
10:32:10 <The_Kinaesthetic> I tried many things already. But to be quite honest I've forgotten most of it now. It was all in the late am last night.
10:32:20 <dmwit> What is the type of position?
10:32:31 <The_Kinaesthetic> Ratio
10:32:35 <dmwit> no
10:32:48 <The_Kinaesthetic> no?
10:33:02 <geekosaur> Ratio is an incomplete type
10:33:06 <geekosaur> did you mean Rational?
10:33:12 <dmwit> I mean... it at least has to have a function type if you plan on taking arguments. And `Ratio` isn't a good type (perhaps you meant `Rational` or `Ratio Integer`?).
10:33:14 <geekosaur> (== Ratio Integer)
10:33:24 <The_Kinaesthetic> O you mean the function "position"
10:33:30 <The_Kinaesthetic> It's not complete at all
10:33:42 <dmwit> What is the *intended* type?
10:34:01 <The_Kinaesthetic> so I'm not entirely sure yet but something like position :: Tree a -> [Int] -> Rational (or whatever)
10:34:22 <dmwit> Okay. Then here's my question, based on your drawing: why is the `Tree a` argument needed at all?
10:34:59 <dmwit> Ah, no, I understand that. Okay, now let me read the code you have so far for `position`.
10:35:27 <The_Kinaesthetic> the code I have written there is not actual code btw
10:35:57 <The_Kinaesthetic> I sort of wrote out my thoughts of what should happen, and I'm pretty sure that series would work if I could implement it
10:36:31 <The_Kinaesthetic> I'm just stuck on the increment part since !! and "take" both take an incremented number for every new recursion
10:37:03 <dmwit> Okay, so I think it's worth talking about two things: 1. how to implement the algorithm you have in mind 2. how to implement the function more directly (and consequently more efficiently).
10:37:09 <dmwit> Let's start with 1 first.
10:37:16 <dmwit> Are you familiar with `where` blocks?
10:38:01 <The_Kinaesthetic> yes but perhaps not familiar enough. My understanding is that it allows you to assign a variable to something that gets repeated multiple times
10:38:46 <dmwit> I'm not sure about that "repeated multiple times" part. But yes, it lets you make local definitions.
10:39:02 <dmwit> Okay, so here would be my plan:
10:39:17 <dmwit> You can use `inits` (from `Data.List`) to get successively longer chunks of a list.
10:39:21 <dmwit> > inits [1..5]
10:39:24 <lambdabot>  [[],[1],[1,2],[1,2,3],[1,2,3,4],[1,2,3,4,5]]
10:39:32 <dmwit> > inits "abcde"
10:39:34 <lambdabot>  ["","a","ab","abc","abcd","abcde"]
10:40:11 <dmwit> This will give you the `take 1 y`, `take 2 y`, `take 3 y`, etc.
10:40:26 <eacameron> Does GHC support compiling source trees that have symlinks?
10:40:43 <eacameron> I'd like to do a quick-n-dirty sharing of a source file between projects.
10:40:56 <dmwit> eacameron: I feel like it would have to do actual work not to support that. So I'm going to guess "yes" without even testing or knowing the answer.
10:41:10 <The_Kinaesthetic> :dmwit but then I would still have to use !! on that list itself and increment
10:41:32 <The_Kinaesthetic> o wait, maybe I can actually pattern match on that new list
10:41:38 <dmwit> The_Kinaesthetic: Nah, just walk over the list with the usual recursion+pattern matching.
10:41:47 <The_Kinaesthetic> aha
10:41:56 <The_Kinaesthetic> but where do I put this new list? In a where statement?
10:42:07 <dmwit> `walk [] = ...; walk (beginning:beginnings) = ...`
10:42:10 <dmwit> The_Kinaesthetic: Right.
10:42:26 <Welkin> The_Kinaesthetic: there are no statements, only expressions
10:42:27 <The_Kinaesthetic> ok thanks give me a sec
10:43:27 * hackagebot fast-tagsoup 1.0.14 ‚Äì Fast parsing and extracting information from (possibly malformed) HTML/XML‚Ä¶ ‚Äì https://hackage.haskell.org/package/fast-tagsoup
10:43:31 <The_Kinaesthetic> :Welkin I don't know what the difference is sorry
10:43:41 <The_Kinaesthetic> I just started all this crap a month ago. 
10:43:58 <The_Kinaesthetic> actually more like two months if you include all the videos I watched on haskell
10:43:59 <dmwit> uh
10:44:05 <dmwit> Most of us in here don't think Haskell is crap. =)
10:44:08 <eacameron> dmwit: Ok I thought it didn't work, but forgot that the module name would need to be the same in both places so I need the same folder structure
10:44:13 <The_Kinaesthetic> lmao 
10:46:22 <eacameron> dmwit: Sure enough. If you do it right, it works. ;)
10:46:53 <dmwit> =)
10:48:47 <maerwald> The_Kinaesthetic: haskell has a difficult learning curve yeah. And don't get confuse of the occasional terminology nitpicking in this channel. It sometimes leads to new insights.
10:53:18 <The_Kinaesthetic> i didn't find it too difficult
10:53:30 <The_Kinaesthetic> :dmwit I don't think the inits thing is on the right track
10:53:59 <The_Kinaesthetic> I don't need [1,2,3] from [1,2,3,4] I need [0,1,1] from perhaps [0,1,1,0]
10:54:07 <The_Kinaesthetic> ugh
10:55:41 <The_Kinaesthetic> :maerwald I mean I feel like for a month the amount I've learned seems like a lot. I feel quite comfortable with pattern matching, guards, let, where, lambdas, making types.
10:55:59 <The_Kinaesthetic> Last programming language I began learning was 3 years ago, c++
10:56:23 <The_Kinaesthetic> took me like 3 months but I wasn't near the kind of comfortability I feel with haskell
10:57:02 <Welkin> The_Kinaesthetic: I don't think anyone is comfortable with c++...
10:59:01 <The_Kinaesthetic> lmao
10:59:15 <dmwit> I honestly don't know what to do with "I don't need [1,2,3] from [1,2,3,4] I need [0,1,1] from perhaps [0,1,1,0]".
10:59:30 <maerwald> Welkin: ed writes C++ these days, so I heard...I'm sure he's comfortable with it ;)
10:59:39 <dmwit> > inits [0,1,1,0] -- tada
10:59:41 <lambdabot>  [[],[0],[0,1],[0,1,1],[0,1,1,0]]
10:59:53 <The_Kinaesthetic> o
10:59:54 <The_Kinaesthetic> lmao
11:00:16 <dmwit> I'm not sure Ed gets comfortable with any language. More like he warps it around his comfort zone.
11:00:22 <The_Kinaesthetic> would it not be cleaner to perhaps do a patternmatched where expression with [1..] and then use that variable for both the take and !!
11:00:40 <dmwit> Code he writes isn't necessarily recognizable as the language he wrote it in.
11:00:50 <maerwald> dmwit: hahaha
11:01:21 <Welkin> likw writing javascript as a kind of weird scheme
11:01:30 <dmwit> The_Kinaesthetic: Well, if you want to jump straight to the clean way, you're going to have to scrap everything and start over with a new idea. Which I'm happy to talk about. But first you should get it working, *then* get it clean.
11:01:45 <Welkin> the Clean way?
11:01:56 <Welkin> you're in the wrong channel then
11:02:15 <The_Kinaesthetic> why would I have to start with a new idea
11:02:42 <The_Kinaesthetic> btw the thing I tried didn't seem to work. how would I get the tail of the [1..] for the later recursions?
11:02:59 <The_Kinaesthetic> I was thinking doing something like -- where (inc:incs) = [1..]
11:03:20 <dmwit> The_Kinaesthetic: As above, write a function like `walk [] = ...; walk (inc:incs) = ...`. Then call it.
11:03:54 <The_Kinaesthetic> I don't understand
11:03:59 <dmwit> The reason I suggest starting over is because your current approach is going to result in recalculating a lot of things repeatedly; even calling `inits` itself is usually a bad sign because of how much it recalculates.
11:04:02 <The_Kinaesthetic> wouldn't the function return the end result right away?
11:04:32 <dmwit> You say that like returning the end result would be a bad thing. Isn't that the goal?
11:04:34 <The_Kinaesthetic> :dmwit well I've tried many approaches, I thought you meant scrap everything including my tree etc.
11:04:46 <The_Kinaesthetic> I'm willing to approach this specific function a different way
11:05:46 * hackagebot cabal-debian 4.35.9 ‚Äì Create a Debianization for a Cabal package ‚Äì https://hackage.haskell.org/package/cabal-debian
11:05:50 <dmwit> I'm happy to follow your lead on this, but I would stress again that I recommend first getting it working, *then* getting it clean.
11:06:03 <The_Kinaesthetic> ok well let's get back to the walk thing
11:06:12 <The_Kinaesthetic> I don't see how that helps at all but I'm sure I just don't understand
11:06:33 <freeside> premature tidying up is the root of all evil!
11:06:36 <dmwit> Well, you want to do some processing on each element in a list, right?
11:06:46 <The_Kinaesthetic> yes
11:06:55 <maerwald> freeside: I feel it's more temtping in haskell than anywhere else
11:07:02 <dmwit> Okay. So, the standard way you do that is to write a function which looks at each element of the list and does your processing.
11:07:11 <dmwit> I'm not sure I can make the idea more basic than that.
11:07:39 <The_Kinaesthetic> but I have two lists that need to work in tandem
11:07:49 <freeside> if pretweeting is the evil version of retweeting, because you didn't actually read the original article, the prefactoring is the evil version of refactoring
11:07:57 <The_Kinaesthetic> so if I try to make a function to work on one list I would need each step along the way to put into the other one
11:08:09 <dmwit> That's also possible. But I don't agree that you have two lists.
11:08:19 <freeside> there is only one list in the world, but she wears many faces.
11:08:29 <dmwit> You have one list: `inits y` (or whatever you called the list of indices into the tree, I think it was `y`).
11:08:34 <geekosaur> also, two lists can become one list with a (lazy) zip :p
11:09:03 <freeside> what was the initial problem statement again?
11:09:40 <The_Kinaesthetic> :dmwit yes, I'll call it inst for instructions, I need to access that same list by using !! in one case and either take or inits inst in the other
11:09:46 <The_Kinaesthetic> but they need to be on the same step
11:09:46 <dmwit> freeside: lpaste.net/933481055539691520
11:09:51 <dmwit> freeside: There's a drawing, too, one moment
11:10:16 <dmwit> freeside: awwapp.com/s/65eb9ef4-899e-4428-98cc-8b497b32df1f
11:10:24 <geekosaur> also, as a general rule, if you are using (!!) you should consider if you are using the right data type
11:10:46 <geekosaur> Haskell lists are cons-lists, that is, singly-linked lists. they are not vectors or arrays
11:10:46 <The_Kinaesthetic> yes I think I am, it's Int acting on [Int]
11:11:06 <The_Kinaesthetic> yup
11:11:06 <dmwit> The_Kinaesthetic: No, you should not need `take` or `(!!)`. Once you have called `inits`, you already have a list of prefixes of the list; you just need to walk the list.
11:11:10 <geekosaur> indexing is O(n)
11:11:22 <maerwald> geekosaur: well, sometimes the performance implications are not obvious, even if you use !!. Lists might still be faster than vectors
11:11:31 <maerwald> (for the given program context)
11:11:43 <freeside> i'm still not sure what the problem definition actually is here
11:11:45 <dmwit> geekosaur: Yes, there is a much cleaner way to do what he's doing. But it involves a new concept (accumulators) and I thought it would be good to start with getting the implementation of his idea done before hacking on a completely new approach.
11:12:07 <maerwald> reasoning about performance is not very nice in haskell
11:12:30 <The_Kinaesthetic> :dmwit If I have [[],[0],[0,1],[0,1,1],[0,1,1,0]], for the top part of my ratio I would need first 0, then 1, then 1, then 0
11:12:33 <The_Kinaesthetic> that's !!
11:12:43 <The_Kinaesthetic> but on the original inst
11:13:20 <dmwit> > map last [[0], [0,1], [0,1,1], [0,1,1,0]]
11:13:22 <lambdabot>  [0,1,1,0]
11:13:32 <dmwit> The_Kinaesthetic: You want `last`, not `(!!)`.
11:13:51 <dmwit> Like, you want `last` on the current element, not `(!!)` on the original list.
11:14:06 <The_Kinaesthetic> > last [0,1]
11:14:08 <lambdabot>  1
11:14:16 <The_Kinaesthetic> ok 
11:14:20 <The_Kinaesthetic> let me try
11:15:20 * hackagebot safe-exceptions 0.1.6.0 ‚Äì Safe, consistent, and easy exception handling ‚Äì https://hackage.haskell.org/package/safe-exceptions
11:16:48 <The_Kinaesthetic> >inits [0,1,1,0]
11:16:59 <dmwit> needs another space =)
11:16:59 <The_Kinaesthetic> > inits [0,1,1,0]
11:17:01 <lambdabot>  [[],[0],[0,1],[0,1,1],[0,1,1,0]]
11:17:12 <The_Kinaesthetic> doesnt' that empty list screw things up?
11:17:32 <dmwit> Think. I'm sure you can work out a solution without me.
11:17:57 <The_Kinaesthetic> I can lmao just use tail, but I feel like I'm just adding more and more things in here to fix everything
11:17:57 <The_Kinaesthetic> lol
11:19:45 <boojinks> fix everything... or develop a solution ;)
11:20:09 <The_Kinaesthetic> I'm stuck again
11:20:21 <The_Kinaesthetic> how do I bring the inits list into the next recursion?
11:20:28 <The_Kinaesthetic> position (B x) inst = (last cur % posLength x cur) + position x inst                     where (cur:end) = tail (inits inst)
11:22:17 <Welkin> > inits <$> tails [0,1,1,0]
11:22:20 <lambdabot>  [[[],[0],[0,1],[0,1,1],[0,1,1,0]],[[],[1],[1,1],[1,1,0]],[[],[1],[1,0]],[[],...
11:22:24 <Welkin> lol
11:22:54 <Welkin> > tail $ inits [0,1,1,0]
11:22:56 <lambdabot>  [[0],[0,1],[0,1,1],[0,1,1,0]]
11:23:29 <The_Kinaesthetic> o
11:23:35 <The_Kinaesthetic> i can use tail of inst?
11:25:33 <dmwit> The_Kinaesthetic: As I said above, at least twice now: write a function that recurses over the list, then call it.
11:25:56 <dmwit> Pattern matching on `inits inst` will not recurse over the list; it will operate only once.
11:28:50 <The_Kinaesthetic> I guess I just don't understand :(
11:30:00 <The_Kinaesthetic> wouldn't position being called again generate a new where?
11:30:04 <The_Kinaesthetic> is that the problem
11:30:04 <The_Kinaesthetic> ?
11:30:22 <The_Kinaesthetic> If that's the case then what I'm doing makes sense to me, if not then it's fruitless
11:30:28 <dmwit> I don't recommend recursing on position. I recommend recursing in a second function written to walk over `inits inst`.
11:30:56 <The_Kinaesthetic> I don't understand
11:31:04 <The_Kinaesthetic> what do you mean walk over "inits inst"
11:32:23 <The_Kinaesthetic> If I do a second function, it must return a single value, then how am I supposed to put that back into the position function which is gonna make an arbitrary sum
11:32:47 <dmwit> Have the second function return the sum.
11:32:59 <The_Kinaesthetic> but the sum is recursively defined
11:33:07 <dmwit> Yes. And the second function is recursively defined.
11:33:09 <dmwit> So no problem.
11:33:37 <The_Kinaesthetic> Yeah I'm lost. I have no idea what the second function would even look like
11:33:54 <dmwit> I posted an actual code template at least twice now.
11:34:26 <The_Kinaesthetic>  `walk [] = ...; walk (beginning:beginnings) = ...` ?
11:34:33 <dmwit> I think at this point it might be time for me to step aside. I've used up my good pedagogical ideas; reiterating them is likely to merely frustrate us both further.
11:34:36 <dmwit> The_Kinaesthetic: yes
11:34:45 <The_Kinaesthetic> I'm not frustrated don't worry
11:34:50 <The_Kinaesthetic> I appreciate this very much
11:35:00 <The_Kinaesthetic> If you're frustrated then yes, you can leave me be for a while
11:35:11 <boojinks> what're we looking at?
11:35:20 <The_Kinaesthetic> :dmwit Yeah I don't know what goes in "..."
11:35:29 <The_Kinaesthetic> like what is walk even supposed to do
11:36:06 <dmwit> walk is supposed to look at each element of `inits y` and compute a term of the sum using `last` and `posLength`.
11:36:33 <dmwit> boojinks: I'd like the two reference materials, but copy-and-paste appears to be broken for me right now for some reason.
11:36:34 <The_Kinaesthetic> so walk would need the tree and inst too?
11:37:00 <dmwit> It would need the tree (which is no problem, since you're defining it in a `where` block in `position`), but shouldn't need `inst`.
11:37:23 <The_Kinaesthetic> woah, I'm defining walk in a where block?
11:37:26 <The_Kinaesthetic> ok
11:37:29 <The_Kinaesthetic> that changes things
11:37:48 <dmwit> Uh, well. I mean, that's up to you, I guess. You could also pass the whole tree as an argument and define it outside the block.
11:38:09 <dmwit> It shouldn't be, like, an earth-shattering change one way or another.
11:38:37 <The_Kinaesthetic> ok
11:39:17 <dmwit> boojinks: http://lpaste.net/933481055539691520 and https://awwapp.com/s/65eb9ef4-899e-4428-98cc-8b497b32df1f/
11:39:23 <The_Kinaesthetic> you said walk wouldn't need inst but how could that be if I need to take inits inst and do stuff with it?
11:39:41 <The_Kinaesthetic> inst is the same thing as my original "y" btw
11:39:53 <dmwit> You're going to pass `inits inst` as an argument. So it's going to have all the information it needs about `inst` already.
11:41:03 <The_Kinaesthetic> I feel bad saying "I don't understand" at this point
11:41:08 <The_Kinaesthetic> sorry
11:41:44 <dmwit> Perhaps it would be sensible to start with some simpler functions.
11:41:53 <dmwit> Have you implemented `sum :: Num a => [a] -> a` before?
11:41:59 <The_Kinaesthetic> so I have to do something like `where lst = inits inst; (cur:end) = ...`
11:42:01 <The_Kinaesthetic> ?
11:42:31 <The_Kinaesthetic> :dmwit that was my plan if this whole where expression thing worked out
11:43:15 <dmwit> Why don't you start there? It might also be worth trying to reimplement `map`.
11:43:30 <dmwit> These functions are simple, self-contained, and good tutorials for how to walk over lists.
11:43:35 <XorSwap> is there a O(1) way to permute a list according to another list besides a hash table?
11:44:25 <The_Kinaesthetic> o I meant `walk (cur:end)` in that example
11:44:26 <dmwit> XorSwap: If by "list" you mean an actual `[a]`, I don't think there's an O(1) way to do anything that uses the whole list, even with a hash table.
11:44:27 <Welkin> XorSwap: permute?
11:45:10 <XorSwap> well, hash tables are usually considered 'close enough' right?
11:45:13 <The_Kinaesthetic> AHA
11:45:25 <The_Kinaesthetic> :dmwit I think it all just clicked, thanks. i'm going to try now
11:45:47 <dmwit> Good luck! I hope you're right. =)
11:45:53 <slack1256> what does determine the number of worker threads on a program?
11:46:12 <XorSwap> Welkin: one list of data, another list of indexes to move the data to, so permuting by [0,1,2,3] would be the identity, [3,2,1,0] would reverse
11:46:22 <dmwit> slack1256: The pool starts with a number determined by `+RTS -N`. Threads can be added by FFI calls.
11:46:43 <slack1256> +RTS -N is the number of capabilities, not Tasks
11:47:24 <dmwit> Okay. Then I don't understand your jargon well enough to answer. Can you unpack a few words for us? What do you mean by "worker threads" and "tasks"?
11:48:13 <dmwit> XorSwap: Even if I grant the common simplifying assumption about hash tables, I believe my previous claim stands.
11:48:30 <Sh4rPEYE> Ok, I've summarized my questions about STRefs. It is here: http://lpaste.net/2608605591895015424
11:48:58 <Sh4rPEYE> This is the closest I've ever got. Getting some weird typechecking errors.
11:49:35 <slack1256> Tasks are a thin wrapper on rts/Task.c of OS threads. They are identified by thread local storage. Capabilities are Haskell Execution Contexts implemented on rts/Capabilities.c , and the struct that are Tasks hold certain Capabilities
11:50:02 <dmwit> Sh4rPEYE: I don't think `lit` and `var` *can* return the same type. Presumably `lit 1 += lit 2` shouldn't even type-check.
11:50:09 <XorSwap> oh shoot, I mistyped, I meant O(n)
11:50:19 <XorSwap> O(1) for each item
11:50:21 <slack1256> There are certain tasks which are called "worker tasks", which are those that don't come from C-land calling for haskell
11:50:52 <The_Kinaesthetic> :dmwit I have to do w:ws even if I don't use ws right?
11:50:55 <slack1256> I asked myself if the number of capabilities has some relation with the number of worker thread a process has
11:51:10 <Sh4rPEYE> <dmwit: One returns ST s VAr and the other just Var. Is it too same?
11:51:12 <The_Kinaesthetic> nvm stupid question
11:51:15 <dmwit> The_Kinaesthetic: The usual idiom for ignoring part of a pattern is to use `_`, as in `w:_`.
11:51:17 <Sh4rPEYE> WHat could the "lit" mean?
11:51:26 <The_Kinaesthetic> :dmwit yes thanks
11:51:36 <slack1256> that is not the case, because taffybar is -threaded on my pc, and running with -N1 lauches 4 ghc_worker thread as seen by 'ps -T -C taffybar'
11:52:51 <dmwit> Programs can also set the number of capabilities with `setNumCapabilities`. Is it possible this is happening?
11:53:40 <dmwit> Sh4rPEYE: How about `(+=) :: Var s -> ST s Integer -> ST s ()`, and writing `a += read b` instead of `a += b`?
11:53:48 <dmwit> Sh4rPEYE: Then `lit = return` would work fine.
11:54:07 <dmwit> Sh4rPEYE: Think of it a bit like `a += *b;` in C -- you need to dereference.
11:54:25 <slack1256> is possible, but it isn't happening in this case (for example in taffybar)
11:54:55 <slack1256> basically, I don't understand the N:M relationship between the OS threads and the HEC (haskell execution centers)
11:55:02 <dmwit> Sh4rPEYE: Alternately, make `(+=)` part of a type class.
11:55:02 <Sh4rPEYE> dmwit: Seems reasonable. Could you elaborate a little bit on why this particular solution came to your mind?
11:56:29 <dmwit> Sh4rPEYE: Well. "References as a pair of read- and write- ends" has been a meme living in me for quite some time. I noticed that `lit 1` would be kind of like a reference, except that it had no "write" end.
11:56:54 <dmwit> Sh4rPEYE: So I thought about what just having the "read" end of a reference might look like. Answer: `ST s Integer`.
11:58:15 <dmwit> But after reading the kata, I suspect the typeclass idea is the one the kata has in mind.
12:01:34 <dmwit> Sh4rPEYE: (I suspect it was monochrom that planted this meme in my head. At some point he had suggested using `IO ((IO (), IO ()))` instead of `IO (MVar ())` for some synchronization task I had, and pondering what he could have meant opened my eyes.)
12:02:59 <dmwit> slack1256: So, I understand your jargon now -- enough to know I don't know the answer to your question. I, too, believed that to begin with there was one OS thread per capability.
12:03:27 <dmwit> slack1256: I do know that extra OS threads can be added to the pool for FFI calls; and presumably taffybar is doing some X interactions somewhere. Perhaps this explains the extra OS threads.
12:03:48 <mstruebing> anyone know why this is happening?
12:03:50 <mstruebing> http://lpaste.net/356677
12:03:59 <dmwit> Are you on Gentoo?
12:04:35 <dmwit> Sorry, I meant, are you on Arch?
12:04:59 <dmwit> https://bugs.archlinux.org/task/54561
12:05:17 <mstruebing> yep on arch, thx
12:05:25 <Sh4rPEYE> dmwit: If I went the typeclass way, how wuould I do that?
12:05:35 <dmwit> ?where+ arch-ld-bug https://bugs.archlinux.org/task/54561
12:05:35 <lambdabot> Good to know.
12:06:38 <mstruebing> dynamic is working \o/
12:07:05 <dmwit> Sh4rPEYE: Something like `class RHS a where read :: a -> ST s Integer`, then `(+=) :: RHS a => Var -> a -> ST s ()`. Some modifications to handle the `s` in `ST` might be needed.
12:07:43 <dmwit> Sh4rPEYE: Then you would have an instance of `RHS` for variables and for literals.
12:07:44 <slack1256> dmwit: yeah, you are right the pool and FFI.
12:08:03 <Sh4rPEYE> The thing is? I can't add the "read" to the four-block
12:08:09 <alios> hi any freebsd (>=10) users here? could you reproduce this issue (linker problems with devel/stack installed ghc-8.0.2 on certain packages) https://github.com/commercialhaskell/stack/issues/3244  
12:08:12 <slack1256> anyways thank for you time. I also sent a message to -cafe to see if somebody has something to say :-)
12:08:13 <Sh4rPEYE> It must stay as-is
12:08:38 <dmwit> Sh4rPEYE: Yes. This is why I suspect they intended you to use this typeclass approach; it would not require any changes to the definitions of `factorial` or `four`.
12:09:34 <EvanR> monochrom: what are the AOL keywords to find your free monad inspired model of IO
12:11:56 <dhtns> How do I write the function `f` in a nicer way? http://lpaste.net/356678
12:12:24 <dhtns> (ah yes, there's still a type error, ignore that please)
12:12:59 <EvanR> with do notation, possibly
12:13:20 <EvanR> or with nested cases
12:13:45 <ongy> I like the version in the paste more than nested. And I'm unsure how you'd do it with do notation
12:14:04 <EvanR> the pattern here wouldnt be Maybe's usual monad instance
12:14:24 <EvanR> it would reverse the effect so any Just ends the show
12:15:19 <Sh4rPEYE> WHat about two fromJusts?
12:15:20 <EvanR> er maybe thats not a monad at all, unlike reversing Either e a
12:15:22 <XorSwap> would this work? http://lpaste.net/4964001030372065280
12:15:30 <ongy> Alternative and fromMaybe could also do it. But I don't think that's nicer or more readable than the case-of there
12:16:08 <dhtns> XorSwap: hey, does that syntax actually work?
12:16:14 <XorSwap> no clue
12:16:34 <XorSwap> I'm pretty sure there's something that works like that
12:17:07 <dhtns> I think that version errors when the "Just x" pattern doesn't match
12:17:08 <XorSwap> https://wiki.haskell.org/Pattern_guard
12:17:53 <dhtns> hmmm, kay
12:18:29 <EvanR> i usually dont like case on a tuple to check separate things
12:18:43 <Sh4rPEYE> Wouldn't somehithingOne possibility would be: maybe (maybe (somethingElseEntirely) (g2 xs) somethingElse) (g1 xs) something
12:19:02 <dhtns> Sh4rPEYE: I'd rather have nested cases than nested maybes though.
12:19:07 <EvanR> thats lisp kind of unreadable
12:19:20 <Sh4rPEYE> Sure. Just a possibility :-D
12:19:23 <EvanR> and fromJust is bad mmkay
12:19:53 <Sh4rPEYE> That was a mistake. I meant maybe
12:21:30 <EvanR> you could break it up into several equations, possibly in a where, but it would require naming them
12:22:34 <dhtns> I noticed I can make the problem a little simpler: http://lpaste.net/356679
12:23:21 <EvanR> http://lpaste.net/356680
12:23:56 <The_Kinaesthetic> :dmwit Nothings working :(
12:24:04 <EvanR> ah
12:24:14 <Gurkenglas> dhtns, case mapMaybe ($xs) of x:_ -> something x; [] -> somethingElseEntirely
12:24:15 <EvanR> dhtns: so case g1 xs >> g2 xs of ?
12:24:29 <Gurkenglas> *mapMaybe ($xs) [g1, g2]
12:25:28 <dhtns> EvanR: won't that discard the result of g1 xs?
12:25:46 <dhtns> Gurkenglas: that would work, but it's rather obscure
12:25:46 <EvanR> http://lpaste.net/356680
12:25:49 <Gurkenglas> dhtns, \xs -> maybe somethingElseEntirely something $ asum $ map ($xs) [g1, g2]
12:26:04 <EvanR> oh... different monad yet again
12:26:26 <EvanR> > First Nothing >> First Nothing >> First (Just 3)
12:26:28 <lambdabot>  First {getFirst = Nothing}
12:27:10 <Gurkenglas> dhtns, or to adjust it to the form you gave: http://lpaste.net/356679#a1532821120103743488
12:28:02 <EvanR> > Last Nothing >> Last Nothing >> Last (Just 3)
12:28:04 <lambdabot>  Last {getLast = Nothing}
12:28:08 <EvanR> what the hell
12:28:26 <Sh4rPEYE> dmwit: Will the datastructures be like this?
12:28:28 <Sh4rPEYE> data Variable s = Var (STRef s Integer)
12:28:36 <dhtns> Gurkenglas: yeah, that's quite nice already :)
12:28:40 <Gurkenglas> dhtns, or you could do "case g1 xs <|> g2 xs of"
12:28:58 <dhtns> What's "<|>"?
12:29:02 <Sh4rPEYE> data Literal = Lit (ST s Integer)
12:29:08 <hpc> @hoogle (<|>)
12:29:09 <lambdabot> Control.Applicative (<|>) :: Alternative f => f a -> f a -> f a
12:29:09 <lambdabot> Text.Parsec (<|>) :: (ParsecT s u m a) -> (ParsecT s u m a) -> (ParsecT s u m a)
12:29:09 <lambdabot> Text.Parsec.Prim (<|>) :: (ParsecT s u m a) -> (ParsecT s u m a) -> (ParsecT s u m a)
12:29:15 <Gurkenglas> dhtns, foldr (<|>) empty == asum
12:29:16 <hpc> it comes from Alternative
12:29:18 <EvanR> :t (<|>)
12:29:19 <lambdabot> Alternative f => f a -> f a -> f a
12:29:37 <EvanR> yes i meant <|>
12:29:47 <Gurkenglas> I simply wrote out asum's definition because I predicted it would lower your obscurity alarms
12:29:57 <dhtns> Wooooow kay, that is awesome :p
12:30:29 <EvanR> so i was odd, you want Alernative (a monoid) not monads
12:30:32 <EvanR> off*
12:33:46 <johnw> to continue my golfing question from yesterday (https://github.com/jwiegley/category-theory/blob/master/Theory/Metacategory/ObjectsArrows.hs), I reduced the runtime for computing the length of a 100 object category down from "takes too long to complete" to 0.035s.  I still wonder, though, why profiling says that it allocates (yet does not retain) 25G of memory over the coures of computing for 1000 objects...
12:34:28 <johnw> here's what the profile looks like: https://gist.github.com/405824df1cf225b29fbcf7ab32321bf8
12:34:38 <johnw> it only takes 4.3s to run, which is fine, I'm just curious about the memory use
12:34:56 <johnw> oh, wait, the total alloc is much smaller now
12:35:07 <johnw> still 26M, when I'd expect fusion to reduce that to almost nothing
12:35:27 <johnw> those results are the 100 object run, n/m
12:35:41 <johnw> https://gist.github.com/c8ef21c0a6dbce3fb048926115c3b92e
12:36:08 <johnw> i've found that adding bang patterns or INLINE directives in most other places can significantly reduce performance
12:36:21 <johnw> just making "go" inline within composablePairs doubles the runtime
12:36:44 * slack1256 proposes (.) f g = f `seq` g `seq` \x -> f (g x) as the one an only composition operator for haskell
12:37:03 <johnw> what does seq on functions do?
12:37:10 <slack1256> we have regained eta-expansion folks!
12:38:20 <slack1256> johnw: I guess reach whnf for functions, which translates to be a single lambda-form 
12:39:02 <slack1256> yet function of (->) type also have undefined on them
12:39:12 <slack1256> @type undefined :: (Int -> Int)
12:39:13 <lambdabot> Int -> Int
12:40:19 <EvanR> would seq on . break the end builder pattern?
12:40:20 <slack1256> which, thanks to seq, can be used to notice the difference between `undefined` and `\x -> undefined` when you shouldn't be capable of doing
12:40:28 <EvanR> endo builder
12:44:49 <The_Kinaesthetic> which module is inits from ?
12:44:53 <The_Kinaesthetic> says it's not in scope
12:44:59 <ongy> @index inits
12:45:00 <lambdabot> GHC.OldList, Data.List, Data.ByteString.Lazy, Data.ByteString.Lazy.Char8, Data.ByteString, Data.ByteString.Char8, Data.Sequence
12:45:20 <The_Kinaesthetic> isn't Data.List included in prelude?
12:45:35 <The_Kinaesthetic> i'm trying to use inits in my ghc and it's not working
12:45:56 <The_Kinaesthetic> hmm, I imported Data.List and it works
12:46:01 <The_Kinaesthetic> didn't think I needed to do that
12:46:11 <ongy> not all of it. Just a few things are reexported
12:46:12 <The_Kinaesthetic> am I misunderstanding something here?
12:46:49 <EvanR> you have to import Data.List to get a lot of stuff
12:47:27 <EvanR> i do more importing than anything when writing haskell code! :)
12:48:19 <The_Kinaesthetic> ok
12:48:29 <The_Kinaesthetic> hmm my code loaded fine
12:48:43 <The_Kinaesthetic> but i got `*** Exception: MainComposer.hs:(22,1)-(25,21): Non-exhaustive patterns in function posLength`
12:49:00 <The_Kinaesthetic> posLength itself works on the input
12:49:16 <EvanR> the most basic error of all... not defining the function for all possible inputs
12:49:24 <EvanR> very easy in other languages
12:49:28 <ongy> -Wall should warn about that I think
12:49:33 <EvanR> yes
12:52:58 <The_Kinaesthetic> o derp my posLength function doesn' even work correctly anyway
12:55:37 <The_Kinaesthetic> ok I fixed it but my other position function still returns the same eror
12:56:15 <ongy> are you compiling with -Wall?
12:57:04 <The_Kinaesthetic> how do I? I tried and it interpreted as a Data constructor of the same name
12:57:10 <The_Kinaesthetic> is it --Wall?
12:57:29 <The_Kinaesthetic> I'm using ghci
12:57:34 <ongy> how are you invoking the compiler?
12:59:01 <The_Kinaesthetic> I'm guessing I need to use just "ghc"
12:59:42 <ongy> what do you currently use as command to run the compiler, which then gives you the errors?
12:59:52 <The_Kinaesthetic> ghci
13:01:21 <ongy> The_Kinaesthetic: `ghci -Wall File.hs` should work
13:06:05 <The_Kinaesthetic> it did thanks. Found the problem
13:07:40 <The_Kinaesthetic> do i ignore all these warnings?
13:07:44 <The_Kinaesthetic> it returned the right value
13:08:30 <ongy> it's usually a good idea to eliminate warnings. But depending on what you are doing, some are fine
13:08:31 <The_Kinaesthetic> now for my `position` function I get `*** Exception: Prelude.last: empty list`
13:08:44 <ongy> > last []
13:08:46 <lambdabot>  *Exception: Prelude.last: empty list
13:08:59 <ongy> The last (also head) functions aren't total, they error on empty lists
13:09:06 <The_Kinaesthetic> i see
13:09:12 <The_Kinaesthetic> ok let me see what I can do
13:09:37 <EvanR> "eliminate warnings" could mean a couple things!
13:09:46 <EvanR> flags to stop the warnings for particular things
13:10:35 <EvanR> The_Kinaesthetic: when your program is crashing because of a thing that youre being warned about, probably bad to ignore teh warnings
13:11:26 <ongy> you aren't warned about head and tail though (I wonder if a flag that makes incompleteness warnings over modules would be possible)
13:11:29 <The_Kinaesthetic> Well `position` is crashing but posLength was returning the right value, when I mentioned warnings earlier I was talking about posLength
13:12:01 <The_Kinaesthetic> ok no warnings this time when I reloaded
13:12:04 <The_Kinaesthetic> pls work
13:12:07 <The_Kinaesthetic> dear god pls work
13:12:24 <The_Kinaesthetic> MOTHER OF GOD
13:12:26 <The_Kinaesthetic> IT WORKS
13:12:38 <johnw> wow, that actually does the trick?
13:12:38 <The_Kinaesthetic> actually let me double check it got the right value, but at least it returned something
13:12:45 <johnw> I need to try pleading the next time I compile
13:14:02 <The_Kinaesthetic> ouch
13:14:06 <The_Kinaesthetic> it returns the wrong value
13:14:23 <ongy> the compiler can't warn you about that
13:14:32 <The_Kinaesthetic> yeah I know it's my logics fault
13:15:01 <ongy> maybe the problem is to blame and your code is correct
13:15:14 <The_Kinaesthetic> what problem?
13:18:25 <kamog> can I check in ghci whether a type has an instance for a class?
13:20:18 <kamog> Oh, nevermind. It's :info...
13:21:50 <The_Kinaesthetic> YUS
13:21:51 <The_Kinaesthetic> OMG
13:21:54 <The_Kinaesthetic> I DID IT
13:22:03 <The_Kinaesthetic> Thanks everyone! Thanks :dmwit!!!
13:22:08 <The_Kinaesthetic> Thanks everyone! Thanks dmwit!!!
13:22:33 <The_Kinaesthetic> does the colon actually ping them or is that just a convention? I'm on the crappy web app.
13:23:13 <XorSwap> The_Kinaesthetic
13:23:21 <XorSwap> :The_Kinaesthetic
13:23:44 <The_Kinaesthetic> That pinged me, so I guess the colons just a convention? similar to @, but @ triggers bots apparently
13:23:55 <The_Kinaesthetic> anyway
13:24:22 <The_Kinaesthetic> dmwit said we would focus on making things clean after I solved it
13:24:32 <The_Kinaesthetic> I wonder if they still want to help me do that
13:26:01 <XorSwap> if your code isn't too monady I could probably help
13:26:25 <The_Kinaesthetic> Somewhat unrelated question: The compiler says my other function is missing a pattern but I have no clue what to return for it because it would be a stupid input, should I put Maybe in the type signature and return Nothing?
13:26:47 <ReinH> That's usually a good idea.
13:27:04 <EvanR> stupid is as stupid does
13:27:28 <The_Kinaesthetic> that gave me type errors now
13:27:49 <The_Kinaesthetic> `Couldn't match expected type `Maybe a' with actual type `a' `a' is a rigid type variable bound by   the type signature for:     elemTree :: forall a. Tree a -> [Int] -> Maybe a`
13:27:51 <ReinH> Yes, you changed the type.
13:28:47 <The_Kinaesthetic> so do I now have to return Just _ for the other values I actually do want to return?
13:28:56 <cocreature> yep
13:29:00 <The_Kinaesthetic> ew
13:29:08 <cocreature> and Nothing for the case where you don‚Äôt want to return anything
13:29:10 <The_Kinaesthetic> Is that gonna mess things up when I use the function for other things?
13:29:18 <ReinH> Yes, you changed the type.
13:29:21 <cocreature> depends on what ‚Äúother things‚Äù are
13:29:29 <cocreature> most code that uses this function will probably need to change
13:29:39 <cocreature> since it needs to handle the case where it gets a Nothing
13:29:49 <The_Kinaesthetic> well i'd like to take the value it returns (when given anything other than an empty list) and perhaps put it in a new tuple
13:29:50 <ReinH> I think crashing at runtime is more "ew" than having to type a few extra characters but YMMV
13:30:19 <cocreature> you can put a "Maybe a" in a tuple
13:30:38 <ReinH> you can also use fmap to lift any functions that work on your a to functions that work on your Maybe a
13:30:52 <The_Kinaesthetic> ok
13:30:59 <The_Kinaesthetic> I guess I can deal with all that later
13:31:02 <The_Kinaesthetic> and just fix errors for nwo
13:31:18 <lamefun> Is there a partial NFData class?
13:31:25 <The_Kinaesthetic> what does this warning mean `   Top-level binding with no type signature: twist :: Tree Integer`
13:31:32 <lamefun> I.e. which allows ignoring fields which are infinite by design.
13:31:48 <The_Kinaesthetic> o nvm I think it's just telling me I didn't explicitly give the type
13:32:51 <tdammers> no, the other way around
13:33:01 <tdammers> you gave *only* the type, but no implementation
13:33:06 <ReinH> No.
13:33:11 <ReinH> The other other way around.
13:33:37 <ReinH> Top-level binding with no *type signature*.
13:33:47 <The_Kinaesthetic> yup ReinH's right
13:33:50 <tdammers> oh right, my bad
13:34:04 <ReinH> Tree Integer is the inferred type.
13:34:13 <The_Kinaesthetic> what does all this mean `Defaulting the following constraint to type `Integer'   Num a0 arising from the literal `1' In the first argument of `L', namely `1' In the expression: L 1 In the first argument of `B', namely `[L 1, L 2]'`
13:34:22 <ReinH> :t 1
13:34:23 <lambdabot> Num t => t
13:34:34 <ReinH> Numbers in Haskell are polymorphic. They can be any time that is an instance of Num.
13:34:37 <thang1> :t 1 + 1
13:34:38 <lambdabot> Num a => a
13:34:41 <ReinH> The default Num type is Integer, which is GMP integers.
13:34:50 <ReinH> There's a good chance that you should use Int instead, which is machine integers.
13:34:55 <thang1> :t 1 `div` 2
13:34:56 <lambdabot> Integral a => a
13:35:00 <The_Kinaesthetic> I used Int
13:35:05 <The_Kinaesthetic> Well, I just used "1"
13:35:11 <The_Kinaesthetic> "2" etc.
13:35:12 <ReinH> s/time/type
13:35:20 <ReinH> Then you used Num a => a, not Int
13:35:30 <ReinH> If you want to use Int, you should specify it explicitly in the types.
13:35:34 <thang1> The_Kinaesthetic: those are numeric literals, that is, "the number itself"
13:35:58 <The_Kinaesthetic> I didn't explicitly give the type, that warnings for the same tree
13:36:15 <The_Kinaesthetic> I just put an example tree in my code so I wouldn't have to type it everytime
13:36:51 <The_Kinaesthetic> But my tree type takes any type `a` as long as they agree
13:37:05 <The_Kinaesthetic> `data Tree a = B [Tree a] | L a          deriving (Show)`
13:37:39 <ReinH> you want your tree to only have values at the leaves?
13:37:44 <thang1> You probably want to write that as data Tree a = L a | [Tree a]
13:37:45 <The_Kinaesthetic> Yes
13:37:56 <ReinH> No, they do not.
13:38:01 <thang1> really? Odd
13:38:03 <ReinH> Since that is not valid.
13:38:05 <The_Kinaesthetic> Yeah I tried Omitting B many times
13:38:09 <The_Kinaesthetic> I was told that was impossible
13:38:15 <AndreasK> The_Kinaesthetic: Imo you can ignore the warning, but if you give the type explicitly the warning will go away
13:38:16 <thang1> oh whoops, forgot the B
13:38:30 <The_Kinaesthetic> :AndreasK, ok thanks
13:38:52 <thang1> I meant Tree a = L a | B [Tree a]
13:38:53 <The_Kinaesthetic> :thang1 o are you just saying I should put L first? If yes, why?
13:39:27 <thang1> Yeah that's just what I'm saying. I'd imagine it makes a difference when fmapping over the tree
13:39:27 <ReinH> It doesn't really matter.
13:39:35 <ReinH> It can't make a difference.
13:39:42 <ReinH> since fmap id = id
13:39:57 <thang1> > length (1,[1..5]) -- behaves "counterintuitively"
13:39:59 <lambdabot>  1
13:40:15 <ReinH> YEs, but that is irrelevant.
13:40:22 <ReinH> That's a different type.
13:40:29 <The_Kinaesthetic> My Branches all take lists so length works on them
13:41:39 <thang1> Well, I meant more that writing instances of, eg fmap, for a data-type means you only work on the right-most part of the data-type
13:41:46 <ReinH> No, it doesn't.
13:41:57 <ReinH> It lets you only work on the last type variable
13:42:03 <ReinH> In this case, there is only one type variable.
13:42:28 <thang1> that's what I meant. Oooh, okay, I gotcha. I must've confused that somehow when I learned that
13:42:34 <thang1> thanks
13:42:43 <ReinH> thang1: you should revisit your understanding of why length does what it does for (a,b)
13:42:51 * thang1 just realized my nickname is wrong
13:42:52 <ReinH> it counts the number of b's, and there is only one.
13:43:18 <ReinH> If it's counter-intuitive then you should replace your intuition with a better one.
13:43:21 <The_Kinaesthetic> so would length (a,b,c) still return 1 since there's only one c
13:43:27 <ReinH> Yes.
13:43:28 <The_Kinaesthetic> those are type variables of course
13:43:30 <jared-w> ReinH: yes, I know what length on (a,b) does. It's not counter-intuitie with me
13:43:39 <ReinH> jared-w: I wasn't talking to you.
13:43:42 <ReinH> :t length
13:43:44 <lambdabot> Foldable t => t a -> Int
13:44:22 <ReinH> The only foldable instance for (a,b,c) is (,,) a b, so it must operate on c's'
13:44:29 <jared-w> right, m'bad. I need breakfast, clearly. Brb to fresh up my brain
13:45:19 <ReinH> You might say that length isn't a very interesting result for (a,b) and that's true, but length is not the point of the Foldable typeclass.
13:45:40 <ReinH> Being Traversable is a very useful property of (a,b), and it requires being Foldable.
13:47:40 <EvanR> exactly what is the point of the foldable type class
13:47:50 <ReinH> Arguably, foldMap.
13:48:01 <ReinH> Or, equivalently, foldr
13:50:25 <jared-w> typeClasses in haskell to me seem to be taking an extremely general abstraction and making it possible to apply it everywhere. A bit like function overloading, but with concepts rather than necessairly explicit functions.
13:51:23 <fresheyeball> hey there
13:51:25 <jared-w> Folding is really useful, so we made a typeclass that says "any instance of this class can be folded"; traversing is neat, so we made a typeclass that says "any instance of this class is traversable"
13:51:44 <fresheyeball> I know there has got to be a proper way of doing this
13:51:47 <fresheyeball> here is what I want to do
13:51:48 <jared-w> Ideally, these are based on mathematical principles, but they dont' always seem to be at first glance  ¬Ø\_(„ÉÑ)_/¬Ø
13:52:15 <fresheyeball> mysteryFunction [a,b,c] = [distance a b, distance b c]
13:52:56 <jared-w> fresheyeball: So, in words, what are you really trying to accomplish?
13:53:08 <mellowmaroon> Hi, does anyone here know how I can configure Spacemacs with autocompletion?
13:53:10 <ReinH> fresheyeball: for arbitrarily long lists?
13:53:19 <mellowmaroon> I'm using NixOS, if that's relevant
13:53:22 <ReinH> zipWith distance xs (tail xs)
13:53:23 <lamefun> Is there a class like NFData, but one which allows some fields to not be evaluated (eg. if you want to have infinite lists).
13:53:27 <fresheyeball> I have a list of points as V2s representing a line segement
13:53:32 <fresheyeball> I am trying to get the length of that line
13:54:18 <fresheyeball> ReinH: can you explain why that works abit?
13:54:38 <ReinH> > tail [a,b,c]
13:54:40 <lambdabot>  error:
13:54:40 <lambdabot>      Ambiguous occurrence ‚Äòa‚Äô
13:54:40 <lambdabot>      It could refer to either ‚ÄòDebug.SimpleReflect.a‚Äô,
13:54:45 <ReinH> > tail [a,b,c] :: [Expr]
13:54:47 <lambdabot>  error:
13:54:47 <lambdabot>      Ambiguous occurrence ‚Äòa‚Äô
13:54:48 <lambdabot>      It could refer to either ‚ÄòDebug.SimpleReflect.a‚Äô,
13:54:53 <ReinH> What.
13:54:58 <ReinH> @undefine
13:54:59 <lambdabot> Undefined.
13:55:01 <AndreasK> > tail [1,2,3]
13:55:02 <ReinH> > tail [a,b,c] :: [Expr]
13:55:03 <lambdabot>  [2,3]
13:55:04 <lambdabot>  [b,c]
13:55:16 <ReinH> > zipWith f [a,b,c] (tail [a,b,c])
13:55:18 <lambdabot>  error:
13:55:19 <lambdabot>      ‚Ä¢ Ambiguous type variable ‚Äòc0‚Äô arising from a use of ‚Äòshow_M440656996391...
13:55:19 <lambdabot>        prevents the constraint ‚Äò(Show c0)‚Äô from being solved.
13:55:28 <fresheyeball> ReinH: ok gotcha
13:55:30 <ReinH> > zipWith f [a,b,c] (tail [a,b,c]) :: [Expr]
13:55:32 <lambdabot>  [f a b,f b c]
13:55:37 <johnw> between (x:y:ys) f = f x y : between (y:ys) f
13:55:42 <jared-w> mellowmaroon: it's in the documentation
13:55:43 <johnw> just add cases for between [] and between [_]
13:56:12 <ReinH> @quote zip`ap`tail
13:56:12 <lambdabot> quicksilver says: zip`ap`tail - the Aztec god of consecutive numbers
13:56:21 <mellowmaroon> jared-w: For Spacemacs? I've been trying for a while, and can't get autocomplete working...
13:56:58 <johnw> heh
13:57:21 <johnw> > (zip `ap` tail) [1,2,3,4]
13:57:22 <jared-w> mellowmaroon: https://github.com/syl20bnr/spacemacs/tree/master/layers/%2Bcompletion/auto-completion does this not work?
13:57:23 <lambdabot>  [(1,2),(2,3),(3,4)]
13:57:23 <johnw> neat
13:57:45 <mellowmaroon> jared-w: ah, this may be it. Thanks
13:58:02 <ReinH> Yeah, in this case zipWith distance <*> tail
13:58:05 <mellowmaroon> jared-w: was looking at the page for Haskell's layer
13:58:14 <jared-w> np. Let me know if the first google result for "spacemacs auto complete" worked for you :p
13:58:46 <mellowmaroon> ...lol
13:59:32 <jared-w> zip ap tail. Neat, I like it
14:00:30 <ReinH> It's usually easier to explain the beta reduced version :)
14:01:30 * hackagebot mediabus-rtp 0.4.0.1 ‚Äì Receive and Send RTP Packets ‚Äì https://hackage.haskell.org/package/mediabus-rtp
14:01:30 * hackagebot mediabus 0.4.0.1 ‚Äì Multimedia streaming on top of Conduit ‚Äì https://hackage.haskell.org/package/mediabus
14:01:48 <Lokathor> the GHC source implies that on a 64-bit machine, Int32 and Int64 are the same size in memory because they both use the Int constrctor. Is this true?
14:02:00 <Lokathor> or does GHC actually replace that stuff when it compiles and Int32 is actually only 32 bits?
14:03:59 <geekosaur> the basic size of the built-in types is a machine word, as I understand it. so it's using 64 bits
14:04:01 <merijn> Lokathor: Int32 is 64bit, because that's usuall the fastest way to access data
14:04:29 <Lokathor> dag
14:04:42 <merijn> Lokathor: Instructions on machine words are generally faster, so the trade off is "faster instructions" vs "less memory usage"
14:05:13 <Lokathor> guess i should make all my rust code use isize and usize :P
14:05:17 <merijn> Lokathor: Although if you use LLVM strictness analysis could potentially unbox the entire thing and then optimise/specialise
14:05:38 <Lokathor> in my case the two Word64 values are strict+unpacked
14:06:00 <merijn> Lokathor: Honestly, I wouldn't worry about it until you profile and have a provable memory bottleneck
14:06:14 <Lokathor> well, they're strict, and then I left the default unpacking unpack it, i guess it probably doesn't unpack Word64 if i compile that code on a 32-bit machien
14:07:30 <mellowmaroon> jared-w: so I put 'company-ghc' in spacemacs-default-company-backends, like that page says, but it only completes import
14:08:01 <mellowmaroon> jared-w: that is, the word "import". Nothing when I try Control, for instance
14:09:25 <Lokathor> merijn, I'm not concerned about speed exactly, I know that PCGen code is faster than StdGen, I'm more concerned if I can make the factual claim that PCGen uses the same memory (2x Word64) as StdGen (2x Int32) on 64-bit machines (since most folks use 64 bit anyway)
14:12:35 <ReinH> mellowmaroon: you shouldn't have to do anything other than use auto-complete and haskell and configure the haskell package variables to use intero or w/e
14:12:51 <ReinH> in particular, you shouldn't have to touch spacemacs-default-company-backends
14:13:13 <mellowmaroon> ReinH: that's really weird that it's not working then....
14:13:23 <ReinH> What is your haskell layer config?
14:13:47 <mellowmaroon> ReinH: I'll retry intero from scratch. One moment
14:14:15 <ReinH> And did you load intero? C-c C-l iirc.
14:14:30 <ReinH> intero has to load your project before it can offer completions
14:14:51 <mellowmaroon> ReinH: I've got a few things there right now, like haskell-completion-backend 'ghci, haskell-process-type 'stack-ghci, and haskell-enable-company-mode t
14:14:58 <jared-w> mellowmaroon: if you're using intero, your backend should be 'intero
14:15:15 <ReinH> If you're using ghci, you still need to load ghci
14:15:23 <mellowmaroon> ReinH: I wonder if that's it (the package thing). I was testing using a one-off test.hs file
14:15:31 <jared-w> mellowmaroon: remove everything except haskell-completion-backend 'intero
14:15:37 <mellowmaroon> got it
14:17:24 <jared-w> Then load up a *.hs file, hit M-m i l
14:17:43 <jared-w> you should see a intero:backend... fundamental buffer listed
14:17:54 <ReinH> Or just , i l
14:18:12 <jared-w> mine is mapped from , to \ because mapping , to leader is a sin
14:21:30 <mellowmaroon> ok, so I started it with only intero, and it can't find runghc or stack
14:21:46 <mellowmaroon> but that may be a NixOS related thing
14:22:37 <mellowmaroon> let me try nix-shell with stack first, that's how I usually access it
14:23:40 <mellowmaroon> nope, no luck
14:25:37 <mellowmaroon> jared-w, ReinH: do you all have any additional advice?
14:27:29 <jared-w> if it can't find stack, that's a path thing
14:27:58 <mellowmaroon> jared-w: right, that seems to be fairly common with Nix
14:28:10 <jared-w> if I type "which stack" into my terminal, I get a path to a stack binary that I can run anywhere. If it's a global path, emacs can find it
14:28:28 <jared-w> Yup, that's part of the side effect of running an OS that hates global paths :)
14:28:54 <jared-w> add this to your user-config
14:29:09 <jared-w> (dotspacemacs/user-config (), I mean)
14:30:01 <jared-w> (with-eval-after-load 'haskell (setq exec-path (append exec-path '("my/path/to/stack"))))
14:30:47 <jared-w> I actually haev ~/.local/bin/ in that string because I want to be able to access anything stack installed and stack installs things to ~/.local/bin/ on my computer. You will need to add the location of the stack binary itself *and* the location where stack installs its binaries
14:31:47 <jared-w> additionally, if you're setting your path in a .bashrc or .zshrc file, you should be setting it in something like .profile or .zprofile instead; they're loaded earlier and GUI programs can access that variable whereas only terminal programs can access a path set in a $shell-rc file
14:32:26 <mellowmaroon> jared-w: right, I have .local/bin in my .zshenv. Ill add it to exec-path anyway
14:33:26 * hackagebot ldap-client 0.2.0 ‚Äì Pure Haskell LDAP Client Library ‚Äì https://hackage.haskell.org/package/ldap-client
14:35:13 <mellowmaroon> jared-w: Nope, still can't find it... I'll have to pick this back up later
14:35:32 <mellowmaroon> jared-w: Thanks for the advice, anyway :) I'll ask the nix folks for help from here
14:35:49 <jared-w> ahh, shame. It's gotta be nix specific at this point
14:36:13 <mellowmaroon> jared-w: and remain with only that intero backend thing. Good to know that's all I should need in my config
14:36:20 <mellowmaroon> Thanks again :)
14:36:29 <jared-w> np, let me know if you ever fix it
14:39:16 <juanpaucar> Hi, does somebody know how to get something like "JSON.stringify" but in Haskell? I'm looking for something like Data.Aeson.Value -> ByteString
14:39:43 <juanpaucar> but i haven't been able to get it
14:41:15 <jared-w> Check out toJSON and fromJSON
14:51:27 <lyxia> juanpaucar: encode/decode
14:52:19 <juanpaucar> lyxia: thanks :)
14:52:36 <juanpaucar> jared-w: somehow it compiled... wit Result Text O.O
14:53:47 <jared-w> juanpaucar: So it worked?
14:54:29 <juanpaucar> jared-w: it compiled, didn't make tests. encode and decode are more straightforward
14:54:45 <jared-w> ahh got it
14:57:25 <jared-w> So, encode and decode both use ToJSON and FromJSON
15:02:10 <lyxia> toJSON and fromJSON are at a different level. They don't handle serialization to a ByteString.
15:02:43 <lyxia> ByteString <-(encode/decode)-> Value <-(toJSON/fromJSON)-> a
15:03:02 <lyxia> (though actually encode/decode range all the way to the right as well)
15:06:23 <jared-w> Right. to/from really mean "this data has the property that you can translate into or from JSON", it doesn't mean they do anything with byteString
15:09:47 <ph88^> why do i get y_stop is not scope on line 16 ?   https://bpaste.net/show/f8fcf0e6d668
15:11:08 <jared-w> Looks like you're shadowing y_stop
15:11:23 <geekosaur> the scope of the let ends at the where
15:11:50 <ph88^> eh ok that's new to me ^^
15:12:13 <monochrom> "(let ... in ...) where", not "let (... in ... where)".
15:12:32 <geekosaur> ^
15:12:44 <monochrom> in fact the "where" belongs to "getMinMaxFromOffset start ip =", not the expression.
15:12:56 <exio4> also, let-in is an expression, where is where is part of a definition 
15:12:57 <ph88^> ok i just moved everything from the in (..) part into the where
15:13:10 <monochrom> It also doesn't help to indent like this to mislead yourself. Put the "where" outer.
15:13:38 <monochrom> f x =
15:13:45 <monochrom>                                       let y = x in z
15:13:50 <monochrom>   where z = x
15:13:57 <ph88^> changed it to this https://bpaste.net/show/88f5212bc884
15:14:01 <monochrom> Now that is honest indentation.
15:14:39 <ph88^> thx guys
15:22:22 <lamefun> Is there a version of NFData class that allows some fields to remain unevaluated?
15:22:54 <monochrom> No.
15:23:31 <lamefun> That's a shame.
15:25:03 <lamefun> Is the requirement that 100% of the fields are evaluated even useful?
15:25:12 <monochrom> Yes.
15:26:07 <jared-w> it helps prevent space leaks, I believe
15:26:25 <monochrom> The typical binary search tree is 100% evaluated.
15:26:44 <monochrom> In fact, furthermore, 1,000,000 ppm too.
15:30:09 <lamefun> https://paste.ofcode.org/HqYx4YByhaT4nXJCvhi5bC - is it a bad idea for a class?
15:30:51 <lamefun> I.e. NFData, but fields with ~ are ignored.
15:31:13 <monochrom> That is not just a class. That is a whole language extension.
15:31:29 <lamefun> How is it?
15:31:43 <monochrom> How is it not?
15:31:50 <lamefun> It's just a class.
15:31:57 <monochrom> You're introducing the ~ syntax. How is it not?
15:32:23 <husel> Hello, why am I getting this error? "Couldn't match type ‚Äò[Char]‚Äô with ‚ÄòChar‚Äô"   My code: factorial 0 = 1, factorial a = a * (a-1), all_factorials nums = map factorial nums, putStrLn (all_factorials nums)
15:33:51 <lamefun> There's no way to use ~ without StrictData at all?
15:35:12 <monochrom> husel: Is "all_factorials nums" supposed to be a string?
15:35:18 <geekosaur> husel, that code doesn't match the error message (as written, it should be complaining that [Char] doesn't match Integer)
15:35:39 <geekosaur> in fact [Integer] not Integer. did you mean print instead of putStrLn?
15:35:58 <husel> @monochrom @geekosaur I'll post the full code :)
15:35:59 <lambdabot> Unknown command, try @list
15:36:10 <husel> ,monochrom, geekosaur I'll post the full code :)
15:36:46 <husel> https://pastebin.com/0Q0aGSsM
15:37:30 <lamefun> Does Generic have any way of annotating fields?
15:38:11 <geekosaur> husel, putStrLn writes a String. it does not write arbitrary types.
15:38:34 <geekosaur> either you need to use show to get a String from the value(s) you want to display, or you want to use print instead of putStrLn
15:38:36 <geekosaur> :t print
15:38:37 <lambdabot> Show a => a -> IO ()
15:38:43 <geekosaur> :t putStrLn
15:38:44 <lambdabot> String -> IO ()
15:38:54 <husel> geekosaur: Ah I see, thanks for your help :)
16:14:30 <Lokathor> oh man
16:14:54 <Lokathor> if i put a package on hackage and later discover that it has a bug that makes it very wrong, can i retract a package?
16:14:58 <Lokathor> or just, push a new version?
16:15:08 <Lokathor> what's the policy there
16:16:13 <dmj`> Lokathor: push a new one, deprecate the old one
16:16:37 <Lokathor> ah, how does one depricate a package on hackage, just tell people to not use the old one?
16:18:50 <jmcarthur> Lokathor: At the bottom of the page for your package, click on "edit package information", then on "Preferred versions". From there you can mark some versions as deprecated.
16:19:03 <Lokathor> ah ha
16:19:04 <Lokathor> okay
16:39:28 <bbaren> Can I specify a constraints file for `cabal new-configure`?
16:53:12 <EvanR> can someone explain a rationale to me for considering fields to be different from accessor functions
16:53:35 <EvanR> like, if they are different, what is different
16:54:16 <EvanR> why would it be good
16:56:42 <lyxia> what difference are you talking about
16:56:49 <EvanR> i dont know
16:57:21 <EvanR> in haskell theyre not really different, but in some languages they are different, and could be different in some way if you designed records differently
16:57:51 <EvanR> i never really understood it, and maybe this is the wrong channel to ask
16:58:08 <Lokathor> EvanR, in haskell you can or can't use record syntax with a data type depending on if the fields have names
16:58:11 <Lokathor> so there's that
16:58:52 <EvanR> pretend in any case that variants dont have fields or accessors in the same way as records
16:58:59 <Lokathor> in OO languages, part of the hope of getters/setters is that you could theoretically override a getter/setter in a subclass and intercept the call and do something else
16:59:00 <EvanR> since im only asking about records
16:59:37 <Lokathor> or you could, in future versions, eliminate that field but *simulate* the field by keeping the getters/setters and generating the info based on some other info you do have
17:00:02 <lyxia> EvanR: is a setter part of what you call "accessor function"
17:00:17 <EvanR> originally, no i was only thinking of getters
17:00:27 <EvanR> is considering setters the key?
17:00:52 <Lokathor> setters that deny invalid inputs is part of it, yes
17:01:44 <EvanR> hypothetically, how could you consider a getter function on a record different from a field
17:02:20 <Lokathor> you can write a getter to data that doesn't directly exist without intermediate computation, for one
17:02:30 <lyxia> I think a setter is an important part of whatever makes a field
17:03:15 <EvanR> a function that doesnt just return some field, but computes an answer based on everything in the record is not what im talking about
17:03:28 <EvanR> thats not really a getter to me
17:04:16 <EvanR> lyxia: can you give an example of a field which makes use of setter?
17:04:19 <Lokathor> are you trying to understand why people like getters within an industry / OO context? or just Haskell's specific idea of getters?
17:04:31 <EvanR> im talking about functional programming languages that have actual records
17:04:37 <Lokathor> oh, okay
17:04:44 <monochrom> I don't know whether this is a terminology debate or semantics debate.
17:04:58 <EvanR> syntax and semantics
17:05:02 <EvanR> not terminology, call stuff whatever
17:05:24 <EvanR> {f1=e1; f2=e2; f3=e3} a record
17:05:32 <monochrom> But even if "getter" was pedantically strictly "just read one field", after a while of evolution you will have to deviate from that because of change in internal representation.
17:05:54 <EvanR> f2 is a field, and also an accessor (in haskell)
17:06:03 <EvanR> so same thing
17:06:10 <Maxdamantus> I've always thought in Haskell it's just to simplify the way it interacts with type inference.
17:06:21 <monochrom> In version 1.0 your "what's the size of this tree?" may be just reading one field. By version 5.5 it may have become a cunning computation.
17:06:35 <monochrom> So what do you call it?
17:06:37 <lyxia> EvanR: data Point = Point { x :: Int, y :: Int }    incrX p = p { x = x p + 1 }    uses the field x in two ways, one as a getter, one as a (second-class) setter.
17:06:39 <Maxdamantus> if you had `f x = x.y`, what type does `f` have?
17:06:39 <EvanR> sure a record could hide a bunch of stuff
17:06:44 <EvanR> and be used like an interface
17:06:56 <EvanR> but the field is still some thunk, value, function value
17:07:00 <EvanR> field contents
17:07:18 <Maxdamantus> if it's instead `f x = y x`, `f` just has the same type as `y`, which is dependent on scope, which everyone understands.
17:08:07 <EvanR> monochrom: the size field of some record could be a computation that does all that, but is "just a number"
17:08:25 <EvanR> in a record
17:08:52 <EvanR> lyxia: how would a first class setter look like?
17:09:01 <monochrom> Well I am saying by version 5.5 there is not even one such field.
17:09:28 <EvanR> version 5.5 changes the interface... ok
17:09:33 <monochrom> WHAT?
17:09:52 <EvanR> ok... size1 size2 size3 ? im not sure i get where youre going
17:10:03 <monochrom> My interface has always stayed the same. There is a function from my data structure to its size.
17:10:25 <monochrom> In version 1.0 the implementation just reads one field and gives it out.
17:10:34 <EvanR> a function from some type (not nec a record) to numbers doesnt seem like what im asking about
17:10:42 <monochrom> In version 5.5 there is a bit of traversal and summing. There is no size field.
17:11:33 <monochrom> I'm going abstract data types. That's where I'm going.
17:12:07 <lyxia> EvanR: A lens, I guess.
17:12:17 <EvanR> sure... my curiosity here is focusing on concrete records with specific fields. however the implementation behind its fields works, ADT or FFI or whatever is another story
17:12:57 <EvanR> put the variety of size functions in there under field size
17:13:16 <EvanR> or size non-functions
17:13:48 <EvanR> lyxia: is this how "fields" work in lens, its a getter + setter?
17:15:02 <EvanR> ski is usually the one wishing for a distinction between fields and accessors... 
17:15:15 * EvanR summons ski
17:17:19 <EvanR> Maxdamantus: yeah im not sure exactly how haskells type system and records would interact... youd need row types or something
17:21:06 <EvanR> wait ive got it... perhaps a field such as name::String could concievably be in different record types, but the relevant accessor functions not all the same because they accept different types
17:21:50 <CodeWeaverX> Is there any... detailed documentation on the fields you can alter in the ~/.cabal/config file?  I'm looking to make cabal tell GHC to use the LLVM, and I know I used to do it at one point, but I can't figure out how to do that anymore.
17:21:55 <EvanR> and name::Text is a different field
17:22:25 <CodeWeaverX> I can do it on the command line directly, but not in the config file by default.
17:23:09 <jle`> does the cabal user manual offer any insight?
17:24:01 <monochrom> CodeWeaverX, the default file has a complete list of all the settings and their defaults, you try to guess their meanings by names.
17:24:31 <monochrom> To obtain the default file:
17:24:33 <CodeWeaverX> And none of them seem to correspond to the "ghc-option" option you can give on the command-line.
17:24:40 <monochrom> 1. Delete your customized file.
17:24:44 <monochrom> 2. cabal update
17:25:05 <monochrom> 3. Read the uncustomized file.
17:25:05 <CodeWeaverX> Right, okay, so the short answer is that there isn't a corresponding 'tell GHC extra flags' thing I can put in the config file anymore.
17:25:16 <monochrom> 4. Restore your customization from your backup.
17:25:29 <geekosaur> no, the short answer is that the IRC channel is not here to read for you
17:25:42 <CodeWeaverX> uh... okay.  Thanks for that then.
17:29:23 * hackagebot pcgen 2.0.0 ‚Äì A fast, pseudorandom number generator. ‚Äì https://hackage.haskell.org/package/pcgen
17:30:45 <Lokathor> whoops, i forgot my hackage password :/
17:34:56 <suzu> it's 'password'
17:35:09 <EvanR> pretty sure it was ******
17:35:54 <CodeWeaverX> Finally found it.  Thanks, monochrome.
17:38:57 <monochrom> EvanR: Haskell is the odd man out in having a field and then a---I'll use Haskell Report terminology---selector function named by a pun.
17:39:15 <EvanR> really, no wonder i am confused
17:39:55 <monochrom> In Haskell you write "R{f=5}" to set, "f R{whatever}" to get. In the latter, that f has the social status of a function.
17:40:13 <monochrom> In other languages, the latter simply doesn't exist. You can't even ask your question.
17:40:32 <monochrom> It is a special syntax "R{whatever}.f"
17:41:23 <EvanR> .f is second class?
17:41:33 <monochrom> "f" is second class altogether.
17:42:01 <monochrom> "f" can only be used in 3 contexts: R{f=5}, R{whatever}.f, and pattern matching: case r of R{f=x} -> x+1
17:42:17 <monochrom> (I mean outside Haskell.)
17:42:40 <monochrom> In Haskell, "R{whatever}.f" is replaced by "f R{whatever}" and suddenly you have some kind of first-class "f".
17:42:57 <monochrom> But clearly it is a different f.
17:42:57 <EvanR> 1/3 of one
17:44:49 <EvanR> so in what would could making a distinction help
17:44:57 <EvanR> in what way could*
17:45:27 <EvanR> because that distinction there looks pretty limiting
17:46:03 <monochrom> Yes.
17:46:13 <EvanR> well maybe haskell not having a notion of "dot f" is also limiting
17:46:22 <monochrom> Records are an afterthought in Haskell.
17:46:24 <EvanR> you can only use the accessor
17:46:27 <EvanR> selector
17:46:56 <hanna> Doesn't GHC have extensions that allow a better record system these days?
17:46:58 <monochrom> In other languages, field names are second class. In Haskell, the whole idea of record is second class.
17:47:00 <hanna> Or is that still WIP / hypothetical?
17:47:08 <hanna> (basically overloading record access using type constraints)
17:47:57 <chaoticlambda> Is the process of converting to STG connected to LLVM? I was under the impression that the low level stuff went through llvm
17:48:00 <ski> (imho, reusing the field name for the selector function name is a mistake)
17:48:15 <lyxia> hanna: Some of it is implemented but it's mostly WIP
17:48:36 <EvanR> ski! 
17:48:42 <hanna> chaoticlambda: GHC supports LLVM but it's not used by default, GHC uses its own native code gen most of the time
17:48:48 <monochrom> Well, the reason I said that sentence is that it explains why the whole mechanism looks half-hearted and asymmetric and all that, for example a first-class getter but not a first-class setter.
17:49:13 <EvanR> ski: what would it look like done right
17:49:16 <hanna> Personally I basically don't use selector functions at all in my ocode
17:49:41 <hanna> whenever I deal with records I *always* find myself using RecordWildCards
17:49:44 <monochrom> Perhaps a special syntax like "#f" for the function version?
17:49:50 <hanna> or explicit pattern matching
17:49:55 <chaoticlambda> Hanna: Thanks you
17:49:58 <monochrom> Actually SML does that IIRC.
17:50:08 <EvanR> #f is a function to do .f ?
17:50:13 <hanna> In fact RecordWildCards make selectors-as-functions even *more* confusing because now ‚Äúfoo‚Äù is ambiguous between foo :: Int and foo :: Record -> Int to the reader
17:50:19 <hanna> unless you use RecordWildCards very consistently (which I do)
17:50:20 <monochrom> Yeah
17:50:27 <ski> yes `#f' is the selector function in SML
17:50:37 <EvanR> does it allow setting somehow
17:50:44 <monochrom> No.
17:51:00 <ski> having some kind of postfix notation would also be ok
17:51:06 <hanna> I would be fine with (\Rec{..} -> fieldName) as the accessor
17:51:08 <monochrom> I would not have switched to Haskell if SML were that cool :)
17:51:09 <ski> hanna : yes
17:51:11 <hanna> in case I need to pass it to `map` or something
17:52:02 <hanna> I also use RecordWildCards for construction, because I find it easier to write = Rec{..} where {- define fields here -}, it's lighter on the syntax
17:52:11 <hanna> works especially well inside do blocks
17:52:23 <EvanR> Rec{..} introduces all the fields as regular words?
17:52:27 <hanna> e.g. do  field1 <- parseSomething; field2 <- parseAnotherThing; return Rec{..}
17:52:41 <hanna> EvanR: Rec{..} is short-hand for Rec{field1 = field2, field2 = field2, etc}
17:52:47 <ski> it would be nice if one could write `f x = ..x..' rather than `f = \x -> ..x..' in a record construction/update
17:52:49 <hanna> err field1 = field1 of course
17:52:50 <EvanR> seems like PHP 
17:53:07 <hanna> For record construction/update I'd rather have native lenses :D
17:53:15 <hanna> #fieldName could be a candidate for that
17:53:30 <EvanR> so #f could be a lens
17:54:19 <ski> also, i don't like being able to write `Just {}' in a pattern. `Just {_}', or something similar would be ok
17:54:39 <EvanR> why
17:54:47 <EvanR> oh dont like
17:54:53 <ski> (as far as possible, pattern syntax should agree with expression syntax)
17:56:43 <geekosaur> record syntax already breaks that, though. you don't need an extension to write R {f1, f2} as a pattern
17:56:47 <geekosaur> er
17:56:56 <hanna> ski: _ agrees with expression syntax as little as {} does
17:57:00 <geekosaur> R { field1 = f1, field2 = f2}
17:57:18 <geekosaur> well, I suppose tha does work as record update
17:57:19 <hanna> ski: ignoring data is something unique to patterns
17:57:23 <hanna> and {} qualifies as ignoring data
17:57:25 <hanna> I think it's valid
17:57:34 <geekosaur> so I gues syou dislike record puns too
17:57:57 <geekosaur> (which are an extension; I didn;t think that out fully, sigjh)
17:58:29 <ski> hanna : `MkFoo {}', as expression syntax, ought to make a "record" with zero fields. `MkFoo {}', as pattern syntax, ought to match on that record
17:58:52 <dolio> That's not what MkFoo {} does.
17:59:01 <dolio> As an expression.
17:59:20 <Maxdamantus> 12:16:58 < EvanR> Maxdamantus: yeah im not sure exactly how haskells type system and records would interact... youd need row types or something
17:59:35 <ski> i know. i was talking about what it ought to do, imho
17:59:42 <dolio> Ah.
17:59:44 <Maxdamantus> aiui, row types could just be thought of as synthetic classes.
17:59:50 <hanna> ski: What would you prefer Just {} do?
17:59:56 <ski> `MkFoo {_}' would be invalid as an expression (at least if you don't enable wildcards or something), so the issue doesn't arise then
18:00:00 <hanna> (as an expression)
18:00:00 <ski> hanna : i already said
18:00:14 <hanna> ski: Yes but I don't follow - what is the meaning of a Just record with zero fields?
18:00:20 <hanna> That doesn't make sense, Just always requires a value
18:00:23 <hanna> By definition of `Maybe`
18:00:23 <Maxdamantus> foo :: .y a b => a -> b; foo x = x.y
18:00:46 <ski> exactly, it doesn't make sense. that was my complaint about `Just {}' being allowed in patterns (and in expressions)
18:00:50 <hanna> You don't get to choose when applying a constructor what field you want the constructor to have
18:01:09 <hanna> Oh, I see what you mean
18:01:13 <geekosaur> hanna, records (as opposed to unnamed fields as used by Maybe) init their fields to undefined if not specified
18:01:27 <Maxdamantus> (where `class .y a b | a -> b` and `instance .y Point Double` are implicitly there)
18:01:39 <ski> Maxdamantus : some light-weight record systems had a "lacks" constraint
18:02:28 <EvanR> so .y is basically HasY
18:02:34 <Maxdamantus> Yes.
18:02:46 <ski>   foo :: r \ x => Rec {y :: b | r} -> b; foo x = x .y
18:03:11 <ski> (er, `r \ y', not `r \ x')
18:08:22 <Maxdamantus> Mm, that might work too. I think that's what Elm has.
18:08:46 <Maxdamantus> actually, maybe not.
18:09:04 <EvanR> its kind of hard to pin down what elm has
18:09:11 <EvanR> unless i presume if you install it and play with it
18:09:27 * Maxdamantus generally dislikes the idea of type systems requiring that things not match though.
18:10:08 <hanna> What are the use cases for flexible statically typed records anyway?
18:10:13 <Maxdamantus> Feels like anything that does it is going to have to reason about it in a larger context that might as well just have a simpler construction for the entire thing.
18:10:17 <hanna> i.e. what problem are we trying to solve?
18:10:45 <hanna> I know one is being able to re-use the same field name in multiple records, but that can be solved with other ways (e.g. type-directed disambiguation, which iirc GHC already supports as an extension?)
18:11:16 <EvanR> ill believe that solution when i see it
18:11:45 <EvanR> i was only trying to see the utility of considering fields and accessors to be different
18:11:51 <hanna> https://ghc.haskell.org/trac/ghc/wiki/Records/OverloadedRecordFields/DuplicateRecordFields and https://ghc.haskell.org/trac/ghc/wiki/Records/OverloadedRecordFields/OverloadedLabels claims this is in GHC 8
18:11:51 <EvanR> and what it would look like
18:11:53 * hanna checks
18:12:03 <hanna> yes, those extensions exist
18:12:23 <EvanR> will ill believe when i see it is it working out practically
18:13:09 <hanna> I might try converting one of my recent programs to use this, since iirc I ran into a conflicting record field problem for mine as well
18:18:57 <jle`> is there a cheap lightweight linear regression library somewhere
18:19:02 <jle`> i just need a quick one
18:19:31 <jle`> i guess ther eare a couple on hackage
18:21:44 <EvanR> speaking of implementing abstract data types as records... 
18:22:26 <EvanR> in haskell you pretty much assume algebraic data is implemented as box-with-multiple-pointers-to-more-boxes-plus-tag
18:22:45 <EvanR> i wonder if it would be interesting to have abstract implementations that look like algebraic data to the programmer
18:22:56 <EvanR> algebraic interface to who-knows-how-its-implemented
18:23:48 <EvanR> looks like S(S(S(S(Z)))) but is really a machine int, or gmp int
18:24:36 <EvanR> looks like [[4,4,3],[2,2,1]] but is a vector of words
18:24:37 <ski> yes
18:25:14 <ski> one should be able to declare multiple alg. data type interfaces to a data type
18:25:25 <Axman6> don't most of the DT languages do that? numbers look inductive but are actually represented as more efficient types if they exist at runtime
18:25:36 <EvanR> but its a specific optimization for just Nat
18:25:41 <EvanR> and its not done by the programmer
18:25:43 <ski> well, that's an ad hoc case
18:25:45 <ski> right
18:25:56 <Axman6> the vector thing is sort of similar to the DPH stuff
18:26:47 <Axman6> EvanR: I think some related topics came up in http://doisinkidney.com/posts/2017-04-23-verifying-data-structures-in-haskell-lhs.html (which is an awesome read nontheless)
18:26:52 <EvanR> looks like byte:byte:byte:... but is really ByteString
18:27:10 <EvanR> looks like String but is really Text
18:27:10 <EvanR> hehe
18:28:38 <hanna> EvanR: hmm yeah, it does seem to not really work well in practice
18:28:42 <hanna> (DuplicateRecordFields)
18:28:43 <EvanR> right now when you get an algebraic data type, you kind of get what you see
18:28:57 <hanna> seems like the crippling information is the fact that type annotations from the argument don't flow ‚Äúinward‚Äù to the usage
18:29:03 <hanna> crippling limitation, even
18:29:18 <EvanR> hanna: :(
18:29:20 <hanna> so foo :: Foo -> Int;  foo x = doSomething (fieldName x)
18:29:22 <hanna> this does not work
18:29:42 <hanna> and in fact neither does fieldName (x :: Foo), apparently
18:29:50 <hanna> (even though it should - bug?)
18:29:59 <EvanR> ive never really seen any of this work ...
18:30:32 <hanna> EvanR: seems like this is missing https://ghc.haskell.org/trac/ghc/wiki/Records/OverloadedRecordFields/MagicClasses before it will be propertly solved
18:30:34 <hanna> the way a user expects it to
18:31:26 <EvanR> ski: is this algebraic interface thing a thing in any language you know of?
18:31:29 <EvanR> or is there a paper
18:32:33 <hanna> pattern synonyms sort of come to mind
18:35:37 <hanna> https://0x0.st/0xH.txt
18:35:47 <hanna> this is an example of how to use pattern synonyms to hide the implementation of Int
18:35:57 <hanna> but it's also ugly in a way
18:36:08 <hanna> doesn't get you the usual nice properties of an ADT interface, like completeness checking
18:36:39 <hanna> even so, with overloaded lists and pattern synonyms I'm sure you could make an interface to Text that's as easy to use as for String
18:36:48 * hanna tries
18:39:30 <hanna> actually OverloadedLists already allows list patterns to work for Text, but via conversion to String
18:39:58 <hanna> what I meant is RebindableSyntax
18:40:30 <Lokathor> what's the flag to let you put type signatures on your methods when you declare an instance?
18:41:22 <hanna> ah, RebindableSyntax doesn't affect the magic list constructors : and []
18:42:22 * hackagebot throwable-exceptions 0.1.0.8 ‚Äì throwable-exceptions gives the easy way to throw exceptions ‚Äì https://hackage.haskell.org/package/throwable-exceptions
18:42:24 <hanna> then again I suppose going through Syntax for pattern matching isn't a big deal if your goal is to make Text work as a drop-in replacement for String
18:42:29 <hanna> going through String*
18:43:15 <hanna> because in a pattern like ('%':rest) the toList will only produce a single character (ideally)
18:45:55 <d34df00d> Hi!
18:46:04 <d34df00d> Is it possible to ignore the order of tags using hxt picklers?
18:46:19 <d34df00d> I'm trying to parse almost-machine-generated file, but the order of tags is not guaranteed to always be the same.
18:48:17 <EvanR> hanna: not as a drop in, since we dont expect some operations ot have the same performance
18:48:29 <EvanR> most of the time prepending a character would be bad
18:48:41 <EvanR> but consuming and analyzing the data would be nice
18:49:03 <endolphin> just did a system update on arch and trying to do cabal install xmonad xmonad-contrib [... etc etc] gives me a bunch of ld/linking errors
18:49:03 <EvanR> so view patterns....
18:49:22 <endolphin> https://bugs.archlinux.org/task/54563 apparently related to this stuff
18:49:25 <geekosaur> endolphin, yes, ghc 8.0.2 on arch is broken
18:49:32 <endolphin> ah.. fix?
18:49:59 <hanna> EvanR: I guess lazy text would probably be the closest drop-in replacement for String
18:50:08 <geekosaur> force -dynamic somehow or get your ghc from somewhere other than arch. or, I have heard (but without confirmation) that the archhaskell repo's ghc etc. still work
18:50:12 <hanna> but even that has problems if you do lots of little prepends
18:50:25 <endolphin> force dynamic in cabal somehow?
18:50:50 <geekosaur> I think you'd have to use a wrapper script around ghc
18:51:06 <geekosaur> since changing it in cabal won't help when xmonad tries to build a custom config
18:51:10 <endolphin> wow that's much more broken than usual
18:51:20 <geekosaur> yes :/
18:51:21 <hanna> EvanR: anyway I think that's a small price to pay, if code does a lot of string prepends it should be rewritten to use a map or builder
18:51:30 <EvanR> lazy text is pretty cool in general... seems like a good general purpose string type
18:51:36 <hanna> it's not like Haskell is the first language to have this ‚Äúlimitation‚Äù
18:51:57 <endolphin> has that been like, a week only?  cause it's not my main computer, i can survive with tint2 for a few weeks
18:52:22 <geekosaur> less than a week, yes
18:52:40 <endolphin> cool
18:52:49 <hanna> EvanR: I would even begin to question whether doing lots of lazy text prepends with minimum chunk sizes wouldn't still be more efficient than String :D
18:53:21 <hanna> but I'm sure benchmarks could (and probably have) easily answered this
18:54:12 <EvanR> (when would you ever do a ton of char prepends)
18:55:06 <hanna> EvanR: I was thinking a good benchmark might be printf :: String -> (..lots of args..) -> String
18:55:09 <EvanR> lets push for all text files to be stored backwards!
18:55:13 <hanna> versus tprintf :: Text -> (..lots of args..) -> Text
18:55:28 <hanna> although I guess that's exactly the kind of function that would use a builder?
18:55:46 <hanna> anyway it might be interesting to benchmark that function for String, Strict.Text, Lazy.Text and TextBuilder
18:56:11 <hanna> EvanR: why not just redefine [] to use snoc cells instead of cons cells? :)
18:56:17 <EvanR> lots-of-args is like your favorite template language and so yes builder
18:56:29 <hanna> in fact why don't we
18:56:36 <hanna> isn't appending more common than prepending
18:56:46 <Lokathor> so if you've got a big record with a RandomGen field in it, is it "sane" to just make your struct also have a RandomGen instance that uses that field and then updates and all that?
18:57:05 <EvanR> hanna: that is why the main sequence type in closure appends
18:57:11 <EvanR> when you "conj"
18:57:26 <EvanR> clojure*
18:58:13 <hanna> I guess looking at the head of a string is more common than looking at the tail of a string (e.g. parsing), but appending to the tail of a string is more common than prepending to the head of a string (e.g. building up a result)
18:58:15 <EvanR> im sure they think were insane using lists backwards like we do
18:58:32 <hanna> so the haskell designers probably chose list ‚Äúreading‚Äù over list ‚Äúgenerating‚Äù? idk
18:58:52 <Lokathor> type String = Seq Char ?
18:58:55 <Lokathor> :3
18:58:56 <hanna> for example consider mapM_ print [1..10]
18:59:02 <hanna> if this used snoc cells we'd get 10 9 8 7 ...
18:59:03 <ski> EvanR : not really .. but i think "inst"s as in Mercury could possibly be useful in conjunction
18:59:09 <hanna> or an expensive revers operation
18:59:27 <hanna> Lokathor: yeah to be honest that would probably be the best of all wolds :D
19:00:09 <hanna> I also wonder if Text wouldn't be better served by a Unboxed.Vector Char
19:00:29 <hanna> (although Text stores UTF-16 instead of chars)
19:00:30 <EvanR> it would certainly avoid its shifting operation
19:00:37 <EvanR> but take up 2x as much memory
19:01:02 <hanna> I do still regularly wonder if UTF-16 is really the best representation for `text`
19:01:17 <EvanR> so did the Text people
19:01:25 <Lokathor> someone was showing off a "replacement" textual package with UTF-8 the other day in the reddit
19:01:36 <EvanR> a post mortem on that was like "well... its already done"
19:01:38 <hanna> there's https://jaspervdj.be/posts/2011-08-19-text-utf8-the-aftermath.html but it's from 2011
19:02:16 <EvanR> by using utf8 we still have the scanning but take up probably 1/2 as much memory
19:02:53 <EvanR> and zero overhead when interfacing with... anything but windows
19:03:24 <hanna> EvanR: seems like the main problem is that streaming over UTF-8 is more expensive than streaming over UTF-16
19:03:42 <hanna> since UTF-8 is more expensive to convert/deconvert than UTF-16, apparently
19:03:44 <hanna> (more complexity
19:03:55 <EvanR> if theres non ascii, i guess so
19:04:03 <hanna> which slows down a lot of functions :: Text -> Text
19:04:10 <hanna> which are internally unstream . operations . stream
19:04:39 <EvanR> thats what i meant, streaming, not scanning
19:07:11 <pacak> You still need to scan for stuff in utf16, it combines worst part of both worlds - lack of direct indexing and having to scan bits is taken from utf8 and worse memory usage is taken from utf32.
19:07:43 <EvanR> its a compromise between good and evil!
19:08:15 <EvanR> and we know who wins in that case
19:20:50 * hackagebot streaming-concurrency 0.2.0.0 ‚Äì Concurrency support for the streaming ecosystem ‚Äì https://hackage.haskell.org/package/streaming-concurrency
19:40:07 * hackagebot pcgen 2.0.1 ‚Äì A fast, pseudorandom number generator. ‚Äì https://hackage.haskell.org/package/pcgen
19:44:46 <YellowOnion__> Why is STACK_ROOT ignored on windows for ghc?
19:46:06 <YellowOnion__> http://lpaste.net/356685
19:46:31 <glguy> GHC doesn't use STACK_ROOT
19:47:51 <YellowOnion__> glguy, why not? I've run out of disk space.
19:49:59 <geekosaur> because ghc is not stack
19:50:30 <YellowOnion__> you miss interpret my point, why is stack installing ghc outside of STACK_ROOT
19:50:54 <YellowOnion__> I don't have space in my %appdata%
19:51:22 <pacak> I can imagine there's little users of ghc on windows and even less users of stack on windows.
19:51:53 <EvanR> thats not very sensitive
19:52:18 <pacak> Check the docs, issues and if nothing matches - submit a bugreport.
19:52:56 <glguy> Google says https://github.com/commercialhaskell/stack/blob/master/doc/faq.md#can-i-change-stacks-default-temporary-directory
19:54:48 <YellowOnion__> glguy, thanks I must have have used the wrong search terms.
19:56:26 <YellowOnion__> Windwos is so frustrating sometimes, pulls in 7GB of updates and the you run out of disk space >.>
19:56:56 <EvanR> download more disk
19:57:08 <pacak> Download better OS...
19:57:38 <monochrom> Those two only cause more pointless debates.
19:57:57 <exio4> download better debates...
19:58:04 <exio4> (am I doing this right!?)
19:58:09 <monochrom> Yes.
19:58:39 <EvanR> a debate on the conflict between commercial haskell and windows haskell
20:00:29 <pacak> I find some snoyman's of design decisions to be questionable.
20:00:56 <YellowOnion__> ~/.config/config.yaml on windows...
20:02:07 <YellowOnion__> I've still yet to figure out how to skip msys in stack as well.
20:02:49 <Lokathor> So can you wrap RandT around an ST computation?
20:03:05 <Lokathor> I forget if ST was weird about being transformed or not
20:04:25 <pacak> It's like IO but with respect to mutability only. Should be fine.
20:05:05 <pacak> (also contains fun to discover bugs)
20:06:05 <Lokathor> ST does?
20:06:12 <pacak> yep
20:06:16 <Lokathor> where
20:06:41 <pacak> https://ghc.haskell.org/trac/ghc/ticket/13615 - this
20:07:50 <Lokathor> trucky
20:07:53 <Lokathor> tricky*
20:07:59 <Lokathor> i'm only using vector though, so i think i'll be okay
20:08:21 <pacak> It's not specific to hashmap. Read proposed patch
20:08:42 <pacak> There's a very detailed explanation
20:10:32 <EvanR> what is WHITEHOLE
20:11:23 <pacak> EvanR: In general relativity, a white hole is a  hypothetical region of spacetime which cannot be entered from the  outside, although matter and light can escape from it. In this sense, it  is the reverse of a black hole, which can only be entered from the  outside and from which matter and light cannot escape.
20:13:06 <MarcelineVQ> AT Field
20:14:04 <EvanR> someone referenced it in that bug report
20:14:07 <EvanR> in the comments
20:14:10 <EvanR> never heard of it in ghc
20:15:02 <geekosaur> it's supposed to prevent other threads from evaluating that thunk
20:15:32 <geekosaur> so that a side-effect-producing action doesn't happen multiple times
20:15:58 <EvanR> isnt that what blackholes are for
20:17:07 <geekosaur> a blackhole catches the same thread re-entering it, e.g. let x = x in x
20:17:15 <geekosaur> iirc
20:17:33 <geekosaur> also you don;t want it to explode, just block until the thunk has been computed and then give it the result
20:17:35 <hanna> http://mainisusuallyafunction.blogspot.de/2011/10/thunks-and-lazy-blackholes-introduction.html
20:17:55 <hanna> ‚ÄúI can't explain precisely what a WHITEHOLE means, but they're used for spin locks or wait-free synchronization in various places. For example, the MVar primitives are synchronized by the lockClosure spinlock routine, which uses WHITEHOLEs.‚Äù
20:18:33 <colonelj> why aren't tuples in the Storable class???
20:19:15 <geekosaur> right, a blackhole explodes if re-entered, a whitehole blocks until it is resolved into a value
20:19:27 <colonelj> someone had to make a library for it https://hackage.haskell.org/package/storable-tuple
20:19:34 <nshepperd> if you try to evaluate x during the evaluation of x, you die because that's an infinite loop (blackhole)
20:20:06 <hanna> don't blackholes also block when using threaded RTS
20:20:16 <hanna> (because it could be that a different thread is currently evaluating this thunk)
20:20:18 <nshepperd> so logically if you try to evaluate x while someone else is already doing so, you wait politely for them to finish instead
20:20:30 <geekosaur> colonelj, because a tuple is a random anonymous collection, you should normally use a proper type instead
20:20:31 <hanna> there's also some work stealing stuff, right? so that probably depends on whether it has side effects or not
20:21:19 <geekosaur> nshepperd, I seem to recall they decided to let pure code re-execute in multiple threads because the locking overhead was too high?
20:21:35 <colonelj> geekosaur: no I NEED an anonymous storable collection to use the fricking Vector.Storable map/zipWith
20:21:37 <geekosaur> that is, it cost more in general to arrange for blocking than to just let each thread go
20:21:50 <colonelj> this is literally a most basic use of a tuple
20:22:12 <colonelj> to tie together two things for the purposes of a quick calculation
20:22:24 <nshepperd> geekosaur: seems reasonable
20:22:26 <colonelj> it doesn't exist outside of this one line of code
20:23:37 <EvanR> or write the storable instance yourself
20:24:06 <colonelj> I'll use the library thanks
20:24:18 <colonelj> the one that has {- This should be in the standard library -} at the top
20:25:07 <EvanR> seems plausible
20:30:32 <Lokathor> GHC should be able to figure out Storable instances on its own
20:32:02 <colonelj> agree
20:32:15 <Lokathor> pacak, I'm only doing this ST bit in a single thread, so I think I'm safe, if i understand it
20:32:28 <colonelj> anyhow why do I have to add a package to extra-deps in the stack.yaml??  I haven't done this for any other packages?
20:32:40 <colonelj> is it because it's not in the resolver?
20:32:45 <Lokathor> it's not on stackage?
20:33:49 <colonelj> it's on hackage
20:33:58 <Lokathor> Stackage, with an S
20:34:01 <Lokathor> is what stack uses
20:34:09 <Lokathor> which is a stable subset of hackage
20:34:27 <EvanR> i doubt it can figure out Storable instances on its own
20:34:46 <Lokathor> EvanR, if all the fields are Storable, just put them in order
20:34:47 <colonelj> well it can for newtypes
20:34:54 <colonelj> which it already does ofc
20:35:06 <EvanR> there are at least 3 ways to store a Word32 as 4 bytes
20:35:08 <Lokathor> colonelj, newtypes don't have a differnet runtime rep, so
20:35:29 <Lokathor> EvanR, and yet Word32 has a Storable instance so ?
20:35:37 <EvanR> yeah it does
20:35:46 <EvanR> someone wrote it :)
20:36:00 <Lokathor> so like with other derivings with fields with instances of their own, you just combine them
20:36:25 <EvanR> C cant even guarantee the storability of structs :(
20:36:42 <Lokathor> what?
20:36:58 <EvanR> youd think your plan would work... but...
20:37:09 <EvanR> padding and alignment issues
20:37:23 <Lokathor> well it takes up maybe more space, yes
20:37:35 <EvanR> the point being how much?
20:37:46 <hanna> You could probably infer Storable using Generic :p
20:38:03 <Lokathor> normal C rules for size, one would assume
20:38:08 <hanna> or well
20:38:13 <hanna> infer Generic and use that to implement Storable
20:38:15 <EvanR> Storable is derived with what seems like a giant standard TH i saw floating around
20:38:17 <Lokathor> eg: if your fields are out of order, you might waste space, and all that
20:39:12 <EvanR> but im not sure GHC should be knowing whats best with your storable instances
20:39:50 <EvanR> this is essentially the same question as serialization
20:40:50 * hackagebot streaming-concurrency 0.3.0.0 ‚Äì Concurrency support for the streaming ecosystem ‚Äì https://hackage.haskell.org/package/streaming-concurrency
20:43:37 <colonelj> it still annoys me that you can't write uniform -5.0 5.0 and simple stuff like that
20:43:49 <colonelj> bizarre lexing rules
20:43:58 <EvanR> unary minus
20:44:23 <colonelj> it's like at odds with every other language
20:44:51 <Axman6> well, most other languages don't allow you to do map (+20) [1..10] either
20:44:56 <EvanR> > Just (-1)
20:44:57 <MarcelineVQ> :set -XNegativeLiterals
20:44:58 <lambdabot>  Just (-1)
20:45:05 <EvanR> yep
20:45:26 <Axman6> so, maybe most other languages are wrong 
20:45:41 <EvanR> yes other languages think (+20) is a good idea and means unary plus
20:45:42 <hanna> Axman6: well haskell also doesn't let you map (-20) so I don't see how that's relevant
20:46:14 <Axman6> I think the reason why we can't write -5 is related to the reason we can write map (+20)
20:46:32 <pacak> wrt Storable for tuples - Storable needs to deal with low level detals and needs to map haskell types to underlying primitives that exists in C for example.
20:46:49 <pacak> Storable instance for  Int8 makes sense.
20:46:53 <colonelj> < EvanR> yes other languages think (+20) is a good idea and means unary 
20:46:57 <colonelj>                plus << what's wrong with that
20:47:17 <pacak> What would be sizeOf for Storabe (Int8, Int8)? How about Storable (Int16, Int8)?
20:47:25 <Axman6> because I want to write map (+20) much more often than I want to write the positive literal for 20
20:47:25 <EvanR> an example of weird choices for lexical in other languages
20:47:30 <pacak> Or Storable (Int8, Int16)?
20:47:34 <colonelj> in my language I use +/- to distinguish signed from unsigned literals
20:47:48 <colonelj> unsigned doesn't have it
20:47:50 <hanna> the + in (+20) and (5 + 20) and (5 +20) all parse as the operator +, but the - in (-20), (5 - 20) and (5 -20) sometimes parses as subtract and sometimes as negate
20:47:53 <nshepperd> other languages have bizzare lexing rules where - is different from every other operator
20:48:01 <nshepperd> so does haskell
20:48:12 <colonelj> mine doesn't
20:48:15 <Axman6> neither of these choices is "right"
20:48:21 <colonelj> all operators are born equal
20:48:23 <nshepperd> it's just different in a different way
20:48:35 <Axman6> colonelj: do you have to write +1 everywhere you want a positive 1? :(
20:48:42 <EvanR> if everything should act the same lexically you have lisp
20:48:49 <colonelj> Axman6: no, this only applies if you write +0d1
20:48:56 <colonelj> 0d for decimal etc.
20:48:56 <EvanR> communist revolution of syntax
20:49:11 <hanna> nshepperd: yes, which is why my point is that it's entirely up to choice - there's no technical reason it has to be one way or the other
20:49:12 <colonelj> normally when you write 0x you want an unsigned number
20:49:18 <hanna> we could arbitrarily make f 5 -20 parse as f 5 (-20)
20:49:25 <hanna> without affecting operator slices at all
20:49:42 <glguy> hanna: GHC will even let you do that
20:49:46 <EvanR> from what i understand the choice was made to supposedly make it easier to parse haskell rather than look nice
20:49:48 <hanna> but it brings with it some possible other side effects, e.g. (x+1) and (x-1)
20:49:51 <hanna> is that x (-1)
20:50:02 <EvanR> so yeah totally arbitrary
20:50:21 <colonelj> there's a space missing
20:50:30 <colonelj> so x-1 would lex together
20:50:32 <Axman6> why?
20:50:38 <Axman6> I often write x-1 :\
20:50:43 <colonelj> x-1 means x - 1
20:50:52 <colonelj> x -1 means x (-1)
20:50:55 <Axman6> or does it mean x (-1)
20:50:59 <colonelj> no
20:51:04 <Axman6> nah, that's completely arbitrary
20:51:13 <colonelj> it's not completely arbitrary, it's completely sensible
20:51:14 <nshepperd> you can mandate whitespace between operators and values, but that sounds terrible
20:51:22 <EvanR> agda
20:51:22 <nshepperd> i like x + y being the same as x+y
20:51:28 <Axman6> me too
20:51:30 <EvanR> x ^ 2 :)
20:51:35 <Axman6> :(
20:51:36 <hanna> the ‚Äúsafest‚Äù course of action is to mandate () around negative literals
20:51:51 <colonelj> it's lame, that is all
20:51:57 <EvanR> (a + b) ^ 2
20:51:59 <Axman6> no, it's a trade off
20:52:13 <hanna> or you could introduce a different symbol for prefix negation :D
20:52:15 <hanna> ~5
20:52:23 <colonelj> I have -~ in my language
20:52:26 <Axman6> --1
20:52:35 <colonelj> -- is decrement
20:52:37 <EvanR> there are already several - signs in unicode
20:52:40 <Axman6> the "Yes, the is really negative" minus
20:52:50 <colonelj> OCaml has ~-
20:52:54 <Axman6> what is decrement
20:52:56 <hanna> also the ‚Äúno, is not a comment‚Äù operator
20:53:06 <Axman6> hanna: yeah, you can't have a space after it :P
20:53:15 <ski> in SML it's `~'
20:53:43 <colonelj> I use ~ for not
20:53:54 <colonelj> or bit inversion
20:53:54 <Axman6> why not !?
20:54:01 <hanna> that's another can of worms
20:54:04 <colonelj> I use ! for bindings
20:54:12 <Axman6> also, using ~ as two's complement makes some sense to me
20:54:14 <exio4> why not not? 
20:54:22 <colonelj> I don't have keywords in my language
20:54:26 <Axman6> why not !
20:54:36 <colonelj> because it's more fun that way
20:54:42 <hanna> colonelj: ah, I see you develop perl?
20:54:47 <ski> "why not" is traditionally written as `?'
20:54:52 <Axman6> colonelj: so I guess yo're finding out these are all mostly arbitrary decisions
20:55:00 <Axman6> ski: ?
20:55:13 <EvanR> all programming languages are doomed to forever fight over about 31 symbols
20:55:17 <colonelj> Axman6: well it depends on the language which operator means what
20:55:22 * hanna .oO( <Axman6> ski: why not )
20:55:47 <Axman6> porque no los dos - ? both
20:57:12 <nshepperd> from now on, negation shall be written with U+2301 ELECTRIC ARROW
20:57:13 <ski> <https://en.wikipedia.org/wiki/Linear_logic#Exponentials>
20:57:24 <nshepperd> a + ‚åÅ1
20:57:44 <Axman6> pronounced "bzzzzap one"
20:58:09 <EvanR> or we could use space
20:58:14 <EvanR> or lack thereof
20:58:46 <pacak> ‚ò≠ for all the things!
20:59:45 <colonelj> is it ok if the first line of my Bits.hs has {-# LANGUAGE EmptyDataDecls, GeneralizedNewtypeDeriving, GADTs, MultiParamTypeClasses, FlexibleInstances, FlexibleContexts, Rank2Types, ImplicitParams #-}
20:59:47 <EvanR> not on 4th of july!
21:00:06 <hanna> some of those seem redundant
21:00:11 <Axman6> colonelj: ok in what way?
21:00:12 <pacak> ImplicitParams - hmm...
21:00:17 <hanna> well EmptyDataDecls and GADTs are, right?
21:00:29 <Axman6> IMO, the only acceptable use of implicit params is for stack traces
21:00:32 <colonelj> I needed ImplicitParams to implement my 'ensure' I was talking about yesterday
21:00:43 <colonelj> yeah stack traces, exactamundo
21:01:18 <hanna> implicit params seem useful for avoiding the syntactic overhead of a Reader monad
21:01:32 <nshepperd> you shouldn't actually be using ImplicitParams for that. it's supposed to be a hidden implementation detail of the call stack api
21:01:40 <Axman6> so, your ensure function is generally not considered great style - using error is something most people try to avoid at all costs, given we have much better error handling mechanisms in Haskell. why does it need to call error?
21:01:48 <colonelj> nshepperd: you're wrong I'm pretty sure
21:01:52 <nshepperd> use the HasCallStack constraint and the callStack function
21:02:13 <Axman6> you can return the call stack in an error type you return in an Either MyErr a for example
21:02:14 <colonelj> I need the callStack of the calling function
21:02:15 <hanna> it's not always the case that I want to manually write the boilerplate of carrying a ‚Äúconfiguration‚Äù-style parameter all the way through my computation, nor do I necessarily want to write everything in a monadic style
21:02:38 <pacak> I don't think I ever needed to use call stack and I'm working with a big-ish codebase...
21:02:58 <colonelj> pacak: if you want an assert that doesn't get optimized out then you might appreciate this code
21:03:01 <nshepperd> colonelj: you should be able to do that with 'callStack'
21:03:04 <colonelj> ensure :: (?location :: CallStack) => Bool -> t -> t
21:03:04 <colonelj> ensure c x = if c then x
21:03:05 <colonelj>     else error ("ensure failed\n" ++ prettyCallStack ?location)
21:03:14 <pacak> Big enough to trigger unique-id overflow bug.
21:03:42 <EvanR> what :(
21:03:51 <Axman6> pacak: how many bits?
21:04:03 <pacak> Axman6: It used to be 24 bits I think.
21:04:12 <hanna> colonelj: HasCallstack
21:04:20 <Axman6> > 2^24
21:04:22 <lambdabot>  16777216
21:04:28 <Axman6> that's not very many id's...
21:04:41 <colonelj> what's wrong with ImplicitParams seriously :(
21:04:43 <hanna> colonelj: doesn't ‚Äúerror‚Äù append a callstack by default
21:04:44 <pacak> Axman6: 640kb should be enough for everybody...
21:05:01 <hanna> yeah to be honest I don't mind implicit params either
21:05:08 <colonelj> I was only following the manual
21:05:08 <hanna> they're like a reader monad except with less syntactic overhead
21:05:33 <colonelj> hanna: yes but it's not the one I want
21:05:39 <pacak> https://ghc.haskell.org/trac/ghc/ticket/12899 - this
21:05:50 <EvanR> manually putting callstacks in the string of an error O_o
21:05:57 <EvanR> this is nuts
21:06:07 <Axman6> colonelj: I think you just need to add the HasCallStack constraint to the function calling error to get the callstack you want
21:06:39 <hanna> colonelj: I'm just saying you don't need {-# LANGUAGE ImplicitParams #-} for this
21:06:48 <hanna> type HasCallStack = ?callStack :: CallStack
21:06:53 <hanna> callStack :: HasCallStack => CallStack
21:07:06 <hanna> oh or what Axman6 said
21:07:11 <hanna> right, ?callStack is inserted by GHC
21:07:16 <hanna> but your code seems like you're inserting it manually
21:07:29 <hanna> in which case the fix is to add HasCallStack => to every function you want as part of your call stack
21:08:00 <colonelj> hanna: ok by the sounds of it yes that would work
21:08:06 <colonelj> I'll try it v soon
21:08:35 <Axman6> I believe this is the intended way of using the callstack stuff
21:09:09 <Axman6> s/::/:: (HasCallstack) =>/g done =)
21:09:12 <MarcelineVQ> that can end up being a lot of work, consider remote-ghci profiling if it's appropriate http://simonmar.github.io/posts/2016-02-12-Stack-traces-in-GHCi.html
21:09:17 <Axman6> (that probably won't work)
21:09:45 <hanna> It's sort of slightly annoying that GHC requires you to uglify your functions with HasCallStack to get callstacks
21:09:59 <hanna> but if I understand it correctly, these callstacks need to be moved around and manipulated at runtime?
21:11:16 <EvanR> in comparison, "make sure / hope your code just doesnt crash" seems like a better deal
21:11:52 <colonelj> I only really need that one layer of CallStack to get the line where the assertion failed
21:11:56 <hanna> well the biggest benefit is the fact that `error` now prints the location of where it was called when it crashes
21:13:05 <Axman6> so, coming back to my original point, if possible it is much better to avoid the use of error at all and use better mechanisms
21:13:52 <colonelj> Axman6: I literally wanted a replacement for assert
21:14:01 <hanna> I usually like to lift ‚Äúerror‚Äù out to the top level and use ExceptT
21:14:29 <colonelj> it's not an exception it's an ERROR it's not supposed to happen at all
21:14:32 <hanna> although callstacks are still useful for ExceptT :)
21:14:44 <hanna> fair enough
21:14:59 <hanna> I think that's the main use of `error` in Haskell: internal assertions
21:15:06 <hanna> I guess that's the main use of `assert` in C as well
21:15:11 <colonelj> it means your code is wrong
21:15:27 <colonelj> that's why assert gets optimized out because when you release code it theoretically isn't wrong
21:15:28 <hanna> I remember recently wondering why we don't have an `assert` in base
21:15:46 <glguy> :t assert
21:15:47 <lambdabot> Bool -> a -> a
21:15:57 * hanna scratches head
21:16:05 <colonelj> it's in Control.Exception
21:16:07 <hanna> ah
21:16:23 <colonelj> but it gets optimized out when you compile at -O2
21:16:32 <Axman6> I wonder ig that type has been updates
21:16:33 <colonelj> and -fno-ignore-assertions doesn't work
21:16:35 <Axman6> updated*
21:16:37 <hanna> colonelj: so why aren't you using that instead of your defined function? :)
21:16:49 <colonelj> because like I just said, the compiler removes it
21:16:52 <hanna> ah
21:17:16 <colonelj> I don't want to run without optimization because it's very numerical heavy code
21:17:33 <colonelj> if the flag worked I would use assert
21:17:55 <hanna> open a GHC ticket? :)
21:17:57 <colonelj> but I think the flag means "I'm not forcing you to ignore the asserts"
21:18:04 <colonelj> so they'd probably argue it's not a bug
21:18:07 <hanna> seems like a perfectly reasonable use case
21:18:08 <colonelj> so I cbf
21:18:35 <EvanR> it makes no sense to tie up optimizations with "sorry you cant have sanity checks at runtime"
21:18:44 <hanna> yeah it strikes me odd as well
21:18:47 <EvanR> its not one or the other
21:18:54 <hanna> usually that would be tied to the presence or absence of debugging symbols, but then again I don't think GHC has anything like that
21:19:02 <EvanR> and optimizations arent supposed to change the behavior :(
21:19:21 <hanna> GHC currently doesn't have any concept of ‚Äúdebug‚Äù vs ‚Äúrelease‚Äù, right?
21:19:30 <hanna> (other than the optimization level)
21:19:48 <hanna> oh there's -debug
21:19:50 <Axman6> not really, no
21:19:51 <hanna> ‚ÄúUse the debugging runtime‚Äù
21:19:56 <hanna> (whatever that means)
21:20:11 <Axman6> but, you can use CPP to build a zero overhead at release time assert
21:22:03 <MarcelineVQ> assert is a zero overhead at release time assert
21:22:05 <hanna> my problem with removing asserts at release time is that it makes it harder for users to identify bugs, for users to report bugs, and for you to process user bugs
21:23:56 <colonelj> yes, this is a very controversial issue, but removing asserts in release mode is the norm
21:24:10 <Axman6> in some places, sure
21:24:17 <Axman6> that doesn't make it a great idea though
21:24:29 <colonelj> that's why you shouldn't normally be using them
21:24:39 <Axman6> that I can agree with
21:24:40 <colonelj> they're almost comments
21:24:46 <EvanR> ok so asserts are useless...
21:24:51 <colonelj> if the compiler was capable it should try to statically verify them
21:24:54 <colonelj> they're not useless
21:24:56 <colonelj> but they are
21:25:33 <hanna> assertions are most useful if you have a test framework capable of actually triggering them
21:25:36 <Axman6> I always got the feeling that asserts in languages like C/C++ exist because the languages aren't great at giving you the tools to make impossible states unrepresentable
21:25:57 <hanna> so you can 1 make logic change, 2. compile with assertions enabled, 3. run test framework with high coverage, 4. trigger assertions and fix bug
21:26:14 <hanna> Axman6: well yes, that's what assertions exactly exist for
21:26:24 <hanna> logic bugs that can't be statically prevented
21:26:57 <hanna> An example that comes to mind of where assertions are justified and how a type system can help prevent them would be red-black trees :p
21:27:27 <hanna> Assertions also exist to turn bad crashes into good crashes
21:28:13 <colonelj> that's not much use if they get removed
21:28:14 <Axman6> #nocrashes
21:28:36 <EvanR> i wish i could say #nocrashes to erlang types
21:28:58 <EvanR> but i cant seriously
21:29:40 <Axman6> misparsed that sentence and though "uh, erlang basically doesn't have types bro"
21:30:10 <Axman6> thought*
21:30:41 <EvanR> referring to the #crashallthethings of elixir
21:31:06 <Axman6> "Elixir: Crash all the time, concurrently!"
21:31:16 <EvanR> must be nice having "web request" as your entire research focus :)
21:31:45 <hanna> ‚Äúyou don't need garbage collection if your program crashes before it leaks too much memory‚Äù
21:32:02 <monochrom> haha
21:32:22 <EvanR> unfortunately, haskell needs gc even if it crashes pretty soon
21:32:43 <hanna> yeah I'm still annoyed that haskell can't solve millisecond-scale problems
21:32:45 <EvanR> GBps allocations and all
21:32:51 <hanna> I would like to write a video player in haskell but I'm scared of GC spikes
21:33:00 <hanna> I would do it if I could guarantee a 1ms max pause
21:33:48 <pacak> hanna: I'm using haskell for algoritmic trading and typical reaction time for certain events comes in less than 200us.
21:33:49 <hanna> but GHC currently allows you no way to trade throughput for latency
21:34:27 <hanna> well what worries me is blog posts like https://making.pusher.com/latency-working-set-ghc-gc-pick-two/ that you can find all over the net if you search for ‚Äúhaskell garbage collection latency‚Äù
21:34:38 <EvanR> how little GC can you get away with and not epically fail to account for GBps allocation rates
21:35:06 <hanna> EvanR: garbage collection runtime doesn't depend on your allocation / deallocation rate
21:35:06 <EvanR> besides "all of it"
21:35:26 <EvanR> i mean, if you dont fully collect a generation
21:35:44 <EvanR> how do you know youre not actually leaking
21:35:45 <hanna> I mean GHC already has short generational garbage collections
21:35:50 <hanna> it's the long ‚Äúfull cycles‚Äù that are the problem
21:36:00 <hanna> all of the GBps of allocations and deallocations are short-lived
21:36:17 <EvanR> if you dont fully do a major collection, how do you know youre not leaking
21:36:29 <hanna> I think in practice I probably wouldn't have much to fear considering most of my data is going to be sitting in ForeignPtrs
21:36:44 <hanna> but the scary thing is I can't know until I try
21:37:04 <hanna> and I don't want to pour lots of work into a project only to have to eventually scrap it because the (project complexity √ó GC overhead) < realtime requirements
21:37:10 <EvanR> im just trying to understand where this "just have less throughput" comes from
21:37:19 <EvanR> how that would help latency
21:37:56 <hanna> EvanR: the comment about throughput was just doing incremental garbage collection has more book-keeping overhead
21:38:01 <EvanR> slow down your program? then youll have less garbage? :)
21:38:04 <hanna> so you'd spend more time garbage collecting overall
21:38:16 <hanna> garbage collection does not depend on the garbage
21:38:30 <EvanR> but if you dont spent enough time collecting grabage, your memory usage increases as if you werent doing gc at all
21:38:38 <EvanR> thats broken
21:38:40 <EvanR> not just slow
21:38:56 <EvanR> so how do you know
21:39:00 <hanna> yes, the trade-off is spending less time in your code in order to ensure you run often enough to not run out of memory
21:39:04 <hanna> every GC algorithm has this problem though
21:39:17 <EvanR> not ones that have a major cycle
21:39:31 <EvanR> that potentially blocks everything
21:39:31 <hanna> even GHC's full-cycle garbage collector will break if your program tries allocating more memory than it has access to
21:39:52 <hanna> the closer you to get to this limit, the more often the GC needs to run
21:39:55 <EvanR> ... ok running out of memory is another subject
21:40:03 <hanna> but isn't that your concern
21:40:06 <EvanR> no
21:40:09 <hanna> you said incremental GC wouldn't work because you could run out of memory
21:40:46 <hanna> At the end of the day it's just a redistribution problem
21:40:50 <EvanR> im asking a question about how you / it could know its working, where i think were misunderstanding what working means
21:41:09 <hanna> instead of spending 100 ms running collect[addressspace] once, you could spend 1ms running collect[addressspace/100] 100 times
21:41:21 <EvanR> during which time you are generating more garbage
21:41:22 <hanna> but if all you care about is latency, this is a trade-off you're more than happy to make
21:41:40 <hanna> what is there to ‚Äúknow‚Äù if it's working?
21:42:29 <EvanR> the "non broken" criteria i have is: your program is only using N bytes of memory right now. the gc is working if the amount of memory allocated doesnt increase without bound above N, assuming N stays the same for a while
21:42:57 <EvanR> and running out of memory doesnt count as working
21:43:57 <EvanR> like if allocated increase above N like a square root graph, its broken
21:43:58 <colonelj> the beauty of my stack based language is you don't need garbage collection for stuff that is explicitly on the stack, you can just refcount it
21:44:20 <colonelj> the problem is when you start adding in variables that can hold stuff
21:44:28 <EvanR> if it zig zags between N and N + 10000, its working
21:45:22 <EvanR> relying on a stack for everything doesnt mean youre not wasting space
21:45:32 <EvanR> a lot on the stack could be "garbage"
21:45:33 <hanna> EvanR: the fundamental approach is to choose how often and how long you run your incremental GC pass depending on how quickly the program is approaching its memory limits
21:46:10 <hanna> EvanR: if you're interest in this stuff, you should check out Go's garbage collector - they use a real-time concurrent incremental GC with bounded runtimes
21:46:13 <hanna> see e.g. https://making.pusher.com/golangs-real-time-gc-in-theory-and-practice/
21:46:28 <EvanR> right, i see how you can get bounded runtime
21:46:49 <EvanR> do they get bounded memory usage for programs that use bounded memory?
21:47:18 <hanna> I don't see why not, you can trivially put an upper limit on the heap size in any garbage collection scheme
21:47:29 <hanna> all that happens is that you need to run your garbage collector more and more often as you approach the heap size limits
21:47:42 <colonelj> EvanR: nothing on the stack is garbage in a stack based language..
21:47:46 <hanna> (which is also why you can reduce garbage collection overhead by increasing the heap size)
21:47:54 <EvanR> colonelj: this is ignoring a good definition of garbage
21:47:58 <hanna> EvanR: ‚Äúgarbage‚Äù doesn't mean ‚Äúunused‚Äù, it means ‚Äúit will never be used again‚Äù
21:48:09 <hanna> or perhaps more to the point
21:48:11 <colonelj> you will use everything that's on the stack
21:48:13 <EvanR> thats what i am saying
21:48:14 <hanna> ‚Äúgarbage‚Äù is memory that's allocated but unreferenced
21:48:23 <EvanR> we should all be agreeing on that
21:48:24 <hanna> everything in a stack based language is referenced
21:48:27 <hanna> by the stack frame that contains it
21:48:32 <hanna> once you leave that stack frame, it gets dereferenced
21:48:39 <EvanR> hanna: will never be used again... not the same as referenced
21:48:41 <colonelj> *poof*
21:48:45 <colonelj> gone
21:48:45 <EvanR> unreferende*
21:48:49 <hanna> in other words: there's no way to ‚Äúleak‚Äù memory in a stack based language unless you have an infinite loop
21:49:08 <colonelj> I represent infinite loops as codata though
21:49:18 <colonelj> laziness ftw
21:49:24 <EvanR> the stack tangent seems like youre not understanding something.... but i dont want to diverge from the idea of a "working" gc
21:49:48 <colonelj> a working gc removes all the garbage?
21:49:56 <EvanR> by placing a bound on total memory allowed you get the bounded memor usage
21:50:00 <EvanR> but thats kind of silly
21:50:05 <hanna> EvanR: why is that silly?
21:50:13 <hanna> if you don't have bounded memory you don't need a garbage collection scheme
21:50:21 <colonelj> lawl
21:50:22 <EvanR> ENOMEM would count as a GC working
21:50:48 <EvanR> talking about a practical diff between, give this process 10M to work with and the usual case of "I have 64G of ram"
21:51:07 <EvanR> "but only use 10M usually, sometimes go above for bit then back down"
21:54:03 <EvanR> you also regularly waste space in e.g. C by automatically allocating a bunch of space on the stack that doesnt get released until you return. you use it, dont use it ever again, but may not return for a while
21:54:23 <EvanR> usually not considered a waste or garbage, but it is
21:54:46 <colonelj> presumably it's a lot easier to estimate how much garbage you have than to actually collect it
21:54:59 <Lokathor> what if you reference it later. impossible to know if you will. it's not like we have static analysis tools
21:55:04 <EvanR> if you do, its not garbage
21:55:10 <EvanR> not saying you can detect it
21:55:13 <hanna> garbage collection works by figuring out what memory you still need
21:55:31 <colonelj> nah it works by figuring out what memory you DON'T need
21:55:31 <Lokathor> i'm suggesting that you can detect if a variable is never referenced again :3
21:55:33 <EvanR> im saying allocating it on the stack is easy, but not necessarily efficient with space
21:55:37 <Lokathor> and could theoretically collect it "early"
21:55:41 <EvanR> Lokathor: ... not always
21:55:48 <hanna> anyway I don't see the point in conflating memory leaks and unused variables
21:55:59 <EvanR> i wasnt talking about variables
21:56:01 <Lokathor> not always, but at least part of the time
21:56:07 <Lokathor> oh
21:56:11 <Lokathor> what were you talking about
21:56:18 <EvanR> garbage collection, memory usage
21:56:38 <hanna> but you bring up stack variables that are never accessed again?
21:56:56 <EvanR> this is a tangent brought up by colonelj 
21:57:26 <hanna> colonelj: ‚Äúit works by figuring out what memory you DON'T need‚Äù which GC implementation does this?
21:57:27 <EvanR> not variables, just using a stack for most work
21:57:41 <EvanR> like forth
21:57:45 <hanna> actually that's a trick question
21:57:48 <hanna> because the two are equivalent
21:58:23 <colonelj> well there's the fuzzy part of memory that you might need
21:58:38 <colonelj> if the GC can't guarantee that you don't need it then it can't collect it
21:58:56 <colonelj> e.g. you might happen to have a number that looks like a pointer to something in some dumb GC
21:59:35 <EvanR> put a bit in each heap object which is 1 if you will need it, 0 otherwise :)
22:00:17 <colonelj> that's presumably a joke
22:00:56 <colonelj> that's like reference counting with a global referencer that references all the things
22:01:03 <EvanR> or: it's so stupid it just might work? 
22:01:33 <colonelj> you have the sort of difficult task of figuring out when to flip the bit :D
22:01:39 <EvanR> references existing isnt the same as "will need it"
22:01:54 <colonelj> exactly
22:02:03 <colonelj> circular references and all that
22:02:15 <EvanR> references existing that you can use
22:02:32 <EvanR> from root
22:02:49 <EvanR> totally possible to hold on to stuff "accidentally", just try using haskell hehe
22:03:23 <dramforever> That 1-bit rc thingy?
22:04:28 <EvanR> i was sort of hoping someone would give a pithy reason why it wouldnt work... i guess "figure out when the flip the bit" might be it
22:04:42 <dramforever> allocate: make new object with rc = 0, add_ref: change rc to 1, deallocate: find directly referenced objects that has rc = 0 and deallocate them
22:05:17 <dramforever> RC handles all the single references, your regular tracing GC does the rest
22:05:57 <EvanR> oh youre saying it would work
22:06:23 <hanna> reference counting is not a new concept and it certainly works to some extent, C++ does this
22:06:33 <EvanR> this isnt counting though
22:06:41 <hanna> problem with refcounting is usually lots of redundant reference operations for simple things like this.foo = foo;
22:06:47 <hanna> it's counting with a 1 bit counter, no?
22:06:57 <EvanR> presumably youre manually marking it as done
22:07:09 <EvanR> until some AI is invented that can do it for you
22:07:19 <colonelj> you mean like delete foo;
22:07:33 <EvanR> right, except delete foo is unsafe since you still have foo
22:07:38 <colonelj> oh look manual garbage collection a.k.a. manual memory management
22:07:45 <EvanR> dramforever's plan is safe
22:08:08 <EvanR> yeah, mostly silly
22:09:56 <colonelj> what might be cool in haskell is some way to say delete this, and then it would go off and finish all the computations that use it so it can be GC'd
22:10:21 <EvanR> time travel?
22:10:33 <colonelj> no I meant all the unevaluated thunks
22:11:21 <hanna> what I would find potentially interesting in haskell is the ability to do scoped allocation of fixed values
22:11:29 <hanna> for example say you're writing a web server that processes incoming requests
22:12:31 <colonelj> you mean like RAII?
22:12:47 <hanna> if you could do something like say withRequest :: (Request -> a) -> a where the ‚ÄòRequest‚Äô lifetime is bound to the scope of of the parameter's execution
22:13:01 <hanna> the garbage collector would skip Request completely
22:13:02 <Axman6> I wonder if you could do that with compact regions - one per request (ie, thread), and all data is allocated in that thread's region
22:13:10 <hanna> yeah that's what I was thinking as well
22:13:16 <Axman6> that would work well until some data gets shared with another thread
22:13:23 <hanna> but compact regions still get memcpy()'d by the GC into the other half
22:13:23 <colonelj> yeah I was thinking something similar also^2
22:13:37 <EvanR> compact regions are mutable?
22:13:52 <Axman6> well, appendable
22:13:53 <colonelj> what you want is lots of mini-GCs with their own parts of the data
22:13:54 <hanna> and even though a memcpy is way faster than a GC crawl, a memcpy() can still be prohibitively slow for bulk data
22:14:11 <colonelj> or is that pretty much generational GC..
22:14:22 <EvanR> mini-computations which dont do any GC at all, and everything that goes in or out is copied
22:14:26 <hanna> for example suppose you're processing Gbps of raw frame data that's immutable and has clearly defined lifetime, right now the only way is to use Foreign.Alloc.malloc
22:14:33 <hanna> perhaps using ForeignPtr
22:14:33 <EvanR> C-in-a-box
22:14:50 <Axman6> can't you just use pinned memory?
22:15:05 <hanna> you mean StablePtr?
22:15:07 <hanna> that still has the IO problem
22:15:08 <Axman6> (not too different to malloc I guess, but native)
22:15:10 <Axman6> possibly
22:15:13 <hanna> ideally I'd like a solution that doesn't require IO
22:15:31 <hanna> basically a ForeignPtr under-the-hood
22:15:33 <Axman6> my recollection of this part of memory management in ghc is sketchy at best
22:15:43 <EvanR> i have a misgiving about every frame using a slow allocate - free cycle
22:16:00 <EvanR> like, why not use the same buffer for each frame, and now its like, manual
22:16:04 <colonelj> can't you just preallocate a buffer and use that
22:16:10 <hanna> EvanR: what makes you think a malloc/free per frame is slow? :)
22:16:15 <Axman6> that involves mutation
22:16:17 <colonelj> malloc is slow
22:16:24 <EvanR> slower than GHC 
22:16:26 <colonelj> mutation good
22:16:33 <Axman6> I disagree
22:16:39 <hanna> mutable buffers need to be garbage collected too
22:16:42 <hanna> for example MVector
22:16:45 <Axman6> mutation is sometimes, but very, very rarely necessary
22:16:47 <hanna> in case that's what you were proposing
22:17:12 <hanna> anyway I doubt you'll be able to measure an overhead of a single malloc(size_of_frame) per frame except in the nanosecond scale
22:17:13 <EvanR> i was thinking of Ptr to pinned memory
22:17:14 <colonelj> if you keep using the same one you don't need to let it ever be GCd
22:17:26 <colonelj> nanosecond mallocs???? lol
22:17:26 <hanna> but what I can promise you is that you can measure a memcpy(size_of_frame) ;-
22:17:29 <hanna> ;)
22:18:01 <EvanR> manual memory mysticism says that malloc+free the same thing in a loop is slow :)
22:18:09 <Axman6> allocation in GHC is essentially just incrementing a pointer, so nanosecond malloc is doable (but I'm being very loose here)
22:18:12 <EvanR> and should reuse the buffer
22:18:28 <EvanR> i assume FFI malloc is not using that
22:18:32 <EvanR> probably wrong
22:19:56 <hanna> colonelj: how long does this code take for you? https://0x0.st/0xV.txt
22:20:40 <EvanR> 1 second
22:20:44 <colonelj> 6.5s
22:21:21 <colonelj> anyway that's microseconds level
22:21:40 <EvanR> real    0m1.076s
22:21:59 <hanna> even if I modify it to sporadically write ints to the allocated memory region it runs in <1ms on my machine
22:22:00 <hanna> weird
22:22:06 <EvanR> o_O
22:22:12 <EvanR> impressive
22:22:34 <colonelj> it probably matters how long your PC's been on for
22:22:51 <hanna> uptime 13 days
22:22:54 <EvanR> 121 days
22:22:56 <hanna> memory 40% used
22:23:30 <EvanR> now do it with haskell FFI
22:23:32 <hanna> hmm I think GCC is eliminating this for some reason
22:23:38 <EvanR> lol
22:23:45 <EvanR> how in the world
22:24:18 <hanna> yeah with -O0 I can measure it
22:24:36 <hanna> now I get 3.6s for 10 million frames
22:24:42 <hanna> err 1 million
22:24:56 <hanna> 3.6 microseconds
22:25:06 <hanna> but this is also libc malloc()
22:25:33 <colonelj> that's generally what one means when they say malloc
22:25:57 <hanna> anyway my point is that even allocating many Gbps of raw texture frames is fine
22:26:17 <hanna> colonelj: well in this context we were just talking about allocating frames in haskell in general, not necessarily via Foreign.Alloc
22:26:32 <hanna> presumably GHC could also do stable allocations of large data, possibly even faster
22:26:56 <colonelj> sounds like you don't know
22:27:01 <EvanR> i believe in ghc's ability to dump me large immutable blobs
22:27:35 <colonelj> me too but not by choice
22:27:37 <EvanR> they dont contain pointers so... 
22:27:45 <EvanR> should collect nicely
22:37:57 <hanna> conal: how come in https://hackage.haskell.org/package/Boolean-0.2.4/docs/Data-Boolean.html e.g. ifB :: bool ~ BooleanOf a => bool -> a -> a -> a  -- why not just write ifB :: BooleanOf a -> a -> a -> a  ?
22:41:56 <piyush-kurur> ezyang: ping
22:45:15 <EvanR> n years ago, it was common knowledge that haskell will never have dependent types
22:45:30 <EvanR> today, it is common knowledge that haskell will never have a totality checker!
22:45:56 <EvanR> so ive learned to treat knowledge of never existence as a christmas wish list
22:46:28 <hanna> haskell will never have a rank 2 type solver!
22:46:36 <dramforever> EvanR: Or, you know, you could just try to make Idris better
22:47:26 <piyush-kurur> EvanR: Okey let me say something Haskell can never cure cancer. If we follow your theory then I have planted the seeds for cancer cure
22:47:45 <EvanR> i think were on the same page here
22:47:49 <AlecTaylor> Hi
22:49:03 <EvanR> rank 2 solver probably (not-) happen strictly after the cancer cure doesnt happen
22:49:28 <piyush-kurur> EvanR: :-)
22:49:32 <EvanR> the power of negativity
22:50:13 <AlecTaylor> What's the concept of having a list of functions then applying them all to the same variable, adding each to other?
22:50:23 <AlecTaylor> Do I just make a big partial?
22:51:07 <Maxdamantus> > map ($ 4) [(5+), (5*), (5/)]
22:51:09 <lambdabot>  [9.0,20.0,1.25]
22:51:14 <Axman6> AlecTaylor: can you add some types to that sentense?
22:51:20 <piyush-kurur> EvanR: https://existentialtype.wordpress.com/2015/01/27/the-power-of-negative-thinking/ 
22:51:41 <Axman6> you have [a -> a] and want a -> a, or a -> [a]?
22:51:46 <AlecTaylor> No
22:52:05 <Axman6> I
22:52:13 <Axman6> I'm also not sure what a "partial" is
22:52:30 <AlecTaylor> [add2, add3, doublenum]
22:52:51 <AlecTaylor> And I want to pass in `5`
22:53:05 <Axman6> and get?
22:53:09 <AlecTaylor> And get out 15
22:53:30 <AlecTaylor> Is that like a rightReduce or something?
22:53:42 <AlecTaylor> foldr?
22:53:47 <Maxdamantus> Looks like left reduce to me.
22:54:06 <Maxdamantus> Wait, left reduce on that would be 10.
22:54:12 <AlecTaylor> Yeah 
22:54:17 <Maxdamantus> Okay, right reduce then.
22:54:40 <AlecTaylor> Dammit, I'll have to reverse this list first :(
22:54:50 <AlecTaylor> Why oh why isn't a finger tree used 
22:54:56 <AlecTaylor> :P
22:55:30 <Maxdamantus> > foldr ($) 5 [(2+), (3+), (2*)]
22:55:33 <lambdabot>  15
22:56:03 <AlecTaylor> Yeah 
22:56:15 <Axman6> > let run xs x = foldr (\f y -> f y) x xs in run [(+2),(+3),(*2)] 5
22:56:17 <lambdabot>  15
22:56:38 <Maxdamantus> > foldr id 5 [(2+), (3+), (2*)]
22:56:39 <Axman6> (yeah, a.k.a, flip (foldr ($))
22:56:40 <lambdabot>  15
22:57:41 <dramforever> > foldr (.) id [(2+), (3+), (2*)] 5    -- Maybe this will make a bit more sense?
22:57:43 <lambdabot>  15
23:02:25 <colonelj> do people generally actually use flip in code?
23:03:07 <hanna> sometimes
23:03:31 <hanna> flip foo smallExpr $ bigExpr, possibly spanning lines
23:04:02 * dramforever wouldn't do that
23:04:09 <colonelj> yeah I was thinking of doing that, but not sure if it's a good idea
23:04:32 <colonelj> like I have "runState (big ol' computation) rng"
23:04:54 <colonelj> and I could write flip runState rng $ le computation goes here...
23:05:12 <colonelj> arguably the arguments to runState are backwards
23:05:38 <colonelj> or maybe not if it means run X in state Y
23:07:40 <colonelj> what's the precedence level of `my_operator`
23:08:01 <colonelj> iirc $ is 10
23:08:23 <johnw> colonelj: the problem is really that runState isn't a normal function
23:08:24 <colonelj> no wait, function application is 10
23:08:26 <johnw> 'runState s' just unwraps the newtype wrapper from 's', which reveals a function that takes a state value
23:08:50 <colonelj> johnw: oh ok thanks makes sense
23:08:56 <ertes> colonelj: most of my usage is with run* functions
23:09:01 <cocreature> ^ that
23:09:06 <ertes> colonelj: flip evalStateT s0 $ ‚Ä¶
23:09:09 <johnw> yeah, it makes sense from Haskell's point of view, but I'd rather there was a regular function version that had the right order
23:09:15 <johnw> I use "flip runState" 99% of the time
23:10:09 <Axman6> yeah I use flip a lot when writing pointfree code (but acoid things being too complicated)
23:10:23 <hanna> yeah, the `transformers` functions are pathological examples
23:10:30 <ertes> > map length ["flippedRunStateT", "flip runStateT"]
23:10:32 <lambdabot>  [16,14]
23:10:41 <johnw> haha
23:10:50 <hanna> I would also prefer those the other way around
23:11:06 <johnw> i would have chosen: x <- state 10 $ do ...
23:12:02 <ertes> i happen to use 'mempty' as the initial state most of the time, so i would actually like to have a special case for that
23:12:14 <johnw> mstate $ do ... :)
23:12:17 <hanna> the one case I can think of where this version of evalState etc. is useful is if you want to eta-reduce a function that uses the user-specified argument as the initial state
23:12:20 <colonelj> oh yeah, precedence for `my_op` what is it??
23:12:22 <hanna> but I find this to be exceedingly rare in my own code
23:12:34 <johnw> colonelj: you can use ':i my_op' in ghci
23:12:51 <colonelj> :i `flip`
23:13:01 <johnw> not here
23:13:13 <ertes> colonelj: if unspecified, it's infixl 9 (GHCi won't show you)
23:13:41 <ertes> but you can set precedence for alphanumeric names, too
23:13:49 <ertes> infixl 6 `my_op`
23:13:53 <colonelj> that's cool (and confusing?) I didn't know that
23:15:05 <colonelj> what else is precedence level 9?
23:16:01 <ertes> almost all alphanumeric names have the default precedence‚Ä¶  it's rarely specified (unfortunately)
23:16:05 <ertes> example: 'ap'
23:16:32 <colonelj> I meant the non-alphanumeric ones to be more specific
23:17:01 <colonelj> I reckon giving precedence levels to alphanumeric operators is potentially confusing
23:17:07 <ertes> infixl 9 is actually quite rare for symbolic names, as far as i know
23:17:14 <ertes> (.) is infixr 9
23:17:38 <ertes> it's not really any more confusing than for symbolic names =)
23:17:54 <colonelj> well at least there's some conventions to follow
23:19:44 <colonelj> going back to 'flip' I feel like all the functionals are backwards compared to my language where I tend to put the function last
23:20:09 <colonelj> map obj (\x -> whole buncha code)
23:20:22 <colonelj> seems to make more sense
23:20:34 <ertes> not when you consider composability
23:20:39 <colonelj> except that being a prefix language, yeah...
23:20:56 <colonelj> wait you might need to give an example
23:21:06 <hanna> I like to call that ‚Äúfor‚Äù, but unfortunately ‚Äúfor‚Äù is the equivalent of flip traverse
23:21:14 <hanna> which IMO should be forM
23:21:17 <hanna> but oh well
23:21:24 <ertes> map takes two kinds of arguments: the "how" and the "what"
23:21:35 <colonelj> oh right yeah, in my language it's postfix so it curries in the last argument first
23:21:43 <ertes> you would want to take the "what" as the last argument
23:21:44 <colonelj> so it makes even more sense for the function to go last
23:21:47 <ertes> because then you can easily compose
23:22:00 <hanna> clearly we need type-directed argument commutation where you can just write ‚Äúmap f list‚Äù or ‚Äúmap list f‚Äù and it will infer to the correct version based on the only thing that makes sense
23:22:08 <hanna> hell you could do that with type classes I'm pretty sure
23:22:46 <colonelj> they do something like that in Jane Street's OCaml Core using named arguments
23:22:58 <ertes> hanna: 'map' is a rare example though
23:23:07 <ertes> even for 'fmap' it's no longer possible
23:23:36 <hanna> would be possible for runState but only because the reverse would be an infinite type
23:25:14 <hanna> (and not something a type class could decide, I'm pretty sure)
23:25:30 <hanna> actually you probably could with overlapping type classes or liberal (ab)use of type families
23:25:54 <hanna> type family isFlipped arg1 arg2 arg3 where -- implement arbitrary logic
23:26:00 <hanna> :: Bool
23:26:10 <hanna> so you could use any sort of heuristic you want :D
23:26:12 * hanna runs and hides
23:27:50 <hanna> let's try it
23:29:14 <colonelj> is it better to use showString "Hello " or "Hello " ++
23:30:16 <colonelj> :src showString
23:30:38 <colonelj> :list showString
23:30:39 <pacak> If you care about performance - you don't use string.
23:30:46 <colonelj> forgotten what the command is
23:30:51 <pacak> If you don't care about performance - you use whatever is more readable.
23:31:20 <colonelj> I'm not sure that one is more readable than the other though, it's just one is longer
23:31:47 <pacak> ++ is more readable to me.
23:32:07 <colonelj> I guess performance wise it's just adding some chars to the front anyhow
23:32:23 <colonelj> however I'm better off using shows than show blah ++
23:33:58 <colonelj> so "For parameters " ++ shows params ":"
23:34:20 <colonelj> I guess it's the mixing of ++ with shows that is a bit weird
23:37:43 <EvanR> :t showString
23:37:44 <lambdabot> String -> ShowS
23:38:05 <liste> @src ShowS
23:38:06 <lambdabot> type ShowS = String -> String
23:38:14 <EvanR> if you care about performance you still might want to write a proper Show instance
23:38:43 <EvanR> which is all based on String
23:39:10 <colonelj> @src showString
23:39:10 <lambdabot> Source not found.
23:40:11 <EvanR> showString      =  (++)
23:42:18 <colonelj> damn it I want zipWithM_ and friends for Data.Vector and friends
23:42:58 <EvanR> :t zipWithM_
23:42:59 <colonelj> is there a way to do it without using Data.Vector.toList?
23:42:59 <lambdabot> Applicative m => (a -> b -> m c) -> [a] -> [b] -> m ()
23:43:08 <cocreature> colonelj: https://hackage.haskell.org/package/vector-0.12.0.1/docs/Data-Vector-Generic.html#v:zipWithM_
23:43:16 <EvanR> perhaps write a zipWithM_ for Foldables
23:43:28 <colonelj> n1 cocreature 
23:44:02 <jasonh> Hi, I am using Data.Binary for decoding network packet data, and the packet length can affect the decoding, remaining can do that, but is deprecated, and I do not need to know the total length, I only need to know it's longer than 8 bytes or not, can anyone help me? Thank you in advance.
23:44:05 <cocreature> colonelj: http://hoogle.haskell.org/?hoogle=zipWithM_%20package%3Avector is great for finding stuff like this
23:45:26 <pacak> jasonh: Use attoparsec? O_o
23:45:32 <hanna> https://0x0.st/0x3.txt
23:45:38 <hanna> A great sin has been committed this day
23:46:10 <jasonh> pacak: No
23:46:32 <jasonh> pacak: Only Data.Binary for packing and unpacking data
23:54:41 <EvanR> so MagicClasses not only get closure to more flexible selectors, and other kinds of accessors for records... 
23:54:48 <EvanR> s/closure/closer/
23:55:01 <EvanR> they might enable anonymous records
23:56:08 <colonelj> EvanR: I think you were right about printing the callstack, it prints it anyway, so I just get it printed out twice, except the first one is shorter
23:56:25 <EvanR> i wasnt the one who questioned that but was thinking it
23:56:36 <colonelj> it wasn't working before because I didn't use HasCallStack
23:56:46 <colonelj> and used my own implicit variable
23:58:12 <jchia> I have a data structure design question. Could someone look at these 20 lines and comment? http://lpaste.net/356694
23:59:11 <colonelj> it was you 05:04 < EvanR> manually putting callstacks in the string of an error O_o
23:59:56 <EvanR> yeah, what i was thinking at the time was "error already throws up a callstack by default" which other people said explicitly
