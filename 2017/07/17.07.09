00:00:35 <iqubic> So what tiling window managers should I try next?
00:01:59 <mryandao> ls
00:02:08 <mryandao> oops, typo
00:04:01 <dmwit_> I guess a window mistake would be a "windo"?
00:04:43 <mryandao> iqubic: i3 is pretty good.
00:05:09 <iqubic> I've already tried it. I don't like it.
00:12:41 <iqubic> Honestly, I feel it has too many window decorations.
00:13:19 <Myrl-saki> XMonad is not a complex thing to configure, IMO. Rather, it's a complex thing to understand. I have no idea which is which.
00:13:49 <Myrl-saki> Rather, what connects to what.
00:15:23 <iqubic> What do you mean?
00:15:33 <hanna> i've been using xmonad successfully for several years and I don't really understand its operation either. I don't think it's really necessary
00:15:36 * pacak likes xmonad
00:16:13 <hanna> The changes I need to make for the purposes of customizing its behavior don't require knowledge of what a “manage hook” or “log hook” actually is/does
00:16:59 <iqubic> What's a manage hook?
00:17:49 <hanna> iqubic: am I understanding correctly that you are switching window managers in order to avoid seeing a red squiggly line in your IDE?
00:18:17 <iqubic> More or less.
00:19:17 <iqubic> Actually that's exactly what's going on
00:19:37 <hanna> Perhaps you should switch editors to one that doesn't show red squiggly lines underneath perfectly valid imports
00:20:03 <iqubic> I guess I should. But emacs is just so perfect for me.
00:20:24 <hanna> I'm sure many people use emacs just fine without having it print red squiggly lines underneath perfectly valid imports
00:21:29 <iqubic> Well I'm using emacs to edit my xmonad.hs and it can't find the xmonad libs.
00:21:39 <sm> iqubic: here's the solution. Give up on the red squiggly lines. Use ghcid to find the errors instead
00:22:31 <iqubic> But how do I give up on them?
00:23:40 <sm> iqubic: I guess turn off whatever half-baked emacs IDE plugin you've installed
00:24:09 <sm> for this one project at least
00:24:12 <iqubic> I don't want to stop using emacs and I don't want to uninstall ghc-mod or intero, because
00:24:42 <iqubic> sm: I'm using ghc-mod and intero. I don't think those are half-baked.
00:25:03 <sm> I think they are, really. No offense to them, but as you see they don't "just work"
00:25:04 <hanna> If they misidentify perfectly valid imports as errors, they can't be that good
00:25:04 <MarcelineVQ> doesn't intero make ghc-mod redundant?
00:25:45 <hanna> iqubic: If it somehow makes it happier, maybe you could write a .cabal file or whatever is necessary for your xmonad config
00:26:19 <iqubic> hanna: I might just to that.
00:26:34 <iqubic> MarcelineVQ: I'm not sure. I don't know if that's true
00:27:29 <sm> iqubic: ok, since I have failed to scare you off, you must: dig in and figure out why it's doing that and fix it and share the solution :)
00:27:58 <iqubic> I don't know how to fix this though
00:28:25 <hanna> (Figuring that out is part of the process of fixing something)
00:28:43 <sm> obviously, and maybe nobody here does, but maybe you can figure out a small step forward ?
00:29:07 <sm> look at the intero code and see how it decides those imports should be red ?
00:29:12 <MarcelineVQ> step one, figure out if it's ghc-mod or intero reporting the error
00:29:44 <iqubic> How can I do that?
00:30:05 <iqubic> I use spacemacs, so I can't easily turn one or the other off.
00:30:28 <jle`> is there a ConstT somewhere
00:31:30 <iqubic> jle`: Perhaps
00:31:37 <iqubic> @index ConstT
00:31:37 <lambdabot> bzzt
00:33:36 <cocreature> jle`: what would that be good for?
00:36:07 <jle`> i need to write a (forall a. Foo a -> WriterT Bar Baz a), but basically ignoring the 'a' parameter
00:36:22 <jle`> all i care about is the accumulated Bar
00:36:29 <jle`> from a `forall a. Foo a`
00:36:47 <jle`> i would execWriter at the end of it all and never use the result
00:36:55 <jle`> i could use writer and 'return undefined'
00:38:59 * hackagebot chatwork 0.1.1.0 – The ChatWork API in Haskell – https://hackage.haskell.org/package/chatwork
00:39:07 <jle`> i suppose i could just do Const [f w] a instead of ConstT w f a
00:39:09 <hanna> `Const` *is* a monad, so maybe you can use `Const Bar a` instead of `WriterT Bar Baz a`? Or does the type of whatever you're using require it to be a monad transformer?
00:39:27 <hanna> Oh, you need to access effects in Baz?
00:39:36 <jle`> and then `mappend . sequence` the [f w]
00:39:41 <jle`> yes
00:39:50 <glguy> it's not a monad
00:39:54 <jle`> the effects of Baz-the-Monad is important here
00:40:01 <jle`> and yes Const is no monad
00:40:34 <hanna> Oh, can't write `join`
00:40:40 <jle`> yes what i wish is basically Const [f w] a, and then `fmap mappend . sequence' the resulting [f w]
00:40:46 <jle`> you can't write >>= either :o
00:40:58 <jle`> where would the 'a' come from for the (a -> Const w b) ?
00:41:04 <jle`> hm
00:41:08 <jle`> i suppose you could write one that typechecks
00:41:11 <cocreature> undefined! :)
00:41:23 <hanna> I'm wondering.. what about Const (Baz Baz) a ?
00:41:30 <hanna> Baz Bar even
00:41:44 <jle`> you'd have to wrap it in some newtype wrapper
00:41:44 <hanna> but nah that won't work because it needs a monoid instance for Const to be an applic-- and it still isn't a monad
00:41:49 <jle`> where mappend = liftA2 (<>)
00:41:54 <hanna> yeah
00:41:59 <jle`> there might be one out there
00:42:01 <jle`> which would be nice
00:42:02 <hanna> Okay, convinced - make your own ConstT :D
00:42:11 <jle`> i always wanted such a newtype wrapper, though
00:42:20 <hanna> Or perhaps avoid the use of an API that forces you to return an ‘a’ that you don't care about
00:42:56 <jle`> it comes from those libraries that take a rank-n (forall a. f a -> g a) for some Applicative f/g
00:43:01 <jle`> like lens
00:43:03 <jle`> and friends
00:43:17 <jle`> lens uses it to implement 'view' and stuff like that
00:43:38 <jle`> um i guess not lens in specific
00:45:35 <jle`> but yes a better thing that i would like is to have that newtype wrapper somewhere in base maybe
00:46:26 <hanna> in lens your ‘g’ never really needs to be more than applicative
00:46:32 <hanna> so you can use Const just fine
00:46:41 <hanna> which is exactly what lens does
00:46:44 <jle`> i can use const
00:46:57 <jle`> but for me i'd have to fmap mappend . sequence the result
00:47:52 <hanna> hmm how does lens solve this problem
00:48:14 <jle`> lens doesn't need to do this specific thing
00:48:39 <hanna> http://hackage.haskell.org/package/lens-4.15.3/docs/Control-Lens-Fold.html#t:Traversed aha
00:48:47 <hanna> it defines a newtype that has a Monoid instance ;)
00:48:57 <jle`> but like, this is the same basic procedure of 'hijacking' (forall f. Applicative f => f a -> ...) functions to do new and brave things
00:49:06 <jle`> s/new and brave/useful one-off
00:49:20 <hanna> jle`: lens has this exact problem when it needs to implement `traverseOf`
00:49:29 <jle`> :o
00:49:45 <quick_dudley> Does lens provide any type along the lines of `forall f . Applicative f => (a -> f b) -> s -> f t`?
00:49:50 <hanna> consider the type traverseOf_ :: Functor f     => Getter s a     -> (a -> f r) -> s -> f ()
00:50:12 <hanna> `Getter` in lens is basically the equivalent of using Const as your ‘g’
00:50:37 <hanna> And it does this by constraining the ‘g’ to be Const (Traversed r f)
00:50:44 <hanna> where Traversed is the monoid-that-wraps-an-applicative
00:52:33 <jle`> i like to believe my hack is slightly more principled
00:53:29 <jle`> but i know i'm full of myself too :)
00:53:34 <hanna> which hack?
00:54:34 * hackagebot pdfname 0.1.2 – Name a PDF file using information from the pdfinfo command – https://hackage.haskell.org/package/pdfname
00:54:36 <hanna> and yes I think `newtype LiftedMonoid f m = LiftedMonoid (f m); instance (Applicative f, Monoid m) => Monoid (LiftedMonoid f m) where mempty = pure mempty; mappend = liftA2 mappend` would be a fine solution
00:54:55 <hanna> together with using `forall a. Foo a -> Const (LiftedMonoid Baz Bar) a`
00:55:13 <hanna> nothing hacky about it
00:55:39 <hanna> hmm
00:55:43 <hanna> Surely this *must* exist
00:56:01 <hanna> I mean how long have people been writing instance Foo where foo = fmap foo; bar = liftA2 bar etc. for?
00:56:08 <hanna> Heck you could do the translation mechanically
00:56:42 <hanna> Having a single newtype to cover all of these cases (newtype Lifted f a = Lifted (f a); instance (Applicative f, Num a) => Num (Lifted f a);  Monoid, Semigroup, Default, etc.)
00:56:47 <hanna> would almost surely be reused often
00:58:45 <jle`> one newtype to rule them all
01:52:17 <k0ral> Hello
01:52:57 <k0ral> are there some optics available for sized vectors ? (vector-sized, Vector n a)
01:54:18 <k0ral> the standard "ix" returns a traversal, but with sized vector, we could theoretically implement an ix-like that always matches an element
01:54:38 <k0ral> using `Finite n` as index rather than `Int`
02:24:54 <jle`> k0ral: i've been writing my own from scratch
02:25:34 <jle`> but now i do realize that you could put one right into vector-sized
02:25:45 <jle`> but, yes, there is no Lens version of Ixed
02:27:01 <k0ral> I'll consider making a pull request to vector-sized then
02:28:34 <Gurkenglas_> If we have some way to search the logs, searching for a link to lpaste.net/355233 should find a discussion previously had here about this
02:30:10 <k0ral> Gurkenglas_: http://ircbrowse.net/browse/haskell
02:30:26 <Gurkenglas_> k0ral, how do I search that?
02:30:39 <cocreature> ircbrowse is dead
02:31:20 <Gurkenglas> Merely unsearchable, the link is live
02:32:13 <cocreature> dead in the sense of no longer indexing new messages since a few months
02:32:40 <sm> alas :(
02:33:15 <sm> iqubic: did you make any progress on your squiggles ?
02:35:02 <sm> -- -*- eval:(flycheck-mode -1) -*-
02:35:19 <sm> it might be as simple as putting that at the top of your xmonad file
02:36:23 <Gurkenglas> Can we just get google to index the haskell logs by getting "Disallow: /~nef/logs/" out of "http://tunes.org/robots.txt"?
02:47:04 <Athas> Gurkenglas: that would also enable indexing of tons of other IRC channel logs.
02:47:14 <Athas> And many people are queasy about IRC logs in general.
02:48:34 <Gurkenglas> Sure, they can allow only haskell channel logs.
03:19:59 * hackagebot aivika 5.2, aivika-branches 0.3, aivika-distributed 0.6, aivika-lattice 0.3, … and 2 more
03:19:59 * hackagebot  → https://hackage.haskell.org/packages/recent
03:38:24 <Geraldus> Hi friends!
03:40:39 <Geraldus> Is there a way to group conduit data, e.g. I have a Conduit with output values of type `a`.  I want to take N `a`s and perform some bulk IO action on them
03:41:04 <Geraldus> Rather that applying action one by one
03:45:07 <quick_dudley> `runMaybeT (replicateM n (MaybeT await)) >>= yield`, would do it for one block
03:45:38 <quick_dudley> I can't remember whether or not conduit has a function to repeat something until the input runs out
03:46:40 <quick_dudley> Actually: my function is wrong
03:48:04 <Geraldus> quick_dudley: I don't need to repeat anything
03:48:08 <werwe> wewe
03:48:41 <Geraldus> I tried `chunksOf`, but nothing happens
03:48:46 <Geraldus> I have no idea why
03:49:51 <quick_dudley> `replicateM n await >>= yield . catMaybes`. Will be a bit inefficient if the input runs out early, but will do what you're looking for
03:50:56 <Myrl-saki> What data structure should I use? I have a text file that I parse into an AST. The AST's text is editable, and it may change the AST.
03:51:10 <Myrl-saki> I'm thinking of doing some local parsing, and update the AST on that point only.
03:54:11 <quick_dudley> Myrl-saki: Do you mean something like a parser that you can store the full state of after it reads each character?
03:54:54 <cocreature> Geraldus: “nothing happens” is a bit vague. can you give us a bit more details or even a minimal code sample?
04:02:34 <Myrl-saki> quick_dudley: I'll just say what I'm trying to solve. More or less structural editing. Basically, imagine drag and drop programming, but on a text editor. What I want to do different is that text editing should be unaffected.
04:03:15 <Myrl-saki> quick_dudley: I guess what I want is to just have structural navigation, and have editing the same.
04:05:07 <pavonia> So you want to re-parse if structure changes but not if only values within the same structure change?
04:06:04 <Myrl-saki> pavonia: Right.
04:06:13 <Myrl-saki> pavonia: But changing the value in a structure may change the structure.
04:06:22 <Myrl-saki> pavonia: For example, deleting braces.
04:07:00 <quick_dudley> Ok. Maybe you'd want to use something like a zipper
04:07:32 <Myrl-saki> quick_dudley: The next problem. I want it to work with any parser.
04:07:45 <Myrl-saki> I should have said that first.
04:07:51 <Myrl-saki> But yeah, zippers were the very first thing that came into mind.
04:08:05 <Myrl-saki> I was wondering if there's some kind of zipper isomorphism?
04:09:36 <quick_dudley> I guess that depends what you mean by isomorphism
04:12:03 <Myrl-saki> A way to convert a given zipper to any other zipper.
04:16:20 <quick_dudley> I'm not seeing how that would help. I guess for parser integration you'd have to keep track of where in the source code each part of the AST came from in a way that didn't get messed up when characters are inserted and deleted
04:23:07 <quick_dudley> The parser itself would be tricky too because parser libraries tend to assume they're running in a fixed direction
04:25:18 <Geraldus> cocreature: Yeah, I know, sorry.  First I used x <- runResourceT $ src $$ sinkList; print (take 10 x).  Then I switched to src $$ chunksOf 10 $$ mapM_ (liftIO . print).  But this does not give any output
04:26:34 <shafox_> Is there any library that I can use for reading and parsing wikipedia dump file which is multistream bz2 file ?
04:27:56 <JuanDaugherty> mediawiki api?
04:28:21 <shafox_> I have the dump file not using api to get the page.
04:28:47 <JuanDaugherty> i didn't mean to access a live instance
04:31:19 <cocreature> Geraldus: you probably want a .| instead of the $$ at the beginning
04:31:21 <cocreature> Geraldus: e.g.  List.sourceList [1..10] .| List.chunksOf 2 $$ List.mapM_ print
04:34:36 <JuanDaugherty> shafox_, https://www.mediawiki.org/wiki/Wikibase/API also #mediawiki
05:05:12 * hackagebot jsaddle 0.9.3.0 – Interface for JavaScript that works with GHCJS and GHC – https://hackage.haskell.org/package/jsaddle
05:20:22 * hackagebot jsaddle-dom 0.9.1.0 – DOM library that uses jsaddle to support both GHCJS and GHC – https://hackage.haskell.org/package/jsaddle-dom
05:20:22 * hackagebot jsaddle-warp 0.9.3.0 – Interface for JavaScript that works with GHCJS and GHC – https://hackage.haskell.org/package/jsaddle-warp
05:26:27 * hackagebot ghcjs-dom 0.9.1.0, ghcjs-dom-jsaddle 0.9.1.0, ghcjs-dom-jsffi 0.9.1.0
05:26:27 * hackagebot  → https://hackage.haskell.org/packages/recent
05:34:33 * hackagebot ghcjs-dom-jsffi 0.9.1.1 – DOM library using JSFFI and GHCJS – https://hackage.haskell.org/package/ghcjs-dom-jsffi
05:34:33 * hackagebot ghcjs-dom 0.9.1.1 – DOM library that supports both GHCJS and GHC – https://hackage.haskell.org/package/ghcjs-dom
05:49:43 * hackagebot relational-query 0.9.2.0 – Typeful, Modular, Relational, algebraic query engine – https://hackage.haskell.org/package/relational-query
05:49:43 * hackagebot relational-query 0.8.5.0 – Typeful, Modular, Relational, algebraic query engine – https://hackage.haskell.org/package/relational-query
05:50:56 <Myrl-saki> quick_dudley: Right. I'm just thinking of reparsing.
06:42:01 <orion> @pl identityWithUid conn uid = listToMaybe <$> (runQuery conn (identityWithUidQuery uid))
06:42:01 <lambdabot> identityWithUid = ((listToMaybe <$>) .) . (. identityWithUidQuery) . runQuery
06:42:09 <orion> eww
06:43:36 <JazzyEagle> Hey, I have a question for folks...  Trying to iterate through a directory and its tree using System.Directory's listDirectory and then MapM_ through the results, calling one of two functions depending on if the result is a sub-directory or a file...
06:44:29 <JazzyEagle> I know since I'm in the IO Monad I can go isDirectory <- doesDirectoryExist path and then do an if off of isDirectory, but is there a more streamline way to do the conditional?
06:46:28 <cocreature> JazzyEagle: you could use something like https://hackage.haskell.org/package/extra-1.6/docs/Control-Monad-Extra.html#v:ifM but tbh I woud just use do notation and a regular if for this
06:47:10 <JazzyEagle> Out of curiosity, why would you do that, cocreature?
06:47:46 <cocreature> JazzyEagle: because I’m too lazy to define ifM myself and it’s not worth adding a dependency just for that
06:48:09 <JazzyEagle> Fair enough.  Thank you for the feedback!!
06:48:22 <osa1> JazzyEagle: you could also use LambdaCase: `doesDirectoryExist path >>= \case True -> ...; False -> ...`
06:48:29 <Axman6> bool <$> onFile <*> onDirectory <*> isDirectory $ doesDirectoryExist path
06:49:09 <Axman6> hmm, actually, that runs both computations, don't do that
06:49:34 <osa1> there's also a type error I think. you may need to delete $ and use parens
06:50:10 <osa1> hmm no, nvm
06:50:21 <Axman6> @pl (\f -> bool (onFile f) (onDirectory f) (isDirectory f)) =<< doesDirectoryExist path
06:50:22 <lambdabot> ap (liftM2 bool onFile onDirectory) isDirectory =<< doesDirectoryExist path
06:51:18 <Axman6> hmm, not very satisifying, even if you do use  ap = <*> or applicative style for liftM2
06:51:33 <Axman6> actually
06:52:12 <Axman6> ((bool <$> onFile <*> onDirectory) <*> isDirectory) =<< doesDirectoryExist path
06:52:41 <Axman6> (don't do this, unless you want to hate yourself a week later when you read it again)
06:53:09 <JazzyEagle> I wonder if I could do something with a where clause?  I was hoping to use a guard, so I was thinking like checkFile :: FilePath -> IO () \n checkFile path \n | is Directory = scanDir path ...  where isDirectory <- doesDirectoryExist path  ?
06:53:09 <Lokathor> what do i say with "stack bench" to make it generate a fancy report and all that
06:54:29 <Axman6> JazzyEagle: no, where clauses aren't do blocks
06:54:37 <JazzyEagle> Ahhh, ok.
06:54:45 <JazzyEagle> So probably osa1 's solution is probably best, then...
06:54:51 <Axman6> Lokathor: stack bench --benchmark-arguments="-o foo.html"
06:55:01 <Lokathor> cool
06:55:53 <Lokathor> unboxing ints gets me less gains thatn i used to get on this old benchmark :/ when i rerun it with modern ghc
06:56:14 <Lokathor> i still get gains :3
06:56:16 <JazzyEagle> Thanks, everyone!
06:57:26 <Axman6> that's probably because GHC is doing a much better job of onboxing for you
06:57:34 <Axman6> unboxing*
07:04:26 <paolino> hi, just wondering about the Data.Bool.bool ,it would be nice to have it applicative.
07:05:25 <paolino> :t \f g h -> flip (bool f g) <*> h
07:05:27 <lambdabot> (b1 -> b) -> (b1 -> b) -> (b1 -> Bool) -> b1 -> b
07:07:58 <paolino> > map (flip (bool Left Right) <*> (==) 0 . flip mod 3) [1..10]
07:08:00 <lambdabot>  [Left 1,Left 2,Right 3,Left 4,Left 5,Right 6,Left 7,Left 8,Right 9,Left 10]
07:08:18 <Lokathor> Axman6, http://lokathor.github.io/ludolib/ whee
07:09:09 <Axman6> what am I looking at? (other than a criterion report)
07:09:46 <Lokathor> oh, well the code itself is field of view code in various modes at various ranges, Boxed, ST, ST Unboxed
07:10:03 <Axman6> field of view?
07:10:09 <Lokathor> yeah like for a video game
07:11:12 <Axman6> right
07:11:47 <Lokathor> i had the versions sitting around, but not a benchmark that could run all at once side by side
07:11:52 <Lokathor> more like spread across the git history of the repo
07:12:02 <Axman6> I wish I could get the benchmarks running on the thing I'm working on at the moment, I made a function 100x faster :)
07:12:25 <Lokathor> a guy was like "oh unless you have a benchmark available this very instant you can't possibliy make speed claims, it'd be irresponsible!"
07:12:34 <Lokathor> so i put it all in one spot
07:12:48 <Axman6> nice
07:13:02 <Lokathor> they just don't like that code runs faster when you write your Haskell like it's C :P
07:13:21 <Axman6> yeah, my faster code is very much C in Haskell code
07:13:41 <Lokathor> some haskell folks get really upset about imperative haskell for some reason :/
07:14:41 * hackagebot basic-cpuid 0.1.0.0 – A small package to access the cpuid instruction directly. – https://hackage.haskell.org/package/basic-cpuid
07:19:48 <Lokathor> wow, one single criterion HTML file and the repo is now 80% HTML
07:32:53 * hackagebot text-all 0.4.1.0 – Everything Data.Text related in one package – https://hackage.haskell.org/package/text-all
07:38:13 <Lokathor> reallyUnsafePtrEquality#
07:38:18 <Lokathor> delightful
07:40:43 * hanna .oO( https://github.com/mmirman/ImperativeHaskell/blob/master/Main.hs )
07:41:22 <Lokathor> see this doesn't look as good though
07:41:30 <Lokathor> i don't want them braces
07:42:18 <Lokathor> i like that you can defer the io
07:42:22 <Lokathor> i guess that's neat
07:53:48 <mpickering> What could the possible cause of a "Bad File Descriptor" error be? this might not be a haskell question I guess
07:54:07 <Lokathor> did you try to use a file as a directory, or the reverse?
07:54:55 <sepakorayl> guys what's the difference between llvm-general and llvm-hs ?
07:56:02 <mpickering> Lokathor: that might be plausible, it is ghc-pkg which is throwing this error not one of my programs though so I'm finding it a bit harder to debug
07:56:13 <Lokathor> llvm-hs seems newer?
07:58:09 <sepakorayl> ah it's a fork
07:58:19 <sepakorayl> it says so in the github repo
08:41:38 * hackagebot stratosphere 0.4.4 – EDSL for AWS CloudFormation – https://hackage.haskell.org/package/stratosphere
08:45:30 <zomg> Wasn't there some tool to enforce sort of good haskell coding styles?
08:45:41 <zomg> I was looking to perhaps publish some of my cryptocoin stuff on github since there was some interest
08:45:52 <MarcelineVQ> check out hlint and hindent
08:46:03 <zomg> but I've not really done that much haskell so want to make sure at least the obvious easy issues won't bother anyone :D
08:46:09 <zomg> cool will check those out,thanks :)
09:14:38 <zomg> MarcelineVQ: 158 hints from hlint :P nice
10:02:18 <spinus> I'm running runStateT with X as state, runStateT is run inside WidgetMonad, if I run lift to use "get" I get error:
10:02:19 <spinus> "Could not deduce: m
10:02:19 <spinus>                         ~
10:02:19 <spinus>                         Control.Monad.Trans.State.Lazy.StateT (ApplicationState t) m0"
10:02:19 <spinus> How I can annotate lift to solve that?
10:06:57 <lyxia> spinus: can you give more context
10:07:48 <lyxia> What's WidgetMonad? Can you paste some of the code around which you are using get?
10:08:08 <spinus> lyxia: sure, give me sec, I'll prepare 'paste'
10:17:22 <spinus> lyxia: http://lpaste.net/356820
10:18:00 <spinus> MonadWidget comes from https://hackage.haskell.org/package/reflex-dom-0.3/candidate/docs/Reflex-Dom-Class.html#t:MonadWidget
10:23:57 <spinus> I assume this could be more general question, how to nest lifts
10:27:42 <MitchellSalad> for starters, turn on -XScopedTypeVariables
10:28:15 <MitchellSalad> also, a type sig on 'render_page' and 'render_application' would help
10:28:15 <spinus> have it
10:28:30 <spinus> ok, trying
10:28:33 <MitchellSalad> k
10:36:56 <lyxia> You probably shouldn't be using get inside lift.
10:37:06 <spinus> MitchellSalad: http://lpaste.net/356820
10:37:31 <spinus> lyxia: how to do it other way?
10:37:56 <lyxia> spinus: for the type annotation you can write render_application :: _ instead and the compiler will tell you whatever it infers for "_"
10:38:19 <spinus> ah, let me check
10:38:43 <lyxia> spinus: replace   lift $ do state <- get ...   with   state <- get   ? I don't understand what you're trying to do here because of the return ().
10:39:19 <spinus> I'm just trying to "get" data from StateT
10:40:12 <spinus> lyxia: if I do what you suggested, which is using "state <- get" in render_page function, I have
10:40:19 <spinus> Could not deduce: m ~ StateT a0 m0
10:40:19 <spinus>       from the context: R.MonadWidget t m
10:40:19 <spinus>         bound by the type signature for:
10:40:19 <spinus>                    render_page :: R.MonadWidget t m => D.Page -> m ()
10:40:47 <lyxia> spinus: from line 1 it looks like StateT is already the topmost layer of your stack, so using lift to get that state would be incorrect..
10:41:18 <MitchellSalad> spinus: use "method 1", but lift the calls to 'R.text'?
10:41:41 <lyxia> spinus: It's hard to tell whether that's because I misunderstood what you were trying to do, or whether the type signature of render_page is wrong.
10:41:54 <lyxia> spinus: note that is makes no mention of state.
10:42:16 <spinus> lyxia: I think MonadWidget is the topmost (but not sure)
10:43:02 <MitchellSalad> spinus: MonadWidget isn't a transformer, so your stack is StateT MyState MyWidget
10:43:11 <lyxia> spinus: the "stack" is "StateT (ApplicationState t) m"  <- StateT is at the top.
10:43:57 <spinus> mhm
10:44:53 <spinus> MitchellSalad: I used did method1 as you suggested, and lifter R.text, 1 R.text worked, but there is error on the second one 
10:44:53 <spinus> Could not deduce: m ~ StateT (D.ApplicationState t0) m0
10:44:53 <spinus>       from the context: R.MonadWidget t m
10:45:48 <spinus> btw, when I remove 'get' it works, which I assume I'm in MonadWidget, is that right?
10:46:03 <spinus> so I thought I need to use "lift" to get StateT
10:46:22 <andromeda-galaxy> Does anyone know why "Typed brackets may only appear in typed splices."?
10:47:26 <andromeda-galaxy> AFAICT it isn't possible to make a typed declaration splice, so is there any way to let a user pass arguments to a declaration splice using typed brackets?
10:48:39 <andromeda-galaxy> (also is there an equivalent of ''Name that is actually typed?
10:48:43 <andromeda-galaxy> )
10:51:30 <spinus> lyxia: thanks, :: _ did the job
10:51:39 <spinus> I mean, found what the type should be
10:51:55 <spinus> render_page still fails on using "get"
10:55:34 <lyxia> MonadWidget doesn't have a lot of instances. If you have MonadWidget t m, you don't have MonadWidget t (StateT s m), I don't know whether that's by design.
10:56:09 <spinus> lyxia: so I could implement that and would that help do you think?
10:57:09 <lyxia> So if you're going to layer StateT on top of this, my guess is render_page would have type (... => Page -> StateT (ApplicationState t) m ()), which means that you don't need lift for get, but you do need to lift all MonadWidget methods.
10:58:14 <orion> If I have an Arrow defined as: foo = proc (bar) -> ..., how do I call it from a regular function?
10:58:30 <spinus> this will be very hard, because most of my code is MonadWidget, and I need to access state in few places, refactoring code around that will be terrible :)
11:02:20 * hackagebot pid1 0.1.1.0 – Do signal handling and orphan reaping for Unix PID1 init processes – https://hackage.haskell.org/package/pid1
11:08:28 <ph88> writing loops always was a nobrainer with folds i have to think much harder
11:09:46 <monochrom> So write the loop version first, then mechanically convert it to fold.
11:11:04 <kinaesthetician> http://lpaste.net/7063927424626458624
11:11:04 <ph88> mechanically ?
11:11:27 <lyxia> or don't write folds at all
11:11:41 <ph88> recursion is easier at least
11:11:42 <monochrom> mechanically.
11:12:04 <kinaesthetician> *test*
11:12:19 <monochrom> test failed. please try again later.
11:12:22 <kinaesthetician> monochrom: how did you bold
11:12:33 <monochrom> depends on client software.
11:12:44 <kinaesthetician> o i'm using l'internet
11:13:21 <monochrom> OK, you're looking for a generic formula.
11:13:33 <monochrom> So I'll describe a generic formula.
11:13:44 <ph88> kinaesthetician, if you have "[ "  then you get 2 nested branches with only 1 branch in each of them  .. it's ugly
11:14:01 <kinaesthetician> ph88: it doesn't even type check
11:14:15 <monochrom> Find a website that has logs for this channel. The topic line has one or two, I think.
11:14:16 <ph88> i'm not a type checker
11:14:30 <monochrom> Save the log to a file on your disk.
11:14:52 <monochrom> Use a hex editor to find out what bytes are around my bolded "mechanically".
11:15:06 <monochrom> Convince your IRC client to emit those bytes. Done.
11:15:13 <kinaesthetician> ph88: I'm not sure what you're saying
11:15:23 <monochrom> Piece of cake, no? That's what you get when you ask for a generic formula.
11:15:39 <monochrom> So general it is utterly unoptimized for you.
11:16:30 <monochrom> Just like abuses of type classes in Haskell.
11:16:35 <ph88> kinaesthetician, well i can not help you think, that's up to you, i'm only talking about your code
11:17:33 <kinaesthetician> ph88: o I probably should have a mention of what the input's supposed to look like ;  "[ [ 1 [ 1 2 ] ] 3 ]"  i want to become B [ [ L 1, B [ L 1, L 2] ], L 3]
11:17:47 <ph88> kinaesthetician, when you encounter [ you don't save important information that you have entered some kind of scope .. it's doing the same as " "
11:18:06 <kinaesthetician> Yes
11:18:10 <kinaesthetician> I realized that
11:18:12 <monochrom> This "data Tree a = B [Tree a] | L a" has been highly popular and persistent this past week.
11:18:21 <kinaesthetician> It's all me lmao
11:18:29 <kinaesthetician> probably
11:18:37 <kinaesthetician> I've been on here like every other day
11:18:47 <kinaesthetician> It's been a lot of help
11:18:59 <ph88> kinaesthetician, when you encounter [ then supply it the empty list as accumulator, when you encounter ] then stop accumulating and pass it back to the higher level
11:19:41 <kinaesthetician> ooo that's what the other user was probably trying to tell me
11:19:53 <ph88> kinaesthetician, without accumulator you can not pass around the state what you need to remember for the [  ] scoping
11:20:19 <monochrom> Why is the type not "[Char] -> Tree Integer"?
11:20:20 <ph88> i have to go, good luck
11:20:27 <kinaesthetician> ok can you elaborate a bit more on what you mean by "supply it the empty list as accumulator"? 
11:20:29 <kinaesthetician> o
11:20:31 <kinaesthetician> ok bye
11:20:44 <ph88> you make a helper function
11:20:52 <ph88> helper [] some other stuff here
11:21:00 <ph88> in the case of   [
11:21:28 <kinaesthetician> monochrom: really I think the end input might actually be something like " [ 4,1 4,5 4,7 ] "
11:21:30 <ph88> in the case of digit it will be like    blablab acc = newStuff : acc
11:21:49 <ph88> acc maybe is empty when the previous char was [
11:21:57 <ph88> if it was a digit then acc already has stuff
11:22:15 <kinaesthetician> monochrom: but I'm still deciding if I can simplify this down. Really it's musical pitches, so I have to indicate octave along with pitch-class.
11:22:19 <ph88> sorry i can not explain it clearly right now, bit rushing the typing since my train is arriving :P
11:22:22 <ph88> bai bai
11:22:27 <kinaesthetician> bye thanks!
11:22:49 <kinaesthetician> I think I understand
11:24:51 <monochrom> But you are not going to have "Tree a". At best you have "Tree Integer" or "Tree Pitch" or something ungeneralized.
11:24:51 <kinaesthetician> monochrom: For example, I'm considering having the last used octave indicator (first number) carry over into the others until changed like "4,1 5 7" but I mean I guess in the end the L itself will contain a tuple
11:25:19 <kinaesthetician> Yes you are correct
11:25:31 <kinaesthetician> Do you think in practice it's better to be specific like that?
11:25:34 <monochrom> Do not go for [Char]->Tree X directly. Do these two things first.
11:26:16 <monochrom> 1. parseTree :: [Char] -> (Tree X, [Char]).  The second [Char] is for "the rest of the string, i.e., the suffix I haven't parsed yet".
11:26:52 <monochrom> 2. parseList :: [Char] -> ([Tree X], [Char]). Ditto.
11:27:20 <monochrom> The second function is for the "B [Tree X]" case.
11:27:28 <kinaesthetician> aha yes
11:28:34 <monochrom> This "String -> (Answer, String)" technique is how virtually all Haskell parser libraries do it.
11:28:56 <kinaesthetician> wait, shouldn't the input need to be a tuple also since it's recursive?
11:29:14 <monochrom> "since" is wrong.
11:29:36 <kinaesthetician> ?
11:29:40 <kinaesthetician> it's not recursive?
11:30:09 <monochrom> recursive descent parser does not imply (Answer, String) for the input.
11:30:31 <monochrom> String -> (Answer, String) is exactly right.
11:30:46 <monochrom> (Unless you want parse errors to be handle gracefully.)
11:30:57 <kinaesthetician> but you must output the tuple for a pattern, so how would you keep the recursion going?
11:31:09 <kinaesthetician> OOO
11:31:10 <kinaesthetician> wait
11:31:24 <kinaesthetician> (output, createTree tail) ???
11:31:38 <kinaesthetician> no
11:31:44 <monochrom> Your question would make sense if s/recursion/loop/ but you never want a loop.
11:32:39 <monochrom> There is a paper for that.
11:33:21 <kinaesthetician> ?
11:33:47 <monochrom> Read http://www.cs.nott.ac.uk/~pszgmh/bib.html#monparsing for good measure.
11:34:04 <kinaesthetician> thanks
11:34:28 <monochrom> Or the one before it for shortness.
11:34:49 <kinaesthetician> the one with "combinators" is more detailed?
11:34:52 <kinaesthetician> I prefer detail
11:35:11 <kinaesthetician> I learned haskell by reading the language report lmao
11:35:11 <monochrom> Famous last words.
11:35:24 <kinaesthetician> "learned" haskell lol
11:35:40 <kinaesthetician> monochrom: ???
11:35:45 <monochrom> I don't believe you. Because if you did, you would have know how ReadS does it by now.
11:36:49 <kinaesthetician> Well I didn't finish the entire report, was it far in?
11:37:15 <monochrom> No.
11:37:52 <kinaesthetician> I finished chapter 4 and did some slight reading in later seemingly relevant chapters like I/O
11:38:03 <kinaesthetician> I don't recall "ReadS"
11:38:19 <monochrom> Can you trust yourself to assess relevance?
11:38:48 <kinaesthetician> Nope lol
11:38:55 <kinaesthetician> The report is pretty dense though
11:38:56 <monochrom> There you go.
11:39:00 <kinaesthetician> I tried my best
11:40:35 <kinaesthetician> what does read do return the thing in a string?
11:40:53 <monochrom> Yes.
11:40:58 <kinaesthetician> o lmao I found it, it's first mentioned in chapter 4
11:41:01 <kinaesthetician> so I should have read it
11:42:36 <kinaesthetician> actually it's only used as an example to explain types
11:42:56 <kinaesthetician> along with "genericLength"
11:43:12 <kinaesthetician> but read isn't actually explained until chapter 6
11:43:18 <kinaesthetician> maybe I should finish the report 
11:43:29 <kinaesthetician> monochrom: finish the report or read the paper?
11:43:47 <monochrom> Read both. They help each other.
11:43:59 <monochrom> The 3rd explanation you read is the best explanation.
11:44:50 <kinaesthetician> k
11:44:54 <kinaesthetician> thanks, i guess
11:48:57 <WinchellsM> Are there any emacs/spacemacs Haskell users here? I just made the switch from vim.
11:49:00 <WinchellsM> [2:36] 
11:49:04 <WinchellsM> I'm trying to figure out how to use Haskell as a string manipulation language for selected visual blocks in emacs. I found [haskell-emacs](https://github.com/knupfer/haskell-emacs) but couldn't get it working. Does anyone have any experience with this?
12:08:03 <EvanR> https://twitter.com/ProgrammerDude/status/884072548954247168
12:12:59 <monochrom> Interesting.
12:14:11 * hackagebot rattletrap 2.4.0 – Parse and generate Rocket League replays. – https://hackage.haskell.org/package/rattletrap
12:14:21 <kinaesthetician> monochrom: The paper uses "type Parser a = String -> [(a,String)]", how is this done in haskell?
12:14:22 <EvanR> if it acually works of course
12:15:55 <monochrom> You can do that directly.
12:16:05 <monochrom> I guess s/directly/exactly/
12:16:18 <monochrom> Or you can make it a newtype instead.
12:16:41 <kinaesthetician> what's this s/a/b/ thing you keep doing?
12:17:03 <EvanR> black magic that no longer works
12:17:32 <monochrom> Pros and cons: Keeping it "type" is more educational but denies you to the nice do-notation. Making it "newtype" incurs annoying wrapping and unwrapping.
12:17:53 <monochrom> Unambiguous substitution notation.
12:18:08 <geekosaur> miming a correction/replacement to what they said
12:18:20 <Tuplanolla> Not everyone is called Ed.
12:18:35 <monochrom> As opposed to the bloodily ambiguous notation everyone uses. Why do people love ambiguity? Example:
12:18:45 <monochrom> John hates Mark.
12:18:46 <kinaesthetician> monochrom: wait like literally use 'type', I thought 'type' was just used for type synonyms
12:18:49 <monochrom> *Peter
12:19:08 <monochrom> (Now you have no idea whether I mean "Peter hates Mark" or "John hates Peter")
12:19:26 <EvanR> its pretty much obvious frmo context 
12:19:32 <monochrom> 'type" is still just used for type synonyms.
12:19:43 <kinaesthetician> o shit
12:19:50 <kinaesthetician> so it's a synonym for a function?
12:19:54 <monochrom> EvanR, my example is completely nonobvious even from context.
12:19:56 <kinaesthetician> for "a->a"
12:20:03 <kinaesthetician> within the type declaration?
12:20:13 <EvanR> i guess the context is context sensitive
12:20:25 <monochrom> I grant you that if the context resolves it, it's fine.
12:20:39 <monochrom> But do you actually trust lowly humans to be able to tell?
12:21:09 <geekosaur> kinaesthetician, the type Parser a exactly means the type String -> [(a, String)], a function from a String to a list of tuples (a, String)
12:21:16 <monochrom> Humans believe that they're unambiguous 100% of the time, while in reality they are only unambiguous 35% of the time.
12:21:41 <monochrom> Every writer thinks that he/she is perfectly clear.
12:21:45 <monochrom> You know better than that.
12:22:14 <geekosaur> functions are first class in Haskell, we can talk abotu them, pass them around, even create them on the fly after a fashion (e.g. (+1))
12:22:15 <kinaesthetician> geekosaur: yeah I get it now. I guess I always thought about type synonyms as being shortcuts for other algebraic data declarations
12:22:24 <kinaesthetician> but i mean it makes perfect sense
12:22:47 <kinaesthetician> since i guess technically that's what it is
12:23:03 <EvanR> functions are a "normal" type like ADT types... (->) a b
12:23:07 <EvanR> Either a b
12:23:32 <EvanR> it just has a funny infix ctor
12:23:59 <monochrom> There are ways (->) is not normal.
12:24:15 <monochrom> But it sure is a type.
12:24:45 <kinaesthetician> yes
12:24:48 <kinaesthetician> I understand now
12:25:16 <monochrom> Oh while we're at it:
12:25:31 <monochrom> There are ways (->) is an ADT rather than an ADT. \∩/
12:26:00 <monochrom> Oh why don't I rub it in too?
12:26:02 <monochrom> *ADT
12:26:15 <EvanR> knew it
12:26:39 <monochrom> (Resolution: There are ways (->) is an abstract data type rather than an algebraic data type.)
12:52:05 <codygman> I need to compile a Haskell program usable by Windows 10 from an OSX Sierra computer. What are my options? Has anyone done this?
12:52:32 <vktec> I'd use a Windows VM
12:52:32 <kinaesthetician> monochrom: "p 'bind' f = \inp -> concat [f v inp' | (v,inp') <- p inp]" I would never ever come up with this myself lmao
12:52:38 <geekosaur> the only reasonable option is windows 10 in virtualbox or etc.
12:53:03 <vktec> You might get away with WINE (Is it Darwine on macOS? I forget), but it's better to use a VM
12:55:10 <hpc> compiling for windows is hard enough without having to deal with not-windows on top of it, i would absolutely go VM
12:56:00 <vktec> It is possible to cross-compile to Windows
12:56:06 <monochrom> codygman: I recommend virtualbox, like others. But sometimes dual-booting is also worth considering.
12:56:11 <vktec> Whether it's worth it or not is another matter
12:57:19 <codygman> vktec:, monochrom, geekosaur: Thanks. I thought that wasn't an option since this is a work computer, but I see can install a windows VM so I'll probably go that route.
12:57:43 <monochrom> kinaesthetician: It is that complex because of [(a, String)]. If you're just doing (a,String), you just need \inp -> case p inp of (v, inp') -> f v inp'
12:58:21 <monochrom> virtualbox is the best thing since computers :)
12:58:57 <monochrom> My sister is on Mac but she wants to keep using Quicken for Windows (because she started with Windows a long time ago or something). virtualbox.
12:59:12 <monochrom> And she even found virtualbox herself, she didn't ask me for help.
12:59:45 <monochrom> To be sure, most likely any mac user forum is going to recommend that route already.
12:59:56 <Tuplanolla> I'd hesitate to call any crutch "the best".
13:00:11 <monochrom> Best crutch since vmware. OK? :)
13:00:30 <vktec> I prefer KVM to VirtualBox, but of course it's Linux only, so that doesn't help here
13:00:31 <geekosaur> for quicken there's actually good reason, quicken for mac is a completely different and inferior product
13:00:36 <geekosaur> it's not a port of quicken for windows
13:00:52 <monochrom> Ah yeah.
13:00:57 <geekosaur> it's missing most of the functionality of the windows version
13:01:25 <Tuplanolla> Switching operating systems shouldn't be any harder than switching on another electric lamp. That I could describe as "the best".
13:02:21 <monochrom> Are computers as cheap as electric lamps yet? Are even OSes as cheap as electric lamps yet?
13:03:22 * hackagebot aspell-pipe 0.3 – Pipe-based interface to the Aspell program – https://hackage.haskell.org/package/aspell-pipe
13:03:46 <Tuplanolla> Replace electric lamp with x-ray source if price is your concern.
13:03:48 <nshepperd_> Tuplanolla: so, have two machines and a kvm switch? :)
13:03:55 <ongy> monochrom: depends on your lamp
13:06:16 <kinaesthetician> monochrom: that(the case of example) is a lot easier to understand (though i still don't know if I'd ever come up with it myself lol), but I'm confused on how the list comprehension version is working
13:06:35 <kinaesthetician> [f v inp' | (v,inp') <- p inp]
13:06:37 <monochrom> What I'm pretty sure about: Soon, me taking over your desk lamp remotely will be as simple as me taking over your desk computer remotely. http://queue.acm.org/detail.cfm?ref=rss&id=3121440
13:07:22 <hpc> both will have stored your credit card number too
13:07:43 <geekosaur> Tuplanolla, 'what's the problem, they're both light sources' :p
13:08:05 <kinaesthetician> specifically the "(v,inp') <- p inp" part. How are the variables (since they are in a tuple) being used in the "f v inp' " part
13:08:13 <MarcelineVQ> monochrom: just stay out of my always-on-always-connected-app-aware-phone-connected-cloud-enabled juicer
13:09:18 <pikajude> always-on juicer
13:09:20 <pikajude> what a waste of electricity
13:10:01 <MarcelineVQ> and it doesnt even juice, I put in packets of juice and it squeezes the packets empty, it's a squeezer, this world is a lie pikajude
13:10:25 <geekosaur> that cracktacular thing?
13:10:37 <pikajude> I remember the juice packet squeezer
13:10:42 <geekosaur> the one that turns out to not even work as well as just squeezing the packets in your hands?
13:10:47 <pikajude> "we thought the packets would be harder to squeeze to justify the cost of the squeezing machine"
13:10:54 <kinaesthetician> nevermind, I guess it works 
13:10:56 <kinaesthetician> > [x - y | (x,y) <- [(1,2),(2,3),(3,4)] ]
13:10:58 <lambdabot>  [-1,-1,-1]
13:11:10 <kinaesthetician> so I ain't complainin lol
13:11:11 <hpc> haha, i love that thing
13:11:33 <hpc> i was running out of inexplicable design decisions to make fun of, and then that pile of gold falls in my lap
13:11:57 <geekosaur> kinaesthetician, that's a list comprehension
13:12:55 <kinaesthetician> geekosaur: yes, I get that, I just got confused by it being taken from a tuple, I've always seen it like [x-y | x <- [1,2,3], y <- [2,3,4] ]
13:13:05 <geekosaur> it can also be read as an operation in the list monad:   do { (x,y) <- [(1,2),(2,3),(3,4)]; return (x - y) }
13:13:14 <geekosaur> you can pattern match in lots of places in Haskell
13:13:41 <kinaesthetician> o there is a difference
13:13:49 <hpc> and to close the loop entirely, take a look at MonadComprehensions
13:14:05 <kinaesthetician> the [x-y | x <- [1,2,3], y <- [2,3,4] ] actually does the first against all the y's, then the next against all the y's, and so on
13:14:05 <geekosaur> it's most useful when failure to match does something other than throwing an exception, as with List or Maybe (where failure is [] or Nothing respectively)
13:14:56 <kinaesthetician> danke
13:15:56 * hackagebot tweet-hs 1.0.0.1 – Command-line tool for twitter – https://hackage.haskell.org/package/tweet-hs
13:32:43 <Lokathor> hash table turned out to be slower than just a normal Set :/
13:32:45 <Lokathor> awh
13:34:33 <monochrom> The one stuck in IO?
13:34:40 <Lokathor> no the ST one
13:34:42 <Lokathor> from hashtables
13:35:15 <monochrom> Ah, STArray is not exactly fast. (IOArray same story.)
13:35:54 <monochrom> However, HashSet is worth consideration.
13:36:29 <monochrom> There are times HashSet is faster than Set, and there are times the other way round.
13:36:29 <Lokathor> i did a Data.HashTable.ST.Cuckoo.HashTable s k ()
13:37:07 <Lokathor> that ended up slower than even the "doesn't use ST at all" version
13:38:18 <Lokathor> i must be hitting some crazy case somehow, because it's 6x to 10x slower than not even using ST somehow
13:38:19 <Lokathor> :/
13:39:16 <monochrom> No, you are not alone, hashtable is generally slow.
13:39:40 <monochrom> I don't think I know exactly why, and probably few people do, but the slowness fact is widely known.
13:39:47 <geekosaur> ^
13:40:01 <lyxia> What are you storing with it?
13:40:33 <Lokathor> tuples, basically
13:40:34 <monochrom> Do not think that STRef or IORef are "w00t in-place destructive update, automatically fast". In practice often quite the contrary.
13:40:42 <Lokathor> it's a data value with two unboxed ints
13:41:17 <Lokathor> monochrom, with using normal Data.Set from containers, the speed order goes Normal -> ST -> ST with manual unboxing
13:41:28 <monochrom> There was once I helped with a newbie performance problem by merely replacing IORef Int by Int parameter passing. Something like 10x speedup.
13:41:38 <Lokathor> nice
13:42:47 <Lokathor> I'm all about those speedy codes
13:43:00 <monochrom> The vector library is faster, but I haven't heard of a hash table library based on vector.
13:43:36 <Lokathor> i suppose i could do it with MVector maybe, and just collapse the duplicates when i merge it back into a set at the end
13:43:49 <nisstyre> you have to do what the compiler optimizes for
13:43:56 <nisstyre> that's how you get good performance
13:44:14 <nisstyre> that and a good algorithm
13:45:06 <Lokathor> https://github.com/Lokathor/ludolib/tree/master/bench/Util these are the variants so far
13:45:38 <nisstyre> speaking of that, what's the best haskell web server library for writing APIs (no need for templating bs or anything)
13:46:41 <Lokathor> https://github.com/hyperium/hyper >_>
13:47:13 <nisstyre> does it support web sockets Lokathor?
13:47:29 <Lokathor> no the joke is that it's the rust webserver lib :P
13:47:34 <nisstyre> yeah I know
13:47:39 <nisstyre> but seriously it might be useful
13:47:51 <monochrom> heh
13:47:54 <Lokathor> i have no idea if it does websocket, i know they recently moved it to using high speed async IO for a big boost
13:50:41 <nisstyre> maybe I'll just use warp
14:34:39 <statusbot> Maintenance update: Hackage restarting... -- http://status.haskell.org/pages/maintenance/537c07b0cf1fad5830000093/59629ee93971d74b0e000271
14:39:52 <duog> is hackage down?
14:40:10 <lispy> it's restarting
14:40:12 <hpc> just before you joined: 17:34 < statusbot> Maintenance update: Hackage restarting... -- http://status.haskell.org/pages/maintenance/537c07b0cf1fad5830000093/59629ee93971d74b0e000271
14:40:21 <glguy> duog: You can always check https://status.haskell.org/
14:40:29 <duog> great, thanks
14:41:27 <statusbot> Maintenance update: Hackage operational again! -- http://status.haskell.org/pages/maintenance/537c07b0cf1fad5830000093/59629ee93971d74b0e000271
14:48:22 <kinaesthetician> god I just followed the logic
14:48:32 <kinaesthetician> for a bunch of functions and lambdas
14:48:39 <kinaesthetician> to figure out how this parser works
14:48:41 <kinaesthetician> that was hell
14:48:50 <kinaesthetician> NOW, I understand that list comprehension
15:14:14 <vlnts> Hi - I am very new to haskell but found a couple of comment bugs in Data.Either.Unwrap and wonder how to proceed to fix them
15:15:22 <sandonfuge> Guys, with this code shouldn't I be able to just do something like "succ Sunday" and get Monday as a result? http://lpaste.net/356832
15:17:01 <hpc> what error do you get?
15:17:11 <hpc> something to do with Show, i am guessing?
15:17:35 <sandonfuge> Nevermind, I just forgot to derive Show
15:17:39 <sandonfuge> Thank you, hpc!
15:17:47 <dmj`> @def data Days = Sunday | Monday | Tuesday | Wednesday | Thursday | Friday | Saturday deriving (Enum, Show)
15:17:48 <lambdabot>  .L.hs:171:13: error:
15:17:48 <lambdabot>      Multiple declarations of ‘Sunday’
15:17:48 <lambdabot>      Declared at: .L.hs:162:12
15:20:00 <vlnts> the bugs are in the docs to Data.Either.Unwrap on hackage - how can I submit a patch or make an issue ?
15:21:03 <glguy> vlnts: You can go the contents page for that package and find its homepage or issue link
15:21:31 <glguy> vlnts: This package is deprecated in favor of a deprecated package, so the author might not be interested in working on it
15:22:04 <vlnts> glguy: ah ok thx
15:25:38 <kinaesthetician> monochrom: you still here?
15:39:44 <kinaesthetician> ahhhh
15:39:50 <kinaesthetician> I can't wrap my head around all this
15:39:57 <kinaesthetician> too much abstraktion
15:48:15 <Cale> kinaesthetician: Any question in particular?
15:53:45 * hackagebot plot-light 0.1.0.2 – A lightweight plotting library, exporting to SVG – https://hackage.haskell.org/package/plot-light
15:59:44 <EvanR> when its abstract, there might not be enough for your brain to wrap around. like a wave totally ignoring a small obstacle
15:59:58 <EvanR> not enough complexity!
16:00:38 <hpc> this is why i write all of my code with the spring framework
16:31:14 * hackagebot plot-light 0.1.0.3 – A lightweight plotting library, exporting to SVG – https://hackage.haskell.org/package/plot-light
17:12:47 * hackagebot system-linux-proc 0.1.0.3 – A library for accessing the /proc filesystem in Linux – https://hackage.haskell.org/package/system-linux-proc
18:09:26 <cheshircat> I have something strange happening with building a cabal package on NixOS. bash is running at 100% CPU with the command /nix/store/wb34dgkpmnssjkq7yj4qbjqxpnapq0lw-bash-4.4-p12/bin/bash -e /nix/store/3k978nnp7ppjim34di40vwz5f95rsxhw-gcc-wrapper-5.4.0/bin/cc @/tmp/ghc28943_0/ghc_30.rsp
18:10:57 <monochrom> IIRC gcc is highly inefficient when given a long rsp file (compared to the supposedly equivalent act of directly putting the same filenames in command line arguments)
18:11:13 <monochrom> It happened to someone else here last week.
18:11:49 <cheshircat> what is a rsp file?
18:11:54 <cheshircat> and why is it happening to me?
18:12:09 <monochrom> The /tmp/ghc28943_0/ghc_30.rsp there
18:12:43 <monochrom> Some NixOS developer inflicted it on you I guess?
18:15:20 <cheshircat> Do you think it could have anything to do with template haskell?
18:15:23 <cheshircat> I'm using yesod
18:15:52 <monochrom> Oh, denial mode now? But I'll insist too: No.
18:15:52 <geekosaur> it has to do with excessively long link commands, which will be related to having a lot of packages as dependencies (yep, that'd be yesod)
18:16:20 <cheshircat> great...
18:16:36 <geekosaur> also, while they originated on windows, the linker command lines that you get from ghc with lots of packages can exceed the execargs limit on linux and os x too
18:16:40 <geekosaur> (but not freebsd)
18:16:41 <cheshircat> is there anything I can do to make it better? Other than rewriting my application to use servant?
18:16:48 <EvanR> gold linker instead of gnu linker
18:17:02 <geekosaur> that said, is it actually bash or gcc that is spinning
18:17:11 <geekosaur> or ld
18:17:16 <cheshircat> well, htop shows bash
18:17:25 <geekosaur> *that* is weird
18:17:41 <monochrom> What is "-e"?
18:18:20 <geekosaur> exit on error
18:19:12 <geekosaur> that business is a nix-ism, every command installed for nix comes in a wrapper script like that and nix arranges for you to run them that way
18:19:25 <geekosaur> so this may actually be nix's fault
18:19:52 <cheshircat> yeah, it usually is
18:20:11 <cheshircat> But I love it anyways
18:21:47 * geekosaur also has nix installed... in its own little cage
18:22:08 <cheshircat> nah dude, go hard or go home
18:23:14 <cheshircat> OK, I now understand why it's bash
18:23:42 <cheshircat> but it's just called bash, because the last line is exec /nix/store/blah/bin/ghc
18:23:54 <cheshircat> the actual thing that's spinning is definitely ghc
18:28:12 <geekosaur> gcc
18:28:14 <geekosaur> not ghc
18:28:29 <geekosaur> ghc invokes gcc to do the final link, because that way it also gets the C runtime foo
18:28:42 <geekosaur> which is more substantial, and sometimes more complex, than you'd think
18:29:10 <cheshircat> hmm, but it is spinning in compiling the individual files, not in the linking page
18:29:11 <geekosaur> (mostly because it is also where C++ global constructors and destructors get handled)
18:40:13 <cheater> can ghc's Integer easily hold and check equality of a 2100 digit natural number?
18:41:19 <Claudius1aximus> > 10 ^ 2100 + 1 == (1 + 10 ^ 2100 :: Integer)
18:41:21 <lambdabot>  True
18:42:59 <pacak> cheater: It can hold much more.
18:44:22 <cheater> thank you
18:44:27 <Axman6> > length (show (13^5000))
18:44:29 <lambdabot>  5570
18:44:32 <quick_dudley> Depends how much memory your computer has: if I wanted to do something with (2^4000000000) I'd have to close some applications first
18:45:19 <Axman6> sometimes I wish for sparse Integers, there must be many occasions where there are many 0 words in an Integer
18:45:49 <quick_dudley> Nothing's stopping you from making a library for that
18:45:57 <Axman6> except time
18:46:01 <erisco> there is scientific notation for the suffix case
18:46:06 <quick_dudley> True
18:46:18 <Axman6> yeah
18:46:24 <Axman6> (and Data.Scientific I guess)
18:47:26 <erisco> what we need is a library that stores integers as the smallest program that outputs the integer :P
18:47:58 <geekosaur> gonna make for some "interesting" math...
18:48:22 <EvanR> it stores integers in the smallest program that outputs the integer but in the specific language where that integer happens to be one symbol
18:48:47 <Axman6> isn't that sort of how some of the arbitrary precision floating point numbers work?
18:49:14 <erisco> and we'll index these languages with integers! so we just need to store the language index and presto
18:49:24 <geekosaur> only integers? ༳
18:49:27 <dfeuer> Sure. You just have to use a weak enough language and all is boring.
18:49:28 <quick_dudley> But there's an actual proof that there's no way to find the smallest program for a given output
18:49:50 <dfeuer> If you use a Turing-complete language, you're in trouble.
18:49:52 <EvanR> the program isnt computable
18:50:17 <dfeuer> I wonder just how weak the language has to be to escape that....
18:51:01 <EvanR> store integers as one symbol each but the symbol can be as complex as you need
18:51:01 <quick_dudley> Because there are always smaller programs that might have the same output or might go into an infinite loop
18:51:17 <EvanR> if that were the case, the definition wouldnt make sense
18:51:46 <EvanR> its like BB numbers you need a team of grad students to prove that such and such programs do or dont terminate
18:52:02 <dfeuer> quick_dudley: you can escape that proof by using a language with decidable termination.
18:52:12 <dfeuer> (as the encoding)
18:52:14 <quick_dudley> That's true
18:52:47 <EvanR> "theres always a smaller program that does what you want, or doesnt do what you want and loops" doesnt really make sense
18:53:25 <dfeuer> No, but it points to a valid proof.
18:53:40 <quick_dudley> If you're using a Turing complete language then there will be loops which can't be proven to be finite or infinite
18:53:41 <EvanR> "the grad students didnt figure out what most of the programs less than X did yet" might be the case
18:54:00 <EvanR> cant be proven or disproven is subjective
18:54:43 <dfeuer> Hrmmm
18:54:49 <erisco> if a grad student can determine if an arbitrary program halts then we have a big hole in a certain problem
18:54:52 <quick_dudley> Not in math it's not
18:55:15 <EvanR> my conclusion so far is, yeah it is
18:55:36 <hanna> Axman6: as far as I can tell, CReal makes no attempt to satisfy the “smallest program” requirement
18:55:47 * dfeuer attempts to come up with an actual proof.
18:56:01 <EvanR> erisco: prove they cant!
18:56:42 <hanna> (such a thing of course being blatantly unfeasible)
18:56:51 <erisco> haha, well, I suspect reality is more complicated... I am usually critical when people use the halting problem to argue against something
18:56:57 <EvanR> quick_dudley: these judgments always come with some metatheory, and so and so doesnt accept it until its interpreted in yet another metatheory
18:57:28 <erisco> the thing is, a grad student is making guesses... there is no guarantee they solve it, but there is a decreasing probability that they won't over time
18:57:54 <EvanR> a guess?
18:58:08 <hanna> erisco: I'm pretty sure a computer does a better job of assessing the termination of programs than a grad student :p
18:58:10 <EvanR> surely we accept a valid proof once they find it
18:58:23 <EvanR> thanks to type checkers
18:59:19 <hanna> Not only can a computer mechanically assess termination for an infinite class of programs that have high complexity but halt quickly, but a computer can also apply rigorous totality proof functions for arbitrarily complex programs that satisfy the constraints of that particular totality proving scheme
19:00:28 <EvanR> none of which counts when you ask them about turing machine X !
19:00:33 <quick_dudley> Apparently we don't accept valid proofs once we find them because some of us are still disputing Alan Turing's proof of undecidability of the halting problem
19:01:09 <erisco> I am not disputing it. I am saying that it has to apply to grad students as well
19:01:18 <EvanR> erisco: oh really!
19:01:37 <geekosaur> million monkeys, Shakespeare...
19:01:39 <quick_dudley> I agree it has to apply to grad students
19:01:51 <erisco> but then I am suggesting that the way to understand the grad student approach is probabilistically
19:01:52 <EvanR> im not sure the proof covers this
19:02:17 <erisco> now, I don't have a formal proof or reason for this, but I suspect you can devise an algorithm that is more likely to find the solution the longer it runs
19:02:23 <hanna> The halting problem feels like one of those classes of problems where you could solve 99.9% of the solution space heuristically only for the worst case scenarios to trigger undecidable/exponential behavior
19:02:40 <erisco> so you are left with an algorithm not guaranteed to terminate but increasingly likely to
19:02:53 <erisco> and in that manner you might hope to circumvent the halting problem
19:03:00 <hanna> The amount of SAT solvers in existence seems to suggest that, actually, we have a pretty good idea of how to solve SAT as long as your program input doesn't show up in a CS textbook
19:03:04 <EvanR> the probability that a given machine halts eh
19:03:16 <EvanR> this leads directly back to the issue
19:03:28 <hanna> So many of these problems feel like they only blow up for pathological worst cases
19:03:38 <erisco> not the probability that it halts, the probability that you determine whether it halts or not
19:03:39 <hanna> But it seems like the phenomenon of a problem being “mostly” solvable is largely untreated in CS
19:03:54 <erisco> so you analyse the program one way and this may or may not succeed in determining if it halts
19:03:59 <erisco> then you try another way, and so on
19:04:23 <hanna> (And can lead to surprising results, if you rely on the difficult of solving a function for, say, a security reduction :p)
19:04:28 <quick_dudley> Yeah, there are partial solvers for the halting problem. My classmate has written one
19:04:28 <EvanR> this makes vague sense, but you cant get any actual probability numbers, without first going through a series of research grants
19:05:43 <EvanR> probability that my probability is probably pretty right
19:06:13 <EvanR> 5% !
19:06:37 <erisco> the question is what this space of proofs looks like... all the possible ways to show a program does or does not halt
19:07:05 <erisco> and can you then devise some way to navigate it such that you asymptotically converge to the answer
19:08:09 <cheater> can someone suggest a fast prime test algorithm in haskell?
19:08:15 <erisco> well, that the probability of finding the answer asymptotically converges to 1
19:08:15 <cheater> i don't want to reinvent the wheel
19:08:26 <EvanR> hackage package arithmoi has one
19:08:30 <EvanR> at least one
19:08:41 <hanna> Writing an algorithm that asymptotically converges towards 100% success in deciding the halting problem is trivial
19:09:15 <hanna> If it halts before your execution budget ends, output “halts”. Otherwise, output “doesn't halt”. As you evaluate this for longer and longer, you approach the correct result
19:09:56 <hanna> (In fact once your number of execution steps surpasses the busy beaver function of the size of the input, it reaches 100% success)
19:10:00 <EvanR> so while searching through the space of proofs, which is infinite, say you get to N because the budget is up
19:10:05 <hanna> (But of course, the busy beaver function is uncomputable :p)
19:10:09 <EvanR> youve covered N/inf = 0 
19:10:16 <erisco> eh, that doesn't seem right to me... so it has run for 1 year, what is the probability at this point that it does not halt?
19:10:29 <EvanR> the probability is not computable
19:10:42 <cheater> EvanR: thank you
19:10:43 <erisco> well it is just a nonsense question I think
19:10:44 <hanna> Isn't there a defined constant in terms of that
19:11:03 <EvanR> but a given problem, they may be able to figure out an approximation through blood and tears
19:11:05 <erisco> how long the program has run already is not related to whether it terminates
19:11:18 <hanna> https://en.wikipedia.org/wiki/Chaitin%27s_constant
19:11:23 <erisco> so I disagree that this is a convergence
19:11:53 <erisco> interesting, well I'll have to look at that
19:11:54 <quick_dudley> Chaitlin's constant is only known to 2 bits
19:12:22 <EvanR> the story behind that "number" is going to be a bunch of set theory
19:12:46 <EvanR> the arguments will be classical as hell
19:12:49 <hanna> erisco: All turing machines that halt, halt after a finite number of steps
19:13:37 <cheater> quick_dudley: what does that mean?
19:13:49 <hanna> erisco: Of course, you can neither know when you've reached this critical threshold ‘N’ after which your function reaches 100% success, *nor* can you know your current success probability
19:14:06 <erisco> yes, but after running a finite number of steps and seeing that it still has not stopped doesn't make it obvious to me how likely it is going to keep running
19:14:10 <Lokathor> :k (# Int, Int #)
19:14:11 <lambdabot> TYPE 'GHC.Types.UnboxedTupleRep
19:14:13 <erisco> it doesn't seem related whatsoever
19:14:19 <EvanR> you can know it, if you have the research, but you cant compute it
19:14:25 <hanna> erisco: Well you are trying to solve the halting problem, so good luck
19:14:30 * hanna goes back to inventing free energy
19:14:31 <Lokathor> that's.. not what i expected
19:14:43 <erisco> so the idea that the longer I run the program the closer I get to the answer seems incorrect
19:14:57 <erisco> no, I never said I was trying to solve the halting problem...
19:14:59 <EvanR> pretty much
19:15:00 <quick_dudley> There was a group that tried to calculate as much of Chaitlin's constant as possible: but they didn't narrow it down enough for a single digit in decimal, but in binary it was enough for 2 bits
19:15:44 <hanna> erisco: But it's provably correct. The number of “wrong” cases is monotonically decreasing as you increase the length of the simulation
19:15:59 <erisco> hanna, decreasing from what?
19:16:07 <hanna> f(n-1)
19:16:14 <EvanR> assuming the max is N, an unknown number
19:16:15 <erisco> what is the starting point?
19:16:22 <hanna> (In fact this is literally how the halting problem is solved in practice)
19:16:24 <EvanR> you can formally prove it increases to zero
19:16:29 <EvanR> er decreases
19:16:30 <hanna> erisco: Chaitin's constant
19:16:41 <cheater> man, why is downloading the package list from cabal such a drag
19:16:52 <cheater> you'd think it wouldn't take so long
19:16:59 <erisco> okay, well, it sounds interesting but I'll have to read on it carefully to understand it
19:17:13 <hanna> (chaitin's constant is the probability that a random program will halt)
19:17:15 <cheater> from hackage, actually
19:17:35 <hanna> So if you just output “yes” or “no” without looking at the program, you will get a success/error ratio of chaitin's constant
19:17:43 <cheater> quick_dudley: interesting. i bet it must have been a complex undertaking
19:18:02 <erisco> okay, just from that brief description I do not see how it applies here
19:18:55 <hanna> If you feed f0(P) = "yes" a random program, what's the probability that it will give you the correct result?
19:18:55 <EvanR> statements about chaitin constant are a lot like statements about unmeasurable sets, undefinable numbers, 
19:19:02 <erisco> I can tell you that program X has a 37% chance of halting, determined by whatever method, and I do not see how running program X for longer matters
19:19:07 <EvanR> they "exist" and thats it
19:19:15 <hanna> erisco: There's no such thing as a program that has a 37% chance of halting
19:19:17 <hanna> Maybe that's your mistake
19:19:22 <erisco> I do not see how running it for longer increases or decreases your assuredness that it halts
19:19:30 <cheater> ok, i have broken something. i did cabal update and it took too long, so i ctrl-c'd out of it. now when i do eg cabal install, it still says the package list is 34 days old, but when i do cabal update, it says "skipping download: local and remote files match". how can i fix this? :S
19:19:37 <hanna> Every program has either a 100% chance to halt or a 0% chance to halt
19:19:49 <erisco> hanna, you just explained that Chaitin's constant is the probability that a random program halts
19:19:52 <quick_dudley> cheater: stack is faster when it comes to keeping the hackage database because it uses a mirror which is a git repository: but it does take longer the first time
19:20:04 <hanna> erisco: Yes
19:20:21 <erisco> hanna, so I gave you a random program, it is X, and I am telling you the probability is 37% (I don't know what the constant is, doesn't matter)
19:20:36 <EvanR> youre in danger of conflating two different kinds of logic!
19:20:36 <cheater> quick_dudley: i'm using cabal right now, i need to fix it now i guess..
19:20:38 <erisco> how does this fact help you when running the program for longer
19:20:44 <EvanR> time to switch to linear logic
19:21:58 <EvanR> erisco: you know the BB numbers?
19:22:04 <quick_dudley> If you have an estimate of Chaitlin's constant you can use Bayesian inference each time your program takes a step and doesn't halt, but it still doesn't give an accurate probability because your initial estimate of Chaitlin's constant is probably wrong
19:22:08 <erisco> EvanR, nope
19:22:12 <EvanR> ah
19:22:45 <EvanR> erisco: for a machine of a given size, there "exists" a maximum runtime for halting machines that big. this is the limit of your search
19:22:47 <cheater> does anyone have an idea how to unbreak my cabal db?
19:23:06 <EvanR> if it doesnt halt after that many steps, you can stop and be assured it doesnt halt
19:23:15 <cheater> oh i think i know
19:23:16 <pacak> cheater: rm -rf, reinstall all the things.
19:23:16 <EvanR> so the longer you run it, the closer you are to an answer
19:23:30 <erisco> quick_dudley, I do not know Bayesian statistics but for these two things to be related it would have to be, for example, the probability that it halts after N steps, or on the next step
19:23:31 <hanna> erisco: Consider the set of all programs as the set of all programs of size S that halt within 1 instruction, the set of all programs that halt within 2 instructions, within 3, etc.  Each set is trivially non-empty.  Let fN(P) be the function that checks to see if program P halts within N steps, and if so, outputs “halts” - otherwise “doesn't halt”. That is, f2(P) will get all of the cases in
19:23:33 <hanna> “halts within 1 instruction” and “halts within 2 instructions” right, and everything else potentially wrong. Since all of these sets are trivially nonempty, your probability of error goes down every time you increase N
19:23:41 <erisco> it has to be somehow related to steps, otherwise it is unrelated...
19:23:42 <cheater> i'll try to remove .cabal/packages/hackage.haskell.org/00-index.tar.gz.etag
19:23:45 <cheater> i think that's what it's using
19:23:55 <hanna> As N -> infinity, fN(P) becomes 100% accurate. In fact, this always happens once N > beaver(S)
19:23:57 <erisco> if it is just the probability that it halts after an arbitrary number of steps then it is independent of
19:24:11 <quick_dudley> https://oeis.org/wiki/Busy_Beaver_numbers
19:24:17 <cheater> yea that did it
19:24:26 <MarcelineVQ> cheater: gj
19:24:27 <cheater> nothing a little strace couldn't fix
19:24:31 <hanna> (sorry, that “of size S” annotation was supposed to be on all “set of all programs”)
19:25:35 <quick_dudley> But both the program size and the number of steps are counted as if the program representation is a Turing machine, so the numbers will be different if you're using an actual programming language
19:25:55 <cheater> ok, something seems to be weird about cabal, it's taking much too long to get this package list
19:26:12 <EvanR> cheater: i think hackage had some maintenance issues of some sort earlier
19:26:15 <hanna> In practice, what compilers etc. that rely on terminating type checkers do is just use f50()
19:26:22 <hanna> and if it does not halt within 50 steps, outputs “infinite loop”
19:26:30 <geekosaur> if it's a very old version of cabal-install then yes, it has a fairly major slowness bug
19:26:30 <hanna> (This works fine in practice, ergo halting problem is solved. QED)
19:26:36 <cheater> is there any instance of cabal just hanging when downloading the package list? can something on the backend have changed that cabal wouldn't have known if it hadn't been updated for say 300 days?
19:26:36 <MarcelineVQ> cheater: it's a 284mb file
19:26:38 <geekosaur> but if it's 1.24ish then it should be fine
19:26:41 <cheater> is it MarcelineVQ
19:26:45 <cheater> i'll let it download then
19:27:05 <cheater> o nice, it seems to have worked. thank you MarcelineVQ
19:27:10 <erisco> hanna, your set of sets of programs does not contain programs which do not halt, and so I do not see how you are determining if a non-halting program indeed does not halt
19:27:28 <EvanR> erisco: run it for at most BB(n) steps
19:27:36 <EvanR> see if it halts
19:27:51 <hanna> erisco: Fair enough, but that doesn't change the proof in any significant way. Since for the rest, your fallback of “always outputting ‘doesn't halt’” will be correct
19:28:02 <erisco> proof of what?
19:28:15 <hanna> The proof that my function converges towards 100% success as N -> infinity
19:28:38 <erisco> this started with you saying you had a trivial way to implement what I was specifying, but my specification includes determining if non-halting programs do not halt
19:28:50 <cheater> is the set of programs that can be proven to halt or not halt by construction dense in the space of programs?
19:29:08 <cheater> i guess it depends on what you construct with
19:29:14 <cheater> as in what primitives
19:29:18 <EvanR> erisco: you need to be more careful setting up such problems! non-halting programs obviously dont halt
19:29:21 <hanna> erisco: My function determines if a non-halting problem does not halt
19:29:22 <cheater> but i assume there's some canonical way of doing this
19:29:30 <hanna> erisco: I don't see the problem
19:29:37 <hanna> It outputs “doesn't halt” for every program that doesn't halt
19:29:39 <erisco> hanna, I don't see how it succeeds in doing that
19:29:45 <hanna> Did you even read what I wrote?
19:30:11 <erisco> yes, so I missed how it works in this case
19:30:40 <hanna> I don't know how I could possibly spell out “ if it halts within N steps, output ‘halts’. else output ‘doesn't halt’” in a way that's more simple for you to understand
19:30:43 <hanna> But whatever, not my problem
19:30:46 <hanna> Keep solving that halting problem
19:31:19 <erisco> yeah, I read that, and seeing as non-halting programs do not halt in N steps I do not see how your method determines if a non-halting programs does not halt
19:31:33 <EvanR> it halts by assumption
19:31:37 <quick_dudley> If it outputs "halts" then that's a definite answer, so anything that doesn't halt will make it output "doesn't halt". But there will be some programs which actually do halt which will still make it output "doesn't halt"
19:31:37 <erisco> unless we're allowing it to give it answer at time infinity, or something
19:31:38 <EvanR> or did i not get that
19:31:41 <cheater> erisco: it determines this in asymptote
19:32:00 <erisco> okay, well no, that is outside what I was specifying... sorry if that was unclear
19:32:07 <EvanR> er, doesnt halt by assumption
19:32:28 <erisco> well if it doesn't halt by assumption then just print "doesn't halt" :P
19:32:37 <EvanR> solved
19:33:11 <EvanR> erisco: the procedure of running it for n steps gets closer to working for a given program because of BB numbers
19:34:12 <EvanR> rather than always being stuck at progress = 0 because n/inf = 0
19:34:34 <hanna> EvanR: It grows monotonically even if there wasn't an upper bound on the number of execution steps a program can have
19:34:57 <EvanR> what does
19:35:05 <hanna> The success rate of fN
19:35:19 <hanna> The upper bound is just what allows it to reach 100% in a finite number of steps
19:35:34 <EvanR> n/inf doesnt grow monotonically
19:36:15 <EvanR> infinitesimals?
19:36:18 <hanna> ?
19:36:54 <hanna> P[fN(X) = H(X)] -> 1 as N -> infinity
19:36:58 <hanna> I have no idea where your division comes from
19:37:09 <quick_dudley> As the step limit increases: the number of programs identified as halting grows monotinically, and the number of programs identified as non-halting also shrinks monotinically
19:37:17 <hanna> Exactly
19:37:33 <EvanR> nope im lost
19:38:58 <erisco> hanna, to be more precise about what I mean, the probability of that algorithm printing "doesn't halt" for a non-halting program after N steps (steps of the algorithm) is zero
19:39:25 <hanna> no, it's 100%
19:39:26 <erisco> hanna, it only works when you give exception to saying that given infinite time the algorithm will print "doesn't halt"
19:39:32 <EvanR> seems like itd be 100%
19:39:33 <hanna> all non-halting programs trivially don't halt
19:39:55 <erisco> okay, then somehow I am terribly misunderstanding how what you described works
19:40:03 <cheater> EvanR: arithmoi was a good tip, thanks
19:40:22 <erisco> because it sounds like you have a set of sets of terminating programs, and you are checking if the program at hand is in any of those sets
19:40:28 <hanna> oh for fuck's sake I refuse to believe you can possibly misunderstand my trivial program involving a single fucking if expression and two `print` commands
19:40:31 <erisco> and you've ordered them by how many steps they take to halt
19:40:37 <EvanR> cheater: yeah its pretty great
19:41:12 <erisco> so to determine if a program is non-halting you would have to check that it is nowhere in the set of sets of halting programs, a task that requires infinite time
19:41:43 <erisco> that is my understanding of the algorithm, so if I got that wrong then that is where my confusion comes from
19:43:36 <EvanR> theres a lot of subtle double talk surrounding all of this, always has been
19:43:49 <EvanR> check out the debate over the foundations of math in the 1920s
20:02:03 <erisco> EvanR, are you suggesting that is resolved now?
20:12:28 <greymalkin> emacs Interactive-Haskell mode suddenly stopped putting the symbols of the file I am working on into the session when I compile there. What's going on?
20:52:29 <iqubic> how do I insert a unicode symbol into a haskell string?
20:52:39 <iqubic> Like  
20:53:12 <Axman6> what do you mean
20:53:42 <glguy> > text "Example \8712"
20:53:44 <lambdabot>  Example ∈
20:53:48 <Axman6> just write it, Haskell files are UTF-8 so you can put whatever symbols you want in
20:54:09 <glguy> > text "Example ∈"
20:54:11 <lambdabot>  Example ∈
20:54:38 <Axman6> yo can also escape them with "\NNNN" or "\xNNNN" for decimal and hex unicode values
20:55:05 <glguy> > text "Example \o21010"
20:55:07 <lambdabot>  Example ∈
20:55:15 <Axman6> and octal! (ew)
20:55:35 <iqubic> Axman6: I'm getting this error.
20:55:38 <iqubic> lexical error in string/character literal at character '\61497'
20:55:52 <Axman6> that's fantastic, congratulations
20:55:57 <iqubic> Is it?
20:55:58 <Axman6> if only we knew what the code looked like
20:56:44 <glguy> > Data.Char.generalCategory '\61497'
20:56:46 <lambdabot>  PrivateUse
20:56:58 <Axman6> It's amazing that even after all this time you're still struggling with the concept of how to ask questions of others. Having problems with some code? share the code. 
20:57:16 <iqubic> > print "echo \" \" "
20:57:18 <lambdabot>  <hint>:1:15: error:
20:57:18 <lambdabot>      lexical error in string/character literal at character '\61497'
20:57:22 <glguy> In this case the issue isn't any surrounding code, you just can't use that Private Use symbol in a string literal
20:57:30 <iqubic> See that is the exact error.
20:57:49 <iqubic> So I can't take a font awesome glyph and stick it into my code?
20:58:03 <Axman6> there's some characters in there (probably non-printing characters) which are causing issues
20:58:11 <iqubic> Oh.
20:58:32 <Axman6> no, if fontawesome is using the private use seciton of unicode, then it's not going to be supported anywhere else, and is non-standard
20:59:01 <iqubic> All I'm trying to do is use haskell to print the font awesome character "fa-align-justify"
20:59:12 <Axman6> the PrivateUse section of unicode is designed for domain specific use, and will only be supported in that domain
20:59:23 <iqubic> Is there a way to figure out if a certain glyph is acceptable?
20:59:41 <Axman6> well, the way this is done in HTML is by using HTML escapes. it is very unliukely to work outside of HTML really
20:59:49 <glguy> iqubic: Data.Char.generalCategory '\61497' like I did her
21:00:07 <glguy> here* ; you can use \61497 instead of the literal glyph in your string literal
21:00:11 <iqubic> Cool, I'll try that.
21:02:23 <iqubic> Is there a way to just insert a unicode code point into haskell?
21:02:32 <iqubic> Or is that do-able?
21:02:41 <Axman6> that's what the escape syntax does
21:03:01 <Axman6> but if it's not a valid codepoint, it rightly won't work in many cxases
21:03:14 <iqubic> Alright then. Good to know.
21:10:52 <Lokathor> i often wish for an ArrayList in haskell
21:10:53 <Lokathor> ah well
21:11:03 <Lokathor> i don't wish enough to go do it, so that says something
21:11:19 <Axman6> with what properties?
21:11:34 <Axman6> Data.Vector.Lazy type thing? (which doesn't exist AFAIK)
21:11:59 <Lokathor> the properties of "Works like the ArrayList in Java"
21:12:10 <iqubic> Lokathor, you wish for a dynamically resizing array in Haskell?
21:12:14 <ongy> that's slabs, right?
21:12:18 <Axman6> that sounds pretty mutable to me (I can't remember what ArrayList does)
21:12:29 <iqubic> Axman6: It is rather mutable.
21:12:37 <Lokathor> yea, so it's a Vector that actually has more space than it claims, and inserts don't force a reallocation right away
21:12:46 <Lokathor> yeah you'd do it with MVector
21:13:12 <Axman6> no reason you couldn't make one with MVector quite easily
21:13:40 <Lokathor> oh you could, but my wrist hurts and i've other coding to do so i'll just bumble with linked lists and suffer the overhead
21:13:50 <iqubic> With ArrayList, you have one pointer to an object (the ArrayList) and then you can add or remove items to that indefinitely, without which object the variables point to.
21:13:55 <Lokathor> in my case, the linked lists are never too large
21:14:13 <Axman6> I came up with an idea for a structure for storing sorted data with hopefully slightly better constants than a resize-by-multiplying-by-2 normally does
21:14:31 <iqubic> Lokathor: Haskell has linked lists? Circular or no? Is is doublely linked?
21:14:57 <Lokathor> ...can't.... tell if joking...
21:15:24 <iqubic> I am joking.
21:15:39 <iqubic> I know the answers to my own questions.
21:16:01 <Axman6> basically, it's the same idea, but instead of copying every element into the beginning of the array and needing to move on average n/2 elements when inserting, put them in all the even (or odd) locations with spaces between. then initially inserts will be O(1), getting slower (but still hopefully faster on average)
21:16:02 <iqubic> My point is: why not just use Java if you want mutable data
21:16:19 <glguy> That's seems like a bad point
21:16:25 <Axman6> Haskell also has doubly linked lists, but every operation on them is basically O(n)
21:16:51 <iqubic> Haskell is *NOT* know as a language with mutable data.
21:17:00 <iqubic> at least not know to me
21:17:11 <Axman6> sometimes mutable structures are the right choice, and there's no reason why we shouldn't have access to mutable structures too
21:17:39 <Axman6> iqubic: I disagree with that, haskell is great for mutable structres (in some cases)
21:18:25 <iqubic> How (and why) does haskell have mutable data structures?
21:18:43 <Axman6> having actual mutable variables would be really useful for avoiding indirections though (IORefs are a mutable pointer, not a mutable value - super useful, but sometimes not what you want)
21:19:40 * glguy assumes iqubic knows the answers to his questions and ignores them
21:19:42 <Axman6> iqubic: Data.HashMap uses a lot of mutable structures internally for better performance, for example (though its API is supposed to be safe)
21:19:45 <iqubic> > let x = x +
21:19:47 <lambdabot>  <hint>:1:12: error:
21:19:47 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
21:19:51 <iqubic> > let x = x + 5 in x
21:19:57 <lambdabot>  mueval-core: Time limit exceeded
21:20:05 <glguy> iqubic: Nope, that's not relevant to the topic of mutable structures
21:20:13 <iqubic> Is it not?
21:20:18 <glguy> Correct
21:20:26 <iqubic> Why not?
21:20:30 <pacak> You are not mutating x here.
21:20:52 <Axman6> to perform mutation, you need IO (or ST)
21:20:59 <pacak> > let ones = 1 : ones in ones
21:21:01 <Axman6> because ordering matters
21:21:01 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
21:21:10 <pacak> You are doing something like this.
21:21:17 <iqubic> Oh, I see.
21:21:27 <quick_dudley> iqubic: Haskell has mutable pointers and mutable arrays, just not mutable values. And reading or writing mutable pointers and arrays needs something like IO or ST
21:21:39 <pacak> Or STM
21:22:13 <Axman6> right
21:23:07 <iqubic> Is there a guide to all this that I can read?
21:23:24 <cheater> is there a good way to use read, but if it can't read, then get a Nothing?
21:23:27 <Axman6> there's plenty of documentation
21:23:35 <iqubic> cheater:
21:23:37 <Axman6> there's a readMay function
21:23:39 <glguy> :t Text.Read.readMaybe
21:23:40 <lambdabot> Read a => String -> Maybe a
21:24:01 <pacak> :t reads
21:24:02 <lambdabot> Read a => ReadS a
21:24:07 <cheater> oh nice, but that depends on the text package, right?
21:24:12 <cheater> pacak what is ReadS?
21:24:12 <glguy> no
21:24:19 <iqubic> mutable data in haskell seems like Java strings. 
21:24:25 <cheater> thank you glguy
21:24:29 <pacak> > reads "1" :: [(Int, String)]
21:24:30 <lambdabot>  [(1,"")]
21:24:33 <Axman6> the Text.* stuff is much older that Data.Text
21:24:51 <Axman6> than*
21:24:55 <pacak> > reads "x1" :: [(Int, String)]
21:24:57 <lambdabot>  []
21:25:22 <iqubic> Java strings are not mutable, but still accept things like: s = "Hello"; s = s + "World"
21:25:36 <pavonia> Is there an example for a type where reads may yield more than one result?
21:25:49 <Axman6> pavonia: I've never seen one
21:25:53 <iqubic> It just changes which string s is pointing to.
21:26:04 <Axman6> I don't believe it's recommended. why it's not Maybe I have no idea
21:26:27 <Axman6> iqubic: the variable s is mutable though - the object pointed to by s changes
21:27:05 <iqubic> Axman6: How is that different from haskell's mutability?
21:27:26 <Axman6> it's not really, we're just much more explicit about it
21:27:43 <iqubic> How so?
21:28:18 <Axman6> the equivalent would be: do{ ref <- newIORef ("hello" :: Text); refVal <- readIORef ref; writeIORef ref (refVal <> "World")}
21:28:37 <iqubic> Oh, That has a lot more boiler palte
21:28:46 <iqubic> What si the type of that function?
21:28:55 <Axman6> IO ()
21:29:03 <iqubic> HOW???
21:29:14 <iqubic> :t writeIORef
21:29:15 <lambdabot> error:
21:29:16 <lambdabot>     • Variable not in scope: writeIORef
21:29:16 <lambdabot>     • Perhaps you meant ‘writeSTRef’ (imported from Data.STRef)
21:29:16 <Axman6> how could it be anything else?
21:29:25 <iqubic> :t writeSTRef
21:29:27 <lambdabot> STRef s a -> a -> ST s ()
21:29:40 <Axman6> writeIORef :: IOTRef a -> a -> IO ()
21:29:50 <iqubic> Oh, I see
21:30:14 <iqubic> IORef is STRef with s being Identity, right?
21:30:19 <quick_dudley> I'm surprised lambdabot doesn't import that module
21:30:31 <Axman6> no
21:30:36 <quick_dudley> :t modifySTRef
21:30:38 <lambdabot> STRef s a -> (a -> a) -> ST s ()
21:30:49 <Axman6> s is the magic that makes ST guaranteed pure
21:30:56 <iqubic> oh.
21:31:15 <glguy> IORef is STRef with 'ReadWorld' basically (Identity has the wrong kind)
21:31:22 <Axman6> IIRC IORef is something like data IORef = STRef RealWorld# a
21:31:37 <glguy> with ReadWorld just being a well-known, uninteresting type
21:32:02 <iqubic> Axman6: In that Hello World example, you could have used modifyIORef
21:32:13 <Axman6> yes
21:32:24 <Axman6> modifyIORef ref (<> "World")
21:32:51 <iqubic> do{ ref <- newIORef ("hello" :: Text); modifyIORef ref (<> "World")}
21:33:18 <iqubic> Is it possible to return the final IORef here?
21:33:39 <Axman6> just return ref
21:34:06 <iqubic> And that will have type IO (IORef Text)
21:34:12 <Axman6> yes
21:34:22 <iqubic> Is there a nicer way to write that?
21:34:33 <Axman6> it's worth thinking about what happens if you return refVal as well
21:34:47 <zqvt8> is there a specific reason that a "take the last n elements of a list" function is not implemented in the default libraries? seems very common
21:34:55 <iqubic> From the first verion?
21:34:56 <Axman6> just newIORef ("helloWorld" :: Text) :P
21:35:09 <iqubic> How did you get that?
21:35:15 <iqubic> Where did that come from?
21:35:28 <Axman6> zqvt8: because they're singly linked lists, that's actually a pretty hard function to write efficiently
21:36:13 <quick_dudley> zqvt8: I suppose it does seem like a reasonable thing to put in a default library, but I can't remember ever needing to do it
21:36:24 <Axman6> zqvt8: it's trivial to define reverse . take n . reverse, but that's not exactly a safe function, since the list may be infinite
21:37:00 <Axman6> zqvt8: what is the result of takeLast 10 [1..]?
21:37:01 <iqubic> Axman6: If the list is infinite, then there exist no last n elements.
21:37:08 <quick_dudley> I don't think there's any way to take the last n elements of a list safely once infinite lists are allowed
21:37:17 <iqubic> quick_dudley: There isn't
21:37:25 <Axman6> and infinite lists are always allowed
21:37:29 <iqubic> Leastways I don't think there are.
21:37:39 <iqubic> Infinite lists are easy to get.
21:37:53 <iqubic> > let ones = 1 : ones in ones
21:37:55 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
21:38:06 <glguy> > let takeLast n xs = drop (length xs - n) xs in takeLast 10 [1..] :: [Word8]
21:38:08 <lambdabot>  [246,247,248,249,250,251,252,253,254,255]
21:38:23 <quick_dudley> In general you can't find the end of an infinite list, but if you know what function is generating the list you might be able to figure out the asymptote.
21:38:26 * Axman6 glares
21:39:33 <iqubic> glguy: That only works because the list of Word8 runs out of values to add to the list so it isn't actually infinite, despite looking like it is.
21:39:34 <pacak> Axman6: There's a function to take one last element, called last. Why is it there if lists can be infinite?
21:39:53 <iqubic> :t last
21:39:54 <lambdabot> [a] -> a
21:40:00 <iqubic> That's the function.
21:40:10 <iqubic> > last [1..]
21:40:16 <lambdabot>  mueval-core: Time limit exceeded
21:40:23 <quick_dudley> last is supposed to be used extra-carefully
21:40:31 <iqubic> Yeah.
21:41:11 <iqubic> Head is also supposed to be used carefully. But that's because you should almost always pattern match on lists, rather than use head and tail.
21:41:25 <iqubic> > head []
21:41:26 <pacak> Why is it not accursedUnutterableLast then, the same way as accursedUnutterablePerformIO is?
21:41:27 <lambdabot>  *Exception: Prelude.head: empty list
21:42:06 <pacak> And accursedUnutterableHead?
21:42:06 <glguy> It's infinite lists that have to be used carefully
21:42:31 <glguy> head and last aren't so dangerous as to merit such a scary prefix
21:43:38 <quick_dudley> accersedUnutterablePerformIO is more prone to doing accursed things without even having the decency to throw a runtime exception
21:45:16 <iqubic> :t accersedUnutterablePerformIO
21:45:18 <lambdabot> error:
21:45:18 <lambdabot>     Variable not in scope: accersedUnutterablePerformIO
21:45:30 <quick_dudley> :t unsafePerformIO
21:45:31 <lambdabot> error: Variable not in scope: unsafePerformIO
21:45:49 <pacak> I don't think lambdabot will allow you to use them.
21:46:03 <quick_dudley> Putting that in lambdabot's scope would probably be a bad idea anyway
21:46:09 <Axman6> pacak: well, last has complexity O(infinity + 1) where as takeLast n has complexity O(infinity + n), which is obviously _much_ worse :P
21:46:10 <iqubic> IO a -> a seems problematic.
21:46:27 <quick_dudley> It is
21:46:49 <iqubic> It alawys you to do any IO and get any result you need.
21:47:20 <EvanR> that sounds pretty good!
21:47:21 <iqubic> because you just end with "return whateverYouWant"
21:47:51 <iqubic> So you can tell you computer to detonate a nuclear bomb, and then return 0.
21:48:14 <iqubic> Which doesn't seem right at all.
21:48:22 <iqubic> unsafePerformIO is bad.
21:48:31 <Axman6> it used to be possible to implement unsafeCoerce using IORefs and unsafePerformIO
21:48:40 <quick_dudley> There are situations where it's useful though: such as when you have a function that's externally pure but internally uses concurrency or some other feature that prevents it from being implemented in ST
21:48:42 <EvanR> this is a bit of a weak argument agains UPIO
21:48:48 <pacak> iqubic: How so? Javascript people do this all the time.
21:49:36 <pacak> quick_dudley: Yea, like bytestring or unordered-containers. It can result in some fun to catch bugs as well.
21:50:43 <EvanR> the only certainty with UPIO is, its ok as long as your computation "is pure"
21:51:19 <EvanR> due to IO being way more than simply I/O
21:51:33 <EvanR> that makes sense
21:52:10 <iqubic> http://lpaste.net/356833\
21:52:32 <iqubic> Is lambdabot unable to respond to posts to lpaste?
21:52:51 <iqubic> Also, that's taken from the second answer here: http://lpaste.net/356833
21:52:52 <quick_dudley> I'm actually surprised it's in unordered-containers: that seems like something which would be pretty compatible with ST
21:53:06 <iqubic> Sorry, second answer here: https://stackoverflow.com/questions/10529284/is-there-ever-a-good-reason-to-use-unsafeperformio
21:54:43 <EvanR> youd think if there was never a good reason to use it... it wouldnt exist
21:54:46 <pacak> quick_dudley: Hmmm.... Actually it might be just ST. It's doing a bunch of allocation and copying.
21:54:51 <Lokathor> lambdabot should have the unsafe functions in scope so that it can tell you their type, but then if you call them she just says "no way no how"
21:54:59 <Lokathor> like literally that exact phrase
21:55:24 <EvanR> @src unsafePerformIO
21:55:24 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
21:55:38 <EvanR> good, the weird replies still exist
21:56:10 <iqubic> @src trace
21:56:11 <lambdabot> trace string expr = unsafePerformIO $ do
21:56:11 <lambdabot>     hPutStrLn stderr string
21:56:11 <lambdabot>     return expr
21:56:30 <iqubic> And that is an example of "safe" UPIO
21:56:39 <EvanR> i dont know about that
21:56:50 <iqubic> How might that not be safe?
21:57:05 <EvanR> it has side effects
21:57:14 <iqubic> trace :: String -> a -> a
21:57:37 <iqubic> EvanR: hPutStrLn is hardly a side effect in my book.
21:57:44 <EvanR> o_O
21:57:50 <pacak> It's safe in a sense that it won't launch missile or eat your cat. At most it will beep from console.
21:58:11 <iqubic> I mean, unless another part of the program reads from stderr.
21:58:12 * dmwit squints
21:58:15 <EvanR> it will certainly have an effect on your stderr behavior, and if this was a test, it might fail the test
21:58:20 <iqubic> But I doubt that will have.
21:58:22 <dmwit> What exactly do you mean by "safe"?
21:58:40 <iqubic> dmwit: no side effects.
21:59:08 <iqubic> But clearly *all* IO has side effects, hence the name unsafe.
21:59:21 <EvanR> if you arbitrarily cared about the exact behavior of stderr, then the type of whatever using that will "guarantee" (wrongly) that nothing happens to stderr
21:59:30 <EvanR> no, not all IO has side effects
21:59:32 <pacak> :t return 1 :: IO Int
21:59:33 <lambdabot> IO Int
21:59:42 <EvanR> also ST 
21:59:45 <iqubic> Alright then. I stand corrected.
21:59:47 <EvanR> among many other things
22:00:21 <dmwit> I suspect we also do not agree on the meaning of the term "side effects".
22:00:24 <iqubic> Haskell if full of exceptions to the rule.
22:00:34 <pacak> Extracting 1 from return 1 with unsafePerformIO is 100% safe.
22:00:39 <iqubic> dmwit: What do you mean by "side effect"?
22:00:42 <Axman6> many of the 'safe' uses of unsafePerformIO can these days be performed in ST and actually be safe
22:00:53 <pacak> It's just often you don't know what else is in there.
22:00:57 <iqubic> What is ST?
22:01:13 <Xe> the state monad
22:01:23 <Axman6> not quite
22:01:24 <pacak> Like State, but on steroids.
22:01:44 <iqubic> Oh.
22:01:46 <pacak> Basically IO, but limited to safe-ish stuff.
22:01:55 <Axman6> it is IO without any io, and uses a trick to ensure it actually is safe
22:01:57 <iqubic> What do you mean by safe.
22:02:12 <iqubic> Also, ST is IO sans IO?
22:02:12 <Axman6> (the underlying immplementation is the same in GHC)
22:02:16 <Axman6> yes
22:02:16 <pacak> It won't eat your cat. But can make 2+2 to be equal 5.
22:02:23 <iqubic> how the heck is that possible???
22:02:34 <Axman6> it's basically the mutation bits of IO without the input and output bits of IO
22:03:02 <iqubic> Alright, I have to go.
22:03:04 <pacak> iqubic: There's a bunch of functions defined for ST - mutations, allocations, etc. But eating cats and launching missiles are not amongst them.
22:03:05 <iqubic> Night all.
22:03:17 <Axman6> so you can allocate mutable arrays in it, modify them, then "freeze" them and return those, but it's not possible to return the mutable arrays
22:03:19 <pacak> Night O_o
22:03:37 <dmwit> Anything that ruins the claim "I can replace a computation with the computed value and have the program behave the same (up to runtime and memory usage)" would fall into "side effects" land for me, I think.
22:04:51 <dmwit> But if I replace `trace "hi" 5` with the value it computes, namely, `5`, then the program behaves differently (it doesn't print "hi"). So I would call that a side effect.
22:05:59 <pacak> If a tree falls in a forest and no one is around to hear it, does it make a sound?
22:06:12 <Axman6> yeah the running out of memory thing is one I'm never satisified with
22:07:14 <Axman6> dmwit: well, more to the point, if (trace "hi" 5, trace "hi" 5) behaves differently from let x = trace "hi" 5 in (x,x) then it's not pure (I feel that better shows why this is a useful thing to have)
22:07:32 <EvanR> if what you care about changes when you replace equals with equals, then... something
22:08:10 <EvanR> if i care so little about stderr that i pipe it to /dev/null, i cant tell the diff
22:08:30 <Axman6> sure you can, if you fill up /dev/null :P
22:09:31 <EvanR> i was going to say, unless at the same time you care about CPU wattage
22:10:17 <EvanR> then you can tell the difference again
22:10:22 <EvanR> choose what you care about wisely!
22:11:30 <Axman6> yeah, at some point you decide the CPU/OS/something is an interpreter and not part of your program and then it's all good
22:11:36 <Axman6> "someone else's problem"
22:14:45 * hackagebot miso 0.1.4.0 – A tasty Haskell front-end framework – https://hackage.haskell.org/package/miso
22:18:42 <dmj`> added a websocket example, https://websocket.haskell-miso.org/
22:22:05 <pacak> view-source:https://websocket.haskell-miso.org/all.js
22:23:09 <pacak> Looks unpleasant.
22:23:24 <Axman6> that's just gHCJS
22:23:45 <Axman6> which models the STG VM pretty closely (and this works surprisingly well)
22:24:17 <Axman6> luite_: has done a pretty awesome job :)
22:25:10 <dmj`> he really has
22:25:56 <cheater> in a QuickCheck property test, how can I tell QuickCheck to generate only Int's between 0 and 1000?
22:26:01 <cheater> can i do this using Options?
22:26:26 <pacak> cheater: generate one between 0 and lots, use mod.
22:26:29 <pacak> or rem
22:27:23 <cheater> I don't want to do that, I want to tell QuickCheck to generate the right numbers in the first place
22:28:46 <pacak> ghcjs might be a way to get something in production without having to deal with javascript, but generated code looks insane. Some stupid people decided that using electron is good enough way to develop cross platform apps. Somebody might decided that ghcjs is good enough to be used in production as well.
22:29:14 <Cale> We're using ghcjs in production
22:29:37 <EvanR> im looking at nw.js for non-cross platform apps
22:29:41 <Cale> It's really nice to be able to build web applications entirely in Haskell, and to share the vast majority of the code with our mobile applications
22:29:57 <Cale> (the mobile apps being compiled to native ARM code with GHC)
22:29:57 <EvanR> just for the vast graphics support
22:30:03 <dmj`> pacak: atom editor, slack, plenty of people use electron in product as well
22:30:11 <pacak> Sure. And people are developing chat applications with electron.
22:30:12 <dmj`> production*
22:30:29 <Cale> The generated code looks insane, but it works quite reasonably well.
22:30:30 <EvanR> function h$l32(x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15, x16, x17, x18, x19, x20, x21, x22, x23,
22:30:37 <EvanR> im amazed js can deal with this
22:30:50 <Cale> You lose a factor of 4 or so relative to native code
22:30:51 <EvanR> i can totally imagine v8 being like "nobody will use that many args, make it slow"
22:31:02 <Cale> But that's quite tolerable most of the time
22:31:43 <Cale> I have found some bits of the ghcjs RTS which v8 doesn't like. h$e is one of them
22:31:49 <pacak> dmj`: Right. So if I want to use skype and forced to use slack - I can either keep 2gb of ram dedicated for chats or I can go for something more native - and use ~20x less memory  and about 200x less CPU.
22:31:56 <Axman6> Slack is a particularly poor example though, it's so resource hungry it's crazy
22:32:15 <EvanR> so
22:32:18 <Axman6> but Visual Studio Code is actuallly pretty nice
22:32:18 <Cale> Not entirely sure what to do about them -- I may need to actually learn something about how these JS engines work
22:32:25 <EvanR> whats ghcjs using google closure library for?
22:32:57 <Lokathor> i'm looking at old code
22:33:00 <Lokathor> and it uses foldl
22:33:15 <Lokathor> ...and i'm not sure if i meant to use foldl for real, or if i should have used foldl'
22:33:30 <Cale> Lokathor: Note that if you compile with optimisations, foldl is often compiled to the very same thing as foldl'
22:33:46 <Lokathor> oh yeah
22:33:47 <Lokathor> duh
22:33:57 <Axman6> but it's not guaranteed
22:33:58 * pacak wants to generate sane javascript from haskell and for that /me wants to be able to get an arbitrary haskell expression and get it's AST. using TH or anything
22:34:00 <Cale> But yeah, foldl' is often safer in the cases where you want it -- just so the compiler doesn't have to guess as much
22:34:22 <Axman6> the output from elm is pretty readable
22:34:29 <Axman6> purescript not as much but still doable
22:34:36 <Lokathor> foldl likely can't blow out the thunk stack in this case because the list is never long enough
22:34:43 <Lokathor> usually <10 elements
22:35:25 <EvanR> still seems like foldl' is the idiomatic choice when you arent trying to do a lazy left fold
22:35:27 <pacak> Axman6: Last time I looked at purescript it tried to install few hundred megabytes of javascript crap from npm in addition to pure haskell code.
22:36:06 <Axman6> welcome to javascript dev
22:36:21 <marvin3> what is a real world example of actually wanting to use foldl over foldl'?
22:36:22 <Lokathor> EvanR, but i don't know if i wanted to do it lazy or not :P
22:36:32 <Lokathor> i probably didn't
22:37:01 <quick_dudley> The only time foldl is preferable to foldl' is if the first argument is tail recursive
22:37:02 <cheater> i am using a test suite in my cabal file (it has type: detailed-0.9) and in my test-module when i import something from the library i'm testing i get linker errors. does anyone have any clues what might be happening? here's a log of what i see: https://dpaste.de/HOkd
22:37:11 <quick_dudley> even then: it's debatable
22:38:15 <pacak> Axman6: I thought the idea for purescript was "javascript, but without bad parts". I do maintain a sizeable site in javascript and I know it's possible to do it without having to touch npm.
22:38:41 <Axman6> lots of stuff in purescript uses react right?
22:38:43 <paf31> You don't need npm to compile purescript
22:38:52 <Cale> marvin3: It's pretty rare.
22:39:23 <Cale> marvin3: I suppose reverse is an example of something where it clearly doesn't hurt to use foldl
22:39:54 <cheater> why would you even get a linker error for such simple code? https://dpaste.de/h1sa
22:39:55 <Cale> To prefer foldl over foldl' you'd want the combining function to be more expensive, but similarly lazy as flip (:) is
22:41:09 <Axman6> cheater: have you exported the right modules from the library?
22:41:15 <cheater> i don't know
22:41:32 <cheater> do you mean exposed-modules?
22:41:37 <Axman6> in the cabal file, do you have Math.Fibonacci in the exposed-modules section?
22:41:37 <cheater> all the modules are exposed
22:41:39 <pacak> paf31: main page suggest installing purs pulp and bower from npm. trying to compile anything (taked  from the front page) with purs installed from hackage results in various complains about missing stuff.
22:41:42 <cheater> yes
22:41:54 <EvanR> Lokathor: was it something like a sum?
22:41:55 <Axman6> and you have the library as a dependency of the tests?
22:41:57 <cheater> but if they weren't exposed cabal/ghc would complain, rather than crash and burn
22:42:03 <cheater> yeah
22:42:16 <EvanR> you had to do the whole thing before using any of it
22:42:36 <Lokathor> EvanR, it was, uh sorta? https://github.com/Lokathor/ludolib/blob/master/bench/Util/PPFOVBoxed.hs#L250
22:43:02 <Lokathor> based on some python code where the python code clumsily walked a half-way linked list, and then updated an accumulator as it did
22:43:19 <Lokathor> so, yeah, basically a sum
22:43:21 <cheater> i think it might be the test lib i'm using, it's cabal-test-quickcheck. can someone suggest another good lib for running a few light quickcheck tests when i do 'cabal test'?
22:43:47 <EvanR> Lokathor: is this some kind of append to the end of a list?
22:44:10 <Lokathor> uhhh, no
22:44:52 <Lokathor> it's like... uh... an insane filter... kinda? Like you start with one value, and then as you walk the list you run a predicate between the accumulator and the list element you're at and if it checks out you update your accumulator value
22:45:22 <Lokathor> i guess it's not like a filter, it's just like a fold
22:45:33 <EvanR> yeah
22:46:51 <Lokathor> just gonna rewrite it with foldr
22:47:15 <Lokathor> in this case i don't think i needed any of the properties of l, i just picked the one whose func arguement order matched what i had
22:47:51 <EvanR> foldl' seems like it makes more sense
22:47:57 <Lokathor> oh?
22:48:29 <EvanR> would it work on an infinite list?
22:48:38 <Lokathor> uh, no
22:48:42 <Lokathor> it would fail to terminate
22:49:33 <paf31> pacak: I'm saying if you don't want to use npm you don't have to
22:49:55 <Lokathor> http://www.roguebasin.com/index.php?title=Permissive_Field_of_View_in_Python was how it looked in python
22:49:56 <paf31> The recommended path is to install tools from npm though because it's simpler
22:50:14 <EvanR> this means nothing to me
22:50:17 <Lokathor> while node.next is not None: .... node = node.next
22:50:17 <paf31> But there are alternatives which are all Haskell
22:50:41 <Axman6> cheater: tasty works well in my limited experience
22:50:51 <Lokathor> in other words: it has to consume the entire list, and it has to be a finite list
22:51:20 <EvanR> Lokathor: foldl' gives you the effect of doing a loop over a finite list, evaluating the accumulator at each step
22:51:51 <pacak> paf31: Maybe I haven't tried hard enough then.
22:52:09 <EvanR> until you get the final accumulator
22:53:05 <EvanR> foldr allows the accumulator to be built lazily, so it works on an infinite subject list
22:53:16 <EvanR> foldl is foldr backwards
22:53:57 <Lokathor> so does foldr still work at all when foldl' is the answer (assuming you flip your function argument order)
22:54:07 <EvanR> yes but less efficiently
22:54:08 <Lokathor> or does it lazily lazy too much lazy?
22:54:11 <Lokathor> ah
22:54:42 <EvanR> the loop situation doesnt need laziness
22:55:42 <Lokathor> doesn't at all
22:59:22 <cheater> how do i use test-framework with quickcheck? test-framework-quickcheck only works with QC < 2, and that requires base < 4.8, and ghc 7.2 comes with base > 4.8.
22:59:33 <cheater> er ghc 7.10
23:00:36 <cheater> o there's test-framework-quickcheck2
23:01:18 <cheater> yea that worked yay
23:14:44 <zqvt8> is there a way to compile a parallel haskell program so that the user does not need to explitily run it with "+RTS Nx"?
23:15:24 <Axman6> -threaded -rtsopts--with-rtsopts=-N IIRC
23:15:45 <Axman6> (the second flag may not be necessary if you want o not allow the user to specify further opts)
23:16:00 <zqvt8> I'll try it out, thanks!
23:16:13 <MarcelineVQ> ye, -threaded -rtsopts -with-rtsopts=-N
23:21:52 <cheater> hey guys i have a quickCheck test which never fails no matter what i do. I can negate it and it still passes. what gives? here's the code https://dpaste.de/Hvpb am I doing something weird?
23:26:50 <quchen> cheater: Try running it with verboseCheck instead of quickCheck. This will show you which inputs are used.
23:27:15 <cheater> it's not about inputs I set the prop to just False and it still succeeded
23:28:25 <quchen> cheater: Can you write a self-contained file we could debug? The code looks correct
23:28:26 <cheater> so the stupid issue was that even if quickCheck fails, it doesn't exit non-zero
23:28:28 <cheater> so
23:28:41 <quchen> (The parentheses are redundant by the way)
23:28:49 <cheater> the solution was to use test-framework and test-framework-quickcheck2 and defaultMain and testProperty
23:29:08 <cheater> which, around fibTable and fibFast?
23:29:12 <quchen> Yes
23:29:51 <cheater> yeah, i know, it's only because of something else I had going that I deleted for now
23:29:57 <cheater> anyways using tf worked :)
23:38:46 <Lokathor> tfw a loop is almost a fold, but not quite a fold
23:39:45 <erisco> maybe it is a paramorphism
23:40:01 <quchen> Lokathor: A loop can be much more than a fold, it can jump around arbitrarily
23:40:37 <quchen> A fold is a very limited form of loop, namely one that looks at each list element at most once, and in order
23:40:41 <Lokathor> checkSub :: [Location] -> Set Location -> [View] -> Set Location -- stop stops as soon as either list is empty, and the size of the second list does not strictly decrease over time.
23:42:27 <Lokathor> you could maybe make it into a fold over the [Location], but not terminating early when the [View] is empty is probably bad for your performance
23:44:17 <erisco> early termination is not necessarily difficult
23:44:37 <Lokathor> i just did it with function cases
23:45:11 <quick_dudley> It's particularly easy if you're using ContT, but so is spaghetti code
23:45:42 <Lokathor> hmm
23:46:27 <Lokathor> does contT usually go faster, slower, or the same as a plain function?
23:46:43 <quick_dudley> I haven't noticed
23:47:13 <Lokathor> hmm
23:47:43 <Lokathor> https://github.com/Lokathor/ludolib/blob/master/bench/Util/PPFOVBoxed.hs#L219 does this look like the kind of weird loop that could be done into ContT?
23:47:53 <quick_dudley> probably a little slower for most functions, but there are a few monads which are faster with ContT over the top
23:49:42 <Lokathor> C is the only fast language :(
23:50:14 * Lokathor glumly converts all IORefs into Ptrs instead
23:50:21 <erisco> speed is not the only function of a car
23:50:44 <quick_dudley> I wouldn't use it in that situation: but an example of where it's useful is stopping in the middle of `traverse`
23:50:57 <Lokathor> sure but if you're writing a module with a single complex function to call and very simple arguments
23:51:06 <Lokathor> all the intermediate steps should ideally be as fast as possible
23:52:00 <quick_dudley> ContT has a small overhead, so probably better not to use it unless you know you're doing something it's good at
23:52:08 <Lokathor> ah well
23:52:26 <quick_dudley> like, about the same overhead as StateT, more or less
23:59:22 <tdammers> I don't normally care about small overheads; an abstraction that expresses the right concepts is usually worth more to me
