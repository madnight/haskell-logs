00:03:20 <MarcelineVQ> unqiue types due to scope,  "forall a1 b1. Identity a1 -> Identity b1"
00:04:12 <MarcelineVQ> iow when you mention a type variable like that you're mentioning a new type variable
00:04:42 <osa1> MarcelineVQ: any way to declare a type variable in GHCi?
00:06:15 <MarcelineVQ> :seti -XScopedTypeVariables    :t coerce (undefined :: a -> b) :: forall a b. Identity a -> Identity b
00:06:32 <MarcelineVQ> is the only way I can think of to fix it when it's written like that
00:07:35 <MarcelineVQ> because the 'scope of types' is defined by the outermost type signature there, you can use ScopedTypeVariables and forall to tell ghc that you're talking about the same a and b on the inside
00:07:45 <MarcelineVQ> Hopefully I'm not too far off with that explanation
00:08:31 <osa1> hmm makes sense
00:30:40 <eklavya> is there an easy to follow backpack blog post, showing what it is and how to use it?
00:31:47 <eklavya> also, will frameworks like servant use compact regions for request lifecycle memory management?
00:33:53 <MarcelineVQ> eklavya: some posts by the creator of backpack about it http://blog.ezyang.com/category/haskell/backpack/
00:35:35 <Franciman> Hello
00:36:48 <eklavya> thanks MarcelineVQ :)
00:36:57 <Franciman> I have a datatype Tree for a binary tree, and I've written usual functions of binary search trees for it. Now I'd like to extend the tree by adding a further value to each node which I'll use for other computations. How can I make another datatype which uses Tree but adds this new value to all nodes?
00:37:21 <jle`> Franciman: you can parameterize your tree type
00:37:26 <jle`> by the type of its nodes
00:37:35 <jle`> or the things it contains
00:38:01 <jle`> for example, instead of having a binary tree that only holds Ints, or only holds Bools, or Doubles
00:38:22 <jle`> make one that can hold a value of a type it is parameterized over
00:38:44 <Franciman> jle`, but, by doing so, can I still use the tree type by itself, without the augmenting data?
00:38:58 <Franciman> I need both a tree type and this augmented tree
00:39:06 <Franciman> I should use phantom types, maybe?
00:39:11 <jle`> Franciman: what is your current tree type?
00:39:30 <Franciman> data Tree a = Empty | Tree a Int (Tree a) (Tree a)
00:39:34 <Franciman> the Int is for balancing
00:39:38 <jle`> ah, so it's already parameterized
00:39:44 <Franciman> now I want to make an interval tree, so I want one more value in the nodes
00:39:51 <Franciman> it should become
00:39:56 <Franciman> Tree a Int Int (Tree a) (Tree a)
00:40:16 <jle`> can't you just do `Tree (Int, a)` instead of `Tree a` ?
00:40:37 <Franciman> yes, but then can I make another instance of Ord that overloads the usual?
00:40:44 <jle`> no
00:40:44 <Franciman> for Ord a, b => (a, b)
00:40:53 <jle`> well
00:40:57 <jle`> yes, that's the instance you automatically get
00:41:05 <jle`> for instance Ord a => Ord (Tree a)
00:41:05 <Franciman> that Int does not have to impact on ordering
00:42:48 <jle`> there's the `Arg a b` that's basically a newtype wrapper over (a, b) that has an Ord instance that igorres the 'b'
00:43:00 <jle`> so you could do Tree (Arg a Int)
00:43:16 <Franciman> oh cool
00:43:18 <Franciman> thanks
00:43:23 <jle`> but it depends on what you want to do in the end, really
00:43:29 <jle`> all i'm offering you is suggestions in a vacuum
00:43:32 <jle`> with no other context
00:43:50 <Franciman> jle`, I need an interval tree and a tree
00:43:54 <Franciman> and I want to share the common code
00:43:54 <jle`> if you look at the big picture, you might get a better/different answer :)
00:43:56 <Franciman> that's all
00:43:58 <Franciman> got it
00:45:09 <jle`> the problem with this is that you don't get a nice Functor instance
00:46:16 <jle`> if Arg was backwards, you could use `(Tree :.: Arg Int) a` where fmap would do what you want, but Arg in base has the arguments in the wrong order for that, heh
00:46:58 <Franciman> jle`, but does it make sense to make a functor instance for a balanced binary tree?
00:47:09 <Franciman> yep it does, but I mean, is it worth it, sorry?
00:47:34 <jle`> well you get a couple of nice utility functions
00:47:39 <jle`> from Data.Functor
00:48:21 <jle`> but it might not be important to you in your uses
00:48:28 <Franciman> for example for the interval tree, I don't think it makes sense
00:48:37 <Franciman> since fmap potentially transforms intervals in other things
00:48:40 <Franciman> which are not intervals
00:48:50 <jle`> mhm, the pros/cons will depend on your use case
00:49:07 <Franciman> well, thanks for giving me advices and context
00:49:20 <jle`> one advantage of making it a FUnctor is that there are some interesting combinators that are polymorphic over functors
00:49:28 <jle`> but yeah it might not be important to you
00:49:36 <jle`> (like Free, lenses, etc.)
00:51:03 <Franciman> so, to be sure I'm not going to cry about it, I will follow your advice and not share code :P
00:51:48 <jle`> it'd be nice to be able to re-use the code
00:52:31 <rowmal> \h
00:52:44 <rowmal> 
00:52:58 <jle`> Tree (Arg a Int) isn't too bad i don't think, but you could also define your own Argie intervalish type
00:53:09 <jle`> data Interval a = Interval Int a
00:53:12 <jle`> with the Ord instance you want
00:53:16 <jle`> and do Tree (Interval a)
00:53:18 <Franciman> right
00:53:22 <jle`> but yeah experimene tiwht different things :)
00:54:42 <Franciman> well, thank you
01:00:15 <tsahyt> is there a lens retrieving the last element of a list? or some lensy way to use last?
01:02:50 <tsahyt> :t _Snoc
01:02:51 <lambdabot> (Applicative f, Choice p, Snoc s t a b) => p (s, a) (f (t, b)) -> p s (f t)
01:04:46 <cocreature> tsahyt: https://hackage.haskell.org/package/lens-4.15.3/docs/Control-Lens-Fold.html#v:lastOf
01:06:24 <tsahyt> cocreature: thanks
01:06:30 <jle`> > over (_Snoc . _2) negate [1..10]
01:06:32 <lambdabot>  [1,2,3,4,5,6,7,8,9,-10]
01:06:47 <jle`> > [1..10] & _Snoc . _2 %~ negate
01:06:50 <lambdabot>  [1,2,3,4,5,6,7,8,9,-10]
01:07:45 <jle`> and you can retrieve it too
01:07:53 <jle`> > preview (_Snoc . _2) [1..10]
01:07:55 <lambdabot>  Just 10
01:08:15 <jle`> > [1..10] ^? _Snoc . _2
01:08:17 <lambdabot>  Just 10
01:08:28 <tsahyt> um why is the _2 there?
01:08:31 <jle`> oh there's an alias for _Snoc . _2 already
01:08:34 <tsahyt> ah
01:08:35 <jle`> called _last, surprisingly
01:08:37 <tsahyt> I see
01:08:47 <jle`> _last = _Snoc._2
01:08:53 <MarcelineVQ> What is _2 doing?
01:08:55 <tsahyt> so when or why would I use preview _last over lastOf traverse?
01:08:58 <jle`> tsahyt: it's cause _Snoc gives both the last item and the "rest of the list"
01:09:06 <jle`> tsahyt: well lastOf only lets you retrieve it
01:09:10 <MarcelineVQ> oh
01:09:14 <jle`> but _last gives you an actual prism
01:09:15 <tsahyt> I see
01:09:16 <MarcelineVQ> oops, it was just asked too ehe
01:09:17 <jle`> er, an actual traversal
01:09:22 <jle`> so you can like, use all the traversally stuff
01:09:24 <jle`> like 'over'
01:09:31 <jle`> > over _last negate [1..5]
01:09:33 <lambdabot>  [1,2,3,4,-5]
01:10:31 <jle`> of course if all you wanted to do was retrieve the last item, you could just use 'last' from Prelude
01:10:39 <jle`> (except for the fact that it's partial)
01:11:28 <tsahyt> jle`: my usecase here was to get a field from the last element of a list of records
01:11:43 <tsahyt> or to be specific, lastOf (traverse . points)
01:12:14 <cocreature> whether you should be using lists if you need to access the last element is another question :)
01:13:03 <jle`> chaining is nice, but remember that you can convert any regular ol' (a -> b) function into a getter of b's from a's by using 'to' as well
01:13:04 <tsahyt> cocreature: it's the result of an iterative process
01:13:21 <jle`> but yeah whatever floats
01:14:18 <tsahyt> :t view (to last . _2)
01:14:19 <lambdabot> (Field2 a a b b, MonadReader [a] m) => m b
01:14:26 <tsahyt> but that imposes a MonadReader constraint
01:14:37 <tsahyt> or maybe I've just done something very stupid
01:14:37 <jle`> you can pick your own instance
01:14:42 <jle`> so people usually use (->)
01:14:45 <tsahyt> ah
01:14:46 <jle`> > view (to last) [1..10]
01:14:49 <lambdabot>  10
01:14:49 <tsahyt> nvm, I did do something stupid then
01:14:55 <jle`> but view (to last) is kinda silly cause you can just use last, heh
01:15:33 <tsahyt> true, but when you want to go deeper into the structure of that last element it starts being useful
01:16:07 <jle`> lastOf (traverse . points) could also just be (view points . last)
01:16:16 <jle`> minus partialness
01:16:21 <jle`> or well, they're both partial aren't they
01:16:34 * jle` gazes out the window wistfully
01:16:42 <cocreature> no lastOf gives you a Maybe
01:16:44 <tsahyt> lastOf (traverse . points) :: Maybe Int
01:16:49 <jle`> oh, awesome
01:16:58 <MarcelineVQ> why ask for the last at all, add items you care about to the front of the list :>
01:17:34 <tsahyt> MarcelineVQ: because replicateM doesn't do it that way :P
01:17:51 <cocreature> write your own replicateM
01:18:18 <tsahyt> meh, why bother. what I have now performs as expected
01:18:25 <tsahyt> or rather, as desired
01:18:30 <cocreature> if you just need the last element, building up the list is unnecessary anyway
01:18:51 <tsahyt> I need the last element but I need all the computations to build up the other elements
01:20:00 * jle` . o (replicateM_ n *> n)
01:20:04 <jle`> er
01:20:10 <jle`> replicateM_ (n-1) x *> x
01:20:26 <tsahyt> for context, I have a stateful computation that does the brunt of the work. running it returns the best element found thus far. then I just run that for as many times as I desire, and only ever look at the last one. without looking too deeply into it, memory usage looks constant so far
01:21:05 <jle`> fmap last (replicateM n x)  =>  replicateM_ n *> x
01:21:19 <tsahyt> the whole thing is a tournament setup for training a game AI. each stateful computation performs one round, the state is the agents competing with points etc. the best agent is returned.
01:21:22 <jle`> but yeah good thing ghc optimizes away the intermediate list
01:22:37 <tsahyt> I actually use lists for iteration a lot. head . drop n . iterate foo, etc
01:22:40 <MarcelineVQ> stateful? sounds like a job for iterate/N/M/NM
01:23:04 <tsahyt> MarcelineVQ: that'd have been an alternative to what I have now
01:25:09 <tsahyt> but the iterateMs are a bit painful to use when you want to have some precise number of iterations rather than break on some condition, and standard iterate would require me to thread state manually.
01:25:34 <tsahyt> also the result of each iteration is irrelevant to the next one, only the state needs to be preserved
01:25:52 <MarcelineVQ> that's why I brought up iternateNM but whatever works :>
01:26:49 <tsahyt> I actually haven't seen iterateNM yet
01:26:57 <tsahyt> hoogle brings up something in vector, is that the one?
01:27:34 <Virgo_> good morning
01:28:54 <MarcelineVQ> I wasn't thinking of a particular one, just that the idea fits
01:38:30 <ElectricSheep2>     "editor.fontLigatures": true,
01:38:31 <ElectricSheep2>     "editor.fontFamily": "Hasklig",
01:43:02 <Virgo_> wut
01:43:48 <systemfault> I guess it's always fun to paste VSCode settings on the channel...
01:44:20 <Virgo_> well at least there is proof someone is alive in here 
01:44:31 <tsahyt> :hal (8 choose 2) * 512 * 0.5 seconds
01:44:45 <tsahyt> oops, wrong channel, sorry
01:46:16 <Virgo_> o
01:46:18 <Virgo_> ok
01:52:40 <kuribas> good morning
01:54:05 <Virgo_> good morning
02:27:28 * hackagebot irc-client 0.4.4.2 – An IRC client library. – https://hackage.haskell.org/package/irc-client
02:42:11 * hackagebot async-refresh-tokens 0.3.0.0 – Package implementing core logic for refreshing of expiring access tokens – https://hackage.haskell.org/package/async-refresh-tokens
02:42:11 * hackagebot SSTG 0.1.0.1 – STG Symbolic Execution – https://hackage.haskell.org/package/SSTG
03:04:51 <Athas> Sweet, new GHC.
03:05:21 <Athas> Can't wait for the Stack snapshot!
03:09:32 <EvanR> fresh GHC straight outta the oven
03:09:46 <EvanR> which is itself GHC
03:09:51 <EvanR> all the way down
03:09:54 <Rembane> Yo dawg...
03:10:16 <EvanR> lol
03:12:58 <Athas> Was "Glorious Haskell Compiler" ever the official expansion of GHC?
03:15:49 <peddie> Athas: I thought it was Glorious Glasgow Haskell Compiler, i.e. Glorious was an occasional title-cased prefix to the existing GHC
03:29:44 <Athas> I've seen someone say that the G started standing for "Glorious" once development moved away from Glasgow, but I don't think it stuck.
03:31:30 <cocreature> Athas: ghc --version outputs "Glorious Glasgow Haskell Compilation System" and has done so for a while
03:31:54 <cocreature> so I guess it’s up to you to choose what the G in the abreviation stands for
03:32:23 <MarcelineVQ> Grape
03:32:25 <Athas> Should be G²HC then.
03:41:51 <kuribas> Good-old
03:58:35 <fr33domlover> Hello!
03:59:00 <fr33domlover> Attroparsec has a match function: " both the result of a parse and the portion of the input that was consumed while it was being parsed"
03:59:09 <fr33domlover> Does parsec have a similar function?
04:01:43 <cocreature> megaparsec has one. I can’t find one in parsec itself
04:02:30 <fr33domlover> Thanks cocreature! I can't find one in parsec either
04:06:04 * hackagebot crawlchain 0.2.0.0 – Simulation user crawl paths – https://hackage.haskell.org/package/crawlchain
04:08:59 <tsahyt> Is there a simple way to build a lens that acts on two fields from two lenses acting on one field each?
04:09:25 <tsahyt> e.g. I have data Foo = Foo Int Int, I'd like a lens acting on both the ints from the TH-generated separate lenses
04:14:15 <osa1> anyone know if persistent has a way to run a query on a given table, rather than on the table it infers from the types?
04:15:15 * hackagebot hills 0.1.2.6 – Generate STL models from SRTM elevation data. – https://hackage.haskell.org/package/hills
04:15:15 * hackagebot QuickCheck-safe 0.1.0.3 – Safe reimplementation of QuickCheck's core – https://hackage.haskell.org/package/QuickCheck-safe
04:15:23 <tsahyt> hm actually what I'm looking for doesn't quite work anyhow
04:18:32 <tsahyt> osa1: do you mean a raw sql query?
04:18:49 <tsahyt> for "normal" queries, the types should always fully determine the table to operate on
04:19:24 <osa1> tsahyt: nope, I mean "normal" queries
04:19:40 <osa1> tsahyt: I don't understand this restriction at all. I need to implement a migration but I can't because of this.
04:20:49 <kuribas> Is it a bug if compiling with -O2 takes forever?
04:21:02 <tsahyt> osa1: but the tables in two different schemas, even when describing the same data, should be different types, no?
04:21:24 <tsahyt> or rather should correspond to different types
04:21:50 <osa1> tsahyt: imagine this scenario; you need to update your table but things will change a lot so no automatic migration (add a column with default value) etc. can do it.
04:22:35 <osa1> tsahyt: I'm no DB expert what but in cases like this what I do is; I first rename the old table, then create the new table, then read old table, write to the new table, one row at a time
04:23:35 * hackagebot template-haskell 2.12.0.0 – Support library for Template Haskell – https://hackage.haskell.org/package/template-haskell
04:23:36 * hackagebot base 4.10.0.0 – Basic libraries – https://hackage.haskell.org/package/base
04:23:52 <osa1> so if I use persistent I need to define another schema, with old table duplicated (but with a new name). then manually run "alter table", "create table" etc. and use persistent
04:24:50 <osa1> for example in selda I can define tables without giving them names. this lets me run same queries on different tables by passing table names to queries
04:25:26 <osa1> this reduces duplication
04:25:36 <tsahyt> I see
04:26:13 <tsahyt> I suppose you could define functions working on a DB in a way that remains schema agnostic through some use of classy lenses or something
04:26:18 <osa1> so AFAICS there's not way to handle this in persistent without duplicating table definitions, am I missing anything?
04:26:28 <tsahyt> but I don't think you can get away from the duplicate table definitions
04:26:34 <tsahyt> except for some TH hackery I suppose
04:26:39 <osa1> sigh
04:26:51 <tsahyt> but I'm no expert on persistent so don't take my word for it
04:26:59 <osa1> this is frustrating because with database versioning and different types for each database version etc. we already have ridiculous amount of boilerplate
04:27:54 <osa1> OH btw this also means more bugs because when there's copy-paste there are also bugs
04:29:07 * hackagebot ghc-boot-th 8.2.1 – Shared functionality between GHC and the @template-haskell@ library – https://hackage.haskell.org/package/ghc-boot-th
04:30:11 <osa1> tsahyt: forgot the mention another thing: with selda-style table definitions I can implement downgrades too
04:30:27 <osa1> tsahyt: with persistent this means even more duplication: I need to uplicate V2 tables in V1
04:36:30 * hackagebot ghc-boot 8.2.1 – Shared functionality between GHC and its boot libraries – https://hackage.haskell.org/package/ghc-boot
04:38:22 * Athas is writing his first Template Haskell code.
04:38:31 <Athas> I still find it ugly on principle, but the convenience has seduced me...
04:38:46 <srhb> Athas: It's not the worst metalanguage ever.
04:38:54 <srhb> Though i guess that's a pretty low bar. :-)
04:39:22 <eklavya> can someone please give me a tldr of backpack?
04:39:24 <Athas> No, but it's unbelievably ugly from a language purity POV.
04:39:29 * srhb nods
04:39:32 <eklavya> I am not getting the problem and the solution
04:39:47 <srhb> eklavya: ezyangs blog posts on the topic are quite approachable, if you haven't read them.
04:39:48 <Athas> eklavya: the first three or four pages of the POPL paper are quite readable.
04:40:12 <eklavya> srhb: just read the latest post but still couldn't understand the problem :(
04:40:31 <Athas> It may be that you don't have the problem.  It's mostly a solution for writing generic library code.
04:41:20 <eklavya> Athas: could you please tell more about what was missing before and how this solves it?
04:41:55 <srhb> eklavya: You should probably read some of the early ones instead.
04:41:56 <srhb> eklavya: http://blog.ezyang.com/2016/09/the-base-of-a-string-theory-for-haskell/
04:41:58 <srhb> For instance.
04:42:29 <eklavya> srhb: thanks !!
04:42:36 <eklavya> starts with a problem I know of :P
04:43:14 <srhb> It's mostly a motivational example.
04:46:11 <Athas> It will be very interesting to see the library uptake.
04:48:23 <kuribas> Is it a ghc bug when compiling with -O2 takes a long time?
04:48:31 <kuribas> Like in several minutes or more?
04:49:03 <Athas> kuribas: depends on what you compile.
04:49:07 <Athas> GHC is not a fast compiler.
04:49:25 <kuribas> some vector stuff
04:49:28 <Athas> But if you think it ought to be faster, then report it to the bug tracker.
04:49:47 <Athas> Vector stuff involves a lot of rewrite rules, yeah?  Wouldn't be surprised if GHC got stuck in the optimiser for a while.
04:49:53 <Athas> How many lines of code?
04:50:12 <kuribas> 162
04:50:33 <Athas> Okay, that's gotta be a bug somehow.
04:50:50 <kuribas> 5.6 s with -O
04:51:58 <kuribas> Is ghc particularly buggy, or is it just because I use the latest?
04:55:56 <Athas> GHC is not the most bug-free compiler, but most of the issues arise when using advanced libraries, because those libraries hook into the compiler in various ways.
04:56:25 <Athas> When compiling code that does not use rewrite rules, Template Haskell, or unsafe type hackery, GHC is pretty bug-free.
05:00:04 <cocreature> kuribas: by the latest you mean 8.2 or 8.0?
05:00:35 <kuribas> 8.0.2
05:01:55 <davr0s> does haskel automatically generate dynamic vtable and statically infered vtable based code based on context , when using typeclasses  , (e.g compared to the situation of static and runtime dispatch in rust - type-params vs 'trait-objects')
05:02:07 <cocreature> kuribas: try with 8.2 and if the problem persists, report a bug
05:02:29 <kuribas> ok
05:02:47 <kuribas> I hope upgrading to 8.2 doesn't break stuff...
05:03:21 <davr0s> e.g. in rust you write explicitely:  fn foo<T:Trait>(x:&T){... }    vs fn foo(x:&Trait)   {...}  to select between 'compile-time dispatch' and 'runtime dispatch'
05:03:48 <davr0s> in the latter case it will pass a vtable pointer paired with the data; in the former, it will resolve at copile time
05:07:33 <beepbeep_> I have a datatype that contains multiple data constructors. Is it possible to write a function for a specific data constructor without having to match all of the data constructors?
05:08:56 <kuribas> beepbeep_: that would be a partial function
05:09:21 <kuribas> which you should avoid
05:09:42 <kuribas> If you need to do that, better rewrite your datatypes then.
05:18:43 <Athas> Is there a way to speed up Template Haskell's 'lift' method for very large expressions?
05:20:04 <Athas> In my case, I have a 381600 element array that I suspect is causing issues.
05:20:36 <Athas> Or rather, a 21200x18 element array.  Probaby a pretty big Haskell expression.
06:17:07 <rain1> hello
06:17:36 <rain1> how do you implement a type checker with typeclasses for kinds beyond just * ?
06:29:30 <danilo2> hi guys! :) I've got a question regarding unboxed ADT. Let's consider I've got performance critical code and I want my ADT to be stored as raw bytes in memory. I know I can provide MVector / Storable instances for it, but it seems that they would only allow me to store it in this form in vector. However if I would like to access some unboxed element and access it's fields (like raw C++ object fields), there is no nice syntax for it 
06:32:14 <hpc> would {-# UNPACK #-} help?
06:33:30 <hpc> see https://hackage.haskell.org/package/vector-0.12.0.1/docs/src/Data.Vector.html#line-217 for an example of it
06:34:00 <danilo2> hpc: to be honest, I don't know. I know what UNPACK does, but I want to have guarantee that my nested ADT will be stored in a flat raw memory and I woudl be able to operate on it as fast as in C would be possible
06:34:14 <hpc> and https://downloads.haskell.org/~ghc/6.12.2/docs/html/users_guide/pragmas.html#unpack-pragma
06:34:21 <hpc> hmm
06:35:27 <hpc> i think unpack is the way to do that
06:35:56 <danilo2> hpc, look. Even If I got a datatype `data Foo { x :: Int, y :: [String], z :: Char }` (or more complex / nested one) If I put the "UNPACK" pragma, the fields will be unpacked, but the whole datatype will be boxed. So If I store Vector of Foo and acess any Foo from inside, before I can use "x", Foo will be boxed, wont be?
06:37:02 <hpc> ah yeah
06:37:19 <hpc> so you have two levels of boxing to content with then
06:37:30 <hpc> boxes around individual constructor parameters (which UNPACK solves)
06:37:35 <hpc> and then the box around the entire data type
06:39:33 <danilo2> hpc: yes. So how could I prevent the outer box to be constructed? Moreover, according to Haskell Wiki: "If there is a pattern match on a constructor with an unpacked field, and the value of that field is passed to a non-strict function, GHC has to re-box the value before passing it on." Why does it happen? Why we need to pack it again ?
06:42:12 <hpc> not sure, probably some implementation detail around how boxed and unboxed values get passed around
06:45:42 <danilo2> hpc: hmm, that's interesting
06:45:51 <hpc> it looks like unpack and strict fields is as close as you can get with a data definition
06:46:10 <hpc> unless you want to pull some shennanigans and operate on unboxed tuples of unboxed types
06:46:46 <hpc> which will make things like pattern matching harder
06:46:47 <danilo2> hpc: aren't unboxed tuples of unboxed types behaving the same way ?
06:47:42 <danilo2> hpc: I mean - if you've got function with strict argument and your own tuple definition that tells that its arguments are strict (and unpacked), then GHC would probably unpack everything for you, right?
06:48:31 <hpc> that does the parameter unpacking, but there's still a box around the whole ADT
06:50:41 <hpc> you should probably look up the list of caveats when manipulating unboxed tuples
06:50:50 <danilo2> hpc: hmm, maybe, so how we can get rid off it ?
07:02:38 <danilo2> By the way, could anybody tell me what is the relation between array package (Data.Array.Unboxed) and primitive package (Data.Primitive.ByteArray)? They are both wrappers around GHC's Array# and some packages use one or other (Text uses Data.Array, vector uses Data.Primitive)
07:03:14 <danilo2> are there any pros/cons when comparing them? I knwo this is a little naive question, but in fact without spending a lot of time comparing them I cannot have any thoughts by myself
07:15:40 <Netwolf> W
07:59:54 <cuc> Hi, I'm new to Haskell. Why the empty tuple () is in Enum typeclass? 
08:00:23 <hpc> because you can enumerate the values of that type
08:00:55 <hpc> > [() ..]
08:00:57 <lambdabot>  [()]
08:00:59 <hpc> ;)
08:01:40 <cuc> Why does anyone want to enumerate an empty list?
08:01:55 <Tuplanolla> Who needs zero anyway?
08:02:13 <cuc> at least there are many numbers following zero
08:02:21 <hpc> () isn't an empty list or tuple type, it's the unit type
08:02:26 <cuc> However, there is nothing following ()
08:02:52 <hpc> it's the type with one value, and behaves like the number 1 in type algebra
08:03:20 <cuc> sorry, my mistake, Why does anyone want to enumerate an empty "tuple"?
08:04:06 <hpc> why would you want to exclude an operation that behaves consistently wrt Enum? :P
08:04:57 <danilo2> Hi! Out of curiosity - is there any way to create an alias for "deriving" list? So if I've got a datatype `data Foo a = Foo a deriving Bar` I could create `type Bar = '(Show, Functor, Applicative)` etc?
08:05:29 <cjayyy> cuc: like with the id function and other stuff that seems useless on its own, it's useful to parametrize higher order stuff
08:06:22 <sproingie> danilo2: yes, with -XConstraintKinds
08:06:31 <sproingie> danilo2: https://downloads.haskell.org/~ghc/7.8.4/docs/html/users_guide/constraint-kind.html
08:06:39 <hpc> sproingie: really? i thought a deriving list was a syntactic list of class names
08:06:44 <cjayyy> cuc: imagine a datastructure that needs the Enum property for a type variable, but you don't really need to store values of that type. they you could pass ()
08:06:51 <sproingie> actually though ... i'm not sure if those work with deriving
08:07:07 <sproingie> wouldn't be surprised if they didn't
08:07:16 <danilo2> sproingie: Im using ConstraintKinds and it does not work with deriving :/
08:07:24 <danilo2> sproingie: according to: https://wiki.haskell.org/Context_alias
08:07:25 <hpc> danilo2: consider that Show and FUnctor/Applicative have different kinds ;)
08:07:33 <danilo2> hpc: it doesnt matter
08:07:37 <sproingie> yeah the deriving machinery doesn't want to have to expand stuff, i guess
08:07:47 <danilo2> hpc: look at my code, i used DataKind lifted tuple
08:08:16 <danilo2> sproingie: :(
08:08:44 <sproingie> maybe something you can do with TH
08:09:03 <danilo2> sproingie: surely I can, but putting everywhere th is just ugly
08:09:17 <danilo2> sproingie: but yeah, it is the way to go for now
08:09:18 <sproingie> violent agreement
08:12:10 <cuc> Thanks to all. 
09:28:43 <Guest221> Hi! Does anyone know how to build HsOpenSSL on MacOS? I've looked at some github issues about it, and adding the lib/include directories to my stack.yaml doesn't seem to help
09:30:11 <__monty__> I'm implementing my own language to learn more about haskell and how programming languages work. I'm wondering about the parsing of control sequences would this involve mapping the sequences to the actual control characters or are the sequences already interpreted as control characters? (I'm using Megaparsec.)
09:31:04 <Athas> __monty__: what control sequences?  The low-order ASCII characters?
09:34:12 <__monty__> Athas: All of the control sequences that haskell accepts, excluding \&.
09:34:51 <hpc> \& isn't really a character
09:34:54 <hpc> > '\&'
09:34:56 <lambdabot>  <hint>:1:3: error:
09:34:56 <lambdabot>      lexical error in string/character literal at character '&'
09:35:07 <hpc> > '\5\&\6'
09:35:09 <lambdabot>  <hint>:1:4: error:
09:35:09 <lambdabot>      lexical error in string/character literal at character '\\'
09:35:12 <hpc> > "\5\&\6"
09:35:15 <lambdabot>  "\ENQ\ACK"
09:35:15 <__monty__> hpc: I know but it is a haskell control sequence.
09:36:03 <Athas> Oh, you mean escape characters?
09:36:13 <Athas> I don't know what "control sequence" means in this context.
09:36:28 <__monty__> I think you'd just need to parse strings like \t, \n, \x05, \NUL and then convert them to the corresponding character like '\NUL' which'd probably involve a Map of some kind.
09:37:58 <__monty__> Basically "escape" as defined in the haskell 2010 report.
09:38:19 <Athas> If you are using Megaparsec, then you probably have a parser for the contents of string literals that looks something like: many character
09:38:26 <sproingie> Guest221: what error messages are you getting?  could you pastebin them somewhere?  also your stack.yaml
09:39:08 <Athas> Just define the 'character' parser as something like 'anythingButQuote <|> escapeCharacter', where escapeCharacter is something like: char '\' >> validEscape
09:39:45 <__monty__> It's the implementation of validEscape I'm wondering about.
09:41:58 <Athas> You could make a list of all valid escapes and use 'choice'.
09:42:48 <cocreature> __monty__: take a look at https://hackage.haskell.org/package/megaparsec-5.3.1/docs/Text-Megaparsec-Lexer.html#v:charLiteral
09:59:13 <rostero> I'm trying to create a new tool for fetching data, but with the goal of being able to still access the data while loading or failure (if available).  I want to provide the user with a default update function, but still allow them to define their own if necessary.  This is my first (incomplete) haskell program.  Any suggestions for improvement?  https://gist.github.com/rostero1/76c58d84728a452114fecaf1ab9558ee
10:21:04 <__monty__> cocreature: I'm still looking at charLiteral if I understand correctly this will interpret an entire control sequence as a single character?
10:26:45 <cocreature> __monty__: yep
10:29:50 <__monty__> Thanks for pointing it out. I'd come across it but not understood the documentation.
10:45:07 <__monty__> cocreature: Maybe you can clarify further, the documentation says charLiteral adheres to the haskell grammar but it parses both ' and " which are not allowed inside character and string literals respectively. Is this the only exception or is the documentation incorrect?
10:58:00 <__monty__> cocreature: Also, the suggested implementation for string literals in haskell seems to ignore gaps.
10:58:07 <cocreature> __monty__: tbh I don’t know
10:58:37 <cocreature> __monty__: I only stumbled upon this when I was browsing the docs a while back. I haven’t used it myself :)
10:58:56 <__monty__> Actually, nevermind the thing about gaps, seems like it handles them.
11:02:29 <cocreature> __monty__: reading the source it looks like if it doesn’t start with a backslash it will just return the original character
11:02:34 <cocreature> so that explains the behavior for ' and "
11:04:01 <__monty__> Yeah, my only problem with it is they say they conform to the grammar but that's not the case : )
11:05:28 <cocreature> make a PR to fix the docs ;)
11:06:14 <__monty__> Actually, wouldn't gaps also pose a problem? Since charLiteral skips over them if you use it to parse a character literal it would allow something like '\   \a' for the character a.
11:06:49 <geekosaur> __monty__, you might consider that it expects the caller to know which context it's called in rather than trying to figure it out itself, so it passes both because ' is fine in String and " in Char
11:07:38 <jaaaames> make a PR
11:07:39 <zoey> hi :3
11:08:14 <__monty__> Sure but it makes the name somewhat deceiving because if you try to parse a character literal with it you need to take care of ' (only if that's your delimiter for character literals though) and gaps.
11:09:13 <geekosaur> I can see it being used within a parser, it parses one lexical-char and the caller decides when it stops. this is fairly common for parsing, and what name would you give something which defers the delimiter handling to the caller?
11:09:30 <geekosaur> and how do you justify it against a couple decades of existing practice in parsers?
11:10:04 <geekosaur> it in fact does what it says. not charLiteralOrDelimiter, but charLiteral
11:11:56 <__monty__> geekosaur: Gaps have little to do with character literals afaik.
11:13:19 <__monty__> It's great for parsing the characters that occur in haskell strings because of this (excluding \& which needs to be handled seperately)
11:14:07 <__monty__> To be clear, I'm not saying it's bad, just that claiming it implements haskell's grammar is misleading.
11:14:55 <cocreature> if you find the docs misleading they are apparently misleading to a user so they should be fixed, i.e., you should make a PR to improve them :)
11:15:03 <geekosaur> I see it's documented as not handling \& which is correct.
11:15:09 <geekosaur> I don't see it handling gaps
11:15:18 <__monty__> geekosaur: Found that out by testing.
11:15:25 <geekosaur> which would also be correct, that processing needs to be done upstream
11:15:58 <__monty__> But it handles gaps. I don't know any languages but haskell that use gaps like this /    /
11:21:39 <geekosaur> I don't see it handling gaps. What exactly does your testing show it doing?
11:22:17 <geekosaur> (because I can see what it would do with a string gap, and it's not quite right but you might *think* it is right)
11:23:29 <trigone> hi, i keep having to check if my Ints are >= 0. is there an unsigned int type?
11:23:48 <hpc> Word
11:23:55 <__monty__> Hmm, I'm testing this in ghci so I'm probably mistaken. Ghci probably takes care of that gap and then the string is passed to the parser.
11:24:39 <trigone> > (5 - 50) :: Word
11:24:41 <lambdabot>  18446744073709551571
11:25:54 <__monty__> hpc: Is there an unsigned version of Integer?
11:26:05 <trigone> hpc: k thx... mind you i'm not entirely sure that to risk overflow is what i'd like either... something raising an error would be better, along with safe substracting giving out Maybes...
11:26:15 <hpc> Natural
11:26:22 <hpc> Natural is relatively new
11:26:29 <trigone> > (5 - 50) ::Natural
11:26:31 <lambdabot>  *Exception: Natural: (-)
11:26:34 <hpc> > (maxBound :: Int) + 5
11:26:37 <lambdabot>  -9223372036854775804
11:26:44 <hpc> trigone: it's always a risk
11:26:48 <Xnuk> @hoogle Natural
11:26:48 <lambdabot> module Numeric.Natural
11:26:48 <lambdabot> Numeric.Natural data Natural
11:26:48 <lambdabot> module GHC.Natural
11:27:23 <geekosaur> __monty__, specifically if you feed it a gap, it will in effect remove the \ \ from it and leave the whitespace (which is wrong)
11:27:33 <trigone> hpc: i wonder if it's faster to use Natural, or to use a wrapped version of Word that checks for overflow
11:27:51 <__monty__> geekosaur: What would it do with a string gap? My tests seem to indicate it errors with unexpected '\' since "\ " is not a valid escape sequence.
11:28:05 <trigone> thanks hpc 
11:28:22 <Xnuk> > 0 :: Natural
11:28:24 <lambdabot>  0
11:28:41 <Xnuk> > negate 1 :: Natural
11:28:43 <lambdabot>  *Exception: Natural: (-)
11:29:49 <geekosaur> __monty__, I guess I have to ask how exactly you are testing this
11:30:25 <geekosaur> string gaps are handled by Text.Read.Lex.lexString, or more precisely its local binding lexEmpty
11:30:30 <__monty__> geekosaur: I was using ghci> parseTest (charLiteral :: Parser Char) "\   \a"
11:30:45 <geekosaur> oh wait, you are doing thjsi in ghci, yes, it will eat the gap in the literal string
11:30:59 <geekosaur> you need to double the \ to get it to the parser
11:31:44 <__monty__> Yeah, so I tried "\\   \\a", and that reports unexpected '\'
11:32:12 <__monty__> Which doesn't correspond with dropping the backslashes.
11:32:16 <MichaelBurge> Anyone with lens experience know of an easier way to generate or write annotation here? https://hastebin.com/ixosifejak.hs
11:32:25 <geekosaur> right, that is what I actually just traced though, I was expecting it to translate unknowns by dropping the \ but it throws an error instead
11:32:51 <MichaelBurge> The Control.Lens.Plated looks close, but it's mostly for recursive types
11:33:51 <__monty__> geekosaur: Ok thanks, so gaps would need to be handled in addition to the \& in the example and ' needs to be handled for character literals? (assuming haskell's grammar)
11:35:30 <geekosaur> well, the caller needs to handle it. the haddock for charLiteral even says that, btw
11:35:41 <Gurkenglas> MichaelBurge, how about type StatementEx a = (a, StatementExWithoutA)?
11:35:54 <Gurkenglas> MichaelBurge, then annotation = _1
11:36:12 <geekosaur> although perhaps not as explicitly as you might prefer: "It's your responsibility to take care of character literal syntax in your language (by surrounding it with single quotes or similar)."
11:36:20 <geekosaur> i.e. it handles only the chars themselves not the delimiters
11:36:29 <geekosaur> which is what I expect of a combinator
11:36:36 <geekosaur> *parser combinator
11:39:24 <__monty__> geekosaur: My problem is in this "The literal character is parsed according to the grammar rules defined in the Haskell report."
11:39:40 <geekosaur> but it parses a _character_
11:39:51 <geekosaur> you want it to parse the whole language to parse a single character?
11:40:11 <geekosaur> you are, basically, thinking about it in the opposite direction from the way people who write parsers (like this) do
11:40:24 <geekosaur> and the people who do that, do so because _that's how parsers work_
11:40:33 <__monty__> No but a "char" according to the grammar in the report does not match a single apostrophe.
11:40:58 <geekosaur> so instead we need a separate stringCharLiteral
11:41:14 <__monty__> I understand why it is implemented the way it is but that statement is misleading.
11:41:44 <geekosaur> only if you take it by itself instead of as a combinator in a particular parser library
11:42:11 <geekosaur> so does every combinator have to cite the whole language so its statements in any particular place are 100% complete?
11:42:20 <geekosaur> and how does that interact with "reads only first sentence"?
11:42:43 <sflux> Hi all, I've been wondering something. Should I specify the version numbers of dependencies in my cabal file or can I leave it unspecified. Everytime I try to specify the number, it seems to break some other package. (newbie)
11:42:52 <__monty__> What? All it should say is it parses according to the grammar except for apostrophe.
11:43:06 <geekosaur> it parses according to the grammar exclusing delimites
11:43:12 <geekosaur> it 8says that*
11:43:19 <geekosaur> does it need to expand what that means for you?
11:43:40 <geekosaur> because \' is valid in the context of a String
11:43:43 <__monty__> I'm not talking about delimiters. ''' is not a valid character literal in haskell according to the grammar.
11:43:49 <geekosaur> sigh'
11:44:34 <geekosaur> ok, so we need to duplicate all the char literal parsing so you can have a Char-100-specifc charLiteral and a String-100%-specific sgtringCharLiteral
11:44:51 <geekosaur> combining them means it isn;t a charLiteral by your obviously correct rules
11:45:22 <__monty__> After reading the doc for charLiteral I'd implement char (as in haskell's grammar) like this: char = char '\'' *> charLiteral <* char '\''
11:45:46 <__monty__> That wouldn't be correct though because it would parse '''.
11:46:08 <geekosaur> I would not because it tells me that I need to handle delimiters myself which means it is on *me* to detect that the delimiter was used as the character
11:46:45 <n_blownapart> this is mono*chrom's example from a webpage. I don't know what it does because I expected multiplication to work as written in this paste : https://ptpb.pw/m2hS it returns zero
11:47:04 <geekosaur> ad you still require that I have a 99.9999% duplicate of this function to parse character elements in String-s
11:47:11 <__monty__> Ok, I see your point. That's not how I interpretted it though.
11:47:30 <geekosaur> this is how parsing works in the real world
11:47:36 <__monty__> I'm not advocating for any duplicate, just for clearer documentation.
11:47:49 <geekosaur> so clarify parser documentation for people who don't understand parsers
11:48:07 <n_blownapart> oh sorry please disregard for a moment ^
11:48:10 <geekosaur> it needs to be a tutorial instead of API docs
11:49:35 <__monty__> I hardly see how adding "except for apostrophe" to a single sentence makes it a tutorial. I feel like you're being too harsh.
11:51:02 <trigone> hi, i wonder why in the class Apply (akin to Applicative without Pure) there is the operator (<.>), which seems like an alias to (<*>). To me it doesn't look like the equivalent to (.) like <$> is akin to ($)...
11:51:24 <trigone> s/alias/ alias with a different constraint/
11:51:51 <MichaelBurge> Gurkenglas: Yeah, maybe that would be better. The only other things are the typeclass constraints on a, but it should be possible nowadays to include constraints in type
11:52:23 <trigone> :t (.)
11:52:25 <lambdabot> (b -> c) -> (a -> b) -> a -> c
11:52:32 <trigone> :t (<.>)
11:52:34 <lambdabot> Indexable (i, j) p => (Indexed i s t -> r) -> (Indexed j a b -> s -> t) -> p a b -> r
11:52:51 <trigone> :t Data.Functor.Apply.(<.>)
11:52:53 <lambdabot> error:
11:52:53 <lambdabot>     Not in scope: data constructor ‘Data.Functor.Apply’
11:52:53 <lambdabot>     No module named ‘Data.Functor’ is imported.
11:53:22 <trigone> sigh. well (<.>) :: f (a -> b) -> f a -> f b 
11:53:54 <ongy> n_blownapart: did you find the mistake?
11:54:17 <geekosaur> __monty__, the real problem here is you are persistently refusing to read this in its context, but instead forcing your own context on it
11:54:35 <ongy> :t (Data.Functor.Apply<.>)
11:54:37 <lambdabot> error:
11:54:37 <lambdabot>     Not in scope: data constructor ‘Data.Functor.Apply’
11:54:37 <lambdabot>     No module named ‘Data.Functor’ is imported.
11:54:46 <geekosaur> and then complaining that nobody presupposed that you would arrive with your context
11:55:13 <trigone> ongy: don't bother it clearly has limited access to hackage
11:55:32 <trigone> ongy: i gave the signature, copy pasted
11:55:35 <geekosaur> the only ways I see to handle this are: (1) __monty__'s context is so special that it and it alone must be accounted for; (2) we must allow in general for users insisting on their own contexts, and therefore provide the full; context in every API document
11:55:57 <trigone> ongy: it's a class method, aka there's an implicit (Apply f =>)
11:57:04 <MichaelBurge> Gurkenglas: Actually, you wouldn't be able to annotate child nodes with that, would you? https://hastebin.com/uyoqigagej.hs
11:57:06 <n_blownapart> ongy well I went back and changed the function name. let me paste it I still get zero
11:58:46 <__monty__> geekosaur: I disagree. "It's your responsibility to take care of character literal syntax in your language (by surrounding it with single quotes or similar)." suggests to me that I just need to write a parser that parses single quote then charliteral then single quote (or whatever delimiter you choose). I'm sure with experience the extra step of induction "hmm, I'll need to watch out for charliteral 
11:58:53 <__monty__> matching my delimiter" comes natural but appending that little three word sentence makes it clear to inexperienced people like me.
11:59:06 <n_blownapart> https://ptpb.pw/nvJ3 ongy yeah what does this do exactly? thanks
12:00:04 <ongy> n_blownapart: think a moment about your base case. If you have a piece of paper close to you, do it by hand for [1, 2, 3] :)
12:00:19 <Gurkenglas> MichaelBurge, https://hastebin.com/oloyaxamey.hs
12:01:45 <trigone> what's an example of a semigroupoid, including Functor/Apply/Bind (the equivalent apparently of Applicative/Monad without pure/return)
12:06:00 <glguy> Writer (NonEmpty a) is such an example type
12:06:05 <n_blownapart> ongy sorry could you explain that? I can do substitution in scheme till the cows come home, but here I'm expecting xs to not be empty
12:06:29 <geekosaur> __monty__, I could see that being clarified but not with your version
12:06:52 <geekosaur> because your version says "this must only be used for Char", and now we need a 99.9999% identical one for String
12:07:28 <geekosaur> but my attempts to get you thinking in that direction don;t work, so I guess that is what must be done, duplicate code because generalization confuses people too much
12:07:37 <trigone> glguy: hm... why can't you create arbitrary values of that type?
12:08:04 <glguy> trigone: try implementing it
12:08:29 <trigone> glguy: doing something else, maybe later...
12:09:39 <glguy> ok, come back later :)
12:09:58 <geekosaur> __monty__, more to the point, if everything has to explain why a given reusable function is reusable and how to reuse it in specific contexts, then we end up duplicating significant parts of the parser documentation for every combinator. and nobody will read it and therefore will _still_ be confused.
12:10:30 <geekosaur> correct answer is you read the parser from the top down and when you get to charLiteral you understand that it works for both String and Char and it's up to the caller to handle the special cases for each
12:10:50 <n_blownapart> ongy because I would expect evaluation to begin on the right side which would do 'car 5'
12:11:01 <geekosaur> not that you duplicate the documentation for String and Char in charLiteral, not that you almost-duplicate charLiteral as stringCharLiteral
12:11:03 <__monty__> geekosaur: So your issue is with my version is that it refers specifically to apostrophe? The only reason I refer specifically to apostrophe is that the doc says it implements the grammar.
12:11:15 <geekosaur> I am trying to get you to think generally
12:11:17 <geekosaur> I am clearly failing
12:11:37 <n_blownapart> so we wouldn't have a zero anywhere to multiply by. 
12:11:40 <geekosaur> you want to be specific, and you don;t want to have to read how the parser works to understand how the parser works
12:12:07 <ReinH> n_blownapart: What about with [1]?
12:12:17 <ongy> n_blownapart: car?
12:12:34 <ReinH> [1] is also spelled 1 : []
12:12:51 * monochrom grins
12:12:57 <n_blownapart> ongy yeah isn't that 5:[]  like car is scheme ? I thought it was called car here as well
12:13:07 <ReinH> what does hick [1] do?
12:13:31 <n_blownapart> one sec thanks ReinH ongy
12:13:36 <__monty__> I don't see how you got to that conclusion. I've been reading the docs for a while while implementing my first parser. It's just the documentation for charLiteral that's confused me so far and only because it explicitly refers to haskell's grammar, which it doesn't match (with good reason but that doesn't make it less confusing).
12:13:41 <monochrom> "car" is "head" here.
12:14:00 <n_blownapart> yeah isn't ':' like car ?
12:14:06 <geekosaur> cons
12:14:07 <ReinH> : is like cons
12:14:09 <n_blownapart> cons I mean sorry
12:14:14 <monochrom> head [5,6,7] = 5. That much is fine. Your problem is elsewhere.
12:14:39 <ReinH> what does hick [1] do?
12:14:39 <n_blownapart> the * is intentional, you realize that right?
12:14:40 <geekosaur> __monty__ because you are insisting that it has to deal with someone jumping into the middle of the parser without context and refusing to pay attention to the parser's context but applying some other context instead
12:14:53 <ReinH> Which pattern is matched? (x:xs) or []?
12:15:08 <ongy> we are aware, the * isn't a problem
12:15:28 <n_blownapart> hick [1] returns zero
12:15:42 <ReinH> Yes, I know that.
12:16:14 <__monty__> geekosaur: Please clarify this proper context. If you say it parses according to the grammar the context seems to be the grammar.
12:16:21 <geekosaur> yes
12:16:30 <ReinH> Which pattern is matched? (x:xs) or []?
12:16:35 <geekosaur> the grammar _defined there_
12:16:41 <geekosaur> not the informal grammar of the report.
12:16:50 <n_blownapart> hold on please thanks a lot
12:16:50 <geekosaur> this is not an informal grammar, it is a parser implementation
12:17:44 <geekosaur> you cannot necessarily understand individual parts of that parser grammar without the context of the parser
12:17:50 <MichaelBurge> Gurkenglas: Thanks for the tip. It seems like it's used pretty similar to the tuple you originally suggested: https://hastebin.com/juborovoma.hs
12:18:12 <__monty__> But it literally says it parses according to the grammar in the haskell report.
12:18:35 <ReinH> case [1] of { (x:xs) -> True; [] -> False; } -- n_blownapart is this true or false?
12:18:36 <geekosaur> yes, and this is the divisde
12:18:36 <__monty__> And I'm already dropping the delimiters from char in the grammar.
12:18:39 <geekosaur> you want that to be formal
12:19:09 <geekosaur> and I am giving up on trying to explain how that cannot be the case because it's not working
12:20:11 <__monty__> Please don't I'm genuinely putting in effort trying to understand. How is the grammar in the report not formal?
12:20:13 <monochrom> This is why I don't negotiate with people of strong convictions :)
12:21:09 <geekosaur> you are also continuing to insist that charLiteral means thisIsOnlyUsableInHaskellCharTypeLiteral
12:21:35 <glguy> monochrom: what would it take for you to start?
12:22:06 <glguy> I could make you a deal 
12:22:10 <geekosaur> by insisting that its not handling ' specifically has Haskell's Char does is a bug or documentation issue or etc. instead of _it handles individual characters for either Char or String_
12:22:15 <geekosaur> wjich is what a parser does
12:22:48 <dhtns> Is there a terser / cleaner way to write "if EXPR1 then Nothing else Just (EXPR2)"
12:23:19 <dhtns> I was thinking about "guard (not (EXPR1)) >> Just (EXPR2)"
12:23:32 <glguy> no, that's not cleaner
12:23:34 <dhtns> but that's not really clean
12:24:08 <ReinH> If EXPR1 can be a Maybe instead of a Bool, EXPR2 <$ EXPR1
12:24:23 <n_blownapart> ReinH that is True
12:24:28 <__monty__> geekosaur: You lost me, it's wrong of me to say that part of the doc could use clarification?
12:24:59 <ReinH> n_blownapart: then in hick [1], which case is matched? hick (x:xs) = x * hick xs or hick [] = 0?
12:25:49 <geekosaur> no, that is not what I said. but another thing I said is I am done with this discussion because I am clearly failing at explaining myself
12:26:30 <n_blownapart> the case returning 0, but how do we get a 1?
12:26:33 <n_blownapart> ReinH, 
12:26:34 <geekosaur> your latest being a good example
12:26:42 <ReinH> n_blownapart: How is it the case returning a 0??
12:27:20 <ReinH> you just said [1] matches (x:xs), not []
12:28:44 <cocreature> well now I know why this code didn’t use tuplesections. you can’t use them in TH …
12:28:58 <n_blownapart> hick [1] returns 0 when I run it
12:29:04 <ReinH> n_blownapart: That's not what I asked.
12:29:12 <ReinH> Which case matches?
12:30:59 <ReinH> if (x:xs) matches [1] then why are you having trouble answering?
12:31:03 <__monty__> geekosaur: "by insisting... bug or doc issue" How can I not interpret that as "the ' handling is not a bug or documentation issue, therefore you're wrong in insisting it is." I'll leave you alone if you don't answer this.
12:31:32 <geekosaur> ok, I;m not allowed to say :I am failing at this", I must continue to fail at it. Thank yu.
12:32:58 <__monty__> You are, that's why I said I'd leave you alone. I'd just rather you kept trying.
12:33:39 <ReinH> n_blownapart: there are two cases and I've told you it isn't one of them...
12:35:33 <n_blownapart> ReinH, sorry maybe we could take a different approach 
12:35:40 <ReinH> This is the only approach.
12:35:50 <ReinH> Pattern matching is what you need to understand.
12:36:06 <ReinH> Why won't you agree that it is matching the (x:xs) case?
12:37:37 <n_blownapart> please hold on I'm having trouble
12:38:11 <ReinH> Do you want to describe your issue, or do you want me to keep guessing?
12:38:55 <n_blownapart> please forget it I 'm not following
12:39:04 <rain1> ill show you
12:39:07 <rain1> [] = []
12:39:10 <rain1> [1] = 1:[]
12:39:15 <rain1> [1,2] = 1:(2:[])
12:39:21 <rain1> [1,2,3] = 1:(2:(3:[]))
12:39:42 <rain1> so [1] matches with x:xs giving x=1, xs=[]
12:42:06 <n_blownapart> rain1 oh so the inner most [] remains empty ?
12:42:34 <EvanR> [] is one of two kinds of list, its just a symbol for empty list
12:42:47 <EvanR> its not really containing or not-containing anything
12:43:08 <n_blownapart> right yet it evaluates to zero, given our base case
12:43:10 <EvanR> you could have wrote nil instead of [] if this was lisp 
12:43:21 <EvanR> to stand for emtpy
12:43:21 <ReinH> What is "it"?
12:43:29 <monochrom> [] is not one of those "state variables". It doesn't "change" from empty to non-empty and back again.
12:43:44 <ReinH> product (1:[]) = 1 * product []
12:43:47 <ReinH> product [] = 0
12:43:54 <ReinH> so product (1:[]) = 1 * 0 = 0
12:44:09 <ReinH> You wanted product [] = 1
12:44:52 <n_blownapart> so in (3:(5:[])) ....
12:45:19 <ReinH> product (3:5:[]) = 3 * product (5:[])
12:45:27 <ReinH> product (5:[]) = 5 * product []
12:45:34 <ReinH> product [] = 0
12:45:46 <zebrah> 42
12:45:52 <ongy> don't
12:45:52 <monochrom> I think it's better to use the original name "hick". Because Prelude's "product" does something else.
12:45:58 <ReinH> so product (3:5:[]) = 3 * 5 * 0
12:46:23 <ReinH> You are essentually replacing every (:) with * and every [] with 0
12:46:28 <ReinH> so it's foldr (*) 0
12:46:46 <ReinH> your base case is always 0, so you are always multiplying something by 0 (or you have a infinite list).
12:47:13 <n_blownapart> so ':' here is not cons, it is actually '*', the operation? 
12:47:17 <ReinH> : is cons
12:47:29 <ReinH> You define a function that turns it into *
12:47:35 <EvanR> > foldr (*) z (w:x:y:[])
12:47:37 <lambdabot>  w * (x * (y * z))
12:47:46 <EvanR> eeehehehehhoo
12:49:07 <ReinH> Every finite list has a []
12:49:18 <n_blownapart> yes, so it doesn't operate as cons; I was reading it as cons 5 [] -> [5] ; cons 3 [5] -> [3,5]
12:49:20 <ReinH> Which means hick will eventually reach the base case of 0
12:49:27 <ReinH> : is cons
12:49:40 <ReinH> 5 : [] is (cons 5 nil)
12:50:23 <monochrom> But hick is not building up a list. hick is consuming a list and crunching numbers.
12:50:40 <n_blownapart> interesting, thank you all
12:51:22 <ReinH> Write a product function in your favorite lisp and compare its base case with the base case of hick.
12:53:22 <n_blownapart> > foldr (*) z (w:x:y:[])    w * (x * (y * z))   <<thanks for this EvanR
12:53:24 <lambdabot>  error:
12:53:24 <lambdabot>      • Couldn't match expected type ‘Expr -> Expr’
12:53:24 <lambdabot>                    with actual type ‘Expr’
12:53:51 <n_blownapart> sorry so that's how lambdabot works
12:54:56 <n_blownapart> ReinH thanks kindly 
12:55:08 <ReinH> If you're familiar with racket, you have (foldr * 0 '(1 2 3 4))
12:55:18 <ReinH> Can you see why that would be 0?
12:55:50 <ReinH> While (foldr * 1 '(1 2 3 4)) would be the product
12:59:02 <ReinH> Your function would be something more like (defn (hick list) (if (null? list) 0 (* (car list) (hick (cdr list)))))
13:00:41 <monochrom> To some extent there is a learning gap from the null?-car-cdr combo to Haskell's pattern matching.
13:01:42 <ReinH> If you trace that evaluation out in lisp, you'll see that hick (cons 1 (cons 2 nil)) is (* 1 (* 2 0))
13:02:10 <ReinH> Just like in Haskell, hick (1:2:[]) is 1 * (2 * 0)
13:03:44 <ReinH> monochrom: otoh, I don't have to count parenthesis in Haskell
13:04:49 <n_blownapart> ReinH thanks I was looking at x:xs strictly as a list with its head
13:05:27 <n_blownapart> like car:cdr
13:06:12 <ReinH> Er.
13:15:12 <schmidt73> Whats the best way to build a package with cabal and sandbox? I tried 'cabal sandbox init', but what do I do after that?
13:15:47 <Welkin> cabal commands are sandbox-aware
13:15:50 <Welkin> just use cabal build
13:16:06 <Welkin> also, you should not use cabal sandboxes
13:16:09 <Welkin> they are outdated
13:16:12 <Welkin> use stack instead
13:16:25 <Welkin> schmidt73: https://docs.haskellstack.org/en/stable/README/#quick-start-guide
13:17:08 <monochrom> cabal sandboxes are not outdated.
13:17:19 <schmidt73> Okay, I'll try that
13:17:26 <monochrom> Instead, people are simply very opiniated about cabal and stack.
13:17:55 <c_wraith> cabal sandboxes will be mostly outdated when cabal new-build is the default
13:18:01 <monochrom> Like the way Windows fans and Mac fans claim that the other side is outdated. No more no less.
13:18:22 <Clint> one of these days i should find out what new-build does
13:18:56 <c_wraith> new-build allows multiple copies of the same version of the same package to exist with different dependencies
13:19:04 <c_wraith> and it shares all build products
13:19:52 <Clint> ah
13:20:49 <c_wraith> The one thing is doesn't do, as was recently pointed out to me, is handle unversioned C symbols.  You can't depend on multiple versions of network, for instance, as that will cause a link error
13:21:06 <Welkin> nix is supposed to fix that
13:21:19 <Welkin> and it works, when you can actually get nix to work at all
13:21:44 <c_wraith> does nix provide additional versioning of C symbols?
13:21:53 <Welkin> no idea
13:22:48 <Welkin> all I know is it sets up an entire system-level environment
13:23:07 <Clint> through the wonders of symlink farms?
13:23:12 <Welkin> lol
13:23:25 <jmcarthur> Does anybody recommend any particular regex library? For all my time having used Haskell, I've never really needed a regex library before now.
13:23:36 <Clint> they're all pretty annoying
13:23:37 <Welkin> jmcarthur: why regex over parsing?
13:23:49 <Clint> i think regex-pcre maybe
13:24:01 <c_wraith> jmcarthur: do you need pcre-ish, or just arbitrary regular pattern matching?
13:24:27 <jmcarthur> Welkin: I'm making a library to simplify testing with stdout and stderr, and I want it to be really convenient.
13:24:51 <c_wraith> so look for packages with pcre in the name. :)
13:24:52 <jmcarthur> c_wraith: It doesn't matter a whole lot, but pcre might be nice.
13:25:28 <c_wraith> jmcarthur: haskell being haskell, there are regular expression libraries that work over arbitrary data types, not just characters.  I was trying to figure out which you were going for.
13:25:40 <n_blownapart> thing is, hick (3:(5:[10]))  also returns zero. so I must be tripping https://ptpb.pw/uFIZ
13:25:41 <jmcarthur> Ah
13:25:45 <jmcarthur> Strings only
13:27:12 <trigone> hi, can i write a >>= (b . c) >>= d without paretheses?
13:27:16 <jmcarthur> Ew, regex-pcre's compile function uses IO.
13:27:36 <rain1> @pl a >>= (b . c) >>= d
13:27:36 <lambdabot> a >>= b . c >>= d
13:27:39 <rain1> yes
13:27:40 <c_wraith> trigone: ask ghci what the precedence of (.) and (>>=) is
13:27:47 <Welkin> jmcarthur: embed lua in your library and use that for regex parsing
13:27:52 <trigone> rain1: thx!
13:28:02 <c_wraith> trigone: :info will tell you the precedence of an operator
13:28:08 <trigone> :info (.)
13:28:16 <c_wraith> trigone: in ghci 
13:28:16 <trigone> :info (>>=)
13:28:22 <trigone> c_wraith: ok ^^
13:28:35 <trigone> c_wraith: thx!
13:28:55 <c_wraith> trigone: :info is handy.  Keep it in mind.  It helps with all sorts of things. :)
13:29:45 <Welkin> @info info
13:29:45 <lambdabot> info
13:29:46 <geekosaur> sadly :info is not available from lambdabot
13:29:50 <Welkin> lol
13:29:58 <Welkin> lambdabot turns @info into @undo
13:30:05 <geekosaur> and @info is edit "corrected" to @undo, just like phone auto"correct"
13:30:08 <trigone> @info parrot
13:30:08 <lambdabot> parrot
13:30:50 <geekosaur> @info do {x <- y; f x}
13:30:50 <lambdabot> y >>= \ x -> f x
13:31:00 <trigone> geekosaur: ooh i see
13:31:29 <trigone> geekosaur: does it work for arrows too?
13:31:39 <c_wraith> I'm pretty sure :info isn't in lambdabot because the output is often 30 lines
13:32:22 <geekosaur> or more. consider Eq
13:32:31 <geekosaur> especially with 14 tuple instances
13:34:13 <n_blownapart> https://ptpb.pw/uFIZ   monochrom does the [10] also 'get consumed' here ? this fact set me back a bit 
13:34:48 <n_blownapart> because it doesn't initiate with []
13:34:48 <rain1> (3:(5:[10])) = (3:(5:(10:[])))
13:35:33 <Welkin> rain1: what is this? lisp?
13:36:11 <osfameron> that'd be (: 3 (: 5 (: 10 []))) ;-P
13:36:35 <n_blownapart> rain1, oh, I see [] is always included with x:xs . is that how I could say it? 
13:36:47 <rain1> no I wouldn't say that
13:36:57 <rain1> every list ends in []
13:37:08 <Welkin> [] is syntactic sugar for Nil
13:37:15 <rain1> is it?
13:37:17 <rain1> > Nil
13:37:17 <Welkin> data List a = Nil | Cons a (List a)
13:37:19 <lambdabot>  error: Data constructor not in scope: Nil
13:37:29 <Welkin> that is roughly how a list works
13:37:35 <n_blownapart> right that I remember from the little schemer
13:37:36 <Welkin> there is special support for [] though
13:37:54 <Welkin> and (:) as Cons
13:38:03 <rain1> but Nil and Cons aren't defined in haskell
13:38:09 <Welkin> right
13:38:11 <rain1> I think this is confusing
13:38:13 <EvanR> you could define them
13:38:16 <Welkin> it is just [] and (:)
13:38:36 <EvanR> [] and : are syntax sugar, not fundamentally different things from the rest of the language
13:38:50 <n_blownapart> this is interesting, as I've grown accustomed to saying , please have patience with me this is very cool stuff
13:38:56 <mniip> wellllll just one thing
13:39:07 <EvanR> probably more than one thing
13:39:08 <Welkin> mniip: alright steve jobs
13:39:12 <mniip> while : looks like a constructor name it's not actually exported from anywhere and it's builtin
13:39:24 <EvanR> Welkin: columbo?
13:39:31 <Welkin> EvanR: no...
13:39:56 <Welkin> his famous "One more thing" special reveal at the end of every presentation
13:40:09 <geekosaur> yes, because while in theory one could have data [] a = [] | a : [] a, this quickly runs into trouble with the list convenience syntax [a,b,c]
13:40:19 <EvanR> im pretty sure he stole that from columbo
13:40:33 <Welkin> you think he watched columbo?
13:40:37 <EvanR> yes
13:41:09 <EvanR> yes [a,b,c] is yet more sugar
13:41:23 <EvanR> for a:b:c:[]
13:41:38 <Welkin> you could define and use your own list if you want to as well
13:41:40 <n_blownapart> so if you have (3:(5:[10])) how does that hick function 'extract' the 10 out of the list to return an empty list? Am I a retard?
13:41:56 <geekosaur> [10] is shorthand for 10 : []
13:42:50 <mniip> (no you're just learning haskell, it's a similar situation because the gradient of knowledge is very high)
13:43:11 <Welkin> n_blownapart: or borat's brother, billo
13:43:28 <n_blownapart> borat is funny does that dude still make movies?
13:43:40 <trigone_> is there a keyword to hide functions but otherwise export everything else?
13:43:46 <Welkin> trigone_: hiding
13:43:55 <Welkin> import Prelude hiding (.)
13:43:59 <geekosaur> so whether you write [3,5,10] or (3:(5:(10:[]))) or (3:(5:[10])), the compiler sees (3:(5:(10:[])))
13:44:01 <mniip> Welkin, "export"
13:44:02 <Welkin> oh, export?
13:44:09 <trigone_> Welkin: yeah export :)
13:44:12 <mniip> I think you're fairly doomed
13:44:22 <geekosaur> trigone_, not for export that I am aware of
13:44:25 <Welkin> make another module that wraps it
13:44:27 <mniip> for at least the docs purposes you have to list every identifier
13:44:28 <Tuplanolla> You can import by hiding and export the module, trigone.
13:44:33 <Welkin> and import with `hiding`
13:44:40 <Welkin> and export that
13:44:41 <mniip> oh indeed
13:44:46 <trigone_> Welkin: hm that's not a bad idea for that matter... but it should actually be doable
13:44:49 <n_blownapart> thanks interesting geekosaur !
13:44:57 <geekosaur> "hiding" support in export lists is one of the things that gets asked for periodically but I don;t think anyone has ever put together an actual proposal
13:45:16 <mniip> geekosaur, not sure how that'd play with haddock and friends
13:46:16 * hackagebot stratosphere 0.6.0 – EDSL for AWS CloudFormation – https://hackage.haskell.org/package/stratosphere
13:47:08 <trigone_> it's weird how much the core of coding in haskell is powerful and well thought, but the least abstract stuff is not typically better thought through than in other languages. it's sad :(
13:47:50 <rain1> i think its this way on purpose trigone_
13:47:52 <trigone_> i guess the best one can do is compulsive wrapping... i gather you can't have two modules in one file (esp not if one module is wrapping the other)?
13:48:03 <rain1> the idea is that you can see everything you're going to import just by looking at the module line 
13:49:18 <JSharp> trigone_, no one language is perfect for all use cases. I'd consider it an opportunity to contribute to haskell prime and other efforts to improve the standard. Haskell isn't some dictate from on high -- it's a living, evolving standard to which we all have the opportunity to contribute. it's a good thing (tm).
13:49:26 <Welkin> there are things that may be convenient in other languages, but that doesn't mean it is a best practice
13:50:02 <Welkin> implicit imports and global variables for one (in things like rails), along with metaprogrammed-everything is a complete disaster
13:50:16 <trigone_> rain1: the "module line" is actually usually higher than Taipei 101. in a way it's not terribly different than to scan the whole file (or a haddock doc). sure, most of the noise is put aside, but if you want to only hide 10% of the file, i feel it's pretty weird to put lots of noise at the file start that merely recapitulates what follows.
13:50:37 <rain1> haha nice metaphor!
13:53:29 <monochrom> Wait, export everything except functions? That may actually be pretty easy.
13:53:54 <monochrom> It depends on what the other things are, but there is one special case:
13:54:18 <trigone_> monochrom: i didn't mean *all* functions. regardless i'm wondering if that is possible?
13:54:19 <monochrom> "module M() where"  This means export instances only.
13:54:50 <trigone_> monochrom: hm, cool... i think
13:54:57 <monochrom> If you also have one class and two types, "module M(TheClass(..), Type1(..), Type2(..))"
13:55:10 <trigone_> overall it's still weird you can import and hiding, but not export and hiding...
13:55:16 <monochrom> If you have a type family too, I forgot the syntax.
13:55:22 <trigone_> you're really sure there's no keyword for module hiding?
13:55:31 <monochrom> True, it's a bit asymmetric.
13:55:33 <geekosaur> very sure, yes
13:55:44 <trigone_> geekosaur: sigh. thanks anyway :)
13:56:00 <monochrom> However, I content that in practice you want extremely explicit export list. Reason: works so much better with haddock.
13:56:53 <monochrom> In other words, haddock gives you a lot of perks and bonuses if you write out your export list.
13:57:03 <trigone_> monochrom: hm... but, haddocks already extracts signatures, does it not? so it reads the file anyway, and it could use a hiding list as filter instead of the default include list... i don't see the difference
13:57:45 <monochrom> Well let me tell you the smallest bonus to tempt you. If you write an export list, then doc order can be different from implementation order.
13:58:15 <__monty__> trigone_: I think it's more because a mistake would be more expensive. If you forget to hide a new function and release the module you now have something in the public api and you'll have to introduce a breaking change to take it back out.
13:58:17 <trigone_> monochrom: that is true...
14:00:14 <trigone_> __monty__: yeah, that is true... technically though, when your import list becomes something like a third as big as the rest of your file, i'm not totally convinced you can't export something by mistake, by merely forgetting to remove it. you gotta have the habit of always updating the summary with the rest of the file, instead of having the keyword "export" (as per example) right where the code is.
14:01:26 <trigone_> (or the keyword hiding for that matter. i don't think it's that hard to get used to using it, especially if it's right before the function name or something very visible.)
14:03:06 <trigone_> yeah, actually: a keyword for exporting would already be nicer. then, everytime you create a function, you'd decide whether importing it or not. personally i have yet to take that habit since i have to jump at the start of a file, repeat the function name (after choosing the order), and that breaks my workflow rather painfully.
14:03:13 <monochrom> It is possible to support "module M hiding(f, g, C) where". By both GHC and haddock. But probably there hasn't been sufficient demand.
14:03:38 <trigone_> a/whether (importing) it or not/exporting/
14:03:59 <geekosaur> actually I'd suspect an issue to be that someone might think that hides instances too
14:04:37 <trigone_> geekosaur: is it the kind of behavior when importing with hiding?
14:04:54 <geekosaur> there have been people who thought they could hide instances that way, yes
14:05:00 <jmcarthur> Not ready for release yet, but here's the current test suite for this stdout/stderr based testing library I'm working on. http://lpaste.net/357159
14:05:02 <geekosaur> (instances are always exported and always imported)
14:05:14 <geekosaur> (and currently the type system's soundness relies on this)
14:05:28 <jmcarthur> (For those wondering why I wanted regexes, and also just because I'm pretty happy with how it's going.)
14:05:46 <trigone_> geekosaur: then why did you say you had to write module Thingy(), why do you need the empty parentheses? are they not optional then?
14:05:49 <jmcarthur> lpaste syntax highlighting apparently hates it though
14:06:11 <geekosaur> er, I didn't say that, monochrom did. and that was to export *only* instances
14:06:42 <trigone_> geekosaur: oh sorry. and, i got it
14:06:52 <geekosaur> (it relies in the fact that instances are always exported, and explicitly exports nothing else --- the default being to export *everything* if there is no export list)
14:07:34 <jmcarthur> The little (re) suffixes denote lines that should be treated as regexes instead of exact matches.
14:07:36 <monochrom> Oh I did this cute thing a while ago. "module M() where { f x = x && x {- or whatever -}; foreign export cf ... }"
14:07:57 <monochrom> So actually the empty export list exports instances and foreign exports. :)
14:08:20 <__monty__> trigone_: The convenience of the export keyword you describe could be implemented by your editor (adding whatever name your cursor is on to the export list).
14:09:14 <geekosaur> I expect some editor Haskell modes already have that, because there's a sizeable subcommunity that believes all exports and imports should be explicit
14:10:39 <trigone_> __monty__: true. still, it's no trivial trick. and, i think that you could have syntax highlight tricks to show functions with a keyword more easily. then, even if the import would subjectively be "implicit", it'd still be pretty obvious what is exported or not, just like commented code vs non commented code.
14:10:47 <glguy> monochrom: I have some of those, when it comes to making an executable it annoys me that I have to then import that module from the Main module
14:10:56 <glguy> even though the module is listed in the .cabal
14:11:08 <monochrom> Oh that's strange.
14:11:30 <glguy> Specifically if the module is defined in an executable, not an imported library
14:12:46 <trigone_> in java, i think the way to "hide functions from a module" is to have special keywords for the relevant methods. i wonder how well that works out then?
14:14:09 <geekosaur> there are languages that do the opposite as well: the only things that get exported are things with a specific export trait associated with them
14:14:24 <geekosaur> but yes, theres the C/C++/Java "static" mechanism
14:14:44 <trigone_> geekosaur: i thought static meant "
14:14:50 <trigone_> "common to all instances"?
14:14:59 <geekosaur> inside classes, yes
14:15:18 <geekosaur> for definitions at top level (not inside a function or a class), it means "only visible in this file"
14:15:25 <trigone_> oh, ok
14:15:39 <c_wraith> I'm not sure any C keyword means only one thing
14:15:48 <geekosaur> (and inside functions it means still a third thing, "shared across all invocations of this function")
14:15:50 <trigone_> i'm not sure java has top level definitions, everything is supposed to be class-ed
14:16:23 <geekosaur> yes but Java takes its syntax and gross semantics from C
14:16:42 <geekosaur> with changes, btu that's why it's Java and not C:: or whatever
14:17:20 <trigone_> geekosaur: ^^
14:18:01 <imPure> Is it possible to define a class similar to Default, except that it returns a `Just a`, and when Default isn't defined it returns Nothing?
14:19:24 <geekosaur> imPure, not really, if I understand what you are asking; it runs into the same overlapping instances issue as 'instance Foo x => Bar x where ...; instance Bar x where ...;'
14:19:39 <pikajude> well
14:19:45 <pikajude> you could always just make the default definition def = Nothing
14:19:50 <pikajude> and then override it in the instances
14:20:20 <pikajude> class DefaultMaybe a where mdef :: Maybe a
14:20:34 <monochrom> Defaulting on defaults? :)
14:20:35 <imPure> And then the compiler know that the class is defined for every type?
14:20:40 <geekosaur> c_wraith, afaik 'auto' always means one thing. it just means a different one thing in C++11 and later :p
14:20:40 <pikajude> well
14:20:47 <pikajude> if a class method has a default definition
14:20:59 <pikajude> actually, i suppose the problem is that you'd still have to define the instance
14:21:02 <pikajude> you just don't have to give the method a body
14:21:03 <geekosaur> (and a useless one thing in earlier C++ and in C)
14:21:06 <trigone_> pikajude: you still need to explicitly make everything an instance
14:21:07 <imPure> pikajude: Yea
14:21:13 <pikajude> trigone_: maybe YOU need to make everything an instance
14:21:19 <imPure> How? :)
14:21:26 <trigone_> pikajude: what?
14:21:31 <pikajude> sorry
14:21:40 <ReinH> your face needs to make everything an instance
14:21:48 <trigone_> what?
14:21:55 <pikajude> there we go. just ask trigone to define the instances
14:22:02 <trigone_> lol what?
14:22:18 <pikajude> you could always write some TH to define the instance for every Default instance in scope
14:22:39 <trigone_> yeah, i'll define the instance, just give me the list, i'll do fmap makeInstance allTypes
14:22:45 <imPure> pikajude: Actually, I tried TH and failed at what i was really up to, this was my work around.
14:22:56 <imPure> What I'm actually trying to do...
14:23:11 <pikajude> oh ok
14:23:19 <pikajude> if TH isn't solving the problem, just use more of it
14:23:20 <imPure> Every bind on a monad that matches a constraint, I'm trying to rewrite the bind.
14:23:51 <imPure> So, it's pretty dark magic here. It's for making a DSL more readable.
14:23:53 <trigone_> imPure: it looks like you'd like a negative constraint, something like (Default a, not Default b) => Either a b -> Maybe a
14:24:19 <ReinH> Is this one of those instance MyClass a => Show a tragedies?
14:24:19 <jmcarthur> imPure: Have you considered defining your own bind operator and use RebindableSyntax to allow using do notation with it?
14:24:22 <pikajude> well that's effectively the same as defining the defaulting Default instance
14:24:25 <imPure> trigone_: Yes, but classes don't match or not based on a constraint, so I can't overlap them based on that, right?
14:24:37 <pikajude> instance not (Default a) => MyDefault a
14:24:40 <pikajude> and so on
14:25:01 <imPure> jmcarthur: Haven't looked at RebindableSyntax... Googling...
14:25:04 <pikajude> that said, a "not constraint" constraint would be a really funny thing to add to the language
14:25:32 <geekosaur> I think it can't exist
14:25:35 <trigone_> pikajude: i think there are problems at the level of sets...
14:25:44 <pikajude> wait, what?
14:25:52 <pikajude> the compiler clearly knows when a constraint is fulfilled
14:26:00 <imPure> jmcarthur: Not sure that's what I want.
14:26:00 <ReinH> There are no sets here.
14:26:19 <pikajude> i feel like if you can know X, you can also know (not X)
14:26:21 <geekosaur> pikajude, it "knows" because anything using it presents a witness in the form of a dictionary
14:26:24 <pikajude> ok
14:26:37 <trigone_> ReinH: no i mean, seeing classes as sets of types, but i think no set is actually built, only the conditional definition matters
14:26:44 <jmcarthur> imPure: It's just my gut reaction whenever somebody wants to do something with do notation that the type of (>>=) doesn't permit.
14:26:45 <geekosaur> so does eveyrthing have to default-present a dictionary witnessing not-instance?
14:26:56 <pikajude> i don't know the answer, but i'm guessing no
14:26:57 <imPure> jmcarthur: Issue is, I can already overload the bind syntax with a rewrite rule...
14:27:11 <trigone_> geekosaur: i think before there's translation with a dictionary, the type checker checked if the instance existed
14:27:17 <imPure> jmcarthur: But, what I can't do is optionally rewrite based on the constraint matching or not.
14:27:42 <geekosaur> trigone_, no, it can't. which is why the 'instance Foo x => Bar x; instance Bar x' is an overlap
14:27:47 <jmcarthur> imPure: I was trying to find a way that maybe you don't need rewrite rules at all, but that's tricky without knowing what you're actually tryng to do.
14:27:52 <imPure> Now, it turns out TH does work in rewrite rules, surprisingly enough.
14:28:07 <imPure> I'm trying to log bound variable names.
14:28:17 <jmcarthur> Ah, I see.
14:28:28 <trigone_> geekosaur: at the level of the typechecker, i think this kind of constraint could work out. but the question is, why the hell would it be useful? constraints are there to be sure you can use relevant methods. what's the point of explicitly being sure you can't use a specific method? aside from impure's project
14:28:29 <imPure> My code is in a DRI county :)
14:28:40 <imPure> And I'm sick of typing variable names twice.
14:28:58 <jmcarthur> DRI = Don't Read It? :)
14:29:02 <rain1> lol
14:29:10 <imPure> DRI ≡ Don't Repeat Yourself :)
14:29:17 <jmcarthur> I = Y?
14:29:20 <pikajude> Iourself?
14:29:29 <imPure> Err, Sorry, DRY.
14:29:56 <pikajude> DRY = Hindley-Milner Type System
14:30:32 <trigone_> geekosaur: technically, an anti-constraint would not require a dictionary. the dictionary is there because the constraint implies there's gonna be ad-hoc polymorphic code. an anticonstraint would just explicitly forbid the use of a type that could use so and so method. it's pretty useless as i said, at least at first sight.
14:30:52 <imPure> Now, the thing is, I can only log the bind on Monads that support logging the binds, but that depends on a constraint.
14:30:56 <trigone_> pikajude: i fail to properly translate the definition and the acronym
14:31:03 <monochrom> An anti-constraint requires whole program analysis to check.
14:31:34 <imPure> monochrom: That sounds like it doesn't work...
14:31:56 <trigone_> monochrom: a constraint does not? i think that if constraint survive the typechecking and are transformed apparently into dictionary, an anticonstraint would add nothing.
14:32:29 <imPure> Why aren't there just closed type classes?
14:32:31 <trigone_> monochrom: esp that would not be a dynamic anticonstraint. but maybe i've missed sth
14:32:34 <imPure> Would make this whole thing trivial.
14:32:41 <trigone_> what's a closed typeclass?
14:32:45 <monochrom> As said, a constraint requires just dictionary passing, aka delegation.
14:32:52 <imPure> Like a closed type family, only classes.
14:33:02 <trigone_> imPure: what's a closed typefamily?
14:33:15 <imPure> Guarantee that all instances are defined in a small region. 
14:33:19 <trigone_> imPure: and if you tell me like a closed door, only a typefamily...
14:33:19 <jmcarthur> imPure: If you want to only replace binds for a certain monad, define a separate function to replace instead, then define bind to be equal to that and force it to inline.
14:33:22 <monochrom> The situation is very analogous to NP vs coNP.
14:33:31 <trigone_> imPure: nevermind i don't get it
14:33:49 <geekosaur> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#closed-type-families
14:34:01 <imPure> monochrom: I can see that, and it generalizes. Determining similarity is simple, determining differences is expensive.
14:34:20 <jmcarthur> imPure: You can sort of define closed type classes by defining them over data kinds. It at least prevents you from defining more instances than there are constructors in your data type.
14:34:21 <monochrom> A check of "this graph contains a hamilton circuit" is very different from a check of "this graph contains no hamilton circuit".
14:34:29 <geekosaur> typeclasses have the problem that they can lead to "fun" abuses. imagine for example being given a Map and being able to substitute your own Ord instance for its key type
14:34:59 <trigone_> monochrom: i dunno. the only difference i could see bwn id :: (not Show a) => ... and id :: ... would be that id 3 would typecheck only on the latter case. once the typechecking done, i don't see how the constraint could change anything.
14:35:23 <sproingie> any system that's open will yield more opportunities for abuse
14:35:39 <imPure> All I want is a default class, which is why a closed type class seems like the right thing for my needs.
14:35:56 <monochrom> No, id :: (not Show a) => ...  is not the problem. The problem is instance (not Show a) => Read a
14:36:08 <sproingie> come to think, that's true for more than technology
14:36:08 <trigone_> monochrom: ah, that's different...
14:36:36 <trigone_> monochrom: at least i suppose. i don't know much about how that works behind the code
14:36:43 <baconated> I'm trying to add a dependency to my project, specifically 'uuid'. If I add it to the build-depends section of my .cabal file and run stack build, it simply deletes the uuid line. What am I doing wrong?
14:36:46 <EvanR> geekosaur: which everyone but haskell seems to allow
14:36:48 <imPure> Or, anytime Haskell says it can't find a match, use the default...
14:36:57 <monochrom> And how about this conundrum which is actually the intended use case?  instance (not Show a) => Show a  -- I am merely supplying a default. What can possibly go wrong!
14:37:13 <EvanR> default class??
14:37:34 <EvanR> foo :: SomeClassAnyClass a => a -> a
14:37:38 <Tuplanolla> This sounds like Ruby's `method_missing`, which was not a complete disaster at all.
14:38:09 <sproingie> method_missing is a piss-poor way to extend, but extensibility itself isn't evil
14:38:23 <glguy> baconated: Do you have a package.yaml?
14:38:58 <baconated> glguy: yes. I suppose I should be adding it there
14:39:06 <glguy> baconated: Having one of those is what you're doing wrong then
14:39:13 <trigone_> monochrom: dunno, i'm mostly lost around all this, sorry. but i do see that adding anticonstraints on instances is probably breaking things up
14:39:16 <imPure> It's more that I want to define the class for a free index, and then have overrides. The thing is, I can do that without constraints...
14:39:21 <imPure> And that solves my constraint problem.
14:39:33 <trigone_> monochrom: still, i'm pretty sure that instance (A a) => A a where... is also a problem
14:39:54 <monochrom> Right, that one is banned actually.
14:39:57 <trigone_> monochrom: as in, is probably not allowed.
14:40:25 <trigone_> monochrom: i think it shudbe allowed, but the file in question should be erased at compile time :P
14:40:43 <imPure> trigone_: Haskell did that for a while.
14:40:50 <monochrom> Well, it may be an honest typo.
14:40:54 <trigone_> imPure: i know :)
14:41:30 <trigone_> monochrom: sure i'm kiddin
14:41:38 <monochrom> But meh. Don't attribute to malice or incompetent what can be attributed to simultaneous malice and incompetence!
14:42:39 * hackagebot postgresql-simple-queue 0.4.0.0 – A PostgreSQL backed queue – https://hackage.haskell.org/package/postgresql-simple-queue
14:43:07 <trigone_> monochrom: ^^
14:43:54 <imPure> Ok, so can I do what I'm trying in TH?
14:43:57 <trigone_> monochrom: the accused one is stuck between having to say "i did it on purpose, i'm not an idiot" or "i'm an innocent idiot"
14:44:01 <imPure> I'm a total novice in TH...
14:45:30 <trigone_> why the name template haskell? what's the name and what's the name-adjective?
14:45:43 <monochrom> "template" is the adjective
14:45:51 <trigone_> and why "haskell" in it? it's not like you can use it outside of haskell
14:46:17 <Tuplanolla> It's like "oil drilling".
14:46:26 <monochrom> Well, I can't use "advanced haskell" outside haskell either.
14:46:44 <jmcarthur> "literate haskell" also follows this pattern.
14:46:57 <trigone_> Tuplanolla: you can drill (for) other things...
14:47:10 <Tuplanolla> Yes, but the grammatical structure is the same.
14:47:32 <trigone_> Tuplanolla: well sure... oh you meant my previous question
14:47:43 <Tuplanolla> You could call it "template metaprogramming".
14:48:07 <Welkin> in c++ they call it "c++ templates"
14:48:37 <imPure> The solution I really want is to use plugins, but manipulating core is too hard.
14:49:29 <trigone_> Welkin: actually the name implies c++ is an adjective, so you can omit it if you say "in this class of c++, we'll learn templates, ...".
14:50:26 <trigone_> but here if i just say "i wanna learn templates", maybe i'll be understood but in a way i won't explicitly say what i'm talking about, context notwithstanding
14:50:41 <trigone_> at least it looks like it but i may be wrong
14:51:32 <geekosaur> see, if you said that, first thing I'd point you to is Shakespeare
14:51:59 <trigone_> geekosaur: the programming language?
14:52:09 <geekosaur> @hackage shakespeare
14:52:09 <lambdabot> http://hackage.haskell.org/package/shakespeare
14:52:19 <geekosaur> _web_ templates
14:52:33 <Welkin> these days I prefer html combinators to templates
14:53:19 <trigone_> are all those things different/equivalent/alternatives to "TH"?
14:53:30 <geekosaur> ...granted that is partially because web programmers tend to forget there is programming not related to the web, so people pop in asking for "<x>" and meaning "web <x>"
14:53:55 <trigone_> geekosaur: even if i say "i wanna learn how to code with templates"?
14:54:11 <geekosaur> that could well mean something else, yes
14:54:17 <geekosaur> "templates" is a fairly broad concept
14:54:25 <Tuplanolla> Code snippets from Stack Overflow?
14:55:10 <trigone_> geekosaur: yeah
14:55:23 <geekosaur> and no, web templates do not necessarily relate to TH (although shakespeare does, because it's about web templates implemented at compile time so it's TH/quasiquoters all over the place)
14:55:33 <monochrom> Yeah I was very infuriated (OK that's an exaggeration) when one day a haskell-cafe post announced "I have uploaded an API package to hackage". And they only meant web API.
14:55:52 <geekosaur> funny enough I was thinking of that incident when I wrote the above
14:56:12 <monochrom> And shakespeare is ironic because it uses template haskell for web templates.
14:56:12 <trigone_> lol a web API is not an API? for that matter what's an API? and what's not?
14:56:41 <geekosaur> more that a web API is not the only kind of API
14:56:50 <geekosaur> so calling itself "API" is a bit of a misnomer
14:56:50 <monochrom> No, trigone_, the converse is the problem. Is an API a web API?
14:57:15 <geekosaur> is swig's API no longer an API? curl's? openssl's?
14:57:23 <trigone_> geekosaur: well sure, but if it had not been web, it'd still have been mostly undefined, right?
14:57:26 <monochrom> For that matter if you wrote up a mortgage calculator, would you obnoxiously call it just "calculator"?
14:57:43 <monochrom> I mean think about how obnoxious or ignorant or self-centred it is.
14:58:43 * hackagebot base-noprelude 4.10.0.0 – "base" package sans "Prelude" module – https://hackage.haskell.org/package/base-noprelude
14:58:52 <trigone_> monochrom: such jerks indeed... so if i resume, it's only a problem to omit the type of API when it's a web API?
14:59:09 <monochrom> But I guess "real world" people are actually used to that, meh? It is "Word", not "MS Word". It is "SQL Server", not "MS SQL server".
14:59:55 <monochrom> No, anyone who just say "API" out of context is bad. But in practice, only web developers have done that so far.
14:59:56 <trigone_> monochrom: you forgot the version
15:00:07 <trigone_> monochrom: ok got it ^^
15:00:16 <trigone_> monochrom: yeah i understand
15:01:56 <trigone_> monochrom: it's actually weird that they just posted "i uploaded an API" without describing anything further...
15:02:21 <monochrom> I think even Java people, even when in ##java so there is context, take the extra effort to say "the Java API" rather than "the API".
15:02:52 <trigone_> monochrom: even java people! ^^ even java web developers?
15:03:30 <monochrom> Yeah I'm pretty sure exposure to Java actually opens their eyes to diversity.
15:03:41 <trigone_> monochrom: i don't get it, should i say "i uploaded a web/whatever haskell api" even if it's on haskell-cafe?
15:04:20 <geekosaur> it's not a 'haskell api' unless it is an API to Haskell itself arguably
15:04:38 <hpc> with a sufficiently advanced mailing list, all you have to say is "upload" and the rest is inferred automatically
15:04:38 <monochrom> "a package/library for web APIs" is fine.
15:04:48 <geekosaur> which is another problem with the 'web api' business
15:05:28 <monochrom> All you have to do is to insert the word "web".
15:05:40 <trigone_> k, at any rate i don't web-develop yet :) gotta go, see ya :)
15:05:42 <monochrom> But I have this sinister theory of why they refuse to.
15:05:51 <trigone_> sinister?
15:06:05 <monochrom> If you say "I'm a web developer" other programmers look down upon you and you know this.
15:06:20 <trigone_> monochrom: really? why? is it that easier?
15:06:35 <monochrom> For the sake of dignity you therefore you have incentive to omit the "web" word to feel better about yourself.
15:07:07 <trigone_> well is reputation survival really a sinister motive?
15:07:26 <monochrom> No. "sinister" refers to my theory, not to them.
15:07:31 <Eduard_Munteanu> It's not easy, although it's badly done in many cases.
15:07:32 <trigone_> monochrom: ha ^^
15:08:41 <Eduard_Munteanu> And "web technology" kinda sucks.
15:09:03 <monochrom> Oh, the other programmers have various arrogant reasons to look down upon web programmers.
15:09:22 <monochrom> C people may say "you don't know registers and you can't do your own malloc and free"
15:09:31 <monochrom> Haskell people may say "you don't know types"
15:09:41 <monochrom> SML people may say "you don't know modules"
15:11:53 <mniip> philosophers may say "you don't know"
15:12:25 <monochrom> Of course, what Eduard_Munteanu said is also true. It doesn't help that a lot of their code are incompetently inefficient. Just look at most ads on the web. 100% CPU for a minute just to show you a picture.
15:14:30 <Welkin> I don't see ads
15:14:31 <Welkin> I block them all
15:15:18 <Eduard_Munteanu> It's not just ordinary developers... the whole thing is awfully-engineered if you look at standards and languages which are supposed to be designed by people who know better.
15:16:02 <Welkin> all gui APIs suck
15:16:07 <Welkin> the web sucks the least from my experience
15:16:27 <Welkin> the DOM has some very interesting features
15:17:10 <Welkin> it's actually a decent application platform
15:17:16 <Welkin> people are confused because it has two use cases
15:17:24 <Welkin> one is "websites" that are really just documents
15:17:29 <Welkin> the other use case is for applications
15:17:31 <Welkin> which are not websites
15:17:47 <Eduard_Munteanu> The DOM is semantically-useless except for really dumb stuff.
15:18:26 <Welkin> websockets, http2, web audio, file api, etc
15:18:31 <Eduard_Munteanu> And practically, there's no abstraction.
15:19:25 <Eduard_Munteanu> The only thing I really appreciate about the web is they managed to build a relatively safe sandbox for arbitrary code.
15:22:15 <EvanR> but you can whip out a GUI in zero seconds
15:23:58 <maerwald> Eduard_Munteanu: where is that sandbox?
15:24:24 <monochrom> The web browser's javascript interpreter.
15:24:33 <EvanR> hehe... yeah that sandbox can be used to steal computer time, operate botnets
15:24:39 <maerwald> ok: where is that safe sandbox
15:24:59 <monochrom> Oh it's just relatively safe.
15:25:03 <maerwald> haha
15:25:15 <monochrom> Better than sending you a Windows exe.
15:25:29 <Tuplanolla> Well, I couldn't run that one...
15:25:33 <monochrom> which people actually do just 20 years ago by email.
15:25:56 <Tuplanolla> The safest code is code not run.
15:26:29 <monochrom> During Christmas time, my old classmates used to email me Windows exe that, if they were not mistaken, merely did the job of a Christmas card.
15:28:33 <monochrom> People have not changed. Only technology has. Sometimes for the better, sometimes for the worse.
15:28:50 * geekosaur remebers websites that would make such exe-s for you on the fly
15:29:13 <EvanR> we need a technology which... when you send an email to an address, turns that computer on via network, delivers it to the computer, and automatically runs the exe contained in it
15:29:23 <monochrom> 30 years ago, people craved for paper Christmas cards that contained chips to play music.
15:29:29 <EvanR> would be so convenient
15:29:40 <Eduard_Munteanu> It's quite unfortunate that desktop applications have not yet been sandboxed properly.
15:29:42 <monochrom> 20 years ago, people craved for Windows exe Christmas cards that contained code to play music.
15:30:00 <monochrom> 10 years ago, people craved for web Christmas cards that contained Flash to play music.
15:30:12 <monochrom> 0.5 years ago, people craved for web Christmas cards that contained javascript to play music.
15:30:22 <Wizek> Anyone knows why this doesn't compile without -XUndecidableInstances? And/or how could I rephrase "An Int that may be wrapped in type constructor parameter `c`" in a different way? https://www.irccloud.com/pastebin/6XVvAaEl/
15:30:49 <t7> monochrom: today people crave exploiting your buggy gpu driver through webgl
15:30:59 <monochrom> But to a large extent, you feel much better with paper-with-chip and javascript than Windows exe and Flash.
15:31:57 <mniip> in 10 years people will craft for paper Christmas cards that contained chips to connect to internet and play music
15:32:01 <mniip> crave*
15:32:09 <monochrom> Ah yes!
15:33:28 * geekosaur bets on that being in 5 months instead
15:36:13 <Eduard_Munteanu> Wizek, it's undecidable because the constraint isn't clearly smaller than the instance head
15:37:29 <Wizek> Eduard_Munteanu: Do you perhaps have an example for me where this could lead to trouble?
15:38:09 <cheater> hi
15:38:18 <cheater> is there a way to make cabal repl start in a specific module?
15:39:05 <Eduard_Munteanu> Wizek, well, maybe 'c Int' is a 'DataTest c' after all, so instance resolution will never end
15:40:05 * hackagebot tmp-postgres 0.1.0.8 – Start and stop a temporary postgres for testing – https://hackage.haskell.org/package/tmp-postgres
15:40:55 <Eduard_Munteanu> Something like   newtype C a = C (DataTest C)
15:45:37 <Wizek> Eduard_Munteanu: I'm not sure I follow yet. Are you able to make your GHC enter an infinite loop while compiling with that newtype?
15:47:02 <Eduard_Munteanu> I haven't tried.
15:50:21 <Wizek> Eduard_Munteanu: But perhaps more importantly, have you got an idea how I could state this differently? I don't want to make it fully polymorphic, because I want to restrict the inner type. And at the same time I want to allow for different kinds of wrappers over that type.
15:52:39 <akfp> how can I write something like (,,) <$> thing <*> other <*> final  but instead of a tuple, create a 3-element list?
15:52:57 <rain1> (\x y z -> [x,y,z]) <$> ...
15:53:27 <akfp> rain1: ok, nice.. no shorter magic?
15:53:35 <rain1> i don't think there is sections for lists
15:53:49 <qmm> can i have two main functions? one in A.hs and another in B.hs?
15:53:49 <akfp> ok, good enough. thx!
15:53:55 <rain1> would be fun if you could write [,,] 
15:54:02 <Eduard_Munteanu> sequence [thing, other, final]
15:54:11 <qmm> will cabal expect that if I have a main function, the module should also be called Main?
15:54:21 <Eduard_Munteanu> :t sequence
15:54:22 <qmm> s/cabal/ghc
15:54:23 <lambdabot> (Monad m, Traversable t) => t (m a) -> m (t a)
15:54:24 <akfp> Eduard_Munteanu: ah, that's nice
15:55:17 <geekosaur> qmm, there is a main-is: for cabal files
15:55:31 <geekosaur> (behaves a bit differently than ghc's though)
15:55:49 <qmm> geekosaur: i have used that. do i need to declare a main function in the file that is declared in main-is?
15:56:22 <geekosaur> at this point I am a bit confused, you switched it from cabal to ghc. which one?
15:56:39 <qmm> sorry, maybe it will be easier if i paste
15:56:55 <geekosaur> ok, cabal's is the main source file of a given executable.
15:57:03 <Scubajump[m]> Hello there! Does anybody have any experience in Haskell + vue.js projects? I'd like to know if it is a good choice, pros and cons on your experience, or if you would recommend something else altogether. It's for web development, hopefully using Haskel for the back end.
15:57:40 <akfp> Scubajump[m]: I'm using Haskell + react native.
15:58:15 <geekosaur> within that you would need to use ghc-options: -main-is module:function
15:58:36 <geekosaur> (note that it expects a module not a filename!)
15:59:12 <Scubajump[m]> akfp: so, do you like it? I've studied it a bit, but didn't like very much the mixing of html with code, in react web.
15:59:50 <Eduard_Munteanu> I've been using Haskell's servant and Angular 4.x recently.
16:00:45 <akfp> I'm targeting mobile, and there isn't too much to choose from.  React native gives me Android + iOS, cross platform.  The model is pretty clean and maps well with Haskell.
16:00:51 <qmm> geekosaur: http://lpaste.net/8271129563438776320 and https://gist.github.com/qmmdb/5c0c91cbb49e6f4e1668a62ae5150a30
16:01:51 * hackagebot swish 0.9.1.9 – A semantic web toolkit. – https://hackage.haskell.org/package/swish
16:01:51 * hackagebot apply-refact 0.4.1.0 – Perform refactorings specified by the refact library. – https://hackage.haskell.org/package/apply-refact
16:01:56 <akfp> We're using GHCJS and most of the logic is in Haskell.  React Native is mostly views of a static data structure
16:02:08 <cheater> if i have data A = B | C | D, how do i write an Aeson FromJSON instance for it? It seems to only show you how to do this for record types / objects but not when you want to decode a string to a sum type.
16:02:20 <geekosaur> qmm, yes, so what I just said about ghc's -main-is
16:03:02 <Peaker> cheater, you can pattern match Aeson.Values directly, if they're simply JSON strings
16:03:08 <geekosaur> in this case I think: ghc-options: -main-is T
16:03:30 <geekosaur> (this is *in addition to* the cabal main-is:.)
16:03:42 <qmm> geekosaur: trying it out!
16:04:12 <cheater> Peaker: how do you pattern match on that? i can't imagine what the code would look like
16:05:00 <qmm> geekosaur: that did it!
16:05:07 <Peaker> cheater, from memory, so I might be wrong, but something like: fromJSON (Aeson.String "foo") = pure Foo ; fromJSON (Aeson.String "bar") = pure Bar ; fromJson _ = fail "Expected foo | bar" 
16:05:20 <cheater> you mean like parseJSON a | a == String "bbb" = B
16:05:21 <cheater> ?
16:05:28 <cheater> right
16:05:46 <Peaker> cheater, oh, because you can't pattern match Data.Text? I guess so
16:05:54 <Peaker> though maybe OverloadedStrings lets you pattern match on Text? I'm not sure
16:06:10 <Peaker> parseJSON (String a) | a == ".." ...
16:07:51 <cheater> i can't just do parseJSON (Aeson.String "bbb") = B
16:08:02 <cheater> because parseJSON needs to return a parser
16:08:05 <cheater> so maybe i need, like, pure
16:08:15 <Peaker> cheater, I wrote "pure" there
16:08:20 <cheater> yea that worked
16:08:27 <cheater> Peaker: i missed that, thanks
16:09:40 <Scubajump[m]> akfp: that's interesting... I guess it would not be too difficult to implement a generic react web interface, too, right?
16:12:09 <imPure> So, trying to write a plugin, and confused about something with Core. Are constraints applied as if they're values?
16:12:24 <mniip> yes
16:12:32 <Peaker> cheater, another option: parseJSON j = Foo <$ guard (j == String "foo")  <|>  Bar <$ guard (j == String "bar")  <|>  ...
16:12:34 <mniip> * and Constraint are synonymous in some stages of core
16:12:52 <imPure> mniip: Yikes. Aside from the $, any way to tell they're not values?
16:13:10 <mniip> they have a kind of constraints?
16:13:27 <cheater> thanks Peaker 
16:13:34 <mniip> they are values at runtime btw
16:13:40 <akfp> Scubajump[m]: no, it's basically the same stuff.  our designer can work directly with React, while the Haskell devs take it from there.  I don't know vue or how it compares.  We follow a strict flux architecture which works well with Haskell since no state is allowed to change in react-land.
16:13:46 <imPure> mniip: Oh, ok, so I have the Var, I could check it's type somehow.
16:13:54 <imPure> mniip: Wait... what...
16:14:04 <imPure> mniip: Constraints are at runtime?
16:14:23 <mniip> yes
16:14:37 <imPure> mniip: I have constraints all over my code, no wonder it's so expensive...
16:14:55 <mniip> show is a binary function that takes a dictionary and the object printed
16:15:24 <cheater> what sort of constraints are you guys talking about
16:15:39 <imPure> cheater: Constraint, the one and only.
16:15:43 <mniip> cheater, the C in f :: C => T
16:16:16 <mniip> imPure, sometimes when the dictionary is known it can inline at compile time
16:16:36 <mniip> there's a reason they're not distinguished from function arguments in core: the same optimization semantics apply
16:16:55 <imPure> mniip: Gotcha... So, perhaps because my plugin is appended at the front of the list of plugins they're not gone yet?
16:17:09 <mniip> I'm not sure, haven't done much with the plugin interface
16:17:15 <EvanR> i see the word panic used for a situation where the reaction is like C exit(-1) (after printing something)
16:17:23 <imPure> mniip: What I
16:17:30 <EvanR> and exception is used for conditions that you can recover from
16:17:53 <imPure> mniip: What I'm trying to do is take a bind, and modify the left side of it.
16:17:58 <EvanR> are these the only kinds of "error" (in which case error is now redundant and ambiguous)
16:18:07 <mniip> I've had something related to constraints there...
16:18:08 <imPure> mniip: Are there any libraries to help me manipulate core?
16:18:25 <imPure> mniip: I'm also using 8.0.2
16:19:30 <geekosaur> EvanR, also the kind of error from e.g. a user providing the wrong kind of command line parameter, which can be captured by Maybe and friends
16:19:37 <mniip> here's a demonstration of what instance dictionaries look like at runtime http://lpaste.net/357160
16:21:04 <mniip> it should work with ghc 8.0.2, I think that includes my unsafecoerce patch
16:21:06 <geekosaur> more colloquially "error" is kinda nonspecific and the point of this is to make it undefined
16:21:39 <mniip> yup, merged in 8.0.2
16:23:18 <imPure> mniip: So, known takes a constraint, and reifies it?
16:24:08 <mniip> sort of
16:24:51 <EvanR> ok, user input error
16:25:00 <EvanR> bad request
16:26:30 <dimsuz> hello! In ghci prompt if I type "pure (2 :: Int)" it prints 2. and the type of this expression is said to be "Applicative f => f Int", but I don't understand where it gets f from?
16:26:35 <dimsuz> is it IO? 
16:26:49 <mniip> yes
16:27:06 <mniip> ghci first tries to unify your expression with Show a => IO a
16:27:10 <mniip> then just Show a => a
16:27:26 <dimsuz> phew, I thought I'm missing something
16:29:58 <dimsuz> now I can go to sleep in peace. thanks, bye!
17:07:20 <isd> Hey all. I'm trying to build a type class that works with DeriveGeneric; the GHC.Generics docs on hackage have a good running example with an "Encode" type class, but it just junks the meta information. I'm having trouble figuring out how to write a generic implementation that actually uses that information. Is there any good documentation out there on that?
17:08:24 <glguy> isd: I don't know of such documentation off the top of my head, but if you don't find any, here's an example of using the selector names: http://lpaste.net/167793
17:18:15 <simon`> Is there some general agreement on how the order of functions within a source file should be? Order by degree of abstraction/name/...?
17:19:07 <isd> glguy: what does the @-symbol on line 12 (and elsewhere) do?
17:19:59 <geekosaur> oh boy
17:20:08 <geekosaur> VisibleTypeApplication
17:21:58 <isd> Ah.
17:25:06 * hackagebot Cabal 2.0.0.2 – A framework for packaging Haskell software – https://hackage.haskell.org/package/Cabal
17:25:06 * hackagebot postgresql-simple-queue 0.5.0.0 – A PostgreSQL backed queue – https://hackage.haskell.org/package/postgresql-simple-queue
17:34:45 <mniip> >2.0.0.2
17:56:08 <n_blownapart> https://ptpb.pw/YBo8 in case anyone wants a colorized ghci prompt....this STX suffix is what keeps my ghci from going haywire FWIW
17:56:48 <n_blownapart> that goes in .ghc/ghci.conf
17:57:49 * hackagebot rattletrap 2.5.1 – Parse and generate Rocket League replays. – https://hackage.haskell.org/package/rattletrap
18:10:18 <Lokathor> so
18:10:37 <Lokathor> wait i think i got it
18:15:10 <Lokathor> no i don't
18:15:25 <Lokathor> is there a lens that targets the first element in a list that matches a predicate
18:16:16 <Gurkenglas> Hmm "partsOf (traverse . filtered predicate) . _head" should do it
18:16:47 <puregreen> or singular (each . filtered predicate)
18:16:53 <Welkin> is there an easier way to install threadscope on mac?
18:17:02 <glguy> Lokathor: no, at best there is a sketchy Traversal
18:17:14 <Gurkenglas> (Note that it's a Traversal, since there isn't guranteed to be a target)
18:17:16 <glguy> or a Fold
18:17:23 <Welkin> I tried `stack install threadscope`, but it told me to add gtk-mac-integration-0.3.4.0 to my extra deps
18:17:32 <Welkin> so I have to create a new stack project, add this, then build?
18:17:35 <Welkin> no easier way?
18:17:35 <Lokathor> well i have a record, and in the record is a list field, and in that list i want to find a creature that matches a predicate and then update it
18:17:54 <Lokathor> in this case, i _know_ that there's a correct target already
18:18:03 <Gurkenglas> Do you know there's exactly one correct target?
18:18:07 <Gurkenglas> Does the update invalidate the predicate?
18:18:23 <Lokathor> actually
18:18:34 <Lokathor> ...it might invalidate the predicate
18:18:54 <Lokathor> alright i'll do the careful way
18:22:47 <Welkin> god damn it
18:23:02 <pacak> Welkin: Installing linux worked nicely for me. A bit more work upfront, but no problems installing anything later...
18:23:05 <Welkin> I don't understand what the issue is with stack
18:23:14 <Lokathor> updateCreatureAt loc cf d = d { _dCreatures = map (\c -> if _cLocation c == loc then cf c else c) (_dCreatures d)}
18:23:15 <Lokathor> ew
18:23:17 <Welkin> pacak: this is a mac
18:23:19 <ReinH> Welkin: last time I installed threadscape I had to find a particular binary someone had built for my arch
18:23:37 <pacak> Welkin: I know, I'm using mac as well. Just with macos removed.
18:23:38 <ReinH> So the issue may not be with stack in this case
18:23:41 <glguy> Welkin: have you tried stack?
18:23:49 <Welkin> it tells me it knows which library it needs, then asks me to type it into my stack config... why not just solve the problem itself?
18:23:56 <Welkin> glguy: I am installing it using stack
18:23:59 <Welkin> that's the issue
18:24:15 <glguy> ah, maybe switch to stack then
18:25:18 <Gurkenglas> Is there something that can go wrong with "partsOf (traverse . filtered predicate) . _head" and predicate invalidation, when the user is aware and wants that each time he uses that pseudo-traversal he'll get different targets?
18:25:53 <Welkin> ghc-events-0.4.4.0 must match >=0.5 && <0.7 (latest applicable is 0.6.0)
18:25:54 <Welkin> O.o
18:26:27 <hamishmack> Welkin: https://github.com/commercialhaskell/stack/issues/2048
18:27:46 <slack1256> why is common for allocation be done on a power of 2?
18:27:48 <Welkin> hamishmack: I don't see how that relates
18:27:53 <Gurkenglas> Like, is this about rewrite rule application breaking something? Why obey lens laws?
18:28:00 <slack1256> on haskell, the block are 64kb, yet I don't understand why
18:28:02 <Welkin> but even after I just installed these deps manually with stack, it still complains...
18:28:29 <glguy> Gurkenglas: someone could rewrite the expression according to the laws and change the result
18:28:44 <slack1256> *he allocation blocks are of 64kb
18:29:54 <glguy> or one of the -Of operations could rely on the optic being well behaved and get bad results
18:30:12 <Gurkenglas> What should one use instead of filtered to do invalidating updates?
18:31:25 <Gurkenglas> Or is the fact that one wants to do them the same sort of hint as wanting to write !!?
18:32:47 <hamishmack> Welkin: Sorry, I thought your problem was needing a different stack.yaml for osx
18:40:09 <geekosaur> slack1256, ease of tracking and computation generally since it's just a bit shift
18:40:17 <Welkin> who knows if this will even work, but I had to add the exact packages + versions output by stack
18:40:24 <Welkin> to my global stack.yaml
18:40:31 <Welkin> it's too stupid to do this on its own?
18:41:48 <geekosaur> also the underlying implementation generally prefers powers of 2 (for example malloc() allocates OS memory in powers of 2 on most platforms, and often rounds up user allocations to the next power of 2 if they aren't too big (where "too big" depends on the implementation, and for your sanity don't look at what OS X does :))
18:42:20 <Lokathor> code so generic it won't even compile :(
18:42:37 <geekosaur> Welkin, for the global one in particular I would not want it making that decision for me
18:43:50 <geekosaur> and more generally, stack will only suggest but you can invoke 'stack solver' in a mode that will apply it (only to a local project, not the global, iirc)
18:46:56 <Welkin> oh great
18:47:03 <Welkin> now it is complaining about pangocairo
18:47:14 <Welkin> has anyone ever compiled threadscope on mac?
18:47:19 <Welkin> or found a way to find a binary?
18:49:17 <slack1256> oh, that make sense
18:55:11 <Welkin> it looks like my only solution is to use a binary of threadscope from 2012
18:55:21 <Welkin> it's the only mac binary that liekly exists
18:55:23 <Welkin> likely*
19:01:14 <Welkin> well, time for game of thrones
19:06:16 <qmm> in this example, what is the type of i? https://hackage.haskell.org/package/postgresql-simple-0.4.10.0/docs/Database-PostgreSQL-Simple.html#g:2 i am trying to print it, but it needs a type for i
19:08:07 <cheater> i wish aeson threw errors when it encounters things that are out of spec, rather than just leave me trying to figure out if my parser is wrong, or the data, or something else
19:10:23 <geekosaur> qmm, in that example it is obviously Int, per the type signature. more generally I would have to see the code (and still might not know...)
19:10:50 <geekosaur> note that hello :: IO Int so you would need to use (>>=) or do notation <-
19:11:49 <Lokathor> the player can now attack creatures
19:11:59 <Lokathor> but they don't fight back
19:12:14 <Lokathor> also if the player dies the game ends up making you control the next creature in the list
19:12:24 <Lokathor> since it assumes that the first creature in the list is always the player
19:13:29 <qmm> http://lpaste.net/357161
19:14:58 <geekosaur> qmm, ok, the problem there is ghci needs to fix the type immediately, ghc can infer it from uses (or type signatures as in the example)
19:15:22 <geekosaur> prob ably the easiest way to deal is:
19:15:35 <geekosaur> :seti -XScopedTypeVariables
19:15:39 <qmm> oh, i received that error in ghc as well
19:16:07 <geekosaur> [Only (i :: Int)] <- query_ conn "select 2 + 2"
19:17:09 <geekosaur> in ghc you would need to do something else to fix the type, if it can't be inferred from its use or a type signature
19:17:41 <geekosaur> although the easiest solution might be the same as the one I showed for ghci (except it'd be {-# LANGUAGE ScopedTypeVariables #-} )
19:18:58 <monochrom> I love ScopedTypeVariables. Best thing since type variables. :)
19:19:16 <qmm> scoped typed variables did it. got rid of both the errors in ghc
19:19:20 <geekosaur> well, this is actually a slightly weird use of it since PatternSignatures went away
19:20:00 <monochrom> Oh, right, this is ScopedTypeVariable swallowing up PatternSignatures.
19:20:18 <monochrom> Because "random variable" is neither random nor variable anyway. :)
19:21:03 <monochrom> "Down with ScopedTypeVariables expansionist imperialism!"
19:37:13 <qmm> is this how others are listening for updates to postgresql: https://hackage.haskell.org/package/postgresql-simple-0.4.10.0/docs/Database-PostgreSQL-Simple-Notification.html this is the only method i've seen so far
20:06:11 * hackagebot composable-associations-aeson 0.1.0.0 – Aeson ToJSON/FromJSON implementation for the types of composable-associations – https://hackage.haskell.org/package/composable-associations-aeson
20:06:11 * hackagebot composable-associations 0.1.0.0 – Types and helpers for composing types into a single larger key-value type. – https://hackage.haskell.org/package/composable-associations
20:20:23 * hackagebot digestive-functors-lucid 0.0.0.5 – Lucid frontend for the digestive-functors library – https://hackage.haskell.org/package/digestive-functors-lucid
20:42:41 * hackagebot neko-obfs 0.1.0.1 – a TCP tunnel with packet length obfuscation – https://hackage.haskell.org/package/neko-obfs
21:44:36 <scalaparsingprob> Does anyone know the scala equivalent for recursive ADT's from Haskell? For instance in scala how I could represent: data AExpr = ABinary ABinOp AExpr AExpr
21:51:35 * hackagebot tls-session-manager 0.0.0.1 – In-memory TLS session manager – https://hackage.haskell.org/package/tls-session-manager
22:02:12 <dibblego> sealed trait AExpr; case class ABinary(x: ABinOp, l: AExpr, r: AExpr) extends AExpr
22:20:59 <imPure> Trying to debug a plugin, and Core lint is throwing an error that seems like it should be fine: warning:
22:21:00 <imPure>     In the expression: id @ [Char] (unpackCString# "a"#)
22:21:00 <imPure>     Illegal type application:
22:21:00 <imPure>     Exp type: [Char] :: *
22:21:03 <imPure>     Arg type: [Char] :: *
22:21:57 <monochrom> Should it be [Char]? Should it be ([] Char)?
22:22:29 <imPure> monochrom: I'll give that a shot, but the error says Exp and Arg are the same...
22:22:43 <imPure> monochrom: How can I tell them apart?
22:22:52 <monochrom> Yeah, I'm just guessing, not really sure.
22:23:32 <monochrom> I have experience reading -ddump-simpl output but never tried plugins.
22:23:45 <imPure> monochrom: I've been having trouble modifying core, so wrote some utils to modify the ith binding of an application.
22:24:19 <imPure> monochrom: What I did here was modify an argument just by applying "id" to it
22:24:43 <imPure> monochrom: The type came from a call to exprType on that argument.
22:25:05 <monochrom> Ah, it's already given.
22:26:36 <imPure> monochrom: I'm just trying to apply id to the arg, without breaking anything.
22:27:19 <imPure> monochrom: Have to crawl before I walk. But, not getting very far :)
22:27:52 <monochrom> Yeah, it's strange, you're already using the inferred type.
22:29:03 <imPure> monochrom: TyConApp '[]' [TyConApp 'Char' []]
22:30:27 <imPure> TyConApp '[]' [TyConApp 'Char' []]
22:30:36 <imPure> So, they're the same.
22:30:55 <imPure> That second one I got by calling id.
22:31:11 <imPure> And just looking at what it outputs.
22:31:49 <trigone> hi, if type synonyms defined with keyword type don't participate to typechecking, what's their purpose/usage?
22:31:57 <geekosaur> can you even use VTA with id?
22:32:05 <imPure> VTA?
22:32:05 <geekosaur> sadly the only test I know for it requires 8.2.1
22:32:13 <geekosaur> visible type application
22:32:23 <imPure> geekosaur: Don't know what that is
22:32:29 <geekosaur> the @
22:32:51 <geekosaur> ...how are you using it if you don;t even know what it's called?
22:33:08 <imPure> geekosaur: I'm manipulating Core...
22:33:33 <imPure> geekosaur: Like... mkApps
22:33:39 <geekosaur> oh, that's going to be harder, I'm not even sure the rules there
22:33:51 <geekosaur> at haskell level there are places you can;t use @
22:33:52 <imPure> geekosaur: Is there an easier way?
22:34:05 <geekosaur> and I don't know if the same applies to Core
22:34:24 <geekosaur> sigh. I did not mean harder to use
22:34:30 <geekosaur> I mean harder to figure out
22:34:33 <trigone> nvm i remembered
22:34:36 <geekosaur> (what rules apply etc.)
22:35:27 <geekosaur> thing is, I'm not sure applying id like that makes sense
22:35:32 <geekosaur> because it;s always the same id
22:35:39 <geekosaur> it;s not a typeclass instance or w/e
22:36:00 <imPure> *** Offending Program ***
22:36:00 <imPure> add :: String
22:36:00 <imPure> [LclIdX, Str=DmdType]
22:36:00 <imPure> add =
22:36:03 <imPure>   ++ @ Char (id @ [Char] (unpackCString# "a"#)) (unpackCString# "b"#)
22:36:04 <geekosaur> so nothing is gained by specifying the type
22:36:05 <imPure>  
22:36:09 <imPure> $trModule :: Module
22:36:12 <imPure> [LclIdX, Str=DmdType]
22:36:15 <imPure> $trModule =
22:36:18 <imPure>   Module (TrNameS "main"#) (TrNameS "CoreTest"#)
22:36:21 <imPure>  
22:36:25 <imPure> *** End of Offense ***
22:36:28 <imPure>  
22:36:28 <geekosaur> aaand, right, paste long stuff directly intot he channel
22:36:41 <imPure> geekosaur: Oh, pastebin, sorry
22:37:35 <imPure> Actually, I have an idea of what may be wrong.
22:38:42 <imPure> Using mkGlobalVar to go from the name looked up in the OccEnv.
22:38:56 <imPure> However, mkGlobalVar requires it be passed a type.
22:39:59 <imPure> What's needed is a way to lookup the type of the variable from OccEnv.
22:52:46 <minn> Is it possible to derive lens instances (using the lens package) in Alex/Happy files (e.g., for AlexUserState)?
22:58:10 <imPure> Guessing lookupType is what I need to go from OccName → Type
22:58:30 <imPure> Correction, lookupTypeEnv
22:59:44 <mniip> hey
23:12:01 <imPure> Is there no way to lookup a Var in one shot? As opposed to getting the type from TypeEnv, and the name from OccEnv?
23:15:47 <Hijiri> buffer 20
23:23:36 <imPure> Actually, is it as simple as lookupId?
23:24:36 * hackagebot relational-query 0.9.4.0 – Typeful, Modular, Relational, algebraic query engine – https://hackage.haskell.org/package/relational-query
23:24:36 * hackagebot relational-query 0.8.7.0 – Typeful, Modular, Relational, algebraic query engine – https://hackage.haskell.org/package/relational-query
23:42:57 * hackagebot naqsha 0.2.0.1 – A library for working with geospatial data types. – https://hackage.haskell.org/package/naqsha
23:57:06 * hackagebot hw-rankselect 0.8.0.1 – Rank-select – https://hackage.haskell.org/package/hw-rankselect
23:57:07 * hackagebot hw-bits 0.5.0.2 – Bit manipulation – https://hackage.haskell.org/package/hw-bits
