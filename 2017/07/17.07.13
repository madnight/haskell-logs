00:01:33 <pacak> neoncontrails: Yes.
00:01:49 <pacak> And there's stuff for state machines as well
00:02:22 <Axman6> Haskell has the best tools for parsing
00:02:34 <johnw> writing parsers in Haskell takes a little getting used to, since combinator parsers aren't very much represented in other languages; but once you get the hang of, is it *very* nice
00:02:48 <johnw> I've used tons of different parser construction tools and languages, and Haskell is hands down my favorite
00:03:04 <neoncontrails> pacak: Music to my ears. :) Are there any apps you can think of that do a nice job implementing the state machine pattern? 
00:07:36 <neoncontrails> johnw: I had to remind myself the definition of a combinator... this is precisely the pattern I thought sounded optimal for my use case, you are 100% correct that this is not well-represented in other languages :)
00:08:17 <merijn> neoncontrails: Are we talking natural language or just structured text?
00:08:34 <neoncontrails> (For some reason I just had a hunch that Haskell might express this more simply than Python -- it sounds like my hunch was a good one, aw yisss)
00:09:46 <merijn> neoncontrails: I just (well, last month) rewrote all the parsing of input for feeding into a python machine learning library from Python to Haskell and everything about life is better now :p
00:10:20 <neoncontrails> merjin: Just structured text at the moment. The problem I have been having is that certain patterns on a typical structured document are sectional dividers -- in some abstract sense they change the "state" of the reader
00:10:46 <johnw> neoncontrails: I ported the concept to Emacs Lisp, and it worked out nicely there too, but was totally foreign
00:11:55 <neoncontrails> merijn: by any chance is the code public? I'd really love to see the repo if it is
00:12:34 <merijn> neoncontrails: eh, it will be public eventually, but I forgot if I already made an early version open :)
00:12:58 <merijn> not yet
00:14:22 <merijn> neoncontrails: Are the documents a single structure or just sequences of smaller records you need to process?
00:18:11 <neoncontrails> merijn: good question. My test case is the entirety of wiktionary. My hunch is it would be great to compose them in such a way that each heading passes through to a nested parser (so the parser would accept a fragment of text, which may be structured, and passes the structured parts to the appropriate handler)  
00:19:23 <merijn> neoncontrails: I'm asking because one of the huge benefits of Haskell over python is that turning a parser for a single record into something can parse lists of record in a streaming way is absolutely trivial in Haskell, while being rather hard in other languages :)
00:25:15 <neoncontrails> merijn: that does sound nice, out of curiosity is there a "best" way of feeding very large files to Haskell? The corpus is basically a large XML file, it can be iterated over but I am not totally sure if it's possible to do in Python without loading the entire file into memory. (This might be exactly what you're saying)
00:25:40 <pacak> neoncontrails: define "very".
00:25:58 <merijn> neoncontrails: oh, just recently I contributed a bunch of patches to xml-conduit to make it a bit more usable. The documentation is a bit...sparse, but it works very well :)
00:26:42 <neoncontrails> 16GB thereabouts? It's smaller compressed, but I won't hold it against Haskell if it prefers it not be
00:27:18 <neoncontrails> Oh good!
00:27:46 <pacak> I'm using iteratees to deal with big amount of data and it's easy to decompress stuff as you read it from disk.
00:28:12 <pacak> You probably want SAX parser and some understanding what are you going to do with this data.
00:28:39 <pacak> GC overhead might be significant if you want to keep a ton of small objects in memory.
00:28:53 <merijn> meh...just get more memory :p
00:29:15 <merijn> If he has 16GB of data to process I'm assuming they can afford a server with like >32GB RAM
00:29:41 <Axman6> 16GB of data is nothing :\
00:30:21 <pacak> Axman6: If you know what you are doing with it.
00:30:33 <merijn> mmap all the things :p
00:30:39 <Axman6> aye
00:30:42 <neoncontrails> Heh it's for an open source project, I'm limited to my ol' Macbook
00:31:01 <merijn> neoncontrails: Then you probably wanna invest a bit of time to stream process it :p
00:31:15 <neoncontrails> My thoughts too :)
00:31:30 <merijn> neoncontrails: Which, incidentally, should be easier to do in Haskell than python :p
00:32:05 <neoncontrails> It's certainly not easy in Python. So that's good to hear
00:34:28 <neoncontrails> Is the Mac Haskell IDE a good development environment for a Haskell newb?
00:34:59 <Axman6> it's probably not a bad place to start, but it has some limits IIRC
00:35:19 <merijn> neoncontrails: Depends, do you have an existing editor you're comfortable with?
00:35:59 <merijn> neoncontrails: I would say the people here use 33% vim, 33% emacs, 33% miscellaneous (sublime, textmate, VS Code, atom, whatever)
00:36:30 <neoncontrails> I use IntelliJ, but it's not as extensible as I would like
00:36:31 <merijn> neoncontrails: So I would probably recommend sticking with whatever you're already comfortable with
00:37:48 <sm> haskell for mac might be particularly good for learning though
00:37:59 <johnw> merijn: hah
00:38:15 <wz1000> neoncontrails: If you would like to be a guinea pig, I've been working on haskell-ide-engine, which is almost ready for an alpha release
00:38:20 <merijn> johnw: hmm?
00:38:28 <wz1000> Haven't tested it on osx though
00:38:30 <johnw> merijn: such a fair distribution
00:38:43 <merijn> johnw: I think it's roughly accurate, tbh
00:39:20 <merijn> johnw: vim/emacs certainly make up at least two thirds here, and I don't have any evidence one of the two is significantly more popular than the other
00:39:29 <johnw> i don't either
00:39:55 <neoncontrails> wz1000: as generous as your offer sounds, I am a bit leery of using an alpha version of an IDE as my very first dive into Haskell 
00:39:55 <merijn> I suppose the "misc" group could be smaller than 1 third, but there's also a lot of newbies which inflate those numbers
00:40:41 <neoncontrails> But I'd love to play with it when I graduate from Haskell for Mac, and can take the training wheels off :)
00:41:41 * hackagebot spreadsheet 0.1.3.5 – Read and write spreadsheets from and to CSV files in a lazy way – https://hackage.haskell.org/package/spreadsheet
00:47:45 * hackagebot typed-duration 0.1.1.0 – Thread delay and timeout functions with typed arguments – https://hackage.haskell.org/package/typed-duration
00:49:08 <neoncontrails> merijn: are there any resources/tutorials you found particularly helpful for expressing parser logic in haskell? 
00:50:02 <merijn> neoncontrails: The Real World Haskell chapter on parsec is pretty decent. It's dated in the sense that the code might not compile directly as listed in the book, but the high level overview of how parsec works and how to write parsers should be the same
00:51:05 <merijn> neoncontrails: Incidentally you might wanna look at megaparsec (slightly more modern/featureful replacement for Parsec) or attoparsec (faster parsing, but worse error reporting), both should be "mostly the same as parsec" in terms of how you use them
00:52:45 <pacak> RWH is a bit ancient.
00:52:56 <pacak> Parsec can be a bit annoying with try.
00:53:10 <neoncontrails> thanks for that heads up. What sorts of expressions have a different syntactic expression in 2017, is it a large list? (i.e. I usually use 'print' as a litmus test in Python for checking if it's Python 2 vs 3)
00:56:56 <merijn> neoncontrails: I'm not sure if there are any clear difference beyond "huh, this doesn't compile without error", usually because some imports have changed. Parsec predates a lot of modern Haskell (like Applicative/Alternative), so some of the operators it defines where later generalised, but the precedence levels don't always match up identically
00:57:24 <merijn> neoncontrails: Large parts of the examples should still work, I think
01:00:59 <ventonegro> Does anybody here else use Chart-cairo? I'd like to output a PNG to a Bytestream, but it seems it only writes directly to disk
01:01:21 <ventonegro> ByteString*
01:02:36 <erisco> so just set up a RAM disk and then use shared memory
01:02:51 <ventonegro> "just" :)
01:03:25 <ventonegro> Just found this `temporary` package, I guess it'll do
01:08:50 <merijn> ventonegro: Make a patch and submit a PR for that functionality! :)
01:09:32 <ventonegro> merijn: I know, I know... Complaining is cheap
01:10:42 <merijn> ventonegro: I believe in the power of small incremental improvement :) Fix a tiny thing here and there and no one else will have to have the same problem :)
01:11:27 <ventonegro> merijn: I agree
01:11:39 <Athas> Complaining is cheap; compiling is time-consuming.
01:12:16 <Athas> What is the best replacement for Parsec these days?
01:12:29 <Athas> (If you want good error messages and such.)
01:14:19 <merijn> Athas: Is pretty errors more important than easy docs?
01:15:29 <Athas> merijn: I suppose.
01:16:04 <merijn> Athas: I really like Trifecta's errors, but the docs are...not immediately obvious :p I think my parser has served as unofficial trifecta tutorial for a handful of people so far: https://github.com/merijn/lambda-except/blob/master/Lexer.hs
01:16:14 <Athas> Although it would be nice to have something I can point to when I teach parser combinators this fall.
01:16:34 <Athas> That thing has a billion dependencies - no dice for me.
01:16:42 <merijn> Athas: Then probably megaparsec?
01:17:59 <merijn> Athas: It looks fairly successful as "cleaner and more modern" parsec
01:18:44 <Athas> Yes, that looks good.
01:19:08 <ocramz> morning all
01:21:54 <ocramz> I'd like to interleave text parsing, a sys call and text generation. Specifically, an attoparsec parser goes through the input file and when it encounters certain keywords it performs a syscall and inserts the result in the output file
01:22:08 <ocramz> this thing says monad transformers iiuc
01:22:40 <ocramz> so there would be IO at the bottom, and a "parser transformer" on top? can anyone shed some light?
01:23:06 <Athas> ocramz: yes, that is what you would need.
01:24:44 <ocramz> so I could use `lift` from transformers to perform IO in the parser ?
01:25:01 <dmwit> Doh! I can't `[] @Int`.
01:25:37 <dmwit> ocramz: I would be a bit nervous about wrapping IO in a parser transformer.
01:26:01 <ocramz> dmwit :D how would you structure it instead?
01:26:03 <dmwit> ocramz: Many parsers backtrack.
01:26:07 <ocramz> right
01:26:28 <dmwit> ocramz: I haven't read far enough back to give really targeted advice. This is just a gut reaction to seeing a few messages go by.
01:27:07 <ocramz> dmwit : really simple question; if an attoparsec parser encounters a keyword, splice in the result of an IO call
01:27:10 <dmwit> ocramz: I think I would structure it like so: parse to a sequence of commands. Then execute the commands when you're sure the parse succeeded. Then write the results to file.
01:27:54 <Athas> Writing parsers that produce monadic actions is also great fun.
01:28:07 <dmwit> Yes, you can do that. But 99% of the time it's premature optimization.
01:28:20 <dmwit> Write a good ADT for what you're expecting to see in the file.
01:28:27 <Athas> I once wrote a parser for regular expressions that produced another parser.  The type was something like: regex :: Parser (Parser Bool)
01:28:27 <dmwit> You'll thank yourself later when things change a little bit.
01:29:30 <ocramz> dmwit right: thanks, I'll give it a try
01:29:54 <ocramz> the text format is frozen though; it's Unix "conf"
01:30:16 <ocramz> but yeah I see the advantages of decoupling parsing and generation
01:30:23 <dmwit> Even if the format doesn't change, the program might. =)
01:30:28 <ocramz> yep
01:31:29 <ocramz> thanks dmwit and Athas
01:32:10 <Athas> ocramz: oh, for something like this, definitely don't put an IO monad beneath your parser.
01:32:24 <Athas> I thought this was for some delayed stream where the IO actions would affect what was going to be read.
01:43:02 <ADG> is there any gui debugger for haskell
01:43:25 <pacak> ADG: O_o
01:43:37 <pacak> Why would you want such a thing?
01:43:48 <merijn> pacak: Clearly you've not used a good graphical debugger
01:43:56 <dmwit> I'm not sure whether you want a GUI that is a debugger or a debugger for GUIs, but either way there isn't really one.
01:45:01 <ADG> I really liked the one for Eclipse JAva
01:45:18 <ADG> I will try GHCi
01:45:26 <merijn> Actually I think you could make a kick-ass graphical debugger for Haskell, it'd just be an insane amount of work
01:46:43 <pacak> Typechecks - deploy!
01:47:25 <AWizzArd> Can Opaleye be used to query Redshift?
01:54:41 * hackagebot servant-auth-cookie 0.5.0.5 – Authentication via encrypted cookies – https://hackage.haskell.org/package/servant-auth-cookie
01:54:58 <merijn> AWizzArd: What's Redshift?
01:55:15 <AWizzArd> merijn: One Amazon’s database systems.
01:55:28 <AWizzArd> merijn: It’s a modified postgres under the hood.
01:55:44 <dmwit> I think I invented a trick today, and I've been really enjoying it. http://lpaste.net/356904
01:55:51 <merijn> AWizzArd: Probably not?
01:56:17 <dmwit> This way you can add functions anywhere in the pipeline cleanly (e.g. you don't have to add an extra `.` or move where the `=` is or anything like that, as you do with most other styles).
01:56:22 <merijn> dmwit: That'd work just as well without the id?
01:56:55 <dmwit> merijn: Sure. Would you put the `=` on line 1 or 2?
01:57:20 <dmwit> merijn: If line 1, then you don't have a `.` on line 2, and so adding functions to the beginning of the pipe requires more than just adding a line, you also have to modify an existing line.
01:57:37 <merijn> dmwit: I haven't made up my mind yet where I want = in these cases
01:57:53 <merijn> dmwit: So far I've kept = near the LHS when doing line continuation
01:57:56 <dmwit> merijn: If line 2, then basically the same, except instead of having to add a `.`, you have to replace an `=` with a `.` and add an `=` for the new line.
01:58:09 <cocreature> I’ll take the “pain” of adding or removing the . over a redundant id
01:58:13 <dmwit> merijn: You see why the extra `id` makes this question go away in a really clean way?
01:58:15 <merijn> dmwit: tbh, I don't think this is common enough to worry about to much
01:58:25 <dmwit> cocreature: The compiler will kill the `id`, if it's overhead you're worried about.
01:58:38 <cocreature> dmwit: it’s mental overhead not runtime overhead that I’m worried about :)
01:58:43 <neoncontrails> Is the zeroth koan to modify the repository so the installation instructions no longer return "setup-koans: [ERROR]cabal install --only-dependencies failed." ? :)
01:58:49 <neoncontrails> https://github.com/HaskVan/HaskellKoans
01:58:56 <cocreature> I guess you get used to it but I just don’t care anough about having to add a dot sometimes
01:59:09 <dmwit> I've done it 8 times today already. So I think it's pretty common. =)
01:59:58 <merijn> dmwit: Quit changing your code so much then :p
01:59:59 <dmwit> cocreature: So, on the mental overhead point: this also keeps diffs nice and clean, which removes some mental overhead from code reviews and from when you inevitably have to dig into your logs to understand some problem.
02:00:08 <dmwit> merijn: ?
02:00:10 <cocreature> also I tend to use (f . g . h) x instead of f . g . h $ x which makes this slightly more awkward
02:00:38 <merijn> dmwit: "I've done it 8 times today already" :)
02:00:52 <dmwit> merijn: "it" = "use id to start a function"
02:01:27 <dmwit> (I like functions that can be written as pipelines. It makes me think I'm designing nice clean, reusable helpers.)
02:03:03 <merijn> dmwit: Well, how often have you updated those pipelines?
02:03:24 <dmwit> Dunno. Didn't track that.
02:04:06 <dmwit> But historically, I've updated such pipelines a lot.
02:04:10 <dmwit> um.
02:04:12 <dmwit> I think.
02:04:29 <dmwit> Humans are notoriously bad at such judgments, so take that with whatever salt you intend to.
02:04:44 <merijn> dmwit: At the start? :p
02:04:54 <erisco> oh sure, blame humans
02:05:14 <dmwit> merijn: Often enough that it's been an annoyance that I've been trying to figure out how to avoid. =P
02:05:29 <dmwit> Now if only lists would accept a trailing comma, I could clear that problem, too...
02:09:26 <merijn> dmwit: Don't you mean leading comma? Or are you one of those "comma after element" heathens?
02:10:26 <dmwit> Either one would be fine. I'll use the style that lets me have a consistent editing pattern.
02:10:40 <dmwit> Currently I put commas at the beginnings of lines.
02:14:29 <neoncontrails> I wonder if anyone's written a test suite that passes the program output through an entropy functor, so "100% passing" files with a lastUpdated timestamp older than a few years have lower confidence
02:15:38 <dmwit> I'm not sure I understood that.
02:15:51 <dmwit> In fact, I'm sure I didn't understand that.
02:21:03 <neoncontrails> Oh I mean in the sense that a data pipeline can be '100% correct' in the eyes of the interpreter, but as time passes the interpreter is less likely to align with the state of the language. You could modify the test suite to assign a  "confidence score" as a function of the lastUpdated timestamp :)
02:21:23 <neoncontrails> (I've never seen this implemented though)
02:23:47 <lambdaGrp> you'll need a way to predict the future
02:24:53 <kuribas> I wish Data.Map.insertWith had type:  Ord k => (a -> b -> b) -> k -> a -> Map k b -> Map k b
02:25:06 <kuribas> It's too specialized...
02:25:43 <wonderer88> I'm looking for a tool I recently discovered, which visualises GHC Core as you progress through Haskell programs. I.e. what's on the stack, on the heap, the currently evaluated function etc. It runs in a termal window. Can anyone tell me what the tool is called?
02:30:33 <merijn> wonderer88: Are you thinking of stgi?
02:31:07 <wonderer88> merijn: that's the one, thanks!
02:31:34 <merijn> kuribas: I wish Map had a useful Monoid, but alas :)
02:32:04 <kuribas> merijn: merge?
02:32:17 <kuribas> but there's a constraint...
02:32:46 <Athas> I use the Map Monoid all the time!
02:32:58 <ventonegro> How to convert a strict ByteString to a lazy one? I've see toStrict, but cannot find toLazy
02:33:12 <merijn> Athas: Really? When?
02:33:26 <merijn> Athas: And why not just use "unions"? Which does the same thing already
02:33:28 <Athas> merijn: name shadowing when using it to implement symbol tables.
02:33:43 <merijn> Athas: I just use unions for that
02:34:37 <merijn> Athas: And the other Monoid would allow for so many neat and concise things :\
02:34:47 <kuribas> hm, I could define insertWith2 f k a = insertWith (const (f a)) k undefined
02:35:47 <lambdaGrp> ventonegro: https://hackage.haskell.org/package/string-conversions
02:35:49 <ventonegro> Ah ha, `fromStrict`
02:35:49 <pacak> ventonegro: fromStrict?
02:35:54 <ventonegro> thanks :)
02:36:05 <kuribas> merijn: what's bad about it?
02:36:17 <merijn> ventonegro: Don't use that package
02:36:28 <merijn> ventonegro: There's toStrict and fromStrict in Data.ByteString.Lazy
02:36:51 <merijn> kuribas: Bad about what? The current Monoid you mean?
02:36:56 <kuribas> yes
02:37:00 <ventonegro> Yeah, for some reason I thought I'd find `toLazy` :)
02:37:43 <merijn> kuribas: The fact that it's not "instance (Semigroup v) => Semigroup (Map k v)"
02:38:34 <merijn> kuribas: I've wanted/needed that one like 25 times so far. I've enver really wanted "left-biased union" for map
02:38:42 <merijn> kuribas: And definitely as it's monoid
02:39:20 <peddie> merijn: do you know why that's not the instance?  I've wanted that too
02:39:27 <peddie> just history?
02:39:34 <merijn> peddie: Sad history
02:39:57 <merijn> peddie: There have been two recent campaigns on libraries@ to at least add a module with a newtype for Map that does that
02:40:16 <peddie> no luck?
02:40:40 <merijn> peddie: It's not happened yet, but I think it's mostly a matter of bikeshedding the name and actually implementing it
02:40:57 <kuribas> merijn: you'd want flip union instead?
02:40:59 <peddie> I suppose it could just as well be a standalone package
02:41:17 <merijn> kuribas: No, I want mappend duplicate keys
02:41:35 <merijn> kuribas: Note semigroup constraint on v in the instance I wrote
02:41:56 <kuribas> merijn: unionWith (<>) ?
02:42:55 <merijn> kuribas: Basically, but if you use unionWith you can't use the Monoid instance of functions to combine things
02:45:01 <kuribas> merijn: how would you define it?  this doesn't work: instance (Monoid a) => Monoid (Map k)
02:45:53 <merijn> kuribas: "instance Monoid v => Monoid (Map k v)"? Like I just said
02:46:25 <kuribas> hm, right
02:46:58 <merijn> Except you only need Semigroup on 'v', since "mempty" is just the implicit "missing key"
02:47:58 <kuribas> Then you could implement left biased union with First.
02:49:22 <merijn> kuribas: Not quite First, since that's apparently on Maybe, but yeah, a newtype that always returns the left hand would be a special case of that instance
02:50:23 <merijn> Oh, First from semigroup
02:50:24 <merijn> Yeah
02:51:00 <merijn> kuribas: Hence my annoyance of the current Monoid. It's a, not particularly interesting nor useful, special case of a far nicer abstraction
02:51:29 <merijn> But people are terrified of breaking it since it's hard to detect any breakage
02:51:38 <merijn> So, we might be stuck with it forever
02:51:52 <merijn> Someone should survey Hackage to see how many people are actually using it
02:52:16 <kuribas> Though map is O(n), that may not be efficient...
02:52:49 <merijn> kuribas: You mean wrapping the newtype?
02:52:54 <merijn> kuribas: That's why you use coerce
02:53:01 <merijn> Everyone keeps forgetting about coerce...
02:53:08 <merijn> <3 coerce
02:54:08 <kuribas> coerce sounds like magic...
02:54:13 <kuribas> How does it know it's a newtype?
02:54:20 <merijn> kuribas: Inferred by GHC
02:54:37 <merijn> kuribas: GHC automatically generates relevant Coercible instances for newtypes
02:54:50 <merijn> kuribas: It's basically "unsafeCoerce" but without the unsafe :p
02:55:12 <merijn> kuribas: You also have the whole role system to guide Coercible and stop it from doing unsafe things
02:55:13 <kuribas> that's neat
02:56:18 <merijn> "Coercible is a two-parameter class that has instances for types a and b if the compiler can infer that they have the same representation. This class does not have regular instances; instead they are created on-the-fly during type-checking."
02:57:56 <merijn> kuribas: If you use roles you can also do thing like, "disallow coerce to work on, e.g. Set" (since newtypes in Set affect Ord which would break invariants)
02:58:21 <merijn> Sadly they decided to default to an "unsafe" default for Coercible, since the safe default would force everyone to make role annotations
02:58:23 * kuribas found Data.Map.adjust would actually work fine...
02:58:51 <merijn> kuribas: For what?
02:59:03 <kuribas> merijn: my insertWith2 function
02:59:08 <merijn> ah, right :)
02:59:55 <kuribas> So "safe" coerce isn't actually safe...
03:00:52 <merijn> kuribas: It's safe, as long as datatypes accurately define roles when needed.
03:01:22 <merijn> Which containers, for example, does
03:02:02 <kuribas> But it cannot be checked by ghc...
03:02:07 <orion> In GHC 8.0.2 I was able to call this function: http://hackage.haskell.org/package/postgresql-simple-0.5.3.0/docs/Database-PostgreSQL-Simple-FromField.html#v:returnError with "a' being "data Foo = A | B | C"
03:02:14 <merijn> kuribas: The choice was "infer a default role of nominal", i.e. dont' allow "coerce", unless explicitly annotated. (This is the safest thing, since everything not explicitly annotated as safe won't work)
03:02:42 <orion> I did not derive Typeable on the Foo type, yet I'm able to use returnError successfully in spite of the Typeable type class constraint.
03:02:49 <orion> Does anyone know why this would happen?
03:02:56 <merijn> kuribas: The other alternative is "infer a default role of representational", i.e. allow "coerce" unless explicitly annotated (this means coerce works with almost everything out there, but unsafe coercions need to be explicitly disallowed)
03:03:25 <merijn> kuribas: They ended up going with the latter, since the former would require chasing all of Hackage to add role annotations and nominal roles are relatively rare
03:04:50 <kuribas> that's pretty neat
03:06:13 <kuribas> This advanced stuff must be scary for newbies...  But I guess that applies to C++ as well.
03:08:12 <Athas> Both Haskell and C++ are probably creaking under all the extensions.
03:08:16 <Athas> (But C++ much more so.)
03:08:18 <kuribas> And while C++ is fast, I think haskell is much better in tranforming high-level code into low level code.
03:09:10 <Athas> Really?  C++ is actually one of the few languages that allow you to get "free" abstractions (you pay with tears instead).
03:09:48 <Athas> I guess you could get similar with Template Haskell, but it's not really as convenient as template programming.
03:10:15 <kuribas> Athas: Well, how would you implement parser combinators in C++?
03:11:28 <kuribas> Athas: templates are like parametric polymorphism, except in haskell you can choose when to duplicate code (with SPECIALIZE pragmas).
03:11:31 <Athas> Isn't that what Boost Spirit does?  Anyway, does GHC turn parser combinators into particularly low-level code?
03:12:04 <kuribas> Athas: it does inlining etc...
03:12:31 <kuribas> I don't know if C++ knows how to inline HOFs...
03:12:50 <kuribas> I could be wrong though...
03:12:55 <Athas> If you implement them with templates (which is a very common strategy), then it does.
03:13:29 <pacak> Athas: You can get free abstractions in haskell as well. ghc is kind of smart plus you can help him with  pragmas and rewrite rules.
03:14:24 <Athas> I actually find C++ templates easier to reason about than pragmas and rewrite rules (especially the latter, with the multiple simplification stages).
03:16:59 <kuribas> Athas: can you make rule "expensiveInversTransformation . expensiveTransformation = id" in C++?
03:17:32 <pacak> kuribas: c++ templates are turing complete.
03:17:41 <kuribas> Athas: which also works after several reduction stages?
03:17:41 <pacak> You can.
03:17:47 <Athas> kuribas: probably only if the composition is expressed as templates, but it will be very painful.
03:18:27 <Athas> It's also worth mentioning that the C++ techniques are standard C++, while all these pragmas and rewrite rules are compiler extensions.
03:18:43 <Athas> And essentially untyped.  You can screw up your rewrite rules and nobody will tell you.
03:18:59 <f-a> are there any up-to-date logs?
03:19:03 <pacak> You can pretend that ghc is the only haskell compiler alive
03:19:32 <kuribas> Athas: I think they are typed...
03:20:09 <Athas> You may get a core lint error or something _if_ your rewrite rule fires incorrectly, but nobody will tell you that your rewrite rule is bad before it goes wrong.
03:20:24 <Athas> Although this is the case for C++ templates, too.
03:20:59 <kuribas> yes, but that's the point.
03:21:11 <kuribas> So you can specify transformations that ghc cannot infer.
03:21:56 <Athas> I'm not saying it's not a pragmatic and useful tool, just that it's not really beautiful.
03:22:41 <kuribas> beautiful and practical often don't go well together...
03:22:56 <Athas> For rewrite rules, you are also not told if they fail to fire, so that can go undetected for a while.  That failure scenario does not really exist with C++ templates.
03:23:23 <kuribas> Athas: you can tell ghc to show when rules fire.
03:24:32 <thelinuxguy> does "g = map subtract" make any sense? how would I use such a function?
03:24:40 <Athas> Then whenever you change your code, you have to check all users for whether the expected rewrite rules fire.  Not really practical...
03:24:57 <Athas> I am pretty sure I have seen performance regressions due to this, but I can't remember the details offhand (text, maybe?).
03:26:31 * kuribas must study the black magic of C++ templates more 
03:26:41 <Athas> thelinuxguy: map ($0) $ map subtract [1,2,3]
03:27:18 <Athas> kuribas: it's just a really bad compile-time functional language!  The only really weird thing is how you encode control flow not just by specialisation, but also by triggering type errors in instantiations you don't want.
03:27:21 <kuribas> thelinuxguy: perhaps with (<*>)?
03:28:27 <kuribas> :t (<*>)
03:28:29 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
03:29:09 <thelinuxguy> hmm... it's part of a university assignment... not sure why it's so complicated... ^^
03:29:22 <thelinuxguy> thanks anyway, now I know how to use it...
03:29:55 <kuribas> > let g = map subtract in g [1, 3] <*> [4, 6, 12] --thelinuxguy
03:29:57 <lambdabot>  [3,5,11,1,3,9]
03:31:34 <kuribas> Athas: one of the advantages of C++ (besides being fast for numerical code) is that it can give me a job without moving to another country.
03:32:50 * pacak liked moving to another country part.
03:33:29 <kuribas> pacak: where do you live now?
03:33:30 <pacak> kuribas: One of the advantages of moving to another country is that instead of 4 weeks of summer you get 12 months of it.
03:33:34 <Xion__> SFINAE is awesome, not weird.
03:33:41 <pacak> kuribas: Singapore.
03:33:59 <Athas> kuribas: use Fortran for your numerical code!
03:34:13 <kuribas> noooooooooo
03:36:59 <hari90> hello all
03:37:37 <zwild> hello
03:37:47 <pacak> o/
03:38:39 <hari90> I have a scraping job which I want to do with Haskell ... can someone suggest libraries to go with .. I have never done scraping before .. I am familiar with Haskell so other languages are not a choice for me
03:40:36 <lambdaGrp> https://hackage.haskell.org/package/scalpel
03:42:07 <hari90> lambdaGrp: will scalpel is all I need or I need something else
03:44:35 <hari90> I have a scraping job which I want to do with Haskell ... can someone suggest libraries to go with .. I have never done scraping before .. I am familiar with Haskell so other languages are not a choice for me
03:45:05 <f-a> hari90: did you read lambdaGrp message?
03:45:14 <f-a> it was a suggestion for you, I believe
03:45:18 <hari90> f-a: yes
03:46:19 <hari90> f-a: but didn't get the counter ans from lambdaGrp 
03:46:46 <f-a> oh sorry missed that message
03:47:18 <hari90> f-a: its ok... 
03:47:29 <f-a> hari90: https://hackage.haskell.org/package/scalpel-0.5.1/docs/Text-HTML-Scalpel.html the module itself is pretty compact, check it out and see if it has everything you need
03:48:51 <lambdaGrp> there are also some examples on the github
03:48:52 <hari90> f-a: I read about selenium driver at some place is it required to do scraping with Haskell ... I also have to take account of sessions
03:52:47 <f-a> hari90: sorry can't help you there
03:54:28 <lambdaGrp> yeah, it's hard to give specific answers to generic questions
03:55:31 <hari90> ok let me share something which I am required to do ... can you guys suggest me then...
03:58:17 <hari90> please see this ....http://lpaste.net/356908
04:02:55 <hari90> is that can be considered specific...
04:06:32 <hari90> is someone with me here ...
04:07:19 <f-a> hari90: if someone reads it and has something meaningful to say, they will chime in
04:08:30 <lambdaGrp> if you are required to use selenium, you can check that: https://hackage.haskell.org/package/webdriver
04:09:37 <hari90> i have this work http://lpaste.net/356908 can someone guide me or give advice how to proceed for it.
04:09:51 <lambdaGrp> lol, I don't think I could be more constructive
04:10:18 <lambdaGrp> Im' here to try to help, not to do consulting job
04:10:28 <f-a> hari90: if it is for a job, consider subcontracting, if it is for uni, consider taking it next semester
04:11:59 <hari90> lambdaGrp: sorry I sent this msg earlier ...but due to net connectivity issue it came now
04:13:44 <hari90> f-a: hmm well I am a student and a Haskell lover ..this thing I have taken as a freelance work
04:13:50 <t7> what do i call the implication symbol in lambda cal
04:13:59 <t7> oh wait they use dot, do they not?
04:18:36 <lambdaGrp> an arrow?
04:19:44 * hackagebot med-module 0.1 – Parse song module files from Amiga MED and OctaMED – https://hackage.haskell.org/package/med-module
04:22:34 <Cale> t7: I'm not sure which thing in particular you're referring to
04:22:48 <t7> ->
04:24:21 <nshepperd_> Typed lambda calculi use -> for function types
04:26:19 <nshepperd_> The syntax of actual lambda abstraction uses a dot. Because it's a quantifier
04:27:20 <Cale> Yeah, there's nothing significant in particular about the fact that it's a dot in λx.e -- it's just a piece of punctuation to offset the variable from the expression which is the body of the lambda
04:27:45 <nshepperd_> Neither of those is really an "implication symbol" so I'm not sure which one you mean
04:28:06 <Cale> Well, it's possible to regard the function type constructor as an implication symbol
04:28:17 <Cale> It very much behaves the same way :)
04:29:23 <Cale> In logic, if we want to prove that A -> B, we start by assuming A, and try to construct a proof of B from there. Then if we're successful, natural deduction lets us conclude A -> B.
04:29:40 <lambdaGrp> sure
04:30:03 <nshepperd_> Yes, it's like an implication
04:30:06 <Cale> In lambda calculus, if we want to construct a function of type A -> B, we start by introducing a variable x of type A, and try to construct an expression e of type B using it. Then if we're successful, (λx.e) is the function of type A -> B
04:30:55 <Cale> In logic, if we have both A -> B and we have A, then we may infer B. In lambda calculus, if we have both f: A -> B, and x: A, then we can obtain f x: B
04:31:25 <Cale> Lambda calculi can then be seen as a sort of elaboration of logics, where terms encode something about how you came to prove each statement.
04:35:53 <lambdaGrp> so a point is an arrow, it depends on the point of view
04:39:43 <AWizzArd> I am looking at the Monad implementation of Maybe: http://hackage.haskell.org/package/base-4.9.1.0/docs/src/GHC.Base.html#line-665   – where is return?
04:42:13 <Logio> AWizzArd: pure = Just in the Applicative instance
04:42:57 <Logio> return is defined as pure by default
04:47:07 * hackagebot ekg-elasticsearch 0.3.1.0 – Push metrics to elasticsearch – https://hackage.haskell.org/package/ekg-elasticsearch
04:52:12 * hackagebot stack-bump 0.7.1.0 – Dead simple version bumping for hpack packages – https://hackage.haskell.org/package/stack-bump
04:52:12 * hackagebot ekg-elasticsearch 0.3.1.1 – Push metrics to elasticsearch – https://hackage.haskell.org/package/ekg-elasticsearch
05:10:34 <AWizzArd> Logio: okay I see this now: http://hackage.haskell.org/package/base-4.9.1.0/docs/src/GHC.Base.html#Monad
05:11:55 <AWizzArd> Logio: This was not in Learn You A Haskell, so I wasn’t aware of it until now. Back then Monads didn’t inherit from Applicative.
05:19:28 <TRManderson> Anyone here tried to generate Haskell bindings to a C lib by parsing a C header?
05:19:51 <TRManderson> Struggling in several ways - getting comfortable with parsing C, getting Cabal/stack to build stuff via Setup.hs
05:21:21 <peddie> TRManderson: check out c2hs perhaps
05:21:22 <srb> Is there an easy way to get Cabal to only use llvm if it is installed?
05:22:25 <TRManderson> I started checking out c2hs, but apparently it doesn't support enum define still? and it hasn't for like 10 years?
05:23:35 <peddie> I haven't used it for a while, but it might make sense to use it to generate almost all you need and just fill in a bit by hand?
05:26:28 <srb> anyone?
05:26:42 <peddie> srb: what does it mean for Cabal to use llvm?
05:27:11 <srb> peddie: the equivalent of `ghc-options: -fllvm`
05:27:33 <peddie> oh, I see what you mean.  is this the kind of thing you can do using a custom Setup.hs?
05:36:29 <kuribas> Does coerce work with Data.Vector?
05:44:51 <ocramz> dmwit I followed your advice of decoupling parsing and IO with an ADT + interpreter. Then it's just a matter of `traverse`ing the parsed data with the interpreter. Beautiful stuff
05:46:22 <cocreature> kuribas: I think so but just try it out. ghc will yell at you if it doesn’t work
05:47:17 <cocreature> hm at least for boxed vectors, it seems like it’s not safe for unboxed vectors
05:51:11 <kuribas> yes, and making an Unbox instance for a newtype isn't trivial either.
05:52:13 <cocreature> huh? you should be able to just reuse the instance of whatever type you’re wrapping
05:52:43 <kuribas> that doesn't work for Vector
05:54:49 <merijn> TRManderson: If you #define enums have a look at CApiFFI
05:54:58 <kuribas> It has something to do with the typefamily magic that I don't really understand...
05:56:02 <lambdaGrp> have you read: https://stackoverflow.com/questions/39522041/how-to-coerce-functors-applied-to-coercible-arguments ?
05:57:08 <kuribas> lambdaGrp: I see nothing about Vector there...
05:57:42 <lambdaGrp> oh, sure!
05:58:27 <kuribas> but having to produce 20 lines of boilerplate just to get Unbox for the newtype isn't very elegant.
05:59:43 <cocreature> sure it’s not elegant but what I was trying to say is that it’s not hard
05:59:53 <cocreature> it’s just a bunch of wrapping and unwrapping
06:00:02 <cocreature> maybe there is some th for that somewhere
06:01:11 <kuribas> maybe this: https://hackage.haskell.org/package/vector-th-unbox
06:06:31 <boxscape> is there a way to tell ghci to only keep one copy of each command in its history? It's a bit annoying if I have to keep going up through 10 copies of ":r" because I reloaded a file a bunch of times
06:07:00 <Axman6> boxscape: I don't knoe but if you do find out I'd love to know
06:07:19 <boxscape> If I do I'll let you know
06:09:58 <Cale> Well, there's certainly a way, the question is, does it involve recompiling ghci ;)
06:13:46 <boxscape> right, fair point. It would also be possible to write a program aside from ghci that goes through the history each time it's changed, but that seems a bit tedious
06:14:26 <lambdaGrp> here: http://trac.haskell.org/haskeline/wiki/UserPrefs !
06:14:34 <lambdaGrp> see historyDuplicates
06:14:48 <boxscape> nice, thank you
06:14:52 <boxscape> ^ Axman6 
06:16:33 <Axman6> \o/
06:18:39 <boxscape> And a vi edit mode, too. I wish I'd known about this years ago :D
06:21:21 <lambdaGrp> the custom key bindings link is worth it too!
06:22:01 <boxscape> oh, didn't even notice that. Certainly looks promising
06:23:24 <Unode> there's also the haskell-ipython kernel. A bit more effort to setup but you get most of the editing power from the ipython shell.
06:24:02 <Unode> https://github.com/gibiansky/IHaskell
06:25:17 <boxscape> I actually found out about it earlier today, I was wondering how well that would work with stack projects
06:27:02 <cocreature> stack just launches ghci so it should work just as well
06:27:37 <boxscape> that's good to hear. Might take a look then
06:28:42 <boxscape> Had some trouble for a while getting ghc-mod to work with stack projects, which is why I'm worried about that now (although that turned out to have an easy fix)
06:35:35 <Unode> boxscape: I haven't tried to install it, only used the docker container a couple of times. https://hub.docker.com/r/gregweber/ihaskell/ . There's other containers with same name so YMMV.
06:36:23 <boxscape> I see
06:57:09 <tabaqui> I have a problem with Test.HUnit module
06:57:29 <tabaqui> all defeault assertions like <expected> ?@= <result>
06:57:51 <tabaqui> all of them use (==) for comparison
06:58:20 <tabaqui> but trees and heaps can be "equal" if they have the same content in different order
06:58:39 <tabaqui> I cannot override imported instances, right?
06:58:55 <tabaqui> another solution is to define my own TestEq class
06:59:36 <tabaqui> but I should implement my own `equal` functions for all basic types used in my tests
06:59:58 <kuribas``> tabaqui: use a newtype?
07:00:41 <kuribas``> tabaqui: and override Eq
07:00:55 <tabaqui> kuribas``: I cannot pass newtypes into function, that I'm testing
07:01:37 <kuribas``> why not?
07:02:06 <tabaqui> hmm, extract tree from the newtyped tree, and pass it?
07:02:16 <tabaqui> I'll try
07:02:17 <saep> tabaqui: You only need to wrap the result.
07:02:29 <tabaqui> saep: yeah, I mean it
07:02:47 <tabaqui> fine, thanks
07:04:42 <tabaqui> Greenspun's Tenth Rule
07:04:45 <tabaqui> I was close to it
07:05:16 <kuribas``> every language eventually becomes LISP?
07:05:25 <tabaqui> no exceptions
07:05:58 <Athas> Not if your language is sufficiently weak!
07:06:13 <tabaqui> like hq9+ ?
07:06:29 <Athas> HQ9+ will eventually becomes HQ9+L.
07:06:34 <Athas> The L instruction starts a Lisp REPL.
07:06:37 <Athas> Greenspun!
07:07:31 <fendor> is there a way to improve the performance of the repa stencil library when using a kernel that is not known during compile time?
07:08:34 <adamCS> Hello all!  Can anyone explain what a ".\" at the end of a function name means in a profiling report?  I often see the same function, but sometimes with the usual name and then, sometimes, deeper in the call stack with a ".\" at the end.  
07:09:35 <Athas> adamCS: it's a lambda inside the function.
07:09:54 <adamCS> Athas:  Thanks!  
07:09:57 <otini> Has anyone else experienced "stack build" being super slow because of preprocessing and linking times? (Compilation is fine.)
07:10:06 <otini> (possibly Nix-related)
07:10:31 <adamCS> Athas: And now that totally makes sense.  And is super useful.
07:11:07 <Athas> You're welcome!  Indeed it is.  I'm actually not sure what it looks like when you have multiple lambdas.
07:11:23 <Athas> I think nested lambdas become .\.\.
07:11:46 <Athas> otini: yes, linking in particular is extremely slow for large-ish programs.
07:12:15 <Athas> My project has ten executables.  I feel the pain.
07:12:39 <adamCS> Athas:  Right.  But I could just insert a cost center if I needed it to be explicit.  In my case I usually just see one, or only one that seems to matter. 
07:12:49 <otini> Athas: weird, it's much faster on another machine which is not much more performant.
07:13:19 <otini> Here it's about 30 s minimum for a not-so-big executable.
07:13:40 <otini> Also do you know what the "preprocessing library/executable is for?"
07:13:50 <Athas> No idea.
07:13:54 <otini> (misplaced double quote*)
07:13:58 <Athas> Collecting metadata?
07:14:05 <Athas> Information on what's changed and what to recompile, maybe?
07:14:40 <otini> Well it's quite long too.
07:17:39 <adamCS> Monad stack question:  I have an app which does a monte-carlo sim.  Each path runs in a monad transformer stack.  It was a StateT s (ReaderT e (Either err a)) stack which had all sorts of magnifying and zooming happening to match up the various smaller computations that went into it.  I re-wrote to use, basically, a StateT (s,e) (Either err a) stack and used HasX and ReadsX type classes everywhere instead of all the zooming
07:17:39 <adamCS>  and magnifying. 
07:17:48 <adamCS> Now it's slower
07:18:30 <adamCS> And I'm not sure why though from a quick look at the profiling, bind seems to be a bigger % of runtime in the slower version
07:18:52 <adamCS> is bind in StateT slower than bind in ReaderT?  
07:19:09 <adamCS> I'm guessing that's an extremely imprecise question...
07:20:14 <kuribas> you compile with optimizations?
07:20:25 <adamCS> Yes
07:20:50 <adamCS> -O2 -funbox-small-strict-fields
07:22:40 <kuribas> perhaps try with strict state?
07:23:24 <adamCS> it already is. In both versions.
07:24:32 <adamCS> But yeah.  I wonder if something in the re-writing created a memory issue.  The new version is using more memory though neither spends a significant % of time doing GC.
07:25:03 <adamCS> more memory in the sense of "total alloc"
07:32:31 <alexbiehl> adamCS now you are strict in your tuple but not in s anymore, maybe you now allocate thunks for s where you evaluated before? 
07:33:36 <adamCS> alexbiehl:  huh.  That's a good point.  I hadn't thought about the strictness of that top-level state pice.  I'll try making those strict.  Thanks!
07:38:38 <adamCS> hmm.  Didn't seem to change anything.  I guess I'll dive into the memory piece and see if that helps...
07:46:03 <boxscape> Why does "data A = B; |C; |D" not work? Does the braces+semicolon syntax simply not work with datatype definitions?
07:46:13 <boxscape> (it says parse error on "|")
07:47:32 <boxscape> actually, on second thought, I guess this is sort of similar to "show; 4"
07:47:38 <boxscape> which I wouldn't expect to work
07:48:06 <barrucadu> The braces-and-semicolons syntax is an alternative for indentation
07:48:10 <Cale> boxscape: You don't need the semicolons
07:48:26 <Cale> (rather, they're not allowed there)
07:48:44 <boxscape> Cale: I know I don't need them, I was just wondering if I could convert multiple line inputs into single line inputs for ghci automatically
07:49:08 <boxscape> but yeah, it makes sense that they are for indentation rather than simply for whitespace
07:49:13 <Cale> boxscape: If you want to do that, perhaps use haskell-src-exts to parse
07:49:20 <barrucadu> ghci can do multi-line inputs, start with :{ and end with :}
07:49:23 <boxscape> Cale: I will look into that, thanks
07:49:28 <Cale> (and to print out the Haskell again)
07:49:45 <boxscape> barrucadu: I know, but I'm trying to interface with ghcid, and haven't been able to really make multiline input work with that, but I might yet be able to
07:50:38 <Cale> You can use the PPNoLayout style to prettyprint, and it'll put everything on a single line
07:50:49 <boxscape> oh, nice
07:55:28 <boxscape> actually, I just managed to make multiline input work with ghcid without converting it, I just forgot the \n after :{
08:07:43 <fendor> hey, what would be a good library for a high performance nbody simulation?
08:14:14 <BernhardPosselt> could you replace pattern matching with polymorphism in haskell?
08:14:28 <BernhardPosselt> kinda wondering what that would look like
08:14:41 <BernhardPosselt> similar to rust maybe?
08:15:23 <fendor> well, haskell's approach are type classes
08:15:44 <fendor> it has mostly parametric polymorphism
08:15:49 <BernhardPosselt> ah right
08:15:59 <fendor> so, I'd say, it is similar to rust
08:16:06 <fendor> since rust borrowed a lot of concepts form haskell
08:17:33 <dolio> What "polymorphism"?
08:18:00 <BernhardPosselt> dolio: instead of matching on types you'd define a function for a type that would be used in that case
08:18:34 <BernhardPosselt> you should probably try to avoid case ... of statements
08:18:40 <dolio> Okay, what "pattern matching" are you talking about?
08:18:52 <dolio> You don't match on types in a case statement.
08:19:18 <dolio> You match on constructors.
08:19:52 <BernhardPosselt> right
08:20:22 <BernhardPosselt> iirc something like case result of (Just value) -> value
08:20:50 <fendor> what's the exact question here?
08:21:14 <fendor> > fromJust (Just 4)
08:21:16 <lambdabot>  4
08:21:22 <fendor> > fromJust (Nothing)
08:21:24 <lambdabot>  *Exception: Maybe.fromJust: Nothing
08:21:26 <BernhardPosselt> question is basically a general guideline
08:21:32 <shapr> Is there a recommended graphql client in Haskell?
08:21:41 <BernhardPosselt> when to avoid case of statements and go for typeclasses
08:22:09 <mpickering> Has anyone recently used ghcjsHEAD on nix?  
08:22:13 <dolio> Those two things are fairly different.
08:22:27 <dolio> Type classes _are_ like matching on types.
08:22:41 <dolio> And not constructors of a particular type.
08:23:38 <BernhardPosselt> easy example would be basically map vs case of for Maybes
08:23:49 <dolio> If you want to replace case statements by functions in a general way, you can view case statements as functions T -> U, where T is the type of the thing in between the 'case' and 'of', and U is the type of the branches.
08:24:09 <dolio> Then the constructors organize T into a sum: T = A + B + C + ...
08:24:22 <BernhardPosselt> you could do: case value of (Just value) -> Just (f value)     None -> None
08:24:48 <dolio> And a function from a sum is equivalent to a product of functions: (A + B + C + ... -> U) = (A -> U) * (B -> U) * (C -> U) * ...
08:25:36 <dolio> And you can represent a sum as a value that takes a product of functions and calls one of those functions.
08:26:56 <BernhardPosselt> sum/product in a category theory context?
08:27:04 <dolio> Sure.
08:30:40 <orion> @pl test
08:30:40 <lambdabot> test
08:31:51 <lambdamu_> mpickering: Not really recently but what's wrong?
08:32:13 <mpickering> cabal run fails to find the node executable 
08:32:31 <mpickering> "/nix/store/gzh9cahbq4h921xdilgn9r7abala75n6-ghcjs-0.2.020170323/bin/ghcjs-run-0.2.1-8.0.2.jsexe/node: openFile: does not exist (No such file or directory)"
08:33:22 <lambdamu_> mpickering: Are you building a package, using nix-shell with a package or using the compiler raw?
08:34:40 <mpickering> I can using nix-shell to build my dependencies with "ghcjsHEAD.ghcWithPackages" 
08:34:50 <mpickering> then using cabal directly with "configure --ghcjs"
08:36:49 <lambdamu_> mpickering: Hm I don't know what's wrong here from the top of my head
08:47:23 <lambdamu_> mpickering: It has something to do with this probably: https://github.com/ghcjs/ghcjs/blob/ghc-8.0/src-bin/Run.hs
08:48:51 <shapr> @check \x y (z :: Float) -> (x * y) * z == x * (y * z)
08:48:51 <lambdabot>  <unknown>.hs:1:19:ScopedTypeVariables language extension is not enabled. Ple...
08:48:59 <shapr> @check \x y z :: Float -> (x * y) * z == x * (y * z)
08:49:00 <lambdabot>  <unknown>.hs:1:8:Parse error: ::
08:49:13 <shapr> what am I doing wrong? How do I tell it to use Float for x y z?
08:49:20 <mpickering> lambdamu_: thanks!
08:49:39 <glguy> @check \x y z -> (x * y) * z == x * (y * z :: Float)
08:49:41 <lambdabot>  *** Failed! Falsifiable (after 2 tests and 2 shrinks):
08:49:41 <lambdabot>  51.871258 0.6179222 1.3466706
08:49:47 <shapr> ah, thanks!
08:53:29 * hackagebot pid1 0.1.2.0 – Do signal handling and orphan reaping for Unix PID1 init processes – https://hackage.haskell.org/package/pid1
08:56:03 <sproingie> @check \x y z -> abs ((x * y) * z) - (x * (y * z :: Float)) < 1.0
08:56:06 <lambdabot>  *** Failed! Falsifiable (after 3 tests and 2 shrinks):
08:56:06 <lambdabot>  -3.1709976 1.8014442 1.4969523
08:56:25 <sproingie> huh.  what am i getting wrong
08:58:44 <glguy> @check \x y z -> abs ((x * y) * z - x * (y * z :: Float)) < 1.0
08:58:47 <lambdabot>  *** Failed! Falsifiable (after 77 tests and 6 shrinks):
08:58:47 <lambdabot>  -1426.901 -81.16541 -83.25473
08:59:28 <glguy> > ((-1426.901) * (-81.16541)) * (-83.25473)
08:59:30 <lambdabot>  -9642146.945781836
08:59:35 <glguy> > (-1426.901) * ((-81.16541) * (-83.25473))
08:59:38 <lambdabot>  -9642146.945781836
09:00:36 <glguy> > (-1426.901) * ((-81.16541) * (-83.25473)) :: Float
09:00:39 <lambdabot>  -9642148.0
09:00:42 <glguy> > ((-1426.901) * (-81.16541)) * (-83.25473) :: Float
09:00:45 <lambdabot>  -9642147.0
09:01:11 <sproingie> something rotten going on
09:01:17 <glguy> Looks right to me
09:01:22 <glguy> Float's just not as precise
09:01:48 <sproingie> imprecision is one thing, but losing the entire fractional part?
09:02:27 <sproingie> or maybe it just coincidentally rounded that way
09:03:11 <glguy> > -9642148.5 :: Float
09:03:14 <lambdabot>  -9642148.0
09:03:21 <dolio> > logBase 10 (2^23)
09:03:24 <lambdabot>  6.923689900271567
09:03:28 <dolio> 7 digits.
09:03:44 <sproingie> > \x y z -> (abs ((x * y) * z) - (x * (y * z :: Double))) $ -3.1709976 1.8014442 1.4969523
09:03:46 <lambdabot>  error:
09:03:46 <lambdabot>      • Couldn't match expected type ‘t2 -> t’ with actual type ‘Double’
09:03:46 <lambdabot>      • The first argument of ($) takes one argument,
09:03:57 <sproingie> oh FML
09:04:23 <dolio> > 23 / logBase 2 10
09:04:26 <lambdabot>  6.923689900271567
09:13:52 <sproingie> oh JFC, mysterious type errors because of haskell's retarded negative literals once again
09:15:29 <sproingie> > (\x y z -> (abs ((x * y) * z) - (x * (y * z :: Double)))) (-3.1709976) 1.8014442 1.4969523
09:15:31 <lambdabot>  17.102306492195964
09:15:51 <sproingie> parenthesis are like violence.  if it doesn't fix your problem, you're not using enough
09:21:03 <sproingie> > (\x y z -> (abs $ ((x * y) * z) - (x * (y * z :: Double)))) (-3.1709976) 1.8014442 1.4969523
09:21:06 <lambdabot>  0.0
09:21:11 <sproingie> and the world is sane again
09:21:25 <tabaqui> abs (x - x)
09:21:27 <tabaqui> ofc
09:21:39 <kuribas> > (\x y z -> ((-) (abs ((*) ((*) x y) z)) ((*) x ((*) y z :: Double))))
09:21:41 <lambdabot>  <Double -> Double -> Double -> Double>
09:21:54 <sproingie> ?
09:22:21 <sproingie> a Show instance, how about that
09:22:36 <tabaqui> > \x -> x
09:22:39 <lambdabot>  error:
09:22:39 <lambdabot>      • No instance for (Typeable t0)
09:22:39 <lambdabot>          arising from a use of ‘show_M666968600002294619617166’
09:22:48 <kuribas> > (\x y z -> ((-) (abs ((*) ((*) x y) z)) ((*) x ((*) y z :: Double)))) (-3.1709976) 1.8014442 1.4969523
09:22:50 <lambdabot>  17.102306492195964
09:23:17 <sproingie> forgot the parens or $ for abs
09:23:56 <kuribas> infix is for noobs
09:24:27 <kuribas> > (\x y z -> (abs ((-) ((*) ((*) x y) z) ((*) x ((*) y z :: Double))))) (-3.1709976) 1.8014442 1.4969523
09:24:29 <lambdabot>  0.0
09:25:13 <tabaqui> I think you should write all this stuff into #lisp
09:25:36 <sproingie> be much cleaner looking if it were in forth :)
09:25:44 <ggVGc> C++ m8
09:25:45 <kuribas> from now on I'll write all my haskell code parenthesised and infix :)
09:26:07 <ggVGc> I noticed the more haskell I wrote, the more parens I used
09:26:29 <sproingie> infix expressions would be handy there.  foo `withinTolerance 0.001` bar
09:26:53 <sproingie> (or just define it with a let/where i guess)
09:27:23 <ggVGc> just realised I haven't actually writen any haskell in almos a year
09:27:27 <ggVGc> wonder if I still can
09:27:35 <ggVGc> wasn't very good at it when I stopped
09:27:47 <sproingie> havent written any "production" haskell in like five years.  and ditto.
09:28:02 <ggVGc> so you're one of the 2 people that has written production haskell?
09:28:07 <ggVGc> guess you must have been working for facebook
09:28:22 <sproingie> production as in "used it at work for a utility that i rewrote in python"
09:28:37 <tabaqui> I get money for my haskell code
09:28:41 <ggVGc> "yeah boss, this is python, trust me. Check the indentation"
09:28:44 <sproingie> big graph traversal thing using lists, space leaked all the hell over the place
09:28:54 <tabaqui> but I'm alone in my team
09:29:43 <kuribas> I'll get money for my prototype written in haskell...
09:29:59 <sproingie> i got money to solve problems, they didn't care how
09:30:06 <kuribas> though it looks like C++ with Vector all over the place
09:30:37 <ggVGc> I once started writing a haskell program, then I started abstracting
09:30:43 <ggVGc> and then it's now
09:30:53 <kuribas> sproingie: doesn't matter if you have room to spare
09:30:56 <sproingie> yah i started to look at doing it with a proper array type, but i just didn't know enough haskell, plus i needed to slap a web UI on it and i was totally at sea there with haskell
09:31:45 <tabaqui> arrays make me hurt
09:32:09 <sproingie> that problem was closer to 10 years ago come to think
09:32:10 <tabaqui> but I don't much care about performance
09:32:22 <sproingie> very little in the way of web stuff for haskell then
09:32:32 <tabaqui> so hash- and intmaps are fine enough for me
09:33:32 * hackagebot th-data-compat 0.0.2.3 – Compatibility for data definition template of TH – https://hackage.haskell.org/package/th-data-compat
09:33:33 <kuribas> tabaqui: they usually are fast enough
09:34:25 <tabaqui> kuribas: but you cannot win ASM without arrays
09:34:33 <sproingie> jobs i'm looking at these days are PHP. once again, FML.
09:34:56 <sproingie> taking a hard look at idris's PHP backend
09:35:01 <tabaqui> *acm
09:36:03 <kuribas> what's an acm?
09:36:22 <sproingie> what's aleppo? </derp>
09:36:54 <tabaqui> kuribas: https://icpc.baylor.edu/
09:37:02 * sproingie is still one big unclosed <derp> tag today
09:37:04 <tabaqui> international programming contest
09:37:29 <monochrom> The full acronym is ACM ICPC, not merely ACM.
09:37:30 <kuribas> that's a real ugly website
09:37:54 <tabaqui> dunno, I think they made it before I went to school
09:38:01 <monochrom> But meh, people speak like "ANSI" stands for colour codes for terminals, etcc.
09:38:35 <monochrom> And another group of people speak like "ANSI" stands for a standard for C.
09:38:46 <monochrom> And one more group thinks it's Pascal instead.
09:38:59 <sproingie> i think of ACM as that place where i can't read papers because $employer isn't paying
09:39:04 <monochrom> which brings us to ECMA...
09:39:46 <tabaqui> can you win it?
09:40:07 <sproingie> "... Later still, in an effort to cash in on the popularity of skin diseases the language is renamed ECMAScript."
09:40:39 <monochrom> Actually, what's aleppo?
09:40:58 <sproingie> tasty pepper
09:41:03 <tabaqui> city?
09:43:00 <monochrom> neato
09:44:03 <kuribas> monochrom: a city in syria?
10:02:50 <crobbins_> i think monochrom is working on his 2020 US presidential campaign
10:04:12 <sproingie> i'm voting for Inanimate Carbon Rod
10:06:54 <monochrom> I don't think I am eligible. Not a US citizen.
10:08:27 <crobbins_> i hear good things about inanimate carbon rod
10:13:17 <kuribas> in Rod we trust
10:19:30 <NemesisD> has anyone here used the gogol-* libraries for anything?
10:21:44 <will_> Does anyone know if the O'Reilly book on Yesod is still mostly relevant?  It's from 2012 (http://shop.oreilly.com/product/0636920023142.do)
10:23:22 <ent> at least the online version is
10:23:27 <ent> http://www.yesodweb.com/book
10:25:21 <will_> Thanks - do you know if the O'Reilly book goes into much more depth?  Working through the online version now but I quite enjoy having a dead tree version around.
10:25:46 <ent> I don't know, I've assumed that it's the same book though
10:42:06 * hackagebot propellor 4.3.3 – property-based host configuration management in haskell – https://hackage.haskell.org/package/propellor
10:45:21 <sepakorayl> hello guys, is there a monad transformer that allows for early value returns?
10:45:51 <glguy> ExceptT
10:49:18 <ertes-w> i sometimes abuse ContT for that
10:49:57 <ertes-w> :t ContT . const . pure
10:49:58 <lambdabot> Applicative m => r -> ContT r m a
10:51:01 <glguy> :t cont . const
10:51:03 <lambdabot> r -> Cont r a
10:52:14 <ertes-w> BTW, i wish transformer libraries would use RankNTypes for the pure variants instead of hard-coding Identity
10:52:37 <ertes-w> type Cont r a = forall m. (Monad m) => ContT r m a
10:53:01 <ertes-w> then (cont . const) would work for both
10:53:16 <merijn> ertes-w: You're familiar with Tekmo's mmorph?
10:53:23 <ertes-w> merijn: yeah
10:54:02 <merijn> Then I have nothing helpful to contribute :)
10:54:18 <dolio> @type const . const :: r -> Cont r a
10:54:20 <lambdabot> error:
10:54:20 <lambdabot>     • Couldn't match type ‘b1 -> b0 -> r1’ with ‘ContT r1 Identity a1’
10:54:20 <lambdabot>       Expected type: r1 -> Cont r1 a1
10:54:33 <mbw> Is there a reasonable way to narrow down a function that seems to have been inlined in the core output generated with ddump-simpl? Furthermore, how can you make it more readable, I tried "-dppr-cols=120" and it doesn't seem to change anything. Everything runs off to the right. Same problem as with the profiler output.
10:54:48 <dolio> @type cont . const :: r -> Cont r a
10:54:50 <lambdabot> r -> Cont r a
10:54:58 <ertes-w> merijn: start by explaining why you asked ;)
10:55:04 <mbw> The suppress-* options seem to work on the other hand.
10:55:30 <ertes-w> merijn: even the almighty ertes misses something from time to time, because…  uhm…  quantum mechanics
10:55:31 <merijn> ertes-w: Because mmorph lets you generalise things like Cont away from their Identity base into something more useful to you :)
10:56:12 <ertes-w> merijn: ah, sure, but that requires an mmorph dependency and an import and explicit casts and …
10:56:26 <ertes-w> it would be more useful, if libraries just did that by default
10:57:33 <merijn> ertes-w: Yes, sometimes it would be nice to replace existing libraries with what we've learned since they were written (see the discussion earlier today about Map's monoid), unfortunately, the "don't break backwards compat" crowd halts that sorta progress
10:57:49 <johnw> merijn: yes indeed
10:58:08 <sproingie> alternate preludes FTW
10:58:29 <merijn> sproingie: Alternate preludes don't solve, for instance, the wrong monoid instance in containers
10:58:50 <merijn> sproingie: Also, alternate preludes are generally unacceptable in libraries
10:59:06 <sproingie> true.  sigh.
10:59:49 <merijn> The inability to backwards incompatibly fix some things in Haskell is what makes me keep coming back to the idea of just writing my own language
10:59:50 <johnw> Coq allows "intance overrides"
11:00:28 <ertes-w> merijn: yeah, although i must say that other languages are suffering from that much more
11:00:45 <ertes-w> we can push something like the AMP and the FTP through
11:01:22 <glguy> Map's Monoid instance isn't really "wrong", Monoid is just a bit of a garbage typeclass
11:01:48 <merijn> glguy: Map's monoid *is* wrong, since it's a special case of a far nicer and more general one
11:01:50 <ertes-w> glguy: it's not wrong, but it's also not very useful
11:02:00 <merijn> (wrong in a moral sense, that is)
11:02:18 <ertes-w> glguy: about Monoid: why?
11:02:23 <glguy> It certainly has plenty of uses, just different uses the the alternatives
11:02:26 <merijn> Monoid is a lovely class
11:02:36 <sproingie> import Foo.Bar hiding (instance Baz) -- some day after I get my pony
11:02:38 <mud> What does its monoid instance do exactly? It's not just union or whatever?
11:02:46 <merijn> mud: Left biased union
11:02:56 <mud> Oh. What's wrong with that?
11:03:05 <sproingie> actually that seems kinda useful
11:03:10 <ertes-w> mud: it should be doing this:  mappend = M.unionWith (<>)
11:03:16 <merijn> mud: The nicer, more general instance would be "instance Semigroup v => Monoid (Map kv)"
11:03:37 <sproingie> left-biased ... as in it won't replace existing keys?
11:03:38 <mud> ertes-w: Oh. Hmm *ponders*
11:03:42 <merijn> sproingie: Yes
11:03:45 <sproingie> oh that's kinda borked
11:03:46 <glguy> ertes-w: garbage because it's an arbitrary operation and identity element that happen to be associative, no guarantees beyond that. for most types with an instance there's an arbitrary choice to be made as to what it does
11:03:49 <merijn> sproingie: Rather than mappending duplicate keys
11:03:58 <monochrom> My https://mail.haskell.org/pipermail/haskell-cafe/2017-May/127147.html is how you can eliminate fighting over what an instance "should do". :)
11:04:08 <glguy> it just happens the common choices are good enough and if you memorize all of the instances there are handy uses for them
11:04:28 <merijn> sproingie: You can achieve the same effect by doing mappend on "fmap First" on a map
11:04:43 <ertes-w> glguy: what would you propose?  Monoid is quite useful, and for many types there is a canonical one like for the various Builder types
11:04:46 <merijn> sproingie: Or, "coerce" if you dislike the additional work of fmap
11:04:59 <glguy> ertes-w: there isn't even a canonical choice for the builders
11:05:04 <dolio> So it makes your code really shitty. Great.
11:05:18 <mbw> Core, anyone? :(
11:05:24 <ertes-w> glguy: hmm?
11:05:25 <glguy> there's a common choice, but there are alternatives, too
11:05:25 <merijn> dolio: What does?
11:05:49 <ertes-w> glguy: well, it reflects the main use case of Builder
11:05:54 <dolio> The 'more general' instance where you have to wrap and unwrap your map values all over the place.
11:05:56 <glguy> ertes-w: The instance for builders could just as easily be flipped or some kind of biased operation, too
11:05:58 <glguy> it's arbitrary
11:06:18 <merijn> dolio: It doesn't require wrapping all over the place, only if you want the current behaviour
11:06:20 <dolio> For the same behavior as today.
11:06:33 <merijn> dolio: Except, in previous discussion, no one ver uses the current behaviour
11:06:37 <dolio> Yeah, so you're pessimizing all those use cases.
11:06:39 <ertes-w> glguy: i get your point, but i think the utility of Monoid is undeniable…  if you're suggesting not to use Monoid, what would be the alternative?
11:06:44 <glguy> merijn: Oh, it's not true that no one uses the current behavior
11:06:53 <merijn> glguy: I've so far met one, Athas
11:07:07 <sproingie> i don't think it's Monoid so much as unwanted instances of it popping up
11:07:11 <merijn> glguy: I have met 12 people who have repeatedly implemented the monoid I describe
11:07:25 <glguy> merijn: wow, that's pretty awesome that you documented the 12 people
11:07:34 <glguy> but no, it's not just athas who has used this instance
11:08:04 <merijn> Anyway, I should get back to writing >.>
11:08:19 <sproingie> me, i'm still wondering why we have to have a separate map and fmap
11:08:34 <dolio> Because students.
11:08:40 <ertes-w> because history
11:08:51 <monochrom> because evolution
11:09:01 <ertes-w> since the FTP students are kind of a bad excuse =)
11:09:05 <ertes-w> :t length
11:09:07 <lambdabot> Foldable t => t a -> Int
11:10:04 <dolio> Well, no one asked for an argument. They asked why something is the way it is.
11:10:24 <srhb> Blood for the blood good!
11:10:29 <srhb> er, god.
11:10:34 <sproingie> moral of the story: avoid success
11:10:52 <dolio> Now the argument is that changing it is way more effor than it's worth.
11:10:58 <sproingie> "I don't believe in Blood God, I believe in Blood Good" :)
11:11:09 <ertes-w> to be fair at this point i'm convinced haskell can have its success without making everybody sad
11:11:33 <shapr> me too
11:11:36 <sproingie> as language warts go, it's hardly a show-stopper
11:11:53 <dolio> Yeah, it's already too successful.
11:12:05 <dolio> So more wouldn't be that bad.
11:13:04 <ertes-w> we're still talking about CPS, coalgebras and natural transformations in #haskell
11:13:05 <ertes-w> we're fine
11:13:56 <ertes-w> meanwhile #python keeps telling me to just do what everybody does =)
11:14:43 <dolio> The point is that the existing level of success is why you have the afforementioned, "we can't fix things."
11:15:58 <shapr> Meh, I say fix things and live with the fallout
11:16:19 <sproingie> yeah me and #python parted ways a while back.  tho the tone has gotten a bit less dogmatic these last few.
11:16:22 <shapr> Haskell is a 'research language' and that's enough of an excuse to keep making breaking improvements.
11:16:27 <dolio> Yeah, well, the success is why it's not up to just you. :)
11:16:46 <ertes-w> i see why there is disagreement on whether the Monoid instance for Map should be fixed…  the trouble is that some bugs introduced by the change wouldn't be caught by the type system
11:16:46 <shapr> Yeah, I left #python around the same time #haskell got started
11:17:04 <shapr> ertes-w: quickcheck tests?
11:17:27 <sproingie> anyway ghc has the "three release rule" for breaking stuff.  only thing relatively set in stone would seem to be the standard itself.
11:18:40 <monochrom> A successful commercial company can just declare "discontinued" at a whim and be backward incompatible and do things the new way (for better or worse). The point is the more successful they are, the more they actually do this---and become even more successful in the future.
11:19:00 <monochrom> So now why are free software people so afraid of doing the same.
11:19:02 <dolio> Well, the three release rule is a limit on how fast you are able to break stuff. You still have to get people to agree to break stuff in the first place. :)
11:19:14 <geekosaur> monochrom, they're not. see: golang
11:19:28 <sproingie> commercial company cannot just EOL stuff on a whim
11:19:38 <sproingie> and for some customers, there's EOL and there's EOL
11:19:44 <dolio> They can't?
11:19:45 <geekosaur> or the linux kernel which has an annoying tendency to force xmobar updates to match whatever new interface they came up with for system info
11:19:45 <sproingie> (i'm all about TLAs today)
11:20:04 <geekosaur> sproingie, sometimes they can, sometimes they can't
11:20:06 <ertes-w> sproingie: they can and do, more often than not as a business decision more than a technological one
11:20:36 <sproingie> commercial software that's an *app* is easier to rev, you just declare a new API and say "live with it"
11:20:37 <geekosaur> ertes-w, it's possible for customer contracts to force freezes on things, although that may be handled by forking the product
11:21:15 <geekosaur> $BIGCORP can and will demand that an API be frozen for X years where X can be > 20
11:21:21 <sproingie> when your biggest customer refuses to upgrade, you can't just tell them you're not supporting them anymore
11:22:03 <geekosaur> this will be specified in the purchase contract, the company could reject it but the customer will likely walk. and customers who do this tend to be the sort you do not want to lose.
11:22:30 <ertes-w> geekosaur: forking is the usual way to do it, so you can sell new services as well as migrations…  holding a customer's business hostage is rather something that crypto malware does
11:22:31 <sproingie> so you might keep the old version alive and keep going on the new version.  the analogous thing in free software would be a fork.
11:22:51 <ertes-w> that's how major version numbers are born in the commercial world
11:22:52 <sproingie> holding business hostage is also what customers do
11:23:11 <geekosaur> ertes-w, in a business context that depends on being able to support all forks
11:23:30 <ertes-w> geekosaur: nah, just follow microsoft's lead
11:23:50 <sproingie> (actually microsoft was the customer who wouldn't upgrade)
11:23:57 <monochrom> haha
11:23:59 <ertes-w> heh
11:24:07 <geekosaur> microsoft's lead here is not making necessary changes until windows 7 and even then having to get sign-off from enterprise customers who complained about it
11:24:50 <ertes-w> imagine they would still have to support windows 95
11:24:52 <dolio> They EOL stuff all the time, too, though.
11:25:04 <dolio> Mainly stuff they don't sell directly, though, I guess.
11:25:07 <geekosaur> ertes-w, they had to support the APIs
11:25:41 <ertes-w> yeah, i know =/
11:25:48 <geekosaur> windows 7 was a massive rewrite (and incomplete, win8 had the rest), all the cruft they'd accumulated from win95 on that they could finally get rid of
11:25:59 <ertes-w> that's why they have lovely identifiers such as MsgWaitForMultipleObjectsEx
11:26:07 <geekosaur> (then they wrecked it with win8's new UI, but I digress)
11:26:10 <ertes-w> (the linux version of that is called 'poll')
11:26:27 <sproingie> *Ex suffix on MS API's is like real_* prefixes on PHP APIs
11:26:36 <ertes-w> hahaha yeah
11:26:43 <sproingie> i like to think of win10 as what win8's UI should have been
11:27:26 <sproingie> room to improve, but still a step up
11:28:04 <geekosaur> they also had to keep supporting windows 3.1 APIs, and in fact still do --- which is why win7+ ship with a cut-down HyperV that in effect can boot win3.1 for ancient apps
11:28:23 <geekosaur> (which they then reused for WOW32 to run 32-bit stuff on 64-bit Windows)
11:28:24 <sproingie> aren't IOCPs the superior thing to WFMO anyway?
11:29:16 <monochrom> Oh w00t I can haz Win3.1 apps on Windows 10?!
11:29:27 <armlesshobo> but, why would you?
11:29:31 <monochrom> I still have an ancient Mathematica For Student for Win3.1
11:29:34 <armlesshobo> nastalgic for games?
11:29:35 <sproingie> inasmuch as it more or less runs in a DosBox, yes
11:29:41 <armlesshobo> nostalgic*
11:29:53 <monochrom> Games would be DOS rather than Win3.1
11:30:09 <geekosaur> Win3.1 was on top of DOS
11:30:21 <sproingie> yah but for games you always exited out to DOS
11:30:32 <geekosaur> WOW does three things: DOS/win3.1 box, WinXP compat, 32 bit on 64 bit Windows
11:30:53 <sproingie> i so "fondly" remember dealing with IRQ conflicts
11:31:05 <geekosaur> right, the dosbox does that in reverse, if you run an EXE with a Win3.1 header it spawns win3.1 emulation
11:31:20 <shapr> sproingie: just swap the right jumpers, it'll probably be fine
11:31:20 <monochrom> There were no WIn3.1 games in practice. Apart from what came with Win3.1 itself, Solitaire and Reversi etc.
11:31:48 <sproingie> there were a few, using WinG
11:31:54 <monochrom> "Windows games" was not a thing until Win95 at the very least.
11:32:11 <wizwizwizwiz> so what impact will linear types have on performance such as GC pauses, etc?
11:32:35 <sproingie> should eliminate them entirely, at least for those types
11:32:48 <wizwizwizwiz> i don't understand what that means
11:32:59 <wizwizwizwiz> because the entire application pauses for some of the GC, no?
11:33:02 <sproingie> you can overwrite a linear type in place
11:33:09 <sproingie> look ma, no garbage
11:33:16 <wizwizwizwiz> i understand,
11:33:25 <wizwizwizwiz> so that means that more time passes between GC runs?
11:33:38 <sproingie> that's the consequence of less garbage, yah
11:33:39 <wizwizwizwiz> than would be the case if the application was written without the linear types?
11:33:47 <wizwizwizwiz> but i still have my full application pausing when GC runs
11:33:52 <sproingie> copies are made and have to be cleaned up
11:34:03 <sproingie> (shallow copies usually, but still copies)
11:34:17 <geekosaur> wizwizwizwiz, linear types do not let you get rid of garbage collection
11:34:37 <sproingie> it's not a panacea and you'd certainly not want to write everything with linear types
11:34:40 <geekosaur> linear types and compact regions together can let you minimize GC overhead in parts of your program that need it
11:35:04 <ertes-w> you know…  when we get them
11:35:28 <wizwizwizwiz> but i still can't switch off GC...
11:35:32 <geekosaur> correct
11:35:57 <ertes-w> well, you can…  but you really don't want to
11:36:11 <monochrom> You can eliminate GC pauses by sticking to malloc and free.
11:36:11 <sproingie> the GC just has less work to do
11:36:20 <Tuplanolla> Have you tried doing functional programming in languages without gc, wizwizwizwiz?
11:36:24 <geekosaur> asking every week isn't going to make it happen, either
11:36:31 <monochrom> haha
11:36:32 <dolio> monochrom: How do I eliminate malloc/free pauses, then? :P
11:36:53 <Tuplanolla> Allocating closures by hand is not the most fun pastime, wizwizwizwiz.
11:37:21 <monochrom> You know what? For both malloc-free and GC, you can eliminate pauses by having unlimited memory (or good-enough approx thereof).
11:37:31 <sproingie> or running on an infinitely fast machine
11:37:44 <monochrom> which is what jhc did for a long time :)
11:37:52 <sproingie> laws of physics, shmaws of shmysics
11:38:02 <Tuplanolla> Besides, if you give up gc, you might as well give up on dynamic allocation altogether.
11:38:38 <wizwizwizwiz> can i cap the max GC pause time to a pre-specified amount, such as 1 msec?
11:38:52 <dolio> No.
11:39:52 * hackagebot preamble 0.0.47 – Yet another prelude. – https://hackage.haskell.org/package/preamble
11:40:55 <sproingie> deadline-driven GC would go into the large "tall order" column
11:41:34 <dolio> There exist garbage collectors that try to ensure certain low latency guarantees.
11:41:41 <dolio> GHC does not have one of those, though.
11:41:43 <wizwizwizwiz> well,... i didn't mean that the GC run would complete in 1 msec
11:41:55 <dolio> And I'm sure they make tradeoffs.
11:42:02 <wizwizwizwiz> i meant that it would do at most 1 msec worth of GC
11:42:13 <wizwizwizwiz> every say, 2 msec
11:42:25 <sproingie> there are uninterruptible parts of GC that take pretty much unbounded time
11:42:30 <Tuplanolla> So you spend one third of your time on gc, wizwizwizwiz?
11:42:38 <wizwizwizwiz> and then if more work needed to be done, that would be deferred to the next 2 msec, ad nauseum
11:42:39 <sproingie> you need a different algorithm
11:43:07 <wizwizwizwiz> i see
11:43:28 <monochrom> It sounds do-able (no evidence for now though). It also sounds like a PhD thesis waiting to happen.
11:44:00 <monochrom> But yeah asking again every week is not going to even get that thesis done.
11:44:10 <wizwizwizwiz> because what's significant about GC for many applications isn't the fact that it pauses, it's that the pause exceeds some usability threshold
11:44:28 <monochrom> At some point you have to quit IRC for 1 year and do that thesis for real.
11:44:39 <wizwizwizwiz> haha, i guess ya'll want me to go away?
11:44:44 <dolio> monochrom: Pff, PhD?
11:44:48 <dolio> https://www.azul.com/products/zing/pgc/
11:44:50 <sproingie> sounds like the subject has been talked to death
11:45:22 <monochrom> If IRC could get theses done, why did I take 10 years for mine? :)
11:45:57 <dolio> Oh, there's a patent, too.
11:46:15 <dolio> So GHC can't use anything too similar for 20 years or so. :P
11:46:25 <docmoxie> Hey fellas--I'm attempting to use optparse-applicative to parse CLI arguments and options (AKA flags). For dependency reasons, I needed to split up the parsing of args and options into two steps. So I have parseArguments, which grabs all positional arguments and throws away all optional flags, and parseOptions, which does the opposite...or, I'd lik
11:46:26 <docmoxie> e it to. The problem is, I can't seem to find a way to parse arbitrary keys, or to just tell the parser to succeed automatically after a certain point and ignore everything else. Does anyone have any experience with optparse-applicative who might be able to point me in the right direction? Thanks!
11:46:29 <sproingie> azul makes some neat stuff
11:46:59 <Tuplanolla> Does it matter if that stuff is patented and thrown away?
11:47:00 <wizwizwizwiz> i'm aware of azul
11:47:23 <monochrom> Unfortunately it does, Tuplanolla.
11:47:57 <geekosaur> wizwizwizwiz, I think we'd prefer you did things more productively than just popping in every week or so and asking if the language has been reimplemented to *your* standard yet
11:48:05 <geekosaur> s/language/compiler/
11:48:13 <monochrom> Although, this patented garbage collector is not thrown away. (Hrm, the irony.)
11:48:41 <sproingie> your best bet is to write your app in such a way to minimize garbage
11:48:51 <sproingie> not terribly easy in haskell
11:49:00 <Tuplanolla> The implication was that patenting things is equivalent to throwing them away.
11:49:06 <wizwizwizwiz> i'm not "judging" haskell, i'm just trying to learn stuff about it :P
11:49:18 <wizwizwizwiz> and about GC in general
11:49:23 <wizwizwizwiz> but yeah i can stop
11:49:35 <wizwizwizwiz> i've run into real world situations where i've gone along with implementation decisions made by more senior folk
11:49:43 <sproingie> even in runtimes with realtime gc, you still have to use realtime libs
11:50:01 <wizwizwizwiz> and then the GC for the language chosen (C#) did really dumb stuff which made lots of trouble for our application
11:50:19 <geekosaur> didn't say you were judging it. did imply you are being a bit pushy with expecting that someone will have taken your hint and dropped everything and redesigned the GC just for you
11:50:42 <cocreature> wizwizwizwiz: it’s not that you’re wrong in wanting a GC with lower latencies or even guaranteed latencies. it just doesn’t exist in Haskell and the reason why it exists are not that it doesn’t make sense but that no one has written one
11:50:45 <wizwizwizwiz> namely we experienced really bad memory fragmentation and pause times
11:50:52 <sproingie> the CLR has reasonably tunable GC but nothing like java's
11:51:09 <EvanR> i do question if it makes sense sometimes
11:51:10 <wizwizwizwiz> i'm not expecting that someone will "take my hint" or any such thing
11:51:12 <phadej> https://blog.plan99.net/modern-garbage-collection-911ef4f8bd8e is worth reading
11:51:20 <phadej> repeating the points mentioned there, isn't
11:51:38 <EvanR> i asked how you can know that a GC is doing its job when doing less work per run to keep latency down
11:51:57 <phadej> though it bitches about go's gc "marketing", there is gc stuff explained
11:52:08 <sproingie> GC is one of those thankless jobs, it works best when you don't notice it
11:52:22 <Tuplanolla> Why have only one gc?
11:52:29 <wizwizwizwiz> i think also i ask in haskell specifically because i think you guys are more knowledgeable :P
11:52:54 <sproingie> go's hype factory prompts many valid complaints
11:53:06 <wizwizwizwiz> if it had been named Gold Collection rather than Garbage Collection it would be much better
11:53:18 <sproingie> Technical Debt Collection
11:53:22 <wizwizwizwiz> haha
11:53:23 <cocreature> collect all the gold and throw it in the garbage
11:53:52 <phadej> Tuplanolla: I would guess you have to design RTS so GC is switchable, in worse case you may to reimplement a lot of it
11:53:56 <ystael> sproingie: well, most organizations do need at least one technical debt collector with a baton and a bad attitude
11:53:56 <wizwizwizwiz> is rust/jemalloc solving all my memory problems hype?
11:54:13 <dolio> GHC has two GCs, as I recall.
11:54:28 <dolio> It switches to mark/sweep when the heap gets full enough.
11:54:35 <dolio> Instead of copying.
11:54:44 <phadej> dolio: I didn't knew that!
11:55:09 <phadej> wizwizwizwiz: rust has manual memory maangement, that might be a problem or might be not
11:55:20 <wizwizwizwiz> via jemalloc
11:55:25 <wizwizwizwiz> as the default allocator
11:55:32 <wizwizwizwiz> but you can still experience fragmentation
11:55:45 <wizwizwizwiz> apparently it's fairly unusual
11:55:52 <sproingie> fragmentation is a different matter.  again, usually solved by libraries.
11:57:08 <dolio> I guess that only happens if you specify a max heap size, though?
11:57:13 <Tuplanolla> What if gc was offloaded to the os?
11:57:38 <dolio> Because otherwise I don't know how it'd decide to switch, and you can easily use all your memory without setting a cap.
11:58:11 <Tuplanolla> Would that solve anything?
11:58:31 <dolio> Tuplanolla: I imagine it would be implemented in a way ill-suited for Haskell, then. :)
11:58:32 <phadej> Tuplanolla: how? gc is pretty tight to rts/vms
11:58:43 <phadej> where to have and which barriers etc
11:59:49 <phadej> compact regions solve one slice of problems in Haskell btw
12:00:01 <phadej> I cannot wait to try them in practice
12:01:59 <monochrom> Tuplanolla: If the OS has a better idea of how your program behaves and which GC approach works better, then yes; else no.
12:02:16 <EvanR> best GC, do nothing until you run out of memory, then automatically order more ram
12:02:28 <EvanR> then block
12:02:37 <dolio> That sounds like a great strategy for my high frequency trading.
12:02:38 <sproingie> sounds like a few shops i've worked in
12:02:39 <monochrom> My understanding of most OSes in use is "no", they don't even try to observe your programs.
12:03:00 <Tuplanolla> I was just wondering if it would be useful for the operating system to be able to coordinate multiple processes that need gc, dolio, phadej and monochrom.
12:03:28 <sproingie> the OS can be told how to dispose of your program's memory though.  with some, it's simply "don't swap" (usually for security), some have more fine-grained advice
12:04:48 <monochrom> "Just order more RAM" sounds like what the Java shops actually do.
12:04:50 <sproingie> otherwise it's only language-specific OS's that get intimate with the process like that
12:05:31 <monochrom> If your program uses 1GB more memory than you like, then:
12:06:09 <monochrom>   If it's Haskell, you go to #haskell and whine about space "leaks" and how it is so difficult to troubleshoot
12:06:25 <wizwizwizwiz> haha
12:06:30 <wizwizwizwiz> hey i haven't done that... yet ;)
12:06:33 <monochrom>   But if it's Java, you just tell your boss to buy more RAM.
12:06:52 <dolio> Oh, I've been doing my job wrong.
12:07:37 <monochrom> Now, to be fair, I don't have evidence for my last sentence. But if it's true, someone needs to explain to me why the cognitive dissonance (aka hypocrisy).
12:07:54 <monochrom> Actually I think I have weak evidence that it's true.
12:07:54 <cheshircat> I want a function with this type signature (yes I've already hoogled it) that runs in O(1) (no copying): PrimMonad m => MVector (PrimState m) a -> (Vector a -> b) -> m b
12:07:55 <thoughtpolice> Tuplanolla: In practice it seems you can do better by actually getting the OS out of the way and letting the RTS do more itself; approaches like Azul's JVM do this (their JVM directly manage CPU page tables themselves, for example, to help the GC sustain extremely low pause times).
12:07:56 <sproingie> not sure that counts as hypocrisy
12:08:02 <EvanR> yeah mean, why not reverse the strategies
12:08:04 <sproingie> double standard perhaps
12:08:05 <dolio> Tuplanolla: I don't know. I kind of doubt it.
12:08:20 <EvanR> buy more ram in haskell, and complain about debugging java
12:08:27 <dolio> Like, I don't see why you'd want to coordinate multiple processes that can't point to each other's memory.
12:08:38 <monochrom> Well yeah I don't see any difference between the three: hypocrisy, double standard, cognitive dissonance.
12:08:40 <dolio> Breaking things up into processes like that is one of the ways people improve GC.
12:08:44 <dolio> So you can collect them separately.
12:08:52 <sproingie> hypocrisy is a double standard where one of the standards is private to you
12:09:47 <monochrom> Tuplanolla: The holistic coordination idea is interesting. But it's also very difficult to do, I don't think anyone has dared.
12:10:42 <monochrom> Then again, where local minimums are not good enough and you go for global minimum, you also easily run into downright NP-hard problems :)
12:11:01 <Tuplanolla> I just reckoned it would be useful to know when processes are going to pause or swap ahead of time, thoughtpolice and dolio.
12:11:05 <monochrom> (I don't mean you should shy away from NP-hard problems. But expect it to be sometimes too slow.)
12:11:18 <thoughtpolice> You can also be smarter in certain edge cases too; for example, if your heap is running close to the RAM limits of a machine, you could coordinate with the virtual memory system to understand the paging/swapping characteristics of the system more effectively.
12:11:26 <Tuplanolla> I'm not an expert on this subject.
12:11:34 <dolio> I'm not, either.
12:11:56 * wizwizwizwiz thinks RAM modules should have some kind of allocator ASIC
12:12:48 <Tuplanolla> Let's turn software bugs into hardware bugs, wizwizwizwiz.
12:13:03 <dolio> Tuplanolla: The main advantage I can imagine is pulling more logic about memory handling into the garbage collector.
12:13:03 <sproingie> MMUs are complicated enough as it is
12:13:27 <EvanR> and make the allocate asic programmable
12:13:43 <sproingie> then put that program in the RAM itself and execute it on the cpu </brilliant>
12:13:52 <EvanR> yes!
12:14:05 <thoughtpolice> Tuplanolla: Better OS integration would be nice of course, but more because you could just make GC a lot faster rather than monitoring, it seems. And you can of course get fairly predictable GC times without any OS help, today, depending on how your GC is designed.
12:14:10 <sproingie> paging Dr. Von Neumann...
12:14:24 <thoughtpolice> (GHC's GC does not really satisfy this constraint)
12:15:04 <dolio> Maybe you could design hardware to help with the problem, too.
12:15:13 <sproingie> routers probably do have some allocation logic on the ASICs.  dead simple allocation tho, ring buffers and whatnot
12:15:18 <dolio> If you could convince hardware manufacturers to implement it.
12:15:28 <thoughtpolice> If Azul is any indication, the hardware already has the features, the OS just doesn't give you control of it.
12:16:28 * hackagebot loup 0.0.13 – Amazon Simple Workflow Service Wrapper for Work Pools. – https://hackage.haskell.org/package/loup
12:16:30 <geekosaur> already has features and new ones being developed all the time... needs OS support, needs application support
12:16:36 <sproingie> azul used to be in the hardware game iirc
12:17:01 <geekosaur> mostly targeting supercomputing
12:17:04 <thoughtpolice> Yeah, but they've been using bog-standard x86 for close to half a decade or more now.
12:17:08 <sproingie> custom hardware is a losing proposition nowadays
12:17:46 <sproingie> gotta have massive economies of scale to break even
12:18:03 <monochrom> No no! Custom hardware is a win if your problem is a new problem. But expect to move to software a few years later.
12:18:32 <monochrom> For example there was even a time when there was hardware acceleration for video playback.
12:19:52 <sproingie> far as i know, that's still a thing in TV's
12:20:20 <Tuplanolla> You supposedly have acceleration, but the speed stays constant. There is something sketchy in here.
12:20:38 <sproingie> the mass keeps increasing.  we must be nearing c
12:21:03 <sproingie> (and for my next trick, i'll prove that 1+1 = blue)
12:21:21 <monochrom> w00t please show how to prove 1+1=blue
12:21:36 <sproingie> blue = 2
12:21:39 <sproingie> ta dah
12:22:01 * geekosaur was thinking an enumerated ADT with a Num instance
12:22:05 <monochrom> That's a bit anticlimatic.
12:22:11 <sproingie> sounds like my last date
12:26:02 <unclechu> how do i upload documentation using cabal for package candidate?
12:27:31 <mbw> Is there an unsafe indexing function actually exported for Data.Array? There do exist functions lessSafeIndex (exported by GHC.Arr) and unsafeIndex (not exported). Also I noted that some RULE pragmas are defined regarding indexing, however only for up to Ix = (Int, Int, Int). I have the problem that a series of loops over a UArray (Int, Int, Int, Int) get worker-wrappered, but I can't get indices unboxed. I 
12:27:37 <mbw> got them unboxed for the entry into the worker function, but then indices get rewrapped and a lot of bounds-checking occurs...
12:28:40 <mbw> Sorry, unsafeIndex does get exported, my bad.
12:28:47 <mbw> Still, this all feels kinda off...
12:28:56 <johnw> does anyone know where free monads for functional programming were first discussed in the academic community?
12:33:50 <sproingie> wasn't it Data Types à la Carte?
12:34:31 <monochrom> No.
12:34:45 <monochrom> Err, wait, maybe.
12:35:37 <sproingie> if not that, you could probably find the cite in there
12:36:31 <monochrom> Yes, section 6 "Monads for free"
12:36:52 <monochrom> This was 2008.
12:36:52 <johnw> ok, thank you!
12:38:04 <monochrom> But it has a sentence "These monads are known as free monads (Awodey, 2006)."
12:38:31 <monochrom> "these" refers to the familiar "data Term f a = Pure a | Impure (f (Term f a))"
12:38:56 <sproingie> Awodey, wonder if that's the CT book
12:39:01 <johnw> yes
12:39:05 <monochrom> Yes it is.
12:54:45 <n_blownapart> hi line 5 here has intentionally bad indentation. The error is different than the textbook's intended error with correct indents. If line 5 has no indentation, how is the program being read? just trying to understand 2 error messages thanks https://ptpb.pw/6YoU
12:57:27 <lambdaGrp> greeting is only defined in main, printSecond can't see it
12:57:37 <lambdaGrp> the where clause is local
12:57:41 <geekosaur> n_blownapart, I think this is because the NondecreasingIndentation extension is on by default
12:58:05 <geekosaur> lambdaGrp, it's not getting that far
12:59:07 <monochrom> Yeah, NondecreasingIndentation makes a difference.
12:59:07 <geekosaur> http://lpaste.net/356912 since we're not getting notifications again
13:00:59 <n_blownapart> sorry you meant I was not notifying ? geekosaur 
13:01:11 <geekosaur> no, I made a paste and it didn't get announced
13:01:24 <geekosaur> error messages with and without -XNoNondecreasingIndentation
13:01:53 <n_blownapart> oh within the error message you mean. I thought I was missing an irc protocol
13:01:58 <n_blownapart> geekosaur, 
13:02:21 <geekosaur> er. I was not asking for that, I was saying I pasted an example of that
13:02:31 <geekosaur> maybe start this over from scratch
13:02:44 <geekosaur> http://lpaste.net/356912 shows the errors I get with and without -XNoNondecreasingIndentation
13:03:43 <n_blownapart> geekosaur oh thanks ok. so could you explain nodecreasing ..? 
13:03:53 <n_blownapart> non*
13:04:16 <geekosaur> it loosens up the indentation rules for do-blocks (and possibly other layout-inducing constructs like let and case; I haven't tested those)
13:04:40 <n_blownapart> yeah those are the precise messages I got while fiddling
13:05:00 <geekosaur> speciifcally it lets you use the same *or* greater indentation (normally it would have to be greater)
13:05:03 <geekosaur> but in this case it means you can't "get out of" the do block any more, because there's no indentation to decrease
13:05:18 <mbw> Consider this: src/MP2.hs: warning:
13:05:18 <mbw>     Could not specialise imported function ‘GHC.Arr.$w$crangeSize2’
13:05:18 <mbw>       when specialising ‘GHC.Arr.$fIx(,,,)_$crangeSize’
13:05:18 <mbw>       when specialising ‘GHC.Arr.$fIx(,,,)’
13:05:19 <mbw>     Probable fix: add INLINEABLE pragma on ‘GHC.Arr.$w$crangeSize2’
13:05:58 <mbw> I really need this function specialized, since it is being called polymorphically in a tight loop. Is this possible?
13:06:09 <monochrom> It means line 5 is no longer a parse error. Instead, it becomes: printSecond = do { putStrLn greeting; main :: IO (); main = do {...
13:06:50 <monochrom> and suddenly "main =" is a parse error because you have an "x = y" in a do block without starting from "let"
13:07:04 <mbw> Also, rangeSize shouldn't even be called, judging from the definitions of the functions I use, which are all unsafe.
13:07:49 <n_blownapart> x = y means you essentially have definitions for 2 separate do blocks ? geekosaur 
13:08:26 <monochrom> No, I mean this. Your code now looks like: do { putStrLn stuff; x = y }
13:08:26 <n_blownapart> ...without correct indents
13:09:20 <n_blownapart> oh thanks that was monochrom 
13:09:27 * geekosaur was wondering...
13:09:42 <geekosaur> (sorry, am also trying to debug a vpn issue with $employer)
13:09:54 <sproingie> that flag sounds like it'd be more useful if one could enable it only for a region
13:09:55 <monochrom> so-called "2nd do block" is a red herring.
13:11:08 <n_blownapart> geekosaur monochrom thanks !! I'll go through whats been said. 
13:11:51 <geekosaur> I suspect it should refuse to trigger if it's impossible to decrease indentation
13:11:59 <geekosaur> (i.e. in first column, like this)
13:12:46 <n_blownapart> a possible decrease of indentation would be a minimum of 2 spaces in haskell I guess
13:13:31 <geekosaur> 1 would be sufficient
13:13:43 <geekosaur> but negative column numbers kinda aren't a thing
13:14:04 <geekosaur> (or 0 if you are counting from 1)
13:14:25 <n_blownapart> no I mean if it had been indented by two and you decreased by 1
13:14:37 <n_blownapart> that would be bad practice
13:15:06 <geekosaur> I'm not sure there is such a thing as bad practice. I mean, we survive Henning's naming conventions :p
13:15:36 <n_blownapart> over my head but thanks for the help
13:15:52 <lambdaGrp> sorry if I insist (it's late here), but it's not just greeting that is out of scope?
13:15:54 <geekosaur> look at the type and class names in any Haskell software by Henning Thielmann
13:16:16 <geekosaur> lambdaGrp, you hav e to be able to parse the input before you can determine semantics like that
13:16:36 <geekosaur> this is a parse error, at that point it has no idea whether greeting will be defined later or not
13:16:42 <rydgel> How do you flatten a lot of nested `alloca` lambdas?
13:16:45 <geekosaur> (it could have been defined at top level later in the file)
13:18:12 <sproingie> rydgel: monad comes to mind, but that depends how they're nested.  can you share a paste?
13:18:29 <glguy> rydgel: like this https://github.com/glguy/irc-core/blob/v2/src/Client/CApi.hs#L200-L246
13:18:40 * geekosaur just writes them at the same indentation, since that isn't layout
13:18:48 <rydgel> @sproingie https://cdn.discordapp.com/attachments/144185026722922496/335142324419952641/unknown.png
13:18:48 <lambdabot> Unknown command, try @list
13:19:00 <n_blownapart> ok that is helpful too, "at that point it has no idea whether greeting will be defined or not" part. the prog is still broken but I can see why I was getting different errors
13:19:09 <geekosaur> and it knows it's going to continue the expression because the previous line ended with an operator
13:19:16 <sproingie> glguy: documentation on parameters in a haskell program?  inconceivable!
13:19:27 <glguy> rydgel: for what you pasted, you delete the do's, and you line up all the 'alloca'
13:19:40 <bbear> hello
13:19:52 <bbear> what's your opinion on HashMap ? Which one should I use ?
13:19:57 <lambdaGrp> ok, I thought that one more space there and nearly done..
13:20:12 <rydgel> @glguy ok, I was wondering if there were some additional abstractions for cases like this
13:20:12 <lambdabot> Unknown command, try @list
13:20:29 <glguy> rydgel: The additional abstraction is the link I pasted above
13:20:40 <rydgel> thank you
13:20:40 <glguy> rydgel: but in your case you don't need any of the indentation
13:20:54 <boxscape> rydgel: what is that font?
13:26:28 <rydgel> boxscape: Operator Mono
13:26:32 <boxscape> thanks
13:30:03 <rydgel> If you would start a new API wrapper library, what would you use as http client?
13:31:41 <sproingie> wreq perhaps
13:44:11 <bbear> any advice on working in ghci ?
13:47:19 <srhb> bbear: Have fun always!
13:47:29 <srhb> bbear: (Seriously though, any specific questions?)
13:49:43 <bbear> copy paste is hard
13:49:49 <bbear> I want copy paste to work
13:50:06 <monochrom> Use an editor. Save to a file. Use :load
13:50:13 <geekosaur> use a better terminal?
13:50:23 <bbear> ok i'll go for the editor
13:50:30 <bbear> and :load
13:51:23 <monochrom> Why would anyone think of the REPL prompt as the best place to enter code?
13:51:57 <monochrom> I never had that intuition even back then when I met my first REPL, of Lisp.
13:52:06 <geekosaur> smalltalk?
13:52:23 <geekosaur> also forth and some (not all) lisps
13:52:37 <dolio> Smalltalk is like the opposite of a REPL, isn't it?
13:52:54 <monochrom> Yeah right all the current generation of Haskell beginners learned Smalltalk and Forth in kindergarten.
13:53:05 <Zemyla> I really wish that Rational wasn't just an alias for Ratio Integer.
13:53:36 <bbear> monochrom: it depends on the REPL
13:54:00 <Zemyla> Is Ratio a well-defined for "a" being a Bounded Integral?
13:54:02 <bbear> To test small snippets, check types, etc interactively is cool
13:54:17 <monochrom> "small"
13:54:32 <bbear> well yeah as soon as you put EOL chars it messes up
13:54:32 <monochrom> If you are doing copy-paste, clearly your snippet exceeds "small".
13:54:36 <bbear> yes
13:54:39 <dolio> What does "well-defined" mean?
13:54:48 <monochrom> Even in Lisp where it would work fine.
13:55:11 <geekosaur> Zemyla, there's no attempt to keep demoninators from ballooning
13:55:14 <monochrom> There is a very important reason I mentioned my Lisp encounter.
13:55:43 <monochrom> Even though Lisp's REPL was perfect for entering code at the prompt, I never considered it intuitive. That was my point.
13:55:52 <monochrom> The REPL prompt is not an editor.
13:56:16 <monochrom> And you will need an editor even you ever have at least 3 lines of code.
13:56:28 <monochrom> s/even/if/
13:56:49 <monochrom> Because by the 3rd line you will regret something in the 1st line and want to go back and change it.
13:57:20 <glguy> no regrets yolo
13:57:23 <monochrom> "does not scale" doesn't even come close to describing the problem.
13:57:51 <monochrom> because "does not scale" refers to when you have more than 50 lines, not when you have more than 2 lines.
13:58:18 <monochrom> We only use "does not scale" for proving program correctness.
13:58:44 <bbear> do you happen to have Haskell orgasmes ?
13:58:45 <dolio> Ackermann scale.
13:59:07 <monochrom> Entering 3 lines of code at the REPL prompt is even worse than proving those 3 lines correct.
13:59:17 <monochrom> Why would anyone do this?
13:59:18 <bbear> I need to have a good work stack anyway (vim/whatever)
13:59:30 <bbear> vim is slow though.
13:59:59 <dolio> That's a shame, because almost everything else is slower than vim.
14:00:00 <bbear> I just used fmap on function that's awesom.
14:00:01 <dolio> Except vi.
14:00:04 <kadoban> vim is slow? O.o
14:00:10 <dolio> And ed, I guess.
14:00:15 <bbear> if you load it with a shit ton of plugins yes.
14:00:23 <monochrom> sed is faster, FSVO faster
14:00:41 <bbear> I need really autosave
14:00:44 <dolio> Oh, you mean you made it slow.
14:00:50 <bbear> interactive editing is the way to go.
14:01:27 <bbear> I don't know why I stick to kate but vim is the bread and butter if you only work in console mode. 
14:01:44 <dolio> I made my vim auto-save.
14:01:54 <kadoban> bbear: Don't do that then? (re the plugins)
14:02:04 <bbear> dolio: I think there is a way for everything
14:02:09 <Zemyla> geekosaur: So why is Ratio a even a thing and Rational isn't just a special type with Integers?
14:02:17 <monochrom> kate is fine.
14:02:20 <Zemyla> Or even better, an Integer in the numerator and a Natural in the denominator?
14:02:38 <geekosaur> Zemyla, I have no idea. think there was a discussion on cafe a number of years back
14:02:49 <dolio> Well, Natural didn't exist like two years ago.
14:03:18 <monochrom> Let's chase down the question dependency hell. Why did Natural not exist until two years ago.
14:04:18 * hackagebot qm-interpolated-string 0.1.1.0 – Implementation of interpolated multiline strings – https://hackage.haskell.org/package/qm-interpolated-string
14:04:38 <Zemyla> Also, clearBit still isn't well-defined for Naturals.
14:05:54 <Zemyla> The definition of clearBit for Natural should be something along the lines of clearBit x n = xor x $ x .&. bit n
14:08:29 <monochrom> Send a PR.
14:09:42 <Zemyla> How do I send PRs to the GHC base library?
14:10:14 <bbear> I don't really work in console mode at all, so I don't benefit from all those awesome tools.
14:10:22 <monochrom> I don't know, but ask around in the libraries mailing list.
14:10:38 <EvanR> the embarassment of riches of integer types
14:10:45 <rostero> new to haskell and haven't seen much of other people's code.  i know you can write forward function application in haskell, but am i correct that not a lot of people do it?
14:10:55 <EvanR> Int Integer Natural Nat 
14:11:10 <EvanR> Word
14:11:49 <Taneb> rostero, what do you mean by forward function application? I'm not familiar with the term
14:11:49 <bbear> someone told me that functions are functors
14:11:56 <bbear> is that true ?
14:12:12 <EvanR> in a suitable category yeah
14:12:13 <johnw> yes, they are functors
14:12:16 <Taneb> bbear, yes, sort of
14:12:17 <rostero> & in haskell or |> in elm, etc ...
14:12:18 <monochrom> Does it mean you write "5 & sin" backwards instead of "sin 5" forward?
14:12:19 <Tuplanolla> I tend to avoid `$` and `&`, rostero.
14:12:23 <johnw> between discrete categories whose objects are values
14:12:28 <Taneb> rostero, ah, yes
14:12:49 <monochrom> http://www.vex.net/~trebla/weblog/intuitive.html
14:12:52 <johnw> so, not terribly interesting functors
14:12:55 <Taneb> rostero, it's useful with some libraries like lens or diagrams, but not really for general use
14:13:11 <EvanR> johnw: also between groupoids whose objects are types and arrows are equalities!
14:13:23 <johnw> EvanR: ooh, nice
14:13:35 <bbear> johnw: 
14:13:57 <EvanR> er, the objects would be the values again here
14:14:03 <johnw> ok, sanity restored
14:14:04 <EvanR> the whole groupoid is the type
14:14:10 <bbear> it's interesting
14:14:28 <johnw> bbear: better, it's so deeply fascinating that if you go far enough, you'll never return
14:15:17 <bbear> i'm lost in types
14:15:24 <[exa]> ...even if you return the people of your village won't ever recognize your again
14:15:31 <EvanR> yeah in hott the function functors are more interesting because they also preserve equality, and if you do higher stuff, the equalities of equalities
14:15:34 <[exa]> </prophet_voice>
14:16:09 <johnw> bbear: becoming lost, you set the stage for being found
14:16:15 <dolio> Right, it's more interesting because they're not equalities. :P
14:17:13 <johnw> the fact that hott lets me regards isomorphisms as equalities seems almost too good to be true.  I have some proofs right now that would be tremendously simplified by that.
14:17:14 <EvanR> or they preserve the non-equality of equalities
14:17:56 <johnw> as it stands, I have to call "to" and "from" in various places, and then prove in terms of to . from = id and from . to = id equivalences.  It's rather cumbersome.
14:18:23 <johnw> It seems like hott would free me from setoids
14:18:43 <bbear> <*> is commutative ?
14:18:47 <EvanR> so in hott, you need to prove in terms of ua <foo> ? :)
14:18:50 <monochrom> No.
14:18:52 <bbear> i'm quite drunk i must tell
14:19:00 <johnw> bbear: the types on the two sides are not even the same
14:19:15 <EvanR> dont drink and derive
14:19:17 <Tuplanolla> I can exchange your `<*>` to something commutative for a small fee, bbear.
14:19:51 <johnw> someone asked me, do I commute to work?  I said, even better, my work commutes.
14:20:05 <monochrom> It is not too good to be true. If you regard isomorphisms as equalities, you'll lose something else.
14:20:17 <johnw> monochrom: what?
14:20:31 <dolio> The ability to disrespect isomorphisms.
14:20:35 <bbear> that was deep
14:21:03 <EvanR> you can restore whatever you lost with extra structure!
14:21:23 <bbear> I want to know what I can do with this type : :: (Map.Map [Char] a -> FilePath) -> Map.Map [Char] a -> Maybe a
14:21:24 <dolio> johnw: It's the problem people run into with real numbers.
14:21:24 <EvanR> perhaps with an indexed family of types 
14:21:29 <monochrom> If you regard isomorphisms as equalities, that restricts what kinds of functions you have. Because Leibniz: x=y implies f x = f y
14:21:48 <dolio> Like, everyone imagines, 'wouldn't it be great if we could take an actual quotient, instead of working with a setoid.'
14:22:12 <dolio> But, when you take the quotient, all functions from the reals to the naturals are constant, for example.
14:22:23 <monochrom> I.e., you're looking at: (x isomorphic to y) implies (f x isomorphic to f y). This may ban some things you want to be functions.
14:22:43 <EvanR> as they should be
14:23:04 <dolio> So maybe you lose the ability to do something you wanted to do.
14:23:12 <johnw> monochrom: my free lunch keeps getting charged a surtax
14:23:19 <monochrom> :)
14:23:21 <EvanR> when did we have the ability to have non constant functions from reals to integers!
14:24:09 <EvanR> rather, how could we if we wanted to
14:24:13 <dolio> EvanR: I think ASD has them somehow. I forget how that works.
14:24:40 * EvanR looks at the encyclopedic paper explaining ASD
14:24:56 <EvanR> one day
14:25:36 <monochrom> I once bought a home router "for free plus tax". It worked like this:
14:25:59 <dolio> Was it sold by Billy Mays?
14:26:00 <monochrom> The router price tag was $50 (say). Manufacturer instant rebate was also $50.
14:26:28 <monochrom> Ah but sales tax is defined on the price tag alone, rather than price tag minus rebate.
14:26:50 <monochrom> Actually I misremembered. It was a USB flash stick. But meh.
14:27:12 <monochrom> No, it was a Kingston USB flash stick.
14:27:17 <EvanR> tax is brilliant
14:28:49 <EvanR> so hotts HITs make quotients a trivial side feature, they make most functions tedious to define
14:29:06 <EvanR> since you now must prove all higher equalities are preserved by your function
14:29:22 <EvanR> functor like
14:30:03 <EvanR> and the statements might take the form of a complex nest of dependent transports
14:30:34 <EvanR> actually im not sure how any of this relates to univalence
14:31:01 <monochrom> It is highschool math coming back to haunt you. Every time you draw a curve, you have to do the "vertical line test" before you can call it a function.
14:31:30 <EvanR> haha
14:31:37 <dolio> monochrom: Did you pay income tax on the $50 rebate, though?
14:31:46 <monochrom> No.
14:31:54 <dolio> Oh man.
14:32:01 <dolio> Now the IRS is after you.
14:32:05 <EvanR> the vertical line test, that is great
14:32:19 <EvanR> i like that
14:32:40 <EvanR> you can use that in functional programming!
14:33:26 <EvanR> next question, how do you violate it in functional programming
14:34:00 <EvanR> with side effects, state, I/O perhaps
14:34:46 <c_wraith> those only change the domain, not the definition of functions 
14:35:19 <c_wraith> well, codomain. 
14:35:53 <c_wraith> Haskell pretty much restricts functions to being functions. 
14:36:33 <monochrom> There is a reason they didn't call it "relational programming" :)
14:36:35 <c_wraith> if you want more generality, you have to move to relations. haskell has no special syntax for them, unlike something like prolog 
14:36:41 <monochrom> Basically the language is deterministic.
14:37:10 <monochrom> As it happens there are also a few other things Haskell bans. For example parallel-or.
14:37:41 <monochrom> Parallel-or means a function f that satisfies both equations: f True bottom = True, f bottom True = True.
14:39:51 <monochrom> The annoying thing is that f is still monotonic, continuous, ... all those nice properties you require of CPOs.
14:40:32 <c_wraith> Oh yes. haskell doesn't allow all functions. it just requires that things you write as functions are functions. 
14:41:27 <EvanR> that parallel or thing is supposed somewhat by concurrency?
14:41:33 <EvanR> supported*
14:41:52 <EvanR> async race, lub
14:42:08 <c_wraith> yes, to some extent. 
14:42:19 <monochrom> Yeah but there is no official bridge from the IO world back to the pure world.
14:42:52 <c_wraith> I guess you can claim unsafePerformIO let's you write non-functions as functions. 
14:42:58 <c_wraith> *lets 
14:43:23 <EvanR> and lets you write more functions that you otherwise couldnt
14:43:37 <c_wraith> yes. 
14:43:42 <EvanR> so its like taking the shield off the tablesaw :)
14:44:10 <bbear> sorry but I have a noob question. I have those twothings :
14:44:16 <ystael> EvanR: "inevitably resulting in blood, tears, and a hospital visit"?
14:44:22 <bbear> :t ( <*> (map (wordToTuple.words) <$> mapM (\_ -> getLine) [1..]))
14:44:23 <bbear> ( <*> (map (wordToTuple.words) <$> mapM (\_ -> getLine) [1..]))
14:44:23 <lambdabot> error:
14:44:24 <lambdabot>     Variable not in scope: wordToTuple :: [String] -> b
14:44:24 <EvanR> or "cool shit"
14:44:42 <c_wraith> note that things like lub and unamb are very sketchy in some ways. they only work in sane ways for certain input pairs. 
14:44:59 <bbear> this `:: IO ([(String, String)] -> b) -> IO b` and this `[(k, a)] -> Map.Map k a` ; how do I put them together ?
14:45:06 <EvanR> so they have unchecked input criteria...
14:45:34 <c_wraith> yes. fortunately, they are very explicitly called out in their docs. 
14:45:36 <EvanR> similar to requiring a function argument to be commutative
14:45:54 <EvanR> if requirements arent met, undefined behavior :(
14:46:21 <Tuplanolla> I wonder what type I should give to a function whose exact value is provably known at 1, 2, 3, 4 and 24, hypothetically known at 4, 5, 6 and 7, numerically tightly bounded from 8 to 36 and very loosely bounded everywhere else.
14:46:46 <monochrom> @type mapM (\_ -> getLine) [1..]
14:46:48 <lambdabot> IO [String]
14:46:49 <EvanR> hypothetically known?
14:46:59 <Tuplanolla> It'd feel wrong to use `Int -> Double`.
14:47:10 <johnw> an ADT of 4 constructors?
14:47:14 <EvanR> is this like donald rumsfeld
14:47:17 <c_wraith> Tuplanolla, use a type with a constructor for each of those cases. 
14:47:34 <bbear> :t l x = x*1.0 :: Int -> Double
14:47:36 <lambdabot> error:
14:47:36 <lambdabot>     parse error on input ‘=’
14:47:36 <lambdabot>     Perhaps you need a 'let' in a 'do' block?
14:47:41 <bbear> :t let l x = x*1.0 :: Int -> Double
14:47:43 <lambdabot> <no location info>: error:
14:47:43 <lambdabot>     not an expression: ‘let l x = x*1.0 :: Int -> Double’
14:47:47 <EvanR> actually whenver this comes up i name a type like that Rumsfeld
14:48:07 <conal> c_wraith: it's not that lub is sketchy, considering that it's at the heart of the meanings of programming languages; and unamb is lub on flat types; but rather than Haskell's type system is not yet up for capturing the domain of well-definedness.
14:48:12 <Tuplanolla> I wish open problems weren't so messy.
14:48:44 <c_wraith> conal, well yes. it's perfectly well-defined on a subset of the inputs the type system allows you to provide. :) 
14:49:30 <conal> and lub is not about concurrency. the meaning of lub is simple, while the meaning of concurrency is frightfully complex.
14:49:37 <Tuplanolla> (Bonus points to anyone who can recognize it from my description.)
14:50:03 <c_wraith> bbear, for lambdabot, you need to provide it a full expression, meaning you need let [decls] in [expr] 
14:51:19 <bbear> it's complicated to do the distinguo when I need a <- or a let x=(foo)
14:51:36 <bbear> <- is for functions that return a (m a)
14:51:46 <bbear> let x= is for function that return a (a)
14:52:14 <bbear> let f=2*x in f x
14:52:17 <bbear> > let f=2*x in f x
14:52:19 <lambdabot>  error:
14:52:19 <lambdabot>      • Couldn't match expected type ‘Expr -> t’ with actual type ‘Expr’
14:52:19 <lambdabot>      • The function ‘f’ is applied to one argument,
14:52:21 <monochrom> Tuplanolla: Is that Ramsey theory?
14:52:25 <bbear> die
14:52:31 <bbear> lambdabot
14:52:51 <glguy> <- and = don't have to do with functions or not, they have to do with whether you're naming an expression or using >>=
14:52:55 <Tuplanolla> Not quite, monochrom.
14:53:15 <glguy> let x = True,  y <- getLine,   no functions involved
14:53:20 <monochrom> Hmm, 1,2,3,4,24. I think I saw it recently. Sphere packing?
14:53:29 <Tuplanolla> Ding!
14:53:34 <monochrom> \∩/
14:53:52 <fvh> Hi guys, how can I reduce output line in GHCi ? it's showing me full list of loaded modules, so the actual line for typing is very small
14:54:09 <glguy> fvh: :set prompt="> "
14:54:46 <monochrom> Make your terminal wider. You have a 16:9 screen. Use it.
14:55:06 <monochrom> OTOH the "full" list of loaded modules should be short.
14:55:08 <fvh> ome flags have not been recognized: prompt="> "
14:55:08 <fvh> ome flags have not been recognized: prompt="> "
14:55:08 <fvh> Some flags have not been recognized: prompt=">
14:55:18 <fvh> ah, sorry for duplication
14:55:32 <Tuplanolla> Drop the equals sign, fvh.
14:55:55 <Tuplanolla> Also `:set prompt2 "  "`.
14:55:59 <bbear> someone is good with map here ?
14:56:10 <monochrom> No one.
14:56:28 <fvh> nice, is there some kind of config to do this automatically?
14:57:09 <Tuplanolla> @google care and feeding of your users guide
14:57:11 <lambdabot> https://downloads.haskell.org/~ghc/master/users-guide/editing-guide.html
14:57:17 <bbear> The problem is that I want to retrieve a key in a Map in a case insensitive way.
14:57:34 <bbear> it is really hard to do in the current state of the Map library.
14:57:46 <bbear> It is possible only if I redefine the lookup function
14:57:59 <dmwit> fvh: ~/.ghci
14:58:20 <glguy> bbear: normalize your keys before using them in the Map, or use a case-insensitive string type
14:58:44 <bbear> do you know of such a type in ghc ?
14:58:45 <monochrom> fvh: Eventually you will want to read the GHC User's Guide for this kind of things. But for now what dmwit said.
14:58:51 <dmwit> fvh: I like to include the modules, but on a separate line, as they are often useful information to know. Try `:set prompt "%s\n> "` to see if you like that.
14:59:06 <monochrom> Ah neat
14:59:23 <dmwit> fvh: (Actually I use `:set prompt "%s\n\ESC[32m\STX>>>\ESC[0m\STX "` to get a prompt that's easy to spot in the middle of a lot of output.)
14:59:38 <monochrom> heh
14:59:59 <monochrom> Humongous prompt strings for bash and ghci.
15:00:41 <monochrom> Let's also set the terminal window title...
15:00:50 <dmwit> (... and `:set prompt2 "\ESC[32m\STX...\ESC[0m\STX "`. Indeed, the standard "..." continuation explains why I use ">>>" instead of ">".)
15:00:57 <monochrom> and don't forget screen's title
15:01:18 <fvh> ah, nice, when I load with `stack ghci` it loads everything so it's also useful, thanks dmwit
15:01:23 <dmwit> monochrom: set it and forget it =)
15:01:55 <geekosaur> https://github.com/geekosaur/dotty/blob/master/.prompt.pl you rang?
15:02:09 <monochrom> Oh, stack ghci, no wonder you have a million module names.
15:02:26 <monochrom> Oh well, one more rationalization for me not using stack. :)
15:03:13 <dmwit> geekosaur: nice and concise =)
15:03:20 <fvh> stack is awesome tool, you can `stack ghci <some file>` and it will load only it, but I often start ghci and then load file
15:03:23 <jared-w> hah, stack ghci is really useful for the project. If you just need /a/ ghci then just use ghci but if you need one that's linked to all of the project, stack ghci is really convenient
15:03:49 <geekosaur> someday I may finish un-pmax_ul4-ing it >.>
15:04:16 <jared-w> uhhh... is all of that your shell prompt or something?
15:04:47 <geekosaur> it generates the prompt (and titlebar and status bar info for tmux or screen and ...)
15:04:55 <Tuplanolla> I use `"\ESC[37m\x2508\x2504\x254c\x2500\x254c\x2504\x2508 \ESC[93m\x03c2( \x361\ESC[92;1m\xb0\ESC[91m \x35c\ESC[93;22m\x296 \x361\ESC[32;1m\xb0\ESC[93;22m)\x0242\ESC[37m \x2508\x2504\x254c\x2500\x254c\x2504\x2508\ESC[0m\n"`.
15:05:05 <jared-w> ahh okay, I was wondering why that was obscenely complex for just a prompt :p
15:05:15 <fvh> geekosaur what in hell is that? how can I try it? =)
15:05:31 <jared-w> Tuplanolla: I have a bunch of color codes defined elsewhere so my prompt is actually readable. geekosaur, I'm kinda interested in seeing a screenshot of what that monstrosity looks like :p 
15:05:40 <dmwit> jared-w: Just want to point out: one can have a ghci with all the appropriate modules available without loading them all by default. (There has been some discussion about this in some tickets for `cabal repl` and `cabal new-repl`, after some folks mentioned how much they like `cabal exec ghci` as a replacement for `cabal repl`.)
15:06:16 <armlesshobo> in lambda calculus, is λsz.s(z) synonymous with λsz.sz?
15:06:35 <glguy> yes
15:06:39 <armlesshobo> ok ty
15:06:41 <geekosaur> it goes with the other shell dotfiles and isn't really usable as is (in particular it expects the shell to pass in some status information, see https://github.com/geekosaur/dotty/blob/master/.bashrc#L1180
15:06:52 <dmwit> > text "\x2508\x2504\x254c\x2500\x254c\x2504\x2508\x03c2\x361\xb0\x35c\x297\x361\xb0\x0242\x2508\x2504\x254c\x2500\x2548\x2504\x2508"
15:06:54 <lambdabot>  ┈┄╌─╌┄┈ς͡°͜ʗ͡°ɂ┈┄╌─╈┄┈
15:07:01 <dmwit> ...ugh
15:07:07 <geekosaur> and don't look at the top of that file if you value your sanity
15:07:08 <jared-w> lol
15:07:24 <jared-w> That's a ridiculous prompt. +1
15:07:55 <Tuplanolla> It's hard to miss among dozens of error messages.
15:07:58 <armlesshobo> glguy: and the body of λsz.sz says "apply function 's' to 'z'" right?
15:08:23 <jared-w> I just color my prompt a certain color and I can search-backwards for the prompt... Works for me ¯\_(ツ)_/¯
15:08:27 <dmwit> armlesshobo: Right.
15:08:35 <fvh> I thought my zsh setup is ugly but this is something =) well at least works for you
15:08:58 <jared-w> geekosaur: dancing prompt? wat. Now I gotta see this lol
15:09:02 <armlesshobo> dmwit: ok thank you
15:09:15 <geekosaur> not literally
15:09:25 <geekosaur> but the way it adapts to different machines and different configurations
15:09:44 <jared-w> ahh got it. Because if MACHINE_NAME= was too complicated ;)
15:09:53 <Tuplanolla> We're one step away from a sentient prompt.
15:10:09 <geekosaur> it was, with some 400 such machines
15:10:31 <jared-w> oh, yeah that makes sense if you want a differnt prompt for each one...
15:11:06 <jared-w> Also explains why you have compatibility for bash /2.01/, jeez I didn't even know it was still around.
15:13:51 <bbear> I don't get it : 
15:13:53 <bbear> data Map k a  = Tip 
15:13:54 <bbear>               | Bin {-# UNPACK #-} !Size !k a !(Map k a) !(Map k a) 
15:14:00 <bbear> what is this Tip thingy ?
15:14:13 <monochrom> Empty tree I guess?
15:14:22 <monochrom> It's a binary search tree.
15:14:43 <bbear>  yes 
15:14:47 <bbear> where is it defined ?
15:15:00 <bbear> I try to copy paste a function to just modify it. 
15:15:07 <monochrom> Huh? You know algebraic data types and data constructors, no?
15:15:17 <phadej> `containers` don't export definition of `Map`
15:15:27 <monochrom> If you see "data X = Y | Z" are you going to ask "where is Y defined"?
15:15:34 <phadej> until recently... http://hackage.haskell.org/package/containers-0.5.10.2/docs/Data-Map-Internal.html
15:16:34 <bbear> ok
15:16:35 <phadej> i.e. the containers bundled with  GHC-8.0.2 doesn't have that module
15:16:36 <bbear> I get it
15:16:40 <bbear> i was sorry 
15:17:02 <jared-w> bbear: can I ask what method you're using to learn haskell?
15:17:23 <bbear> Not in scope: data constructor ‘Tip’
15:17:28 <bbear> jared-w: wild 
15:17:50 <bbear> I mostly read LYAH
15:17:56 <bbear> the style is horripiling
15:18:04 <monochrom> Well yeah it's in some other modules, not your module. And it is unexported, so you can't even import it.
15:18:13 <bbear> lastly I went through something readable about CT I was curious.
15:18:43 <bbear> this night I am real-problem-solving
15:19:05 <bbear> Trying to perform hashmap lookup that doesn't not look like O(n)
15:19:16 <monochrom> You are going to have no luck copying out one function into a different context.
15:19:20 <bbear> doesn't look like O(n²)
15:19:28 <bbear> monochrom: that's for real man
15:19:30 <bbear> yes
15:19:44 <bbear> I think I should try to define a new type, but refining all the types in p
15:19:49 <bbear> my program is going to take time.
15:19:54 <bbear> I am not sure I want to do that.
15:19:55 <phadej> bbear: are you using stack?
15:19:56 <phadej> or cabal
15:20:00 <monochrom> If you want to modify one function there, you have to download the whole source tree and modify it there.
15:20:02 <bbear> no, I use my distro full stuff.
15:20:22 <phadej> i.e. you just ghc yoursource.hs ?
15:20:23 <monochrom> Think of it as a private fork.
15:20:31 <bbear> phadej: yes
15:20:35 <bbear> quite so
15:20:51 <phadej> bbear: oh, than it's a bit complicated to guide you to get recent containers
15:20:56 <bbear> phadej: do you know of ppl that are treating teh haskell stack as just a big framework to modify here and there ?
15:21:18 <phadej> now I don't understand
15:21:55 <bbear> phadej: ideally most ppl treat a standard lib as « evangil »
15:21:56 <jared-w> He means "how can I find a guide to look up how to tinker around and modify a library on hackage and basically pretend that all of hackage is one giant playground I can mess around in"
15:22:07 <jared-w> (I think?)
15:22:11 <bbear> jared-w: no
15:22:26 <bbear> I wouldn't dare that some ppl would even dare to think about it.
15:22:37 <bbear> I wouldn't dare * to think * etc
15:23:27 <jared-w> Nobody treats the standard prelude as mythical and perfect gospel...
15:23:57 <mniip> something something wired-in types
15:23:58 <bbear> my program is here http://lpaste.net/356917
15:23:59 <monochrom> I think I do, somewhat.
15:24:01 <phadej> bbear, well, if you somehow manage to get yet-unreleased GHC-8.2-rc3 then you can `import Data.Map.Internal`
15:24:13 <phadej> bbear: but I suspect you aren't using Ubuntu?
15:24:16 <bbear> jared-w: 
15:24:18 <bbear> phadej: not
15:24:21 <bbear> archlinux
15:24:23 <glguy> phadej: Why is rc3 unreleased?
15:24:52 <phadej> glguy: i misstyped GHC-8.2 is unreleased (but there is rc3)
15:24:53 <bbear> jared-w: standard library in production-ready language are.
15:25:39 <jared-w> You misunderstood what I said. The standard libraries in Haskell are good and Haskell itself is production-ready. Just because Haskell takes a separate philosophy than C++ and Python do doesn't mean our standard library is useless
15:25:42 <bbear> I mean -- languages aiming to really be used in the wild don't change their API at the drop of a hat -- and are not designed for that I suppose.
15:25:55 <monochrom> I contest that.
15:25:59 <bbear> jared-w: no I don't misunderstood
15:26:08 <bbear> I guess the philosophy in haskell is quite different.
15:26:24 <jared-w> Yes you do, you think I'm getting at something very different than what I actually am. I suppose it's part language barrier and part failure on my end to communicate effectively
15:26:25 <monochrom> Several standard library sorting algorithms including Java's was proven wrong. There goes perfect gospel.
15:26:25 <bbear> or it is used by people much more competent than I am.
15:26:28 <EvanR> wait, we have "the philosophy" ?
15:26:29 <phadej> I disagree to. Haskell is good in refactorign, so adapting to changed API isn't hard
15:26:51 <bbear> phadej: I agree with you. Adapting isn't hard in Haskell.
15:26:53 <glguy> monochrom: or we conclude that Java just isn't production ready
15:26:59 <EvanR> its not official until a ghci flag prints the philosophy out on boot
15:27:03 <glguy> Python has a number of issues in its standard library keeping it from being production ready
15:27:04 <bbear> Java is not quite production ready I believe.
15:27:04 <jared-w> Haskell does not change its "API" frequently at all. You can't even think of the "haskell language" changing its "API" because "haskell" itself doesn't really have one
15:27:08 <monochrom> As for mythical, if a standard library is mythical (as opposed to "could have been userland code"), that's a shortcoming of the language.
15:27:25 <bbear> jared-w: monochrom: yes and yes.
15:27:40 <monochrom> It just so happens that so many production-ready languages out there are so full of second-class things such that their standard libraries cannot possibly be userland code.
15:27:41 <EvanR> the amount of money going through ruby and its sorry state of standard library....
15:27:42 <bbear> I mean, it depends on the language and on the purpose. Haskell is quite a pure language
15:27:47 <bbear> Java and Python are note.
15:27:50 <monochrom> So, production-ready my ass.
15:28:15 <bbear> monochrom: I mean -- you know the verb . if it aint broken, don't fix it.
15:28:19 <jared-w> bbear: why does the language design and purpose change the needs of a standard library? What does the purity of a language have to do with how stable an "API" is?
15:28:33 <monochrom> Here in Haskell land, with GHC, even some of the code optimization recipes can be userland code. See for example "rewrite rules" and "list fusion".
15:28:38 <ertes-w> glguy: i agree about the python stdlib, but i'd be interested in what issues you found
15:28:45 <Tuplanolla> `__asm__` here, `__asm__` there...
15:28:46 <bbear> jared-w: basically all the standard constructs in Java and python are programmed in C
15:28:59 <bbear> you don't java-around standard built-in types 
15:29:17 <bbear> you don't even python-around standard python built-in types. In Haskell you do.
15:29:22 <bbear> (I suppose that was teh point)
15:29:31 <jared-w> I'm not quite sure what you're getting at there or what that has to do with the standard librarys of languages
15:29:56 <bbear> ha... sorry
15:30:08 <bbear> I wast just going to ask for a (lookup) replacement
15:30:15 <jared-w> Haskell's type system is actually useful so people make types for everything. Java's type system consists of making objects for everything and pretending they're types
15:30:43 <bbear> :t lookup
15:30:45 <lambdabot> Eq a => a -> [(a, b)] -> Maybe b
15:30:50 <jared-w> a lookup replacement? What do you mean by that?
15:31:31 <bbear> you know (Eq) is a type class right ?
15:31:42 <jared-w> Yeah
15:31:50 <bbear> okay
15:31:56 <monochrom> Lookup based on Eq alone is going to be linear time. This can be proved.
15:32:00 <EvanR> thats pretty chiasmic jared-w 
15:32:25 <bbear> How would I kind of « overload » the equality test in the lookup function ?
15:32:27 <EvanR> type your objects or you will object to types
15:32:39 <bbear> I want some kind of lookupBy
15:32:46 <EvanR> :t find
15:32:48 <lambdabot> Foldable t => (a -> Bool) -> t a -> Maybe a
15:33:06 <phadej> bbear: we disagree that "production-ready == standard libraries API develops monotonically"
15:33:19 <jared-w> EvanR: eh... I've heard so many people refer to types, subtyping, classes, and inheritence all in the same everything lol
15:33:26 <bbear> phadej: forget this bullshit
15:33:34 <bbear> I mean
15:33:35 <phadej> bbear: Java 1.4 -> 5 (addition of generics) is e.g. "what you get when you try too hard to do that"
15:33:49 <bbear> really
15:34:22 <bbear> you know that I'm trying hard to learn Haskell. But I have my cultural bias :)
15:34:52 <phadej> bbear: you should watch a Haskell history talk by SPJ
15:35:00 <phadej> let me find it for you
15:35:17 <bbear> I don't disagree with anything that you would say.
15:35:30 <bbear> (just for the taste of disagreeing)
15:35:43 <bbear> I don't like to disagree in general.
15:35:55 <bbear> But opposites are fertile : take men and women for example.
15:36:08 <bbear> yeah
15:36:36 <jared-w> Men and women aren't opposites
15:36:44 <EvanR> haskell rocks
15:36:47 <phadej> https://www.youtube.com/watch?v=re96UgMk6GQ this one
15:36:52 <jared-w> EvanR: true :p
15:36:59 <bbear> so a lookupBy :: (a->a->Ordering) -> a -> [(a, b)] -> Maybe b would be cool
15:37:29 <bbear> sometimes a wrong has to be said to be acknoweledged as wrong.
15:37:33 <EvanR> you can use find 
15:37:40 <jared-w> bbear: you could always try writing something like that yourself. Perhaps looking at the find function for inspiration.
15:37:48 <monochrom> No, not when you use a list.
15:37:54 <phadej> quote at this point: https://youtu.be/re96UgMk6GQ?t=22m50s
15:38:01 <bbear> :t find
15:38:03 <lambdabot> Foldable t => (a -> Bool) -> t a -> Maybe a
15:38:13 <EvanR> :t comparing
15:38:14 <lambdabot> Ord a => (b -> a) -> b -> b -> Ordering
15:38:23 <EvanR> :t on
15:38:25 <lambdabot> (b -> b -> c) -> (a -> b) -> a -> a -> c
15:38:37 <EvanR> somehow these collide to form the thing
15:39:06 <bbear> how can you know that integers are a monoid ?
15:39:20 <jared-w> Integers are not a monoid
15:39:24 <bbear> I mean more generally how can you know that a type belong to some instances ?
15:39:30 <bbear> (N,+,0) is a monoid
15:39:32 <EvanR> look at its info listing
15:39:38 <EvanR> ghci command :info
15:39:40 <bbear> EvanR: how do you do that ?
15:39:41 <monochrom> Go through docs.
15:39:41 <bbear> ok
15:39:44 <bbear> ok
15:40:02 <phadej> "too successful too quickly => you cannot change anything; GHC users have been trained over decade or two decades: when something goes wrong or new version of compiler is incompatible with the old one... they just grief their teeth and modify their code" - SPJ
15:40:12 <jared-w> Yeah, says that the Integers /over addition/ form a monoid, bbear
15:40:44 <jared-w> A monoid requires 1) an appending operation, 2) an identity element, 3) a collection of elements. Integers alone are not a monoid
15:41:00 <phadej> addition and multiplication are bad examples, as Int could be both, we chose not to make Int instance of either one
15:41:08 <EvanR> (N,0,+,proofOfId,proofOfAssoc) is a monoid
15:41:39 <monochrom> You need more spaces for readability.
15:41:42 <phadej> EvanR: left-identity and right-identity, doesn't have to be commutatie!
15:41:49 <Tuplanolla> You might need another proof too, EvanR.
15:42:00 <EvanR> true
15:42:11 <jared-w> But... are we being pedantic /enough/? Can we be even more obtusely specific about what exactly a monoid is?
15:42:37 <EvanR> is it pedantic
15:42:38 <Tuplanolla> We could talk about the universe it inhabits.
15:42:55 <monochrom> Yes, one can split hair on whether the "N" there is a set or a type.
15:42:58 <EvanR> i was ok with "integer is a monoid"
15:43:33 <phadej> monochrom: https://bartoszmilewski.com/2017/02/09/monoids-on-steroids/ ? :)
15:44:26 <EvanR> haha
15:44:27 <jared-w> Oooh another bartoz link. Time to lose two hours of my day
15:44:33 <EvanR> i have work to do
15:44:44 <jared-w> *sigh* me too...
15:44:51 * jared-w leaves yet /another/ browser tab open
15:45:17 <phadej> "a monoid is a category that has only one object"
15:45:35 <jared-w> SPJ is a great speaker. I'm not sure if it's the accent or the charisma and well polished speaking skills; probably both. It's a shame I can only hear 10% of it :(
15:45:35 <phadej> that makes you not worry about whether N is a set or a type :)
15:45:53 <EvanR> unfortunately the definition of category takes twice as much space to explain as the original monoid definition
15:46:26 <EvanR> and still doesnt explain whether its a set or type!
15:46:30 <phadej> EvanR: :)
15:46:39 <Tuplanolla> Your categories also depend on your concept of a collection, phadej.
15:47:00 <monochrom> It's lasagna all the way down.
15:47:17 <phadej> Tuplanolla: honestly, my head explodes when one starat talk about small & big categories (small categories = sets)
15:47:22 <EvanR> is a category a set or a type. answer: its a category...
15:47:32 <EvanR> sorted
15:47:58 <phadej> > A category C is called small if both ob(C) and hom(C) are actually sets and not proper classes, and large otherwise.
15:48:00 <lambdabot>  <hint>:1:30: error: parse error on input ‘if’
15:48:07 <phadej> but what that implies, no idea
15:48:11 <jared-w> bbear: your getFromMaybe function should be reconsidered
15:48:12 <Tuplanolla> I'll ignore the problem if you start using the term hom-sack, phadej.
15:48:22 <EvanR> that definition assumes you have some working set theory and are using it for something
15:48:42 <phadej> EvanR: it's not a definition, only an intuition giver, I guess
15:48:44 <bbear> jared-w: why there is no lookupBy in the prelude ? That would come handy
15:48:59 <bbear> I don't know of a crying smiley
15:49:12 <jared-w> ;-;  <-- is my favorite
15:49:28 <EvanR> bbear: can you just write the function yourself in various ways, would get you more practice with haskell at least
15:49:37 <EvanR> moreso than complaining in here
15:49:43 <monochrom> phadej: "The category of monoids" is not going to be a small category because you can't have a set of all carrier sets. That's basically the reason we have that distinction.
15:49:45 <bbear> then ;-; it would have saved 4 hours of my week (half-crying, half-smiling)
15:50:02 <EvanR> four hours
15:50:08 <jared-w> Anyway, you really should reconsider why you're using getFromMaybe in your code
15:50:09 <bbear> yes maybe I could even contribute in some way.
15:50:09 <EvanR> you think thats all you need to spend practicing :)
15:50:19 <bbear> jared-w: I don't see why this is so relevant
15:50:25 <EvanR> try years
15:50:40 <jared-w> It's an indicator that you have a fundamental misunderstanding of why the Maybe type even exists
15:50:40 <bbear> jared-w: that's the smallest of my concerns right now. I just do the job I want.
15:50:52 <bbear> It just do the job I want*=
15:51:02 <bbear> jared-w: that's just a peculiar thing in a peculiar context.
15:51:06 <EvanR> nlab doesnt mention "the category of monoids" anywhere so it doesnt exist
15:51:14 <phadej> monochrom: I kind of get it, but I haven't seen much distinction between small/large categories in their treatments
15:51:26 <monochrom> True
15:51:33 <bbear> jared-w: I don't mean it as a canonical use case of the Maybe monad
15:51:44 <bbear> I say that to reassure you
15:51:55 <EvanR> phadej: i have a feeling it really doesnt matter
15:52:04 <bbear> But there is similarity with some NULL pointer somewhere I must tell you
15:52:15 <bbear> in case you didn't notice.
15:52:21 <phadej> monochrom: the only analogy I have is functional analysis (where things in infinite-dimensional spaces aren't as trivial as in finite ones)
15:52:40 <jared-w> That's beside the point. Maybe is one of the types that help eliminate even needing to think about null pointers as a concept
15:53:12 <bbear> yes indeed, that is an elegant replacement.
15:53:28 <jared-w> You're also using x::Int like :: actually casts the x (which it doesn't)
15:53:39 <bbear> (read x::Int)
15:53:45 <bbear> that's to map a string to an int
15:53:55 <bbear> that's basic and do the job again
15:54:07 <maerwald> Maybe is not there ti avoid null pointers as a concept
15:54:08 <bbear> I'm not sure what I am even doing when I do that. But it wors.
15:54:10 <maerwald> the GC is
15:54:12 <bbear> works
15:54:52 <Tuplanolla> Is that really the case, phadej? Intuition aside, I've found that infinite-dimensional things tend to have a lot less structure than finite-dimensional ones.
15:54:53 <EvanR> its funny that null pointers are getting a bad rap here
15:54:56 <jared-w> maerwald: You still have NPEs in Java. GC is not sufficient alone to avoid thinking about null pointers. The fact that a type can indicate "may not return a valid result" is what really helps prevent NPEs and things like that
15:55:06 <EvanR> because... the whole idea of a pointer is to blame
15:55:18 <maerwald> jared-w: Java has null, haskell doesn't, unless you mean "undefined", but that's not null
15:55:28 <jared-w> http://lpaste.net/356917 but yeah... lots of issues in here
15:55:29 <EvanR> you could have pointers without a concept of null pointer, and it would be just as bad
15:55:31 <maerwald> so the comparison is not particularly correct
15:55:43 <EvanR> even worse probably
15:55:54 <phadej> Tuplanolla: I don't remember the details anymore, e.g. some properties imply each other in finite-setting, but not in infinite one
15:56:17 <bbear> jared-w: I would like you to point them out.
15:56:19 <phadej> Tuplanolla: I suppose something like that might be with small/large categories
15:56:25 <bbear> It is only meant to be a script
15:56:43 <jared-w> maerwald: I suppose I should've clarified. In Haskell, if you had no type system strong enough to properly support something like Maybe, then you would have to check whether or not there was a valid result or a "nothing". If you forgot to check that, you could cause a haskell equivalent of a NPE. (that is, if haskell's type system was too weak for a Maybe)
15:57:03 <bbear> jared-w: I don't see the real problem as it compiles.
15:57:14 <maerwald> jared-w: but null pointers are really not there to do what Maybe does, nor the other way around
15:57:27 <bbear> any program that is compiling is isomorphic to another program doing the same job and compiling right :p ?
15:57:30 <EvanR> haskells equivalent of NPE is "prelude: undefined" with no stack trace, which can totally happen
15:58:07 <EvanR> bbear: job equivalence eh
15:58:21 <jared-w> Right... I wasn't the one that brought up null pointers in the first place, I was just attempting to continue with it
15:58:22 <ertes-w> haskell's equivalent to an NPE is an NPE
15:58:43 <EvanR> java bridge or what
15:58:47 <ertes-w> if you disagree, have some fun with Foreign.Ptr for a change =)
15:58:48 <bbear> ertes-w: yeh
15:58:57 <bbear> good to go
15:59:00 <jared-w> To attempt to give a better explanation of why writing an unsafe fromMaybe function is a terrible idea
15:59:07 <EvanR> FFI throws an error if you try to dereference a null pointer??
15:59:12 <bbear> jared-w: why is that unsafe ?
15:59:16 <bbear> (it type -check)
15:59:25 <ertes-w> well, ok
15:59:37 <ertes-w> SIGSEGV is worse than an NPE though =)
15:59:42 <bbear> jared-w: I can use fromMaybe instead but I didn't know it at that time.
15:59:47 <jared-w> Type checking is not a magical solution to prevent writing stupid code
16:00:00 <EvanR> not yet at least
16:00:02 <jared-w> bbear: fromMaybe does not exist because that defeats the purpose of maybe
16:00:03 <ertes-w> and since you can catch SIGSEGV, you could convert it to an NPE =)
16:00:06 <jared-w> :t fromMaybe
16:00:07 <lambdabot> a -> Maybe a -> a
16:00:15 <jared-w> *sigh* nvm, it exists
16:00:32 <EvanR> ertes-w: that... doesnt sound right
16:00:55 <bbear> ok so what  would you propose instead ?
16:01:02 <jared-w> EvanR: NPE is just a certain exception. Just catch all exceptions and then throw the NPE manually :p
16:01:07 <MarcelineVQ> jared-w: it doesn't defeat the purpose of Maybe :X
16:01:30 <jared-w> You're basically using a fromMaybe but you're doing so in a way that hides the fact that you're using a "base case." Using fromMaybe "NOTHING" is at least better
16:01:33 <duncan^> phadej: Nice blog post. I've stolen it.
16:01:49 <phadej> duncan^: ?
16:01:51 <ertes-w> EvanR: it is, but i have to go now…  bye =)
16:01:57 <jared-w> but pretending to unsafely extract out of a maybe is just weird
16:01:59 <MarcelineVQ> It's just what you do when you're done with the "might fail" part of your work
16:02:15 <phadej> duncan^: ah, by bartosz
16:02:22 <duncan^> phadej: the one you linked above about monoids, yea
16:02:31 <phadej> sorry, I switched context already :)
16:02:31 <jared-w> MarcelineVQ: http://lpaste.net/356917 Did you see the code here?
16:02:48 <bbear> jared-w: I do that
16:03:26 <bbear> getFromMaybe x = case x of Nothing -> "UNKNOWN"; Just y -> y
16:03:31 <MarcelineVQ> No, I'm speaking generally
16:03:32 <glguy> Instead of 'fmap (\x -> read x::Int) getLine', use readLn
16:03:38 <bbear> that's just what most programmers are writing :p
16:04:14 <jared-w> Right. Maybe you'll see what I'm trying to get at better if you saw it? Or am I just explaining everything wrong?
16:04:18 <glguy> instead of mapM (\_ -> getLine) [1..nelem], use replicateM nelem getLine
16:04:30 <bbear> no ok
16:04:34 <bbear> yes
16:04:38 <bbear> replicateM
16:04:42 <bbear> (I'm noting carefully
16:05:42 * hackagebot threepenny-editors 0.3.0 – Composable algebraic editors – https://hackage.haskell.org/package/threepenny-editors
16:05:44 <maerwald> golfing begins
16:06:08 <glguy> readLn isn't about golf, but getting prompt errors
16:06:08 <Axman6> 4
16:06:26 <jared-w> 12
16:07:04 <Axman6> I was golfing
16:07:26 <jared-w> (☞ﾟヮﾟ)☞
16:09:57 <bbear> I don't get how it works but that's 
16:10:02 <bbear> so I just do readLn
16:10:12 <bbear> the compiler cannot say what type is it
16:10:13 <Axman6> what don't you understand?
16:10:23 <bbear> later I use it as an Int
16:10:35 <bbear> and it just compile without any conversion needed ?
16:10:42 <Axman6> yep
16:11:18 <bbear> from this moment the type is fixed right ?
16:11:41 <bbear> I mean. the type is inferred from later use, right ?
16:11:50 <bbear> (I suppose so)
16:11:54 <bbear> (let's continue )
16:12:09 <Axman6> readLn has type Read a => IO a, which means the value returned is _anything_ of type a where a implementes Read. Later, you use it as an Int, so the compiler then knows actually you really meant a specific a, ie, Int and it then knows that that value is an Int (this is at compile time, all types are fixed at compile time)
16:12:15 <Axman6> yeah exactly
16:12:41 <Axman6> basically, readLn :: IO Int is a specialised type of readLn :: Read a => IO a
16:13:18 <bbear> that's quite amazing
16:13:38 <Axman6> what is importsnt to understand though is that you can't then also use the same value later as a Bool or a Double
16:13:39 <phadej> bbear: that's the cool thing about global type-inference
16:13:43 <Axman6> important*
16:14:13 <bbear> Axman6: are you sure ?
16:14:19 <Axman6> yes
16:14:33 <bbear> Axman6: but not as a string ?
16:14:34 <Axman6> it cannot be both an Int and a Bool (the value returned by readLn that is)
16:14:45 <Axman6> no, can't be a String either
16:14:46 <jared-w> You can't use it as anything else other than an Int if you first use it as an Int
16:14:49 <bbear> yes
16:15:00 <bbear> jared-w: is more right I think.
16:15:09 <jared-w> You're not reading in an int, you're reading in a type of IO a. It turns into an IO Int later and from then on is fixed
16:15:10 <Axman6> but, readLn can be used to read other values of different types
16:15:17 <phadej> ^ that
16:15:22 <phadej> important note
16:15:24 <bbear> Axman6: I suppose
16:15:29 <jared-w> bbear: I am saying the same thing as Axman6
16:15:35 <Axman6> yeah, we said the same thing
16:16:15 <bbear> ha sorry didn't read teh negation
16:16:20 <bbear> I saw can
16:16:23 <bbear> you wrote can't
16:17:25 <bbear> http://lpaste.net/356919 (looks better)
16:17:26 <bbear> omg
16:17:54 <bbear> you don't have all the burden of other languages
16:18:12 <bbear> random ppl can still implement new functions in the Prelude I suppose
16:18:28 <jared-w> Not really
16:18:39 <bbear> yes, I mean, tihs is not discouraged.
16:18:46 <bbear> Take the idea of lookupBy
16:18:49 <jared-w> It's just that you can write functions that work on generic types or special types. Nothing is stopping you from writing a function that works on Maybe
16:19:10 <jared-w> Just because something is inside a Data.Maybe module doesn't mean I can't write a function that works on Maybe type
16:19:46 <jared-w> Things in haskell are not locked inside classes and objects like they are in Java because it's a different philosophy of working with different data
16:21:07 <EvanR> that fact is related to a ADT vs OOP object dichotomy
16:21:36 <EvanR> https://www.cs.utexas.edu/users/wcook/papers/OOPvsADT/CookOOPvsADT90.pdf
16:33:06 <monochrom> Type inference is timeless. There is no "determined by later". It is rather "determined by somewhere".
16:35:14 <EvanR> show her how much you love her with a 24K most general generalization from hindley milner
16:35:29 <jared-w> amazing
16:35:33 <monochrom> haha
16:36:05 <monochrom> "You are my [a]"
16:36:41 <monochrom> "Oh great you're saying I'm empty. I'm leaving you now."
16:36:50 <jared-w> "You are my polymorphic list"
16:37:30 <EvanR> type inference has determined your relationship is type Void
16:37:41 <jared-w> "No no trust me, it's romantic and funny! See this nerd on the irc (yes I'm one too shut up) made this really funny joke about... where are you going?"
16:37:45 <MarcelineVQ> "Oh why did I enter a realtionship with a Simple Type!"
16:38:32 <glguy> jared-w: She's not your type
16:39:09 <Tuplanolla> That's what many people think of at first when I mention type theory, no joke.
16:39:13 <jared-w> Maybe I just needed more :: Love annotations
16:39:18 <EvanR> hahaha
16:39:53 <jared-w> Actual conversation snippet: "I'm making relationship jokes by punning with type theory on an IRC chat. I've hit full nerd"
16:40:24 <jared-w> gf: "BABE, I THOUGHT I WAS BAD AT PACKING"   (as in, I should be packing because I move into my new apartment tomorrow. But instead I've spent most of the day on the IRC screwing around)
16:40:41 <EvanR> dont try to explain IRC to people IRL
16:40:54 <jared-w> Luckily I only own about 10% as much as she does, so I'm banking on that :p
16:41:07 <glguy> You'll need some {-# UNPACK #-} pragmas later
16:41:39 <jared-w> glguy: thanks. I'm just gonna stuff those somewhere in a box and surely I'll be able to find them later when I need 'em
16:45:39 <jared-w> But yeah I should probably get off my ass and actually pack... see y'all
17:17:45 <plakband> Is it possible to have ghc suggest functions for type holes?
17:19:28 <mniip> unlikely
17:19:45 <mniip> it's very hard to make such suggestions both useful and decidable
17:22:04 <EvanR> paperclip, "I see you're trying to write a function of type [a] -> [a]"
17:22:18 <plakband> mniip: even if you were to restrict it to functions that return the exact missing type?
17:22:30 <EvanR> or Integer -> Integer
17:22:54 <plakband> mniip: although i could imagine that not being that useful
17:22:56 <mniip> plakband, define exact?
17:23:19 <mniip> denotationally equal? judgementally? unifiable?
17:23:20 <EvanR> it suggests const 9
17:23:53 <mniip> EvanR, const 9 :: [a] -> [a], exactly
17:23:55 <mniip> :)
17:24:10 <EvanR> Integer -> Integer
17:24:21 <mniip> nah I mean in some sense it fits
17:25:01 <plakband> mniip: you're missing a Bool -> Bool, so ghc suggests (&& x)
17:25:11 <mniip> what's x?
17:25:25 <EvanR> a random variable from the local env!
17:25:36 <EvanR> haha
17:26:07 <mniip> what I actually wish typed holes could do is dump the local assumptions
17:26:25 <plakband> something to be defined
17:26:40 <mniip> including types of bound variables using the same (!) unification variables as the printed type
17:27:04 <mniip> then TDD would be much easier
17:28:08 <mniip> plakband, I suspect there's at least a hundred identifiers that can be sufficiently partially applied to match with Bool -> Bool
17:28:19 <mniip> in Prelude
17:28:48 <plakband> of course, but in your own application you'd likely have many fewer candidates
17:28:59 <mniip> no, you'd have all of them and even more
17:29:10 <mniip> unless you import Prelude hiding (everything)
17:29:20 <EvanR> do you get exactly 1 suggestion?
17:29:29 <EvanR> wouldnt be that bad because it would be easy to ignore it
17:29:44 <EvanR> if its 5 useless suggestions... ill call bullshit
17:30:39 <EvanR> what goes in a type hole is usually an expression other than one function with one partial arg applied
17:30:56 <EvanR> other than f x
17:31:38 <EvanR> if it somehow knew what you were trying to do, and wrote the code for you, ... now were talking!
17:31:39 <monochrom> I think typed holes already dump local assumptions. At least enough of them for me.
17:32:48 <monochrom> "f x y = _" causes "y :: t1", "x :: t2", and "f :: t2 -> t1 -> t"
17:33:29 <Axman6> plakband: I doubt that's true. As Haskell functions tend to be incredibly generic, it's impossible to provide good suggestions
17:35:25 <Axman6> if you have Prelude in scope, then there are thousands of funtions that will fit in most locations
17:36:02 <plakband> yeah thanks for answering my question
17:36:09 <plakband> i can see how it could be difficult
17:36:48 <plakband> useful code suggestions would be really neat
17:38:01 <plakband> alas
17:38:32 <mniip> if an algorithm could figure out what sugestions were useful
17:38:36 <mniip> you wouldn't be writing programs
17:39:00 <monochrom> Reductio ad unemploymentum.
17:40:33 <Axman6> would would be good is completion which also took types into account
17:41:51 <Axman6> so if you type map in an IO do block, it would suggest mapM, mapM_, but not map because it can't possibly type check
17:42:54 <plakband> is the reason some IDEs can do that just because the languages are less polymorphic?
17:43:10 <Axman6> yeah that's part of it
17:43:11 <monochrom> No.
17:43:25 <monochrom> Well, I guess yes, that's an indirect way to put it.
17:43:42 <monochrom> Those some IDEs only work for OOP, which is very restrictive.
17:43:45 <Axman6> if you're writing Java, completing methods is as simple as knowing what methids can be applied to that object and any of the ones it inherits from
17:44:23 <monochrom> You write "x.", and then the IDE only needs to look up the class of x and dump all methods of that class (and superclasses).
17:44:33 <boxscape> If you wrote the first argument first, it would be possible in haskell as well to figure out what functions could typecheck with that argument, I would think. That's esesntially what "x." in OOP does, isn't it?
17:45:02 <boxscape> I guess it'd still be less performant than simply going through all methods of a class
17:45:39 <monochrom> This also means the IDE will never bother to guess, suppose you write "5", that maybe you want to wrap "Math.sin(" ")" around it.
17:47:35 <EvanR> OOP IDE's "the power of the dot"
17:48:11 <plakband> imagine lens autocompletion
17:48:31 <pikajude> can you implement early return using the cont monad
17:49:00 <monochrom> Yes.
17:49:15 <pikajude> nice
17:50:03 <mniip> yeah, in comparison with OOP languages,
17:50:15 <mniip> suggesting haskell functions would be like suggesting blocks of code in java
17:53:21 <plakband> from the autocomplete-haskell atom plugin docs: You can show auto-completions for hole _. This will try to find replacements based on type. It's no magic though, so if hole has some crazy type, it won't find anything.
17:59:36 <Axman6> yeah, I'd be surprised if you wrote _ (.) id you'd actually get foldr as a suggestion
18:00:26 <monochrom> heh
18:13:50 * hackagebot debian 3.93.2 – Modules for working with the Debian package system – https://hackage.haskell.org/package/debian
18:23:56 <sveit> is there a way to get stack to just use the latest versions of packages on hackage (in some particular project)?
18:30:20 <Axman6> not really, if you want something outside the snapshot, you need to give an explicit version. this is part of the point of stack, reproducible builds
18:32:06 <sveit> ok, but when i am iterating on the early stages of a library i like to make sure it works with the most up-to-date versions of packages on Hackage, and i suspect others like to do this as well. how do people accomplish this workflow?
18:33:07 <Axman6> well, there are stackage nightlies too, but you can also just build with cabal I guess
18:33:15 <Axman6> (CI is really where you should be doing this stuff anyway)
18:36:11 <sveit> for example, no stackage snapshot that i am familiar with has containers 5.10.2
18:36:21 <bhrgunatha> @pl \x -> length . filter (uncurry (==)) . zip x
18:36:21 <lambdabot> ((length . filter (uncurry (==))) .) . zip
18:44:24 <sveit> also, what is the usecase for a git repository in the packages section of a yaml file with extra-dep: false?
18:44:32 <sveit> stack.yaml file*
19:22:54 * hackagebot unliftio-core 0.1.0.0 – The MonadUnliftIO typeclass for unlifting monads to IO – https://hackage.haskell.org/package/unliftio-core
19:22:54 * hackagebot unliftio 0.1.0.0 – The MonadUnliftIO typeclass for unlifting monads to IO (batteries included) – https://hackage.haskell.org/package/unliftio
19:25:34 <joehh> is there any reason why "Preprocessing library xxx" when running cabal build would start taking minutes to run with cpu sitting at 100%?
19:26:27 <joehh> using ghc 8.0.2 and cabal 1.24.0.2 under nix
19:27:30 <joehh> it used to take a few seconds
19:29:53 <slack1256> I would guess it is compiling or linking
19:30:14 <slack1256> what does htop say?
19:32:29 <joehh> cc is using 100% of cpu
19:33:18 <joehh> if it was linking, I would expect to see ld or similar running
19:34:19 <joehh> I also would not expect it to be compiling the library as no changes were made to it, just a trivial change (adding putStrLn "hello") to the executable using the library
19:34:21 <slack1256> Mmm I would argue linking by cc is more common than we think
19:34:45 <geekosaur> 'preprocessing the library' is building an executable from the Setup.hs, iirc
19:34:59 <slack1256> in fact I don't know how to link binaries that isn't through (g)cc
19:35:29 <joehh> could something make that drastically slower?
19:36:03 <geekosaur> shared objects can be sanely linked without using cc. executables, it's something of a bad idea because (g)cc knows what extra things the system needs (several static objects on most systems, libc, and sometimes other libraries)
19:37:02 <geekosaur> I think there was another recent report of something like this that came down to a change in nix
19:38:01 <geekosaur> iirc it started using the windows-style response file mechanism to run gcc and a gcc bug makes that take 100% cpu and a ridiculous amount of time?
19:38:14 <joehh> I'll ask in #nixos
19:38:16 <joehh> thanks
19:38:36 <pacak> ps ax to check what exactly it's doing?
19:39:19 <boxscape> so, I updated my arch system a few hours ago, and now, when I try to run "stack ghci", it say "no compiler found, except minor version match with ghc-8.0.1 [...] try running stack setup", but when I run "stack setup", I get "Unable to find installation URLs for OS key: linux64-ncurses6-nopie". Does anyone know what to do about that?
19:40:32 <boxscape> uh, nevermind, looks like I just needed to delete the global stack.yaml
19:40:59 <joehh> it is running with an argument of a ghc_1.rsp file in a temp directory
19:41:13 <joehh> that file is 833 lines long - not sure if that is a normal sort of length or not
19:41:25 <boxscape> ...or not, the error message is still there -.-
19:49:54 <pikajude> oooooh, using ContT I can also implement a fallthrough return!
19:50:12 <pikajude> genius
19:50:48 <EvanR> its funny that continuations were once thought to be the key feature to enable "cool stuff", but then it became a side show to lazy evaluation
20:32:48 <wespiser> EvanR: yea, it seems like we've passed over continuations as a serious data structure to implement programming languages, at least in Haskell
20:36:41 <Axman6> the join points stuff coming in GHC looks really interesting (SPJ's talk on it discusses some of the pros and cons IIRC)
20:36:53 <Axman6> it = continuation based compilation
20:37:24 <EvanR> GHC is at it again
20:37:31 <EvanR> you never know what its going to do next
20:40:58 <Axman6> that crazy GHC, what a cad
20:48:30 <Lokathor> what an absolute nutter
21:03:58 <lin_> were should i look if i encounter error using cabal install/stack install?
21:04:25 <lin_> ''gcc' failed in phase 'Linker'.'
21:07:01 <ammazza> lin_: missing native libraries?
21:07:29 <ammazza> if you scroll up don't you see messages about missing symbols?
21:07:43 <lin_> yes
21:07:59 <lin_> all called -lHS*
21:08:44 <ammazza> mmmm... that's not what I was thinking about...
21:09:18 <ammazza> sorry.
21:09:22 <lin_> i see what you mean
21:09:58 <geekosaur> arch?
21:10:03 <lin_> yes
21:10:15 <geekosaur> you need to force -static or ditch arch's ghc
21:10:23 <geekosaur> er force -dynamic
21:10:30 <geekosaur> statci libs were removd, ghc still defaults static
21:10:38 <geekosaur> brilliant arch devs :/
21:12:08 <pacak> https://cdn-images-1.medium.com/max/455/1*snTXFElFuQLSFDnvZKJ6IA.png
21:12:27 <Sh4rPEYE_> Does anybody know any good config files for Yi? I'm trying to get started with it... Basically anything that would help normal use (highighting, intendation, ...)
21:12:47 * pacak uses distributive provided ghc only to compile xmonad.
21:12:50 <lin_> geekosaur: thanks, i would not have expected problems to be _there_
21:13:55 <geekosaur> it's also claimed the archhaskell setup still works, since the people maintaining it actually know what they are doing
21:14:24 <geekosaur> (which exists in part because this isn't the first time arch has broken the ghc in the main repo...)
21:16:19 <nshepperd_> lin_: pacman -S ghc-static
21:16:52 <lin_> nshepperd_: thanks trying it right now
21:17:16 <geekosaur> only works for the libs with ghc itself, though
21:17:54 <geekosaur> other haskell library packages were modified to remove their static libs and not provide any way to get them back (maybe they fixed this, look for additional -static packages?)
21:18:01 <nshepperd_> Yes, so don't install any other haskell-* packages
21:18:26 <lin_> i try to mainly use stack for the rest
21:21:50 <nshepperd_> I never want distro packages anyway, because they interfere with installing the bleeding edge new hotness :p
21:24:36 <lin_> I am tempted to deinstall ghc-static and XMonad and just compile everything myself...
21:25:25 <EvanR> call a type T self similar if its isomorphic to Either T T
21:25:40 <EvanR> are there are self similar types in haskell
21:25:52 <geekosaur> lin_, you need a custom build script for xmonad in that case
21:26:14 <geekosaur> it only knows about ghc, not about other build mechanisms
21:26:33 <boxscape> [Bool] maybe? Having either just means putting an extra boolean at the end
21:26:33 <lin_> is cabal not enough?
21:26:41 <boxscape> ^^ EvanR 
21:26:59 <EvanR> nice
21:29:36 <geekosaur> it doesn't use cabal either
21:29:36 <geekosaur> xmonad runs ghc directly to build your config
21:29:37 <EvanR> er... lets check by implementing the conversions
21:29:37 <geekosaur> ...unless you have a custom build script (~/.xmonad/build, takes as parameter the destination binary to create, you get to figure out what's needed to do the build and update the specified binary)
21:29:37 <boxscape> ok, I just did a fresh arch install and I *still* get "Unable to find installation URLs for OS key: linux64-ncurses6-nopie" when doing stack setup :/
21:29:37 <iam1> im having that problem box
21:29:37 <boxscape> good to know that I'm not alone
21:30:00 <iam1> arch just updated the gcc to include the PIE flag
21:30:00 <iam1> i think thats whats causing this
21:30:00 <geekosaur> that sounds like a stack issue
21:30:05 <iam1> it is
21:30:05 <boxscape> I see
21:30:06 <EvanR> boxscape: http://lpaste.net/356928
21:30:46 <boxscape> EvanR: hm, yeah, that's a good point
21:31:00 <iam1> i put something on the stack github, hopefully they'll fix it
21:31:07 <nshepperd_> boxscape: Stream Bool maybe. Require infinite
21:31:09 <MarcelineVQ> boxscape, iam1: it's known at least, no mention of a patch atm https://github.com/commercialhaskell/stack/issues/3268
21:31:16 <MarcelineVQ> ah
21:31:22 <EvanR> i guess you just pick Left or Right arbitrarily?
21:32:01 <boxscape> uh, true. my first instinct would say that it isn't isomorphic if you do that, but it seems to work out with the functions...
21:32:11 <EvanR> ah no
21:32:24 <lin_> geekosaur: http://xmonad.org/intro.html claims that everything could be done using cabal only
21:32:42 <boxscape> ah, yeah, you get either Left [] or Right [] twice
21:32:49 <EvanR> if you do that, then to and from arent inverses
21:32:54 <boxscape> thank MarcelineVQ, by the way
21:33:16 * nshepperd_ goes one better. type SelfSimilar f a = Iso' a (f a)
21:34:22 <nshepperd_> For some Functor f i guess
21:34:47 <nshepperd_> So there's Fix f, that's the obvious solution
21:37:05 <nshepperd_> Maybe the only solution, up to isomorphism, i wonder
21:39:15 <nshepperd_> data EitherF a = Left a | Right a would be the f for EvanR's question, and Fix EitherF indeed gives you your stream of Bools
21:39:27 <mnoonan_> EvanR: you can get T isomorphic to (T,T,T,T,T,T,T) for “data T = X | Y T T” with the approach from “Seven Trees in One”. So I’d be surprised if you can’t get sums..
21:41:32 <EvanR> so Fix f gives you a self similar type for any functor?
21:41:53 <EvanR> and any a ?
21:42:21 <EvanR> or a = Fix f
21:42:51 <EvanR> 7 trees in 1 eh
21:43:29 <mnoonan_> or 13 trees in 1, if you’re greedy
21:44:13 <EvanR> it must be prime?
21:44:24 <mnoonan_> no, congruent to 1 mod 6
21:44:34 <nshepperd_> Fix f = f (Fix f)
21:45:10 <nshepperd_> Maybe not an interesting self similar type, as it does not use any properties of f
21:45:11 <mnoonan_> (because the root t of T = 1 + T^2 satisfies t^6 == 1!) 
21:49:13 * hackagebot pipes-bytestring 2.1.6 – ByteString support for pipes – https://hackage.haskell.org/package/pipes-bytestring
21:50:32 <EvanR> for the original question, functor EitherF, since we are essentially duplicating the type, it stands to reason that the type must be infinite to be self similar?
21:50:48 <EvanR> just by counting
21:50:52 <mnoonan_> right
21:51:22 <EvanR> and if its V2
21:51:24 <mnoonan_> ah, well, or uninhabitable :)
21:51:25 <EvanR> same thing
21:52:01 <EvanR> infinite... well if you think 1 2 3 are finite numbers and 0 isnt.... :)
21:52:44 <EvanR> this might be argument for why 0 is considered "non-finite"
21:56:03 <nshepperd_> 0 and infinity share the property that 2x=x
21:59:43 <jared-w> Does infinity really share that property? Just because you can say 2*infinity doesn't really mean you're doing it, does it? It's not like infinity is a "real number"
22:01:54 <EvanR> but an infinite type may be isomorphic to two copies of itself
22:02:13 <EvanR> the arithmetic of numbers was fast and loose language for that
22:02:30 <EvanR> a "finite" type cant do that because... arithmetic
22:14:18 <jared-w> ahh right, gotcha
22:14:33 <jared-w> lost the translation from numbers to types for a second. I'm with you now :p
22:15:13 <jared-w> Also it appears that xmonad has to be recompiled for every configuration change so installing it outside of stack or some other sandbox seems insane to me
22:18:38 <EvanR> heh xmonad predates stack and sandboxes
22:18:50 <EvanR> i guess that era was characterized by insanity
22:19:16 * pacak prefers xmonad kind of insanity to stack kind of insanity.
22:30:36 <penguin359> \quit
22:37:36 <Axman6> is there a term for something which may be arbitrarily large, but not infinite? is that just finite?
22:38:12 <mnoonan_> “arbitrarily large” :)
22:38:16 <mud> "arbitrarily large", heh
22:38:43 <johnw> Axman6: yeah, just finite
22:41:20 <geekosaur> lin_, only if you never create your own config. xmonad does not use, or know about, either cabal or stack (or hsenv or etc. for that matter) when building a customized config
22:45:09 <jle`> it'd be nice if i can encode schema warnings in my FromJSON instances
22:45:21 <jle`> shouldn't be too hard to implement
22:46:22 * hackagebot aivika-gpss 0.3 – GPSS-like DSL for Aivika – https://hackage.haskell.org/package/aivika-gpss
22:46:29 <_sras_> Why does this code produce a parse error when doing a stack build, but loads fine from repl (stack ghci) ? http://lpaste.net/356929
22:46:33 <jle`> like emit a warning if fields in an object that are supposed to be mutually exclusive are included
22:46:33 <Axman6> yeah I wish mechanisms for warnings were more common in Haskell, we focus on only success or failure
22:47:04 <jle`> warnings can be implemented with just some Writer-ish mechanism probably
22:47:17 <Axman6> _sras_: the return in getSome doesn't look indented enough to me
22:47:51 <jle`> it shouldn't load fine in the repl
22:47:59 <jle`> so that's indeed a mystery
22:50:39 <lambdaGrp> NondecreasingIndentation stuff?
22:51:38 <geekosaur> seems likely yes
22:52:00 <lambdaGrp> lesson learned ;)
22:52:07 <geekosaur> absent NondecreasingIndentation, lines 11-13 would be outside the do and starting a new definition
22:53:10 <lambdaGrp> but does the stack repl trigger the extension?
22:53:43 <geekosaur> stack repl would have to explicitly pass -XNoNondecreasingIndentation to stop ghci from doing it
22:54:07 <geekosaur> or pass -XHaskell2010 which disables adding the default extensions
22:55:25 <geekosaur> you can see/check this with ":showi language" in ghci
22:58:45 <_sras_> geekosaur: output of "showi language"  http://lpaste.net/356930
22:59:38 <geekosaur> yeh, the first 5 are default adds and the rest are added by 'stack ghci' likely based on the cabal file
23:01:03 <geekosaur> now I'm trying to figure out why -XNondecreasingIndentation is default in ":show language". I know why it would be in the REPL itself (forcing strict indentation is kinda stupid there, multiline mode is annoying enough as it is) but just seems like pointless different behavior for loaded code
23:02:59 <_sras_> geekosaur: I am not getting it. Does repl accept it because of the presence of NondecresingIndentation flag?
23:03:07 <geekosaur> yes
23:03:23 <geekosaur> it specifically changes the parsing rules so that kind of thing is valid
23:03:37 <geekosaur> but it's not valid for normal compiled code
23:03:48 <geekosaur> (unless you explicitly enable that extension yourself)
23:05:54 <_sras_> geekosaur: is there way to pass it while starting the repl using' stack ghci'?
23:07:00 <geekosaur> probably something like stack ghci -- -XNoNondecreasingIndentation
23:07:10 <Lokathor> remind me of the downside of marking everything as INLINABLE?
23:07:43 <geekosaur> .hi file bloat, possibly slowdowns in compiling modules using that .hi file
23:08:34 <cr1t1cal> what is the best book
23:08:39 <cr1t1cal> to learn Haskell?
23:08:48 <Lokathor> oh i was gonna give the Conan answer
23:08:56 <Lokathor> haskellbook.com is the best if you have the $60 for it
23:09:04 <cr1t1cal> Conan?
23:09:06 <_sras_> geekosaur: Had to do stack ghci --ghci-options -XNoNondecreasingIndentation
23:09:15 <cr1t1cal> Lokathor, what is the meaning of Conan?
23:09:29 <cr1t1cal> some weird guy doing late night tv shows?
23:09:34 <Lokathor> http://www.imdb.com/title/tt0082198/quotes?item=qt0446932
23:10:12 <cr1t1cal> Lokathor, that is the best book?
23:10:17 <cr1t1cal> Lokathor, conan the barbarian?
23:10:29 <Lokathor> it just reminded me of the "What is best in life?" question is all
23:10:42 <Lokathor> haskellbook.com is the best book for learning Haskell if you have the $60 for it
23:10:46 <Lokathor> there is your real answer
23:17:10 <Sh4rPEYE_> Does anybody know any good config files for Yi? I'm trying to get started with it... Basically anything that would help normal use (highighting, intendation, ...)
23:18:10 <lambdaGrp> here: https://github.com/yi-editor/yi/tree/master/example-configs
23:19:12 <Sh4rPEYE_> Thanks! I wonder how I missed that
23:20:03 <lambdaGrp> in the readme, there is a link to cutom configs on github
23:20:12 <lambdaGrp> migth be interesting too
23:21:56 <Lokathor> geekosaur, re: .hi file bloat: seems like a small price to pay?
23:22:52 <Lokathor> beyond -O an -O2, I want a -OIIIFinalMixPlusChainOfMemories
23:23:10 <Lokathor> which just acts as if every function in the package were temporarily INLINABLE
23:25:27 <dramforever> -fexpose-all-unfoldings is a thing apparently
23:25:55 <Lokathor> but i sadly doubt it has a Kingdom Hearts joke mixed in
23:27:09 <dramforever> Lokathor: We should probably have just install all library packages with -fexpose-all-unfolding
23:27:10 <johnw> i once quarupled the speed of an assembler written in Haskell by removing all the inlining; turns out GHC is smarter than we were
23:27:26 <dramforever> INLINABLE is different though
23:27:35 <Lokathor> johnw, that's the magic of INLINABLE vs INLINE
23:27:42 <johnw> yeah, it just makes the function body part of the .hi file
23:29:11 <dramforever> Has anyone got numbers on how that affects compiler speed?
23:29:46 <Lokathor> i turn on -O2 for all my projects at the start and then never think about it :S but also my projects never get too crazy large
23:36:57 <dramforever> I heard you shouldn't do that
23:37:21 <dramforever> ghc -O is like gcc -O2, and ghc -O2 is like gcc -O3
23:38:15 <osa1> anyone know why Text.Lazy.Builder doesn't have functions like intercalate that lazy text has?
23:43:02 <osa1> I have a function that generates log lines which does lots of appends and some intercalate. strict version works faster than lazy version
23:43:21 <osa1> I want to try with lazy builder but its api sucks (no intercalate, concat)
23:45:09 <dramforever> osa1: pretty sure you just need mconcat...
23:45:58 <dramforever> oh, and intercalate is probably mconcat (intersperse stuff idk_what_exactly_you_want)
23:51:50 <osa1> surely I can implement this stuff myself but it's not as convenient as having same function in Data.Text.Lazy
23:52:29 <osa1> err, having same functions in Data.Text.Lazy.Builder
