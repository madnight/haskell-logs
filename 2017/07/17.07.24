00:08:01 <siraben> >
00:08:50 <cocreature> <
00:09:09 <Axman6> most pleasing diff ever
00:09:44 <MP2E> haha :)
00:11:21 <siraben> It's so quiet...
00:12:18 <platz> is there no longer :set prompt2 in 8.2.1 ghci?
00:12:52 <platz> ahh, maybe it's prompt-cont now
00:12:55 <cocreature> eyp
00:12:56 <platz> a lot has changed
00:12:57 <cocreature> *yep
00:14:18 <platz> guessi can't share a ghci.conf between ghc versions anymore
00:15:08 <cocreature> yeah, that’s kind of annoying
00:15:34 <cocreature> luckily for me, the customizations I use didn’t change :)
00:36:35 * hackagebot hw-excess 0.1.0.1 – Excess – https://hackage.haskell.org/package/hw-excess
00:53:36 <phz_> hey peeps
00:53:55 <phz_> I just read through a backpack article, and I still don’t get why it exists
00:54:04 <phz_> the Str example could be easily implemented with typeclasses
00:54:11 <phz_> so why the need for a new tool?
00:59:51 * hackagebot servant-docs 0.11 – generate API docs for your servant webservice – https://hackage.haskell.org/package/servant-docs
01:03:33 <cocreature> phz_: one difference is that backpack has zero runtime overhead. typeclasses are not always specialized so there can be an overhead to using them
01:04:43 <ongy> will backpack be ready with 8.2?
01:04:45 <phz_> hm, yeah, I tend to think in Rust nowadays, because in Rust, there’s no runtime overhead over that
01:04:50 <phz_> it’s there, yes
01:04:55 <phz_> I just don’t see the point of using it
01:05:01 <phz_> the Str example makes me very dizzy
01:05:09 <phz_> it’s like overengineering to me
01:15:51 <will_> Can anyone help a noob with a Yesod question?  Trying to run a DB query in a subsite, after some googling to get the correct type signature for the subsite handler I arrived at the following, which gives me a type error (details in the link): http://lpaste.net/357162
01:17:48 <Franciman> Hello
01:17:59 <Franciman> Is there somebody using haskell for Mac?
01:18:18 <phz_> yes
01:18:22 <phz_> even at work 
01:18:27 <phz_> we’re working on Mac and deploying on linux ;)
01:18:30 <fkbm> Maybe it would be best to ask the problem ::)
01:18:35 <phz_> sure it’d be
01:19:04 <Franciman> does the IDE indent the code ?
01:19:12 <Franciman> automatically?
01:19:18 <fkbm> What IDE?
01:19:23 <liste> Haskell for Mac
01:19:25 <phz_> Franciman: well, my neovim does.
01:19:38 <phz_> liste: haha
01:19:45 <Franciman> phz_, which plugin do you use?
01:19:49 <phz_> Haskell for Amiga and C64 doesn’t, it’s too old!
01:19:51 <Franciman> Because all I've tried suck
01:19:58 <phz_> Franciman: the “official one>
01:19:59 <phz_> ”
01:20:00 <phz_> haskell-vim
01:20:12 <phz_> https://github.com/neovimhaskell/haskell-vim
01:20:12 <cocreature> phz_: “haskell for mac” is the name of an ide, it’s not a joke :)
01:20:14 <phz_> this one
01:20:22 <phz_> cocreature: oh
01:20:31 <phz_> that sounds so insanely funny though :D
01:20:39 <cocreature> http://haskellformac.com/
01:21:08 <ventonegro> I thought Haskell for Mac was being used for work
01:21:26 <phz_> ventonegro: I use neovim, a colleague uses vim, another uses emacs and Visual Code
01:21:31 <phz_> we’re in 2017
01:21:33 <phz_> ;)
01:21:49 <fkbm> Have you tried spacemacs?
01:21:49 <phz_> there’s even a dude using an editor called BBEdit haha
01:21:57 <phz_> no, I haven’t
01:22:03 <phz_> but that guy using emacs told me about it
01:22:10 <phz_> “it’s like vim, but in emacs”
01:22:18 <phz_> which I respond with “then, use (neo)vim!”
01:22:19 <phz_> :–’
01:22:38 <phz_> I wrote an article about my workflow yesterday! :)
01:22:42 <fkbm> Yeah, kinda like that. :) I think I tried (neo)vim when it was „younger”. :)
01:22:59 <phz_> https://www.reddit.com/r/rust/comments/6p2yi4/on_programming_workflows/
01:23:02 <ventonegro> Does anybody know if Windows will benefit from GHC's smaller binaries (-fsplit-sections)?
01:23:08 <fkbm> Thanks phz_ ! :)
01:23:31 <merijn> ventonegro: Seems like the kinda question better suited to the mailing list :)
01:24:09 <merijn> ventonegro: Since this channel skews rather strongly to *nix and it's a rather niche question so lots of people who might know will miss the question here
01:24:40 <ventonegro> merijn: I see
01:25:41 * hackagebot packdeps 0.4.4 – Check your cabal packages for lagging dependencies. – https://hackage.haskell.org/package/packdeps
01:25:43 <fkbm> Nice phz_ ! I also use some of those packages for the VIM config.
01:26:00 <phz_> fkbm: :)
01:26:04 <phz_> yeah, those are pretty amazing
01:26:20 <phz_> even the “little nits”, like startify, are candies :P
01:26:27 <fkbm> ;)
01:26:32 <phz_> though I need to fix those images’ widths goddammit :D
01:52:53 <merijn> phz_: You really do, the Haskell one is way out of bounds, even on my huge ass display
01:53:09 <merijn> phz_: What resolution is that?! 10k?
01:53:48 <kuribas> phz_: how difficult is using haskell on a mac?  Can you mix it with objective-C code?
01:54:22 <merijn> kuribas: Using Haskell on a mac is trivial, although I've never mixed it with objective-c
01:54:40 <merijn> kuribas: What makes you think you need objective-c? (Unless you wanna do like cocoa GUI apps)
01:54:52 <kuribas> merijn: yeah, cocoa GUI apps :)
01:55:10 <kuribas> merijn: And I got a question if my haskell library can be used for a cocoa or ios app.
01:55:11 <merijn> kuribas: Well, Objective-C can call/be called by C, so you can just use the FFI
01:55:33 <alexbiehl> kuribas: http://hackage.haskell.org/package/language-c-inline
01:55:34 <merijn> kuribas: Shouldn't be trickier to use Haskell than it would be to use C
01:55:50 <kuribas> Wouldn't it be hard to integrate the object files etc in the xcode IDE?
01:56:14 <merijn> kuribas: I doubt it? Why would that be?
01:56:34 <merijn> tbh, I don't use xcode, but I don't see why it'd be harder than using any other C library
01:56:41 <kuribas> ehm, I thought xcode had limited support for other languages...
01:57:26 <merijn> kuribas: Haskell's FFI follows the C ABI (else it wouldn't be an FFI), so far as xcode is concerned it just looks like a C library
01:57:40 <kuribas> hm, okay.  I should try it then.
01:57:45 <merijn> kuribas: Whatever the source languages was is irrelevant, because those don't exist in object files
01:58:12 <merijn> kuribas: You could always write your GUI in Objective-C and just use whatever IPC mechanism to talk with a GUI-less Haskell backend too
01:58:31 <merijn> kuribas: All the usual *nix IPC (pipes, unix sockets, regular sockets, etc.) all just work
01:58:51 <kuribas> merijn: that would give overhead though.
01:59:18 <merijn> kuribas: How low latency are your GUIs that that is too much overhead?
01:59:21 <kuribas> For example drawing to a window would need to go through the pipes.
01:59:49 <kuribas> merijn: if it is custom drawing code it might matter.
01:59:55 <merijn> hmm, maybe
02:00:10 <kuribas> On the other hand, that's how X windows works..
02:00:31 <cocreature> if it’s custom drawing code, that could live completely on the objective-c side and you only send the data that should be drawn
02:00:51 <cocreature> ofc you can come up with scenarios where the overhead is too large but I doubt that’s often the case
02:01:54 <kuribas> you don't like cross platform toolkits like Qt and wxWidgets?
02:03:17 <kuribas> phz_: why not code directly in linux?
02:05:06 <kuribas> I suppose I could write my app with reactive-banana, and hook to events in a pure objective-C GUI backend.
02:05:31 <merijn> So the GHC8.2 release notes mention "Improved runtime system performance on NUMA systems"
02:05:37 <merijn> Any clues what that entails?
02:07:05 <cocreature> merijn: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/runtime_control.html?highlight=numa#rts-flag---numa
02:07:21 <mbrock> if a top level function has a constraint Foo f => ..., and I then write a local let function with a type signature that mentions f, isn't "ScopedTypeVariables" supposed to make those mentions of f mean the same type?
02:07:50 <whoman> kuribas, how come?
02:07:52 <merijn> mbrock: ScopedTypeVariables requires explicit opt in
02:08:15 <merijn> mbrock: you need to use "forall <variables here> ." in the signatures of functions where you want to enable it
02:08:33 <kuribas> whoman: sorry?
02:08:55 <mbrock> merijn: ahhh, thanks!
02:09:12 <kuribas> whoman: what's your question?
02:09:14 <mbrock> adding `forall f. Foo f => ...' make it compile
02:09:43 <merijn> mbrock: Otherwise enabling it might break half the functions in your file as you try and fix that one that was broken, which is...annoying :)
02:09:55 <mbrock> yeah, makes sense
02:10:38 <cocreature> I’m still not sure how I feel about that
02:10:48 <cocreature> I get the motivation but it feels like a hack
02:11:54 <kuribas> Does this mean ghc-8.2 can vectorize code into SIMD now? https://downloads.haskell.org/~ghc/8.2.1/docs/html/libraries/ghc-8.2.1/Vectorise.html
02:17:21 <kuribas> hm I suppose not
02:18:59 <merijn> kuribas: GHC has had SIMD instruction support for awhile, but it doesn't attempt to vectorise code, afaict
02:19:26 <merijn> kuribas: So either you hand-vectorise, or use the LLVM backend and pray to the ASM optimisation gods
02:19:39 <Aruro> what happened with haskell on archlinux? i upgraded to ghc 8.0.2 and everything broke :( ld can not find libraries
02:20:06 <kuribas> Aruro: run ldconfig?
02:20:15 <merijn> Aruro: arch linux maintainers broke shit, I believe there's an article on the arch wiki
02:20:28 <merijn> Aruro: So follow that first, then yell at arch maintainers to stop breaking shit
02:20:47 <EvanR> smh
02:20:51 <Aruro> during clean install hackage0security complains :(
02:21:09 <Aruro> man i knew i dont have to reainstall 8.0.1 everything was working :D
02:21:24 <Aruro> wanted FANCY upgrade to 8.0.2
02:21:41 <Aruro> kuribas: i will try now
02:22:12 <Aruro> during clean install many packages claim that dependency does not exist (ignoring)
02:22:16 <Aruro> i guess that is problem
02:23:06 <merijn> Aruro: The problem is that they decided to ship a completely dynamic compiler, but by default GHC tries to built static and then goes "whoops, can't find any static libs!"
02:23:15 <merijn> At least, that's what I've gathered from comments
02:23:33 <Aruro> yeah, but i followed their docs and installed ghc-static :), rediculous i agree
02:27:59 <Aruro> ok dynamic linking works
02:28:10 <Aruro> but static not, gcc failed in phase linker
02:29:32 <Aruro> why people like to brake stuff is beyong my understanding, all the time these useless upgrades :)
02:29:43 <Aruro> have to reinstall like several times a year :(
02:30:21 <kuribas> Aruro: install from source instead?
02:30:34 <Aruro> will it not take long?
02:30:40 <phz_> merijn: fixed!
02:30:45 <phz_> kuribas: it’s as simple as on mac, for me
02:30:49 <phz_> I use neovim and stack
02:30:58 <phz_> nothing fancy to that setup :)
02:31:20 <phz_> (it’s way harder in Rust because I do low-level graphics programming, and, erm, Apple and graphics programming… :()
02:31:28 <phz_> it’s my work laptop
02:31:35 <phz_> my spare one is a linux setup (archlinux)
02:31:48 <phz_> and I also have a windows native setup, so I cover three platforms that way :P
02:31:52 <ongy> Aruro: I'm running ghc, ghc-static from pacman and (my own) cabal-install-git from aur. But that setup would break horribly when something from the repos that pulls any haskell package is installed (so I have pandoc-lite or something, since pandoc pulls 100+ packages)
02:32:16 <ventonegro> Aruro: Or try Stack
02:32:25 <Aruro> ongy: yeah i read about people being angry about pandoc deps
02:32:53 <kuribas> phz_: I have a two partition pc (linux, windows), and mac mini.  But cross compiling everything from linux sounds appealing :)
02:32:54 <Aruro> before it was pacman -s ghc alex happy cabal-install
02:33:03 <phz_> kuribas: yeah!
02:33:05 <Aruro> now there is like 20 haskell packages
02:33:21 <ongy> for pandoc? the tree it pulls is over 100 packages
02:33:25 <phz_> at the latest demoparty I attended, I cross-compiled my Windows release (Rust) from my archlinux
02:33:37 <phz_> I was pretty amazed that it worked perfectly
02:33:41 <ongy> oh, exactly 100
02:33:41 <phz_> cross-compiling is da shit! :D
02:33:55 <Aruro> ongy: i mean now even simple haskell install pulls all rediculous haskell-* packages
02:34:05 <MarcelineVQ> Aruro: it's pretty darn silly
02:34:09 <ongy> did you build your application general enough to work? I tend to not care enough about windows to fix my paths :)
02:34:51 <Aruro> ventonegro: stack pulls all same packages actually :) i doubt it will work, plus has some bug on 32bit systems
02:35:31 <Aruro> is archlinux dead for haskell dev? im starting to think so :(
02:35:44 <cocreature> Aruro: certainly not, I’m using it just fine
02:36:12 <Aruro> well pacman -Syu certainly broke stuff, which i think is not serious
02:36:46 <cocreature> Aruro: avoid installing anything Haskell-related except for ghc and ghc-static via pacman and you’ll be fine
02:36:54 <ongy> cocreature: do you have *anything* haskell related installed from the repos?
02:37:24 <Aruro> cocreature: do u have ghc 8.0.2?
02:37:26 <cocreature> ongy: yes ghc and ghc-static :)
02:37:38 <cocreature> Aruro: yes
02:37:41 <ongy> hehe. same
02:37:57 <Aruro> cabal-install alex happy no?
02:37:58 <cocreature> ongy: although I’m using the 8.2 ghc I built myself atm :)
02:38:06 <cocreature> Aruro: don’t install those
02:38:15 <ongy> Aruro: cabal-install-git (aur). And then installed with cabal, not from arch repos
02:38:33 <cocreature> Aruro: get a statically linked version of cabal from somewhere. either from before the 8.0.2 update or build it using stack or something like that
02:38:42 <cocreature> and then use that to install alex and happy
02:38:46 <ongy> cocreature: when I tried to make a ghc-git PKGBUILD for the aur, happy didn't cooperate :(
02:39:35 <ertes-w> helo
02:39:39 <Aruro> i got 20 haskell-* packages with cabal-install, seems they cause all this linking trouble
02:39:59 <cocreature> Aruro: yep, that’s why I said you should _only_ install ghc and ghc-static via pacman
02:40:05 <Aruro> cocreature: ty i will try now
02:40:14 <cocreature> at least if you want to use static linking
02:40:40 <Aruro> yes
02:40:50 <ongy> you can put some option into the cabal conf to link dynamically by default, but it still breaks a few things
02:40:51 <cocreature> ongy: tbh I just drop my ghc builds in some directory so I have little use for a pkgbuild
02:41:03 <cocreature> passing -w to cabal is easy enough
02:41:43 <ongy> I just like to put things into the package manager. If I didn't want to do it as system-install, I wouldn't do that either
02:42:27 <merijn> Aruro: mixing package manager packages with libraries you build yourself is a disaster
02:42:30 <Aruro> im starting to think maybe i dont use pacman at all? and just install platform from haskell.org?
02:42:52 <cocreature> -git packages are also slightly annoying since if you actually use some aur helper they will usually rebuild from a clean state which can significantly increase build times over an incremental build
02:42:56 <merijn> Aruro: My linux workflow is: install GHC bindist, install Cabal and cabal-install by hand, build all other haskell sutff myself
02:43:26 <merijn> Aruro: Works on every linux I've encountered, no root required, and easy to drop in and add newer GHC versions
02:43:33 <Aruro> merijn: yeah, i think ill do that too, dont like people messing with my haskell :)
02:43:43 <merijn> (literally just dropping a new GHC bindist in some other dir)
02:44:05 <cocreature> I built 8.2 myself because I wanted to make sure it uses lld by default :)
02:44:25 <Aruro> how long it took?
02:44:41 <merijn> Aruro: Building GHC from source takes awhile
02:44:50 <cocreature> it’s not that bad, it was <1h
02:44:59 <cocreature> on a laptop that’s a few years old
02:45:00 <merijn> cocreature: You must have a monster machine
02:45:17 <cocreature> merijn: definitely not
02:45:22 <merijn> cocreature: Really? my macbook from like 2015 takes at least 1.5 hours if not more
02:45:40 <merijn> ANd that's without me doing anything else
02:45:45 <ongy> lld?
02:45:47 <MarcelineVQ> unoptomized ghc is a 20 minute build here, dunno what -O2 or similar would be though
02:46:15 <cocreature> merijn: I don’t have the exact numbers but I’m fairly sure it was something around 50minutes
02:46:27 <cocreature> ongy: the new linker from the llvm guys
02:46:39 <ongy> ahh, is that the one with LTO?
02:47:07 <cocreature> you can use it for lto but that’s not what I care about. it’s just significantly faster than gnu ld or gold
02:48:34 <cocreature> and you can also do lto with other linkers so that’s not really the main selling point of lld
02:51:02 <Aruro> merijn: wow just yesteryesterday new ghc was released :) i will go with binary install
02:51:35 <bvad> Any info on when stackage nightly will support 8.2?
02:51:46 <bvad> Well, move to 
02:51:50 <whoman> =) i did not have enough memory to compile, so i used binary install as well
02:57:38 <cocreature> bvad: one of the stackage maintainers hinted that the first nightly supporting 8.2 should be out in ~2 weeks
03:00:01 <kuribas> merijn: that's not too bad, you can go see a movie, or go shopping :)
03:00:20 <merijn> kuribas: I can be stuck at work with my machine not really usable :p
03:00:58 <kuribas> merijn: then compile it in the background?
03:01:54 <merijn> kuribas: The problem is compilation takes rather a lot of CPU
03:02:06 <merijn> kuribas: Developing on a machine compiling GHC is...not pleasant
03:02:56 <kuribas> hm, I am compiling ghc right now and don't have any issues...
03:04:15 <kuribas> couldn't you force it to use only one or two cores?
03:04:41 <kuribas> then again this is a linux pc, not macbook...
03:14:51 <bvad> cocreature: Cool, thanks :)
03:18:38 <ertes-w> Aruro: one further option is to install nix…  it doesn't interfere with the rest of your system, because everything it installes is below /nix
03:19:14 <[exa]> merijn: if CPU is a problem why not deprioritize it using nice?
03:19:56 <[exa]> (btw CPU scheduler is fairly good on linux these days, I guess your problem is more like disk cache grinding)
03:20:04 <ertes-w> Aruro: then you can use a number of GHC versions, switch between them seamlessly and also update them properly
03:20:46 <Aruro> ertes-w: i actually do have nix :) maybe i should rely solely on it
03:21:19 <ertes-w> Aruro: you can, if you want…  it usually provides the latest versions of GHC very quickly, up to and including a regularly updated HEAD snapshot
03:21:38 <merijn> [exa]: I don't use linux on my desktop/laptop
03:21:58 <ertes-w> Aruro: or you can go one step further and replace cabal-install entirely, but that requires some extra effort
03:22:04 <Aruro> tried to install binary ghc-8-2 make install gave me error 127, ghc.mk:992, Makefile:51 install] Error 2
03:22:27 <Aruro> aa , libtinfo, ok
03:23:39 <[exa]> merijn: oh so, sorry :]
03:26:49 <Aruro> why ncurses 5 is not shipped with ghc binary?
03:30:51 <merijn> Aruro: Any reason why it should?
03:31:09 <Aruro> i mean, would be nice to have completely portable binary
03:31:21 <Aruro> now i have to search for ncurses 5
03:31:47 <Aruro> im starting to think there should be completely staticly linked protable distro of linux :)
03:31:49 <AWizzArd> Aaah! 8.2! Nicee
03:31:54 <merijn> Aruro: What kinda ghetto OS/distro are you using that it doesn't ship with ncurses?
03:32:16 <Aruro> archlinux :)
03:32:22 <Aruro> it has ncurses 6
03:32:24 <MarcelineVQ> some use 6
03:32:33 <merijn> Aruro: ah...
03:32:38 <Aruro> :(
03:32:41 <bvad> Ghetto OS.. Hah
03:32:55 <Aruro> is there portable version of all linux apps?
03:33:07 <merijn> Aruro: Well, can't really expect all packages to accommodate "we love the bleeding edge we like to break every tool/package every release" distro
03:33:27 <Aruro> merijn: yeah
03:34:00 <merijn> On the one hand, I veel your pain. On the other hand, you're kinda asking for it ;)
03:34:34 <MarcelineVQ> You can just grab ncurses5-compat-libs off the AUR
03:34:43 <Aruro> yeah did that
03:35:05 <Aruro> what is most haskell friendly distro (not Arch obviously) ?
03:35:10 <Aruro> except nixos :)
03:35:22 <Aruro> debian?
03:35:25 <mauke> why not arch?
03:35:36 <Aruro> mauke: does not work :)
03:35:40 <merijn> mauke: They've broken GHC like 3 different ways in the past 2 months :)
03:35:45 <mauke> ah
03:36:16 <Aruro> i think the idea of package managers is not good, makes u too lazy
03:36:20 <merijn> mauke: They ship a dynamic-only GHC so that every haskell package has to download the entire GHC toolchain AND breaks the default build config for GHC
03:36:47 <yushyin> mauke: ghc and haskell ecosystem is a bit pita for dynamic linking
03:37:01 <merijn> mauke: So people installing pandoc end up pulling in like 4GB and 100s of packages of haskell tooling/dependencies
03:37:08 <bvad> Yeah you really wanna avoid using ghc from the repos.. 
03:37:37 <merijn> yushyin: OTOH, GHC and Haskell are one of the easiest/simplest tools for installing user local. They don't get enough credit for that
03:37:49 <yushyin> you should avoid ghc from the repos for developing stuff in the first place anyway
03:38:03 <bvad> merijn: Using stack or in general?
03:38:56 <merijn> bvad: I don't use stack
03:38:57 <yushyin> because it’s too much pain and chances are high that one need more than one ghc version
03:39:13 <bvad> merijn: alright :)
03:39:40 <merijn> bvad: You can just dump a GHC bindist in your homedir, build Cabal/cabal-install from source (it's like 4 commands that you can copy+paste from the README) and everything "Just Works"
03:39:59 <merijn> bvad: Switching GHC versions is just a manner of changing your path to a different GHC too
03:40:16 <merijn> None of this virtualenv/whatever stuff
03:40:44 <bvad> Was just about to mention virtualenv.. 
03:41:12 <merijn> bvad: Ever try installing python user local and getting virtualenv working right? It's a PITA
03:41:32 <bvad> Yeah it's really bad 
03:42:17 <Aruro> pandoc casus is already on reddit
03:42:29 <mauke> hmm, sounds like perlbrew except for the bindist
03:42:31 <bvad> Just so we're clear, I was about to mention virtualenv as an example of how not to do user local :) 
03:43:05 <Aruro> where would opensource world will be without irc and stackexchange?
03:43:38 <bvad> Aruro: some other tools would surely surface 
03:43:54 <Aruro> i would use them
03:44:21 <guillaum1> I think I understood boxing / unboxing and co. Imagine I have the function `f = box . fUnboxed . unbox` and `g = box . gUnboxed . unbox`, then `f.g = box. fUnboxed . unbox . box . gUnboxed . unbox`, and there is some rewrite rules to remove `unbox . box`. I am right ?
03:48:41 * hackagebot tdoc 0.4.7 – TDoc is a typed document builder with support for (X)HTML – https://hackage.haskell.org/package/tdoc
03:52:26 <kuribas> hm, my cross compiler for mingw failed: "Types.hsc:219:20: error: storage size of ‘test_array’ isn’t constant"
04:02:23 <osa1> guillaum1: I don't know the whole question but if you're talking about wrapping/unwrapping you don't need any rewrite rules, existing optimization passes can already optimize `unwrap (wrap x)` to `x`
04:03:44 <MarcelineVQ> osa1: really?
04:03:57 <osa1> really
04:04:07 <MarcelineVQ> which wrap unwrap are you talking about?
04:04:21 <osa1> as in worker and wrapper functions
04:07:39 <MarcelineVQ> I'm not sure what you mean :X
04:09:18 <MarcelineVQ> as in the intermediate Anys dissapear somehow here?  getAny . foldMap Any
04:09:22 <osa1> worker/wrapper transformation that's a program transformation GHC does. I can't give any paper names off the top of my head but a quick google would probably yield something useful.
04:10:51 <osa1> MarcelineVQ: not sure about that part but if that code (after some inlining) reduces to something like `case C x of C y -> ... use y ...` that kind of code optimizes well. take a look at "a transformation based optimiser for haskell"
04:13:08 <MarcelineVQ> ah it seems to be something else, based on ghc the source comments
04:28:09 * hackagebot fortran-src 0.2.0.0 – Parser and anlyses for Fortran standards 66, 77, 90. – https://hackage.haskell.org/package/fortran-src
04:29:50 <merijn> MarcelineVQ: or...you just use coerce instead of foldMap
04:30:10 <merijn> I suppose that needs mconcat too, but anyway
04:43:19 * hackagebot relational-query 0.9.4.1 – Typeful, Modular, Relational, algebraic query engine – https://hackage.haskell.org/package/relational-query
04:43:19 * hackagebot relational-query 0.8.7.1 – Typeful, Modular, Relational, algebraic query engine – https://hackage.haskell.org/package/relational-query
05:03:31 * hackagebot decimal-literals 0.1.0.0 – Preprocessing decimal literals more or less as they are (instead of via… – https://hackage.haskell.org/package/decimal-literals
05:08:34 <guillaum1> osa1: sorry, I'm just curious about how it works actually in GHC. Is my understanding of the existance of "wrap / unwrap" right? And you confirm it is a GHC optimization pass instead of a rewrite rule?
05:08:50 <Aruro> what to do when cabal tells -> Parse of field 'build-depends' failed?
05:09:02 <Aruro> after cabal configure
05:09:18 <merijn> Aruro: fix your cabal file to follow the right syntax? :)
05:09:31 <Aruro> it is correct
05:09:39 <quchen> Cabal disagrees.
05:09:41 <Aruro> i just installed new ghc :)
05:09:42 <quchen> Can you show us the lines?
05:09:51 <Aruro> i think its problem with base or smth
05:10:00 <merijn> Aruro: You think it's correct. Cabal disagrees. Most likely Cabal is right :p
05:10:07 <Aruro> :)
05:10:16 <Aruro> so syntax changed in new version of cabal?
05:10:19 <merijn> No
05:10:28 <merijn> At least, it shouldn't have
05:10:28 <Aruro> it was compiling like 2 monthes ago
05:10:53 <cocreature> Aruro: just show us the file and we can stop guessing what is wrong :)
05:12:57 <Aruro> hm
05:13:08 <Aruro> i would be glad but on other machine, it has no internet
05:13:14 <Aruro> ok at least it told me line
05:13:41 <Aruro> but there is nothing special there aeson-compat >= 0.3.5.1,
05:13:59 <merijn> Aruro: We need the whole file, not one line
05:14:59 * hackagebot engine-io 1.2.17 – A Haskell implementation of Engine.IO – https://hackage.haskell.org/package/engine-io
05:14:59 * hackagebot socket-io 1.3.8 – <i>Added by OliverCharles, Mon Jul 24 12:09:00 UTC 2017.</i> – https://hackage.haskell.org/package/socket-io
05:15:40 <phadej> probably you have forgotten/extra comma in between/at the end
05:15:58 <phadej> i.e. scan whole build-depends list
05:16:13 <phadej> someone is using aeson-compat \o/
05:16:34 <Aruro> i wish it will guide me where is mistake :)
05:16:37 <sphinxo> Say I have Maybe a, Maybe b and function a -> b -> c, how can I apply it to the maybes and get Maybe c
05:17:00 <hpc> f <$> a <*> b
05:17:03 <merijn> sphinxo: You want Applicative
05:17:12 <sphinxo> ooh yeah
05:17:37 <Aruro> phadej: yeah, ty, comma was missing but not on the line cabal specified :) they should really use trifecta or smth.
05:17:38 <cocreature> :t liftA2
05:17:40 <lambdabot> Applicative f => (a -> b -> c) -> f a -> f b -> f c
05:17:43 <cocreature> ^ sphinxo that works too
05:18:32 <Aruro> sphinxo: i like liftA2 because u see what happens
05:18:45 <Aruro> and it is what u logically want, to LIFT it
05:19:58 <phadej> Aruro: will use parsec
05:20:02 <phadej> we'll
05:20:28 <phadej> although  IIRC it will report error place more correctly, but I haven't tested it
05:20:32 <Aruro> i mean error and line specified in message differ by 10 lines
05:21:04 <phadej> Aruro: well, it says where "build-depends" started, so it's correct - very unprecise though
05:21:13 <phadej> please open an issue in haskell/cabal github
05:21:27 <phadej> then I'll remember to check it works properly with new .cabal parser
05:22:32 <Aruro> btw im using latest cabal
05:22:36 <Aruro> just downloaded it
05:23:17 <phadej> is 2.0 already uploaded/released?
05:23:43 <Aruro> 1.24.0.2?
05:23:56 <phadej> December 2016 :)
05:24:04 <Aruro> :D using official website
05:24:05 <phadej> the 2.0 will be uploaded very soon (tm)
05:24:35 <phadej> ... release scripts broke, we don't use them very often :?
05:25:36 * hackagebot engine-io-snap 1.0.5, libsystemd-journal 1.4.2, tasty-rerun 1.1.7
05:25:36 * hackagebot  → https://hackage.haskell.org/packages/recent
05:32:48 * hackagebot aeson-compat 0.3.7.1, ekg-bosun 1.0.9, network-carbon 1.0.10, snap-error-collector 1.1.4, … and 1 more
05:32:48 * hackagebot  → https://hackage.haskell.org/packages/recent
05:37:52 * hackagebot digestive-functors-aeson 1.1.22, exhaustive 1.1.5, streaming-postgresql-simple 0.2.0.1
05:37:52 * hackagebot  → https://hackage.haskell.org/packages/recent
05:43:45 <ventonegro> "Hey, gimme that digestive functor over there"
05:48:55 <sepakorayl> guys what's the modern way to install ghci on acid ?
05:49:46 <boj> with a buddy in case you trip out
05:49:49 <peddie> sepakorayl: get the ghci from haskell.org, get the acid from a darknet market, drop the acid 90 minutes before beginning the installation
05:49:57 <peddie> boj: high-five
05:50:17 <boj> i honestly have no idea what "acid" is in this context, but wanted to contribute :o
05:51:01 <dysfun> yeah i'm wondering too
05:51:04 <sepakorayl> https://wiki.haskell.org/GHC/GHCi#GHCi_on_Acid
05:51:27 <peddie> sepakorayl: thanks, I learned something new
05:51:52 <boj> me too
05:52:03 <dysfun> why wouldn't cabal be the modern way?
05:52:04 <peddie> sorry for the snarky reply
05:52:09 <dysfun> i mean you can have a sandbox if you like
05:53:10 <dysfun> also GoA looks really cool
05:54:59 <sepakorayl> yea I just googled for something similar because I thought it would be cool to have, GoA popped up.
06:02:16 <sepakorayl> how do i install globally with cabal? just cabal install away outside of a sanbox ?
06:02:39 <sepakorayl> I am pretty new to the ecosystem :PP
06:02:46 <peddie> sepakorayl: for stuff like goa and lambdabot, I'd probably install in a sandbox and copy the binaries to my $PATH myself
06:03:03 <peddie> it has a lot of dependencies you may not want floating around in your global env
06:03:31 <sepakorayl> yea ok that sounds managable
06:05:28 <Boomerang> sepakorayl: Alternatively you could probably install them with your distro's package manager (which would hopefully just install binaries). On Ubuntu: sudo apt-get install lambdabot
06:06:26 <Boomerang> It looks like apt-get doesn't have goa though.
06:06:28 <ertes-w> does anyone know how to give the 'terminfo' library the FD of the terminal in question?  it seems to have std* hard-coded
06:06:47 <sepakorayl> yea
06:07:09 <Boomerang> sepakorayl: nix does if that's good for you. nix-env -i goa lambdabot
06:07:17 <cocreature> ertes-w: maybe you can do something nasty like dup2 the fd you care about to stdout? :)
06:08:17 * hackagebot relational-query-HDBC 0.6.4.0 – HDBC instance of relational-query and typed query interface for HDBC – https://hackage.haskell.org/package/relational-query-HDBC
06:08:17 * hackagebot relational-query-HDBC 0.6.3.0 – HDBC instance of relational-query and typed query interface for HDBC – https://hackage.haskell.org/package/relational-query-HDBC
06:08:37 <ertes-w> cocreature: i suppose i could do that and restore the originals, but it's really nasty
06:09:05 <ertes-w> the terminfo C library supports passing the FD
06:09:18 <cocreature> make a PR to the terminfo Haskell lib? :)
06:15:56 <sepakorayl> is Either.Validation the standard approach for writing functions reporting multiple errors before failing?
06:17:25 <phadej> sepakorayl: it's good
06:17:44 <phadej> (i personally would prefer it to be a newtype over Either, but that's details)
06:20:32 * hackagebot dumb-cas 0.1.0.0 – A computer “algebra” system that knows nothing about algebra, at the core. – https://hackage.haskell.org/package/dumb-cas
06:21:07 <kuribas> Hm, apparently some constants aren't in mingw, and the windows ghc needs them.
06:24:52 <merijn> phadej: either has a newtype for Validation :)
06:25:37 <kuribas> To make a mingw-crosscompiler I need to manually add them...
06:27:29 * hackagebot seakale-tests 0.1.1.0 – Helpers to test code using Seakale – https://hackage.haskell.org/package/seakale-tests
06:27:38 <AWizzArd> Given   type Reducer a r = r -> a -> r    what is the difference between
06:27:42 <AWizzArd> a) type Transducer a b = Reducer a r -> Reducer b r       and
06:27:48 <AWizzArd> b) type Transducer a b = forall r . Reducer a r -> Reducer b r   ?
06:27:54 <phadej> merijn: that doesnät look like newtype: http://hackage.haskell.org/package/either-4.4.1.1/docs/Data-Either-Validation.html
06:27:55 <AWizzArd> Is it that in a) both `r`s are the same type, while in b) the r in both Reducers can be different?
06:28:25 <phadej> AWizzArd: have you tried to write a)
06:28:49 <AWizzArd> phadej: I am reading a blog post about Transducers in Haskell. Didn’t try anything. The blog says that a) is illegal.
06:29:05 <phadej> compiler is quite good at answering some questions, and yes it's illegal
06:29:09 <AWizzArd> Because r is not bound in the type definition.
06:29:35 <sepakorayl> btw should I avoid using Writer ?
06:29:36 <AWizzArd> So, in b) – is the r in both cases the same?
06:29:44 <phadej> AWizzArd: yes, it's the same
06:29:51 <AWizzArd> phadej: okay thx
06:30:13 <merijn> phadej: hmmm, I was sure it was last I looked...
06:30:20 <phadej> AWizzArd: consider "foo a b = bar a x + bar b x" and "foo a b = \x -> bar a x + bar b x"
06:30:26 <cocreature> sepakorayl: because it results in spaceleaks
06:30:48 <sepakorayl> what's a good alternative
06:30:49 <sepakorayl> ?
06:30:54 <cocreature> sepakorayl: but that’s only true for the implementation of writer in transformes. there is a writer-cps package which doesn’t suffer from this
06:31:35 <phadej> (or use State.Strict)
06:31:51 <phadej> though it will have different Monad* class instances
06:32:15 <cocreature> another reason is that some of the usecases that are often brought up when people are introduced to Writer, most notably logging, really should stream their results to some kind of output instead of accumulating all of them
06:35:15 <sepakorayl> I am asking because I was looking for something akin to Validation but I would also like some limited flow control. So I used MaybeT Writer [Errors] and then converted that to Either [Errors] inside the same function.
06:35:47 <phadej> sepakorayl: you either have multiple errors or Monad instance
06:35:51 <phadej> both will be illegal
06:36:21 <Younder> phadej, multiple errors are illegal? explain!
06:36:24 <sepakorayl> multiple errors worked with MaybeT Writer, I just logged the errors
06:37:05 <sepakorayl> but I don't know it doesn't feel right.
06:37:20 <tabaqui> is there any extension to simulate namespaces?
06:37:26 <phadej> Younder: ap != <*>
06:37:33 <tabaqui> i want to define two functions with the same name in one module
06:37:52 <tabaqui> and don't want to add new class
06:38:02 <phadej> sepakorayl: but then errors don't fail your computation :)
06:38:04 <Peaker> sepakorayl, MaybeT (Writer [Errors]) has errors even in case of success, is that intentional?
06:38:20 <tabaqui> it would be fine if I could use them as x.function and y.function
06:38:43 <sepakorayl> I want to use that for typechecker error reporting
06:39:00 <sepakorayl> so I want to find multiple errors before failing
06:39:13 <sepakorayl> give me a minute
06:39:36 <phadej> sepakorayl: you could use `These`
06:40:12 <sepakorayl> what is These?
06:40:29 <phadej> http://hackage.haskell.org/package/these-0.7.4/docs/Data-These.html
06:40:30 <Boomerang> Some as Either but with the option to have Both
06:41:05 <cocreature> the instances are also different
06:41:09 <sepakorayl> but I kind of want just Either. I just want to accumulate multiple errors before converting to Either.
06:41:12 <cocreature> even when not both are present
06:41:42 <Boomerang> The problem with Either is that as soon as you get a Left you can't continue your monad
06:44:19 <_drsk_> :167
06:45:22 <sphinxo> How do I deal with comparing floats of different precisions, eg 1.345235 == 1.3452347
06:46:27 <rain1> one way is to check x - y < 0.00005  some tolerance
06:46:39 <rain1> oopse forgot abs (x - y) < ...
06:47:45 <merijn> Better just switch to precise numbers
06:48:05 <merijn> Either Ratio or Fixed
06:48:16 <Boomerang> For float comparison with different precision you should use a dynamic epsilon. Check this out: http://floating-point-gui.de/errors/comparison/
06:50:46 * hackagebot aeson-extra 0.4.1.0 – Extra goodies for aeson – https://hackage.haskell.org/package/aeson-extra
06:51:50 <mschristiansen> Using Servant how do I run a WAI application as a endpoint without loosing access to my config in ServerT?
06:52:46 <phadej> "config in ServerT" ? could you elaborate, show the code...
06:53:37 <mschristiansen> I have a normal `Raw` endpoint e.g. `stream :> Raw`
06:54:36 <mschristiansen> and a server e.g. `api = Tagged app where app :: Application`
06:56:06 <mschristiansen> the config is in a readerMonad using `runReaderTNat`, so my other handlers are of type `ServerT Api AppHandler`
06:56:20 <mschristiansen> phadej: hope that made sense or want me to write a gist?/
06:56:53 <phadej> mschristiansen: I see, that problem which didn't exist prior servant-0.11
06:57:07 <phadej> as you couldn't enter Raw endpoints
06:57:21 <phadej> so I guess there isn't a solution atm
06:57:37 <phadej> mschristiansen: do you mind open a ticket in github.com/haskell-servant/servant
06:57:56 <mschristiansen> OK, I'll do that
06:58:25 <phadej> thanks, I don't promise there will be elegant solution soon
06:58:45 <phadej> unelegant one is to have Raw endpoints separately, and do plumbing manually
06:58:54 <mschristiansen> I need the raw endpoint for server sent events (SSE)
06:59:37 <mschristiansen> Think it might work with a normal `Get` endpoint if I create the correct content-type
06:59:49 <mschristiansen> content type must be "text/event-stream"
07:00:05 <mschristiansen> Think that would work?
07:11:21 <_drsk_> :322
07:12:20 <infandum> Is it possible to import a module from a different directory from *within* the source file?
07:13:01 <infandum> Without using a cabal or stack.yaml file
07:13:14 <infandum> And without compiler flags
07:14:38 <phadej> the sooner you turn your experiment into proper package, the less head aches you'll have
07:14:54 <Yearner> Assalam O Allaikum Warakhmathullahi Wabarakathuhu
07:15:34 <Yearner> if you kick me for those reason even i will answer all those issues of a slave have been made to promote your name illegaly used enough
07:15:42 <Yearner> and you all are apparently mirc clients
07:15:45 <Yearner> as far as i know
07:16:08 <Yearner> okey i gotta go now 
07:17:14 <infandum> phadej: Was that to me?
07:19:09 * Yearner is male
07:19:40 <ertes-w> Yearner: do you have a question about the programming language haskell?
07:28:17 * hackagebot TeX-my-math 0.201.0.0 – Render general Haskell math to LaTeX. Or: math typesetting with high… – https://hackage.haskell.org/package/TeX-my-math
07:28:50 <phadej> infandum: yeah
07:29:02 <Boomerang> infandum: Making it a package is the right solution but if you really want to know you can add a directory for the compiler to use: ghc -isrc src/Main.hs
07:32:06 <ertes-w> infandum: though i doubt it you might be lucky with the OPTIONS_GHC pragma
07:32:17 <ertes-w> {-# OPTIONS_GHC -i… #-}
07:32:32 <ertes-w> but you should probably just create a package, as others have noted
07:33:00 <sepakorayl> check out this shitty thing. http://lpaste.net/357167
07:33:31 <sepakorayl> Ii am using Maybe inside the MaybeT so I can also shortcircuit independantly although it is not used in this example.
07:33:39 <sepakorayl> Is there a better approach?
07:34:39 * hackagebot licensor 0.2.1 – A license compatibility helper – https://hackage.haskell.org/package/licensor
07:36:01 <ertes-w> sepakorayl: MaybeT (Writer e) a ≃ Writer e (Maybe a) ≃ (Maybe a, e)
07:36:22 <Boomerang> sepakorayl: checkA doesn't need to return a list of errors since only one error is ever returned if any. My guess is because of that you can keep it as an either and remove part of the logic that converts back and forth between Either and MaybeT
07:36:32 <ertes-w> (MaybeT (Writer e)) supports both logging and short-circuiting
07:36:33 <tabaqui> I cannot combine MultiParamTypeClasses with UndecidableInstances, do I?
07:36:36 <sepakorayl> MaybeA returns multiple errors
07:36:37 <tabaqui> I mean
07:36:44 <ertes-w> and the log will survive short-circuiting
07:36:53 <tabaqui> class (Eq x, Ord y) => LegalPair x y where {}
07:37:00 <sepakorayl> checkA*
07:37:06 <ertes-w> > runWriter (runMaybeT (tell "a" >> tell "b" >> empty >> tell "c"))
07:37:09 <lambdabot>  error:
07:37:09 <lambdabot>      Variable not in scope: runMaybeT :: m0 () -> Writer w a
07:37:17 <sepakorayl> for instance checkA (A (-3))
07:37:18 <ertes-w> @let import Control.Monad.Trans.Maybe
07:37:20 <lambdabot>  Defined.
07:37:22 <ertes-w> > runWriter (runMaybeT (tell "a" >> tell "b" >> empty >> tell "c"))
07:37:25 <lambdabot>  (Nothing,"ab")
07:37:29 <ertes-w> sepakorayl: ^
07:37:30 <tabaqui> I tried to mix different definitions and got compile error all the time
07:38:11 <ertes-w> sepakorayl: note that this is different from:  WriterT e Maybe a ≃ Maybe (a, e)
07:38:25 <ertes-w> in other words:  MaybeT and WriterT don't commute
07:39:12 <sepakorayl> sorry ertes-w I got lost, what is this advice for
07:40:27 <ertes-w> sepakorayl: if i understood your problem correctly you're looking for a more elegant solution for your pattern of short-circuiting
07:40:59 <infandum> phadej, Boomerang, ertes-w: Normally I would agree with you, but in this case I just want a file with a "plot theme" to be loaded for org-babel scripts when plotting data. It's a pretty esoteric use case, so while in most cases having a package would be fine, here it would not be because the theme should not be a package here.
07:41:16 <infandum> ertes-w: That pragma is exactly what I need, thank you!
07:42:36 <ertes-w> infandum: i can't promise that it works
07:42:57 <infandum> ertes-w: I'll test it out.
07:43:35 <Boomerang> infandum: what about using a stack shebang like some of the examples from the turtle package? Would that allow you to import other module?
07:43:48 <sepakorayl> ertes-w I want logging for the sub-checks and I want infer to only be attempted if the others are checked correctly
07:43:58 <sepakorayl> but I also want to be able to log inside infer
07:44:05 <sepakorayl> and also be able to short-circuit the logs inside infer
07:44:16 <sepakorayl> (using mzero in my case)
07:45:16 * hackagebot servant-swagger-ui 0.2.4.3.0.20 – Servant swagger ui – https://hackage.haskell.org/package/servant-swagger-ui
07:45:57 <ertes-w> sepakorayl: my suggestion is to use a single MaybeT (Writer E), for some suitable E (e.g. E = Either AError BError)
07:46:30 <ertes-w> sepakorayl: you can also turn AError and BError into proper exceptions and use SomeException
07:46:45 <ertes-w> or rather E = [SomeException] in your case
07:47:21 <ertes-w> sepakorayl: BTW, you can simplify your types a lot by using effect classes
07:47:30 <sepakorayl> but now I can convert AErrors to BErrors, how can I catch them and change them without being in IO ?
07:47:42 <sepakorayl> (not very familiar with exceptions in haskell)
07:47:50 <sepakorayl> (same with effect classes)
07:48:13 <Boomerang> > do { a <- These ["a"] 5; b <- These ["b"] 6; return (a, b)}
07:48:16 <lambdabot>  error:
07:48:16 <lambdabot>      Data constructor not in scope: These :: [[Char]] -> Integer -> m t1error:
07:48:16 <lambdabot>      Data constructor not in scope: These :: [[Char]] -> Integer -> m t
07:48:28 <Boomerang> @let import Data.These
07:48:29 <lambdabot>  .L.hs:124:1: error:
07:48:29 <lambdabot>      Failed to load interface for ‘Data.These’
07:48:29 <lambdabot>      Perhaps you meant
07:48:52 <ertes-w> well, if AError ≤ BError (for a suitable (≤)), you can probably convert from AError to BError
07:49:21 <ertes-w> generaliseAError :: (Functor f) => Either (f AError) a -> Either (f BError) a
07:49:41 <ertes-w> or you use SomeException – it doesn't require IO
07:50:01 <sepakorayl> okay I will try to grok these when I get home
07:50:06 <ertes-w> using effect classes means:  instead of 'Left' use e.g. 'throwM' from the 'exceptions' package
07:50:06 <sepakorayl> where can I read about effect classes?
07:50:16 <infandum> ertes-w: Yeah, it doesn't look like OPTIONS_GHC works
07:50:25 <jle`> you can convert "errors" in Either using 'left'
07:50:27 <ertes-w> instead of 'Nothing' use 'empty' from 'Alternative' from Control.Applicative
07:50:44 <jle`> left :: (e -> d) -> Either e a -> Either d a
07:51:00 <ertes-w> instead of using Control.Monad.Trans.Writer from 'transformers' use Control.Monad.Writer from 'mtl'
07:51:05 <ertes-w> then 'tell' is already generalised
07:51:06 <ertes-w> :t tell
07:51:07 <lambdabot> MonadWriter w m => w -> m ()
07:51:17 <infandum> ertes-w: Because "-i" is a dynamic flag
07:51:28 <infandum> sorry, static flag
07:51:36 <infandum> and OPTIONS_GHC only works with dynamic
07:52:31 <kuribas> why does ghc build the Win32 library?
07:52:38 <kuribas> Couldn't it just be a library?
07:52:41 <ertes-w> sepakorayl: in the end your types look like this: checkA :: (MonadWriter [SomeException] m, Alternative m, Monad m) => A -> m (A, Int)
07:52:57 <ertes-w> MonadWriter and Alternative are effect classes
07:53:04 <ertes-w> err
07:53:29 <ertes-w> yeah, that's right
07:54:18 <sepakorayl> how would infer look?
07:54:44 <dysfun> "same vague shape"
07:55:33 <ertes-w> sepakorayl: what does it look like right now?
07:55:35 <Boomerang> infandum: Would this work for you: http://lpaste.net/357170
07:56:15 <sepakorayl> it's in the lpaste. Notice that it takes as an argument the checked B and attempts to produce the int
07:57:49 <sepakorayl> infer :: B (Int, n) -> MaybeT (Writer [BError]) (Maybe Int)
07:58:06 <ertes-w> sepakorayl: 'infer' is weird…  it doesn't seem to ever fail
07:58:25 <sepakorayl> in this example it doesn't
07:58:25 <ertes-w> as far as i can tell the only effect it uses is 'tell'
07:58:39 <sepakorayl> in my typechecker it is responsible for type inference
07:58:50 <ertes-w> in any case it would follow the same shape
07:58:53 <sepakorayl> so there are cases where it has to return Nothing
07:58:57 <Boomerang> sepakorayl: Have you tried the monad instance of (These a)? It uses the semigroup instance of a to accumulate the errors, it's a good fit for your problem
07:59:40 <infandum> Boomerang: I see what you are trying to do and it would work, but unfortunately this is my issue: I'm basically using emacs to plot through diagrams. That's done with "stack exec diagrams-builder-cairo -- sourcefile. Your suggestion did not work, but I assume it's because it's input to diagrams-builder.
08:00:09 <sepakorayl> Boomerang no, not yet I am checking a lot of things in parallel, I will check it out after I grok ertes-w's appraoch
08:00:40 <sepakorayl> by the way, thanks a lot guys you are very helpful
08:01:02 <Boomerang> infandum: In that case you might be interested in the stack shebang: https://github.com/commercialhaskell/stack/wiki/Script-interpreter
08:01:10 <ertes-w> sepakorayl: infer :: (MonadWriter [SomeException] m) => B (Int, n) -> m (Maybe Int)
08:01:12 <ertes-w> at this point
08:01:20 <ertes-w> an Alternative constraint might come in later
08:02:28 <ertes-w> but as you can see it's a nice way to separate concerns: the type only specifies which effects the action wants to use
08:02:40 <infandum> Boomerang: I was trying that out but it wasn't working (here). I guess diagrams-builder uses ghc?
08:02:46 <ertes-w> and later, when you actually run an action, you build the precise monad stack you need
08:05:10 <byorgey> infandum: diagrams-builder does use ghc, via hint
08:05:28 <sepakorayl> thanks ertes, so Alternative handles shortcircuiting, MonadWriter the logging of exceptions, how can I use checkA in checkB and handle the exceptions?
08:05:46 <fvh> is there any way to change type like this data C a b = C {am :: a, bm :: b} into something nicer? it's hard to pattern match over such type. I saw such code in library why people would sacrifices clear statement of the types and how to make it polymorphic properly, typeclass?
08:06:31 <sepakorayl> the m would be different inside checkB
08:06:53 <infandum> byorgey: Okay, so I need to figure out how to use "-i" without stack and inside of a source file. Oh man.
08:07:52 <byorgey> infandum: sounds tricky.  Let me know if there would be a simple feature we could add to diagrams-builder that would help.
08:08:37 <ertes-w> sepakorayl: my suggestion is *not* to have different monads
08:09:37 * hackagebot github 0.16.0 – Access to the GitHub API, v3. – https://hackage.haskell.org/package/github
08:10:26 <sepakorayl> my problem is the MonadWriter [AError], MonadWriter [BError] part
08:12:40 <ertes-w> sepakorayl: as i said one solution would be to use SomeException
08:12:44 <jle`> fvh: what do you mean by nicer?
08:12:49 <jle`> fvh: pattern matching odesn't seem that bad?
08:12:54 <jle`> foo (C x y) = x + y ....?
08:13:35 <jle`> seems perfectly fine to me, unless you're referring to the fact that 'C' is probably a bad name for a type
08:13:47 <jle`> and 'am' and 'bm' are probably bad names for record accessors
08:14:56 <ertes-w> sepakorayl: the other would be (Either AError BError), and one further option would be:  checkA :: (MonadWriter [e] m, …) => (AError -> e) -> A -> m …
08:15:35 <infandum> byorgey: I mean, I don't think it's diagrams-builder's fault. I think it's my use case -- I want to be able to use diagrams in emacs org-mode for figures for the diagrams "plots" library (so I can plot data prettily). Using ob-diagrams, this is pretty easy. However, I would like a different "default" theme. Instead of entering the code in over and over for the theme, I would prefer to have a file with a "Plots.Theme" that I can import
08:15:35 <infandum> and just use a simple command. I don't want this module to be a library, however, because that's a bit silly to have a library for a small theme, so a file was fine. I was just having trouble including the file in the source (in org-mode) without using the command line.
08:16:27 <sepakorayl> I don't know how to convert the exception types using SomeException. I want to be able to handle checkA's exception inside checkB. And I don't know how to catch them so I can convert them. Control.Exception seems to imply I can only catch exceptions inside IO
08:16:36 <guillaum1> I realize backpack allows to define multiples modules at once, and this is great ;) But I did not find how I can import modules from a .bkp file to ghci. ?
08:18:53 <Cale> sepakorayl: This is true, you can only catch exceptions from IO.
08:19:18 <Cale> sepakorayl: The operations to convert are pure though
08:19:23 <Cale> :t fromException
08:19:25 <lambdabot> Exception e => SomeException -> Maybe e
08:19:32 <Cale> :t toException
08:19:34 <lambdabot> Exception e => e -> SomeException
08:20:27 <Cale> sepakorayl: You can define new instances of Exception trivially. All you need to do is add Typeable to the deriving clause for the data declaration, and then write "instance Exception MyType"
08:20:49 <Cale> (no 'where' required unless you want to do something fancy)
08:21:21 <Hafydd> Only in exceptional cases.
08:21:37 <Cale> Actually, it is pretty interesting what can be accomplished by overriding the default method implementations: you can create types which behave like arbitrary unions or restrictions of other existing exception types.
08:21:58 <phadej> displayException is cool on newer GHC
08:22:20 <Cale> That is, by defining fromException yourself, you sort of get to decide which exceptions will be caught if you attempt to catch an exception of the given type.
08:22:26 <Boomerang> sepakorayl: Here I rewrote your example with These: http://lpaste.net/357172
08:22:52 <fvh> jle` I shortened type names for the sake of showing on irc, there are might be tons of different type combinations in such type with more fields
08:24:23 <Cale> Boomerang: heh, at this rate we'll soon be using MonadChronicle :)
08:24:36 <jle`> fvh: yes, i figured so
08:24:48 <jle`> so i'm not exactly sure what is wrong with the type yu gave
08:24:57 <jle`> it seems like a perfectly good type to me
08:25:10 <Boomerang> Cale: my builds are taking a long time at work ^^
08:29:18 <Cale> Boomerang: A full build from scratch of one of our applications is up to somewhere over an hour now. That includes building the Android and iOS apps, but yeah, if you have to rebuild certain modules and ghci can't be used for some reason, it gets pretty annoying.
08:31:38 <Boomerang> Cale: We're building hardware with Haskell here. Once GHC is done we still have a few hours (if it succeeds :p) of synthesis for the full build.
08:34:20 <Boomerang> MonadChronicle looks pretty cool :)
08:38:08 <Cale> Boomerang: ah, sounds fun
08:38:32 <Cale> Boomerang: It's basically an abstraction around "These" but with silly names
08:39:15 <Athas> Is there some trick to using stack with caches on Travis?  Even though I cache STACK_ROOT, it still wants to rebuild a lot of dependencies every time.
08:39:43 <kuribas> how can I compile ghc with the right llvm?  It says it can only use 3.9, but then uses another version on my system.
08:41:49 <quchen> kuribas: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/flags.html#replacing-phases
08:41:58 <quchen> -pgmlc⟨cmd⟩ 	Use ⟨cmd⟩ as the LLVM compiler
08:42:12 <quchen> I haven’t tried it, but it looks like a good start.
08:42:17 <kuribas> quchen: I am trying to build a windows (mingw) crosscompiler for linux.
08:56:57 <sepakorayl> sorry guys my internet died
08:57:17 <sepakorayl> Boomerang, it seems that This short-circuits everything
08:57:21 <sepakorayl> so it doesn't log all errors
08:59:35 <platz> unboxed sums don't work yet? http://lpaste.net/4638689873681711104
08:59:40 <Boomerang> I don't think it shortcircuits everything, look at the Bind instance for (These a). Or maybe I am missunderstanding what you mean by short-circuiting.
09:00:09 <platz> (in ghci)
09:00:37 <dolio> Just like unboxed tuples.
09:00:38 <sepakorayl> checkA (A (-3)) does reports only the first error
09:00:39 <geekosaur> ghci doesn't do unboxed
09:00:45 <Boomerang> No you are right it does short ciruit with just This, I was testing with These
09:00:52 <platz> geekosaur: ty
09:01:34 <geekosaur> (and there's some nastiness in the runtime that makes it difficult to change that)
09:01:35 <Boomerang> I guess the These approach only works if you want to report several warnings or one error
09:01:52 <Boomerang> *with up to one error
09:02:59 <geekosaur> 2017 Jul 22 20:35:42 <geekosaur>	there are too many unexpected interactions between things. (some months back someone was trying to add unboxed tuple support to ghci and discovered a place in the runtime where it (a) knew ghci didn't create them, so (b) reused a function in such a way that it used an unboxed tuple in ghc and a boxed one in ghci, so if you added unboxed tuples to ghci then it had no idea whether what it was handed was boxed or n
09:03:00 <geekosaur> ot
09:08:58 <paolino> hello, I have this error I cannot fix <interactive>:1:18: error:
09:08:58 <paolino>     • Couldn't match type ‘text-1.2.2.1:Data.Text.Internal.Text’
09:08:58 <paolino>                      with ‘Text’
09:08:58 <paolino>       NB: ‘Text’
09:08:58 <paolino>             is defined in ‘Data.Text.Internal’ in package ‘text-1.2.2.2’
09:08:59 <paolino>           ‘text-1.2.2.1:Data.Text.Internal.Text’
09:09:01 <paolino>             is defined in ‘Data.Text.Internal’ in package ‘text-1.2.2.1’
09:09:04 <paolino> sorry
09:09:10 <paolino> http://lpaste.net/357174
09:09:23 <Clint> wow
09:10:47 <platz> i'm just glad we have unboxed in some form w/ this release; the main use case seems to be tight loops anyways
09:11:01 <geekosaur> you have gotten ghci to load two packages that use incompatible versions of text. you probably want either a stack or cabal sandbox, and their respective ghci wrappers (cabal repl / stack ghci)
09:11:23 <geekosaur> because ghc / ghci by itself will happily do that to you
09:21:48 <sepakorayl> why aren't there when/unless etc for applicative?
09:25:16 <Boomerang> sepakorayl: You can make my example with These not short-circuit by replacing "This something" by "These something ()"
09:25:41 <sepakorayl> Boomerang let me try
09:26:06 <Boomerang> But you are getting a These at the end (so the result along with the errors)
09:26:21 <byorgey> :type when
09:26:31 <byorgey> @type when
09:26:32 <lambdabot> Applicative f => Bool -> f () -> f ()
09:26:39 <byorgey> sepakorayl: ^^^ what do you mean?
09:27:17 <sepakorayl> :3
09:27:19 <sepakorayl> woops
09:30:04 <Boomerang> sepakorayl: If you you don't want the result to be computed in the case where you have at least one error you can use laziness and simply dicard it when you are getting a These back.
09:30:25 <Boomerang> To make the code nicer you might want to use a helper function along the lines of: addError e = These [e] ()
09:31:15 <Cale> addError = dictate
09:31:16 <Cale> ;)
09:31:33 <Boomerang> :D
09:32:12 <Boomerang> Why make thing simple when you can reinvent the wheel!
09:33:12 * hackagebot lazy-hash-cache 0.1.0.0 – Storing computed values for re-use when the same program runs again. – https://hackage.haskell.org/package/lazy-hash-cache
09:33:13 * hackagebot lazy-hash 0.1.0.0 – Identifiers for not-yet-computed values – https://hackage.haskell.org/package/lazy-hash
09:33:36 <Cale> At the same time, MonadChronicle is kind of ridiculous.
09:35:03 <Boomerang> My favourite ridiculous package is needle: https://hackage.haskell.org/package/needle-0.1.0.1/docs/Control-Arrow-Needle.html
09:35:37 <Cale> Brilliant
09:46:29 <sepakorayl> Boomerang I will check it out after I go home
09:46:44 <sepakorayl> I think I am trying to solve a non-problem
09:46:46 <sepakorayl> http://lpaste.net/357175
09:47:15 <sepakorayl> I can achieve short-circuiting by simply converting to the either monad when appropriate
09:50:06 * hackagebot proto-lens-arbitrary 0.1.1.0 – Arbitrary instances for proto-lens. – https://hackage.haskell.org/package/proto-lens-arbitrary
09:55:58 <infandum> How can I use stack to install a local library to the database?
09:56:00 <infandum> globally
09:56:35 <infandum> I assume stack exec ghci should be able to load it
09:59:51 <infandum> Nevermind, I just needed to rereun "stack build" outside of the project after entering it into the global stack.yaml.
10:15:41 <Sepakorayl> What would be the cleanest way to introduce a wrapper around Validation that also includes a Skip constructor so that it can satisfy Product?
10:25:51 <Unicorn_Princess> how do I make stack rebuild a project from scratch/clean the build folder? just delete .stack-work manually? because I have a project, and I changed the name of the executable, but the old executable is still there
10:27:52 <platz> deleting .stack-work does work, assuming you're willing to rebuild
10:37:34 <dysfun> stack clean?
10:44:14 <Unicorn_Princess> dysfun: doesn't seem to clear out old executables. I guess deleting .stack-work will have to do
10:44:24 <dysfun> ah, pity
10:46:40 <sepakorayl> sorry I got disconnected again. What would be a clean way to enhance Either.Validation so that it stops failure accumulating?
10:47:21 <Boomerang> What do you mean by stop? Short circuit in some cases?
10:47:36 <sepakorayl> yep
10:47:56 <sepakorayl> make a completely new type ?
10:48:03 <osa1> do you mean Data.Validation?
10:48:24 <sepakorayl> Data.Either.Validation
10:48:30 <sepakorayl> I guess it's the same with Data.AccValidation
10:48:55 <Boomerang> I know I keep mentioning These but you do get the option to short-circuit or not with These ^^
10:48:57 <sepakorayl> Data.Validation.AccValidation*
10:49:29 <sepakorayl> I just got home, it was just something I was thinking during my way here
10:49:36 <sepakorayl> I will check These now
10:51:56 * hackagebot alex-tools 0.2.0.1 – A set of functions for a common use case of Alex. – https://hackage.haskell.org/package/alex-tools
10:53:04 <sepakorayl> alex-tools seems interesting
10:56:06 <sepakorayl> These e _ for eror accumulating, This for short-circuiting and That for result ?
10:56:49 <Boomerang> yeah! You can use "These e ()" for error accumulating
10:57:09 <Boomerang> The short-circuit will be a list of all the error up to the one that short circuits
10:57:23 <Boomerang> sorry I meant These [e] ()
10:58:20 <kuribas> I am trying to cross compile ghc for mingw windows.  I get: "libraries/Win32/Graphics/Win32/GDI/Pen.hsc:60:25: error: parse error on input ‘//’"
10:58:26 <Boomerang> You can use these as helper functions (critical short-circuits): "critical e = This [e]" "warning e = These [e] ()"
10:59:35 <kuribas> the line looks valid: ", pS_SOLID             = PS_SOLID            // default"
10:59:42 <geekosaur> technically it's not
11:00:45 <geekosaur> well, depends. C99 allows // as comment, ANSI C doesn't
11:01:28 <geekosaur> but I'm not sure what is producing that error, if it's hsc2hs then it's probably expecting ANSI C syntax
11:01:59 <kuribas> geekosaur: is it a version mismatch for hsc2hs ?
11:06:11 <geekosaur> it looks like hsc2hs HEAD does have support for // comments, so maybe
11:09:17 <osa1> here's a life-changing tip: create a ~/.haskeline file with `historyDuplicates: IgnoreConsecutive` and ghci will stop adding duplicate lines to your command history
11:15:34 <kuribas> geekosaur: well, it compiles without the comments.  Not sure why they were there in the first place...
11:19:20 * hackagebot algebraic-classes 0.8 – Conversions between algebraic classes and F-algebras. – https://hackage.haskell.org/package/algebraic-classes
11:19:33 <t7> has anyone read about and or implemented 'flexible types' aka hml?
11:22:40 <sepakorayl> Boomerang do you have the previou lpaste?
11:32:32 * hackagebot free-functors 0.8 – Free functors, adjoint to functors that forget class constraints. – https://hackage.haskell.org/package/free-functors
11:32:33 * hackagebot resin 0.2.0.0 – High performance variable binders – https://hackage.haskell.org/package/resin
11:37:10 <pera> Uhm, I thought that "let x=2 in x+1" to be equivalent to "(\x->x+1) 2", but then I tried "let x=2 in let x=x in x+1" which seems to be _|_ instead of "(\x->(\x->x+1) x) 2"
11:37:34 <pera> can let _ in _ be expressed in lambda terms?
11:37:35 <rain1> it's not exactly equivalent but it's pretty close
11:37:46 <rain1> they are semantically the same, but they differ in terms of the type system
11:38:26 <rain1> as for the example you gave, let is also binding recursivly
11:38:29 <ReinH> > let x = x in x
11:38:35 <lambdabot>  mueval-core: Time limit exceeded
11:38:35 <t7> a skolom constant would never be in ftx(e) ?
11:38:36 <ReinH> This is what you are doing.
11:38:39 <t7> right
11:38:55 <Boomerang> sepakorayl: Here's a new one http://lpaste.net/357177
11:38:56 <rain1> you can do "let x=2 in let x'=x in x'+1"
11:39:00 <ReinH> You are defining x recursively in terms of itself, not in terms of any previous x.
11:39:06 <rain1> to avoid the recursive binding
11:40:06 * hackagebot resin 0.2.0.1 – High performance variable binders – https://hackage.haskell.org/package/resin
11:40:09 <pera> it's a bit confusing to me because both expressions have the same context
11:40:14 <ReinH> No, they do not.
11:40:25 <ReinH> let x introduces a new binder called x and anything on the rhs refers to that x
11:40:42 <ReinH> s/binder/bound variable
11:40:42 <pera> I see...
11:40:57 <ReinH> you are shadowing the previous x, not referring to it
11:41:50 <rain1> sometimes you use let to make a recursive functio, like   let f x = if x == 0 then 1 else x * f (x-1) in ...
11:42:09 <rain1> just like that you can make recursive data  let x = 1 : x in .. for example
11:42:18 <rain1> so that's why your expression was _|_
11:42:26 <pera> ah that makes sense
11:42:27 <pera> thanks
11:47:25 <ReinH> Haskell's let is often called letrec in other languages.
11:48:55 <pera> ReinH: so that would explain why the denotational semantics of Haskell's let seems to be different from the one I read in TAPL
11:48:56 <ReinH> let p = e1 in e0 desugars differently depending on whether it is recursive, i.e., whether a variable in p appears free in e1
11:50:09 <pera> I suppose this should be in the Haskell report right? I will check later
11:50:14 <ReinH> Haskell's let semantics are defined syntactically. They are syntactic sugar.
11:50:30 <ReinH> The difficulty is that they can be desugared in two different ways depending on whether they are recursive.
11:51:31 <ReinH> The report describes this in detail: https://www.haskell.org/onlinereport/haskell2010/haskellch3.html#x8-440003.12
11:51:52 <pera> thanks you ReinH !
11:51:58 <pera> *thank
11:52:12 <ReinH> in other languages, there is a let and a letrec. The former is desugared into a case statement and the later into a new let that uses fix for the recursion.
11:52:42 <ReinH> In Haskell, let desugars into either based on whether it is recursive (a variable in p appears in e1) or not.
11:53:07 <ReinH> pera: you're welcome :)
11:54:40 <sepakorayl> Boomerang seems pretty good
11:57:55 <ReinH> pera: fwiw, there are two other non-obvious things wrt let bindings: let generalization and lazy pattern matching. Let generalization was introduced in GHC 7.2 and is described in https://ghc.haskell.org/trac/ghc/blog/LetGeneralisationInGhc7.
11:58:36 <dolio> What?
11:58:42 <ReinH> The other is that let p = e1 in e0 always desugars into a lazy pattern match on p. In the non-recursive case, that would be case e1 of ~p -> e0.
11:58:47 <ReinH> dolio: ?
11:58:54 <dolio> Let generalization was introduced in Hindley-Milner.
11:59:27 <ReinH> sorry, I should have said that 7.2 changed the let generalization rules
11:59:36 <pera> ReinH: thank you very much
12:00:45 <pera> "The old one had grown to resemble the closing stages of a game of Jenga, in which making any change was a delicate operation that risked bringing the whole edifice crashing down." lol
12:01:32 <sepakorayl> Boomerang: one problem is that there is no any way to stop the short-circuiting
12:01:35 <ReinH> > \f -> (f True, f 0)
12:01:37 <lambdabot>  error:
12:01:37 <lambdabot>      • No instance for (Num Bool) arising from the literal ‘0’
12:01:37 <lambdabot>      • In the first argument of ‘f’, namely ‘0’
12:01:39 <ReinH> > let f = \x -> x in (f True, f 0)
12:01:41 <lambdabot>  (True,0)
12:01:45 <ReinH> ^ an example of let generalization
12:01:54 <sepakorayl> so if I hahd short-circuited inside checkA it would not produce any other errors
12:06:13 <mclark1129_> I'm looking at an example implementation of tic-tac-toe and it has an operator :>>=, but I can't seem to find any sort of implementation or explanation of what it does
12:06:15 <mclark1129_> anyone know?
12:06:20 <sepakorayl> Do you guys think a AccValidation type with skips/ suspended skips would be useful ?
12:06:24 <rain1> it's the monad bind operator
12:06:38 <mclark1129_> you mean >>=?
12:06:50 <rain1> wheres this code?
12:06:58 <mclark1129_> http://projects.haskell.org/operational/examples/TicTacToe.hs.html
12:07:29 <rain1> http://projects.haskell.org/operational/Documentation.html it's described here it seems
12:07:35 <rain1> (:>>=) :: instr a -> (a -> Program instr b) -> ProgramView instr b
12:08:12 <rain1> seems to be a data "code" for bind, so they can do optimization on expressions before turning it into an actual bind
12:08:23 <mclark1129_> i see..
12:08:27 <mclark1129_> cool thx.
12:09:55 <geekosaur> The operational package is an embellished free monad
12:11:57 <mclark1129_> so kind of like a way to build out a DSL/
12:11:58 <mclark1129_> ?
12:20:36 <Yearner> well yeah guys so what were we upto
12:20:45 <Yearner> laugh out louds
12:20:49 <Yearner> hahahahahahaha
12:30:23 * hackagebot groundhog-th 0.8.0.1 – Type-safe datatype-database mapping library. – https://hackage.haskell.org/package/groundhog-th
12:32:46 * jared-w finished the monad chapter on haskellbook.com
12:33:04 <bitemyapp> jared-w: congrats :)
12:33:04 <jared-w> Am strangely both enlightened and disappointed :p
12:33:13 <bitemyapp> nobody said truth had to be interesting
12:33:47 <jared-w> haha true. I thought it was a bit strange how short the chapter was, but then again it's just going over 'what' a monad is and you'll presumably be getting far more practice implementing "interesting" ones later?
12:34:27 <jared-w> I must confess, writing `(Pattern match a) k >>= k a` still feels a bit like a magical incantation I recite
12:34:45 <bitemyapp> We shoved the difficulty down
12:34:52 <bitemyapp> to Monoid, Functor, Applicative
12:35:01 <bitemyapp> It's meant to indicate that there isn't _that much_ there
12:35:14 <jared-w> It did that pretty well :p
12:36:07 <jared-w> Now I'm having fun realizing I never really understood how to write folds in the first place
12:44:13 <EvanR> jared-w: the first chapter exercises in hott book is interesting in that regard, asks you to juggle various ways to fold/recurse/induct on numbers
12:45:26 <jared-w> oooh neat, I really need to understand folding and recursing and induction just a tiny bit better, I think
12:45:45 <jared-w> being able to write a foldr with a weird-ass lambda function and have it do almost anything is something I need to get better at, I think :p
12:47:46 <EvanR> almost anything? hmm 
12:48:38 <jared-w> Well you can write sum, product, elem, minmum, maximum, null, length, toList, etc., all as folds. You can even construct an infinite list out of a fold (iirc)
12:50:41 <jared-w> https://en.wikibooks.org/wiki/Haskell/Foldable I'm liking this introduction
12:51:21 <EvanR> foldr corresponds to the recursion principle for lists, and i think without recursive visitor functions, this allows you to write any primitive recursive function on lists
12:51:50 <EvanR> and youre guaranteed the result is a total function
12:52:04 <EvanR> not sure how that extends to infinite lists
12:52:45 <jared-w> https://stackoverflow.com/a/12299223 pigworker to the rescue :p
12:54:33 <EvanR> "any infinitary recursion" see im not sure thats true, depending on what "any infinitary recursion" is
12:55:15 <jared-w> > foldr (\_ fib a b -> a : fib b (a + b)) undefined [1..] 1 1 -- does this not work?
12:55:18 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
12:55:38 <EvanR> shifting to natural numbers (list of ()), you cant write e.g. the ackermann function using the equivalent of foldr for numbers
12:56:25 <jared-w> ahh you're picking on the usage of 'any', gotcha.
12:56:40 <EvanR> well thats the interesting part
12:56:51 <EvanR> i was even reading it as "any function" and ignoring foundations :)
12:57:05 <Tuplanolla> If you carry a Turing machine in the accumulator...
12:57:07 <jared-w> Can you represent the ackermann function with a fixed point?
12:57:30 <EvanR> if you do... then ?
12:58:02 <jared-w> The above foldr that pigworker gave was just him using the fodlr to construct a general purpose fixpoint operator
12:58:36 <jared-w> So if you can write the ackermann function with a fixed point, you can write the fixpoint using foldr and shove it all in there, If I'm reading that right :p
12:58:52 <Tuplanolla> Then you can perform any computation as the recursion happens elsewhere.
13:00:35 <jared-w> Isn't that the point of a fold? To abstract out the explicit recursion?
13:00:37 <ReinH> You can perform any computation using foldr in a very unsatisfying way: f x = foldr (const f) undefined [x]
13:01:12 <ReinH> tada
13:01:17 * jared-w claps
13:02:28 <EvanR> so the nature of the visiting function is pretty important
13:03:14 <EvanR> it determines if you reach primitive recursion, or reached general recursion, or ???
13:03:30 <EvanR> transcendental recursion
13:03:38 <cocreature> ReinH: are you a magician?
13:04:48 <jared-w> "Any sufficiently advanced visiter function is indistinguisable from corecursion"
13:06:53 <EvanR> in hott you begin only being able to do primitive recursion, and "under the counter" you have LEM ready, just in case
13:07:26 <EvanR> which lifts you out of the sorry world of computability
13:08:18 <jared-w> LEM?
13:08:41 <EvanR> law of excluded middle, principle of excluded middle
13:08:55 * cocreature removes EvanR’s constructivist license after seeing him selling lem
13:09:20 <EvanR> its not for sale, its like your tire iron
13:09:30 <ReinH> Sorry, it's foldr (const . f) undefined [x]
13:09:39 <EvanR> customers assume you can pull it out but its better to let them wonder
13:10:07 <ReinH> > foldr (const . succ) undefined [x]
13:10:09 <lambdabot>  succ x
13:10:11 <ReinH> tada
13:11:12 * hackagebot resin 0.2.0.2 – High performance variable binders – https://hackage.haskell.org/package/resin
13:11:54 <ReinH> carter: You're doing binders now?
13:14:07 <jared-w> lol
13:14:13 <napping> Do join points work for stream fusion in 8.2.1? I've written a little example using streams without Skip, but it doesn't fuse.
13:14:24 <jared-w> gotcha, thanks for the clarification, EvanR :)
13:14:32 <napping> http://lpaste.net/357179
13:19:27 <jared-w> Hmm... can you automatically derive instances even when the language has dependent types?
13:20:16 <phadej> jared-w: not really, you cannot derive that much even for GADTs
13:20:30 <jared-w> That's a shame
13:21:59 <phadej> what you have in mind?
13:22:33 <jared-w> I just read a random comment on r/haskell that said they read somewhere once that you couldn't derive much (if at all) with dependent types so all of the nifty "the compiler writes your code for you" goes out the window with them
13:23:00 <phadej> well, it writes but differently
13:26:07 <phadej> jared-w: if you have time, look at https://www.youtube.com/watch?v=QojLQY5H0RI
13:26:55 <jared-w> ಠ_ಠ what a wonderful time to discover my laptop's volume decided to stop working
13:37:17 <k0ral> has anyone already worked with zippers that have multiple "cursors" ?
13:38:08 <jared-w> k0ral: there's a pretty interesting article on that that I read once (was a bit beyond me)
13:38:30 <jared-w> https://pavpanchekha.com/blog/zippers/multi-zippers.html
13:39:38 <k0ral> oh man... how did I not find that page ? it's just exactly what I'm looking for
13:39:44 <k0ral> thanks
13:40:11 <jared-w> no problem! The entire series of articles was pretty great :)
13:41:07 <jared-w> phadej: I'm very excited that I can actually hear what he's saying! I'll defintely listen to this at some point
13:43:53 <fizbin> Anyone have an example of a non-trivial .hsc file? I'm trying to figure out what https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/utils.html#writing-haskell-interfaces-to-c-code-hsc2hs says and clearly I've missed something.
13:48:41 <fizbin> I have a C function that takes an array of structs, and I can't figure out how to call it, nor can I figure out how hsc2hs is supposed to help me. I've called functions that take just primitive values without using hsc2hs in the past (that is, just using "foreign import ccall"), but I can't figure out what I might say here.
13:49:41 * hackagebot SSTG 0.1.0.2 – STG Symbolic Execution – https://hackage.haskell.org/package/SSTG
13:49:41 * hackagebot katip 0.5.0.0 – A structured logging framework. – https://hackage.haskell.org/package/katip
13:49:45 <jared-w> fizbin: https://github.com/search?utf8=%E2%9C%93&q=*.hsc+language%3Ahaskell&type=Code  does this help at all?
13:50:09 <geekosaur> fizbin, in this case it might be easier to skip hsc2hs and use Storable
13:51:20 <fizbin> geekosaur: I'm all for Skipping hsc2hs, since I can't figure out how to use it. Unfortunately, https://wiki.haskell.org/FFICookBook says "use hsc2hs" when dealing with structs, and then gives what might be part of a solution, maybe?
13:51:54 <geekosaur> the wiki is not always the fount of all wisdom.
13:52:00 <fizbin> jared-w: Does that link return results for you? It doesn't seem to for me.
13:52:23 <jared-w> It did. Odd.
13:53:10 <fizbin> jared-w: I get "We could not perform this search. Must include at least one user, organization, or repository"
13:53:34 <geekosaur> hsc2hs can be useful if all you have is a C header file, and it predates Storable which lets you more or less treat the result as Haskell data
13:56:57 <jared-w> yeah nope, seems like I can't find anything useful on github after all
13:57:13 <jared-w> Seems like most everyone has moved onto using Storable?
13:57:35 <geekosaur> or c2hs, which (when it works) does more of the gruntwork
13:58:08 <geekosaur> but arrays are prone to confuse it because C types are ambiguous with respect to them
13:58:10 <fizbin> I guess? But I can't find good "here is how you make a C array of your Storable thing" documentation.
13:58:21 <fizbin> s/good/any/
13:59:21 * hackagebot katip-elasticsearch 0.4.0.0 – ElasticSearch scribe for the Katip logging framework. – https://hackage.haskell.org/package/katip-elasticsearch
14:01:57 <k0ral> okay so a zipper with n cursors is "just" the n-th derivative of the type; is there a way to write a `differentiate` type-operator in haskell ?
14:02:55 <EvanR> fizbin: look in the FFI docs under Foreign.Marshal.Array actually, read everything under Foreign
14:05:12 <sepakorayl> if there are multiple memptys should I write wrappers to implement Alternative
14:05:14 <sepakorayl> ?
14:10:06 <jared-w> There's only one mempty per monoid. Do you not just specify which monoid you're talking about?
14:11:13 <EvanR> haha... multiple memptys = breaks the monoid laws
14:11:27 <unknownln> How do you have multiple memptys? The definition of mempty states that mappend x mempty == x, so if you appended one definition for mempty with another definition of mempty, you would have to choose which value to return, and the laws wouldn't hold
14:11:49 <EvanR> the next question is, why would we care
14:11:54 <EvanR> practically
14:12:02 <hololeap> what is a good example of a monad that doesn't fit into the analogy of wrapping/unwrapping values from a container?
14:12:14 <koala_man> parsing
14:12:19 <unknownln> (and mappend mempty x = x)
14:12:25 <napping> sepakorayl: do you have multiple mappends too? If there are several monoid structures, you do need a newtype
14:12:46 <unknownln> ^ basically this is the answer
14:12:54 <EvanR> hololeap: Reader
14:13:01 <unknownln> For example the Sum and Product newtypes
14:13:07 <EvanR> Cont
14:13:11 <EvanR> IO
14:13:17 <EvanR> Parser
14:13:24 <EvanR> Logic
14:13:34 <k0ral> sepakorayl: maybe what you want is to work on a quotient type such that all memptys are equivalent and treated as a single instance of the quotient type, then you can define that as mempty
14:14:43 <k0ral> s/instance/value (poor choice of word)
14:15:07 <EvanR> defeats the purpose of having multiple values?
14:15:49 <sepakorayl> I just have two failure constructors
14:16:46 <EvanR> then, that might also play weirdly with associativity too
14:17:01 <EvanR> if you associate it one way you get one failure, or another way to get another?
14:17:20 <EvanR> also failure isnt mempty i thought
14:17:47 <EvanR> are you sure this isnt MonadPlus
14:17:59 <sepakorayl> sorry I meant empty
14:18:06 <unknownln> It is if you wrap an Alternative with the Alt newtype
14:18:12 <monochrom> Cont is still a container but meh.
14:18:36 <EvanR> anything is a container
14:18:57 <EvanR> sepakorayl: e1 <> e2 = e1 or = e2 ?
14:19:01 <monochrom> But it's better to first demand "write down the axioms for container".
14:19:13 <Xandaros> http://tcpst.net/93n5 - What is happening here?
14:19:13 <EvanR> thatd be interesting
14:19:37 <sepakorayl> I am not sure how <|> plays with other typeclasses
14:19:49 <EvanR> e1 <|> e2 = e1 or e2 ?
14:19:50 <monochrom> Demanding axioms is my natural way of telling you how lousy your thinking is. :)
14:19:52 <sepakorayl> is it independent from other operators ?
14:20:21 <geekosaur> Xandaros, you are on arch?
14:20:25 <Xandaros> I am
14:20:33 <geekosaur> yep.
14:20:42 <sepakorayl> nvm
14:21:16 <nshepperd> cont is sort of like a container but also not
14:21:18 <geekosaur> if you must use arch's ghc, install the ghc-static package, uninstall the arch-provided haskell libraries, reinstall them via cabal
14:21:20 <Xandaros> I did install ghc-static, which allowed me to use runghc, but why is it having problems with the sandbox now? :/
14:21:30 <geekosaur> because you got those packages from pacman
14:21:51 <geekosaur> so they're dynamic-only until the arch packagers get their heads out of their rumps
14:22:35 <Xandaros> Well, I did uninstall all arch provided packages, but some are required for cabal :/
14:22:47 <nshepperd> Cont Void a is different from a container of `a` (it's ¬¬a)
14:23:03 <geekosaur> hm, those packages would make sense then
14:23:26 <geekosaur> but that's still the issue. could also try forcing -dynamic
14:23:31 <EvanR> recast logic as containers haha
14:23:53 <geekosaur> frankly the most reliable solution at the moment is stop using arch packages for anything haskell related :/
14:24:07 <nshepperd> if you assume that a 'container' should have some way of extracting the value supposedly 'contained', anyway
14:24:23 <Xandaros> Question: How do I get cabal without cabal?
14:24:24 <EvanR> A -> B, if you give me a container labeled A, i can get a container labeled B out of it :)
14:24:51 <epoitras> Hello friends! I'm trying to build a simple compressor in Haskell and I'm having some strange behaviour with the binary-bits package (https://hackage.haskell.org/package/binary-bits)
14:24:57 <EvanR> container labeled Void, i can get whatever container i want out of it
14:25:10 <epoitras> Anyone know why putBool would be padding 0 bits for byte alignment (even when not using joinPut)?
14:25:10 <Xandaros> I bet there's a properly packaged ghc on the AUR, but I feel like I won't be able to build cabal without cabal
14:25:12 <geekosaur> Xandaros, source distribution and its bootstrap.sh
14:25:22 <Xandaros> Oh? Okay then
14:25:32 <geekosaur> also supposedly there's an ArchHaskell setup which is not broken; just the main repo
14:25:47 <sepakorayl> I am trying to write a new library and I am not sure which typeclasses to implement
14:26:07 <geekosaur> but I am not an arch user (and am less and less inclined to become one every time they pull something like this)
14:26:12 <fizbin> Okay, I looked into c2hs and... WTF? How does one use *that*? I have a C header file. I want to make Haskell. Apparently c2hs doesn't actually do that. It requires me to make a binding file (.chs) that is described.... somewhere? Not any place I can find.
14:26:23 <EvanR> what is the type of operation you think matches some standard class?
14:27:31 <Xandaros> The temptation to ask "Is there a properly packaged GHC in the AUR?" in #archlinux...
14:27:45 <adelbertc> anyone know what "upgrading haskell-src-exts" for hlint means? i'm running into an issue: https://github.com/ndmitchell/hlint/issues/296 and i'm seeing the proposed solution is to upgrade haskell-src-exts
14:28:05 <adelbertc> i have hlint installed through Nix
14:28:16 <geekosaur> Xandaros, since I am your interface to google apparently, https://wiki.archlinux.org/index.php/ArchHaskell
14:28:34 <brisbin> Xandaros: fwiw, i uninstalled everything and installed only stack-static from AUR, then do everything else with stack
14:28:35 <nshepperd> Xandaros: cabal install cabal-install, then put the resulting binary into your PATH
14:29:09 <nshepperd> Xandaros: then remove the arch cabal package
14:29:31 <Xandaros> nshepperd: sounds like a plan! I'll try that :)
14:29:37 <jared-w> brisbin: there's a stack-static in AUR now? Nice
14:29:40 <MarcelineVQ> sounds annoying, just go pacman -S ghc-static
14:29:57 <Xandaros> MarcelineVQ: I have that. Doesn't help
14:30:14 <MarcelineVQ> I see, pardon me :(
14:30:39 <jared-w> I don't like the ghc-static. It was much easier for me to just do everything with stack and put a random stack installed ghc into my global path
14:31:15 <geekosaur> that can have its own issues though
14:31:43 <Xandaros> I have had terrible experiences with stack, so I don't even have it installed. I will stick to sandboxes for now
14:31:50 <geekosaur> like, installing anything into it not via stack stands some chance of confusing stack, since it believes it is managing the package databases without other things poking at them
14:32:18 <geekosaur> this won't happen (easily) if the ghc is hidden inside of stack, but is possible if it's also on $PATH
14:33:02 <jared-w> I mean, the only thing I have installed is shellshock-static and pandoc-static from the AUR. I only keep GHC on the $PATH because I'm too lazy to add something to emacs to point to it ¯\_(ツ)_/¯
14:33:19 <brisbin> yeah i don't do that global path bit. just use `stack ghci` when i'm playing not in a project. i've had nothing but great experiences with stack compared to the prior options (e.g. sandboxes)
14:33:38 <brisbin> i've not kept up with nix or new-build or whatever else has sprung up since stack, to be fair though
14:34:25 <brisbin> jared-w: why not `stack install pandoc` instead and put `~/.local/bin` on PATH for "pandoc" to work? as an example
14:34:43 <Xandaros> Okay, so cabal install cabal-install also fails. I'll downgrade to 8.0.1, install cabal and then go back to 8.0.2. *sigh*
14:34:55 <Xandaros> I might decide to just install ghc to /usr/local...
14:36:14 <jared-w> brisbin: Pretty sure that won't install a binary? Although to be perfectly honest, I have yet to actually use pandoc
14:36:26 <brisbin> jared-w: works on my machine :shrug:
14:36:37 <brisbin> it's how i do xmonad and pandoc
14:37:29 <kadoban> jared-w: That's what 'stack install' is for, binaries. That's really the only thing it's for.
14:39:05 <Xandaros> Ok, I'll give stack another chance - I don't seem to have an old version of cabal to use, it seems
14:40:01 <napping> Xandaros: did you try installing from the cabal-install tar file?
14:40:02 <nshepperd> Xandaros: uh, right. I think what I actually did was, downgrade cabal to 1.24.0.0-11 (thereby removing all the broken libraries from global db), leaving ghc and ghc-static at 8.0.2
14:40:13 <nshepperd> Xandaros: then install cabal-install from there
14:40:42 <Xandaros> I tried cabal-install 1.24.0.0-2 and it complained about missing shared libaries...
14:41:22 <Xandaros> I'll try stack-static, since everyone is raving on about stack. If it's as annoying as I remember, I'll try that again
14:41:30 <jared-w> ahh, duh, I knew that, kadoban... But how to get said pandoc binary? Do I have to build it myself or does stack install do that for me?
14:42:13 <napping> Xandaros: for installing very from scratch I get that and run its bootstrap.sh to build cabal
14:42:48 <kadoban> jared-w: It does it for you. 'stack install' is really just 'stack build' with an extra tiny step at the end (copying executables)
14:44:16 <deech> Does anyone know if GHCi ever automatically recompiled if a pre-processor file changed? eg. modifying a .chs file and doing `:reload`.
14:44:27 <jared-w> ahh got it. I was hoping to avoid building all of pandoc myself just to have it. I'm lazy like that :p
14:44:40 <nshepperd> i've made a bunch of PKGBUILDS that are just 'cabal sandbox init; cabal install foo; cp .cabal-sandbox/bin/foo ${the usr/bin dir}'
14:44:58 <nshepperd> so efficient
14:45:01 <kadoban> Ah, heh. Fair enough.
14:45:23 <monochrom> I think you need to strip the exe yourself.
14:45:37 <monochrom> Err no, "cabal install" already does that. Nevermind.
14:46:12 <monochrom> But yes, I do recommend sandboxing when you want to do "cabal install cabal-install".
14:46:38 <monochrom> Presence of new versions of Cabal can confuse ghc-mod for example.
14:46:45 <monochrom> It has happened. It will happen.
14:47:08 <Xandaros> Well, I was going to nuke the system-installed one anyway. But it didn't work either way
14:47:22 <jared-w> Is anyone still getting my messages?
14:47:36 <monochrom> Yes, you're lazy. :)
14:47:46 <nshepperd> i think arch makepkg does exe stripping also
14:47:50 <jared-w> lol I am
14:48:01 <jared-w> Mostly I'm frustrated right now because I can't get the wifi on my laptop to stop dropping randomly
14:48:19 <jared-w> But... I can still talk to you guys even though I can't ping anything ಠ_ಠ
14:48:29 <monochrom> Someone is playing whack-a-mole on your wifi packets.
14:49:07 <monochrom> (Best error model ever!)
14:49:08 <Xandaros> http://tcpst.net/zf2x - well... that went well
14:50:47 <monochrom> I want someone to write a "Learn You A Stack" for me :)
14:51:39 <Xandaros> Well, I found a tutorial, but I ran into issues with the second stack command in it... Not looking good
14:52:05 <monochrom> Yeah one tutorial is not going to be enough. Learning stack is like learning haskell.
14:52:53 <MarcelineVQ> a simple google search away  https://github.com/commercialhaskell/stack/issues/3268
14:53:53 * hackagebot bloodhound-amazonka-auth 0.1.2.0 – Adds convenient Amazon ElasticSearch Service authentication to Bloodhound. – https://hackage.haskell.org/package/bloodhound-amazonka-auth
14:54:16 <brisbin> looks like the AUR package is missing a dep then :/
14:54:24 <MarcelineVQ> needing ncurses5-compat-libs for ghc comes up every once in awhile
15:05:58 <Xandaros> Can I tell stack to just get the newest packages from hackage or do I have to get my packages from stackage and be bound by this resolver thing?
15:06:34 <jared-w> Every now and then, just update your resolver to the latest LTS for stack (or the latest nightly)
15:06:49 <napping> If you want the latest hackage versions, you probably shouldn't use stack
15:06:51 <jared-w> You want to do it this way because that's what makes stack stable vs the cabal hell of ye olde days
15:07:23 <napping> of ye olde pre-sandbox days
15:07:37 <Xandaros> Well, not all packages are on stackage, though. What if I want a package that isn't on stackage?
15:07:48 <brisbin> Xandaros: you can always add hackage versions via extra-deps in your project
15:08:10 <brisbin> s/hackage versions/anything not on stackage/
15:08:15 <MarcelineVQ> gosh, people sure do like using stack for specifically-not-its-intended-purpose :>
15:08:45 <Xandaros> Currently I'm using stack to install cabal :P
15:09:37 <jared-w> ಠ_ಠ but why
15:09:58 <Xandaros> Scroll up
15:09:58 <MarcelineVQ> jared-w: distro issues :(
15:10:01 <Xe> jared-w: probably some level of hell no mortal sould endure
15:10:07 <monochrom> There are more purposeful people than there are cabals and stacks.
15:11:03 <Xandaros> I'll actually try to use stack, but I honestly don't see the need. I have never experienced this "cabal hell" everyone speaks of and I've been using plain cabal for 2 years or something now
15:11:22 <napping> Xandaros: if you only want a cabal-install binary, it's probably easier to download the source from https://www.haskell.org/cabal/download.html and run the setup script
15:11:48 <napping> which takes care of installing the dependencies of the binary without the benefit of cabal-install
15:11:53 <kadoban> Xandaros: Then why bother?
15:12:04 <Xandaros> I had the idea to install cabal via stack after I already installed stack. At that point, it didn't really matter, did it? :P
15:12:20 <Xandaros> kadoban: Because I just installed stack. Might as well try it
15:12:26 <Xandaros> (again=
15:12:49 <brisbin> what was the (claimed or true) upside of arch's move?
15:12:58 <monochrom> It all began when arch packages went weird.
15:13:16 <brisbin> because i'm having trouble seeing any reasons to muck it up
15:13:24 <jared-w> brisbin: the upside claim is that dynamic linking is always superior to static linking because it's reusable, DRY, unix-like, etc
15:13:36 <monochrom> I see this as yet another ideology.
15:14:20 <tommd> Is GHC 8.2.1 missing profiling libraries at least in the debian x86_64 build?
15:14:24 <tommd> for base
15:14:49 <monochrom> Oh! 8.2.1 is out!
15:14:53 <Xandaros> You know, I actually see their point regarding the dynamic linking thing. But they make it almost impossible to do static linking and that's just not acceptable
15:15:01 * monochrom rubs his hands and grins evilly
15:15:40 <monochrom> Um why are they not posting to haskell-cafe or haskell :)
15:16:07 <tommd> Unknown.  It was a really quiet release afaict.
15:17:22 <hpc> pppsh, it's only got dependent types
15:18:54 <Xandaros> Okay, I here's one really positive thing I just noticed about stack: It uses ~/.local/bin. I approve
15:19:33 <monochrom> :)
15:19:36 <brisbin> love that xdg
15:19:51 <monochrom> I believe more in ~/bin
15:21:11 <Xandaros> I used ~/bin for a while - I just copied somebody, but I decided ~/.local/bin makes more sense and moved my things there. This is the first time I've seen something else acknowledge it as a thing
15:21:23 <nshepperd_> But ~/bin isn't a dotdir!
15:21:24 <hpc> i install all of my binaries to C:/usr/lib/share/local/bin/win32/noarch
15:21:29 <Xandaros> Does stack have an equivalent of "cabal run"?
15:21:30 <jared-w> I believe more in using XDG stuff rather than statically linking to the same spot XDG would :p
15:22:01 <hpc> is there anything else that uses ~/.local/bin?
15:22:46 <kadoban> Xandaros: It has 'stack exec the-thing' though it somehow doesn't build for you, it's like the one thing that doesn't. And you have to tell it what to run.
15:23:41 <Xandaros> That seems rather annoying
15:23:57 <Xandaros> Looks like there's a stack-run package, though
15:24:44 <monochrom> All controversies over ~/bin vs ~/.local/bin can be resolved by symlinks :)
15:25:05 <hpc> ln -s ~/bin /bin
15:25:22 <hpc> whoops i had that backwards, well it's too late now!
15:25:29 <hpc> better make ~ globally read-write
15:25:51 <monochrom> colorful error messages?!
15:27:30 <monochrom> "GHC will now use ld.gold or ld.lld instead of the system’s default ld, if available." \∩/
15:27:41 <hpc> what is lld?
15:27:48 <phadej> llvm-ld
15:27:53 <monochrom> Although, I am not sure about what the next sentence means about "evaluated at configure time".
15:28:01 <nshepperd_> I don't like having things in ~ that aren't either 1. starting with a dot and hence hidden or 2. something i actually use every day
15:28:35 <Xandaros> I have far too many things in ~ that don't meet those criteria
15:28:35 <phadej> monochrom: i.e. when you install ghc, it will pick the default
15:28:51 <monochrom> "Split sections is enabled by default in the official binary distributions for platforms that support it." \∩/
15:29:09 <Xandaros> But even with the dot, I often feel like ~/.config would be a better place for things
15:29:19 <monochrom> Well yeah, I was wondering whether it's "the configure when you build GHC yourself" or "the configure before you make-install"
15:29:21 <nshepperd_> So things like virtualbox that just dump stuff in ~ make me sad
15:29:53 <brisbin> i accidentallied a ~/go earlier today
15:31:40 <monochrom> "Data.Either now provides fromLeft and fromRight" haha
15:31:56 <Tuplanolla> I put my own things under `~/files`, because `~` is a mess.
15:31:59 <monochrom> Ohh w000t "liftA2 is now a method of the Applicative class" !!!
15:32:20 <nshepperd_> Mostly the offenders seem to be programs coming from Windows, where $HOME really is a dumping ground for random config, as people put all their documents on the desktop and never visit ~
15:33:33 * hackagebot threads 0.5.1.5 – Fork threads and wait for their result – https://hackage.haskell.org/package/threads
15:34:21 <nshepperd_> liftA2 is now a method? huh
15:34:51 <nshepperd_> Why is that good
15:35:08 <Xandaros> nshepperd_: Yes. I just found a "My Games" in ~. I'm pretty sure that's a windows thing
15:35:19 <Tuplanolla> Maxima puts its temporary pipes into `~` and J also installs there, nshepperd_.
15:35:32 <Tuplanolla> They're not even hidden.
15:37:25 <nshepperd_> Horrible
15:37:38 <srpx> why can't I join #haskell-blah without ssl?
15:37:54 <hpc> because it was configured by space weasels
15:38:10 <phadej> nshepperd_: one can write better Traversable instances uisng liftA2
15:38:12 <hpc> use -offtopic, or reconnect with ssl
15:38:12 <duncan^> SSL is a good idea.
15:38:35 <duncan^> SSL is a very nice thing that everyone should use if possible.
15:39:13 <phadej> nshepperd_: https://mail.haskell.org/pipermail/libraries/2017-January/027579.html
15:40:55 <srpx> problem is I'm using freenode's online irc client
15:41:10 <srpx> I'm yet to find an OSX IRC client that doesn't suck
15:41:22 <hpc> irssi?
15:41:31 <nshepperd_> phadej: ah, so it's more efficient if liftA2 is implemented directly
15:41:34 <jared-w> I like weechat myself :p
15:42:29 <srpx_> kiwiirc.com has ssl, yay
15:43:07 <nshepperd_> Why would freenodes online client not have ssl o_O
15:45:19 <Xandaros> I second weechat. Love it
15:45:51 <geekosaur> probably because it uses an internal communication channel that is already otherwise encrypted
16:02:25 <nisstyre> Xandaros: weechat also has a Guile plugin system
16:02:34 <nisstyre> so you can write your IRC plugins in Scheme >.>
16:02:41 <nisstyre> that's a major plus for me
16:02:49 <nisstyre> sorrynotsorry
16:03:21 <Xandaros> There are many languages I would use before touching a lisp :P
16:03:58 <Tuplanolla> The GNU empire was supposed to be built on Scheme, but look what happened.
16:04:33 <Tuplanolla> I don't think I have any Scheme-configured software right now.
16:04:38 <rain1> there's a really good GNU scheme now!
16:04:43 <nisstyre> lol
16:04:53 <ertes> Xandaros: perl, python, scheme or elisp – pick
16:05:07 <Xandaros> python
16:05:10 <nisstyre> nobody uses anything except Guile, Racket, or elisp (for emacs obvs)
16:05:14 <ertes> well, there is glirc, which is written and scriptable in haskell
16:05:19 <ertes> and it looks like a decent client, too
16:05:23 <lordcirth> cool
16:05:26 <ertes> i haven't tried it myself yet though
16:05:35 <rain1> https://www.gnu.org/software/guile/
16:05:54 <rain1> it's come a long way, lot of really good modern compiler technology in it
16:05:56 <nisstyre> rain1: are you talking about MIT/GNU Scheme or GNU Guile?
16:05:59 <ertes> because the ways of a man are complicated and paved with…  you know…  i'm crazy lazy
16:06:02 <nisstyre> because they're two different projects
16:06:26 <sepakorayl> http://lpaste.net/357180
16:06:42 <nisstyre> https://www.gnu.org/software/mit-scheme/
16:06:54 <sepakorayl> any obvious missing instances?
16:07:04 <ertes> Xandaros: i would prefer unlambda over python
16:07:05 <glguy> ^_^ Did someone say glirc? It looks like this https://glguy.net/irc.png, it has a C API for adding scripting environments. Examples include C, Rust, and Lua
16:07:19 <Xandaros> ertes: lol, HF
16:07:47 <Xandaros> From your list, this would be my order of preference: python, perl, scheme, elisp
16:08:28 <nisstyre> ertes: python, scheme, perl, elisp
16:08:31 <nisstyre> in that order
16:08:57 <ertes> i kinda agree, except it would flip python and scheme
16:09:04 <ertes> s/it/i/
16:09:09 <nisstyre> actually I might switch scheme with python too
16:09:14 <Xandaros> glguy: That does look pretty neat. Does it have a buffer system like weechat and irssi?
16:09:16 <nisstyre> depends if I can say Racket
16:09:33 <jared-w> glguy: you need a prettier picture to sell people on
16:09:41 <ertes> nisstyre: other schemes like chicken and guile are decent, too
16:09:51 <Xandaros> I just can't read Lisps. Syntax should be the last thing you use to decide on a language, but...
16:09:55 <nisstyre> ertes: I know Guile is okay
16:10:00 <jared-w> My Weechat looks like this: http://i.imgur.com/FjcUD3B.jpg
16:10:03 <rain1> you get used to it after a bit!
16:10:04 <nisstyre> ertes: I just like some of the cool concepts and DSLs that Racket has
16:10:28 <glguy> jared-w: I think that's just a matter of taste. I wouldn't want my client to look like that
16:10:49 <nisstyre> ertes: things like Racket's parameters are *really* cool
16:11:04 <nisstyre> they're basically the same thing as Haskell's but way more flexible
16:11:33 <Xandaros> glguy, jared-w: Here's my weechat: http://tcpst.net/n37n.png - fairly standard, I think
16:11:36 <nisstyre> implicit params in Haskell that is
16:11:40 <ertes> Xandaros: i believe syntax is very important (which is one of the reasons i hate python)…  scheme kinda gets away with its syntax, because you get used to it after a while
16:11:58 <nisstyre> you can use them for things like installing the current i/o ports, etc
16:12:01 <nisstyre> or exception handlers
16:12:19 <nisstyre> of course that's contrary to the spirit of Haskell
16:12:23 <glguy> Xandaros: It looks like your font is misconfigured
16:12:38 <Xandaros> ertes: I'm actually fine with python's syntax, most annoying are its binding rules... or lack thereof. We are going off-topic, btw
16:13:05 <Xandaros> glguy: Everyone says that, but I don't see anything wrong with ti
16:13:35 <nisstyre> holy crap
16:13:38 <nisstyre> how can you read that?
16:13:41 <ertes> Xandaros: i could list numerous issues i have had with python in the past few weeks that go far beyond surface issues like syntax, but yes, it's getting off-topic, and i'm planning to write an article about it anyway =)
16:14:14 <ertes> Xandaros: BTW, your font is horrible =)
16:14:22 <Xandaros> lol
16:14:40 <Tuplanolla> Try SymPy before you do that, ertes. That will surely double the length of your article!
16:15:04 <ertes> the spacing is completely messed up…  it looks like those weird wide-char japanese/chinese replacements for latin letters that you find in unicode
16:15:52 <ertes> Tuplanolla: fun fact: 99% of my rant will not deal with anything beyond the language and standard library, although i am going to touch some of the external libraries as well
16:16:02 <nisstyre> this is what mine looks like https://i.imgur.com/tX3Zk34.png
16:16:27 <jared-w> yeah, the spacing is completely wanked on your setup, Xandaros. Yours should look almost identical to nisstyre's
16:16:27 <Xandaros> See, to me it looks squashed together :P
16:16:38 <ertes> i could make a screenshot of mine, but it looks like…  uhm…  emacs
16:16:45 <Tuplanolla> Every second using it is coupled with yearning how much better it would work in Haskell, ertes.
16:17:11 <nisstyre> Xandaros: it's a monospaced font...
16:17:11 <jared-w> Xandaros: in fact, you and nisstyre are using the same font. nisstyre just has correct font rendering enabled :p
16:17:28 <ertes> Tuplanolla: another fun fact: i won't even need to compare it to haskell =)
16:17:50 <jared-w> Well, almost correct font rendering... nisstyre needs to space out their font by about 0.1 points so the letters don't touch each other wrongly
16:18:23 <ertes> that…  sounded weird
16:18:43 <jared-w> whoops, I didn't mean it like that obviously :p
16:18:53 <geekosaur> ... "show us on the doll where the font touched you"
16:19:12 <nisstyre> jared-w: I'm using xfce4-terminal, any idea how to configure that?
16:19:25 <nisstyre> or do I have to do that system wide
16:19:38 <nisstyre> I hate fontconfig with a passion
16:19:51 <ertes> jared-w: don't worry about it…  unix itself has its fair share of really awkward terms
16:19:55 <ertes> shebang
16:20:27 <ertes> (yes, yes, it's supposed to be called hashbang…)
16:20:40 <nisstyre> who thought it would be a good idea to configure fonts using XML?
16:20:43 <Xandaros> unzip; strip; touch; grep; finger; mount; fsck; more; yes; umount; sleep
16:20:55 <nisstyre> I need to strangle them
16:21:00 <jared-w> nisstyre: I've got no idea actually.
16:21:19 <nisstyre> jared-w: I think I would have to mess around with fontconfig
16:21:22 <ertes> i would sexp them
16:21:54 <jared-w> nisstyre: I just used my Xresources to set things and they're fine. In all honest it's *probably* just that you're using a lower resolution screen and so font hinting blurs things enough to touch slightly
16:21:55 <nshepperd> a bunch of unix tools were invented before people realised xml was bad
16:22:03 <nshepperd> i would guess
16:22:14 <nisstyre> jared-w: it's 1920x1080
16:22:42 <Xandaros> I do the same, jared-w, so why do our fonts look so different?
16:22:54 <Xandaros> URxvt*.font: xft:terminus:pixelsize=15:antialias=false
16:23:02 <nisstyre> you have antialising disabled
16:23:11 <nisstyre> why?
16:23:11 <Xandaros> Yes, it looks stupid
16:23:24 <Xandaros> Makes it all blurry
16:23:26 <jared-w> My screen resolution is high enough that I don't need it
16:23:36 <jared-w> But I still have it cause it's nice :)
16:23:41 <nisstyre> URxvt.font:     xft:Hack:size=16:antialias=true
16:23:45 <nisstyre> that's mine
16:24:04 <geekosaur> it might also need tuning; every so often you run into a monitor with the color subpixels arranged differently and default antialias will make a mess
16:24:13 <jared-w> Anyway, Xandaros you're going to need to set URxvt.letterSpace: -1
16:24:16 <nisstyre> that's URxvt though of course...which I don't use anymore
16:24:56 <nisstyre> Xandaros: are you trying to save battery life or something?
16:25:09 <nisstyre> also I'm gonna end the off topicness
16:25:14 <jared-w> In more likelihood you're not actually using Terminus correctly and URxvt is falling back onto a weird font with wrong settings
16:25:14 <ertes> Xandaros: you should enable anti-aliasing *and* hinting
16:25:22 <nisstyre> how bout that laziness
16:25:34 <ertes> Xandaros: that takes care of both the blur and the pixelation
16:25:54 <srpx> hey guys, if anyone could give feedback/insights about those thoughts, I'd be so thankful: http://lpaste.net/raw/357181 - it is basically about whether we should use WASM or a functional core as the main format for sending code through the web (assuming minified JS was a mistake)
16:26:28 <nisstyre> srpx: it sounds similar to what cloud haskell was trying to do
16:27:28 <jared-w> There's two layers of thought here
16:27:43 <jared-w> You're wanting to talk about code at a very high level and yet wanting to serialize code efficiently at a very low level
16:28:27 <lordcirth> jared-w, I believe that's the idea of compiling to Web Assembly
16:28:36 <jared-w> I'm thinking you're going to want WASM and a smart compiler that compiles down into WASM. Since everythings goes into an 'assembly' anyway, caching can happen at the assembly level even with functional languages
16:28:38 <ertes> srpx: the first question that comes to my mind is: is there an actual benefit to sending code instead of data?
16:29:37 <jared-w> optimizing also isn't really done in WASM; that's not the point of it. If you're trying to automatically optimize assembly, you're probably thinking about the problem the wrong way.
16:29:39 <geekosaur> now every web page is a potential exploit \o/
16:30:39 * hackagebot SSTG 0.1.0.3 – STG Symbolic Execution – https://hackage.haskell.org/package/SSTG
16:30:39 * hackagebot hw-balancedparens 0.1.0.2 – Balanced parentheses – https://hackage.haskell.org/package/hw-balancedparens
16:33:18 <srpx> jared-w: sure, but if apps are just compiled asm, then you lose all the caching, no? Example: if two different apps use React, and both get compiled to WASM, then React will be somehow present on both apps bytecodes, but will not be cached by the browser
16:33:34 <srpx> jared-w: if I understand the model you're proposing it leaves no room for caching at all
16:36:29 <jared-w> You can share assembly between apps quite fine. You could denote something as the assembly subroutine for a function and then just call that 'function' and share it between apps. Nothing wrong with that
16:40:58 <lordcirth> Essentially dynamically linked libraries?
16:43:03 <jared-w> sure. You can also have that implemented invisibly by the caching mechanism. Just have it run through all of the assembly and aggressively minimize it, find duplicate sections and rip out stuff, link things together, yadda yadda. Then just have every program believe itself to be the only owner of their code
17:09:55 <rostero> i read a disadvantage of haskell is "Some things, like modifying deeply nested immutable data structures, are hard."  i'm just now learning haskell.  is this still the case?
17:10:11 <srpx> jared-w: but if you share ASM you'll not be able to optimize things by fusion, no?
17:10:12 <rostero> and are there any examples online that show how to manipulate such structures
17:10:32 <rostero> in a not "hard" way
17:11:18 <srpx> I wasn't arguing you can't share ASM, just that if you do you can't optimize by inlining/fusing anymore
17:11:39 <monochrom> lens or microlens makes that not-hard.
17:11:58 <pacak> rostero: You can use lenses to do this modification, but problem is still there - in order to modify something deep inside you will have to modify things all the way to the top.
17:12:09 <monochrom> In fact and then goes on to make easy something hard in other languages.
17:12:31 <monochrom> But you won't hear about it from people of other languages, because it is so hard they don't even want to think about it.
17:13:00 <rostero> i'm not sure i follow that last statement
17:13:54 <monochrom> Namely, if you have seen for example the AVL rebalancng algorithm, you see how it is really two mirror images of the same code, just swapping "left" and "right" (both getter and setter). Have you thought about how to eliminate this duplication?
17:14:10 <monochrom> No, you haven't, because no one has talked about it, because people have already given up.
17:14:20 <monochrom> But it is easy with lens.
17:15:03 <rostero> i'll look into lenses, then.  thanks
17:15:04 <monochrom> lens enables "passing getter-setter as a parameter", among other goodies.
17:15:20 <pacak> :t confusing
17:15:21 <lambdabot> Applicative f => LensLike (Data.Functor.Day.Curried.Curried (Data.Functor.Yoneda.Yoneda f) (Data.Functor.Yoneda.Yoneda f)) s t a b -> LensLike f s t a b
17:21:48 <exio4> monochrom: you're damn right there, there are so many imperative algorithms which become *simpler* with lens 
17:21:58 <monochrom> :)
17:22:36 <monochrom> There is a lot of religion and brainwashing among programmers.
17:23:13 <monochrom> If they can't figure out something, they decree "no one cares".
17:25:18 * EvanR comes in an sits at the front row of church of FP and puts on disciple hat
17:25:54 <n_blownapart> hi is there any difference when we see parentheses around a type constraint, than without them, like this ?  (Eq a) => a -> a -> Bool
17:25:57 <EvanR> 10% of your performance must be sacrificed to lazy evaluation
17:26:41 <n_blownapart> Eq a => a -> a -> Bool      << as opposed to this
17:26:46 <EvanR> no
17:27:12 <EvanR> because this isnt lisp :)
17:27:21 <EvanR> Eq a = ((((Eq a))))
17:27:48 <geekosaur> n_blownapart, some people use the parens always. because if you have more than one constraint, it is e.g. (Eq a, Show a) => ...
17:28:02 <geekosaur> parens necessary there
17:28:57 <n_blownapart> so just use them for good practice , that makes sense
17:30:06 <EvanR> use 3 pairs of parens for good measure
17:30:18 <EvanR> its like brushing your teeth
17:30:42 <n_blownapart> brushing your teeth is the law, though. its not optional
17:30:44 <monochrom> The average programmer uses 0.113927348 pairs of parenthesis
17:31:04 <monochrom> And indents by 3.14159277334 spaces
17:31:06 <Logio> is there some syntax which necessitates those parentheses, btw?
17:32:19 <Axman6> only if there's multible constraints
17:32:36 <Logio> I know, but why are they necessary in that case?
17:33:11 <Logio> why can't ghc parse a comma-separated list of constraints until "=>"?
17:33:24 <EvanR> > 337/113
17:33:27 <lambdabot>  2.982300884955752
17:33:29 <monochrom> They were probably just analogizing tuple notation.
17:33:32 <EvanR> > 377/113
17:33:34 <lambdabot>  3.336283185840708
17:33:39 <EvanR> :<
17:33:43 <n_blownapart> readability ?
17:33:47 <monochrom> But then you could also raise: why does tuple notation require parentheses
17:33:55 <monochrom> And then I don't know.
17:33:56 <glguy> If you don't like the parens you can do:  Read a => Show a => stuff -> stuff
17:34:04 <monochrom> But I know. It's a committee decision. Done.
17:34:05 <nshepperd> Logio: it would be ambiguous, now that constraints are valid types
17:34:20 <monochrom> Actually it's a bit more interesting than that.
17:34:46 <nshepperd> is it (Eq a, (Show a => blah)) or ((Eq a, Show a) => blah)
17:34:48 <Logio> nshepperd: ah, so it's really being parsed as a tuple?
17:35:02 <monochrom> They agreed a priori the convention "if there is a syntax bikeshedding question, we won't argue, the first proposal is passed"
17:35:09 <monochrom> So this would be one of them.
17:36:02 <monochrom> So, just sheer good luck or bad luck in this branch of the multiverse, in which "requires parentheses" was proposed first by chance, so it was passed.
17:36:44 <nshepperd> Logio: pretty much
17:36:55 <EvanR> i like no-parens tuples
17:37:00 <nshepperd> (Eq a, Show a) has kind Constraint
17:37:01 <EvanR> also no-parens sequence
17:37:12 <Logio> it just always bugs me that code which seems perfectly unambiguous and reasonable does not compile
17:37:20 <srpx> so I'm thinking a lot about the WASM vs small functional core - I think I'll use WASM, if only because it will probably increase the hype factor and adoption odds (shamefully, because I still think it'd be a worse solution)
17:37:23 <monochrom> I think Perl has no-parens tuples.
17:37:28 <n_blownapart> what's kind constraint exactly ? just reading about it to no avail
17:37:29 <Logio> (and I always forget the parens at some point)
17:37:32 <EvanR> the syntax is like the syntax for integers, 999 is just 999. figure out what it is interpreted as later
17:37:52 <srpx> "hey this browser's apps are specified with a small functional core" - meh
17:38:08 <srpx> "hey this browser's apps are defined directly with asm" - wooooooow the future
17:38:12 <srpx> wasm*
17:38:30 <EvanR> if its about hype, do the better thing, an spin it as the other
17:38:39 <nshepperd> i don't like no-parens tuples. it means a,b,c is neither (a,b),c nor a,(b,c)
17:38:40 <EvanR> like hybrid kernels
17:38:45 <monochrom> Is there a difference between functional core and asm?
17:38:53 <EvanR> a,b,c is the sequence a,b,c
17:39:36 <srpx> monochrom a lot I guess, if I receive a WASM bytecode and compile it, I'll not be able to do compile it to a well-typed native term and do something like app.render.icon()
17:39:40 <EvanR> it could be ((a,b),c) (a,(b,c)) (a,b,c) [a,b,c] depending on the needs of the moment :)
17:40:11 <nshepperd> EvanR: so what's its type
17:40:14 <srpx> using a small functional core gives structure to the thing code I parse and compile, it just looks so much easier to work with in general
17:40:18 <monochrom> nshepperd, I think I can come up with a self-consistent grammar such that "a,b,c" is a 3-tuple, "(a,b),c" is a 2-tuple in which the 1st component is a 2-tuple, and "a,(b,c)" the other way round.
17:40:22 <EvanR> its pre-typal
17:40:25 <exio4> nshepperd: ∃e.e
17:41:09 <srpx> EvanR: I'm not really sure a small functional core is the superior option here anymore, they have very good arguments for asm and I'm yet to see someone else supporting a small core
17:41:15 <nshepperd> EvanR: 999 has a type
17:41:31 <srpx> and not sure I'm with enough patience to defend that choice against all the hate it generates
17:41:39 <monochrom> srpx: I guess WASM is a very specific, already defined asm, rather than an asm I can start designing now such that it's equivalent to functional core (e.g., I could design a typed asm...)
17:41:42 <EvanR> yeah at some level, we intuitively see it as fromInteger (999 :: Integer)
17:41:54 <nshepperd> :t 999
17:41:55 <EvanR> but at a lower level, 999 appears as is
17:41:56 <lambdabot> Num t => t
17:42:23 <srpx> monochrom yes yes, WASM is the new asm.js... i.e., a small assembly-like language. they're making a standard for it and trying to kill javascript again
17:42:56 <srpx> and your browser has it now, check out window.WebAssembly on the console
17:42:58 <monochrom> Ah
17:43:19 <monochrom> Whenever you can't explain something by technical merit, explain it by corrupt bribery. :)
17:43:47 <ReinH> monochrom: I mean...
17:43:55 <monochrom> Namely, Symantecs is bribing the web people to switch over to WASM so that Symantecs can sell anti-virus for web browsers in the future!
17:44:16 <srpx> as a side note, I'd love if WASM became a GHC target
17:44:32 <srpx> monochrom lol
17:44:43 <EvanR> nshepperd: theres this funny part in the idris parser which looks at syntax and produces zero or more interpretations... you could use it to say... 'c' is a particular Char, or its a particular CChar heh
17:44:56 <nshepperd> llvm -> webasm is inevitable
17:44:56 <EvanR> later it is type checked
17:45:00 <monochrom> But yeah, WASM can open up opportunities for many more languages.
17:45:01 <srpx> I do think WASM is pretty cool tho, just not sure if it is the right solution for shipping code through the wire
17:45:17 <EvanR> but 'c' has no proper type of its own
17:45:29 <nshepperd> come to think of it surely llvm -> js would already exist
17:45:53 <nshepperd> oh, that's emscripten
17:46:01 <exio4> llvm -> asm.js, I thought?
17:46:27 <monochrom> llvm -> node.js -> llvm -> llvm.js
17:51:57 <monochrom> They should have done this instead: http://jpc.sourceforge.net/home_home.html
17:53:06 <n_blownapart> sorry the other day someone showed me how to go the next level down to find a type. so if ':t 99'   gives us  99 :: Num t => t  , what is the ghci input to get that it is an Integer ? 
17:53:37 <geekosaur> there isn't one; that *is* its type. it becomes more specific only if you use it in a context which requires it to be more specific
17:53:58 <pacak> :t 99 :: Integer
17:53:59 <lambdabot> Integer
17:54:06 <geekosaur> this is why you can add a literal 1 to a Double instead of having to write 1.0 or whatever
17:54:15 <pacak> :t 99 :: Int
17:54:17 <lambdabot> Int
17:54:23 <pacak> :info Num
17:54:25 <monochrom> I think instead you turn on a warning so ghc/ghci warns you of what defaulting it carries out.
17:54:28 <geekosaur> no :info in here
17:54:34 <pacak> Yea, keep forgetting :(
17:54:50 <pacak> :t fromInteger
17:54:52 <lambdabot> Num a => Integer -> a
17:54:56 <monochrom> @info do { x<-y; return x }
17:54:56 <lambdabot> y >>= \ x -> return x
17:54:58 <monochrom> :)
17:55:21 <pacak> :t fromString -- also this
17:55:23 <lambdabot> IsString a => String -> a
18:01:24 <n_blownapart> sorry disconnected I was asking about a bound. I think it had to do with how many bits a number requires
18:02:24 <geekosaur> that didn't make it here
18:02:43 <pacak> Bound - as in Bounded? If so - it's nothing to do with bits in general.
18:02:49 <geekosaur> [25 00:52:44] <n_blownapart> sorry the other day someone showed me how to go the next level down to find a type. so if ':t 99'   gives us  99 :: Num t => t  , what is the ghci input to get that it is an Integer ? 
18:02:53 <geekosaur> is the last thing you said in here
18:03:39 <n_blownapart> cool appreciate it . Let me sort it out . geekosaur 
18:04:25 <n_blownapart> types are beginning to sink in. its exciting.
18:04:39 <geekosaur> Bounded in the general case involves the number of constructors. specifically for Int it will be based on the number of bits in a machine word (in ghc it's the same, in other implementations it may be smaller as the implementation is allowed to steal a couple of bits for tagging)
18:05:24 <geekosaur> also most ghc-s built on a 32 bit platform will use a 64 bit Int by default even though it's slower than the native word size
18:06:26 <n_blownapart> it was like, I'm making this up : -234167894 and 234167893, that's int, then it goes up to integer 
18:06:50 <n_blownapart> where zero is obviously included with positive numbers
18:07:28 <n_blownapart> or integer, then going up to int. sorry I forget
18:07:36 <jle`> types are awesome
18:08:08 <n_blownapart> yes very intrigued here
18:11:02 <Welkin> so ghc 8.2 shipped
18:11:06 <Welkin> that was fast
18:13:34 <kadoban> Oo did it? Nice
18:15:45 <Welkin> https://ghc.haskell.org/trac/ghc/blog/ghc-8.2.11-released
18:15:51 <geekosaur> "fast"?
18:16:08 <geekosaur> wasn't the original schedule for sometime in April?
18:16:13 <kadoban> 8.2 is the one that has colored output, right? I gotta check that out. Also the other changes sound really nice xD
18:16:31 <geekosaur> (but as usual, weird platform-specific Issues slowed stuff down)
18:16:41 <Welkin> geekosaur: I haven't kept up with releases, and I only heard about 8.2 very recently, so it seemed fast to me
18:16:43 <jaseemabid> Anyone here familiar with the llvm-hs library? I generated a module that is segfaulting GHC and I really cannot debug this. This is the module. d http://lpaste.net/357182.
18:20:47 <monochrom> kadoban: Yes, "what's new" says colored error messages, I'm thoroughly horrified :)
18:21:30 <monochrom> Now the white-background people and the black-background people are going to fight over bikeshed colouring, literally!
18:21:57 <Welkin> I like the coloring in the purescript compiler
18:22:07 <Welkin> I wonder if it's similar (or better)
18:22:10 * monochrom uses white background in emacs, black background in terminals. Riding on the fence!
18:22:48 <EvanR> i prefer black background, black foreground
18:23:28 <boj> i too prefer the black on black. easy on the eyes
18:23:53 <EvanR> in old games that let you set the entire 16 color palette, i was the guy with 16 shades of black
18:24:28 <monochrom> It was amber for me.
18:24:35 <Welkin> stealth programming?
18:24:42 <Welkin> not even you can see what is on the screen
18:24:43 <kadoban> monochrom: Hah. Isn't that handled by terminals already though? I thought there were set colors you could adjust as a group so they're actually all visible.
18:25:00 <EvanR> yes black defeats the diffuse reflection telescopes
18:25:02 <monochrom> Ah I don't know.
18:25:53 <EvanR> burn before reading
18:26:43 * pacak uses gray on gray
18:28:34 <monochrom> 8.4 will have 3D error messages.
18:28:45 <EvanR> you mean, like word art ?
18:29:45 <monochrom> word art if your monitor is not a 3DTV
18:30:16 <Welkin> it doesn't output errors using the system bell and morse code?
18:32:08 <monochrom> No, but GHC 10 will manipulate gravity to move your clock hands to do morse code.
18:32:39 <geekosaur> system bell is for gc :p
18:35:21 <EvanR> i only interact with the computer via a jazz quartet
18:35:33 <orion> What exists in memory with boxed sum types vs. unboxed sum types?
18:35:56 <orion> For example: data Foo = A | B | C | D
18:36:14 <Axman6> I believe that wil become a field in the type it is unpacked into
18:36:22 <Axman6> so the tag will be inline
18:36:58 <kadoban> monochrom: Does it at least manipulate gravity in the past to tell you before you write errors?
18:37:14 <Axman6> and IIRC data Foo = Foo String {-#UNPACK#-}!(Maybe Int) will have space for an Int# allocated to Foo and a coupld of tag bits
18:40:41 <n_blownapart> what is an anonymous product type, anonymous sum type (or the lack thereof in haskell) and an anonymous union type? I can find no definitions of these things for a layman. All I could find is that a tuple is an anon. product type 
18:41:20 <kadoban> n_blownapart: Do you know what product types and sum types are in general?
18:42:29 <n_blownapart> no kadoban the book I'm using casually reads that "Tuples in Haskell are the usual
18:42:29 <n_blownapart> means of expressing an anonymous product."
18:42:43 <Axman6> yeah, tuples are annonymour product types
18:42:50 <Axman6> annonymous*
18:42:58 <Axman6> man I can't type
18:43:17 <n_blownapart> guitarists(?) shouldn't need to type
18:43:24 <Axman6> Haskell now has anonymous sum types though, part of the unpacked sum types
18:43:37 <n_blownapart> what does it all mean?
18:43:57 <Axman6> so, do you agree that Bool has two inhaitants?
18:44:04 <Axman6>  and Maybe Bool has three?
18:44:16 <n_blownapart> yes True and False  ... 3?
18:44:22 <Axman6> False, True and Nothing, Just False and Just True respectively
18:44:43 <Axman6> how many inhavitants does (Bool, Maybe Bool) have?
18:44:51 <Axman6> inhabitants
18:45:50 <n_blownapart> um 3 .. sorry what's Maybe Bool
18:45:52 <n_blownapart> ?
18:45:55 <Axman6> if we say |Bool| = 2, |Maybe Bool| = 3
18:46:06 <Axman6> Maybe Bool is Maybe a with a = Bool
18:46:07 <pacak> n_blownapart: + outer bottom, plus fst bottom, + snd bottom, +Just bottom.
18:46:12 <Axman6> are you not familliar with Maybe?
18:46:21 <Axman6> pacak: fast and lose reasoning, shush :P
18:46:54 <jle`> pacak: definitely the wrong time/audience to bring that up, heh
18:47:27 <jle`> (instead of Maybe Bool, maybe data Ordering = LT | EQ | GT might work for 3?)
18:47:37 <Axman6> yeah
18:48:01 <Axman6> n_blownapart: you understand how |Ordering| = 3? because it has three values, LT, EQ and GT?
18:48:15 <pacak> 4...
18:48:19 <Axman6> shush
18:49:09 <Axman6> and they're gone :\
18:49:20 <pacak> ᴮᵘᵗ ᴴᵃˢᵏ ᶜᵃᵗᵉᵍᵒʳʸ
18:49:39 <n_blownapart> sorry I keep losing my connection in this blasted cafe
18:49:53 <Axman6> n_blownapart: do you understand how |Ordering| = 3? because it has three values, LT, EQ and GT?
18:50:24 <pacak> ₄... 
18:50:30 <n_blownapart> sorry yes Ordering can only return one of the 3
18:50:52 <Axman6> and you're happy with |Bool| being 2, and |Word8| = 256, etc?
18:51:10 <Axman6> we're going to ignore bottoms for this dicussion
18:51:13 <monochrom> Oh w00t unboxed sums. Is this new in 8.2.1? Or was this in 8.0.2 already?
18:51:19 <Axman6> 8.2
18:51:21 <jle`> monochrom: it's new :O
18:51:22 <n_blownapart> sure |BOOL| is 2, what is the pipe notation?
18:51:44 <pacak> "size of domain"
18:51:46 <Axman6> I'm using it to denote "size of" or "number of inhabitants, it's not Haskell syntax
18:51:49 <pacak> Not a notation
18:51:55 <n_blownapart> ok cool
18:51:58 <kadoban> Well, it is a notation, just not a haskell one.
18:52:13 <pacak> Hmm... Right. Not a haskell one.
18:52:20 <n_blownapart> ok I like inhabitants 
18:52:27 <Axman6> so if we have |Bool| = 2, |Ordering| = 3, what is |(Bool, Ordering)|?
18:52:39 <n_blownapart> (2,3)
18:52:51 <Axman6> no, it's always a number
18:52:53 <pacak> n_blownapart: But it's acltually a lie! There's bottoms! Bottoms everywhere!!!!
18:52:59 <Axman6> pacak: please shut up
18:53:25 * pacak sighs
18:53:46 <pacak> n_blownapart: You have two bits. How many combinations can you make?
18:53:58 <jle`> yeah, bringing up bottoms isn't really appropriate when introducing someone to the algebra of algebraic data types
18:54:15 <Axman6> yes, it's just getting in the way
18:54:42 <Axman6> n_blownapart: so |(Bool,Ordering)| = 6, or 2*3
18:54:51 <n_blownapart> I would love to follow Axman6 's instruction
18:54:57 <monochrom> Well by the time you get to "data X = X0 (Int -> X) | X1 (X -> Int)" even the part about "algbraic" is a lie, you have analytic, transcendental types.
18:55:07 <Axman6> |(Bool,Word8)| = 512, or 2*256
18:55:11 <ReinH> |(Bool, Ordering)| = |Bool| * |Ordering|
18:55:32 <n_blownapart> ok, we multiply. 
18:55:36 <Axman6> so in general, |(a,b)| = |a|*|b|, ie, the product
18:55:57 <n_blownapart> with anything you can put in a tuple?
18:56:04 <srpx> monochrom what?
18:56:12 <Axman6> you can see how it is 6 by thinking of all the combinations of Bools and Ordering
18:56:32 <monochrom> X->Int is Int^X.
18:56:42 <n_blownapart> ok got that.
18:56:49 <n_blownapart> not immediate ^
18:56:53 <kadoban> In other words it's a type that is a product of other types. A product type. And since it's not being given a name, it is an anonymous product type.
18:57:06 <Axman6> so now we introduct sum types: Either a b = Left a | Right b
18:57:27 <monochrom> A recursive type gives you an infinite series. "data Y = Nil | Cons Int Y" is "1 + Y + Y^2 + Y^3 + ..."
18:57:31 <ReinH> Don't give the game away lol
18:57:42 <Axman6> if we have Either Bool Ordering, we have 5 inhabitants: Left False, Left True, Right LT, Right EQ and Right GT
18:58:04 <Axman6> monochrom: you're jumping ahead too far
18:58:13 <n_blownapart> ok, hold on please. so earlier, we were talking about two constraints in a type def, (geekosaur 's help) and they were listed with parens, like a tuple. is this similar?
18:58:14 <monochrom> I'm answering srpx.
18:58:18 <ReinH> |Either a b| = |a| + |b|, which is why we call it a coproduct.
18:58:20 * ReinH ducks
18:58:30 <kadoban> xD
18:58:42 <Axman6> urgh, ok, you guys can do this, I have better things to do
18:58:58 <monochrom> Should I use ROT13?
18:58:59 <EvanR> :(
18:59:17 <kadoban> monochrom: twice
18:59:36 <ReinH> You have to do ROT13 an odd number of times, and the more the better.
18:59:58 <pacak> Isn't 13 enough? It says 13 in the name....
19:00:09 <EvanR> hyperbolic complex transcendental types
19:00:20 <n_blownapart> I was following. can I have fewer cooks in the pot?
19:00:40 <Axman6> whatever happened to #haskell being helpful, this has become a joke. sorry n_blownapart
19:00:45 <monochrom> I thought cooks were outside the pot.
19:00:52 <Axman6> and now I have to leave
19:01:00 <n_blownapart> sorry Axman6 I was following no worries  thanks!
19:01:00 <pacak> n_blownapart: You might get better luck finding a book online and asking specific questions for parts you don't understand.
19:01:02 <ReinH> If you really want to be secure you have to do it 2^n - 1 times where n is a large integer.
19:01:42 <monochrom> Also I was not a cook. I was discussing with other people.
19:01:53 <ReinH> That's why it's called elliptic cryptography.
19:02:01 <n_blownapart> whatever
19:02:26 <n_blownapart> I gleaned a little from that thanks all
19:02:57 <ReinH> n_blownapart: You could also read the first few chapters of Algebra by Mac Lane and Birkhoff.
19:03:44 <ReinH> It's very approachable for a Mac Lane book, which I attribute mostly to Birkhoff.
19:04:10 <n_blownapart> will do but I'm trying to get through a book on haskell that assumes little background
19:04:23 <Axman6> this could have been a simple 10 minute discussion
19:04:34 <n_blownapart> word Axman6 glad you're still here
19:04:59 <srpx> monochrom sure it gives you an inifinite series but?
19:05:10 <monochrom> So it is no longer algebraic.
19:05:13 <Welkin> Algebra is a good book
19:05:22 <n_blownapart> Axman6, care to move to beginners channel if you have time?
19:05:23 <EvanR> algebra by who
19:05:24 <Welkin> it still took me 30 minutes to read one page though
19:05:33 <Welkin> Saunders MacLane
19:05:44 <EvanR> oh i see up there
19:05:44 <srpx> why that makes it not algebraic?
19:06:14 <srpx> what is your definition of algebraic?
19:06:22 <monochrom> Polynomial.
19:06:40 <srpx> hmmm. isn't an infinite series a polynomial? ...
19:07:36 <ReinH> I feel like monochrom is committing an equivocation fallacy but I'm not sure.
19:07:37 <srpx> SoundLogic: cool band name
19:08:35 <monochrom> Polynomials are finite power series.
19:08:54 <monochrom> I guess that's poor words. Finite power sums.
19:08:59 <ReinH> As an algebra of ADTs aside, type theory is one of the few places where 0^0 = 1 is well motivated.
19:09:06 <srpx> hmm I see monochrom
19:09:25 <srpx> why so, ReinH
19:09:31 <ReinH> id :: Void -> Void
19:09:59 <lordcirth> Is void really 0 though?
19:10:01 <monochrom> You could say I'm making an artificial distinction, but experience from math and denotational semantics say otherwise. Techniques you bring to finite power sums are very different from techniques you bring to infinite series and/or recursion.
19:10:21 <ReinH> In set theory, it's an empty function ∅ -> ∅
19:10:37 <EvanR> void :: forall a . Void -> a
19:11:05 <monochrom> For example the denotational semantics of recursive types took Dana Scott new techniques, techniques even more difficult and technical than those for recursive programs
19:12:14 <ReinH> In Haskell, Void is 0 up to bottom. In other type theories (total ones), 0 is really 0.
19:13:13 <ReinH> Oh, that reminds me. What do you call it when 1 * 1 = 4?
19:13:31 <ReinH> Sorry. 5.
19:14:05 <monochrom> 0^0 = 1 is also much appreciated by combinatorists, but then they're basically using the same reason as ∅ -> ∅.
19:14:18 <srpx> ReinH that's Haskell since bottom inhabits every type
19:14:40 <ReinH> srpx: Yep.
19:15:16 <monochrom> Hrm, when does 1 * 1 = 5 happen?
19:15:26 <srpx> yay
19:16:28 <pacak> > let 1 * 1 = 5 in 1 * 1
19:16:30 <lambdabot>  5
19:18:16 <ReinH> monochrom: ⊥, (⊥, ()), ((), ⊥), (⊥, ⊥), ((), ()) :: ((), ())
19:18:32 <monochrom> Oh, that.
19:19:03 <monochrom> Lifted product of two lifted singletons.
19:20:11 <monochrom> Basically with Haskell-like non-strictness you say "lifted" left right and centre.
19:20:55 <monochrom> And then with GHC-like choice-of-lifted-and-unlifted you say "lifted" and "unlifted" all over the place.
19:21:02 <ReinH> I feel like McBride could turn that into a catchy paper title
19:21:17 <ReinH> It wouldn't be a very interesting paper though
19:21:53 <monochrom> Haha, I can see how to may go. "To lift the lifted"
19:23:22 <ReinH> Who lifts the lifters?
19:25:20 <ReinH> Do you even lift?
19:29:12 <trigone> Hi, when is it better to put arguments into a custom ADT instead of passing them directly? Using a type synonym, you nearly end up with the same thing. the only difference is, the custom ADT is data and can be passed as output, otherwise you have to do a sort of callback style, giving the client function (as argument) to the server that formats the arguments and calls the client function with them. (am i making sense?)
19:29:39 <monochrom> When your arguments have very rich structure.
19:29:46 <trigone> (here server/client is just a metaphor)
19:29:59 <trigone> monochrom: define very rich?
19:30:00 <monochrom> For example too many of them, or too many cases, or too many variations.
19:31:25 <trigone> monochrom: hm... so if i have three of them, better do it callback style? because it feels like things are less separated, less flexible, since i don't compose the "server"and "client" with (.), and instead i give the client to the server...
19:31:35 <trigone> maybe it's an incorrect feeling
19:32:02 <SoundLogic> Is there a way to make a type level const? So I could have Const Integer results in a * -> * which always results in the Integer type. Type families and type aliases can't seem to be partially applied...
19:32:25 <monochrom> I didn't say callback style. You said ADT so I'm saying ADT. If you have 3 parameters, you think about whether a product type of 3 fields is better or not.
19:32:25 <ReinH> Const exists.
19:32:26 <trigone> ofc it nonetheless feels more elegant without the ADT too...
19:32:45 <monochrom> It also depends on the other 999 lines of code so I can't tell you a deterministic answer.
19:32:55 <ReinH> @hoogle Const
19:32:56 <lambdabot> Control.Applicative newtype Const a b
19:32:56 <lambdabot> Control.Applicative Const :: a -> Const a b
19:32:56 <lambdabot> module Data.Functor.Const
19:33:04 <monochrom> (Or rather, I'm too lazy to. Of course I could enumerate all 2^999 possibilities.)
19:33:14 <trigone> monochrom: i said ADT as one of two possibilities... maybe i wasn't clear enough? what are your two options?
19:33:25 <saylu> I’m about to implement user authentication in Servant — log in, access protected resources — does anyone have favorite resources / guides / info they could point me to that could help? Besides the official tutorial?
19:33:27 <EvanR> trigone: are you sure this is 1 function and not several/many functions with different signatures
19:33:37 <EvanR> and your rich language is only there to choose the function
19:33:42 <ReinH> It's very hard to answer trigone's question in entirely abstract terms
19:33:50 <ReinH> ADTs are better when they are better.
19:33:53 <monochrom> X -> Y -> Z -> T  vs  XYZ -> T  where XYZ is "data XYZ = Ctor X Y Z"
19:33:53 <trigone> "product type of 3 fields is better or not" --> better than what?
19:33:56 <ReinH> For various values of "better".
19:34:29 <monochrom> This teaches me to never answer a broad question again.
19:34:59 <EvanR> X -> Y -> Z -> T allows currying
19:35:02 <monochrom> "Honey which T-shirt should I wear today?"  "Sorry I have to go to the washroom."
19:35:15 <SoundLogic> ReinH: You mean the Const functor? 
19:35:21 <trigone> monochrom: yeah that was it. except, if X, Y and Z are produced by a function "server" f, and i don't use ADT, i gotta have f :: (X->Y->Z) -> K -> T, where K is whatever type from which f will derive the arguments of type X, Y and Z
19:35:31 <ReinH> SoundLogic: Well, Const is a type constructor.
19:35:47 <monochrom> No, the server would have given you (X,Y,Z)
19:35:56 <SoundLogic> Const Integer String isn't Integer though?
19:36:01 <trigone> EvanR: i think you're giving me the intuition that unless i have more than one function, i don't really require bundling the fields into an ADT
19:36:10 <SoundLogic> It has a newtype wrapper around it
19:36:17 <ReinH> Const Integer String is isomorphic to Integer.
19:36:32 <EvanR> trigone: well, do you see a benefit, in your case (whatever it is) to requiring a bundling-into-an-adt
19:36:37 <trigone> monochrom: technically (X, Y, Z) or XYZ, i don't see a useful difference.
19:36:56 <SoundLogic> Yes, but I would have to wrap and unwrap things all the time
19:37:19 <EvanR> (X,Y,Z) -> T is the classic thing haskell doesnt usually want you to do
19:37:52 <EvanR> and js goes to great pains to undo
19:37:56 <trigone> EvanR: i have a tendency to try to anticipate future modifications. plus i think i prefer coding with too much "reusabilism" even if the situation does not require it, it probably gives me better habits.
19:38:13 <EvanR> too much reusability? haha
19:38:16 <trigone> EvanR: javascript?
19:38:18 <EvanR> i hate it when that happens
19:38:46 <ReinH> Trying to predict every way your code can change ironically leads to code that is harder to change.
19:39:07 <EvanR> thats why generic code is great
19:39:29 <trigone> EvanR: so, it does is better if i have g :: X->Y->Z->T and f :: (TypeOfG) -> K -> T rather than g :: (X,Y,Z)-> T and f :: K -> (X,Y,Z)?
19:39:30 <EvanR> once its written, you get the feeling it cant be changed, its too perfect
19:40:05 <EvanR> and if its composable, "changes" come in the form of some-other-generic-code, thats independent
19:40:13 <trigone> and then i have (f g) k instead of  (g . f) k with k :: K
19:40:15 <EvanR> write more composable code, then compose it
19:40:35 <trigone> EvanR: nah i'd think to compose code and leave it like that to admire it
19:40:39 <EvanR> trigone: arent you missing a "instead of f ((,,) x y z) somewhere
19:41:00 <EvanR> or g of that
19:41:46 <EvanR> actually i am kind of sad that returns have to be in the form of a tuple
19:41:51 <trigone> EvanR: hm no, f would have type f :: K -> (X, Y, Z) in that case. yes it'd be equivalent to your other f applied to (,,)
19:42:10 <EvanR> if (X,Y,Z) some kind of special record that you will always have everywhere?
19:42:15 <trigone> EvanR: "in that case" -> in the case i was talking about
19:42:28 <EvanR> you could make it a record 
19:42:30 <trigone> EvanR: actually it's mostly just for g and nothing else :)
19:42:36 <EvanR> :(
19:42:44 <trigone> EvanR: yeah, it's not worth it is it?
19:42:48 <EvanR> if this is 1 time code, who cares
19:43:27 <EvanR> otherwise, do like 99.999999999% of other code and use currying
19:43:37 <trigone> EvanR: no code is one-time code if you take into account what you learn from doing every thing properly
19:43:39 <ReinH> This discussion has enough context to be completely useless.
19:43:47 <trigone> ReinH: enough?
19:44:01 <EvanR> yes
19:44:19 <EvanR> lpaste actual code and have people opinionatedly refactor it
19:44:38 <trigone> EvanR: ok, 2 secs then
19:44:43 <Welkin> I'm curious what the best haskell books are right now
19:45:02 <Welkin> I notice Graham Hutton came out with a new book last year
19:45:08 <ReinH> Hutton's new book is great.
19:46:08 * hackagebot servant-pandoc 0.4.1.3 – Use Pandoc to render servant API documentation – https://hackage.haskell.org/package/servant-pandoc
19:46:47 <monochrom> trigone, there is no one simple universal rule for properly. At least not simples ones like "always use your own record type" or "no, always use tuples" or "no, don't listen to them, always use currying".
19:47:37 <monochrom> At your beginner stage you should either be optimistic and just throw a die and random choose one way. Or be pessimistic and fork 3 branches to do all 3 ways.
19:47:51 <Welkin> the issue with tuples is that they already have instances defined for common type classes that you may not want
19:47:58 <monochrom> I heard that git makes branching pretty trivial so it should be OK.
19:48:00 <Welkin> fmap only maps over the second parameter
19:48:03 <Welkin> for example
19:48:58 <monochrom> As far as toy programs go, you probably have only 4 functions. So if you do 3 ways for each function...
19:49:06 <monochrom> > 3^4
19:49:08 <lambdabot>  81
19:49:21 <trigone> monochrom: i never seek any general solution for even relatively big sets of problems. i wasn't seeking a yes/no answer, more like a debate (and now we're sorta meta-debating)
19:49:25 <monochrom> I think that's still a manageable number of branches!
19:49:48 <monochrom> @quote monochrom debate
19:49:48 <lambdabot> monochrom says: All pointless debates can be settled by going polymorphic.
19:50:01 <trigone> monochrom: i don't use git yet :P
19:50:11 <boj> you monster
19:50:49 <trigone> ok, here's my paste. https://pastebin.com/2D0Tmpsc
19:51:04 <trigone> there could be other solutions i have not thought about, mind you.
19:51:23 <EvanR> maybe the answer is more humble: this channel isnt smart enough to answer :)
19:51:54 <monochrom> Yes, that's actually a reasonable stance.
19:51:56 <R0B_ROD> using stack build yesod-bin cabal-install --install-ghc takes a good bit...retrieved 111 files... is it normal? first timer to all this ecosystem
19:52:01 <R0B_ROD> i asked in yesod
19:52:17 <Welkin> R0B_ROD: yesod is huge on its own
19:52:22 <monochrom> But I have economic inclinations. I may also say you haven't paid enough for a high-quality answer.
19:52:28 <trigone> EvanR: what?
19:52:30 <Welkin> if you are also building ghc, then it will take a while
19:52:50 <Welkin> yesod takes 30-40 minutes to build for me
19:52:54 <monochrom> If you paid me cdn$4000 per month, I could be your consultant.
19:53:00 <Welkin> ghc from abinary distribution takes 30 minutes at least
19:53:17 <EvanR> how many different ways can you justify not having a clue
19:54:01 <trigone> EvanR: that's directed to me?
19:54:05 <monochrom> I don't think stack actually builds GHC? At worse it downloads GHC.
19:54:06 <EvanR> no
19:54:40 <monochrom> EvanR: I know one way. Take the stance that there is no free will. :)
19:54:46 <Welkin> you're right
19:54:50 <Welkin> it builds base though
19:55:08 <monochrom> That also sounds wrong, but I don't have evidence, so meh.
19:55:16 <Welkin> I could be wrong too
19:55:28 <trigone> so, nobody has an opinion on my paste? cuz earlier it was quite confusing, not sure to have understood everything you could have tried imparting me with..
19:55:33 <Welkin> I might be remembering the last time I used a binary distribution
19:55:38 <monochrom> However, yesod and dependencies can already take forever to build.
19:56:00 <monochrom> Plus if you are low on RAM and go into swap space, it can take forever^2.
19:56:21 <ReinH> I think you mean 2^forever
19:56:40 <monochrom> And it doesn't have to be because it's hard on GHC. It can be merely because it's hard on ld.
19:57:48 <EvanR> disable swap to make forever get here sooner
19:59:28 <trigone> ok, i'll rephrase my question in hope of enlightenment: is there a third way between using bundling types (a nuple or whatever) and giving the processor of the data to the parser of the data as argument? cf my paste if it's not clear
19:59:49 <monochrom> trigone: As said, both have applications. For consultance when you have a larger project, my fee is cdn$4000 per month...
20:00:21 <trigone> and by third way, that's taking into account the goal of separating the processing from the parsing, in the idea of composability blabla
20:00:51 <monochrom> Also controversies can be resolved by the economic argument: https://xkcd.com/808/
20:02:51 <trigone> monochrom: i keep telling that to my newage friends, doesn't deter them from thinking the pharmaceutical industries could never make profit out of mystical panacea
20:03:19 <R0B_ROD> thank you Welkin 
20:03:50 <trigone> so, nobody aside from monochrom's capitalism to help me?
20:04:42 <EvanR> not sure if its any more specific now than before, your question
20:05:24 <EvanR> to return N different things, use a tuple or record. to return between zero and infinity of the same thing, use a list
20:05:32 <monochrom> Over here in #haskell we don't debate over "should you use direct style or should you use CPS".
20:05:40 <trigone> EvanR: i can't make everything specific.....
20:05:46 <monochrom> But we do debate over "cabal or stack? fight!"
20:05:55 <trigone> monochrom: so, "callback style" as per my paste is CPS? i was wondering if i t were
20:06:04 <monochrom> Yes.
20:06:25 <trigone> monochrom: cool
20:07:41 <trigone> Ok, another question: when is it justified to create a custom type instead of using a n-uple?
20:07:56 <Welkin> trigone: almost always
20:08:08 <Welkin> a tuple of size greater than 2 is probably never what you want
20:08:35 <Welkin> I've used tuples for pattern matching though
20:08:59 <Welkin> for some variables a, b, and c `case (a, b, c) of ...`
20:09:08 <Welkin> which allows you to match on 3 variables at once
20:11:24 <trigone> Welkin: yeah... still, creating an ADT just for one single item feels stupid... and verbose
20:11:25 <Welkin> the problem with using tuples at a data type is that you lose information about the intent
20:12:37 * hackagebot pg-recorder 0.2.0.0 – Initial project template from stack – https://hackage.haskell.org/package/pg-recorder
20:12:37 * hackagebot postgrest-ws 0.3.3.0 – PostgREST extension to map LISTEN/NOTIFY messages to Websockets – https://hackage.haskell.org/package/postgrest-ws
20:14:46 <trigone> Welkin: hm... yeah but in my case i already newtyped the subfields, so the intent is pretty much enough secured by the types of the subfields. you meant in cases of very vague tuples like (String, String, Int)?e
20:14:47 <EvanR> trigone: whether it would help you by introducing more type safety, or get in the way and make no sense... depends on circumstances
20:15:52 <EvanR> "when should i make a type for something" is pretty vague
20:16:11 <trigone> EvanR: when did i say that?
20:16:20 <EvanR> just now
20:16:41 <EvanR> after years of writing haskell you may not know when and what kind of type to define
20:17:39 <trigone> EvanR: sure, but it doesn't hurt checking if there's some special cases already resolved in one best way notoriously, akin to "design patterns" or whatever
20:18:06 <EvanR> probably reading some library code would be good to see that
20:23:13 <trigone> EvanR: it's a bit hard on average, exploded code in tons of modules, etc... not always easy to find a good map, and i have not found yet small but big enough libraries to explore...
20:25:57 <monochrom> Oh wow Cabal-2.0.0.2 is already on Hackage!
20:25:57 <monochrom> (But cabal-install on hackage is still at 1.24.*)
20:26:51 <Welkin> has anyone read Type Driven Development in Idris?
20:26:54 <Welkin> is it any good?
20:28:32 <monochrom> Does GHC 8.2.1 turn on -split-sections by default?
20:34:58 * hackagebot miso 0.4.0.0 – A tasty Haskell front-end framework – https://hackage.haskell.org/package/miso
20:35:20 * dmj` slurps
20:36:30 <dfeuer> @free F (b -> c) -> F (a -> b) -> F (a -> c)
20:36:30 <lambdabot> Try `free <ident>` or `free <ident> :: <type>`
20:36:43 <dfeuer> @free comp :: F (b -> c) -> F (a -> b) -> F (a -> c)
20:36:44 <lambdabot> (forall k. (forall p q. g . p = q . f                        =>                         k p = q)           =>            $map_F k x = y) => (forall f1. (forall f2 f3. f . f2 = f3 . h
20:36:44 <lambdabot>           =>                            f1 f2 = f3)            =>             $map_F f1 z = u) => (forall f5 f6. g . f5 = f6 . h               =>                f4 f5 = f6) => $map_F f4 (comp x z) =
20:36:44 <lambdabot> comp y u
20:37:25 <pacak> o_O
20:38:26 <MarcelineVQ>  why indeed
20:52:27 <d34df00d> ранные.
20:52:36 <d34df00d> Oh, sorry, wrong chat window. It was "hi"!
20:53:04 <d34df00d> So, as I understand, Data.Compact.compact evaluates the passed value. How deeply does it evaluate it?
20:55:50 <renzhi> "cabal build -j" does not seem to do build in multicore. I also tried "cabal build --ghc-options='j4'", but it does do multicore either. How do I build with multiple instances of ghc?
20:55:57 <monochrom> Oh, no, GHC does not turn on -split-sections by default.
20:56:32 <monochrom> cabal-install 1.24 has not gained --enable-split-sections like it already has --enable-split-objs
21:01:31 <jle`> anyone use travis for CI for haskell?  is there any way i can automatically trigger a rebuild when there's a new stack lts release?
21:06:53 <Axman6> d34df00d: as deeply as necessary for all pointers to also be pointing to the same Compact region
21:07:07 <Axman6> basically it does a fully copy of the data into the compact region
21:11:53 <d34df00d> Axman6: I seem to understand the Compactable constraint in Yang's paper. But how come (from types point of view) it's not present in the "production" API?
21:12:14 <d34df00d> Was it omitted for the sake of simplicity at the cost of some type safety, or am I missing something?
21:12:27 <Axman6> because basically everything except mutable references are copmpactable, so you'll get an exception if you try to add an IORef etc
21:12:33 <Axman6> yeah basically
21:12:41 <Axman6> afaiui anyway
21:12:50 <pacak> d34df00d: cyka blyat?
21:13:17 <d34df00d> pacak: almost.
21:13:28 <d34df00d> Axman6: thanks for clarifying!
22:10:44 <renzhi> intero keeps on crashing if you open a file in a project that does not use stack. Anyone knows how to get around this issue?
22:12:05 <pacak> Obvious solutions are use stack or don't use intero.
22:13:07 <glguy> renzhi: dante is an alternative to intero, it's a fork that supports more than just stack
22:13:31 <glguy> https://github.com/jyp/dante
22:13:33 <renzhi> glguy: hmm, I'll take a look
22:13:42 <renzhi> thx
22:14:06 <glguy> I use it sometimes via the develop branch of spacemacs
22:22:33 * hackagebot aeson-flowtyped 0.7.0 – Create Flow type definitions from Haskell data types. – https://hackage.haskell.org/package/aeson-flowtyped
22:26:17 <renzhi> glguy: hmm, I have the same issue with dante :)
22:26:51 <glguy> renzhi: That's good news, it means that the problem isn't with your emacs plugin, it's probably with your environment outside of dante
22:29:41 <renzhi> and go-to-definition just shows "Symbol's funtion definition is void: f-read"
22:35:25 <nikra> Hello!
22:48:44 <Lokathor> so when are we going to rewrite all of emacs in Haskell
22:49:31 <EvanR> sounds like something to do real fast on a lazy afternoon
22:50:02 <Lokathor> yeah it's probably like 500 lines of lens and Template
22:51:02 * hackagebot sensu-run 0.3.0 – A tool to send command execution results to Sensu – https://hackage.haskell.org/package/sensu-run
22:51:45 <Axman6> so I've been thinking about this, and there was a good talk at C++now on a data structure which I'm surprised we don't have in Haskell yet: https://www.youtube.com/watch?v=ZsryQp0UAC8
22:52:23 <Axman6> their results are really promising, basically you can build a text editor which handles editing gigabytes of data with very little effort, all thanks to immutability and persistence
22:53:33 <Axman6> Also Ryan Newton's talk at the same conference is why I started watching videos there: https://www.youtube.com/watch?v=lC5UWG5N8oY
22:54:04 <Lokathor> Axman6, I was mostly making a remacs joke
22:54:17 <Lokathor> but neat
22:55:05 <zwild> I write all my Haskell code in Emacs :)
22:55:41 <zwild> not Emacs in Haskell :(
22:56:36 <renzhi> One of these days, we need to have a real IDE
22:56:38 <Axman6> I reckon a similar structure with liberal use of ST where necessary would be fantastic. much like unordered-containers
22:59:03 <zwild> haskell-mode is great
23:04:26 <EvanR> every time i open a "real" IDE, and it attempts to type code after me, tripping me up...
23:04:41 <EvanR> i want to smash it
23:04:42 <mniip> tru dat
23:05:33 <pacak> Every time I open a "real" IDE that takes longer than vim to start...
23:06:00 <EvanR> youre never supposed to close any java app
23:06:07 <EvanR> or browser
23:06:08 <pacak> Hmm... I don't think I ever did it this millennia.
23:08:12 * hackagebot wolf 0.3.24 – Amazon Simple Workflow Service Wrapper. – https://hackage.haskell.org/package/wolf
23:08:12 * hackagebot bytestring 0.10.8.2 – Fast, compact, strict and lazy byte strings with a list interface – https://hackage.haskell.org/package/bytestring
23:08:22 <zwild> aeu;aoes staoe
23:08:29 <zwild> Sorry, quit vim.
23:10:00 <zwild> The first I try Emacs, I don't how to quit either.
23:11:47 <jle`> it'd be nice if there was a modifyM or something for StateT
23:12:34 <glguy> :t StateT
23:12:35 <lambdabot> (s -> m (a, s)) -> StateT s m a
23:13:48 <jle`> :t \f -> StateT (fmap ((),) . f)
23:13:50 <lambdabot> Functor m => (a -> m a) -> StateT a m ()
23:14:02 <jle`> that's basically what i've been having to do
23:14:37 <jle`> it doesn't really fit into MonadState so maybe that's why the StateT people are reluctant to add it
23:15:31 <jle`> not that that's actually important
23:18:38 <zoey> i'm making my way through learn you a haskell uwu
23:19:36 <jle`> :D
23:19:43 <zoey> pattern matching is so cool... now i really get the introductory chapter of Haskell Programming (book) which is all about lambda calc, especially the bit about mapping input to output
23:21:32 <jle`> did you read through that book first?
23:24:40 * hackagebot servant-pandoc 0.4.1.4 – Use Pandoc to render servant API documentation – https://hackage.haskell.org/package/servant-pandoc
23:33:38 <halogenandtoast> Could someone briefly explain to me what the Backpack module system is?
23:43:14 <Axman6> zoey: once you start using pattern matching, it becomes hard to use languages without sum types
23:46:25 <EvanR> speaking of containers... https://pbs.twimg.com/media/DFcgXzJXsAEQP6I.jpg (old pic... but with new math?)
23:46:45 <EvanR> box -> cat ?
