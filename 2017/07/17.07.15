00:25:18 <davr0s> would there be any sense in acessing arrays in haskell as 'funcallable objects' - i think clojure does this
00:25:44 <davr0s> e.g. an array of 't' behaves like a function  index->t
00:26:16 <davr0s> i guess you could always pass a function wrapping an array around instead
00:34:12 <cocreature> davr0s: you can’t update your array and keep the O(1) accesses if all you know is that it’s a function index -> t
00:34:16 <cocreature> you end up chaining ifs
00:34:40 <davr0s> sure mutable arrays are a different kettle of fish
00:34:56 <cocreature> if you have an immutable array then you can definitely do this
00:35:28 <cocreature> and it might even be a nicer API since the caller could also choose to use a map or something else instead of an array
00:35:32 <davr0s> i suppose such a wrapper could just inline out
00:36:11 <davr0s> e.g. if you go passing your array t  around as index->t ... the compiler can figure out to just inline that,  .. or perhaps the lazy-eval would make it harder 
00:36:59 <davr0s> thats maybe why I ask if there's any demand for 'intrinsic support'   .. data-types that 'can behave like index->t' 
00:38:08 <cocreature> the compiler should be able to optimize that just fine in most cases
00:38:19 <davr0s> it certainly seems sensible to write code that 'knows it's a random access object, but it desnt' matter what specifically..'
00:38:25 <EvanR> that time i thought i would just make a custom Read instance
00:38:33 <davr0s> array, map, deque, whatever
00:38:57 <EvanR> davr0s: random access against what key type?
00:39:13 <davr0s> integer index -> value
00:39:19 <EvanR> integer
00:39:48 <EvanR> that doesnt really make sense very often
00:39:53 <davr0s> tangentially i like the idea of semantically wrapping indices aswell ('vertex index', etc)
00:40:03 <EvanR> but you can export a view like that, i.e. Integer -> A
00:40:16 <cocreature> I guess there is little reason to not use an array if it’s immutable
00:40:36 <EvanR> an array cant span all of Integer
00:40:57 <cocreature> right but if your code is written such that it also works for an array, it won’t use all of them anyway
00:41:02 <davr0s> my thinking for performance oriented code woudl be to stick with flat arrays, and some sort of double buffering going on for 'update'
00:41:10 <EvanR> if its assuming an array, then...
00:41:27 <davr0s> i suppose you could have ways to batch up 'updates' 
00:41:31 <EvanR> youre pretty much stuck
00:41:50 <davr0s> oh you're alluding to ranged integers
00:42:07 <EvanR> davr0s: the road youre going down has been tried... see diffarray
00:43:34 <davr0s> i see posts telling me 'diffarray is obsolete'
00:43:44 <EvanR> because it didnt work that wel
00:43:46 <davr0s> hence why you said 'has been tried'
00:44:07 <EvanR> like, Data.IntMap or HashMap Int is better
00:44:16 <davr0s> doesn't a mutable array go against the whole pure idea
00:44:25 <davr0s> and what about parallel algorithms
00:44:26 <EvanR> its pure mutable
00:44:43 <EvanR> you get an "updated copy" that isnt a full copy
00:45:15 <davr0s> oh ok, some sort of tiled approach i guess
00:46:14 <davr0s> for making something parallelizable.. many tasks mutating the same array sounds bad, thats why i would be thinking in terms of batching up.. some sort of pass that reads one version, and generates another
00:46:44 <davr0s> probably better to think more about specific scenarios though. (what are these arrays for?)
00:47:56 <davr0s> how do they implement those arrays under the hood, does it connect to FFI code, or
00:48:09 <davr0s> does it use a load of nested (_,_,_,_....)
00:48:27 <EvanR> which arrays
00:48:36 <davr0s> i can imagine somthing like a diff-array being stored as some sort of tree
00:48:49 <EvanR> its some kind of data structure
00:48:58 <EvanR> havent really looked into it since no one liked it
00:51:04 <davr0s> some sort of animated cellular automa, that might as well be double-buffered, read an immmutable array, generate another, every output could be done in parallel
00:51:20 <EvanR> do it on the GPU
00:51:39 <davr0s> so there the components would be an immutable array as input,   and a 'parallel map,generating immutable array'
00:52:03 <davr0s> here's me hoping we can write GPGPU code in haskell..
00:53:59 <davr0s> other cases- 'arrays of particles' - they dont strictly need to be arrays, i.e. they're not used in random acess, but they might generate arrays in intermediate steps e.g. gridding to find interactions
00:54:45 <davr0s> that could still be done pure (and would have value for parallelism) e.g. 'count the number of particles in each grid cell' -> 'allocate space per grid cell -> populate the grid cells'
01:00:46 <EvanR> davr0s: temporary arrays exist, in ST
01:00:59 <EvanR> or i might have missed the part where you dont literally use arrays
01:01:06 <EvanR> or dont want to
01:05:57 <mniip> hmm
01:06:03 <mniip> :t \f x -> f (f x)
01:06:04 <lambdabot> (t -> t) -> t -> t
01:22:14 <dibblego> @hoogle f a -> ReaderT f a
01:22:14 <lambdabot> Control.Monad.Representable.Reader ReaderT :: f (m b) -> ReaderT f m b
01:22:14 <lambdabot> Control.Monad.Representable.Reader getReaderT :: ReaderT f m b -> f (m b)
01:22:14 <lambdabot> Control.Monad.Reader ReaderT :: (r -> m a) -> ReaderT k r
01:23:51 <dibblego> @type ReaderT . const
01:23:52 <lambdabot> forall k r (a :: k) (m :: k -> *). m a -> ReaderT r m a
01:25:36 <mniip> sounds like lift
01:26:07 <dibblego> yeah it is, cheers
01:32:10 <EvanR> i tried my hand at generating a random tree of data
01:32:22 <EvanR> it usually never terminates!
01:32:46 <EvanR> its branching a random number between 0 and 6 times
01:33:21 <EvanR> what is the chance it terminates
01:35:49 <mniip> EvanR, http://www.wolframalpha.com/input/?i=p%3D(1%2Bp%2Bp%5E2%2Bp%5E3%2Bp%5E4%2Bp%5E5%2Bp%5E6)%2F7
01:38:01 <mniip> EvanR, try nerfing the chances of big branches significantly
01:38:36 <mniip> perhaps exponentially with depth
01:39:04 <EvanR> im using IO random, maybe it would help to make it lazy IO
01:39:37 <mniip> nah
01:39:48 <mniip> you're not approaching this mathematically enough
01:40:04 <vaibhavsagar> Hi #haskell, I'm trying to build IHaskell with Nix, and it works except that modules defined inline don't load because of this error: "cannot find object file ‘./A/B.dyn_o’ while linking an interpreted expression"
01:40:21 <vaibhavsagar> building IHaskell with stack works fine
01:40:40 <EvanR> well its still waiting until its done to return the tree, even if you make it behave saner, itll still be too strict
01:41:18 <vaibhavsagar> no *.dyn_o files are produced in either IHaskell-Nix or IHaskell-Stack
01:41:19 <EvanR> and if its lazy, no need for sanity!
01:41:54 <vaibhavsagar> can anyone help me figure out what I need to change to get inline module definitions to work?
01:43:20 <mniip> EvanR, on average your tree will contain -1/14 nodes
01:43:37 <EvanR> mmkay seems workable
01:47:58 <EvanR> is that a rational number or an exotic thing greater than infinity
01:48:59 <mniip> the latter
01:49:13 <mniip> it means the probability diverges in positive numbers
01:50:01 <mniip> :t (/)
01:50:02 <lambdabot> Fractional a => a -> a -> a
01:50:15 <arbus> If you use stack, should you still add version bounds to your cabal file?
01:51:17 <MarcelineVQ> if you intend other people to ever build it that's a good idea
01:53:46 <arbus> MarcelineVQ What should I specify the bounds as? Pin it as the exact version in the lts that I use or allow for some flexibility?
01:55:16 <MarcelineVQ> If it's an executable I'd pin to what you're using since you know those work, establishing version bounds for a lib though I'm not really sure
01:58:47 <arbus> MarcelineVQ Its an executable, so I'll pin it exactly, thanks for the help!
02:00:45 <mniip> hmm
02:01:03 <mniip> is MonadPlus recoverable from 'void :: m Void' and 'bool :: m Bool'?
02:01:49 <mniip> mzero = fmap absurd; mplus x y = do b <- bool; if b then x else y
02:02:49 <mniip> can the laws be restated simply though
02:03:05 <mniip> iirc MonadPlus and Alternative are monoid families?
02:10:50 <mniip> hmm, did I just make a nonassociative >>=
02:10:54 <mniip> my monad doesn't behave as expected
02:14:59 <mniip> now that's better
02:57:14 <joel135> My book states about functors that "In fact, for any parameterized type in Haskell, there is at most one function fmap that satisfies the required laws." In think this is untrue; isn't there always a trivial alternative "fmap g = id"?
02:58:20 <lfairy> joel135: consider the case where the input has a different type to the output
02:58:34 <joel135> Oh now I see why that won't work.
02:59:33 <dasvi> Trying to install haskellR in windows ... - any chances someone tried that task before?
03:00:10 <joel135> It is a funny fact.
03:09:40 <jle`> joel135: parametricity is full of surprises :)
03:10:11 <jle`> things like these become one of your best friends
03:10:55 <joel135> Does it have something to do with the common uniqueness claims in algebra/category theoty, or is it more of a language limitation/logic thing?
03:11:17 <joel135> theory*
03:12:24 <joel135> Maybe my question makes sense. -- that's a type if "my question makes sense" is a type :p
03:24:07 <dibblego> @type \f -> foldr ((<|>) . f) empty
03:24:08 <lambdabot> (Alternative f, Foldable t) => (a1 -> f a) -> t a1 -> f a
03:27:16 <phadej> dibblego: lens could blow you mind on that
03:27:19 <phadej> :t alaf Alt foldMap
03:27:20 <lambdabot> forall k1 (t :: * -> *) (b :: k1) (g :: k1 -> *) a. (Monoid (Alt g b), Foldable t) => (a -> g b) -> t a -> g b
03:30:35 <phadej> Monoid (Alt ... isn't reduced because of not yet reduced kinds
03:45:01 <bollu> how do I generate documentation of my app / library without it trying to generate docs for everything?
03:45:11 <bollu> I'm using stack, if that helps
03:57:20 <cocreature> stack haddock --no-haddock-deps
03:59:01 <bollu> thanks, much obliged :)
03:59:22 <cocreature> protip: --help is actually helpful :)
03:59:36 <bollu> xD 
03:59:41 <bollu> IRC is faster 
03:59:43 <bollu> :)
04:00:00 <cocreature> then something is seriously wrong with the speed of --help on your computer
04:17:16 <mniip> EvanR, huh
04:17:36 <mniip> I reduced your trees until they were always finite (6 -> 2)
04:17:50 <mniip> curiously they're always finite (p=1) yet average size is infintie
04:24:27 <EvanR> mniip: seems to work with 2
04:27:57 <mniip> EvanR, again, you could have larger trees
04:28:14 <mniip> but you need to ensure that after a finite number of nodes the average child count was below 1
04:28:54 <ertes> protip:  command --help | grep -i the_thing_i_am_about_to_type_a_much_longer_question_about_and_wait_for_an_answer_for_on_IRC
04:31:04 <bollu> hm, how do I set a "stack path" variable?
04:32:21 <ertes> :t \f -> asum . fmap f
04:32:23 <lambdabot> (Functor t, Alternative f, Foldable t) => (a1 -> f a) -> t a1 -> f a
04:32:27 <ertes> dibblego: ^
04:36:27 <dibblego> ertes: yeah, I had asum, cheers
06:30:12 <kgarg26> _flow_
06:35:35 <vuto> test
07:12:10 <mniip> ertes, you forgot 2>&1
07:12:20 <mniip> most commands dump usage tostderr
07:26:01 <butterthebuddha> What should I be doing right now if I want to master Haskell, say, in a year?
07:26:04 <butterthebuddha> I feel absolutely inadequate
07:27:38 <CardMaster> Hey, I am working on a small exercise that I was given and I am not sure, if I am approaching something false. I have to define a card deck in haskell, part of the exercise is to define the type suit and have it derive the Typclass "Enum". I tried it like this but it won't work, any help would be appreciated. data Suit = Club | Heart | Spade | Diam
07:27:38 <CardMaster> ond deriving Enum
07:28:15 <vaibhavsagar> butterthebuddha: what if it took longer than a year?
07:28:24 <pavonia> CardMaster: What doesn't work?
07:28:49 <butterthebuddha> vaibhavsagar: let's remove the (arbitrary) time limit
07:29:17 <vaibhavsagar> butterthebuddha: write a program in Haskell
07:29:23 <CardMaster> pavonia I try [Club .. Diamond] in the ghci which should return the list of all 4suits I think, but that won't work for me.
07:29:32 <CardMaster> *to enter
07:29:51 <vaibhavsagar> I'd recommend rewriting something you've already written in another language
07:30:02 <pavonia> CardMaster: Could you be more specific, please? Doesn't work can mean anything
07:30:46 <vaibhavsagar> feel free to ask for help
07:30:51 <CardMaster> pavonia sorry, it says variable not in scope (...) :: Suit -> Suit -> t, it won't return me anything, no result
07:31:37 <vaibhavsagar> then either write something new or refactor the old thing to be more idiomatic
07:31:47 <pavonia> CardMaster: You probably used three dots instead of two in the list
07:33:11 <butterthebuddha> I guess I was hoping for something more specific than "write a program"
07:33:13 <CardMaster> pavonia I used 2 dots in the list, just tried again
07:33:43 <butterthebuddha> What kinds of programs would exercise the skills that are often used in Haskell the most?
07:34:14 <pavonia> > [1 .. 5]
07:34:16 <lambdabot>  [1,2,3,4,5]
07:34:18 <pavonia> > [1 ... 5]
07:34:20 <lambdabot>  error:
07:34:20 <lambdabot>      • Could not deduce (Num (Over p f c0 c0 a b))
07:34:20 <lambdabot>          (maybe you haven't applied a function to enough arguments?)
07:34:51 <vaibhavsagar> butterthebuddha: rewrite something you've written before in Haskell is pretty specific advice IMO
07:34:55 <pavonia> CardMaster: If it tells you about (...) no being in scope, you seems to have used that somewhere
07:35:20 <mniip> :t (...)
07:35:21 <lambdabot> (Plated c, Applicative f) => LensLike f s t c c -> Over p f c c a b -> Over p f s t a b
07:35:26 <mniip> dammit lens
07:37:07 <vaibhavsagar> I've been Haskelling seriously for about a year and a half
07:37:20 <mniip> huh
07:37:21 <vaibhavsagar> and for me it was about learning to think functionally
07:37:33 <mniip> CardMaster, any particular reason you list suits in that order?
07:37:37 <mniip> I suppose it's cultural
07:37:48 <mniip> but for me the natural order is hearts, diamonds, clubs, spades
07:38:30 <geekosaur> depends on which games you're most familar with. my default order is, descending: spades hearts clubs diamonds
07:38:48 <CardMaster> pavonia you are right, might have typed it wrong. When I enter [Club .. Diamond] though now, I still get a error. It says No instance for (Show Suit) arising freom a use of 'print', do I have to derive Show aswell?
07:39:02 <CardMaster> and i just used the order given in the exercise
07:39:05 <geekosaur> if you want to see the result, yes
07:39:14 <mniip> I only remember one game where suits are ordered explicitly
07:39:23 <mniip> and that one isn't super popular
07:39:30 <mniip> not even in my locality
07:40:06 <pavonia> CardMaster: Yes
07:40:41 <mniip> oh!
07:40:55 <Clint> explicit ordering is common in trick games
07:41:10 <mniip> preference
07:41:24 <mniip> was super popular here a few decades ago and it orders suits in that order
07:42:00 <Clint> eastern europe?
07:42:18 <CardMaster> oh my bad, thank you. How do I derive typeclasses? Line break and same spacing?
07:42:32 <geekosaur> data ... deriving (Show, Read, ...)
07:42:51 <mniip> Clint, yes
07:42:57 <geekosaur> 'deriving' can go on a separate line if needed; should probably indent it
07:43:26 <CardMaster> ok thanks, and another question. I guess it won't make a difference but to be sure, does  the order make a difference? Like is  deriving (Show, Enum) different from deriving (Enum, Show)?
07:43:52 <mniip> unicode for some reason likes SHDC
07:43:59 <mniip> and CP437 likes HDCS
07:48:12 <geekosaur> CardMaster, the order doesn't make a difference
07:51:12 <CardMaster> thanks
07:55:11 <mniip> it affects the order they appear in Core but haskell has the property of not needing the declarations to be in any specific order
07:59:34 <ongy> so could this influence the compile speed if I need significantly more of one than the other?
07:59:58 <geekosaur> huh?
08:00:54 <ongy> I guess that would only work if lookup of instances is done in a linear fashion depending on the order of things in core
08:03:45 <geekosaur> afaik they're not looked up at all, instance methods become references to maps deterministically named from the instance and that lookup happens at runtime (must do so, at least in the case of polymorphic recursion; if this can't hapen, the optimizer might be able to optimize that lookup away but then it'd be using a Map or Hash<something> not linear lookup)
08:11:00 <CardMaster> Okay, uhm I hope it's okay to ask again, because I am just not totally sure how I should do this. Now I also have defined data Value (ranging from Two to Ace) and type Card = (Suit, Value). Now I have to implement a way to compare the cards, where the suit doesn't matter except if it is heart, which trump the other 3 suits
08:12:19 <CardMaster> Not I would use instance Eq => Card where,....but after that I am unsure how to proceed
08:13:17 <monochrom> I wouldn't put it inside instance Eq.
08:13:32 <monochrom> I would call name the function "heartyCompare".
08:13:46 <monochrom> s/call/just/
08:13:57 <monochrom> As for implementation technique, use pattern matching.
08:14:27 <CardMaster> okay I'll give it a try, thank you
08:47:32 <ReinH> deriving Ord on Value may help
09:07:53 <mniip> is there a formal name for a forall-exists-forall-exists-... telescope?
09:08:52 <monochrom> If you don't specify the number and which one is the first, just "alternating quantifiers"
09:09:20 <monochrom> If you start to care about the number and which one is the first...
09:09:54 <monochrom> Then you also have to specify what's in the body.
09:10:34 <monochrom> Suppose the body is computable. Then look up "arithmetic hierarchy".
09:11:00 <monochrom> OTOH if the body is not only computable, but also actually computable in polynomial time, look up "polynomial hierarchy".
09:11:18 <monochrom> Those are the two major kinds of bodies people care about.
09:12:20 <monochrom> But I suppose you can get inspiration from this. If the body is drawn from a family of predicates called FFF, then you say "the FFF hierarchy".
09:12:57 <Tuplanolla> You could call this forall--exists a "guessing game".
09:13:14 <monochrom> Yeah, it's totally a two-person game too.
09:13:58 <mniip> monochrom, yeah I'm familiar with polynomial hierarchy
09:14:08 <mniip> not exactly the context this came up in
09:15:41 <Cale> I'm not sure the body is required to be computable usually for the arithmetical hierarchy... it's just that because it contains no unbounded quantifiers it will be.
09:26:13 <trigone> hi, i was wondering, is there a way to make a generic function `safe` which would replace ($) (in an applicative-like fashion) and would catch any error thrown by partial functions, outputting a Maybe-like value you could pattern-match over? i know exceptions cannot be caught outside IO, but is it not a safe case to use unsafePerformIO or something?
09:29:19 <trigone> (edo tell me if i'm not very clear btw)
09:29:25 <trigone> s/^e//
09:29:35 <Cale> trigone: Well, it's not exactly "safe" because it spoils referential transparency to catch exceptions in that way. But it can be done, there's a library called 'spoon' which does this.
09:29:41 <geekosaur> how does that interact with laziness?
09:29:51 <Cale> http://hackage.haskell.org/package/spoon
09:30:03 <geekosaur> (answer: either it strictifies or it fails to work)
09:30:06 <Welkin> edo?
09:30:09 <trigone> Cale: i'm not sure to get the referential transparency issue here...
09:30:11 <Cale> Well, spoon requires an NFData instance.
09:30:14 <trigone> Welkin: i meant "do"
09:30:14 <Welkin> tokyo?
09:30:53 <trigone> geekosaur: no idea, are you asking me rhetorically in a didactical fashion?
09:31:11 <geekosaur> I gave you the answer...
09:31:23 <trigone> geekosaur: oh right didn't see that
09:32:13 <trigone> geekosaur: you're right, indeed... unless it bundles lazily the value into a functor that could potentially be evaluated later, but then we're just not far away from IO anymore, are we?
09:32:24 <Cale> trigone: Well, you can distinguish different terms whose value would be _|_
09:32:40 <trigone> Cale: really, you can pattern match over bottom?
09:32:56 <trigone> oh you mean you *can't*?
09:32:56 <Cale> trigone: Well, exceptions are considered _|_ as well
09:33:14 <Cale> So, this lets you take *some* of those, and turn them into stuff you can pattern match on
09:33:26 <Cale> and tell them apart
09:33:38 <trigone> Cale: some of those what?
09:33:47 <Cale> Some terms whose value is _|_
09:34:30 <trigone> sorry you lost me... all you're saying now, what is it answering to exactly?
09:34:59 <Cale> Well, this gets to why it spoils referential transparency.
09:36:07 <trigone> sorry i don't really get what you meant to convey... but at least i know it's impossible/unsafe inherently...
09:36:42 <trigone> or, you have to bundle stuff and you end up with an IO monad rebuilt from unsafePerformIO or something
09:36:52 <trigone> i mean another IO monad
09:37:03 <Cale> It's not *as* unsafe as unsafePerformIO, for instance.
09:37:13 <trigone> Cale: what is not?
09:37:17 <Cale> spoon
09:37:27 <trigone> and how does spoon work?
09:37:35 <Cale> http://hackage.haskell.org/package/spoon-0.3.1/docs/src/Control-Spoon.html
09:37:48 <Cale> It uses unsafePerformIO and deepseq
09:38:43 <Cale> But even if it doesn't produce arbitrary effects or destroy typechecking, it spoils the usual way of thinking about the meaning of terms
09:39:14 <Cale> where we usually regard any term whose evaluation to WHNF doesn't terminate normally as having _|_ as its value.
09:39:16 <trigone> Cale: i see... but aren't exceptions themselves kind of an error? or not?
09:39:36 <trigone> WHNF=?
09:39:43 <Cale> weak head-normal form
09:39:47 <trigone> Cale: so there is a logical place for bottom?
09:40:01 <trigone> and by extension errors?
09:40:04 <Cale> A term is in weak head-normal form if either it is a data constructor applied to some arguments, or it is a lambda
09:40:06 <trigone> i mean exceptions
09:40:29 <trigone> Cale: ok... by contrast with what? like, what is a strong head-normal form?
09:40:34 <Cale> Normally for example,  undefined  and  error "Foo!"  are considered to have the same "value"
09:40:55 <trigone> Cale: yes, and?
09:41:05 <Cale> A term is in head-normal form if either it is a data constructor applied to some arguments, or it is a lambda whose body is in head normal form.
09:42:09 <trigone> Cale: are you trying to say that, because there should always only be one bottom encountered in a program (and it should halt at that point), to try to replace bottoms by Nothings is breaking the system's rules so to speak?
09:42:35 <geekosaur> the problem as I see it is you can never replace all bottoms
09:42:44 <Cale> Right
09:42:56 <trigone> Cale: you said right to whom?
09:43:01 <hpc> Cale: would a correct alternate formulation for lambdas be that (f _|_) > _|_?
09:43:04 <Cale> You can never really take *all* the terms which evaluate to _|_ and treat them the same way with this
09:43:25 <Cale> To geekosaur, but also you
09:43:58 <hpc> hmm, on second thought they are different, but HNF does imply that
09:43:59 <trigone> Cale: you mean, sometimes you'll use spoon and at some others you won't, and the double standard is making things unpredictable?
09:44:00 <Cale> Let's just consider the type ()
09:44:03 <geekosaur> trigone, it is possible to construct an infinite loop. very simple ones will be expressed as exceptions ("<<loop>>"); more complex ones cannot be detected
09:44:04 <Cale> which has only two values
09:44:06 <Cale> _|_ and ()
09:44:14 <Cale> If you wanted to map those to False and True
09:44:21 <Cale> then you'd need to solve the halting problem
09:45:10 <Cale> But using spoon, you can map *some* of the terms whose value is _|_ to False and () to True, but some of the terms whose value is _|_ will still be sent to _|_ (especially those whose evaluation doesn't throw an exception, but takes forever)
09:46:04 <osa1> Haskell 2010 says errors are indistinguishable from non-termination, but I can do things like `undefined `catch` (\(e :: SomeException) -> return ())` in GHC
09:46:28 <osa1> I'm wondering if this is still Haskell 2010 compliant
09:46:34 <Cale> osa1: They're only indistinguishable from the context of evaluation.
09:46:56 <Cale> The execution of IO actions can (perhaps unfortunately) tell them apart.
09:47:09 <osa1> hmm are there any words about this in Haskell 2010?
09:47:24 <Cale> I don't know for sure.
09:47:27 <geekosaur> I think exception handling is not part of the standard
09:47:33 <osa1> oh
09:47:43 <osa1> no actually there's a chapter: https://www.haskell.org/onlinereport/haskell2010/haskellch7.html#x14-1480007.3
09:48:12 <osa1> it doesn't mention undefined or error though.
09:48:31 <trigone> Cale: i think i understand: it's because before execution, you cannot solve the halting problem, so the evaluation alone cannot perfectly (especially purely) replace all bottoms, because some of them are in the shape of infinite loops, right?
09:49:07 <Cale> yeah
09:49:08 <geekosaur> ah, right, the standard only specifies the old style exceptions
09:49:30 <Cale> osa1: Are you sure they're not in the Prelude?
09:49:33 <trigone> Cale: yeah to me? you should specify the target for one-word sentences :P
09:49:55 <Cale> undefined        :: a  
09:49:55 <Cale> undefined        =  error "Prelude.undefined"
09:49:58 <Cale> error            :: String -> a  
09:49:58 <Cale> error            =  primError
09:50:09 <Cale> trigone: to you, yes
09:50:12 <trigone> is there any other type of bottom beyond infinite loops that would not be caught by spoon?
09:50:32 <Cale> trigone: spoon only specifically catches certain exceptions
09:50:40 <osa1> Cale: I meant the exception handling chapter, it doesn't mention undefined or error.
09:50:48 <Cale> there's spoonWithHandles which lets you specify others
09:50:57 <Welkin> spoon?
09:51:07 <geekosaur> @hackage spoon
09:51:07 <lambdabot> http://hackage.haskell.org/package/spoon
09:51:29 <trigone> Cale: so it does not replace, say, all partial pattern-matching with Maybes?
09:51:48 <trigone> you know, the head, (!!) and so on
09:52:00 <geekosaur> trigone, currently ghc does not provide a way to handle heap overflow bottoms (Control.Exception reserves an exception type for it, but the runtime never throws it)
09:52:25 <trigone> geekosaur: so ... what does happen when that happens?
09:53:43 <geekosaur> trigone, the main reason ghc does not try to deal with it is that usually the OS kernel handles it by sending SIGKILL to the process, which cannot be trapped
09:54:24 <geekosaur> (or Windows equvialent; there is iirc an out of memory handler but it is not allowed to allocate and therefore can't do much)
09:55:19 <mniip> you could reserve a block for the OOM handler
09:55:27 <geekosaur> in short, there are bottoms that can never be detected or caught. (also consider: hardware failures, power failure with no UPS)
09:55:42 <trigone> geekosaur: what i'm wondering is, how much of all this is not a moot point? to try to catch exceptions comes from the idea of deciding whether a bottom should really be a bottom (aka the program halts), or if it's seen as a mistake, and you'd like to avoid halting the program, and do something about it instead. in this situation, is it that bad to merely partially catch some bottoms but not all of them?
09:55:48 <Cale> I'm not sure I'd consider hardware/power failure to be _|_
09:56:05 <Cale> _|_ is a mathematical concept, it's part of the mathematical semantics of the language
09:56:14 <Cale> It's not a physical thing
09:56:31 <geekosaur> mniip, I was just thinking about perl 5's hacky version of that: you feed it a predefined string which is allocated in writable storage and will be used as emergency memory in that case
09:56:47 <geekosaur> how much memory you have depends on how long that string is
09:56:49 <trigone> i think you all mistake my idea of a safe polymorphic function as an attempt to forbid all halting in the program. but in truth, it's only to prevent those haltings that don't really make sense
09:57:25 <mniip> geekosaur, oops my stack jumped over a page boundary
09:57:26 <Cale> trigone: Usually the better thing to do is just to fix the program which is throwing exceptions from evaluation.
09:58:03 <Cale> trigone: This stuff exists as a kind of last resort, but I would sooner fetch the source code of a library I was using and just fix it than to attempt this.
09:58:28 <trigone> Cale: you mean, in short, in a practical example, replace head by safeHead or perhaps manually check the parameter?
09:58:36 <Cale> Yeah
09:58:44 <mniip> using head is often a bad sign
09:58:54 <Cale> Using !! is even worse
09:59:17 <Cale> (as even when it works, there's a good chance it's slow)
10:00:12 <Cale> btw, if you're almost, but not entirely sure that using 'head' is fine, consider using (\(x:_) -> x) instead
10:00:32 <trigone> Cale: but then, you must understand that my only desire here was to polymorphise all this plethora of safeThing that are both verbose and not extensible. i never wanted to control the halting of the program, i merely wanted a `safe` way to apply a potentially or actually partial function to an argument without having to inline the job of testing if the function would throw a bottom or not
10:00:33 <Cale> The reason being that when it actually does go wrong, it'll give you a much better error message
10:01:05 <trigone> Cale: really? is that not how head is defined itself?
10:01:06 <Cale> trigone: I don't typically need safeHead either.
10:01:27 <Cale> It is how head is defined, but by defining it in place, the pattern match failure throws an exception which includes a source location.
10:01:32 <Welkin> you shouldn't need head or safeHEad, because you don't need to use head when you can pattern match
10:01:37 <Cale> > head []
10:01:39 <lambdabot>  *Exception: Prelude.head: empty list
10:01:50 <Cale> ^^ this tells us nothing about where the failure occurred
10:01:57 <Cale> > (\(x:_) -> x) []
10:01:59 <lambdabot>  *Exception: <interactive>:3:2-12: Non-exhaustive patterns in lambda
10:02:05 <Cale> ^^ line number!
10:02:55 <Cale> But really, just use case more
10:03:02 <Cale> and handle all the cases explicitly
10:03:03 <trigone> Cale: so you always know whether a list is empty or not? mind you all this would be solved with some dependent typing. in a way it's the problem of checking the type of a parameter that loosely-typed language have to contend with...
10:03:23 <geekosaur> you can know
10:03:27 <geekosaur> use pattern matching
10:03:31 <Cale> Not *all* of it would be solved that way
10:03:56 <geekosaur> > case "" of [] -> "empty"; _ -> "nonempty"
10:03:58 <lambdabot>  "empty"
10:03:59 <Cale> Even in a dependently typed setting, it's possible not to know statically whether a list is empty or not.
10:04:51 <Cale> trigone: Mostly people just avoid things like head altogether, though it has its place in certain idioms.
10:05:01 <Cale> > map head . group . sort $ "mississippi"
10:05:03 <lambdabot>  "imps"
10:05:09 <trigone> Cale: as regards dependent types: really, how so?
10:05:33 <Cale> trigone: Well, for example, you still might have a list which originates from user input.
10:05:36 <c_wraith> trigone: you can require a proof that a list is non-empty to call a function, but such proofs can't always be derived statically.
10:05:39 <trigone> :t group
10:05:41 <lambdabot> Eq a => [a] -> [[a]]
10:05:48 <Welkin> > map (take 1) . group . sort $ "mississippi"
10:05:50 <lambdabot>  ["i","m","p","s"]
10:06:11 <Welkin> > concat . map (take 1) . group . sort $ "mississippi"
10:06:13 <lambdabot>  "imps"
10:06:14 <Welkin> :D
10:06:40 <Welkin> > concat . map (take 1) . group . sort $ ""
10:06:40 <c_wraith> you didn't use use concatMap? :P
10:06:42 <lambdabot>  ""
10:06:44 <Cale> It's always safe to apply head to the elements of the list produced by group because they're never empty. This is an example of something which could be handled (even in Haskell), by a more precise, but less convenient type.
10:07:14 <trigone> c_wraith: is this about what they say of dependently types systems, that they're undecidable or osmeting?
10:07:14 <Welkin> c_wraith: never
10:07:24 <Cale> We could have group :: [a] -> [Nonempty a]
10:07:38 <Cale> But that's obnoxious in a lot of ways
10:07:44 <Welkin> I never think to use it. and it reminds me too much of "flatMap" which is the stupidest name for `bind` anyone has come up with
10:07:51 <trigone> Cale: yeah i can imagine
10:08:43 <Cale> Welkin: I don't think it's that bad of a name
10:09:02 <Cale> concat and flatten are common names for the same thing
10:09:29 <ertes> mniip: i rarely need it, and i always write my own programs such that they print --help to stdout, if explicitly requested (whereas when the result of an error i print it to stderr instead)
10:09:39 <c_wraith> I've got it!  joinMap!
10:09:46 <Welkin> I hate it anyway
10:09:49 <Welkin> it makes me cringe
10:09:51 <ertes> mniip: i consider the help text to be the actual result of the command when --help is given
10:10:30 <Welkin> it's all ocaml's fault, right?
10:10:32 <Welkin> or scala
10:10:33 <Guest11032> Hey guys, I'm trying to create a function that returns all directories in a folder ([FilePath]), and was thinking of doing filterM (not doesFileExist) directories, but doesFileExist returns an IO Bool, so how would I do that? doesFileExist returns false if it is a folder :D 
10:10:34 <Welkin> something like that
10:10:35 <nshepperd_> Only monsters hate foldMap though
10:10:43 <geekosaur> arguable but then you run into having to either specify it twice (once for --help, once for invalid usage) or pass the fd/handle to whatever does the print
10:11:04 <geekosaur> which I have done in the past but it confuses most people >.>
10:11:32 <trigone> :t filterM
10:11:34 <lambdabot> Applicative m => (a -> m Bool) -> [a] -> m [a]
10:11:50 <trigone> geekosaur: it seems to be compatible
10:11:57 <Cale> Guest11032: filterM (\p -> fmap not (doesFileExist p))
10:12:11 <Guest11032> cool, thanks :D 
10:12:20 <geekosaur> trigone, (1) you wanted Guest11032 (2) the 'not' has to be fmap-ed
10:12:24 <Cale> Guest11032: However, I think there's also a more suitable function.
10:12:37 <Welkin> it's annoying when a program outputs the same information on incorrect usage as when using a --help flag, but it doesn't actually tell you how to use it
10:12:38 <Guest11032>   filterM (fmap not . doesFileExist) directories 
10:12:51 <Cale> doesDirectoryExist :: FilePath -> IO Bool
10:12:52 <Welkin> it just shows you a seemingly random string of characters after the program name
10:13:07 <Welkin> without any information about what they do
10:13:11 <Guest11032> ooh missed that function haha
10:13:39 <Welkin> how do programs install man pages?
10:13:48 <kadoban> Welkin: Those *are* typically enough information to tell why what you tried is invalid though, so it's semihelpful.
10:13:54 <Welkin> or rather, how do you include man pages in your program to be installed when the program is installed?
10:15:37 <glguy> Welkin: I don't know the answer, but I know that when I build cabal-install, it generates a man page. You might check out what it's doing
10:17:25 <trigone> geekosaur: yeah you're right i did not check much
10:18:46 <monochrom> glguy: I don't think I find how it happens. In cabal-install.cabal there is not even mention of source files for man pages. And there is no makefile.
10:19:05 <geekosaur> Setup.hs?
10:19:08 <cocreature> yep
10:19:16 <monochrom> Ah, let me see
10:19:28 <cocreature> there is some post install hook iirc
10:20:00 <geekosaur> Welkin, yeh, I also don't limit help output in either case to a traditional Unix 'usage: foo [-abhlux]'
10:20:24 <glguy> Yes, the Setup.hs has a buildManpage and installManpage
10:20:30 <geekosaur> although I don't usually go as far as some lwall programs which output their full manpage when invoked incorrectly :)
10:20:50 <ertes> Guest11032: note that there are non-files other than directories
10:21:11 <glguy> Apparently running "cabal manpage" causes cabal to print out its own manpage
10:21:13 <ertes> i'm not sure whether doesFileExist considers those "files"
10:21:17 <monochrom> Oh haha what? "cabal manpage" outputs a man page?!
10:21:34 <monochrom> This is so surreal.
10:21:41 <cocreature> huh, til
10:21:48 <osa1> wow
10:22:14 <ertes> cabal-install has a man-page?  i'm so used to haskell programs not having a man-page
10:22:18 <monochrom> Is there anything cabal-install doesn't do? XD
10:22:32 <hpc> uninstall ;)
10:22:45 <ertes> monochrom: update
10:23:27 <geekosaur> ertes, per documentation it only produces False for directories
10:23:31 <cocreature> cabal new-build can sort of update :)
10:23:59 <geekosaur> (which is interesting since the C API equivalent only returns TRUE for S_IFREG)
10:24:19 <geekosaur> (but then, that's a compatibility issue posix<->windows, so.)
10:24:35 <nshepperd_> It can't save us from ourselves
10:24:55 <monochrom> I output the manpage of those who don't output their manpages.
10:25:34 <monochrom> (Inspired by nshepperd_'s "can't save ourselves")
10:25:50 <ertes> does `cabal fix` output cabal-install's source code?
10:26:20 <monochrom> The Firefighter of Seville: He saves those who don't save themselves.
10:26:53 <monochrom> haha ertes
10:27:00 <monochrom> But no, not even "cabal quine".
10:27:30 <geekosaur> arguably 'cabal fix' should invoke itself on its own source, trying to find the least fixpoint...
10:28:25 <ertes> > fix cabal
10:28:28 <lambdabot>  "Building: Building: Building: Building: Building: Building: Building: Build...
10:28:42 <monochrom> Haha great
10:29:13 <monochrom> Although I think "cabal install cabal-install" plays the role of "cabal fix" already
10:32:34 <ertes> > fix cabal-install
10:32:36 <lambdabot>  Nix
10:35:17 <monochrom> Haha
10:36:41 <Welkin> that's a lie
10:36:48 <Welkin> nix is often much more broken
10:37:00 <Welkin> when it works, it's great though
10:44:12 <nshepperd_> > fix nix
10:44:14 <lambdabot>  curl $URL | sh
10:45:23 <hpc> you forgot --insecure
10:48:11 <Welkin> > fix windows
10:48:13 <lambdabot>  error: Variable not in scope: windows :: a -> a
10:48:19 <Welkin> lol
10:48:48 <srhb> In stark contrast to Nix, Windows cannot even produce an identity function, that's how impure it is.
10:48:49 <srhb> :-)
10:51:01 <rydgel> What's your preferred parser combinators library?
10:51:15 <johnw> I use parsec, like trifecta, probably should be using megaparsec
10:51:41 <johnw> or use the parsers library and abstract your parsers, although the types can be a bit more confusing
10:52:18 <f-a> is there any extension (or way) that deals with 3 arguments infix operators?
10:52:24 <cocreature> no
10:52:57 <glguy> > let (a ? b) c = sum [a,b,c] in (10 ? 20) 30 -- this is about it
10:52:59 <lambdabot>  60
10:53:17 <glguy> > let (a ? b) c = sum [a,b,c] in 10 ? 20 $ 30
10:53:19 <lambdabot>  60
10:53:47 <f-a> yeah glguy, I wondered if I could find a way to remove parentheses from (p ##$ 2) 2
10:54:20 <glguy> yeah, using the $
10:54:58 <f-a> that's what I guessed. Well, 2 characters more won't be that bad, thanks
10:55:04 <kadoban> I somehow didn't know that   (a ? b) c   would even work there. I wonder why that looks wrong
10:56:14 <Welkin> the ternary operator is a mistake
10:56:33 <Welkin> I've seen too much buggy and/or incomprehensible code written that way
10:58:13 <c_wraith> it also is totally unnecessary if you make if an expression
11:01:53 <nshepperd_> I always use excessive parentheses with it because i don't remember what the precedence is
11:06:30 <johnw> (((((((1 + 2)))))))
11:06:55 <kadoban> Hah
11:10:12 <monochrom> https://mail.haskell.org/pipermail/haskell-cafe/2017-July/127537.html :)
11:11:39 <Welkin> that's one way to detect that someone is brand new to haskell: they use way too many parentheses even when it doesn't make sense
11:11:58 <Welkin> and no spaces
11:12:01 <monochrom> And for people new to math...
11:12:04 <hpc> (defun fmap ((f x)) (...))
11:12:42 <Welkin> hpc: wrong language
11:12:45 <monochrom> <Q> Hi I need help with 1+2/3  <A> Could you add parentheses to disambiguate?  <Q> Yes! (1)+(2)/(3)
11:13:12 <kadoban> monochrom: lol
11:13:51 <ongy> now it looks like lisp
11:14:30 <monochrom> Actually it was not as bad as that. It was more like 5*1+2/3 and the parenthesizing was (5*1)+2/3.
11:15:03 <monochrom> But anyway beginners know exactly what is right, they just then add a not-gate in front.
11:15:23 <f-a> I always forget ^ fixity
11:15:43 <Welkin> I findi t hard to forget
11:15:50 <Welkin> * and / always comes before + and -
11:16:02 <Welkin> in reduction
11:19:06 <ongy> just do the reverse polish notation (+) ((*) 5 1) ((/) 2 3)
11:19:46 <ongy> oh, that one's the normal, not reverse.
11:19:46 <Welkin> why is it polish?
11:19:56 <f-a> polish mathematician devised it
11:20:00 <Welkin> yeah, RPN is stack-based
11:23:25 <Welkin> you know what else is polish?
11:23:27 <Welkin> The Witcher
11:34:05 <Cale> Welkin: I guess Łukasiewicz Notation wasn't catchy enough.
11:34:24 <f-a> it was for lispers ;_;
11:34:32 <monochrom> Could not be typed on an American typewriter back then. :)
11:34:55 <monochrom> Also how do you even pronounce it? :)
11:35:08 <kadoban> Badly
11:36:45 <johnw> you just say, "It's spelled Łukasiewicz, but pronounced 'Bob'"
11:38:07 <srhb> Wukasievits.
11:38:16 <srhb> (Sorry to any Poles)
11:38:39 <srhb> More like tjs at the 
11:43:48 <Cardmaster> How can I compare a data type which itself consists of 2 data types using instance Eq or Instance Ord?
11:44:24 <Cardmaster> Of those two data types one would take priority in the comparions, if that makes sense
11:44:43 <slack1256> yep, you have to define the instance yourself probably
11:44:53 <slack1256> to force that "the first one" takes priority
11:45:46 <wz1000> Cardmaster: GHCs derived ord instance would probably do what you expect.
11:46:46 <wz1000> if you have data X = I Int | S String deriving (Eq, Ord), then I _ > S _
11:46:49 <monochrom> Cardmaster: Could you show the actual code for your type?
11:47:26 <monochrom> Without it, we can only give Bayesian-probabilistic answers because we're all blind guessing.
11:47:56 <Cardmaster> Sure whats the best way to paste it?
11:48:04 <monochrom> E.g., with probability 1/8, "deriving Ord" already works.
11:48:06 <wz1000> sorry, I mean S _ > I _
11:48:09 <geekosaur> gist.github.com or lpaste.net
11:48:51 <slack1256> when using lazy patterns, does ghc generate accessors in place to pass around the data?
11:48:51 <Tuplanolla> > I undefined < S undefined
11:48:53 <lambdabot>  True
11:48:59 <slack1256> (I don't know if that is the correct terminology)
11:49:03 <yellowj> how to run 'stack new name' if directory 'name' already exists?
11:49:18 <unknownln> Rename the directory
11:49:39 <mniip> slack1256, somewhat
11:49:54 <unknownln> stack wants a nonexistent directory so it doesn't accidentally overwrite anything I believe
11:50:05 <Cardmaster> http://lpaste.net/356955 Here, the instance Eq and Ord part are just from me trying things out, basically I have to compare cards. But the suit doesn't matter, except if it is Heart that is greater than the other 3, but the other 3 are all on the same "level". http://lpaste.net/356955
11:50:25 <Cardmaster> *Heart is always greater than the other suits, thats what I mean
11:50:38 <monochrom> slack1256: Could you show an example? Actually does it look like "case l of ~(x:xs) -> f x"?
11:51:37 <kadoban> Cardmaster: Just to warn you, that doesn't sound like quite a sane Ord instance
11:51:55 <mniip> slack1256, they are rewritten in core
11:52:17 <monochrom> The Eq could be derived. You don't have to write this code.
11:52:23 <kadoban> You might want to just skip Ord, or at least not use it for this, and give a different function name for this operation.
11:52:23 <Cardmaster> What I have written or using Ord in general for that purpose? 
11:52:38 <mniip> '\~(C x y) -> f x y' is rewritten into '\r -> f (case r of C x _ -> x) (case r of C _ y -> y)
11:52:40 <mniip> '
11:52:42 <monochrom> You're abusing Ord. Ord is not for this.
11:52:50 <kadoban> Using Ord in general for this purpose. The issue is that there will be a bunch of Cards where they compare EQ, but they're not (==)
11:53:12 <Cardmaster> It is part of an exercise though and it states I should implement an instance Eq and Ord for that purpose
11:53:15 <kadoban> I don't really know what will happen when you for example try to make a Data.Set of Cards, probably nothing good.
11:53:23 <erisco> ah yeah, don't do that, that's a no-no
11:53:29 <monochrom> Although, you can always play the "no one is using this code except me" card. (Pun!)
11:53:40 <slack1256> mniip: Cool, it just pass the pattern matching down the line
11:54:09 <mniip> well, it also adds a _ -> error "irrefutable pattern match failed" branch to those cases
11:54:20 <erisco> if you want different equalities then use different types
11:54:36 <mniip> homotopy on cards!
11:54:52 <kadoban> Cardmaster: Well, then I guess you don't have much choice. But just remember that this is a bit of a crap idea in principle.
11:55:02 <Cardmaster> I understand that lol
11:55:02 <monochrom> 99% of the time you don't even get Eq or Ord involved. Just make up your own function names and use them.
11:55:45 <monochrom> Who the hell is that teacher? The community needs to excommunicate them.
11:55:54 <Cardmaster> I'm open to try a better method if it is that bad
11:56:07 <erisco> we need to get them on here to persuade them, actually
11:56:10 <mniip> last time I implemented playing cards in haskell (yesterday) I just put the constructors in an order s.t. deriving Ord did the correct thing
11:56:17 <monochrom> Expose excommunicate extinguish
11:56:25 <kadoban> Cardmaster: But okay, so you're asking how to achieve this I guess? The easiest way would be to do explicit pattern matching, where you do the cases where either (or both) things are Hearts first, and then do the others
11:56:31 <mniip> monochrom, ext4
11:56:49 <kadoban> Well, the most conceptually clear to me anyway, not sure that's actually "easiest" by every measure.
11:56:56 <erisco> Cardmaster, have you done OOP? it is like having x == y not imply they have the same hash code
11:57:25 <erisco> this is just a basic assumption made so other code can work
11:57:37 <monochrom> Yeah even Java's standard class hierarchy has taste.
11:57:50 <Cardmaster> so pattern matching for (Card Heart _) (Card _ _); (Card _ _ ) (Card Heart _) and (Card Heart _) (Card Heart _) ?
11:58:06 <mniip> are you implementing Ord for trump cards?
11:58:27 <monochrom> Hrm. Trump. Fake Ord. :)
11:58:34 <Welkin> oh no, someone said trump
11:58:36 <Cardmaster> I haven't had OOP yet lol, only functional programming. 
11:58:36 <kadoban> Cardmaster: Yes, giving explicit answers for those. But you'd want the last of those first, otherwise it won't go very well (Card Heart _) (Card _ _) would match two Hearts too
11:58:47 <mniip> Control.Comonad.Covfefe
11:58:50 <Welkin> Cardmaster: yet? Avoid oop if you can
11:59:07 <Welkin> it's a blemish in the history of programming
11:59:28 <Cardmaster> So start with the 2 hearts, and then the other possibilities right?
11:59:37 <Cardmaster> in the pattern matching
11:59:46 <mniip> compare (Card s1 r1) (Card s2 r2) = compare (s1 == Hearts) (s2 == Hearts) <> compare r1 r2
11:59:47 <mniip> \o/
12:00:01 <monochrom> I think OOP is OK. But it should be taught as a niche in the 4th year, not as a universality in the 1st year.
12:00:14 <kadoban> Cardmaster: Yep
12:00:25 <mniip> monochrom, here they teach C first year, then basics of assembly, then OOP
12:00:33 <mniip> I'm not sure which is better tbh
12:00:42 <monochrom> Whereas FP is actually close enough to universality. (But the Pascal kind of imperative is also OK.)
12:00:56 <Welkin> mniip: so that you can have manager for your factories that use dependency injection?
12:01:04 <erisco> newtype CardValue = CardValue Card;  and then define your Eq for CardValue, whereas Eq for Card is structural
12:01:23 <monochrom> The engineering-minded tends to start with C and asm, yeah.
12:01:25 <erisco> so you have two concepts. one is the card itself, like the piece of printed paper, and the second is its value in the game
12:02:08 <Welkin> I took computer engineering. It was all assembly and C (and hardware description languages). No oop to found found anywhere in sight, except for a brief lesson during  scripting/python/bash course.
12:02:40 <erisco> the ace of spades is definitely a different card than the ace of clubs but in your game they have the same value (I am guessing)
12:02:48 <mniip> o
12:02:53 <mniip> erisco, did you get my paste yesterday
12:02:55 <Cardmaster> mniip does that work? it says variable not in scope (<>) It's meant to mean mappend right?
12:02:58 <monochrom> It is tenable to say "we're CE not CS, we will get low-level, so let's start with C which is easier given the final goal, but you will find that even C doesn't let you touch the carry flag, so after C you will do asm"
12:03:11 <Cardmaster> erisco exactly
12:03:15 <mniip> Cardmaster, I'm not sure about old GHC but nowadays <> is synonym for mappend
12:03:20 <Welkin> Cardmaster: ⊕
12:03:21 <Welkin> :D
12:03:24 <Welkin> use that instead
12:03:28 <erisco> mniip, for the SK translator?
12:03:29 <monochrom> Of course today Rust is probably better for that.
12:03:30 <kadoban> erisco: Hmm. Isn't it better to just not call the function "compare" (and <, >, etc.). I guess that'd work as long as you make the Eq instance match though.
12:03:33 <mniip> no, for poker hands
12:03:35 <mniip> erisco, http://lpaste.net/356956
12:03:44 <erisco> oh right, yes I did get that one
12:03:50 <Welkin> is there a way to make these unicode operators work?
12:03:56 <mniip> I was worried it expired before you saw it
12:04:08 <Welkin> in place of <>
12:04:11 <mniip> @let x ⊕ y = x ⊕ y
12:04:11 <Welkin> for example
12:04:12 <kadoban> Welkin: Don't they work already, as long as they're in the right category?
12:04:12 <lambdabot>  .L.hs:168:11: error:
12:04:12 <lambdabot>      Ambiguous occurrence ‘⊕’
12:04:12 <lambdabot>      It could refer to either ‘Debug.SimpleReflect.⊕’,
12:04:16 <mniip> wot
12:04:29 <monochrom> haha
12:04:31 <Welkin> hm
12:04:41 <slack1256> how do you access the docs? do you have an open web browser with hackage loaded?
12:04:52 <mniip> yes
12:04:57 <slack1256> is there any ide with a good story of auto-completion and docs by the side?
12:05:02 <monochrom> I have an open web browser but I don't open hackage.
12:05:02 <Cardmaster> compare (Card s1 r1) (Card s2 r2) = compare (s1 == Heart) (s2 == Heart)  compare mappend r1 r2 so shall I write it like that?
12:05:05 <Welkin> > (λ a b -> a + b) 1 2
12:05:08 <lambdabot>  error:
12:05:08 <lambdabot>      Pattern syntax in expression context: λ a b -> a + b
12:05:16 <slack1256> monochrom: local copy of hackage docs?
12:05:17 <Welkin> nope
12:05:26 <monochrom> I am a real programmer who build local docs at install time.
12:05:29 <Cardmaster> and sorry if I don't reply to everyone or do something wrong it's kinda hard ot keep up with somanymessages lol
12:05:36 <mniip> Cardmaster, I wasn't really serious
12:05:41 <erisco> kadoban, you can, but then you do not have the correct Eq and Ord for whatever wants it ... insert some comment about ML modules here
12:05:41 <mniip> don't write that if you don't understand how it works
12:05:55 <slack1256> well, I consider that the same thing. Maybe is just has less latency
12:05:59 <monochrom> Only xmonad end-users forgot to tell cabal to build docs.
12:06:13 <Cardmaster> oh lol
12:06:14 <kadoban> Hm, ya.
12:06:32 <glguy> I build local docs like monochrom, I just don't use them for anything other than generating documentation to upload to hackage :)
12:06:34 <mniip> I suppose I do too
12:06:35 <Welkin> I recall some people using λ in place of \
12:06:41 <mniip> but I never use them either
12:06:58 <Welkin> or is that a compiler extension?
12:07:04 <monochrom> No. Even pragmatically, there are reasons why you should build local docs and trust them instead. One, version mismatch. Two, hackage docs are sometimes missing.
12:07:08 <kadoban> Welkin: I think they just make their editor show it like that. Or maybe there's a compiler extension too.
12:07:21 <slack1256> I always end up with 15+ tabs open with duplicated info. I wanted to know if there is a better way
12:07:25 <glguy> monochrom: This way if they're missing I know to upload them :-p
12:07:29 <Welkin> there is a unicode syntax setting in haskell-mode
12:07:34 <Welkin> it converts as you type
12:07:37 <Cale> Cardmaster: If (<>) isn't in scope, import Data.Monoid
12:07:50 <erisco> Cardmaster, so that is just to show there are many ways to have an equality relation and you should not be afraid of treating each way with equal regard
12:08:25 <monochrom> I don't eliminate the 15 tabs. I manage them.
12:08:27 <mniip> 01[U] dev-lang/ghc 02,01Installed versions:01  07,017.10.2-r101(0/7.10.2)(01:01:19 PM 01/31/2016)(doc gmp 07,01-binary01 07,01-ghcbootstrap01 07,01-ghcmakebinary01 ELIBC="glibc")
12:08:41 <monochrom> If firefox, use the "tree style tab" add-on.
12:08:42 <erisco> wish I had a dark theme for my client...
12:08:56 <kadoban> mniip: xD What have you done
12:09:10 <slack1256> monochrom: just what I was thinking about
12:09:11 <mniip> I think I broke my irc colors script
12:09:54 <monochrom> If chrome, use the "tab outliner" extension.
12:10:24 <monochrom> If IE or Edge, switch to firefox or chrome already.
12:10:43 <monochrom> (I won't dare to offend the safari users!)
12:10:52 <erisco> people who never close their tabs drive me nuts
12:11:09 <monochrom> Why? It is their browsers, not yours. :)
12:11:18 <monochrom> It's also their screens, you don't have to look. :)
12:11:21 <Cardmaster> I did it the pattern matching way now
12:11:42 <monochrom> You're like saying you're nuts just because I never close my drawers in my bedroom :)
12:11:46 <erisco> I don't mind when I don't see, but sometimes they're setting up a presentation
12:11:55 <monochrom> Oh heh
12:12:10 <kadoban> monochrom: That does actually sound a bit nuts xD
12:12:11 <monochrom> Just don't look. Stare at the person, not at the display :)
12:12:20 <wz1000> slack1256: for docs, I've been working on haskell-ide-engine. we are ready for an alpha release. https://github.com/wz1000/haskell-ide-engine
12:12:34 <monochrom> Don't worry I actually close my drawers all the time. I was just being hypothetical.
12:12:34 <erisco> I just want to go up and start middle clicking them... like popping bubble wrap
12:12:39 <wz1000> Look at the third gif. Does it do what you want?
12:12:41 <kadoban> Oh okay
12:13:24 <monochrom> 70% of the time looking at the speaker is more informative than looking at the slide.
12:13:47 <erisco> I have a huge list of bookmarks that I haven't organised though, so that is how I manage the junk
12:14:04 <monochrom> Watch the body language, and listen to what the voice actually says.
12:14:15 <monochrom> The slides are often fillers.
12:14:16 <erisco> they expect you to organise them in a directory hierarchy and that just doesn't make sense... the tagging extensions also suck
12:14:49 <erisco> they're either too clumsy, too buggy, or are actually tied to this stupid web service that either advertises to you or wants you to give money to it
12:15:05 <erisco> I'd do it once but not recurring
12:15:10 <Welkin> I hate slides
12:15:41 <monochrom> I disbelieve in tree hierarchy too. If anything you need a DAG. Consequently, I now go with tags.
12:15:43 <Welkin> I prefer either no visuals (just talking), or talking with a chalkboard/whiteboard for drawing visuals in real time
12:16:06 <mniip> kadoban, more specifically I ran eix in a xterm TERM while my script only handles basic escapes
12:16:14 <monochrom> So I don't actually use my browser's bookmarking. I use Google bookmarks and tag there.
12:16:35 <kadoban> mniip: Ahh
12:16:37 <mniip> [10U] 03dev-lang/03ghc      03Installed versions:  01,027.10.2-r104(0/7.10.2)06(01:01:19 PM 01/31/2016)(04doc 04gmp 02-binary 02-ghcbootstrap 02-ghcmakebinary ELIBC="04glibc")
12:16:39 <mniip> this is more sane
12:16:44 <kadoban> Wait, google has bookmarks?
12:16:51 <kadoban> Yeah, that's for more readable in my client
12:16:52 <monochrom> https://www.google.ca/bookmarks/
12:16:59 <erisco> I didn't know that either... they already know everything about me anyways
12:17:13 <monochrom> I guess change "ca" to whatever is right for your region?
12:17:17 <wz1000> monochrom: a tree is a DAG
12:17:39 <wz1000> I mean a directory tree
12:17:49 <kadoban> monochrom: Huh, good to know
12:17:52 <wz1000> with symlinks and all.
12:18:01 <mniip> monochrom, just use google.com/ncr
12:18:18 <glguy> mniip: Is that about what you intended that to look like? https://glguy.net/mniipcolor.png
12:18:37 <glguy> (just sanity checking on my end)
12:18:39 <mniip> yes
12:18:48 <monochrom> What does that ncr do?
12:18:57 <Cardmaster> Hey, sorry if I repeat myself. I  did it that pattern matching way now, given the task this should be the way asked for right? Or could I have done that part better? http://lpaste.net/356957
12:19:11 <mniip> monochrom, no country recognition
12:19:37 <monochrom> neat
12:19:42 <erisco> monochrom, so they want you to go to a web page and fill out a form to bookmark stuff? eh...
12:19:45 <kadoban> Cardmaster: lines 13 and 14, do you have to compare anything there on the right-hand-side, or do you already know the answer?
12:20:25 <codygman> Have you guys used Ammonite (http://ammonite.io/), we need a Haskell version. Maybe I could have something that monitors input of ghci, looks for imports, then does searching for them adds it to ghci, and resumes state to accomplish this: https://youtu.be/wk2-ZsQU358?t=481 
12:20:33 <monochrom> erisco: No, look near the bottom for "Drag this bookmarklet to the Bookmarks bar of your browser". I use that.
12:20:41 <Cardmaster> I already know the answer I suppose
12:20:51 <erisco> yeah, it brings up a pop-up, that is what I am referring to
12:20:58 <monochrom> It is a piece of "javascript:..."
12:21:17 <kadoban> Cardmaster: But other than that, that seems fine, given the requirements.
12:21:17 <monochrom> Then the form is mostly prefilled. You just have to specify tags.
12:21:23 <erisco> I know... first problem is I never use my bookmark bar... not sure that is worth it
12:21:26 <mniip> glguy, http://tcpst.net/31jk.png
12:21:33 <erisco> that's like, 20 pixels down the drain :P
12:21:40 <kadoban> Cardmaster: Same comment on lines 7 and 8 I guess
12:21:52 <Cardmaster> kodoban can I write equals GT LT? How would I write that as a result
12:22:39 <kadoban> For compare, GT or LT or EQ are just normal values you can use, yep. For (==), the result is a Bool, so True or False
12:22:39 <Cardmaster> ah I can! 
12:22:42 <glguy> mniip: thanks
12:22:49 <monochrom> It is worth it. Because in general you should have at least 4 things in your bookmark bar. They are important.
12:22:53 <kadoban> Well, they're "constructors" I guess, but whatever, they're values.
12:23:06 <monochrom> 1. for https://www.google.com/bookmarks/
12:23:10 <Cardmaster> Thank you, It didn't work when I tried some time ago, but maybe my  code was wrong or I did something wrong.
12:23:14 <mniip> glguy, funny how I've translated ansi escape codes into irc colors only to have them translated back at everyone's end  :p
12:23:16 <monochrom> 2. for the bookmarklet
12:23:26 <monochrom> 3. for your local Haskell library docs
12:24:44 <monochrom> 4. a link to a web page that shows current time. This is useful when you use a cafe's free wifi and they have this annoying "confirm you know our T&C" redictionion.
12:25:19 <Cardmaster> Another question I have. Why does show (Card Heart Two) not work? or with any other values
12:25:39 <Cardmaster> do I have to do deriving with data Card aswell?
12:25:44 <kadoban> Cardmaster: Doesn't appear that Card is an instance of Show. Yep
12:26:03 <kadoban> Or manually write a Show if you prefer of course.
12:26:50 * slack1256 is liking tree style tabs
12:26:52 <erisco> monochrom, just seeing if I can find an extension for it... merely to put a button up where the extension buttons are so I don't need the bookmarks bar
12:27:21 <Welkin> slack1256: you have too many tabs then...
12:27:43 <Welkin> I try to have no more than I can count on my fingers
12:27:45 <monochrom> There was a firefox add-on for google bookmarks. (written by 3rd party.) But it bitrotted. Also I no longer use firefox.
12:27:48 <Welkin> less than 10
12:28:08 <monochrom> I haven't looked for a Chrome extension, but yeah, it would be better.
12:28:15 <Welkin> it also makes it navigable using keyboard shortcuts
12:29:01 <erisco> if I knew anything about making chrome extensions it'd probably be really easy to do... literally just click and run the javascript
12:29:57 * geekosaur has 98 tabs open. believe it or not, most of them are reference tabs that get used at least once a day
12:30:19 <monochrom> How many of them are RFC's? :)
12:30:30 <geekosaur> although at the moment around 25 of them are waiting for me to classify and file them elsewhere
12:31:11 <geekosaur> none. ghc user manual is one of them, plus various other manuals
12:31:22 <geekosaur> some github repos where I reference code somewhat often
12:31:35 <monochrom> Ah.
12:31:36 <slack1256> Welkin: is not that amount (I also got less that 8). Is that docs from different packages are not in hiearchy. This addon fixes it
12:31:40 <ertes> regarding the question from earlier about ternary operators: there is often a way to get the desired notation by combining two binary operators
12:32:05 <Cardmaster> I definded the show function myself  so it just shows the suit and value, I am slowly understanding it better now. Thanks everbody
12:32:11 <slack1256> also, moving with C-PgDown C-PgUp only make sense with not many tabs
12:32:36 <Welkin> slack1256: I use Alt+number
12:33:08 <monochrom> AAAhhhh so you mean the number of keyboard numerals, not the number of fingers.
12:33:22 <Tuplanolla> I have learned to close tabs, but not PDF documents.
12:33:33 <monochrom> If F1-F10 would mean 11 to 20, you would allow 20 tabs.
12:33:58 <ertes> @let b --> x = if b then Just x else Nothing; mx ? y = maybe y id mx; infix 4 -->; infixr 3 ?
12:33:58 <Welkin> my new laptop doesn't have function keys
12:33:59 <Welkin> lol
12:33:59 <lambdabot>  Defined.
12:34:02 <monochrom> Indeed that's basically what Rise of Nations does. :)
12:34:27 <ertes> > even 3 --> "even" ? odd 3 --> "odd" ? "math is broken"
12:34:29 <lambdabot>  "odd"
12:34:52 <monochrom> What is that magic?
12:35:04 <monochrom> Oh wait you have code up there.
12:35:39 <ertes> monochrom: it was my late response to this: <f-a> is there any extension (or way) that deals with 3 arguments infix operators?
12:36:01 <monochrom> Neato
12:36:32 <ertes> you could have defined this (say, in agda) as a single mixfix operator _-->_?_
12:36:44 <ertes> but i think this version with two operators is a lot nicer
12:37:30 <ertes> and i think if you really can't do it with infix binary operators, you probably shouldn't do it at all =)
12:37:37 <Welkin> or use metaprogramming...
12:39:26 <nope__> what pervert invented this language
12:39:53 <monochrom> Which language?
12:40:03 <dolio> English.
12:40:04 <Welkin> nope__: java?
12:40:22 <slack1256> L-lewd!
12:40:26 <EvanR> clearly the english
12:40:27 <nope__> !
12:41:09 <Welkin> Anglais
12:41:21 <Vegitto> nope__: you mean haskell
12:41:23 <Vegitto> nope__: ?
12:41:30 <nope__> Im not sure anymore
12:41:42 <Vegitto> nope__: in that case, it was invented by a group of perverts (and some non-perverts, i assume)
12:42:04 <EvanR> haskell was designed by committee, a fact that never ceases to amaze
12:42:21 <Welkin> well, if you mean vikings and anglo-saxons, then yes
12:42:21 <dolio> I mean, it was basically invented by David Turner.
12:42:36 <dolio> The committee made a bunch of refinements.
12:42:42 <slack1256> it was also co-authored by mark zuckeberg
12:42:48 <EvanR> who the heck is this
12:42:53 <Welkin> english was invented through war and sex
12:42:58 <ertes> i think the first version of haskell dates back to somewhere around 1880
12:43:13 <EvanR> begriffsschrift?
12:43:22 <ertes> it really wanted to succeed being a consistent logic
12:43:24 <EvanR> probably too many double letters there
12:43:25 <ertes> but fails to this day
12:43:52 <nope__> thats when we rebooted right
12:44:07 <ertes> yeah, it was known as haskell '80 back then, alias begriffsschrift
12:44:17 <Welkin> ...?
12:45:00 <Vegitto> 88 - is haskell that old?
12:45:13 <EvanR> 1988 yeah
12:45:26 <Vegitto> whoa
12:45:42 <dolio> Miranda was '85, though, and that's almost Haskell.
12:46:35 <Welkin> and functional programming dates back over 100 years before that
12:47:12 <EvanR> 100 years before they didnt even have math straight
12:47:26 <slack1256> nah, I don't believe you. You will have to bend semantics to say that 100 years ago there was functional programming
12:47:30 <Vegitto> 100 years before programming
12:47:34 <kadoban> Welkin: Wait, what happened around/before 1888 that you're counting?
12:47:35 <dolio> Yeah, I don't know about 100.
12:47:51 <slack1256> also, not everybody is in the same page about what functional programming is
12:47:56 <kadoban> lambda calc was like 1940s, 1930s?
12:47:58 <Welkin> okay
12:48:02 <Welkin> maybe not over 100
12:48:07 <Welkin> at least back to lambda calculus
12:48:14 <Welkin> which was 1930s
12:48:22 <kadoban> Oh okay
12:48:25 <dolio> I think programming with lambda calculus is closer to 40s.
12:48:29 <mniip> yeah, church found a niche solution to russell's issues with set theory
12:48:29 <ertes> wasn't lambda calculus meant to be a logical framework initially?
12:48:42 <slack1256> it is
12:48:44 <ertes> yeah, exactly
12:48:45 <dolio> We went digging a couple weeks back and the really early lambda calculus stuff is more like logical notation.
12:48:51 <EvanR> frege's begriffsschrift from late 1870s was largely ignored, and was a syntax for logic
12:49:07 <ertes> but that raises the question: was STLC first, before untyped LC?
12:49:22 <EvanR> which bears a curious resemblance to much much later type theory logic
12:49:23 <dolio> No, the earliest stuff was untyped.
12:49:37 <dolio> Even though it was notation for logic.
12:49:48 <ertes> how do you do logic in untyped LC?
12:49:52 <dolio> At least, it seems to be. It's really hard to tell.
12:50:01 <mniip> was it hindley and milner who first typed lc?
12:50:11 <mniip> or maybe they proved a lot of stuff about it
12:50:14 <dolio> Nah, Church had typed lambda calculus.
12:50:15 <ertes> i believe church typed it
12:50:20 <mniip> aha
12:50:25 <mniip> but church could not infer types/
12:50:26 <mniip> ?
12:50:31 <EvanR> ertes: well, being syntax, you are concerned more that its grammatically correct than what the type of referents are
12:50:33 <slack1256> I don't think so, exactly, church did it because it had an analogous of russel paradox the untyped version
12:50:55 <ertes> mniip: IIRC church only provided the logical primitives through types…  basically he wrote down deduction rules
12:51:07 <monochrom> Church typed it. Then Church or Russell thought up "stratification" which you call today "Type_0, Type_1, Type_2 ..."
12:51:31 <ertes> was stratification before grothendieck universes?
12:51:32 <slack1256> hindley & milner broght this: given a proof, we can construct the theorem it represents (backwards of what we usually do, the theorem first (the type) then the proof (the term))
12:51:33 <mniip> yes but russells' numbers were each in their own sort
12:51:49 <EvanR> socrates was a man contains two kinds of pluggable things, a noun and a adjective phrase. you could replace socrates with any noun
12:52:14 <slack1256> ertes: probably, this stuff is older than gotherdieck by 25 years
12:52:30 <EvanR> later they found out nouns like "this sentence" dont work 
12:52:31 <ertes> ah
12:52:44 <dolio> ertes: https://docs.google.com/file/d/0B0CU-A1oqzzLd3VfWm1ja1E2WDQ/view
12:52:46 <EvanR> and it all went to hell
12:52:51 <mniip> "sentence is not a sentence"
12:52:53 <mniip> oboy
12:53:08 <ertes> so basically all grothendieck did was: "shit, type theory fixed it…  i have to save set theory!!!!"
12:53:20 <EvanR> all grothendieck did !
12:53:27 <erisco> monochrom, turned out to be really easy, done it
12:53:30 <mniip> hahaha
12:53:56 <EvanR> you need large cardinal to quantify over all grothendieck did
12:53:58 <mniip> man imagine if martin-lof was taught in schools
12:54:03 <Welkin> so now what's with homopoty-type theory?
12:54:15 <Welkin> is it the future yet again?
12:54:16 <monochrom> erisco: Neato.
12:54:26 <Welkin> homotopy-type theory*
12:54:36 <EvanR> homotopy space type space theory
12:54:47 <mniip> homotopy space!
12:54:59 <ertes> homotopy hype theory
12:55:07 <mniip> Welkin, well it's a HoT theory
12:55:26 <Tuplanolla> Why not just call it htt?
12:55:26 <EvanR> its ambiguous, type theory with homotopy types!
12:55:41 <slack1256> I am currently studying homotopy theory to classify topological spaces (for undergrad degree). I think I am doing a really long path to understand homotopy type theory lol
12:55:44 <mniip> Tuplanolla, HoTT sounds more hot
12:56:00 <ertes> Tuplanolla: because intel would sue you
12:56:09 <monochrom> "htt" is probably not a pronounciable acronym.
12:56:09 <Tuplanolla> With wrong kerning it looks like H composed with Pi, mniip.
12:56:24 <EvanR> HoPi
12:56:34 <mniip> slack1256, I know zilch about topology (I have some guesses but no formal education) yet I understand HoTT somewhat
12:56:39 <Welkin> the native americans will be in an uproar
12:56:51 <monochrom> You do know how people are irrationally obsessed with pronounciable acronyms, don't you? They don't even accept "ehch tee tee"
12:56:54 <mniip> in fact I learned some topology basis *through* CT and HoTT
12:56:58 <mniip> basics
12:57:19 <EvanR> it always comes back to topology
12:57:23 <Tuplanolla> Everything is pronounceable with enough effort, monochrom.
12:57:33 <monochrom> Yes.
12:57:38 <mniip> except my nick for some reason
12:57:39 <ertes> it's fine if it looks like HoΠ…  it's a dependent theory after all
12:57:49 <monochrom> But people even refuse to say "es queue ell"
12:57:55 <Welkin> how do category theory and type theory interact? Is one a subset of the other?
12:57:56 <erisco> monochrom, needs more work still though... has to be one button to make the bookmark like the regular button is
12:57:59 <monochrom> they have to say "sequel"
12:58:01 <ertes> monochrom: i say that all the time
12:58:02 <mniip> Welkin, no?
12:58:09 <ertes> monochrom: i refuse to say "sequel"
12:58:09 <dolio> monochrom: That's one extra syllable.
12:58:29 <dolio> 50% bigger.
12:58:34 <mniip> Welkin, why would you think that
12:58:36 <slack1256> Welkin: both can be used to be a foundation for mathematics. Type theory by design, CT by accident
12:58:48 <Welkin> how do they relate?
12:59:00 <mniip> slack1256, is there research on synthetic CT?
12:59:05 <mniip> I'm somewhat interested in that
12:59:08 <monochrom> erisco: I'm thinking if you could put it in the right-click popup menu instead.
12:59:09 <ertes> although i wouldn't say "hoe-tee-tee"
12:59:18 <mniip> couldn't find any prior work
12:59:20 <ertes> that sounds kinda awkward
12:59:21 <slack1256> Type theory can be cast as "set theory with set with some structure", usually some kind of product or sum being avaible from the start
12:59:41 <Welkin> ertes: at least use the intenrational phonetic alphabet like a civilized person!
12:59:45 <Welkin> international*
12:59:47 <slack1256> in usual set theory, "x belongs the some set S" is a fundamental operation (unless you are an structuralist)
12:59:53 <ertes> slack1256: hmm?  what do you mean?  i think types and sets are very different
13:00:06 <mniip> slack1256, in TT "x:A" is not a proposition
13:00:13 <mniip> unlike set theory
13:00:23 <mniip> that's very important
13:00:25 <ertes> slack1256: sets have a lot of notions that types don't have, like "subsets"
13:00:41 <erisco> A is
13:00:51 <mniip> ertes, well, a subset could be implemented in types
13:00:54 <slack1256> mniip: right, because in TT, a element only belongs to a single set. Set and objects go hand in hand in TT
13:00:57 <Welkin> I suppose it is more confusing because abstract algebra is described using set theory
13:01:01 <ertes> mniip: sure, but it's not a subset *of* types
13:01:06 <mniip> right
13:01:08 <ertes> it's a subset of sets encoded as types
13:01:27 <EvanR> Welkin: luckily, it doesnt have to be
13:01:42 <Welkin> well in saunder's mclane's "Algebra" it is
13:01:48 <Welkin> saunders*
13:01:55 <mniip> ertes, well, uh, in HoTT you have IsSet(A) implies IsSet(SubSet(A, P))
13:01:56 <EvanR> almost everything is
13:01:59 <mniip> for a suitable SubSet
13:02:07 <EvanR> luckily it doesnt have to be
13:02:09 <dolio> I don't think things are so cut and dry about sets vs. types.
13:02:21 <mniip> e.g SubSet(A, P) = A * (pi_(x:A) P(x))
13:02:27 <Tuplanolla> When you need to say SQL, you're can alternate between "ess-cue-ell", "sequel", "squeal", "ess-cull", "squabble", "squiggle", "skew-ell", "squirrel" and either "grotesquely" or "picturesquely", but for the last two you have to mutter the first syllables quietly, monochrom.
13:02:39 <mniip> mmmm
13:02:41 <EvanR> yes right now were trying to clearly define a difference but if you read, no one agrees
13:02:43 <slack1256> is basically what you consider fundamental operations on set theory vs type theory for your collections
13:02:44 <mniip> needs more propositional truncation
13:02:58 <ertes> mniip: hmm?  that sounds like something you can have in classical type theory, too
13:03:12 <dolio> I'm sure there are type theories that have sub types that are like sub sets, and there are set theories that don't look much like the ZF stuff people usually consider as 'set theory'.
13:03:15 <mniip> ertes, what's a set in classical type theory
13:03:28 <ertes> mniip: a predicate over a type
13:03:34 <mniip> uh
13:04:12 <ertes> mniip: in agda notation:  Pred n A = A -> Set n
13:04:13 <EvanR> before doing anything just clearly define the whole set theory or type theory youre about to use!
13:04:27 <mniip> ertes, well in HoTT is a set is a type such that ...
13:04:48 <EvanR> also called an h-set
13:04:49 <ertes> mniip: my experience with HoTT is very limited
13:05:04 <EvanR> sets defined within HoTT
13:05:07 <mniip> and it turns out that "is a set" is also a proposition
13:05:08 <ertes> i can probably come up with ways to encode sets as a higher inductive type
13:05:21 <EvanR> ertes: theres a whole chapter on that!
13:05:40 <mniip> uh
13:05:56 <dolio> You don't need higher inductive types. People model certain set theories in type theory already.
13:06:02 <mniip> IsSet(A) = Pi_{x,y:A} Pi_{p,q:x=y} p=q
13:06:12 <EvanR> unrelated to h-setness
13:06:14 <dolio> See stuff by Aczel, I think.
13:06:17 <mniip> here's your higher inductive type
13:06:18 <ertes> dolio: yes, i've done that, too, inspired by agda's Pred
13:06:33 <ertes> not sure whether it's a full set theory, but i think it is
13:06:34 <EvanR> thats not a HITT its just Pi and equality
13:06:44 <[exa]> seems like I should really finally read the hott book
13:06:49 <mniip> right
13:07:00 <mniip> could be defined in terms of 0-truncation
13:07:03 <mniip> which is a HITT
13:07:23 <EvanR> later in the book they develop a traditional looking set theory out of such things
13:07:24 <ertes> HITT?  higher inductive …?
13:07:33 <EvanR> i spelled it wrong now everyones doing it
13:07:39 <ertes> haha
13:07:48 <mniip> Higher Indductive Type Theory!
13:07:50 <EvanR> higher inductive Pi
13:07:51 <dolio> Only one T.
13:07:52 <erisco> a small group of people know exactly what you mean EvanR
13:08:03 <hpc> haha
13:08:06 <mniip> a small groupoid of people
13:08:22 <ertes> small groupoid?  you can't be a HoTT person
13:08:28 <mniip> a locally small groupoid
13:11:26 <EvanR> if type theory is the syntax then category theory could be the semantics
13:13:01 <mniip> they actually exist on the same ontological level
13:13:07 <mniip> with ZF as well
13:13:26 <EvanR> its syntax all the way down!
13:13:39 <mniip> what I'm wondering is
13:13:58 <mniip> has anyone yet come up with synthetic category theory
13:14:11 <mniip> which allows a recursively selfcontaining category of all categories
13:15:01 * EvanR looks up this post about such "autistic categories"
13:15:19 <EvanR> http://cs.nyu.edu/pipermail/fom/1999-May/003117.html
13:19:01 <mniip> I see a problem!
13:19:28 <mniip> pseudoautisticity is a judgement
13:19:44 <mniip> yet they construct a subcategory using pseudoautisticity as a predicate (proposition)
13:20:02 <mniip> in a TT framework this can be avoided
13:20:08 <Tuplanolla> I find it hard to tell conjecture from jest.
13:20:27 <mniip> take that steve from 1999
13:20:30 <EvanR> IsPseudoAutistic here, thinking from a type theory perspective, is just another predicate indexed by a category
13:21:04 <EvanR> you which need to provide some evidence to construct or refute for a particular category
13:21:29 <MarcelineVQ> often both at once
13:22:11 <mniip> I know the port of russell's paradox to CT
13:22:19 <EvanR> the hott book also constructs category theory out of hitt, and i can barely understand it
13:22:25 <EvanR> out of HOTT
13:23:06 <EvanR> actually i dont understand it
13:23:12 <mniip> hmm
13:23:26 <dolio> There is synthetic category theory.
13:23:41 <mniip> dolio, is there with a category of all categories though?
13:23:44 <dolio> Why would you expect it to allow a category of categories that contains itself without problems, though.
13:24:35 <mniip> idunno, I think the ability to construct a category of all categories the ultimate categorical problem
13:24:40 <mniip> is the
13:25:02 <EvanR> is this like the trisecting an angle with compass all over again?
13:25:45 <mniip> actually now that I think about it HoTT ideas seem cool
13:26:04 <EvanR> im reminded of the classic MUD implementation snafu where a user tries to "put bag in bag"
13:26:05 <mniip> defining an algebraic structure along with an "equality" groupoid
13:26:19 <EvanR> causing the universe to explode
13:26:33 <dolio> The most natural way to collect up 'all categories' is in a 2-category, anyway.
13:26:44 <mniip> does it matter?
13:26:44 <dolio> But even that doesn't get out out of self-reference issues.
13:27:11 <erisco> sounds like an item dup exploit
13:27:13 <mniip> I mean we could easily come up with (infty,0)-categories as long as we figure out 1-categories
13:27:20 <EvanR> these essays about the various problems self reference causes are great
13:28:22 <EvanR> and pretty much settles the issue with: any time your blank spot allows something from a collection, then "this" must be outside that collection. and so theres no way to have a universal collection
13:29:50 <Tuplanolla> Can we not have one if it's forbidden to talk about?
13:30:10 <EvanR> you cant have it
13:30:11 <EvanR> sorry
13:30:16 <EvanR> we can talk about it though
13:30:31 <EvanR> syntax vs semantics
13:30:44 <EvanR> meaning vs meaninglessness
13:30:46 <mniip> I'm thinking about disallowing "x in Ob(C)" as a fundamental proposition
13:31:21 <mniip> some Cs might define their own but you can't pick a C from CAT and talk about "x in Ob(C)"
13:31:38 <EvanR> well, then talking about the definition of a morphism is annoying....
13:31:39 <erisco> meh, meaning is overrated
13:32:13 <EvanR> or trying to construct it inside some setting
13:32:36 <mniip> EvanR, you get pi-quantification over objects though
13:32:39 <erisco> explaining one thing in terms of another is a game that has to stop somewhere
13:32:46 <dolio> You can have theories with collections of all collections, but they need to be restricted in some other way.
13:32:55 <mniip> dolio, obviously
13:32:59 <EvanR> mniip: is that not the same thing
13:33:08 <mniip> EvanR, = is not universal duh
13:33:24 <EvanR> i must have misunderstood
13:33:37 <EvanR> you began with the assumption that would be using set theory language to do stuff
13:34:01 <EvanR> and then Xd it
13:34:16 <EvanR> just dont begin with it :)
13:34:38 <EvanR> mniip: whats not universal is the idea that anything can be in any collection with anything else
13:35:24 <mniip> uh
13:35:26 <EvanR> like socrates and france and whatever are great ... what the heck are they doing in the same boat as "this sentence"
13:35:36 <mniip> not sure where you found that
13:35:43 <mniip> did the "in" throw you off?
13:35:57 <EvanR> im thrown off because i dont know where you got that fundamental proposition
13:36:05 <EvanR> assumed it was set theory
13:36:11 <mniip> I synthesized it
13:36:16 <EvanR> ah yeah
13:36:19 <dolio> mniip: Do you know about Girard's paradox in System U-?
13:36:19 <mniip> I hypothesized synthesizing it
13:36:28 <mniip> then said that synthesizing such a relationship is bad
13:36:50 <EvanR> dude get van heijenoorts giant book on logic messages "From Frege to Godel"
13:36:56 <mniip> Système U is a French retailers' cooperative, comprising about eight hundred independent hypermarkets and supermarkets
13:37:00 <EvanR> logic essays
13:37:14 <EvanR> they all make up shit like this :)
13:39:17 <mniip> dolio, oh I've seen that page before but wasn't interested enough to actually read that GR-typed term
13:39:50 <dolio> Well, the point is, it doesn't even have a 'type of all types'.
13:40:10 <dolio> It just allows quantification over kinds in types.
13:40:20 <dolio> And it's still inconsistent.
13:40:45 <EvanR> theres an interesting remark about the hierarchy of universes near the beginning of hott book, that the indexes "cant even be from the natural numbers"
13:41:45 <dolio> I'm not sure about that.
13:41:51 <monochrom> Tuplanolla: Haha "squiggle" wins
13:42:00 <mniip> EvanR, I suppose that's related to the total order of universes and that "succcessor" isn't really a single universe but it always exists
13:42:28 <dolio> Agda lets you define a hierarchy of universes indexed by the natural numbers in the lowest universe.
13:42:35 <EvanR> i know
13:42:52 <EvanR> agda has had problems though
13:43:02 <dolio> Well, induction-recursion does that.
13:43:08 <dolio> And there are set theoretic models.
13:43:24 <monochrom> Haha would be nice to have a "Chomsky's paradox in System U" to confuse the hell out of both computer scientists and economists.
13:43:46 <dolio> So unless the HoTT book has a new proof of the inconsistency of a certain large cardinal axiom....
13:44:26 <EvanR> note this is talking from within its specific system, not agda or coq
13:44:33 <EvanR> which are all separately developed systems
13:44:38 <EvanR> im getting the exact issue now
13:48:29 <EvanR> ok what it does is, just doesnt use literally N from inside the theory to talk about U
13:48:42 <dolio> Sure. That's pretty common.
13:49:00 <dolio> I think it's certainly harder to justify doing that.
13:49:19 <dolio> As in, prove that it's kosher, and provide some model.
13:50:40 <EvanR> so you have at least 2 kinds of natural numbers floating around if youre using these sorts of type theories as a foundation for something!
13:50:55 <EvanR> and one of them is meta undefined or something
13:51:00 <mniip> what if your type theory has no kinds!
13:51:06 <mniip> and what's 2
13:51:17 <EvanR> ok at least 3
13:51:19 <EvanR> uh oh
13:51:40 <dolio> EvanR: That's kind of a common problem, anyhow.
13:51:46 <mniip> synthetic theory of natural numbers!
13:51:56 <Tuplanolla> What if you didn't want natural numbers in your theory, EvanR? You'd still need them outside.
13:52:06 <mniip> that sounds terribly ad-hoc
13:52:15 <EvanR> why?
13:52:27 <dolio> Like, people will try to argue something by induction, but in actuality have only proved it by meta-induction.
13:53:13 <dolio> But there's not typically a formal rule that a meta-inductive argument justifies something about the internal natural numbers.
13:53:39 <EvanR> its like you want them to mix
13:53:47 <EvanR> but they cant be the same
13:54:27 <mniip> hm
13:54:32 <EvanR> how about an infinite array of natural number rules...
13:54:42 <EvanR> and so on
13:54:44 <mniip> there's still things left to research in TT/CT, right?
13:55:09 <EvanR> maybe this is why they invented transfinite induction
13:56:40 <dolio> EvanR: A meta-inductive rule would be pretty strong, probably.
13:57:01 <dolio> Kind of like how second-order arithmetic has only one model.
13:57:30 <EvanR> models
13:57:34 <mniip> EvanR, http://tcpst.net/zlic.jpg
13:57:50 <EvanR> gross
13:58:01 <thimoteus> i think transfinite induction was invented to deal with a problem in point-set topology
13:58:39 <Akii> lol
14:02:30 <mniip> I should start collecting these higher math memes
14:02:49 <mniip> so that I can make a meme dump where no one singlehandedly understands all the memes
14:22:39 <pikajude> is it possible to define a MonadBaseControl instance for ContT?
14:23:20 <c_wraith> I believe it's considered to be impossible
14:23:49 <pikajude> darn!
14:23:53 <hpc> does MonadBaseControl have laws?
14:24:04 <pikajude> fortunately, while waiting for an answer to that question, I realized that I can just use `lift`
14:46:45 <lyxia> hpc: they are written under the class methods
14:49:32 <mson> strings has type [IO String]. Why does for_ strings (fmap putStrLn) print nothing, and how do I make it print something? 
14:50:10 <hpc> :t for_
14:50:12 <lambdabot> (Applicative f, Foldable t) => t a -> (a -> f b) -> f ()
14:50:25 <hpc> @let strings' = undefined :: [IO String]
14:50:26 <lambdabot>  Defined.
14:50:31 <hpc> :t for_ strings (fmap putStrLn)
14:50:32 <lambdabot> error:
14:50:32 <lambdabot>     • Variable not in scope: strings :: [f String]
14:50:32 <lambdabot>     • Perhaps you meant one of these:
14:50:37 <hpc> :t for_ strings' (fmap putStrLn)
14:50:38 <lambdabot> IO ()
14:50:56 <hpc> oh
14:51:00 <hpc> :t for strings' (fmap putStrLn)
14:51:01 <lambdabot> IO [IO ()]
14:51:16 <pikajude> doesn't MonadBaseControl have a liftIO equivalent somewhere
14:51:19 <EvanR> strings is badly named
14:51:22 <hpc> you're not performing any of the putStrLns, just making a list of the actions you want it to do
14:51:27 <pikajude> i.e. for MonadBaseControl IO m you can write liftIO without *also* incurring a MonadIO constraint
14:51:32 <pikajude> i just don't remember what it is
14:51:33 <EvanR> its not a list of strings
14:51:42 <mson> EvanR: you're right.
14:51:43 <kadoban> :t for strings' (>>= putStrLn)
14:51:44 <lambdabot> IO [()]
14:52:20 <hpc> ^ that one will do it
14:52:55 <mson> kadoban's did it, thanks all
14:52:58 <EvanR> and now i see why haskell is hard
14:53:15 <kadoban> That is a bit of an unfortunate little case in IO
14:53:23 <EvanR> IO actions dont come with a simple ".execute" method
14:53:47 <EvanR> not that you want thme to
14:54:15 <EvanR> however i had the same issue with clojure
14:54:27 <EvanR> you have to trick the system into executing the IO effects
14:55:26 <EvanR> without the help of types
15:01:30 <f-a> is there a standars set of options I should put in cabal to get static binaries?
15:02:35 <slack1256> f-a: at least at haskell level, most libraries are statically linked
15:02:51 <slack1256> yet they still depend on the system libraries (glibc i think) dynamically
15:06:01 <f-a> slack1256: when shipping a simplebinary to a friend I got ../.cabal/(longpath)/share/hyph-en-gb.hyp.txt.gz: openBinaryFile: does not exist
15:06:06 <geekosaur> note that depending on glibc statically has lots of hidden bombs in it http://micro.nicholaswilson.me.uk/post/31855915892/rules-of-static-linking-libstdc-libc-libgcc
15:06:21 <geekosaur> that's not static linking
15:06:30 <geekosaur> that's a package with a data file
15:06:51 <geekosaur> you cannot magically make a program expecting an external data file somehow bundle that data file into the binary
15:06:57 <f-a> mhhh
15:07:10 <slack1256> as geekousar said
15:07:11 <f-a> well, the library is hyphenation
15:07:23 <geekosaur> exactly, and it's reading a database of hyphenations
15:07:28 <f-a> and indeed it's full of data
15:07:31 <geekosaur> which you must ship with it
15:07:35 <slack1256> you must include data-files: on cabal. At least
15:08:31 <f-a> https://github.com/ekmett/hyphenation/issues/3 I am not the first having this problem, apparently
15:21:57 <Guest20308> I'm learning haskell through practical application, I'm trying to write a function that generates the frequency of octave[x] of a specific note. f (x y) = if y <= 0: return x else: f(x*2, y -1). What's the nicest way to type this in haskell, what I have brings errors: octaves x y = putStrLn (show x) >> if y > 0 then return 0 else main (x * 2) y - 1
15:23:36 <Guest20308> join /programming
15:23:58 <geekosaur> why main instead of octaves?
15:24:03 <geekosaur> also you are missing parentheses
15:24:25 <geekosaur> hm, no, misread
15:24:34 <geekosaur> buyt you need 'return' in the else also
15:24:39 <geekosaur> 'return' is not flow control
15:25:26 <mniip> Guest20308, you forgot the , between (x, y)
15:25:37 <mniip> also you shouln't really use uncurried functions in haskell
15:26:01 <mniip> also : is not haskell syntax
15:26:19 <mniip> return is a specific function whose type you probably don't need used
15:26:32 <mniip> main?
15:28:57 <geekosaur> in fact, since the only reason you have IO in there is to debug x, I suggest using pure code and Debug.Trace.traceShowId
15:29:04 <geekosaur> (sigh, hotspot glitched)
15:29:46 <EvanR> mniip: like randomRIO :: (a,a) -> a
15:29:48 <geekosaur> mniip, I think they were pseudocoding in pseudoPython
15:30:00 <EvanR> er IO a
15:30:09 <EvanR> er whatever... the uncurriedness of that is annoying
15:30:17 <mniip> uh
15:30:21 <mniip> Ix-y functions have that
15:30:37 <mniip> a range might be better perceived if grouped
15:30:58 <EvanR> well then uncurried is great!
15:31:05 <geekosaur> in this case it's a range and whether it should be grouped or not probably depends on the use case. I'm inclined to treat the range as a composite, so a tuple would be apropos
15:31:25 <geekosaur> but I can certainly think of use cases where it's an extra hoop to jump through
15:31:35 <EvanR> yep
16:08:15 <mson`> There are a distressing number of regex packages listed at https://wiki.haskell.org/Regular_expressions and I'm new to the language. Which should I use?
16:08:54 <mson`> Oh, probably Text.Regex.
16:10:10 <slack1256> regexes on haskell need usually two pacakges. a regex-base package with the function you will use and a "back end" for how to implement them
16:10:12 <geekosaur> that's actually a wrapper API
16:10:23 <slack1256> is highly annoying, so people just use parsec
16:10:47 <geekosaur> so you want regex-base for Text.Regex and then you want a backend; different backends may be available on different platforms and may have different limitations
16:11:24 <mson`> I seeeee.
16:11:27 <geekosaur> (for example regex-posix isn't available on Windows and often doesn't speak UTF8, and regex-pcre may or may not support UTF8 depending on how your OS/distribution built its PCRE libs)
16:12:07 <geekosaur> also the Text.Regex APIm while capable, is a nightmare to decipher
16:12:18 <geekosaur> s/APIm/API,/
16:14:10 <mson`> That helps geekosaur, thanks.
16:32:23 <mson`> How do I read the type Array Int (Int,Int)? Seems like... more than one type, but I'm told a function returns it.
16:32:50 <dmwit> mson`: It is an array that uses Int as indices and has (Int, Int) pairs as elements.
16:33:19 <mson`> dmwit: Thanks!
16:36:50 <lyxia> We should replace Text.Regex with something like what Stephanie Weirich presented at POPL this January. https://www.youtube.com/watch?v=-mrkj_5OEv8&list=PL46QaMgfWUxyT6H3vYqhUt3YTOrP8c4x3
16:37:27 <dmwit> uh
16:37:32 <dmwit> That audio is unintelligible.
16:37:45 <dmwit> But you might like regex-applicative.
16:37:51 <lyxia> :(
16:38:54 <mniip> doesn't feel like there's an audio at all
16:40:22 <lyxia> isn't regex-applicative "just" a parser combinator thing
16:40:32 <dmwit> yes
16:40:51 <dmwit> But with the performance characteristics of regexen (so linear time).
16:41:14 <lyxia> ah!
16:55:14 <dmj`> Gurkenglas:  ping
17:00:56 <EvanR> is there a word for the horizontal line seen here https://i.stack.imgur.com/VsA2m.jpg (the only image i could find with a single such line)
17:01:19 <EvanR> "horizontal line" isnt very specific and is quite long
17:06:54 <mniip> inference line?
17:07:05 <mniip> if this is a rule of inference
17:07:45 <mniip> https://math.stackexchange.com/questions/771066/notation-for-the-horizontal-line-found-in-sequent-calculus-for-linear-writing
17:08:30 <EvanR> viniculum seems to be reserved for overbars
17:09:21 <EvanR> ... inference line
17:52:48 <minn> Is it possible to recover the contents of a group in an Alex regex (roughly: does Alex implement capture groups?), or do you need to process the string when making the token?
17:58:41 <Gurkenglas> dmj`, pong
17:59:07 <jez_> minn: I think I get what you're asking. Would making the one lexer rule into several accomplish the same thing?
17:59:39 <dmj`> Gurkenglas: was able to get Windows builds working, https://ci.appveyor.com/project/dmjio/miso/build/1.0.4
17:59:45 <dmj`> with stack
18:00:45 <minn> jez_: It wouldn't be particularly elegant in this case. However, looking through the documentation again, I think this is an appropriate use of left/right contexts.
18:01:55 <jez_> I've never thought of lexing as particularly elegant :P
18:02:23 <jez_> Not heard of left/right contexts though; I'll have to check them out
18:02:24 <minn> If people wrote languages with sane lexical specifications, it would be :)
18:02:50 <Gurkenglas> dmj`, I also use the 7103 one and stack build, let me do it again so I can make certain of the commands
18:03:20 <dmj`> Gurkenglas: k, sounds good
18:05:07 <jez_> minn: True :)
18:07:33 <Gurkenglas> http://sprunge.us/IYLJ weird that it seems to be building other stuff now
18:10:00 <dmj`> Gurkenglas: \o/
18:10:35 <Gurkenglas> completed. Hm. Want a copy of miso_old?
18:12:07 <dmj`> Gurkenglas: yes
18:12:25 <dmj`> I’d like to see what stack file was in there, before the call to stack build that failed on ansi-terminal
18:15:07 <Gurkenglas> dmj`, https://www.file-upload.net/download-12608968/miso_old.zip.html
18:15:11 <dmj`> My hypothesis is that it wasn’t building w/ ghcjs, but rather latest ghc
18:19:25 <dmj`> Gurkenglas: thanks
18:21:16 <dmj`> Gurkenglas: strange, `elerea` in the extra-deps section isn’t needed, but that wouldn’t pull in ansi-terminal. No idea why that failed. Otherwise the stack files are identical
18:22:20 <dmj`> Gurkenglas: do you also happen to know where on windows stack stores the ghcs? (equivalent to ~/.stack)
18:23:27 <Gurkenglas> stack path says "ghc-paths: C:\Users\Gurkenglas\AppData\Local\Programs\stack\x86_64-windows"
18:24:49 <dmj`> Gurkenglas: thanks again
18:32:26 <stevebash> join #ufo
18:45:55 <slack1256> haha
19:00:08 * hackagebot hedgehog 0.5 – Hedgehog will eat all your bugs. – https://hackage.haskell.org/package/hedgehog
19:13:15 <luisdevlopez> Hi, just a question, may sound silly but
19:13:22 <luisdevlopez> is Function a Monoid?
19:13:43 <luisdevlopez> I mean, composing functions can be viewed as appending, it's an associative operation and the id function would be the idenitty
19:14:37 <monochrom> Yes, see the "Endo" newtype in Data.Monoid
19:14:43 <luisdevlopez> Appending two functions in Haskell with Data.Monoid.(<>) only works when the return value of the functions is a Monoid and then it combines the results.
19:14:55 <luisdevlopez> So IDK what kind of crazy stuff I can do with the knowledge that a Function is a Monoid
19:15:16 <luisdevlopez> ok will do, thanks
19:20:33 <lfairy> luisdevlopez: all Applicatives can implement Monoid via liftA2 (<>) and pure mempty -- the function instance is a special case of that
19:20:51 <lfairy> luisdevlopez: and Endo is a generalization of difference lists
19:23:57 <glguy> There's Endo, but there's also: instance Monoid b => Monoid (a -> b)
19:24:24 <glguy> which is the one lfairy described with liftA2 (<>)
19:26:42 <kadoban> That one is so nice for comparison chains. I miss that in like every other language. It's super code-golfy, but it's just cute as hell.
19:36:36 <lfairy> hjk
19:40:59 <dmwit> Functions are (almost) a category, which are kind of like a typed monoid.
19:48:06 <mniip> if a group extends to a groupoid
19:48:13 <mniip> then a monoid turns into a monoidoid
19:59:49 <pimlu> does haskell have something similar to Symbol in JS?
19:59:51 <pimlu> https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol
20:00:32 <pimlu> essentially it would be something that gives me unique values for Maps without having to keep track of some incrementing integer or something
20:01:32 <slack1256> Data.Unique
20:03:02 <slack1256> Nah, neverming Data.Unique
20:03:28 <lfairy> ironically, Data.Unique is implemented as a globally incrementing Integer underneath
20:03:47 <pimlu> the thing is
20:04:02 <pimlu> data.unique is exactly what I want except for the IO
20:04:38 <pimlu> which I assume must be a thing because otherwise ord would be nondeterministic
20:04:53 <pimlu> but that's not what I want it for, I just want unique keys for maps lol
20:05:33 <lfairy> well, you have to thread some state through somehow, otherwise CSE would merge two different keys into a single one
20:05:58 <slack1256> seeing the implementation, it creates a IORef with a 0 value and then increments it
20:06:17 <slack1256> State monad and modify (+1) ?
20:06:19 <pimlu> aw :(
20:06:52 <pimlu> that means I need to learn monad stacks I think
20:07:22 <pimlu> yeah, I guess so
20:07:22 <slack1256> hahaha
20:07:50 <slack1256> do something, get stuck and come back. #haskell works 24/7
20:08:20 <pimlu> lol sounds good
20:09:23 <slack1256> although what you need is just a function that from some seed, is strictly increasing
20:09:38 <slack1256> you just need to thread such value around
20:09:57 <slack1256> you could also pass it as argument on each of your functions
20:10:13 <slack1256> is not that bad if you have a single event loo
20:10:16 <slack1256> *loop
20:10:26 <pimlu> the the problem is
20:10:44 <pimlu> the thing I need this for is a crazy stupid monad I'm implementing lol
20:11:23 <pimlu> I'm trying to figure out how to make goto work in monads by myself
20:11:40 <pimlu> I know someone already made a better version but it's just a silly exercise
20:13:10 <pimlu> honestly I don't have a clue what I'm doing so I might give up lol
20:57:48 <lordcirth> pimlu, implement COME FROM instead, it's cooler
20:58:36 <pimlu> oh no lol
20:58:36 <minn> Is there any way to specify that a regular expression is case-insensitive in Alex? I'm dealing with a language where function names (and some keywords) are case-insensitive. One way to deal with this is to store identifiers in a lookup table, and handle them in the case for identifiers. But if the option is available, I would rather (since lexer size isn't really that much of an issue) store them as keywords.
20:58:43 <pimlu> I'm already having enough trouble
20:59:02 <pimlu> I think I'm closer to not using Maps at all to do this though
21:00:31 <lordcirth> minn, only some things are case insensitive?  sounds odd.  If everything was, you could just lowercase it all pre-lexing
21:01:35 <mson`> How do I filter a list of IO a? I thought throwing an fmap in there would do it since that's worked when I wanted to map, so I'm trying filter (fmap ((> 0) . length)) mylist. But it errors, saying the filtering function returns IO Bool. 
21:01:54 <minn> lordcirth: Well, it's not a language whose design decisions I would endorse (PHP).
21:02:13 <lordcirth> minn, lol. Why are you trying to parse PHP?
21:02:15 <lfairy> mson`: try filterM
21:03:15 * hackagebot yaml 0.8.23.3 – Support for parsing and rendering YAML documents. – https://hackage.haskell.org/package/yaml
21:03:32 <mson`> lfairy: AH! I spent half an hour trying fmap alone and filterM alone, but never together. Just tried it and it compiled. Thanks
21:03:43 <lfairy> mson`: btw, what's the general problem you're trying to solve? it's not possible to inspect the 'a' in 'IO a' without running the action
21:03:57 <lfairy> so using filterM here comes across as strange
21:04:28 <lewandowski> Hi People! I am trying to install gnuplot bindings for Haskell Platform on Windows. I have done cabal install gnuplot but I am unable to import the package in REPL. Any help?
21:04:44 <lewandowski> I have gnuplot installed on Windows too.
21:05:09 <lewandowski> I cannot import Graphics.Gnuplot.Simple.
21:05:31 <minn> lordcirth: We need more reliable/customizable/informative lexical analyses than available tools produce to associate defect/vulnerability data with statements and line numbers (for defect/vulnerability prediction).
21:05:58 <lordcirth> minn, and you can't mark all .php in red and be done? :P
21:06:39 <mson`> lfairy: I read a bunch of webpages in at the beginning of this program and now I think I'm stuck with IO forever (right?)? So it's just normal filtering of a list, but I have to get around being stuck with IO.  
21:06:58 <minn> lordcirth: haha, if only :)
21:09:03 <lfairy> mson`: makes sense, cool. so what does the list represent / what type is it? is it the web pages you've read?
21:09:26 <lfairy> I'm concerned that if your IO actions do something like download the page, you'll end up running the actions twice
21:12:26 <renl> hi may I ask how does fp languages make function composition easier? can't imperative languages compose too?
21:12:39 <mson`> lfairy: Hmm. It's a few steps removed from the pages. The program reads 15 pages, getting the bodies as Strings. Then I get a list of the indices at which a certain substring occurs. That list of lists of indices is what I'm filtering.
21:14:01 <mson`> But something has gone wrong with what I thought was the solution to my current issue: (filterM (fmap ((> 0) . length)) mylist) returned a IO [IO [Int]], but I wanted it to be the same type as mylist, which is [IO [Int]]. So I've prepended an IO somehow.
21:15:07 <zgrogan> you can do pretty much anything in an imperative language that you can do in fp.  you'll be jumping though a lot more hoops, though
21:15:23 <zgrogan> the converse is also true.  pick your poison
21:15:35 <minn> renl: Functional languages don't make function composition easier, but many imperative languages don't support partial application, currying and first-class functions.
21:17:16 <lfairy> mson`: yeah, I feel like you should 'sequence' the list first, to convert it from [IO [Int]] to IO [[Int]] (i.e. move the IO layer outside)
21:17:59 <lfairy> I was a bit trigger happy with suggesting filterM ;)
21:21:27 <mson`> lfairy: Hmm. I kept having issues earlier mapping over [IO a] that I finally solved by passing (fmap f) to map all over the place. Now that I see what you mean with sequence I wonder if that's making it overhard.
21:21:56 <mson`> Is it usually better to sequence as early as possible and work with IO [a] as much as possible?
21:22:49 <lfairy> mson`: yep, either that or use a streaming abstraction (like pipes)
21:24:24 <lfairy> that way, the inner business logic of your app only has to deal with pure values
21:25:05 <mson`> Yeah... that makes sense. I was thinking it would be silly to have to fmap on every line.
21:26:06 <mson`> So if the list [a], map f list works; if the list is type [IO a], (map (fmap f) list) works; what works for IO [a]?
21:26:22 <mson`> *if the list is type [a]
21:28:32 <wespiser> is the gradient descent well tested in the 'ad' or automatic differentiation package?
21:30:18 <lfairy> mson`: to answer your immediate question, fmap (map f) list
21:30:43 <lfairy> in general though, you'd have (fmap somePureComputation list) instead, where somePureComputation is defined separately for easier testing
21:32:20 <mson`> lfairy: I am composing 3 functions in place of f, and none have IO in their signature, so I think I am already doing that.
21:34:01 <lfairy> mson`: sounds like you have the right idea then :)
21:34:06 <pimlu> not sure if I'm asking something stupid, but
21:34:25 <pimlu> how can I ensure on a particular constructor for a type, the parameterized type a is a certain 2-tuple type I want?
21:34:51 <mson`> lfairy: thanks for all your help!
21:36:54 <pimlu> such as (b, b -> b) for some b
21:37:42 <kadoban> pimlu: data Blah b = Blah (b, b -> b)    -- like that?
21:38:03 <pimlu> problem with that is
21:38:10 <pimlu> if I make a monad instance with Blah
21:38:26 <pimlu> the type will be
21:38:40 <pimlu> (>>=) :: Blah a -> (a -> Blah b) -> Blah b
21:38:45 <pimlu> and in my case
21:38:49 <pimlu> I need a itself to be a tuple
21:39:01 <pimlu> so that in
21:39:10 <pimlu> a -> Blah b
21:39:16 <pimlu> it actually gets passed a tuple
21:40:25 <pimlu> (I'm trying to reproduce https://stackoverflow.com/questions/5193876/goto-in-haskell-can-anyone-explain-this-seemingly-insane-effect-of-continuation )
21:41:55 <pimlu> in that link, haskell knows it's a tuple because of the type of getCC'
21:42:18 <pimlu> but in my case, I need to know it's a tuple inside my implementation of >>= (I think...)
21:46:02 <pimlu> because basically what happens is I try to pattern match Blah (x,y) inside my definition of >>= and it says "`a` might not be a tuple for sure so you can't do that"
21:47:56 <Lokathor> pimlu, what you're saying is that you're not trying to implement >>=
21:47:57 <Lokathor> basically
21:48:29 <Lokathor> it's fine to have something similar to bind, but not quite, you just can't use it to satisfy the typeclass is all
21:49:15 <pimlu> are you saying I'm trying to do something that's incompatible with the type of >>= so I shouldn't bother?
22:05:11 <geekosaur> pimlu, they're saying you should not bother trying to make it be (>>=). it can be some other name of your choosing, but you do not get to say what (>>=) accepts
22:05:18 <geekosaur> :t (>>=)
22:05:20 <lambdabot> Monad m => m a -> (a -> m b) -> m b
22:06:17 <geekosaur> this is a typeclass-defined method. the above is its signature. you cannot choose the 'a'; it is (a) chosen by the caller, and (b) fixed by the Monad typeclass.
22:09:19 <pimlu> I see
22:09:47 <geekosaur> the typeclass is a contract. you can't pencil over it with your own version; you must honor the contract. the contract says 'you accept any "a"'
22:11:16 <pimlu> so, in other words, even if I could somehow restrict the constructors it wouldn't matter since the type of >>= would still be general
22:12:08 <geekosaur> you cannot even match that type if you try to specify what "a" is
22:12:20 <geekosaur> which is what the compiler is telling you when you attempt to make it be a tuple
22:12:38 <geekosaur> "you are violating the contract specified by the type of (>>=)"
22:14:50 <pimlu> okay
22:15:14 <pimlu> I think I understand
22:15:26 <geekosaur> and because it's defined as a typeclass method, the typeclass "owns" the contract so you can't change it. (were it your own function, you could just change the signature to be what you needed)
22:16:04 <pimlu> I guess I need to look at Cont and see how that guy's usage of it makes it work
22:16:37 <geekosaur> part (a) of what I said above
22:17:08 <pimlu> yeah, I see that
22:17:22 <geekosaur> you cannot control within your definition of (>>=) what "a" is; but code that uses (>>=) *can* control it. (which is why you aren't allowed to make assumptions about what "a" looks like)
22:17:36 <pimlu> getCC' has the tuple in its signature
22:18:11 <geekosaur> right, but getCC' is not a Monad typeclass method. it's *using* Monad, and as such it can specify that for that particular use "a" will be a tuple
22:18:30 <geekosaur> but, while you can do that in a function that *calls* >>=, you cannot do so in a *definition* of >>=
22:18:48 <pimlu> yeah, I understand now
22:18:53 <monochrom> When you said "in Blah a, a is a tuple", you're extremely misleading yourself, conflating types with values and whatnot.
22:18:56 <geekosaur> only one side of the "calls"/"defines" can know what a type looks like
22:19:14 <geekosaur> the other side must accept, or they must have a contract in common that specifies it will always be the same
22:19:25 <monochrom> Let's use distinct names to help unmislead. data Blah a = Make a (a -> a).
22:19:53 <monochrom> In the type "Blah Int" for example, Int is clearly not a tuple type.
22:20:47 <monochrom> But its value is going to be of the form "Make x y", where value x has type Int, value y has type Int->Int, and the whole Make x y value is a tuple of x and y.
22:23:03 <monochrom> It can be said that "Blah a" is basically a tuple type. But this has nothing to do with the "a" there.
22:24:44 <pimlu> so then, for example in Map
22:25:32 <pimlu> is the gist of this that Map typechecks only with Ords for keys because the constructors have that restriction
22:25:52 <pimlu> not because Map itself has Ord as a restriction for k?
22:26:13 <monochrom> The constructors don't have that restriction either.
22:26:14 <pimlu> (and all the other functions that operate on Maps)
22:26:54 <monochrom> insert has the Ord restriction. The code of insert actually uses an Ord method.
22:27:15 <monochrom> You will observe that singleton doesn't require Ord.
22:27:17 <pimlu> er, I meant to say the empty expression thing
22:27:24 <pimlu> but looking at the type it doesn't have Ord either
22:27:54 <pimlu> so basically you could make an empty Map with the key being a list type but you wouldn't be able to insert anything without failing typechecks?
22:28:15 <monochrom> Right.
22:28:20 <pimlu> huh, okay
22:29:07 <pimlu> so, is there a reason why they don't put Ord on empty, even though it doesn't compare anything?
22:29:08 <monochrom> But no, even lists enjoy Ord.
22:29:17 <monochrom> > [] <= [1,2]
22:29:19 <lambdabot>  True
22:29:39 <pimlu> oh, I didn't know that
22:29:57 <monochrom> If you take your question, replace "even though" by "because", that answers your question.
22:30:33 <pimlu> well, I mean, any code that actually uses the map will fail typechecking later
22:32:43 <pimlu> I guess it kind of makes sense to me, as long as you apply that policy everywhere
22:33:46 <pimlu> man, haskell and friends are nothing like imperative programming languages lol
22:37:07 <pimlu> thanks for you guys' help, btw
22:37:16 <pimlu> I learned a lot today
23:04:01 <Lokathor> pimlu, my imperative programming skills are actually beginning to go bad at this point
23:04:13 <Lokathor> and i've only been injecting the Haskell for ~2 years
23:05:18 <Lokathor> I'm sad to say it folks, but the rust crew has beaten us to the punch on the curses front
23:05:53 <Lokathor> there's a "pancurses" lib that does the right thing and automatically makes a PDCurses version on win32 and an ncurses version on unix (only exposing a subset API that works with both)
23:15:03 <pimlu> Lokathor: do you have a job writing haskell or something?
23:15:18 <Lokathor> no i don't work in software
23:15:40 <pimlu> whoah, that's awesome
23:15:48 <pimlu> you're the coolest kind of hobbyist programmer
23:15:57 <Lokathor> what kind?
23:16:16 <pimlu> I just mean you use a really interesting language for your hobby
23:16:54 <Lokathor> rust has an "almost good enough" type system, and i've written little demos in it even since starting Haskell
23:17:28 <Lokathor> If I needed to write a major distributed server to back something, i'd pick Erlang/Elixir
23:17:40 <Lokathor> For everything else, only Haskell seems to do the trick for me
23:18:01 <pimlu> rust and exlixir (or maybe just erlang, as long as it's on the VM) are the other interesting languages I've been meaning to learn >.<
23:18:23 <pimlu> now that I'm working full time for my internship, time is scarce lol
23:22:18 <heebo> hi im trying to parse prices using aeson. the structure is {"asks":[["40.49235","0.809",1500095481],["40.49236","15.000",1500095455]]}
23:22:53 <heebo> the problem is the json has different types in the array, and haskell doesnt allow it
23:23:22 <heebo> namely the type is [[String, String, Int]]
23:23:29 <heebo> any idea on how to handle
23:23:52 <Lokathor> i'm assuming that you can't adjust the json format
23:24:12 <cocreature> heebo: so are you trying to parse this as [(String, String, Int)]?
23:24:12 <heebo> yes its not my site
23:24:29 <Lokathor> changing your target parse type would work
23:24:51 <cocreature> [[String, String, Int]] is an error not a type :)
23:24:54 <heebo> cocreature: yes its saying that the Pattern match failed
23:25:26 <cocreature> heebo: so step 1. create some type to store the individual elements, i.e. "data Price = Price String String Int"
23:25:42 <cocreature> heebo: step 2. write a FromJSON instance for that type that parses a single 3 element array
23:26:03 <heebo> cocreature: thank you
23:26:05 <cocreature> heebo: step 3. have the usual aeson machinery turn that into one that gives you a list of prices
23:27:15 <heebo> this is what i had :                      [(ap,av,at)] <- v .: "asks"
23:28:31 <cocreature> this will crash for anything but a single tuple
23:28:42 <cocreature> I’m also not sure if the FromJSON instance of tuples does what you want here
23:29:46 <heebo> ah yes i see the single tuple issue
23:29:51 <heebo> ok will revise
23:30:56 <cocreature> oh it looks like the instance for tuples really does the right thing
23:31:29 <cocreature> so you don’t need the custom Price type but it’s probably still a good idea to make it clearer what it represents
23:32:39 <heebo> gotcha thanks
23:32:47 <luisdevlopez> Hey, does anyone know why zip <*> reverse is equal to zip xs (reverse xs) ? I thought (<*>) had a type signature of Applicative f => f (a -> b) -> f a -> f b
23:33:03 <luisdevlopez> I don't see how zip is of type f (a -> b) or how reverse is of type f a
23:33:24 <cocreature> luisdevlopez: (->) r is an instance of Applicative for any r
23:33:27 <cocreature> :t zip
23:33:28 <lambdabot> [a] -> [b] -> [(a, b)]
23:33:53 <cocreature> you can rewrite that as (->) [a] ([b] -> [(a,b)]
23:33:55 <cocreature> )
23:34:27 <cocreature> and then substitute the implementation of <*> https://hackage.haskell.org/package/base-4.9.1.0/docs/src/GHC.Base.html#line-641
23:36:07 <cocreature> luisdevlopez: I wouldn’t recommend writing "zip <*> reverse" in real code. even for experienced haskellers it’s easier to read \xs -> zip xs (reverse xs)
23:36:37 <luisdevlopez> I understand, I was just experimenting with Applicative after watching a video on LambdaCasts
23:37:21 <luisdevlopez> I also wanted to make it point free
23:37:35 <luisdevlopez> which is a little obsession of mine, not in real code
23:37:45 <cocreature> for learning purposes that’s fine :)
23:37:56 <luisdevlopez> thanks
23:38:15 <luisdevlopez> it was easier to understand why f <> g yielded the results it yielded
23:38:23 <luisdevlopez> but I was having a hard time with f <*> g
23:39:51 <cocreature> if you specialize the type of (<*>) for f= (->) r you end up with (->) r (a -> b) -> (->) r a -> (->) r b which is just (r -> a -> b) -> (r -> a) -> (r -> b)
23:40:08 <cocreature> that makes it reasonably easy to see what the implementation must be
23:40:15 <shafox_> I asked this in haskell-beginners, I am hoping somewhere here would reply. I know I have waited very little time but anywho I want some suggestions, here it goes:: Which xml library should I use for a beginner learner in haskell ? My current goal is to read xml file and print out the nodes data. I am looking at the  something that uses events so that I dont have to use more memory to read multi gigabyte file later. 
23:40:42 <shafox_>   /s/somewhere/someone
23:41:04 <Lokathor> hmm
23:41:47 <Lokathor> https://wiki.haskell.org/HXT this seems to be a beginner's guide, but i don't know how effective it will be for your case for sure
23:42:02 <cocreature> shafox_: I would probably use xml-conduit https://hackage.haskell.org/package/xml-conduit-1.5.1/docs/Text-XML-Stream-Parse.html but I have admittely not used its streaming support so far
23:42:34 <Lokathor> "multi-gig file" and "beginner" aren't so good to need in the same sentence :/
23:43:05 <cocreature> also it requires conduit but if you want to stream something in Haskell you are going to need to learn one of the streaming libraries anyway
23:44:05 * hackagebot gtk3-mac-integration 0.3.4.0 – Bindings for the Gtk/OS X integration library. – https://hackage.haskell.org/package/gtk3-mac-integration
23:44:05 * hackagebot gtk-mac-integration 0.3.4.0 – Bindings for the Gtk/OS X integration library. – https://hackage.haskell.org/package/gtk-mac-integration
23:51:07 <Cale> shafox_: Oh, this is probably a better place to answer :)
23:51:35 <Cale> Yeah, I also suggested xml-conduit as probably the best bet
