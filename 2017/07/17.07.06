00:10:22 <Lokathor> > sizeOf True
00:10:25 <lambdabot>  error:
00:10:25 <lambdabot>      • Variable not in scope: sizeOf :: Bool -> t
00:10:25 <lambdabot>      • Perhaps you meant one of these:
00:12:48 <saylu> It works!
00:12:49 <saylu> whew
00:12:57 <saylu> > You can write your own data type that contains an AccessToken and write a FromJSON for it.
00:12:59 <lambdabot>  <hint>:1:24: error: parse error on input ‘data’
00:13:01 <saylu> ReinH: This is what I did
00:27:15 <ertes-w> helo
00:32:10 <nshepperd> muzzle, [exa]: as i understand, a typeclass constraint is translated to an extra argument data type containing 
00:32:20 <nshepperd> containing all the methods
00:32:37 <nshepperd> so whether it gets erase at runtime is up to the inliner
00:33:38 <dramforever> 'adds an additional Int# argument' sounds wrong
00:33:47 <[exa]> nshepperd: I kindof hoped this approach was long forgotten
00:33:59 <dramforever> ?
00:34:58 <ertes-w> is yarr still faster than repa?
00:35:13 <dramforever> muzzle: All the types themselves are erased at compile time
00:35:16 <ertes-w> (or has it ever been?  i haven't benchmarked myself)
00:35:28 <nshepperd> [exa]: why? seems like a good approach to me
00:35:34 <dramforever> but instance dictionaries can't always be erased
00:35:35 <ertes-w> i need a fast CPU parallel array library
00:35:43 <[exa]> nshepperd: it looks too much like vtables :]
00:35:55 <dramforever> except you have nowhere to put the vtables
00:36:02 <dramforever> :t read
00:36:04 <lambdabot> Read a => String -> a
00:36:13 <dramforever> [exa]: here, put the vtable in
00:37:34 <saylu> In the end you can get hoauth2 to work with this:
00:37:34 <saylu> https://github.com/freizl/hoauth2/issues/62
00:37:56 <[exa]> dramforever: iirc it creates something like  DictWithReadMethods -> String -> a
00:38:05 <dramforever> yep
00:38:28 <[exa]> any docs on what does the DictWith..... actually contain today?
00:38:28 <dramforever> [exa]: so what's the deal?
00:39:26 <[exa]> dramforever: well actually no big deal, let's just say I'm a fan of monomorphic compiler output
00:39:28 <nshepperd> [exa]: if your typeclass has exactly one method, it's just that method
00:40:02 <dramforever> You lose some of the features of typeclasses if you actually made everything monomorphic
00:40:10 <[exa]> so it is a tuple of functions?
00:40:35 <dramforever> like... you can't use polymorphic recursion with typeclass constraints
00:40:42 * dramforever wonders why that came to mind so quickly
00:40:48 <[exa]> dramforever: I understand that cross-module compilation is hard with monomorphic stuff; is there something you lose in a single module?
00:40:51 <[exa]> oh so
00:41:16 <dramforever> Hmm
00:41:22 <[exa]> good point though, thanks
00:41:33 <nshepperd> why not leave this up to the inliner
00:41:44 <nshepperd> generating code to make stuff monomorphic is always a tradeoff
00:41:54 <[exa]> yup
00:42:32 <[exa]> dramforever: any good example of the class-constrained poly recursion?
00:42:39 <dramforever> No
00:43:01 <[exa]> :]
00:43:16 <[exa]> ok I'll try to invent some and see
00:43:40 <nshepperd> finger trees
00:44:43 <dramforever> I thought finger trees do *not* need poly rec constraints
00:44:47 <dramforever> 2-3 treees
00:44:54 <dramforever> that
00:46:27 <[exa]> btw--- anyone here going to ICFP'17 ?
00:46:30 <nshepperd> i thought they might for the Measure stuff, but i dunno
00:46:43 <dramforever> Ahh
00:46:59 <dramforever> Yes that's probably going to be needed
00:47:01 <Athas> [exa]: I certainly intend to!
00:47:08 <dramforever> oh wait
00:47:09 <dramforever> no
00:47:25 <nshepperd> anyway, the dictionary transformation is good because it's flexible like that. if you have enough information to inline it you can do so, otherwise it's fine
00:47:52 <dramforever> yes
00:47:58 <dramforever> damn it
00:48:09 <dramforever> I have no ****ing clue
00:50:04 <[exa]> Athas: well, I'm kindof thinking about the poster session there
00:50:58 <Athas> [exa]: do it!
00:51:34 <Athas> I'm handing in my dissertation a week before ICFP, so I'm sadly not eligible.
00:52:17 <[exa]> I have lots of debatable stuff here, I guess letting the people there shred it could provide some answers :D
00:52:28 <[exa]> oh wow, good luck then :]
00:52:48 <Athas> Poster sessions are always good fun.  They are a concentrate of the most important part of conferences: meeting other researchers.
00:54:06 <[exa]> what I wanted to ask originally, how super-formal should the posters be?
00:54:25 <nshepperd> also, you can put functions that take constraints into GADTs and stuff, and send them over Chans, just to make sure you lose all hope of being able to monomorphize them
00:54:41 <[exa]> There are conferences where posters Should Present Results (TM) and there are conferences where posters should ask good questions
00:54:52 <Lokathor> does mapM_ run better/faster/less memory than mapM ?
00:55:10 <Athas> [exa]: my poster strategy is to optimise for the case where I'm standing in front of it.  Thus, it is an aide to my own explanations.  But not everyone does it that way.
00:55:32 <Athas> I don't think I have ever liked a super-formal poster.  Nobody wants to think that hard while standing in a crowded room.
00:56:17 <bartavelle> Lokathor: it should not run in more memory, but it sometimes leak memory, because the first argument is 'a -> m b' and not 'a -> m ()' (can't remember why exactly, there is a blog post on that topic that I can't find)
00:56:36 <Lokathor> so prefer mapM_ when possible?
00:56:55 <bartavelle> well, it makes the intend clearer, so that's always better
00:57:29 <bartavelle> Lokathor: https://www.snoyman.com/blog/2017/01/foldable-mapm-maybe-and-recursive-functions
00:57:35 <dramforever> :t mapM_
00:57:36 <lambdabot> (Monad m, Foldable t) => (a -> m b) -> t a -> m ()
00:57:38 <dramforever> :t mapM
00:57:39 <lambdabot> (Monad m, Traversable t) => (a -> m b) -> t a -> m (t b)
00:57:42 <dramforever> That's different!
00:57:57 <jared-w> yeah, any monad function with a _ throws away the result of the computation
00:58:07 <[exa]> Lokathor: if you don't need the result, discard it asap. mapM_ won't allocate the Traversable (very likely a list)
00:58:20 <dramforever> There's something else!
00:58:28 <dramforever> Foldable and Traversable are different!
00:58:41 <dramforever> This means you will be able to mapM_ a Set but not mapM it (IIRC
00:58:53 <dramforever> )
00:58:56 <Lokathor> this is a list
00:58:59 <bartavelle> indeed, and that's a big difference, I always thought mapM was more general than mapM_ !
00:59:11 <Lokathor> mapM_ (\i -> ST s action) [list of indexes]
00:59:39 <jared-w> bartavelle: mapM keeps the computation, mapM_ throws it away
00:59:47 <[exa]> Athas: more pictres then. Thanks :]
01:00:09 <bartavelle> jared-w: yes, I do know that :) I thought you could use mapM everywhere you used mapM_, and just ignore the result
01:00:18 <bartavelle> turns out it is wrong
01:00:30 <jared-w> Because you throw away the result, you don't need to care about it at all, so you can do a larger amount of things
01:01:12 <jared-w> Traversable preserves shape, foldable throws away the shape. If you don't care about the computation result ergo you shouldn't care about the shape either as long as you're preserving the structure; hence, Traversable for MapM and Foldable for mapM_
01:01:49 <Lokathor> jared-w, but mapM_ is the version that leaks memory >_>
01:02:16 <Lokathor> (that sometimes leaks memory)
01:02:16 <bartavelle> Lokathor: mapM_ leaks memory compared to a specialize version 'a -> m ()', but not compared to mapM
01:02:26 <Lokathor> ah
01:02:42 <Lokathor> and just with some instances?
01:03:28 <bartavelle> IIRC it is mostly important for stuff like Maybe, but I'll need to read that article again to grasp the issue again (and forget about it again)
01:03:54 <jared-w> bartavelle: link to article? I, too, would like to grasp and then immediately forget something
01:04:02 <bartavelle> https://www.snoyman.com/blog/2017/01/foldable-mapm-maybe-and-recursive-functions
01:04:17 <jared-w> thanks!
01:04:21 <bartavelle> np
01:04:55 <nshepperd> i wonder if you could somehow fix that leaking memory by throwing a Codensity at it or something
01:05:14 <dramforever> ah
01:05:22 <dramforever> That looks like the problem is in recursion not Maybe
01:05:25 <jared-w> oooh, it's not tail recursive for Maybe
01:05:53 <bartavelle> edwardkmett • 6 months ago
01:05:55 <bartavelle> In Lens I resolved this with a fancier choice of monoid.
01:05:57 <bartavelle> ;)
01:06:19 <jared-w> Seems to be caused by the return type of -> m ()
01:06:25 <dramforever> actually
01:06:26 <bartavelle> so there is a solution in lens, mapMOf_
01:06:36 <jared-w> :t mapMOf_
01:06:38 <lambdabot> Monad m => Getting (Sequenced r m) s a -> (a -> m r) -> s -> m ()
01:06:56 <dramforever> it's leaking because it's got return () >> return () >> return () >> return () >> ...
01:07:15 <dramforever> which is Pretty Bad (tm)
01:08:13 <jared-w> :t Data.MonoTraversable.omapM_
01:08:14 <lambdabot> error:
01:08:14 <lambdabot>     Not in scope: ‘Data.MonoTraversable.omapM_’
01:08:14 <lambdabot>     Perhaps you meant ‘Data.Traversable.mapM’ (imported from Data.Traversable)
01:09:20 <jared-w> nah, he probably changed the function name
01:09:31 <jared-w> :t Data.MonoTraversable.oforM_
01:09:32 <lambdabot> error:
01:09:32 <lambdabot>     Not in scope: ‘Data.MonoTraversable.oforM_’
01:09:32 <lambdabot>     Perhaps you meant one of these:
01:11:21 <jared-w> anyway, is there any polymorphism lost by changing the specialized forM_ on maybe to (a -> m ()) rather than (a -> m b)  ?
01:11:53 <merijn> jared-w: Now you have to explicitly "void" the function you wanna pass into it
01:12:37 <jared-w> right... which would not be very nice to write
01:13:09 <dramforever> and still leaky
01:13:17 <dramforever> you can't 'just void' the thing
01:13:31 <dramforever> whoa
01:13:34 <dramforever> wait a sec
01:13:35 <Gurkenglas_> When would you even pass something to forM_ that doesn't already have (a -> m ())-shape?
01:13:35 <merijn> oh, are we talking forM vs forM_?
01:13:59 <merijn> Gurkenglas_: When you have "a -> m Foo" lying around, but don't care about the results?
01:14:10 <jared-w> Originally we were talking about why mapM_ and mapM have different constraints (traversable vs foldable)
01:14:41 <jared-w> then it got into a "there's an ugly space leak in the M_ version"
01:15:02 <Gurkenglas> When does that happen? Usually I don't want to throw away values. I find throwing values away unusual enough to be worth pointing out in the code. And then when I would throw values away by accident the compiler tells me.
01:15:03 <jared-w> which lead to bartavelle linking an explanatory blog post: https://www.snoyman.com/blog/2017/01/foldable-mapm-maybe-and-recursive-functions 
01:15:21 <Gurkenglas> But examples pls :D
01:15:50 <jared-w> Gurkenglas: the blog post I linked has some very simple yet plausibly non-contrived code that demonstrates a usecase
01:18:38 <Gurkenglas> Scanning it, not seeing it, where do you mean? (Oh look if one needed void to do this I wouldn't have troubles spotting it :P )
01:18:56 <dramforever> no, actually void wouldn't have helped
01:19:24 <jared-w> The space leak happens because you return () over and over due to forM_ not being tail recursive in the case of Maybe's implementation
01:20:01 <dramforever> It's not mapM_/forM_ that's non-tailrec
01:20:13 <Gurkenglas> No, I mean where in that post do you want to pass (a -> m b) for (a -> m ())? I've been advocating for making that explicit since before this space leak stuff ^^
01:20:17 <dramforever> it's because it causes printChars to be non-tailrec
01:21:16 <jared-w> dramforever: ahh right, thanks for the clarification. Although, verbatim in the text, "the issue is that the implementation of mapM_ ... is not tail recursive, at least for the case of Maybe"
01:21:30 <dramforever> which is at best misleading
01:22:00 <jared-w> ctrl+f "There's one slight difference in the type" ... and read that paragraph 
01:23:32 <dramforever> Reminds me of an exercise from CLRS
01:23:46 <dramforever> (introduction to algorithms)
01:24:10 <dramforever> 'Write a version of quicksort that runs in O(log size) recursive call depth'
01:26:53 <jared-w> hmm...
01:27:32 <Gurkenglas> jared-w, was that "ctrl+f"-line to me? That paragraph doesn't answer my question, which is: If forM_ was of type "Foldable f => (a -> m ()) -> f a -> m ()", can you think of an example where you'd need to use void on the (a -> m b) you have to be able to use forM_?
01:27:44 <Lokathor> a type signature so long that gitbook thinks it should add a tiny horizontal scroll bar to the code block
01:28:14 <jared-w> dramforever: is that the version which requires two pointers moving towards each other?
01:28:20 <merijn> Lokathor: You level up from beginner to intermediate when you have to start linewrapping typesignatures :)
01:28:33 <merijn> And I don't mean because of haddock comments :p
01:28:38 <Lokathor> setBox :: PrimMonad m => Int -> VM.MVector (PrimState m) a -> (Int,Int) -> (Int,Int) -> a -> m ()
01:28:40 <dramforever> jared-w: I don't know, tbh
01:28:47 <Lokathor> in week 3 of a "beginners" tutorial :3
01:28:53 <merijn> Lokathor: wut
01:28:57 <merijn> Lokathor: Which tutorial is that?
01:29:04 <Lokathor> mine!
01:29:05 <dramforever> Which 'beginner' is that?
01:29:08 <Lokathor> https://lokathor.gitbooks.io/using-haskell/content/roguelike/week-3-random-dungeons.html
01:29:21 <jared-w> random dungeons? Pffh, that's practically cheating
01:29:30 <Lokathor> o_O
01:29:32 <merijn> Lokathor: Fair enough
01:30:09 <jared-w> I'm joking, but I'd assume a ton of extra constraints on type variables because of Random and other things needed which would add a lot of padding space
01:30:23 <Lokathor> dramforever, it's a haskell "how to build a roguelike" tutorial, which ends up using advanced haskell features here and there, but the text between the code examples is targeting as low a level as possible with the explanations
01:30:30 <dramforever> Not bad
01:31:07 <Lokathor> eg: I'm explaining what flip does... but the reason that I need to explain flip is because I wrote, runST $ flip runRandT g $ do
01:31:13 <merijn> Lokathor: I have it bookmarked, but not actually looked at yet. But I think that might actually be neat to showcase "imperative" haskell :)
01:31:15 <Lokathor> :S
01:31:22 <merijn> Lokathor: What are you using to display things?
01:31:35 <jared-w> Of course, having read that, I realize the long sig in question doesn't actually use RandomGen anywhere in the type constraint :p
01:31:37 <dramforever> jared-w: It could be Really Bad (tm) if I spoiled the answer...
01:31:53 <Lokathor> a GLFW-b+gl based lib that I wrote myself (you can learn how too! just read the OpenGL part of the book instead of the Roguelike part of the book :3 )
01:32:13 <merijn> Lokathor: Ah, so you're a heretic ;)
01:32:18 <Lokathor> dramforever, it's that PrimMonad nonsense
01:32:27 <dramforever> let's just say 'tail recursion ftw'
01:32:37 <merijn> I started working on a rogue-like using vty-ui years ago, but it's shelved atm :p
01:32:41 <jared-w> oh right
01:33:04 <Lokathor> merijn, for tiles over ascii? show me a curses-like lib that is easy to use on windows and we can talk
01:33:24 <merijn> Lokathor: I have high hopes for the Windows Linux Subsystem ;)
01:33:34 <Lokathor> Win7 for me, sad days
01:33:39 <jared-w> I have realistic hopes: None. I still expect to be disappointed
01:33:45 <Lokathor> :OP
01:33:55 <Lokathor> that's two faces in one, it's like a textual gif
01:34:44 <dramforever> Lokathor: ooh I really like the style
01:35:48 <Lokathor> like the CSS?
01:36:32 <dramforever> uh
01:36:46 <dramforever> I mean the almost livecoding style of talking
01:37:03 <jared-w> It's pretty great except for the fact that horizontal scrollbars don't exist on my computer with it for some reason
01:37:08 <Lokathor> ah, well
01:37:25 <dramforever> I keep seeing things like 'which reminds me'
01:37:26 <Lokathor> jared-w, like the page is wider so it doesn't have to scroll?
01:37:39 <dramforever> Which is good. It's easier to follow
01:37:55 <Lokathor> dramforever, yeah I've got a very conversational explanation style
01:38:46 <dramforever> whoa, that 'commit' thingy at the end of the section made my day
01:39:11 <Lokathor> i accidentally left part out of last week's writeup for a while
01:39:26 <dramforever> 'and now you get a random blob of wall that changes every time you start the program: commit'
01:39:27 <Lokathor> some poor newbie was like "hey it doesn't compile at this point in the guide and i can't tell why"
01:39:42 <jared-w> Lokathor: no, I have to scroll sideways to see the super long function type, but there's no indication that the text is cut off
01:39:44 <Lokathor> so i'm going to try intermediate commits too
01:40:16 <Lokathor> jared-w, how troublesome. Sadly, gitbook is doing 99% of the website production there. I'm just telling it what colors to use with CSS, they do the rest
01:40:23 <Lokathor> with uh, mdbook is the program i think
01:40:52 <jared-w> yeah, if I dind't know -> a was a weird type for setbox, I wouldn't intuitively know to scroll it
01:42:06 <Lokathor> was gonna go to bed, but i'm gonna fix that and also a typo i just saw
01:42:18 <jared-w> I think the different sizing of the text is throwing off mdbook a bit. The type signature is only 97ish characters long and the width of your text itself is over 100 and yet the text doesn't wrap but the code requires a tiny bit of scrolling
01:43:44 <jared-w> Also, even if I can scroll the main text side by side, I don't have an indication on my computer that I need to scroll the code block for setBox
01:44:11 <slack1256> I looking for executables that compile with -N rtsops on hackage. Any examples?
01:44:28 <jared-w> To be fair, this is somewhat of a deliberate setup on my computer to hide all scrollbars in the browser because they're ugly and I hate them. A more conventional setup on chrome shows the horizontal scrollbar just fine
01:45:02 <merijn> slack1256: Any specific reason why?
01:45:26 <slack1256> I want to see how they did their performance testing
01:46:11 <slack1256> ie how do they arrived at a conclusion that in their case, that default was helpful
01:46:53 <slack1256> (I got a mess in my head about the interaction of the number of capabilities, paralle gc and raw throughput)
01:48:07 <Lokathor> jared-w, not having scroll bars does seem a little differnet of a browser experience
01:49:16 <jared-w> It's fine for me because I use firefox + vimperator for a 99% keyboard driven experience. Scrollbars are irrelevant to me for the most part because the large majority of web content out there assumes I don't want to scroll horizontally and need to see all of everything at once
01:50:30 <ventonegro> "hana::for_each(xs, f) requires 'xs' to be Foldable"
01:50:41 <ventonegro> Heh, C++ has Foldable now
01:51:56 <quchen> Yes, C++ is a functional language now, it has map and filter.
01:52:20 <Lokathor> Peyton save us all
01:52:40 <merijn> for_each is old school, you can just do "for (x : xs) { }" now
01:53:50 <ventonegro> merijn: That's from the Hana library for type-level programming
01:54:20 <quchen> What’s less widely known is that Haskell is object oriented these days, because there are functions called »new«.
01:54:49 <Lokathor> rust has new but it's only by convention
01:54:52 <merijn> quchen: pfft, implying anyone uses "new" in C++
01:54:57 <Lokathor> ha
01:55:35 <Lokathor> my tutorial teaches peolpe that `mk` is how you prefix a builder function in haskell
01:55:39 <nshepperd_> std::make_unique is where it's at
01:55:42 <Lokathor> I hope that's still what the cool kids do
01:56:01 <systemfault> C++ was my first FP language :)
01:56:04 <Axman6> data Object a = Object { privateData :: a, methods :: HashMap Text (Object a -> IO ())}
01:56:40 <Lokathor> Axman6, now inherit from Object
01:56:43 <Lokathor> I know you can do it
01:56:47 <[exa]> about c++, have you seen this?   https://github.com/vituscze/norri
01:57:00 <Lokathor> (bonus: then compose instead, because composition is better :P)
01:57:21 <jared-w> Lokathor: mkFoo is how I see it everywhere still, so it seems good to me
01:57:40 <Lokathor> nice
01:57:53 <Lokathor> welp, bed time i think
01:58:00 <jared-w> Although it's a tossup between whether I'm reading something practical or "let's turn on the kitchen sink and screw mkFoo, we're doing this shit at the type level"
01:58:34 <Lokathor> if your types can't compute enough to compile GHC why are you even touching the keyboard
02:09:40 <wz1000> which library should I use for pretty printing a small subset of html to markdown?
02:09:52 <Lokathor> parsec
02:10:08 <Lokathor> but really i don't know
02:10:19 <merijn> parsec is for parsing, not pretty-printing
02:10:35 <merijn> wz1000: Can you clarify what you mean by pretty-printing html?
02:10:44 <Lokathor> merijn, my implication was to build a parser that parses the HTML you want and spits out the markdown
02:11:10 <tdammers> I think you mean pando
02:11:12 <tdammers> pandoc*
02:11:49 <brynedwards> pandoc sounds right; it sounds like you want to convert formats?
02:12:16 <wz1000> I get data as html, need to show it to the user with an application that knows how to render markdown
02:12:38 <wz1000> I think pandoc would be too heavy for my usecase.
02:13:47 <tdammers> too heavy? why?
02:13:59 <halogenandtoast> Is there something like repeat but for IO?
02:14:22 <merijn> halogenandtoast: You wanna execute the IO indefinitely?
02:14:31 <halogenandtoast> merijn: like this
02:14:32 <halogenandtoast> zip . repeat <$> randomIO <*> pure [1,2,3]
02:14:49 <merijn> halogenandtoast: Eh, that will never finish :p
02:15:06 <halogenandtoast> well that code ^^ finishes
02:15:07 <merijn> halogenandtoast: You want
02:15:09 <merijn> :t randoms
02:15:10 <halogenandtoast> I just get the same number :p
02:15:10 <lambdabot> (RandomGen g, Random a) => g -> [a]
02:15:33 <halogenandtoast> Yeah I've been using randoms, I was just wondering if I could use randomIO instead
02:15:39 <tdammers> halogenandtoast: of course you get the same number over and over
02:15:44 <halogenandtoast> tdammers: I know!
02:15:56 <[exa]> halogenandtoast: not sure if it helps you but I use something like: 
02:16:01 <[exa]> repeatM n f a0 = foldM (\a _ -> f a) a0 [1..n]
02:16:07 <merijn> halogenandtoast: Well, you could reimplement randoms, but at that point the question is: why?
02:16:19 <halogenandtoast> merijn: I was just playing around in ghci
02:16:25 <halogenandtoast> no serious reason
02:16:34 <merijn> "randoms <$> newStdGen" is probably the way to go
02:16:38 <halogenandtoast> just wondering if I could
02:16:58 <halogenandtoast> [exa]: yeah but you have to know some value for `n` in that case
02:17:32 <halogenandtoast> Thanks for the advice.
02:18:19 <tdammers> forM [1,2,3] $ \n -> (,n) <$> randomIO
02:18:23 <tdammers> maybe
02:19:23 * hackagebot tasty 0.11.2.2 – Modern and extensible testing framework – https://hackage.haskell.org/package/tasty
02:20:24 <halogenandtoast> tdammers: that seems to work with TupleSections
02:20:42 <tdammers> halogenandtoast: ah yes, forgot to mention that
02:20:58 <merijn> Man, I hope they add TupleSections to the Prime report, because it's annoying that that's an extension
02:21:04 <tdammers> agree
02:21:50 <halogenandtoast> I mean you could just do
02:21:51 <halogenandtoast> forM [1,2,3] $ \n -> (,) n <$> randomIO
02:21:56 <halogenandtoast> and not need TupleSections
02:22:12 <tsahyt> is anyone with some FRP experience around? I'm still not sure how to deal with getting a view to display contents of a database and changing the database from the view, keeping everything in sync
02:22:18 <halogenandtoast> I would just change my code to deal with it
02:22:33 <halogenandtoast> or to get the same result
02:22:33 <tsahyt> everything I can think of somehow feels like a ugly hack
02:22:34 <halogenandtoast> forM [1,2,3] $ \n -> flip (,) n <$> randomIO
02:22:43 <tdammers> sure
02:23:06 <merijn> So, question: Does anyone know if "a -> b" is coercible to "a -> c" when "b" is coercible to "c"?
02:23:31 <halogenandtoast> merijn: wouldn't that be a no?
02:23:33 <tsahyt> merijn: logically speaking, I think so
02:23:48 <merijn> tsahyt: I agree with the logic, I'm just wondering if GHC does that
02:23:52 <merijn> halogenandtoast: Why?
02:24:32 <halogenandtoast> merijn: for some reason I was thinking "All squares are rectangles, but not all rectangles are squares"
02:24:53 <halogenandtoast> but that doesn't apply here
02:24:54 <halogenandtoast> ignore me
02:25:20 <merijn> ooh
02:25:24 <merijn> Looks like the answer is yes
02:25:32 <merijn> This makes things so much easier!
02:26:30 <tsahyt> halogenandtoast: if b is coercible to c, then that's equivalent to having a function b -> c (those must all be concrete b's and c's of course), so given a function a -> b, getting a function a -> c should just be a matter of function composition. at least I think this is how this works out
02:27:40 <merijn> <3
02:27:48 <merijn> Man, coerce is like, the best thing since sliced bread....
02:28:09 <wz1000> I think coerce can deal with arbitarily nested types.
02:28:41 <merijn> :t \l -> getAny . mconcat (coerce l)
02:28:42 <lambdabot> error:
02:28:42 <lambdabot>     • Variable not in scope: coerce :: t -> [a -> Any]
02:28:42 <lambdabot>     • Perhaps you meant ‘coerced’ (imported from Control.Lens)
02:28:49 <merijn> :t \l -> getAny . mconcat (Data.Coerce.coerce l)
02:28:51 <lambdabot> Coercible a1 [a -> Any] => a1 -> a -> Bool
02:29:26 <merijn> That makes the Bool monoids so much more usable
02:29:41 <tsahyt> :t \l -> getAny . mconcat (Any l)
02:29:42 <lambdabot> error:
02:29:42 <lambdabot>     • Couldn't match expected type ‘[a -> Any]’ with actual type ‘Any’
02:29:42 <lambdabot>     • In the first argument of ‘mconcat’, namely ‘(Any l)’
02:29:56 <tsahyt> oh
02:29:59 <tsahyt> :t \l -> getAny . mconcat (map Any l)
02:30:01 <lambdabot> error:
02:30:01 <lambdabot>     • Couldn't match expected type ‘a -> Any’ with actual type ‘Any’
02:30:01 <lambdabot>     • Possible cause: ‘mconcat’ is applied to too many arguments
02:30:05 <tsahyt> no, that wasn't it
02:30:21 <merijn> tsahyt: That doesn't work because I have a list of "a -> Bool", not "Bool"
02:31:02 <merijn> Which is that amazing "instance Monoid b => Monoid (a -> b)" :)
02:31:12 <tsahyt> I see
02:31:46 <merijn> Probably my favourite monoid :)
02:32:50 <tsahyt> all monoids are beautiful
02:33:52 <tsahyt> even instance Monoid (), though that's pretty useless
02:34:26 <merijn> I've used that monoid before :)
02:34:42 <merijn> I forgot why, but still!
02:35:13 <tsahyt> () <- mconcat <$> mapM foo xs, for when you want to be sure that () is returned
02:35:31 <merijn> tsahyt: How does that ensure that?
02:35:56 <tsahyt> I don't think it really does, it should be equivalent to just not binding the result
02:36:05 <merijn> > () `mappend` undefined
02:36:08 <lambdabot>  ()
02:36:36 <tsahyt> I guess what the above line does depends on the monad it runs in
02:37:07 <tsahyt> can mapM be ever even be sufficiently lazy that some actions just aren't executed?
02:37:20 <merijn> tsahyt: No, that'd violate the Monad laws
02:38:04 <tsahyt> how so?
02:38:51 <merijn> tsahyt: Because mapM boils down to repeated use of >>=
02:39:24 <merijn> I guess for mapM specifically you'd have to refer to the combination of Monad laws + Traversable laws
02:41:26 <tsahyt> hmm, I keep forgetting these things
02:51:58 <Axman6> > mappend undefined undefined :: ()
02:52:00 <lambdabot>  ()
02:52:04 <Axman6> D:
02:52:09 <merijn> Axman6: Well, duh :)
02:52:35 <Axman6> well, not necessarilly duh, it could have been more strict
02:53:27 <Axman6> instance Monoid () where mappend () () = () would be perfectly sensible
02:53:58 <merijn> Axman6: Yeah, but why compute a potentially expensive ()? :)
02:54:07 <Phyx-> 09:32:43 < Lokathor> merijn, for tiles over ascii? show me a curses-like lib that is easy to use on windows and we can talk
02:54:10 <Phyx-> 09:33:02 < merijn> Lokathor: I have high hopes for the Windows Linux Subsystem ;)
02:54:19 <Phyx-> why? the console API on windows is far more powerful
02:54:33 <merijn> Phyx-: But then it'd only work on Windows
02:54:39 <tsahyt> @hoogle Read a => Text -> a
02:54:40 <lambdabot> BasicPrelude read :: Read a => Text -> a
02:54:40 <lambdabot> Text.PDF.Info readRight :: (MonadError PDFInfoError m, Read a) => Text -> m a
02:54:40 <lambdabot> Prelude read :: Read a => String -> a
02:54:52 <merijn> Phyx-: And who the hell wants to maintain two separate copies of something?
02:55:00 <tsahyt> hmpf
02:55:08 <tsahyt> :t read . Data.Text.unpack
02:55:10 <lambdabot> Read c => Data.Text.Internal.Text -> c
02:55:12 <Phyx-> merijn: what I mean to say is, there's no reason you can't build cursus like lib supporting both
02:55:17 <tsahyt> that doesn't look quite satisfactory though
02:55:29 <merijn> Phyx-: Also, if you're familiar with the windows console API you should add windows support to vty/brick, I'd love you forever
02:55:33 <tsahyt> @hoogle Read a => Text -> Maybe a
02:55:33 <lambdabot> BasicPrelude readMay :: Read a => Text -> Maybe a
02:55:33 <lambdabot> Web.PathPieces readFromPathPiece :: Read s => Text -> Maybe s
02:55:33 <lambdabot> Text.Read readMaybe :: Read a => String -> Maybe a
02:55:49 <Phyx-> merijn: at least I plan on updating haskeline, the rest i'll look at on an as needed basis
02:56:52 <Phyx-> merijn: well, I'm rewriting all I/O in base for 8.4. I'll at some point put out a beta and ask for feedback and which libraries people would like to see updated. (I obviously can't do them all) but I'll see what I can do for the more popular ones
02:58:54 <tsahyt> what packages provides those nested fmap applications again? e.g. (Functor f, Functor g) => (a -> b) -> f (g a) -> f (g b) iirc
03:00:35 <unsymbol> tsahyt: seems to be a few http://hayoo.fh-wedel.de/?query=%28Functor+f%2C+Functor+g%29+%3D%3E+%28a+-%3E+b%29+-%3E+f+%28g+a%29+-%3E+f+%28g+b%29
03:01:04 <tsahyt> I believe I was thinking of composition-extra
03:01:22 <tsahyt> yep
03:01:26 <tsahyt> <$$>, that's it. thanks!
03:01:50 <alios> Data.Functor.Syntax (<$$>) :: (Functor f0, Functor f1) => (a -> b) -> f1 (f0 a) -> f1 (f0 b)
03:10:57 <tsahyt> actually I might be better off just working with the composition of those functors directly, since I need the compositions of their Applicative instance later anyhow
03:17:01 <kuribas> would there be interest in a std::vector wrapper for Data.Vector.Storable?
03:17:27 <kuribas> Basicly a storable vector that can be interchanged with a C++ vector without copying?
03:18:25 <kuribas> And perhaps O(n) mutable append
03:19:38 <kuribas> Creation and destruction would go via the ffi, other operations directly on the buffer.
03:24:39 <lambdamu_> kuribas: So the operations would have to live in a PrimMonad or how would you interchange it without copying?
03:26:16 <kuribas> lambdamu_: it would simply wrap a std::vector
03:27:41 <lambdamu_> kuribas: I'm all for it, but I'm not quite sure what that means? A newtype wrapper around a Ptr?
03:27:51 <kuribas> lambdamu_: yes
03:28:57 <kuribas> lambdamu_: and a pointer to the storage
03:29:40 <kuribas> for efficiency.
03:30:34 <kuribas> Of course the storage pointer  shouldn't change then...
03:31:53 <lambdamu_> kuribas: Well then, go for it :D
03:33:25 <kuribas> There will be an extra indirection though, I wonder if ghc will optimize that...
03:34:32 <kuribas> Float out the storage pointer in a loop.
03:34:41 <kuribas> Otherwise performance will be worse, not better...
03:37:00 * hackagebot ploton 0.2.0.0 – A useful cli tool to draw figures – https://hackage.haskell.org/package/ploton
03:37:17 <merijn> kuribas: How do you imagine this being different than the exist mutable vectors?
03:37:38 <kuribas> merijn: going to c++ wouldn't involve copying
03:37:58 <merijn> kuribas: You can already do that without copying with minor boilerplate...
03:38:05 <kuribas> merijn: how?
03:38:08 <merijn> kuribas: You can initialise a std::vector from a pointer, afaik
03:38:23 <kuribas> oh right, I didn't know...
03:38:40 <kuribas> that would be better
03:39:41 <merijn> hmm, no turns out I'm wrong
03:45:06 * hackagebot tweet-hs 0.6.1.3 – Command-line tool for twitter – https://hackage.haskell.org/package/tweet-hs
03:47:08 <systemfault> merijn: Initialize a std::vector from a pointer, of course you can
03:47:17 <merijn> systemfault: Only by copying
03:47:20 <merijn> systemfault: Not zero copy
03:47:24 <systemfault> Oh yeah, of course
03:47:26 <systemfault> Sorry
03:54:12 * hackagebot church-pair 0.1.0.0 – Church encoded pair – https://hackage.haskell.org/package/church-pair
04:10:08 <piyush-kurur> Phyx-: thanks for the help with raaz. I have merged your changes
04:13:01 <kuribas> How do I get "castPtr ptr :: Ptr a", given a type "Storable a => MyType a"?
04:13:25 <merijn> kuribas: Allocate one
04:13:28 <kuribas> ghc interpretes a as a fresh variable
04:13:32 <kuribas> merijn: I mean the type
04:13:49 <merijn> kuribas: Oh, sounds like classic lack of ScopedTypeVariables
04:14:02 <kuribas> merijn: So only with ScopedTypeVariables?
04:14:05 <geekosaur> or the forall
04:14:14 <tsahyt> you'll need to explicitly quantify it too
04:14:28 <merijn> kuribas: Yes, unless you can make GHC infer the right a
04:14:36 <geekosaur> kuribas, if it can't be inferred then yes, you need ScopedTypeVariables
04:14:44 <kuribas> hm ok
04:16:47 <merijn> Sometimes I wish Haskell had named arguments
04:17:38 <hanna> anonymous records? :p
04:18:09 <quchen> Yes, that’s also something Haskell does not have :-/
04:18:14 <hanna> but yes normally the haskell way of making named patterns is fooBar def{arg1 = val1, arg2 = val2}
04:18:59 <quchen> merijn: I’m sure you know the string-on-typelevel hack? foo :: (Int ::: "Age") -> Bool
04:18:59 <hanna> if only we could write fooBar{arg1 = val1, arg2 = val2} instead
04:19:00 <merijn> hanna: That's a lot of boilerplate when you only use them in a single place
04:19:19 <quchen> Where t ::: _ = t
04:19:25 <kuribas> hm I could do innertype :: MyType a -> a; innertype _ = undefined
04:20:56 <hanna> (castPtr :: MyType a -> Ptr a) myType
04:21:09 <hanna> or w/e
04:21:24 <hanna> castPtr . getMyPtr
04:21:30 <kuribas> hanna: oh, that's nice
04:22:00 <hanna> or use scopedtypevars :p
04:22:13 <kuribas> hanna: what about sizeOf?
04:22:40 <hanna> or you could define asTypeOf1 :: f a -> g a -> f a; x `asTypeOf1` _ = x
04:22:45 <hanna> castPtr ptr `asTypeOf` myType
04:22:48 <hanna> that probably reads the nicest
04:24:18 <kuribas> you mean `asTypeOf1` ?
04:24:21 <hanna> yeah
04:24:50 <hanna> for sizeOf.. idk; if you still want to avoid scopedtypevars you could do sizeOfPtr :: Ptr a -> Int; sizeOfPtr = sizeOf undefined
04:24:57 <hanna> but that requires undefined :D
04:25:14 <hanna> so there goes my mission of finding an idiomatic non-undefined haskell98 way of doing this
04:25:38 <hanna> sizeOf should really have been defined as sizeOf :: proxy a -> Int
04:25:44 <hanna> but warts will be warts
04:25:52 <kuribas> sizeOf x = 3 * sizeOf (inner x) where inner x :: MyType a -> a; inner = undefined
04:26:53 <kuribas> that doesn't evaluate x, does it?
04:28:14 <hanna> no
04:28:19 <hanna> sizeOf explicitly ignores its argument
04:30:43 <quchen> sizeof predates proxy
04:31:02 <quchen> I’m always surprised Proxy was discovered so late (or at least made its breakthrough so late)
04:32:46 <hanna> Some weird thought that was going through my head: with TypeApplications, could it theoretically be made possible to have expressions with variables in the context that don't show up in the body, i.e. Storable a => Int, and then to use this you have to specify it using `@`?
04:32:49 <hanna> sizeOf @In
04:32:51 <hanna> @Int 
04:32:51 <lambdabot> Maybe you meant: wn let
04:33:12 <hanna> but I guess that's probably too tricky: what is the type of sizeOf + sizeOf?
04:33:51 <hanna> although I guess that question has an answer ( (Storable a, Storable b) => Int ), there might be more complicated scenarios where it's not so clear
04:33:56 <quchen> hanna: I guess, yes. But proxy# has a similar role.
04:35:20 <hanna> I was just wondering if perhaps proxy# could be kept under the hood and we could live in a world where explicit type disambiguation and definitions like “class Storable a where sizeOf :: Int” are possible
04:36:00 <Saizan> hanna: i thought that was most of the point of explicit type disambiguation
04:38:36 <Phyx-> piyush-kurur: no problem :) sorry for the delay, last week was busy :)
04:38:40 <hanna> https://0x0.st/0UL.txt
04:38:42 <hanna> indeed
04:38:44 <hanna> this compiles
04:38:56 <hanna> but requires AllowAmbiguousTypes
04:39:45 <hanna> also using it from GHCi results in a panic :)
04:40:18 <hanna> actually not that
04:40:28 <hanna> “sdkfjkdsjfsdf @Int” also panics
04:40:44 <hanna> (I didn't actually have the module loaded)
04:40:53 <Philonous> Wouldn't it have to be pi (a :: Type) . Int ? The type parameter isn't actually irrelevant, is it?
04:42:24 <Saizan> Philonous: the information is actually in the Storable instance
04:42:29 <Philonous> Uh, maybe it is. 
04:42:30 <Philonous> Yeah
04:43:06 <hanna> ah
04:43:15 <hanna> AllowAmbiguousTypes exists to allow functions that would not be normally possible to call
04:43:21 <hanna> but in this case it's fine because we have TypeApplications
04:44:09 <hanna> ooh
04:44:18 <hanna> this actually *lets* you define classes like class Foo a where foo :: Int
04:44:32 <hanna> but you need AllowAmbiguousTypes for it as well
04:50:47 <ertes-w> hanna: woah, that's nice…  i didn't know you could do that
04:51:15 <ertes-w> sizeOf (undefined :: Int)  -- stupid
04:51:24 <ertes-w> sizeOf (Proxy :: Proxy Int)  -- inconvenient
04:51:33 <ertes-w> sizeOf @ Int  -- lovely!
04:51:51 <hanna> the one thing that *was* nice about sizeOf is that you could do `sizeOf x` when allocating storage for `x`
04:51:53 <hanna> or something
04:52:00 <hanna> but this also goes against what we expect sizeof() to do in other languages
04:52:16 <ertes-w> hanna: well, with Proxy you can still do that…  almost
04:52:19 <merijn> hanna: eh...no?
04:52:22 <ertes-w> sizeOf (pure x)
04:52:36 <hanna> ooh, of course Proxy is a trivial Applicative
04:52:51 <merijn> hanna: "double *foo = malloc(10 * sizeof *foo);"
04:53:00 <hanna> merijn: hmm, fair point
04:53:20 <merijn> hanna: In fact, sizeof on types is always a dumb idea in C/C++
04:54:27 <hanna> ertes-w: random thought: that ‘pure’ trick only works if sizeOf explicitly requests Proxy
04:54:36 <hanna> and also doesn't work for e.g. Proxy#
04:54:45 <hanna> because Applicative isn't defaultable to Proxy
04:55:31 <hanna> (and you also can't make Proxy# an applicative because it has kind VoidRep)
04:57:57 <hanna> merijn: you could argue that sizeOf on types is a bad idea in Haskell as well
04:58:00 <hanna> because it isn't statically checked
04:58:09 <merijn> true
04:58:11 <hanna> say you switch from Int to Int32 in a refactor
04:58:20 <hanna> oops, your code now crashes on some platforms
04:58:49 <merijn> With Int it already crashes on some platforms, so that's fine :p
04:58:50 <hanna> so in retrospect it's probably a good idea to keep Storable specifically as it is
04:58:54 <merijn> Well, depending on what you do with it :p
04:58:57 <hanna> but this trick applies to Proxy stuff
04:58:59 <hanna> which is abundant in general
05:00:17 <ertes-w> hanna: sizeOf (const x)
05:01:16 <hanna> ertes-w: I don't follow
05:02:22 <ertes-w> hanna: if sizeOf doesn't request Proxy specifically (e.g. (Storable a) => proxy a -> Int), then you can use 'const' instead of 'pure' to instantiate 'proxy'
05:02:48 <ertes-w> proxy = (->) a  -- for some 'a'
05:03:11 <hanna> oh, neat
05:03:17 <ertes-w> or even just:  sizeOf [x]
05:04:28 <merijn> Is there a glob expansion library for haskell somewhere?
05:05:08 <Clint> @hackage Glob
05:05:08 <lambdabot> http://hackage.haskell.org/package/Glob
05:05:15 <DollyDuplex> is there anything that does "do { x <- action1; y <- action2; return $ f x y }" for any given action1, action2, f?
05:06:17 <merijn> DollyDuplex: liftA2?
05:07:13 <DollyDuplex> aaaaah, ok, now i feel stupid
05:26:27 <yorick> anyone ever see basvandijk around here?
05:31:34 <codedmart> I am trying to use ViewPatterns https://gist.github.com/codedmart/4a1e375ec9c56f3c2d1bc0065bde5364#file-error
05:32:02 <dramforever> codedmart: you got it in reverse
05:32:08 <dramforever> should be toLower -> v
05:32:42 <codedmart> dramforever: OK thanks!
05:32:52 <codedmart> I feel like a dummy. I thought I tried that.
05:33:02 <dramforever> because:
05:33:05 <dramforever> :t toLower
05:33:07 <lambdabot> Char -> Char
05:33:08 <dramforever> :t map toLower
05:33:09 <lambdabot> [Char] -> [Char]
05:33:18 <dramforever> you're probably missing this too
05:34:18 * hackagebot data-diverse 0.6.0.0 – Extensible records and polymorphic variants. – https://hackage.haskell.org/package/data-diverse
05:35:55 <yorick> @seen basvandijk
05:35:55 <lambdabot> 8A5\/4NDijx
05:35:58 <yorick> thanks lambdabot
05:36:14 <yorick> I'll just email the guy
05:36:18 <Axman6> heh, corrected to @leet
05:39:50 <quchen> Bas isn’t much on IRC
05:39:56 <quchen> But you can surely mail him or something
05:40:02 <quchen> He’s still alive and well :-)
05:49:31 * hackagebot data-diverse-lens 0.1.0.0 – Isos & Lens for Data.Diverse.Many and Prisms for Data.Diverse.Which – https://hackage.haskell.org/package/data-diverse-lens
05:56:46 <riaqn> hello, what would be the best way to handle compact binary format? like IP/TCP header
05:57:05 <riaqn> I hope there is as little copying as possible.
05:59:00 <merijn> riaqn: Handle in what way? As in, parse it/generate it?
05:59:31 <Vulume> They should program fembots in Haskell
05:59:35 <Vulume> For type safe sex
05:59:45 <ventonegro> ...
05:59:59 <riaqn> merijn: like NAT..or something alike.
06:00:08 <Axman6> Data.Binary isn't a terrible place to start, but Erlang's bit syntax would make parsing much easier
06:00:08 <riaqn> network address translation.
06:00:26 <Axman6> o.O
06:00:47 <Axman6> merijn: well, we tried :\
06:06:13 <riaqn> merijn: ideas?
06:06:32 <merijn> riaqn: I have no idea what you mean by that answer, so, no?
06:06:34 <riaqn> Axman6: yeah, but this looks not quite good
06:07:12 <Axman6> riaqn: what do you want to do
06:07:35 <riaqn> Axman6: for one thing, Binary do things linearly, while sometimes I'm sure a field is say, from 16 bytes to 18 bytes.
06:07:39 <Axman6> "NAT" is an operating system level thing, so I don't understand your question
06:08:12 <riaqn> in which case I hope to utilize the lazy evluation, I mean, assign each field of some offset, and only read it when needed.
06:08:53 <Axman6> what types of data do you need to parse?
06:09:13 <riaqn> Axman6: basically, I will get lots of bytestring representing IP packet, and read some fields out of it, and reconstruct a packet with a lot of common with the old.
06:09:15 <Axman6> is it mostly going to be integer values? (IP addresses, ports)?
06:09:28 <riaqn> Axman6: yeah definitely.
06:09:48 <Axman6> anything else? do you need to check header flags?
06:10:01 <riaqn> Axman6: probably.
06:11:01 <Axman6> I wonder if you'll find what you need in https://hackage.haskell.org/package/openflow
06:11:13 <Axman6> (sadly the docs aren't there :\)
06:11:43 <Axman6> https://hackage.haskell.org/package/network-house also exists, but is quite old so may not compile without some work
06:12:29 <riaqn> Axman6: thanks. let me check.
06:13:41 <Axman6> riaqn: I would actually suggest that laziness isn't going to save you very much - parsing the whole packt using something like binary or attoparsec (or attoparsec's Zepto parser https://hackage.haskell.org/package/attoparsec-0.13.1.0/docs/Data-Attoparsec-Zepto.html) will result in faster code than trying to lazily evaluate each field only if you need it
06:15:42 <Axman6> laziness is only really an optimisation where the amount of work you don't do is large. 
06:15:48 <riaqn> Axman6: how about Storable? this looks low-level enough.
06:17:12 <Axman6> sure, but you have to be quite careful - Binary isn't much more than a safe wrapper over the sort of code you would write with storable
06:18:40 <riaqn> Axman6: yeah right. but at least I can now jump forth and back with offsets now.
06:19:31 <Axman6> sure, but parsing is basically just jumping forward too
06:19:51 <Axman6> IP wasn't exactly designed with the idea you would need to jump around a lot :)
06:27:58 * hackagebot Clipboard 2.3.2.0 – System clipboard interface. – https://hackage.haskell.org/package/Clipboard
06:46:39 <AWizzArd> What is the meaning of the pipe symbol `|` in a type signature? Example: class (Monoid w, MonadReader r m, MonadWriter w m, MonadState s m) => MonadRWS r w s m | m -> r, m -> w, m -> s
06:48:06 <merijn> AWizzArd: Functional Dependency
06:51:32 <L4rmbr> hi, I have a question. In monad transformer, why the monad m is not in the first arg position. For example, "newtype ReaderT r m a"  instead of "newtype ReaderT m r  a", actually I tried to write Monad for the latter one, and found it is also a good form
06:52:07 <lyxia> L4rmbr: you can't write a MonadTrans otherwise
06:53:05 <L4rmbr> lyxia, thanks for the answer, I haven't learned MonadTrans yet. 
06:53:08 <merijn> lyxia: Well, you could, it'd just be far less convenient to writ
06:53:36 <lyxia> merijn: What do you mean
06:54:28 <jchia_1> Style question about lens: When is it preferable to use view/set/over and when is it preferable to use their corresponding operators (^.), (.~), (%~)?
06:54:36 <AWizzArd> merijn: do you refer to this? https://wiki.haskell.org/Functional_dependencies
06:54:38 <merijn> lyxia: Oh, actually, you mean MonadTrans instances, yeah, you're right about that
06:54:53 <merijn> AWizzArd: Yes
06:56:19 <lyxia> L4rmbr: It's more consistent if you look at the order of type variables starting from the right, things work better that way with type classes.
06:57:52 <AWizzArd> merijn: okay thx
06:59:23 <L4rmbr> lyxia, thanks. Indeed, in ReaderT this order explanation holds, but in "newtype EitherT e m a = EitherT {runEitherT :: m (Either e a)}" this explanation seems does't sound convincing.
06:59:25 <lyxia> jchia_1: the ones with letters often look better when partially applied.
07:00:16 <lyxia> L4rmbr: why not? It always ends in kind (* -> *) -> (* -> *)
07:00:35 <lyxia> as expected of MonadTrans
07:00:59 <L4rmbr> lyxia, alright, I misunderstood your words. I got it. thanks
07:01:37 <lyxia> You're welcome!
07:04:04 <jchia_1> lyxia: Thanks
08:32:20 * hackagebot protocol-buffers-descriptor 2.4.2 – Text.DescriptorProto.Options and code generated from the Google Protocol Buffer… – https://hackage.haskell.org/package/protocol-buffers-descriptor
08:32:20 * hackagebot hprotoc 2.4.2 – Parse Google Protocol Buffer specifications – https://hackage.haskell.org/package/hprotoc
08:36:22 <synch1> join #c
08:36:28 <shapr> NO! Don't do it!
08:39:55 <synch1> exit
08:41:08 <shapr> synch1: you're back! we missed you!
08:41:15 <shapr> synch1: how's code?
08:42:13 <synch1> shapr: omg, I've just started using IRC and someone already greets me :D
08:42:31 <Clint> it's all downhill from here
08:42:53 <synch1> shapr: great, despite the fact that now I'm learning python
08:42:59 <shapr> synch1: oh, that's a good language to know
08:43:15 <shapr> I teach Python as well as Haskell.
08:43:39 <shapr> synch1: how'd you find out about Haskell?
08:44:31 <synch1> shapr: From yt video with Larry Wall that was called "The 5 languages you should now"
08:44:40 <synch1> or something like that :D
08:45:02 <synch1> Anyway, I'm more proficient in haskell than in python right now
08:46:01 <shapr> synch1: in my opinion, that's a good way to start, you'll have a good view on both the imperative and functional approaches to programming.
08:46:48 <crobbins> synch1: that is exactly how i heard about it too
08:47:23 <synch1> crobbins: wanna feel like a genius like me? :D
08:47:47 <shapr> what were the other languages mentioned in that video?
08:47:52 <shapr> synch1: are you coming from a Perl background?
08:48:11 <synch1> shapr: perl, C and JAva ofc :D
08:48:21 <ongy> that sounds painful
08:48:37 <synch1> shapr: no, I am a student with no professional background
08:48:57 <synch1> shapr: i've spent most time with c++, Java and C#
08:49:34 <synch1> I feel like I know a lot of languages but have no big use of it
08:49:52 <shapr> synch1: stretching your brain into other ways of programming is good, you get tools you can use in any language.
08:50:10 <synch1> shapr: is teaching your job or hobby?
08:50:58 <shapr> synch1: hobby only, I'd love to be a college professor, but I'd have to take a pay cut
08:51:54 <synch1> shapr: you're then working as a coder?
08:52:07 <shapr> yup, for a bunch of years
08:53:26 <shapr> synch1: it's great fun
08:53:30 <shapr> especially if you like both people and code
08:54:13 <synch1> shapr: I agree, I enjoy myself solving problems via coding
09:26:41 <synch1> how to scroll name list in weechat?
09:29:05 <lyxia> synch1: F11 goes up   F12 goes down
09:34:20 <trigone> hi, i just read this weird snippet in wikihaskell: https://pastebin.com/u8eXx96U ---- am i right to think there's no reason to write inc3 using >>= instead of >> ?
09:35:32 <monochrom> Right.
09:35:47 <trigone> oh nevermind. the snippet was apparently here specifically to say that it was not needed. still that was really not clear on first reading
09:36:13 <ReinH> inc3 = g1 >> g2 >> g3
09:37:41 <trigone> ReinH: yeah, what i thought
09:38:16 <ReinH> k >>= \x -> return x = k
09:38:21 <ReinH> @src (>>)
09:38:21 <lambdabot> m >> k = m >>= \_ -> k
09:38:31 <ReinH> by monad laws and definitions
09:40:45 <trigone> yeah
09:45:51 <trigone> for the reader monad, a monadic value of type Reader a b, is it appropriate to see "a" as a database-like thing to query, and "b" as the part that is specifically queried by the monadic value, although obviously it can be the result of some function taking the database as parameter
09:46:24 <Zemyla> trigone: That's how Haxl works.
09:46:59 <trigone> and asks f = ask >>= f ?
09:47:07 <trigone> @src asks
09:47:07 <lambdabot> asks f = do
09:47:07 <lambdabot>     r <- ask
09:47:07 <lambdabot>     return (f r)
09:47:16 <trigone> apparently
09:47:24 <trigone> Zemyla: what is Haxl?
09:49:18 <trigone> Zemyla: oh right i see. no, i spoke of databases in a metaphorical way, i was not asking if the Reader monad could be used for databases specifically
09:51:04 <trigone> the main difference with state monad is that the Reader's environment is not meant to be modified, correct?
09:52:14 <trigone> and therefore its use is to share common static data rather than, for the state monade, create the equivalent of a mutable state without too much variable juggling
09:56:26 <lyxia> yes
09:57:14 <trigone> i hear of inline-ing sometimes, and i wonder: since most if not all the code is always pure in haskell, how come everything is not systematically inlined? but then maybe i don't get the meaning of inline
09:57:24 <trigone> inlining
09:58:13 <cocreature> trigone: inlining is not always better. if you inline a big function in a lot of places you end up duplicating it very often and your code size gets gigantic
09:58:46 <trigone> cocreature: but does it harm the execution time then?
09:59:17 <cocreature> trigone: due to cache behavior memory usage and execution time are far from being independent of each other so it can definitely harm execution time
10:01:59 <lyxia> trigone: recursive functions are also tricky to inline
10:04:06 <ongy> let the compiler rewrite them into loops
10:06:58 <setrex> I think I need to make a function for discovering rss/atom feeds from a given URL. Which libraries could I use for fetching and scraping?
10:09:36 <ReinH> INLINE also prevents other optimizations to ensure any rules are fired.
10:10:05 <ReinH> GHC will automatically inline functions that are 'small enough'
10:10:15 <ReinH> trigone: ^
10:10:39 <pikajude> how small is small enough?
10:11:15 <ReinH> GHC uses heuristics to determine small enough
10:11:43 <dolio> I think it depends on other factors, too.
10:11:46 <ReinH> "GHC has a set of heuristics, tuned over a long period of time using many benchmarks, that decide when it is beneficial to inline a function at its call site."
10:11:59 <ReinH> It also won't inline functions when there is no benefit
10:12:06 <dolio> Like, if your function is called only once.
10:12:07 <johnw> I have a case where using inline on a very small function doubles my runtime
10:12:10 <ReinH> The docs spell this all out https://downloads.haskell.org/~ghc/7.10.3/docs/html/users_guide/pragmas.html
10:12:28 <johnw> and where not using it on another function in the same file hurts
10:13:06 <johnw> https://github.com/jwiegley/category-theory/blob/master/Theory/Metacategory/ObjectsArrows.hs#L18
10:13:24 <ReinH> inlined functions also will not be worker/wrapper transformed by strictness analysis
10:13:26 <johnw> in this file, `step` needs to be marked INLINE; if I mark the `go` sub-function of composablePairsStep, it really hurts performance
10:14:19 <dolio> Oh, well, go is a recursive function.
10:14:37 <johnw> ah! that makes sense
10:14:40 <dolio> Marking those inline is weird.
10:14:55 <johnw> wait, not the first go
10:14:57 <johnw> the second go
10:15:03 <johnw> line 33 go
10:15:33 <johnw> which profiling says 99% of my allocations are assigned to
10:15:35 <ReinH> I would expect INLINE on the recursive go to not do anything
10:15:45 <ReinH> since the loop breaker should hit it
10:16:59 <dolio> ReinH: That's not what used to happen, at least.
10:17:22 <ReinH> "For example, for a self-recursive function, the loop breaker can only be the function itself, so an INLINE pragma is always ignored."
10:17:25 <dolio> GHC would do some weird transformation where it partially inlined a recursive function into itself.
10:17:37 <ReinH> So the loop breaker only fires at some depth?
10:17:48 <ReinH> That's... not what the docs imply
10:18:05 <dolio> I haven't looked at it in a while. It may have changed since I did.
10:18:24 <ReinH> Ah, perhaps.
10:18:55 <Ke> main = fmap (L.concatMap mapper) (L.getContents) >>= L.putStr why does this give me unreasonable cpu time in kernel
10:19:08 <Ke> L is Data.ByteString.Lazy
10:19:41 <dolio> johnw: I'm not sure the second go is actually small.
10:19:43 <Ke> I guess it's reading byte per byte, any better ByteStrings for this
10:19:45 <Ke> ?
10:20:16 <dolio> If step is inlined.
10:20:50 <johnw> dolio: go point; the output from ghc-core shows composablePairStep to be a larger function than what it appears there
10:20:52 <johnw> good*
10:21:13 <johnw> ooh, changing triangularNumber to shiftR (shiftL n 1 + n) 1 gains another 10%
10:21:26 <bartavelle> is there a way to find the modules on hackage that reexport a given function from another module ?
10:22:23 <johnw> but.. doesn't mean the same :)
10:24:02 <lambdamu_> How can I convince GHC this is ok: http://lpaste.net/356726
10:25:02 <lambdamu_> Help greatly appreciated, everytime I want to use types in earnest something like this happens
10:25:22 <ReinH> johnw: I wonder if there aren't some tricks in hacker's delight that might be of use to you.
10:25:54 <lyxia> lambdamu_: it's theoretically correct but still non-trivial to prove.
10:26:17 <ReinH> johnw: oh, well, in that case you can also replace it with const 0 for what I imagine would be a much larger speed improvement. ;)
10:26:27 <eklavya> hi, I was reading the hexagonal and free monad post shared on reddit
10:26:43 <eklavya> how does one handle errors in a free monad interpreter
10:26:56 <lambdamu_> Yeah but what is in general the process to prove something to GHC? In coq one can write tactics for example, but with GHC I have no clue
10:26:58 <ReinH> eklavya: link to the post?
10:27:02 <eklavya> I mean you could be in a different interpreter
10:27:10 <eklavya> ReinH: https://deque.blog/2017/07/06/hexagonal-architecture-a-less-declarative-free-monad/
10:27:13 <lambdamu_> lyxia: directed to you
10:27:56 <eklavya> I think it's the most aporachable post on free monads for haskell that I have seen :)
10:28:34 <ReinH> eklavya: there are different sorts of errors
10:28:38 <eklavya> approachable*
10:29:10 <ReinH> Your interpreter could incorporate MonadError and/or MonadCatch to catch runtime errors.
10:29:18 <eklavya> ReinH: I mean to ask what if I need to make a decision based on the outcome of a previous step (if it failed or not)
10:29:28 <ReinH> You get to decide on m, so m can incorporate error handling
10:29:32 <eklavya> interpreter is just command -> effect
10:29:53 <ReinH> interpreter is a monad morphism from your free monad to some concrete monad
10:30:06 <ReinH> that concrete monad can be whatever you want, so it can incorporate error handling as you choose.
10:30:50 <eklavya> sorry if it seems obvious but I mean the interpreter is only concerned with interpreting a command regardless of what happened to the last one
10:30:55 <eklavya> so do I introduce state?
10:30:58 <eklavya> or what
10:31:04 <ReinH> interpret :: MonadError YourError m => Free FooF a -> m a
10:31:25 <ReinH> Maybe you're using a different definition of 'interpreter' than I am.
10:31:45 <eklavya> umm
10:31:49 <eklavya> I just realized
10:31:52 <eklavya> I was being stupid
10:31:53 <eklavya> :P
10:31:57 <eklavya> it's simple
10:32:00 <lyxia> lambdamu_: you can use the type Data.Type.Equality.(:~:) for equality proofs, and implement them in a type class.
10:32:03 <eklavya> it would work the same way
10:32:14 <ReinH> eklavya: http://aaronlevin.ca/post/122079863187/reasoning-about-errors-in-free-monads-and-their
10:32:25 <ReinH> Apologies for the awful code formatting, it isn't my blog
10:32:32 <eklavya> if I am expecting an error I would return an Either and how that is produces is irrelevant here
10:32:44 <eklavya> produced*
10:33:20 <eklavya> I can still talk in terms of the result without actually getting it
10:34:20 <eklavya> ReinH: thanks :)
10:35:52 <trigone> hi, how am i supposed to read a monad stack in terms of semantics?
10:36:53 <lambdamu_> lyxia: I tried that once, but it is worth a shot, but really useful it's only in combination with singletons, right?
10:37:03 <pikajude> "see?? it's equal! i told you!"
10:37:06 <pikajude> equality proofs
10:39:00 <nshepperd_> If that doesn't work, you can make a type checker plugin that creates the right equalities on demand
10:39:52 <nshepperd_> Assumptions, rather than proofs though
10:42:53 <lyxia> lambdamu_: it doesn't have to be with singletons
10:47:16 <trigone> asking just in case: is there no way to create tags to mark a discussion inside a channel, like we tag messages with usernames?
10:47:54 <Athas> trigone: not on IRC, no.
10:48:19 <shapr> trigone: but there are other quieter Haskell channels for longer discussions
10:48:29 <shapr> such as #haskell-overflow and #haskell-in-depth
10:48:36 <Athas> Or you can just create a new channel whenever you want!
10:48:41 <shapr> that too!
10:51:59 <trigone> shapr: yeah, but it was just an informal notion of discussion, not a very large topic
10:53:13 <trigone> like poof someone asks a question, creating a tag on the spot, and until someone thinks it spawned some new discussion, the tag is used by everyone who contributes to the exchange. i'm thinking it'd be useful for filtering and stuff. a bit like ephemereal, one-use channels
10:54:21 <lambdamu_> Ok so very target use of unsafeCoerce makes it work, I could get used to that
10:56:22 <ReinH> trigone: You just have to know how transformers compose wrt semantics, e.g., what happens when StateT is outside of ExceptT and vice versa.
10:56:59 <ReinH> trigone: Slack has tried that with threads. It has had... mixed success.
10:57:19 <ReinH> Probably would be useful for that exact use case, but generally it just fragments the discussion.
10:59:07 <Athas> trigone: usually, you just address your message to the other participants in the conversation.
10:59:07 <trigone> ReinH: yeah i can imagine if it transforms everything into twitter
10:59:31 <monochrom> IRC discussions are short-lived. 99.9% lasts for 10 minutes or less. 100% lasts for under 2 hours. The value of tagging is diminished.
10:59:34 <Athas> I like the conceptual simplicity of IRC.  It scales better than one might expect, too.  It's only in the largest channels that activity sometimes makes it hard to keep track of a conversation.
10:59:43 <ReinH> the problem is that it removes replies from the flow of conversation so you have to actually go look for them.
11:00:01 <acowley> Is there a nice way of using stackage on Travis? The stackage docs talk about a nice future with apt packages, and links to issue where the last comment is that the apt repos are deprecated.
11:00:02 <Athas> Of course, it probably helps that even a huge IRC channel has at most few hundred members.
11:00:13 <trigone> ReinH: depends if you can't have more than one filtering on the same IRC
11:00:18 <Athas> acowley: depends on "nice".  There is a shell script you can use that sets up everything.
11:00:25 <acowley> My current thing just curls the cabal.config files and uses cabal-install.
11:00:30 <monochrom> OTOH nothing stops you from creating your own tagging convention.
11:00:57 <acowley> Athas: does that support multiple GHC testing, too?
11:00:59 <Athas> acowley: look at mine for an example; it also shows how to use several different snapshots: https://github.com/HIPERFIT/futhark/blob/master/.travis.yml
11:01:02 <Athas> Yes.
11:01:22 <Athas> I copied my setup from somewhere else (although I remember simplifying it a little), so I can't claim credit.
11:01:28 <lyxia> lambdamu_: http://lpaste.net/356728 here's what a proof looks like in Haskell, though it's actually not very useful since you incur a constraint anyway. It's not much better than simply adding the constraint and letting it be proved at every specialization http://lpaste.net/356729
11:01:39 <acowley> Athas: Thank you, that looks pretty reasonable!
11:02:01 <trigone> ReinH: or it could change color automatically based on the conversations still active. as said most conversations don't last and can be erased automatically after a short timeout
11:02:07 <Athas> acowley: remember this script too: https://github.com/HIPERFIT/futhark/blob/master/.travis-setup.sh
11:02:25 <Athas> It's what does the work.
11:02:45 <trigone> what is #haskell-indepth bythe way?
11:03:07 <lambdamu_> lyxia: Wow thanks, I'm gonna study that
11:42:40 <clamchowder> Hello. I just installed stack for the first time and have run into some problems.
11:43:44 <clamchowder> I want to test pandoc code. So I went into the pandoc dir and executed: stack install; stack setup; stack build
11:44:00 <jbaum98> hi, i'm trying to implement a fisher yates shuffle using monadrandom and vector. i had to use a tweaked version of modify so i could get out the generator, and i want to make sure that it still works where it clones if necessary but reuses the same vector if it can. can someone explain how that works and how i can test/make sure that it's working for my code?
11:44:04 <jbaum98> https://gist.github.com/jbaum98/9de8966debaf21e51fb3a9bf9c6d81a0
11:44:24 <clamchowder> pandoc is working, but I can't load any .hs files in the pandoc source.
11:45:55 <clamchowder> the errors are "Failed to load interfaces for [Module name]". http://lpaste.net/4496309001989914624
11:46:34 <clamchowder> Oh btw I tried to load the files with ghci.
11:46:41 <geekosaur> use 'stack ghci'
11:46:52 <geekosaur> ghc/ghci does not know about sandboxes
11:48:33 <clamchowder> geekosaur: thanks that works. Is there any faster way? It compiled 22 modules Markdown.hs (the file I try to load) depends on
11:49:10 <clamchowder> so every time I stack ghci I have to wait for the compiling
11:49:29 <geekosaur> I don't know, it may be forcing bytecode compile in which case there is no way to save the result and it'll have to redo it every time
11:50:07 <clamchowder> when I used cabal, I could `cabal install` in the pandoc dir and then ghci was fast
11:50:55 <clamchowder> cabal didn't have to compile the dependencies first. Is there a way to install the dependencies with stack?
11:51:29 <clamchowder> I tried `stack install` but it did not seem to work the same way as cabal install
11:52:28 <clamchowder> it simply copied the pandoc binary to ~/.local/bin
11:55:00 <geekosaur> two differences (1) you were not using a sandbox (2) as I understand it, stack ghci assumes you will want to do general debugging and forces bytecode load for all modules
11:55:35 <geekosaur> (you can't, for example, set breakpoints in a native-compiled module, you would need to exit ghci and re-enter it forcing bytecode compile for the module)
11:56:30 <geekosaur> possibly using 'stack exec ghci' will avoid bytecode-loading, but again you would have only limited abilities
11:57:55 <clamchowder> geekosaur: so every time I make a change to markdown.hs and nothing else, to test the change interactively I'll have to wait for the 22 modules to compile?
11:58:43 <clamchowder> geekosaur: even though I didn't change any of those 22 modules
12:00:10 <geekosaur> if you don't need to touch those, 'stack exec ghci Markdown.hs' and hope the dependencies don't force everything else to be compiled anyway. if it does, then yes you would have to wait regardless
12:00:45 <geekosaur> you could possibly speed it up a bit though: stack ghci -- +RTS -A128m
12:01:30 <clamchowder> geekosaur: OK thanks! I tried `stack exec ghci Markdown.hs` and it seems to work the same way as `ghci` when I used cabal-install :)
12:11:21 <wrengr> dmwit: hrm... I thought the c.h.o email was still working. I do need to update the c.h.o page anyways though. In any case, you can send patches to https://github.com/wrengr/logfloat
12:17:33 <jbaum98> can someone explain to me how Data.Vector.modify safely modifies in place when possible and creates a new vector when necessary?
12:31:45 <Cale> jbaum98: Various RULES pragmas in Data.Vector.Generic which eliminate occurrences of 'new'
12:45:19 * hackagebot astro 0.4.2.0 – Amateur astronomical computations – https://hackage.haskell.org/package/astro
12:50:54 <c_wraith> jbaum98, don't think of it as modifying in place so much as fusing modification and allocation passes together. 
12:53:26 <jbaum98> c_wraith: can you elaborate? Is the mechanism the rewrite rules?
12:53:46 <jbaum98> c_wraith: I thought you don't allocate new memory with modfy 
12:55:51 <c_wraith> jbaum98, it is via RULES pragmas, yes. and the specific allocation I was talking about was the original creation of the vector
12:56:56 <c_wraith> jbaum98, but once the vector is realized, it is truly immutable. the rules allow deferring that so that modifications can be fused in. 
12:57:36 <jbaum98> c_wraith: ahhh. So what exactly forces the vector to be realized, and how do the RULES relate to that 
12:58:46 <jared-w> RULES are just plain text rewrites, aren't they?
12:59:22 <jbaum98> c_wraith: and which specific rules are at work with modify? Will they still work with the tweaked modify in my code? https://gist.github.com/jbaum98/9de8966debaf21e51fb3a9bf9c6d81a0
13:00:02 <monochrom> I don't think RULES are plain text rewrites.
13:04:53 <c_wraith> jbaum98, the rewrite rules for vector are incredibly complex. I understand the concept of what they do, but the details involve 4 different intermediate representations, iirc. 
13:06:21 <c_wraith> jbaum98, I can tell you that a vector will be realized when you use an operation on it that isn't marked as subject to fusion, or when the combination of simplifying, inlining, and rewriting gives up in the optimizer. 
13:07:21 <monochrom> Yikes, 4 representations.
13:09:08 <c_wraith> something about each different representation making some kinds of operations fuse. 
13:10:10 <dolio> Not necessarily making them fuse, but allowing more efficient fusion.
13:10:35 <c_wraith> ah, that is better wording 
13:10:50 <dolio> A simpler example I know of glguy came up with.
13:11:19 <dolio> You can use `data CoYo f a = forall e. CoYo (e -> a) (f e)` to fuse your fmaps.
13:11:55 <dolio> But, if you use it, you always at least fmap once, even when you don't fuse anything.
13:12:04 <dolio> Because you fmap with the identity.
13:12:38 <dolio> So, instead, you can use `data Fused f a = forall e. Fused (f a) (e -> a) (f e)`.
13:13:56 <dolio> Where you inject with `\x -> Fused x id x` and `fmap g (Fused _ f y) = Fused (fmap (g . f) y) (g . f) y`
13:14:11 <dolio> And `extract (Fused y _ _) = y`
13:14:20 <jared-w> monochrom: the types have to match, but in the semantics part of https://downloads.haskell.org/~ghc/7.0.1/docs/html/users_guide/rewrite-rules.html it basically just says "it replaces the LHS with the RHS whenever it finds an appropriate match"
13:14:54 <monochrom> "From vector to coyoneda to fused to cofused to very confused to nothing at last"
13:15:44 <monochrom> Yeah but I feel that the rewrite is on expression subtrees rather than text.
13:16:04 <dolio> Yeah.
13:16:04 <jbaum98> So how can I wrote my tweaked modify so that it still works with fusion
13:16:10 <c_wraith> jared-w, there is a bit more to it than that.. for one, it runs on core rather than text, and it runs after inlining and simplification. (and before them, and phases come into play..) 
13:16:11 <monochrom> For example it is not like you can cross parentheses boundaries.
13:16:40 <dolio> Also you can have variables that match arbitrary subexpressions.
13:16:50 <dolio> Not exactly the variables as text.
13:17:16 <jared-w> right... text was a bad choice of phrasing :p
13:17:21 <jared-w> that makes more sense
13:18:07 <monochrom> "structured text" is maybe a good middleground between precision and human-friendliness. (Stupid humans who can't grok trees.)
13:18:44 <jared-w> lol, fair enough. I was mentally thinking expression trees anyway
13:19:25 <c_wraith> jbaum98, that certainly won't work with the fusion framework. 
13:19:43 <c_wraith> jbaum98, among other things, it's recursive. 
13:20:22 <monochrom> (I have just cause for the latter. When civilization transitioned from Usenet to web forums, what you see evidently is the loss of tree literacy, i.e., Usenet people were comfortable with a thread being a tree, web forum people couldn't even imagine it. It took some 20 years, until Reddit appeared, for people to rediscover trees.)
13:20:26 <jared-w> The reason foldr fuses so nicely is because it's "recursive" but gets rewritten into a non recursive form. It's actually more expensive to use foldr over naive recursion if the optimizations don't fire
13:21:33 * monochrom commences writing a new sociology book, "The New Internet Dark Age".
13:21:44 <c_wraith> jbaum98, that's complex enough that if you wanted it to fuse, you'd have to rewrite it entirely in terms of the fusion primitives. 
13:22:05 <c_wraith> jbaum98, I'd personally not bother. :) 
13:22:10 <orion> monochrom: What about top posting?
13:22:25 <jbaum98> c_wraith: how would I go about that 
13:23:00 <c_wraith> jbaum98, study everything in Data.Vector.Fusion
13:23:14 <c_wraith> good luck! 
13:23:18 <jbaum98> c_wraith: I need to rewrite modify so I can get out the modified random generator
13:23:18 <jared-w> learn the ways of the fusion wizard
13:23:23 <dolio> modify will never fuse.
13:23:38 <jbaum98> dolio: why not I thought that's the whole point?
13:23:49 <andromeda-galaxy> What's the equivalen tof doing n <- newName "x"; LamE [VarP n] <$> somexepr n for typed expressions?
13:23:52 <jbaum98> dolio: that it doesn't reallocate
13:23:56 <dolio> The point of modify is to run an arbitrary function on a mutable vector to get a new immutable vector.
13:24:07 <dolio> And fusion does all kinds of stuff in terms of streams.
13:24:15 <dolio> Which are not mutable vectors at all.
13:24:36 <jared-w> So it seems like his modify is, by principle, not fusable?
13:25:06 <jbaum98> dolio: I thought modify let's you run in place modifications without copying 
13:25:12 <dolio> The allocation avoidance of modify is separate from the stream fusion.
13:26:05 <dolio> modify is so that when you create an immutable vector via producing a mutable one that you freeze, and then modify it, you can instead run an operation on the mutable vector before freezing it the first time.
13:26:52 <dolio> So it is a separate mechanism from all the stream fusion stuff, although I suppose they can interact at the edges.
13:26:59 <cocreature> so the “when it is safe to do so” only refers to that specific case and there is no black magic for detecting that there is only one reference to the vector and thereby inplace modification is safe?
13:27:51 <jared-w> that black magic would probably just be linear types, wouldn't it?
13:28:14 <dolio> Yeah. The rule is something like `modify f (new e) = new (do v <- e ; f v ; return v)`
13:28:28 <dolio> Probably not exactly that, but something similar.
13:29:14 <cocreature> jared-w: well then you need to explicitely specify it in the type. I was thinking of some GC internal magic which dynamically checks how many references there are to that vector
13:29:44 <jared-w> Rust's borrow checker? :p
13:30:15 <cocreature> that would still require you to statically enforce that there is only one reference instead of checking for that dynamically
13:31:31 <jared-w> Right. I don't think there's a way to dynamically and magically check? Or if it is, I've never seen it mentioned
13:32:12 <dolio> Certainly vector does not make queries like that, if GHC would even know.
13:32:24 <dolio> I think it probably wouldn't.
13:32:52 <cocreature> dolio: why not? the gc needs to figure out what references exist, no?
13:33:43 <cocreature> the query would probably be more expensive than just copying the vector but it seems like it should be possible
13:34:29 <dolio> If answering the question requires a GC crawl, I think it's probably worthless.
13:34:58 <dolio> You could keep track of the information, but that's overhead, and you'd need some story where it's worthwhile.
13:35:01 <cocreature> yeah I’m only thinking about whether it would be possible, whether it’s worth doing is another question :)
13:35:07 <dolio> Which I've heard, but I don't think GHC does it.
13:36:07 * hackagebot project-m36 0.1 – Relational Algebra Engine – https://hackage.haskell.org/package/project-m36
13:43:53 <booo> hi
13:43:56 <jbaum98> How can I check if fusion is happening or that allocation isn't happening 
13:44:08 <jbaum98> So that I can try stuff and see if it is working or not
13:47:25 <crobbins> jbaum98: -ddump-simpl
13:47:26 <crobbins> ;)
13:47:48 <crobbins> works in ghci also
13:47:53 <crobbins> :set -ddump-simpl
13:48:23 <crobbins> then for each expression you enter, it'll dump the core
13:50:46 <Tuplanolla> I'll dump your core in an undisclosed location for cheap.
13:52:19 <geekosaur> but fusion doesn't generally happen in ghci
13:54:08 <monochrom> m36 looks very nice.
13:54:55 <milo_> Hi, I'm sort of new to Haskell! Gonna type out a couple-line question.
13:55:49 <jbaum98> crobbins: what should I look for in the dump
13:56:54 <milo_> Is there a way to "specialize" (?) a type? Like say I have a function that returns an Either String Int, can I have it return a "EvalResult" which still means Either String Int but won't fit into other places I use Either String Int?
13:57:33 <Athas> milo_: this is what you usually use newtype for (but it's not fully transparent).
13:58:27 <milo_> Oh - so `type` creates an alias but `newtype` creates a really "different" type. Is that right?
13:58:36 <lyxia> yes
13:58:44 <milo_> Thanks!
13:58:56 <jared-w> and then newtype is unboxed at runtime so it incurs no performance penalty
13:59:19 <MitchellSalad> if it was unboxed at runtime it'd have a performance penalty ;)
13:59:33 <jared-w> durr, I meant compile time :p
13:59:52 <Tuplanolla> One could argue that with pedantry, too.
14:00:58 <jared-w> Just out of the sake of humoring the pedant... How would that argument go?
14:01:19 <Tuplanolla> Take a look at `.#` and `#.`.
14:01:51 <Tuplanolla> They're either in `lens` or `profunctors`.
14:02:40 <jared-w> Mentioning lens as a corner case is practically cheating, though
14:03:00 <MitchellSalad> what about those operators?
14:04:13 <jared-w> "Strictly map the first argument argument contravariantly with a function that is assumed operationally to be a cast, such as a newtype constructor." From Profunctor
14:04:37 <jared-w> That's for .#  for #. it's the second argument
14:05:04 <jared-w> Both are unsafe
14:05:11 <MitchellSalad> eh? yeah but what about them?
14:05:33 <lyxia> I also don't understand why they were brought up
14:05:37 <jared-w> I said "newtypes are unboxed at compile time and incur no performance penalty"
14:05:44 <MitchellSalad> that's true!
14:06:18 <MitchellSalad> still 'map MyNewtype' is not free
14:06:23 <jared-w> Tuplanolla countered with `.#` works only on functions that are casts such as newtypes
14:06:46 <Tuplanolla> They're there so that compositions of wrapping or unwrapping representationally equal types don't incur an extra lambda.
14:06:53 <jared-w> only on functions that are assumed operationally to be a cast, eg a newtype constructor** (for more pendant points)
14:07:51 <jared-w> if map MyNewtype is not free then newtypes aren't 100% unboxed at compile time :p
14:08:17 <monochrom> People seldom make 100%-correct assertions.
14:08:31 <Tuplanolla> If you have `Slurp . f . unSlurp`, inlining `.` would put lambdas in there, while inlining `.#` and `#.` would just ignore the useless slurp functions.
14:09:31 * hackagebot pdf-slave-server 0.1.2.0 – Web service for pdf-slave tool – https://hackage.haskell.org/package/pdf-slave-server
14:09:31 * hackagebot propellor 4.3.1 – property-based host configuration management in haskell – https://hackage.haskell.org/package/propellor
14:12:37 <MitchellSalad> there is a 'map coerce = coerce' rewrite rule
14:12:47 <MitchellSalad> i suppose 'map MyNewtype' is free then, sometimes. or something.
14:12:58 <Tuplanolla> That's why, if you look inside `lens`, you'll find `re p = to (runIdentity #. unTagged #. p .# Tagged .# Identity)` for example.
14:20:22 <MitchellSalad> is it safe to unsafeCoerce# from Int to Word8?
14:20:36 <Tuplanolla> Probably not.
14:21:32 <hpc> there is very little that's safe to do with an unsafe function
14:21:38 <hpc> particularly unsafeCoerce
14:21:46 <shapr> unsafeSegFault
14:22:02 <glguy> MitchellSalad: It's compiler-specific what you're allowed to do with unsafeCoerce. For GHC those restrictions are documented here http://hackage.haskell.org/package/ghc-prim-0.5.0.0/docs/GHC-Prim.html#v:unsafeCoerce-35-
14:22:09 <MitchellSalad> according to ghc-prim, Int# always has the same number of bits as Word#
14:23:23 <hpc> and if you read the docs for unsafeCoerce: https://hackage.haskell.org/package/base-4.9.1.0/docs/src/Unsafe.Coerce.html#unsafeCoerce
14:23:44 <lyxia> It's never safe to unsafeCoerce between different data types
14:23:44 <hpc> the comparison makes unsafeCoerce look downright sane
14:25:32 <crobbins> jbaum98: do you have an example? i'm no expert with core, but usually if you squint it'll make some level of sense
14:27:23 <jbaum98> crobbins: not really, I'll take a look when I can. I just want to know what fused vs unfused looks like so I can know when I've gotten it right 
14:29:57 <XorSwap> is there a list somewhere of all the unsafeX functions?
14:31:45 <crobbins> XorSwap: https://www.haskell.org/hoogle/?hoogle=unsafe
14:31:59 <crobbins> we need a lmhtfy
14:32:35 <glguy> http://hackage.haskell.org/package/base-4.9.1.0/docs/doc-index-U.html
14:33:59 <XorSwap> huh, I didn't know hoogle was that good
14:35:15 <haski> hi all, i'm developing the newton function in haskell, but i'm getting a "stack overflow" exception and i don't know how to solve it .. can someone help me? ;)
14:35:52 <crobbins> i think you
14:35:58 <crobbins> are not allowed to ask a question
14:36:01 <crobbins> about asking a question
14:36:15 <haski> hu?!
14:36:20 <c_wraith> stack overflow? what compiler or interpreter are you using? 
14:36:27 <haski> ghci
14:36:33 <c_wraith> version? 
14:36:57 <crobbins> haski: jk, feel free to paste links to code snippets that reproduce your problem
14:37:02 <haski> i think the latest version, 8.0.1 (?)
14:37:02 <crobbins> gist.github.com is a good one
14:37:20 <haski> https://thepasteb.in/p/GZhWXr4zODVCV
14:37:34 <c_wraith> that's weird. I thought stack overflows were removed a long time ago. 
14:38:09 <haski> i posted the link above. ghci version 8.0.2-a
14:39:09 * hackagebot propellor 4.3.2 – property-based host configuration management in haskell – https://hackage.haskell.org/package/propellor
14:39:24 <lyxia> haski: what input are you using
14:40:33 <lyxia> the second argument of the pow function is a Float
14:40:51 <lyxia> so if it is, for instance, 0.1, then you get an infinite loop.
14:41:06 <haski> lyxia to run the newton function call "newton (Add(Monom(2,3), Monom(3,4))) (-2) 0.001"
14:41:40 <haski> i only use integers to call that method
14:41:45 <lyxia> > let pow :: Float -> Float -> Float ; pow x 0 = 1 ; pow x n = x * pow x (n-1) in pow 2 0.1 
14:41:47 <lambdabot>  *Exception: stack overflow
14:42:02 <crobbins> haski: btw, you don't need to do `data Term = Monom(Float,Float) | ...`, the (Float,Float) is constructing a tuple; instead you can do `data Term = Monom Float FLoat | Add Term Term | ...`
14:43:14 <haski> yeah, but that shouldn't be the reason for stack overflow
14:43:41 <geekosaur> and you could save on rebuilding values by using as-patterns in e.g. eval (Add(Monom(a,b), Monom(c,d))) x =  (eval (Monom(a,b)) x) + (eval (Monom(c,d)) x)
14:44:44 <geekosaur> eval (aa@Add(Monom(a,b)), bb@(Monom(c,d)))) x =  (eval aa x) + (eval bb x)
14:45:09 <geekosaur> er, wait
14:45:10 <lyxia> haski: pow b x  <- which is supposed to be the integer
14:45:33 <geekosaur> eval Add(aa@Monom(a,b)), bb@(Monom(c,d)))) x =  (eval aa x) + (eval bb x)
14:45:56 <geekosaur> and then you can use wildcards in place of a, b, c, d since they're otherwise unused
14:46:01 <lyxia> haski: if one argument is supposed to be an integer it is better to pick an integral type for it to avoid mistakes.
14:46:23 <jared-w> Your pow function takes two floats and returns a float, so a simple recursive solution won't work as you can't guarantee n-1 will reach 0
14:46:58 <haski> lyxia: yes, would make sense, but i know these "problems", but i would like to solve the stackoverflow problem at first
14:47:18 <haski> i spent at lot of time but got no solution -.-
14:47:34 <jared-w> Your stack overflow is being caused because the power function skips zero and goes down to negative infinty
14:48:07 <lyxia> haski: pow b x  <- which one is supposed to be the integer?
14:48:25 <geekosaur> welcome to floating point
14:48:34 <haski> lyxia both of them are integer values
14:49:13 <haski> jared-w in case of i call pow 10 1, i'll get the result 10.0 -> it works ?!
14:49:24 <geekosaur> sometimes
14:49:27 <jared-w> 1 - 1 = 0
14:49:44 <jared-w> pow 10 0.9. First call triggers 10 * pow x (0.9-1)
14:50:05 <jared-w> 0.9-1 = -.1 so you skipped zero and you'll keep happily going down forever and ever
14:51:19 <haski> ok guys, i got your point, but in case of i call newton like "newton (Add(Monom(2,3), Monom(3,4))) (-2) 0.001", i don't have a "pow 1 0.1" oder similiar values
14:51:39 <jared-w> A temporary solution would be to use guards check for n <= 0 instead of just n == 0
14:51:43 <lyxia> haski: how can you trust that you didn't put a non-integer value at the wrong place while you are stuck with this bug
14:53:01 <haski> i'll be the only guy who will use this code for now ;) so i would like to fix the stackoverflow-bug and afterwards all other critical codes
14:53:09 <jared-w> A better solution would be to learn how to do floating point exponentials correctly
14:54:07 <jared-w> haski: The large point people are trying to make here is that you have code which is blatently wrong in certain points and that /will/ cause stackoverflow issues if used incorrectly. You are insisting that this code is not the problem and are trying to find some other solution rather than fixing this code and seeing if that fixes anything else
14:54:50 <lyxia> haski: what's the solution you are supposed to reach here
14:54:55 <jared-w> It's like saying "well my front door is broken and all the locks in my house don't work. Does anyone know how to repair my security camera system? I wanna prevent people from robbing my stuff"
14:55:42 <haski> so, sorry guys, i didn't understood how critical this problem is.. ;)
14:55:45 <monochrom> Relocate your stuff to a Swiss bank. Jason Bourne did this.
14:58:11 <jared-w> That's because you're trying to write physics quality code in a language that expects CS quality code /s
14:58:36 <lyxia> haski: pow also loops if x is negative.
14:58:42 <lyxia> haski: (-2) is negative.
14:59:55 <jared-w> Anyway, is there some reason you can't just use the normal exponent function in haskell?
15:00:51 <ReinH> Your function will throw a runtime exception on something like 99.999% of possible inputs.
15:01:02 <ReinH> That's how critical the problem is.
15:01:32 <haski> and the problem is based on the exponentiation?
15:01:33 <ReinH> I might be underestimating that by a few orders of magnitude
15:01:53 <ReinH> the problem is based on assuming a Double will be a positive integer.
15:02:12 <ReinH> The vast majority of Double values are not positive integers.
15:03:12 * hackagebot eventstore 0.15.0.0 – EventStore TCP Client – https://hackage.haskell.org/package/eventstore
15:03:18 <ReinH> It's like I wrote a function that takes a string but only works on strings that only works if the string contains only a's.
15:03:28 <ReinH> s/but only works on strings//
15:03:49 <monochrom> Where is your pow used?
15:04:27 <haski> in eval function
15:05:48 <monochrom> What actual input do you use to get errors or stack overflows or whatever problem you have?
15:07:03 <jared-w> "newton (Add(Monom(2,3),Monom(3,4))) (-2) 0.001"   was mentioned earlier in the chat
15:07:07 <haski> call newton (Add(Monom(2,3), Monom(3,4))) (-2) 0.001
15:07:08 <ReinH> monochrom: With floating point division included, it isn't hard to create an input that would stack overflow even if all of the input values are whole numbers
15:07:19 <jared-w> (the -2 will trigger a stack overflow here)
15:07:44 <jared-w> haski: if you only use integers with pow, write the type signature as Integer -> Integer -> Integer
15:08:01 <ReinH> Then you wouldn't be able to do floating point division
15:08:36 <haski> why?
15:08:51 <jared-w> That's not really related to the power function though? So they should be able to use fromIntegral to get back into floating point division?
15:08:58 <monochrom> "stop" and "step" are super-poor names. Who will actually bother to check the "e" and the "o"?
15:09:14 <ReinH> Because you can't do floating point division with Integers
15:09:49 <ReinH> The proper solution is to implement pow in a way that works with non-positive-integral exponents
15:10:37 <jared-w> Right, which I think has been mentioned a few times now
15:10:52 <jared-w> > (fromIntegral 2) / 3.0
15:10:54 <lambdabot>  0.6666666666666666
15:11:23 <jared-w> but that works?
15:11:30 <ReinH> I think we've spent the past 30 minutes just convincing them that their pow is broken?
15:11:45 <ReinH> jared-w: What do you think that demonstrates?
15:11:53 <monochrom> Yeah you do have a "pow 3 (-2)" which you overlooked.
15:12:11 <ReinH> I thought the stack overflow would have been enough to convince them
15:12:28 <jared-w>  ¯\_(ツ)_/¯
15:12:35 <monochrom> > 3 ** (-2)
15:12:37 <lambdabot>  0.1111111111111111
15:13:11 <jared-w> ReinH: I was hoping it demonstrated that if they only use integers with their power function, they can get away with an int type signature and use fromIntegral if they need floating division later
15:13:16 <monochrom> But I know people who reinvent their own sorting algorithm and it has to be bubble sort.
15:13:31 <jared-w> So fixing the function would be less complicated than learning how to write a correct power function
15:13:34 <ReinH> jared-w: Well sure, but then they can't use the same type.
15:13:49 <ReinH> And once they do division, they are stuck
15:13:57 <jared-w> ah right
15:14:37 <jared-w> forgot you'd be doing division and exponentiation over and over
15:14:44 <monochrom> I am also wondering why this uses Float rather than Double. And no, don't tell me Float is faster (false on x86) or Float saves memory (false on GHC).
15:14:56 <ReinH> Once you do division, you have a Double that you can't use any more with Add Integer Integer and etc.
15:15:45 <ReinH> monochrom: I think 99% of Float usage is by mistake.
15:16:09 <ReinH> About the only reasonable use case is GPU programming.
15:16:10 <monochrom> Yeah, urban legends simply never die.
15:16:28 <ReinH> GPUs still choke on doubles unless you have the super swanky industrial strength GPUs
15:16:51 <monochrom> 15% of Republicans still believe that even tail recursion consumes memory.
15:17:57 <monochrom> I do understand that embedded controllers and GPUs require single-precision floats. And DSPs simply go fixed point.
15:19:44 <ReinH> Yeah. I meant reasonable use case *for Haskell*
15:19:55 <monochrom> I am also wondering why Add(Term, Term) not Add Term Term.
15:20:08 <ReinH> I would guess that they don't know the syntax.
15:20:12 <haski> Does it matter?
15:20:18 <ReinH> Yes.
15:20:23 <nshepperd_> Maybe you're storing millions of floats in an unboxed vector
15:20:26 <monochrom> It does. It spends more memory for starters.
15:20:42 <ReinH> They are different things.
15:21:11 <monochrom> nshepperd_, I was thinking of mentioning that, but clearly "data Term = Monom(Float, Float) | ..." is not an unboxed vector.
15:21:33 <ReinH> If you meant to make Add take a tuple, why isn't it a newtype?
15:21:46 <ReinH> Oh sorry, it's part of a sum type
15:21:48 <ReinH> never mind that
15:21:52 <endiruna> hi is there anyone which uses pandoc? I would like to convert to pdf or latex html pages which contain mathjax. when i use pandoc i get escaped stuff like \$ or \_. there seems to be possible reading the documentation to correctly convert html with mathjax to pdf but I do not understand how
15:21:59 <nshepperd_> Yeah
15:22:42 <ReinH> If you meant to make Add take a tuple, that's one thing. If you wrote Add(Term, Term) because you don't understand Haskell's syntax, that's another thing entirely.
15:23:42 <ReinH> The fact that you use parens in a lot of unnecessary places that would be necessary in languages where parens indicate application leads me to believe that it's the latter.
15:32:27 * hackagebot scientific 0.3.5.0 – Numbers represented using scientific notation – https://hackage.haskell.org/package/scientific
15:35:42 <ReinH> johnw: btw I am very happy that I no longer have to store all of Conor McBride's SO answers in DevonThink separately.
15:50:47 <jared-w> wait what. DevonThink?
15:56:47 * hackagebot rtcm 0.1.12 – RTCM Library. – https://hackage.haskell.org/package/rtcm
16:07:23 <michalrus> Hey, I’m running my program with `+RTS -M1M -RTS` but it still takes 34M RES memory. Can this be limited? E.g. somehow git-annex-remotedaemon is able to use only 13M of RES.
16:10:06 <monochrom> Well I just did a little test.
16:10:12 <monochrom> ghci +RTS -M20M
16:10:37 <monochrom> And RES is 113M. So I'm pretty sure RES includes actual code, too.
16:13:31 <mniip> michalrus, besides the heap there's a stack
16:13:43 <mniip> controlled with -K
16:14:00 <mniip> and, yes, of course RES includes the code, and static data, which there's plenty
16:14:03 <monochrom> Stack uses the heap, too.
16:14:12 <mniip> monochrom, er?
16:14:16 <monochrom> Yes.
16:14:27 <mniip> ok, nevermind me then
16:14:33 <michalrus> (:
16:14:51 <monochrom> Best-kept secret. GHC stack is growable and steals from heap.
16:15:09 <mniip> but what happens when stack meets the heap!
16:15:11 <michalrus> So… the simplest explanation would be that I just added too many deps, then?
16:16:12 <monochrom> Or you wrote ten million lines of code.
16:17:02 <michalrus> OK. :) And there isn’t any -O∞ removing dead code?
16:17:10 <michalrus> Or is it all alive? :o
16:18:54 <monochrom> I don't think it's that simple. And compile time is the wrong place to look. Link time is the right place.
16:19:30 <mniip> does ghc do split sections
16:19:34 <mniip> lto might work
16:19:55 <monochrom> Not sure about split sections, but -split-objs is a non-default option.
16:20:14 <mniip> michalrus, in general though I wouldn't expect much success from trying to reduce a haskell program's memory usage
16:20:35 <monochrom> But you have to use -split-objs when building the libraries in the past, not when building the exe now.
16:20:40 <michalrus> OK! =) Thank you both.
16:21:14 <mniip> it's not a very commonly sought target, and even less easily achievable on
16:21:15 <mniip> e
16:21:34 <monochrom> The good news is that libraries that come with GHC already had -split-objs, so for example base.
16:22:12 <monochrom> But Haskell Platform's extra libraries and your own "cabal install"s use the default.
16:24:53 <monochrom> It is also possible that too much -split-objs will make the linker very slow.
16:27:25 <endiruna> hi is there anyone which uses pandoc? I would like to convert a html webpage to pdf or latex. when i use pandoc i get escaped stuff like \$ or \_. there seems to be possible reading the documentation to correctly convert html with mathjax to pdf but I do not understand how
16:27:52 <zomg> hum, where do exceptions go if I run an Async and essentially discard it?
16:28:03 <zomg> I'm noticing they seem to just disappear into thin air :P
16:28:38 <Tuplanolla> That's right, zomg. The functions replace the default handler with a quiet one.
16:28:39 <monochrom> Yes.
16:29:11 <zomg> Ah so I actually should not be using Async to start background tasks in this fashion if I don't intend to ever `wait` on it?
16:29:36 <monochrom> Two things you can do. First option: The job inside has a handler. Second option: There is a "link" thing that transfers the exception to the parent.
16:30:05 <zomg> hmm I tried with link but not much luck...
16:30:32 <zomg> the fact I'm running it in ghci wouldn't happen to have any effect on that behavior would it?
16:30:44 <monochrom> Then consider http://www.vex.net/~trebla/humour/tautologies.html #4
16:31:06 <zomg> hehe
16:31:19 <monochrom> ghci does a forkIO to the command you enter at the prompt.
16:31:55 <monochrom> However I don't think one extra layer of forkIO is going to steal your exception.
16:32:29 <zomg> well I did isolate the location of where the exception gets thrown and while as far as I can tell that thread uses link, I guess I'll see if I can actually catch it and track where it gets lost :P
16:32:51 <Tuplanolla> You should use `link` outside the new thread, zomg.
16:33:00 <zomg> hmm?
16:34:12 * hackagebot ua-parser 0.7.4 – A library for parsing User-Agent strings, official Haskell port of ua-parser – https://hackage.haskell.org/package/ua-parser
16:35:58 <iqubic> Anyone here able to help me with glirc configuration?
16:36:06 <zomg> I wonder if the websocket runClient command spawns a thread...
16:36:48 <zomg> because I essentially have async which spawns a websocket client, but it gets linked... and within the websocket client app, there's another async which loops to read the socket... which actually uses wait
16:37:39 <monochrom> True, wait also transfers the exception to whoever waits.
16:39:00 <ReinH> I sometimes wonder if the English language isn't better for dropping the who/whom distinction.
16:39:13 <ReinH> My dad still corrects me on it though.
16:39:48 <zomg> runClient seems fairly simple and I doubt the underlying socket stuff does any magic with threads that would eat the error
16:39:51 <zomg> bleh.
16:44:25 <zomg> well okay, it does get caught if I wrap the line with the wait with a catch
16:44:36 <zomg> so it must be somewhere up the chain from there then
16:54:28 * hackagebot MemoTrie 0.6.8 – Trie-based memo functions – https://hackage.haskell.org/package/MemoTrie
17:00:33 * hackagebot usb 1.3.0.5 – Communicate with USB devices – https://hackage.haskell.org/package/usb
17:06:23 <zomg> well I don't know but the only way I can manage to get the damn exception out from it is if I use wait
17:07:02 <zomg> I tracked it all the way down to the initial func which connects the client and I added the Async val into the returned value... wait on it and it gets thrown
17:07:26 <zomg> link should work basically with `a <- async someTask` and then `link a` right?
17:08:07 <robertkennedy> Should I use compact regions for all linear data? Ie, is `print' x = compact (show x) >>= getCompact >>= putStrLn` better than print?
17:11:14 <robertkennedy> The reason I think maybe, is that compact regions are apparently motivated by servers, where something like `proxy url = get url >>= compact >>= getCompact >>= put` seems like the idiom they are referring to
17:12:57 <k0001> Does `data Foo a = Foo a a` exist somewhere in the usual libraries? Does `Foo` have a name?
17:13:22 <lyxia> V2 in linear
17:21:04 <k0001> lyxia: thanks.
17:22:31 <zomg> here's a somewhat simplified example of my thread/Async exceptions issue https://gist.github.com/jhartikainen/87da759c3f75a85ac3612ff80133c56f
17:22:58 <zomg> *as far as I can tell* since the initial async is linked it *should* rethrow in current thread
17:23:01 <zomg> but not happening
17:23:28 <jared-w> k0001: that data-type is also often called Pair and is either heterogeneous (tuples) or homogenous ("2d vector")
17:26:30 <k0001> jared-w: do you know if it exists in a library other than `linear`? Mostly I want to know if I have to redefine it in my library or import it from somewhere for better downstream compatibility. `linear` has too many deps for my needs.
17:26:51 <frud> @hoogle Seq a -> Int -> Maybe a
17:26:51 <lambdabot> Data.Sequence lookup :: Int -> Seq a -> Maybe a
17:26:51 <lambdabot> Data.Sequence.Internal lookup :: Int -> Seq a -> Maybe a
17:26:51 <lambdabot> Data.Sequence (!?) :: Seq a -> Int -> Maybe a
17:38:29 <jared-w> k0001: look in hoogle for Pair and for V2 and check out the datatypes you find in there
17:39:03 <jared-w> https://hackage.haskell.org/package/TypeCompose-0.9.12/docs/Data-Pair.html#t:Pair there's this, for example
17:39:37 <jared-w> Doesn't really seem to be what you want
17:41:42 <jared-w> https://downloads.haskell.org/~ghc/8.0.1/docs/html/libraries/ghc-8.0.1/Pair.html#t:Pair this should be exactly what you want
17:42:33 <k0001> jared-w: ah, yes, excellent find! Thank you :)
17:42:42 <k0001> I didn't know that lived in `ghc`.
17:42:54 <jared-w> lol me neither
17:44:11 <Cale> d... don't pull in the GHC API just for that though.
17:45:09 <k0001> Cale: yeah, maybe I won't. I wish I could partially apply `type Pair a = (a, a)`, that would solve all my problems :)
17:45:25 <Cale> k0001: You could also just make your own Pair type.
17:45:47 <Cale> But why do you need to partially apply it?
17:47:03 <k0001> Cale: I need to use it as the first argument to a `(* -> *) -> *` thing. 
17:48:40 <jared-w> Honestly I'd just copy and paste that file and stick it in your own pai rmodule...
17:49:32 <k0001> I'll just `data Pair a = Pair a a`. That's enough for my needs. Mostly, I was wondering whether the thing already existed in transformers, base, or some of those places and I was missing it.
17:49:42 <jared-w> unless you can import ghc (Data(..)) without importing the universe and the kitchen sink?
18:04:45 <ReinH> you can also derive Functor, which would probably be useful
18:08:08 <Lokathor> http://lpaste.net/356742 what are some good enemies/creatures to encounter in a roguelike with a theme where you're trying to save Haskell from an Ed K that's been bewitched by C++
18:08:17 <Lokathor> I've got like half of them
18:09:15 <greymalkin> Do any lens afficianados want to lead me to the lens-equivalent of `or . fmap _thingBoolean`
18:09:21 <geekosaur> symbol-heavy lens combinators }:>
18:09:35 <glguy> greymalkin: map (view thingBoolean)
18:09:40 <glguy> Oh, I missed the or
18:09:54 <glguy> orOf (folded . thingBoolean)
18:10:59 <greymalkin> Is there a way that nests?
18:11:05 <glguy> Oh, actually:
18:11:11 <glguy> any (view thingBoolean)
18:14:40 <glguy> greymalkin: if you show the actual code we can probably do better
18:24:38 <zomg> Anyone got any ideas why using link with an Async value doesn't seem to make errors get thrown in the thread?
18:24:51 <zomg> Relevant bits of code https://gist.github.com/jhartikainen/87da759c3f75a85ac3612ff80133c56f
18:56:06 * hackagebot hspec-meta 2.4.4 – A version of Hspec which is used to test Hspec itself – https://hackage.haskell.org/package/hspec-meta
19:08:10 <lyxia> zomg: where's the error coming from
19:14:30 <Costar> Is possible to do foo :: forall f. Functor f => (a -> f b) -> f c -> (a, b -> c) ???
19:17:10 <geekosaur> where do you think the result a is coming from?
19:17:34 <Costar> in the paper says
19:17:37 <geekosaur> (a -> f b) is not something that 'contains' an a, it is something that 'requires' an a
19:17:59 <Costar> we need to instantiate f to be the Functor (a, b -> c)
19:19:27 <Costar> im trying to understand this
19:19:44 <petejohanson> Do functions defined in the where section inherit the type restrictions/definitions for the toplevel function definition?
19:20:07 <petejohanson> Or do they need to be added to each function in the where clause as well to match?
19:20:11 <kadoban> petejohanson: No. Though you can do that if you like with ScopedTypeVariables
19:20:38 <kadoban> (you also have to pick which ones you want to give a scoped meaning to with forall)
19:20:48 <zomg> lyxia: from the innermost function
19:21:10 <zomg> lyxia: if I put a catch on line 21 or 14, it'll catch the error
19:22:27 * hackagebot gnss-converters 0.2.10 – GNSS Converters. – https://hackage.haskell.org/package/gnss-converters
19:23:00 <geekosaur> Costar, I don't know what paper you are referring to, but I am pretty sure that is not what they mean. they are saying that the f has to have the form (a, b -> c). which I *think* is talking about the Functor instance for 2-tuples?
19:23:05 <zomg> the issue is that the error can occur at a later time and I don't really want to put a catch-all eat-all-errors catch call there :)
19:23:05 <geekosaur> @src (,) fmap
19:23:05 <lambdabot> fmap f (x,y) = (x, f y)
19:24:03 <petejohanson> kadoban: Thanks.
19:27:01 <geekosaur> Costar, in any case what you wrote is impossible, as you only have something that *requires* an a, and neither an a nor anything that produces one --- so the result cannot have an a, except to the left of a ->
19:28:23 <Costar> geekosaur: The defined foo to be foo h = hR(\a -> (a, id)). This hR is like picking a Functor from that forall. Seems to be theoretical only, right?
19:29:38 <Costar> geekosaur: He is showing an isomorphism between  forall f. Functor f => (a -> f b) and (a, b -> c) 
19:30:14 <Costar> geekosaur: One side is possibe, that one I asked is weird
19:32:13 <geekosaur> I would still want to see the paper to understand the context
19:32:31 <Costar> geekosaur: do you want the link?
19:32:49 <geekosaur> it would help, yes
19:33:44 <Costar> geekosaur: http://www.fceia.unr.edu.ar/~mauro/pubs/Representation.pdf
19:33:48 <Costar> geekosaur: page 3
19:34:45 <petejohanson> Follow up:  I have nested StateT transformer.... and I'm getting errors about "Could not deduce" about finding the MonadState blah blah around use of modify/gets.
19:34:52 <petejohanson> (Happy to pastebin specific error)
19:35:08 <petejohanson> I feel like I need to be lifting the gets/modify to the proper spot maybe, but feeling a bit lost.
19:35:20 <penguin359> Hello
19:35:33 <geekosaur> Costar, I think the answer is back on page 1
19:35:53 <penguin359> I'm at the GHCi prompt, but I'm curious how I find what loaded module a function is coming from.
19:36:03 <geekosaur> penguin359, :info
19:36:19 <geekosaur> e.g. :info putStrLn
19:36:29 <penguin359> thanks, that did it.
19:36:51 <Costar> geekosaur: where?
19:36:56 <geekosaur> Costar, they are using that (a, b -> c) as a representation of a functor in order to talk about a second-order functional
19:37:42 <glguy> petejohanson: MonadState doesn't help when you nest StateT
19:38:38 <penguin359> hmm, so mapM comes from Data.Traversable, but filterM comes from Control.Monad?
19:38:40 <geekosaur> Costar, section 1.1, the representation theorem. they suggest that a functor can be represented as a pair (a, b -> c) as part of talking about a second-order functional (a "functor" over functors, I think?(
19:38:50 <geekosaur> penguin359, yes these days
19:39:11 <penguin359> I was thinking they were defined together, but only had one of them.
19:39:15 <geekosaur> mapM can be considered legacy, replaced by traverse which is the primary method of Traversible
19:39:23 <geekosaur> er Traversable
19:39:40 <geekosaur> basically, Monad historically had a lot of things that can be more general than Monad
19:39:54 <Costar> geekosaur: Ok.
19:40:17 <Costar> geekosaur: Maybe that represented word confused me
19:40:28 <geekosaur> so Applicative was split from Monad (originally return and ap), and then Foldable and Traversable were generalized and the generalized Traversable subsumes mapM
19:40:52 <geekosaur> Costar, they're talking theoretical math there, not Haskell :)
19:40:54 <penguin359> Does that mean that mapM is deprecated?
19:41:15 <geekosaur> penguin359, not quite yet. there's far too much code in existence that relies on it
19:41:37 <Costar> geekosaur: Thank you :)
19:41:59 <geekosaur> new coe that doesn't hjave to worry about backward compatibility to ghc 7.10 and earlier could use traverse, but backward compatibility still matters in a world with the likes of Debian stable in it :)
19:44:58 <Imagine> is there a : operator but in the other direction?
19:45:10 <Imagine> [] : 2 
19:45:43 <geekosaur> Imagine, not really, no. (:) isn't an operator, it's a constructor. you'd have to define a reversed list to get the reverse operator
19:45:48 <andreabedini> Imagine: flip (:) ? :)
19:45:54 <geekosaur> or [...] ++ [2]
19:46:07 <ReinH> geekosaur: Is this a representable functor thing?
19:46:18 <Imagine> ok
19:46:27 <geekosaur> :t \xs x -> xs ++ [x]
19:46:29 <lambdabot> [a] -> a -> [a]
19:47:00 <ReinH> data Snoc a = Lin | xs :< x
19:47:12 <geekosaur> ReinH, the paper was about a formalization of second order functionals
19:47:16 <ReinH> If you want to add elements on the right, use a data type designed for it
19:47:36 <Imagine> ok
19:47:43 <Imagine> That was a dumb question tbh
19:47:51 <geekosaur> so they wanted a way to talk about functors such that they could then reason about those functionals in terms of them
19:47:53 <Imagine> Really I just want to know how to make a constructor
19:48:04 <Imagine> can I adapt the : constructor for my tree?
19:48:06 <petejohanson> glguy: Not using it explicitly. Snippet of code in question: https://gist.github.com/petejohanson/ad3a00b62de00c581a7e240587d8f12e
19:48:15 <MarcelineVQ> Sounded like a good question to me, since it got good answers
19:48:19 <Imagine> Btw I am formerly known in here as "The Kinaesthetician"
19:48:22 <petejohanson> glguy: Any insight would be appreciated.
19:48:39 <geekosaur> Imagine, not as such although there is OverloadedLists extension
19:48:42 <Imagine> I was asking questions about my tree functions throughout the week
19:49:13 <Imagine> I have structure like B[]
19:49:54 <geekosaur> defining your own infix constructors is as simple as data Tsil a = Lin | Tsil a :< a -- or similar
19:50:03 <ReinH> Imagine: Any operator beginning with a : (but not :) can be used as an infix constructor
19:50:10 <geekosaur> (if it's not obvious, that's List and Nil backwards...)
19:51:37 <Imagine> what is :<
19:51:44 <Imagine> and it doesn't need to be infix necessarily
19:51:52 <Imagine> I just literally don't know how the colon operator works
19:51:58 <Imagine> so I don't know how to define my own that works on trees
19:53:08 <geekosaur> :< was just an infix constructor I dreamed up. it's *defined* by that
19:53:14 <Hafydd> :< is the face I make when seeing names like "Tsil".
19:53:40 <geekosaur> the constructors for the type Tsil are Lin and (:<), equivalent to [] and (:) for lists
19:54:18 <glguy> petejohanson: first write that without >>=, join, <$>, or <*>. Just use do-notation
20:02:28 <petejohanson> glguy: I get effectively the same error, but on the line that is now:  ct <- gets Resp.chosenContentType 
20:05:17 <quick_dudley> The list type in Haskell is defined like this: data [] a = [] | a : [a]
20:06:04 <quick_dudley> It's just a normal ADT except for the special syntax with [], and : is just one of its constructors
20:10:25 <glguy> petejohanson: ok, paste the deobfuscated version and we can see what's going on
20:17:38 <petejohanson> glguy: Reload gist.
20:18:02 <glguy> petejohanson: OK, change: gets Resp.chosenContentType  to  lift (gets Resp.chosenContentType)
20:19:09 <glguy> petejohanson: It's not generally going to be a good idea to using a type synonym'd StateT, much less two stacked
20:19:50 <glguy> But lift there should fix the error you're getting
20:28:57 <Imagine> I'm stuck
20:29:16 <Imagine> I created a tree data type
20:29:34 <Imagine> made a few functions that take a list of numbers corresponding to a location on the tree
20:29:55 <Imagine> but my actual goal is to parse text such as "[1[1 2] 3]
20:30:20 <Imagine> but my actual goal is to parse text such as "[1[1 2] 3]"
20:30:30 <glguy> Imagine: If you have some code so far, throw it up on a pastebin
20:32:43 <Imagine> https://pastebin.com/uviiSdQ5
20:32:46 <Imagine> did I do it right
20:32:52 <Imagine> or should I use lpast
20:33:05 <Imagine> lpaste is really slow for me
20:33:12 <glguy> github's better, doesn't have ads
20:33:16 <glguy> but this works as pasted for now
20:33:47 <Imagine> http://lpaste.net/2017966289259069440
20:33:49 <glguy> | cur == '[' = B [createTree rest]
20:33:59 <glguy> In this line, why would you only create a single-element list?
20:34:16 <Imagine> how do I not
20:34:24 <Imagine> It could potentially be infinite
20:34:33 <glguy> [x] makes a single element list where x is that element
20:34:33 <Imagine> well I mean it can't
20:34:53 <Imagine> so do I jus not put the brackets
20:35:17 <glguy> Yeah, there are other issues to figure out, but thinking you need to surround lists in brackets is a common mistake, so I'm just pointing it out
20:35:33 <Imagine> Hold up a second though. 
20:36:12 <Imagine> I may need to start over, which is fine, but wouldn't it be less computationally efficient to derive the tree from the text and then call the functions which search the tree anyways?
20:36:30 <Imagine> shouldn't as I'm creating the tree, I then go ahead and do the thing I want it to do
20:38:04 <Imagine> because eventually I want all this to happen automatically
20:38:11 <Imagine> maybe using a do expression
20:38:41 <glguy> I don't know what you have in mind, but I'd get it working first before worrying about that
20:38:53 <glguy> You should be able to write it this way. If you can't it's worth spending some time figuring out
20:39:20 <Imagine> yeah, it's not like I'll really be wasting my time
20:39:27 <Imagine> since I'll always be learning something
20:39:36 <Imagine> but still I already forsee that I'm doing the wrong path
20:39:41 <Lokathor> are there monads other than IO and ST that don't/can't have transformer variants?
20:39:52 <Imagine> I'd need to store the location in the tree of numbers
20:40:45 <Imagine> :glguy So how do I get commas in there?
20:40:52 * hackagebot rattletrap 2.3.0 – Parse and generate Rocket League replays. – https://hackage.haskell.org/package/rattletrap
20:40:53 <Imagine> in the guards
20:41:03 <geekosaur> Lokathor, STM
20:41:24 <Imagine> Ok let me say that more clearly. How do I parse and create commas in a list, since currently I have no operator to add elements.
20:41:50 <glguy> Imagine: comma won't factor in, you're using space ' ' for your element delimiter
20:42:09 <lyxia> Lokathor: ListT is non-trivial to get right.
20:42:13 <glguy> and for building up lists you'll have :
20:42:14 <Imagine> yeah but my tree structure is of the form B[L 1, L 2]
20:42:27 <pacak> Imagine:  fromList <$> many parseElement
20:42:44 <Lokathor> boy howdy is it. aren't there like 3 packages that all claim to have an ListT ? and like, they all violate the mond laws somehow?
20:42:56 <glguy> Imagine: A tree is either a digit, or a list of trees (which is started by [ and separated by ' ', and ended by ']'
20:43:42 <Imagine> but how do I separate
20:44:02 <Imagine> and not every space is necessarily a coimma
20:44:31 <lyxia> Lokathor: the one in transformers is wrong. I think list-t and pipes are correct.
20:44:38 <geekosaur> I get the feeling that Imagine is stuck on the textual shorthand for a list in Haskell, when trying to build up a list from elements
20:45:44 <Imagine> :geekosaur I know that a list is a:b:[], 
20:45:57 <Imagine> but as of now my data structure doesn't allow that
20:46:19 <Imagine> so unless I redefine it, or somehow make a function that can add elements to any nested list
20:46:27 <Imagine> the hard part is the fact that it's nested
20:46:32 <Imagine> so like how do you refer to any one
20:46:37 <glguy> Imagine: Your tree parsing function will need to return the unused portion of the input string when it's done parsing a single tree
20:47:26 <Imagine> yes, I can see imagine that
20:47:53 <geekosaur> Imagine, you do so recursively. once you have finished with a list, you don't need to do anything with it again, so at any given time you are appending to a list that will be wrapped in a B and passed up
20:48:46 <Imagine> but when I try to append to the list wrapped it doesn't work
20:49:18 <Imagine> can i somehow pattern match, within my guards
20:49:27 <Imagine> outside the initial pattern match
20:49:50 <geekosaur> there are pattern guards, but you are overthinking this
20:50:02 <geekosaur> you can leave the B off until you are done constructing the list
20:50:41 <Imagine> perhaps
20:50:43 <geekosaur> once you are done with that, you wrap it in a B and give it back to the caller; it will not be modified after that, only new lists will be created
20:51:27 <Imagine> ok i'm starting to imagine
20:51:47 <Imagine> how do i do digits with more than one place
20:51:50 <Imagine> like 39
20:52:11 <Imagine> ok nvm
20:52:24 <Imagine> I can figure something out using if expressions probably
20:57:13 <jchia> lens question: Can zoom be used directly to change a ExceptT e (StateT s m) a into an ExceptT e (StateT (s, t) m) a? (I'm not particularly interested in ExceptT, just concerned about whether zoom can be used when StateT is not in outermost layer. I'm getting type errors that I don't understand.)
20:58:23 <glguy> jchia: Did you check to see if there was a Zoom instance for the type you were interested in?
20:59:32 <jchia> glguy: Do you mean like how there's Zoom for WriterT & MaybeT, if I want to zoom for FooT, I need to also define Zoom for FooT?
20:59:58 <glguy> Yeah, to use a Zoom instance there must be one
21:00:31 <jchia> glguy: I see, I'm trying to use it for LoggingT from logging-effect. I suppose I need to define Zoom for it
21:00:43 <glguy> :t zoom
21:00:44 <lambdabot> Zoom m n s t => LensLike' (Zoomed m c) t s -> m c -> n c
21:05:43 <Sebastian> Hey Haskell folks! I am interested in making an foreign function wrapper for the LiquidFun library, for open source use by the Haskell community
21:06:06 <Sebastian> LiquidFun is a Google fork of the Box2D physics engine, that has both rigidbodies and particle dynamics
21:06:42 <Sebastian> Haskell has no current, maintained, non-deprecated 2D physics engine from what I can see, so I think it's worth doing
21:06:54 <Sebastian> My questions are:
21:07:25 <Sebastian> 1. I am experienced with Haskell but not with interacting with C++ code from Haskell. What is the most correct, up-to-date resource I should be referencing?
21:07:57 <glguy> You can't interact with C++ directly; you'll need a C wrapper around the C++ API
21:08:02 <Sebastian> 2. Is anyone else interested in this goal, and interested in helping me get this up and going?
21:08:37 <Sebastian> glguy: Okay, sounds do-able. Any good reference material you recommend?
21:09:50 <Sebastian> I'm also kind of wondering whether some libraries just aren't compatible with the ffi stuff, but it would take some effort to verify that even for someone who knows the answer. The repository is at https://github.com/google/liquidfun/tree/master/liquidfun
21:11:22 <Sebastian> There's also a JavaScript version of the library via Emscripten, but boy... C++ > JavaScript > GHCJS > Haskell seems like quite the path, and I have concerns about the performance of such a solution
21:17:19 <pacak> With javascript I usually  have concerns about my sanity...
21:20:17 <Imagine> glguy, geekosaur, Idk if I'm thinking about this wrong but since my function is supposed to :: [Char] -> Tree a, but I'm trying to make a list first and then wrap a B around it, I get type errors
21:22:14 <Imagine> http://lpaste.net/356744
21:24:23 <Imagine> also "wrapping a B around it" is hard
21:24:45 <Imagine> i don't see how I can reference the list that i'd be making recursively
21:25:00 <Imagine> since at any given point the function won't really know about the rest of the list it's creating
21:25:04 <Imagine> even if the types worked
21:26:50 <jle`> so
21:26:54 <jle`> i'm a big fan of the free applicative now
21:26:57 <jle`> pretty neat stuff
21:27:35 <pacak> jle`: How are you using it?
21:28:26 <jle`> basically a free way to define an 'append' for functors
21:28:43 <jle`> if i make a functor representing a form element in a GUI
21:28:49 <jle`> with interactive capabilities
21:29:11 <jle`> i can just throw into a free applicative to get a functor for an entire form
21:29:25 <Imagine> I have to go to bed Night
21:29:36 <jle`> in a way it's kind of like a list for higher-kinded items
21:32:16 <pacak> Hmm... I know that free monads/free applicatives make a nice hammer, just couldn't find any nails that match it in my codebase :)
21:33:01 <jle`> yeah, i probably wouldn't go out of my way to force them into a project
21:33:22 <jle`> so like, in my case, a 'FormElement a' was a form element that produced an 'a'
21:33:38 <jle`> and i was like, 'can i combine a FormElement Int and a FormElement Bool to make a FormElement (Int, Bool)'
21:34:23 <jle`> normally i'd have to like, make some sort of complicated type that is a tree or list of FormElements
21:34:30 <jle`> and like add it in as a constructor, maybe
21:34:45 <jle`> but i'd basically then be copying the structure that Ap gives for free
21:34:55 <jle`> being able to lift any functor into a "combinable functor"
21:35:02 <pacak> If FormElement is applicative - what's wrong with (,) <$> feInt <*> feBool ?
21:35:19 <jle`> i'd have to change the structure of how it's represented
21:35:22 <jle`> to be able to make it Applicative
21:35:26 <jle`> add like an extra constructor maybe
21:35:29 <pacak> Hmm... I  see.
21:35:43 <pacak> Instead you get this applicative for free.
21:35:45 <jle`> since its actual structure isn't built to represent two elements
21:35:51 <jle`> mhm
21:36:02 <quick_dudley> :info Zoomed
21:36:31 <jle`> i guess at this point in my mind, Applicatives are like functors you can combine "horiziontally", and Monads are functors you can combine "vertically"
21:37:47 <jle`> and Ap/Free are just ways to get that combining ability for free
21:38:30 <jle`> also one advantage of using Ap/Free instead of manually modifying the structure of your functor to accomodate it is that you now don't have to use explicit recursion to work with your functor
21:38:54 <jle`> if i had modified my FormElement to be recursive and support multiple items, i'd have to use explicit recursion/pattern matching to render it
21:39:12 <jle`> but Ap/Free come with combinators that let you render/process your structure without requiring explicit recursion
21:42:50 <Lokathor> i hate that the list type's name isn't a word
21:42:56 <Lokathor> it makes writing about it so much more annoying
21:43:13 <pacak> type List a = [a]
21:43:36 <Lokathor> yeah i'm calling it List
21:43:45 <Lokathor> but like, properly it's kinda like, [ ]
21:43:48 <EvanR> you mean referring to the type ctor itself
21:43:52 <Lokathor> but that looks like []
21:44:01 <pavolzetor> hi, I am trying to avoid typeclasses or putting everything into a single data. What are the strategies to work around it?
21:44:06 <Lokathor> Unlike with `IO`, `ST`, and `RandT`, with List the `<-` doesn't just ...
21:44:07 <EvanR> actually it is []
21:44:10 <pavolzetor> I have data BVH a = ...
21:44:21 <EvanR> :k [] Bool
21:44:23 <lambdabot> *
21:44:26 <pavolzetor> and I want to use it for holding instances and geometry
21:44:39 <pavolzetor> but I prefer not to have them in same data constructor
21:44:41 <Lokathor> pavolzetor, "instances"?
21:45:04 <pavolzetor> yes, in ray tracing you want instancing to share geometry
21:45:04 <EvanR> @src []
21:45:04 <lambdabot> data [] a = [] | a : [a]
21:45:35 <pavolzetor> I am thinking of passing a function to builder which is (a -> AABB)
21:46:01 <pavolzetor> so currently I have mkBVH :: V.Vector a -> BVH a
21:46:18 <pavolzetor> but "a" needs to be able compute bounding box
21:46:19 <Lokathor> I ammend my statement that what I don't like is that one of the constructors looks like one of its values when you leave the 'a' part off, which in this sentence i have to do for parity
21:46:38 <pacak> pavolzetor: So you basically reimplementing typeclasses yourself?
21:46:49 <EvanR> agreed, thats why idris uses colors
21:46:52 <Lokathor> pavolzetor, this is a lot like what a typeclass is for
21:47:00 <EvanR> blue () is a type, red () is a value
21:47:16 <Lokathor> EvanR, ugh that's worse! that's so much harder to put into a markdown document that's being rendered into HTML :3
21:47:49 <EvanR> i hope that markdown doesnt become an excuse to make documents crappier
21:48:03 <pavolzetor> Hmm, maybe. I just dont want a typeclass, it feels heavy weight and here I have only 2 different data types
21:48:18 <Lokathor> EvanR, well you can't do the colorization in IRC either :P
21:48:32 <EvanR> you can, idris bot does it
21:48:34 <Lokathor> pavolzetor, then accept a conversion function, i guess
21:48:49 <glguy> 02() 04()
21:48:50 <pavolzetor> That is my current approach
21:49:04 <Lokathor> hmm, are colors part of the IRC spec?
21:49:07 <pavolzetor> How do you decide when it is right to create new typeclass?
21:49:10 <Lokathor> never read that part
21:49:39 <Lokathor> pavolzetor, when you start passing a function and a value of a type together and the function is always the same as the type that goes with it
21:49:47 <pacak> pavolzetor: When you pass (a -> B) and a - how is it different from passing a typeclass dictionary containing (a -> B) and a, except for you having to do it by hands rather than ghc dealing with everything?
21:49:50 <Lokathor> you might have the beginnings of a typeclass
21:50:24 <EvanR> you can also pass a record of functions
21:50:48 <pacak> EvanR: Yea, and call it DictionaryFoo....
21:51:14 <EvanR> yes its operationally what typeclasses are
21:51:37 <EvanR> but a type can only have 1 such dictionary per clas
21:51:53 <EvanR> so explicit might be good
21:52:35 <EvanR> you also have to have a type to anchor it to in the first place
21:53:04 <pavolzetor> I see, so I would have such record for each data type?. I may be able to change it so none is necessary.
21:53:12 <pacak> @where reflection
21:53:12 <lambdabot> http://hackage.haskell.org/package/reflection
21:55:02 <pavolzetor> I will think about it over night; it is just bit peculiar as Instance has materials and Geometry does not. It feels wrong to put then under same data type.
21:55:42 <Lokathor> https://lokathor.gitbooks.io/using-haskell/content/roguelike/week-3-random-dungeons.html 5100 words of haskell explanation and i haven't even written the dungeon generator yet
21:55:57 <quick_dudley> Putting two types in the same typeclass is not the same as making them the same data type
21:56:09 <pavolzetor> And many people put BVH inside a mesh, but I want it outside and pass closure with vertex set
21:56:36 <pavolzetor> I want to avoid typeclass.
21:57:01 <pacak> Why?
21:57:24 <pavolzetor> I dont like the style it is written in. The extra indentation is annoying
21:57:38 <EvanR> Lokathor: nice music
21:57:40 <pavolzetor> I much more prefer have the function zero indent
21:57:56 <quick_dudley> You can avoid the extra indentation if you use { and }
21:58:48 <pavolzetor> interesting; is there an actual techncal difference to passing a function?
21:59:16 <pavolzetor> (if I have typeclass with only one function)
21:59:53 <EvanR> no, thats what typeclasses do 
22:00:05 <EvanR> (for you)
22:00:38 <pacak> Having to pass stuff manually, shooting yourself in a foot when it comes to some optimizations, etc.
22:00:38 <pavolzetor> than I dont see any benefit for just one function
22:00:51 <pavolzetor> what optimizations?
22:01:39 <quick_dudley> For example: inlining and rewrite rules
22:02:03 <quick_dudley> I think it might also affect stream fusion, but don't quote me on that
22:02:06 <pacak> Specialization for example. In some cases ghc can inline a bunch of stuff and apply rewrite rules.
22:02:12 <EvanR> i dont think "always use classes if you can" is the right message
22:02:22 <pacak> stream fusion = rewrite rules
22:02:27 <pavolzetor> why would ghc not be able to do it with a function?
22:02:49 <pacak> With typeclass if ghc knows type - it knows what function you are going to pass.
22:03:08 <glguy> with GHC if it knows the function you're going to pass, it can take advantage of that, too
22:03:08 <EvanR> and change your code to be less natural to get optimizations is definitely not
22:03:09 <pacak> With function - you can pass anything and ghc won't be able to tell
22:03:14 <quick_dudley> I knew stream fusion could be implemented with rewrite rules but I thought GHC did a bit extra
22:04:14 * hackagebot streaming-with 0.1.1.0 – with/bracket-style idioms for use with streaming – https://hackage.haskell.org/package/streaming-with
22:04:40 <pavolzetor> I dont understand, I am passing some explicit function and GHC should see it
22:06:20 <quick_dudley> If you're using a class then sometimes GHC implements it as passing a function but often it will do it at compile time so the function doesn't have to be passed at runtime
22:06:23 <EvanR> Lokathor: how did you come up with the split algorithm?
22:06:31 <pacak> quick_dudley: List producers are implemented via build, consumers - via foldr, and there's some rules that combine those together avoiding making a loop in the first place.
22:07:03 <Lokathor> EvanR, I run the generator enough to get 128 bits of output (enough for one generator) and then i mess them around.
22:07:03 <tilk> hello, n00b here, I was wondering if anyone can recommend a good tutorial for teaching a machine to play a simple game (e.g. pong) 
22:07:17 <EvanR> also, pseudorandom number god? 
22:07:17 <Lokathor> as it says in the official version, "-- no statistical foundation for this!"
22:07:30 <Lokathor> EvanR, you clearly need to play more video games
22:07:32 <pavolzetor> I thought GHC can specialize a function. I have to run, thanks for explaining concepts.
22:07:47 <EvanR> its a reference?
22:07:53 <Lokathor> https://en.wiktionary.org/wiki/Random_Number_God
22:08:04 <Lokathor> it's a common joke on the RNG acronym
22:08:18 <pavolzetor> I will ponder it for a few days and see. Thanks!
22:08:29 <Lokathor> as in, "i would have won that game of nethack, but the random number god was against me"
22:09:47 <EvanR> when the generator is working, the great part is that its not a god
22:10:29 <Lokathor> well, it is arbitrary from the outside
22:12:01 <EvanR> no
22:12:16 <EvanR> big diff between statistical and arbitrary
22:12:41 <EvanR> its like a severely constrained god
22:12:57 <Lokathor> ugh, it cannot be predicted ahead of time without knowing the internal state of the generator, how about that :3
22:13:36 <Lokathor> it's sufficiently arbitrary
22:13:43 <Sebastian> Anyone have experience with fficxx or Hoppy?
22:13:55 <Sebastian> They're both C++ ffi generation libraries
22:14:26 <Sebastian> fficxx is automatic, Hoppy requires a Haskell-side description of the API
22:15:31 <EvanR> probabalistic
22:15:54 <EvanR> probabilistic
22:18:50 <EvanR> i think at some point people hypothesized god was like a watchmaker, created a deterministic universe and left it to run deterministically. now they call him a gambler, throwing dice to see what happens next. either way, hes not really involved :)
22:19:24 <Lokathor> einstein.txt
22:21:51 <MarcelineVQ> wiggly waves of timey wimey
22:22:22 <Lokathor> ^
22:22:30 <jle`> mfw evalStateT takes a Monad constraint still for some reason
22:23:33 <Lokathor> mfw I'm not even entirely clear what the type of the do block in rogueDungeon is because i'm not using liftRandT so i'm not clear how it's making a RandT value
22:23:36 <Lokathor> but it works so whatever
22:26:30 <tilk> anyone?
22:27:41 <Lokathor> tilk that sounds more like a machine learning sort of thing than a haskell specific sort of thing
22:28:02 <Lokathor> if you can find a version that does it in another popular language we might be able to help you translate it to haskell though
22:28:46 <tilk> oh woops. i just posted in the wrong channel! me being clumsy
22:28:48 <tilk> sorry
22:29:53 <Lokathor> http://lpaste.net/356746 what are some monsters i should add. Game theme is: Ed K has been turned evil by C++ and you have to save the Haskell Kingdom
22:30:30 <dramforever> Quasiquoters gotta be in
22:30:43 <Lokathor> ahh, perf
22:31:38 <MarcelineVQ> V0-V4 , a boss V, and a secret boss called V5
22:32:00 <mniip> Lokathor, Lens, duh
22:32:23 <halogenandtoast> what does the `~` do here? let ~(a, s') = f s
22:32:24 <Lokathor> I was thinking that a lens would be a weapon you might get, but i guess it can be an enemy
22:32:28 <mniip> for Z consider Zygohistomorphic prepromorphisms
22:32:33 <Lokathor> halogenandtoast, makes it irrefutable
22:32:39 <Lokathor> mniip, whaaaaa
22:32:42 <johnw> halogenandtoast: it defers the deconstruction until the value of 's' is required
22:32:42 <pacak> Lokathor: P should be PHP...
22:32:50 <MarcelineVQ> halogenandtoast: makes the pattern irrefutable, allowing you to do the stuff on the right and only pattern match as is demanded by what you use
22:32:56 <dramforever> surprise!
22:32:58 <dramforever> nothing!
22:33:06 <dramforever> > let ~(a, b) = undefined in 42
22:33:08 <lambdabot>  42
22:33:15 <dramforever> > let (a, b) = undefined in 42
22:33:17 <lambdabot>  42
22:33:18 <halogenandtoast> Lokathor, johnw, MarcelineVQ, dramforever thanks
22:33:21 <Lokathor> pacak, i have a special place in my heart for Python, and wanting to tell people that they should move to more maintainable langauges
22:33:29 <dramforever> It's the same!
22:33:36 <dramforever> > case undefined of (a, b) -> 42
22:33:38 <lambdabot>  *Exception: Prelude.undefined
22:33:40 <dramforever> > case undefined of ~(a, b) -> 42
22:33:42 <lambdabot>  42
22:33:43 <pacak> Lokathor: Have you ever seen php?
22:33:44 <dramforever> This is different
22:33:46 <mark__> Hi, I just saw the definition of the inifinite fibonacci list with zipWith (so fibs = 0 : 1 : (zipWith (+) fibs (tail fibs))).  I think I understand how this works, and wanted to write a similar list for factorials.  But, facts = 1 : 2 : (zipWith (*) facts (tail facts)) gives me an all 0's list, and I'm not sure why.
22:33:59 <johnw> dramforever: if I didn't already know what it did, your examples would mean nothing to me
22:34:03 <Lokathor> pacak, most of the people doing roguelike tutorials are doing it python though, not PHP
22:34:20 <dramforever> johnw: I'm writing an explaination...
22:34:27 <pacak> Lokathor: PHP quizz. true or false: md5('240610708') == md5('QNKCDZO')  ?
22:35:12 <MarcelineVQ> mark__: works for me, are you sure you didn't leave a 0 : in the facts version?
22:35:12 <Lokathor> never written a line of PHP in my life. gut says somehow that's true
22:35:29 <mniip> pacak, you mean md5('QNKCDZO') == md5('240610708')
22:35:40 <pacak> Lokathor: Indeed it's true.
22:35:43 <dramforever> An irrefutable, well that's basically: case x of ~(a, b) -> ... a ... b ...     means    ... (fst x) ... (snd x)
22:35:43 <MarcelineVQ> > let facts = 1 : 2 : (zipWith (*) facts (tail facts)) in take 10 facts
22:35:45 <lambdabot>  [1,2,2,4,8,32,256,8192,2097152,17179869184]
22:35:47 <dramforever> ...
22:35:48 <mniip> it's the QNKCDZO that begins with a 0
22:35:52 <mark__> oh, I think I just hit the int uppre bound quickly then see all 0's
22:36:08 <pacak> mniip: I think they both do
22:36:13 <mniip> oh
22:36:14 <mniip> indeed
22:36:30 <Lokathor> B, D, F, K, T, W, X
22:36:40 <Maxdamantus> I get 1 when I try it.
22:36:41 <mniip> oh
22:36:52 <mniip> it's the property that they completely parse as a number?
22:36:58 <pacak> Lokathor: md5sum makes two strings that start with "0e" so php converts them to numbers and compares. Obviously 0 == 0 => true.
22:36:59 <mniip> being of the form \d*e\d*
22:37:15 <dramforever> johnw: I don't think my upcoming explaination will do anything
22:37:19 * dramforever feels bad
22:37:36 <Lokathor> pacak, sure, classic, sounds like JS honestly
22:37:36 <johnw> I'm sorry, I didn't mean to be discouraging, but I was
22:37:45 <MarcelineVQ> mark__: seems like it
22:37:47 <mniip> Lokathor, B is for Boost
22:38:08 <dramforever> johnw: It's fine, I was trying to clear things up
22:38:12 <dramforever> apparently I didn't
22:38:26 <Lokathor> good good
22:38:29 <pacak> mniip: As far as I remember it only needs \d*e\d* that can be followed by anything.
22:38:30 <dramforever> saying it anyway: patterns in 'let' bindings are already irrefutable
22:38:45 <mniip> well these are fairly curious hashes
22:38:54 <MarcelineVQ> monochrom: Who was your thesis supervisor?
22:39:14 <pacak> Lokathor: T - typescript, like javascript but with fake types.
22:39:23 <dramforever> Yeah and I think I used to say Python was not strongly types enough
22:39:25 <mniip> the probability of finding one is 3e-7, a bit higher than I expected
22:39:34 <dramforever> I promise I'll never do that again
22:40:01 <pacak> W - windows, OS that got a userbase of ghc of size 1.
22:40:10 <Lokathor> i'm the 1
22:40:12 <Lokathor> ;_;
22:40:20 <pacak> Hmm... Make it 2 then.
22:40:44 <dramforever> 3
22:40:47 <pacak> C and D and could be Domain and Codomain...
22:41:02 <Lokathor> C is class file, particularly a Java class file
22:41:14 <mniip> Lokathor, perhaps Field puns?
22:41:21 <Lokathor> hmmm
22:41:27 <Lokathor> Finalizer?
22:41:28 <pacak> L - lambda calculus?
22:41:31 <mniip> sounds good
22:41:41 <mniip> pacak, nah we're describing enemies of haskell as I gather
22:41:47 <pacak> L - Lokathor, lonely ghc users on windws?
22:41:56 <Lokathor> :(
22:41:58 <Lokathor> yes
22:42:01 <Lokathor> D, K, X
22:42:10 <Lokathor> didn't you say Xylocombinator or something
22:42:24 <EvanR> this game has java in it?
22:42:28 <mniip> you didn't use Zygohistomorphic prepromorphisms
22:42:42 <johnw> Kan Extension
22:43:08 <pacak> D - Dynamic typing
22:43:21 <EvanR> haha
22:43:25 <mniip> S - SFINAE
22:43:26 <Lokathor> EvanR, the theme is that Ed K has been bewitched by C++ and you have to save the Haskell Kingdom by fighting him and his evil minions
22:43:38 <Lokathor> DUCK typing
22:43:42 <Lokathor> the worst
22:43:48 <EvanR> so java related characters seems kind of funny!
22:43:49 <mniip> not... really
22:43:57 <mniip> Duck typing at least has a theoretical basis
22:44:00 <mniip> read up on subtyping
22:44:07 <pacak> You can do duck typing in haskell
22:44:16 <mniip> sort-of
22:44:22 <systemfault> Dependency Injection
22:44:24 <mniip> not sure if you'll survive the context pileup
22:44:35 <systemfault> Singleton
22:44:35 <Lokathor> X seems to be the last one
22:44:51 <MarcelineVQ> Module X
22:44:57 <EvanR> you can use extensible records
22:45:00 <mniip> X11
22:45:10 <EvanR> of methods
22:45:49 <mniip> I hear ed is working on jegalkin polynomials, so, perhaps,
22:45:50 <mniip> Xor
22:45:51 <pacak> OS X...
22:45:52 <EvanR> this language crystal... it almost has duck typing
22:46:03 <EvanR> despite being almost exactly like ruby
22:46:26 <Lokathor> Zygohistomorphic prepromorphisms
22:46:27 <Lokathor> what are those
22:46:51 <EvanR> if a variable has the type A | B | C where  A B C are classes, then you use methods on the variable which are in all A B and C
22:47:19 <mniip> well, imagine you need to repeatedly apply an NT to get deeper into the functor while also having access to history and semi-mutual recursion
22:47:32 <pacak> Lokathor: zygoHistoPrepro :: (Corecursive t, Recursive t) => (Base t b -> b) -> (forall c. Base t c -> Base t c) -> (Base t (EnvT b (Cofree (Base t)) a) -> a) -> t -> a 
22:47:42 <EvanR> whats semi-mutual recursion
22:48:24 <systemfault> Is that actually useful of it exists so we can look awesome on programming channels?
22:48:35 <mniip> yes
22:49:07 <pacak> It actually exists, but in practice you can avoid using it directly...
22:49:13 <pacak> More like in-joke.
22:49:35 <mniip> well yes, much like the monoid in the endofunctor category
22:49:37 <EvanR> im kind of amazed it actually exists
22:49:41 <mniip> technically correct
22:50:08 <EvanR> whats an example of semi mutual recursion
22:51:41 <Lokathor> pacak, i have no idea what you said
22:51:59 <Lokathor> :3
22:52:56 <pacak> Lokathor: recursion-schemes package. Since they merged my TH derivation code you can actually use it on recursive datastructures and ending up writing less/faster code.
22:53:15 <mniip> EvanR, zygo :: (f b -> b) -> (f (b, a) -> a) -> Fix f -> a
22:53:35 <pacak> Lokathor: programming with bananas, lenses and barbed wire paper or something like that.
22:53:45 <Lokathor> that sounds.. cool i guess
22:53:52 <Lokathor> maybe someday i'll do that
22:54:12 <pacak> Lokathor: doc.utwente.nl/56289/1/meijer91functional.pdf
22:54:31 <pacak> :t cata
22:54:33 <lambdabot> Functor f => (f a -> a) -> Mu f -> a
22:55:28 <Lokathor> pacak, have you considered writing a 10 part guide on how to make this into a video game
22:55:31 <Lokathor> because i'd read that :3
22:56:39 <pacak> I wonder which cata is it...
22:57:50 <jchia> I'm trying to convert a 'LoggingT msg (StateT s1 m) a' to a 'LoggingT msg (StateT s2 m) a' for some specific s1 & s2 where s1 is the type of one of the fields in s2. I could do this using zoom (from Control.Lens) but I don't know how to define Zoom & Zoomed for LoggingT. Do I have other, easier, options? (https://hackage.haskell.org/package/logging-effect-1.2.0/docs/Control-Monad-Log.html#t:LoggingT)
22:59:18 <trigone> hi, i'm trying to get how to use dependent types. say i have a function returning a value with a dependent type out of nowhere (a constructor of sorts): i'll be the one to have to check that the value matches the semantics of the type, correct?
23:00:08 <trigone> since the typechecker won't be able to tell if the dependent type matches the value
23:00:33 <pacak> Dependent types in haskell? O_o
23:01:47 <Axman6> trigone: that doesn't sound right. you may want to go through something like the Idris tutorial, which should give you a good feel for what it means to be dependently typed
23:02:07 <pacak> Lokathor: Recursion schemes are useful when you are working with recursive data structures. You can create or fold them using algebras. Or write an algorithm that first creates a structure then folds it back.
23:03:04 <Lokathor> usually i'm just a lame Vector guy :(
23:03:42 <pacak> Lokathor: For example if you are trying to calculate factorial of 10000000000 - it's faster to calculate it as a tree  rathern than trying to multiply them one by one.
23:03:54 <Lokathor> true
23:04:09 <pacak> (a * b) * (c * d) is faster than a * (b * (c * d))
23:04:15 <pacak> :t apo
23:04:16 <lambdabot> error:
23:04:16 <lambdabot>     • Variable not in scope: apo
23:04:16 <lambdabot>     • Perhaps you meant one of these:
23:04:19 <pacak> Ugh.
23:04:47 <pacak> actually no
23:04:50 <pacak> :t hylo
23:04:51 <lambdabot> error: Variable not in scope: hylo
23:04:54 <pacak> Ugh.
23:04:55 <trigone> Axman6: i was just reading a bit of said tutorial. types as first class? does this mean types survive the compilation process in that language?
23:05:06 <pacak> hylo :: Functor f => (f b -> b) -> (a -> f a) -> a -> b
23:05:40 <pacak> takes to algebras - with first one you describe how to consume a tree, second - how to make one
23:06:12 <mniip> trigone, of course
23:06:22 <mniip> relevant arguments aren't erased
23:07:12 <trigone> mniip: i just don't get what you could do once you got a type as value... at least i can gather that types are dynamic to some extent, correct?
23:07:30 <mniip> er?
23:07:41 <mniip> the type of types is open, if that's what you're saying
23:08:39 <mniip> otherwise I don't think it makes any sense to relate dependent and dynamic typing
23:09:35 <trigone> mniip: oh never mind, i just understood that functions creating types only live in signatures, not in the rest of the code.
23:09:49 <mniip> well
23:10:12 <trigone> mniip: so why can't types be erased after the compilation process like in haskell?
23:10:13 <mniip> f : Int -> Type
23:10:17 <mniip> f 3 = Char
23:10:38 <ReinH> Because types are values in dependently typed languages.
23:10:44 <ReinH> And values are not erased.
23:10:53 <mniip> trigone, I think it should be obvious, the code needs to know the value of types at runtime
23:11:26 <trigone> ReinH: hmm... but you'll only use (f 3) in signatures, correct?
23:11:47 <mniip> well, you cannot pattern match a type directly
23:11:56 <mniip> but there are equality proofs
23:12:12 <mniip> that will need to be passed around at runtime if they are used around relevant arguments
23:12:18 <ReinH> The idea that signatures are a special, separate language is exactly what is incorrect
23:12:40 <ReinH> dependently typed languages do not have separate type and value languages
23:12:41 <mniip> yeah, in dependent types there is not difference between terms and values
23:12:51 <mniip> terms and types*
23:12:59 <trigone> what is idris's affiliation wrt haskell? it seems very similar to some degree
23:13:01 <trigone> i see
23:13:14 <ReinH> It's borrowed a lot of Haskell's syntax.
23:13:18 <mniip> idris is written in haskell
23:13:20 <MarcelineVQ> Idris is hosted by haskell
23:13:21 <Axman6> well, Idris is written in Haskell right?
23:13:32 <trigone> how fast is idris?
23:13:43 <Axman6> it compiles to Haskell, so that fast
23:13:45 <ReinH> Well, Haskell is hosted in C, and Haskell isn't very much like C.
23:13:47 <Axman6> (IIRC)
23:13:48 <MarcelineVQ> what an interesting question
23:13:53 <mniip> and yes, haskell is de-facto the language of functional programming papers, so if you want to reinvent as few wheels as possible, you'd want to used haskell syntax
23:14:09 <pacak> Axman6: It compiles to all sorts of things, but generated code is not exactly efficient.
23:14:21 <Axman6> ReinH: not sure how comfortable I am with that, the amount of C requitred for GHC these days is mostly just the RTS
23:14:41 <ReinH> Idris is not conceptually different.
23:14:48 <ReinH> It could be more self-hosting than it is.
23:15:06 <trigone> what are the reasons to choose idris or haskell and vice versa?
23:15:09 <ReinH> I'm just pointing out that the host language doesn't imply much about the nature of the hosted language
23:15:32 <pacak> trigone: If you want to write real world programs - use Haskell.
23:15:36 <Axman6> do you want to use dependent types to more closely model your domain? then use Idris
23:15:37 <MarcelineVQ> haskell has a lot more libraries to choose from so that's a pretty big bias towards it
23:15:49 <mniip> and yes, haskell is de-facto the language of functional programming papers, so if you want to reinvent as few wheels as possible, you'd want to used haskell syntax
23:15:51 <mniip> oops
23:15:53 <Axman6> but they;re not really comparable at the moment
23:16:02 <pacak> Idris is pacman complete, but there's not much practical use of it at the moment.
23:16:07 <mniip> pacak, haha that saying has sure changed a lot in recent years
23:16:38 <ReinH> If Idris had first-class FFI with Haskell like Agda does, I think it would be used more.
23:16:55 <ReinH> That's the thing I'm the most sad about with Idris atm.
23:17:09 <Axman6> hmm, yeah no Haskell FFI is pretty bad
23:17:24 <ReinH> I would really like to write the core of a system in Idris, say something like xmonad, and the driver in Haskell.
23:17:36 <pacak> I looked at code (javascript) generated by Idris recently - it looked pretty ugly.
23:17:44 <ReinH> I think you'd see a lot more of that sort of design if Idris had a great Haskell FFI story.
23:17:52 <trigone> agda is another dependently typed language?
23:17:59 <ReinH> Yes.
23:18:06 <mniip> agda is less of a programming language
23:18:16 <mniip> and more of a proof assistant of sorts
23:18:17 <ReinH> Idris is sort of like the child of Agda and Haskell.
23:18:41 <ReinH> It's somewhere between the two on the programming language <-> proof assistant continuum
23:18:46 <MarcelineVQ> that story can change, idris has an extensible ffi, iirc for example there's c and js atm
23:18:51 <cocreature> agda is somewhere between idris and Coq on the continuum
23:18:52 <pacak> ReinH: There's bytestring-fiat - if you don't mind using coq instead of Idris.
23:19:00 <ReinH> cocreature: Heh, yes.
23:19:01 <Axman6> Idris aims to be a useful depenbdently typed language, Adga, Coq and Isabelle are proof assistance, which may make it possible to produce useful code in other languages
23:19:08 <johnw> pacak: thanks for the mention :)
23:19:09 <glguy> https://glguy.net/smallstep/TypeSystem.html
23:19:33 <glguy> exercises in agda I was working on tonight from the software foundations book, for example
23:19:53 <ReinH> I do =enjoy proper mixfix
23:19:54 <trigone> mniip: proof assistant, in two words? they're just used to prove math theorems? or more like, to be an illustration of math research?
23:20:03 <ReinH> That was a typo but it works
23:20:17 <Axman6> trigone: btw, my understandingh of yuour level of experience with Haskell would suggest you should spend some more time learning haskell, because doing so will make understanding what's going on in Idris much simpler
23:20:20 <cocreature> trigone: not only math theorems. they are often also used to prove things about programs
23:20:22 <mniip> trigone, yes and so much more
23:20:26 <pacak> glguy: Looks too unicodish to my taste...
23:20:40 <glguy> pacak: then you'd just not use Unicode
23:21:02 <trigone> cocreature: right, i included programs in math in the general idea of "sciences that are based on logic"
23:21:11 <ReinH> tpacak: The unicode is entirely optional, and there's an agda input mode for emacs that makes it... well, not quite a joy, but pretty ok to work with.
23:21:31 <ReinH> trigone: you can also include programs in math in the "they are math" sense.
23:21:34 <trigone> Axman6: you're right, but one does not preclude the other. and i'm curious.
23:21:45 <mniip> hmm, is there a category of logic systems
23:21:50 <mniip> with logic homomorphisms
23:22:00 <cocreature> to quote bob harper “math is just applied computer science”
23:22:09 <pacak> ReinH: https://www.reddit.com/r/rust/comments/5penft/parallelizing_enjarify_in_go_and_rust/dcsgk7n/
23:22:14 <mniip> (if A |- B then f(A) |- f(B))
23:22:37 <ReinH> pacak: I've seen that. Obviously one can abuse unicode.
23:23:03 <EvanR> and computer science is applied philosophy :)
23:23:29 <ReinH> Although that particular example is more of an indictment of golang than unicode
23:23:49 <trigone> pacak: there are fonts using ligatures to simulate unicode but that are saved on disk in ascii format. sadly does not work on vim
23:24:03 <qqumber> ReinH: hi. What's your current feeling? fear, joy, anxiety, neutral, energic?
23:24:04 <pacak> > let ᐸElementTᐳ = 2 in let (☭) = (+) in ᐸElementTᐳ ☭ 3
23:24:06 <lambdabot>  5
23:24:08 <trigone> philosophy is applied narcissism so...
23:24:10 <ReinH> trigone: They work in vim if your vim is running in a terminal where they work
23:24:42 <ReinH> And actually iirc there is a patch to vim
23:24:45 <trigone> ReinH: interesting, i'll check that
23:24:52 <ReinH> for gvim
23:24:53 <trigone> iirc?
23:24:59 <ReinH> if I recall correctly
23:25:09 <Axman6> trigone: re what is a proof assistant, they are used to prove properties about programs. the seL4 microkernel, a project at the company I work for, is the world's first formally verified operating system kernel, which has been proven that it will never crash short of hardware failure, as well as several security properties about information flow between processes it hosts
23:25:22 <trigone> i prefer vim in terminals
23:26:11 <ReinH> They work in (vim in) iTerm, for example.
23:26:15 <trigone> Axman6: is there a chance to use it for real computers soon? does that mean it's safe from security breach? that latter question is mere curiosity
23:26:24 <trigone> ReinH: iterm is mac right
23:27:03 <Axman6> trigone: another L$ microkernel produced by the same team is, with very high probability, running you your phone right now, with Linux running on top of it, so yes
23:27:11 <johnw> trigone: yes, a very high chance
23:27:15 <ReinH> Yes.
23:27:31 <ReinH> You can look at Fira Code's terminal support https://github.com/tonsky/FiraCode
23:27:46 <Axman6> seL4 is open source, and being used in a few different applications. verified avionics for drones is one of the uses at the moment (much of the work has been done for a larger project with DARPA)
23:28:14 <Axman6> L4*
23:29:14 * hackagebot streaming-concurrency 0.3.0.1 – Concurrency support for the streaming ecosystem – https://hackage.haskell.org/package/streaming-concurrency
23:29:14 * hackagebot streaming-with 0.2.0.0 – with/bracket-style idioms for use with streaming – https://hackage.haskell.org/package/streaming-with
23:29:17 <Axman6> trigone: the team is working with defence researchers in Australia to build high security systems for dealing with classified data too, regarding your second question
23:29:44 <trigone> Axman6: that's cool
23:30:13 <qqumber> trigone: your current mood is what? What's an appropriate mood?
23:30:19 <trigone> if i learned to use dependent types, would i have trouble coding without them afterwards? as in, would that cause me heartache?
23:30:26 <trigone> qqumber: i'm sorry?
23:30:41 <johnw> trigone: no, you'd be fine afterward
23:31:04 <mniip> I concur
23:31:06 <Axman6> just a little sad occasionally
23:31:10 <Axman6> like learning Haskell
23:31:19 <mniip> can't wait for dependent haskell
23:31:34 <qqumber> trigone: I'm trying to find functional moods. I don't know what a correct mood is. I'm like a child that's chosing food: just going to eat candy for dinner. So I don't know how much and what I should feel to be functional.
23:32:30 <trigone> johnw: but would i not keep telling myself "ah if only i could use dependent types...". because it's harder for me to code in non-functional/strongly-statically typed languages now. does not bother me since haskell is very useful.
23:32:44 <johnw> trigone: I work in a dependently-typed language, and I find myself using them sparingly
23:32:59 <Axman6> trigone: http://ts.data61.csiro.au/projects/ has lots of info about high assurance systems, many of which use dependently typed languages/proof assistants to verify important properties
23:33:05 <johnw> they have great value, but using them everywhere is often more than what is needed
23:33:14 <trigone> qqumber: drinking is not conducive to good coding...
23:33:22 <Axman6> trigone: I disagree
23:33:38 <Axman6> drinking lubricates the mmind and lets the code flow :)
23:33:42 <qqumber> trigone: so what are you feeling right now, what is your mood?
23:33:45 <trigone> Axman6: depends how much
23:33:55 <qqumber> trigone: what is your general mood and is it functional?
23:33:56 <Axman6> indeed
23:34:11 <trigone> qqumber: between blue and green
23:34:12 <qqumber> Axman6: what are you feeling right now? joy, stress, fear, anger, nothing?
23:34:31 <Axman6> pure contentment, so as to not have any affect on the state of the world
23:34:43 <mniip> hmm
23:34:52 <trigone> qqumber: heisenberg risks making your questioning influence the mood of your questionee
23:35:02 <mniip> drinking makes me talk about HoTT (or another thing I just learned) to everybody, not code
23:35:26 <trigone> Axman6: i'll look into your link, sounds interesting
23:35:27 <grmp> HoTT is so fun!
23:35:38 <Axman6> HoTT is so hot right now
23:35:54 <trigone> i keep forgetting what that is
23:36:13 <grmp> homotopy type theory?
23:36:23 <qqumber> mniip: what are you feeling right now? 
23:37:06 <trigone> grmp: thx
23:37:09 <mniip> sadness with notes of depression? but that's because of things irrelevant to haskell
23:37:46 <qqumber> mniip: but that's ok to feel, you're still being fully functional despite that?
23:38:24 <mniip> when we speak of 'functional' here in this channel that is not quite what we mean...
23:38:29 <trigone> Axman6: they really used haskell to write the kernel?
23:39:08 <qqumber> mniip: I mean, does this sadness cause you to get worn out or something?
23:39:12 <Axman6> they used it for part of the process
23:39:35 <trigone> Axman6: the rest was in C?
23:39:40 <mniip> I don't think there's a correlation
23:40:27 <trigone> i kinda wonder how you can prove a C program works as expected... that gotta be hard.
23:40:43 <Axman6> there was a translation from Isabelle HOL to Haskell, and then one from Haskell to C, but these steps were all verified (IIRC)
23:41:43 <trigone> to prove a program works well, do you have to specifically write another program in a proof assistant language, or can you create checkers that would take a wide variety of programs as input?
23:41:55 <trigone> Axman6: Isabelle HOL?
23:42:11 <Axman6> @google Isabelle HOL
23:42:12 <lambdabot> https://www.cl.cam.ac.uk/research/hvg/Isabelle/
23:42:15 <johnw> trigone: there are a variety of approaches
23:42:46 <qqumber> mniip: do you regulate your emotions/moods or do you just let them happen?
23:42:50 <johnw> trigone: including those two you just mentioned
23:43:00 <mniip> trigone, you could define propositions reasoning about pieces of code
23:43:12 <trigone> Axman6: you telling me they wrote a kernel with a proof assistant before rewriting it in haskell then C?
23:43:13 <Axman6> one approach that team is using is writing domain specific languages which have just enough power to express their problem domain, to greatly aid in the verification. I believe they're working on one for making a verified file system for use by things like seL4
23:43:21 <Axman6> trigone: yes
23:43:22 <mniip> introduce some axioms (the C ISO)
23:43:31 <mniip> and then start proving theorems about *your* pieces of code
23:44:01 <trigone> ok... so there is a level of reusability
23:44:05 <mniip> qqumber, with all due respect I doubt this has anything to do with haskell
23:44:36 <qqumber> mniip: but I have to know D: so that I can get into an appropriate state so that I can code haskell
23:44:38 <Axman6> part of that process is ensuring that you don't produce anything in that translation which may be undefined or ambigupus in the target language, so all the proofs ensured that there wasn't any integer overflow or our of bounds array accesses, so that the C code is only working on the defined part of its specification
23:44:49 <Axman6> (and then they use a verified C compiler to compile that C)
23:45:08 <trigone> how did they compile the compiler? autocompiling?
23:45:25 <qqumber> mniip: can't you just tell me, and then we'd be done with it and.. things would be good
23:45:29 <johnw> trigone: just curious, but are you asking purely from interest, or do you want to use these techniques?
23:45:35 <trigone> unless they used a compiler written with haskell or whatever
23:45:49 <mniip> johnw, that's some kind of metacuriosity
23:46:04 <Axman6> you compile the compiler using another compiler, and then compile itself with itself
23:46:05 <trigone> johnw: no so far it's mostly curiosity. but i did read what you wrote, thanks btw
23:46:08 <mniip> infinity-groupoids!
23:46:22 <trigone> Axman6: hm... yeah and you check they're both the same
23:46:27 <Axman6> but it's relatively easy to stick to the fully defined subset of C
23:46:37 <trigone> no wait
23:46:38 <pacak> In addition to verified C compiler you need verified OS and verified hardware.
23:46:53 <Axman6> pacak: enter seL4 =)
23:47:08 <mniip> Axman6, it's still tainted
23:47:20 <mniip> with whatever system you were developing it on first
23:47:23 <Axman6> and RISC-V
23:47:38 <Axman6> mniip: this ain't homeopathy :P
23:48:42 <pacak> Axman6: verified manufacturing process, ECC all over the place....
23:49:34 <trigone> what is the crucial type of issue that having such a very-verified kernel attempts to avoid?
23:49:39 <mniip> Axman6, I think you should design a cpu from scratch on paper, then compile it into LEs by hand, then assemble them out of "dumb" parts
23:50:14 <mniip> that could be used to bootstrap an IC manufacturing facility
23:50:47 <mniip> then with that you can (after manually checking) pick an open-source risc cpu design
23:50:49 <Axman6> trigone: how often would you like the plane you're flying on to fall out of the sky because the entertainment system write to some memory it shouldn't ahve?
23:50:55 <mniip> implement a C compiled in machine code
23:51:30 <mniip> compiler*
23:51:32 <pacak> Right, bootstrapping all the things from source by hands.
23:51:53 <pacak> Because compilers can insert backdoors :)
23:51:58 <mniip> yes
23:51:59 <Axman6> mniip: https://www.youtube.com/watch?v=lNa9bQRPMB88?
23:52:02 <mniip> and so can IC manufacturers
23:52:04 <Axman6> uh, https://www.youtube.com/watch?v=lNa9bQRPMB8
23:52:07 <trigone> Axman6: no i see what you mean, but what about the rest of the code? are softwares usually more problematic than kernels, precisely because even without being as well checked, most kernels are much more heavily scrutinized?
23:53:07 * hackagebot hoauth2 1.3.0 – Haskell OAuth2 authentication client – https://hackage.haskell.org/package/hoauth2
23:53:32 <trigone> pacak: you mean corrupted compilers or just plain mistakes?
23:53:39 <Axman6> trigone: sure, there's many factors, but having something like seL4 means you can have formally verified avionics code running next to say the ADS-B transponder code without needing to worry that the transponder code could crash the airplane because it's taking longer than it should to send a packet
23:54:10 <Axman6> a verified kernel isn't a sufficient thing to guarantee safety or security, but it is an important component in making a safe or secure system
23:54:20 <pacak> trigone: Intentionally modified to insert backdoors in all the code they compile and to insert backdoor installing backdoor if asked to compile themselves.
23:55:58 <trigone> Axman6: of course. i'm thinking in fact it's logical to focus on kernels first because they'd be used in many more machines than any software (since every machine has a kernel or whatever else equivalent)
23:56:21 <trigone> pacak: that's not nice.
23:56:26 <Axman6> you should read some of their papers :)
23:56:34 <pacak> trigone: Welcome to real world.
23:56:52 <mniip> trigone, let me tell you the story of RDRAND the wise
23:57:10 <trigone> Axman6: why that specific advice?
23:57:58 <trigone> Axman6: not that i'm against it but it looks like you mean i'd need it
23:58:47 <Axman6> you'll find them interesting, and they'll go a much better job of explaining the motivations and properties you want in these systems than I could
23:59:18 <Axman6> do*
23:59:49 <trigone> if you can prove a program works well, is it easier from then on to write a malicious program that does things very surreptitiously?
