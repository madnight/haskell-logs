00:00:03 <Lokathor> cocreature, you're a copal
00:10:24 <cinimod> If I say `f :: (forall (n :: Nat). KnownNat n => S.R n -> z)` then the typechecker is happy
00:11:09 <cinimod> But if I say `f :: forall (n :: Nat). KnownNat n => S.R n -> z` then I get `error: Not in scope: type variable ‘z’`
00:12:12 <cinimod> Of course I can say `f :: forall (n :: Nat) z . KnownNat n => S.R n -> z`
00:12:36 <cinimod> But how come brackets bring things into scope?
00:13:00 <cocreature> Lokathor: is a copal someone that everybody hates?
00:13:25 <Lokathor> i've never learned what the co in comonad means
00:13:41 <c_wraith> cinimod: it is because if there is no top-level forall, it's implicit that there is a forall on all unquantified variables
00:13:42 <cinimod> it means reverse the arrows
00:13:42 <MarcelineVQ> is the first one possibly   f :: forall z. (forall (n :: Nat). KnownNat n => S.R n -> z)
00:14:15 <c_wraith> cinimod: if you put the forall inside parens, it's no longer considered top-level, even if it's logically equivalent
00:14:36 <Lokathor> cinimod, but "pal" has no arrows :(
00:14:40 <c_wraith> cinimod: it's a bit of a hack.  mixing implicit and explicit quantifiers goes that way
00:14:43 <cinimod> lol
00:14:59 <MarcelineVQ> mm, I think contra means reversed arrows not co, yeah?
00:15:28 <cinimod> You write down the monad diagrams and reverse the arrows
00:17:34 <Lokathor> what's a monad diagram
00:17:47 <MarcelineVQ> appearantly the co of cofunctor means contra anyway ehe
00:18:03 <Lokathor> Look, I'm just a Java programmer who wandered into the wrong type system
00:18:50 <c_wraith> Lokathor: in category theory, you do all your work by drawing pictures.
00:19:02 <Lokathor> oh
00:19:02 <MarcelineVQ> it's the square the math teachers draw in monad tutorials
00:19:10 <c_wraith> Lokathor: the pictures have lots of directed arrows in them.
00:19:21 <slack1256> cabal configure --ghc-options='-fno-code' will type check every module on cabal build, right?
00:19:25 <c_wraith> Lokathor: a co-thing is a thing with the direction of the arrows reversed
00:19:40 <Lokathor> i never saw those videos :(
00:19:48 <Lokathor> i always just listened to the audio
00:20:15 <`Guest00000> how much worse using (Chan String) is than already using String?
00:20:21 <slack1256> and `cabal configure` will just typecheck those module that have changed on each cabal build?
00:20:51 <Lokathor> `Guest00000, a Chan String is for a totally different thing than just a String
00:21:14 <MarcelineVQ> gosh this Eugenia Cheng monad vid is 9 years old now
00:21:27 <cocreature> `Guest00000: if you are asking whether you should be using a "Chan Text" instead, the answer is probably yes ;)
00:21:49 <`Guest00000> cocreature: i intend this for printing diagnostic messages
00:21:58 <`Guest00000> maybe i can just roll with String
00:22:03 <`Guest00000> Chan String *
00:22:31 <c_wraith> Lokathor: well, in the case of Monad/Comonad, it's kind of easy.  First, use the traditional monad operations, "return :: a -> m a" and "join :: m (m a) -> m a". Reverse the arrows (and rename things a bit).  "extract :: w a -> a" and "duplicate :: w a -> w (w a)"
00:23:01 <Lokathor> a copal sounds like an extraction
00:23:06 <Lokathor> they get you out of sticky situations
00:23:13 <c_wraith> Lokathor: and yes, extract and duplicate are the operations for comonads
00:23:19 <cocreature> `Guest00000: sure you can, whether you should is a different question :) as long as you don’t put some gigantic strings in that chan you’re probably fine and it won’t matter too much
00:23:31 <`Guest00000> thanks
00:23:35 <c_wraith> Lokathor: in that particular case, it's pretty easy to see how the arrows were reversed.
00:23:38 <Lokathor> what is a comonad data type example and why would i care to use it and how would i use extract and duplicate with it
00:24:15 <c_wraith> Lokathor: sometimes it's harder to see how reversing the arrows works because we don't map the category theory arrows to exactly haskell functions.
00:24:23 <[exa]> Lokathor: this is a good reading btw http://www.haskellforall.com/2013/02/you-could-have-invented-comonads.html
00:24:43 <c_wraith> Lokathor: also http://blog.sigfpe.com/2006/12/evaluating-cellular-automata-is.html
00:25:19 <Lokathor> once i did a cellular automata thing and people mentioned that it's a comonad
00:25:33 <Lokathor> i said, "no it's a Data.Vector.Unboxed Bool"
00:25:56 <MarcelineVQ> Lokathor: there's even an edwardk version https://www.schoolofhaskell.com/user/edwardk/cellular-automata
00:25:56 <c_wraith> then it was a bounded universe.  The comonadic variant is for an unbounded universe
00:26:17 <Lokathor> i'm a sucker for edk
00:26:35 <Lokathor> c_wraith, it was. it was for dungeon generation
00:26:58 <Lokathor> i will read some of these later
00:27:12 <Lokathor> for now i think i should fold a list of monsters over a GameState
00:27:22 <Lokathor> dunno if i want foldl' or foldr
00:27:40 <c_wraith> if each monster updates the gamestate, probably foldl'
00:27:47 <MarcelineVQ> there's even https://hackage.haskell.org/package/foldl
00:27:48 <Lokathor> that is the case
00:28:20 <Lokathor> MarcelineVQ, perhaps a bit much for inclusion in a tutorial
00:28:26 <wz1000> what streaming(pipes, streaming, conduit, machines etc) is best when it comes to type safety? i.e., if it compiles, it works, with as few "gotchas" as possible. 
00:29:26 * hackagebot libravatar 0.4.0.1 – Use Libravatar, the decentralized avatar delivery service – https://hackage.haskell.org/package/libravatar
00:30:40 <Lokathor> MarcelineVQ, is the advantage of the package that you can combine the folds into higher folds efficiently?
00:31:44 <c_wraith> Lokathor: yeah.  It's like how "avg :: [Double] -> Double ; avg xs = sum xs / fromIntegral (length xs)" is inefficient.  the foldl package fixes that.
00:31:52 <Lokathor> oh
00:31:57 <Lokathor> well i only need to go through the list once
00:33:01 <Lokathor> http://lpaste.net/357268
00:38:40 <cocreature> wz1000: I don’t think there is any significant difference between the different libs in that regard. all of them are reasonably typesafe but you can also screw up in each of them especially when it comes to resource finalization.
00:46:11 <Lokathor> hmm
00:46:18 <Lokathor> isn't there like a foldM thingy bopper
00:46:42 <Lokathor> there is
00:46:56 <cocreature> there is even foldlM and foldrM although those are relatively new
00:47:27 <`Guest00000> wow, cool, synced IO now
00:47:36 <mrkgnao> how would I parse a Markdown-like language? 
00:47:46 <Lokathor> carefully
00:47:49 <mrkgnao> rather, how would I write a lexer for one?
00:47:55 <Lokathor> Megaparsec might be your jam
00:47:56 <mrkgnao> carefully again, yes
00:48:35 <mrkgnao> no, I'm asking about the "strategy". tokenize as a stream of words?
00:48:41 <Lokathor> oh
00:48:46 <mrkgnao> I might be premature-optimizing here, but that sounds slow
00:49:16 <Lokathor> it's shitty, but you sorta have to do it mostly character based because of how bold and italics work
00:49:26 <mrkgnao> it actually seems that I might have to go character by character
00:49:32 <mrkgnao> yeah, ugh
01:08:04 <cinimod> I have a function `S.mean :: ((1 <=? n) ~ 'True, KnownNat n) => S.R n -> Double`
01:08:15 <cinimod> But I would like to say something like
01:08:35 <cinimod> f :: forall (n :: Nat) . KnownNat n => S.R n -> Double
01:08:48 <cinimod> f x = case natVal (Proxy :: Proxy n) of
01:08:58 <cinimod>    0 -> error "Mean of empty vector!"
01:08:59 <cinimod>  
01:09:08 <cinimod>    n -> S.mean x
01:09:18 <cinimod> Of course this doesn't work
01:09:54 <cinimod> The typechecker still doesn't know n > 0
01:12:34 <wz1000> cinimod: you need to use unsafeCoerce Refl
01:12:39 <wz1000> like so: https://github.com/wz1000/HMat/blob/master/src/Proofs.hs#L43
01:18:26 <antoniooohhh> ..
01:20:23 <Lokathor> defining a random instance is tricky :(
01:20:35 <Lokathor> it won't let me call random of another instance
01:20:36 <ab9rf> a random instance of what?
01:21:18 <Lokathor> http://lpaste.net/357274
01:22:06 <ab9rf> you can use a different instance to define an instance
01:22:13 <ab9rf> you just don;'t have your types ducked up
01:22:44 <Lokathor> do you mean declared
01:23:31 <MarcelineVQ> ducks in a row, aligned, stacked up, lego, skookum, fit
01:24:17 <Lokathor> i'm 99% sure it's just inferring the wrong type
01:24:19 <Lokathor> but i could be wrong
01:24:26 <ab9rf> it 'looks like you're trying to use an Random Integer instance to implement Random Direction
01:24:39 <Lokathor> oh direction works, Maybe is the one that doesn't work
01:24:53 <Lokathor> Directoin works because i swapped it to next
01:25:20 <Lokathor> waht i want is to be able to have random Maybe Direction values generated
01:25:33 <ab9rf> your randomR violates the Random laws
01:25:52 <Lokathor> the laws are nonsensical for unordered things anyway
01:26:19 <ab9rf> enums are ordered, even if you don't care about the order
01:26:38 <Lokathor> it is Show and nothing else, you can't even call < or > on a Direction
01:27:05 <Lokathor> thus, it is impossible to assert that the laws are broken, actually
01:28:19 <ab9rf> i suppose
01:29:19 * hackagebot safeio 0.0.3.0 – Write output to disk atomically – https://hackage.haskell.org/package/safeio
01:29:52 <`Guest00000> is Chan a queue?
01:30:15 <`Guest00000> not bounded
01:30:17 <ab9rf> i'm vaguely surprised there isn't an instance for Random a => Random (Maybe a)
01:30:38 <Lokathor> i gave up and just did it as two lines
01:30:38 <ab9rf> i iamgine such an instance would be fairly easy to write
01:30:47 <Lokathor> since it's being used from MonadRandom anyway
01:32:55 <MarcelineVQ> :t \gen -> first Just (random gen)
01:32:57 <lambdabot> (RandomGen g, Random a) => g -> (Maybe a, g)
01:33:14 <MarcelineVQ> I like that one
01:33:53 <MarcelineVQ> style points  first Just . random
01:34:01 <Lokathor> :t first
01:34:03 <lambdabot> Arrow a => a b c -> a (b, d) (c, d)
01:34:24 <Lokathor> huh
01:34:26 <MarcelineVQ> I use the first from Bifunctor but that one applied just fine here
01:34:30 <MarcelineVQ> *applies
01:35:36 <ab9rf> told you it would fairly easy :)
01:36:58 <MarcelineVQ> > (first (\n -> bool (Just n) Nothing (even n)) . random) (mkStdGen 125)
01:37:00 <lambdabot>  (Nothing,2141140476 2103410263)
01:37:01 <MarcelineVQ> > (first (\n -> bool (Just n) Nothing (even n)) . random) (mkStdGen 126)
01:37:03 <lambdabot>  (Nothing,1340044678 2103410263)
01:37:23 <MarcelineVQ> oops ehe, it was 124 I meant, 124 is a Just, oh well
01:38:26 <MarcelineVQ> I think you wanted evens though, so that bool is backwards anyway
02:27:31 <Lokathor> case getCreatureByID myID dungeon of
02:27:31 <Lokathor>     (Just actor) | isAlive actor
02:27:38 <Lokathor> you can use a guard like that, right?
02:31:58 <MarcelineVQ> yeah but you use -> instead of = on the right
02:32:13 <Lokathor> right
02:32:28 <Lokathor> then 40 lines of if expressions and do blocks
02:32:44 <Lokathor> with a few other lets thrown in for good measure
02:33:27 <MarcelineVQ> idk if it's relevant to what you have but you can combine those a little with pattern guards, myFun | Just actor, isAlive actor = somethinelse
02:33:37 <Lokathor> http://lpaste.net/357275 
02:33:48 <MarcelineVQ> er mor elike    myFun x | Just actor <- x, isAlive actor = somethinelse
02:35:42 <MarcelineVQ> actually I wonder if you can depend on actor in-order like that, lemme double-check
02:36:17 <MarcelineVQ> yep you can
02:37:42 <MarcelineVQ> @let foob x | Just foo <- x, foo > 3 = True | otherwise = False
02:37:43 <lambdabot>  Defined.
02:38:00 <MarcelineVQ> > (foob (Just 3), foob (Just 2), foob Nothing)
02:38:02 <lambdabot>  (False,False,False)
02:38:15 <MarcelineVQ> oops, shoulda said 4, oh well, it's concise though
02:38:33 <Lokathor> asy what now?
02:39:12 <Lokathor> how about edit the lpaste and i'll tell you if it looks better or worse
02:39:21 <lyxia> there's some code duplication
02:39:40 <Lokathor> lyxia, just, like, 1 or two duplicate characters, tops
02:39:44 <MarcelineVQ> It's a bit embarassing to say but I have trouble reading your pastes ehe
02:40:01 <Lokathor> i write only the clearest code :P
02:40:55 <cocreature> everything after the "moveCheck <- getRandom" is duplicated 3 times
02:41:28 <cocreature> and Global and Rustacean have even more duplication
02:42:18 <Lokathor> yes well, you write a gitbook of what you're doing and why every 5 lines of code and see how well you do after 5 weeks
02:42:43 <Lokathor> (PS: the gitbook web editor is stuuuupidly slow so when you type a sentence you have to wait for the fill thing to show up like half a second)
02:42:48 <cocreature> no need to get defensive. I was honestly just trying to help
02:42:58 <Lokathor> no it's fine my copal
02:43:09 <Lokathor> you're right that there's a lot of duplication
02:43:41 <Lokathor> i'll clean it up once the monsters can attack the player
02:43:45 <Lokathor> ...probably
02:49:18 <Lokathor> we need a new operator ?$?!
02:49:31 <Lokathor> and it makes the parens on that line just go how they should until it type checks somehow
02:50:41 <cocreature> the famous dwim operator
02:51:06 <Lokathor> the ! at the end lets you know it might be unsafe to use
02:51:11 <Lokathor> like a lens
02:52:01 <Lokathor> hey the monsters move!
02:52:08 <Lokathor> hey they move right into the walls becasuse they don't respect terrain!
02:52:10 <Lokathor> whoops!
02:54:36 <cocreature> I’m impressed by how determined you seem to be to finish that book
02:54:44 <cocreature> that must take _a lot_ of time
02:54:57 <Lokathor> i took a rest for a while and write some rust libs
02:56:58 <Lokathor> i might have accidentally made rust more tempting for game development than Haskell is >_>
02:59:53 <AndreasK> I would have expected the option of manuel memory management to make rust more tempting to begin with
03:00:34 <Lokathor> that part is less interesting
03:01:43 <Lokathor> but speeds like sonic.jpg and also a sweet cross-platform lib that makes curses of all things totally cross platform, and then i did a nice little wrapper to make it actually friendly to use
03:04:14 <MarcelineVQ> good stuff
03:04:53 <Lokathor> though, even if you run curses at 60fps like a nutter, it can't detect keyup events anyway
03:05:37 <sm> ack
03:06:00 <sm> damnit we need at least to make vty cross-platform 
03:06:16 <MarcelineVQ> what's the barrier for that, terminfo?
03:06:34 <cocreature> the main barrier is that someone needs to sit down and actually do it :)
03:06:41 <Lokathor> vty would need to build against PDcurses on win32
03:06:42 <MarcelineVQ> shucks buster
03:06:45 <sm> I forget, here's the status: https://github.com/jtdaugherty/vty/pull/1#issuecomment-297143444
03:07:55 <Lokathor> i want vty to include a module for painting a picture or image or whatever they call it one character at a time
03:08:54 <sm> what's sonic.jpg ?
03:09:21 <Lokathor> http://knowyourmeme.com/memes/gotta-go-fast
03:09:22 <cocreature> sm: heh I guess I’m not the only one who had trouble googling that ;)
03:09:38 <sm> you're not :)
03:12:36 * sm returns from crazy meme world
03:12:51 <Lokathor> you were gone for 1 million years
03:12:59 <sm> aiieeeee!
03:14:03 <sm> I thought maybe there was some rust game that's stupidly fast, in a way that haskell games aren't
03:14:45 <sm> but it's a million years later, by now haskell has achieved world domination, I guess
03:15:15 <Lokathor> but GHC only builds on redox, because that's the only OS left
03:15:46 <AndreasK> which was rewritten in the V16 Javascript engine
03:15:47 <sm> and vty is cross platform, cabal install works, ghc executables don't crash if $LANG is missing..
03:16:36 <AndreasK> ghc executables crash when lang is missing?
03:17:16 <sm> if it's not set to a locale that can handle all characters being read/written, see https://www.snoyman.com/blog/2016/12/beware-of-readfile
03:17:48 <AndreasK> Oh that one. Yeah I had it crash in the windows console when I didn't set the encoding to utf8
03:17:50 <sm> this affects pretty much all current ghc-compiled programs, as most haskellers find out
03:17:54 <Lokathor> yeah if you try to print out esperanto but you don't have the right codepage you'll just crash
03:17:57 <Lokathor> ~mysteriously~
03:18:04 <sm> it looks bad
03:18:12 <Lokathor> you'll ĉiam crash, one might say
03:18:42 <sm> it DID look bad, a million years ago hahaha
03:19:02 <Lokathor> sm, https://github.com/Lokathor/hexes here contribute to this cross-platform grid display thingy instead
03:19:20 <AndreasK> Is there a ticket for that on ghc trac?
03:19:41 <sm> not sure AndreasK, good question
03:20:53 <sm> Lokathor: that sounds good for games.. I am hooked on the extra ui features provided by brick, which is vty-based
03:21:44 <Lokathor> i'm sure you can build brick on top of this :3c
03:22:00 <sm> probably, and I guess it would be much faster
03:23:05 <sm> why do you call it hexes ? seems a bit unclear for marketing
03:23:26 <AndreasK> If there is a ticket it doesn't come up when searching for unicode crash.
03:23:31 <sm> oh, like curses. But it always makes me think it's only for hex-grid wargames
03:23:38 <Lokathor> sadly so
03:23:45 <Lokathor> perhaps a rebrand
03:23:52 <Lokathor> it's not on hackage yet so it's not too late
03:23:57 <sm> +1
03:24:54 <sm> tiles ? boring I know
03:25:50 <Lokathor> we need at least a _little_ zip in the name
03:26:01 <sm> supertiles
03:26:11 <Lokathor> I think that "Hexes is Curses for Haskell" explains it well enough
03:26:17 <Lokathor> says that right at the top
03:26:36 <MarcelineVQ> Churses
03:26:37 <Lokathor> though, perhaps those who are not english natives wouldn't immediately get it
03:26:49 <sm> curses, though, only does primitive character graphics and has a reputation for being slow
03:27:28 <`Guest00000> weird behavior
03:27:30 <Lokathor> this will soon enough do any tile mapped graphics
03:27:43 <Lokathor> you know, once i finish all my other things in my queue
03:27:52 <`Guest00000> i send commands to another thread to print messages in console
03:28:10 <`Guest00000> using Chan
03:28:15 <sm> so it's really more exciting and game-y than curses. And (I assume) not as handy as curses if you do just want to render characters
03:28:48 <`Guest00000> but they don't even seem do be delivered
03:28:59 <Lokathor> at the moment drawing just 1 update is wildly inefficient because i'm using the wrong vector type
03:29:06 <Lokathor> but in the next version i'll fix that
03:29:22 * sm 's dreams crash to earth.. waa it's still 2017
03:29:41 <`Guest00000> until this thread spawns another thread
03:29:51 <`Guest00000> then the messages show up
03:30:06 <MarcelineVQ> `Guest00000: check your buffering mode, might matter, dunno
03:30:09 <sm> `Guest00000: compiled with --threaded ?
03:30:12 <Lokathor> `Guest00000, well you do need someone to read out of the channel and use them, yes
03:30:15 <`Guest00000> MarcelineVQ: it's fine
03:30:18 <`Guest00000> sm: no :)
03:30:27 <sm> -threaded
03:30:44 <`Guest00000> well thanks
03:30:49 <`Guest00000> this solved it.
03:31:33 <Lokathor> sm, if you know much at all about opengl you should take a look
03:31:44 <Lokathor> also if you use it and want more features you should file issues
03:32:05 <sm> I'd like to, but can't justify it.. sorry
03:32:06 <Lokathor> though, "implement brick on top of this" might get a wontfix
03:32:27 <Lokathor> justify in the time sense?
03:32:33 <sm> yup
03:32:50 <sm> and I know what you're going to say... "in the time you spent chatting in here..."
03:33:08 <Lokathor> oh no i wouldn't say that
03:33:15 <Lokathor> opengl is a nightmare
03:33:19 <sm> ok :) because I have arguments ready.
03:33:33 <sm> "that's a different kind of time. I'm not allowed to code at this time of night. etc." :)
03:33:45 <Lokathor> not allowed? by who?
03:34:10 <sm> myself. And more importantly, my wife
03:34:44 <sm> no more workaholic hacking nights for me, it's too costly
03:34:55 <cinimod> wz1000: turned out to be even easier:
03:35:05 <cinimod> bazz :: forall n . KnownNat n => S.R n -> Double
03:35:05 <cinimod> bazz n = case (Proxy :: Proxy 1) %<=? (Proxy :: Proxy n) of
03:35:05 <cinimod>           LE  Refl -> S.mean n
03:35:05 <cinimod>           NLE _    -> 0
03:35:31 <Lokathor> sm do you live in hawaii?
03:35:39 <sm> california
03:35:41 <cinimod> the `typelits-witnesses` does all the work
03:35:47 <cinimod> package
03:35:48 <Lokathor> do you know the time there?
03:36:07 <sm> yes ?
03:36:18 <Lokathor> how is 3am not a "workaholic hack night"?
03:36:33 <sm> ..I'm not hacking ?
03:36:39 <sm> no, I see your point
03:36:41 <Lokathor> oh okay
03:36:43 <sm> and will go :)
03:36:55 <sm> thanks for your work on the book, will check out the latest some time
03:36:55 <Lokathor> but
03:36:57 <Lokathor> the monsters move!
03:37:08 <sm> \o/ go go
03:37:25 <sm> good luck o/
03:37:30 <`Guest00000> i need the ability to create modified Chans
03:37:30 <Lokathor> o7
03:37:41 <Lokathor> `Guest00000, modified how?
03:38:20 <`Guest00000> you have original chan, you make a modified duplicate, and now whenever you write x to it, (f x) is written to the original chan
03:38:28 <`Guest00000> or
03:38:59 <`Guest00000> chans which before modify the written value first
03:39:05 <`Guest00000> before writing *
03:39:20 <`Guest00000> so you write 5 and read back 6
03:39:29 <Lokathor> i'm afraid you can only do that with a modified read function
03:39:33 <Lokathor> not a modified channel
03:40:47 <Lokathor> :t readChan
03:40:49 <lambdabot> error: Variable not in scope: readChan
03:40:54 <Lokathor> :t readIORef
03:40:56 <lambdabot> error:
03:40:56 <lambdabot>     • Variable not in scope: readIORef
03:40:56 <lambdabot>     • Perhaps you meant ‘readSTRef’ (imported from Data.STRef)
03:41:04 <Lokathor> :t readSTRef
03:41:05 <lambdabot> STRef s a -> ST s a
03:41:22 <Lokathor> :t fmap (+1) (\ref -> readSTRef ref)
03:41:25 <lambdabot> Num (ST s a) => STRef s a -> ST s a
03:41:45 <Lokathor> hmmm
03:42:11 <`Guest00000> why not? i think it's implementable easily
03:42:45 <`Guest00000> just store actual read/write functions in the (Chan a), and just modify them on creation of new chans
03:43:56 <Lokathor> oh, like if you built your own chan?
03:43:56 <Lokathor> sure
03:44:02 <`Guest00000> hm, that means i can make MyChan's without modifying the library
03:44:21 <`Guest00000> but why not add it to the original lib
03:51:10 <parazyd> last step :/
03:51:22 <parazyd> could anyone please shed some light on this: http://sprunge.us/CWhY
03:59:19 * hackagebot data-flags 0.0.3.4 – A package for working with bit masks and flags in general. – https://hackage.haskell.org/package/data-flags
04:03:17 <lyxia> parazyd: this Ganeti package seems to depend on an older version of template-haskell
04:03:47 <parazyd> lyxia: there is no such package. is it a part of something else?
04:04:40 <parazyd> oh, dev-haskell/template maybe? it wasn't pulled even (it's not installed)
04:05:09 <lyxia> parazyd: ganeti is not on hackage, but I found its source here https://github.com/ganeti/ganeti/tree/master/src
04:05:27 <lyxia> parazyd: template-haskell is bundled with ghc
04:06:03 <parazyd> hmm, i've 8.0.2. maybe i can try 8.0.1? it's in the haskell overlay
04:06:13 <lyxia> parazyd: basically to compile ganeti you need ghc 7.10.3 or lower.
04:06:20 <parazyd> oh...
04:07:02 <lyxia> parazyd: or you can try modifying the source by hand
04:07:17 <parazyd> i tried patching it by removing the last _ in the arglist
04:07:23 <parazyd> but it made a mess
04:07:46 <lyxia> what happened
04:07:58 <parazyd> more errors
04:08:28 <parazyd> hold on, i can try again
04:09:26 <lyxia> parazyd: actually it seems they require an even older version, 7.8 for now https://github.com/ganeti/ganeti/issues/1222
04:09:45 <parazyd> lyxia: think it's better to try that out than patching?
04:14:31 * hackagebot data-sword 0.2.0.2 – Shorter binary words – https://hackage.haskell.org/package/data-sword
04:15:20 <lyxia> parazyd: yeah
04:15:35 <parazyd> alright. thanks tor the tip
04:19:18 <`Guest00000> help plz
04:20:18 * hackagebot SSTG 0.1.1.0 – STG Symbolic Execution – https://hackage.haskell.org/package/SSTG
04:20:19 * hackagebot network-ip 0.3.0.2 – Internet Protocol data structures – https://hackage.haskell.org/package/network-ip
04:21:33 <`Guest00000> i have ((w `race` accept s) >>= cont) where w waits for a flag and cont writes to console if the flag is set. problem is w doesn't finish before something happens with the socket (for example a new client connection is started)
04:22:40 <`Guest00000> and i need w to react to the flag immediately
04:23:32 <lyxia> What do you want your program to actually do?
04:24:23 <`Guest00000> why do you ask this? i'm confused and want to understand this and solve this generally
04:25:31 <lyxia> I don't understand the problem.
04:27:11 <lyxia> `Guest00000: if 'accept s' finishes, do you want w to keep waiting?
04:30:32 * `Guest00000 is back
04:35:41 * Guest0000 is sorry
04:38:05 <MarcelineVQ> `Guest00000: <lyxia> `Guest00000: if 'accept s' finishes, do you want w to keep waiting?
04:39:16 <`Guest00000> MarcelineVQ: lyxia: i don't care
04:40:05 <lyxia> then what's the problem
04:41:09 <`Guest00000> lyxia: problem is `race` description says (a `race` b) returns if a returns
04:41:31 <`Guest00000> and a should return because it waits for a flag which is already set
04:41:38 <cocreature> no it says “Run two IO actions concurrently, and return the first to finish.”
04:41:49 <cocreature> that’s the whole point of race
04:42:49 <`Guest00000> how your description is different from mine?
04:42:56 <`Guest00000> a finishes first
04:43:08 <`Guest00000> or anyway it should
04:43:10 <cocreature> well you didn’t tell us that a finishes first.
04:43:36 <cocreature> I still don’t know which behavior you would like and what the current behavior of your code is
04:43:44 <cocreature> you’ll need to give us a bit more details
04:43:46 <`Guest00000> i think i already described it
04:43:59 <lyxia> you told us the opposite. "problem is w doesn't finish before something happens with the socket (for example a new client connection is started)"
04:44:10 <cocreature> it’s great that you think that but if we don’t understand it you obviously haven’t described it sufficiently for us to help you
04:45:03 <`Guest00000> lyxia: earlier i told what actually happens, and now i described what i want
04:45:44 <cocreature> so you want w to finish first but it doesn’t finish first?
04:46:15 <`Guest00000> i want (w `something` accept s) to finish when a flag is set
04:46:38 <`Guest00000> w waits for the flag
04:46:54 <`Guest00000> but 'accept' for 'something' doesn't do it
04:46:57 <`Guest00000> err
04:46:58 <`Guest00000> 'race'
04:47:13 <lyxia> w `concurrently` accept s  ?
04:47:47 <cocreature> so you want to wait until "w" returns even if "accept s" finishes first?
04:47:55 <`Guest00000> noo
04:48:09 <`Guest00000> ok, from start
04:48:22 <`Guest00000> w waits for the flag, then exits
04:48:59 <`Guest00000> hence *i think* that (w `race` accept s) should exit when the flag is set, if there is no activity at the socket
04:49:12 <`Guest00000> but it doesn't
04:49:22 <`Guest00000> i'm confused and i want this behavior
04:49:57 <lyxia> That seems like a reasonable expectation
04:50:12 <cocreature> are you on windows by any chance?
04:50:20 <`Guest00000> it's true, i'm on windows
04:50:41 <cocreature> are you using the threaded or the nonthreaded runtime?
04:50:45 <`Guest00000> -threaded is set
04:51:36 <cocreature> afaik nonblocking IO on windows is not really implemented in GHC atm but I thought with the threaded runtime you can avoid those problems.
04:52:06 <`Guest00000> what do i do?
04:52:39 <`Guest00000> i tried running (accept s) in bound thread, wasn't good
04:52:54 <cocreature> https://ghc.haskell.org/trac/ghc/ticket/7353 looks like the relevant issue.
04:53:54 * hackagebot genvalidity-aeson 0.0.0.0, text-lips 0.1.0.1, validity-aeson 0.0.0.0, genvalidity-scientific 0.0.0.0, … and 5 more
04:53:54 * hackagebot  → https://hackage.haskell.org/packages/recent
04:53:55 <cocreature> I’m not sure if there is a workaround
04:56:08 <`Guest00000> well, thank you
04:56:30 <`Guest00000> a crude workaround is making a second process and talking to it
04:57:10 <budand> hey #haskell
04:57:25 <budand> could anyone recommend a lens tutorial?
04:57:39 <budand> I am looking for one that "starts from scratch"
04:59:03 <lyxia> https://hackage.haskell.org/package/lens-tutorial-1.0.0/docs/Control-Lens-Tutorial.html
04:59:08 <lyxia> http://www.mchaver.com/posts/2017-07-12-lens-tutorial-1.html
04:59:31 <budand> cool, thanks lyxia
05:18:23 * hackagebot system-info 0.1.0.8 – Get information about CPUs, memory, etc. – https://hackage.haskell.org/package/system-info
05:34:52 <vktec> Why do both >>= and =<< exist and which is preferred?
05:35:29 <sbrg> neither is preferred. it's just a matter of style/convenience/personal preference
05:35:36 <JuanDaugherty> what is =<< ?
05:35:44 <sbrg> flip (>>=)
05:35:47 <sbrg> :t (>>=)
05:35:49 <lambdabot> Monad m => m a -> (a -> m b) -> m b
05:35:49 <JuanDaugherty> ah
05:35:50 <sbrg> :t (=<<)
05:35:52 <lambdabot> Monad m => (a -> m b) -> m a -> m b
05:36:01 <vktec> sbrg: Fair enough.
05:36:31 <vktec> Why is there no (<<) to match (>>)?
05:37:08 <JuanDaugherty> you've decomposed a thing that's just an atomic symbol
05:37:28 <JuanDaugherty> (semiotics notwithstanding)
05:37:54 <mniip> why is there no (--) to match (++)
05:37:55 <vktec> What do you mean by that?
05:38:38 <vktec> mniip: Well, that's a different thing. What I'm asking is, since both (>>=) and (=<<) exist, why don't both (>>) and (<<)?
05:38:50 <lyxia> nobody cared to add it
05:39:03 <vktec> Okay
05:39:07 <mniip> =<< is analogous to <*> and <$>
05:39:10 <mniip> and .
05:39:36 <Myrl-saki> mniip: Well, -- kinda removes things, doesn't it? :P
05:39:43 <`Guest00000> is there a library for interpreting numbers (Word8/16/32's) as bit sequences?
05:40:01 <`Guest00000> to translate them to flag sets e.g.
05:40:04 <mniip> as for >> it's usually used with stateful monads, hence a << is somewhat counterintuitive
05:40:18 <mniip> `Guest00000, does Data.Bits work?
05:40:29 <Athas> Cabal tires me so much...
05:40:49 <Myrl-saki> Athas: Use stack!
05:40:54 <sbrg> if we think about >> being kind of like an imperative semi-colon, asking for << is kind of like asking for a semi-colon that reverses the order of effects
05:40:55 <sbrg> i guess
05:41:07 <`Guest00000> mniip: i can use it, but it's kinda uncool
05:41:08 <sbrg> which is kind of counter-intuitive
05:41:14 <vktec> That's true
05:41:16 <`Guest00000> each time
05:41:23 <`Guest00000> i write bitfields
05:41:33 <vktec> Thanks for the clarification :)
05:42:09 <Athas> Myrl-saki: I want to!  But I wanted to try a package (Accelerate) whose installation instructions suggest the use of Cabal, so I wanted to try it out.
05:42:28 <mniip> `Guest00000, could you elaborate on what kind of interface you'd want?
05:43:20 <`Guest00000> mniip: well, like mapping individual bits in a number to something other
05:43:26 <`Guest00000> and backwards
05:43:36 <mniip> "something other" what
05:44:21 <`Guest00000> well I dunno
05:44:24 <sbrg> > let (؛) = flip (<<) in execState (modify (*2) ؛ modify (+1)) 1
05:44:26 <lambdabot>  error:
05:44:27 <lambdabot>      • Variable not in scope: (<<) :: a -> b -> c
05:44:27 <lambdabot>      • Perhaps you meant one of these:
05:44:30 <sbrg> oops
05:44:33 <`Guest00000> maybe something like serializations, only with bits instead of bytes
05:44:34 <sbrg> > let (؛) = flip (>>) in execState (modify (*2) ؛ modify (+1)) 1
05:44:37 <lambdabot>  4
05:44:44 <sbrg> upside-down semi-colon = flip >>!
05:45:01 <stevenxl> Hi folks. I have a question on using Haskell for web development. I want the back-end to be Haskell, and the front-end to be React. There's nothing stopping me from writing "regular react" and just having the server serve the JavaScript file as a static asset right? 
05:45:03 <mniip> :t \x -> map (flip testBit) [0 .. bitSize x]
05:45:04 <lambdabot> (Bits a1, Bits a) => a1 -> [a -> Bool]
05:45:11 <mniip> er
05:45:12 <stevenxl> I don't need to get involve with the various libraries, react-haskell, ghcjs, etc.?
05:45:22 <sbrg> stevenxl: not at all, no. 
05:45:30 <mniip> :t \x -> map (testBit x) [0 .. bitSize x]
05:45:32 <lambdabot> Bits a => a -> [Bool]
05:45:39 <sbrg> stevenxl: if you use servant for your backend, you can ask it to generate JS to consume the API automatically
05:46:17 <sbrg> (and if you go the swagger route, you can generate a haskell backend that uses servant from the swagger codegen CLI utility from a swagger spec I believe)
05:47:17 * hackagebot DOH 0.1.0.0 – A complete API wrapper for DigitalOcean API V2 – https://hackage.haskell.org/package/DOH
05:47:32 <stevenxl> sbrg: So it can generate JS from source files I write in ES6? I don't have to write Haskell that then gets compiled to JavaScript? My big fear is that if I have to write Haskell -> JavaScript, can I use all the pre-built React code out there.
05:48:36 <sbrg> stevenxl: no I think you misunderstood. If you use servant, which is a very nice library for writing type-safe web backends in Haskell, you can get it to generate javascript which talks to your backend. then you can just write JS on the front-end, if you want that
05:50:47 <stevenxl> sbrg: OK. Let me see if I understand. Servant will generate JavaScript that I can use on the front-end to talk to the back-end. However, I can write the front-end however I please, and use the JavaScript generated by servant to make the API calls from the front-end?
05:50:56 <sbrg> exactly
05:51:03 <stevenxl> sbrg: Beatiful! 
05:51:23 <sbrg> see https://www.stackage.org/package/servant-js -- it can even spit out a few different flavors
05:51:23 <stevenxl> Thats pretty awesome. I have to check that out.
05:52:22 <stevenxl> sbrg: thank you!
05:52:25 <sbrg> yw!
05:52:32 <stevenxl> any recommended tutorials besides of course the official docs?
05:53:53 <sbrg> incidentally, servant is one of the (not too many) very well documented haskell libs, with tutorials and stuff. http://haskell-servant.readthedocs.io/en/stable/
05:54:21 <stevenxl> ah - the story gets better and better; very excited for that
05:55:21 * hackagebot DOH 0.1.1.0 – Complete API bindings for DigitalOcean API V2 – https://hackage.haskell.org/package/DOH
06:12:08 * hackagebot th-kinds 0.2 – Automated kind inference in Template Haskell. – https://hackage.haskell.org/package/th-kinds
06:22:43 <`Guest00000> which view pattern you used was the most complex?
07:04:42 <`Guest00000> can i read/write to a handle in different threads?
07:05:51 <hpc> yes
07:09:36 <vktec> How should I sequence a set of items that need to be acted upon at certain "ticks" of a clock? I'm thinking of having a clock thread that puts the current tick number in an MVar which can then be used by the main thread but I can already see potential issues with this method. Is there a better way?
07:13:25 <hpc> frp might help here
07:13:42 <hpc> but i haven't had the occasion to use it myself, so i couldn't recommend a library or what your code would look like
07:18:45 <parazyd> lyxia: with ghc-7.8.4 it went through! :))
07:18:54 <parazyd> thanks a lot for the advice!
07:29:24 <lyxia> parazyd: you're welcome
07:42:23 * hackagebot irc-conduit 0.2.2.2 – Streaming IRC message library using conduits. – https://hackage.haskell.org/package/irc-conduit
07:52:04 <parsnip> hmm, so this `docker: \n    enable:true`, just this line alone may greatly effect my build time? 
07:54:06 <parsnip> "Beware the pitfalls: it does not use docker-compose", whatever
08:00:42 <parsnip> trying momentarily, oh boy
08:12:49 <sm> joeyh: what's happening when you do "propellor spin" commmits ? They seem completely empty
08:13:04 <parsnip> hmm, it's not instance, but the download configure build seems to go a bit faster, but... i had spun up a pretty fast machine, so i'll have to try on a slower machine to make sure it's similarly sped up. 
08:15:48 <parsnip> what is docker speeding up? i'm guessing the download part is trivial now, but are configures and builds still being done from scratch on local? or are those downloaded partially done? 
08:17:27 <sm> parsnip: I'm guessing not many here have used stack's docker support
08:18:54 <joeyh> sm: propellor commits anything in the tree when ru.. I've not bothered to make it avoid empty commits
08:19:16 <sm> aha. thanks
08:19:49 <joeyh> and, I'm often flailing when there's a pile of them, which is amusing/embarrassing to record ;)
08:20:12 <sm> :) I've been browsing commits in a feed reader
08:21:06 <sm> was just curious
08:21:35 * sm waits for secret-project's grand unveiling
08:22:02 <joeyh> well, it just fully, completely, 100% worked (except progress display)
08:22:30 <joeyh> I'll be presenting it at DebConf, August 8th
08:23:00 <sm> \o/ sweet
08:23:19 <joeyh> managed to segfault ghc rts this morning, too! something to do with infinite recursion and/or Data.Typable
08:58:43 <ezyang> anyone using CI services like Travis/AppVeyor/CircleCI to build binaries? 
09:06:49 <osa1> anyone know how to parse a list of tokens using megaparsec? it doesn't have a `Stream [a]` instance so I can't use functions like `token`.
09:10:05 <monochrom> Really?! Maybe you can implement it yourself.
09:10:36 <sm> ezyang: yes
09:11:04 <monochrom> Ah it may require newtype-wrapping your list.
09:11:35 <osa1> monochrom: see the existing instances here: http://hackage.haskell.org/package/megaparsec-6.0.1/docs/Text-Megaparsec-Stream.html no Stream [a] instance there
09:12:33 <monochrom> To be frank, I don't actually trust haddock for this. I have seen in aeson and/or cassava where haddock misses out instances. Probably because they're TH-generated.
09:12:36 <ezyang> sm: When you need multiple builds (e.g., 32-bit/64-bit) do you just maintain separate CI confs for each of them? 
09:13:07 <sm> ezyang: I haven't gone that far, just using appveyor's default builds for windows
09:13:20 <ezyang> ok :) 
09:15:36 <bbear> hello
09:15:49 <bbear> say I have a type data Direction = L Int | R Int
09:15:50 <osa1> hmm looking at the methods providing an instance for [a] would be impossible because you can't implement methods like "advance current position"
09:16:12 <bbear> How can I pattern match the value of the Int without knowledge of the (L) or (R) ?
09:16:24 <Cale> bbear: You can't.
09:16:25 <osa1> bbear: you can't
09:17:03 <glguy> bbear: use a different type:  data Direction = Direction LorR Int; data LorR = L | R
09:18:11 <bbear> glguy: your stuff is going to work ?
09:18:14 <bbear> interesting
09:19:47 <bbear> I can write a function to specifically extract the n 
09:29:29 <bbear> isn't that what Lense is about ?
09:34:25 <bbear> is there something to fold stuff « in place » ?
09:35:34 <bbear> for example if you have [1, 2, 3, 4, 5], you can foldl (+) 0 [1, 2, 3, 4, 5] == 15 ; but how could you have instead [1, 3, 6, 10, 15] ?
09:36:01 <cocreature> > scanl (+) 0 [1,2,3,4,5]
09:36:03 <lambdabot>  [0,1,3,6,10,15]
09:36:14 <bbear> okay
09:36:26 <cocreature> ofc it will produce a new list and not actually be “in place”
09:36:36 <bbear>  > tail $ scanl (+) 0 [1, 2, 3, 4, 5]
09:36:43 <bbear> > tail $ scanl (+) 0 [1, 2, 3, 4, 5]
09:36:45 <lambdabot>  [1,3,6,10,15]
09:37:01 <bbear> cocreature: it would be hard to do stuff in place with immutable values.
09:37:34 <cocreature> there is also scanl' which is often what you want
09:37:43 <bbear> (strict version I presume)
09:37:48 <cocreature> yep
09:38:09 <bbear> > tail $ scanl (+) 0 []
09:38:11 <lambdabot>  []
09:38:36 <cocreature> tail is safe here since the initial value will always be in the resulting list
09:38:37 <hpc> > scanl1 (+) []
09:38:39 <lambdabot>  []
09:38:43 <hpc> > scanl1 (+) [1, 2, 3, 4, 5]
09:38:45 <lambdabot>  [1,3,6,10,15]
09:46:51 <fendor> hello everyone, i'm playing around with template haskell and i was curious how i could implement a type family of the following form: `type SetContainer Test = Int`
09:47:28 <fendor> currently, I got this: `return $ TySynD (mkName "ContainerKey") [PlainTV name] keyType` which causes a compile time error
09:47:52 <fendor> about and illegal `Test` occurrence where Test is the name of a newtype
09:48:18 <fendor> if someone is interested into the error message: https://hastebin.com/fakiqebefe.cs
09:49:49 <fendor> is it possible that this problem is caused by the type families? hence, i used the wrong type?
09:50:09 <glguy> Test isn't a type variable, it's a type constructor
09:50:23 <glguy> TySyn makes type synonyms, not type families and not type family instances
09:51:29 <fendor> ok, thought so, so, rather use TySynInstD?
09:56:10 <fendor> glguy, thanks, i fixed it
09:57:59 <jmcarthur> In coroutine speak, are there good generic names for "the thing you are yielding" and "the thing you get back from yielding"?
09:59:58 <glguy> fendor: In your code the other day you were still using mkName instead of 'mempty
10:00:20 <glguy> fendor: Doing that results in brittle generated code that delays name resolution until splice time
10:00:49 <glguy> and requires the user of the template haskell code to import modules
10:01:01 <fendor> glguy, i see, you're absolutely right, gonna fix that immediately
10:01:35 <Welkin> jmcarthur: other than something related to producer and consumer?
10:01:45 <aoeu> can anyone explain the difference between , and ; in functional programming/mathematics?
10:02:07 <Welkin> aoeu: it depends on the programming language
10:02:56 <aoeu> shouldn't "," mean "and" and ";" mean "or"?
10:03:12 <monochrom> aoeu, there is no universal standard over all of functional programming and/or mathematics. Different niches do different things.
10:03:28 <aoeu> i've been looking at the syntax of a few languages (haskell, prolog, f#), and the use of these characters seem inconsistent
10:03:30 <Welkin> , and ; mean very specific things in erlang
10:03:41 <fendor> glguy, currently i'm trying to automatically implement typeclasses for simple newtypes, including their type instance declarations. A lot of functions do have a similar pattern, which i tried to refactor. 
10:03:53 <Welkin> in haskell "," is used in many places as syntax, but not as an operator
10:04:00 <aoeu> i also don't understand lists from a type theory standpoint
10:04:04 <Welkin> ";" is also just syntactic sugar as part of do-notation
10:04:15 <fendor> therefore i currently have a lot of function like this `simpleUnWrap 'mapToList`
10:04:18 <fendor> dies that make sense?
10:04:21 <aoeu> i understand sum and product types, but i don't get why anyone would use tuples (product types without names)
10:04:22 <Welkin> data List a = Nil | Cons a (List a)
10:04:24 <monochrom> Yeah, do not expect global consistency.
10:04:38 <monochrom> Mathematicians themselves can't even agree on whether 0 is natural. So there.
10:04:51 <aoeu> why would anyone use a Tuple?
10:04:57 <monochrom> But why are you looking for global consistency? There is none.
10:05:03 <aoeu> i try to understand the difference between a tuple and a record
10:05:40 <monochrom> Ah but even "record" gets subtly different meanings over different niches.
10:05:41 <MarcelineVQ> Welkin:  ; isn't for do notation, it's layout syntax useable anywhere along with { }, thought that happens to be useful for do
10:05:41 <jmcarthur> Welkin: I'm hoping for something that generalizes over your point of view. "Produce" and "consume" are counterexamples of this in that whether you are producing or consuming just depends on what side you're on.
10:05:50 <MarcelineVQ> Welkin: https://www.haskell.org/onlinereport/haskell2010/haskellch2.html#x7-210002.7
10:05:58 <aoeu> it doesn't make sense to redefine the meaning of symbols such as , or ;
10:05:59 <jmcarthur> Welkin: But now that I think about it I realize this is kind of silly.
10:06:06 <aoeu> nor does it make sense to use them inconsistently
10:06:22 <monochrom> For example one niche doesn't have row polymorphism, so a record type is a product type, done. But another niche has row polymorphism, so a record type is not simply a tuple type.
10:06:24 <jmcarthur> So nevermind.
10:06:41 <monochrom> Again, why are you looking for global consistency? It's an anti-thesis to diversity.
10:06:59 <aoeu> why can't we all agree on a shared semantics?
10:07:08 <aoeu> monochrom: i hate diversity
10:07:11 <monochrom> There are going to be people who want row polymorphism. There are going to be people who don't want it.
10:07:24 <aoeu> it leads to fragmentation which is counter productive
10:07:38 <monochrom> There are going to be people who want to write [1,2,3] for lists. And there are people who want to write it as [1;2;3] instead.
10:07:42 <aoeu> but clearly, some of these people are wrong
10:08:01 <monochrom> Anyway, good luck with your ideal.
10:08:13 <aoeu> there's a difference between 1 AND 2 AND 3 and 1 OR 2 OR 3
10:08:18 <joeyh> anyone know of any terminal emulators written in haskell?
10:08:21 <monochrom> I'm pretty sure 5000 years ago someone advocated the same ideal. Look what has changed.
10:09:13 <monochrom> Sure, but who says "AND" means "," and "OR" means ";"? I think it's just you.
10:09:43 <aoeu> monochrom: you're happy that so many different languages exist, and that the energy is spread across all of them and that none of them are truly great?
10:10:01 <aoeu> monochrom: the english languages says so
10:10:25 <MarcelineVQ> language variety is good, people think in languages, thought variety is good
10:10:26 <aoeu> monochrom: unless i misunderstand something
10:10:39 <aoeu> MarcelineVQ: but if we had a single great language, things would be a lot better
10:10:50 <glguy> aoeu: This channel is for discussing Haskell rather than just ranting about the world
10:11:03 <aoeu> MarcelineVQ: i don't mean to enforce a single language, we can have other experimental languages, but there should be a default language we can communicate with
10:11:10 <monochrom> To be fair, I ranted about mathematicians and 0 first. :)
10:11:12 <marvin2> aoeu you need to develop one universal language that covers everyone's use cases
10:11:27 <aoeu> glguy: i thought the haskell community would share my ideals, i guess not
10:11:38 <monochrom> Do you happen to also think that dictatorship is better than democracy?
10:11:43 <aoeu> marvin2: that's my plan
10:11:46 <marvin2> monochrom yes
10:11:47 <MarcelineVQ> monochrom: come on now
10:12:04 <monochrom> I mean I am still undecided on that issue, but if it is going to be dictatorship, I don't want you to be the dictator.
10:12:05 <MarcelineVQ> baiting offtopicness is bein a big ol' meany
10:12:05 <aoeu> monochrom: i'm an anarchist
10:18:40 <suppi> aoeu: the only way you can try to solve your problem is by creating another language that will try to unite all others, yet that solution is just going to make your problem bigger!
10:20:08 <monochrom> There is an xkcd for that.
10:20:14 <suppi> yup
10:20:19 <geekosaur> "Standards"
10:20:47 <monochrom> But I can't believe how aoeu actually believes that English ";" means "or", "," means "and".
10:20:54 <aoeu> 927, i know the number by heart
10:21:13 <geekosaur> I'm getting there, I only reference it every other week :p
10:21:39 <aoeu> geekosaur: i'm always on the receiving end of it :P
10:22:02 <aoeu> geekosaur: but unlike others, it's not meant to be another standard but the last standard
10:23:15 <geekosaur> ...
10:23:51 <Welkin> one language to rule them all?
10:24:13 <Welkin> that will always fail because not all languages can be the best at everything
10:24:38 <aoeu> i don't believe in "the best tool for the job"
10:24:38 <marvin2> I think aoeu is onto something
10:24:39 <Welkin> that will lead to a language that no one likes or uses and is bad at everything
10:24:40 <Welkin> like Go
10:25:03 <aoeu> these people are fairly stupid
10:25:19 <Welkin> it's the most basic concept of design
10:25:25 <aoeu> the sheer lack of elegance in these languages is only proof that they're not candidate to be ultimate
10:25:30 <Welkin> if you try to please everyone, you will please no one
10:25:44 <aoeu> i'm not trying to please anyone, you can't please the fools
10:25:56 <Welkin> okay, go make your language then
10:25:58 <aoeu> i'm creating a language that any rational people can learn to be pleased by
10:26:16 <suppi> I'm also planning on creating a programming language
10:26:27 <aoeu> i'm not designing a language for humans, i'm finding the perfect language that exists independently of us, and then will make humans adapt to it
10:26:28 <Welkin> suppi: suppiscript?
10:26:32 <aoeu> suppi: why?
10:26:37 <suppi> Welkin: close!!
10:26:42 <suppi> aoeu: because i can
10:27:01 <suppi> and because there are things i want that aren't available all in one language
10:27:35 <suppi> Welkin: I have the perfect name for it but it's still a secret
10:27:41 <aoeu> suppi: that's the worst reason and people like you should be ashamed of contributing to the problem that is fragmentation
10:27:43 <aoeu> such as?
10:28:19 <suppi> i'm not the least ashamed, you should be ashamed for shaming others for doing what they want
10:28:42 <MarcelineVQ> shame on all of you for not inviting me to prom
10:29:17 <suppi> MarcelineVQ: wanna go to prom?
10:31:05 <aoeu> what's as elegant as prolog, lisp (and maybe idris)?
10:31:30 <Welkin> syntactically, I wouldn't call prolog or lisp elegant
10:31:56 <Welkin> idris has almost the same syntax as haskell
10:32:01 <Welkin> it's 99% the same
10:32:23 <Welkin> not that haskell has much syntax
10:32:31 <marvin2> there is a special charm to lisp syntax
10:32:59 <aoeu> lack of arbitrary keyword = elegance
10:33:05 <cocreature> haskell 98 might not have a lot of syntax. modern GHC haskell has a lot of syntax
10:33:05 <aoeu> java is not elegant
10:33:35 <marvin2> there was a haskell in lisp syntax effort, but IIRC it was short lived
10:33:51 <suppi> aoeu: haaaaave you met forth?
10:34:31 <aoeu> i tried
10:34:39 <aoeu> am not enlightened yet
10:35:04 <Welkin> maybe tried buddhism?
10:35:10 <Welkin> try*
10:35:29 <aoeu> i tried
10:35:33 <fr33domlover> stack install buddhism
10:35:44 <fr33domlover> note that package is very old
10:35:49 <aoeu> ok, so you guys don't care about higher languages
10:35:54 <fr33domlover> and idk how well maintained ;)
10:36:16 <MichaelBurge> What's the name for a Traversal that can drop elements?
10:36:27 <glguy> MichaelBurge: no
10:37:06 <MarcelineVQ> MichaelBurge: witherable but see what glguy has to say about it before looking it up, he usually says more than no
10:37:15 <fr33domlover> aoeu, Haskell works great for me as is
10:37:53 <glguy> Oh, I just read "Traversal" in the context of lens, Witherable is a Traversable that can drop elements
10:38:52 <MichaelBurge> Thanks - that does look useful. The context is reducing an AST to a minimal example.
10:39:52 <aoeu> fr33domlover: you're dead to me
10:40:50 <fr33domlover> aoeu, ah great! you're lucky then, you can finally ask me and find out what happens when you die!
10:40:54 <fr33domlover> :)
10:41:08 <bbear> can you use Haskell for real life coding ?
10:41:22 <fr33domlover> bbear, absolutely!!!!
10:41:25 <fr33domlover> many people do
10:41:34 <fr33domlover> haskell has many many applications
10:41:36 <bbear> I think it is quite possible I enjoy working with it a lot but I must confess that the time to learn and to be proficient with a programming language is huge
10:41:52 <aoeu> bbear: nobody use haskell in real life
10:42:03 <bbear> I really do enjoy working with Haskell but the type system is hard to go through
10:42:25 <fr33domlover> Just like any language, I guess it's not for everyone
10:42:33 <fr33domlover> e.g. I can vomit from writing Java
10:42:38 <MarcelineVQ> bbear: you'll get it :>
10:42:56 <bbear> I'm digging a little bit into Scala
10:42:57 <fr33domlover> But Haskell and FP in general is so fun to me
10:43:06 <bbear> Haskell is quite interesting
10:43:06 <revtintin> aoeu: wouldn't it be more productive use of your time to go write that universal language of yours instead of just, trolling?
10:43:33 <bbear> If you become sufficiently proficient, you can practically write bugless programs.
10:43:46 <aoeu> revtintin: i'm serious so by definition not trolling
10:43:58 <aoeu> revtintin: it's not something you can just go and write, research is not like that
10:44:14 <revtintin> aoeu: it was just a thought. :)
10:44:36 <glguy> aoeu: Your serious concerns about languages aren't welcome in #haskell, but you're welcome to particpate in productive discussion Haskell itself and questions thereof
10:45:03 <bbear> aoeu: Haskell seems to me a powerful enough tool to me. I don't think I would need anything more to write programs but if this is teh case why are all the languages outside so popular ?
10:45:35 <aoeu> glguy: There is no channel for people who seek innovation. Only channels to talk about existing already-obsolete things 
10:45:37 <bbear> IDK. Seems that to be good at programming you don't need to know tons of languages. Just master 2 or 3 of them and you can virtually solve anything. What do you think of that statement ?
10:45:47 <aoeu> glguy: But I will respect your rules and stop.
10:45:50 <glguy> thanks!
10:46:12 <MichaelBurge> bbear: Most software isn't intrinsically complex, so getting people interested involves getting them comfortable more than anything.
10:46:47 <Welkin> what is a recommended library for writing command-line programs (optional parameters, named parameters, etc.)
10:46:52 <aoeu> bbear: Any turing-complete language, such as haskell, is "good enough" by definition. You can accomplish anything with them. That doesn't mean we should stop improving.
10:47:00 <bbear> learning curve for Haskell is steep but it has become kind of a de-facto standard for functional programming.
10:47:18 <Welkin> and also interfacing with other command-line programs through the shell
10:47:20 <MichaelBurge> bbear: Something like Ruby or Javascript often "looks" easy at first glance, while I don't "read" Haskell so much as deduce how primitives work and then compose them.
10:47:24 <aoeu> bbear: Haskell is quite simple to learn. The learning curve is not steeper than most other languages. 
10:47:30 <Welkin> something like Turtle for the second case?
10:47:42 <bbear> Ruby seems hard to me.
10:48:31 <stevenxl> Folks familiar with JavaScript ecosystem, is there a "prettier" equivalent for Haskell?
10:48:36 <Welkin> bbear: that is because there is too much special syntax that introduces unforeseen problems when you don't understand all the edge-cases where you cannot use that special syntax
10:48:36 <bbear> maybe I didn't try hard enough to learn it. Right now I am wondering If I should go learn Scala/Ruby/JS framework or go deeper into Haskell. Second option means more fun but really it wouldn't have a lot of practical use for job hunting.
10:48:58 <MarcelineVQ> stevenxl: I don't understand the question, but are you aware of purescript?
10:49:06 <Welkin> I have found javascript to be a very nice language in spite of all the crap it gets
10:49:15 <Welkin> if you think of it like scheme, it is good
10:49:16 <MarcelineVQ> stevenxl: or is that a pretty pritner lib?
10:49:19 <Welkin> compared to haskell, of course it is bad
10:49:26 <MichaelBurge> bbear: Compare e.g. the Ruby cucumber library for unit tests with something like QuickCheck: https://github.com/cucumber/cucumber/wiki/Scenario-Outlines
10:49:45 <stevenxl> MarcelineVQ: prettier is a library that automatically formats my code. I think elm has elm-format or something.
10:49:59 <stevenxl> is there haskell-format?
10:50:10 <MarcelineVQ> stevenxl: I see, hindent will do this, I've no idea how to configure it though
10:50:22 <stevenxl> MarcelineVQ: enough of a clue for me. 
10:50:24 <stevenxl> Thank you!
10:51:18 <Welkin> I'm still looking for a recommendation for writing command-line programs
10:51:41 <bbear> MichaelBurge: unit testing in Haskell isn't too hard if you do it at lowlevel
10:52:00 <bbear> actually I write my small snippets like that, by successively unit-testing my functions
10:52:24 <bbear> QuickCheck seems like a bazooka for unit-testing to me / but seems really powerful.
10:52:39 <MichaelBurge> bbear: I'm only talking about your question of why certain languages/frameworks are more popular. Making it "seem" easy is important for that.
10:52:43 <Welkin> quickcheck is not unit testing
10:52:47 <Welkin> it is generative functional testing
10:53:03 <Cale> Unit testing is a special case of quickCheck
10:53:09 <Welkin> there are different inds of tests: functional, unit, and integration
10:53:12 <Cale> where your tests don't have any arguments
10:54:12 * hackagebot yi 0.14.1, yi-core 0.14.1, yi-dynamic-configuration 0.14.1, yi-frontend-pango 0.14.1, … and 11 more
10:54:12 * hackagebot  → https://hackage.haskell.org/packages/recent
10:54:51 <fr33domlover> hackagebot learned to group releases? :)
10:56:19 <bbear> I have existential concerns about what I should do for a living
10:56:41 <bbear> I enjoy really working with Haskell but I suppose I should find a Haskell user group close to me.
10:56:45 <bbear> I live in Paris actually
10:57:01 <suppi> bbear: If you want to market yourself to a big market you probably want JavaScript
10:58:09 <bbear> suppi: well I don't get how javascript has become so increadibly popular. For serious application, I am not even sure that Javascript holds.
10:58:29 <bbear> I am more of a backend developer, Front-end stuff tends to repel me.
10:58:30 <lordcirth> Transpiling to JS is the fad these days
10:58:30 <AndreasK> It runs in the browser
10:58:34 <suppi> it's because it's the only language that runs in your browser
10:58:45 <lordcirth> Web assembly also looks interesting
10:59:10 <ab9rf> javascript is a machine language at this point
10:59:55 <suppi> if you want web backend, i think python and ruby are pretty dominant?
11:01:05 <suppi> also... javascript
11:01:09 <ab9rf> bbear: javascript is popular because it's the "machine language" of the ubiquitous web platform, not because it has particularly desirable characterisitcs as a language
11:01:10 <tdammers> depends - in enterprise, java and C# are pretty dominant; in web dev land, PHP is king
11:01:19 <tdammers> in startup land, javascript, python, ruby
11:02:40 <suppi> is php still more popular than ruby/python/js across the job market?
11:02:49 <MichaelBurge> I kind of like the newer versions of Javascript. I'd probably recommend it for someone first getting into programming.
11:03:16 <AndreasK> Isn't the new stuff in JS only optional?
11:03:17 <ab9rf> i can't recommend javascript for any purpose
11:03:23 <tdammers> sadly, yes, especially for anything that is more or less a CMS
11:03:58 <suppi> i'm guessing it's also depends on the region...
11:04:30 <AndreasK> Hell ghc development uses arc and afaik thats written in php
11:04:42 <MichaelBurge> A "production" Javascript app that needs to run across all browsers, including old ones, is a PITA to make. That doesn't matter for learning, though.
11:05:14 <Welkin> MichaelBurge: just use polyfills
11:05:57 <Welkin> I used to have the same thoughts about javascript, but then I gave it a chance, and it is quite nice, as I said before
11:06:15 <Welkin> use es6/es2015 on a real project with something like react and redux for state management
11:06:22 <Welkin> and a good functional utility library
11:06:37 <Welkin> it will essentially be a functional rogramming language
11:07:16 <tdammers> "functional" in the weak sense
11:07:17 <Welkin> of curse, you lack a type system, but that doesn't seem to matter too much for the kinds of applications you tend to build in js
11:07:47 <tdammers> that's not the point
11:07:57 <tdammers> you lack functions, in the strict sense
11:08:05 <Welkin> ?
11:08:09 <Welkin> it's no different than scheme
11:08:12 <tdammers> true
11:08:14 <AndreasK> As in no side effects I assume
11:08:21 <tdammers> correct
11:08:28 <tdammers> and scheme doesn't have functions either
11:08:29 <MichaelBurge> In any case, I wouldn't worry too much about picking the "wrong" language. Most businesses don't actually care about that, and other programmers make the decision.
11:08:42 <tdammers> at least scheme has the intellectual honesty of calling them "procedures"
11:10:15 * hackagebot ratel-wai 0.3.0 – Notify Honeybadger about exceptions via a WAI middleware. – https://hackage.haskell.org/package/ratel-wai
11:10:23 <MichaelBurge> And Haskell lets you write some impressively-complex applications, because you don't spend as much time on ad-hoc debugging.
11:10:33 <suppi> anyway, bbear, you can get a job writing haskell as well, but the market is smaller :)
11:10:53 <Welkin> choosing where to work based on what language they use is foolish
11:11:14 <Welkin> many companies I have come across that are vocal about how they use haskell are really shitty places to work imo
11:11:31 <Welkin> find a good place to work, then introduce haskell
11:11:45 <ab9rf> Welkin: that doesn't surprise me that much
11:11:55 <tdammers> programming languages matter, but other things matter more
11:12:30 <Welkin> it's actually the same with many popular languages
11:13:04 <Welkin> I would stay far away from companies that advertise that they are using elixir or elm or similar. It's just a trick to get people to come work for them for low rates because they are using a "cool" language
11:13:19 <tdammers> sometimes it is
11:13:22 <tdammers> sometimes it's not
11:13:38 <Welkin> it's almost exclusively startups
11:14:14 <AndreasK> The few times I worked on other peoples code in OSS so far the language chosen made hardly a difference for how good of a experience it was.
11:14:23 <tdammers> which is logical, because startups can afford to roll with off-mainstream languages, and they can benefit more from them
11:14:48 <tdammers> large enterprises are by their very nature conservative
11:14:58 <tdammers> naturally, this extends to language choice
11:15:13 <suppi> first, unless you are very senior, knowledgable and have a really open minded team, i think it's going to be very hard to introduce haskell at work
11:15:35 <ab9rf> nah, just write useful stuff with it and it'll be introduced.
11:16:08 <suppi> second, some of us are already ill with the haskell bug and won't really want to go back to work on java or python code bases
11:16:38 <stevenxl> Hi folks. I have a quick question. is this a valid instance of Foldable for the data type defined in teh file?
11:16:39 <stevenxl> https://paste.ubuntu.com/25199156/
11:16:53 <suppi> ab9rf: for example?
11:17:29 <AndreasK> I know of a case where someone did their prototyping in haskell, and they just kept using haskell for that project.
11:18:14 <tdammers> I did that once
11:18:18 <suppi> i don't see that working very well if you are working in a team and are doing agile or something like that
11:18:49 <tdammers> prototyped in haskell, then started implementing the real thing in JS, got stuck, went back to the haskell codebase and even made up for the time lost with the js version
11:19:02 <tdammers> highly experimental project to begin with though
11:19:25 <Welkin> suppi: for mainstream languages, seriously consider javascript as an alternative to haskell for a day job. I have found it very enjoyable, even though for a long time before I was stubborn about not using anythign but haskell.
11:19:44 <suppi> Welkin: sure, but i don't do web
11:20:07 <suppi> currently at least
11:20:09 <MarcelineVQ> program js in haskell :>
11:21:12 <AndreasK> I felt more productive when I had to do a project in Java recently than I did in Haskell so far. There is just SO much tooling already there
11:21:35 <MatthiasGoergens> If you want to introduce Haskell at work, you need a good strategy.
11:21:52 <MatthiasGoergens> I've heard of people making inroads via shake.
11:22:37 <MatthiasGoergens> If OCaml is good enough for you, BuckleScript might be a good gateway drug: it's a OCaml to JavaScript compiler that integrates very well with existing JavaScript (and produces very human-readable JavaScript).
11:23:22 <parsnip> oh rats, search is broken on ircbrowse? http://chrisdone.com/posts/ircbrowse
11:23:57 <suppi> MatthiasGoergens: yeah i really hope ReasonML can gain some traction
11:23:58 <parsnip> anyone have the history here to mention of "-j1" and "+RTS" from this last week? 
11:24:01 <AndreasK> stevenxl: Not sure if it's valid but it certainly doesn't seem useful.
11:24:13 <MatthiasGoergens> stevenxl: do you still need an answer to your question?
11:24:15 <Welkin> there are lots of compile-to-js languages that can be good options
11:24:32 <tdammers> Welkin: really? So far, most of the options I've tried suck
11:24:33 <Welkin> but es6/es2015/es2017 is surprisingly good on its own
11:24:34 <MatthiasGoergens> Welkin: yes.  BuckleScript has the advantage of being actual OCaml.
11:24:52 <Welkin> tdammers: purescript is the best (and easiest to use) I have found so far
11:25:07 <suppi> ReasonML is attractive because it's basically OCaml but it has the kind of syntax and backing that can be sold to mainstream programmers and employers
11:25:08 <MatthiasGoergens> (And mostly since OCaml is strict, it maps well on a module-to-module level (and in some cases even function to function level.  As opposed to ghcjs, which has to produce weird JavaScript.)
11:25:15 <suppi> at least that's what i see
11:25:18 <MatthiasGoergens> Reason is just a skin on top of OCaml.
11:25:24 <tdammers> Welkin: agree. I've also tried elm, clojurescript, ghcjs, and they were all rather "meh"
11:25:33 <MatthiasGoergens> It's exactly the same language.  (I like some of their changes.)
11:26:08 <MatthiasGoergens> You could do you Reason / BuckleScript in secret, and only let your coworkers and boss see your JavaScript output.
11:27:08 * hackagebot pusher-http-haskell 1.3.0.0 – Haskell client library for the Pusher HTTP API – https://hackage.haskell.org/package/pusher-http-haskell
11:27:14 <Welkin> "What's with all these dollar sign variable and function names?"
11:27:27 <MatthiasGoergens> And quite a lot more actual-Haskell jobs available these days.
11:27:45 <MatthiasGoergens> Welkin: template haskell?
11:28:19 <Welkin> MatthiasGoergens: I was referring to the output from compile-to-js languages
11:29:11 <MatthiasGoergens> Welkin: Don't see no $ in https://bucklescript.github.io/bucklescript-playground/#Functional_Programming
11:29:35 <MatthiasGoergens> Or https://bucklescript.github.io/bucklescript-playground/#Baanced_tree to give something meatier.
11:30:24 <Welkin> MatthiasGoergens: it's common in purescript and elm output
11:30:56 <MatthiasGoergens> Welkin: do you have an example (either paste or link) handy?
11:31:42 <MatthiasGoergens> According to stackoverflow the $ is just a convention in JavaScript, just like an underscore a normal part of a variable name.
11:32:13 <Welkin> hm, maybe that was only in elm then
11:32:20 <Welkin> http://try.purescript.org/
11:32:26 <Welkin> check "show JS"
11:32:28 <MatthiasGoergens> JQuery library also uses $ a lot.
11:32:32 <geekosaur> ^
11:32:46 <Welkin> of course, but this is different
11:33:14 <geekosaur> $ is convenient when you need to create internal identifiers in a transpiler that don't clash with names in the source language, since most modern languages don;t allow $ in identifiers
11:33:36 <geekosaur> (note that ghc does the same thing! names generated for ghc's Core language can have $ in them)
11:33:49 <suppi> purescript probably needs a better pretty printer for calling a function
11:33:49 <MatthiasGoergens> Saves you on escaping.
11:35:01 <MatthiasGoergens> I'm trying to cross-compile C++ to solaris/sun.  Just telling this since they misery shared is misery divided.
11:47:02 <sqooq> If
11:49:06 <sqooq> I feel so lost. I'm trying to parse a text which represents a tree structure and then do stuff using that tree structure.
11:50:15 <sqooq> I sort of learned how parsers work
11:53:50 <jle`> what part are you stuck on?
12:01:08 <sqooq> Well first, I don't know if I should start from scratch or just use parsec. Second, I don't know how to actually use parsec, I have an idea but Idk how I would even begin to parse nested brackets into a tree structure. Also how do you actually evaluate once you've parsed the text
12:01:29 <sqooq> Wait can parsec return anything?
12:01:45 <Welkin> if you are doing this as a learning exercise, write your own parser and do not use a library
12:02:00 <Welkin> it isn't hard and is covered in the upen course
12:02:00 <sqooq> I mean i am learning haskell
12:02:17 <sqooq> I wrote a parser following a paper
12:02:41 <Welkin> sqooq: http://www.seas.upenn.edu/%7Ecis194/spring13/lectures.html
12:02:42 <sqooq> I understand most in that paper but it's focused on problems different from my own
12:02:46 <Welkin> it starts in week 10
12:02:57 <sqooq> I used http://www.cs.nott.ac.uk/~pszgmh/monparsing.pdf
12:03:00 <sqooq> but I'll check it out
12:04:00 * hackagebot pushbullet-types 0.3.0.0 – Datatypes used by the Pushbullet APIs – https://hackage.haskell.org/package/pushbullet-types
12:04:00 * hackagebot octane 0.20.1 – Parse Rocket League replays. – https://hackage.haskell.org/package/octane
12:04:12 <sqooq> Ok if I'm going to use my own Parser, my first question is whether it's necessary to categorize it as a Monad or whatever
12:04:17 <sqooq> I've never done that before in Haskell
12:04:28 <tdammers> you don't need to "categorize" it
12:04:38 <tdammers> but implementing Functor, Applicative and Monad for it makes sense, usually
12:05:01 <sqooq> yeah I don't understand what that means
12:05:08 <sqooq> I'm talking about "instance Monad Parser where ..." btw
12:05:11 <tdammers> yes
12:05:17 <sqooq> yeah what does that even do
12:05:29 <tdammers> instance Monad Parser where ... -- is a typeclass instance definition
12:06:06 <tdammers> it says "there is an instance for the typeclass Monad for the type Parser, and the typeclass methods map to the following:"
12:06:20 <tdammers> start with Functor, it's simpler and easier to understand
12:06:49 <tdammers> actually, I suggest implementing Functor instances for a few types from Prelude yourself, e.g. Maybe or []
12:08:15 <sqooq> I understand monad and Functor I think, If I'm understanding you
12:08:20 <sqooq> I know what makes a monad
12:08:23 <sqooq> and what makes a Functor
12:08:25 <tdammers> OK
12:08:35 <tdammers> so that "instance Foo Bar where..." thing
12:08:53 <tdammers> is really just you telling the compiler the details of how exactly Bar is a Foo
12:09:00 <sqooq> For example, If I'm not mistaken, 
12:09:10 <sqooq> actually I can't type in here can I
12:09:24 <sqooq> basically a Monad requires a bind operator and a result operator
12:09:26 <sqooq> which I have both of
12:09:34 <sqooq> I also have a zero and plus operator
12:09:55 <tdammers> monad requires bind and return, yes
12:09:58 <tdammers> (>>=) and return
12:10:13 <sqooq> I guess what I'm confused about is why I would need to tell the compiler, the functions work just fine without doing the instance thing
12:10:31 <tdammers> normally, functions only work on one specific type
12:10:42 <tdammers> you could define return as a -> Maybe a
12:10:47 <tdammers> but then it would only work on Maybe
12:10:53 <tdammers> not on any other type that is a monad
12:11:14 <tdammers> and it would be impossible to extend return to support other types
12:11:20 <tdammers> typeclasses solve this
12:11:34 <sqooq> hmm
12:11:48 <tdammers> with Monad being a typeclass, we can define (in the typeclass) that the "shape" of return should be a -> m a, where m is the type for which a Monad instance exists
12:12:07 <tdammers> and then we can define (in the instance) what exactly return should be for a particular type such as Maybe
12:12:14 <tdammers> i.e., we can say:
12:12:23 <tdammers> instance Monad Maybe where { return = Just }
12:12:30 <monochrom> You can and should certainly get your functions to work first, outside class instances.
12:12:43 <tdammers> which means, "Maybe is a Monad, and its implementation of return is Just"
12:12:49 <sqooq> They work.
12:12:58 <monochrom> Then we can take a look at the working version and say "yes you can make it a Monad instance" or 'no, here is why not".
12:13:20 <tdammers> so then you could just write instance Monad MyType where { (>>=) = myBind; return = myReturn }
12:13:23 <monochrom> I don't think any essay writing has any predictive power on this question.
12:13:34 <tdammers> ^ agree
12:13:46 <tdammers> just lpaste your code and we'll have a look
12:13:49 <tdammers> @where lpaste
12:13:49 <lambdabot> http://lpaste.net/
12:13:56 <monochrom> Because at the very least one has to see the formal (symbolic) type signatures, not any paraphrasing that clearly is wrong.
12:14:22 <monochrom> Not to mention checking the laws. (Even though we usually don't bother.)
12:14:23 <sqooq> does haskell code have to be in order
12:14:34 <sqooq> Can I use a function before it's defined
12:14:40 <monochrom> Yes you can.
12:14:42 <sqooq> ok
12:14:43 <geekosaur> order is not generally a thing
12:14:52 <sqooq> I'm just going to reorder for clarity
12:14:53 <monochrom> Very little contraint on order.
12:15:53 * hackagebot ratel 0.3.5, strive 3.0.4, ratel-wai 0.3.1
12:15:53 * hackagebot  → https://hackage.haskell.org/packages/recent
12:16:25 <sqooq> http://lpaste.net/357280
12:17:30 <monochrom> OK first thing you need to change "Parser" from type synonym to newtype. This also means there is much wrapping and unwrapping in the rest of the code.
12:18:06 <monochrom> But if you survive that, result and bind will have the right type sigs for making a Monad instance.
12:18:25 <sqooq> what do you mean wrapping and unwrapping
12:18:34 <sqooq> when I change it to newtype do I then have to change thigns
12:18:37 <tdammers> yes
12:18:41 <tdammers> the compiler will tell you where
12:18:42 <monochrom> Have you written a newtype declaration?
12:19:05 <hpc> or a data declaration
12:19:47 <monochrom> The algorithms you use look OK, I'm sure they already satisfy the Monad laws.
12:20:09 <monochrom> (Pretty standard algorithms afterall.)
12:20:47 <monochrom> But you won't be able to declare a type synonym to be an instance (of any class at all). You need a newtype.
12:21:03 <monochrom> And that's basically it.
12:21:30 <rostero> why would someone choose mconcat over concat when using a list:  `html (mconcat ["<h1>Scotty, ", beam, " me up!</h1>"])`?
12:21:47 <monochrom> Is it a list?
12:21:57 <sqooq> How do I turn it into a single constructor
12:21:58 <hpc> :t mconcat
12:21:59 <lambdabot> Monoid a => [a] -> a
12:21:59 <byorgey> rostero: it doesn't really matter
12:22:02 <geekosaur> because they're using OverloadedStrings
12:22:06 <tdammers> rostero: mconcat is a more generic version and will work on any monoid; if at some point you decide to use, say, vectors instead of lists, the code will still work
12:22:08 <hpc> :t concat
12:22:10 <lambdabot> Foldable t => t [a] -> [a]
12:22:14 <byorgey> oh, I missed the "why", sorry
12:22:20 <monochrom> Oh I guess it is a list.
12:22:25 <tdammers> (or Text instead of String)
12:22:40 <rostero> geekosaur: gotcha
12:22:43 <rostero> and thanks, tdammers 
12:23:08 <monochrom> But I guess I had the right spirit. Are strings strings? :)
12:23:30 <monochrom> Do not trust syntax.
12:23:31 <tdammers> rostero: IIRC, scotty is already polymorphic over its text type, so plain old `concat` wouldn't even work
12:24:32 <Lokathor> cocreature, https://lokathor.gitbooks.io/using-haskell/content/roguelike/week-5-combat-+-gui.html i did not cleanup the code duplication in the end
12:24:34 <Lokathor> oh well
12:29:01 <sqooq> ok seriously, how do I do this
12:29:06 <sqooq> "newtype Parser a = Parser { parser :: String -> [(a,String)] }" ??
12:29:08 <cocreature> Lokathor: as long as I don’t have to work with that code I’m fine with that :P
12:29:12 <sqooq> seems redundant
12:29:15 <tdammers> sqooq: pretty much, yes
12:29:23 <sqooq> hmm
12:29:27 <Lokathor> no one is intended to work with the code, not even me >_<
12:29:29 <monochrom> No comment on redundancy. You have correct code.
12:29:29 <sqooq> but all those Parsers
12:29:41 <sqooq> alright lmao
12:29:57 <tdammers> sqooq: the two Parsers in there are type-level (the type constructor) and term-level (the value constructor)
12:30:16 <tdammers> so they are different identifiers, they live in separate namespaces (type vs. term)
12:30:21 <monochrom> To make it less redundant, I choose better names: newtpye Parser a = ParserOf { deParser :: String -> [(a, String)] }
12:30:24 <Lokathor> sqooq, the only difference between you and other parsers is that they usually call it "runParser" instead
12:30:32 <byorgey> "A Parser for Things is a Function from Strings to Lists of Pairs of Things and Strings"
12:30:40 <sqooq> ok
12:30:59 <byorgey> http://www.willamette.edu/~fruehr/haskell/seuss.html
12:31:01 <tdammers> I like unParser for the field name, but in this case, runParser is also good
12:31:34 <sqooq> ok
12:31:43 <sqooq> now why do I need to make this an instance of Monad again
12:31:43 <monochrom> I actually hate the "run" prefix. Come on, in 99% of the cases, nothing is run, not even intuitively.
12:32:16 <monochrom> You don't need to, if you don't want to use do-notation or sequence or other monad utilities.
12:32:38 <sqooq> hmm I probably want to use do notation
12:32:47 <monochrom> But I will want to use Applicative utilities at the very least, e.g., liftA2 and *>
12:33:13 <CodesecSky> eae
12:33:19 <CodesecSky> hello
12:33:20 <CodesecSky> hi
12:33:22 <CodesecSky> oi
12:33:24 <CodesecSky> hola
12:33:27 <CodesecSky> ola
12:33:33 <monochrom> Are you done now?
12:33:42 <stevenxl> Lokathor: that's pretty cool that you wrote that book
12:33:53 <CodesecSky> nao entendo sua lingua
12:34:07 <tdammers> sqooq: you don't *have* to make it an instance of Monad
12:34:18 <tdammers> sqooq: but there are two compelling arguments to do it anyway:
12:34:36 <Lokathor> stevenxl, i keep meaning to switch away from their web editor, because that's the worst part of the experience
12:34:51 <Lokathor> larger than like 1000 words in a file and it gets super laggy
12:34:56 <CodesecSky> ta cheio ein
12:35:04 <CodesecSky> full peoples
12:35:06 <tdammers> 1) it *is* a Monad (there are functions that fulfill the shape and laws of Monad), so it makes sense to make this fact explicit and document it as intentional
12:35:08 <stevenxl> Folks, can someone take a quick look at this code and tell me if it makes sense
12:35:09 <stevenxl> http://lpaste.net/357282
12:35:22 <stevenxl> writing an instance of Foldable. 
12:35:26 <CodesecSky> 1,3sistem operation
12:35:28 <tdammers> 2) it being a Monad is actually positively useful, since you can now use do notation and all sorts of monadic utility functions
12:35:30 --- mode: ChanServ set +o monochrom
12:35:50 --- mode: monochrom set +q CodesecSky!*@*
12:35:50 <byorgey> stevenxl: makes perfect sense
12:36:01 <byorgey> thanks monochrom 
12:36:05 <sqooq> tdammers: ok, if I used monochrom's notation do I use "Parser" or "ParserOf" in the instance def
12:36:06 <stevenxl> byorgey: thank you!
12:36:16 <tdammers> sqooq: whichever you prefer
12:36:24 <sqooq> ?
12:36:31 <tdammers> sqooq: for newtypes, my personal convention is to match the term constructor with the type constructor
12:36:42 <tdammers> sqooq: oh sorry, misunderstood
12:36:51 <sqooq> yeah I used "newtype Parser a = ParserOf { deParser :: String -> [(a,String)] }"
12:36:52 <monochrom> sqooq, "Parser" is the type name, "ParserOf" is the data constructor name. I trust that you know their difference and their respective appropriate contexts.
12:36:59 <tdammers> sqooq: the name you need in the instance declaration head is the name of the type, not the term constructor
12:37:13 <sqooq> ok
12:37:22 <sqooq> but do I do Parser a or just Parser
12:37:25 <tdammers> but again, the compiler will slap you if you get it wrong
12:37:32 <monochrom> But yeah, instance header wants type name, pattern matching wants data constructor name.
12:37:53 <tdammers> :k Monad
12:37:55 <lambdabot> (* -> *) -> Constraint
12:38:00 <osa1> :t some
12:38:01 <lambdabot> Alternative f => f a -> f [a]
12:38:03 <tdammers> :k Parser
12:38:04 <lambdabot> error:
12:38:04 <lambdabot>     Not in scope: type constructor or class ‘Parser’
12:38:07 <osa1> any reasons for not returning NonEmpty here?
12:38:08 <tdammers> oh lol ofc
12:38:11 --- mode: monochrom set -o monochrom
12:38:26 <tdammers> sqooq: when you write instance A B where, A and B must be of the same kind
12:38:42 <tdammers> in this case, Monad is * -> *, and Parser is also * -> *
12:38:50 <tdammers> hence, Parser, not Parser a
12:39:07 <sqooq> o boy
12:39:12 <sqooq> i need to brush up on this stuff
12:39:19 <tdammers> :k Monoid
12:39:20 <lambdabot> * -> Constraint
12:39:33 <tdammers> ^ this is an example of a typeclass that demands kind *
12:39:54 <tdammers> so if you were to write an instance of Monoid for Parser, you'd have to make it instance Monoid (Parser a) where
12:40:24 <sqooq> :k Monad
12:40:26 <lambdabot> (* -> *) -> Constraint
12:40:39 <sqooq> yeah I don't understand
12:41:35 <sqooq> why would "Parser a" give it the right kind for Monoid
12:42:36 * hackagebot servant-pushbullet-client 0.3.0.0 – Bindings to the Pushbullet API using servant-client – https://hackage.haskell.org/package/servant-pushbullet-client
12:43:08 <kvakvs> [stack question] how to compile my stack project to print stack traces on exception? can't see in stack docs
12:44:10 <geekosaur> Parser is * -> * (you apply type constructor Parser to a type, to produce a type), Parser a is * (it has now been applied to some type identified by a type variable)
12:44:41 <sqooq> hmm
12:44:42 <geekosaur> that is, you never have a value of type Parser, it is going to be Parser Int or Parser Bool or ...
12:44:51 <sqooq> true
12:45:05 <geekosaur> Monoid applies to values (it is kind *) so you need that type
12:45:19 <sqooq> so Parser Int is a value?
12:45:26 <geekosaur> Monad applies to single parameter type constructors (* -> *)
12:45:31 <geekosaur> it is the type of a value
12:45:43 <sqooq> yes
12:45:50 <sqooq> ok I understand
12:46:08 <sqooq> Parser takes a type as input
12:46:09 <sqooq> sort of
12:46:16 <geekosaur> yes. it is a type level function
12:46:17 <MagneticDuck> is `let x = <expression on x> in x` always equivalent to `let x = fix (\y -> <expression in y>) in x`?
12:46:23 <sqooq> Parser a already has the input
12:46:29 <geekosaur> as opposed to a value level function like (+) or sin or floor
12:46:34 <sqooq> ok so is this right now
12:46:34 <sqooq> http://lpaste.net/357284
12:46:37 <MagneticDuck> how about when instead of a let expression, the equation is a top-level definition in a source file?
12:48:21 <stevenxl> Can someone tell me if i my instance of Foldable for my data type Three' makes sense (http://lpaste.net/357285). It type checks, but I don't know how principled Foldable is.
12:48:30 <stevenxl> (Line 30 in that file)
12:48:45 <sqooq> Btw, the paper I followed used a bunch of lambdas, is there any benefit to that? It's less readable to my eyes
12:48:46 <MagneticDuck> more generally, if my program consists of a single module, can I think of my program as "basically" a great big fix statement?
12:49:22 <stevenxl> Oh wait! I'm going to change my code up a bit.
12:49:27 <stevenxl> one second.
12:49:33 <MagneticDuck> insofar that the ability to refer to `x` in the top-level definition of `x` is basically just syntatic sugar?
12:49:45 <sqooq> Instead of "result v = \inp -> [(v,inp)]" I would just do "result v inp = [(v,inp)]
12:50:22 <monochrom> sqooq: By the time you have to write "result v = ParserOf (\inp -> [(v, inp)])", you have to have that lambda there.
12:50:27 <monochrom> Unless:
12:50:53 <monochrom> Unless you prefer to write: result v = ParserOf helper  where helper inp = [(v, inp)]
12:51:09 <monochrom> It is now up to you. They both suck. Choose your poison.
12:51:10 <sqooq> o shoot I have to put ParserOf around everything?
12:51:46 <sqooq> do the type signatures stay the same?
12:51:53 <monochrom> inb4 <monochrom> This also means there is much wrapping and unwrapping in the rest of the code.
12:51:58 <stevenxl> OK I have a new version up (http://lpaste.net/357285)
12:52:06 <stevenxl> Line 30. I think that makes a ton more sense now.
12:54:43 <sqooq> monochrom: ?
12:54:59 <monochrom> The type signatures stay the same.
12:55:06 <sqooq> ok I figured
12:55:49 <sqooq> shoot so I basically have to wrap ParserOf around everything that isn't built up from lower thigns
12:56:49 * hackagebot propellor 4.7.2 – property-based host configuration management in haskell – https://hackage.haskell.org/package/propellor
12:58:46 <monochrom> which means exactly half of your things. It is not so bad.
13:01:52 <sqooq> hmm type error on bind
13:02:42 <sqooq> The function `f' is applied to two arguments, but its type `a -> Parser b' has only one
13:03:08 <sqooq> but Parser b is "String -> [(a,String)]" so really it has 2
13:03:26 <sqooq> maybe I'm missing a wrap
13:03:30 <sqooq> anyway my dad's getting mad at me
13:03:33 <sqooq> I have to go
13:03:34 <sqooq> bye
13:14:04 <R0b0t1> If I install GHC into my home directory how do I also install everything else into my home directory
13:14:14 <R0b0t1> I prefer to put things in ~/.local and treat it like /
13:14:24 <R0b0t1> I can't seem to configure the location cabal puts things, which is .cabal
13:14:55 <R0b0t1> I also can't seem to clone cabal and then get it to run, it says it can't download most of the packages it needs to install
13:18:55 <monochrom> "cabal install --global" may be what you want.
13:19:54 <monochrom> Actually that is necessary but not sufficient. You have to change some settings in $HOME/.cabal/config too.
13:26:07 <hexagoxel> R0b0t1: specifically in the config: install-dirs user:prefix. and for the config itself being in non-standard location, cabal has --config-file flag.
13:59:38 * hackagebot Earley 0.12.0.1 – Parsing all context-free grammars using Earley's algorithm. – https://hackage.haskell.org/package/Earley
14:24:44 <bbear> any idea how you write yourself a compiler ?
14:25:14 <Tuplanolla> @google the dragon book of compilers
14:25:16 <lambdabot> https://www.amazon.com/Compilers-Principles-Techniques-Tools-2nd/dp/0321486811
14:30:24 <suppi> bbear: i recommend these two resources: http://www.ccs.neu.edu/course/cs4410/ https://www.cs.swarthmore.edu/~jpolitz/cs75/s16/
14:31:07 <k0ral> Hello
14:31:25 <Cale> bbear: https://www.microsoft.com/en-us/research/wp-content/uploads/1987/01/slpj-book-1987-small.pdf -- this is aging, but also a rather good place to start
14:31:27 <suppi> also self plug if you want a whirlwind simplified overview: https://gilmi.xyz/post/2016/10/14/lisp-to-js
14:33:06 * hackagebot propellor 4.7.3 – property-based host configuration management in haskell – https://hackage.haskell.org/package/propellor
14:33:12 <R0b0t1> hexagoxel: I mean cabal itself
14:33:33 <R0b0t1> I can't pass a flag to cabal because it isn't installed yet
14:34:05 <R0b0t1> I'm having trouble finding instructions because everything tells me to "cabal install cabal" which is great but I don't have it yet
14:34:20 <trigone> hi, i don't understand the function forever :: (Applicative f) => f a -> f b. how can you get an f b by making an apparently unbreakable loop out of an (f a) value? how are those loops ever broken?
14:34:44 <geekosaur> that's actualy what the type signature is telling you
14:34:48 <R0b0t1> trigone: Its name is forever, why do you think it stops?
14:34:51 <geekosaur> it has a new type variable b, used nowhere else
14:35:15 <trigone> so... the function is literally made to create an unbreakable loop? what's the point of it?
14:35:28 <lime_> Heh
14:35:34 <lime_> Oh dear
14:35:37 <trigone> R0b0t1: i thought it was forever in a metaphorical "forever till it breaks" way
14:35:39 <hpc> you've never written while(1) before? ;)
14:35:41 <geekosaur> so it can be any type and its only inhabitant is bottom
14:35:59 <hpc> and it can be broken
14:36:01 <hpc> > forever []
14:36:03 <lambdabot>  []
14:36:21 <trigone> hpc: ... hm i see
14:36:23 <R0b0t1> trigone: Well it is, but those things are kind of outside the functional paradigm
14:37:19 <Tuplanolla> Can we see a use case where `f` is not `IO`?
14:38:05 <hpc> Free, for one
14:38:15 <trigone> when do we have to use while(1)?
14:39:07 <R0b0t1> When you're programming in a C derived language, probably
14:39:53 <suppi> for example, you are running a web server that expects to live... forever... without stopping
14:40:07 <suppi> sometimes you don't want your program to stop :)
14:40:18 <geekosaur> when your loop ending condition is either too complex or comes at the wrong time to be part of the loop definition. or when you effectively don't have one, as when writing a service that accepts connections from outside
14:40:36 <geekosaur> (in this case the end condition is typically an OS signal or equivalent)
14:40:44 <R0b0t1> And you can ultimately stop the program in some way, by hitting Ctrl+C or something, but that is handled by your OS and not represented well in Haskell (or any language, for that matter)
14:40:59 <trigone> suppi: hm... that's to avoid having to pay the cost of checking for the end at every looping? you use an exception to get out of it?
14:41:33 <geekosaur> what exactly is the exit condition you would test there?
14:41:40 <Lokathor> it's reprienseted well enough
14:41:54 <Lokathor> just not at the type level by default
14:42:14 <R0b0t1> trigone: It's because termination is abnormal behavior and it doesn't really make sense to write a termination condition in
14:42:20 <Lokathor> also, if there's an exit condition then you should use something other than forever
14:42:24 <trigone> R0b0t1: ok
14:43:25 <geekosaur> OS signals are actually a bit too coarse to be represented well in a type system
14:44:22 <geekosaur> for example, on POSIX OSes a signal is sent to a process, not a thread, and any currently executing-on-CPU thread could be picked by the scheduler to receive it in a multicore environment
14:45:22 * hackagebot sbvPlugin 0.10 – Formally prove properties of Haskell programs using SBV/SMT – https://hackage.haskell.org/package/sbvPlugin
14:45:22 * hackagebot sbv 7.1 – SMT Based Verification: Symbolic Haskell theorem prover using SMT solving. – https://hackage.haskell.org/package/sbv
14:45:39 <monochrom> your_PC_is_stoned :: IO b; your_PC_is_stoned = forever (putStrLn "Your PC is stoned!\a")
14:47:41 <monochrom> More seriously, if you write a chat server, pretty sure you want to use forever in a child thread whose job is to read from a socket, queue it on a message queue, repeat. No "exit condition" other than getting an exception such as socket dies or thread killed.
14:48:19 <trigone> yes i understand, thanks everyone :)
14:48:50 <monochrom> To a large extent we really should just answer "when you grow up, you will know" and be done.
14:49:00 <geekosaur> well, no, you could have an admin shutdown command, but most of the time for a service it gets shut down by the OS's service manager which will usually use a signal
14:49:11 <monochrom> "Why would anyone need money? ELI5"
14:49:44 <geekosaur> (OS X is an exception there, but only if you use the launchd transaction API. I don't think there's a Haskell binding for it.)
14:59:09 <k0ral> is it true that any functor f that includes an empty value (`Empty :: f a`) is not representable ?
15:00:31 <geekosaur> counterexample: Maybe
15:00:43 <geekosaur> I suspect what they mean is a bit more nuanced
15:05:38 <k0ral> geekosaur: Maybe is not representable, as far as I know
15:06:23 <k0ral> so this is an example of what I stated, not a counterexample
15:06:47 <k0ral> or am I mistaken ?
15:06:52 <geekosaur> you said functor f
15:07:03 <geekosaur> f : * -> *
15:07:12 <geekosaur> (kind)
15:08:39 <bbear> a functor isn't the analog of function between sets but for categories, ie a functor is an arrow that map objects from category A to category B ?
15:09:15 <geekosaur> if we're talking CT, we're not talking about values, are we?
15:09:22 <k0ral> geekosaur: yes I said that, what's your point ?
15:09:49 <bbear> I don't what you mean by « representable »
15:09:56 <geekosaur> ok, so my point is you can fmap over Nothing. the result will be Nothing, at the new type.
15:10:09 <geekosaur> likewise fmap over an empty list
15:10:11 <k0ral> I'm talking about representable functors, ie functors such that there exist some X such that f is isomorphic to (->) X
15:11:05 <bbear> k0ral: ? I still don't get it. I am maybe not versed enough in Category Theory.
15:11:42 <bbear> the part « is isomorphic to (->) X » is creeping my mind.
15:11:49 <bbear> crippling rather
15:12:31 <k0ral> it means that for some X, we have (f a) ~ (X -> a)
15:13:07 <k0ral> I'm not an expert, just read about that concept an hour ago, and it so happens it's quite important to what I'm implementing right now
15:13:50 <k0ral> geekosaur: that is "just" a functor, but I'm only interested in representable ones
15:14:19 <Cale> k0ral: So if there's an "empty" value, the only way we could possibly represent that is if the function type had an empty domain. But then for particular choices of 'a' that won't work out.
15:14:27 <Cale> k0ral: So you're correct.
15:14:40 <k0ral> geekosaur: I'm referring to what's implemented in the adjunctions package, module Data.Functor.Rep
15:15:49 <k0ral> Cale: okay, thanks for confirming, I'm afraid it means what I intended won't work :(
15:16:14 <Cale> What were you trying to do?
15:17:26 <k0ral> I'm using `Cofree (Map e) a` to implement a decision tree, with `e` the decision type and `a` the outcome type
15:18:20 <k0ral> I intended to build a zipper over that tree and make it an instance of `ComonadStore (Seq e)`
15:19:13 <k0ral> but it looks like I can't because `Map e` is not representable
15:20:51 <ertes> k0ral: "outcome"?  in (Cofree (Map e) a), 'a' is more like the "current state"
15:20:52 <Cale> Is Cofree really the right way around? I guess if you want the empty sequence of choices to give some outcome...
15:20:57 <k0ral> from ComonadStore class, `peek :: s -> w a -> a` requires a value of type `a` for any position `Seq e`, which cannot be done using a `Map e`
15:21:21 <k0ral> ertes: yes, incorrect wording, my bad, this is indeed a "current state"
15:22:51 <mnoonan_> k0ral: I might just be thinking about this because I’m literally writing the library right now, but I think I have a way of making a variation on Map e representable in some cases..
15:22:53 <k0ral> Cale: the empty sequence of choices should produce the root of the tree so that's not an issue
15:23:31 <k0ral> mnoonan_: what did you sacrifice to achieve that ? :)
15:24:02 <ertes> data Function a b = Function { image :: Map a b, def :: b }
15:24:17 <mnoonan_> k0ral: your maps pick up a phantom type parameter, so you now have `Map ph k v`, and you can only lookup values of type `Key ph k` (with matching phantom type)
15:24:41 <mnoonan_> so basically you prove that a `k` is in the map to obtain a `Key ph k`, and then you can lookup etc Maybe-free
15:24:45 <k0ral> Cale: but a sequence of choices might not lead to a valid state, which is my blocking point to implement the instance for ComonadStore
15:25:03 <k0ral> Cale: of Cofree isn't the right way, what would you suggest ?
15:25:03 <mnoonan_> anyway, I think that makes (Map ph k) ~ (Key ph k ->)
15:25:22 <mnoonan_> maybe there is an issue with the Ord constraint on k too
15:25:42 <ertes> Function is representable
15:26:40 <ertes> you can even do this:  data Function a b = Function { special :: Map a b, regular :: a -> b }
15:27:18 <ertes> apply (Function s r) x = M.findWithDefault (r x) x s
15:29:52 <k0ral> ertes: in my use case, this would create branches out of illegal decisions, in the tree
15:30:51 <k0ral> ertes: you're basically increasing the size of the type enough for it to be representable, if I understand correctly
15:32:42 <k0ral> mnoonan_: in my case, `ph` is distinct for each node of the tree
15:33:18 <k0ral> mnoonan_: wonder how much boilerplate this would entail, but I like the idea
15:35:06 <mnoonan_> k0ral: I’ve been trying to figure out if I can use it to make a lambda-calculus evaluator that comes with a guarantee that every name can be found in the current context. I haven’t had luck there yet, but it had a similar problem with differing `ph`.
15:36:29 <mnoonan_> if your set of keys is fixed across all nodes of the tree, you can at least keep the same `ph`.
15:37:57 <k0ral> the decisions set (this is my map key) is static, however there are illegal decisions in some states
15:38:24 <k0ral> so `ph` depends on the current state
15:41:31 <Cale> k0ral: Ah, okay. I think you might want something like Map together with a default value for unbound keys?
15:41:56 <Cale> I'm trying to remember what that was called, I know there's at least one package which defines it on hackage
15:42:22 <Cale> http://hackage.haskell.org/package/total-map
15:42:56 <Cale> there's also http://hackage.haskell.org/package/total-maps
15:43:15 <k0ral> Cale: technically, that would work, but then how could I distinguish between a legal and an illegal decision ?
15:45:11 <bbear> i'm getting tired of this -- I start to understand the need for <*> <$> operators but I am still not really proficient with them
15:45:53 <glguy> bbear: You can ignore them for a while, then. You don't *need* to use them
15:46:23 <Cale> k0ral: Maybe just by the outcome?
15:46:39 <bbear> zip ['a'..] (lookup 'a' [('a',[1,2,3,4]), ('b',[5,6,7,8])])
15:46:50 <Cale> bbear: If it helps, the main thing to know is that  f <$> x <*> y <*> z  is the same thing as  liftA3 f x y z
15:46:50 <monochrom> @type liftA2 ($)
15:46:51 <lambdabot> Applicative f => f (a -> c) -> f a -> f c
15:47:23 <Cale> bbear: Which, in the case of a monad, is the same thing as  do a <- x; b <- y; c <- z; return (f a b c)
15:47:42 <bbear> zip ['a'..] (lookup 'a' [('a',[1,2,3,4]), ('b',[5,6,7,8])]) <-- I don't know if you see what I mean to do
15:48:06 --- mode: ChanServ set +o monochrom
15:48:13 <bbear> the problem is that lookup returns a Maybe. AFAIK, Maybe is both a monad and an applicative functor, right ?
15:48:20 --- mode: monochrom set -q CodesecSky!*@*
15:48:23 <Cale> yes
15:48:27 --- mode: monochrom set -o monochrom
15:48:43 <Cale> Perhaps just use do-notation to begin with
15:48:48 <bbear> so how can I return a Maybe ?
15:48:49 <k0ral> Cale: what you (and ertes) are suggesting is deferring the validity check at runtime, and I'm trying to avoid that
15:49:28 <bbear> Cale: using a Monad maybe a way, yes, but maybe just using the functor properties or teh applicative properties would be enough ?
15:49:47 <Cale> Quite possibly enough yes
15:49:56 <bbear> >zip ['a'..] <$> (lookup 'a' [('a',[1,2,3,4]), ('b',[5,6,7,8])])
15:50:04 <bbear> > zip ['a'..] <$> (lookup 'a' [('a',[1,2,3,4]), ('b',[5,6,7,8])])
15:50:06 <lambdabot>  Just [('a',1),('b',2),('c',3),('d',4)]
15:50:13 <monochrom> 90% of the time Applicative is enough, but do-notation is less abstract.
15:50:20 <bbear> yes, it is enough. 
15:50:25 <monochrom> Or looks less abstract.
15:50:25 <Cale> If you only want to make one choice, then it's enough
15:50:32 <Cale> (to just use Functor)
15:50:39 <trigone> hi, if i implicitly export everything from the module (module Foo where), does it also re-export anything i'd have imported?
15:50:53 <monochrom> It's up to you. It sucks both ways. Choose your poison.
15:50:57 <bbear> From my experience, I practically never need <*>, <$> is quite enough.
15:51:07 <bbear> do you know why ?
15:51:11 <Cale> <*> is for when you have multiple Maybe arguments
15:51:36 <bbear> ah ok.
15:51:36 <monochrom> Limited experience.
15:51:39 <bbear> interesting
15:51:49 <geekosaur> trigone, yes
15:52:09 <geekosaur> to avoid this: module Foo (module Foo) where
15:52:27 <trigone> geekosaur: hm ok thx. it's both logical and very weird...
15:53:20 <bbear> so you can show me with (+) and two Maybe integers ?
15:53:35 <bbear> monochrom: I don't claim to have it all :) experience is limited per se :)
15:53:50 <Cale> > (+) <$> Just 3 <*> Just 4
15:53:52 <lambdabot>  Just 7
15:53:56 <Cale> > (+) <$> Nothing <*> Just 4
15:53:58 <lambdabot>  Nothing
15:53:59 <monochrom> I was answering "do you know why?".
15:54:04 <bbear> ha ok, so you need the <$> ?
15:54:13 <Lokathor> i had a place where i should have used <*> recently
15:54:18 <Lokathor> but i just did a case match
15:54:18 <bbear> :)
15:54:29 <k0ral> > do x <- Just 3; y <- Just 4; return (x + y)
15:54:29 <jle`> bbear: <$> and <*> work together to combine mutliple Maybe's
15:54:30 <Cale> bbear: It's worth looking at the type of <*> carefully to work out why that is
15:54:31 <lambdabot>  Just 7
15:54:39 <Cale> You don't *need* it, but it's idiomatic
15:54:47 <Cale> (that is secretly a pun)
15:54:59 <mnoonan_> I was about to say something :)
15:55:07 <Lokathor> in my case, i didn't have a function to apply to the un-maybe'd versions
15:55:08 <monochrom> pure (+) <*> Just 3 <*> Just 4
15:55:14 <Lokathor> so the case let me do that sorta
15:55:25 <Cale> > pure (+) <*> Just 3 <*> Just 4
15:55:27 <lambdabot>  Just 7
15:55:39 <bbear> much cooler with pure
15:55:44 <Cale> Or of course, we could write Just in place of pure there
15:55:46 <Cale> It's the same thing
15:56:00 <Cale> Nothing <*> Just 3 <*> Just 4
15:56:03 <Cale> > Nothing <*> Just 3 <*> Just 4
15:56:05 <lambdabot>  Nothing
15:56:16 <Cale> > Just (^) <*> Just 3 <*> Just 4
15:56:18 <lambdabot>  Just 81
15:56:28 <k0ral> bbear: for what it's worth, at first I only used <$> and <*> as a way to rewrite some monadic code without intermediate variables
15:56:35 <Cale> :t (<*>)
15:56:36 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
15:56:41 <Cale> :t ($)
15:56:42 <lambdabot> (a -> b) -> a -> b
15:57:05 <monochrom> Yes, "do { x <- j; y <- k; return (x+y) }" is boring after a while.
15:57:24 <monochrom> Especially since you will agonize over choosing "meaningful names" for x and y.
15:57:38 <bbear> so when you do (+) <$> Just 1 <*> Just 2, you actually apply it to (+) <$> Just 1 which is Just (+1) <*> Just 2
15:57:48 <bbear> :t Just (+1)
15:57:49 <lambdabot> Num a => Maybe (a -> a)
15:57:57 <bbear> :t (<*>
15:57:59 <lambdabot> error:
15:57:59 <lambdabot>     parse error (possibly incorrect indentation or mismatched brackets)
15:58:00 <bbear> :t (<*>)
15:58:00 <Cale> To be quite honest, I often find myself removing Applicative-style code and replacing it with do-notation
15:58:01 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
15:58:20 <geekosaur> btu are you using ApplictiveDo? :p
15:58:26 <k0ral> bbear: if I may suggest, applicative parsers are a good use case to get comfortable with those operators
15:58:30 <Cale> geekosaur: Emphatically no.
15:58:58 <Cale> ApplicativeDo is mostly a bad idea.
15:59:35 <Cale> I can see why they wanted it at Facebook to help the non-Haskell users write imperative-looking code which would be sneakily turned into concurrent stuff.
15:59:46 <geekosaur> that was about half of the " :p "
16:00:04 <Cale> But unless you want to trick yourself into writing stuff that you don't know quite what it means, there's no point.
16:00:38 <glguy> I've found ApplicativeDo useful a couple of times, but don't use it much
16:01:39 <Cale> Maybe if you were writing something polymorphic which you wanted to have an Applicative rather than a Monad constraint, but couldn't bring yourself to use the Applicative operators
16:02:13 <bbear> evaluation is right to left in Haskell, right ?
16:02:19 <bbear> (to left ...)
16:02:21 <glguy> https://github.com/glguy/irc-core/blob/2a129b0dd9aa794c29bc1ecae197a8a970d87e93/src/Client/Configuration/Macros.hs#L26-L32 I think that turned out nicer than the <*> version
16:02:22 <Cale> left to right
16:02:41 <bbear> you mean you start by evaluating what's on the left first ?
16:02:47 <Cale> If you see something like  f (g (h x))
16:02:55 <Cale> it's the code for f which gets entered first
16:03:05 <bbear> so if I do (+) 3 2
16:03:07 <Cale> and (g (h x)) is passed, unevaluated, as an argument to f
16:03:16 <bbear> it computes (+3) and then apply it to 2 ?
16:03:28 <bbear> ok, so how can you be sure it type check ?
16:03:36 <monochrom> Ah you have a nested thing like \x y z -> (x, Macro y z)
16:03:42 <glguy> This would have been more of a mess with <*> and Applicative do https://github.com/glguy/irc-core/blob/64019d5e75cc69fcbffa8092654c3946cb39b383/src/Client/Configuration.hs#L253-L293
16:03:44 <bbear> I mean that's probably done before the execution anyway.
16:03:47 <Cale> Oh, well, the compiler will probably optimise that and not actually construct the intermediate function in cases like that
16:03:54 <Cale> But as for what the expression means, yes
16:04:06 <Cale> This has nothing to do with evaluation order
16:04:10 <Cale> f x y z
16:04:11 <Cale> means
16:04:15 <Cale> ((f x) y) z
16:04:26 <Cale> Independently of what order you evaluate that expression in
16:04:39 <bbear> yes, that's why I forget parenthesis so much and add them where they are not needed. The right to left stuff is not natural.
16:04:45 <monochrom> Also bear in mind nothing says you must keep 100 <*>'s all on the same line.
16:05:40 <monochrom> If I have a 100-field data constructor C100, I really will write "C100 <$> ..." and use 101 lines.
16:05:47 <Cale> bbear: The main thing to remember with regard to operator precedence in Haskell is actually technically not a precedence rule, it's that whitespace binds tighter than any infix operator
16:05:58 <Cale> So if you have  f x + g y
16:06:05 <Cale> that's got to be (f x) + (g y)
16:06:06 <glguy> monochrom: Yeah, in the case that you have a flat constructor like that I think the C100 <$> ... version is just fine
16:06:33 <Cale> Or, so if you write f n + 1, that's not f (n+1), but rather (f n) + 1
16:06:36 <monochrom> The problem with the do-notation equivalent is that both me, the writer, and you, the reader, will have to check that no one is messing up the order of the fields by the time I finally say "return (C100 ...)"
16:07:20 <Cale> bbear: <*> like ordinary function application, is defined to associate to the left
16:07:41 <Cale> So if we have f <*> x <*> y <*> z, it means ((f <*> x) <*> y) <*> z
16:07:53 <Cale> That's specified by an infixl declaration for it.
16:08:14 <Cale> Prelude> :info (<*>)
16:08:18 <Cale> ... some stuff ...
16:08:22 <Cale> infixl 4 <*>
16:08:59 <bbear> yes infix is a little bit different from the rest, it binds the two operands together ?
16:10:24 <Cale> The infixl declaration says that if you have a chain of occurrences of that same operator, they should be associated to the left. There's also infixr if you'd prefer they associate to the right, and just plain infix if you'd like it to be an error to attempt that.
16:10:27 <glguy> monochrom: I find the advantage of the do-notation version is that you don't match the order between the 100 lines and the parameters of the constructor
16:10:45 <bbear> I read it just like (f <*>) x <*> y <*> z -> (((f <*>) x) <*> y) <*> z -> ((((f <*> ) x ) <*> y ) <*> ) z
16:11:16 <Cale> That's got too many parens
16:11:33 <Cale> It works though
16:11:42 <Cale> It's just, you're forming operator sections
16:11:44 <monochrom> But really, the electronic engineers figured it out 40 years ago. Draw a circuit diagram already.
16:12:00 <Cale> monochrom: proc/do
16:12:01 <Cale> :)
16:12:14 <Cale> (kinda)
16:12:26 <monochrom> If they look at our discussion, they're going to say, "why are you people arguing over how to write netlists by hand? It only needs to be machine-readable!"
16:13:30 <geekosaur> sifflet? :p
16:14:28 <hpc> whenever i have to debug something that's "machine-readable", i think of https://www.youtube.com/watch?v=VHfroJBMlVM
16:15:06 * geekosaur sends hpc a sheaf of greenbar with a hex memory dump printed on it
16:18:29 <jared-w> hpc: I love that comedy bit
16:25:32 <bbear> you are all Galois veteran ?
16:25:37 <bbear> I am impressed.
16:25:41 <hpc> yep
16:25:44 <hpc> all 1640 of us
16:25:58 <bbear> Thanks to you I keep progressing
16:27:44 <bbear> I was sure of this cabalistic gathering 
16:27:49 <jle`> any good libraries for bidirectional programming
16:27:53 <jle`> bidirectional functions
16:27:55 <jle`> i mean
16:28:27 <bbear> > lookup 'a' <$> zip ['a'..] <$> (lookup 'a' [('a',[1,2,3,4]), ('b',[5,6,7,8])])
16:28:29 <lambdabot>  Just (Just 1)
16:28:44 <jle`> i suppose one could get pretty far by just composing Iso's
16:28:47 <bbear> how can I get out of this 'Just (Just)' thing ?
16:29:08 <jle`> join :: Maybe (Maybe a) -> Maybe a
16:29:15 <jle`> but you probably wanted the monadic interface from the beginning
16:29:34 <bbear> yes, that's the moment I am telling to myself that the do notation could be quite useful.
16:29:40 <jle`> > lookup 'a' =<< zip ['a'..] <$> (lookup 'a' [('a',[1,2,3,4]), ('b',[5,6,7,8])])
16:29:43 <lambdabot>  Just 1
16:30:02 <bbear> Are you sure that my problem cannot be solved less specifically than by using a Monad ?
16:30:16 <jle`> (<$>) :: (a ->   b) -> m a -> m b
16:30:21 <jle`> (=<<) :: (a -> m b) -> m a -> m b
16:30:23 <bbear> it's ok if not.
16:30:28 <jle`> bbear: your problem can be solved by just pattern matching
16:30:43 <bbear> jle`: what do you mean ?
16:30:45 <jle`> @let joinMaybe (Just x) = x; Nothing = Nothing
16:30:46 <lambdabot>  Defined.
16:30:58 <jle`> > joinMaybe $ lookup 'a' <$> zip ['a'..] <$> (lookup 'a' [('a',[1,2,3,4]), ('b',[5,6,7,8])])
16:31:00 <lambdabot>  Just 1
16:31:13 <bbear> > joinMaybe (Just (Just (Just 1)))
16:31:15 <lambdabot>  Just (Just 1)
16:31:43 <jle`> my point was that you never "need" Monad
16:31:45 <jle`> for Maybe
16:32:00 <bbear> jle`: in this case, it seems just the right way to do it. 
16:32:05 <Lokathor> it just cuts down on the indenting
16:32:10 <jle`> i'd probably use do notation instead of (=<<)
16:32:13 <jle`> but yeah
16:32:18 <bbear> I don't know, themonadic notation is alright.
16:32:24 <jle`> monadic notation is pretty great
16:32:31 <jle`> that's one of the reasons why it was invented
16:32:45 <jle`> but you never need it :)
16:33:23 <jle`> the point where Applicative fails you is if the Nothing-or-Justness of your result depends on the *value* inside the Maybe
16:33:24 <Lokathor> http://lpaste.net/357287 is my recent "should perhaps have used <*> here" code
16:33:47 <jle`> bbear: in your example, whether or not lookup 'a' returns Nothing or Just depends on the list you get
16:34:10 <jle`> that's how you know Applicative isn't powerful enough
16:34:47 <jle`> for all Applicative applications, the Nothing-or-Justness has to be determined completely by whether its inputs are Nothing or Just, and not what's inside them
16:36:18 <danilo2> Hi guys! :) I've got strange problem. I'm getting different results when using criterion and just by measuring the program from command line. It seems that when using criterion IGHC does not optimize the program the same way
16:36:36 <jle`> ighc?
16:36:38 <danilo2> Which is strange, let me explain it better
16:36:49 <Lokathor> GHCi?
16:36:53 <danilo2> jle`: IGHC -> GHC :)
16:37:19 <Lokathor> danilo2, unfortunately, GHC being fickle with optimizations does happen :/
16:37:45 <hpc> in C++ it's IGHC, in java it's GHCable
16:38:13 <danilo2> the IGHC was just a typo :)
16:38:18 <hpc> :P
16:38:22 <danilo2> the criterion benchmarks look like: `bench "0  trans (10e6)"  $ nf t_2R 100000000` - it runs 300ms 
16:38:22 <Lokathor> hpc, you mean C#
16:38:41 <Lokathor> and Java would be AbstractGHCFactoryBuilder
16:39:49 <danilo2> however, when I create just main: main = do {x <- read . (!!0) <$> getArgs; print =<< eval (t_2R x)}, where eval = GHC.IO.evaluate . force ;  I get 100 ms
16:40:09 <danilo2> and it scales - so when I use 10^7, I got 3s vs 1s 
16:41:01 <danilo2> (the signature of `t_2R` is just `Int -> Int`)
16:42:48 <danilo2> Lokathor: it could be fickle, but in this particular example it should behave the same way. Otherwise, if using criterion can completely destroy performance, we do not have any benchmarking utility here
16:44:33 <Lokathor> i don't think it always happens, just that it can happen
16:44:39 <Lokathor> unforunately, i'm not any sort of expert
16:47:02 <danilo2> Lokathor: I understand it. However, if you look at the code I pasted, for me it makes completely no sense why something like that could happen (the function `t_2R`) is where all the computations are being crunched and its definition is independent from criterion usage, so why we got different optimizations ? :/
16:48:17 <Lokathor> if i had to guess, my first guess would be that probably one version is always unboxed, and one version doesn't unbox
16:50:20 <danilo2> Hmm, it still does not make sense (at least to me). Even if criterion values get boxed, they are boxed once and then passsed to this function, which is strict on them, so it should not affect the performance 3times. I think I need to generate core out of it
16:52:06 <bbear> Is there a serious use of Maybe around ?
16:52:32 <monochrom> Maybe is seriously used in the containers library.
16:52:40 <hpc> the documentation specifically says Maybe is for silly functions only :P
16:52:47 <monochrom> and unordered-containers too
16:53:12 <Lokathor> getCreatureAt :: (Int,Int) -> Dungeon -> Maybe Creature
16:53:16 <jle`> there hasn't been a single haskell app or library i've written that doesn't use Maybe
16:53:17 <Lokathor> classic lookup result
16:53:21 <jle`> Maybe is ubiquitous in Haskell
16:53:29 <glguy> I get very serious when I use Maybe
16:53:36 <jle`> technically, optional values are ubiquitous in programming languages in general
16:53:46 <jle`> haskell is just one of the few languages that give you sane ways to handle it
16:53:57 <jle`> see: billion dollar mistake
16:54:23 <bbear> yes, I understand this claim.
16:54:29 <monochrom> In contrast, the paper "how to turn possible failures into lists of successes" is not serious.
16:54:42 <jle`> if you've ever programmed before, you've probably used hackey ways to handle things that were supposed to have been Maybe's in the first placec :)
16:54:43 <geekosaur> define "seriously". I don't know of many large scale uses of the Maybe monad, for example, since most commonly you want to substitute a default for a Nothing instead of failing a larger computation
16:54:45 <monochrom> Or rather, the title.
16:55:32 <Welkin> jle`: or where everything is a string
16:55:40 <bbear> Please forgive my pretentiousness, but it feels that if you are using Maybe a lot, you are kind of stuck in a giant Monadic program
16:55:50 <jle`> hm, how so?
16:56:01 <jle`> you don't need to use any of the Monad combinators to work with Maybe
16:56:16 <monochrom> Not necessarily. Whenever you finally have a default value, you use "maybe" or "fromMaybe".
16:56:17 <jle`> all you usually need is just a simple case statement or pattern match
16:56:38 <Lokathor> bbear, Monad is an interface that Maybe happens to support. I don't ususally use the Monad interface for Maybe at all though
16:56:41 <monochrom> or yeah, pattern matching.
16:56:42 <Lokathor> i usually just use fmap
16:56:46 <bbear> jle`: if you start to use maybe in your program. then you have to pass it around.
16:56:51 <jle`> not necessarily
16:56:59 <jle`> you can get out of Maybe immediately if you want
16:57:03 <jle`> by supplying a default value
16:57:11 <jle`> and also, one of the advantages of haskell is that it's *easy* to combine Maybe's
16:57:13 <monochrom> But if you layer your layers of abstractions nicely, usually you don't have a default to speak of, for 90% of your layers.
16:57:14 <bbear> yes, with unsafe functions like fromMaybe
16:57:20 <jle`> fromMaybe is not unsafe
16:57:26 <jle`> > fromMaybe 0 Nothing
16:57:28 <lambdabot>  0
16:57:40 <bbear> allright I agree
16:57:50 <jle`> but also, combining Maybe's and working with Maybe's while staying inside Maybe is really simple with Haskell, so even the "worst-case scenario" is actually pretty nice
16:58:20 <jle`> you escape maybe easily in the best case scenario, and you work with Maybe with some great easy-to-use and simple abstarctions in the worst-case
16:58:23 <jle`> sounds like a win win
16:59:16 <jle`> > fromMaybe 0 (lookup 'a' [('b', 10), ('c', 13)])
16:59:19 <lambdabot>  0
16:59:23 <monochrom> I don't understand why "stuck in a monad" is such a problem, or even why it's negatively described as "stuck".
16:59:58 <monochrom> In C, you are stuck between ignoring errors or nesting deeply with if-then-else's.
17:00:38 <geekosaur> for that matter, in just about eveyr other language you are "stuck" in the IO monad with no escape at all
17:00:45 <monochrom> And I do think 90% of the programmers ignore errors and pretend they're done, so they can point at their code and say "look, nice linear code".
17:00:46 <bbear> monochrom: it feels like you are doing imperative stuff
17:00:46 <bbear> it's not really like fp
17:00:48 <bbear> you see this programs with a lot of error checking
17:00:51 <EvanR> in C you are free! free to modify arbitrary areas of virtual memory with special syntax 
17:01:17 <jle`> bbear: not sure how Maybe's monadic interface is imperative
17:01:29 <jle`> it's...pretty un-imperative
17:01:34 <monochrom> No I think he means my depiction of C code.
17:01:39 <hpc> why stop yourself there! write your website backend as a kernel module like tux, and operate on physical memory
17:01:40 <jle`> ah i see
17:01:47 <bbear> yes if (error) return
17:02:12 <jle`> is that supposed to be an english sentence, heh, i'm not sure what you mean
17:02:23 <monochrom> In the Maybe monad it is linear code and it still preserves the error.
17:02:55 <monochrom> And you have mplus and <|> if you want to try several alternatives until you find one that succeeds.
17:02:59 <bbear> there exists code out there if thousands of such lines (not only in C code)
17:02:59 <bbear> s/if/with
17:02:59 <bbear> s/there/where/
17:02:59 <bbear> not the second
17:02:59 <bbear> meh
17:03:15 <monochrom> In C this kind of rich logic simply can't be coded.
17:03:16 <Lokathor> functional code doesn't mean "never linear code" it just means that you've got fixed outputs for given inputs
17:03:38 <monochrom> OK I am exaggerating. Of course you can code it up in C. But no one will understand it.
17:03:48 <EvanR> f . g . h . ... linear code!
17:04:05 <monochrom> OK I'm exaggerating on that second one too. Of course the C people simply declare that they don't understand Haskell code either.
17:04:13 <Welkin> C people!
17:04:28 <Welkin> they emerge from the C
17:04:37 <SwiftRocks_JavaS> Category theory is so bull shit! It means nohting ad we already know what a Category is..sSomething things are in. Thats why haskell, commeon lisp, prologue,, and the other functional (I think it should be call DYSfunctional) programming languages are Trash. Any question?
17:04:49 <monochrom> Sometimes you don't understand something because it's simpler than you thought.
17:05:13 <jle`> EvanR: haskell doens't have linear programming yet! :O
17:05:22 <hpc> it's coming though
17:05:27 <bbear> good night america
17:05:29 <Welkin> hpc: through an extension?
17:05:38 <hpc> yeah
17:05:43 <peddie> jle`: https://hackage.haskell.org/package/glpk-hs  of course it does :)
17:05:46 <jle`> ;)
17:06:15 <hpc> https://ghc.haskell.org/trac/ghc/wiki/LinearTypes
17:06:21 <jle`> i guess technically we already have linear programming
17:06:26 <jle`> it just has to be enforced by hand
17:06:28 <jle`> hehe
17:06:32 <hpc> i hope that extension leads to a type-safe rust FFI
17:06:53 <jle`> my linearity checker is my coworker
17:06:55 <manek> Hi! :) I'm playing with Haskell performance and I'm playing with something very, very simple now. Let's consider `pureInc :: Int -> Int -> Int pureInc !a !i = case i of 0 -> a ; _ -> pureInc (succ a) (i - 1)` . (run it like pureInc 0 (10^9)). Why this function performs much worse than C implementation (just incrementing int value in a loop) ? Can we optimize it better with ghc ?
17:07:19 <jle`> manek: are you compiling with optimizations?
17:07:29 <manek> jle`: of course, -O2
17:07:34 <monochrom> Oh I don't think "check by hand" ever counts. You don't say "Turing machines are statically typed because you can check yourself"
17:08:01 <jle`> what is a compiler but not a robotic human checking my code for me
17:08:07 <jle`> s/but/if
17:08:08 <hpc> turing machines also never have bugs because they can't crash
17:08:11 <manek> jle`: I'll show you full source codes, brb
17:08:34 <jle`> manek: also maybe try flipping the arguments?
17:09:10 <Welkin> another troll bites the dust
17:09:49 <jle`> manek: i do notice that the argument order is the opposite of what these accumulator functions usually are
17:09:54 <jle`> but that might not matter
17:09:56 <monochrom> manek: I somewhat don't believe it. I have seen the generated asm for similar Haskell code. It is as good as my handwritten asm.
17:10:32 <Welkin> it may have to do with a difference between boxed/unboxed values
17:10:37 <monochrom> But I can try this one and see what happens.
17:10:48 <jle`> yes this is surprising to me as well
17:10:52 <bbear> advent of code is really fun
17:10:57 <monochrom> No, GHC keeps it Int# in the loop, only boxing it at the end.
17:10:57 <bbear> see you o/
17:10:58 <Tuplanolla> You probably get `^` defaulted to `Integer` there.
17:11:08 <jle`> but pureInc has a type
17:11:23 <Tuplanolla> The second argument is unconstrained.
17:11:30 <Tuplanolla> :t (^)
17:11:32 <lambdabot> (Num a, Integral b) => a -> b -> a
17:11:33 <ertes> i think that particular confusion comes from a common misconception: "once you get into IO, you can't get out"
17:11:35 <ertes> the truth is exactly the opposite: "you start in IO, and you can use pure code wherever you want"
17:11:37 <jle`> ah i see
17:11:42 <ertes> manek: only force 'a'
17:11:46 <ertes> manek: but i doubt that it makes a difference…  GHC should have figured this one out by itself
17:11:57 <jle`> try 1e9 instead of 10^9
17:12:00 <ertes> manek: but you can change the strictness slightly, which should make a difference
17:12:01 <hpc> manek: try reducing your arguments to pureInc to normal form before measuring
17:12:22 <hpc> manek: pureInc (fix id) (fix id) is going to look like pureInc is an infinite loop, if you don't profile with the right granularity ;)
17:12:33 <ertes> pureInc a 0 = a; pureInc a i = let !a' = a + 1 in pureInc a' (i - 1)
17:12:34 <kadoban> ertes: That's a nice way to put it (re: pure code)
17:12:35 <ertes> if you flip the argument order:  pureInc 0 a = a; pureInc i a = pureInc (i - 1) $! a + 1
17:12:55 <manek> ertes, hpc, jle`, monochrom : maybe I did something stupid, but I dont see where. Here are the codes: http://lpaste.net/357288
17:13:57 <jle`> manek: oh, are you just running it like that?
17:14:07 <jle`> that 1s might be from the ghc runtime booting up
17:14:28 <jle`> it might be 1s of initializing the runtime and ~0s of actual computation
17:14:30 <manek> jle`: I dont think so. If you provide small number the ghc version is also 0
17:14:51 <ertes> freenode is lagging terribly for me
17:14:53 <monochrom> manek, are you on a 64-bit system?
17:15:10 <manek> monochrom: yes
17:15:22 <jle`> if the runtime boots that quickly for you then i am jealous ;_;
17:15:30 <monochrom> Does it matter that C's int is 32-bit signed, and Haskell's Int is 64-bit signed?
17:15:44 <monochrom> > 10^9 < 2^31
17:15:46 <lambdabot>  True
17:15:47 <jle`> it shouldn't make a difference by that much
17:15:57 <monochrom> Oh it is OK.
17:16:00 <manek> monochrom: I dont know. I can use Word64 instead 
17:16:14 <manek> monochrom: anyway, the difference is huge
17:16:17 <monochrom> OK I'll read the core and asm code.
17:16:36 <jle`> if you can, try using a benchmarking library to make sure the problem is with the computation and not with some other potential runtime quirks
17:16:42 <jle`> like criterion
17:16:59 <manek> jle`: I did, I used criterion with different sizes. Everything scales with the input size lineary
17:17:16 <manek> *input size = the x in 10^x 
17:17:25 <jle`> funny
17:17:36 <jle`> so it scales logarithmically?
17:18:24 <manek> jle`: Im sorry, my description was just wrong. No, it scales lineary :) If you provide 10^(n+1) it runs 10 times slower than when you provide (10^n) :)
17:18:42 <hpc> silly idea, try using x+1 instead of succ
17:18:55 <jle`> haha no worries.  that would have definitely been very interesting
17:18:57 <hpc> succ has a pattern match and error call attached to it
17:19:02 <hpc> > succ (maxBound :: Int)
17:19:04 <hpc> iirc?
17:19:04 <lambdabot>  *Exception: Prelude.Enum.succ{Int}: tried to take `succ' of maxBound
17:19:05 <hpc> yeah
17:19:17 <hpc> that might be getting in the way of it looking like a tight loop
17:19:24 <jle`> that succs
17:19:25 <hpc> > maxBound + 1 :: Int
17:19:27 <lambdabot>  -9223372036854775808
17:21:04 <manek> using +1 instead of succ gives us 2x faster code, but still much slower than c
17:21:51 <monochrom> Ah so that's why I'm seeing the Cmm code saying "if xxx != 9223372036854775807 goto this; else goto that"
17:21:58 <jle`> haha
17:22:24 <manek> monochrom: oh
17:22:26 <manek> heh
17:23:08 <manek> monochrom: have you discovered anything besides this maxInt goto that makes the code so slow ?
17:24:08 <monochrom> No, the Cmm code looked as tight as possible. (For example, again, no unboxing-reboxing, it's all machine int)
17:24:35 <manek> monochrom: interesting. But as I understand, you've got the same results as mine ?
17:24:51 <monochrom> I haven't timed anything.
17:25:29 <monochrom> I'm going to post the asm code (replacing "succ a" by "a+1" of course)
17:26:32 <maerwald> monochrom: my maaan
17:26:39 <manek> monochrom: hmm, woud you be so nice and time both versions to be sure you've got the same results as me? You dont need anything fancy to time them, the difference is huge
17:26:43 <ertes> manek: did you try my variant?
17:27:40 <manek> ertes: I'm sorry, I somehow overlooked your idea. I'm tyring it right now
17:28:29 <jle`> can confirm that my loop is also tight
17:29:12 <monochrom> http://lpaste.net/357288#a357289
17:29:25 <monochrom> OK, I'll need to try running it.
17:29:38 <manek> ertes: I cannot belive GHC did not this automatically, but your optimisation makes it running almost 2times faster. Still thousand times slower than C
17:30:01 <manek> I'm tlaking about using: ertes version: `pureInc a 0 = a; pureInc a i = let !a' = a + 1 in pureInc a' (i - 1)`
17:30:14 <ertes> manek: don't forget the type signature
17:30:26 <ertes> or specialise it to Int yourself
17:30:36 <ertes> otherwise you get Integer code
17:31:35 <manek> ertes: Im using type signatures
17:31:52 <manek> ertes: look at my pasted code above. I know about type defaulting etc
17:32:14 <crucify_me> 'let jackel :: (Ord a, Eq b) => a -> b -> a; jackel = undefined'    how does this fly when the second arg, Eq b, takes only one argument ? does the interpreter not make it that far if you're querying ':t jacket "keyboard" ?
17:32:26 <ertes> manek: this is not an optimisation…  my function is in fact subtly different from yours
17:32:45 <ertes> manek: try this in particular:  pureInc 0 undefined
17:32:52 <jle`> crucify_me: i'm not sure how to interpret your question
17:33:07 <monochrom> Do an "strace ./progname 1000000000"
17:33:08 <ertes> although…  actually it shouldn't make a difference
17:33:09 <jle`> what do you think is wrong with that?
17:33:21 <crucify_me> wouldn't Eq take two arguments in any case? jle` 
17:33:24 <monochrom> By progname I mean the Haskell version.
17:33:30 <jle`> Eq always takes one argument
17:34:01 <ertes> manek: i have to leave now, but if you hang around, i'll investigate this later
17:34:05 <crucify_me> thanks jle` confused again
17:34:11 <jle`> `(Ord a, Eq b) => a -> b -> a` means that jackel is a function that takes two arguments of any type, as long as the first is an instance of Ord, and the second is an instance of Eq
17:34:18 <ertes> manek: i would expect the haskell version to be just as fast as the C version
17:34:19 <monochrom> And behold all the time it spends on handling SIGVTALARM, I guess? :)
17:34:30 <jle`> so you couild use jackel as an `jackel :: Int -> Bool -> Int`
17:34:32 <jle`> which is fine
17:34:48 <jle`> since you have Ord Int (Int is an instance of Ord), and you have Eq Bool (Bool is an instance of Eq)
17:34:54 <ertes> manek: oh, and minor difference: int from C is most likely not the same type as Int from haskell
17:35:03 <ertes> manek: Int has 64 bits on modern architectures
17:35:14 <ertes> manek: but it shouldn't make much of a difference
17:35:52 <jle`> crucify_me: so you can give jackel an Int and a Bool, or you could give it a Bool and a Double, those are all valid
17:35:54 <monochrom> No, that's not it. There is a pause after a lot of strace messages.
17:36:08 <manek> monochrom: Im installing strace, brb
17:37:03 <manek> ertes: thank you :) 
17:37:07 <crucify_me> jle`, one moment please
17:37:10 <geekosaur> +RTS -V0
17:37:47 <jle`> crucify_me: btw, the second arugment is 'b', not 'Eq b'
17:37:48 <geekosaur> don't strace without it. VTALRM every 1/100 second of cpu time, the overhead of tracing will dominate everything
17:38:01 <monochrom> Ah OK.
17:38:56 <monochrom> Anti-climatic result: +RTS -V0 reduces the running time to instantaneous, simply because I didn't enable -rtsopts at build time. XD
17:38:56 <geekosaur> (and the next most significant delay will come from strace's voluminous output making it block repeatedly on output before it can resume the traced program)
17:39:29 <monochrom> But the real test still takes more than a second.
17:39:50 <geekosaur> actually that, if not output to disk file, will probably be even worse than the overhead of tracing per se
17:39:57 <monochrom> OK, does Int32 make a difference?
17:40:25 <manek> monochrom: here is the strace: http://lpaste.net/357290
17:41:10 <monochrom> Haha what? Int32 takes longer?!
17:42:00 <monochrom> I'm switching back to Int.
17:42:06 <geekosaur> wonder if something is checking for overflowing the 32-bit limit when ghc is using a 64-bit internal rep
17:43:28 <monochrom> No, but it does a "movslq %eax, %rax" to drop the upper bits.
17:43:54 <geekosaur> *eyeroll*
17:44:03 <monochrom> So yeah, it's "increment a, bitmask; decrement i, bitmask"
17:45:50 <monochrom> OK, now I want to test the C version. And read its asm to see what secret sauce it's using.
17:46:56 <geekosaur> inb4 gcc -O2 optimizes it to set the register to the final value
17:47:12 <manek> monochrom: I cant wait to know what are your findings
17:47:24 <manek> geekosaur, monochrom I compiled it with clang -O3
17:47:33 <monochrom> I think geekosaur is right. I saw this before.
17:47:43 <jle`> manek: does the c version increase in runtime if you put in bigger numbers?
17:48:44 <crucify_me> jle`, sorry, what does Eq do with "has the word jackel in it" ... or does it do nothing and ignored by the interpret since the type will return a Char  
17:48:57 <monochrom> Yeah there doesn't look like any loop at all. (gcc -O2)
17:48:59 <crucify_me> *and is ignored
17:49:15 <crucify_me> interpreter*
17:49:16 <jle`> crucify_me: what do you mean?
17:49:25 <jle`> what si "has the word jackel in it" ?
17:49:55 <jle`> are you asking how Eq is related to that string?
17:49:56 * geekosaur trying to figue out where that came from too
17:49:58 <manek> jle`, monochrom : To test bigger numbers I modified the code slightly:
17:50:10 <kadoban> Makes sense. Anything sufficiently close to 0s is really not enough time for it to be doing a billion of anything.
17:50:16 <cauchy> hi
17:50:16 <cauchy> Is there a book/paper/resource for implementing a proof checker for e.g. first-order logic?
17:50:35 <crucify_me> yeah what would it do to that string jle`  ?
17:50:44 <jle`> Eq doesn't do anything to any strings, heh
17:50:48 <jle`> it's a typeclass
17:50:48 <manek> jle`, monochrom : the results are - if you provide the C version with 10^5 (so it makes 10^15 itereations) it runs in 0.5s here. Haskell's version with 10^6 iterations runs in 2s 
17:50:49 <jle`> not a function
17:50:49 <cauchy> Doesn't have to be in Haskell, just thought Haskell folks might be knowledgable about these things.
17:51:28 <jle`> crucify_me: do you understand what 'foo :: a -> b -> a' is?
17:51:32 <jle`> what that type signature means?
17:52:20 <crucify_me> the question from the textbook is what type is jackel "keyboard" "has the word jackel in it"   ....   yeah it just takes an a and b (potentially different type) and returns an a type
17:52:32 <trigone> :t const
17:52:33 <lambdabot> a -> b -> a
17:52:53 <trigone> hi, is the Reader monad read-only or not? it's not very clear to me... i heard you could change the environment but in a temporary way (by contrast with state monad) only for sub-computations. how does one manage to do that?
17:53:15 <jle`> crucify_me: so, `foo :: a -> b -> a` can take two arguments of *any* type.  it can be specialized to foo :: Int -> Bool -> Int
17:53:20 <jle`> it can be foo :: Double -> String -> Double
17:53:26 <geekosaur> trigone,
17:53:28 <geekosaur> :t local
17:53:29 <lambdabot> MonadReader r m => (r -> r) -> m a -> m a
17:53:31 <jle`> crucify_me: anyhting goes!
17:53:44 <jle`> crucify_me: but, if we want, we can constrain what you can instantiatne 'a' and 'b' as
17:54:06 <jle`> so `foo :: (Num a) => a -> b -> a` means that you can only specialize the a to instances of Num
17:54:15 <jle`> so you can use foo :: Int -> Bool -> Int
17:54:20 <jle`> but you can't use foo :: String -> Double -> String
17:54:28 <jle`> since String isn't an instnace of Num
17:54:35 <crucify_me> got that thanks....
17:54:36 <jle`> you can constrain b if you want, as well
17:54:44 <monochrom> http://lpaste.net/357288#a357292
17:54:48 <jle`> foo :: (Num a, Show b) => a -> b -> a
17:55:06 <jle`> that means you can use foo :: Double -> Bool -> Double
17:55:10 <crucify_me> so in this case both parameters are constrained, right?
17:55:16 <jle`> bit you can't do, say, foo :: Double -> (Int -> Bool) -> Double
17:55:17 <jle`> yes
17:55:28 <jle`> so i can't call `foo` with a Double and an (Int -> Bool)
17:55:40 <jle`> since (Int -> Bool) has no Show instance
17:55:58 <crucify_me> thanks, so , I'm fuzzy on what Eq is.... isn't it primarily (==) ?
17:56:03 <jle`> Eq is a typeclass
17:56:08 * cauchy is sad
17:56:25 <jle`> just like Show, or Num, etc.
17:56:34 <jle`> you can use :i Eq in ghci to see what methods it has
17:56:36 <geekosaur> cauchy, to be honest that's more a question for reddit or stackoverflow
17:57:02 <cauchy> geekosaur: hmm, how so? Doesn't get asked often?
17:57:11 <jle`> crucify_me: note that constraints can be redundant, as well
17:57:35 <jle`> @let redundant :: (Num a, Show b) => a -> b -> a; redundant = 0
17:57:36 <lambdabot>  .L.hs:165:13: error:
17:57:36 <lambdabot>      • Could not deduce (Num (a -> b -> a)) arising from the literal ‘0’
17:57:36 <lambdabot>          (maybe you haven't applied a function to enough arguments?)
17:57:38 <cauchy> geekosaur: I asked on ##math but they're luddites and can't use anything other than a blackboard
17:57:43 <jle`> @let redundant :: (Num a, Show b) => a -> b -> a; redundant _ _ = 0
17:57:45 <lambdabot>  Defined.
17:57:50 <jle`> > redundant 0 True
17:57:51 <manek> monochrom: I'm not too good in asm to be honest. 
17:57:53 <lambdabot>  0
17:58:00 <jle`> > redundant 100 "hi"
17:58:02 <lambdabot>  0
17:58:13 <jle`> > redundant True id
17:58:15 <lambdabot>  error:
17:58:15 <lambdabot>      • No instance for (Num Bool) arising from a use of ‘redundant’
17:58:15 <lambdabot>      • In the expression: redundant True id
17:58:18 <trigone> :t ask
17:58:20 <lambdabot> MonadReader r m => m r
17:58:24 <trigone> geekosaur: thanks :)
17:58:25 <monochrom> manek: It's what geekosaur said. The C optimizer eliminates the loop altogether.
17:58:32 <geekosaur> cauchy, they're just mroe about theory in that channel. as for here, it's more that stuff like that will only be answerable by a small subset of people and in a busyt channel the question gets lost
17:58:42 <manek> monochrom: anyway, it seems that C really executes the loops, if you look at the version with nested loops: http://lpaste.net/357291 you can observe 0.5 s when prvided with 10^5
17:58:57 <geekosaur> so the people who could answer wll likely never notice it was asked because of all the other stuff going on
17:59:03 <monochrom> Oh I have to try that one.
17:59:04 <cauchy> geekosaur: ah, I see
17:59:07 <manek> monochrom: if it optimizes it away, why the version with 3 loops takes 0.5s ?
17:59:13 <cauchy> geekosaur: Thanks for elaborating :)
17:59:35 <monochrom> Well within 3 nested loops maybe one of them is eliminated. I haven't tried.
17:59:39 <jle`> hm, that was a bad example, since redundant actually uses Num a
17:59:47 <jle`> > redundant 100 negate
17:59:50 <lambdabot>  0
18:00:02 <jle`> oh, cause lambdabot has a Show instance for functions
18:00:06 <jle`> ....
18:00:37 <monochrom> I have to go. But do try to read the asm. Don't be always black-boxing. :)
18:00:51 <crucify_me> jle`,  please hold on I'm just trying to figure out if a String has an instance of Eq
18:00:56 <monochrom> There is always a scientific explanation. Even a reductionist one.
18:01:06 <jle`> crucify_me: it does, check on ghci :)
18:01:27 <jle`> hm actually it's hard to check that on ghci
18:01:31 <manek> monochrom: sure, thank you for your help. Im trying to read it, but I dont see instantly (or even after a while) where the difference is, especially when not playing with asm for a long long time
18:01:34 <jle`> unfortunately
18:01:48 <crucify_me> jle`, I can't exactly read all of the output of :i Eq
18:02:15 <jle`> :i []
18:02:25 <jle`> or well, :i String
18:02:29 <trigone> geekosaur: is local used this way? http://lpaste.net/357293
18:02:29 <jle`> will tell you that String is [Char]
18:02:33 <jle`> so check out :i []
18:02:37 <crucify_me> ok
18:02:58 <jle`> or also you can just check by doing `"hello" == "world"`
18:04:12 <crucify_me> so Eq b means b is an instance of Eq, any type that utilizes various features of Eq
18:04:24 <crucify_me> *and is any type
18:04:49 <geekosaur> trigone, that's a simple way to use it, yes. more commonly it's used in things like compilers, where you keep track of what's visible in a given scope in the environment and an inner scope is run in a local with the environment augmented by that scope's local bindings
18:05:12 <jle`> crucify_me: it doesn't have to be a type that utilize various features of Eq
18:05:17 <jle`> it just has to be an instance
18:05:34 <ab9rf> instances have to be explicitly declared
18:05:45 <ab9rf> it's not duck-typing like in something like ruby
18:05:55 <trigone> geekosaur: ok thx. my example didn't prove it, but just to be clear, if i do an ask after a local, the environment is the same as beforelocal, right?
18:06:00 <geekosaur> yes
18:06:08 <crucify_me> ok, so in that example, its sort of just fluff to throw you off while trying to answer the correct type in multiple choice. jle` 
18:06:10 <ab9rf> you have to actually say, somewhere, that Blippity is an instance of Blah
18:06:29 <jle`> crucify_me: well, reading instances is important
18:06:33 <geekosaur> that's the point, it's "run this thing with a local change that doesn't change the outer environment"
18:07:11 <trigone> geekosaur: k thx :) it's pretty simple after all :) by contrast, the state is threaded in a strictly linear way, right? there's no equivalent to local? (or maybe there is?)
18:07:28 <trigone> * monad state
18:07:31 <trigone> * state monad
18:07:40 <geekosaur> you can write something like local for MonadState, it tends to be less useful
18:07:43 <ab9rf> monad monad
18:07:55 <geekosaur> I've seen maybe 4 requests for it in the past decade :)
18:08:09 <trigone> requests for adding local to state?
18:08:12 <geekosaur> yeh
18:08:58 <trigone> k
18:09:18 <jle`> if we add local to state
18:09:22 <jle`> can we also add state to federal
18:09:23 <geekosaur> and because state is writable it's easy to implement if you do need it
18:09:33 <trigone> geekosaur: yeah
18:09:43 <trigone> jle`: what's federal? is it a pun?
18:09:44 <geekosaur> for Reader you need access to the implementation, or you have to create a new Reader
18:10:01 <geekosaur> joke about levels of government
18:10:01 <ab9rf> jle`: but then you get into intergovernmental immunity and Holland v. Missouri, and lord knows what happens if someone shoots the wrong goose.
18:10:04 <jle`> data Federal a = Federal { runFederal :: a -> Void }
18:10:45 <trigone> what's Void? is it a type without constructor?
18:11:02 <jle`> (yes)
18:11:09 <ab9rf> jle`: as far asi know, nobody has a good deontic logic library for haskell :)
18:11:34 <jle`> data Void
18:11:35 <trigone> does bottom inhabit a type without constructor?
18:11:39 <jle`> or the more fun way, data Void = Void Void
18:11:54 <geekosaur> trigone, bottom is the only inhabitant of such type
18:12:01 <jle`> trigone: in haskell Void has a single inhabitant, bottom
18:12:09 <trigone> geekosaur: well at least you can have undefined then :P
18:13:03 <trigone> btw, the monad writer is always based on monoids?
18:13:13 <jle`> well
18:13:24 <jle`> what do you mean by always
18:13:26 <jle`> and wariter
18:13:29 <jle`> *rwriter
18:13:51 <jle`> and what do you mean by monoid
18:13:55 <jle`> sorry, that wans't very helpeful
18:14:06 <trigone> jle`: what do you mean by helpful :P
18:14:17 <jle`> there is always some underlying monoidal action under any implementation of Writer
18:14:33 <jle`> even if it might not be explicitly Monoid
18:15:06 <trigone> jle`: is there one which takes a concatenative function and a default value as parameters? ofc as you said, you end up with a portable monoid instance i suppose
18:15:23 <trigone> s/default value/empty value/
18:15:33 <jle`> it's tricky to do that in haskell's Monad
18:15:42 <jle`> but yes it'd be possible if you do
18:15:45 <geekosaur> here's where someone drags in SML's open
18:15:55 <jle`> as long as the concatenative function and the empty value form a monoid
18:16:02 <jle`> (the function has to be associative, the value has to be an identity)
18:16:41 <trigone> jle`: what happens if say the value is not an identity?
18:17:00 <jle`> trigone: `return x >> return y` wouldn't be the same as `return y`
18:17:13 <jle`> er
18:17:15 <jle`> tat's not a monad law
18:17:44 <jle`> `f =<< return x` would not be the same as `f`
18:17:46 <jle`> there ya go
18:17:58 <benzrf> i think return x >> return y is a corollary
18:18:25 <jle`> 'return x' logs the empty value, so if it's an identity, it won't affect whatever 'f x' logs
18:18:57 <jle`> but if it's not an identity, the thing that 'f x' logs will be whatever 'f =<< return x' logs, plus whatever 'return' logs
18:19:32 <jle`> benzrf: indeed
18:19:48 <trigone> jle`: k thx :)
18:20:13 <jle`> no problem :)
18:20:22 <jle`> it might be easier to see with Applicative
18:20:45 <jle`> since `liftA2 (,)` is supposed to be "monoidal"
18:21:07 <jle`> you can imagine `Writer m` as basically a way to lift any Monoid to be an Applicative
18:21:30 <trigone> jle`: hm...
18:21:34 <jle`> liftA2 (,) is supposed to be associative, and also have an identity (return _)
18:22:01 <jle`> or well i guess we can talk about (<*>) instead of liftA2 (,)
18:22:25 <jle`> (<>) corresponds to (<*>), and mempty corresponds to return
18:22:27 <jle`> *pure
18:23:22 <trigone> > (1,3) <*> (3,4)
18:23:24 <lambdabot>  error:
18:23:24 <lambdabot>      • Could not deduce (Num a0)
18:23:24 <lambdabot>        from the context: (Num (a -> b), Num a, Num t, Monoid t)
18:23:42 <jle`> > ("a", id) <*> ("b", True)
18:23:44 <lambdabot>  ("ab",True)
18:23:52 <trigone> jle`: ooh
18:24:20 <jle`> > ("a", id) <> pure True
18:24:22 <lambdabot>  error:
18:24:22 <lambdabot>      • Couldn't match type ‘Bool’ with ‘a -> a’
18:24:22 <lambdabot>        Expected type: ([Char], a -> a)
18:24:26 <jle`> er
18:24:29 <jle`> > ("a", id) <*> pure True
18:24:31 <lambdabot>  ("a",True)
18:24:33 <jle`> pure has to be mempty
18:25:33 <trigone> ok... so if i understand this correctly, (Monoid a => (,) a) has an applicative instance that applies the right side and concatenates the left side?
18:25:55 <trigone> i thought the writer concatenated the right side...
18:26:05 <jle`> what is the 'right side' of Writer?
18:26:21 <jle`> just an implementation detail :)
18:26:27 <jle`> Writer could have been implemented either way.
18:26:53 <jle`> the important thing is the order of the type parameters
18:27:12 <trigone> jle`: hm ok
18:27:31 <trigone> Writer w a = Writer (a,w) ?
18:27:44 <jle`> it could have just as well have been Writer (w, a)
18:28:10 <jle`> the only important thing is that w is the first type parameter and 'a' is the second
18:28:56 <trigone> do they share some common code or are they both defined in isolation? is there a special class for Monads which have a concatenative side-aspect?
18:28:59 <texasmynsted> when I look for hosting for a haskell web app, do I look for cgi hosting?
18:29:20 <jle`> trigone: what common code do you mean?
18:29:27 <jle`> Writer is a monad because of its external API/interface
18:29:32 <jle`> how its implemented doesn't matter
18:29:34 <jle`> *it's
18:29:50 <jle`> oh, do you mean the Monad instance for Writer, and the Monad instance for (,) w?
18:29:55 <jle`> yes, they are defined separately
18:30:05 <jle`> we actually had to fight for the (,) w instance to get into base
18:30:14 <trigone> jle`: ok, i just want to know if (<*>) for Writer w and (w,) are using some common code in their implementation
18:30:29 <jle`> ah.  there is no common code in their actual implementation
18:30:37 <jle`> there could have been, in an alternative world
18:30:57 <trigone> jle`: maybe :)
18:30:57 <jle`> it's just an arbitrary design decision
18:31:21 <texasmynsted> is my question better suited for another channel? 
18:31:57 <jle`> instance Monoid w => Applicative ((,) w) where pure = runWriter . pure; f <*> x = runWriter $ uncurry writer f <*> uncurry writer x
18:32:24 <jle`> oh, that could have been just f <*> x = runWriter $ writer f <*> writer x
18:32:33 <trigone> :t writer
18:32:35 <lambdabot> MonadWriter w m => (a, w) -> m a
18:32:45 <jle`> oh
18:33:02 <jle`> f <*> x = runWriter $ writer (swap f) <*> writer (swap x)
18:33:25 <jle`> but yes the more sane thing would be (a, f) <*> (b, x) = (a <> b, f x)
18:34:09 <trigone> jle`: yeah, and then define Writer accordingly
18:34:27 <trigone> is there a Monadic ((,) w)?
18:34:37 <jle`> yes (,) w has a Monad instance
18:34:40 <jle`> for Monoid w
18:34:59 <jle`> > replicateM 5 ("a", 10)
18:35:01 <lambdabot>  ("aaaaa",[10,10,10,10,10])
18:35:15 <jle`> bad example since replicateM really only needs the Applicative instance but yeah
18:35:35 <jle`> > ("a", 5) >>= ("b",)
18:35:38 <lambdabot>  ("ab",5)
18:35:47 <trigone> so, basically, Writer is just a mirrored and wrapped implementation of that...
18:36:18 <jle`> it does depend on the implementation too
18:36:28 <trigone> runWriter (do {tell "b"; return 3})
18:36:29 <jle`> Writer in transformers is actually implemented slightly differently
18:36:41 <jle`> but you could impelemnt Writer using that
18:36:46 <trigone> > runWriter (do {tell "b"; return 3})
18:36:48 <lambdabot>  (3,"b")
18:37:02 <trigone> jle`: how can it be implemented differently?
18:37:08 <jle`> @let data MyWriter w a = MyWriter (w, a) deriving (Show, Functor, Applicative, Monad)
18:37:09 <lambdabot>  .L.hs:167:44: error:
18:37:09 <lambdabot>      • Can't make a derived instance of ‘Applicative (MyWriter w)’:
18:37:09 <lambdabot>          ‘Applicative’ is not a standard derivable class (Eq, Show, etc.)
18:37:19 <jle`> trigone: well there's the way it's implmeneted in transformers
18:37:25 <jle`> and there are also more efficient ways to implement it as well
18:37:35 <jle`> the tuple implementation is an infamously inefficient implementation
18:37:46 <trigone> jle`: oh
18:37:54 <jle`> well
18:37:58 <trigone> so, the transformers version does not use tuples?
18:38:02 <jle`> the implementation in transformers is also infameously inefficient
18:38:11 <jle`> both versions are pretty awful
18:38:19 <trigone> ok... what would be an efficient version?
18:38:36 <trigone> does it matter even if we don't write too much?
18:38:37 <jle`> the transformers version actually has data WriterT w m a = WriterT (m (w, a))
18:38:46 <jle`> and type Writer w = WriterT w Identity
18:39:26 <jle`> the problem with this tuply version is that you can potentially get O(n^2) writing runtime if you associate badly
18:39:38 <jle`> so replicateM n (tell x) might be O(n^2)
18:39:50 <trigone> jle`: you mean if <> is (++) for example?
18:40:01 <jle`> yeah, and depending on how replicateM associates under the hood
18:40:15 <jle`> a more efficient way would be to make Writer a wrapper over State
18:40:25 <jle`> and tell x = modify (<> x)
18:40:44 <jle`> er wait
18:41:07 <jle`> maybe.
18:41:09 <trigone> jle`: ok... i don't get how WriterT can define Writer, and yet the former has type WriterT (m (w, a)) and the latter Writer (a, w)... or is there two implementations of Writer?
18:41:24 <jle`> Writer (a, w) doesn't exist in transformers
18:41:29 <jle`> or in any other major library
18:41:39 <jle`> it used to, back in the old days
18:41:53 <trigone> jle`: so... should i use the transformers version or the base version?
18:42:02 <jle`> base doesn't have Writer
18:42:16 <trigone> ok... so where is Writer (a,w)?
18:42:42 <jle`> it doesn't exist anywhere in any commonly used library
18:42:47 <trigone> @src Writer
18:42:47 <lambdabot> type Writer w = WriterT w Identity
18:42:47 <lambdabot> --OR
18:42:47 <lambdabot> data Writer w a = Writer { runWriter :: (a, w) }
18:42:54 <jle`> it's usually a pedagogical learning example
18:42:59 <jle`>  @src doesn't actually use any real code
18:43:05 <jle`> it's just a grep on a text file somewhere
18:43:23 <jle`> it's pretty much the same engine as @quote
18:43:44 <jle`> @quote java
18:43:44 <lambdabot> java says: public class Hello{ public static void main(String [] args){ System.out.println("Hello, World!"); } }
18:43:54 <jle`> arbitrary responses for a given lookup key
18:44:39 <trigone> @quote javascript
18:44:39 <lambdabot> medfly says: I wanted to use xmonad and yi, just to be cool like that, but to write javascript.
18:44:49 <trigone> @quote javascript
18:44:50 <lambdabot> ion says: monad.bind = function (func, args) { return func.apply(undefined, [value].concat(Array.prototype.slice.apply(args || []))); }; is idiomatic JavaScript?
18:45:30 <trigone> jle`: thx for all the explanations :)
18:45:42 <jle`> no problem :)
18:56:36 <crucify_me> jle`, could you write a little function for that signature? jackel :: (Ord a, Eq b) -> a -> b -> a , just so it will return something that I can ponder ? if you have time
18:58:38 <trigone> is there a way to write a unified Class Wrapper w v | w -> v where unwrap :: w v -> v ?
18:58:47 <Cale> crucify_me: jackel x y = x
18:59:23 <trigone> so every (newtype Bla x = Bla x) could use (unwrap bla) (modulo an implementation of the class Wrapper ofc)
18:59:44 <Cale> trigone: I don't think you want that functional dependency
18:59:50 <crucify_me> Cale thanks sorry its so basic I'm in confused mode
19:00:15 <trigone> Cale: hm i guess... i was thinking of wrappers for known types, aka newtypes
19:00:20 <byorgey> trigone: that's essentially what http://hackage.haskell.org/package/lens-4.15.3/docs/Control-Lens-Wrapped.html is
19:00:56 <Cale> trigone: I was going off of the type signature you gave for unwrap
19:01:09 <Cale> trigone: Where apparently w has a type parameter
19:01:43 <trigone> oh right, newtypes wouldn't indeed, i mixed things up
19:01:52 <trigone> unwrap :: w -> v, then?
19:02:25 <trigone> byorgey: how is that module used?
19:03:41 <byorgey> trigone: for example, you get your 'unwrap' by using the 'op' function from that module
19:03:47 <byorgey> > op Sum (Sum 3)
19:03:49 <lambdabot>  3
19:04:12 <byorgey> 'op Sum' means to do the "opposite" of Sum and unwrap instead of wrap
19:05:05 <trigone> byorgey: right... that's not terribly... polymorphic? since you have to give out the wrapper... it's kinda weird, are there types for which you'd have more than one wrapper to unwrap or sth?
19:05:30 <trigone> :t op
19:05:31 <lambdabot> Wrapped s => (Unwrapped s -> s) -> s -> Unwrapped s
19:06:10 <byorgey> trigone: sure, because it works for things more general than just newtypes.
19:06:26 <byorgey> trigone: maybe what you should really look at is the newtype package:  http://hackage.haskell.org/package/newtype-0.2/docs/Control-Newtype.html
19:06:30 <trigone> hm... basically, it's a Wrapped class that does not have a dependency between the Wrapper and the Wrapped... right?
19:06:43 <byorgey> right
19:07:16 <Myrl-saki> Holy shit what
19:07:16 <athan> If functions that end in _ denote thrown away return values, like traverse_, what would be a good tradition for a forgetful function that throws away some content, like `m (f a) -> m a`?
19:07:20 <Myrl-saki> How does that even work
19:07:39 <trigone> byorgey: hey Newtype is cool... so why is it not more used? i see everywhere clumsy runStuff and runThing even when really they don't have feet to run...
19:08:04 <crucify_me> off topic anyone know how to set ghci_history to store all history from session to session ? Like put the date/timestamp on the sessions?
19:08:44 <Myrl-saki> Ohhh
19:09:03 <trigone> athan i'd say it performs some sort of... reduction? your signature makes me think about join, otherwise dunno...
19:09:04 <Myrl-saki> So, `(Unwrapped s -> s)` is only used to give information about which instance to use?
19:09:52 <byorgey> trigone: note that the 'newtype' package is pretty much superseded by 'lens' (which I linked to at first), but lens is much more complicated/general so I thought you would enjoy looking at newtype.
19:09:56 <byorgey> Myrl-saki: correct
19:10:18 <Myrl-saki> That's still pretty funny lmao
19:10:39 <trigone> byorgey: yeah, both links are very interesting :) do we have to compile Lens to get Control.Newtype??
19:10:44 <byorgey> trigone: no
19:10:46 <Myrl-saki> Imagine writing that without the type.
19:10:59 <Myrl-saki> (Or rather, giving the definition to someone without the type.)
19:11:04 <byorgey> Control.Newtype is from the newtype package, it is older than lens
19:11:09 <trigone> byorgey: hey it's in its own module, wha do you mean by "superseded?
19:11:17 <geekosaur> crucify_me, it uses a single history file, you can however remove the limit on its size http://trac.haskell.org/haskeline/wiki/UserPrefs
19:11:28 <trigone> byorgey: nevermind, i get wha you meant :)
19:11:32 <athan> trigone: yeah it's actually a really funny use case
19:11:39 <crucify_me> sweet thanks geekosaur  
19:12:12 <athan> basically, with MonadBaseControl and MonadTransControl, the "running" function which can turn a monadic expression into a base expression, will pack the monad's state in `f`. Basically, I want to throw away that monadic state
19:13:07 <trigone> so, why don't all newtypes enjoy the perks of Control.Newtype? they'd not need to use such clunky pseudo-accessors just to make a projector
19:13:56 <crucify_me> that .haskeline file goes in .ghc ? geekosaur 
19:15:05 <trigone> btw what's the deal with orphan instances, is it that bad?
19:15:58 <geekosaur> crucify_me, in ~
19:16:03 <geekosaur> I think
19:16:15 <geekosaur> yes
19:16:58 <crucify_me> thanks what's that completionType: MenuCompletion setting ? geekosaur  thanks a lot
19:17:14 <trigone> how can i get a list of all instances of a class across all of hackage?
19:17:16 <geekosaur> what happens when you press tab
19:19:27 <crucify_me> thanks
19:23:08 <HallaSurvivor> Hey! Does anybody happen to know why our option constructor is called Just? It seems like a strange name.
19:23:26 <HallaSurvivor> I've done some cursory googling, and I've found speculation, but nothing super concrete
19:25:27 <trigone> HallaSurvivor: Just v is "just (=merely) v, nothing more nothing less, beyond the wrapping".
19:27:35 <trigone> byorgey: i don't get why Control.Newtype.op requires the pack function as parameter. why is there a need for it, when the Newtype instance is directly implied by the type of the wrapped value (n)?
19:28:36 <trigone> byorgey: aka, in theory, we should be able to use unpack directly without having to give the pack function, should we not?
19:30:09 <c_wraith> trigone: just because you know the function exists doesn't imply the compiler knows how to find it.
19:31:10 * hackagebot algebraic-graphs 0.0.5 – A library for algebraic graph construction and transformation – https://hackage.haskell.org/package/algebraic-graphs
19:31:58 <HallaSurvivor> trigone: Makes enough sense, sorry for the silly question, haha
19:33:05 <trigone> HallaSurvivor: np :) it's not the coolest label ever chosen anyway
19:33:10 <ertes> manek: i'm having difficulty producing a C version that doesn't just optimise the whole loop away
19:33:51 <ertes> manek: i've tried the following trick: int bench(int n, volatile int x) { for (int i = 0; i < n; i++) x++; return x; }
19:33:54 <trigone> c_wraith: but with functional dependency, it should not have alternatives to choose from... ?
19:34:31 <ertes> manek: but now GCC refuses to do certain optimisations like using register variables
19:34:52 <ab9rf> ertes: volatiles can't be kept in a register
19:35:52 <ertes> yeah, i expected that, but i thought maybe due to caching it would still be on the same performance level as a register
19:35:55 <ertes> far from it
19:36:10 <geekosaur> um, volatile wants to defeat caching too
19:36:33 <geekosaur> it's for things like device registers that aren't real memory but a communications channel
19:36:53 <geekosaur> or things that get changed without notice by other threads, etc.
19:37:09 <ertes> anyway, i have produced a benchmark that GCC can't optimise away
19:37:13 <ab9rf> volatile signals the compiler to assume that the value stored in that memory location could change at any time, and to never store it in an temporary location for any period of time at all
19:37:49 <c_wraith> trigone: oh, that's a slightly different case.  For that one, the important part is that providing the constructor pins the types down so that inference isn't completely wide open.  Sometimes it's important to narrow the possibilities
19:38:15 <glguy> trigone: the function parameter of 'op' is just for type inference
19:38:49 <trigone> c_wraith: but, why is it necessary when you have a method unpack that doesn't seem to have trouble finding the Newtype instance just from its one parameter?
19:38:55 <ertes> haskell version: bench :: Word64 -> Word64 -> Word64; bench 0 a = a; bench i a = bench (i - 1) $! a + a + a + 2
19:38:55 <ertes> C version: uint64_t bench(uint64_t n, uint64_t x) { for (uint64_t i = 0; i < n; i++) x = 3*x + 2; return x; }
19:38:55 <ertes> they have exactly the same performance
19:38:55 <ertes> manek: ^
19:38:55 <ertes> both need roughtly 990ms
19:38:55 <ertes> *roughly
19:38:55 <trigone> 's type
19:39:28 <c_wraith> trigone: it's not necessary.  it exists so that it can be used when it makes inference better.
19:39:56 <c_wraith> trigone: it completely ignores its argument, so unless the optimizer falls down entirely, it's just as efficient.
19:40:10 <trigone> c_wraith: but when could it make it "better"? and what does it mean to say "a less better inference"?
19:41:07 <c_wraith> trigone: inference is better when you don't have to pass proxies or provide manual annotations to to pin down the types
19:41:08 <trigone> c_wraith: didn't mean less efficient, but you gotta explicitly give it the pack function, which mostly erases the purpose of ad-hoc polymorphism, unless i missed something...
19:41:12 <glguy> worse inference is when inference fails and things are ambiguous
19:41:31 <trigone> c_wraith: ooh, so you mean the purpose is when you don't provide (enough) type signatures
19:42:04 <ab9rf> i'm not entirely sure that ad-hoc polymorphism is a good thing
19:42:25 <trigone> c_wraith: since apparently other classes don't bother with this, i'm not sure how useful that thing is... but whatever
19:42:26 <c_wraith> trigone: it's like asTypeOf.  Occasionally it just makes your code better.
19:42:27 <trigone> ab9rf: why?
19:42:35 <c_wraith> :t asTypeOf
19:42:36 <trigone> c_wraith: don't know of asTypeOf
19:42:37 <lambdabot> a -> a -> a
19:42:51 <trigone> c_wraith: i get it (i think).
19:43:04 <c_wraith> > return 5 `asTypeOf` Nothing
19:43:06 <lambdabot>  Just 5
19:44:02 <trigone> c_wraith: if you give type signatures to all floor-level values, do you really ever get type inference issues?
19:44:47 <trigone> i couldn't code with a minimum of explicit types, esp since i reason mostly in the types (but maybe it's bc i'm a beginner)
19:45:26 <orion> Stack doesn't build with 8.2.1. :(
19:45:28 <c_wraith> trigone: sometimes it happens.  usually when you need to have an intermediate value be of a type related to an input or output value.
19:45:37 <trigone> s/with/without
19:45:48 <ertes> manek: you get the same performance with a version based on lists due to list fusion
19:46:09 <ertes> index' :: Int -> [a] -> a; index' n xs = foldr (\x go i -> x `seq` if i > 0 then go (i - 1) else x) (const undefined) xs n; bench :: Int -> Word64 -> Word64; bench n = index' n . iterate (\x -> x + x + x + 2)
19:46:29 <c_wraith> trigone: which can happen sometimes when you're using underconstrained polymorphism.  things like freeze or thaw from vector, for instanec.
19:46:51 <trigone> c_wraith: hm... maybe i vaguely see what you mean... something that could not be inferred either from the input or from the output...?
19:47:12 <c_wraith> trigone: exactly.
19:47:36 <trigone> c_wraith: is there an `op` equivalent for thaw/freeze?
19:47:41 <c_wraith> trigone: there is not
19:48:17 <trigone> c_wraith: so you use asTypeOf? since you say they cause trouble (i only vaguely heard of them so)
19:49:32 <c_wraith> trigone: you can usually use ScopedTypeVariables as a solution, but sometimes it's annoying.  As a one-off, sometimes you use a function that is identical to another function but takes an extra argument to pin down types without ScopedTypeVariables
19:49:57 <trigone> what's ScopedTypeVariables?
19:50:41 <c_wraith> It's an extension that allows type variables in a signature to be in scope without the body of the accompanying binding.
19:50:54 <c_wraith> It does a couple other things too, but that's the important part here.
19:51:19 <trigone> k
19:51:24 <trigone> thk :)
19:52:06 <c_wraith> err, in scope *within* the body...
19:56:16 <trigone> c_wraith: maybe there should be a keyword to tag just one type variable as scoped, instead of everything everywhere (at least in the module), which i assume is the drawback of that options?
19:56:37 <trigone> i hardly know if it's doable though
19:56:47 <glguy> There is a keyword that tags a type signature as using scoped type variables
19:56:51 <c_wraith> trigone: actually, it repurposes the forall keyword that purpose
19:56:56 <c_wraith> that's part of why it's so awkward
19:57:28 <c_wraith> The extension does basically nothing unless you remember to use it.
19:58:49 <trigone> is the forall keyword usable? does it require extension? are there limitations due to the implementation?
19:58:59 <glguy> :t (show . read) `asTypeOf` id
19:59:00 <lambdabot> String -> String
19:59:10 <c_wraith> forall is a keyword used by at least 3 different extensions.
19:59:15 <glguy> :t (read . show) `asTypeOf` id
19:59:16 <c_wraith> But it's only used by extensions.
19:59:16 <lambdabot> (Show c, Read c) => c -> c
20:00:03 <trigone> :t read . show
20:00:04 <lambdabot> (Show a, Read c) => a -> c
20:01:03 <trigone> c_wraith: ok... i'll look into in, someday. :)
20:07:45 <EchoLogic> teaching myself haskell, would like to split a string by spaces. I can split on the first space. Guess I need to learn something recursion related? http://lpaste.net/357294
20:12:29 <mrkgnao> EchoLogic: if you can split on the first space, why don't you try splitting the remainder again? (this is recursive, yes)
20:14:47 <EchoLogic> mrkgnao: Thought as much. Can you provide a link to the necessary syntax I might need?
20:15:17 <mrkgnao> what are you reading? 
20:15:45 <mrkgnao> any introductory reference (haskellbook, LYAH, ...) will go into these things
20:17:23 <EchoLogic> mrkgnao: LYAH
20:20:09 <texasmynsted> how are you all hosting your haskell apps?
20:20:20 <texasmynsted> or is there a better place to ask this?
20:21:01 <Clint> i host them on computers
20:22:33 <glguy> Clint: exclusively?
20:23:40 <Clint> glguy: i might host one or two in someone's dreams
20:24:23 <EchoLogic> mrkgnao: recursion pertaining specifically to takeWhile seems to be impossible (?) because I am not doing the `(x:xs)` thing (technical term)
20:24:49 <mrkgnao> EchoLogic: sorry, I'm a bit busy right now
20:25:20 <mrkgnao> you hshouldn't needto go character-by-character if you have a splitOnFirstSpace function
20:27:31 <jle`> texasmynsted: i used heroku at one point
20:30:10 <EchoLogic> anyone here know how I can take the remainder from takeWhile and do something recursively with it?
20:30:48 <jle`> hm, what does that mean?
20:31:26 <EchoLogic> no idea. 
20:31:39 <jle`> take the remainder from takeWhile and do something recursively with it
20:31:45 <jle`> i feel like i understand all of those words separately
20:32:02 <jle`> but i have some issues putting them together
20:32:13 <jle`> is there a specific thing you're trying to do?
20:32:26 <EchoLogic> "teaching myself haskell, would like to split a string by spaces. I can split on the first space. Guess I need to learn something recursion related? http://lpaste.net/357294"
20:33:20 <jle`> EchoLogic: instead of using takeWhile, you can use span
20:33:37 <jle`> > span isDigit "1234abc1234"
20:33:39 <lambdabot>  ("1234","abc1234")
20:33:49 <jle`> takeWhile p xs = fst (span p xs)
20:34:11 <jle`> takeWhile is just span but you drop the second part
20:34:20 <EchoLogic> what is `p`and what is `fit`?
20:34:22 <EchoLogic> *fst
20:34:30 <jle`> > fst (1,2)
20:34:32 <lambdabot>  1
20:34:40 <EchoLogic> so returns the lowest number? :P
20:34:47 <EchoLogic> or "first"? :P
20:34:54 <jle`> i'm saying that if you call takeWhile ith arguments 'p' and xs, you get the first item in span p xs
20:34:58 <jle`> EchoLogic: i know one way to find out :)
20:35:08 <jle`> try testing it :o
20:35:16 <jle`> alternatively, look at the type
20:36:09 <jle`> EchoLogic: but yeah, takeWhile is like span but it gets rid of the remainder
20:36:21 <jle`> span returns the things taken as well as the remainder
20:38:04 <EchoLogic> jle`: so that teaches me how to use span, but it doesn't tell me how to recurse over the remainder
20:38:33 <jle`> recusion isn't anything special in haskell
20:38:37 <jle`> you'd just call the function again on the remainder
20:38:55 <jle`> try taking it step by step
20:40:37 <jle`> EchoLogic: slit p xs = let (firstPart, secondPart) = span p xs in ....
20:40:46 <jle`> what's the answer?
20:40:53 <EchoLogic> jle`: oh, on another note, is there something wrong with my guard syntax here? I keep trying to convert a list of I guess you'd call them function statements and convert them to a guard but I always get a parse error when I try (possibly incorrect indentation or mismatched brackets) http://lpaste.net/357295
20:40:54 <jle`> how do you re-combine firstPart and secondPart into the thing you want?
20:41:13 <jle`> EchoLogic: yes you're missing the equals sign after otherwise
20:41:31 <EchoLogic> that'd help. Back to span...
20:41:35 <EchoLogic> thx
20:41:38 <jle`> no problem :)
20:43:32 <texasmynsted> jle`: what do you use now?
20:43:38 <texasmynsted> dokku?
20:44:24 <jle`> i still use heroku, but also sometimes digital ocean.  my static sites i use github pages
20:46:14 <EchoLogic> jle`: what exactly does `Couldn't match type ‘([Char], [Char])’ with ‘[Char]’` mean?
20:46:20 <EchoLogic> I know [Char] is just String
20:46:31 <jle`> EchoLogic: ([Char], [Char]) is a tuple of two strings
20:46:39 <EchoLogic> where in the world is it getting that from
20:46:45 <geekosaur> span?
20:46:47 <geekosaur> :t span
20:46:49 <lambdabot> (a -> Bool) -> [a] -> ([a], [a])
20:46:50 <jle`> "couldn't match X with Y" means that you are giving it a Y, but it's expecting X
20:46:59 <jle`> EchoLogic: need more code to be able to answer
20:47:37 <EchoLogic> my latest bonfire http://lpaste.net/357296
20:47:47 <EchoLogic> shouldn't it be expecting [String] not [String]?
20:47:55 <jle`> hm
20:47:56 <EchoLogic> err, [String] not String?
20:48:12 <jle`> you are returning [(String, String)]
20:48:20 <jle`> you are returning a list
20:48:21 <texasmynsted> Just wanting a solution that will scale.
20:48:23 <jle`> whose only item is the result of span
20:48:31 <EchoLogic> The expected type should be "String" though
20:48:41 <EchoLogic> ugh, wait. No.
20:48:41 <texasmynsted> DO should scale
20:48:48 <jle`> according to the type of split, you are expecting a [String]
20:49:00 <EchoLogic> I need to step back 
20:49:15 <EchoLogic> because I'm getting myself thoroughly confused here.
20:49:22 <jle`> sometimes stepping back helps :)
20:49:32 <monochrom> Where is the recursion?
20:49:32 <jle`> the nice thing about haskell is that the compiler catches these errors for you
20:49:49 <EchoLogic> monochrom: still nonexistent. 
20:49:56 <jle`> try the pattern i started for you
20:50:07 <jle`> split p xs = let (firstPart, secondPart) = span p xs in ....
20:50:20 <EchoLogic> do I have to convert it back from a guard to try that?
20:50:28 <jle`> you don't
20:50:32 <jle`> but the guard isn't really necessary either
20:51:09 <EchoLogic> I presume `...` should be replaced by `secondPart`?
20:51:15 <EchoLogic> since that's the "remainder"
20:51:19 <jle`> it should be replaced by whatever you want it to be
20:51:25 <jle`> are you familiar with let ... in ... syntax?
20:51:35 <jle`> the second ... is your final result
20:51:51 <jle`> so for split p xs = let (firstPart, secondPart) = span p xs in ...., you'd put what you want your final result to be
20:51:53 <jle`> in the ....
20:51:56 <EchoLogic> in more... ahem... conventional languages, yeah I know what let in does :P
20:52:09 <jle`> so don't put secondPart there :)
20:52:13 <jle`> i mean, don't just put it alone
20:52:20 <jle`> it'd probably not be the result you want
20:52:34 <jle`> you wouldn't want splp xs to just return the "second part"
20:52:36 <Welkin> isn't `let` explained in LYAH using the beatles song "Let it be"?
20:52:56 <monochrom> I guess songs have no predictive power.
20:53:01 <EchoLogic> okay well I got an infinite loop there
20:53:44 <jle`> EchoLogic: try walking thorugh an example
20:53:54 <jle`> say you want to split isAlphaNum "hello world"
20:54:00 <EchoLogic> http://lpaste.net/357297
20:54:23 <jle`> EchoLogic: yes that is definitely not the answer you want
20:54:27 <EchoLogic> lol
20:54:32 <jle`> don't you want to keep the first part, too?
20:54:46 <EchoLogic> I think so?
20:54:47 <jle`> what should split isAlphaNum "hello world 123" give?
20:54:58 <EchoLogic> ["hello", "world", "123"]
20:55:01 <jle`> yes
20:55:04 <EchoLogic> so I need the first part.
20:55:07 <jle`> > span isAlphaNum "hello world 123"
20:55:09 <lambdabot>  ("hello"," world 123")
20:55:13 <jle`> mhm, the first part is important
20:55:39 <jle`> i would suggest not just typing things in until they typecheck
20:55:41 <jle`> walk through an example
20:56:09 <jle`> if you called split isAlphaNum "hello world 123", you can start with span and get firstPart = "hello", secondPart = " world 123"
20:56:15 <jle`> how do you use those to build your final result?
20:56:29 <jle`> what do you do with firstPart, and what do you do with secondPart?
20:56:42 <EchoLogic> [firstPart ++ split fn secondPart]?
20:56:45 <jle`> if you want ["hello", "world", "123"]
20:57:05 <jle`> you don't have to ask me
20:57:07 <jle`> ask the compiler :)
20:57:51 <Welkin> you are the compiler
20:58:10 <EchoLogic> Welkin: I'm just dumb.
20:58:55 <trigone> hi, i'd like to know if monad transformers is a good design pattern, or not :)
20:59:14 <jle`> there is a place to use them
20:59:17 <jle`> and a place to not use them
20:59:27 <jle`> there is no blanket answer for all situations
20:59:40 <Welkin> I was just reading in my erlang book about constructing lists. The recommended way of doing it is (of course) consing onto the head of the list, then reversing if you want to maintain the same order.
20:59:56 <Welkin> Can't construct the list in-place like in haskell because it is strict instead of lazy
20:59:59 <Welkin> I suppose
21:00:35 <EchoLogic> jle`: so `split fn xs = let (firstPart, secondPart) = span fn xs in [firstPart ++ split fn secondPart]
21:00:35 <EchoLogic> ` doesn't work.
21:00:37 <Welkin> trigone: I wouldn't call it a "design pattern" as that has baggage and historical connotations that don't apply here
21:00:44 <jle`> EchoLogic: what is the problem?
21:00:53 <Welkin> but yes, monad transformers are one way to "compose" monads
21:01:16 <EchoLogic>  Couldn't match type ‘[Char]’ with ‘Char’. Expected type: [Char]. Actual type: [String]
21:01:18 <monochrom> That's right. In Haskell "print (map sin [1..n])" is O(1) space, in SML Omega(n) space.
21:01:59 <monochrom> When I hear "space leaks" I say "eagerness leaks space too".
21:02:09 <jle`> EchoLogic: looks like you have a list of list of strings
21:02:19 <jle`> that probably happened because you're putting everything in []
21:02:30 <jle`> [x] is just... a list with only one item, x
21:02:57 <jle`> EchoLogic: even if firstPart ++ split fn secondPart is correct...you won't be getting your answer as a result
21:03:01 <EchoLogic> even removing the brackets doesn't help though... The error just flips.
21:03:03 <jle`> you'll be gettilng a list whose only item is your answer?
21:03:15 <EchoLogic> and by "flip" I mean the actual type and expected type are swapped
21:03:24 <jle`> so you have firstPart ++ split fn secondPart
21:03:28 <jle`> what do you think (++) does?
21:03:32 <jle`> (what is its type?)
21:03:33 <EchoLogic> concatenate
21:03:39 <jle`> what does it concatenate
21:03:44 <jle`> two lists of the same type, right?
21:03:56 <jle`> but...you don't have two lists of the same type
21:04:01 <jle`> you have an item and a list of that item
21:04:02 <monochrom> Yeah, answer the question "what's its type".
21:04:06 <EchoLogic> I don't? 
21:04:09 <jle`> yes
21:04:12 <jle`> firstPart is String
21:04:16 <jle`> but split fn secondPart is [String]
21:05:08 <EchoLogic> sure, okay. I can see that from the, I guess you'd call it... type definition.
21:05:17 <jle`> you probably don't want (++)
21:05:17 <EchoLogic> Not sure that's the proper terminology.
21:05:18 <jle`> :t (++)
21:05:20 <lambdabot> [a] -> [a] -> [a]
21:05:22 <jle`> you probably what (:)
21:05:24 <jle`> :t (:)
21:05:25 <lambdabot> a -> [a] -> [a]
21:05:33 <monochrom> The proper terminology is just "type".
21:06:43 <EchoLogic> How do I google this stuff? I can't just google a colon prepended to the search phrase "haskell"
21:07:10 <EchoLogic> I'll call it the smiley face operator.
21:07:11 <jle`> you can use hoogle
21:07:38 <EchoLogic> I tried using hoogle earlier! Every search was a parse error, so I gave up lol
21:07:54 <jle`> @hoogle a -> [a] -> [a]
21:07:54 <lambdabot> Data.List intersperse :: a -> [a] -> [a]
21:07:54 <lambdabot> GHC.OldList intersperse :: a -> [a] -> [a]
21:07:54 <lambdabot> Data.Text.Internal.Functions intersperse :: a -> [a] -> [a]
21:07:59 <jle`> oh huh that's not too helpful
21:08:04 <jle`> i guess it's because (:) is a built-in function
21:08:29 <jle`> usually most things you can hoogle or checkout out in ghci
21:08:34 <EchoLogic> okay so (:) is just giving me another infinite loop
21:08:40 <EchoLogic> `split fn xs = let (firstPart, secondPart) = span fn xs in firstPart : split fn secondPart`
21:08:44 <jle`> but even if you didn't know how to use (:), you can just do [firstPart] ++ split fn secondPart
21:09:05 <EchoLogic> tried that! the compiler didn't like it. let me fetch the error.
21:09:06 <jle`> EchoLogic: you need to give yourself a base case
21:09:12 <EchoLogic> base case?
21:09:23 <jle`> a "non-recursive" branch
21:09:29 <jle`> so we know when to stop recursing
21:09:50 <jle`> so we can know once we're done
21:10:02 <EchoLogic> right
21:10:07 <EchoLogic> Here's what I have currently, at least. http://lpaste.net/357298
21:10:47 <jle`> when in doubt, try manually evaluating things by hand step-by-step
21:10:51 <ab9rf> i wouldn't use the xs == "" guard
21:10:58 <jle`> that's one of the things that haskell is good for :)
21:11:02 <jle`> something you can't do in other languages
21:11:12 <jle`> try split isAlphaNum "the quick brown fox"
21:11:13 <ab9rf> just pattern-match on an empty string
21:11:29 <ab9rf> split _ "" = []
21:11:31 <jle`> EchoLogic: the trick is to replace all function calls by their body
21:11:36 <ab9rf> split fn xs = [span fn xs]
21:11:50 <EchoLogic> ab9rf: ?
21:12:01 <jle`> so split isAlphaNum "the quick brown fox" => let (firstPart, secondPart) = span isAlphaNum "the quick brown fox" in firstPart : split fn secondPart
21:12:16 <jle`> we just replaiced any occurence of 'split p xs' into the actual function body
21:12:25 <jle`> in this case, what is firstPart, and what is secondPart
21:12:28 <jle`> ?
21:13:09 <EchoLogic> ["the"] and ["quick brown fox"]?
21:13:13 <jle`> not quite
21:13:26 <jle`> try it out on ghci
21:14:10 <trigone> thx Welkin, jle`
21:15:18 <jle`> trigone: :D     ; my answer wasn't too descriptive though, it's just that transformers are good in someone situations and bad in others.
21:17:48 <trigone> jle`: i noticed you liked answering "everything is relative" to many questions :P my original inquiry was mostly in the spirit of "is it truly a good idea or is it the kind of thing that should mostly lead to refactoring the program `somehow` instead"
21:18:17 <jle`> it depends on where you use it, really
21:18:23 <jle`> it's a good idea for a lot of situations
21:18:37 <jle`> i use them as one-offs all the time
21:18:48 <EchoLogic> my error is now about 20 lines long lol
21:18:50 <jle`> if i need to filter through a bunch of [IO (Maybe a)]'s
21:18:52 <trigone> sometimes the most popular things are the worst but the least (subjectively) complicated, and since monad transformers have some degree of popularity, esp among "beginner tutorials", i was wondering.
21:19:08 <jle`> instead of writing a manual recursive function to find the first IO that succeeds
21:19:16 <jle`> i can just wrap each item in MaybeT
21:19:20 <jle`> and then use something like 'asum'
21:19:51 <jle`> trigone: ah.  yes i tend to only use monad transformers in situations where they are immediately unwrapped
21:20:17 <jle`> this is very different than the style of using monad transformers as a basis for the architecture of your program
21:20:34 <trigone> jle`: ok :) so when say you have some environment data not-used-everywhere, do you pass it around manually?
21:20:41 <trigone> jle`: indeed
21:21:05 <trigone> :t traverse
21:21:07 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
21:21:08 <monochrom> I don't see what's wrong in answering "relative" or more precisely "depends". I don't even say "always use OOP" or "don't use OOP". I don't even assign a probability very close to 0 or 1.
21:21:32 <monochrom> It is not like your questions are of the form "is 1 a natural number?"
21:21:37 <jle`> there's a tipping point where the cognitive and syntactical overhead of passing it around manually becomes large enough that ReaderT makes things significantly cleaner
21:21:47 <jle`> there's always a balance
21:21:53 <trigone> monochrom: me neither, that was just a quip, don't take it like that
21:22:00 <EchoLogic> okay I'm not getting anywhere with this. 
21:22:11 <jle`> trigone: sometimes i use ReaderT and sometimes i don't
21:22:14 <EchoLogic> need to shelve this for a while.
21:22:21 <jle`> i usually default to not using it until it becomes helpful
21:22:21 <EchoLogic> thanks for your help anyway jle` 
21:22:27 <jle`> EchoLogic: no problem :) you're very close btw.
21:22:31 <trigone> jle`: yeah :) experience will guide me then
21:23:53 <trigone> thx :)
21:23:57 <jle`> trigone: but, there is a style of structuring your entire application around a composition of several monad transformers.  this one is a bit controversial
21:24:33 <trigone> anybody knows of "extensible effects" as alternative to monad transformers? does it work? http://okmij.org/ftp/Haskell/extensible/exteff.pdf
21:25:06 <jle`> for what it's worth, i don't use transformers as a tool to combine effects
21:25:18 <trigone> jle`: how are programs structured when they don't use monad stacks? cuz intuitively it does seem very easy to fall into that kind of structuring...
21:25:26 <trigone> jle`: it's hard to tell what that entails...
21:26:09 <jle`> "i need a context withe state, environment, writer logging, and IO...i'll build one with monad tranformers"
21:26:10 <jmcarthur> I think monad transformers are best used as tools for building higher level abstractions. If you actually see them throughout your application, you're using them badly.
21:26:32 <jle`> using monad transformers to add effects to existing monads
21:26:34 <jle`> this isn't something i use them for
21:26:51 <jle`> but this is just personally me.
21:27:05 <jle`> so to me, extensible effects and monad transformers are unrelated things.
21:27:16 <trigone> jmcarthur: not sure what you mean...
21:27:36 <jmcarthur> Put another way, for me they are basically just a way of making GeneralizedNewtypeDeriving more useful sometimes.
21:27:51 <trigone> jle`: extensible effects is the name of an alternative to monad transformers, cf the link i game, which i started reading
21:28:08 <jle`> they are an alternative to monad transformers in the domain of a specific usage of monad transformers
21:28:22 <jle`> but for that usage, I would not use monad transformers anyway
21:28:29 <jle`> that's like saying Int is an alternative to String
21:28:38 <jle`> yes, Int can be used in some situations where other people would use String
21:28:44 <jle`> but i'm not someone who uses String for those situations anyway
21:29:08 <jmcarthur> This is also how I feel.
21:29:36 <jmcarthur> Extensible effects aims to solve a problem I don't have.
21:29:43 <trigone> jle`: ok, i get what you mean. i don't manage to understand any instance to those specific cases, but i get the spirit...
21:30:02 <trigone> s/understand/imagine on the fly/
21:30:18 <jle`> trigone: some people use monad transformers to accomplish X goal, and extensible effects can also X goal as well.  but X goal is not the *only* usage of monad transformers
21:30:37 <jle`> for example, String can be used as a rudimentary type to replace non-negative integers
21:30:48 <trigone> jle`: *that* i understand. but without ANY idea of what X would look like, that information remains terribly abstract
21:30:48 <jle`> 0 can be []
21:31:57 <jle`> trigone: ah.  extensible effects tries to give you a monad where you can pick-and-choose the type of effects for
21:32:04 <jle`> or, ways to construct that monad
21:32:35 <jle`> but yeah, this is something you'll see more when you write more application code
21:32:43 <trigone> application code?
21:33:01 <jle`> code for executables/applications
21:33:13 <jle`> as opposed to an abstract library
21:33:46 <jle`> not saying that this issue doesn't come up in library code, but application code tends to bring out the ugliest in situations :)
21:34:25 <trigone> jle`: what is "this" in "this is something you'll see more..."
21:34:35 <trigone>  yeah... tbh it's pretty hard to find application code that is not too huge and therefore readable...
21:34:43 <jle`> you'll get a better picture of the problem that extensible effects intends to solve
21:35:05 <trigone> jle`: hm... and you say you have a better approach, so i'd be interested in understanding it...
21:35:17 <jle`> and their trade-offs with monad transformers for the same problem
21:35:26 <jle`> for me it's case-by-case
21:35:30 <jle`> ;)
21:36:11 <trigone> you said ""they are an alternative to monad transformers in the domain of a specific usage of monad transformers /// but for that usage, I would not use monad transformers anyway", so what did you imply to use?
21:36:44 <trigone> it looked as if you used neither
21:36:45 <jle`> i usually write my own monads
21:37:06 <jle`> well, for coding actual logic, i write to typeclasses normally
21:37:13 <jle`> like MonadState
21:37:19 <trigone> jle`: ok :) and you don't rewrite too many times the same code?
21:37:40 <jle`> well if all your application logic is in typeclasses
21:37:49 <jle`> you only need to pick a concrete instance at one point
21:38:03 <trigone> jle`: i suppose...
21:38:29 <jle`> but yeah this isn't prescriptive advice
21:38:34 <trigone> i'd have to see what your monads do to understand why you don't need transformers
21:38:40 <trigone> prescriptive advice?
21:38:53 <trigone> (why you don't need them in certain cases)
21:39:07 <jle`> this isn't something that i'm saying intending for you to do the same thing
21:39:16 <jle`> it's just a factual statement of my own habits
21:40:04 <Welkin> trigone: you seem to be too interested in having someone else tell you what to do
21:40:07 <trigone> jle`: i obey no one, but if i'm there asking about your habits it's bc i want to choose my own way by being inspired with as many (good) alternatives as possible
21:40:12 <Welkin> just try it yourself
21:40:14 <Welkin> experiment
21:40:17 <Welkin> see how it goes
21:40:24 <trigone> Welkin: no that's not it at all
21:40:32 <Welkin> monad transformers are useful
21:40:34 <jle`> my typical multiple-effects situation is to defer pikcing an actual type
21:40:48 <Welkin> they are the only way I have ever composed monads in haskell, but I know there are other options as well
21:40:51 <Welkin> they work fine for me
21:40:58 <jle`> and just write MonadState, MonadIO, etc., and use only the constraints that i'd need
21:41:09 <jle`> that way you could even use extensible-effects as your final backend/concrete type
21:41:20 <nshepperd> sometimes I use StateT in the implementation of a function, in order to do a simple accumulating traversal over some data type.
21:41:20 <jle`> or you could use composed transformers
21:41:57 <jle`> yeah, things like this is definitely the more common thing i use monad transformers for.
21:41:59 <nshepperd> runStateT (traverse blah blah)
21:42:07 <jle`> not as a way of structuring the architecture of a program
21:42:56 <trigone> :t traverse
21:42:57 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
21:43:06 <jle`> trigone: but yeah, it might not be too helpful to "pre-emptively" look for solutions to problems you think you might have in the future
21:43:15 <jle`> when you do run into the problem, the specifics of that problem will guide your solution
21:48:18 <trigone> jle`: depends. if i have a solution but it's just not a good one, i can't be sure unless i ask (or if i spend three years using a very bad method in my blind ignorance till i randomly find a better solution, but honestly i prefer asking before ending up there)
21:48:42 <trigone> thanks at any rate :)
22:11:05 <Guest6658> Hello, is there a way to call `deriveJSON` with multiple types? eg $(deriveJSON opts [''User, ''Order])
22:19:26 <pacak> deriveJSON :: Options -> Name -> Q [Dec]
22:19:47 <pacak> sequence (mapM (deriveJSON opts) [''User, ''Order])
22:19:54 <pacak> No idea if that will work though.
22:24:40 * pacak pokes haskeller
22:30:07 <haskeller> it doesn't :(
22:30:10 <haskeller>     • Couldn't match type ‘[]’                      with ‘template-haskell-2.11.1.0:Language.Haskell.TH.Syntax.Q’       Expected type: template-haskell-2.11.1.0:Language.Haskell.TH.Lib.DecsQ         Actual type: [template-haskell-2.11.1.0:Language.Haskell.TH.Syntax.Q                         [template-haskell-2.11.1.0:Language.Haskell.TH.Syntax.Dec]]     • In the expression:         sequence           (mapM (deriveJSON 
22:37:40 <butterthebuddha> Is there an inbuilt function for counting the num of occurences of a number in a list of integers?
22:38:05 <jle`> no built-in function, but you can just build up a map
22:38:18 <pacak> butterthebuddha: What would you like to see in case if an infinite list?
22:38:21 <MarcelineVQ> haskeller, pacak: try fmap concat instead of sequence to get a Q Decs
22:39:08 <butterthebuddha> Does someting like length (filter (== 3) [1, 2, 3] ) work?
22:39:15 <jle`> > M.fromListWith (+) . map (,1) $ "hello world"
22:39:17 <lambdabot>  fromList [(' ',1),('d',1),('e',1),('h',1),('l',3),('o',2),('r',1),('w',1)]
22:40:00 <MarcelineVQ> *DecsQ    aka.  Q [Dec]
22:40:31 <pacak> > map (head &&& L.length) . group . sort $ "hello world"
22:40:33 <lambdabot>  [(' ',1),('d',1),('e',1),('h',1),('l',3),('o',2),('r',1),('w',1)]
22:42:07 <MarcelineVQ> pacak, haskeller:  to clarify    concat <$> mapM (deriveJSON defaultOptions) [''Foo, ''Wub] :: Q [Dec]
22:49:45 <jle`> butterthebuddha: if you just want the number of occurence of a specific integer then yeah, that works
22:51:41 <butterthebuddha> jle`: thanks
22:55:36 <arahael> As a novice haskell dev, when I see that something on hackage is "deprecated", what does it mean?
22:55:45 <arahael> And how do I determine what to use instead? (Eg, system-fileio-0.3.16.3: Consistent filesystem interaction across GHC versions (deprecated)
22:55:55 <arahael>  - That package has no recommended replacements?
22:56:00 <jle`> arahael: deprecated means that you are recommended against using it
22:56:06 <jle`> it's kind of a common term in other languages too i'd think
22:56:08 <trigone> are there any letter-based alternatives to the basic "universal" operators like (/=), (>=), etc? eg "diff/eq", "sup/inf", etc
22:56:15 <arahael> jle`: Other languages usually say: "Use xyz instead".
22:56:39 <arahael> jle`: Or otherwise they make the alternative fairly obvious.
22:57:06 <jle`> sometimes people just realize that their package is very very bad and recommend people against using it
22:57:11 <wz1000> :t compare
22:57:12 <lambdabot> Ord a => a -> a -> Ordering
22:57:16 <wz1000> trigone: ^
22:57:22 <wz1000> > compare 1 2
22:57:23 <jle`> trigone: what is a letter-based alternative?
22:57:25 <lambdabot>  LT
22:57:53 <trigone> wz1000: thanks... it's a bit of a mouthful though, and i'd need to pattern-match it to make it a bool...
22:58:19 <MarcelineVQ> trigone: what do you really need? :>
22:58:31 <arahael> jle`: Ok, so I'll just use something like directory instead.
22:58:45 <trigone> jle`: like i gave as example, "eq/diff", "sup/inf". basically, something which is alphadecimal instead of infix-by-default operator
22:58:46 <jle`> do you mean like a non-operator alias for (==) 
22:58:52 <trigone> jle`: yes!
22:59:01 <`Guest00000> is the function name usually included in the message for fail, like in messages for error?
22:59:06 <trigone> MarcelineVQ: one million dollar please :)
22:59:26 <marvin2> trigone why the "non-operator" requirement? just a preference?
22:59:42 <butterthebuddha> Okay, so I'm working on problem 3 at https://www.seas.upenn.edu/~cis194/spring13/hw/03-rec-poly.pdf
23:00:12 <jle`> `Guest00000: the default implementation for fail is basically 'error'
23:00:17 <butterthebuddha> I'm struggling with converting the list into a histogram
23:00:21 <jle`> fail = error (technically failureWithoutStackTrace)
23:00:34 <trigone> `Guest00000: to my experience, the standard format is "Full.Function.name: error type". however it's usually/always just a literal string apparently, so no guarrantees.
23:00:43 <butterthebuddha> So I'm able to turn the list [1, 1, 1, 5] into [0, 3, 0, 0, 0, 1, 0, 0, 0, 0]
23:00:53 <trigone> btw full function name = Module.Path.functionName
23:01:14 <trigone> marvin2: i noticed i had a tendency to badly read symbol operators, esp the most basic ones (/=, >=, etc). it's way easier for me to write /= 0 and meaning == 0 than if it were written in plain text.
23:01:39 <butterthebuddha> The idea I have in mind, as someone on this channel told me yesterday(?), was to go through the list and decrement each item by 1 while adding a star in the appropriate location to build the string
23:01:51 <jle`> yeah that might have been me
23:02:12 <butterthebuddha> The issue is that that way I'm going to have to go through the list multiple times
23:02:18 <butterthebuddha> Until everything is 0 or below 0
23:02:22 <jle`> indeed
23:02:31 <butterthebuddha> So I'm returning a tuple (list, string)
23:02:49 <butterthebuddha> But if I consume the list using the head:tail pattern, how do I build the list back up?
23:03:00 <jle`> you can just use map instead
23:03:15 <jle`> well, you can us ehead:tail pattern, but that's kind of verbose
23:03:23 <jle`> map through it once to produce the string
23:03:27 <jle`> map through it again to produce the new list
23:03:33 <geekosaur> butterthebuddha, maybe you want an as-pattern
23:03:43 <butterthebuddha> What's an as-pattern?
23:03:51 <jle`> > map (subtract 1) [0,3,0,0,0,1,0,0,0]
23:03:53 <lambdabot>  [-1,2,-1,-1,-1,0,-1,-1,-1]
23:03:55 <jle`> ^ to get your new list
23:04:04 <butterthebuddha> Hmm I think I'll try that 
23:04:12 <jle`> maybe i shouldn't have given everything away
23:04:18 <butterthebuddha> (Wouldn't map ((-1) 1) [..] also work?)
23:04:23 <trigone> so, is there some module somewhere with non-operator aliases for those operators (of Eq, Ord, esp)?
23:04:23 <jle`> what is (-1) 1
23:04:25 <geekosaur> > let f xss@(x:xs) = "list is " ++ show xss ++ " which is " ++ show x ++ " : " ++ show xss in f [1..3]
23:04:27 <lambdabot>  "list is [1,2,3] which is 1 : [1,2,3]"
23:04:29 <`Guest00000> jle`: some monads don't, though, like Get
23:04:33 <geekosaur> er
23:04:36 <geekosaur> > let f xss@(x:xs) = "list is " ++ show xss ++ " which is " ++ show x ++ " : " ++ show xs in f [1..3]
23:04:38 <lambdabot>  "list is [1,2,3] which is 1 : [2,3]"
23:04:47 <jle`> `Guest00000: yeah; you asked for a general answer
23:04:53 <jle`> the real answer is that every Monad is free to implement it however it wants
23:05:00 <geekosaur> trigone, not generally
23:05:09 <`Guest00000> but what is the *recommendation*
23:05:18 <`Guest00000> convention
23:05:51 <geekosaur> trigone, some packages (notably lens) provide function versions of their operators, but that tends to consume names you might want to use for other things
23:06:07 <marvin2> trigone there aren't any in standard (or third party) library that I'm aware of. you can of course define your own, eq = (==), etc
23:06:14 <jle`> `Guest00000: usually it's pretty clear per monad how to treat fail
23:06:17 <trigone> what do you mean "generally"? there's no generalism here, i don't mena *all* operators, just the most basic ones (Eq, Ord), those i honestly don't read well. i can write aliases myself, but if it's already done
23:06:19 <jle`> if there is a way at all
23:06:43 <jle`> `Guest00000: are you only asking if fail's "error message" should include "fail: ...", or not?>
23:07:25 <trigone> > 3 `compare` 4 == LT
23:07:27 <lambdabot>  True
23:07:32 <`Guest00000> i'm asking whether thing which throws parsing error should include its name or not
23:07:55 <jle`> are you talking about `fail` from Monad?
23:07:58 <trigone> > let f x y c = compare x y == c in f 3 4 LT
23:08:00 <lambdabot>  True
23:08:03 <haskeller> MarcelineVQ: Thanks! this works: concat <$> mapM (deriveJSON defaultOptions{sumEncoding=TwoElemArray})
23:08:10 <`Guest00000> like: getAppleWithGivenType BadAppleType = fail "bad apple type"
23:08:11 <jle`> `Guest00000: because 'fail' doesn't have access to the name of the function that calls it
23:08:27 <jle`> oh, you're talking about *calling* fail
23:08:29 <trigone> marvin2: shame... thanks anyway
23:08:35 <jle`> i thought you were asking about implementing it
23:09:09 <jle`> in that case, it depends on who is consuming the error message, probably
23:09:13 <trigone> where can i find the list of symbols authorized in operators?
23:09:22 <jle`> trigone: the Report
23:09:32 <jle`> `Guest00000: it depends on who is using the error messages
23:09:44 <trigone> jle`: is it readable? i don't read well the Standardism
23:09:45 <jle`> `Guest00000: for example, for a parsing library, the end-user of the applications might be dealing with the errors
23:09:53 <jle`> trigone: the haskell report is actually very readable
23:10:01 <jle`> besides, how unreadable could a list of symbols be ...
23:10:05 <trigone> jle`: ok, i'll try finding it...
23:10:51 <trigone> jle`: well sometimes there are several levels of indirections, with variables defined with other variables, etc (and more often than not horrible font)...
23:10:59 <trigone> it can be a small maze, rather than a mere list
23:11:07 <trigone> (without variables)
23:13:21 <jle`> i suppose the list of symbols in the report could b emore straightforward
23:13:54 <jle`> `Guest00000: if i'm using an application that i don't know is Haskell, i probably wouldn't care about the function that calls the error
23:14:12 <jle`> and i probably wouldn't be leaking that detail either if i were writing an application
23:14:18 <trigone> jle`: nah found it, it's not too bad (took me two minutes to get it but it still could be worse)
23:14:57 <butterthebuddha> jle`: that look good? https://pastebin.com/jaxF4FeS
23:15:11 <jle`> butterthebuddha: nice :)
23:15:21 <butterthebuddha> And then just call buildLine over and over until everything is 0
23:15:28 <`Guest00000> now i'm in embarassing situation
23:15:29 <jle`> <= 0, but yeah
23:16:09 <jle`> butterthebuddha: by the way
23:16:13 <jle`> listToLine is just a map, too
23:16:14 <`Guest00000> i have   newtype Apple = Apple { getApple :: Word8 } deriving blahblahblah
23:16:37 <jle`> butterthebuddha: listToLine = map (\x -> if <1 then ' ' else '*')
23:16:39 <`Guest00000> and now i need to parse it with Data.Binary.Get, ie have thing :: Get Apple
23:16:53 <butterthebuddha> jle`: what about the new line?
23:16:54 <jle`> *if x < 1
23:17:00 <`Guest00000> but by convention, it should be called getApple!
23:17:01 <jle`> butterthebuddha: you can just ++ "\n" at the end
23:17:05 <`Guest00000> it's a convention clash!!!
23:17:11 <butterthebuddha> Wouldn't that be more inefficient?
23:17:32 <jle`> benchmark it
23:17:38 <`Guest00000> solution one: move them to different modules
23:18:00 <butterthebuddha> Well i mean I don't expect the difference to be non-trivial given the list sizes I'm working with
23:18:13 <jle`> :D
23:18:15 <butterthebuddha> But I just like to stay away from the ++ operator
23:18:17 <jle`> (you got my point)
23:18:24 <`Guest00000> solution two: deviate from a convention, which isn't a solution
23:18:44 <jle`> butterthebuddha: honestly you're sacrificing a *lot* of readability
23:18:48 <jle`> for a tiny performance gain
23:19:39 <jle`> butterthebuddha: if you want, you can build up [String] instead of String
23:19:50 <jle`> and then use unlines at the end
23:20:05 <`Guest00000> jle`: "i probably wouldn't be leaking that detail" why?
23:20:07 <jle`> that'll associate the ++'s the correct way to make it just as efficient as what you have now
23:20:32 <jle`> `Guest00000: well if i'm writing an application i want to be graceful with how i present my errors
23:21:01 <jle`> butterthebuddha: but really, especially when learning haskell, the important thing is learning readability and the idioms
23:21:07 <jle`> not avoiding (++)
23:21:17 <jle`> for an imperceptible performance gain
23:21:23 <butterthebuddha> I just did that https://pastebin.com/sdZ6qC8c
23:21:28 <`Guest00000> i don't think messages for `error` are impossible to untie from error messages in your program
23:21:44 <jle`> they aren't
23:21:50 <jle`> but sometimes types use 'fail' for user consumption
23:22:09 <`Guest00000> well, just rewrite the message?
23:22:12 <jle`> where fail /= error
23:22:18 <marvin2> butterthebuddha that doesn't look like it'll compile
23:22:33 <jle`> `Guest00000: the problem with fail is that it doesn't take structured input
23:22:36 <`Guest00000> heh
23:22:38 <marvin2> nevermind, you are mapping Int to Char
23:22:45 <`Guest00000> i imagined html fed to fail/error
23:23:01 <jle`> you want to give fail something that you can use later
23:23:31 <`Guest00000> well, let's rewrite fail API
23:23:43 <`Guest00000> i think it's good
23:23:45 <`Guest00000> e.g.
23:23:59 <`Guest00000> make a newtype ErrorMessage = ErrorMessage String
23:24:01 <geekosaur> the problem with changing fail's api is the compiler knows about it
23:24:12 <`Guest00000> and a typeclass for monads defining which types they can take for fail
23:24:15 <jle`> each type should probably define its own sensible failure function
23:24:18 <geekosaur> (fail exists specifically for pattern match failures in do expressions)
23:25:01 <`Guest00000> geekosaur: good, can even do a second newtype PatternMatchFail = PatternMatchFail String
23:25:53 <`Guest00000> has something like this been proposed already?
23:26:11 <jle`> in the end you probably don't gain that much by uniting all fails into a typeclass
23:26:29 <jle`> if the goal is to give them all custom api's/arguments
23:26:35 <butterthebuddha> How do I actually call the function over and over again?
23:26:36 <MarcelineVQ> if you did though you could call it something like, MonadFail
23:26:47 <jle`> it would make more sense for each type to define its own custom function
23:26:56 <jle`> butterthebuddha: have you been exposed to recursion yet? :)
23:27:22 <butterthebuddha> Could I do somehting like take the maximum num from the list
23:27:25 <butterthebuddha> and recurse until that's 0
23:27:39 <jle`> mhm
23:27:42 <jle`> well
23:27:44 <jle`> why are you asking me
23:27:53 <jle`> you can just try it :)
23:28:53 * hackagebot pdfname 0.3 – Name a PDF file using information from the pdfinfo command – https://hackage.haskell.org/package/pdfname
23:31:18 <butterthebuddha> How about this? https://pastebin.com/Uz4p1a5y
23:31:52 <jle`> i'd use pattern matching instead of fst/snd
23:32:13 <butterthebuddha> Of course, forgot about that
23:33:15 <butterthebuddha> But does the rest look fine?
23:33:25 <`Guest00000> but what do i do with the convention clash?!
23:34:50 <jle`> butterthebuddha: can't tell from just this snippet, but it looks like it should be ok to me
23:39:20 <butterthebuddha> Yep, that works
23:39:24 <butterthebuddha> Wow, thanks for all the help!
23:39:42 <jle`> no problem!
23:40:25 <butterthebuddha> http://lpaste.net/357299
23:40:28 <butterthebuddha> That's my final solution
23:43:17 <butterthebuddha> Oh no! the histograms are inverted: https://imgur.com/a/sfYXU
23:44:19 <jle`> try flipping the ++ in buildString
23:45:03 <jle`> but yeah this is getting to the point where even i feel uncomfortable recommending ++
23:45:22 <jle`> since you're calling it recursively and it's being associated the wrong way
23:45:39 <butterthebuddha> Ah, that fixed it
23:46:00 <marvin2> butterthebuddha, i just glanced at your code and didn't run it, but maybe you could simplify some of your code with:
23:46:03 <marvin2> > map (flip replicate '*') [0..5]
23:46:05 <lambdabot>  ["","*","**","***","****","*****"]
23:46:07 <jle`> i'd recommend making buildString return [String], and backwards (as in (s : buildString i (n - 1)))
23:46:15 <jle`> and then reversing and using unlines at the end
23:48:00 <jle`> (see my annotation)
23:48:17 <jle`> this one should be O(n) and not O(n^2)
23:48:54 <mbrock> I wonder how to get good profiling info when my problem is not space leaks but many small allocations and gen-0 GCs
23:49:38 <trigone> are there libraries out there encoding in the types limitations to typical types like Int or List, so that respectively, for example, the former only be in [0..], and the latter not be [], etc?
23:49:42 <mbrock> hmm I guess the normal kind of .prof output should be good since it also lists allocations
23:50:23 <jle`> trigone: there's the "refined" library, that doesn't actually structurally restrict values, but rather requires you to use smart constructors
23:50:26 <butterthebuddha> Argh honestly I don't care anymore
23:50:30 <butterthebuddha> this problem took forever to solve
23:50:43 <MarcelineVQ> trigone: Liquid Haskell can express preconditions on types like that, that sort of thing can also be called Refinement Types
23:50:54 <trigone> jle`: yes that's what i imagined. i'll check it out, thanks :)
23:51:04 <jle`> trigone: but when possible it's best to encode these structurally
23:51:05 <trigone> MarcelineVQ: what's liquid haskell wrt haskell?
23:51:06 <cocreature> trigone: for your specific examples there is NonEmpty and Natural/Word
23:51:17 <jle`> trigone: for example, NonEmpty in base is a non-empty list
23:51:34 <trigone> jle`: does it not imply Dependent types or something?
23:51:38 <jle`> no
23:51:46 <jle`> see NonEmpty
23:51:51 <MarcelineVQ> trigone: I thiiinnk, it's haskell with extra syntax to call an smt solver to prove properties about types before you use them, but I'm not quite sure as I havent' used it
23:51:51 <jle`> data NonEmpty a = a :| [a]
23:52:05 <jle`> it's a type that structurally enforces that it's a list with at least one item
23:52:28 <trigone> MarcelineVQ: ok :) well that sounds overkill, i don't want to jump into a whole new sublanguage just now
23:52:30 <jle`> it's literally impossible (aside from bottom shenanigans) to create a NonEmpty with 0 items
23:52:46 <trigone> MarcelineVQ: but thanks for the idea, i'll still check it out sometime
23:53:06 <trigone> jle`: what's the ":|" thingy?
23:53:10 <jle`> it's a constructor
23:53:23 <jle`> like data Maybe a = Nothing | Just a
23:53:27 <jle`> Nothing and Just are data constructors
23:53:28 <jle`> for the type Maybe
23:53:36 <jle`> :| is just an operator constructor
23:53:40 <trigone> ok... so how do you use that constructor twice?
23:53:49 <jle`> use it twice?
23:53:51 <jle`> just type it twice :)
23:54:05 <jle`> haskell doesn't limit how many times you can use things by default
23:54:10 <jle`> it's sort of a post-scarcity economy
23:54:21 <jle`> soon we'll have linear types though
23:54:28 <trigone> say i have (3 :| [3,4]). how do i get (5 :| [3,3,4]) from it?
23:54:54 <trigone> jle`: what's linear types? they allow limiting input types to specific values?
23:55:03 <cocreature> 5 <| (3 :| [3,4])
23:55:05 <cocreature> > 5 <| (3 :| [3,4])
23:55:07 <lambdabot>  error:
23:55:07 <lambdabot>      • Data constructor not in scope: (:|) :: Integer -> [Integer] -> s
23:55:07 <lambdabot>      • Perhaps you meant one of these:
23:55:11 <jle`> linear types is restricting how many times you can use a value
23:55:16 <cocreature> @let import Data.List.NonEmpty
23:55:17 <lambdabot>  .L.hs:159:16: error:
23:55:17 <lambdabot>      Ambiguous occurrence ‘last’
23:55:17 <lambdabot>      It could refer to either ‘Data.List.last’,
23:55:17 <cocreature> > 5 <| (3 :| [3,4])
23:55:19 <lambdabot>  error:
23:55:20 <lambdabot>      • Data constructor not in scope: (:|) :: Integer -> [Integer] -> s
23:55:20 <lambdabot>      • Perhaps you meant one of these:
23:55:22 <cocreature> welp I give up
23:55:24 <mbrock> whoa, the heap profiling thing says that the slow version of my program has a huge amount of values of type *
23:55:29 <trigone> well that's terribly verbose... :/
23:55:32 <Myrl-saki> trigone: No.
23:55:43 <cocreature> trigone: how is <| more verbose than :?
23:55:45 <Myrl-saki> trigone: Linear types allow "use exactly once variables"
23:55:57 <trigone> cocreature: about 200% actually :P
23:55:57 <cocreature> well I guess it’s one more character but it really doesn’t seem like a big deal
23:56:10 <jle`> trigone: well, that's a part of the problem with restricted types
23:56:18 <Myrl-saki> trigone: Which turns out to be very useful in resource management.
23:56:21 <jle`> you give up some expressiveness
23:56:29 <jle`> for example, check out the type of (:|)
23:56:32 <jle`> :t (:|)
23:56:32 <Myrl-saki> Ino thers news...
23:56:33 <lambdabot> error:
23:56:33 <lambdabot>     • Data constructor not in scope: :|
23:56:33 <lambdabot>     • Perhaps you meant one of these:
23:56:38 <Myrl-saki> This is 3 fucking MB. http://hackage.haskell.org/package/base-4.10.0.0/docs/Prelude.html#v:fromIntegral
23:56:51 <trigone> Myrl-saki: is it a bit like unique types?
23:56:52 <jle`> (:|) :: a -> [a] -> NonEmpty a
23:57:07 <jle`> trigone: but, it looks like you wanted an a  -> NonEmpty a -> NonEmpty a
23:57:07 <mbrock> mysterious heap profiling plot with mystery * thing: https://i.imgur.com/OoaaX3l.png
23:57:09 <Myrl-saki> trigone: They're very similar.
23:57:11 <trigone> the fact you can't use [x, y,z] syntax is a bummer
23:57:12 <jle`> trigone: notice how those two have different types?
23:57:29 <trigone> jle`: which two?
23:57:36 <jle`> (:|) :: a -> [a] -> NonEmpty a
23:57:42 <jle`> but you were looking for some function a -> NonEmpty a -> NonEmpty a
23:57:57 <jle`> those two have different types, necessarily
23:58:07 <trigone> jle`: yeah i had gathered that, that's why my question was sort of rhetorical
23:58:25 <jle`> yeah, this is sort of drawbrack of descriptive types, in a way
23:58:27 <Myrl-saki> Wait, where is SNat declared?
23:58:32 <cocreature> mbrock: * means that it is an unknown type
23:58:33 <jle`> in Data.Singletons.TypeLits
23:58:33 * ongy wonders if DH will at some point make NonEmpty obsolete
23:58:38 <Myrl-saki> jle`: THanks.
23:58:46 <trigone> what's SNat?
23:58:56 <jle`> it's a data constructor
23:59:00 <jle`> for a type
23:59:01 <trigone> nvm i remember (i think)
23:59:19 <trigone> ongy: what's DH?
23:59:28 <jle`> trigone: but yeah, you can't use the same function for a -> [a] -> NonEmpty a and also a -> NonEmpty a -> NonEmpty a
23:59:29 <mbrock> cocreature: oh... my slowness-inducing refactoring uses associated data types, maybe it doesn't understand how to name those...
23:59:42 <Myrl-saki> jle`: Is there any Peano TypeLit?
23:59:47 <ongy> https://ghc.haskell.org/trac/ghc/wiki/DependentHaskell dependant haskell. But I don't think it's in a foreseeable future
23:59:49 <jle`> trigone: if you already have a list, you can just use `nonEmpty`
23:59:57 <jle`> Myrl-saki: not TypeLit
