00:03:07 <merijn> Any pointers w.r.t. dynamically linking (by that I mean, dlopen at runtime, not just linking .so's) Haskell libraries?
00:03:23 <merijn> I used to have a link to dons' thesis on that kinda stuff, but it appears to have bitrotted?
00:04:02 <Squarism> That scala promo is too wierd
00:04:09 <cocreature> merijn: the plugins package is maintained reasonably well although nobody seems to use it
00:04:19 <dibblego> Axman6 ❤ scala
00:04:37 <cuddly[m]> Squarism: thats a perfectly normal advertisement
00:04:58 <wwizzy> i have 15 years experience in scala
00:05:21 <merijn> cocreature: Well, I know Simon Marlow (and thus presumably some facebook peeps) are using dynamic linking, since he committed some stuff to dynamically unload libraries in, like, ghc 7.10
00:05:33 <merijn> cocreature: But I think this is dark arts in terms of documentation level :p
00:05:37 <cocreature> merijn: good point
00:06:00 <Axman6> yeah I wish more of the FB dynamic code loading stuff were available, it woulds really useful
00:06:09 <cocreature> merijn: I wrote a blogpost at some point on how to dynamically load Haskell object files but I haven’t tried loading whole libraries
00:06:41 <merijn> Sadly, googling for haskell and dynamic linking just turns up a bunch of stuff on linking your libraries dynamically, but that's not quite the dynamic I had in mind :p
00:07:10 <EvanR> merijn: keywords dynamic loading
00:07:14 <LiaoTao> merijn, Are you sure you mean linking and not 'loading'?
00:07:35 <cuddly[m]> http://code.haskell.org/~dons/papers/thesis/dons-phd-thesis.pdf
00:07:37 <cuddly[m]> this?
00:08:52 <merijn> cuddly[m]: Maybe, I'm not sure whether it was his thesis or just a paper, I'll have a look
00:08:55 <cocreature> iirc the plugins package is based on dons thesis
00:09:03 <cocreature> but updated for modern GHCs
00:09:22 <Axman6> glguy: are you using anything like plugins in glirc?
00:09:55 <cocreature> iirc glirc only loads C libs (or anything that pretends to be one)
00:10:29 <Axman6> I believe there's some lua stuff, but haven't looked into it too much
00:13:08 <ongy> there's a glirc-lua.c, so going over the C loader probably
00:24:10 <merijn> bollu: You have to become less productive with this simplexhc thing before I start feeling bad about my productivity levels... :p
00:56:00 <Axman6> merijn: link to progress? :o
00:56:48 <merijn> Axman6: There was an update post on /r/haskell
01:03:13 <ertes-w> helo
01:04:32 <wwizzy> hi
01:12:41 --- mode: ChanServ set +o dibblego
01:12:55 --- mode: dibblego set -q hackagebot!*@*
01:13:02 --- mode: dibblego set -o dibblego
01:13:44 <Athas> Does anyone know which format was used to write the book 'Parallel and Concurrent Programming in Haskell'?  I really like that it has both a nice web version and a printed version.
01:13:49 <Athas> I guess the same goes for Real World Haskell.
01:16:38 <kadoban> Athas: From a quick view of the HTML "source", I'm thinking asciidoc
01:17:15 <merijn> Writing books in something other than LaTeX, REEEEEEEEE :p
01:17:48 <kadoban> ;)
01:18:09 <wwizzy> it's pronounced la-tec
01:18:38 <EvanR> lay tech
01:18:45 <wwizzy> gets you laid
01:19:04 <EvanR> is that why its so popular
01:19:12 <wwizzy> out so you can see where your formatting is wrong
01:19:23 <EvanR> lol
01:19:37 <merijn> Although you should probably be using XeTeX or XeLaTeX instead
01:19:53 <kadoban> I can never manage to remember that it's supposed to be pronounced like that.
01:20:06 <EvanR> chet tech
01:20:53 <EvanR> ĥetech
01:22:40 <Athas> kadoban: hm!  I never thought that Asciidoc would be good enough for that.
01:24:20 <kadoban> I can't remember if I've ever looked at asciidoc before. But maybe I should now, that output is quite nice.
01:24:35 <merijn> hmmm, I really wish someone would come up with, like, a universal interface for different streaming libraries so that when I want APIs that easily accomodate streaming I don't have to tie myself to a specific streaming library or make the user do all the wrapping...
01:25:10 <systemfault> Wasn't that the goal of gstreamer or something
01:25:23 <systemfault> Ahh, oops, unrelated to sound.
01:25:34 <wwizzy> i wish somebody would hurry up and make the last programming language
01:25:53 * EvanR volunteers wwizzy 
01:25:58 <systemfault> That would suck...
01:26:20 <EvanR> languages only get worse, so the last one must be *really* bad
01:26:35 <systemfault> A return to BCPL
01:26:35 <wwizzy> i would suggest a whitespace-only language
01:26:49 <wwizzy> it would be called spacesAndTabs#
01:27:02 <Sh4rPEYE> I'm working on this kata: https://www.codewars.com/kata/the-most-imperative-functional-language . Is there any way I can define the Variable Monad without knowing anything about IORefs and similar advanced topics? I tried with State, but failed.
01:27:10 <Athas> BCPL is too new-fangled.
01:27:13 <cocreature> a whitespace only programming language will drive all programmers into suicide so it might actually be the last one
01:27:14 <kadoban> wwizzy: Been done ... a few times I think. The popular one's name is a bit more ... punchy though.
01:27:20 <Sh4rPEYE> wwizzy: It does exist actually.
01:27:22 <Athas> Both APL and ALGOL-60 would be improvements over most of its successors.
01:27:39 <kadoban> Oh wait no I was thinking of a different esolang for the name, ignore the name part.
01:27:39 <Sh4rPEYE> https://en.wikipedia.org/wiki/Whitespace_(programming_language)
01:27:40 <merijn> Athas: My keyboard isn't big enough for APL :\
01:27:48 <merijn> cocreature: That already exists
01:27:50 <wwizzy> cocreature: are you saying the job market would be awesome? just think of all the turnover
01:27:56 <merijn> cocreature: "Whitespace, the language for spies"
01:27:59 <merijn> cocreature: Like...for years
01:28:08 <Athas> merijn: is your wallet big enough to buy a K license?  It uses only ASCII.
01:28:09 <merijn> cocreature: https://esolangs.org/wiki/Whitespace
01:28:21 <cocreature> merijn: I know it exists :)
01:28:22 <merijn> Athas: So does J and that's free :p
01:28:34 <wwizzy> spacesAndTabs# is unicode-only
01:28:50 <wwizzy> it is derived from Whitespace
01:29:03 <wwizzy> but has features beyond spaces, tabs, and linefeeds
01:29:19 <EvanR> Sh4rPEYE: you just need to write newIORef instead of var
01:29:31 <EvanR> and import Data.IORef
01:29:32 <merijn> Sh4rPEYE: What makes you say IORefs are advanced?
01:29:35 <quchen> Fun fact, the father of Whitespace is also the father of Idris.
01:29:49 <EvanR> that cant be true
01:29:58 <wwizzy> who is the mother
01:29:58 <kadoban> quchen: Wait, really?
01:30:01 <Sh4rPEYE> merijn: For me. Just finished the HAskell Book. Don't know nothing about them, just heard the name somewhere
01:30:11 <quchen> :-)
01:30:15 <merijn> kadoban: The esolang wiki says it's Edwin Brady, so yes
01:30:26 <EvanR> so thats what he was referring to...
01:30:29 <kadoban> Wow, that's kind of hilarious trivia.
01:30:31 <quchen> bollu: Hooray for prettyprinter adoption :-)
01:30:40 <merijn> Sh4rPEYE: Although it seems you're right, the question seems to heavily imply State as answer
01:30:40 <EvanR> i figured it was yet another whitespace 
01:31:05 <quchen> merijn: Edwin Brady says it’s Edwin Brady. Source: Edwin Brady
01:31:24 <systemfault> Edwin Brady rocks but is also a madman
01:31:40 <quchen> systemfault: You’d think Whitespace was his craziest invention
01:31:43 <EvanR> Sh4rPEYE: true... and the fact that all the vars are Integer valued makes it pretty easy
01:31:44 <systemfault> Created Whitespace... and took the time to write a Idris to PHP compiler.
01:31:51 <quchen> Exactly.
01:32:06 <merijn> Sh4rPEYE: As for IORef being advanded, they're literally just the kinda mutable variables you're familiar with from other languages. Except you have to allocate them explicitly and you can only read/write them from within IO
01:32:25 <EvanR> and they survive a function scope :)
01:32:36 <merijn> Sh4rPEYE: Pretty sure 5s on the documentation page would be enough to figure them out :)
01:33:30 <merijn> quchen: Any success convincing the optparse-applicative maintainer to adopt prettyprinter? :) Or should I go complain on the github issues to do that :p
01:33:48 <Sh4rPEYE> merijn: I'll look them up, thanks. When you say the question implies State, does it mean I could solve it just using State?
01:34:14 <bollu> how do I "assert" my assumptions in haskell?
01:34:14 <quchen> merijn: I haven’t talked to him about this yes. But I *do* have a converter from ansi-wl-pprint lying around!
01:34:19 <merijn> Sh4rPEYE: The example type signatures I see on the page looks like they expect a State solution
01:34:21 <quchen> bollu: Use »assert«
01:34:35 <bollu> quchen when does it get evaluated? when the thunk is forced?
01:34:52 <quchen> bollu: I think so. See the GHC manual
01:35:02 <quchen> bollu: The nice thing about asserts is that they’re erased with -O
01:35:08 <bollu> quchen ah, I see.
01:35:15 <quchen> merijn: I recently changed ansi-wl-pprint to expose its privates; when that’s published on Hackage I can release the converter
01:35:22 <bollu> quchen I was just bitten by a bug that an assert would have caught
01:35:35 <EvanR> :t assert
01:35:36 <lambdabot> Bool -> a -> a
01:35:38 <bollu> also, how do I set a compiler path for cabal?
01:35:46 <quchen> merijn: It’s not a compatibility drop-in, it’s a proper »Ansi.Doc -> Prettyprinter.Doc AnsiTerminal« function
01:35:46 <Sh4rPEYE> merijn: That'd be better for me, as I should know how to work with State by now.
01:35:47 <bollu> I want to use my home-build ghc-stage1
01:35:50 <bollu> is that possible?
01:35:50 <EvanR> let x = assert False 3 in 4
01:35:51 <merijn> bollu: Cabal just picks whichever is first on your path
01:35:54 <EvanR> > let x = assert False 3 in 4
01:35:56 <lambdabot>  4
01:36:02 <EvanR> > let x = assert False 3 in x `seq` 4
01:36:02 <merijn> bollu: So I just change my $PATH variable when I have to
01:36:02 <bollu> merijn ah, I see.
01:36:03 <cocreature> bollu: -w path/to/your/ghc
01:36:04 <lambdabot>  *Exception: Assertion failed
01:36:04 <lambdabot>  CallStack (from HasCallStack):
01:36:04 <lambdabot>    assert, called at <interactive>:3:9 in interactive:Ghci1
01:36:11 <bollu> cocreature hm? what's -w do?
01:36:26 <merijn> bollu: And since GHC has a per-version package DB it "just works"
01:36:37 <cocreature> bollu: exactly what you want. it sets the path to the compiler
01:36:46 <bollu> I see
01:36:54 <bollu> merijn but I'm on stage1, and my package DB is broken
01:37:03 <quchen> merijn: The nice thing about conversion functions is that I can convince authors switching isn’t a dead end of compatibility agony, hopefully.
01:37:04 <bollu> can I still use the stage1 compiler to compile programs with dependencies?
01:37:07 <merijn> bollu: Ah... :)
01:37:17 <merijn> quchen: \o/
01:37:23 <bollu> merijn my stage1 can't compile stage2 (broken package DB)
01:37:24 <quchen> And users can convert whatever they want regardless of which pretty flavor the package author prettyprints to.
01:37:41 <merijn> bollu: #ghc can probably better help you :)
01:37:43 <quchen> merijn: I just haven’t poked Edward to make a new release enough.
01:37:50 <quchen> Maybe hvr is also a maintainer? Hmm
01:38:00 <quchen> Well, I’m not one, so I can’t release it on Hackage.
01:38:08 <merijn> bollu: They know all the stuff about stage1/stage2 and broken compilers :)
01:38:24 <merijn> bollu: plus, smaller chance your question gets lost in the noise
01:40:17 <quchen> bollu merijn: And many GHC maintainers are not even in here, just in #ghc
01:43:32 <merijn> bleh, neither pipes nor conduit seems to have a convenient function for turning "Monad m => m (Maybe a)" into a Pipe/Conduit that produces a's...
01:45:03 <wwizzy> does chipotle sell monads?
01:47:05 <bollu> merijn xD
01:55:34 <ertes-w> merijn: sequence >=> traverse_ yield
01:56:47 <ertes-w> :t \f -> sequenceA >=> traverse_ f :: (Applicative f) => (a -> m b) -> f (Maybe a) -> f ()
01:56:49 <lambdabot> error:
01:56:49 <lambdabot>     • Couldn't match type ‘()’ with ‘f1 ()’
01:56:49 <lambdabot>       Expected type: (a1 -> m1 b1) -> f1 (Maybe a1) -> f1 ()
01:56:56 <ertes-w> :t (\f -> sequenceA >=> traverse_ f) :: (Applicative f) => (a -> m b) -> f (Maybe a) -> f ()
01:56:57 <lambdabot> error:
01:56:57 <lambdabot>     • Couldn't match kind ‘k1’ with ‘*’
01:56:57 <lambdabot>       ‘k1’ is a rigid type variable bound by
01:57:30 <ertes-w> :t (\f -> sequenceA >=> traverse_ f) :: (Applicative f) => (a -> f b) -> f (Maybe a) -> f ()
01:57:32 <lambdabot> error:
01:57:32 <lambdabot>     • Couldn't match type ‘f1’ with ‘Maybe’
01:57:32 <lambdabot>       ‘f1’ is a rigid type variable bound by
01:58:40 <ertes-w> ah, i'm stupid
01:59:20 <ertes-w> :t (\f -> (>>= traverse_ f)) :: (Monad m) => (a -> m b) -> m (Maybe a) -> m ()
01:59:22 <lambdabot> Monad m => (a -> m b) -> m (Maybe a) -> m ()
01:59:29 <ertes-w> merijn: ^
02:00:24 <merijn> ertes-w: Well, I figured I could also rewrite the API to "MonadIO m => (b -> m ()) -> m ()" and get the same effect
02:00:46 <merijn> ertes-w: Then I just handle the Maybe case internally and you just write "foo yield" to make it a Pipe/Conduit
02:01:09 <ertes-w> yeah
02:02:04 <merijn> And I can actually use the same API as both input and output, so that's nice too :)
02:02:23 <ertes-w> although that should be equivalent to just writing a producer =)
02:02:29 <merijn> For added bonus, time to figure out if there's a way to abstract composition of pipes/conduit too
02:02:31 <EvanR> what are my options for sending "values" from one haskell process to another
02:02:40 <merijn> ertes-w: Well, I am using a producer
02:02:51 <merijn> EvanR: How performance crucial?
02:03:15 <merijn> EvanR: I've mostly just been using binary to serialise stuff and sending it over sockets
02:03:16 <ertes-w> EvanR: depending on your requirements: aeson, binary, cereal, Read/Show, yaml, …
02:03:17 <EvanR> if i say low, will i get something really cool in return
02:03:34 <merijn> EvanR: 
02:03:46 <ertes-w> EvanR: i'd use aeson by default…  it's fast enough and easy to debug
02:03:47 <quchen> EvanR: Show/Read :>
02:03:51 <merijn> ertes-w: I think cereal is mostly obsolete?
02:03:54 <merijn> ertes-w: ugh
02:03:58 <ertes-w> merijn: is it?
02:04:00 <EvanR> i heard show read is actually pretty fast... 
02:04:20 <merijn> ertes-w: Well, the main thing cereal had going for it was dealing with strict ByteString, but binary got a strict incremental API years ago
02:04:20 <EvanR> aeson???
02:04:41 <merijn> ertes-w: for parsing, as for output, it's pretty simple to convert a strict bytestring to lazy for outputting
02:04:57 <ertes-w> EvanR: 'show' is fast, if you can send the string right away (i.e. if you never construct the list in memory)
02:05:06 <merijn> ertes-w: So, I'm not really sure what cereal's niche is nowadays. There were vague ideas of merging the two, but that never happened
02:05:36 <EvanR> do we not have some kind of magic technology...
02:05:37 <ertes-w> EvanR: 'read' is fast, if you read the string into a Text/ByteString and give it the lazy decoding string as argument
02:05:39 <merijn> EvanR: I wouldn't use aeson, mostly because I think this whole "everything is JSON" thing is nonsense :)
02:05:47 <EvanR> me too
02:05:57 <merijn> EvanR: Well, binary is pretty magic. You can derive the serialisation if you have a Generic instance
02:06:22 <ertes-w> merijn: i see…  might as well switch to 'binary' then, but i tend to avoid binary serialisation =)
02:06:35 <merijn> EvanR: So it's literally "encode -> write to socket" and "read from socket -> decode", you can use the pipes/conduit wrappers for binary to turn it into a nice streaming-parsing thing going
02:06:42 <EvanR> what about passing compact heap blobs through shared memory!
02:06:56 <ertes-w> merijn: i agree about the JSON thing, but the only real alternative is Read/Show, which i personally consider more to be debugging tools =)
02:07:06 <merijn> EvanR: The other fancy alternative is -XStaticPointers
02:07:14 <EvanR> StaticPointers eh
02:07:40 <merijn> EvanR: That requires the same binary (or at least same library providing the static pointer) linked into both binaries, though
02:07:58 <ertes-w> merijn: BTW, is the output of 'binary' actually compiler/platform-agnostic?
02:08:04 <merijn> EvanR: So if your compact region is statically known then you could send it supercheap
02:08:18 <merijn> ertes-w: Yes, but not binary-version agnostic
02:08:27 <EvanR> hrm
02:08:49 <merijn> ertes-w: And that applies only to the auto-generated instance of Binary, you can write Put/Get by hand and then it's as platform agnostic as the Put/Get you write
02:09:23 <merijn> ertes-w: You wanna use hand-written Put/Get for custom/stable formats anyway, since binary inserts some internal sanity checks too
02:10:01 <ertes-w> perhaps we should think of a text format that more closely matches haskell's "there is more to the universe than lists and maps" view, and then implement that one =)
02:10:24 <ertes-w> the only reason i use JSON is that it's both easy to generate/parse and easy (enough) to read/write by humans
02:10:31 <merijn> ertes-w: but since we we're talking "easy communication", if you can get away with assuming the same version in both processes then deriving Binary saves you a lot of time
02:11:31 * hackagebot test-framework-sandbox 0.1.1 – test-sandbox support for the test-framework package – https://hackage.haskell.org/package/test-framework-sandbox
02:11:35 <EvanR> i am assuming two different programs that happens to be written in haskell
02:12:09 <EvanR> yes i agree, we need the "json-of-haskell"
02:12:16 <EvanR> which would look like ??????
02:12:24 <merijn> EvanR: Well, if you want to communicate a datatype X then both versions need to have the same library defining X, no?
02:12:33 <EvanR> does it?
02:13:20 <merijn> EvanR: If you do it sanely, yes. Else you end up defining effectively your own serialisation format
02:13:48 <merijn> EvanR: How can 2 programs have a datatype X that's the same without coming from the same definition? How would you know both X's are actually the same?
02:13:48 <EvanR> maybe there could be a generic "untyped lambda calculus term with data constructors, case analysis, explicit recursion" 
02:14:04 <EvanR> and some sort of type system on top of that
02:14:28 <EvanR> which would be optional or not egregiously intrusive
02:15:18 <EvanR> i could sent the number 3, or the infinite number loop
02:15:26 <EvanR> and it would "just work"
02:15:30 <merijn> EvanR: Tekmo is working on that
02:15:37 <merijn> EvanR: Google Morte
02:15:41 <EvanR> HMMMM
02:15:46 <merijn> @google tekmo morte
02:15:47 <lambdabot> https://www.reddit.com/r/haskell/comments/2g6wsx/haskell_for_all_morte_an_intermediate_language/
02:19:27 <EvanR> wait
02:19:47 <EvanR> tekmo = gabriel gonzales?
02:19:54 <merijn> EvanR: Yes
02:20:25 <EvanR> brain explode
02:21:53 <quchen> Gonzale*z*
02:22:12 <EvanR> ah
02:24:27 <EvanR> ok thats great...... if it werent already outlandish, lets go further and define a stateful protocol to allow the parties to not only send arbitrary well typed "values" but also say "heres what i mean by foo" and then future communication is more efficient
02:24:44 <EvanR> now who has solved that one ?
02:24:52 <merijn> EvanR: Oleg, probably :p
02:25:38 <EvanR> limitation to one (almost certainly crappy) format seems stone age!
02:26:35 * quchen is hoping for CBOR to land soon
02:27:30 <EvanR> heard about it, what does CBOR bring to the table?
02:33:37 <merijn> CBOR as in for binary?
02:35:16 <merijn> ooh, completely unrelatedly, github apparently has fancy license visualisation now
02:36:04 <cocreature> merijn: cbor as in https://github.com/well-typed/binary-serialise-cbor
02:36:45 <merijn> Yeah, that looks good
02:37:47 <fred-fri> how can i avoid passing arguments into function a when the arguments are not actually used in function a but only used by another function b that is called by a only when some other computation inside a has been successful
02:40:28 <dibblego> reader and its functor/applicative/monad instance
02:41:17 <EvanR> or implicit parameters ! >:)
02:41:21 <dibblego> ew
02:41:31 <EvanR> hawhawhaw
02:41:37 <fred-fri> don't tell anyway but it's actually a legacy java codebase i'm working on
02:42:03 <fred-fri> but i never get good answers in the java channel so asking here instead because i want to model it functionally
02:42:40 <dibblego> http://www.functionaljava.org/javadoc/4.7/functionaljava/fj/F1Functions.html#bind-fj.F-
02:43:59 <srhb> I agree that #haskell is better for almost any question, but I think #haskell would be a very bad place if everyone used it like that. :P
02:44:15 <merijn> Does anyone know if it's possible to have Haddock output the docs for re-exported module inline, rather than just a link to the original module?
02:44:38 <merijn> I can explicitly enumerate my re-exports, but that's kinda annoying...
02:45:07 <fred-fri> i agree with that, actually im more interested in how this *would* be modelled in haskell because i don't think it can be done in java the same way
02:45:36 <EvanR> anything is possible with enough static methods
02:45:36 <ertes-w> merijn: yeah, and it's the same with aeson =)
02:45:47 <srhb> fred-fri: Reader is definitely the obvious approach.
02:46:03 <ertes-w> although i tend to write the instances by hand
02:46:05 <ventonegro> fred-fri: In Haskell arguments are not evaluated if not needed, so...
02:46:20 <ertes-w> because i rarely agree with what aeson produces
02:46:25 <EvanR> passing "implicit" params in java? no you make a superclass hierarchy!
02:46:42 <ventonegro> fred-fri: You wouldn't "pay" anything by passing the arguments
02:46:46 <EvanR> arguments -> instance variables
02:47:02 <merijn> ertes-w: I mean, binary has all you need for writing portable things. All the types/size are explicit and you can explicitly specify which endiannes to serialise with
02:47:57 <ertes-w> merijn: but it's not text…  having a text format has important usability/debuggability benefits
02:48:11 <ertes-w> unless you're comfortable using a hex editor and counting bytes
02:48:17 <merijn> ertes-w: Sure, but there's lots of time where a binary format is important too :)
02:48:20 <fred-fri> i'm refactoring a login that accepts a httprequest. initially i just check that the httprequest has a username, password an ip. if not, i show an errorpage. otherwise, i call one of two methods depending on the ip. both methods require more arguments out of the request. but i dont like passing htem the request because they only need one or two thin
02:48:21 <fred-fri> gs out of it. but now i have to send those things, which are actually not used by the inital username, password, ip present check function, into that function
02:48:39 <merijn> ertes-w: Especially if you care about efficiency :)
02:48:44 <ertes-w> merijn: perhaps the ideal format would just support both =)
02:48:55 <ertes-w> use text output for debugging, binary output for production
02:48:58 <ertes-w> parser supports both
02:54:34 <cocreature> one of the nice things about cbor is that you can convert it to a pretty readable text representation independent of the specific application
02:56:36 <merijn> gah
02:57:02 <merijn> I can't return RankN functions inside some datatype without running afoul of ImpredicativeTypes? :(
02:59:40 * hackagebot overload 0.1.0.4 – Finite overloading – https://hackage.haskell.org/package/overload
03:01:01 <EvanR> return them inside?
03:01:28 <EvanR> data Thing = InsideThing (forall a . a -> a)
03:36:27 <bitonic> in fact `newtype` is enough -- `newtype Thing = InsideThinkg (forall a. a -> a)`
03:41:30 <bvad> I'm considering using `async` instead of `forkIO` for my "runs forever" workers that communicate through STM queues - does it make sense to use `async` when a result is never returned? I'm mainly interested in the error handling provided by `withAsync` to avoid thread leaks. 
03:42:24 <bvad> I'm mainly asking because it seems "wrong" to never use the result of the Async values 
03:43:15 <osa1> bvad: forkIO doesn't have a bracket function so you'll either have to implement it yourself or use withAsync. I do the latter because bracket functions are sometimes tricky to implement
03:44:52 <bvad> osa1: That's the exact reason I'm looking for something with better resource handlin :) Is it possible to safely combine async and ResourceT? I ran into the "don't fork in ResourceT"-problem earlier 
03:45:24 <cocreature> bvad: even if your process runs forever you want to wait for it to terinate at the end of main and give it a chance to run exception handlers if main dies
03:45:51 <osa1> async also doesn't silently forget exceptions thrown in the thread, you can get them using poll or wait etc.
03:45:57 <cocreature> I often have something like waitAnyCancel at the end of main
03:47:01 <osa1> bvad: I don't know about ResourceT, never used it. if it has MonadBaseControl IO instance then you should be able to use it in async, although that opens a whole new can of worms...
03:48:34 <osa1> I also don't know about the "don't fork in ResourceT" problem
03:50:22 <bvad> osa1: basically, if you fork in runResourceT and the 'main' thread releases the resource, the forked thread will throw an exception trying to access the resource - or at least that's how I percieved the problem :)
03:52:30 <bvad> cocreature: how do you recover from one thread crashing unexpectedly? Restart everything?
03:52:59 <bvad> using "thread" very loosely here of course 
04:00:29 <osa1> I'd be surprised if there isn't a library/function for forking inside ResourceT. in any case I think you could do that with correct "bump ref counter"/"decrease ref counter" functions used with withAsync
04:04:04 <osa1> bvad: it has a MonadBaseControl instance so I think you can safely fork inside ResourceT using lifted-async
04:06:05 <bvad> osa1: I was just looking at that package. It seems to be a drop-in replacement :) Thanks!
04:06:39 <osa1> yup, lifted-async is great. it's really painful to fork inside LoggingT etc. without it
04:07:26 <osa1> there's also lifted-base for lifted versions of timeout, threadDelay, forkIO etc.
04:09:28 * hackagebot system-linux-proc 0.1.0.0 – A library for accessing the /proc filesystem in Linux – https://hackage.haskell.org/package/system-linux-proc
04:16:34 * hackagebot psqueues 0.2.3.0 – Pure priority search queues – https://hackage.haskell.org/package/psqueues
04:39:44 <ertes-w> a monad-control dependency is often a sign that you should check your abstraction meter…  you may be suffering from overengineering =)
05:36:46 <bvad> ertes-w: How would you do things like using `finally` inside an mtl-style stack without monad-control? I'm all for reducing over-engineering!
05:39:57 <ertes-w> bvad: i'd avoid the stack in the first place…  my usage of transformers is very localised these days
05:45:55 <bvad> ertes-w: so if you're using a library based around an mtl stack, you would evaluate the actions to IO immediately? 
05:49:06 <ertes-w> bvad: there is no general answer in that case…  it depends on the situation
05:52:57 <bvad> ertes-w: I'll look into how this could be done. It's an interesting topic for sure
05:54:36 <ertes-w> bvad: also this is not necessarily about avoiding monad-control…  it's more that doing things in IO is simple and predictable
05:55:41 <bvad> ertes-w: Indeed, especially since mtl stacks do make a lot of things implicit 
05:56:21 <bvad> Of course that's not always a bad thing, but it can be a bit cumbersome navigating deep stacks 
05:57:31 <ertes-w> bvad: my personal opinion is that transformers are often overused
05:57:36 <ertes-w> especially in web frameworks
05:59:38 <Younder> I disagree. I think transform from spaces to saces with different properties has been one of the most productive ideas in geometry. I am sure the same will be found true in programming. But.. You need to understand categories first.
05:59:51 <Younder> And topological spaces.
06:02:03 <Younder> I believe that in physics  one of the greater tragedies in our educational system is the skip of proofs for science students. They have sloppy understanding of math. They take things on faith. And when it comes to plow the untrodden field they don't know how.
06:02:13 <bvad> Younder: are the ideas comparable? I have no real knowledge in that area
06:03:35 <Younder> One of the things that hold them back of finding faster ways of doing things is a lack of math and through their education a lack of ability to learn higher math.
06:05:00 <quchen> class (MonadIO io, MonadIrc io) => MonadArmchair io where markov :: io Text
06:05:08 <Younder> bvad, They are but it would a long disussion.
06:05:30 <bvad> Younder: but a very interesting on I'm sure
06:07:51 * hackagebot VKHS 1.9.1 – Provides access to Vkontakte social network via public API – https://hackage.haskell.org/package/VKHS
06:08:30 <Younder> bvad, I'd like to write you a reference, but I can't. My knowlege seems to come from a 100 sources. (Maybe I should write it..)
06:10:20 <Younder> If I were to pick one, it would be Serge lang's book on Algebra. But it required a graduate level understanding of mathematics.
06:11:57 <bollu> Younder surely theoretical physics in good schools is not taught that way?
06:12:17 <bollu> bvad also, if you want a recommendation for algebra, I personally really like Artin's algebra book
06:12:37 <bollu> bvad there's also a video lecture series on undergrad algebra by benedict gross that is very good
06:13:10 <Younder> bollu, It shows up all the time. But then again many theoretical physicist are in fact in applied mathematics.
06:13:31 <Younder> physecists
06:13:44 <bollu> Younder I see
06:13:55 <bollu> Younder I duno, I'm a comp sci student anyway, I just dabble in math
06:16:13 <lambdamu> How did we come from monad-control to algebra references and physicsts allegedly inferior grasp on math?
06:16:32 <Younder> bollu, If you want to learn Machine Learning you will find yourself in a whole different ball game. Statistics. Calculus. Linear algebra. optimization theory... It is just as complicated mathematically as physics
06:17:36 <bollu> Younder I don't much care about ML. I'm reading integer point counting in polyhedra right now, it's quite cool
06:17:50 <lambdamu> A novel idea how to deal with higher order functions and monad transfomer stacks apart from monad control and MonadMask where applicable would be very interesting to me
06:18:42 <lambdamu> forking entire packages to provide lifted versions surely can't be satisfying
06:20:27 <Younder> bollu, For understanding the sometime confusing Haskell lingo, I found 'Introduction to lattices and order' 2 ed. by Davey and Priestly to work for me. (even mathematicians can't understand each-others babble outside their field.)
06:21:00 <Younder> It filled in a few holes.
06:21:32 <Younder> It is suitable for a undergrad with a mathematical aptitude.
06:25:19 <Younder> For a more cohesive work on understanding all mathematics you have the 'Princeton guide to mathematics' and and it's companion volume the Princeton guide to applied mathematics. 
06:26:52 <Younder> It gives a taste some of the most interesting fields and a road-map for further exploration.
06:27:19 <bollu> Younder interesting, lemme check that book out
06:27:32 <bollu> Younder I've been looking for a book on denotational semantcs, and one on type theory
06:27:35 <bollu> any recommendations?
06:30:38 <Younder> bollu, Fpr denotation semantics I recommend 'The formal semantics of programming languages' by Winskel. For type theory why nor start out with a introductory text like 'Types and programming languages' by piercse
06:32:25 <Younder> Also interesting for more advanced study are 'Categorical logic and type theory' by Jacobs. Again advanced
06:32:29 <quchen> bollu: Any progress on the GHC ASM backend?
06:32:32 <bvad> bollu, Younder, thanks for the recommendations! 
06:33:24 <quchen> ReinH: Ping
06:35:43 <ertes-w> Younder: i don't mind transformers at all, but i'm very careful about "application monads"
06:36:42 <ertes-w> Younder: i.e. using a giant monad that includes *all* application-specific effects
06:48:33 <Younder> ertes-w, As you add stuff you might find it necessary to divide it into three parts, A OS kernel specific part, and Human Interface part and a Data aquistion part to help isolate the more transient parts fom the more static problem domain.
06:52:08 <glguy> Axman6: There's a C extension API where I can load extensions at runtime with dlopen that I use to support OTR, Lua scripts, and I have a Rust stub started that uses that interface
06:53:51 <bollu> quchen nope, still stuck with broken package DB
06:54:02 <bollu> quchen I can't compile large programs because they would have dependencies
06:54:06 <bollu> quchen small programs seem to work
06:54:14 <bollu> quchen it's thorny, idk how to debug it.
06:54:27 <pierrot> Good morning. I'm trying to install ghc-vis on Debian 8 but I have problems with the dependencies glib-0.12.5.4 and cairo-0.12.5.3
06:54:53 <Clint> pierrot: upgrade to debian 9?
06:54:54 <Axman6> merijn: ^ is glguy's response helpful? (RE dynamic loading)
06:55:13 <srhb> pierrot: What's the problem?
06:55:26 <merijn> Axman6: I've been kinda sidetracked trying to fix hdevtools, since it doesn't work with new-build :\
06:55:46 <Axman6> :(
06:55:48 <Clint> oh, glib 0.12 is old
06:55:55 <Younder> bolly: Tried a berkley-db interface? http://hackage.haskell.org/package/BerkeleyDBXML-0.1
06:56:08 <merijn> Axman6: So I don't really know :)
07:00:36 <pierrot> srhb: http://sprunge.us/LHDc
07:01:29 <merijn> Axman6: Sadly, my best workaround atm is a dirty hack to disable cabal option parsing in hdevtools, manually getting the relevant options out of cabal 
07:01:37 <merijn> Axman6: And then passing them all to hdevtools
07:02:14 <pierrot> Clint: yeah, I'll upgrade it as soon as I have enough time to make backups
07:05:48 <Axman6> merijn: that doesn't sound fun - bugs in hdevtools or newbuild? surely new-build should be able to build anything right?
07:06:49 <merijn> Axman6: neither, hdevtools was just using Cabal to figure out the right flags, but new-build uses entirely different ways to deal with those, they're working past eachother
07:07:06 <Axman6> oh right
07:07:27 <Axman6> thoguht this was a problem with building hdevtools
07:07:27 <merijn> Free beer or booze of choice for whoever fixes hdevtools >.>
07:07:50 <srhb> pierrot: Seems like the path of least pain is to user newer libraries.
07:23:39 <quchen> merijn: https://github.com/pcapriotti/optparse-applicative/issues/273
07:23:47 <quchen> merijn: There you go :-)
07:24:15 <merijn> quchen: \o/
07:31:47 * hackagebot syfco 1.1.0.0 – Synthesis Format Conversion Tool / Library – https://hackage.haskell.org/package/syfco
07:31:47 * hackagebot web-routes 0.27.12 – portable, type-safe URL routing – https://hackage.haskell.org/package/web-routes
07:39:55 <Younder> Why do you need type-safe URL routing? You already know the type ipv4 or ipv6, I don't get it.
07:40:40 <merijn> Younder: What do ipv4/6 have to do with anything?
07:41:05 <Younder> What else if there to routing
07:45:47 <hpc> url routing means the httpd resolving an http request to a webpage
07:46:13 <hpc> it's called routing because writing it in its most composable form looks very similar
07:46:21 <hpc> stuff starting with "/login" goes down the login route, etc
07:47:58 * hackagebot sbp 2.2.7 – SwiftNav's SBP Library – https://hackage.haskell.org/package/sbp
07:58:05 * hackagebot dual-tree 0.2.1 – Rose trees with cached and accumulating monoidal annotations – https://hackage.haskell.org/package/dual-tree
08:15:16 <nshepperd> Younder: 'type' refers to things like url parameters and postdata
08:15:50 <GamboPango> When I install `operational` using cabal, the system tries to build a TicTacToe example and fails with linker errors.  The linker cannot find any of the libraries needed to build the example, even `base`.  I would like to either skip building the example or help the linker find the libraries.  Any ideas?
08:15:52 <nshepperd> like how in /page/<id> the id should be an integer
08:16:01 <nshepperd> or whatever
08:19:20 * hackagebot hops 0.7.2 – Handy Operations on Power Series – https://hackage.haskell.org/package/hops
08:24:22 <shapr> @hackage checkers
08:24:22 <lambdabot> http://hackage.haskell.org/package/checkers
08:24:45 <shapr> Have I mentioned conal's checkers package is great and you should try it?
08:26:01 <bollu> is there a function of the type signature with foldable / traversable constraint on "t",  t a -> m Bool -> m Bool, which mimics "all", except you have this happening in the "m:" context
08:26:13 <bollu> I can write it myself, but I was wondering if there is a clever stdlib function
08:28:13 <jchia_1> I have a [State s a]. Is there a function of type 's -> [State s a] -> (s, [a])' that lets me 'chain' them up and get the final state and the list of a's that are returned?
08:29:28 * hackagebot diagrams-solve 0.1.1 – Pure Haskell solver routines used by diagrams – https://hackage.haskell.org/package/diagrams-solve
08:29:48 <bollu> allTraversable ta mpred = (foldl (&&) True) <$> (forM ta mpred)
08:29:53 <bollu> simpler way of writing that?
08:30:16 <bollu> jchia_1: traverse
08:30:18 <bollu> :t traverse
08:30:19 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
08:30:26 <bollu> :t sequence
08:30:27 <lambdabot> (Monad m, Traversable t) => t (m a) -> m (t a)
08:30:33 <bollu> jchia_1 ^
08:30:41 <shapr> @pl allTraversable ta mpred = (foldl (&&) True) <$> (forM ta mpred)
08:30:41 <lambdabot> allTraversable = ((foldl (&&) True <$>) .) . forM
08:30:50 <jchia_1> bollu: Will it actually chain up the states or will it just run all of them with the same inital state?
08:31:32 <nshepperd> :t \f xs -> and <$> traverse f xs -- bollu
08:31:33 <lambdabot> (Applicative f, Traversable t) => (a -> f Bool) -> t a -> f Bool
08:31:36 <bollu> jchia_1 it will chain it up 
08:31:45 <bollu> nshepperd wow, ty
08:31:48 <bollu> :t and
08:31:50 <lambdabot> Foldable t => t Bool -> Bool
08:31:50 <jchia_1> bollu: traverse only needs Applicative, so I doubt it'll involve >>=
08:31:52 <bollu> TIL >_>
08:32:17 <nshepperd> bollu: there is also Control.Monad.Loops.allM, which shortcircuits when it encounters False
08:32:18 <bollu> jchia_1: hm, sequenceM?
08:32:23 <bollu> :t sequenceM
08:32:25 <lambdabot> error:
08:32:25 <lambdabot>     • Variable not in scope: sequenceM
08:32:25 <lambdabot>     • Perhaps you meant one of these:
08:32:45 <bollu> :t sequence
08:32:46 <lambdabot> (Monad m, Traversable t) => t (m a) -> m (t a)
08:33:00 <bollu> I think sequence does what you want it to do
08:33:14 <bollu> because the traversable gives it the ability to chain the results. I'm not 100% sure
08:33:16 <bollu> try it out? :)
08:33:50 <nshepperd> "running all of them with the same initial state" doesn't make any sense for an arbitrary monad
08:34:01 <jchia_1> OK
08:34:22 <nshepperd> like, for IO you would have to reset the universe :)
08:34:57 <jchia_1> nshepperd: But IO does not require an input initial state to be used with runState
08:35:31 <nshepperd> so, both Applicative and Monad 'sequence' the actions in just the same way
08:37:34 * hackagebot bitcoin-payment-channel 1.2.0.0 – Instant, two-party Bitcoin payments – https://hackage.haskell.org/package/bitcoin-payment-channel
08:37:45 <bollu> nshepperd picking t = IO and arguing is cool :D
08:39:28 <nshepperd> > runState (sequence (replicate 10 (get <* modify succ))) 'a'
08:39:30 <lambdabot>  ("abcdefghij",'k')
08:41:07 <nshepperd> bollu: IO is the ideal monad :)
08:44:09 <nshepperd> i suppose you could write an unlawful instance of <*> for Applicative (State s) that would run both actions with the same initial state, and then return one of them as the next state. but it would be illegal!
08:44:25 <nshepperd> so it definitely doesn't do that
08:46:41 * hackagebot symantic 6.3.0.20170703, symantic-grammar 0.1.0.20170703, symantic-lib 0.0.2.20170703
08:46:41 * hackagebot  → https://hackage.haskell.org/packages/recent
08:51:55 <jchia_1> bollu: nshepperd: I think traverse works. I suppose it doesn't need >>= as I thought it would.
09:16:59 <Welkin> yesterday's rust/memory management discussion got me thinking about something
09:17:31 <Welkin> how exactly is rust's automatic memory management any different from garbage collection, or than freeing up resources on-demand instead of in cycles?
09:17:39 <Welkin> other than freeing up*
09:18:51 <AWizzArd> The first code box in the „Motivation” section: https://ghc.haskell.org/trac/ghc/wiki/UnpackedSumTypes
09:19:20 <AWizzArd> What is this {-# UNPACK #-} thing, what is the exclamation mark for, and why does (T1 a b) work, when T1 is not a data constructor?
09:19:27 <nshepperd_> Welkin: you have to think about it a lot more?
09:19:52 <hpc> Welkin: imagine a garbage collector backed by static analysis to insert "i know this is a good spot to free up space"
09:20:25 <hpc> Welkin: then imagine you had some sort of perfect static analysis tool that knows when everything leaves scope, loses all its references, etc
09:20:36 <Welkin> hpc: so it _is_ still garbage collection, just by a different name
09:20:55 <hpc> not quite
09:20:56 <Welkin> because it's fashionable to say "GC is bad"
09:21:32 <hpc> now that you have this perfect static analyzer, you eliminate the garbage collection algorithm and free only the specific memory that you statically know can be collected
09:21:47 <hpc> it's no longer a garbage collector, it's more like automatic insertion of malloc and free
09:22:11 <Welkin> to me, that is a garbage collector
09:22:20 <Welkin> but perhaps my definition is not the same as others
09:22:33 <hpc> it's a garbage collector in the same way that python's object tags are a type system
09:22:41 <hpc> one is static, the other is dynamic
09:22:58 <Welkin> okay, that makes more sense
09:23:25 <Welkin> why can't other languages do the same then?
09:23:36 <hpc> it takes an affine type system to pull it off
09:23:39 <Welkin> and is it inherently better?
09:23:56 <Welkin> or, in practical usage?
09:23:59 <hpc> so it's hard to implement
09:24:12 <Welkin> what do you mean by affine?
09:25:09 <hpc> https://en.wikipedia.org/wiki/Substructural_type_system
09:25:12 <nshepperd_> It's also hard to use imo, because (immutable) sharing is good and it makes that extra effort
09:25:22 <AWizzArd> I think with Haskell’s 8.2 Linear Typing one can have similar benefits in some cases. You can have automatic memory management, but without the GC.
09:25:25 <nshepperd_> Welkin: move semantics
09:25:29 <Welkin> hpc: just found that article too :P
09:25:42 <hpc> also what nshepperd_ says
09:25:56 <hpc> it being a static checked system, memory management mistakes show up as compile errors
09:27:48 <hpc> and yeah, haskell getting linear types is going to be rather exciting
09:27:56 <hpc> i personally hope that someone writes a type-safe rust FFI
09:28:36 <AWizzArd> Welkin: http://blog.tweag.io/posts/2017-03-13-linear-types.html
09:29:28 <Younder> Is Petry Jones cleaning up that messy type dispatcher. I always felt it should be rule based.
09:31:09 <Welkin> AWizzArd: thanks
09:31:25 <Younder> Atomic types is a good efficiency improvement. But the real advantage is making the maintainable. At present 2 people understand it, but close to retirement, and the it will be maintained no more.
09:32:22 <Younder> :)
09:34:50 <Welkin> Does anyone use Clean for anything?
09:34:54 <Welkin> or is it just a research project?
09:38:39 <horrorcheck> Hi, I'm trying to use ghci breakpoints like so: `:break ListTests 119`, but it says `module 'ListTests' is not interpreted; try ':add *ListTests' first`, and when I run `:add *ListTests`, that doesn't help, I still get the same error
09:41:00 <zomg> if you need to fold through a potentially large list, but you don't necessarily have to iterate every element, is foldl "good enough" or is it better to have a custom function which cancels out?
09:41:13 <zomg> Ie. there's an accumulator and once it hits a certain value, the rest of the list can be skipped
09:41:56 <clever> really ugly solution, throw the result!
09:41:59 <nshepperd_> foldl will always read the whole list
09:42:39 <Welkin> you can exit early using foldr
09:43:07 <Welkin> but simple recursion always works too
09:43:50 <zomg> well foldr would save having to reverse the list after sorting it =)
09:45:27 <nshepperd_> :t \f z xs -> foldr (\x k acc -> either id (k . f x) acc) id xs (Right z)
09:45:28 <lambdabot> error:
09:45:28 <lambdabot>     • Occurs check: cannot construct the infinite type: c ~ Either c a
09:45:28 <lambdabot>       Expected type: Either c a -> c
09:45:40 <nshepperd_> So close
09:46:18 <Cale> zomg: foldl will *always* go through the whole list
09:46:25 <Cale> while foldr can short circuit
09:46:28 <Cale> @src foldl
09:46:29 <lambdabot> foldl f z []     = z
09:46:29 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
09:46:45 <Cale> foldl does nothing except to greedily apply itself to new arguments until it reaches the end
09:46:50 <Cale> @src foldr
09:46:50 <lambdabot> foldr f z []     = z
09:46:50 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
09:47:11 <Cale> while foldr passes control to f, only if f pattern matches its second parameter will the foldr need to continue
09:49:18 <Cale> (If and when -- f might return something constructed in terms of its second parameter, and the foldr will continue only when that bit of its result is evaluated)
09:51:51 <zomg> Ok, not sure if I really get how that works because all I can think of is a for loop and a break keyword =)
09:52:18 <Cale> zomg: Well, the important thing to understand is that lazy evaluation is outermost-first
09:52:29 <mniip> maybe writing out some call-by-name reductions on a piece of paper can help
09:53:18 <Cale> zomg: So when you see an expression like f (g (h x)), it's f which happens first, and it receives (g (h x)) as an argument, not yet evaluated.
09:54:04 <mniip> that assuming f is a function at all
09:54:14 <Cale> Well, f has to be a function there
09:54:16 <mniip> (first f itself is evaluated)
09:54:17 <hpc> it has to be in order to take an argument
09:54:38 <hpc> it might be bottom, but it absolutely has a type with (->) at its root
09:54:47 <mniip> bottoms, exactly
09:54:49 <zomg> that makes sense but how can f produce a value without having its parameters be evaluated
09:55:24 <Cale> zomg: Well, perhaps a better question would be "why would f need to evaluate its parameters?"
09:55:36 <zomg> heh
09:55:40 <Cale> zomg: and the reason for almost all evaluation to occur is pattern matching
09:55:58 <Cale> f only needs to evaluate its parameters if it wants to match them against patterns
09:56:16 <zomg> right
09:56:36 <Cale> Otherwise, it can simply pass them along to wherever they're going, untouched
09:56:43 <Cale> (or discard them, if they're unused)
09:56:58 <Sh4rPEYE> Hey, I'm trying to implement a little bit of imperative programming in Haskell. It should work like this snppet suggests: http://lpaste.net/8176238200973426688
09:57:12 <nshepperd_> > foldr (\x a -> if x^2 > 1000 then x else a) 0 [1..]
09:57:14 <lambdabot>  32
09:57:47 <mniip> Sh4rPEYE, there's a thing called ST
09:57:52 <Cale> omg
09:58:01 <Cale> can we...
09:58:02 <Cale> not
09:58:03 <mniip> eh, matrix
09:58:19 <Cale> Is this matrix thing really necessary?
09:58:29 <hpc> why do they all have [m] in their nick, too
09:58:36 <mniip> hpc, that's the matrix thing
09:58:38 <Clint> it's a scarlet letter
09:58:53 <Cale> hpc: Because they're not actually connected to IRC properly, they're using some sort of matrix interop thing
09:58:57 <nshepperd_> a is only evaluated if x^2 is <= 1000, so the program terminates without evaluating all of the list
09:58:59 <hpc> ah
09:59:00 <Welkin> what matrix thing?
09:59:03 <bitemyapp> Cale: I wouldn't mind if the bridge wasn't such a bad IRC citizen.
09:59:05 <mniip> Sh4rPEYE, ST is made specifically for this purpose - explicit mutable variables in pure code
09:59:09 <Clint> Welkin: riot.im
09:59:10 <zomg> nshepperd_: ah I think I get it now :)
09:59:14 <Welkin> ...?
09:59:17 <zomg> thanks all
09:59:39 <Welkin> Cale: this happened earlier too, about 20-30 minutes ago
09:59:47 <Welkin> massive channel flood
09:59:47 <mniip> there are channels that ban matrix entirely
09:59:52 <mniip> not that I would advise to do so
09:59:52 <Welkin> why is it here?
09:59:57 <Sh4rPEYE> mniip: Oh, ok. I'll look it up. So it is like IORef (with the mutability) + State (with the "outside of IO" pureness)?
10:00:03 <Sh4rPEYE> That'd be cool
10:00:21 <Clint> Welkin: because people joined the channel
10:00:30 <mniip> Sh4rPEYE, it's a monad. Variables are tainted with the monad, and there's a function toget a pure value out
10:00:30 <Welkin> I remember some slack-irc bridge bot was in here before and was quickly banned for spamming
10:00:34 <Cale> zomg: Anyway, for this reason, the stack in most lazy evaluators (GHC included) isn't really a call stack -- you don't need a stack entry to tell you where the result of a function application is returning to -- it's the same place as before since everything is outermost-first.
10:00:43 <mniip> Sh4rPEYE, but due to type magic you cannot drag a *variable* out of it
10:01:22 <Cale> zomg: It's the case expressions and other pattern matches where things are interesting -- those will wait on the stack for the scrutinee to be sufficiently evaluated to match a pattern.
10:02:10 <Cale> zomg: and they make up the majority of the stack entries most of the time -- there are a few other sorts of stack entries in GHC, but if you ever get a stack overflow, it's almost certainly because of too many pattern matches waiting to happen.
10:02:40 <m4lvin[m]> some Data.Set experts around? Is there a better way to collapse lists than my naive (Data.Set.unions . Data.Set.toList) ?
10:03:00 <m4lvin[m]> (sorry, I mean collapse sets of sets to sets.)
10:03:19 <Welkin> m4lvin[m]: are you using matrix to connect to irc?
10:03:37 <zomg> Cale: thanks, good to know :)
10:04:20 <Sh4rPEYE> Thanks.
10:04:34 <m4lvin[m]> yes, why?
10:04:58 <Welkin> m4lvin[m]: why not connect directly?
10:05:43 <zomg> so I wrote a very very naive bitcoin trading bot in haskell... I should donate the initial proceeds to some of you :P
10:06:02 <zomg> don't get excited - it's currently made like 50 cents or so
10:06:03 <zomg> lol
10:06:10 <Sh4rPEYE> zomg: is it open source? 
10:06:11 <kadoban> zomg: Do we have to pay the losses too?
10:06:32 <zomg> Sh4rPEYE: it might be at some point :)
10:06:55 <koala_man> I'll sell my Google stock and buy into your bitcoin bot. It's probably less volatile
10:07:10 <zomg> heh
10:07:40 <m4lvin[m]> Welkin: laziness ;-)  is matrix frowned upon here?
10:08:11 <Welkin> m4lvin[m]: it's spamming up the channel with massive floods
10:08:37 <monochrom> I don't think matrix normally flood.
10:08:49 <zomg> I've not even noticed any floods because I have all joins, parts and quits ignored :P
10:08:54 <hpc> it's netsplit flood
10:09:09 <hpc> or the equivalent of netsplit for whatever matrix is
10:09:19 <zomg> I initially thought I might miss having those info lines but after using it I don't miss them at all
10:09:22 <monochrom> Yeah, you don't say "let's get rid of asimov.freenode.net" just because there were one or two netsplits.
10:09:35 <monochrom> Although, who knows? Maybe it's a good idea.
10:09:47 <Clint> they should get rid of all the servers
10:09:59 <Welkin> we should move to OFTC
10:10:00 <hpc> Clint: you don't need any servers if you use the cloud
10:10:05 <Clint> hpc: hooray!
10:10:15 <hpc> this is why whenever i write new code, it's vaporware
10:10:38 <monochrom> But make sure you condense the vaporware into cloud!
10:11:09 <nshepperd_> If one server was particular susceptible to netsplits you'd probably replace it
10:11:39 <Clint> decades of irc history show that to be untrue
10:12:09 <monochrom> We need to move off to Usenet.
10:12:10 <hanna> What would it take to make a fork of Haskell that has no garbage collector? What would the resulting language look like? How much more awkward would it be to program in compared to Haskell?
10:12:20 <mniip> Welkin, :<
10:12:20 <hanna> I'm thinking that maybe ideas from Rust could be “ported back”
10:12:52 <monochrom> IIRC jhc had no garbage collector.
10:13:02 <mniip> hanna, something something linear programming
10:13:16 <mniip> hanna, you could read up about linear types and comonads
10:13:19 <mniip> er
10:13:22 <mniip> comonoids*
10:13:39 <monochrom> Or probably towards its latest version it began to have an experimental garbage collector you can turn off.
10:13:55 <hanna> linear types aren't a 1:1 map, though, right? more like affine (“use at most once”)
10:14:08 <mniip> iirc there was a language that supported linear types in such a fashion. Idris perhaps
10:14:18 <monochrom> Clean?
10:14:53 <mniip> hanna, linear types enforce both explicit duplication and explicit destruction
10:15:04 <mniip> saving you from 1) use after free and 2) leaks
10:15:51 <mniip> I suppose you could make something like a reference type, that would make sense in presence of linear types
10:22:42 <Sh4rPEYE> mniip: How do I create a new ST?
10:22:50 <mniip> ?
10:23:11 <mniip> How do you create a new IO?
10:23:51 <Sh4rPEYE> I just, well, create some action
10:24:08 <kadoban> Sh4rPEYE: What do you mean create a new ST? reimplement ST, or you're just trying to use it?
10:24:19 <Sh4rPEYE> Just use it.
10:24:28 <Sh4rPEYE> I want to have function like this: (+=) :: STRef Integer Integer -> STRef Integer Integer -> ST s ()
10:24:38 <Sh4rPEYE> At least, I think the function should look like that.
10:25:28 <Sh4rPEYE> It should that two STRefs and replace the first one with their sum. (normal impertaive +=)
10:25:28 <kadoban> Sh4rPEYE: A more likely candidate would be  :: forall s. STRef s Integer -> STRef s Integer -> ST s ()     or using some s from ScopedTypeVariables at a higher scope
10:25:37 <hanna> the ‘s’ in STRef should always stay polymorphic; i.e. you'd write += :: STRef s Int -> STRef s Int -> ST s ()
10:25:52 <Sh4rPEYE> Oh, ok.
10:26:00 <hanna> the reason for this is that runST :: (forall s. ST s a) -> a  needs it to be polymorphic
10:26:18 <hanna> think of the ‘s’ as just a value that prevents you from mixing up different ST actions from between different runST invocations
10:26:29 <hanna> it could be “MagicTypeOne” for the first runST block and “MagicTypeTwo” for the second
10:26:32 <hanna> your code doesn't care
10:26:48 <hanna> but you can't somehow mix an STRef MagicTypeOne Int with an STRef MagictypeTwo Int, which is why “runST” is pure
10:26:57 <hanna> the ‘s’ can never “escape” the runST
10:27:04 <hanna> since your code never even knows what it is
10:27:17 <kadoban> I like to think of it as the thing that prevents me from using (.) with a weird type error :(
10:27:29 <hanna> yeah
10:27:42 <hanna> rank-N polymorphic types are annoying for sure :p
10:28:01 <Sh4rPEYE> Ok. Ok, got it.
10:28:09 <hanna> iirc doesn't GHC even have some specialcasing for (.) and ($) ?
10:28:15 <kadoban> But ST is pretty cool anyway.
10:28:40 <kadoban> I think for ($). I'm not really quite sure for (.) what's going on. Every time I try it seems to ... not go well, which could just be incompetence or old versions or something.
10:28:41 <Sh4rPEYE> I think I need reed up on it some more.
10:28:59 <Sh4rPEYE> Any good articles? Suitable for a beginner (as much as possible)? :-)
10:29:15 <Welkin> for ST?
10:29:27 <Sh4rPEYE> Yep
10:30:10 <Welkin> Sh4rPEYE: https://www.microsoft.com/en-us/research/wp-content/uploads/1994/06/lazy-functional-state-threads.pdf
10:30:16 <Welkin> the best (and my favorite) paper
10:30:17 <hanna> :t let idST v = newSTRef v >>= readSTRef in runST . idST
10:30:19 <lambdabot> error:
10:30:19 <lambdabot>     • Couldn't match type ‘ST s0 b’ with ‘forall s. ST s c’
10:30:19 <lambdabot>       Expected type: ST s0 b -> c
10:30:20 <hanna> :t let idST v = newSTRef v >>= readSTRef in runST $ idST 0
10:30:22 <lambdabot> Num a => a
10:30:22 <hanna> seems to still be the case
10:30:32 <kadoban> Sh4rPEYE: I personally didn't understand it very well until I just used IO first. ST s is more powerful in a certain way (you can eventually drop the ST s, which you can't for IO safely), but otherwise they're similar. And IO has less magic around it, IMO.
10:31:07 <hanna> From a programmer point of view you can think of ST as a subset of IO that allows you to evaluate it purely: runST :: ST s a -> a  (hiding the magic)
10:31:29 <hanna> it only allows you to perform mutable memory operations
10:32:10 <hanna> (and only on safe references constructed within the same ST s monad)
10:32:33 <Sh4rPEYE> WHen I'm in the ST Monad, does it work like normal State Monad?
10:32:40 <Cale> Sh4rPEYE: I don't know how new you are to functional programming, but I found it very helpful to realise that it's generally possible to translate imperative programs (with only memory effects) into pure functional ones by taking all the mutable variables in scope and turning them into function parameters, and turning each point of control in the imperative program into a separate function.
10:32:57 <Sh4rPEYE> I'm new to programming in general
10:33:01 <cocreature> Sh4rPEYE: ST and State don’t have much to do with each other
10:33:27 <Welkin> Sh4rPEYE: read the paper I linked, it is very beginer friendly and explains a lot
10:33:31 <Cale> So you just have these functions apply each other according to how the imperative program would run, to new arguments determined by how the variables are changing
10:33:33 <Sh4rPEYE> Yes, will do
10:33:37 <hanna> Sh4rPEYE: ST has nothing to do with State
10:33:39 <kadoban> Sh4rPEYE: Very much less like State and very much more like IO, except without the ability to write to files, read from files, output to screen, etc.
10:33:41 <Sh4rPEYE> Seems I have deep misconceptions
10:33:42 <hanna> that's a misconception
10:33:48 <hanna> think of ST as IO-lite, not State
10:33:50 <Cale> I might have an example sitting around...
10:33:52 <kadoban> It's a very common one
10:34:10 <hanna> well how familiar are you with IO in haskell?
10:34:35 <wz1000> cabal haddock fails when I build stuff with -dynamic
10:34:38 <wz1000> http://lpaste.net/356647
10:35:23 <Sh4rPEYE> hanna: ONly marginally. I know how to use it to do basic stuff. In my mind I see IO as means of getting recipe to get something later. Get or do, that is
10:35:31 <Sh4rPEYE> Just basic stuff from HAskell Book.
10:35:32 <Welkin> Sh4rPEYE: this is also a good one on introducing monads https://www.microsoft.com/en-us/research/wp-content/uploads/1993/01/imperative.pdf
10:35:51 <Welkin> when monads first started being used for IO
10:36:06 <Cale> http://lpaste.net/354126
10:36:11 <Sh4rPEYE> Taks. Will read that one too
10:36:24 <Cale> lpaste maybe deleted the rest of the steps I had?
10:36:25 <hanna> Sh4rPEYE: well if you think of ‘IO a’ as a recipe to perform a computation that affects the real world, then you could think of ‘ST s a’ as a recipe to perform a computation that (temporarily) requires mutable memory to complete
10:36:52 <hanna> Sh4rPEYE: for example, a good use case for ST might be a sorting algorithm on an array
10:36:53 <Cale> But anyway, once you get the idea of this translation, it's easy to simplify this mess that we end up with because it's a mess of *equations*
10:37:10 <cocreature> wz1000: how exactly are you enabling -dynamic? iirc I’ve seen errors like that when manually trying to pass that argument instead of using --enable-executable-dynamic
10:37:15 <Cale> So you can simplify it just like you'd simplify expressions in highschool algebra, substituting equals for equals.
10:37:21 <Sh4rPEYE> Cale: There is only 30 lines
10:37:26 <wz1000> cocreature: in .cabal/config
10:37:47 <Cale> Sh4rPEYE: Yeah, only 30 lines, but it's for a function which ought to be more like 2 :)
10:38:01 <cocreature> wz1000: via ghc-options or via executable-dynamic?
10:38:09 <wz1000> ghc-options
10:38:11 <Sh4rPEYE> Cale: Just reported so you could see if something got lost n lpaste
10:38:16 <Sh4rPEYE> Cale: THanks :-)
10:38:18 <cocreature> wz1000: then try executable-dynamic
10:38:23 <monochrom> Yeah, please don't use ghc-options for that.
10:38:27 <Cale> Sh4rPEYE: Well, I know what got lost
10:38:36 <Cale> Sh4rPEYE: all the rest of my simplification steps...
10:38:56 <Cale> (I pasted this a long time ago, and added other stuff in annotations, but they seem to be missing)
10:39:42 <Cale> Sh4rPEYE: anyway, does that general pattern make sense?
10:40:07 <Sh4rPEYE> Sure it will, once I find some time to read that. I'm on commute right now.
10:40:17 <Cale> You can usually go directly to a much better translation than this technique produces
10:40:23 <monochrom> "Don't IRC and drive" :)
10:40:53 <Cale> But at least I found it helpful to have something where you can turn a crank and go from imperative to functional
10:41:22 <Sh4rPEYE> I'll read the two papers and look at the general idea on lpaste :-)
10:41:33 <Sh4rPEYE> If something will be still unclear, I'll come tomorrow
10:41:34 <monochrom> The remainings steps are really just "inline most of those functions because they're one-shot deals anyway"
10:41:36 <Sh4rPEYE> Thanyou all
10:41:39 <Cale> I've actually used this technique in order to understand a few small obfuscated (or just confusing) C programs
10:41:59 <wz1000> cocreature: executable-dynamic is broken on arch
10:42:03 <Cale> Sh4rPEYE: My lpaste isn't about ST though, just plain functional programming
10:42:34 <monochrom> I've lately done the reverse, Cale. From recursion (usually non-tail and doubly, e.g., f(n-1) + f(n-2)) to loop+stack, via first CPSing then defunctionalization.
10:43:10 <monochrom> Oh, not arch again.
10:43:28 <Cale> monochrom: neat
10:43:47 <monochrom> Please talk to the Reverend geekosaur for how to redeem yourself from arch's sin.
10:43:47 <Sh4rPEYE> Cale: I know, but it'll help in my concrete example.
10:43:54 <Cale> Sh4rPEYE: yeah
10:44:17 <Cale> Sh4rPEYE: and quite often something along these lines is useful even if you're using IO or ST already
10:45:25 <Cale> I will very often have a loop or some such written using IO, and accumulating something in a function parameter.
10:45:55 <monochrom> The stack emerges when defunctionalization of this kind of CPSed code causes a stack-like ADT you have to pass around.
10:46:56 <monochrom> So you don't actually have to aim for a stack. Just aim for a loop with defunctionalization, it will invent the stack (and what stack frames you need) for you.
10:48:12 <monochrom> Now that Peter Naur kid was a genius. He was before CPSing and defunctionalization, and he still invented using a stack for recursion. That's something.
10:48:47 <cocreature> wz1000: how so?
10:48:59 <cocreature> wz1000: I’m pretty sure I’ve used it on arch even since the last update
10:49:45 <wz1000> cocreature: i get ld error
10:50:11 <monochrom> Did you know: Before Peter Naur, implementers thought that recursion was unimplementable, because they thought that their only option was to statically reserve space for: one activation record per procedure, i.e., non-reentrant.
10:50:36 <wz1000> cocreature: how have you made it work since that update?
10:50:43 <mizu_no_oto> Sh4rPEYE: Are you familiar with State, and how it works?
10:50:58 <monochrom> cocreature: Do you use arch's GHC, or do you acquire your own?
10:51:10 <cocreature> wz1000: personally I’ve just nuked everything except for ghc and ghc-static and installed a statically linked cabal via stack and now everything works again
10:51:18 <cocreature> monochrom: I use the one from arch
10:51:36 <monochrom> That's an interesting approach.
10:51:44 <monochrom> So you don't use arch's cabal-install.
10:51:59 <monochrom> That solves a bit of bootstrapping problem.
10:52:09 <monochrom> Or rather, breaks the vicious cycle.
10:52:10 <cocreature> wz1000: if you show us the _exact_ command you ran (including any customizations in cabal.config) and the exact error message, we might be able to help more
10:52:50 <cocreature> monochrom: yeah, it’s not super pretty but at least I have a working setup and since I’ve done this nothing broke and I hope it stays this way
10:53:10 <cocreature> I’m still pissed off that they switched to dynamic linking but I’m not interested in debating this with the maintainer
10:53:50 <monochrom> It is not switching to dynamic linking per se. It is banning static libraries altogether that hurts.
10:54:38 <bitemyapp> monochrom: Apple did this with macOS as well and it has been painful.
10:54:42 <monochrom> There is nothing wrong with "build and ship both *.so and *.a, but exes linked against *.so".
10:55:04 <monochrom> In fact cabal-install does that already.
10:55:13 <cocreature> tbh, I’d even be fine if they changed the default of GHC to dynamic linking
10:55:27 <cocreature> but having ghc and cabal not work without passing any options is just shitty
10:55:27 <monochrom> Well, the second half requires a non-default setting, but meh.
10:55:45 <wz1000> cocreature: my cabal config is clean except for -dynamic in ghc-options. The command I use is cabal sandbox init; cabal install --only-dependencies; cabal haddock
10:56:01 <monochrom> This is why I hate distro party lines and ideologies.
10:56:12 <cocreature> wz1000: step 1. remove -dynamic step 2. add --enable-executable-dynamic to your cabal invocation
10:56:22 <Tuplanolla> Is this a replay of yesterday?
10:56:34 <Welkin> why would you install ghc from a linux distro's package manager anyway?
10:56:36 <monochrom> It's more subtle than that, Tuplanolla!
10:56:42 <Welkin> use stack or nix
10:56:51 <Tuplanolla> You've been on it the whole time?
10:56:54 <monochrom> It's a replay of a few days ago. :)
10:57:16 <Welkin> someone else was in here yesterday complaining about the same thing, right?
10:57:24 <monochrom> So basically we have multiple victims of arch, a different victim each day, but someones a past victim returns.
10:57:28 <Welkin> installing ghc from arch's repos
10:57:34 <monochrom> s/someones/sometimes/
10:58:10 <monochrom> And in fact it gets even messier than that.
10:58:26 <Welkin> linux distro's package managers are always out of date with haskell
10:58:38 <Welkin> and if they screw something up in the build, it's their fault
10:58:55 <Welkin> but no one blames the repo
10:59:07 <monochrom> You also have a victim of unwanted space growth, who in the process of profiling, also runs into this arch problem.
10:59:28 <Cale> http://lpaste.net/354126#a356648 -- there, remade the annotation :)
10:59:52 <Welkin> I set up an arch system recently, but have not yet installed haskell on it
10:59:56 <Welkin> when I do, it will be using nix
11:00:46 <wz1000> cocreature: I still get the linker error.
11:01:31 * monochrom replays his leaky-abstraction rhetoric.
11:02:25 <Cale> I use Linux Mint, but lately I get all my GHCs using nix
11:02:53 <monochrom> I have used GHCs from Haskell Platforms for many versions.
11:03:18 <Cale> nix-shell -p "haskellPackages.ghcWithPackages (pkgs: with pkgs; [pipes mtl async])"
11:03:32 <Cale> will drop you into a shell with the appropriate list of packages installed
11:03:58 <monochrom> But I'm planning next time I'll use GHC from GHC directly, and just steal Haskell Platform's list and build them myself. It's for fewer broken links in the docs.
11:04:29 <Cale> reflex-platform also has a script called work-on which you can aim at any directory with a .cabal file in it, and it will put you in a shell with all the dependencies for that project
11:05:43 <Cale> I really should make a script for that first case -- I usually just type "ghcW" and press up and then edit the commandline from my shell history :P
11:05:55 <monochrom> haha
11:06:35 <monochrom> No, make a shell function.
11:07:30 <Welkin> make it a shell alias
11:07:39 <Welkin> `g`
11:07:50 <Welkin> or `h`
11:07:59 <suzu> true haskell naming
11:13:28 <benzrf> i made an alias
11:13:38 <benzrf> hack8 () {
11:13:39 <benzrf>  nix-shell -p "haskell.packages.ghc802.ghcWithPackages (hp: with hp; [hdevtools $*])"
11:13:42 <benzrf> }
11:14:10 <benzrf> er, i suppose that's a function and not an alias
11:14:58 <plugin> I've got some code that tries yields a storable vector of `Float`; I'm trying to write this to an audio bufffer which expects `CFloats`; GHC complains though I belive the former is a newtype of the latter.  how can ask ghc to accept this?
11:15:59 <monochrom> benzrf: QED :)
11:16:26 <benzrf> Error: Attempt to save an incomplete proof (in proof Haskell_irc)
11:16:38 <monochrom> heh
11:17:06 <monochrom> plugin: I wonder if the "Coercible" type class helps you.
11:17:26 <monochrom> Alternatively, work with CFloat throughout.
11:18:37 <suzu> plugin: perhaps Foreign.Marshal is what you're looking for?
11:18:49 <ph88> is it possible to export a function from a module with a different name ?
11:19:48 <suzu> module Foo where (newName)
11:19:52 <suzu> newName = oldName
11:20:02 <suzu> ?
11:20:36 <ph88> eh ok
11:22:40 <nick_h> Hello - is there anyone with an understanding of ghc-8.0.2 and linking that could please help me debug an issue I'm having in my environment?
11:23:02 <monochrom> Is it arch?
11:24:30 * hackagebot sloane 5.0.1 – A command line interface to Sloane's OEIS. – https://hackage.haskell.org/package/sloane
11:25:07 <nick_h> Yes...
11:25:16 <geekosaur> arch's 8.0.2 is broken
11:25:42 <geekosaur> install the ghc-static package to get the static libvs back that ghc is expecting, and expect further breakage with any arch-packaged haskell packages
11:25:44 <nick_h> Oh.
11:25:48 <suzu> arch fucked all the haskell packages
11:26:06 <suzu> fucked meaning made everything dynamically linked
11:26:08 <geekosaur> or, install ghc from somewhere other than arch (although I hear the archhaskell overlay is still functional)
11:26:15 <suzu> i'm afraid to upgrade my system tbh
11:26:18 <suzu> i know xmonad is gonna break
11:26:19 <suzu> :(
11:26:23 <geekosaur> made everything dynamically linked *without switching ghc to dynamic by default*
11:27:00 <geekosaur> so you can force -dynamic to make things work, or install static libs (which won't help with arch packages that explicitly remove them and provide no way to get them back)
11:27:01 <nick_h> I uninstalled a lot of things trying to get this working :P
11:27:03 <ReinH> I'm going to quote myself from a decade ago regarding a different language and system package manager dispute.
11:27:05 <ReinH> Let gems manage your rails package otherwise gem and apt-get will start fighting like Spock and Captain Kirk in Amok Time. If you haven't seen that episode, trust me: you don't want that. 
11:27:07 <nick_h> ... including xmonad.
11:27:12 <ReinH> In this case, that's cabal or stack.
11:27:43 <ReinH> The situation has not improved appreciably in the last decade.
11:28:33 <nick_h> geekosaur: I did try the static ghc package earlier, but that fixed all but a few packages.
11:28:43 <geekosaur> yes, as I warned
11:28:57 <suzu> im going to bite the bullet and just upgrade my system now
11:29:01 <suzu> sigh
11:29:10 <geekosaur> any haskall packages installed via pacman lack static libraries and don't provide a way to get them back
11:29:26 <suzu> the only haskell packages i want out of arch are two: xmonad and stack
11:29:27 <nick_h> What's the best approach? I started my day setting up nix, but somehow thought that was broken or it broke everything...
11:29:30 <ReinH> I recommend installing stack and then not using the system ghc at all. In fact, I recommend uninstalling the system ghc.
11:30:33 <ReinH> You can also do well by installing ghc and cabal and then using only cabal to manage your haskell packages.
11:31:06 <ReinH> But if your system package manager's ghc is having issues then I recommend ignoring it altogether.
11:31:10 <Gurkenglas> Looks like ghcjs can't build ansi-terminal on Windows. Is there a workaround?
11:31:45 <ReinH> I suppose a linux VM is technically a workaround. I don't know if ghcjs has a good windows story.
11:31:57 <Gurkenglas> (Should this be posted as an issue to ghcjs or ansi-terminal?)
11:32:26 <monochrom> Don't use arch's haskell libraries. They are simply incomplete.
11:32:45 <suzu> ghcjs likely Gurkenglas 
11:32:47 <monochrom> But I guess easier said than done if you use arch's ghc.
11:32:54 <suzu> ghc has no problem building ansi-terminal on windows
11:32:56 <nick_h> Which entails not using ghc from arch...
11:33:11 <ReinH> Thus my suggestion to use stack.
11:33:24 <monochrom> cocreature: You use arch's GHC. How much of haskell libraries does that bring in? Do they cause you problems?
11:33:47 <geekosaur> Gurkenglas, arguably this is neither because javascript is not expected to have access to C FFI
11:33:48 <nick_h> Yeah :) I was in the process of removing stack as well, to use nix instead.
11:33:53 <Gurkenglas> (I think it's because ansi-terminal uses C primitives for its Windows compatibility)
11:34:06 <geekosaur> (and javascript kinda doesn't normally expect to run in a terminal environment)
11:34:06 <ReinH> nick_h: Well, would you rather learn stack or nix?
11:34:24 <Gurkenglas> geekosaur, so I suppose it should go to miso for having ansi-terminal as a dependency?
11:34:40 <suzu> oh whoops yes geekosaur is right
11:34:47 <geekosaur> no, ghcjs will never be able to guess how to make this work for you. you could file it against ansi-terminal but I wouldnt be surprised if they don't care about javascript targets
11:35:01 <geekosaur> Gurkenglas, quite possibly yes, it should provide a flag to amke it optional
11:35:25 <ongy> monochrom: there's ghc-static in community, which has the static files for the libraries distributed with ghc
11:35:25 <cocreature> monochrom: it brings in the libs that ghc always brings in and if you install ghc-static it behaves just as usual
11:35:33 <monochrom> It may be a pipe dream that ansi-terminal is going to automatically do jquery terminal just because it detects that you're using ghcjs :)
11:35:53 <monochrom> Ah, ghc-static.
11:36:13 <nick_h> ReinH: I'd prefer nix .. I think .. 
11:36:30 <ongy> I also pimped cabal-install-git on the aur to work (provided none of the haskell-* libs are installed)
11:37:37 <nick_h> monchrom/ongy: ghc-static seemed to not include primitive/hashtable/text - these linking errors were not resolved by installing ghc-static.
11:37:50 <srhb> nick_h: There's a fair number of Nix users here (and a fair number of Haskell users in #nixos) if you need a hand sometime.
11:38:12 <monochrom> I would think ghc-static would bring in primitive.
11:38:31 <monochrom> You are supposed to acquire hashtable and text outside arch. This is not negotiable.
11:38:43 <ReinH> nick_h: fwiw, it took me a day to learn enough stack to be productive but I have bounced off of nix multiple times.
11:39:11 <ReinH> This despite pairing with johnw on setting nix up initially.
11:39:24 <ReinH> YMMV, I suppose. Apparently it is indeed possible to learn nix.
11:39:46 <ReinH> For people who are not me.
11:39:49 <johnw> :(
11:39:51 <Cale> ReinH: I don't really know how to use nix, but I use it.
11:39:55 <Cale> heh
11:40:07 <monochrom> Oh, nevermind, acquire primitive from outside arch, too.
11:40:08 <Younder> it is sort of i think i have been trying for 30 years and i am still not sure i have succeded
11:40:09 <ReinH> johnw: I'm sure it wasn't your fault.
11:40:25 <ReinH> But iirc we did have a fun time trying to use the unstable channel or w/e it is called.
11:40:48 <Cale> Unfortunately, I feel like the same is true of mostly everyone else, because the details of what has been constructed with nix are almost entirely unlearnable, except locally.
11:41:08 <ReinH> When you were like "Oh, let me patch that for you live" I was quite impressed but I also began to have doubts about my ability to use nix successfully. ;)
11:41:23 <monochrom> Time to hire monochrom to write "Structure and Interpretation of Nix" :)
11:41:30 <ReinH> heh
11:41:39 <ReinH> Yes. SIN. Makes sense.
11:42:06 <geekosaur> SINE Structure and Interpretation of the Nix Environment
11:42:08 <Cale> monochrom: Instead of that, I'd prefer to hire you to work on a clean transition from nix scripts to Haskell.
11:42:38 <monochrom> Highest bidder wins my contract and pay the 2nd highest bidding price.
11:42:39 <Younder> Modern OS'es are so complex you never understand the sum of the parts. You get a bit at a time, but the devil is in the detail, and there is always some bugger that get's away. I can barely keep my head above water and I am better than average. Says something about the state 
11:43:12 <ReinH> "And all the children are above average."
11:43:24 <srhb> Cale: That would be cool indeed. I'm starting to grok nix, but it's surprisingly dense (and why oh why are there no proper types)
11:43:27 <Younder> Give it a try
11:43:39 <srhb> Cale: That said, the amount of cargo culting is probably helped along by how easy it is to cargo cult. :-P
11:43:45 <Cale> We need someone who knows more about how the foundations of nix work (and enough Haskell), to reimplement all the basic stuff that nix does in Haskell as a sort of combinator library for building derivations, and then an interpreter for .nix files.
11:43:50 <monochrom> Does Nix have its quantum theory like Darcs does? :)
11:44:10 <srhb> monochrom: I think Eelcos thesis is that.
11:44:22 <byorgey> monochrom: even bettter: highest bidder wins, and 2nd highest bidder pays the 2nd highest bidding price.
11:44:28 <Younder> monochrom, well ate you a git?
11:44:30 <srhb> But I don't really think it related to the language.
11:44:41 <srhb> (Well, not very much anyway, aside from laziness)
11:44:55 <monochrom> byorgey: That is a scary scheme!
11:44:58 <Younder> I am lazy too.
11:45:05 <byorgey> =)
11:46:04 <Younder> monads after all lead to applicative code
11:46:31 <Cale> srhb: I've started to think of nix as a way of feeling good about concatenating together all your bash scripts
11:46:34 <Younder> ;)
11:46:41 <srhb> Cale: No comment. :-P
11:47:41 * hackagebot diagrams-contrib 1.4.1 – Collection of user contributions to diagrams EDSL – https://hackage.haskell.org/package/diagrams-contrib
11:55:08 <Unicorn_Princess> does anyone have some tips on how to implement findM :: Monad f => (a -> f Bool) -> [a] -> f (Maybe a)? Like, not the full solution. I'm at like the 5th version that type-checks, but gives wrong results.
11:55:58 <AWizzArd> The first code box in the „Motivation” section: https://ghc.haskell.org/trac/ghc/wiki/UnpackedSumTypes – what is that exclamation mark for?
11:56:31 <Cale> Unicorn_Princess: Are you just writing it recursively?
11:56:42 <Cale> That's what I would do
11:56:46 <monochrom> AWizzArd: See my http://www.vex.net/~trebla/haskell/strict-field.xhtml
11:57:14 <Unicorn_Princess> Cale: I'll try. been using foldr
11:57:59 <srhb> Short circuiting on foldr may be a little non-obvious at first.
11:58:04 <Cale> It's probably possible to write that using foldr, but it's trickier than it needs to be, since your function argument will be sort of complicated.
11:58:05 <srhb> Oh wait, that's not what you're trying at all.
11:58:08 <srhb> Nevermind :)
11:58:23 <srhb> Well, sorta.
11:58:46 <Cale> It's not so bad I guess
11:59:07 <Cale> But if you're struggling with it, just try recursively, and then stare at what you wrote, and *then* write the foldr
12:00:56 <jle`> Unicorn_Princess: what are the wrong results you get?
12:03:39 <Unicorn_Princess> jle`: "let p x = (\s -> (const $ pure (x == 'c')) =<< put (1+s)) =<< get in runState (findM p $ ['a'..'h']) 0" is supposed to be (Just 'c',3), but I get either (Just 'c', 8), (Just 'c', 128), or (Just 'c', 131), I think. anyway, will do the recursive solution first, then report back
12:04:42 <jle`> ah yeah
12:09:11 <Unicorn_Princess> writing it recursively worked \o/
12:10:21 <Unicorn_Princess> foldr must have been messing with me
12:16:06 * hackagebot concurrent-machines 0.3.1 – Concurrent networked stream transducers – https://hackage.haskell.org/package/concurrent-machines
12:19:01 <nick_h> srhb: Thanks for the offer of help from the community - I should have reached out earlier in the day.
12:19:11 <nick_h> ReinH: When you mean bounced off of nix, do you mean dropped it and gone back to stack?
12:21:57 <nick_h> monchrome: Ah - perhaps this is the problem text got installed with arch's cabal-install...
12:23:20 <monochrom> I think no.
12:23:38 <ongy> cabal-install from the repos pulls a few libs, which make things fail
12:29:28 <dreams> What is the profiling library for parsec called? I tried "cabal install parsec-prof" but no luck.
12:30:09 <geekosaur> that's not how it works; profiling is a build option
12:30:49 <geekosaur> cabal install --enable-profiling
12:30:50 <geekosaur> er
12:30:55 <geekosaur> cabal install parsec --enable-profiling
12:33:08 <dreams> geekosaur: thanks
12:33:17 <dreams> parsec-3.1.11 failed during the building phase. The exception was: ExitFailure 1
12:35:10 <AWizzArd> monochrom: thx
12:36:36 <geekosaur> dreams, you'll have to find the build log and put it on a pastebin
12:36:37 <geekosaur> @paste
12:36:37 <lambdabot> Haskell pastebin: http://lpaste.net/
12:37:02 <monochrom> It probably means that everything parsec depends on also needs to be rebuilt with profiling enabled.
12:37:34 <monochrom> http://www.vex.net/~trebla/haskell/cabal-cabal.xhtml#config  And bite the bullet.
12:39:03 <dreams> geekosaur: I've looked at the log and I'm running on a dependency hell right now.
12:39:50 <dreams> "It seems that you have not installed Y to install X" then "It seems that you have not installed Z to install Y"
12:41:12 <geekosaur> see what monochrom said, it is likely it is not finding the profiling libs
12:42:31 <dreams> monochrom: thanks
12:51:55 <nicootto> :t group
12:51:57 <lambdabot> Eq a => [a] -> [[a]]
12:53:13 <mizu_no_oto> dreams: have you tried using cabal new-build?
12:53:40 <mizu_no_oto> dreams: or sandboxes, for that matter
12:54:57 <nicootto> molo  =  map  head . group  .  sortBy  (flip  compare)
12:55:01 <nicootto> :t molo
12:55:02 <lambdabot> error: Variable not in scope: molo
12:55:06 <monochrom> What does new-build do for this?
12:55:23 <nicootto> :t  map  head . group  .  sortBy  (flip  compare)
12:55:25 <lambdabot> Ord b => [b] -> [b]
12:56:35 <mizu_no_oto> monochrome: while you need to make a myproject.cabal file, sandboxes and new-build solve most of the dependency hell problems people run into with cabal
12:57:20 <jle`> :t S.toList . S.fromList
12:57:21 <lambdabot> Ord a => [a] -> [a]
12:57:40 <monochrom> My "this" means specifically you already have a bunch of libraries installed with profiling disabled and now you regret it.
12:57:57 <monochrom> So, what does new-build do for specifically this?
12:59:04 <mizu_no_oto> new-build and sandboxes mean that you can fairly easily reinstall the world with profiling enabled 
13:00:22 <monochrom> So would I just enter "cabal new-build parsec" and THE END?
13:04:17 <cocreature> monochrom: with new-build you wouldn’t call "cabal new-build parsec" you would just add parsec to your build-depends, and then build your project with "cabal new-build --enable-profiling" and it will build the deps with profiling if they are not already present
13:07:11 <trigone> hi, i'd like to know what everybody does wrt comments: do you comment once you finish a function in a satisfatory manner, or only after finishing a whole module, or package?
13:07:39 <johnw> I follow no general rule, and comment when the mood strikes me
13:07:42 <trigone> or do you do it right while developping the functions, modifying it later if needed?
13:07:52 <trigone> johnw: well then when does it strike you?
13:07:56 <Tuplanolla> After each function, but only if I believe it's there to stay, trigone.
13:07:59 <johnw> all of the above mentioned cases
13:08:10 <johnw> there is no predicting when I will write a comment :)
13:08:35 <Tuplanolla> For me the only alternative to now is never.
13:09:49 <jle`> i comment as i go along becuase it helps me develop my code
13:09:57 <jle`> the next day i want to be able to look back on a function and remember why i wrote it
13:10:08 <jle`> at first it's a very brief comment just for me
13:10:13 <jle`> so when i render the haddocks there's something there
13:10:22 <hpc> i just want to be able to remember as i am writing it, even
13:10:27 <jle`> after the module/library is done then i go back and make it more "full"
13:10:58 <Rembane> I comment because I need to talk to myself when I code.
13:11:08 <Rembane> Interestingly enough, the more powerful the language, the less I comment.
13:11:49 <Tuplanolla> Starting with the user manual is a good idea.
13:12:03 <trigone> Rembane: well that's logical, the more powerful, the more descriptive: that means you can read the code and it's saying how, but what.
13:12:10 <trigone> Tuplanolla: user manual?
13:12:28 <trigone> jle`: do yu use haddocks for yourself?
13:12:43 <Tuplanolla> You might discover your idea is dumb before writing a single line of code, trigone.
13:12:48 <Rembane> trigone: Indeed, I don't have to wade through for-loops to get to the gist of it.
13:12:56 <trigone> *it's not saying how, but what i meant
13:12:58 <jle`> trigone: yes
13:13:06 <jle`> it helps me refer to type signatures
13:13:20 <jle`> and names, heh
13:13:32 <jle`> although really my IDE should be doing that for me
13:13:36 <monochrom> It is almost like asking "when you do take a sip of coffee".
13:14:03 <jle`> but i keep local haddocks of my projects/libraries updated as i write them
13:14:17 <trigone> Rembane: exactly, you don't need to compile the code in your head. in some way, descriptive programming is like the image of the actual consequences of the program, and it's transformed into the causes accordingly, instead of the opposite. it's like describing how the cookie taste instead of the complicated recipe that does not tell you how it will look
13:14:31 <trigone> a bit like drawing a picture of the result, like art...
13:14:44 <jle`> maybe it's a habit from using yard as a rubyist
13:14:46 <trigone> jle`: yeah, that would be good.
13:14:57 <Rembane> trigone: Indeed.
13:15:01 <trigone> monochrom: well then when do you breathe too while coding?
13:15:18 <trigone> jle`: what is yard?
13:15:34 <hpc> ruby haddock
13:15:57 <jle`> with yard you can launch a local server with automatically updated documentation
13:16:17 <trigone> jle`: you mean it waits for a file to change and reload documentation?
13:16:42 <jle`> yeah
13:16:58 <jle`> not a particularly ground-breaking thing, but it built in a habit for me
13:17:22 <trigone> to me that would not work well. i got this tendency to save my work everytime i pause, as in every symbol sometimes. still, with an appropriate way to reload it from the server manually... good idea
13:18:24 <trigone> is ruby's OOP better than the others? so many people seem to like ruby but i've never been good at OOP, too complicated to put things into objects for me...
13:19:12 <geekosaur> Ruby's OOP is basically Smalltalk's OOP; according to some it's more "pure" OOP
13:19:28 <hpc> i think ruby's OOP isn't that great, in that it's hard to really make OOP into something objectively pleasant to work with
13:19:39 <trigone> like JS, prototypes?
13:19:46 <hpc> ruby blocks are pretty handy though
13:20:01 <trigone> hpc: you mean compared to other OOP or just you mean OOP from whichever language, ruby included?
13:20:10 <hpc> OOP as a whole
13:20:39 <trigone> hpc: blocks are chunks of imperative statements? though that would mostly be functions in higher order fashion
13:20:46 <Tuplanolla> You can change the behavior of code by eliminating dead code around it or inherit a randomly chosen class, hpc. What is that if not object-disoriented?
13:20:49 <trigone> as in imperative functions
13:21:01 <hpc> blocks are sort of like a dual of do-notation
13:21:12 <trigone> Tuplanolla: i did not get what you meant to convey
13:21:19 <hpc> do-notation lets you (in some sense) override semicolons and assignment
13:21:37 <hpc> ruby blocks let you override name resolution on functions
13:22:05 <hpc> a block is a chunk of code (that optionally can take parameters)
13:22:09 <trigone> hpc: you mean it allows ad-hoc polymorphism like do-notation does not depend on the monad?
13:22:38 <hpc> soooooooort of
13:22:40 <trigone> hpc: ah no i get it i think, i remember: you pass automatically the previous result to the next function, right?
13:22:50 <trigone> so you don't need temporary variables
13:22:55 <hpc> technically yes, because ruby is dynamically typed and you can make anything not depend on anything
13:23:05 <hpc> but technically also no because without types it's not really an abstraction
13:23:21 <hpc> here's an example
13:23:27 <hpc> foo |x| do
13:23:29 <hpc>   bar x
13:23:30 <hpc> end
13:23:54 <trigone> hpc: yeah it's more like anything is permitted and if you don't do it correctly it fails on runtime or gives out absurd results
13:24:01 <trigone> bar would be what here?
13:24:07 <hpc> some other library might define foo so that when it executes the block, x is read from stdin, and bar is printing to stdout
13:24:27 <hpc> in the block, bar is "this.bar"
13:24:35 <hpc> implicitly
13:25:06 <trigone> so it's a bit like monads indeed, where the "input" underlying state is, well dependent on where you call it.
13:25:09 <nshepperd_> Blocks sound like "\x y -> do ..." except only for IO
13:25:49 <hpc> nshepperd_: plus the thing you pass the block to gets to define things in the scope of that block
13:25:54 <trigone> hpc: oh of course, yes, it's like JS's ability to call any method with your desired this-object ... with an efficiency price though
13:25:57 <hpc> yeah
13:26:41 <hpc> javascript's way of doing it is more awkward because you have to apply((function(){}))() everywhere, but you can do the same thing
13:26:50 <trigone> so it's like methods that you call on objects, but i guess you'd call them at a place that would not require you to specify the object, otherwise there's no benefit from usual functions
13:27:22 <trigone> hpc: you mean the awkward way to make anonymous functions?
13:27:39 <hpc> the awkward way to make anonymous functions plus the additional awkward way you have to force the value of this
13:28:21 <trigone> yeah... well i guess there are ways to trick the system but the result would be as unreliable and probably slow as most interesting things in js.
13:28:50 <trigone> still, what would be everyone's best OOP language, *if you had to choose*?
13:29:19 <hpc> definitely perl
13:29:38 <yushyin> Simula67
13:30:27 <trigone> hpc: i heard perl was too easily obfuscating because too many things added to the language... but then that matters only when reading others' scripts. what's perl take in OOP?
13:31:15 <trigone> if i've heard correctly, you can use methods as normal functions with first parameter being the OOP object, like in JS, and, i believe, python?
13:31:27 <hpc> it's more that perl exposes so much of itself that understanding a language feature requires understanding the implementation
13:31:34 <hpc> which... extends greatly to its OOP
13:32:00 <trigone> which allows relative interpolation between functional and OOP, though it's mostly a question of notation at this stage, and that does not really matter then.
13:32:01 <hpc> an object is a "blessed" hash
13:32:08 <hpc> as in it has the bless keyword applied to it
13:32:19 <trigone> hpc: i don't get it. you mean most tools are in libraries rather than built-ins?
13:32:50 <trigone> hpc: well that tells me nothing i can understand :P i'm not sure i'm ready to convert to a new programming religion...
13:33:09 <trigone> to me bless is a hex editor
13:33:18 <hpc> i wouldn't recommend "converting" to ruby
13:33:30 <hpc> i would recommend learning perl as a test of your ability to keep track of multiple things at once
13:34:23 <hpc> trigone: come to -offtopic and i will give you an example
13:34:53 <trigone> sorry i don't know what that means, i'm new to irc
13:35:08 <hpc> /join #haskell-offtopic
13:35:09 <geekosaur> /join #haskell-offtopic
13:35:33 <trigone> thanks, i'll try, as i'm on webchat.freenode.net (the website)
13:35:48 <yushyin> hpc: fyi an object is a blessed ref to a builtin datatype, it doesn’t need to be a blessed hashref
13:35:51 <geekosaur> yes, it supports that
13:36:05 <hpc> yushyin: ah good point
13:47:02 <johnw> yushyin: for a moment I thought I was in #perl
13:49:44 <grayhatter> is there a way to make sure code runs?
13:49:53 <grayhatter> when it's supposed to be?
13:49:55 <grayhatter> err
13:50:03 <grayhatter> when I expect it to*
13:50:15 <monochrom> Lower your expectation.
13:50:22 <grayhatter> lol
13:50:26 <yushyin> johnw: sorry, I didn’t want to scare you
13:50:46 <monochrom> More seriously and frankly I don't see how willpower can change reality.
13:51:20 <monochrom> To get code to run, you don't expect, you reason and fix.
13:51:32 <Gurkenglas> lpaste's down?
13:51:44 <buff3r> what about https://wiki.haskell.org/Performance/Strictness#Explicit_strictness
13:51:45 <buff3r> ?
13:51:45 <ReinH> Ruby blocks are, imo, a hold-over from a time when the language didn't have a reasonable syntax for anonymous functions. They are essentially syntax for anonymous closures that can only be used in certain places.
13:52:33 <Gurkenglas> (back now, huh)
13:52:34 <ReinH> I think Ruby would have benefitted more from first-class anonymous closures in the beginning.
13:52:44 <monochrom> Ruby probably inherited blocks from Smalltalk.
13:52:47 <grayhatter> monochrom: I'll give you an example
13:52:58 <ReinH> monochrom: Yes, but blocks in smalltalk were better.
13:53:03 <monochrom> Ah.
13:53:03 <ReinH> As were named arguments.
13:53:14 <ReinH> Ruby blocks are just anonymous closures with a restricted syntax.
13:53:34 <monochrom> Yes every young designer has to butcher good old wisdom, no?
13:53:36 <grayhatter> say I wanted to run the init code on my car's brakes, you know sanity checks and all that. That code wouldn't be called until I stepped on the brakes
13:53:40 <grayhatter> does that seem right?
13:54:27 <Tuplanolla> No; that's weird, grayhatter.
13:54:39 <monochrom> I don't know cars.
13:54:56 <johnw> grayhatter: there are ways to ensure properties of code
13:55:05 <monochrom> But go ahead change the code to your liking.
13:55:07 <johnw> grayhatter: there's no way to ensure how it will interact with physical reality, however
13:55:46 <recursion-ninja> when I build a project with ' stack build --ghc-options="-ddump-splices" ', where do the splices get dumped?
13:55:50 <johnw> grayhatter: I can verify that an algorithm will only stop the brakes when asked to, but I can't ensure that you've connected the initiator to the braking system correctly
13:56:16 <grayhatter> johnw: haskell dosen't offer that ablity by design then?
13:56:38 <johnw> that's really what types do, and the more expressive your types, the more you can determine the behavior of an algorithm
13:56:52 <johnw> but it's just an internal verification
13:57:45 <ReinH> monochrom: for one thing, blocks in Smalltalk were objects. You could say c := [:x | x + 3] and call it with c value: 3 to get 6. Blocks in Ruby are not objects. c - {|x| x + 3} is a syntax error.
13:58:05 <ReinH> s/c -/c =
13:58:19 <monochrom> Oh that's a shame.
13:58:46 <ReinH> You can instead say c = Proc.new {|x| x + 3}, which instantiates a Proc object using the given block.
13:58:52 <monochrom> Can't give a name to a perfectly vanilla subexpression eh?
13:59:28 <monochrom> My gripe with Java too compared with Haskell on the aspect of creating data.
14:00:13 <ReinH> monochrom: Ruby also has 3 different kinds of anonymous closure (blocks, procs, and lambdas) with subtly different semantics.
14:00:14 <monochrom> Haskell "x = Right (Just 4)" --> Java "x = new Right(new Just(4))" new this new that nuke it all already.
14:01:12 <monochrom> Was Ruby designed by a committee?!
14:01:15 <geekosaur> 'newk it'
14:01:32 <systemfault> monochrom: I'd probably write a static factory method to avoid the "new" if I was writing monads in Java... x = Either.of(Maybe.of(4))
14:01:56 <ReinH> monochrom: It was designed by someone who did not have a formal education in PLT. It's actually surprisingly decent to work with for all that.
14:02:43 <ReinH> The underlying object model is relatively elegant, being largely ported from Smalltalk.
14:02:47 <buff3r> PLT?
14:02:53 <johnw> programming language theory
14:03:11 <buff3r> gotcha
14:03:31 <monochrom> systemfault: Does Either.of give me Left or give me Right? :)
14:04:02 <systemfault> I'd say... A right but it's up to you I guess :)
14:04:20 <johnw> if it's your monadic constructor, then X.of() should be return, no?
14:04:40 <systemfault> Hmm, right
14:04:46 <monochrom> OK, I guess.
14:05:28 <monochrom> But I did not have monads in mind. (Who would dare.) I merely had ADT in mind.
14:07:10 <monochrom> In the ADT farm, all data constructors are equal, but some are more equal than others.
14:07:48 <johnw> John Major constructors?
14:08:32 <johnw> McBride really has an excellent sense of humor :)
14:08:51 <ReinH> He really does.
14:10:28 <monochrom> Which paper was that?
14:10:49 <johnw> "Elimination with a motive"
14:11:18 <johnw> presented at TYPES 2000
14:11:40 <hpc> that sounds like the sequel to johnny mnemonic
14:12:22 <MarcelineVQ> johnw, ReinH: It's quite nice in general for many haskell papers to have playful attitudes, I've been reading papers from other fields recently and it's quite dry by comparison, and oddly repetative in that a single paper might say the same thing 3 times in slightly different ways.
14:14:11 <kuribas``> ruby is ok as a better perl
14:14:11 <MarcelineVQ> It's seemed to be that in many haskell, and related, papers you'd say it once in a math-technical way and perhaps once in a ML-like psudo-code way and you've covered your bases. Not that it's neccesarily easier to understand, but it's less crufty
14:14:18 <MarcelineVQ> *seems to me
14:17:23 <alios> hi! having a problem installing cabal-install via stack on freebsd-11. Basic setup: stack+ghc-7.10.2 from port, used stack to install ghc-8.0.2. global project is 
14:17:26 <alios>                set to lts-8.19. when trying to "stack install cabal-install" (I need cabal-install >= 1.24) it fails while compiling hackage-security-0.5.2.2. I guess because for 
14:18:35 <MarcelineVQ> you were cut off at " I guess because for "
14:18:52 <alios> ... some reason it calls the clang ld and not the gnu ld? https://gist.github.com/alios/06072c6b1df36aea9d8a10f20c12ac14
14:20:25 <geekosaur> I don't think there is a difference?
14:20:43 <geekosaur> but that stops at file 34 of 42, now I wonder if this is TH related
14:21:46 <MarcelineVQ> alios: just as a precheck, what version of stack do you have?
14:22:12 <geekosaur> mm, no, no TH in the source file
14:22:40 <alios> the called (clang) linker does not understand the build-id cmd line opt ...  "/usr/bin/ld: unrecognized option '--build-id=none'"
14:23:02 <alios> MarcelineVQ: Version 1.4.0 x86_64
14:23:17 <MarcelineVQ> I see that should be plenty recent enough for freebsd
14:24:05 <MarcelineVQ> though there is a note for 1.4.0_1, I'm not sure it's related though, you may want to  stack upgrade --git  just to be sure
14:24:27 <alios> MarcelineVQ: will try thnx!
14:24:29 <MarcelineVQ> doing this places the new stack in  .local/bin
14:24:48 <MarcelineVQ> <home>/.local/bin  I​ mean
14:25:33 <alios> MarcelineVQ: should work fine ./local/bin is in the very beggining of the PATH
14:26:20 <MarcelineVQ> good stuff, I'm not convinced it'll help but its worth trying
14:29:22 <alios> i really love stack ... use freebsd ports to bootstrap an base ghc-7/stack env in /usr/local ... from thereon build the dev env in $HOME/.stack-work 
14:31:19 <alios> MarcelineVQ: lol .. the "stack upgrade --git" failed with the same error when compiling hackage-security as package 143/178
14:32:52 <duog> Hi all, in my haskell program I need do find the location of the shared library of one of my cabal dependencies, is there a simple way to do this?
14:33:07 <MarcelineVQ> well now that's interesting, two options that come to mind now are to try the 1.4.0_1 ports version here  https://www.freshports.org/devel/stack  and/or consider opening a ticket at https://github.com/commercialhaskell/stack/issues in that case please in case there's an easy fix or it's an issue that could help others
14:34:12 <geekosaur> duog, are you sure it has one? usually haskell libraries are static
14:34:21 <MarcelineVQ> not sure what happened to the end of that sentence, but it should be readable ehe
14:34:57 <duog> geekosaur: yes I am building a shared library, I need it to load it as a sqlite extension lib
14:36:40 <trigone> i was just reading some (pseudo?) standard ML. there was this thing called signature (more or less like data+operations associated) and there was the possibility to put exceptions in it
14:36:50 <geekosaur> ghc-pkg field thepackagename dynamic-library-dirs
14:37:12 <trigone> has there been implementations of exceptions as polymorphic values? actually they should depend on the function calling, so, not sure it's doable
14:37:30 <trigone> meaning, there would be one exception Empty, but 
14:37:56 <trigone> if you call it say with head you get a different instance than say with.... i dunno, another function that could raise such
14:38:36 <alios> MarcelineVQ: thnx will follow that path :) 
14:38:46 <trigone> mind you i don't mean exceptions like the things you have to catch and so on, the ideal would be to connect it with Either
14:39:29 <trigone> i don't really know how errors (rather than exceptions) are handled in haskell. are there typeclasses relative to it?
14:40:29 <duog> geekosaur: thanks!
14:40:34 <trigone> and i'm not sure you could have a "function" that would take a function and return an appropriate error value depending on the implementation
14:40:59 <alios> MarcelineVQ: oh btw ... the version info I gave above was from "stack --version" ... The installed port is 1.4.0_1
14:41:29 <trigone> sorry, depending on the instanciation of the function Fn -> Error by the function. anyway you can't use functions as if they were types...
14:42:28 <trigone> the most approaching would be indeed values in typeclasses along the corresponding functions... but then you could not have a type class ErrorHead, could you? i think i'm losing myself
14:42:42 <trigone> sorry, not ErrorHead, ErrorEmpty
14:43:17 <trigone> or maybe ErrorImpossibleToGet that could also apply to trying to reach a value with an inexistent key, etc
14:43:24 <Cale> trigone: Exceptional cases are handled in almost too many ways in Haskell -- though they all have their reasons
14:43:49 <MarcelineVQ> alios: alrighty I'd open a stack git ticket then, there is a stack channel on irc but I'm not sure I've ever seen a dev repond there
14:44:35 <Cale> trigone: First of all you have types like Maybe and Either. Maybe t is for things which can fail in an essentially unique way denoted Nothing, or else succeed with some value x of type t, denoted Just x.
14:44:48 <trigone> Cale: ok, let's do simpler, what's then your preferred methods? aside from trying never to have errors to report, which is always better...
14:45:08 <Cale> Either e a is similar, but where you have Left err, for some err of type e, or else Right x for some successful result x of type a.
14:45:42 <trigone> Cale: yeah i know about Maybe and Either, my thoughts were about how to report the special content of the error: it could be a string, but the best would be to isolate the error value from the function (at the very least to put it in a where clause)
14:45:44 <Cale> Those are what you use when the expectation is that the error will not be ignored for long.
14:46:29 <ublubu> is there a way to output comments with haskell-src-exts? i'm trying to generate some haskell code
14:46:39 <trigone> i think it's messy to put the content of the value directly as a string/whatever in a Left container and right in the middle of the code...
14:46:51 <Cale> It doesn't need to be a String
14:47:11 <Cale> But I have used my fair share of Either Text
14:47:31 <Cale> Sometimes, just the message you're going to report to the user is exactly what you need
14:48:06 <trigone> Cale: yes, i know... ok, my thought is: how to abstract the error to have the same value ErrorImpossibleToGet even if it's not the same function... lol i think i just answered myself: using enumerations seems cleen
14:49:13 <trigone> the only issue with enumeration: to translate the Constructor into a string or whatever more useful, you'd need a function ErrorValue -> whatever, and that would mean the actual translation of the errors would be handled at one place only
14:50:09 <Cale> The decision between using something like String or Text and using an enumeration should be based on whether you ever expect to pattern match or make any sort of decision based on the error.
14:50:40 <trigone> decision using String/Text descriptions of error?
14:50:43 <Cale> But it's not difficult to provide a function like  myErrorText :: MyError -> Text
14:51:20 <trigone> Cale: yes, but it's not polymorphic, but i'm not sure i'm very clear... i think instead of a data Error, i'd need a class that would contain values to be instanciated...
14:51:22 <Cale> Yeah, if your program is going to behave differently (apart from displaying a different message) based on what the error was, you don't want to use Text for that
14:51:48 <Cale> But if you're only displaying a different message, there's no point in making up a sum type.
14:52:17 <trigone> Cale: ok i got what you meant earlier, it's not pattern match vs decision, you meant it as synonymous
14:52:26 <trigone> sum type?
14:52:31 <Cale> This is sort of in general true: if you're defining a type and you can't imagine writing a case expression pattern matching on all the constructors, probably the thing you're defining should not have those constructors
14:52:34 <trigone> oh right A | B | C
14:53:45 <Cale> As a case in point: http://hackage.haskell.org/package/font-awesome-type-0.1/docs/Web-FontAwesomeType.html -- this type would be much better off just being a newtype wrapper around Text, along with a bunch of predefined constants
14:54:33 <Cale> Why? Because 1) nobody is ever going to write a pattern match against all those cases, and 2) it requires patching the data type if there are new icons in the future
14:56:14 <Cale> (and in fact, there are new icons not supported by that type)
14:58:07 <Cale> Well, I say that, but there happens to be a pattern match in that file. ;)
14:58:13 <trigone> Cale: yes i agree :) in fact that's because the functions manipulating the icons should be blind to the actual icon. only some limited traits should require an enumeration, if the functions sometimes care about said traits
14:58:32 <trigone> Cale: i think they only pattern match on subsets of that gigantic enum, do they not?
14:58:41 <trigone> subsets = subtraits
14:58:45 <trigone> i mean traits
14:59:01 <Cale> No, the whole thing gets matched for  fontAwesomeClass and then again for fontAwesomeChar
14:59:46 <Cale> Rather than just defining something like  data FontAwesome = FontAwesome { fontAwesomeClass :: Text, fontAwesomeChar :: Char }
14:59:53 <trigone> haha i'd say they're pretty masochists... that would be much better put in a json or a database
15:00:11 <Cale> No need to put it in JSON, but at least break it up into one definition per icon
15:01:02 <trigone> Cale: yeah. i think the problem here is indeed the choice of factoring
15:01:07 <Cale> yep
15:01:20 <trigone> i can't reach the sourcecode?
15:01:26 <Cale> http://hackage.haskell.org/package/font-awesome-type-0.1/src/Web/FontAwesomeType.hs
15:01:32 <jle`> what's the simplest way to get haskell to print integers using comma separators?  like 1,345,012
15:01:33 <Cale> I don't know why the source links don't work
15:02:23 <trigone> how can you tell they're pattern matching then if you don't have access to the source either? maybe the functions are utterly polymorphic on the input of icon 
15:02:50 <trigone> however... i do believe the second function at least would require pattern match
15:03:00 <geekosaur> > (reverse . intercalate "," . chunksOf 3 . reverse . show) 1345012
15:03:02 <lambdabot>  "1,345,012"
15:03:03 <Cale> ^^ I did look at the source (see the link I just gave)
15:03:17 <Cale> However, I can also tell that because there's no other way you could do it
15:03:24 <jle`> chunksOf from that utility package, right?
15:03:31 <jle`> i guess it's simple enough
15:03:38 <geekosaur> split package, yes
15:03:54 <dreams> how do you tell what PINNED is on a heap profile.
15:03:59 <Cale> Now what's the easiest way to do it which will be cross platform and respect the user's locale?
15:04:07 <trigone> Cale: yeah, at least for the char function (for the class function, it could just use show to transform it into string)
15:04:19 <Cale> (to insert separators as appropriate while formatting a number)
15:05:07 <Cale> trigone: I suppose it could, and then it would need to change it from CamelCase to snake-case
15:05:13 <Cale> But that's doable
15:06:02 <trigone> Cale: yeah, depends on the actual content of the function... there is one non-negligible advantage to those impracticable enums
15:06:33 <trigone> basically you have the biggest incentive possible in trying to make your function work without pattern matching, regardless of the specific content of the values passed :P
15:07:33 * hackagebot yi-rope 0.9 – A rope data structure used by Yi – https://hackage.haskell.org/package/yi-rope
15:07:34 <trigone> though it was not enough for that haskell writer... i was very disappointed when i realized you could do a lot of very bad code in haskell (i realized that a while ago, not just now)
15:08:51 <Cale> trigone: For sure, it's possible to out-perl perl
15:09:08 <trigone> Cale: lol what do you mean?
15:09:32 <Cale> http://hackage.haskell.org/package/regex-base-0.93.2/docs/Text-Regex-Base-RegexLike.html#t:RegexContext
15:10:26 <Cale> Mostly meaningless type classes that pick between a whole bunch of functions based on the type of result you ask for
15:10:56 <Cale> At least with perl, there's like 3 types or whatever
15:11:04 <trigone> Cale: you mean it's an example of bad coding? or is it part of the conversation about locale number separators?
15:11:23 <Cale> This is an example of... well, let's just say questionable choices
15:12:04 <trigone> yeah indeed wow that's weird... never seen as many instances except when defining all at once for a particular abstract concept (monads, etc)
15:12:04 <Cale> It's very unnecessary for those match functions to all be called 'match'
15:12:12 <geekosaur> it's an example of 'out-perl-ing perl'
15:12:58 <Cale> and at least in this version of the library, they have the newtypes to help distinguish what the heck it is you're asking for
15:13:10 <Cale> In earlier versions, it was sort of hard to tell
15:13:48 <trigone> Cale: how do you know about them, do you use them? or did you just want to see how they were doing it?
15:13:58 <trigone> how they specifically had chosen doing it
15:14:05 <Cale> I've tried this library -- a long time ago
15:14:25 <Cale> I basically wouldn't bother using regex libraries for anything other than implementing user-facing regular expressions now.
15:14:41 <Cale> Combinator-based parsing or bust!
15:15:48 <trigone> by the way, is there any good book about pure, lazy (functional) and efficient data structures? i'm reading purely functional data structures by chris okasai, but everything is in standard ml and i barely know a thing about it
15:16:02 <trigone> Cale: you mean so you can transform user-given strings into parsers?
15:17:01 <Cale> trigone: Yeah, if the requirement for my program was that it's able to take a regular expression input by the user, and do some matching with it, I would consider using a regex library then.
15:18:04 <Cale> I might also use *actual* regular expressions if I had very stringent requirements on parsing performance (and so wanted to compile to a DFA representation)
15:18:40 <trigone> DFA?
15:18:40 <Cale> But most of the regex libraries do this "perl compatible" stuff which precludes such efficient algorithms anyway.
15:18:48 <Cale> Deterministic finite automaton
15:19:09 <trigone> i don't know as much about regexes to tell the truth, but i trust you on the word
15:19:35 <colonelj> in the language I'm designing I made up my own regex format :P
15:19:40 <ggVGc> it's intersting how highly irregular regex implementations are
15:19:46 <colonelj> allows you to recursively call other regexes :D
15:19:50 <ggVGc> ^ point
15:19:58 <Cale> hah
15:20:02 <geekosaur> have you seen perl 6 regexes yet?
15:20:11 <geekosaur> and grammars?
15:20:14 <colonelj> I've heard about them
15:20:18 <colonelj> pretty old news that
15:20:54 <Cale> Yeah, I saw that stuff back when perl 6 was getting its first implementation in Haskell. :)
15:21:06 <trigone> ggVGc: you could not be truer... honestly the #1 issue with computers is above all compatibility...
15:21:36 <trigone> colonelj: you mean, using variables to insert into other variables?
15:21:45 <trigone> i mean to insert into other regexes
15:22:00 <colonelj> yeah you can insert code quotations into the regex
15:22:00 <ggVGc> sounds a lot like PEG
15:22:04 <ggVGc> which I like a lot more than regex
15:22:20 <Cale> But yeah, there's not much reason that parsers shouldn't usually be first class values -- it's so easy to build a library for that once you know how.
15:22:20 <colonelj> it's pretty much the same as PEG except still allowing normal alternations with backtracking as an option
15:22:25 <ggVGc> unfortunately almost nothing has mature PEG implementations
15:22:33 <colonelj> what do you think of PEG.js?
15:22:54 <ggVGc> I think I've looked at it briefly at some point but don't really have an opinion
15:23:11 <ggVGc> I've really only used lpeg for actual work
15:23:16 <Cale> You can whip up a parser combinator library using monad transformers in like a couple dozen lines, if the ones which already exist don't quite suit your needs.
15:23:17 <colonelj> the problem is I want to parse python style indentation (or I guess haskell style too)
15:23:24 <trigone> isn't PEG the principle of parsers used in haskell?
15:23:29 <ggVGc> I tried something in python at some point but didn't like it at as much as lpeg at all
15:23:33 <Cale> trigone: more or less
15:23:43 <trigone> Cale: better or worse?
15:24:00 <trigone> is PEG doable in haskell?
15:24:07 <Cale> sure
15:24:15 <Cale> It's just that formally, it's a bit of a different thing
15:24:37 <trigone> PEG looks like adding the features of variables and functional functions
15:24:48 <trigone> Cale: formally?
15:25:36 <Cale> Well, a PEG is about describing a language. Most parser combinator libraries give you parsers that not only accept or reject a string, but produce a result while they're at it.
15:26:09 <trigone> hm... but then PEG could be seen as defining the subset of haskell that is limited to what the parser can do, correct?
15:26:42 <trigone> what i mean is, if you do a parser in functional style, won't it be PEG automatically? if not, what is the difference?
15:26:55 <trigone> i mean a parser library
15:27:20 <trigone> or built in parser functions why not
15:27:37 <colonelj> you're not really making sense, there are different kinds of parsers
15:28:20 <colonelj> Cale: PEG.js does that
15:28:36 <colonelj> as does the recursive regex in my language
15:28:36 <trigone> colonelj: never pretended to make sense. i only know a little about haskell parsers, and i just read a bit of PEG right now
15:28:57 <trigone> colonelj: does not stop me from trying to get the abstract differences and underlying concepts :P
15:29:45 <colonelj> well PEG doesn't have backtracking so it's kinda unusual
15:29:51 <trigone> producing a result: is it more or less than the regex options of returning matches?
15:30:15 <colonelj> the results don't have to be strings they could be ASTs or something
15:30:45 <trigone> colonelj: yeah but that's up to whatever monoid you give to it... or at least i guess that could be separated from the parser
15:31:08 <trigone> oh wait AST, i'm not sure to know what that is
15:31:21 <trigone> oh right a tree
15:31:25 <colonelj> abstract syntax tree
15:31:46 <colonelj> but there's not even any requirement that the different parts parse to compatible types
15:32:01 <colonelj> I'd guess haskell may limit you in that way
15:32:36 <trigone> really? if you need polymorphic types in a tree it's doable with a multiconstructor data, no?
15:32:42 <colonelj> I must confess I don't know much about parsing in haskell
15:33:11 <colonelj> yeah but you might need infinitely many constructors or something :P
15:33:40 <trigone> colonelj: hm no i don't think so... but maybe we don't speak of the same thing.
15:34:03 <colonelj> yeah it's probably not a serious limitation for any practical purposes
15:34:04 <trigone> "different parts parse to compatible types" -> can you reformulate
15:34:13 <AerialBoundaries> I'm looking for a graphics library to draw fractals with, specifically iterated function system fractals (using defined shapes rather than an equation for each pixel: think koch's snowflake, but not the mandelbrot set). I guess a vector library would be best?
15:34:47 <colonelj> what you said with multiple constructors in some umbrella data type would work
15:35:13 <trigone> colonelj: then why the need for infinitely many constructors?
15:35:45 <colonelj> so that you're not limited by the definition on what things you can have as output
15:35:49 <trigone> you only ever have so many cases to parse (as in, any language you parse has a limited grammar)
15:36:16 <colonelj> yeah if you're parsing an AST or something you're not going to have this problem
15:36:39 <trigone> colonelj: what could you parse that you'd not know statically what you'd get as possible output?
15:37:08 <trigone> that would imply a parser that would literally plan for what it does not know statically... i don't really conceive it
15:37:09 <colonelj> idk deserializing objects or something
15:37:35 <colonelj> like some ORM encoded in JSON or whatever
15:38:26 <colonelj> maybe it's XML and you have to download a schema to understand what you're parsing
15:39:02 <colonelj> so the structure of the grammar isn't exactly fixed
15:39:28 <johnw> something I will never achieve: remembering the difference between intersperse and intercalate
15:39:29 <trigone> colonelj: you mean... you'd want a parser that would take as argument instructions on what to parse? well that's exactly the idea of a parser taking a random monoid (or whatever typeclass), and creating the output regardless of the actual final structure
15:40:30 * hackagebot array 0.5.2.0 – Mutable and immutable arrays – https://hackage.haskell.org/package/array
15:41:10 <trigone> colonelj: in fact, the xml grammar IS fixed, but XML is also allowing the representation of new concepts. like haskell's grammar is fixed but you can create types: it's just not at the same level of staticity
15:41:26 <trigone> what's hackagebot?
15:41:41 <Tuplanolla> It's easy, johnw: `intersperse` contains "perse", which is Finnish for ass, so it's the less powerful of the two.
15:42:03 <colonelj> johnw: hah, now you'll never forget again
15:42:51 <nshepperd_> :t intersperse
15:42:52 <lambdabot> a -> [a] -> [a]
15:42:59 <colonelj> arguably an ass is quite powerful, they do a lot of hauling stuff around
15:43:05 <colonelj> idk what you're comparing it to
15:43:39 <trigone> colonelj: i get what you mean though... the parser should create types basically dynamically... as in, depending on what xml it inputs, the output would need to differenciate the different words. but indeed in haskell types are fully static. the best is to put a string representing the type of the virtual language defined by the xml document
15:43:42 <nshepperd_> :t intercalate
15:43:43 <lambdabot> [a] -> [[a]] -> [a]
15:44:12 <colonelj> :t transpose
15:44:14 <lambdabot> [[a]] -> [[a]]
15:44:20 <johnw> for all those who love to golf: https://github.com/jwiegley/notes/blob/master/haskell/ObjectsArrows.hs
15:44:34 <johnw> this code takes forever to tell me how many composable pairs exist in a 100 object category
15:44:42 <trigone> intersperse to me implies to explode first something and then add stuff, whereas you could intercalate a discreet interval of numbers with other values
15:44:45 <colonelj> golfing is a bit lame nowadays when there are specialized languages for it
15:45:00 <nshepperd_> Could intercalate be generalised to Monoid m => m -> [m] -> m
15:45:19 <johnw> well, I'd also like to find the simplest formulation of that algorithm, so that I can prove it correct
15:45:27 <pikajude> nshepperd_: yes
15:45:31 <johnw> an efficiency version that I can show refine to is a bonus
15:45:40 <johnw> refinement to*
15:45:40 <nshepperd_> Seems like it would be clearer that way
15:46:05 <Tuplanolla> Can you also slap `Foldable` on it, nshepperd_?
15:47:02 <nshepperd_> :t \d -> fold . intersperse d
15:47:03 <lambdabot> Monoid c => c -> [c] -> c
15:47:26 <Tuplanolla> Is this not in OEIS, johnw?
15:47:31 <johnw> OEIS?
15:47:42 <trigone> Sometimes i wonder: what if we invented a language with no types, and everything is just either typeclass instances or sets of them, and actual types are basically very rare because when making functions you only need what typeclasses the types instanciate, not the actual types themselves
15:48:00 <Tuplanolla> @google sloane oeis
15:48:02 <lambdabot> https://oeis.org/
15:48:06 <trigone> iot: to focus on what the functions need to know in priority...
15:48:43 <colonelj> a.k.a duck typing extreme edition
15:48:53 <colonelj> have a typeclass for every possible method
15:49:03 <trigone> colonelj: well yeah... well no...
15:49:09 <nshepperd_> T
15:49:14 <trigone> ok, you're right, i dunno...
15:49:31 <colonelj> reminds me of how C++ templates work
15:49:43 <trigone> it's true, to some extent it's like in natural languages, you don't need to care about every isolated trait beyond the combinations that actually exist
15:49:48 <johnw> Tuplanolla: the series is this: https://en.wikipedia.org/wiki/Centered_triangular_number
15:50:08 <johnw> so I have an easy formula to compute what the length should be
15:50:34 <trigone> if all functions ever used only used one type, creating a typeclass would be absurd pragmatically
15:50:36 <nshepperd_> trigone: in haskell things get very difficult when you abuse typeclasses too much, so...
15:50:49 <Tuplanolla> I was hoping there would be an existing mapping in literature, which would have been cited in OEIS, johnw.
15:51:13 <johnw> I don't know the terminology by which to search for it
15:51:18 <johnw> only the current expression of the problem
15:51:45 <Tuplanolla> Type in the sizes of the first few cases you've calculated, johnw.
15:51:57 <trigone> nshepperd_: yes, it's like trying to use the most minimal vocabulary to describe everything. like saying "solid surface" instead of table just because in the sentence it's all that matters.
15:52:16 <Tuplanolla> Here: https://oeis.org/A005448
15:53:05 <Tuplanolla> There seems to be no mention of categories, graphs or networks, unfortunately.
15:54:17 <trigone> is there a type for double-ended lists? implemented as two lists representing more or less half the whole list each? because that would be cool... even reversing it would be as trivial as reversing the 
15:54:25 <trigone> reversing the two sublists
15:55:07 <johnw> Tuplanolla: excellent, thanks
15:55:12 <jle`> trigone: there's Seq, which is O(1) to pop/cons from either end
15:55:40 <jle`> reverse is still O(n) though
15:55:48 <jle`> s/Seq/finger trees
15:55:53 <johnw> Tuplanolla: that's the series of the lengths of the lists I'm generating for each 'n'
15:56:05 <johnw> I want a better algorithm for producing those lists
15:56:25 <trigone> jle`: and so, do you recommend its use? what is that sed-like replacement of Seq?
15:56:32 <trigone> did you mean finger trees?
15:56:56 <jle`> finger trees is the name of the ADT, and Seq from 'containers' is the canonical implementation in the haskell ecosystem
15:56:57 <trigone> jle`: reverse as O(n): well i don't get that
15:57:12 <trigone> jle`: ok...
15:57:24 <jle`> it's not quite a linked list that stores both halves
15:57:30 <jle`> http://hackage.haskell.org/package/containers-0.5.10.2/docs/Data-Sequence.html
15:58:06 <trigone> jle`: yeah i know otherwise to pop past one of the halves would require computing the whole second half
15:58:07 <Tuplanolla> It looks like you're on your own then, johnw.
15:58:25 <johnw> Tuplanolla: sniff
15:58:56 <trigone> jle`: is it more like two separate lists that represent both the whole list?
15:59:13 <jle`> trigone: ah, and yeah, s/blah/blah is kind of the common way to correct typos in irc
15:59:13 <trigone> jle`: as in, that represent it in the other direction
15:59:36 <trigone> jle`: got it, i assumed so
15:59:40 <jle`> implementationally, it's kind of like a container structure that has "fingers" to both ends for fast access
15:59:57 <trigone> jle`: i think it's more like a cosmonaute suit :P
16:00:05 <jle`> https://en.wikipedia.org/wiki/Finger_tree
16:00:56 <jle`> also O(log(n)) concatenation so that's neat too
16:01:04 <confusedFunctor> Hi! I'm trying to capture an invariant that a number should be within a certain range (1-32). What's the best way to do this?
16:01:22 <jle`> you mean, as a part of the type?
16:01:32 <confusedFunctor> I can think of LiquidHaskell, and Type Level Naturals. But not sure which would be a better approach, of if there's a better approach.
16:01:40 <jle`> there's no canonical way to do this, but there a couple of ways to go
16:01:49 <confusedFunctor> Yes. As part of the type would be nice. An external tool like an SMT solver would do as well.
16:02:00 <colonelj> assert(x >= 1 && x <= 32)
16:02:13 <trigone> jle`: but seriously, why is reverse so slow? i mean if you need to reverse but you still want to keep everything lazy? what's the very point anyway to reverse if you can reach things from both ends? aside from reversing a strict double-ended list of course
16:02:44 <colonelj> for reversing you could just set a flag to say which end is the front
16:02:44 <jle`> confusedFunctor: there are some libraries (like refined) that let you use type-level nats and runtime checking/smart constructors
16:02:52 <jle`> liquid haskell might be a 'smarter' way
16:02:53 <trigone> colonelj: yeah that's what i meant
16:03:07 <jle`> there might be a Word5 type somwhere too hehe
16:03:29 <jle`> trigone: why is reverse so slow for finger trees?
16:03:31 <jle`> or in general
16:03:57 <trigone> at core Seq feel like doubly-linked lists, that link to the same elements, although as long as part of the list is not computed both lists are strictly separated, aren't they?
16:04:16 <jle`> yeah, you could do something like add a reversed bit, but that's basically ad-hoc optimization for specific operations
16:04:29 <jle`> where would you draw the line
16:04:33 <trigone> jle`: no, i think it's a question of asking how slow it is to reverse a non-strict list (aka part of it is still non-evaluated)
16:04:54 <jle`> list like [] ?
16:05:17 <trigone> jle`: well yeah more or less.. .but maybe finger trees use something else
16:05:32 <jle`> reverse is going to be O(n) for [] no matter what
16:05:37 <trigone> jle`: no sorry, a non-strict double-ended list
16:05:38 <jle`> because it has to re-allocate the entire list
16:06:34 <jle`> well, of course, lazily calling 'reverse' is O(1), but if you want to consume the result, then you need to talk about what references need to be updated
16:06:39 <jle`> and what re-allocations need to happen
16:06:56 <trigone> as in, say, you have the list [1,2..100,101], and basically all that is computed so far is 1,2,100,101. its lazy reverse would only need to create [101,100..2,1] and the appropriate thunks for both ends
16:06:58 <jle`> Seq is a finger-tree so it's likely that reversing the list requires re-building the tree
16:07:04 <confusedFunctor> jle`: Thanks! refined is exactly what I was looking for.
16:07:21 <jle`> confusedFunctor: no problem!  be careful with runtime checked types for numbers though
16:07:24 <jle`> since Num is awful
16:07:29 <trigone> jle`: yes non-lazy reverse is probably always as slow as rebuilding the structure
16:07:48 <jle`> for lists, reverse is O(n) no matter what, lazy or not
16:07:55 <jle`> since it requires re-allocating all of the cells of the list
16:08:04 <trigone> but a doubly-linked list, even strict, should be reversable just by exchanging the flag for start and end...
16:08:15 <jle`> you can do that with even normal lists
16:08:30 <jle`> that doesn't "really" make reverse O(1)
16:08:36 <jle`> that's basically delaying the act of reversing
16:08:53 <colonelj> nof if you reverse twice :P
16:08:57 <jle`> ;)
16:09:27 <trigone> jle`: well yeah in fact the question of reversing is intrinsically related to the notion of popping: if you reverse, you want to be able to read the list the other way round without having to reverse the list
16:10:15 <jle`> yeah, it depends on how you actually consume the data
16:10:23 <trigone> i mean, without having to read the whole list in the other direction then backtracking and combining in the reversed form
16:10:29 <jle`> if all you want to do is pop from the end until the list is empty, seq lets you do that
16:10:33 <jle`> it's still O(n) of course
16:10:38 <jle`> cause you have to pop every item
16:10:41 <Tuplanolla> Cursor reversal is actually implemented for arrays in Repa, trigone.
16:10:51 <colonelj> gotta pop 'em all
16:11:02 <Cale> This is sort of a tangent, but an important thing to remember about lists in Haskell is that they basically are a way to say "I am going to iterate over these things *in this order*"
16:11:09 <trigone> jle`: yeah, of course, but then within that definition of reverse, you don't even *need* to reverse
16:11:18 <trigone> Cale: quite true
16:11:22 <jle`> yes, if all you want to do is pop from the end, you don't need to reverse
16:11:29 <jle`> that's why Seq isn't optimized for reversals
16:11:36 <skiddieproof> How would I declare the type of a function that uses Functor to map over a Tree containing Nums? I want to do something like (Functor Tree, Num a) => (a -> a) -> Tree a -> Tree a
16:12:05 <jle`> skiddieproof: if Tree has an instance of Functor, you can just do (a -> a) -> Tree a -> Tree a
16:12:11 <trigone> your functor depends on the tree being filled with numbers as opposed to something else?
16:12:19 <trigone> i mean your fmap
16:12:34 <Cale> skiddieproof: One thing you should try is just leaving out the type signature and asking ghci to compute one for you
16:12:55 <Cale> skiddieproof: It will typically succeed, and when it does, it will give you the most general type signature that will fit
16:14:16 <skiddieproof> trigone : I want to add a number to every element in a tree containing things that can be added (Nums)
16:14:49 <skiddieproof> Cale: thanks, I'll try that
16:15:14 <trigone> i think you would need to be able to add a constraint on the types of the elements of the tree. there's a ghc extension for that, something like data Tree a = Num a => ... but i'm not sure
16:15:26 <Cale> skiddieproof: In that case, it'll probably be a type like  (Num a) => Tree a -> Tree a
16:15:46 <geekosaur> note that (a) there is no such thing as "containing Nums"; Num is a typeclass, and you need types not typeclasses. (Num a) => ... will still resolve to *one* type 'a' at a use site, not any type
16:15:52 <Cale> skiddieproof: You won't need to constrain Tree in any way -- type classes are only needed to constrain the type variables
16:15:59 <jle`> :t fmap (+10)
16:16:00 <suzu> wouldn't it be something like: Num a => a -> Tree a -> Tree a ?
16:16:01 <lambdabot> (Num b, Functor f) => f b -> f b
16:16:07 <jle`> :t \x -> fmap (+ x)
16:16:08 <lambdabot> (Num b, Functor f) => b -> f b -> f b
16:16:17 <Cale> suzu: If the number to add is a parameter, then yeah
16:16:24 <suzu> ^ it'd be what lambdabot just said
16:16:27 <suzu> where f is Tree
16:16:31 <suzu> ye
16:17:42 <skiddieproof> jle`: I tried (Functor Tree, Num a) => (a -> a) -> Tree a -> Tree a, and it did not work. Yet, lambda dot says (Num a, Functor Tree) =>... any reason order matters?
16:17:59 <colonelj> it doens't matter
16:18:02 <jle`> what error do you get?
16:18:24 <jle`> it also depends on what you are doing
16:18:34 <skiddieproof> "Non type-variable argument in the constraint: Functor Tree"
16:18:38 <jle`> if you just type a type signature out in a file, it'll complain about having a definition
16:18:42 <suzu> skiddieproof: can you show us the definition of your function
16:18:51 <jle`> ah
16:19:01 <suzu> oh you can't do Functor Tree
16:19:02 <jle`> you can fix that with FlexibleContexts, but, you don't really need Functor Tree
16:19:06 <jle`> either Tree is a Functor or it's not
16:19:11 <suzu> ^
16:19:12 <trigone> i think the idea is: in the functor typeclass, you don't put the Num constraint, you don't need it because all that will happen to the values of the trees is meant to be independent from your tree functor's fmap
16:19:14 <jle`> it's not quite a constraint that you need to do
16:19:23 <skiddieproof> I have an instance for Tree as a functor too
16:19:36 <jle`> if you enable FlexibleContexts, you can do it, but it's not necessary
16:19:39 <trigone> skiddieproof: and why can you not use the fmap of that functor?
16:19:53 <jle`> just do (a -> a) -> Tree a -> Tree a, if your function takes a function and a Tree
16:20:05 <jle`> also next time you have an error, you should paste the error and the code that causes it
16:20:05 <trigone> maybe you need a monad over the tree, to modify the tree structure based on its elements?
16:20:20 <skiddieproof> jle`: got it, thanks
16:20:24 <jle`> just saying that things "does not work" is a sure way to make it take several times longer to help :)
16:20:49 <skiddieproof> <--- noob
16:20:56 <jle`> if your function just adds a number to every item in a tree, it could be Num a => Tree a -> Tree a
16:21:36 <skiddieproof> I take it will figure out that Tree is a functor because I have an instance declaration
16:21:37 <trigone> jle`: and therefore could be a curried version of fmap called with a Num a => a -> a function like (+10)
16:22:23 <jle`> skiddieproof: yeah, Functor Tree is a redundant constraint
16:22:29 <jle`> cause if Tree doesn't have an instance, it'll complain when you use fmap
16:22:34 <jle`> and if it does, it'll find it automatically
16:22:38 <geekosaur> skiddieproof, yes. you only use a context like that when all you know about the type is that it must have a Functor instance
16:22:51 <trigone> jle`: i'm pretty sure you can't make a non-polymorphic constraint anyway, can you?
16:22:56 <geekosaur> if you know the type, hat is sufficient; either it has the instance or it doesn't and the compiler will be able to determine that.
16:22:58 <trigone> i mean context
16:23:04 <jle`> you can with FlexibleContexts
16:23:16 <jle`> which really should have been in haskell in the first place, but oh well
16:23:46 <jle`> > let f :: Num Int => Int -> Int; f = (*2) in f 10
16:23:48 <lambdabot>  20
16:24:07 <colonelj> :t (,)
16:24:08 <lambdabot> a -> b -> (a, b)
16:24:11 <jle`> but that's the same as saying f :: Int -> Int; f  = (*2) in f 10
16:24:16 <trigone> apparently flexiblecontexts is mostly used when typeclasses have more than one argument
16:24:43 <trigone> so you can make context like FooClass a String => instead of FooClass a b =>
16:24:59 <jle`> it's used when you have non-type-variables in your typeclass constraints, which usually comes up when you have more than one argument yeah
16:25:11 <jle`> but sometimes it comes up when you don't
16:25:24 <trigone> jle`: like when?
16:25:46 <jle`> like if i have a type `Bar a` and i have separate instances of a typeclass for Bar String, Bar Int, Bar Bool
16:25:58 <trigone> the point of contexts is to be a middle ground between absolute polymorphic and fully-known types
16:26:12 <trigone> hm... 
16:26:15 <jle`> oh you're right
16:26:18 <jle`> my example is silly
16:26:20 <jle`> sry
16:26:29 <jle`> i seem to remember situations when i've used it though
16:26:33 <jle`> hm ~
16:26:40 <jle`> i guess my example is about FlexibleInstances
16:26:47 <trigone> well no not silly but indeed as long as there are no variables and everything is known, every context is by definition redundant
16:27:19 <trigone> contexts mostly amount to making methods for possibly several typeclasses....
16:27:34 <jle`> oh, you can still have type variables and use FlexibleContexts, actually
16:27:44 <trigone> then if you know all the types of everything that's the opposite of adhoc polymorphism aka typeclasses
16:27:54 <jle`> `Bar [a] => a -> a`, for instance
16:27:57 <Cale> It's possible to put a context in place with no type variables as a way of saying that users of a library must implement an instance, but nobody tends to do this.
16:28:19 <jle`> wait, does that need flexible contexts?
16:28:27 <trigone> jle`: actually i'm not sure
16:28:30 <Cale> Yes
16:28:31 <jle`> Foo (Bar [a])
16:28:58 <trigone> i think so, but you know you should append a C to differentiate classe from types because i'm getting lost
16:28:59 <Cale> FlexibleContexts is needed whenever you have a constraint which doesn't consist of a type class applied to some bunch of type variables.
16:29:26 <trigone> so flexiblecontexts is really just for multi-variable typeclasses
16:29:50 <jle`> Monoid (Tree [a]) => ... would need FlexibleContexts, i think
16:30:33 <trigone> actually i think yes but that would be redundant because then Tree [a] would be known as monoid without need of context
16:30:59 <jle`> not if there's no Monoid (Tree [a]) instance for all a's
16:31:13 <jle`> there might be a Monoid (Tree [Int]) instance and a Monoid (Tree [Bool]) instance
16:31:59 <trigone> hm i get it
16:32:30 <trigone> so it's to imply a context of a specific list of potential typeclasses instances of shape Monoid (Tree [a])
16:32:48 <clamchowder> Hello, I am having a problem with arch linux and cabal... I asked here about it yesterday but then ran out of time..
16:33:18 <clamchowder> So I rm -rf'ed both ~/.cabal and ~/.ghc
16:33:35 <trigone> clamchowder: maybe stack would do it right?
16:33:58 <geekosaur> only if you use stack to install ghc; it's the arch ghc package that is broken
16:33:58 <clamchowder> and tried to cabal install aeson-pretty, but failed.
16:34:15 <clamchowder> trigone: you think so? I'll give it a try. Thanks.
16:34:30 <trigone> clamchowder: i don't know, maybe stack uses better packages...
16:34:50 <ReinH> stack installs ghc itself
16:34:54 <trigone> geekosaur: stack always uses its own ghc, does it not?
16:35:05 <geekosaur> it will use a system ghc if one is available
16:35:17 <ReinH> you can change a setting to disallow this
16:35:19 <geekosaur> and we've had several people so far in the past 2 days using stack on arch with the system ghc
16:35:24 <trigone> geekosaur: really? mine seemed to redownload it from somewhere
16:35:36 <trigone> geekosaur: and it broke?
16:35:39 <ReinH> It will use the system ghc if the version matches the resolver
16:35:45 <geekosaur> ^
16:35:53 <geekosaur> but the system ghc is broken so things will fail
16:35:54 <ReinH> and system-ghc is not false
16:36:24 <trigone> ReinH: ok, but if clamchowder deletes ghc before maybe stack will download a good ghc?
16:36:28 <ReinH> On arch, I would atm recommend using stack with system-ghc: false to ensure that it doesn't try to use the broken ghc installed by the arch packages
16:36:47 <ReinH> stack setup will then install its own ghc
16:37:07 <lambdamu> I think system-ghc: false is the default
16:38:07 * hackagebot miso 0.1.1.0 – A tasty Haskell front-end framework – https://hackage.haskell.org/package/miso
16:38:08 <clamchowder> OK I'll remove ghc and then use stack
16:38:20 <clamchowder> by the way here's the log of cabal install aeson-pretty: http://lpaste.net/5066399673548275712
16:38:37 <trigone> jle`: you know i was reading the definition of Monoid. if there is no instance that is polymorphic on "a", will it really resolve it to Int or Bool or will it not say the instance does not exist? is that the very point of the extension?
16:38:41 <geekosaur> yep, that's the arch ghc failure
16:39:47 <geekosaur> trigone, instances are generally on specific types. *contexts* are on type parameters
16:40:34 <geekosaur> (it is possible to make an instance over a type variable but this usually does not do what you want, since it will prevent more specific instances from existing)
16:42:48 <trigone> geekosaur: actually we were speaking of two hypothetical Monoid(Tree[Int]) and Monoid(Tree[Bool]), and i was wondering if even with flexiblecontexts, to put a constraint Monoid(Tree[a]) would not try to find an instance polymorphic on "a", aka Monoid(Tree[a]), and if it fails then will it really seek more specific instances?
16:43:41 <colonelj> does haskell have a useful debugger for stepping through the code?
16:43:42 <clamchowder> but in arch stack depends on ghc, so installing stack will cause ghc to be installed as well
16:43:47 <trigone> geekosaur: you mean if i make a Class (Foo a), i can't make a Class (Foo Int) afterwards?
16:44:03 <colonelj> something like gdb but haskell
16:44:12 <geekosaur> trigone, it will be an overlapping instance and in some cases that instance will not be selected
16:44:25 <geekosaur> when it might otherwise.
16:44:58 <trigone> colonelj: maybe but in haskell you would try to put as much possible in the type system, so that ghc tells you what is wrong even before ending the compilation... but then of course sometimes it may not be doable
16:46:08 <colonelj> trigone: real bugs don't show up in teh type system
16:46:37 <clamchowder> is there any page on the web addressing the problem with arch linux?
16:47:04 <trigone> colonelj: yeah i just thought i should mention that sometimes the best is to add more polymorphism and more specific types, and the bugs go away :P but of course i'll never say it's panacea
16:47:24 <colonelj> trigone: it's simply not the case that it will remove all bugs magically just because it type checks
16:47:38 <colonelj> e.g. if you use a / instead of a - it won't catch that
16:48:01 <trigone> colonelj: no, it will merely not compile because it cannot compile with type bugs, and it always tells you where you did wrong (in cryptic and stupidly reversed fashion)
16:48:22 <colonelj> trigone: it compiles fine but it clearly doesn't work
16:48:46 <trigone> colonelj: well yeah but then what's the benefit of a gdb thing over just reading your code directly?
16:49:02 <colonelj> I want to see what the intermediate values are
16:49:16 <colonelj> without having to spread print statements through my code
16:49:40 <trigone> well you could use unsafePerform printStrLn myValues. as long as it's for debugging there's no real issue (i think)
16:49:59 <geekosaur> @hackage ghc-vis
16:49:59 <lambdabot> http://hackage.haskell.org/package/ghc-vis
16:50:20 <trigone> geekosaur: sounds cool
16:50:31 <kadoban> Debug.Trace has useful debugging of that sort, trigone
16:50:34 <trigone> geekosaur: does it work? as in, did you use it, is it mature?
16:51:06 <colonelj> I'll just use the built in GHCi debugger that I didn't know existed
16:51:14 <geekosaur> this works *with* the ghci debugger
16:51:30 <trigone> geekosaur: makes things easier?
16:51:49 <geekosaur> it gives you something like a debugging IDE that shows values live as you step through things
16:52:21 <colonelj> geekosaur: I'm not using that if I don't need it for now
16:52:32 <colonelj> how do I pass program arguments when I'm running the app from within GHCi?
16:53:04 <geekosaur> :main parameter ...
16:53:33 <trigone> i wonder if there's a setArgs function in some IO library?
16:54:12 <geekosaur> @index withArgs
16:54:12 <lambdabot> System.Environment
16:55:03 <marvin3> if it is just for testing main in ghci you can do :main arg1 arg2
16:55:25 <colonelj> geekosaur: it seems like -fno-ignore-asserts doesn't work?!
16:55:36 <colonelj> I used the option and the asserts are firing now I'm running within GHCi
16:55:45 <colonelj> this is a bit crap
16:56:28 <trigone> > :t withArgs
16:56:30 <lambdabot>  <hint>:1:1: error: parse error on input ‘:’
16:56:56 <trigone> :t withArgs
16:56:57 <lambdabot> error: Variable not in scope: withArgs
16:57:07 <colonelj> I think it's just the opposite of -fignore-asserts
16:57:07 <trigone> :t System.EnvironmentwithArgs
16:57:09 <lambdabot> error:
16:57:09 <lambdabot>     Not in scope: data constructor ‘System.EnvironmentwithArgs’
16:57:09 <lambdabot>     No module named ‘System’ is imported.
16:57:12 <trigone> :t System.Environment.withArgs
16:57:13 <lambdabot> [String] -> IO a -> IO a
16:57:20 <colonelj> as in it says not to ignore the asserts, except it ignores them anyway
16:57:23 <colonelj> what a load of crap
16:58:39 <trigone> so you can also do withArgs args main (but you need System.Environment)... there are always too many modules to import, it's really weird how in the end modules should not matter beyond name clashing...
16:59:12 <trigone> if i import a library, but i use no function, or just one or two, does ghc add all the library to the final executable, or only what i use?
17:00:38 <geekosaur> if it's static (default) then just what you use
17:00:58 <trigone> geekosaur: what do you mean by static?
17:01:12 <thang1> you rub your feet on it and then touch it and it makes your hair stand on end
17:01:22 <geekosaur> .a / .lib library vs. .so / .dll / .dylib
17:02:27 <trigone> thang1: that's what i thought :P static typing is mostly a question of haircut after all
17:02:49 <colonelj> is there something equivalent to assert that doesn't get ignored in -O2 compiles?
17:02:58 <trigone> geekosaur: i don't get what you mean, sorry... i mean i don't know at all what ghc does behind the scene
17:03:01 <geekosaur> you cannot pick and choose parts from a dynamic/shared library, they are always all or nothing, regardless of language or platform
17:03:50 <trigone> geekosaur: and how do you end up with a dynamic/shared library, by contrast with static libraries
17:03:56 <trigone> ?
17:05:20 <trigone> geekosaur: is it a choice at the time of compiling the library or something? does it has different usage?
17:05:53 <geekosaur> ghc's default is static libraries for Haskell code. the -dynamic option lets you build shared libraries instead
17:07:40 <trigone> ok i just read a definition of dynamic vs static. technically, what you said makes not much sense because if you imply dynamic then the library is separated and then of course there's nothing in the final executable, but then it has to be followed with all the used dynamic libraries of course
17:07:50 <geekosaur> this is often not a good idea because of the way ghc's dependencies work (you generally can't substitute in a new version of a shared library because code from the library might be inlined, which means the runtime and compile time code must match exactly
17:07:58 <geekosaur> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/shared_libs.html#building-programs-that-use-shared-libraries
17:08:54 <thang1> colonelj: what do you mean? Like "assert that this function is totes legit"?
17:09:56 <colonelj> I want an assert that doesn't get compiled out
17:10:00 <geekosaur> @index assert
17:10:01 <lambdabot> Control.Exception.Base, Control.Exception
17:10:06 <trigone> thang1: i think colonelj wants a way to break the program, or possibly interrupt it, if some assertion is false
17:12:37 <trigone> colonelj: well if you have a function assert, you can construct assert' and make it depend on, say the first argument given to the program, so you can use "true/false" or maybe "debug/nodebug" as first argument of command line, and consume it within your assert' function... but it'sa bit messier than it could be
17:12:47 <colonelj> I think this is the whole ASSERT vs ENSURE or whatever it is issue
17:14:03 <colonelj> ideally it should show the line number and source code of the assertion
17:14:16 <colonelj> maybe that's why it doesn't work in O2
17:15:38 <masaeedu[m]> Is it possible to use a type family to generate a record type from an HList of HTuples?
17:15:42 <trigone> colonelj: it'd be messy but you could have a program adding the line number to all your assertions, using some pattern matching. then, you'd call ghc on this...
17:16:04 <colonelj> c'mon no don't be ridiculous
17:16:55 <colonelj> is it possible with template haskell or something???
17:17:07 <colonelj> I don't know much about that
17:17:56 <xcmw> masaeedu[m]: This may be related to what you are looking for: https://github.com/VinylRecords/Vinyl
17:18:05 <nshepperd> colonelj: it's working for me.. http://lpaste.net/356653
17:18:11 <colonelj> :t fail
17:18:12 <lambdabot> Monad m => String -> m a
17:18:48 <colonelj> well that's great for you nshepperd ....
17:19:30 <colonelj> idk if it makes any difference if it's inside a library where the assertion is supposed to happen
17:19:32 <masaeedu[m]> xmcw: Thanks, I'll take a look
17:19:44 <trigone> :t assert
17:19:45 <lambdabot> Bool -> a -> a
17:20:05 <colonelj> :t error
17:20:06 <lambdabot> [Char] -> a
17:20:09 <nshepperd> colonelj: probably. i bet you have to recompile the library with -fno-ignore-asserts if you want that to work
17:20:18 <colonelj> I used that option when building the library
17:20:49 <colonelj> anyway I want a more reliable option
17:21:01 <nshepperd> well idk then
17:21:06 <nshepperd> force recompile everything
17:21:23 <colonelj> it already recompiled the bits of the library I care about and the asserts didn't fire
17:21:32 <crobbins> anyone know how to get the cabal tool (cabal-install) to output source paths in its error/warning messages with absolute paths
17:21:39 <nshepperd> usually when i have a problem like this it's because i expected it to rebuild but it actually didn't cause ghc thought "nah i got this"
17:22:04 <colonelj> I don't think this is what's happening here, I think because it's in a library with -O2 it didn't hold on to the assertions
17:22:15 <colonelj> it might be a bug or something
17:23:38 <colonelj> another possibility is that your "assert False" gets evaluated at compile time
17:23:44 <pacak> https://ghc.haskell.org/trac/ghc/ticket/13615  Resolution: → fixed
17:23:44 <pacak> That was fun.
17:23:47 <colonelj> you're not really proving much
17:27:29 <nshepperd> why would being evaluated at compile time matter
17:27:54 <nshepperd> the important thing is that it goes away if I don't supply -fno-ignore-asserts
17:28:57 <nshepperd> wow, ghc -c doesn't recompile the object files if they already exist, even if I supply -fforce-recomp. how rude
17:29:26 <colonelj> relevant http://haddock.stackage.org/lts-5.2/base-4.8.2.0/GHC-Stack.html#t:CallStack
17:31:22 <colonelj> anyone know what that question mark means because I have nfi
17:31:31 <colonelj> :t showCallStack
17:31:32 <lambdabot> error: Variable not in scope: showCallStack
17:32:33 <geekosaur> it's an implicit variable
17:32:55 <colonelj> that sounds cool, how do they work?
17:32:55 <geekosaur> you can think of it as a value passed via a context instead of as a normal parameter
17:33:29 <geekosaur> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#implicit-parameters
17:34:20 <geekosaur> (keep in mind that a context is implemented as an additional parameter that is a dictionary, normally indexed by type to find instance method implementations. implicit parameters can also be passed in that dictionary)
17:35:20 * hackagebot llvm-pretty-bc-parser 0.4.0.0 – LLVM bitcode parsing library – https://hackage.haskell.org/package/llvm-pretty-bc-parser
17:35:35 <colonelj> geekosaur: I'm not quite understanding this, where does ?loc get bound?
17:37:26 <colonelj> will it just work if I use it as shown?
17:37:43 <geekosaur> in code generated by the compiler.
17:38:29 * geekosaur looking up the design docs
17:38:36 <geekosaur> but my local network is being crap
17:38:46 <geekosaur> http://hackage.haskell.org/package/base-4.9.1.0/docs/GHC-Stack.html
18:00:18 <colonelj> +ensure :: (?location :: CallStack) => Bool -> t -> t
18:00:18 <colonelj> +ensure c x = if c then x
18:00:19 <colonelj> +    else error ("ensure failed\n" ++ prettyCallStack ?location)
18:00:36 <colonelj> works pretty good
18:01:28 <colonelj> you get two stack traces though one for the 'ensure' and one for the 'error'
18:01:53 <colonelj> :t assert
18:01:54 <lambdabot> Bool -> a -> a
18:02:10 <colonelj> so you can just replace all your asserts with ensures
18:26:40 * hackagebot streaming-concurrency 0.1.0.0 – Concurrency support for the streaming ecosystem – https://hackage.haskell.org/package/streaming-concurrency
18:49:48 <skiddieproof> Is there a way to search a list for an element using a lambda? Something like (\x y -> case y == [] = blah | y == h : t = x == y...) element list
18:52:08 <verement> :t find
18:52:10 <lambdabot> Foldable t => (a -> Bool) -> t a -> Maybe a
18:54:45 <ReinH> skiddieproof_: you can’t use elem?
18:55:40 <skiddieproof_> I can and will, but it brought the question to mind. Generally, can you do recursion with lambda?
18:57:54 <verement> > fix (\r n -> if n == 0 then 1 else n * r (n - 1)) 4
18:57:56 <lambdabot>  24
18:57:57 <ReinH> Are you familiar with the y combinator?
18:59:37 <skiddieproof_> awesome!
19:00:01 <skiddieproof_> yeah I know of the theoretical y combinator didn't know you could do that in haskell
19:00:02 <ReinH> If so, you might like to read https://stackoverflow.com/q/4273413/2225384
19:01:22 <ReinH> The short answer is that you can’t. The long answer is that you can do something similar with the help of a recursive type.
19:02:34 <ReinH> Actually, the long answer is that you can’t.
19:02:41 <skiddieproof_> haha
19:03:22 <colonelj> :t all
19:03:24 <lambdabot> Foldable t => (a -> Bool) -> t a -> Bool
19:10:07 <skiddieproof> Is there an idiom for declaring an instance of Eq for a type with only nullary constructors?
19:11:53 <geekosaur> you can derive Eq for most types
19:12:22 <skiddieproof> for instance say I have data Mybool = mtrue | mfalse
19:12:37 <skiddieproof> * Mtrue | Mfalse
19:13:10 <geekosaur> most commonly one would : data Mybool = Mtrue | Mfalse deriving (Eq, Show, Read, Enum, Bounded)
19:13:27 <geekosaur> and possibly Ord
19:13:29 <skiddieproof> ok cool, so it will just do it automatically, great
19:42:39 * hackagebot tls-session-manager 0.0.0.0 – In-memory TLS session manager – https://hackage.haskell.org/package/tls-session-manager
19:54:49 * hackagebot warp-tls 3.2.4 – HTTP over TLS support for Warp via the TLS package – https://hackage.haskell.org/package/warp-tls
20:12:03 * hackagebot warp 3.2.13 – A fast, light-weight web server for WAI applications. – https://hackage.haskell.org/package/warp
20:30:33 <bluebaron> I know monads aren't "the same" as continuations, but the more I look at them the closer it seems they're related. I'm aware there's a continuation monad, but I'm talking about the resemblance therebetween, not the fact that there exists a monad that represents continuations. This may be an absurd question, but is there like some kind of isomorphism between them or something?
20:31:42 <bluebaron> I feel like I'm on the verge of truly grokking monads after having seen the same phrasings of its definition countless times and investigating on my own for a while as well, I think I've nearly reached a precipice
20:40:56 <EvanR> bluebaron: consider data Program = Get (Word8 -> Program) | Put Word8 Program | Exit Int, you could consider the Word8 -> Program or Program payloads there to be continuations, i.e. "what to do next"
20:41:15 <EvanR> you could have these even when the situation doesnt involve monads
20:42:11 <EvanR> theres a generalization of this example though that makes good use of monads, so you could easily string continuations together
20:42:27 <colonelj> is there ever a time in Haskell where you need () -> type functions?
20:42:46 <EvanR> you could use that to fake ghc into reevaluating something
20:42:47 <colonelj> or does the whole idea of monads make them unnecessary?
20:43:02 <EvanR> the idea of lazyness makes it usually unnecesary
20:43:16 <colonelj> yeah, that too
20:44:05 <EvanR> purity makes that not really make sense for something like getLine :: IO String
20:44:14 <EvanR> its not a function, so why would it have a function type
20:44:31 <EvanR> thats not really a monad phenomenon either
20:45:00 <EvanR> because evaluating function application doesnt have side effects, it just doesnt make sense to do () -> X for that
20:45:02 <colonelj> well I was thinking like in ML where you need it for side-effectful computations
20:46:00 <EvanR> Put Word8 Program works without a () -> thanks to laziness
20:47:04 <EvanR> a js-equivalent like Put Word8 !Program would necessarily freeze up if you try to make a program that looped "put 4" forever
20:48:25 <colonelj> I don't think it would necessarily have to freeze up in starpial
20:48:42 <colonelj> so long as you break it into transactions for each put
20:49:00 <colonelj> idempotent writes don't do anything
20:49:16 <colonelj> so you just wait until it changes then change it back
20:49:30 <EvanR> it would freeze up just by attempting to construct the piece of data
20:49:39 <EvanR> since you have to evaluate the payload to normal form first
20:49:48 <EvanR> which is itself, and so on
20:50:03 <bluebaron> EvanR: continuations are essentially a provision of context for an eventual value though, right? Doesn't the "sequencing" of operations by composition in Monads work in at least a similar way? I'm not trying to argue I'm right, I'm just trying to get a deeper understanding of both concepts I guess
20:50:33 <EvanR> bluebaron: you could think of the (a -> m b) in the type of >>= to be a continuation argument
20:50:47 <EvanR> >>= is free to use it, use it many times, or ignore it
20:51:04 <EvanR> sure, any function has some closure context
20:51:15 <EvanR> thats not specific to monads
20:52:19 <EvanR> maybe what youre missing is a well defined question, like, what would it mean technically for something to "be continuations". not sure this is very specific
20:52:42 <EvanR> theres is a specific thing called continuation passing style, and thats not happening with Monad
20:53:00 <EvanR> (besides Cont monad)
20:53:16 <bluebaron> EvanR: You're right, I knew I wasn't coming at this with the most clear question in hand, but I think you've helped a bit so far, so thanks!
20:54:14 <EvanR> a related thing is coroutines
20:54:33 <bluebaron> EvanR: related to CPS, you mean?
20:54:33 <EvanR> you can certainly set up coroutines for cooperative multitasking with monads
20:55:19 <EvanR> related to "continuations", and the suspendable kind of programs like Program
20:56:06 <EvanR> Get and Put occurring are like yields
20:56:42 <EvanR> if you had a pile of Programs you could interleave them like coroutines instead of running them in different threads
20:57:54 <bluebaron> EvanR: As an exercise just a few hours ago, I actually implemented just that, I believe
20:58:08 <bluebaron> EvanR: the `It` monad from the Freer monads paper: http://okmij.org/ftp/Haskell/extensible/more.pdf
20:58:27 <EvanR> thats more like a partiality monad
20:58:28 <bluebaron> Maybe not "the" freer monads paper, but a paper thereon nonetheless haha
20:58:35 <EvanR> it allows a computation to be safely non terminating
20:58:57 <bluebaron> EvanR: Couldn't coroutines be implemented using them though?
20:59:19 <EvanR> any free monad looks like a coroutine to me
20:59:46 <colonelj> what's a monad transformer?
21:00:03 <EvanR> a thing that maps monads to monads!
21:00:19 <bluebaron> I might be afk for a while but thank you for the explanations thus far!
21:00:20 <EvanR> if you have a monad, a monad transformer will give you another monad based on the original
21:00:36 <colonelj> is the original encoded in the type?
21:00:52 <EvanR> in the monad transformer libraries, yes
21:01:17 <EvanR> im not sure if thats necessary in general
21:01:32 <EvanR> hmm
21:02:06 <EvanR> it might be necessary, so that you dont mix up actions in the target monad that involve different original monads
21:07:36 <moet> hello
21:07:41 <moet> i'm forgetting something basic again
21:07:42 <moet> http://lpaste.net/356655
21:08:15 <moet> I feel like ^ should work because I can get back some `a` which can only be `show`ed
21:08:27 <moet> but aparrently i'm wrong
21:08:28 <EvanR> unf :: Show a => F -> a means, for any a you want (which is showable), ill give you one
21:08:41 <EvanR> but thats not what your function does, and is in fact impossible
21:08:58 <EvanR> the user of unf chooses what a is at the call site
21:09:27 <moet> yes, that makes sense
21:09:30 <EvanR> so unf :: F -> () is a valid specialization of your type
21:10:45 <moet> So if I was loading a file, and needed to return a different type based on the bytes in the header... what would i do with my F after having read the header?
21:11:15 <EvanR> theres a few things i know of
21:11:30 <EvanR> return Either Foo Bar
21:11:40 <EvanR> depending on whether the header is this or that
21:12:43 <EvanR> this is what the library JuicyPixels does, and it has some further enhancements to get more type safe
21:13:08 <EvanR> it loads images, but you dont know until runtime what format youll get
21:13:45 <EvanR> so the baseline is, return a sum type
21:14:39 <moet> so have an `data F = A | B` and an `data FData = A String | B Int` or somesuch?
21:15:01 <EvanR> right and FData is pretty the same as Either String Int
21:16:13 <EvanR> if you somehow "know" its supposed to be one or the other, and getting the opposite would make no sense, then we should reevaluate
21:16:50 <colonelj> is there any way in haskell to control the floating point rounding mode used for division etc?
21:16:51 <EvanR> but so far it sounds like youre trying to write a ByteString -> FData
21:17:34 <moet> yes, i suppose that's what i'm trying to do
21:17:50 <c_wraith> colonelj: there are ways, but they're dangerous.  that's something that leaks to other haskell threads running on the same OS thread
21:17:54 <moet> i was overcomplicating it thinking there was some way to get the best of both worlds using typeclasses or families or sth
21:18:24 <EvanR> not sure i see any worlds here
21:18:46 <colonelj> c_wraith: link?
21:20:00 <colonelj> "GHC completely ignores the floating-point environment, the runtime neither modifies nor reads it."
21:20:15 <EvanR> i could have sworn there was a way to configure the global floating point env
21:20:17 <moet> EvanR: ;P maybe that's where i took a wrong turn
21:20:38 <colonelj> c_wraith: apparently you can use Control.Concurrent.forkOS bound threads
21:21:09 <EvanR> moet: haskell is great for making you make concrete what youre trying to do
21:21:30 <EvanR> which is ironic because of all the abstraction
21:22:00 <colonelj> I find dependent types to be more abstract, stuff in Haskell is a bit of a fudge to achieve the same things
21:22:03 <arahael> EvanR: Simplest way is to probably find out how existing libraries do that, eg, http://en.cppreference.com/w/cpp/numeric/fenv
21:22:37 <arahael> EvanR: It's something that comes up when bridging across the FFI between languages.
21:23:07 <arahael> EvanR: Worse: I'm not sure if it's thread-local.
21:23:49 <colonelj> it sounds like it's local to the OS-thread
21:24:12 <EvanR> thread local state, great!
21:25:21 <moet> EvanR: yes, it is .. thanks for the help & reminder!
21:33:10 <EvanR> "programming language" on google gives you an array of language logos, no haskell
21:33:14 <EvanR> success avoided!
21:33:33 <EvanR> its because haskell's current logo doesnt have enough curvy edges
21:35:48 <arlenik> noob here.  I want to create a new integer type that, say, represents specific range of Integers.  how would I do that?
21:36:18 <EvanR> swap Integer in a newtype and hide the constructor
21:37:24 <EvanR> s/swap/wrap/
21:38:00 <ReinH> You can’t enforce that constraint in the type system. At least, not in a reasonable way.
21:38:13 <arlenik> does it even make sense to create a new integer type? or should I leave it to run-time testing with quickcheck for example?  say the function is a fibonacci function where a negative argument wouldn't make sense.
21:38:15 <EvanR> > 3 - 4 :: Natural
21:38:17 <lambdabot>  *Exception: Natural: (-)
21:38:40 <EvanR> Natural is a newtyped Integer example which doesnt allow negatives
21:40:25 <ReinH> Sure, you can enforce it in the value system.
21:43:08 <arlenik> ReinH: how?
21:43:38 <ReinH> By making such functions partial, as EvanR just demonstrated.
21:44:02 <EvanR> theres no reason Natural must have a partial subtraction
21:44:25 <EvanR> but thats what i would choose in order to detect bugs at runtime
21:44:32 <ReinH> Yes there is.
21:45:04 <ReinH> You just proved it.
21:45:10 <EvanR> you could choose 0 to be the answer, like in a lot of math "implementations" of nat
21:45:23 <EvanR> they arbitrarily pick 0
21:45:54 <EvanR> > 3 `monus` 4
21:45:56 <lambdabot>  error:
21:45:56 <lambdabot>      Variable not in scope: monus :: Integer -> Integer -> t
21:46:01 <ReinH> Well, it isn’t arbitrary. It’s saturated subtraction.
21:46:26 <EvanR> you could arbitrarily pick whatever `div` 0 to be 0
21:46:45 <EvanR> the decision to utilize partiality is also arbitrary
21:46:58 <ReinH> No it isn’t.
21:47:09 <ReinH> It comes from the definition of the natural numbers.
21:47:37 <EvanR> "the" definition of natural numbers doesnt include definitions of operations, those are made up extra things
21:47:51 <EvanR> and they are arbitrary!
21:48:19 <ReinH> You can choose saturated arithmetic, but you shouldn’t call the result the natural numbers.
21:48:23 <EvanR> the - operation on Natural is necessarily partial in the sense that you download the package and it is
21:48:37 <ReinH> Saturated arithmetic breaks most of the properties of arithmetic for the natural numbers.
21:48:52 <EvanR> if you say so
21:49:04 <ReinH> It is not associative or distributive.
21:49:22 <EvanR> nats never had properties for subtraction to break
21:50:02 <Sh4rPEYE> I'm reading the original paper on IO and I can't understand, why the RealWOrld value is needed. 
21:50:23 <EvanR> its not
21:50:24 <Sh4rPEYE> The say if I had:
21:50:37 <Sh4rPEYE> data IORes a = MKIORes a
21:50:58 <EvanR> its not ultimately intrinsic to the idea of an IO monad
21:50:59 <Sh4rPEYE> bionIO m k w = case (m w) of MkIORes a -> k a w
21:51:26 <Sh4rPEYE> Then the sequencing would be lost.... (the above is bind* ofc)
21:52:02 <EvanR> what is the type of bionIO supposed to be
21:53:02 * hackagebot openexr-write 0.1.0.1 – Library for writing images in OpenEXR HDR file format. – https://hackage.haskell.org/package/openexr-write
21:53:07 <Sh4rPEYE> it is bindIO... so bindIO :: IO a -> (a -> IO b) -> IO b
21:53:30 <arlenik> so in Perl6 i could do:  subset MyInteger of Int where * ~~ 2 .. 21;
21:53:33 <EvanR> so IO a is a function ?
21:53:48 <Axman6> arlenik: before you ask, no, there isn't an easy way
21:53:52 <Axman6> sadly
21:54:59 <arlenik> Axman6: well I'm reading how great Haskell's type system is, i figured such a thing would be easy to express.  So how do Haskeller solve such a problem?
21:55:02 <Sh4rPEYE> Yes. type IO a = World -> IORes a
21:55:20 <Sh4rPEYE> data IORes a = MkIORes a World
21:55:23 <EvanR> arlenik: theres liquid haskell which does put a lot of effort into that particular use case
21:55:31 <Axman6> arlenik: assuming I'm understanding rightly, what you want an integer type which only allows the values 2..21?
21:56:10 <EvanR> in regular haskell you probably use Int or Integer and error if they pass in something out of bounds
21:56:12 <ReinH> Subtraction on Nats is defined in the usual way, as the inverse of addition. It is partial.
21:56:24 <EvanR> how is that an inverse
21:56:29 <Axman6> since we don't have any sort of subtyping, this sort of thing is not so natural to express. it can be done with the type system, but it's likely somewhat cumbersome (also, there's lots of considerations, like what result do you get if you have 21+21)
21:56:31 <EvanR> youre not making any damn sense
21:56:50 <EvanR> it "is defined" totally not like that in idris for example
21:57:03 <ReinH> I didn’t want to write it out, but if you insist.
21:57:11 <ReinH> Let N be the natural numbers.
21:57:14 <arlenik> Axman6: that's just an example.  If I have a function that takes an integer as input, and, say, integers outside certain range wouldn't make say to pass in(like -3-th fibonacci number), what do I do to avoid those kinds of bugs?
21:57:42 <ReinH> Let n, m in N s.t. m <= n
21:58:08 <ReinH> Let p in N s.t. m + n = p
21:58:09 <Sh4rPEYE> EvanR: Nvm, got it.
21:58:42 <EvanR> Sh4rPEYE: well now you made RealWorld required by baking it into your implementation of IO. theres a nicer way to look at it here
21:58:48 <Axman6> arlenik: so, the usual solution is to use newtypes, so newtype Positive = Positive Integer, and a smart constructor positive :: Integer -> Maybe Positive. the smart constructor can be arbitrarilly smart
22:00:12 <Axman6> you could make a type: newtype Bounded (lo :: Nat) (hi :: Nat) = Bounded Integer so you can build a type for values which are between two bounds, which again would use a smart constructor to make sure you never produce an invalid value
22:00:49 <EvanR> now i cant find monochrom's free IO tutorial
22:01:00 <Axman6> but this is something I really miss from Ada, its ability to have types which are some arbitrary range (and I think these days you can have them defined by an arbitrary predicate) is really handy
22:01:13 <Axman6> EvanR: it's hidden behind a paywall now
22:01:17 <t_> any ghc-mod/lint users?
22:01:19 <Sh4rPEYE> Axman6: WHat' wrong with LiquidHaskell? I don't knwo anything about it, really, but it seemed interesting from what I've heard
22:01:21 <EvanR> o_O
22:01:46 <Axman6> Sh4rPEYE: nothing, but it's also not Haskell
22:02:10 <t_> https://gist.github.com/anonymous/b659cd66bc1013c85b27ebf879ac10c9
22:02:23 <EvanR> i like (n : Nat, Between n A B) 
22:02:29 <Sh4rPEYE> Oh, is it not? I thought it's just some extension of the Llanguage
22:02:29 <t_> I'm curious why hlint and ghc-mod lint produce differnt outputs for this file
22:02:30 <EvanR> if were doing dependent types
22:02:42 <t_> if someone can repeat the experiment that'd be great
22:02:46 <ReinH> Then p - m = n
22:02:46 <Axman6> Sh4rPEYE: well, it is sufficiently different to not be Haskell
22:03:04 <Axman6> it's type system is more powerful than Haskell's
22:03:08 <ReinH> That’s the usual definition of subtraction, given addition. It is partial for the natural numbers.
22:03:13 <EvanR> ReinH: so this operation is neither an inverse nor partial
22:03:16 <t_> (to make sure I'm not the only one seeing the difference)
22:03:29 <ReinH> It is not defined for all natural. Umber.
22:03:35 <Hasnoob> I am new to haskell and data structures. Which data structures book will be good for a newbie like me? 
22:03:43 <ReinH> Natural numbers. When it is defined, it is the inverse of addition.
22:03:53 <EvanR> its defined on a subset of nats
22:04:07 <Axman6> Hasnoob: depends on what data structures you're interested in Okasaki's book is the original and most widely recommended
22:04:34 <Axman6> there hasn't been a whle lot of fundamental new structures since then (finger trees being a notable exception)
22:04:36 <ReinH> Yes, that’s what it means to be partial.
22:04:45 <EvanR> now prove that its necessarily defined like you said
22:04:52 <ReinH> Oh my god.
22:04:53 <Hasnoob> Axman6: I want to improve my basics.
22:04:57 <ReinH> Are you serious.
22:05:18 <EvanR> are you? why are you going on and on with stuff we all know
22:05:21 <ReinH> Nothing is necessarily defined any way. Everything is made up. It is the usual definition.
22:05:24 <Axman6> Hasnoob: I'm not sure what that means :) do you have a particular problem domain you're thinking about?
22:05:32 <ReinH> Because you refused to accept it.
22:05:43 <EvanR> i do refuse "it is X. period."
22:05:50 <ReinH> Whatever.
22:05:59 <ReinH> I’m done.
22:06:05 <Axman6> children, go and take a break
22:06:09 <EvanR> its defined with saturation in various relevant places that mattered at the beginning of the convo
22:06:25 <EvanR> totally  wrong? ok 
22:07:08 <EvanR> when you dont want to prove advanced number theory you can also just pick arbitrarily the answer for some operations like division by zero
22:07:10 <Axman6> EvanR: enough
22:07:27 <Axman6> this is #haskell, we don't do fights in here
22:08:42 <ReinH> This is a pointless argument.
22:08:50 <ReinH> I’m done with it.
22:08:51 <t_> anyone who can opine on this: https://gist.github.com/anonymous/b659cd66bc1013c85b27ebf879ac10c9
22:08:52 <EvanR> is that IO page really behind a pay wall?
22:09:10 <Hasnoob_> Axman6: Sorry i got disconnected.
22:09:12 <Hasnoob_> Axman6: I am a student. No, not a particular problem domain in my mind. I want to learn Data structures to improve my programming skills
22:09:13 <Axman6> EvanR: no, it was a joke about it being a free, IO tutorial
22:09:22 <EvanR> oh 
22:09:30 <Axman6> Hasnoob_: well take a look at Okasaki's book
22:09:41 <EvanR> "IO a free _" cant remember 
22:09:43 <Hasnoob_> ok, thank you :0
22:09:45 <Hasnoob_> :)
22:11:08 <Axman6> but what is interesting really depends onw aht sort of problems you're trying to solve. do you what to know about different kinds of key/value maps? queues? primitive types like vectors? or algorithms on these and other structures?
22:43:26 <Lokathor> https://pbs.twimg.com/media/C9tsaSaVwAAEsVe.png:large
22:45:57 <EvanR> Lokathor: is that a fight scene or
22:46:31 <Lokathor> i don't understand your question
22:46:49 <EvanR> i figured it was a hex roguelike demo
22:47:06 <EvanR> that happened to look like haskell
22:47:40 <MarcelineVQ> bit of a mind twister, seeing a record getter as infix symbols
22:47:42 <Lokathor> oh, no
22:47:52 <Lokathor> it's a bit of a joke
22:48:03 <EvanR> yeah wait...
22:48:04 <Lokathor> yes, what MarcelineVQ said
22:57:40 <The_Kinaesthetic> Hi there. I've been stuck on a problem for hours and I'm sick of it, but I don't know how to ask in here.
22:57:44 <The_Kinaesthetic> It involves a lot of things
22:58:24 <The_Kinaesthetic> Abstractly: I need a function that does two things recursively but they both occur "at the same speed", so to speak.
22:58:51 <The_Kinaesthetic> But I can't seem to figure out how to formulate one recursive process without it finishing and returning that instead.
22:59:06 <Axman6> two mutually recursive functions?
22:59:09 <suzu> what are you trying to do?
22:59:12 <Axman6> can you at least give us some types?
22:59:33 <The_Kinaesthetic> Slightly less abstractly: P1/L1 + P2/(L1*L2) + P3/(L1*L2*L3) ...
22:59:43 <The_Kinaesthetic> It's being done on a tree
23:00:11 <The_Kinaesthetic> a tree with arbitrary branch numbers
23:00:11 <Axman6> a breadth first traversal?
23:00:15 <suzu> what are you /really/ trying to do?
23:00:26 <The_Kinaesthetic> idk what breadth first traversal is sorry
23:01:06 <Axman6> it's visitin all the elements in a tree, in order of depth, so everything at the root first, then everything at the next level, and so on
23:01:22 <The_Kinaesthetic> @suzu I'm trying to fulfill the above formula where P is the index of whatever Branch list I happen to be on, and L is the length of the respective branch list.
23:01:22 <lambdabot> Unknown command, try @list
23:01:42 <suzu> you are trying to calculate a value from a tree?
23:01:49 <suzu> following that equation?
23:01:56 <suzu> what is a branch list?
23:02:13 <The_Kinaesthetic> My type is --- data Tree a = B [Tree a] | L a | Tie
23:02:23 <The_Kinaesthetic> so Branch list refers to the list of trees
23:02:36 <The_Kinaesthetic> so if pattern matched with B x, then L = length x
23:02:37 <suzu> ah so the children of a node
23:02:45 <The_Kinaesthetic> ignore "tie" for now
23:02:53 <suzu> Tie is an empty node i guess
23:03:00 <The_Kinaesthetic> Basically
23:03:04 <The_Kinaesthetic> yeah it is
23:03:04 <suzu> L is a leaf, i see
23:03:07 <The_Kinaesthetic> yup
23:03:11 <suzu> got it
23:03:29 <suzu> and so Lx is the sum of the values in one level of the tree?
23:04:11 <The_Kinaesthetic> yes...I think
23:05:07 <suzu> what is P?
23:05:30 <The_Kinaesthetic> If it's B [ B [ L 1, L 1], L 1] , for example, then L_1 would be 2, and L_2 would be 2 as well, but really I need those multiplied together , ie 4.
23:06:09 <The_Kinaesthetic> With regards to P, the function takes a second variable which is a list of instructions to get to some Leaf on the tree
23:06:40 <The_Kinaesthetic> so for the tree of the above example, the list might be [0,1] to refer to the second L 1
23:07:02 <Axman6> this sounds like breadth first traversal to me :\
23:07:09 <The_Kinaesthetic> maybe it is idk
23:07:15 <suzu> so L_1 is the length of the topmost B [.. ]
23:07:21 <The_Kinaesthetic> Yes
23:07:29 <The_Kinaesthetic> well the length of the list of that B
23:07:33 <suzu> L_2 is the length of the innermost B [ .. ]
23:07:34 <suzu> right
23:07:46 <The_Kinaesthetic> Respective to the inputted list, yes
23:08:13 <suzu> what if you had
23:08:16 <The_Kinaesthetic> if there were 2 inner most Bs, but the direction list takes you through the second one, then L_2 would be the length of the second one
23:08:27 <suzu> yes i was just about to ask that ^ :)
23:08:32 <suzu> direction list?
23:08:45 <suzu> the P .. values?
23:08:51 <The_Kinaesthetic> "With regards to P, the function takes a second variable which is a list of instructions to get to some Leaf on the tree ... so for the tree of the above example, the list might be [0,1] to refer to the second L 1
23:09:10 <suzu> oh shit thats kinda tricky
23:09:15 <suzu> why not have P be a lens?
23:09:24 <The_Kinaesthetic> what's lens
23:09:32 <The_Kinaesthetic> There are probably better ways of doing these things
23:09:48 <The_Kinaesthetic> but I tried googling but couldn't really find anything 
23:09:58 <suzu> a lens is a function that will take some larger structure, and let you access some field inside it
23:10:19 <suzu> you can use the lens to modify, view, or set that field, and then get that larger structure back with just that field changed
23:10:38 <suzu> you can compose lenses into larger lenses as well using the regular (.) operator
23:11:18 <suzu>  > view _1 (,3,5)
23:11:27 <suzu>  > view _1 (3,5)
23:11:42 <Axman6> no space at the beginning...
23:11:44 <suzu> > view _1 (3,5)
23:11:46 <lambdabot>  3
23:11:51 <The_Kinaesthetic> what does that do
23:12:02 <The_Kinaesthetic> it returns the respective element?
23:12:05 <The_Kinaesthetic> like !! ?
23:12:07 <suzu> > view _1._2._1 ((3,(1,4)),5)
23:12:09 <lambdabot>  error:
23:12:09 <lambdabot>      • Couldn't match expected type ‘a1 -> a0 -> b1’
23:12:09 <lambdabot>                    with actual type ‘((Integer, (Integer, Integer)), Integer)’
23:12:15 <suzu> oops
23:12:20 <suzu> > view (_1._2._1) ((3,(1,4)),5)
23:12:22 <lambdabot>  1
23:12:28 <The_Kinaesthetic> I have an element returning function already defined btw
23:12:42 <The_Kinaesthetic> for later on 
23:12:44 <Axman6> I feel that lenses are an unnecessary sidetrack here
23:12:49 <suzu> oh then nevermind
23:12:53 <The_Kinaesthetic> elemTree (L x) y = x elemTree (B x) (y:ys) = elemTree ((!!) x y) ys
23:12:53 <suzu> Axman6 is right
23:12:55 <The_Kinaesthetic> oops
23:13:02 <The_Kinaesthetic> elemTree (L x) y = x
23:13:04 <Axman6> even if they often are the answer
23:13:07 <The_Kinaesthetic> elemTree (B x) (y:ys) = elemTree ((!!) x y) ys
23:13:07 <suzu> sounds to me you want to do a level-by-level traversal
23:13:23 <The_Kinaesthetic> god is there a way to do lines in here? so I can show the pattern match
23:13:29 <suzu> use lpaste in the topic
23:13:30 <Axman6> no
23:13:34 <The_Kinaesthetic> o
23:13:35 <Axman6> @where lpaste
23:13:36 <lambdabot> http://lpaste.net/
23:14:14 <The_Kinaesthetic> how do I give?
23:14:42 <Axman6> just paste the link
23:14:48 <The_Kinaesthetic> where's the link?
23:14:55 <The_Kinaesthetic> o nvm
23:15:01 <The_Kinaesthetic> had to press public or private
23:15:01 <The_Kinaesthetic> http://lpaste.net/356659
23:15:35 <The_Kinaesthetic> that's my element function ignoring "Tie" which gives me type issues (I need help with that too but we can save that for later)
23:15:47 <The_Kinaesthetic> it works otherwise
23:15:53 <suzu> so you want to:
23:16:01 <suzu> navigate to p1 elem using the first instruction in p
23:16:05 <suzu> calculate p1/l1
23:16:08 <The_Kinaesthetic> no
23:16:11 <suzu> oh
23:16:15 <The_Kinaesthetic> yes but no
23:16:20 <The_Kinaesthetic> i don't actually need the value
23:16:26 <The_Kinaesthetic> There are only values on the leaves
23:16:31 <suzu> right
23:16:46 <The_Kinaesthetic> so the elemTree function would actually never be used in this other function
23:17:10 <suzu> so you're going to fetch all the p-s first
23:17:13 <suzu> and then hand them over
23:17:22 <suzu> is that right?
23:17:42 <The_Kinaesthetic> idk
23:18:14 <The_Kinaesthetic> call the function "position", If pattern match then -- position (B x) (y:ys) = (y % somehowlengthfunction) + position ....
23:18:24 <The_Kinaesthetic> the "y" would be the P_x
23:18:35 <The_Kinaesthetic> the way I'm thinking about it at least
23:19:36 <Axman6> The_Kinaesthetic: if you want help, saying "idk" when asked a question is a pretty poor way to get it. you are literally the only person who can know, so take some time to think about what it is _you_ want
23:19:53 <The_Kinaesthetic> Sorry, i just didn't understand
23:19:58 <The_Kinaesthetic> then I went on to clarify
23:20:02 <The_Kinaesthetic> what I think i want lmao
23:20:56 <The_Kinaesthetic> Btw I made a function that does the Length part on it's own, but it goes all the way down the tree, which doesn't help for the final equation since I need all the parts.
23:20:57 <The_Kinaesthetic> http://lpaste.net/356660
23:21:14 <The_Kinaesthetic> oops forgot to rename posDenom.
23:21:54 <The_Kinaesthetic> http://lpaste.net/8647889940094386176
23:22:24 <The_Kinaesthetic> that gives the correct final length, so like L_1*L_2*L_3, but I need all the OH
23:22:38 <The_Kinaesthetic> Why don't I just make a list that keeps track and then extract it from that list?
23:22:51 <suzu> sounds good to me!
23:30:13 <The_Kinaesthetic> hmm
23:30:15 <The_Kinaesthetic> type error
23:30:31 <The_Kinaesthetic> really vague one too
23:31:04 <The_Kinaesthetic> why is it sometimes it gives really detailed helpful type errors, but then other times it gives me hardly anything
23:31:40 <Axman6> because giving good error messages for a language with a type system so expressive as Haskell's is difficult
23:31:42 <EvanR> if you lpaste the specific error somebody can help you decipher it
23:32:17 <EvanR> sometimes the line with the clear problem is buried
23:33:54 <The_Kinaesthetic> I think it has to do with the fact that in one case, it returns a list, but in another an integer.
23:34:05 <EvanR> that would do it
23:34:08 <Axman6> well that definitely doesn't type check
23:34:25 <The_Kinaesthetic> http://lpaste.net/6954646886632390656
23:34:28 <EvanR> haskell doesnt allow that
23:34:37 <Axman6> > () :: (Integer ~ [Integer]) => ()
23:34:39 <lambdabot>  error:
23:34:39 <lambdabot>      Couldn't match type ‘Integer’ with ‘[Integer]’
23:34:39 <lambdabot>        arising from a use of ‘it’
23:34:54 <EvanR> maybe you mean [1]
23:35:07 <The_Kinaesthetic> will [1] work with ":" ?
23:35:19 <EvanR> [1] is the same as 1:[]
23:35:21 <The_Kinaesthetic> does [1]:[1] = [1,1] ?
23:35:25 <The_Kinaesthetic> o really
23:35:30 <EvanR> yeah
23:35:31 <Axman6> no
23:35:32 <The_Kinaesthetic> I thought it would do [[1],1]
23:35:49 <Axman6> what would the type of that be?
23:35:56 <The_Kinaesthetic> > [1]:[1]
23:35:58 <lambdabot>  error:
23:35:58 <lambdabot>      • Ambiguous type variable ‘t0’ arising from a use of ‘show_M858772503993...
23:35:58 <lambdabot>        prevents the constraint ‘(Show t0)’ from being solved.
23:36:04 <EvanR> [[1],1] cant be done
23:36:16 <Axman6> that's trying to be bot a [Integer] and [[Integer]]. those arent the same thing
23:36:24 <The_Kinaesthetic> yeah
23:36:43 <The_Kinaesthetic> so what do I do to make my function work. when it reaches a Leaf it has to do something right? 
23:36:51 <EvanR> return [1]
23:36:59 <EvanR> isnt that what you wanted
23:37:17 <The_Kinaesthetic> No, i want a list of every step
23:37:28 <EvanR> actually, please write the type sig of posLength
23:38:20 <EvanR> you want to return a list, that much seems clear, but thats about it
23:38:26 <The_Kinaesthetic> posLength :: Tree a -> [Int] -> [Int]
23:38:45 <EvanR> so all your equations must come out to a list of Int
23:38:53 <EvanR> so [1] ought to type check
23:38:53 <The_Kinaesthetic> ye
23:38:59 <The_Kinaesthetic> Yes but if I return 1
23:39:04 <The_Kinaesthetic> then I'll always get htat
23:39:06 <The_Kinaesthetic> then I'll always get that
23:39:07 <wilornel> Hey #haskell! I was wondering, with the SimpleReflect package ( https://hackage.haskell.org/package/simple-reflect-0.3.2/docs/Debug-SimpleReflect.html ) , why is it that `f g :: Expr` works, but `f g h :: Expr` does not?
23:39:10 <The_Kinaesthetic> my function will become useless
23:39:14 <EvanR> you were gonig to return "1"
23:39:24 <Axman6> :t f
23:39:26 <lambdabot> FromExpr a => a
23:39:32 <The_Kinaesthetic> O true I guess it would do all the recursion
23:39:42 <The_Kinaesthetic> still wouldn't [1]*Int fail
23:39:44 <The_Kinaesthetic> ?
23:39:50 <EvanR> probably
23:40:09 <The_Kinaesthetic> see the way I had it was such : (length x * posLength (x !! y)  ys) 
23:40:13 <EvanR> you can try to work trough it by saying in words what each case is suppose to return, based on what the whole function is supposed to do
23:40:14 <Axman6> wilornel: is there an instance for (FromExpr a, FromExpr b) => FromExpr (a -> b), or something similar?
23:40:37 <EvanR> posLength :: Tree a -> [Int] -> [Int], whats the goal here in words?
23:41:28 <The_Kinaesthetic> I want to take a non-binary Tree as I've defined (scroll up), a list of instructions, and return a list of every branch length along the way
23:41:51 <EvanR> ok
23:42:07 <EvanR> you could start by making a list of branches first, then map length over that
23:42:33 <The_Kinaesthetic> true
23:43:03 <The_Kinaesthetic> I thought about something like that hours ago but it didn't play out the way I wanted but then again I was thinking about my "position" function not my length function.
23:43:14 <The_Kinaesthetic> gimme a sec to try
23:43:14 <hanna> Axman6: seems like the relevant instance is (Show a, FromExpr b)
23:43:23 <Lokathor> does using the LLVM compilation path make smaller binaries?
23:43:27 <Lokathor> or the GHC path?
23:43:50 <The_Kinaesthetic> @EvanR Ouch, I remember the problem
23:43:50 <hanna> f (g h) would work but (f g) h would not
23:43:50 <lambdabot> Unknown command, try @list
23:44:02 <The_Kinaesthetic> I don't want the length of every single Branch, only the ones relevant to the instruction
23:44:24 <EvanR> make a function that returns a list of branches relevant to an instruction?
23:44:35 <The_Kinaesthetic> I mean maybe I could get the length of every branch and then later take the ones I need but wouldn't that be excess computation?
23:45:26 <hanna> The_Kinaesthetic: perhaps not if you use laziness to your advantage?
23:46:30 <The_Kinaesthetic> Thanks for the suggestion. Don't see how I could but maybe I don't understand lazy evaluation enough
23:46:48 <The_Kinaesthetic> the branch might be the 3rd one of 5
23:46:53 <The_Kinaesthetic> and i'd only need that length
23:47:02 <EvanR> a basic strategy would be to make a list of all branches, then filter out the ones you detect to be irrelevant 
23:47:36 <The_Kinaesthetic> hmm
23:47:37 <Seege> Hey guys, what does ':>' mean in data type definition?  e.g., data Rose a = a :> [Rose a]
23:47:48 <The_Kinaesthetic> I was curious about that too
23:47:52 <EvanR> its a constructor
23:47:52 <The_Kinaesthetic> I think they define it themselves
23:48:05 <EvanR> > 2 :+ 3
23:48:06 <Axman6> Seege: it's a data constructor, like : for list
23:48:07 <lambdabot>  2 :+ 3
23:48:23 <EvanR> > (\(x :+ y) -> y) (2 :+ 3)
23:48:26 <lambdabot>  3
23:48:29 <Axman6> Seege: it has type: a -> [Rose a] -> Rose a
23:48:47 <Seege> Ah, thanks guys
23:48:58 <EvanR> infix constructors need to start with a :
23:49:00 <Axman6> ie, if you give it an a and a list of rose trees containing a's, you will hey back an rose tree containins a's
23:58:44 <The_Kinaesthetic> lmao
23:58:47 <The_Kinaesthetic> spent all that time
23:59:10 <The_Kinaesthetic> making a function that filters out everything but the path to my value, then I realized what I need are lengths, so I need anything anyways!
23:59:25 <The_Kinaesthetic> i need everything*** anyways
