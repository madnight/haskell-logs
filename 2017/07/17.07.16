00:01:27 <shafox_> Cale: yes I want to process multigigabyte XML file. But first I would try with a smaller file size varying 1mb or so.
01:07:31 <mson> How can I zip over input lists IO [a] and IO [b]?
01:08:46 <dysfun> do as' <- as; bs' <- bs; return zip as' bs'
01:09:11 <dysfun> that can probably be improved on
01:12:39 <int-e> :t \(as :: IO [a]) (bs :: IO [b]) -> zip <$> as <*> bs
01:12:41 <lambdabot> IO [a] -> IO [b] -> IO [(a, b)]
01:12:57 <gryle> There is also liftM2 from Control.Monad
01:13:10 <gryle> :t (liftM2 zip)
01:13:11 <lambdabot> Monad m => m [a] -> m [b] -> m [(a, b)]
01:13:20 <int-e> dysfun: that looks fine, except that you need parentheses around the zip (or use $)
01:14:34 <dysfun> quite probably. i didn't type it into ghci
01:14:42 <mson> nice, thanks both
01:14:56 <mson> or... throth...
01:15:09 * dysfun hands mson 'all'
01:15:33 <mson> that's a good word
01:15:53 <dysfun> :)
01:17:28 <boxscape> When I add "import Language.Haskell.Exts" to my .hs file, stack tells me that it's a member of the hidden package haskell-src-exts-1.18.2, but when I try to add haskell-src-exts >= 1.18 && < 2 to "build-depends", stack says that its configuration has no specified version of that package. What can I do about this?
01:18:29 <dysfun> stack locks down hackage to a subset of versions chosen by your resolver
01:18:59 <dysfun> if you remove the version bound from your cabal file, it may well magically start working
01:19:30 <flounders> Has anyone seen an error like this? http://lpaste.net/356963
01:20:04 <zomg> I wonder why it says "hidden", is there some technical explanation for this? It always seemed kind of confusing to me, when all it seems to mean "this isn't in your cabal file" :P
01:20:11 <boxscape> dysfun: stack now says that haskell-src-exts must match -any, but the stack configuration has no specified version
01:20:21 <zomg> at least stack seems to be smart enough to suggest that you can probably fix this by adding it there
01:20:29 <dysfun> boxscape: in which case you may add it to stack.yaml with a specific version
01:21:11 <flounders> zomg: I tried the suggestion and even modified my executable that is bringing wreq in which has foundation as a dependency to use the ld option -static, but the same thing.
01:21:13 <dysfun> zomg: 'hidden' means "you haven't specified a dependency on this, so to prevent you from accidentally making the build break, we're telling you instead of letting it just happen
01:21:34 <flounders> Oh sorry wrong conversation.
01:21:35 <boxscape> dysfun: to which field?
01:22:01 <dysfun> extra-deps
01:22:35 <boxscape> hm, I actually already put it in there earlier while testing and forgot to take it out again. It doesn't make a difference :/
01:22:38 <dysfun> e.g. extra-deps: [haskell-src-exts-1.18.2]
01:23:04 <boxscape> yeah, that's exactly what my extra-deps look like
01:23:08 <dysfun> oh :/
01:23:09 <zomg> dysfun: yeah, but why doesn't it just say the dependency is missing or something instead of "hidden"
01:23:12 <MarcelineVQ> there isn't a resolver without haskell-src-exts, you shouldn't need extra-deps to use an unspecified version of it
01:23:32 <MarcelineVQ> lpaste your cabal and stack files
01:23:36 <zomg> dysfun: at least until I learned what hidden means in this context it was always "wtf is a hidden package"
01:23:40 <dysfun> zomg: i'll agree it's not the most helpful term, but it's not inaccurate either, it has been deliberately hidden from you
01:23:56 <MarcelineVQ> and the full original error
01:24:12 <zomg> dysfun: yeah :) it's better with stack though because at least it points out to the most likely solution in its message now
01:24:45 <dysfun> yes, stack has made using haskell for real things much easier for beginners
01:25:34 <dysfun> flounders: but it says recompile it with PIC, not static
01:26:38 <flounders> dysfun: So I added -static for the ld-options and then when I invoked stack I passed --ghc-options="-fPIC".
01:27:01 <flounders> The reason I added -static was a suggestion from a StackOverflow post I saw.
01:27:10 <boxscape> stack.yaml: http://lpaste.net/356964 .cabal: http://lpaste.net/356965 stack error: http://lpaste.net/356966
01:27:19 <dysfun> irta requiring you to tell the *linker* to use PIC
01:27:54 <dysfun> i dunno what higher level ghc options do to the linker
01:28:46 <dysfun> yeah, my ghc doesn't have -fPIC
01:28:55 <dysfun> it's telling you you need it in the linker args
01:29:27 <flounders> Alright I'm doing some digging there and I'll see if it makes a difference.
01:29:27 <cocreature> flounders: are you on arch?
01:29:29 <dysfun> there's a cabal option for that, but i forget what it's called
01:29:32 <flounders> cocreature: Yes I am.
01:29:42 <cocreature> flounders: apparently installing ncurses5-compat-libs helps https://github.com/commercialhaskell/stack/issues/3268#issuecomment-315436707
01:30:52 <flounders> cocreature: Installing that now. I'll let you know if it has an impact.
01:31:29 <cocreature> arch is really not painful for Haskell devs atm :/
01:32:49 <mson> How do I map over the elements IO [String], printing each out?
01:34:10 <cocreature> :t \xs -> mapM_ print =<< xs
01:34:11 <lambdabot> (Show a, Foldable t) => IO (t a) -> IO ()
01:34:19 <cocreature> or just use do notation
01:36:56 <mson> thanks!
01:42:32 <flounders> cocreature: That did the trick. I wasn't even aware of the new default flags.
02:08:41 <boxscape> huh. I reset my project to an earlier state, put everything into the .cabal file again, and now it just works.
02:35:33 * hackagebot transformers-bifunctors 0.1 – Bifunctors over monad transformers. – https://hackage.haskell.org/package/transformers-bifunctors
02:41:58 <James123_> I was thinking of writing a small compiler in haskell. Are the haskell lexer / parser tools easy to use compared to ocaml's ocamllex, menhir? Thank you!
02:44:45 <cocreature> James123_: most people tend to use one of the various parser combinator libraries such as megaparsec instead of triditional lexer/parser tools. they have various benefits (most notably you don’t need to generate the code which simplifies development and debugging) but they also have a cost (you usually need to left-factor your grammar). but we do also have traditional lexer and parser generators, e.g. alex
02:44:47 <cocreature> and happy which are comparable to the tools you find in other languages.
02:44:59 <cocreature> I don’t have any experience with the ones in ocaml specifically so I can’t comment on that
02:47:00 <James123_> cocreature: Thank you, I will give alex/happy a try
03:00:18 <f-a> I am modifying a file in my project and invoking `cabal new-build`. "Up to date". What's the way to trigger a full rebuild?
03:01:20 <srhb> f-a: cabal clean first perhaps?
03:02:13 <f-a> cabal clean cleans old-style dist/ folder. Unfortunately I haven't found a cabal new-clean alternative which isn't rm -rf dist-newstyle/
03:05:06 <ongy> afaik that's the current new-clean. But it's interesting that the build doesn't trigger when you modify the file
03:05:16 <ongy> are you reading that in with TH? or ist it a normal source file?
03:05:59 <f-a> ongy: a very normal file
03:07:29 <f-a> ok, I am a moron, I now realise I did erase other-modules: by mistake
03:09:53 <f-a> yep, that fixed it. Now the question is "why did cabal allow it", but I guess it's a sensible default
03:10:08 <cocreature> cabal & 8.2 will finally warn about missing other modules
03:10:16 <cocreature> ghc 8.2 that is
03:10:29 <f-a> cocreature: fair behaviour
03:11:07 <cocreature> the problem is that ghc automatically figures out that it needs to build things you import but cabal doesn’t track them if they’re not in other-modules
03:11:14 <cocreature> so your build succeeds but you don’t get rebuilds
03:11:23 <f-a> yeah exactly what happened here
03:11:34 <cocreature> ghc 8.2 adds an option where it issues a warning if it tries to build modules not specified explicitely
03:12:24 <Enamex> I have a question on Stack and its provided GHC:
03:12:50 <Enamex> I can do `stack build` in a stack-created directory and everything builds fine
03:13:38 <Enamex> So I want to pass a flag to the underlying GHC invocation and say instead `stack build --ghc-options=-flag` but it complains that GHC "ghc: no input files" :/
03:14:13 <cocreature> Enamex: can you be a bit more specific? what’s the exact command you issued?
03:15:13 <Enamex> stack build --ghc-options=-fno-code
03:16:26 <cocreature> hm that looks reasonable. you might want to add a --verbose and see the command that stack in invoking
03:17:27 <cocreature> although fno-code seems like it could cause errors where dependencies are not being built so maybe also try other flags
03:17:54 <Enamex> Aha
03:18:19 <Enamex> There was an issue on Github that made me assume that ghc flags passed through stack only applied to my own module
03:19:55 <cocreature> right but your modules can depend on each other
03:20:40 <cocreature> I think it should still work but making sure that it’s not -fno-code is not the culprit here is probably still a good idea
03:21:51 <Enamex> Basically I'm trying to cook up a command to do type checking without code-gen
03:21:59 <cocreature> use ghcid?
03:22:41 <Enamex> For now though the error refers to 1:
03:22:43 <Enamex> Warning: the following files would be used as linker inputs, but linking is not being done: .stack-work/dist/x86_64-linux/Cabal-1.24.2.0/build/Lib.dyn_o
03:22:53 <Enamex> 2:
03:22:54 <Enamex> Warning: the following files would be used as linker inputs, but linking is not being done: .stack-work/dist/x86_64-linux/Cabal-1.24.2.0/build/Lib.dyn_o
03:23:11 <cocreature> that’s a warning not an error
03:24:01 <s4tyendr4_> hello people
03:24:55 <s4tyendr4_> is there any one online now..??
03:25:32 <f-a> many of us s4tyendr4_ , just ask and wait for reply
03:26:20 <Enamex> cocreature: Sorry, I copied the wrong line
03:26:24 <Enamex> 2: ghc: no input files
03:26:55 <Enamex> Stack colors them as warnings but it's weird that "no input files" is just a warning
04:12:39 <Wizek> Hello. If typed-holes are currently a warning, can I make them into a compile time error?
04:13:19 <ongy> -Werror
04:13:50 <ongy> but that will make all warnings errors. From what I have read here, 8.2 will get some flag to turn specific warnings into errors
04:13:52 <Wizek> ongy, But that would turn all warnings into error, no?
04:14:00 <Wizek> I see
04:16:33 <Wizek> ongy, might you know what those new flags are? Maybe I can check out ghc-8.2.1-rc3 
04:18:05 <osa1> Wizek: typed holes generate errors by default, no? how did you turned typed hole errors into warnings?
04:19:18 <osa1> Wizek: just find the warning you want here https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/flags.html#warnings then use `-Werror=<warning flag>`
04:21:44 <Wizek> osa1, Yes, I remember them to be errors too, but this particular project I am currently working on made use of `-fdefer-type-errors` and similar flags liberally. Now I am trying to turn these off gradually per module.
04:22:24 <cocreature> why would anyone use -fdefer-type-errors for anything else than maybe enabling it for a short time during development …
04:23:54 <osa1> Wizek: ahh, I see. yeah you can use `-Werror=typed-holes` to override that: http://lpaste.net/356967
04:24:10 <osa1> (I'm using GHC HEAD)
04:24:26 <Wizek> osa1, thanks!
04:24:30 <cocreature> -fno-defer-type-errors should also work
04:24:33 <cocreature> even with 8.0
04:25:01 <Wizek> cocreature, Yes, that's already set via options_ghc for the module
04:25:08 <Wizek> cocreature, no dice
04:25:24 <Wizek> cocreature, I suspect -fwarn-typed-holes might play a role
04:25:53 <cocreature> there is also -Wno-deferred-type-errors, not sure if there is a difference
04:30:50 * hackagebot plot-light 0.1.1 – A lightweight plotting library, exporting to SVG – https://hackage.haskell.org/package/plot-light
04:40:16 <Enamex> Can I ask about things in papers here?
04:40:43 <Enamex> For example, a question about a declaration in http://web.cecs.pdx.edu/~mpj/pubs/fundeps-esop2000.pdf (functional dependencies paper)
04:42:33 <cocreature> Enamex: sure (assuming the papers are somewhat Haskell related)
04:43:43 <Enamex> Awesome!
04:43:56 <Enamex> OK, so on page 10 of the linked paper we have this definition:
04:44:02 <Enamex> instance ( Eq i ) ⇒ FiniteMap i e [( i , e )] where ...
04:44:28 <Enamex> I'm confused on what `e` could be here. It looks like a weird recursive type. To summarize:
04:44:52 <Enamex> class FiniteMap i e fm | fm -> ( i , e ) where ...
04:45:06 <cocreature> i is the index type and e is the type of the values stored in the map
04:45:11 <cocreature> :t Map.lookup
04:45:12 <lambdabot> error:
04:45:12 <lambdabot>     Not in scope: ‘Map.lookup’
04:45:12 <lambdabot>     Perhaps you meant one of these:
04:45:17 <cocreature> :t Data.Map.lookup
04:45:18 <lambdabot> Ord k => k -> M.Map k a -> Maybe a
04:45:27 <cocreature> compare that to i -> fm -> Maybe e
04:45:36 <bollu> cocreature ping
04:45:41 <cocreature> pong
04:45:42 <bollu> does llvm-hs support "getSizeOf"?
04:46:49 <Enamex> cocreature: But then doesn't the element type e correspond to (i, e) (it's the element type in [(i, e)]?
04:47:36 <cocreature> Enamex: no the idea is that to store a map that maps 'i's to 'e's you can store a list of tuples
04:47:41 <cocreature> but the values in that map are the 'e's
04:48:06 <Enamex> Ooooh
04:48:28 <cocreature> :t Data.List.lookup
04:48:30 <lambdabot> Eq a => a -> [(a, b)] -> Maybe b
04:48:36 <cocreature> basically that
04:48:58 <cocreature> bollu: I don’t think so
04:49:24 <cocreature> bollu: getTypeAllocSize exists
04:50:38 <cocreature> bollu: getSizeOf is just a gep anyway, no?
04:51:20 <cocreature> yeah it’s a gep
04:51:23 <bollu> yes
04:51:36 <bollu> cocreature that is what it compiles to :) 
04:51:42 <cocreature> I’m open to adding a helper function to llvm-hs for that
04:52:36 <bollu> ah, OK
04:52:36 <cocreature> well what it compiles to depends on how geps are lowered. my point is that getSizeOf does not even exist in llvm’s internal AST. it’s just a convenience wrapper around creating a gep
04:52:37 <bollu> cool
04:53:41 <bollu> right
04:56:05 * hackagebot hedgehog-quickcheck 0.1 – Use QuickCheck generators in Hedgehog and vice versa. – https://hackage.haskell.org/package/hedgehog-quickcheck
05:15:16 <bbear> hi 
05:16:30 <bbear> i'm looking at that right now : https://www.youtube.com/watch?v=JMP6gI5mLHc&t=2830s ; speaker is cool. It makes sense. my CT knowledge is a litte bit enlightened by his talk.
05:18:21 <bbear> the guy's accent is weird though. Never heard of it.
05:18:55 <cocreature> he’s dutch
05:26:52 <MatthiasGoergens> Hello!  Does anyone know why QuickCheck is so tame in its generation of eg Floats?
05:29:14 <osa1> anyone know why criterion doesn't print out the GC stats it collected during a measurement? the information is there, but it's not printed anywhere as far as I can see
05:29:22 <osa1> I can't see a flag to print those
05:29:25 <srhb> MatthiasGoergens: can you elaborate on "tame" ?
05:32:08 <MatthiasGoergens> QuickCheck never produces NaN or infinities or values just below infinity.
05:32:42 <MatthiasGoergens> See eg https://github.com/HypothesisWorks/hypothesis-python/blob/master/src/hypothesis/searchstrategy/numbers.py#L92 for an interesting take.
05:33:35 <MatthiasGoergens> I ported that idea from hypothesis to QuickCheck on my private fork, but am asking if anyone knew of a good reason for QuickCheck not being meaner before I make a pull request.
05:34:25 <srhb> Ah, okay :)
05:34:48 <cocreature> I guess you could argue that a lot of people don’t care about the behavior of their code in that case
05:35:27 <MatthiasGoergens> Probably---and if you introduce those cases in the generator now, you'd break a lot of tests.
05:36:10 <MatthiasGoergens> The right approach, if there wasn't a status quo bias, would be too document those with not (isNan x) ==> restOfProperty
05:36:13 <cocreature> yeah although quickcheck did become “meaner” when it comes to unicode text in the last update so the maintainers don’t seem to be opposed in general to making changing things
05:36:29 <MatthiasGoergens> We have a quickcheck fork for our hacked-up ocaml at work.
05:36:37 <MatthiasGoergens> Or rather, a quickcheck part to ocaml.
05:37:22 <MatthiasGoergens> And so I was looking into that topic in general.  Python's hypothesis is a great fount of ideas.  The author is smart, understands Haskell's QuickCheck, and had to come up with some good ideas for working around Python's lack of static types.
05:37:38 <MatthiasGoergens> Some of those ideas are worth porting back to Haskell.
05:38:23 <cocreature> you might also want to look into hedgehog which is a new Haskell library for property based testing
05:39:23 * hackagebot hcom 0.0.0.1 – Haskell COM support library – https://hackage.haskell.org/package/hcom
05:41:03 <MatthiasGoergens> Thanks!
05:41:10 <MatthiasGoergens> I also looked into 'jack' a bit.
05:42:26 <MatthiasGoergens> Just looked at hedgehog: it has integrated shrinking!  That's dear to my heart after seeing that it's possible and relatively easy to get.
05:43:54 <cocreature> http://teh.id.au/posts/2017/07/15/state-machine-testing/index.html is also pretty nice
05:44:15 <cocreature> (although that’s not specific to hedgehog, there is also a library for doing that with quickcheck)
05:46:40 <ltielen> hi all, just updated my arch linux and now stack is giving some weird error: "Unable to find installation URLs for OS key: linux64-ncurses6-nopie". Also cant seem to find my installed ghc anymore (installed with stack)
05:47:02 <cocreature> ltielen: https://github.com/commercialhaskell/stack/issues/3268
05:48:02 <ltielen> cocreature: thanks, and wow quick reply. ill check issue list first next time :)
05:48:22 <cocreature> ltielen: you’re not the first person to ask this and I’ve run into this myself :)
05:49:14 <MatthiasGoergens> cocreature: Looks nice!  I have read a bit about that kind of testing when working with hypothesis.  (I used hypothesis a lot at my last job---since Google insists on using inferior languages..)
05:49:33 <MatthiasGoergens> We'll probably use state machine testing for our UIs soon.
05:49:39 <zomg> this ncurses lib thing seems pretty common on arch :P
05:49:49 <cocreature> MatthiasGoergens: if you don’t mind me asking, where are you working now?
05:49:50 <zomg> don't recall having to deal with that in any other distro I've used
05:50:02 <MatthiasGoergens> We are revamping our UI approach to be closer in line with the elm approach, and not the crazy weird side-effectful monstrosity we have today at work.
05:50:20 <zomg> (I also recall having some ncurses related issue which was solved by installing some random package like that on arch)
05:50:22 <cocreature> zomg: that’s not really related ncurses. it’s due to arch having changed the default gcc flags
05:50:32 <MatthiasGoergens> cocreature: Bloomberg in London.
05:50:35 <zomg> cocreature: ah
05:51:13 <MatthiasGoergens> zomg: arch is a bit bleeding edge.  I do like it, though.  And overall even though it gives me minor issues every so often, it's far from the six-monthly trainwreck that ubuntu upgrades were.
05:51:42 <cocreature> yeah in general arch is mostly fine. but the last month or so hasn’t been very pleasant for Haskell devs
05:52:03 <ongy> bloomberg? that's finance, isn't it?
05:52:05 <zomg> MatthiasGoergens: yep :P
05:52:22 <zomg> I still run ubuntu lhs on my vps but otherwise I'm using arch
05:52:29 <zomg> *lts
05:53:43 <ltielen> zomg: same reason im using arch
05:56:04 <MatthiasGoergens> ongy: yes, finance.  We are doing the standard FP in finance thing: https://www.microsoft.com/en-us/research/publication/composing-contracts-an-adventure-in-financial-engineering/
05:57:13 <MatthiasGoergens> On the side, I'm trying to introduce some more Haskell by porting our Frankenstein's monster of a build system (Gnu Make + OMake + extra in-house wrapper around Gnu Make) to shake.
06:03:09 <bbear> I was just thinking..
06:03:45 <bbear> there's no way to tell a FP system how to make an addition
06:04:08 <bbear> except by telling him that x+0 = x and x+1=x+1
06:04:23 <bbear> I mean the recursive addition function 
06:05:07 <erisco> x+1=x+1 is true but doesn't help you calculate :P
06:05:51 <erisco> there are lots of ways to add... the question is just what you are adding
06:06:49 <bbear> >let add x y | y==0 = x | y==1 = x+1 | otherwise = add (add x 1) (y-1)
06:07:27 <ongy> I wouldn't put in the y==1 case
06:07:42 <erisco> how about add 0 y = y; add x y = 1 + add (x - 1) y
06:07:59 <bbear> yes it's cooler without the y==1
06:08:17 <bbear> I didn't notice it wasn't needed.
06:08:22 <erisco> this is how you add Peano naturals, i.e. add Z y = y; add (S x) y = S (add x y)
06:08:37 <erisco> but there are other ways to represent numbers and your algorithm to add them will be different
06:09:20 <erisco> commonly with computers we are adding bit fields
06:09:23 <bbear> bootstraping a compiler with Peano's axiomatics is not possible, 
06:09:58 <bbear> erisco: yes, the + operation is something more like you would do without axiomatic
06:10:15 <erisco> I don't know what you mean
06:10:22 <bbear> if you try to describe it for a machine, it would be if (shift register) then shift register etc
06:10:58 <bbear> with bit shifting and XOR operations etc. It wouldn't look anywhere like an axiomatic system.
06:11:01 <erisco> are you talking about what instruction set is necessary to implement addition?
06:11:07 <bbear> erisco: yes.
06:11:41 <erisco> not sure how that is relevant to Haskell... but nonetheless it is a sensible question... look to Turing machines
06:12:16 <erisco> I doubt you need all of a Turing machine but at least if you have one you can do addition
06:13:01 <bbear> yes, I was sure that someone was thinking about it. But a nowadays processor, if conceptually looks like a Turing machine, is probably as far as it is possible from a conceptually pure abstract theoretical computer.
06:13:31 <erisco> that doesn't matter
06:13:40 <bbear> yes
06:14:02 <MatthiasGoergens> You can do arithmetic with church numerals, too.
06:14:24 <MatthiasGoergens> And you are not restricted to unary.  You can implement decimal or binary or roman numerals etc.
06:14:27 <erisco> yes, that was another example I wanted to mention, thanks MatthiasGoergens
06:14:31 <MatthiasGoergens> (I like base negative 2. :)
06:15:26 <ongy> how do you encode decimal 2 in base negative 2?
06:15:33 <MatthiasGoergens> Of course, you could conceptually have eg peano in your language, but have the compiler recognise and turn into something optimized for your target machine---like ones complement binary.
06:15:56 <MatthiasGoergens> (Or rather two's complement these days.)
06:16:03 <MatthiasGoergens> ongy: 110
06:16:08 <MatthiasGoergens> 4 - 2.
06:16:23 <bbear> yes -- actually I was thinking that all the purity must come from the language not the machine.
06:16:35 <MatthiasGoergens> Working out how to do addition (or even just incrementing) in base negative two is instructive.
06:17:06 <bbear> (I mean for an example I don't know of arbitrary size integer system hardcoded into a machine.)
06:17:13 <ongy> MatthiasGoergens: that implies 2s complement, right?
06:17:23 <bbear> MatthiasGoergens: thanks for the idea, I will look into it.
06:17:24 <erisco> why is implementing the language on the machine interesting to you?
06:17:30 <bbear> BTW, when I do this : let add x y | y==0 = x | otherwise =  add (x + 1) (y-1)
06:17:34 <MatthiasGoergens> bbear: what's interesting is that a program written in a pure language compiled with a very optimizing compiler and a great GC won't look so different in its memory access patterns to eg a C program:
06:17:58 <bbear> it's true that due to laziness, it actually is equivalent to just x+y ?
06:17:58 <MatthiasGoergens> most entities die young, so their memory location will be overwritten frequently---just as if they had been mutation.
06:18:27 <MatthiasGoergens> bbear: equivalent in what sense?
06:18:29 <bbear> MatthiasGoergens: you did a mistake with your buffer ?
06:18:40 <MatthiasGoergens> I don't think laziness has anything to do with it?
06:18:43 <MatthiasGoergens> bbear: buffer?
06:18:44 <bbear> I mean strictly speaking, doing in ghci a call to add 2 3
06:18:52 <bbear> is equivalent to evaluating 2+3
06:19:02 <erisco> yeah, you have to specify what equivalence you mean
06:19:09 <erisco> equality is hard :P
06:19:34 <MatthiasGoergens> You probably get the same answer.  But it might take different amounts of time and memory.
06:19:37 <erisco> is it functionall equivalent? well if we are talking about nonnegative integers, sure, looks so
06:19:41 <bbear> « most entities die young, so their memory location will be overwritten frequently---just as if they had been mutation. » <-that doesn't look like a C program ?
06:19:51 <bbear> (actually it looks like a C program sorry)
06:20:17 <MatthiasGoergens> bbear, why?  I am just talking about the observable memory access patterns.
06:20:31 <MatthiasGoergens> The 'entities' exist purely on the level of your source language.
06:20:58 <bbear> MatthiasGoergens: I thought my function would evaluate ultimately to to (x + 1 + ( 1 + ( 1 + ( 1 + 0 ) ) ) )
06:21:19 <MatthiasGoergens> In C you have long living mutable entities, in Haskell you have short-lived immutable entities.  They both get compiled to a bunch of repeated accesses to a tiny amount of memory (that fits into cpu cache).
06:21:39 <MatthiasGoergens> Sorry, gotta go now.  It's fascinating to talk about these things.
06:21:48 <bbear> yes me too
06:21:57 <bbear> not too hard on a sunday
06:22:57 * hackagebot hcom 0.0.0.2 – Haskell COM support library – https://hackage.haskell.org/package/hcom
06:23:07 <bbear> would be more like ( ( ( ( ( x + 1 ) + 1 ) + 1 ) + 1 ) + 0 )
06:25:34 <erisco> there is a chasm between the language and what happens on the computer
06:25:54 <erisco> you can talk about the expression, that is a language thing, or you can talk about what is happening on the computer
06:26:15 <erisco> or you can talk about the software that translates one to the other (the compiler)
06:27:19 <erisco> asking if the computer does the same thing when you use your "add" versus using "+" is different than asking if they are functionally equivalent (a language thing)
06:27:48 <erisco> and different than asking if they take the same time and space (language things, but also can be analysed as a computer thing)
06:28:32 <bbear>  I started this discussion because I re-discovered bit-shifting operators with Scala
06:28:52 <bbear> Now I want to develop my own virtual CPU :|
06:29:08 <erisco> but generally speaking, Haskell is one world and computers are another
06:29:44 <bbear> don't be so though with computers :)
06:30:08 <bbear> I see what ya mean.
06:30:11 <erisco> I am not being tough, I am saying they are to be considered separately
06:30:39 <erisco> there are times to consider the middle ground (the compiler and runtime), like if we find a program runs too slowly
06:32:31 <erisco> Haskell is not a tool to move bits around in memory
06:32:47 <bbear> actually I was more like thinking about how FP can be thought to be as close as possible as the machine under and I was thinking how a functional (in the sense FP) machine could work
06:32:48 <erisco> it is a programming language that incidentally can be executed on a computer
06:33:20 <bbear> erisco: I totally agree with you -- though most ppl expect to actually run their programs after they wrote it.
06:34:10 <erisco> how do you qualify a functional machine?
06:34:10 <cocreature> bbear: there is some research in function cpus but I don’t think any of them ever took off
06:37:30 <cocreature> conal elliot was working at some cool startup which had some kind of fpga that could be reconfigured very fast and they were using it to execute haskell code in parallel
06:37:37 <cocreature> I think they ran out of funding sadly
06:38:46 <erisco> a company called Tabula iirc
06:44:18 <erisco> a bunch of circuits isn't ever what functional programming is about, so I think you need some other description of what a functional computer is
06:44:40 <shafox_> Having trouble with packages in stack. I have create a new stack project with the simple template. And I created a new dir called MyApp in the same dir and added the name to the packages config in stack.yml but when I do stack build or stack ghci I get error saying no .cabal file found. What should be in there for the package ? Where can I get more info ? 
06:45:16 <bbear> erisco: a functional computer is simply a function
06:45:30 <bbear> (immutable) ?
06:45:41 <erisco> I have seen functions in stock at my local computer store
06:45:51 <bbear> to be honest with you I can't even give a def. of pure functional programming
06:45:56 <bbear> it would be harder for a computer.
06:46:16 <erisco> I have not* ... worse kind of typo
06:47:00 <duncan^> if a functional computer is just a fucntion and this function is expressed in pure lambda calculus how much paper does it take to write the function out
06:47:24 <bbear> -- erisco: can you see the difference between imperative/shared state programming and pure fonctional programming ?
06:47:34 <bbear> -- duncan^ i don't know
06:49:19 <erisco> the definitive difference? no, but they are described with different methods, particularly operational semantics versus denotational semantics
06:49:25 <erisco> and some languages have axiomatic semantics
06:50:36 <erisco> with a procedural language you have a state before, some instruction, and a state after
06:54:24 <bbear> it's the same for a computer.
06:55:02 <erisco> no, you are mistaking my point... I am not talking about the model of the computer, I am talking about the computer
06:55:10 <erisco> the wires
06:55:55 <erisco> if we weren't talking about that then I can't see any reason not to call our modern computers functional computers merely because they can execute functional programs
06:56:29 <erisco> so to have some meaningful distinction I assumed you are talking about how the computer works, which is a question of how it is constructed, i.e. the wires
06:59:10 <erisco> so the fpga computer conal was working with has a different way of operating, and presumably more conducive to the kinds of things we like to do with FP
06:59:36 <Enamex> What are 'uniques' exactly in GHC dev? Reading this: https://ghc.haskell.org/trac/ghc/wiki/DeterministicBuilds
07:00:18 <cocreature> Enamex: unique identifiers
07:00:35 <shafox_> What should be in the package cabal file that stack expects for the package in the project dir ?
07:00:36 <cocreature> they’re used for a variety of different things afaik
07:00:51 <erisco> you could imagine another kind of computer based on neurons, which is something people are trying to do (I hear)
07:03:54 <Enamex> cocreature: I'm interested in their uses and the problems that leads them to be generated non-deterministically. Is there somewhere I can read or someone to ask?
07:05:28 <cocreature> Enamex: not sure, I guess you could try #ghc.
07:05:56 <cocreature> having unique names for things can generally be useful
07:06:59 <cocreature> and because you usually don’t care about what those names are, it’s sometimes tempting to base them on things that are not deterministic, e.g., just incrementing them sequentially will result in nondetirministic allocation of uniques if your program is multithreaded
07:09:45 * hackagebot plot-light 0.1.2 – A lightweight plotting library, exporting to SVG – https://hackage.haskell.org/package/plot-light
07:24:55 * hackagebot list-transformer 1.0.2 – List monad transformer – https://hackage.haskell.org/package/list-transformer
07:25:25 <APic> B-)
07:27:53 <fendor> hi, how can i tell stack to build a package from github for my project?
07:28:49 <fendor> if i add it to packages with location, it complains that this should be specified in extra-deps
07:30:09 <cocreature> fendor: https://docs.haskellstack.org/en/stable/yaml_configuration/#complex-package-locations-location
07:32:16 <fendor> cocreature, thanks, but I'm still unable to make the correct changes to the yaml file. currently, it is a default template with the following changes https://pastebin.com/BsE0jnf6
07:32:45 <fendor> but stack still complains, that there is no extra-dep setting found
07:33:07 <cocreature> fendor: unindent extra-dep
07:33:14 <cocreature> fendor: it needs to line up with location
07:34:14 * hackagebot language-glsl 0.2.1 – GLSL abstract syntax tree, parser, and pretty-printer – https://hackage.haskell.org/package/language-glsl
07:34:15 * hackagebot plot-light 0.2 – A lightweight plotting library, exporting to SVG – https://hackage.haskell.org/package/plot-light
07:34:15 <fendor> cocreature, oh tanks, yeah this resolved the problem, but the project cant find the packages now, do i have to add this extra build dependency to the cabal file?
07:34:29 <cocreature> fendor: yes
07:34:55 <fendor> and stack will notice, that i mean my local version and not the version available on hackage?
07:34:59 <cocreature> fendor: in general you can think of the cabal file as declaring which dependencies are needed by your project and the stack.yaml file as declaring where to find them
07:35:10 <cocreature> yes
07:35:52 <fendor> cocreature, oh thanks, this helps me a lot and now it also compiles, thanks a lot
07:40:22 * hackagebot plot-light 0.2.1 – A lightweight plotting library, exporting to SVG – https://hackage.haskell.org/package/plot-light
07:43:12 <bbear> what is forall keyword ?
07:44:42 <zomg> it's used for stuff like scoped type variables and some other things
07:47:36 <bbear> I see
07:47:36 <Filthy_Causual> I have a question about stack. Is there a way to auto clean up extra-deps in stack.yaml?  Currently my small project has 60+.
07:47:52 <cocreature> it’s used for explicit foralls, scoped type variables, rank n types and existential types
07:48:04 <bbear> rank n types ?
07:48:19 * bbear is googling rank n types
07:49:00 <cocreature> iirc https://ocharles.org.uk/blog/guest-posts/2014-12-18-rank-n-types.html is a pretty good explanation
07:49:13 <cocreature> but admittedly it’s been a while since I’ve looked at it
07:50:24 <bbear> Don't have time to dive into this but it's interesting. 
07:50:40 <c_wraith> bbear: Rank N types are really cool, but you need a good grasp of where regular Rank 1 polymorphism breaks down before it really is clear.
07:50:45 <bbear> I am never going to get going reading FP tutorials through all day like that.
07:51:04 <cocreature> the good thing about rankntypes are that they are a fairly natural generalization of the things you already know
07:58:56 <Enamex> Doesn't the Base/Prelude source come with GHC?
07:59:07 <setre> anyone use keter? how do you set environment variables for apps?
08:00:24 <Metaxi> Bonus, are you here?
08:08:14 <c_wraith> Enamex: I don't believe so, at least for binary distributions.  I'm pretty sure they just have the compiled versions.  (4 compiled versions, actually, for... reasons)
08:20:34 <shafox_> How do I install cabal-install using stack for the whole system ? 
08:21:15 <c_wraith> stack probably already installed it.
08:21:24 <c_wraith> It uses cabal-install to do the actual package installation
08:21:25 <shafox_> cant find it. 
08:22:06 <Enamex> It's under stack itself
08:22:12 <Enamex> So stack cabal, I think
08:23:34 <Enamex> Doing this: main = do { s <- return ("fooh" ++ undefined) >>= return . const "bar" ; putStrLn "lived" }
08:24:04 <Enamex> I'd have expected the "fooh" ++ undefined to be evaluated because of the bind. What am I misunderstanding?
08:24:08 <shafox_> I created a project using stack new appname simple, i then i added one module to the project but it complaints about not finding cabal file the module, which has some code. And also if I use import Distribution.Simple in my main file, it complaints that https://gist.github.com/shadow-fox/a72d7440b0bf32e9264f2323278c2ae9 . 
08:24:48 <glguy> Enamex: Why would bind evaluate that?
08:26:58 <Enamex> Actually, I don't know. Read something a while ago talking about bind explicitly in sequencing terms.
08:27:16 <Enamex> Oh, also it's compiled with -XStrict
08:27:37 <glguy> Strict just sprinkles strictness annotations on binders, it doesn't make the language strict
08:27:45 <glguy> you should ignore -XStrict
08:28:11 <glguy> In IO >>= sequences actions. In your case the action was 'return ("fooh" ++ undefined)'
08:28:26 <glguy> not the list itself
08:28:34 <glguy> and returns doesn't evaluate its argument
08:29:16 <glguy> > take 3 ("fooh" ++ undefined)
08:29:18 <lambdabot>  "foo"
08:29:34 <Enamex> I think the error is a combination of return and const being non-strict (since they're not defined in my module)
08:29:54 <c_wraith> really, 99.99% of code should not use -XStrict
08:30:06 <glguy> Enamex: Also your use of ++
08:30:14 <lewandowski> Brothers! Has anyone been able to install stream-fusion successfully? I am currently facing dependency hell due to the package depending on base < 4.8
08:30:17 <c_wraith> It was added to make writing certain types of numeric code much less tedious
08:31:18 <Enamex> Redefining return and const and saying undefined++"blah" instead got me the error correctly :T
08:31:54 <Enamex> c_wraith: I'm just playing around for now. Goal in the forseeable future is to write a compiler for a toy language I'd been desigining
08:35:06 <glguy> lewandowski: Why do you need to install that package?
08:35:44 <glguy> and it doesn't sound like you're in dependency hell, you know what your dependencies are. To use that package you just need an older version of GHC
08:36:12 <lewandowski> glguy: ok so I just use an older GHC?
08:36:37 <glguy> Or don't use this package
08:36:40 <lewandowski> glguy: I wanted to see how stream fusion worked, I am an intermediate programmer
08:37:02 <lewandowski> glguy: ok so there's no practical aspect to stream fusion? 
08:38:27 <Welkin> lol lewandowski 
08:38:33 <Welkin> what the heck is an intermediate programmer?
08:39:11 <marvin2> i want to cross compile haskell for ARM, is this the guide I should be following? https://ghc.haskell.org/trac/ghc/wiki/Building/CrossCompiling
08:39:15 <lewandowski> Welkin: like I am an electrical engineer and really don't program but I've sorta liked the mathematical-ness of Haskell so I'm kinda learning typeclasses et cetera
08:40:11 <lewandowski> Welkin: Essentially up for learning techniques and not for writing coding contests
08:48:00 <lewandowski> ok then I guess I wont install it
08:48:45 <lewandowski> So is map f the same as (unstream . mapS . stream) f?
08:54:10 <cocreature> which unStream, mapS and stream are you talking about here? there are several
08:56:16 <lewandowski> https://hackage.haskell.org/package/stream-fusion-0.1.2.5/docs/Data-List-Stream.html
08:56:18 <lewandowski> this one
09:02:26 <cocreature> yeah in that case that holds
09:12:14 <setre> what method do you guys use for deploying haskell programs onto a server? I am trying keter but having some issues (with logging and compression format error)
09:15:52 <Welkin> I've only used keter for automatic deployment
09:16:05 <Welkin> what logging issues are you having?
09:16:40 <Welkin> if you are running keter behind nginx through a reverse proxy, you'll need to pass the original IP address and other info along
09:17:54 <monochrom> My Haskell programs are usually self-contained exes. So I just copy the exe to some /home/xxx/bin or /usr/local/bin. Done.
09:27:52 <srhb> setre: Mostly nixops with relevant systemd units.
09:28:54 * hackagebot HaTeX 3.17.3.0 – The Haskell LaTeX library. – https://hackage.haskell.org/package/HaTeX
09:30:23 <edwardk> setre: I've mostly just built things in little docker containers and deployed containers
09:44:50 <setre> thanks for answering :-)
09:45:03 <Enamex> I thought I'd seen mention (long ago) of Named Instances being implemented in GHC. It isn't :|
09:45:24 <setre> Welkin: I haven't looked into it very closely but I was unable to find the output from my program's stdout
09:45:35 <setre> re. keter
09:51:33 <Welkin> Enamex: you mean like in Purescript?
09:52:14 <Welkin> although there it is just boilerplate for the compiler
09:53:24 <Enamex> Kinda. I think PS's are just for readable JS output, though
09:53:43 <Enamex> Welkin: was referring to this: https://pdfs.semanticscholar.org/d6ee/be83b614be16596c40426691a90df57543f9.pdf
10:23:18 <thannan> Hello
10:28:32 <erisco> thannan, salutations
10:33:54 <thannan> I am hitting some issues with stack, was hoping I could get some guidance
10:36:23 <erisco> I don't use stack... many do so someone will speak up eventually
10:37:02 <thannan> All is well, it's more of a longer term issue rather than a 'nothing works' issue
11:07:30 <cocreature> thannan: just ask your question directly and stick around for a bit to see if someone answers
11:13:59 <thannan> Turns out my stack question was more of a linux problem
11:14:01 <thannan> seems fixed now
11:14:25 <thannan> vaguely regret the Haswell-E setup
11:14:51 <Welkin> what is that?
11:15:00 <thannan> Haswell-E?
11:15:13 <Welkin> yes
11:15:21 <thannan> It's a CPU architecture
11:15:27 <Welkin> I know what haswell is
11:15:30 <Welkin> what is the E?
11:15:49 <thannan> Like a variant
11:16:15 <thannan> tends to be Intel's "extreme" range or whatever
11:16:22 <mson> I have a function f :: [a] -> [b] that I'm passing a value of type IO [a] to. So when I call it, I use (fmap f) mylist and it works. But now I want to pass two arguments, one of type [b] and one of type IO [a]. fmap doesn't work anymore. What do I use instead? 
11:16:22 <thannan> I just wanted a 6-core CPU
11:16:40 <geekosaur> looks like it's overclocking zoo if I can trust search engines
11:16:47 <monochrom> AMD has 6-core CPUs too.
11:16:49 <geekosaur> and yes, I can imagine it's ... unstable
11:16:54 <thannan> This was a while back
11:16:56 <mson> I've been looking, and seen some things with <$> and <*>, but I can't get them to work.
11:17:01 <thannan> like, 2 3 years perhaps
11:17:09 <monochrom> Oh, you're already saying you regret Intel. We agree. :)
11:17:22 <thannan> lol
11:17:37 <ongy> mson: what do you mean with "can't get them to work"?
11:17:44 <geekosaur> mson, passing two arguments to [a] -> [b] does not make a lot of sense. could you show example code?
11:17:48 <erisco> mson, so what is the type of the function which takes two arguments? and what are the types of your arguments?
11:18:03 <geekosaur> however, at a guess, you want ot learn about >>=
11:18:39 <geekosaur> (this is not guaranteed, need to know quite a bit more about what you;re trying to do)
11:19:12 <Welkin> amd has 8 core (16 thread) cpus now
11:19:14 <Welkin> ryzen
11:19:33 <mson> erisco: the type of the function will be [a] -> [b] -> [c]
11:19:57 <erisco> okay, and the argument types are [b] and IO [a]?
11:20:01 <mson> geekosaur: I think I've explained badly; I don't think doing that makes sense either :)
11:20:12 <mson> erisco: Yup
11:20:41 <thannan> The Haswell-E socket ain't mainstream enough is the problem in a nutshell
11:20:54 <geekosaur> <*> flip f the_b
11:21:00 <erisco> f <$> x <*> pure y  where  f :: [a] -> [b] -> [c]; x :: IO [a]; y :: [b]
11:21:31 <ed__> hello friends
11:22:00 <erisco> do x' <- x; return (f x' y)   also works, as does   x >>= flip f y
11:22:22 <erisco> er no that last one doesn't
11:23:28 <erisco> x >>= return . flip f y  which is more simply  fmap (flip f y) x  or  flip f y <$> x
11:25:10 <ed__> would anyone like to help me figure out why my algorithm takes so darn long?
11:25:35 <ed__> https://justpaste.it/190gl and also what is the best way to share code?
11:25:40 <mson> erisco: got the first one to work! thanks~
11:25:44 <ongy> @lpaste is nice for haskell stuff
11:25:44 <lambdabot> Haskell pastebin: http://lpaste.net/
11:25:46 <ed__> im trying to solve project euler questions
11:26:17 <ongy> ed__: that's slow because you call fibonnaci *a lot*
11:28:04 <ed__> ongy: can you say wether its calling fibonacci some 4000000 times or as many times as it takes for the fibonacci sequence to exceed 4000000
11:28:14 <erisco> liftA2 f x (pure y)  or  (liftA2 f x . pure) y  or  ((. pure) . liftA2 f) x y  or  (((. pure) .) . liftA2) f x y
11:29:39 <ed__> http://codepad.org/3Mzne9lz this probably looks better
11:29:53 <ongy> ed__: it calls fibonacci until the return value exceeds 4000000, but the recursive function calls itself *a lot*
11:30:16 <ongy> oh, what do you do with the result of that either way?
11:30:38 <ed__> i need to sum all even fibonacci terms less than 4000000
11:31:12 <ed__> i also gotta work out how to use the main function lol
11:31:32 <freeside> rosetta code might be useful to you
11:31:42 <Welkin> ed__: generate all fibonacci numbers and take while less than 4,000,000
11:31:52 <erisco> ed__, well this is the classic example given for algorithmic complexity, i.e. this is an exponential time algorithm to find the nth fib number
11:32:27 <erisco> ed__, then the class is tasked with figuring out a smarter way to find the nth fib number, after understanding why this naive version takes exponential time
11:32:32 <Welkin> > let fib a b = a : fib b (a + B) in sum . takeWhile (< 4000000) $ fib 0 1
11:32:34 <lambdabot>  error: Data constructor not in scope: B
11:32:45 <Welkin> project euler is not a good source ofp rogramming problems
11:32:54 <Welkin> they are math problems that should not be solved with brute force
11:32:55 <monochrom> ed__: Suppose you just need F1+F2+F3+F4. It would be extremely unwise to actually compute F1, F2, F3, and F4, and add them.
11:32:57 <ed__> okay so the way ive got it set up it runs to the base case every time i call fibonacci
11:33:06 <Welkin> there is always a more elegant way to solve them that requires no programming
11:33:33 <Welkin> > let fib a b = a : fib b (a + b) in sum . takeWhile (< 4000000) $ fib 0 1 -- curious is this times out
11:33:34 <lambdabot>  9227464
11:33:35 <mson> Welkin: depends on the field. normal programmer, whatever that is? you're right. data scientist / numerical programmer type? more useful.
11:33:39 <ed__> okay well i love math as well so i can enjoy both sides of the excercises
11:34:07 <Welkin> looks like it works
11:34:08 <monochrom> Hrm let me look at wikipedia for a formula.
11:34:12 <erisco> well you can address the summation algorithm as well, but first of all you have a poor algorithm for finding the nth Fibonacci number
11:34:22 <ed__> im studying mathematics at university
11:34:33 <ed__> okay i just gotta spend some more time looking at it then
11:34:59 <erisco> monochrom, I imagine you can find the integral of the exponential formula somewhere
11:35:28 <mson> ed__: try drawing out the calls. the function makes two recursive calls each time, so you'll end up drawing a tree. draw that tree for F_5 or F_10 or something to get an idea of how many calls are being made.
11:35:32 <erisco> my point is that if you understand why fibonacci is slow then you will understand why the summation is slow... it is the same problem twice
11:36:00 <Welkin> you can generate fibonacci numbers in linear time, as I showed above
11:36:02 <mson> (i mean draw out on paper)
11:36:12 <monochrom> ed__: You will want to take a look at https://en.wikipedia.org/wiki/Fibonacci_number#Combinatorial_identities
11:36:14 <erisco> the first is to reduce an exponential algorithm to linear and the second is to reduce a quadratic algorithm to linear
11:36:35 <erisco> well, if you count the cost of addition there should be a log factor in there, but w/e
11:36:56 <monochrom> F1 + ... + Fn = F(n+2) - 1. You need only compute one fibonacci number.
11:36:58 <ed__> but I am very new to haskell and fp, i just figured project euler would be a good hands on way to practice and gain some familiarity
11:37:11 <ed__> but this is perfect because i also need to get my hands dirty with algorithms and complexity
11:37:22 <mson> project euler is great, I used it to learn julia and it was perfect for my purposes
11:37:27 <Welkin> ed__: it is not a good way to learn programming of any kind
11:37:29 <Welkin> it is a terrible way
11:37:36 <ed__> gotta grab a pen and paper
11:37:57 <Welkin> real programming is not about solving toy algorithms exercises
11:38:09 <ed__> Welkin: why do you say that? what is """real programming"""
11:38:17 <Welkin> ed__: building software
11:38:22 <erisco> and what monochrom described is the smart way of first using your brain to simplify the problem as much as possible before writing the program
11:38:23 <monochrom> Real programming means whatever I do.
11:38:45 <monochrom> As opposed to whatever you do.
11:38:46 <Welkin> I should have said, realy world programming
11:38:50 <mson> Welkin: the issue i've always run into is that structuring a real, non-toy program _and_ learning what the heck an impure function, or monad, or this or that is, at the same time, is just too hard for my monkey brain
11:38:52 <Welkin> real world*
11:38:56 <monochrom> Because clearly I make more money than you do.
11:39:13 <mson> I like using these little problems to get familiar with a new language
11:39:26 <monochrom> Objectively, real programming means you be the manager, tell your underlings to write code, and you take all the credit and the money.
11:39:44 <monochrom> Don't program the computer. Program the employees.
11:40:11 <erisco> you wear the jeans and turtle necks and give press conferences
11:40:11 <ed__> i care more for the theory than building software
11:40:11 <monochrom> And yes that's the real real world.
11:40:15 <mson> monochrom: no cyncicism until it's no longer sunday morning in anyone's timezone
11:40:42 <Welkin> the point of programming is usually for a purpose (often to achieve some kind of organizational or business objective)
11:40:46 <kadoban> mson: Which is a good thing, but the "problem" with project euler for this use is that a lot of the problems are primarily mathimatical, so you get distracted from the goal of learning the language by math you might just not know.
11:41:06 <ed__> Welkin: for you it may be, not for me
11:41:12 <erisco> all the programming competitions I have been in are designed by mathematicians
11:41:13 * ongy mostly programs to fix some small personal problem
11:41:31 <erisco> it is 95% the math you know and 5% writing it in a program :P
11:41:39 <mson> kadoban: that's fair. I think for a math major it's suitable, though then we'd have to argue whether his goal was ever actually "learn programming"
11:41:49 <ed__> id rather be a mathematician than a software developer
11:41:54 <ed__> define "programming"
11:42:07 <erisco> computer scientists are mathematicians
11:42:09 <monochrom> As for PE, if you use it to practice writing one more for-loop, that's fine, but don't expect it to be not-slow, and don't expect it to be the point of PE.
11:42:12 <mson> ed__: but that would end the discussion!
11:42:17 <Welkin> but many computer scientists do not program
11:42:20 <Welkin> and they don't even like computers
11:42:26 <erisco> haha, yes
11:42:48 <mson> i was under the impression most programmers of all forms do not like computers
11:42:55 <kadoban> erisco: PE is even more so. Or at least programming competitions use different parts of math (more the algorithms and data structures part)
11:43:18 <mson> so hey actually this is a great time for me to ask
11:43:20 <ongy> mson: I just don't like software
11:43:33 <schmidt73> Does anyone know why I get this error: "Unsupported extension: InstanceSigs
11:43:33 <schmidt73> " on GHC 7.2.1?
11:43:40 <mson> I'm learning haskell using Rosalid and a little project euler, which are both toy problems sites
11:43:59 <mson> do people here have other recommendations?
11:44:20 <erisco> some Haskell book
11:44:20 <ongy> schmidt73: https://downloads.haskell.org/~ghc/8.0.2/docs/html/users_guide/glasgow_exts.html#instance-signatures-type-signatures-in-instance-declarations since 7.6.1
11:44:21 <schmidt73> CIS194 and Data61 course
11:44:52 <cocreature> schmidt73: is there a specific reason why you’re using 7.2? that’s ancient
11:44:54 <erisco> or that website bernalex (?) has
11:45:03 <schmidt73> Some flags have not been recognized: -XInstanceSigs
11:45:11 <schmidt73> Oh
11:45:14 <schmidt73> since 7.6.1
11:45:19 <schmidt73> God I'm an idiot
11:45:34 <mson> I'm learning by going through Gentle Introduction and stackoverflow and talking to you people, so what I'm really just lacking is an idea of what to write the code _for_
11:46:14 <erisco> yeah, well, you have to figure out why you want to program
11:46:20 <ongy> mson: I just picked something random I needed (rather wanted to have different) and just implemented it. Then completly reworked it after a few months when I knew things about haskell
11:46:34 <schmidt73> Which is the version of haskell I should use?
11:46:35 <ed__> mson: do you have an end goal for why your learning haskell?
11:46:38 <kadoban> If you really just want those kinds of small-exercise sites, I like hackerrank and codeforces. I've learned a lot of haskell that I otherwise wouldn't have doing those, but I already knew the language and don't know how much of the basic stuff I could have learned doing that.
11:47:20 <cocreature> schmidt73: 8.0.2
11:48:00 <Welkin> stay away from hacker rank.
11:48:03 <Welkin> it is awful
11:48:08 <ongy> they spam me with mails -.-
11:48:12 <erisco> just don't pick something that is IO intensive... I see people trying to learn by wanting to write some low level program and I think it is too obscuring
11:48:41 <kadoban> What's wrong with hackerrank?
11:48:49 <ongy> are you talking about me? :D I'm only doing IO and in weird ways at that
11:49:05 <mson> ed__: I want to know a language with a good type system...
11:49:07 <Welkin> poorly designed exercises and templates written by someone who has obviously never written haskell before
11:49:22 <erisco> you're exceptional ongy, you do you
11:49:34 <kadoban> Poorly designed exercises? They're quite nice. Yeah, don't use the templates, write your own code.
11:49:57 <mson> Welkin: I have a challenge for you: say something nice about a website
11:50:05 <Welkin> for me, the best way is to jump into a porject
11:50:11 <Welkin> it was a yesod project that really helped me learn
11:50:18 <Welkin> project*
11:50:38 <Welkin> it required reading source code pretty often because not everything is documented
11:51:03 <Welkin> it probably would have been better to start with scotty though, or even wai
11:51:05 <f-a> I have a grid (2d) of Cells. Was ready to use a vector but apparently they are 1 sized only. Is there an alternative? Or should I do the "2d vectors are 1d vectors (n*k)" trick?
11:51:31 <Welkin> f-a: you can use Array
11:51:54 <TommyC> If you have a grid of 1-sized cells, isn't that just 1 vector?
11:52:04 <Welkin> or, if all of your 2d vectors are fixed sizes, you can use a single vector with an indexing function
11:52:24 <glguy> codewars.com has some OK Haskell content
11:52:25 <ed__> mson: i guess what im getting at is this: do you want to learn haskell for the sake of learning haskell? or is there some bigger end goal you have in mind
11:52:46 <f-a> thanks Welkin 
11:53:05 <mson> ed__: I don't think I really have a real use for it at this time.
11:54:00 <erisco> mson, I wrote parser combinators to learn, so maybe that interests you
11:54:33 <duncan^> mson: read LYAH 
11:54:37 <mson> erisco: I'll check those out
11:54:56 <mson> duncan^: can't stick with it. too many words
11:54:58 <erisco> I was fascinated by how you can take a string and end up with a more complex structure... something mystical about how programming languages actually work
11:55:07 <schmidt73> Any fun languages to try to parse?
11:55:09 <mson> the jokes aren't funny... there, I said it.
11:55:12 <duncan^> the wiki is generally more illustrative than SO... SO has a low signal-to-noise ratio
11:55:21 <mson> So I'm going through A Gentle Introduction.
11:55:30 <f-a> gentle introduction is not at all gentle
11:55:35 <schmidt73> When talking about parser combinators
11:55:46 <erisco> schmidt73, well the objective I had was to parse some class of languages, not any in particular
11:55:49 <mson> f-a: yes true but I find it's at a good level for me
11:56:05 <mson> I like this sort of dense stuff
11:56:07 <schmidt73> Interesting
11:56:16 <schmidt73> I think I'd want to start with one in particular
11:56:26 <f-a> mson: then it's ok. CIS194 if you need something less steep
11:56:36 <mson> thanks
11:57:10 <erisco> schmidt73, I used examples to get my intuition working, but they were not programming languages, they were just simple grammars
11:58:04 <erisco> schmidt73, so I might think about  S -> aS | a  for a while to figure out how I could parse that
11:58:35 <erisco> each example tells you a bit more about how your parser needs to work, or what limitations you are accepting
11:59:13 <schmidt73> Can you send me the grammars?
11:59:28 <schmidt73> I'm new to parsing and all of that stuff but it sounds really interesting.
11:59:46 <schmidt73> @erisco
11:59:46 <lambdabot> Unknown command, try @list
12:00:40 <mson> erisco: writing parser combinators is the general case of writing a program that takes a brainfuck program and executes it -- is that right? 
12:00:58 <erisco> schmidt73  S -> aS | a; S -> (S) | ε; S -> Sa | a; S -> SaS | a; S -> SS | a;
12:01:02 <mson> (or whatever language, but I've seen BF parser tutorials all over)
12:01:07 <cocreature> mson: no execution is not part of parsing
12:01:13 <erisco> I don't know all the examples I used, but I just kept thinking of things which seemed problematic or strange to me
12:01:39 <mson> cocreature: oh yeah. I knew that once.
12:01:42 <ed__> f-a: is there a certain school you're referring to when you say cis194? what is that
12:01:53 <erisco> I have not need interpreter combinators but that would be really interesting!
12:01:54 <mson> ed__: just google, it's first result
12:01:57 <erisco> not seen*
12:02:11 <schmidt73> That would be really interesting
12:02:11 <erisco> you might be able to execute brainfuck as a byproduct of constructing the AST, I am not sure
12:02:15 <cocreature> @where learnhaskell
12:02:16 <lambdabot> https://github.com/bitemyapp/learnhaskell
12:02:22 <ed__> so were talking about upenn's class in particular?
12:02:27 <schmidt73> Brainfuck can't be too hard to parse
12:02:32 <f-a> ed__: http://www.seas.upenn.edu/~cis194/fall16/ <-- free, well done
12:02:35 <cocreature> ^ ed__ that links to the mentioned course among others
12:03:08 <mson> schmidt73: yeah, that's why it has so many tutorials
12:03:22 <ed__> oh good deal, that looks great
12:03:33 <f-a> it is
12:05:02 <ed__> has anyone here done research in cs or maths?
12:05:29 <erisco> parsing was my undergrad research project... so being undergrad nothing new happened in it ;)
12:07:34 <ed__> right on, when did you do your undergrad?
12:07:55 <erisco> hm, 2014 I think
12:07:59 <freeside> 4613732
12:08:47 <ed__> okay, so not too long ago, what are you doing now if you don't mind me asking
12:09:17 <erisco> learning some information theory which is requiring me to relearn what I forgot in the one stats class I took
12:09:24 <erisco> not that I really understood it then...
12:10:04 <mson> I think he meant job, in which case your answer would either be very impressive or very unimpressive. I can't decide which
12:10:16 <erisco> what about your maths? I was surprised that my math major friend had not seen much abstract algebra... apparently not a huge focus on it, though some
12:10:43 <werner___> Hi, quick question, why does this https://paste.gnome.org/pkvygjp7d give me the error Error:(4, 1) Package-qualified imports are not enabled; use PackageImports?
12:10:57 <erisco> mson, haha, well, I answered with exactly what I am involved with right now :P
12:11:08 <mson> erisco: such a programmer
12:11:36 <hpc> move the LANGUAGE line to the top of the file
12:11:36 <werner___> Never mind, just wrongly ordered
12:11:46 <werner___> Yeah, that was the probem, thanks
12:11:59 <ed__> hahaha i guess i meant more like job vs grad school or something like that
12:12:08 <hpc> the disadvantage of those pragmas also technically being comments
12:12:09 <erisco> I am waiting to find a job more interesting for me but most likely will have to pick up another web dev or mobile gig in not too long...
12:12:26 <mson> I have an annoyingly vague question. In some of my programs putStrLn prints the string surrounded by quotes to my terminal, sometimes it prints the string bare. What gives?
12:13:06 <erisco> mson, did you show the string before printing?
12:13:15 <cocreature> mson: you are probably calling "show" on string before you pass it to putStrLn in the cases where you see the quotes
12:13:24 <ed__> information theory is wild, theres a great introduction series on youtube done by somebody at khan academy
12:13:57 <mson> That was it! thanks both
12:14:23 <erisco> ed__, I bought a book on it several months ago and just recently found out I really need to start reading it :P
12:14:32 <ed__> i meant to check out this foundational paper "a mathematical theory of communication but i never got around to it"
12:14:34 <erisco> ed__, the notation is what is killing me... darn you mathematicians ;)
12:15:05 <ed__> haha cool, is the book more proof based then?
12:15:40 <mson> i've learned that according to my brain, books are not for reading, they are for collecting
12:15:51 <erisco> it gives a little explanation and then proofs... in their opinion the math speaks for itself
12:16:06 <ed__> and as far as abstract algebra goes ive found that only those students who really care about the pure math will really get into it, its not even required for a lot of the math tracks
12:16:36 <erisco> ed__, seems weird from my perspective because abstract algebra should be where it is all at... *shrug*
12:17:02 <schmidt73> erisco do you work as a programmer?
12:17:06 <erisco> too much focus on reals and number stuff
12:17:31 <ed__> what kind of math background do you have? books like that are hit or miss where you have to have just the right amount of mathematical maturity, not enough and youll be struggling to fill in the gaps or too much and you feel like youre reading fluff
12:17:39 <mson> erisco: I sat in calc 4 at the end of my undergrad for about two days... the teacher was working out triple integrals on the board by hand!
12:17:52 <mson> I couldn't believe it. Enough already...
12:18:01 <erisco> they use the "mathematical maturity" catch phrase over there too do they? we had a prof that would talk about that every class
12:19:04 <ed__> lol calc is for the engineers, analysis is for the mathematicians ;)
12:19:09 <erisco> schmidt73, I did, then I worked for a start up and it went poof, so I have been trawling for jobs since
12:19:39 <cocreature> going poof seems to be what startups are best at
12:20:14 <schmidt73> Oh interesting, I thought you could be in academia or something.
12:21:12 <erisco> schmidt73, what about yourself?
12:21:36 <schmidt73> I'm a rising sophomore at uni, working at HPE over the summer.
12:21:45 <ed__> but a good linear algebra course with proofs is enough abstract algebra for most really
12:21:51 <schmidt73> You've helped me out a few times
12:21:59 <schmidt73> But I've used different IRC names
12:22:01 <schmidt73> So thank you
12:22:26 <erisco> what is HPE?
12:22:37 <schmidt73> Hewlett Packard Enterprise
12:22:37 <APic> lol
12:23:59 <schmidt73> we use C at work and it pains me
12:24:38 <erisco> is it for firmware?
12:25:46 <schmidt73> for MPI which is a distributed computing framework and profiling tools for MPI
12:26:19 <n_blownapart> holy mother of God vim requires one to read tomes before one can cut and paste
12:26:55 <erisco> one does not simply cut and paste
12:27:30 <n_blownapart> yes one reads Dante's Inferno first and writes a dissertation
12:27:54 <geekosaur> I know vimscript is ugly, but isn't that overblowing it a bit?
12:28:00 <dario> n_blownapart: but then one writes the dissertation in vim ;)
12:28:03 <ongy> "+p
12:28:18 <Tuplanolla> I think so, geekosaur. I'm definitely disappointed by how pedestrian Vim actually is.
12:29:11 <n_blownapart> ongy is that in visual mode ? why does visual mode begin highlighting in the second place char?
12:29:34 <dolio> "+p is paste from the clipboard register.
12:29:49 <ongy> n_blownapart: that pastes from the + clipboard, which is the X clipboard on linux.
12:29:59 <n_blownapart> correct dolio I"m just trying to stay within the vim register
12:30:15 <mson> #haskell is a great channel for discussing languages that require reading tomes to perform simple IO tasks
12:30:25 <dolio> The opposite would be "+y or "+d for copy and 'cut'.
12:30:33 <zomg> you can just yank it with y and then just go p all over the place
12:30:56 <erisco> @remember <zomg> you can just yank it with y and then just go p all over the place
12:30:56 <lambdabot> Nice!
12:31:16 <APic> Yup.
12:31:41 <zomg> well I accidentally loaded that message with more puns than I first realized...
12:31:41 <kebertx[m]> Does anyone here know any good books about machine learning?
12:31:42 <zomg> :P
12:31:51 <Tuplanolla> How about pasting a block-selection-copied thing as if it was not?
12:32:22 <n_blownapart> zomg lewd ! I will also bookmark that
12:33:04 <kebertx[m]> I'm looking for something that's detailed and thorough, but from more of an academic/mathematical perspective
12:33:10 <n_blownapart> but is that visual mode, "+yy2" for 2 lines, then p ?
12:33:26 <n_blownapart> or *yy2
12:33:40 <n_blownapart> correction "*yy2
12:34:29 <n_blownapart> brutal I need atom and a 64bit machine
12:34:49 <ed__> kebertx[m]: one of my math profs recommended me the two books by Robert Tibshirani and Trevor Hastie
12:35:16 <n_blownapart> sorry all ignore me
12:35:17 <zomg> I've actually never tried what would happen in visual mode if I tried to use 2 in a command...
12:35:19 <ed__> introduction to statistical learning is the easier one
12:36:26 <n_blownapart> zomg since you're responding, so that's just not in visual mode, just "*yy2 to stay within the vim register?
12:37:19 <geekosaur> this is confusing because it's all in visual mode (i.e. not ex mode) to an old vi-er :p
12:37:28 <zomg> n_blownapart: not sure I'm following :) if you want to copy something into a register it's just "ayy to put the current line into register a
12:37:44 <zomg> plain yy will also put it into "0 or something, I can never remember :)
12:38:08 <n_blownapart> zomg thanks what about multiple lines ?
12:38:20 <zomg> "a2yy should work
12:38:38 <geekosaur> ^ count before the command
12:38:47 <freeside> i am pleased to report, from the emacs side of the trenches, that i managed to get intero-mode installed and cooperating with slack, with only a medium-sized bag of yak fur to show for it
12:38:56 <freeside> er, cooperating with stack
12:38:59 <kebertx[m]> ed__: He publishes [free pdfs](http://web.stanford.edu/~hastie/pub.htm) of his books, so I'll call that as good a place to start as any :)
12:39:53 <n_blownapart> or entire file. every online answer seems different. thanks never even saw the a bit zomg geekosaur  thanks
12:40:26 <kebertx[m]> I feel like this entire field snuck up on me, so I recently resolved to catch myself up
12:40:30 <zomg> yeah the answers probably differ because there's a few ways of doing it :P
12:41:04 <zomg> it's easier once you understand the concept of motions and such
12:41:26 <zomg> so for example since the motion to top of file is gg and the motion to bottom is G, you can mix it with y to get ggyG
12:41:43 <geekosaur> and 1G also works for top of file
12:42:07 <erisco> I press that button called "home" and for the end I press "end"
12:42:28 <zomg> isn't it ctrl+home to scroll to top though? :p
12:42:38 <zomg> at least in any editor using those keys for this it just goes to beginning and end of line without ctrl...
12:42:57 <erisco> yeah it is with ctrl, my bad, otherwise it is start and end of the line
12:43:01 <geekosaur> also in a line is that doing 0 or ^ ? :p
12:43:14 <Tuplanolla> It's also nice how `%` goes to the next paired delimiter, `1%` goes almost to the top and `0%` does nothing.
12:43:50 <Tuplanolla> It makes perfect sense.
12:44:23 <erisco> too bad insert and delete do not do anything that interesting
12:44:32 <zomg> that reminds me I wonder if there's something that'll let me use [{ and ]} to go to top and bottom of function in .hs files...
12:44:32 <erisco> insert is just a nightmare...
12:44:38 <zomg> or something similar :P
12:45:45 <erisco> for years I thought it was some computer bug, but actually I was just fat fingering insert when I pressed backspace
12:45:49 <kebertx[m]> geekosaur: My `.vimrc` has `map 0 ^` at the end - I never found `0` to be very helpful, and `^` feels like an awkward reach on my keyboard
12:46:08 <erisco> I clued in once I changed operating systems and the problem happened again...
12:46:44 <n_blownapart> I just hate it. seems like the authors just need to be clever
12:46:49 <kebertx[m]> Also, `0 === ^b`, so if I need that behavior its still only one more keystroke away
12:47:16 <geekosaur> in nvi, { and } move to the prev/next 'paragraph' = blank line...
12:48:06 <kebertx[m]> Helps a lot for latex or markdown, but it doesn't come up much when I'm coding
12:48:10 <zomg> geekosaur: yeah that works if you have sensible nice functions and not the terrible long and badly structured ones I have
12:48:13 <zomg> :D
12:49:27 <zomg> erisco: I'm pretty sure there's been a few instances with people I know where they accidentally pressed insert and then they didn't know what was going on and got super confused
12:49:33 <n_blownapart> steve jobs' mouse obviously overlooked by some.
12:50:02 <ongy> what does insert do in vim?
12:50:19 <zomg> seems to go into insert mode :P
12:50:26 <zomg> (ie. the normal "I want to type stuff" mode)
12:50:28 <n_blownapart> it makes a chocolate shake, but you can't eat it. ongy
12:50:28 <ongy> makes a lot of sense
12:51:24 <ongy> he, good thing I wouldn't want to either way
12:52:06 <n_blownapart> insert ^ makes a vegan chocolate shake for ongy
12:52:58 <zomg> best mouse btw https://twitter.com/lazygamereviews/status/885975948704829440
12:53:24 <ongy> n_blownapart: oh, now I don't want it either. Good change :P
12:53:44 <ongy> does the haskell-ide stuff work with (neo-)vim yet?
13:15:05 <pera> Does anyone knows what's the history behind the use of the "data" keyword for ADT definitions?
13:24:50 <bitonic> pera: aDt
13:25:25 <bitonic> data seems quite natural
13:26:02 <erisco> why not adT, and why does the type keyword introduce an alias
13:31:45 <geekosaur> this _type_ names a different type. this _data_ type introduces a new shape for data
13:31:51 <geekosaur> (imo)
13:32:19 <geekosaur> (but yes, it's just begging for confusion)
13:32:21 <pera> type seems more natural to me :)
13:35:38 <monochrom> Usually you define algebraic data types for your data structures, so the "data" aspect dominates.
13:36:21 <monochrom> However, clearly, with lazy data structures, soon you use them for control-flow purposes instead. Lazy list is the stereotypical example, but lazy trees happen too.
13:36:59 <monochrom> So if you have a chance to start over, you should do this:
13:37:36 <monochrom> "data X = ..." defaults to what StrictData does. "control X = ..." gives you non-strictness by default.
13:38:37 <monochrom> data List a = DNil | DCons a (List a). control Loop a = CNil | CCons a (Loop a)
13:40:54 <pimlu> is there a better way to represent the inner lambda here without pulling in Control.Cond?
13:40:57 <pimlu> fib n = length $ iterate (>>= \b -> if b then [False,b] else [True]) [False] !! n
13:42:57 <monochrom> I like that lambda.
13:43:33 <pimlu> hm, alright
13:43:36 <erisco> \b -> bool [False, b] True b   and then some more work to make it pointless... it won't look good
13:43:49 <monochrom> @type bool
13:43:51 <lambdabot> a -> a -> Bool -> a
13:44:09 <edwardk> \b -> [b] ++ [b | not b]
13:44:22 <monochrom> ah neat
13:44:26 <edwardk> > (\b -> [b] ++ [b | not b]) <$> [False,True]
13:44:28 <lambdabot>  [[False,False],[True]]
13:45:44 <edwardk> oh that is an if b, i screwed up
13:45:46 <pimlu> > length $ iterate (>>= (bool [True] [True,False])) [False] !! 4
13:45:48 <lambdabot>  5
13:46:13 <edwardk> > (\b -> [not b | b] ++ [b]) <$> [False,True]
13:46:15 <lambdabot>  [[False],[False,True]]
13:46:28 <edwardk> and the other is not b, wow, i'm lame today
13:46:50 <edwardk> > (\b -> [not b] ++ [not b | b]) <$> [False,True]
13:46:52 <lambdabot>  [[True],[False,False]]
13:46:56 <monochrom> Boolean logic stumbles the top minds of the world.
13:47:01 * edwardk stops
13:47:06 <erisco> oh yeah, if/then/else is figuring out what b is... derp
13:47:08 <monochrom> It's why the top minds switch to intuitionistic logics. :)
13:47:21 <erisco> bool [False, True] [True]
13:47:55 <pimlu> what does a list comprehension mean when you don't have a <- in it like that?
13:48:36 <monochrom> > [ 5 | True ]
13:48:38 <lambdabot>  [5]
13:48:41 <erisco> > fib n = length $ iterate (>>= bool [False, True] [True]) [False] !! n in fib 5
13:48:43 <lambdabot>  <hint>:1:7: error:
13:48:43 <lambdabot>      parse error on input ‘=’
13:48:43 <lambdabot>      Perhaps you need a 'let' in a 'do' block?
13:48:46 <monochrom> > [ 5 | False ]
13:48:48 <lambdabot>  []
13:48:56 <erisco> I forgot my let
13:50:16 <pimlu> I see, so that's the condition at the end, just without the sequence of lists separated by commas prefixing it?
13:50:17 <monochrom> Wait a second, is it some kind of computing Fibonacci numbers by unary arithmetic?!
13:50:18 <erisco> when you're used to just transforming syntax sometimes you forget to consider the semantics :P
13:50:21 <Tuplanolla> :t \ b -> [b | not b]
13:50:22 <lambdabot> Bool -> [Bool]
13:50:58 <pimlu> it's simulating the finonacci rabbits thing by using the list monad lol
13:51:00 <monochrom> "To compute 100000000000000, let's count the length of a list of 100000000000000 items"
13:51:00 <erisco> pimlu, it translate to guard
13:51:30 <edwardk> > length $ iterate (>>= \b -> [not b] ++ [b|b]) [False] !! 4
13:51:32 <lambdabot>  5
13:51:37 <lyxia> > let fib n = length $ iterate (>>= \b -> filter (>= not b) [True,False]) [False] !! n in fmap fib [0 .. 5]
13:51:39 <lambdabot>  [1,1,2,3,5,8]
13:51:56 <edwardk> that flips the negation test to shave a few chars
13:52:02 <erisco> pimlu, the condition is not just at the end, you can have many and wherever
13:52:30 <edwardk> b | not b     becomes b <$ guard (not b)  -- basically
13:53:30 <erisco> > [x | False, x <- [1..]]
13:53:32 <lambdabot>  []
13:53:53 <edwardk> pimlu: there are of course slightly faster methods. =)
13:54:17 <Tuplanolla> Yes, but then you lose the Shakespeareness, edwardk.
13:54:21 <edwardk> > [x | x <- [1..], False]
13:54:27 <lambdabot>  mueval-core: Time limit exceeded
13:54:28 <edwardk> ^- whee non-termination
13:54:48 <pimlu> huh, okay
13:54:49 <erisco> > [(x,y) | x <- [1..], x < 5, y <- [1..], y < 10]
13:54:55 <lambdabot>  mueval-core: Time limit exceeded
13:55:11 <erisco> well you would have seen [(1,1),(1,2),(1,3),(1,4),(1,5),(1,6),(1,7),(1,8),(1,9) and then the timeout
13:55:26 <edwardk> it has no knowledge of monotonicity
13:56:00 <exio4> Ord and Enum have no need to work like that, though
13:56:19 <exio4> because there are no laws about them? 
13:56:25 <edwardk> in theory on a 32-bit machine it might eventually give you more data, just really slow
13:56:43 <monochrom> 64-bit too, just even slower
13:56:45 <erisco> heh
13:56:48 <edwardk> exio4: sure, there are -reasons- why it has no knowledge of monotonicity here =)
13:56:57 <Filthy_Causual> Why doesn't it evaluate the False first?
13:57:04 <monochrom> Whee conclusion: modern 64-bit computers are slower than old 32-bit computers!
13:57:08 <erisco> I think edwardk was specifying 32-bit so there was at least a hope of having enough memory
13:57:16 <EvanR> in theory on a 64-bit computer the universe ends
13:57:22 <edwardk> Filthy_Causual: because we told it to do the other thing first, and in general it isn't sound to reorder monadic computations
13:57:22 <erisco> I mean time
13:57:27 <erisco> space, time, what's the difference
13:57:38 <exio4> it's based on Int's size 
13:57:58 <exio4> it's smaller on a 32bit computer, meaning there will be some point when [1..] actually stops
13:58:13 <exio4> (I guess?) 
13:58:20 <monochrom> The Reverse Moore's Law: A program that overflows becomes twice as slow every 18 months.
13:58:59 <monochrom> Err wait "twice" is wrong haha.
13:59:04 <edwardk> now i want a version of filter that takes your program, starts abstract interpreting it if it doesn't emit results over a sufficiently long period of time and tries to run it through z3 to detect if no more results can be returned in the current loop and provides early termination =P
14:00:29 <monochrom> [ x::Int | x <- [18446744073709551606..], x < 0 ]
14:00:30 <c_wraith> what about using liquid haskell to somehow encode a check that filter will be sufficiently productive?
14:00:33 <monochrom> > [ x::Int | x <- [18446744073709551606..], x < 0 ]
14:00:39 <lambdabot>  mueval-core: Time limit exceeded
14:00:43 <monochrom> Eh!
14:00:45 <Filthy_Causual> monochrom: no I think thats about right..its just it rounds down to the nearest 2^(8^2).
14:00:48 <monochrom> Oh!
14:01:05 <monochrom> > [ x::Int | x <- [9223372036854775798..], x < 0 ]
14:01:07 <lambdabot>  []
14:01:15 <monochrom> That.
14:04:47 <Filthy_Causual> c_wrath: I think a proof that (take n (filter p s)) is terminating for all n would work right?
14:05:10 <monochrom> erisco: Space and time may have much difference because it's likely PTIME != PSPACE.
14:05:45 <c_wraith> Filthy_Causual: it was mostly a joke based on the fact that liquid haskell already can use Z3.  But in most cases, such a restriction would be too much.
14:05:51 <monochrom> Although, if someone proves them equal, that will be really interesting. (Well it's interesting either way.)
14:06:47 <Filthy_Causual> PSPACE includes NPTIME, right?
14:06:53 <monochrom> Yes.
14:07:35 <Filthy_Causual> Yeah, that would be interesting.
14:09:52 <Filthy_Causual> Anyway, the reason i am here is the hope there is a better way to write (\ r -> g r >> return r)?
14:10:21 <Filthy_Causual> @pl \ r -> g r >> return r
14:10:21 <lambdabot> liftM2 (>>) g return
14:10:52 <erisco> \r -> r $> g r
14:10:54 <Filthy_Causual> :t liftM2 (>>)
14:10:55 <lambdabot> (Monad m, Monad m1) => m1 (m a) -> m1 (m b) -> m1 (m b)
14:11:41 <erisco> which happens to be (<*>) ($>) g
14:11:55 <erisco> :t (<*>) ($>)
14:11:56 <lambdabot> error:
14:11:57 <lambdabot>     • Variable not in scope: ($>) :: f (a -> b)
14:11:57 <lambdabot>     • Perhaps you meant one of these:
14:12:09 <lyxia> :t (<$)
14:12:10 <lambdabot> Functor f => a -> f b -> f a
14:12:35 <erisco> Data.Functor.$> is a thing, but yeah, I guess I meant <$
14:12:45 <erisco> :t (<*>) (<$)
14:12:46 <lambdabot> Functor f => (a -> f b) -> a -> f a
14:12:48 <trigone> @pl \f g h x -> g x `f` h x
14:12:49 <lambdabot> liftM2
14:12:52 <lyxia> Filthy_Causual: basically it doesn't get much simpler than what you have already
14:13:13 <erisco> didn't I just make it simpler though? =\
14:13:44 <lyxia> just a little
14:13:52 <lyxia> and you do need to know about ($>)
14:13:59 <Filthy_Causual> Just a little was all I expected.
14:14:09 <trigone> @src liftM2
14:14:09 <lambdabot> liftM2 f m1 m2 = do
14:14:09 <lambdabot>     x1 <- m1
14:14:09 <lambdabot>     x2 <- m2
14:14:09 <lambdabot>     return (f x1 x2)
14:14:34 <erisco> and you need to know (<*>) for functions, but these are doable
14:14:45 <trigone> @pl \f g h x -> g x `f` h x
14:14:45 <lambdabot> liftM2
14:14:52 <lyxia> <*> is arguably much more common than $>
14:15:46 <trigone> :t \f g h x -> g x `f` h x
14:15:47 <lambdabot> (t3 -> t2 -> t1) -> (t -> t3) -> (t -> t2) -> t -> t1
14:16:00 <lyxia> $> has the advantage that it can sometimes be optimized
14:16:08 <trigone> :t liftM2
14:16:10 <lambdabot> Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
14:16:28 <trigone> i see
14:17:18 <erisco> you can also use ap instead of (<*>)
14:17:38 <erisco> ... usually
14:19:06 <Filthy_Causual> I think "(($>) <*> print))" is better then "(\ c -> print c >> return c)" Mostly because it elides the return.
14:19:40 <Filthy_Causual> (Its not the Prelude's print there)
14:20:46 <lyxia> I find the lambda much clearer.
14:21:00 <lyxia> Just my opinion.
14:22:03 <erisco> you need to be practiced to make sense of ($>) <*> print quickly
14:22:12 <AWizzArd> What is the Haskell way to do what Clojure’s Transducers are good for?
14:22:51 <lyxia> Is ($>) <*> print actually correct
14:23:59 <erisco> no, it is supposed to be <$ ... I am not sure why $> seems more intuitive
14:24:09 <erisco> I keep thinking of it as pointing to the new value it is to take
14:24:16 <erisco> but the opposite is happening
14:24:26 <erisco> :t (*>)
14:24:27 <lambdabot> Applicative f => f a -> f b -> f b
14:24:38 <erisco> it doesn't agree with *> and <*
14:25:18 <lyxia> it points to the b where b is the type of the final result.
14:25:24 <erisco> oh yes it does, lol, I am not thinking of it as infix :P
14:25:31 <erisco> guess I am too tired now =\
14:25:46 <lyxia> but anyway the lambda raises no such issues.
14:25:55 <lyxia> therefore it is better
14:26:51 <lyxia> But at the end of the day I'm not the one writing that code...
14:28:04 <erisco> well the problem is just that it is no recognisable pattern
14:28:14 <erisco> print c >> return c  uses the "do this do that" intuition
14:29:23 <Filthy_Causual> :t (<$)
14:29:24 <lambdabot> Functor f => a -> f b -> f a
14:29:26 <erisco> (<$) <*> print  is not a thing you see often, just because you don't see a lot of people leveraging <*> for functions often
14:29:40 <erisco> but if you are used to that then it is easy
14:29:58 <Filthy_Causual> :t (<*)
14:29:59 <lambdabot> Applicative f => f a -> f b -> f a
14:30:21 <erisco> as soon as you pick up that it is S then you immediately see the \f g x -> f x (g x)  and f = (<$) and g = print
14:30:43 <Filthy_Causual> It is "S"?
14:30:47 <erisco> mhm
14:30:53 <erisco> guess what pure is
14:31:03 <Filthy_Causual> return!
14:31:11 <erisco> in context of combinators
14:31:19 <lyxia> https://en.wikipedia.org/wiki/SKI_combinator_calculus Filthy_Causual 
14:31:22 <Filthy_Causual> Oh..K?
14:31:27 <Filthy_Causual> Or I?
14:31:29 <erisco> yup
14:31:43 <Filthy_Causual> K right?
14:31:51 <erisco> no need to guess... look at the type :)
14:33:35 <lyxia> erisco: if you write   \x -> x <$ print x   you can also see that it is \f g x -> f x (g x) with f = (<$) and g = print so what's the point
14:35:26 <erisco> it is slightly shorter, but the point is that it does not use variables
14:35:33 <Filthy_Causual> Yeah most of the savings is in using <$ not in using <*> on <$ .
14:35:35 <erisco> some of us find that a worthwhile improvement
14:36:07 <Filthy_Causual> Really its that I am trying to write monadic code in applicative style.
14:37:40 <Filthy_Causual> Which is maybe dumb. >.<
14:40:23 <lyxia> I guess it's all a subjective trade-off. If you spend less effort deciphering that notation than you spent packing it, all the more power to you.
14:45:10 <Filthy_Causual> Eh, I think its about a wash with do notation.
14:47:05 <ibrahims> hello people, do you know of any examples that use this https://hackage.haskell.org/package/algebra-4.3/docs/Numeric-Coalgebra-Geometric.html
14:49:02 <ibrahims> i took an interest at the geometric algebra but the math seems to heavy. i thought i could get some intuition if i play around with some code. any direction is appreciated.
14:52:24 <koala_man> I have some crusty monadic code where I passed a parameter to each function instead of adding a ReaderT. I'm now fixing it, but just adding the ReaderT (while leaving the existing parameter) slows it down reliably by 10% (39 vs 35 seconds). Is that expected behavior?
14:55:10 <EvanR> transformers arent free!
14:59:27 <pikajude> foldMap f is the same as mconcat . map f, right?
14:59:31 <pikajude> for lists at least
14:59:58 <[exa]> EvanR: I always thought that transformers can be easily totally compiled out?
15:01:15 <phadej> [exa]: it depnds
15:01:44 <phadej> koala_man: but if you leave parameter, then you pass things twice - it's not surprising that way is slower
15:05:44 <anhduy> I try to write a simple application in Haskell but have a problem on maintaining application state. It's a simple WAI app that store all requests in memory to display later. My question is can i use State monad to do it? Do I need IORef or MVar ... They looks confusing to me
15:07:20 <phadej> anhduy: you cannot use State monad, you'll need some *Ref or *Var
15:07:49 <phadej> (to answer why not, think about what happens when two *concurrent* requests come in)
15:08:27 <phadej> I use TVars because STM is cool (and you can have many of them)
15:09:05 <phadej> anhduy: read this https://www.microsoft.com/en-us/research/publication/beautiful-concurrency/
15:09:16 <anhduy> Can you explain a bit more about that. Something likes why and when i should use state monad or *Ref *Var, beside *concurrent* problem
15:09:59 <anhduy> If it's not a web server but something single thread, then how the answer change?
15:12:32 <phadej> anhduy: yes, then State is an option. And is simple one.
15:13:26 <phadej> but then there's another paper to read: http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.144.2237&rep=rep1&type=pdf
15:15:19 <anhduy> thanks, let me read it and comeback to you
15:20:41 <phadej> anhduy: for the record, I don't remember using ST in the past year, but it's good to know it exists. For many iteration problems State is good and fast.
15:26:15 <anhduy> thanks, scan throught the paper but still feel a bit confusing. Because in the paper they still use Mut* thing which is a update inplace. Can we do it without mutable reference?
15:36:22 <cxdf> I'm not sure if I understand the assignment operator (<-) properly. Can anybody help explain what I may doing wrong?
15:36:56 <lyxia> what are you having trouble with
15:37:42 <cxdf> https://pastebin.com/QHxRrB7F
15:38:46 <cxdf> I have a function very similar to the above: But i get an error saying it's expecting `a` to be of type `WebA UTCTime` instead of `IO UTCTime`, So I can't compile. However, I can use it with other Monad types (PGTransaction and such)
15:39:49 <mauke> <- is not assignment and it's not an operator
15:40:36 <cxdf> Okay, the "draw from" keyword. I'm not sure I understand how it works.
15:40:57 <mauke> I recommend not using do notation until you know what it does
15:41:21 <mauke> do { x <- y; ... } is equivalent to y >>= \x -> do ...
15:41:33 <mauke> >>= is an actual operator
15:46:46 <anhduy> phadej: https://stackoverflow.com/questions/10449819/thread-safe-state-with-warp-wai/10452065#10452065 i saw StateT and Mut being use together here. If ignore concurrent issue and only use State without any mutation, how we archieve same behaviour?
16:05:30 <jle`> anyone have a good resource on how to set up ghc boot files for circular dependences
16:06:08 <geekosaur> "try anything else first" :p
16:06:27 <jle`> well i want to define an instance for a type
16:06:43 <jle`> but defining the instance requires....a lot of code
16:06:55 <jle`> i'd like to just be able to define the instance in a separate module to keep things clean
16:07:07 <jle`> or well, define the functions for the instance in a separate module
16:07:22 <jle`> and then just write instance Foo MyType where theMethod = OtherModule.theMethod
16:07:35 <geekosaur> (I meant, that's approximately the *only* resource I've encountered, aside from "look at how others have done it"
16:07:49 <glguy> jle`: Have you already looked at the users's guide?
16:07:50 <geekosaur> nobody wants to document it, maybe they think it'll become common if they do)
16:08:17 <geekosaur> (aside from the guide which isn't much iirc, some tech details)
16:08:35 <glguy> The guide isn't much, but there isn't much to it, so it works out nicely
16:11:46 <jle`> i've been reading through the guide but still piecing together how to work it out
16:15:08 <tikhon> huh, enabling TypeApplications is causing parse errors for me with @-patterns
16:15:14 <tikhon> that isn't intended behavior, is it?
16:15:26 <glguy> tikhon: It seems likely that it would
16:16:01 <glguy> tikhon: We can help you fix it if you're not sure how
16:16:04 <tikhon> oh, and it only happens with certain Unicode characters in my patterns
16:16:18 <tikhon> t_1@(...) is fine but t₁@(...) doesn't parse
16:16:24 <tikhon> but only with TypeApplications enabled
16:16:41 <tikhon> now that I've tried that, I'm really suspicious
16:17:16 <tikhon> But can it cause parse issues in other ways?
16:19:16 <lyxia> how strange
16:19:24 * geekosaur is afraid to ask
16:19:38 <glguy> tikhon: The issue with ₁ sounds like a bug that could be fixed
16:19:39 <tikhon> I'm not sure if x₁ is supposed to be a valid identifier in the Haskell *standard*, but it generally works in GHC.
16:19:56 <glguy> ₁ is in the "other number" category
16:20:08 <tikhon> glguy: yeah, after I thought to change the name and see what happened, the behavior was pretty inconsistent
16:20:11 <geekosaur> should be fine as an identifier character
16:20:30 <tikhon> alright, time to figure out how to submit a bug report
16:20:41 <geekosaur> but I could imagine the code to disambiguate @ checks for changing unicode category without considering the full set of possible identifier chars
16:20:56 <tikhon> geekosaur: yeah, that sounds very plausible
16:21:34 <geekosaur> I think edge cases like that have happened before
16:22:10 <geekosaur> (rarely; most users don't explore much beyond latin-1 subset
16:22:21 <tikhon> I am a big fan of going beyond latin-1 :)
16:22:46 <tikhon> it's a bit controversial at work, but other people do use Greek letters in their code pretty often
16:23:34 <geekosaur> I would be more so if some of the charsets I'd use weren't blacklisted for lack of case
16:23:47 <tikhon> that's annoying :/
16:23:57 <tikhon> which ones are those?
16:24:10 <geekosaur> arabic, hebrew
16:24:15 <tikhon> ah, yeah
16:24:22 <tikhon> I imagine it's similar with a lot of languages
16:24:44 <tikhon> the whole capital/lowercase thing is useful, but becomes incoherent as soon as you're out of a handful of languages
16:24:52 <geekosaur> we need an alphanum equivalent of : prefix
16:24:54 <tikhon> I don't even like the way : works for infix symbols
16:24:55 <glguy> geekosaur: blacklisted?
16:25:35 <tikhon> similarly, there are characters that are treated as operators but shouldn't be
16:25:39 <tikhon> like ∞
16:25:45 <geekosaur> well, the times I tried (granted, not recently) if it can't tell if it is a constructor or not so it refuses it
16:26:05 <glguy> geekosaur: As far as I know the current state of affairs is Uppercase and "Nonuppercase"
16:27:04 <glguy> > let אה = "stuff" in אה
16:27:06 <lambdabot>  "stuff"
16:27:32 <tikhon> I guess you could have a convention like "C is the alphanum equivalent of :"
16:27:35 <tikhon> but it would be pretty ugly
16:27:35 <glguy> map Data.Char.generalCategory "אה"
16:27:38 <glguy> > map Data.Char.generalCategory "אה"
16:27:40 <lambdabot>  [OtherLetter,OtherLetter]
16:27:52 <geekosaur> ok, so guess that's improved. it used to not like OtherLetter
16:28:19 <Tuplanolla> Akkadian is still a mess.
16:29:53 <Tuplanolla> > map Data.Char.generalCategory "𒋺𒐡"
16:29:55 <lambdabot>  [OtherLetter,LetterNumber]
16:29:57 <geekosaur> but we're a couple thousand years from anyone caring enough to fix it :p
16:31:19 <EvanR> in 4017 itll be unicode 323.0
16:32:05 <EvanR> and still be broken
16:38:24 <toad__> If I try to install any package or do 'stack path' I get some weird error about Swagger.. https://pastebin.com/4h5y0rrZ
16:38:57 <toad__> I've tried stack clean, and I'm confident that I've never explicitly installed swagger. Happens in global project .. weird stuff
16:40:38 <MarcelineVQ> it's not about swagger exactly, just some file signature mismatches, try updating your stack if it's not the most recent
16:41:06 <toad__> It's the newest. Also, Stack update does finish w/o errors
16:41:07 <MarcelineVQ> as an aside I don't think ghc-modi is a package, it'll be installed with ghc-mod
16:45:58 <MarcelineVQ> no idea why servant-swagger-ui would be coming up :(
16:46:35 <MarcelineVQ> It should be complaining about not finding ghc-modi rather than anything else
16:46:56 <toad__> i get the same message if i remove ghc-modi from command
16:47:42 <MarcelineVQ> should have gotten that error though :X what version of stack do you have?
16:48:15 <toad__> 1.4.0
16:51:07 <MarcelineVQ> hmm wonder if it's an s3 issue then, something old being served. one possible option is to delete your .stack/indices dir to reset the state of what stack knows about hackage
16:51:30 <MarcelineVQ> The only thing else that comes to mind is to try again later, which isn't super helpful
17:03:57 <pera> What's the meaning of an expression like 1=1? my ghci doesn't return anything (ie no value nor error) when I try something like that
17:04:38 <kebertx[m]> That doesn't look like a valid expression
17:04:46 <tikhon> pera: 1 is a valid pattern—think about how you can use it in a function definition
17:04:50 <hpc> patterns with numeric literals translate into guards and equality testing
17:05:24 <pera> oh I thought that pattern matching was only available inside a function
17:05:30 <hpc> let 1 = 1 in <expr> translates to let unusedName | unusedName == 1 = 1 in <expr>
17:05:51 <hpc> or something like that
17:05:51 <Welkin> it's because of that new feature in ghci where you can omit the `let`
17:05:51 <tikhon> pera: you can have a pattern anywhere you define a name, including top-level declarations
17:05:56 <tikhon> it's very useful sometimes
17:05:59 <Welkin> ghci is just a mess...
17:05:59 <tikhon> (a, b) = (1, 2)
17:06:11 <tikhon> [a,b,c,d] = "abcd"
17:06:29 <tikhon> but since the pattern 1 doesn't bind any names, 1 = 1 does not do anything
17:06:44 <Welkin> == is logical equality, if that is what you are looking for
17:07:05 <tikhon> in GHCi, it's also often really useful to have partial patterns
17:07:13 <tikhon> Just x = ...
17:07:15 <pera> I mean, it makes sense when you have an unbound symbol on the left side of the =, but I am not sure to understand the meaning of a literal being equal to something else
17:07:40 <hpc> here's a better example where you can see it actually do something
17:07:41 <Welkin> > let 3 = 2 in 2 == 3
17:07:43 <lambdabot>  False
17:07:51 <Welkin> lol
17:07:56 <pera> > 1 = 2
17:07:56 <hpc> > let (5, 1) = (4, 2) in "example"
17:07:58 <lambdabot>  <hint>:1:3: error:
17:07:58 <lambdabot>      parse error on input ‘=’
17:07:58 <lambdabot>      Perhaps you need a 'let' in a 'do' block?
17:07:58 <lambdabot>  "example"
17:08:00 <hpc> er
17:08:14 <hpc> > let (x, 1) = (5, 2) in "example: " ++ show x
17:08:16 <lambdabot>  "example: *Exception: <interactive>:3:5-19: Irrefutable pattern failed for p...
17:08:20 <hpc> > let (x, 1) = (5, 1) in "example: " ++ show x
17:08:22 <mniip> let 3 = 2 is akin to defining a global identifier by pattern matching
17:08:23 <lambdabot>  "example: 5"
17:08:34 <mniip> but like always with literals it's using Eq
17:08:52 <hpc> pera: mess with those two expressions and see how they work
17:09:08 <Welkin> > let 3 = 2 in 2 + 3
17:09:10 <lambdabot>  5
17:09:18 <pera> hpc: I will try it, thanks
17:09:20 <hpc> and take a second look at what let-bindings are with that behavior in mind
17:09:49 <hpc> that section of the report miiiiight be one of the ones that's hard to read, but i don't remember
17:10:33 <mniip> Welkin, no like
17:10:44 <mniip> f (Just v) = e
17:10:47 <mniip> f 3 = e
17:10:51 <mniip> (Just v) = e
17:10:57 <mniip> complete the lattice: 3 = e
17:11:33 <mniip> > let x@3 = 3 in x
17:11:35 <lambdabot>  3
17:11:37 <mniip> > let x@3 = 2 in x
17:11:39 <lambdabot>  *Exception: <interactive>:3:5-11: Irrefutable pattern failed for pattern x@3
17:12:08 <hpc> pera: oh, add irrefutable patterns to your list of things to read up on
17:12:22 <hpc> if you don't run into it on your way through let-in
17:12:37 <Welkin> and the monomorphism restriction
17:12:39 <Welkin> while you're at it
17:13:15 <mniip> and monomorphisms!
17:13:25 <mniip> even though they're irrelevant
17:13:32 <pera> it's just something I had never tried before because it doesn't seem to make much sense grammatically in that context
17:14:20 <tikhon> pera: this *specific* definition is pretty meaningless, but it's a combination of two separate things that do make sense
17:14:30 <tikhon> (ie patterns in top-level definitions and numeric literals in patterns)
17:14:46 <Welkin> I thought there was an example of being able to redefine literals
17:15:00 <mniip> hmm
17:15:02 <Welkin> so that 2 + 2 = 5
17:15:05 <tikhon> <pattern> = <expression> makes sense, and 1 is a <pattern> that matches against 1
17:15:15 <mniip> can you explicitly type pattern-bound things
17:15:16 <tikhon> it's the same way that _ is a pattern that just ignores what it matches
17:15:18 <tikhon> so you can write
17:15:20 <tikhon> > _ = 1
17:15:22 <lambdabot>  <hint>:1:3: error:
17:15:22 <glguy> Welkin: that example redefines +
17:15:22 <lambdabot>      parse error on input ‘=’
17:15:22 <lambdabot>      Perhaps you need a 'let' in a 'do' block?
17:15:30 <tikhon> > let _ = 1
17:15:31 <lambdabot>  <no location info>: error: not an expression: ‘let _ = 1’
17:15:38 <mniip> @let _ = 1
17:15:40 <lambdabot>  Defined.
17:15:43 <tikhon> okay, never mind, lambdabot is weird
17:15:49 <tikhon> but do you see what I'm getting at?
17:15:52 <mniip> no it's just you
17:15:52 <Welkin> lambdabot is not ghci
17:15:56 <pacak> > let _ = 4 in 5
17:15:58 <lambdabot>  5
17:16:17 <tikhon> by the way, you could also do all of this at the top level of a Haskell module in a file
17:16:29 <mniip> hum
17:16:52 <mniip> :t let x | x = x in x
17:16:53 <lambdabot> Bool
17:16:54 <mniip> \o/
17:18:00 <glguy> :t case show of f -> let _ = f True in f
17:18:01 <lambdabot> Bool -> String
17:18:11 <glguy> Look, let _ = doesn't have to be useless, it can help with types :)
17:18:49 <tikhon> ooh, we got a built-in function to count leading zeros in Data.Bits since the last time I looked at it
17:19:09 <Welkin> leading zeros in what representation? binary?
17:19:14 <tikhon> yes
17:19:22 <tikhon> it's in Data.Bits
17:19:59 <tikhon> I had some cute shifty code I copied from somewhere (Data.IntMap probably), but this is much better
17:20:24 <tikhon> it's implemented as a CPU instruction for primitive integral types now
17:47:27 <zoey> hey i'm learning haskell and i'm having a hard time understanding the `take5s` part in `let take5s = filter (==5) in take5s [1,5,2,5,4,5]`... I just... don't get the syntax... like I know what happens but I don't know what it's saying...
17:48:00 <tikhon> let is a way to define names within an expression
17:48:02 <zoey> like why not just filter (==5) [1,5,2,5,4,5]?
17:48:12 <tikhon> so let x = 1 in x + x is the same as 1 + 1
17:48:22 <tikhon> in this case, you're defining take5s to be the function filter (== 5)
17:48:31 <tikhon> and then you're applying it to [1,5,2,5,4,5]
17:48:42 <zoey> oh i see this hurts my head but ok i get it thanks
17:48:52 <zoey> i'm doing tryhaskell.org rn
17:51:27 <geekosaur> in this case it's not really needed. you might do this if you're reusing the expression a lot, or in order to break down a more complex expression into smaller/more comprehensible pieces
17:57:53 <zoey> thanks <3
17:58:19 * hackagebot HDBC-session 0.1.1.1 – Bracketed connection for HDBC – https://hackage.haskell.org/package/HDBC-session
18:03:23 * hackagebot names-th 0.2.0.3 – Manipulate name strings for TH – https://hackage.haskell.org/package/names-th
18:08:26 * hackagebot sql-words 0.1.5.1 – SQL keywords data constructors into OverloadedString – https://hackage.haskell.org/package/sql-words
18:13:30 * hackagebot text-postgresql 0.0.2.3 – Parser and Printer of PostgreSQL extended types – https://hackage.haskell.org/package/text-postgresql
18:18:34 * hackagebot jose 0.6.0.3 – Javascript Object Signing and Encryption and JSON Web Token library – https://hackage.haskell.org/package/jose
19:09:09 <schmidt73> k
19:27:07 <xylospongium> hi newbie question here
19:27:36 <xylospongium> I want to create a type that has a constructor with two fields: an integer and a list.
19:27:50 <geekosaur> list of what?
19:28:23 <xylospongium> of any type
19:28:52 <geekosaur> not in Haskell, not without a *lot* of scrambling around
19:29:13 <xylospongium> I want to throw an exception if the length if the list is not equal to the provided integer. I know this is easy to do in Idris with dependent types
19:29:21 <xylospongium> but is there a work around for Haskell?
19:29:46 <Welkin> why would you throw an exception?
19:29:53 <Welkin> exceptions are not for normal control flow
19:29:58 <xylospongium> ah
19:30:00 <Welkin> they are for *exceptional* cases
19:30:13 <Welkin> like the program blows up
19:30:19 <geekosaur> there's a couple of counted list types on hackage, I think. it can be done, it's a bit annoying because we don't have real dependent types
19:31:55 <xylospongium> ok that should help thanks
19:32:41 <Welkin> by list of any type, do you mean a heterogeneous list?
19:33:06 <Welkin> or a generic homogeneous list? (forall a. List a)
19:33:07 <Welkin> ?
19:33:28 <ReinH> xylospongium: Idris doesn't throw an exception. Idris makes it a type error that prevents your program from compiling.
19:33:33 <xylospongium> no a homogenous list
19:34:01 <xylospongium> ah ok thanks for clearing up the difference ReinH
19:37:25 <pacak> instead of throwing an exception you can make a smart constructor that takes Int, [a] and produces Maybe YouType
19:37:56 <pacak> In YourType's type you can keep length as well.
19:38:19 <pacak> With type level numerals you can make operations on YourType to preserve this length.
19:38:35 <pacak> No exceptions needed.
19:38:51 <cheater> hello
19:38:55 <cheater> is brendan hay on this channel?
19:39:24 <Welkin> cheater: the guy from the Mummy?
19:40:15 <xylospongium> ah thanks pacak
19:40:28 <cheater> ? no
19:48:25 <dmj`> cheater: sometimes, why
19:50:36 <trigone> hi, can't stay long, but i wondered how long it took you guys to reach an arbitrary level of proficiency in haskell? so i can build a certain expectation
19:51:43 <MarcelineVQ> an arbitrary ammount of time
19:51:56 <pacak> http://imgur.com/TTBBeJs
19:52:05 <pacak> trigone: ^ somewhat accurate.
19:57:39 <Welkin> trigone: by arbitrary, you mean able to program something other than toy exercises? Like a web app?
19:57:43 <Welkin> trigone: about 3 months
19:58:24 <trigone> pacak: why are lens that big of a deal? is it that horribly difficult?
19:58:53 <Welkin> they are very useful (for there specific use case), but not necessary if you never need to use deeply nested data structures
19:59:03 <Welkin> you can use them without understanding how they work
19:59:08 <Welkin> but they are not *that* complicated either
19:59:20 <Welkin> edward has several talks he has given explaining how they work
19:59:37 <dmwit> trigone: I have been hacking in Haskell for around ten years now, and I still feel like I'm learning new things from time to time.
19:59:58 <trigone> Welkin: pretty cool. although i did not know you could build web apps in something else than JS. unless you compile haskell to js or something?
20:00:14 <trigone> dmwit: yes i did not imply there was an end to learning haskell
20:00:14 <Welkin> trigone: a web app can be statically rendered on the server
20:00:24 <Welkin> it doesn't mean a client-side application
20:00:25 <Welkin> but yes
20:00:30 <Welkin> you can compile haskell to javascript using ghcjs
20:00:42 <Welkin> haskell is extremely good for web servers
20:00:54 <dmwit> trigone: Then again, I also strongly identify with the attitudes espoused in "Teach Yourself Programming in Ten Years" (http://www.norvig.com/21-days.html).
20:01:15 <trigone> Welkin: so i heard, though i also heard there was limitations to flexibility. but then it was on a blog mostly advocating OO stuff...
20:01:35 <Welkin> trigone: look at scotty, spock, yesod, and servant
20:01:57 <Welkin> I don't use anything but haskell for my web servers any more
20:02:00 <Welkin> nothing beats it
20:02:26 <trigone> Welkin: someday maybe, for now i gotta sleep :) but i heard of them, and if you vouch for it by experience, i take that as a good sign
20:02:34 <Welkin> even if I might use javascript or purescript for the client-side portion
20:02:44 <trigone> dmwit: i'll read that post, seems insightful
20:02:45 <cheater> dmj`: i wanted to ask him about one of his libraries.
20:03:22 <cheater> dmj`: does he come here often or should i use email instead?
20:03:51 <trigone> thanks all for your answers, bye!
20:08:30 <dmj`> cheater: worth a try
20:08:48 <cheater> dmj`: ok
20:09:10 <cheater> dmj`: i wanted to use googol-youtube but i don't know how i would, say, log into my account to see private lists.
20:13:07 <dmj`> cheater: I think gogol tries to discover your credentials in your environment somehow, be it a file or environment variable
20:13:15 <dmj`> cheater: here, https://github.com/brendanhay/gogol/blob/f14b3b61ef8e4839b588715c09bea96b76a428d4/gogol/src/Network/Google/Auth/ApplicationDefault.hs#L61-L85
20:14:03 <dmj`> cheater: I would copy what this example does, but import the channels module instead, https://github.com/brendanhay/gogol/blob/master/examples/src/Example/Storage.hs#L34
20:18:24 <cheater> dmj`: hmm, interesting. the link (and the linked doc therein) doesn't actually say what the credential files should look like, though..
20:18:42 <cheater> oh wait
20:19:06 <cheater> " The environment variable GOOGLE_APPLICATION_CREDENTIALS is checked. If this variable is specified it should point to a file that defines the credentials. The simplest way to get a credential for this purpose is to create a Service account key in the Google API Console: ...     Go to the API Console Credentials page."
20:19:49 <cheater> that's an issue. you need an api key, and i'm not looking to do that. i would like to just use my google login and use the api available to end users, like you can do with the youtube python module for example
20:20:39 <cheater> this is, after all, just for use with my private data
20:20:54 <dmj`> cheater: there is a gitter for gogol, and it seems brenday hay has been active on it, https://gitter.im/brendanhay/gogol
20:21:15 <cheater> oh, i didn't realize gitter was useful in that way. i've never used it before, thanks
20:24:32 <cheater> nice link, thank you :)
21:10:01 <vimalloc> Noobie question :) I'm getting more and more comfortable with monads, and am working on stuff that uses a lot of Maybe's. My code right now works fine, but there are a lot of 'where' statements for making named variables all over the place. I am thinking about converting these to 'do' notation with let bindings, as functionally it will be the same thing, but when I need a named variable it will be right
21:10:03 <vimalloc> there in the code, instead of having to look for it in the 'where' block below and then finding where I am in the function again.
21:10:15 <vimalloc> Is that a terrible reason to use the do notation?
21:10:36 <geekosaur> er. let-in is a thing
21:10:40 <geekosaur> > let x = 5 in x * x
21:10:42 <lambdabot>  25
21:12:00 <geekosaur> note that expressions don't normally give you nice places to "stop" and insert a let in the same way you would in do notation
21:13:00 * hackagebot persistable-record 0.4.1.2 – Binding between SQL database values and haskell records. – https://hackage.haskell.org/package/persistable-record
21:13:18 <vimalloc> I could look at that, but for this stuff I have a gut feeling like let would be more cumbersom as I had more named variables that were used in multiple places
21:13:40 <geekosaur> (and using do notation for a pure expression is not going to give you those places either)
21:13:49 <vimalloc> Unless, can You do multiple lets together
21:14:01 <vimalloc> let x = 5, y = 6 in x + y
21:14:05 <vimalloc> something like that?
21:14:11 <geekosaur> use braces and semicolon, or layout
21:14:19 <geekosaur> > let {x = 5; y = 6} in x + y
21:14:21 <lambdabot>  11
21:14:46 <vimalloc> Interesting... Thx.
21:14:48 <monochrom> Conservation of matter-energy implies that switching from "where" to "let" preserves the number of bindings.
21:17:19 <hexfive> does anyone know why I'm getting this error?
21:17:22 <hexfive> Module ‘Data.Map.Strict’ does not export ‘(!?)’
21:17:34 <hexfive> with an import stmt:
21:17:36 <hexfive> import Data.Map.Strict (Map, (!), (!?))
21:18:09 <glguy> hexfive: Presumably because  ‘Data.Map.Strict’ does not export ‘(!?)’
21:18:13 <monochrom> Does (!?) actually exist?
21:18:18 <glguy> (because it was added in a newer version than you have)
21:18:21 <vimalloc> so just in general, is there a preference for using let vs where?
21:18:21 <geekosaur> ^
21:18:24 <hexfive> ahh, i see
21:18:27 <hexfive> thanks!
21:18:48 <monochrom> No preference. Do what's aesthetic to you. Go with your heart.
21:18:56 <geekosaur> containers is under active development, it also comes with ghc so you are likely to have an older one than hackage shows as latest
21:19:32 <geekosaur> and yes, there have been a few additions to containers since the last ghc release that updated containers. probably 8.2.1 will have a newer version
21:32:12 <Rotaerk_> program with your heart
21:33:41 <vimalloc> ok, last question for the night. I have some helper functions in the 'where' block of another function. In the top level function, I may have something like 'where x = 3'. In my helper functions (in the same where block), I don't have to pass x to the function to use it in said function. Would doing that be considered bad style? I like it because it keeps my helper function definitions from blowing up, but
21:33:43 <vimalloc> on the flip side if I ever needed to make them a top level function I would need to reformat it to include 'x'
21:35:52 <vimalloc> I think that sentence got away from me. For a more concrete example, something like this: https://gist.github.com/vimalloc/e0d9ef6dc7f4f93f14e1d7fd09f39d77
21:36:02 <vimalloc> Specifically the 'incPoint' in there.
21:38:06 <monochrom> It is OK to do that.
21:38:50 <vimalloc> Awesome, thx for all the help guys! <3
21:42:59 <minn> I need to implement the functionality of `yyless(0)` in Alex (i.e., force the current input to be rescanned), possibly after performing some actions (e.g., pop startcodes off a stack). I'm a little unclear how to accomplish this, and the documentation isn't that revealing. Any advice?
22:07:17 <minn> ah, nevermind. you can just explicitly reset the input.
22:16:16 <adamCS> cocreature:  Turned out a lot of my issue was specialization/inlining.  A painful tour through some Core showed me the specialization problem and then inlining a bunch of things nearly fixes it.  But, oddly, just doing specialize doesn't fix things and just making all the things INLINEABLE doesn't do it either.  Quite a few seem to actually need to be INLINE.  Performance loss now closer to 20% instead of >100%. 
22:18:02 <adamCS> cocreature: Anyway, off to sleep for me. 
22:27:05 <slack1256> ghc -ddump-simp will print core right?
22:28:05 <pacak> slack1256: It should. There's also -ddump-to-file and -dsuppress-all to make output easier to work with.
22:28:35 <MarcelineVQ> also  -ddump-prep  can't recall the differences from simpl directly
22:29:29 <tippenein> http://lpaste.net/356971
22:29:51 <tippenein> is there a nice way to use non-pure values for guard clauses?
22:33:35 <MarcelineVQ>   | uid <- isAdmin, uid    = return Authorized     maaaaybbe, not sure, that's called a PatternGuard  not quite sure how it fits together for your case, or if it does, 
22:33:55 <MarcelineVQ> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#pattern-guards
22:34:40 <glguy> tippenein: IO actions are also "pure values", but you can't execute an action in a guard, no
22:35:07 <slack1256> that will just confuse him, i think
22:36:38 <tippenein> yeah, sorry. didn't know what word to use there
22:38:36 <pacak> glguy: He can with unsafePerformIO, but it's not a very good idea.
22:38:51 <glguy> No, that's not a serious alternative
22:39:00 <nshepperd> do { admin <- isAdmin uid; foo <- isFoo; if { ... }}
22:39:05 <nshepperd> with MultiWayIf
22:39:10 <nshepperd> or a case statement
22:40:13 <nshepperd> or a helper function with guards i guess
22:40:32 <tippenein> MarcelineVQ: your | b <- isAdmin uid  = return Authorized seems to compile
22:40:47 <tippenein> it's weird tho because I don't acutally require the b at all
22:40:49 <pacak> How about
22:40:49 <pacak> whenM (isAdmin uid) $ ....
22:41:01 <slack1256> if is a non-IO monad, you could use the run function for it and bind the value with patternGuards
22:41:08 <mniip> tippenein, if you tried to require b it would type-error
22:41:17 <mniip> right now your guard does nothing
22:41:44 <nshepperd> i suspect that <- means something different in a guard
22:41:55 <MarcelineVQ> tippenein: I was in error, you can't unpack IO so there's no reasonable way to use guards the way I had intended :(
22:43:31 <MarcelineVQ> conversely something like   | Just b <- maybeIsAdmin uid, b  = return Authorize   would work because you're able to examine the b by pattern matching it, IO doesn't have a constructor to match on
22:46:58 <mniip> nshepperd, same as in a list comprehension
22:47:10 <mniip> different from a do-block yes
22:47:24 <tippenein> MarcelineVQ: the MonadIO in my exmaple is actually "Handler" from yesod in my application
22:47:34 <tippenein> so, what you suggested worked perfectly
22:47:57 <tippenein> I picked a bad placeholder for my example 
22:48:34 <tippenein> hmm.. or maybe comes out True
22:48:36 <MarcelineVQ> Are you sure? if you're not using the b you're not really performing a check, you're just going along with an irrefutable pattern
22:50:14 <tippenein> yeah. it's true for every case
22:50:18 <MarcelineVQ> > let  foo | Just b <- Just False = "yay" in foo
22:50:20 <lambdabot>  "yay"
22:51:33 <glguy> tippenein: You can't use a pattern guard (this <- syntax) to execute an action like isAdmin
22:54:58 <tippenein> what other options do I have?
22:55:21 <MarcelineVQ> two were mentioned above you should have a look at first
22:55:34 <MarcelineVQ> by nshepperd_  and pacak 
22:56:02 <pacak> I mentioned two options, one of them is stupid. Don't do that.
22:56:25 <tippenein> I looked past the unsafePerform option :D
22:56:37 <tippenein> whenM tho
22:57:49 <tippenein> what does the otherwise case look like in the whenM case?
22:58:05 <pacak> return ()
22:58:38 <pacak> You can write ifM if you want to do something specific.
23:04:51 <glguy> I was doing a solution to the "Simple Interactive Interpreter" on codewars.com this weekend. You have a make a program that takes a list of function definitions and expressions and then store the functions and evaluate the expressions in the context of the functions
23:05:21 <glguy> I kind of lost my mind when parsing was expected to vary based on the arity of functions, e.g.
23:05:29 <glguy> ["fn echo x => x", "fn avg x y => (x + y) / 2", "avg echo 4 echo 2"]
23:05:39 <glguy> That's supposed to mean:  avg (echo 4) (echo 2)
23:05:48 <glguy> Who does this??
23:05:51 <mniip> perl
23:06:19 <glguy> o.O
23:06:22 <mniip> it's really simple to reassociate though
23:06:35 <mniip> much simpler than hacks GHC uses for your infix operators
23:06:42 <pacak> adjust with regexps and pipe into php :)
23:06:49 <pacak> Or use parsec
23:06:51 <glguy> I implemented it, I just think it's terrible and I feel bad for the author of the exercise
23:07:05 <jle`> feel bad for the victims
23:07:32 <mniip> glguy, well imagine parsing "3 `avg` 5 + 2"
23:07:45 <mniip> and then in 3 years being told "infixr 7 `avg`"
23:07:51 <glguy> mniip: That is quite reasonable to parse
23:08:17 <mniip> really the same as your excercise
23:08:28 <mniip> parse into list of words, reassociate when you have arity data
23:08:55 <geekosaur> well actually perl does not do quite that, but close. would need to be avg echo 4, echo 2
23:09:23 <mniip> yeah, for sub avg($$), sub echo($)
23:09:49 <mniip> and it's not like anyone uses those signatures extensively
23:09:59 <glguy> mniip: Why is it simpler than the infix hacks?
23:10:26 <mniip> glguy, in ghc fixity data is available way too late
23:10:52 <mniip> only after renaming
23:11:06 <glguy> and that's later than arity?
23:11:56 <mniip> ok, let's settle on a less-than-or-equal
23:12:57 <geekosaur> glguy, you have to feed the prototype info back to the parser but once you've done that (and that's not anything special, it's more or less the same thing as C's typedef problem) it's not hard to parse those
23:14:10 <glguy> I don't think it's hard to parse, I think it's hard to read
23:14:17 <geekosaur> I would still take a stick to the dev who came up with it, though; parsers can handle it fine, it's the ... that
23:14:26 <geekosaur> it's a nightmare for the next person who has to deal with the code
23:14:35 <geekosaur> (including you, 6 months later)
23:20:24 <pacak> Suppose I have a computation that can be represented by Alternative: blah <$> (get "foo1" <|> get "foo2") <*> (get "bar1" <|> get "bar2"), where foo* and bar* are doing lookups in some map that's in scope.  I don't know on compile time values that will be in this map, but I will know it on run time. What are my options to optimize this expression to blah <$> get "foo2" <*> get "bar1" once I know that keys "foo2" and "bar1" will be present?
23:21:02 <glguy> They didn't test it, but the defined 'function-call   ::= fn-name { expression }' which means   f 1 + 2 would parse as f (1+2)
23:21:24 <glguy> https://www.codewars.com/kata/simple-interactive-interpreter
23:27:08 <jle`> pacak: i suppose depending on how your computation is structured, you can reify the call tree and make such optimizations
23:28:47 <pacak> jle`: I can represent it in any way I want as long as I can fetch a bunch of things and apply them to a function with some arbitrary type so the problem is how to represent this tree with sane syntax.
23:29:24 <jle`> when i can't figure out how to represent trees like this i just usually use a free structure
23:29:39 <jle`> and in most cases it works ok
23:29:46 <jle`> there's a Free Alternative you can use
23:29:50 <glguy> pacak: My config-schema package works much like this
23:29:58 <glguy> a free applicative of alternatives
23:30:23 <glguy> and then I'm able to inspect the structure of those values at runtime
23:31:09 <pacak> jle`: I tried free monads/free applicative - the problem is - I can't get past monadic bind operation (a -> m b) - I don't have at that time a to get m b so with them I can optimize only a small fraction of a tree.
23:31:18 <jle`> depending on your use case it might even make more sense to do blah <$> result-of-get-foo2 <*> result-of-get-bar1
23:31:45 <jle`> pacak: not sure what you mean by getting past monadic bind operation
23:31:57 <pacak> jle`: Schema will stay the same, but data will be changing all the time.
23:32:09 <jle`> ah yes
23:32:23 <jle`> not sure what monadic bind has to do with anything here though
23:32:26 <glguy> pacak: why do you need a bind operation on this type?
23:32:37 <jle`> do you *want* your type to have a monadic bind?
23:33:04 <pacak> Hmm.... so m b is either (Return b) - which is trivial to process or act1 >>= act2 and to get to monadic value of act2 I need to produce something from act1 first - which I can't do.
23:33:22 <glguy> pacak: You wouldn't use a free monad for this
23:33:27 <glguy> Have you seen https://glguy.net/config-demo/ ?
23:33:29 <pacak> glguy: I probably don't need it.
23:33:48 <pacak> glguy: looking at it right now.
23:34:00 <jle`> not sure why you are concerning youself with >>=
23:34:03 <jle`> unless i misunderstood what you wanted
23:34:10 <jle`> you just wanted something that is only an Alternative and Applicative
23:34:13 <jle`> and not a Monad, right?
23:34:25 <pacak> Alternative is enough
23:34:27 <speak> Hi! Any ideas, I'm getting some errors when trying to run stack build: https://paste.xinu.at/8uxlV/
23:34:40 <glguy> pacak: Is 'styleSpec' similar to what you're doing? http://hackage.haskell.org/package/glirc-2.23/docs/src/Client.Configuration.Colors.html#colorSpec
23:34:42 <jle`> yes, so you don't even need to ever worry about a >>=
23:34:54 <speak> OS is Arch Linux
23:35:36 <pacak> jle`: Ap ::  f a -> Alt f (a -> b) -> AltF f b  -- free alternative.
23:35:39 <cocreature> speak: see https://github.com/commercialhaskell/stack/issues/3268 install ncurses5-compat-libs and maybe uninstall libtinfo
23:36:01 <pacak> f a - is something I can easily process, but second argument requires a to produce Alt f b
23:36:10 <pacak> Or something like that. Similar to bind.
23:36:17 <glguy> If you're using Arch Linux you have to remember to read the website before updating and check the wiki to see what's been broken recently
23:36:23 <speak> cocreature: Thank you so much, I'll try those
23:36:34 <jle`> pacak: you shouldn't need to directly use the Ap constructor
23:36:47 <jle`> it's sort of exported as an implementation detail
23:37:01 <jle`> you really should be only using 'liftAlt :: Functor f => f a -> Alt f a'
23:37:02 <speak> glguy: I do check that out yeah :D
23:37:38 <cocreature> glguy: that wouldn’t have helped in this case :)
23:38:32 <glguy> Why, is someone stopping people from putting information like this on the arch wiki?
23:38:42 <jle`> the AltF type and the Alt constructor in that module really should be hidden, heh
23:39:13 <cocreature> glguy: no but nobody has put it on the wiki so far :)
23:39:46 <pacak> jle`: I need to take one Alt f a, trim all the dead branches and create either different Alt f a or f a that will have no branches and functor will be a simple reader.
23:39:52 <glguy> That's too bad. Part of why it's OK for Arch to be so fragile is that people put stuff on the wiki
23:39:59 <jle`> pacak: mhm
23:40:08 <jle`> pacak: that's what you'd use runAlt for
23:40:44 <jle`> runAlt :: (forall x. f x -> Alt f x) -> Alt f x -> Alt f x, if you don't want Reader
23:40:48 <jle`> oops
23:41:03 <jle`> runAlt :: (forall x. f x -> Alt f x) -> Alt f a -> Alt f a
23:41:25 <pacak> Let me try...
23:41:30 <jle`> runAlt :: (forall x. f x -> ReaderT r (Alt f) x) -> Alt f a -> ReaderT r (Alt f) a
23:41:40 <jle`> if you need the 'r' Reader environment
23:42:06 <jle`> if i unwrap the newtype wrapper that's runAlt :: (forall x. f x -> r -> Alt f x) -> Alt f a -> r -> Alt f a
23:42:17 <jle`> reduce an Alt wit an environment
23:42:18 <speak> glguy: Yeah I mean this problem just popped up so I think nobody's had a chance to update the wiki yet
23:42:29 <speak> I'll update it once I have stuff working
23:42:37 <jle`> if an 'f x' is a dead end, have it return 'empty'
23:43:06 <jle`> and it won't be included in the resulting Alt f a
23:43:16 <glguy> The Alt type has never been what I wanted. it expand into a single sum of products
23:43:35 <glguy> you lose all nesting structure
23:44:47 <glguy> because it makes assumptions that aren't promised by the alternative class
23:45:48 <glguy> actually maybe I'm reading that wrong
23:46:09 <pacak> jle`: You're right, runAlt was enough.
23:46:48 * glguy retracts objection
23:47:36 <jle`> if alternative respects nesting structure then wouldn't <|> not be associative?
23:47:41 <jle`> or am i understanding this wrong
23:47:58 <pacak> TODO: figure out what exactly I was doing wrong, how to do it properly but in a way I did it before, look at config-demo
23:48:25 <glguy> i meant nesting under <*>
23:49:13 <glguy> but I'd missed an Alt vs AltF in the type
23:49:55 <jle`> yes the mutually recursive type is kinda neat, i'll admit that i don't understand anything about the underlying implementation of Alt
23:50:01 <speak> cocreature: It looks like it's working, hooray :)) Was banging my head against the wall with this last night
23:50:06 <jle`> i just stick with liftAlt and runAlt
23:50:42 <jle`> and trust in kmett
23:51:00 * pacak prefers to understand
23:52:06 <Axman6> In kmett we trust, but without blind faith we verify
23:52:29 <jle`> i mean, if something claims to be called a "free applicative", you can already completely determine its behavior w.r.t. liftAlt and runAlt
23:54:06 * jle` hopes nobody calls his bluff
23:54:31 * Enamex calls jle` 's bluff
23:54:31 <pacak> I figured out this much when I started looking for solutions - free something is what I need and if I want to limit users's abilities to meddle with data - I need free applicative/alternative. It's just when trying to actually implement it - I got lost somewhere.
23:55:18 <jle`> for me i reach for "free something" if i know i want some recursive tree type but i don't want to bother with picking an actual tree or dealing with explicit recursion
23:57:46 <pacak> Hmm... I wonder how to get from Alt f a to g a but with Applicative only restriction on g.
23:58:31 <jle`> well you can use MaybeT to give g a free Alternative instance
23:58:37 <glguy> wrap g in a type that provides an Alternative
23:58:55 <pacak> Anyway, gym time. jle`, glguy, thanks for your help.
23:59:17 <jle`> `MaybeT g` imbues g with a 'first success' Alternative instance
23:59:35 <jle`> no problem, have fun!
