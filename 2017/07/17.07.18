00:00:13 <EvanR> cocreature: it might have predated bang patterns...
00:00:24 <wz1000> jle`: the c function is isatty()
00:00:33 <cocreature> EvanR: well we have had seq for ages, no?
00:00:36 <wz1000> should be a binding or somwthing somewhere
00:00:38 <cocreature> so I don’t accept that as an excuse
00:00:42 <Lokathor> jle`, use inlinec to call isatty(), clearly
00:00:44 <cocreature> jle`: https://hackage.haskell.org/package/unix-2.7.2.1/docs/System-Posix-Terminal.html#v:queryTerminal
00:00:45 <EvanR> yep
00:00:55 <jle`> ty
00:01:04 <Lokathor> jle`, also plz avoid the unix package it's not win32 compat :(
00:01:05 <jle`> with a package name like 'unix', should i expect it to be portable?
00:01:50 <cocreature> who would have thought that the unix package doesn’t work on windows
00:02:10 <jle`> joke's on all of you, it works on the ubuntu for windows subsystem
00:02:26 <Cale> cocreature: To be fair, I'd be very surprised if the strictness analyser doesn't get that one.
00:02:28 <Lokathor> but i have only win7
00:03:33 <cocreature> Cale: yeah, I just really hate that a lot of example code doesn’t use strictness where it should because the strictness analyzer should catch it and then when people move to more complex code they are scared by “horrible spaceleaks that you can’t debug”
00:04:32 <cocreature> I’m with neil mitchell on that part: if your code has a spaceleak with -O0 it’s a bug
00:04:46 <jle`> i never trust the strictness analyzer
00:05:18 <cocreature> but we can’t even get "sum" and "product" right in base so I feel like I’m fighting a lost fight
00:05:20 <Lokathor> I rewrote an entire module to have all Int values converted to Int# as much as possible
00:05:29 <Lokathor> even wrote an Int# based list indexing func
00:05:35 <Lokathor> never strict enough
00:05:36 <EvanR> so that seems over the top
00:05:52 <EvanR> like changing the names of js variables to get more speed
00:06:05 <Lokathor> naw you think it's a joke but it ran like 20% faster so
00:06:16 <EvanR> :(
00:06:25 <EvanR> the compiler should be doing that for you!
00:06:34 <cocreature> and you’re sure you didn’t have some spaceleak somewhere before?
00:06:35 <jle`> in fact i'm also really bugged that sum/product are implemented in ghc 8 as foldl instead of foldl'
00:06:40 <Lokathor> and that's on top of having done one pass to convert to ST already
00:06:44 <Lokathor> the compiler is a lazy butt
00:06:44 <jle`> oh i sent that message too late
00:07:05 <jle`> i typed it up and thought that i should check the latest docs to see if the situation has changed
00:07:14 <cocreature> jle`: it’s even worse in the default implementation in Foldable. there it’s a foldr
00:07:15 <jle`> but then i got beat to the punch
00:07:20 <jle`> i'm never going to care about correctness ever again
00:07:39 <jle`> well default implementation of Foldable i can sort of understand
00:07:56 <cocreature> give me one Foldable instance where that’s the right implementation
00:07:58 <Athas> I should probably add some strictness annotations to my code.  However, I know I have no space leaks.  Are there still potential performance improvements?
00:08:15 <jle`> it's not the right implementation for any specific instance
00:08:22 <wz1000> to be fair, foldr is "more correct" for sum/project for certain data types.
00:08:31 <wz1000> Ones that permit infinity
00:08:31 <cocreature> for types that nobody uses
00:08:47 <jle`> but it is possibly a sensible implementation for the general Foldable
00:08:56 <jle`> with no assumptions on implementation/structure
00:08:58 <Lokathor> Athas, yes there are. If a field is always strict GHC can potentially unbox it which eliminates a pointer indirection. it will do this for small strict fields when optimizations are on
00:09:01 <cocreature> I care more about a version that’s actually usable 99% of the time than one that is unreasonably shitty 99% of the time but also somewhat works in the last 1%
00:09:08 <MarcelineVQ> Athas: not sptrinkled randomly, look into the unpack pragma though
00:09:59 <Lokathor> note that there are potential *drawbacks* too. Too much unpacked data might make updates to a big record more costly than you want
00:10:09 <Lokathor> always benchmark
00:10:22 <Athas> Lokathor: can I get away with just adding Strict and StrictData LANGUAGE pragmas to the most interesting modules?
00:10:32 <jle`> https://github.com/ghc/ghc/blob/master/libraries/base/GHC/List.hs#L248-L259
00:10:34 <jle`> but, why :'(
00:10:55 <jle`> i can kind of guess why
00:10:58 <EvanR> strictness analyzer does the right thing for list product implemented in terms of foldl not-prime
00:11:03 <EvanR> i heard
00:11:09 <jle`> i suspect that the Haskell Report specifies that sum and product must use foldl for lists
00:11:12 <Lokathor> Athas, maybe. Haskell is a strange beast and you absolutely must profile the program to know for sure
00:11:14 <jle`> instead of foldl'
00:11:26 <EvanR> why would that be
00:11:27 <jle`> so if foldl' was used, it'd break from the specification in the Report
00:11:36 <cocreature> we break from the report in all kinds of places
00:11:41 <MarcelineVQ> jle`: ghc doesn't adhere to close to that sort of thing, r.e span and break
00:12:14 <MarcelineVQ> reverse, etc
00:12:16 <jle`> yes ghc doesn't care too much about the report anymore
00:12:25 <jle`> ghc doesn't even adhereto Prelude.sum and Prelude.product
00:12:29 <jle`> lol.
00:12:53 <jle`> but this might be the only tenuous rationale that i can think of for sum = foldl (+) 0 still, in 2017
00:13:16 <jle`> we got Functor as a superclass of Monad before we get sum = foldl' (+) 0
00:13:23 <Athas> I don't expect much speedup from making things strict, as my program is a compiler.  Pointer chasing is the name of the game.
00:13:26 <jle`> #prorities
00:14:28 <Lokathor> i wonder if a vector.unboxed of bool is any speed difference from a vector of bool
00:14:32 <cocreature> I’ve thought several times about trying to fix sum, product, maximum, minimum, … but I’m scared of the endless bikeshedding discussions
00:14:41 <jle`> `product = foldr (*) 0` might be neat cause then we can get short-circuiting products for infinite lists
00:15:24 <cocreature> yeah you can make an argument for foldr although I disagree with that. foldl instead of foldl' is just silly
00:16:01 <cocreature> and if we’re fine with foldl for lists I don’t see why we shouldn’t make that the default implementation in Foldable
00:16:41 <EvanR> Lokathor: sure
00:17:09 <jle`> what about my favorite Foldable instance, newtype FM a = FM { unFM :: forall m. Monoid m => (a -> m) -> m }
00:17:34 <jle`> `getSum . foldMap Sum` is clearly the best implementation for sum, so base gets that right
00:19:26 <Athas> Looks like making my AST strict does not bring much benefit.
00:20:55 <jle`> Athas++ for benchmarking
00:21:21 <Athas> Let's see if randomly adding Strict and StrictData pragmas to the lexer and parser will help!
00:21:27 <Lokathor> cocreature, http://lpaste.net/356997 is this what you meant? because this seems almost orthognal to the lens issue
00:21:43 <MarcelineVQ> Athas: be sure to be checking memory use :>
00:22:06 <cocreature> jle`: hm fair enough. I would still prefer having to overwrite the default implementation for that type instead of having to overwrite it for list, vector, …
00:24:06 <cocreature> Lokathor: if you inline that a bit you have "newPlayer = oldPlayer { creatLocation = shiftDir dir (creatLocation oldPlayer)}" and then you can actually see what lenses allow you to do (which is not a whole lot in that case) namely rewrite that as "newPlayer = over createLocation (shiftDir dir) oldPlayer"
00:24:44 <Lokathor> but we don't want to be using over on player, we want to be using over on game with a composed lens
00:24:44 <cocreature> it’s not entirely orthogonal since using "over" requires that you have some function like "shiftDir"
00:25:08 <Lokathor> i was gonna use get and then set, not modify, i guess
00:25:09 <Lokathor> but okay
00:25:10 <cocreature> well then use over (… . createLocation)
00:25:38 <cocreature> the main reason to use lens is that you get modify
00:25:47 <cocreature> if you just use get and set, you don’t gain that much
00:25:54 <Lokathor> because what really happens is that we need to do a get, then check what's there, and then sometimes we can purely modify, and sometimes we need to run a MonadRandom computation to do the combat 
00:26:41 <cocreature> :t traverseOf
00:26:43 <lambdabot> LensLike f s t a b -> (a -> f b) -> s -> f t
00:26:45 <cocreature> use that
00:26:52 <Lokathor> forward stab
00:27:04 <Lokathor> i have no idea how to use any of that
00:27:10 <cocreature> :t over
00:27:11 <lambdabot> ASetter s t a b -> (a -> b) -> s -> t
00:27:25 <cocreature> traverseOf is over but allows you to perform some kind of effect
00:27:41 <cocreature> (also traverseOf is just "id" but that doesn’t really matter here)
00:28:21 <Lokathor> https://github.com/Lokathor/hexes/blob/master/src/Hexes/Internal/Types.hs#L319 this is, no joke, the only lines of lens code ive ever written down and saved
00:28:22 <Lokathor> so
00:28:29 <Lokathor> you're way over my head right now
00:29:41 <jle`> Lokathor: do you know the difference between 'fmap' and 'traverse'
00:29:59 <Lokathor> i remember there is one
00:30:06 <Lokathor> but really, no
00:30:09 <jle`> or mapM
00:30:44 <jle`> fmap :: (a -> b) -> [a] -> [b]
00:30:52 <jle`> traverse :: (a -> IO b) -> [a] -> IO [b]
00:30:56 <jle`> (for some example instances)
00:31:05 <jle`> traverse is basically fmap but you can do effects
00:31:16 <Lokathor> uh, okay
00:31:44 <jle`> so if i want to process all the items in my list with some mapping function (a -> b), but my function has to do IO or some MonadRandom computation, i can't use fmap
00:31:47 <Lokathor> :t execState
00:31:49 <lambdabot> State s a -> s -> s
00:31:54 <Lokathor> :t runState
00:31:56 <lambdabot> State s a -> s -> (a, s)
00:31:56 <jle`> if i have a (a -> Rand s b), or an (a -> IO b), i can't use fmap
00:32:02 <jle`> or an (a -> State s b)
00:32:08 <jle`> but i can use 'traverse'
00:32:12 <jle`> which is fmap-with-effects
00:32:27 <jle`> traverse :: (a -> Rand g b) -> [a] -> Rand g [b]
00:32:59 <Lokathor> what are you traversing
00:33:03 <ertes-w> helo
00:33:07 <jle`> in this case, the list of a's
00:33:09 <Lokathor> what are the list of a values
00:33:13 <Lokathor> no like
00:33:19 <Lokathor> how does that apply to me
00:33:34 <jle`> ah i'm just illustrating the difference between fmap and traverse
00:33:42 <jle`> so, lens lets you "modify" parts of a value
00:33:43 <jle`> using 'over'
00:33:48 <Lokathor> sure
00:33:51 <jle`> (using a pure functino)
00:33:59 <Lokathor> and sometimes that's what i wnat
00:34:02 <jle`> but it also lets you "traverse" parts of a value, as we,, using traverseOf
00:34:14 <Lokathor> there's no possible traversal
00:34:20 <Lokathor> there's no collection of thingies to visit
00:34:28 <jle`> so you can "modify" a part of your value with an effectful function
00:35:01 <Lokathor> well, it's pure because the effecty part gets run away
00:35:10 <jle`> so lens lets you modify an aspect of a value, like run an (Int -> Int) to modify HP in a character
00:35:25 <jle`> but you can also run an (Int -> IO Int), to have a Character -> IO Character
00:35:34 <jle`> that modifies the character's HP, with potential effects
00:36:08 <Lokathor> so, in this scenario, if there is a creature in the way, the GameState gets broken down into a RandGen and also a Dungeon, and then they get fed into parts of a MonadRandom, and that gets run, giving us the Dungeon and the RandGen back each in their own channel, and then those get mushed back into a GameState
00:36:33 <Lokathor> but there's no "effect" going on back up at the top, it's been unwrapped
00:37:46 <jle`> you could decouple the game state from the RandGen, and have (Dungeon -> Rand g Dungeon) -> GameState -> Rand g GameState
00:38:13 <jle`> that is, given a dungeon-modifying-function that might use Rand effects, apply it to the Dungeon inside your GameState
00:39:18 <jle`> over dungeonLens :: (Dungeon -> Dungeon) -> GameState -> GameState
00:39:21 <Lokathor> well something needs to hold a game universe and also a RandGen together. right now the universe is one dungeon, and they're held in a GameState
00:39:30 <jle`> traverseOf dungeonLens :: (Dungeon -> Rand g Dungeon) -> GameState -> Rand g Dungeon
00:40:05 <jle`> you don't really necessarily need to tie the logic of the game state to the random generator seed
00:40:09 <Lokathor> i really don't see the virtue of invoking the traverse concept
00:40:47 <Lokathor> i *want* to tie the logic of the game world to the RNG it's hooked up to. Then when you store an old GameState you store the RNG with it
00:40:49 <jle`> it lets you modify values in an effectful way, which simplifies a lot of code
00:40:54 <Lokathor> that's specifically a property that i'm pro
00:41:22 <boj> Lokathor: when i wrote my game server i needed to basically map over a lot of State things. mapM/mapM_ let me do it. traverse is just the applicative variation of that
00:41:57 <jle`> if you tie your game state to your rng then your functions become harder to compose in general
00:42:01 <Lokathor> I'm just gonna use some MonadRandom based stuff and do it in a way that is effect free from the outside
00:42:10 <Lokathor> we'll call it the "ST style"
00:43:02 <Lokathor> jle`, i suppose that GameState = World + RNG + UI Settings would be the best way to describe it
00:43:36 <minn> man, after using ocamllex/yacc for so long, alex/happy are really a breath of fresh air
00:44:34 <Athas> minn: I am disturbed at the implication that there is something worse than Alex/Happy.
00:44:42 <Athas> Well, significantly so, anyway.
00:44:58 <Lokathor> always a worse fish
00:45:10 <boj> lex/yacc doesn't fit that bill? :p
00:45:33 <minn> boj is right :D
00:45:51 <Athas> Lex and yacc are only slightly worse, I think.  And mosmlex/mosmlyac (for SML) are slightly better than Alex/Happy.
00:45:59 <Athas> But none of these parser generators are very nice.
00:46:38 <minn> sedlex always looks appealing, but i've never done anything serious with it
00:47:08 <minn> (or sedlex + menhir, i suppose)
00:47:27 <merijn> Lokathor: I would probably decouple UI settings from GameState
00:48:15 <Lokathor> merijn, well it doesn't matter what you call it, UI info goes in the top level data bundle
00:48:29 <ertes-w> Lokathor: as you know, fmap does not *extract* values, it can only ever *modify* them…  can you think of a functor that has a certain effect that would allow you to *extract* a value?
00:48:59 <ertes-w> @let fstL f (x', y) = (\x -> (x, y)) <$> f x'
00:49:00 <lambdabot>  Defined.
00:49:01 <Lokathor> ertes-w, i have no idea what you're on about
00:49:20 <ertes-w> Lokathor: i'm going to give you a rationale why one might want the *traversal* aspect
00:49:27 <Lokathor> uh
00:49:34 <Lokathor> i'm 10 minutes from going to bed pal
00:49:38 <merijn> Lokathor: I would probably take a client+server design. Have one thread dedicated for doing UI/user input, another for GameState (world, rng, etc.) and keep them completely decoupled and communicating via messages
00:49:58 <Lokathor> merijn, what uh... is the benefit of that?
00:50:29 <boj> seperation of concerns
00:50:33 <merijn> Lokathor: Stops you from intertwining UI code and game logic, which simplifies both. Additionally makes it easier to implement alternative frontends for your game
00:50:34 <ertes-w> Lokathor: you go to bed WITHOUT LEARNING SOMETHING VERY IMPORTANT ABOUT STRUCTURAL DESIGN PATTERNS IN PROGRAMMING?
00:50:58 <Lokathor> ertes-w, erryday
00:51:20 <merijn> Lokathor: Start out writing a terminal, opengl, whatever frontend, later decide you want to play it over a webserver? Simply switch out client code to render to a webpage with websockets or some shit and don't have to touch the game logic at all
00:52:05 <Lokathor> right, the game can already do that without needing to introduce multi-thread
00:52:38 <merijn> Also, having a separate thread for UI should improve responsiveness
00:53:00 <ertes-w> uhhhh
00:53:10 <Lokathor> gameUpdate :: Key -> GameState -> GameState -- i don't care where the keys are coming from, and i don't care how the game is shown to the player
00:53:50 <ertes-w> merijn: you can have that separation by following a simpler coroutine-based design
00:53:58 <ertes-w> it's also more efficient and more predictable than a thread-based design
00:54:05 <ertes-w> (and you can still use threads, if you really want to)
00:54:49 <ertes-w> data GuessGame = Running Challenge (Guess -> GuessGame) | Won Result  -- like this
00:54:52 <merijn> ertes-w: I'm not saying it requires threads
00:55:13 <merijn> ertes-w: That won't work with semi-realtime design
00:55:21 <merijn> ertes-w: That blocks waiting for a Guess
00:55:30 <ertes-w> add a Maybe
00:55:59 <ertes-w> and then you have pretty much reinvented AFRP =)
00:57:47 <angerman> let say xs = [True, True, True, False, True, False, False, True, ..., False], and I want to get the offset and longest sequence of True from the list, can someone suggest an elegant approach?
01:02:17 <kadoban> I can suggest *an* approach, I'm not sure it's amazingly elegant, heh.
01:02:19 <kadoban> :t fst . head . maximumBy (comparing length) . filter (snd . head) . groupBy ((==) `on` snd) . zip [0..]
01:02:21 <lambdabot> (Enum c, Num c) => [Bool] -> c
01:03:15 <angerman> kadoban: hehe, yep that doesn't look that elegant :-)
01:05:24 <ertes-w> why not?  i find that quite elegant
01:05:33 <ertes-w> as elegant as it gets with lists
01:05:46 <ertes-w> note:  (==) `on` snd = comparing snd
01:06:13 <kadoban> The maximumBy part is a bit not good, if you ever expect empty inputs, or no True in inputs I guess. But that can be fixed.
01:06:56 <kadoban> Oh, right
01:07:29 <ertes-w> i don't see how to fix that, except by replacing the group/length computation by a single traversal
01:07:37 <ventonegro> :t on
01:07:39 <lambdabot> (b -> b -> c) -> (a -> b) -> a -> a -> c
01:08:00 <angerman> kadoban, ertes-w: thanks, I'll have to think about this a bit.
01:08:17 <ventonegro> :t comparing
01:08:19 <lambdabot> Ord a => (b -> a) -> b -> b -> Ordering
01:08:19 <kadoban> Well, you'd use what maximumByMay or whatever from the safe package I guess, or I guess you could use sorting and then maybeToList
01:09:00 <kadoban> Er, listToMaybe heh
01:15:50 <halogenandtoast> If I have two Either String String and I want to join the Right values with a " " in between is there a good way to do this
01:16:43 <halogenandtoast> I have something like this
01:16:44 <halogenandtoast> > (++) <$> ((++) <$> Right "foo" <*> pure " ") <*> Right "bar"
01:16:46 <lambdabot>  Right "foo bar"
01:18:43 <AndreasK> halogenandtoast: Do you want the resulting string or the result in another Either?
01:19:03 <kadoban> > (\a b -> unwords [a,b]) <$> Right "foo" <*> Right "bar"
01:19:04 <lambdabot>  Right "foo bar"
01:19:07 <kadoban> That maybe?
01:19:17 <halogenandtoast> AndreasK: In an Either
01:19:44 <halogenandtoast> kadoban: that does look better.
01:24:29 <tac-tics> Comments that begin with -- * or -- | are interpreted specially by haddock, right?
01:28:25 <merijn> tac-tics: -- ^ too
01:28:32 <tac-tics> ah, tyty
01:28:34 <tac-tics> this is why I asked :)
01:28:58 <raek> > (\a b -> a ++ " " ++ b) <$> Right "foo" <*> Right "bar"
01:29:00 <lambdabot>  Right "foo bar"
01:29:29 <raek> but I like the unwords one better too
01:29:42 <tac-tics> yeah, that catches another case I didn't think about. thanks again, merijn 
01:54:51 <jonge> is there a very short way to express (f :: whatever -> IO whatever) `f a >> f b >> f c >> f d >> f e`? i though of `mapM f [a, b, c, d, e]`, but that returns a list, and not the last value.
01:55:08 <Citizen_> tholy shit
01:55:20 <Citizen_> Aliens detected
01:56:56 <marvin2> jonge foldr (>>) (return 0) [a, b, c, d]? (untested)
01:57:28 <marvin2> foldr (>>) (return <default value if list is empty>) [a, b, c, d] even
01:57:51 <jonge> marvin2: that code does not use my function `f`
01:58:04 <francesco_> Hello
01:58:13 <francesco_> Is it possible to give to ghc the file to compile from stdin?
01:58:55 <marvin2> jonge replace (>>) with ((>>) . f)
02:00:03 <jonge> marvin2: wow that works. thank you!
02:00:07 <marvin2> np :)
02:06:04 <AndreasK> francesco_: Seems not: https://ghc.haskell.org/trac/ghc/ticket/2427
02:06:11 <francesco_> k, thanks
02:11:13 <Axman6> halogenandtoast: there's also unwords <$> sequence [Right "foo", Right "bar"], which is a little less clumsy to extend if you need another word
02:17:13 <merijn> francesco_, AndreasK: Yes there is, just pass /dev/stdin as the file to compile
02:17:21 <francesco_> ok thanks
02:17:22 <merijn> l33t unix hacks :)
02:17:45 <francesco_> one more thing. Can I prevent ghci to close on EOF?
02:18:48 <srhb> francesco_: What are you actually trying to accomplish?
02:19:15 <francesco_> pass commands to ghci through a named pipe
02:19:22 <francesco_> I'd like to use ghci in my editor
02:19:30 <francesco_> merijn, it doesn't work, it tells me: /dev/stdin.o: openBinaryFile: permission denied (Permission denied)
02:20:07 <merijn> ah...looks like it bases result names on the input name
02:23:30 <cocreature> maybe -outputdir helps
02:23:57 <Axman6> francesco_: are you sure there aren't better supported ways to do this for your editor already?
02:24:53 <francesco_> just trying, actually
02:25:19 <francesco_> but no, I don't think, I searched
02:26:00 <mniip> francesco_, do you have full system function access? or is this shell level stuff
02:26:15 <francesco_> shell level
02:26:28 <mniip> well that sucks
02:27:04 <francesco_> what do you mean full system function access?
02:27:46 <mniip> the best way to do this is to make a pair of anonymous pipes and store them in your program, or better even, open a pty master/slave pair
02:29:10 <francesco_> I can do that, but for the anonymous pipes, isn't it the same thing as a fifo?
02:29:28 <mniip> fifos are ugly
02:29:28 <francesco_> btw, I can create a C program called from the shell stuff :P
02:30:11 <francesco_> well, ok, enough off topic. Thanks a lot for your help
02:30:19 <francesco_> I will try to explore in those directions
02:30:22 <mniip> everything you can do with fifos is better done with anonymous pipes
02:30:35 <mniip> and anything you can't do with pipes is best done with unix sockets instead
02:30:50 <francesco_> :P
02:31:08 <francesco_> mniip, and how would I pass a a pipe or unix socket to ghci?
02:31:29 <mniip> doesn't quite work with unix sockets in this case,
02:31:31 <francesco_> maybe it's better to use System.Process, spawn a ghci process and use the Handles given from there
02:31:39 <mniip> but for a pipe you just dup2 it into stdin/out and exec ghci
02:31:40 <francesco_> to do the job
02:32:15 <mniip> also, you might need some ghci script hacking
02:32:37 <mniip> I'm using ghci from an irc bot, and one thing I do in particular is
02:33:49 <mniip> I give -v0 on ghci commandline and then run a -ghci-script with :set -v1 at the end
02:34:09 <mniip> that avoids the startup message
02:34:38 <mniip> also consider the prompt. Perhaps you might want to set some unique string as the prompt
02:34:53 <francesco_> yeah, I was thinking about "" :P
02:35:06 <francesco_> no maybe it's important, yes
02:35:08 <mniip> what if a command prints two lines of output?
02:35:12 <francesco_> exactly
02:35:21 <francesco_> it signals end of output, for now
02:35:36 <mniip> yeah
02:35:49 <mniip> I had to do something much worse - I had to mod ghci
02:36:06 <mniip> to signal the end of output in a non-filedescriptor-related way
02:36:09 <francesco_> oh
02:37:06 <mniip> which reminds me...
02:37:06 <francesco_> how did you deal with input, instead?
02:37:18 <mniip> I should try to install cabal again, with -M15G
02:37:25 <Flonk> Is the size of ob(Hask) Aleph 0 and also, does DataKinds change anything about that?
02:37:26 <mniip> er, cabal-install*
02:37:54 <mniip> Flonk, TypeFamilies changes a lot about that
02:39:19 <mniip> Flonk, all haskell98 types can be written out as strings (even in presence of type synonyms, as those can't be partial or recursive) hence they are countable
02:39:42 <Flonk> Ah yeah, typefamilies
02:39:50 <Flonk> Yup that's what I thought.
02:40:16 <Flonk> With typefamilies you can diagonalize it up, at the least
02:40:29 <mniip> not sure about that
02:40:39 <mniip> but you can get infinite limit-point types
02:41:01 <mniip> hm
02:41:41 <mniip> tricky
02:41:49 <mniip> francesco_, the same way as with other programs
02:41:54 <mniip> an anonymous pipe
02:42:41 <francesco_> but for anonymous pipes, you have to explicitly send EOF, right?
02:42:58 <mniip> I just send \n
02:43:12 <francesco_> I mean, to close ghci, like when you do Ctrl-D
02:43:20 <mniip> just close the pipe
02:43:20 <francesco_> (Ctrl-d, actually)
02:43:39 <francesco_> for example with named pipes, if I send a command, then ghci executes it and just right after it closes
02:43:45 <francesco_> it quits*
02:43:45 <Flonk> mniip, what's a limit-point type?
02:43:45 <mniip> Ctrl-D is translated by your tty driver into an eof-like thing
02:44:04 <mniip> Flonk, type family F a where F a = [F a]
02:44:09 <mniip> or, even, without a
02:44:58 <mniip> francesco_, pretty sure ghci unbuffers its input, so whenever I write() to the pipe ghci starts working on it immediately
02:44:59 <Flonk> hmm
02:45:10 <francesco_> ok thanks
02:45:15 <francesco_> I will try, thank you very much
02:45:26 <mniip> Flonk, I'm not sure what implications this has
02:45:35 <mniip> because the same you can do with Haskell98 types
02:45:52 <mniip> but it doesn't let us do the same proof because not every type has a finite normal form
02:46:08 <francesco_> what changes when ob(Hask) > Aleph0 ?
02:47:27 <mniip> hm
02:47:31 <Flonk> francesco_, nothing, it's just an interesting question
02:47:36 <Flonk> I'll think about it during lunch break :P
02:47:37 <mniip> why do I get such lags to a server 5 meters away
02:47:56 <francesco_> got it, I hoped in strange uncomputability stuff
02:48:06 <francesco_> like for all other diagonalization proofs
02:48:07 <francesco_> :P
02:49:56 <tdammers> mniip: because physical distance and network distance aren't always related?
02:50:28 <mniip> ok. it's one wifi iface, one router, and one cat5 away
02:59:26 <tdammers> I blame the router
03:03:47 <pacak> I blame wifi
03:04:19 <MarcelineVQ> Recently removed my repeater and replaced with a direct cat5 to the rooms that needed it, unreal connection establishing speed increase
03:08:16 <mniip> I'd blame wifi too
03:08:22 <mniip> lots of interference
03:08:33 <mniip> the router is fiiine
03:35:53 <mniip> uhhuh
03:36:39 <mniip> is it possible to install lens on a ghc 8.3
03:37:48 <srhb> WE have 8.3 already?!
03:37:55 * srhb lives under a rock, clearly
03:38:45 <mniip> if you're unfamiliar with ghc versioning, odd numbers are development versions and even numbers are releases
03:38:50 <pacak> mniip: I suspect it will be exciting.
03:39:45 <mniip> well
03:39:52 <mniip> actually I did it some months ago
03:39:57 <mniip> but something decided to break just now
03:40:21 <pacak> A bunch of requirements, you must satisfy all of them. Plus lens themselves can be tricky.
03:41:32 <mniip> cabal: The following package dependencies were requested
03:41:32 <mniip> --dependency='base=base-4.10.0.0'
03:41:32 <mniip> however the given installed package instance does not exist.
03:41:36 <mniip> wtf
03:44:53 <srhb> mniip: Is master what is considered 8.3 then?
03:45:58 <mniip> kinda
03:46:04 <mniip> I have ghc HEAD over here
03:53:49 <mniip> why would cabal produce that kind of error message
03:53:56 <mniip> it does that for other packages too
03:54:03 <mniip> all of which are installed in the package db
03:59:17 <mniip> aha
03:59:20 <mniip> I think cabal got confused
03:59:34 <mniip> even though I specified --with-ghc it was trying to use something different
04:00:49 <mniip> now we're getting there http://lpaste.net/357001
04:19:11 <mniip> what module reexports Data.Typeable.Internal.typeRepFingerprint
04:19:15 <mniip> in HEAD
04:32:54 <mniip> Data.Typeable?
04:34:48 <mniip> welp
04:35:09 <mniip> this accompanied with cabal taking 2 minutes to warm up is not nice
04:43:10 <mniip>       Expected type: Data.Typeable.TypeRep        Actual type: TypeRep a
04:43:11 <mniip> uhhh
04:46:38 <mniip> aha, Type.Reflection has the same-named function
04:57:01 <ertes-w> i'm pretty sure that with TypeInType ob(Hask) is larger than Aleph0
05:25:51 <Srb> Is anyone here familiar with Cmm?
05:28:50 <Srb> anyone?
05:29:06 <pacak> Srb: A bit.
05:29:12 <Axman6> you may get better responses if you ask your question
05:29:14 <mniip> a nibble
05:29:20 <Srb> Is ptr arithmetic always in 8-bit increments?
05:29:23 <Srb> Or is it typed like C?
05:31:29 <pacak> I guess it's in those bits I haven't touched.
05:33:09 <[exa]> Srb: iirc c-- specification doesn't specify pointed types, so my best guess would be that you always do "raw" arithmetic
05:56:26 <davr0s> do haskells libs have something like the concept of 'identity' eg an identity typeclass to get the identity value for spcific types and operations,
05:56:45 <davr0s> egg 0= indentity for addition, 1=identity for mul, etc etc
05:57:06 <davr0s> could such an idea be expressed in the type system
05:57:21 <dibblego> Monoid
05:58:56 <hi-there> is it okay to ask a somewhat newbie question here, or is there a separate channel for that (like go-nuts)?
05:59:19 <Iceland_jack> hi-there: here is fine, but there is also #haskell-beginners
06:01:00 <hi-there> okay, I'll try there first if you don't mind. is there a better way than do-notation to construct a record where a single field is a result of an impure function, and the rest of the fields are pure?
06:01:07 <Takumo> Iceland_jack: Well thanks, I'm definItely going to join that one!
06:02:03 <pacak> Suppose I have f :: a -> m and g :: b -> m, where m is a monoid, how do I compose them to get c :: a -> b -> m ; c a b = f a <> g b ?
06:02:54 <Srb> pacak: try pointfree.io
06:03:10 <pacak> (in general I want to go from f1 ... fn to a1 -> .. an ->  m)
06:03:27 <pacak> @pl \a b -> f a <> f b
06:03:27 <lambdabot> (. f) . (<>) . f
06:04:11 <hi-there> so I have this: http://lpaste.net/357003
06:04:27 <pacak> Srb: The point is not to get something unreadable, but to find the right abstraction.
06:04:46 <hi-there> is there a way to somehow lift the record constructor to impureContent?
06:04:50 <Srb> Pacak: What's wrong with the explicit form?
06:05:22 <mniip> hi-there, if you make it the last field, you could do
06:05:32 <mniip> MyRecord pure1 pure2 pure3 <$> impure
06:05:53 <Iceland_jack> pacak: How will you use this?
06:05:54 <hi-there> oh, neat
06:06:02 <hi-there> and if it's the very first field, can I flip that?
06:06:02 <mniip> no record notation though
06:06:06 <mniip> uhhhh
06:06:09 <mniip> not in a simple way
06:06:09 <Iceland_jack> Something like Bifoldable may apply, depending on how it gets used eventually
06:06:28 <Iceland_jack> See bifoldMap :: Monoid m => (a -> m) -> (b -> m) -> p a b -> m
06:06:31 <hi-there> oh, okay, still better than what I had
06:06:51 <hi-there> so I suppose I can also do MyRecord pure1 pure2 <$> impure1 <$> impure2
06:06:52 <hi-there> ?
06:07:03 <Iceland_jack> bifoldMap @(,) :: Monoid m => (a -> m) -> (b -> m) -> ((a, b) -> m)
06:07:06 <Srb> the second <$> should be a <*>
06:07:13 <mniip> hi-there, <$> impure1 <*> impure2
06:07:15 <hi-there> ah, I see
06:07:58 <hi-there> mniip: thanks a lot
06:07:58 <mniip> have you seen Applicative before?
06:07:59 <pacak> Iceland_jack: I'm playing around with serialization and deserialization interfaces. deserialization works nicely with applicative notation cons_fn <$> get "field1" <*> get "field2" <*> ... etc. I'm looking for a similar notation to make serializers
06:08:08 <hi-there> yes, a bit
06:08:12 <hi-there> I played with parsec
06:08:24 <hi-there> but I guess my understanding is not general enough
06:08:30 <mniip> well, this is what it does
06:08:31 <hi-there> I didn't see it being used here
06:08:52 <pacak> So I want to get a function a -> b -> c -> m form put "field1" <☭> put "field2" <☭> ...
06:09:01 <mniip> you have MyRecord :: a -> b -> T, and impure1 :: IO a, impure2 :: IO b
06:09:07 <pacak> Not sure what to use in place of <☭>
06:09:12 <mniip> MyRecord <$> impure1 :: IO (b -> T)
06:09:20 <mniip> MyRecord <$> impure1 <*> impure 2 :: IO T
06:09:36 <Iceland_jack> <☭>  ..
06:10:04 <hi-there> huh, okay
06:10:20 <pacak> > let (☭) = (+) in 1 ☭ 2
06:10:22 <lambdabot>  3
06:10:26 <pacak> A perfectly valid haskell identifier :)
06:10:27 <hi-there> and if I have MyRecord :: a -> b -> c -> T, I can do MyRecord <$> impure1 <*> impure2 <*> impure3?
06:10:52 <mniip> yes
06:11:02 <hi-there> nice
06:11:08 <hi-there> thanks once again
06:11:09 <mniip> :t (<*>)
06:11:11 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
06:11:18 <mniip> (and <$> is just fmap)
06:11:54 <hi-there> just to make sure I get it fully
06:12:17 <hi-there> the precedence is (((MyRecord <$> impure1) <*> impure2) <*> impure3)
06:12:18 <hi-there> ?
06:13:04 <mniip> yes
06:13:16 <hi-there> great
06:14:02 <Srb> pacak: If you don't mind new operators, how about replacing (<$>) with an operator which = \f x -> pure (f x), and (<*>) with \mf x -> mf <*> pure x
06:14:06 <Srb> ?
06:15:51 <Srb> but for serialization don't you just want to build your data structure and then serialize the whole thing in one operation?
06:16:20 <pacak> New operators are probably OK.
06:17:44 <pacak> Srb: It's also an option, but I have about 200 different datatypes to serialize. It's easy to make serialization into a typeclass and derive it's instance with generics/TH, just declaring 200 datatypes you don't really need is ugly.
06:20:23 <mpickering> Is there a (new-)cabal command to output the the location of the build products?
06:20:56 <merijn> mpickering: hvr has a wrapper for that, cabal-plan
06:21:08 <merijn> mpickering: https://hackage.haskell.org/package/cabal-plan
06:21:48 <Srb> pacak: On second thoughts, don't you want monoid rather than applicative?
06:22:10 <Srb> unless you need the result for something
06:23:09 <pacak> Srb: Right. I want to make a function that consumes individual fields and smashes them together using monoidal instances.
06:24:35 <Srb> pacak: then you just need a new operator which does \m x -> m <> serialize x, easy-peasy!
06:25:41 <pacak> Hmm... Tomorrow then. Time to go to sleep.
06:25:58 <pacak> Srb: Thanks for your suggestions, I'll see if it fits nicely.
06:27:16 <f-a> hello, I am getting bitten by https://ghc.haskell.org/trac/ghc/ticket/2189 on windows. Is there any workaround? I tried following FFI approach from https://stackoverflow.com/questions/2983974/haskell-read-input-character-from-console-immediately-not-after-newline but (at least via Wine) program just hangs
06:27:24 * hackagebot jose 0.5.0.5 – Javascript Object Signing and Encryption and JSON Web Token library – https://hackage.haskell.org/package/jose
06:47:17 <merijn> f-a: Which console are you using on windows?
06:47:52 <mnoonan> is there a way to do a full-text search of source code on hackage?
06:48:55 <merijn> mnoonan: I don't think so
06:49:06 <merijn> mnoonan: You could just download all of hackage and do it locally, I suppose
06:49:26 <mnoonan> yeah, that might not be too bad
06:50:32 <merijn> mnoonan: Someone did that hard work for you: https://hackage.haskell.org/package/hackage-mirror
06:51:35 <mnoonan> merijn: nice, thanks! (and also thanks johnw, I guess!)
06:51:59 <f-a> merijn: I expect the user to use cmd
06:52:44 <mpickering> mnoonan: https://mail.haskell.org/pipermail/ghc-devs/2015-September/009958.html
06:52:57 <mpickering> That's an easier way
06:54:49 <mnoonan> mpickering, do you have an order-of-magnitude sense of how much data we're talking about? I'm a little worried about something where the two options are "clone it to S3" vs "download it locally"
06:55:12 <mpickering> Maybe 1gb?
06:55:27 <mpickering> I have a clone on my laptop
06:55:35 <mnoonan> oh, awesome!
06:55:42 <mpickering> I just set one going on my office pc now so will let you know?
06:56:15 <mpickering> I think there is one packages which is 400mb but most are really small
07:21:54 <quchen> 400???
07:23:54 <ongy> bad request?
07:31:26 <mnoonan> quchen: it looks like there are some random .git directories in there, so maybe it isn't so surprising
07:31:53 <mnoonan> whoops, he's gone
07:46:00 <Yotam> @pl func g = (\(f, a, b) -> (g f, g a, g b))
07:46:00 <lambdabot> (line 1, column 9):
07:46:00 <lambdabot> unexpected " "
07:46:00 <lambdabot> expecting operator
07:48:40 <ReinH> Yotam: you won't find anything reasonable for that.
07:48:52 <ReinH> What you already have is pretty reasonable.
07:49:02 <ReinH> Well, it could be eta converted
07:49:08 <Yotam> to what?
07:49:29 <ReinH> func g (a,b,c) = (g a, g b, g c)
07:49:49 <Yotam> Well, what I have is more like this:
07:50:57 <Yotam> func g bs = map (\(f, a, b) -> (g f, g a, g b)) bs
07:51:22 <Yotam> bs :: [(a, a, a)]
07:52:39 <ReinH> seems fine, although calling the first element f is odd
08:02:38 <schoppenhauer> hi. the following is my .emacs: https://uxul.de/~schoppenhauer/bla.txt – still, when trying to load a file mit C-c C-f into interaction mode, I get an error that I did not set an interaction mode
08:03:37 <shapr> schoppenhauer: M-x intero-mode
08:03:41 <shapr> if you're using intero
08:03:52 <shapr> then C-c C-l will load your project into intero
08:04:07 <shapr> oh, I don't know anything about nix
08:06:13 <davr0s> what method for 'faking dynamic dispatch classes' is better...   holding a bunch of functions in a record,  or having a function which takes a 'message'  (a single function with a case inside)
08:06:48 <davr0s> e.g. if trying to build something like GUI elements which react to clicks / are renderable etc
08:06:51 <Cale> davr0s: Well, they have different advantages
08:07:38 <Cale> If you expect to extend the number of constructors in the sum often, then you'd much rather have the record of functions
08:08:13 <davr0s> i guess the other approach would have slower dispatch
08:08:42 <Cale> But having the sum type means that everything about the data is available, so new functions can be written on it in an unrestricted manner.
08:09:40 <c_wraith> There are also return values to consider
08:09:46 <Iceland_jack> Yotam: if lens is an option
08:09:46 <Iceland_jack> > over each f (a, b, c) :: (Expr, Expr, Expr)
08:09:48 <lambdabot>  (f a,f b,f c)
08:09:57 <davr0s> yeah i was about to say in the latter case i might end up wrrapping it to make the return values more sane
08:10:27 <davr0s> maybe i'm leaning toward the former.
08:10:31 <schoppenhauer> shapr: nix ist just the distro, it should not be related 
08:10:31 <c_wraith> Really, I wouldn't even think of them as interchangeable
08:10:43 <c_wraith> They do different things.  Each is good at the thing it does.
08:10:44 <schoppenhauer> shapr: M-x intero-mode does not exist
08:10:59 <shapr> schoppenhauer: stack install intero # ?
08:11:07 <schoppenhauer> stack?
08:11:33 <schoppenhauer> shapr: why do I need "intero"? apparently I have some haskell mode installed.
08:11:35 <shapr> schoppenhauer: stack is a wrapper around cabal that can ease installing Haskell cabal packages  (cabbages)
08:11:47 <schoppenhauer> I just want that simple thing that loads stuff into a ghci-repl
08:12:01 <Cale> schoppenhauer: Somehow it's funny to me that someone would be using nix as their desktop OS and not be using it to build their Haskell projects.
08:12:02 <shapr> sadly, I've forgotten how to drive the simple haskell mode.
08:12:16 <schoppenhauer> Cale: what?
08:12:18 <Cale> (I use it for the latter, but couldn't stand the former)
08:12:47 <schoppenhauer> Cale: I could write a nix expression, but first I have to write code, right?
08:13:03 <Cale> schoppenhauer: Well, that's fair.
08:13:17 <schoppenhauer> Cale: I try to do things in nix-shells, but then I have to use multiple .emacs-files.
08:13:19 <Cale> I just mean with respect to stack
08:13:31 <schoppenhauer> Cale: but stack is not nix, is it?
08:13:34 <Cale> right
08:13:42 <Cale> stack is like mini-nix-only-for-haskell
08:13:52 <schoppenhauer> Cale: yes, so I prefer nix packages.
08:14:06 <schoppenhauer> Cale: there is cabal2nix, but I assume that if this intero-thingy is well-known, nox will find it
08:14:49 <Cale> Yeah, I don't know much about intero
08:14:58 <schoppenhauer> Cale: anyway, I do not see how this is related to my problem.
08:15:06 <schoppenhauer> Cale: I mean, I need some interaction mode to write code.
08:15:12 <Cale> Personally, I haven't really bothered much with the Haskell IDE-like stuff
08:15:32 <Cale> I use hasktags to generate tags files for jumping around in code
08:15:49 <schoppenhauer> Cale: actually, I just want to code a few small functions for instructional purpose
08:15:50 <schoppenhauer> s
08:15:50 <c_wraith> My approach has always been "emacs makes for an ok editor, but its interaction with external stuff is awful. just use a terminal window for ghci"
08:15:51 <Cale> and ghcid to recheck compile errors/warnings whenever I save
08:16:03 <Cale> yeah
08:16:14 <dolio> Hah.
08:16:15 <Cale> Just have a separate window for ghci
08:16:17 <schoppenhauer> anyway … I liked the simple haskell interaction mode from a few years agi.
08:16:20 <schoppenhauer> *ago
08:16:25 <schoppenhauer> why has it been so over-engineered?
08:16:31 <dolio> I can't imagine any reason to use emacs except its interaction with external stuff.
08:16:52 <c_wraith> dolio: it has a wealth of customized editing tools that most editors think users are too dumb to provide.
08:16:59 <Cale> dolio: Maybe you just like having your editor take a while to start up
08:17:59 * hackagebot tasty 0.11.2.3 – Modern and extensible testing framework – https://hackage.haskell.org/package/tasty
08:18:10 <davr0s> it seems like 'traditional OOP' could be viewed as 'an optimization for a bunch of lambdas sharing an environment' ... which leads me to ask,  do any functional language engines actually try to spot the scenario, and 'share environment'
08:18:48 <davr0s> (e.g. in the case of faking an OOP class with a record of lambdas who will happen to have a lot of overlapping data)
08:19:40 <schoppenhauer> hm. ok. do I really have to install intero?
08:20:50 <schoppenhauer> I mean, obviously, this thing ignores my configuration for some reason
08:21:19 <kuribas> davr0s: an OOP class just carries a dictionary with the virtual methods.  You can do the same in haskell.
08:22:48 <kuribas> davr0s: data MyType a = MyType (MyDict a) theData ...; data (MyDict a) = MyDict {fun1 :: a -> String; fun2 ....
08:23:04 <dolio> schoppenhauer: I'm kind of confused. You don't want to use intero, but you're trying to for some reason?
08:23:04 <davr0s> oh more like  VCALL(obj,method,args) ===   obj->vtable->method(obj,  args...)
08:23:59 <kuribas> davr0s: also you can use existention quantification to emulate OO.
08:24:46 <dolio> If you liked the thing that existed years ago, I think that still exists. It's called haskell-mode.
08:25:05 <davr0s> what i had in mind was probably more awkward i.e. a 'constructor' making labdas for each 'method', individually refering back to the shared data
08:25:30 <schoppenhauer> dolio: I *am* using haskell-mode. but the interaction mode does not work.
08:25:34 <davr0s> youd have to rebuild that when the data changes, which would suck
08:25:36 <dolio> Oh.
08:25:56 * schoppenhauer installs intero now
08:26:23 <bjobjo> have anyone here tried the "ord"-test in the checkers package?
08:26:32 <kuribas> davr0s: a class is just a function with an implicit "this" variable, and some hidden state.
08:26:59 <bjobjo> I'm struggling to make it work, it keeps failing the anti-symmetry property for my type. It states that it gives up after 0 tests.
08:27:08 <[exa]> davr0s: it's a bit worse than 'bunch of lambdas', each object is stateful
08:27:29 <davr0s> yeah thats where the 'relying on the lambdas to point back' fails
08:27:35 <bjobjo> I'm probably not understanding the (a -> Gen a) parameter to give it, but the docs are a bit sparse on what exactly I'm supposed to generate
08:29:01 <dolio> If your language has mutable state, then a bunch of functions can refer to and modify that state, so I don't see why that'd be a problem.
08:29:38 <davr0s> it's going to be a mess in haskell
08:29:46 <Iceland_jack> bjobjo:  you mean (a) and (Gen a) parameters?
08:30:08 <[exa]> davr0s: abstract the mess behind some useful syntax?
08:30:09 <Iceland_jack> https://hackage.haskell.org/package/checkers-0.4.7/docs/Test-QuickCheck-Instances-Ord.htm
08:30:47 <bjobjo> Iceland_jack: I've looked at those, and I struggle to see how they fit in with ord :(
08:31:08 <bjobjo> ord :: forall a. (Ord a, Show a, Arbitrary a, EqProp a) => (a -> Gen a) -> TestBatch, while greaterThan (for example) gives me a Gen a
08:31:18 <dolio> What's the point of trying to emulate OOP or whatever, though?
08:31:50 <davr0s> i dont doubt it can be given a pleasant wrapper, i think the mess here will come from setting up functions that point to shared state,then if you 'udpate the state' you basically have to rebuild the 'object' (new functions pointing at the new state).    Whereas if you actually set it up more like a 'fake vtable' (functions taking state as an input..) you wouldn't have to do that
08:32:51 <plugin> I'm trying to encode a graph using a GADT with constraints on the constructors but I keep getting an "illegal constraint in type" error when I try to define a type alias using the GADT.  Anyone have any ideas why this might be the case?  gist here: https://gist.github.com/o1lo01ol1o/020b372608183f4ba4e591078a514c7e
08:32:58 <[exa]> davr0s: maybe you should not represent the buttons as data?
08:34:14 <davr0s> something else i'm thinking about (not sure if i'll even bother trying to build it) is a 3d modeller, with various node types .. 'some have selectable vertices, some can be converted to triangle-meshes, etc etc etc'
08:34:36 <davr0s> i suppose something like that could also be done with ADTs all the way
08:34:42 <francesco_> plugin, The x, y, z you don't use. May them be the cause?
08:36:23 <[exa]> davr0s: well if you try to model that like objects, you should use object-oriented language :D
08:36:35 <schoppenhauer> ok, my client crashed. anyway, now I have intero. how do I get an interaction mode here? When running C-c C-l, I get an error message that some argument type was wrong.
08:36:44 <schoppenhauer> and it complains that it cannot find a "stack.yaml"
08:36:48 <davr0s> enum SceneNode = SceneNode  | Spline [ControlPoint] |  Mesh [Vertex] [Triangle] | etc etc etc
08:37:45 <schoppenhauer> omg who wrote this sh*t?
08:38:00 <schoppenhauer> the error message comes repeatedly
08:38:02 <sproingie> schoppenhauer: how did you install intero?
08:38:10 <schoppenhauer> sproingie: I hope so.
08:38:14 <davr0s> [exa] some say that haskell 'can do OOP' ... althoguh i take the point that it might be square peg/round hole.
08:38:20 <schoppenhauer> sproingie: at least it gives me error messages
08:38:31 <sproingie> *how* did you install it?  through melpa?
08:39:04 <sproingie> davr0s: i'm not sure "OOP" necessarily fits into a single box any more than FP does
08:39:06 <schoppenhauer> sproingie: copied the stuff from https://commercialhaskell.github.io/intero/ in my .emacs 
08:39:22 <sproingie> yeah that should do it.  do you have any other haskell modes active?
08:39:23 <davr0s> i think part of the motivation to do such a thing in OOP is really about how sourcecode / interfaces can be distributed (e.g. creating a plugin interface); if you have control of the sourcebase/'distribute as sourcecode' it's not an issue.
08:39:40 <schoppenhauer> sproingie: probably "haskell-mode"
08:39:48 <[exa]> davr0s: what I wanted to say that there are possible better approaches than OOP. I saw GUI stuff modeled as a list of transforms that was applied on the "empty window" by the framework
08:40:45 <davr0s> (by OOP here i mean the switch from 'sort by type' to 'sort by function' .. 'here's an interface every scene node must implement',   vs  'here's a list of all the scene nodes.. now implement every required function for each case..'
08:40:54 <dolio> I don't think being able to write plugins has anything to do with OOP.
08:41:12 <sproingie> well, reifying interfaces is OOP's bread and butter
08:41:13 <schoppenhauer> sproingie: https://uxul.de/~schoppenhauer/bla2.txt this is my .emacs now
08:41:33 <dolio> Reifying interfaces is ML's bread and butter.
08:41:54 <sproingie> sure, considering all those "module functors for dummies" books out there
08:42:05 <schoppenhauer> sproingie (or anyone else): what's wrong with https://uxul.de/~schoppenhauer/bla2.txt now?
08:42:42 <sproingie> then there's the mainstream appeal... technical superiority were the only dominating factor, the world would look a lot different
08:43:23 <Yotam> davr0s: If you want to model meshes why not treat them as graphs
08:43:25 <lambdamu> schoppenhauer: My crystal ball isn't working today
08:43:36 <sproingie> schoppenhauer: looks all right to me.  you shouldn't need most of the package rigamarole they tell you to add, but it shouldn't hurt either
08:44:04 <schoppenhauer>  https://uxul.de/~schoppenhauer/bla3.txt  is the error message. I don't even have a "stack.yaml" file anywhere, at least I did not actively write one
08:44:04 <sproingie> best i can think of is try nuking and reinstalling haskell-mode and intero
08:44:42 <sproingie> though it doesn't look like an install problem, looks like an actual bug of some sort
08:44:52 <sproingie> oh, do you have stack installed?
08:45:05 <sproingie> intero needs stack, it won't install that
08:45:37 <Benzi-Junior> what is the asymptotic runtime of "read" ?
08:45:38 <schoppenhauer> sproingie: stack is installed
08:45:45 <schoppenhauer> sproingie: where is stack.yaml?
08:46:17 <sproingie> should be in your project root.  intero should still work without it.  that should just be an invisible warning.
08:46:24 <schoppenhauer> sproingie: what is a project root?
08:46:51 <schoppenhauer> it is not an invisible warning. and I cannot load the file into ghci.
08:46:59 <schoppenhauer> C-c C-l should do that, shouldn't it?
08:46:59 <sproingie> the dir that contains your foo.cabal file and stack.yaml.  it's what you get from "stack new"
08:47:11 <lambdamu> schoppenhauer: https://docs.haskellstack.org/en/stable/README/
08:47:12 <schoppenhauer> I never ran "stack new"
08:47:17 <sproingie> you don't have to
08:47:35 <sproingie> though ... if you have a brand new stack install, you probably *do* have to run "stack setup"
08:47:35 <schoppenhauer> I don't have a large project, just a small file
08:47:48 <kzhang> How to tell Cabal to statically link certain C libraries but not all?
08:48:06 <glguy> If intero gives you too much trouble there's always https://github.com/jyp/dante
08:48:20 <sproingie> yeah intero should be fine with it.  no idea why you're getting that bug, might have to follow their advice and report it as a bug
08:49:02 <lambdamu> schoppenhauer: stat ~/.stack/global-project/stack.yaml
08:49:13 <sproingie> dante looks pretty neat, but no hoogle or eldoc and you get to set up flycheck by hand
08:49:32 <glguy> you don't set up flycheck by hand, it works out of the box, you just have to decide whether or not to turn it on
08:49:48 <Yotam> Does anyone know a library to solve a system of nonlinear inequalities?
08:49:50 <sproingie> oh at least it does have flycheck presets.  i may have to take another look.
08:50:30 <sproingie> dante might be better if you're not inclined toward stack
08:51:18 <glguy> dante can use stack and new-repl and normal ghci
08:59:01 <chewzerita> @lpaste
08:59:02 <lambdabot> Haskell pastebin: http://lpaste.net/
09:02:14 <AWizzArd> 1euiaeuiaeuieaoaeoiaoeiaeoiao
09:04:37 <sproingie> nice, dante's looking smooth.  its install instructions need work tho
09:05:22 <sproingie> use-package is some non-standard thing
09:07:31 <glguy> use-package is used extensively in spacemacs and is maintained by the maintainer of emacs
09:09:55 <sproingie> easy fix.  install instructions should reflect that though.
09:10:09 <sproingie> i should look into spacemacs sometime, the layers stuff looks like a nice approach.
09:10:11 <ReinH> use-package is about as standard as a package can get.
09:10:23 <sproingie> if you consider spacemacs to be the standard
09:10:27 <ReinH> No.
09:10:39 <ReinH> That's not what I said.
09:11:03 <ReinH> It's heavily used and, as glguy said, maintained by johnw.
09:11:04 <sproingie> it's not part of 25.1.1 vanilla
09:11:08 <ReinH> Yes.
09:11:10 <ReinH> Can you not read?
09:11:13 <sproingie> fuck off
09:11:22 <ReinH> "ReinH> use-package is about as standard as a package can get."
09:11:26 <ReinH> *as a package can get*
09:12:06 <ReinH> lol
09:12:46 <sproingie> sorry.  i was in a really bad place for a moment
09:12:49 <sproingie> should not have taken it out here
09:12:53 <ReinH> Thanks.
09:13:03 <ReinH> Anyway, I specifically said "as a package can get"
09:13:31 <sproingie> i suspect it's already in emacs head.  or hope, anyway.
09:18:27 <sproingie> so is spacemacs entirely a monster config over vanilla emacs, or does it use a custom emacs build too?
09:19:34 <sproingie> nvm, found the github, looks like it's elisp.  nice.
09:19:55 <ReinH> Yeah, it's just a giant config. Works with any (?) emacs version.
09:20:07 <ReinH> Well, I guess not old versions.
09:21:55 <sproingie> i was using my own emacs build for a while, but didn't do anything that interesting with it so i reverted to vanilla.
09:23:18 <sproingie> wanted to see if a webkit toolkit was feasible.  should be, for someone with way more patience than myself
09:39:29 <fvh> hey guys, why people use underscores in ADTs I understand when you want to use "_" for some field if you're not using it, but why for every field? Maybe this related to some derivations?
09:39:48 <kadoban> fvh: I think that's a lens thing
09:40:47 <glguy> fvh: That's a naming convention. There will typically then be lenses defined with the same names with the leading underscore dropped
09:41:30 <fvh> well library I'm looking at don't have lenses as deps, so it's like preparation for integration?
09:41:44 <jle`> fvh: if identifiers start with _, ghc doesn't warn you if you don't use them
09:41:58 <jle`> but that doesn't mean you can use _ for a field name
09:42:02 <jle`> i'm not sure waht you mean exactly
09:42:03 <fvh> I know that, and I use it that way myself
09:42:18 <jle`> are they using "_" as the name for every field?
09:42:35 <jle`> i don't think that's a valid field name
09:42:36 <fvh> but I see ADT where every field starting with "_" but they are used all over the library
09:42:56 <jle`> ah, they're using "_" at the start of the field name?
09:43:07 <fvh> ADT { _ myField1:: Type, _myField2:Type }
09:43:23 <jle`> do they ever define anything called myField1 and myField2?
09:44:10 <jle`> also other packages export lenses besides the 'lens' package
09:45:11 <jle`> if they have something called myField1 and myField2, then they probably are using the underscore to prevent a name collision
09:46:13 <fvh> yes, seems like it, but I can't understand why just give another name, it clashes with common convention as "_" is for unused fields
09:46:30 <lyxia> fvh: is there really a space after _
09:46:36 <fvh> no, typo
09:46:55 <fvh> so it's either just naming convention or preparation for lens integration
09:56:57 <ReinH> Actually, lens could already be integrated. You can write optics without a lens dependency.
09:56:59 <ReinH> Oh, they left.
10:06:44 <sproingie> if i ran the zoo, i'd make "foo.bar" use a lens and "foo . bar" be composition.  or maybe just use chevrons for composing, i dunno.
10:07:02 <sproingie> yay for whitespace-sensitivity.  see negative literals.
10:07:31 <sproingie> come to think doesn't purescript do something like this, or have i been smoking the discount crack again?
10:08:13 <paf31> purescript uses <<< and >>> for composition, and dot is used for record accessors
10:08:25 <sproingie> ah, not crazy whitespace tricks then
10:08:32 <paf31> no :)
10:09:46 <sproingie> i like syntax that rolls off the fingers nicely.  i don't even like using -> in perl or c++
10:10:15 <sproingie> achy tendons really hate leaning on the shift key
10:11:37 * hackagebot threepenny-editors 0.4.0 – Composable algebraic editors – https://hackage.haskell.org/package/threepenny-editors
10:17:53 * hackagebot threepenny-editors 0.4.1 – Composable algebraic editors – https://hackage.haskell.org/package/threepenny-editors
10:20:32 <ReinH> I wish we could all just type • easily.
10:21:01 <ReinH> It's actually quite easy on macos: alt-8
10:21:16 <ReinH> Or with agda or latex input mode in emacs
10:21:22 <ReinH> I love agda input mode.
10:23:06 <sproingie> input modes are nice ... when you have an editor supporting them
10:23:42 <sproingie> global input modes are better ... when they're actually global.  alt-8 in irssi?  why no sir.
10:24:09 <ReinH> Or in emacs, most likely.
10:24:22 <sproingie> it's 2017 and we still type like it's the 50's
10:24:28 <ReinH> Yeah.
10:25:06 <sproingie> everything that tries to solve the problem ... works for that one app
10:26:00 <sproingie> ah well.  i've other things to be confused and frustrated over now that are even older unsolved problems.  c'est la vie.
10:26:34 <mniip> sproingie, but xkb solved the problem
10:26:45 <mniip> you can define layouts however the hell you want and they will work everywhere
10:26:53 <mniip> no one's just using it
10:27:01 <sproingie> i don't even use X
10:27:49 <sproingie> bettertouchtool and karabiner on the mac were a good solution, but sierra crippled karabiner and it never recovered.
10:28:31 <sproingie> anyway first world problems
10:33:45 <Tuplanolla> If only XKB wasn't impossible to understand, mniip.
10:33:59 <mniip> I've written an APL layout in xkb once
10:34:23 <mniip> ○∆⍝ ⍳~⍕⌈ ∊∪∊⊤ ○⊤ ~∆⍳⌈ ⎕⍺*~○*⌶
10:34:44 <Tuplanolla> I spent several days remapping two keys and it doesn't even work reliably.
10:39:11 <portnov> @pl \f g z -> foldr f z . map g
10:39:12 <lambdabot> (. map) . flip . ((.) .) . foldr
10:39:28 <portnov> @pl \f g z -> foldr g z . map f
10:39:28 <lambdabot> flip (flip . ((.) .) . foldr) . map
10:39:30 <ReinH> portnov: foldr f . map g = foldr f . g
10:39:36 <ReinH> This equation might be helpful to you.
10:39:44 <portnov> hm
10:39:46 <portnov> thx
10:39:50 <ReinH> er, foldr f z . map g = foldr (f . g) z
10:59:15 <NemesisD> is it possible to do something like this: class FooFamily v where type MonadFoo v :: (* -> *) -> * -> *; inMonadFoo :: (FooFamily v, MonadFoo v m) => proxy v -> m ()
10:59:57 <slack1256> I will repeat a question because I don't know if it reached the channel (I got disconnected afterwards)
10:59:59 <NemesisD> in other words, create an associated type alias to a typeclass within a class
11:00:07 <slack1256> Is there any tree definition (AVL, 2-3 tree, black red, etc) that when implemented on a pure lang, get an extra O(log) which the imperative version doesn't?
11:04:05 <glguy> NemesisD: With the ConstraintKinds extension you can have the associated type: type MonadFoo v :: (* -> *) -> Constraint
11:04:25 <NemesisD> glguy: when did ConstraintKinds land in GHC?
11:04:32 <glguy> Check the users guide
11:04:50 <kadoban> slack1256: Probably not. I don't know of any, and I'm not sure how that'd work, since those family of trees are asymptotically optimal for what they do and the operations they're allowed. You can't have O(1) comparisons to insert/delete for instance and still allow the same operations.
11:05:31 <kadoban> I'm sure you could make a tree that would have Θ((lg n)^2) bounds on stuff I guess, but it'd probably be artificial, I don't know what it would do for you.
11:07:06 <NemesisD> looks like 7.8.4, fair deal
11:18:06 <jared-w> mniip: I would be super interested in seeing that APL keyboard layout and. I really want to figure out how to reproduce a useful set of overlay keyboard bindings (eg hitting right alt to get a new 'keyboard layout') or somehow seeing if I can get something similar/identical to the osx keyboard layout with its alt magic
11:18:32 <mniip> this one is a separate layout though
11:18:45 <geekosaur> you could look at the way neo is defined <gd&r>
11:18:46 <mniip> if needed I can merge it with en_US with alt
11:18:56 <slack1256> kadoban: yeah, but I was thinking that if some operation (lets say insert) relied on some pointer aritmethic or side effect to archive good asymptotic (in the classical definition of the algorithm), then when trasnlated to a pure lang, we would pay a extra O(log) factor
11:18:57 <Athas> What was the typeclass you needed to embed a Haskell value in a Template Haskell result?
11:19:03 <geekosaur> Lift?
11:19:10 <geekosaur> which should be auto-derived these days
11:19:13 <jared-w> mniip: how do you switch your layouts then?
11:19:20 <slack1256> that kind of happens with graphs for the cycles
11:19:23 <jared-w> I still find xkb incomprehensible for the most part :p
11:19:29 <mniip> well, I have a dual layout keyboard anyway
11:19:32 <n_blownapart> https://ptpb.pw/Rmoi hello how do I use trace in this program to follow output of the currying going on? (I believe this is a good example of currying but I'm not sure)
11:19:40 <mniip> for apl, I just do a command in console
11:19:58 <geekosaur> that was why the duck-and-run :p neo is a very complex layout and nearly incomprehensible.
11:20:01 <Athas> Ah, yes, Lift, thanks geekosaur.
11:20:48 <kadoban> slack1256: Which might make sense, except it's not true in any of those, and it's unclear why you'd use a different one that had that property.
11:21:10 <slack1256> I wouldn't use it
11:21:28 <slack1256> I wanted to know if such tree definition existed though
11:25:57 <jared-w> gotcha. That makes sense
11:31:13 <n_blownapart> https://ptpb.pw/Rmoi I can generally see what's happening but I'd like to use trace in the right places to follow the output. I know how on drRacket
11:33:10 <kadoban> n_blownapart: Not really sure which part you're having trouble with. What'd you try? If I want to see what's getting called in what order, I usually add a first guard with | traceShow (stuff) False = undefined   if that helps
11:34:07 <Fuuzetsu> in this case adding ‘factors n | traceShow n False = undefined’ right under type signature
11:35:21 <n_blownapart> kadoban, Fuuzetsu hold on thanks sorting it out
11:40:24 <n_blownapart> Fuuzetsu, sorry, the output for your first suggestion on #beginners outputs numbers much larger than n. how can that be?
11:41:52 <n_blownapart> I did this : https://ptpb.pw/0w9h  ^^
11:46:03 <Fuuzetsu> n_blownapart: does it? works for me: http://lpaste.net/357008
11:47:34 <jared-w> ughhhhh, arch broke with haskell yet again. Now I gotta fix the nopie issue -_-
11:50:37 <n_blownapart> Fuuzetsu, thanks !
11:53:15 <mniip> jared-w, sounds like debian already ships with one fairly similar (and superior) to mine
11:53:16 <mniip> https://packages.debian.org/stretch/all/xkb-data/filelist
11:53:40 <mniip> /usr/share/X11/xkb/symbols/apl
11:54:26 <KENNYNR1[m]> sup hask
11:54:32 <Fuuzetsu> greetings
11:54:40 <jared-w> neat
11:54:48 <Tuplanolla> @hackage subhask
11:54:48 <lambdabot> http://hackage.haskell.org/package/subhask
11:55:51 <Unicorn_Princess> so DuplicateRecordFields is really neat, but there's still the problem of record names matching regular function names, e.g. data Interval = Interval {min :: Float, max :: Float} - how to get around this problem? best I can think of is mangle the record names a bit, like with some prefix. any conventions around this already in place?
11:56:25 <Fuuzetsu> prefixing record fields with common prefix for the type is a frequent practice
11:56:32 <jared-w> The only convention I really know of is "don't name them the same thing" :p
11:56:56 <Unicorn_Princess> (I really miss dedicated record access syntax, i.e. C's .)
11:57:01 <Fuuzetsu> ‘interval_min’ or whatever it is you want; alternatives are defining that stuff in separate module and importing qualified
11:58:25 <Unicorn_Princess> it gets hairy once you have records named radius, and then you have to name your variables radius', or vice-versa :/
11:59:02 <Unicorn_Princess> sure there aren't any projects around with an existing convention on record names, e.g. prepending _ or appending ' to them?
11:59:11 <Unicorn_Princess> before I go for my own
11:59:31 <Fuuzetsu> my "convention" is ‘_somethingrelatedtotype_recordfield’
11:59:47 <Fuuzetsu> it serves the second purpose of getting rid of unused field warnings
11:59:49 <sproingie> Unicorn_Princess: if you're not using the global function, consider hiding it when you import it
11:59:55 <Tuplanolla> I would've chosen `_ivalMax` there, Unicorn_Princess.
11:59:57 <sproingie> you can also rename it
12:00:24 <sproingie> i really hate prefixing field names, it defeats the purpose imho
12:00:36 <Fuuzetsu> _ival_max is nicer as it's easier to drop the prefix and get "original" intent; useful when deriving Aeson instances for example, you don't have to downcase the Max.
12:01:49 <n_blownapart> Fuuzetsu, man that's more than I bargained for
12:02:12 <Fuuzetsu> n_blownapart: what's the matter?
12:02:27 <Unicorn_Princess> how common is ' or _ in library names?
12:02:39 <Unicorn_Princess> as the 1st or last character, specifically
12:03:10 <sproingie> in a library name as the first char?  i'd say unheard of.
12:03:13 <n_blownapart> no it works thanks, just trying to follow it Fuuzetsu 
12:03:24 <geekosaur> ' can't be used as a first character
12:03:44 <Unicorn_Princess> sproingie: no no, I mean in the names of functions / stuff defined by the library
12:03:47 <geekosaur> conflicts with: Char literals, Template Haskell quotes, lifted types
12:03:56 <mizu_no_oto> Unicorn_Princess: _ should be reasonably common, since Lens will autogenerate lenses for fields prepended with _ - see https://hackage.haskell.org/package/lens-4.15.3/docs/Control-Lens-TH.html
12:04:34 <sproingie> well the leading ' is reserved syntax, and leading _ implies it's private, so i'd say you won't run into those
12:04:43 <mizu_no_oto> Of course, you're intended to use the autogenerated lenses there, rather than the _ prepended fields.
12:05:15 <sproingie> i like the trend of using an Internals module for "private" stuff, but some stuff still goes by naming conventions
12:06:32 <Unicorn_Princess> I am unfamiliar with Lens, but what I'm getting from this is that it's common to prefix record names with _?
12:06:52 <sproingie> yah then there's the Lens convention.  *shrug*
12:07:14 <Fuuzetsu> just go with whatever is convenient for you unless you're targetting a big audience in which case people will yell anyway
12:08:24 <sproingie> seeing what others do, especially the prolific authors, is helpful
12:10:35 <mizu_no_oto> Unicorn_Princess: lenses are basically composable getters, setters and modifiers for immutable data.  Lens is probably the most widely used lens library in Haskell.
12:11:03 <Unicorn_Princess> I'll read up on Lens. but first, should I also read up on https://nikita-volkov.github.io/record/ ?
12:14:40 <mizu_no_oto> > set (_2 . _1 . _1) "Hello" (1,((2, 3), 4))
12:14:42 <lambdabot>  (1,(("Hello",3),4))
12:14:59 <mizu_no_oto> > view (_2 . _1) ("hello",("world","!")
12:15:01 <lambdabot>  <hint>:1:38: error:
12:15:01 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
12:15:09 <mizu_no_oto> > view (_2 . _1) ("hello",("world","!"))
12:15:11 <lambdabot>  "world"
12:15:32 <sproingie> record and vinyl might be worth a look.  both seem thinly maintained.
12:15:36 <Unicorn_Princess> > set (_0) "goodbye" (2,3)
12:15:38 <lambdabot>  error:
12:15:38 <lambdabot>      • Found hole: _0 :: ASetter (Integer, Integer) t a0 [Char]
12:15:38 <lambdabot>        Where: ‘t’ is a rigid type variable bound by
12:15:46 <Unicorn_Princess> > set (_1) "goodbye" (2,3)
12:15:48 <lambdabot>  ("goodbye",3)
12:15:51 <Unicorn_Princess> I see
12:16:07 <Unicorn_Princess> 'thinly' maintained?
12:16:11 <sproingie> not that thinly though, they both have 2016 updates.  bit of "if it works, it doesn't need it" factor
12:16:27 <sproingie> they both have incomprehensible error messages
12:16:46 <mizu_no_oto> Unicorn_Princess: It looks like record has 2602 total downloads (44 in the last 30 days), and lens has 164642 total downloads (6015 in the last 30 days)
12:17:22 <Unicorn_Princess> sproingie: well if I can deal with C++'s boost...
12:17:36 <sproingie> well yeah if you can decipher template errors
12:18:18 <sproingie> tho modern c++ libs usually have nice compile errors owing to stuff like static_assert
12:19:03 <mizu_no_oto> So there's about 2 orders of magnitude more use of lens than record.  Popularity doesn't necessarily mean if something's good, but it at least shows that the community hasn't fallen behind record as being obviously better.
12:19:10 <Unicorn_Princess> haha no I can't. at least for some libs I dealt with, no-one can. I'd first have to increase the history of my console. I just look up the line that caused the error, then squint at it till I figure out what was wrong :)
12:19:25 <sproingie> that's pretty much my process too ;p
12:19:51 <sproingie> sometimes i'll try breaking it even further with something i know is obviously wrong and see how the errors correspond
12:19:57 <Unicorn_Princess> that record fella says something about records working -with- lenses? I don't even know if one is supposed to replace the other, or offer similar functionality
12:20:37 <sproingie> there's overlap, neither is a complete replacement for the other
12:22:09 <sproingie> lens aims at accessors, other packages give more treatment to use cases like record construction
12:23:11 <mizu_no_oto> Lens also allows you to solve the second two problems that Volkov notes
12:24:01 <Unicorn_Princess> so it solves all 4?
12:24:02 <mizu_no_oto> Though you can't define the records themselves in the same file
12:24:16 <sproingie> "solves" is putting it strongly.  i'd say addresses.
12:27:52 <mizu_no_oto> If you want to use the same accessors for multiple data types, you can use typeclasses in conjunctions with lenses.  Basically, you have something like 'class HasFoo t where foo :: Lens' t Foo', and Lens has template Haskell to autogenerate 'instance HasFoo Bar where ...' and 'instance HasFoo Baz where ...'
12:28:45 <mizu_no_oto> It's kinda heavyweight, but record seems to be pretty heavyweight as well.  It's not really something I've had to do, myself.
12:52:04 <jared-w> I wouldn't say it's "heavyweight" so much as "extraordinarily general"; it's not like lenses and prisms are /only/ for getting and setting records
12:54:44 <jared-w> You can write lenses to access individual bands of a fourier-transformed signal, you can compose traversables together, you can use them in GUIs, synchronizing updating data structures... 
13:07:24 <n_blownapart> Fuuzetsu, hi if you're still on, can you look at this? the output from the trace is all scrambled. http://lpaste.net/357015 what would cause that?
13:08:35 <geekosaur> laziness? stuff is forced as needed, not necessarily in the order you would do it
13:09:20 <Fuuzetsu> I suspect GHCi buffering rather than laziness
13:11:14 <Fuuzetsu> http://lpaste.net/357016 call hSetBuffering before main and it goes away
13:11:44 <Fuuzetsu> GHCi is not very good to run this in anyway because it it will just memoize the result and you'll only get trace output once
13:13:43 <n_blownapart> Fuuzetsu, only get trace output once? that is what seemed to happen. the output was identical to your paste, then on 2nd try I got this. what is a better way to run that?
13:14:26 <Fuuzetsu> ghc yourmodule.hs -o Main && ./Main
13:14:39 <Fuuzetsu> that way you at least don't have any weird interactions with GHCi and you only have your shell to worry about
13:15:48 <n_blownapart> Fuuzetsu, ok, thing is geekosaur was suggesting I use ghc the other day, but I'm running stack without a system haskell, so I don't think I can use that command
13:16:06 <geekosaur> stack exec ghc -- ...
13:16:10 <Fuuzetsu> stack exec -- ghc …
13:16:19 <kadoban> n_blownapart: stack ghc   or you can use stack's script interpreter thing
13:16:46 <n_blownapart> thanks ALL ! I was missing the exec part
13:17:14 <kadoban> Well, you don't quite need the exec part, though that will work. 'stack ghc' is a command that exists too.
13:17:33 <n_blownapart> hmm, I thought I tried that. working...
13:23:29 <n_blownapart> kadoban, Fuuzetsu geekosaur   very sorry, but can I run that properly without getting those stack aux files?
13:23:56 <Fuuzetsu> I don't know what you mean.
13:24:59 <n_blownapart> I'm trying to keep it simple and not get file.o file.hi and whatever that compiled file thing is.
13:25:20 <kadoban> n_blownapart: Using the script interpreter thing from stack would be the easiest way to go, it's quite nice.
13:25:38 <Fuuzetsu> that's just files GHC produces; uh, you could try ‘stack exec -- runhaskell yourprogram.hs’
13:26:05 <kadoban> Isn't runhaskell pretty much like using ghci in most ways? What was compiling the thing originally supposed to achieve? I missed that part.
13:26:33 <Fuuzetsu> not dealing with GHCi buffering output and memoizing results
13:26:36 <kadoban> p.s. there's also 'stack runghc'
13:27:17 <n_blownapart> what is the script interpreter command kadoban ?
13:28:01 <kadoban> n_blownapart: https://docs.haskellstack.org/en/stable/GUIDE/#script-interpreter this stuff
13:28:37 <n_blownapart> kadoban with stack runghc I get the same weird output from using trace.. working on it
13:34:19 <Fuuzetsu> n_blownapart: trace is just a quick debugging tool, it's not intended for any sort of presentable output and you have to be careful with it (or you get interleaving/it doesn't show up/whatever); originally I thought you just wanted to debug your code quickly but are you actually trying to use it for some sort of consistent output?
13:35:49 <kadoban> A good point.
13:39:36 <n_blownapart> Fuuzetsu, kadoban thanks so much. I am using trace as a learning tool, to follow the output so I can see how the currying is going on. 
13:40:16 <n_blownapart> In Scheme it was helpful to use trace. In haskell it's tougher to use to create easily followable output
13:40:28 <EvanR> theres also ghc-vis
13:40:44 <EvanR> which can give you heap objects after or before they get lazily evaluated
13:41:23 <Fuuzetsu> scheme is inpure, trace in haskell is nothing more than a hack
13:41:33 <Fuuzetsu> impure*
13:41:49 <EvanR> impure is not a hack in other systems?
13:42:02 <n_blownapart> EvanR would you mind giving an example of that?
13:42:05 <Fuuzetsu> not in the same context
13:42:10 <n_blownapart> Fuuzetsu, hmm that is over my head
13:42:16 <n_blownapart> I'm not a programmer
13:43:09 <Fuuzetsu> n_blownapart: the difference is in scheme you say "ok print this please!"; in Haskell you're doing "hey compiler this is pure but actually I'm lying, do a side effect when you're here and just dump it out to console without regard to anything else"; easiest way I can explain it…
13:43:25 <EvanR> n_blownapart: well the page does have a lot of examples http://felsin9.de/nnis/ghc-vis/
13:43:27 <Fuuzetsu> so if you want the scheme way, you ought to do it "properly" in your code
13:43:54 <EvanR> trace used for debugging or for poking around is not bad
13:43:55 <sproingie> it's a hack because the system wasn't designed to do it.  it just happens that it can.
13:44:13 <EvanR> im not sure how you would do either of those things "properly"
13:44:26 <sproingie> Writer i imagine
13:44:43 <Fuuzetsu> precisely, it's for poking around but at the point where I hear "oh but it doesn't come out nicely and does weird things" your usecase doesn't sound like poking around anymore
13:44:46 <EvanR> rewrite your code to use Writer for debugging or poking around?
13:45:03 <sproingie> to do it "properly" yeah.  improper sometimes is a win.
13:45:03 <Fuuzetsu> just write your code in IO is the simplest way
13:45:08 <Fuuzetsu> Writer is broken garbage
13:45:11 <EvanR> that doesnt make any sense
13:45:46 <EvanR> especially for debugging
13:45:46 <Fuuzetsu> why not? it composes same way as writer would
13:45:59 <Fuuzetsu> yes, for debugging trace is OK; I'm saying the use-case here sounds beyond debugging
13:46:02 <sproingie> maybe not Writer, but whatever.  properly, types should reflect intent
13:46:32 <EvanR> sproingie: the point of debugging is to fix the existing code. once you need to rewrite, you cant be debugging anymore
13:46:41 <EvanR> youre rewriting
13:47:18 <EvanR> i guess logging is a situation where debugging could be the intent
13:47:18 <Fuuzetsu> and once you start using tracing for nice output, you're also no longer debugging…
13:47:29 <sproingie> lots of debugging involves temporary rewrites
13:47:41 <sproingie> in fact all debugging ends with at least one thing changed
13:47:46 <EvanR> i highly disagree with the idea of temporarily rewriting code to be monadic
13:48:00 <EvanR> (usually takes a lot of rewriting)
13:48:12 <sproingie> well it helps if it was monadic in the first place.  if not, then, well, other things
13:48:31 <sproingie> but debugging doesn't really have to be "proper" anyway
13:48:31 <EvanR> you somehow skipped the then and went straight to the else
13:48:40 <Fuuzetsu> if you want logging/proper debugging you have to design your code to support that
13:48:47 <Fuuzetsu> in Haskell world this basically means monadic
13:48:47 <sproingie> properly we're not made to be cut open.  in reality, surgeons exist.
13:49:42 <EvanR> i highly disagree with a hair shirt interpretation of haskell, where all effects must be terrible monad stacks
13:49:47 <sproingie> if you want proper *logging* then that's something that should be designed in.  trace for debugging, whatever, it's a scalpel.  hopefully you don't introduce complications.
13:49:51 <EvanR> no matter what
13:50:09 <sproingie> such design doesn't have to be a Monad Stack Of Doom, which i also dislike intensely.
13:50:17 <shirt> EvanR: eh?
13:50:17 <EvanR> for instance, things that are provably pure but not by the type system. you need unsafePerformIO
13:50:20 <sproingie> (hell it chased me away from haskell for years)
13:51:18 <Fuuzetsu> so what's your solution EvanR? We want purity, no "terrible monad stacks" but we also want logging/debugging…
13:52:18 * hackagebot csound-catalog 0.7.1, csound-expression 5.2.2, csound-expression-dynamic 0.3.2, csound-expression-typed 0.2.0.2, … and 1 more
13:52:18 * hackagebot  → https://hackage.haskell.org/packages/recent
13:52:23 <n_blownapart> sproingie, Fuuzetsu EvanR holy smokes I opened a can of worms
13:52:33 <sproingie> welcome to the internet ;)
13:53:02 <n_blownapart> no I learned a lot reading that!
13:53:04 <Fuuzetsu> not really, I'm just interested in what alternative could be proposed here that's not actually a monad stack in disguise
13:53:31 <n_blownapart> well the ghc-vis sounds good haven't looked at it yet
13:53:42 <sproingie> there's Eff and such which i'm still learning.  goes from vertical monad stacks to a sort of indexed effect soup
13:54:36 <Fuuzetsu> Eff is basically monad stacks with reordering and better compose, it's not exactly a vibrantly different solution as cool as it is
13:54:59 <sproingie> right, my point is that it's a pretty decent disguise
13:55:30 <Fuuzetsu> I never used it; when I read the paper about it again recently co-worker mentioned why it was not very good but I forgot the reason
13:55:39 <Fuuzetsu> let me search Slack, maybe I can find it in first 5 seconds..
13:55:39 <sproingie> performance is apparently not the best
13:55:53 <sproingie> but it also hasn't been tuned to the degree mtl has
13:55:56 <Fuuzetsu> right, I think that was it but I also seem to remember the Eff paper saying it was better
13:56:06 <EvanR> i was about to include stuff like Eff in the pot of stuff that may not be appropriate
13:56:28 <EvanR> but couldnt come up with a good name for it, extensible effects-like
13:56:39 <sproingie> i'm still searching for a heart of gold^W^W^Wbetter monad stack solution myself
13:56:55 <sproingie> i just dont think there's a silver bullet out there
13:57:07 <Fuuzetsu> yep apparently larger overhead of Eff was the problem
13:57:18 <EvanR> i think there is overlap with a similar "omg how do i compose a variety of different exception types"
13:57:24 <EvanR> problem
13:57:34 <Fuuzetsu> sproingie: recently I found out about and succesfully employed in codebase I'm working on at the moment a ReaderT approach
13:57:40 <Fuuzetsu> there was a blog post recently about it, sec
13:58:03 <sproingie> multiple ReaderT's stacked?  sounds downright DI-ish
13:58:06 <Fuuzetsu> basically you have a flat ‘ReaderT yourstate IO a’ and if you need weird things in state you can use IORef &c.
13:58:14 <Fuuzetsu> sec
13:58:27 <sproingie> i'm a bit of a DI zealot when i do OOP
13:58:37 <Fuuzetsu> https://www.fpcomplete.com/blog/2017/06/readert-design-pattern
13:59:01 <Fuuzetsu> there's some buy-in but so far I like it quite a lot actually
13:59:56 <Fuuzetsu> I think I removed multiple 4-5 deep transformer stacks with this, 2 deeps is the most we have right now IIRC
14:01:06 <sproingie> putting iorefs in the environment is interesting.  i guess it's being honest "yeah, you're going to run this in IO at some point anyway"
14:06:07 <dolio> Ideally, if you want to debug pure code, you use a debugger for pure code.
14:06:28 <dolio> And stop thinking in terms of sprinkling print statements in your code.
14:06:28 <Fuuzetsu> do we have such?
14:06:47 <dolio> We did, but it's rotted.
14:07:02 <dolio> There were multiple such debuggers, actually, I think.
14:07:03 <Fuuzetsu> name? kind of looking for cool things to do in evenings these days
14:07:14 <dolio> One was buddha, one was hat, one was hood.
14:07:42 <dolio> hat was many things, but it could do buddha stuff (buddha was the first, I think).
14:07:54 <sproingie> most of my imperative debugging is putting very strategic prints in code
14:08:00 <Fuuzetsu> I'll check these out, thanks (AFAIK hood was kind of recent-ish?)
14:08:11 <sproingie> as in spitting out lots of json dumps of current state
14:08:19 <tdammers> my favorite debugging strategy is staring at the code until I understand it
14:08:25 <dolio> Anyhow, what you do is run your code, see an incorrect result, and get to drill back through how that result was computed to figure out where the bad result came from.
14:08:37 <tdammers> and if that doesn't work, relentlessly refactor it until I do understand it
14:08:49 <Fuuzetsu> tdammers: sadly that works very poorly on large amount of convoluted code you haven't written yourself ;/
14:08:57 <kadoban> Everyone is so down on Debug.Trace, I find it very useful :-/
14:09:12 <tdammers> Fuuzetsu: depends on the language; it's more viable in Haskell than most other languages I've tried
14:09:31 <Fuuzetsu> 99% of the time I use it it's either on something dead-trivial or I regret not putting proper debug in for future use there anyway
14:09:44 <n_blownapart> https://ptpb.pw/H-dj yeah I was expecting to see a boolean but the divides (2, 5390) comes from ldf k n on line 11, I guess. 
14:09:45 <Fuuzetsu> tdammers: I'm talking about Haskell :)
14:09:53 <dolio> It's useful. But there could be better stuff.
14:09:55 <Fuuzetsu> I agree it's much more viable but convoluted Haskell exists
14:10:13 <sproingie> i just fork and refactor anyway, then when i figure out the problem, i go back and focus in on the problem in the original
14:10:25 <sproingie> i refuse to debug shit i don't have any source access for
14:11:03 <tdammers> of course, bad programmers can write bad code in any language
14:11:32 <dolio> trace can even help you do something like that kind of debugging, by printing out values you're suspicious of, with enough annotation to know where they came from.
14:11:33 <n_blownapart> i.e. I expect to see booleans in that trace output.
14:11:38 <n_blownapart> expected
14:11:47 <dolio> But you can't expect the order to tell you, for instance.
14:12:01 <sproingie> dolio: i.e. as a debug tool.  implementing logging with it is horrible.
14:12:47 <sproingie> anyway, time to start up the xbox and go debug some faces with shotguns
14:16:12 <n_blownapart> EvanR, can I install that ghc-vis package with stack? 
14:27:19 <shapr> Was it Andy Gill who did most of the work for foldr / build deforestation/fusion?
14:42:32 <ReinH> shapr: Gill and Voigtländer iirc
14:42:58 <ReinH> https://link.springer.com/chapter/10.1007%2F978-3-540-78969-7_13
14:51:27 <setre> can someone show me how to write: <a href="#">Foo<span class="caret"></span></a> with lucid template?
14:52:56 <Unicorn_Princess> what should I be using for low-dimensional linear algebra, e.g. operations with 2D and 3D vectors, and their associated transformation matrices? using https://hackage.haskell.org/package/linear-1.20.6 currently, and it seems fine
14:53:28 <Unicorn_Princess> but then it says that it's experimental, and has 25k downloads, which is... a lot? not a lot?
14:53:46 <Fuuzetsu> kind of a lot
14:54:21 <Unicorn_Princess> it also says it's not portable, is that in relation to non-ghc compilers?
14:55:09 <jared-w> Unicorn_Princess: wher are you getting the portable and experimental information from?
14:56:03 <Unicorn_Princess> jared-w: if I click on the Linear module on that page, which takes me to https://hackage.haskell.org/package/linear-1.20.6/docs/Linear.html - upper right corner
14:59:31 <Unicorn_Princess> hm. x^2 gets compiled down to the same as x*x? I don't know how clever GHC is
14:59:45 <ReinH> I wouldn't worry too much about "experimental".
14:59:55 <Fuuzetsu> output Core and find out today!
15:00:04 <jared-w> Unicorn_Princess: Here's a tiny bit of ugliness in Haskell. The stability field is almost meaningless, so nobody even really checks it :)
15:00:26 <Unicorn_Princess> Fuuzetsu: I've learned too much today already. reading core is not on the list :P
15:00:42 <ReinH> I mean, lens is marked "experimental".
15:00:51 <jared-w> Although experimental originally meant "API may change between minor revisions. Documentation and tests aren't required for an experimental library"
15:00:55 <Fuuzetsu> it's basically Haskell with bunch of stuff around it you can ignore
15:01:17 <ReinH> I think maybe edwardk just doesn't bother changing that field.
15:02:12 <jared-w> Non-portable also means a library might require language extensions, or depend on nonportable libraries (or has some OS/platform specific stuff)
15:02:51 <Fuuzetsu> Unicorn_Princess: http://lpaste.net/5650614413779009536 last line of the Core output (tl;dr: yes with -O2)
15:04:24 <Fuuzetsu> jared-w: or "haven't tested on Windows/OSX so I'll just say non-portable"
15:04:34 <glguy> http://hackage.haskell.org/package/base-4.9.1.0/docs/src/GHC.Real.html#%5E
15:04:34 <Unicorn_Princess> nix? figures :P
15:04:45 <glguy> If you scroll down you'll find "^2/Int"        forall x. x ^ (2 :: Int) = let u = x in u*u
15:04:45 <jared-w> Fuuzetsu: true that :p
15:06:55 <Unicorn_Princess> glguy: how should I read those rules? and what are they? machine-checked? do they say that the code generated by x^2 is the same as x*x, or just that the value is the same?
15:07:31 <glguy> Unicorn_Princess: No, they're rewrite rules. The are used by GHC to replace the lefthand-side of the rule with the righthand-side at compile time
15:07:45 <Fuuzetsu> unchecked, it's programmer heuristic, it's you saying "OK GHC when you see this, I'm telling you to replace it with that as it's the same but better"
15:07:49 <Unicorn_Princess> oooh, I think I skimmed a paper about that
15:08:09 <Unicorn_Princess> didn't check if it was implemented. very fancy
15:10:51 <jared-w> GHC does this with a lot of things. The paper you probably read was about foldr and build/unbuild or build/consume fusion of some sort :p
15:11:21 <Unicorn_Princess> huh. do I have to add the -fglasgow-exts flag to ghc-options to take advantage of RULES pragmas? https://wiki.haskell.org/GHC/Using_rules claims so
15:12:00 <jared-w> eh, no. Just compiling with -O2 will do that
15:12:08 <Unicorn_Princess> cool
15:12:58 <jared-w> No idea why the wiki page mentions that flag... I thought it was depreciated ages ago
15:13:05 <glguy> Unicorn_Princess: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#rewrite-rules
15:19:12 <dmwit> Unicorn_Princess: (And from the "flag reference", -fenable-rewrite-rules is implied by setting any optimization level.)
15:21:51 <Unicorn_Princess> thanks
15:30:19 <erikd_> whats' the best way of reading/writing a Vector of unboxed Double from/to a file? Binary or is there something better?
15:40:49 <erikd_> Hmmm. maybe Data.Vector.Storable.MMap 
16:01:08 <max3> when does hPutStrLn write out to a handle? say in ghci for example?
16:02:39 <max3> oh you have to do hClose
16:04:06 <EvanR> or hFlush
16:04:43 <Unicorn_Princess> sorry to keep bothering you folks, but despite DuplicateRecordFields this still doesn't work: data A = A {x :: Int}; data B = B {x :: Int}; a = A 2; v = x a; is Lens the only mainstream solution to this?
16:05:22 <Unicorn_Princess> I tried the same example, but using Lens' view, and it worked without having to disambiguate any types
16:05:39 <Unicorn_Princess> (there's no performance penalty to such simple use of Lens, right?)
16:09:42 <pikajude> with really passionate inlining it should be fine
16:12:08 <Unicorn_Princess> (I'm rather upset this is a problem at all, tbh. How the hell did they manage to make member access so difficult... any hope on the horizon for somesort of fix?)
16:12:20 <pikajude> one day
16:12:56 <Unicorn_Princess> ah, magic classes for overloaded record fields looks like it's it?
16:13:50 <pikajude> probably
16:14:23 <max3> if :t x is Just Handle shouldn't fmap hFlush x write out the buffer?
16:14:48 <max3> Maybe is a Functor instance right?
16:15:02 <Unicorn_Princess> yes
16:16:07 <max3> i guess it's not working because of this
16:16:17 <max3>     No instance for (Show (IO ())) arising from a use of ‘print’
16:16:23 <Unicorn_Princess> ..hFlush will give you an IO action tho, so you'll have a Just (IO ())
16:16:45 <max3> so how do i actually flush? from ghci
16:16:46 <Unicorn_Princess> to actually flush it, you'll have to feed that action to the main function, I think
16:17:29 <max3> how do i evaluate from ghci?
16:18:20 <pikajude> mapM_ hFlush probably
16:18:25 <pikajude> that should work
16:18:48 <max3> what does the underscore mean? because there's an SO post that says use sequence_
16:18:49 <taktoa> some packages have source pages in their documentation, as generated by `--hyperlink-source`. However, in some of these source pages, it is simply highlighted with HsColour, whereas in others it is highlighted AND the source itself is hyperlinked
16:19:00 <pikajude> max3: _ means discard
16:19:01 <taktoa> e.g.: https://hackage.haskell.org/package/hup-0.2.0.0/docs/src/Distribution.Hup.Parse.html#readCabal
16:19:05 <pikajude> @type sequence
16:19:06 <lambdabot> (Monad m, Traversable t) => t (m a) -> m (t a)
16:19:08 <pikajude> @type sequnce_
16:19:09 <lambdabot> error:
16:19:09 <lambdabot>     • Variable not in scope: sequnce_
16:19:09 <lambdabot>     • Perhaps you meant one of these:
16:19:10 <pikajude> whoops
16:19:12 <pikajude> @type sequence_
16:19:13 <lambdabot> (Monad m, Foldable t) => t (m a) -> m ()
16:19:17 <taktoa> anyone know how to get the latter kind of docs generated?
16:19:18 <max3> wonderful
16:19:19 <max3> thank you
16:19:45 <geekosaur> taktoa, use the most recent haddock
16:19:58 <max3> for the record this is the best monad tutorial i've seen https://slpopejoy.github.io/posts/Effectful02.html
16:20:04 <max3> the literate source really helps
16:20:43 <taktoa> geekosaur: haddock 2.17.3 isn't new enough?
16:21:23 <geekosaur> ...hackage doesn't even think that one exists...
16:21:24 <taktoa> :-| of course github picks right now to http 500 on me
16:22:12 <boj> yeah, it's down apparently
16:22:35 <geekosaur> 2.17.5 is what hackage shows as current; 2.17.3 is missing from the list. possibly a buggy version?
16:23:04 <taktoa> hmm, let me try 2.17.5
16:25:19 <geekosaur> 2.17.5 docs seem to think that should happen automatically, except it won't hyperlink across packages if you don't tell it how to (--read-interface options to read haddock metadata generated for other packages)
16:25:43 <taktoa> 2.17.5 doesn't change anything. let me try updating hscolour too
16:27:20 <taktoa> nope, I'm on the latest hscolour
16:27:38 <taktoa> whatever, it'll probably be fixed once GHC 8.2 releases
16:28:57 <edwardk> ReinH: i tend to mark small stable packages as other stuff, but most of my stuff keeps the experimental flag
16:29:25 <deceract> Could anyone help me to understand the relationships, if they exist, between strong monoidal functors, strong profunctors, and strong dinaturality?
16:30:08 <taktoa> ah, I needed cabal haddock --haddock-option="--hyperlinked-source"
16:30:17 <taktoa> not cabal haddock --hyperlinked-source, which is different (!)
16:35:06 <evveo> What am I not understanding about GADTs? I'd expect both of these to compile but only the second does: http://lpaste.net/357021 . Is there some way to encode things so that the second does compile?
16:37:00 <dysfigured> is there a preferred lib for "curses" programs?
16:37:05 <EvanR> imagning ghc outputting "does not compile"
16:39:08 <EvanR> without even telling you if its a syntax error or type error or whatever :)
16:39:42 <jared-w> EvanR: It'd be funny if sometimes your errors are just so fundamentally stupid GHC just gives you a "wat" message
16:39:44 <evveo> Updated the paste with the error mesasge
16:40:15 <EvanR> if it could judge the relative stupidity of an error, yes that would be really good
16:40:38 <EvanR> then if its beyond a certain threshold of stupidity, it just deletes the file
16:41:24 <jared-w> evveo: You have 4 different data declarations, but you said 'both'?
16:41:45 <evveo> They are paired declarations
16:41:51 <evveo> The M pair and the P pair
16:42:17 <evveo> And the type error comes in `pbaz` but not in `mbaz`
16:42:29 <jared-w> gotcha. So the error says "could not deduce ks ~ (k0 : ks0) in an equation for pbaz"
16:42:35 <edwardk> deceract: i don't know that there is much connecting them
16:42:40 <EvanR> for less confusion, two pastes one with an error one without
16:42:40 <LiaoTao> EvanR, Maybe it'd be a good idea to build in some self-preservation laws
16:42:47 <EvanR> LiaoTao: lol
16:43:12 <edwardk> deceract: i'm sure if you ask bartosz he'll spend 6 months and come up with a clever way to say oh, look its all just the yoneda lemma some how ;)
16:43:37 <edwardk> deceract: but i don't spot any obvious connections between the concepts and i use them fairly regularly (well, less so strong dinaturality)
16:44:35 <jared-w> evveo: if they're identical other than layout, maybe that's the issue?
16:45:33 <MarcelineVQ> jared-w: PImpure's argument type parameters are different in PEff than in MEff
16:45:40 <evveo> Yup, that
16:47:42 <deceract> edwardk: So true about bartosz ;) I'll look forward to his next treatise on the topic.
16:48:26 <max3> how do you read this signature? `validateMsgRdr :: String -> Reader AppConfig (Either String ())` from the definition of Reader i see only one type variable
16:48:31 <deceract> edwardk: Thanks. I wasn't sure. Their respective definitions, diagrams had just enough similarities to make me wonder.
16:48:43 <mniip> max3, Reader surely has two
16:48:47 <mniip> what definition are you reading
16:48:58 <max3> `type Reader r = ReaderT r Data.Functor.Identity.Identity`
16:49:00 <edwardk> deceract: i know the feeling
16:49:09 <mniip> max3, that doesn't mean it has kind *
16:49:22 <mniip> check the kind of ReaderT
16:49:40 <max3> right you are
16:49:51 <max3> :k Reader is actually * -> * -> *
16:49:53 <lambdabot> error:
16:49:53 <lambdabot>     Not in scope: type constructor or class ‘*’
16:49:53 <lambdabot> error:
16:50:44 <max3> so how do i read the definition of Reader? partially applied type constructor?
16:50:48 <mniip> yes
16:50:55 <max3> interesting
16:50:56 <max3> thank you
16:57:23 <nacho> Hello
16:59:41 <max3> hello
17:05:22 <nacho> Is this the correct (Just)  channel for Haskell beginners? Or (Maybe) there's another one?
17:05:50 <Tuplanolla> We have #haskell-beginners too, nacho.
17:06:18 <nacho> @Tuplanolla thanks!
17:06:18 <lambdabot> Unknown command, try @list
17:07:29 <mniip> that cohumor looks like humor
17:08:34 <erisco> definitely cocohumour but I can't constructively say it is humour
17:10:52 <mniip> LEMme try
17:39:12 <haskell_newbie> Hey folks, I know I'm about to ask a question you get ten times a day, but is Learn You a Haskell still a good way to learn haskell for the first time? I know it was talked up years ago when I thought about picking haskell up, but life got busy and I never bit
17:39:37 <Rembane> haskell_newbie: It's not the best resource anymore. 
17:40:41 <ziman> what's the recommended one?
17:41:01 <Rembane> Here's a quite good list: https://github.com/bitemyapp/learnhaskell
17:41:08 <boj> haskell_newbie: i would suggest http://haskellbook.com
17:41:26 <mnoonan_> haskell_newbie: it’s kind of like reading pop physics. it’s entertaining and will expose you to some new ideas, but you’ll find your knowledge lacking when you try to dig deeper.
17:41:44 <boj> haskell_newbie: authored by bitemyapp (Chris) and Julie, basically a very pedagogical approach to the repo Rembane linked
17:41:56 <haskell_newbie> Sweet, thanks for the feedback guys
17:42:10 * jared-w picks up his favorite bike shed color
17:42:46 <haskell_newbie> @mnoonan_ You're saying LYaH is the pop book, right?
17:42:47 <lambdabot> Unknown command, try @list
17:42:57 <jared-w> it suuure would be real damn nice if we finally got around to removing RWH and LYAH from the learning materials in the r/haskell sidebar and put something useful in there. Just because the best materials out there aren't free doesn't mean they shouldn't be mentinoed
17:42:59 <haskell_newbie> (sorry, haven't used IRC in ages, not sure how to address someone)
17:43:01 <mnoonan_> haskell_newbie: right
17:43:12 <haskell_newbie> Got it. Cool. That was my hunch
17:43:14 <mnoonan_> (you can do it without the @ :)
17:43:17 <Rembane> jared-w: Blue?
17:43:25 <haskell_newbie> Which is what brought me here, ironically, from the LYaH page :)
17:43:30 <haskell_newbie> mnoonan_: got it
17:43:31 <jared-w> haskell_newbie: yeah. LYAH is pop or worse
17:43:34 <haskell_newbie> mnoonan_ got it
17:43:34 <boj> jared-w: sadly there was a debate about that, for whatever reason people weren't comfortable promoting book authors
17:43:37 <haskell_newbie> Maybe I don't
17:44:19 <boj> haskell_newbie: definitely poke at LYAH, there's some good stuff in there, but don't make it your primary learning resource
17:44:24 <jared-w> boj: I don't get it. You're not promoting authors, though. It's not like I'm ever going to promote /everything/ Bird's written. Much of his stuff is great, a lot of it is terrible for beginners, one of his books is really good for beginners.
17:44:34 <boj> jared-w: i don't get it either
17:44:37 <haskell_newbie> (Maybe you guys using my name just causes it to show up a different color because it's my name and I'm trying to make a feature work that isn't there)
17:44:55 <haskell_newbie> Yeah, I'm on the same boat as jared in terms of promoting authors
17:45:01 <haskell_newbie> Though I'm not well-versed on your culture here
17:45:08 <mnoonan_> haskell_newbie: it’s all client-specific, but most clients just highlight any line that contains your nick in any form, afaik
17:45:10 <haskell_newbie> (and by that I mean I am unexposed to it)
17:45:12 <jared-w> Yet somehow it's totally fine to link to bitemyapp's git repo, LYAH (written by /someone/ ಠ_ಠ), Real World Haskell (ALSO written by a human...) etc
17:45:17 <haskell_newbie> mnoonan_ got it
17:45:36 <haskell_newbie> ;)
17:46:17 <boj> the reddit community seemed pretty adamant about only linking to free resources. that's too bad really
17:46:37 <haskell_newbie> Yeah, that is a shame
17:46:42 <jared-w> Can't they just link to the pirate bay versions of the best resources then? /s
17:46:50 <haskell_newbie> hahaha
17:47:02 <haskell_newbie> Well if anyone has any hints or wants to private message me paid resources that are stellar, I won't tell :P
17:47:20 <boj> haskell_newbie: i've been onloading new team members with Haskell Book, they're picking things up pretty fast. definitely give it a look
17:47:35 <jared-w> Yeah I'm reading it now and it's great.
17:47:38 <haskell_newbie> roger that
17:47:39 <haskell_newbie> sweet
17:47:46 <jared-w> There's 3 basic "good beginner books" and they approach haskell on a spectrum.
17:47:51 <haskell_newbie> I'm on 2 week vaca from work and just felt like digging into something new
17:47:53 <boj> p.s. dear #haskell channel if you don't mind moving to Alaska and can work in the US we are hiring :P
17:47:57 <haskell_newbie> (not that I won't continue past 2 weeks)
17:48:14 <mnoonan_> boj: what if I don’t mind but my family does? :)
17:48:18 <jared-w> HFFP is on the "learn by doing! Practical! Know how to use Haskell!" side of things
17:48:19 <haskell_newbie> boj: Let me know if you join 2017 and let me consult remotely :)
17:48:57 <jared-w> So you might not learn how to *think* in haskell as well with that book as some others, you'll have a very strong background in how to *do* haskell
17:49:09 <haskell_newbie> Right. That makes sense
17:49:23 <jared-w> In the middle is Hutton's 3rd edition of programming in haskell. Less strong in the doing, more strong in the "how to think functionally"
17:49:38 <haskell_newbie> I'm really looking for how to think in haskell
17:49:42 <ReinH> For thinking functionally with Haskell, I recommend the book Thinking Functionally With Haskell.
17:49:58 <jared-w> On the far side is Bird's book "Thinking Functionally with Haskell"
17:50:15 <ReinH> It's a great book.
17:50:22 <haskell_newbie> By far side you mean it's super theoretical and will give very little practical knowledge at all?
17:50:29 <ReinH> No.
17:50:38 <jared-w> Nah, just that its strongest aspect is giving you that thinking functionally mindset
17:50:48 <ReinH> It will give you some extremely practical knowledge.
17:50:48 <haskell_newbie> Okay
17:50:57 <haskell_newbie> Also, sorry, which book is HFFP?
17:51:00 <jared-w> They're all practical and all have some theory
17:51:16 <jared-w> HFFP is haskell from first principles. By bitemyapp (and his co author who isn't nerdy enough to lurk irc)
17:51:18 <MarcelineVQ> haskell_newbie: it's http://haskellbook.com/
17:51:25 <haskell_newbie> got it
17:51:43 <haskell_newbie> I'll take a look at that and also Thinking Functionally with Haskell, unless you guys tell me to really just start with haskellbook
17:51:59 <haskell_newbie> Frankly, I'm here because I'm bored with my software life recently and looking to brute force some paradigm shifts
17:52:33 <jared-w> What I meant by the spectrum is that the books have different strengths. HFFP approaches Haskell where the most important thing is to just start doing it. Bird's book has a philosophy where the most important thing is to learn how to think in a functional way (I think? Haven't started reading it yet. ReinH will tell you if I'm wrong)
17:52:50 <haskell_newbie> Roger.
17:52:53 <ReinH> I would agree with that.
17:53:14 <haskell_newbie> Still a good starter though?
17:53:21 <jared-w> haskell_newbie: What I like about HFFP is that it starts you off pretty slowly, with some basic lambda calculus, and then you get right into doing some fun tinkering around. I think the two books complement each other *really* well
17:53:52 <haskell_newbie> Got it
17:53:59 <haskell_newbie> So I'll take the hybrid approach then
17:54:02 <haskell_newbie> Thanks guys, you rock
17:54:11 <jared-w> If I had to pick one, I'd pick the HFFP because, for me, it was most important to shut up and just start coding since I'm a theorist and my weakness is not applying my theory enough to make sure I truly understand it :p
17:54:26 <haskell_newbie> I've never jumped onto a chat channel and been met with nothing but friendly, helpful people before xD
17:54:40 <haskell_newbie> Right-o, that makes sense
17:54:58 <EvanR> i know, its weird
17:55:05 <jared-w> So I picked a book that approached the weaker side of my learning. As aconsequence, I've gotten way better at Haskell way faster than I thought I would. I'm going to start reading the Bird book right after I finish the monad chapter in HFFP and start reading them more or less in parallel :)
17:55:09 <haskell_newbie> And I have the same tendencies, but I'm also really sick of writing Java and JS and only have two weeks until clients start expecting work to leave my desk again :)
17:55:24 <haskell_newbie> Nice!
17:55:29 <haskell_newbie> Seems like you're rocking your learning style very well
17:55:48 <jared-w> haskell_newbie: JS? Look up redux, immutable.js, and (unrelated) Elm.
17:56:18 <EvanR> i need to dredge up whatever tutorials and materials i used to learn haskell
17:56:29 <jared-w> Then forget about that, learn some haskell, and come back to the redux/immutable and all the sudden you're gonna be like "omg I can use JS sanely"
17:56:48 <haskell_newbie> jared-w: Yup, spent most of my time the last year leading a react project. Been using redux for state management with immutable.js backing the whole state management layer
17:56:53 <haskell_newbie> It's definitely been a pleasure
17:56:57 <haskell_newbie> Elm's been on my list for a while
17:57:41 <jared-w> Elm is kinda thought of by a lot of people in the Haskell community as a "haskell-lite" so you should be able to pick it up really fast if you're familiar with Haskell :) in fact, any functional language should come naturally after Haskell
17:57:55 <haskell_newbie> I definitely *enjoy* JS. It's a thinly veiled lisp, and with structural typing options like Typescript as well as a great Nominal typing option with Flow now, it's got a lot going for it. When I'm feeling that structured. Which normally I'm not unless it's a big team moving aggressively.
17:58:21 <haskell_newbie> Very cool, will definitely have to look at it more
17:58:33 <deceract> Is there a channel for haskell-related category theory? Somewhere if I lurk long enough, I might pick up a few nuggets of categorial goodness?
17:58:35 <Lokathor> jared-w, were you the one going on about traversable last night?
17:58:41 <haskell_newbie> That makes sense since it's some friends that write clojure a lot I know that have recommended it
17:58:45 <deceract> What do most haskellers think of react.js and react fiber?
17:58:59 <EvanR> haha
17:59:11 <jared-w> deceract: If you want category theory just ping edwardk and have at it ;)
17:59:12 <haskell_newbie> deceract: I'm confused how react fiber plays into the conversation
17:59:19 <EvanR> haskell_newbie: "A Gentle Introduction to Haskell (98)" https://www.haskell.org/tutorial/haskell-98-tutorial.pdf
17:59:27 <jared-w> Lokathor: uhhhh maybe?
17:59:36 <dolio> EvanR: Oh, that's what you read, too?
17:59:39 <Lokathor> it might have been cocreature >_>
17:59:43 <dolio> The only thing that existed.
17:59:43 <EvanR> i think so
17:59:53 <jared-w> I mentioned how Lenses are  useful for more than just for basic getters and setters but that's it
17:59:55 <haskell_newbie> EvanR: thanks for the link!
18:00:00 <Lokathor> ah
18:00:18 <jared-w> haskell_newbie: warning: That link is famous for being extraordinarily "non-gentle"
18:00:25 <haskell_newbie> I inferred as much ;)
18:00:36 <EvanR> i heard that but i dont think thats going to be the case for haskell_newbie 
18:00:38 <deceract> haskell_newbie: Sorry. It only pertains tangentially at best, since you mentioned react (I think). I'm not sure what the proper irc etiquette is.
18:00:56 <haskell_newbie> Roger. I don't either. I was just curious if there was something I didn't know about fiber
18:01:06 <EvanR> since theyre already on the way to knowing what that want, and know other languages and their issues
18:04:04 <jared-w> I've never seen JS described as a thiny veiled lisp lol
18:04:40 <haskell_newbie> Oh, I'm a huge fan of Common Lisp
18:04:44 <haskell_newbie> I'll talk your ear off about it ;)
18:04:53 <haskell_newbie> But that's definitely how I view JS
18:05:05 <EvanR> there are a couple of features that lisps have, but other than that youll need to stretch lisp quite a bit to get js
18:05:09 <haskell_newbie> Especially with the latest features, I mean damn, it's almost homoiconic
18:05:34 <haskell_newbie> EvanR: I mean, right, it's a stretch to be sure
18:05:42 <haskell_newbie> But in philosophy they've got a lot in common
18:05:49 <EvanR> im sure theres a lisp that has stretched that way
18:05:59 <haskell_newbie> Brendan Eich actually wanted to make a lisp
18:06:08 <haskell_newbie> But it wasn't viewed by his peers at netscape as marketable
18:06:45 <EvanR> yes, the story goes he was told to make lisp, spent an entire weekend on an acid trip, and produced js
18:07:01 <EvanR> or something along those lines
18:07:03 <haskell_newbie> hahaha haven't heard the acid trip part
18:07:40 <dysfigured> is there a preferred lib for "curses" programs?
18:07:40 <EvanR> millenia later billions was invested in making it high performance
18:08:22 <c_wraith> um. I think brick is the hot choice for terminal UI these days. 
18:08:39 <mnoonan_> since elm came up as a JS-ified Haskell, what’s the story with purescript? it seems haskellier from a very cursory examination, but I’m not clear on how it compares to elm or ghcjs
18:09:07 <dysfigured> ^ i too am curious about this
18:09:13 <dysfigured>  
18:10:21 <jared-w> lol that's hilarious if it's true
18:10:43 <dysfigured> iinm elm is also an opinionated framework about how sites should be made, whereas purescript and ghcjs are just languages and leave the whole architecture and such up to the user
18:10:45 <c_wraith> ghcjs is a different backend for ghc. support almost the entire language, and a lot of what's on hackage. elm and purescript are different languages specifically designed for the frontend 
18:10:58 <evveo> Elm community claims to prioritize simplicity e.g. no typeclasses. Purescript is basically a strict Haskell with the benefit of hindsight. ghcjs is compatible with much of hackage but generates big code
18:11:09 <haskell_newbie> jared-w: Right?! I mean I'd believe it, but damn, what a weekend!
18:11:23 <jared-w> iirc, PureScript is a fork off of Haskell's GHCJS project where they basically said "screw trying to keep compatibility with GHC, let's just make the best Haskell-like compile-to-JS that we can"
18:11:28 <mnoonan_> oh, I didn’t realize purescript was strict. that’s interesting.
18:11:32 <dysfigured> i'd be interested to see how to integrate something like react with purescript or ghcjs
18:11:40 <c_wraith> yeah, strict basically ruins it. 
18:11:44 <dysfigured> since elm basically has react+redux baked in (iiuc)
18:11:48 <EvanR> haskell_newbie: that was a standard mutation of the latest evolution of the story
18:12:06 <haskell_newbie> EvanR: Right
18:12:07 <EvanR> your reality may vary
18:12:10 <ReinH> Uh... I don't think purescript is a fork of ghcjs? Doesn't purescript predate ghcjs?
18:12:18 <evveo>  https://github.com/paf31/purescript-thermite
18:12:23 <dolio> It's definitely not a fork of ghcjs.
18:12:26 <dysfigured> ReinH: i think so
18:12:44 <evveo> ^ Pretty sure that's the preferred react lib for PS 
18:12:47 <jared-w> whoops. I read that at one point and somehow never really saw something that refuted that ¯\_(ツ)_/¯ probably read that wrong
18:13:08 <EvanR> not refuted = must be true
18:13:42 <dysfigured> oh nice
18:14:17 <Lokathor> {-# LANGUAGE Trustworthy, TemplateHaskell #-}
18:14:19 <Lokathor> mmmmmm
18:14:25 <Lokathor> good sauce
18:14:34 <EvanR> haha
18:15:33 <paf31> evveo: purescript-react is the basic one, thermite is my opinionated layer on top
18:16:28 <EvanR> opinionated
18:16:35 <deceract> I think there's already at least one purescript library that wraps react, called purescript-react.
18:16:48 <deceract> A couple of other UI frameworks besides thermite: pux and halogen.
18:16:51 <EvanR> i need to remember to use this in my libraries to justify not knowing what im really doing
18:18:08 <paf31> opinionated in the sense that it uses things like lenses and coroutines, whereas ps-react is a low level set of bindings
18:18:12 <deceract> I don't think purescript-react does much more than take pull react in directly in javascript form into a purescript-wrapping library. I'm not sure whether anyone's tried a pure purescript-idiomatic translation of it yet.
18:18:20 <paf31> Halogen doesn't use React, it has its own virtual dom library
18:19:16 <haskell_newbie> I find it funny when libraries wrap React for v-dom management
18:19:28 <haskell_newbie> There are much lighter weight and less opinionated v-dom solutions already on the shelves
18:19:48 <haskell_newbie> Now, writing a react *adapter* for a library is a different story
18:21:13 <haskell_newbie> jared-w: On haskellbook.com and noticed on the purchase screen is mentioned it's "Early Access." Nothing to be concerned about, though?
18:21:35 <haskell_newbie> the "Progress" page doesn't seem to indicate anything in particular missing
18:21:50 <haskell_newbie> (and it does say it's content complete)
18:23:25 <haskell_newbie> (I don't know why I asked actually, I already bought it...I'm sure it's just fine)
18:23:39 <EvanR> you could ask bitemyapp what that early access means
18:29:00 <EvanR> there should be an addendum to the gentle introduction to bring the reader up to speed with some more modern stuff, like Control.Exception
18:30:25 <EvanR> or perhaps a "colored overlay" to place over the original document
18:31:29 <EvanR> it even explains how to write Read and Show classes!
18:39:04 <ammazza> haskell_newbie: just wanted to say hi! I'm also a Common Lisp fan who's recently started looking into Haskell.
18:40:04 <ammazza> haskell_newbie: I can confirm haskellbook.com is a great resource!
18:40:30 <haskell_newbie> Awesome!
18:43:18 <ammazza> With 2 weeks holiday you likely wanna focus on a good book.
18:43:40 <ammazza> But when you have more time, you could have a look at this: https://github.com/data61/fp-course
18:44:11 <haskell_newbie> ammazza: Already have a page that links to that one bookmarked - thanks for the +1!
18:44:13 <ammazza> It's a functional programming course, not a Haskell one. But uses Haskell as language.
18:44:25 <haskell_newbie> cool!
18:45:23 * Lokathor gives an intro on get/set/modify with lenses
18:45:46 <haskell_newbie> From a footnote in the intro of that book: "Functional programming is a style of programming in which function calls, rather than a series of instructions for the computer to execute,"
18:45:54 <Lokathor> "And now you know why this section is called "ASCII Vomit Magic"."
18:46:01 <haskell_newbie> "function calls, rather than a series of instructions..."
18:46:05 <haskell_newbie> Kind of made me go o.O
18:46:31 <EvanR> youre going to have a hard time getting people to agree on what functional programming is
18:46:35 <haskell_newbie> Oh, of course
18:46:38 <Lokathor> haskell_newbie, the book is in early access only because you can't currently get a physical version
18:46:42 <Lokathor> all content is complete
18:46:45 <ammazza> I think they wanna stress composability.
18:46:46 <haskell_newbie> Got it
18:47:03 <Lokathor> it's like, 1200+ pages, and so most publishers are pretty wary about it, you know
18:47:12 <haskell_newbie> EvanR: Oh, of course. It's hard enough to get people to agree on what microservice architecture is, and that has a concrete definition xD
18:47:32 <haskell_newbie> That wording was just awfully deceptive for someone without a professional software background, which is one of their target audiences
18:47:51 <EvanR> i see a book writing project in your future!
18:47:57 <EvanR> just dont write a monad tutorial
18:48:22 <Lokathor> A monad is a burrito in the category of sandwiches
18:48:23 <boj> yes, hopefully this monad tutorial *i* am writing will be the last
18:48:28 <haskell_newbie> Who, me? Nah, I'm just really good at telling other people what they should've have done differently! ;-)
18:48:35 <haskell_newbie> (actually, I've wanted to write a book for a long time)
18:48:42 <EvanR> i only give good advice, never take it
18:48:50 <haskell_newbie> Damn skippy.
18:48:51 <mnoonan_> haskell_newbie: that comment reminds me of.. what the heck is it called.. “stack oriented programming”? some old idiom that isn’t quite what it sounds like anymore, where every program is broken down into a sequence of procedure calls.
18:49:18 <mnoonan_> “procedure oriented programming”? my google-fu is failing me.
18:49:48 <mnoonan_> ah, got it! https://en.wikipedia.org/wiki/Concatenative_programming_language
18:50:16 <mnoonan_> er, no, that wasn’t it after all :|
18:50:21 <EvanR> i heard some people talking about concatenative programm as "stack based" and became very confused
18:50:27 <EvanR> programming
18:51:05 <haskell_newbie> mnoonan_: xD
18:51:40 <EvanR> is programming purely via procedure calls... "procedural programming"
18:51:52 <EvanR> is it not
18:51:58 <kadoban> mnoonan_: Procedural programming perhaps? It's a somewhat outdated term, because what it replaced kind of doesn't exist anymore.
18:52:40 <mnoonan_> kadoban: yeah, I thought that might have been it but it has become un-googleable, so I couldn’t verify
18:54:29 <Jinxit> i agree with procedural
18:55:11 <Axman6> isn't procedural programming more about the fact that the unit of code is a procedure of instructions to carry out?
18:55:26 <EvanR> prepare yourself... http://wiki.c2.com/?ProceduralProgramming
18:55:32 <Axman6> not that there "are procedures", procedurres as the thing which are _procedural_
18:55:37 <haskell_newbie> Yeah, people tend to use procedural and imperative interchangeably
18:55:54 <haskell_newbie> (whether that is semantically accurate or not, I couldn't tell you)
18:55:56 <EvanR> contrast imperative programming with declarative programming
18:56:03 <haskell_newbie> That's another mess
18:56:16 <haskell_newbie> I tend to tell people that declarative programming focuses on decoupling contexts
18:56:17 <EvanR> you could or could not use procedures a lot when doing imperative programming
18:56:37 <EvanR> i could have sworn there was a BASIC which didnt have procedures, but is definitely imperative
18:56:41 <Jinxit> what defines declarative programming? no sequentiality?
18:56:54 <EvanR> specifying "what" rather than "how"
18:56:58 <haskell_newbie> In theory, it is in part defined by a decoupling from sequentiality
18:57:02 <haskell_newbie> Right
18:57:13 <Axman6> I would say that declarative means that order only matters when you declare it matters
18:57:31 <EvanR> order can matter, thats not really the focus
18:58:02 <EvanR> you wouldnt say CSS is a sequence of instructions, its a set of rules
18:58:07 <EvanR> or descriptions
18:58:23 <haskell_newbie> Good example
18:58:38 <EvanR> the rules have various priorities which happen to be encoded with order
18:58:42 <Jinxit> anyone familiar with behaviour trees? (AI)
18:58:52 <Jinxit> i would say they're declarative too, now that i think about it
18:58:52 <haskell_newbie> Jinxit: What about them?
18:58:58 <haskell_newbie> Ah, ok
18:59:04 <haskell_newbie> I mean yeah, that seems accurate
18:59:22 <Jinxit> they're basically sequences of ands and ors down a tree
18:59:31 <haskell_newbie> It's behavior represented through a consistent data structure
18:59:41 <haskell_newbie> Which is declaratively oriented if nothing else
19:00:12 <haskell_newbie> Of course, that effectively draws out the question: Can Common Lisp be described as a purely declarative language?
19:00:35 <EvanR> common lisp seems pretty imperative to me
19:01:05 <Jinxit> i don't see how it's declarative
19:01:55 <haskell_newbie> Well that's the discussion, right? The line between imperative and declarative is somewhere between thin and invisible, and you know when you're on one end of the spectrum, but could it be argued that you can exist in both?
19:02:07 <EvanR> its not so clear
19:02:09 <haskell_newbie> Being homoiconic, it can largely be viewed as a behavior tree
19:02:12 <haskell_newbie> CL that is
19:02:30 <haskell_newbie> A complex behavior tree with different types of nodes, sure
19:02:34 <haskell_newbie> But a behavior tree nonetheless
19:02:37 <EvanR> i argue, on a biannual basis, that homoiconic doesnt really mean anything coherent
19:02:37 <Jinxit> well okay
19:02:40 <Jinxit> i see your point
19:02:53 <Jinxit> but i was thinking of a behaviour tree that just selects a single "result"
19:03:04 <Jinxit> no state or memory nodes
19:03:06 <haskell_newbie> sure
19:03:08 <EvanR> in lisp you have a lot of confusion over concrete syntax, abstract syntax, and a lot of other things with those two things
19:03:27 <Lokathor> I would say that imperative / declarative describes how the programmer thinks of the program. One says "i will tell you every step" and the other says "oh figure it out yourself you dumb compiler"
19:03:28 <EvanR> sort of on purpose, but i find it annoying
19:03:52 <haskell_newbie> EvanR: Fair enough, though I wouldn't say that argument renders the concept of homoiconicity meaningless
19:04:06 <EvanR> i didnt make any arguement yet
19:04:12 <haskell_newbie> Noted :P
19:04:13 <Jinxit> Lokathor: but the compiler is always so abstract that you're not telling the machine what to do
19:04:28 <EvanR> it certainly doesnt render the concept non existent
19:04:42 <haskell_newbie> Jinxit: Is that a necessity for the definition, though?
19:05:05 <Lokathor> Jinxit, that is surely not the point, the programmer _thinks_ that they're telling the compiler each step
19:05:11 <Lokathor> even if the truth is somewhere else
19:05:22 <Jinxit> good point
19:05:35 <EvanR> a good example of how declarative and imperative might not be clear is in do notation
19:05:45 <Jinxit> is declarative by definition stateless?
19:05:49 <EvanR> do notation essentialy defines a data structure that you can operate on from within the language
19:05:55 <Jinxit> in a single "block" or however you want to divide it
19:05:55 <EvanR> but its clearly an imperative thing
19:06:30 <Lokathor> "clearly"
19:06:31 <Lokathor> hmm
19:06:41 <EvanR> yeah *do ... stuff* :)
19:06:49 <EvanR> in IO especially
19:07:18 <Jinxit> or if you look at something like lens it's also very clear
19:07:48 <haskell_newbie> Jinxit: I do not believe that declarative is by definition stateless at all; to me, it just necessitates a clear decoupling of state management and state interaction, and dictates the style of each of those components.
19:07:55 <EvanR> you declare an IO action or a "IO action factory (functor)"
19:08:10 <EvanR> (function)*
19:08:28 <haskell_newbie> decoupling of state writing processes and state reading processes would have been a much better way of saying what I said
19:08:30 <EvanR> stateless and stateful dont seem applicable to what were talking about
19:08:33 <haskell_newbie> Since what I actually said didn't make sense
19:08:44 <Jinxit> yeah i got what you meant
19:08:44 <haskell_newbie> EvanR: Agreed.
19:09:54 <Jinxit> but that was also what i was trying for when i mentioned a "block", not doing both edits and reads in the same block
19:10:30 <haskell_newbie> got it
19:10:43 <Jinxit> i don't see how state isn't applicable
19:10:53 <Jinxit> you can't say what "is" if you're also changing it
19:10:56 <EvanR> state or statelessness/statefulness?
19:11:09 <EvanR> i think maybe youre referring to a too-vague kind of "state"
19:11:16 <Jinxit> maybe
19:12:03 <EvanR> like, if i have some words on paper, words on the screen, words in a file, or am holding an AST in my hand... i dont really think of statefulness or statelessness because i dont have a process or procedure to do repeated experiments on
19:12:18 <EvanR> to see if my experiments are repeatable
19:12:29 <Jinxit> you lost me
19:13:04 <haskell_newbie> Alrighty folks well I hate to start an argument and then bail, especially because I'm liking this one, but I g2g
19:13:09 <haskell_newbie> I'm sure I'll be back on in coming days/weeks
19:13:16 <haskell_newbie> You guys seem like a fun group
19:13:23 <haskell_newbie> Thanks for all your help
19:13:30 <Jinxit> seeya around
19:14:04 <EvanR> declarative and imperative are adjectives for languages+semantics
19:14:07 <monochrom> "State" is always applicable. "Parameter passing" is also always applicable.
19:14:59 <monochrom> Where performance requirements are low or achievable, "state" and "parameter passing" are interchangeable.
19:15:02 <EvanR> but with syntax alone, which you can use more readily with declarative, what use is statelessness
19:16:04 <monochrom> For example, I have helped a beginner to boost performance by 5-10x by merely replacing state (IORef Int) by parameter passing.
19:16:17 <EvanR> does an inert artifact have a state? yeah, but thats not the same as stateless/stateful
19:16:40 <EvanR> which is an adjective for a process you can repeat
19:17:56 <EvanR> when i keep trying to the same thing and expect different results, i have either gone insane, or i think the process is stateful
19:18:21 <EvanR> or both
19:20:06 <mnoonan_> are you distinguishing stateful from stochastic somehow?
19:20:15 <EvanR> haha no
19:20:52 <EvanR> but yeah thats another kind of process
19:21:21 <EvanR> i think you can model a stochastic process using some state, rng state?
19:24:30 <mnoonan_> EvanR: I mean, sure, but if we’re going to start conflating models with the thing to be modeled, let’s just blow the whole damn thing up and go back to C :)
19:26:41 <EvanR> i accept defeat, the process could also be stochastic
19:27:00 <EvanR> i hope you never have to deal with that on the job!
19:27:26 <EvanR> the process could also behave arbitrarily
19:27:30 <EvanR> even better
19:28:10 <EvanR> if you cant see the state or not, you might not be able to tell the difference between the 3
19:28:26 <EvanR> er, s/or not//
19:29:47 <electron42> so what if i want something like acid-state but i want my variables to be large enough that they can't fit in main memory?
19:30:09 <boj> rethink your problem
19:30:16 <boj> and your approach
19:30:17 <boj> :)
19:30:44 <electron42> heh
19:30:49 <electron42> i'm stuck with a database, aren't i
19:31:09 <boj> sounds like it
19:31:37 <EvanR> well, what if they cant fit in a disk?
19:31:48 <electron42> well with zfs
19:31:54 <electron42> you can have really big "disks"
19:32:00 <EvanR> how?
19:32:17 <electron42> doesn't zfs allow you to pool disk space in a way which is transparent?
19:32:20 <boj> you can keep adding physical disks to zfs but get exobytes of space
19:32:29 <EvanR> next move
19:32:41 <electron42> right, so with zfs i can have 100 TB of space, no problem
19:32:42 <EvanR> why cant you pool more memory together
19:32:51 <electron42> more RAM?
19:32:57 <EvanR> yeah
19:33:01 <electron42> cash
19:33:09 <EvanR> alrighty then
19:33:44 <EvanR> cash is also the reason you cant relativistically visit alpha centauri for brunch!
19:33:50 <boj> electron42: was there any particular reason you needed it all in memory?
19:34:05 <electron42> i've just been learning/thinking about databases lately
19:34:11 <boj> ah
19:34:25 <electron42> many applications don't need databases which are all that large
19:34:33 <boj> indeed
19:34:34 <electron42> but type safety is increasingly regarded as important
19:34:46 <electron42> and ORMs all seem to be one or another form of horror
19:35:11 <electron42> and SQL ends up just taking part of your program and putting it into a language which is specific to whatever database you are using
19:35:22 <EvanR> what is the distinguishing feature between memory and disk that messes up the benefits of type safety
19:35:42 <electron42> distinguishing feature is SQL versus my own types in memory
19:35:46 <electron42> not memory and disk
19:35:49 <EvanR> ah
19:35:53 <electron42> so, i just want RAM
19:36:02 <electron42> but like 100 TB of it
19:36:13 <EvanR> but... now youre back to RAM vs (your programs use of) disk
19:36:22 <electron42> ideally it'd be smart and snappy but if i have microsecond rather than nanosecond latency, i'll find a way to survive
19:36:37 <electron42> well
19:36:46 <mnoonan_> wait, I thought the whole point of acid-state was automatically persisting stuff to a db, invisibly?
19:36:50 <boj> i imagine acid-state does this as it is? you are just talking about being limited by RAM
19:36:55 <electron42> ideally something would allow me to store things in "RAM"
19:36:59 <EvanR> acid-state uses disk, but keeps everything in memory
19:37:08 <electron42> but i don't want to think about the size of my RAM or how that synchronizes to disk
19:37:09 <mnoonan_> i see
19:37:28 <EvanR> well sql databases do keep stuff in memory to a point
19:37:28 <electron42> right, but i can't use acid-state with a 100 GB file on a system with 2 GB of RAM, no?
19:37:53 <electron42> RAM, regrettably is expensive (and consumes power...)
19:38:04 <boj> so, you need disk storage
19:38:05 <EvanR> thats ultimately the trade off
19:38:09 <nshepperd> couldn't you make something like acid-state that puts everything in a bunch of mmaped Storable arrays
19:38:23 <EvanR> yeah i was just thinking that
19:38:25 <nshepperd> or uh
19:38:32 <EvanR> but it wouldnt solve the performance tradeoff
19:38:48 <electron42> nshpperd: yeah that's something like what i'm talking about
19:38:58 <Lokathor> alright
19:39:10 <Lokathor> what's the magic to take two lenses and use both on the same thing and get a tuple back
19:39:17 <nshepperd> i guess i don't see any reason why a normal DB that stores stuff on disk couldn't be implemented as a haskell library
19:39:19 <EvanR> electron42: basically, you want an SQL database engine that runs within the process
19:39:27 <Lokathor> i feel that there are ancient runes that will somehow do this
19:39:32 <EvanR> which may not even use SQL
19:39:53 <ReinH> nshepperd: it certainly can
19:40:02 <electron42> yeah i'm not that excited about SQL
19:40:10 <mnoonan_> Lokathor: (&&&) ?
19:40:11 <electron42> if i want to index on a variable, i can do that myself
19:40:31 <ReinH> nshepperd: e.g., https://hackage.haskell.org/package/arena
19:40:50 <Lokathor> hmm, it says that's not in Control.Lens
19:40:55 <Lokathor> do i need to import extra?
19:41:28 <nshepperd> :t both view
19:41:30 <lambdabot> (MonadReader s f, Data.Bitraversable.Bitraversable r) => r (Getting b s b) (Getting b s b) -> f (r b b)
19:41:43 <EvanR> boils down to 1) large storage engine which 2) usable from haskell directly
19:41:47 <mnoonan_> It’s in Control.Arrow according to hoogle. Are you really after something lens specific? Maybe I don’t quite get the type of what you’re after.
19:41:52 <verement> electron42: have you looked at vcache?
19:41:57 <electron42> EvanR: something like that
19:42:02 <Lokathor> mnoonan_, doesn't have to be lens specific i guess
19:42:02 <ReinH> arena is a pretty good starting point for writing a database in Haskell
19:42:06 <electron42> verement: ill take a look now
19:42:10 <Lokathor> right now i'm accessing two fields and then making them a tuple
19:42:14 <ReinH> that's exactly what we created it for
19:42:33 <EvanR> how does it ensure type safety?
19:42:34 <Lokathor> i just wanted to know if there's one that does the tupling for me, which.. i guess both is doing
19:42:58 <nshepperd> > both view (_2, _1) (40, 45)
19:43:01 <lambdabot>  (45,40)
19:43:21 <electron42> verement: that's closer to what i'm talking about, although that does require a database 
19:43:34 <Lokathor> neato
19:43:59 <EvanR> there are also other backends that arent SQL
19:44:15 <EvanR> redis... db-of-the-week
19:44:40 <ReinH> Maybe we should come up with a name for these not SQL databases.
19:44:47 <electron42> haha
19:44:59 <electron42> i just want to store my application state :P
19:45:06 <EvanR> probably useless, who would use "not SQL" as a single design criteria
19:45:13 <electron42> haha
19:45:19 <ReinH> It sounds silly when you put it that way
19:45:21 <verement> electron42: not sure what your concern is re: database
19:45:35 <nshepperd> . o O (selling nonapples)
19:45:53 <EvanR> electron42: im thinking sqlite-simple for typical applications
19:46:11 * dmj` mutters something about acid-state
19:46:23 <electron42> writing idiomatic code in a modern language like haskell
19:46:25 * glguy wonders if dmj` muttered anything good
19:46:26 <EvanR> or acid-state though the safecopy stuff...
19:46:45 <electron42> means that when you serialize your data structure, it doesn't map onto a sql database nicely
19:46:47 * dmj` wonders as well
19:46:49 <EvanR> acid-state is not what i call idiomatic haskell :(
19:47:01 <glguy> EvanR: Is it NoIdiomatic?
19:47:14 <Lokathor> what's not idiomatic about it?
19:47:17 <EvanR> IdiNomadic
19:47:21 <nshepperd> ofc maybe you could just give you machine a 100TB swap file, write idiomatic haskell assuming 100TB ram, and hope the kernel swapping algorithms are reasonable
19:47:30 <nshepperd> (plot twist: they're not)
19:47:37 <electron42> haha
19:47:40 <ReinH> nshepperd: that... sounds terrible
19:48:25 <electron42> so then SQL ends up either shaping your code in haskell (or whatever language) and whatever benefits you gain from using it
19:48:33 <EvanR> Lokathor: extensive TH, copying of data types to almost-the-same-but-version-number-plus-one...
19:48:34 <electron42> or you end up writing some kind of bulky translation layer
19:48:47 <electron42> all in all it seems like a waste
19:49:03 <ReinH> SQL is a pretty reasonable choice for a functional language to use as its interface to a storage system.
19:49:04 <nshepperd> oh no, i boxed a value; 1 MILLION CYCLES cache miss
19:49:13 <ReinH> It is a declarative, functional language after all.
19:50:09 <EvanR> electron42: however you manage to write your code to even have a state... you can run a thread to monitor for updates and save them behind the scenes
19:50:44 <verement> electron42: vcache doesn't use any SQL database; it uses LMDB as a transparent key-value store. You can write your own instances to serialize/deserialize any type.
19:51:16 <Lokathor> nshepperd, hmm, how do i use another lens before the "view both"
19:51:31 <ReinH> What are your goals? Durability? Atomicity? Performance?
19:51:54 <Lokathor> like, "view world g" gets the dungeon, and then "both view (dWidth,dHeight)" goes dungeon to result, but i'm not sure how you compose them
19:52:00 <dmj`> acid-state seems good enough for hackage..
19:54:46 <nshepperd> Lokathor: good question. 'view both (x, y) . view z' isn't very appealing
19:55:21 <ReinH> view both (x . z, y . z)
19:55:49 <EvanR> both suggestions violate DRY :)
19:56:44 <Lokathor> mmm
19:56:52 <Lokathor> uncomfortable
19:56:59 <Lokathor> also the latter seems to not compile
19:57:02 <Lokathor> or i wrote it wrong
19:57:38 <Lokathor> i wrote it wrong
20:00:10 <EvanR> interesting, class Serial from bytes package
20:01:02 <EvanR> is this pretty much like Binary and Cereal Serialize
20:01:38 <ReinH> I probably wrote it wrong
20:01:44 <Lokathor> naw i did
20:02:02 <Lokathor> pain point: view both and both view are each syntatically valid on their own
20:02:08 <ReinH> heh
20:02:16 <Lokathor> so the type error just keeps getting crazier if you mix them up
20:02:35 <ReinH> you could write a lens for the tuple
20:03:48 <EvanR> trying arena now for my current mad science experiment
20:05:28 <nshepperd> there should be a way to combine two Getters into one
20:05:42 <nshepperd> even if it's illegal for tuples
20:08:54 <c_wraith> there...  sort of is
20:09:24 <c_wraith> > (1, 2) ^.. _1 <> _2
20:09:26 <lambdabot>  error:
20:09:26 <lambdabot>      • Couldn't match expected type ‘[t]’
20:09:26 <lambdabot>                    with actual type ‘(a0 -> f0 b0) -> s0 -> f0 t0’
20:09:33 <c_wraith> > (1, 2) ^.. (_1 <> _2)
20:09:35 <lambdabot>  [1,2]
20:09:56 <c_wraith> it only works as a getter, though..
20:10:19 <glguy> Fold
20:11:24 <c_wraith> err, yes
20:12:37 <`Guest00000> how do i call the invertion combinator of type (C a b => (a -> b) -> (b -> a)): `invert` or `inverse`?
20:13:34 <c_wraith> usually that'd be `converse`
20:14:08 <c_wraith> well, no.  It could be inverse, if that's what it actually does
20:14:23 <`Guest00000> really it inverts the function
20:17:23 <Lokathor> guhh
20:17:31 <Lokathor> composing the lens library is not for the faint
20:17:58 <glguy> The best course of action is not to try and do everything at once
20:18:23 <glguy> let d = view whatever c in (view thisthat d, view theother d) etc
20:18:31 <Lokathor> so i want a tuple that's held within the first element of a list
20:18:40 <Lokathor> but it seems that sticking a list into the mix makes it crazy hard
20:20:23 <c_wraith> what's the type you have and the desired type?
20:21:50 <Lokathor> uh
20:22:25 <Lokathor> GameState holds a Dungeon holds a [Creature] and I want the (Int,Int) inside the first Creature of that list
20:23:57 <`Guest00000> getTuple . head . getCreatureList . getDungeon :: GameState -> (Int,Int)
20:24:07 <`Guest00000> omg
20:24:10 <mnoonan_> `Guest00000: I’d name it with the verb since your combinator is doing a thing to its input. like “let inverse = invert f”.
20:24:24 <`Guest00000> i just realized that this chat is Literal Haskell
20:24:27 <boj> Lokathor: this is completely unrelated to your lens questions, but have you considered looking into an entity component system for decoupling how you track things?
20:24:39 <`Guest00000> wait
20:24:41 <`Guest00000> it isn't..
20:24:52 <`Guest00000> it's Literal Interactive Haskell
20:24:57 <`Guest00000> > "test"
20:24:59 <lambdabot>  "test"
20:25:22 <Lokathor> `Guest00000, :3 but anyway i need to update that value later, so being all optical about it is the point
20:25:40 <`Guest00000> ah sorry
20:25:48 <Lokathor> boj, i was told that ECS is not as cool in Haskell and I don't even know who to believe
20:25:50 <`Guest00000> i didn't notice you wrote both messages
20:25:54 <setre> I once saw in a video where the guy presenting used some tool to automatically :reload and :main in ghci. anyone happen to know it?
20:26:00 <boj> Lokathor: i have a terribly neglected example at https://github.com/uncannyworks/hack-slash
20:26:21 <glguy> Lokathor: write a lens for viewing the (Int,Int) from your creature and then use it like:  creatures . _head . creaturePairOfInts
20:26:30 <Lokathor> _head
20:26:31 <Lokathor> ah ha
20:26:38 <Lokathor> see there's just too many lenses to track
20:26:47 <glguy> Yeah, you'll never guess what _head does...
20:26:52 <boj> hmm, that is the first time i've heard it suggested it may not be a good fit for Haskell. i don't sit in the game channels though
20:27:34 <Lokathor> glguy, oh no a type mismatch :(
20:28:09 <glguy> Lokathor: Put some actual code on lpaste if you want things that are more likely to work
20:28:18 <glguy> error messages too if you generate them
20:28:28 <Lokathor> yeah okay
20:29:05 <EvanR> ReinH: hmm would there be any possibility of updating the data types stored in an arena
20:31:00 <edwardk> https://github.com/drathier/stack-overflow-import <- man haskell is behind the times
20:32:04 <Lokathor> http://lpaste.net/357025
20:32:10 <edwardk> maybe template haskell? *looks over at glguy*
20:32:38 <glguy> Lokathor: No, you can't use ^. with _head, there might not be a head element
20:32:47 <Lokathor> oh
20:32:59 <edwardk> > [1,2,3]^?traverse
20:33:01 <lambdabot>  Just 1
20:33:05 <edwardk> > [1,2,3]^?_head
20:33:08 <lambdabot>  Just 1
20:33:12 <edwardk> > []^?_head
20:33:14 <lambdabot>  Nothing
20:33:19 <glguy> Because edwardk insists that this view fallsback to Monoid instead of the user just using foldOf when that's what the user wants
20:33:29 <Lokathor> and then there's ^?! for when you're sure there's a head right
20:33:29 <edwardk> =P
20:33:35 <edwardk> Lokathor: yes
20:33:35 <glguy> and having view use a custom type with no Applicative instance
20:33:47 * glguy looks back over at edwardk :)
20:33:51 <edwardk> glguy seems surprisingly bitter about this fact =)
20:34:11 <Lokathor> how do i set along that lens path?
20:34:21 <edwardk> &
20:34:29 <edwardk> er
20:34:35 <glguy> & *and* .~
20:34:37 <edwardk> > [1,2,3] & _head .~ 3
20:34:40 <lambdabot>  [3,2,3]
20:34:47 <glguy> or 'set'
20:34:52 <edwardk> > [1,2,3] & traverse .~ 3
20:34:54 <lambdabot>  [3,3,3]
20:34:58 <glguy> > set _head 3 [1..3]
20:35:00 <lambdabot>  [3,2,3]
20:36:30 <nshepperd> there should be (Functor f, Contravariant f) => LensLike' f s a -> LensLike' f s b -> LensLike' f s (a,b)
20:37:01 <edwardk> :t alongside
20:37:02 <lambdabot> LensLike (Control.Lens.Internal.Getter.AlongsideLeft f b') s t a b -> LensLike (Control.Lens.Internal.Getter.AlongsideRight f t) s' t' a' b' -> LensLike f (s, s') (t, t') (a, a') (b, b')
20:37:04 <Lokathor> mmmm
20:37:06 <Lokathor> it doesn't like set
20:37:29 <nshepperd> hmmm
20:37:32 <edwardk> oh you want just for the getter not to view into the pair
20:37:44 <nshepperd> :t alongside _2 _1
20:37:46 <lambdabot> (Field1 s t' a' b, Functor f, Field2 s1 t a b1) => LensLike f (s1, s) (t, t') (a, a') (b1, b)
20:37:59 <glguy> Lokathor: We can't see your screen
20:38:07 <edwardk> :t runGetter $ (,) <$> Getter _2 <*> Getter _1 
20:38:09 <lambdabot> (Field1 s s a a, Field2 s s a1 a1, Functor f, Contravariant f) => ((a1, a) -> f (a1, a)) -> s -> f s
20:38:10 <Lokathor> i'm gettin there glguy
20:38:29 <Lokathor> half the time this nonsense is just a typo like the view both / both view thing
20:38:30 <nshepperd> ah
20:39:00 <edwardk> Getter packages up your getter into something that has all the instances you'd expect on s -> a
20:39:11 <Lokathor> http://lpaste.net/357027
20:39:12 <edwardk> Fold does the same for s -> [a]    etc
20:40:25 <edwardk> pLocPath = world . dCreatures . _head . cLocation isn't getting generalized
20:40:49 <Lokathor> :(
20:41:11 <Lokathor> i guess i could type it twice
20:41:16 <edwardk> Turn on NoMonoLocalBinds or NoMonomorphismRestriction (I forget which) or write a manual type signature
20:41:17 <glguy> add a type signature to pLocPath
20:41:19 <glguy> or an extra parameter
20:41:20 <edwardk> or repeat yourself
20:41:34 <nshepperd> > view (runGetter $ (,) <$> Getter _2 <*> Getter _1) (10, 20)
20:41:36 <lambdabot>  (20,10)
20:41:40 <Lokathor> NoMonomorphismRestriction does it
20:41:41 <glguy> pLocPath f = (world . dCreatures . _head . cLocation) f
20:41:42 <edwardk> or modify the code to use that thing once in a more way
20:41:43 <glguy> will do it
20:41:57 <Lokathor> oh neat
20:41:57 <nshepperd> sweet
20:42:20 <Lokathor> with the addition of lenses the game can now do ~exactly what it did before~
20:42:24 <Lokathor> but more functorally
20:42:29 <edwardk> > (10,20)^..(_2 <> _1)
20:42:31 <lambdabot>  [20,10]
20:42:43 <edwardk> ^- if you just need a list of results you can glue together folds with mappends
20:43:47 <Axman6> :o
20:44:02 <edwardk> Lokathor: the main thing the lens stuff gives you is a more consistent format for writing code that works with maps and records and json bibs and bobs, etc. for any one usecase you may not get much mileage out of it
20:44:27 <Lokathor> well that's fair
20:44:37 <Lokathor> i'll put that quote in my tutorial
20:45:33 <edwardk> go for it. i definitely don't claim that lens is better than everything on all fronts. its just better than most things on most fronts, except for comprehensible errors. there we suck.
20:47:05 <boj> many an hour wasted on lens errors :(
20:47:24 <Lokathor> if view both and both view didn't both typecheck :S
20:48:47 <edwardk> both view would be a damn mess
20:48:49 <edwardk> :t both view
20:48:50 <lambdabot> (MonadReader s f, Data.Bitraversable.Bitraversable r) => r (Getting b s b) (Getting b s b) -> f (r b b)
20:48:53 <edwardk> yep
20:49:05 <monochrom> You can do what Dennis Ritchie did. Ritchie claimed that C is the universal 2nd-best language. So you can try "lens is the universal 2nd-best library". :)
20:49:32 <nshepperd> > both view (_2, _1) (10, 20)
20:49:34 <lambdabot>  (20,10)
20:49:44 <edwardk> nshepperd++
20:50:20 <EvanR> cut [] = []; cut (x:xs) = [x]
20:50:25 <edwardk> nshepperd: looks like you have your combinator after all
20:50:36 <edwardk> cut = take 1
20:50:52 <EvanR> what about performance
20:51:27 <Axman6> every addition matters
20:51:33 <Axman6> #SaveOurCycles
20:51:53 <edwardk> EvanR: we've probably spent more time talking about it than the sum total of time it'll ever cost you in practice ;)
20:52:12 <edwardk> :t uncurry (both view)
20:52:14 <lambdabot> Data.Bitraversable.Bitraversable r => (r (Getting b s b) (Getting b s b), s) -> r b b
20:52:19 <nshepperd> I guess the type of 'both view' is overconstrained though
20:52:22 <edwardk> :t curry (both view)
20:52:24 <lambdabot> MonadReader s f => Getting b s b -> Getting b s b -> f (b, b)
20:52:38 <nshepperd> > both view (_1, _2) (6::Int, 'a')
20:52:40 <lambdabot>  error:
20:52:40 <edwardk> oh thats still not quite right
20:52:40 <lambdabot>      • Couldn't match type ‘Int’ with ‘Char’
20:52:40 <lambdabot>          arising from a functional dependency between:
20:52:55 <edwardk> nshepperd: sadly the types must align, like with the <> case
20:53:36 <nshepperd> I was hoping there should be something like the illegal "product of lenses" for a pure getter or fold
20:53:58 <edwardk> nshepperd: just through the Getter and Fold newtypes at present
20:53:58 <nshepperd> since the problem with the product of lenses was that you can put a different value back in
20:54:08 <edwardk> mainly because its a bit of a mess to manipulate the type of their contents, etc.
20:54:09 <Lokathor> edwardk, also you're the big bad of Haskell Quest; the "story" is that the evil C++ demon has bewitched you and made you attack the Haskell Kingdom
20:54:15 <Lokathor> like Kirby's Adventure for NES
20:54:26 <edwardk> hah
20:54:50 <edwardk> So I turned into a Troll?
20:55:11 <haskell_newbie> Hey folks, quick lambda calculus terminology check - are functions applied to arguments, or are arguments applied to functions?
20:55:25 <glguy> Functions are applied to arguments
20:55:43 <haskell_newbie> Okay, that's what I thought but saw it referenced the other way around somewhere. Fits with the paradigm I've got going properly, too
20:55:44 <haskell_newbie> Thanks!
20:55:46 <Lokathor> when i posted about the roguelike tutorial on /r/haskell someone made a joke about "edwardk s t a b s you with his Lens"
20:55:54 <edwardk> functions are applied to arguments. sometimes you might hear of arguments being passed to functions
20:55:55 <Lokathor> and i was hooked on the idea
20:56:00 <Axman6> I've seen the C++ edwardk has produced, it's horrific (really awesome, but horrific - definitely a "how the sausage is made" situation)
20:56:05 <pacak> I implemented some stuff used free alternative construction that gets executed on runtime into a reader functor (from Alt FooF x I'm getting st -> x). I also implemented exactly the same reader functor on compile time. Code wise it should be exactly the same and it works, but version created from free applicative works about 5 times slower because ghc optimizes second version much better. Is it possible to convince it to apply some of those optimizations on f
20:56:05 <haskell_newbie> edwardk: Right, yeah
20:57:00 <Lokathor> Axman6, my Haskell is just as sausagey
20:57:08 <edwardk> Axman6: its getting worse. i'm currently using simd registers as 256 (or 512) x 1 bit registers
20:57:22 <Axman6> D:
20:57:27 <edwardk> Axman6: then building up my bigger registers out of those so i can do circuit minimization on the result
20:57:28 <Lokathor> people tell me to stop writing C in haskell, i tell them to save the frames
20:57:33 <Axman6> so, we need much better SIMD support i GHC
20:57:51 <Axman6> edwardk: you're a madman
20:58:04 <Axman6> but I approve this insanity because #fast
20:58:44 <Axman6> I recently wrote some SIMD like code in Haskell, and really wanted to make it use SIMD, but not having support in the NCG makes it not worth the effort
20:59:00 <pacak> I have Thing that does a bunch of lookups [(String, a)], then composes those lookup results into a value, optimized version replaces lookup by name with (!!) and potentially with array index access. But it works slower :(
20:59:07 <arahael> edwardk: You compiling Haskell to C++, or what?
20:59:08 <Lokathor> I think that Rust has only mild SIMD at the moment as well
20:59:30 <edwardk> arahael: compiling something to c++, not sure quite what it is yet ;)
20:59:33 <Lokathor> pacak, if it's slower it's not really optimized well :P
20:59:43 <Axman6> the current code is able to process data one Word at a time, but it'd be great to do that 2 or 4 words at a time
20:59:58 <pacak> Lokathor: Thank you Captain Obvious.
21:00:05 <Lokathor> <3
21:00:09 <arahael> edwardk: Heh, so haskell-like, or are you referring to something totally different?
21:01:57 <Axman6> so, speaking of performance, I disassembled some Haskell code which was compiled with coverage info, the implementation of coverage is insane, it adds essentially hundreds of x++'s to each function call
21:02:14 <ReinH> EvanR: what do you mean?
21:03:26 <EvanR> you build up a database of type A with summary F
21:03:38 <EvanR> then decide to change A slightly
21:04:08 <Axman6> you get assembly which looks like http://lpaste.net/357028 - this is just the entry point of the function, each basic block also has the same stuff
21:04:21 <EvanR> is the data lost
21:04:26 <Axman6> yet another "how the sausage is made" situation
21:05:29 <ReinH> EvanR: you would want to start a new journal and then possibly migrate the previous journals somehow
21:05:39 <EvanR> i see
21:06:29 <EvanR> likewise, if you want a section kind of index, second arena i guess
21:06:43 <EvanR> ... 2nd kind of index
21:06:56 <pacak> edwardk: I'm trying to write a decoder of some binary data with following restriction - schema (field names and their relative positions) is only known on run time, I want to be able to reference fields by names and build decoders using Alternative-like interface. Are there any abstractions  you would recommend to look at?
21:07:31 <edwardk> arahael: currently something different. the zurihac talk i gave talks briefly about some issues with compiling haskell down to the kind of form i like though
21:07:38 <ReinH> yeah, if you modify the types of the data or the summary or such you wouldn't necessarily have backwards compatibility, although it might be possible if you do a good job of defining things in an extensible way.
21:07:58 <arahael> edwardk: If you have a transcript, I might fidn it interesting (even if it goes over my head)
21:08:31 <arahael> edwardk: I know that purescript (a non-strict version of haskell, effectively) compiles to C++, but it's not intended to be fast.
21:08:48 <Axman6> there's at least one video recording of the talk
21:09:03 <Axman6> (We didn't record ours sadly, it was better than the LambdaJam one)
21:09:21 <Lokathor> arahael, that's uh... purescript compiles to JS normally
21:09:25 <ReinH> EvanR: the two best options would be probably be extensibility or versioning
21:09:26 <EvanR> a non-non-strict version of haskell
21:09:26 <Lokathor> maybe you can do JS -> C++?
21:09:42 <paf31> There is a c++ backend
21:09:42 <EvanR> what do you mean by extensibility here?
21:09:45 <ReinH> or migrations. The three best options.
21:09:52 <arahael> Lokathor: There are purescript compilers that compile directly to C++.
21:09:57 <Lokathor> neato
21:10:00 <ReinH> EvanR: a data format that can be extended/changed without losing backwards compatibility
21:10:03 <arahael> Lokathor: Eg, pure11, pure14.
21:10:14 <Lokathor> read that as "purel" at first
21:10:20 <ReinH> Among the best options are such diverse choices as extensibility, versioning, migrations
21:10:30 <edwardk> arahael: https://www.youtube.com/watch?v=KzqNQMpRbac <- no transcript sorry
21:10:30 <paf31> Purerl also exists
21:10:41 <Lokathor> er, i mean the hand sanitizer
21:10:41 <paf31> It's an erlang backend
21:10:41 <EvanR> ok so serialize it yourself
21:10:44 <arahael> edwardk: Then I can't watch it, I'm afraid. :(  (I'm deaf)
21:11:00 <Axman6> :(
21:11:07 <Lokathor> that's a crazy amount of backends
21:11:15 <Axman6> It's a shame Youtube's automatic subtitling is so bad
21:11:17 <arahael> paf31: That's impressive. :)
21:11:21 <edwardk> arahael: ack! my wife sometimes writes up transcripts for my less technical talks but this one is probably a bit beyond her transcription capabilities
21:11:46 <paf31> They're separate projects, forked from the main compiler with their own packages
21:12:05 <arahael> paf31: Even so, it suggests that you've done well setting up an ecosystem.
21:12:12 <Lokathor> paf31, are they #fast?
21:12:17 <edwardk> pacak: maybe take a look at how optparse-applicative does a lot of its stuff
21:12:28 <paf31> I mean, probably not very fast
21:12:51 <paf31> But fast enough for certain types of things I suppose
21:13:00 <pacak> edwardk: Thanks, I'll have a look.
21:13:05 <ReinH> EvanR: the user is responsible for providing Serial instances for data and finalizer.
21:13:14 <EvanR> oh right
21:13:23 <paf31> I haven't used either very much though tbh
21:13:44 <nshepperd> > view (_2 ⬦ _1) (5, "hi")
21:13:46 <lambdabot>  ("hi",5)
21:13:51 <nshepperd> \o/
21:13:51 <Lokathor> before http://tinyurl.com/ycojb4eb after http://tinyurl.com/y9y6c7uu I think we can call this a win
21:13:52 <EvanR> next question, you seem to get all blocks back in a list. are you necessarily suppose to linearly scan through this list to find the stuff yourself looking for?
21:14:05 <EvanR> is there some ordering to the blocks returned that could help
21:14:41 <ReinH> Lokathor: The idea is that the summary can provide indexing information and etc to improve this
21:14:44 <haskell_newbie> Question: Are there situations other than cases where arguments are applied to themselves in which a lambda form may be divergent?
21:15:04 <Lokathor> i think you mean evy-boy
21:15:18 <ReinH> sorry
21:15:20 <nshepperd> :t (_2 ⬦ _1)
21:15:21 <lambdabot> (Field1 s b1 t b, Field2 s t2 t1 b2, Contravariant f, Functor f) => ((t1, t) -> f b3) -> s -> f t2
21:15:26 <EvanR> er yeah
21:15:55 <EvanR> you get like 1 level of BST search here
21:16:06 <ReinH> EvanR: Yeah, you're stuck with a linear scan, but you can use the summary/finalizer to store block headers with indexes, you can add other external indices
21:16:14 <EvanR> where binary means, however many blocks there are
21:16:52 <nshepperd> edwardk: see above ^^ but I used 'fmap absurd . contramap absurd' three times there, I feel like i should be able to golf it down
21:16:52 <EvanR> hmm so you could put the blocks in a tree
21:16:54 <ReinH> So you can use, e.g., edwardk's favorite semi-indexing strategy to figure out which chunk you need to actually read
21:17:14 <ReinH> the data is provided as an IO action, only the finalized header is already read into memory
21:17:41 <nshepperd> oh, only twice in the end
21:17:46 <EvanR> how does that work?
21:17:46 <nshepperd> i guess that's ok
21:17:56 <ReinH> EvanR: how does which work?
21:18:03 <EvanR> semi-indexing strategy
21:18:05 <electron42> sorry i had to bail there for a bit
21:18:11 <EvanR> does this get you out of the linear scan or
21:18:30 <edwardk> nshepperd: the main reason we don't offer such a combinator up in lens is because we have the more flexible Getter/Fold wrappers and re-associating, etc. becomes a pain with the (,)-restricted forms
21:18:35 <ReinH> EvanR: Well, if you're storing structured data then you can use a semi-index to figure out which chunk holds the part of the structure you care about
21:18:36 <electron42> i'm confused by how much of my application is "supposed to" be written in sql, particularly if i want to make use of a more siphisticated type system
21:18:37 <Lokathor> https://lokathor.gitbooks.io/using-haskell/content/roguelike/week-5-combat-+-gui.html
21:18:47 <electron42> sophisticated
21:18:50 <ReinH> EvanR: but also remember that the goal here is to eventually move the journals in the arena into layer-two storage
21:18:58 <Lokathor> partially complete week 5 of the tutorial, big lens go through so far mostly
21:19:20 <ReinH> EvanR: you aren't restricted to using accessData to, er, access the data.
21:19:26 <Axman6> electron42: I've been down the road of doing SQL like things in Haskell, and found it much more painful than just writing the SQL when the operation was easily written as a SQL query
21:19:32 <ReinH> That just provides convenient access to what the journal currently knows about
21:19:50 <EvanR> how do you access the chunks directly?
21:19:53 <ReinH> You control the serialization format, so the storage isn't opaque to you. You can read it back yourself.
21:19:58 <electron42> so then i want to build data structures which look like a relational database
21:20:10 <ReinH> accessData is for the chunks that are in the journal now.
21:20:17 <electron42> ?
21:20:19 <ReinH> Once stuff has moved to secondary storage, you can access it yourself
21:20:20 <edwardk> nshepperd: you can golf it down by using 'view' and 'to' of course
21:20:26 <nshepperd> (⬦) ga gb f s = let cast = fmap absurd . contramap absurd in ga (\a -> cast $ gb (\b -> cast $ f (a,b)) s) s
21:21:00 <Lokathor> edwardk, i'll note that this is the second talk of yours i've seen this year where there's a bait and switch
21:21:00 <ReinH> EvanR: the goal of accessData is to provide atomic access to the contents of the journal
21:21:09 <Lokathor> your poor audiences
21:21:09 <EvanR> ah i did not realize that
21:21:10 <nshepperd> but using 'view' forces the input lenses to a particular type
21:21:37 <edwardk> yeah
21:21:39 <EvanR> like, what is the filename used for the chunks on secondary storage?
21:21:40 <ReinH> EvanR: "When the summary indicates the correct amount of data has accumulated, the journal data is moved, as a block accompanied by its summary, to long-term storage."
21:22:02 <edwardk> f ⬦ g = runGetter <$> Getter f <*> Getter g   -- has the same problem
21:22:21 <edwardk> er... f ⬦ g = runGetter $ (,) <$> Getter f <*> Getter g   -- has the same problem
21:22:38 <edwardk> :t phantom
21:22:40 <lambdabot> error: Variable not in scope: phantom
21:22:40 <nshepperd> well, the version with Getter is rank 2, isn't it
21:22:48 <EvanR> also, is a chunk on disk FinalizedHeader followed by N serialized blocks?
21:22:49 <edwardk> :t Data.Functor.Contravariant.phantom
21:22:51 <lambdabot> (Contravariant f, Functor f) => f a -> f b
21:22:57 <edwardk> ^- that is your 'cast'
21:22:59 <nshepperd> ah, that's what i wanted
21:23:12 <EvanR> guess i should read the source
21:23:42 <nshepperd> but yeah, same problem
21:23:46 <ReinH> EvanR: Sorry, it's been a while since I've looked at it
21:25:09 <nshepperd> my ⬦ avoids that but it's true that even with that problem fixed it doesn't help much once you want to get 3 items out
21:25:12 <ReinH> EvanR: moving things to secondary storage is handled by internArenaFile
21:25:32 <nshepperd> > view (_3 ⬦ _2 ⬦ 1) (10, 11, 12)
21:25:32 <ReinH> EvanR: There could certainly be more documentation
21:25:34 <lambdabot>  error:
21:25:34 <lambdabot>      • Could not deduce (Num t0)
21:25:34 <lambdabot>        from the context: (Num
21:26:32 <ReinH> EvanR: The idea is that a good journaling system is an important primitive component of a lot of different database designs, and arena aims to solve that problem in as general a way as possible.
21:27:01 <ReinH> thus the user-configurable summary, finalization, interning policy, etc
21:27:18 <nshepperd> > view (_3 ⬦ _2 ⬦ _1) (10, 11, 12)
21:27:21 <lambdabot>  ((12,11),10)
21:27:23 <nshepperd> >.<
21:27:43 <EvanR> i see, when the summary looks like "done" the finalized header is written to a file "header" and every "piece of data" is serialized and written one-after-the-other to "data"
21:28:28 <EvanR> got it... 
21:28:34 <ReinH> Yeah, this is the process for moving a journal to secondary storage. It is summarized and atomically moved.
21:28:54 <ReinH> EvanR: most of your data retrieval will be from secondary storage, where you can do whatever you want
21:29:09 <ReinH> For atomic access to the current contents of the journal, there's accessData
21:29:29 <EvanR> so a higher level query would look at both
21:29:45 <ReinH> which is kind of annoying to work with on purpose, but will be a relatively small part of your overall query
21:29:56 <EvanR> the disk (by using some index, where does that come from) and the current journal
21:29:58 <ReinH> Yes, it would combine results from secondary storage with results from the journal.
21:30:29 <ReinH> you get to decide what indexing strategy you need, it's orthogonal to the journal
21:31:50 <EvanR> hold on... you addData 1 d at a time. but the journal has multiple sets of [d]'s ?
21:32:02 <ReinH> that is, the summary can be used for a variety of indexing needs, but is pretty much limited to indexes of the journal is a list of all the data written to it
21:32:07 <ReinH> sorry
21:32:08 <EvanR> a new [d] is created when s -> Bool becomes True ? or
21:32:10 <ReinH> I forgot to hit enter
21:32:26 <EvanR> or does it get moved when True
21:32:30 <ReinH> when s -> Bool becomes true, it gets moved
21:32:44 <EvanR> in which case, how do you get multiple things in the result of accessData
21:32:51 <ReinH> the journal is written to atomically on every addData.
21:33:03 <EvanR> yeah and that goes in which [d]
21:33:22 <ReinH> I'm not sure what [d] you're referring to
21:33:44 <EvanR> access data gives "the journal", a [(f,IO [d])]
21:33:56 <EvanR> but addData insets 1 d
21:34:06 <EvanR> so not sure where 2 levels of grouping is coming from
21:36:01 <EvanR> maybe thats the incremental history of every addData ?
21:36:28 <EvanR> and the IO gives you all the d's up to that point
21:36:51 <EvanR> and the f's are all the finalizations
21:37:18 <EvanR> like a scanl
21:38:49 <Lokathor> stop having the same length name as each other
21:39:07 <EvanR> at least you can index on the first char
21:40:25 <Lokathor> not from the corner of my eye :P
21:41:23 <EvanR> use audio clips to indicate who said what
21:41:53 <Lokathor> oh right
21:42:18 <EvanR> i want to be a frog sound
21:42:57 <Lokathor> http://www.rpgamer.com/games/chrono/ct/sounds/wav/croak.wav
21:43:38 <EvanR> i want a DSL for generating sound effects like that
21:44:15 <Lokathor> http://www.rpgamer.com/games/chrono/ct/sounds/wav/engage.wav ooh one of the fancy ones
21:44:49 <EvanR> godspeed
21:46:40 <ReinH> EvanR: sorry, there are multiple "datablocks". Each datablock maps to a file in the arena. The current datablock is a "persistent vector", clojure style, where the snocs are automatically persisted atomically. Previous datablocks are the finalized, "interned" journals. accessData gives access to the entire arena, including both previous, finalized datablocks and the current datablock.
21:47:05 <ReinH> The list is a list of summaries and IO actions for retrieving the data for that block.
21:47:12 <ReinH> well, "finalized" summaries.
21:47:16 <ReinH> sometimes the finalizer is just id
21:48:18 <ReinH> It's possible that another structure would be better than a list, but a list was good enough for our use case.
21:48:31 <ReinH> traversing the list is pretty cheap compared to reading in a block
21:48:55 <ReinH> Too many "automatically"s
21:49:21 <ReinH> EvanR: so the outer list is the datablocks and the inner list is the data in each block
21:49:35 <EvanR> which one is the current uninterned datablock, the first or the last?
21:49:40 <ReinH> the first
21:50:20 <EvanR> the current summary is accessible there?
21:50:34 <EvanR> which is where you could get the index
21:50:54 <EvanR> then skip ahead in the list
21:51:20 <EvanR> makes way more sense
21:51:24 <ReinH> Well, no.
21:51:30 <ReinH> The summary is made from the contents of that data.
21:51:54 <ReinH> the function d -> s that creates a summary from a datum is used and then the semigroup instance for s is used to combine them
21:52:07 <ReinH> you would need to manage a separate, secondary index to help you skip around
21:52:12 <ReinH> databases do this all the time
21:52:33 <EvanR> oh... and the s is computed from stuff only in that block? or all d ever
21:52:43 <ReinH> the s is computed only from that block
21:52:46 <ReinH> it is a summary of that block
21:53:04 <nshepperd> > view (paste [_3, _2, _1]) (1, 2, 3)
21:53:07 <lambdabot>  [3,2,1]
21:53:08 <ReinH> each addData does, essentially, summary <> makeSummary d
21:53:29 <EvanR> its amazing how little this system is accomplishing :)
21:53:33 <ReinH> EvanR: linear scans are often pretty good in practice though
21:53:39 <nshepperd> > view (paste [_3, _2, _1._Just]) (Just 1, 2, 3)
21:53:40 <ReinH> EvanR: yeah, amazing that our client paid for it at all ;)
21:53:41 <lambdabot>  [3,2,1]
21:53:45 <ReinH> Well, we also wrote a database with it.
21:53:48 <EvanR> hahahaa
21:53:56 <nshepperd> > view (paste [_3, _2, _1.traverse]) ("abc", 2, 3)
21:53:58 <lambdabot>  error:
21:53:58 <lambdabot>      • No instance for (Num Char) arising from the literal ‘2’
21:53:58 <lambdabot>      • In the expression: 2
21:54:13 <EvanR> i need more clients like this
21:54:20 <nshepperd> > view (paste [_3, _2, _1.traverse]) ([4,5,6], 2, 3)
21:54:21 <ReinH> EvanR: like I mentioned before, a solid journal is the basis for almost anything interesting you want to do in database systems
21:54:23 <lambdabot>  [3,2,4,3,2,5,3,2,6]
21:54:36 <EvanR> is it solid?
21:54:36 <ReinH> it doesn't need to do much, it just needs to be a rock solid journal
21:54:40 * nshepperd useless combinators
21:54:51 <ReinH> EvanR: it seems to be.
21:55:04 <ReinH> EvanR: I worked on it with an expert, who deserves all the credit for making it not suck.
21:55:47 <ReinH> EvanR: anyway, you'd be amazed what a linear scan of block headers can do.
21:56:03 <EvanR> yeah im not really worried about that
21:56:32 <EvanR> im just thinking, if i was electrons 100TB application
21:56:39 <EvanR> how would it work
21:57:08 <ReinH> It is incredibly unlikely to need access to all 100TB at the same speed.
21:57:21 <EvanR> thats fine
21:57:30 <ReinH> You can usually offload a bunch of stuff to tertiary storage.
21:57:33 <EvanR> as long as what i want is the fast one :)
21:57:35 <ReinH> and keep the arena lightweight
21:57:40 <ReinH> haha
21:58:05 <ReinH> well, when different things have different rates of change or access you often want to handle them differently
21:58:34 <EvanR> that brings up a good point... my RDBMs is continually growing with useless junk
21:58:47 <EvanR> im mostly only care about the latest stuff
21:59:04 <EvanR> but theres no built in way i know about that offloads old crap to tertiary storage that slows down
21:59:19 <EvanR> but i still have access in the same way
21:59:47 <ReinH> EvanR: you can also use arena as the basis of a write ahead log for a distributed state machine
22:00:15 <ReinH> if you were implementing raft or something like that
22:00:29 <ReinH> it's a pretty general-purpose journal
22:01:07 <ReinH> Well, a journal basically is a WAL.
22:01:08 * EvanR not a distributed guy
22:01:17 <ReinH> The thing a WAL writes to is the journal.
22:01:19 <EvanR> raft page looks nice graphically
22:03:22 <pavolzetor> if I have Vector (V3 Double)
22:03:39 <pavolzetor> is it going to unpack those V3 (linear package)?
22:04:32 <EvanR> no
22:05:01 <EvanR> each element of the Vector is a pointer to a box and 3 pointers to a box with 1 double in it
22:05:07 <pavolzetor> why not?
22:05:17 <EvanR> a box of 3 boxed doubles
22:05:22 <pavolzetor> I though linear will unpack 
22:05:46 <pavolzetor> as in source those fields are strick
22:05:47 <EvanR> let me see if there are RULES for that
22:05:47 <pavolzetor> t
22:06:10 <EvanR> ah, maybe GHC will auto unpack strict Double fields
22:06:17 <pavolzetor> I have productivity 90% on 1 core, on 4 cores it is 30%
22:06:43 <pavolzetor> and most time is spent in linear package
22:07:06 <ReinH> EvanR: Oh, one thing I forgot to mention is that the journal is often used as a recovery device (i.e., this is why a journaling filesystem is called that) rather than as the actual storage target.
22:07:11 <pavolzetor> I think in ghc 7.10 they changed it to default unpacking for small stuff
22:07:26 <ReinH> arena can serve as both, as long as a linear scan of headers is good enough for your retrieval needs.
22:07:38 <EvanR> pavolzetor: dont you want to use unboxed vector here? then it will be unboxed in both levels
22:07:50 <ReinH> (or something you can whip together with a secondary index)
22:08:01 <EvanR> yeah im sure
22:08:15 <EvanR> so this is on the level of acid-state
22:08:26 <EvanR> but allows data to leave memory
22:08:50 <pavolzetor> is there a simple way to autoderive Unbox instance?
22:09:05 <cocreature> there is a vector-th-unbox package iirc
22:09:13 <pavolzetor> for example I have data Face = Face !Int !Int !Int !Int
22:09:14 <EvanR> i dont know, but V3 is already unboxable
22:09:20 <pavolzetor> this shuld be trivial
22:09:33 <pavolzetor> hmm, maybe I can use V4 to represent Face
22:10:12 <ReinH> EvanR: This is, essentially, a write-ahead-log. You can use it directly to implement a simple database for some use cases, or you can use it to implement a redo log or undo/redo log or some other system that provides durability guarantees and failure recovery for a more complex database.
22:11:07 <ReinH> Oracle uses a WAL as a redo log, for example. They use a circular system, but otherwise it is very similar to arena.
22:11:17 <ReinH> Most databases do something similar.
22:12:17 * hackagebot papillon 0.1.0.4 – packrat parser – https://hackage.haskell.org/package/papillon
22:12:23 <pavolzetor> is there a way to check bandwidth?
22:12:51 <pavolzetor> I dont want to spent time unboxing and then it will turn out it is not the issue
22:13:02 <ReinH> We were fortunate in that our use case let us use arena more-or-less directly. Our client's database was append-only, relatively low query volume, etc. So we were able to essentially bold a retrieval system directly on top of arena.
22:13:22 <ReinH> For something more serious, you would use arena to implement only part of the system.
22:13:28 <ReinH> EvanR: does that make sense?
22:13:37 <ReinH> s/bold/bolt
22:14:15 <pavolzetor> another thing, I have N1 => MUT 145s, GC 14 s, but with N4 => MUT 82s, GC 144s
22:14:22 <EvanR> yes
22:14:32 <ReinH> If you are reading the database systems or distributed systems literature and something calls for a WAL (as many things do), you can probably use arena.
22:14:34 <pavolzetor> is there some guideline how to address that issue?
22:14:41 <EvanR> i am overwhelmed by what youd have to do to add the rest of an RDMS though
22:15:38 <ReinH> EvanR: Database Systems by Ullman is a good introduction.
22:16:20 <ReinH> Also yes, so am I.
22:21:10 <mbuf> Is there a way to re-write camel case naming in Haskell, including class names?
22:22:21 <ReinH> mbuf: re-write?
22:24:11 <mbuf> ReinH, or rename?
22:24:22 <ReinH> rename how?
22:27:34 <mbuf> ReinH, that is my question!
22:27:46 <ReinH> I don't know what you're taking about.
22:27:57 <mbuf> ReinH, instead of ByteString, can we use something like byte-string
22:28:08 <ReinH> Oh. No.
22:28:37 <ReinH> Well, camel case is a convention, but some things must start with capital letters and some must not.
22:28:45 <geekosaur> initial upper vs. lower case is baked into the language
22:29:09 <mbuf> is it possible to use some extension or meta-programming concept like macros
22:29:22 <mbuf> instead of ByteArrayAccess, if I could use byte-array-access, it is more readable
22:29:24 <nshepperd> you could write Byte_string, but then all the simons will cry
22:29:39 <mbuf> okay :)
22:29:41 <ReinH> No. You should get used to the conventional names.
22:29:52 <mbuf> ReinH, okay
22:29:53 <cocreature> technically you could use cpp but you really shouldn’t :)
22:30:01 <pacak> mbuf: You can use CPP
22:30:25 <geekosaur> original Bourne shell source ahoy! (macros for fake-Algol in C)
22:30:25 <ReinH> If you actually do this, I will find you and change it back.
22:30:49 <EvanR> How-About-HTTP-Headers
22:31:16 <mbuf> EvanR, better
22:31:19 <EvanR> in 4017 they will figure out how to write variables with spaces in their names
22:31:34 <ReinH> or mixfix without
22:31:47 <pacak> ͠B҉y̢t͝e͟Ar̸rayA͘cc̸ess̸
22:31:54 <cocreature> and in 5017 we’ll have gone back to sexprs
22:31:56 <pacak> Much more readable, no?
22:32:09 <EvanR> no we will no
22:32:17 <EvanR> i swear to god
22:32:48 <nshepperd> ssǝɔɔɐ-ʎɐɹɹɐ-ǝʇʎq
22:33:17 <nshepperd> {-# LANGUAGE AustralianHaskell #-}
22:33:17 <arahael> Haskell lets you use dots in names, doesn't it?
22:33:26 <arahael> nshepperd: That's upside down.
22:35:23 <monochrom> If in 5017 we'll use sexprs instead of being directly telepathic, that will be pretty pathetic.
22:36:02 <EvanR> nshepperd stop your leet hax
22:36:11 <EvanR> fix my monitor
22:36:40 <EvanR> (it looks exactly right in font iosevka)
22:38:35 <monochrom> {-# LANGUAGE llǝʞsɐHuɐᴉlɐɹʇsn∀ #-}
22:39:49 <nshepperd> :)
22:40:46 <mbuf> haha!
22:41:50 <XorSwap> programming via telepathy sounds awful, you'd get all kinds of stray thoughts in there
22:42:16 <monochrom> Don't worry, "you have to think in Russian".
22:42:41 <monochrom> (Cf. the movie called Firefox. That's right, not the web browser!)
22:42:51 <EvanR> 08:39 < nshepperd> :)
22:43:06 <EvanR> o_O
22:43:12 <EvanR> how did the mouse cause that
22:43:33 <nshepperd> good old middle click paste?
22:43:33 <monochrom> The mouse didn't. The cat did.
22:43:57 * EvanR tries to detect a middle mouse on macbook piece-of-glass
22:44:47 <nshepperd> i think macbooks use some sort of crazy multitouch scheme to imitate having multiple buttons
22:44:54 <geekosaur> ^
22:45:04 <geekosaur> especially if you have bettertouchtool or similar
22:46:57 <arahael> nshepperd: They do.
22:47:04 <arahael> Two-finger clicks.
22:47:23 <EvanR> the raft paper is interesting because it calls out paxos for "its proof of correctness is useless because no one can understand it"
22:47:39 <arahael> Err: For right-click, that is.  Not sure how to do a middle-click, I've never needed to do one on macos.
22:48:06 <EvanR> and im thinking... wait... are most correctness proofs useless because this issue doesnt come up, because the algorithm is understandable as is ?
22:48:40 <EvanR> not only have we proved it correct, the algorithm is pretty obvious, so good
22:48:41 <geekosaur> 3-finger, often
22:48:43 <EvanR> why even bother
22:49:34 <xylospongium> hi I have a question. Is anyone here familiar with the hs-glpk package?
22:49:35 <monochrom> Is that Leslie Lamport's Paxos and his proof?
22:49:57 <EvanR> yes
22:50:05 <cocreature> xylospongium: asking your question directly is probably going to give you a better answer unless you’re just interested in how many people use that package
22:50:20 <nshepperd> because no one can understand which part? you don't need to understand the actual proof normally, but you do need to understand the conclusion what is being proved
22:50:43 <nshepperd> that is, what even is correctness
22:50:58 <EvanR> their issue is the algorithm itself is incomprehensible, let alone teh proofs
22:51:16 <monochrom> I didn't read that one. But I read other Lamport proofs. They are different, but they are not "no one understands" unless in the same sense as "no one understands Haskell because I'm entrenched in imperative programming".
22:51:16 <xylospongium> ok, can you give me an example of how to use quickSolveLP in a do block? I can't figure out the syntax
22:51:20 <ReinH> EvanR: yeah, Raft is the There Has To Be A Better Way of consensus algorithms.
22:51:41 <ReinH> monochrom: paxos is a different beast
22:52:02 <monochrom> In fact the way I prefer proofs to be done, which I learned from my thesis supervisor, is also pretty close to Lamport's way.
22:52:49 <MarcelineVQ> monochrom: "its proof of correctness is useless because no one can understand it"   I think [it] is the algorithm not the proof
22:53:24 <monochrom> Ah, well, that's even more quaint then.
22:53:44 <monochrom> There was a time no one understood the AKS algorithm, either.
22:53:47 <MarcelineVQ> that's not how I read it at first, but EvanR's follow up makes it seem likely
22:54:15 <EvanR> yeah
22:54:23 <ReinH> distsys proofs are notoriously hard to understand
22:54:26 <monochrom> That time was short because people didn't whine, they learned.
22:54:44 <ReinH> some of it is strange notational choices, some of it is poorly specified models.
22:55:21 <EvanR> true i have no idea what paxos is like, and the paper here doesnt really going into detail
22:55:36 <EvanR> i am interested in the idea that proofs can be useless for some reason
22:56:10 <ReinH> I'd recommend trying ARIES before Paxos and FLP before Aries.
22:56:43 <arahael> EvanR: Proofs, which later are found to contain a mistake, are useless. ;)
22:56:50 <ReinH> ARIES is relevant too because we were just talking about undo/redo
22:57:17 <ReinH> and WAL
22:58:49 <ReinH> I'm not sure how to parse that sentence from the Raft paper but either way the Paxos algorithm is very complicated.
22:58:57 <monochrom> Proofs are useful or useless depending on your expectation.
22:59:15 <ReinH> And part of the problem with Paxos is that it's hard to know whether an implementation is correct.
22:59:29 <ReinH> Raft is much easier to implement correctly.
22:59:35 <monochrom> Sometimes you expect a proof to be intuitive. So you are disappointed at counterintuitive or very techincal proofs.
23:00:06 <ReinH> This is merely a practical concern, though.
23:00:08 <EvanR> a proof is just a program, the computer will spit out if its correct or not :)
23:00:31 <EvanR> but the subject matter, someone tells you its useless because... 
23:00:52 <monochrom> Sometimes you expect a proof to go the "A implies B, B implies C direction". So if I give you one in the "C because B, B because A" direction, you are disappointed.
23:01:24 <EvanR> i am not
23:01:40 <ReinH> your face is disappointed
23:01:45 <monochrom> Sometimes you expect a proof to be an essay. So if I give you equations and inequalities, you are disappointed.
23:02:31 <arahael> monochrom: implication isn't proof.
23:03:11 <arahael> (Or is it? I forget the supposedly-english jargon sometimes)
23:03:31 <shaleh> if one were to write a new network server/service today what networking layer is preferred? conduits? Old school 'import network'?
23:03:53 <monochrom> Well the more important point is: Did I say that implication is proof?
23:04:12 <nshepperd> i think that was shorthand for "[arguments] therefore A implies B; furthermore, [arguments] therefore B implies C"
23:04:29 <EvanR> shaleh: async is probably a must
23:04:59 <ReinH> shaleh: what sort of network service?
23:05:19 <nshepperd> or something
23:05:44 <EvanR> ReinH: its interesting because, the emphasis of this paper is like "proof shmoof... here is a better argument ... for how the algorithm even works"
23:06:14 <shaleh> ReinH: I have been out of Haskell for a while. To get back in I am writing simple stuff. Think chat server just because it has all of the same pieces
23:06:24 <shaleh> EvanR: thanks for the async pointer
23:06:32 <EvanR> a careful argument not of correctness but something else
23:06:55 <ReinH> I wouldn't write one from scratch at all.
23:07:06 <EvanR> it does claim to be equivalent to paxos though
23:07:20 <monochrom> I think it is written from scratch because it's just fingering exercise.
23:07:21 <cocreature> for learning purposes writing one from scratch is not so bad
23:07:35 <cocreature> in fact it’s a pretty decent exercise I would say
23:07:58 <monochrom> I even tell people to write their own id.
23:08:01 <ReinH> If I wanted to learn how to write a server I would go read warp's code.
23:08:05 <nshepperd> EvanR: providing an intuition for why something works is certainly a valuable function
23:08:24 <EvanR> yeah. i see a similarity to the json.org webpage
23:08:25 <nshepperd> EvanR: it's not like this is "better" than a proof though lol
23:08:33 <shaleh> ReinH: reading other code misses the learning of putting the pieces together
23:08:42 <EvanR> and conways construction of the surreals
23:08:47 <ReinH> yes, but it does help you know what the pieces are.
23:08:52 <monochrom> Why do we have to choose?
23:08:58 <ReinH> Which is sort of a prerequisite for putting them together.
23:08:58 <EvanR> "this is the whole spec"
23:09:17 <monochrom> Use your left brain and right eye to read warp. Use your right brain and left hand to write IRC.
23:09:25 <shaleh> ReinH: it also has the problem of trusting their choices. Did Warp make a good choice? How should I know? Or maybe it used libX because it was hot 5 years ago and now there are better toys
23:09:50 <ReinH> It certainly made better choices than someone who doesn't know how to write a server would.
23:10:04 <shaleh> last time I played with Haskell 'cabal sandbox' was the new hotness. Now we stack is.
23:10:22 <cocreature> well the goal is probably not to write a production ready webserver so just writing something and then gradually improving it is a reasonable thing to do
23:10:25 <monochrom> Oh wait JSON is given the designation ECMA-404?! 404?!
23:10:27 <shaleh> I have written servers in plenty of languages. The point is learning how to do it in Haskell. Which means learning API.
23:10:48 <cocreature> figuring out how to improve your code can be a better learning experience than just stealing the “right way” that somebody else figured out
23:11:03 <shaleh> cocreature: that is my experience as well.
23:11:04 <monochrom> So if I look for JSON on ECMA will I get a 404, literally? :)
23:11:21 <EvanR> lol
23:11:35 <cube_> hi, i'm looking for stuff connecting lambda calculus and natural languages.
23:12:35 * hackagebot OpenGLRaw 3.2.5.0 – A raw binding for the OpenGL graphics system – https://hackage.haskell.org/package/OpenGLRaw
23:12:35 * hackagebot monad-skeleton 0.1.4 – Monads of program skeleta – https://hackage.haskell.org/package/monad-skeleton
23:12:49 <cube_> cocreature: but is that not slower? at the extreme, reinventing all haskell would give you a mastery of the language but it would be terribly long, and not necessarily very uniform
23:13:35 <cube_> cocreature: however i just got here, i'm not sure what was said before
23:13:42 <shaleh> cube_: The key for me is not recreating hard to write servers. Just a simple login and send commands works me through command line parsing, config files, networking, async actions, etc.
23:13:55 <cocreature> cube_: ofc you can take that too far but up to a certain point I think it’s useful
23:14:36 <cocreature> cube_: it’s also not necessarily slower since the end results are different. if you just trust someone else what the right way to solve a problem is you don’t know why that is the right way or what problems and benefits other solutions have
23:15:32 <shaleh> my issue is I keep running into 3 - 5 year old blog posts talking about this "new" thing. And now there are new(er) things. It is hard to decide where to start.
23:15:52 <cube_> cocreature: can you really just copy paste code in haskell without learning how it works?
23:15:53 <ReinH> I'm not sure where folks are getting the idea that I would read the warp code and then shut my brain off.
23:16:15 <shaleh> ReinH: I never thought that was what you meant.
23:16:37 <EvanR> so is warp's code especially enlightening and well done?
23:16:40 <shaleh> ReinH: like I said, my issue is why would I have chosen Warp to read? What makes it a good choice and how would I know that?
23:17:03 <shaleh> how do I determine it is popular? Efficient? Well written?
23:17:13 <cocreature> I’m not saying that. but I think just starting to write something and then maybe look at other things to figure out how you can improve your code can be a more valuable experience than starting to look at the code of something and then reusing the same architecture
23:17:13 <ReinH> It's the highest performance haskell web server that I know of. It must be doing someting right.
23:17:17 <EvanR> this channel is the source of all subjective truth
23:17:23 <EvanR> the rest is up to you
23:17:32 <shaleh> other than "Gods Lens is insane (still)" I find looking for any consensus out there to be impossible
23:17:38 <srhb> It's also used as the default server in so many projects.
23:17:45 <srhb> That seems like a good reason to know about it, too.
23:17:53 <monochrom> No, lens is not insane, and has never been.
23:17:58 <EvanR> God's Lens ?
23:18:09 <davr0s> is there a shortcut for destructuring eg writing many functions that extract the same fields of a record
23:18:11 <pacak> Lens are not insane. They are big. Small bits are simple.
23:18:17 <cocreature> does god use profunctor lenses?
23:18:25 <srhb> I don't think we're talking about lens :-P
23:18:27 <ReinH> High performance IO-bound things in Haskell are hard to do right by trying something and then thinking really hard about why it is slow.
23:19:04 <ReinH> You will eventually make progress, perhaps, but having exemplars is much better.
23:19:17 <monochrom> davr0s: I don't understand. What do you mean?
23:19:23 <cube_> regarding lambda calculus, is there a channel for functional programming in general? or maybe the theoretical (but not completely math-only) side?
23:19:27 <shaleh> ReinH: agreed. I have been trying to find resources talking about this and stumble into the inconsistencies of blog posts. Most are random people writing down their experience learning something instead of people who are actually doing it.
23:20:52 <cube_> cocreature: i suppose in that case you may be right. i can't see myself copying the architecture of another project without first appropriating it, so i may be biaised
23:21:27 <ReinH> I also didn't suggest "reusing the same architecture".
23:21:33 <pacak> Speaking of theoretical stuff - what are some interesting blogs, podcasts, channels and other stuff you are following?
23:22:03 <ReinH> What I actually suggest is picking a fight with the code. Asking why it is the way it is and why it could not be some other way,
23:22:30 <srhb> shaleh: fpcomplete can be considered at least partially responsible for Warp, and they blog a lot about it and the surrounding ecosystem.
23:22:47 <srhb> shaleh: I know that's a boring suggestion, but... :-P
23:23:13 <shaleh> srhb: Nah. fpcomplete are reasonably trustworthy. If they are suggesting it then that is good to know.
23:23:40 <monochrom> Yeah, much better than randomly chosen blogs.
23:28:24 <pacak> I find fpcomplete blog rather useless...
23:28:57 <monochrom> How come?
23:29:21 <cube_> pacak: what would yourself recommend?
23:31:28 <pacak> monochrom: Looking at it right now, last 3 months.  Fancy stack features - not using stack and not planning to. Functional programming 101 - nothing new. Hiring. Whatever. Nodejs... Ugh.
23:31:52 <monochrom> Ah, that sense.
23:32:39 <monochrom> Because there are two senses. Do you want its topics? Does it do a topic justice, provided that it does that topic at all?
23:32:53 <shaleh> thanks all
23:34:15 <pimlu> is there a way to apply do notation to some other typeclass I make that implements return, >>=, and such?
23:34:25 <pacak> cube_: Oleg's stuff, Dan Piponi's blog, Neil Mitchell's blog (to some extent)
23:34:42 <pimlu> it really makes me sad that it sounds like you can't get monad-like behavior on Sets and Maps
23:34:58 <monochrom> I think yes. Go into GHC user's guide and look for Rebindable Syntax
23:35:41 <pacak> monochrom: It's not theory. It's company mostly PR.
23:35:59 <monochrom> It will be a rabbit hole and pandora's box and can of worm and 50 shades of grey and... but it exists.
23:37:34 <pimlu> aw that
23:37:41 <pimlu> that's great! thanks
23:37:56 <monochrom> pacak: I'm imaging that maybe it had good stuff, non-PR, the first three months, just because they had to pretend to be non-corrupt back then :)
23:39:09 <cube_> what's a monad behavior over sets and maps? you mean a bit like the list monad?
23:39:29 <monochrom> Yeah.
23:39:36 <peddie> pimlu: look for "restricted monad"
23:39:38 <monochrom> The Ord constraint does get into the way.
23:41:37 <pacak> monochrom: Nope. yesod as PR, web IDE as PR (they almost guessed with this one - atom is about as stupid as web ide, but for some reason it survived popular), 5 days haskell course and Foo in C++ as FP101.
23:44:00 <cocreature> I think you’re being a bit unfair. if you look at the last three months, there is a blogpost about unliftio, about problems with bracket and monad-control and about resourcet. I’d hardly call any of this company PR
23:44:15 <cocreature> (well not more than having a company blog in the first place)
23:45:11 <cube_> just read the rebinding syntax. does that mean that, to use Monad-based do syntax with that extension you have to specify the meaning of (>>), etc, every time after each do-block?
23:47:11 <cube_> btw is there an extension for multiline strings?
23:47:26 <cocreature> you don’t need an extension for that, it’s builtin
23:47:42 <cocreature> add a backslash at the end of the line and at the beginning of the next line
23:47:43 <nshepperd> cube_: no, it means it uses whatever (>>=) is in scope, instead of Control.Monad.>>=
23:48:29 <cube_> cocreature: will i have to add manually a newline though? and what about indentation?
23:50:07 <cocreature> indentation depends on where you place the backslashes and you will need to manually add a newline
23:50:30 <cocreature> there is no extension for anything else here but there are some packages which use TH to provide a slightly nicer syntax
23:51:58 <pacak> cocreature: Probably, but almost posts have word "stack" in first view sentences. It might contain some useful information, but it's company PR.
23:52:13 <pacak> *few
23:53:06 <cube_> nshepperd: hm... could i define all my Monad-do-blocks in one scope by just binding a big n-uple at the top-level of the file?
23:53:43 <cube_> cocreature: multiline strings: well it's a shame
23:54:26 <cocreature> pacak: dunno, would it be company PR if well-typed started their blogposts with “this blogpost is literate haskell and you can load it in ghci" because they work on ghc? that seems to be what the mentions of stack in most of the posts I mentioned are.
23:55:41 <cocreature> I’m not arguing that they’re not doing PR. a fair amount of their posts are PR but I think they have actual content too
23:56:09 <fearless_man> hello I'm trying to install the latest ghc-8.0.2 from http://downloads.haskell.org/~ghc/8.0.2/ for armv7. I've installed haskell-platform 7.6.3 on my phone using this debian emulator https://play.google.com/store/apps/details?id=com.gnuroot.debian, which doesn't have a ghci(interpreter). If I try to cross compile the latest 8.0.2 for armv7 to make it work for my android phone, is it worth the 
23:56:15 <fearless_man> effort? If I do try to cross compile it, where do I start? What are the gains I can have by having the latest 8.0.2 vs the haskell-platform 7.6.3. If I successfully cross compiled it, where do I put it in my phone? Thanks!
23:59:06 <nshepperd> cube_: you could just write your own (>>=), and your own return, seperately
23:59:20 <nshepperd> and uh, whatever other things are necessary
23:59:37 <nshepperd> or put this in a different module and import it
