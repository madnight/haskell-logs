00:22:48 * hackagebot cryptonite 0.24 ‚Äì Cryptography Primitives sink ‚Äì https://hackage.haskell.org/package/cryptonite
00:54:11 * hackagebot haskell-disque 0.0.1.0 ‚Äì Client library for the Disque datastore ‚Äì https://hackage.haskell.org/package/haskell-disque
01:15:28 * hackagebot haskell-disque 0.0.1.1 ‚Äì Client library for the Disque datastore ‚Äì https://hackage.haskell.org/package/haskell-disque
01:21:40 <fr33domlover> Hello! Q: My test suite uses the tasty-discover program. To make sure people have it installed when they run the tests, what's the best practice for ensuring it gets installed?
01:21:58 <fr33domlover> so I list it as a dependency package of the test suite?
01:22:02 <fr33domlover> *do I
01:37:19 <quick_dudley> I think you do, but I'm not entirely sure whether or not executable dependencies are fully supported
01:38:32 <fr33domlover> quick_dudley, I just checked in the tasty-discover stack template
01:38:46 <fr33domlover> It does list tasty-discover as a build-depends
01:38:51 <fr33domlover> so I guess they are :P
01:40:07 <hanna> yes, listing it as a dependency of the test suite is fine
01:40:29 <quick_dudley> Ok. If that's all it takes to get it to build correctly then I guess some of the GTK bindings need some attention: stack fails to build them unless you manually run "stack intall ..." to get a couple of executables first
02:05:55 <vktec> Is it possible to derive for everything apart from one constructor on a data declaration? One of my constructors takes a function, which isn't an instance of Eq, but all the other constructors should be fine and I'd rather not write code for each one myself if I can help it
02:08:59 <cocreature> vktec: that doesn‚Äôt make sense. you define an instance for a type not for a constructor
02:09:39 <cocreature> so you can‚Äôt even manually write an instance for everything but one constructor
02:09:45 <vktec> Ah, okay
02:11:03 <quick_dudley> You can just leave it out if you really want to; but 1: GHC will warn you; and 2: it's likely to crash your program
02:23:40 <hanna> vktec: what would YourConstructor f == YourConstructor g  return?
02:26:10 <riaqn> If I read/write file with System.Posix.IO, will I enjoy the green threads of Haskell?
02:26:32 <riaqn> namely, what will happen when I read from a blocking file descriptor?
02:27:53 <ongy> it will block the current thread, but others can still run (thread from haskell perspective, see forkIO)
02:30:03 <quick_dudley> ongy: some foreign calls block all threads in the program, even if they're started with forkIO. I'm just about to help riaqn check whether or not the System.Posix.IO functions do this
02:31:02 <cocreature> if you use the threaded runtime they shouldn‚Äôt block
02:31:16 <cocreature> block other threads I mean
02:31:28 <cocreature> if you don‚Äôt, they will block everything
02:31:46 <cocreature> riaqn: is there a reason why you want to use System.Posix.IO over the more standard IO functions in base?
02:33:06 <riaqn> cocreature: I'm using some low-level linux interface, where I specially needed to read/write once to represent a whole packet.
02:33:24 <riaqn> instead of buffering, as found in System.IO
02:33:32 <quick_dudley> If you're using the threaded runtime does blocking on a foreign call reduce the number of running system threads? If so: too many concurrent system calls would block everything but just one won't
02:33:32 <cocreature> ah ok
02:34:08 <cocreature> quick_dudley: afaik the threaded runtime will just spawn new (OS) threads for blocking foreign calls
02:34:20 <ongy> quick_dudley: afaik the depends on whether they are marked safe or unsafe
02:34:39 <riaqn> yeah, I prefer to do it in haskell way(green thread)
02:35:39 * hackagebot foundation 0.0.13 ‚Äì Alternative prelude with batteries and no dependencies ‚Äì https://hackage.haskell.org/package/foundation
02:38:08 <riaqn> I wonder if hGetBufSome uses buffering. https://hackage.haskell.org/package/base-4.9.0.0/docs/System-IO.html#v:hGetBufSome
02:41:02 <quick_dudley> The ghc manual on downloads.haskell.org isn't entirely clear on what happens if a foreign function that's marked unsafe blocks
02:41:19 <c_wraith> ezyang's blog is much clearer
02:41:32 <c_wraith> when an unsafe foreign function blocks, the entire HEC is blocked
02:41:39 <c_wraith> which means among other things, GC can't run
02:41:44 <c_wraith> Which means it can stall all threads
02:41:54 <c_wraith> hint: don't mark foreign calls unsafe.
02:42:16 <quick_dudley> Wasn't planning on it
02:43:28 <cocreature> don‚Äôt mark foreign calls that may block unsafe
02:43:36 <cocreature> things that return immediately are fine
02:43:49 <c_wraith> don't mark foreign calls as unsafe unless you know exactly what "unsafe" means.
02:44:31 <c_wraith> (and know that it's not broken for your use case, and that it actually helps for your use case)
02:44:59 <c_wraith> But the short version is just don't mark foreign calls as unsafe.
02:57:04 <riaqn> I noticed for some function in System.Posix explicit warning of blocking other user threads is provided. So I guess read/write is fine then.
03:06:29 <Gurkenglas> I wish you could eta-reduce "f xss = [g x xs | x : xs <- xss]".
03:12:39 <ph88> hello
03:15:15 <[exa]> Gurkenglas: isn't there a method to bend zipWith to do that?
03:16:11 <Gurkenglas> [exa], if I wanted to stop using list comprehensions there I could do something like "map (uncurry g) . mapMaybe uncons"
03:20:57 <[exa]> Gurkenglas: ok what about something like (>>= \x:xs -> return $ g x xs )
03:21:07 <[exa]> (just trying)
03:22:01 <Gurkenglas> :t (>>= \x:xs -> return $ g x xs ) -- you need to put (x:xs) in brackets
03:22:02 <lambdabot> error: parse error on input ‚Äò:‚Äô
03:22:42 <[exa]> >  (>>= \(x:xs) -> return (x,xs)) [[1,2,3],[1,2,3,4]]
03:22:44 <lambdabot>  [(1,[2,3]),(1,[2,3,4])]
03:23:34 <[exa]> (I imagine (,) replaced with g)
03:23:39 <Gurkenglas> > (>>= \(x:xs) -> return $ (curry show) x xs ) [[1,2,3],[]] -- you don't handle the empty list
03:23:41 <lambdabot>  ["(1,[2,3])"*Exception: <interactive>:3:6-42: Non-exhaustive patterns in lambda
03:24:51 <Gurkenglas> > map (\(x:xs) -> curry show x xs) [[1,2,3],[]] -- map fits more neatly
03:24:53 <lambdabot>  ["(1,[2,3])","*Exception: <interactive>:3:6-31: Non-exhaustive patterns in l...
03:25:32 <[exa]> hm list monad should have some guard for exceptions
03:25:41 <[exa]> it would be great if I remembered how it desugars
03:26:11 <quick_dudley> > let s [] = []; s (a:r) = (a,r) : map (\(b,r') -> (b,a:r')) (s r) in s [1 .. 4]
03:26:13 <lambdabot>  [(1,[2,3,4]),(2,[1,3,4]),(3,[1,2,4]),(4,[1,2,3])]
03:26:35 <Gurkenglas> > [map (\(x:xs) -> curry show x xs) [[1,2,3],[]]] -- Wrapping it in a list doesn't and shouldn't poof the errors
03:26:37 <lambdabot>  [["(1,[2,3])","*Exception: <interactive>:3:7-32: Non-exhaustive patterns in ...
03:27:29 <quick_dudley> It desugars to a case statement
03:28:19 <Gurkenglas> quick_dudley, not what I meant. The example implementation "f xss = [g x xs | x : xs <- xss]" is already functionally correct. I just want "f = [g x xs | x : xs]" syntax or something :3
03:29:01 <Gurkenglas> Maybe "f = \[g x xs | x : xs]" if it introduces too many ambiguities otherwise
03:33:14 <`Guest00000> i need to represent a lazy function which operates on non-homogeneous input stream (an infinite list with first element with a distinct type), returns the same stream type and outputs signal each time a new piece of input stream is needed. how do i do it best?
03:33:53 <`Guest00000> if it was just a regular stream, i could write: data Func = Func [Piece] (Piece -> Func)
03:34:04 <quick_dudley> "f = [g x xs | x : xs]" wouldn't really work because it doesn't specify where "x : xs" comes from, but the option with the lambda could work if someone made a ghc extension for it
03:35:33 <`Guest00000> but now first element has different type and Piece has to encode it, hence "first elements" can occur in middle of stream, hence this solution is bad
03:35:43 <[exa]> `Guest00000: how does it recognize that a new piece of input is needed? everytime it reads? or is there some flag the stream is "empty" ?
03:39:33 <`Guest00000> [exa]: it just decides on basis of values in input stream whether it needs a new value or it can output some more. i need the request to be explicit and encoded in the type
03:41:17 <[exa]> `Guest00000: data Func = FuncWantsMore  
03:41:19 <[exa]> oh sorry
03:41:38 <[exa]> `Guest00000: data Func = FuncWantsMore (internaldata) | FuncDoesntWantMore (internaldata)
03:41:49 <[exa]> oh a boolean flag?
03:41:52 <[exa]> *or
03:42:04 <`Guest00000> what is "internaldata"?
03:42:23 <[exa]> whatever description of the computation state you'd need
03:43:19 <`Guest00000> but i don't want to describe computation state
03:44:59 <`Guest00000> do you even describe computation state in haskell
03:45:09 <`Guest00000> explicitly
03:46:04 <[exa]> hmm I guess I read your question wrong (more about the 'lazy') --- you want a type-level distinction of elements that can be first?
03:46:45 <`Guest00000> yep
03:47:12 <`Guest00000> of elements that are first
03:49:36 <[exa]> Gurkenglas: well, you can just wrap the Piece in another type to make a "tag"
03:50:32 <Gurkenglas> [exa], you mean `Guest00000.
03:50:45 <[exa]> but then you'll need two alternatives for Func (one with first piece and one in the middle of the stream)
03:50:50 <[exa]> Gurkenglas: yes, sorry. :(
03:50:54 <[exa]> `Guest00000: ^^
03:51:20 <`Guest00000> [exa]: which stream? we have input and output
04:06:23 <`Guest00000> draft 1: crude solution, but it shows the needed structure: http://lpaste.net/356786
04:07:26 <`Guest00000> also, i don't know how to generalize over stream structure or arity
04:15:47 <[exa]> `Guest00000: generalizing over structures/arities with simple ADT's is hard, you will probably come to some kind of dependent types (there's a paper called "Faking it" that explains the whole problem)
04:16:25 <`Guest00000> but why dep types?
04:16:31 <`Guest00000> where does it come from
04:16:48 <`Guest00000> it's not like i ever need a type dependent on value
04:18:57 <`Guest00000> i mean
04:19:00 <`Guest00000> by generalizing
04:19:20 <`Guest00000> ignore ^
04:47:58 * hackagebot data-clist 0.1.2.0 ‚Äì Simple functional ring type. ‚Äì https://hackage.haskell.org/package/data-clist
05:01:21 <hanna> `Guest00000: I don't understand what your `F` or `N` are, or what your functions are supposed to be doing, or what ‚Äúa new piece of input stream‚Äù means, nor what ‚Äúfirst elements‚Äù means
05:01:43 <hanna> Can you pick a more illustrative example of the ultimate goal?
05:04:04 <quick_dudley> hanna: what he described earlier sounds like he wants to know how to write a function with a type like `(a,[r]) -> s`
05:13:52 <`Guest00000> hanna: F and N - types of first and next elements in the stream; functions are supposed to process the stream one input value at a time and decide whether they can output some values; a new piece of stream means a new value in the stream; first element means first value in stream
05:15:57 <`Guest00000> the goal is just lazily process streams which have first element with a different type, in a typed way
05:15:59 <hanna> in the monomorphic case that sounds like data Function i o = Request (i -> Function i o) | Return o (Function i o)
05:16:20 <hanna> and now you want the ability for the function to choose which type of ‚Äòi‚Äô it requires next?
05:16:37 <`Guest00000> not quite
05:16:43 <`Guest00000> 'i' just changes
05:16:57 <hanna> who changes ‚Äòi‚Äô and why?
05:17:06 <`Guest00000> after it takes I_F, it will then take I_N's
05:17:34 <hanna> so how is this different from (i_f -> Function i_n o) ?
05:18:28 <`Guest00000> where do i get i_n for a general structure?
05:18:38 <hanna> data Func i j o = InputFirst (i -> Func i j o) | InputNext (j -> Func i j o) | Output o (Func i j o) ?
05:18:50 <hanna> do you need to generalize this to more than two i/js?
05:19:21 <`Guest00000> hanna: input and output stream "types" are same 
05:20:34 <quick_dudley> `Guest00000: Is the output type the same type as the first value or the same type as the rest of the values?
05:20:57 <`Guest00000> quick_dudley: *stream* types
05:21:18 <`Guest00000> so the output stream too has a first and next element
05:21:38 <quick_dudley> Ok, let me think
05:23:15 <quick_dudley> data Func a r = Input (a -> Func r r) | Output r (Func a r)
05:23:20 <hanna> `Guest00000: hmm, so when your function takes an ‚Äòi‚Äô it returns an ‚Äòi‚Äô and then switches to the ‚Äòj‚Äô mode, and when it takes a ‚Äòj‚Äô it returns a ‚Äòj‚Äô and stays in ‚Äòj‚Äô mode - unless it wants to reset back to ‚Äòi‚Äô?
05:23:59 <`Guest00000> hanna: nope. just two independent modes for two streams
05:24:24 <hanna> now you're making less sense - you want to process to independent streams at the same time?
05:25:04 <`Guest00000> hanna: input and output streams
05:25:55 <hanna> so it can choose to swap between ‚Äòi‚Äô and ‚Äòj‚Äô for the input stream and it can choose to swap between ‚Äòi‚Äô and ‚Äòj‚Äô for the output stream?
05:26:01 <`Guest00000> data Func i j = Req (i -> Func N j) | Resp (j, Func i N)
05:26:16 <`Guest00000> i think it's the solution
05:26:47 <`Guest00000> for this exact structure and 1-arity
05:27:01 <quick_dudley> `Guest00000: where does the N come from?
05:27:10 <`Guest00000> it's constant
05:27:21 <`Guest00000> data N = ...
05:28:21 <`Guest00000> type Func1 = Func F F; data F = ... -- Func1 is the initial type
05:29:12 <quick_dudley> Ok, got it. The first input is i, the first output is j, then all the other inputs and outputs are N. Right?
05:29:28 <`Guest00000> yep
05:29:54 <hanna> ah
05:29:55 <quick_dudley> data Func i j = Req (i -> Func N j) | Resp (j, Func i N) -- will do that
05:32:33 <hanna> (although I somewhat question how you're going to work with these Func values)
06:31:53 <chrissound> Hello! I'm looking for a logger function to debug my custom layout functionality (doLayout). I've had a look at `XMonad.Hooks.DynamicLog` but this does not really seem like a 'logging' utillity. Is there any recommendations? Or do I just write to a tempory file?
06:35:37 <srhb> chrissound: If you're just debugging, you might want to try Debug.Trace.trace
06:35:40 <srhb> And friends.
06:37:55 <chrissound> srhb, Where would the output be shown though? 
06:38:40 <chrissound> I know to stdout, but I'm not sure where this goes with startx / xinit.
06:44:35 <Axman6> there are ways of redirecting al stdio, I can't remember where the functions are definied though
06:44:55 <Axman6> ie, you can capture all output from your own app within itself and redirect that to another handle
06:45:47 <Axman6> https://hackage.haskell.org/package/io-capture-1.0.0/docs/System-IO-Capture.html is one way
06:46:16 <Axman6> also https://hackage.haskell.org/package/silently-1.2.5/docs/System-IO-Silently.html
06:47:53 <Axman6> (for chrissound)
06:54:15 <chrissound> Oh that would be rather cool. Thanks!
06:58:33 * hackagebot tyro 0.3.0.0 ‚Äì Type derived JSON parsing using Aeson ‚Äì https://hackage.haskell.org/package/tyro
07:03:24 <ocramz> hai
07:03:55 <ocramz> is there a library for working with colors in hex triplet form?
07:05:32 <Axman6> hmm, I thought the colour package had that, let me see
07:05:55 <Axman6> https://hackage.haskell.org/package/colour-2.3.3/docs/Data-Colour-SRGB.html#v:sRGB24read
07:06:14 <ocramz> oh, right. Thanks Axman6 ^^
07:07:35 <Axman6> no worries
07:11:41 * hackagebot elenco-albero 1.0.0 ‚Äì make tree from a list ‚Äì https://hackage.haskell.org/package/elenco-albero
07:52:19 <kqr> what do you call the specific few input cases that trigger bad behaviour? there's a good noun
07:52:26 <kqr> maybe ends in -pathic
07:53:00 <zomg> A bug? :P
07:53:39 <kqr> pathological!
07:56:12 <zomg> hmm interesting :) I know what pathological is in context of say "a pathological liar" but didn't really make the connection
08:15:25 <kritzcreek> is running a Criterion benchmark and looking at the profiling output a good idea? Or does the measurement machinery skew the results too much?
08:25:59 <fosskers> Hi there, I'm having some trouble with TypeLits
08:26:06 <fosskers> http://lpaste.net/356797
08:26:28 <fosskers> The compiler tells me: Expected a type, but ëní has kind ëNatí
08:26:51 <fosskers> I'm probably missing something trivial that will fix this (some LANGUAGE pragma, I'm guessing)
08:30:19 <hanna> fosskers: need PolyKinds
08:30:36 <hanna> (n :: *) gets inferred otherwise
08:31:05 <fosskers> that seems to have done it. I'll go look up what that extension is
08:31:10 <mniip> polyKinds might be an overkill
08:31:11 <fosskers> thanks hanna
08:31:15 <mniip> try KindSignatures instead
08:31:17 <fosskers> haha
08:31:21 <hanna> it makes GHC infer type variables polymorphically by default
08:31:23 <mniip> and annotate the n
08:31:35 <fosskers> nope, same error with `KindSignatures`
08:31:42 <mniip> you do need to annotate the n
08:31:47 <hanna> did you add a kind signature? :)
08:31:49 <mniip> newtype (n :: Nat) a = ...
08:31:54 <mniip> oops
08:31:57 <mniip> newtype Foo (n :: Nat) a = ...
08:32:01 <fosskers> ah
08:32:29 <fosskers> that seems to do it
08:33:11 <fosskers> nice
08:33:28 <fosskers> Œª foo 1 :: Foo 7 Int
08:33:29 <fosskers> Foo {_foo = 1}
08:42:46 * hackagebot h2c 1.0.0 ‚Äì Bindings to Linux I2C with support for repeated-start transactions. ‚Äì https://hackage.haskell.org/package/h2c
09:07:22 <Axman6> kritzcreek: I would not be paying much attention to the benchmark results if profiling is turned on, it's a significant overhead
09:08:18 <kritzcreek> Axman6: I'm looking for allocation hotspots. But criterion cluttered the .prof file, so I'm running it without criterion now
09:09:07 <kritzcreek> but I fear I might be looking at outliers.
09:09:36 <kritzcreek> I'm not as good as criterion at making sure GHC reevaluates the same pure function every time ;)
09:14:09 * hackagebot bno055-haskell 0.1.0 ‚Äì Library for communication with the Bosch BNO055 orientation sensor ‚Äì https://hackage.haskell.org/package/bno055-haskell
09:19:06 <bno2> cool name
09:22:23 <EvanR> in 2007 hbc was still on par with ghc for performance https://web.archive.org/web/20070225070308/http://www.cse.unsw.edu.au/~dons/nobench/results.html
09:23:26 <EvanR> at least in situations where it could even compile and run the benchmark correctly
09:23:35 <srhb> That's the first I hear of hbc
09:23:39 <EvanR> me too
09:24:13 <EvanR> https://www.reddit.com/r/haskell/comments/42vcdf/why_is_haskell_ghc_so_darn_fast/cze2psg/
09:27:04 <srhb> Oh, it's augustss' compiler. Then I knew of it peripherally.
09:32:11 <EvanR> latest version is 0.9999.5c
09:32:21 <EvanR> supports haskell 98 supposedly
09:33:59 <hpc> i hear after version 1.0c programs compiled with it will have negative run time
09:34:48 <mniip> hpc, no they run in space
09:39:54 <monochrom> haha hpc
09:40:00 <monochrom> haha mniip too
09:40:23 <monochrom> "0.99999c" simply invites the obvious relativity jokes.
09:40:29 <monochrom> @quote monochrom faster
09:40:29 <lambdabot> monochrom says: einstein's theory implies that haskell cannot be faster than c
09:40:58 <hpc> oh good, that quote is still there
09:42:09 <Axman6> man, we never reference lambdabot quotes anymore
09:42:14 <hpc> @quote .cried.
09:42:14 <lambdabot> Ferdirand says: I was TA for a C++ programming course aimed at 1st year physics once. Some girl asked for help "i wrote pseudo-code but I cannot translate it to C++". Her pseudo-code was valid
09:42:14 <lambdabot> haskell. I cried.
09:42:17 <hpc> that one is my favorite
09:42:28 <Axman6> I feel like a part of our history is slowly dying by not doing it
09:42:37 <hpc> iirc it died off when the first round of majestic stereo quotes got removed
09:42:54 <hpc> and the @nixon thing put people off of messing around with the bot in general
09:42:55 <edwardk> bno2: it is a good thing the author chose to include -haskell in the package name to remove all doubt.
09:42:59 <Axman6> whaa, those were great
09:43:26 <hpc> @quote .stereo.
09:43:26 <lambdabot> shachaf says: I remember when I joined #haskell and everyone would @quote stereo.
09:43:34 <hpc> @quote .contrapun.
09:43:34 <lambdabot> monochrom says: Welcome to #haskell, where your questions are answered in contrapuntal fugues.
09:43:40 <hpc> oh good, that's still there
09:43:51 <Axman6> bno1: feeling obsolete?
09:46:50 <iqubic> So, I have a few packages that I installed into the global stack project. How can I tell intero and ghc-mod where the libraries are, so that I can get the red lines under the import statements to go away in emacs?
09:49:13 <Welkin> I used nix-shell to set up a shell with hakyll, but then when I tried to `cabal build` I got a linker error `ld: framework not found Cocoa`
09:49:21 <Welkin> is there something else I need to do (on macos)?
09:50:02 <iqubic> Well, actually, I have one project (XMonad) installed with my package manager, and the other project (Monky) is istalled in the global stack project.
09:50:14 <iqubic> Both have an executable and a library portion.
09:51:00 <kuribas> I had a brilliant (or crazy) idea: create parser combinators for recognizing patterns in images...
09:51:46 <iqubic> However, emacs doesn't know where the libraries are located, so I get red lines under the import statements for modules in those libraries.
09:52:07 <kuribas> iqubic: there is #haskell-emacs
09:52:25 <iqubic> I'l look into that.
09:53:18 <kuribas> For example, first decomposing an image into primitive shapes, then creating higher level parsers for recognizing combined shapes...
09:53:28 <kuribas> For example for music scores, technical documents...
09:53:39 <iqubic> For machine learning, or what?
09:53:56 <kuribas> no machine learning, it would be formally defined.
09:54:31 <kuribas> For example, a G-clef can be defined by a series of strokes on a paper.
09:55:10 <mniip> kuribas, how do you plan to make it not run in superexponential time
09:55:21 <kuribas> mniip: that's a good question :)
09:55:22 <mniip> 2^(megapixel) is a lot
09:55:35 <hpc> by making it run in ackermann time, of course
09:56:06 <kuribas> mniip: First collecting outlines, doing segmentation of shapes.
09:56:41 <kuribas> mniip: then perhaps a space structure to quickly search the space for close objects?
09:56:47 <mniip> unconditionally or with backtracking?
09:56:56 <kuribas> With backtracking
09:56:59 <mniip> hmm that's an interesting nuance
09:57:16 <mniip> image recognition with backtracking
09:57:19 <kuribas> Perhaps also scoring
09:57:53 <kuribas> mniip: only on the higher level objects though
09:59:20 <kuribas> mniip: But it could carry a probability of match.
10:01:29 <kuribas> mniip: for example, a staff would be 5 stafflines separated by a certain vertical space.  A staffline would be a long vertical line.
10:01:54 * mniip . o O ( a staff would be 5 klines )
10:02:14 <kuribas> What's a kline?
10:02:48 <kuribas> And the distance between the stafflines would be aprroximately the hight of a notehead.
10:03:01 <kuribas> These constraints could all be encoded in the combinators.
10:03:52 <mniip> that sounds very nice but can you do it fast?
10:04:07 <kuribas> mniip: yeah, that's the challenge.
10:05:07 * hackagebot eventstore 0.15.0.1 ‚Äì EventStore TCP Client ‚Äì https://hackage.haskell.org/package/eventstore
10:05:29 <kuribas> Maybe a kd-tree quad-tree to store the bounding boxes.
10:06:41 <mniip> !
10:06:51 <mniip> you could make a grammar on bitmaps
10:07:57 <kuribas> Well technically this would operate on a preprocessed image
10:09:18 <kuribas> Which is something I am implementing right now...
10:10:36 <kuribas> Good segmentation is kinda hard...
10:14:24 <kuribas> But if it works well, a parser could be a logical next step.
10:19:42 <Zemyla> Will GHC 8.2 include instances from Data.Functor.Classes for the types from GHC.Generics?
10:34:03 <edwardk> zemyla: surprised we dont have hem already
10:34:21 <edwardk> ryanglscott: ^-
10:35:09 <edwardk> pinging ryan as he tends to be the person who takes care of ghc.generics these days, and has done a ton towards fixing up missing instances
10:35:26 <edwardk> so if anyone would know the status it'd be him
10:39:48 <testing5> @pl (\f -> Just . (\x y -> f x y))
10:39:48 <lambdabot> (Just .)
10:40:33 <testing5> @pl (\f -> (\x y -> Just (f x y)))
10:40:33 <lambdabot> ((Just .) .)
10:41:31 <testing5> @pl ((Just .) .. f
10:41:31 <lambdabot> (line 1, column 13):
10:41:31 <lambdabot> unexpected '.'
10:41:31 <lambdabot> expecting operator
10:41:41 <testing5> @pl \ -> ((Just .) .. f
10:41:42 <lambdabot> (line 1, column 3):
10:41:42 <lambdabot> unexpected "-"
10:41:42 <lambdabot> expecting pattern
10:41:51 <testing5> @pl (\x y -> Just (f x y))
10:41:51 <lambdabot> (Just .) . f
10:52:10 <kuribas> :t curry (Just . uncurry f)
10:52:12 <lambdabot> (FromExpr a, Show b, Show a1) => a1 -> b -> Maybe a
11:21:07 <iqubic> How can I place Haskell Libs in a place that Intero and GHC-Mod can view them
11:21:08 <iqubic> ?
11:22:49 <andromeda-galaxy> If I have data Name = Name { ... } where some of the record fields have type synonyms in their types, will late running reify ''Name inside TH be guaranteed to not expand the type synonyms?
11:22:54 <andromeda-galaxy> Is there a workaround to be able to easily get Type C injectivity from https://ghc.haskell.org/trac/ghc/wiki/InjectiveTypeFamilies? GHC won't solve my type family constraints properly without it
11:22:58 <andromeda-galaxy> also, is there a way to use -XTypeApplications with record constructors?
11:32:35 <glguy> andromeda-galaxy: reify shouldn't expand type synonyms
11:32:53 <andromeda-galaxy> glguy: great, ty!
11:33:20 <glguy> andromeda-galaxy: Are you writing something new with TH or using something with TH?
11:33:29 <andromeda-galaxy> writing something new
11:33:37 <glguy> http://hackage.haskell.org/package/th-abstraction-0.2.3.0/docs/Language-Haskell-TH-Datatype.html
11:33:42 <glguy> Better than using reify directly
11:34:10 <glguy> and what I use for the TH code in lens
11:34:51 <andromeda-galaxy> wow, that is much nicer than the raw reify
11:34:53 <andromeda-galaxy> thanks for the pointer!
11:36:00 <glguy> and it includes operations like: resolveTypeSynonyms :: Type -> Q Type
11:36:55 <andromeda-galaxy> in this particular case I was hoping that type synonyms wouldn't be expanded - I was using them to tag the types of some record fields so that the TH could treat them differently.  But that definitely sounds useful generally!
11:48:14 <Lokathor> https://hackage.haskell.org/package/MonadRandom-0.5.1/docs/Control-Monad-Random-Class.html#t:MonadSplit
11:48:24 <Lokathor> why does MonadSplit say that you can't do anything with the two generators
11:48:37 <Lokathor> it seems like you can do anything with it that you could do with a normal generator?
11:52:39 <geekosaur> I think it means user code using MonadRandom would have to take extra steps to get a MonadRandom out of it
11:53:28 <geekosaur> and the MonadRandom interface can't really improve the experience using an explicit split like that. MonadInterleave plays better with the framework
11:54:18 <Lokathor> http://lpaste.net/356798 well this is my code right now, and i have a few other MonadRandom things
11:54:34 <Lokathor> and i'm wondering if i should rearrange the outer bits of this to make it also monadrandom
11:54:42 <Lokathor> i'm not sure how that would interact with the runST
12:04:08 <andromeda-galaxy> Is there a way to be able to write e.g. ''Name in a pattern?
12:05:08 * hackagebot word-wrap 0.1 ‚Äì A library for word-wrapping ‚Äì https://hackage.haskell.org/package/word-wrap
12:21:29 * hackagebot brick 0.20 ‚Äì A declarative terminal user interface library ‚Äì https://hackage.haskell.org/package/brick
12:32:16 <angryMonk> hi there!
12:32:28 <angryMonk> i stumbled upon this pretty sweet library.
12:33:10 <angryMonk> https://github.com/shiatsumat/compare-type
12:33:21 <angryMonk> anyone know of something similar?
12:40:30 <glguy> angryMonk: What use did you have in mind for that? http://hackage.haskell.org/package/singletons-2.2/docs/Data-Promotion-Prelude-Ord.html is similar
12:50:25 <GamboPango> I'm playing around with dependently typed programming and trying to do some stuff by hand.  One thing that I tried is to pass witness values for certain types implicitly.  However, I do not understand how the constraint solver works and my code does not compile.  http://lpaste.net/1236608130620588032 (49 lines)  Any help would be great!
12:51:26 * hackagebot data-diverse 0.8.0.0 ‚Äì Extensible records and polymorphic variants. ‚Äì https://hackage.haskell.org/package/data-diverse
12:56:25 <jollygood2> hi. i'm having some issues with readFile followed by writing to the file. i am getting "file alredy opened" exception
12:57:46 <dmj`> jollygood2: can you paste your code on lpaste.net for us
12:59:36 <jollygood2> moment, i'll write a short test case
13:02:04 <angryMonk> hey glguy, sorry about that. had to take a dump.
13:02:11 <angryMonk> you were saying about http://hackage.haskell.org/package/singletons-2.2/docs/Data-Promotion-Prelude-Ord.html?
13:02:35 <angryMonk> looking at the page right now, it's similar
13:02:40 <angryMonk> give me a sec
13:04:17 <angryMonk> huh. sweet. Thanks!
13:04:21 <angryMonk> glguy++
13:04:22 <athan> yeah core dumps are a pain
13:05:50 <jollygood2> dmj` hmm, I can't reproduce it. this works fine. http://lpaste.net/356801
13:06:37 <jollygood2> i thought it was because readFile leaves file descriptor hanging due to laziness, but I guess not?
13:07:04 <kuribas> What would you use to serialize haskell datatypes?  Xml or Jason?
13:07:16 <jollygood2> oh yeah, it happens if I remove putStrLn text
13:08:14 <jollygood2> here's the code and exception. http://lpaste.net/356802
13:08:23 <k0001_> kuribas: JSON serialization of Haskell datatypes is quite common and well supported nowadays, through `aeson`. But... it really depends on your needs.
13:08:49 <kuribas> k0001_: preferably cross platform
13:10:29 <kuribas> jollygood2: yes, readFile is lazy
13:10:50 <jollygood2> so how do i handle this?
13:10:59 <kuribas> jollygood2: what is the problem?
13:11:11 <jollygood2> here's the code and exception. http://lpaste.net/356802
13:11:34 <angryMonk> hi there! this might be a weird question but is it possible to make a type operator that doesn't care about the order of argument?
13:12:27 <geekosaur> angryMonk, not directly. you might look at some of the Nat-oriented ghc plugins on hackage though
13:12:54 <angryMonk> not directly? hmmmm
13:13:35 <kuribas> jollygood2: well, don't use lazy IO
13:14:51 <geekosaur> commutativity is not directly supported either at type or value level. compiler plugins can sometimes mitigate this by adding equality constraints for you (e.g. annotating a Foo :~~: Bar constraint with Bar :~~: Foo, which is the closest you can get to actual commutativity)
13:15:11 <EvanR> "actual commutativity" :)
13:15:11 <kuribas> jollygood2: lazy IO was probably a mistake
13:15:18 <jollygood2> what is non-lazy version of readFile
13:15:59 <EvanR> Data.ByteString.readFile
13:16:17 <angryMonk> thanks geekosaur!
13:16:30 <EvanR> commutativity depends on what = means
13:16:46 <dmj`> jollygood2: here is an explanation of why the file is locked, https://stackoverflow.com/a/5053188
13:16:50 <jollygood2> no version that returns String?
13:17:07 <dmj`> another solution is to use a temporary file
13:17:07 <EvanR> like, you could make a function or type function that is commutative according to different kinds of equality
13:17:15 <EvanR> but you cant enforce it in haskell
13:17:32 <dmj`> @package strict
13:17:32 <lambdabot> http://hackage.haskell.org/package/strict
13:18:01 <EvanR> jollygood2: String = [Char] so its probably bad to try this with String
13:18:21 <EvanR> see also Data.Text
13:18:55 <lambdamu> GamboPango: Hey I'm not immersed into the intricates of ghcs constraint handling either, but the possible fix mentioned in the error message, actually works, namely: add (GreaterThanI n2 m) to the context of the data constructor ‚ÄòGTbyMore‚Äô
13:19:34 <dmj`> jollygood2: if you want to use String, main = System.IO.Strict.readFile "foo.txt" >>= Prelude.writeFile "foo.txt"
13:19:57 <lambdamu> GamboPango: replace "GTbyMore :: GreaterThan n m -> GreaterThan ('S n) m" by "GTbyMore :: GreaterThanI n m => GreaterThan ('S n) m", adjust the rest of your code and it works
13:20:13 <dmj`> jollygood2: when you had the call to putStrLn it was forcing the contents in memory
13:20:25 <kuribas> jollygood2: you could use encoding to convert to/from string: https://hackage.haskell.org/package/encoding-0.8.1/docs/Data-Encoding.html
13:20:48 <EvanR> do you just want to copy a file? there is System.Directory.copyFile
13:21:18 <kuribas> jollygood2: also a string in haskell represents unicode text, not binary data
13:21:26 <kuribas> jollygood2: for binary data use ByteString
13:21:49 <jollygood2> i'm not dealing with binary data
13:22:16 <GamboPango> lambdamu: Can you explain why GHC cannot deduce the constraint without adding that context?
13:22:24 <jollygood2> dmj` yeah I think I got why it happens
13:22:40 <geekosaur> but are you dealing with utf8? because if not, it's effectively binary data and could get mangled otherwise
13:22:49 <jollygood2> I am
13:22:59 <geekosaur> well, more precisely: do the file contents match your set locale
13:23:34 <jollygood2> yes, I am getting expected characters
13:24:56 <kuribas> does readFile use the current locale?
13:25:29 <GamboPango> lambdamu: It seems like there should be a way to assert that in the case branch GTbyMore w, that w = gtWitness :: GreaterThan n' m
13:25:45 <duncan^>  /buffer 16
13:25:57 <EvanR> is there a canned response somewhere explaining the issues with String, ByteString, Text, encodings, laziness, efficiency, etc ?
13:26:36 <EvanR> io-laziness i should say
13:28:18 <kuribas> maybe this? http://www.alexeyshmalko.com/2015/haskell-string-types/
13:28:58 <lambdamu> GamboPango: Not really, but first of all im wondering why you are not getting overlapping instance warnings, but my rough thinking goes like that: You don't know from what instances declaration GreaterThanI n m from the context came, you can see by global analysis that when you pattern match on the corresponding gtWitness with the pattern GTByMore there is just one possible instance declaration, and it has the right constraint such that 
13:28:58 <lambdamu> GreaterThanI n' m where S n' ~ n could be derived, but GHC just doesn't do that kind of analysis
13:29:02 <kuribas> hm, not much information about lazy vs string bytestring.
13:29:15 <dmj`> EvanR: Appendix B of real world haskell had some info, and https://wiki.haskell.org/Performance
13:29:20 <geekosaur> kuribas, Handle I/O does, either you use the binary versions of things or you get decoding to String
13:29:21 <dmj`> has a Strings section
13:29:24 <GamboPango> lambdamu: I ended up adding {-# OVERLAPS #-} to the first instance
13:29:32 <cocreature> io lazyness and string types are mostly orthogonal issues
13:29:51 <EvanR> when, without reading anything, you use readFile, its not
13:30:04 <lambdamu> GamboPango: If you want to bring that instance in scope you have to capture it explicitly by a data constructor, that's all I can guess
13:30:14 <EvanR> i mean, when asking for help, you will immediately be explained String and lazy IO issues together
13:30:27 <EvanR> so i should include file-io in there
13:32:17 <EvanR> the blog post there does cover it all pretty much
13:33:04 <kuribas> Except that strict bytestring has constant time random access.
13:33:44 <kuribas> Which is kind of important.
13:34:09 <GamboPango> lambdamu: How would you do that?
13:34:23 <EvanR> does that really come up... that sounds more like Vector territory
13:34:29 <cocreature> bytestring is also pinned contrary to all the other types
13:34:32 <lambdamu> GamboPango: Like I said: replace "GTbyMore :: GreaterThan n m -> GreaterThan ('S n) m" by "GTbyMore :: GreaterThanI n m => GreaterThan ('S n) m", adjust the rest of your code and it works
13:34:33 <srhb> Do we run out of words if we need something that acts to kind as type does to value (or kind to type) or is there already precedence in the field?
13:34:35 <EvanR> ah yes, extend the post to talk about Vectors of Word8 :)
13:34:50 <srhb> Er
13:35:00 <dxtr> Are there any good resources for reading about error management?
13:35:07 <cocreature> srhb: sort?
13:35:11 <ahri> i want to use 'fromLeft' but don't understand which one i should use; it looks like it's available from Data.Either.(Combinators|Extra|Compat|Utils), Data.Strict.Either and just Extra... this is from using (g|h)oogle. i'm confused!
13:35:17 <srhb> cocreature: Is that the end of the line?
13:35:24 <dxtr> I've never quite understood how to properly deal with errors
13:35:32 <EvanR> what kind of errors
13:35:35 <cocreature> srhb: no, it‚Äôs turtles all the way down or rather types all the way up
13:35:37 <GamboPango> lambdamu: Oh, ok, I was confused about what you meant by "bring that instance in scope..."
13:35:50 <geekosaur> srhb, as I understand it there is little consistency in nomenclature above the level of kinds
13:35:52 <kuribas> EvanR: when you need to random access elements from a buffer read from a file?
13:35:54 <srhb> cocreature: Right, I'm just wondering how far convention has named the turtles ;-)
13:35:55 <dxtr> EvanR: Was a while since I looked at it, but I think I got stuck at exceptions
13:36:06 <cocreature> srhb: languages like Coq or Agda just use indices
13:36:08 <GamboPango> lambdamu: It does work as expected!
13:36:17 <srhb> cocreature: Yeah.
13:36:19 <jollygood2> while i understand why readFile fails the way it does, i am still not sure what the "right" way of dealing with this is. should i use strict module? or text, bytestring and converting it to String myself? I ever saw seq being recommended while searching this on google
13:36:24 <EvanR> kuribas: right.... now sounds like a parser
13:36:33 <srhb> geekosaur: It reminds me of the derivatives of distance wrt time
13:36:34 <lambdamu> GamboPango: If you have an instance it part of a data type constructor, you pattern match on it, then it is in scope in the case branch
13:36:38 <GamboPango> lambdamu: Thanks
13:36:46 <srhb> What do they go, yank and jerk after acceleration? Something like that.
13:36:53 <lambdamu> GamboPango: s/it part/as part/
13:36:59 <hpc> jollygood2: usually you open the file and use hGetLine :: Handle -> IO ByteString
13:37:02 <hpc> explicitly
13:37:04 <cocreature> srhb: I guess the usecase for languages that have a fixed number of hierarchies > 3 but not arbitrarely many is just very small
13:37:10 <EvanR> dxtr: exceptions in haskell is divided into IO-based exceptions see Control.Exception docs, and "pure exceptions" like Either e, ExceptT, Maybe
13:37:12 <cocreature> so people don‚Äôt bother coming up with names since you need indices anyway
13:37:23 <jollygood2> hpc won't that give me the same issue?
13:37:25 <hpc> or more likely for a ByteString, hGet
13:37:30 <srhb> cocreature: That's my thought as well. Which makes the first even being named sort of arbitrary, I suppose.
13:37:40 <ahri> i guess my question is: what's the canonical place to import 'fromLeft' or 'fromRight' from?
13:37:45 <EvanR> dxtr: and a third category is the error function, which simply crashes everything
13:37:55 <dxtr> right
13:38:06 <GamboPango> lambdamu: What was the last thing?
13:38:11 <geekosaur> ahri, there isn't a canonical one
13:38:18 <GamboPango> lambdamu: Oh nm
13:38:19 <jollygood2> brb
13:38:29 <geekosaur> I think most people just pattern match
13:38:42 <EvanR> so three different use cases
13:38:46 <EvanR> at least
13:38:47 <hpc> jollygood2: the issue of readFile is that the execution (actually reading from the file) happens based on evaluation (as in the "lazy evaluation" that is a haskell feature)
13:39:12 <hpc> jollygood2: with hGet, the execution happens immediately as part of the execution
13:39:37 <cocreature> one of my favorite things about protolude is that it calls "error" "panic" which is a way better name to indicate when you might want to use it
13:39:41 <hpc> the thing after it doesn't happen until the data is fully read from the file
13:40:23 <ahri> geekosaur: when i'm just using it to default a value, i feel like it's neater to use a function, which i could write with pattern matching, but then i may as well do the same with 'maybe', which is available in the default prelude... so there's that inconsistency :\
13:40:42 <geekosaur> :t either
13:40:44 <lambdabot> (a -> c) -> (b -> c) -> Either a b -> c
13:41:31 <ahri> hmm i didn't know about that one, thanks!
13:42:15 <hpc> ahri: there's a few others like that
13:42:17 <hpc> :t maybe
13:42:18 <lambdabot> b -> (a -> b) -> Maybe a -> b
13:42:38 <dmwit> Most types have catamorphisms, and generally with fairly predictable names -- just lowercase the type constructor.
13:42:42 <dmwit> And then there's foldr.
13:42:44 <hpc> ahri: as an exercise, i suggest looking at what it would look like for []
13:42:53 <hpc> dmwit: you ruined it lol
13:42:58 <dmwit> Oops. Spoilers.
13:43:00 <geekosaur> they mentioned maybe already, that's why I pointed at either
13:43:02 <geekosaur> :t bool
13:43:04 <lambdabot> a -> a -> Bool -> a
13:43:09 <hpc> oh, that's a better example
13:43:38 <hpc> bool is fun to think about as an infix operator
13:43:50 <hpc> (x ?? y) = \p -> if p then y else x
13:44:12 <EvanR> so, a 3-arg operator
13:44:24 <EvanR> now people think haskell is weird
13:44:42 <dmwit> (p??) = \(x, y) -> if p then x else y -- is the more traditional ternary operator
13:44:52 <geekosaur> people would then be confused because it doesn't work like C's ternary :p
13:45:32 <dmwit> I guess I could have written `p ?? (x, y) = ...`.
13:45:36 <hpc> dmwit: too bad you can't shoehorn (:) in there somewhere
13:45:40 <dmwit> That'll teach me to livecode.
13:45:55 <EvanR> i bet you can 
13:45:56 <geekosaur> dont give peop;e ideas :p
13:45:59 <EvanR> lol
13:46:02 <dmwit> data Pair a b = a :| b
13:46:10 <dmwit> p ?? x :| y = ...
13:46:21 <hpc> ooh
13:46:24 <EvanR> program C in any language
13:46:36 <hpc> p ?? (x:y:_) = if p then x else y
13:46:42 <EvanR> why two ? ?
13:46:43 <hpc> @let p ?? (x:y:_) = if p then x else y
13:46:44 <lambdabot>  Defined.
13:46:58 <hpc> > False ?? 1 : [2, 3, 4]
13:47:00 <lambdabot>  error:
13:47:00 <lambdabot>      Ambiguous occurrence ‚Äò??‚Äô
13:47:00 <lambdabot>      It could refer to either ‚ÄòLens.??‚Äô,
13:47:06 <hpc> nooooooooooooo!
13:47:07 <dmwit> hpc: Calling that one is a bit less natural, though, isn't it?
13:47:09 <hpc> @undefine
13:47:09 <lambdabot> Undefined.
13:47:22 <EvanR> use one ?
13:47:24 <EvanR> :t (?)
13:47:25 <dmwit> False ?? 1 : 2 : [] -- got that weird extra `: []`
13:47:25 <lambdabot> error: Variable not in scope: ?
13:47:38 <hpc> @let p ? (x:y:_) = if p then x else y
13:47:40 <lambdabot>  Defined.
13:47:42 <hpc> > False ? 1 : [2, 3, 4]
13:47:44 <lambdabot>  error:
13:47:44 <lambdabot>      ‚Ä¢ Ambiguous type variable ‚Äòa0‚Äô arising from a use of ‚Äòshow_M109753419474...
13:47:44 <lambdabot>        prevents the constraint ‚Äò(Show a0)‚Äô from being solved.
13:47:58 <dmwit> Guess who got the fixity wrong?
13:48:02 <axaysd> >
13:48:09 <hpc> dmwit: that's just because you're programming like a normal person
13:48:16 <dmwit> > False ? [1,2]
13:48:18 <lambdabot>  2
13:48:32 <EvanR> i think we have a new idiom
13:48:40 <axaysd> grep
13:48:44 <dmwit> :t let x ? ls = ls !! fromEnum x in (?)
13:48:45 * EvanR calls ruby people to brag
13:48:46 <lambdabot> Enum a1 => a1 -> [a] -> a
13:48:52 <hpc> @let infixr 4 ?
13:48:53 <lambdabot>  Defined.
13:48:56 <hpc> > False ? 1 : [2, 3, 4]
13:48:57 <dmwit> > let x ? ls = ls !! fromEnum x in False ? [1,2]
13:48:58 <lambdabot>  2
13:48:59 <lambdabot>  1
13:49:00 <hpc> nailed it
13:49:29 <EvanR> myBool ? [case1, case2] 
13:49:35 <EvanR> cant be denied
13:49:48 <hpc> no, you still write myBool ? case1 : case2
13:49:52 <hpc> but case1 and case2 are different types
13:49:54 <axaysd> > False ? 1: [2, 3, 4]
13:49:56 <lambdabot>  2
13:50:06 <EvanR> that... makes no sense
13:50:13 <axaysd> myBool ? [case1, case2]
13:50:27 <EvanR> axaysd: hello world
13:50:32 <axaysd> lol hi
13:50:35 <axaysd> im new to IRC
13:50:42 <EvanR> or are you
13:50:54 <axaysd> someone on HN said there's an ad-hoc expression eval bot here
13:51:14 <iqubic> There is.
13:51:16 <dmwit> Yep, that's lambdabot, who responded to your last query.
13:51:27 <iqubic> > someExpressionHere
13:51:29 <lambdabot>  error: Variable not in scope: someExpressionHere
13:51:36 <axaysd> >2+15
13:51:36 <dmwit> You need to include "> " at the beginning for it to know you want it to try running your code.
13:51:43 <dmwit> axaysd: one more space =)
13:51:45 <axaysd> > 2+15
13:51:47 <lambdabot>  17
13:51:55 <axaysd> oh
13:52:02 <hpc> you can also use it in PMs
13:52:07 <iqubic> Thank you for giving me permission to use lambdabot again, glguy.
13:52:19 <iqubic> I won't abuse it in public chat.
13:52:22 <hpc> to test things out before pasting them into a conversation (as i so aptly failed at doing above)
13:52:30 <axaysd> sorry how do I PM ?
13:52:35 <hpc> /query lambdabot
13:52:54 <iqubic> ./query lambdabot > someExpressionHere
13:52:59 <axaysd> aw yiss
13:53:02 <axaysd> nice
13:53:04 <axaysd> thanks !! 
13:53:13 <iqubic> anything after lambdabot is considered the input.
13:53:14 <hpc> iqubic: btw, i wrote what i did by typing "/ /query lambdabot"
13:53:36 <iqubic> Oh.
13:53:42 <hpc> might vary based on your client
13:54:09 <geekosaur> some clients need /say, some use //, some use / /, some dont support it at all
13:54:22 <hpc> if you use irssi, you can do all three
13:54:38 <EvanR> or the butterfly effect client
13:55:03 <iqubic> /query lambdabot
13:55:18 <iqubic> glirc only repsonds to /say
13:55:29 <iqubic> But this is off topic.
13:58:43 <iqubic> Is #emacs-haskell the right place to ask about haskell + emacs integration?
14:17:33 <orion> No, that would be very off-topic there.
14:20:53 <sepakorayl> is there an operator that composes a function to each function argument?
14:21:34 <EvanR> what is the type of that function
14:25:33 <sepakorayl> I am doing runMaybeT $ join $ (MaybeT . example) <$> (MaybeT . pure) a1 <*> (MaybeT . pure) a2 <*> (MaybeT . pure) a3
14:25:44 <sepakorayl> I thought I could perhaps cut some boilerplate
14:34:13 <Logio> :t on
14:34:15 <lambdabot> (b -> b -> c) -> (a -> b) -> a -> a -> c
14:36:33 <Logio> sepakorayl: ^ you can probably use that, but it quickly gets messy in other ways (you'll probably need binary-unary composition etc.)
14:38:07 <sepakorayl> mhm perhaps I can't get ri of this boilerplate
14:38:13 <Logio> though looking at your example there's most likely a better way to clean it up, but one which I can't find at this hour :P
14:39:07 <Tuplanolla> I don't see how it could be done either.
14:39:59 <Tuplanolla> The thing with `pure` is that each invocation takes the methods of the type class as an implicit argument, so complicated things may look deceivingly simple.
14:41:35 <sepakorayl> I am basically operating inside a writer monad and I have some maybe values. Example operates when all these are Just and possibly produces more errors in the writer monad
14:41:52 <Tuplanolla> @pl \ f -> f f -- I fall for its consequences about once a month.
14:41:53 <lambdabot> join id
14:45:26 <GamboPango> Is there a way to use cabal to install a local copy of the docs for packages I have already installed?
14:45:44 <iqubic> I too want to know this ^^^
14:46:00 <GamboPango> Or maybe: What is the best way to set up a local copy the docs for some package.
14:46:31 <iqubic> Yes that.
14:47:40 <sepakorayl> perhaps this is too simple for what it does
15:00:16 <EvanR> sepakorayl: you could define a custom monad/applicative which supports all the operations you want
15:00:18 <AWizzArd> https://en.wikibooks.org/wiki/Haskell/Traversable says that Foldable can‚Äôt be used to produce the effect of Traversal. Okay, true for the specified function deleteIfNegative x = if x < 0 then Nothing else Just x.
15:00:38 <EvanR> instead of manually using transformers
15:01:03 <AWizzArd> But one could have some other function, similar to deleteIfNegative, which can be used with fold to have a traverse effect.
15:01:09 <AWizzArd> So, what does this mean?
15:02:32 <sepakorayl> the problem is I want to be able to inspect maybe values but also write function that only work when all are just
15:03:11 <EvanR> sure
15:04:02 <EvanR> one of the operations of your monad/applicative is "exit early", and you can build on top of this an operation, getJust :: Maybe a -> m a
15:05:07 <EvanR> or whatever is more natural for your intended use case
15:10:19 <EvanR> actually free applicative might be a good way to go about implementing that monad/applicative
15:14:06 <EvanR> hrm... i know f <$> x = pure f <*> x, but what about f <$> pure x ?
15:15:08 <EvanR> is that irreducible
15:18:40 <geekosaur> isn't that pure (f x)?
15:18:53 <EvanR> i hope so... but then i was second guessing
15:19:37 <EvanR> if so, sepakorayl's example becomes this http://lpaste.net/356804
15:19:53 <EvanR> one pure instead of 3
15:20:28 <EvanR> sepakorayl: ^
15:25:47 * hackagebot data-diverse-lens 0.1.1.0 ‚Äì Isos & Lens for Data.Diverse.Many and Prisms for Data.Diverse.Which ‚Äì https://hackage.haskell.org/package/data-diverse-lens
15:25:47 * hackagebot data-diverse 0.8.1.0 ‚Äì Extensible records and polymorphic variants. ‚Äì https://hackage.haskell.org/package/data-diverse
15:38:12 <orion> Hi. I am using a servant for an API with a ReaderT threaded in to the handler. I want to call a function from my handler, but I am not sure what the type should be.
15:38:14 <orion> https://gist.github.com/centromere/893182ec22c6cc8ee950ed0f30cfcb34
15:38:29 <orion> Anyone know how to accomplish this goal?
15:39:24 <orion> When I tried this, I got an error: No instance for (Control.Monad.IO.Class.MonadIO Data.Functor.Identity.Identity) arising from a use of ‚ÄòliftIO‚Äô
15:40:40 <Tuplanolla> Turn off the mmr and try again, orion.
15:48:00 <orion> Tuplanolla: I know that MMR probably means "Monomorphism Restriction", but that's about it.
15:48:12 <Tuplanolla> @where mmr
15:48:12 <lambdabot> https://wiki.haskell.org/Monomorphism_restriction
15:48:56 <Tuplanolla> That should get you an inferred type, which you can then refine.
15:48:58 <quick_dudley> orion: liftIO only works if you have IO at the bottom of your transformer stack
15:51:34 <orion> quick_dudley: !!! You're right. I've changed my AppHandler type to be "ReaderT AppEnv IO", but now I am having trouble with the natural transformation.
15:53:57 <orion> let nt = generalizeNat C.. (runReaderTNat env) :: AppHandler :~> Handler <-- Couldn't match type ‚ÄòData.Functor.Identity.Identity‚Äô with ‚ÄòIO‚Äô Expected type: AppHandler :~> Handler Actual type: transformers-0.5.2.0:Control.Monad.Trans.Reader.ReaderT AppEnv Data.Functor.Identity.Identity :~> Handler
15:54:24 <orion> I must admit, I just copied/pasted that line of code from the Servent documentation. I have no idea how it works.
15:54:45 <orion> I do understand though that, in general, a natural transformation is when you go from m a -> n a
15:55:34 <quick_dudley> I admit I don't know exactly how to fix that error either: not familiar with servant
15:56:08 <orion> Thanks for pointing out that I didn't have IO in the stack though.
15:59:12 * hackagebot plot-light 0.1.0.0 ‚Äì A lightweight plotting library, exporting to SVG ‚Äì https://hackage.haskell.org/package/plot-light
16:00:19 <dmj`> orion: can you paste the  code
16:00:33 <dmj`> oh, you did:)
16:02:12 <orion> dmj`: Note that I have changed line 5 to be: type AppHandler = ReaderT AppEnv IO
16:02:31 <orion> And that helped, but the natural transformation is fairly mind-bending.
16:18:43 <unit73e> hey. are there any function documentation conventions with haddock? Or is it just plain common sense?
16:19:15 <unit73e> in java there's javadoc conventions for example
16:19:26 <quick_dudley> The user should be able to figure out what the function does by reading the haddock
16:19:32 <hpc> ^
16:19:37 <unit73e> thanks
16:19:44 <unit73e> so common sense :P
16:19:51 <unit73e> or good judgment
16:19:53 <hpc> there isn't a series of "thou shalt"s like having @author on every method or anything like that
16:20:00 <quick_dudley> Yeah, pretty much
16:20:06 <Tuplanolla> Just be consistent.
16:20:13 <EvanR> javadoc conventions?
16:20:38 <unit73e> yeah in Java you actually have a "thou shalt" start a getter with "Return <something>"
16:21:00 <EvanR> interesting, so conventions for the actual english text
16:21:25 <unit73e> yeap
16:21:28 <Tuplanolla> There's the choice whether you want to say "calculates the thing" or "calculate the thing".
16:21:38 <quick_dudley> Having learned javadoc by imitation: I have no idea which parts are actually in the spec and which parts are just how my teammates happened to do it.
16:22:01 <hpc> all haddock must be written in the third person with an unreliable narrator
16:22:26 <Tuplanolla> Must use royal we.
16:23:00 <unit73e> I'm just glad there's none of that non sense strict rules in haddock. I'll just copy some of the standard libraries documentation and that's pretty much it.
16:23:04 <EvanR> this has gotta be a conspiracy by java people to continue typing for as long as possible without having to think
16:23:18 <hpc> in my experience, you can get pretty far with just having a module overview followed by the (automatically added) type signatures of all your definitions
16:23:38 <hpc> to the point where in some of my acme packages, jokes have been ruined by automated spoilers
16:26:33 <unit73e> EvanR, I don't know what they were thinking but you end up having 'returns' duplicated lol
16:26:42 <quick_dudley> Some type signatures convey purpose more clearly than others
16:27:23 <EvanR> common sense in haddock is complicated by the fact that people disagree on whether "no explanation, just a type sig" is enough in different situations
16:27:46 <EvanR> a module wide introduction seems like it would make sense in all cases
16:27:47 <hpc> yeah, it's a context-sensitive issue
16:28:19 <unit73e> I say as long as people understand what modules and functions are supposed to do it's fine
16:28:32 <EvanR> and plenty of important libs dont have this
16:28:50 <EvanR> and "haskell docs suck" is an existing sentiment in the wild
16:28:51 <Tuplanolla> Just don't Henning it up.
16:28:52 <hpc> if you need documentation on print :: Show a => a -> IO () depends on if you know Show
16:29:35 <hpc> which is conveniently linked automatically, but for larger type signatures you need to know which of the dozen links to click and in what order to understand them
16:29:47 <EvanR> if you look at python docs, youll see 1.5 pages written in each function. might be another extreme.
16:30:11 <hpc> python has a habit of putting 1.5 modules worth of functionality into a single function though
16:30:44 <EvanR> heh... "this haskell function does too little to document"
16:31:06 <lamefun> Can a class of polymorphic types imply a class of monomorphic types? http://lpaste.net/2282965908861222912
16:31:15 <hpc> yeah, that's usually where i fall
16:32:20 <paulolieuthier> hi all, could someone please point me to a piece of documentation/explanation regarding performance cost of exception handling in haskell? thanks
16:32:33 <hpc> i have a habit of relating things to languages, so my module docs sometimes look like "this is the sub-language this module provides, below is a list of words"
16:33:37 <hpc> exceptions are pretty close to free when you're not throwing them
16:33:51 <hpc> if you're throwing enough of them to have performance cares, i don't know what to say
16:34:02 <Tuplanolla> How about "stop"?
16:34:12 <EvanR> i kind of want to see the performance cost of exceptions in C++
16:34:14 <hpc> you basically just pay for having the RTS in general, which if you can't pay that cost you can't use ghc ;)
16:34:40 <quick_dudley> lamefun: I think that would work if you used the right ghc extensions
16:34:54 <EvanR> good point, if exceptions are the ... exception rather than the rule, performance shouldnt be a problem
16:35:13 <lamefun> quick_dudley: GHC doesn't tell me which.
16:36:00 <hpc> what error do you get?
16:36:17 <quick_dudley> I'm thinking something like IncoherentInstances might do it. But I don't actually know
16:36:49 <lamefun> Illegal polymorphic type: forall a. Sequence (list a) ;  A constraint must be a monotype
16:37:05 <hpc> FlexibleConstraints maybe
16:37:24 <hpc> er, FlexibleContexts
16:37:50 <lamefun> Didn't help.
16:39:03 <hpc> IncoherentInstances definitely won't help here
16:39:24 <hpc> and even if it fixed your error, it probably still wouldn't help ;)
16:44:02 <lamefun> Is there another way or syntax?
16:44:45 <hpc> i think, reconsider what you're trying to do with that maybe
16:44:46 <quick_dudley> It does seem like something that should be possible but I don't know whether or not it actually is
16:45:46 * hackagebot penrose 0.1.0.0 ‚Äì A system that automatically visualize mathematics ‚Äì https://hackage.haskell.org/package/penrose
16:45:57 <EvanR> if the type variable is not used in the body of the type sig, how will ghc choose your instance?
16:46:19 <hpc> i think it wants for there to be exactly one instance, the most generic one
16:46:51 <EvanR> hijacking typeclasses for fun and profit
16:48:17 <lamefun> EvanR: I want that to just mean: "if (List list) then (Sequence list a) exists for every (a)".
16:48:46 <EvanR> instance exists for all types?
16:49:59 <lamefun> No, that if you see a type 'list' which is (List list), you can be sure that (Sequence list a) exists for any 'a'.
16:50:29 <EvanR> Sequence list a exists for any type a
16:50:37 <EvanR> not sure ive heard of such a thing
16:50:58 <EvanR> since instances are defined one by one, and never for all types at once
16:52:01 <lamefun> Wait, no, sorry.
16:52:31 <lamefun> If you see a type 'list' which is (List list), you can be sure that (Sequence (list a)) exists for any 'a', that's what I mean.
16:52:42 <EvanR> oh
16:52:50 <lamefun> I.e. Foldable that implies MonoFoldable.
16:53:07 <EvanR> so make Sequence an associated type of List ?
16:53:43 <lamefun> How would that help?
16:54:10 <EvanR> it reminds me of, if VectorSpace a, then you have some ScalarTypeFor a
16:54:34 <EvanR> but i see its slightly different
16:54:50 <EvanR> maybe you want, Sequence list instead of Sequence (list a)
16:54:56 <hpc> this sounds a bit like some hypothetical class (forall a. Monoid (f a)) => Alternative f
16:55:30 <hpc> where (<|>) = mappend
16:56:02 <lamefun> But if I do Sequence list, I'll have to make List a mono-class as well, which defeats the point.
16:56:24 <EvanR> a mono-class ?
16:56:34 <lamefun> a class of types with no parameters I mean
16:56:48 <hpc> i think you're trying to do too much with type classes
16:57:36 <hpc> if you do it the other way around, and try doing the class without constraints and then making connecting instances
16:57:40 <hpc> you overlap like crazy
16:57:42 <EvanR> how could Foldable imply MonoFoldable
16:58:12 <hpc> lamefun: how would you do what you are doing without type classes?
16:58:25 <lamefun> can't you implement MonoFoldable for all cases of Foldable (f a)
16:58:27 <EvanR> ah, MonoFoldable ... for all a
16:58:47 <EvanR> yeah sounds like a thing that wouldnt work
16:58:52 <EvanR> overlapping instances
16:59:52 * hackagebot plot-light 0.1.0.1 ‚Äì A lightweight plotting library, exporting to SVG ‚Äì https://hackage.haskell.org/package/plot-light
16:59:52 * hackagebot penrose 0.1.0.1 ‚Äì A system that automatically visualize mathematics ‚Äì https://hackage.haskell.org/package/penrose
17:05:01 * hackagebot penrose 0.1.0.2 ‚Äì A system that automatically visualize mathematics ‚Äì https://hackage.haskell.org/package/penrose
17:06:14 <EvanR> http://penrose.ink has a nice spinning graphic
17:21:31 <gnezdo> Anybody has suggestions how to code-golf this: http://lpaste.net/356810
17:22:33 <EvanR> optimizations might mean you dont need to do @ signs
17:22:49 <EvanR> you dont need two ` in a `f` b if you do f a b
17:24:09 <gnezdo> well, I didn't mean syntactical shortening :)
17:24:28 <gnezdo> probably some clever combinators can do it
17:24:31 <EvanR> its pretty idiomatic
17:24:35 <bno1> combine f a b = maybe b (\ja -> b >>= f ja) a
17:25:11 <bno1> i'm sure  that lambda can be simplified
17:25:18 <EvanR> :t \f a b -> maybe b (\ja -> b >>= f ja) a
17:25:19 <lambdabot> Monad m => (t -> a -> m a) -> Maybe t -> m a -> m a
17:25:29 <EvanR> @pl \f a b -> maybe b (\ja -> b >>= f ja) a
17:25:29 <lambdabot> flip . ap maybe . flip ((.) . (>>=))
17:26:05 <dyreshark> `combine f (Just a) (Just b) = Just (a `f` b); combine _ a b = a <|> b`?
17:26:09 <dyreshark> not as short as EvanR's, though
17:26:33 <bno1> wait, mine isn't not good because if b is Nothing it returns Nothing instead of a
17:26:39 <EvanR> if shortening isnt the goal... is using unreadable operators?
17:26:59 <EvanR> yes haskell can do that
17:27:21 <gnezdo> I was just wondering if I was missing something like liftA2 but that won't be what I wrote. Looks like there's no obvious nice way.
17:27:25 <geekosaur> is this supposed ti be haskell or apl? >.>
17:27:29 <bno1> code golfing pretty much means making it as short as possible, readable or not
17:28:17 <gnezdo> thanks y'all
17:28:22 * jmcarthur prefers golfing the number of tokens rather than the number of characters
17:28:24 <EvanR> after you write that code, then `combine' is the shortest way :)
17:30:26 <jmcarthur> Actually, maybe it would better charactize my preferred golfing style as optimizing the depth of the syntax tree when considering a series of associative operations to make their leaves children, or something like that.
17:30:59 <jmcarthur> So things like function composition don't increase the depth that much.
17:31:06 <bno1> or minimize the number of cycles your cpu needs to compile the program
17:31:49 <jmcarthur> Well, that's interesting, but not what I personally go for.
17:32:56 <dyreshark> it also optimizes for job security if used in a critical part of a very important program :)
17:34:28 <bno1> When I code gold I try to minimize the time I spend code golfing
17:34:47 <gnezdo> bno1: good one :)
17:44:08 <Lokathor> https://lokathor.gitbooks.io/using-haskell/content/roguelike/week-3-random-dungeons.html
17:44:43 <EvanR> i was looking at that earlier
17:46:21 <Tuplanolla> Is the choice of rng there just for exposition, Lokathor?
17:46:46 <Lokathor> the particular RNG used is because it's very easy to understand and high quality
17:47:19 <EvanR> so its aimed at people who are familiar with C++ and writing RNGs in it
17:47:23 <Lokathor> but choosing to go over how it all works is partly to just ramble on about seeing C code then converting it to Haskell code (a vital skill if you want to get on in the world)
17:47:52 <Lokathor> there's a video talk linked that explains the fine details of why it works
17:48:11 <EvanR> how to write C code in haskell :(
17:48:25 <EvanR> then, might be a better title
17:48:45 <Tuplanolla> George Marsaglia has written a lot about random number generators for statistical physics, which is very similar to the application here.
17:48:53 <Lokathor> it's an important skill to be able to look at C and write some Haskell. Most examples are in C, that's just life
17:49:24 <EvanR> most examples are in C ?
17:49:28 <Lokathor> or C++
17:49:45 <Lokathor> or Java/C# sometimes
17:50:08 <Lokathor> or Python, maybe Ruby
17:50:14 <Lokathor> just about anything that isn't Haskell really
17:50:38 <EvanR> true, most examples are not haskell
17:51:21 <jmcarthur> Man, I was thinking of making a simple roguelike just for kicks. Now I have to decide whether to read this (and other things about roguelikes) or to leave my creativity and design issues unspoiled to be solved by myself.
17:51:35 <MarcelineVQ> most examples I come across are non-specific psudocode, but surely more imperative than otherwise
17:52:10 <EvanR> specifically C examples of anything are going to be relatively oddball for not being able to return arrays
17:52:26 <Lokathor> jmcarthur, this tutorial is following in the steps of a (very bad) python tutorial that RL folks have been using as an intro for over a decade
17:52:49 <Lokathor> so, feel free to follow some tutorials that outline the general steps you might want to develop
17:52:54 <jmcarthur> Ah... well, perhaps this is even more the reason for me not to read it. I don't want to just do what everybody else is doing.
17:53:10 <jmcarthur> Not intentionally, at least.
17:53:27 <jmcarthur> So be it if I end up doing it anyway, but at least I discovered it on my own.
17:53:32 <Tuplanolla> It depends on what you mean by Rogue-like.
17:53:50 <EvanR> theres definitely some haskellisms to use in the roguelike domain
17:54:06 <MarcelineVQ> rogue as in permadeath dead, not rogue as in red leader
17:54:38 <Lokathor> funny you mention that MarcelineVQ , https://github.com/Lokathor/roguelike-tutorial-hs/blob/1b253dd03b86d85ff7cfbd391a9b6f3326604a16/app/Dungeon.hs#L154
17:54:41 <jmcarthur> Rogue: Die Hard
17:54:46 <MarcelineVQ> if someone makes that mistke though and creates a haskell rogue leader..
17:55:45 <MarcelineVQ> Lokathor: you're full of beans!
17:55:58 <iqubic> How do I run a stack progject?
17:56:09 <Lokathor> stack exec <binname>
17:56:24 <Lokathor> (stack exec game, if you mean this project)
17:56:34 <MarcelineVQ> iqubic: have you looked at the stack documentation? https://docs.haskellstack.org/en/stable/GUIDE/
17:58:17 <Lokathor> MarcelineVQ, beans?
17:58:35 <MarcelineVQ> you got moxy kid
17:59:01 <Lokathor> ah
17:59:38 <Lokathor> that and "Mission... accepted." are two of my favorite confirmation quotes
17:59:54 <Lokathor> though the latter is perhaps more obscure simply because it's only 2 words, which makes it hard to place
18:01:05 <MarcelineVQ> endless waltz?
18:01:12 <Lokathor> :OOOOO
18:04:11 <Welkin> gundam wing?
18:04:22 <Lokathor> yes to both
18:04:49 <Lokathor> Hiro uses the line several times in Wing, including at least once in Endless Waltz IIRC
19:40:23 <SrPx_> Hello. I'm making a DSL which is basically Œª-calculus + JSON and primitive JSON operations. I'm attempting to figure out the minimal set of primitive JSON operations needed not to miss anything. Is anything important missing here? http://lpaste.net/356813
19:41:18 <SrPx_> The number operations are quite obvious. For objects (string maps), I have just "get" and "gen", which generates a brand new map. I think those are enough to do anything that you could do with maps, right? On strings, I have just slice, concat and compare. I also think they are sufficient, right?
19:41:41 <SrPx_> When I say sufficient, I mean other operations could be implemented in terms of those without a significant loss of performance.
19:44:56 <raynold> ahh it's a wonderful day :-)
19:45:27 <SrPx_> what ):
19:46:16 <iqubic> So I have a project that I have built with stack.
19:46:41 <iqubic> And I get this output when trying to run it:
19:46:48 <iqubic> Warning (added by new or init): Specified resolver could not satisfy all dependencies. Some external packages have been added as dependencies.
19:47:01 <iqubic> you can suppress this message by removing it from stack.yaml
19:47:19 <iqubic> And then the project procceeds to run as normal.
19:47:30 <iqubic> Why is that message showing up?
19:48:04 <iqubic> Wait, I see.
19:48:13 <iqubic> I just had to read the actual error
19:56:46 <iqubic> Is there a way to take a haskell program installed via stack, and run it in a script?
19:57:28 <iqubic> I have installed monky via stack, and now I need to create a script that will pipe the text output to a dzen bar.
19:59:10 <iqubic> I can just do "executeMonkyCommand | dzen --argsHere" except I don't know what the executeMonkyCommand should be, since the way I run monky is "cd monky; stack exec monky" when in the home directory.
19:59:21 <iqubic> I'm not sure that will work for this circumstance.
19:59:57 <geekosaur> it should
20:00:11 <geekosaur> (cd monky; stack exec monky) | dzen ...
20:01:06 <quick_dudley> stack install will put the executable somewhere that other scripts can find it
20:01:11 <iqubic> Oh. Is that the prefered way to use haskell programs in a script.
20:01:22 <geekosaur> generally, yes
20:01:47 <quick_dudley> If you don't want it generally available you can run "stack build" and at the end of the output it tells you where it is.
20:01:52 <iqubic> quick_dudley: it appears to be sitting in ~/.local/bin
20:02:01 <iqubic> Which is in my path.
20:02:14 <iqubic> So I should be able to just call monky directly.
20:02:36 <quick_dudley> Yes, that's where it goes in Linux. I can't remember what the Windows version does but it's somewhere on the path
20:03:12 <iqubic> I don't use windows.
20:03:27 <iqubic> And I can indeed just run monky in a script.
20:03:37 <iqubic> So that solves my issues there.
20:04:22 <iqubic> So, since the config file and the library modules are in different places, Emacs' ghc-mod can't figure out where the monky libs are. Therefore it flags any monky lib with a red squiqqly line under the word import in those lines.
20:04:35 <iqubic> That is my next issue.
20:04:47 <Welkin> monky?
20:05:05 <iqubic> @hackage monky
20:05:06 <lambdabot> http://hackage.haskell.org/package/monky
20:05:17 <Welkin> lol, conky
20:05:37 <iqubic> It's like conky, but written in haskell, and doesn't depend on X
20:05:38 <Welkin> I'm using conky right now
20:05:42 <Welkin> maybe I should try monky
20:05:53 <Welkin> but I am using X too, though
20:06:21 <Welkin> lol written by ongy
20:07:14 <iqubic> So, there are a few programs (XMonad and Monky) that have their configs written in haskell. ghc-mod for emacs doesn't know where the libraries that I want to import are located, so I get a red line under my import statements.
20:08:01 <iqubic> Is there a tell ghc-mod where the libs are that this single file uses?
20:09:32 <iqubic> Welkin, what WM/DE do you use?
20:10:24 <iqubic> out of curiousity
20:11:09 <Welkin> iqubic: bspwm
20:11:30 <Welkin> https://github.com/baskerville/bspwm
20:12:45 <iqubic> Any particular reason why?
20:13:39 <iqubic> Also, just splitting the windows seems hard to do there.
20:14:05 <AndChat|556404> It looks pretty I guess
20:16:24 <Welkin> iqubic: I tried i3 and liked it for the most part, but didn't like how everything was coupled together and how it was kind of a pain to modify
20:16:36 <Welkin> this is much lighter weight and allows greater customization
20:16:48 <Welkin> plus the fibonacci spiraling windows is cool
20:17:11 <iqubic> But why not XMonad or something like that?
20:17:20 <Welkin> I never got xmonad to install
20:17:27 <Welkin> that's the only reason
20:17:35 <Welkin> and I like bspwm for now, so no reason to switch again
20:17:36 <iqubic> Just use awesome.
20:17:38 <quick_dudley> I got xmonad to install but I never got it to run
20:19:27 <iqubic> Is there a list that compares tiling window managers?
20:19:38 <Welkin> iqubic: probably on wikipedia
20:20:05 <Welkin> once you go tiling, you never go back
20:20:13 <iqubic> Or even google itself.
20:21:03 <iqubic> @google tiling window manager list
20:21:04 <lambdabot> https://wiki.archlinux.org/index.php/Comparison_of_tiling_window_managers
20:21:10 <iqubic> Why so many?
20:22:09 <Welkin> iqubic: it's the open source way
20:22:28 <Welkin> try several of them
20:22:45 <Welkin> I started with i3, mostly liked it, then went on to find something that better fit my needs
20:23:25 <iqubic> I should really try some of the others out.
20:23:29 <iqubic> I really should.
20:26:50 <Welkin> does anyone know of a way to easily browse websites in "dark mode"
20:26:54 <Welkin> not just inverting the colors
20:27:04 <Welkin> any plugins I could use?
20:27:14 <iqubic> Welkin, this is haskell chat
20:27:19 <iqubic> Try elsewhere.
20:27:23 <Welkin> yeah, you are programmers
20:27:34 <iqubic> Also, sorry for derailing the haskell chat
20:27:55 <Welkin> it happens all the time
20:30:08 <geekosaur> I found a Stylish theme for it but it was (and was advertised as being) unreliable
20:30:17 <geekosaur> too many websites doing their own weirdshit
20:31:14 <iqubic> So why is i3 not the greatest?
20:31:26 <Welkin> I tried using eww (emacs web browser), but it's too damn slow and hard to use
20:31:53 <Welkin> iqubic: not that configurable and is kind of an all-in-one package
20:32:00 <iqubic> Oh.
20:32:05 <iqubic> WHat do you recomend?
20:32:14 <Welkin> depends on you
20:32:16 <Welkin> I like bspwm
20:32:19 <Welkin> others like xmonad
20:32:26 <Welkin> or awesome
20:32:37 <iqubic> What is awesome?
20:32:41 <iqubic> Is it good?
20:32:43 <geekosaur> keep in mind that tiling wms are very much personal preference, if you don't like one there's 50 others to try
20:32:53 <iqubic> Yeah.
20:32:54 <geekosaur> half of them forks of ratpoison >.>
20:32:58 <Welkin> iqubic: I hear good things about it
20:33:10 <Welkin> never tried ratpoison, but I know it's old
20:33:50 <iqubic> Why do so many ratpoison forks exist
20:34:09 <geekosaur> because everyone liked it EXCEPT they just wanted this one thing to behave a little differently...
20:34:09 <Welkin> because they can
20:34:13 <Welkin> it's the open source way
20:34:27 <Welkin> if you don't like it, try to contribute. If you are rejected, fork it and make your own
20:34:51 <iqubic> I don't know any libs well enough to create a fork of WM.
20:35:19 <Welkin> the only tiling wm I know of that runs on wayland is sway (an i3 port)
20:35:26 <Welkin> all others only run on X
20:35:28 <geekosaur> aside from dwm and xmonad which are both window manager libraries so you fork someone else's plugin library instead
20:36:16 <iqubic> So I shouldn't spend my time writing a fork of a tiling WM?
20:36:38 <Welkin> not unless you find it fun
20:37:01 <iqubic> I don't find it fun
20:37:21 <Welkin> glguy wrote his own irc client in haskell instead of using one of the many existing ones
20:37:39 <Welkin> http://hackage.haskell.org/package/glirc
20:38:05 <iqubic> And I use that right now.
20:38:22 <Welkin> lol you do?
20:38:30 <Welkin> I never tried it
20:38:34 <Welkin> I'm too lazy to switch from irssi
20:38:53 <quick_dudley> I've always assumed the irc protocol is not too complicated, but have never bothered to actually check
20:39:04 <Welkin> it's not that bad
20:39:06 <geekosaur> not so much complicated as fiddly
20:39:19 <Welkin> but probably worse than you think
20:39:21 <geekosaur> lots of weird server messages
20:39:22 <Welkin> like midi
20:39:30 <Welkin> when I wrote a midi parser, I ran into a lot of trouble
20:39:36 <Welkin> it took much longer than expected
20:40:13 <Welkin> too much poorly documented stuff
20:40:30 <duckqlz> I followed this while learning haskell https://wiki.haskell.org/Roll_your_own_IRC_bot
20:40:32 <quick_dudley> I knew midi was difficult, but didn't know it was used in irc
20:40:52 <Welkin> lol quick_dudley 
20:40:59 <duckqlz> learned a bit about irc and alot about haskell 
20:41:14 <Welkin> duckqlz: I used that when I started haskell too
20:41:15 <Welkin> :D
20:41:18 <Welkin> great tutorial
20:42:15 <glguy> Since it came up, my client looks like this right now https://glguy.net/client.png
20:42:19 --- mode: glguy set -o glguy
20:42:37 <glguy> The IRC protocol isn't that complicated, but there's lots of fiddly UI stuff to do
20:43:21 <Welkin> you group all the joins/parts into a paragraph it seems
20:44:12 <glguy> Welkin: Yeah. I can also toggle though other views, like https://glguy.net/detail.png
20:44:17 <Welkin> I've wanted to customize how irssi looks, but I don't want to write perl
20:44:18 * hackagebot system-linux-proc 0.1.0.2 ‚Äì A library for accessing the /proc filesystem in Linux ‚Äì https://hackage.haskell.org/package/system-linux-proc
20:44:19 * hackagebot system-linux-proc 0.1.0.1 ‚Äì A library for accessing the /proc filesystem in Linux ‚Äì https://hackage.haskell.org/package/system-linux-proc
20:51:02 <iqubic> UGH PEAR!?!?!
20:51:37 <iqubic> *PERL?!!?!!?!?!
20:52:04 <quick_dudley> "No specific character set is specified." I will assume that doesn't mean freenode will know what to do if a client starts sending it EBCDIC
20:52:41 <geekosaur> it just sends it on; what clients do is up to the clients
20:53:08 <geekosaur> this is one reason one encounters encoding issues; clients often try to figure out whether a line is utf8 or iso8859, and sometimes guess wrong
20:53:32 <geekosaur> especially if someone using a dumb client cut and pasted something in one into something in the other
20:53:54 <quick_dudley> I suppose that's better than software which just assumes everything is in one encoding
20:57:54 <iqubic> glguy: What encoding does glirc assume things are in?
20:58:35 <glguy> It tries UTF-8, and if that doesn't work it uses CP-1252
20:58:48 <iqubic> Cool.
20:59:25 <geekosaur> oh, and a bit of trivia: nicks can contain characters like [] because there was a common encoding in the scandinavian countries that used those for letters like √∏ and √•
21:03:38 <glguy> and as a result this is True for nicks: "{}~|" == "[]^\\"
21:03:45 <glguy> and channel names
21:04:04 <iqubic> WHAT THE!?!?!
21:05:27 * Clint nods.
21:06:45 <quick_dudley> Because the IRC protocol specifies how to do case insensitivity and assumes you're not exactly using ascii
21:07:00 <iqubic> OH
21:07:31 <quick_dudley> Actually: it doesn't really assume that, it just specified that the same case sensitivity function should be used
21:13:14 <geekosaur> like I said, fiddly
21:18:06 <shedm> does this function declaration have side effects? 
21:18:07 <shedm> readInts s = let ws = words s in map read ws
21:18:25 <shedm> forgot to include: readInts :: String -> [Int]
21:18:47 <quick_dudley> Not side effects but `read` sometimes throws exceptions
21:20:01 <ongy> Welkin: is that good or bad when it's written by me? :)
21:21:13 <shedm> but if you use the function, then you modify some variable outside of the readInts scope
21:22:02 <geekosaur> no, it shouldn't do that. *but* if the string came from a lazy I/O function, conceivably that can have side effects
21:22:54 <geekosaur> (it shouldn't, but lazy I/O's semantics are tricky and you may get effects that are unexpected but correct)
21:23:16 <glguy> shedm: You can't modify a variable
21:23:23 <shedm> Ah ok got it. Thanks
21:23:56 <geekosaur> also they are not actually variables, they are bindings (because they are immutable). can you show a full example that you believe has a problem?
21:24:34 <shedm> Yeah I got confused with terminology. I am really new to programming/haskell.
21:30:49 <Cale> shedm: The only way in which variables vary in Haskell is when, for instance, you apply a function to new arguments, and so its parameters get bound to something different. They don't change so long as they remain in scope. If you see some variable like ws, it will have the same value throughout its entire scope.
21:31:23 <Cale> shedm: The ws which gets bound there only scopes over the body of that function definition though. It's inaccessible from outside of readInts.
21:31:53 <Cale> and each time you apply readInts to some string, ws will be a new variable, separate from all the others
21:32:57 <geekosaur> hm, I bet they tried to do something like let foo = ... in multiple scopes and were surprised to get the original value on exiting the inner scope
21:33:34 <geekosaur> also note that in do notation, every line is a new inner scope
21:33:45 <geekosaur> because it becomes foo >>= \bar -> baz >>= ...
21:35:50 <geekosaur> not to mention that let is recursive, so 'let x = x + 1' does not do what you expect from other languages
21:36:28 <geekosaur> (it will be an infinite loop if you ever try to use its value)
21:37:08 <shedm> Interesting
21:37:19 <shedm> Thanks for the explanations Cale and geekosaur
21:44:03 <tabemann> I have to write a parser for something, namely parsing treecode into an executable structure, and I was wondering if anyone had any suggestions for parsing modules to use for this; I know a number exist, but I don't remember their names or their pluses and minuses
21:47:12 <tabemann> now I remember parsec and attoparsec, but it appears that attoparsec is specifically for bytestrings, and I want something that will parse unicode
21:47:38 <geekosaur> megaparsec, I think. (parsec with fixes and proper Applicative support, among other things)
21:48:06 <tabemann> oh, attoparsec does support Text
21:51:57 <Myrl-saki> This is going to be stupid.
21:52:46 <Myrl-saki> But I want to use `Free` on AttoParsec's IResult.
21:52:49 <Myrl-saki> Or something similar.
21:52:55 <Myrl-saki> I want to know which part fails. That kinda stuff.
21:53:10 <Myrl-saki> I guess I should just use alternative?
21:57:14 <Myrl-saki> Does chrisdone come over here?
22:44:49 <iqubic> What's the best tiling window manager?
22:54:17 <Myrl-saki> iqubic: XMonad ofc.
22:56:15 <iqubic> Myrl-saki: Do you use emacs?
22:57:11 <iqubic> How do you edit the xmonad config file?
22:57:36 <systemfault> With a text editor? :/
22:58:22 <iqubic> Yes, but I want to know which text editor he uses.
22:58:25 <iqubic> or she.
22:58:42 <systemfault> Ahh
22:58:47 <iqubic> Which editor *they* use
23:05:00 <geekosaur> I think the context here was that iqubic asked me that in #xmonad a few hours ago... they're looking for an IDE. I pretty much don't do IDEs.
23:07:29 <iqubic> That's not my issue.
23:08:41 <iqubic> http://imgur.com/a/fL71z
23:08:55 <iqubic> That is my issue. See the red lines under the imports.
23:09:06 <iqubic> I don't know how to get that to go.
23:09:42 <iqubic> ghc-mod or intero or something can't find the location of the libs, but XMonad compiles just fine.
23:11:14 <geekosaur> iqubic, the dirty secret of Haskell IDEs is they all use ghc-api for performance --- which ties them to a specific ghc installation and the libraries it knows about. intero can often convince its IDE backend to find stuff provided (a) it was installed with stack (b) you are using the same *.cabal and stack.yaml (this won't generally be true for an xmonad.hs).
23:11:36 <geekosaur> but in the general case, getting everything on the same page is a nightmare
23:12:52 <geekosaur> which is a big part of why I don't bother with Haskell IDE functions in an editor
23:13:04 <iqubic> So what should I do
23:13:05 <iqubic> ??
23:13:28 <geekosaur> could you explain what part of what I said suggested that there is something you can do?
23:14:14 <iqubic> Well, I see that trying to get these errors to go away will be a huge pain in the butt.
23:14:25 <geekosaur> were you expecting me to have the Big Reveal of how to fix the problem I basically said is inescapable?
23:15:10 <iqubic> Yeah. I suppose.
23:15:23 <iqubic> So is this problem unsolve-able?
23:15:35 <geekosaur> people have been trying to solve it for years
23:16:17 <iqubic> wow. So what *should* I do?
23:34:16 <Myrl-saki> iqubic: Yep.
23:34:19 <Myrl-saki> I use both nvim and Emacs.
23:35:49 <iqubic> This problem will not be solve-able will it?
23:35:55 <iqubic> Like not at all?
23:36:01 <iqubic> I just have to deal with this?
23:37:01 <xormor> I use nano and gedit
23:37:44 <quick_dudley> It can be solved for a given project by compiling the ide with the same stack snapshot as whatever you're working on, but once you start using a different snapshot the problem will come back and you'll have to recompile.
23:38:37 <iqubic> quick_dudley: I think the issue is not which compiler I'm using, but where the libs are.
23:39:11 <iqubic> Usually there's a .cabal file in the project root, but that's not here currently.
23:39:12 <quick_dudley> Stack also makes sure the libs match up
23:39:27 <iqubic> quick_dudley: What does that mean?
23:42:04 <quick_dudley> I mean the stack snapshot specifies which version of each lib to use (unless there's stuff about "extra-deps" in either one's stack.yaml file
23:42:34 <quick_dudley> xormor: I find geany has better syntax highlighting for Haskell than gedit
23:42:51 <iqubic> Ah.
23:43:09 <iqubic> So is there a way to easily fix this?
23:44:02 <quick_dudley> No, not really. And even the fix which is there won't work across different projects
23:45:02 <iqubic> This is the only project where I'm getting this issue, so.
23:46:25 <quick_dudley> In that case give stack a try, but don't be surprised if it makes the same problem appear in some of your other projects instead.
23:48:00 <iqubic> this project is XMonad. Compiling for stack will be hard to do.
23:48:32 <iqubic> Because I'd also need the contrib too.
23:48:32 <quick_dudley> Oh, I'd been afk and not realized which project you were talking about
23:48:51 <quick_dudley> unfortunately although I've managed to build XMonad it's never actually run for me.
23:50:01 <iqubic> quick_dudley: What WM do you use?
23:51:11 <quick_dudley> Recently I've been using Ubuntu with the default window manager. It's not the best I've used but I haven't gotten around to changing it yet
23:51:22 <quick_dudley> Relatively new computer and all
23:51:53 <iqubic> What would you like to be using in the future?
23:52:18 <iqubic> Also, I'm thinking of switching away from XMonad.
23:52:41 <iqubic> Not because of this, but because XMonad is a complex beast to configure.
23:52:46 <quick_dudley> I'd like to try a tiling window manager. If I get one to work and still don't like it I'll probably go back to cinnamon
23:53:34 <quick_dudley> which I hear isn't as easy to install on Ubuntu as it used to be
23:53:40 <iqubic> which one were you thinking of trying?
23:53:52 <quick_dudley> Probably try again with xmonad
23:54:10 <iqubic> Even with the issues I've been mentioning?
23:54:45 <iqubic> I hate this issue with the imports not being found.
23:55:27 <quick_dudley> Since I don't use an IDE I'll probably have a completely different set of issues
