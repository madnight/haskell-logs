00:11:35 <fearless_man> should I post my question again?
00:12:47 <fearless_man> i've read that oop is sequential and fp is not, is event driven also sequential?
00:13:10 <fearless_man> oop(most imperative languages, e.g. python)
00:13:42 <MarcelineVQ> it hasn't been a page scroll yet so no, there's a little bit of stuff from a guy called angerman here https://medium.com/@zw3rk   The last part of your question suggests you may want to do additional research on your end though, I don't know much about phones but you should find out where programs go on the phone before worrying about compiling for it :>
00:13:45 <cocreature> fearless_man: just stick around for a bit and see if someone knows the answer. in general, cross-compiling using GHC is kind of painful but luckily people like angerman are working on changing that
00:15:26 <angerman> fearless_man: don't try 8.0.2. Use HEAD, and apply at least: https://phabricator.haskell.org/D3352
00:16:00 <cocreature> suddenly a wild angerman appears
00:16:35 <fearless_man> angerman: you mean the latest on dev?
00:17:20 <angerman> fearless_man: yea. Or just use my custom my-ghc branch from https://github.com/zw3rk/ghc.
00:17:47 <angerman> fearless_man: that one includes D3352, as well as -staticlib
00:19:06 <angerman> fearless_man: you can also find the build script I use to build x86_64-macOS, aarch64-iOS, armv7-android, aarch64-anroid and arm-linux (rpi) from https://github.com/zw3rk/ghc-build-scripts
00:19:56 <angerman> fearless_man: be aware that if you compile libffi with clang, you will need a libffi-head copy, due to clang dropping support for the old arm syntax, and libffi not having a release in years.
00:20:09 <fearless_man> angerman: after cross compiling, where do i putt the executables? in /bin?
00:20:38 <angerman> fearless_man: and as MarcelineVQ said, you will find rather detailed write-ups on https://medium.com/@zw3rk
00:20:44 <EvanR> its raining men
00:21:26 <angerman> fearless_man: which executable? If you want to cross compile to android, or iOS, you end up building a Library in Haskell, which you than wrap with your mobile application.
00:21:42 <angerman> EvanR: sorry :p
00:23:16 <angerman> fearless_man: however, after rereading your question a few times, your intent is to have ghci running on your phone, ... that's something I haven't gotten around yet. It is however on my list of things I'd like to get around to eventually.
00:24:11 <angerman> cocreature: by the magic of ircclouds push notifications :)
00:25:00 <cocreature> angerman: if it‚Äôs becoming annoying that I keep mentioning you, just tell me and I‚Äôll stop :)
00:25:26 <angerman> ha, it's alright ;-)
00:28:37 <fearless_man> angerman: I have installed this debian emulator on my phone (https://play.google.com/store/apps/details?id=com.gnuroot.debian). It works like a real debian, I can install pretty much anything. I already installed haskell-platform version 7.6.3. Is there an easier way to upgrade it to the latest verion? And what is the pros of getting the latest version, all I want is to learn the fundamentals of FP. 
00:28:43 <fearless_man> About the cross compiling, I've never tried it before. So if I cross-compiled something, I will just copy the executable to my phone's /bin directory?
00:29:30 * nshepperd is glad someone is working on bringing sanity to cross compilation
00:29:43 <angerman> fearless_man: I think you might be confusing two things here. If you run ghc/ghci within an emulated environment, you are not cross compiling. You basically just run a full ghc in an emulator.
00:29:45 <bvad> fearless_man: if you have shell access through that emulator, I guess you just have to run the executable yes
00:30:10 <bvad> Did you install haskell-platform on your phone? :o
00:30:53 <angerman> fearless_man: cross compiling is specifically useful if you plan on compiling on a more powerful machine to a less power full one. Or if you want to deploy something in a restricted environment, where you can not install a full compiler.
00:31:35 <angerman> fearless_man: however if you just want to *learn*. I wonder if fpcomplete Online UI (they still have that I believe?) is better suited?
00:32:00 <angerman> e.g. this one I believe: https://www.schoolofhaskell.com
00:32:21 <fearless_man> bvad: I do have a root access
00:33:04 <fearless_man> bvad: yeah I have haskell-platform on my phone
00:34:14 <angerman> fearless_man: or http://www.tryhaskell.org, even though that's only really basic. 
00:34:44 <fearless_man> angerman: I already have the ghc compiler on my phone
00:38:46 <angerman> fearless_man: if you *really* want to go through that, try to find an ARMv7 emulator, and build the latest ghc-HEAD with it. (I would advise against trying this on your phone), that should provide you with ghc, and ghci for armv7.
00:40:02 <angerman> fearless_man: yet again, if all you want is to learn about functional programming (and haskell), you might also choose a route that is less painful, yet leads to enlightenment?
00:47:22 <nshepperd_> Hm, with TH, I think i prefer the method that runs TH on the build machine. It seems rather unnatural to need an emulator or network connection just to evaluate splices
00:48:41 <merijn> nshepperd_: I don't see how you could make that work without a *LOT* of work
00:49:03 <merijn> nshepperd_: Since TH has access to architecture specific things while running
00:49:13 <angerman> you can always try to "emulate" the target on the build ;-)
00:49:45 <nshepperd_> If your template haskell makes assumptions about running on the same machine as the output code, my advice would be, don't do that :)
00:50:01 <merijn> nshepperd_: What if you're generating TH code that accesses the FFI?
00:50:12 <merijn> nshepperd_: You need access to things like the size of CInt to properly gen code
00:50:24 <angerman> One solution that *might* work, is (once we have multi target support in ghc) to compile everything for the build and target, and then use the build libraries to evaluate the splices.
00:50:33 <merijn> angerman: Sure, that's theoretically possible, hence my *lot* of work comment :)
00:50:37 <angerman> There are quite a few questions about *what* that actually means though :)
00:51:00 <angerman> merijn: yea... I've been chipping away at it... slowly.
00:51:15 <nshepperd_> You mean that it accesses the ffi at compile time? Or generating code that accesses the ffi?
00:51:25 <merijn> nshepperd_: Well, both
00:51:39 <merijn> Why wouldn't TH have access to the FFI?
00:52:06 <angerman> nshepperd_: the key is that to evaluate TH splices, an arbitrary haskell function is run. That function in turn can call C ffi or do any other kind of IO.
00:52:11 <merijn> nshepperd_: I was referring to generating code that accesses FFI, but I'm actually unsure what the "right" way for compile-time FFI usage would be either
00:54:17 <nshepperd_> Why would accessing the ffi need anything special?
00:55:21 <angerman> nshepperd_: if you depend directly or indirectly on the word size in your splice, and your build and host machines word sizes done match, you are in trouble.
00:55:23 <merijn> nshepperd_: Welp, suppose your TH access a library via and you're compiling for ARM on x86. Do you expect it to access a C library built for ARM or for x86?
00:55:24 <nshepperd_> You don't need to know the size of CInt normally, you just import the relevant Foreign module
00:55:58 <ertes-w> helo
00:55:59 <merijn> nshepperd_: Well, what if you're using TH to generate some struct accessing code?
00:56:09 <merijn> nshepperd_: That requires you to know the size of C datatypes
00:56:23 <merijn> TH for generating Storable instances, for example
00:57:38 <fearless_man> angerman: do you think this setup is enough to learn the fundamentals of haskell? https://pasteboard.co/GBCUSkD4.png what functionalities does 7.6.3 lack vs the latest? thanks!
00:58:42 <nshepperd_> Well, you can generate code that uses the storable instance for CInt
00:59:28 <angerman> fearless_man: probably. I don't think you'll miss out on anything significant with 7.6.3
00:59:51 <nshepperd_> If you really need to know the size at compile time for some reason, and that isn't enough, i guess you'd better import some library providing the target architecture's properties
01:00:18 <merijn> nshepperd_: Well, what if GHC ends up inlining CInt's Storable instance by accident?
01:00:28 <nshepperd_> What?
01:00:48 <angerman> nshepperd_: assuming we had that, yes. But as far as ghc is concerned the arch properties are discovered by "configure". 
01:01:03 <nshepperd_> It doesn't matter if it's inlined if the code is correct...
01:01:18 <merijn> nshepperd_: "Just generate code using Storable instance for CInt" <- well, when GHC compiles that code, how do you ensure it doesn't inline the constant size fromt CInt on the host
01:01:19 <Axman6> #import  gives you access to the macros you need btwchDep.h"
01:01:22 <Axman6> uh
01:01:42 <merijn> nshepperd_: It matters if it's inlining the HOST implementation of Storable for CInt, rather than the TARGET instance
01:01:44 <angerman> Axman6: alright!
01:02:02 <Axman6> ok, that did not come out right - #include "MachDep.h" gives you the macros you need
01:02:17 <nshepperd_> I'm talking about generating code that says "import Foreign.C"
01:02:28 <nshepperd_> Mention is not use
01:03:08 <angerman> Axman6: but we do not yet generate that in a multi-target fashion :)
01:04:02 <merijn> nshepperd_: Which Foreign.C is being imported? Host or target?
01:05:17 <nshepperd_> It's code that is supposed to run on the target, so it will import the target's Foreign.C
01:05:55 <merijn> nshepperd_: Well, except, what if that generated code is also used to run and generated other code from some other TH splice?
01:06:33 <nshepperd_> Multiple stages of TH?
01:06:33 <merijn> nshepperd_: Should we actually generate it twice? Once for the target and once for the host? Should it always run linked with libraries build for target?
01:06:47 <merijn> nshepperd_: TH is multi-stage already
01:07:05 <merijn> nshepperd_: You can include modules that include TH generated code and call them from other modules that use TH to generate code
01:08:05 <merijn> nshepperd_: It's unclear to me what you should even expect in that scenario
01:08:36 <merijn> So it's not even "just implementing it", but deciding what the expected behaviour *should* be
01:08:55 <merijn> Which is non-obvious in any non-trivial scenario
01:14:19 <nshepperd_> That sure sounds like it could get confusing, if there were multiple stages that were used both on the host and in the target and that also cared about target architecture details
01:31:42 <nshepperd_> But, what i would expect would be: if you encounter a splice when compiling a module for the target, you compile the splice for the host (with a module made available describing target architecture, if it needs that) and run it. If, in compiling something for the host, you encounter a splice, you do the same
01:33:56 <angerman> nshepperd_: now I'll make that a bit more complicated for you :-) Let's assume you have $(f x), and thus you need to evaluate f, but f depends on some C library on the host (for which there is no counterpart for the build system), all you have is `f` in a form that can only be evaluated on the host.
01:35:07 <lamefun> Haskell's inference seems pretty disappointing to me. I don't get why is it so revered... Can somebody explain it to me?
01:35:22 <Axman6> disappointing how?
01:35:43 <angerman> In general `f` is a black box to ghc. It's a symbol with an arity, and some compiled library that contains it. Evaluating f with the passed arguments will return some AST fragment that will be spliced in place. However how that AST fragment came to be is of no concern to ghc.
01:37:26 <Athas> lamefun: you mean the type inference?
01:39:01 <lamefun> I mean, if this compiled, then I'd be impressed: http://lpaste.net/4311538284850315264
01:39:40 <lamefun> If I didn't need to deal with stuff like Direction.Left like in most languages.
01:39:57 <merijn> lamefun: Seems like you want the opposite of inference
01:40:19 <merijn> lamefun: Looks like type-derived name resolution, which, IMO is a *terrible* idea
01:40:25 <Axman6> There are definitely situations where it is not possible to infer a type of something (read . show being a pretty common example), but type interence generally doesn't get any better than Haskell's
01:40:47 <merijn> Axman6: If you look at that example it doesn't deal with type inference at all, since it's all annotated
01:40:50 <Athas> Axman6: SML is better.
01:41:05 <merijn> Athas: In what way?
01:41:08 <Athas> Haskell has (consciously, pragmatically) added features that make type inference more difficult.
01:41:28 <Athas> merijn: type inference is always possible.
01:41:34 <Athas> No exceptions.
01:41:42 <Axman6> I'm not familliar enough with SML to be able to comment really
01:41:52 <merijn> Athas: That's only better if there are cases that are possible in SML, but not in Haskell
01:42:01 <Axman6> Athas: what's the type of read . show?
01:42:19 <Athas> Axman6: you don't have ad-hoc polymorphism in SML.  The type inference is better because the language is less powerful.
01:42:29 <merijn> Axman6: Axman6 "read . show" is fine
01:42:44 <merijn> Axman6: That's just "(Show a, Read b) => a -> b"
01:42:48 <merijn> :t read . show
01:42:50 <Axman6> (In Haskell it's String -> () because of defaulting if it doesn't have any more info, but that's nearly never what you want)
01:42:50 <lambdabot> (Show a, Read c) => a -> c
01:43:07 <Axman6> hmm, maybe it was show . read
01:43:08 <Athas> SML only has basic parametric polymorphism, and everything else must be encoded via the module language.
01:43:16 <merijn> Axman6: Also, defaulting like that is only in ghci
01:43:21 <ephemera__> Can I parse cabal configuration file (*.cabal) with standard library?
01:43:28 <Axman6> is it?
01:43:43 <merijn> Axman6: Defaulting to () is ghci, GHC just errors at compile time
01:44:04 <merijn> Axman6: GHC only defaults numerics (to Integer) and fractional (to Double)
01:44:20 <merijn> Everything else is ambiguous type error
01:44:41 <merijn> ephemera__: Cabal actually has a library to parse things, but it's not a stable API, so prone to breaking
01:44:46 <merijn> ephemera__: What are you trying to do?
01:45:09 <lamefun> merijn: Why is type-derived name resolution a bad idea?
01:45:18 <lamefun> Is there an example where it breaks everything?
01:45:38 <ephemera__> merjin: I want to read some value inside cabal configuration
01:45:56 <merijn> lamefun: 1) You need to annotate types everywhere, which is exactly what type inference tries to avoid, 2) you can't understand an expression without knowing it's type
01:46:25 <merijn> lamefun: If you have a huge 2000 lines file and you see "Left", you now have no idea of knowing *which* Left (Direction, Either, something else) it is, unless you know it's type
01:46:36 <merijn> ephemera__: Which value and to do what?
01:46:58 <lamefun> merijn: point the mouse over it and see. Atom can already do this.
01:47:28 <flounders> Is anyone else having issues with stack and making new projects right now?
01:47:53 <merijn> lamefun: It can do that *now*, because the type can be inferred
01:47:55 <ephemera__> merjin: `library > hs-source-dirs`. 
01:48:14 <merijn> lamefun: But if you have type-derived name resolution you can't use inference anymore (or, at least only in a very restricted way)
01:48:57 <merijn> ephemera__: https://hackage.haskell.org/package/Cabal but, be warned, as I said it's not a stable API
01:51:03 <lamefun> If the file compiles that means GHC knows which Left it is (or else it wouldn't compile), otherwise Atom would simply show the available candidates.
01:51:30 <merijn> lamefun: How do you think Atom knows the available candidates/types? It's asking ghc
01:52:07 <lamefun> Wouldn't GHC know which Left's are visible in the current module from the imports?
01:52:29 <ephemera__> merjin: Thanks. Actually I want to distinguish between someone who put the source file in src and not. 
01:52:48 <merijn> lamefun: And how would GHC decide which one it is? if there are multiple in scope?
01:53:01 <merijn> ephemera__: And what do you plan to do with that info?
01:53:17 <bash0r> merijin: Ambiguos names in scope. :p
01:53:53 <merijn> bash0r: Well, that's the problem with type-derived name resolution, everything becomes a pit of ambiguity and sadness
01:54:30 <bash0r> merijin: yepp yepp, I agree
01:55:30 <ephemera__> merjin: Because I need file path of some files  
01:55:33 <bash0r> merijin: I'm happy I'm able to resolve such ambiguoities on my own by giving precise declarations.
01:56:21 <lamefun> merijn: you'd have to give it a hint or just write "Either.Left" if all else fails.
01:56:48 <merijn> lamefun: Right, so then we're basically where we are now, except with more ambiguity when reading code
01:57:08 <bash0r> lamefun: You can handle your imports in an explicit manner. E.g. import qualified ... as ...
01:57:31 <bash0r> lamefun: Which does exactly the same.
02:00:56 <lamefun> Would that ambiguity really be that bad?
02:01:02 <sphinxo> Is it just me or are the examples given here for IO TestTree failing? https://github.com/lwm/tasty-discover
02:01:30 <sphinxo> http://lpaste.net/1690695712653705216
02:01:31 <bash0r> lamefun: Yes it is bad. You can't decide which symbol to use in some cases. Which makes legal programs illegal as you just can't check them.
02:02:16 <bash0r> lamefun: By stating explicitly clear which symbol you mean, get achieve a lot more concise code.
02:02:31 <bash0r> lamefun: you achieve *
02:03:09 <bash0r> lamefun: Such code is much more likely to be correct and will do what you intended.
02:06:36 <lamefun> "You can't decide which symbol to use in some cases" - like (read . show)?
02:07:06 <bash0r> lamefun: Exactly. In such cases explicit declaration of some way is required.
02:07:19 <merijn> "read . show" works just fine
02:07:50 <bash0r> Oh well, yeah. You're right.
02:08:04 <bash0r> Do you have a real example? Can't think of one right now.
02:08:40 <bash0r> At least if you want to use more advanced features of the type system.
02:16:58 <lamefun> So is OOP method syntax like obj.method1().method2() bad even in OOP languages?
02:17:45 <zomg> lamefun: that often goes against the law of demeter
02:18:25 <zomg> it depends on what those methods are, but for example if you have user.getAddress().getStreetName(), then the suggested better practice is user.getStreetName() which internally does that
02:18:47 <zomg> (but imo whether it's useful to strictly follow that everywhere is debatable)
02:21:28 <lamefun> Why is that a better practice?
02:22:23 <Cale> lamefun: I don't consider that syntax "bad", after all, it's basically just weird-looking function application.
02:23:14 <Cale> Of course, I'd prefer to write  method2 (method1 obj)  myself :)
02:23:50 <lamefun> It's not about the syntax, it's about what it does. Isn't it essentially a version of that type-derived name resolution thing?
02:24:53 <lamefun> I mean, in Haskell you can't write "insert a (insert b set)" and "insert k v (insert k v map)" without importing one or both inserts qualified.
02:25:04 <Cale> I wouldn't really think of it as such, even though typed OOP languages often conflate types of objects with the implmentation of their methods
02:25:08 <Cale> (via classes)
02:25:32 <zomg> lamefun: it reduces the dependencies in your code so it only depends on the interface of the user, rather than on also how the user internally represents the address
02:25:54 <zomg> iirc anyway, I'm sure the internet can tell you more if you look up law of demeter on google =)
02:25:56 <Cale> Oh, you mean how it picks which actual function the name is bound to based on the object type. That's fair.
02:26:49 <Cale> That is, you can have two completely unrelated object types which each have a method called method2
02:27:09 <merijn> I would actually say that's one of the worst things about OO, after inheritance
02:28:51 <Cale> I'm not even sure I'd call it an OO thing specifically. That's just ad-hoc polymorphism. But yeah, whether it's a good idea is questionable.
02:28:57 <lamefun> I think it's actually one of the most important reasons why OOP is so popular. Even Rust has implemented this.
02:30:43 <merijn> Popular /= good
02:30:49 <merijn> PHP and JS are popular
02:31:10 <sphinxo> is there a testProperty from which I can use IO? 
02:31:28 <cocreature> sphinxo: https://hackage.haskell.org/package/quickcheck-io-0.2.0/docs/Test-QuickCheck-IO.html
02:31:59 <sphinxo> thanks
02:35:45 <lamefun> Popular == good most of the time. PHP is good because it's popular (more libraries, forums and tutorials). JS is good because it's THE web app platform.
02:36:31 <lamefun> PHP and JS are therefore good *despite* their flaws as languages.
02:37:52 <zomg> Did any of you see the recent take regarding how FP in JS is an antipattern btw?
02:39:17 <lamefun> Why?
02:39:49 <zomg> Seemed to be suggesting that there's so many different libs for different tasks and you have to hold all this info in your head about which value is from which lib etc.
02:40:00 <zomg> Been kind of feeling the same tbh, going really "hardcore" FP feels like the code becomes nothing but noise (nothing but million helpers), compared to how the same would be implemented for example in Haskell
02:40:30 <zomg> this was my recent attempt at describing the "noise" issue :) https://gist.github.com/jhartikainen/323096fb49dd0acc81310e1dfdeec1c6
02:41:23 <thimoteus> syntax matters!
02:41:34 <zomg> and here's that article https://hackernoon.com/functional-programming-in-javascript-is-an-antipattern-58526819f21e
02:42:05 <zomg> I'm not sure if I really agree with the premise the article lays out, at least that was never much of an issue for me - just the fact that the helpers obscure the meaning too much
02:42:36 <zomg> without truly making the code better than its more "JS-style" version
02:43:49 * hackagebot leancheck 0.6.3 ‚Äì Cholesterol-free property-based testing ‚Äì https://hackage.haskell.org/package/leancheck
02:47:58 <lamefun> Why not just write this? "const combinations = list => map(mkTuple, filter(x => x.length == 2, subsequences(list)))"
02:48:49 <zomg> or why not just subsequences.filter(x => x.length == 2).map(mkTuple)
02:49:38 <zomg> it's perhaps not the best example as you can easily translate it into something "saner", but the idea was to highlight how much of the code using Ramda and such looks like :)
02:54:56 <lamefun> 'going really "hardcore" FP feels like the code becomes nothing but noise' - then why go hardcore FP? and what does "hardcore FP" even mean?
02:55:47 <zomg> I guess it would be better described as using more FP than what JS syntax makes easy
02:56:09 <zomg> although JS provides facilities for (basic) partial application, that already starts to become a bit heavy
02:56:32 <cocreature> good code is not independent of the language it‚Äôs written in
02:57:07 <zomg> and yeah - why do it in JS is pretty much my issue. People are trying to shoehorn every damn FP pattern into the language even where the language itself makes it annoying to deal with
02:57:08 <cocreature> you can‚Äôt just take good C code and translate it into Haskell and get good Haskell code
02:57:22 <zomg> so if you really want your FP cake just use Elm, PureScript, GHCjs, ClojureScript... whatever :)
02:57:24 <lamefun> also, "((==) 2 . length)" - is this really how code is written in Haskell in real programs?
02:57:39 <zomg> I don't know tbh, I'm not that experienced in Haskell :p
02:58:07 <Viwor> What is your problem with this function?
02:58:26 <Rembane> lamefun: I write this: (== 2) . length
02:58:37 <cocreature> (2==) . length :)
02:58:49 <merijn> honestly "(==2) . length" is terrible code, but for a completely different reason
02:59:02 <merijn> It's needlessly wasteful to compute the entire length just to check if it's 2
02:59:10 <zomg> heh
02:59:20 <Viwor> So you can do pattern mathing?
02:59:30 * cocreature starts searching for the link to quchen‚Äôs post
02:59:31 <merijn> Pattern matching would be far better, yes
02:59:56 <zomg> is there some way of doing it that wouldn't require several additional lines of code though?
03:00:04 <zomg> unless I'm misunderstanding the pattern matching part you're referring to :)
03:00:22 <Viwor> You would need two lines, or do it with guards
03:00:24 <merijn> zomg: It'd only be two/three lines depending on where you wrote this
03:00:26 <Rembane> merijn: So you go: (_:_:[])?
03:00:38 <phadej> Rembane: you can write [_,_] too
03:00:40 <merijn> Rembane: I'd do "[_, _]", but yeah
03:00:45 <phadej> \o/
03:00:58 <Rembane> phadej, merijn: Cool! Sugar is good.
03:01:04 <phadej> square elephant ass. </sorry>
03:01:12 <zomg> interesting
03:01:36 <zomg> definitely wouldn't have thought of that even if I had been thinking of the performance of this function :P
03:01:42 <phadej> or maybe some other behemoth
03:01:56 <phadej> zomg: what's if list is infinite?
03:02:08 <phadej> length is O(n)
03:02:09 <Viwor> then add another line that returns false
03:02:16 <Rembane> phadej: I wonder if there is a mirrored comma. Then you can have a happy dog elephant.
03:02:23 <zomg> phadej: does subsequences work on such?
03:02:23 <Viwor> if the first doesn't match
03:02:44 <phadej> zomg: pattern matching? yes
03:03:00 <phadej> (or don't need to be infinite, large enough is enough)
03:03:15 <zomg> I suppose that's a valid point then
03:03:28 <phadej> the intereting part is that if we had length :: [a] -> PeanoNat, where PeanoNat = O | S PeanoNat
03:03:31 <zomg> I knew the length of the list going into this function is <10 anyway :P
03:03:41 <phadej> then (== 2) . length would work nicely and layz
03:03:49 <phadej> but slow otherwise :)
03:03:51 <cocreature> ah I finally found the post https://github.com/quchen/articles/blob/5dd82fe5e6f71a35e41ee20366f17c7bf9fe4a50/useful_techniques.md#avoiding-length-in-list-functions
03:03:58 <lamefun> If noise is an issue... aren't qualified names also noise? (Text.replace "foo" "bar" (Text.toLower (Text.trim text)))? vs. text.trim.toLower.replace("foo", "bar")?
03:04:40 <phadej> cocreature: sameLength = all isThese . align
03:05:40 <cocreature> phadej: heh yeah that‚Äôs nice
03:05:42 <boj> phadej: i am going to remember that shape as square elephant ass from now on :p
03:06:20 <phadej> :)
03:06:31 <zomg> lamefun: It depends. If it doesn't add anything useful then it could be
03:07:23 <zomg> (of course it's going to be difficult to eliminate all such instances from code)
03:08:02 <phadej> the argument is that the names like `map` "should" behave the same
03:11:09 <lamefun> To what end?
03:15:26 <lamefun> Nevermind, I agree that common names like 'map' should behave the same.
03:15:45 <lamefun> But why would having an option for other names to behave differently based on type be bad?
03:16:33 <Cale> lamefun: For exactly the same reason, it makes it hard to figure out what's going on
03:17:06 <Cale> lamefun: With type classes, you can look at the type of the thing and see that it's type class polymorphic, and work out how its implementation will depend on its type
03:17:24 <Cale> With ad-hoc polymorphism, you can't really do that, because you don't have a thing at all unless you know what type it's at.
03:19:32 <lamefun> Same with OOP methods, but for some reason people try to use them as much as possible instead of the opposite.
03:20:30 <lamefun> In fact, I genuinely think that Rust would've been rejected if it went the Haskell route and used qualified names instead of impl {}.
03:22:15 <lamefun> Or at least far less successful.
03:27:25 <Cale> lamefun: Sometimes it's only on the type of the argument before the dot though.
03:28:18 <Cale> (sometimes not, and that's much more questionable)
03:30:58 <Jinxit> can someone remind me what the type is of a parser combinator? without hiding it behind a monad or similar
03:31:28 <mpickering> For the record, all the packages on hackage comes to 4.1gb and the biggest package is "gf" which is 249mb followed by liquidhaskell which is 123mb. 
03:31:45 <Cale> Jinxit: You mean like a dead simple inefficient one?
03:31:50 <Jinxit> yeah
03:31:56 <Cale> Jinxit: Something like String -> [(a, String)]
03:31:58 <cocreature> mpickering: do you know what makes liquidhaskell so big?
03:32:06 <mpickering> lol
03:32:15 <Jinxit> it would need to take a function as an argument, no?
03:32:16 <mpickering> they have a .stack-work in there
03:32:19 <Jinxit> to actually do the combining
03:32:20 <cocreature> ‚Ä¶
03:32:20 <mpickering> I'll open an issue
03:32:31 <Cale> Jinxit: "A parser for things is a function from strings to lists of pairs of things and strings"
03:32:31 <Jinxit> for something like many
03:32:41 <Jinxit> hm
03:33:10 <Cale> Jinxit: The idea is that you give your parser the input, and it gives you back a list of possible parses
03:33:32 <Cale> each parse consists of a resulting value, and a depleted string which should always be some suffix of the input string
03:33:51 <Jinxit> ok yeah i see what you mean
03:34:36 <cocreature> huh gf breaks the ‚Äúbrowse‚Äù link on hackage https://hackage.haskell.org/package/gf-3.8/src/
03:34:41 <lamefun> TBH Haskell can do method calls, now that OverloadedLabels exist (https://github.com/haskell-gi/haskell-gi), but it's second-class compared to functions and you don't have the ability to define custom methods (without risks associated with orphan instances).
03:34:59 <Cale> Jinxit: This is basically the same thing as StateT String [] a
03:35:39 <mpickering> The big thing in gf is the lib directory which looks like it contains lots of files related to different languages
03:35:56 <Jinxit> and all the nice composability of say parsec is just a result of a good api?
03:36:13 <Jinxit> or i guess just how state works
03:36:27 <Jinxit> StateT _ [] to be specific
03:36:57 <Cale> Yeah, that will also automatically have an Alternative instance
03:37:01 <mathk> @pl \xs -> map (subtract $ average xs) xs
03:37:01 <lambdabot> map =<< subtract . average
03:37:07 <Cale> which does the right thing
03:39:25 * hackagebot speculate 0.2.5 ‚Äì discovery of properties about Haskell functions ‚Äì https://hackage.haskell.org/package/speculate
04:13:45 <chominist[m]> This may not be related, but how does one set xmonad change workspace hotkey?
04:15:02 <srhb> chominist[m]: You override modMask in the configuration with your preferred one
04:15:16 <srhb> chominist[m]: https://wiki.haskell.org/Xmonad/Frequently_asked_questions#Rebinding_the_mod_key_.28Alt_conflicts_with_other_apps.3B_I_want_the_key.21.29
04:27:50 * hackagebot plot-light 0.2.2 ‚Äì A lightweight plotting library, exporting to SVG ‚Äì https://hackage.haskell.org/package/plot-light
04:38:25 <lin_> i am trying to use flycheck from emacs, but i seem to encounter a haskell error which i don't understand
04:38:28 <lin_> Suspicious state from syntax checker haskell-stack-ghc: Flycheck checker haskell-stack-ghc returned non-zero exit code 1, but its output contained no errors: /usr/local/lib/ghc-8.3.20170713/package.conf.d/package.cache: GHC.PackageDb.readPackageDb: inappropriate type (Not a valid Unicode code point!)
04:42:57 <merijn> lin_: Blind guess: you're environment is broken and doesn't set a proper locale
04:43:29 <merijn> lin_: What does "locale" output when you run it in your shell?
04:43:37 <merijn> (and/or inside emacs)
04:44:25 <Akii> I think I had something similar when building ghc-mod with another compiler version than what my emacs was using
04:44:51 <Akii> I've a globally installed ghc and the one stack installs
04:45:05 <Akii> and if they don't match I get exactly that error
04:46:13 <merijn> Akii: Odd, ghc uses per-version package databases, so multiple installs of different versions shouldn't interfere
04:46:51 <Akii> merijn: I don't know the details, just that it worked once those two versions were the same
04:47:17 * Maxdamantus wonders what an example of something that's not a valid unicode code point might be.
04:47:57 <merijn> Maxdamantus: Decoding something with a different encoding than it was written with resulting in a value that's currently not defined in the unicode database
04:47:58 <Maxdamantus> Presumably it'd just be something outside of the range U+0 to U+110000
04:48:18 <merijn> Maxdamantus: Keep in mind that only a small portion of the possible incode codepoint values have been actually assigned
04:48:45 <Maxdamantus> Right, so most valid code points simply don't appear in that database.
04:48:55 <merijn> lin_: Also, why are you using ghc-8.3?
04:49:48 <quchen> 8.3? Is that a thing?
04:49:56 <quchen> Did the branch-off already occur?
04:50:08 <quchen> Eh nevermind, we‚Äôre in RC3 stage, of course it did, ignore me
04:51:33 <merijn> quchen: 8.3 == HEAD
04:51:45 <merijn> quchen: Only even versions are releases
04:51:49 <quchen> Yeah I thought we were still on 8.2
04:51:57 <merijn> We're not on 8.2 yet :p
04:52:05 <quchen> ‚Ä¶ish
05:08:14 <lin_> merijn: my locale is en_US.UTF-8
05:09:06 <lin_> ghc 8.3 because i needed a library that worked for ghc-version>8.1 and ghc in arch repositories is 8.0.2 so i build it from source
05:09:38 <lin_> but in my $PATH ghc is version 8.0.2, i don't understand why stack uses 8.3
05:10:50 * Clint squints.
05:11:30 <Akii> and there we have the version problem
05:12:34 <clamchowder> > :t 42
05:12:36 <lambdabot>  <hint>:1:1: error: parse error on input ‚Äò:‚Äô
05:12:56 <clamchowder> >:t 42
05:13:35 <clamchowder> hmm. lambdabot is not responding..
05:13:46 <Akii> :t 42
05:13:48 <lambdabot> Num t => t
05:14:00 <clamchowder> oh ok
05:14:14 <Akii> > let x = 42 in x
05:14:16 <lambdabot>  42
05:14:19 <clamchowder> thanks.
05:14:28 <Akii> np ^.^
05:15:15 <clamchowder> What does Num t => t mean? 42 has the type of any type in typeclass Num?
05:15:32 <merijn> clamchowder: Yes
05:16:04 <int-e> > (42 :: Integer, 42 :: Double)
05:16:06 <lambdabot>  (42,42.0)
05:16:20 <merijn> clamchowder: So if you write your own datatype that's an instance of Num you can use numeric literals as that type
05:16:58 <lin_> how can i fix version problems and how do i avoid them in the future? is there a resource about it that i did not find?
05:17:30 <clamchowder> OK. I asked about Rational before but I forgot the answer... What is the type of 2 and 3 when I write
05:17:35 <clamchowder> > 2 / 3 :: Rational
05:17:37 <lambdabot>  2 % 3
05:17:41 <merijn> lin_: Which library are you using? If it only supports ghc >8.1 it sounds like "ridiculous bleeding edge and experimental"
05:18:01 <merijn> lin_: In which case the solution would be "don't use ridiculously bleeding edge libraries if you can help it"
05:18:25 <flounders> lin_: GHC 8.0.2 is the latest stable release. Anything beyond that is not ideal to use unless you really know what you are doing.
05:19:11 <lyxia> clamchowder: Rational
05:19:13 <lyxia> :t (/)
05:19:15 <lambdabot> Fractional a => a -> a -> a
05:19:26 <lyxia> clamchowder: the result type is the same as the arguments
05:20:49 <merijn> clamchowder: You're asking for a result of type Rational, / requires arguments that are the same as it's return (so Rational too) and since Rational is an instance of Num, things "just work"
05:20:54 <merijn> > 2 :: Rational
05:20:57 <lambdabot>  2 % 1
05:22:28 <clamchowder> merijn: thanks. By the way did you mean to say "since Rational is an instance of Fractional"?
05:22:59 <merijn> clamchowder: Rational is an instance of Num, which is why it works with numeric literals. It is *also* an instance of Fractional, which is why it works with / :)
05:23:31 <clamchowder> OK. Now what is the most commonly used module for polynomial?
05:24:15 <merijn> Not quite sure what you meany by that?
05:24:21 <Yotam> you can save it as a list of tuples
05:24:51 <merijn> clamchowder: Although, I think Num is a superclass of Fractional, so anything with a Fractional instance must be Num by definition :)
05:24:53 <Yotam> 1+2x+3x^2 -> [(1,0), (2,1), (3,2)]
05:26:32 <clamchowder> merijn: I mean for example, to use rational numbers I can use Rational. But what do people use when they want to use polynomials? More specifically, I'm looking to use polynomials and Ratio Polynomials i.e. rational functions
05:26:58 <merijn> clamchowder: I've never used something like that, so honestly I don't know :)
05:27:08 <clamchowder> merijn: OK no worries :)
05:29:02 <clamchowder> Yotam: that works but I don't want to reinvent the wheels
05:29:17 <Yotam> That's part of the fun :)
05:29:34 <merijn> clamchowder: https://hackage.haskell.org/package/polynomial ? :)
05:29:52 <mxf> Hey *, when using stack, how do I delete a particular resolver (as in the libraries and its ghc)? 
05:30:52 * hackagebot platinum-parsing 0.1.0.0 ‚Äì General Framework for compiler development. ‚Äì https://hackage.haskell.org/package/platinum-parsing
05:31:11 <clamchowder> merijn: yeah I saw that one but I suspect I can't do Ratio to get rational functions, like x / (1 + x^2)
05:31:43 <quchen> mxf: There‚Äôs currently no way to do that, safely. Snapshots use libraries compiled for other snapshots.
05:31:51 <lin_> how could i change the ghc for stack, or how would i uninstall ghc from source?
05:31:56 <MarcelineVQ> mxf: .stack/snapshots  and  .stack/programs  will have relevant pieces to delete, but there isn't a particular command for it
05:32:08 <wz1000> clamchowder: You can use plain functions as polynomials
05:32:19 <quchen> mxf: That said, snapshots cannot use libraries compiled with other GHC versions, so I guess it‚Äôs safe to delete all, say, 7.8 snapshots.
05:33:31 <quchen> lin_: Remove $(which ghc) and ~/.ghc
05:33:46 <Yotam> clamchowder: Do you want precise results (symbolic even)? or just get the final result of the fraction?
05:33:52 <clamchowder> merijn: because the Poly (https://hackage.haskell.org/package/polynomial-0.7.3/docs/Math-Polynomial-Type.html#t:Poly) type does not belong to the Integral typeclass
05:33:54 <quchen> lin_: And then alias ghc as ¬ªstack ghc --¬´
05:34:00 <quchen> But that sounds a bit brittle
05:34:07 <quchen> Not sure whether it works in all cases.
05:34:12 <clamchowder> Yotam: Yes I want to do symbolic maths.
05:35:03 <clamchowder> merijn: sorry I mean the list below the Poly does not have a Integral instance on the right hand side
05:36:42 <Yotam> clamchowder: I don't think there is a library that provides you with this. You can however use Real Reals to get accurate end results.
05:36:53 <clamchowder> Is there any active development on symbolic maths in Haskell?
05:38:13 <Yotam> not something that will just hand you what you need without some hacking
05:38:55 <wz1000> clamchowder: symbolic maths is boring... You can use automatic differenation, and use taylor series to recover a polynomial from your function.
05:39:58 <wz1000> if you have a num instance for (a -> b), you can write polynomials like (x^3 + 3*x^2 + 5) where x = id
05:40:28 <MarcelineVQ> lin_: Are you trying to use HEAD with stack?
05:40:50 <mxf> quchen, MarcelineVQ: thanks, will try later. I'm hitting linker bugs with an older lts version, maybe I'm asking more dubious q's later ;)
05:41:04 <clamchowder> Yotam: OK thanks, what is the point of Real class by the way? https://hackage.haskell.org/package/base-4.9.1.0/docs/Prelude.html#t:Real does not have any descriptions and only has a toRational function
05:41:47 <quchen> mxf: Nuking all snapshots is a valid strategy
05:41:48 <lin_> MarcelineVQ: i did, did not work, now i am just trying to get flycheck from emacs running, (this time using arch repositories with stable versions)
05:42:00 <quchen> mxf: The price is you have to rebuild things you still need :-/
05:42:29 <MarcelineVQ> lin_: stack doesn't often like ghc's it didn't install itself, if you're trying to specify something like ghc HEAD you may be better off making a bin dist from ghc source and making a stack.yaml that uses it, something like   http://lpaste.net/357031  this would let stack sort out how it wants to handle ghc. I'm not sure you really want to be using stack with HEAD though because its resolvers aren't going to be super happy about 
05:42:29 <MarcelineVQ> ghc version, you'd have to figure that part out, I've not dealt with it.
05:42:36 <MarcelineVQ> Some arcane and eldritch combination of flags here  https://docs.haskellstack.org/en/stable/yaml_configuration/#non-project-specific-config   and here  https://docs.haskellstack.org/en/stable/custom_snapshot/  would be required
05:42:40 <Yotam> clamchowder: https://wiki.haskell.org/Exact_real_arithmetic
05:43:40 * hackagebot minio-hs 0.3.0 ‚Äì A Minio client library, compatible with S3 like services. ‚Äì https://hackage.haskell.org/package/minio-hs
05:43:55 <MarcelineVQ> Why did you need ghc head btw?
05:45:18 <clamchowder> wz1000: I don't know about automatic differentiation, will look into it, thanks.
05:46:09 <MarcelineVQ> clamchowder: there's an interesting automatic differentiation lib called  ad  iirc
05:50:28 <clamchowder> Yotam: thanks. That article does not really explain the purpose of the Real class though
05:51:49 <Yotam> Exact Real arithmetic is a way to represent numbers with infinite precision, but when you want to look at a result you'll need to decide on your precision (similar to handling [0..])
05:52:21 <Yotam> there is also the chance that do not speak of the same thing
05:56:31 <bash0r> Would you guys use a language that can pretty print to / parse from both, functional and object oriented code at once? (E.g. it can defunctionalize / refunctionalize specific code snippets directly tailored to your use case.)
05:57:22 <ertes-w> bash0r: that doesn't sound like a transformation that would actually work
05:58:00 <bash0r> ertes-w: it could. Professor Ostermann from University T¸bingen, DE is currently working on it. If he's right, such a compiler / tool is possible.
06:00:25 <bash0r> ertes-w: it's more a question, if somebody would use the benefits of both worlds or if you prefer to stick to one.
06:04:11 <bvad> bash0r: When I'm writing programs in languages that supports port (e.g. Scala) I actively avoid anything OOP
06:04:36 <ertes-w> bash0r: i seriously doubt it
06:04:42 <bvad> So no, I don't think I would use the language
06:04:48 <ertes-w> bash0r: but to answer your question, i wouldn't use OOP
06:04:54 <bash0r> bvad: imagine it more like you can switch to the OO-world when you need to add another constructor.
06:05:11 <bvad> bash0r: Add another constructor? I'm not sure I follow
06:05:44 <ertes-w> bash0r: you can't have the benefits of OO (i'm using that phrase lightly) without putting up with its deficiencies as well
06:06:01 <ertes-w> like subtyping and other non-sense
06:06:22 <bash0r> bvad: Let's say you have an ADT representing a syntax tree. When you need another syntax element to the syntax tree, you switch to the OO-world and edit all the functions in one place that need terms for this specific syntax construct.
06:06:44 <bash0r> After that you will switch back to the functional world and again, you see your pattern matches.
06:08:07 <ertes-w> bash0r: why would i need OO to do that?
06:08:17 <ertes-w> there are ways to make ASTs extensible algebraically
06:08:24 <quchen> ertes-w: I don‚Äôt think subtyping is strongly part of OOP. What drives me crazy is that objects in all popular OOP languages are about hiding state.
06:08:52 <quchen> ertes-w: Rust doesn‚Äôt have subtyping, but it still has the crazy ¬ªwhat is my state, how deep do I have to clone¬´ issue, for example.
06:09:06 <ertes-w> quchen: honestly i don't really know what OO is anymore‚Ä¶  if you consider all the things even OO people tend to avoid these days, it's pretty much just a syntactic thing
06:09:18 <bvad> bash0r: Do you have any concrete examples?
06:09:21 <ertes-w> "x.f" vs. "f x"
06:09:22 <bash0r> ertes-w: without that you need to open each source file containing a function using that particular type. The compiler will tell you where you need to go. Though, I for myself would prefer to get a prompt which functions need to be edited in my IDE or something.
06:09:34 <ertes-w> bash0r: no, you don't
06:09:46 <ertes-w> bash0r: that couldn't be called extensibility
06:10:11 <bash0r> ertes-w: But that's exactly what Haskell and other languages featuring (G)ADTs actually do right now.
06:10:21 <ertes-w> bash0r: it's people who do that, not languages
06:10:28 <quchen> ertes-w: ¬ªIf you have to model the platonic ideal of a chair in order to make a chair, then it‚Äôs OOP¬´ ;-)
06:10:43 <ertes-w> hehe
06:10:56 <bash0r> ertes-w: it's fairly easy to define a new function for an existing, fixed set of constructors for a type like "List" with "Nil" and "Cons".
06:11:33 <ertes-w> bash0r: your issue seems to be that you think "extending language/AST X" means "extending type X"
06:11:50 <ertes-w> but if you think that way, you would naturally gravitate toward OO solutions rather than algebraic ones
06:11:51 <quchen> An immutable OOP language might be interesting. I mean we can encapsulate methods and values in a tuple in Haskell as well, but working with it is not nice. I suspect that‚Äôs due to Haskell not being made for handling these things, not because they‚Äôre inherently bad.
06:11:56 <bash0r> ertes-w: in the OO-world we say to operate on a fixed set of functions and can then create additional classes deriving from List and instantiate the terms for, let's say length and append.
06:12:07 <ertes-w> bash0r: the proper algebraic solution is in terms of homomorphisms
06:13:12 <ertes-w> quchen: is that really something desirable?  to me that sounds like a purely syntactic thing, and i *really* prefer to write "f x" over "x.f"
06:13:14 <quchen> ertes-w: Defining FP is much easier: ¬ªhas map and filter¬´ ;-)
06:13:27 <ertes-w> hahaha yeah
06:13:29 <quchen> ertes-w: I don‚Äôt know. I meant the American ¬ªinteresting¬´, not the British one.
06:14:44 <quchen> > let (.) x f = f x in ("hello", "world").fst
06:14:47 <lambdabot>  "hello"
06:14:57 <quchen> (‚Ä¢_‚Ä¢)     ( ‚Ä¢_‚Ä¢)>‚åê‚ñ†-‚ñ†     (‚åê‚ñ†_‚ñ†)     YEEEEEAAAAAAAHHHHH 
06:15:03 <ertes-w> ugh
06:15:11 <Akii> :D
06:15:25 <ertes-w> > ("hello", "world") ^. _1  -- at least don't replace (.) =)
06:15:28 <lambdabot>  "hello"
06:15:52 <bash0r> ertes-w: No, that's not what I mean.
06:19:06 <quchen> ertes-w: Surely you meant ¬ªshadow¬´, not ¬ªreplace¬´ :-√æ
06:19:56 <ertes-w> quchen: path splitter!
06:22:44 <ertes-w> bash0r: if that's not what you mean i honestly don't understand
06:23:11 <ertes-w> bash0r: the way i see it this is about extending types, and my point is that it should never ever be done
06:23:15 <bash0r> ertes-w: I try to come up with a better example.
06:24:44 <ertes-w> bash0r: feel free, but to save you time: there is no example where i would agree that extending types would be a good idea
06:25:10 <bash0r> ertes-w: Actually, I agree with you in that point.
06:25:41 <ertes-w> bash0r: if you agree about that, then i may have misunderstood you
06:26:11 <ertes-w> if extending types is not what you're proposing, where does OOP come into play?
06:26:35 <bash0r> ertes-w: In Scala, you say trait MyType and then define case classes to define the "Constructors" in terms of GADTs.
06:27:26 <bash0r> ertes-w: By saying MyType to be an interface and only those case classes we know in Haskell as Constructors derive from MyType, this all forms a GADT.
06:27:55 <ertes-w> bash0r: so you have a trait Maybe and two case classes for Just and Nothing resp.
06:27:57 <ertes-w> ?
06:28:05 <bash0r> ertes-w: exactly
06:28:35 <bash0r> ertes-w: So the trait is just what we call Type and the case classes are Constructors in our ADT syntax.
06:28:56 <halogenandtoast> If I have a Text type that contains Japanese characters and I want it to print useful information when I run hspec, what should I do
06:29:07 <halogenandtoast> Currently I see things like: expected: "\12414\12385\12414\12377"
06:29:36 <bash0r> ertes-w: Now let's assume that we defunctionalize this thing. Then you get something like the visitor pattern. You need to add the visitor and every instance of it another case for the newly implemented constructor.
06:30:07 <ertes-w> halogenandtoast: you may be out of luck there‚Ä¶  you should probably file a bug report
06:30:10 <bash0r> ertes-w: You can translate that into extending the cases in every function that pattern matches on that type X.
06:30:41 <ertes-w> bash0r: you lost me completely there
06:30:45 <ertes-w> i have no idea what that means
06:30:55 <halogenandtoast> ertes-w:ÔºàÔæü–îÔæüÔºâ
06:31:00 <bash0r> ertes-w: damn sorry. I have no better idea to explain it.
06:32:09 <ertes-w> bash0r: now let's say you have an AST type called Lang
06:32:39 <ertes-w> bash0r: and you have an optimiser (optimise :: Lang -> Lang)
06:33:01 <ertes-w> bash0r: all this is about being able to extend Lang without having to worry about 'optimise' breaking, right?
06:33:15 <bash0r> ertes-w: If you give that ADT a new constructor like "CaseExpression", then you need to change the body of the function "optimizer".
06:33:30 <bash0r> ertes-w: Precisely, you got it.
06:33:41 <ertes-w> yes, this is the gist of the expression problem
06:33:47 <halogenandtoast> ertes-w: okay I found a "solution" by using https://hackage.haskell.org/package/unicode-show-0.1.0.2/docs/Text-Show-Unicode.html
06:34:10 <ertes-w> bash0r: my proposal is not to extend Lang at all, because Lang is that specific language
06:34:23 <ertes-w> it's not a family of language versions, but a precise language‚Ä¶  extending it would be wrong
06:34:40 <bash0r> ertes-w: But to put another layer with desugarings from the new language to the current one.
06:35:11 <ertes-w> not quite‚Ä¶  let's call the new language Rang
06:35:21 <bash0r> ertes-w: Okay
06:35:30 <ertes-w> what you should do is to provide translation functions from Lang to Rang
06:35:59 <bash0r> ertes-w: that's what I meant with desugarings.
06:36:30 <bash0r> ertes-w: But let's assume that the world is not that great and not everything went out as we planned previously.
06:36:53 <ertes-w> update :: Lang -> Rang  -- if this function is injective, then it's usually possible to translate the 'optimise' function in a mechanical way
06:37:04 <bash0r> ertes-w: So we need to refactor Lang and Rang. What now? Do you really want to touch all 200 functions that define the desugarings?
06:37:12 <ertes-w> especially if Rang is actually defined like this:  data Rang a = LangExpr (Lang a) | ‚Ä¶
06:37:50 <bash0r> So you want to generate the desugarings from Rang to Lang?
06:38:13 <ertes-w> not necessarily‚Ä¶  some functions only make sense for the Lang subset of Rang
06:38:39 <ertes-w> lang :: Prism' (Rang a) (Lang a)
06:38:56 <ertes-w> (lang %~ optimise) rangExpr
06:39:19 <bash0r> Just to be sure we're talking of the same Prism: https://hackage.haskell.org/package/lens-4.15.3/docs/Control-Lens-Prism.html
06:39:25 <ertes-w> yes
06:40:38 <bash0r> ertes-w: what exactly do you achieve with this? Avoid the refactoring of the specific subset?
06:41:21 <ertes-w> bash0r: this is an algebraic extension‚Ä¶  in algebra we never change things, we always translate
06:41:45 <ertes-w> bash0r: that's the whole idea of homomorphisms
06:41:54 <bash0r> ertews-w: Ahh okay now I see your point.
06:42:13 <ertes-w> bash0r: and then we can go as far as to relate languages to each other
06:42:24 <ertes-w> imagine that 'lang' is not just a prism, but an isomorphism
06:42:31 <ertes-w> then we know that Lang and Rang are really the same language in disguise
06:42:48 <ertes-w> at that point we can translate Rang optimisations *back* into Lang
06:42:49 <halogenandtoast> are there any tools/libraries for converting kanji to hiragana asks ÂæÖ„Å§ to „Åæ„Å§
06:42:49 <ertes-w> etc.
06:43:03 <halogenandtoast> s/asks/for example/
06:43:10 <halogenandtoast> no idea how I typoed that radically
06:43:12 <halogenandtoast> pun intended
06:44:00 <halogenandtoast> and by tools I mean in Haskell of course.
06:44:16 <bash0r> ertes-w: okay that makes sense to me. Can I read somewhere any further on that?
06:44:28 <ertes-w> bash0r: you can also establish a monomorphism partial order over languages:  if there exists a monomorphism from language A to language B, then language B is more expressive
06:44:42 <ertes-w> or rather: at least as expressive as A
06:45:10 <ertes-w> dually: if there is an epimorphism from A to B, then A is at least as expressive as B
06:45:27 <ertes-w> bash0r: pick your favourite introduction into either group theory or category theory =)
06:45:37 <ertes-w> group theory is usually easier to pick up
06:45:54 <bash0r> ertes-w: Damn, I get too many reasons in the last few weeks to actually read my copy.
06:49:17 <ertes-w> bash0r: in any case we embrace algebra as an actual practical design pattern in haskell; that's why you see all those math terms in our libraries‚Ä¶  it's not that we are just *inspired* by algebra, but we actually use it directly
06:58:39 <bash0r> ertes-w: So what about the use of Monad ((->) a), is it useful or does it make everything less readable?
07:00:40 <ertes-w> bash0r: it's useful and unrelated to readability
07:01:27 <bash0r> ertes-w: I've implemented some things that I guess weren't that readable anymore. It was just less obvious where parameters were passed.
07:01:34 <ertes-w> but again the true power of monads comes from two things: 1. functions defined over monads and effect classes, 2. monad morphisms
07:02:25 <ertes-w> and monads also really require a certain kind of syntax‚Ä¶  not necessarily syntactic sugar, but you really want (syntactically) lightweight lambdas and infix operators
07:03:13 <bash0r> ertes-w: That's why I love them in Haskell and hate them in Scala.
07:03:43 <ertes-w> scala is one of the few languages where you can even properly encode them such that you could benefit from them
07:04:06 <ertes-w> but languages like C# and even F# do *not* have monads
07:04:23 <[exa]> f# doesn't have monads?!
07:04:29 <ertes-w> they have particular monadically composed languages, but they do not have monads
07:04:43 <[exa]> whoa
07:04:47 <bash0r> ertes-w: Good to know, thank you!
07:09:06 <ertes-w> [exa]: F# does not support higher-kinded polymorphism
07:09:19 <ertes-w> no .NET language does
07:09:47 <deceract> q
07:15:26 <mizu_no_oto> <[exa]>: F# and C# use monads, but their type systems can't represent a monad interface.
07:16:47 <ertes-w> [exa]: practically speaking it means that you can have maybeReplicateM, parserReplicateM and eitherReplicateM, but you can't have replicateM
07:17:15 <ertes-w> you can't do things "for all monads"
07:18:35 <mizu_no_oto> <[exa]>: F#, for example, has "computation expressions", which is basically syntax sugar similar to do notation for monadic blocks.
07:19:49 <mizu_no_oto> And LINQ is almost a heavily extended monad comprehension syntax - it has bind and map, but it's missing return/pure.
07:22:06 <Yotam> ertes-w: by "do stuff" I am guessing you are not talking about function that can be build from bind/return/etc
07:26:05 <ertes-w> Yotam: i am
07:26:23 <ertes-w> Yotam: but not only that‚Ä¶  monad transformers also quantify over a monad
07:26:40 <ertes-w> instance (Monad m) => Monad (MaybeT m)  -- there is an implicit "for all" there
07:28:51 <mniip> omg
07:29:02 <mniip> someone implemented addition without any identifiers in scope
07:30:36 <ertes-w> mniip: SKI?
07:30:42 <mniip> no like
07:30:49 <mniip> add :: String -> String -> String
07:30:58 <ertes-w> err
07:30:59 <mniip> in something similar to import Prelude ()
07:31:22 <ertes-w> that doesn't sound too hard, but‚Ä¶  String?
07:31:40 <mniip> ertes-w, you cannot use any prelude-defined functions or constructors
07:32:00 <ertes-w> data Nat = Z | S Nat
07:32:11 <ertes-w> can i use that?
07:32:15 <mniip> sure
07:32:17 <mniip> but strings
07:32:54 <mniip> basically the full context is, implement a program that reads two numbers from stdin and outputs their sum to stdout
07:33:09 <mniip> the program has to begin with "import Prelude (getLine, print)\na=a"
07:33:27 <ertes-w> yeah, honestly that doesn't sound too hard
07:33:32 <mniip> go try
07:34:21 <AndiK> You could just copy the code from the prelude functions you would want anyway or do I muss something with that thought?
07:34:35 <ertes-w> the only difficulty i see is using the result of getLine
07:34:36 <Yotam> Someone knows how to quickly access stack msys installation without digging in folders?
07:34:41 <mniip> AndiK, you get Prelude.[] Prelude.Char as input
07:34:43 <ertes-w> because none of the list/Char functions are in scope
07:34:45 <mniip> you have to work with that
07:35:05 <ertes-w> well, you can pattern-match on Char
07:35:11 <AndiK> ^
07:35:19 <mniip> right
07:35:21 <ertes-w> for lists i'm not sure
07:35:33 <ertes-w> you can use list sugar
07:35:59 <mniip> hint: : is built-in syntax
07:36:13 <ertes-w> ah, yeah, that makes it easy
07:36:31 <ertes-w> now all you need is Nat with some basic operations (add, mul, integer div, modulo)
07:37:03 <ertes-w> then you can translate the input into Nat and back
07:37:35 <AndiK> We had to implement our own number type for uni assignments. It's annoying and without prelude functions has terrible performance but wouldn't say that it's hard from what I remember
07:37:47 <mniip> the numbers aren't hard
07:37:57 <mniip> it's figuring out all these annoyances of builtin types
07:59:54 <merijn> Anyone here ever call cabal from make? i.e. existing C/C++ buildsystem using make that has to call cabal for the haskell bits. How did you end up tracking whether cabal needs to run/rebuild? (if you did)
08:00:09 <AndiK> mniip: Like which ones in particular?
08:00:42 <ertes-w> merijn: .PHONY: my-haskell-target
08:01:08 <merijn> ertes-w: Yeah, that's the plan B
08:01:17 <merijn> ertes-w: Ideally I'd like something a little more sophisticated ;)
08:01:36 <ertes-w> it's plan A, unless you want to invoke GHC yourself =)
08:02:06 <merijn> ertes-w: cabal build can be kinda slow, so I was hoping I could avoid needlessly running it
08:02:37 <f-a> mhh apparently bot isn't pasting, so I'll do it myself: http://lpaste.net/357043 <-- why is this not picking up any keystroke
08:02:52 <ertes-w> merijn: GHC does support a bunch of -M* flags that correspond to the same flags in GCC
08:03:06 <ertes-w> you could use that‚Ä¶  or just depend on everything within the haskell part
08:03:22 <ertes-w> but ideally you should just keep the projects separate and combine them using a deployment system
08:03:23 <phadej> % time cabal new-build
08:03:23 <phadej> Up to date
08:03:23 <phadej> cabal new-build  0,06s user 0,01s system 98% cpu 0,065 total
08:03:28 <phadej> ^ quite fast, IMHO
08:03:36 <merijn> phadej: cabal new-build is out
08:03:49 <phadej> why?
08:03:57 <merijn> phadej: I spent 2 weeks trying to get error reporting/type querying working, I wasn't able to
08:04:21 <phadej> as in ghc-mod?
08:04:22 <merijn> phadej: So I'm switching back from new-build to sandboxes until someone else has time to fix things
08:04:29 <merijn> phadej: ghc-mod and hdevtools, yeah
08:04:59 <phadej> well, between new-build and ghc-mod I chose new-build :) YMMV
08:05:37 <merijn> phadej: lack of hdevtools utterly cripples my haskell productivity, so no, I definitely don't chose new-build
08:08:56 <phadej> merijn: that's why I said ymmv :) but thanks for opening an issue in hdevtools about new-build
08:09:16 <merijn> phadej: I actually already had a hacky way to hook up new-build into my makefiles, which is why I invested the 2 weeks to get ghc-mod/hdevtools working. But you need to remember sunk-cost at some point :)
08:10:26 <ertes-w> what is hdevtools?
08:11:07 <merijn> ertes-w: similar to ghc-mod, except it only does error/warning reporting and type querying
08:12:06 <ertes-w> merijn: for vim?
08:12:24 <merijn> ertes-w: Tool agnostic, but it works with vim via syntastic and vim-hdevtools
08:12:43 <ertes-w> merijn: no, i mean: do *you* use it for vim?
08:12:47 <merijn> yeah
08:13:35 <merijn> ertes-w: Although I don't think not using vim would help, as afaik there's no similar tool that supports new-build regardless of editor
08:14:25 <ertes-w> merijn: it's fairly easy to add support for other tools to haskell-mode‚Ä¶  i have integated nix, which was a matter of writing a small wrapper script
08:15:05 <merijn> ertes-w: Not entirely sure how that relates to the problem?
08:17:11 <ertes-w> merijn: well, all haskell-mode wants is a GHCi prompt‚Ä¶  if you can provide that, it will happily integrate with your tooling‚Ä¶  everything else comes for free, including what hdevtools does
08:17:52 <ertes-w> so i'm pretty sure you can easily add new-build support, if it's not there yet
08:17:58 <merijn> How can haskell-mode query the type of an expression from just ghci, considering ghci doesn't actually implement that afaik
08:18:14 <ertes-w> merijn: i have no idea =)
08:18:15 <ertes-w> but it does
08:18:35 <ertes-w> or do you mean the type of a subexpression?
08:18:50 <merijn> ertes-w: The type of any arbitrary (sub)expression anywhere in a source file
08:19:21 <ertes-w> ah, no, haskell-mode doesn't do that, but i can actually think of ways to implement it
08:19:47 <ertes-w> replace the part by a hole temporarily, reload, restore original
08:19:59 <merijn> ertes-w: nope
08:20:18 <merijn> ertes-w: That's not equivalent (it's what I did in the past)
08:20:30 <merijn> ertes-w: The holes can be more polymorphic/general than the actual expression
08:20:31 <ertes-w> merijn: in which cases does it differ?
08:20:41 <ertes-w> ah
08:21:06 <merijn> ertes-w: I used that *a lot* for navigating other people's codebases where you often don't know the type of things
08:21:41 <ertes-w> err‚Ä¶  i'm not actually sure‚Ä¶  do holes not respect the MMR?
08:21:58 <glguy> GHCi has :type-at for this sort of thing I think
08:22:16 <cocreature> I used to spend a lot of time getting ghc-mod to work so I can get the type info and now I actually have a setup where I can get type info and I don‚Äôt use it
08:22:21 <cocreature> glguy: yep but only since 8.0 iirc
08:22:54 <merijn> cocreature: With hdevtools it mostly "just worked" for me, and it's really ingrained in my editing now :\
08:23:17 <cocreature> merijn: are you still waiting two years before you upgrade to 8.0? otherwise just using ghci should do the job as glguy mentioned
08:23:41 <cocreature> although I guess running a ghci process in the background might be a bit painful in vim iirc
08:23:47 <merijn> cocreature: I'm at 8.0 now, but that'd still involve writing a plugin from scratch to use that ghci thing
08:24:08 <cocreature> merijn: well you need to send a command with your current position and display the output of ghci
08:24:12 <cocreature> that‚Äôs not that hard :)
08:24:18 <cocreature> (famous last words)
08:24:39 * ertes-w didn't know about :type-at, and it's not even listed in :?
08:24:47 <merijn> cocreature: Yeah, I also discussed with the author of ghc-mod how we could fix it with new-build, that was also "not that hard" :p
08:24:59 <ertes-w> i have to see if i can integrate that into haskell-mode somehow, because it would actually be nice to have that
08:25:09 <cocreature> ertes-w: I‚Äôm pretty sure it‚Äôs already integrated
08:25:54 <machinedgod> Hi all. I need help with digging out one Haskell blog article. Author talks about implementing eDSL's as a proper way of separating concerns, and specifically - he's showing how to do a cloud storage file management. I can't, for the love of god, remember the name of the guy, but i know he shaves his head and he kinda looks bulked-up on his picture.
08:25:58 <merijn> Incidentally, ghci-8.0.2 does not agree with yout that :type-at is in it
08:26:00 <cocreature> merijn: relying only on ghci has the advantage that if ghci doesn‚Äôt work any other tooling is also broken so it‚Äôs about as robust as you can get it :)
08:26:05 <ertes-w> nice!
08:26:10 <ertes-w> haskell-mode already has it =)
08:26:22 <ertes-w> glguy, cocreature: thanks, that's really neat!
08:26:24 <glguy> merijn: Yes, :type-at is in GHCi 8.0.2
08:26:39 <cocreature> merijn: you need :set +t iirc for it to work
08:27:27 <glguy> merijn: Here you go: https://downloads.haskell.org/~ghc/8.0.2/docs/html/users_guide/ghci.html?highlight=type-at#ghci-cmd-:type-at
08:27:30 <merijn> cocreature: Anyway, if I had the extra avilable time to implement my own plugin I'd just invest that time to fix ghc-mod, but alas :)
08:33:13 <machinedgod> Sorry, if anyone actually went googling too - I found it! Author's name is John A De Goes
08:35:45 <tabaqui> which vim tags plugin do you prefer?
08:35:45 <tabaqui> I was used fast-tags, but it looks broken now and hothasktags looks nicier
08:36:02 <tabaqui> *I used
08:37:18 <zomg> machinedgod: link to article if you also found that? sounded interesting :)
08:37:59 <machinedgod> zomg: Here you go: http://degoes.net/articles/modern-fp
08:38:12 <zomg> thanks
08:38:13 <machinedgod> zomg: And here's the part 2: http://degoes.net/articles/modern-fp-part-2
08:38:15 <machinedgod> Np :-)
08:43:22 <ertes-w> "The only advantage of the latter is that because it‚Äôs a value, it can be stuffed into data structures, lazily executed, retried until success, and so on. Which is all well and good, but it‚Äôs at best a token benefit over writing the same thing in C."
08:43:25 <ertes-w> i disagree
08:43:44 <ertes-w> because IO is pure, you can do equational reasoning, even with IO
08:44:50 <mniip> judgemental equality, not propositional (! important)
08:45:28 <cocreature> I should make a cheat sheet for different equalities. I always mix them up
08:47:00 <mniip> judgemental, propositional, extensional, intensional,
08:47:19 <mniip> observational (sp?)
08:48:15 <zomg> so ==, ===, ====, ===== and ====== ? :p
08:49:16 * hackagebot haskell-lsp 0.1.0.0 ‚Äì Haskell library for the Microsoft Language Server Protocol ‚Äì https://hackage.haskell.org/package/haskell-lsp
08:49:25 <petercommand> zomg: lolol
08:49:34 <cocreature> there is also contextual equality but maybe that‚Äôs the same as one already mentioned
08:49:41 <petercommand> you missed difinitional equality
08:49:45 <cocreature> and then you can use heterogenous and homogenous forms
08:49:51 <petercommand> *definitional equality
08:50:12 <mniip> definitional is kinda judgemental, not?
08:50:16 <zomg> I think we can ignore that, seven ='s is a bit too much
08:50:17 <cocreature> not always afaik
08:50:22 <mniip> hm
08:50:24 <mniip> true
08:50:27 <cocreature> judgmental always includes some kind of normalization
08:50:33 <cocreature> definitional not always
08:50:45 <dolio> No, it doesn't.
08:50:49 <cocreature> oh?
08:51:19 <cocreature> those lazy academics should finally decide what the right equality is so I don‚Äôt need to remember all this stuff
08:51:44 <ertes-w> for IO i'm happy with the "does the same thing" kind of equality =)
08:52:04 <cocreature> ertes-w: but which equality do you use for ‚Äúthe same‚Äù?
08:52:10 <ertes-w> modulo time/memory
08:52:12 <ertes-w> cocreature: no idea
08:52:15 <dolio> Judgmental is just whatever your equality judgments allow.
08:52:21 <ertes-w> i use the "does the same thing" equality =)
08:52:36 <dolio> You could even have more than one sort of equality judgment, too.
08:52:38 <machinedgod> "Thanks" for making me open about 4-5 new tabs to explain all the equalities to me. I was just working my way downwards and was almost at the point where all tabs fit on one screen
08:52:43 <ertes-w> but in reality i pretty much only use the monad laws
08:52:50 <ertes-w> + the equality laws
08:52:54 <machinedgod> I probably should go back to #haskell-beginners
08:53:05 <petercommand> when is judgemental equality different from definitional equality?
08:54:47 <petercommand> dolio: um, right
08:54:54 <dolio> I don't think it makes a ton of sense for 'equational reasoning' in Haskell to be about 'judgmental equality', either.
08:55:52 <dolio> Inasmuch as the latter is typically what is mechanized by the computer when applied to a machine checked language.
08:56:16 <dolio> But people use all kinds of equations that GHC doesn't use to reason about their programs.
08:57:56 <ertes-w> i'm afraid that the deeper i go into the equality notion when it comes to IO, the less it will make sense to even use equality
09:00:13 * hackagebot websockets 0.12.0.0 ‚Äì A sensible and clean way to write WebSocket-capable servers in Haskell. ‚Äì https://hackage.haskell.org/package/websockets
09:00:25 <mniip> you can apply extensional equality to IO
09:02:31 <ertes-w> i'm happy with the "same program or whatever" kind of equational reasoning about IO i have done so far‚Ä¶  fast and intuitive
09:03:00 <ertes-w> fast and loose and intuitive
09:03:02 <dolio> petercommand: I'm not sure "definitional equality" is as well defined as e.g. "judgmental equality".
09:04:11 <dolio> So it might depend on what you mean by the former.
09:04:43 <petercommand> dolio: I think definitional equality means equality up to beta reduction?
09:04:57 <dolio> In contexts where it means, "whatever is implemented automatically by the computer," it'd correspond to judgmental equality if you imagine a corresponding formal system.
09:05:33 <dolio> At least, usually it would.
09:07:46 <dolio> I think there are some contexts in mathematics, though, where "definitional equality" means that you have "defined" something to be abbreviated syntax for something else.
09:08:22 <dolio> And it's just referring to that.
09:08:43 <dolio> Absent any further equalities you could prove on the underlying thing.
09:11:57 <ertes-w> i'm almost sure that IO is not a monad under this particular notion of definitional equality
09:15:49 <clamchowder> Question: do monad laws imply applicative laws and applicative laws imply functor laws?
09:17:33 <Tuplanolla> Yes to all, clamchowder.
09:18:20 <clamchowder> Tuplanolla: thanks. Is there a reference to the statement?
09:18:23 <Tuplanolla> Did you mean to ask "do monad laws excluding applicative laws imply the excluded laws" instead?
09:18:49 <Tuplanolla> Depending on the formulation, the answer to that may be no.
09:20:07 <ertes-w> do excluded monad laws exclude the law of the applicative middle?
09:20:19 <clamchowder> Tuplanolla: I mean to ask: since monads are applicative functors, given a monad, ap and pure can be defined from bind and return. If the bind and return satisfy the monad law, does the corresponding ap and pure satisfy the applicative law?
09:21:04 <nshepperd_> If you include the laws that relate monad to applicative under "monad laws" then i think the answer is yes
09:21:15 <Tuplanolla> That should be the case.
09:21:29 <clamchowder> Is there a reference to this statement?
09:22:08 <clamchowder> Also is the same thing true for applicative functors and functors?
09:24:36 <Tuplanolla> However, I think it was the case that you can define `pure` and `join` without being able to extract `fmap` from them.
09:24:56 <mniip> ertes-w, what about the axioms for Choice
09:25:19 <Tuplanolla> This will not satisfy monad laws, but should fit your "monad-only laws", clamchowder.
09:25:35 <mniip> uh
09:25:41 <mniip> a monad doesn't make much sense without a functor
09:25:55 <mniip> by definition a monad is an endofunctor
09:26:30 <mniip> whether you can recover the fmap morphism is a good question but laws pretty much must hold
09:27:40 <mniip> for applicative the question is trickier, what is your definition of applicative
09:29:28 <clamchowder> mniip: the definition of applicative is f a with functions <*> and pure with proper signatures as in hackage: https://hackage.haskell.org/package/base-4.9.1.0/docs/Control-Applicative.html
09:29:43 <mniip> so
09:29:55 <mniip> a type family with a morphism family
09:29:59 <mniip> s.t laws hold
09:31:46 <clamchowder> sigh, I just saw the answer on the hackage page...
09:32:08 <Tuplanolla> Is the question about things that look like monads, but violate the applicative laws?
09:33:13 <clamchowder> Tuplanolla: no it's just a simple question, and the control.applicative hackage page answered it with "(which implies that pure and <*> satisfy the applicative functor laws)."
09:33:32 <Tuplanolla> Oh, I took it the wrong way then.
09:34:08 <clamchowder> mniip, Tuplanolla: Thanks.
10:08:50 * hackagebot orizentic 0.1.0.0 ‚Äì Token-based authentication and authorization ‚Äì https://hackage.haskell.org/package/orizentic
10:08:50 * hackagebot uri-parse 0.1.0.0 ‚Äì A simple library for parsing and generating URIs ‚Äì https://hackage.haskell.org/package/uri-parse
10:14:30 <Yotam> Someone knows how to quickly run stack msys shell from cmd easily?
10:37:04 <cocreature> Yotam: maybe "stack exec sh" works?
10:37:42 <Yotam> cocreature: Yea, thanks
11:12:57 <Gurkenglas> What libraries should I use in order to turn a JSON file that contains image links and information on how to cut and rearrange them into an image, into an image?
11:16:38 <pavonia> Gurkenglas: aeson for the JSON part, I'd say
11:17:00 <pavonia> Perhaps the ImageMagick binding fo the rest
11:18:18 <Gurkenglas> Sounds good. The image parts that the cutting produces and the rearranging requires are all equal-sized rectangles. Is ImageMagick at an appropriate level of abstraction for that?
11:21:00 <Gurkenglas> I shall write the "AsJSON a => a -> [[[b]]] -> [[b]]" first.
11:31:24 <f-a> https://hackage.haskell.org/package/base-4.9.1.0/docs/System-Info.html is there any way to see which strings can "os" possibly be?
11:32:14 <f-a> (or for cabal os(something)). I am using wine and it outputs mingw32, I don't know if it is unique to Wine or not
11:40:15 <pavonia> f-a: It's not
11:42:32 <f-a> pavonia: thanks
11:52:52 * hackagebot country 0.1.2 ‚Äì Country data type and functions ‚Äì https://hackage.haskell.org/package/country
12:04:32 <Unicorn_Princess> do you guys tend to use Lens for small projects as well? I think I saw some advice on how it's best for medium-large projects, but it seems pretty handy for small stuff too
12:04:45 <Gurkenglas> I sure do
12:04:56 <merijn> Unicorn_Princess: USe whatever you find convenient
12:05:29 <merijn> Unicorn_Princess: Probably people don't like lens as dependency for a small library. But if you're developing the library only for yourself or it's an application, then use whatever you want
12:06:41 <Unicorn_Princess> thanks. oh, the makeLenses ''ADTName lines - what are the '' that I see prepended for?
12:06:53 <merijn> Unicorn_Princess: Template Haskell syntax
12:06:59 <Unicorn_Princess> aaah
12:08:05 <Unicorn_Princess> huh. makeLenses doesn't work on type aliases?
12:09:27 <tikhon> Unicorn_Princess: I'd be happy using lenses everywhere except maybe libraries I expect other people to use‚Äîlens is a large dependency that not everybody wants to incur.
12:11:00 <shapr> tikhon: I like reading your writings, thanks!
12:11:08 <Unicorn_Princess> they shouldn't have made records so awful if they didn't want lenses... :P
12:11:25 <Gurkenglas> How should I cut images apart and rearrange the pieces? Randomly clicking through https://hackage.haskell.org/package/imagemagick leaves me thinking this isn't the right way to gather information.
12:12:16 <shapr> Gurkenglas: are you making jigsaw puzzles?
12:12:17 <tikhon> shapr: :)
12:12:39 <Gurkenglas> shapr, nah, trying to print custom decks from tabletop simulator
12:12:53 <tikhon> Gurkenglas: ImageMagick probably supports what you want to do, but I don't know how good the Haskell bindings are.
12:13:53 <tikhon> I've done some image stuff with JuicyPixels, but it doesn't give you any high-level operations.
12:14:12 <tikhon> It can read/write a bunch of formats to a Vector of pixels and then you can do stuff to the pixels in Haskell
12:14:24 <Gurkenglas> There are image files but they're not arranged in 3-per-row for printability, and some cards need to be duplicated
12:15:53 <mizu_no_oto> tikhon: have you seen http://hackage.haskell.org/package/microlens ?
12:17:06 <tikhon> mizu_no_oto: I've seen a few smaller lens libraries, but haven't used any of them
12:17:53 <tikhon> it does seem like a good solution for using lenses in implementing your library
12:18:18 <cocreature> I love when people use microlens but forget that they also depend transitively on the big lens library ‚Ä¶
12:18:49 <tikhon> to be fair, transitive dependencies are hard to track‚Äînot the best UX
12:19:25 <cocreature> sure but if you care about keeping the dependency footprint of your library small then that‚Äôs what you need to do
12:19:38 <cocreature> and if you don‚Äôt care about that you might just as well use lens itself
12:21:15 <Gurkenglas> What's the quick&dirty way to turn an url into a (temp?) file?
12:21:58 <mizu_no_oto> Gurkenglas: curl? :p
12:22:37 <phadej> parseUrl url >>= httpLbs >>= LBS.writeFile file . responseBody
12:22:38 <Gurkenglas> https://hackage.haskell.org/package/curl sounds like a thing that wouldn't work on Windows. Does it?
12:23:04 <cocreature> I would expect curl to have windows support
12:23:15 <tikhon> I think I've used http-client before
12:23:17 <tikhon> https://hackage.haskell.org/package/http-client
12:23:18 <cocreature> but phadej‚Äôs solution is better
12:23:50 <phadej> (that's from http-client)
12:24:17 <phadej> also, I cannot make my mind, import qualified Data.ByteString.Lazy as LBS or BSL?
12:24:41 <tikhon> I like LBS
12:25:02 <tikhon> but you could compromise and cycle the three letters each time you use it
12:26:02 <cocreature> lbs
12:26:22 <phadej> I made a poll https://twitter.com/phadej/status/887755277482819584 
12:27:00 <shapr> BSL is winning
12:27:16 <Tuplanolla> My configuration has it `BSLazy`.
12:28:48 <phadej> the bonus question is for: Data.ByteString.Lazy.Char8, LBS8/BSL8/? :)
12:29:02 <tikhon> I could go with LazyBS to differentiate it from BS that took hard work
12:29:40 <Gurkenglas> What should I use for the "file" filepath if I only need it because I have one library that saves to a file and another that reads from a file
12:30:04 <cocreature> phadej: the right answer is obviously to not use Char8 :)
12:30:36 <Gurkenglas> Is there some sort of filepath that also works on Windows and tells the OS as if I wrote to hard disk, but leave it in RAM?
12:30:45 <Gurkenglas> *the OS to act as if
12:30:52 <koala_man> nope
12:32:14 <phadej> Gurkenglas: i'm pretty sure the "another library" can read from ByteString
12:32:35 <phadej> Gurkenglas: otherwise I'll really reconsider whether to use that library
12:32:58 <phadej> (or Text, or some other value)
12:33:17 <Gurkenglas> Perhaps. I went for hip because it has crop and superimpose, but here's the io docs https://hackage.haskell.org/package/hip-1.5.3.0/docs/Graphics-Image-IO.html
12:33:27 <Gurkenglas> Feel free to recommend something better
12:34:04 <phadej> Gurkenglas: https://hackage.haskell.org/package/hip-1.5.3.0/docs/Graphics-Image-IO-Formats.html#t:Readable
12:34:19 <phadej> `decode` consumes strict ByteString
12:36:14 <Gurkenglas> Thanks. Do you know how I should know what format to use, if I only crop and superimpose anyways?
12:36:33 <phadej> Gurkenglas: no idea, I just click around the haddock docs :)
12:43:45 <XorSwap> phadej: is that vinny pugh in your twitter pic?
12:45:20 <phadej> XorSwap: yes, the soviet one
12:46:36 <Gurkenglas> Gah its readFile takes a path and guesses the format but the decode wants me to supply it and it does implement a guessFormat function but doesn't export it and that seems to use parts from all over the place in order to have me not just copy it into my code
12:58:12 <cocreature>  make a PR to export it :)
13:00:35 <ahri> i don't understand why i can't use `f :: (Monad m) => m -> m'; i.e. Monad as a class constraint - can anyone explain this to me?
13:01:03 <kadoban> ahri: Are you familiar with kinds by any chance?
13:01:04 <geekosaur> actually that signature?
13:01:53 <ahri> kadoban: i have a vague understanding that Monad is of kind '* -> *', and i need a kind of '*' - but not enough understanding to get to that point
13:02:43 <geekosaur> what do you imagine a value of type Maybe (as opposed to, say, Maybe Int ) to be?
13:03:09 <ahri> geekosaur: no, not that signature exactly, i was just using a simple example, sorry
13:03:38 <kadoban> ahri: Oh. My question has a lot to do with why that exact signature wouldn't work.
13:03:46 <ahri> geekosaur: i guess it's not a concrete type yet?
13:03:52 <geekosaur> right
13:04:00 <geekosaur> that's what kind * means
13:04:02 <glguy> What's a concrete type?
13:04:19 <glguy> People seem to have different ideas for what that means
13:04:36 <geekosaur> and all values have kind *. something like "Maybe" is incomplete, it cannot have values, it needs a *type*
13:04:56 <ahri> hm, so what i want to express is "give me something i can use the >> operator on", which seems like 'Monad' should cover it regardless of the kind
13:05:07 <geekosaur> so we say its kind is * -> * (it is a "type function" that takes a type of kind * and produces a type of kind *)
13:05:10 <glguy> Right, all values have types that have kind *
13:05:27 <glguy> and >> only makes sense to use with values, it lives at the value level
13:05:36 <geekosaur> ahri, that is expressed as "m a" for otherwise unspecified "a"
13:06:14 <glguy> :t (>>)
13:06:16 <lambdabot> Monad m => m a -> m b -> m b
13:06:18 <geekosaur> (>>) requires a value, so its type must be expressed in terms of things that have values (thus "m a" instead of just "m")
13:06:46 <ahri> oh.... hm... yes i think i see
13:07:48 <geekosaur> eta reduction doesn't happen here because the implementation requires values. (and I suspect it would be far too confusing if it were permitted)
13:08:05 <geekosaur> alos, for something like (>>), note that the value type changes!
13:08:32 <geekosaur> as glguy showed, we start with an (m a) and an (m b), and get an (m b), so you can't reduce it away anyway
13:09:32 <glguy> The reduction might make some initial intutive sense, but it doesn't make much sense in general
13:09:46 <glguy> (->) is just another type
13:10:15 <glguy> it would be strange for 't u u' to mean 't (u a) (u a)' in some strange context
13:10:56 <geekosaur> it would be, but then I look at some of the type aliases used by e.g. parsec and servant and it's much the same thing :/
13:11:20 <glguy> I don't know which thing you're thinking of
13:11:56 <ahri> i _really_ don't get the (->) being a type thing...!
13:12:10 <ahri> isn't it syntax?
13:12:19 <merijn> ahri: Why would it be syntax?
13:12:30 <nshepperd_> -> is a type operator
13:12:41 <nshepperd_> It's like Maybe, but infix
13:13:14 <glguy> (->) and Either are both types with kind * -> * -> *
13:13:15 <nshepperd_> The kind is * -> * -> *
13:13:34 <glguy> (Either Bool) and Maybe are both types with kind * -> *
13:14:21 <glguy> there's the separate dimension of the syntax being used either prefix or operator application.   Int `Either` Bool   is Either being used as an operator
13:14:35 <glguy> (->) Int Bool   is a prefix version of a function
13:15:02 <nshepperd_> :t id :: (->) Int Int
13:15:04 <lambdabot> Int -> Int
13:15:39 <glguy> > (+) 10 15
13:15:41 <lambdabot>  25
13:15:45 <glguy> > 7 `mod` 4
13:15:47 <lambdabot>  3
13:17:18 <ahri> ah, so (->) is a function at the type level?
13:17:48 <phadej> yes
13:17:51 <glguy> Yeah, by virtue of its kind
13:17:56 <phadej> :kind (->)
13:17:57 <glguy> or at least as witnessed by its kind
13:18:07 <phadej> > :kind (->)
13:18:09 <lambdabot>  <hint>:1:1: error: parse error on input ‚Äò:‚Äô
13:18:12 <phadej> silly lambdabot  :(
13:18:17 <phadej> @kind (->)
13:18:19 <lambdabot> * -> * -> *
13:18:19 <glguy> :k (->) -- better?
13:18:20 <lambdabot> * -> * -> *
13:18:40 <phadej> :)
13:18:55 <phadej> @kind StateT
13:18:56 <lambdabot> * -> (* -> *) -> * -> *
13:19:06 <dfeuer> @kind Category
13:19:07 <lambdabot> (k -> k -> *) -> Constraint
13:19:16 <phadej> :)
13:19:33 <ahri> i find the term "witnessed" weird, coming from an procedural/oo world
13:19:59 <glguy> Why's that?
13:22:19 <ahri> how can something be a function "as witnessed by its kind"? how can a kind witness anything?
13:22:39 <ahri> i guess the word is being used in an unfamiliar way
13:23:01 <glguy> (witness to) give or serve as evidence of; testify to
13:23:10 <danilo2> Hello guys! I'm benchmarking some of my functions and have found a very strange behavior. I've got line `let src = reverse $ take (convert textDiff) $ drop (convert spacDiff) $ history` and I do NOT use this variable anywhere. However if I remove this line, the time changes about 0.2s. 
13:23:21 <danilo2> I'm using -O2 and -XStrict 
13:23:53 <glguy> danilo2: It gets faster when you remove that line?
13:23:54 <danilo2> However, there is no time difference when not using -XStrict. It shows me that GHC does not optimize such unneeded variables. 
13:24:00 <danilo2> glguy: yes
13:24:12 <glguy> Right, if it doesn't have to evaluate src, then it will go faster
13:24:25 <glguy> XStrict forces src to be evaluated to at least WHNF
13:24:28 <danilo2> glguy: but why GHC evaluates it if it is not used anywhere ?
13:24:43 <geekosaur> XStrict?
13:24:43 <danilo2> glguy: why it needs WHNF ?
13:24:44 <glguy> Because you used it by turning on XStrict and implicitly adding strictness to that pattern
13:24:50 <ahri> glguy: ok, the kind (* -> * -> *) serves as evidence that (->) is a type function taking two arguments, then?
13:25:00 <glguy> ahri: yeah
13:25:06 <geekosaur> -XStrict doesn't mean "magically sometimes lazy"
13:25:09 <danilo2> glguy: I was sure it will need whnf when pattern mathcing on constructor, not purte variable
13:25:28 <glguy> danilo2: No, that would be surprising
13:26:08 <danilo2> glguy: hmm, maybe, I was somehow sure it works this way. Thanks for the clarification!
13:26:51 <mnoonan> does XStrict have laziness annotations the way normal Haskell has strictness annotations?
13:26:59 <danilo2> mnoonan: yep
13:27:00 <geekosaur> ~ iirc
13:28:48 <ahri> i think i'm still missing something about kinds; i changed my code to use 'Monad m => m a' and i now get; 'Couldn't match type ‚Äòm‚Äô with ‚ÄòEither Error‚Äô' with the elaboration - Expected type: m ([Command], [Event]), Actual type: Either Error ([Command], [Event]). is this in some way related to the fact that the monad I picked is Either and it's of kind '* -> * -> *'?
13:29:17 <glguy> ahri: You can't replace 'Either Error' with 'm' and still treat it like an Either Error
13:29:39 <glguy> If your type signature promises to work for any 'm' at all, you can't make any assumptions about that choice of m
13:31:18 <glguy> Suppose we have a definition for ahrisThing :: Monad m => m ([Command],[Event])
13:31:50 <glguy> We could use various types for 'm': Maybe ([Command],[Event])
13:32:08 <glguy> So the implementation of ahrisThing better not assuming that we're going to pick Either Error
13:33:56 <ahri> oh, yes, i see the difference now between (>>)'s definition/impl and mine; ok, so i can't be so general
13:33:58 <glguy> More specifically the type variables in a type signature are imlicitly "universally quantified"
13:34:08 <glguy> implicitly*
13:37:04 <ahri> ah that's something i don't understand; that's the 'forall' bit, right? i noticed that PureScript (which i've not tried) requires the explicit use of forall
13:40:51 <glguy> Yes, that's right.
13:42:22 <ahri> i'll read up on that. :\
13:43:19 <ahri> every time i ask questions in here i realise i know even less than i thought i knew. and i end up deleting lots of code because i have a more elegant solution. i'm not exactly sure how that makes me feel!
13:44:10 <Tuplanolla> Do we have the tools to, say, track that an `Int` never exceeds 255 in the intermediate computations of an existing function?
13:44:53 <ahri> (or that a String only contains certain characters?)
13:45:18 <glguy> Tuplanolla: You could make a newtype around Int that implemented those restrictions in its implementation of (+), but not beyond that
13:47:10 <Tuplanolla> Integer overflows are an annoying bunch.
13:54:33 <merijn> Tuplanolla: We do!
13:54:38 <merijn> Tuplanolla: Google Liquid Haskell
13:55:17 <Tuplanolla> Isn't that a bit different?
13:55:26 <merijn> Tuplanolla: A bit different in what sense?
13:55:39 <merijn> It's a tool, it tracks that kinda thing :p
13:58:17 <dolio> That seems like the kind of thing liquid haskell can do.
13:59:40 <Tuplanolla> Hmm, maybe I was mentally too set on dynamic analysis to see it this way.
13:59:46 <MarcelineVQ> what would that looks like I wonder, boundedAdd : Fin 255 -> Fin 255 -> Either ArithError (Fin 255)
14:00:47 <dolio> That's the kind of thing you don't want.
14:04:35 <MarcelineVQ> dolio: the typical overhead of type tracking that or the clunky either?
14:04:58 <dolio> Well, the overhead is way more than the cost of adding, so that's pretty bad.
14:05:30 <MarcelineVQ> sometimes you really don't want the jet fighter to crash, but I agree
14:06:01 <orzo> I'm using the psqueues package, and I usually need the OrdPSQ, but now I have an instance where I want IntPSQ. Is there a way to use the same type for each and have it specialize to IntPSQ when parameterized with Int keys?
14:06:07 <dolio> The API isn't great to use, either, but that's probably the smaller problem.
14:06:44 <dolio> Yeah, well, maybe that isn't the only way to ensure that your fighter jet doesn't crash.
14:06:56 <MarcelineVQ> hopefully not :>
14:07:30 <dolio> Also maybe your fighter jet crashed anyway, because you missed a realtime deadline using bulky arithmetic operations. :)
14:08:14 <Tuplanolla> The "don't care" option is to use `Integer` everywhere.
14:09:06 <geekosaur> good luck stuffing an Integer into a device register / other external hardware though
14:12:55 <dolio> Anyhow, what you probably want, ideally, is a system where you can write something that turns into just arithmetic, and allows you to ensure you don't violate your invariants over larger chunks of code than every single addition.
14:14:22 <dolio> So that you only have to test at the boundaries or something.
14:15:14 <XorSwap> you're thinking of some kind of compile time check?
14:15:26 <dolio> And liquid haskell can do stuff like that.
14:16:44 <dolio> Yeah, a compile time check that isn't just people staring at the code for a while and declaring it good. :)
14:16:59 <dolio> Which is probably what happens in most stuff.
14:18:33 <ahri> thanks a lot for your help in understanding kinds :) i'd better go to sleep now
14:21:51 <thoughtpolice> Tuplanolla: Yes, Liquid Haskell can do this; for example you can ensure your unsigned Word8 never overflows, etc. An example: https://ucsd-progsys.github.io/liquidhaskell-blog/2017/03/20/arithmetic-overflows.lhs/ which lets you flag things like `x < x + 1`, etc
14:23:36 <Tuplanolla> This says nothing about intermediate computations, it appears.
14:23:49 <Tuplanolla> Let me slap together a less trivial example.
14:26:01 <Tuplanolla> @let irt k n | n <= 1 = n | otherwise = let p = k - 1; f r m | m < r = f m (quot (p * m + quot n (m ^ p)) k) | otherwise = r in f (n + 1) n
14:26:02 <lambdabot>  Defined.
14:27:39 <dolio> For instance, at some point someone verified that there were no out-of-bounds accesses in vector-algorithms, I've heard.
14:27:40 <Tuplanolla> > fmap (irt 2 &&& floor . sqrt . fromIntegral) [1 .. 64] -- It's integer root, if that wasn't clear from the definition.
14:27:43 <lambdabot>  [(1,1),(1,1),(1,1),(2,2),(2,2),(2,2),(2,2),(2,2),(3,3),(3,3),(3,3),(3,3),(3,...
14:27:53 <dolio> And I should really contact them and get that some time.
14:28:52 <Tuplanolla> Alas, there's no guarantee that intermediate values don't overflow.
14:29:39 <Tuplanolla> How well does Liquid Haskell fit this problem?
14:30:39 * hackagebot language-ninja 0.1.0 ‚Äì A library for dealing with the Ninja build language. ‚Äì https://hackage.haskell.org/package/language-ninja
14:31:37 <Tuplanolla> The ultimate goal is to detect and eliminate all potential overflows.
14:41:46 <dolio> Tuplanolla: You only care that the result value isn't above 255, and don't care about intermediate values, you mean?
14:42:22 <Tuplanolla> I care about all values, intermediate or not, dolio.
14:42:26 <dolio> Oh.
14:43:12 <dolio> I think it's possible to try and prove that. I don't know how easiy it will be.
14:48:39 <Tuplanolla> > irt 2 255 :: Word8 -- That actually happens with the example.
14:48:41 <lambdabot>  0
14:48:59 <Tuplanolla> > irt 2 255 :: Word16
14:49:01 <lambdabot>  15
14:55:59 <thoughtpolice> I... Don't think that will be easy to prove in some magical way. You need an actual proof to accomplish something like that I imagine, or you need to strengthen your assumptions about the function in question.
14:57:03 <Tuplanolla> My original plan was to test the edges of the domain for the integral types of interest, but even that way detecting overflows takes work.
14:57:37 <Tuplanolla> Trap representations would be nice to have.
14:58:01 <NemesisD> is it possible to write f :: (m a -> n b) -> (m (a, s) -> n (b, s))
14:58:52 <Tuplanolla> Are you trying to map `StateT` when you should be mapping `ReaderT`, NemesisD?
15:00:02 <NemesisD> Tuplanolla: yeah, i've got  newtype MyMonad m a = MyMonad (StateT InternalState m a), and i'm trying to write mapMyMonad :: (m a -> n b) -> MyMonad m a -> MyMonad n b
15:01:23 <Tuplanolla> :t hoist
15:01:25 <lambdabot> error: Variable not in scope: hoist
15:01:33 <Tuplanolla> :t Control.Monad.Morph.hoist
15:01:34 <lambdabot> (Monad m, Control.Monad.Morph.MFunctor t) => (forall a. m a -> n a) -> t m b -> t n b
15:02:18 <Tuplanolla> This is probably the closest you'll get, unless you switch to `ReaderT` for that part.
15:04:07 <glguy> I think this might be the best you can do without the rank-2 type (and it's not what you want)
15:04:08 <glguy> :t (\f m -> liftA2 (,) (f (fmap fst m)) (fmap snd m))
15:04:10 <lambdabot> Applicative f => (f a1 -> f a) -> f (a1, b) -> f (a, b)
15:05:31 <NemesisD> Tuplanolla: i don't think hoist is quite right because a -> a, b -> b
15:06:01 <Tuplanolla> Looks like I could detect overflows by porting my code to C and running UBSan on it.
15:06:38 <glguy> NemesisD: Yeah, hoist is about as good as it gets. Notice that it's not (a -> a) -> (b -> b)
15:06:51 <glguy> it's (forall a. ...) -> (forall b. ...)
15:06:56 <NemesisD> sooo, am i screwed?
15:07:50 <glguy> You just need to figure out how to use the type signature of hoist to do what you had in mind
15:10:34 <NemesisD> actually now that i think of it, i don't really need m a -> n b, m a -> n a may work fine
15:11:22 <NemesisD> i think it may just suffice to derive MFunctor for MyMonad
15:29:58 * hackagebot deepseq 1.4.3.0 ‚Äì Deep evaluation of data structures ‚Äì https://hackage.haskell.org/package/deepseq
15:29:58 * hackagebot unix 2.7.2.2 ‚Äì POSIX functionality ‚Äì https://hackage.haskell.org/package/unix
15:41:03 <manek> Hi! Would anybody be so nice and explain to me why this function is about 40 times slower than mapM_ (measured with criterion): repeatM :: Monad m => Int -> m a -> m (); repeatM 0 _ = return (); repeatM i f = f >> repeatM (pred i) f ; {-# INLINE repeatM #-}
15:43:03 <Tuplanolla> Is `repeatM i f = let r !i = f >> r (pred i) in r i` any faster, manek?
15:43:28 <Tuplanolla> I accidentally left out the base case.
15:44:28 <glguy> the strictness of 'i' isn't an issue
15:44:42 <Tuplanolla> Yes, but I don't pass `f` through every time there.
15:46:04 <Tuplanolla> With the base case `repeatM i f = let r 0 = pure (); r i = f >> r (pred i) in r i`.
15:46:25 <glguy> 'i - 1' is faster than 'pred i'
15:46:40 <glguy> (pred checks for underflow)
15:46:58 <glguy> but I think that's probably not the issue either
15:47:08 <glguy> more likely that the benchmarking code is wrong in some way 
15:48:28 <manek> Tuplanolla: It is, it is even 2 times faster than MapM
15:49:40 <manek> Tuplanolla, glguy , ok but why I've got so different results? In fact the benchmarking code is very strange too - I'm just calling one milion times State's "get" function and I'm wondering why:
15:49:58 <manek> 1) using mapM_, my function and Tuplanolla's one I've got so different time results
15:50:22 <manek> 2) why GH doesnt optimize it to just nothing (I call "get" and nothing more, passing 0 in evalState)
15:50:37 <glguy> manek: Your test case is probably optimizing the nonsense code to nothing in some of the cases
15:50:37 <manek> *GHC
15:52:28 <manek> glguy, Tuplanolla : here is the full code: http://lpaste.net/357055
15:53:14 <manek> glguy, Tuplanolla : as you can see it just does nothing, but If you measure it, the evaluation using mapM takes 3ms and using Tuplanolla's function about 1ms
15:53:38 <manek> I'm just wandering why it doesnt optimize it completely away
15:54:01 <Tuplanolla> What are the uncertainties on those?
15:54:26 <manek> 13% and 15%
15:54:47 <manek> (according to criterion)
15:55:26 <Tuplanolla> Well, I don't know. GHC can be unpredictable with performance.
15:56:00 <manek> Tuplanolla: uh :( And why your function is so much better than mine? Where is this difference coming from?
15:56:55 <Tuplanolla> Since GHC can't inline recursive definitions endlessly, it has to pass `f` through to every call of your function, manek.
15:57:08 <Tuplanolla> I avoid that by capturing `f` in the enclosing context.
15:57:39 <Tuplanolla> As for glguy's suggestion, it's simply less work to do.
15:58:20 <Tuplanolla> These rule-of-thumb estimates only work as long as GHC doesn't catch onto them.
15:59:25 <Tuplanolla> Dump Core (not core) and inspect it to see how they actually compile.
15:59:35 <manek> Tuplanolla: Ok, so I understand that GHC cannot discover that this `f` is not changed and in fact can be automatically captured this way. 
15:59:59 <manek> Tuplanolla: so the question for me is now why it isnt optimized completely away, I'll dump core now and see what i get!
16:00:20 <Tuplanolla> Don't forget to `-dsuppress-all`.
16:02:30 <manek> Tuplanolla: ok! Should I use ghc-core or something else?
16:02:44 <Tuplanolla> Just `ghc` should do.
16:08:21 <eacameron> Anyone know of a 3d bin packing algorithm written in Haskell?
16:09:51 <eacameron> Aha, Binpack
16:13:25 * hackagebot acid-state 0.14.3 ‚Äì Add ACID guarantees to any serializable Haskell data structure. ‚Äì https://hackage.haskell.org/package/acid-state
16:16:03 <jared-w> "use regular data structures as your database and get stronger ACID guarantees than most RDBMS offer"
16:16:25 <jared-w> I mean, that's cool, but I don't exactly use RDBMS for the ACID guarantees :p
16:28:12 <eacameron> jared-w: What do you use them for? Relations?
16:29:43 <jared-w> Well sure, but other things as well. Relations, storing data, accessing it in powerful ways. Keeping data sanitizing inside the database so that other applications can access the data as well (which is really the important point for me), and so on
16:30:32 <jared-w> For me, so far, if I've got enough data that's important enough to where I care about ACID guarantees, I want a database and I probably screwed up somewhere if I don't already have one. If I don't care about ACID, I probably have a very small amount of data that nobody else needs to use except my haskell program
16:30:48 <srb> Does anyone know where built-in deriving (Eq, Ord, etc.) implementations live?
16:31:11 <srb> I tried browsing the GHC sources but I could'nt track it down
16:31:13 <jared-w> Even then, sometimes I want to use a database from the start, especially when working with anything 'server' related like web servers or anything that's traditionally thought of in a database-like manner
16:48:47 * hackagebot hw-balancedparens 0.1.0.1, hw-bits 0.5.0.1, hw-conduit 0.2.0.1, hw-hspec-hedgehog 0.1.0.0
16:48:47 * hackagebot  ‚Üí https://hackage.haskell.org/packages/recent
16:56:49 <ReinH> Does anyone happen to know the technical details of acid-state? Does it use undo logging or redo logging? etc
16:57:17 <joebobjoe> what is a pure functional programming language that is lazy like haskell but closer to category theory (or at least uses the terminology correctly)
16:58:13 <ReinH> joebobjoe: How does Haskell use the terminology incorrectly?
17:06:03 <srb> Does anyone know what C:Eq means in core?
17:08:59 * hackagebot hw-kafka-avro 1.1.0 ‚Äì Avro support for Kafka infrastructure ‚Äì https://hackage.haskell.org/package/hw-kafka-avro
17:13:13 <EvanR> srb: paste the context it appears in?
17:14:59 <srb> EvanR: $fEqExpr = C:Eq $fEqExpr_$c== $fEqExpr_$c/=
17:15:59 * hackagebot hw-kafka-client 1.1.3 ‚Äì Kafka bindings for Haskell ‚Äì https://hackage.haskell.org/package/hw-kafka-client
17:16:05 <EvanR> im going to guess it stands for "class Eq"
17:17:34 <srb> EvanR: Ah, OK, so it's the constructor of the `Eq` dictionary.
17:18:03 <EvanR> its creating an instance
17:18:07 <EvanR> thats my guess
17:18:33 <EvanR> yeah a dictionary
17:22:08 * hackagebot hw-kafka-client 1.1.4 ‚Äì Kafka bindings for Haskell ‚Äì https://hackage.haskell.org/package/hw-kafka-client
17:28:13 * hackagebot hw-kafka-conduit 1.1.4 ‚Äì Conduit bindings for hw-kafka-client ‚Äì https://hackage.haskell.org/package/hw-kafka-conduit
17:33:08 <srb> If I have foo :: Bool -> Bool -> Bool where foo x y == x ==y, and foo is NOINLINE, I get foo = $fEqBool_$c== in my core even with optimization. Shouldn't it optimize further than this?
17:34:30 <EvanR> to what
17:35:12 <ReinH> const True, perhaps.
17:35:17 <srb> either case dispatch or an equality primop
17:36:17 * hackagebot hw-parser 0.0.0.2 ‚Äì Simple parser support ‚Äì https://hackage.haskell.org/package/hw-parser
17:37:02 <EvanR> like, inline the code for bools equality test? hmm. does that makes sense since that code is not really available?
17:37:20 <EvanR> its in the stdlib
17:37:50 <EvanR> i wonder how cross module inlining ties into this
17:39:43 <srb> EvanR: I don't mark it NOINLINE, it's optimized at its call-sites to a case-tree
17:40:20 <EvanR> maybe its taking NOINLINE seriously
17:40:28 <srb> maybe it doesn't get inlined because the assumption is that foo would be inlined, and it doesn't want to create code bloat
17:54:30 <monadhelp> Hello I am banging my head against a wall(fig. of course) trying to map an id across tuples, but my goal is to get a tuple in return
17:55:35 <monadhelp> I want to end up with [(Id*Orignal*, [Id*New*])]
17:55:58 <monadhelp> do I need to use sequence [] or will mapM alone do?
17:58:57 <geekosaur> you can't sequence a tuple that way
17:59:19 <geekosaur> a tuple is not iterable, aside from lens/generics hacks
18:00:43 <monadhelp> but you can map a function across a tuple?
18:01:07 <geekosaur> no?
18:01:23 <geekosaur> rather, you can map a function across one element of the tuple
18:01:25 <geekosaur> not both
18:01:34 <geekosaur> that requires iteration, or a different typeclass
18:01:39 <geekosaur> http://hackage.haskell.org/package/base-4.9.1.0/docs/Data-Bifunctor.html
18:01:45 <srb> fmap f (a, b) = (a, f b)
18:02:12 <EvanR> bimap f g (a,b) = (f a, g b)
18:03:23 <pacak> monadhelp: "map an id across tuples"?
18:03:46 <EvanR> i dont really understand Id*New*
18:04:08 <monadhelp> sorry for the confusion y'all
18:04:21 <geekosaur> monadhelp, a tuple is not a funny-looking list, it's a funny-looking record. do you expect to "map" across data Foo a = {fe :: String, fi, :: Int, fo :: Bool, fum :: Maybe Double} ?
18:05:23 <monadhelp> I guess what I mean is that I want to keep the first element, and replace the other elements that make up the "record" with numbers using a count function
18:06:01 <pacak> (a, b, b, b, b, b, b) to (a, 6) ?
18:06:49 <pacak> You can do that with generics, but I strongly suspect that  you are doing something wrong.
18:07:05 <EvanR> i dont think anyone knows what you want to do
18:07:19 <Axman6> monadhelp: can you give an example of inputs and expected outputs?
18:07:22 * geekosaur is just confused at this point...
18:07:29 <Axman6> because I think we're all very confused
18:08:47 <monadhelp> sort of, right now my data is structured [[ kid1 [purchase1,purchase2]], [ kid1 [purchase1,purchase2,purchase3]]....]
18:09:15 <monadhelp> and I want to use a specific count function that I have to replace that purchase with the number of items purchased
18:09:33 <pacak> Those are lists.
18:09:43 <monadhelp> so i end up with [[ kid1 [2,3]], [ kid1 [1,3,2]]....]
18:09:52 <EvanR> is kid1 a function
18:10:04 <monadhelp> no kid1 is a person
18:10:16 <EvanR> or is it supposed to be a data constructor wrapping a list
18:10:28 <EvanR> or is it supposed to be the first thing in a tuple
18:10:47 <pacak> So it's really [( kid1, [purchase1,purchase2]), (kid1, [purchase1,purchase2,purchase3])....] ?
18:10:49 <EvanR> [(kid1, [2,3]), (kid1, [1,3,2])]
18:11:16 <monadhelp> @EvanR yes
18:11:16 <lambdabot> Unknown command, try @list
18:11:28 <EvanR> :t map (fmap (map f))
18:11:30 <lambdabot> (FromExpr b, Show a, Functor f) => [f [a]] -> [f [b]]
18:11:44 <pacak> :t map (second f)
18:11:46 <lambdabot> (FromExpr c, Show b) => [(d, b)] -> [(d, c)]
18:12:09 <pacak> :t map (second (map f))
18:12:10 <lambdabot> (FromExpr b, Show a) => [(d, [a])] -> [(d, [b])]
18:12:23 <pacak> f :: purchase1 -> 1
18:13:46 <EvanR> second? really
18:14:18 <monadhelp>  [(kid1, [2,3]), (kid1, [1,3,2])] is right
18:15:03 <EvanR> monadhelp: to map over a list which is second in a tuple which is in a list... you chain maps and fmaps like i did. apparently you can also use second to map over the right side of a tuple instead of fmap
18:15:22 <EvanR> like pacak did
18:15:45 <EvanR> it helps to understand the types of all these operations to see how they can go together
18:16:23 <pacak> EvanR: I find it more readable than fmap because often I find it necessary to do something with first element of the tuple and tuple's functor instance won't help you.
18:17:32 <pacak> :t second
18:17:33 <lambdabot> Arrow a => a b c -> a (d, b) (d, c)
18:17:59 <pacak> :t second :: (a -> b) -> (d, a) -> (d, b)
18:17:59 <monadhelp> I like pacak's approach b/c it makes sense in my head
18:18:00 <lambdabot> (a -> b) -> (d, a) -> (d, b)
18:18:16 <pacak> :t first :: (a -> b) -> (a, d) -> (b, d)
18:18:17 <lambdabot> (a -> b) -> (a, d) -> (b, d)
18:18:46 <c_wraith> pacak: but the bifunctor instance will!
18:20:02 <pacak> monadhelp: Do you know what a bifunctor is?
18:20:35 <monadhelp> haha no I was frantically googling it
18:20:49 <pacak> c_wraith: Here's your answer :)
18:21:19 <c_wraith> pacak: it's simpler than Arrow, especially when what you want is first and second
18:22:19 <EvanR> which is funny because... using bimap will require the use of the function `id` which ironically is what you were literally asking about
18:22:29 <EvanR> the time loop has been closed
18:22:38 <c_wraith> Arrow is some huge bundle of things which happens to have first and second.  Bifunctor is first, second and first+second simultaneously.
18:23:30 <pacak> monadhelp: Any luck with googling?
18:23:34 <pacak> :t (***)
18:23:35 <lambdabot> Arrow a => a b c -> a b' c' -> a (b, b') (c, c')
18:23:42 <pacak> :t (&&&)
18:23:44 <lambdabot> Arrow a => a b c -> a b c' -> a b (c, c')
18:24:01 <monadhelp> Yup reading it now
18:26:59 <monadhelp> tbqh a bit confused by the triple equals sign here (https://hackage.haskell.org/package/base-4.9.1.0/docs/Data-Bifunctor.html)
18:27:39 <pacak> monadhelp: "the same as"
18:30:42 <monadhelp> got it but how do i actually go about defining first and second
18:30:52 <monadhelp> like the methodology makes total sense
18:31:36 <pacak> At the beginning you just use existing instances
18:31:43 <c_wraith> Do you need to, or is there already an instance for the type you've got?
18:32:00 <pacak> When defining stuff - you need to make sure that laws specified there are satisfied.
18:32:37 <c_wraith> though for the case of Bifunctor, usually the most natural implementation also happens to be the correct one
18:32:58 <c_wraith> This is not true of crazy things like MonadFix. :)
18:33:13 <monadhelp> ooooh!
18:34:26 <pacak> monadhelp: Can you  explain us your understanding of bifunctors?
18:37:57 <halogenandtoast> Does anyone have any suggestions for lexical analysis of Japanese text. For instance parsing conjugated verbs into the base form. Kind of like what MeCab does.
18:39:28 <halogenandtoast> The problem I'm trying to solve is to convert past tense or te form godan verbs to their stem form.
18:41:01 <c_wraith> I have enough trouble remembering the rules for that, let alone writing them down to catch all the corner cases.  This probably counts as a full-on NLP problem - and you'd need to find a ruleset for japanese.
18:43:35 <halogenandtoast> c_wraith: it doesn't need to be perfect, I was just trying to determine if their were any tools that existed already for handling the majority of cases. MeCab gets me pretty far. I found Haskell bindings, but they don't seem to work for me.
18:43:36 <monadhelp> basically bifunctors are a class and if defined correctly, aka define first and second in the top of my script, I'll be able to use second to save the first element of a tuple while modyfying the second
18:44:13 <halogenandtoast> Pretty outdated package it seems, perhaps there is a lack of interest in the Haskell community surrounding this problem.
18:44:24 <c_wraith> monadhelp: you don't need to define it - there is already an instance for tuples
18:44:26 <halogenandtoast> Or I'm bad at searching.
18:45:46 <monadhelp> but I have to define what the id is
18:46:17 <monadhelp> like first id = kid
18:47:00 <c_wraith> monadhelp: well, the advantage of Bifunctor over something like Arrow is that you don't have to.  It just uses the simple id for functions
18:48:44 <monadhelp> cwraith and pacak thanks for the help! I feel like I'm in a better place to go to try to implement the function tomorrow
18:54:13 * hackagebot country 0.1.3 ‚Äì Country data type and functions ‚Äì https://hackage.haskell.org/package/country
19:13:22 <cube_> hi, i'd like to know how i can print a line on stdin, then overwrite it later instead of adding another line. i tried hSeek-ing stdout but it said it was not "seekable"
19:13:58 <cube_> btw i tried that on ghci, so maybe the stdout is special there? i doubt it but who knows
19:14:33 <geekosaur> you can't seek on a terminal
19:14:42 <geekosaur> you have to use cursor control stuff
19:14:53 <cube_> geekosaur: what's cursor control?
19:15:26 <geekosaur> http://hackage.haskell.org/package/ansi-terminal
19:15:29 <cube_> oh! it's the ansi stuff?
19:16:14 <cube_> so, it works with special character which, when read, don't get printed but move the cursor and so on?
19:16:33 <cube_> it's the standard way in terminals, i gather? i mean it's nothing special to haskell right?
19:16:49 <geekosaur> right
19:16:58 <cube_> geekosaur: thanks!
19:17:05 <geekosaur> although there is some weirdness with Windows, at least before win10
19:17:36 <geekosaur> only some things could be done with ANSI escapes, others required special device control calls. (win10's ANSI handlng is more complete)
19:18:10 <cube_> geekosaur: well i only plan on making stuff for linux for the forseeable future :)
19:18:15 <cube_> device control calls?
19:18:43 <geekosaur> on unix/linux it'd be ioctl. on windows it's something else I'd have to look up
19:18:43 <cube_> geekosaur: does that mean writing to some file on /dev/...?
19:19:56 <cube_> geekosaur: so if i write to /dev/ioctl, some stuff happens to the program's control over stdin/out? i hope there's a library for that... i'mma check that out
19:20:29 <geekosaur> no, it's a system call, like ioctl on linux
19:20:38 <geekosaur> windows doesn't do /dev
19:20:55 <geekosaur> (although cygwin and msys2 may pretend to some limited extent)
19:22:19 <cube_> geekosaur: ok... looking through the ANSI stuff, some functions say they clear parts of the screen. is it like when opening emacs or vim, as in, once the program ends, the screen comes back to its original state, or can it really overwrite previous commands and results?
19:22:27 <geekosaur> most curses / terminal i/o packages that support windows handle it for you in anyy case
19:22:55 <geekosaur> that depends on whether they support ANSI alternate screen or not
19:23:14 <cube_> geekosaur: what is they? terminals?
19:23:41 <geekosaur> terminals, or the ansi emulation on windows
19:24:05 <cube_> ok
19:24:10 <geekosaur> also some terminal descriptions don't specify alternate screen in their terminal setup, so vi/emacs won't use it for those
19:24:33 <cube_> well i'll try that out, thanks! by any chance would you know of the haskell equivalent of sleep(n)?
19:24:48 <geekosaur> Control.Concurrent.threadDelay
19:25:03 <geekosaur> note that it is in microseconds, so multiply by 1000000
19:25:25 <geekosaur> (a very common bug is to assume it's in milliseconds and then wonder why threadDelay 1000 didn't :)
19:25:32 <cube_> geekosaur: ok, thanks! is there no constant defined as "secondInMicroseconds"?
19:25:43 <cube_> or something
19:26:09 <geekosaur> not that I'm aware of
19:26:25 <cube_> geekosaur: ok! nvm i'm gonna make one then :)
19:27:08 <cube_> actually, a bunch of constants for multiples of 10 or even 2 could come up handy...
19:29:21 <geekosaur> not sure how much those help since someone could still assume secondInMilliseconds would be the right one to use :)
19:29:43 <geekosaur> kind of a pity it wasn't specced via Data.Fixed
19:30:01 <cube_> geekosaur: well sure but then if i use a function without checking what it's doing that's on me
19:30:08 <cube_> Data.Fixed?
19:30:54 <zoey> hi i am learning haskell uwu
19:30:55 <geekosaur> specifically https://downloads.haskell.org/~ghc/latest/docs/html/libraries/base-4.9.0.0/Data-Fixed.html#t:E6 so it'd be a type error if you tried to use milliseconds
19:32:59 <jmcarthur> I with things like threadDelay would just depend on the time package or something, but I understand why it doesn't.
19:34:12 <jmcarthur> There's probably a package that contains a bunch of related functionality like that... delay for X amount of time, run every X amount of time, delay until time T, etc.
19:34:13 <cube_> geekosaur: it's pretty cool :)
19:36:59 <cube_> is there a way to write function.Module instead of Module.function? i like qualified but it sucks that you lose the distinction bwn camelCase and CamelCase
19:37:11 <ReinH> No.
19:37:18 <cube_> i mean you don't lose it, but it's way less readable
19:37:44 <Rotaerk> hmm what's the appropriate way to add a timed delay inside an Async?  wait $ async $ threadDelay 5000000  ?
19:38:01 <Rotaerk> err..
19:38:08 <cube_> in fact, given you don't always need to read the prefix, the fact that it's upfront is kinda view-obstructing
19:38:12 <Rotaerk> minus the wait
19:38:54 <Rotaerk> nm, thinking in terms of C#'s async/await stuff
19:39:24 <ReinH> cube_: Ok, but that's how it is.
19:40:10 <ReinH> People often try to make the qualifier as small as reasonably possible.
19:40:29 <ReinH> import qualified Data.ByteString as BS and so on.
19:40:41 <Rotaerk> that's BS
19:43:58 <cube_> ok, i tried using ANSI.cursorUpLine, but it didn't do a thing. here's my code: https://pastebin.com/6wYDkMxx
19:45:00 <cube_> i tried first with cursorUpLine 1 but didn't work, and does not work with 2 either
19:45:21 <cube_> unless i'm supposed to erase text before writing?
19:47:17 <cube_> doesn work with clearLine either... anybody got an idea?
19:48:20 <mnoonan_> cube_: this is from the docs for cursorUpLine, relevant? https://github.com/feuerbach/ansi-terminal/issues/10
19:49:42 <mnoonan_> according to http://hackage.haskell.org/package/ansi-terminal-0.6.3.1/docs/System-Console-ANSI.html, all of the *Line functions have potential portability issues
19:50:14 <cube_> mnoonan_: ok, i'll try with cursorUp. any idea how i know how far back to go to be at the start of a line?
19:52:44 <ReinH> cube_: what terminal are you using?
19:53:35 <cube_> ReinH: konsole these days
19:53:38 <glguy> often you can return to the beginning of the line with \r and then use many space characters to "erase"
19:53:39 <ReinH> if you want more control, you should consider ncurses or vty.
19:55:57 * hackagebot miso 0.3.0.0 ‚Äì A tasty Haskell front-end framework ‚Äì https://hackage.haskell.org/package/miso
19:57:01 <cube_> glguy: isn \r supposed to be something like "sometimes part of a line separator" or something?
19:57:34 <cube_> ReinH: i just want to rewrite over one line instead of filling the screen with modified versions of some information
19:58:06 <glguy> cube_: What happened when you tried it?
19:58:24 <cube_> glguy: didn't yet, ok, i'll do it
19:58:24 <geekosaur> cube_, for historical reasons the canonical line separator = carriage return \r + line feed \n
19:58:58 <geekosaur> unixlikes generally map between that and \n used internally but you can change terminal modes to avoid it (see the stty command, and the termios subsystem)
19:59:24 <geekosaur> (stty -icrnl -onlcr)
19:59:30 <glguy> non-historically \n is the line *terminator* for POSIX text files
19:59:36 <glguy> and for windows it's \r\n
20:00:02 <c_wraith> well, \r\n is correct as long as your output device is a line printer
20:00:04 <cube_> glguy: i replaced "cursorUpLine" with putStr "\r" in the code i pastebinned above, and it didn't work
20:00:21 <glguy> cube_: \r goes to the beginning of the line
20:00:31 <c_wraith> and if you treat them as line printer commands, what \r does makes perfect sense
20:01:17 <cube_> glguy: oh wait, maybe i made a mistake
20:02:05 <cube_> glguy: your solution worked, once i avoided adding a newline after the line i wanted to overwrite :) thanks!
20:06:09 <cube_> how can i read directly from the screen regardless of if it's stdin or stdout? i mean both get written at the same place, it's rather confusing... or maybe stdin becomes part of stdout when say using getLine?
20:06:36 <glguy> You read from stdin, you write to stdout
20:06:55 <geekosaur> cube_, it is a bit confusing, but the terminal's input and output streams are separate
20:06:59 <flounders> The only reason what you type shows up on the screen is due to stdin being echoed to stdout.
20:07:06 <glguy> By default stdin echos to the screen, you can disable that
20:07:19 <cube_> flounders: so stdin does get copied onto stdout?
20:07:30 <geekosaur> or because someting is using a line editor that also does such echoing (readline, editline, haskeline, ...)
20:07:52 <flounders> cube_: When echoing is enabled.
20:08:14 <cube_> flounders: ok thx
20:12:04 <cube_> i'm a bit confused reading the documentation of Console.ANSI. it describes a bunch of functions with an Int parameter always being "Number of lines or characters to move". how can it possibly be either lines or character? and there's no additional parameter either
20:14:25 <cube_> i have a suspicion that the functions all had only one type signature, hence the "polymorphic amazing Int", but haddock copied the type signature and distributed it over the bunch of functions. plausible?
20:14:58 <cube_> s/one type signature/one common type signature/
20:15:27 <Cale> cube_: Uh... you mean this? https://hackage.haskell.org/package/ansi-terminal-0.6.3.1/docs/System-Console-ANSI.html
20:16:02 <glguy> Yeah, the source looks like this: cursorUpCode, cursorDownCode, cursorForwardCode, cursorBackwardCode :: Int -- ^ Number of lines or characters to move
20:16:02 <glguy>                                                                     -> String
20:16:05 <cube_> Cale: yeah
20:16:06 <Cale> Haddock doesn't automatically copy type signature comments for you. If there's a comment on an argument, someone put it there.
20:16:12 <Cale> oh, I see
20:16:30 <Cale> Right, those all got commented together, because they shared a type signature.
20:16:37 <Cale> But the comment makes sense for all of them
20:17:05 <geekosaur> cube_, some ANSI escapes operate on lines (vertical), some on characters (horizontal)
20:17:06 <Cale> It's how many cells the cursor is going to move in whatever direction.
20:17:22 <geekosaur> the only one that is on both takes two parameters, not one
20:18:06 <cube_> Cale: well that's not easy to understand...
20:18:34 <cube_> geekosaur: i was talking of the confusing haddock comment(s)
20:18:41 <geekosaur> yes
20:18:54 <geekosaur> cursorUpCode, cursorDownCode are lines
20:19:07 <geekosaur> cursorForwardCode, cursorBackwardCode are characters
20:19:33 <geekosaur> ANSI is not typed
20:19:35 <cube_> geekosaur: yeah i got that. why the Code suffix btw? what's the difference without
20:20:43 <geekosaur> cube_, thats described up at the top of the System.Console.ANSI documentation
20:20:54 <geekosaur> this is a "strawberry" interface
20:21:28 <geekosaur> so it works on unix where the operations are always escape codes, but not necessarily on windows where you need to use special Windows functions instead
20:21:41 <geekosaur> (except many of them should work on recent win10, as I described earlier)
20:21:47 <cube_> geekosaur: oh! thanks i had missed that bit. i understand now "code".
20:22:47 <cube_> geekosaur: actually at the time i misinterpreted your comment and i thought that win10 was the one handling ANSI better than linux. but i understood later given the rest of what you said
20:23:27 <geekosaur> I may not have said that clearly enough
20:23:38 <geekosaur> windows 10's ANSI emulation is better than that of earlier Windows versions
20:23:50 <geekosaur> (and I think it improved again with the "creator update")
20:24:32 <cube_> geekosaur: ok
20:25:56 <cube_> is there an option in ghc/cabal/stack to run a custom script over the project folder before each build? esp, even before ghc checks if there's been a change in the source and it decides lazily what to compile?
20:26:39 <geekosaur> before each build? no
20:27:04 <geekosaur> most projects have a Setup.hs which is run at 'configure' time though
20:27:12 <cube_> when's that?
20:28:04 <geekosaur> if you look at the output when building something (may need some verbose option for stack) it'll say something about Configuring package-ver.s.i.on
20:29:46 <cube_> geekosaur: ok... but does it do it every build, and if so when? i don't have something to build at hand for testing... if you have references on the build process it can be useful too
20:30:31 <geekosaur> I already said it does not do it before each build
20:31:02 <geekosaur> I don;t know of a way to do that other than wrap cabal/stack in your own tooling
21:01:43 * hackagebot sbv 7.0 ‚Äì SMT Based Verification: Symbolic Haskell theorem prover using SMT solving. ‚Äì https://hackage.haskell.org/package/sbv
21:02:17 <glguy> cube_: There are many hooks http://hackage.haskell.org/package/Cabal-1.24.2.0/docs/Distribution-Simple.html#g:2 preBuild could be relevant
21:16:06 <ReinH> cube_: what are you trying to do?
21:19:34 <cube_> oops got distracted by some stuff, sorry to have left abruptly...
21:20:52 <cube_> glguy: i'll look into it  thx :)
21:21:10 <cube_> ReinH: nothing in particular, just curiosity...
21:21:35 <cube_> gotta go, thanks all again :)
21:25:26 <Rotaerk> hmm wonder what the origin of the term "mailbox" is, in the context of FIFO
21:25:39 <Rotaerk> I see it used in pipes-concurrency, and I remember seeing it in F#
21:26:54 <Rotaerk> I don't really like the way pipes-concurrency uses the term "output" to refer to sending messages to the mailbox, and "input" referring to receiving messages from the mailbox
21:27:09 <Rotaerk> because you can reverse that and it just as much sense if you flip your perspective from the user to the mailbox itself
21:27:52 <Rotaerk> "input from the mailbox" and "output from the mailbox" are basically equivalent, because the key word that tells you the direction is the "from"
21:38:07 <bsima> I've got some 1000-1500 links to download and scrape. Is forkIO what I want?
21:49:56 <peddie> @hackage async  -- bsima, you probably want this
21:49:56 <lambdabot> http://hackage.haskell.org/package/async  -- bsima, you probably want this
21:50:47 <bsima> peddie: ok thanks, i was just looking at Control.Concurrent.Chan
21:52:04 <bsima> ooh Async looks real nice
22:00:09 <bsima> :t mapConcurrently
22:00:10 <lambdabot> error: Variable not in scope: mapConcurrently
22:02:00 <tsmish> :t Control.Concurrent.Async.mapConcurrently
22:02:01 <lambdabot> Traversable t => (a -> IO b) -> t a -> IO (t b)
22:05:07 <bsima> changing `mapM` to `mapConcurrently` while downloading 90 urls took total time from 32.3 to 3.6 seconds !!
22:05:18 <bsima> literally a one-line change, this is great
22:06:00 <mud> bsima: Just as a warning, that might annoy some web servers if many of those URLs are at the same place. They might give you error responses instead of real responses.
22:06:30 <bsima> they are all different, and it's my own website that I'm archiving :) 
22:06:34 <mud> Those yes that is cool
22:06:36 <bsima> but thanks for the warning
22:06:37 <mud> Ah okay, haha.
22:21:54 <Axman6> bsima: You you may want to do things like share an HTTP manager between requests - doing that takes care of limiting how many connections are open at a time (so you don't piss people off), but also pipelining requests through open connections which can improve performance of many small reauests a lot
22:23:43 * hackagebot sbvPlugin 0.9 ‚Äì Formally prove properties of Haskell programs using SBV/SMT ‚Äì https://hackage.haskell.org/package/sbvPlugin
23:21:20 <Marisa> hello there. I am trying to install ghc on wsl by running stack setup (stack is from aptitude). It took 3 hour and is still eating my cpu. the issue had been reported before, but do anyone know how long will it typically take?
23:23:50 <c_wraith> Marisa: something about the binaries GHC creates does not play nicely with WSL.  the startup time is excessive for all of them.  something like stack makes lots of calls to cabal, which itself makes lots of calls to GHC - you are going to pay that startup time a lot.
23:24:30 <Marisa> got it. I'll try cygwin...
23:42:07 <Axman6> @hoogle Alternative f => f a -> f (Maybe a)
23:42:08 <lambdabot> Control.Applicative optional :: Alternative f => f a -> f (Maybe a)
23:42:08 <lambdabot> Text.Parser.Combinators optional :: Alternative f => f a -> f (Maybe a)
23:42:08 <lambdabot> Text.Megaparsec optional :: Alternative f => f a -> f (Maybe a)
23:51:46 * hackagebot language-puppet 1.3.8 ‚Äì Tools to parse and evaluate the Puppet DSL. ‚Äì https://hackage.haskell.org/package/language-puppet
23:59:52 * hackagebot hpqtypes-extras 1.3.1.0 ‚Äì Extra utilities for hpqtypes library ‚Äì https://hackage.haskell.org/package/hpqtypes-extras
