00:01:28 <osa1> thanks
00:23:39 <balor> If I build something using stack it puts the logs of building deps in `.stack-work/logs/`. Where does the build log of my application? i.e. the one that has the dependencies.
00:28:10 <MarcelineVQ> nooo, bad timing, come back alahariel
00:29:41 <ertes-w> ello
00:35:22 <MarcelineVQ> geekosaur: I'm getting that error alhariel was having when I tried to build an old project just now. solution was to remove libtinfo6 since the ghc version stack pulled in had the needed libs with it
00:36:22 <MarcelineVQ> idk why it pulled in a version with libtinfo when I already had that, was under the impression it's supposed to pick the thing that covers what you don't have
00:41:28 <Lokathor> so if you're a pro, you'll /always/ use unsafe reads and writes with your storable mutable vectors, right?
00:41:47 <Lokathor> we can just set safety on fire, right?
00:42:07 <MarcelineVQ> if you're a pro you've made a dsl that ensures they're safe when you use them muahaha
00:42:43 <dysfun> sure, set safety on fire, just make sure it's not me who maintains your code later
00:44:50 <ertes-w> Lokathor: array bounds are a bit like safe web routes…  if that's really the most serious engineering problem you have, then i envy you =)
00:45:21 <dysfun> ertes-w: i'd say the current state of the art brings its problems
00:45:29 <dysfun> (yay, template haskell errors, love those)
00:46:31 <Lokathor> ertes-w, it's not the most serious engineering problem I have, but it makes me wonder why there's not a builtin option in the to just cut all the range checks with the flip of a switch
00:46:37 <Lokathor> or like, on a per module basis
00:46:46 <Lokathor> i guess you can make an alias and then switch it around
00:46:48 <ertes-w> Lokathor: there is:
00:46:52 <ertes-w> yeah, that ^
00:47:21 <ertes-w> Lokathor: i found that it gives you a minor speed boost, if you alias your array accessor functions to the array in question anyway
00:47:32 <ertes-w> let writeArr = Vsm.write arr
00:47:40 <Lokathor> oh neat
00:47:56 <Lokathor> i will keep this potential option in mind
00:47:57 <ertes-w> not always, but sometimes it does
00:48:18 <ertes-w> and if it doesn't, it doesn't really hurt, and you can easily switch to unsafe when it works
00:49:35 <Lokathor> yeah
00:49:43 <ertes-w> also…  in many cases i found that the bounds check doesn't have much of a performance impact
00:49:53 <Lokathor> my troubles are much less the speed or not of VSM, but more the arcane finnicking of OGL
00:49:56 <ertes-w> benchmark, and if it doesn't make a difference, consider using the safe variant
00:50:28 <ertes-w> VSM makes GL reasonably enjoyable, especially if you use GL >= 4.5
00:50:35 <ertes-w> because then you can use persistent mappings
00:50:44 <Lokathor> i'm using 3.3
00:50:55 <Lokathor> because that's what the tutorial did
00:51:07 <ertes-w> are you using glMapBufferRange?
00:51:11 <Lokathor> I'll get around to learning the 4.5 stuff some day, but i guess OSX is like stuck on 3.3 or so anyway
00:53:21 <ertes-w> Lokathor: ^
00:53:47 <Lokathor> oh hmm
00:53:49 <Lokathor> nope
00:54:14 <Lokathor> i'm guessing it gives you a pointer straight to GPU memory or something?
00:54:22 <ertes-w> Lokathor: you should…  given a buffer name, it maps the buffer into your program's address space, so you can turn it into a storable vector
00:54:39 <ertes-w> it's available in 3.3
00:54:44 <Lokathor> that sounds handy
00:56:29 <ertes-w> Lokathor: the new feature in 4.5 is the GL_MAP_PERSISTENT_BIT flag to glMapBufferRange, which lets you map a buffer once and then reuse the mapping throughout your app's lifetime
00:56:52 <Lokathor> I only need a few things mapped
00:57:06 <ertes-w> (not sure which exact GL version introduced it, but it's somewhere >= 4)
00:57:34 <ertes-w> in any case: use glMapBufferRange =)
00:57:56 <Lokathor> once things are a little stabler
00:58:01 <Lokathor> i will check that
00:58:12 <Lokathor> at the moment you can't even draw the tiles you're supposed to be able to draw yet
01:00:08 <ertes-w> the joy of GL =)
01:01:10 <ertes-w> if you thought that GHC error messages are mind-bending, look at the standard error message of OpenGL: the blank screen
01:01:29 <Lokathor> i got a fun segfault too
01:02:30 <ertes-w> that's not possible
01:02:57 <ertes-w> you're using haskell, which can't have segfaults together with OpenGL, which is specified never to segfault
01:03:07 <Lokathor> sure it is, ask for GL to make a shaderID before you've set the window's context as the current context :P
01:03:47 <ertes-w> really?  that segfaults?
01:04:06 <Lokathor> well, it's an access violation / segfault
01:04:14 <Lokathor> the program terminates but it doesn't tell you which happened for sure :3
01:04:45 <Lokathor> i guess they're the same thing really
01:04:55 <ertes-w> they are
01:06:16 <ertes-w> well, potentially…  the "segfault" is an address space access violation
01:06:33 <ertes-w> there might be other "access violations", of course
01:09:16 <Lokathor> https://www.dropbox.com/s/ebz7za406dgu77c/Screenshot%202017-10-23%2002.08.23.png?dl=0
01:09:29 <Lokathor> it is not intended to interpolate like that :/
01:10:41 <ertes-w> Lokathor: looks like your shader is broken
01:11:00 <Lokathor> i think my color data is broken
01:13:06 <jcarpenter2> lol
01:13:36 <ertes-w> Lokathor: interpolation happens in the fragment shader…  you're probably using a varying variable where you should be using a uniform one
01:13:41 <jcarpenter2> what's the shortest program you can come up with that generates that picture
01:14:32 <ertes-w> Lokathor: varyings set in the vertex shader are automatically interpolated in the fragment shader
01:14:40 <Lokathor> ertes-w, http://lpaste.net/359461 totally bog standard shaders. the color data array is being written one index too many i'm sure of it
01:15:23 <Lokathor> yes
01:15:55 <Lokathor> liftIO $ forM_ [0,3..12] $ \plus -> do ... -- do you spot the error? I do now.
01:18:13 <ertes-w> Lokathor: why don't you just use 'color' in the fragment shader?
01:18:15 <MarcelineVQ> not without reading your mind ^^;
01:18:32 <ertes-w> Lokathor: as far as i can tell you're just passing it through
01:18:40 <Lokathor> MarcelineVQ, it's the 12! for this iteration, the 12 had to be excluded, not included
01:19:31 <Lokathor> forM_ [0,3,6,9] -- this version is better, much more clear
01:19:32 <MarcelineVQ> oh, well of course. that was obvious to everyone! I thought you meant something else.        that aught to fool him
01:19:49 <Lokathor> i did say "the color data array is being written one index too many i'm sure of it" just above ;3
01:20:16 <Lokathor> ertes-w, I'm not sure what you mean by using color in the fragment shader
01:20:19 <Lokathor> it uses it
01:20:20 <ertes-w> (takeWhile (< 12) [0,3..])  -- i kinda wish there was a short-hand notation for this =)
01:20:52 <MarcelineVQ> like python slices?
01:21:20 <ertes-w> Lokathor: your VS is turning 'color' into a varying 'fragColor' for the FS, but you could just as well use 'color' in the FS directly
01:21:55 <ertes-w> unless you *want* interpolation, but i don't think you do =)
01:22:13 <Lokathor> well the fragment shader gets more complex later on
01:22:16 <ertes-w> MarcelineVQ: just an open interval notation
01:22:27 <Lokathor> right now every cell is exactly 1 color
01:23:22 <Lokathor> i was told that if i want the color data to go from the vertex shader to the fragment shader i had to pass it along
01:26:21 <ertes-w> Lokathor: fragment shaders can use uniform variables directly…  these are variables that are constant for a primitive
01:27:10 <ertes-w> they are passed from the application, whereas varying variables are passed from the VS, and those are interpolated automatically
01:28:08 <Lokathor> but then i have to set a uniform and do a draw call for every single tile, right?
01:28:19 <Lokathor> seems easier to just do it in bulk
01:29:54 <ggVGc> ertes-w: there's this thing we can do in haskell to make shorthands for stuff, called "defining functions"
01:29:57 <ggVGc> I can teach you
01:30:41 <Lokathor> ggVGc, you're going crazy there pal. I only jump to numeric memory addresses. labels are just too modern for me
01:30:57 <ggVGc> I just picked it up myself
01:33:22 <ertes-w> ggVGc: context?
01:33:36 <Lokathor> i think they mean your desire for more shorthand
01:36:37 <Lokathor> ertes-w, https://github.com/Lokathor/kaheloj-hs you can see the whole thing
01:36:39 <Lokathor> if you like
01:40:16 <ertes-w> Lokathor: no, there are bulk methods, but i'd have to look it up myself…  i can do that later, but if you know you're gonna need interpolation anyway, then just go with your current approach
01:41:18 <Lokathor> the base color layers don't need it, but the texture layers will want to interpolate the texture data
01:41:58 <ertes-w> the bulk method is to just pass the color information through a VBO
01:42:12 <Lokathor> that's how i'm doing it now :P
01:42:52 <ertes-w> yeah, and then you can just use 'color' in the FS directly; there is no need to pass it down from the VS…  that's what i mean =)
01:43:11 <Lokathor> uh
01:43:14 <Lokathor> hmm, not sure how to do that
01:43:22 <Lokathor> make a pull request if you want :P
01:52:52 <jml> choosing a logging library always makes me sad
01:53:26 <zzq> quit
01:57:07 <ertes-w> jml: IO not good enough?
02:06:59 <jml> not really
02:07:20 <jml> I want something that emits ISO timestamps and severity and can be filtered by severity
02:07:50 <jml> I keep wanting to use logging-effect but then get bogged down in type complexty
02:08:12 <jml> then I use 'logging' and feel bad about myself 
02:08:18 <osa1> monad-logger?
02:09:14 <jml> what's its selling point?
02:09:30 <osa1> it does things you listed
02:09:42 <osa1> has a mtl-style class so you don't have to enforce IO to your logging functions
02:10:31 <osa1> the transformer has MonadBaseControl and UnliftIO instances so you can fork your logging functions etc.
02:11:59 <jml> ah, I see. fast-logger doesn't have severity
02:12:10 <jml> osa1: do you know if it's possible to use it without TemplateHaskell?
02:12:21 <osa1> no, you handle that part before calling fast-logger functions
02:13:05 <osa1> you pass a function runLoggingT which does the filtering based on severity
02:13:33 <osa1> jml: it works fine without TH on modern GHCs -- use Control.Monad.Logger.CalLStack module
02:14:06 <ertes-w> jml: IO is good enough for that
02:14:37 <ertes-w> jml: type Logger = Severity -> String -> IO ()
02:14:42 <ertes-w> jml: mainWith :: Logger -> IO ()
02:16:42 <ertes-w> jml: i think all existing logging frameworks we have right now are overengineered, but provide nothing that this simple functional abstraction scheme couldn't handle
02:17:10 <carbolymer> ^ this
02:18:23 <carbolymer> hs-logger for example: no way of changing logging levels to custom ones (without extensive hacking)
02:18:52 <osa1> that problem exists in monad-logger too
02:19:08 <jml> I've never wanted custom logging levels.
02:19:11 <osa1> I don't think that it's over-engineered though
02:19:29 <angerman> Wheee. Someone went ahead and built an installer for the mobile ghcs.
02:19:29 <osa1> well, there's `LevelOther` constructor which you can use for embedding your log levels ;-)
02:20:44 <jml> ertes-w: I think I get what you're saying. What you describe isn't quite enough to allow filtering by severity though.
02:20:59 <jml> unless you store the current level in an MVar or similar
02:24:14 <ertes-w> jml: do you need to *relax* filters in deeper levels?
02:24:32 <ertes-w> jml: because it is good enough to make filters stricter
02:26:59 <ertes-w> jml: mainWith log = … someFunc (\l -> when (l >= WARN) . log l) …  -- this gives someFunc a variant of 'log' that wants at least the WARN level
02:27:33 <jml> makes sense
02:27:52 <jml> almost always, I just want to set it once after parsing the command line
02:29:41 <ertes-w> actually you can relax this way, too…  make sure your level type is Ord, then you can apply min/max
02:29:57 <ertes-w> mainWith log = … someFunc (log . min 5) …
02:30:48 <ertes-w> anything that goes to 'log' is clamped to (<= 5)
02:31:02 <jml> you should publish this as a library :)
02:31:21 <ertes-w> i think acme-empty already exists =)
02:31:24 <jml> and make the choice for haskell programmers harder still ;)
02:33:22 <ertes-w> jml: john millikin already made that package
02:33:25 <ertes-w> https://hackage.haskell.org/package/empty
03:20:41 <geekosaur> @remember ertes-w if you thought that GHC error messages are mind-bending, look at the standard error message of OpenGL: the blank screen
03:20:41 <lambdabot> Nice!
03:26:36 <MarcelineVQ> she loves it
04:51:54 <_sras_> What does this Stack error really mean"In the dependencies for models-0.1.0.0:     aeson-caseing must match -any, but the stack configuration has no specified version" ?
04:54:27 <lyxia> _sras_: the package models depends on aeson-caseing (no bounds), but it cannot be found in the stackage snapshot you are using (specified by "resolver")
04:56:46 <_sras_> lyxia: What does the " but the stack configuration has no specified version" part mean speicifically?
04:58:18 <lyxia> _sras_: stack.yaml is expected to specify working versions of all packages that your project is using
04:58:29 <lyxia> _sras_: that error message is saying that this expectation is not met
05:04:37 <lyxia> It's like cooking. A .cabal file with no version bounds is like just the list of names of ingredients, with no quantities specified. If you're a good enough cook you might figure out the right ones. A stack.yaml tells you explicitly how much of each ingredient you can use to make something palatable.
05:10:08 <_sras_> lyxia: So why doesn't it just say something like "as per the stack.yaml and cabal file, we need package-version, but it was not found in snapshot"?
05:11:15 <geekosaur> because that's not quite right. what it means is more like 'I can't determine which versions might be compatible with your resolver and / or stack.yaml; please advise me'
05:12:25 <geekosaur> the resolver is packages whose versions are known to work together. stack.yaml is how you add additional packages with specific versions that you have tested (or are trying, as the case may be) to be compatible with the snapshot
05:13:21 <geekosaur> if you have a package not in the resolver and not in stack.yaml then stack won't proceed, because it wants to provide reproducible builds instead of quasi-random version choices for unknown packages.
05:13:34 <geekosaur> admittedly the error message is rather stack-internals-geek
05:15:56 <_sras_> geekosaur: If there is no version explictily provided in stack.yaml, then "There is no package X in snapshot" is the same as "I can't determine the compatible version", right? Because if it is in snapshot, then it will also have the compatible version, right?
05:16:04 <ekr> hello, how can I find the implementation of the composition operator "(.)", in a local ghc instance. I've been grepping for stuff, with no luck.
05:16:28 <ekr> or could i find it somewhere on hackage?
05:16:59 <ekr> i assume it's in Prelude.hs, isn't it?
05:16:59 <geekosaur> _sras_, that ignores that you often need additional packages from stack.yaml (often your own packages from a multi-package project, but also often prerelease packages from others or just packages that never made it into stackage for some reason)
05:17:33 <geekosaur> ekr, per ghci locally: (.) :: (b -> c) -> (a -> b) -> a -> c 	-- Defined in ‘GHC.Base’
05:17:41 <geekosaur> Prelude is mostly reexports
05:18:30 <ekr> thanks, i didn't know about :i
05:18:30 <geekosaur> (that's from ":i (.)")
05:25:12 <nicknight> hi what is matplotlib like in haskell for plotting graphs and numpy like for computing?
05:26:56 <[exa]> I§m kindof hoping numpy never gets to haskell
05:27:12 <LuxMundi> lol why
05:27:50 <[exa]> nicknight: but there is this kindof list on the wiki https://wiki.haskell.org/Applications_and_libraries/Mathematics
05:28:02 <[exa]> LuxMundi: numpy-like style is scary
05:29:04 <_sras_> geekosaur: Yes. But I don't understand why you have to shoehorn all of these possibilities into the same error message. For ex, right now, my problem was a Typo in a package name...
05:31:03 <nicknight> ok thanks you [exa] 
05:40:29 <saurabhnanda> quick question, how do I generate a list of 1..n in multiples of 3, i.e. 1, 4, 7, and so on...
05:41:59 <Geekingfrog> saurabhnanda: map ((+1) . (*3)) [0..n] ?
05:42:00 <LKoen> > [3*k+1 | k <- [1..10]]
05:42:02 <lambdabot>  [4,7,10,13,16,19,22,25,28,31]
05:42:11 <saurabhnanda> LKoen: thanks
05:43:13 <LKoen> > map ((+1) . (*3)) [0..10] (* does the same thing exactly *)
05:43:17 <lambdabot>  <hint>:1:59: error: parse error on input ‘)’
05:43:35 <LKoen> :(
05:44:01 <Geekingfrog> > map ((+1) . (*3)) [0..10] -- does the same thing with comment ?
05:44:04 <lambdabot>  [1,4,7,10,13,16,19,22,25,28,31]
05:44:05 <Geekingfrog> \o/
05:45:33 <sdtsui> Hi!
05:46:24 <sdtsui> Can anyone explain to me what this use of the applicative typeclass does?
05:46:25 <sdtsui> ```
05:46:28 <sdtsui> eqAll :: (Eq a) => [a] -> Bool eqAll = and . (zipWith (==) <*> tail)
05:46:30 <sdtsui> ```
05:46:50 <sdtsui> Having trouble getting my head around the <*>
05:53:05 <lyxia> sdtsui: zipWith (==) and tail are functions; (<*>) passes the result of tail as the second argument of zipWith (==).
05:53:57 <lyxia> \x -> zipWith (==) x (tail x)
05:55:40 <ski> mivael_ : note that you could pass around different versions of `ops' at run-time, letting run-time computation or input influence which version to use
05:58:18 <ski> mivael_ : "Is there a name which is usually used to refer to such design pattern in Haskell?" -- you have a record of operations (usually including functions or actions), this is one sense of "object-oriented", so i might refer to it as an OO approach. by passing around operations at run-time, you get "dynamic dispatch" (meaning basically that you have a function, or record-of-functions, as an argument. iow a higher-order function (HOF))
05:59:34 <ski> your "record of functions" is an "object" that decides for itself how to "interpret" "messages" sent to it (iow the actual function placed in the record field contains the behaviour that will be invoked when accessing the field and calling the contained function)
06:01:27 <ski> a customer/user of the record doesn't need to know the actual implementation (and corresponding behaviour) of the operations. if you either throw in `IO'/`ST s', or an existential, you can also have data structures that the operations can operate on, but which are private to outsiders
06:02:03 <mivael_> hello all
06:02:10 <ski> (the point with `IO'/`ST s' is that there's `newIORef'/`newSTRef' and friends)
06:02:15 <ski> hello mivael_
06:05:33 <ski> "On Understanding Data Abstraction, Revisited" by William R. Cook in 2009-10 at <http://www.cs.utexas.edu/~wcook/Drafts/2009/essay.pdf> is a paper that talks about the sense of "object-oriented" here, also relating to closures (such a record-of-functions would often close over some common environment, or state)
06:07:02 <ski> mivael_ : btw, the reason i included `interact :: (o -> o) -> IO ()' in the record is that the type of `o' in it differed in your two situations, so it would have been pretty useless to not include it. nonetheless, it may be better to replace the first `o' in its type with something else
06:07:34 <mivael_> hello ski, it indeed is similar to OO, I agree.  I thought that maybe there is some haskell-specific terminology on that
06:09:36 <mivael_> ski, I understand that it could be something else if 'main' would not use interact-like function in its base
06:10:24 <mivael_> Well, today I have another (and completely unrelated) question...    ;)
06:10:26 <ski> there's a trade-off between variant/sum types (aka disjoint/discriminated/tagged union types, "variant record" types (Pascal,Ada), in Haskell incarnated as algebraic data types) on the one hand, and record/product types (object types, not necessarily the same as classes) on the other hand
06:12:35 <ski> let's say you want to handle geometric "shapes". these come in various alternative forms, like triangles, rectangles, circles
06:13:16 <ski> and you also want to have some operations on shapes, like computing perimeter, area, perhaps rendering in a picture, &c.
06:13:57 <ski> so, for each combination of an operation and an alternative form, you will have a piece of code that implements the operation for that form
06:14:08 <ski> the question is how you structure these pieces of code
06:14:50 <ski> the variant type (common in Haskell) way is to have a type `Shape', with a data constructor for each alternative form of shape
06:15:28 <ski> then, each operation is a function that pattern-matches on the data constructors, to select which piece of code to do
06:15:45 <ski> if you want to add a new operation, that's simple, just make a new pattern-matching function, handling all existing cases
06:16:25 <ski> if you want to add a new alternative form, that's a bit more involved, you have to modify each one of your existing pattern-matching functions
06:17:10 <mivael_> ski, I understand so far...
06:17:33 <ski> now, the alternative here is the record type based architecture / structure : you still have a type `Shape', but instead of having the alternative forms in there, you make it a record that contains all the *operations* as fields
06:19:04 <ski> now, it's simple to add a new alternative form, you just make a new record (perhaps parameterized on some stuff, iow a function giving a record then), which contains all the implementation pieces of all operations for that particular alternative form
06:19:56 <ski> on the other hand, it's harder now to add a new operation, since you must now modify each one of your record-of-operations functions
06:20:12 <Psybur> > (3 <$ (+5)) 1
06:20:16 <lambdabot>  3
06:20:18 <Psybur> :t (<$)
06:20:20 <lambdabot> Functor f => a -> f b -> f a
06:20:26 <Psybur> Why isn't the answer four?
06:20:30 <mivael_> ski, yeah, I understand that
06:20:39 <ski> in an OO language, your record type would probably be implemented by a class, (or maybe a template object, if you're doing prototyping OO)
06:20:46 <Psybur> I thought the first part would create a (+3), then I would apply 1 to it getting 4
06:20:53 <Psybur> Cant understand why Im getting 3 :D
06:20:54 <ski> and the record-of-operations function would be called a "constructor" in OO parlance
06:21:11 <fakenullie> > (3 <$ (+5)) 100500
06:21:15 <lambdabot>  3
06:21:16 <ski> mivael_ : so, it's like you have a rectangle with alternative forms being columns, and operations being rows
06:21:37 <mnoonan> :t \x -> (x <$ (+5))
06:21:39 <lambdabot> Num b => a -> b -> a
06:21:51 <ski> mivael_ : with the variant/sum type approach, you slice the rectangle into separate columns. adding a new column (pattern-matching function) is now easy
06:21:56 <fakenullie> Psybur: where 3 would get +?
06:22:14 <fakenullie> > ((+3) <$ (+5)) 100500
06:22:17 <mnoonan> Psybur, you're getting a function of type (b -> a) out of a value of type a, so it must be const
06:22:18 <lambdabot>  <Integer -> Integer>
06:22:39 <ski> mivael_ : with the record/product (/ object) type approach, you slice the rectangle into separate rows. adding a new row ("OO constructor/class", record-of-operations (methods)) is now easy
06:22:42 <mnoonan> iow, your '3' is the function \_ -> 3
06:23:10 <Cooler> anyone here use automated theorem provers like Z3 and Yices 2?
06:23:50 <mnoonan> Cooler, yes (though I think calling an SMT solver an automated theorem prover is a bit generous)
06:24:18 <ski> mivael_ : of course, in practice, it tends to be a bit more complicated than this simplified picture (e.g. your type may be recursive), but hopefully it explains how sometimes the sum type approach is to be preferred, sometimes the record type one. e.g. depending on whether you expect it to be more common to add/change alternative forms, or operations/methods
06:24:21 <Cooler> mnoonan: have you used Z3?
06:24:40 <ski> @wiki Embedded domain specific language
06:24:40 <lambdabot> https://wiki.haskell.org/Embedded_domain_specific_language
06:24:44 <mnoonan> yes, though really only with very specific workflows
06:25:05 <Cooler> i was reading the Z3 tutorial and they mention in the section "Nonlinear Arithmetic" that it can't solve some problems
06:25:10 <Cooler> https://rise4fun.com/z3/tutorial
06:25:25 <Cooler> they give an example (assert (= (+ (* b b b) (* b c)) 3.0))
06:25:33 <Cooler> b^3 + bc = 3
06:25:42 <Cooler> i was wondering why it couldn't solve that
06:25:46 <Cooler> seems really easy
06:25:49 <ski> mivael_ : that page ^ is also relevant. "deep embedding" is similar to the sum type approach here, and "shallow embedding" can be similar to the record type approach (in examples they often would just have one field, but in general one can have several)
06:26:52 <mnoonan> Cooler: they aren't doing arbitrary symbolic manipulation, even of the easy sort
06:27:18 <ski> mivael_ : .. i could also possibly talk a bit about how OO is related to existential quantification, and how existential quantification can be used both for an OO approach and an ADT (abstract data type) approach, and how they differ .. but perhaps another time :)
06:27:37 <ski> mivael_ : now, what was your other completely unrelated question ? ;)
06:28:08 <Psybur> mnoonan, thanks I realized that just because a's and b's get switched around that doesn't necessarily mean values are being switched around like that
06:28:15 <mnoonan> Cooler, the key in in the preceding paragraph:  "Nonlinear integer arithmetic is undecidable: there is no procedure that is correct and terminates (for every input) with a sat or unsat answer. Yes, it is impossible to build such procedure."
06:28:25 <Psybur> I should have looked at how the function is actually defined first, which I see is fmap . const
06:30:53 <Cooler> mnoonan: thats true of a lot of problems in constraint solving
06:31:23 <mivael_> ski, yes, it's probably better to do it "another time" :)   I'm have enough information for today :)
06:32:03 <Cooler> mnoonan: there are machine learning algorithms like RACOS https://www.aaai.org/ocs/index.php/AAAI/AAAI16/paper/download/12367/11874
06:32:11 <Cooler> that can solve that problem
06:32:32 <Cooler> i was wondering why solvers like Z3 don't include machine learning algorithms
06:33:04 <mivael_> ski, I understand all you were talking about, except maybe the origins of those four names (variant/sum, record/product).
06:33:35 <mivael_> Yeah, the "unrelated" one...
06:33:37 <mnoonan> Cooler: the point of SMT solvers (at least from my perspective, as a first-order approximation) is to give a black-box decision procedure, so they need decidability of the theory you're working over.
06:34:06 <mnoonan> In reality they weaken that somewhat, but they aren't supposed to be a general-purpose proof assistant really
06:34:45 <mivael_> > let  g 1 = f;  g n = (g (n-1)) >=> f;  countMA = g;  f s = Just $ s ++ " " ++ show (length s)  in  take 5 $ zipWith countMA [1..] (repeat "prefix")
06:34:48 <lambdabot>  [Just "prefix 6",Just "prefix 6 8",Just "prefix 6 8 10",Just "prefix 6 8 10 ...
06:34:59 <mivael_> Is there a library equivalent of the countMA function above?
06:35:11 <mivael_> In other words, I need a function (g :: Monad m => Int -> (a -> m a) -> a -> m a) which "multiplies" a monadic action N times passing result between multiple sequential applications of the action.  So that, particularly, (g 5 f) == (f >=> f >=> f >=> f >=> f).
06:35:23 <mivael_> I was tempted to say that the g function is a generalization of 'Text.Parsec.count' for monads but it is actually not: a generalization of 'count' would operate on monads (m a) whereas g should operate on a particular case of monadic actions (a -> m a).
06:35:40 <mivael_> Note:  I'm not experienced yet on practical usage of monads.  Thus, I maybe asking for something obvious...  Please excuse me if that is the case :)
06:36:49 <Cooler> mnoonan: well Z3 itself returns "unknown" as the answer on some classes of problems, including ml algos like RACOS would only reduce the number of problems for which it returns unknown
06:37:16 <Cooler> extend the class of problems for which Z3 is useful
06:38:00 <mnoonan> :t \n -> foldl' (>=>) return . replicate n  -- mivael_
06:38:01 <lambdabot> Monad m => Int -> (b -> m b) -> b -> m b
06:39:08 <ski> mivael_ : "variant" vs. "record" are common terms from computing science. "sum" vs. "product" refers to how these types behave "algebraically". a product/record type is like a (cartesian) product of sets, in set theory
06:40:16 <ski> mivael_ : if the set `A' has `m' elements, and the set `B' has `n' elements, then the product set of `A' and `B' (consisting of all pairs with first component coming from `A', second from `B') has `m * n' elements. hence this type is written as `A * B' (or ⌜A × B⌝ with fancier symbols)
06:40:49 <mivael_> ski, "record" is familiar, but I have not heard it called "variant"
06:41:39 <tdammers> "variant" is sometimes also used to refer to dynamic types, i.e., the Any type (or, in Haskell, Dynamic from Data.Dynamic)
06:41:53 <ski> mivael_ : similarly, the disjoint union set of `A' and `B' (consisting of all elements of `A', and all of `B', tagged or renamed (if necessary) in such a way that any common element of `A' and `B' is counted *twice*) has `m + n' elements, hence this "sum" of `A' and `B' is written `A + B'
06:42:54 <ski> mivael_ : for completeness, the set of all functions from `A' to `B', is written in math with exponentiation `B^A', though we prefer the `A -> B' notation in computing science. there are `n^m' such functions
06:43:13 <geekosaur> mivael_, fwiw I know the term 'variant' from Pascal's record system
06:44:16 <mivael_> geekosaur, I think I have not been using Pascal for too long, maybe I just forgot
06:44:21 <ski> an algebraic data type in Haskell is a sum-of-products type. e.g. `data List a = Nil | Cons a (List a)' corresponds to `List a = 1 + a * List a' (`1' being the type `()' in Haskell)
06:44:38 <geekosaur> they aren't well covered in intro courses iirc
06:46:40 <ski> mivael_ : your `countMA' looks a bit similar to `replicateM', hm
06:47:20 <ski> (also, "a generalization of 'count' would operate on monads (m a)" -- a value of type `m a' is not a monad, it's an action, an `m'-action. `m' itself (together with its `Monad' instance) is the monad)
06:48:12 <ski> @type Text.Parsec.count
06:48:16 <lambdabot> Text.Parsec.Prim.Stream s m t => Int -> Text.Parsec.Prim.ParsecT s u m a -> Text.Parsec.Prim.ParsecT s u m [a]
06:48:48 <mivael_> mnoonan, thank you.  I understand that it could be emulated this way, still I expected something simpler, though :)
06:51:27 <ski> @type \n f -> (execStateT . replicateM n . StateT) (((,) () <$>) . f)
06:51:29 <lambdabot> Monad m => Int -> (s -> m s) -> s -> m s
06:52:08 <mivael_> ski, understood on (m a) terminology.  How people name (Monad m :: a -> m b) functions, then?  Do they have a special name?
06:52:37 <ski> i suppose you could say "action-producing function", but that's a bit clunky ..
06:52:44 <ski> maybe "parameterized action"
06:52:53 <ski> or "effectful function"
06:53:15 <ski> (itym `Monad m ::' should not be there)
06:53:18 <mivael_> I like "effectful function".
06:54:16 <mnoonan> "kleisli arrow", if you want to be opaque about it :)
06:54:16 <mivael_> ski, I like the term "effectful function" for (a -> m b).  Thanks.
06:54:23 <ski> mivael_ : .. i don't know about something close than the above `replicateM' to get your `countMA'
06:54:34 <mivael_> mnoonan    :)
06:54:53 <ski> however, `Int -> (a -> a) -> (a -> a)', and `Category cat => Int -> cat a a -> cat a a' would also be useful
06:55:23 <ski> mnoonan : yea .. but i suspect mivael_ also wanted to include cases like `A -> B -> M C', where that term fits less well
06:55:24 <mivael_> ski, yes, I was going to ask about a more general function
06:56:04 <ski> with that `Category'-based version, you could recover both the `Int -> (a -> a) -> (a -> a)' and the `Monad m => Int -> (a -> m a) -> (a -> m a)' (via `Kleisli')
06:56:35 <mivael_> Maybe (powerWith:: (a -> a) -> Int -> a -> a) would be useful...
06:56:56 <hexagoxel> bennofs: fyi reflex-host needs another one-liner change to work with newer reflex for ghc-8.2 compat.
06:57:11 <ski> also useful here would be `compose :: [a -> a] -> (a -> a)' (or `compose :: Category cat => [cat a a] -> cat a a'), e.g. `compose = foldr (.) id' or `compose fs a = foldr ($) a fs'
06:57:13 <mivael_> s/Maybe/Maybe this function.../
06:57:31 <ski> then you could combine `compose' and `replicate' to get the former functions
06:57:44 <bennofs> hexagoxel: can you make a PR? :)
07:01:02 <hexagoxel> bennofs: sorry, ignore that. i missed the last commits on your repo.
07:01:17 <hexagoxel> should work as is :)
07:01:54 <jvliwanag> having a hard time figuring out how `(.).(.)` ends up with a type `(b -> c) -> (a -> a1 -> b) -> a -> a1 -> c`. anyone have some pointers? :)
07:03:05 <mivael_> ski, it would be good to have such 'compose', I agree  (and, as I understood, we do not have one:)
07:06:42 <ertes-w> jvliwanag: work out what the expression (((.) . (.)) f g x y) evaluates to
07:07:22 <jvliwanag> ertes-w: hm, i'll try that now thanks
07:11:58 <jvliwanag> sigh, have to admit. don't know how to start
07:12:08 <ertes-w> jvliwanag: you'll need two things
07:12:24 <ertes-w> 1. the definition of (.):  for all f g x, (f . g) x = f (g x)
07:12:47 <ertes-w> 2. the currying desugaring rule:  for all f x y, f x y = (f x) y
07:13:58 <ertes-w> ((.) . (.)) f g x y = (((.) . (.)) f) g x y  -- apply rule 2
07:14:26 <jvliwanag> hehe awesome. ok, trying it out on pen and paper first
07:14:30 <ertes-w> = ((.) ((.) f)) g x y  -- apply rule 1
07:14:34 <ertes-w> etc.
07:14:42 <ertes-w> remember that (.) is just another function
07:14:49 <jvliwanag> got it
07:19:59 <fendoer> hello guys, how can i create an int of type `Int#`? do i need some language extension?
07:20:12 <fendoer> some language extesion?
07:21:47 <ski> fendor : `MagicHash'
07:22:02 <fendor> ski, thanks! 
07:22:38 <fendor> small side question, when i use ghc.prim the various simd instructions, will they work as expected? i read once that they do not actually work and result in some warnings
07:22:51 <ski> s/currying desugaring rule/associativity of application/ :)
07:22:59 <ski> @type 5#
07:23:01 <lambdabot> GHC.Prim.Int#
07:24:12 <fendor> ski, sorry, did you write more than just the extension? because i disconnected for a second
07:25:37 <fendor> ok, vector instructions work only on the ghc-simd-branch and will only work when compield with -fllvm
07:28:20 <ertes-w> ski: well, it is a kind of desugaring =)
07:29:04 <ski> i suppose .. though i don't think it has much to do with "currying" :)
07:31:10 <ski> (i think of "currying" as either one choice of how to represent a multiple-argument function .. or as a transformation going from anther representation to the curried representation, as in the function `curry' e.g.)
07:37:48 <jvliwanag> @ertes-w `((.).(.) f g x y)` evaluates to `(f (g x)) y`. is that right?
07:37:49 <lambdabot> Unknown command, try @list
07:38:07 <jvliwanag> oops
07:38:34 <ertes-w> jvliwanag: nope
07:38:54 <jvliwanag> hm, oki. lemme retrace
07:40:48 <ski> `((.).(.) f g x y)' is not the same as `(((.) . (.)) f g x y)'
07:42:51 <jvliwanag> oh
07:51:00 <carbolymer> wide tits are always different
07:53:39 <jvliwanag> hm. so `(((.).(.)) f g x y)` becomes `f ((g x) y)`. which makes sense since it's `(b -> c) -> (a -> a1 -> b) -> a -> a1 -> c`. meaning `f` takes is one arg, and `g` essentially takes in two args. is that right? 
07:54:35 <EvanR> @pl \f g x y -> f ((g x) y)
07:54:35 <lambdabot> (.) . (.)
07:54:40 <ski> jvliwanag, yep
07:54:52 <EvanR> @djinn (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
07:54:53 <lambdabot> f a b c d = a (b c d)
07:55:11 <jvliwanag> awesome. thanks ski 
07:55:19 <jvliwanag> and ertes-w 
07:56:28 <Denommus> @pl \f g x y -> f (g x y)
07:56:28 <lambdabot> (.) . (.)
07:57:07 <EvanR> also known as (.:)
07:57:16 <ski> jvliwanag : i've been known to define `infixr 9 .:; (.:) :: (c0 -> c1) -> (a -> b -> c0) -> (a -> b -> c1); (.:) = (.) . (.)' and similarly for `(.::) = (.) . (.) . (.)'. the number of dots in the operator symbol is the same as the number of dots in the implementation. the number of characters is the number of arguments that are "passed on" to the right operand of the operator
07:58:40 <jvliwanag> nice, quite handy
08:06:39 <ertes-w> jvliwanag: isn't it…  and now forget that it exists =)
08:07:10 <ertes-w> unless you have to use it repeatedly over and over again and it really improves the readability/uniformity of your code, better use it sparingly
08:08:02 * ski nods
08:08:13 <jvliwanag> :)
08:08:58 <ski> also `f .: g' is the same as `(f .) . g', which may perhaps be more reasonable at times
08:09:39 <ski> (and `f .:: g' is `((f .) .) . g', &c.)
08:12:54 <totallyhuman> > x = "is this ghci?"
08:12:56 <jvliwanag> hm, is there a sort of point free version of -- `foo x = f <$> g x` wherein I can skip `x` arg?
08:12:57 <lambdabot>  <hint>:1:3: error:
08:12:57 <lambdabot>      parse error on input ‘=’
08:12:57 <lambdabot>      Perhaps you need a 'let' in a 'do' block?
08:13:04 <totallyhuman> mmkay
08:13:34 <mauke> jvliwanag: foo = (f <$>) . g
08:13:43 <mauke> jvliwanag: foo = fmap f . g
08:14:03 <mauke> jvliwanag: foo = (.) (fmap f) g
08:14:11 <mauke> jvliwanag: foo = fmap (fmap f) g
08:14:52 <ski> @let totallyhuman = "this is not GHCi"
08:14:55 <lambdabot>  Defined.
08:14:57 <ski> > totallyhuman
08:14:59 <lambdabot>  "this is not GHCi"
08:15:31 <ski>   foo = (fmap . fmap) f g
08:15:39 <jvliwanag> hehe thanks mauke for the options. that last one though.. hm, still trying to figure it out
08:15:50 <ski> @src (->) fmap
08:15:50 <lambdabot> fmap = (.)
08:16:07 <mauke> foo = (.) fmap fmap f g
08:16:09 <ski>   fmap :: (b0 -> b1) -> ((a -> b0) -> (a -> b1))
08:16:14 <mauke> foo = fmap fmap fmap f g
08:16:22 <ski> this is the `Functor (a ->)' instance
08:16:33 <jvliwanag> ooohh
08:17:03 <jvliwanag> awesome
08:17:22 <ski> in practice, i probably wouldn't use `fmap' in place of `(.)' here
08:17:45 <ski> (going with one of the first two suggestions)
08:18:06 <fendor> @src (->) r
08:18:07 <lambdabot> Source not found. I've seen penguins that can type better than that.
08:18:09 <fendor> @src (->)
08:18:09 <lambdabot> Source not found. You untyped fool!
08:18:15 <jvliwanag> hehe yeah. got it. nice nice
08:18:17 <mauke> WE NEED MAXIMUM FMAP
08:18:21 <mauke> it really puts the Fun in Functor
08:18:27 <jvliwanag> :))
08:22:07 <ertes-w> jvliwanag: in particular: (.) . (.) = fmap fmap fmap
08:22:33 <ertes-w> > fmap fmap fmap length replicate 4 'a'
08:22:36 <lambdabot>  4
08:23:59 <jvliwanag> hehe nice. i see that now
08:28:34 <dsal> hmm...  My computer is rebuilding a lot of things.  I'm starting to think stuffing my stack stuff in Google Drive File Stream™ may cause some confusion.
08:28:54 <MarcelineVQ> and loss of privacy
08:29:11 <MarcelineVQ> not that there's a huge issue with that and typical stack projects :>
08:30:04 <dsal> It's not the project, but ~/stack/snapshots
08:30:14 <dsal> er ~/.stack/snapshots
08:30:27 <EvanR> build files probably contain paths on your computer
08:30:32 <dsal> It's rebuilding libs that are there.  What would cause it to do that?
08:31:08 <cocreature> dsal: how do you check whether the libs are already there?
08:31:28 <dsal> Well, ls.  But also, I was doing this last night and they were there.
08:31:36 <dsal> This morning, my build is rebuilding a bunch of things.
08:31:45 <dsal> It's also possible I'm totally wrong.
08:31:59 <alhariel> if theres anyone from yesterday still around, i tried running stack upgrade --git and ran into the same problem
08:32:02 <dsal> Oh, I think it's that.
08:32:04 <cocreature> if you change the resolver, extra-deps or similar configuration things will be rebuilt
08:32:14 <dsal> I'm profiling.  I assume that's causing stuff to be rebuilt.
08:32:24 <dsal> I was not profiling last night.
08:32:25 <cocreature> ah yep
08:32:34 <dsal> I see -prof -fprof-auto-exported
08:32:50 <dsal> OK, that's good.  Sorry for the confusion.
08:32:53 <alhariel> https://pastebin.com/r0g8MSFD
08:33:06 <dsal> Someday, I'm going to get a machine with enough storage for things I do that I won't have to do weird things.
08:33:57 <MarcelineVQ> alhariel: "<MarcelineVQ> I'm getting that error alhariel was having when I tried to build an old project just now. solution was to remove libtinfo6 since the ghc version stack pulled in had the needed libs with it"
08:34:26 <alhariel> hm ill try that
08:35:17 <MarcelineVQ> Appearantly my stack install had libtinfo6 as a dependency so I just removed them both, you don't need a stack install after doing an upgrade since it'll live in ~/.local/bin from then on
08:35:44 <dsal> Can anyone explain why I need this 'c' function here?  It seems the Nothing case causes some type issues when I try to do the read from within the Just case. https://www.irccloud.com/pastebin/VtsvOd4o/gpsdatum.hs
08:35:58 <alhariel> i installed stack from the script
08:35:59 <dsal> ETRow is something like Double -> Double -> Float -> Float -> Float -> Float -> Int
08:36:00 <alhariel> initially
08:36:24 <alhariel> that is, i dont have the stack package
08:36:36 <MarcelineVQ> alhariel: I've no idea what that does, if you're on arch you should prefer pacman or aur sources though, in the interest of clean removals of things
08:36:50 <MarcelineVQ> *I've no idea where that puts things,
08:37:01 <cocreature> it’s just a statically linked binary that’s put in ~/.local/bin
08:37:19 <MarcelineVQ> ah that's good then
08:37:53 <alhariel> 'which stack' says its in /usr/local/bin/stack
08:37:59 <MarcelineVQ> less good
08:38:04 <alhariel> s:
08:38:35 <MarcelineVQ> not an issue at this time though, you should be trying to deal with libtinfo6 first
08:38:49 <alhariel> i just uninstalled it and wiped .stack
08:38:55 <cocreature> also that error is not a problem with the stack install, it’s a problem with the version of GHC stack uses
08:39:06 <alhariel> trying stack upgrade --git again
08:39:40 <MarcelineVQ> ah :X shouldn't need all that, just removing the libtinfo6 and trying to build your project after should have been enough
08:39:49 <alhariel> XD
08:40:23 <geekosaur> dsal, you should generally include the full code and full error message from such attempts instead of making people guess
08:40:59 <alhariel> oh but the reasoni installed libtinfo in the first place was that i got a complaint about a missing libtinfo.so while trying to build that project
08:41:12 <dsal> yeah, was benchmarking.  I'll break it again real quick.  ETGPSData is just a data constructor, though.  I wouldn't think you'd need much beyond that.
08:41:14 <geekosaur> however: your Nothing case is wrong, and just happens to do approximately the right thing as written in the paste
08:41:40 <geekosaur> it parses as (Error "invalid column: ") ++ s
08:41:52 <dsal> Oh weird.
08:42:00 <geekosaur> er, error not Error
08:42:19 <geekosaur> and that's not weird, it's normal. function application is higher precedence than operators
08:42:34 <dsal> I mean weird that it appears to work.  :)
08:42:42 <MarcelineVQ> alhariel: that's quite odd, the compiler version stack has fetched for you includes libtinfo.
08:42:59 <geekosaur> as long as the read is outside, cw's result type is String which is acceptable to read
08:43:35 <geekosaur> if the read is inside, you have a Nothing that is always result type String and a Just that is potentially any type with a Read instance that the caller requests
08:43:57 <dsal> Thanks, that was it.
08:43:58 <geekosaur> the fact that error never returns control to the Nothing case isn't relevant to typechecking
08:44:36 <dsal> The error would be wrong, though, wouldn't it?
08:45:09 <mauke> > error "invalid column: " ++ "some other stuff"
08:45:12 <lambdabot>  "*Exception: invalid column:
08:45:20 <dsal> Yeah
08:46:08 <geekosaur> no? reread what I just said. at runtime it would not be relevant, at typechecking time it still has to typecheck. error does not propagate its type through the ++, instead its type unifies with String
08:46:47 <alhariel> after uninstalling libtinfo every ghc stack fetches has the ncurses6-nopie suffix
08:46:59 <geekosaur> error's type is not a magic code for 'I am an exception and should propagate that as type information through any expression I am used in'
08:47:31 <geekosaur> it's just a type that unifies with any type, and then ++ with a String value unifies that type with String
08:48:54 <dsal> I'm not sure what you're  disagreeing with.  I understand your answer to why my code failed to compile and mauke confirmed my intuition as to why it wouldn't've done what I wanted anyway.
08:49:15 <geekosaur> [23 15:44:14] <dsal> The error would be wrong, though, wouldn't it?
08:49:27 <geekosaur> maybe I misunderstand what you were trying to say there
08:49:36 <dsal> Yeah, it doesn't produce the error message I wanted.
08:50:15 <geekosaur> right, that's why I pointed it up initially. then realized while doing so that that was probably the source of your typechecking issue as well
08:50:34 <dsal> :t error "thing " ++ "x
08:50:36 <lambdabot> error:
08:50:36 <lambdabot>     lexical error in string/character literal at end of input
08:50:39 <dsal> :t error "thing " ++ "x"
08:50:42 <lambdabot> [Char]
08:50:47 <MarcelineVQ> alhariel: quite odd, I'm guessing your project isn't building in that case?
08:51:24 <dsal> Sure, makes a lot of sense now.  I didn't realize you could append a string to whatever error "x"'s return type is
08:51:26 <alhariel> didnt try it yet, im waiting for the upgrade --git to finish, no problems so far
08:51:27 <dsal> :t error "x"
08:51:29 <lambdabot> a
08:52:07 <geekosaur> it's a type that unifies with any type context it's used in (with some specific exceptions involving impredicativity, I think)
08:52:41 <dsal> Yeah, it seems like it'd have to.
08:53:00 <geekosaur> which is why it's useful, you can use it (properly) anywhere without having to force the type to match with non-error cases. but it also makes this kind of thinko difficult to catch
08:59:16 <dsal> I feel better understanding this, though.  It seemed wrong to me that I had to write a function just to call read.
08:59:22 <dsal> Good to know it was.  :)
09:00:42 <geekosaur> occasionally there are cases when you do need that, mostly involving something that monomorphizes (e.g. lists or maps)
09:01:30 <alhariel> MarcelineVQ, ok so at least stack upgrade --git finished successfully this time, attempting to build the project again
09:03:44 <alhariel> about time lts snapshots moved to 8.2 s:
09:07:53 <alhariel> MarcelineVQ, yup same issue as before, complaining about missing libtinfo
09:08:12 <alhariel> https://pastebin.com/gJs5AwAk
09:08:51 <alhariel> will try installing it again
09:11:14 <MarcelineVQ> alhariel: do you know how to install aur pacages?
09:11:44 <alhariel> with yaourt right?
09:11:55 <MarcelineVQ> whatever you know how to use
09:11:58 <alhariel> also did you say anything after my last message? i had to relog
09:12:02 <MarcelineVQ> no
09:13:00 <cocreature> maybe try a "stack setup --reinstall"
09:13:16 <cocreature> also what’s the output of "pacman -Qs ncurses" and "pacman -Qs tinfo"
09:13:28 <MarcelineVQ> if you do what I would try is installing  ncurses5-compat-libs  and trying  stack setup  again afterwards. it's a semi-longshot but I'm not sure what else might be helpful
09:13:30 <cocreature> and is your system up2date? arch changed with regards to tinfo yesterday
09:13:53 <MarcelineVQ> cocreature is giving good things to try before my suggestion
09:14:27 <alhariel> https://pastebin.com/cTm4WUUa
09:14:55 <cocreature> remove tinfo and update your system
09:15:13 <alhariel> ok but im not exactly running arch, its manjaro
09:15:39 <cocreature> well then updating might not do anything but removing libtinfo is probably a good idea anyway
09:15:45 <cocreature> and then try "stack setup --reinstall"
09:21:32 <alhariel> the package im trying to build requires ghc 8.2, so should i try that command with the latest mightly resolver?
09:21:38 <alhariel> nightly*
09:23:03 <MarcelineVQ> you'll have to
09:24:28 <MarcelineVQ> if the package has a stack.yaml you won't need to specify a resolver yourself, you can just run your commands in its root
09:35:05 <sm> or below
09:39:06 <humanoyd> are there cases where liftA2 and liftM2 give different results?
09:41:35 <mud> humanoyd: Depending on what you consider different, and what Applicative/Monad you're talking about, yes. But usually they shouldn't, in a well behaved Monad. The most obvious thing though is that sometimes liftA2 will work, and liftM2 won't (type error), when something is only an Applicative.
09:43:08 <humanoyd> mud: thanks
10:15:33 <ski> humanoyd : perhaps in some cases `liftM2' will be less defined (or just less efficient) than `liftA2'
10:16:07 <ski> but i think the idea is that, when both are applicable, they "ought" to give the same result
10:20:29 <humanoyd> ski: thanks
10:27:17 <jerin[m]> Hey I'm on arch and trying to use the OS provided Haskell packages. Lately nothing's installing
10:27:26 <jerin[m]> Unregistering would break ... Errors
10:27:33 <jerin[m]> Any known fix I could quickly apply?
10:29:12 <geekosaur> no quick fixes. you can;t replace or upgrade the OS packages, you can usually build stuff if you force ghc -shared (--enable-library-dynamic/--enable-executable-dynamic to cabal/stack iirc)
10:29:52 <cocreature> if you want to keep your sanity you might want to consider not using OS provided Haskell packages (apart from ghc, ghc-libs and ghc-static)
10:30:51 <jerin[m]> What do I switch to? Stack?
10:31:28 <cocreature> stack or cabal
10:33:45 <bjobjo> jerin[m]: https://aur.archlinux.org/packages/stack-static/ is worth a shot
10:34:09 <bjobjo> that's what I use after giving up on the packages in the repo
10:34:55 <michowski> hey guys ;) . i wonder if I can ask a code-related question here?
10:34:58 <humanoyd> will the situation on arch improve in the foreseeable future?
10:36:52 <cocreature> humanoyd: depends on how many people end up yelling at the maintainer :)
10:36:58 <Lokathor> TFW your code has three functions that are all very close but not quite the same :(
10:37:04 <jerin[m]> ^ +1. Also, how do I get the thing uninstalled?
10:37:13 <jerin[m]> Or simply don't bother at all or what?
10:37:19 <cocreature> which thing?
10:37:32 <bennofs> humanoyd: almost any "modern" language is a pain to package with a traditional package manager. most languages nowadays assume that having different projects depend on different versions of the same package is ok (but most disto's package manager requires a globally unique versions of packages)
10:38:06 <Lokathor> Haskell and Rust are both this way
10:38:12 <EvanR> package managers are really for final products, programs and "latest" versions of libraries
10:38:22 <EvanR> not detailed development
10:38:42 <bennofs> even for final products, many projects pin specific versions of libraries
10:39:32 <Lokathor> yeah even if it's "final", you're going to have a fiddly time dragging all versions of all your stackage projects onto exactly the same stackage version
10:39:50 <EvanR> i guess the rationale has always been, the package gods choose 1 version for each package so they all work together. it would be heresy to want different versions to coexist
10:39:57 <jerin[m]> > which thing?
10:39:58 <jerin[m]> The ones which floods or my updates with unregistering errors
10:40:01 <lambdabot>  <hint>:1:13: error:
10:40:01 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
10:40:10 <EvanR> unless its a huge version jump, like SDL 1.2 and 2.0
10:40:20 <EvanR> then you call it something else
10:40:45 <maerwald> Lokathor: haskell and rust?
10:40:51 <maerwald> rust is rather easy to package
10:41:09 <maerwald> and it works fundamentally different than cabal
10:41:12 <cocreature> jerin[m]: what command are you running and what is the exact error message you’re seeing?
10:41:31 <jerin[m]> pacman -Syu gets me errors
10:41:43 <Lokathor> maerwald, yeah I know, it works more like stack
10:41:44 <jerin[m]> Wait while I get a paste
10:41:48 <maerwald> Lokathor: no
10:42:26 <Lokathor> well, i use both stack and cargo on a regular basis, so yes
10:43:53 <maerwald> well, but the statement is incorrect
10:43:59 <Lokathor> how so
10:44:06 <maerwald> crates.io doesn't have releases whatsoever
10:44:31 <Lokathor> oh i didn't care about that part in my evaluation of their similarity
10:44:31 <jerin[m]> Oopsie. Can't reproduce now
10:44:37 <maerwald> and the way stack shares stuff is totally orthogonal to what cargo does
10:44:58 <maerwald> if your statement is not technical, then I have no idea what it was supposed to mean
10:45:49 <humanoyd> cocreature: :) 
10:46:11 <Lokathor> simply that a cargo crate and a stackage package can both be pulled from source, and compiled within their directory, without affecting your ability to do the same with something else from cargo or stack. Neither system actually pollutes a global resource
10:46:23 <humanoyd> bennofs: what will be the solution on the distro level? Something like nix?
10:46:46 <maerwald> Lokathor: cabal can do that too and a few other hundred build systems
10:46:56 <bennofs> humanoyd: maybe. idk if there is a solution at the distro level
10:47:07 <Lokathor> cabal doesn't do that by default and we both know it ;P
10:47:09 <maerwald> that's hardly enough to say those are similar
10:47:30 <maerwald> stack follows a completely different idea and design goal
10:47:31 <monochrom> http://www.vex.net/~trebla/humour/tautologies.html #0
10:48:41 <Lokathor> jerin[m], crates.io archives all released versions of all crates. Things are still reproducable if you keep your Cargo.lock file or specify exact patch versions with your Cargo.toml
10:54:23 <nshepperd> the main problem with distro packages is that you can't ignore them
10:56:30 <nshepperd> they should be installed separately from the packages that come with ghc, so that ghc only sees them when you pass a --global-packages flag or something
10:56:50 <nshepperd> then they wouldn't mess up your development environment
10:59:24 <maerwald> and you don't really have that problem with rust
11:01:45 <shapr> burdges: jeff?
11:01:46 <Cale> Lately I've just been using ghc from nix-shells rather than actually installing it globally at all.
11:02:37 <Cale> Though I probably should at least use nix-env -i to install something globally for convenience.
11:03:49 <Cale> (I use Linux Mint, but I don't use any of its packages for Haskell related stuff obviously.)
11:13:00 <damienstanton> can anyone recommend a package or architecture pattern like Apache Flink / Storm / Spark? Interested in pure streams without the JVM
11:13:10 <damienstanton> can anyone recommend a package or architecture pattern like Apache Flink / Storm / Spark? Interested in pure streams without the JVM
11:13:46 <shapr> I don't understand the question?
11:15:55 <pikajude> even though it got asked twice??
11:16:12 <shapr> funny that
11:16:13 <SegFaultAX> shapr: If you're replying to damienstanton's question: Flink/Storm/Spark are "big data" stream processing frameworks. I think they're asking for the Haskell analog. :)
11:16:29 <shapr> so, they want conduit? machines?
11:16:41 <SegFaultAX> For what it's worth, I've been recommended conduit as a starting point for that kind of project before.
11:17:14 <shapr> damienstanton: perhaps you want https://github.com/tweag/sparkle ?
11:17:29 <damienstanton> Good links, thanks
11:17:56 <damienstanton> Correct, I'm basically looking for good package or pattern for unbounded data streams
11:18:46 <damienstanton> Conduit looks good, and I'll peek at how the interfaces in sparkle look (since I know Spark's architecture)
11:19:02 <shapr> damienstanton: are you already familiar with Haskell?
11:19:13 <damienstanton> Yes
11:19:31 <shapr> ok, just checking
11:21:31 <michowski> Does anyone here have experience with lens for aeson? I can't make them work even after reading many tutorials :/
11:22:19 <Clint> in lens-aeson?
11:22:24 <michowski> Yes
11:22:26 <pikajude> post code?
11:22:50 <michowski> old = ("{\"a\": 2}" :: ByteString) ^? key "a"
11:23:12 <pikajude> and the error?
11:23:19 <damienstanton> Shapr & SegFaultAX: yeah conduit is what I was searching for. Thanks again
11:24:02 <SegFaultAX> damienstanton: Cheers :)
11:24:27 <michowski> oh my! now with this code the error message seems much simpler and not related to lens, actually. sorry for bothering :)
11:24:51 <SegFaultAX> Rubber ducky debugging wins again.
11:25:10 <pikajude> which one of us is the rubber ducky
11:25:13 <michowski> But the thing I still don't get is why I have to use lens-aeson on ByteString, rather than on already decoded Aseon.Value
11:25:34 <shapr> pikajude: all of us!
11:25:44 <shapr> all duckies matter!
11:26:36 <pikajude> i'm so proud of myself
11:26:42 <pikajude> michowski: you can do both
11:26:51 <pikajude> it operates on AsValue t and there's an instance for both of those types
11:27:59 <GamboPango> I added "ghc-options:\  everything: -fPIC" to my "~/.stack/config.yaml" in an attempt to fix a linker error, but in the error dump the flag "-fPIC" is not included among the build flags.  Is there extra config required?
11:29:03 <michowski> Oh my, thank you so much. For some reason "now it works"... I really don't get it, maybe I followed an old error msg from stack file watcher...
11:32:48 <shapr> GamboPango: I think you have to pass that through to llvm or gcc or whatever
11:32:58 <pikajude> i really don't know why ByteString is AsValue, it's very confusing
11:33:35 <shapr> GamboPango: also, I upgraded my GHC version and that fixed the problem with-fPIC for me
11:33:46 <shapr> though I forget the exact cause of the error
11:38:39 <GamboPango> Any idea why the flag is not getting passed?
11:39:10 <remos> !s dvdrip
11:39:31 <shapr> GamboPango: looks like you need to add it to cc-options: https://github.com/haskell/cabal/issues/2207
11:39:44 <shapr> remos: want to write that plugin for lambdabot?
11:40:07 <shapr> remos: we have a bot in channel in Haskell, and we welcome new plugins
11:40:12 <GamboPango> shapr: Thanks for the link!
11:40:44 <shapr> GamboPango: ok, after reading that page, I'm not sure if that'll fix it.
11:40:54 <shapr> GamboPango: if it doesn't, I'll try to find something else :-)
11:41:33 <shapr> poor remos, doesn't know what amazing things options they lost
11:42:17 <GamboPango> shapr: BTW setting "ghc-build: nopie" also seems to get rid of my "-fPIC" woes.
11:42:50 <shapr> oh good
11:45:01 <mnoonan> in other build woes.. is there a way that I can control the link line so that some C libraries appear after a certain haskell library?
11:46:25 <mnoonan> (or maybe a better question is: why does stack [or cabal?] keep trying to build my library as a .so, when I think I only need a .a?)
11:48:09 <shapr> mnoonan: ask on the mailing list? I have no idea
11:48:38 <mnoonan> shapr: thanks, that's at least evidence that I didn't miss something obvious :)
11:49:00 <shapr> I don't know much about that specific subject, sorry.
12:04:02 <GH-PH-Student> Io, haskellers.Something insane just happened.
12:04:31 <shapr> GH-PH-Student: huh?
12:04:41 <GH-PH-Student> I was redoing Graham Hutton's Programming in Haskell 2nd edition exercises, specifically chapter 11 (unbeteable tic tac toe)
12:05:40 <GH-PH-Student> And the bestmove/minimax algorithm was not working at all for the computer player.It would lose.
12:06:10 <GH-PH-Student> So I reviewed the code for hours, using the book as reference, and didn't find any mistakes.
12:06:56 <GH-PH-Student> I downloaded the code from the website and changed just the bestmove/minimax functions in my code and... it worked.
12:07:30 <GH-PH-Student> Except that they only syntax differed from mine.So I uncommented mine 1 by 1 and ... now it works?!! With no modifications?!
12:09:05 <GH-PH-Student> The only syntax difference is identation + in the minimax function i used a newline between 2 pattern matched declarations.
12:09:33 <geekosaur> indentation can count for a lot in Haskell
12:09:35 <GH-PH-Student> Both the compiled and interpreted versions had the same behavior.GHC bug?
12:10:36 <GH-PH-Student> Ye geekosaur, but i reviewed the code a lot.
12:10:45 <GH-PH-Student> And then it started working with no modifications.
12:13:24 <nshepperd> tabs?
12:13:28 <alhariel> is nixos a good distro for haskell dev?
12:14:36 <Eduard_Munteanu> There sure are lots of Haskell packages for Nix, AFAICT.
12:14:44 <shapr> alhariel: I've heard many positive things for that combination, but I've not yet tried it myself.
12:14:48 <nshepperd> GH-PH-Student: restore the version that didn't work and look again
12:15:40 <alhariel> eh im feeling more and more inclined to give another distro a try
12:31:20 <dsal> stack setup vs. machine that doesn't support symlinks == kind of suck
12:31:40 <dsal> er, filesystem.  The machine is several abstractions away from where this is running.  heh
12:44:11 <sm> GH-PH-Student: sounds like an interesting puzzle
13:04:02 <foojs> why we need fp in frontend language like js
13:06:24 <geekosaur> Haskell's IO model turns out to be a great way to reinvert callback-based I/O so you can write it 'naturally'. also treating data as immutable by default helps rule out a number of common bugs. (hence, Haskell-derived languages like Purescript, in addition to mechanism to compile Haskell to Javascript)
13:07:26 <monochrom> I need FP in almost everywhere. It's how I think in the first place.
13:07:27 <geekosaur> oh, and the rules of Haskell IO prevent you from trying to modify the wrong thing at the wrong time in what actually runs as a callback
13:08:40 <foojs> i dont understand this why js need to follow this paradigm
13:09:00 <foojs> unable to get into my head :)
13:09:07 <foojs> haskell is really great language
13:09:14 <geekosaur> I don't understand why it would 'need' to
13:09:15 <monochrom> You don't have to.
13:09:16 <foojs> i would use it as backend
13:09:18 <geekosaur> it's an option, not the law
13:09:30 <monochrom> But I'll do it anyway.
13:11:13 <tdammers> you don't need FP; it's just a pretty promising approach to dealing with callback hell, promise hell, and most concurrency issues
13:11:26 * dsal doesn't need callback
13:12:06 <foojs> i dont see concurrency in frontend
13:12:18 <foojs> that made me tricky why they use fp in frontend
13:12:36 <monochrom> OK, so do it your way.
13:12:42 <tdammers> a typical gui-heavy js frontend has concurrency *everywhere*
13:13:17 <dsal> I've not seen a frontend that didn't have concurrency.
13:13:22 <monochrom> Unless your real agenda is to force the rest of us to do it your way too.
13:13:38 <tdammers> user types, ajax call goes to backend for autocompletion, meanwhile user moves mouse, popup appears, ajax call to backend to fetch stuff for popup, user types some more, first ajax call returns with completions, etc. etc.
13:14:05 <tdammers> if you model this the oldschool way, with event handlers and mutable state updates, it gets really messy really quick
13:14:06 <monochrom> But not going to happen by merely pretending to ask "why" though.
13:14:34 <tdammers> promises are a first step in making highly concurrent JS code more palatable, but they aren't without issues
13:14:56 <Cale> Yeah, a typical gui-heavy application has concurrency everywhere, and a typical gui library isn't threadsafe.
13:15:20 <tdammers> "concurrent" doesn't necessarily imply "threaded" though, mind you
13:16:06 <dsal> It sometimes does, and it sometimes implies reentrant.  You end up doing weird things trying to manage a lot of concurrency with timeliness while avoiding reentrancy and stuff.
13:16:09 <Cale> Sure, but still, it's rather ironic that GTK and such can't deal with such a natural thing to want to do
13:16:28 <Cale> (knowing that GTK is written in C makes it less ironic)
13:16:42 <dsal> A lot of them have that "run on main thread" sort of thing to try to at least keep the event loop aware of what's happening.
13:18:27 <monochrom> The real irony is that Java with its built-in concurrency gave up its chance to propose a new model when it came up with AWT and Swing.
13:18:41 <dsal> Java just punted to web apps.
13:19:13 <tdammers> it's not irony, people just didn't anticipate future developments yet
13:20:02 <tdammers> when those things were designed, multi-core CPUs were the exception, not the norm, and the expectation was that for the foreseeable future, hardware performance would improve by achieving higher clock speeds
13:20:59 <tdammers> also, it wasn't really clear what the "better model" should have been
13:34:56 <eikke> if I have a `a -> t IO b` for some transformer t, is there a way to construct a `a -> IO b` out of it? I'm puzzled.
13:35:39 <mud> eikke: What do you mean by transformer?
13:37:14 <eikke> mud: monad transformer
13:38:15 <EvanR> your t would come with a "run" function that does that
13:38:23 <EvanR> :t runStateT
13:38:25 <lambdabot> StateT s m a -> s -> m (a, s)
13:38:38 <EvanR> imagine m = IO
13:39:23 <eikke> EvanR: that was my suspicion indeed (and looking at it now, obviously there's no other way). Sadly enough that won't fly :)
13:40:27 <EvanR> huh
13:41:04 <EvanR> i think you need to be more specific, a -> t IO b doesnt give you any information necessary to do what you say
13:41:23 <EvanR> theres no universal run function
13:42:29 <eikke> EvanR: yup. My 't' is concrete, and I have its 'run*' function, but I can't use it in this specific context because I need to pass some more arguments to it which I don't have available
13:42:51 <EvanR> are you just trying to execute IO from inside the transformer?
13:43:20 <EvanR> if so, thats the opposite direction
13:43:23 <EvanR> :t liftIO
13:43:25 <lambdabot> MonadIO m => IO a -> m a
13:45:39 <eikke> EvanR: nope. It's related to a Wai middleware which is Application -> Application where Application is Request -> (Response -> IO ResponseReceived) -> IO ResponseReceived. I have this working for something related (for Request -> (Response -> T IO ResponseReceived) -> T IO ResponseReceived), and was wondering whether I could write a version which takes a 'normal' Wai app, and re-use the version which can handle a non-standard Wai-like app
13:46:27 <EvanR> you basically want to run a transformer without providing the args?
13:46:34 <EvanR> how would that work
13:46:47 <monochrom> Wai's monad transformer is going to be pretty like StateT, only more complicated. It can't be done.
13:47:31 <monochrom> There is no going from X -> StateT S IO Y to X -> IO Y. Even less so with Wai.
13:48:24 <eikke> monochrom, EvanR: Indeed, should've thought this through a bit more first *oops*. Maybe monad-unlift could help.
14:01:58 <Ero> Hi All. 
14:01:58 <Ero> does anyone here use idris?
14:05:21 <michowski> Hey. I use lens-aeson and wanted to "dynamically" build a lens (Traversal) inside a recursive function. Sometimes I use a "key" function and sometimes "nth", everything composed with a ".".
14:05:57 <michowski> This is a function signature:     go ::   JsonPathSegments -> JsonPathSegments -> Traversal' J.Value J.Value -> JsonAction
14:06:43 <michowski> And after googling the error I get I can imagine it doesn't really work like this: Illegal polymorphic type:         Traversal J.Value J.Value J.Value J.Value       Perhaps you intended to use RankNTypes or Rank2Types
14:07:24 <monochrom> Dynamically building a lens also sounds like dynamic typing.
14:07:38 <glguy> michowski: The issue is that Traversal is a synonym for a quantified type
14:07:52 <michowski> Any idea how I can achieve what I want? That is, "build a lens" starting from id function?
14:07:57 <glguy> so you'll need a type signature and that extension, or to build an ATraversal instead of a Traversal
14:08:20 <glguy> In the end you can recover a Traversal from an ATraversal using cloneTraversal
14:09:15 <michowski> Thank you guys. I'm going to have a look at ATraversal.
14:09:37 <michowski> Indeed, it is a random path to JSON, so a "dynamic typing".
14:11:04 <michowski> I couldn't figure out on my own how to modify JSON in such a manner without lens.
14:11:09 <glguy> Dynamically "building a lens" is quite common. You're doing it every time you apply ''at'' to an index
14:15:40 <Gurkenglas> michowski, you may be able to use combinators lens already defines to implement your recursive strategy. Take a look at Control.Lens.Plated
14:16:01 <Gurkenglas> (then you can skip the ATraversal stuff)
14:17:26 <glguy> or you can skipe the ATraversal stuff by just turning on the extension and adding the type signature
14:17:28 <ertes> is there a HOAS-style javascript EDSL?  not like jmacro, which uses QQ
14:17:42 <Gurkenglas> Also, if you only use the traversal in one way, you can replace Traversal' with LensLike' and specify the Applicative
14:19:57 <Gurkenglas> michowski, oh and Data.Aeson.Lens provides lenses for JSON
14:20:36 <Gurkenglas> Whoops, you already knew that last one
14:21:58 <michowski> Thank you guys. Is there any trade-off for enabling that extension? I still don't have enough knowledge about forall etc.
14:22:16 <ski> Ero : perhaps you could also try asking in #idris
14:24:16 <tomd_> yo does anyone know how to use CPP preprocessor to detect a Mac OS?
14:25:06 <tomd_> trying #ifdef OS_Mac
14:25:25 <tomd_> should i be `#ifdef __OS_Mac__`?
14:25:31 <tomd_> it*
14:26:02 <geekosaur> https://stackoverflow.com/questions/2166483/which-macro-to-wrap-mac-os-x-specific-code-in-c-c
14:35:15 <tomd_> for future reference, it's `#ifdef __APPLE__`
14:41:17 <Gurkenglas> Can you make ghc stop floating out foralls from right sides of a ->?
15:06:03 <bionic> \quit
15:09:11 <Axman6> The only thing that can contain them is triple parens: const :: a -> (((b -> a)))
15:14:24 <lyxia> also throw in a few square brackets to be sure.
15:15:14 <iqubic> Axman6: How do those triple parens work?
15:20:20 <monochrom> I think it was a joke.
15:24:41 <ClaudiusMaximus> is it just me or is log viewing broken on hackage matrix? eg https://matrix.hackage.haskell.org/package/gulcii i want to see the logs from the failing builds to know which dep is broken so i can work around it or report failure upstream
15:28:19 <geekosaur> you might want to ask in #hackage
15:28:42 <ReinH> Have stack setup downloads of GHC been stalling for anyone else?
15:28:54 <ReinH> Mine is currently stalled at 92.81% :(
15:29:24 <ReinH> I suppose this would also apply to any other haskell.org binary downloads, assuming stack still uses those binaries.
15:29:56 <ReinH> I just want to parse some CSV :(
15:32:49 <ReinH> Oh, I restarted it again and it worked this time. 13th try is the charm, I guess.
15:33:48 <monochrom> I actually think stack doesn't download from haskell.org.
15:33:55 <ReinH> It certainly used to.
15:34:12 <ReinH> I haven't had occasion to check in the last couple years though.
15:35:19 <geekosaur> I thought they mirrored everything in s3 buckets these days
15:39:45 <ReinH> Oh, that would make sense.
15:42:50 <someuniquenickna> hello everybody. Is there a documentation on gi-gtk-hs somewhere? it claims to be a wrapper for gi-gtk, adding a few more idiomatic API parts on top, but i can't seem to find any docs or even examples
15:43:32 <glguy> It's linked from the hackage page: https://hackage.haskell.org/package/gi-gtk
15:44:18 <hamishmack> Most of the code in gi-gtk-hs is ported from Gtk2Hs gtk and gtk3 packages
15:44:20 <glguy> https://github.com/glguy/CookieCalculator/blob/master/gui/Main.hs is an example of using it
15:44:44 <glguy> You can use the native documentation from GTK to understand what the objects, methods, and parameters are
15:44:56 <ertes> alternative: is there any embedded language that compiles to JS online and is general-purpose enough to write frontend code?
15:46:01 * kg
15:46:31 <hamishmack> gi-gtk-hs mostly provides code for lists and combo box controls and the like
15:47:01 <glguy> There's gi-gtk, and there's gtk-hs
15:47:15 <glguy> but what's this gi-gtk-hs?
15:47:50 --- mode: glguy set -o glguy
15:48:17 * glguy reads hamishmack pre-answer
15:49:02 <geekosaur> go back a minor version to get docs
15:49:04 <hamishmack> Looks like haddock docs are not present for gi-gtk-hs
15:49:51 <hamishmack> Slightly older version has them https://hackage.haskell.org/package/gi-gtk-hs-0.3.4.3
15:49:59 <geekosaur> they'll probably be a little behind but hopefully not too much since it's a minor version bump if it's pvp
15:51:29 <someuniquenickna> slihtly older version will do, thanks
15:53:08 <hamishmack> someuniquenickna: there are also some code examples here https://github.com/haskell-gi/gi-gtk-examples/search?utf8=%E2%9C%93&q=ModelView&type=
16:01:50 <jp_rider> hi. Is there any reason cabal new-build can't find a project while cabal build can? http://lpaste.net/4605804850989498368
16:04:09 <geekosaur> at a guess, it's misreporting the same error cabal build got (solver failed, fed back up an empty buildable package list?)
16:06:06 <jp_rider> If I pass --allow-newer to new-build (which I expect should take care of the regular build error), I get the same error message.
16:08:18 <glguy> jp_rider: Did you try any of the suggestions in the message new-build printed?
16:10:12 <jp_rider> If I specify the package name, I get unknown targets, unknown targets
16:10:23 <jp_rider> I'll try all
16:12:42 <hexagoxel> jp_rider: do you have a cabal.project file? what are its contents?
16:15:15 <jp_rider> Sorry, should have included that. http://lpaste.net/8040301588406861824
16:16:50 <jp_rider> It looks like it gets farther if I omit the foundation (but compiling without that fails since I need patches from angerman's fork for cross-compilation)
16:16:54 <zenspider> is there a way to make HUnit output not do silly TTY stuff? I'm running it inside of emacs and just want the final output
16:17:20 <dsal> stack test --test-arguments --plain
16:18:19 <angerman> jp_rider: yes you need to use a patched foundation.
16:19:22 <jp_rider> o hi!
16:19:59 <hexagoxel> jp_rider: could you test if moving "." into the "packages:" line works?
16:20:30 <hexagoxel> i.e. "packages: .\n/User/" etc.
16:20:37 <angerman> To use head hackage and other overlays you need to either use the shell script from head.hackage to update it. Or use a patched cabal (see the new-update PR).
16:20:37 <zenspider> dsal: and if I'm not using stack?
16:20:55 <angerman> Sorry it’s all kind of a mess.
16:22:01 <geekosaur> zenspider, just pass --plain to the test program
16:23:02 <angerman> jp_rider: are you confident packages accepts new lines? I’ve never tried that.
16:23:59 <angerman> jp_rider: what I usually do is add the packages as submodules to the one I try to compile. And add “. foundation ...”
16:24:01 <zenspider> geekosaur: nope? doesn't seem to process cmdline args... hrm
16:24:31 <zenspider> oh. I'm using a deprecated runner... sec.
16:24:31 <geekosaur> it should, it's built into the HUnit entry point
16:24:50 <jp_rider> hexagoxel: huh that seems to fix that error. getting further with compilation (hitting other errors though)
16:24:52 <jp_rider> thanks! 
16:25:23 <angerman> jp_rider: please open a cabal issue!
16:26:08 <jp_rider> angerman: I'm not sure. I've never tried using cabal new-build before. I'll try symlinking them as subdirectories and let you know how that goes
16:26:12 * hexagoxel has serious doubts about the cabal.project grammar design decisions
16:26:13 <jp_rider> ok, will do
16:27:09 <angerman> hexagoxel: yes :-(
16:27:58 <angerman> jp_rider: i would assume absolute path would work.
16:28:21 <zenspider> geekosaur: what entry point is that?
16:28:32 <angerman> jp_rider: just wanted to share my workflow (which works for me)
16:29:05 <jp_rider> angerman: angerman: I'd expect that too, but maybe your way will work
16:30:07 <zenspider> I don't see any way to specify the test output style... 
16:30:17 <jp_rider> do you think it'd be feasible to set up the cross-compilers for stack (similar to ghcjs)? maybe that'd be more reliable? 
16:31:01 <zenspider> it looks like the only thing I have availble is runTestTT and that doesn't take anything but my list-o-tests
16:32:51 <geekosaur> we seem to have confused this with a different test suite. but you would not see this in your code
16:33:09 <geekosaur> this would be a getArgs call buried somewhere in or under runTestTT
16:33:45 <geekosaur> and if you needed to modify it you would need to use withArgs to change what the getArgs produces
16:36:33 <geekosaur> thing is, I also don
16:37:17 <geekosaur> t see any code in HUnit to do any kind of fancy formatting beyond \r stuff and there's no way to override that except to build your own modified HUnit
16:37:54 <angerman> jp_rider: tbh, I don’t know and don’t use stack much.
16:39:43 <jp_rider> angerman, hexagoxel: FYI https://github.com/haskell/cabal/issues/4843
16:40:03 <geekosaur> maybe run it under a more complete test management suite that can clean up the output? like tasty + tasty-hunit-adapter maybe
16:40:05 <jp_rider> ok, maybe I can look into it at some point
16:41:07 <zenspider> this works: runTestText (putTextToHandle stderr False) tests
16:41:17 <zenspider> took too much to figure that out... but it works :)
16:42:15 <zenspider> tho I think I'd rather that False be figured out if TERM="dumb" or somesuch
16:48:43 <zenspider> hrm... Still don't grok some of this IO/monad stuff... how can I compare against `getEnv "TERM"` ?
16:49:01 <geekosaur> >>= or do notation
16:49:17 <zenspider> I'm doing the do notation? unless I don't understand
16:49:19 <zenspider> main = do ...
16:49:31 <Cale> zenspider: getEnv "TERM" will be an IO action, so you'll probably want to run it before doing something with the result
16:49:38 <Cale> yeah, use do notation
16:49:41 <geekosaur> term <- getEnv "TERM"; if term == "dumb" then ...
16:49:44 <geekosaur> else ...
16:49:51 <Cale> yeah, like that
16:49:53 <zenspider> I'm doing just that
16:50:02 <zenspider> term <- getEnv "TERM"
16:50:07 <zenspider> dumb <- "dumb" == term
16:50:11 <Cale> nah
16:50:17 <zenspider> IO Bool vs Bool
16:50:18 <Cale> (==) doesn't produce an IO action
16:50:25 <Cale> It just produces a Bool
16:50:32 <Cale> so you don't have to run the resulting Bool
16:50:32 <zenspider> oooooh.... ok
16:50:43 <zenspider> let dumb = ...
16:50:48 <Cale> yeah, that'll work
16:50:55 <geekosaur> if the type is IO something or ... -> IO something then use <-. if not, you can just use it directly or use let
16:51:13 <geekosaur> @where iotut
16:51:13 <lambdabot> https://www.vex.net/~trebla/haskell/IO.xhtml
16:52:12 <jp_rider> angerman: FYI, I get the same result w/ full paths and symlinked subdirectories
16:52:44 <angerman> jp_rider: on the same line?
16:52:47 <zenspider> well fuck... dumb is always true even if I'm in an xterm
16:52:57 <angerman> Or with linebreaks?
16:53:11 <jp_rider> linebreaks
16:53:38 <jp_rider> i'll try on the same line (although I don't think i'm getting new-build errors now, just version conflicts)
16:53:42 <angerman> jp_rider: I actually believe the linebreaks could be the issue.
16:55:06 <angerman> In general I think new-build needs to be used more excessively and more hands on deck :-(
16:55:24 <jp_rider> yes, same result for sameline
16:55:53 <angerman> What’s the issue now?
16:57:57 <jp_rider> I don't know, I feel like new-build missed the boat. stack seems to address most of these sorts of issues
16:58:03 <jp_rider> http://lpaste.net/38737104611573760
17:01:06 <angerman> jp_rider: I believe the issue is that you try cryptonite with gmp, your cross compiler doesn’t have gmp. It only has simple-integer
17:03:06 <angerman> package cryptonite
17:03:06 <angerman>   flags: -integer-simple
17:03:21 <angerman> Something like that. The flag for cryptonite might be wrong.
17:04:48 <angerman> Prob `flags: -integer-gmp`
17:05:44 <zenspider> Does everyone turn off name-shadowing? This binding for ‘max’ shadows the existing binding imported from ‘Prelude’... so all names should be unique at all scoping levels? or is there something I'm not getting?
17:06:04 <jp_rider> Do I put that in cabal.project? I get the same error with it included
17:06:24 <angerman> Yes it should go in the cabal.project file.
17:06:44 <raynold> ahh it's a wonderful day
17:06:50 <angerman> jp_rider: does it still try cryptonite:+integer-gmp?
17:07:13 <angerman> raynold: 32°C, I agree.
17:07:20 <angerman> Time to get up.
17:08:35 <zenspider> Also how do I address type default warnings? My unit tests have a ton of this: Defaulting the following constraints to type ‘Integer’ (Enum a0) arising from the arithmetic sequence ‘1 .. 4’
17:08:36 <jp_rider> Sorry, I was wrong. It looks like it's no longer trying to use gmp http://lpaste.net/24438196410515456
17:09:21 <zenspider> (code in question: 4 ~=? myLast [1..4])
17:09:53 <ski> add an explicit type ascription ?
17:09:56 <zenspider> and I named it myLast to avoid name shadowing :/
17:10:12 <ski> `(4 :: Integer) ~=? ...'
17:10:34 <jp_rider> looks like there's a new version of basement i need
17:12:02 <jp_rider> zenspider: I turn them off. This has bitten me once when reusing a name inside a let definition which caused an infinite loops 
17:12:19 <jp_rider> something like: let reused = f reused
17:12:43 <zenspider> jp_rider: the name shadowing? yeah... it seems not terribly helpful. At least, I'd rather only see them within the local scopes, not imported
17:14:01 <zenspider> ski: that seems really ugly and I don't see why the warning exists... 4 is well within any normal int boundaries and the type sig for myLast is clean... so I don't understand why the warning exists or what it is trying to clarify for me
17:15:00 <jp_rider> angerman: things are compiling after adding basement to the packages list in cabal.project :)
17:15:05 <jp_rider> *crosses-fingers*
17:15:13 <zenspider> last q... I want to break up these tests from One Huge List at tho bottom. Test includes TestList [Test], which is how I think I'm using it. Can I concat those together somehow to specify my suite?
17:15:44 <zenspider> I think I'm just gonna decide that name shadowing and type default warnings are not worth it (for now)
17:17:37 <zenspider> looks like I can break out to a bunch of Test instances, and concatenate them with `test` and another list
17:18:34 <Gurkenglas> How do I handle intero's M-. saying "No tags containing rectangleSolid"?
17:19:37 <zenspider> Gurkenglas: are you actually tagging the code?
17:19:50 <zenspider> I don't know intero, but that's hinting that you should have a TAGS file
17:20:27 <jp_rider> on a side note, would an MIT licensed alternative to gmp be useful? This could be used as an Integer backend for cross-compiling and I know there are some licensing concerns with gmp. I started writing one in Rust and made decent progress
17:20:47 <geekosaur> if it is reasonably performant, yes
17:21:09 <geekosaur> libtommath was apparently tried a few years ago and found even slower than integer-simple (which has since been optimized a bit)
17:22:43 <zenspider> OK... I'm just confused by shadowing & namespacing in haskell. If I go from myLast -> last then I get errors saying Ambiguous occurrence ‘last’ It could refer to either ‘Prelude.last’ or Main.last. 
17:22:52 <zenspider> How does scoping work in haskell? 
17:23:24 <geekosaur> names you import unqualified are in the local namespace
17:23:54 <zenspider> yes... and?
17:24:04 <geekosaur> which is why you get that. if you want to use 'last' as a local binding then you want to explicitly "import Prelude hiding (last)"
17:24:09 <jp_rider> zenspider: You might want to `import qualified Prelude` or `import Prelude hiding (last)`
17:24:25 <geekosaur> qualified import of Prelude is usually not the best of ideas
17:24:31 <jp_rider> true
17:24:33 <geekosaur> unless coupled with an import ... hiding
17:25:10 <geekosaur> so "import Prelude hiding (last); import qualified Prelude (last)" would let you use the Prelude one qualified without making lots of other stuff break
17:26:37 <Gurkenglas> zenspider, I have used a command that probably makes tags, and going to a definition works for some definitions, and trying to go to one sometimes asks if I want to "also" keep old tags files (I answer yes). I suspect that command only works in projects (as projectile-regenerate-tags claims) rather than the standalone .hs files I sometimes and currently work in, and works for those imports I've made tags files 
17:26:38 <Gurkenglas> for earlier from some project
17:27:12 <geekosaur> do you have a file named "tags" or a file named "TAGS"?
17:27:14 <Gurkenglas> I was hoping for a way to get it to work without making a dummy project that imports the things I use. (Hmm, a use for acme-everything?)
17:27:23 <geekosaur> ctags format (used by vi) is not the same as emacs TAGS file format
17:27:35 <Gurkenglas> I don't use vi
17:28:18 <jp_rider> geekosaur: ok cool. who's involved in including gmp backends? the ghc devs? In the meantime I'll publicly push what code I have
17:28:27 <geekosaur> M-x visit-tags-table might be of interest?
17:28:43 <geekosaur> ghc devs, yes. might ask in #ghc
17:29:29 <jp_rider> ok, will do
17:29:31 <zenspider> Gurkenglas: just a warning... emacs ships with ctags, but it is vastly inferior to exuberant ctags (ectags usually)
17:29:39 <Gurkenglas> geekosaur, no such file in the current folder, but I use stack, so it might be somewhere else on the filesystem. How do I have it tell me where the file it's currently using is?
17:30:09 <Gurkenglas> Is this compatible with intero, zenspider?
17:30:43 <zenspider> Gurkenglas: again, I don't use intero, so I dunno... but if this is using the usual emacs tags stuff, then yes
17:31:47 <geekosaur> easiest way is probably M-x select-tags-table to get a menu of the loaded tags tables
17:31:50 <zenspider> I have a rather involved shell script `retag` that knows all the languages I use and the standard names I want to filter out... I run that any time I get a miss when trying to follow a tag
17:32:20 <Gurkenglas> Neither package-install nor M-x find "ectags"
17:32:25 <zenspider> geekosaur: your hiding + qualified one means I can use Prelude.last explicitly if I need to?
17:32:36 <geekosaur> zenspider, yes
17:32:52 <zenspider> Gurkenglas: ectags isn't part of emacs, it is a system package. I get it in homebrew (osx) via ectags
17:32:56 <Gurkenglas> 2 are called TAGS, one tags
17:33:12 <Gurkenglas> http://lpaste.net/8046960372558594048
17:33:38 <Gurkenglas> Oh wait, there appear to be two in a line, for a tie
17:33:58 <zenspider> a tie?
17:33:59 <Gurkenglas> Actually it's three in a line, 3:2 for tags now
17:34:18 <zenspider> those are all (probably) tag files
17:34:21 <geekosaur> ectags would normally be from the exuberant-ctags system package
17:34:29 <Gurkenglas> I'm on Windows
17:35:13 <Gurkenglas> Support for Windows seems to end with XP? :P
17:35:17 <zenspider> I guess I don't understand the how/why of haskell's namespacing philosophy. I'm used to scheme / LISP1 and would expect defining `last` to be unambiguous within the scope of this file
17:36:59 <geekosaur> https://www.haskell.org/onlinereport/haskell2010/haskellch5.html#x11-980005
17:38:43 <geekosaur> you can bring names into your module namespace unqualifiedor qualified; qualified names are always unique, so you can always use the current module name to get the definition from within that module as opposed to imported. you can also change the qualifier for the qualified import with import [qualified] ... as Name
17:40:06 <angerman> jp_rider: wheeee! ;)
17:40:45 <geekosaur> section 5.3.4 has a table summarizing the various forms of import and their effects on the namespace.
17:40:47 * ski . o O ( `import qualified A as AB; import qualified B as AB' )
17:41:21 <geekosaur> it's a little weird in that 'import qualified A (foo)' brings the name A.foo into the local namespace, instead of giving you acces to the name foo in the A namespace
17:43:26 <geekosaur> .oO { as long as it doesn;t leave you ABD }
17:46:45 <gh_fo> using servant client, what should I be using if I want to download a file to disk? (i.e. don't care about parsing data other than to confirm the transfer works)
17:49:00 <monochrom> The real fun begins when you try to re-export what you think you have imported. :)
17:49:27 <monochrom> http://www.vex.net/~trebla/haskell/module.xhtml#re-export
17:53:05 <gh_fo> anyone else use servant for this?
18:04:04 <zenspider> what's the point of `import A()` ? Just to get the name A only?
18:04:23 <jxv> It imports instances
18:04:33 <geekosaur> it imports any typeclass instances in module A, but no names
18:04:40 <jxv> ^
18:05:00 <zenspider> I'll understand that someday :P
18:05:44 <geekosaur> note that you have no control over import of typeclass instances; they are always imported and always affect the entire program, not just the module(s) they are imported into, because they have runtime dictionaries associated with them
18:06:18 <geekosaur> and because the typesystem becomes unsound if different/incompatible instances are defined or imported into different modules in the same program
18:11:32 <zenspider> I think this was the part of the Little MLer where I started to glaze over 
18:13:07 <Gurkenglas> Is this why the Prelude doesn't define any instances?
18:13:54 <Gurkenglas> (Wait, does `import A()` import instances imported by A?)
18:14:08 <gh_fo> is there a way to select type-level type based on value-level values at run time?
18:14:34 <Gurkenglas> There is no type at runtime unless you add run-time type information via something like Dynamic, gh_fo 
18:15:14 <zenspider> is there a way to get hlist or ghc/i to bitch about unused top level vars? I'm breaking up my tests so I can put the tests under each function and I want the system to remind me that I haven't plugged a new test into the suite
18:15:26 <gh_fo> i see
18:15:30 <Gurkenglas> gh_fo, but elaborate on your situation, this is a common tool some reach for when they don't need to
18:15:31 <MarcelineVQ> gh_fo: to a degree you can, it's a little clunky currently though  https://www.schoolofhaskell.com/user/konn/prove-your-haskell-for-great-safety/dependent-types-in-haskell
18:15:55 <gh_fo> yeah was wondering if there was some clever dependent-type trick to do this
18:15:57 <MarcelineVQ> Gurkenglas is very right about that as well
18:16:19 <gh_fo> typed vectors is a good example
18:16:27 <geekosaur> zenspider, -Wunused-top-binds
18:16:30 <gh_fo> what about the case where there's a function that takes a value
18:16:47 <gh_fo> and i want to initialize a vector with size determined by that value
18:17:23 <gh_fo> if value to type level information transfer is mostly prohibited, is there an alternative way to get that functionality that doesn't involve
18:17:34 <gh_fo> trying to have a type definition depend on the value?
18:17:36 <gh_fo> (can't think of any)
18:18:35 <zenspider> perfect. thank you... wait no, it doesn't seem to report anything (I just disconnected a test on purpose)
18:18:36 <MarcelineVQ> in the case of vector I'd use someone else's canned solution  https://hackage.haskell.org/package/vector-sized-0.6.1.0/docs/Data-Vector-Sized.html
18:19:18 <MarcelineVQ> I'm not sure whether that's a proper answer to your question though, I've not really done much with haskell type-level-fu
18:21:22 <geekosaur> hm. you could try -Wunused-binds which turns on all of the unused binding warnings, but this might be a bug. or might require -O to work, like gcc used to (possibly still does)
18:22:14 <Gurkenglas> "<gh_fo> if value to type level information transfer is mostly prohibited" afaik the most you can get is having type values on the value level & mostly can be scratched
18:22:15 <geekosaur> the former would be a ghc bug, the latter a ghc documentation bug
18:22:42 <gh_fo> MarcelineVQ thanks, it looks like sizes are declared in the type in that library, you'd never instantiate a vector based on a size value from the looks of it
18:24:08 <Lokathor_> So i have three similar things (graphical layers in a display) that each have different associated data, but i want to store them all in a list
18:24:38 <Lokathor_> Do i make a sum type, or do i do some other wacky thing?
18:24:41 <Gurkenglas> The source link for withSized doesn't seem to work https://hackage.haskell.org/package/vector-sized-0.6.1.0/docs/Data-Vector-Sized.html#v:withSized
18:25:36 <Gurkenglas> gh_fo, as a few functions in there show, you can build vectors of size that is unknown at compile time so long as your functions can handle any size
18:27:04 <ski> Lokathor_ : i suppose they don't support the same set of operations .. ?
18:28:14 <Lokathor_> ski, well they can each be drawn with, but they also support updates that are unique per layer (eg: you can't do setColor on a texture layer)
18:28:45 <Lokathor_> I suppose the wrong op on the wrong later could just do nothing and print a warning
18:28:57 <Lokathor_> The wrong layer*
18:29:03 <zenspider> geekosaur: oh... it only works for actual compilation. not interpretation
18:29:16 <geekosaur> that wouldn't surprise me much
18:29:40 <geekosaur> the interpreter is not especially smart, and if you meant ghci as opposed to runghc then even less smart than that
18:30:28 <geekosaur> bytecode backend is missing a lot of functionality
18:30:30 <zenspider> using runhaskell but not married to it
18:30:39 <geekosaur> it's basically there for TH and ghci
18:30:46 <zenspider> hrm... is there a check but don't write anything mode?
18:30:53 <geekosaur> -fno-code
18:40:03 <ski> Lokathor_ : what do you want to do with the list ?
18:44:07 <Lokathor_> ski, well the layers have a sequence to them when drawing. Lower number layers must be drawn first
18:44:21 <Lokathor_> So i was putting them all in a list and using mapM_
18:45:47 <Lokathor_> I guess i could make a sum type where each type holds a data blob of a different type, and those blobs can have the correct ops performed on them only
18:47:44 <zenspider> geekosaur: perfect. thank you. I think this makes it much more manageable, albiet slower to run
18:47:54 <MarcelineVQ> Lokathor_: could look at https://hackage.haskell.org/package/sorted-list-0.2.0.0/docs/Data-SortedList.html if the order is absolutely important, though I've not used that
18:48:18 <iqubic> So, I fire up a ghci session and ask the following:
18:48:24 <iqubic> > 1.5 `div` 2
18:48:28 <lambdabot>  error:
18:48:28 <lambdabot>      • Ambiguous type variable ‘a0’ arising from a use of ‘show_M700420011892...
18:48:28 <lambdabot>        prevents the constraint ‘(Show a0)’ from being solved.
18:48:40 <iqubic> It fails like such.
18:48:43 <iqubic> Why?
18:48:44 <geekosaur> :t div
18:48:45 <lambdabot> Integral a => a -> a -> a
18:48:54 <geekosaur> :t 1.5
18:48:56 <lambdabot> Fractional p => p
18:49:09 <iqubic> > (1.5 `div` 2) :: Float
18:49:09 <geekosaur> there is no type with both Fractional and Integral instances
18:49:13 <lambdabot>  error:
18:49:13 <lambdabot>      • No instance for (Integral Float) arising from a use of ‘div’
18:49:13 <lambdabot>      • In the expression: (1.5 `div` 2) :: Float
18:49:27 <iqubic> geekosaur: So how do I get haskell to do that division?
18:49:37 <iqubic> > 1.5 `div` 2.0
18:49:40 <lambdabot>  error:
18:49:40 <lambdabot>      • Ambiguous type variable ‘a0’ arising from a use of ‘show_M356758099596...
18:49:40 <lambdabot>        prevents the constraint ‘(Show a0)’ from being solved.
18:49:40 <geekosaur> > 1.5 / 2
18:49:44 <lambdabot>  0.75
18:49:51 <iqubic> Why is that a thing?
18:49:54 <geekosaur> div is integer division only
18:49:56 <iqubic> :t (/)
18:49:58 <lambdabot> Fractional a => a -> a -> a
18:50:54 <geekosaur> and it's a thing because it is usually faster than floating point division or rational division
18:52:05 <Lokathor_> MarcelineVQ, the order is already kept by the sequence-ish container. Any sequence-ish thing should work (list, vector, seq), i just happened to default to list to start
18:53:08 <MarcelineVQ> To paraphrase a bit  'I find your surplus of faith disturbing' :>
18:54:22 <MarcelineVQ> Don't mind me though if that package isn't helpful, just exploring a bit
18:54:39 <ski> Lokathor_ : once you've put them in the list, you'll only draw them ?
18:57:06 <ski> > 1.5 `div'` 2  -- iqubic ?
18:57:09 <lambdabot>  0
18:57:54 <ski> > 1.5 `div'` 2  -- iqubic_ ?
18:57:58 <lambdabot>  0
18:58:25 <Lokathor_> ski, no, the user will probably also update them between draws, probably at 60fps or so
18:59:13 <Lokathor_> MarcelineVQ, the layers aren't Ord so I cannot sortedlist them :(
18:59:29 <ski> > pi `divMod'` exp 1
18:59:31 <lambdabot>  (1,0.423310825130748)
19:00:37 <jchia> Is there a function of type "Monoid v => Map k v -> Map k v -> Map k v" That combines same-key values using mappend on the v?
19:01:18 <jchia> Or some simple combination of existing functions so that I don't have to write this from scratch?
19:01:27 <mud> M.unionWith mappend ?
19:01:54 <jchia> mud: Thanks, I think that's what I'm looking for
19:02:01 <mud> Cool, 'welcome
19:03:39 <felix1> in persistent: any ideas how to get a `Key Model` for my `Model` when the key is not an Int64 (i.e. declared via the `Primary` keyword)
19:04:41 <jkachmar> does entityKey not do this?
19:05:32 <felix1> jkachmar: without access to an entity
19:05:44 <felix1> the id is coming from a file i am reading in
19:06:16 <felix1> i could do a round trip to the database to get the key, but was wondering if there was a way w/o
19:06:16 <jchia> Is there a simple function of type "Monoid v => [(k, v)] -> (k, v)" or "[(k, v)] -> (k, [v])" That allows me to combine a list of (k,v) by keeping only the first k and 'mconcat'ing the v's or put them in a list?
19:10:52 <monochrom> No, I don't think Haskellers are fond of key-value lists enough to develop elaborate libraries like this.
19:11:38 <monochrom> Instead we look for these key-value utilities in the containers library.
19:11:43 <jchia> monochrom: OK, I'll convert all the pairs to maps with singletonMap first and then use map operations.
19:12:52 <suzu> Map can do that
19:12:57 <monochrom> Emacs would be where programmers would be fond of key-value lists. But it's just because they're in a list-based religion.
19:13:25 <monochrom> Even then I recently found that its key bindings use an abstract dictionary.
19:13:40 <suzu> pretty sure: instance Monoid v => Monoid (Map k v)
19:17:19 <jchia> suzu: I'll have to use "unionsWith mappend " on the "Map k [v]" to concatenate all the list values
19:17:42 <suzu> guess so
19:18:35 <suzu> that instance i thought existed, does not
19:20:18 <jchia> I think the Monoid instance of Map is defined to be less general (without constraints) so that it is always available.
19:24:13 <jkachmar> @felix1 keyFromValues might be what you're looking for
19:24:13 <lambdabot> Unknown command, try @list
19:37:00 <jkachmar> yeah something like `(hush . keyFromValues $ [toPersistValue myIdent]) :: Maybe MyIdType` would probably do it felix1 
20:02:41 <felix1> jkachmar: thanks, but turns out the TH code generates a value constructor
20:03:04 <felix1> jkachmar: i asked and answered my question here: https://stackoverflow.com/questions/46901164/persistent-tosqlkey-for-custom-primary-key
20:36:05 <doomrobo> how do I view the output of CPP macro expansion from ghc?
20:40:36 <Eduard_Munteanu> doomrobo, ghc -E   I think
20:41:52 <Eduard_Munteanu> Similar to the gcc flag.
20:43:02 <doomrobo> ah, ok. not getting any output though :\
20:44:37 <Eduard_Munteanu> doomrobo, it generates a hspp file
20:45:46 <doomrobo> ooh nice. thanks!
21:00:13 <doomrobo> Is there a way to have the CPP preprocessor put a line break between lines of a macro expansion. I realize that the trailing \ will escape the subsequent linebreak, but I need it. Also template haskell is overkill for what I'm trying to do
21:16:09 <doomrobo> nvm, semicolons worked
21:25:05 <ekthalooser> Hi I just started haskell just now, and I am interested in scientific computing....If haskell is my only programming/first language. How long it might take me to write basic scientific comptations
21:26:28 <mud> ekthalooser: Somewhere between 12 seconds and a lifetime, depending on how much effort you put into it, and your definition of what a basic scientific computation is.
21:27:09 <mud> I wouldn't focus too much on how long it takes, when learning a language. It tends to just stress you out or discourage you.
21:30:21 <ekthalooser> mud:  12 sec ?/ I read this https://www.reddit.com/r/haskell/comments/2rsxrb/is_haskell_a_good_programming_language_for/   and I am scared
21:32:36 <ekthalooser> mud:  basic computation means differentiating/integrating sometimes computing multiple matrices 
21:32:47 <ekthalooser> visualising results etc
21:33:14 <mud> I'm not all that familiar with those libraries
21:33:23 <mud> That reddit thread is likely to know better than I will.
21:33:29 <peddie> ekthalooser: it's pretty easy to do basic optimization, ODE solving, numerical quadrature etc. in haskell
21:33:41 <ekthalooser> I dont like PYTHON because its meaning snake
21:33:47 <ekthalooser> I dont like snakes
21:34:18 <ekthalooser> peddie sounds good
21:34:22 <peddie> ekthalooser: I usually use the bindings to the GSL
21:34:26 <peddie> https://hackage.haskell.org/package/hmatrix-gsl
21:34:42 <ekthalooser> peddie Ok 
21:34:55 <peddie> ekthalooser: works fine for small problems
21:35:24 <ekthalooser> Large problems hell ?
21:35:30 <peddie> ekthalooser: I don't think visualization is too good, or at least I haven't found an easy way to do it compared to just dumping the data and plotting it in matplotlib
21:35:46 <peddie> ekthalooser: it's more just that those bindings are all designed for convenience and safety, not for high performance
21:36:03 <peddie> ekthalooser: for larger optimization problems in haskell I have used the DYNOBUD toolkit
21:36:22 <peddie> which drives a bunch of C++ libraries under the hood but puts a nice and type-safe interface on it
21:36:35 <peddie> haven't had a lot of performance problems with that 
21:37:05 <ekthalooser> peddie matplotlib again using python ?
21:37:12 <peddie> ekthalooser: yeah, just for the plotting
21:37:34 <peddie> ekthalooser: but you could use gnuplot or octave if you have a snake allergy
21:37:50 <ekthalooser> peddie:  I asuume you just use haskell for everything and only for plotting matplotlib 
21:38:03 <peddie> ekthalooser: for those kinds of problems, yes
21:38:07 <ekthalooser> peddie:  snake is satan (just a joke)
21:38:26 <peddie> ekthalooser: do you have a specific thing you want to compute / problem to solve?
21:38:47 <ekthalooser> peddie:  Yes 
21:39:09 <ekthalooser> I have an idea but not sure how to do it, it is a scientific problem
21:40:01 <peddie> ekthalooser: by the way, there is a channel called #numerical-haskell which is occasionally helpful for scientific or numerical problems (although you will have to be patient; it's not a busy place)
21:40:21 <ekthalooser> Ok thank you peddie  I am joining that
21:40:37 <peddie> ekthalooser: if you can say more about your particular problem, people can perhaps give better guidance around whether and how to solve it in haskell
21:40:45 <ekthalooser> I am asking ther
21:40:50 <ekthalooser> will leave this channel for now
21:46:07 <kaychaks> am trying to execute some code inside an Org file but getting error `could not find any installation of ghc`. my emacs is setup with intero / stack for usual haskell stuff. for org mode source code execution I guess inf-haskell mode is being used and somehow it's not getting ghci. I tried changing the `haskell-process-type` to `'stack-ghci`but no luck.
22:56:11 <d6e> Potentially dumb question, can one double fmap a nested functor?
22:57:02 <slack1256> :t (fmap . fmap)
22:57:04 <lambdabot> (Functor f2, Functor f1) => (a -> b) -> f1 (f2 a) -> f1 (f2 b)
22:57:09 <slack1256> yes
22:57:43 <slack1256> > (fmap . fmap) (+1) (Just (Identity 9))
22:57:46 <lambdabot>  Just (Identity 10)
22:58:21 <d6e> ah, yes the (.) operator, thanks
22:59:30 <cocreature> d6e: you might also be interested in the Compose newtype from Data.Functor.Compose
22:59:45 <cocreature> :t getCompose .  fmap . Compose
22:59:47 <lambdabot> error:
22:59:47 <lambdabot>     Variable not in scope: getCompose :: (f0 a0 -> f0 b0) -> c
22:59:47 <lambdabot> error:
22:59:54 <cocreature> @let import Data.Functor.Compose
22:59:58 <lambdabot>  Defined.
22:59:59 <cocreature> :t getCompose .  fmap . Compose
23:00:02 <lambdabot> error:
23:00:02 <lambdabot>     • Couldn't match type ‘f0 a0 -> f0 b0’ with ‘Compose f1 g1 a1’
23:00:02 <lambdabot>       Expected type: f (g a) -> Compose f1 g1 a1
23:00:13 <slack1256> If I bind value on ghci { ex1 <- System.IO.readFile "/home/user/file" } and import an extra module, that binding is lost
23:00:25 <slack1256> how can I preserve it?
23:00:38 <cocreature> :t \f -> getCompose . fmap f . Compose
23:00:40 <lambdabot> forall k1 (f :: k1 -> *) (g :: * -> k1) a1 a2. Functor (Compose f g) => (a1 -> a2) -> f (g a1) -> f (g a2)
23:00:57 <slack1256> isn't that an overkill for an one time thing ?
23:01:15 <slack1256> if you are going to be using (fmap . fmap) alot then maybe is worth it
23:01:43 <cocreature> sure it’s overkill if you only need it once but it’s a useful tool to add to your toolbelt so you know about it when you need it :)
23:01:50 <centril> are the rules for how  DeriveAnyClass / GeneralizedNewtypeDeriving  work wrt.  desugaring into  instance ctx => Class head   written anywhere? (I'm not interested in the instance body, just the context and instance head
23:02:30 <MarcelineVQ> slack1256: how are you importing it?
23:02:48 <slack1256> `import Control.Applicative` on ghci
23:02:52 <slack1256> for example
23:03:35 <MarcelineVQ> ah, hmm, that shouldn't wipe bindings
23:03:54 <MarcelineVQ> afaik only :load and :reload are supposed to do that
23:04:04 <slack1256> It has done as far I can remember. I didn't question it until now :-)
23:06:13 <slack1256> weird, now it works
23:06:30 <slack1256> maybe is something wrong on that machine
23:07:23 <slack1256> I was doing a reload in between, sorry
23:07:45 <slack1256> another question, is it possible to maintain (or redo) bindings when reloading?
23:08:33 <cocreature> slack1256: not really, you can use https://hackage.haskell.org/package/foreign-store but ime just extracting things you repeatedly need to a definition in one of your files is easier
23:09:28 <MarcelineVQ> slack1256: it's not a direct answer to your questions but there's more info here about that sort of thing, https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/ghci.html#what-s-really-in-scope-at-the-prompt
23:11:34 <slack1256> cocreature: how does extracting the definition to another file works if the bound value is one of an IO action?
23:11:54 <cocreature> slack1256: just make the definition of type IO something
23:12:16 <slack1256> oh, you mean that
23:12:22 <slack1256> yeah, that is what I currently do
23:14:43 <slack1256> thank for the info guys
