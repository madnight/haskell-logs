00:10:47 <saurabhnanda> baseline: 16m 45s / -j: 13m 34s / -j8: 13m 18s -- more concurrency is not solving anything. Trying -sstderr to see what's happening...
00:14:04 <pacak> try less concurrency
00:14:07 <pacak> -j4
00:15:57 <saurabhnanda> pacak: ghc: unrecognised flag: -sstderr
00:16:11 <saurabhnanda> is it a GHC flag or a stack flag?
00:16:37 <saurabhnanda> is it +RTS -s ?
00:26:17 <srhb> It's an RTS flag, yes. 
00:36:12 <saurabhnanda> what inference can I draw from https://gist.github.com/saurabhnanda/c8f8654a7f29c1adb753b357b897b5f3 /cc pacak
00:39:02 <saurabhnanda> in those stats ^^ what does MUT mean? it's taking up ~75% of the time. ~25% of the time is being taken by GC.
00:42:54 <kosmikus> saurabhnanda: MUT is for "mutator"
00:44:05 <saurabhnanda> kosmikus: mutator of what? is there a link which explains how to understand these stats?
00:44:30 <kosmikus> saurabhnanda: it's essentially all the time spent doing something useful, as opposed to GC
00:44:35 <saurabhnanda> ah okay....
00:44:41 <saurabhnanda> so 75/25 is expected?
00:45:07 <kosmikus> oh well, that very much depends on the kind of application
00:45:41 <kosmikus> it's neither horrible nor great
00:45:47 <saurabhnanda> kosmikus: Those stats are for the compiler building the library part of our app.
00:45:48 <kosmikus> of course, the less time is spent in GC, the better
00:45:56 <kosmikus> oh, I see, for GHC itself
00:46:26 <kosmikus> doesn't seem implausible to me
00:46:32 <saurabhnanda> About 800,000 GB (!) was allocated during compilation. Is that normal? -- https://gist.github.com/saurabhnanda/c8f8654a7f29c1adb753b357b897b5f3#file-building-library-txt-L6
00:47:58 <geekosaur> yes. note that that does not mean memory in use, just the total amount requested over the life of the program. all of it comes from gen 0/nursery and most of it gets gen-0 gcd
00:48:55 <kosmikus> nearly 2G maximum residency is rather high though
00:49:30 <saurabhnanda> which is why gen[0].sync is high? https://gist.github.com/saurabhnanda/c8f8654a7f29c1adb753b357b897b5f3#file-building-library-txt-L34 -- would -A32m impact this in any way (during compilation)?
00:50:33 <saurabhnanda> does gen[0].sync mean the number of times nursery was GCed? gen[1].sync means the number of times the area which comes after nursery was GCed? (what is it called)?
00:51:59 <geekosaur> no, that information is higher up. gen 0 was gcd 160 times, gen 1 10 times
00:52:47 <geekosaur> I would assume both of those have to do with locking/synchronization
00:54:19 <saurabhnanda> geekosaur: for building the library it is 12946 and 39 -- https://gist.github.com/saurabhnanda/c8f8654a7f29c1adb753b357b897b5f3#file-building-library-txt-L13-L14 
00:57:55 <saurabhnanda> the gen0 collection has come down with -A32m: https://gist.github.com/saurabhnanda/c8f8654a7f29c1adb753b357b897b5f3#file-building-library-02-txt-L14-L15
00:58:17 <geekosaur> yes, that'd be expected. larger nursery = fewer collections
00:58:22 <saurabhnanda> work:gc has improved to 80:20
01:54:20 <merijn> Is there a way to make cabal prefer a specific version of a dependency? i.e. code CAN work with foo-1.2 but 'foo > 1.2' doesn't have to rely on some really inefficient hack?
01:57:50 <fakenullie> won't it just install latest compatible version?
01:58:36 <merijn> fakenullie: It has to juggle dependencies so that all transitive dependencies match
02:09:18 <saurabhn_> nothing seems to be improving the compile time significantly. Any more tips would be appreciated. https://docs.google.com/spreadsheets/d/1HD4LaZBLftajGKFwoj6Nd4ZccQwYO8pHLNC7vrJc25Q/edit?usp=sharing
02:09:52 <AWizzArd> Looking for someone who works with an Oracle DB with Haskell. I’ve got the lib HDBC-odbc to compile but need more info about what other setup needs to be done, in order to connect to a DB.
02:16:50 <tabaqui> https://hacktoberfest.digitalocean.com
02:17:12 <tabaqui> who wanna some help from lame haskell programmer?)
02:18:31 <saurabhn_> Oddly enough, people really do use this option! Our pal in Durham (England), Paul Callaghan, writes: “Some people here use it for a variety of purposes—honestly!—e.g., confirmation that the code/machine is doing something, infinite loop detection, gauging cost of recently added code. Certain people can even tell what stage [the program] is in by the beep pattern. But the major use is for annoying others in the same office…”
02:18:46 <carbolymer> noice
02:20:15 <merijn> tabaqui: ghc-mod and cabal-install could use some help ;)
02:21:11 <merijn> tabaqui: Are there no tools at all that you'd like to see minor improvements in?
02:21:11 <tabaqui> I use ghc mode by itself, so it is good point to start
02:21:34 <tabaqui> what do you mean?
02:21:58 <merijn> tabaqui: Support for 8.2 and cabal-2.x is nearly, but not quite finished. dxld (the guy working on ghc-mod) is rather active and helpful in #ghc-mod if you wanna hack on that
02:22:32 <tabaqui> I'll check opened issues
02:22:46 <merijn> tabaqui: Well, like I said, asking for people wanting help sounds like you don't have anything you'd like fixed in libraries/tools you're using. Which is just odd to me, since I usually have lots of stuff I'd like to see fixed :p
02:23:13 <tabaqui> merijn: I've recently opened a bug in hs-tls though
02:23:52 <tabaqui> mostly, I don't know where is a problem - in the tool or in my head
02:24:36 <merijn> tabaqui: I can point out plenty of small things I'd like to see fixed in cabal-install, but that code base tends to be a bit hard to get started with, unfortunately :\
02:25:27 <tabaqui> I don't use it directly, so will not even dig inside
02:25:36 <merijn> I don't suppose anyone has a workaround for the broken new-haddock (besides nuking dist-newstyle)?
02:28:49 <carbolymer> How can I invoke threadDelay  here: https://repl.it/MonD/0 ? Is there a const equivalent for monads maybe?
02:29:35 <merijn> carbolymer: eh...yeah, I strongly recommend burning that code and pretending it never existed
02:29:52 <merijn> carbolymer: I don't know what you're trying to do, but nothing good can come from this approach
02:30:24 <carbolymer> merijn, I want to introduce delay in the pure function
02:30:28 <carbolymer> just, for science, you know
02:30:31 <merijn> carbolymer: You can't
02:32:40 <carbolymer> damn it
02:39:26 <pacak> carbolymer: Why would you want to do that? O_o
02:40:18 <muzzle> couldn't you *technically* use (unsafePerformIO (threadDelay foo)) for fun and profit?
02:40:48 <muzzle> I mean aside from it being somewhat insane it should work, right?
02:40:51 <merijn> muzzle: Well, it wouldn't work anyway, since it's passed as second argument to const, so just ignored
02:41:02 <pacak> % unsafePerformIO (threadDelay 1000000) `seq` 10
02:41:05 <yahb> pacak: 10
02:41:10 <pacak> % unsafePerformIO (threadDelay 10000000) `seq` 10
02:41:15 <yahb> pacak: [Timed out]
02:41:20 <muzzle> lol
02:41:38 <merijn> muzzle: Also, note that threadDelay probably would only delay the first call of the function in that scenario
02:41:49 <merijn> muzzle: Assuming the compiler doesn't optimise it away, etc.
02:42:15 <merijn> muzzle: You can probably find some dirty-hack way of delaying it using unsafePerformIO, but all bets are off w.r.t. reliability
02:42:21 <merijn> muzzle: As the famous quote goes
02:42:24 <merijn> @quote not.a.bug
02:42:24 <lambdabot> Lemmih says: "I don't understand why my code acts weird when I use unsafePerformIO" is not a bug.
02:42:30 <pacak> Don't do this.
02:43:03 <merijn> pacak: Can I define functions in yahb?
02:43:17 <pacak> merijn: it's ghci
02:43:38 <pacak> % :?
02:43:39 <yahb> pacak:  Commands available from the prompt:; <statement> evaluate/run <statement>; : repeat last command; :{\n ..lines.. \n:}\n multiline command; :add [*]<module> ... add module(s) to the current target set; :browse[!] [[*]<mod>] display the names defined by module <mod>; (!: more details; *: all top-le
02:43:43 <mniip> it's ghci but when ghci dies, it dies
02:43:50 <merijn> % let f s = unsafePerformIO (threadDelay 5000000) `seq` s
02:43:52 <yahb> merijn: 
02:43:58 <merijn> % f "foo"
02:44:03 <yahb> merijn: "[Timed out]
02:44:06 <merijn> % f "bar"
02:44:07 <yahb> merijn: ; <interactive>:1:1: error: Variable not in scope: f :: [Char] -> t
02:44:11 <merijn> hmm
02:44:14 <mniip> see my comment above
02:44:22 <merijn> % let f s = unsafePerformIO (threadDelay 2000000) `seq` s
02:44:22 <yahb> merijn: 
02:44:25 <merijn> % f "foo"
02:44:27 <yahb> merijn: "foo"
02:44:31 <merijn> % f "bar"
02:44:33 <yahb> merijn: "bar"
02:44:44 <merijn> hmm, not quite what I was expecting
02:45:32 <pacak> One thunk with threadDelay is evaluated - it's just ()
02:45:35 <pacak> once
02:45:37 <carbolymer> hm, right, I should've used seq instead of const https://repl.it/MonD/2
02:46:12 <merijn> pacak: That's what I'd expect
02:46:18 <merijn> pacak: But it seems it had delay on both
02:46:51 <mniip> merijn, it's polymorphic
02:46:59 <merijn> oh, duh
02:48:18 <mniip> also hmm
02:48:21 <mniip> it's still a lambda
03:19:09 <halogenandtoast> If I want to write a server than bots written in haskell can join and communicate with each other, should I use something low level like Network.Socket or is there a better library?
03:19:34 <liste> just bots, with no humans?
03:19:48 <halogenandtoast> No humans. Basically the bots play a game against each other
03:19:53 <liste> oh, a game
03:20:25 <ventonegro> halogenandtoast: Protocol buffers
03:20:58 <halogenandtoast> ventonegro: by that do you mean: https://hackage.haskell.org/package/protocol-buffers
03:21:14 <ventonegro> halogenandtoast: indeed
03:21:34 <michalrus> If I have `let a = [1,2,3]; b = a in a == b`, will it use Eq on that list (O(n)), or just compare references (O(1))?
03:21:42 <halogenandtoast> Alright, I'll try to figure out Protocol buffers.
03:21:59 <pacak> michalrus: Eq
03:22:03 <michalrus> :’
03:22:12 <pacak> % :t reallyUnsafePointerEquality
03:22:13 <yahb> pacak: ; <interactive>:1:1: error: Variable not in scope: reallyUnsafePointerEquality
03:22:48 <michalrus> Ptr
03:22:48 <michalrus> :]
03:22:51 <pacak> % import GHC.Prim
03:22:51 <yahb> pacak: 
03:22:56 <pacak> % :t reallyUnsafePointerEquality#
03:22:56 <yahb> pacak: ; <interactive>:1:1: error:; * Variable not in scope: reallyUnsafePointerEquality#; * Perhaps you meant `reallyUnsafePtrEquality#' (imported from GHC.Prim)
03:23:03 <pacak> % :t reallyUnsafePtrEquality#
03:23:04 <yahb> pacak: reallyUnsafePtrEquality# :: a -> a -> Int#
03:23:04 <halogenandtoast> Wait, yahn isn't our bot, where did our old bot go?
03:23:12 <marvin2> you're assuming that he wants to do pointer equality
03:23:17 <halogenandtoast> lambdabot where are you?
03:23:31 <halogenandtoast> You've been replaced with yet another haskell bot.
03:23:40 <pacak> marvin2: He wants to do something strange. I'm showing the most stupid way of doing it.
03:23:44 <cocreature> halogenandtoast: lambdabot is still here :)
03:24:07 <halogenandtoast> @lambdabot ping
03:24:07 <lambdabot> Unknown command, try @list
03:24:12 <halogenandtoast> fair enough
03:24:44 <pacak> % :t let a = [1;2;3] ; b = a in reallyUnsafePtrEquality# a b
03:24:44 <yahb> pacak: ; <interactive>:1:11: error: parse error on input `;'
03:24:55 <pacak> % :t let a = [1;2;3] in let b = a in reallyUnsafePtrEquality# a b
03:24:55 <yahb> pacak: ; <interactive>:1:11: error: parse error on input `;'
03:25:01 <pacak> % :t let a = [1,2,3] in let b = a in reallyUnsafePtrEquality# a b
03:25:01 <yahb> pacak: let a = [1,2,3] in let b = a in reallyUnsafePtrEquality# a b :: Int#
03:25:10 <michalrus> Uh? :o
03:25:19 <michalrus> K-Lined for what?
03:25:46 <pacak> % let a = [1,2,3] in let b = a in reallyUnsafePtrEquality# a b
03:25:46 <michalrus> Why not first compare pointers/refs during (==), and if that’s False, use Eq?
03:25:46 <yahb> pacak: ; <interactive>:12:1: error:; * Couldn't match a lifted type with an unlifted type; When matching the kind of `Int#'; * In the first argument of `print', namely `it'; In a stmt of an interactive GHCi command: print it
03:25:57 <marvin2> pacak or maybe he just wants to figure out how == works in haskell
03:26:01 <michalrus> Yes.
03:26:12 <michalrus> s/how/why :p
03:27:04 <marvin2> michaelw I see no reason why compiler couldn't do that for optimization sake. from users perspective though, == uses Eq instance
03:27:31 <michalrus> Yes, yes, I’m totally asking from compiler’s perspective.
03:27:47 <michalrus> But does it?
03:27:55 <marvin2> no clue
03:27:57 <michalrus> K.
03:28:01 <mniip> uh-oh
03:29:45 <marvin2> > let x = [1..]; y = x in x == y
03:29:51 <lambdabot>  mueval-core: Time limit exceeded
03:29:55 <michalrus> :c
03:30:27 <pacak1> Awesome. And now I'm banned...
03:30:39 <pacak> Hmm... Not anymore.
03:31:04 <halogenandtoast> pacak: Apparently unsafe functions are spam in this channel ;)
03:32:06 <pacak> They don't spam _that_ much.
03:32:49 <pacak> Maybe 6 messages that looked to similar was too much?
03:32:53 <pacak> too
03:32:54 <mniip> yahb repeating your input in :t
03:32:59 <mniip> yeah, that contributed
03:33:18 <marvin2> michalrus compiling with -O2 flag does the same, at least on my old ghc version
03:33:46 <pacak> % :t id
03:33:46 <yahb> pacak: id :: a -> a
03:33:48 <michalrus> Mhmm, OK. :)
03:33:54 <pacak> At least bot wasn't banned with me :)
03:34:40 <mniip> :Sigyn!sigyn@freenode/utility-bot/sigyn NOTICE yahb :Your actions in #haskell tripped automated anti-spam measures, but were ignored based on your time 
03:34:40 <mniip> in channel; stop now, or automated action will still be taken. If you have any questions, please don't hesitate to contact a member of staff
03:34:52 <mniip> basically, he's kind of a big deal
03:35:04 <mniip> got away with a warning
03:35:44 <pacak> I'm kind of spending plenty of time in this channel as well.
03:36:35 <pacak> logs showing 9k messages by me.
03:36:58 <mniip> when was your last join though
03:37:38 <pacak> this irc client runs something like 24/7
03:37:56 <pacak> Since 2015
03:38:38 <pacak> I think I reconnected  yesterday when my internets went uplorry.
03:38:51 <mniip> ah I see
03:39:02 <mniip> looks like a bug!
03:42:15 <orion> Instead of using State s Monad, I've seen people use a Reader (MVar s) or (Reader IORef s) Monad. Is it possible and/or desirable to use STRef instead of IORef?
03:45:52 <jle`> probably possible to use STRef
03:46:03 <jle`> the advantage is that you can run your state actions in not-IO
03:46:06 <jle`> "purely"
03:46:29 <jle`> you can get a (forall s. Reader (STRef s r) a) -> r -> a
03:47:12 <jle`> er that is, (forall s. Reader (STRef s r) a) -> r -> (a, s)
03:47:37 <jle`> whereas for IORef you'd have to do Reader (IORef r) a -> r -> IO (a, s)
03:47:48 <jle`> er, s/(a,s)/(a,r)
03:48:05 <merijn> orion: The main reason to use IORef is in multi-threaded settings and that doesn't work with ST
03:48:29 <merijn> orion: You can only modify an STRef within a single ST block
03:48:58 <mniip> hey jle`
03:49:19 <jle`> hi!
03:49:20 <orion> merijn: What if it isn't your intention to run multi-threaded?
03:49:37 <orion> Also, the computation is 100% pure.
03:49:45 <merijn> orion: Well, then it works, but then I'm not sure the Reader bit matters?
03:49:49 <mniip> jle`, have you seen the github issue
03:49:52 <merijn> orion: What do you need STRef for, then?
03:50:06 <jle`> which one?
03:50:07 <orion> STRef is pure, no?
03:50:15 <jle`> oh i just see it now
03:50:41 <merijn> orion: Everything not using unsafeX is pure
03:50:45 <jollygood2> a
03:51:21 <jle`> have to head to bed now but i'll sleep on some possible solutions
03:51:43 <merijn> orion: The point with ST is that it lets you do mutation in a way that is not externally observable
03:51:44 <orion> merijn: Ok, true, but why have STRef at all if IORef is so superior?
03:52:04 <merijn> orion: IORef is not superior because you can not use it without incurring IO somewhere
03:53:21 <merijn> orion: The point with ST is that it allows mutation that can be used in a pure setting. Suppose you have a sort function that takes an array, and returns a new (sorted) array. If the function allocates a new array and sorts that in place using mutation, the fact that it uses mutation is not externally visible (i.e. the sort function is pure, since it always produces the same result for the same input)
03:53:33 <orion> merijn: Ok, *that*'s what I mean: You can not use it without incurring IO somewhere.
03:53:57 <merijn> orion: ST is about capturing this sort of mutation. You can do mutable operations in a way that can (safely!) be converted into a pure operation later
03:54:13 <angerman> anyone got a minimal cabal project that uses hsc2hs? I just need to test some hsc2hs stuff, and I don't want to pull in a large dependency chain :)
03:54:17 <roi_du_silence> is there such athing as applying a number of functions to a variable in an undetermined order in a parallel fashion; if I make sure that the order of application of functions doesn't matter - or if I'm in the IO Monad, that I actually want that randomness factor ?
03:54:21 <orion> merijn: That's what I meant to say when I said, "STRef is pure, no?"
03:54:46 <merijn> orion: My fault, I'm being sloppy and using terminology sloppy
03:55:11 <orion> angerman: https://github.com/centromere/blake2/tree/master/src/Crypto/Hash/BLAKE2
03:55:32 <roi_du_silence> no wait I'm retarded. I got it.
03:55:43 <merijn> orion: Anyway, the reason people use "ReaderT (IORef a)" is for concurrent mutation, however if you're not using concurrency anyway, why would you use "ReaderT (STRef s a)" instead of just State?
03:56:02 <orion> merijn: I've read that State should be avoided.
03:56:17 <orion> Something about performance problems.
03:56:21 <merijn> roi_du_silence: Say, like you have a function "a -> IO b" and you want to run it in parallel?
03:56:39 <merijn> orion: The people telling you to avoid State would almost certainly tell you to avoid "Reader (STRef s a)" too
03:56:44 <angerman> orion: neat
03:57:05 <orion> merijn: But they would be fine with telling me to use Reader (IORef s) a?
03:57:10 <merijn> orion: No
03:57:41 <merijn> orion: But sometimes you just need to pass something mutable everywhere (SQL connection, for example) to multiple threads to run stuff concurrently
03:58:16 <cocreature> ST makes a lot more sense if you’re working with arrays than if you’re just working with STRefs
03:58:17 <roi_du_silence> my question was that you have for instance a variable of type a and f,g,h,i :: a -> a and that you would be able to apply f g h i to a *at the same time*. Obviously it doesn't make sense; and that's because that was a bad exemple of what I was tryingto do. One sec
04:02:11 <roi_du_silence> http://lpaste.net/6354384739834527744
04:02:40 <roi_du_silence> that's the model I had in mind
04:03:43 <merijn> roi_du_silence: Maybe someone in #haskell-lens knows?
04:04:31 <roi_du_silence> Woah didn't know that was a thing. will ask there
04:04:35 <roi_du_silence> thank you.
04:04:57 <merijn> roi_du_silence: Dunno how active it is, but might stop your question getting lost in the noise
04:07:26 <nsievers> does anyone know an example of a modification that comes up outside of "pure" category theroy?
04:08:01 <merijn> nsievers: I'm not sure what you mean by that?
04:09:26 <merijn> Can I document individual fields of a data constructor using haddock?
04:10:28 <orion> merijn: What, in your opinion, is the precise argument against State?
04:10:43 <nsievers> merijin: the only examples I can find are ones that are completely generic
04:11:17 <merijn> nsievers: The only examples of *what*?
04:11:24 <cocreature> orion: tbh I’m not sure there is a good argument against State (for pure code layering State on top of IO is another story)
04:11:25 <nsievers> modifications
04:11:38 <merijn> nsievers: I'm not sure what you mean by "modifications"
04:11:52 <nsievers> the 3-cells in the 3-category of 2-categories
04:13:53 <orion> cocreature: Oh, I see. So some component of the argument includes IO.
04:15:22 <cocreature> orion: layering it on top of IO is mostly just silly imho. an IORef works just as well and has the additional benefit that it’s easy to change your code such that multiple threads can access the state (which becomes quite common once IO is involved)
04:16:24 <nsievers> i.e. for some fixed 2-natural transformations between 2-categories alpha, beta :: C -> D
04:16:43 <nsievers> a family of 2-cells in D indexed by objects a in C
04:16:54 <nsievers> gamma_a :: alpha_a -> beta_a
04:17:07 <nsievers> satisfying axioms
04:18:06 <orion> cocreature: I see.
04:20:25 <mniip> nsievers, n'th level homotopies in an infty-groupoid are a particular kind of invertible n-cells aren't they
04:21:49 <nsievers> Those are n cells sure but what I'm talking about is a specific mapping between two 2-natural transformations
04:22:25 <ertes-w> helo
04:22:25 <nsievers> I dont see where the 2-natural transformations are in your example.
04:22:29 <mniip> well just pick a topological space,
04:22:39 <mniip> and examine the infty-groupoid of its homotopies
04:23:37 <mniip> then your 3-cells are homotopies between homotopies between homotopies between homotopies of paths
04:23:40 <mniip> if I count correctly
04:24:12 <mniip> if your space has enough dimensions this might actually be a nontrivial groupoid
04:26:09 <nsievers> Maybe I'm misunderstanding you. What I'm looking for isn't an example of an n-cell.
04:26:30 <nsievers> Its a map between the 2-categorical version of natural transformations
04:27:22 <mniip> well then I misunderstood your question
04:27:36 <nsievers> I guess if you were to look at a homotopy between ... between homotopies of topological spaces
04:28:17 <nsievers> then apply the infinity groupoid construction to that diagram
04:28:51 <nsievers> you would get a more general version of what I'm asking. But that still isn't really a concrete example
04:30:38 <jollygood2> will we get extensible records any time soon? data Color = Red | Green | Blue  <- allowing user of the library to add Purple, without changing the source where Color is defined
04:32:33 <liste> wouldn't that break pattern matching?
04:32:59 <liste> and that isn't a record, it's a sum type ↑
04:33:15 <tdammers> it would completely break totality checks
04:33:26 <tdammers> and indeed this isn't extensible records
04:33:58 <cocreature> jollygood2: we’re not going to get that anytime soon as a GHC builtin. you can kind of hack your way around using fancy type-level stuff but most of the time it’s not worth it
04:34:07 <maerwald> we have totality checks?
04:34:09 <jollygood2> it would for library defined functions. so library would have to be written in a way to support this (in which case it may be useful to have this feature turned off by default)
04:34:28 <liste> jollygood2: you can do "data Color a = Red | Green | Blue | CustomColor a"
04:34:28 <tdammers> maerwald: manual if need be :x
04:34:54 <tdammers> maerwald: but yes, we have totality checks on pattern matching
04:35:34 <tdammers> jollygood2: closest thing I am aware of that doesn't completely replace Haskell records is the HasX typeclass functionality from lens
04:37:38 <cocreature> HasX is for extensible records. for extensible sums (extensible variants) you need the AsX stuff from lens
04:38:25 <cocreature> alternatively there are also libraries such as vinyl which try to provide things like this
04:42:16 <merijn> bleh...nothing as annoying as having to wait for one of your patches to make it into upstream so you can use it...
04:43:08 <maerwald> hack the repo, force-push the patch
04:45:37 <ertes-w> jollygood2: note that sum types compose rather naturally by…  you know…  summing them =)
04:46:17 <ertes-w> you could them perhaps use traversals for easy pattern-matching and prisms for easy construction
04:48:52 <ertes-w> merijn: can you use local packages as drop-in replacements for hackage packages with new-build?
04:49:31 <merijn> ertes-w: Yes, but in this case that's not enough :p
04:50:04 <ertes-w> merijn: can you use multiple local packages as multiple drop-in replacements for hackage packages with new-build?
04:50:22 <merijn> ertes-w: I patched tasty with some stuff I want for my tests, so unless I start embedding a local checkout of tasty into all my repo's my tests can't use that stuff while running on Travis
04:51:13 <ertes-w> ah, travis…  i see
04:51:42 <merijn> ertes-w: After fixing multi-ghc-travis to be more awesome, I'm now working on "tasty-travis" to have fancier Travis output using tasty :)
04:52:05 <merijn> ertes-w: (Specifically folding test outputs and adding coloured output)
04:54:01 <ertes-w> i don't even know what travis looks like =)
04:54:43 <merijn> ertes-w: Quite nice, tbh: https://travis-ci.org/merijn/broadcast-chan/jobs/288930887
04:55:36 <lynn> I don't know fancy Lens stuff... but I'd go with something like `data MyColor = TheirColor Color | Purple`?
04:57:33 <ertes-w> merijn: sure, i just don't really have a use case for it…  by the time i push, i have already tested with four GHC versions, including GHCJS
04:57:49 <ertes-w> (up to four, sometimes less, depending on my build-depends)
04:57:53 <merijn> ertes-w: Yeah, I'm too lazy to keep more than 1 or 2 GHCs locally
04:58:10 <ertes-w> merijn: i don't do it manually
04:58:11 <merijn> ertes-w: And it's nice that if someone submits a PR to your repo the tests will already be run and visible
04:59:22 <ertes-w> nix-build --argstr compiler ghc7103
05:00:02 <ertes-w> merijn: sure…  if anyone wants to configure travis for me, i'm happy to let them do it =)
05:00:04 <ertes-w> it's one of those "i can't be bothered" cases
05:00:14 <merijn> ertes-w: Well, do I have good news for you, then!
05:00:48 <merijn> ertes-w: You can help me test my addition to hvr's script ;)
05:01:05 <ertes-w> merijn: how is that good news for me? =P
05:01:48 <merijn> ertes-w: Clone https://github.com/merijn/multi-ghc-travis, build "make_travis_yml_2.hs" (just a matter of cabal build/install), make sure your cabal file has a Tested-With field (see README), run "make_travis_yml myproject.cabal >.travis.yml" and you're done ;)
05:02:16 <merijn> ertes-w: It's good news because there's already a tool to configure Travis for you :p
05:03:31 <ertes-w> can you use arbitrary tool-chains with travis?
05:04:17 <merijn> ertes-w: I think you can just apt-get stuff, yes. So if your tools are in apt-get for the Ubuntu they run or you can build them in a reasonable amount of time I think you can
05:05:03 <ertes-w> so it's basically a kind of time/RAM-limited container that processes output and exit codes?
05:05:11 <merijn> ertes-w: Pretty much
05:06:04 <maerwald> except you are stuck with old ubuntu crap
05:09:39 <ertes-w> there was someone here recently who tried to use haskell for competetive programming, and it turned out that the hosting site would offer them their idea of what a basic haskell tool chain and set of libraries is…  it sounded like a frustrating experience
05:09:50 <ertes-w> i thought travis was like that, but this makes it more attractive
05:10:39 <ertes-w> with haskell more than with any other language i know it's *very* important to have absolute freedom over tools and libraries
05:10:55 <Ferdirand> ertes-w: oh yeah. I tried that and they didn't include bytestring
05:10:56 <maerwald> well, you don't
05:11:07 <maerwald> you cannot choose the host distro
05:11:40 <Ferdirand> and then it's your fault because you cannot meet the i/o performance requirements
05:12:42 <ertes-w> maerwald: well, i have a working nix-based build chain…  i could try to just dump it into travis, and whether it's gonna work really just depends on whether they let me have per-project setup code that is only run once
05:12:59 <maerwald> then you are stuck with nix
05:13:07 <maerwald> not what I call freedom, so travis is very limited
05:13:26 <maerwald> your only option is to use docker stuff inside travis if you want freedom, but then you are stuck with docker...
05:14:24 <ertes-w> maerwald: if all else fails you can probably use 'unshare' to fire up your own container
05:14:36 <ertes-w> running anything you want
05:14:53 <ertes-w> (but then you're stuck with linux, i guess) =)
05:16:56 <maerwald> yeah, I can also write my own container software... 
05:17:24 <ertes-w> or QEMU-late your own OS =)
05:17:52 <merijn> ertes-w: By default Travis offers a bunch of fixed GHC versions which aren't ideal. But the multi-ghc-travis script uses hvr's PPA for up to date GHC versions (including HEAD!) and install cabal-install HEAD as well to work with
05:17:54 <maerwald> or just realize travis doesn't give you freedom, but a limited toolchain
05:18:22 <merijn> ertes-w: It pulls everything else off of Hackage (and the multi-ghc script sets up caching so dependencies built for earlier runs can be reused)
05:18:46 <ertes-w> merijn: ah, that's the important part…  so it doesn't always run from scratch
05:18:51 <ertes-w> merijn: yeah, i can make use of that
05:19:11 <merijn> ertes-w: So for my repo for example it fetches whatever GHC I want from the PPA, installs cabal-install, reuses all the cached dependencies from a previous run and immediately starts building the code
05:19:40 <merijn> ertes-w: atm the slowest step is installing GHC from the PPA (about 1.5 minutes to download install), after that it's pretty much instantly building the package itself
05:20:49 <tdammers> maerwald: Travis doesn't pretend to give you freedom either, the whole idea behind it is to give you a limited but turnkey environment to test on
05:20:59 <maerwald> tdammers: yes
05:21:58 <ertes-w> honestly being able to run arbitrary code in a complete linux environment sounds like a lot of freedom to me
05:22:05 <merijn> ertes-w: Word.
05:22:25 <merijn> ertes-w: Don't forget you get to run it for free and without paying for storage of the cache either
05:22:33 <fakenullie> travis does not let you run containers?
05:23:19 <ertes-w> do you have root privileges over that system?
05:23:38 <maerwald> ertes-w: then you can pretty much call any environment that gives you a compiler to bootstrap something "a lot of freedom"
05:23:43 <merijn> Presumably, since apt-get doesn't work without root
05:23:58 <merijn> maerwald: Eh...well, yes?
05:24:33 <ertes-w> maerwald: sure
05:25:06 <maerwald> then you can also call assembler a lot of freedom, since you can write your own high-level language in assembler
05:25:28 <maerwald> the definition is not very useful
05:26:01 <maerwald> you are confusing control with freedom. I am not free to choose a different OS in travis
05:26:21 <ertes-w> maerwald: i would make one further distinction: is it *practical* to do arbitrary things?  the way merijn described it with travis it is
05:26:31 <maerwald> I just have enough control over the travis environment to bootstrap whatever OS I need
05:26:51 <ertes-w> you're not free to change the host OS perhaps, but i don't really care about that…  the situation where i can't control the host OS is by far not new to me
05:27:00 <ertes-w> that's why i like to work with stuff like nix and docker for deployment
05:27:17 <maerwald> docker in travis is annoying
05:27:21 <maerwald> fetches often fail
05:30:51 <ertes-w> possibly…  i'll see how it works out for me later =)
05:38:44 <herzmeister[m]> maerwald: thanks for the info and the links. Indeed, I guess thanks to haskell we can reason more about the robustness of the security of the GHC with potentially greatly minimized attack surface.
05:40:32 <maerwald> herzmeister[m]: what does that mean?
05:40:52 <carbolymer> quick question: which synchronizing variable is best for multiple simultaneous reads and exclusive writes? Is there one or should I use dedicated locks?
05:41:55 <merijn> carbolymer: MVar or IORef?
05:42:01 <maerwald> herzmeister[m]: if you pick the technical approach to attack surface, haskell/GHC is rather hard to correctly analyze, because of the runtime and the GC abstractions
05:42:21 <carbolymer> merijn, IORef is thread-safe?
05:42:46 <merijn> carbolymer: If you use atomicallyModifyIORef, yes
05:42:59 <merijn> carbolymer: MVar is slightly slower, but safer it you worry about it
05:43:30 <carbolymer> hm, interesting, THANKS
05:45:11 <cocreature> ertes-w: you might also be interested in https://docs.travis-ci.com/user/languages/nix/
05:46:09 <ertes-w> cocreature: nice, thanks!
05:47:17 <maerwald> herzmeister[m]: simply speaking. If you strive for security, you end up in the formal methods field, but not just at the "high level" (e.g. all your type stuff), but also about *what gets actually executed* and what happens in-memory. Haskell is, maybe against your intuition, not very well suited for formal methods in terms of security. On a similar note, this has been discussed on the haskell-cafe mailing list wrt cryptography
05:47:43 <maerwald> where you want a lot more control over things than you naturally have in a high-level language
05:48:49 <cocreature> ertes-w, merijn: regarding root access, travis has two modes: container-based and non-container-based. in the container-based mode you don’t have root access but it’s faster and has better caching. in the non-container-based modes you have root access
05:49:18 <ertes-w> carbolymer: IORef is great for single-writer patterns, but quickly loses to MVar as you increase the number of writers
05:49:26 <merijn> cocreature: Yeah, I know, I'm just using whatever the multi-ghc script was initially written for :p
05:49:26 <ertes-w> carbolymer: in terms of performance
05:49:54 <Psybur> What do you guys think is the most encompassing computer science book out there? From transistors and gates to monads :D?
05:49:54 <cocreature> merijn: it depends, travis_yml_2 uses the container based infrastructure while the old travis script uses the other infrastructure iirc
05:49:59 <Psybur> Think one book has it all?
05:50:10 <ertes-w> carbolymer: reason is that atomicModifyIORef busy-loops until it wins the race…  there is even potential for live-locks
05:50:16 <merijn> cocreature: _2 is the default now (plus the one I've been extending)
05:51:09 <maerwald> haskell is only well-defined on a high-level. If you want to reason about security, you need well-definedness on all levels (hence transpilers, multi-verification on code and binary level, DSLs etc.)
05:51:14 <carbolymer> ertes-w, thanks! I think someone should create comparison table for TVar, TMVar, STRev and IORef - every few months I forgot the differences if I am not using them frequently -_-
05:52:11 <ertes-w> carbolymer: for anything transactional i'd use T*, for anything with multiple writers i'd use MVar, and for everything else i'd use IORef
05:52:40 <ertes-w> carbolymer: and STRef isn't relevant, because ST is single-threaded by design
05:58:21 <carbolymer> right
05:58:29 <_d0t> hi. I have to cabal projects in a single repo, and I need them to share some C header files. What's the best way to arrange that?
05:58:35 <_d0t> *two cabal projects
05:58:49 <carbolymer> I guess, use stack?
05:59:59 <ertes-w> _d0t: copy them
06:00:16 <ertes-w> _d0t: to cabal for all intents and purposes those are separate projects
06:00:43 <ertes-w> _d0t: alternatively make a third package as a binding to those C files, then use that one
06:01:37 <_d0t> ertes-w: so, there's no way to tell cabal to use a directory one level above as an extra include dir?
06:02:07 <ertes-w> _d0t: how would cabal package it?
06:02:36 <_d0t> right
06:02:56 <__mjb> newbie question here, if I have a tuple of types, say (Seq a, [a]) and wished to define a functor instance
06:03:09 <__mjb> how could I use the already existing fmap instances?
06:03:33 <__mjb> e.g. something like fmap f (sq, l) = (fmap f sq, fmap f l)
06:03:37 <_d0t> __mjb: fmap f (s, l) = (fmap f s, fmap f l)
06:03:40 <ertes-w> __mjb: data SeqAndList a = SeqAndList (Seq a) [a]  deriving (Functor)
06:04:08 <ertes-w> you can't write such a functor instance with (,)
06:05:28 <__mjb> hmm, how come it can't be written as a tuple? I guess it might end up cleaner writing it without
06:05:31 <__mjb> thanks!
06:05:44 <_d0t> __mjb: tuples already have functor instances
06:05:53 <ertes-w> that's not even the problem
06:05:59 <ertes-w> what would the instance even look like?
06:06:05 <ertes-w> instance Functor (,)  -- kind error
06:06:15 <ertes-w> instance Functor ((,) a)  -- not quite what you wanted
06:06:31 <ertes-w> notice that ((,) :: * -> * -> *), while (SeqAndList :: * -> *)
06:06:34 <erisco> use  Ap (Compose (,) Seq) [] a  of course
06:06:37 <merijn> Anyone know what the version macros for packages with dashes in them look like?
06:06:50 <merijn> i.e. "MIN_VERSION_foo-bar(0,1,0)"
06:06:53 <__mjb> ahh right, I should have thought it out a bit more, thanks a lot
06:07:04 <erisco> then fmap is free
06:08:16 <ertes-w> __mjb: DeriveFunctor will write the Functor instance for you in almost every case…  the only cases it doesn't know how to handle is when there are existentials
06:08:34 <ertes-w> __mjb: and there is also DeriveFoldable, DeriveTraversable
06:08:55 <ertes-w> you can get quite a lot of functionality for free with a custom type
06:09:14 <__mjb> haskell seems to be very impressive so far, thanks for the tip
06:09:30 <__mjb> out of interest is there a way to specify different functor instances' fmaps?
06:09:42 <ertes-w> __mjb: there is one fmap per instance
06:10:13 <__mjb> I meant for example writing the previous cases' fmap instance specifically, referring to Seq's fmap and the list fmap in the definition
06:10:21 <ertes-w> sure
06:10:46 <ertes-w> instance Functor SeqAndList where fmap f (SeqAndList xs ys) = SeqAndList (fmap f xs) (fmap f ys)
06:10:54 <erisco> fmap is not a function, it is a family of functions indexed by type
06:10:54 <merijn> Is there an easy way to detect in CPP whether a specific dependency exists or whether a cabal flag was set?
06:11:01 <hexagoxel> merijn: for Paths_pkgname, it is "-" -> "_". not sure if it is the same for macros, but it would make sense..
06:11:17 <erisco> so, referring to fmap in the definition of fmap does not necessarily refer to the same fmap
06:11:35 <merijn> Or even better, where can I find the docs for cabal-install generated CPP macros?
06:12:01 <__mjb> oh right, thanks a lot, this short conversation has cleared up a lot for me
06:18:31 <mniip> > over each (fmap negate) ([1,2], [3,4])
06:18:35 <lambdabot>  ([-1,-2],[-3,-4])
06:21:10 <makalu> when I build a shared library with GHC (-dynamic -shared -fPIC) the RTS is not linked. I can add it with -lHSrts-ghc8.0.2 but this depends on the GHC version. Is there a sane way to tell GHC to link the RTS?
06:22:01 <merijn> makalu: That would result in linking the RTS multiple times if you use multiple shared Haskell libraries
06:22:36 <merijn> makalu: Are you distributing the Haskell library on its own or are you just linking a C program that uses your Haskell code?
06:23:05 <makalu> merijn: there will be a C program that uses this Haskell library
06:23:51 <makalu> I want an .so that will be used in a C program. It exports Haskell functions using the FFI.
06:23:52 <maerwald> shouldn't the C program link to the GHC RTS then?
06:24:49 <merijn> makalu: A simple solution (depending on the complexity of your C program) would be to just have GHC link your C program for you
06:24:57 <maerwald> -lHSrts
06:25:44 <merijn> makalu: Like this: https://gist.github.com/merijn/4a0fee2b3a5ef3476aa4#file-foo-cabal
06:25:46 <makalu> what I'm trying to do is described here http://www.well-typed.com/blog/30/ and they also explicitly link the RTS with -lHSrts-ghc6.11
06:26:04 <merijn> makalu: Note the "-no-hs-main" GHC flag and the fact that "Main-Is:" lists a C file
06:27:14 <merijn> makalu: That blog is ancient (ghc 6.12 is from 2009), cabal-install should be able to do that for you now
06:27:50 <merijn> makalu: Anyway, the gist I linked shows a minimal cabal setup where cabal does all the messy linking for you
06:28:16 <makalu> it's cool if cabal-install can do it. I just wonder how :D. Because right now I put HSrts-ghc8.0.2 in extra-libraries but I don't like that.
06:28:54 <makalu> merijn: OK I'll think about it and see if your solution works in my case. Thank you.
06:29:57 <merijn> makalu: extra-libraries is intended for C libraries that you plan to use. Not sure how well that would work for the runtime
06:34:08 <maerwald> makalu: http://www.vex.net/~trebla/haskell/so.xhtml#cabal this suggest cabal-2.0 has some support for it
06:35:49 <makalu> maerwald: nice, that's what I want. Thanks!
06:38:29 <jgt> how do I use (<|>) with a list of things?
06:38:38 <cocreature> :t asum
06:38:40 <lambdabot> (Alternative f, Foldable t) => t (f a) -> f a
06:38:47 <cocreature> ^ jgt is that what you’re looking for?
06:38:56 <jgt> maybe? I don't know :P 
06:39:19 <cocreature> then you’ll need to explain more precisely what you want :)
06:40:12 <jgt> I have a [HandlerT App IO (Either SMSFail SMSSuccess)]
06:40:35 <jgt> I want to try running each thing in the list until one of them succeeds
06:40:46 <cocreature> asum = foldr (<|>) empty
06:41:07 <cocreature> so it sounds like it does what you want
06:41:09 <maerwald> quite a poor function name though
06:41:13 <lyxia> runExceptT . asum . fmap ExceptT
06:41:19 <cocreature> > asum [Just 1, Just 2, Nothing]
06:41:20 <maerwald> I'd just use the explicit expression
06:41:22 <lambdabot>  Just 1
06:41:28 <cocreature> > asum [Nothing, Just 1, Just 2]
06:41:31 <lambdabot>  Just 1
06:41:52 <jgt> cocreature: yeah, that sounds like exactly what I want
06:42:00 <jgt> cocreature: Thanks! And *amazing* response time!
06:43:02 <jgt> oh, I'm sure I can do that with partials, but how?
06:43:12 <jgt> I would want to pass the same argument to each of those things
06:43:48 <jgt> because everything in my list is * -> * 
06:44:22 <cocreature> I kind of doubt everything in your list has kind * -> *. the type of elements in a list has to be of  kind *
06:44:29 <cocreature> (no pun intended)
06:44:50 <ventonegro> :t map ($ 123)
06:44:50 <jgt> ohhh
06:44:52 <lambdabot> Num a => [a -> b] -> [b]
06:46:15 <jgt> so, asum $ map ($ x) [a, b, c] wouldn't work?
06:46:36 <cocreature> depends on what the type of a b and c is
06:46:41 <cocreature> functions don’t have kind * -> *
06:46:52 <cocreature> :k Int -> Int
06:46:54 <lambdabot> *
06:47:07 <jgt> ok so I'm confusing myself with kinds here
06:47:21 <Psybur> :k State
06:47:23 <lambdabot> * -> * -> *
06:47:32 <jgt> what I have are functions that are awaiting an argument
06:47:47 <jgt> I have a list of external SMS service providers
06:47:48 <cronokirby> that's still a concrete kind
06:47:50 <cronokirby> so *
06:47:54 <cocreature> in that case "map ($ x)" should be what you’re looking for
06:48:03 <jgt> I want to try each of them, passing in the same SMS
06:48:11 <ventonegro> jgt: I guess you meant a -> b, * has a special meaning
06:48:22 <jgt> ventonegro: yes, you're right
06:48:32 <cocreature> that’s the type not the kind :)
06:48:56 <cronokirby> If you have `A -> SMS -> Result` then you have `A -> (SMS -> Result)` so if you partially apply all the functions with As, then you have functions from SMS to Result
06:51:17 <jgt> now I need to figure out how to write the Alternative instance for HandlerT App IO
06:51:51 <cocreature> jgt: where is HandlerT coming from?
06:51:59 <jgt> Yesod
06:52:34 <cocreature> ExceptT is probably going to come in handy as lyxia already suggested
06:53:26 <jgt> oh yeah, I missed that
06:53:41 <cocreature> so just wrap your stuff in ExceptT and things should work
07:05:07 <merijn> You know what the hardest part is about Haskell? Trying to come up with package names that aren't so generic that it's rude to take them...
07:05:14 <jgt> now I get to write the Monoid instance for SMSFail :D
07:05:18 <jgt> [googles furiously]
07:08:24 <shapr> jgt: is this a twilio binding or something?
07:09:13 <jgt> shapr: yeah, Twilio, and a couple of other providers
07:09:27 <shapr> is it an open source lib?
07:09:32 <jgt> nope
07:09:34 <shapr> ah, too bad
07:09:42 <jgt> I know someone already wrote a twilio lib
07:09:53 <jgt> but there's too much going on for my needs
07:11:44 <akfp> How can I combine two prims so I get a list of either of the two constructors.  Example  x ^.. traverse . _Constructor1 gives all elements with Constructor1, but how can I write x ^.. traverse . (_Constructor1 OR _Constructor2) ?
07:16:30 <phadej> I suspect there aren't such `or`, as there aren't `and` for Lens
07:20:59 <phadej> akfp: it's dual of https://stackoverflow.com/questions/36521208/how-to-make-the-product-of-two-lenses
07:28:22 <phadej> akfp: see https://gist.github.com/phadej/71b1980ccdcc738a45a3f0a31b1b10a6
07:32:14 <merijn> ok, I need some naming help
07:32:24 <phadej> edwardk: should we add `Control.Lens.Unsafe` with `lensProduct` and `prismSum` and warnings and broken examples
07:32:47 <maerwald> merijn: don't name your child haskell, if that's where this is going
07:32:48 <phadej> edwardk: people ask about often enough, if they want to put stick into their wheels, let's them do it?
07:33:00 <phadej> but for cat, it's totally fun.
07:33:01 <phadej> and ok
07:33:09 <merijn> I've got a small utility library for more easily constructing trees (like tasty testtrees or criterion trees) from a function. I keep reusing it, so I figure I'd package it up as a library on hackage, but I have no clue what to call it
07:33:24 <merijn> I though of something like "param-tree" but that seems a bit to generic?
07:33:50 <phadej> "forestration"
07:33:55 <ventonegro> merijn: easy-tree, ofc
07:34:03 <byorgey> one-two-tree ?
07:34:11 <cronokirby> What's a good type to use for positive Ints?
07:34:15 <byorgey> treezy
07:34:18 <phadej> cronokirby: Word
07:34:53 <phadej> (or `Natural`, if for `Integer`s)
07:35:05 <merijn> (Basically, if you have a function "Foo -> Bar -> Baz -> Test" it lets you just specify a bunch of parameters for each of those arguments and unfolds a tree from that for you)
07:36:18 <byorgey> merijn: that does sound nice.
07:36:39 <ventonegro> merijn: Orchard -- this game is fun
07:36:45 <byorgey> merijn: 'possibilitrees'
07:36:48 <merijn> byorgey: It's really kinda simple, but it was so incredibly painful to do by hand that I decided once and for all :p
07:37:51 <byorgey> merijn: that's the best kind of library.
07:38:04 <merijn> byorgey: Indeed ;)
07:38:13 <merijn> byorgey: But, like I said, naming is hard :p
07:38:39 <phadej> byorgey: you should co-author a paper with pigworker
07:38:47 <phadej> (maybe you did?)
07:38:55 <merijn> phadej: Not enough Shakespeare in his suggestions ;)
07:39:04 <byorgey> haha, that would be great.  No, I have never co-authored with pigworker
07:40:07 <merijn> I just realise that since it "grows" a tree I could pick some fancy synonym for growing :p
07:40:54 <merijn> Ha! Growing a tree into some fixed shape is called "tree shaping", so clearly that should be the name
07:42:39 <phadej> or just: bonzai
07:42:49 <phadej> bonsai*
07:42:57 <merijn> phadej: That seems like to good a name to take for something as small as this, tbh
07:46:03 <ertes-w> akfp: you could "or" two traversals into a traversal, but you can't really "or" into a prism
07:46:18 <ertes-w> akfp: which one would (#) pick?
07:48:24 <dragon_> I like bonsai
07:48:35 <ertes-w> merijn: why don't you just work with auxiliary definitions?
07:48:43 <merijn> ertes-w: hmm?
07:49:39 <akh> Hi. I have an issue with GHCi/intero memory usage. Loading a large project using 'stack ghci' in the shell works, but it uses >3GB out of my 8GB RAM. However, when opening the project in emacs/intero (default config), it eventually exceeds the RAM capacity and begins swapping. Any suggestions for how to deal with heavy memory usage in large projects?
07:51:45 <pgiarrusso> akh: my 2 cents (not sure if useful): there's a few options to control whether files are interpreted or compiled
07:52:22 <pgiarrusso> e.g. -fobject-code (https://downloads.haskell.org/~ghc/7.8.4/docs/html/users_guide/ghci-obj.html)
07:53:04 <pgiarrusso> I suspect that *might* improve memory usage
07:54:06 <pgiarrusso> aah: sorry if it doesn't help
07:58:20 <ertes-w> merijn: for the tree building
07:58:39 <merijn> ertes-w: I don't see how auxiliary definitions help anything?
07:58:57 <ertes-w> merijn: [group1, group2, group3] where group1 = testGroup …; group2 = testGroup …; …
07:59:38 <merijn> ertes-w: The problem is that, as I said, I will often have a function "Foo -> Bar -> Baz -> Test" that I will want to test for various combinations of Foo/Bar/Baz
08:00:08 <merijn> ertes-w: Unrolling such a function into a tree is really obnoxious and definitions like that don't improve that
08:00:56 <phadej> merijn: so something like exhaustive smallcheck but with predefined values?
08:01:30 <merijn> phadej: That type is basically a builder for a test case, not the test itself
08:01:45 <phadej> why test case and not test itself?
08:02:08 <merijn> phadej: Ok, let's take a concrete example
08:02:28 <merijn> phadej: https://github.com/merijn/broadcast-chan/blob/master/broadcast-chan/benchmarks/Channels.hs#L200-L234
08:03:00 <phadej> fair point, for benchmarks it make more sense
08:03:03 <merijn> phadej: I have several chan type interfaces and I want to generate benchmarks for several combinations of "reader" and "writer" values
08:03:19 <merijn> phadej: Similarly I also have tests like (test for various combinations of readers/writers, etc.
08:03:40 <merijn> phadej: I end up writing a benchmark/test parameterised over reader/writer counts, number of messages, etc.
08:04:03 <merijn> phadej: If I wanna build a tree from that I end up messily interspersing the tree construction into those functions
08:04:28 <merijn> phadej: Ideally I just take my simple/clean function that generate a single case and nicely generate a tree of various cases and groups
08:05:37 <merijn> phadej: That is exactly what this code is doing. Take a random function that generates a test/benchmark from N parameters. Take ranges/sets of date for those N parameters and nicely unwrap a tree for you
08:05:41 <phadej> I see. I don't say "use smallcheck", but I wonder if you can just abuse container's Monad Tree for that? fun <$> writerCounts <*> readerCounts
08:05:47 <phadej> etc.
08:06:07 <merijn> phadej: In theory, maybe. But you want to properly label your tests/benchmarks too
08:06:50 <phadej> merijn: I guess that's what `fun` would do?
08:07:10 <phadej> I don't know :)
08:07:34 <phadej> fwiw, in Cabal I just use `Typeable` to label tests automatically
08:07:40 <phadej> (IIRC in aeson too)
08:08:14 <ertes-w> merijn: ah, now i see what you mean
08:14:01 <akh> pgiarrusso: Actually it appears to use slightly less RAM. I just ran intero outside emacs and it had the same issue, so I guess this is mainly a problem with intero.
08:14:30 <akh> I'll try compiling to object code in GHCi with intero.
08:14:54 <pgiarrusso> akh: less RAM with -fobject-code? good
08:15:47 <pgiarrusso> akh: since you say "ghci with intero", let me clarify (if needed): intero is a ghci variant with some more services (for use in editors)
08:16:10 <pgiarrusso> I suspect it *needs* to use more RAM since it keeps more info on the source
08:16:16 <pgiarrusso> (maybe not 3G)
08:16:46 <pgiarrusso> anyway, maybe I'd file an issue on GitHub, to get a good opinion
08:17:09 <pgiarrusso> (not sure they'll respond timely)
08:18:51 <akh> pgiarrusso: Well, intero appears to use more than an additional 2-3 GB. In particular when it "collects type info".
08:22:44 <pgiarrusso> akr: I've googled ghc-mod and ghcid (intero alternatives), and ghc-mod seems to have similar issues: https://github.com/diku-dk/futhark/issues/188
08:22:53 <pgiarrusso> ghcid is at https://github.com/ndmitchell/ghcid
08:23:28 <pgiarrusso> akh: maybe also worth trying: -fno-code
08:30:33 <edwardk> phadej: ok
08:30:39 * shapr hugs edwardk
08:30:43 <shapr> HI
08:30:43 <edwardk> maybe Control.Lens.Unsound ? =)
08:30:48 <edwardk> heya shapr 
08:30:50 <edwardk> ltns
08:30:53 * shapr hops cheerfully
08:31:13 <phadej> edwardk: I'll make a PR soon-ish
08:31:29 <edwardk> phadej++
08:32:26 <glguy> ?karma ++
08:32:26 <lambdabot> ++ has a karma of 83
08:32:31 <shapr> haha
08:32:41 <edwardk> ++++
08:32:45 <edwardk> ?karma ++
08:32:45 <lambdabot> ++ has a karma of 84
08:35:13 <phadej> that's an operator yet to be defined?
08:39:17 <akh> pgiarrusso: Thank you, I'll take a look at those. Actually, this is the same project as linked (futhark) :)
08:39:18 <phadej> edwardk: you you remember any other unsound operations, which are sometimes useful?
08:39:32 <phadej> (`non` is already there :)
08:39:58 <edwardk> clearly Unsound should re-export non  as a joke
08:40:33 <edwardk> there is also singular which is partial, and filtered which is a pseudo-prism
08:40:45 <Athas> akh: ghcid works very well and very quickly with the Futhark code base.
08:40:53 <edwardk> and (^?!) etc
08:40:58 <Athas> But it's much more limited than Intero or ghc-mod.
08:41:37 <merijn> Athas: And neither ghcid nor Intero support vim :\ *sigh*
08:41:44 <edwardk> you could export a 'head' and 'tail built off of the '_head' and '_tail' traversals
08:41:46 <Athas> ghcid doesn't support anything, does it?
08:41:47 <bollu> Hey, is anyone at LLVM Dev meet right now? :) 
08:41:51 <Athas> I just run it in an xterm.
08:42:00 <bollu> I'd love to bump into fellow haskellers
08:42:03 <edwardk> we didn't export those because they'd be partial
08:42:06 <merijn> Athas: I mean in the sense that there's no editor plugins for, e.g. auto highlighting errors
08:42:25 <Athas> merijn: oh, right.  I miss those.  But I'm willing to give it up for something that actually works reliably.
08:42:47 <merijn> Athas: I'd rather have both reliable and auto highlighting...I rely on it so much :(
08:42:48 <edwardk> phadej: the combinators for partsOf and unsafePartsOf are dangerous in the wrong hands
08:42:56 <Athas> Haskell editor tooling seems really ill-behaved, and I value consistency very highly.  (Intero is way better than anything that came before, though.)
08:43:31 <shapr> there's the haskell-ide-engine project
08:43:36 <shapr> lots of good stuff happening there
08:44:29 <edwardk> phadej: takingWhile, droppingWhile are unsound in general
08:44:43 <edwardk> worded, lined
08:45:38 <edwardk> itakingWhile, idroppingWhile as well
08:45:55 <edwardk> selfIndex lies a bit
08:46:07 <Athas> shapr: I have hopes for the future, but it seems like even the foundations are fragile.
08:46:08 <cronokirby> intero is really nice
08:46:14 <edwardk> enum claims to be an iso but works on Float, Double. etc
08:46:20 <Athas> Loading code in ghci requires a tonne of memory.
08:46:33 <edwardk> levels and ilevels
08:46:35 <Athas> ghcid works around that by not generating code, or something like that, but I'm not sure what implications that has.
08:46:52 <shapr> Athas: write up a summary blog post?
08:46:59 <shapr> I bet that'd get some feedback
08:47:41 <Athas> shapr: seems too trollish.  People are already working on these things, I don't think it serves any purpose for me to whine that they haven't gotten to my use cases yet. :-)
08:47:46 <edwardk> strict and lazy are valid only for finite inputs but that's getting wibbly
08:48:03 <shapr> Athas: describe the good points, describe the next steps as you see them?
08:48:38 <edwardk> multiplying 0 / dividing 0 are unsound but those are documented and are special cases.
08:49:05 <edwardk> directory/extension/fileName are all a little wonky too
08:49:36 <edwardk> feel free to drop any of those that are being too anal retentive. i just went through and skimmed for any law breakage
08:52:39 <EvanR> that feel when laws seem to be ruining the fun... change the laws? hehe
08:53:33 <mbwgh> Is there some way to use an inductively defined Nat type in conjunction with literals? The singletons library exports the GHC.TypeLits API, but you can't pattern match, making type-level programming very hard. On the other hand, if you roll your own `data Nat = Z | S Nat`, or use something like type-combinators, you have to pass things like `S (S (S (S Z)))` as arguments :/
08:55:12 <lyxia> Define a type function GHC's.Nat -> Your.Nat
08:56:11 <lyxia> Then you can type "F 144" instead of "S (... (S Z) ...)"
08:56:17 <pgiarrusso> shapr: I fear what's missing is people paid to work full time on this  ideas are around
08:57:14 <pgiarrusso> *also*, I hear reusing a compiler for editor services is not trivial  you'd want to design your compiler for this
08:57:23 <mbwgh> lyxia: Sounds feasible. Though this should've been defined a million of times already...
08:58:16 <pgiarrusso> success stories: C#, clang. Failures: GCC
08:59:07 <lyxia> mbwgh: Yeah, I don't know of a common package that you can reuse.
09:00:31 <James123> Is there any way to split a list (or similar) to two sublists in constant time?
09:01:46 <pgiarrusso> James123, for a list that seems impossible (for splitting in half), not sure about fancier data structures
09:01:56 <pgiarrusso> logarithmic time should be possible (probably already with finger trees)
09:02:26 <lyxia> case list of (h : t) -> ([h], t) ; [] -> ([], [])
09:02:34 <mbwgh> lyxia: The type-combinators package defines an inductive Nat type and exports synonyms N0 - N9. If you think about it, using these in the three-digits is probably a stretch anyway. Idris for instance makes it easy to call a type-level function with (10000 : Nat) or something. This kills Idris...
09:03:09 <James123> pgiarrusso: Hmm, thank you. Maybe I could use arrays and appropriate indexing.
09:04:11 <pgiarrusso> James123, if you absolutely can't tolerate logarithmic and don't need the data structure to be persistent, that could work
09:04:38 <pgiarrusso> though logarithmic is often effectively a (high) constant
09:04:56 <pgiarrusso> (as in, log (a million) is 20)
09:05:00 <lyxia> mbwgh: yeah that sounds reasonable too
09:05:25 <Psybur> If youre using a vector, splitAt is constant time
09:06:11 <Psybur> James123, ^
09:06:43 <lyxia> mbwgh: In my experience type class instances on Nat are not so bad.
09:06:45 <James123> Psybur: Thank you, I could try that
09:09:30 <mbwgh> lyxia: Do you roll your own?
09:29:13 <saurabhnanda> stack user here. Using ghc --make for the first time on a tiny project. It can't find any of my modules. How do I give it an include directory? is there an equivalent of gcc's -I flag?
09:31:49 <cocreature> saurabhnanda: yes -I
09:31:57 <saurabhnanda> same :)
09:32:09 <cocreature> eh no that’s for #include, lowercase
09:32:23 <cocreature> assuming you mean import path and not include dirs
09:32:43 <saurabhnanda> yes, import path.
09:33:07 <cocreature> -i it is
09:34:02 <saurabhnanda> okay thanks.
09:34:21 <saurabhnanda> it seems that ghc --make is faster than stack. is that generally the case?
09:35:37 <cocreature> given that stack uses ghc --make it would be weird if, if stack was faster
09:37:06 <saurabhnanda> ah okay.... 
09:47:27 <erisco> I thought there was a data type called Error, or similar, which is iso to Maybe but is more appropriately named for computations which either succeed trivially or produce an error
09:47:37 <erisco> instead of failing trivially or producing a result
09:48:00 <erisco> can't find it now
09:48:56 <erisco> but if I was to come up with the naming myself I'd think of something like  data Test a = Pass | Fail a
09:49:17 <fakenullie> Either
09:49:44 <fakenullie> oh, no argument
09:49:47 <Cale> I typically use  Either Text ()  to represent a possible error message
09:49:57 <Cale> Note the order of the arguments to Either there, it's important.
09:50:22 <Cale> Of course, that's not adequate if you want to accumulate errors
09:50:30 <fakenullie> it's not computation then, it's effect
09:51:07 <erisco> Cale, yeah, it is just aesthetically clumsy to me
09:51:13 <Cale> Sure -- the example in my head at the moment is responses to web APIs 
09:51:47 <Cale> Sometimes there will be a result as well, in which case you'd also use the Right portion.
09:52:12 <fakenullie> I think web api success always carries some additional information
09:52:26 <Cale> Not always. Sometimes you're just requesting deletion of something.
09:52:32 <Cale> For example
09:52:44 <erisco> I swore someone was talking about such a data type a few months ago, but maybe I am misremembering
09:52:49 <fakenullie> can you use maybe in reverse?
09:53:02 <cement> that's what I was thinking
09:53:08 <Cale> Actually, a lot of our APIs don't produce meaningful data on success, because we have a whole other mechanism for requesting live data.
09:53:18 <cement> "Nothing wrong" "Just an error"
09:53:49 <Cale> Actually, I had a need for such a thing the other day, in the context of constructing queries
09:54:06 <Cale> where the cases were basically "No restriction" vs. "Information about how to restrict"
09:54:23 <fakenullie> Maybe Error
09:54:36 <Cale> So, I wanted something like data MaybeNot a = Only a | Everything :)
09:55:20 <Cale> (though the name MaybeNot suggests that it ought to be  Only (a -> Void))
09:55:54 <Cale> (that's obviously less useful in Haskell)
09:58:44 <erisco> a type is easily aliased, but not a constructor
09:59:01 <fakenullie> how about Exception
09:59:22 <erisco> the closest I can think of is a pattern
09:59:34 <erisco> a view pattern
09:59:49 <cocreature> erisco: pattern synonyms?
10:00:11 <erisco> never heard of it… I'll take a look
10:00:39 <cocreature> depends on what exactly you mean by “aliasing constructors” but pattern synonyms should at least come close to what you’re looking for
10:02:01 <fakenullie> well, looks like Right () is the way
10:08:29 <new_haskeller> hi all, I am using https://github.com/myfreeweb/pcre-heavy for REGEX
10:08:40 <new_haskeller> I have a tuple of strings, (String, String)
10:08:53 <new_haskeller> I want to regex match for true on the second string
10:09:36 <new_haskeller> i.e. myFunc ("someliteralstring", y ~= [re|^aeiou|])
10:09:54 <new_haskeller> I can't seem to get the second part of the tuple regex part to compile
10:10:09 <new_haskeller> i.e. pattern matching with regex
10:11:55 <int-e> new_haskeller: use a guard?  myFunc ("some...", y) | y =~ [re|...] = ...?
10:13:54 <new_haskeller> int-e: I'll check it out, thanks!
10:16:55 <crucify_me> hi I'm revisiting something I still don't quite understand. After unifying with (+) , function gg requires a 3rd parameter and it is clear in the type check: gg (+) :: Num a => a -> c -> a -> a   so the operator (+) creates the new parameter, its reflected in a new type, and the programmer has to know that they are adding an argument (say, in a case where the number of arguments is not obvious) 
10:16:59 <crucify_me> https://ptpb.pw/G27Y
10:18:09 <crucify_me> or is the only way to know what to enter is by looking at the type signature?
10:19:49 <crucify_me> I could imagine a more complex function where dropping the c argument would be confusing
10:22:55 <crucify_me> I mean, in what situation would you use gg f a c = f a   ?
10:23:32 <int-e> crucify_me: Usually when working with functions in Haskell, looking at the type is highly recommmended. The number of arguments is not clear in the case of polymorphic types. For example id :: a -> a has an instance id :: (a -> b) -> a -> b with two visible arguments, id :: (a -> b -> c) -> a -> b -> c with three, and so on.
10:24:36 <Cale> > foldr (\x xs s -> s : xs (x : s)) (const []) [1,2,3,4] []
10:24:39 <lambdabot>  [[],[1],[2,1],[3,2,1]]
10:24:48 <crucify_me> int-e thanks yeah. could you off-hand see an application?
10:24:49 <Cale> > foldr (\x xs s -> s : xs (x : s)) (\x -> [x]) [1,2,3,4] []
10:24:52 <lambdabot>  [[],[1],[2,1],[3,2,1],[4,3,2,1]]
10:25:02 <Cale> How many arguments does foldr take? :)
10:25:11 <int-e> printf ... is perhaps too extreme.
10:25:14 <erisco> crucify_me, your dilemma is that you are thinking about uncurried functions when this is in fact a curried function
10:25:34 <Cale> We can simulate a stateful foldr just by accumulating a function, which we immediately apply to another argument
10:25:43 <Cale> Effectively giving foldr an additional argument.
10:25:57 <crucify_me> er..
10:26:22 <Cale> (because a function of two arguments is the same thing as a function which produces another function as its result)
10:26:45 <erisco> talking about giving things arguments or how many arguments or whatever is a nice shortcut when you already understand how the game works
10:26:55 <int-e> :t foldr (.) id
10:26:57 <lambdabot> Foldable t => t (b -> b) -> b -> b
10:27:04 <Cale> Yeah, really every function has exactly one parameter
10:27:39 <erisco> it is like if I started talking about  a -> (b, c)  as returning two values
10:27:41 <mnoonan> yeah, it's probably better to think of it as returning a function, rather than adding arguments. e.g. instead of thinking of id for functions as having type id :: (a -> b) -> a -> b, think of it as id :: (a -> b) -> (a -> b)
10:27:52 <Cale> and those who appear to accept more arguments are just producing other functions
10:28:15 <erisco> sure, that's a fine shortcut at times, but as read plainly it is incorrect
10:28:27 <crucify_me> I understand it intuitively and currying too, its funny, visually f a c = f a   plays tricks on my brain
10:29:33 <crucify_me> I guess for now I'll rely on the type signature .. reading it is getting a bit easier for me. thanks ALL
10:31:32 <crucify_me> gg (+) 4 1   << we have this. once 1 is dropped so to speak, (+4 ) is one function looking for an argument, correct?
10:31:55 <ertes-w> crucify_me: let f be any function, then (id f) is also a function, right?  because (id f = f)
10:32:05 <ertes-w> crucify_me: so you can give it an argument:  (id f) x
10:32:13 <ertes-w> but in haskell that's just (id f x)
10:32:40 <mnoonan> so I'm getting a failure on some test cases when going from ghc 8.0.* -> 8.2.1 and I can't even quite wrap my head around how to debug it..
10:32:41 <mnoonan> https://github.com/matt-noonan/justified-containers/blob/master/test/Data/Map/JustifiedSpec.hs#L138
10:33:03 <mnoonan> in that test case, `isLiterally` is supposed to check if two values occupy exactly the same location in memory
10:33:19 <ertes-w> crucify_me: that's why it's best to view all functions as taking exactly one argument
10:33:36 <mnoonan> m is just a newtype of letters, and k is a newtype of "theKey k"
10:34:21 <mnoonan> this worked in 8.0.*, and a bunch of the other tests that use `isLiterally` still pass, but these two consistently fail on 8.2.1
10:34:38 <cocreature> mnoonan: fail as in “runtime error” or it just doesn’t compile?
10:35:06 <cocreature> oh isLiterally seems sketchy, unsafePerformIO, unsafceCoerce and reallyUnsafePtrEquality in a single function :)
10:35:13 <mnoonan> it's super sketchy! :)
10:35:22 <mnoonan> but it has worked so far, so.. *shrug*
10:35:38 <crucify_me> right, you just need to infer that id f is looking for one argument. the compiler makes an allowance for any argument that is "dropped" such as in f a c = f a ertes-w 
10:36:08 <Cale> :t let f a c = f a in f
10:36:10 <lambdabot> error:
10:36:10 <lambdabot>     • Occurs check: cannot construct the infinite type: t3 ~ p0 -> t3
10:36:10 <lambdabot>       Expected type: t2 -> t3
10:36:28 <Cale> ^^ that equation doesn't type check, since f would need to have an infinite type.
10:36:30 <mnoonan> cocreature, anyway, it fails as in the test case runs but reports that the two values are not at the same memory location
10:36:51 <ertes-w> crucify_me: take a look at the 'replicate' function
10:36:55 <ertes-w> > replicate 4 'a'
10:36:58 <lambdabot>  "aaaa"
10:37:11 <cocreature> mnoonan: well the test case only fails if the memory locations are different, no?
10:37:17 <ertes-w> crucify_me: now look at the type
10:37:19 <ertes-w> :t replicate
10:37:21 <lambdabot> Int -> a -> [a]
10:37:45 <ertes-w> crucify_me: we think of it as a binary function, but that type is really the same as:  replicate :: Int -> (a -> [a])
10:37:55 <ertes-w> crucify_me: it takes an Int and returns a *function*
10:38:01 <mnoonan> cocreature: right. but both sides are lookup up the same key in the same map, modulo some newtype wrapping and unwrapping
10:38:25 <ertes-w> crucify_me: that function takes a value and produces a list of that value
10:38:44 <ertes-w> crucify_me: so (replicate 4) is the function that takes a value and produces a list containing that value four times
10:38:55 <ertes-w> > (replicate 4) 'a'
10:38:57 <lambdabot>  "aaaa"
10:39:41 <ertes-w> crucify_me: does that make sense?
10:40:29 <crucify_me> ertes-w, Cale  thanks hold on please .. really want to make sure I get the infinite type error. I looked at    a ~ [a]    and    a ~ (a -> a)
10:40:54 <crucify_me> earlier and I want to know the mechanics of that
10:41:16 <cocreature> mnoonan: sorry not sure what’s going on here. I can only suggest trying to isolate it to a minimal example
10:41:26 <robertkennedy> What's the best way to increment a counter many times per second from 400+ threads? Just `modifyTVar'`?
10:41:55 <robertkennedy> Or would the lazier version be better if I only read it occasionally?
10:42:42 <mnoonan> cocreature: fair enough. beyond that, is there something past Core I can inspect to try to figure out why an allocation is apparently happening?
10:42:51 <mnoonan> and before assembly ;)
10:42:57 <ertes-w> robertkennedy: no, strict is almost certain to be better
10:43:03 <cocreature> mnoonan: there’s stg and c--
10:43:21 <cocreature> mnoonan: and LLVM IR if you use that code generator
10:43:27 <mnoonan> ahh, -ddump-stg
10:43:31 <ertes-w> robertkennedy: if you do it lazily, you will cause allocation and long-term GC
10:43:38 <mnoonan> guess it is finally time for me to get friendly with stg
10:43:48 <robertkennedy> I figured as much. I'll make sure that's the bottleneck before spending too much more time on it
10:43:50 <cocreature> mnoonan: but stg is really close to core so I doubt it will be helpful if core isn’t helpful
10:44:00 <crucify_me> Cale  so what is the compiler trying to do before this is determined to fail >>  :t let f a c = f a in f
10:44:13 <erisco> let each thread have its own counter, and then on the thread where you need the total merely read and sum the counters of each thread
10:44:19 <mnoonan> maybe just comparing the core for 8.0.* vs 8.2.1 will reveal something
10:45:08 <crucify_me> by having it in a let statement ?
10:45:17 <ertes-w> crucify_me: f :: a -> b -> c;  f a c = f a
10:45:25 <erisco> this will tell you a minimum bound on what the actual total sum must be
10:45:30 <ertes-w> crucify_me: whatever is on the right hand side of "=" is of type 'c'
10:45:43 <ertes-w> crucify_me: (f a) is of type (b -> c)
10:45:54 <robertkennedy> ericso: makes sense. Then each counter could be an IORef instead of TVar, since it's only modified by one thread yeah?
10:46:06 <ertes-w> crucify_me: normally with monomorphic types this would just be a type mismatch
10:46:32 <ertes-w> crucify_me: however, 'c' is a fully polymorphic type, so the compiler is thinking:  "hmm, maybe i can choose 'c' such that it works"
10:46:39 <ertes-w> so it chooses:  c = b -> c
10:47:05 <ertes-w> but if c = b -> c, then b -> c = b -> (b -> c)
10:47:16 <ertes-w> = b -> (b -> (b -> c))
10:47:20 <ertes-w> = b -> (b -> (b -> (b -> c)))
10:47:25 <erisco> robertkennedy, I don't know about the concurrency tools in Haskell. What I do know is you have to be conscientious about what is atomic
10:47:30 <ertes-w> crucify_me: do you see the problem?
10:47:34 <Cale> and there's an explicit check, called the "occurs check" to see if a type variable occurs on both sides of an equation when the compiler is finding and solving these equations
10:47:55 <Cale> in order to prevent this kind of infinite descent
10:47:59 <erisco> robertkennedy, for example, if a thread incrementing the counter is an atomic action, then you can read the counter from a different thread at any time and you will see some valid version of it
10:48:24 <erisco> robertkennedy, however, if it is not atomic, then at some times you will read the counter as it is being updated, i.e. it will be invalid
10:48:51 <erisco> in Haskell, I am going to guess that incrementing an Int will be atomic but incrementing an Integer may not be, but these are things you'll have to check
10:49:02 <crucify_me> It's fascinating. I need to go over this log outside a noisy cafe. thanks so much ertes-w Cale
10:50:01 <ertes-w> crucify_me: welcome to the infinite rabbit hole that is haskell =)
10:50:22 <robertkennedy> ericso: is fine to not have exactly correct value, I'll test it out. 
10:50:24 <erisco> robertkennedy, by atomic I mean there is no possibility of interruption
10:50:52 <erisco> well, it could give you a high probability of garbage though
10:51:01 <erisco> or a low probability … that's a scheduling question
10:51:25 <crucify_me> I'm on infinitely too much caffeine
10:51:52 <erisco> for example, say an Integer is stored as a list of digits, and so to increment it we have to increment each digit as appropriate
10:52:18 <ertes-w> erisco: if you use MVar or STM, then you get atomicity pretty much for free
10:52:52 <erisco> so  [0,1,1] incremented is [1,0,0] … you'd expect there to be intermediate states, namely [0,1,0] then [0,0,0] then [1,0,0]
10:52:53 <ertes-w> in the case of STM even if you store each digit in a separate TVar
10:53:16 <erisco> ertes-w, talk to robertkennedy about it
10:53:58 <erisco> so then, if you are reading sometime during the incrementing of the Integer, which may be a low probability based on what the threads are doing overall, then there is a 1/3rd chance you read a valid state
10:54:04 <barrucadu> erisco: An MVar or IORef contains a single reference to a Haskell value, so you can't see an intermediary state with a half-constructed Integer
10:54:05 <erisco> and a 2/3rds chance you read an invalid one
10:54:10 <cocreature> mnoonan: if you figure it out, let me know. I’m now curious what changed in 8.2 that caused these tests to break :)
10:54:20 <erisco> so, it isn't just not the current total, it is a state that possibly never was the total
10:54:23 <mnoonan> cocreature: will do!
10:54:30 <erisco> so instead of a minimum bound you now have a probability of complete garbage
10:54:58 <erisco> okay, it seems people are responding without understanding the premise of what I am talking about
10:55:51 <erisco> I am talking about what would happen if you looked at the state of a thread absent of any sort of concurrency mechanism
10:56:02 <geekosaur> grah. I really do need to write up that article at some point
10:56:08 <erisco> it is just a question of what states does that thread go through, and from there, what is it possible that we read
10:56:18 <erisco> what ends up atomic here is dependent on the CPU
10:56:26 <Zemyla> So question. For all arrows, there is a function like this:
10:56:47 <Zemyla> :t \p a -> p <<< arr (\() -> a)
10:56:49 <lambdabot> Arrow cat => cat b c -> b -> cat () c
10:56:59 <Zemyla> And for all ArrowApplys, there is a function like this:
10:57:15 <Zemyla> :t \f -> app <<< arr (\a -> (f a, ()))
10:57:17 <lambdabot> ArrowApply cat => (a -> cat () c) -> cat a c
10:57:23 <Zemyla> Is this an isomorphism?
10:57:46 <erisco> I am guessing that incrementing an Int in Haskell is not going to have any other memory states than the number before and the number after
10:58:14 <erisco> so, regardless of when we read the Int, we should see a valid number in the sense it was in fact a state the thread was in
10:58:24 <Zemyla> Is every ArrowApply p a b isomorphic to (a -> p () b)?
10:58:47 <erisco> let me correct: a valid number in the sense that it was in fact a logical state the thread was in
10:59:17 <erisco> logical being on the level of "increment a number" and otherwise being the individual atomic changes in state to get there
11:00:32 <crucify_me> pardon ertes-w 
11:00:42 <erisco> so in the case of something like incrementing an Int, I am guessing you can read that with abandon, no special concurrency mechanisms
11:01:13 <erisco> on the other hand, trying to have 400 threads concurrently write an Int would be a disaster
11:01:37 <crucify_me> you said whatever is on the rhs of f a c = f a    is c. but did you mean right of = f   ?
11:01:43 <crucify_me> if you around ertes-w 
11:01:46 <erisco> the only benefit being that the value is always current
11:04:43 <ertes-w> crucify_me: f = _
11:04:46 <ertes-w> _ :: a -> b -> c
11:04:58 <ertes-w> crucify_me: f a = _
11:05:03 <ertes-w> a :: a
11:05:06 <ertes-w> _ :: b -> c
11:05:13 <ertes-w> crucify_me: f a c = _
11:05:15 <ertes-w> a :: a
11:05:17 <ertes-w> c :: b
11:05:20 <ertes-w> _ :: c
11:05:34 <ertes-w> crucify_me: does that make sense?
11:06:33 <cocreature> using the same names for value-level variables and type variables is not helping to make this less confusing :)
11:06:45 <ertes-w> yeah, i agree =)
11:06:54 <ertes-w> crucify_me: allow me to rename your variables a bit
11:06:58 <ertes-w> f :: a -> b -> c
11:07:18 <crucify_me> the wildcard symbol ....
11:07:39 <ertes-w> f = _  -- if you wrote it this way, then you literally say that f is equal to _, so they are of the same type
11:07:42 <ertes-w> _ :: a -> b -> c
11:08:06 <ertes-w> f x = _  -- if you write it this way, then you say that f applied to x is equal to _
11:08:17 <ertes-w> therefore (x :: a) and (_ :: b -> c)
11:08:25 <ertes-w> crucify_me: does that make sense?
11:08:29 <ertes-w> (so far)
11:08:41 <crucify_me> one moment please .. really want to get this
11:09:17 <ertes-w> crucify_me: let's use a less abstract example
11:09:28 <ertes-w> repChar :: Int -> Char -> String
11:10:01 <ertes-w> repChar = _  -- if you write it this way, then you're saying repChar is equal to _, so obviously they also have the same type, i.e. (_ :: Int -> Char -> String)
11:10:58 <ertes-w> repChar n = _  -- if you write it this way, then repChar applied to n is equal to _, therefore n has to be of type Int, and _ has to be of type (Char -> String)
11:11:47 <crucify_me> no I'm studying the notation and I'm getting it. one moment please lets stick with the original example if possible
11:11:57 <ertes-w> crucify_me: sure
11:16:16 <crucify_me> so on the rhs f is partially applied and we are left with b -> c  ertes-w 
11:16:29 <ertes-w> crucify_me: correct
11:17:31 <crucify_me> ok so you mentioned that the rhs resolves to c
11:17:52 <crucify_me> that's what you meant to say?
11:18:22 <crucify_me> ertes-w, ^
11:19:09 <ertes-w> crucify_me: if you write (f x y = _), then according to f's type, _ should be the *result* of type 'c'
11:27:26 <tobim[m]> Is there a haskell like language that stores all functions in an indexed DB and makes them importable as packages on a global level?
11:29:53 <crucify_me> ok the result is of type c on the rhs, so f is applied to a on the right hand side, and we are left with b -> c  ertes-w 
11:30:28 <ertes-w> crucify_me: correct
11:30:52 <ertes-w> tobim[m]: do shared objects count as indexed DBs?
11:30:53 <geekosaur> that doesn't seem to go well with 'functions are first class', now you have functions that are more special than others by being in the DB
11:31:04 <crucify_me> ok we could gently move on from there :)
11:31:42 <ertes-w> crucify_me: ok, allow me to come back to the repChar special case just to demonstrate something
11:31:52 <geekosaur> or you do it on a different level, e.g. if you do it at the linker level then you have ghc's -split-objects flag. but linkers have a tendency to overload when you do that
11:31:56 <crucify_me> ok
11:32:46 <ertes-w> crucify_me: imagine you wrote:  repChar n c = repChar n  -- now even just intuitively this should strike you as weird, and GHC will think the same, because (repChar n :: Char -> String)
11:32:54 <ertes-w> crucify_me: but the RHS is of type String
11:33:15 <ertes-w> so you can't have a (Char -> String) there
11:34:32 <ertes-w> crucify_me: interestingly in this specialised form GHC will actually just tell you that there is a type mismatch
11:35:13 <ertes-w> crucify_me: now back to your more general 'f'
11:35:17 <ertes-w> f :: a -> b -> c
11:35:19 <crucify_me> ok
11:35:20 <tobim[m]> well, think more on the lines of as if hackage supported only packages consisting of single functions
11:36:20 <ertes-w> crucify_me: this is just repChar, but if you look at the type signature, you can read it as:  "hi, i'm f…  if you use me, feel free to pick any types you like for 'a', 'b' and 'c'…  i don't care what they are, i will work regardless"
11:36:21 <tobim[m]> then the dependency tree could be represented on a very fine grained level
11:36:59 <ertes-w> crucify_me: particularly 'c' is also fully polymorphic, and that's the result type
11:37:20 <ertes-w> f x y = f x  -- now you write this…  you write a (b -> c) where a 'c' was expected
11:37:56 <ertes-w> this is *not* a type mismatch, because f is using itself, and as we know it promises to work for arbitrary choices of 'c'
11:38:14 <Zemyla> But yeah, I'm really wondering if there's a law-abiding ArrowApply p which isn't isomorphic to Kleisli (ArrowMonad p).
11:38:29 <crucify_me> so c ~ (b -> c) and we get infinite results
11:38:36 <ertes-w> exactly
11:38:44 <crucify_me> trippy
11:38:56 <fishythefish> an infinite *type* to be clear
11:38:59 <ertes-w> we get an infinite *type*
11:39:10 <fishythefish> we discussed before how an infinite type is not the same as saying an infinite set of values
11:39:49 <ertes-w> crucify_me: now haskell is very conservative about infinity on the type level…  it's simply not allowed
11:40:11 <ertes-w> otherwise (f x y = f x) might actually type-check
11:41:24 <crucify_me> so gg f x y = f x does type check, because the compiler allows for gg to have its own parameter..
11:41:53 <ertes-w> crucify_me: that one isn't even recursive
11:42:05 <fishythefish> the type of `gg f x y` need not be the same as the type of `f x y`, so the previous argument doesn't apply
11:42:07 <ertes-w> gg :: (a -> b) -> a -> c -> b
11:42:25 <fishythefish> ertes-w: perhaps `const` is a useful talking point here
11:42:48 <ertes-w> gg f x y = _  -- (f :: a -> b), (x :: a), (y :: c), (_ :: b)
11:43:11 <ertes-w> gg f x y = f _  -- (f _ :: b), (_ :: a)
11:43:17 <ertes-w> gg f x y = f x  -- check
11:46:30 <crucify_me> ertes-w, fishythefish thanks so much I'll get this
11:48:34 <ertes-w> crucify_me: it's a symbolic game of fitting puzzle pieces together…  allow me to give you an exercise:
11:48:48 <crucify_me> please do
11:49:58 <ertes-w> f :: (b -> c -> d) -> (a -> b) -> a -> c -> d  -- write a function of this type
11:50:21 <ertes-w> this is an easy one
11:50:26 <robertkennedy> @lpaste 359344
11:50:26 <lambdabot> Haskell pastebin: http://lpaste.net/
11:50:47 <robertkennedy> lpaste.net/359344
11:51:18 <robertkennedy> This was my various counter implementation. Pretty much no change
11:53:54 <crucify_me> ertes-w, I'm a bit overloaded
11:54:47 <merijn> robertkennedy: If you wanna do accurate measurements you might wanna look intro criterion (a library for micro benchmarks), as a bonus you get fancy HTML visualisation too
11:55:05 <ertes-w> crucify_me: there is no time limit…  feel free to do it whenever you want…  or do you need help?
11:55:21 <merijn> robertkennedy: I even have some examples for benchmarking variables like that: https://github.com/merijn/broadcast-chan/blob/master/broadcast-chan/benchmarks/Sync.hs
11:55:43 <merijn> robertkennedy: Note that there's huge performance differences between these concurrent variables in the threaded and unthreaded runtime
11:56:15 <merijn> robertkennedy: Compare http://files.inconsistent.nl/sync-threaded.txt and http://files.inconsistent.nl/sync.txt
11:57:40 <crucify_me> considering I don't see you here often, if you give me a solution I will pour over it later today. ertes-w 
11:57:58 <merijn> crucify_me: lol, ertes-w is here all the time :)
11:58:11 <merijn> crucify_me: But, I suppose, maybe not in your timezone
11:58:43 <crucify_me> really? yeah not sure maybe they avoid me merijn  :)
11:59:14 <ertes-w> crucify_me: yeah, i'm a fairly common sight around here =)
11:59:35 <fishythefish> crucify_me: start with the easy stuff. name your arguments
12:00:01 <ertes-w> crucify_me: just try it on your own…  you are not allowed to use recursion, and there is only one possible solution
12:00:16 <fishythefish> crucify_me: next, work out what you can do with the values you have -- the types are such that you're pretty restricted.
12:00:32 <fishythefish> alternatively, work out where the result type you want can come from
12:00:42 <ertes-w> crucify_me: by just looking at the type you can already infer the following template:  f g h x y = _
12:01:14 <ertes-w> crucify_me: in fact just write it like that into a source file (together with the type signature!), then GHC will actually help you out =)
12:01:24 <ertes-w> it tells you the type of _ and the types of things that are in scope
12:01:41 <robertkennedy> merijn: yeah, not looking for super precision - just an incrementing procedure that won't slow down the process
12:01:47 <crucify_me> put of my problem is the irc venue. .. excellent I will do that. ertes-w << that's your only moniker?
12:01:51 <crucify_me> *part
12:02:21 <ertes-w> crucify_me: i go by 'ertes', too, and sometimes by 'supercynic'
12:03:02 <ertes-w> usually you can tell by my nickname which languages i have used that day
12:03:05 <ertes-w> ertes → haskell
12:03:11 <ertes-w> supercynic → pretty much anything else
12:03:25 <crucify_me> nice!
12:04:07 <crucify_me> thanks its very encouraging to have people who have a lot of patience ertes-w 
12:04:15 <crucify_me> and fishythefish 
12:04:23 <fishythefish> no problem :)
12:06:10 <ertes-w> my pleasure =)
12:06:25 <ertes-w> fishythefish: (BTW, i didn't ignore your suggestion, i just didn't know how to make use of it) =)
12:06:38 <fishythefish> yeah, sorry, that was unclear
12:06:52 <crucify_me> ertes-w, fishythefish well I'm interested since I know const fairly well
12:07:22 <fishythefish> i meant `const` instead of `gg` as a common example of a function where stuff on the LHS is ignored/doesn't contribute to the result type
12:07:24 <crucify_me> > const id 3 4 "t" 
12:07:27 <lambdabot>  error:
12:07:27 <lambdabot>      • No instance for (Num ([Char] -> ()))
12:07:27 <lambdabot>          arising from a use of ‘e_134’
12:07:34 <merijn> robertkennedy: I think we need more low-level benchmarks, so I figured if I could get you to write some more I wouldn't have to ;)
12:07:57 <crucify_me> oops
12:08:00 <fishythefish> > const (+) 1 2 3
12:08:04 <lambdabot>  5
12:08:11 <merijn> Is there some kind of Typeable abuse or something I can use to check whether a type is an instance of a class?
12:08:38 <ertes-w> merijn: don't think so
12:08:44 <merijn> ertes-w: Well, I know about IfCxt
12:08:59 <merijn> But I was hoping for something better tested :)
12:09:01 <ertes-w> merijn: you mean dynamically?
12:09:04 <erisco> merijn, what is that?
12:09:35 <ertes-w> no, that doesn't even make sense =)
12:09:35 <merijn> erisco: https://github.com/mikeizbicki/ifcxt
12:10:16 <merijn> IfCxt is freaking magic, btw
12:10:31 <merijn> But not sure whether a "real" library should depend on that :p
12:11:12 <erisco> merijn, I asked a question that could have been answered by this just yesterday
12:11:43 <ertes-w> that's crazy
12:12:08 <merijn> ertes-w: :)
12:12:32 <merijn> ertes-w: That library is absolute genius and not enough people know about it
12:13:49 <fishythefish> merijn: wow, that's incredible
12:13:53 <ertes-w> merijn: well, it's one of those case of: "if you can't kill it, bury it under a thick layer of TH"
12:14:04 <merijn> But it also requires you to enumerate instances I think, so it's not quite good for what I want
12:14:18 <ertes-w> yeah, it uses TH
12:14:40 <ertes-w> it's not much more than the old overlapping trick
12:14:49 <ertes-w> like Show used to do for [Char]
12:14:51 <fishythefish> merijn: sorta, I think it just requires you to enumerate the typeclasses you want
12:15:26 <fishythefish> mkIfCxtInstances should derive all the instances for that typeclass, if I'm reading this right
12:15:40 <merijn> My life is probably easier if I just require Eq instances instead of using IfCxt
12:15:48 <ertes-w> (i was expecting something that requires -XSuperCrazyMagicInstances and -XIncreadiblyUnsafeSuperDuperCasts or something)
12:15:50 <merijn> Since nearly everything has an Eq instance anyway
12:16:18 <ertes-w> merijn: what would you do in case of absence?
12:16:28 <geekosaur> isn't there already a mailing list thread about doing that?
12:16:30 <erisco> with this, I can complete OOP in Haskell
12:16:31 <tdammers> ifcxt sounds extremely useful and feels extremely wrong
12:16:51 <tdammers> erisco: what were you missing?
12:17:10 <erisco> don't you remember? just what merijn linked to
12:17:15 <merijn> ertes-w: Basically I have a list of 'a' and if I have an equal instance I want to coalesce duplicates, in the absence of an Eq instance I'd just leave them uncoalesced
12:17:43 <ertes-w> i don't know…  i feel like the cases where one might be inclined to use IfCxt one should really just take an extra argument
12:17:48 <erisco> ah, great, I forgot my cabal had disappeared… sigh
12:17:53 <ertes-w> merijn: like in your case…  i'd just take a comparison operator
12:17:54 <tdammers> erisco: sure, I just can't see how you need that for OOP
12:18:10 <ertes-w> f (.==) … = …
12:18:12 <merijn> ertes-w: That is...very painful, since this is heterogeneous list
12:18:20 <erisco> okay, well, you'll see later if I get it working now
12:18:32 <merijn> ertes-w: So I'd need to take an arbitrary number of different comparison operators
12:18:46 <ertes-w> merijn: or a family of them
12:18:59 <merijn> ertes-w: Or make it a hard requirement to specify a comparison operator for each
12:19:07 <merijn> ertes-w: I don't particularly like either of those options
12:19:09 <erisco> where is the cabal executable supposed to be in Haskell Platform?
12:19:18 <merijn> ertes-w: Simply requiring Eq seems less annoying
12:19:19 <ertes-w> merijn: i like the hard-requirement approach =)
12:20:02 <tdammers> erisco: btw., http://programming.tobiasdammers.nl/blog/2017-10-17-object-oriented-haskell
12:20:10 <merijn> ertes-w: Meh, how often do you want to parameterise over something with no Eq instance?
12:21:15 <erisco> we have different ideas on a correspondence
12:21:54 <shapr> tdammers: nice!
12:21:58 <erisco> I can't install anything because cabal is missing
12:22:06 <erisco> where is it supposed to be if I install Haskell Platform 8.2.1 on Windows?
12:23:28 <ertes-w> merijn: i misread…  i mean i like the "just require Eq" approach
12:23:47 <tdammers> shapr: it's still a bit experimental, I'm not quite sure how I want to do mutability
12:24:04 <shapr> tdammers: oh, is that a pre-release post?
12:24:12 <shapr> cause I already submitted it to lobste.rs
12:24:24 <ertes-w> merijn: sure, it's less flexible, but flexibility is overrated…  what you're really trying to do is to write a function with different semantics based on the existence of an instance
12:25:02 <erisco> maybe I am the only one using Haskell Platform
12:25:05 <ertes-w> merijn: i learned from my PHP days that you shouldn't do stuff like that =)
12:25:30 <tdammers> shapr: nah, it's fine; it just doesn't cover mutability yet; I've been experimenting with that, but I'm not yet happy with it
12:25:37 <shapr> ok, whew
12:26:11 <ertes-w> merijn: the 'nub' example is fine, because it's actually just a performance improvement…  no semantical difference
12:26:23 <tdammers> close call, huh
12:26:59 <ertes-w> merijn: on the other hand it's really just a different algorithm with the same result…  might as well define separate functions =)
12:27:39 <merijn> ertes-w: The problem is that I'm processing a HList and I want to take the "Eq" using function for elements that have it and the "non-Eq" version for others
12:27:58 <merijn> ertes-w: But You can't do that without branching on the presence of an Eq instance
12:29:06 <ertes-w> merijn: data MaybeCtx c a where WithCtx :: c a => a -> MaybeCtx c a; WithoutCtx :: a -> MaybeCtx c a  -- what about this approach?
12:29:36 <merijn> ertes-w: That means I need two different versions of functions producing my HList
12:30:19 <ertes-w> or even just (Maybe (Dict c))
12:31:26 <Ero> hey all
12:31:51 <Ero> the more i think about solving problems in haskell the more i want to define types that rely on terms
12:32:06 <merijn> Ero: Welcome to my life :p
12:32:11 <Ero> is moving to dependently typed haskell my only option?
12:32:34 <merijn> Ero: Dependently typed haskell doesn't exist (yet) and faking it is...painful
12:32:42 <merijn> Ero: You might wanna look at Idris?
12:32:46 <Ero> damn xD
12:32:50 <Ero> thank merijn 
12:32:51 <maerwald> Ero: move to a language that does it properly
12:33:18 <Ero> I'm sort of happy with haskell. I'll settle for making awkward solutions to my problems lol
12:33:22 <merijn> Ero: "moving from Haskell to dependent types" is Idris' target audience, so the docs should be optimised for you :)
12:33:40 <merijn> Ero: Only downsides are: 1) not a very big ecosystem atm and 2) not lazy
12:33:53 <cement> something something haskell 2020
12:33:55 <Ero> its tempting merijn but i've been on a 'which language' journey for over half a decade
12:34:03 <Tuplanolla> It never ends, Ero.
12:34:22 <Ero> i can see the path winding on but for now i want to make some things :)
12:34:52 <Tuplanolla> One of the features I'm not completely sold on is laziness, so I definitely want to try Idris at some point.
12:35:07 <Ero> laziness is awesome. Im not sure i can go back
12:35:10 <maerwald> Tuplanolla: I also think it's overrated
12:35:23 <cement> it makes things harder to reason about, yeah
12:35:30 <Ero> ?!
12:35:31 <lambdabot> Maybe you meant: v @ ? .
12:35:35 <Tuplanolla> It's all fun and games until you run out of memory.
12:35:54 <Ero> maybe you guys have more experience with this than me. In concept laziness seems ideal
12:35:59 <maerwald> even in languages like rust you can have sort-of-laziness with Iterator trait etc... just where it matters
12:36:02 <MP2E> Idris is total. Picking between lazy or strict is only an optimization for it (at least, that's what I've been told!)
12:36:07 <ystael> Tuplanolla: which happens around the time you have a kid. At least I can't remember anything any more. :p
12:36:10 <merijn> Lazy by default is better than strict by default
12:36:22 <maerwald> and that's what I don't belive
12:36:42 <merijn> Because "too lazy" is trivial to fix with a single local annotation. Too strict can never be solved by that
12:37:02 <Tuplanolla> That contradicts my experience, merijn.
12:37:08 <merijn> Problems of "too strict" can only be solved by threading laziness through the entire codepath that ends up being too strict
12:37:23 <maerwald> also, in haskell, laziness isn't part of the type system, so in order to know what is _actually_ lazy is not as easy as one might thinkg
12:37:38 <Tuplanolla> People don't optimize their libraries for low memory footprint, so some point I'd have to go put that single local annotation into all my dependencies.
12:38:03 <merijn> Tuplanolla: Consider composing folds or traversals. If laziness is an issue you can fix it with a local strictness annotation on the fold. If the folds are too strict you have to make all the composed folds/traversals lazy, since if even one is strict it undoes everything
12:39:18 <cement> I know that the people I work with have remade some libraries specifically because the "normal" libraries for those tasks use too much memory or are too slow
12:39:18 <Tuplanolla> Consider a 2 GB XML or TIFF file, merijn.
12:40:36 <merijn> Tuplanolla: I use stream processing libraries like conduit for those anyway, tbh
12:40:56 <merijn> cement: I'm a bigger fan of trying to fix/improve upstream if at all feasible
12:42:09 <cement> well, the issue was that they had fixed upstream and performance still wasn't good enough
12:42:09 <maerwald> even SPJ said "the next haskell might be strict"... just be open to it, I think it's less of a big deal than people think
12:42:25 <Ero> he said that?
12:42:30 <erisco> I re-ran the Haskell Platform 8.2.1 installer over top of the old install and now cabal is back… I dunno…
12:42:35 <maerwald> yes, in a talk, he was talking about language evolution
12:42:40 <maerwald> it wasn't a statement about "haskell"
12:42:43 <Ero> is the takl online?
12:43:04 <merijn> Whoo! Turn around time of less than between PR and upstream being updated on Hackage
12:43:15 <erisco> merijn, why is this package not on hackage… oO
12:43:22 <EvanR> strict by default...
12:43:23 <maerwald> yes, it's a talk on yt where he wars his red sweater
12:43:24 <EvanR> i refuse
12:43:25 <maerwald> have to find it
12:43:29 <merijn> erisco: Wich package? IfCxt?
12:43:31 <merijn> erisco: It is
12:43:43 <erisco> http://hackage.haskell.org/packages/search?terms=ifctx
12:43:49 <erisco> don't tell me
12:43:52 <merijn> erisco: Hoogle doesn't index all packages
12:43:54 <merijn> erisco: https://hackage.haskell.org/package/ifcxt
12:44:07 <merijn> Also, you misspelled cxt as ctx :p
12:44:20 <erisco> I also spelt it wrong, but the proper spelling does not show up either
12:44:41 <merijn> erisco: Like I said, Hoogle doesn't index all package, I usually use the package index to find new things
12:44:43 <erisco> that's the usual abbreviation, is why
12:45:04 <erisco> why are you talking about Hoogle?
12:45:35 <merijn> erisco: Oh, my brain parses that search URL as Hoogle :p
12:45:45 <erisco> and now ifcxt does show up… I blame my browser
12:46:08 <erisco> it has this habit of assuming what I want to type before I have typed it
12:47:03 <erisco> it is broken, darn… well I can just copy it
12:47:50 <erisco> and rename cxt to ctx like a sane person
12:49:29 <EvanR> rename to Γ like a sane person
12:51:09 <maerwald> Ero: I think it is this https://www.youtube.com/watch?v=3bjXGrycMhQ but I am not sure
12:51:40 <maerwald> the jokes he makes :>
12:51:48 <maerwald> what a guy
12:52:06 <EvanR> ill have what hes having
12:52:15 <maerwald> it might be too strong for ya :D
12:52:46 <maerwald> "this is what god intended... or at least church"
12:52:47 <maerwald> xxD
12:53:21 <maerwald> you can see he prepared that one though :P
12:53:31 <erisco> well, if memory use is that big a problem, why be so crude about it
12:55:32 <erisco> I don't think strict or nonstrict has anything to do with it
12:56:25 <erisco> it is just that, given the ways we happen to write programs, strict programs on average use less memory, or at least that is the assumption I am inferring
12:57:01 <EvanR> im not sure its that big of a problem
13:00:23 <Ero> idris is way over my head
13:01:05 <erisco> C requires you to be painfully specific about dynamic memory
13:01:07 <Ero> the good news is that didn't stop me from getting to grips with haskell
13:01:30 <erisco> and Rust offers some more reward for that pain
13:01:30 <maerwald> erisco: well, that's a solved problem
13:01:53 <Ero> maerwald: thx for the link
13:02:06 <maerwald> Ero: it is indeed the correct video, he said it somewhere towards the end
13:02:18 <Ero> i might have seen version of this video before lol
13:02:36 <maerwald> it's so full of jokes that it could be a stand-up show
13:02:42 <Ero> there tends to be a slew of spj talks that all cover very similar ground on almost every subject he talks on
13:03:24 <Ero> yes, i rememeber this one. Yup it was pretty funny too :)
13:04:00 <maerwald> what I found interesting is where he talked about hardware architecture that executes functional programs directly, but it seems it never took off
13:16:16 <merijn> ok, I have a more concrete topic! I have "Proxy a" and a "b", both 'a' and 'b' are instances of Typeable, how do I check if they're the same type?
13:16:52 <merijn> oh, wait, TypeRep is an Eq instance. Easy-peasy!
13:17:36 <erisco> merijn, there is a function expressly for this which I am happy to look up for you
13:18:07 <merijn> erisco: I can just do "typeRep proxy == typeOf other"
13:18:31 <erisco> you can do many things
13:18:42 <erisco> eqT :: forall a b. (Typeable a, Typeable b) => Maybe (a :~: b)
13:19:06 <int-e> eqT has the added benefit that pattern matching the result produces evidence of the type equality
13:19:07 <merijn> erisco: Yeah, but the boolean case is more convenient for me, so that's all I need
13:19:08 <erisco> that is ludicrously stronger
13:19:20 <erisco> :t isJust
13:19:21 <lambdabot> Maybe a -> Bool
13:19:45 <erisco> isJust ... eqT  using my amazing operator
13:20:04 <merijn> int-e: I don't really plan to use the equality, though. I'm just trying decide whether a specific "tasty" option is already registered or not
13:20:23 <phadej> (Typeable a, Typeable b) => Bool -- ambiguous
13:43:17 --- topic: 'https://www.haskell.org | https://wiki.haskell.org/IRC_channel | Paste code/errors: http://lpaste.net/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D | https://www.reddit.com/r/haskell | Admin: #haskell-ops | Offtopic: #haskell-offtopic | https://downloads.haskell.org | https://summer.haskell.org Summer of Haskell 2017'
13:43:17 --- topic: set by mauke!5lzdiZJQGk@p3m/member/mauke on [Mon Jul 31 05:45:12 2017]
13:43:17 --- names: list (clog Denommus chaosmasttter hallomann pfurla karshan Apocalisp ninedotnine whitephoenix sqooq `Guest00000 epsilonhalbe sarna woodson tremon king_idiot leah2 cdg_ towerio fishythefish Orbstheorem pimlu hexamod otulp MindlessDrone djapo replay gdzb8fu6fm Denthir pandeiro robertmkennedy shutdown_-h_now _d0t davr0s govg soLucien oisdk LeanderK `^_^v dddddd codesoup zzq iAmerikan ziocroc2 MP2E toblorone etorreborre okuu divVerent mortum5 nologo Nd-69-M chindy)
13:43:17 --- names: list (m0rphism mcoffin Ero Philonous Wizek_ mmn80 peterbecich Jesin twanvl_ revprez_cst merijn nicknight sheyll valentinbuza unyu coot____________ Immune blackjid1 potong aarvar ystael jgertm Durbley gehmehgeh gxt tommd shloub LiaoTao theelous3 raibutera dedgrant_ killtheliterate machinedgod alveric1 connrs brisbin lachenmayer johnw alanz marble_visions poliquin__ raynold conal mivael__ Swizec_ Wizek alx741 ilyaigpetrov miklcct Volt_ desperek stevenxl serendependy)
13:43:17 --- names: list (Myrl-saki nick123 xinming cschneid_ samrat jb55 James123 sleffy hackebeilchen pera jmelesky tim1 azahi Enigmagic tac-tics urodna raichoo bigos doodleha_ Guest94027 tromp dsh Foritus leat lukaramu teej wraithm castlelore gawen ortmage Wuzzy zariuq jrheaton ashirase tomaw WorldControl saurabhnanda eschnett dkremer_ WhereIsMySpoon_ isomarcte hexfive crobbins freeman42x jao ssarah eliasr twomix Scorchin am2on zaphar_ps[m] erisco schplaf[m] levzhazeschi[m])
13:43:17 --- names: list (Guest291964[m] M-ms Mike[m]1 sn[m] thejonny[m] Cadey[m] JHBrannam[m] ArrayWindrunner[ MarkusK[m] Scapin[m] toa[m] M-krsiehl jacobleach[m] rydia5[m] WinterFox[m] hiq[m] ltq520[m] m3tti[m] wubbalubbadubdu4 piluex[m] mith[m] slartibartfast[m M-rgh el_tejon[m] M16_29[m] bustillo[m] Maikel_Experius[ o0o[m] rellen Guest312594[m] bramvdbogaerde[m ElliotKiyomizu[m yashi[m] hakan[m] Snircle_ JohnnyReb[m] cgfbee XertroV[m] papapishu malt3 oldsk00l posco niklasb)
13:43:17 --- names: list (danthemyth Arcaelyx_ poligen capisce mattyw stoopkid andyo sepp2k deba5e12 JeanCarloMachado emilypi nighty- ertes-w descender Ewout carbolymer besenwesen mmhat unK_ pacak drcode steshaw thc202 marr asjo Majiir Fekinox hamishmack averell carlomagno1 mkoenig Sigyn mou qzd ironChicken nikivi t7 mxf squisher yaiyan Guest96542 meandi rcat Bane^ HappyEnte baweaver_2 Vorpal banc qwertydvorak markus1189 kensan jli thoros mattp_ maerwald a3Dman_ bezik_ bitemyapp)
13:43:17 --- names: list (joeytwiddle fack SCHAPiE mivael_ bydo_ kiboneu benzrf Hijiri_ hydraz kosmikus1 velpoman anoe_ Gothmog_ saftsuse_ ps-auxw theDon owickstrom andrewmc1eigh wagle_ waylon531 mendez_ Tesseraction asthasr R0b0t1_ acidjnk Fairy armyriad Lynxium[] Lokathor_ quobo S007 slimetrap sw1nn pavonia inhortte cetchmoh erikd iomotoko Swizec cyphase infinity0 snahor CoderPuppy asdfghq Cale alex`` bcoppens_ minad acowley_away justanotheruser felixsch__ brynedwards schoppenhauer)
13:43:17 --- names: list (thunderrd esph Emantor rembo10 akermu dolio keep_learning orion MitchW lagothri1 wedify lambdamu kuttifunk MarcelineVQ HallaSurvivor Nik05 jrabe srk Adluc mek42 nathanic buttbutt1r nakal ego ByteEater[m] ngross[m] GreySunshine hiratara ContessaTP Zialus theorbtwo hive-mind koz_ yeeve ziman lassulus mithsv iw00t Atlantic777 lobata langkid1 _kit_ SkyPatrol int0x27h SegFaultAX myme banjiewen h_ndrik[m] tsaka__ dfeuer forker dysfun prg318 chenyu thebnq xplat)
13:43:17 --- names: list (eruditass mzf mikeplus64 Tehnix jcjf texasmynsted jophish cods magthe tlevine kolko_ ahihi perrier-jouet danieli ski nano- dmiles Khisanth alexbiehl seliopou naudiz nyuszika7h uwap obiwahn x1n4u ManiacTwister StoneToad remexre atomi Raynes Chobbes boj buoto1 zyla zekt Xnuk kshannon ncl28 valdyn kody^ Tourist c-rog tgecho huda[m] jdt michaelw beerdrop Sgeo zebrah Cthalupa scinawa PifyZ[m] quakestor arw pierrot Ulrar sdothum chrissl AndreasK mud machbio)
13:43:17 --- names: list (petercommand robogoat ericsagnes fryguybob thallada jnonpony[m] ddbbuu[m] phittacus schum[m] jvalleroy[m] dumptruckman thoradam TabAtkins spinda dpn` cbaines Brando753-o_O_o Guest30811 andromed1-galaxy Guest18753 ChongLi_ athan electrostat jchia_ jdnavarro mlen OnkelTem NinjaTrappeur stellis[m] tabaqui juhp xeel[m] qnikst jchia1 reorder u-ou ggherdov gleber_ Guest63586 thomashoneyman dgpratt pringlescan nelll dstockwell cgag thi_ JoJoen eacameron jonrh)
13:43:17 --- names: list (Overload[m] xormor dogui jorendorff freusque taylskid akkad ijp rgrinberg urdh bsmt bogdanteleaga alp nek0 suppi twopoint718_ angular_mike___ wizonesolutions Xorlev hansihe ericbmerritt_ nkpart sclv Heero__ CARAM___ kipd gornikm ebutleriv avdi adelbertc Guest64392 solidsnack tharper_ bbielsa dgonyeo marcel andrew_n_ capicue kyagrd Tallenz baamonde monad_cat wenzowski prizim twold afcondon_ paf31 mbrock lexi-lambda mkurkov_ nbouscal prefork yminsky lumimies)
13:43:17 --- names: list (gridaphobe simony lynn stig johtso cansis zpconn__________ wavewave codedmart reem Bengi spicydonuts niveus rann angerman incomprehensibly cdal akl trig-ger stasku rizary sa1 nshepperd leothrix kefin LnL AntiSpamMeta nahra atk ralu slackman rntz Deadhandd falafel LeaChim Frans-Willem localhorse remy monochrom tortal kav dandan86 seccus unidan revprez catsup greeny nwf mimi_vx M-gst Moyst treehaqr Ornedan stux|RC vin-ivar alexelcu paraseba Qommand0r meck)
13:43:17 --- names: list (ethercro1 jle` DTZUZU hpd_ newsham_ jluttine kculpis kg martingale dpepsilon Eagle_Erwin Xion_ payphone Wamanuz iliastsi vrnithinkumar[m] mdupont huonw ezyang absquatulate soareschen riaqn M-kitsune MohdSKhoeini[m] Litom[m] icen[m] kilian[m] scanleft[m] rblaze kyren albel727 tmciver APic gutigen[m] kaol comboy Quintasan x-n2o jaargon noam hiptobecubic Draggor Ninja3047 ph88^ amf renzhi pita Robin_Jadoul cross eikke jinblack wonko7 echoreply slester _6a68)
13:43:17 --- names: list (phadej trosa Guest30004 cjwelborn mdarse RayNbow`TU mearnsh nekomune przembot simon mitchty Levex tolt_ amuck byorgey chirpsalot TommyC rjungemann dibblego sm padre_angolano mniip yahb zenzike_ sjl__ crlane tomasmu nullifidian centril przemkovv Sose jaj rossberg marienz amiri vaibhavsagar supki Limeth_ meinashi[m] shsnthstnhs[m] verement Benzi-Junior ambrosia Laney _ashbreeze_ qzo j0ni[m] fr33domlover cow_2001[h] esssing revprez_1nz cyberlard yrid nitrix ehkks)
13:43:17 --- names: list (swflint geekosaur liyang gareth__ tobiasBora SAL9000 fearless_man jml AlainODea billstclair OliPicard Archrover dustinm leee pedroteo[m] niklasl nemesit|znc porcow[m] duncan^ isaac__ nisstyre Forkk cschneid zymurgy lispy AustinMatherne Clint heurist spion edwardk houli ocharles rootnode SaidinWoT pygospa nh2[m] erg inr daoo[m] zeroed micro Saizan Neo zaquest caasih japesinator tzaeru dmwit chuzz[m] gargawel z0ttel jrm xa0 jfredett_ bod_ wto dysfigured avn)
13:43:17 --- names: list (jbalint jlouis kwantam Unode albertsg[m] FederalRick[m] sgal[m] grahf[m] mad[m] Makinit[m] sdrodge hvr lopex Ke joachifm dilinger numberten aweinstock tg SijmenSchoon[m] ft srhb poga spoonm Voldenet saurik unga peschkaj marens Tuplanolla Spockz felixonmars stux|RC-only TimWolla max-m grumble ernst ctag reu Pilfers iross sigmundv_ osfameron Sasasw stevendai[m] justicefries ephemera_ jol ahf Lord_of_Life tomku jw358 pfoetchen MitchellSalad_ goodboy[m] bno1)
13:43:17 --- names: list (testingriotnmat4 bencryption mk-fg odamn dostorb geppettodivacin chaosdav roninkaizen[m] TFX[m] arslanatajanov[m closures999[m] zhangjiji[m] redviking[m] LangeOortjes[m] tester668[m] dh Tritlo chriswk meinside Masaomi[m] coup catern pelegreno_ chu baetheus pharaun runawayfive scde shikhin __main__ tarcwynne__ Tehnix` Tspoon_ Deaddy Randy Jonno_FTW ephemeron kipras`away abbiya sirius[m] naviknair7[m] moonrunes[m] innaytool[m] srenatus fgaz[m] ycy[m] Dako300[m])
13:43:17 --- names: list (mark_c reactormonk[m] LucasFrancesco[m ninegua[m] rizo[m] dirb subz[m] thisLight[m] sebisebi[m] magog[m] ramirezD[m] ajtowns[m] TimWolla[m] trikl[m] mrhania[m] trevorriles[m] dlandau[m] KevinMGranger cheshircat jzl yushyin lambdabot Frankablu terrorjack dminuoso mstruebing ids1024 caw__ heyj sbauman rodarmor libbyk gnusosa vimto Willis etiago megaTherion vikram__________ tumdedum noexcept_ davean amx chaetopterus[m] solarus jared-w h30 datajerk sanitypassing)
13:43:17 --- names: list (prooftechnique sns thoughtpolice zph bigs tazjin bitonic edofic tjpeden fingerzam xplat|work peteretep wyvern xnyhps tomus jmct S11001001 mbeidler joel135 yaknyasn redcedar flux KaneTW byte512 M2tias xpoqp lukeshu mantovani Athas ycheng SuprDewd Maxdamantus dxld noteventime ehubinette Hafydd bweston92 guest69[m] glguy kmicu jounaz^__ tnks qmm hrnz cow-orker pandem Ranhir SpaceKnight RGamma Bashmetim harmaahylje sleepynate m1dnight_ logcat tv foolswood)
13:43:17 --- names: list (hdurer[m] Soft JoelMcCracken chrzyki GGMethos epta bjs Guest82765 earthy lavalike mnoonan sudom0nk[m] ftop ixian zenspider bbaren Ferdirand apeyroux salva peddie[m] omilu tessier bshelden mak` cheater _flow_ m4lvin dancek Natch fluxit riatre mceier michalrus fxk[m] jimmyrcom_ WarzoneCommand fakenullie newman[m] mikosty bartavelle mutsig kaychaks Klumben Vq grayhatter Meanirelli quicksilver sgoody[m] m00n Morgawr zenzike akfp mitch_ Rembane smyds AWizzArd ab9rf)
13:43:17 --- names: list (devpav[m] jrslepak wamaral kini ClaudiusMaximus joehillen bgamari Axman6 aidecoe klugez beaky rotty dave24 hanna DustyDingo packetbiompm[m] Stumbler adamCS Paks bxc noctux Blkt Jaxan int-e peddie fergusnoble raid SuperTux88 Intensity fall_ kloeri cjay- Drezil nopf PyroLagus jonge abbe pdgwien rom1504 Elsi orcus richi235 Flecheck[m] a_t jtcs Dykam tangled_z[m] hugogomes[m] Warrigal runde Amadiro hodapp sveit zipper vili garphy tsani Cathy anderson __name__)
13:43:17 --- names: list (anhduy Sornaensis c_wraith wadadli nurupo henrytill ramatevish benonsoftware a3f hongminh1e frontendloader fgaz [exa] destiny__ Liskni_si eagleflo Guest18532 fxrs CindyLinz jamiis_ kloplop321 implementation Burnout641_ mulk jdevlieghere Fubar^ butterthebuddha bastelfreak Someguy123 mauke froztbyte fonadius[m] g2 avatias0[m] bluepixel sqrt2 wrengr electrocat SlashLife Adeon solatis Mistv[m] acro Tharbakim geetam coup_de_shitlord dmj` dashed Squidnyan[m])
13:43:17 --- names: list (Verandetten[m] dpacbach[m] defanor nesqi hiredman aijony xxpor mt Reyu[m] jsonhigh[m] ons charlag[m] sdx23 zombs c0ff33[m] oozz[m] swalladge pikhq milli nille teqwve madknight dxtr Reisen rotaerk hpc Xe rjeli Akii cynick Ankhers amatecha barrucadu tokik mathu nullset[m] Purlox bwe paroxp dsm__ Niamkik vikraman NemesisD aniketd[m] rbocquet canta fbreitwieser[m] asenski[m] cocreature valkyr2e soncodi altooid sujeet mikedlr BytesAndCoffee changyj etXzat[m])
13:43:17 --- names: list (jameseb sdhand Taneb drdo nathyong bollu Zemyla statusbot lyxia pdxleif anishathalye iphy staffehn gilbertw1 himmAllRight[m] brixen wting amerlyq opqdonut fiddlerwoaroof Kneiva rdococ Mcpurplemuffin[m vfs gspia eyenx Rubas[m] rprospero[m] rimon[m] Bimmie[m] Vipernet1220[m] sssi1ver[m] scrypso[m] Guest1573[m] seto[m] hesiodos[m] yaspoon[m] Monad[m] akshay7777[m] boash[m] ptek[m] mk[m] zmre[m] Andry976[m] Jasonjunsu[m] joakimf95[m] prot[m] KENNYNR1[m] shekel[m])
13:43:17 --- names: list (M0xfiras[m] Guest340521[m] psan[m] M\u202e[m] guest121[m] mrhunky[m] kebertx[m] lixiang4u[m] dbramucci[m] sphalerite M-HirmeS Zarthalan[m] nimbus[m] peel[m] howsiwei[m] asm[m]1 BartGroeneveld[m adziahel[m] Niboor[m] mrgraffe[m] km42[m] gylpm[m] astronavt[m] goolord[m] nine-h[m] mrdaak[m] djquant[m] caro401 razvanc-r[m] antiless[m] ya-alex[m] pacmansyu[m] DavesTestingAcco pyrtheibarit[m] Shaunthesheep[m] polux[m] felipeac[m] mlainz[m] joncfoo[m] rcat[m])
13:43:17 --- names: list (Luguber[m] thekyriarchy__ tobim[m] saci[m] cuddly[m] SansFr[m] magnap Courage[m] unclechu adampaigge[m] WolfLightning[m] TristanBKildaire moka[m] Naughtmare[m] superobserver[m] lucnx[m] chominist[m] Akito[m] Nerka[m] beemo[m] M-herah ThousandLions[m] intheclouddan[m] laaksoan[m] Deleh[m] Barnabas[m] mtncoder[m] talesmantovani[m memoryruins[m] AX3L[m] dkellner[m] synopz[m] Michi[m] ttk2[m] softashell emme[m] okkk tommy0010[m] wisn[m] psYchotic[m] elpfen[m])
13:43:17 --- names: list (stites[m] lonokhov[m] pingfreud[m] lkh[m] NickSeagull[m] testtt55[m] spotter[m] kimchi[m] Adau[m] ItevNabdifNi[m] romanzolotarev[m toumi124[m] masaeedu[m] zukonake[m] Novitsh[m] ketanhwr phil_frontal[m] futpib[m] CryptoCalsius[m] plll[m] M-schmittlauch equalunique[m] khac[m] crapman[m] Rifa[m] idnar[m] puffnfresh etcinit[m] M-Illandan Obscurity[m] strixy[m] thekyriarchy wizzup[m] Matthew[m] ElyKar[m] dtcristo riadvargas[m] octalsrc[m] M-whoops sudoreboot[m])
13:43:17 --- names: list (Alexander_Hansen s0ra[m] SuperW[m] fib11235[m] MikasiCoyote[m] undu[m] Nuva[m] kritzcreek hpd_m Soif[m] TylerCecil[m] drasich[m] M-kevinliao Aidan[m] lysgaard[m] angelbeats[m] ollieh M-BostonEnginerd WilliamHamilton herzmeister[m] davidar hendrik[m] cutie davidar_ MatrixTraveler[m aspiwack[m] aer[m] spacekitteh[m] unlmtd bb010g berton turt2live tfc[m] jmnoz pellegrino M-berdario trevortknguyen[m bennofs[m] jyp[m] unknownln rexor[m] dt343gs[m] grandy____ stass)
13:43:17 --- names: list (brolin_empey acfoltzer_ kaffepanna MagneticDuck niluje flebron ryanbooker Meow-J Kamuela strmpnk jzelinskie etrepum milessabin Cir0X pchiusano JSharp micmus stephe nshepperd_ liste happy0 worch Zoddo pmn l_zzie ongy ventonegro tekacs heath sleblanc bmeynell procgen tjbp cic joeyh pikajude pyrtsa michi7x7 rofer zmanian ccase Arguggi Deewiant tsahyt vimalloc cfoch-al1 MalfaitRobin_ greymalkin swhalen janne pasukon aminb navilan cesardv luigy gareth_ jlewis asm89)
13:43:17 --- names: list (danzimm rootmos hsiktas tolt jokester wladz twk- StianL xacktm SiCC akemot markhuge guios Gabemo kubrat ljhms heinrich5991 statusfailed cpallares ByronJohnson TakumoKatekari edran Squarism gesindel aaron7 oberste1n exferenceBot scav intelux_ Bigcheese idupree2 bjobjo PotatoGim mpickering bgyss feltnerm ryantm noobst mystfox aib integral vodkaInferno dan64 nonzen wtw fairfieldt HalfEatenPie juri_ syamaoka dschoepe fnurglewitz agrif Zowlyfon Chousuke malthe)
13:43:17 --- names: list (fredsir edwtjo Fylwind bbee jix matthavener codebje RevJohnnyHealey scopedTV ocramius lokydor pleiosaur nerteren burp aatxe oherrala relrod mmaruseacph2 NocnaShada stefan- sbrg hegge_ Igloo_ wayne Profpatsch reynir jackhill admwrd ircbrowse Fuuzetsu dredozubov madsj julmac Xandaros tdammers trcm magnuson tippenein bus000 Logio ynyounuo Solarion Geekingfrog lukexi koala_man bananagram da-x hexagoxel monty tctara zerokarmaleft orzo dqd lpsmith Eliel phaazon e)
13:43:17 --- names: list (TyOverby__ runeks si14 fuziontech RazorX reinh1 discrttm lieven Netwolf Twey Jinxit bind nshepperd1 noplamodo majoh_ andjjj23 brennie geal abra0 niko Boreeas oleks tek0 hsyl20 arkeet bengt_ ec2-user_ zomg raek EvanR Nikotiini platz alek skeuchel cjh` Desoxy brent80_plow TallerGhostWalt hjklhjklhjkl emmflo absence gabiruh Oipo yarou Guest60956 Biohazard DDR eL_Bart0 MasseR qz zachary12 Jello_Raptor dyreshark blackdog Ring0` suzu coeus betawaffle d3lxa nikolah)
13:43:17 --- names: list (shapr kfish Tristan-Speccy nilOps mgaare wz1000 croben bvad exio4 reptar_ PHO \u so SolitaryCypher armlesshobo oldsnakey SolarAquarion @ChanServ carter zgrepc ReinH carc ij dsal georgew cdornan_ elvishjerricco iravid Argorok gothos mbrcknl_ mindtree cstrahan gsingh93 noxd frew kgadek sdemos bytesighs customminer metalrain darthThorik joedevivo shans_)
13:56:06 <Ero> maerwald: i found that interesting too. It particularly piqued my interest because i recall that RMS worked on lisp machines when they were about
13:57:37 <maerwald> rms also likes jellyfish in his salad
14:00:28 <Tuplanolla> I expect us to be stuck in this hardware and operating system local minimum for a while.
14:10:56 <woodson> what are the package usually used to serialize json to binary?
14:12:14 <woodson> im using Data.Aeson and Data.Binary however its always returning Nothing
14:15:21 <phadej> woodson: to binary?
14:15:31 <dsal> calibre doesn't let me have two variants with the same format.  That's kind of lame.
14:15:43 <dsal> oops.  I'm complaining about the haskell book in the wrong haskell channel.
14:16:22 <erisco> what is the future OS, Tuplanolla?
14:16:30 <phadej> woodson: do you see something like:
14:16:31 <phadej> Prelude Data.Aeson> decode (encode "foobar") :: Maybe Int
14:16:31 <phadej> Nothing
14:16:31 <phadej> Prelude Data.Aeson> decode (encode "foobar") :: Maybe String
14:16:33 <phadej> Just "foobar"
14:16:46 <Tuplanolla> You're asking the wrong person, erisco.
14:16:52 <erisco> does it have a unified desktop experience across PC, tablet, smart phone, and wristwatch?
14:17:04 <int-e> erisco: uh I hope not
14:17:13 <Tuplanolla> You're asking the wrong questions too, erisco.
14:18:36 <woodson> phadej: Im using (Data.Binary.encode . Data.Aeson.encode ) to serialize it
14:18:48 <erisco> I was thinking maybe they should have it boot straight to Facebook
14:19:06 <erisco> and you can extend it by writing Facebook apps
14:19:09 <woodson> phadej: but when it comes to deserializing it i just get Nothing back
14:19:20 <phadej> woodson: that doesn't make sense
14:19:33 <phadej> Data.binaray.encode :: ByteString -> ByteString = id
14:19:34 <erisco> IPC can be done through Twitter
14:20:08 <erisco> "social media integration" gets a big check mark… nearly funded!
14:20:40 <phadej> :t Data.Aeson.encode
14:20:42 <lambdabot> aeson-1.2.1.0:Data.Aeson.Types.ToJSON.ToJSON a => a -> BSLC.ByteString
14:20:54 <phadej> :t Data.Binary.encode
14:20:55 <lambdabot> binary-0.8.5.1:Data.Binary.Class.Binary a => a -> BSLC.ByteString
14:21:30 <phadej> woodson: I don't understand what you try to do, BSON? https://en.wikipedia.org/wiki/BSON
14:21:48 <woodson> phadej: yes BSON actually
14:24:28 <phadej> woodson: there's https://hackage.haskell.org/package/aeson-bson and http://hackage.haskell.org/package/bson
14:24:38 <phadej> but seems that former doesn't support newest aeson's
14:24:56 <phadej> (I don't think upgrading them is hard, but needs to be done)
14:28:22 <woodson> phadej: Thank you
14:37:35 <erisco> wee bit surprised there is not a splice function for Seq
15:02:52 <lambdamu> Hi, when I unsafeCoerce# an unpinned ByteArray# to an Addr# and pass it of to an unsafe foreign call, there is no guarantee that the GC won't move the ByteArray# between the coercion and the call, thereby invalidating the pointer right?
15:03:52 <EvanR> isnt a coercion not really taking any time at runtime
15:04:47 <lambdamu> EvanR: Hm ok that would be a possible angle, but I'd like to add an offset to the pointer
15:05:07 <EvanR> that takes time
15:06:14 <EvanR> i think the gc can only run at certain points? and doing an offset to an unboxed Addr# might not have those points around it ?
15:06:36 <lambdamu> EvanR: That would be great, is there any reference of that?
15:07:43 <EvanR> hmm http://ezyang.com/jfp-ghc-rts-draft.pdf
15:09:03 <EvanR> might be better to rethink it
15:09:07 <int-e> hmm anything like that seems to be banking on the compiler not doing stupid thing... like let-binding the unsafeCoerce# result and floating it out.
15:12:15 <lambdamu> int-e: True, that has to be taken care of, too
15:12:46 <EvanR> this is why foreign stuff should use pinned byte arrays
15:13:28 <lambdamu> EvanR: Yes that is certainly easier
15:13:56 <lambdamu> EvanR: I skimmed the paper, did you have any specific part in mind or just as a general reference?
15:14:06 <EvanR> i didnt see anything useful in there
15:14:11 <EvanR> red herring
15:15:41 <lambdamu> It would be nice if we have some way to specify a critical region where the GC shouldn't run maybe with the constraint that you can't allocate on the heap
15:15:53 <lambdamu> in that region
15:16:33 <lambdamu> This is basically the deal we get with unsafe foreign calls so I wonder how hard that would be to expose as a construct in Haskell
15:18:04 <EvanR> if you cant/dont allocate in some code (as shown in core) then the gc doesnt run, as i understand it
15:18:21 <geekosaur> hard, sadly. there's a pervasive assumption that allocating from the nursery is okay. (but now I wonder if a modified form of that is possible: no large allocations and provide your own (expansion for the?) nursery, to avoid having to gc it)
15:19:12 <geekosaur> also comes the question of what to do if, despite your assurances, the contract is violated
15:20:07 <lambdamu> EvanR: That means as long as compute with primitive types I'd be ok?
15:20:24 <EvanR> i doubt you get that guarantee
15:21:55 <geekosaur> you have to guarantee not only primitive types but also fusion
15:22:22 <geekosaur> otherwise a temporary value for a primitive type might be allocated
15:22:54 <geekosaur> which is why I'm wondering if changing it to nursery-only would be 'good enough'; allocations themselves are fast, unless the nursery fills which triggers gc
15:23:07 <geekosaur> and allows more flexibility elsewhere
15:23:50 * geekosaur should look at compact regions implementation; maybe it provides a path?
15:24:40 <lambdamu> geekosaur: If I'm just doing arithmetic with primitive Int#, Addr#, Word# etc. Do you mean code is generated that allocates on the same heap where garbage collected boxed values live?
15:25:02 <int-e> EvanR: you can pass ByteArray# values to foreign functions, btw. I'd need to experiment, but I hope that passes a pointer to the bytearray contents, not the header on the heap. This solves the potential floating out problem that unsafeCoerce# has. I'd then recommend passing the offset to the foreign function and adding the offset there rather than trying to do that on the Haskell side.
15:25:32 <geekosaur> it could produce temporaries, yes. forcing it all to happen in registers is extremely difficult, and the next level out requires reuse of existing allocatef values which is essentially fusion
15:25:53 <int-e> EvanR: (this, passing ByteArray# to foreign functions, is used by integer-gmp.)
15:25:57 <lambdamu> geekosaur: Yes but I would have thought the allocation happens on some kind of stack unrelated to the GC
15:26:16 <geekosaur> there is no call stack, so nowhere to do that.
15:26:31 <geekosaur> pattern match stack is a different matter, and one of those differences is you can't reuse it for temporaries
15:26:33 <lambdamu> geekosaur: Hm ok, I guess the RTS is a black box to me after all
15:26:51 <int-e> (I suspect integer-gmp performance would suffer quite a bit if it had to use pinned bytearrays.)
15:27:06 <geekosaur> the C stack *can* be used for some things... inside of primitives. Not when combining them generally
15:27:45 <EvanR> any numbers for difference in performance between integer-gmp and integer-simple
15:28:05 <geekosaur> but really, gc is what you want to prevent. preventing allocation at all is a really big hammer there; allocations are only a problem if they would overflow the nursery
15:28:47 <geekosaur> so providing a way to avoid that overflow seems a better way to avoid gc than trying to prevent allocation period
15:29:17 <EvanR> a primitive bracket where, if the code is statically known to allocate less than is in the nursery, do it. otherwise, gc first, then do it?
15:29:55 <geekosaur> that could work too. still need to watch out for large allocations (see +RTS -AL) but you would anyway; it's not clear to me where those are allocated or how they affect gc
15:30:47 <EvanR> (then, just gc first always could do it?)
15:31:06 <lambdamu> int-e: Passing the ByteArray# directly and doing the arithmetic on the foreign side is possible and was the solution I came up with, but it complicates what I'm trying to do quite a bit
15:31:09 <geekosaur> possibly also combine with a -W option (or maybe some other way), off by default, where it could tell you the nursery size needed for a region instead of enforcing
15:31:21 <geekosaur> (esp. since you need this at compile time but nursery size is *runtime*)
15:35:37 <lambdamu> Is there a way to query the nursery allocation at runtime? RTSStats doesn't seem to have the information
15:38:01 <geekosaur> the allocation is justa  pointer inside of a runtime. allocation is: save value of pointer, add size of allocation, return old pointer
15:38:21 <geekosaur> *inside of the runtime
15:39:10 <geekosaur> so figuring the nursery allocation information you need to know is just knowing the pointer to the start of the nursery and its size. the latter at least is both specifiable and retrievable
15:39:27 <int-e> EvanR: hmm, http://www.mega-nerd.com/haskell-big-integer-experiment/ has some integer library benchmarks; the last one that includes integer-simple seems to be for ghc-7.10 though
15:40:09 <geekosaur> and the current nursery pointer
15:40:33 <geekosaur> that can probably be accessed but you either need to do Ptr swizzling or modify theruntime to expose it to Haskell (same for nursery base_
15:40:51 <geekosaur> but neither one of those is *difficult*. just reallyUnsafe
15:42:53 <lambdamu> geekosaur: modifying the runtime is out of question, but I assume there is some kind of global RTS state at a static pointer? I could go from there, or what do you have in mind as an entry point?
15:44:14 <felix1> hey
15:44:21 <geekosaur> that was what I was referring to by Ptr swizzling
15:44:47 <felix1> I am looking for a function of type `(Maybe a, Maybe b) -> Maybe (a, b)`, hoogle reports nothing
15:45:03 <lambdamu> geekosaur: Alright then we are on the same page here :D
15:45:04 <geekosaur> I know it's there, and you could access it directly by abusing Foreign.Ptr. I don;t know off the top of my head where it is, but that shouldn't be hard to determine by inspecting the RTS (I hope)
15:45:07 <hpc> :t liftA2 (,)
15:45:08 <lambdabot> Applicative f => f a -> f b -> f (a, b)
15:45:15 <hpc> :t uncurry (liftA2 (,))
15:45:17 <lambdabot> Applicative f => (f a, f b) -> f (a, b)
15:45:22 <hpc> felix1: ^
15:45:25 <felix1> like `sequenceA` for tuples
15:45:35 <felix1> oh wow :D
15:45:54 <hpc> there isn't really anything that will let you generically "traverse" every member of a tuple
15:46:19 <hpc> each element is a different type (potentially)
15:46:44 <felix1> hpc: bit of a bummer. the purescript project managed to achieve this by always expecting 2 members and then nesting the right element
15:47:00 <felix1> looks like there's room sth like this in haskell land
15:47:08 <felix1> would be awesome to have tuples be bifunctors etc
15:47:31 <hpc> tuples are bifunctors
15:47:36 <hpc> but then you need trifunctor and so forth
15:48:04 <lambdamu> geekosaur: I'd say Capability **capabilities = NULL; in rts/Capability.c looks promising
15:48:27 <hpc> i don't know how purescript infers tuple associativity like that, but i expect it comes with the (,) type not being first-class
15:48:35 <geekosaur> not for gc directly although there are separate nursery pointers per capability (but beware of +RTS -n)
15:48:38 <johnw> hpc: one could say that tuple type constructors fulfill the object mapping definition of a bifunctor; you need an instance of Bifunctor for them to fully be bifunctors
15:48:58 <hpc> instance Bifunctor (,) where
15:49:00 <hpc>     bimap f g ~(a, b) = (f a, g b)
15:49:02 <johnw> yeah
15:49:02 <hpc> :P
15:49:09 <hexagoxel> instance BiFunctor (HList r) => BiFunctor (HList (a ': r)) where ..
15:49:37 <felix1> hpc: tuple is defined as `Tuple a b = Tuple a b`, no special language support
15:49:52 <hexagoxel> that.. does not make much sense, does it
15:50:29 <hpc> felix1: how does it automatically munge between Tuple a (Tuple b c) and Tuple (Tuple a b) c? can it do that for arbitrary types if you declare them associative in some way?
15:51:17 <felix1> hpc: https://github.com/purescript/purescript-tuples/blob/master/src/Data/Tuple/Nested.purs#L36
15:51:24 <hpc> (ideally you could just say "this type is associative" and you're off to the races, but maybe it has a preferred leaning?)
15:52:05 <hpc> ah, so they just always learn right
15:52:19 <felix1> i am not sure i follow, the `/\` operator simply has an associativity like any other operator
15:52:23 <felix1> yes
15:52:35 <felix1> haven't had any issues with that in practice whatsoever
15:52:59 <hpc> ah, i think i misread your initial line
15:53:26 <hpc> i thought you meant that purescript could figure out which direction you were using the tuple in, and change (a, (b, c)) into ((a, b), c)
15:53:30 <hpc> that makes much more sense
15:53:43 <EvanR> int-e: wow this new lib seems to be competing with gmp
15:54:09 <hpc> i remember thinking about something like this years ago, and reaching the conclusion that there are situations where you would need to turn a tuple inside-out in order for it to behave conveniently
15:54:14 <hpc> but i don't remember how i arrived at that
15:54:24 <EvanR> whatever it is
15:56:23 <erisco> felix1, this is definable, if you want to decide on an associativity for your tuples
15:57:00 <erisco> presuming we're talking about 2-tuples here
15:57:55 <hexagoxel> and now i wonder if you can define HList-based classes that act like n-functor on HLists.
16:00:36 <JappleAck> ed. kmett is on the stream https://www.youtube.com/watch?v=090hIEiUoE0
16:01:30 <hpc> hexagoxel: i wonder if HList would be better if it was something like HList i ts
16:01:50 <hpc> hexagoxel: i would be the "interface", just as class constraints
16:02:02 <hpc> and ts would be a type list where everything matches against i
16:02:32 <hpc> and then you could do traversals like that, but only if it works generically on things that are i
16:04:03 <hexagoxel> hpc: for other stuff, baking in the dicts into the datastructure is discouraged though.
16:04:17 <hpc> ah, fair
16:04:43 <hpc> maybe this is a case where the answer is "don't do that, it usually doesn't make sense"
16:05:48 <erisco> huh, I thought there was a more popular library for interval maps http://hackage.haskell.org/package/IntervalMap
16:05:49 <hexagoxel> and you can write the AllConstrained type family :: (* -> Constraint) -> [*] -> Constraint
16:49:34 <tommd> I'm looking for a collection of higher kinded classes such as `class Functor2 (t :: (* -> *) -> *) where` (and Foldable2, and Traversable2).  I'm sure this must exist, right?
16:50:13 * tommd will look at this screen in a bit
17:09:00 <Axman6> using GHC Generics, if I have the name of a field (in the type system) and a data type which has a Generic instance, can I find the type of that field?
17:09:52 <Axman6> it looks like the types of the fields disappear (as they're all wrapped with a Rec0, which expands to that type's Rep)
17:10:34 <camilo_cs> Hi
17:11:34 <Axman6> JappleAck: thanks for the link btw, this is much beter than the Scala World versiion of the talk (Ed's always best when unconstrained by time)
17:12:07 <Axman6> camilo_cs: hello!
17:12:40 <pacak> Axman6: K1?
17:13:23 <pacak> Axman6: newtype K1 i c p = K1 { unK1 :: c }    -- a container for a c
17:14:23 <Axman6> hmm, that could do it. let's see
17:20:51 <Axman6> I've come up with this horrible idea using generics, bthis looks tedious to traverse...
17:22:52 <Axman6> but this*
17:25:52 <camilo_cs> Does anyone have a tutorial for learn programming concurrent and parallel with haskell? :O
17:29:47 <MarcelineVQ> camilo_cs: http://chimera.labs.oreilly.com/books/1230000000929/index.html
17:30:24 <camilo_cs> MarcelineVQ: thank you!
17:31:22 <nash_> hello #haskell. I'm working with conduit and when connecting my sources/conduits/sinks, I ran into this error: http://lpaste.net/359353
17:33:14 <nash_> can someone advice if I have to change the "CsvParseError" into a "GHC.IO.Exception.IOException" myself, or is there a better "lifting" solution that allows multiple kinds of errors to co-exist
17:35:04 <kvda> what's a good haskell to begin with?
17:35:14 <Axman6> 2010
17:35:16 <peddie> kvda: Haskell 2010
17:35:22 * peddie high-fives Axman6
17:35:30 <Axman6> ha, was literally about to write that
17:36:31 <pacak> Axman6: Can you share your horrible idea?
17:39:29 <Axman6> I was looking at https://turingjump.com/blog/bookkeeper/ because one of our teams has run into an issue where they have a lot of types which have some fields in common (like an ID, a status, etc), and were getting a bit sick of manually writing the HasFoo s t a b instances for the lenses to access them, so we were looking at making somthing based around overloaded labels. Then I had the thought that we could actually avoid the need for the cl
17:39:29 <Axman6> asses all together by using generics to turn #fooField into a lens which accesses the field named fooField in any record
17:41:27 <Axman6> so given data MyRec a = MT { foo :: Int, bar :: Maybe String, other :: a } deriving (Show, Eq, Generic) you could write #bar to produce Lens (MyRec a) (MyRec a) (Maybe String) (Maybe String)
17:42:00 <Axman6> then you get adhoc lenses for all Generic record types
17:42:23 <Axman6> and I think you might even avoid the ambiguity you'd get when using classes
17:42:44 <Axman6> s/you'd get/you might get in some circumstaances/
17:46:10 <kvda> peddie Axman6 ahh that sweet sweet snobbery
17:46:37 <tommd> kvda: I think it was just to point out your question is a bit vague.
17:46:56 <tommd> What is "a haskell" and by what measure can one of them be "best"?
17:47:01 <kvda> ah lol, i see it now "haskell book"*
17:47:09 <tommd> Ohhhh
17:47:19 <kvda> haha pardon i typed that out too fast
17:47:22 <tommd> I really like Simon Thompson's 'Craft of Functional Programming'
17:47:29 <kvda> i thought i was getting the spec thrown at me
17:47:31 <athan> Hi everyone - can anyone here reccommend an up-to-date guide on C-FFI in haskell? The Real World Haskell book seems out of date - I don't think `#include ...` is valid in hsc anymore.
17:48:22 <tommd> athan: If you are starting from zero I'd just look at simple things for examples (and, certainly, the wikibooks).
17:48:37 <kvda> thanks tommd ! i'll check it out
17:48:42 <tommd> Simple things include hashable, boomfilters... mabye even Saltine since the bindings themselves are simple.
17:49:45 <athan> tommd: awesome, thank you!
17:50:49 <peddie> kvda: Haskell Programming From First Principles seems pretty popular, gets good reviews  haskellbook.com
17:50:56 <glguy> athan: Why don't you think #include is valid in .hsc anymore?
17:54:23 <glguy> (because it's valid) https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/utils.html#writing-haskell-interfaces-to-c-code-hsc2hs if you want to read more
17:54:27 <athan> glguy: oop... comments on RWH :D
17:54:33 <athan> shoot, thanks glguy 
17:56:58 <tommd> glguy: Higher up in this chat I asked about the existance of `Traversable2` etc, as in `class T2 (t :: (* -> *) -> *)`.  I figure this must exist somewhere.
17:57:09 <tommd> Have you seen it around?
17:57:12 <kvda> peddie thank you
17:57:23 <peddie> kvda: have fun :)
18:03:04 <glguy> tommd: I've seen versions of it tossed around in the context of higher kinded lens-likes but I don't know of any standard libraries providing that
18:04:47 <geekosaur> #include is valid, just not very useful since FFI is no longer compiled via C
18:05:02 <glguy> hsc goes via C
18:05:04 <geekosaur> ...but you still need it to get maifest conts and the like
18:05:12 <geekosaur> *manifest constants
18:05:27 <glguy> similarly for CApiFFi
18:19:17 <tommd> OK, thanks
18:25:59 <Tehnix> Does anyone know any good resources on GHCs runtime? Like, if you wanted to play around with extending it etc
18:26:42 <geekosaur> https://ghc.haskell.org/trac/ghc/wiki/Commentary/Rts ?
18:27:11 <JavaSucksMan> I got a ghci question.
18:27:13 <MarcelineVQ> the ghc source itself it fairly well documented also
18:27:32 <Tehnix> geekosaur: hmm, was perhaps thinking more of blog posts that document the dive into it, but that's a good starting point nonetheless :slightly_smiling_face:
18:27:39 <dmj`> JavaSucksMan: yes
18:28:25 <geekosaur> on the page above that one are links to some reading lists. o promises they cover anything useful to you though. and, uh, indexing blog pages is whack-a-mole >.>
18:29:03 <geekosaur> JavaSucksMan, it usually works better to actually ask the question
18:29:43 <JavaSucksMan> sorry.. I'm thinking how best to phrase it.
18:31:01 <JavaSucksMan> ghci :cmd takes an IO String and interprets according to the ghci interpreter's language. I'm looking to somehow get the ghci's interpreter output into a vaiable... sorta like the variable it, but ghci's output,
18:31:12 <Tehnix> geekosaur: I guess a good way for blog posts would be to provide an additional link to it on <http://archive.org|archive.org>
18:40:22 <JavaSucksMan> Did my request at least make sense to anybody?
18:40:56 <JuanDaugherty> a lil bit
18:42:19 <geekosaur> made sense but I think that's still an open question
18:43:16 <JavaSucksMan> so, imagine the magic variable was cmdIt, and the associated command was :cmdit
18:43:45 <JavaSucksMan> :cmdit return ":help"
18:44:48 <JavaSucksMan> head $ lines cmdIt  ==>  Commands available from the prompt:"
18:46:25 <JavaSucksMan> I suppose it would be mind-bendingly weird to run ghci from within ghci to expose the command interpreter's internals
18:58:03 <mnoonan_> so I’m digging into the gory details of why my test started failing between 8.0.2 and 8.2.1, and in the .dump-simpl file for 8.0.2 I see this:
18:58:27 <mnoonan_>  case {__pkg_ccall_GC base-4.9.1.0 performMajorGC State# RealWorld -> (# State# RealWorld #)}_a38k
18:58:43 <mnoonan_> while in 8.2.1, it looks like this:
18:58:52 <mnoonan_> case {__pkg_ccall_GC base-4.10.0.0 State# RealWorld -> (# State# RealWorld #)}_a3OP
18:59:47 <mnoonan_> I’m assuming the 8.0.2 line is the invocation of an FFI call (and I guess _GC means it is hitting an FFI call that can affect garbage collection?).. but then where is the “performMajorGC” in the 8.2.1 version?
19:01:34 <Axman6> performMajorGC is provided in System.Mem
19:03:20 <geekosaur> I would suspect looking at that that there is nol onger a distinction so it doesn;t pass the type of gc any more
19:03:24 <Tehnix> JavaSucksMan: I suspect it's not exactly what you're looking for, but you can access the result of the command you just ran using `it`. That is, `getLine` returns `IO String`, after running it, you have a `String`, which you can test with `:t it`
19:03:45 <geekosaur> Tehnix, they mentioned that one. but it doesn;t get the result of a :cmd
19:03:59 <geekosaur> and people have asked about that one before but I don;t think anyone has figured out an answer
19:04:16 <mnoonan_> geekosaur: I don’t follow, is the format not “__pkg_ccall* package-name function-name” ?
19:04:46 <geekosaur> mnoonan, my point is it's an internal, they can change the way it works how they see fit and they may well have done so
19:04:54 <geekosaur> especially since this is simplifier level and not the generated code
19:05:20 <Tehnix> geekosaur: Ahh, I glossed over the `:cmd` part &lt;.&lt;
19:05:30 <geekosaur> so my guess is that 8.2.1 no longer distinguishes, so they don't include the performMajorGC any more
19:05:57 <mnoonan_> the original code explicitly calls performGC though (which is defined as perfomMajorGC)
19:06:12 <oodani> Hi, I'm using Text.Hamlet (shakespeare 2.0.14) and Text.Blaze.Html (blaze-html 0.9.0.1) to generate web pages, and then, rendering the result with Text.Blaze.Renderer.Pretty (blaze-markup 0.8.0.0) - and it's… not pretty? There's still no indentation in the output HTML, and there seems to be a newline inserted before and after every interpolated value. Am I doing something wrong, or does Text.Blaze.Renderer.Pretty just not work in the current version of
19:06:12 <oodani>  Blaze, or what?
19:11:05 <geekosaur> mnoonan, yes, but the call itself says GC. the qyestion is, what other uses of __pkg_ccall_GC might have existed and whether they do any more, or work differently; in that case, the performMajorGC would be redundant (in effect __pkg_ccall_GC *is* performMajorGC)
19:11:46 <mnoonan_> ah, I see what you are saying.
19:13:32 <geekosaur> of course it's also possible it's a bug somewhere, possibly including the prettyprinter since what ghc shows there is not the actual internal structure in question
19:13:51 <geekosaur> (in the map/territory sense)
19:13:54 <Tehnix> JavaSucksMan: Trying again, one direction I would investigate is utilizing the pretty printer to capture the output, since it has to go through that first. For example, <https://stackoverflow.com/a/14610920/701940> shows how to log the output
19:14:04 <mnoonan_> it looks like the generated Cmm in both cases still has a call to performMajorGC, so maybe that was a red herring (thought the two calls are not quite the same)
19:14:32 <Tehnix> You could then either log it to a file and have a command that reads that file, or I suppose do some mutable global variable magic
19:30:18 <Lokathor> I made a multiparam type class :S
19:30:20 <Lokathor> spooky
19:30:26 <Lokathor> perfect for this month
19:31:43 <Lokathor> class ParamRandom p a where nextP :: RNG g => p -> g -> (a, g)
19:32:09 <Lokathor> it's kinda an abuse of the typeclass system, if you're the kind of person who belives in laws and all that
19:32:21 <Axman6> missed opportunity to call it ParRandom
19:32:28 <Lokathor> i can call it anything
19:32:36 <Lokathor> many of the names are up in the air
19:33:01 <Lokathor> Axman6, how do you feel about the random package?
19:33:03 <Axman6> performMajorGC is provided in System.Mem(or Paramdom)
19:33:10 <Axman6> uh
19:33:19 <Axman6> not sure how that first message got in there...
19:33:40 <Axman6> eh, I have no strong thoughts on it. I don't use randomness very often
19:35:44 <Lokathor> you're not my audience :(
19:36:15 <Lokathor> https://github.com/Lokathor/pseudorandom-hs i want folks to look at my WIP and give me strong thoughts on it
19:37:08 <|{ame`> hello, I am trying to change the behavior of a data
19:37:18 <Lokathor> what data?
19:37:35 <|{ame`> concretely, I have ResizableTall as defined here https://hackage.haskell.org/package/xmonad-contrib-0.13/docs/src/XMonad-Layout-ResizableTile.html
19:37:52 <|{ame`> and I did a newtype ResettableTall a = ResettableTall{
19:37:52 <|{ame`>                         l ::ResizableTall a
19:37:52 <|{ame`>                        }
19:38:10 <|{ame`> planning to do instance LayoutClass ResettableTall a where ...
19:39:05 <|{ame`> but but I get Illegal instance declaration for `LayoutClass ResettableTall a'
19:39:05 <|{ame`>        (All instance types must be of the form (T a1 ... an)
19:39:05 <|{ame`> when I omit the parenthesis around resettable
19:39:05 <|{ame`> and The first argument of `LayoutClass' should have kind `* -> *'
19:39:08 <|{ame`>          when I put them
19:39:29 <|{ame`> and if I omit a,  Expecting one more argument to `LayoutClass ResettableTall'
19:40:23 <Axman6> looks like you need to enable MultiParamTypeclasses
19:40:39 <Axman6> which the rest of that error would have told you to do ;)
19:41:10 <|{ame`> In practice, all I want to change only the handleMesg function without modifying the original source
19:41:39 <|{ame`> is there a smarter way to do then the approach I am taking? (using a newtype)
19:42:13 <|{ame`> *In practice, all I want to do is to change only
19:42:31 <Welkin> |{ame`: how do you pronounce your nickname?
19:42:53 <Lokathor> "ka-me", i'd guess?
19:43:02 <|{ame`> yes
19:43:06 <Axman6> not really, but you can save some typing by using the type safe coercions stuff - all your instance functions would look like doLayout = coerce doLayout
19:43:14 <Lokathor> Welkin, how do /you/ feel about the random package?
19:43:44 <|{ame`> ka-me, as in ca[lifornia] me[dicine]
19:43:48 <Welkin> Lokathor: haven't used it much except to create a dice roller
19:44:10 <Lokathor> ah ha, what if i told you that all the dice is was rolling for you were giving you NON-UNIFORM RESULTS! dun dun dun!
19:44:21 <Welkin> yeah, that is to be expected
19:44:28 <Welkin> no random function is truly random
19:44:39 <Lokathor> :( that is rather false
19:44:39 <Welkin> there is some web api that is though
19:44:51 <Lokathor> they are not truly random, but many are at least uniform
19:44:52 <Welkin> it uses environmental measurements like temperature and other things
19:45:05 <Welkin> lol Lokathor 
19:45:08 <Welkin> rather false?
19:45:16 <Welkin> not just false?
19:45:26 <Lokathor> there was more than one clause you said, so it was a percentage
19:45:36 <Welkin> like a quantum boolean
19:45:47 <Lokathor> a good PRNG is uniform, and a good function for randing into a range will also give uniform results
19:46:01 <Welkin> where is there a better random function?
19:46:04 <Welkin> another package?
19:46:31 <Lokathor> yes the StdGen is not particularly good, in fact it has an output range of a little less than 31 bits for some odd reason
19:46:39 <Welkin> I know you wrote a rouge-like tutorial
19:46:40 <Lokathor> most RNGs are uniform across 32 bits or 64 bits
19:46:45 <Welkin> did you use StdGen?
19:46:53 <Lokathor> no i used a thing called PCGen
19:47:19 <fDev2179> Quick typeclass question: http://lpaste.net/359357.  I can't figure out why I'm getting the error.  Does the typeclass need another parameter?
19:47:22 <Lokathor> it's ~2x-40x faster than StdGen, as well as being better in other ways
19:47:34 <Welkin> what package is that from?
19:48:14 <Welkin> I started writing a rouge-like in purescript and haskell, but didn't get to the parts yet that require randomness
19:48:31 <Lokathor> fDev2179, your problem makes sense when you put in Line in the signature of your methods: Line s a -> Int
19:48:34 <Clint> @hackage pcgen
19:48:35 <lambdabot> http://hackage.haskell.org/package/pcgen
19:48:54 <Lokathor> ah ha, yes, i did put it on hackage
19:48:56 <Lokathor> i forgot
19:49:01 <Hafydd> A "rouge-like" is a shade of red such as crimson.
19:49:34 <Welkin> thanks Clint 
19:49:45 <Welkin> I'll try using PCGen instead
19:50:03 <Lokathor> oh no! but it's not sufficient actaully or you'll still take some needless speed hits
19:50:12 <Lokathor> that's what my pesudorandom package is hopefully gonna fix
19:50:25 <Lokathor> but it needs more content before i can call it worthy of even a 0.1 on hackage 
19:50:30 <Welkin> okay
19:50:38 <Welkin> I starred it on github anyway so I can come back to it
19:50:52 <fDev2179> Can you explain what you mean when you say my problem makes sense when I put in Line in the signature, Lokathor?  I don't follow.
19:51:07 <Hijiri> a true roguelike would start with just the randart generator and then have the game built on top of that
19:51:11 <Welkin> lol, it has a rating of "3 lambdas" on hackage
19:51:18 <Welkin> I don't see an upvote button anymore though
19:51:28 <Welkin> I think jle` was the only one who upvoted packages
19:51:37 <Welkin> not sure what the 3 lambdas mean
19:51:57 <Welkin> hello Hijiri 
19:52:21 <Lokathor> fDev2179, so the "kind" stuff is saying that line expects 2 other types to become a full type, basically, but one of them must itself be a higher kinded type
19:52:28 <Lokathor> and you're not building it up that way
19:52:34 <Lokathor> it's hard to explain a kind error :/
19:53:05 <fDev2179> I'm definitely a beginner, but it is hard for me to understand this error. 
19:53:23 <Welkin> fDev2179: do you know what "kinds" are?
19:53:34 <fDev2179> Yes.  I spent a few hours reading about them last night.
19:54:13 <fDev2179> If I'm being honest, I should say I sort of understand them.
19:54:27 <Welkin> they are the types of types
19:54:36 <fDev2179> Right.
19:55:31 <fDev2179> Correct me if I'm wrong, but I look at something like Line s a as a type which has type parameters.
19:55:35 <Welkin> :k Either
19:55:38 <lambdabot> * -> * -> *
19:55:54 <Welkin> :k Either String Int
19:55:56 <lambdabot> *
19:56:24 <Welkin> I think the * is more confusing than it should be
19:56:36 <fDev2179> It is being "applied" to concrete types, right?
19:56:38 <Welkin> in Idris and Purescript the * is named `Type`
19:57:04 <Welkin> so, Either is a function that takes two Types and produces a Type
19:57:15 <fDev2179> Right.  I follow that much.
19:59:50 <Welkin> I haven't worked much with this kind of thing yet either
20:00:10 <Welkin> but it looksl ike your error is saying that the `s` in `Line s a` should have kind * -> *
20:00:35 <fDev2179> The kind of s should be *.  The kind of Node should be * -> *, I believe.
20:02:36 <fDev2179> I take that back, s should be of kind * -> *.  I'm expecting types that look like the following: data TensorProduct  b = TensorProduct  b Int deriving (Show,Eq)
20:03:52 <fDev2179> Lokathor, you are right that one of the types is a higher kinded type.  s is.
20:05:18 <fDev2179> What do I have to change to make it so that is a higher kinded type?  Something like this: data Line (s b) a?
20:10:44 <fDev2179> In my mind, by the time I create something of type Line, the kind of s should be *, because its type parameter has already been set.  
20:11:01 <iqubic> What issue are we working on.
20:11:52 <fDev2179> This is my question: http://lpaste.net/359357.  Not sure if that's what you're refering to, iqubic.  Issues with kinds.
20:13:13 <fDev2179> I believe I see the issue, thanks to Welkin and Lokathor.  However, I'm not sure how to fix it.
20:13:55 <fDev2179> s is a "higher kinded" type.
20:14:19 <fDev2179> Problem is I'm not sure how to specify this.
20:14:54 <ludat> Hi everyone, I'm having trouble installing intero in archlinux, is this a known issue or am I doing something wrong (https://pastebin.com/gaXjTDMv paste of the error)
20:15:04 <iqubic> What is the exact kind of s?
20:15:38 <fDev2179> Here's the kind of an instance of ShapeFcn: TensorProduct :: * -> *
20:16:10 <fDev2179> Is type parameter the right terminology to use for the parameter?
20:16:11 <iqubic> Not sure how to help you. Sorry.
20:16:23 <fDev2179> Okay, thanks iqubic.
20:18:16 <clinton> is there anything I can put in my cabal file to indicate to Hackage to attempt to compile my package with GHC 8.2 only? (it seems to be making attempts with GHC 8.0.2 and failing)
20:20:15 <clinton> oh no matter I think I've found it
20:23:51 <sinsnare> Hi, I am trying to understand Arrows, I am reading John Hughes paper, but the syntax is a bit confusing, can someone look at this? http://lpaste.net/359359
20:24:07 <sinsnare> It seems like the function only takes one argument, but he is putting in 2 arguments
20:25:16 <geekosaur> remember that an arrow is essentially a function
20:25:35 <geekosaur> (first f) produces, a function, which can in turn be applied to a parameter
20:26:12 <geekosaur> and haskell knows from the type of (->) that this will happen, so it allows you to include the application.
20:26:46 <geekosaur> you could also write it, to look more like the definition: first f = \(a, c) -> (f a, c)
20:27:51 <sinsnare> geekosaur: that makes sense, so its because of the (->) type, makes sense.
20:28:26 <sinsnare> i still dont really get arrows yet, but thats helpful to understanding a lot of the examples haha
20:28:48 <geekosaur> yeh, this makes the (->) instance of Arrow really confusing.
20:29:50 <geekosaur>  you can run into it also in other contexts where Haskell knows something produces a function, so it lets you apply it immediately; again, this looks like you passed one parameter too many, because the extra one is given to the returned function
20:30:15 <geekosaur> so if it loks like that and it typechecks, look for the function
20:31:04 <geekosaur> here, it's hidden in (a b c) which for the function instance is ((->) b c) aka (b -> c)
20:32:29 <ski> > foldr (\n k acc -> k (acc * n)) (\acc -> acc) [1 .. 5] 1  -- "leaned so far right it came back left again"
20:32:33 <lambdabot>  120
20:33:42 <ski> (how many arguments does `foldr' take ?)
20:35:51 <geekosaur> (this is also why if you *do* pass one too many parameters to something that doesn;t want it, the error message references a function type. the other direction, one too few, is a partial application and returns a function)
20:36:20 <saurabhnanda> anyone using `stack build --docker` -- it has suddenly started throwing random errors.
20:36:48 <geekosaur> might be related to the stacksge docs issue i.e. they're (or S3 is) having network issues
20:37:04 <geekosaur> I know s3 was reported to bee having problems with us-west-1 earlier today
20:38:32 <sinsnare> geekosaur: interesting. yeah, im using a library that involves signal functions and arrows, and SFs look kinda weird too :p
20:39:16 <jle`> saurabhnanda: by random do you mean like nondeterminstic errors
20:39:21 <jle`> *non-deterministic
20:39:44 <jle`> that's pretty interesting actually
20:41:23 <MarcelineVQ> saurabhnanda: note that when you provided the actual error you were having on a previous problem the problem was solved shortly after
20:41:37 <saurabhnanda> jle`: started off with OOM errors. Then graduated to linker errors. Random crashes in between as well.
20:41:47 <geekosaur> oh. that sounds like what's on the tin
20:42:29 <saurabhnanda> throwing a bunch of the following, currently:
20:42:34 <saurabhnanda> Linking .stack-work/dist/x86_64-linux-dkfe00e7bee1f31adfb1c0a1698a6a3dca/Cabal-1.24.2.0/build/webservice-exe/webservice-exe ...
20:42:34 <saurabhnanda>     /Users/saurabhnanda/projects/vl-haskell/.stack-work/dist/x86_64-linux-dkfe00e7bee1f31adfb1c0a1698a6a3dca/Cabal-1.24.2.0/build/libHSwebservice-0.1.0.0-G0E7WRnzL1nIEK83JHqwLl.a(Booking.o): In function `cf10D_info':
20:42:34 <saurabhnanda>     (.text+0x5188): undefined reference to `webservicezm0zi1zi0zi0zmG0E7WRnzzL1nIEK83JHqwLl_AutoGeneratedziModelsziTripOption_zdfDefaultpTripOptionPolyTripOptionPolyzuzdcdef_info'
20:42:43 <saurabhnanda> [... truncated ...]
20:43:06 <saurabhnanda> the same codebase is building with `stack docker`
20:43:11 <saurabhnanda> , sorry `stack build`
20:43:15 <geekosaur> (also I just checked the AMZ service onsole and the us-west-1 issues I metnioned are reported resolved)
20:43:25 <saurabhnanda> the same codebase is building with `stack build`, but not with `stack build --docker`
20:43:27 <MarcelineVQ> undefined references are usually cause by not listing all your modules in your cabal file. either in exported, or other, etc
20:43:43 <MarcelineVQ> That's not a rule or anything, just common
20:43:50 <saurabhnanda> @MarcelineVQ the same codebase is building with `stack build`, but not with `stack build --docker`
20:43:50 <lambdabot> Unknown command, try @list
20:44:02 <saurabhnanda> MarcelineVQ the same codebase is building with `stack build`, but not with `stack build --docker`
20:44:08 <MarcelineVQ> that's fine, but check your modules just in case
20:44:49 <saurabhnanda> don't need to -- using hpack, which does this automatically
20:45:11 <saurabhnanda> I used to get these errors when I was managing cabal file by hand. Never ran into this since moving to hpack.
20:45:34 <saurabhnanda> and the exact same working directory, is building with `stack build` (i.e. without --docker)
20:47:58 <suzu> hey you're the vacation labs guy!
20:48:19 <Welkin> what?
20:48:28 <saurabhnanda> suzu: yep.
20:48:29 <suzu> maybe i'm wrong
20:48:31 <suzu> oh ok
20:48:33 <suzu> !
20:48:36 <Welkin> what is that?
20:48:45 <saurabhnanda> Welkin: name of company -- www.vacationlabs.com
20:48:48 <suzu> it is a company that i've seen in r/haskell a bit
20:48:59 <Welkin> no advertising!
20:49:17 <suzu> is that actually a rule?
20:49:29 <MarcelineVQ> not that I'm aware of, usually it's more of a dont' spam thing
20:49:44 <suzu> ok
20:57:39 <saurabhnanda> suzu: anything in particular?
20:57:51 <dmj`> I’d assume someone trying to hire Haskell programmers wouldn’t be frowned upon :)
20:58:46 <Welkin> it was partialy a joke, but also serious in a way
20:59:01 <Welkin> because the way saurabhnanda linked it made it look like generic spam
20:59:14 <geekosaur> unless you happened to be following the discussion
20:59:27 <saurabhnanda> let it be... move on...
21:00:01 <saurabhnanda> ...trying docker building on a monster EC2 instance to see if it's a Mac OSX issue.
21:00:07 <Welkin> john lennon?
21:00:18 <suzu> fwiw i do not use stack docker and i don't like it
21:00:30 <suzu> i do the docker-ing manually
21:00:46 <saurabhnanda> what does your deploy pipeline look like, suzu? Which machine do you build on?
21:01:04 <suzu> i develop on osx
21:01:12 <suzu> but build and deploy inside alpine linux
21:01:37 <suzu> the final image is about ~30mb and ships right up to google cloud where it runs
21:03:29 <suzu> i do this with a multi-stage dockerfile
21:03:45 <suzu> one docker image, based off alpine linux, installs ghc and stack, then builds the application statically
21:04:06 <suzu> the second image, also alpine, just copies that binary into itself, and is the final artifact
21:04:11 <saurabhnanda> docker is running on osx, correct? are you building with -O0 or -O1?
21:04:19 <suzu> yes, osx
21:04:38 <suzu> -O1..? i think.
21:04:53 <Axman6> suzu: I would be interested in a blog post outlining how you manage this workflow
21:05:12 <suzu> oh would you? i can publish one :)
21:05:26 <saurabhnanda> suzu: can you please check. My hypothesis has to do with OSX with -O1
21:05:49 <saurabhnanda> and it happens again....
21:05:58 <suzu> i did this for work.. so i don't know if i'm allowed to write
21:06:03 <suzu> maybe i'll just do it anyway.
21:06:06 <saurabhnanda> Process exited with code: ExitFailure (-9) (THIS MAY INDICATE OUT OF MEMORY)
21:06:20 <saurabhnanda> on a 64gig machine?! suzu, do I need to increase docker's memory?
21:06:49 <suzu> i have no -O at all, actually
21:07:42 <saurabhnanda> suzu: if you have itme, please try a docker build with -O1. Stick a -j there, while you're at it.
21:08:12 <suzu> sure, give me a moment
21:09:53 <suzu> yes, no problem at all
21:10:00 <suzu> i should be clear that i'm not using stack with docker integration
21:10:10 <suzu> im doing all the docker work manually
21:11:02 <suzu> saurabhnanda
21:11:22 <saurabhnanda> suzu: got it...
21:11:40 <saurabhnanda> does docker have any resource limits, by default?
21:11:42 <suzu> i had some problems with that
21:11:50 <suzu> namely, the fpco docker images are like 300mb
21:11:52 <suzu> what a waste
21:12:05 <suzu> saurabhnanda: are you using Docker For Mac?
21:12:10 <suzu> or did you `brew install docker`
21:12:25 <saurabhnanda> I'm on a Ubuntu 16.04 now.. (on EC2). 
21:12:40 <suzu> okay
21:12:44 <saurabhnanda> this suggests some problems with docker+OSX -- https://github.com/commercialhaskell/stack/issues/2054
21:12:51 <suzu> well by default, there are no limits to docker resource consumption
21:13:12 <suzu> > Docker integration is not supported on OS X
21:13:15 <suzu> welp, there you go
21:13:17 <lambdabot>  error:
21:13:17 <lambdabot>      Data constructor not in scope:
21:13:17 <lambdabot>        Docker
21:13:17 <suzu> that's funny though
21:13:22 <suzu> "we don't support docker on this one platform"
21:13:29 <suzu> ~_~ thats what docker is supposed to do though
21:13:45 <saurabhnanda> suzu: exaclty. completely kills the use-case.
21:13:51 <suzu> this issue is also from before Docker For Mac hit public usage
21:13:54 <suzu> which it has now
21:13:59 <suzu> so i dont know if this is accurate anymore
21:16:24 <saurabhnanda> can anyone help me make sense of this dmesg output -- https://gist.github.com/saurabhnanda/328320110e8fe30ecf2ec41cccb6e101
21:16:47 <saurabhnanda> where does it say how much memory was docker using?
21:17:17 <geekosaur> I think it's still not running docker the way linux does
21:17:35 <saurabhnanda> that's on linux (EC2 monster instance.)
21:17:45 <saurabhnanda> 16 core / 64 gig ram.
21:18:03 <geekosaur> because there's no way they can put cgroups in the OS X kernel
21:18:23 <geekosaur> so it's still being a frontend for a virtualization system/hypervisor
21:19:17 <saurabhnanda> can someone please check the dmesg output... it seems the process is being killed as soon as it crosses somewhere around the 4gig mark... can someone please confirm for me?
21:19:17 <geekosaur> line 7, total-vm
21:20:04 <geekosaur> oh total-vm doesn;t count, it's the fast page allocator 1TB stuff
21:20:09 <geekosaur> anon-rss is the right one
21:20:09 <saurabhnanda> geekosaur: am I reading that correct? 1024 GB!! memory usage
21:20:12 <geekosaur> and yes, around 4g
21:20:37 <saurabhnanda> that's 3.7gigs... in the same ballpark
21:20:49 <saurabhnanda> so something is capping off the memory to 4gig... what is it. how to peel the onion?
21:21:02 <geekosaur> saurabhnanda, that is why 'top' says haskell programs use 1TB. it's 'allocated' but not 'committed'; the memory allocator uses madvise() to request and free individual pages in that address space
21:21:11 <geekosaur> but the whole address space is 'reserved'
21:22:02 <geekosaur> saurabhnanda, you can;t put cgroups in the OS  X kernel. they're running Linux in a (likely 4GB) VM and running docker inside that
21:22:34 <geekosaur> Apple does not provide the inf0rmation needed to implemnt cgroups, so docker will never run natively on os x unless apple either releases the kernel info or implements cgroups itself
21:22:35 <saurabhnanda> geekosaur: I'm on a linux box. 
21:22:53 <saurabhnanda> hang on, am I on a 32 bit machine? even that has something to do with 4gigs, right?
21:22:55 <geekosaur> oh, this isn;t the os x issue mentioned then? I must have misread backscroll :/
21:23:10 <geekosaur> it does, yes
21:23:22 <geekosaur> oneld use large page support but theres still a 4gb limit on segments
21:23:28 <geekosaur> *one could use
21:23:41 <geekosaur> so yes, a 32 bit machine will fail
21:26:04 <geekosaur> although the kernel message says 'killed as a result of limit of /docker/...'
21:26:10 <saurabhnanda> geekosaur: didn't want to spend time on OSX due to that GH issue.
21:26:14 <geekosaur> so might still be looking forsome kind of docker config
21:26:22 <geekosaur> (line 28)
21:26:39 <saurabhnanda> on /proc/cpuinfo how do I check bit-size?
21:27:14 <dyreshark> how do you mean bit size
21:27:36 <saurabhnanda> 32bit or 64bit
21:27:54 <saurabhnanda> word-size... whatever is the correct term.
21:27:59 <Axman6> use MachDeps.h :\
21:28:54 <geekosaur> you want the 'pae' cpu flag, I think
21:29:54 <geekosaur> hm, no
21:30:19 <geekosaur> pae lets 32 bit go past 4gb too, what is the flag...
21:30:50 <MarcelineVQ> does Xeon come in 32?
21:31:37 <saurabhnanda> got it. arch // x86_64
21:31:46 <saurabhnanda> so it *is* a docker resource limit... where the hell is this config now!
21:33:57 <geekosaur> the original zeons were 32 bit
21:34:01 <geekosaur> xeons
21:34:21 <Eduard_Munteanu> Do Intel / AMD still manufacture 32-bit CPUs? 64-bit versions can do everything the 32-bit versions do.
21:34:22 <geekosaur> ah, cpu flag is lm
21:34:56 <Eduard_Munteanu> And they've been available for like 10+ years.
21:35:00 <geekosaur> likely they do, but only to the extent that a cpuy that passes 32 bit but not 64 bit tests gets the em64t stuff masked off and it's sold as 32 bit
21:35:22 <Eduard_Munteanu> Hm, binning makes sense.
21:39:29 <saurabhnanda> found the culprit. It was in stack.yaml itself -- run-args: ["--ulimit=nofile=60000", "--memory=4g"]
21:40:00 <geekosaur> "oops"
21:44:41 <iqubic> Tomorrow I turn 17.
21:48:03 <saurabhnanda> okay.. the docker build is not running out of memory, but I'm still getting unexplained linker errors:
21:48:12 <saurabhnanda> gcc: error: .stack-work/dist/x86_64-linux-dkfe00e7bee1f31adfb1c0a1698a6a3dca/Cabal-1.24.2.0/build/Models/Coupon/Types.dyn_o: No such file or directory
21:49:14 <geekosaur> are you building with the -dynamic flag? (might need to check the .cabl or .yaml file)
21:49:51 <geekosaur> also it's conceivable tat all the OOMs caused things like partially written files that would confuse it because dependency checking thinks they're completed
21:52:18 <saurabhnanda> I tried doing `stack clean --docker` but it didn't seem to have the desired effect.
21:53:12 <saurabhnanda> trying without `-j` for now... let's see what happens. This will take a while, though...
21:54:18 <saurabhnanda> this is going to all blow-up in CircleCI though, which has a 4gb hard limit.
22:09:25 <saurabhnanda> suzu: did you get the build with -o1 working on docker.. it's failing for me even on a 64 gig machine... same linker errors at the end -- (.text+0x5188): undefined reference to `webservicezm0zi1zi0zi0zmG0E7WRnzzL1nIEK83JHqwLl_AutoGeneratedziModelsziTripOption_zdfDefaultpTripOptionPolyTripOptionPolyzuzdcdef_info'
22:11:41 <geekosaur> missing _info like that often points to a module not listed in either exposed-modules or other-modules. I would wonder if they're both using the same version of ... webservice-0.1.0.0 and their cabal files match
22:12:31 <geekosaur> er. module: AutoGenerated.Models.TripOption --- 'autogenerated'? does the buold make those? check that part of the build
22:13:21 <geekosaur> and it looks like a class dictionary
22:16:23 <geekosaur> (why yes, I am z-decoding symbol names on the fly...)
22:17:10 <MarcelineVQ> you absolute madman
22:17:40 <Axman6> I can't believe you've done this
22:23:31 <suzu> saurabhnanda, yes
22:23:38 <suzu> i got it working by _not using stack docker_
22:23:46 <suzu> ;)
22:26:29 <saurabhnanda> geekosaur: same dir is building without --docker... the cabal file is not a problem, unles --docker makes it behave differently.
22:26:50 <geekosaur> figured once I looked more closely at the symbol name. read on
22:29:12 <geekosaur> full decoded symbol webservice-0.1.0.0-G0E7WRnzzL1nIEK83JHqwLl:AutoGenerated.Models.TripOption:$fDefaultpTripOptionPolyTripOptionPoly_$cdef_info --- I haev no idea what that class dictionary is for (Defaultp...)
22:32:42 <geekosaur> the $f is what marks it as a class dictionary. _info suffix is its 'info table' which is what describes it to STG. beyond that I'd need to see source to module AutoGenerated.Models.TripOption, but maybe you can find something wrong if 'AutoGenerated' actually means what it says and something in the build is supposed to be creating it
22:39:03 <\u> seq evaluates an expression to Head Normal Form?
22:39:56 <dmj`> weak head normal form, to the outer most constructor
22:41:12 <\u> HNF is a subset of WHNF and someone told me it evaluates to HNF (but i'm not familiar with this concept)
22:42:23 <\u> if the function after a list of \a b c is saturated applied to its arguments, it is not a HNF, (but a WHNF)
22:44:08 <dmj`> @google what is weak head normal form
22:44:09 <lambdabot> https://wiki.haskell.org/Weak_head_normal_form
22:44:42 <dmj`> ah, this link instead: https://stackoverflow.com/a/6889335/453261
22:45:07 <dmj`> and https://en.wikibooks.org/wiki/Haskell/Laziness#Thunks_and_Weak_head_normal_form
22:46:18 <\u> I know what is WHNF. I meant, someone told me, `seq` does more and actually evaluates an expression to Head Normal Form, which is a subset of WHNF
22:48:27 <mniip> \u, no, haskell has no notion of HNF
22:48:50 <mniip> well, the GHC RTS doesn't anyway,
22:48:53 <mniip> seq is WHNF only
22:49:37 <\u> Good. I was dubious about his argument
23:42:52 <saurabhn_> geekosaur: you around?
23:43:00 <saurabhn_> just saw your messages... was driving to office.
23:43:16 <saurabhn_> build script is not doing autogen.. it's checking into the repo
23:43:54 <saurabhn_> geekosaur: do you want to see the code for AutoGenerated.Models.TripOption?
