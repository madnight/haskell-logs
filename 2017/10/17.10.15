01:03:05 <roi_du_silence> is scheme fun
01:05:22 <[exa]> (is-scheme? fun)
01:05:48 <[exa]> => #t
01:11:50 <Hail_Spacecake> can someone help me actually thoroughly understand monad transformers?
01:12:22 <Hail_Spacecake> I more or less understand monads, in the sense that I know what >>= and return do in terms of their type signatures and I know why do notation makes sense
01:12:37 <Hail_Spacecake> but when I read things about monad transformers, I find I get lost quickly, I think because of the notation
01:14:04 <cocreature> Hail_Spacecake: is there something specific you’re confused about?
01:18:16 <dmj`> Hail_Spacecake: which notation
01:19:34 <Hail_Spacecake> dmj`: for instance
01:19:38 <Hail_Spacecake> newtype MaybeT m a = MaybeT { runMaybeT :: m (Maybe a) }
01:19:47 <Hail_Spacecake> which ocomes from the wikibooks example on monad transformers
01:20:54 <cocreature> Hail_Spacecake: what’s confusing you here?
01:21:13 <Hail_Spacecake> what runMaybeT is doing
01:21:25 <cocreature> Hail_Spacecake: are you familiar with Haskell’s record types?
01:21:34 <Hail_Spacecake> also why is it using newtype to create a complete novel type
01:21:36 <Hail_Spacecake> instead of data?
01:22:06 <[exa]> Hail_Spacecake: that's actually a fancy syntax for something like: `MaybeT m a = MaybeT (MaybeT m a -> m (Maybe a))`  where the only field of MaybeT is called runMaybeT
01:22:37 <Hail_Spacecake> so, in record syntax, you have DataConstructor { someValue :: Type, someOtherValue :: Type }
01:22:45 <Hail_Spacecake> and then that automatically creates in the global namespace
01:22:51 <Hail_Spacecake> functions called SomeValue and someOtherValue
01:22:56 <Hail_Spacecake> so, I guess this is
01:22:57 <[exa]> yes
01:22:58 <cocreature> right, in this case there is just one field called runMaybeT of type "m (Maybe a)
01:24:02 <Hail_Spacecake> okay, so if sti down and type that into ghci
01:24:05 <Hail_Spacecake> I can do :t runMaybeT
01:24:12 <Hail_Spacecake> and that has type MaybeT m a -> m (Maybe a)
01:24:49 <cocreature> Hail_Spacecake: if you define "data X = X { someValue :: Type, someOtherValue :: Type }" and type ":t someValue" into GHC it will have type "X -> Type"
01:24:59 <cocreature> so it’s really the same thing that’s going on here
01:25:13 <dmj`> @google transformers grabmueller step
01:25:13 <lambdabot> https://page.mi.fu-berlin.de/scravy/realworldhaskell/materialien/monad-transformers-step-by-step.pdf
01:25:18 <dmj`> @Hail_Spacecake ^
01:25:19 <lambdabot> Unknown command, try @list
01:25:27 <dmj`> is a good one too
01:25:38 <Hail_Spacecake> okay I'll give that I read
01:25:50 <Hail_Spacecake> I think I was just tripped up by not grokking how record notation was being used here last time I tried to understand this
01:27:48 <[exa]> Hail_Spacecake: about the newtype vs. data, 'data' always wraps the inner time in some structure at the runtime, 'newtype' doesn't create any wrapping (and can be "compiled" to the inner type) but it's therefore a bit limited in functionality
01:28:35 <[exa]> moral is that 'newtype' typechecks as data but doesn't cause runtime overhead
01:30:12 <dmj`> Hail_Spacecake: I remember that tripping me up too. Suppose we have the type newtype Identity a = Identity { runIdentity :: a }, the type of runIdentity isn’t obvious
01:30:49 <the_2nd> I wrote a folding method where I pass a state through each apply of f
01:31:08 <the_2nd> I wrote this explicitly for lists, any generic class I can define this on?
01:31:15 <[exa]> Foldable?
01:31:31 <Hail_Spacecake> [exa]: what do you mean by "inner type"?
01:31:55 <the_2nd> ah wait
01:32:04 <the_2nd> it's mapping while holding a state
01:32:44 <[exa]> the_2nd: maybe you'd want some combination of mapM and State?
01:33:18 <[exa]> Hail_Spacecake: the data in the only field there. I usually explain it on this example:
01:33:49 <[exa]> you have String, but you also want CheckedString that's just an implicit mark that the string doesn't contain e.g. dangerous characters or something
01:34:32 <[exa]> compare: type CheckedString = CheckedString String; newtype CheckedString=...same; data CheckedString=...
01:34:51 <[exa]> 'type' only creates a type alias and allows you to pass Strings as CheckedStrings
01:35:18 <[exa]> 'data' does the required functionality, but in runtime it wraps all strings in a tiny box with a label 'oh yes this is CheckedString'
01:36:29 <[exa]> 'newtype' typechecks as data (you cant fake CheckedStrings from Strings), but since the inner type is required to be trivial (only one data constructor with one field iirc) the box is erased and it behaves just as String in runtime
01:36:39 <Hafydd> "type CheckedString = CheckedString String" is an error.
01:36:52 <[exa]> oh sorry, type CheckedString = String :]
01:38:34 <Hafydd> The important difference between the newtype and the data type is that with the data type CheckedString undefined is not itself bottom, but with the newtype it is.
01:40:18 <Hafydd> I don't think values of the data type actually have a label identifying their type. That isn't necessary, since the types are known at compile time.
01:41:42 <knupfer> Is there an efficient type level append implementation?
01:42:04 <[exa]> Hafydd: I thought that the difference with undefined is exactly derived from boxing the value
01:43:00 <Hafydd> [exa]: what do you mean by "derived from"?
01:43:14 <knupfer> http://lpaste.net/359246
01:43:27 <knupfer> This one is quite slow for the compiler.
01:43:41 <[exa]> Hafydd: in the "implemented by" sense :D
01:43:49 <knupfer> If I add extra cases for long lists, it gets better but uglier in the code...
01:44:30 <Hafydd> [exa]: yes, I think so, too. What of it?
01:45:01 <knupfer> http://lpaste.net/359247
01:45:40 <knupfer> this one is a lot faster, but it's quite ugly
01:45:58 <the_2nd> [exa], http://lpaste.net/3935449769928818688   I try to get it to work with mapM, but failing
01:46:19 <[exa]> Hafydd: the point was that I thought that the boxing of 'data' doesn't get erased except in function-local code (there's not the actual "label", that was for illustration)
01:47:02 <Hafydd> [exa]: that was also my understanding. Do you think I claimed otherwise?
01:49:06 <[exa]> Hafydd: well not entirely, I seems I have misread "known at compile time"
01:50:10 <Hafydd> [exa]: on the other hand, I am claiming that there is no such label attached to the box, and to say so is misleading, since it implies that the representation of "data A = A Int" is disinct from that of "data B = B Int", somehow.
01:53:45 <[exa]> Hafydd: well there should certainly be some typeclass information for the generic functions
01:55:16 <Hafydd> [exa]: yes. However, this is not part of the value representation.
01:55:46 <[exa]> interesting.
01:56:21 <Hafydd> (It would be a tremendous waste of space if it were.)
01:56:55 <[exa]> the_2nd: 'find' is the standard find from Data.Foldable ?
02:00:08 <the_2nd> its signature is below. Maybe it's equal but it's my own function in this case
02:00:28 <[exa]> ioc
02:00:38 <[exa]> why's there the $ in the cachedMap definition?
02:03:16 <[exa]> (runState has 2 arguments)
02:04:52 <the_2nd> the $ is unnecessary, yes
02:05:10 <[exa]> maybe even harmful in this case :]
02:05:34 * geekosaur finds it suspicious as well
02:06:44 <the_2nd> [exa], got it :)
02:08:55 <[exa]> the_2nd: if it works, you might also want to use the strict variant of State since it looks like you're after speed
02:09:17 <the_2nd> [exa], http://lpaste.net/2551034042078199808
02:09:33 <the_2nd> [exa], I think I already do that import Control.Monad.State.Strict
02:10:22 <the_2nd> I had lots of duplicates in [a], the method works wonders
02:11:04 <[exa]> cool
02:12:11 <[exa]> anyways I'd either parametrize the operation out, or remove it to specific cachedMapFind
02:12:15 <[exa]> *rename
02:12:53 <[exa]> (but I have no idea what your Cache actually is, so maybe it makes sense this way)
02:13:49 <the_2nd> It's a map a -> b   find either returns what is in the map or calls f a and inserts it
02:15:17 <the_2nd> unsure what you mean by parameterizing the operation out
02:15:25 <the_2nd> since f is already a parameter
03:14:28 <drdo> Are local data declarations a thing yet? Or at least newtype
03:14:38 <drdo> e.g. in let/where
03:14:43 <c_wraith> no
03:15:05 <drdo> What about passing explicit instances?
03:15:23 <drdo> In this I want a Set with and Ord that isn't the usual one
03:15:23 <c_wraith> people vehemently do not want that.
03:15:28 <drdo> *this case
03:15:32 <drdo> *an
03:15:40 <c_wraith> Set is exactly why people do not want that.
03:15:55 <drdo> How so?
03:16:24 <c_wraith> Set merge operations
03:16:47 <Maxdamantus> You can already corrupt Sets, just have to do it across different modules.
03:16:48 <c_wraith> :t S.union
03:16:49 <lambdabot> Ord a => S.Set a -> S.Set a -> S.Set a
03:17:00 <c_wraith> Maxdamantus, yes, but that's a GHC bug.
03:17:02 <drdo> c_wraith: What about it is a problem with explicit instances?
03:17:06 <c_wraith> Maxdamantus, the spec does not allow that.
03:17:46 <Maxdamantus> What? It doesn't allow different instances for the same type-level arguments in different modules?
03:18:10 <drdo> Naturally you probably don't want to expose a public API with Sets that were created using non-standard instances, but otherwise what's the issue?
03:18:12 <c_wraith> Maxdamantus, correct.  The spec says that instances must be globally unique in a whole program
03:19:08 <Maxdamantus> O_o
03:20:08 * hackagebot text-format-heavy 0.1.2.0 – Full-weight string formatting library, analog of Python's string.format – https://hackage.haskell.org/package/text-format-heavy
03:20:48 <drdo> Oh well, guess I'll just newtype with some silly name
03:23:32 <Maxdamantus> Doesn't seem to mention that restriction in https://wiki.haskell.org/Multiple_instances
03:24:06 <Maxdamantus> Guess I can try looking for it in the report later, but I'm not very familiar with reading that.
03:37:04 <drdo> Hmm, I really do need a custom compare function for this Set. I could do a newtype and include the custom compare function in each element, but that's a bit silly
03:37:09 <drdo> Is there a better way to do this?
03:37:47 <drdo> (the function is not fixed, if has to be parameterised with something else)
03:47:11 <erisco> drdo, what is the comparison?
03:48:05 <Maxdamantus> drdo: note that the structure itself of the `Set` is determined by the compare function. It's not just something you can decide to use on some `Set` operations.
03:48:53 <drdo> Assume distance ∷ A → A → Int, then the compare function is c z x y = compare (distance x z)  (distance y z)
03:48:54 <Maxdamantus> drdo: eg, it would be completely wrong to add a member to a set while using one compare function, then see if some member is an element of that same set using a different compare function.
03:49:08 <drdo> i.e. the compare function is c z, parameterised by z
03:49:09 <fakenullie> drdo: what's wrong with new type?
03:49:19 <drdo> fakenullie: I need to parameterise the compare function
03:49:51 <drdo> Maxdamantus: I understand that
03:50:08 <drdo> I want to use a consistent compare function
03:50:22 <erisco> you can use a Data.Map from the distance to the object(s) at that distance
03:50:40 <fakenullie> Define compare function in ord instance
03:50:50 <drdo> fakenullie: How?
03:52:05 <fakenullie> instance Ord YourNewType ?
03:52:22 <drdo> fakenullie: But how do you parameterise it?
03:53:04 <drdo> erisco: Hmm, how exactly?
03:53:19 <erisco> what don't you know?
03:53:56 <fakenullie> well, maybe it's a -> b problem
03:54:48 <drdo> erisco: Nevermind, I think I get it. Yeah that should work probably work
03:54:55 <drdo> s/work//
03:56:35 <fakenullie> can't you put (distance x z) instead of x into the set?
03:57:28 <drdo> Not exactly, but in this case I could do something like that since it's reversible
03:57:32 <drdo> It's just ugly
03:57:38 <drdo> But in general that wouldn't work
03:57:52 <fakenullie> you can use map instead of set to keep x
03:58:59 <drdo> Actually, it's not even reversible in this case, but I could hack something up such that it is
03:59:28 <fakenullie> you can keep x in map value in use distance ot x in map key
04:22:42 <fabler> Hello, programmers, can someone send me a tutorial about writing file in thread (forkIO)?
04:25:31 <barrucadu> What are you having difficulty with?
04:27:31 <fabler> I can't write string to file in thread. Data will be written only after thread stopped work.
04:29:33 <barrucadu> Writing to a file in a thread is exactly the same as writing to a file in main (main is just another thread).  Are you possibly having buffering issues? https://hackage.haskell.org/package/base-4.10.0.0/docs/System-IO.html#g:12
04:29:40 <cocreature> fabler: how are you writing the file?
04:32:10 <fabler> Here is my code: https://pastebin.com/VQ8YGdUG
04:33:18 <fabler> Now I trying write to file with appendFile. I want try out working with locks, but find no tutorials about it.
04:33:44 <fabler> Buffer issues? Can you say more about it?
04:36:00 <barrucadu> Writing to files is slow, so writes tend to be cached in memory until you either call hFlush on it, you write a newline (if writing to a terminal), or the buffer fills up (if writing to a file).
04:36:40 <barrucadu> But appendFile calls hClose, so I don't think that will be the problem
04:37:23 <fabler> I'm so sorry for being dropped from chat. Can anyone explain me, or give advise about writing file in threads?
04:37:51 <cocreature> fabler: can you be a bit more specific? what behavior are you seeing and what behavior do you expect?
04:38:05 <barrucadu> How are you determining that writing only happens when the thread stops?  That forked action looks to me like it'll complete pretty quickly.
04:38:51 <shafox> I am trying to parse one xml using xml-conduit: here is the code: https://gist.github.com/shadow-fox/8db9b7e8009f72dd3026c9cacf3d7338 . But getting InvalidEndElement. 
04:40:13 <fabler> I want write all data to file, when my server receive it. So, char received - char will be written to file. This is what I expect to have
04:42:27 <fabler> barracadu, problem is that data writing only when I disconnects from server.
04:42:40 <barrucadu> Ah, I see
04:43:45 <barrucadu> That's because you're calling hGetContents on the handle and trying to print it all out before writing it to the file
04:43:55 <barrucadu> That putStrLn can't terminate until it has the entire message
04:44:02 <barrucadu> Which can't happen until you disconnect
04:44:21 <fabler> Thanks! I will check it out now!
04:44:33 <cocreature> fabler: are you reading binary or text input?
04:44:45 <fabler> Text input
04:44:50 <barrucadu> You could use hGetChar, repeating until it throws an exception (which signifies EOF)
04:45:03 <cocreature> fabler: in that case, I would use hGetLine and call that in a loop
04:45:44 <cocreature> hGetChar works if you really want each char separately but unless you have a good reason to care about individual chars, hGetLine is probably a better solution
04:45:47 <fabler> Interesting, after I removed putStrLn - i get another error that resource (file) is busy
04:46:04 <barrucadu> You have a race condition between the two appendFile calls
04:46:23 <barrucadu> You'll probably need some synchronisation to ensure that only one thread is writing to the file at a time
04:46:33 <fabler> If I truly understand - I need some kind of a lock
04:46:37 <barrucadu> Yes
04:48:12 <fabler> Heh, interesting, I removed first appendFile, and my first problem sucsessfully returned :D
04:48:31 <fabler> I'll figure out: how to work with buffering
04:53:15 <fabler> Yes, guys! Thank you a lot! I solved my problem. You are the best!
04:54:20 <fabler> Problem was in buffering. I created file handle, and set NoBuffering to it. Then applied hPutStr with string on it, and it works
04:54:42 <mauke> never use NoBuffering
04:55:05 <fabler> Ok, why? what's wrong with it?
04:57:01 <cocreature> fabler: it’s terribly slow
04:57:56 <fabler> Hm, ok, I will read about that. Thankully, there is a good documentation about it
05:04:16 <portnov> hi all
05:04:50 <portnov> damn, pressed ctrl-w in the wrong place :)
05:05:12 <portnov> does anybody know, what is synchronization timeout of fpcomplete's hackage mirror?
05:05:57 <erisco> are there any adaptive parsing solutions in Haskell?
05:06:18 <portnov> aha, it seems about 5 minutes
05:06:40 * portnov just uploaded package to hackage and was not able to get it with stack build
05:07:41 * hackagebot graphql-api 0.2.0 – Sketch of GraphQL stuff – https://hackage.haskell.org/package/graphql-api
05:07:49 <etiago> (hopefully) quick question: I´m currently using Atom plus a bunch of packages as an IDE for Haskell. It´s less than ideal though, I can´t seem to get a repl up and running for the current ¨session¨
05:07:56 <etiago> does anyone have suggestions of a proper IDE setup?
05:08:50 <fabler> Hm, you can use Microsoft Visual Code, but it's proprietary
05:08:51 <erisco> hm, I think this has a different meaning in the parsing world than what I meant
05:09:16 <etiago> fabler, does it integrate well with Haskell in terms of indentation and repl?
05:09:28 <etiago> I´ve used it before, but not for Haskell
05:10:29 <etiago> it would also be cool if there was a feature where I could highlight a piece of code and it would tell me the type signature of that particular segment
05:10:36 <erisco> and I can't find a reference for what I mean by "adaptive", but I know it exists, hm
05:10:52 <fabler> So, before I used nano + cabal. But you can actually try. MS VC + Ghc plugin + CodeRunner plugin = works not perfect, but well
05:11:29 <etiago> fabler, cool, thx, I´ll give it a try
05:12:02 <erisco> what I mean by "adaptive" is that a change to an input, plus the history of computation for the output, can be used to more efficiently compute the new output
05:12:04 <fabler> etiago: your welcome
05:13:32 <erisco> for example, if I change some numbers in a list, the sort of that list just has to adapt to the changed numbers
05:14:00 <erisco> so, adaptive parsing, if I change the text, the parsed text adapts just to the changed text
05:14:42 <portnov> erisco: i heard something similar (but not exactly) under term "incremental parsing"
05:15:15 <portnov> and it seems I even read some papers about incremental parsing in haskell
05:15:30 <erisco> I thought incremental parsing was something else but I'll take a look
05:15:58 <erisco> iirc incremental parsing only adapts to appends
05:19:07 <erisco> at best you could save the parsing state at every position and rewind to any position to make an edit, but this is wasteful
05:34:33 * hackagebot heavy-logger 0.1.0.0 – Full-weight logging based on fast-logger – https://hackage.haskell.org/package/heavy-logger
05:35:36 <shafox> Can someone help parsing this xml ? I am trying to parse one xml using xml-conduit: here is the code: https://gist.github.com/shadow-fox/8db9b7e8009f72dd3026c9cacf3d7338 . But getting InvalidEndElement.
05:39:08 <tomasmu> hello
05:41:22 <tomasmu> i have a small exercise, the task is to find the max profit out of an array with buy/sell prices, e.g. [5, 2, 10, 9], so best would be to buy for 2 and sell for 10, for a profit of 8
05:42:19 <tomasmu> i've managed to get a list of all possible profits, so i could just use maximum on it, but it would be fun to figure out how to do it in a single function
05:42:56 <tomasmu> i want tips rather than solutions, do you have any pointers? :)
05:43:31 <fabler> tomasmu: Can you use maximum?
05:43:34 <tomasmu> what i have this far: profits [] = []; profits (x:xs) = [n - x | n <- xs] ++ profits xs
05:43:40 <ongy> can any value in the list be the sell or the buy price?
05:43:55 <tomasmu> fabler: yeah
05:44:31 <tomasmu> it's not a school assignment or anything, just a problem i saw somewhere
05:44:40 <fakenullie> you could do it in one list comprehension
05:44:44 <xft0> hi, just short question from newbie, how to convert string to hash algorithm (cryptonite library) i.e "sha1" -> SHA1
05:44:49 <fabler> tomasu, so you can use just: maximum [5,2,10,9]
05:45:13 <fakenullie> or subtract minimum buy from maximum sell
05:45:46 <tomasmu> if you had this: [5, 2, 10, 9, 1], you cannot buy for 1 and sell for 10, since you can't sell if you haven't bought
05:46:17 <shloub> <tomasmu> i want tips rather than solutions, do you have any pointers? :)
05:46:19 <tomasmu> so buying for 2 and selling for 10 would yield 8
05:46:50 <shloub> what if you used scanl to compute the mins or maxs so far?
05:47:55 <shloub> i believe that leads to an efficient and simple way to solve it
05:48:19 <tomasmu> cool, i'll google for scanl and see where it takes me, thanks :)
05:48:30 <shloub> you're welcome
05:53:57 <shafox> I got disconnected from the server. Has anyone answered to my query that I have missed ? 
05:54:35 <nicknight> shafox:  you can find haskell logs
05:54:42 <nicknight> I am not sure of your question
05:55:28 <tomasmu> ongy: sorry, missed your question, the list i have is the current value of the product per day, which equals both sell and buy prices
05:56:03 <shafox> nicknight: I am trying to parse that xml to extract the element. in the person tag. But it gives me error on the InvalidEndElement. Where have I done wrong? 
05:56:09 <shloub> spoiler: http://paste.awesom.eu/5Ja0
05:56:39 <shloub> $ is not necessary, sorry
05:57:55 <lyxia> shloub: yeah the $ totally ruins it
05:58:21 <tomasmu> fakenullie: i have not managed to figure that out, though
05:58:38 <tomasmu> but the more different solutions the merrier =)
05:59:04 <shloub> lyxia, i thought the aim of the exercise was to make more $$$
05:59:07 <mauke> shafox: I think the error means it expects the <population> element to be empty
06:02:25 <lyxia> shloub: does that mean php is a good language for banks
06:03:47 <shloub> :)
06:05:47 <stevenxl> Hi folks. For those of you that use vim, how do you have your editor set up? I have vim-stylish-haskell installed, and for projects that dont' use that style, I have resorted to using a non-preferred editor so that it doesn't do automatic formatting. 
06:05:54 <stevenxl> Should I just get rid of vim-stylish-haskell?
06:13:44 <osa1> stevenxl: I have this line in my .vimrc `au FileType haskell nnoremap <leader>sh :%!stylish-haskell<CR>` with this I can run stylish-haskell manually easily
06:14:07 <osa1> I don't use any Haskell plugins, I just have a syntax file and some key bindings like the <leader>sh one
06:14:19 <stevenxl> osa1: thanks, I think i might go that route as well. 
06:23:45 <LeanderK> Hey, i have a HList defined and want to write a Functor instance if the types are actually homogenous. My heterogenous map is defined as a list of functions where the domain matches the types of the HList. Is this possible by resuing the mapH definition? Here is my code so far: http://lpaste.net/359248
06:27:07 * hackagebot servant-rawm 0.2.0.1 – Embed a raw 'Application' in a Servant API – https://hackage.haskell.org/package/servant-rawm
06:42:04 <lyxia> Functor HList won't have the right kind. But you can write a function with a signature like fmap rather than an actual Functor instance.
06:42:50 <phadej> or wrap in a newtype
06:43:03 <lyxia> I meant that Functor HList is ill-kinded, actually.
06:43:39 <phadej> indeed
06:44:39 * hackagebot indextype 0.2.3.0 – A series of type families and constraints for "indexable" types. – https://hackage.haskell.org/package/indextype
06:45:20 <royal_screwup21> I need a list of all binary strings with bit length = n. So if n =2, my output is: ["01","00","11","10"]. How do I go about this problem? I know that I'm looking at 2^n strings, but I'm at a loss when it comes to generating those strings
06:45:57 <lyxia> > replicateM 3 [0,1]
06:45:59 <lambdabot>  [[0,0,0],[0,0,1],[0,1,0],[0,1,1],[1,0,0],[1,0,1],[1,1,0],[1,1,1]]
06:46:13 <phadej> :)
06:46:21 <royal_screwup21> wow
06:47:32 <royal_screwup21> wait is replicateM even a function? I'm getting a "not in scope" error on ghci (I've imported Data.List)
06:47:54 <mauke> @index replicateM
06:47:54 <lambdabot> Control.Monad, Data.Sequence
06:48:02 <lyxia> You can also write a recursive function by hand: if you can enumerate strings of length (n-1), use that to enumerate strings of length n.
06:50:36 <royal_screwup21> hmm
06:51:30 <stevenxl> Hi folks. I have a question on this function: https://github.com/markandrus/twilio-haskell/blob/master/src/Twilio/Internal/Request.hs#L62
06:52:35 <stevenxl> The expression (return $ f) has the type RequestF (IO (FreeT RequestF m a)).
06:53:14 <mauke> more like return <$> f
06:53:36 <stevenxl> mauke: Yes, sorry
06:53:59 <stevenxl> But a value of that type is used as an argument to the run expression, and that pattern matches on the value like so: run (RequestF (request, go))
06:54:05 <stevenxl> Where did the rest of the structure go?
06:54:34 <mauke> what rest of what structure?
06:55:26 <stevenxl> I'm having trouble understanding how this type: RequestF (IO (FreeT RequestF m a)) matches this value: (RequestF (request, go))
06:55:47 <mauke> types don't match values
06:56:16 <mauke> what's the type of RequestF (the data constructor?
06:56:59 <mauke> apparently it's: (Request, Response ByteString -> a) -> RequestF a
06:57:00 <stevenxl> RequestF :: (Request, Response LBS.ByteString -> a) -> RequestF a
06:57:11 <mauke> so there you go
06:57:50 <mauke> presumably request is a value of type Request, and go is a value of type Response ByteString -> IO (FreeT RequestF m a)
06:58:49 <stevenxl> mauke: I see what you are saying. Thank you. 
07:00:13 <geekosaur> looks to me like you are confusing the type constructor with the data constructor
07:00:36 <geekosaur> admittedly that is easy to do when the programmer names them both the same thing
07:00:54 <stevenxl> geekosaur: Yea, but it's also very common so I better get used to it. 
07:01:29 <stevenxl> For some reason I wanted to map type to a value of the same "shape", if that makes any sense, instead of looking at the declaration for the type.
07:04:07 <EvanR> to define a type to value mapping, use type classes
07:04:31 <royal_screwup21> is it possible to put multiple if else statements inside map? Like so: map (\x -> if x<2 then "less than 2" else if x<5 then "less than 5" else "high") [<some ints>]. I know it
07:04:46 <EvanR> though you will have to use a proxy hack if the value depends on the type alone
07:05:13 <royal_screwup21> *I know it's syntactically invalid, but is there a way to allow to take multiple conditions?
07:05:18 <EvanR> you can use multiple nested ifs
07:05:23 <oisdk> Is there any info out there on generating minimal pattern-matching definitions given a function? (like for (x && y) = case (x,y) of (True,True) -> True; (_,_) -> False) Currently struggling through some of the stuff on compiling pattern-matching code efficiently, wondering if there's something more specific.
07:05:24 <EvanR> or you can use multi-way if
07:05:55 <lyxia> royal_screwup21: what you wrote actually looks valid
07:06:07 <mauke> > map (\x -> if x<2 then "less than 2" else if x<5 then "less than 5" else "high") [1, 2, 5, 6]
07:06:11 <lambdabot>  ["less than 2","less than 5","high","high"]
07:06:36 <royal_screwup21> this language never fails to surprise me
07:06:48 <mauke> if/else is not a statement, btw; it's an expression
07:07:55 <lyxia> oisdk: these two functions of x and y don't have the same strictness BTW
07:13:19 <oisdk> lyxia In which case? It seems like it works the same as normal (&&)
07:13:37 <oisdk> @let and x y = case (x,y) of (True,True) -> True; (_,_) -> False
07:13:39 <lambdabot>  Defined.
07:13:45 <oisdk> > and False undefined
07:13:48 <lambdabot>  error:
07:13:48 <lambdabot>      Ambiguous occurrence ‘and’
07:13:48 <lambdabot>      It could refer to either ‘Data.List.and’,
07:14:08 <oisdk> @let lazyAnd x y = case (x,y) of (True,True) -> True; (_,_) -> False
07:14:10 <lambdabot>  Defined.
07:14:25 <oisdk> > lazyAnd False undefined
07:14:28 <lambdabot>  False
07:15:38 <lyxia> uhm... you are right! Nevermind.
07:16:09 <mauke> @undefine
07:16:09 <lambdabot> Undefined.
07:16:27 <geekosaur> pretty sure the Report specifies that behavior (re pattern matching)
07:16:42 <lyxia> yeah I was just confused.
07:19:42 <erisco> challenge: and False undefined = and undefined False = False
07:20:27 <oisdk> erisco and _ _ = False
07:21:25 <geekosaur> you might want to test that
07:21:37 <erisco> heh, well then  and True x = x; and x True = x  as well
07:21:46 <lyxia> @hackage lub
07:21:46 <lambdabot> http://hackage.haskell.org/package/lub
07:22:14 <lyxia> for your challenge.
07:26:06 <ttoe> has anyone worked with ihaskell notebooks to solve ODEs, using hmatrix-gsl?
07:26:37 <ttoe> For me the kernel dies, as soon as i want to look at the solution of the system.
07:27:54 <ttoe> I guess it has something to do with hmatrix calling GSL and that does not work together with ihaskell?
07:28:19 <cocreature> % (\x y -> case (unsafePerformIO . try . evaluate) x :: Either SomeException Bool of Left _ -> (case y of False -> False; True -> undefined); Right False -> False; Right True -> y) False undefined
07:28:19 <yahb> cocreature: False
07:28:25 <cocreature> % (\x y -> case (unsafePerformIO . try . evaluate) x :: Either SomeException Bool of Left _ -> (case y of False -> False; True -> undefined); Right False -> False; Right True -> y) undefined False
07:28:26 <yahb> cocreature: False
07:28:29 <cocreature> % (\x y -> case (unsafePerformIO . try . evaluate) x :: Either SomeException Bool of Left _ -> (case y of False -> False; True -> undefined); Right False -> False; Right True -> y) True True
07:28:29 <yahb> cocreature: True
07:31:12 <EvanR> best haskell software rendering! http://lpaste.net/359250
07:32:13 <dfsafd> suppose we have an int sequence and a binary function Int -> Int -> Int, how do you find the pair for which the function is the smallest?
07:32:48 <Cooler> anyone familiar with z3?
07:33:07 <geekosaur> ttoe, I suspect gsl uses gmp internally. gmp is not well designed for multiple users with different memory allocators
07:33:07 <Cooler> is there a channel for z3?
07:33:08 <erisco> Cooler, just ask
07:33:25 <erisco> dfsafd, what is the relevance of the ints being in a sequence?
07:33:31 <Cooler> erisco: well its off topic here
07:33:37 <erisco> then don't ask :)
07:33:43 <cocreature> Cooler: there is #haskell-offtopic :)
07:33:55 <geekosaur> and gsl using haskell's allocator will cause *big* problems because haskell will happily move its allocations out of the nursery leabing gsl holding bogus pointers
07:33:59 <cocreature> dfsafd: just calculate the results for all inputs and then find the minimum?
07:34:13 <dfsafd> the types does not matter :)
07:34:31 <dfsafd> consider the list a list of vectors in some vector space
07:34:47 <dfsafd> my job is to find the vectors closest to each other
07:35:24 <ttoe> geekosaur: so using ihaskell is no option then, i guess? what a pity
07:35:49 <ttoe> geekosaur: or i could try and find some native haskell library for ODEs
07:36:29 <geekosaur> actually, I wonder if that is true. because that should make hmatrix-gsl impossible unless it is very careful
07:36:47 <dfsafd> the "binary function" i described, measures the vectors distance
07:36:59 <geekosaur> which it might be but in ways incompatible somehow. but I don't know what the jupyter kernel is doing interally; for all I know it uses gmp in some cases and that's whats explocd
07:37:03 <geekosaur> ...exploding
07:44:36 <benzrf> % unsafePerformIO (print 30
07:44:36 <yahb> benzrf: ; <interactive>:11:26: error: parse error (possibly incorrect indentation or mismatched brackets)
07:44:38 <benzrf> % unsafePerformIO (print 3)
07:44:38 <yahb> benzrf: 3; ()
07:44:46 <benzrf> 🤔
07:45:26 <EvanR> !ops
07:45:55 <EvanR> they figured out how to use unsafePerformIO
07:46:05 <ongy> canI somehow tell when a version of a package has been upladed to hackage?
07:47:11 <ongy> EvanR: yahb is a sandboxed bot that's supposed to support IO and unsafe functions. (also lambdabot uses @ops iirc)
07:47:28 <barrucadu> is "yahb" "yet another haskell bot"?
07:49:48 <geekosaur> not @ops either. and the correct thing to do is to join #haskell-ops, not have the bot ping people
07:51:57 * hackagebot text-format-heavy 0.1.3.0 – Full-weight string formatting library, analog of Python's string.format – https://hackage.haskell.org/package/text-format-heavy
08:03:42 <dfsafd> what's the function for sorting a list by a key?
08:04:20 <geekosaur> depends on what you mean by key
08:04:27 <geekosaur> :t sortBy
08:04:29 <lambdabot> (a -> a -> Ordering) -> [a] -> [a]
08:04:32 <geekosaur> :t sortOn
08:04:33 <lambdabot> Ord b => (a -> b) -> [a] -> [a]
08:04:53 <[exa]> also
08:04:55 <[exa]> :t sortWith
08:04:57 <lambdabot> error: Variable not in scope: sortWith
08:05:13 <[exa]> looks like my hask-fu is out of date though
08:05:13 <dfsafd> can "sorting a list by a key" really mean more than one thing?
08:05:24 <geekosaur> it can mean:
08:05:38 <geekosaur> (a) you have a list of lists and think sorting by some element of the sublist should be primary functionality
08:05:40 <[exa]> dfsafd: well, there's the list of things, there's sorting algorithm, where do we get a key?
08:05:41 <shloub> @index sortOn
08:05:41 <lambdabot> GHC.OldList, Data.List
08:05:51 <geekosaur> (b) you have a list of strings and think splitting tat into fields should be primary functionaly
08:06:00 <shloub> can't find sortOn on hoogle oO
08:06:08 <geekosaur> (c) you have a list of records and want to sort on a projection thereof
08:06:46 <geekosaur> the hoogld db i out fo date, unless you are using hoogle.haskell.org which has other issues (hoogle v5 is still alpha quality)
08:07:04 <geekosaur> . . .
08:07:12 <geekosaur> "the hoogle db is out of date..."
08:07:29 <dfsafd> geekosaur: your three examples are all manifestations of the same pattern
08:07:50 <geekosaur> but they are patterns that many people thik *are* primary functionality
08:07:56 <shloub> thanks
08:08:05 <geekosaur> and if you do not consider them primary then I'm not sure how you missed sortBy and sortOn
08:08:48 <geekosaur> (well, aside from considering IRC to be the better alternative to hoogle/hayoo or the Data.List haddock)
08:09:24 <dfsafd> i did google it, but i ended up on the page https://www.haskell.org/hoogle/?hoogle=sortWith
08:10:11 <dfsafd> sortBy appears to sort by a comparator, not a key
08:10:13 <ongy> I'm trying to build a package which requires c2hs as build tool. to work around a bug in language-c (dependency of c2hs) I tried adding language-c (with a patch) and c2hs to my project. I removed dist and dist-newstyle. now when I try to build I get http://lpaste.net/359252 I'm on recent-ish cabal-install git HEAD
08:10:44 <EvanR> :t sortBy . comparing
08:10:46 <lambdabot> Ord a1 => (a2 -> a1) -> [a2] -> [a2]
08:11:04 <EvanR> :t sortBy . comparing even
08:11:05 <lambdabot> error:
08:11:05 <lambdabot>     • Couldn't match type ‘Ordering’ with ‘a -> Ordering’
08:11:05 <lambdabot>       Expected type: a -> a -> a -> Ordering
08:11:08 <dfsafd> sortOn however, appears to be right. thanks
08:11:43 <EvanR> :t sortBy (comparing even)
08:11:44 <lambdabot> Integral a => [a] -> [a]
08:12:16 <EvanR> > sortBy (comparing even) [1, 2, 3, 4, 5, 6, 7]
08:12:19 <lambdabot>  [1,3,5,7,2,4,6]
08:12:21 <cocreature> ongy: the problem is that c2hs has a constraint on language-c that forbids languagec-0.7
08:13:10 <dfsafd> EvanR: "sortOn f is equivalent to sortBy (comparing f), but has the performance advantage of only evaluating f once for each element in the input list"
08:13:22 <ongy> ah, I thought there was some issue with cabal wanting to use something it build earlier. didn't check the current version. thx
08:14:17 <geekosaur> dfsafd, this is Haskell.
08:14:58 <cocreature> ongy: cabal has a selective allow-newer these days try putting "allow-newer c2hs:language-c" in your cabal.project.local
08:15:29 <geekosaur> ... a comparator is somehow not capable of specifying arboitrary parts of your values for comparison?
08:16:13 <EvanR> what does "sort by key" mean
08:17:18 <dfsafd> this is #haskell, so obviously i should have written "sort using the Schwartzian transform" not "sort by key" :)
08:17:21 <geekosaur> they alredy deflected that one with an answer that somehow did not also answer their own later remark
08:17:21 * hackagebot translate-cli 1.0.0.0 – Translation cli tool – https://hackage.haskell.org/package/translate-cli
08:18:10 <geekosaur> ok, so now mwe #twentyquestions around what you don;t feel like answering because it's obvious to you and therefore to everyone.
08:20:05 <ongy> cocreature: thx. let's see if it builds
08:23:40 <cocreature> ongy: judging from https://github.com/haskell/c2hs/pull/193/files it won’t :)
08:27:16 <ongy> cocreature: that PR builds. good enough for me :)
08:28:23 <ongy> can I somehow check cabal picks up the correct c2hs?
08:29:16 <ongy> ah it did, meh
08:34:49 <ongy> ha, got it to do what I want. nice
08:43:36 <EvanR> is there a way to get an FD to act like a bounded buffer, if you try to write more bytes than it currently allows, blocks until it can. and the amount is customizable
08:49:49 <EvanR> apparently you cant make a pipes buffer smaller than a page
08:50:44 <EvanR> in linux
09:01:59 <dfsafd> here is my function for finding the smallest distance in a list, given a metric:
09:02:03 <dfsafd> head $ sortOn key [(x, y) | (x:ys) <- tails seq, y <- ys]
09:02:33 <EvanR> theres also minimumBy
09:02:35 <EvanR> :t minimumBy
09:02:37 <lambdabot> Foldable t => (a -> a -> Ordering) -> t a -> a
09:02:42 <drdo> Shouldn't "import Data.Sequence (Seq (..))" also import the pattern synonyms (:<|) and friends?
09:02:58 <EvanR> :t minimumBy (comparing even)
09:02:59 <lambdabot> (Integral a, Foldable t) => t a -> a
09:03:44 <dfsafd> but minimumBy uses a comparison function, not a key function
09:04:34 <drdo> Nevermind, I just have an old version of containers
09:16:29 <fabler> Hello, programmers. I have problem with IO operations in threads, so does anyone knows good tutorial about MVars?
09:16:50 <mauke> what would that tutorial say?
09:16:57 <Rembane> fabler: What do you want to do?
09:18:50 <geekosaur> fabler, what kind of problem? and. . would this be in ghc 8.2.1 by any chance?
09:19:11 <fabler> Here is my code: https://pastebin.com/PWv66vaB. What I trying to do: I want write data to file from different threads (Example: two connections writing one file).
09:19:46 <fabler> Should I use some kind of MVars in my code?
09:20:34 <EvanR> unless you synchronize somehow, the two threads output will be interleaved in the file
09:21:05 <EvanR> so one way is to deposit lines of text into the MVar, and have one thread take lines and put them in the file one by one
09:21:39 <EvanR> only one line will be in the MVar at a time
09:21:53 <mauke> or: store the handle in an mvar
09:22:25 <mauke> do { h <- takeMVar v; hPutStr h myString; putMVar v h }
09:23:11 <fabler> Aha! That was what I needed! Do you have some good tutorial about MVars, or good article to read? Because I read docs on Hoogle and don't understand a little.
09:23:16 <fabler> mauke, thanks!
09:23:30 <EvanR> the documentation in Control.Concurrent is pretty good
09:24:14 <fabler> So, I read it, and there was no examples
09:24:31 <mauke> http://hackage.haskell.org/package/base-4.10.0.0/docs/Control-Concurrent-MVar.html
09:24:57 <EvanR> read it more carefully?
09:25:21 <fabler> Ok, thanks
09:26:57 <fabler> Also, if I understand right: I should create MVar in main, and then "send" it to thred, right?
09:27:34 <EvanR> that would probably work. but you can create it anytime as long as you can get it to the threads that need it
09:28:25 <geekosaur> the easy way to adapt your code is to make the MVar in main, put f in it, and ass the MVar instead of f
09:28:52 <geekosaur> oh, also: you should not need to flush h before closing it; closing it flushes it
09:29:02 <fabler> Hm, interesting, that is much more understandable
09:30:18 <geekosaur> (also, for those wondering why I asked the ghc version: https://ghc.haskell.org/trac/ghc/ticket/14346)
09:31:04 <fabler> No, I'm using version 8.0.2 from gentoo overlay
09:31:16 <fabler> Thanks for that, geekosaur!
09:45:27 <vivekramaswamy> Hello all a quick question http://lpaste.net/359254
09:47:15 <shloub> /x->x*x
09:47:19 <shloub> what does that mean?
09:48:14 <EvanR> probably a misspelling of \x -> x * x
09:48:23 <shloub> [(\a->a*a) x|x<-[1..100]] ?
09:48:40 <EvanR> its a lambda, an anonymous function
09:48:45 <EvanR> which squares its argument
09:49:15 <vivekramaswamy> oh my bad, I ended up spending sometime but could not figure it out. Thanks and sorry about the wrong question
09:52:21 <dfsafd> can you make a tree of tuples/lists in haskell? im trying to build a data structure like this: [(5,(2,3)), 4, (7,6)]
09:53:51 <EvanR> no
09:53:58 <EvanR> everything in the list has to have the same type
09:54:31 <EvanR> you can make a tree with that structure, but it cant literally be a list
09:56:03 <dfsafd> ok so I have to convert it to something like [Node (Leaf 5) (Node (Leaf 2) (Leaf 3)), (Leaf 4), ...]?
09:56:38 <EvanR> here is a basic tree
09:57:05 <EvanR> data Tree a = Leaf a | Node [Tree a]
09:57:15 <EvanR> here is another
09:57:23 <EvanR> data Tree a = Tree a [Tree a]
09:59:03 <EvanR> what you wrote seems to only make sense if you wanted exactly 3 branches at each node
09:59:16 <EvanR> and the outer list is something else
09:59:28 <dfsafd> the outer list was a forest
09:59:36 <EvanR> right
10:00:05 <dfsafd> what im creating is a binary tree where only the leaves contain data
10:01:01 <EvanR> data Tree a = Node (Tree a) (Tree a) | Leaf a
10:01:41 <EvanR> which doesnt really help you search for anything
10:02:06 <dfsafd> it's not a bst so that's ok
10:05:56 <dfsafd> it's a newick tree actually
10:28:32 * hackagebot tyfam-witnesses 0.1.1.1 – Provide proof witnesses for closed type family evaluation – https://hackage.haskell.org/package/tyfam-witnesses
10:37:57 <EvanR> ls
10:38:33 <hpc> [sudo] Password for EvanR:
10:39:06 <EvanR> lens did not compile all night on the rpi
10:39:20 <EvanR> i think the result was a dead sshd
10:40:14 <iqubic> EvanR: That sucks.
10:40:46 <EvanR> sdl requires linear requires ... requires lens
10:41:03 <iqubic> That really sucks.
10:42:20 <iqubic> What are the best Haskell frame works for doing Game Development?
10:42:45 <iqubic> s/frame works/frameworks/
10:46:00 <EvanR> there is lambdacube 3D
10:46:14 <EvanR> other than that, its up to you to mix and match libraries
10:48:01 <iqubic> What does lambdacube 3D do?
10:48:08 <EvanR> its a 3D engine
10:49:02 <iqubic> I want to make 2 games though.
10:49:15 <iqubic> I might write my own DSL like thing.
10:49:18 <Rembane> Gloss!
10:49:30 <Rembane> Oh well, OpenGL, but anyway...
10:49:34 <iqubic> Something like this: http://www.puzzlescript.net/
10:49:53 <iqubic> I might make a DSL to do something like that.
10:50:20 <iqubic> But I have no idea how DSLs actually work.
10:50:29 <iqubic> At least not big complex ones.
10:52:00 <EvanR> a DSL is just a stupid data structure
10:52:17 <EvanR> or the other way around
10:52:43 <iqubic> Is it really?
10:52:52 <iqubic> Do you use DSLs EvanR?
10:53:20 <EvanR> every data type you design and include operations for could be considered a DSL
10:53:35 <EvanR> its just a matter of what level of functional programming youre on
10:54:01 <EvanR> the chapter in SICP on image manipulation is a great example
11:01:30 <dfsafd> how do you alias data constructors? i want to write type L = Leaf, but it doesnt work
11:02:44 <EvanR> Leaf isnt a type
11:02:57 <EvanR> you can do leaf = Leaf
11:03:11 <dfsafd> i know, it is a data constructor
11:03:42 <EvanR> so you cant define a type as it
11:03:42 <dfsafd> leaf like Leaf is four letters, L is only one
11:03:52 <EvanR> theres l
11:03:57 <aarvar> dfsafd: you can use pattern synonyms
11:04:17 <dfsafd> l will do, but L would have been preferable
11:04:39 <aarvar> pattern L = Leaf
11:05:07 <dfsafd> it says, not in scope data constructor
11:05:19 <aarvar> enable the PatternSynonyms extension
11:05:23 <iqubic> You need to use the right language pragma
11:05:42 <aarvar> but then you also need complete pattern pragmas to get exhaustiveness warnings, and those require ghc 8.2
11:05:47 <nschoe> Hi all, I have a small issue: with this code (http://lpaste.net/359255) I'm trying to make my data type 'BootstrapPeer' an instance of 'FromRow' to use with `postgresql-simple`, but I've got error "‘fromRow’ is not a (visible) method of class ‘FromRow’"
11:05:51 <nschoe> What should I do to fix this?
11:05:58 <cheater> hi
11:06:07 <aarvar> so pattern synonyms still arent really ideal
11:08:10 <iqubic> No, not at all.
11:08:33 <cheater> i would like to create a simple persistence store for my program. it's a single-user application, and the data is just usual ADTs that contain simple types. this should be stored in a single file. human readability is not important. the data will be at most a couple megabytes. can someone suggest a simple library that can do this? my main requirement is for the library to be easy to use - something ...
11:08:39 <cheater> ... like store :: DB -> a -> IO () and retrieve :: DB -> IO a.
11:09:32 <aarvar> nschoe: maybe you need to import fromRow from somewhere?
11:09:42 <cocreature> nschoe: import Database.PostgreSQL.Simple.FromRow
11:10:12 <nschoe> cocreature, yeah I was browsing hackage and I jsut found this. But... has this changed recently? Every tutorials I see on Internet do not mention this at all
11:10:37 <cocreature> nschoe: maybe these tutorials don’t use the fromRow method?
11:11:19 <nschoe> cocreature, yes they do, I followed them in order to know hwo to write the instance
11:11:44 <nschoe> cocreature, besides, the documentaiton for the package (https://hackage.haskell.org/package/postgresql-simple-0.5.3.0/docs/Database-PostgreSQL-Simple.html) also shows how to do this and they don't mention the import
11:11:50 <nschoe> Let me check with the import if this works :)
11:11:52 <cocreature> nschoe: not sure then, it’s been like that for at least a few months
11:12:22 <cocreature> nschoe: well they don’t mention any import in the corresponding docs
11:12:29 <nschoe> indeed
11:12:41 <nschoe> cocreature, this is why I don't understand if I'm doing smth wrong or not :/
11:13:44 <nschoe> cocreature, it does work with the import
11:13:51 <nschoe> Thank you
11:15:10 <cocreature> tbh, I’m not sure why it isn’t just exported from the main module
11:15:48 <nschoe> cocreature, I suppose it used to be (that's the only explanation I can think of why the other tutorials don't mention the import specifically)
11:20:24 <EvanR> heh, my plan to generate 320x240 graphics entirely with functional programming probably wont work on rpi cpu
11:20:39 <EvanR> its at 100% cpu usage
11:21:23 <Welkin> cheater: acidstate or sqlite using persistent
11:21:58 <Welkin> acid state is in-memory, so I suppose you would want sqlite
11:22:10 <Welkin> for which you can use the persistent library
11:22:46 <EvanR> acid state is not just in memory, but you need to be able to have the whole db in memory
11:23:17 <Welkin> oh wait
11:23:29 <Welkin> yeah, it looks like it is written to disk as well
11:23:39 <EvanR> thats the D part of acid
11:24:12 <johnw> as I understand it, acid-state is just a persistent transactional heap
11:24:37 <johnw> it's not an external data store with caching
11:24:46 <fakenullie> how is this persistent
11:24:56 <johnw> it saves state between process executions
11:25:02 <fakenullie> oh
11:25:03 <EvanR> if you "crash only" crash your program and reboot, the state is still there
11:25:09 <Welkin> https://github.com/acid-state/acid-state
11:25:23 <Welkin> well, it doesn't support schema migrations though
11:25:31 <sdx23> best imagine it as a statemonad that persists over program restarts.
11:25:33 <EvanR> it does, using safe-copy
11:25:39 <EvanR> made specifically for acid state, aiui
11:34:31 <cheater> Welkin: thanks
11:35:06 <cheater> acid state sounds ok
11:45:54 <dfsafd> how can i declare a function type?
11:45:56 <dfsafd> like this: type DistanceKey = (Int -> a -> a -> Double)
11:46:14 <Myrl-saki> What does it take to port ghc to a different OS?
11:46:35 <iqubic> Myrl-saki: What OS do you want to port it too?
11:46:52 <Myrl-saki> iqubic: I don't think I'd be able to port it, but I wanna play around with Plan9.
11:51:08 <cocreature> Myrl-saki: https://ghc.haskell.org/trac/ghc/wiki/Building/Porting
11:55:27 <Myrl-saki> cocreature: Thanks.
11:59:24 <Welkin> isn't plan9 an operating system that stopped development decades ago?
12:00:35 <Welkin> also, a sci-fi film from the 1950s
12:01:03 <Myrl-saki> Welkin: Yeah, it is.
12:01:51 <Myrl-saki> Welkin: I'm just interested in how it's more unix than UNIX.
12:13:02 <mivael_> hello all
12:14:11 <cocreature> hey mivael_ 
12:15:11 <mivael_> cocreature: nice to see you
12:15:18 <mivael_> I'm struggling to find examples which would show that Data.Semigroup.Option is practically different from Maybe.  Failed so far.
12:16:19 <mivael_> In which way Option is "a better Monoid for Maybe"?  Does anyone know?
12:16:38 <cocreature> mivael_: it’s more general
12:16:49 <cocreature> for Maybe you have "instance Monoid a => Monoid (Maybe a)"
12:17:17 <cocreature> but that doesn’t really make sense since that instance doesn’t use the "mempty" part of "Monoid a" since "Maybe a" already provides an identity in the form of "Nothing"
12:17:33 <cocreature> Option has the instance "instance Semigroup a => Monoid (Option a)"
12:17:48 <cocreature> so it doesn’t force you to provide an identity element which is then not used
12:17:48 <Welkin> never heard of that
12:17:56 <Welkin> I can't find Data.Semigroup.Option in any docs either
12:18:01 <Welkin> what package is it from?
12:18:13 <cocreature> Welkin: http://hoogle.haskell.org/?hoogle=Option
12:18:51 <mivael_> Welkin: http://hackage.haskell.org/package/base-4.10.0.0/docs/Data-Semigroup.html#t:Option
12:22:47 <mivael_> cocreature: trying to comprehend... I will now look into (Monoid (Maybe a)) instance source code and let you know.
12:23:51 <cocreature> mivael_: basically if you can use the Monoid instance of Maybe then there is no difference. But if "a" is _only_ an instance of Semigroup but not an instance of Monoid, you can’t use the Monoid instance of Maybe but you can use the instance of Option
12:29:28 <johnw> When I'm at the airport and they ask me for my id, I should answer, "But officer, I'm a semigroup."
12:29:48 <Welkin> no, because they are not officers
12:30:03 <Welkin> they are minimum wage thugs
12:30:22 <johnw> when I start my sentences with "Dear minimum wage thug", they don't hear the rest of the sentence
12:53:33 <crucify_me> hello I'm still alive
12:54:30 <crucify_me> its interesting that graham hutton's book begins the first chapter with an example of a monad. I thought it was for beginners. scary
12:54:42 <crucify_me> *ends the first chapter
12:55:09 <fakenullie> get the haskell book
12:55:33 <fakenullie> I kind understand the monad now
12:55:35 <crucify_me> got it, its so long it bums me out
12:56:15 <crucify_me> nice moniker fakenullie 
12:57:18 <EvanR> ending the first chapter with an example of a monad doesnt sound bad at all
12:57:45 <iqubic> What book are we taling about?
12:58:07 <fakenullie> I'm talking about http://haskellbook.com/
12:59:07 * hackagebot tomlcheck 0.1.0.9 – Command-line tool to check syntax of TOML files – https://hackage.haskell.org/package/tomlcheck
13:03:40 <stevenxl> @crucify_me I also have the Haskell Book. It is very long. I had to take it slow. It's a great book. There's a lot of effort learning Haskell (for me), but I think that it is necessary. The book is not making it harder than it needs to be -it's just hard. 
13:03:40 <lambdabot> Unknown command, try @list
13:05:34 <maerwald> Monad is like love... everyone knows what it is, but it's hard to explain
13:05:45 <maerwald> you have to experience it
13:06:11 <johnw> lol
13:06:38 <johnw> I imagine Zen monks in a monastery somewhere: "Ah, monad, so that's nameless name."
13:08:43 <crucify_me> stevenxl, thanks for the encouragement. 
13:09:19 <stevenxl> crucify_me: sure.
13:11:23 <etiago> stevenxl, fakenullie, it´s the second time I see the Haskell Book mentioned here... is it really as good as reviews make it to be?
13:11:38 <etiago> or is it Yet Another Haskell Book and I´m just better off sticking to LYAH
13:11:50 <EvanR> LYAH :(
13:12:11 <Boarders> personally I found it to be way too long
13:12:57 <stevenxl> etiago: I don't think I would have gotten anywhere with LYAH by itself. I think it is great if you have an understanding already, and want to use it as a reference, but to actually learn what's going on, I'm a big proponent of the Haskell Book. 
13:12:59 <grizwako_> if you are self learning and have no functional experience, Haskell Book is great because of the assignments
13:13:13 <maerwald> lyah is the thing you can do after 3 glasses of wine
13:13:29 <mivael_> :t (<>) `foldr1` map Data.Semigroup.Max [123,456]
13:13:31 <lambdabot> (Num a, Bounded a, Ord a) => Data.Semigroup.Max a
13:13:32 <etiago> maerwald, lol
13:13:43 <mivael_> > (<>) `foldr1` map Data.Semigroup.Max [123,456]
13:13:45 <lambdabot>  error:
13:13:45 <lambdabot>      Not in scope: data constructor ‘Data.Semigroup.Max’
13:13:45 <lambdabot>      No module named ‘Data.Semigroup’ is imported.
13:13:55 <etiago> I might get the Haskell Book then
13:14:04 <etiago> I think some small practical exercises will help me
13:14:06 <stevenxl> etiago: I wish I could use LYAH. It's a funner book I think. Has drawings, is much shorter, but frankly it's not deep enough for me. 
13:14:27 <EvanR> if you like pictures...
13:14:40 <EvanR> http://www.happylearnhaskelltutorial.com/
13:14:47 <mivael_> How to make lambdabot to "import Data.Semigroup(Max)"?
13:14:53 <etiago> stevenxl, I get exactly the same feeling
13:15:23 <grizwako_> LYAH is great resource anyway, if some concepts are foggy after seeing them in Haskell Book, LYAH helps in seeing a different approach to same theme
13:15:52 <stevenxl> EvanR: Thank you. That does look like fun. ;)
13:16:09 <EvanR> personally i would like pictures of actual haskell stuff
13:16:17 <Boarders> I learnt by reading yet another haskell tutorial and then writing some parsers (though I am bad at haskell)
13:16:42 <EvanR> like, demonstrating lazy evaluation, or heap object sharing, or...
13:16:56 <erisco> ++parsing
13:17:36 <etiago> oh wow, Haskell Book is definitely on the pricey side :(
13:17:37 <erisco> not many people are interested in parsing though, so not a great example to base a book on
13:19:03 <stevenxl> etiago: At the end of the day here is my deal. Learning Haskell is not easy. It's not always fun. It takes time, it takes effort, and I'd be embarrassed to tell you how long I've been at it. (Though I am doing all the exercises). 
13:20:02 <etiago> stevenxl, that´s the thing though, it´s difficult but rewarding... because it shows a very different perspective on programming than what most people are used to
13:20:04 <stevenxl> But I want to be able to write software that doesn't turn into a mess after two to three months. I want software that is maintainable, and I don't want to be scared to change things around. 
13:20:05 <EvanR> learning haskell may not be fun, or easy, or make you rich, or be useful, or teach you anything, or ... wait
13:20:09 <etiago> that´s my reason for learning Haskell anyway
13:21:05 <erisco> Haskell inspires you to write Haskell tutorials
13:21:11 <stevenxl> lol.
13:21:35 <EvanR> its unpopular, it alienates you from mainstream programming, people think youre elitist, 
13:21:57 <Rembane> And it will make you unhappy when all other programming languages become ugly.
13:24:27 <maerwald> not all
13:25:02 <etiago> sure, you´ll still like frege :-)
13:31:39 <crucify_me> funny comments thanks!
13:51:31 * hackagebot bool8 0.0.1 – Alternative Bool type stored as byte – https://hackage.haskell.org/package/bool8
14:01:58 <GamboPango> Hi everyone.  I have two type level lists of kind '['(Symbol, *)] (I think) and I want to use (++) on them, but GHC rejects this.  Is there a way to concatenate type-level lists of this form?
14:02:29 <GamboPango> What is the kind signature of '++ anyway?  Is it poly-kinded?
14:06:46 <GamboPango> OK, defining a type family (:++) with an explicit kind signature seems to do the trick.
14:27:10 <Welkin> it looks like crucify_me isn't here any more, but what is wrong with introducing monads at the end of the first chapter? how is that scary?
14:27:16 <Welkin> a monad is a very simple concept
14:28:09 <Welkin> Elm does a good job of introducing it using `andThen`
14:28:45 <Welkin> I feel that people make a big deal out of nothing in programming all the time
14:29:03 <Welkin> the whole oop cargo cult is especially guilty of this
14:29:59 <Welkin> or even recently I found a blog post on currying and partial application in javascript, and there are dozens of these articles
14:30:29 <Welkin> it was a couple thousand words to explain something very simple
14:31:03 <Welkin> and the implementation was some monstrosity using `apply` and `call` instead of just showing manual currying and partial application was *normal) function application
14:31:45 <hexagoxel> you are making fallacies made by (many) individuals into an "oop cargo cult" :p
14:32:16 <Welkin> what?
14:33:48 <Welkin> I feel like there is too much "fear, uncertainty, and doubt" spread around about functional programming concepts
14:34:09 <Welkin> it is especially bad because so many people misunderstand it and then go on to explain it wrongly to other people
14:34:12 <Welkin> and it goes on
14:34:28 <Welkin> I found many "functional programming" libraries that confused `compose` with `curry`
14:35:03 <sm> I think hexagoxel is saying the same thing happens about OOP, and you're doing it :)
14:35:32 <Welkin> this isn't much of an issue inside communities like haskell, but for people in the js or other ecosystems, it is a huge problem
14:36:00 <Welkin> sm: I don't understand what you are saying
14:36:32 <EvanR> js or other developer needed, must have 5+ years experience in js or other
14:36:40 <Welkin> lol
14:37:13 <Welkin> I recently spoke with some recruiter that contacted me, and they said over the phone "you can use any language you want for the interviews... as long as it is an object oriented one"
14:37:28 <Welkin> at that point I wanted to say "k, thanks, bye"
14:37:28 <maerwald> use C then
14:37:42 <EvanR> dont use C++ then
14:37:43 <sm> it seemed like you dismissed all of OOP as a cargo cult just now, not recognising any of the smart contributions made in that field
14:38:08 <Welkin> sm: well, it depends on what you mean by OOP
14:38:12 <Welkin> are you talking about smalltalk?
14:38:14 <Welkin> or java?
14:38:20 <Welkin> when I say oop, I mean java oop
14:38:26 <Welkin> which is what 99% of people know
14:39:14 <EvanR> when you say oop, you mean java, which is surprising to me and off topic
14:40:46 <athan> Hey all, I'm trying to read a file manually using the unix library, but failing miserably. I'm trying to do this as an exercise, so please try to not suggest a 1-show-pony solution to fix my bugging :) http://lpaste.net/359264
14:41:11 <Welkin> athan: 你好
14:41:27 <athan> Basically, I am seeing the text being read in the calls to "Actually read", but after the loop is finished I'm still just getting an empty string
14:41:39 <athan> so I'm wondering if a pointer is getting borked or something
14:41:45 <Welkin> athan: what about a pony with 6 legs?
14:42:13 <athan> o/ Welkin
14:42:15 <sm> what about a lazy pony?
14:42:23 <Welkin> c ffi
14:42:24 <Welkin> o.o
14:42:36 <Welkin> ffi is always a black hole
14:42:48 <athan> I mean I'm technically not ffi'ing myself :D
14:42:50 <Welkin> mostly I feel that pain with js ffi
14:43:04 <EvanR> athan: i am confused by the from integral and mempties...
14:43:47 <athan> EvanR: `createUpToN` asks to return an `IO Int`, not an `IO CSize` I think
14:44:03 <EvanR> so mempty is being used as zero and as empty string ?
14:44:04 <athan> and `mempty :: Data.ByteString.Lazy.ByteString`
14:44:11 <athan> yep!
14:44:19 <athan> only if there was no text scanned
14:44:24 <EvanR> 0 and "" would work...
14:44:35 <athan> WAIT
14:44:38 <athan> ugh I'm sorry
14:44:49 <athan> it should be `pure acc`
14:44:51 <athan> ><
14:44:54 <athan> thanks everyone
14:45:26 <sm> irc rubber duck technique wins again!
14:45:41 <EvanR> if you split up each weirdo step into a function that returned standard types, might help
14:46:11 <EvanR> <>-ing lazy byte strings to the end of an accumulator is probably bad too
14:51:54 <ertes> sm: it's rare, but i agree 100% with Welkin there…  i think the only noteworthy contribution OOP has made to software engineering is a collection of delightfully challenging puzzles
14:51:59 <ertes> i think they call them "design patterns"
14:52:41 <maerwald> the misconception is that all people associate "mutable state" with OOP
14:53:10 <ertes> they are the kind of puzzle, where the solution actually just gets you to the next level
14:53:51 <ertes> i mean the java style of OOP, not the smalltalk style
14:54:06 <ertes> so yes, i'm talking about OOP to manage state
14:54:47 <maerwald> also, if you see how annoying C APIs are, even stateful OOP was a step forward, so less random implementation details leak into the API
14:55:23 <ertes> well, if you reduce your usage of OOP to what is basically just a module system, then by all means, if your language doesn't offer you a real module system, use classes
14:55:48 <ertes> i've done that for years in C++ and PHP
14:56:33 <Welkin> ertes: or in js and lua, use a table/object/hash
14:56:40 <hpc> if C had namespaces from the start, i wonder how different OOP would be
14:56:56 <maerwald> this was not about "how can you achieve XY in language AB"
14:57:36 <mauke> hpc: isn't that basically the situation in perl?
14:57:40 <mauke> perl4 had namespaces
14:57:46 <ertes> hpc: i can see how contemporary OOP was very much inspired by smalltalk, but i think it got the wrong message
14:57:57 <ertes> (no pun intended)
14:58:08 <Rembane> It was a good one though
14:58:10 <monochrom> . o O ( Pun on "message" >:) )
14:58:24 <Welkin> erlang is more like smalltalk than java is
14:58:35 <hpc> mauke: perl's like the borg, i think it would have absorbed OOP regardless
14:58:56 <hexagoxel> even if i would agree on some interpretation of "oop is plain bad", where does this get us? what is the constructive part of this whole discussion?
14:58:56 <ertes> Control.Concurrent can also do smalltalk-style OOP, and it's actually a useful pattern
14:59:02 <maerwald> even failed concepts can have a contribution. OOP allowed the design of cleaner APIs with implementation details hidden. Saying "you can do that this way too" is orthogonal to the contribution
14:59:58 <hexagoxel> "pure functional programming is misrepresented" so what do you propose we (as a the (haskell) community) do about it?
15:00:05 <hpc> hexagoxel: i see OOP like hungarian notation - it's a style guide for writing a particular type of modular code
15:00:10 <Welkin> make it more accessible
15:00:21 <Welkin> stop talking about monads
15:00:27 <hpc> hexagoxel: if you pick and choose from the style guide, nothing works but you don't get any feedback that you're doing it wrong
15:00:40 <monochrom> I thought you supported talking about monads right in Chapter 1.
15:00:51 <Welkin> monochrom: yes, but don't talk about monads by name
15:01:06 <hexagoxel> hpc: i fail to see how this is any more constructive.
15:01:07 <Welkin> just introduce the concept as something natural, then say "oh hey, by the way, this is called a monad"
15:01:08 <Rembane> Those constructs who should not be named...
15:01:16 <Rembane> Voldemonads...
15:01:20 <maerwald> hexagoxel: why do you think it's misinterpreted?
15:01:29 <hpc> hexagoxel: because you can still use that style outside of languages with OOP-enforcing features
15:01:29 <ertes> Welkin: that has never been helpful for me…  if you're talking about monads, name them monads
15:01:39 <Welkin> ertes: but you already know what it is
15:01:39 <ertes> Welkin: if you don't want to name monads, don't talk about monads
15:01:50 <monochrom> Oh I don't think Welkin proposes to give it another name.
15:01:51 <ertes> Welkin: no, i teach haskell
15:01:57 <hexagoxel> maerwald: Mu (?)
15:02:05 <hpc> hexagoxel: data types in haskell with private constructors do something similar
15:02:11 <Welkin> who cars what you call it
15:02:23 <Welkin> SPJ likes to call monads "warm fuzzy things"
15:02:24 <hpc> you expose the type itself and operations on the type, and everything inside the module enforces certain invariants
15:02:26 <monochrom> But you can't avoid the line of code "instance Monad XXX where"
15:02:27 <ertes> Welkin: i do introduce monads early, but not quite at the beginning…  actually i start with IO most of the time
15:02:33 <hexagoxel> hpc: i think you completely misread my message.
15:02:36 <hpc> from the outside, that data type is conceptually an "object"
15:02:39 <ertes> (after a brief introduction of syntax and how to read types)
15:03:01 <Welkin> monochrom: you can if you write your own class for Monad and call it something else that makes sense to someone that doesn't know category theory
15:03:13 <maerwald> hexagoxel: I cannot follow
15:03:18 <Welkin> like I said before, Elm does this quite nicely
15:03:20 <ertes> anyway, monads are difficult to explain as a *modularity* feature
15:03:29 <monochrom> What does Elm call it?
15:03:30 <ertes> (they are one, but they are difficult to *explain* as one)
15:03:36 <Welkin> and also the best "monad tutorial" I have read, "you could have invented monads"
15:03:44 <Welkin> monochrom: nothing, since it lacks type classes
15:03:50 <Welkin> Elm just uses `andThen`
15:04:17 <monochrom> What is the type of andThen?
15:04:18 <tobiasBora> Hello,
15:04:37 <Welkin> monochrom: it is a monomorphic version of bind
15:04:52 <monochrom> Yes, what is it monomorphized to?
15:04:59 <hexagoxel> maerwald: i did not even use the word "misinterpreted", nor did i assert that the statement in quotes was true.
15:05:07 <Welkin> I forget the type since I haven't used it in a while
15:05:15 <maerwald> Welkin: what do they call (<*>)?
15:05:19 <hpc> ertes: the tricky part is to disconnect Monad itself as a modularity feature, from the API it expresses (specifically sequences of actions)
15:05:25 <Welkin> maerwald: I don't remember
15:05:34 <maerwald> andThenButSomehowDifferent?
15:06:03 <monochrom> OK, do you recall what you usually do with that type? I mean is it similar to Haskell's IO type?
15:06:12 <hpc> ertes: it's like confusing the concept of an iterator with the for-each operation
15:06:28 <Welkin> monochrom: yes
15:06:37 <Welkin> it is like IO
15:06:47 <maerwald> hexagoxel: I meant misrepresented
15:06:58 <ertes> hpc: i found the crucial part of that is to understand Monad as an abstraction, with its two aspects: 1. what do you see if "Monad m" is all you know?  when you're blinded from IO or Maybe?  2. Monad is an abstraction, which means that you can abstract over it (and that's why the question in aspect 1 is important)
15:07:18 <monochrom> OK, so Hudak's book does a very similar thing. It uses >>= and return early, but they are IO's and the general Monad is not brought up early.
15:07:24 <maerwald> yet another "how to explain monads" conversation
15:07:31 <Welkin> lol
15:07:39 <Welkin> I think it also depends on your audience
15:07:51 <hpc> ertes: this is why i like teaching Functor first - you can learn the power of giving such concepts a first-class name using an easier "implementation"
15:07:56 <Welkin> are you teaching this in terms of computer science? Or are you teaching this to practicing programmers
15:07:57 <maerwald> which is indeed funny, given how often people claim it's such a simple concept... if it is, why does this conversation pop up every day?
15:08:10 <hpc> ertes: and then when you get to Monad, you have a better base of concepts and can focus entirely on (>>=)
15:08:12 <Welkin> maerwald: because people don't know how to explain it without making a big deal out of it
15:08:13 <Rembane> maerwald: Because teaching it is not
15:08:23 <ertes> hpc: i teach IO, then Functor, then (much later) Monad
15:08:32 <hpc> ertes: that's a good order
15:08:54 <maerwald> you shouldn't focus on teaching, but on learning
15:09:07 <hexagoxel> maerwald: i was trying to sum up parts of the sentiment that started this whole thread. but perhaps this whole discussion has moved on anyways..
15:09:16 <ertes> maerwald: me?
15:09:52 <maerwald> if you stop trying to teach, you will see that it's easier to lay out a path of learning, that can be diverged from at the learners option
15:10:01 <maerwald> and then you won't really need all those witty definitions
15:10:07 <Welkin> I have been thinking about how these topics are covered
15:10:40 <Welkin> why is it that everyone seems to want to divide up their curriculum into topics that you might find in an encyclopedia: Functor, Monad, etc...
15:11:01 <Welkin> what if you took a different approach and just intorduced these naturally as they make sense when building a real program?
15:11:11 <Welkin> instead of creating aribtrary boundaries
15:11:13 <hexagoxel> Welkin: isn't the problem there that people already expect it to be a big deal, so if you come up with some short explanation, they never believe you?
15:11:17 <maerwald> the problem is that people are trying to teach and come up with the most correct and intuitive definitions for concept XY... which usually ends up completely useless for the audience
15:11:38 <tobiasBora> I'd like to read a file "f" using several threads, so that each threads read a different line of f. For example, thread 1 read line 1, thread 2 reads line 2, then thread 1 reads line 3... For now, I'm using a withFile that gets a handle, and then, I create a function that uses putMVar to create a locker so that only one tread can get the handle at the same time, and finally I use Async.replicateConcurrently
15:11:40 <tobiasBora> to create all my threads that will call the last function when the want to read from the inputHandle. But the thing is that sometimes they seems to read the same line several times... Do you know why ??? The inputHandle is duplicated in each Thread, or it's still a global variable ?
15:11:41 <maerwald> and so 90% of the discussions about how to teach monads are useless
15:11:46 <ertes> maerwald: it was a long learning experience for me how to teach haskell, and i faced many failures along the way, but i think i have a method that works now…  it depends on the audience of course, but my success rate has reached a point where i'm confident enough to talk about it
15:12:00 <maerwald> ertes: I don't believe you
15:12:09 <ertes> maerwald: you don't have to
15:12:17 <Rembane> tobiasBora: I think it is much easier to have one thread read all lines, and then spawn new threads to handle each alread read line.
15:12:22 <maerwald> not meant as an offense
15:13:04 <ertes> maerwald: feel free to visit my workshop =)
15:13:14 <Welkin> ertes: I'm still curious who your target audience is. Are they computer science students or practicing programmers?
15:13:20 <maerwald> I don't like to listen to teachers
15:13:32 <maerwald> I prefer to learn
15:14:37 <tobiasBora> Rembane: The thing is that the threads needs to say "hey, now I need a new line", so the main thread cannot know when the others threads needs a new line... Or else I would need to create a bidirectionnal channel between each of my 500 threads and the "main" thread... Quite heavy compared to a shared handle no ?
15:16:03 <Rembane> tobiasBora: Indeed, maybe you need a worker pool and the ability to send more lines to a thread when it runs out of things to do. Is it possible to read in the whole file before starting to process it?
15:16:15 <ertes> Welkin: random software developers or other IT people, students of all kinds of fields
15:16:29 <ertes> Welkin: the group is typically around 15 people
15:16:53 <ertes> Welkin: "random" as in: varying branches, languages and experience levels
15:16:56 <Welkin> tobiasBora: why not use `par` and sparks?
15:17:13 <Welkin> read in the whole file, then create a spark for each line, wrap in `par` and you are done
15:17:41 <tobiasBora> Rembane: I'd like to avoid to read the whole file at the beginning indeed
15:17:56 <Welkin> why?
15:17:57 <tobiasBora> Welkin: If I remember correctly, `par` cannot be used when IO is in the game...
15:18:15 <Welkin> reading the whole file at once should be faste than seeking around
15:18:41 <tobiasBora> Welkin: Yes, but the file can be quite big. Like a few Gb. So I don't want to run out of memory
15:18:55 <Welkin> tobiasBora: what about streaming the file?
15:18:58 <Welkin> using pipes
15:20:02 <tobiasBora> How would you pipe to several threads so that each thread gets only one input ?
15:20:11 <Welkin> you don't
15:20:17 <Welkin> just create sparks
15:21:30 <ertes> tobiasBora: do you know how stream processing frameworks work?
15:21:34 <ertes> (roughly)
15:21:56 <tobiasBora> Welkin: I don't know sparks, what is that ?
15:22:12 <tobiasBora> ertes: not that much
15:22:54 <tobiasBora> Welkin: the references to sparks are all linked with `par` that cannot handle IO I think no ?
15:23:08 <ertes> tobiasBora: without streamproc i would suggest going with what Rembane suggested:  use one thread to write lines to an MVar, then read from the MVar
15:23:27 <Rembane> Channels work too.
15:23:41 <ertes> if you use a channel, use a bounded one
15:24:13 <tobiasBora> ertes: Hum... In fact I don't see why it's not possible to use a handle as a global variable
15:24:14 <ertes> otherwise if the readers are the bottleneck, lines will be piling up in memory
15:24:28 <ertes> tobiasBora: because readling a line from a Handle is not a thread-safe process
15:24:45 <ertes> tobiasBora: you might find one thread reading part of a line, then another thread reading another part, etc.
15:24:53 <tobiasBora> ertes: even if I use lockers on top of it to ensure that only one thread read the handle in the same time ?
15:25:17 <ertes> tobiasBora: then it's safe, but locking is not a scalable abstraction
15:25:32 <ertes> tobiasBora: remember that a haskell thread does not translate into an OS thread…  it's just an abstraction
15:27:36 <tobiasBora> Well, the readers are really slow compared to the read action, so I'd say that the scalability of locking here is not really a problem
15:28:06 <tobiasBora> And I don't understand how using your solution would scale better
15:28:12 <tobiasBora> "use one thread to write lines to an
15:28:13 <tobiasBora> MVar, then read from the MVar"
15:29:55 <tobiasBora> >>> it means that when a reader wants to read a new line, he must check if a value is in MVar, if the value is "Nothing", then he waits a few ms and try again, and if the value is "Just x", it changes the value to Nothing and proceed ? And meanwhile the main thread constently checks if the variable is Nothing, and if yes, then feeds it with a new value ? Looks vary dirty no ?
15:30:38 <geekosaur> att the mvar level is likely is. the lower level underpinnings of concurrency are usually dirty
15:31:14 <tobiasBora> geekosaur: I don't see why here the upper level is not also dirty
15:31:42 <monochrom> I don't understand why Nothing and Just are involved in your story.
15:31:52 <monochrom> Completely not my model of MVar.
15:32:24 <monochrom> My model of MVar is Yoda's: Blocked or not blocked, there is no try.
15:32:35 <geekosaur> the upper level is something like async. if you're working directly with mvars then you are generally down in the guts; mvars are synchronization primitives.
15:32:43 <johnw> Yoda was fond of sudden abort over exception handling
15:34:23 <hpc> monochrom: word
15:34:51 <ertes> tobiasBora: reading from an empty MVar blocks, literally…  there is no "perioditic retrying"
15:34:57 <ertes> *periodic
15:35:36 <ertes> tobiasBora: and once written the blocking thread wakes up in response immediately
15:36:31 <ertes> tobiasBora: now to answer your question: locking doesn't scale in terms of *engineering*, not in terms of performance
15:36:42 <ertes> (it should deliver about the same performance)
15:36:52 <ertes> tobiasBora: because locking doesn't compose
15:37:39 <tobiasBora> ertes: oh, you mean that MVar blocks is already a "take one value"... Ok I understand better
15:38:19 <ertes> tobiasBora: you can use MVar like a bounded channel with a one-message limit
15:38:26 <barrucadu> You'll have one thread reading lines from the file and writing them to the MVar with putMVar, and a bunch of threads taking lines from the MVar with takeMVar: putMVar blocks until the MVar is empty, takeMVar blocks until it is full.
15:39:40 <ertes> tobiasBora: as a bonus MVar has fair scheduling built in, so one slightly more aggressive reader will not starve the others
15:39:44 <tobiasBora> ok great, it's clearer now. Thanks
15:48:00 <athan> ertes: How fair is that scheduling? Round robin or something like that?
15:49:01 * hackagebot follow-file 0.0.1 – Be notified when a file gets appended, solely with what was added. – https://hackage.haskell.org/package/follow-file
15:49:42 <EvanR> follow file seems to good to be true
15:50:03 <Rembane> You need to sacrifice your first born for it to work properly
15:50:03 <athan> it is, kinda like head
15:50:34 <athan> I don't have a quickcheck for it yet
15:50:47 <EvanR> tail -f
15:50:50 <Welkin> athan: what about a smallcheck, or a goldencheck?
15:51:00 <Welkin> what is the difference between all those anyway?
15:51:01 <athan> o_o
15:51:15 <ertes> athan: http://chimera.labs.oreilly.com/books/1230000000929/ch07.html#sec_fairness
15:52:21 <Welkin> https://hackage.haskell.org/package/smallcheck
15:52:26 <Welkin> how is that different from quickcheck?
15:52:44 <Welkin> and does anyone use "golden tests"? https://hackage.haskell.org/package/tasty-golden
15:53:15 <Welkin> oh, lol
15:53:18 <ertes> athan: fsnotify is a portable notification library…  you can wait for Modified events, then stat the file to see if it grew
15:53:21 <ryantrinkle> ertes: does your ismtp library support TLS in any form?
15:53:30 <Welkin> I just realized that a "golden test" is what jest calls "snapshot testing"
15:53:36 <ertes> ryantrinkle: no, and i no longer recommend using it
15:53:52 <EvanR> ertes: this is making a lot of assumptions about how the monitored file will be used
15:54:11 <EvanR> i ran into a lot of complications trying to get a "tail -f"-type program to just work
15:54:16 <ryantrinkle> ertes: ok, cool; thanks :)
15:54:21 <ryantrinkle> is there another lib you recommend?
15:54:32 <ertes> ryantrinkle: i wrote it at the time to solve a very specific problem, and that was quite a few years ago, when 'enumerator' was the most popular streaming library =)
15:54:34 <athan> ertes: Yeah I know, I just knew I wanted to start with unix first
15:54:42 <athan> thanks though, one sec I'm making a tail poc
15:54:45 <ertes> ryantrinkle: i recommend to shell out to 'sendmail'
15:55:03 <Welkin> athan: why are you re-creating unix utilities?
15:55:06 <ryantrinkle> ertes: yeah, not a bad approach
15:55:30 <EvanR> piping tail -f, really -F does get you pretty far
15:55:39 <athan> lol Welkin
15:55:44 <barrucadu> Welkin: Rather than generating inputs randomly, like quickcheck, smallcheck enumerates values up to some "depth"
15:56:06 <geekosaur> https://github.com/feuerbach/smallcheck/wiki/Comparison-with-QuickCheck
15:56:08 <barrucadu> The idea is that most bugs are revealed by small cases
15:56:37 <ertes> EvanR: true
15:56:41 <Welkin> so smallcheck is an alternative to quickcheck?
15:56:45 <barrucadu> Yes
15:57:37 <ertes> ryantrinkle: if you use postfix, check out the 'smtp_tls_security_level' option
15:57:39 <Welkin> what do you typically use for your test suite. Obviously, quickcheck or smallcheck for testing functions. What else?
15:57:54 <EvanR> quickcheck and smallcheck test properties
15:58:03 <EvanR> which might involve functions
15:58:12 <Welkin> do you use hspec at all?
15:58:21 <Welkin> or golden tests?
15:58:33 <barrucadu> I believe GHC uses golden tests a fair bit
15:58:44 <EvanR> i havent looked at hspec yet
15:59:24 <ertes> ryantrinkle: if you want something simpler, there is msmtp, which also has a sendmail-compatible interface, but i strongly recommend postfix regardless, except for interactive scenarios (what if sending fails?)
15:59:38 <athan> Welkin: log parsing with attoparsec, for instance
15:59:44 <athan> which fires off application code
16:00:52 <Welkin> EvanR: Hspec is Rspec for haskell
16:01:17 <Welkin> so, the standard `describe` `it` `expects/assert`
16:01:22 <Welkin> unit tests
16:01:47 <Welkin> but with generative functional tests, are unit tests useful? Also, if you already have something like golden tests?
16:01:55 <ryantrinkle> ertes: yeah, i use postfix for most things
16:02:14 <ryantrinkle> it is a lot more complex than what i usually need
16:02:26 <ryantrinkle> but that's alright; it's reliable, at least
16:03:14 <jle`> unit tests and property tests both have their place
16:03:39 <Welkin> is there a library for integration tests in haskell?
16:04:48 <ertes> ryantrinkle: my approach is to have a base configuration that i just use everywhere, and where needed add a few extra options…  plus NixOS' services.postfix has fairly sane defaults =)
16:05:12 <Welkin> ryantrinkle: speaking of postfix, you reminded me of milkypostman and melpa
16:05:50 <Welkin> I've always just used a 3rd-party mail service like mailgun to avoid setting up sendmail
16:08:39 <Welkin> has anyone written a comprehensive guide on testing in haskell?
16:12:57 <athan> woot, it works
16:13:14 <athan> same behavior as tail -f I mean
16:13:22 <Welkin> athan: but you aren't an owl
16:15:10 <platz> is it just me or is there no package that really provides a de-facto FromXMl/ToXML class ? 
16:15:41 <platz> i took a look at amazonka-core and it looks like it had to implement this itself
16:15:52 <EvanR> athan: what if log rotate messes with the file
16:19:46 <athan> EvanR: Oh then you're screwed haha
16:20:05 <athan> actually maybe not
16:20:12 <athan> if it's deleted then created
16:20:17 <athan> under the same name
16:20:35 <athan> I don't think I matched on the `Move` case.. hm
16:20:58 <iqubic> athan: I think you'd get a compile error in that case.
16:21:59 * hackagebot follow-file 0.0.1.1 – Be notified when a file gets appended, solely with what was added. – https://hackage.haskell.org/package/follow-file
16:36:15 * hackagebot follow-file 0.0.1.2 – Be notified when a file gets appended, solely with what was added. – https://hackage.haskell.org/package/follow-file
16:38:24 <ertes> platz: the easiest library for XML handling is aeson…  you just need to replace XML by JSON first
16:38:51 <ertes> don't worry…  JSON is just XML without the "enterprise" tag
16:39:01 <Welkin> what about yaml!
16:39:21 <EvanR> erm...
16:39:47 <EvanR> can i has library to replace xml with josn
16:39:49 <EvanR> json
16:40:21 <EvanR> efficiently
16:40:41 <EvanR> if you see a <, then {. > then }
16:40:44 <ertes> replace ≠ convert
16:41:07 <EvanR> just saying that would help
16:41:39 <ertes> one nice result of the REST movement was that many APIs that use XML also provide a JSON version
16:41:52 <Welkin> what about yaml!
16:41:54 <alx741> hello everyone. How would Haskell handle the following situation: I have a complex data type (possibly with a lot of data) `data T = T { someInt :: Int, someDouble :: Double, etc ...}`, and have a particular `someT = T 1 1.0 ... `. When I go and introduce this someT in a HashMap (from unordered-containers) like `insert 1 someT someHashMap`. Will someT get duplicated in memory?
16:42:09 <Welkin> alx741: paste your code in @lpaste
16:42:11 <Welkin> @lpaste
16:42:11 <lambdabot> Haskell pastebin: http://lpaste.net/
16:42:24 <iqubic> % lpaste
16:42:24 <yahb> iqubic: ; <interactive>:15:1: error:; * Variable not in scope: lpaste; * Perhaps you meant one of these: `Data.ByteString.Lazy.Char8.last' (imported from Data.ByteString.Lazy.Char8), `Data.ByteString.Lazy.last' (imported from Data.ByteString.Lazy), `Data.ByteString.Char8.last' (imported from Data.ByteString.Char8)
16:42:39 <EvanR> alx741: no
16:42:43 <EvanR> its shared
16:43:00 <platz> just saying it's odd is all; of course there could be a reason why typeclasses arent a good fit here
16:43:19 <alx741> Welkin: sorry, my bad
16:43:34 <alx741> EvanR: oh! that's what i needed to know, thanks!
16:43:47 <EvanR> records do get duplicated if you modify a field
16:44:08 <ertes> platz: i think such a library is very well possible…  might perhaps need some extra engineering to deal with namespaces properly
16:44:15 <alx741> EvanR: but the untouched fields will remain shared... is that correct?
16:44:25 <EvanR> whatever is in those fields are shared
16:44:33 <EvanR> unless its unboxed
16:44:44 <ertes> if it's unboxed, it's *practically* shared
16:45:03 <ertes> unless it's large
16:45:29 <EvanR> lets unroll the unlesses
16:45:43 <ertes> data V4 a = V4 !a !a !a !a;  type M44 a = V4 (V4 a)
16:45:50 <ertes> if you change a single component, you copy the whole matrix
16:46:10 <EvanR> strict fields get unboxed?
16:46:21 <ertes> data Row4 a = Row4 a a a a;  type M44' = Row4 (V4 a)
16:46:31 <ertes> now if you change a single component, only a row changes
16:46:36 <ertes> the remaining rows are shared
16:46:40 <ertes> EvanR: yes
16:46:46 <ertes> since GHC 7.something
16:46:51 * EvanR mumbles to self
16:47:07 <ertes> the UNPACK pragma has become default
16:50:36 <alx741> ertes: default for strict fields only... correct?
16:52:40 <ertes> alx741: well, you can't unbox non-strict fields =)
16:53:03 <ertes> they are pointers (or almost-pointers) by design
17:04:45 <Welkin> maerwald: (<*>) in Elm is called `andMap` http://package.elm-lang.org/packages/elm-lang/core/4.0.0/Task
17:05:02 <Axman6> alx741: don't forget, since all Haskell data types are immutable, they are always safe to share between different structures
17:05:18 <Welkin> `>>=` is `andThen`, and `>>` is `sequence`
17:05:36 <Axman6> ertes: polymprphic fields aren't unpacked, so you example only works if you have an unpackable type afaiui
17:06:07 <ertes> Axman6: oh, indeed
17:06:21 <ertes> i wonder if special cases are still unpacked, if statically known
17:06:25 <Axman6> data V4 = V4 !a !a !a !a will force the a values to be evaluated, but not unpacked, so sharing awill still happen for "updates"
17:07:30 <alx741> So it seems my worries are unfounded, Haskell just does the right thing, brilliant
17:08:33 <Axman6> alx741: yes, we can share much more data than you can in other languages, because we know it will not change ever
17:09:31 <Welkin> huh
17:09:37 <Welkin> it looks like with every update elm gets worse
17:09:47 <Welkin> more syntax removed, more features removed
17:11:57 <Axman6> I feel Elm makes a good FP tutorial, which you can use to boot strap learning another language
17:12:32 <Welkin> I think the elm architecture is great
17:12:35 <Welkin> but the language sucks
17:12:56 <Welkin> lol oh my god...
17:13:30 <Welkin> evan (creator of elm) is talking about how he was inspired by talking to guido (python creator) in this talk
17:13:33 <Welkin> o.o
17:13:42 <Rembane> Who needs syntax?! LISP FTW! 
17:13:44 <Welkin> python has to be one of the worst designed languages I have ever used
17:13:53 <Rembane> Welkin: Why?
17:13:55 <Welkin> I wouldn't take pointers from guido...
17:14:53 <EvanR> the ISS runs on python and is still up there (i think) !
17:15:01 <Rembane> EvanR: Have you seen it lately?
17:15:05 <EvanR> but i found it unusable
17:15:22 <Rembane> The ISS is indeed quite hard to use.
17:16:24 <EvanR> needs a REST API imo
18:02:22 <slack1256> Lets say I got a single reference to a mutable array that I would like to update in place. 
18:02:40 <slack1256> I could do it in ST and freeze & thaw when neccesary but that incurs in a whole copy and the array is about as big as the nursery, so it would fill it complety and incur a minor gc (copying)
18:03:02 <slack1256> I also could store it on the C side of the FFI , operate there and just make it available for reading on haskell.
18:03:17 <slack1256> does that last approach work or are there pitfalls?
18:11:00 <lyxia> slack1256: what about unsafeThaw and unsafeFreeze that don't incur a copy
18:11:50 <lyxia> The pitfall of storing it in C, is that it is in C.
18:13:03 <slack1256> lyxia: looking for them!
18:14:17 <iqubic> Thaw and Freeze?
18:14:24 <slack1256> Oooooh this is great
18:14:27 <slack1256> I missed the Unsafe module
18:15:30 <iqubic> slack1256: Use it with caution.
18:22:31 <slack1256> obviously, but I know it there will be just a single reference to it in the whole run
18:32:16 <srpx> Pro tip: you only need a type system if you've not mastered the arts of binary bug search. See you guys
18:32:37 <tmerr> What is the difference between => and -> in a type signature?
18:33:14 <Welkin> `=>` is used after all of your constraints
18:33:23 <Welkin> `->` is a function arrow
18:35:09 <tmerr> Thanks Welkin.. still grappling with this, what is the constraint in `Syntax delta => String -> delta`? First dive into haskell, not really sure how to google these things 
18:35:48 <Welkin> that can be read as "delta must be an instance of Syntax, for a function from String to delta"
18:36:01 <Welkin> `delta` is a type variable because it starts with a lowercase letter
18:37:01 * hackagebot ethereum-analyzer-webui 3.0.0 – A web frontend for ethereum-analyzer – https://hackage.haskell.org/package/ethereum-analyzer-webui
18:37:02 * hackagebot ethereum-analyzer-deps 3.0.0 – Stripped dependencies of ethereum-analyzer. – https://hackage.haskell.org/package/ethereum-analyzer-deps
18:37:02 * hackagebot ethereum-analyzer-webui 3.0.0 – A web frontend for ethereum-analyzer – https://hackage.haskell.org/package/ethereum-analyzer-webui
18:37:02 * hackagebot ethereum-analyzer-deps 3.0.0 – Stripped dependencies of ethereum-analyzer. – https://hackage.haskell.org/package/ethereum-analyzer-deps
18:38:15 <tmerr> Ah, that makes some sense. Googling I see that datatype generic functions work a similar way, where it would be Generic mytyvar => ... 
18:48:52 <tmerr> ah, and Syntax is a typeclass, which is vaguely like a rust trait
18:51:51 <c_wraith> Rust traits are almost exactly like type classes.
18:53:29 <iqubic> Really? I thought Rust was OOP
18:53:40 <c_wraith> Rust is not OOP at all.
19:03:15 <sm> Welkin: I use shelltestrunner
19:04:32 <jle`> also typeclasses and OOP are not mutually exclusive language features
19:08:35 <tmerr> the syntax feels oop-like: `mything.do_something()`; but i cant think of anything else that's especially oop
19:20:20 <slack1256> :q
19:20:22 <slack1256> ayy
19:29:33 <tmerr> is there a quick way to tell what library provides some identifier? like i see this random `cons` function, how do i see what import it is from? 
19:31:10 <c_wraith> sadly, there's actually no trivial way to do that.  There *should* be.  It's an easy problem, given the nature of Haskell.  But everything that does it is part of some bigger package
19:31:28 <c_wraith> And the bigger packages don't always play nicely together.
19:31:34 <c_wraith> Or with themselves.
19:33:52 <geekosaur> for stuff in the libraries distributed with ghc, the bot has a database
19:34:00 <geekosaur> @index cons
19:34:00 <lambdabot> Data.ByteString.Lazy.Char8, Data.ByteString.Lazy, Data.ByteString.Char8, Data.ByteString
19:34:25 <geekosaur> ...but 'cons' is actually a rather common name and a lot of other libraries also define it
19:34:33 <tmerr> i don't think it's from standard lib
19:34:41 <geekosaur> (and expect you to import qualified so you can specify which one you want)
19:34:56 <c_wraith> there are packages like https://hackage.haskell.org/package/hasktags
19:35:04 <c_wraith> But they're designed to be integrated with editor tooling
19:35:40 <geekosaur> the tag db is a text file though. grep (unix) / find (windows) works fine...
19:36:54 <tmerr> great, i'll try it
19:36:55 <sm> a common way is to throw it at hoogle. A browser bookmark shortcut is handy for this
19:37:19 <sm> or if you (can) have it loaded in ghci, :i SYMBOL
19:39:15 <fDev2179> Is there a way to split a list into two parts: all elements except the last element, and the last element?  I'm writing a recursive function and rather than do (x:xs), I need something like (xs:x).  Is there any syntactic sugar for doing something like this?  What I have works, but it uses a lot of last and take (something-1).
19:40:58 <sm> easy way: (init l, last l)
19:42:22 <fDev2179> I'll try that, sm.  Thanks.
19:42:43 <byorgey> fDev2179: this isn't what you asked, but trying to split a list like this may be a sign that you are using the wrong data structure.
19:43:13 <fDev2179> Interesting.  Why do you say that, byorgey?
19:43:24 <geekosaur> fDev2179, a list is a singly linked list
19:43:33 <geekosaur> (x:xs) is cheap, (xs:x) is expensive
19:43:44 <fDev2179> I see.
19:43:48 <geekosaur> (and the expensive one is therefore not easy to do)
19:43:55 <byorgey> fDev2179: I would suggest either (1) reverse the list before processing it recursively, so you can just pattern-match on (x:xs) normally, or (2) use Data.Sequence, which lets you look at either the first or last element cheaply
19:44:02 <fDev2179> I could switch it to (x:xs).  Would just take some more work.
19:44:14 <geekosaur> there are data structures that are better suited for that, but have their own costs. or just process it in cons order and reverse at the end
19:44:56 <fDev2179> What I am doing is relatively simple so it shouldn't be that much work to swap it so I start at the beginning of the list.  Good point, byorgey and geekosaur.  Thank you both. 
19:45:11 <tmerr> hasktags is generating tags for my package, but i am not sure it understands dependencies, which is where these things are defined :/
19:45:28 <mnoonan_> so I’m picking up ownership of a neglected kmett package, and I’m trying to put together some understandable prose for the motivation and usage examples. would anybody mind having a look / comment? https://github.com/matt-noonan/roles
19:46:13 <geekosaur> tmerr, you;d have to run it on the dependencies as well, yes. at this point it may be more helpful to set up hoogle locally and rebuild everything wth documentation enabled; that will also create hoogle databases
19:46:25 <geekosaur> and for local hoogle there is a command line client as well as the web interface
19:48:32 <geekosaur> (and if you're using stack, it should notice that you have docs enabled and hoogle installed, and download a hoogle database for the stackage snapshot you're using)
19:49:44 <tmerr> thanks for the pointer. i'll try setting that up, if it's not too complicated
19:52:51 <tmerr> is there a design reason that haskell allows non-qualified imports by default? seems like most other langs steer away from it
19:55:55 <c_wraith> only that qualified imports are an incredible pain to use in comparison
19:56:00 <c_wraith> especially for infix operators
19:57:53 <jle`> i suppose it's a cultural thing
19:58:29 <tmerr> and cabal failed to install hoogle :( this is discouraging
19:58:39 <mnoonan_> not just infix operators, it is annoying for any little combinator
20:03:29 <tmerr> this language seems designed to keep normies like me out. well, haskellers, i will show you. even if it means i have to become my greatest enemy
20:03:53 <jle`> haskell was definitely not designed to keep people out :)
20:04:20 <jle`> also haskell is designed to make programming easier and more accessible
20:04:37 <tmerr> the community seems friendly :)
20:05:30 <jle`> :3
20:06:56 <tmerr> easy and accessible compared to what? :P
20:07:08 <c_wraith> Coq :P
20:07:47 <jle`> well, accessible in the sense that it takes less thought/attention to program in haskell because of purity and its expressive type system
20:07:49 <jle`> heh
20:07:52 <geekosaur> haskell also likes to provide multiple ways to do things like this. you can manage your namespace with qualified imports, or with targeted imports (import Foo (name1, name2, ...), or default qual+unqual and make a local binding to the qualified one with a preferred local name, ...
20:07:57 <monochrom> I am not sure whether you're referring to the language design or the ecosystem infrastructure.
20:09:44 <monochrom> But anyway humans are strongly opinionated and strongly convicted to uphold their opinion so whatever you say it must be true.
20:10:19 <tmerr> monochrom: is this directed to me?
20:10:23 <monochrom> Yes.
20:10:54 <tmerr> nah, i recognize that it's nearly impossible to tell the difference between complex and foreign
20:13:10 <monochrom> No, I'm referring to the much simpler thing that you feel strongly about merely the existence of non-qualified imports and the way idiomatic code uses it a lot.
20:14:18 <monochrom> Me, I'm pretty indifferent about ideological issues like this.
20:14:30 <tmerr> c_wraith's answer sort of made sense, that it's helpful for infix operators
20:15:34 <tmerr> my background is mostly python where you can't define your own operators, and the `from x import *` is an anti-pattern. but i think this is mostly a problem because of lack of static typing
20:15:46 <tmerr> and re-exports
20:17:55 * hackagebot justified-containers 0.2.0.0 – Keyed container types with type-checked proofs of key presence. – https://hackage.haskell.org/package/justified-containers
20:17:56 <geekosaur> there is also that haskell compilers will tell you about collisions; iirc python will let you import * and then have a local definition that shadows an imported one
20:18:06 <tmerr> exactly
20:18:32 <geekosaur> haskell will throw an error telling you thgat you have both names in the same scope and you must qualify to say which you want
20:19:15 <paraseba> mnoonan_: I just read the roles Readme. I knew nothing about the library, nothing about the newtype cost (assumed it was always zero), I probably saw coerce a few times before, but never used it myself. I was able to understand the documentation very well. 
20:19:28 <mnoonan_> paraseba: awesome, thanks!
20:19:47 <tmerr> even worse, if a.py contains `from b import *`, and b.py contains `from c import *`, then a has everything from c in scope
20:19:55 <paraseba> mnoonan_: if anything I'd add one more example of a situation where regular coerce is not enough and you would need the library
20:21:00 <mnoonan_> paraseba: that seems reasonable
20:21:18 <paraseba> really like the approach of first stating the problem, and only then the solution
20:21:19 <geekosaur> and in that case haskell does not do that; if you want to , you need an explicit export list *and* either list all the names or export the whole imported module
20:27:57 <tmerr> ah, export lists! that's exactly what was confusing me
20:28:19 <tmerr> https://hackage.haskell.org/package/partial-isomorphisms-0.2.2.1/docs/src/Control-Isomorphism-Partial.html
20:28:22 <tmerr> the stuff in parens is an export list
20:28:37 <tmerr> so when i import Control.Isomorphism.Partial I get the others for free
20:29:00 <tmerr> hence the `cons` constructor from Control.Isomorphism.Partial.Constructors :)
21:33:03 <crucify_me> hello I'm wondering why I keep seeing this type for abs   abs :: Num a => a -> a    when it should be (Ord a, Num a) => a -> a     ?
21:33:46 <crucify_me> in text, online examples
21:39:25 <mnoonan_> abs is a method of Num, why do you think it should have an Ord a constraint?
21:40:40 <crucify_me> mnoonan, thank you, while defining my own function called abss , it won't work with abss :: Num a => a -> a 
21:41:12 <crucify_me> > ?src abs
21:41:15 <lambdabot>  mueval-core: internal error: PAP object entered!
21:41:15 <lambdabot>      (GHC version 8.2.1 for x86_64_unknown_linux)
21:41:15 <lambdabot>      Please report this as a GHC bug:  http://www.haskell.org/ghc/reportabug
21:41:45 <mnoonan_> well, how are you defining abss?
21:42:18 <crucify_me> https://ptpb.pw/HsCg
21:43:39 <mnoonan_> you wrote >=, so you need Ord
21:44:43 <crucify_me> mnoonan, yeah, super basic question, where are the actual prelude function definitions ? 
21:46:43 <mnoonan_> The hackage docs usually have source links for each definition: https://hackage.haskell.org/package/base-4.10.0.0/docs/Prelude.html
21:47:37 <crucify_me> thank you in hackage now. Its strange that a quick search doesn't yield the definitions themselves, only the type signatures mnoonan 
21:48:24 <mnoonan_> well, since abs is a member of the Num class, it isn’t like there is one definition sitting around. it’s source link just leads to the type signature (basically the interface).
21:48:55 <crucify_me> I don't understand 
21:48:56 <mnoonan_> if you want to see how a particular type implements it for their Num instance, look at the docs for that type’s Num instance.
21:49:36 <mnoonan_> it’s like if you wanted to find the source of “show”. There is no such thing! Each type that has an instance of Show will implement its own version of “show”
21:51:18 <crucify_me> how would I do that if I wanted to see how it is written for Integer ?
21:52:21 <mnoonan_> in the prelude docs, go down to where the documentation for the Num typeclass is
21:52:42 <mnoonan_> just below, you’ll see a list of instances that are also defined by prelude
21:52:50 <mnoonan_> one is Num Integer, and it has its own source link
21:53:21 <crucify_me> thank you checking it. still struggling with basics...
21:53:29 <mnoonan_> (but now that i’m looking at it, you aren’t going to like what you find :)
21:55:12 <mnoonan_> anyway, here is one other thing to keep in mind. many of the types that have Num instances also happen to have Ord instances (e.g. Int), and it would be perfectly valid for any of those types to use the “abss” definition you gave.
21:55:57 <mnoonan_> but it won’t work for *all* Num types, since Num a doesn’t require Ord a. so that’s why your definition fails to compile. it might work for some *particular* types, but not *all* types.
21:56:43 <crucify_me> yeah it works fine with Int -> Int     however
21:57:09 <mnoonan_> right
21:57:37 <crucify_me> If the prelude version doesn't use >= I don't see how you can have an abs function
21:58:03 <crucify_me> so I'm missing a basic concept once again
21:58:40 <Maxdamantus> The `Num Int` instance happens to refer to the `Ord Int` instance.
21:59:04 <mnoonan_> you don’t have “an abs function”, singular. you have a bunch of different abs functions, with a bunch of different definitions. one for each type that is an instance of Num.
21:59:40 <Maxdamantus> It's like how you can write a function `(a -> b) -> (b -> c) -> (a -> c)`
22:00:03 <Maxdamantus> Once you've applied an `a -> b` and a `b -> c`, you just get an `a -> c`, with no mention of `b`
22:00:42 <crucify_me> ok so in the textbook they are using Num a => a -> a  just for illustration but it is too general for actually writing the function to your own liking
22:02:30 <crucify_me> thank you Maxdamantus is the above post accurate?
22:03:17 <crucify_me> ie I wanted to use >=  , which is the only way I know how to write abs
22:05:42 <Maxdamantus> crucify_me: right, I think that it's impossible to write a general implementation of `abs` without using `abs` from `Num`.
22:06:26 <Maxdamantus> crucify_me: you can of course implement it for particular types, such as ones that also have an `Ord` instance.
22:07:51 <crucify_me> interesting, thanks Maxdamantus .. I'm wondering if, as one learns more haskell, if a Num constraint alone would be used less and less
22:10:46 <Maxdamantus> crucify_me: well, a lot of programming doesn't have to do with actual numbers.
22:11:14 <Maxdamantus> crucify_me: eg, if you're interating over some sort of collection, even though that collection might have a numeric size, you shouldn't usually need to use numbers to do it.
22:17:20 * hackagebot indextype 0.3.0.0 – A series of type families and constraints for "indexable" types. – https://hackage.haskell.org/package/indextype
22:18:10 <crucify_me> Maxdamantus, that looks like a good read
22:18:33 <Maxdamantus> What does?
22:19:30 <crucify_me> I went through foldl foldr and some list comprehension stuff. oh sorry hackagebot gave me something to read.
22:19:41 <crucify_me> Maxdamantus, 
22:22:39 <crucify_me> thanks for your help
22:23:10 <Maxdamantus> np
22:29:17 <fresheyeball> Hey out there
22:29:34 <fresheyeball> is it possible to have a Read instance for an existentialized singleton?
22:30:21 <fresheyeball> data SomeFoo = forall (x :: Foo). SomeFoo (Sing x)
22:34:32 * hackagebot htoml-megaparsec 1.0.1.7 – Parser for TOML files – https://hackage.haskell.org/package/htoml-megaparsec
22:35:12 <Axman6> hmm, would you need a constraint on x?
22:35:59 <Axman6> data SomeFoo where SomeFoo :: forall (x :: Foo). Read x => Sing x -> SomeFoo?
22:36:26 <Axman6> then the constructor SomeFoo carries around the constraint disctionary... but I have no idea if that would work
22:37:12 <Maxdamantus> Don't see why you couldn't.
22:37:59 <fresheyeball> I get
22:38:11 <fresheyeball> No instance for (Read (Sing mt0))
22:38:24 <fresheyeball> arising from use of 'readPrec'
22:38:45 <fresheyeball> I put `Read` into the existential thing
22:38:51 <Maxdamantus> Right, so you'll need to define `instance Read SomeFoo` instead of trying to derive it, since `Sing` doesn't have a `Read` instance.
22:39:12 <fresheyeball> ok
22:39:59 <Maxdamantus> Presumably there's a single constructor for `Sing x` .. if that's again called `Sing`, your `Read` instance just has to produce `SomeFoo Sing`
22:40:19 <fresheyeball> http://lpaste.net/782009675112513536
22:40:51 <fresheyeball> I need something like a pair
22:41:03 <fresheyeball> where one half is a value level representation of a type
22:41:18 <fresheyeball> and the right is a type family parameterized with that type
22:42:50 <Maxdamantus> This doesn't look like a singleton.
22:44:00 <fresheyeball> Sing mt is a singleton no?
22:44:39 <Maxdamantus> I can't see where `Sing` is defined.
22:45:07 <fresheyeball> https://hackage.haskell.org/package/singletons-2.3.1/docs/Data-Singletons.html
22:45:18 <Maxdamantus> but if it has multiple constructors, or if its constructor takes a non-singleton as an argument, it's not much of a singleton.
22:45:28 <mbeidler> s anyone familiar with `State#` or `RealWorld` types from GHC.Exts and Control.Monad.ST.Safe?
22:45:37 <mbeidler> https://hackage.haskell.org/package/base-4.10.0.0/docs/GHC-Exts.html#v:runRW-35-
22:45:48 <mbeidler> I probed a few ply deep with Google, but didn't find the explanation / paper / background I was looking for.
22:46:00 <mbeidler> I first encountered this mysterious type in **parallel**. The `Eval a` monad.
22:47:13 <Axman6> fresheyeball: you probably need Read (Sing x) in the constraint, not Read x, that was my mistake
22:48:11 <fresheyeball> Axman6: I do have (Read (Sing x))
22:48:22 <fresheyeball> Read x is a kind error
23:04:12 <nshepperd_> mbeidler: it's used in IO to represent order of execution also
23:05:10 <nshepperd_> I don't know where a good source of explanation for that is
23:07:54 * hackagebot constraint-manip 0.1.1.0 – Some conviencience type functions for manipulating constraints. – https://hackage.haskell.org/package/constraint-manip
23:10:02 <mbeidler> nshepperd_: interesting, it mentions "floating" but that's a term I"m not familiar with.
23:10:34 <mbeidler> "it is necessary to use NOINLINE to prevent semantically undesirable floating."
23:11:01 <nshepperd_> What does?
23:11:48 <mbeidler> In the documentation for the `runRW#` which uses the type.
23:12:19 <nshepperd_> Stuff that messes with the internal representation of IO / mutability often needs to be NOINLINED to prevent evaluation from being reordered by the compiler
23:12:49 <nshepperd_> Or to prevent things from being shared or not shared
23:13:10 <osa1> MVar documentation says FIFO semantics for threads blocked for take is not guaranteed but I can see the queueing code in GHC source. anyone know when is FIFO property not guaranteed?
23:13:16 <mbeidler> Yeah, and it makes sense that that would also be true for things in the `Eval` monad.
23:13:21 <osa1> I was kind of hoping to have that guarantee for a program I'm writing
23:14:28 <mbeidler> Since you are often specifying order of evaluation with strategies. 
23:15:13 <mauke> osa1: http://hackage.haskell.org/package/base-4.10.0.0/docs/Control-Concurrent-MVar.html#v:takeMVar
23:15:45 <osa1> mauke: from the same page: "One usual implementation of this fairness guarantee is that threads blocked on an MVar are served in a first-in-first-out fashion, but this is not guaranteed in the semantics"
23:16:01 <mauke> I think the first part is a general description of MVar semantics
23:16:11 <mauke> takeMVar/putMVar are what ghc actually implements
23:16:24 <mauke> and there FIFO order is guaranteed
23:16:48 <osa1> OK the documentation is still confusing I think
23:17:33 <osa1> is there another documentation/specification/standard etc. for mvars?
23:17:50 <jle`> fresheyeball: alternatively you can just use read on the DemoteRep
23:18:14 <jle`> then you won't need all the contstraints
23:18:40 <jle`> fresheyeball: well, having Read on all of the singletons themselves is kind of a not-normal thing
23:18:51 <jle`> this is something you'd do as a kindclass instead, ideally
23:18:53 <nshepperd_> Anyway the meaning of State# is basically that it's an imaginary value which is passed around in the implementation of IO and ST types in order to control evaluation order
23:22:48 <fresheyeball> jle`: I just tried DemoteRep
23:22:49 <fresheyeball> same thing
23:23:56 <jle`> what's the error?
23:24:22 <fresheyeball> I will do it again
23:24:23 <fresheyeball> hang on
23:26:07 <jle`> ideally you'd want a kindclass for readable singletons, but you can hack together the same behavior by using Read on the DemoteRep/value that the singleton represents
23:26:30 <jle`> in this case the DemoteRep is ModuleType
23:26:43 <jle`> so you'd just need a Read instance for ModuleType
23:27:22 <fresheyeball> http://lpaste.net/3424852074821582848
23:27:23 <jle`> you'd use readPrec + withSomeSing
23:27:35 <fresheyeball> jle`: http://lpaste.net/3424852074821582848
23:27:48 <jle`> what is the 'x' type variable there?
23:28:01 <jle`> should probably just be x :: ModuleType <- step readPrec
23:28:41 <jle`> hold on i'll annotate
23:31:58 <jle`> fresheyeball: http://lpaste.net/3424852074821582848
23:32:39 <jle`> you might have some issues depending on what the Show instance for Payload mt is
23:32:49 <jle`> if it's completely polymorphic on mt then you should be okay
23:33:55 <jle`> but if there's a constraint on mt you have to prove that that constraint is realized
23:43:01 <ongy> can I have a type annotation that says, something will always be 'Traversable t => t a', but I can change the underlying type in the function? so I can rely on the traversable instance in calling code, but can change the actual type when I want to
23:50:06 <EvanR> Traversable t => b -> c and use a proxy for type t ?
23:53:28 <ongy> proxy would still be determined from the caller, right?
23:53:46 <ongy> I know I can do it with existentials, but that would be overkill just to be lazy when I change around types later on
23:57:55 <woodson> is there way to create data type based on another data type ? So for instance i would have file A have data A = A { x :: String }  and would like to have file B have data B = A 
