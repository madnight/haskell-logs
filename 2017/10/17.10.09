00:00:02 <Cale> Now to define edge resistance in FRP :)
00:00:11 <Myrl-saki> Cale: I wanted a WM that doesn't "just work."
00:00:22 <Cale> hahaha
00:00:38 <Myrl-saki> Like, I have no idea how XMonad modules interact with each other, so yeah.
00:00:50 <Myrl-saki> OTOH, I'm still using XMonad, because well, it just works.
00:01:29 <Myrl-saki> Cale: This does the bare minimum and it follows the tall layout in XMonad.
00:02:16 <Myrl-saki> Oh right.
00:02:27 <Myrl-saki> I remember now why I didn't finish this.
00:02:36 <Myrl-saki> I have no idea how to handle inputs. :D
00:03:14 <Cale> You have to add them to your host
00:03:23 <Profpatsch> EitherT/ExceptT cannot have an instance of Bifunctor. So sad.
00:03:29 <Cale> and provide some Events
00:03:36 <Cale> (and or Behaviors)
00:03:53 <Cale> Like, you probably want a Behavior for the location of the mouse
00:05:36 <Cale> and actually, it might make more sense to make the screen layout a Behavior as well, I'm not sure
00:06:26 <Cale> Well, depends a bit on how the host needs to do its thing
00:06:28 <Myrl-saki> Cale: Yeah.
00:06:43 <Myrl-saki> Cale: I meant on the XCB side. Even XCB people don't know how to handle input. :/
00:06:53 <Cale> Maybe Dynamic will again end up being more appropriate for similar reasons to why we use Dynamics in reflex-dom
00:07:02 <Cale> ah
00:07:19 <Myrl-saki> Cale: OTOH, when to not use Dynamic?
00:07:30 <Myrl-saki> Cale: (compared to, say, Behavior)
00:08:29 <Cale> Well, there's a semantic difference: Dynamics have to be step functions of time, while Behaviors, you can't really tell, they might be continuous.
00:08:49 <Cale> But from an engineering perspective
00:09:23 <Cale> Behaviors might be things that update rapidly and which it might be a bad idea to do a bunch of processing every time they change
00:09:59 <Cale> You can sort of think of occurrences of Events as "permission to do a bunch of work"
00:10:15 <Cale> Dynamics give you permission to do a bunch of stuff every time they change
00:10:22 <Cale> Behaviors don't
00:10:38 <Myrl-saki> Also, I was wrong, apparently, XCB does have keyboard input(incomplete, but not inexistent), and I wasn't searching hard enough.
00:10:46 <Myrl-saki> I guess that means I'll be finishing this. :D
00:10:50 <Cale> nice
00:10:53 <Myrl-saki> Cale: So it's kind of like push and pull?
00:10:57 <Cale> yeah
00:11:11 <Cale> Events are "push", Behaviors are "pull"
00:12:23 <Myrl-saki> Cale: Thanks.
00:12:27 <Cale> You can imagine a crazy FRP network which has audio processing going on at 44kHz somewhere, and that part exposes a Behavior to the graphics part for the FFT of the audio signal for some sort of visualisation
00:13:13 <Cale> It would be madness to have the graphics code running at 44kHz by accident, so you wouldn't want to deliver an Event that fired on every audio sample to that part of the system.
00:13:18 * geekosaur gave up on xcb when he had to dig into kde source to figure out how to use it
00:14:14 <Myrl-saki> geekosaur: We just have to make YAXL(Yet another X Library)!
00:14:37 <geekosaur> maybe they have actual documentation now. what they had then was basically API docs with no explanation of what the parameters and returns were
00:14:42 <Cale> Haskell representation of the X protocol from the ground up.
00:14:55 <geekosaur> xhb's a thing but I don't think its docs are any better >.>
00:15:20 <Myrl-saki> geekosaur: Yeah, I'm using XHB, and I still refer to XCB for docs.
00:15:54 <Myrl-saki> Cale: When do Dynamics come to place?
00:16:40 <Myrl-saki> (place or play?)
00:17:50 <Cale> Myrl-saki: Well, Dynamics are a combination of a Behavior (which is guaranteed to only change discretely), and an Event (which is guaranteed to occur exactly when the Behavior changes, and which occurs with the value it is about to change to)
00:18:34 <Cale> At the moment when the Event occurs, the Behavior won't yet have changed, but will have its new value at any subsequent moment.
00:18:44 <Cale> (until the Event occurs again)
00:18:46 <Myrl-saki> Cale: Right.
00:19:28 <Cale> So, in practice up to this point, Dynamics are sort of an apology for not quite being able to use Behaviors in interacting with certain external APIs
00:19:46 <Cale> Like, the DOM isn't going to ask us what we want various subtrees of the DOM to be
00:19:55 <Cale> We have to tell it about each update
00:20:10 <Myrl-saki> I see.
00:20:27 <Myrl-saki> Cale: So, this is more on the output side of things?
00:20:27 <Cale> So many things in reflex-dom which would morally be Behaviors perhaps end up being Dynamics because it's unreasonable to poll.
00:21:00 <Cale> Well, and then that chains backward, because you can't so easily get a Dynamic if you only have a Behavior
00:21:15 <Cale> (you need to know when you'd like to measure the Behavior and discretise it)
00:22:06 <Myrl-saki> Cale: Right. Thanks.
00:22:29 <Myrl-saki> Cale: I'll start working on the inputting today. :D
00:22:41 <Myrl-saki> So excited~
00:23:40 <Cale> Also, right now Reflex doesn't have any way to construct primitive Behaviors except via holds
00:24:13 <ertes-w> hllo
00:24:42 <Cale> But that's not a totally fundamental limitation -- things are designed in such a way that it should be possible to have other sorts of Behaviors that potentially vary continuously.
00:26:03 <Cale> It's just that up to this point, we haven't needed that part ourselves, and depending on exactly what features you want in that space, it can be hard work to get things to perform really well (and it's already been lots of hard work chewing what was bitten off).
00:26:05 <Myrl-saki> Cale: So I'll first have to, say, make a mouse move event?
00:26:44 <Cale> Yeah, you can make a mouse move Event, and then hold that to get a Behavior, or holdDyn it if you'd prefer a Dynamic.
00:27:54 <Myrl-saki> Cale: What other way could there have been a way to make a behavior? `:: MonadHold m => IO a -> m (Behavior a)`?
00:28:05 <Myrl-saki> Cale: (Going to hypotheticals now)
00:28:16 <Cale> Well, probably not MonadHold, but some other constraint there
00:28:42 <Cale> You'd want to give that thing an ugly name and make sure it only ran in the host
00:28:44 <Cale> :)
00:28:52 <Cale> Because it's easy to screw it up
00:29:22 <Myrl-saki> Cale: Thanks. :D I'm really appreciating the help.
00:29:31 <Cale> But yeah, running an IO action at most once per frame to sample a sensor in the real world or something
00:29:55 <Myrl-saki> Oh right. With that said.
00:30:00 <Myrl-saki> Cale: Isn't this pretty close to PerformEvent?
00:30:04 <Cale> You'd just want to be sure that no matter what order those IO actions ran in, they'd see a consistent picture of the world
00:30:05 <Myrl-saki> Or something.
00:30:05 <ertes-w> example: the current time
00:30:08 <Profpatsch> Hm, Data.Set doesn’t have any function to e.g. convert a List or Foldable to a Set.
00:30:12 <Myrl-saki> I forgot the name of the function.
00:30:40 <Cale> Set.fromList
00:30:50 <Myrl-saki> I think it was something along the lines of `:: ((a -> IO ()) -> IO ()) -> m (Event a)`?
00:30:58 <Myrl-saki> Oh wait, that's still Event.
00:30:59 <Profpatsch> Huh, how did I miss that.
00:31:21 <Profpatsch> Cale: is fromList . Foldable.toList efficient then?
00:31:24 <Cale> Myrl-saki: performEvent is on the other side
00:31:33 <ertes-w> Myrl-saki: for that kind of behaviour you don't really need anything extra with current reflex
00:31:38 <Profpatsch> aka will it fuse?
00:32:06 <Myrl-saki> ertes-w: Yeah.
00:32:06 <Cale> Myrl-saki: Well, the primitive ways to create Events give you a trigger action
00:32:19 <ertes-w> Myrl-saki: you can create a behaviour that from your application's point of view is primitive, but you would have created it from an event that you fire in every frame
00:32:54 <Myrl-saki> ertes-w: Yeah, I was thinking of a way where a Behavior when sampled would, say, run an IO event.
00:33:07 <Myrl-saki> ertes-w: Just hypotheticals.
00:33:16 <Cale> Myrl-saki: So one thing I do when I want a primitive behaviour of that sort
00:33:27 <ertes-w> Myrl-saki: that's equivalent: instead you run the action and fire an event, which updates a behaviour
00:33:32 <ertes-w> Myrl-saki: the end result is the same
00:33:32 <Cale> Is to write a function like  Event t x -> m (Event t (a,x))
00:33:55 <Cale> as an apology for not being able to provide m (Behavior t a)
00:34:25 <Myrl-saki> Cale: I see.
00:34:30 <Cale> So, you give me an arbitrary Event, and I'll give you what would have been the result of attaching the Behavior to the Event
00:34:49 <Myrl-saki> Makes sense. Thanks. :D
00:34:50 <ertes-w> Myrl-saki: like pretty much all FRP frameworks right now reflex is inherently time-framed, so the only potential reason to have primitive behaviours is performance – you could circumvent the whole event machinery
00:35:35 <Myrl-saki> ertes-w: Cale: On the concept of time-framed, how would you do a time-framed IO?
00:35:44 <Cale> It *would* be nice at some point to do more of the integration and measurable time stuff.
00:35:52 <Cale> On top of reflex
00:36:05 <Myrl-saki> I guess technically, a host can function as a time-framed IO.
00:36:20 <ertes-w> Myrl-saki: a host is *always* time-framed
00:36:29 <ertes-w> you don't get to do non-time-framed IO
00:36:40 <Myrl-saki> Right.
00:37:13 <ertes-w> the only way to advance a reflex application is fireEventsAndRead
00:37:19 <Cale> Anyway, I should get to sleep :)
00:37:25 <Myrl-saki> Cale: Night~
00:37:34 <Cale> But yeah, I'll be happy to see what you come up with :)
00:37:34 <ertes-w> Cale: night =)
00:37:43 <Cale> night!
00:37:57 <ertes-w> Myrl-saki: (there is also runHostFrame, but that one doesn't really move time forward)
00:38:30 <Myrl-saki> ertes-w: Thanks. :D
00:51:05 <mivael> geekosaur, monochrom: I did not respond timely, but for completeness: I installed all haskell related packages (including hoogle) by means of my OS (Debian GNU/Linux) only.  No stack, no cabal, etc.  That's why I was surprised that hoogle gave me results related to different parsec version (not the one installed in my system).
00:53:42 <mivael> I certainly do not have parsec-3.1.11 on my system.  It is strange to see 'endOfLine' in its results despite the fact that 'endOfLine' is not present in locally installed parsec-3.1.3
00:54:26 <mivael> s/its results/hoogle's results/
00:59:57 <Profpatsch> Hrm; I have a list of short Texts
01:00:04 <Profpatsch> The list is very long.
01:00:59 <Profpatsch> I want to pass over the whole (fold list) and build a `Set Char` with all occuring different Chars.
01:01:24 <Profpatsch> This kind of primitive function takes a very long time:
01:01:26 <Profpatsch> packageNameChars (PackageNames xs) = T.foldl' (flip Set.insert) mempty $ fold xs
01:01:38 <Profpatsch> At least it’s using constant memory. :P
01:02:21 <Profpatsch> Building a binary structure that can be evaluated in parallel might be a lot nicer.
01:02:40 <Profpatsch> Probably with the parallel package? But I have no idea how to achieve that.
01:05:33 <nshepperd_> Divide the list into n chunks, then fold each chunk in parallel
01:05:54 <nshepperd_> Later aggregating chunks
01:07:14 <nshepperd_> Eg. parMap yourFold . transpose . chunksOf n
01:07:30 <nshepperd_> Where n is your number of cpus or whatever
01:09:02 <Profpatsch> nshepperd_: How would I build a recursive binary evaluation from the list?
01:10:20 <Profpatsch> The most efficient version is probably a divide-and-conquer tree reduction with Set.union at each node?
01:11:48 <nshepperd_> A recursive binary tree sort of thing sounds like effort
01:12:56 <nshepperd_> I would expect that simply making n workers to evaluate separate stripes of the input gets you 95% there
01:13:38 <nshepperd_> Or might even be better. The typical machine has limited parallelism
01:14:00 <Profpatsch> nshepperd_: It wouldn’t be very efficient because splitting the list is overhead?
01:14:42 <Profpatsch> Wouldn’t parallel keep the number of evaluations down to the number of cores?
01:15:04 <Profpatsch> Or does it just fire everything at the same time? It’s wired into the runtime, right?
01:15:39 <Profpatsch> I wonder why there is no Text.nub.
01:21:14 <nshepperd_> The straightforward method of splitting the list into two parts and evaluating each part in parallel, has overhead in sparking too many evaluations
01:22:27 <nshepperd_> And also, probably uses more memory than it should, because it can force different parts of the list in unpredictable order
01:23:44 <Profpatsch> nshepperd_: How do I find out the number of cores then? I don’t like that it kind of depends on the machine.
01:24:03 <Profpatsch> Maybe using a Set is inefficient as well.
01:29:21 <Profpatsch> Maybe HashSet.fromList . Text.unpack and that on a few chunks in parallel.
01:33:06 <maerwald> haskell didn't make it into the lsat Tiobe index!
01:33:17 <maerwald> is this the end?
01:34:18 <tdammers> no, it's the beginning
01:35:04 <maerwald> :D
01:36:11 <Profpatsch> Achievement unlocked: Avoid too much success.
01:36:49 <merijn> Pretty sure TIOBE rankings have a near 0 correlation with success
01:37:27 <maerwald> it's just search engine stuff, I doubt it even correlates to industry trends
01:39:32 <maerwald> but people use it to argue about languages on Quora, so it must be important
01:56:22 <ertes-w> i'm completely stuck on an encoding problem
01:57:44 <ertes-w> could it be that FreeT is the type of *all* languages with an isomorphic church encoding?  i.e. if you have a recursive type that can't be encoded as FreeT, then you don't get an isomorphic church encoding
01:59:40 <ertes-w> i'm under the impression that FreeT/FT give rise to a universal property in that regard
02:01:18 <ertes-w> the type in question i'm failing to encode is the type of effectful mealy machines:  newtype MealyT a m b = MealyT { stepMealyT :: a -> m (b, MealyT a m b) }
02:02:08 <ertes-w> i have a church encoding of MealyT called W, and i can convert *to* it, but i can't convert *from* it
02:10:56 <saurabhn_> is there any way to make the compiler and package DB part of a docker image with stack? so that anyone in the dev team can start building immediately by pulling a pre-configured docker image from hub.docker.com?
02:11:19 <maerwald> sure
02:11:43 <dfsafd> how do you get cabal to install dependencies for test suites?
02:11:58 <merijn> dfsafd: Configure with --enable-tests before building/installing
02:12:08 <merijn> dfsafd: Or run "cabal install --enable-tests"
02:13:21 <dfsafd> thank you.
02:13:32 <dfsafd> that stuff should be done automagically by cabal
02:13:57 <merijn> dfsafd: I don't think so
02:14:22 <dfsafd> yes it should
02:14:28 <merijn> dfsafd: Most people who are installing a library won't be developing/testing it, dragging in lots of test dependencies for everyone seems like a waste of CPU time
02:14:46 <dfsafd> also the cabal.sandbox.config file contains absolute paths
02:14:55 <dfsafd> so the build apparently breaks if you move the directory around
02:15:01 <merijn> dfsafd: If you always want to enable tests you can do so in your "~/.cabal/config"
02:15:21 <merijn> dfsafd: You might want to look into new-build to get rid of sandboxes
02:15:22 <dfsafd> the command *cabal test* should install test dependencies
02:15:33 <merijn> dfsafd: https://cabal.readthedocs.io/en/latest/nix-local-build-overview.html
02:15:55 <merijn> (although it still has some rough edges)
02:16:38 <dfsafd> :) i learned about cabal sandboxes last week
02:22:32 <fredsir> I use Stack, and are right now trying to use haskintex (http://daniel-diaz.github.io/projects/haskintex/) but it fails with "haskintex: ghc: readCreateProcess: runInteractiveProcess: exec: does not exist (No such file or directory)" I'm guessing it's because I only have GHC installed via stack and haskintex can't find it. If so, is it possible to tell Stack to like ... link it's ghc and other tools so 
02:22:38 <fredsir> they are in use globally on the system?
02:31:04 <barrucadu> You could try `stack exec haskintex`
02:31:14 <barrucadu> (+ whatever arguments haskintex needs)
02:41:47 <maerwald> idris is interoperable with haskell?
02:42:06 <fredsir> barrucadu: that works, thanks!
02:44:07 * hackagebot language-puppet 1.3.12.1 – Tools to parse and evaluate the Puppet DSL. – https://hackage.haskell.org/package/language-puppet
03:07:32 * hackagebot log-warper 1.2.3.1 – Flexible, configurable, monadic and pretty logging – https://hackage.haskell.org/package/log-warper
03:13:48 <dfsafd> can haskell be made to memoize functions? i want the naive fib n = fib (n-1) + fib (n-2) to run fast
03:14:00 <maerwald> :>
03:14:35 <Boomerang> join #cabal
03:14:46 <Boomerang> :/
03:14:56 <maerwald> Boomerang: ok :D
03:21:27 <mivael> dfsafd, for a general solution for memoization, maybe immutable non-strict arrays (Data.Array) could be your friend?
03:23:12 <fakenullie> dfsafd: https://wiki.haskell.org/Memoization have fibonacci example
03:24:31 <dfsafd> fakenullie: i dont understand how that code works
03:24:38 <fakenullie> Heh
03:24:53 <mivael> > let a = array (1,7) ((1,1) : [(i, i * a!(i-1)) | i <- [2..7]]) in a  -- dfsafd, there is an example demonstrating the non-strictness at http://hackage.haskell.org/package/array-0.5.2.0/docs/Data-Array.html#v:array
03:24:56 <lambdabot>  array (1,7) [(1,1),(2,2),(3,6),(4,24),(5,120),(6,720),(7,5040)]
03:25:33 <dfsafd> in other languages, it is sufficient to add an annotation @memoize
03:26:16 <mivael> dfsafd, you probably have a specific "other language" in mind  :)
03:26:28 <fakenullie> Yeah, in pure functional it's tricky
03:28:51 * hackagebot mysql-haskell-openssl 0.8.3.0 – TLS support for mysql-haskell package using openssl – https://hackage.haskell.org/package/mysql-haskell-openssl
03:28:51 * hackagebot mysql-haskell 0.8.3.0 – pure haskell MySQL driver – https://hackage.haskell.org/package/mysql-haskell
03:34:38 <mivael> dfsafd, Memoization is indeed an issue for immutable data structures.  But laziness (non-strictness) is an option which does the trick.
03:36:38 <mivael> (although, not in all cases)
03:44:57 <fakenullie> I've implemented strict memoization by returning map updated with current result from recursion
03:53:46 <ertes-w> dfsafd: for memoisation i suggest just using a library like MemoTrie
03:54:25 <ertes-w> dfsafd: however, it won't make that naive fib fast, unless you use the *memoised* variant recursively
03:55:14 <dfsafd> ertes-w: then it is a little more convenient in imperative languages where you can just declare the function as memoized
03:55:41 <ertes-w> dfsafd: only if there is language-level support, otherwise it's the same deal
03:55:55 <ertes-w> the difficulty of memoisation is not inherent to haskell
03:56:49 <ertes-w> dfsafd: a much smarter option to memoise something like fib is to use dynamic programming, which requires that you write your function in a certain way
03:57:14 <ertes-w> but the smartest option is to just implement fib efficiently enough to not need any of this =)
03:57:48 <dfsafd> of course, but then what's the point of haskell if you cant write beautiful code?
03:58:15 <ertes-w> what's the relationship between what i said and code beauty?
03:59:04 <dfsafd> the relationship is obvious
03:59:55 <ertes-w> @let fib = f where fibs = unfoldr (\(x, y) -> Just (x, (y, x + y))) (0, 1); f = (fibs !!)
03:59:58 <lambdabot>  Defined.
04:00:02 <ertes-w> > fib 500
04:00:04 <lambdabot>  1394232245616978801397243828704072839500702565876973072641089629483255716228...
04:00:08 <ertes-w> > fib 501
04:00:12 <lambdabot>  2255915161619363308725126950360720720460113249137581905886388664184746277386...
04:00:51 <ertes-w> dfsafd: i don't see it
04:00:56 <dfsafd> way uglier, my slow def. is much closer to the mathematical one
04:01:32 <ertes-w> dfsafd: and you're saying that in imperative languages you can get both close to the math *and* fast *and* memoised?
04:02:01 <merijn> zipWith fibs is best fibs :)
04:02:51 <Ferdirand> linear algebra fibs is best fibs
04:03:23 <ertes-w> dfsafd: also the recursive definition is by far not the only definition…  another common definition of fibs in math is in terms of a sequence…  and that's *exactly* what i wrote =)
04:03:33 <ertes-w> so this is fast and memoised and close to the math =)
04:04:01 <ertes-w> (well, almost…  needs some extra strictness, but that's a matter of adding a bang)
04:05:13 <dfsafd> in python: def fib(num): return (1 if num < 2 else fib(num-1) + fib(num-2))
04:05:21 <dfsafd> with the annotation: @functools.lru_cache(maxsize=None)
04:05:54 <ertes-w> dfsafd: that's pretty much the same way you would write it with MemoTrie
04:07:22 <dfsafd> really? because the python method depends on annotating functions which i didn't think haskell could
04:08:41 <ertes-w> dfsafd: fib = memo fib' where fib' x | x < 2 = 1; fib' x = fib (x - 1) + fib (x - 2)
04:08:59 <ertes-w> dfsafd: haskell doesn't need annotations like that…  you can just wrap a function directly like here
04:09:23 <geekosaur> (also, while it's not normally used for this, there is an annotation pragma)
04:10:09 <merijn> Also, I feel compelled to complain loudly about recursive fibonacci
04:10:27 <merijn> Fibonacci is like the stupidest example of recursion since it's neither recursive nor particularly intuitive
04:10:32 <merijn> I hate people always bring it up
04:10:34 <ertes-w> dfsafd: function annotations are rather trivial syntactic sugar, even in python…  if you were to do this without annotations, you would almost write the haskell version
04:10:44 <merijn> Pre-/post-order tree traversal are so much nicer
04:10:56 <ertes-w> merijn: <ertes-w> but the smartest option is to just implement fib efficiently enough to not need any of this =)
04:10:57 <ertes-w> =)
04:11:01 <cocreature> merijn: and to make things worse, they then use it as an example for parallelization
04:11:08 <dfsafd> ertes-w: where does the memo function come from?
04:11:13 <ertes-w> dfsafd: MemoTrie
04:11:20 <ertes-w> dfsafd: https://hackage.haskell.org/package/MemoTrie-0.6.8/docs/Data-MemoTrie.html
04:11:28 <merijn> cocreature: It's up there with my annoyance with everyone always using QuickSort as the "default sort"
04:11:41 <merijn> QuickSort is a terrible sort and I hate people think it's a good interview algorithm
04:11:49 <geekosaur> mivael, if you don;t have hoogle on your system then I'm not sure how you could have it give you any results.. .unless you mean hoogle.haskell.org and that doesn't look on your system
04:11:52 <Ferdirand> so apparently, when you use a decorator with the @ annotation in python, recursive calls inside your function refer to the decorated version
04:11:53 <dfsafd> ertes-w: so not builtin? Ok :P
04:12:04 <ertes-w> dfsafd: nope, it's a library
04:12:11 <Ferdirand> how do you achieve that in haskell without y-combinator-trickery ?
04:12:33 <ertes-w> Ferdirand: mutual recursion, see above
04:12:46 <ertes-w> it's a common dynamic programming trick
04:13:03 <Ferdirand> ertes-w: yes, okay. matter of taste, i guess
04:13:25 <ertes-w> Ferdirand: that's what the python annotation translates to, if you use recursion
04:13:44 <merijn> I someone ever asks me an interview question about quicksort I'm just going to lecture them for half an hour on why quicksort is terrible >.>
04:13:45 <ertes-w> (in fact i'm not even sure it would work with recursion)
04:13:46 <Ferdirand> you cannot take an arbitrary already defined function and apply it a memoizing combinator
04:13:58 <Ferdirand> but you cannot do this with python decorators either, so fair enough
04:14:06 <merijn> Ferdirand: You can, IFF you have a method of storing the inputs
04:14:25 <merijn> Ferdirand: So, usually that means you need an Ord/Hashable/Eq instance on your inputs
04:14:33 <merijn> Which seems like a relaxed enough condition for most situations
04:14:51 <ertes-w> you're not going to memoise function arguments
04:15:05 <ertes-w> or polymorphic arguments
04:15:06 <merijn> ertes-w: No, but you need to lookup the result based on arguments, usually
04:15:25 <ertes-w> merijn: i was just reinforcing your "relaxed enough condition" note =)
04:15:45 <Ferdirand> merijn: even if the original function is defined recursively ?
04:15:51 <merijn> Ferdirand: Sure
04:15:56 <Ferdirand> without taking itself explicitely as an argument ?
04:16:00 <Ferdirand> how ?
04:16:01 <merijn> Ferdirand: That's what ertes-w' MemoTrie link does
04:16:28 <ertes-w> Ferdirand: MemoTrie also has a memoFix function
04:16:36 <ertes-w> that makes it easier
04:17:10 <ertes-w> fib = memoFix $ \mfib x -> if x < 2 then 1 else mfib (x - 1) + mfib (x - 2)
04:17:10 <merijn> ertes-w: He means he doesn't understand how to do it *without* fix
04:17:23 <ertes-w> it's not possible without fix
04:17:42 <merijn> ertes-w: You mean in the language?
04:18:04 <merijn> ertes-w: He's refering to using fix explicitly yourself to define the function to memoise, I'm pretty sure
04:18:17 <Ferdirand> indeed
04:18:26 <ertes-w> ah
04:18:28 <merijn> ertes-w: So "using Data.MemoTrie.memo" would qualify as "not using fix"
04:18:36 <Ferdirand> no
04:18:38 <cocreature> merijn: you can’t take an existing recursive function and transform it into a recursive function without modifying the code of that function
04:18:42 <merijn> Ferdirand: Why not?
04:18:46 <ertes-w> i'm confused =)
04:18:48 <mivael> geekosaur, I do have hoogle on my system.  Installed by means of OS, the same way as parsec and other haskell related packages.  I maybe wrote something wrong which made you think I do not have 'hoogle' binary on my system.
04:19:01 <cocreature> if you use "memo" you need to change the definition to call the memoized function in the recursive calls
04:19:13 <ertes-w> i don't think you can fully memoise a recursive function in haskell without fixpoint awareness
04:19:25 <merijn> hmm, maybe I'm thinking of the wrong issue
04:19:29 <ertes-w> whether you use fix or not doesn't seem overly relevant
04:19:45 <Ferdirand> i think we all agree
04:19:48 <ertes-w> of course my definition from earlier could be rewritten in terms of 'fix', but what's the point?
04:20:00 <ertes-w> memoFix on the other hand is quite handy
04:20:00 <cocreature> basically you can’t magically modify recursive calls in an existing definition to refer to a memoized version
04:20:07 <merijn> I guess memo doesn't memoise a recursive function the way Ferdirand meant
04:20:13 <ertes-w> it can't
04:20:33 <ertes-w> it can only memoise the surface…  deep memoisation requires fixpoint awareness
04:20:51 <Ferdirand> yes, that's what i tought
04:21:07 <ertes-w> what you can do is to write a template function
04:21:25 <ertes-w> fib r x = if x < 2 then 1 else r (x - 1) + r (x - 2)
04:21:38 <Ferdirand> yes, that's what i meant by "taking itself explicitely"
04:21:48 <ertes-w> this one is fixpoint aware and in fact can be passed to memoFix directly
04:22:54 * hackagebot ngx-export 0.9.0.0 – Helper module for Nginx haskell module – https://hackage.haskell.org/package/ngx-export
04:23:32 <ertes-w> Ferdirand: yeah, that's what my second example demonstrated
04:23:43 <ertes-w> Ferdirand: fib = memoFix $ \mfib x -> if x < 2 then 1 else mfib (x - 1) + mfib (x - 2)
04:23:55 <ertes-w> mfib is its memoised self
04:25:44 <ertes-w> BTW, if you master sharing, you'll probably never need memoisation =)
04:26:17 <ertes-w> or rather: you will do memoisation in domain-specific ways that are much faster than a generic memoiser like MemoTrie
04:26:44 <hpc> or you will use algorithms that don't depend on a time-space tradeoff to be performant
04:26:58 <merijn> hpc: Those don't always exist
04:27:26 <hpc> they do often enough that it's worth mentioning
04:27:31 <merijn> hpc: Or if they do, I'm forced to deny their existence since I'll ruin the entire point of my phd research ;)
04:27:58 <ertes-w> hahaha
04:28:06 <hpc> merijn: i see memoization like the naive translation from mutable to pure code
04:28:22 <hpc> it puts an upper bound on the damage you can do when writing sub-optimal code
04:28:30 <geekosaur> mivael, debian package appears to have added an update-hoogle command. which, I suspect, downloads a database instead of making one from what you have installed
04:28:52 <geekosaur> in which case it's likely all current hackage (or maybe some stackage lts) versions of things
04:29:14 <mivael> oh
04:29:14 <merijn> ertes-w: Basically, I'm arguing that I can speed up graph algorithms by switching between implementations at runtime, but that requires switching between representations and I'm currently justifying loading multiple representations as "it's just a classic time-space trade-off!" :p
04:29:35 <ertes-w> "what's the point?  there is a log-time constant-space algorithm for that!" – "sure, but just look at that beautiful GPU utilisation!" – "but…" – "don't you want to use your GPUs at least once in your life?!"
04:29:43 <mivael> geekosaur, sounds not like consistent behaviour to me  :)
04:30:09 <geekosaur> distros do what distros do. even debian gets to wear the dunce cap every so often
04:30:15 <merijn> mivael: Various package manager don't really consistently use cabal logically, tbh
04:30:40 <merijn> mivael: personally I just don't use package managers for haskell dependencies and let cabal handle it all
04:30:44 <hpc> my experience has been that the fedora family gets packaging the most right
04:30:52 <hpc> (but still don't use their haskell packages)
04:30:56 <geekosaur> suppose its a refreshing change over arch being the main distro screwing its haskell ecosystem up...
04:31:08 <merijn> Honestly, I don't even install GHC using package managers
04:31:12 <fakenullie> is there efficient algo for coin change problem without memoisation?
04:31:21 <merijn> Mostly, because not a single package manager works as non-root
04:31:45 <merijn> And cabal + GHC deserve a ton of kudos for how painless they work as non-root
04:31:45 <hpc> i use the package manager to install stack, and then do everything in an LTS
04:31:56 <merijn> Easily the least painful language I work with
04:32:06 <merijn> Everything Just Works (TM)
04:32:21 <hpc> and then i install the packaged ghc because "stack ghci" is too slow :P
04:32:32 <merijn> hpc: bindist all the things
04:32:52 <ertes-w> hpc: i don't know how well fedora does it, but nix manages to maintain almost a 1:1 correspondence between hackage packages and nixpkgs.haskellPackages…  it's autogenerated and Just Works (TM)
04:32:59 <geekosaur> 'not a single package manager' nix...
04:33:40 <hpc> ertes-w: fedora does it the same way debian does, they're just generally better at not messing up
04:33:46 <ertes-w> ah
04:34:14 <ertes-w> used to be like that in nixpkgs before the switch to "haskell-ng", and it was a mess
04:34:15 <hpc> it took debian until last year to get a policy on reproducible builds
04:34:22 <hpc> of course, they still happen on contributors' workstations
04:34:24 <merijn> geekosaur: I don't know any systems that have nix installed normally
04:35:06 <cocreature> “just works™” seems a bit of an overstatement. nix has a few hundred lines of manual configuration because the automation doesn’t actually work properly and some parts break fairly often
04:35:09 <ertes-w> merijn: nix works as non-root even in a single-user installation
04:35:48 <hpc> when i use nix it takes all of my brainpower just to not want to use it like puppet
04:35:50 <ertes-w> cocreature: the point is that the manual packaging and updating is gone…  when something breaks it gets fixed in a more scalable way
04:35:58 <merijn> ertes-w: Yeah, I got that from what geekosaur said, but I wasn't aware it did since no OS I know ships with it, and honestly I can't be arsed to learn something new now that most of my code has moved to Haskell anyway
04:36:04 <merijn> ertes-w: Since haskell already Just Works
04:36:08 <cocreature> ertes-w: now we have automatic breakage :P
04:36:44 <ertes-w> cocreature: if all else fails, undo the channel update and wait for it to get fixed =)
04:37:12 <hpc> cocreature: as silly as it sounds, if the majority of breakage is catastrophic and you don't see any catastrophic breakage
04:37:37 <hpc> i would feel more confident about that working correctly than something where breakage requires a more detailed traversal of the thing's features
04:38:31 <cocreature> ertes-w: sure I know my way around and I wouldn’t use nix (for some stuff) if I didn’t think it provides benefits. I just don’t like people claiming it magically just works when that’s not the case in my experience (and those are not the “I screwed up personally” issues but “it’s broken in nixpkgs for everybody”)
04:38:49 <maerwald> cocreature++
04:40:05 <ertes-w> cocreature: it seems like you took my "Just Works (TM)" too literally ;)
04:40:47 <cocreature> fair enough :)
04:40:53 <maerwald> it's not about the exact words so much, but the way people promote certain tools
04:41:36 <maerwald> sometimes it's hard to be enthusiastic and realistic at the same time
04:42:14 <ertes-w> cocreature: however, since the switch to haskell-ng problems with haskell+nix have become the exception rather than the norm…  the old haskell system was much much worse
04:42:30 <ertes-w> at least that much i'm confident in saying
04:45:13 <saurabhnanda> :t liftM2
04:45:15 <lambdabot> Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
04:45:37 <saurabhnanda> if I have an `a -> m b` how do I change it to `m (a -> b)`
04:45:50 <cocreature> you can’t
04:46:27 <merijn> You can't run an action depending on 'a' without giving it an 'a'
04:46:47 <cocreature> imagine you have a "Int -> Maybe ()". to decide if it is Nothing, you first need to provide an "Int". for "Maybe (Int -> ())" the fact that it’s Nothing can’t depend on the Int
04:47:44 <saurabhnanda> hmm
04:48:56 <saurabhnanda> rains on my party... but I'll have to work around it I guess
04:49:20 <merijn> saurabhnanda: What were you trying to do?
04:49:39 <cocreature> saurabhnanda: there might be a way to do this for your specific instance of "m" but for an arbitrary "m" that is an instance of Monad it just doesn’t make sense
04:50:25 <saurabhnanda> cocreature: merijn: would it involve calling runAppM to unwrap the `m`?
04:50:58 <cocreature> maybe? you haven’t told us what runAppM does
04:51:20 <cocreature> as I’ve explained before, if you’re "m" looks somewhat like Maybe, it just doesn’t make sense
04:51:25 <saurabhnanda> hang on... preparing a gist
04:53:49 <dfsafd> is there a function for getting all permutations of a given length of a list?
04:55:05 <dfsafd> i mean combinations, not permutations
04:55:55 <mivael> geekosaur, merijn: well, it seems that I should eventually try to install/use haskell environment without relying on OS packaging.
04:56:30 <arcetera> I'm attepmting to write a function that can return a Double, Integer, Complex, or Rational type
04:56:36 <arcetera> how do I write a type definition for it?
04:56:38 <saurabhnanda> cocreature: merijn: trying to reduce code duplication in `srcBuilder` at https://gist.github.com/saurabhnanda/2406ccd5811c43993d66cdfd6ccdf8af
04:56:45 <merijn> mivael: A lot of people use/like stack, but I don't so I can't really recommend anything specific about it
04:56:51 <arcetera> i'll pastebin in a minute
04:58:07 <merijn> mivael: Personally, the way I install stuff on linux and OSX is: 1) download GHC bindist, "./configure --prefix=$HOME/ghc82 && make install" (prefix changed to whatever is logical) 2) if I have no cabal-install, install from source as documented in the Cabal README, if I already have cabal-install (from a previous/different haskell install) use that
04:58:15 <merijn> mivael: Then install everything else via cabal-install
04:58:25 <arcetera> http://lpaste.net/359071
04:58:29 <arcetera> and there we go
04:59:13 <merijn> mivael: If I want to use different compiler versions I just install them into different prefixes (I have ~/ghc710, ~/ghc80, ~/ghc82 at the moment), I change versions my just modifying my path (cabal-install automatically uses the one first in your path)
04:59:17 <cocreature> saurabhnanda: not sure what that has to do with your originial question. if you want to remove duplication just extract the common parts into a function, i.e., "let f g = pure $ \p -> L.src_ $ T.concat [d, "/"", g p]". then the first expression is f id and the second is f \p -> fromJustNote … …"
04:59:46 <saurabhnanda> cocreature: let me rephrase. In the definition for `srcBuilder`, I want to use `assetUrl` function.
05:00:05 <saurabhnanda> cocreature: the duplication of code is between srcBuilder and assetPath/assetUrl functions
05:00:31 <arcetera> function is designed to unpack a number for use in a function wrapping some math primitives 
05:02:01 <merijn> saurabhnanda: Can't you change srcBuilder to be "RelativeAssetPath -> m L.Attribute"?
05:02:20 <merijn> saurabhnanda: Then you can just return assertUrl
05:02:25 <cocreature> or assetUrl to "m (RelativeAssetPath -> Text)"
05:02:34 <cocreature> but that’s probably less useful
05:02:38 <saurabhnanda> merijn: no, I'm trying to make the call-side within Lucid easier.
05:02:50 <saurabhnanda> *call-site
05:03:51 <Ferdirand> arcetera: you could define a new type that can only be Number, Ratio, Float or Complex... or you could rethink your wrapping
05:04:37 <saurabhnanda> cocreature: merijn: let it be... I'm going ahead with this minor duplication. 
05:05:23 <arcetera> yeah i kinda figured
05:08:46 <Darwin226> I really hate that there's a monad instance for tuples and functions
05:09:22 <ertes-w> Darwin226: why?
05:09:23 <saurabhnanda> on ghci, I'm getting this error -- "(use -fprint-potential-instances to see them all)" -- while loading a module. How exactly do I pass this argument to ghci?
05:09:33 <Darwin226> The number of times that I've been handed completely useless error messages because the compiler assumed that my monad was (a,) or (a ->) is reaching tripple digits
05:10:03 <Darwin226> forgot an argument to a function that returns a monadic value? have fun figuring that one out
05:10:27 <ertes-w> Darwin226: the instances can be useful though
05:10:31 <k_bx> Hi! We're starting a Haskell Learning Group in Kyiv, Ukraine. First Meetup will be at 17 October (Tuesday) and will continue on weekly basis at the Institute of Mathematics. See full info about the first meetup at https://www.meetup.com/Kyiv-Haskell-Learning-Group/events/243945548/ Info about the course itself (in Ukrainian): https://github.com/KyivHaskell/haskell-study-startup See you there!
05:10:43 <Darwin226> I've used the applicative instace for function occasionally
05:10:47 <arcetera> the thing is I have a function numericBinop that takes as an argument a function that unpacks all of its number arguments
05:10:56 <Darwin226> never the monad one because I usually go for the explicit reader then
05:11:08 <arcetera> so how do I unpack every number argument in that manner?
05:11:14 <ahihi> eventually you learn to look for missing arguments when you get those errors :P
05:11:31 <Darwin226> I wish I could somehow override them and error on them
05:11:31 <ertes-w> k_bx: you should probably post that on haskell-cafe…  here it will only get lost in the backlog
05:12:02 <merijn> And maybe /r/haskell?
05:12:06 <Darwin226> ahihi: I don't know... This one consistently manages to confuse me
05:12:33 <arcetera> takes a function that takes Num a => a -> a -> a
05:12:46 <k_bx> ertes-w: that's what I was going to do next. Promoting it right now :)
05:12:58 <ertes-w> k_bx: good luck =)
05:13:02 <k_bx> thank you!
05:13:21 <ertes-w> Darwin226: i wouldn't remove instances for that reason
05:13:36 <ertes-w> Darwin226: learning to read instance errors is much more valuable =)
05:14:14 <Darwin226> ertes-w: It's a skill I shouldn't have to learn. The errors should be useful
05:14:34 <ertes-w> Darwin226: the error *is* useful…  and i disagree, you should totally learn that skill
05:15:18 <ertes-w> Darwin226: i mean what else should it report?  for example what error do you want to get when you forget an argument to 'sin' or 'negate'?
05:15:19 <ertes-w> same deal
05:15:22 <Darwin226> Ok, I'll rephrase. The error should explicitly point to the issue, not just have enough information to allow for cunning deduction
05:15:27 <ertes-w> > sin + 5
05:15:30 <lambdabot>  error:
05:15:30 <lambdabot>      • No instance for (Num (Double -> Double))
05:15:30 <lambdabot>          arising from a use of ‘e_15’
05:15:47 <Darwin226> Yep, isn't it great how there's a missing instance for num
05:15:54 <Darwin226> even though there could absolutely be one?
05:16:21 <merijn> Darwin226: Well, what do you expect GHC to do about that?
05:16:30 <merijn> Darwin226: Disallow instances for functions?
05:16:45 <Darwin226> There are many possible solutions
05:16:46 <merijn> My favourite ever typeclass instance is for functions, so I'm not a fan of that
05:16:52 <merijn> Darwin226: Like?
05:16:56 <ertes-w> Darwin226: like what?
05:17:01 <Darwin226> Btw, check out the rest of the error above: maybe you haven't applied a function to enough arguments?
05:17:07 <Darwin226> That's what I expect
05:17:28 <ertes-w> Darwin226: but how should it know that you forgot an argument?
05:17:32 <Darwin226> but GHC can't do that for Monad because there is an actual instance and by the time the error occurs, who knows if it's because of that
05:18:21 <merijn> Darwin226: Do you have an example error?
05:18:23 <Darwin226> I don't really EXPECT the compiler to do anything about it since this is a venting rant more than anything else
05:18:33 <merijn> Darwin226: also, which GHC are you using atm?
05:18:45 <Darwin226> but I can fantasize about magical flags that turn off those instance for my code
05:18:48 <ertes-w> @let instance (Num b) -> Num (a -> b) where (+) = liftA2 (+); (*) = liftA2 (*); negate = fmap negate; abs = fmap abs; signum = fmap signum; fromInteger = pure
05:18:48 <lambdabot>  Parse failed: Illegal instance declaration
05:18:56 <ertes-w> @let instance (Num b) => Num (a -> b) where (+) = liftA2 (+); (*) = liftA2 (*); negate = fmap negate; abs = fmap abs; signum = fmap signum; fromInteger = pure
05:18:58 <lambdabot>  .L.hs:278:23: error:
05:18:58 <lambdabot>      • Couldn't match type ‘b’ with ‘Integer’
05:18:58 <lambdabot>        ‘b’ is a rigid type variable bound by
05:19:02 <merijn> Darwin226: 8.2 has a rather considerable overhaul of error reporting
05:19:03 <ertes-w> @let instance (Num b) => Num (a -> b) where (+) = liftA2 (+); (*) = liftA2 (*); negate = fmap negate; abs = fmap abs; signum = fmap signum; fromInteger = pure . fromInteger
05:19:06 <lambdabot>  Defined.
05:19:08 <ertes-w> > sin + 5
05:19:11 <lambdabot>  <Double -> Double>
05:19:20 <merijn> ertes-w: Hah
05:19:28 <ertes-w> well, lambdabotisms
05:19:29 <merijn> ertes-w: Owned by the Show instance for monomorphic functions
05:19:35 <ertes-w> heh, yeah
05:20:07 <Darwin226> > do { y <- sin; return y }
05:20:10 <lambdabot>  <Double -> Double>
05:20:54 <ertes-w> > do { y <- sin; pure (y^2) } + do { y <- cos; pure y }^2
05:20:57 <lambdabot>  <Double -> Double>
05:21:11 <ertes-w> > (do { y <- sin; pure (y^2) } + do { y <- cos; pure y }^2) 500
05:21:15 <lambdabot>  1.0000000000000002
05:21:28 <ertes-w> > (do { y <- sin; pure (y^2) } + do { y <- cos; pure y }^2) 500 :: CReal
05:21:30 <Darwin226> merijn: Anyways, I can't use 8.2 ATM, but AFAIK it's only a cosmetic overhaul, no?
05:21:31 <lambdabot>  1.0
05:22:17 <merijn> Darwin226: It's considerably different from 7.10 at least
05:25:00 <mniip> > (sin * sin + cos * cos) 3.0
05:25:03 <lambdabot>  0.9999999999999999
05:25:49 <Darwin226> Ironically, I'd get much more mileage from a Num instance on functions than I get for the other classes
05:26:56 <ertes-w> i'm an occasional abuser of 'join' for functions =)
05:27:03 <ertes-w> > join (++) "abc"
05:27:05 <lambdabot>  "abcabc"
05:27:38 <centril> ertes-w: aren't we all
05:27:50 <centril> and of (***) and (&&&)
05:31:01 <bollu> Quick question: when I dump stg with -ddump-stg, can I get the STG in a separate file? (like I can with GIMPLE in GCC)
05:37:39 <_sras_> I am trying to create a custom docker image for an App with all the haskell package dependencies bundled in. I tried creating a stack and ~/.stack folder in container and have installed all the dependencies there. But when using for the build, stack still download the packages during the build. 
05:38:33 <merijn> _sras_: ok, so I don't use/know either stack or docker, so this might be a dumb question, but: Why not just distribute a statically executable and call it a day
05:40:46 * hackagebot semiring-num 1.5.0.0 – Basic semiring class and instances – https://hackage.haskell.org/package/semiring-num
05:42:29 <mivael> merijn, thank you for the installation instruction!  Now I have something to start with.
05:43:09 <_sras_> merijn: The image will be used to create builds for deploying. It is a web app.
05:50:07 <arcetera> so if I'm trying to unpack various number types (e.g. rational, float, integer) into one list that can be passed to +, -, div, etc
05:50:18 <arcetera> what should I do?
05:53:51 <merijn> arcetera: Parameterise your original datatype over the type of number inside?
05:58:31 <cocreature> _sras_: can you be a bit more specific? how did you install the deps in the container? and how are you running stack during the build?
06:00:59 <_sras_> cocreature: I started a terminal in the container. Switched to the `stack` user and then I copied the projects `.cabal` and `stack.yaml` files into the container. Then I did a stack build using those files. The pacakge index and dependencies were downloaed and cached in the /home/stack/.stack folder.
06:01:37 <_sras_> cocreature: Then I made an image out of the running container using the 'docker commit'
06:02:22 <_sras_> cocreature: I am using that new image for the build now. If I log in to the container, I can see the cached files in the /home/stack/.stack folder. 
06:02:56 <_sras_> cocreature: During the build I just enable docker using the --docker flag.
06:03:13 <_sras_> cocreature: the image name is specified in the stack.yaml file.
06:03:57 <cocreature> _sras_: if you use the --docker flag, stack places things in ~/.stack and .stack-work _outside_ of your container afaik
06:04:01 <arcetera> merijn: so create a seperate LispNum type that takes an argument as to what type of number to take?
06:04:40 <arcetera> doesn't that just add another layer for me to un--- oh wait 
06:04:42 <arcetera> aha
06:05:23 <_sras_> cocreature: Yes. But the stack documentation's section on 'custom images' contain this line that says "
06:05:36 <_sras_> cocreature: "Create a user and group named stack, and create a ~/.stack directory for it. Any build plans and caches from it will be copied from the image by Stack, meaning they don't need to be downloaded separately."
06:06:36 * hackagebot conduit-algorithms 0.0.6.0 – Conduit-based algorithms – https://hackage.haskell.org/package/conduit-algorithms
06:07:11 <merijn> arcetera: I meant change it to "LispExpr a" "LispNum a"
06:07:13 <merijn> argh
06:07:39 <arcetera> i see
06:07:39 <merijn> Anyone have any suggestion how to debug my haskell program somehow being convinced connected sockets aren't connected?
06:08:23 <Dougger> I'd like to perform disk I/O once (to get a list of files) and then reference the list without having to perform the disk I/O again. What's the recommended approach in Haskell?
06:08:29 <cocreature> _sras_: ah interesting, sorry not sure why it isn’t working as it claims to
06:08:51 <arcetera> what's the argument for though?
06:08:57 <arcetera> the type which I'd like to use?
06:09:23 <merijn> arcetera: Yes
06:12:00 <arcetera> so if LispVal is LispExpr | LispNum
06:12:14 <arcetera> but, say, I had String Text and Atom Text in the original LispVal
06:12:28 <arcetera> should i make a type alias for Atom and LispString?
06:12:39 <arcetera> one helluva refactor
06:15:09 <fakenullie> I think your arithmetical functions should just take LispVal and return LispVal
06:15:18 <arcetera> but then if I have a type LispList a = [LispVal a] merijn 
06:15:32 <arcetera> i can't create a list (2 'a)
06:15:41 <arcetera> which is valid scheme
06:15:53 <fakenullie> why can't you?
06:16:15 <arcetera> because the list will only contain LispVals of a certain type
06:16:32 <fakenullie> [Float 1.0, Atom "a"]
06:16:37 <mnoonan_> presumably you’d want LispList to be a constructor “LispList [LispExpr]” of LispExpr
06:16:48 <fakenullie> arcetera: the type is LispVal
06:16:49 <mnoonan_> or more likely, “LispCons LispExpr LispExpr”
06:17:05 <mnoonan_> *oops, replace LispExpr with LispVal above
06:18:01 <arcetera> the way i'm implementing arithmetic functions is unpacking into numbers and running them through the haskell ops
06:18:18 <arcetera> numericBinop op params = Number $ foldl1 op $ map unpackNum params
06:18:22 <fakenullie> oh, sorry, I should not interfere with other one trying to help
06:18:42 <fakenullie> but to me looks like you don't want unpack
06:18:56 <arcetera> just operate directly on the lispvals?
06:18:59 <fakenullie> yes
06:19:06 <arcetera> i suppose that could work yes
06:23:11 <merijn> ok, wtf
06:23:15 <merijn> I have this code: http://lpaste.net/2018079594791305216
06:23:27 <merijn> And it prints it readable, writable and connected
06:23:50 <merijn> Yet shutdown throws an exception "Network.Socket.shutdown: invalid argument (Socket is not connected)" every time
06:23:58 <merijn> wtf is going on there?
06:24:16 <_sras_> cocreature: If it works according to the doc,I mean, even the cached files was being used, it still needs to be compiled and built, right?
06:25:15 <merijn> Or am I getting hit with a super annoying race condition where the remote is closing before I succesfully shutdown and then crash on shutdown?
06:29:30 <earthy> really depends on the remote
06:30:41 <merijn> The remote just reads all input and then writes something back and exits
06:30:54 <merijn> If I get rid of the shutdown it hangs indefinitely like I'd expect
06:31:04 <earthy> you're not sending or reading, in that bit of code
06:31:46 <earthy> if the remote has already sent it all, and does a close on its end, then your connection may already have been torn down on your end
06:31:53 <merijn> earthy: There's some sendAll above it
06:32:05 <earthy> though that'd be indeed highly annoyingly raceconditiony
06:32:12 <merijn> earthy: The remote doesn't start sending until the send side is closed
06:32:24 <earthy> and bad form on the remote
06:32:29 <earthy> ah, you control the remote?
06:32:41 <merijn> earthy: Server blocks until upstream returns EOF (hence the shutdown)
06:32:42 <quchen> Anyone got the unsafeCoerce implementation via unsafePerformIO handy?
06:32:42 <merijn> earthy: Yes
06:32:53 <earthy> merijn then that should not happen
06:33:04 <merijn> earthy: Ah!
06:33:12 <merijn> Looks like shutdown is called elsewhere
06:33:13 <earthy> unless there's network interference
06:33:17 <merijn> The mystery deepens
06:33:24 <merijn> earthy: It's unix socket, so local only
06:33:40 <earthy> yeah, shutdown, as opposed to close, shuts down on all instances of the fd
06:33:50 <merijn> I wrapped the shutdown in a handler and that one is returning succesfully
06:33:50 <earthy> (as it starts the teardown handshake)
06:33:55 <merijn> shutdown is being called elsewhere
06:34:03 <merijn> Time to get a profiling built with stack trace...
06:35:56 <merijn> doh...
06:36:26 <mnoonan_> quchen: https://gist.github.com/ppetr/3693348
06:37:02 <quchen> Thanks :-)
06:37:43 <mnoonan_> I thought I remembered seeing one that didn’t use polymorphic references, but maybe I’m mistaken.
06:38:20 <merijn> earthy: Found the culprit: https://hackage.haskell.org/package/network-2.6.3.2/docs/src/Network-Socket-ByteString-Lazy.html#getContents
06:38:41 <merijn> earthy: It calls "shutdown" when the socket runs out of data
06:38:51 <merijn> earthy: But that only happens when the socket is closed
06:38:53 <mnoonan_> quchen: heh, I just noticed the same example is in the docs: https://hackage.haskell.org/package/base-4.10.0.0/docs/System-IO-Unsafe.html
06:39:04 <merijn> earthy: And calling shutdown on a closed socket throws an exception
06:39:14 <merijn> earthy: So I'm confused how the fuck anyone expected this to ever work?!
06:39:15 <earthy> uhuh
06:39:23 <earthy> no clue. sounds stupid.
06:39:25 <merijn> Does no one use this module?
06:39:28 <merijn> ffs
06:39:41 <quchen> mnoonan_: Oh, I should have remembered that, I stumbled upon it a couple of times now. Hopefully next time :-)
06:40:42 * hackagebot primes-type 0.2.0.3 – Type-safe prime numbers. – https://hackage.haskell.org/package/primes-type
06:41:02 <quchen> mnoonan_: I wonder why [a] is used, and not simply undefined
06:41:13 <quchen> :: a
06:41:37 <merijn> Jesus christ...
06:41:47 <merijn> This makes my leave so needlessly more difficult :(
06:42:03 <merijn> s/leave/live
06:42:08 <merijn> Can't even spell anymore
06:42:08 <quchen> http://lpaste.net/359076
06:52:46 <mnoonan_> quchen: yeah, it seems to work fine. maybe they just wanted to avoid “undefined” in the example?
06:53:09 <quchen> For safety reasons, I assume.
06:54:40 <mnoonan_> har har :)
06:54:57 <merijn> earthy: Right, the library is just broken. I'll take this as my queue to finally actually hijack the maintenance of network, since literally no one appears to be doing it
06:55:37 <merijn> I wrote my own version of getContents and it immediately works flawlessly
06:55:50 <merijn> That was a waste of an afternoon
06:57:35 <fendor> merijn, out of curiousity, what library did you use?
06:57:41 <merijn> fendor: network
06:57:49 <fendor> just network?
06:57:52 <merijn> fendor: Yes
06:58:12 <fendor> ok, well, i only used simple.network, always fitted my use case
06:58:33 <earthy> yeah, the haskell ecosystem is... thin
06:58:38 <merijn> I've noticed before that it's...not well maintained to put it lightly.
06:58:44 <merijn> fendor: No such package I can find?
06:59:10 <fendor> merijn, https://hackage.haskell.org/package/network-simple-0.4.0.5/docs/Network-Simple-TCP.html
06:59:21 <fendor> ok, yeah, this is only for tcp
06:59:33 <bolver> hi there
07:00:06 <merijn> The main reason I've held back from usurping network is that I'm unable/unwilling to test Windows support
07:00:28 <merijn> But in previous discussion people agree that linux/osx/bsd only maintenance is preferable to none
07:00:28 <ertes-w> merijn: while you're at it, please make a separate NetworkException type with meaningful constructors =)
07:00:49 <merijn> fendor: Yeah, I regularly use Unix sockets
07:00:52 <bolver> i am trying to set up haskell-interactive-mode on emacs, but the autocomplete feature, among other things, don't seem to work.  appreciate any help 
07:01:16 <ertes-w> bolver: does GHCi interaction itself work?
07:01:27 <bolver> ertes-w: yes, it does
07:01:27 <merijn> fendor: network-simple still uses network internally, so a broken stuff in network still affects you indirectly
07:01:39 <bolver> ertes-w: ghci repl opens up
07:01:52 <fendor> merijn, i see... well, that's terrible :D 
07:02:12 <ertes-w> bolver: then completion should work, too
07:02:20 <ertes-w> bolver: unless by "autocomplete" you mean something else
07:02:30 <fendor> and you want to rewrite it now?
07:03:06 <merijn> fendor: Not rewrite (well, at least certainly not initially), just incrementally fix broken stuff
07:03:24 <bolver> ertes-w: suppose i type import Control., then autocomplete should show me a list of possible completions, but doesn't
07:03:37 <merijn> Like, the lack of network specific exceptions as ertes-w points out. Broken things like getContents
07:03:51 <fendor> merijn, so, fork it?
07:04:39 <merijn> fendor: Since there's no active maintainer, why bother forking if you can just fix network directly
07:04:54 <merijn> That way you don't split the ecosystem around network
07:05:08 <merijn> Anyway, gym first, package takeovers later
07:05:10 <ertes-w> bolver: unfortunately i have no further ideas…  once GHCi interaction worked for me, completion worked as well
07:05:25 <ertes-w> bolver: are you completing with M-tab?
07:06:08 <ertes-w> bolver: it's bound to 'complete-symbol' for me
07:06:09 <bolver> ertes-w: when you say GHCi interaction worked, what exactly do you mean?  may be i am missing something.  for example, C-c, C-l works for me
07:06:18 <ertes-w> bolver: yes, that's what i mean
07:07:14 <bolver> ertes-w: amazing ... autocomplete just doesn't, but curiously, autocomplete works in the GHCi repl it opens up!
07:07:40 <ertes-w> bolver: check that you're actually using the complete-symbol function
07:07:53 <aramiscd> test
07:07:58 <aramiscd> hello #haskell
07:08:04 <ertes-w> bolver: type "import Control.", then M-x complete-symbol RET
07:08:19 <bolver> ertes-w: ok
07:08:43 <ertes-w> bolver: if that offers completions, then it's a matter of key bindings
07:09:04 <ertes-w> bolver: also note that haskell-mode only offers GHCi-based completions, if the module is actually loaded
07:09:17 <ertes-w> otherwise it falls back to TAGS
07:10:41 <bolver> ertes-w: you know, i did what you suggested, and it DID give a list of options!
07:11:20 <bolver> i mean, i typed "import Control." and did what you suggested
07:11:49 <bolver> ertes-w: so something amiss with the key-bindings?
07:12:30 <bolver> ertes-w: btw, yeah, i loaded the module using C-c C-l, and then checked for autocompletion
07:13:04 <aramiscd> I'd like to call vim from a haskell program.  In python I can just do `os.system('vim')` and I'll end up in an interactive vim session.  Any idea how to do this in haskell?  I found Shelly and things like `main = Shelly.shelly $ do Shelly.run "touch" ["my_file"]` work, but `main = Shelly.shelly $ do Shelly.run "vim" []` does not work as expected, i.e. it doesn't give me an interactive vim session.
07:14:50 <fendor> merijn, sorry, switched building, so, you would fork it, wouldn't you? i'm asking, because i am unsure how you can fix an exisiting package where the maintainer is not present anymore
07:15:35 <ertes-w> bolver: yes, the default key binding for completion is M-tab
07:15:57 <bolver> ertes-w: let me check that
07:16:46 <ertes-w> bolver: i have also bound tab to indent-for-tab-command, but that one is a bit strange, because it will prefer to indent, and more often than not you would want completion rather than indentation
07:17:07 <ertes-w> so now i'm just using separate keys for indentation and completion
07:18:09 <bolver> ertes-w: M-tab works!! i just didn't know that it was the default key binding.  instead, i thought that it was just tab
07:19:10 <bolver> ertes-w: what about M-/? isn't that used for completions as well?
07:19:23 <ertes-w> bolver: dunno
07:20:32 <ertes-w> bolver: M-/ is bound to dabbrev-expand for me, which is not completion
07:20:33 <bolver> ertes-w: thanks anyway -- what you suggested works, though.  but the haskell-mode documentation didn't mention anywahere M-tab is the default key binding ... at least i didn't find one
07:20:45 <ertes-w> bolver: because it's not specific to haskell-mode
07:20:52 <ertes-w> M-tab is the emacs default
07:20:53 <bolver> ertes-w: i see
07:21:19 <bolver> ertes-w: alright ... silly me!
07:22:11 <shapr> hippie-expand!
07:22:28 <bolver> ertes-w: the haskell mode has also some some custom-set-variables, such as (haskell-process-suggest-remove-import-lines t)
07:22:46 <hexagoxel> aramiscd: Use System.Process. createProcess_ _ (proc _ _) >>= \(_, _, _, handle) -> waitForProcess handle
07:22:55 <hexagoxel> or something in that direction.
07:23:11 <bolver> when i type some redundant or useless import statement, it doesn't seem to do anything
07:23:37 <ertes-w> bolver: it does, but i'm not sure when exactly it's triggered
07:23:53 <ertes-w> bolver: in fact it may only trigger if you have at least -W
07:24:08 <bolver> ertes-w: i see
07:24:27 <aramiscd> hexagoxel: Thank you!  I'll look into that.
07:24:31 <bolver> ertes-w: you mean -W option in ghc compile command?
07:24:45 <ertes-w> bolver: i just enable -Wall and read the warnings…  i have all suggestions disabled, because they annoy me more than they help
07:24:59 <ertes-w> bolver: the suggestions are modal queries, so they break the development flow
07:25:21 <ertes-w> bolver: yes, the GHC flag
07:25:35 <bolver> ertes-w: i see
07:25:54 <ertes-w> bolver: usually i just keep adding imports without removing any, until i'm done with the module…  then i remove all unnecessary imports
07:26:27 <bolver> ertes-w: you see, but how do you find the unused import?
07:26:33 <ertes-w> with -Wall enabled i can just jump from unused import to unused import
07:26:39 <bolver> ertes-w: i see
07:26:51 <ertes-w> it warning-highlights all unused imports
07:27:01 <bolver> ertes-w: i use flycheck, and it report them quite nicley
07:27:01 <ertes-w> and you can jump between them using e.g. next-error
07:27:34 <ertes-w> i don't…  i'm kinda used to just typing C-c C-l every few seconds =)
07:28:11 <ertes-w> flycheck would probably just confuse me
07:28:19 <bolver> ertes-w: as you work in emacs, C-c C-l has hard-coded compilation flags ... so how do you work around that? 
07:28:20 <ertes-w> or even annoy me
07:28:33 <ertes-w> "hard-coded"?
07:28:58 <ertes-w> there is haskell-process-args-ghci
07:29:27 <bolver> ertes-w: yes
07:29:58 <bolver> i am just working with a single haskell source file ... with no cabal file etc
07:30:24 <ertes-w> i have set haskell-process-type to ghci and provide my own shell script wrapper around GHCi for nix integration…  haskell-mode doesn't support nix by itself
07:30:40 <bolver> ertes-w: i see ...
07:30:41 <ertes-w> and the nix-specific part is only used when there is a .cabal file
07:30:47 <ertes-w> otherwise it just fires up plain GHCi
07:30:57 <bolver> ertes-w: yeah, i thought so
07:31:41 <bolver> so if it is using GHCi, can you set the compilation flags?
07:32:28 <ertes-w> compilation?  you mean the interpreter flags?
07:32:42 <ertes-w> or do you mean C-c C-c?
07:32:44 <bolver> ertes-w: yeah, sorry, interpreter flags
07:33:08 <ertes-w> yes, you can:  M-x customize-variable RET haskell-process-args-ghci RET
07:33:31 <bolver> i see
07:34:25 <bolver> ertes-w: you can also compile by seting key bindings to haskell-compile
07:34:46 <bolver> but then, within haskell-compile, the flags are hard-coded
07:35:08 <ertes-w> i think so, but i don't know…  i'm using a Makefile for standalone modules
07:35:28 <bolver> ertes-w: i see
07:35:54 <Ero2> Greetins 
07:36:49 <bolver> ertes-w: thanks much ... i think your suggestions resolved the problem
07:37:40 <Ero2> Is there a way for a data constructor to be defined by other data constructors, rather than by other types?
07:38:11 <ertes-w> Ero2: what are you trying to do?
07:58:39 <Ero2> ertes-w: I was interested in the curry-howard isomorphism. And I wanted to create a program according to the rules of a game. One of the rules states what the full deck consists of. I wanted to then construct a type that fully reflects a 'full deck' 
07:58:47 <Ero2> im not sure if that answers your question ertes-w 
08:00:12 <Ero2> i thought i had achieved my goal with GADT's but then I was unable to make one of my types an instance of typeclasses
08:00:19 <Ero2> so i'm back to square 1
08:01:28 <ertes-w> Ero2: haskell is not well suited for formal verification on that level, but if you still want to try it, you should look into singleton types
08:02:07 <ertes-w> Ero2: they are the bridge between the value level and the type level
08:08:04 <Ero2> thanks ertes-w . It was something interesting i thought i would try but if the tools are incorrect ithink i'll just skip that :)
08:37:22 <Ero2> i really want to peruse 'logic in computer science' but its  £50 just to have a look! 
08:40:11 <[exa]> Ero2: in fact, full book PDF is googlable
08:40:35 <Ero2> [exa] tell me more, I beg
08:41:04 <[exa]> google "logic in computer science pdf" ?
08:41:15 <Ero2> good god, you're right!
08:41:48 <Ero2> My wallet & I thank you, good stranger
08:48:08 <Ero2> can anyone vouch for a book like 'logic in computer science' significantly improving their usage of haskell?
08:54:46 <srk> heh, exactly what I need :D
08:55:24 <_sras_> How can I make stackl install dependencies to a global location instead local .stack-work folder?
08:55:25 <srk> started reading types and programming languages and I miss some logic basics :)
08:58:25 <brynedwards> _sras_: Run the stack command in a folder that doesn't contain a .stack-work folder
09:01:20 <nicknight> I have a really silly questions...how many hours do you sleep in a day ?
09:04:27 <blackdog> nicknight: at least 8 if i can get it. don't buy the whole idea that Real Hackers(TM) work insane hours.
09:04:47 <blackdog> i pulled 100 hour weeks in my first startup. my code was shithouse. i would have been better off working 40 focused hous.
09:06:02 <nicknight> blackdog:  that is okay...I did a morning job and when back to home I slept and woke up and didnt learn anything already midnighthere :(
09:06:38 <_sras_> brynedwards: When I remove the .stack-work, the next run of stack build just creates it again.
09:07:58 <srk> nicknight: like 10 for last year, 8-6 before
09:08:00 <DigitalKiwi> nicknight I sleep 4 hours if I'm lucky
09:08:42 <srk> but I'm wasted anyway cause I'm mostly awake during night
09:08:54 <nicknight> ok aramiscd  DigitalKiwi  then you might be sleeping at office :P
09:09:07 <DigitalKiwi> sometimes if I'm really depressed I'll sleep 3 hours and wake up for a little bit and then sleep 3 more
09:09:18 <nicknight> I almost became insomanaiac staying nights daily till 4/5
09:09:35 <DigitalKiwi> I haven't been able to sleep for 20 years
09:09:46 <DigitalKiwi> because that would be too long
09:10:04 <nicknight> DigitalKiwi:  when you sleep after those 3 hours there are chance do get sleep paralysis on that day
09:10:04 <Psybur> I sleep like 10-6:30 ;p
09:10:26 <DigitalKiwi> I haven’t slept for ten days, because that would be too long. -- Mitch Hedberg
09:10:29 <Psybur> On the floor
09:11:20 <Psybur> Get into heavy lifting. You can tire yourself out in a few reps :D
09:12:31 <ahihi> i can't tell if this is a types joke or not
09:12:33 <ranberry> Lots of physical activity after work helped me with sleep as well
09:13:14 <brynedwards> _sras_: What do you want to do exactly? stack already builds dependencies in $HOME/.stack/snapshots and copies the dependencies to stack-work. If you run stack build in a folder without stack.yaml and .stack-work, it will use global stack resolver.
09:13:15 <DigitalKiwi> I most likely have sleep apnea in addition to my body hates me and doesn't regulate my temperature well so I go between sweating and then shivering and any noise wakes me up and yeah :| luckily I don't need a lot of sleep, because I don't
09:13:27 <Psybur> Lifting heavy weights is also good for your eyes which as computer people we probably strain them
09:14:04 <DigitalKiwi> my eyes are fine, I only need new glasses 2 times a year!
09:14:11 <Psybur> Dx
09:14:55 <DigitalKiwi> kidding, I can usually go a few years without new glasses, my contacts only change slightly, sometimes in the opposite direction...
09:15:04 <Psybur> Hmm, maybe its actually bad for your eyes
09:15:44 <DigitalKiwi> my doctor is never concerned, I tell him I'm on the computer 18 hours a day and he's like you're fine...
09:16:20 <_sras_> brynedwards: I am trying to create a docker image with all the hackell package bundled in. I am following the "Custom image" section of the stack documentation. There it says this
09:16:24 <_sras_> brynedwards: "Create a user and group named stack, and create a ~/.stack directory for it. Any build plans and caches from it will be copied from the image by Stack, meaning they don't need to be downloaded separately."
09:16:50 <Psybur> DigitalKiwi, you just need to tap your foot and you pretty much get rid of the risk of going sedentary
09:16:55 <_sras_> brynedwards: I tired this, but it seems that stack rebuilds the packages anyway
09:17:13 <cocreature> _sras_: are the build plans actually being copied to the host?
09:17:16 <Psybur> Also remember to recline at a 135 degree angle if you sit
09:17:32 <DigitalKiwi> Psybur I get a lot of exercise by going to the kitchen a few times an hour
09:17:41 <Psybur> DigitalKiwi, oh you :D
09:18:03 <Psybur> DigitalKiwi, get a weighted fork
09:18:21 <DigitalKiwi> I actually do that, I open the fridge, and then I don't eat anything
09:18:41 <Psybur> Catch and release sport eating, never heard of that one hah
09:18:42 <_sras_> cocreature: I see a `build-plan` and `build-plan-cache` in the container's "/home/stack/.stack" folder
09:18:47 <sm> sounds like you need a new doctor :)
09:18:48 <DigitalKiwi> the exact same (or lack of) food is always there and I check anyway
09:19:00 <mpickering> phadej: Do you know why "makeElement" has a phase annotation on the inline pragma?
09:19:07 <mpickering> {-# INLINE[1] makeElement #-} (in lucid)
09:19:22 <cocreature> _sras_: I was asking about the _host_ not the container
09:19:46 <phadej> mpickering: wild guess: to suppress "rule won't fire" warning by GHC
09:20:02 <mpickering> What rule does it participate in?
09:20:14 <phadej> mpickering: I plan to refactor lucid so one don't need INLINE's there (cpise the monad)
09:20:18 <phadej> cspise*
09:20:52 <phadej> if there is good reason to prioritise that refactor, I can do it already tomorrow
09:21:06 <mpickering> I'm suspecting that the performance gain is because makeElement gets specialised after it is marked INLINE
09:21:20 <_sras_> cocreature: Ah. Yes. But what does it mean. 
09:21:28 <phadej> mpickering: I'd rather specialize it manually
09:21:43 <mpickering> by using SPECIALISE pragmas?
09:21:45 <phadej> yes
09:21:51 <_sras_> cocreature: are build plans actually being copied to host from where?
09:22:06 <cocreature> they are supposed to be copied from the container to the host
09:22:28 <phadej> fwiw, cpsising refactor is motivated by the fact, that I have largish html-page generation, and INLINE >>= makes compilation quite slow (I suspect it's cullprit, didn't yet investigate)
09:23:00 <cocreature> _sras_: maybe try inserting a bunch of print statements at https://github.com/commercialhaskell/stack/blob/master/src/Stack/Docker.hs#L758 and see if the copy path is actually being triggered
09:23:16 <phadej> i.e. I'd like to balance between being super fast generating html, and compiling times (though, I'd rather be super fast in both :))
09:23:29 <mpickering> well yes it does about 4x work from what I just measured
09:24:14 <phadej> but INLINE >>= is motivated by benchmark, where there is clear win if INLINE is present
09:24:38 <phadej> https://github.com/chrisdone/lucid/pull/67
09:24:53 <mpickering> ok but it wasn't tested for each of the 7 functions individually which one made the difference
09:24:56 <mpickering> ?
09:25:45 <phadej> mpickering: IIRC I added as little INLINE pragmas as possible to make the difference
09:26:15 <phadej> but makeElemement INLINE was there before my changes
09:26:35 <phadej> maybe it should be INLINEABLE (aren't those specialisable then too?)
09:26:41 <mpickering> yes
09:27:20 <phadej> ok. I'll try to remove INLINE's from lucid, we shouldn't need them
09:27:40 <phadej> mpickering: do you have some good benchmark btw, if I can use that too?
09:28:06 <mpickering> no I am just looking at the compiler output
09:28:12 <mpickering> preparing my talk for thursday :P
09:28:39 <mpickering> Also I see this function being unfolded a large number of times
09:28:39 <mpickering> 1188 Data.Bits.$fBitsInt_$cshiftR
09:28:46 <mpickering> Any idea where that comes from?
09:28:57 <phadej> in lucid?
09:29:06 <phadej> I guess it leaks from bytestring builder
09:29:10 <mpickering> yes, perhaps it is from makeElement?
09:29:45 <mpickering> ah yes, 1183 = 33*36 and 33 is the number of times that makeElement is unfolded
09:30:22 <phadej> ok, I'll try to do the changes so you could update your talk tomorrow ;)
09:30:36 <mpickering> so inlining an unoptimised makeElement creates quite a large cascade of other optimisations 
09:31:55 <phadej> argh, lucid uses blaze builder
09:31:59 <phadej> not bytestring
09:34:06 <mpickering> is that bad?
09:34:12 <phadej> mpickering: does the makeElement count grows if you make bigger HTML
09:35:00 <phadej> e.g. if you use `span_ "foo" <> span_ "bar"` I'd like to see only single `makeElement`
09:35:18 <phadej> inlined into definition of `span_`, and then optimised as a whole
09:38:06 <Psybur> Anybody know if theres a good DBSCAN module out there?
09:39:21 <mpickering> ok lol, I opened the benchmark file for the first time and worked out how to modify it a bit, let's see
09:42:18 <mpickering> ok I added a single extra "div" and it went up by 4
09:42:50 <mpickering> total ticks went up by 6000 from 64000 to 7000
09:43:07 <phadej> a lot of ticks :/
09:55:45 <ezrios> @pl (\x y -> y `f` g x)
09:55:45 <lambdabot> flip f . g
10:12:29 * hackagebot directory 1.3.1.5 – Platform-agnostic library for filesystem operations – https://hackage.haskell.org/package/directory
10:31:46 * hackagebot colorless 2.2.12 – Colorless – https://hackage.haskell.org/package/colorless
10:37:23 <siwica> Are there any recommendations on how to order individual funtions in a haskell file? (specific -> general/alphabetic/...)
10:37:33 <siwica> +functions
10:38:01 <shapr> siwica: I like to see the 'big picture' first
10:38:04 <shapr> and then the support functions later
10:38:17 <mnoonan> ^ that
10:38:33 <shapr> I like to put exported functions as early as possible, and all the supporting code later.
10:38:58 <shapr> that way if the docs aren't enough, the reader can immediately jump into "how to use this"
10:39:13 <shapr> and "how it works" is later in the file
10:39:36 <mpickering> phadej: So it seems the INLINE on "term" "termWith" and "makeElement" are the crucial ones
10:39:47 <mpickering> the ones on the bind don't make a difference as far as I can see
10:40:47 * hackagebot concurrent-st 0.1 – Concurrent Haskell in ST – https://hackage.haskell.org/package/concurrent-st
10:40:51 <shapr> siwica: what do you think about how to order functions in a file?
10:41:01 <mpickering> phadej: But only saves 2000 ticks removing the others :P
10:53:18 <Ero2> has anyone got a style guide/methodology for how heavily to use types in a project?
10:54:00 <Ero2> I have a basic working knowledge of haskell and am comfortable with all the basics but I'm struggling now with creating projects that i care about
10:54:59 <blackdog> Ero2: it depends a lot on who you're working with. if you're all type theory astronauts, go nuts - throw type families around, get into generics, write template haskell, whatever.
10:55:00 <Ero2> Since my earlier exploration of using types for formal verification is the extreme which Haskell (I) should not go, where lies the middle ground?
10:55:32 <Ero2> blackdog: I'm just a simple boy with dreams of world domination
10:55:41 <blackdog> but i tend to prefer the dumb stuff. you can go a long way just writing even one-use datatypes, writnig things polymorphically, and newtyping stuff.
10:56:06 <arcetera> if i have an ADT that has a value Number represented as an Integer
10:56:18 <blackdog> i keep trotting out this idea of the novelty budget. every gee-whiz extension needs to pull its weight in terms of safety or concision.
10:56:23 <arcetera> how can I implement +, -, *, div, mod, etc
10:56:24 <Ero2> blackdog, have you got a relatively small but sound project that you would be proud to share with me?
10:56:36 <arcetera> without unpacking the value from the type
10:56:44 <blackdog> oof, i wouldn't use mine as a model really :)
10:57:24 <arcetera> the type implements Ratio, Complex, and Double similarly
10:57:33 <Ero2> i think you have to unpack the type arcetera, isn't that the point of defining your own ADT's?
10:57:37 <arcetera> and I can't make a function that returns 4 different types
10:57:47 <arcetera> Ero2: problem is the 4 different # types
10:58:02 <cocreature> arcetera: I’m not following, how can it be an instance of Double if it’s just a wrapper around an Integer?
10:58:08 <blackdog> https://github.com/meanpath/robots/blob/master/src/Network/HTTP/Robots.hs isn't totally terrible, though i'd probably newtype more of it if i rewrote it today.
10:58:20 <Ero2> thanks blackdog 
10:58:49 <arcetera> http://lpaste.net/359083 like this
10:59:12 <arcetera> it's a wrapper around... a lot of types
10:59:32 <arcetera> and i'm trying to make a universal unpack function that'll unpack Number, Double, Ratio, and Complex
10:59:33 <monochrom> OK so what should be the answer to (Atom x + Vector y)?
10:59:46 <arcetera> monochrom: haven't implemented error checking yet but
10:59:53 <arcetera> the answer should be "what are you doing please stop""
11:00:07 <arcetera> i'm only concerned about Number, Float, Ratio, and Complex
11:00:15 <Ero2> wouldnt GADT's be a solution to this, arcetera ?
11:00:16 <monochrom> OK so what should be the answer to (Number 5 + Complex (6 :+ 7))?
11:00:39 <Ero2> I assume you are implementing a Lisp interpreter and the value type would be closed
11:00:41 <arcetera> monochrom: 11+7i
11:00:51 <arcetera> i think that's how math works
11:00:56 <monochrom> How about (Number 5 + Number 8)?
11:01:06 <arcetera> 13
11:01:09 <arcetera> are you trying to confirm i'm a human
11:01:32 <monochrom> Is that Number 13 or is that Complex (13 :+ 0)?
11:01:42 <arcetera> both
11:01:56 <monochrom> Cannot be both. This is a deterministic function. Pick one.
11:02:07 <arcetera> hm
11:02:27 <monochrom> I am confirming that you haven't thought it through.
11:02:38 <monochrom> So yes you're human.
11:02:51 <cocreature> "(+) :: (MonadRandom m, Num a) => a -> a -> m a" ;)
11:02:58 <monochrom> haha
11:03:58 * hackagebot liquidhaskell 0.8.0.5 – Liquid Types for Haskell – https://hackage.haskell.org/package/liquidhaskell
11:04:15 <arcetera> monochrom: so wait
11:04:18 <arcetera> what about Ratio then?
11:04:31 <monochrom> I thought I were the one asking.
11:04:42 <arcetera> hm
11:04:47 <monochrom> But I don't know. It's your project. You tell me what you want.
11:05:03 <monochrom> Me? I wouldn't even do this project this way.
11:05:26 <fakenullie> lisp has type coercion?
11:05:29 <monochrom> Hell, make it: I wouldn't even do this project, period.
11:05:41 <arcetera> i would
11:05:43 <arcetera> that's why i'm doing it
11:06:22 <arcetera> so scheme type hierarchy is complex > real > rational > integer
11:06:25 <arcetera> per well
11:06:26 <arcetera> math
11:06:54 <arcetera> i get that a real would be a complex with no imaginary element, but how would i distinguish an integer from a non-integer in the first register of the Complex type
11:07:05 <jle`> arcetera: basically implementing these things on these types is a 'bad idea' and you're going to have to make weird compromises
11:07:08 <jle`> no matter what
11:07:22 <arcetera> howso
11:07:42 <arcetera> is there a way i can refactor the way the type is structured such that it's not a total garbage mess
11:07:49 <arcetera> garbage fire**
11:08:18 <monochrom> No. I think if you look at any existing Scheme implementation you will see the same mess.
11:08:40 <monochrom> Including the need to write out all 16 cases of how to do +
11:09:16 <fakenullie> can't you just use complex for every number?
11:09:46 <fakenullie> javascript gets away with similar trick
11:10:02 <arcetera> fakenullie: yeah but then how would i distinguish a floating point from an integer
11:10:09 <arcetera> and a rational from a floating point
11:10:14 <fakenullie> why would you need to?
11:10:24 <arcetera> r5rs
11:10:25 <monochrom> fakenullie: Ah but play with Scheme some time. You can ask it to do 5+6 and then ask "is the answer an integer?" it will say yes. So it has some fine-grained runtime type tracking.
11:10:43 <arcetera> (integer?)
11:11:03 <fakenullie> then it makes sense to implement 16 cases for +
11:11:09 <arcetera> well fuc,j
11:11:13 <arcetera> yeah
11:11:40 <monochrom> And IIRC it goes even beyond that. Because I seem to remember that I did (sqrt(2))^2 and then asked "is the answer an integer?" and it still said yes. At which point it seemed to have Mathematica power. :S
11:11:54 <fakenullie> heh
11:13:11 <arcetera> now my problem is
11:13:31 <arcetera> nevermind
11:13:32 <arcetera> I'm dumb
11:13:38 <arcetera> or I might not be
11:14:04 <arcetera> regardless of whether I implement seperate cases for each type of number, I'm still facing the problem of potentially returning 4 datatypes in 1 function
11:14:33 <monochrom> Well yeah that's Scheme for you.
11:15:00 <monochrom> But in this Haskell representation it is still 1 type. Just 4 different possilbe values.
11:15:38 <monochrom> That's dynamic typing for you. See also what Robert Harper said about "unitype".
11:16:08 <fakenullie> you return LispVal., it's one type
11:18:13 <monochrom> Also you're forgetting lambdas.
11:18:31 <fakenullie> > add (LispInteger a) (LispComplex b) = fromInteger a + b
11:18:34 <lambdabot>  <hint>:1:37: error:
11:18:34 <lambdabot>      parse error on input ‘=’
11:18:34 <lambdabot>      Perhaps you need a 'let' in a 'do' block?
11:18:55 <fakenullie> > LispVal = LispInteger Integer | LispComplex Complex
11:18:58 <lambdabot>  <hint>:1:9: error:
11:18:58 <lambdabot>      parse error on input ‘=’
11:18:58 <lambdabot>      Perhaps you need a 'let' in a 'do' block?
11:19:24 <fakenullie> > data LispVal = LispInteger Integer | LispComplex Complex
11:19:27 <lambdabot>  <hint>:1:1: error: parse error on input ‘data’
11:19:35 <fakenullie> eh
11:19:40 <arcetera> fakenullie: repack my values then?
11:19:52 <arcetera> ic
11:20:00 <fakenullie> what am I doing wrong
11:20:29 <phadej> mpickering: cpsising was pessimisation, so I guess lucid is quite close to optimal atm
11:21:39 <fakenullie> arcetera: it would be add (LispInteger a) (LispComplex b) = LispComplex (fromInteger a + b) 0
11:22:02 <fakenullie> well not quite
11:22:05 <mnoonan> fakenullie: the first one needs a 'let' like the message says, the second one is the wrong syntax for defining a data type, and the third seems fine to me (assuming Complex is defined)
11:23:37 <fakenullie> > import Data.Complex; data LispVal = LispInteger Integer | LispComplex Complex
11:23:41 <lambdabot>  <hint>:1:1: error: parse error on input ‘import’
11:24:16 <fakenullie> > :k Complex
11:24:19 <lambdabot>  <hint>:1:1: error: parse error on input ‘:’
11:24:27 <arcetera> lambdabot pls
11:25:49 <fakenullie> @type Complex
11:25:51 <lambdabot> error: Data constructor not in scope: Complex
11:25:54 <jle`> @let import Data.Complex
11:25:56 <lambdabot>  Defined.
11:25:58 <jle`> :k Complex
11:26:00 <lambdabot> * -> *
11:26:01 <jle`> :t (:+)
11:26:03 <lambdabot> a -> a -> Complex a
11:26:52 <fakenullie> I wonder if scheme complex is polymorphic
11:27:00 <arcetera> i face another issue
11:27:10 <arcetera> +, -, etc have to take a theoretically infinite # of parameters
11:27:47 <fakenullie> like fold?
11:27:49 <Psybur> > 1 :+ 2
11:27:50 <arcetera> so if i dispatch for (Number op1, Complex op2, _) i don't know if they're putting a Ratio somewhere in there
11:27:52 <lambdabot>  1 :+ 2
11:28:10 <arcetera> fakenullie: like fold
11:28:19 <arcetera> fold is what i used before i had to deal with multiple types
11:28:25 <fakenullie> just use this operator with fold
11:28:28 <arcetera> numericBinop op params = Number $ foldl1 op $ map unpackNum params
11:28:53 <[exa]> fakenullie: it's even better: (/ 1+2i 3) => 1/3+2/3i
11:29:18 <arcetera> what kind of neverending hell have i cast myself into
11:29:32 <[exa]> duck typed hell?
11:29:44 <mnoonan> maybe you should write-you-a-statically-typed-language :)
11:29:45 <arcetera> yeah i guess
11:30:40 <arcetera> fugit i'll just do integer for now
11:30:45 <fakenullie> maybe you should implement arithmetic in scheme
11:30:47 <arcetera> work on this later to focus on error checking
11:30:53 <arcetera> fakenullie: maybe i should
11:31:47 <[exa]> arcetera: what's the target purpose of your polymorphic numbers anyway?
11:31:50 <fakenullie> > data LispVal = LispInteger Integer | LispDouble Double
11:31:53 <lambdabot>  <hint>:1:1: error: parse error on input ‘data’
11:32:14 <fakenullie> @let data LispVal = LispInteger Integer | LispDouble Double
11:32:16 <lambdabot>  Defined.
11:32:38 <Ero2> its better to declare newtypes rather than type synonyms, correct?
11:32:51 <fakenullie> @let lispAdd (LispInteger a) (LispDouble b) = LispDouble (a+b)
11:32:52 <lambdabot>  .L.hs:299:54: error:
11:32:52 <lambdabot>      • Couldn't match expected type ‘Double’ with actual type ‘Integer’
11:32:52 <lambdabot>      • In the first argument of ‘LispDouble’, namely ‘(a + b)’
11:33:00 <fakenullie> @let lispAdd (LispInteger a) (LispDouble b) = LispDouble (fromIntegral a+b)
11:33:02 <lambdabot>  Defined.
11:33:20 <fakenullie> > lispAdd (LispInteger 3) (LispDouble 5)
11:33:23 <lambdabot>  error:
11:33:23 <lambdabot>      • No instance for (Show LispVal)
11:33:23 <lambdabot>          arising from a use of ‘show_M210797790700438363511551’
11:34:08 <fakenullie> @let data LispVal = LispInteger Integer | LispDouble Double deriving Show
11:34:09 <lambdabot>  .L.hs:286:1: error:
11:34:10 <lambdabot>      Multiple declarations of ‘LispVal’
11:34:10 <lambdabot>      Declared at: .L.hs:283:1
11:35:02 <[exa]> fakenullie: you can't beat scheme when it does this: (inexact->exact 0.1) => 3602879701896397/36028797018963968
11:35:19 <fakenullie> wtf
11:35:27 <arcetera> yeah what the fuc
11:36:01 <[exa]> :]
11:36:39 <[exa]> 36028797018963968 is 2^55
11:37:03 <[exa]> because double precision
11:37:27 <[exa]> Ero2: not always; it's a bit different
11:37:58 <[exa]> Ero2: if you declare the type synonym, you can e.g. still patternmatch it using the "internal" type, and generally use it interchangeably with it
11:38:12 <[exa]> not the case with newtype, which in fact "means" something
11:38:47 <[exa]> String is a case for newtype because you usually want to match it using list constructor, as in 'a':"restofstring"
11:39:07 <[exa]> SafeCheckedString is a case for newtype, since you don't want the "mark" to go away easily
11:40:34 <fakenullie> > foldr lispAdd (LispInteger 0) [LispDouble 3.4, LispInteger 3, LispDouble 6.5]
11:40:37 <lambdabot>  LispDouble 12.9
11:41:51 <fakenullie> > foldr1 lispAdd [LispDouble 3.4, LispInteger 3, LispDouble 6.5]
11:41:55 <lambdabot>  LispDouble 12.9
11:42:18 <fakenullie> > foldr1 lispAdd [LispInteger 3, LispInteger 3, LispInteger 6]
11:42:21 <lambdabot>  *Exception: /tmp/mueval11908-0.hs:(164,1)-(168,35): Non-exhaustive patterns ...
11:42:59 <fakenullie> > foldr1 lispAdd [LispInteger 3, LispInteger 3, LispInteger 6]
11:43:01 <lambdabot>  LispInteger 12
11:43:07 <fakenullie> arcetera: ^
11:43:30 <arcetera> i uh
11:43:31 <arcetera> i see
11:43:45 <arcetera> thanks
11:44:49 * hackagebot colorless 2.2.13 – Colorless – https://hackage.haskell.org/package/colorless
12:09:07 * hackagebot Plot-ho-matic 0.12.1.0 – Real-time line plotter for generic data – https://hackage.haskell.org/package/Plot-ho-matic
12:12:03 <k____> @pl primitiveTriples n =         [ (a,b,c)         | a <- [1..n]         , b <- [a+1..n]         , gcd a b == 1         , c <- [b+1..n]         , 
12:12:03 <lambdabot> (line 1, column 21):
12:12:03 <lambdabot> unexpected " "
12:12:03 <lambdabot> expecting operator
12:14:04 <k____> @pl primitiveTriples n =        [ (a,b,c)        | a <- [1..n]        , b <- [a+1..n]        , gcd a b == 1        , c <- [b+1..n]        , a^2 + b^2 == c^2        ]
12:14:04 <lambdabot> primitiveTriples = ap ((:) . (((a, b, c) | a) <-) . enumFromTo 1) (ap ((:) . (b <-) . enumFromTo (a + 1)) (((gcd a b == 1) :) . (: [a ^ 2 + b ^ 2 == c ^ 2]) . (c <-) . enumFromTo (b + 1)))
12:14:43 <byorgey> pl doesn't know how to deal with list comprehensions apparently
12:14:44 <mniip> I don't think lambdabot understood that exactly
12:16:42 <mniip> @let primitiveTriples n = [1..n] >>= (\a -> mfilter (\b -> gcd a b == 1) [a + 1 .. n] >>= (\b -> mfilter (\c -> a^2 + b^2 == c^2) [b + 1 .. n] >>= (\c -> (a, b, c))))
12:16:44 <lambdabot>  .L.hs:176:25: error:
12:16:44 <lambdabot>      • Couldn't match type ‘(,,) b b’ with ‘[]’
12:16:44 <lambdabot>        Expected type: [b]
12:16:54 <mniip> @let primitiveTriples n = [1..n] >>= (\a -> mfilter (\b -> gcd a b == 1) [a + 1 .. n] >>= (\b -> mfilter (\c -> a^2 + b^2 == c^2) [b + 1 .. n] >>= (\c -> return (a, b, c))))
12:16:56 <lambdabot>  Defined.
12:17:08 <mniip> > primitiveTriples 10
12:17:11 <lambdabot>  [(3,4,5)]
12:17:15 <mniip> @pl primitiveTriples n = [1..n] >>= (\a -> mfilter (\b -> gcd a b == 1) [a + 1 .. n] >>= (\b -> mfilter (\c -> a^2 + b^2 == c^2) [b + 1 .. n] >>= (\c -> return (a, b, c))))
12:17:19 <lambdabot> primitiveTriples = ap ((>>=) . enumFromTo 1) (ap (ap . ((>>=) .) . ap (mfilter . flip flip 1 . ((==) .) . gcd) . flip (enumFromTo . (1 +))) ((`ap` (((return .) .) . (,,))) . (liftM2 (>>=) .) . flip (
12:17:19 <lambdabot> ap . (mfilter .) . flip flip (^ 2) . (((.) . (==)) .) . (. (^ 2)) . (+) . (^ 2)) . flip (enumFromTo . (1 +))))
12:17:26 <mniip> now that's more like it
12:19:54 <miguelv> Hi,  I'm a beginner so I'm probably missing something: in parsec is there a function to filter the matched string against some predicate? I want to do this to filter out some reserved words
12:22:09 <lyxia> Control.Monad.guard
12:22:34 <lyxia> Text.Parsec.notFollowedBy
12:22:59 <lyxia> or use the fact that backtracking only happens if the first try doesn't consume anything.
12:52:30 <Psybur> Crono says that if the ircops sacrifice 4 chatters in a blood ritual the hero of dankness will appear. I nominate Death, Endless, FifthDream and Scribe.
12:52:59 <Psybur> Sorry, freak amsg accident
12:56:30 <zyxoas> Buds and Budettes.
12:57:11 <zyxoas> Is it possible for me to lift unsafeInterleaveIO?
12:57:47 <zyxoas> That is unsafeLiftedInterleaveIO :: forall m a . MonadIO m => m a -> m a
12:58:29 <zyxoas> OF course, I can put the result in MonadIO by using liftIO, but I can't remember if there is a way to lift the parameter?
13:01:22 <kuribas> exit
13:02:55 <boogalooga> Any better way to write this function
13:02:56 <boogalooga> https://imgur.com/a/gp1ck
13:03:10 <boogalooga> It's an insert operation on a BST of LogMessages
13:03:34 <Hafydd> boogalooga: that's an interesting way of sharing text.
13:03:40 <boogalooga> haha
13:03:57 <boogalooga> http://www.cis.upenn.edu/~cis194/spring13/hw/02-ADTs.pdf
13:04:01 <boogalooga> it's problem 2 here
13:04:12 <Hafydd> ...also, an interesting font to use for programming.
13:04:30 <boogalooga> wait is that not monospace
13:04:30 <boogalooga> ?
13:04:35 <boogalooga> I had a feeling
13:04:37 <Hafydd> It doesn't look like it.
13:04:49 <boogalooga> because my stuff wasn't lining up, but I was too lazy to change it back
13:04:56 <boogalooga> haha
13:05:37 <boogalooga> Any better way to write that insert operation
13:05:38 <boogalooga> ?
13:05:53 <boogalooga> Also, isn't it really slow to rebuild the entire tree like that
13:05:53 <boogalooga> ?
13:08:55 <Hafydd> boogalooga: your function doesn't handle the case where the inserted message has the same timestamp as an existing one in the tree, but I don't know whether you intend to handle that.
13:10:07 <Hafydd> boogalooga: but otherwise, I think that's a standard way to write that. It isn't as inefficient as you may think, because returning "left" and "right" in the result doesn't cause those entire subtrees to be re-evaluated, so it isn't the whole tree being rebuilt.
13:10:17 <Hafydd> Given the constraints of the exercise, there isn't really a faster way to do it.
13:12:28 * hackagebot brick 0.28 – A declarative terminal user interface library – https://hackage.haskell.org/package/brick
13:13:29 <Hafydd> You might be able to improve performance by forcing strict evaluation, but I think that's also beyond the scope of the exercise.
13:16:01 <boogalooga> I see
13:16:10 <boogalooga> I was mostly worried about style
13:16:20 <boogalooga> is that how a haskell programmer would write it?
13:18:15 <jle`> it seems fine to me
13:18:22 <jle`> aside from the non monospace font
13:18:58 <jle`> also this is decently good, space-wise
13:19:02 <jle`> because of sharing
13:19:28 <jle`> you only need to rebuild the tree directly along the spline towards the new leaf, the rest of the tree can remain in memory and be re-used
13:19:37 <jle`> the power of persistent/immutable data types ~
13:20:05 <jle`> s/rebuild the tree/rebuild the nodes
13:20:52 <boogalooga> oh I see
13:21:00 <boogalooga> so it doesn't rebuild the entire tree
13:21:56 <statusfailed> with recursion-schemes, how do I write a 'catch-all' case in my algebra for use with "cata"?
13:22:00 <statusfailed> I'm reading this: https://medium.com/@jaredtobin/practical-recursion-schemes-c10648ec1c29
13:22:23 <statusfailed> but the functions like "natsum" match every case, which seems not ideal
13:23:23 * hackagebot postgres-embedded 0.1.1 – <i>Added by ilya_murzinov, Mon Oct 9 20:14:08 UTC 2017.</i> – https://hackage.haskell.org/package/postgres-embedded
13:24:29 <lyxia> statusfailed: cata _ = ... ?
13:25:46 <statusfailed> lyxia: sorry, didn't follow?
13:27:05 <mnoonan> statusfailed, here is an example https://github.com/matt-noonan/functor-friends/blob/master/src/Data/Functor/Tutorial.hs#L113
13:27:36 <mnoonan> ("foldMemo" is pretty much like "cata", except it caches all of the intermediate results as node annotations)
13:29:45 <statusfailed> mnoonan: perfect, thanks!
13:29:48 <statusfailed> Also I feel a bit dumb :D
13:30:18 <mnoonan> eh, my usual workflow with recursion schemes is "dumb mess -> dumber mess -> catastrophic simplification -> something very neat and tidy"
13:31:32 <statusfailed> mnoonan: oh no, that puts me at "dumber mess" :D
13:31:43 <statusfailed> or maybe you helped me short-circuit to the end
13:31:45 <statusfailed> i'll stay hopeful
13:32:45 * hackagebot yi-core 0.17.0 – Yi editor core library – https://hackage.haskell.org/package/yi-core
13:38:46 <michalrus> Hey, why is Tagged better than newtype?
13:42:39 <geekosaur> I'm not sure it is any more.
13:43:31 <lyxia> michalrus: who said that
13:43:53 <geekosaur> used to be that newtype had a corner case where it couldn't be simplified out (things like map NewtypeConstructor listOfValues iirc, where the constructor got replaced but the map couldn't be optimized out
13:44:17 <geekosaur> I *think* this is handled better now. but I think using Tagged allowed that to be optimized better?
13:44:18 <michalrus> lyxia: I assumed that, given the effort put into Tagged. :p Sorry.
13:44:31 <michalrus> geekosaur: OK, thank you! :)
13:58:25 * hackagebot yi-dynamic-configuration 0.17.0, yi-frontend-pango 0.17.0, yi-frontend-vty 0.17.0, yi-fuzzy-open 0.17.0, … and 8 more
13:58:25 * hackagebot  → https://hackage.haskell.org/packages/recent
14:00:54 <geekosaur> that said, btw, I think the real point of Tagged is it was a waypoint on the way to Proxy, i.e. a way to carry a phantom type around as or with a value
14:01:08 <geekosaur> which is useful in type level programming
14:02:27 <geekosaur> I vaguely recall people using it as a hack in some (limited, I think) to get around having to unsafeCoerce to avoid the bad optimization I mentioned, but otherwise it's not really related to newtype
14:03:38 <geekosaur> (either that or using it to provide a little type safety around the unsafeCoerce, I can't remember)
14:58:59 <NemesisD> anyone know what the state of the art is for statically linking haskell executables with stack? i recently changed distros to one with slightly diff system deps than production and now my life is hell
15:33:17 <orzo> What are the pros and cons of TVar (Data.Dequeue.BanckersDequeue a) versus TChan a ?
15:34:31 <orzo> I meant Data.Dequeue.BankersDequeue
15:36:00 * hackagebot postgres-embedded 0.1.2 – <i>Added by ilya_murzinov, Mon Oct 9 22:30:31 UTC 2017.</i> – https://hackage.haskell.org/package/postgres-embedded
15:37:26 <lyxia> TChan is more efficient because reading and writing can happen simultaneously
15:39:06 <orzo> is there any plus to use the BankersDequeue?
15:39:16 <orzo> memory maybe?
15:41:28 <orzo> I often put lookup tables in TVars
15:41:44 <orzo> pure lookup table data structures
15:41:54 <orzo> i suppose that has a similar inefficency
15:41:59 <orzo> but i don't typically worry about it
15:43:15 <lyxia> I can't think of a good reason for the dequeue if you want something equivalent to a chan
15:44:14 <robertkennedy> > fail "test" <|> return 5 :: IO Int
15:44:16 <lambdabot>  <IO Int>
15:46:22 <robertkennedy> Would you expect that function to return 5 or fail?
15:47:48 <orzo> fail
15:47:54 <orzo> is what i'd expect
15:48:15 <orzo> is that not what happens?
15:49:01 <orzo> maybe <|> is an exception handling mechanism for IO ?
15:51:28 <orzo> (putStrLn "hello" >> fail "test" >> putStrLn "Alice.") <|> putStrLn "Bob."
15:51:44 <orzo> outpusts "hello\nBob."
15:51:58 <orzo> a little wonky, but okay
16:01:26 <pikajude> so, is <|> 'finally'?
16:01:38 <pikajude> oh no, it's onException
16:03:55 <orzo> seems like onException would be better style
16:04:40 <orzo> why do we have <|> for IO?
16:11:39 * hackagebot log-warper 1.3.1 – Flexible, configurable, monadic and pretty logging – https://hackage.haskell.org/package/log-warper
16:26:27 <lyxia> because we can
16:26:36 <lyxia> I also find it fishy
16:27:03 <fishythefish> did someone say fishy
16:28:40 <lyxia> I don't think so.
16:28:44 <geekosaur> convenience always trumps correctness
16:28:53 <geekosaur> see also: Num
16:55:22 * hackagebot toysolver 0.5.0 – Assorted decision procedures for SAT, SMT, Max-SAT, PB, MIP, etc – https://hackage.haskell.org/package/toysolver
17:18:26 <Ero2> can smart constructors be an adequate replacement for dependant types?
17:18:35 <hdqn> I get warnings from pacman after upgrading ghc: https://ptpb.pw/YmXE # should I be worried?
17:19:18 <hpc> Ero2: they can often accomplish the same abstraction at runtime, but you don't gain anything at compile-time
17:19:32 <hpc> so not really
17:19:45 <Ero2> i got those errors too, hdqn, i assumed it haad to do with generating documentation and wouldnt effect usage of ghc
17:20:19 <hdqn> Ero2: oooh, right. it's just the docs. makes sense, thanks :D
17:21:42 <Ero2> so i could still use smart constructors for giving my algorithms usable assumptions at runtime, but not for program correctness. gotcha thx hpc 
17:22:39 <Ero2> hdqn: have you tried using stack to manage installing ghc, rather than pacman?
17:22:59 <hdqn> Ero2: nope. what's stack and why would I use that?
17:23:37 <hdqn> tbh I haven't played much with Haskell yet, installing ghc was a thing of the moment "for later"
17:25:18 <hpc> Ero2: something your question reminded me of, is that abstractions are ultimately ways to structure code that emulate static guarantees when followed correctly
17:25:50 <Welkin> stack makes it easy to set up your project, install dependencies, and build your project
17:26:02 <Welkin> with reproducible builds
17:26:27 <Welkin> it is part of the commercial haskell toolset (using haskell in production)
17:26:31 <Ero2> hdqn: if developing long term with haskell becomes your thing, using and learning stack would be a good move
17:26:54 <hdqn> Ero2: thanks for the advice, I'll keep that in mind.
17:26:59 <hpc> and if you stretch that idea to its logical conclusion, you can even use it to describe naming conventions like apps hungarian - https://www.joelonsoftware.com/2005/05/11/making-wrong-code-look-wrong/
17:27:51 <Ero2> hpc, how did my question remind you of this?
17:28:00 <hpc> my brain wanders :P
17:28:09 <Ero2> :D i love your brain
17:30:09 <hpc> actually, if you imagine class-based OOP as a way to draw a circle around a bundle of data and say "this has X guarantees because of Y methods", it starts to make a bit more sense how that idea got started
17:30:25 <Ero2> dependant types would be great for deriving truths about complex spaces in a clean manner
17:31:48 <exio4> 46
17:31:53 <Welkin> hpc: what is this essay actually about?
17:32:20 <exio4> welp, that wasn't meant to be sent
17:32:23 <Ero2> thats interesting hpc , i used to visualise OOP in such a way
17:32:59 <Ero2> visualising pure functions is way prettier though
17:33:12 <Ero2> monads look like fractals :D
17:33:36 <Welkin> oop just need an extra s. "oops" is what it should be called
17:34:12 <Ero2> yea oop doesnt make much sense
17:34:37 <Ero2> reading gang of 4 and learning what 'reify meant changed my world
17:35:42 <Ero2> types are all about reification
17:53:27 <johnw> Ero2: how is that?
17:54:27 * hackagebot colorless 2.2.14, orgstat 0.1.0, colorless-http-client 0.0.4
17:54:27 * hackagebot  → https://hackage.haskell.org/packages/recent
17:57:48 <Ero2> is it fair to say that type families replaces the need to use multi-parameter type classes and functional dependencies?
17:58:49 <Ero2> johnw: it made sense to me a while back and now i repeat it tomyself in hopes it comes back to me
18:02:37 <dmwit> Ero2: Most of the time. As far as I know there's no proof that either one can do everything the other can, but it sure seems intuitively so.
18:03:17 <dmwit> Often inference works better in the presence of type families, but it's not clear whether that's a fundamental difference or what.
18:04:37 <begriffs> The jose library provides a function producing type "Prism' Text StringOrURI". Can any lens pro tell me the best way to get the StringOrURI out?
18:12:08 <geekosaur> uh, there isn't one
18:12:51 <geekosaur> Prism' is a function, more or less
18:14:59 <geekosaur> the function 'head' doesn;t have a list inside it, you have to apply it to a list. likewise a Prism' Text StringOrURI is a traversal to be applied to a Text that gives you StringOrURI from it
18:15:59 * hackagebot colorless 2.2.15 – Colorless | The Programmatic IDL – https://hackage.haskell.org/package/colorless
18:19:35 <rotaerk> what's an "IDL"
18:20:08 <Welkin> interactive delicious lion
18:20:26 <dmwit> The standard meaning is "interface description language".
18:20:47 <rotaerk> ah
18:22:34 * geekosaur has clearly been doing too much security of late; first guess was intrusion detection layer >.>
18:23:02 * Welkin has been playing with and eating too many lions
18:23:49 <DigitalKiwi> https://www.youtube.com/watch?v=6g5ZF6DUrHI
18:23:58 <DigitalKiwi> I don't like, obviously
18:24:22 <Welkin> DigitalKiwi: are you a fruit or a bird?
18:24:46 <DigitalKiwi>   phrik:	Digitized, chirping, fruit with citizenship, ftw! lolque? http://i.imgur.com/AT40oPm.jpg
18:25:12 <DigitalKiwi> heh, "are you a good witch or a bad witch?"
18:25:25 <DigitalKiwi> btw that song sucks so you probably don't want to listen to it, you've been warned
18:25:48 <Welkin> DigitalKiwi: da fuck?
18:26:10 <Welkin> I clicked your link...
18:26:29 <DigitalKiwi> I used to DJ, I've lost many brain cells
18:27:33 <DigitalKiwi> CAN YOU PLAY WOBBLE FOR THE THIRD TIME TONIGHT??? HOW ABOUT FUTURE??? PLAY DRAKE
18:27:39 <DigitalKiwi> ...
18:28:11 <DigitalKiwi> Welkin I'm sorry for your loss
18:28:33 <DigitalKiwi> look at the imgur it's good
18:29:17 <dcxaq> test
18:29:20 <dcxaq> TEST
18:29:22 <dcxaq> T3ST
18:29:29 <dcxaq> 0/0
18:29:40 <geekosaur> o.O
18:29:43 <DigitalKiwi> Error: test did not pass
18:29:59 <dcxaq> if you see test means it passed
18:31:15 <DigitalKiwi> no I don't think that's how it works
18:31:29 <Welkin> > test
18:31:33 <lambdabot>  error:
18:31:33 <lambdabot>      • Variable not in scope: test
18:31:33 <lambdabot>      • Perhaps you meant one of these:
18:31:45 <Welkin> @info test
18:31:46 <lambdabot> test
18:31:47 <Welkin> :D
18:32:46 <dcxaq> @info test
18:32:47 <lambdabot> test
18:32:48 <dcxaq> :D
18:32:53 <dcxaq> you THINK YOU SMART
18:33:08 <DigitalKiwi> I know I am!
18:33:15 <Welkin> sam I am
18:33:33 <dcxaq> sam I am
18:34:28 <DigitalKiwi> you can't both be sam
18:35:32 <dcxaq> DigitalKiwi: tell it to god
18:36:02 <DigitalKiwi> in dog we trust
18:36:19 <dcxaq> god*
18:36:50 <DigitalKiwi> my brother is dyslexic too
18:36:59 <dcxaq> and?
18:37:05 <DigitalKiwi> I won't judge you
18:37:31 <dcxaq> oooo
18:37:33 <Welkin> have you ever noticed how lazy the name "god" is?
18:37:43 <Welkin> did someone just look at the word "good" and remove an "o"?
18:37:56 <dcxaq> Welkin: this is #haskell
18:38:35 <DigitalKiwi> omg so my dad wrote a joke on an envelope and left it for me, it said "I have sex daily" crossed off and then "I have dyslexia"
18:39:00 <DigitalKiwi> Welkin so it was supposed to be good is good?
18:39:14 <DigitalKiwi> and due to a transcription error we got religion, awesome
18:40:46 <dcxaq> or god is just translation.. think about it ;)
18:43:26 <DigitalKiwi> maybe it was never supposed to be God, it was just that they were talking about all of them just like in general but always at the beginning of the sentence
18:44:10 <DigitalKiwi> this is entirely too far offtopic and someone's going to get upset so uh...I'll stop >.>
18:57:08 <johnw> thanks, you saved me from having to get upset :)
19:17:18 <daig> Hello all! I have a question about Lens: I notice in the Review type, p only has a Bifunctor constraint, but every function creating a Review also has a Profunctor constraint. It seems natural that we should include Profunctor too, so we constrain p to be isomorphic to Tagged. What power do we gain from only using a Bifunctor constraint?
19:19:19 <lyxia> daig: I'm not sure what you mean. Review includes a Profunctor constraint via Choice
19:27:58 <daig> Thanks lyxia, I had a brain slip -_-'
19:42:08 <iqubic> Is glguy around? I have a few questions for glguy.
19:49:03 <iqubic> glguy: have you pushed this commit to hackage? https://github.com/glguy/irc-core/commit/f8a3c86f2ee9198002b05dd0c7962db813e7b2a5
19:49:09 <cris__> hi all, recently I when I type the following command "nix-env -iA nixpkgs.myHaskellEnv" to update my nix Haskell environment ; i could use packages outside standard library, my config.nix is like this: https://hastebin.com/eqizufinuq.m    
19:49:54 <cris__> does anyone has a solution ? thanks
19:50:41 <cris__> I could NOT use libraries outside standard GHC library
19:51:14 <iqubic> Not even the functions defined in those separate hackage libs?
19:51:55 <cris__> > iqubic , that's right, not ever the functions in the separate hackage libs
19:51:58 <lambdabot>  <hint>:1:8: error: parse error on input ‘,’
19:52:17 <geekosaur> last time I updated my nix setup it was still 8.0.2
19:52:43 <geekosaur> which makes me wonder if 8.2.1 is in there but not much else has been updated to use it yet, or something
19:55:57 <_sras_> Is there any way to make a Haskell container with all the haskell packages bundled, so that the first time the container is used for a build (using stack build --docker), the it starts the build right away without having to download and build the dependencies?
19:57:22 <iqubic> geekosaur: What irc client do you use?
19:57:49 <geekosaur> hexchat
20:09:57 <luggager> so the first version of the function 'word' (I got from a pdf) in the end works but the second oddly doesn't https://hastebin.com/ogozebeken.hs
20:11:12 <geekosaur> a Parser String is not a String, nor even a list
20:12:32 * hackagebot colorless 2.2.16 – Colorless | The Programmatic IDL – https://hackage.haskell.org/package/colorless
20:12:48 <iqubic> A Parser String is a weird thing to have.
20:13:08 <iqubic> Why do you need a parser for a string? Just use the original string.
20:13:23 <geekosaur> er, this is a parser combinator
20:13:38 <geekosaur> word :: Parser String -- parse a word out of a token stream
20:14:57 <geekosaur> which should be a hint: anything of type (Parser x) is a function that, when applied via the parser top level function (runParser or whatever; missing from the source here), will produce a value of type x
20:15:17 <geekosaur> this is explicit in the definition of Parser: newtype Parser a = Parser { parse :: String->[(a,String)] }
20:15:28 <geekosaur> it's a newtype over a function
20:15:49 <geekosaur> oh, and right, there's the run function, called parse >.>
20:16:19 <geekosaur> so a Parser A is given a String representing the input and produces a tuple of the parsed value and the rest of the String
20:17:38 <geekosaur> and the Monad, etc. instances are arranged so that sequencing Parsers together invokes each on the remaining input from the previous, while giving you the parsed value from the previous Parser
20:34:33 <dmwit> iqubic: I feel confident that you, yourself, can check whether that commit has been pushed to Hackage, without any intervention from anybody else. All of the packages on Hackage include all their code.
20:39:59 <iqubic> dmwit: I did not know what.
20:40:05 <iqubic> TIL
20:40:30 <luggager> hm, seems the author who defined 'word' was using "monad comprehensions" that were removed.
20:41:17 <iqubic> dmwit: Where do I go to look for the code for a specific package?
20:46:56 <aweinstock> does (GHC.Prim.addrToAny# :: Addr# -> (# a #)) have an inverse? (i.e. is there a way to get the address of an arbitrary haskell value)
20:46:56 <dmwit> You can `cabal unpack package` if you don't care what version, or `cabal unpack package-version` to get a specific version.
20:47:24 <dmwit> Or you can visit the package's Hackage page and click the tarball in the "Downloads" section.
20:48:18 <dmwit> Honestly, "you can get the code from Hackage" should have been enough of a clue for you. I shouldn't have to tell you that downloading the code involves looking at the "Downloads" section on Hackage. There's, like, a minimum of effort you should be putting in to answering your own questions before asking them on here.
20:51:08 <asturtz> Hey guys, is it possible to use a where clause after a do block? I can't seem to find anything online about it. It seems like I ought to be able to, but I get a parse error whenever I try. Where should bind expressions over the entire function, no?
20:51:17 <dmwit> aweinstock: I don't know the answer. Probably yes. But would a StableName do for your purposes?
20:51:32 <dmwit> asturtz: No, `where` blocks are attached to binding sites.
20:52:05 <asturtz> dmwit: Not quite familiar with that terminology. What qualifies as a binding site in Haskell?
20:52:05 <dmwit> asturtz: So you can put one after a `do` block exactly when the `do` block is part of a binding (e.g. `case` statement or value definition).
20:52:17 <aweinstock> dmwit: this isn't for anything practical, just messing with ghc's innards
20:52:37 * dmwit nods agreeably at aweinstock
20:52:57 <asturtz> Oh wait I think I get it
20:53:02 <dmwit> asturtz: But maybe it's best to just show us the code you tried. =)
20:53:03 <dmwit> ?paste
20:53:03 <lambdabot> Haskell pastebin: http://lpaste.net/
20:53:19 <aweinstock> dmwit: I think (\x -> GHC.Word.W# (GHC.Prim.unsafeCoerce# x)) does what I want for boxed types (assuming the first word of anything of kind * is a pointer)
20:53:36 <aweinstock> and unboxed types aren't guaranteed an address
20:53:58 <dmwit> mmm
20:54:02 <dmwit> I'd be super nervous about using that.
20:54:06 <dmwit> What does it do to thunks?
20:54:06 <luggager> can I add a tag to :load in the console? :P
20:54:15 <dmwit> luggager: "tag"?
20:54:21 <dmwit> You can :load filename.hs.
20:55:02 <aweinstock> dmwit: just tried (\x -> GHC.Word.W# (GHC.Prim.unsafeCoerce# x)) (+5) locally, got a segfault
20:55:02 <luggager> but what about... :load -Wtabs filename.hs
20:55:30 <aweinstock> it worked for a top-level function binding (defined with let in ghci)
20:56:38 <dmwit> luggager: :set -Wtabs
20:56:41 <asturtz> Yeah I think it makes sense now. If I have something like foo = do action where action = print "bar" , it doesn't work because there is binding point to use for the where clause. A do block in this case is a placeholder for a direct value instead of an expression.
20:59:02 <dmwit> % let foo = do action where action = print "bar" in foo
20:59:04 <yahb> dmwit: "bar"
20:59:13 <dmwit> asturtz: I think you haven't understood yet.
21:00:07 <dmwit> % let foo = do (action where action = print "bar") in foo -- this doesn't work, though, because where's have to attach to binding sites and there's none inside the parentheses
21:00:07 <yahb> dmwit: ; <interactive>:2:22: error: parse error on input `where'
21:01:14 <aweinstock> dmwit: It works differently (i.e. fails) if addressOf is a top-level binding: http://lpaste.net/359095
21:02:39 <asturtz> Sorry I meant "no binding site". I have read it suggested that one avoids mixing lets and wheres, is there any reason for that?
21:02:59 <asturtz> one should avoid*
21:03:15 <geekosaur> that's mostly just to avoid confusion
21:03:29 <geekosaur> he compiler handles it fine; *humans* get confused over what has what scope
21:03:41 <luggager> oddly it still gives the warning after I :set it
21:03:59 <aweinstock> dmwit: also, (W# (unsafeCoerce# (+)) gives me a number, but (W# (unsafeCoerce# (+1)) gives me "Illegal instruction"; what insight did you have that lead to guessing it wouldn't work on thunks?
21:04:11 <geekosaur> luggager, if you wanted to turn the warning off, I think you wanted -w instead of -W?
21:04:19 <geekosaur> or-Wno-tabs
21:04:54 <asturtz> Hmm ok. I tend to just use wheres as I find it reads nicer, but in the case of do block this a bit of an issue I suppose
21:05:00 <dmwit> -fno-warn-tabs
21:05:08 <geekosaur> aweinstock, if it's a thunk, it's a function pointer. there's no value until something has forced the thunk
21:05:21 <dmwit> asturtz: Can I again suggest that you show us what code you tried that didn't work?
21:05:24 <dmwit> ?paste
21:05:24 <lambdabot> Haskell pastebin: http://lpaste.net/
21:05:53 <asturtz> dmwit: Yeah I can, though I am pretty unfamiliar with the mechanisms here used to do so
21:06:00 <dmwit> "do block" or "no do block" is orthogonal to "where is allowed" or "where isn't allowed"
21:06:21 <dmwit> asturtz: Just paste your code into the box at lpaste.net, hit submit, then copy and paste the URL into IRC.
21:06:48 <dmwit> Bonus points for making your code as small as possible while still exhibiting the error.
21:06:57 <dmwit> Double bonus points for including the text of the error in a comment at the end of the paste.
21:07:35 <aweinstock> geekosaur: right, but the thunk is still a thing-in-memory
21:07:38 <luggager> alright, thanks
21:07:39 <dmwit> aweinstock: `(+1)` isn't a thunk...
21:08:00 <mnoonan_> if I’m writing a module that exports a bunch of template haskell stuff (think “makeLenses”), and my module name doesn’t end in “.TH”, am I going to get run out of town?
21:08:27 <aweinstock> my current mental model of (W# (unsafeCoerce# foo)) is that, due to (W# :: Word# -> Word), unsafeCoerce#'s return type will unify with Word#, leading to the expression trying to treat foo's memory as a Word#
21:08:28 <geekosaur> it's also a tagged pointer, I believe, which means if you use unsafeCoerce on it you try to execute at an address that still has tag bits and will likely get a bad offset and illegal instructuon unless very lucky
21:08:35 <dmwit> aweinstock: But, to answer your question as asked: I vaguely believe that thunks are implemented as a code pointer + an environment table, and that these get overwritten when the thunk is evaluated. That seemed complicated enough to warrant worrying about.
21:08:37 <geekosaur> normal evaluation would zero the tag bits
21:09:28 <asturtz> dmwit: So uh.. my code is actually fine. It was something completely unrelated that I overlooked
21:09:46 <dmwit> great =)
21:09:53 <geekosaur> (to be clear, ghc generated code is always 16 byte aligned on x86/x86_64, because of some peculiarities in how that arch works. so there's 4 bits at the end of every code pointer that are always 0. so ghc uses those 4 bits to store additional information, and strips them off before actually evaluating)'
21:09:54 <aweinstock> (i.e., I expect (W# (unsafeCoerce# foo)) to be kind-of-like (*(size_t*)foo))
21:11:01 <aweinstock> I know about the tagged-pointers trick, but I'm not sure why that'd be a problem for data reads? (x86_64 allows unaligned fetches)
21:11:54 <dmwit> aweinstock: It might be interesting to compile one of these programs and inspect the actual x86_64 instructions. =)
21:12:07 <dmwit> I would bet you'll get a lot of surprises.
21:13:03 <dmwit> (I'm almost always surprised when I look at what GHC does to my code, and I rarely delve nearly as deep as the actual CPU instructions.)
21:13:47 <dmwit> And by the way there's also a #ghc where you might find folks more expert in the innards of how this stuff works.
21:14:43 <geekosaur> it allows them but they're slower. also if things are aligned, other things can also be faster (notably garbage collection)
21:15:28 <aweinstock> I'll try looking at GHC assembly dumps soon, and I'll also check out #ghc; thanks for the discussion
21:15:49 <geekosaur> alignment is also why that 16-byte alignment I mentioned on function / thunk pointers; quite a lot of the x86/x86_64 innards still assume the old 'paragraph' thing from 8086/8088 and 16 byte aligned code pointers are still noticeably faster as a result
21:17:08 <geekosaur> intel arch has a *lot* of weird historical cruft
21:18:56 <aweinstock> dmwit: some stuff that didn't work in ghci works when compiled (e.g. addressOf as a top-level binding, map addressOf [1..20])
21:19:41 <dmwit> Yes, ghci and ghc have very different evaluation characteristics. ghci uses a bytecode that just doesn't exist in ghc-compiled code.
21:19:58 <geekosaur> also ghci pretty much doesn't do unboxed
21:20:13 <_sras_> Is it possible to use .cabal and stack.yaml from a stack project to install dependencies for  an app globally in a system?
21:20:21 <geekosaur> (and there's  t least one case where it loses track of whether a tuple is boxed or unboxed, leading to core dumps)
21:20:34 <geekosaur> (if you tweak its build to support unboxed)
21:20:41 <dmwit> There's a handful of other gotchas that make ghci different from ghc, all basically related to that fact, and one is that... as geekosaur has now said much more quickly than me... ghci and unboxed mix badly.
21:21:38 <dmwit> _sras_: You can grab the relevant cabal-freeze-file for the resolver mentioned in the stack.yaml, then `cabal install --only-dependencies --global`.
21:22:06 <dmwit> _sras_: (or no --global depending on how global you want global to be)
21:22:43 <dmwit> _sras_: I don't really recommend this (the --global install), though, except in very special circumstances.
21:22:48 <aweinstock> looking at the binary in r2 now, it looks like the relevant control flow is (entry0 -> __libc_start_main -> main -> hs_main -> real_main -> rts_evalLazyIO(progmain_closure))
21:23:09 <asturtz> Hey those of you who use vim, may I ask what plugins, if any, you use for writing Haskell?
21:25:14 <aweinstock> s/progmain_closure/ZCMain_main_closure/
21:25:42 <dmwit> ctrlp, vim-surround, tabular, vim-fugitive, vim-exchange, vim-gitgutter, vim-indent-object
21:25:48 <dmwit> ...basically nothing to do with Haskell. =P
21:25:59 <dmwit> Plus some macros I wrote myself.
21:26:09 <dmwit> Oh, how did I miss vim-commentary.
21:26:43 <dmwit> I have a handful of others, but they are not only unrelated to Haskell, I also don't really think I use them much when doing Haskell hacking.
21:27:49 <iqubic> vim-commentary is the greatest.
21:27:52 <asturtz> dmwit: I use much of the same plugins. So you don't use anything like ghc-mod or amything else for specific Haskell features in vim? I tend to avoid plugins as much as I can, but I wanted to get a feel for what other Haskellers do
21:28:20 <iqubic> I'm using the evil port of vim-commentary in emacs.
21:28:33 <iqubic> I like emacs a lot, but I also want vim bindings.
21:28:35 <dmwit> Everything I've tried has either been buggy or slow.
21:29:53 <dmwit> asturtz: http://lpaste.net/359096
21:30:15 <Hijiri> I chose to use linear for my assignment so I can take a break while lens compiles
21:30:28 <saurabhnanda> does anyone know of a good HTML library in Haskell to do HTML transformations?
21:32:21 <pierrot> Hi. If I have x::Int and y::Int, how can I get ceiling (x/y) and floor (x/y) ?
21:33:11 <asturtz> dmwit: Sorry my internet disconnected so I think I missed whatever reply you made
21:33:46 <dmwit> asturtz: For the unreadable commands: \il to jump to the import list; \t<symbol> to align on <something to do with symbol>; \q to turn something like "import Module.Name (Type)" into "import qualified Module.Name as MN"; and abbreviations "l<blah>" for language pragma names, \L to insert the pragma right here, \l to insert the pragma at the top of the file and stay where you are.
21:34:16 <dmwit> asturtz: Oh, my reply was "everything IDE-like I'v tried has either been buggy or slow." and "http://lpaste.net/359096"
21:34:29 <Hijiri> pierrot: ceilDiv x y = if x `mod` y == 0 then x else x + 1
21:35:10 <Hijiri> something similar for floorDiv
21:35:25 <Hijiri> wait
21:35:27 <Hijiri> that's bad, sorry
21:35:41 <Hijiri> pierrot: ceilDiv x y = if x `mod` y == 0 then x `div` y else x `div` y + 1
21:35:45 <roconnor__> ceilDiv x y = -((-x) `div` y)  -- ?
21:36:40 <pierrot> it could be ceilDiv x y = x `div` y + x `mod` y
21:36:52 <roconnor__> floorDiv x y = div x y
21:36:58 <dmwit> pierrot: For ceiling (x/y), use ```(x+y-1) `div` y```, for floor (x/y) use ```x `div` y```.
21:38:26 <asturtz> dmwit: Ah ok, thanks. I think you and I are very alike in our editor philosophies. The only thing I can even think that might be of interest is examining the type of an expression. Do you just use ghci for that I guess? I have not done a ton of work with haskell, so I am trying to see what improvements there are to be made with my workflow
21:38:45 <pierrot> dmwit: why all those `` ?
21:38:50 <dmwit> asturtz: Pretty much, yup.
21:38:59 <dmwit> pierrot: I like markdown. =)
21:39:21 <pierrot> ahhh :)
21:40:16 <dmwit> I guess if you want both the ceiling and the floor at once it might be more efficient to use `divMod`.
21:40:53 <dmwit> > let ceilFloorDiv x y = case x `divMod` y of (q, 0) -> (q, q); (q, _) -> (q, q+1) in ceilFloorDiv 3 4
21:40:54 <asturtz> dmwit: So I guess you probably have an open ghci session with all the relevant imports, and you use :r whenever you want to try a function?
21:40:57 <lambdabot>  (0,1)
21:41:16 <dmwit> asturtz: Exactly right. `cabal new-repl` helps with getting all the relevant imports.
21:41:46 <dmwit> hah
21:42:13 <dmwit> > let ceilFloorDiv x y = case x `divMod` y of (q, r) -> (q, q + signum r) in ceilFloorDiv 3 4
21:42:16 <lambdabot>  (0,1)
21:42:22 <pierrot> dmwit: yes, I need both at once. Actually, the function f I'm missing is such that f n = (ceilDiv n, floorDiv n)
21:42:41 <pierrot> it must return a pair with the ceiling and the floor
21:42:54 <dmwit> pierrot: See above. Though I named it backwards compared to its behavior.
21:43:16 <_sras_> dmwit: What is the concept of cabal-freeze-file? Can the same be done via stack?
21:43:22 <dmwit> And you can make it slightly faster still if you know `x` and `y` are positive.
21:43:56 <asturtz> dmwith: Ah yeah, I think I can get something similar with 'stack ghci'. Thank you very much
21:44:48 <pierrot> dmwit: Thanks
21:45:34 <Axman6> saurabhnanda: if you're comfortable with lens, taggy-lens looks useful
21:45:47 <dmwit> _sras_: The freeze files are available from URLs like this one: https://www.stackage.org/lts-9.5/cabal.config
21:45:56 <saurabhnanda> Axman6: what's the underlying HTML parser in taggy-lens
21:46:19 <Axman6> taggy apparently
21:46:26 <dmwit> _sras_: I don't know if stack offers a way to install libraries globally, but that does seem sort of counter to its philosophy. I suspect it has a way to install executables globally.
21:46:35 <Axman6> I haven't used taggy before, only tagsoup
21:47:04 <_sras_> dmwit: Do you think stack can use the packages installed globally using this method, ie via cabal?
21:47:11 <saurabhnanda> Axman6: okay, thanks. Will take a look. Have you done HTML transformations with taggy-lens?
21:47:40 <Axman6> no, but it's use of lens makes me look upon it favourably =)
21:48:03 <dmwit> _sras_: I have no idea. Maybe? I haven't really looked into stack's package database management.
21:49:10 <osa1> this package doesn't have a .cabal file but has a package.yaml file. where can I see documentation of this file? I want to add source-repository field but I don't know how
21:49:54 <dmwit> osa1: https://docs.haskellstack.org/en/stable/yaml_configuration/ in case you meant `stack.yaml` instead of `package.yaml`.
21:50:32 <osa1> dmwit: no I really mean package.yaml
21:50:39 <osa1> I know about stack I use it all the time
21:50:44 <osa1> this one is new
21:51:00 <dmwit> neat!
21:51:14 <osa1> interestingly, stack build just worked. it seems like stack knows about this file format
21:51:43 <osa1> https://stackoverflow.com/questions/40332040/what-goes-in-a-stack-package-yaml-file
21:53:58 <osa1> so that's hpack
22:02:33 <Axman6> saurabhnanda: I've also done some really basic stuff with tagsoup, but having just found this, I would definitely give it a go, I think it wou;d make life a lot easier
22:05:09 <saurabhnanda> Axman6: okay... will ge to HTML parsing in a bit. Currency stuck with CSS parsing.
22:05:21 <Axman6> that sounds a lot less fun
22:05:48 <Axman6> though you might be able to use something like cassius? 
22:09:38 <iqubic> Why not just make a library that parses HTML to an AST, manipulates that, then creates HTML from the AST again.
22:09:59 <iqubic> Maybe wrap up the transformations in a monad, so we get do notation.
22:14:05 <Axman6> iqubic: what do you thing taggy and tagsoup do? :\
22:14:09 <Axman6> think*
22:23:24 <_sras_> Is there anyway to stop Stack from volume mounting the ~/.stack folder from host?
22:27:00 <saurabhnanda> is there any complet-ish CSS parser in Haskell?
22:30:24 <Axman6> doesn't look like it
22:48:12 <saurabhnanda> can anyone check if this code seems like it's handling media queries in CSS at all -- https://github.com/yesodweb/css-text/blob/80114bfeab73f6179e4ff4383b9a62994fcc6478/Text/CSS/Parse.hs#L85-L121
23:01:08 <cocreature> looks like it handles them
23:02:28 <saurabhnanda> cocreature: how did you figure that out? when I'm trying to actually parse a CSS with media queries it seems to be bailing out of the first media query it encounters
23:02:50 <cocreature> show us some code or at least the error message
23:03:09 <cocreature> "takeTill (== '{')" should deal correctly with mediaqueries
23:11:47 <saurabhnanda> cocreature: there really is no code
23:12:05 <cocreature> saurabhnanda: well if you claim it’s not working you are apparently testing it somehow
23:12:13 <saurabhnanda> cocreature: https://github.com/yesodweb/css-text/pull/3#issuecomment-335362367
23:12:56 <saurabhn_> cocreature: https://github.com/yesodweb/css-text/pull/3#issuecomment-335362367 -- just testing on the REPL
23:13:29 <cocreature> what’s the exact code that you’re executing?
23:13:44 <saurabhn_> cocreature: https://gist.github.com/saurabhnanda/cd7e603b5c81241189b6ff0a69619be6
23:14:02 <saurabhn_> check out `pc2` -- it doesn't seem to have any NestedBlock. Everything is a LeafNode.
23:15:11 <cocreature> well step 1: isolate to a small example
23:19:44 <saurabhn_> cocreature: thanks... it's working for a small case. Something in the CSS above the @media query is causing the parser to bail out
23:19:47 <saurabhn_> narrowing it down...
23:20:35 <saurabhn_> got it
23:21:48 <saurabhn_> cocreature: https://github.com/yesodweb/css-text/issues/12
23:27:44 <saurabhn_> cocreature: moving all the media queries to the very bottom of the file works. Seems like it's a very small bug...
23:32:30 <Comonad> Stack installation from haskellstack.org is too slow. Is there any solutions?
23:34:13 <Axman6> it's probably GHC installation/download which is slow
23:34:22 <cocreature> saurabhn_: if you change https://github.com/yesodweb/css-text/blob/master/Text/CSS/Parse.hs#L78 to also stop at '}' it seems to work
23:37:46 <Comonad> It is also slow but I mean the stack itself.
23:38:43 <Axman6> slow doing what?
23:39:32 <Comonad> When I put this line "curl -sSL https://get.haskellstack.org/ | sh"
23:40:01 <Axman6> what is it doing that you feel is slow?
23:40:33 <Comonad> It takes forever to downlading "stack-1.5.1-linux-x86_64-static.tar.gz"
23:40:54 <Comonad> Download speed goes to 0
23:41:03 <Axman6> hmm, shouldn't take too long, it's now a big file
23:41:25 <zilitor> hi i am getting this stack build error
23:41:26 <zilitor>     hsc2hs: .stack-work/dist/x86_64-linux/Cabal-1.24.2.0/build/Foundation/System/Bindings/Posix_hsc_make: runProcess: runInteractiveProcess: exec: permission denied (Permission denied)
23:42:33 <Comonad> Also GHC inst/down is painfully slow that you mentioned already.
23:43:01 <c_wraith> Comonad: what os?
23:43:12 <Comonad> I'm on archlinux
23:43:30 <c_wraith> real, not the WSL version?
23:44:03 <Comonad> real one
23:44:12 <Comonad> not even a VM
23:44:28 <c_wraith> ok.  It's not the WSL bug when running things compiled by 64-bit GHC then
23:45:38 <Comonad> There was no speed problem at all 2 or 3 weeks ago.
23:45:50 <Comonad> It's weird
23:58:38 <anuj_> hey
23:59:19 <anuj_> anybody here? i need some information regarding functional programming languages and haskell
23:59:20 <saurabhn_> anuj_: hey
