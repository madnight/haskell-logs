00:07:27 <tdammers> is it? my rule of thumb is that 1) you don't usually need to, and 2) when you do, the silent agreement is that the results you get are only useful up to the IO / pure boundary
00:09:14 <jle`> to me, it just seems like having partial functions throws away a lot of the 'benefits' of haskell
00:10:33 <osa1> so about the fuzzy file loading thing I mentioned before: https://gist.github.com/osa1/aa28bb5c94a74e96e870ddde846b2e9c this works but it needs to libraries. I'm wondering if it's possible to implement this function using base only
00:11:32 <osa1> it's easy to get rid of `temporary` (by using a hard-coded file path) but not sure how to replace `process`
00:13:13 <cocreature> tdammers: the problem is that it’s really easy to accidentally hide them behind some constructor and then have it blow up in a completely different place
00:14:24 <osa1> hmm is unix package distributed with ghc?
00:14:30 <osa1> maybe I can replace process with unix
00:14:59 <cocreature> osa1: process and unix are both distributed with ghc
00:18:07 <osa1> hmm it turns out that doesn't mean I can use those packages in stack repl though
00:18:19 <osa1> I guess I really need a solution that only uses base
00:19:28 <cocreature> maybe try "stack ghci '--ghci-options=-package process'"
00:19:54 <MarcelineVQ> you can shortcut that with  stack ghci --package process  but it sounded like they want to avoid other packages
00:21:21 <osa1> cocreature: that worked!
00:26:00 <tdammers> cocreature: ah yes, right
00:26:04 <tdammers> cocreature: action at a distance
00:26:58 <tdammers> cocreature: come to think of it, the kind of projects in which I'd throw from pure code are typically ones where exception handling is done close to the top level, and doesn't do much more than abort and log anyway
00:37:39 <ertes-w> hllo
01:31:35 <isaac__> ello
01:32:59 <ertes-w> is there a way to evaluate type aliases in GHCi to see what they expand to?
01:34:47 <Axman6> :info FilePath
01:34:56 <Axman6> I think that'll do it
01:37:42 <MarcelineVQ> :kind! expands things, dunno if it's quite what you want to see though
01:38:00 <Axman6> it expands kinds though
01:38:20 <Axman6> or something... actually that may do it
01:38:48 <Axman6> nope
01:39:04 <Axman6> Prelude> :info FilePath 
01:39:05 <cocreature> it expands type families but not type synonyms afaik
01:39:05 <Axman6> type FilePath = String 	-- Defined in ‘GHC.IO’
01:43:52 <mniip> % :kind! Lens s t a b
01:43:52 <yahb> mniip: ; <interactive>:1:6: error: Not in scope: type variable `s'; <interactive>:1:8: error: Not in scope: type variable `t'; <interactive>:1:10: error: Not in scope: type variable `a'; <interactive>:1:12: error: Not in scope: type variable `b'
01:43:58 <mniip> aw
01:44:20 <mniip> % :info Lens
01:44:23 <yahb> mniip: type role ReifiedLens representational nominal representational nominal; newtype ReifiedLens s t a b = Lens {...}; -- Defined in `Control.Lens.Reified'; type Lens s t a b = forall (f :: * -> *). Functor f => (a -> f b) -> s -> f t -- Defined in `Control.Lens.Type'
01:48:36 <MarcelineVQ> the docs claims :kind! expands synonyms, not sure how to prove that since I'm not sure what it means to do that in the conext of :kind   you can get some filling in via https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/using.html#ghc-flag--fprint-expanded-synonyms
01:49:03 <mniip> well this is what kind! does
01:49:26 <mniip> % :kind! ShowS
01:49:26 <yahb> mniip: ShowS :: *; = ShowS
01:49:31 <MarcelineVQ> type Goo a = (a, a, a)    Just 3 :: Goo Int   "Expected type: (Int, Int, Int)  Actual type: Maybe Integer"
01:49:33 <mniip> ....
01:49:47 <mniip> thanks
02:00:36 <MarcelineVQ> alas, the example for :kind! in the ghc test suit seems to only test type families and not aliases
02:04:01 <MarcelineVQ> "Was ever anything so odd!" she at last exclaimed to herself, in her own room.
02:14:25 <mniip> what does this mean: Could not find module ‘Prelude’    There are files missing in the ‘base-4.10.0.0’ package,    try running 'ghc-pkg check'.
02:25:46 <toby1851> mniip: sounds like you have a broken ghc installation
02:27:08 <MarcelineVQ> or at least a mismatch between what ghc and cabal are expecting to see :(
02:59:18 <ongy> I was just asked why I would voluntarily use haskell. :( seems like the FP course here isn't as good as I thought :0
03:00:54 <geekosaur> mniip, if it's arch then you may need the ghc-static package
03:01:01 <pacak> ongy: Some people are strange....
03:02:31 <ongy> I have he strong feeling I am :0
03:51:18 <fabien> I , can i have some help . i'm stuck with Set THanks
03:52:40 <fabien> i want to count the number of occurence of each value of a set into another .
03:52:59 <fabien> going through both Set and count if the value of the first exists in the second one
03:54:41 <barrucadu> fabien: That sounds like the size of the intersection, to me
03:54:54 <fabien> i'm struggling with this. i'm trying to count how many time Data.Set.Member return true with a filter 
03:55:11 <fabien> but i dont know how to apply the filter to the whole first Set
03:56:00 <fabien> i did that S.filter (== cell) glider . it's working but i want the (== cell) is just one element of my first Set . i want to apply this to the whole Set and count how many times its True
03:56:11 <fabien> so maybe filter isn't what i should use here actually
03:58:37 <ertes-w> fabien: aren't you just looking for the size of the Set?
03:59:23 <fabien> hum , no i don't think ill explain with an example
04:00:21 <fabien> i have this [(5,5),(5,4),(5,6), (10,2), (10,8)] and [(2,4),(7,6),(5,8)] . i want to go through the first one and apply a data.set.member using the second one
04:00:35 <fabien> while counting how many times the data.set.member return true
04:00:52 <ertes-w> fabien: sounds like intersection and size
04:01:25 <ertes-w> > let xs = S.fromList [(5,5),(5,4),(5,6),(10,2),(10,8)]; ys = S.fromList [(2,4),(7,6),(5,8)] in S.intersection xs ys
04:01:29 <lambdabot>  fromList []
04:01:37 <ertes-w> of course the intersection is empty in this case
04:01:40 <fabien> oh
04:01:41 <fabien> ok
04:01:42 <fabien> i understand
04:02:00 <fabien>  > let xs = S.fromList [(5,5),(5,4),(5,6),(10,2),(10,8)]; ys = S.fromList [(5,6),(10,2),(5,8)] in S.intersection xs ys
04:02:08 <fabien> how i cant do it ? aha
04:02:35 <ertes-w> remove the space in front
04:03:04 <fabien> > let xs = S.fromList [(5,5),(5,4),(5,6),(10,2),(10,8)]; ys = S.fromList [(2,4),(7,6),(5,8)] in S.intersection xs ys
04:03:08 <lambdabot>  fromList []
04:03:14 <fabien> > let xs = S.fromList [(5,5),(5,4),(5,6),(10,2),(10,8)]; ys = S.fromList [(5,6),(10,2),(5,8)] in S.intersection xs ys
04:03:15 <fabien> ..
04:03:17 <lambdabot>  fromList [(5,6),(10,2)]
04:04:22 <ertes-w> fabien: and then you can just take the size
04:04:38 <ertes-w> > let xs = S.fromList [(5,5),(5,4),(5,6),(10,2),(10,8)]; ys = S.fromList [(5,6),(10,2),(5,8)] in S.size (S.intersection xs ys)
04:04:42 <lambdabot>  2
04:06:17 <ertes-w> if you interpret (Set (Int, Int)) as grids of booleans, then intersection is a bitwise "and", and union is a bitwise "or"
04:10:29 <fabien> Ok
04:10:36 <fabien> thank you again . ill finish soon
04:22:55 <Barry_> Hello am I allowed to ask questions here?
04:23:57 <ertes-w> Barry_: if you weren't, you'd already have violated that ;)
04:24:59 <Barry_> thats true, but I meant if I was allowed to ask question regarding Haskell code. I need some help with my assignment (and with help I mean that there are things I dont quite get)
04:25:22 <ertes-w> Barry_: sure, just ask
04:26:22 <Barry_> Thank you. My assignment is to create a div function which represents following type: div' :: Int -> Int -> Maybe Int,
04:27:16 <Barry_> oh nvm I think I just understood what I had to do. It sais that I am allowed to "reuse" the function div. But I never wrote such function. So I am guessing that there is a package containing that function
04:27:25 <Barry_> brb going to try i
04:27:26 <Barry_> t
04:27:41 <ertes-w> Barry_: 'div' is predefined in the Prelude
04:27:48 <ertes-w> > div 17 4
04:27:51 <lambdabot>  4
04:28:26 <Barry_> I see
04:28:30 <olligobber> > 17 `div` 4
04:28:33 <lambdabot>  4
04:28:46 <Barry_> but none the less its not the type I am looking for
04:28:46 <olligobber> > 17 `quot` 4
04:28:48 <lambdabot>  4
04:29:01 <Barry_> but to get a maybe Int type
04:29:11 <ertes-w> Barry_: the question is: what semantics are you supposed to implement?
04:29:19 <olligobber> > 17 `div` 0
04:29:23 <lambdabot>  *Exception: divide by zero
04:29:33 <ertes-w> Barry_: i can think of at least two sensible ones
04:29:45 <Barry_> dividing by 0 should reutrn nothing
04:29:48 <olligobber> what is the difference between div and quot I wonder
04:29:59 <ertes-w> olligobber: try with negative numbers
04:30:15 <olligobber> > div -2 1
04:30:18 <lambdabot>  error:
04:30:18 <lambdabot>      • Could not deduce (Num t0)
04:30:18 <lambdabot>        from the context: (Num (t -> a -> a -> a), Num (a -> a -> a),
04:30:25 <olligobber> oops
04:30:31 <olligobber> > div (-6) 2
04:30:37 <Barry_> otherwise its suposed to call the prelude div method
04:30:37 <lambdabot>  -3
04:30:43 <ertes-w> olligobber: div and mod interact in such a way that the remainder is always non-negative
04:30:44 <olligobber> > quot (-6) 2
04:30:47 <lambdabot>  -3
04:30:53 <liste> > div 6 (-2)
04:30:56 <lambdabot>  -3
04:31:04 <liste> > quot 6 (-2)
04:31:07 <lambdabot>  -3
04:31:11 <olligobber> lol
04:31:22 <ertes-w> olligobber: quot and rem interact in such a way that the dividend and the remainder have the same sign
04:31:34 <ertes-w> > quot (-17) 4
04:31:37 <lambdabot>  -4
04:31:46 <ertes-w> > rem (-17) 4
04:31:48 <lambdabot>  -1
04:32:16 <olligobber> "integer division truncated toward zero" vs "integer division truncated toward negative infinity"
04:32:54 <ertes-w> by "interact" i mean that they always satisfy this equation for all x and d:  x = divOrQuot x d * d + modOrRem x d
04:33:36 <olligobber> ertes-w, cool, ty
04:33:46 <Barry_> ertews-w  The method should just divide two numbers, except if it is divided by 0. Then it should return Nothing. But for that I got some trouble because:
04:34:30 <Barry_> To create datatypes that might return nothing I just declare them as Maybe
04:34:54 <olligobber> > :t Just 1
04:34:58 <ertes-w> Barry_: do you know how data types are defined?
04:34:59 <lambdabot>  <hint>:1:1: error: parse error on input ‘:’
04:35:10 <MarcelineVQ> olligobber: hang on a little :>
04:35:27 <Barry_> yes : data name= var
04:35:47 <ertes-w> Barry_: ok, how is Maybe defined?
04:36:14 <Barry_> data Maybe name = var
04:36:28 <ertes-w> Barry_: nope
04:36:41 <Barry_> data Maybe name = var | Nothing
04:36:45 <ertes-w> nope
04:36:59 <ertes-w> don't guess…  you can ask GHCi:  :i Maybe
04:37:28 <Barry_> okay. I am refering to our script. There they use this e.g. data Maybe a = Just a | Nothing
04:37:35 <Barry_> checking the type real quick
04:37:37 <ertes-w> yes, that's how it's defined
04:37:52 <ertes-w> so a value of type (Maybe a) for some type 'a' can be in one of two shapes
04:38:09 <ertes-w> 1. either it's of the shape (Just x), where (x :: a)
04:38:15 <ertes-w> 2. or it's of the shape Nothing
04:38:39 <ertes-w> so for example (Just 5) is a (Maybe Int), and Nothing is a (Maybe Int)
04:39:42 <Barry_> That means
04:39:59 <Barry_> I can just use Just
04:40:07 <Barry_> infront of div. Going to check it
04:40:10 <ertes-w> not only that, but you have to
04:40:25 <ertes-w> you have to return either (Just x) for some x, or Nothing
04:40:42 <ertes-w> s/for/with/
04:40:49 <Barry_> okay so far
04:40:53 <Barry_> I got this f(a,b) = Just (div a b)
04:41:04 <ertes-w> that has a different type
04:41:09 <Barry_> going to return nothing if b==0
04:41:19 <ertes-w> f :: (Int, Int) -> Maybe Int  -- that's the type of your 'f'
04:41:34 <ertes-w> but you're supposed to write a function of type:  f :: Int -> Int -> Maybe Int
04:41:41 <Barry_> ah yes
04:41:42 <Barry_> yes
04:41:45 <Barry_> ups
04:43:49 <Barry_> hmm f a::Int,b::Int = Just (div a b) does not work
04:44:00 <Barry_> I though I could just assign them a Type
04:44:03 <ertes-w> f a b = …
04:44:12 <ertes-w> they get their type from the type signature
04:44:21 <ertes-w> (or from inference, if you don't provide one)
04:44:26 <geekosaur> wthere is an extension that would allow you to do that but you'd still need parentheses
04:44:37 <fabien> im sorry but i really dont get how to do the following : going through a set (or anything else actually) and apply to each element a function i made
04:44:54 <fabien> is it not exactly what fold do ?
04:44:56 <ertes-w> fabien: "apply"?  to yield a new set?
04:45:05 <ertes-w> or to perform an action with each value?
04:45:28 <fabien> i dont really know for the moment . maybe you can show me both =)
04:45:42 <geekosaur> 'map' does exactly what you described. 'fold' is a bit different
04:45:55 <fabien> i think i didnt really get what fold do so
04:46:09 <fabien> what is the syntax for map ? because i cant use it good
04:46:25 <ertes-w> > S.map (1 +) (S.fromList [1,2,3])
04:46:27 <lambdabot>  fromList [2,3,4]
04:46:53 <MarcelineVQ> assuming by set you meant Data.Set
04:46:57 <fabien> y
04:47:07 <raek> > S.map abs (S.fromList [-2, -1, 0, 1, 2])
04:47:09 <lambdabot>  fromList [0,1,2]
04:47:26 <fabien> if my function take 2 args how i use it , one of these is the element of the Set im actually going through
04:47:31 <raek> S.toList (map abs (S.fromList [-2, -1, 0, 1, 2]))
04:47:42 <raek> ugh.
04:48:05 <ertes-w> fabien: if you're function is of type (Int -> Int -> A), then 'uncurry' will turn it into a function of type ((Int, Int) -> A)
04:48:10 <ertes-w> :t replicate
04:48:12 <lambdabot> Int -> a -> [a]
04:48:13 <ertes-w> :t uncurry replicate
04:48:15 <lambdabot> (Int, a) -> [a]
04:48:33 <raek> fabien: what is the other argument?
04:48:36 <fabien> my function take the Set and one element of another Set but just one
04:48:56 <ertes-w> fabien: but you can also just write a lambda:  S.map (\(x, y) -> …)
04:49:03 <fabien> :: (t1, t) -> Set (t1, t) -> Int
04:49:07 <fabien> something like that
04:49:36 <ertes-w> fabien: why don't you just explain what you're trying to do…
04:49:52 <fabien> i didnt want you to do everything = )
04:50:09 <fabien> nbofNeigh cell mymap =  (S.size $ S.intersection (neigh cell) mymap) - 1
04:50:11 <fabien> i have this
04:50:17 <fabien> >nbofNeigh cell mymap =  (S.size $ S.intersection (neigh cell) mymap) - 1
04:51:08 <fabien> and i want to go through another Set and apply to it this function (the arg cell is the element of the other set)
04:51:57 <ertes-w> fabien: so you want a map from cells to number of live neighbours
04:52:29 <fabien> i want to count for each actually alive cells how many alive neighbours they have
04:52:33 <ertes-w> "map" as in "association"
04:52:37 <ertes-w> yeah, that
04:53:02 <fabien> the approach is so abstract = O
04:53:04 <ertes-w> you're trying to implement the game of life iteration function?
04:53:46 <fabien> y
04:54:12 <fabien> for one "life"
04:54:16 <fabien> one turn
04:54:52 <ertes-w> once you have the set of all potential cells, all you really need to do is to apply S.filter
04:55:18 <ertes-w> in the filter function compute exactly what you just wrote and then decide whether the cell lives (return True) or is dead (return False)
04:55:22 <ertes-w> :t S.filter
04:55:26 <lambdabot> (a -> Bool) -> S.Set a -> S.Set a
04:55:33 <Barry_> ertes-w: I noticed that I seem to have not understand something in the Script. As far as I understood I can either declare a Datatype or symply use a variable to store my function. My function is returning a division (div a b) or Nothing if b is 0. Hence I use f a b = if b==0 then Nothing else Just (div a b). And here everything gets very confusing. Why do I need that "Just" infront of the div. I understand that Maybe requires Just a
04:56:13 <ertes-w> Barry_: that's the reason
04:56:34 <ertes-w> Barry_: data Bool = False | True  -- a value of type Bool is either of the form False or of the form True
04:56:52 <Barry_> ah
04:56:57 <ertes-w> the reason you need Just is pretty much the same as the reason you need True
04:57:00 <Barry_> but how is my function interpreted as Maybe
04:57:39 <ertes-w> Barry_: you wrote it such that it returns (Maybe Int)
04:58:16 <Barry_> I see and therefore somewhere nothing needs to be returned too, else it would not be Maybe Int
04:58:46 <Barry_> Probably something that is found out during verification
04:59:17 <Barry_> Okay now i only need to find out why I cant declare types
05:00:39 <ertes-w> Barry_: well, you don't *have to* return Nothing, but whatever you return will be in one of the Maybe forms
05:00:53 <ertes-w> *one of the two Maybe forms
05:02:38 <Barry_> dont have to...thats confusing me again. I need to think about that using Bool as an Example
05:03:10 <Barry_> Basicly Bool is similiar to Maybe
05:03:33 <Barry_> If I define a Bool function, than that function is either true or false
05:03:34 <geekosaur> it's got a key difference
05:03:53 <Barry_> geekosaur: ? what key difference
05:04:34 <geekosaur> Bool doesn't carry any other values and therefore doesn't need an additional type for them. (Maybe a) does
05:06:15 <Barry_> what do you mean by "any other values"?
05:06:27 <Barry_> Maybe a is either  a or Nothing
05:06:38 <geekosaur> no, it isn't
05:06:47 <fabien> i dont find the syntax , how can i apply filter to my function who take two args
05:06:49 <geekosaur> Maybe a is either (Just a) or Nothing
05:06:52 <Barry_> Just a or Nothing
05:06:57 <Barry_> oh wait
05:07:02 <fabien> filter (myfunc ....) mymap
05:07:38 <Barry_> so carries other values means that there is a "Just" type which carries the passed value?
05:08:29 <Barry_> Maybe I should read some more websites that explain "Maybe". 
05:09:17 <Barry_> Thank you all for your help. Will stick around and maybe get some help later on after learning more!
05:10:36 <fabien> when you apply filter to filter (>5) [1,3,4,6,7] you compare two elements of the list , but me in my case i want to compare one element with all the list with a filter , how can i do that ?
05:12:21 <ertes-w> Barry_: don't confuse the type level with the value level
05:12:38 <raek> Barry_: Just is a constructor that carries the value, yes. Nothing is another constructor that carries no value.
05:12:41 <geekosaur> Just is a data constructor, not a type
05:12:45 <geekosaur> :t Just
05:12:46 <lambdabot> a -> Maybe a
05:13:14 <ertes-w> Barry_: much like True is not a type…  it lives on the value level
05:13:14 <geekosaur> in that sense it's similar to Bool, where Bool is the type and False and True are data constructors
05:14:24 <fabien> ? =(
05:14:26 <ertes-w> Barry_: "to carry" is a different metaphor for the same idea…  i used the metaphor of being of a certain shape to explain the same idea
05:14:57 <ertes-w> fabien: you only filter a single value, but that value happens to be a tuple
05:15:20 <fabien> hum yea
05:15:26 <ertes-w> fabien: for your particular use case you can consider the tuple to be one unit of information
05:15:41 <ertes-w> no need to extract the individual components
05:15:48 <ertes-w> S.filter (\p -> …)
05:15:58 <ertes-w> "p" as in "position" or "point"
05:16:06 <fabien> position in the list ?
05:16:45 <ertes-w> > S.filter (\p -> fst p > 5) (S.fromList [(1,2), (4,3), (5,7), (8,0)])
05:16:49 <lambdabot>  fromList [(8,0)]
05:17:31 <fabien> fst is for first right ?
05:17:38 <fabien> it takes the first element of a pair 
05:17:45 <ertes-w> > fst (x, y)
05:17:47 <lambdabot>  x
05:17:49 <fabien> i don't get it ..
05:17:59 <fabien> i need to compare both x and y
05:18:03 <fabien> no ?
05:18:42 <ertes-w> fabien: you have a set of all cells that might live in the next frame
05:18:53 <fabien> y
05:19:04 <ertes-w> you filter that set by whether they do actually live, so your filter function should determine if they live
05:19:14 <fabien> i did a function for that
05:19:18 <ertes-w> which depends on how many live neighbours they had in the last frame
05:19:24 <fabien> i did it yea
05:19:36 <ertes-w> yep…  you're almost done
05:19:53 <ertes-w> just try it
05:19:59 <fabien> i want to apply this function to the actually living cells
05:20:14 <fabien> but this function takes one cell and the grid
05:20:25 <fabien> i don't understand how i can do it another way
05:20:49 <Barry_> Wow thanks a lot. I just see that I keep applying things I learned in Java into Haskell and that feels bad
05:23:24 <Barry_> antwort :: Int antwort =42
05:23:27 <Barry_> antwort
05:23:31 <Barry_> ups sry
05:23:35 <Barry_> wrong windo
05:24:26 <ertes-w> fabien: why another way?  just give it the grid
05:25:02 <fabien>  S.filter (\p -> myfunctionwhosayifitsalive fst p) mymap?
05:25:14 <fabien> oh my god i'm lost 
05:25:38 <ertes-w> fabien: how is fst useful there?
05:25:54 <fabien> i dont know , i dont get why i should use fst actually
05:26:04 <fabien> i need both elements of my tuple 
05:26:07 <fabien> to compare it
05:26:16 <ertes-w> fabien: i didn't say you should, but now i can tell that you're bruteforcing
05:26:20 <ertes-w> fabien: take a break
05:26:42 <fabien> =((((
05:27:06 <ertes-w> fabien: and make it at least 15 minutes
05:28:30 <skm_baig> hi! Is there a diagram of haskell type class hierarchy somewhere?
05:30:25 <crobbins> skm_baig: typeclassopedia
05:30:37 <Barry_> Thanks guys I could solve it
05:30:47 <Barry_>  f::Int->Int->Maybe Int 
05:30:48 <Barry_> f a b = if b==0 then Nothing else Just (div a b)
05:31:14 <ertes-w> Barry_: you can actually write this:  f a 0 = Nothing; f a b = Just (div a b)
05:31:44 <Barry_> The reason I didnt think about using this, was because I was typing all this into the console directly without using a file. Which made it fail because of some scope issue
05:32:15 <Barry_> ertes-w: Thank you. I actually tried that first, but again because i was typing it in the console i couldnt use it. What an idiot i am
05:33:21 <Barry_> And now I understand why I needed Just 
05:33:29 <Barry_> because the required Type was Maybe
05:33:49 <Barry_> and without the Just it would be Int and not Maybe Int
05:49:27 <fabien> Ok i did it but its really ugly i think its working
05:50:34 <fabien> http://lpaste.net/359554
05:51:06 <fabien> i did it my way with what i know from list , i didn't know how to deal with Set for the iteration through it
05:52:26 <skm_baig> hi! Is there a diagram of haskell type class hierarchy somewhere? _OR_ how to find out which type implements which type-class?
05:54:57 <atagunov> hey, full novice here; in ghci what is the difference between      let m = "m"      and       m' = "m"  ?
05:56:09 <MarcelineVQ> those things just by themsleves? from ghci 8 onwards no difference at all
05:56:24 <MarcelineVQ> earlier versions required the let
05:56:26 <fabien> im novice too but i guess its the same
05:56:40 <atagunov> isn't this a 0-arg "function"?      m' = "m"
05:57:03 <MarcelineVQ> no it's just a value "m" with a name m'
05:57:20 <MarcelineVQ> functions have -> in their type
05:57:26 <MarcelineVQ> :t "m"
05:57:28 <lambdabot> [Char]
05:57:31 <MarcelineVQ> :t (+)
05:57:32 <lambdabot> Num a => a -> a -> a
05:58:13 <skm_baig> hi! Is there a diagram of haskell type class hierarchy somewhere? _OR_ how to find out which type implements which type-class?
05:58:13 <atagunov> ta!   :t    is massively useful to learn :)
05:58:19 <MarcelineVQ> works in ghci too!
06:00:05 <Psybur> How would you get the first element of a Traversable?
06:00:40 <Fuuzetsu> skm_baig: Haddock shows all instances in scope. You can also use :i in GHCi. I don't know of a diagram: it's difficult to do because type classes are open.
06:01:23 <Psybur> I guess use its foldable features
06:01:44 <Fuuzetsu> Yes, Foldable is what you want.
06:02:11 <Psybur> foldr1 ?
06:02:27 <Psybur> Probably better than foldl1 since it will work on an infinite container?
06:02:30 <Fuuzetsu> toList :: f a -> [a]
06:02:40 <Fuuzetsu> then listToMaybe/head
06:02:45 <Psybur> I see
06:12:39 <ertes-w> Psybur: usually just foldr
06:13:02 <ertes-w> Psybur: for example to print the first element:  foldr (\x _ -> print x) (putStrLn "empty")
06:14:28 <Psybur> > foldr (\x _ -> x) undefined [1,2,3,4]
06:14:31 <lambdabot>  1
06:14:44 <Psybur> > foldr (\x _ -> Just x) Nothing [1,2,3,4]
06:14:47 <lambdabot>  Just 1
06:14:54 <Psybur> > foldr (\x _ -> Just x) Nothing []
06:14:57 <lambdabot>  Nothing
06:15:33 <Psybur> Interesting, I never knew you could skip the accumulation by ignoring it
06:15:38 <Fuuzetsu> toList t = build (\ c n -> foldr c n t)
06:16:02 <byorgey> Psybur: yes, and that is the crucial property that lets foldr work on infinite lists
06:16:10 <byorgey> @src all
06:16:10 <lambdabot> all p = and . map p
06:16:23 <byorgey> @src and
06:16:23 <lambdabot> and = foldr (&&) True
06:16:40 <byorgey> > and (True : True : True : False : repeat True)
06:16:42 <lambdabot>  False
06:16:45 <ertes-w> @where foldrtut
06:16:46 <lambdabot> http://ertes.eu/tutorial/foldr.html
06:16:48 <Fuuzetsu> I hate that ‘and [] = False’ to be honest
06:16:51 <ertes-w> Psybur: ^ you might be interested
06:16:56 <Fuuzetsu> uh, and [] = True*
06:17:15 <ertes-w> Fuuzetsu: what would you prefer?
06:17:17 <byorgey> Fuuzetsu: hmm? why do you hate that?
06:17:47 <fakenullie> True is mempty for All
06:17:55 <ertes-w> Fuuzetsu: True is the most sensible choice, much like the empty product is 1
06:18:03 <ertes-w> Fuuzetsu: (&&) is a monoid
06:18:16 <Fuuzetsu> I don't think it's rational hate. I have previously defined ‘and [] = False; and [x] = x; and (x : xs) = x && and xs’; which was obviously surprising to the next guy
06:18:17 <skm_baig> Fuuzetsu: thanks for info.
06:19:47 <byorgey> Fuuzetsu: definitely sounds irrational to me.  You must learn to let go of your feelings.  Let the Force guide you.
06:19:48 <Fuuzetsu> I agree it's sensible. But it sounds wrong; consider ‘any (== 1)’: it reads as "are any of the elements equal to 1?"; and it's True for []
06:19:56 <Psybur> ertes-w, I think you left out the "tail" exercise
06:20:23 <byorgey> Fuuzetsu: uh,  any (==1) is False for []
06:20:28 <byorgey> > any (==1) []
06:20:30 <lambdabot>  False
06:20:31 <byorgey> =)
06:20:41 <Fuuzetsu> @src any
06:20:41 <lambdabot> any p = or . map p
06:20:49 <Fuuzetsu> @src or
06:20:49 <lambdabot> or = foldr (||) False
06:20:55 <byorgey> all (==1) [], on the other hand, is True, as it should be: all zero of the elements in the empty list are 1
06:20:57 <Fuuzetsu> hm
06:21:04 <Fuuzetsu> oh, I guess I meant all.
06:21:26 <byorgey> if you think all (==1) []  should be False, then you need to adjust your intuition for what 'all' means =)
06:21:54 <Fuuzetsu> As I said, it's irrational hate
06:23:14 <ertes-w> Psybur: right…  i'll fix it some day…  officially the article is still a draft =)
06:23:53 <ertes-w> Fuuzetsu: are all pink elefants drunk?  i'd say yes
06:23:55 * byorgey suggests spending a day meditating upon things such as sum [], product [], and [], or [], maximum []
06:24:14 <Psybur> Im still stuck on how foldr (&&) True only stops when it hits False. What makes it so that it keeps going if it hits True?
06:24:27 <byorgey> Psybur: because of the definition of (&&)
06:24:29 <byorgey> @src &&
06:24:30 <lambdabot> True  && x = x
06:24:30 <lambdabot> False && _ = False
06:24:30 <ertes-w> Psybur: the definition
06:24:36 <Psybur> Ah I see
06:25:01 <byorgey> Psybur: you can see how True && x = x, so it keeps going to look at the x (which in this case is a recursive foldr)
06:25:07 <byorgey> but False && _  ignores the second argument
06:25:12 <ertes-w> Psybur: foldr (&&) True (True : xs) = True && foldr (&&) True xs  -- by definition of foldr
06:25:24 <ertes-w> Psybur: True && foldr (&&) True xs = foldr (&&) True xs  -- by definition of (&&)
06:25:26 <drantriso> Hello guys :-)
06:25:37 <byorgey> hi drantriso, welcome
06:25:50 <Psybur> I gotcha now, thanks
06:35:01 <Psybur> Is there a more efficient way of implementing tail with a fold than: tail' = fst . foldr (\x (ys, xs) -> (xs, x:xs)) (error "empty list", [])
06:39:17 <Psybur> There must because that doesnt work on an infinite list ;_;
06:41:57 <ertes-w> Psybur: 'tail' using foldr is rather expensive unfortunately, because the resulting list has an extra traversal
06:43:00 <ertes-w> > foldr (\x go c -> c x (go (:))) (const []) [0..] (const id)
06:43:02 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
06:43:33 <ertes-w> the problem is that foldr can't "switch"
06:44:42 <Psybur> Youve melted my brain with that. Congrats :D But that doesnt seem hard to do
06:45:00 <ertes-w> it isn't…  see the section "stateful folds" in the tutorial
06:45:24 <Psybur> I mean it doesnt seem hard to melt my brain ;p
06:45:38 <ertes-w> oh =)
06:45:46 <carbolymer> raise your boiling point!
06:45:55 * carbolymer meant melting point
06:45:57 <ertes-w> but it's still not as weird as it looks
06:46:07 * Psybur salts his brain
06:47:09 <ertes-w> > foldr (\x go first -> if first then go False else x : go first) (const []) [0..] True
06:47:13 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
06:47:40 <ertes-w> it's just a stateful pattern…  instead of just returning the list from the fold, return a stateful function
06:48:09 <ertes-w> then give that function an initial state (that's the 4th argument)
06:48:40 <ertes-w> in this case it's a boolean state that starts True and then switches to False after the first element
06:49:52 <ertes-w> in the original version instead of using a boolean as the state i used the cons operator…  it starts with a cons operator that ignores its first argument, then switches to the regular (:)
06:50:29 <ertes-w> > const id 'h' "ello"
06:50:32 <lambdabot>  "ello"
06:50:34 <ertes-w> > (:) 'h' "ello"
06:50:36 <lambdabot>  "hello"
06:51:03 <Psybur> I see
06:53:44 <ertes-w> > foldr (\x go c1 c2 -> c1 x (go c2 c1)) mempty "hello world" (:) (const id)
06:53:48 <lambdabot>  "hlowrd"
06:53:59 <ertes-w> > foldr (\x go c1 c2 -> c1 x (go c2 c1)) mempty [0..] (:) (const id)
06:54:02 <lambdabot>  [0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52...
06:54:10 <mizu_no_oto> Control.Monad has =<< and <=<, but no <<.  <<, these days, would just be <*.  However, does anyone know why it wasn't included before Applicative became a superclass of Monad (or, for that matter, before Applicative was created)?
06:55:44 <Psybur> ertes-w, that last one alternated between (:) and (const id) I take it
06:55:52 <ertes-w> Psybur: exactly =)
06:56:07 <Psybur> ertes-w, now skip three :D?
06:56:14 <Psybur> Or skip two
06:56:23 <Psybur> Or skip n ;p
06:56:53 <ertes-w> @let import qualified Data.Stream as Str
06:56:55 <lambdabot>  Defined.
06:57:01 <Fuuzetsu> mizu_no_oto: but <* isn't (flip *>) while presumably you want << = flip (>>)
06:57:14 <Fuuzetsu> flip (*>)*
06:58:09 <Fuuzetsu> putStrLn "hi" <* putStrLn "bye" = hi\nbye
06:58:11 <ertes-w> > foldr (\x go (Str.Cons c cs) -> c x (go cs)) mempty [0..] (Str.cycle ((:) : replicate 2 (const id)))
06:58:15 <lambdabot>  [0,3,6,9,12,15,18,21,24,27,30,33,36,39,42,45,48,51,54,57,60,63,66,69,72,75,7...
06:58:24 <ertes-w> Psybur: ^
06:58:47 <mizu_no_oto> Fuuzetsu: right; presumably << would have the same effect.
06:59:08 <mizu_no_oto> rather than being "bye/nhi/n"
07:00:15 <Psybur> > foldr (\x go (Str.Cons c cs) -> c x (go cs)) mempty [0..] (Str.cycle ((:) : replicate 3 (const id)))
07:00:19 <lambdabot>  [0,4,8,12,16,20,24,28,32,36,40,44,48,52,56,60,64,68,72,76,80,84,88,92,96,100...
07:00:34 <Fuuzetsu> I think that's a good reason to not include it: f =<< g would not be the same as (\_ -> f) << g
07:02:57 <ertes-w> Psybur: exercise: write in terms of foldr a function that swaps pairwise =)
07:03:14 <ertes-w> Psybur: pairSwap "abcdef" = "badcfe"
07:03:30 <ertes-w> Psybur: pairSwap "abcdefg" = "badcfeg"
07:04:03 <Psybur> ertes-w, ok, ill give it a shot
07:14:29 <mniip> hmm, I've been thinking,
07:14:48 <spaghetti> yellow
07:15:01 <mniip> a higher order type class C :: (* -> *) -> Constraint in haskell, can be emulated with a rebindable trait in C++
07:15:46 <mniip> which I mean, template<typename B> using C_trait<F<A>>::rebind = F<B>
07:16:47 <mniip> with the restrictions that trait<X>::rebind<trait<X>::elem_type> = trait<X>::elem_type
07:17:03 <mniip> and that trait<X>::rebind<Y>::rebind<Z> = trait<X>::rebind<Z>
07:18:11 <mniip> errr
07:18:18 <mniip> trait<X>::rebind<trait<X>::elem_type> = X
07:18:25 <mniip> and
07:18:39 <mniip> trait<trait<X>::rebind<A>>::rebind<B> = trait<X>::rebind<B>
07:20:30 <mniip> hmm if rust allows rebind-style associated generic types
07:20:49 <mniip> that could be a hack to allow higher kinded traits in rust
07:25:56 <Psybur> ertes-w, so Im following the example, trying to turn my recursive function into a function that returns a function. Im stuck trying to figure out how do that to this: alternate (x:y:ys) = y : x : alternate ys
07:27:07 <ertes-w> Psybur: remember that you can only ever process one element at a time…  so what kind of state do you need?
07:29:12 <Psybur> One that can return two elements or none?
07:29:58 <noumenon> has anyone here successfully used Haskell to implement machine learning algorithms?
07:30:21 <Psybur> noumenon, you can use haskell to call scikit learn :D?
07:31:15 <noumenon> I think I'd prefer using TF then ;P
07:32:17 <noumenon> thinking mostly about modern neural nets, CNNs and RNNs and variations thereof; I see there are some packages, just wondering if anyone has any practical experience with them here
07:33:10 <ertes-w> Psybur: you get the first element x1…  you can't return the first element of the result list yet, so you keep x1 on the side…  in the next iteration you get x2, and now you can return something
07:34:49 <ertes-w> noumenon: i have implemented neural networks and genetic learning, and i have used logistic regression in practice
07:35:37 <ertes-w> noumenon: one of my old just-for-fun ANN libraries is on hackage: instinct
07:36:40 <nesqi> What is the shortest code for extracting the first (Monkey b) from a [Animals] where data Animals = Monkey Int | Duck String
07:37:04 <nesqi> It seems so clumsy to define a function that patternmatch on Monkey
07:38:12 <nesqi> Is there no short compact oneliner?
07:38:38 <MarcelineVQ> what if there are no monk
07:39:03 <nesqi> then Nothing
07:39:22 <nesqi> find f list
07:39:33 <tdammers> listToMaybe [ a | Monkey a <- animals ]
07:39:39 <nesqi> AAh!
07:39:46 <nesqi> List comprehensions
07:39:54 <nesqi> Forgot about them
07:39:56 <nesqi> Thanks!
07:40:46 <phadej> firstOf (folded . _Monkey) animals
07:40:50 <phadej> a little shorter
07:41:09 <nesqi> _Monkey?
07:41:15 <phadej> makePrisms ''Animals
07:41:27 <cement> where should I start if I need/want to learn about strictness profiling?
07:41:38 <phadej> I just switched from #haskell-lens :)
07:41:39 <cement> because 13.8 GB space leaks aren't fun
07:41:47 <nesqi> right.. not using lens/prisms
07:41:59 <phadej> cement: first run heap profilers, to see what you leak
07:42:17 <phadej> cement: in 99% cases you'll know where to look after thata
07:42:27 <cement> ok, so step 1 is to look up heap profilers, fair enough
07:42:31 <Wizek> Hey! Anyone remembers what's the other valid naming scheme to .cabal files other than `<project-name>.cabal`?
07:42:46 <Wizek> I remembered something like package.cabal but that doesn't seem to be accepted
07:43:35 <phadej> Wizek: anything.cabal works
07:43:35 <phadej> but
07:43:36 <phadej> * The filename ./any.cabal does not match package name (expected:
07:43:36 <phadej> servant-mock.cabal)
07:43:36 <phadej> Hackage would reject this package.
07:43:49 <phadej> and iirc stack is strict on that too
07:45:13 <Wizek> Isn't there a single other name that's accepted that's independent from the project name? I seem to remember that there was. Similar to how `package.yaml` is accepted and doesn't require us to name it `my-package.yaml`
07:45:40 <Wizek> *I mean stack.yaml
07:47:39 <phadej> Wizek: https://github.com/haskell/cabal/blob/bb5e43f2a00fdbc59c9141bfebeaccd5557e7e8a/Cabal/Distribution/Simple/Utils.hs#L1506
07:48:08 <noumenon> ertes-w: interesting, thanks; I'll check out instinct, hehe
07:49:16 <ertes-w> noumenon: the only interesting thing about it is that it uses dynamic programming with vectors
07:49:28 <ertes-w> both for evaluation and for backprop learning
07:49:39 <ertes-w> that's why the code is so short
07:51:44 <Wizek> phadej: Thanks for the source code link, that seems to corroborate what you said about cabal quite a bit.
07:53:18 <Psybur> Is there a way to get ghci to show you what pattern was missing if it finds a non exhaustive one?
07:53:50 <c_wraith> enable -Wall
07:58:24 <awalterschulze> Hi.  I am new to Haskell.  I have completed my first moderate sized project.  Is anyone willing to review it, so that I can get some feedback and hopefully learn how to write better haskell?  Simply post an issue on github with any comments/advice you might have.  Thank you. https://github.com/katydid/katydid-haskell
07:59:20 <cement> does ghci's debugger play well with a concurrent function?
07:59:37 <cement> as in, a function that only gets run inside of a mapConcurrently?
08:04:17 <mrkgnao> awalterschulze: you should try posting this on the Haskell subreddit. people ask for comments on their new projects there all the time.
08:04:35 <awalterschulze> ah thanks
08:05:03 <mrkgnao> from a quick look, it seems like you know what you're doing. :)
08:06:57 <awalterschulze> thank you very much
08:07:09 <awalterschulze> I didn't know that I knew what I was doing :)
08:07:28 <Psybur> ertes-w, you probably think the h ++ t is cheating huh https://pastebin.com/9UDmfLYz
08:07:28 <Psybur> ;D
08:09:35 <cement> ok, revising my question: is it sane to set a breakpoint on a function that's run only inside of a concurrent thread in ghci's debugger?
08:10:09 <Psybur> Ah and I see that doesnt even work with odd number lists
08:10:19 <awalterschulze> posted https://www.reddit.com/r/haskell/comments/78w65f/code_review_request_from_a_noob_haskeller/ Thank you mrkgnao
08:10:26 <awalterschulze> Have to go.  Cheers.
08:11:36 <ertes-w> Psybur: no, but does it work for lists with odd lengths?
08:11:50 <Psybur> ertes-w, no it doesnt :D
08:12:42 <Psybur> In order to do that I need to build it up as a function that then takes in the list probably
08:13:46 <ertes-w> Psybur: solve this one first: implement (zipWith (+) (cycle [0,1])) in terms of foldr
08:14:14 <ertes-w> f [1,2,3,4,5,6] = [1,3,3,5,5,7]
08:14:57 <ertes-w> f [1,2,3,4,5] = [1,3,3,5,5]
08:15:26 <Psybur> Ok ill take a stab after lunch
08:15:55 <EvanR> f [1,3,5,7] = [1,4,5,8]
08:16:14 <EvanR> the first two examples made me think you were just doubling every other item
08:16:55 <ertes-w> Psybur: i'll be gone soon, so you got time till tomorrow =)
08:17:18 <ertes-w> Psybur: if you get stuck read the tutorial i linked…  it explains stateful folds in detail
08:18:03 <ertes-w> and if it doesn't help you, be sure to tell me that i suck, so i can improve it =)
08:47:03 <lamdevhs> hello! i have a program which among others uses getChar at some point to interact with the user. when using it on ghci, it works fine: i type a letter, and the command is executed by my program. but i built the program and when i use the binary in a linux terminal, typing a character does nothing, i have to press "enter" to make the program take the character into account, and on top of it the "enter" is also taken as a command by
08:48:24 <kadoban> lamdevhs: You got cut off at "[...] command by", but the obvious guess would be buffering. Probably look at hSetBuffering ? Usually I see these problems with output, but then I don't do a lot of interactive programs recently.
08:48:54 <lamdevhs> i'll try looking into it, thanks :)
08:49:27 <lamdevhs> still i'm wondering why the ghci-launched version has a different behavior than the compiled one...
08:50:11 <lamdevhs> is the behavior i want "NoBuffering"?
08:50:19 <EvanR> https://twitter.com/aisamanra/status/923346798093090816
08:50:32 <kadoban> If that's what the problem is, NoBuffering should change the behavior. So it'd be worth a shot
08:52:02 <kadoban> EvanR: Ugh, that's kind of terrible. Is there an obfuscated haskell competition? Because that'd be a good contender for some minor fun.
08:53:43 <lamdevhs> kadoban: hSetBuffering worked, thanks :)
08:53:52 <kadoban> Cool, 'welcome
08:54:11 <kadoban> As to why GHCi behaved differently, it must just have a default buffering setting
08:54:35 <kadoban> It has quite a few different small (and large) behaviors like that, so it's not that surprising to me.
08:56:24 <__monty__> I was hoping to try out keccak with haskell. It seems cryptonite only exposes the hash functions. Is there a way to play around with kmac and keccak based aead?
08:56:55 <lamdevhs> hm ... that sounds a bit absurd to have different behaviors during the tests and when the program compiles... but i guess there must be a good reason. at any rate there's still something strange (though much less problematic): my program first writes a '?' char with putChar, then waits for a command char, then gets it, then writes '\r' to flush the '?' and the command chars from the screen
08:57:05 <lamdevhs> then executes the command. when launching the built version, the '?' char is not printed. any idea why?
08:57:24 <lamdevhs> (it was already the case before using hSetBuffering)
08:57:47 <kadoban> lamdevhs: Same problem but on the output stream?
08:58:00 <kadoban> And yeah, it's sometimes problematic that GHCi has different behavior.
08:58:16 <lamdevhs> kadoban: hm oh so it waits for a newline to print things to screen? ok thx i'll test that
08:58:54 <kadoban> I don't even know what the default output buffering is, maybe LineBuffering, so then yeah it'd wait for a newline or something.
08:59:49 <lamdevhs> kadoban: that worked, thanks again! is that not still a weird default? to me by default putChar should print a character without regard for newlines... i dunno
09:00:42 <thoughtpolice> __monty__: Unfortunately it does not look like there's any kind of generalized implementation of the Keccak sponge, so I'm afraid you'd have to write it yourself. :(
09:00:50 <kadoban> It improves performance *greatly* in the usual case, when you're just inputting/outputting huge blocks of text.
09:00:54 <EvanR> putChar might output more than one byte, so makes sense to sort of expect \n -> \r\n
09:01:04 <Aconite> Hi everyone
09:01:07 <kadoban> But I'm not sure, in a sense at least it's certainly a bit unfortunate.
09:01:21 <thoughtpolice> __monty__: You can, of course, 'just' shell out to some C code to do it for you. Then you could write a nice wrapper over the C API to make it more Haskell-friendly.
09:02:03 <thoughtpolice> (This is what I do for my 'ed25519' package since it means I don't have to work super hard but I can still offer a nice UX for users.)
09:03:01 <lamdevhs> hm i see
09:03:24 <lamdevhs> thanks again!
09:03:34 <Psybur> > foldr (\x (ys,b) -> if b then ((x+1):ys,False) else (x:ys,True)) ([],True) [1,3,5,7]
09:03:37 <lambdabot>  ([1,4,5,8],True)
09:03:41 <Psybur> ertes-w, ^
09:04:14 <__monty__> thoughtpolice: Hmmm unfortunate. I might try my hand at a wrapper, low priority though since it's just for toying around. Thanks anyway.
09:04:26 <Psybur> But that can be more efficient right? Instead of doing a boolean test everytime, you said that we can implement it in such a way that each iteration tells the next one what to do
09:04:51 <Aconite> I've just started learning haskell and am following "Learn you a Haskell for great good", I have one problem though. In GHCI div 9 3 works fine but if I use 9 'div' 3 it gives me <interactive>:6:3: error:     * Syntax error on 'div'       Perhaps you intended to use TemplateHaskell or TemplateHaskellQuotes     * In the Template Haskell quotation 'div'
09:05:06 <Aconite> Any suggestions?
09:06:07 <kadoban> Aconite: You want ` , it's with the tilde
09:06:25 <EvanR> backtick not apostrophe
09:07:14 <Aconite> Yeah that works, thanks!
09:08:40 <thoughtpolice> __monty__: It's not too bad, it's mostly just a little wrapping to deal with ByteString's and Ptrs and converting them. You might also be able to use inline-c: https://github.com/fpco/inline-c/tree/master/inline-c
09:08:51 <thoughtpolice> Ah, damn
09:36:29 <Sornaensis> > (.) (+) (read) “3” 4
09:36:33 <lambdabot>  <hint>:1:16: error: lexical error at character '3'
09:36:38 <Sornaensis> que
09:37:08 <Sornaensis> > (.) (+) (read) "3" 4
09:37:11 <lambdabot>  7
09:37:15 <Sornaensis> fckn keyboards
09:47:13 <nicknight> scala also functional programming and knowing haskelldoes help knowing scala aswell ?
09:50:54 <unixer> Hello. I am still pretty new to Haskell. I have a terminal based application (I am using System.Console.ANSI) that reads input from stdin from a pipe. How can I also get input from the keyboard?
09:52:12 <phadej> for cli applications "stdin" is the "keyboard"
09:52:35 <unixer> so there is no way to get key presses if stdin is attached to a pipe?
09:53:52 <phadej> nope (I might be very wrong, but then the solution is something quite non-portable)
09:54:23 <EvanR> i have solved this by accepting the input on not stdin, but a new pipe
09:54:31 <EvanR> then you still have stdin as normal
09:54:37 <phadej> http://www.linuxjournal.com/content/using-named-pipes-fifos-bash <- something like that?
09:57:39 <EvanR> https://unix.stackexchange.com/questions/351061/does-keyboard-input-always-go-through-a-controlling-terminal
09:58:48 <unixer> EvanR. I am checking that out that stack exchange link. Thanks.
09:59:01 <incog> kbd controllers used to be in the kbd, but im old
09:59:08 <phadej> EvanR: good one
10:08:16 <Psybur> So this is the pairwise flip using foldr. https://pastebin.com/e4LWycfF So what foldr is doing is building up a function that takes two functions that are each a -> [a] -> [a] ?
10:10:24 <johnw> I think foldr is building a function which itself will build up a function
10:15:13 <Psybur> :t \x go c1 c2 -> c1 x (go c2 c1)
10:15:16 <lambdabot> t1 -> (t2 -> (t1 -> t3 -> t4) -> t3) -> (t1 -> t3 -> t4) -> t2 -> t4
10:15:54 <GamboPango> Is there a handy function somewhere that converts a member of some reasonable class of candidate strings to a valid Haskell type name?
10:21:35 <erisco> const "T"
10:23:07 <GamboPango> erisco: =)
10:23:35 <EvanR> names are a b****
10:24:02 <EvanR> use debruijn indices
10:24:44 <monochrom> Using regex simplification laws, b**** = b*
10:25:01 <shapr> anyone using protobuf3 in Haskell? is proto-lens the best option?
10:25:38 <EvanR> propositionally equal but not definitionally equal
10:32:12 <Psybur> Damn that ertes-w, he goes and sublimates my brain and then leaves xD
10:32:36 <johnw> he sublimated your brain? yikes
10:33:05 <Psybur> Im able to modify his dang function switching within a foldr but I just cant understand it :D
10:33:42 <johnw> Psybur: keep partial application in mind
10:33:46 <johnw> a -> b -> c is also a -> (b -> c)
10:34:01 <johnw> it's both a function of two arguments, and a mapping of a's to functions
10:34:39 <Psybur> So in the first iteration of the foldr, what are: go, c1 and c2 ?
10:36:42 <Psybur> I dont see how "mempty" could fill up go c1 c2
10:39:11 <Psybur> I guess it doesnt have to
10:40:24 <Psybur> @let funAlt x go c1 c2 = c1 x (go c2 c1)
10:40:27 <lambdabot>  Defined.
10:40:39 <Psybur> :t funAlt 1 mempty
10:40:41 <lambdabot> (Monoid t3, Num t1) => (t1 -> t3 -> t4) -> t2 -> t4
10:41:10 <cement> can I profile code I run from ghci?
10:41:18 <cement> or do I have to compile it?
10:41:40 <shapr> I think it's usually a compile option
10:41:45 <shapr> o hi cement!
10:42:09 <shapr> I'm excited that argumatronic might visit our group next week
10:42:56 <bollu> @tell quchen, ping, I wanted to discuss STG with you sometime, would you be free? :) 
10:42:56 <lambdabot> Consider it noted.
10:42:58 <EvanR> would you say "order of operations" refers to grouping (parsing), or to evaluation strategy
10:45:47 <Psybur> @let first = funAlt 1 mempty
10:45:48 <EvanR> or its referring to the amalgamation of the two as one
10:45:49 <lambdabot>  Defined.
10:45:59 <Psybur> !let second = funAlt 2 first
10:46:02 <Psybur> @let second = funAlt 2 first
10:46:03 <lambdabot>  .L.hs:174:19: error:
10:46:04 <lambdabot>      Ambiguous occurrence ‘first’
10:46:04 <lambdabot>      It could refer to either ‘Control.Arrow.first’,
10:46:30 <EvanR> i feel like the fact that they are two different things is a big "everything you know is wrong" moment from elementary school
10:48:50 <monochrom> Oh yeah Haskell forces you to separate parsing and evaluation.
10:48:54 <EvanR> f (g (h x)) and ((f g) h) x is like... at least 3 different things
10:49:20 <EvanR> depending on evaluation strategy
10:49:21 <monochrom> Actually any short-circuit scheme does. "if False then 0/0 else 1" will you really evaluate 0/0 first?
10:49:50 <EvanR> of course not, or else if could never let you avoid errors
10:50:15 <monochrom> Although, elementary school is all about strict operators and functions, so they don't need to draw the line.
10:51:16 <EvanR> in the sense that division by zero anywhere in the universe is an error everywhere
10:51:39 <WarmCookie> Hahaha. Great. I'm working on my pet asynchronous actor model based language, trying to make a way of sequencing asynchronous events in a nice manner (using futures).
10:52:03 <monochrom> This is also a major source of gotcha when people learn Haskell.
10:52:05 <johnw> mmm warm cookie
10:52:07 <WarmCookie> I basically ended up with bastardization of a Kleisli arrow.
10:52:22 <WarmCookie> Monads are everywhere -.-
10:52:25 <johnw> WarmCookie: if you're bastardizing kleisli arrows, you may want to look at categories
10:52:34 <EvanR> "everything is a monad"
10:52:51 <EvanR>  -- no one
10:52:55 <WarmCookie> johnw: Actors almost act like category objects too, it's fun.
10:53:10 <johnw> WarmCookie: https://www.youtube.com/watch?v=vzLK_xE9Zy8
10:53:12 <EvanR> almost means "not" ?
10:53:52 <WarmCookie> I haven't gone through the lengths of proving it yet,. I just now realized the similarities.
10:54:16 <johnw> WarmCookie: what I mean by suggesting that link is: if, after removing "actors" and "asynchronicity" and all the extra stuff from your language, leaves you with the lambda calculus, then why not just express your logic using lambda calculus and add in the extra bits by way of categorical interpretation
10:54:53 <johnw> Conal does this to turn plain Haskell functions into circuits
10:56:28 <WarmCookie> johnw: I'll watch it. A priori, I have something akind to lambda calculus, but a little "weaker" because I'm unable to have the variables in the order that I want, which makes partial application very annoying.
10:56:44 <WarmCookie> I was thinking to look at the Y combinator, but I think it's silly. I'm digging a rabbit hole at this point.
10:56:50 <WarmCookie> I need to reconsider what I'm doing.
10:56:58 <EvanR> use flip
10:57:19 <WarmCookie> Yeah. The thing is, while the language is very elegant, it's terribly verbose to work with.
10:57:36 <EvanR> big and beautiful
10:57:43 <WarmCookie> :)
10:58:23 <WarmCookie> johnw: Oh the talk is by conal heh, that should be fun :P
10:59:01 <cement> ok, how do I profile my code when I've got like 15 libraries imported?
10:59:15 <johnw> cement: you need to rebuild them all with profiling enabled
10:59:24 <johnw> cement: note that systems like Nix make this trivial to accomplish
10:59:37 <cocreature> tbh cabal and stack also make this trivial
10:59:44 <cement> ah, I'm using something similar to gabriel's approach with nix
10:59:48 <johnw> cocreature: fair
10:59:53 <cocreature> --profile for stack and --enable-profiling for cabal
11:00:12 <cement> I tried that one, but it didn't rebuild things
11:00:21 <bitemyapp> https://github.com/bitemyapp/katip/blob/bitemyapp/bulk-elasticsearch-scribe/katip-elasticsearch/Makefile#L13
11:00:24 <bitemyapp> this does
11:00:31 <bitemyapp> and did, rebuild things as necessary.
11:00:33 <johnw> cocreature: one thing Nix does for me is that it maintains all the profiled versions all the time, so when I need to profile a specific project, I can just switch to the profiled environment without rebuilding anything at that moment
11:00:46 <cocreature> johnw: new-build does that as well :)
11:00:54 <johnw> cocreature: ohh, nice! I didn't know that
11:01:06 <cocreature> johnw: nix has benefits for sure, I just don’t think this is a particularly compelling one :)
11:01:17 <monochrom> Actually does new-build build profiling libraries?
11:01:35 <bitemyapp> Stack caches profiling versions of libraries separately
11:01:45 <bitemyapp> You can switch between profiling and non-profiling without rebuilding the universe.
11:01:58 <cocreature> bitemyapp: it doesn’t cache things for inplace packages iirc
11:02:28 <bitemyapp> No, it does
11:02:41 <bitemyapp> the extensible snapshot support includes extra-deps, in-place packages.
11:02:58 <cocreature> oh did that change? I’m fairly sure I’ve seen some mass rebuilds when switching between profiling and non profiling builds
11:03:02 <bitemyapp> It changed, yes.
11:03:05 <cocreature> nice
11:03:08 <cement> I really just need the nix expression, tbh. I'm already using nix for this
11:03:19 <bitemyapp> cocreature: so, local packages and extra-deps become part of ad-hoc, implicit snapshot
11:03:27 <bitemyapp> and then it's able to cache profiled/non-profiled, etc. versions of them separately
11:03:32 <bitemyapp> rather than only caching them in-place.
11:04:15 <WarmCookie> All this work on my compiler and everything makes me think maybe all I want afterall is the actor model on top of Haskell (which is fairly trivial to implement).
11:04:26 <WarmCookie> Oh, that and a tricolor concurrent garbage collector.
11:04:54 <bitemyapp> Many Haskellers don't think actor models are a good way to model concurrent applications, but stuff like Cloud Haskell is out there if it's anything like what you want.
11:05:08 <johnw> bitemyapp: how do you know that?
11:05:20 <bitemyapp> Because usually async and the various containers get used
11:05:31 <johnw> I use async to implement my use of the actor model :)
11:05:33 <bitemyapp> I used to participate in a community that more broadly wanted Actor-style concurrency (Clojure)
11:05:39 <bitemyapp> and there was a lot more Actor LARP'ing there
11:05:42 <monochrom> bitemyapp knows because he took a poll and I answered.
11:05:56 <bitemyapp> an alternative hypothesis you could draw is that Haskellers LARP/experiment less and I doubt that's the case.
11:06:12 <johnw> what is actor LARP'ing?
11:06:14 <bitemyapp> I'd like a Java CMS-style collector for GHC Haskell but I've been able to avoid strictly needing it. More of a nice-to-have.
11:06:28 <WarmCookie> I have read a couple articles that seems to support bitemyapp's claim. It seems actors encourages isolation as opposed to the more traditional composition.
11:06:37 <WarmCookie> Do they have to be mutually exclusive though?
11:06:48 <johnw> WarmCookie: I don't think so
11:06:49 <bitemyapp> not really, you can do what you want.
11:06:54 <bitemyapp> Haskell has good concurrency kit, you can make what you want.
11:07:03 <bitemyapp> My point is that something that fits precisely what you want is unlikely to already-exist.
11:07:09 <bitemyapp> We don't have pulsar in Haskell, for example.
11:07:13 <bitemyapp> https://github.com/puniverse/pulsar
11:07:29 <bitemyapp> but we do have async, channels, etc.
11:07:58 <bitemyapp> I've had problems with a lot of the channel containers and have gotten wary of them. TBMQueue's propensity for live-lock is not merely hypothetical, I trip over it in benchmarks regularly.
11:08:14 <bitemyapp> I am made less unhappy by TVar, unagi-chan, MVar, IORef.
11:09:02 <bitemyapp> it's quite possible to spawn up little workers and have them communicate via channels. I do it all the time, but having a couple worker threads and some channels or MVars for communication doesn't seem like "actor model" as I understood it in Clojure and Scala.
11:09:12 <bitemyapp> neither in the form of Clojure's agents, Akka, or pulsar.
11:10:11 <phadej> MVar is way lower-level.
11:10:38 <phadej> but I don't see an obstacle of building something like Akka in Haskell, you just have to do it.
11:11:08 <bitemyapp> no obstacle, I'm suggesting some reasons why something like pulsar or Akka might not already exist in Haskell
11:11:46 <bitemyapp> also I was mentioning MVar in the context of, "this isn't actors", so objecting to its inclusion as, "those are way lower-level" supports my point.
11:12:23 <phadej> well, we have STM which isn't that popular in Scala world. It different way to building concurrent apps
11:12:35 <monochrom> People are simply context-free.
11:15:45 <WarmCookie> brb tonight
11:46:51 <mutantmell> my scala team has been moving more and more towards monix (Lazy Futures) and away from actors
11:49:23 <phadej> and we don't have lazy futures in Haskell, because: green threads and async.
11:50:15 <mutantmell> Right, I mostly treat it as analogous to IO
11:51:23 <phadej> well, sometimes you want to spawn n operations concurrently, and then wait for all of them
11:51:30 <phadej> for that you'll use `async`
11:51:40 <phadej> (and not reinvent yourself)
11:52:04 <mutantmell> Oh for sure
11:52:30 <johnw> I think we need more techonlogies that make us sound crazy when we're overhead in a cafe.  "I'm into lazy futures now."
11:52:51 <phadej> or then you can go haxl-way, i.e. more boilerplate for I/O itself, but then "easy conurrency"
11:53:05 <phadej> i guess there are libs for Scala too
11:53:24 <phadej> (IIRC simonmar mentions some in his strangeloop talk, google for it, it's good)
11:53:37 <phadej> disclaimer: I'm haxl fanboy
11:53:58 <mutantmell> scala isn't purely functional, so the divisions are looser in the libs
11:54:13 <mutantmell> *in the more functional libs
11:57:22 <Ero> hey all
11:57:58 <johnw> Ero: hiya
11:58:13 <Ero> I get bottoms usage in haskell. i was wondering if someone could point me to an explanation for bottom/top in terms of logic? (searching for this is really hard)
11:58:18 <Ero> hi johnw how have you been?
11:58:32 <johnw> Ero: good, writing some Haskell today, so fun too
11:58:49 <Ero> awesome :)
11:58:56 <Ero> what have you been writing?
11:59:08 <johnw> Ero: code that uses Z3 to solve a constraint model
11:59:16 <Ero> woah
11:59:30 <Ero> i dont know what that is :D
11:59:46 <koz_> Z3 is what's called an SMT solver.
11:59:56 <Ero> oh
12:00:11 <Ero> i saw SMT#s mentioned in the logic proof ebook im reading
12:00:20 <Ero> i dont know what they are yet though
12:00:24 <koz_> You can feed it a (suprisingly large) fragment of first-order logic (or rather, a statement in it) and it'll tell you if it's valid (or give a counter-example if not).
12:00:30 <johnw> "In constructive logic, ⊥ or false is the bottom element in the poset of truth values."
12:00:34 <Ero> in logic proofs, bottom is null, is that right/
12:00:44 <Ero> oh
12:01:29 <Ero> poset of truth values? Now i have some vocab to latch onto the rest should be easy. Thanks
12:01:31 <johnw> in Haskell you can determine a lattice of defineability for the values of any type, and ⊥ is the ⊥ of this lattice
12:01:47 <johnw> https://stackoverflow.com/questions/6379458/the-concept-of-bottom-in-haskell
12:01:50 <Ero> thannks
12:02:01 <Ero> i love this channel
12:02:10 <koz_> johnw: So it's the meet of that lattice?
12:02:34 <koz_> Or am I getting my terms crossed?
12:02:39 <johnw> the infinimum, I think
12:02:50 <koz_> Ah, right, that's what I meant. Is there a supremum?
12:02:51 <johnw> er, infimum
12:03:03 <johnw> I don't think so, not in the lattice of definedness
12:03:27 <johnw> that would mean a single "most defined" value for every type
12:03:39 <koz_> johnw: Yeah, that makes sense.
12:03:44 <johnw> but every fully-applied constructor introduces an equally well-defined value
12:09:29 <johnw> Ero: another, more logical connection: https://ncatlab.org/nlab/show/falsehood
12:09:52 <boothead> Hi folks, I'm looking for a bit of help creating Constraints from type level lists can anyone point my in the right direction?
12:16:58 <cocreature> boothead: can you be a bit more specific? do you already have some code sample?
12:17:27 <tinco> hey people, what do you think about the readability of Haskell code? I have a feeling the code I'm writing stops making sense the second I move to a new problem to solve
12:17:53 <tinco> I'm not saying it's necessarily a bad thing, because it's all so nice and pure and well defined, it doesn't really need to be maintained in the classic sense
12:18:21 <tinco> if some function is buggy or nonperformant, you can just tear it out and rewrite it, my functions are never really bad
12:18:29 <tinco> eh s/bad/big
12:20:04 <boothead> cocreature: specifically I have a list like this '["labela" ::: a, "labelb" ::: b] and I want to generate a Constraint that for each element in the list some record type HasField label record (typ -> c) (HasField from here https://hackage.haskell.org/package/generic-lens-0.4.0.1/docs/Data-Generics-Product-Fields.html#t:HasField)
12:20:14 <sm> tinco: I find the overall code can be quickly re-understood. Complicated functions are always hard to matter what, but at least the complexity is confined
12:20:22 <sm> s/to matter/no matter/
12:20:53 <boothead> So in the case above I'd end up with (HasField "labela" r (a -> c), HasField "labelb" r (b -> c))
12:21:02 <sm> tinco: assuming straightforward types, etc. If you go crazy with haskell's power, all bets are off
12:21:29 <boothead> I'm not sure that even makes sense to ask to do, I'm pretty new to type level programming
12:22:01 <cocreature> boothead: should be relatively straightforward to write a type family for that
12:22:17 <cocreature> basically just recurse on the list like you would for a value level function
12:22:45 <boothead> cocreature: Yes, I've started there, but I don't know how to combine the contrainsts together..
12:23:01 <cocreature> boothead: tuples
12:23:18 <cocreature> you’ll end up with (…, (…, (…))) but that works just fine
12:23:32 <boothead> ahhhhhhh! Thanks cocreature :-)
12:23:50 <tinco> sm: yeah that rings true to me
12:26:50 <Psybur> Whats the best way to get the last element of a Seq ?
12:26:50 <boothead> cocreature: is there a way to evaluate the Constraint?
12:27:15 <cocreature> boothead: what do you mean by “evaluate the constraint”?
12:30:07 <boothead> I mean call the type family on some types and see if it all works.. I guess just try to compile and look at type errors?
12:30:37 <Psybur> I believe using viewr and then pattern matching is the way?
12:30:45 <Psybur> Surprised theres no builtin last that I can find
12:31:17 <cocreature> boothead: you can use "kind!" in ghci
12:32:33 <boothead> Cool, thanks again for the help :-)
12:33:30 <geekosaur> Psybur, you want the pattern
12:34:01 <yilinwei> Hello, is there anywhere which gives a good introduction of language pragmas in haskell?
12:35:43 <Hafydd> yilinwei: <https://www.haskell.org/onlinereport/haskell2010/haskellch12.html#x19-18800012> for Haskell 2010 pragmas; <https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/lang.html> for GHC language extensions.
12:36:02 <yilinwei> Hafydd Thank you very much.
12:37:29 <Psybur> geekosaur, how would I use the pattern for that? Best I can seem to get is (_ :> x) = viewr s
12:38:09 <Psybur> I suppose I dont need viewr if I use :|> ?
12:38:23 <geekosaur> x should be bound to the last item in the Seq
12:38:43 <Younder> The following was an interesting read: https://research.utwente.nl/en/publications/functional-programming-with-bananas-lenses-envelopes-and-barbed-wire
12:38:45 <geekosaur> it's like (x:xs) but reversed
12:39:09 <geekosaur> (xs :|> x)
12:39:48 <Psybur> geekosaur, hmm I get Data.Sequence does not export :|>
12:40:08 <geekosaur> what version? I was looking at the one that ships with 8.2.1
12:40:38 <geekosaur> containers-0.5.10.2
12:42:10 <geekosaur> right, they were added in 0.5.10, in 0.5.9 and earlier you have to use viewr
12:42:47 <Psybur> Im using 8.0.2 so I guess I dont get to use that version :{
12:43:39 <Psybur> Lets see if I can bump up to lts-9.10 without issue :D
12:43:54 <Psybur> oh geez, thats a lot of crap to compile >.>
12:44:43 <Psybur> And I dont think it will matter since thats still 8.0.2
12:44:46 <Psybur> Whoops :D
12:46:10 <geekosaur> it is not impossible to upgrade containers on 8.0.2. it does create some limitations in template haskell
12:56:21 <felix1> i find myself writing a `{To,From}PathPiece` instance for a large ADT and I have to repeat the string in the from/to over and over again. I wonder if there's a way to write this w/o duplicating the string literals
12:57:29 <felix1> https://pastebin.com/fe8nePsv
12:58:00 <felix1> ^ there's just too much room for human error in the implementation above
13:00:11 <drdo> Is there a library to handle associating threads and resources with objects? Including handling all the nasty business of resource ownership handover and cleanup in the presence of async exceptions and so on?
13:00:44 <phadej> felix1: https://github.com/futurice/haskell-futurice-prelude/blob/master/src/Futurice/Generics/Enum.hs#L100
13:01:08 <phadej> felix1: essentially, write `toText`, and use that to make a map to use in `fromText`
13:01:34 <phadej> felix1: for big enough ADT it can be even faster (log n, vs n - constrant factors though)
13:01:48 <ph88^> hey guys, i want to put my program on github i'm looking at https://choosealicense.com but i still don't have a clue which license to choose .. anyone have a suggestion ?
13:02:35 <drdo> ph88^: Well, what do you want your license to do?
13:02:44 <phadej> ph88^: it's really hard to simplify from that
13:02:44 <ph88^> dunno
13:03:05 <drdo> Then pick WTFPL
13:03:11 <ph88^> wut ?
13:03:16 <phadej> don't pick that
13:03:22 <phadej> pick MIT or BSD-3-Clause
13:03:29 <phadej> WTFPL it's too much tongue-in-cheak
13:03:45 <phadej> and it's not OSI approved
13:04:08 <ph88^> i want to be credited for my work at all times, i don't want to be hold liable or give any warranty .. other than that i don't really care that much
13:04:15 <ph88^> but all those licenses seem to have that
13:04:31 <sm> ph88^: GPLv3+ gives you most protections, and can be relaxed later (if you maintain copyright)
13:05:38 <ph88^> why would i want to relax it ?
13:05:42 <ph88^> maybe i want to do that right away
13:08:30 <dmwit> "I want to be credited for my work at all times" doesn't sound like something the licenses I'm familiar with mention.
13:09:14 <dmwit> Well. I guess it depends on what you mean by "credited for my work".
13:09:41 <ph88^> refer back to the source when they use the source code
13:10:20 <ph88^> copyright notice
13:10:56 <Tuplanolla> My personal guideline is to put everything under GPL unless I'm paid to put it under BSD.
13:11:06 <eacameron> Can anyone recommend a good lib for URL encoding?
13:11:31 <Psybur> @src take
13:11:31 <lambdabot> take n _      | n <= 0 = []
13:11:31 <lambdabot> take _ []              = []
13:11:31 <lambdabot> take n (x:xs)          = x : take (n-1) xs
13:11:57 <dmwit> I know the CC licenses have an option to require attribution that might meet your needs. I don't think many people use CC licenses for code, though. (I don't know why.)
13:12:34 <Tuplanolla> They don't waive liability, dmwit.
13:13:52 <dmwit> eacameron: I think http://hackage.haskell.org/package/http-types-0.10/docs/Network-HTTP-Types-URI.html is pretty often used
13:14:04 <kadoban> dmwit: https://creativecommons.org/faq/#Can_I_use_a_Creative_Commons_license_for_software.3F even they don't recommend it
13:14:05 <ph88^> where do i put the actual copyright notice ?
13:14:40 <kadoban> cc0 seems to be the only one they say is okay for software
13:18:02 <felix1> phadej: thanks!
13:18:18 <ph88^> should compiler flags or copyright notice come first ?
13:19:50 <eacameron> dmwit: Thanks. That looks nice
13:19:55 <dmwit> Not many documents would contain both of those things. A cabal file, maybe, in which case it doesn't matter; some certification documentation, maybe, in which case read the requirements of the certification.
13:20:38 <ph88^> dmwit, are you talking to me ?
13:20:41 <dmwit> yes
13:20:50 <ph88^> not in the source file then ?
13:21:08 <dmwit> ah
13:21:25 <dmwit> If you're goin to put a notice in every file, put it before everything else.
13:21:33 <ph88^> i don't want to actually
13:21:38 <ph88^> it looks stupid
13:22:07 <ph88^> what's the difference between synopsis and description in the cabal file ?
13:22:47 <kadoban> ph88^: Length and detail
13:23:00 <hexagoxel> synopsis is one-liner, description may be long
13:42:47 <sm> don't forget to reference your readme, changelog, repo and issue tracker too :)
13:47:21 <EvanR> i have a domain theory question
13:48:13 <raynold> ahh it's a wonderful day
13:56:50 <johnw> EvanR: just ask :)
13:56:50 <greymalkin> nix+cabal problem -- FFI to openssl is not finding crypto; even though it's in the environment (and available through LD_LIBRARY_PATH).
13:57:03 <johnw> greymalkin: define "not finding"?
13:58:05 <greymalkin> cabal: Missing dependency on a foreign library:
13:58:06 <greymalkin> * Missing C library: crypto
13:58:46 <johnw> LD_LIBRARY_PATH applies at runtiem
13:58:51 <johnw> you need to pass the right -L flag to cabal
13:59:17 <johnw> --extra-lib-dirs=<PATH>
13:59:31 <greymalkin> Ah -- yes; So nix-build must be adding them automatically.
13:59:39 <johnw> indeed it does :)
13:59:47 <greymalkin> (it's `cabal configure` within the nix-shell environment that was bailing on me)
14:00:06 <johnw> I use this: nix-shell --comand 'cabal configure' && cabal build
14:00:29 <johnw> strange that it wouldn't find crypto though
14:00:37 <EvanR> the definition of x way below y, where x and y are elements of some domain: for all directed subsets A where y <= lub A, there is a z in A such that x <= z. ok...... theorem, x way below y implies x <= y. but what if A is like y <= x <= z <= lub A, how is that ruled out
14:01:16 <greymalkin> johnw: Yes, that is exactly the command I'm using.
14:01:34 <greymalkin> Had to break it down to just nix-shell --command 'cabal configure' to find out that that is where the error is.
14:02:04 <johnw> try adding '-v -v -v' to your cabal configure
14:02:12 <johnw> see if the crypto path is there
14:03:39 <greymalkin> first, I'm going to try upgrading cabal2nix -- looks like it's been a while since I've done that.
14:04:58 <monochrom> Is "-v -v -v" the same as "-v3"?
14:05:31 <johnw> maybe, never tried it
14:06:30 <monochrom> EvanR: I think it's simply about "for all directed subsets" vs "for some directed subset".
14:06:53 <EvanR> i considered that, but if one subset doesnt work, that is still aproblem for "all"
14:07:06 <johnw> greymalkin: btw, it might be better to continue this discussion in #nixos, since this isn't a Haskell problem
14:08:28 <monochrom> I don't understand what you mean by "one subset doesn't work".
14:09:03 <EvanR> an A such that here are 4 items in order... y <= x <= z <= lub A
14:09:34 <EvanR> satisfying the way below, it seems though i have to be wrong, yet x <= y doesnt seem right
14:09:50 <monochrom> No. You haven't checked a lot of other directed sets.
14:12:32 <monochrom> At this point it looks like you're conflating "(for all A. condition) implies x<=y" with either "forall A. (condition implies x<=y" or "(exists A. condition) implies x<=y" or both.
14:15:35 <monochrom> If you're looking at a lattice of 4 elements with y<x<z<top, then the directed subset {y} dissatisfies: there exists z in {y} s.t. x<=z
14:15:39 <Boarders> just use the directed subset of y on its own
14:15:45 <monochrom> Yeah.
14:15:45 <Boarders> (beat me to it)
14:15:56 <monochrom> So the part about "forall A. condition" is false.
14:16:07 <monochrom> So x is not way below y.
14:16:49 <Boarders> also surely you can just prove this by using the constant directed subset of y on its own
14:17:13 <EvanR> ok
14:17:38 <EvanR> its ruled out because theres another subset that precludes being way below
14:18:04 <fishythefish> there's a bit of mixed notation here, too
14:18:17 <fishythefish> is A your entire domain, or just your directed set?
14:20:59 <EvanR> a subset
14:21:52 <EvanR> how does {y} not rule out x <= y <= z <= lub A
14:22:05 <fishythefish> Why should it?
14:22:20 <EvanR> ah z = y
14:23:41 <EvanR> the definition of way below still seems really mysterious
14:24:28 <fishythefish> As in why it's called "way below"? Or would examples help?
14:25:05 <EvanR> sure
14:25:47 <fishythefish> Consider the usual subset partial order on sets
14:26:08 <fishythefish> any infinite set is way above any of its finite subsets
14:26:56 <EvanR> but a fininte subset is not way below a finiinte superset?
14:27:20 <EvanR> thats fine but connecting that example with the definition is still hazy
14:31:58 <harpocrates> I know types/parametricity help document code, but stuff like this is not particularly helpful https://github.com/ghc/haddock/blob/3fddb62913c72f29843335aa796c2e444ded1608/haddock-api/src/Haddock/Backends/Xhtml/Decl.hs#L710-L714 
14:32:01 <fishythefish> so the reason it's "way below" and not just "below" is that we're not even comparing x to y directly
14:32:51 <fishythefish> we can take *any* directed subset whose supremum is >= y (even one not containing y itself), and x will *still* be <= one of the elements of that subset
14:33:09 <EvanR> yeah i just noticed that
14:33:49 <EvanR> but i dont see how that is wayer than normal
14:34:15 <EvanR> i guess it really only makes a difference infinities and dense stuff
14:34:21 <EvanR> with*
14:36:56 <EvanR> whats an example of being below but not way below
14:37:29 <fishythefish> take any infinite subset of the natural numbers
14:37:33 <fishythefish> it's below N but not way below N
14:37:50 <fishythefish> to see this, consider the directed chain {0}, {0, 1}, {0, 1, 2}, ...
14:38:00 <fishythefish> sup of the chain is N itself
14:38:57 <EvanR> i see all evens wont be way below because theres no z in that chain
14:39:37 <EvanR> same with all numbers greater than 3
14:39:52 <EvanR> ok
14:40:15 <EvanR> thats kind of funny
14:42:29 <dsal> Looks like I wasn't the first to think of that particular quickcheck failing:  https://github.com/nick8325/quickcheck/issues/98 -- though the modifier mechanism for weighing particularly suspect values is kind of interesting, it's a bit unfortunate it avoids such values by default.
14:42:46 <EvanR> i still dont see how the definition leads to this intuitive picture
14:42:51 <fishythefish> to address your earlier point, "way below" for the subset partial order just means "finite subset of", whether the superset is infinite or not
14:43:05 <fishythefish> it's just that this stuff only gets interesting in the infinite case
14:43:06 <EvanR> all evens is not  way below N, but the technical reason still seems mysterious
14:43:34 <fishythefish> well, are you familiar with the approximation order in any other context?
14:43:45 <EvanR> no, thats what im trying to learn about
14:44:28 <fishythefish> maybe start with https://en.wikibooks.org/wiki/Haskell/Denotational_semantics
14:48:36 <EvanR> all directed subseets where y <= lub A, not even necessarily containing y... but your example illustrates y doesnt even need to be below anything in A heh
14:48:47 <EvanR> in the case its is lub A
14:54:49 <fishythefish> yeah, you can think of sup A as being a kind of "upward limit" of the elements of A
14:54:57 <fishythefish> the relevant case tends to be when y = sup A
14:58:14 <lyxia> harpocrates: how is this not helpful
14:58:43 <EvanR> in some sense i see evens as not being "inline" with N, as with my other way below examples, which are admittedly finite
14:59:10 <EvanR> in a diagram of the ordering
14:59:51 <EvanR> so youd say evens "doesnt approximate" N ?
15:03:38 <cement> is it normal for mapConcurrently to (briefly) take up a large amount of memory?
15:06:20 <cement> nevermind, answered hat for myself
15:06:27 <cement> s/hat/that
15:06:50 <dsal> "Yes, lots of things take up unreasonably large amounts of memory."  ? :)
15:07:28 <EvanR> memory bang
15:07:38 <dsal> mallocwang
15:08:35 <cement> "Yes, the approach I'm using can spawn some millions of threads at once, and each one takes up a non-zero amount of memory"
15:09:35 <EvanR> and an infinite set is not way below itself because of a chain of finite sets that has it as a supremum
15:10:06 <EvanR> and itself isnt one of them
15:10:36 <EvanR> so you would say it doesnt approximate itself haha
15:10:40 <fishythefish> EvanR: yes, evens does not approximate N
15:11:09 <EvanR> actually im not sure if a chain of finite sets will always work for that argument
15:11:31 <fishythefish> an element that is way below itself is called compact, and the compact elements under the subset partial order are the finite sets
15:12:28 <fishythefish> the argument I outlined demonstrates that no infinite set is way below N
15:13:33 <EvanR> N being the whole domain here?
15:13:48 <EvanR> or all infinite sets ever are not way below themselves
15:14:07 <fishythefish> no, N being the set of natural numbers, which is an element of the domain of sets
15:14:37 <fishythefish> I'm only talking about the subset partial order here
15:14:50 <johnw> does anyone know of code in Haskell for doing loop shifting and compaction?
15:14:53 <fishythefish> In the case of this partial order, the relation "is way below" is the same as "is a finite subset of"
15:15:21 <EvanR> how does that argument work for an uncountable set
15:15:40 <fishythefish> an infinite set could be way below some other set, but *not wrt this order*
15:15:53 <fishythefish> which argument?
15:16:48 <EvanR> consider the chain {} {0} {0,1} ...
15:17:27 <fishythefish> you can't have an uncountable subset of N
15:18:36 <monochrom> fishythefish's domain is P(N).
15:19:26 <fishythefish> ah, yeah, should have made that explicit
15:19:58 <fishythefish> that said, you can enlarge the domain and the argument still holds: for a set to be way below N, it must be a subset of N
15:20:13 <fishythefish> so you can disregard uncountable sets anyway
15:25:56 <EvanR> this is annoying, the pdf i am readying did not defined compact element
15:26:04 <EvanR> but asks to identify them in an exercise
15:27:21 <fishythefish> basically, a compact element c is one such that if c <= sup S for some (nonempty) directed set S, then S must already contain elements above c
15:42:18 <Gurkenglas> Wouldn't c always be equal to the supremum of the set of elements s with s <= c, which contains no elements above c?
15:43:02 <monochrom> Yes, but it's tangential.
15:45:41 <fishythefish> Restricting to algebraic settings, compact elements are the finitely generated substructures
15:46:51 <fishythefish> Otherwise, you can have c = sup S, with all elements of S below c
15:47:20 <fishythefish> e.g. with S an approximating sequence ot c
15:47:21 <fishythefish> to*
15:48:11 <fishythefish> (strictly below c, I should say)
15:59:49 <Denommus> do you guys know of a free cloud service like Heroku that runs Haskell?
16:00:37 <nshepperd_> fishythefish: is this a generalization of the idea of a compact set?
16:01:41 <nshepperd_> The finite subcover definition
16:02:27 <fishythefish> nshepperd_: it's an example of it
16:03:02 <fishythefish> pick a topological space and consider the complete lattices of open sets with order given by subset inclusion
16:03:24 <fishythefish> then compact elements of the lattice are just the compact sets
16:03:31 <fishythefish> (er, yeah, generalization, not example)
16:06:50 <Gurkenglas> Would a probabilistic totality checker be robust to diagonalization?
16:08:07 <fishythefish> nshepperd_: the poset of open sets happens to be a join-semilattice, and an element c of a join-semilattice P is compact if for every nonempty subset S of P, if sup S exists and c <= sup S, then there exists a finite subset T of S such that c <= sup T.
16:08:29 <fishythefish> This translates immediately to the finite subcover definition
16:10:45 <Eduard_Munteanu> Denommus, Amazon and Google give you a 1-year or so trial. No explicit Haskell support, but you can run a VM instance with whatever you need.
16:15:33 <Psybur> Is that ertes without his -w?! Dont think Ive seen that before!
16:16:15 <Psybur> Guess that -w means work? :D
16:16:28 <geekosaur> left the wok at work >.>
16:20:17 <na2th>  
16:23:31 <mniip> -w means no wallops
16:24:34 <geekosaur> in a nick?
16:25:28 <fishythefish> i thought -w was the wumbo flag
16:32:26 <mniip> geekosaur, I am providing misleading information for reasons of humor
16:55:29 <ertes> =)
16:56:27 <ertes> the "-w" means that i'm in comonadic mode
16:56:37 <monochrom> onoes
17:02:27 <jkachmar> Anyone know why `-fwarn-incomplete-uni-patterns` isn't turned on as part of `-Wall`?
17:03:18 <jkachmar> It's _incredibly_ useful, esp. for catching stuff like `let Just a = Nothing`, but it's really easy to miss.
17:05:32 <geekosaur> (so ertes-w is extend-ed?)
17:10:32 <MarcelineVQ> the cases not covered by -Wall are things that sometimes you really do intend to do and might not want the compiler complaining about, yet still want all the other warnings for things a person shouldn't intend. I wouldn't mind some kind of -Weverything myself though
17:13:01 <jkachmar> MarcelineVQ right, I get that for _most_ of the things that -Wall doesn't cover
17:13:27 <jkachmar> -incomplete-uni-patterns kinda baffles me though, that one seems like an obvious-footgun-avoidance-option
17:14:42 <MarcelineVQ> yes, something like  -Weverything -Wno-incomplete-uni-patterns  would be a good option for those people who enjoy danger
17:14:45 <nshepperd> "-Wall" more like -Wsome
17:15:08 <jkachmar> -Wmaybethiswontblowup
17:15:28 <MarcelineVQ> nshepperd: -Wmost :>
17:15:29 <jared-w> I think it was, at some point, actually 'all' and then more fun things got added and of course nobody wants to add it to the 'all' because you might break backwards compatible builds and so on
17:15:39 <jkachmar> -Wyolo - only turn on the useless ones
17:16:24 <nshepperd> If people are using -Wall and -Werror at the same time, I think breaking their build is Justice
17:16:32 <fishythefish> perhaps because `let Just a = ... in a` is a common enough pattern to force some kind of unwrapping?
17:16:54 <jkachmar> `let Just a = Nothing` <-- dis tho
17:17:18 <jkachmar> BAM, now your lang has `null`, RIP in peace
17:17:22 <fishythefish> I understand that that fails, but if I write something like what I said, it's essentially an assertion that I should only be getting a Just
17:17:49 <jared-w> And I would hope that if I assert something stupid that the compiler would call me stupid :)
17:18:05 <geekosaur> I think the problem is it also catches \(Just a) -> ... which is (perhaps sadly) a common idiom
17:18:54 <nshepperd> right, people write 'let Just a = _' for various values of _ all the time, usually intentionally. so warning about it isn't that great
17:19:00 * jared-w thinks that if \(Just a) burns at the stake, it's for a... *just cause*
17:19:09 <monochrom> Haha
17:19:17 <monochrom> onoes everything is -w now
17:19:24 <jkachmar> nshepperd people who write that need to be told not to write that
17:19:36 <jkachmar> Or turn -Wall off
17:20:05 <jared-w> Haskell prefers to hold peoples hand by giving them incomprehnsible error messages and being explody-happy. I kinda like that :)
17:20:10 <nshepperd> let First (Just x) = foldMap (First . Just) list_that_is_not_empty
17:20:30 <jared-w> It's actually weird programming in a language like Curry where you don't always /want/ exhaustive pattern matching and you sometimes want overlapping patterns
17:21:08 <jkachmar> I don't think people should be disallowed from doing it, just that -Wall should tell you off for it.
17:21:58 <nshepperd> warnings should have a high probability of being signal rather than noise
17:22:03 <nshepperd> otherwise people ignore them
17:22:11 <geekosaur> enh. the idiom is normally used when the programmer has done something that is morally isJust and doesn;t want to add extra code that won't be used
17:22:44 <jkachmar> Sure, but I'd argue that introducing a runtime-exception-happy pattern is high signal
17:23:41 <slack1256> any blogpost studying an example of how to reduce allocation ? I ask because this discussion https://www.reddit.com/r/haskell/comments/78tnq7/haskell_for_high_performance_game_engines/ 
17:23:51 <htse> hi everyone, I'm trying to learn me haskell, have plenty of experience in imperative languages but I'm trying to run a map over an array of strings, which works with functions like reverse but not with my own construct, then it complains about incorrect type Char vs array [Char]
17:23:54 <slack1256> not that I have a problem, but seems good to know
17:23:59 <htse> my code is https://pastebin.com/5sRPY8i0
17:24:14 <jkachmar> It's not that much effort to create a `RadioactiveDumpingGround` module and shoving those in there with a `-fnowarn-incomplete-uni-patterns` option up top
17:24:24 <nshepperd> jkachmar: it won't be high signal until we write in Idris
17:24:28 <htse> I'd appreciate any pointers
17:24:53 <jared-w> slack1256: In what case? Reducing allocations in normal code? Or reducing allocations in a theoretical sense of what the compiler is capable of?
17:25:08 <slack1256> on normal code
17:25:16 <jkachmar> slack1256 I think Chris Done posted an example in the comments of how one would do that
17:25:21 <jared-w> htse: thanks for the excellent paste :)
17:25:41 <geekosaur> htse, it's just as well, your first definition for invert would be an infinite loop
17:25:43 <jkachmar> Yeah, this: http://chrisdone.com/posts/fast-haskell-c-parsing-xml
17:26:00 <htse> ah, really? :/
17:26:18 <geekosaur> invert l "" will match invert l _
17:26:34 <geekosaur> so it will do invert l "" again, which will match invert l _ again, ...
17:26:46 <geekosaur> also that 'do seems out of place and is likely the cause of your issue
17:26:57 <htse> oh so value empty array equals value nil? :o 
17:27:15 <htse> do I have to regard it as in erlang where _ is just 'ignore this'?
17:27:20 <geekosaur> _ is a wildcard, not nil
17:27:22 <jared-w> The pattern match for an empty string is [], because strings are just lists of characters :)
17:27:27 <geekosaur> it matches anything and ignores the value
17:27:51 <geekosaur> yes, like erlang
17:27:53 <htse> yeah I'm stumped at that, I actually tried map on the string first, thinking it'd be an array
17:28:10 <geekosaur> as for te second case, I'm not sure what you think that code is supposed to do.
17:28:14 <htse> but that was nonono so I tried something else
17:28:31 <htse> I'm inverting my 'picture' so every # becomes . and vice versa
17:28:41 <geekosaur> the 'do' in this context makes it a list monad operation, which is probably where your type error comes from
17:28:51 <htse> ah
17:28:53 <geekosaur> nds where do you think the result of the 'if' goes?
17:28:58 <geekosaur> *and where
17:29:15 <htse> ah yes here if returns a value
17:29:24 <htse> so used to it not doing that :s
17:30:14 <jared-w> It's probalby best to think of the if/then/else in Haskell as the literal ternary operator written out in english
17:30:40 <jared-w> (which is much more true to reality than the boolean branching of imperative languages)
17:30:50 <htse> every thing I saw so far just sprinkled in where and do to have multiple statements so I thought it was a sort of indicator to the compiler. Guess I need a better or good book. :/
17:31:15 <jared-w> My favorite book is Haskell Programming from First Principles
17:31:20 <geekosaur> it's not just 'multiple statements please'
17:31:56 <geekosaur> working in a monad, you have a context where a 'multiple statements' style can be useful.
17:32:14 <htse> why does map choke on my custom function with my similar value and not on reverse? because reverse takes [a] any and it gets transformed into what map needs?
17:32:28 <geekosaur> but what it actually means depends on the monad; in the list monad, it executes the following 'statements' on each item in the input list 'in parallel'
17:33:22 <jared-w> htse: probably because of the do. You can write invert in a very clean and normal style without needing do notation or monads at all
17:34:04 <geekosaur> i.e. 'do' is not doing what you think it is, and is changing the type
17:34:21 <geekosaur> you cannot use it just to get 'I want to pretend I have multiple statements instead of expressions'
17:34:38 <htse> I understood that, no sure how to give it a 'block' then but I'm no doubt thinking too imperatively. :)
17:34:44 <geekosaur> you are
17:35:18 <geekosaur> Haksell is *always* expressions. even with do 'statements' it's making expressions joined by the >> operator
17:35:39 <geekosaur> and now what you meant will be determined by what >> (or, more usually, >>=) does
17:35:40 <monochrom> The imperative thinking makes no sense here. What do you mean "compute this list concatenation and then go on to discard it"?
17:37:11 <htse> you're right I needed to double my invert call but I'm so used to assigning and not double the call :D
17:37:20 <htse> and no doubt neither would be right here
17:37:26 <monochrom> I'm also altogether skeptic of the arity of invert.
17:38:17 <monochrom> If you want "map invert p" to have type [String] then invert has to have type String->String, i.e., takes exactly one parameter, and its a string parameter. No more no less.
17:42:09 <jared-w> htse: http://lpaste.net/359566  does this help?
17:42:55 <jared-w> (I didn't run the code so it might be wrong, but I think the general gist is what you were wanting)
17:43:30 <jared-w> Hopefully this should give a bit more context to all the advanced stuff everyone was going on about :)
17:44:19 <monochrom> Yeah I think this does it.
17:44:36 <jared-w> (btw: Your first error was that your invert function was taking two arguments, but when you used it in map, you said it only used one argument)
17:44:51 <monochrom> And then you realize that invert can also be rewritten as a "map ???"
17:45:14 <htse> I tried the map it failed 
17:45:29 <jared-w> Try from my code and then see if you can rewrite invert as a map ;)
17:45:41 <htse> this has the same "    • Couldn't match expected type ‘Char’ with actual type ‘[Char]’
17:45:57 <htse> I'll check it out and see if I can get it working
17:46:28 <jared-w> (hint: map takes a function (a -> b) and runs it over the list, so your function in this case would be a function that took a character and if that character is a '#' or a '.', do something, otherwise leave the character alone)
17:46:28 <htse> I find the verbosity of the compiler actually hard to deal with :P
17:46:51 <htse> I know, that's what I figured, I did, and compiler said no
17:46:57 <jared-w> It gets better as you learn to read it, and the error messages are much better with GHC 8.2.1 and later, but they still need a lot of work
17:46:59 <htse> and then I made my monstrosity
17:47:10 <monochrom> Well yeah because there is a vocal minority of people who cry that the error messages are not long enough.
17:47:45 <fishythefish> htse: [Char] is the same as String, so make sure you're checking for '#' and not "#"
17:48:10 <fishythefish> likewise, ['#'] is also a String
17:48:53 <jared-w> ah yup I used double quotes in my case instead of single quotes, whoops
17:49:53 <jared-w> Just refresh the hpaste, htse, I fixed it. Too many list of list levels to keep track of :p
17:50:33 <htse> I already fixed it here
17:50:43 <jared-w> nice! Is it working now?
17:50:48 <htse> I'm reading your code and trying to understand why some of my tries didn't work
17:50:49 <fishythefish> jared-w: otherwise == True ;)
17:50:52 <htse> it is, thx
17:50:55 <fishythefish> you probably want _
17:51:32 <jared-w> darn, you're right. You can tell I haven't used haskell in a few weeks. I've been using Curry for coursework. It's juuuust different enough to mess with the brain cells every now and then :p
17:52:07 <jared-w> htse: The next "exercise for the reader" would be to reimplement invert as a map :)
17:52:47 <fishythefish> (wait, why does that compile?)
17:53:02 <jared-w> Make a function that takes a character and returns either that character, or returns . if given a #, or returns # if given a .  then map that function over the string and you're done :)
17:53:27 <monochrom> fishythefish: Do you mean "why does case xxx of otherwise -> ... compile"?
17:53:32 <fishythefish> yeah
17:53:42 <jared-w> fishythefish: I'm guessing because True means "do this case expression always"? Similar to guards?
17:53:51 <fishythefish> no, because a guard is evaluating a Bool
17:53:55 <fishythefish> a case expression is a pattern match
17:54:03 <monochrom> because "case xxx of v -> ()" compiles, and by alpha equivalence I may change v to otherwise.
17:54:12 <fishythefish> oh derp
17:54:20 <monochrom> > case () of otherwise -> otherwise
17:54:24 <lambdabot>  ()
17:54:24 <fishythefish> thanks, monochrom, it's been a long day
17:54:31 <monochrom> hee hee
17:54:54 <jared-w> mfw your reasoning is wrong yet your code still works ಠ_ಠ
17:55:10 <fishythefish> typical day for me - happy to talk about domain theory, but can't mentally compile a simple case expression
17:55:38 <monochrom> Oh, name shadowing is always treacherous.
17:55:54 <monochrom> Even "let 2+2 = 0 in ..." trips a lot of veterans.
17:56:11 <jared-w> pffh, same. Ask me to do anything more difficult than calculus and I'm happy to help; ask me to figure out how to factor a quadratic and I'll give up half the time
17:56:38 <monochrom> Complete the square and forget about the quadratic formula.
17:56:43 <mniip> > let () = undefined in ()
17:56:46 <lambdabot>  ()
17:56:52 <MarcelineVQ> > let 2+2 = 0 in 2+1
17:56:54 <lambdabot>  *Exception: <interactive>:3:5-11: Non-exhaustive patterns in function +
17:56:55 <jared-w> I never learned the complete the square method and can never seem to get it to stick in my head ¯\_(ツ)_/¯
17:56:59 <htse> ok it's maybe tooo messy but I used 2 lambas: inverse2 p = map (\x -> map (\l -> if l == '.' then '#' else '.') x) p
17:57:10 <mniip> jared-w, have you ever proved the discriminant formula?
17:57:18 <fishythefish> htse: nothing wrong with lambdas, but why not just make it a function?
17:57:29 <mniip> factoring is where that comes from
17:57:35 <jared-w> htse: nice! That'll work since all your characters are only # or .
17:57:36 <htse> is there a way to specify type for a lamba function parameter?
17:58:16 <mniip> htse, there's a thing called eta-reduction
17:58:18 <jared-w> mniip: Unfortunately I haven't. I probably should do that since it'll help me remember the whole factoring nonsense
17:58:18 <monochrom> inverse2 p = map (map f) p where f l = if l = '.' then ...
17:58:25 <fishythefish> you can with the ScopedTypeVariables extension, but you're really better off just making that a standalone function
17:58:37 <mniip> htse, that states that (\x -> foo x) and foo are equivalent
17:58:50 <htse> also does my parameter naming clobber or is every lamba its own little namespace? (i.e. if I use \x -> everywhere will the second x hide the first x and if not can my second lambda refer to the first lamba's x if I name the parameter differently?
17:59:23 <jared-w> The second x hides the first x, but if you name the inner x differently you can refer to the outer x. It's a concept referred to as lexical scope :)
17:59:23 <monochrom> Inner x hides outer x.
17:59:27 <mniip> htse, shadowing happens. you cannot refer to shadowed identifiers except module globals
17:59:29 <fishythefish> yes, parameter naming will "shadow" as usual
17:59:39 <htse> eta-reduction, I'll check that out
17:59:47 <htse> this is better than the tutorial :s
18:00:00 <htse> I've tried learn you some haskell but it confused the heck out of me
18:00:20 <fishythefish> learn you a haskell isn't a great tutorial for self learning; it just makes the language look friendly and colorful
18:00:21 <jared-w> Most tutorials are pretty terrible, especially ones with the word 'Monad' -- I also really dislike that book for being useless, but that's just my opinion
18:01:50 <htse> so you're saying that I could write \x -> map .... as just map ... ?
18:02:05 <monochrom> No.
18:02:13 <geekosaur> only if the x goes at the end
18:02:18 <monochrom> Write "\x -> map ... x" as "map ..."
18:02:28 <geekosaur> (\x -> ... x) is just ...
18:02:34 <monochrom> Because "map ..." is the foo there.
18:03:23 <htse> I see so (\x -> map (..) x) equals map(...) ?
18:03:31 <monochrom> yes
18:05:23 <htse> that's interesting, so I can actually give a function with multiple parameters as a callable to map as long as the param that map calls it with is the last one
18:05:54 <jared-w> yup, partial application is a powerful thing :)
18:06:03 <jared-w> > map (+1) [1..5] -- for example
18:06:07 <lambdabot>  [2,3,4,5,6]
18:06:18 <jared-w> > map (\x -> x + 1) [1..5] -- same thing
18:06:21 <lambdabot>  [2,3,4,5,6]
18:06:45 <jared-w> > foldl' (flip (:)) [1..10] -- If you want to get crazy with it
18:06:47 <lambdabot>  <[Integer] -> [Integer]>
18:07:12 <jared-w> > foldl1' (flip (:)) [1..10] -- If you want to get crazy with it
18:07:16 <lambdabot>  error:
18:07:16 <lambdabot>      • Occurs check: cannot construct the infinite type: a ~ [a]
18:07:16 <lambdabot>        Expected type: [a] -> [a] -> [a]
18:07:28 <MarcelineVQ> you're getting crazy with it
18:07:30 * jared-w gives up
18:07:49 <jared-w> oh, I forgot the [] lol
18:08:05 <jared-w> > fold' (flip (:)) [] [1..10] -- Can't just foldl1 the base case away here
18:08:09 <lambdabot>  error:
18:08:09 <lambdabot>      • Variable not in scope:
18:08:09 <lambdabot>          fold' :: ([a0] -> a0 -> [a0]) -> [a1] -> [Integer] -> t
18:08:21 <jared-w> > foldl' (flip (:)) [] [1..10] -- muh typing skills tho
18:08:26 <lambdabot>  [10,9,8,7,6,5,4,3,2,1]
18:08:28 <htse> is a an actual language type or is that a placeholder everyone uses? I've seen them compiler mention it so I'm assuming it is.
18:08:52 <jared-w> htse: a is a variable. Programmers and math people like certain letters more than others so they tend to use them a lot. It doesn't mean anything
18:09:41 <jared-w> Type variables *tend* to start with a b c..., "container" variables tend to be 't' or 'f', list variables tend to start with x:xs, y:ys, z:zs... etc. They're just conventions :)
18:09:58 <htse> ah I was wondering why not h:t :P
18:10:31 <jared-w> You /could/ have `map :: (ahahaha -> bwahahaha) -> [ahahaha] -> [bwahahaha]` but... why tho
18:10:48 <geekosaur> h:t works as long as there's only one list, and only ever pulling the head off
18:11:00 <geekosaur> foo (x:xs) (y:y1:ys) = ...
18:11:22 <jared-w> ¯\_(ツ)_/¯  I think x:xs comes from the more lispy conventions--we borrow a lot of terminology and naming conventions from lisp
18:11:47 <htse> so how would one implement a function that takes anything, like show? when I :t in ghci it shows me a => a -> String
18:12:07 <geekosaur> it doesn't take 'anything', yuou are misreding it
18:12:11 <geekosaur> :t show
18:12:13 <lambdabot> Show a => a -> String
18:12:34 <geekosaur> Show is a typeclass for things that can be rendered as strings
18:12:40 <geekosaur> the reverse is
18:12:40 <htse> ah it takes a Show
18:12:41 <geekosaur> :t read
18:12:42 <htse> my bad
18:12:43 <lambdabot> Read a => String -> a
18:13:06 <jared-w> `Show a` means "the input 'a' implements an instance of Show"
18:13:21 <geekosaur> you can think of typeclasses as interfaces
18:13:26 * jared-w insert handwavy and vague comparison with java's "implementing X" mechanism
18:14:03 <geekosaur> 'given some type a which implements the Show typeclass, show can produce a String from an a
18:14:14 <htse> sorry for the banal questions, this is the first time I'm having such a hard time learning a language :)
18:14:35 <jared-w> It's not a problem; Everyone has a hard time with Haskell :)
18:15:07 <geekosaur> but the less you know about a type, the less you can do with it; a function taking an unconstrained type 'a' can't do anything with it but either swallow it or give it back to you unchanged
18:15:10 <geekosaur> :t id
18:15:13 <lambdabot> a -> a
18:15:16 <geekosaur> :t const
18:15:17 <lambdabot> a -> b -> a
18:15:28 <jared-w> :t flip const
18:15:31 <lambdabot> b -> c -> c
18:16:03 <geekosaur> and the only way you can produce an unconstrained type a is to throw an exception or make an infinite loop
18:16:05 <geekosaur> :t undefined
18:16:07 <lambdabot> a
18:16:13 <geekosaur> > undefined
18:16:16 <lambdabot>  *Exception: Prelude.undefined
18:16:34 <geekosaur> :t let x = x in x -- note that let is recursive, so all of those are the *same* x!
18:16:37 <lambdabot> t
18:17:20 <jared-w> > let x = x in x -- Of course, should you actually run this, even though it typechecks fine...
18:17:24 <lambdabot>  *Exception: <<loop>>
18:19:05 <htse> thanks for your help guys, it did clarify a lot already
18:24:01 <jared-w> np! 
18:29:28 <htse> How high is the 'penalty' of Integer vs Int? does it balloon the memory footprint of the program?
18:30:43 <geekosaur> they are certainly larger, but size depends on the actual size of the number so it's usually not terrible unles syou fling around a lot fo 100-digit nunbers
18:31:16 <geekosaur> the most noticeable price is speed since Integer requires calling into gmp for every operation, whereas Int is native CPU instructions
18:31:43 <htse> I assume that if I give a Num constraint it also translates it into some sort of larger superstructure dscribing the type and holding the value?
18:32:06 <htse> like func Num a => a -> a
18:32:13 <geekosaur> it will pass whatever type of value it actually is, plus a dictionary of operations
18:32:32 <ertes> GMP functions use Int arithmetic, if the numbers are small enough…  in that case the price is actually just checking the size
18:32:55 <ertes> that's one pattern-match worth of CPU time, so it's usually very small
18:33:11 <ertes> err
18:33:17 <ertes> s/GMP/Integer/
18:33:31 <mniip> geekosaur, 100-digit?
18:33:35 <mniip> that's rookie numbers
18:34:31 <htse> how would one write an 'impure' function say function with no parameters that returns a random string
18:34:45 <mniip> you can't
18:34:48 <htse> ah
18:34:51 <geekosaur> well.
18:34:57 <mniip> but there's a catch
18:35:03 <geekosaur> you can do it in IO
18:35:12 <geekosaur> but IO *describes* an operation.
18:35:18 <ertes> htse: it's also not a function…  all functions can be applied
18:35:19 <htse> I kind of figured that after I read about 'purity' but I figured it does have a use case, so why not ask :P
18:35:46 <mniip> htse, purity is a property of everything in haskell (*)
18:36:53 <htse> how do you have a pure randomizer?
18:37:02 <ertes> htse: imagine you could do that…  what would the type of a random character be?
18:37:17 <ertes> htse: randomChar :: Char?
18:37:23 <htse> the result is supposed to differ for identical output, doesn't that make it impure or am I misundertanding the pure concept?
18:37:52 <htse> identical input I mean
18:38:19 <mniip> htse, that means it's impossible in haskell
18:38:21 <ertes> htse: ^ answer my question
18:39:05 <htse> I don't understand your question, why would the type matter?
18:39:13 <mniip> welcome to haskell
18:39:17 <ertes> htse: it needs to have a type
18:39:18 <jared-w> Types in haskell describe what you're allowed to do
18:39:36 <pacak> https://xkcd.com/221/
18:39:46 <jared-w> So :: a -> Char means "I return a char" and you have to return the same char for the same input
18:39:53 <ertes> htse: and from the way you describe it its type should be Char…  or did you have a different type in mind?
18:40:01 <jared-w> So you need some sort of box to put the Char in that could describe an operation to return a random character
18:40:30 <jared-w> something like `foo :: getRandomSeedAndGenerateMyChar Char`
18:40:54 <mniip> box is a bad name
18:40:57 <ertes> htse: (yes, there is a reason i ask, and yes, i'm going to make my point as soon as we can agree on a type)
18:41:24 <htse> but how would you getRandomSeed? that would itself be function called with identical parameters(ie none) that always returns a different result
18:41:38 <jared-w> (But in the general case, that "box" would be "do some sort of impure action")  (and I agree that box is a bad name, m'bad)
18:41:52 <Hafydd> m'box
18:41:54 <htse> a Char is fine
18:42:14 <ertes> htse: so randomChar is a character…  which one is it?
18:42:16 <jared-w> htse: the getRandomSeed would have to be done through some sort of controlled escape hatch. The punchline here is there's an IO type that you can use for these sorts of things
18:42:36 <ertes> htse: answer in the form of an equation
18:43:06 <htse> I'll never be able to answer in the form of an equation :P
18:43:31 <ertes> htse: neither can anyone else, but that means that Char can't be the correct type
18:43:51 <ertes> htse: any alternative proposals for a type?
18:44:09 <jared-w> (hint: the punchline/escape-hatch provides a partial solution)
18:44:43 <htse> I don't get your point tbh
18:44:57 <jared-w> To surmise so far: The type for a random Char generator in English is "a computation with side effects that returns a random Char", but how do you express this notion in Haskell?
18:45:04 <htse> I usuall use c the last years so everything is a byte for me :/
18:45:43 <ertes> htse: randomChar can't be a character, because that wouldn't make sense in haskell's semantics
18:45:51 <ertes> if it is a Char, then you can write an equation for it
18:45:55 <jared-w> In Haskell, things must be pure. So how do you express the notion of "side effect" in a pure way? Rather than saying the side effect is pure, you can say "the steps I execute to get this side effect are the same every time" and then you can reason about that side effect
18:46:45 <ertes> htse: if your proposal violates our ability to use equational reasoning, then it's not a valid haskell proposal
18:47:01 <jared-w> So randomChar must be a type of IO Char -- that is, "a Char obtained by some side-effect causing operation" (ie reading from input, creating output, grabbing from a disk, etc)
18:47:19 <ertes> htse: let's use a (randomInteger :: Integer) instead of a randomChar
18:47:24 <htse> hmm if I have to be able to do equations then it's probably not the language for me :/
18:47:42 <jared-w> htse: ertes is being a bit on the mathematical side of things, but it's really not so bad as he's making it out to be :p
18:47:46 <ertes> htse: addition is distributive, which means that for all x, x + x = 2*x
18:48:07 <ertes> htse: which means:  randomInteger + randomInteger = 2*randomInteger
18:48:11 <htse> yeah I'm at the "math, what's that' side
18:48:13 <ertes> which is clearly not what you had in mind
18:48:38 <ertes> htse: so let's solve this problem
18:49:03 <jared-w> You can think of the type `IO Char` as being more truthful. In C, you don't know if your Char is "from the computer" or "from the program"; but in Haskell, if our types are obtained by side-effects, we tag them and say "HEY, this was gotten from a side-effect!"  hence IO Char for a randomCharGenerator
18:49:10 <ertes> htse: why not instead of having "random integers" have "actions that, when executed, produce a random integer"?
18:49:27 <ertes> randomInteger :: Action Integer
18:50:02 <ertes> htse: now randomInteger is one specific thing, and it will be the same thing regardless of how often you refer to it
18:50:18 <jared-w> Of course, that means you can no longer just blindly substitute the result of `IO Char` in where you would call the function; you have to now run that function to see what the answer would be. That's the "losing equational reasoning" ertes is talking about. Hopefully that clears up some of what he's talking about, htse? :)
18:50:42 <mniip> jared did you steal ertes's -w
18:51:03 <ertes> htse: but of course that's something we already have:  Action is just IO
18:52:02 <jared-w> mniip: Nah, mine's just a stand-in for my last name. I'll have a jared-w-w nick when I start my new job next wednesday :p
18:52:21 <ertes> htse: the key difference is that randomInteger is *not* an integer, much like /bin/ls or dir is not a list of files
18:52:45 <ertes> htse: when we refer to randomInteger, we refer to an "action", a "program" or a "recipe" to make an integer
18:52:45 <mniip> jared-w, just go for jared-www
18:53:15 <jared-w> Hmm... Needs more cowbell
18:53:33 <htse> so actions are allowed to return a different value for identical input?
18:53:45 <ertes> htse: yes
18:53:56 <mniip> the notion of input is slightly different
18:54:00 <htse> how then does that not completely mess up your equation?
18:54:11 <jared-w> htse: because you're promising different things
18:54:15 <mniip> htse, the equation is about integers not actions
18:54:19 <ertes> htse: because you can never convert an action into its result *within* haskell
18:54:25 <jared-w> `foo :: Char` means "I give you the same character every time you run this"
18:54:35 <mniip> there are however still equations on actions, but those are different
18:54:36 <jared-w> `foo :: IO Char` means "I run the same recipe to make a Char every time you run this"
18:54:42 <ertes> htse: if you have 'randomInteger' in an equation, you're referring to the action, not to its result
18:54:55 <htse> so if I make an action that retuns a random Int, the value returned will always be identical?
18:55:03 <ertes> htse: no
18:55:06 <mniip> not necessarily
18:55:16 <jared-w> The recipe used to generate the int will always be the same, though (if you use the same function)
18:55:19 <ertes> htse: it can return random results
18:56:24 <ertes> htse: much like there are laws for integers there are also laws for actions, but those aren't arithmetic laws, because you can't "add" (as in (+)) two actions
18:56:54 <jared-w> ertes: how did we get from "how does number generation work" to monadic composition? :p
18:57:04 <ertes> htse: given two actions c and d, (c >> d) is the action that first executes c, then executes d and results in d's result
18:57:20 <ertes> htse: (>>) is associative
18:57:32 <ertes> c >> (d >> e) = (c >> d) >> e
18:57:56 <ertes> now remember that c, d and e are the actions themselves, not their results
19:00:49 <ertes> in other words: you can still use equational reasoning…  this concept does not violate haskell's semantics
19:02:05 <ertes> jared-w: kind of naturally =)
19:02:35 <ertes> without IO haskell could at best generate pseudo-random sequences with a fixed seed
19:03:08 <ertes> (or it would need to be written as a function of the seed, and that function would have to be "applied" outside of haskell)
19:07:04 <Eduard_Munteanu> Hmmm...  main :: Conduit Identity Response Request ()
19:07:45 <geekosaur> are we back to that again?
19:08:06 <geekosaur> (because it worked so well the first time around?)
19:08:28 <jchia> when you compile something like "compareLength x 10 >= EQ", what do you do about the annoying warning "Defaulting the following constraints to type ‘Integer’"? Do you just change the 10 to (10 :: Int)? That's ugly. Is there a better way?
19:08:37 <Eduard_Munteanu> Well, the first time around had lazy IO things, now it has conduits. :)
19:09:00 <ertes> jchia: i disable the warning =)
19:09:19 <jchia> ertes: How do you disable this specific warning? What's the option?
19:09:21 <ertes> Eduard_Munteanu: it's still a horribly boolean-blind approach
19:09:32 <ertes> jchia: look at the warning message
19:09:38 <jchia> OK
19:10:35 <geekosaur> -Wno-type-defaults or some such. and sufficiently recent ghc should tell you which warning option produced it, yes
19:11:01 <jchia> geekosaur: Yeah, I got it. The message mentions -Wtype-defaults
19:13:51 <jchia> I was concerned that disabling the warning would skip cases that I should care about I it turns out that type defaulting happens in very specific situations for a small number of numeric type classes, so I think it's fine.
19:14:39 <jchia> Basically they use Integer & Double for numbers, prefering Integer. That's all. Am I right?
19:15:57 <htse> if I want a function without a return value I assume those would have to be action as well since their only purpose would be a side-effect?
19:16:45 <geekosaur> correct
19:16:47 <geekosaur> :t print
19:16:49 <jchia> htse: If the function returns, there will be a return value. If you don't care, you can return ().
19:16:49 <lambdabot> Show a => a -> IO ()
19:17:51 <c_wraith> jchia, that's.. not all the cases.
19:18:19 <c_wraith> @check \ xs -> xs == reverse xs
19:18:23 <lambdabot>  +++ OK, passed 100 tests.
19:18:36 <c_wraith> jchia, that passes because of defaulting
19:20:19 <jchia> c_wraith: What other cases should I know about? How can I list all the defaulting rules for Prelude or for the modules I have loaded in ghci?
19:20:43 <c_wraith> jchia, the report has a full list. it's pretty short.
19:21:39 <c_wraith> jchia, notably, that case was defaulting an unconstrained type variable to ()
19:30:31 <htse> if I have say function c c2 and I was to have conditions on say, say c mod 2 == 0, can I put that in the match somehow?
19:30:32 <jchia> c_wraith: Not sure what @check does. How do I do the same thing as your @check in ghci?
19:30:40 <htse> or must I use if?
19:31:37 <jchia> htse: You can also use guards
19:32:04 <htse> a with | and | otherwise
19:32:15 <htse> that's similar to what erlang uses
19:35:10 <Ecod> hi~ [a | a <- xs, a <= x] where can I found the syntax ref?
19:35:47 <monochrom> Haskell 2010 Report
19:36:02 <Ecod> keyword ?
19:37:02 <jchia> Ecod: This feature is called list comprehension, so if you google for "list comprehension", you'll find some description.
19:37:19 <Ecod> great thanks!
19:37:27 <Ecod> I will try
19:39:34 <c_wraith> jchia, @check is a weird process. you can't do what it does trivially from ghci.
19:40:01 <c_wraith> jchia, it involves type checking and then writing code based on that.
21:21:23 <yuuko> hello; i'm having trouble finding the perfect templating library and i was wondering if anyone in here knew something that fits my criteria:
21:21:42 <yuuko> - templates may reside in external files
21:22:04 <yuuko> - some sort of template haskell hook that allows for compiling templates at the same time as my code
21:22:51 <yuuko> - output looks reasonably similar to input (no syntactic sugar in the vein of hamlet)
21:23:46 <yuuko> - templates may be passed haskell functions, and template *rendering* (at runtime) may produce monadic effects
21:24:28 <yuuko> that's just about my list of requirements
21:25:24 <yuuko> i'm almost happy with the state of mustache implementations on hackage, but there seems to be mutual exclusion between TH hooks and the ability to pass in functions via the mustache spec's ``lambda'' construct
21:27:46 <Welkin> most of us don't use templates any more
21:27:55 <Welkin> we use html combinators
21:28:04 <Welkin> templates have too many issues and are a pain to work with
21:28:16 <Welkin> use lucid or blaze-html
21:28:40 <Welkin> no template haskell required
21:28:51 <yuuko> if i were the only one using this software, i wouldn't have so much as a second thought about going with some html combinator library or edsl
21:29:13 <yuuko> my asking for a template library presupposes that i do in fact want templates
21:29:14 <geekosaur> there's a just-announced one but I don;t think it quite fits your criteria. and it's still evolving if I read the announcement correctly
21:29:18 <geekosaur> @hackage nice-html
21:29:18 <lambdabot> http://hackage.haskell.org/package/nice-html
21:30:53 <yuuko> yes; i'm afraid this doesn't quite fit
21:31:16 <suzu> lucid? blaze?
21:31:23 <geekosaur> when it comes down to it, though, the Haskell community is in general more interested in combinator libraries than template libraries
21:31:33 <suzu> whamlet if you really are married to TH
21:32:00 <suzu> but as geekosaur and Welkin said, i think combinators are more popular than TH
21:32:57 <yuuko> the problem with hamlet is it's a dsl and defeats the WYSIWYG of templates that i'm aiming for
21:33:04 <suzu> by template rendering producing monadic effects, does that mean you want a result type of Monad m => m Text or something on those lines?
21:33:31 <yuuko> yes
21:33:32 <suzu> essentially a monad transformer on the template so you can have effects in whatever monad
21:33:34 <suzu> okay
21:36:17 <yuuko> i'm not particularly enthusiastic about using TH for its own sake; it's more that users being able to edit templates provided in external files that resemble actual html somewhat precludes the use of html combinators
21:38:07 <suzu> hmm
21:38:13 <suzu> and whamlet isn't good enough?
21:38:23 <suzu> im not sure what you want exists, unless you're willing to write it
21:38:42 <yuuko> it increasingly seems as though that's where i'm headed
21:44:00 <Lokathor> class Enumish a where; toEnum :: a -> GLenum; tryFromEnum :: GLenum -> Maybe a
21:44:11 <Lokathor> is there already a typeclass like this in haskell that I should be using?
22:04:26 <yuuko> i spoke too soon of my despair
22:04:47 <yuuko> it looks like ``mustache'' features both TH support and passing in functions
