00:00:49 <pimlu> I have a presentation tomorrow so I can't go past the intro tonight but I'll read it after
00:00:53 <dmwit> Surely whatever work most people doing is the standard work.
00:01:56 <tdammers> oh wait, nm
00:02:01 <cocreature> tdammers: I don’t think “should we disable full laziness” and “how useful is non-strict evaluation, anyway” are the same argument. disabling full-laziness is about preventing GHC from blowing up the space usage of your program _without any good way to prevent it from doing so_. most spaceleaks can be fixed rather easily
00:02:12 <tdammers> cocreature: yeah, I just realized that myself
00:03:00 <cocreature> so while I like lazy evaluation, I still think full-laziness might not be a good default and disabling it might be better
00:03:15 <tdammers> dmwit: things like boring CRUD and CMS-driven small to medium scale websites and stuff like that are underrepresented in Haskell
00:03:21 <tdammers> cocreature: yes, I agree
00:04:45 <cocreature> that said there are cases where you want full-laziness to happen, e.g., if you define functions that don’t depend on input arguments in where clauses
00:05:23 <cocreature> I guess the first step is to provide a way to give users more control about when full-laziness is applied
00:06:05 <ski> hm. perhaps an SML `local'-`in'-`end' would help with that
00:07:26 <c_wraith> isn't everything full laziness does something you could do yourself by refactoring the code?  Hmm.  I guess not, as it applies after inlining/simplification
00:08:48 <cocreature> c_wraith: sure but I would argue that defining functions in where clauses is currently considered idiomatic Haskell so just telling programmers to move these definitions manually to top-level definitions is not a nice solution either
00:09:19 <dmwit> foo x = y where {-# Lift #-} thing = doesNotDependOnX
00:11:01 <ski> cocreature : what if we allowed a `local' thing for that ?
00:12:18 <cocreature> ski: not sure but https://ghc.haskell.org/trac/ghc/ticket/12620 contains some rather tricky cases so I’d be cautious of simple solutions here :)
00:12:36 <tdammers> actually, I would love to be able to do even more in where clauses
00:12:43 <tdammers> like, for example, define scoped data types
00:13:49 <ski> yes, please
00:13:50 <tdammers> e.g., when I write a function that uses a state monad with a custom state type, that state type won't be useful outside the function, so I'd like to scope it to that function alone, and use a generic name
00:14:02 <c_wraith> we can define data types in ghci now.  that requires the same technology as scoped data types!  It can be done!
00:14:27 <ski> tdammers : also to avoid having to parameterize it over tyvars
00:15:07 <ski> c_wraith : you can't say `data Foo = MkFoo (..a..)', where `a' was already in scope
00:15:26 <c_wraith> ski: yeah, I hadn't considered the interaction with ScopedTypeVariables
00:15:45 <ski> that's part of the reason why i want locally declared types
00:15:50 <ski> to allow that
00:15:51 <tdammers> STV should be the default IMO
00:16:01 <tdammers> and it shouldn't require explicit forall
00:16:32 <ski> yeah, rather if you use explicit `forall', the variable should *not* be brought into scope in the definition .. imho
00:17:14 <royal_screwup21> So I'm trying to write a function that removes consecutive duplicates in a list https://thepasteb.in/p/zmh8oVWD3W4IZ The compiler's throwing this error though https://thepasteb.in/p/8qhOp4N32x1i0 I'm not sure where I'm going wrong. I'd love a pointer or two in the right direction
00:17:54 <ski> on this topic, one can also start thinking of having tyvar parameters to modules .. but then, perhaps having fullblown module parameters would be better ?
00:18:08 <ski> anyway, instead of
00:18:16 <ski>   foo x = ..x..bar..
00:18:17 <ski>     where
00:18:25 <ski>     bar y = ..y..
00:18:32 <royal_screwup21> ah never mind, I got it
00:18:37 <ski> one can imagine
00:18:39 <ski>   local
00:18:43 <ski>     bar y = ..y..
00:18:45 <ski>   in
00:18:50 <ski>     foo x = ..x..bar..
00:18:52 <ski>   end
00:19:04 <ski> (SML `local'-`in'-`end')
00:19:40 <ski> (both sections can include multiple declarations)
00:19:53 <ski> perhaps it'd look nicer in Haskell, rendering it something like
00:19:55 <ski>   mutual
00:20:03 <ski>       foo x = ..x..bar..
00:20:06 <ski>     where
00:20:10 <ski>     bar y = ..y..
00:20:50 <tdammers> ski: IMO explicit forall shouldn't change anything at all, just that when you use explicit forall, you must list *all* tyvars explicitly, except for the ones you want to inherit from the parent scope
00:21:32 <LiaoTao> royal_screwup21: dup (x:y:xs) | x == y = dup xs | otherwise = x : y : dup xs
00:22:10 <LiaoTao> Or something like that
00:22:21 <ski> tdammers : when i see `forall a. ..a..', i expect the scope of `a' to be restricted to `..a..', not magically somehow extend over some defining equations, in case this `forall' occurs right after `::'
00:22:27 <ski> otoh, if one writes
00:22:34 <ski>   foo :: ..a..
00:22:38 <ski>   foo = ..a..
00:22:47 <ski> then one can conceptually think of this as
00:22:49 <ski>   forall a.
00:22:51 <ski>     foo :: ..a..
00:22:53 <ski>     foo = ..a..
00:23:11 <ski> with the scope of `a' enclosing both the type signature, and the defining equation
00:23:46 <royal_screwup21> LiaoTao: the error was that I had mismatched the type of the variables. dup [x] =x was wrong, because I returned x, not an explicit, so it should have been like so: dup [x] = [x]
00:23:56 <royal_screwup21> explicit list*
00:24:31 <LiaoTao> royal_screwup21: Sure, but I was suggesting that pattern matching looks cleaner
00:24:40 <tdammers> ski: ah, I see
00:25:26 <ski> (iow, `ScopedTypeVariables' is exactly backwards from how it ought to be done, imho)
00:25:36 <tdammers> agree on that
00:26:07 <tdammers> purescript solves it in a somewhat OK fashion
00:26:25 <tdammers> STV is always on, and all tyvars must be explicitly forall'd
00:26:30 <dmwit> LiaoTao: I think you were not careful when moving his `where`-block pattern match up to the top level.
00:26:45 <tdammers> it's just a bit annoying that you're writing forall all the time
00:26:47 <LiaoTao> Probably
00:26:47 <dmwit> LiaoTao: e.g. your `x == y` case should include `y` in the recursive call (his does).
00:26:59 <ski> .. also, i'm not really that happy with that they removed the possibility for pattern signatures to bring tyvars into scope, except for when you have an existential (there's not much reasonable alternative there)
00:27:32 <dmwit> The other case looks a little worrying, too. =P
00:27:38 <ski> (`PatternSignatures' used to allow that)
00:28:00 <ski> tdammers : ok
00:28:48 <tdammers> some people have adopted the habit of writing ∀ instead of forall
00:30:30 <LiaoTao> dmwit: Yes, I see that now
00:30:46 <LiaoTao> Oh well, back under the bridge
00:31:10 <ski> well, if you have `data Foo = forall a. MkFoo (Bar a)' and you want to write `useFoo (MkFoo bar :: Bar a) = ..(..bar..a..)..', one could in fact, i think, write `useFoo (MkFoo bar) = ..(useBar bar).. where useBar :: forall a. Bar a -> ..a..; useBar bar = ..bar..a..'
00:31:22 <ski> but that requires inventing a new name `useBar'
00:36:08 * hackagebot colorless 2.2.2 – Colorless – https://hackage.haskell.org/package/colorless
00:43:10 <LiaoTao> royal_screwup21, dmwit: http://lpaste.net/358940
00:43:12 <LiaoTao> That's what I meant
00:43:14 <LiaoTao> :)
00:45:27 <merijn> Anyone here have a Travis setup for repos that contain multiple new-build packages?
00:46:54 <merijn> Also, relatedly, anyone with access to both a Mac & linux box and some compile time to spare willing to try and reproduce an issue for me?
00:54:31 <localhorse> does <$> have higher precedence than <*> ?
00:54:47 <merijn> localhorse: I think it's the same, but, you can simply check in ghci :)
00:55:15 <merijn> localhorse: ":i (<$>)" (or :info) prints, among other things, the fixity of operators
00:55:28 <merijn> (if no fixity is printed it's the default of infixl 9)
00:59:08 <merijn> Wow...
00:59:19 <merijn> Why did I only just learn about "-freverse-errors"? o.O
01:00:51 <opqdonut> why would somebody want that?
01:00:59 <opqdonut> scrolling up in their terminal while scrolling down in their file I guess
01:01:34 <merijn> opqdonut: So I don't have to scroll up several screens?
01:02:01 <opqdonut> is the first error usually more relevant? I haven't noticed that
01:02:31 * hexagoxel .oO the cabal repo itself uses new-build on multiple packages in its travis.. but ofc there is some cruft around it.
01:02:41 <merijn> opqdonut: When refactoring they are, because usually it's a type you haven't updated yet invalidating a bunch somewhere else
01:02:51 <opqdonut> right
01:03:25 <merijn> hexagoxel: I don't understand the whole travis.yml stuff, though. I was just using hvr's multi-ghc travis generator, which, sadly, does not support new-build projects with multiple packages atm
01:06:09 <merijn> Also, why the hell can't I find any number formatting functions in base?
01:06:37 <hexagoxel> i don't think there is that much to understand.. if you have the project.cabal in the repo, shouldn't a script that essentially calls new-build packageA packageB be sufficient?
01:06:51 <hexagoxel> wait, let me check what multi-ghc-new-travis prints.
01:10:48 <ertes-w> ello
01:14:33 <hexagoxel> merijn: ah, of course "echo 'packages: .' > cabal.project" needs to go. and the dist testing needs to be done per-package (or disabled).
01:16:41 <hexagoxel> merijn: if you have any concrete errors, i can have a look.
01:17:42 <merijn> hexagoxel: Well, I haven't tried fixing it yet. I'm currently struggling to figure out which of MVar/forkIO/threadDelay is performing like shite on macOS and why
01:18:35 <merijn> Because my N-way parallelisation (which shows perfectly reasonable linear speedup on linux) is showing negative speedup on macOS (as in, the parallel version is actually slower)
01:19:51 <merijn> oh, I suppose the clock could also be fucked on macOS...
01:22:52 <hexagoxel> merijn: public repo?
01:23:12 <merijn> hexagoxel: https://github.com/merijn/broadcast-chan
01:23:42 <cocreature> I use new-build in llvm-hs’s travis config which also contains multiple packages
01:23:44 <merijn> hexagoxel: Should be a simple matter of "cabal new-build all"/"cabal new-test all" in the root of the repo
01:24:21 <merijn> hexagoxel: Or just "cabal new-build broadcast-chan" and "cabal new-test parallel-io" to save some build time
01:30:15 <mivael> hi all
01:30:37 <mivael> > [ y | x <- [1..5], let y = x + 1 ]
01:30:41 <lambdabot>  [2,3,4,5,6]
01:30:48 <mivael> > [ y | x <- [1..5], y <- [x + 1] ]
01:30:53 <lambdabot>  [2,3,4,5,6]
01:31:26 <merijn> Wait...
01:31:37 <merijn> nano second is 10^9, yeah?
01:31:43 <LiaoTao> Yes
01:31:46 <mivael> Is there any practical difference between the two above syntaxes?
01:31:48 <LiaoTao> 10^-9
01:31:56 <merijn> ok, so threadDelay is fucky on macOS
01:32:21 <merijn> or the clock, I suppose
01:32:59 <merijn> Because code that should take 30s probably does not finish in several milliseconds...
01:33:49 <LiaoTao> https://stackoverflow.com/questions/26437770/timing-inaccuracy-in-haskell-threaddelay
01:33:57 <geekosaur> mivael, not in that usage. the second is a bit less efficient, probably. but the second can be used in ways the first can't 
01:34:14 <LiaoTao> But that seems unrelated
01:34:25 <geekosaur> as for number formatting, looked int he Numeric module? although it's not going to give you formatting like e.g. old style database reports
01:34:40 <geekosaur> (but that's kinda dead anyway in the age of postscript output, arguably)
01:35:32 <mivael> geekosaur, thank you.  Less efficient is enough incentive to stick to 'let' version (in such cases).
01:35:36 <merijn> LiaoTao: threadDelay can only take *longer* than asked
01:35:41 <LiaoTao> Yeah
01:35:46 <merijn> LiaoTao: Thread delay should *never* return early
01:36:00 <geekosaur> mivael, basically the second one gives you two lists in parallel, the second generated from the first, then you throw the first away
01:36:30 <geekosaur> you could however do complex combinations of the two, which would be difficult to emulate with let in the general case (but easy in that specific one)
01:36:51 <LiaoTao> merijn: Well threaddelay has had problems before on OSX
01:36:55 <LiaoTao> https://ghc.haskell.org/trac/ghc/ticket/7299
01:36:55 <geekosaur> ^
01:37:44 <merijn> LiaoTao: Oh, I know
01:38:03 <merijn> "threadDelay maxBound" used to crash your program
01:38:35 <ski> mivael : `let' is recursive, `<-' isn't .. also if pattern-matchnig to the left of `<-' fails, it will just carry on
01:38:36 <mivael> Yeah, I think I understand that.  I thought whether 'let' syntax can be considered redundant in case of list comprehension.
01:38:48 <ski> mivael : either of those might sometimes come in handy
01:38:54 <geekosaur> there has also been some recent work related to I/O delays, I don't think it could affect threadDelay but I may be misremembering
01:39:00 <merijn> Although that was buggy on both linux and OSX, except it happened to result in an unnoticable error on linux
01:39:21 <merijn> geekosaur: Well, note that the code works perfectly fine on linux
01:39:27 <LiaoTao> Particularly interesting is that comment about threaddelay "giving no apparent delay"
01:39:27 <geekosaur> (there's a function to read with a timeout that didnt reliably work if the timeout was not zero)
01:39:30 <mivael> ski, that's very important difference, thanks
01:40:07 * ski wouldn't worry too much about efficiency differences (as opposed to semantics differences) here, unless profiling indicated otherwise
01:40:41 <mivael> agree
01:40:46 <ski> mivael : hm, also `let'-bindings can be polymorphic
01:40:46 <geekosaur> merijn, I know the code change affected windows, I don't know about OS X or linux
01:42:11 <mivael> ski, I think I should learn more (and more systematically) about 'let' syntax...  (Any reading suggestions, by the way, on this matter?)
01:42:34 <ski> mivael : sometimes `<pat> <- return <expr>'/`<pat> <- pure <expr>' in `do'-notation will similarly be handy. note that here, in case of matching-failure, `fail' is called, which doesn't always do something useful
01:43:02 <ski> (depending on the monad)
01:43:02 <osa1> anyone know if using persistent and persistent-sqlite I can use sqlite's transactions?
01:43:19 <ph88^> when i use   stack install   how can i give compilation flags with that? just in the normal was as with stack build  ?
01:43:42 <ski> mivael : whatever can go after a `where' (attaching to a defining equation) can also go after `let'
01:44:33 <ski> (well, attaching to a defining equation, or a `case' branch, to be more precise)
01:44:37 <ski> (there's also `where' attaching to `module',`class',`instance',`data' ..)
01:44:53 <ski> @undo [ y | x <- [1..5], let y = x + 1 ]
01:44:53 <lambdabot> concatMap (\ x -> let { y = x + 1} in [y]) [1 .. 5]
01:45:00 <ski> @undo [ y | x <- [1..5], y <- [x + 1] ]
01:45:00 <lambdabot> concatMap (\ x -> concatMap (\ y -> [y]) [x + 1]) [1 .. 5]
01:45:33 <ski> @undo do x <- [1..5]; let {y = x + 1}; [y]
01:45:34 <lambdabot> [1 .. 5] >>= \ x -> let { y = x + 1} in [y]
01:45:35 <mivael> ski, I understand about 'where'.  I just think I do not use/know all let/where power and functionality.
01:45:45 <ski> @undo do x <- [1..5]; y <- [x + 1]; [y]
01:45:45 <lambdabot> [1 .. 5] >>= \ x -> [x + 1] >>= \ y -> [y]
01:45:53 <ski> @src [] (>>=)
01:45:53 <lambdabot> xs >>= f = concatMap f xs
01:56:37 <ski> mivael : you can define functions in there. you can have type signatures. these are allowed to use variables which are already in scope in the surrounding expression / comprehension / defining equation. such nested defining equations may themselves have `where's attached
01:57:29 <ski> mivael : if a defining equation has guards, then one can add a `where' after them, which can use the parameters, and whose bindings scope over the guards
01:58:41 <ski> (this also works for `case' branches)
01:58:43 <ski> mivael : this is also allowed, even if the defining equation is not (at least syntactically) a function definition
01:58:49 <ski> e.g. one can say
01:59:12 <ski>   (x,y) | ..z..     = ...
01:59:20 <ski>         | otherwise = ...
01:59:23 <ski>     where
01:59:28 <ski>     z = ...
02:04:14 <Wizek> Hello! Anyone knows if/how printf can be persuaded to pad a Float with spaces on both ends, keeping the decimal point in the middle?
02:04:36 <Wizek> https://www.irccloud.com/pastebin/RrdTym0j/
02:04:44 <Wizek> Something like the above ^
02:05:15 <merijn> geekosaur: Seems like threadDelay was fine and indeed the clock library wasn't doing what I wanted
02:06:45 <Wizek> The closest I've gotten so far: `iterate (/2) 100 $> takeWhile (round.>(/=0)) $> map (\s -> printf "X %9.5f Y\n" s) $> sequence_`
02:06:51 <merijn> Now on to fixing the travis tests
02:12:29 <mivael> ski, how a 'where' attached to guard is distinguished by a compiler from a 'where' which is common for guards as in your example?
02:12:36 <geekosaur> Wizek, tbh I'd start with Numeric.showFFloat{,Alt}, or maybe Numeric.floatToDigits
02:13:08 <geekosaur> mivael, indentation or braces
02:14:27 <mivael> ski, I see, thanks.  I knew about the rest of of the listed usages, but avoided them when using guards  :)
02:14:34 <geekosaur> Wizek, but to be honest one of the first things I considered writing in Haskell was numeric formatting a' la database reports... until I realized that, these days, it makes more sense to do said formatting in a formatting language. (usually postscript)
02:15:29 <mivael> geekosaur, thanks
02:16:24 <geekosaur> before I switched from database programming to sysadmin, I had one customer who used traditional reports... and the others, I was writing stuff that output LaTeX source and processed that for either screen or printer as appropriate
02:17:07 <ski> mivael : `where' doesn't attach to individual guards
02:18:34 <merijn> cocreature: ok, so I need to get rid of the commands affecting cabal.project and replace the sdist command with one that runs for each package, anything I missed?
02:18:49 <ski> guards doesn't bind variables anyway (well pattern guards do, but then i think you can use `let' in them ?), and since we have non-strictness, if a guard and corresponding expression doesn't need a binding in the common `where', it won't be evaluated
02:18:49 <mivael> ski, Oh, I misread the "then one can add a `where' after them" part.
02:19:28 <ski> > let x | let {y = 0} = y in x
02:19:32 <lambdabot>  0
02:20:05 <ski> > let x | Just y <- Nothing = y | otherwise = () in x
02:20:08 <lambdabot>  ()
02:20:59 * mivael is struggling to parse "let x | let {y = 0} = y in x"...   :)
02:21:20 <merijn> mivael: Yeah, that's a bit confusing without indentation
02:21:31 <Athas> Record patterns are a rare sight, too.
02:21:52 <merijn> mivael: It's a guard for 'x', the guard includes a let that sets 'y = 0' and the result of that guard is 'y'
02:21:53 <mivael> I certainly need something to (re-?)read about Haskel syntax...
02:22:08 <ski> > let () | () <- (),let {() = ()},() <- () = () in ()
02:22:11 <lambdabot>  ()
02:22:12 <Tuplanolla> Reading won't save you, mivael.
02:22:31 <saurabhnanda> if I want to store a global map/lookup-table in my haskell process (which will change infrequently, and only when explicitly signalled to do so) what should I be using - IORef, MVar, TVar, or something else?
02:22:33 <Tuplanolla> The surprises never end.
02:22:35 <merijn> mivael: I think two mandatory things to read are the whitespace layout rules: https://en.wikibooks.org/wiki/Haskell/do_notation
02:22:45 <merijn> mivael: Eh, wrong link, that one is do notation desugaring >.>
02:22:46 <mivael> Tuplanolla, it could still help, anyway :)
02:22:54 <merijn> mivael: I meant this one: https://en.wikibooks.org/wiki/Haskell/Indentation
02:23:02 <merijn> mivael: The do notation one was gonna be my second link :p
02:23:06 <ski> pattern guards extend what's allowed after the guard `|' to a `,'-separated list of boolean expressions, and `<-' and `let' clauses, which looks similar to what's allowed in list comprehensions
02:23:22 <merijn> mivael: If you feel more confident you can also just read the Haskell 2010 Report, it's very readable
02:23:59 <ski> the difference being that the type of both sides of `<-' here is the same. if the match fails, that clause fails. if one of the `,'-separated guard-clauses fails, the whole guard fails
02:24:07 <merijn> Tuplanolla: Honestly, there's not that many surprises if you read the specification. Haskell is fairly consistent in how things can be written. It's just that the rules are far more general/flexible than people think from reading other peoples code
02:24:28 <merijn> Tuplanolla: Since what people actually write is a rather small subset of what's allowed
02:24:34 <ski> mivael : but this in an extension, `PatternGuards', not the language proper (at least not yet)
02:24:39 <Athas> Haskell probably taught me that I don't like whitespace-sensitive indentation after all.
02:24:41 <merijn> ski: *bzzt*
02:24:51 <merijn> ski: PatternGuards is in Haskell2010 and everyone always forgets
02:24:59 <merijn> So it's not an extension
02:25:01 <ski> oh, it is !?
02:25:05 <ski> ah, ty :)
02:25:10 <ski> i stand corrected
02:25:16 <Tuplanolla> See, surprises.
02:25:21 * ski smiles
02:25:57 <Athas> It's the nicest part of Haskell 2010.
02:26:26 <merijn> Everyone always says "Haskell 2010 didn't improve anything!" and then promptly forgets PatternGuards (there was another extension added in 2010 that's nice but I forgot)
02:26:29 <Athas> It doesn't change the unfortunate fact that Haskell is an implementation-defined language, but at least some progress was made!
02:26:41 <Athas> merijn: they fiddled with the syntax for 'if' so it plays better with do-notation.
02:26:54 <merijn> Athas: That's not it, because I don't give a shit about that one :p
02:26:57 <Athas> Also, empty data types.
02:27:19 <ski> btw, i don't really see why `(transform -> f) x = ..x..' is not allowed, when `(transform -> f) = \x -> ..x..' is allowed
02:27:43 <geekosaur> the report itself only mentions pattern guards. (well, hierarchical modules and FFI but those were already in every haskell98, and FFI was a formal addendum to 98)
02:27:51 <geekosaur> the other main change was removal of n+k patterns
02:28:27 <geekosaur> think it considers things like empty data decls to be minor though
02:28:41 <merijn> geekosaur: And empty data decls :p
02:28:46 <ski> Athas : how about a `case' as the last command in a `do', whose last branch is again a `do' ?
02:29:30 <Athas> ski: what about that?
02:30:04 <saurabhnanda> does anyone know the difference between atomicallyModifyIORef and STM's atomically? 
02:30:41 <merijn> saurabhnanda: STM can create and handle arbitrarily complex transactions
02:30:52 <geekosaur> atomicallyModifyIORef guarantees atomicity between retrieving the old value and setting the new. STM's is transaction based and the transaction can be larger than just such a modify
02:30:58 <merijn> saurabhnanda: atomicallyModifyIORef is just that, it atomically modifies an IORef
02:31:12 <saurabhnanda> merijn: for simple use-case, swapping out an entire Data.Map.Strict, is an ioRef with atomicallyModifyIORef, good enought?
02:31:28 <merijn> saurabhnanda: Yes, no, maybe?
02:31:48 <saurabhnanda> merijn: ?
02:31:56 <ski> Athas : is it allowed for the body of the latter `do' to be aligned in the same column as the body of the former ?
02:32:03 <merijn> saurabhnanda: ENOTENOUGHCONTEXT
02:32:08 <saurabhnanda> merijn: heh
02:32:16 <mivael> merijn, now I'm convinced to re-read the Haskell 2010 Report.  When I did it I had so little practice with Haskell that I'm sure most of useful information were not understood (and, therefor, remembered).
02:32:18 <saurabhnanda> merijn: umm... how to summarize...
02:32:42 <mivael> * therefore
02:33:07 <merijn> mivael: I try and read bits every so often. Plenty of gems hidden away
02:33:08 <Athas> ski: no idea.  I quickly concluded that I didn't want to learn about Haskell syntax minutiae.
02:33:20 <merijn> mivael: I can also strongly recommend just skimming/browsing the GHC user guide
02:33:25 <saurabhnanda> merijn: need to read a YAML file and keep it in memory as a Map. Lots of threads will be reading from it. Once in a while the YAML data will change and needs to be re-read into memory.
02:33:30 <Athas> A language is doing something wrong when syntax arguments become complicated.
02:33:37 <merijn> mivael: Most people seem to never look at it, but it's actually rather in-depth and detailed
02:33:53 <merijn> saurabhnanda: That's probably fine
02:34:04 <merijn> saurabhnanda: You could also just use an MVar for that, tbh
02:34:18 <xormor> I am going to the library to pick up my copy of Programming in Haskell by Graham Hutton.
02:34:35 <ventonegro> xormor: Enjoy
02:34:43 <saurabhnanda> merijn: I'll never have an empty/blocking case. Why the MVar? Also, isn't IORef faster?
02:34:46 <merijn> saurabhnanda: (With all the readers using readMVar) and then just to "takeMVar + putMVar" to replace the map
02:34:58 <ski> Athas : fair enough
02:35:30 <merijn> saurabhnanda: MVar is pretty damn fast as is, so without profiling I don't believe that'd be an issue
02:36:37 <merijn> saurabhnanda: I dislike atomicallyModifyIORef, because that kinda code tends to be hard to get bug free. The MVar version is trivially correct and the only time you block any threads is the few microseconds it takes you to take the old map and put the new one
02:36:44 <saurabhnanda> merijn: okay. also, if the Map is being looked up multiple times in the same thread, and I need a consistent view of the Map, I'll need to use STM, right?
02:37:11 <merijn> saurabhnanda: If you wanna make sure it wasn't changed between the first and second, then yes
02:37:34 <saurabhnanda> merijn: that's what I am wondering. isn't atomicallyModifyIORef "isomorphic" to takeMVar+putMVar?
02:37:39 <pacak> STM is when you have several threads changing stuff.
02:37:44 <pacak> For reading MVar will do.
02:38:09 <raek> or when you want to be able to read a consistent snapshot of multiple mutable things
02:38:25 <geekosaur> saurabhnanda, I'd argue that MVar isn;t so much for data like IORefs are. they;re for *synchronization*
02:38:55 <merijn> saurabhnanda: atomicModifyIORef has a complicated memory model
02:38:59 <geekosaur> you use MVar to protect something else that can't reasonably be updated atomically
02:39:25 <geekosaur> or to synchronize access to an external resource, or etc.
02:39:32 <merijn> geekosaur: I think it's fine for my suggested "read only + update" model
02:39:49 <geekosaur> it can be used that way, yes, but for that it can be higher overhead than needed
02:40:20 <merijn> geekosaur: Seems unlikely, readMVar is cheap
02:40:28 <saurabhnanda> get map from mvar/ioref => lookup keyA => do something => get map from mvar/ioref => lookup keyB => do something ====> this requires STM for a consistent view of the map, right?
02:40:40 <geekosaur> otoh if you're using it to synchronize access to a single data value then you can collapse the MVar and data value together, sure
02:40:40 <mivael> merijn, if I read the GHC user guide, would it be easy there to distinguish whether I'm reading about some GHC specific behaviour or, instead, about Haskell language itself?
02:41:10 <geekosaur> mivael, the ghc manual assumes the Haskell2010 standard as a base, but all the extensions are documented in one section of the manual
02:41:33 <saurabhnanda> if I lookup the ioref/mvar once before forking my thread, and put it in the thread's reader environment, will GHC be smart and not gobble up memory by creating copies of the map?
02:41:34 <geekosaur> so for the complete ghc story you need both, but the extensions are all together and marked as such
02:41:46 <mivael> geekosaur, that's great
02:42:22 <merijn> mivael: GHC is Haskell 2010 by default (well...mostly) unless explicitly told otherwise
02:42:47 <merijn> There's a couple of places where GHC defaults from Haskell2010, but most of those are minor (or oversights)
02:42:58 <orion> If I put a Map in a IORef and spawn 1,000 threads to concurrently access it without any locking, can I segfault my application?
02:43:33 <merijn> For example: GHC doesn't have Eq and Show as superclass for Num. GHC doesn't do cyclical imports automatically. GHC accepts some identifier names which are (technically) not legal
02:43:55 <merijn> orion: Not unless you run into weird bugs
02:43:59 <geekosaur> orion, potentially with one version of the containers package yes (because it does nasty unsafe things)
02:43:59 <ski> saurabhnanda : well, an option (probably not in your case) would be to use the same map when looking up `keyB', instead of getting from `MVar'/`IORef'
02:44:18 <ski> saurabhnanda : does "do something" involve updating and replacing the map ?
02:44:41 <saurabhnanda> ski: that makes writing the code harder. Have to keep passing around the map. Which is why I was thinking of putting in the thread's reader environment. But I'm not sure what that'll do to memory usage.
02:44:53 <mivael> merijn, is there a place where such "examples" are listed altogether?
02:44:58 <saurabhnanda> ski: no, it doesn't involve anything with the map. 
02:45:23 <merijn> mivael: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/bugs.html
02:45:45 <geekosaur> saurabhnanda, it'll do what it normally does. shared until something changes it, since Map is immutable you will end up with new Maps. which is why IORef or etc. if you need the changes to be visible elsewhere
02:46:02 <mivael> merijn, thank you
02:46:06 <merijn> mivael: So, yes :)
02:46:17 <merijn> mivael: As I said, the user guide is surprisingly good
02:46:41 * ski isn't sure what "the thread's reader environment" means
02:46:56 <saurabhnanda> geekosaur: does that mean if I spawn 1,000 threads that do a readIORef and never writeIORef, I'll keep consuming more and more memory?
02:46:59 <merijn> ski: Every thread is running a ReaderT, presumably
02:47:09 <saurabhnanda> ski: ReaderT Env IO
02:47:54 <geekosaur> saurabhnanda, what? no, as long as nothing changes it, it'll be using the same Map value. if you are storing an IORef, that's just a pointer, not the actual Map.
02:47:58 <ski> mhm. the expression sounded like you expected that to be standard equipment for threads
02:48:27 <saurabhnanda> geekosaur: what happens once I readIORef? do I get back the same pointer, or does it create a copy of the data?
02:48:44 <ski> no copy
02:48:54 <geekosaur> saurabhnanda, the usual rules apply, if you have an expression that keeps a given immutable Map value around and not letting it be garbage collected, that will leak memory.. .threads, IORefs, etc. dont change that
02:49:06 <geekosaur> no copuy. that was what I was teling you
02:49:09 <geekosaur> it's a pointer.
02:49:15 <geekosaur> not the Map itself
02:49:17 <saurabhnanda> ski: IMO it should be. I went running around in circles the first time I wanted to forkIO from within a ReaderT. Started researching lifted-base and what-note.
02:49:43 * ski idly wonders about distributed/cloud Haskell .. and baked regions (or how they were called)
02:49:54 <saurabhnanda> geekosaur: got it... so all reads point to the same memory location. Only when someone writes, the IORef starts pointing to the new memory location.
02:50:03 <geekosaur> correct
02:50:31 * geekosaur can't tell if ski means compact regions, static pointers, or a combination
02:50:34 <saurabhnanda> geekosaur: thanks. So that means, I can deref the IORef at the top of the thread, and put the map in a Reader and get a consistent view of the Map throughout the thread. Sweet.
02:50:58 <ski> probably compact regions
02:51:32 <merijn> How do I tell haddock to not report coverage for non-public modules?
02:54:43 * hackagebot thread-hierarchy 0.1.0.1 – Simple Haskel thread management in hierarchical manner – https://hackage.haskell.org/package/thread-hierarchy
02:56:51 <alexbiehl> merijin you can't
02:57:29 <merijn> alexbiehl: ugh
02:57:32 <alexbiehl> merijn ^^
02:57:55 <alexbiehl> You could send a PR :) 
02:58:24 <merijn> alexbiehl: I already have enough yaks :(
02:58:34 <tabaqui> I have mixed forkProcess/forkIO code
02:58:44 <tabaqui> and a bunch of ghc_worker zombie processes
02:58:48 <merijn> alexbiehl: There's a ton of stuff I want to see fixed in cabal-install too
02:59:11 <tabaqui> but I do getProcessStatus everywhere
02:59:38 <tabaqui> and moreover, forked processes aren't named as ghc_worker
02:59:57 <tabaqui> so, who spawns them?
03:04:45 * tabaqui out for 20 minutes
03:30:21 * hackagebot bitset-word8 0.1.0.0 – Space efficient set of Word8 and some pre-canned sets useful for parsing HTTP – https://hackage.haskell.org/package/bitset-word8
03:34:20 <jose999> Hi!
03:34:38 <jose999> I came across a bug in GHC, getting a message according to which I was asked to file a bug report
03:34:47 <jose999> The code is not open source, though
03:35:02 <jose999> Is code attached to bug reports confidential, or does such an option exist?
03:35:28 <ventonegro> jose999: Can't you try to replicate the bug with another test case?
03:35:35 <LiaoTao> jose999: Usually you would be asked to provide a minimal test case
03:35:45 <LiaoTao> That shouldn't violate any sort of copyright
03:36:09 <jose999> OK. I'll try that
03:37:29 <jose999> Thanks!
03:37:31 * tabaqui is back
03:45:45 <saurabhn_> jose999: and you you canvass the folks at GHC to do something about the level of information that GHC itself emits when it crashes. 
03:46:22 <saurabhn_> jose999: IME the GHC crash reports are pretty opaque. You don't even know where to begin.
03:46:26 <saurabhn_> anyways...
03:47:05 <pacak> jose999: Is your ghc recent enough?
03:48:03 <pacak> Even if code is not opensource - if it's reproduceable you can usually minimize the example down to a few lines.
03:49:04 * hackagebot hgrep 0.1 – Search Haskell source code from the command line – https://hackage.haskell.org/package/hgrep
03:49:41 <saurabhn_> is there an static/type-safe version of Map which can guarantee that certain keys exist at runtime?
03:50:50 <geekosaur> not without promoting (some?) keys to type level, or switching to a language with actual dependent types
03:51:39 <saurabhn_> if there are 100 such keys, what will it do to the compile times and the binary size?
03:52:18 <tdammers> I think the best you can do is use smart constructors, or make heavy use of metaprogramming
03:53:07 <opqdonut> saurabhn_: there's this trick, https://github.com/matt-noonan/justified-containers
03:53:57 <saurabhn_> tdammers: how will the metaprogrammig technique work? I have no problem with code-gen or TH. But is the result going to be a huge ADT of "keys"?
03:54:18 <tdammers> saurabhn_: yes, pretty much
03:54:36 <saurabhn_> tdammers: very large ADTs tend to stress the compiler, right?
03:54:47 <tdammers> saurabhn_: I'm thinking some sort of DSL to generate suitable record types and some sugar to program against it as if they were plain old maps
03:54:52 <opqdonut> well you could always use type level nats and encode the keys ... :)
03:56:23 <phadej> or just opaque SpecialKey a = SpecialKey a, and an opaque wrapper around Map as well, e.g. with 'create :: (SpecialKey a -> v) -> SpecialMap a v` etc.
03:56:55 <maerwald> go for Agda
03:56:57 <phadej> encapsulate "unsafe" code inside a module, and: profit
04:01:34 <saurabhn_> opqdonut: **conceptually** is justified-containers giving you an opaque reference to a key, that you get once you insert something. You need to carry that reference around to the lookup/call-site. Because you have the key's opaque reference, you have proven that it was definitely inserted. Did I understand it broadly?
04:01:47 <opqdonut> saurabhn_: yeah
04:02:03 <saurabhn_> opqdonut: so it's like Servant/Warp's Vault.
04:02:13 <opqdonut> saurabhn_: you can also get a reference by doing a membership query, of course
04:02:18 <opqdonut> I'm not familiar with Vault
04:02:29 <saurabhn_> tdammers: what kind of record types did you have in mind?
04:02:37 <saurabhn_> opqdonut: similar concept. Just drawing parallels.
04:03:16 <tdammers> saurabhn_: plain old Haskell records
04:03:46 <tdammers> saurabhn_: plus probably safe string-based accessors
04:04:01 <saurabhn_> tdammers: how large can a record be without blowing up GHC/RTS?
04:04:06 <tdammers> saurabhn_: no idea
04:04:23 <tdammers> saurabhn_: but if it's that large, you may want to do it at runtime after all
04:04:37 <tdammers> maybe go with the smart constructor approach then
04:04:48 <tdammers> newtype over string for the key, such that only expected keys are allowed
04:05:03 <tdammers> and newtype over the map, such that expected keys are always present
04:05:09 <saurabhn_> more context -- I'm planning to do this for static assets in a webapp.
04:06:19 <maerwald> is it that useful to engineer this in a "type safe" way when you know the assets are static and not user-input related?
04:06:57 <maerwald> or is this just "must be total" obsession :>
04:07:32 <saurabhn_> maerwald: must prevent stupid typos obsession.
04:07:48 <maerwald> typos?
04:08:19 <saurabhn_> you're typing out the path to a static asset in your own project, and the compiler can tell you there and then, that it doesn't exist.
04:08:38 <maerwald> so your keys are strings?
04:09:56 <saurabhn_> maerwald: which is what I'm trying to avoid.
04:11:14 <saurabhn_> over-engineering, I guess.
04:11:28 <lyxia> can't you use an ADT
04:11:45 <maerwald> yes, as tdammers said... newtype for the key + smart constructor
04:11:55 <tdammers> or, another approach
04:12:11 <maerwald> no reason to model a Map type with a total access function
04:12:12 <tdammers> 1. make an enum type with one constructor per static asset file
04:12:25 <tdammers> 2. write a function StaticAsset -> FilePath
04:12:36 <tdammers> (let's call it assetFilename)
04:12:55 <saurabhn_> tdammers: that was my first approach. But didn't jump at it because the list of static assets is only going to grow.
04:13:09 <saurabhn_> thus increasing the number of constructors. 
04:13:14 <tdammers> so what
04:13:19 <maerwald> I think ghc can handle that pretty well
04:13:26 <saurabhn_> have read a bunch of email on haskell-cafe about GHC issues with 100+ constructors.
04:13:27 <maerwald> darcs does some similar funky stuff too
04:13:32 <saurabhn_> not completely informed, TBH
04:13:33 <tdammers> I don't know what the limit on number of constructors is, but I'd expect it to be at least 65535
04:13:49 <saurabhn_> 65535 out to be enough for everybody :)
04:13:57 <tdammers> probably more though
04:13:59 <tdammers> idk
04:14:59 * hackagebot treefold 0.2.0.0 – Provides folds which try to combine elements in a balanced way. – https://hackage.haskell.org/package/treefold
04:17:35 <[exa]> it would be weird not to put arch-sized integer into the union tag btw (so I'd guess 2^64)
04:19:18 <merijn> saurabhn_: instance deriving becomes very slow with large numbers of constructors
04:19:59 <merijn> saurabhn_: If you don't plan to modify often (and thus can simply reuse previous compilations) that should only matter the first compile
04:23:01 <merijn> So, how do people deal with Haddock complaining about missing docs for unexported modules that aren't externally visible? Ignore them? Somehow silence them? Document them just to make haddock shut up?
04:23:19 <mivael> Does someone have an unstoppable desire :) to review a bit of Haskell code?  The code in question is about 1.5 KiB (2.8 KiB full source).  It is my solution to a toy problem (https://codechef.com/problems/GRID).  I need an advice (on general approach and code style) regarding the part responsible for parsing/preprocessing of input text cases.
04:23:40 <mivael> The code is here: https://www.codechef.com/viewplaintext/15598682
04:23:55 <mivael> I'm rather okay with 'solve' function and "import ..." part of the code.  My question is about the 'testCases' function.  How could I improve it (maybe to make it less verbose but without sacrificing readability)?  Comments on general approach to parsing are generally out of scope of my current question but they are also welcome (speed matters, using unsafe/unstable/rather_new libraries is undesirable).
04:24:19 <merijn> "import qualified Data.ByteString.Lazy.Char8 as BL8" <- I already dislike this code >.<
04:25:12 <mivael> merijn, because of BL8?
04:25:26 <merijn> https://github.com/quchen/articles/blob/master/fbut.md#bytestringchar8-is-bad
04:25:29 <bennofs> probably because of Char8
04:25:57 <merijn> mivael: More stylistic note, putting the 'where' on the end of line is very disorienting to me
04:26:39 <bennofs> that's just a preference though. i've used that style as well
04:26:44 <merijn> Especially without highlighting
04:27:06 <merijn> bennofs: I rarely see that style, so I'm going to assume most people would prefer it not being written like that
04:27:45 <bennofs> it has the advantage of not requiring aligning and not requiring double indent for everything after the where
04:27:54 <merijn> mivael: I also strongly dislike type aliases which rename types, it makes it unnecessarily tricky to figure out what kinda input a function takes
04:28:05 <merijn> bennofs: I just put the where on a half indent
04:28:15 <merijn> bennofs: i.e. indent where 2 spaces, definition 4
04:28:25 <mivael> merijn, do you recommend to use 'where' on a separate line and use additional indentation level for the code inside it?  Maybe an example of good indentation with "where"?
04:28:34 <bennofs> merijn: i've used 2 space indents in the past, and one space where indent is also not very readable :)
04:29:06 <bennofs> but yeah, I think the half-indent (2 spaces) and indent everything else 4 spaces is probably best
04:29:46 <merijn> mivael: This my style: https://github.com/merijn/broadcast-chan/blob/master/broadcast-chan-tests/BroadcastChan/Test.hs#L68-L125
04:29:50 <mivael> merijn, I thought it could help better understand semantics of used types.
04:29:51 <merijn> bennofs: Yeah, that's what I do
04:30:46 <merijn> mivael: I just get annoyed because some libraries make me click through 4 type aliases before I can see the *actual* type I have to pass as input, which gets annoying when you quickly wanna look stuff up
04:31:16 <jose999> pacak: I just noticed that I'm still on 7.10 on that machine; I'll try a recompile on the current GHC version
04:31:39 <jose999> pacak: The error message was rather amusing though, as I was told that "the impossible happened"
04:32:16 <merijn> jose999: That just means an internal invariant of GHC was violated
04:32:42 <mivael> merijn, bennofs: understood regarding indents
04:33:29 <merijn> mivael: For example when I saw "maxRockCol = accumArrayWith conv  where  conv (r, c) = (r, c)" I initially misread the 2nd = as being the function definition
04:34:06 <merijn> mivael: The input is just text?
04:35:20 <mivael> merijn, fair enough (on type clicks), alghough I'm not yet convinced (having a semantic type defined in one place could help avoid mistake if I want to replace, say, Int with Integer for this specific type, etc)
04:35:26 <merijn> mivael: If so I'd say use Text instead of ByteString
04:35:51 <mivael> merijn, yes, it is just 7-bit ASCII text
04:35:57 <merijn> mivael: Well, the type checker would just produce an error if you replace Int with Integer in a way that doesn't work
04:36:01 <mivael> merijn, Text is slow
04:36:16 <merijn> mivael: Should be barely slower than ByteString
04:36:23 <merijn> mivael: Are you sure you're not thinking of String?
04:36:45 <mivael> merijn, no, I'm not sure :)
04:37:02 <merijn> mivael: String does, indeed, suck. Since it's a linked list of Char
04:37:03 <mivael> merijn, I should try it with Text, then...
04:37:17 <merijn> mivael: Text is densely encoded unicode blobs
04:37:45 <merijn> mivael: The problem with Char8 is that it silently corrupts unicode input/output
04:39:23 <merijn> I wonder if we could just makes a bytes library with a Bytes type and then the bytestring package just reexports bytes with a type alias of ByteString so old code stays working but we can in the long run eliminate the stupid historical name
04:40:35 <mivael> merijn, if I use Int for several types in code and then I need to change Int-->Integer only for one of them, the process of changing could be error prone I think
04:41:31 <merijn> mivael: Haskell has no implicit type coercion, so you just hit compile, look at type errors and update them one by one. I personally find it a rather Zen activity ;)
04:42:17 <mivael> merijn, but unicode seems to be an unnecessary overhead when dealing with ascii-7 only
04:43:12 <merijn> mivael: Until you forget that and a year later you have to debug an obscure issue due to not getting ascii-7 input :p
04:43:28 <mivael> merijn, and I do not care about corrupting unicode chars in such toy problems -- unicode is never there
04:43:39 <opqdonut> unicode is definitely there for most of us
04:43:51 <merijn> mivael: My advice will always be: Always use Text first and *maybe* replace it after profiling PROVES it's crucial
04:44:05 <opqdonut> (here in europe)
04:44:09 <merijn> You should always default to something that works
04:44:31 <merijn> opqdonut: Can't even spell my name right on IRC because of ASCII's cultural imperialism :(
04:45:04 <merijn> cocreature: ping?
04:45:17 <opqdonut> merijn: indeed
04:45:32 <mivael> opqdonut, ever encountered unicode in competitive programming context?
04:47:37 <mivael> merijn, I maybe try the same problem with Text and compare.  I vaguely remember that in the past I was advised to use Text but then I failed to find there some functionality which blocked me from using Text that time.  Can not remember details, unfortunately.
04:47:54 <opqdonut> mivael: fair enough.
04:48:06 <mivael> s/I maybe try/I will maybe try/
04:48:54 <merijn> mivael: Some of the IO functionality (like interact) are, unlike bytestring, hidden in a separate module for Text
04:48:59 <merijn> mivael: Data.Text.IO to be exact
04:50:09 <mivael> merijn, but what about my 'textCases' function?  Do you like the approach (and the code) except for your above comments?
04:50:11 <merijn> mivael: Honestly, I'm like 80% sure you could port your code by just replacing the ByteString import with "import qualified Data.Text as BL8; import qualified Data.Text.IO as BL8" since I think all functions you use have exact equivalents :p
04:51:14 <merijn> mivael: It looks mostly reasonable to me
04:51:46 <merijn> mivael: (i.e., I don't notice any flaws that are obvious without scrutinising the exact code in more detail than I can be arsed atm)
04:51:49 <mivael> merijn, I do not feel the porting will be *that* simple but I will definitly give it a try too :)
04:52:00 <mivael> * definitely
04:52:25 <merijn> mivael: Personally I've started adding type signatures on all where-clauses as well, but that's far from common
04:53:07 <bollu> merijn: You need ScopedTypeVariables for that to work correctly in many cases
04:53:11 <merijn> mivael: Maybe add some whitespace after multi-line definition? i.e. between "rockCols" and "injectRowIndices" to make it easier to scan where definition end
04:53:14 <mivael> merijn, I felt unsure about that function: it seems to me like too large for that simple purpose it does
04:53:14 <merijn> bollu: True
04:55:14 <merijn> mivael: A bit, but I also don't see any obvious way to split things up
04:55:30 <mivael> merijn, accepted about whitespace
04:56:35 <mivael> merijn, "adding type signatures on all where-clauses"  --  you mean to use a type signature for each definition inside each 'where' clause?
04:56:52 <mivael> s/to use/to define/
04:57:34 <michalrus> Hey, runtime question: if I use `forever (do something)`, and in that `something` I jump to another function from which I’ll never return to that `forever`… will the effectively-no-longer-referenced stuff from around that `forever` be collected?
04:58:01 <merijn> mivael: Like I said, that one is rather controversial :)
04:58:12 <merijn> mivael: I've been doing it for awhile, but many others don't
04:58:29 <merijn> michalrus: Don't think so, but not sure
04:58:45 <merijn> michalrus: As always when it comes to memory usage: Have you tried profiling? :)
04:58:51 <michalrus> No. :]
04:58:55 <michalrus> Okk. (=
04:59:18 <merijn> michalrus: The profiling output produced by GHC is pretty detailed and useful
05:00:40 <michalrus> OK, I’ll do that.
05:00:52 <mivael> merijn, regarding porting to Text (except additionally replacing ByteString with Text): Not in scope: ‘BL8.readInt’
05:01:51 <merijn> mivael: There's a "decimal :: Integral a => Reader a" in Data.Text.Read
05:03:53 <mivael> merijn, not acquaintant yet with the conception of Reader...  I said it won't be that easy ;)
05:05:45 <saurabhnanda> Data.Map.Strict or HashMap -- which is faster?
05:06:34 <saurabhnanda> Data.Map.Strict vs Data.HashMap.Strict ?
05:06:47 <merijn> mivael: It's basicall "Text -> Either String (a, Text)"
05:07:54 <bollu> saurabhnanda: hello :) how is it going?
05:08:04 <mivael> merijn, the String instance is an error message?
05:08:14 <merijn> mivael: Yeah
05:08:20 <mivael> thanks
05:08:33 <saurabhnanda> bollu: all well... racing towards pushing a build into production.
05:09:37 <bollu> saurabhnanda that is pretty awesome! That you're putting hask into production :) 
05:10:29 <saurabhnanda> bollu: let's hope we live to tell the tale :)
05:12:13 <lyxia> saurabhnanda: it depends on the size of the key. Small keys are fast to compare directly, large keys are worth hashing first.
05:12:39 <saurabhnanda> most of our domain code is in a generic 'm' monad that is type-class constrained. Is it a better idea to have a ProductionM and a DevM monad implementing all the various type-classes, or to have a single AppM monad with a bunch of conditionals that depend on AppEnv?
05:14:48 <bollu> saurabhnanda I would personally prefer the former
05:14:53 <bollu> saurabhnanda it feels cleaner.
05:15:24 <saurabhnanda> lyxia: what's the thumb-rule  to determine small/large.
05:20:01 <lyxia> benchmark
05:23:35 <sacka> is a good practice to stack more than 2-3 Writer/Reader/State Monad?
05:24:16 <merijn> sacka: No :p
05:24:23 <saurabhnanda> sacka: no
05:24:28 <ertes-w> sacka: occasionally, but you'll know when you need it
05:24:34 <osa1> I'd say in practice you never need Writer because using Writer for logging is too inefficient and most of the time logging is why people try to use Writer ;-)
05:24:36 <ertes-w> sacka: in other words: if you have to ask, then no =)
05:24:37 <merijn> sacka: Stacking more than one is already questionable
05:24:42 <sacka> ok at least I understood this :)
05:24:42 <saurabhnanda> sacka: I have even taken out LoggingT. Just a ReaderT over IO.
05:25:16 <osa1> ReaderT over IO is also what I do these days because I need concurrency
05:25:45 <ertes-w> i also question the utility of ReaderT
05:25:58 <sacka> osa1: what for?
05:28:07 <osa1> sacka: we do lots of networking + handle async events (coming from HTTP endpoints and some other sources)
05:30:42 <sacka> osa1 so basically it is a `ReaderT env STM`? and then call atomically to perform IO?
05:30:56 <osa1> sacka: no it's a `ReaderT env IO`
05:31:21 <ertes-w> to me ReaderT is kinda like OOP: people love to think that it's super-useful, so they just gravitate toward it whenever they need to pass information around, and they come up with all sorts of workarounds (including crazy stuff like monad-control) for dealing with the extra layer, which is especially questionable in the very common (ReaderT _ IO) case
05:31:33 <osa1> you need IO at the base to be able to use `lifted-async` or `lifted-base` (or their unliftio variants)
05:31:55 <ertes-w> i maintain that neither ReaderT nor OOP have a single legitimate use case
05:32:13 <osa1> STM would probably work if only thing you do concurrently is updating variables, but we do other effects (logging, updating DBs, networking etc.)
05:33:28 <bollu> ertes-w what do you think of plain Reader?
05:33:39 <osa1> ertes-w: so you prefer passing a logger backend, a database handle, a state plus more parameters to do some work in a thread? OK then don't use ReaderT
05:33:48 <ertes-w> bollu: i love it
05:34:15 <ertes-w> bollu: unless by "Reader" you mean something other than (->) =)
05:34:34 <saurabhnanda> ertes-w: hyperbole, much?
05:34:51 <ertes-w> just try it out
05:35:09 <ertes-w> replace (ReaderT E IO A) by (E -> IO A), and just go with it
05:35:17 <ertes-w> i promise that everything will get simpler
05:36:40 <saurabhnanda> no, it won't. because this doesn't have the answer for getting slightly different behaviour in production and test environment, which type-class constrained monads provide. And if you are going to use a type-class constrained monad, might as well go with a ReaderT as well.
05:36:41 <ertes-w> some library dependencies (like lifted-*) go away, your types become simpler, your code becomes simpler, even in the few cases where a function might become slightly larger, all liftIOs go away, …
05:36:41 <bollu> rete no
05:38:41 <ertes-w> the concept of implicit information passing can be useful for some DSLs, but ReaderT on its own is not a DSL…  it's just a bad compromise for saving a few function applications
05:40:56 <bollu> ertes-w why does the same argument not apply for Reader in that case
05:41:03 <ertes-w> i'd go as far as to say that a class like MonadReader suffers from something that is strongly related to boolean blindness
05:41:14 <ertes-w> bollu: Reader is just (->)
05:41:20 <bollu> ertes-w so?
05:41:27 <bollu> ertes-w so is readerT in a very real sense
05:41:35 <bollu> considering we can make the substitution you propose
05:41:51 <ertes-w> bollu: (ReaderT E IO) has no Reader counterpart
05:41:57 <bollu> ReaderT r m a ~= r -> (m a)
05:42:04 <saurabhnanda> does Aeson have optimised functions to read JSON from disk?
05:42:31 <ertes-w> bollu: the substitution i propose doesn't even make sense for Reader
05:43:25 <mivael> merijn, also there is a need for Text-based equivalent of the following ByteString-ish expression: ( (intDec n) <> (char7 '\n') )
05:43:27 <ertes-w> bollu: again, i'm assuming this:  type Reader = (->)
05:43:48 <ertes-w> bollu: in that sense values of type (Reader E A) are functions, literally
05:44:07 <bollu> ertes-w: so are ReaderT, they are slighly complicated functions
05:44:17 <bollu> what's your point
05:44:22 <ertes-w> bollu: no, they are not
05:44:35 <ertes-w> > (ReaderT pure) ()
05:44:38 <lambdabot>  error:
05:44:38 <lambdabot>      • Couldn't match expected type ‘() -> t’
05:44:38 <lambdabot>                    with actual type ‘ReaderT a0 m0 a0’
05:44:47 <bollu> ertes-w: they
05:44:49 <ertes-w> can't apply it, so it's not a function
05:44:54 <bollu> ertes-w it's a newtype wrapper
05:44:57 <saurabhnanda> bollu: ertes-w: I have a suggestion. Why don't both of you take 20mins from this non-productive debate and contribute to documentation of your favourite haskell project. Just saying.
05:44:59 <merijn> mivael: Either T.snoc to append a Char, or '<> T.pack "\n"', or (using OverloadedLiterals) '<> "\n"'
05:45:06 <bollu> saurabhnanda :)
05:45:31 <bollu> saurabhnanda I'm hoping to understand ertes-w's worldview
05:45:56 <mivael> merijn, thanks, looking into it...
05:46:21 <ertes-w> bollu: i explained it as best as i could: using (ReaderT E M A) involves a heavy compromise, especially when M = IO
05:46:30 <ertes-w> bollu: compared to (E -> M A)
05:46:48 <ertes-w> s/best/well/
05:47:30 <ertes-w> plus MonadReader is a pretty meaningless effect class
05:47:43 <ertes-w> it's not tied to any particular logic/semantics
05:47:49 <mivael> merijn, and about the "intDec n" part?...
05:47:59 <merijn> mivael: What's that do?
05:48:15 <mivael> :t intDec
05:48:16 <lambdabot> error: Variable not in scope: intDec
05:48:33 <ertes-w> the latter is what i meant when i said that "MonadReader suffers from something that is strongly related to boolean blindness"
05:48:42 <mivael> merijn, intDec :: Int -> Builder
05:48:51 <merijn> mivael: https://hackage.haskell.org/package/text-1.2.2.2/docs/Data-Text-Lazy-Builder-Int.html :)
05:50:51 <mivael> merijn, thanks!  And sorry  :)
05:51:45 <foolswood> I'm getting errors from c2hs on the members of an anonymous struct. Any ideas to get around this or am I just going to have to rewrite the C not to have them?
05:55:28 <tabaqui> I want to report issue in hs-tls
05:55:49 <tabaqui> should I do it in github tracker, or vincentz is about here?
05:55:57 <tabaqui> *vincenthz
05:57:59 <ertes-w> tabaqui: github
05:58:16 <tabaqui> fine
06:04:50 <sacka> Every time you use unsafePerformIO, a kitten dies.
06:04:53 <sacka> is this true?
06:05:22 <merijn> sacka: Every time you use unsafePerformIO GHC might kill 0, 1, or an unknown number of kittens
06:05:47 <tdammers> actually, if you use unsafePerformIO, the kitten may even die multiple times
06:06:10 <sacka> oh I'm a murderer
06:06:35 <sacka> is that still valid if it was for science?
06:06:39 <ertes-w> sacka: unsafePerformIO is a bit like monte schrödinger carlo's thunk…  when you evaluate it a kitten might die with some small probability, but you don't know how often you're gonna evaluate it
06:06:45 <DigitalKiwi> I've found it highly advantageous to dislike cats
06:07:45 * hackagebot c-mosquitto 0.1.1.0 – Simpe mosquito MQTT binding able to work with the Amazons IoT – https://hackage.haskell.org/package/c-mosquitto
06:08:34 <sacka> jokes apart is it because is not *deterministic* uresult?
06:08:47 <sacka> unsafePerformIO result*
06:10:03 <pacak> sacka: There's also accursedUnutterablePerformIO.
06:10:17 <mnoonan> don't worry, you can bring the kittens back to life with accursedUnutterablePerformIO
06:10:50 <merijn> sacka: Basically, GHC does not guarantee how often your code gets evaluated and when. The IO type has some voodoo that stops GHC from breaking stuff
06:11:03 <pacak> sacka: You can do all sorts of things with it. Including some very  dangerous ones.
06:11:15 <merijn> sacka: But when you use unsafePerformIO to get rid of the IO you're basically lying to GHC saying "this is pure", and then it secretly isn't
06:11:36 <pacak> More like "hold my beer"...
06:11:54 <merijn> sacka: Since if you, say print to stdout, and GHC evaluates it 5 times, now you accidentally print 5 times. Whoops
06:12:02 <ertes-w> sacka: unsafePerformIO getChar :: Char
06:12:04 <ertes-w> sacka: right?
06:12:19 <Psybur> > unsafePerformIO $ putStrLn ":D"
06:12:21 <lambdabot>  error:
06:12:22 <lambdabot>      Variable not in scope: unsafePerformIO :: IO () -> t
06:12:49 <pacak> % unsafePerformIO $ putStrLn ":D"
06:12:50 <yahb> pacak: :D; ()
06:13:19 <mivael> merijn, for your information: Text-->ByteString porting is done! :)   The Text-based version works.   It is slower (fast enough, though): 690 ms --> 870 ms.  Thank you for your advices and support!
06:14:16 <pacak> % (unsafeCoerce [4 :: Int]) :: Maybe Int
06:14:16 <yahb> pacak: Just 4
06:14:18 <Psybur> % map unsafePerformIO [putStrLn ":D", putStrLn "D:", putStrLn ";]"]
06:14:18 <yahb> Psybur: [:D; (),D:; (),;]; ()]
06:14:27 <pacak> % (unsafeCoerce []) :: Maybe Int
06:14:27 <yahb> pacak: Nothing
06:14:48 <pacak> Theoretically you can use unsafeCoerce as listToMaybe function.
06:14:57 <pacak> It will even work.
06:16:50 <pacak> % unsafeCoerce (134 :: Int) :: Bool
06:16:50 <yahb> pacak: False
06:16:56 <pacak> O_O
06:17:07 <pacak> Y U NO explode?
06:17:25 <sacka> lol
06:17:30 <ertes-w> % (unsafeCoerce () :: [()]) !! 10000
06:17:31 <yahb> ertes-w: *** Exception: Prelude.!!: index too large
06:17:42 <merijn> sacka: All in all, things can be summarised by
06:17:49 <merijn> @quote is.not.a.bug
06:17:49 <lambdabot> Lemmih says: "I don't understand why my code acts weird when I use unsafePerformIO" is not a bug.
06:18:24 <ertes-w> sacka: if you agree that (unsafePerformIO getChar :: Char), then you agree that (unsafePerformIO getChar) is a character
06:18:40 <ertes-w> sacka: so which character is it?  please answer in the form of an equation, not a sentence
06:19:10 <Athas> merijn: I think that quote is disingenuous.  In practise, unsafePerformIO is sometimes the right tool for the job in Haskell.  It should be possible to use it correctly and robustly (and ideally, to get some advice on how to do that).
06:19:35 <ertes-w> sacka: if your response to that is, "that doesn't make sense!", then you understand why unsafePerformIO is problematic: it violates haskell's semantics
06:19:47 <merijn> Athas: That quote doesn't say anything about not using unsafePerformIO
06:20:09 <merijn> Athas: Only, that if you use it, you don't get to claim weird behaviour is a bug
06:20:10 <Athas> merijn: no, but it's a quote that usually seems to be brought up when people are confused about unsafePerformIO, but it does not make anyone less confused.
06:20:50 <ertes-w> sacka: so whenever you do that violation, you need to compensate, and that is difficult and error-prone
06:20:58 <Athas> I'll happily maintain that the current widespread use of unsafePerformIO is a bug!  (At least in the sense "this should not be necessary.")
06:21:06 <ertes-w> sacka: basically you need to do the violation such that from outside it isn't observable
06:21:13 <Itkovian> merijn How's the parallel conduit? :)
06:21:21 <pacak> % unsafeCoerce (Left 123 :: Either Int Int) :: Maybe Int
06:21:21 <yahb> pacak: Nothing
06:21:24 <sacka> ertes-w: can I say that actually I understand what you are trying to say about unsafePerformIO, but your words are like dogmas?
06:21:34 <pacak> Yea, that's more like it.
06:21:56 <pacak> % 1 + 1
06:21:57 <yahb> pacak: 2
06:22:02 <pacak> Oh noes...
06:22:23 <opqdonut> yet another haskell bot?
06:22:39 <merijn> Itkovian: Works well enough to try. The library is still unreleased, though
06:22:50 <merijn> Itkovian: https://github.com/merijn/broadcast-chan
06:23:00 <sacka> I mean ok, it's a monad, you cannot "escape" from it but still you didn't answered why is it illegal to use... btw thanks to merijn and pacak for actually explaining me
06:23:01 <Itkovian> merijn I was looking at https://gist.github.com/nh2/321567bb68e9efa6e299eb6b2410a1fb, which more or less can be used, I think, though the overhead of synchronisation is pretty large. I changed it to no longer require identical ordering
06:23:06 <merijn> Itkovian: Specifically the broadcast-chan-conduit dir
06:23:14 <Itkovian> I'll take look, thx
06:23:16 <merijn> Itkovian: Oh, yeah, I don't maintain ordering
06:23:26 <Itkovian> I do not need that anyway
06:23:38 <Itkovian> I need to parse log messages and turn them into JSON
06:23:39 <pacak> % (unsafeCoerce Nothing) :: Either Int Int
06:23:41 <yahb> pacak: Left [Segmentation fault]
06:23:43 <pacak> HA!
06:23:51 <Itkovian> so each message stands on its own after I chop up the input stream into lines
06:23:58 <merijn> Itkovian: Basically I spawn N workers, buffer N jobs and then I pass in a new job as soon as one finishes
06:24:10 <mivael> merijn, the detailed summary of changes, in case you were curious: ByteString --> Text,   toLazyByteString --> toLazyText,  ((intDec n) <> (char7 '\n')) --> ((Builder.decimal n) <> (Builder.singleton '\n')),  (fromJust . BL8.readInt) --> (fromRight . BL8.decimal),   T.Lazy,T.Lazy.IO,T.Lazy.Read as BL8,   T.Lazy.Builder,T.Lazy.Builder.Int as Builder,   fromRight re-implementation (too new)
06:24:14 <ertes-w> sacka: why are they like dogmas?  haskell has a semantics whereby you can always express yourself in terms of equations…  if you can no longer do that, then you have violated that semantics
06:24:27 <ertes-w> sacka: j       
06:24:30 <pacak> sacka: Amongst other things IO ensures that events happen in a specific sequence. First you launch missiles, then you get a bunch of explosions somewhere
06:24:48 <ertes-w> sacka: in particular if a value is of type Char, then it's either a certain character, or it's undefined
06:24:59 <merijn> Itkovian: I'm working on a complete revamp of broadcast-chan for a future 1.0 release. I'll probably release a 0.2 version on hackage somewhere in the coming weeks so it can be used more easily (with 0 API stability promises, though)
06:25:05 <ertes-w> sacka: "undefined" in the sense of the 'undefined' value, not in the sense of "determined at run-time"
06:25:10 <Itkovian> merijn tailored towards a certain length of time per job? since mine are typically ~ 20- 100 usec (according to criterion)
06:25:23 <pacak> With unsafePerformIO you can have them in the opposite order. Or repeated multiple times. Since haskell is pure some calculations can be performed multiple times and results will be the same
06:25:30 <merijn> Itkovian: Ah, I'm not sure how much the overhead will affect things
06:25:36 <pacak> If you perform an IO operation multiple times - results will be different.
06:25:40 <Itkovian> I'm ok with no API promises as well, my tool needs a revamp to suport kafka anyways
06:25:57 <merijn> Itkovian: MVar performance might kill you with 100usec jobs
06:26:17 <Itkovian> Well, I get a 2x speedup with 4 concurrent workers
06:26:24 <pacak> sacka: https://github.com/tibbe/unordered-containers/issues/147 - read this + related ghc ticket. In this case it was a bug in ghc, but the same effect and be achieved with unsafePerformIO.
06:26:25 <merijn> Itkovian: Should be easy to test, though! I have a (very naive) testing setup that uses threadDelay to confirm I get roughly linear speedup
06:26:44 <merijn> Itkovian: Do you have cabal-install 2.x?
06:26:50 <Itkovian> yes
06:26:52 <Itkovian> well, stack has it
06:27:19 <merijn> Itkovian: ok, I have no clue how to make things work with stack, but the cabal.project in the root of the repo makes it work with new-build
06:27:27 <mivael> merijn, From now on, I will try to avoid ByteString, favoring Text.  Additionally, I learned from you today that it is possible to use the same alias for several 'import qualified ... as ...' statements.  I never used it this way.
06:28:36 <merijn> Itkovian: Should be easy enough to copy some of the Test-Suite code for benchmark things
06:28:42 <Itkovian> ah merijn, I see you've been at HiPEAC :)
06:28:52 <merijn> mivael: ByteString is fine, as long as you pretend the type is just called "Bytes"
06:29:20 <merijn> mivael: And use it for binary data (binary files, network transmission, etc.)
06:29:38 <mivael> merijn, I understand
06:29:45 <sacka> pacak: thanks for the link
06:30:06 <merijn> Itkovian: Yeah, although I'm curious where you got that from?
06:30:29 <Itkovian> I looked at your uni page :)
06:32:39 <foolswood> Is c2hs still a reasonable way to write an FFI or is there something else I should look into?
06:32:50 <ertes-w> sacka: there are operational and semantical aspects to unsafePerformIO…  operationally it's just unpredictable, and that's because GHC actually relies on the semantics just as much as the programmer
06:33:38 <merijn> foolswood: It Depends
06:33:53 <merijn> foolswood: It's not particularly advanced/smart
06:34:25 <merijn> foolswood: You could try using c2hsc which I think has more complete C support (but requires some manual tweaking sometimes)
06:37:48 <foolswood> I'll give it a shot.
06:50:35 <saurabhn_> what's the most efficient way to read a large json file (20 MB+), out of which I'm going to use only a very small component?
06:52:56 <merijn> aeson, probably
06:55:06 <saurabhn_> is using BSL.readFile along with eitherDecode "safe" from a lazy-IO point of view?
06:58:41 <foolswood> merijn: c2hsc's output is definitely more obvious, still doesn't understand anonymous unions but since I can see what's going on maybe I can fix that by hand (at least for now).
06:59:17 <merijn> foolswood: c2hsc is intended to be handfixed for anything besides the most trivial code
06:59:56 <merijn> foolswood: So it's mainly to eliminate the boring boilerplate parts
07:20:41 <hexagoxel> why does ~ have higher precedence than ': ?
07:20:46 <hexagoxel> is ~ syntax?
07:21:23 <hexagoxel> (the type-family type equality constraint)
07:22:41 <orion> I don't get why people write code like "g = (unWrap <$>) . toFunction sendRequest f". It's so pointless!
07:23:25 <c_wraith> hexagoxel: it's probably re-using the pattern parser, somewhat, and it's high-precedence syntax there
07:23:52 <merijn> orion: partially applied <$> is so uggly >.< why not just fmap :(
07:24:04 <c_wraith> hexagoxel: though you're right that it seems like it should be the lowest-precedence in a constraint
07:24:13 <orion> merijn: I was making a pun.
07:24:19 <merijn> orion: I know :)
07:24:29 <merijn> orion: But I stil felt compelled to be pedantic!
07:25:38 <lyxia> saurabhn_: you might like something like https://github.com/bos/aeson/pull/560
07:31:02 <mivael> For those curious, an updated version of my code.  Tried to follow the advices by merijn (except for type aliases).  Also some re-styling, and 'testCases' made a bit more brief (after rethinking on readability).  https://www.codechef.com/viewplaintext/15599820
07:41:50 <ertes-w> mivael: to be honest i find that code hard to read, because each time i see a type i need to track down what it expands to
07:42:22 <c_wraith> Yeah, I also think those type aliases are not useful.
07:44:47 <ertes-w> mivael: also rename your fromRight to unsafeFromRight
07:45:16 <Itkovian> merijn Ideally, I'd need to a apply a pure function, so a -> b, not a -> IO b. I'll try and look at your stuff sometime this week.
07:45:59 <ertes-w> mivael: in general i think you're using a lot of bottoms ('error') for no apparent reason
07:46:36 <merijn> Itkovian: Well, that's trivially solved, no?
07:46:45 <merijn> Itkovian: "return . f"
07:47:22 <merijn> Itkovian: Gotta make sure the result is forced before being returned, though
07:52:33 <mivael> ertes-w, what would you use instead of those 'error'?
07:54:23 <ertes-w> mivael: i would handle the failure cases
07:54:34 <mivael> ertes-w, why the name?  Is it less safe than the original Data.Either.fromRight?
07:55:05 <ertes-w> mivael: if your function is of type (A -> B), but it may not be able to produce a result depending on the argument, then it should have type (A -> Maybe B)
07:55:09 <ertes-w> mivael: yes
07:55:24 <ertes-w> > fromRight 0 id (Left ())
07:55:28 <lambdabot>  error:
07:55:28 <lambdabot>      • Couldn't match expected type ‘Either a1 (Either () b0 -> t)’
07:55:28 <lambdabot>                    with actual type ‘a0 -> a0’
07:55:28 <mivael> ertes-w, grace handling of failures seems costly for me in competitive programming context
07:55:35 <ertes-w> :t fromRight
07:55:37 <lambdabot> b -> Either a b -> b
07:56:00 <ertes-w> > fromRight 0 (Left ())
07:56:03 <lambdabot>  0
07:56:18 <ertes-w> mivael: competetive in what sense?
07:56:27 <ertes-w> what are you competing on?
07:56:41 <mivael> ertes-w, c_wraith: It seems I should really try to avoid type aliases, and compare for myself...
07:57:10 <ertes-w> mivael: obviously not code size, otherwise you would have avoided the type aliases =)
07:57:47 <mivael> ertes-w, in this sense: https://en.wikipedia.org/wiki/Competitive_programming
07:57:53 <c_wraith> mivael: the real problem with type aliases is that they provide no safety.  If you're giving them semantic meaning, it's immediately lost and you're losing the value of the type system.
07:58:27 <ertes-w> mivael: yes, but what are the criteria?
07:58:50 <c_wraith> mivael: type aliases are great when your goal is to abbreviate a common use.  They're awful if you want to signify that a type has a different meaning than another type
07:58:52 <mivael> ertes-w, I use type aliases in C++ competitive programming by the way (despite the size), because it allows me spend less time debugging...  (in short)
07:59:33 <ertes-w> mivael: if you want to reduce debugging time it's more important to think of reusable, total patterns than what to name types
07:59:53 <ertes-w> for example functions like 'foldr' and 'map' eliminate many classes of bugs
08:00:30 <ertes-w> in fact 'error' is probably one of your worst enemies when it comes to reducing bugs
08:02:11 <mivael> ertes-w, oh, it seems I misread the fromRight type signature
08:03:07 <ertes-w> easy mistake to make:  fromRight is not like fromJust =)
08:03:32 <ertes-w> fromJust is the bad guy
08:03:42 <mivael> c_wraith, yes, but I do not loose this semantic when reading/modifying the code.  Those aliases usuallly help me, I think.
08:07:22 <mivael> ertes-w, regarding the criteria: I meant that I should rely that the input is always as specified, I should not gracefully handle errors in input...  Why I do this in a minimalistic way, then?  Because when I run tests loaclly, the input can still be erroneous.  Those short error messages is a compromise, just to allows me not to spend musc time in finding out silly mistakes in my tests.
08:08:03 <mivael> s/loaclly/locally/
08:08:35 <mivael> s/musc/much/
08:09:31 <mivael> This is what I meant speaking about handling failures in "competitive programming context".
08:11:18 <mivael> c_wraith, maybe they're really awful if one want to signify type meaning... but what is NOT awful then in Haskell for this purpose?
08:12:59 <ertes-w> mivael: there are better ways to handle failure than outright crashing
08:13:07 <mivael> ertes-w, can you provide an example of reusable, total patterns please?  I'm not sure I understand what you propose to do instead of using type aliases.
08:13:16 <ertes-w> :t (>>=) :: Maybe a -> (a -> Maybe b) -> Maybe b
08:13:18 <lambdabot> Maybe a -> (a -> Maybe b) -> Maybe b
08:13:52 <ertes-w> mivael: if you have a value of type (Maybe a) and a function of type (a -> Maybe b), you can compose them with (>>=)
08:14:12 <ertes-w> mivael: if you have a value of type (Maybe a) and a function of type (a -> b), you can compose them with (<$>) a.k.a. 'fmap'
08:14:13 <ertes-w> etc.
08:14:33 <ertes-w> you can then choose where you would like to handle failure
08:14:44 <ertes-w> similarly for Either
08:15:35 <ertes-w> mivael: you might even find this easier in the end, because whenever you get a Maybe, you can just go with it
08:15:51 <ertes-w> don't unpack it, just return it as it is
08:18:06 <mivael> ertes-w, but sooner or later I will be forced to decide what my program will do in case of Nothing...  Either the same old 'error' or ...?  What is the second option?
08:19:36 <nshepperd_> Crashing is a pretty good way to handle failure that definitely indicates a bug that you have to fix right now
08:19:51 <ertes-w> mivael: the second option is to handle the error
08:20:10 <ertes-w> nshepperd_: as far as i can tell these aren't bug-type errors, but bad inputs to the program
08:20:56 <nshepperd_> The input is provided by the contest organizer
08:21:02 <ertes-w> mivael: handling an error sometimes just means showing the user an error message in a deterministic way at useful points in your program
08:21:03 <mivael> ertes-w, what specific way of handling an input error I could use in competitive programming context?
08:21:33 <nshepperd_> So pretty much any "bad input" means you have a bug
08:21:49 <c_wraith> mivael: use newtype is you want to signify different meaning.  then the compiler will tell you if you got confused somewhere.
08:21:51 <ertes-w> mivael: if you were in an IO context i'd say: just throw an exception
08:21:54 <c_wraith> *if you want
08:21:59 <ertes-w> but unfortunately you're in an 'interact' context
08:22:06 <ertes-w> that makes things very difficult and ugly
08:22:40 <ertes-w> mivael: well, anyway, this is a matter of program design…  it may not be that important in your case
08:22:54 <mivael> ertes-w, now that's interesting!  Please say me more about ugliness of 'interact'.
08:24:03 <mivael> ertes-w, I did not expect that 'interact' is a bad way of writing such kind of simple (text filter) problems
08:25:15 <ertes-w> mivael: rarely will the 'interact' pattern be flexible and predictable enough to facilitate writing useful programs…  for example indeed your only way to "fail" (or even just write to stderr for diagnostics) is by outright crashing
08:25:19 <mivael> I have an input, I will process it and print the results to the output...  I thought that 'interact' is ideal for such case.
08:26:05 <mivael> ertes-w, I agree... but what pattern should I use, instead?
08:27:07 <mivael> ertes-w, is there a good example somewhere of a flexible pattern?
08:28:26 <ertes-w> mivael: perhaps in the end the final program could be nicely expressed in terms of 'interact', but there is a progression period toward the final program, where it would be really useful not to be locked out of such basic things as "printf debugging"
08:28:35 <ertes-w> mivael: that depends on your level of haskell
08:28:57 <ertes-w> mivael: well, actually you can recover some of "printf debugging" by using Debug.Trace
08:29:42 <mivael> ertes-w, I use 'trace' actively when I need to debug my Haskell code, and I like it by the way :)
08:30:44 <ertes-w> mivael: for now just rename fromRight to unsafeFromRight =)
08:31:06 <mivael> :)
08:31:18 <ertes-w> mivael: i'm not necessarily suggesting to go back to IO, but you asked me to justify the "unsafe" =)
08:31:45 <mivael> ...and excessive use of 'error' in my code
08:34:37 <the_2nd> how can I make lambdabot execute something?
08:34:49 <mivael> ertes-w, no, really.  Could you provide me with a (couple of?) template program which does simple text processing and minimalistic enough (and scalable/flexible to writing real-world useful programs)?  I would try to rewrite my code in that pattern and compare (and I would give you my feedback, then).
08:35:26 <shapr> the_2nd: try this: > map (+1) [1..9]
08:35:27 <mivael> the_2nd, prepend your expression with ">"
08:35:37 <mivael> > "like this"
08:35:39 <lambdabot>  "like this"
08:35:41 <the_2nd> > (,) <$> [0..4] <*> [0..3]
08:35:42 <Sornaensis> > sum [1..]
08:35:44 <lambdabot>  [(0,0),(0,1),(0,2),(0,3),(1,0),(1,1),(1,2),(1,3),(2,0),(2,1),(2,2),(2,3),(3,...
08:35:48 <lambdabot>  mueval-core: Time limit exceeded
08:35:56 <the_2nd> how can I do the same as above, but x counting first?
08:36:10 <the_2nd> (0,0), (1, 0), ...
08:36:29 <the_2nd> where 0..4 must be xs and 0..3 ys
08:36:49 <Sornaensis> you would need bind for that i think
08:37:50 <ertes-w> mivael: i would have to come up with one, and i can't do that right now, sorry
08:38:10 <ertes-w> mivael: also there are a few approaches to handling something like that, depending on your level of haskell
08:38:19 <ertes-w> mivael: for example you can use a stream processing library
08:38:50 <ertes-w> mivael: e.g. a (Producer Text M ()) in 'pipes' is very much like a "Text with effects"
08:38:54 <nshepperd_> Competitive programming code that is written over half an hour until it works then thrown away may be a bad example to demonstrate program design principles
08:38:59 <ertes-w> with M-effects to be more specific
08:39:06 <mivael> > flip (,) <$> [0..4] <*> [0..3]  -- the_2nd, in such way?
08:39:09 <lambdabot>  [(0,0),(1,0),(2,0),(3,0),(0,1),(1,1),(2,1),(3,1),(0,2),(1,2),(2,2),(3,2),(0,...
08:39:31 <the_2nd> now y became x ;)
08:39:33 <ertes-w> mivael: but again, i might be just wasting your time
08:39:53 <ertes-w> mivael: this is software design, so it may be irrelevant in your case
08:40:05 <ertes-w> the only aspect where this might be relevant is when it comes to reducing bugs
08:40:43 <ertes-w> but competetive challenges are probably simple/small enough that it hardly matters
08:40:47 <the_2nd> mivael, maybe flip and switching them one sec
08:41:05 <mivael> ertes-w, yeah, the set of available libraries is limited at competitive programming sites...  What I need is a tamplate using, say, only basic functionality...
08:41:18 <mivael> * template
08:41:41 <the_2nd> mivael, flip and flipping them does the trick
08:41:53 <ertes-w> mivael: the way i solve problems i might end up reinventing the 'free' library =)
08:42:03 <ertes-w> or the 'machines' library
08:42:17 <ertes-w> reason is that i almost always start with a DSL
08:44:28 <nshepperd_> Limited libraries? O
08:45:05 <mivael> nshepperd_, limited set of them
08:45:29 <nshepperd_> That's inconvenient. I was going to suggest using trifecta or something to parse the input, for better error messages
08:47:37 <mivael> nshepperd_, Text.Trifecta.Parser?
08:48:00 <nshepperd_> That sounds like it
08:53:06 <balac> hi, im a haskell beginner, can someone please take a look at this trivial simulation: http://lpaste.net/358948
08:53:24 <balac> and help me understand why it is taking nearly 2 gigs of memory?
08:53:54 <balac> i believed foldl' was strict and shouldn't balloon
08:54:33 <mivael> nshepperd_, Text.Trifecta.Parser: Stability = experimental, Safe Haskell = None.  Chances are low the library is supported by competitive programming sites.
08:55:12 <barrucadu> I think the "stability" field of modules is basically meaningless
08:56:41 <mivael> barrucadu, I appeal to "safe haskell" part more.
08:57:45 <nshepperd_> balac: tuples are non strict, so it may only be evaluating the outer constructor
08:57:53 <mivael> (Data.Text is also "experimental" but it is marked as "trustworthy" regarding safety.)
09:00:08 <ertes-w> parsec might be on the white-list
09:00:14 <balac> nshepperd_: okay. thank you!
09:00:17 <ertes-w> trifecta probably not
09:00:39 <ertes-w> mivael: ^
09:01:32 <mivael> ertes-w, thank you
09:06:55 * hackagebot transformers 0.5.5.0 – Concrete functor and monad transformers – https://hackage.haskell.org/package/transformers
09:08:18 <balac> nshepperd_: i edited it to add bang patterns inside the tuple, but no luck: http://lpaste.net/358948
09:08:43 <balac> puregreen: ping!
09:08:59 <puregreen> huh?
09:09:15 <nshepperd_> balac: the tuples inside, also...
09:09:38 <nshepperd_> Using a strict data type would be better
09:10:06 <balac> puregreen: hi is this artyom?
09:10:11 <puregreen> yep
09:12:19 <balac> puregreen: you had helped a few of us learn haskell in a slack channel you ran. 
09:14:06 <puregreen> ah, I remember now
09:15:15 <balac> puregreen: it is that time of the year when i learn haskell :)
09:15:32 <ertes-w> balac: triple !x !y !z = (x, y, z)  -- construct all your tuples using this function
09:16:31 <monochrom> balac, "type Vec3 = (Double, Double, Double)" is going to be unhelpful, you need something like "data Vec3 = Ctor !Double !Double !Double". But then that's exactly what Linear.V3's V3 does, "data V3 a = V3 !a !a !a", why abandon it?
09:17:46 <balac> monochrom: i was working with V3, but the performance i got wasn't great. i thought i would build it up step by step and find out.
09:18:08 <ertes-w> balac: then start by building V3
09:18:51 <ertes-w> balac: but a short-term solution is to make sure that you tuples are actually strictly built
09:19:02 <ertes-w> duple !x !y = (x, y)  -- like this
09:19:42 <ertes-w> the bang patterns you have added are rather pointless, because you're only forcing the tuple, not its elements
09:20:11 <balac> ertes-w: okay, i thought i was forcing the elements since i put the pattern inside the ()
09:20:29 <ertes-w> (!pos, !vel)  -- pos and vel are tuples
09:20:35 <ertes-w> you're not forcing their elements
09:21:03 <ertes-w> this is how you force them:  (pos@(!_, !_, !_), vel@(!_, !_, !_))
09:23:37 <balac> ertes-w: i understand. i will also compare it to V3. I must have made mistakes in that version too.
09:31:46 <balac> ertes-w: the 'triple' trick worked.
09:32:45 <ertes-w> balac: you can achieve the highest speeds by defining a variant of V3 specialised to Double
09:32:58 <ertes-w> data V3Double = V3Double !Double !Double !Double
09:33:38 <ertes-w> not a very convenient type though: no Applicative, no Traversable, etc.
09:36:59 <balac> okay
09:42:15 <AWizzArd> https://patrickmn.com/software/what-programming-languages-are-used-late-at-night/
09:45:24 <taylskid> do you all have any recommendations for good open source projects that might be looking for contributors?
09:45:58 <Psybur> define good :D
09:46:21 <Psybur> I could throw some code at you but you'd probably lose faith in humanity
09:46:55 <taylskid> Psybur: basically just one with issues to tackle that could be new comer friendly?
09:47:56 <Psybur> I suppose my crappy algotrader/backtester is no longer new comer friendly D: Lucky you!
09:49:06 <Xandaros> Got a question about stack: I'm using lts-8.5 because I'm using an older package, but many packages don't want to compile withi current cabal. Can I tell stack to use an older cabal somehow?
09:51:43 <Xandaros> My approach so far has been to tell it in extra-deps to actually use a newer version of the package. This works, but gets annoying if something has a lot of dependencies that need this (That said, it does not seem to be too common an issue)
09:52:07 <ertes-w> taylskid: GHC, pandoc, xmonad, …
09:52:50 <lyxia> taylskid: QuickCheck
09:58:42 * hackagebot lucid 2.9.9 – Clear to write, read and edit DSL for HTML – https://hackage.haskell.org/package/lucid
09:59:08 <taylskid> cool, thanks
10:00:34 <maerwald> GHC is harldy newcomer friendly, please
10:00:59 <michalrus> Can I have two `deriveJSON`s in one `$()`?
10:01:06 <michalrus> (Easily)
10:01:06 <maerwald> hledger maybe
10:06:24 <lyxia> michalrus: liftA2 (++) (deriveJSON bar) (deriveJSON foo)
10:06:35 <michalrus> ♥ ♥ Thank you!
10:07:28 <michalrus> So… I having a function like… $(deriveJSONs [bar foo]) wouldn’t be very hard?
10:07:32 <michalrus> s/I //
10:07:40 <phadej> concat <$> traverse deriveJSON [''Foo, ''Bar, ''Quux]
10:07:52 <michalrus> ♥
10:07:55 <michalrus> Thank you, both!
10:15:16 <lf94> I'm looking at Generalized ADTs again, and my intuition tells me they add a lot of functionality over Parametric ADTs
10:15:19 <lf94> Is this right?
10:15:54 <lf94> I don't get why they're called "generalized" when they actually seem more specialized
10:15:59 <lf94> https://en.wikipedia.org/wiki/Generalized_algebraic_data_type
10:16:18 <bennofs> generalized in the sense that they allow you to specify more restrictions
10:16:30 <lf94> In this case, operations?
10:16:37 <bennofs> being able to expressing more constraints == more general/expressive
10:17:04 <lf94> Gotchya
10:17:44 <bennofs> i don't know how to answer your question if they add a "lot" of functionality. hard to quantify how much functionality they add IMO
10:19:08 <bennofs> I think this comment "-- A parametric ADT that is not a GADT" is confusing in that wikipedia article
10:19:16 <bennofs> you can express every ADT as a GADT
10:19:44 <lf94> My gut tells me that I think the example for GADT could also be a parametric ADT too
10:20:06 <lf94> You would just have to define a bunch of other ADTs
10:20:25 <lf94> One for EBool, EInt, EEqual
10:20:31 <balac> in this V3 sample: http://lpaste.net/358951,
10:20:32 <bennofs> hmm yes. but then you're changing the structure of the type
10:20:43 <lf94> I am? How
10:20:54 <lf94> I'm just building the structure in a different way
10:21:05 <bennofs> yes. in this case, that's possible
10:21:06 <balac> I am getting different values for the last element of the scanl' depending on whether I am printing out the result of the foldl' !
10:21:23 <lf94> bennofs ok then I take it this example is bad
10:21:28 <bennofs> not sure if it's possible in general though. I suspect not, there's probably some GADT that cannot be trivially converted into an ADT representation
10:21:39 <balac> can someone help me understand what could be going on here?
10:21:39 <lf94> I would love to see that
10:21:42 <bennofs> or where it would be very unpractical to use the ADT representation
10:21:55 <lf94> If you can find me an example of that, that'd be greatly appreciated
10:22:08 <lf94> Because to me now, GADT almost seems like syntatic sugar
10:22:38 <ski> @type concatMap
10:22:40 <lambdabot> Foldable t => (a -> [b]) -> t a -> [b]
10:22:41 <ski> @type ((fold <$>) .) . traverse
10:22:43 <lambdabot> (Applicative f, Traversable t, Monoid b) => (a -> f b) -> t a -> f b
10:23:25 <lf94> Maybe these papers on GADT can provide some better explanations
10:23:53 <balac> i get the expected value, when i print the result of foldl : World (V3 (-6406107.153425763) 0.0 3919493.8924218565) (V3 3808.8100797477014 0.0 6225.300223453233) [World (V3 (-6406107.153425763) 0.0 3919493.8924218565) (V3 3808.8100797477014 0.0 6225.300223453233)]
10:24:01 <bennofs> lf94: how about https://gist.github.com/879857082453e74ec597ad1ee754bce7
10:24:36 <ski> @type Control.Monad.Extra.concatMapM
10:24:38 <lambdabot> Monad m => (a -> m [b]) -> [a] -> m [b]
10:24:39 <ski> @type Control.Monad.Extra.mconcatMapM
10:24:40 <lambdabot> (Monoid b, Monad m) => (a -> m b) -> [a] -> m b
10:24:45 <balac> when i don't print foldl, i get this: [World (V3 (-1.1266458613590188e7) 0.0 7500000.0) (V3 (-2404.2742265803627) 0.0 (-1.2100271406438856e-2))]
10:27:57 <lf94> bennofs: How would you use this
10:28:14 <bennofs> lf94: Cons 1 Nil :: List (Succ Zero) Int
10:28:48 <bennofs> lf94: it's a list that tracks the length in its type
10:29:18 <bennofs> so you know that a :: List (Succ (Succ Zero)) Int  for example has 2 elements
10:29:45 <lf94> len could be a String too couldnt it
10:29:56 <taylskid> is anyone here willing to do a code review on my really bad little http server?
10:29:59 <lf94> Shouldn't we restrict that to Int
10:30:12 <taylskid> just to make sure my code resembles idiomatic haskell
10:30:19 <bennofs> lf94: yeah you could write it nicer with DataKinds but i didn't want to introduce yet another extension :)
10:30:27 <bennofs> lf94: it is not an Int, it is type-level
10:30:51 <lf94> Mmm
10:31:06 <lf94> It is probably extremely clear that things are starting to fly over my head now
10:31:14 <lf94> Anyway, I will hold onto this :)
10:31:18 <lf94> Thank you
10:31:33 <bennofs> lf94: but note for example, there is no possible value of type 'List String Int'
10:31:45 <bennofs> because no constructor will every produce something of type 'List String _'
10:31:51 <bennofs> ever*
10:32:13 <lf94> Right
10:32:22 <lf94> Only List (Succ len) a or List Zero a
10:32:28 <lf94> ok...makes more sense
10:32:40 <bennofs> with DataKinds, you could restrict the len parameter so that it can only ever be Succ x or Zero
10:32:51 <lf94> (ok, saying it is type-level only makes more sense to me now too)
10:33:04 <lf94> Cool, could you show me that?
10:33:30 <taylskid> in any case, here it is https://gist.github.com/taylskid/9b484572f53fb2d745ca895449723a01
10:35:02 <lf94> Ok I'm really starting to see how GADTs can restrict things that ADTs cannot
10:35:17 <lf94> Trying to recreate your example with Parametric ADTs...
10:35:49 <lf94> You basically have to make Cons and Nil their own functions
10:36:01 <bennofs> lf94: yes, you can recreate it with smart constructors
10:36:19 <lf94> Or that, whatever that is :)
10:36:42 <bennofs> lf94: but, you cannot recreate the matching part. if you do `case (a :: List (Succ Zero) ...) of Cons a l -> ...` ghc will not warn you of incomplete patterns
10:36:57 <bennofs> lf94: and that's right, because that 'a' can never be a Nil
10:37:13 <bennofs> lf94: smart constructors = exposing only functions and keeping the "real" constructors private
10:37:48 <bennofs> lf94: anyway, here's the data kinds example. but be warned, this may just confuse you if you don't know about kinds yet :) https://gist.github.com/5c8b1bc6c3cfb2ae7be92df6810a64dd 
10:38:29 <Ero> hi all. I was reporting issues with stack commands yesterday. Turns out my ISP (sky) had the github domain blocked suddenly (was working last week). Its fixed now
10:38:38 <bennofs> there's also special support for type-level natural numbers in GHC that even allow you to write things like `a + 1` at the type level but I forgot the exact syntax right now :)
10:39:02 <phadej> bennofs: it's like that
10:39:10 <phadej> :t Proxy : Proxy (1 + 2)
10:39:11 <bennofs> phadej: yes I just forgot what the kind of nats was
10:39:12 <lambdabot> error:
10:39:12 <lambdabot>     • Couldn't match expected type ‘Integer -> [Proxy t]’
10:39:12 <lambdabot>                   with actual type ‘Proxy t0’
10:39:20 <phadej> :t Proxy :: Proxy (1 + 2)
10:39:21 <lambdabot> error:
10:39:22 <lambdabot>     Not in scope: type constructor or class ‘+’
10:39:25 <bennofs> Nat? Or Natural? or do I have to import somthing? :D
10:39:28 <phadej> Nat
10:39:39 <phadej> http://hackage.haskell.org/package/base-4.10.0.0/docs/GHC-TypeNats.html
10:39:43 <bennofs> from GHC.TypeLits iirc
10:39:48 <bennofs> oh ok
10:40:13 <ski> lf94 : "You would just have to define a bunch of other ADTs" -- yes, but then you can't define `eval :: Expr a -> a'. you could do `class Eval e a | e -> a where eval :: e -> a', with instances, though
10:40:15 <phadej> TypeNats is new in base-4.10, and have Natural as term-level companion
10:40:31 <phadej> :t Proxy :: Proxy (-1)
10:40:33 <lambdabot> error:
10:40:33 <lambdabot>     Not in scope: type constructor or class ‘-’
10:40:33 <lambdabot> error:
10:40:47 <michalrus> phadej: can I have one more question? With -XOverloadedLists, I have to force $(concat <$> traverse (deriveJSON defaultOptions) ([''Foo ''Bar] :: [TH.Name]))
10:41:06 <lf94> bennofs: so ' is a special syntax I take it
10:41:07 <michalrus> Otherwise, it complains about GHC.Exts.Item’s t0 not being solved.
10:41:09 <michalrus> :’
10:41:19 <lf94> bennofs: other than that, seems pretty straight forward
10:41:26 <ski> balac : weird
10:41:34 <bennofs> lf94: you don't even need the ' anymore, but I included it to make clear it's "one level up" and not term level :)
10:41:48 <phadej> michalrus: that's because
10:41:50 <phadej> :t traverse
10:41:52 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
10:41:53 <phadej> :t concat
10:41:56 <lambdabot> Foldable t => t [a] -> [a]
10:42:09 <phadej> are both polymorphic in the outer container (t)
10:42:13 <michalrus> Mhmmmm, yes.
10:42:23 <lf94> bennofs: It's just saying "this type must belong to this type group", right?
10:42:35 <phadej> and OverloadedLists make the [..., ...] syntax overloade too
10:42:36 <michalrus> But doesn’t $() force Q []?
10:42:54 <bennofs> lf94: yes. it's like types for types. just like normal types say "this value must belong to this value group (type)" :)
10:42:55 <phadej> michalrus: it does, but that's the resunt of concat (-> [a])
10:43:05 <michalrus> Ah, right.
10:43:14 <michalrus> All clear.
10:43:17 <michalrus> Thank you. :]
10:43:19 <phadej> no worries
10:43:45 <balac> ski: any guesses?
10:43:56 <balac> what can i check?
10:44:10 <phadej> michalrus: you can do `concat @[]` with -XTypeApplications though
10:44:16 <phadej> it's shorter, and no need to import TH
10:44:24 <michalrus> phadej: how about $(join <$> traverse …)? Would that be bad style?
10:44:30 <michalrus> Oh, nice. :]
10:46:00 <phadej> michalrus: I personally don't like using join for that, as it makes me think "what effects are happening there", when I'm actually working with containers
10:46:24 <michalrus> OK, clear!
10:47:18 <ski> balac : no obvious mistake that i can see (though you could use `last')
10:47:36 <phadej> easy way to confuse a coworker: let maybeValue = do { x <- bar, fooX x }
10:47:55 <michalrus> =)
10:48:01 <phadej> at least, if you omit the type-annotation for maybeValue (and use worse name)
10:48:24 <maerwald> confusing coworkers is something you should be ashamed of, not proud
10:48:37 <phadej> (In IO do block)
10:48:56 <nshepperd> try to nfuse workers instead
10:49:14 <phadej> nshepperd: :)
10:49:21 <ski> michalrus : fwiw, you could use `fold' (or `getAny . foldMap Any' or `ala Any foldMap') instead of `concat'. this combination with `traverse' and `(<$>)' is known as `concatMapM' (or `mconcatMapM') in some modules, it seems
10:50:16 <phadej> ski: `fold` is even more polymorphic than `concat`
10:50:38 <ski> oh. there was a problem with being too polymorphic ?
10:50:57 * ski missed the beginning of the conversation, sorry
10:51:26 <phadej> :t concat
10:51:28 <lambdabot> Foldable t => t [a] -> [a]
10:51:29 <phadej> :t mconcat
10:51:31 <lambdabot> Monoid a => [a] -> a
10:51:45 <phadej> well, mconcat won't need annotation
10:51:53 <phadej> :t fold
10:51:56 <lambdabot> (Monoid m, Foldable t) => t m -> m
10:51:57 <phadej> is polymorphic in both
10:52:19 <ski> (er, s/Any/Alt/)
10:52:25 <ski> @type ala Alt foldMap
10:52:28 <lambdabot> forall k2 (t :: * -> *) (g :: k2 -> *) (b :: k2). (Monoid (Alt g b), Foldable t) => t (g b) -> g b
10:52:34 <michalrus> Nice. =] I’ll use mconcat then. Thank you!
10:52:58 <ski> (for some reason it didn't reduce `Monoid (Alt g b)' to `Alternative g')
10:53:58 <ski> lf94 : ok ?
10:54:40 <phadej> ski: it doesn't know the kind og g
10:54:43 <phadej> kind of g
10:54:46 <balac> ski: when i used 'last' alone, i got the expected answer.
10:54:51 <phadej> (g :: k2 -> *) not * -> *
10:55:06 <balac> ski: when i used take + reverse before last, got wrong value for both!
10:55:06 <ski> phadej, oh, i see
10:55:22 <phadej> ski: I have wondered the same in the past
10:55:47 <ski> balac : s/before/instead of/ ?
10:56:27 <balac> ski: before, as in: print $ take 1 $ reverse simTrace
10:56:41 <balac> followed by: print $ last simTrace
10:56:50 <balac> got wrong for both!
10:59:42 <balac> ski: infact, order of take+reverse and 'last' does not matter. if 'take+reverse' is present before or after 'last', i get wrong values for both lines.
11:00:03 <ski> balac : i wonder why .. you seem to have pinned down the types of your variables, so i don't think it could be a matter of defaulting to another numeric type
11:00:30 <balac> ski: could strictness be an issue?
11:00:37 <ski> and  foldl'  and  scanl'  brackets the same way, so it shouldn't be that, either
11:00:56 <ski> strictness ought not to influence the actual concrete answer you get (if any)
11:01:35 <balac> ski: this is not related to foldl', since i have the issue with just using the scanl result.
11:06:46 <balac> well, 'last' is implemented through foldl
11:07:28 <ski> perhaps you could try asking on the mailing list
11:07:34 <a6a3uh> Hi! Expected type: StateT a (Writer String) ();  Actual type: b World (Writer String) () and I have function (a -> b) as well as (b -> a) so how can I give what expected?
11:08:05 <a6a3uh> sorry Expected type: StateT a (Writer String) ();  Actual type: StateT b (Writer String) () and I have function (a -> b) as well as (b -> a) so how can I give what expected?
11:09:01 <foobar_> Hello, i was reading through https://wiki.haskell.org/Performance/Accumulating_parameter , it says ghc programs can stack overflow
11:09:13 <ski> @type mapStateT . fmap . fmap  -- a6a3uh
11:09:15 <lambdabot> Functor n => (s -> s) -> StateT s n b -> StateT s n b
11:09:18 <foobar_> but i tested using bigger values but i don't get any stack overflows
11:09:40 <ski> oh, actually that does not change the state, hm
11:09:51 <ski> right, you had `b -> a' as well
11:09:55 <foobar_> afaiu, haskell execution model shouldn't be making use of system stack
11:10:05 <a6a3uh> yes I have different states and can convert in both directions
11:11:22 <balac> ski: thank you for your help! this sounds like a compiler bug?
11:18:01 <ski> @type let (f ~> g) h = g . h . f in \f g -> (runStateT ~> StateT) (f ~> (fmap . fmap) g)  -- a6a3uh
11:18:03 <lambdabot> Functor m => (s -> a1) -> (a1 -> s) -> StateT a1 m a2 -> StateT s m a2
11:18:29 <ski> balac : maybe. or maybe a bug in `linear'. or maybe there's just something we're missing ..
11:19:22 <a6a3uh> wow I never used this ~>. Will try. Thank you -- ski
11:19:33 <balac> ski: even if there is a bug in 'linear', the output of one expression cannot change based on evaluating another, right?
11:19:42 <ski> @where SEC
11:19:42 <lambdabot> http://conal.net/blog/posts/semantic-editor-combinators/
11:19:44 <ski> a6a3uh ^
11:19:51 <Psybur> :t (~>)
11:19:52 <lambdabot> error:
11:19:52 <lambdabot>     • Variable not in scope: ~>
11:19:52 <lambdabot>     • Perhaps you meant one of these:
11:20:15 <ski> balac : shouldn't happen, unless there's a bug in unsafe stuff, afaiu
11:21:05 <balac> ski: okay. so if 'linear' is using unsafe stuff, this kinda thing can happen?
11:21:08 <ski> a6a3uh : `infixr 1 ~>', i think is reasonable
11:21:35 <ski> perhaps. just grasping at straws
11:22:08 <a6a3uh> ski: reading about all this stuff. thank you)
11:22:36 <ski> balac : another option (perhaps not that likely), i suppose would me that your machine has problems. try to reproduce on another machine ?
11:22:46 <balac> okay. is there someone on IRC whom I can talk to before taking this to the mailing list?
11:22:50 <ski> a6a3uh : lens is also related (but more advanced)
11:22:54 <ski> @where TV
11:22:54 <lambdabot> http://www.haskell.org/haskellwiki/TV
11:23:10 <balac> ski: okay.
11:23:10 <ski> a6a3uh : that ^ has a few more examples of SEC
11:23:23 <ski> oh, and the type signature is
11:23:39 <ski>   (~>) :: (a1 -> a0) -> (b0 -> b1) -> ((a0 -> b0) -> (a1 -> b1))
11:23:53 <a6a3uh> ski: Im actually using lens but just to make object oriented like stuff with deeply nested types or work with Aeson
11:24:07 <ski> also
11:24:26 <ski>   argument :: (a1 -> a0) -> ((a0 -> b) -> (a1 -> b))
11:24:33 <ski>   argument f = f ~> id
11:24:46 <ski>   result :: (b0 -> b1) -> ((a -> b0) -> (a -> b1))
11:24:53 <ski>   result g = id ~> g
11:26:24 <a6a3uh> ski: now I have couple of hours reading. thank you :)
11:26:39 <ski> one can use a composition chain of functions like `argument',`result',`map',`fmap',`onLines',`perLine',`onWords',`perWord',&c. to specify a path (in terms of the types) to a "component" of the structure
11:27:12 <ski> then that is applied to the function that one'd like to apply at that "spot", and then the structure to traverse using the path, preserving the rest of the structure
11:29:53 <ski> @let onWords = words ~> unwords; onLines = lines ~> unlines; perWord = onWords . map; perLine = onLines . map
11:29:55 <lambdabot>  Defined.
11:31:16 <ski> @type res . res . arg . map . first
11:31:17 <lambdabot> (b1 -> c) -> (a1 -> a2 -> [(c, d)] -> b2) -> a1 -> a2 -> [(b1, d)] -> b2
11:31:54 <ski> here the first components of the pairs in the list, being the third argument, are being changed
11:33:56 <Maurdekye> hello
11:34:08 <shapr> greetings Maurdekye 
11:34:55 <a6a3uh> ski: magic. is it a good haskell style to write this way? haskellists should easily understand what this should do?
11:35:05 <balac> ski: i had ghc 8.0.1 installed on my machine. it doesn't have this issue. for the same code, 8.0.2 installed through stack is showing the problem.
11:36:02 <ski> > perLine reverse "Rats live on no evil star.\n God, a red nugget! A fat egg under a dog!\n"
11:36:05 <lambdabot>  ".rats live on no evil staR\n!god a rednu gge taf A !teggun der a ,doG \n"
11:36:20 <Maurdekye> so i have this vector class: `data Vector a = Vec a a a deriving(Eq)`
11:37:02 <Maurdekye> and i'm trying to make a normalize function for it
11:37:08 <balac> ski: also, both of them are using same version of 'linear'
11:37:09 <ski> a6a3uh : within reason, i'd say yes
11:37:54 <ski> (it's not that hard to go overboard with pointless code)
11:41:53 <Maurdekye> I'll just link my code here: https://repl.it/MGP7/0
11:42:11 <Maurdekye> it compiles fine, but i'm having trouble running the normalized function
11:42:32 <Maurdekye> if I try to run it on one of the vectors i've defined at the bottom; `normalized av`
11:42:36 <Maurdekye> it gives an error
11:42:39 <Maurdekye> I'm not sure why
11:42:44 <nicknight> any one into Machine Learning here ? 
11:45:01 <Maurdekye> the type signature of normalized is: normalized :: (Floating a) => Vector a -> Vector a
11:45:03 <balac> Maurdekye: the variable 'av' has type 'Vector Integer'
11:45:10 <Maurdekye> okay
11:45:18 <Maurdekye> isn't Integer an instance of Floating?
11:45:23 <Maurdekye> wait
11:45:24 <balac> Integer is not a Floatig
11:45:26 <balac> yes
11:45:50 <Maurdekye> i tried modifying the function to take a more general (Num a) input
11:45:58 <Maurdekye> but that conflicted with sqrt and (/)
11:46:10 <opqdonut> Maurdekye: the problemis that iHat, av, etc have type Vec Integer
11:46:12 <Maurdekye> i don't know how to make it general enough to take integer inputs
11:46:12 <opqdonut> due to defaulting
11:46:18 <Maurdekye> thats fine
11:46:32 <opqdonut> welllllll how do you normalize the integer vector [1,1,1]?
11:46:36 <Maurdekye> what i want is for the function to work with integral vectors
11:46:52 <Maurdekye> im not sure
11:46:55 <Maurdekye> how do you?
11:47:15 <opqdonut> you could do something like "normalized :: (Num a, Floatig b) => Vector a -> Vector b"
11:47:36 <opqdonut> no sorry that should be something like Integral a I guess
11:47:38 <balac> that makes sense
11:47:58 <Maurdekye> opqdonut: then it wouldn't take Floating vectors
11:48:08 <opqdonut> indeed
11:48:18 <Maurdekye> can i get it to take both?
11:48:48 <Maurdekye> both Integral vectors and Floating vectors
11:48:50 <balac> Maurdekye: Num is more generic, right? you are restricting only the output.
11:48:51 <Maurdekye> ie. Real vectors
11:49:12 <Maurdekye> no, the (Floating a) constraint applies to the input and the output
11:49:23 <opqdonut> there's really no easy way
11:49:27 <Maurdekye> hmm
11:49:43 <opqdonut> well ok you could define your own ToFloating type class I guess
11:49:43 <Maurdekye> okay, at least is there a way to convert generic numbers to floating numbers
11:49:44 <balac> Maurdekye: the signature that opqdonut shared uses floating only for output.
11:50:17 <Maurdekye> balac: he corrected himself to say that it should be (Integral a) instead of (Num a)
11:50:20 <Maurdekye> which is more restrictive
11:50:37 <opqdonut> (Num a, Floating b) => a -> b doesn't really exist
11:50:45 <opqdonut> consider a == Vec Double
11:50:51 <opqdonut> (and b == Double)
11:51:11 <opqdonut> Num is too wide. You need something like Scalar, but I don't remember there being anything like that
11:51:25 <Maurdekye> is there a way of converting that discards information?
11:51:28 <opqdonut> perhaps you can just implement your own type class, call it Scalar, or ToFloating
11:51:30 <Maurdekye> like truncating
11:51:32 <shapr> opqdonut: put up a PR!
11:51:47 <Maurdekye> but instead of float -> int, num -> float
11:51:48 <opqdonut> shapr: for what? ghc?
11:51:54 <shapr> opqdonut: sure!
11:52:14 <opqdonut> Maurdekye: how would you implement vector->float? remember, vector is a num too
11:52:38 <balac> okay
11:52:42 <Maurdekye> why not just throw away the last two numbers? the implementation with vectors isnt important to me
11:52:52 <Maurdekye> i only care about converting nums to raw floats
11:52:54 <opqdonut> yeah well anyway, no-one has implemented this for you
11:52:58 <opqdonut> implement your own type class
11:53:06 <opqdonut> it's a good exercise :)
11:53:33 <opqdonut> shapr: not sure what the methods would be, toFloating :: Floating b => a -> b?
11:54:01 <shapr> hm
11:54:09 <shapr> fromInteger? :-P
11:54:11 <shapr> I'm not sure
11:54:47 <opqdonut> fromInteger is not quite enough
11:55:13 <Maurdekye> on a similar note
11:55:14 <shapr> yeah, that was a snarky comment because fromInteger is popular, and has its own problems
11:55:31 <Maurdekye> i know there's fromIntegral :: (Num a, Integral b) = b -> a
11:55:44 <Maurdekye> but is there a similar fromFloating :: (Num a, Floating b) => b -> a
11:56:00 <Maurdekye> i cant seem to find it anywhere online
11:56:13 <shapr> @hoogle fromFloating
11:56:13 <lambdabot> No results found
11:56:15 <opqdonut> you can't really have a ->Num function
11:56:16 <shapr> probably not
11:56:23 <a6a3uh> ski: will this work as well? zoom :: Monad m => LensLike' (Zooming m c) a b -> StateT b m c -> StateT a m c
11:56:24 <opqdonut> because Num is so wide
11:56:31 <opqdonut> :t realToFrac -- there's this
11:56:33 <lambdabot> (Fractional b, Real a) => a -> b
11:56:42 <opqdonut> hmm
11:56:44 <opqdonut> @info Real
11:56:44 <lambdabot> Real
11:56:47 <Maurdekye> but isn't fromIntegral a -> Num function?
11:56:48 <nicknight> I wonder if haskell if good fit for machine learning/data science and haskell very toughest programming language?
11:56:54 <Maurdekye> :t fromIntegral
11:56:56 <lambdabot> (Num b, Integral a) => a -> b
11:56:59 <shapr> nicknight: definitely
11:57:06 <opqdonut> Maurdekye: hmm you're quite right
11:57:21 <opqdonut> @src fromIntegral
11:57:21 <lambdabot> fromIntegral = fromInteger . toInteger
11:57:29 <cement> me and my friends think of haskell as programming easy-mode
11:57:34 <opqdonut> @src fromInteger
11:57:35 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
11:57:44 <opqdonut> oh thanks
11:57:48 <shapr> Haskell is good for machine learning and data scienc.
11:57:51 <Maurdekye> @src fromIntegral
11:57:51 <lambdabot> fromIntegral = fromInteger . toInteger
11:57:58 <Maurdekye> hmm
11:58:10 <shapr> I've found Haskell easier to teach than any other language because it allows equational reasoning.
11:58:25 <opqdonut> oh right toInteger is from Integral
11:58:39 <Maurdekye> should fromIntegral not exist then?
11:58:47 <Maurdekye> because it seems to defy all rules of conversion
11:58:56 <opqdonut> oh there's a fromInteger in Num
11:59:00 <opqdonut> weird, I had forgotten that
11:59:09 <shapr> I've heard piles of 'production Haskell' complaints about fromInteger and fromIntegral
11:59:40 <Maurdekye> so in other words
11:59:56 <Maurdekye> you should never expect to have to convert to Num
12:00:06 <Maurdekye> or you just straight up shouldnt at all
12:00:10 <nicknight> shapr:  are you professor ? I am very interested in Ml and I dont like languages like python as I feel bored but at the same time I heard haskell very imposiible language for a beginner
12:00:27 <Maurdekye> nicknight: what nationality are you?
12:00:35 <opqdonut> Maurdekye: in summary, thehaskell numeric classes are messed up and complicated
12:00:36 <a6a3uh> ski: in particular: zoom :: Monad m => Traversal' a b -> StateT b m () -> StateT a m () -- ski
12:00:44 <shapr> nicknight: I'm roughly the opposite of a professor. I got paid to write Haskell before I took any college courses for math or computers.
12:01:04 <nicknight> Maurdekye:  why ?
12:01:25 <Maurdekye> your english is unusually organized, denoting you might not be a native english speaker
12:01:28 <Maurdekye> i'm just curious
12:01:34 <nicknight> ok shapr 
12:01:34 <shapr> nicknight: In my experience, Haskell is a wonderful language for beginners.
12:01:55 <nicknight> Maurdekye:  yes, I am non-native english speaker 
12:01:59 <cement> can confirm, my first language (and main job language) has been haskell
12:02:17 <nicknight> cement:  where do you work ?
12:02:34 <cement> a small networking company in Georgia, called layer 3
12:02:42 <shapr> Many beginners get frustrated at Python, etc because the contents of your buckets (variables) can change to anything at any time, often in code that you never knew existed.
12:02:47 <nicknight> shapr:  really ? I wanted any MOOC that teaches Data science/ml in haskell
12:02:48 <cement> Georgia the state, not the country
12:02:56 <shapr> cement: ooh, come to my Haskell meetups
12:03:02 <Maurdekye> opqdonut, shapr: how do you suggest I change my code to accomodate the error i'm recieving??
12:03:09 <Maurdekye> ?*
12:03:09 <lambdabot> Maybe you meant: v @ ? .
12:03:20 <cement> shapr: where and when and I'll drag my boss and coworker too
12:03:30 <opqdonut> Maurdekye: I suggest you give your example vectors the type "Num a => Vector a"
12:03:43 <shapr> cement: I'm doing a weekly haskellbook.com meetup at dancing goats coffee shop by the midtown marta station
12:03:58 <cement> today?
12:03:58 <shapr> but we also have a monthly meetup, it's almost always Haskell, but sometimes common lisp, etc
12:04:01 <shapr> yes today!
12:04:10 <shapr> I'll send you more info in PM
12:04:23 <Maurdekye> opqdonut: their type still ends up as Vector Integer
12:04:53 <nicknight> This channel so busy I miss my conversation :|
12:04:55 <opqdonut> Maurdekye: surely not if you just say "av :: Num a => Vector a" on the top level?
12:05:05 <opqdonut> works for me
12:05:24 <Maurdekye> oh, i just did av = Vector 1 3 2 :: Num a => Vector a
12:06:19 <Maurdekye> that seems to work
12:07:27 <opqdonut> for actual code, I'd have some sort of function floatify :: Integral a => Vector a -> Vector Double
12:07:41 <opqdonut> to be able to control when I switch from integer to floating point vectors
12:07:49 <opqdonut> if I wanted integer vectors for something
12:07:51 <Maurdekye> opqdonut: i thought we just discussed for 10 minutes how that's a bad idea / not possible
12:08:16 <opqdonut> that signature definitely is possible
12:08:19 <Zemyla> opqdonut: Wouldn't it be better to say "av :: Vector Integer" and use "fmap fromInteger av" where you would use "av"?
12:08:32 <Maurdekye> opqdonut: is the definition possible though?
12:08:42 <Maurdekye> i don't know how you'd implement either of those
12:09:01 <opqdonut> Maurdekye: sure, it's just "floatify (Vec x y z) = Vec (fromIntegral x) (fromIntegral y) (fromIntegral z)"
12:09:46 <opqdonut> what is not easily possible is a function normalized that eats both integer and floating vectors
12:10:14 <opqdonut> but if you're fine with having to call "normalized v" or "normalized (floatify v)" depending on the type, that's fine
12:11:02 <ski> nicknight : it happens
12:11:27 <opqdonut> Zemyla: yeah that's a fine implementation, and the functor instance is probably pretty useful too
12:11:53 <ski> a6a3uh : looks like it
12:12:34 <a6a3uh> ski: I'm just struggling to get right Traversal now :)
12:13:04 <shapr> cement: if you know any other Haskellers in Atlanta, feel free to invite them to the meetups
12:14:29 <Maurdekye> opqdonut: just made Vector an instance of functor
12:14:36 <cement> we'll see, but I'm ~98% certain that there's only my, my desk-neighbor and my boss who are haskellers that I know near atlanta
12:14:44 <Maurdekye> trying to use it to implement those conversion functions
12:14:50 <cement> me*
12:15:21 <shapr> cement: sounds good to me
12:20:17 <Maurdekye> so is there a function like (Integral a, Floating b) => a -> b ?
12:22:56 <lyxia> fromIntegral
12:23:32 <shloub> > :t fromIntegral
12:23:35 <lambdabot>  <hint>:1:1: error: parse error on input ‘:’
12:23:39 <shloub> damn
12:24:59 <shloub> @type fromIntegral
12:25:00 <lambdabot> (Num b, Integral a) => a -> b
12:25:24 <michalrus> Hmm, I’m trying to join Control.Newtype with Database.Postgresql.Simple, but this naive approach fails with the 1st constaint being no smaller than instance head: `instance (N.Newtype n, ToField (N.O n)) => ToField n where toField n = toField (N.unpack n)`. Is it possible to do that?
12:26:34 <Maurdekye> shloub: apparently if you apply a (Floating b) constraint to the output of fromIntegral, then it works
12:26:41 <lyxia> michalrus: You shouldn't do that.
12:26:57 <lyxia> michalrus: use GeneralizedNewtypeDeriving instead
12:27:11 <michalrus> lyxia: so should I manually write all…
12:27:13 <michalrus> Oh, OK. :]
12:35:17 <nicknight> shapr: cement .... there I got 4 days leave so if I can spend 40hrs can I know the basics of Haskel and will be able to code small scripts ?
12:35:33 <nicknight> any haskel expert reply above please
12:35:36 <cement> define scripts
12:37:03 <Tuplanolla> What's your background, nicknight? If you're already an expert in Scheme or OCaml, then most definitely; otherwise less certainly.
12:39:24 <nicknight> cement: making API calls, writing gradient descent algorithm etc?
12:39:36 <nicknight> Tuplanolla:  never touched Scheme and Ocaml
12:39:48 <foobar_> nicknight: tough luck :(
12:40:57 <cement> the actual calculations for eg. the gradient descent algo should be doable, but making it display a pretty picture, probably not
12:41:42 <nicknight> cement:  plotting/ picture I dont care I mean writing small small programs 
12:41:45 <nicknight> foobar_:  :(
12:42:19 <cement> API will depend heavily on what the API calls return. If they're doing JSON, then you're golden, and there are a few other things with really good support, but other things... not so much
12:42:43 <cement> though parsers can be an absolute *joy* to write
12:43:26 <nicknight> what is some single resource to study haskell ?
12:43:38 <balac> nicknight: would this be useful to you? https://github.com/Gabriel439/Haskell-Turtle-Library
12:43:42 <nicknight> I will try these 4 days to check if I am haskell type
12:43:57 <cement> http://haskellbook.com/
12:44:08 <cement> that one is excellent
12:44:40 <balac> nicknight: i found this very useful: https://github.com/neongreen/haskell-ex
12:44:57 <cement> anything by Gabriel is also fantastic because he has massively awesome documentation
12:45:18 <Tuplanolla> You still didn't tell us your background, nicknight.
12:46:13 <nicknight> Tuplanolla:  I am a mechanical engineer who is doing customer support job who is highly inrested in Data Science and programming
12:47:00 <Tuplanolla> Does that mean you know MATLAB and some bits of C++?
12:47:17 <nicknight> c++ no way matlab years back and python I know
12:48:01 <cement> the number 1 thing you'll struggle with is the types
12:48:27 <nicknight> ok :(
12:48:47 <cement> but, once you wrap your head around them
12:49:07 <nicknight> Tuplanolla:  Why you are asking and not replying me now?
12:49:16 <nicknight> cement:  ok 
12:49:32 <Tuplanolla> I was looking for the book options, nicknight.
12:49:36 <cement> well, idk about anyone else, but once I'd wrapped my head around them I wondered why everything didn't have strong inferred types
12:49:37 <nicknight> balac:  those two git I didn't liked are they learning resources?
12:49:45 <nicknight> Tuplanolla:  Thank you
12:49:53 <Tuplanolla> I wouldn't recommend Learn You a Haskell for you, but there are some more elaborate ones that should fit.
12:50:12 <royal_screwup21> I'm trying to write a a data constructor like so: data day = mon | tue. but I keep hitting "parse error on input data". I tried adding a "let" before "data", but that didn't work either. What am I doing wrong?
12:50:21 <cement> I think haskellbook.com is a good fit
12:50:39 <Athas> royal_screwup21: type names and constructor names must start with a capital letter.
12:50:50 <Athas> data Day = Mon | Tue
12:51:21 <nicknight> cement:  checking that book 
12:51:30 <royal_screwup21> thanks Athas!
12:52:15 <Tuplanolla> @where books
12:52:15 <lambdabot> See `LYAH',`RWH',`YAHT',`HR',`wikibook',`PCPH',`HPFFP',`non-haskell-books'
12:52:21 <ski> > perLine (concat . uncurry (/\/) . (first . onUnsplitLengths . const) reverse . (wordsBy (not . isLetter) &&& wordsBy isLetter)) "Eva, can I stab bats in a cave?\nWas it a rat I saw ?\n"  -- a6a3uh, only reversing the letters
12:52:24 <lambdabot>  "eva, can i stab bats In a cavE?\nwas It a rat i saW ?\n"
12:53:31 <ski> @where HPFFP
12:53:31 <lambdabot> "Haskell Programming: from first principles - Pure functional programming without fear or frustration" by Chistopher Allen (bitemyapp),Julie Moronuki at <http://haskellbook.com/>,#haskell-beginners
12:53:42 <Tuplanolla> I thought there was another recent book.
12:54:07 <ski> maybe ?
12:54:26 <cement> as long as it was written after ~2010, you're probably good
12:55:57 <ski> nicknight : if you haven't tried functional programming before, then the best mindset is probably "forget everything you know about programming" (you will have to unlearn some things)
12:56:03 <Psybur> I have newtype Cluster a, which has a constructor elements :: [a]. Can I pull out [a] with pattern matching?
12:56:08 <ski> @where CIS194
12:56:08 <lambdabot> http://www.seas.upenn.edu/~cis194/spring13/
12:56:21 <ski> @where NICTA
12:56:21 <lambdabot> https://github.com/nicta/course
12:56:25 <ski> @where Data61
12:56:25 <lambdabot> Data61 Functional Programming Course <https://github.com/data61/fp-course>,<https://qfpl.io/links/2017-october-fp-course/> by Tony Morris,Mark Hibberd
12:56:39 <ski> nicknight : perhaps those ^ could be useful, as well
12:57:01 <ski> Psybur : yes
12:57:38 <ski> (though `elements' can't be the data constructor, since they must start with upper case letter (or `:', if infix))
12:57:51 <Psybur> Its the newtype constructor
12:58:02 <ski> it's definitely not
12:58:22 <Psybur> Guess I dont know the proper term. https://hackage.haskell.org/package/kmeans-vector-0.3.2/docs/Math-KMeans.html#t:Cluster
12:58:27 <a6a3uh>     ski: its overly complicated for me to grasp :) I thought Lens approach with Traversal' could give most dense and short solution. But cant com up with right Traversal'. Can you suggest something?
12:58:58 <nicknight> ski:  imagine I dont know any programming language then? I want to make haskell as my primary languge if it fits me
12:59:22 <cement> all of those are good option
12:59:24 <cement> options*
13:00:25 <nicknight> I am missing conversation here sorry did you say anything here before?
13:00:55 <foobar_> nicknight: i think you should just buy the haskellbook 
13:01:04 <ski>   newtype Cluster a = Cluster { elements :: [a] }
13:01:08 <ski>           ^^^^^^^     ^^^^^^^   ^^^^^^^^
13:01:12 <ski>           type        data      field
13:01:14 <ski>              constructor|constructor|name/selector
13:01:24 <ski> something like that
13:01:36 <cement> aka record syntax
13:01:52 <nicknight> foobar_:  no free books?
13:02:01 <nicknight> cement:  gave me a book
13:02:13 <ski> Psybur : in this case, the type constructor is named the same as the data constructor .. which may sometimes be confusing, if one doesn't know the difference, or if one doesn't know which of them someone else means
13:02:19 <foobar_> nicknight: not anything written for very beginners to programming
13:02:24 <cement> http://www.seas.upenn.edu/~cis194/spring13/ @nicknight
13:02:26 <nicknight> its haskellbook and its 59$
13:02:30 <cement> that's probably the closest thing
13:02:30 <ski> a6a3uh : .. i'm not that good at lenses
13:02:45 <shloub> don't you guys like http://learnyouahaskell.com/ ?
13:02:53 <ski> nicknight : see above ?
13:03:06 <ski> (including what lambdabot said)
13:03:22 <Psybur> Ok yeah I can just pattern match on Cluster x -> ...
13:03:23 <nicknight> one min my browser trouble...I will read whole conversation 
13:03:33 <ski> shloub : it's been likened to a four-hour trailer of Haskell
13:04:08 <foobar_> nicknight: if you are resourceful you can find a free copy of haskellbook somewhere ;) if you like it then you can buy the book :)
13:04:11 <ski> shloub : pretty pictures, no exercises, not much depth, some brushing under carpet
13:04:46 <shloub> ski. alright, so much like an introduction?
13:05:03 <ski> well, it does catch the eye
13:05:25 <ski> (i didn't learn from it .. it didn't exist at that time)
13:05:25 <cement> not even an introduction, it's more like a spoilery movie trailer
13:05:38 <shloub> lol
13:07:52 <MP2E> as a beginner that learned haskell in late 2013/early 2014, LYAH was an alright introduction, but there were certainly many holes. I didn't feel like I could write anything useful immediately afterward
13:07:59 <MP2E> took cross referencing from a couple of books and papers heh
13:09:00 * hackagebot reducers 3.12.2 – Semigroups, specialized containers and a general map/reduce framework – https://hackage.haskell.org/package/reducers
13:10:39 <foobar_> anyone using iterno with emacs?
13:10:43 <foobar_> intero*
13:11:06 <cement> last I heard that was notoriously buggy with ghc
13:11:09 <foobar_> i can't make it to get the type of local bindings of a function
13:11:42 <dysfun> i'm using intero, but it's quite buggy
13:11:43 <foobar_> what plugins people use to query the types
13:11:56 <cement> ghc-mod in vim
13:12:18 <foobar_> cement: does it work with local types or just top level?
13:14:16 <cement> apparently it doesn't work at all for me
13:14:24 <cement> so I guess I'm FOS
13:15:46 <cement> oop nvm
13:15:53 <cement> I got it to work with nix trickery
13:16:34 <nicknight> https://www.edx.org/course/introduction-functional-programming-delftx-fp101x-0#!  any comments on this ?
13:16:56 <cement> if (nix-trickery) { then answer to your q = "yes"; else ans = "no"; }
13:18:36 <nicknight> CIS 194 gave to me sorry
13:18:44 <nicknight> I missed that conversation
13:21:04 <c_my_nick> is there an existing library suitable for showing a diff in large blocks of copy text?  i have a block of text that is typically 1-3 paragraphs long and would like to highlight word/phrase/punctuation changes in before/after edits
13:21:14 <c_my_nick> i have seen http://hackage.haskell.org/package/tree-diff, but it doesnt seem to be well suited for that
13:33:14 <ski> nicknight : ok, no worry
13:36:16 <dmwit> c_my_nick: The Diff package might be workable, depending on exactly what you want.
13:36:42 <dmwit> You may have to tokenize your input first e.g. if you want differences to only happen at word boundaries or similar.
13:42:03 <c_my_nick> output seems a bit weird.  prettyEditExpr $ ediff ["one", "two", "twoo", "three"] ["one", "two", "three", "four"] returns ["one", "two", -"twoo", +"three", -"three", +"four"]
13:47:49 <dmwit> What is ediff?
13:48:40 <dmwit> For that matter, what is prettyEditExpr?
13:49:04 <c_my_nick> functions in the library i linked to?
13:49:27 <dmwit> Oh. I thought you had already rejected that library.
13:49:48 <c_my_nick> the end result i am looking for is something like this: https://johnresig.com/projects/javascript-diff-algorithm/
13:50:15 <dmwit> The library I linked to does a better job.
13:50:22 <dmwit> getDiff ["one", "two", "twoo", "three"] ["one", "two", "three", "four"]
13:50:22 <dmwit> [Both "one" "one",Both "two" "two",First "twoo",Both "three" "three",Second "four"]
13:52:56 * hackagebot aeson-injector 1.1.0.0 – Injecting fields into aeson values – https://hackage.haskell.org/package/aeson-injector
13:54:36 <jared-w> aeson-injector... Isn't that just lenses with a dumber name? Or am I missing something? :p
14:05:52 <c_my_nick> dmwit:  ok, i will check it out.  thanks for the suggestion
14:29:23 <Darwin226> Can someone try compiling this with O2? https://gist.github.com/091bdef34c26039af14787d3302b0075
14:29:29 <Darwin226> Watch your memory
14:29:39 <Darwin226> Requires the MemoTries package
14:33:44 <srhb> Darwin226: Yes, that appears to blow up.
14:33:56 <Darwin226> Which version are you using?
14:34:11 <srhb> Darwin226: 802, though I can test with any version you like.
14:34:23 <Darwin226> Can you try with 8.2?
14:34:28 <srhb> Sure, one moment.
14:35:54 <srhb> Darwin226: 821 compiles succesfully in moments.
14:36:03 <Darwin226> Ok then, I wont report it
14:36:31 <jared-w> DeriveGeneric is often a bit tricky in memory usage, especially before 8.2 I believe
14:43:37 * hackagebot colorless 2.2.3 – Colorless – https://hackage.haskell.org/package/colorless
14:44:13 <jared-w> s/often/can sometimes be/
15:02:14 <crucify_me> hi yesterday I had an excellent chat with 'member' re: the attempts of ghci to unify a bad input . I studied the log after missing plenty during the chat, and would like to ask specific questions. there are line numbers. http://lpaste.net/7044319382796763136      anyone care to? 
15:02:41 <crucify_me> ^ transcript of log
15:03:04 <crucify_me> the program is here https://ptpb.pw/jF2A
15:03:53 <crucify_me> my questions begin around lines 40 - 50
15:04:42 <fishythe_> go ahead and ask
15:04:49 <yogo> > unsafeCoerce "yo" :: Maybe Int
15:04:52 <lambdabot>  error:
15:04:52 <lambdabot>      Variable not in scope: unsafeCoerce :: [Char] -> Maybe Int
15:04:57 <fishythe_> usually better just to ask questions and see who responds ;)
15:05:28 <yogo> > coerce "yo" :: Maybe Int
15:05:30 <lambdabot>  error:
15:05:31 <lambdabot>      • Variable not in scope: coerce :: [Char] -> Maybe Int
15:05:31 <lambdabot>      • Perhaps you meant ‘coerced’ (imported from Control.Lens)
15:05:40 <qih> I admire crucify_me stalkerish use of chat logs for technical learning +1
15:06:30 <crucify_me> yeah its sensitive because the member was super helpful and intelligent, their remarks were a bit over my head but I was sort of getting it. 
15:06:41 <fishythe_> yogo: lambdabot doesn't have all functions imported. you can also message lambdabot directly instead of in #haskell
15:06:48 <crucify_me> qih: pardon?
15:08:37 <crucify_me> fishythe_: thank you. the first thing re: 'says' on line 49
15:09:13 <fishythe_> mhm
15:09:14 <crucify_me> that means 'would be b -> b if it were correct, right?
15:09:24 <fishythe_> kind of
15:09:31 <qih> crucify_me: No offence intended, good use of chat logs.
15:09:45 <fishythe_> the full type of applyTimes is a -> (b -> b) -> b -> b
15:10:01 <crucify_me> yeah because it was awesome I just couldn't keep up qih :)
15:10:12 <crucify_me> fishythe_: yes
15:10:21 <fishythe_> line 49 is just saying that supplying the arguments 5 and (+) fills the a and (b -> b) positions
15:10:44 <crucify_me> right
15:11:16 <fishythe_> in particular, it means that 5 :: a and (+) :: b -> b
15:11:37 <crucify_me> but it 'fills' them theoretically since it would need to be a -> a -> a
15:11:53 <crucify_me> (b -> b) would need to be ^
15:12:13 <crucify_me> so I realize its wrong. the chat goes on to explain it in logic using id
15:12:18 <fishythe_> right, that's the unification going badly
15:12:57 <fishythe_> however, that's from the human point of view
15:13:04 <fishythe_> you can immediately see that (+) won't fit
15:13:32 <fishythe_> the procedure that member explains is a more systematic method
15:13:43 <fishythe_> you just try to solve for b and see where you get stuck
15:14:28 <fishythe_> assume we specialize to (+) :: Int -> Int -> Int
15:14:35 <fishythe_> recall that this is the same as Int -> (Int -> Int)
15:14:53 <fishythe_> if this is the same as b -> b, then we must simultaneously have b ~ Int and b ~ Int -> Int
15:15:10 <fishythe_> by transitivity, Int ~ Int -> Int, and this is clearly false
15:15:24 <crucify_me> ok this is where I lost member yesterday. one moment pls
15:15:55 <crucify_me> note, I just learned ~   so I don't know it very well
15:16:05 <fishythe_> just think of ~ as type equality here
15:16:37 <crucify_me> fishythe_: thanks, give me a minute to form my next question
15:16:46 <EvanR> and Int ~ Int -> Int is clearly false because
15:17:11 <crucify_me> please look at line 49,50
15:17:41 <crucify_me> b -> b   ..  
15:19:35 <fishythe_> EvanR: hm?
15:21:33 <fishythefish> crucify_me: what about those lines?
15:21:37 <crucify_me> ok I 'd like to see logically why this is wrong : b -> b ~ a -> a -> a    I do understand  ...
15:22:36 <fishythefish> so that's the next step. rather than taking (+) to be Int -> Int -> Int, let's generalize and allow a -> a -> a
15:22:40 <fishythefish> :t (+)
15:22:41 <lambdabot> Num a => a -> a -> a
15:22:47 <crucify_me> that the program compiles because it thinks (+ 1) is a -> a   OR   in this case b -> b
15:22:50 <fishythefish> we're just ignoring the Num constraint
15:23:26 <crucify_me> :t (+ 1)
15:23:28 <lambdabot> Num a => a -> a
15:23:42 <fishythefish> right, in the (+1) case, it unification succeeds because we can unify a -> a with b -> b via a ~ b
15:23:47 <crucify_me> so a -> a here fits (b -> b) in the signature
15:24:07 <crucify_me> right yes that itself is a unification
15:24:52 <fishythefish> in the case of (+), we're trying to solve a -> a -> a ~ b -> b
15:25:23 <fishythefish> remember that a -> a -> a is the same as a -> (a -> a)
15:25:26 <crucify_me> so at least I understand the conflict. 
15:25:36 <fishythefish> so we end up with a ~ b and a -> a ~ b
15:25:41 <fishythefish> by transitivity, a ~ a -> a
15:25:56 <crucify_me> hold on in the case of (+)  ?
15:26:23 <fishythefish> yup, remember we're trying to unify the type of the function you supply with b -> b
15:26:28 <fishythefish> for (+1), the type was a -> a
15:26:31 <fishythefish> for (+), it's a -> a -> a
15:27:08 <iqubic> What problem are we trying to tackle?
15:27:56 <crucify_me> http://lpaste.net/7044319382796763136
15:28:05 <crucify_me> iqubic: 
15:28:14 <iqubic> Yes, crucify_me?
15:28:26 <crucify_me> the problem is in that paste
15:28:37 <crucify_me> its a chat log
15:29:02 <crucify_me> one moment fishythefish really appreciate it
15:29:28 <iqubic> Can you summarize that for me. Just give me the TL;DR version.
15:29:50 <fishythefish> tl;dr: why can't I supply (+) as an argument of type b -> b?
15:30:14 <iqubic> Oh, I see.
15:30:22 <crucify_me> so in this case we are supplying (+1)
15:30:31 <iqubic> :t (+1)
15:30:33 <lambdabot> Num a => a -> a
15:31:00 <iqubic> :t let f n = (+ n) in f n
15:31:02 <lambdabot> Expr -> Expr
15:31:13 <iqubic> Why is that the type?
15:31:39 <hpc> :t n
15:31:41 <lambdabot> Expr
15:31:46 <crucify_me> oh boy
15:31:49 <EvanR> + has two args, b -> b has 1 (simplistic explanation)
15:31:51 <iqubic> I see.
15:32:38 <fishythefish> crucify_me: ignore the lambdabot nonsense for now. EvanR's explanation is the important point here
15:32:44 <fishythefish> though it might not line up with GHC's error message
15:33:24 <iqubic> I was trying to find out the type of "f n = (+) n"
15:33:35 <hpc> :t let f n = (+ n) in f
15:33:37 <lambdabot> Num a => a -> a -> a
15:33:52 <iqubic> Yes, that is what I wanted.
15:34:36 <crucify_me> I do understand EvanR 's post  , thanks. but if you would look at member's irc posts, they go into an interesting explanation that I'd like to fully understand
15:34:55 <fishythefish> yup, and i've basically been rehashing what member said
15:35:37 <Tuplanolla> There is a solution to finding an isomorphism between `a -> a` and `b -> b -> b`, but it's a boring one, crucify_me.
15:35:58 <iqubic> Tuplanolla: What is the solution?
15:36:38 <Tuplanolla> Let `b` be `()` and use the identity of exponentiation, iqubic.
15:36:53 <iqubic> Oh
15:37:21 <iqubic> a -> a ~ () -> b -> b?
15:37:25 <crucify_me> b -> b ~ a -> a -> a is the same as b -> b ~ a -> (a -> a)    << this is where I lost the thread yesterday
15:37:30 * ski thought fishythefish meant abstract `a' and `b' ?
15:37:44 <crucify_me> ok sorry I cannot keep up here
15:37:49 <ski> crucify_me : `A -> B -> C' is short for `A -> (B -> C)'
15:37:54 <fishythefish> crucify_me: #haskell isn't known for great pedagogy
15:37:59 <fishythefish> ski is on the same page as me
15:38:11 <fishythefish> everyone else is supplying technically-correct information which probably isn't useful to you
15:38:11 <Tuplanolla> Rather `() -> ()` and `() -> () -> ()`, iqubic.
15:38:32 <iqubic> That's boring alright. 
15:38:32 <fishythefish> feel free to private message me at any point
15:38:38 <ski> crucify_me : an equation `A -> B  =  X -> Y' can be simplified to the two equations (simultaneous equation system) `A = X' and `B = Y'
15:38:43 <Tuplanolla> You can ignore my aside, crucify_me.
15:40:15 <ski> (i prefer writing `=' to `~')
15:40:52 <fishythefish> (me too, honestly. i just wanna keep consistent notation)
15:41:21 <iqubic> ski: however, you are fine using a backtick and an apostrophe  at the same time?
15:41:39 <fishythefish> iqubic: welcome to \LaTeX
15:41:55 <iqubic> I don't LaTeX
15:43:20 <crucify_me> chat lines 158 -165      this is what I'd like to discuss if anyone has time
15:43:30 <crucify_me> http://lpaste.net/7044319382796763136
15:44:31 <fishythefish> sure
15:44:39 <crucify_me> for starters anyway :)
15:45:18 <crucify_me> so this is wrong b -> b ~ a -> (a -> a)
15:45:28 <iqubic> Correct.
15:46:30 <crucify_me> we cannot unify these because of an infinite set of values, ie , I believe , a ~ a -> a means that a -> a is bigger than a
15:47:24 <crucify_me> so in   a ~ a -> a     ,     a -> a is bigger than a . meaning the input set is bigger than itself. 
15:47:44 <fishythefish> mmm, I wouldn't bother introducing values here
15:47:57 <fishythefish> just look what happens when you try to find a closed form for a:
15:48:07 <fishythefish> a = a -> a = (a -> a) -> (a -> a) = ...
15:48:10 <fishythefish> the type itself is infinite
15:49:51 <crucify_me> so what comes after b -> b -> a -> (a -> a)    , logically ?
15:50:06 <fishythefish> do you mean b -> b ~ a -> (a -> a)?
15:50:17 <crucify_me> correction, yes : so what comes after b -> b ~ a -> (a -> a)    , logically ?
15:50:27 <fishythefish> we can deconstruct that into the two simultaneous equations b ~ a and b ~ (a -> a)
15:50:47 <crucify_me> right, so there is our problem
15:51:13 <crucify_me> so the problem can be written like this
15:51:15 <crucify_me> :
15:51:54 <crucify_me> um
15:52:28 <crucify_me> sorry, I lost my train of thought
15:52:45 <fishythefish> no worries
15:53:01 <fishythefish> continuing, we can apply transitivity to get a ~ (a -> a)
15:53:17 <crucify_me> back to lines 158-162 @
15:53:35 <fishythefish> sure
15:54:15 <crucify_me> right ok so its transitive fishythefish
15:54:26 <crucify_me> so a ~ (a -> a)
15:54:40 <crucify_me> that itself results in an infinite ... what?
15:54:43 <fishythefish> type
15:54:50 <fishythefish> a is an infinite type
15:54:56 <crucify_me> ok if we could discuss that 
15:55:17 <crucify_me> so the program is looking for (b -> b)
15:55:30 <fishythefish> yup
15:55:35 <crucify_me> after an attempt to unify, ghc
15:55:36 <crucify_me> ...
15:55:57 <crucify_me> gives us the false unification
15:56:20 <fishythefish> i wouldn't call this a false unification
15:56:28 <fishythefish> the unification fails, actually, because we can't have infinite types
15:56:58 <fishythefish> basically, in its effort to unify a -> a -> a with b -> b, the typechecker concludes that a ~ (a -> a)
15:57:01 <crucify_me> ok yeah I knew that was off
15:57:16 <fishythefish> since such a type a is disallowed, we can conclude that a -> a -> a cannot be unified with b -> b
15:57:31 <crucify_me> ok thank you so ... 
15:58:04 <crucify_me> how does a ~ (a -> a) represent a set that is infinitely large, and larger than a itself?
15:58:24 <crucify_me> I merely don't understand the notation fully
15:58:25 <fishythefish> ah, i think i see the misunderstanding
15:58:35 <fishythefish> an infinite type doesn't mean that its underlying set of values is infinite
15:58:36 <hpc> it's not that the type has infinite members
15:58:41 <fishythefish> Integer is an "infinite type" in that sense
15:58:44 <hpc> it's that to write the type you need infinite ink
15:58:50 <fishythefish> what hpc said :)
15:59:06 <crucify_me> nice !
15:59:09 <hpc> Integer is a good example of a type that has infinite members
15:59:20 <crucify_me> ok got that hpc  thanks ...
15:59:32 <fishythefish> crucify_me: if a ~ (a -> a) seems confusing, consider trying to solve a ~ [a]
16:00:01 <fishythefish> a ~ [a] ~ [[a]] ~ [[[a]]] ~ ...
16:00:16 <fishythefish> i.e. a would be the type of infinitely nested lists
16:00:17 <crucify_me> so just symbolically, we are 'relating' a with a -> a   ..     ok that is helpful fishythefish  one sec
16:01:36 <crucify_me> so if you see a ~ a -> a   , you instantly know its wrong
16:01:46 <fishythefish> yup
16:01:54 <fishythefish> ~ isn't just any relation, it's really type equality
16:02:07 <fishythefish> i.e. a ~ b means that you should be able to substitute b for a and vice versa
16:02:07 <hpc> for extra credit, you can write something resembling a type quality constraint using ordinary data types
16:02:19 <hpc> the constraint (a ~ a) can be written as data Identity a = a
16:02:24 <fishythefish> if we have a ~ (a -> a), then we should always be able to substitute a -> a for a
16:02:35 <fishythefish> but doing that repeatedly in its own definition results in an infinite expression
16:02:53 <crucify_me> ok so a ~ [a]  tells you that nesting is involved. 
16:02:58 <crucify_me> how?
16:03:21 <hpc> and the constraint (a ~ (a -> a)) can be written as data Whatever a = Something (Whatever a -> Whatever a)
16:03:22 <crucify_me> ok so a = [a]   which is false
16:03:22 <fishythefish> a ~ [a] is disallowed for the same reason a ~ (a -> a) is
16:03:36 * ski . o O ( occurs-check )
16:04:01 <ski> hpc : warning : `a' is unused
16:04:19 <hpc> usually this is used to express (a ~ f a), for certain interesting classes of f
16:04:23 <crucify_me> so if a \= [a]  how would that imply nesting  ? I don't see that.
16:04:26 <hpc> ski: eh?
16:05:05 <ski> hpc : similar to `foo x = foo x ++ foo x'. `x' is only passed to recursive calls, never actually used
16:05:14 <fishythefish> crucify_me: not sure what you mean by "imply", but here is why a ~ [a] is problematic
16:05:20 <fishythefish> suppose you have something of type a
16:05:24 <hpc> ski: oh, that it is
16:05:32 <fishythefish> since a ~ [a], it also has type [a]
16:05:44 <fishythefish> but that means it also has type [[a]] since we can substitute once more
16:05:51 <crucify_me> ok got that
16:05:54 <fishythefish> we can continue this substitution infinitely
16:06:04 <hpc> ski: phantom type parameter for illustrative purposes only ;)
16:06:49 <fishythefish> in general, unification of a type variable a with any structure containing a will fail
16:06:57 <fishythefish> this is known as the "occurs check"
16:07:16 <crucify_me> ok now we're getting there. please bear with me.
16:07:20 <hpc> oh, i just got why it's called that
16:07:27 <hpc> (a ~ b) fails if a /occurs/ in b
16:07:30 <fishythefish> hpc: yup :)
16:07:47 <ski> @type let x = In [x] in x
16:07:49 <lambdabot> Mu []
16:07:49 <fishythefish> the trivial a ~ a notwithstanding
16:07:51 <ski> > let x = In [x] in x
16:07:53 <lambdabot>  In [In [In [In [In [In [In [In [In [In [In [In [In [In [In [In [In [In [In [...
16:08:19 <hpc> @src Mu
16:08:19 <lambdabot> newtype Mu f = In { out :: f (Mu f) }
16:08:26 <ski> (if you ignore the `In's, that is what a value of type `[[[[...]]]]', resulting from `a = [a]', could look like)
16:08:35 <crucify_me> "unification of a type variable a with any structure containing a will fail"
16:08:40 <ski> > In []
16:08:43 <lambdabot>  In []
16:09:08 <hpc> learning to ignore data constructors when convenient is a useful thing to train your eyes for
16:09:09 <crucify_me> ok I'm focusing on that. I need to powder my nose one moment
16:12:53 <crucify_me> ski what's that In   you're using
16:12:56 <crucify_me> ?
16:13:08 <hpc> it's the data constructor for the Mu type
16:13:09 <ski> data constructor of `Mu', see above
16:13:09 <hpc> @src Mu
16:13:10 <lambdabot> newtype Mu f = In { out :: f (Mu f) }
16:13:29 <fishythefish> f-algebras and fixed points, always a fun topic :)
16:13:35 <ski> a simpler version of the same would be
16:13:43 <crucify_me> fishythefish:     ...
16:13:44 <ski>   newtype Mu f = In (f (Mu f))
16:14:03 <crucify_me> so looking at a ~ [a]  and   a ~ (a -> a)
16:14:14 * ski proposes we change the subject to `g'-algebras instead
16:14:24 <crucify_me> the (a -> a) is a function right?
16:14:29 <ski> no, it's a function type
16:14:29 <fishythefish> ski: class Gunctor g where ...
16:14:32 <fishythefish> function type
16:14:35 * ski smiles
16:14:44 <crucify_me> right it is a function that takes one input
16:14:48 <ski> no
16:14:50 <ski> it's a type
16:14:51 <fishythefish> the type of a function
16:14:58 <hpc> ski: no no no, you run F algebra on a G machine
16:15:00 <fishythefish> a function would be a value of that type
16:15:02 <ski> the type of functions which take an input of type `a', and return a result of type `a'
16:15:17 <crucify_me> right ok yes I'm with that
16:16:02 <crucify_me> so its a structure so to speak in the way that [] is a structure
16:16:18 <crucify_me> or [a]
16:16:20 <ski> hpc : oh, but if i happen to have an H machine, what will you do then ? huh ?
16:16:22 <fishythefish> yeah, by "structure", I just mean "type"
16:16:37 <fishythefish> a -> a is a type containing a, as is [a]
16:16:47 <crucify_me> ok, bear with me thanks!    .....
16:16:50 <hpc> ski: it has to be named something different
16:16:54 <hpc> like... preparation h :P
16:17:16 <ski> (no, not the preparations !)
16:17:17 * fishythefish shifts uncomfortably
16:17:34 * ski controls shiftedly
16:17:36 <crucify_me> << gets firm pillow
16:17:44 * hpc alts superlatively
16:17:56 * fishythefish verbs adverbially
16:18:13 <crucify_me> how do you do the bullet thing?
16:18:14 <hpc> this is getting pretty noun
16:18:16 * ski resets back to the prompt, restarts the condition
16:18:20 <fishythefish> slash me crucify_me 
16:18:36 * ski promptly slashes fishythefish
16:18:50 <crucify_me> wha?
16:18:55 * fishythefish can't unify ski ~ crucify_me 
16:19:15 <fishythefish> (perhaps we should get back to types)
16:19:34 <ski> .. ok -- if you insist
16:19:48 <crucify_me> ok so look this is very helpful I would love to keep you guys here
16:20:14 <crucify_me> so its nested [[a]]  ... [[[a]]]
16:20:45 <crucify_me> does that mean a is related to an empty list []   ?
16:20:46 <fishythefish> crucify_me: sorta. think of it like this
16:20:51 <ski> > let x = "[" ++ x ++ "]" in x
16:20:52 <fishythefish> a ~ [a] is a recursive definition for the type a
16:20:54 <lambdabot>  "[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[...
16:21:08 <fishythefish> in an attempt to find a closed form for it, we repeatedly substitute [a] for a
16:21:26 <fishythefish> unfortunately, that results in the infinite type [[[[[[...]]]]]]
16:21:35 <crucify_me> ok
16:21:43 <fishythefish> to use hpc's wonderful phrasing, writing that out would take infinite ink
16:21:44 <ski> (after waiting a countable infinite time, it will print "]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]")
16:22:29 <crucify_me> and good japanese ink is expensive
16:22:43 <hpc> this is why haskellers use single-character type variables
16:23:02 * ski idly notices that you can color a trumpet with infinite area, using a finite volume of ink
16:23:04 <crucify_me> so wait this :   a ~ [a] is a recursive definition for the type a
16:23:34 <fishythefish> "definition" might not be the right word
16:23:39 <ski> it's a recurrence, a recursive equation
16:23:41 <fishythefish> let's just call it a recursive type equality
16:23:54 <ski> in Haskell, it has no solution
16:23:58 <ski> (on the nose)
16:24:16 * fishythefish wonders why we have to bring torricelli into this
16:24:33 <mniip> but but but
16:24:36 <mniip> axiom schemes
16:24:50 <fishythefish> sorry, this is the channel for axiom haskells
16:25:49 <crucify_me> so a ~ (a -> a)   is also a recursive equation
16:26:13 <fishythefish> yes
16:26:32 <crucify_me> the [a] illustration is a bit easier for me right now. how to illustrate ^
16:26:44 <fishythefish> absolutely. we can stick with [a]
16:27:25 <crucify_me> ok , member said this all has to do with really understand currying
16:27:30 * ski . o O ( <https://upload.wikimedia.org/wikipedia/commons/a/ae/Vittoria_della_Rovere_by_G._A._Torricelli_%28Kremlin_exhibition%2C_Moscow_2011%29_02_by_shakko.jpg> )
16:27:49 <fishythefish> in a way, yes, but we already used currying before
16:27:59 <fishythefish> remember when we said a -> a -> a was the same as a -> (a -> a)?
16:28:06 <crucify_me> yes
16:28:11 <fishythefish> currying
16:28:22 <ski> curried style
16:28:28 <fishythefish> more generally, a -> b -> c is the same as a -> (b -> c)
16:28:47 <ski> (currying is the process of turning something into curried style)
16:29:08 <fishythefish> a "two-argument" function of type a -> b -> c is really a unary function taking an argument of type a and spitting out a function of type b -> c
16:29:26 <crucify_me> right got that..
16:29:57 <crucify_me> right a becomes "ab" -> c
16:30:06 <fishythefish> whoa, hold on
16:30:16 <fishythefish> a doesn't become anything
16:30:22 <fishythefish> also "ab" is a string
16:30:48 <crucify_me> no I meant it resolves to a partially resolved function and is applied to c
16:30:54 <fishythefish> applied to b
16:31:06 <fishythefish> c is the output
16:31:38 <crucify_me> ok actually I meant pretty much that sorry bad wc
16:31:52 <crucify_me> but fishythefish  ...
16:32:43 <crucify_me> when member gets into (`asTypeOf` id ) f
16:32:52 <crucify_me> on line  , er ...
16:33:23 <crucify_me> 158
16:33:56 <crucify_me> 159
16:34:27 <fishythefish> mhm
16:35:14 <crucify_me> (+) `asTypeOf` id  they say it means that (+) must have the same type as id
16:35:44 <crucify_me> so perhaps you can see why I glazed over . I wasn't following this
16:35:51 <fishythefish> crucify_me: asTypeOf is the same as const with a slight difference
16:35:52 <fishythefish> :t const
16:35:54 <lambdabot> a -> b -> a
16:35:54 <fishythefish> :t asTypeOf
16:35:56 <lambdabot> a -> a -> a
16:36:13 <fishythefish> both functions will just return the first argument, but asTypeOf forces both arguments to have the same type
16:37:34 <crucify_me> so in light of the chat yesterday, what was member saying about this ?
16:38:17 <fishythefish> well, he was trying to demonstrate what happens if you try to force (+) to have type b -> b
16:38:21 <fishythefish> :t (+) :: b -> b
16:38:23 <lambdabot> error:
16:38:23 <lambdabot>     • Couldn't match type ‘b1’ with ‘b1 -> b1’
16:38:23 <lambdabot>       ‘b1’ is a rigid type variable bound by
16:38:40 <fishythefish> however, you can see that doing what I just did results in a different type error than before
16:38:56 <fishythefish> :t id
16:38:58 <lambdabot> a -> a
16:39:12 <fishythefish> note that id has the type b -> b (or a -> a), so we can instead do this
16:39:20 <fishythefish> :t (+) `asTypeOf` id
16:39:22 <lambdabot> error:
16:39:22 <lambdabot>     • Occurs check: cannot construct the infinite type: a ~ a -> a
16:39:22 <lambdabot>       Expected type: a -> a -> a
16:39:30 <fishythefish> and now we get the infinite type error from before
16:40:09 <crucify_me> got it ! yes because in the type checker you are getting the same result as if you ran it with 5 (+) 5   !
16:40:56 <fishythefish> 5 (+) 5 doesn't make sense, and i'm not quite sure what you're saying :)
16:41:39 <crucify_me> I meant in the original failure, correction : applyTimes 5 (+ 1) 5
16:41:54 <fishythefish> right
16:42:11 <fishythefish> ignoring typeclass constraints
16:42:42 <crucify_me> its the same error as forcing it (+) to conform to id or to b -> b 
16:43:04 <fishythefish> to the type of id, which is b -> b, yes
16:43:48 <crucify_me> right so although those inputs are both identity, they yield different errors. ok I got this fishythefish that is awesome thank you !
16:44:09 <fishythefish> no problem :)
16:44:31 <crucify_me> I learned a *shitload* about types in 48 hours !
16:46:33 <ski> fishythefish : .. yeah, i tend to say that there's two main ways of *encoding* multiple-argument functions in Haskell. curried style and tupled style
16:47:18 <ski> (there also happens to be two main ways of encoding existential quantification)
16:47:29 <crucify_me> ski thanks for your help as well !
16:47:48 <ski> oh, yw
16:48:14 * ski is sleepy
16:48:15 <fishythefish> ski: oh, i agree with your terminology there
16:48:35 <fishythefish> i guess i think about "currying" in terms of mental models rather than the curry function itself
16:49:18 <fishythefish> converting a -> b -> c to a -> (b -> c) is "currying" to me if you read the former type as a binary function type
16:49:36 <fishythefish> even though the types are equal in haskell
16:57:50 <ski> fishythefish : it can be a bit confusing that `curry' can be used both to curry a tupled function, and to partially apply it
16:58:22 <ski> (when seen as a way to partially apply a (tupled) function, `curry' is itself curried)
16:58:33 <ski> @type uncurry curry
16:58:34 <lambdabot> ((a, b) -> c, a) -> b -> c
17:00:10 <fishythefish> agreed
17:51:32 * hackagebot colorless 2.2.4 – Colorless – https://hackage.haskell.org/package/colorless
18:15:56 <|{ame> hello, I have a hs file that I import, and I want to change a single function of it. Is there a way to do that without copying and pasting the file and editing it?
18:17:46 <|{ame> suppose a.hs contains f and g, and f uses g, and I want to change g to a g'
18:24:39 <geekosaur> no, the only option you have is to copy and modify the file
18:26:45 <|{ame> thank you, I will do that then
18:27:25 <dmwit> You can change the file so that `f` takes `g` as an argument...
18:27:27 <geekosaur> when you import a module, you are referring to native-compiled code. not source that can be modified by replacing references
18:43:32 <boogalooga> can someone help me find the flaw in my logic
18:43:42 <boogalooga> I'm trying to convert a number into a list of its digits
18:43:45 <boogalooga> https://imgur.com/a/o62Px
18:45:12 <boogalooga> nvm
18:45:14 <boogalooga> I'm an idiot
18:45:16 <boogalooga> sorry lol
18:45:17 <boogalooga> wtf
18:46:01 <boogalooga> But yea, is there a better way to do this
18:46:08 <boogalooga> after I fix my simple logic error
18:46:10 <boogalooga> ?
18:53:55 <geekosaur> divMod to do both in one operation, maybe
19:04:41 <boogalooga> hmm
19:04:42 <boogalooga> also
19:04:53 <boogalooga> is adding the to front of the list
19:05:03 <boogalooga> and reversing it really the bestway
19:05:03 <boogalooga> ?
19:05:21 <geekosaur> generally, unless the resulting list is really short
19:05:33 <Apocalisp> What's a good setup for quick and dirty visualization of 2d geometry?
19:05:36 <geekosaur> appending with (++) means multiple traversals, whereas revrse is just one traversal at the end
19:06:25 <geekosaur> although you could use a difference list (see ShowS)
19:06:38 <Apocalisp> e.g. I have a `[(Int,Int)]` and I want to see what those points look like as a 2d plot, or as a polygon
19:09:35 <boogalooga> ok thanks
19:48:05 <dmwit> Apocalisp: Dump it in a spreadsheet and use the spreadsheet's chart facilities.
19:48:46 <Apocalisp> dmwit: I'd like to do this basically as quickly as I can try things out in ghci
19:48:49 <dsal> R is my spreadsheet.
19:49:10 <Apocalisp> right, Mathematica is mine. But I'd like Haskell to be my spreadsheet
19:49:38 <dsal> Could be nice.  I hear some people use python, so I guess anything's possible.
19:49:48 <dmwit> I mean, there are ways. But if you want quick and dirty, you're not going to beat tools specifically made for this.
19:50:00 <dmwit> And it is super easy to dump in a format that a spreadsheet will understand.
19:50:16 <dmwit> `mapM_ (\(x,y) -> putStrLn (show x ++ "," ++ show y))` and done
19:50:35 <Apocalisp> does excel have facilities for rendering 2d geometry?
19:50:38 <dmwit> yes
19:50:44 <Apocalisp> well heck
19:52:57 <Welkin> matplotlib is used in numpy/scipy
19:53:39 <Welkin> with ipython/jupyter notebook
19:54:11 <Welkin> you can use jupyter notebook with haskell too
19:55:15 <Welkin> https://github.com/gibiansky/IHaskell
19:57:29 <EvanR> haskell as a spreadsheet? are we talking about FRP? *ducks*
19:58:40 <Welkin> there is also, of course, https://hackage.haskell.org/package/hledger
19:58:52 <geekosaur> didn't SPJ claim spreadsheets are the most common FP "language"? (... insert möb here ...)
19:59:00 <Welkin> double-entry accounting with haskell
19:59:27 <pharaun> can i get a monad to do my taxes for me?
20:00:22 <Welkin> I never actually thought about using hledger, but taking a second look at it now, I think I might
20:00:34 <Welkin> I started using gnucash a while back and have since neglected it
20:00:39 <Welkin> I wonder if hledger will fare better
20:01:35 <vaibhavsagar> I <3 IHaskell
20:01:40 <EvanR> i loved gnucash
20:01:43 <sm> go on Welkin, what could possibly go wrong
20:01:49 <vaibhavsagar> if anyone has issues with it please raise :)
20:02:55 <geekosaur> only real issue I have with it is I really wish someone would come up with friendly packaging for it
20:03:10 <Welkin> you mean the hledger ui?
20:03:28 <geekosaur> no, IHaskell/Jupyter
20:05:16 <pharaun> <- is migrating their gnucash -> ledger
20:05:25 <pharaun> its a bit slow going (xml libraries x_X)
20:05:34 <monochrom> https://plus.google.com/+ConradParker/posts/Armn9rcrK8g
20:05:40 <equalunique[m]> thanks people for sharing about hledger & IHaskell/Jupyter. Cool stuff.
20:05:54 <EvanR> what is xml doing in my spreadsheet ;_;
20:06:01 <pharaun> gnucash :P
20:06:24 <pharaun> do you want xml in your databases? because that's how you get xml in your databases
20:06:37 <monochrom> Perhaps it is not a database
20:07:15 <EvanR> excel vs access
20:07:31 <pharaun> heh access was my first db
20:14:09 <ski> "Vital is a document-centered implementation of Haskell" <https://web.archive.org/web/20140715033114/http://www.cs.kent.ac.uk/projects/vital/>;"Typed and composable spreadsheets" <http://www.haskellforall.com/2015/11/haskell-native-spreadsheets.html>,<https://hackage.haskell.org/package/typed-spreadsheet>,<http://www.haskellforall.com/2014/06/spreadsheet-like-programming-in-haskell.html>
20:14:15 <ski> "HsExcel" <http://www.mrtc.mdh.se/projects/Haxcel/>;"Haxcel: A Spreadsheet Interface to Haskell" <http://www.mrtc.mdh.se/projects/Haxcel/>
20:18:01 * hackagebot Frames 0.2.1.1 – Data frames For working with tabular data files – https://hackage.haskell.org/package/Frames
20:18:31 <PyratedKat> hey all 
20:19:38 <Axman6> o/
20:29:15 <PyratedKat> no ones awake eh 
20:38:06 <jle`> most people idling :)
20:45:25 * hackagebot primes-type 0.2.0.0 – Type-safe prime numbers. – https://hackage.haskell.org/package/primes-type
20:59:59 <pacak> Is there a profunctor-like typeclass that provides something like rmap1 :: (Foo p) => (forall t. b t -> c t) -> p a b -> p a c?
21:07:25 <lyxia> This is more or less HFunctor, but there isn't a canonical package for it yet.
21:08:29 <lyxia> https://hackage.haskell.org/package/quickcheck-state-machine-0.1.0/docs/Test-StateMachine-Types-HFunctor.html for example
21:10:41 <pacak> lyxia:  Yea, looks like it. Thanks :)
21:16:33 <jle`> pacak: i use the one from type-combinators
21:17:10 <jle`> i've been using this library for all my stuff like this :)
21:17:19 <jle`> http://hackage.haskell.org/package/type-combinators-0.2.4.3/docs/Type-Class-Higher.html
21:18:30 <pacak> Right. But again - only Functor1/Bifunctor1...
21:19:19 <jle`> oh hm it's slightly different than yours in that o's arguments are flipped
21:19:26 <jle`> *p's arguments
21:19:58 <pacak> Desired Foo should be profunctor like thingy with rmap1/lmap1
21:20:10 <jle`> it's map1 :: Functor1 p => (forall t. b t -> c ) -> p b a -> p c a
21:21:08 <jle`> ah i see
21:23:29 <jle`> * (forall t. b t -> c t)
21:24:35 <dsal> I'm a little stuck on what would be incredibly easy in like, C or something...  What's a strategy for doing a doubly-linked list?  (Assuming IORef is available)
21:25:03 <dsal> Every time I think I have a good structure, I don't know how to make the first one because I don't have it yet to link to itself.
21:25:44 <jle`> you can do something similar to the canonical singly-linked list type
21:26:10 <jle`> using knot-tying
21:26:21 <dsal> I'm not familiar with that term.
21:26:48 <jle`> circular references that rely on laziness to work
21:27:06 <dsal> Makes sense.  I think I tried that a bit.  Reading an article now.
21:27:07 <jle`> > let xs = 1 : 2 : 3 : xs in take 10 xs
21:27:11 <lambdabot>  [1,2,3,1,2,3,1,2,3,1]
21:27:24 <jle`> but you can also of course do an exact "clone" of the C version using IORefs
21:27:41 <dsal> The problem is I need a new ioref that points to the thing I'm making so I can put it in it.
21:28:39 <geekosaur> wouldn't it be an IORef (Maybe ...) ? then a Nothing in it is end of the list in that direction
21:29:01 <iqubic> Is glguy around?
21:29:04 <dsal> Hmm...  Yeah, I thought about shoving a maybe in there.
21:29:11 <pacak> or MVar...
21:29:24 <dsal> I guess I should learn mvar while I'm at it.
21:29:56 <pacak> Are you sure that  doubly-linked list is exactly what you need? Can you explain your task a bit?
21:30:40 <jle`> yeah it's not a data structure that comes up very often in haskell, i sort of assumed you were just doing it as a learning exercise
21:30:50 <dsal> It's an exercism thing.  It's a data structure that you can add or remove in either end.
21:31:16 <jle`> ah yeah there are "pure"/persistent data structures for that that we use in haskell
21:31:40 <pacak> @hoogle Data.Sequence
21:31:41 <lambdabot> module Data.Sequence
21:31:41 <lambdabot> Data.Yaml.Parser Sequence :: [YamlValue] -> Anchor -> YamlValue
21:31:41 <lambdabot> module Data.Tuple.Sequence
21:31:42 <jle`> for such a data structure with such O(1) operations there are immutable data structures we often use instead of doubly-linked lists
21:31:48 <jle`> namely finger trees
21:32:15 <jle`> (and Data.Seqeunce from containers is the canonical finger tree implementation in haskell)
21:32:40 <dsal> Makes sense.  I'm a little torn on this one.  It's the first one I've had trouble expressing in haskell, but also, yeah, seems kind of obligatory.
21:33:41 <jle`> i mean, some data structures gain their power from mutability, and some gain their power from persistence/sharing
21:34:10 <jle`> doubly linked lists and finger trees are used for similar things because they have similar costs for their analogous operations
21:34:17 <dsal> So far, all of my approaches have just felt really unnatural.
21:34:31 <jle`> but finger trees gain you all of the benefits from persistent data types/sharing in pure languages
21:34:37 <jle`> that you don't get with doubly linked lists
21:35:23 <jle`> yeah, a finger tree implementation isn't a one-liner like the singly-linked list type is
21:40:20 <Axman6> dsal: you might want to look at zippers also - if you need to focus on one element of a list and move backward and forward, then a list zipper gives you that (data ListZipper a = LZ [a] a [a], where the first list is the (reversed) list of things before and the second is the list of things after). you could also apply this to fingertrees (a.k.a, Data.Sequence), and get the ability to append and prepend in O(1) time, and also focus on an eleme
21:40:21 <Axman6> nt in the middle of the structure
21:50:32 <Axman6> With pipes, how do I produce a Producer a m () from [a]? `each` makes a Producer' a m ()
21:54:08 * Axman6 has just defined each' = foldr (\a p -> P.yield a >> p) (return ()) with the appropriate type
22:12:48 <jle`> Axman6: there might be a Producer' -> Producer function that you're supossed to use
22:19:16 <Axman6> I couldn't see one, I thought the same thing
22:19:41 <Axman6> (there's likely to be n^2.. or maybe even n^4 of those functions really)
22:46:29 * hackagebot forest-fire 0.2 – Recursively delete CloudFormation stacks and their dependants – https://hackage.haskell.org/package/forest-fire
22:53:36 <osa1> is this type a functor: `newtype F x y a = F ((a -> x) -> y)` ?
22:55:44 <Axman6> hmm, looks like a Contravariant functor
22:56:08 <Axman6> @djinn (a -> b) ->  ((a -> x) -> y) ->  ((b -> x) -> y)
22:56:08 <lambdabot> f a b c = b (\ d -> c (a d))
22:57:01 <Axman6> hmm, I guess that a is in negative negative position...
22:57:28 <Cale> Right :)
22:57:45 <opqdonut> isn't that like the continuation functor?
22:57:59 <Axman6> that was my first thought, but then I couldn't figure out how to make it all work >_<
22:58:00 <Cale> Quite a bit like it, yeah
22:58:16 <Cale> Except that usually has x = y
22:58:19 <opqdonut> yeah
22:59:52 <opqdonut> @djinn ((a -> x) -> y) -> (a -> b) -> ((b -> x) -> y)
22:59:52 <lambdabot> f a b c = a (\ d -> c (b d))
22:59:55 <opqdonut> there ya go
23:00:20 <opqdonut> oh, you tried that already
23:00:53 <geekosaur> :exf "((a -> x) -> y) -> (a -> b) -> ((b -> x) -> y)"
23:00:54 <exferenceBot> \ f1 f2 f3 -> f1 (f3 . f2)
23:01:12 <opqdonut> that's a bit nicer
23:02:12 * hackagebot madlang 2.4.1.1 – Randomized templating language DSL – https://hackage.haskell.org/package/madlang
23:02:13 * hackagebot madlang 2.4.1.0 – Randomized templating language DSL – https://hackage.haskell.org/package/madlang
23:02:43 <opqdonut> if you need to wrap the constructor it becomes "fmap f (F thing) = F (\g -> thing (g . f))"
23:19:55 <saurabhnanda> does anyone know how to use the traverseObject lens from https://hackage.haskell.org/package/aeson-lens-0.5.0.0/docs/Data-Aeson-Lens.html -- I want to loop over all key/value pairs in an Aeson Object.
23:25:01 <jle`> saurabhnanda: you can use itraverseOf
23:25:32 <saurabhnanda> jle`: can you help me make sense of this type sig? (Indexed i a (f b) -> s -> f t) -> (i -> a -> f b) -> s -> f t
23:25:41 <jle`> what's the context?
23:26:08 <saurabhnanda> getting a JSON with unknown key-value pairs and I need to push the keys and values into another map.
23:26:16 <jle`> yes but where are you getting the type signature from
23:26:19 <jle`> what are Indexed
23:26:24 <jle`> what package is it from?
23:26:32 <jle`> is it the one from lens?
23:26:45 <saurabhnanda> the earlier one is the type sig of itraverseOf
23:26:47 <jle`> it might help to also give the name of the function
23:26:48 <saurabhnanda> this is the one from lens
23:26:49 <saurabhnanda> traverseObject :: (FromJSON v, ToJSON v) => IndexedTraversal' Text (Maybe Value) (Maybe v)
23:27:01 <jle`> ah, okay
23:27:04 <jle`> yeah, the name helps
23:27:09 <jle`> cause the name gives a hint to what the function does
23:27:23 <jle`> well-picked names usually act as good ways to figure out what functions do :)
23:27:34 <jle`> itraverseOf takes an indexed traversal and yields the traversal that it encodes
23:28:27 <jle`> in this case, itraverseOf :: IndexedTraversal' Text (Maybe Value) (Maybe v) -> (Text -> Maybe v -> f (Maybe v)) -> Maybe Value -> f (Maybe Value)
23:28:52 <jle`> or itraverseOf traverseObject :: (Text -> Maybe v -> f (Maybe v)) -> Maybe Value -> Maybe Value
23:29:02 <jle`> * itraverseOf traverseObject :: (Text -> Maybe v -> f (Maybe v)) -> Maybe Value -> f (Maybe Value)
23:29:34 <jle`> compare to
23:29:46 <jle`> traverse :: (a -> f b) -> [a] -> f [b]
23:30:11 <jle`> this lets you apply a (Text -> Maybe v -> f (Maybe v)) function over every key-value pair
23:30:13 <jle`> and get a modified object
23:30:18 <jle`> is that what you wanted to do?
23:30:24 <saurabhnanda> how do I use lenses to take an Aeson Object can convert it to a regular Map Text Text
23:30:36 <jle`> you don't need lenses to do that...you can just pattern match
23:30:55 <saurabhnanda> would like to use lenses... need to increase my lens-fu. 
23:31:25 <saurabhnanda> lenses are the swiss-army knife of data-structure access in haskell. need to master them.
23:31:43 * DigitalKiwi wonders when you guys are going to invent lasik
23:31:57 <jle`> also i'm not sure if you are ware, but nobody uses aeson-lens
23:32:00 <jle`> *aware
23:32:01 <ongy> we don't need lasik, we have edwark
23:32:10 <jle`> it hasn't been updated since 2013
23:32:14 <saurabhnanda> jle`: what's wrong with aeson-lens?
23:32:26 <jle`> nothing wrong with aeson-lens, it just doesn't really have most useful things you'd want from lens and aeson together
23:32:34 <jle`> like, the module doesn't really have much useful
23:32:42 <jle`> and most of the things you'd expect for lens+aeson interop is not there
23:32:43 <saurabhnanda> it has key and nth -- and I use them quite often for throwaway json ops.
23:32:58 <jle`> sure that's one thing, but like, 90% of the other stuff people want is missing
23:33:14 <jle`> why don't you use the one that people normally use instead?
23:33:19 <jle`> the package providing modern lens + aeson interop
23:33:20 <saurabhnanda> which one is that?
23:33:27 <jle`> lens-aeson
23:33:29 <jle`> http://hackage.haskell.org/package/lens-aeson
23:33:33 <jle`> it's actually written by edward kmett, too
23:33:58 <jle`> last update was a couple of months ago :)
23:34:24 <saurabhnanda> found it... 
23:34:32 <saurabhnanda> so this also has key and nth
23:34:37 <saurabhnanda> should be a drop-in replacement, right?
23:34:37 <jle`> mhm indeed, as those are useful
23:34:47 <jle`> not too familiar with aeson-lens, but maybe
23:35:20 <saurabhnanda> aeson-lens vs lens-aeson
23:35:22 <saurabhnanda> who woulda thought
23:35:38 <saurabhnanda> why didn't ekmett call his library the-real-aeson-lens-official :)
23:35:58 <saurabhnanda> and put a blue-tick next to it.
23:36:09 <jle`> ha :)
23:36:14 <jle`> yeah it's a bit unfortunate
23:36:28 <saurabhnanda> thanks for the tip jle`
23:36:35 <saurabhnanda> lens-aeson seems to have more lenses
23:36:45 <saurabhnanda> so, back to the original problem. Object -> Map Text Text
23:37:10 <jle`> do you mean Value -> Map Text Text, maybe?
23:37:28 <DigitalKiwi> yet aother lens aeson library --  yalal
23:37:30 <jle`> because Object is just a type synonym for HashMap Text Text
23:37:33 <saurabhnanda> but it would need ti raise an error on anything that is not an Object.
23:37:49 <jle`> Object is just a type synonym for Hashmap Text Text
23:37:58 <saurabhnanda> jle`: yeah... never felt comfortable pattern matching on Value -- feel like leaking internals.
23:38:08 <jle`> so when you say Object -> Map Txt Text, you really mean HashMap Text Text -> Map Text Text
23:38:36 <saurabhnanda> Object is Map Text Value, right?
23:38:48 <jle`> ah yeah you're right, sorry, Object is HashMap Text Value
23:38:59 <jle`> so you really mean HashMap Text Value -> Map Text Text?
23:39:11 <jle`> how do you want that function to behave?
23:39:17 <jle`> how should it convert non-text values?
23:39:33 <saurabhnanda> raise an error.
23:39:42 <saurabhnanda> this means that the conf file is screwed.
23:39:47 <jle`> if *any* of them are non-text values, the whole thing should be an error?
23:39:56 <jle`> so you mean something like HashMap Text Value -> Maybe (Map Text Text) ?
23:39:59 <saurabhnanda> yup. this is during application startup.
23:40:11 <saurabhnanda> yes, even that would do.
23:40:19 <jle`> just giving it a type signature to clarify your intention
23:40:33 <saurabhnanda> Although. HashMap Text Value -> Either String (Map Text Text) woudl be better, so that I can point out the failing key/value in the Left value.
23:41:03 <saurabhnanda> btw, is there a fold for indexed traversals?
23:41:19 <jle`> yes all traversals are folds
23:41:23 <jle`> so you can use all of the fold methods with them
23:42:23 * hackagebot madlang 2.4.1.3 – Randomized templating language DSL – https://hackage.haskell.org/package/madlang
23:42:24 * hackagebot madlang 2.4.1.2 – Randomized templating language DSL – https://hackage.haskell.org/package/madlang
23:42:24 <jle`> HashMap Text Value -> Map Text Text
23:42:51 <jle`> hm
23:43:03 <jle`> you can have a Value -> Maybe Text with 'preview _Text'
23:43:25 <jle`> sorry, preview _String
23:43:38 <jle`> _String is a prism from a Value to a Text, if the value is a text field
23:43:46 <jle`> so preview _String :: Value -> Maybe Text
23:44:08 <jle`> so traverse (preview _String) :: Map Text Value -> Maybe (Map Text Text)
23:45:13 <jle`> but if you have a 'Value' already, the easiest way to do it would be to just use preview _JSON :: Value -> Maybe (Map Text Text)
23:45:43 <saurabhnanda> where is preview defined?
23:46:02 <jle`> Control.Lens.Traversal, maybe?
23:46:12 <jle`> it's basically a toListOf with a listToMaybe
23:46:31 <jle`> toListOf gets all of the values that your traversal/prism/fold/lens/etc. "matches"
23:46:39 <jle`> preview does the same but just gives you the first match
23:46:58 <saurabhnanda> what about using https://hackage.haskell.org/package/lens-aeson-1.0.2/docs/Data-Aeson-Lens.html#v:members
23:47:06 <saurabhnanda> and doing a Map.fromList on that
23:48:28 <jle`> yes but that too only works on Value's
23:48:37 <jle`> (or strings or bytestrings or text that contain aeson data)
23:49:17 <jle`> members = _Object . itraversed
23:49:28 <saurabhnanda> okay, thanks for you help jle`. I'll try to figure this out from here... I hope lens doesn't throw random error messages at me.
23:49:49 <jle`> _Object goes from Value -> HashMap Text Value
23:49:59 <jle`> itraversed goes from HashMap Text Value -> Value
23:50:37 <jle`> so _Object traverses over all of the Object's inside a Value, and itraversed is an indexed traversal over all of the Value's inside that Object/HashMap's values
23:50:58 <jle`> but if your goal is to make a Map from it, it's kind of a roundabout/perverse way of doing it
23:51:37 <jle`> the simplest way is just to use the _JSON :: Prism' Value (Map Text Text) prism
23:52:42 <jle`> using members and then fromListing that is kind of the opposite of 'using lens'
23:58:48 <saurabhnanda> how does one use Aeson.eitherDecodeWith. Specifically, how does one construct a value of the type `(Value -> IResult a)`
