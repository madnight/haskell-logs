00:30:09 <dminuoso> Is every morphism in a factory also a homomorphism?
00:30:14 <dminuoso> *category o.o
00:30:53 <merijn> dminuoso: Eh, no
00:31:33 <dminuoso> merijn: Without being able to look into objects, how can this be shown?
00:31:39 <merijn> dminuoso: homomorphisms in CT generally mean we're discussing functors or categories of categories
00:31:45 <ventonegro> I'm reading the brand new PDF from Bartosz course. Soon I'll be able to keep up with you guys :D
00:31:55 <dminuoso> merijn: Right. I was wondering whether every morphism in Cat is necessary a functor.
00:32:13 <merijn> dminuoso: eh, I forget the details of Cat, so not sure
00:33:07 <ventonegro> I already know what a profunctor is, so I'm feeling very smug
00:43:50 <ertes-w> hell
00:46:38 <ertes-w> dminuoso: depends on what you mean by Cat…  if you mean a category of categories it's usually *defined* to be functors
00:46:56 <ertes-w> dminuoso: but you can define other categories of categories
00:49:37 <ertes-w> also i think "morphism" and "homomorphism" are really the same thing
00:49:55 <Cale> They are.
00:51:03 <Cale> Also "arrow", though "homomorphism" has a bit more of the connotation of "structure preserving function" than the others
01:19:31 <dminuoso> Cale: Well, "structure preserving" seems to only make sense in context of some internal operation ∘.
01:20:09 <dminuoso> I mean what other morphisms between categories could one come up with? Perhaps a relation regarding cardinality?
01:20:38 <Cale> dminuoso: I mean it more generally and less technically than that
01:20:58 <Cale> But yeah, functors are homomorphisms of categories is a fine thing to say
01:24:43 <ertes-w> dminuoso: functors with less laws, functors with more laws, …
01:25:18 <merijn> man...I can't wait for the new haddock to hit Hackage...
01:25:28 <ertes-w> dminuoso: for example you can map between semigroupoids using what i called "semifunctors" for lack of a better term
01:25:44 <ertes-w> dminuoso: semigroupoids and "semifunctors" form a category
01:26:35 <ertes-w> and of course every category is a semigroupoid
01:27:16 <ertes-w> (semifunctors are a generalisation of semigroup homomorphisms)
01:33:19 <saurabhn_> is there any flag that makes GHC/stack/cabal show a progress bar during a build?
01:33:54 <merijn> GHC and cabal-install I'm certain there isn't. As for stack, doubt it
01:34:35 <ertes-w> saurabhn_: on what level?
01:34:44 <saurabhn_> well then, it would be a good psychological hack... just staring at "webservice-0.1.0.0: build (lib + exe)" for the past ten minutes is not reassuring!
01:34:50 <ertes-w> saurabhn_: modules?  packages?
01:34:56 <merijn> saurabhn_: btw, wrt your build time issue, have you considered using Shake instead of cabal/ghc as build tool?
01:35:21 <saurabhn_> merijn: will look into that after we get this damn thing out... right now, we're racing against time to meet some delivery commitments.
01:35:23 <ertes-w> saurabhn_: GHC does show you how many modules are left to go
01:35:28 <merijn> saurabhn_: I know some of the Haskell using banks use that to manage their builds, since cabal-install and ghc aren't great at dependency management for complex/large builds
01:36:34 <saurabhn_> the memory consumption during the build is also not helping out. Docker builds are throwing weird errors. We're hitting the 4g limit on CircleCI.
01:37:13 <ertes-w> saurabhn_: i seem to remember that you had a module with lots of record types…  was that you?
01:37:37 <saurabhn_> ertes-w: yup... many records split across many modules.
01:38:16 <ertes-w> saurabhn_: so is it a particular module that is taking long?
01:38:51 <saurabhn_> merijn: does shake use any custom algo for "Recompilation Avoidance" - https://ghc.haskell.org/trac/ghc/wiki/Commentary/Compiler/RecompilationAvoidance
01:39:24 <ertes-w> i don't think shake will help here…  GHC already has module dependency management and will only recompile modules it has to
01:39:32 <saurabhn_> ertes-w: don't have any visibility... that's the best I could get after spending almost the entire day on this y'day -- https://gist.github.com/saurabhnanda/c8f8654a7f29c1adb753b357b897b5f3#file-building-library-01-txt-L8-L28
01:39:50 <merijn> saurabhn_: Shake isn't really a pre-built solution, it's more of a DIY build-tool (like Make), but far better at managing dynamic dependencies, etc and better at using parallelism
01:40:01 <ertes-w> saurabhn_: well, as i said GHC displays progress by default…  you should get your tool to show you its output
01:40:05 <saurabhn_> GHC/Cabal/Stack don't seem to output human parseable stats data very well.
01:40:20 <ertes-w> but it only displays progress on the module level
01:40:22 <merijn> saurabhn_: But Shake should be better at handling really big dependency graphs
01:41:16 <saurabhn_> merijn: can "shake" help with https://mail.haskell.org/pipermail/haskell-cafe/2017-October/128033.html
01:41:53 <saurabhn_> ertes-w: can you help me with the GHC flag... I'll figure out how to pass it via stack. Also, does it show elapsed time for each module?
01:41:58 <merijn> saurabhn_: No, changed interface means having to recompile
01:42:14 <ertes-w> saurabhn_: you need to figure out how to stop stack from *hiding* the output
01:42:25 <ertes-w> saurabhn_: unfortunately i have no experience with stack, sorry
01:42:26 <saurabhn_> merijn: but 1,200 modules in the dependency graph? will it be able to handle that better than stack/ghc/cabal?
01:42:54 <ertes-w> saurabhn_: shake is a better make
01:43:10 <saurabhn_> better make or better "gkc --make"
01:43:15 <ertes-w> it can deal with dynamic dependencies and dependencies that aren't files/directories
01:43:18 <merijn> saurabhn_: Both
01:43:18 <ertes-w> better make
01:43:30 <ertes-w> it's unrelated to haskell (except that it's written and programmed in haskell)
01:43:37 <merijn> saurabhn_: It is a better make and it is better than GHC --make
01:44:14 <merijn> saurabhn_: It was developed by Standard Chartered to handle their 1.5 million LOC codebase
01:44:36 <saurabhn_> if anyone knows a GHC/stack flag that shows elapsed time while compiling each module, that'd help. Will help us get more visibility on what exactly is causing the slowdown. Via -sstderr I was able to eliminate the linker step and executable step -- it's the core library build that is taking up 85% of the build time.
01:44:42 <merijn> saurabhn_: You'll just have to have a look whether it'd fit your needs: http://shakebuild.com/why
01:45:09 <ertes-w> saurabhn_: try building it with cabal-install
01:45:22 <ertes-w> cabal-install displays GHC output by default
01:45:39 <ertes-w> (also i'm kinda surprised that stack doesn't)
01:45:40 <osa1> it's extremely annoying that :load in ghci doesn't take LANGUAGE pragmas into account
01:45:56 <ertes-w> osa1: huh?  it does…
01:46:14 <ertes-w> osa1: you mean for the REPL itself?
01:46:16 <osa1> ertes-w: which version? I'm using 8.0.2 and it definitely doesn't
01:46:23 <osa1> yeah
01:46:32 <ertes-w> ah
01:47:02 <saurabhn_> osa1: care to elaborate. seems to work for me.
01:47:07 <osa1> it's literally driving me crazy because I have to enable dozens of pragmas whenever I change modules
01:47:22 <merijn> saurabhn_: He means that loading a file with RankNTypes won't let you use RankNTypes on the prompt directly
01:47:29 <saurabhn_> ah okay
01:47:32 <merijn> osa1: ALternative solution, enable most by default?
01:47:37 <osa1> exactly what merijn said
01:47:48 <merijn> osa1: https://github.com/merijn/dotfiles/blob/master/dotfiles/ghci
01:47:50 <osa1> I don't want alternatives I just want this to work.............
01:47:51 <saurabhn_> osa1: if you're not being pedantic, just enable all the language extensions project-wide in your cabal file and be done with it.
01:48:06 <merijn> osa1: You can enable extensions in .ghci for the prompt
01:48:11 <ertes-w> project-wide .ghci if anything
01:48:18 <ertes-w> but honestly i'd just enable them in ~/.ghci
01:48:29 <merijn> osa1: I don't think always enabling everything in the file is desirable
01:48:30 <osa1> hmm project wide .ghci sounds like a good idea
01:48:33 <ertes-w> be sure to use :seti instead of :set
01:48:34 <MarcelineVQ> I like to have -XTypeapplications set in my ghci for type-play
01:48:44 <merijn> osa1: Some extensions make it a PITA to type stuff on the prompt
01:48:46 <MarcelineVQ> * .ghci
01:49:05 <geekosaur> yes, LANGUAGE pragmas in the loaded code won't affect the prompt
01:49:07 <geekosaur> :seti might be your friend
01:49:49 <MarcelineVQ> so I can do things like  :t join @((->)_)      join @((->)_) :: (w -> w -> a) -> w -> a
01:49:57 <merijn> osa1, ertes-w: I would personally never use a project-wide ghci (in fact, I have ghci set to block those out of ~), don't want simply typing "ghci" in a directory to potentially PWN my machine
01:50:11 <ertes-w> merijn: agreed
01:50:20 <osa1> so these :seti commands persist between :loads, correct?
01:50:23 <mniip> %% :showi language
01:50:23 <yahb> mniip: http://qp.mniip.com/y/98
01:51:00 <osa1> because number of collaborators in this project is >1 I'll just enable these in my global .ghci
01:51:38 <ertes-w> osa1: what merijn said
01:52:40 <merijn> ertes-w: Help me prod this ticket: https://ghc.haskell.org/trac/ghc/ticket/14250
01:56:54 <ertes-w> looks like nobody cares so far (who gives a shit about security?)…  the way i see it there are two options: either just fix it, or wait for the worst case scenario
01:57:32 <merijn> ertes-w: I already have plenty of yaks to shave and I don't have a clue where I'd have to dig in ghci
01:57:42 <ertes-w> me neither
01:58:07 <geekosaur> I think the problem there is too many projects already depend on local .ghci files
01:58:25 <merijn> geekosaur: I'm not even advocating to stop it entirely
01:58:40 <cocreature> merijn: well if you compile your code, you can also get your machine owned due to TH so I’m not sure removing support for local ghci files solves much
01:58:57 <merijn> geekosaur: One suggested option is parsing ~/.ghci *first* and then adding a command to .ghci to toggle reading the rest
01:59:07 <merijn> cocreature: And you never read code without compiling it?
01:59:18 <geekosaur> ys, I saw. but if it's a 'security issue' then the correct default is disabled by default
01:59:21 <merijn> cocreature: This issue is worse though, because I can get owned in non-Haskell directories too
01:59:47 <merijn> cocreature: I clone the repo with a paper, config files, whatever, fire up ghci (I use it as quick calculator often) and be owned
01:59:59 <cocreature> merijn: sure I do but I don’t read code in ghci. if I open ghci I want to compile stuff and if I open it in other peoples code I want to compile their code
02:00:05 <merijn> cocreature: Basically, I can never run ghci in a directory which I'm not confident has no hostile files
02:00:11 <geekosaur> also if you can be owned by something runninbg as you, you have a bigger problem somewhere
02:00:26 <merijn> cocreature: See my previous remark. I use ghci as glorified calculator all the time
02:00:30 <ertes-w> it would be ideal if .ghci worked like emacs' dir-locals or file-locals…  there is a whitelist of "safe" options
02:00:36 <merijn> geekosaur: How so?
02:00:52 <merijn> geekosaur: On my laptop literally anything I care about is owned by my user
02:01:19 <saurabhn_> a lack of -O* flag means -O1 or -O0 ?
02:01:36 <merijn> geekosaur: I'm not talking "company being owned", just "my private machine is totally hosed" kinds of owned
02:01:41 <ertes-w> saurabhn_: with plain GHC it means -O0, with a cabal package it means -O1
02:01:51 <saurabhn_> ah, no wonder...
02:02:11 <merijn> geekosaur: "don't parse .ghci files unless explicitly told to" seem like an eminently sensible and trivial to add layer of defense
02:02:47 <ertes-w> i agree
02:02:58 <merijn> geekosaur: I mean, can you give any reason how "opting out of .ghci files" is going to hurt anyone? Sure, it's not bulletproof, but that's a stupid argument
02:03:18 <merijn> geekosaur: Seatbelts don't guarantee you won't die in a car crash, but no one argues against seatbelts
02:03:29 <geekosaur> osa1 just gave it a few minutes ago, actually
02:03:52 <merijn> geekosaur: How so? I said "opt-out" anyone who wants to drive "without seatbelt" still can
02:04:06 <merijn> geekosaur: I didn't say "enforce no one uses .ghci"
02:04:13 <geekosaur> you just complicated any project that doesn;t rely on cabal/stack repl because now they have to change what they;ve been doing
02:04:18 <merijn> I just want to guarantee *I* don't
02:04:27 <merijn> geekosaur: No they don't
02:04:34 <geekosaur> never mind, obviously just putting a little note somewhere upgrades everyone's brains and procedures
02:04:37 <merijn> geekosaur: That would only be true if I said making .ghci *opt in*
02:04:43 <ertes-w> geekosaur: what's wrong with a whitelist?
02:04:51 <merijn> geekosaur: I suggested making .ghci *opt out*
02:05:00 <merijn> geekosaur: So it defaults to the current behaviour
02:05:10 <ertes-w> i wouldn't even default to the current behaviour
02:05:33 <geekosaur> the bug says 'GHCi by default opens...' which means it wants it to not do so *by default*
02:05:42 <ertes-w> the proper way to deal with this is either a project-based whitelist or a command-based one
02:05:49 <merijn> geekosaur: Did you even read the proposed solution?
02:06:00 <merijn> "2) Adding ghci commands to enable/disable loading local .ghci files in the ghci prompt and change the load order of .ghci files so that ~/.ghci loads first and can enable/disable loading local files."
02:06:21 <merijn> geekosaur: Please explain how that solution would break anyone's workflow
02:09:04 <ertes-w> you should consider the option to break people's workflows
02:09:20 <ertes-w> if they really need this particular functionality, they have adopted some really bad habits
02:09:31 <ertes-w> programmers should care more about the security of their dev machine!
02:09:54 <ertes-w> especially in open source projects, where untrusted people commit executable code
02:10:43 <geekosaur> merijn, what I want is for the title of that ticket to not be phgrased in a way that effectively says 'make this not happen'
02:11:08 <geekosaur> because that's what people will see
02:11:56 <geekosaur> and it specifically says 'by default' meaning that the default is considered wrong/a bug.
02:14:15 <merijn> geekosaur: I would say the default is *definitely* a bug & wrong. The fact that people rely on it is irrelevant
02:15:00 <ertes-w> geekosaur: is it not?  imagine 'ls' would load an arbitrary executable ./.lsopts and use its output for default flags
02:15:04 <merijn> geekosaur: I'm willing to accommodate people wanting dumb and wrong things, but that doesn't make them less wrong
02:15:40 <ertes-w> geekosaur: that's basically what GHCi does right now…  run it in the wrong directory and you're screwed
02:15:47 <geekosaur> I have already tried to explain my point. Thanks for hearing something else.
02:24:00 <saurabhn_> I'm suddenly getting the following error while running my app's binary. What have I messed up? "unexpected RTS argument: N"
02:24:38 <saurabhn_> command-line doesn't have this RTS flag anywhere: APP_ENV=lambda ./webservice-exe
02:24:48 <merijn> saurabhn_: Are you compiling with -rtsopts?
02:25:11 <saurabhn_> this? ghc-options: -Wall -threaded -rtsopts -with-rtsopts=N -O0 +RTS -A128m -n2m -RTS
02:25:26 <merijn> saurabhn_: Right, that N looks wrong
02:25:37 <merijn> Probably should be '-N'?
02:25:59 <saurabhn_> okay
02:26:02 <saurabhn_> thanks
02:27:59 * saurabhn_ needs to stop randomly fiddling with ghc opts
02:28:51 <merijn> Unrelatedly: <3 pattern guards
02:46:18 <ph88> hey guys, how can i make this function so that it accept (x -> y -> Maybe z) as 5th parameter ? i don't want to plot some datapoints https://hackage.haskell.org/package/gnuplot-0.5.4.2/docs/Graphics-Gnuplot-Simple.html#v:plotFunc3d
02:46:35 <merijn> ok, opinion question time: Suppose you could fold the output of your test-suite, what criteria would you like to base folding on? Obvious one would be to just fold all successes, but what other criteria would people like?
02:49:56 <earthy> what do you mean by 'folding'?
02:50:12 <merijn> earthy: Collapsing multiple lines until you expand them
02:50:16 <cheff> i serch a film
02:50:32 <fakenullie> ph88: I think you have to user plotmesh then
02:50:39 <merijn> earthy: For example, see this Travis output https://travis-ci.org/merijn/broadcast-chan#L814
02:50:51 <cheff> @film
02:50:51 <lambdabot> Unknown command, try @list
02:50:56 <merijn> (ignore the cabal noise, I haven't gotten around to filtering that out)
02:50:57 <cheff> @list
02:50:57 <lambdabot> What module?  Try @listmodules for some ideas.
02:51:18 <ph88> oh thx fakenullie 
02:51:20 <merijn> earthy: line 835 for example, note that you can click it to expand the actual output of the test tree
02:51:26 <earthy> merijn: ah. yeah, I'd love to be able to see all passes as well (hey, that new test wasn't supposed to pass!)
02:51:42 <merijn> earthy: I have no way of tracking that, tbh
02:51:45 <earthy> hence fold away failures would be useful
02:51:53 <earthy> merijn: no, obviously, that has to be manually
02:52:03 <ph88> how do i get the cartesian product of 2 lists the easy way ?
02:52:08 <merijn> earthy: Hadn't thought about folding failures, but I suppose that's easy
02:52:17 <merijn> ph88: List applicative/monad
02:52:26 <ph88> why monad ?
02:52:28 <merijn> > (,) <$> [1..5] <*> [6..10]
02:52:30 <fakenullie> ph88: list comprehension or what merijn said
02:52:31 <lambdabot>  [(1,6),(1,7),(1,8),(1,9),(1,10),(2,6),(2,7),(2,8),(2,9),(2,10),(3,6),(3,7),(...
02:52:53 <ph88> oh thx guys
02:53:08 <merijn> earthy: I was considering things like "fold the lowest N levels of the tree" or "fold the top N levels of the tree"
02:53:42 <merijn> earthy: Although that leaves a sticky issue of "how to handle "fold lowest N levels" for uneven trees"
02:53:44 <earthy> well, if you're folding lowest N levels then you need to summarize
02:54:03 <earthy> fold anything beyond depth N?
02:54:23 <merijn> earthy: Yeah, that's probably a better way to formulate it
02:54:33 <barrucadu> It's a different approach than folding, but the mocha test library for javascript has fairly nice output I feel: it displays your test tree as it runs, then displays the list of failing tests again at the end.
02:55:09 <earthy> I like the slicing and dicing Visual Studio provides, but that's in an entirely different UI paradigm
02:55:34 <merijn> Yeah, I'm talking things that will work in a static log like Travis
02:55:44 <merijn> (since I'm doing this to make Travis output nicer :p)
02:56:18 <earthy> yeah. summarize the underlying total/pass/fail counts if you're folding levels
03:04:14 <ertes-w> merijn: i think any sensible folding has to be supported by the test framework
03:04:27 <ertes-w> merijn: for example i want a flat list
03:04:32 <ertes-w> of failures
03:05:41 <merijn> ertes-w: I'm just writing a nicer frontend for tasty, not doing stuff from scratch, so whatever I do ends up being limited to accommodate what's reasonable with tasty
03:05:55 <merijn> Even people want something fancier they'll have to do it themselves
03:09:09 <dminuoso> ertes-w: Regarding your last statement about semifunctors, that makes sense. Thank you for your help ertes-w and Cale.
03:12:45 <ph88> why is this list comprehension and list monad not the same?   https://bpaste.net/show/38a32effda50
03:17:09 <Maxdamantus> ph88: because you've got an extra `return`
03:17:09 <ph88> Maxdamantus, how can i rewrite my list comprehension to return the same thing as the do ?
03:17:09 <Maxdamantus> ph88: you would probably use two list comprehensions.
03:17:09 <ph88> oh ok
03:17:09 <Maxdamantus> [[... | y <- xs] | let xs = .., x <- xs]
03:17:15 --- topic: 'https://www.haskell.org | https://wiki.haskell.org/IRC_channel | Paste code/errors: http://lpaste.net/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D | https://www.reddit.com/r/haskell | Admin: #haskell-ops | Offtopic: #haskell-offtopic | https://downloads.haskell.org | https://summer.haskell.org Summer of Haskell 2017'
03:17:15 --- topic: set by mauke!5lzdiZJQGk@p3m/member/mauke on [Mon Jul 31 05:45:11 2017]
03:17:31 <ph88> i don't really get the difference ..
03:17:57 <ph88> this was an example formula ... i actually have xs and ys and a formula x -> y -> z
03:18:21 <ph88> mesh_points = [(r, i, y)  | r <- rents, i <- interests, let y = f_years r i, y <= 30]   it doesn't plot anything though :(
03:18:24 <Maxdamantus> ph88: well, `return x` in the list monad just means `[x]`
03:19:04 <Maxdamantus> ph88: so when you have `do x <- xs; return (do ..)` it might as well just be `do x <- xs; [..]`
03:21:58 <ph88> ye this is the same do x <- xs; [ do y <- xs; [(x,y,cos(x*x+y*y))] ]
03:22:40 <ph88> oh i know why i need another level in my list comprehension ... i'm just making a 2D line this way ... so i need another level to go 3D ..
03:30:34 <fakenullie> > [(x,y,cos(x*x+y*y)) | let xs = [-2,-1..2::Double], x <- xs, y <- xs]
03:30:40 <lambdabot>  [(-2.0,-2.0,-0.14550003380861354),(-2.0,-1.0,0.28366218546322625),(-2.0,0.0,...
03:31:01 <fakenullie> this should be 3d as far as I know
03:31:20 <fakenullie> > [(x,y) | let xs = [-2,-1..2::Int], x <- xs, y <- xs]
03:31:22 <lambdabot>  [(-2,-2),(-2,-1),(-2,0),(-2,1),(-2,2),(-1,-2),(-1,-1),(-1,0),(-1,1),(-1,2),(...
03:42:47 <ahisdnss> Hello my friend
03:44:39 <ahisdnss> Hello poligen
03:46:31 <sepakorayl> Hello everyone. I would like to write some node transformation functions that possible spit out errors. Since the errors are very specific, I thought AccValidation was a good approachh but the Applicative interface seems a bit too restrictive. Would Writer with an error record monoid be a good substitute?
03:49:34 <Eduard_Munteanu> sepakorayl, aren't the errors fatal for the operation?
03:50:09 <Eduard_Munteanu> Either(T) may be more appropriate in that case.
03:50:30 <sepakorayl> yes I would convert to Either as a final stage
03:51:01 <Eduard_Munteanu> sepakorayl, why Writer then? Do you want to continue even if errors occur?
03:53:14 <sepakorayl> I want a convenient way to log the errors /inside/ the functions. Then convert to either as a final stage.
03:54:10 <Eduard_Munteanu> Both Either and Writer are just as convenient there.
03:54:39 <Eduard_Munteanu> e.g. throw (MyError ...) vs tell [MyError ...]
03:54:54 <phadej> Eduard_Munteanu: http://hackage.haskell.org/package/these-0.7.4/docs/Control-Monad-Trans-Chronicle.html is one option
03:55:04 <Eduard_Munteanu> Either is a monad too, btw.
03:56:10 <sepakorayl> But either short circuits while I want logging.
03:56:39 <Eduard_Munteanu> Oh, ok, if you want to continue in spite of errors, yeah, use Writer..
03:57:51 <phadej> consider Chronicle
03:57:57 <phadej> it's: Hybrid error/writer monad class that allows both accumulating outputs and aborting computation with a final output.
03:59:55 <phadej> it makes "no value but no errors" case impossible, which WriterT [Error] Maybe would have
04:01:16 <sepakorayl> thanks, I will check it out
04:09:10 <ph88> how can i make this function so that it doesn't include some  c  that match a predicate ?   https://bpaste.net/show/239bdd993a7a
04:12:30 <ph88> this  flip  is confusing me
04:12:35 <ph88> trying to get rid of it
04:14:33 <Eduard_Munteanu> ph88, you can apply filter inside the parens, but not sure if you want to prune out empty lists within
04:15:05 <ph88> i'm not sure either ... i give this to a mesh function of gnuplot
04:16:06 <sepakorayl> is simple Cronicle different from These?
04:16:45 <sepakorayl> refering to ChronicleT Identity
04:18:47 <phaazon> hey
04:18:53 <phaazon> so EitherT is opt-out now?
04:18:57 <phaazon> we have to use ExceptT instead?
04:20:03 <phaazon> edwardk: you left the “the EitherT monad transformer” in your github repository :)
04:20:09 <phaazon> I wonder how I should migrate 
04:20:20 <barrucadu> sepakorayl: Looks like These and ChronicleT Identity are the same, other than an Identity wrapper: https://hackage.haskell.org/package/these-0.7.4/docs/Control-Monad-Chronicle-Class.html#t:ChronicleT
04:21:07 <Eduard_Munteanu> sepakorayl, Chronicle takes care of combining errors, while These doesn't
04:21:50 <barrucadu> I think the Bind instance of These does that: https://hackage.haskell.org/package/these-0.7.4/docs/src/Data-These.html#line-275
04:22:41 <phadej> they are isomorphic, a bit like ExceptT e Identity and Either
04:22:46 <Eduard_Munteanu> Hm.
04:29:31 <merijn> Is there a way I can refer to the type of my typeclass instance in the function implementation?
04:29:31 <tabaqui> how could I work with such constructions?
04:29:46 <tabaqui> data Wrapper = forall a. Wrapper { getFunction :: a -> a }
04:30:02 <merijn> i.e. "instance Foo a where myFun = Wrap (x :: a)"
04:30:05 <tabaqui> when I'm trying to extract function from data and call it
04:30:14 <merijn> Does ScopedTypeVariables work for that?
04:30:18 <phadej> merijn: you can, ScopedTypeVariables work
04:30:20 <tabaqui> I get     • Cannot use record selector ‘function’ as a function due to escaped type variables
04:30:43 <merijn> phadej: Cheers
04:31:25 <tabaqui> merijn: I want to hide type a from type constructor
04:31:53 <tabaqui> f.e wrappedId = Wrapper id
04:32:04 <merijn> tabaqui: You can only access that type variable when pattern matching explicitly
04:32:13 <merijn> tabaqui: So you can use the record accessor
04:32:17 <merijn> s/can/can't
04:32:58 <tabaqui> like "let (Wrapper foo) = wrapperId in foo 5"?
04:33:26 <tabaqui>  My brain just exploded
04:33:27 <ertes-w> tabaqui: Wrapper looks like a useless type to me
04:33:28 <tabaqui>       I can't handle pattern bindings for existential or GADT data constructors.
04:33:30 <tabaqui>       Instead, use a case-expression, or do-notation, to unpack the constructor.
04:33:34 <merijn> tabaqui: "case wrapperdId of Wrapper f -> f 5"
04:33:49 <ertes-w> tabaqui: when you pattern-match on a Wrapper, you get a function of type (a -> a) for *some* type 'a' you know nothing about
04:34:00 <ertes-w> so there is nothing you can apply it to
04:35:07 <tabaqui> case wrapperdId of Wrapper f -> f 5
04:35:12 <tabaqui>  Couldn't match expected type ‘t’ with actual type ‘a’
04:35:21 <tabaqui> it is useless here
04:35:35 <merijn> tabaqui: Yeah, because you don't know which 'a' is accepted by 'f'
04:35:42 <ertes-w> tabaqui: as i said
04:35:44 <merijn> tabaqui: So you can't prove you can apply it to 5
04:35:44 <tabaqui> actually, I'm trying to hide Bloodhound.Context inside config data
04:35:49 <merijn> tabaqui: What are you trying to do?
04:35:51 <ertes-w> Wrapper is useless
04:36:08 <tabaqui> https://hackage.haskell.org/package/bloodhound-0.14.0.0/docs/Database-V5-Bloodhound-Client.html#v:withBH
04:36:22 <tabaqui> "withBH settings address" returns some context
04:36:38 <tabaqui> that can be applied to any IO action
04:37:03 <merijn> tabaqui: Right, so you want it to work for any BH IO a that's passed in?
04:37:34 <tabaqui> yeah, and I have some "data ElasticConfig = ElasticConfig context index1 index2 mapping1 mapping2 ..."
04:37:40 <ertes-w> tabaqui: your Wrapper type is existential, but what you seem to want is something universal
04:37:41 <tabaqui> in record notation, of course
04:37:44 <merijn> That should just be a RankN type
04:37:58 <ertes-w> tabaqui: nwetype Wrapper = Wrapper { runWrapper :: forall a. BH IO a -> IO a }
04:38:06 <merijn> tabaqui: You wanna ditch the existential stuff and use RankN instead
04:38:09 <merijn> ^^ like that
04:38:27 <merijn> tabaqui: Your version says "it works for SOME 'a' you don't know about"
04:38:38 <tabaqui> ertes-w: it works
04:38:39 <merijn> tabaqui: ertes-w's version says "it must work for ALL 'a'"
04:39:08 <ertes-w> and since it isn't existential you can just use 'runWrapper' directly without pattern-matching
04:39:23 <merijn> tabaqui: You basically have a problem that's a variant of: https://gist.github.com/merijn/77e3fa9757658e59b01d
04:39:27 <tabaqui> I've read quantifications about 20 times, but still don't get it
04:39:48 <ertes-w> tabaqui: try my tutorial: https://ocharles.org.uk/blog/guest-posts/2014-12-18-rank-n-types.html
04:39:49 <merijn> tabaqui: ExistentialQuantification is rather tricky and usually a code smell
04:40:30 <ertes-w> tabaqui: it only covers universal, but nine times out of ten existentials should be avoided anyway
04:40:32 <tabaqui> someone said here, that any code written with EQ can be rewritten without it
04:40:48 <merijn> tabaqui: RankN is usually more straightforward, in the gist I linked you it's fairly easy to see
04:40:59 <tabaqui> and usually it's much pretty without it
04:41:01 <ertes-w> tabaqui: you can emulate existentials using universals
04:41:10 <ph88> why does ghc infer i need an instance of Num tuple ?  https://bpaste.net/show/f9fd99b2c08a  
04:41:12 <merijn> tabaqui: Normally the *caller* picks the type of every type variable in a signature
04:41:30 <phadej> e.g. forall a. Show a => Showable a  is the same as  String, thanks to laziness
04:41:51 <ertes-w> data Str = forall a. Str a (a -> String)  -- existential version
04:41:54 <merijn> tabaqui: Which is why the first example in my gist fails. What if the "caller" decides 'a = Complex Int', then it wouldn't work on that data
04:42:32 <ertes-w> newtype Str = Str { runStr :: forall r. (forall a. a -> (a -> String) -> r) -> r }  -- equivalent universal version
04:42:46 <ertes-w> String  -- the best version
04:42:51 <merijn> tabaqui: The second one with 'forall' (and thus RankN) says that the *function* (rather than the caller) decides what 'a' is. In other words, the 'forall' say "you better give me something that works for ALL 'a')
04:44:17 <merijn> ph88: That "(<= 30)" is matching the 'c -> Bool' in outerProduct7
04:44:42 <merijn> ph88: But the 'c' is (Int, Double, Double) (inferred from the second function)
04:44:54 <tabaqui> okaay
04:45:15 <merijn> ph88: So, if (<=30) has to take "(Int, Double, Double)" that means "30 :: (Int, Double, Double)"
04:45:23 <tabaqui> well, I know about representations of list and tuples as functions on theirs interfaces
04:45:35 <merijn> ph88: Since "30 :: Num n => n" that implies "Num (Int, Double, Double)" which obviously doesn't exist
04:46:01 <merijn> tabaqui: tbh, I think my gist has a slightly simpler example than ertes-w's link (although his is more practically useful)
04:46:08 <tabaqui> Couldn't match type ‘BH IO a0 -> IO a0’
04:46:17 <tabaqui>                          with ‘forall a. BH IO a -> IO a’
04:46:18 <ph88> merijn, oh yes you are right c is not the type it would be
04:46:37 <tabaqui> merijn: ok, I'll read it
04:46:45 <tabaqui> merijn, ertes-w: thanks
04:46:58 <merijn> tabaqui: It doesn't really have any text besides my explanation, but OTOH it is REALLY simple :)
04:47:22 <merijn> tabaqui: lemme know if anything confuses you
04:47:57 <ertes-w> mine contains, after an explanation, a number of example use cases, one of them being church encoding
04:48:52 <ertes-w> it starts rather slow, but speeds up considerably after the intro =)
04:53:05 <crunchbang> How do I parse a nested set of records? I have defined some types and created a parse tree corresponding to an input program. The part where I'm stuck is when it comes to going through this tree. Code at http://lpaste.net/359365
04:54:07 <AndreasK> Is there something like the -fno-code for GHC that stops after the simplifier?
05:00:20 <phadej> AndreasK: isn't -fno-code exactly that?
05:01:09 <AndreasK> phadej: I think no code stops after typecheking. Then there is still desugar/simplifier before it gets to the cmm/codegen
05:02:32 <AndreasK> More concrete I want to get the result of -ddump-simpl but everything past the simplifier is just wasted time. With no-code it doesn't create core output so I assume that pass doesn't get run
05:05:31 <AndreasK> There is -S which dumps the assembly but I don't think thats noticeably faster then just compiling to o files
05:05:54 <phadej> AndreasK: yeah, I think something like "do enough to produce .hi files, stop then" would be useful
05:05:57 <phadej> I'm not aware there is such
05:06:48 <phadej> OTOH I'm not sure the after simplifier steps take that much time...
05:09:09 <phadej> AndreasK: have you tried -dshow-passes, how much time you'd save?
05:09:42 <phadej> if you omit linking (which takes time usually)
05:13:17 <AndreasK> codegen 6.5 sec, core prep 3 out of 51sec total
05:15:13 <AndreasK> Would be nice to have but not worth obsessing over
05:20:11 <lyxia> crunchbang: case e of ArrCreate { arrType = VarDec { varType = Nothing }, size = ..., defVal = ... } -> ...   for example
05:20:46 <phadej> AndreasK: yeah, but it can make "let me type-check my >1000 module project when I change the very base module" faster, with -O0 you still need to codegen
05:20:47 <lyxia> crunchbang: equivalent to "ArrCreate (VarDec _ Nothing _) _ _"
05:25:11 <crunchbang> lyxia Could you elaborate a little further? I'm new to this. 
05:28:50 <AndreasK> phadej: I assume one would use no-code then anway. I only am in that situation as I'm actually interested in the core output but not the executable itself
05:44:52 <ij> Who chooses the versions on stackage? When does something move from nightly to LTS?
05:45:13 <Clint> ij: https://github.com/fpco/stackage
05:52:02 <ij> \o/
06:02:02 <ph88> how can i display a table in ihaskell ?
06:20:47 <pie___> is there a functional construct for: generate an n-length list from the results of a function
06:21:00 <pie___> or should i just make a list and map onto it while ignoring the argument?
06:21:11 <pie___> (which seems inefficient)
06:22:48 <ventonegro> :t iterate -- pie___ ?
06:22:50 <lambdabot> (a -> a) -> a -> [a]
06:22:55 <lyxia> > replicateM 10 (\x -> x + 1) 33
06:22:58 <lambdabot>  [34,34,34,34,34,34,34,34,34,34]
06:23:13 <lyxia> replicate 10 ((\x -> x + 1) 33)
06:23:23 <pie___> ventonegro, ah hm. that sounds promising.
06:23:31 <pie___> thanks
06:57:54 <janiczek> @pl \f a b -> f b a
06:57:54 <lambdabot> flip
06:58:30 <janiczek> Can I make lambdabot not use that one definition and try to come up with another definition?
07:04:06 <mpickering> Can I use bound with two different kinds of variables?
07:06:32 <Psybur> @pl foldr (:) []
07:06:32 <lambdabot> foldr (:) []
07:15:24 <fiber_pilot> is haskell better than java ?
07:15:36 <etiago> oooh oh oh oh
07:16:02 <ridthyself> go easy fellas he's probably 12 years old
07:16:17 <byorgey> fiber_pilot: that question doesn't mean much.  Better in what ways?  Better for what?
07:17:17 <lyxia> mpickering: I think you can.
07:17:53 <fiber_pilot> is it a more functional language ?
07:18:03 <byorgey> fiber_pilot: yes
07:18:09 <mpickering> lyxia: Do you know of any examples or have some pointers?
07:18:51 <fiber_pilot> anyone here know any of the writers of haskell ?
07:19:03 <mpickering> It seems a lot is predicated on the fact that you parameterise your language by the type of its binders and things won't work if you need two type parameters 
07:19:32 <tdammers> "better" is a relative thing, mostly
07:19:41 <tdammers> depends on your requirements
07:20:12 <tdammers> if you need to ship something next week and all your team knows is Java, then Java is obviously the best
07:20:13 <byorgey> fiber_pilot: do you mean the members of the original Haskell committee?  Or people who work on GHC?  In either case, the answer is yes, and some of them even hang out in this channel or in #ghc
07:20:14 <[exa]> fiber_pilot: by writers you mean ghc developers?
07:20:28 <lyxia> mpickering: No, it's just a guess, but I would try something with a bifunctor and a Flip type
07:27:14 <abs> hey, im just trying to learn about haskell. Does anyone know of a way to figure out how many time x divides into y ? For example 3 divides into 15, 5 times
07:28:55 <ertes-w> abs: (/) or div depending on your needs
07:29:02 <ertes-w> > 17 / 4
07:29:06 <lambdabot>  4.25
07:29:07 <ertes-w> > 17 `div` 4
07:29:09 <lambdabot>  4
07:32:18 <abs> i've just realised that was a silly question, thanks guys :0
07:32:20 <abs> :)*
07:34:09 <mpickering> lyxia: The problem with overlapping scopes also seems non-trivial hmm
07:37:56 <lyxia> mpickering: what do you mean
07:39:36 <mpickering> Having interleaved A scopes and B scopes it seems like performing substitution and keeping everything aligned could be difficult. 
07:41:24 <lyxia> Right, that sounds tricky.
08:04:12 <muzzle> is there a way I can make a record field names "read only" i.e. I can use it to read a field but not set it with something like Record{field="foo"}
08:04:14 <muzzle> ?
08:04:43 <EvanR> yes
08:04:58 <EvanR> hide the record type itself in a module, only export the getters
08:05:22 <EvanR> data A = A { _field1 :: T }
08:05:30 <EvanR> field1 = _field1
08:12:30 <jchia_> I would like to get a style opinion. I'm putting a value x through a long sequence of transformation, and actually a lot of code in reality (The f's are long pieces of code, not merely variable names.). Is "y = f1 . f2 . f3 . ... . fn $ x" or "y = x & fn & ... & f3 & f2 & f1" more readable? I think the main reason the latter may be more readable is that the reader reads from left to right to figure out the steps of the transformation, a
08:12:31 <jchia_> nd left-to-right is the natural direction for reading things.
08:14:55 <ertes-w> jchia_: i think it doesn't really matter
08:15:24 <ertes-w> i'd go with (.)
08:15:54 <jchia_> ertes-w: OK
08:16:11 <ertes-w> jchia_: there is almost no technical reason for my preference though
08:16:24 <ertes-w> one is that (.) is associative
08:17:21 <jchia_> Thanks for the response. I think if it matters a lot to people, I will get more response.
08:19:55 <EvanR> composition makes more sense than a chain of applications
08:20:12 <tdammers> a . b . c . d $ x -- is a fairly common idiom
08:20:13 <EvanR> whether it should be left to right or right to left seems arbitrary though
08:20:57 <tdammers> x & a & b & c & d -- haven't seen that a lot in the wild, and & isn't in Prelude either
08:21:04 <bodisiw> as a haskell noob, the (.) syntax already looks much more familiar to me...
08:21:08 <EvanR> as far as readability, . is way more haskell-like
08:21:46 <tdammers> older haskell code would use a $ b $ c $ d $ x occasionally
08:22:00 <tdammers> multiple $ is a style you come across, for example in the GHC codebase
08:22:26 <tdammers> but all else being equal, I'd go with a . b $ x
08:28:00 * int-e often ends up with return $ foo . bar $ x
08:31:33 <jchia_> EvanR: You said "composition makes more sense than a chain of applications", but isn't "g . f $ x" equivalent to "x & f & g"?
08:31:52 <jchia_> int-e: I end up with pure . foo . bar $ x
08:37:11 <N30N> yo
08:38:47 <ertes-w> jchia_: the difference is mainly that (.) composes…  you can refactor the "g . f" part out of there
08:38:52 <ertes-w> directly
08:38:55 <EvanR> jchia_: it makes more sense because you can reassociate more easily
08:39:04 <N30N> anyone here
08:39:55 <ertes-w> N30N: hi
08:40:02 <tdammers> N30N: yes. Try /who.
08:40:06 <N30N> hey man 
08:40:51 <N30N> whats /who.?
08:41:00 <jchia_> ertes-w: Yeah, I can't change "x & f & g" to "x & (f & g)" and it's not straightforward to move the f & g outside.
08:42:11 <dsal> I've seen code using & lately.  It looks pretty weird to me in general.
08:42:40 <ertes-w> (&) is popular in lensy code
08:42:57 <dsal> Yeah, I can imagine it'd be useful in certain domains.
08:43:05 <ertes-w> i don't use it myself, because i don't get the point
08:43:28 <ertes-w> i guess people just really want that weird OO-style syntax, where the subject is in front
08:44:44 <marvin2> it looks nice in combination with >>=, call flows in the same direction. of course you just use =<< instead
08:45:12 <marvin2> is there a flip (<$>) operator somewhere btw?
08:45:21 <tdammers> :t <&>
08:45:24 <lambdabot> error: parse error on input ‘<&>’
08:45:29 <tdammers> :t (<&>)
08:45:30 <lambdabot> Functor f => f a -> (a -> b) -> f b
08:45:35 <tdammers> :t (<$>)
08:45:38 <lambdabot> Functor f => (a -> b) -> f a -> f b
08:45:42 <tdammers> there you go
08:46:24 <marvin2> where is it defined? hoogle can't find it
08:46:44 <dsal> @hoogle (<$>)
08:46:44 <lambdabot> Prelude (<$>) :: Functor f => (a -> b) -> f a -> f b
08:46:44 <lambdabot> Control.Applicative (<$>) :: Functor f => (a -> b) -> f a -> f b
08:46:44 <lambdabot> Data.Functor (<$>) :: Functor f => (a -> b) -> f a -> f b
08:46:57 <marvin2> odd. https://www.haskell.org/hoogle/?hoogle=<%26>
08:47:08 <marvin2> dsal, <&>, not <$>
08:47:18 <marvin2> @hoogle (<&>)
08:47:18 <lambdabot> Control.Lens.Lens (<&>) :: Functor f => f a -> (a -> b) -> f b
08:47:18 <lambdabot> Control.Lens.Operators (<&>) :: Functor f => f a -> (a -> b) -> f b
08:47:18 <lambdabot> Lens.Micro (<&>) :: Functor f => f a -> (a -> b) -> f b
08:47:36 <dsal> Oh, the last one I saw there was (<$>)
08:47:49 <marvin2> how come hoogle in lambdabot finds it but no on haskell.org
08:47:54 <marvin2> not
08:48:49 <int-e> they use different versions of the hoogle database
08:48:57 <int-e> @hoogle (a -> b) -> [a] -> [b]
08:48:58 <lambdabot> Prelude map :: (a -> b) -> [a] -> [b]
08:48:58 <lambdabot> Data.List map :: (a -> b) -> [a] -> [b]
08:48:58 <lambdabot> GHC.OldList map :: (a -> b) -> [a] -> [b]
08:49:23 <int-e> @hoogle [a] -> Int
08:49:23 <lambdabot> GHC.OldList length :: [a] -> Int
08:49:23 <lambdabot> NumericPrelude.Base length :: [a] -> Int
08:49:23 <lambdabot> Data.Edison.Seq.ListSeq size :: [a] -> Int
08:49:46 <ertes-w> @hoogle a b (a c b)
08:49:47 <lambdabot> Text.ParserCombinators.HuttonMeijerWallace item :: Parser s t e t
08:49:47 <lambdabot> Text.ParserCombinators.HuttonMeijerWallace stget :: Parser s t e s
08:49:47 <lambdabot> Text.XML.Basic.Attribute value :: T (T name string) string
08:51:22 <ertes-w> lambdabot has some weird things in its hoogle DB
08:51:32 <ertes-w> @hoogle ((Int, Int), (Int, Int))
08:51:33 <lambdabot> Game.VierGewinnt brettGroesse :: ((Int, Int), (Int, Int))
08:51:33 <lambdabot> Control.Isomorphism.Partial.Prim commute :: Iso (alpha, beta) (beta, alpha)
08:51:33 <lambdabot> Data.Invertible.Tuple swap :: (a, b) <-> (b, a)
08:54:36 <Johulk> Hey
08:54:42 <Johulk> Is this a good place to ask for help?
08:55:13 <dsal> Johulk: Hard to say without knowing what you want help with.
08:55:38 <dsal> (It's generally polite to ask the question you want the answer to.)
08:55:43 <Johulk> I know
08:55:46 <Johulk> I'm writing
08:55:54 <Johulk> I just thought this might not be the right channel to ask help on
08:55:57 <dminuoso> Oh man. `Think of a monad as a spacesuite full of nuclear waste in the ocean next to a container of apples. now, you can't put oranges in the space suite or the nucelar waste falls in the ocean, but the apples are carried around anyway, and you just take what you need.` - can someone explain to me how this relates to reality?
08:56:31 <Johulk> http://lpaste.net/359368
08:56:33 <Johulk> This is the code
08:57:06 <Johulk> It's supposed to add or subtract from the x and y value depending on the next value on the "Movimento" list
08:57:20 <Johulk> if it goes north, x+1, south, x-1 etc
08:57:27 <Johulk> and in the end gives me the end coordinates
08:57:45 <Johulk> When I compile it gives a parse / mismatched brackets error
08:59:48 <dsal> Johulk: you're missing an else
08:59:54 <EvanR> dminuoso: that seems like a joke
09:00:09 <dsal> But pattern match that h... Code will be way easier
09:00:15 <dminuoso> Johulk, boy please use case .. of
09:00:18 <Johulk> How do I do that?
09:00:21 <Johulk> xD
09:00:26 <Johulk> Sorry, kinda new to Haskell
09:01:36 <carbolymer> https://en.wikibooks.org/wiki/Haskell/Control_structures#case_expressions
09:01:42 <dminuoso> EvanR, mmh. You mean a joke on all those horrible monad analogies out there?
09:01:52 <EvanR> yes
09:02:13 <EvanR> like "as ridiculous as the most ridiculous one, plus"
09:02:19 <Johulk> @carbolymer is that for me?
09:02:19 <lambdabot> Unknown command, try @list
09:02:28 <Johulk> carbolymer: is that for me?
09:02:40 <carbolymer> Johulk, yes
09:02:50 <Johulk> Thanks. Let me rewrite real quick and test it
09:02:56 <sm> Johulk: it helps to keep if/then/else's straight if you put if, then, else on three lines
09:03:10 <dsal> One way:  posicao (x,y) (h: t) | h == Norte = (posicao (x+1,y) t) | h == Sul = ...
09:03:26 <Johulk> I see
09:03:28 <Johulk> Thanks dsal
09:03:31 <Johulk> and sm
09:03:32 <Johulk> xD
09:03:34 <dsal> (sorry, I'm on a phone.  Writing code is hard)
09:04:13 <Johulk> Its okay
09:04:44 <dminuoso> Johulk, as far as I have experienced, generally if/else seems to be a code smell.
09:05:12 <sm> but Johulk is just starting out
09:05:27 <[exa]> dminuoso: it's a good way for matching against True/False :D
09:05:38 <dsal> Though you could also just make a Movimento -> (t,t) -> (t,t) and simplify things a lot
09:05:55 <Johulk> I need to make it be like that
09:05:59 <Johulk> its an exercise
09:06:05 <Johulk> Like I have a Funcional Programming test
09:06:26 <Johulk> teacher gives us 50 questions before the test (like some weeks before). The test is 2 of those questions at random
09:06:29 <Johulk> we choose one and do it
09:06:34 <Johulk> we either have 0 or 1
09:06:37 <Johulk> it's either right or wrong
09:06:46 <Johulk> if I do 0 I fail the course instantly on the first test
09:06:52 <Johulk> with not even a month in
09:07:02 <dsal> It's wrong if he makes you write your own simple fold. :)
09:07:16 <Johulk> Oh well
09:07:34 <Johulk> rewritten
09:07:50 <Johulk> http://lpaste.net/359371
09:08:35 <tinco> hi! in this file: https://hackage.haskell.org/package/safe-money-0.3/docs/src/Money-Internal.html#Discrete
09:08:41 <[exa]> Johulk: just a style note, haskell is usually not coded with tabs so that you can align the | line to the exact character (but that's nitpicking from me :D )
09:08:43 <tinco> there's this line: newtype Discrete' (currency :: Symbol) (scale :: (Nat, Nat)) = Discrete Integer
09:08:46 <tinco> what does that do?
09:09:05 <dsal> Johulk: that's better. I'd remove those parenthesis, though.
09:09:13 <glguy> tinco: It defines a new type synonym Discrete
09:09:20 <Johulk> Its still an error
09:09:24 <dsal> But you'll notice there's a ton of duplication there.
09:09:26 <Johulk> Parse error on the " | "
09:09:34 <tinco> Discrete is defined as type Discrete ... = Discrete' ... a couple lines earlier, I'm confused by the circularity
09:10:01 <[exa]> Johulk: what meaning is the stuff behind = in the posicao definition?
09:10:06 <glguy> tinco: No, the newtype declaration below defines Discrete', which is a different name because of the '
09:10:28 <dsal> Johulk: you put the function definition twice on the same line
09:10:38 <Johulk> oh 
09:10:39 <Johulk> ffs
09:10:41 <Johulk> I'm so blind
09:10:44 <Johulk> ._.
09:10:56 <glguy> The data constructor defined in the newtype definition is in the separate value namespace
09:11:10 <Johulk> still an error dsal 
09:11:11 <tinco> eh oh
09:11:29 <[exa]> Johulk: -> instead of = in cases?
09:11:30 <tinco> there's a separate namespace for that?
09:11:39 <glguy> tinco: Yes, types and values are separate namespaces
09:11:44 <Johulk> let me try
09:11:55 <glguy> So these two definitions define the types: Discrete and Discrete'
09:12:03 <glguy> and also the value: Discrete (no relation)
09:12:12 <Johulk> Still the same error [exa] 
09:12:32 <dsal> Johulk: I don't know what you're looking at
09:12:46 <[exa]> Johulk: oh sorry, you're using part of the syntax from function matching and part from case statement. Either use the case keyword as shown here https://wiki.haskell.org/Case or function guards (without the = )
09:13:09 <dsal> I know how the last code you wrote would fail, but not how you fixed it
09:13:20 <Johulk> http://lpaste.net/359372
09:13:24 <Johulk> its the error
09:13:32 <[exa]> Johulk: this https://wiki.haskell.org/Pattern_guard
09:13:50 <dsal> Error without code isn't helpful
09:14:00 <[exa]> it's in the previous paste :]
09:14:11 <tinco> thanks glguy, I'm still a bit confused as to why there's a Discrete value, but it at least makes sense that it's not a reference to the previous Discrete type
09:14:12 <[exa]> Johulk: erase the = behind your function definition
09:14:24 <[exa]> Johulk: pattern guards don't have =
09:14:39 <Johulk> Okay
09:14:40 <Johulk> deleted it
09:14:47 <Johulk> now the error is on the "->"
09:14:49 <Johulk> must be = now
09:15:06 <dsal> [exa]: the previous one had two function definitions on one line. Said he fixed that and still had an error
09:15:17 <glguy> tinco: newtypes need a value-level constructor for making defined values having the newly defined type
09:15:28 <[exa]> Johulk: cool, getting there
09:15:39 <Johulk> got it
09:15:42 <Johulk> Now lets test xD
09:15:43 <[exa]> dsal: there was also the = etc etc
09:15:51 <[exa]> :]
09:15:52 <glguy> Given ''newtype N = C Int', the way you get a value with type N is to apply C to an Int
09:16:01 <dsal> Yeah. After fixing, hard to tell what's left.
09:16:32 <Johulk> Wooo
09:16:37 <Johulk> \0/
09:16:45 <[exa]> Johulk: as a next step I very strongly suggest to separate list processing from position logic; list processing can be easily done by fold
09:16:55 <dsal> +1
09:16:55 <Johulk> Haven't been taught fold yet
09:16:56 <[exa]> which will probably shrink your function a bit
09:17:03 <Johulk> Doubt I can actually use it xD
09:17:08 <[exa]> Johulk: well you just folded
09:17:13 <Johulk> Oh
09:17:14 <glguy> But given ''type S = Int'' then there's no need for a value constructor, S is just an alias for Int, so we can use S and Int interchangably
09:17:14 <[exa]> :D
09:17:21 <Johulk> I thought this was a way to do "if" statments
09:17:25 <Johulk> statements*
09:18:04 <Johulk> Anyways, thanks guys!
09:18:08 <Johulk> Time to 1 this test
09:18:09 <Johulk> xD
09:18:15 <tinco> glguy: I think I understand it now, are constructors generally in the value namespace? I realize Discrete doesn't have a constructor called Discrete, since it's just a type alias
09:18:35 <glguy> tinco: constructors exist in both namespaces. Constructors are the capitalized names
09:18:40 <[exa]> oh, the youth
09:18:50 <tinco> right that makes sense
09:21:46 <sarna> hey guys, is laziness really such a big obstacle to getting predictable performance?
09:22:35 <c_wraith> sarna: Not once you have sufficient experience with it.
09:22:45 <c_wraith> sarna: but "sufficient" is personal and hard to measure :)
09:23:20 <sarna> c_wraith: aw, thanks. that's good
09:24:18 <c_wraith> sarna: I thought I understood it sufficiently well once, then ended up with a massive performance issue caused by too much strictness.  I'm only confident I understand it well now, instead of absolutely sure. :)
09:25:26 <sarna> c_wraith: how many years of experience do you have in Haskell, if you don't mind me asking?
09:26:50 <c_wraith> Hmm.  looks like 10, with the first 5 being professional.  Note that in production use, laziness issues were very rare.  I've run into a lot more since Haskell has become hobby-only and I'm doing more experimental things.
09:28:16 <Johulk> I am back xD
09:28:30 <sarna> c_wraith: I see. thank you
09:28:50 <Johulk> Is there a way to make a list from a diffrence between coordinates?
09:28:58 <dsal> Sure
09:29:10 <Johulk> This function does something akin to 
09:29:22 <dminuoso> sarna, and honestly it's no different from "usual strict languages". In order to be able to judge performance you have to understand the algorithm, what the compiler does to that code, and how the underlying architecture functions.
09:29:34 <Johulk> path :: (Int, Int) -> (Int, Int) -> [Movement]
09:29:39 <Johulk> The first pair is the starting coords
09:29:45 <Johulk> the second pair is the final position
09:29:46 <dminuoso> sarna, and most of the time its not an issue - and once you learn some concept it gets easier and more intuitive. 
09:29:58 <Johulk> [Movement] is the list of movements done from the first pair to the second pair
09:30:18 <Johulk> I was going to do the second list minus the second one
09:30:42 <Johulk> but then I figured out I wouldnt know how to associate each x value to the new [Movement] 
09:31:25 <pie_> hi guys xD im looking for something that takes a list, applies a function to it, and returns a list, where the output is calculated cumulatively from the input...uh im real bad at expressing this; i want to pass a list of random numbers to function that adds to a variable based on the random number (1d random walk)
09:31:28 <dsal> > let f (a,b) (c,d) = (a-c, b-d) in f (10,10) (7, 4)
09:31:31 <lambdabot>  (3,6)
09:31:59 <Johulk> let f (a,b) (c,d) = (a-c, b-d) in f (10,10) (7, 3)
09:32:02 <sarna> dminuoso: yeah, I figured. that's my third take on Haskell, and as they say, third time the charm :^)
09:32:05 <dminuoso> pie_, foldl back into a list perhaps?
09:32:06 <byorgey> pie_: try 'scanl'
09:32:06 <Johulk> oh thought it was a bot
09:32:07 <Johulk> xD
09:32:10 <dsal> You could do something fancier with &&& or something.
09:32:20 <dsal> Johulk: Yeah, lambdabot is a bot.
09:32:23 <dminuoso> a scanl seems to be that :)
09:32:23 <byorgey> > scanl (+) 0 [1, 4, 1, -1, 3, -2, 7, 9]
09:32:26 <lambdabot>  [0,1,5,6,5,8,6,13,22]
09:32:29 <pie_> so something like (1 2 2 2 1 2 1) where 1 = go left 2 = go right: you start at zero: (-1 0 1 2 1 2 1)
09:32:30 <Johulk> dsal
09:32:35 <Johulk> I know how to make the new coords appear
09:32:49 <pie_> so the returned list gives the position
09:33:02 <lyxia> mpickering: http://lpaste.net/359373
09:33:11 <byorgey> pie_: first of all, I would use (-1) = go left and  1 = go right; then all you have to do is add
09:33:14 <pie_> dminuoso, byorgey thanks ill take a look
09:33:22 <lyxia> using bound with two sorts of variables
09:33:25 <pie_> byorgey, yeah thats better it was a bad quick example :P
09:33:36 <Johulk> Like (2,3) (3,4) = [North, East]
09:33:48 <byorgey> pie_: ok, no worries.  But in any case, I think you want  scanl (+) 0, or perhaps  scanl1 (+)
09:33:56 <pie_> ok thanks
09:34:05 <pie_> given that you saw the example you should be correct :(
09:34:07 <pie_> * :)
09:34:07 <byorgey> > scanl1 (+) [-1,1,1,1,-1,1,-1]
09:34:07 <mpickering> lyxia: Wow amazing thanks
09:34:11 <lambdabot>  [-1,0,1,2,1,2,1]
09:34:11 <pie_> now to try implementing that in scheme
09:34:21 <pie_> :D
09:34:38 <dsal> Johulk: Yeah, that makes sense.
09:35:19 <pie_> maybe i should learn haskell soon sicne these primitives seem more common there..
09:36:03 <Johulk> Anyways
09:36:08 <Johulk> I'll try to figure this out later
09:36:17 <Johulk> Have to run right now
09:36:18 <Johulk> Thanks
09:37:22 <pie_> byorgey, where can i see how scanl is implemented?
09:38:34 <mmaruseacph2> pie_: http://hackage.haskell.org/package/base-4.10.0.0/docs/src/GHC.List.html#scanl
09:38:55 <mmaruseacph2> process: hoogle for scanl, click to get to the hackage link, click on source on the far right
09:39:02 <pie_> thanks! i hope this will hekp
09:39:03 <pie_> ah ok
09:39:07 <pie_> that should be useful later
09:39:07 <pie_> :D
09:39:09 <mmaruseacph2> first step: https://www.haskell.org/hoogle/?hoogle=scanl
09:44:23 <jle`> pie_: that implementation is optimized for sharing and space usage, but there are simpler ones
09:44:26 <jle`> to understand
09:44:35 <jle`> @src scanl
09:44:36 <lambdabot> scanl f q ls = q : case ls of
09:44:36 <lambdabot>     []   -> []
09:44:36 <lambdabot>     x:xs -> scanl f (f q x) xs
09:44:46 <jle`> that's probably the simplest one
09:44:46 <pie_> jle`, do you have any reccomendations of places to look for simple implementations of these?
09:44:47 <pie_> thanks
09:45:17 <Psybur> @src unsafePerformIO
09:45:17 <lambdabot> Source not found. Wrong!  You cheating scum!
09:45:28 <jle`> actually nvm those two are the same heh, just one is moved into a where binding instead
09:45:38 <jle`> Psybur: @src doesn't give actual sources
09:46:06 <jle`> it's basically just like @quote, where users can attach arbitrary responses to certain inputs
09:46:16 <Psybur> i see
09:46:19 <jle`> @quote dmr
09:46:20 <lambdabot> No quotes match. Where did you learn to type?
09:46:25 <jle`> er, i guess like 'where'
09:46:28 <jle`> @where dmr
09:46:28 <lambdabot> http://www.haskell.org/haskellwiki/Monomorphism_restriction
09:57:49 <eacameron> I see that Data.Map says its an "ordered map"
09:58:01 <eacameron> Does that mean it is order preserving on operations?
09:59:05 <eacameron> Ah...nevermind. That must be OMap
10:00:38 <Psybur> > M.toList $ M.fromList [("b",1),("a",1)]
10:00:41 <lambdabot>  [("a",1),("b",1)]
10:10:21 <robertkennedy> > let is = [1..10]; ts = map ((,) True) is; fs = map ((,) False) is in [(the b, take 5 n) | (b,n) <- ts ++ fs ++[undefined], then group by b using groupWith]
10:10:24 <lambdabot>  error:
10:10:24 <lambdabot>      Unexpected transform statement in a list comprehension
10:10:24 <lambdabot>      Use TransformListComp
10:11:08 <robertkennedy> Darn. Well, anyways, would you expect that to work?
10:11:17 <robertkennedy> Seems like it ought to
10:11:53 <robertkennedy> But would require group by to realize Bool only has the two possibilities
10:12:01 <lyxia> I've never used these list comprehension extensions
10:12:21 <jle`> i have never heard of them actually
10:12:39 <robertkennedy> They are super useful in data science
10:12:55 <jle`> huh til https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#generalised-sql-like-list-comprehensions
10:13:18 <lyxia> ah... so that's what it's useful for
10:13:35 <jle`> feels weird to have it as an extension instead of an edsl
10:14:04 <robertkennedy> Yeah I use them many times a day, super super super useful 
10:16:43 <jle`> how long have they been in ghc? :o
10:17:25 <robertkennedy> Supposing this didn't work (not next to PC ATM), where would be the correct place to post this? The GHC Trac? It seems pretty complex, so it's not really a bug
10:17:50 <glguy> jle`: It's been years
10:19:56 <monochrom> Read on into the next section "monad comprehensions". You can do it to your monad too, there is a table showing the desugaring, so you can still think in terms of an edsl.
10:31:48 <Guest_M> Hi
10:45:09 <[exa]> for sure, these massive parts/joins wouldn't happen if the gateways were written in haskell.
10:48:51 <phadej> [exa]: one option is just hide joins/parts from this channel
10:49:16 <phadej> tab-completion is enough to hint if person left before you had time to answer their question :)
10:51:23 <phadej> though now i'm not sure how to do that only for single window/channel in irssi
10:52:13 <phadej> http://wiki.xkcd.com/irc/hide_join_part_messages#irssi
10:52:48 <Tuplanolla> Surely there's an option to only show messages for those users who have said something in the last five minutes.
10:53:44 <phadej> if nothing else, there's definitely a script for that
10:58:32 <jle`> i have that on weechat
10:59:30 <[exa]> phadej: ok thanks  (it was still supposed to be funny a bit, but I failed)
11:07:19 <phadej> [exa]: no thanks to you, i finally overcame my laziness and googled how to do that!
11:10:52 <monochrom> I posit that gateways written in Haskell would cause more netsplits and join/parts. Because every once in a while you get stop-the-world GC. :)
11:11:18 <Psybur> If I have a conduit of element a and a conduit of element b, how do I make a conduit of (a,b) :D?
11:12:27 <Psybur> Some kind of zip? Cant find anything :D
11:13:14 <shapr> I got to meet cement yesterday evening, was lots of fun!
11:13:20 <shapr> cement: is your coworker also on #haskell?
11:13:22 <JappleAck> is it allowed to use '\r' mac line-breaks in haskell source files?
11:14:24 <Psybur> I see there is zipSources
11:15:37 <cement> probably, they go by chessai here
11:16:27 <cement> I'll see if I can drew (my boss) to show up to a meeting sometime
11:17:03 <shapr> cool, would be fun
11:19:13 <Psybur> There a simple way to transpose conduits? :D
11:24:12 <lyxia> Psybur: I don't think there is. What happens if one conduit awaits while another yields?
11:24:41 <Psybur> If all are sourced from a file would that be a problem?
11:25:28 <monochrom> If one conduit awaits, then perhaps we want the zipped conduit to await too.
11:25:30 <Psybur> I suppose if I were to switch it from being sourced from a file to a rest call then yeah there might be that problem. Id probably skip that chunk though :D
11:25:47 <Psybur> or wait
11:25:51 <Psybur> timed wait probably
11:26:26 <Psybur> If there is no builtin I suppose I have to figure out how to do this with conduits :D https://hackage.haskell.org/package/base-4.10.0.0/docs/src/Data.OldList.html#transpose
11:27:45 <lyxia> Psybur: If it's only sources then ZipSource does that
11:27:51 <monochrom> transpose is quite a bit more ambitious than just zipping two inputs.
11:28:09 <Psybur> lyxia, yeah I want to be able to have more than 2 combined
11:28:12 <Psybur> Theres no zipN D:
11:28:26 <Psybur> Id rather it be in a list anyway
11:29:55 <monochrom> Aww nesting and composing a lot of ZipSources...
11:30:02 <Psybur> :{
11:32:17 <nshepperd> looking for transpose :: [Source m a] -> Source m [a]?
11:32:25 <nshepperd> traverse ZipSource should do that
11:34:10 <mnoonan> oof, System.Random's performance leaves much to be desired
11:34:26 <Psybur> Hmm, what about sequenceSources?
11:34:36 <Psybur> Wait nvm
11:35:36 <nshepperd> oh yeah, that's the same thing
11:38:43 <jle`> mnoonan: yes performance wasn't really a priority for system.random
11:38:53 <mmaruseacph2> mnoonan: PCG.Random
11:39:38 <mnoonan> mmaruseacph2, thanks!
11:42:49 <Psybur> Yep, sequenceSources is what I want
11:42:50 <dmj`>  @package mwc-random
11:43:11 <Psybur> nshepperd, thanks for making me second guess my second guessing :D
11:43:16 <dmj`> mnoonan: ^
11:43:59 <monochrom> System.Random did not prioritize anything, really.
11:44:38 <mmaruseacph2> dmj`: in my benchmarks pcg was faster than mwc
11:44:46 <monochrom> Apart from "need something to be present".
11:45:21 <dmj`> mmaruseacph2: hmm
11:45:35 <pie_> so, hypothetically speaking, i just realized lazy lists let us avoid writing loops?
11:45:55 <monochrom> Yes.
11:46:34 <monochrom> A pro doesn't use Haskell list for data structure. But they use it for control structure.
11:46:41 <Psybur> pie_, care to elaborate? :D
11:46:58 <Tuplanolla> @let import Control.List
11:47:00 <lambdabot>  .L.hs:55:1: error:
11:47:00 <lambdabot>      Could not find module ‘Control.List’
11:47:00 <lambdabot>      Perhaps you meant Control.Lens (from lens-4.15.4)
11:47:05 <monochrom> "mapM_ print [1..10]" is my idea of "for i=1 to 10 print i".
11:47:43 <monochrom> Tuplanolla: For maximum irony, Control.Lens and Data.Machine :)
11:48:03 <Tuplanolla> At least I have `Control.Self`.
11:48:09 <monochrom> Haha
11:48:33 <pie_> " well, i found it a pain in the ass writing a loop in scheme in a way i like (well, so far), so since i know the size of my data and its not perf critical right now im just pregenerating everything and using "fancy" stuff like this scanl function, but if you dont have all your data ahead of time, that makes me think a lazy list would make that work in the general case?"
11:48:37 <pie_> Psybur, ^
11:49:08 <pie_> monochrom, wait are you serious or being sarcastic? :P
11:49:20 <monochrom> Which sentence?
11:49:28 <pie_> <monochrom> A pro doesn't use Haskell list for data structure. But they use it for control structure.
11:49:34 <monochrom> Serious.
11:49:37 <pie_> <Tuplanolla> @let import Control.List
11:49:39 <pie_> <lambdabot>      Could not find module ‘Control.List’
11:49:53 <Tuplanolla> That one's less serious.
11:50:08 <Psybur> pie_, I think usually sequences and vectors are used for any non trivial amount of data :D
11:50:09 <monochrom> And I showed an example right after.
11:50:31 <pie_> ah whoops i cant read, that was Tuplanolla :P
11:50:43 <monochrom> OK
11:50:57 <pie_> ok but what if you dont actually need to use the index for anything
11:51:12 <monochrom> You're referring to vector?
11:51:14 <Tuplanolla> :t replicateM
11:51:16 <lambdabot> Applicative m => Int -> m a -> m [a]
11:51:17 <pie_> like, just a plain while true loop or something
11:51:24 <Tuplanolla> :t forever
11:51:26 <lambdabot> Applicative f => f a -> f b
11:51:41 <Tuplanolla> Those should do, pie_.
11:51:54 <monochrom> Oh but the lazy list doesn't have to be [1..10]. It was a boring example.
11:51:58 <pie_> though im actually using scheme so uh, im probably in the wrong place ;P
11:52:35 <monochrom> Read John Hughes's "why functional programming matters" for something less trivial you put in that lazy list.
11:52:54 <monochrom> (and it still acts like a control structure, a loop)
11:53:00 <monochrom> (or rather, it drives a loop)
11:53:48 <pie_> i mean sure it compiles to a loop and constantly has my brain in "its inefficient...its inefficient...its inefficient..." mode but its a lot nicer to read haha
11:54:16 <monochrom> And of course, if you're also saying "some loops can't be expressed in terms of lazy lists" you're also right. There are some loops I write my own recursion for.
11:54:30 <monochrom> It is efficient.
11:54:46 <monochrom> Using SML's list as a loop would be inefficient.
11:54:53 <monochrom> But Haskel's list is not SML's list.
11:55:06 <Psybur> > take 5 $ snd $ span (<5) [1..]
11:55:08 <pie_> right but im not using haskell :( not that i know my way around scheme that well either
11:55:10 <lambdabot>  [5,6,7,8,9]
11:55:24 <monochrom> Oh, then you should switch to Haskell!
11:55:57 <pie_> its been a little easier to play with scheme but given the questions im asking at this point maybe i should >_>
11:56:00 <monochrom> Scheme probably has a huge library of various loop constructs for you to choose from.
11:56:16 <pie_> monochrom, their preferred method of looping is recursion
11:56:17 <Psybur> I wonder if theres a tutorial of haskell that starts people off with vectors and conduits. Like a top down approach to make it so people dont end up making really shitty applications in haskell and giving up in frustration heh
11:56:25 <Tuplanolla> Optimization in Haskell is also more macroscopic than microscopic. You lose inline assembly, but gain rewrite rules etc.
11:57:29 <tdammers> haskell's list is like function () { return { head: function () { return 1 }, tail: function () { return { head: function () { return 2 }, tail: function () { return ...
11:57:32 <monochrom> If you want to know how Scheme programmers write loops in practice, you should ask them. Does #scheme or ##scheme exist?
11:57:47 <Tuplanolla> At least #chicken does, monochrom.
11:57:54 <pie_> monochrom, its probably not actually bad im just not used to it
11:58:01 <Tuplanolla> Ask them. Their compiler is really wacky.
11:58:16 <pie_> haha
11:58:20 <monochrom> My guess is that "reduce" and "map" etc gets you a long way.
11:58:23 <pie_> look for named let loop
11:58:41 <tdammers> scheme loops are probably written in terms of call/cc
11:59:29 <pie_> and of course i only now find this heh http://wiki.call-cc.org/eggref/4/loops
11:59:54 <monochrom> Yeah, those are useful.
12:00:54 <pie_> i uh cant actually find an example offhand
12:01:16 <mpickering> lyxia: It seems to make this work I have to put all my constructors in the same Expr datatype rather than a more fine grained approach I had before
12:01:24 <pie_> basically what ive seen is you recursively call yourself and have a parameter that keeps track of the iteration
12:01:34 <monochrom> Yeah.
12:03:18 <monochrom> Scheme proves that either you stay imperative or you go all out and accept laziness.
12:03:38 <pie_> idk what the thing about named lets was though
12:03:50 <monochrom> Because the "while" loop is only meaningful when you have a mutable variable and you keep polling its new state.
12:03:55 <pie_> monochrom, im pretty sure i didnt see lazyness emphasized at all?
12:04:24 <lyxia> mpickering: Oh?
12:04:53 <monochrom> So if you don't have a mutable variable then you have two choices.
12:05:17 <mpickering> For example, I had a constructor data Expr b a = ... App (Binder b) (Expr b a) (Expr b a)
12:05:22 <monochrom> Either you have to write your own recursion, which is tiresome, which is Scheme's way.
12:05:24 <mpickering> and I can't see how to implement bind for this 
12:05:52 <monochrom> Or you accept laziness, so you have use a lazy list and use mapM_ or map or foldl or foldr or scanl on it, which is Haskell's way.
12:05:56 <mpickering> As I have to somehow apply k to the things inside Binder and stuff the resulting Exprs into a Binder shaped hole
12:06:15 <mpickering> am I thinking about this wrong?
12:08:18 <jle`> mpickering: try thinking about 'join'
12:09:24 <monochrom> The reason writing your own recursion is tiresome is because after writing the recursion you are still not done.
12:09:44 <monochrom> You have to write one more line of code for the initial call with the initial parameter.
12:10:28 <monochrom> In Haskell I just write "mapM_ print [1..10]" and I'm done.
12:11:06 <mpickering> jle`: What exactly are you suggesting?
12:11:33 <monochrom> In Scheme I have to write like "let f x = if x <= 10 then print x; f (x+1) else return ()" and I am still not done. I have to add "main = f 1"
12:12:26 <monochrom> And also something about the "1" and the "10" are now so far away from each other.
12:13:30 <monochrom> Eager functional programming is the worst of both worlds.
12:13:43 <jle`> mpickering: thinking about how you'd write an Expr b (Expr b a) -> Expr b a function
12:13:54 <jle`> in a way that respects the laws
12:14:15 <c_wraith> monochrom, you can theoretically fix the extra line to call it portion. (pun intended, but that probably had problems in scheme somehow) 
12:15:39 <lyxia> mpickering: Binder b is like a pair of a variable and a type (with type variables of type b)?
12:17:50 <monochrom> I guess the Python and OCaml way out is to use "default parameters". f (x defaults to 1) = if x <= 10 then print x; f (x+1) else return ()
12:18:48 <monochrom> This turns out to have misleading effects on students.
12:19:01 <c_wraith> fix (\loop x -> if...) 1
12:19:20 <c_wraith> this is guaranteed to confuse students
12:19:54 <monochrom> My friend and colleague teaches proving correctness of loops and recursions. But his examples never use default parameters.
12:20:42 <mpickering> lyxia: Yes it's like a type which contains type variables of type b - To be concrete I am trying to implement the language described in section 5 of "Polymorphic binding time analysis"
12:20:50 <mpickering> but you could also think of a system F type situation 
12:20:56 <monochrom> And his coursework includes getting students to pose exercises to each other and solve each others' exercises on a forum.
12:21:31 <Psybur> > print $ runConduitPure $ yieldMany [1,2,3,4] .| concatMapC id .| slidingWindowC 2 .| sinkList
12:21:34 <lambdabot>  error:
12:21:34 <lambdabot>      Variable not in scope: runConduitPure :: t2 -> ()error:
12:21:34 <lambdabot>      Variable not in scope: yieldMany :: [Integer] -> t2error:
12:21:38 <monochrom> And since the students have known Python's default parameters, some of the exercises they think up are recursive programs that have default parameters.
12:21:46 <Psybur> @let import Conduit
12:21:47 <lambdabot>  .L.hs:44:1: error:
12:21:47 <lambdabot>      Could not find module ‘Conduit’
12:21:47 <lambdabot>      Use -v to see a list of the files searched for.
12:21:48 <mpickering> I fear my structure is all wrong 
12:22:39 <monochrom> And they think "I have to prove f(1) correct by induction" which is fruitless, rather than the correct approach "I have to prove f(n) correct for all n by induction, then I have a corollary for f(1)".
12:22:41 <EvanR> monochrom: where is that course taught... i think i need it
12:22:56 <monochrom> U of Toronto Scarborough CSCB63
12:23:23 <EvanR> canuckistan
12:25:03 <monochrom> A more illustrative example to show my point is this way of summing up a list/array: f (list, s defaults to 0) = if list is empty then s else f(tail of list, s + head of list)
12:25:36 <monochrom> Student thinks "I will just prove: f(list) = sum of list". And then they will be stuck.
12:26:13 <monochrom> You have to explicitly tell them "No, you need to prove the more general: f(list, s) = s + sum of list".
12:26:36 <monochrom> And even then, there is a 10% chance they disagree, "but I am only ever calling f(list, 0)!"
12:28:46 <lyxia> mpickering: The restriction you mentioned seems to come from the Bound typeclass. it could be generalized, but in the meantime it still seems possible to encode the terms you're playing with at a similar level of granularity using Scope.
12:29:05 <monochrom> Err, it's CSCB36, not CSCB63.
12:29:14 <monochrom> 63 is the data structure one I teach.
12:32:54 <Psybur> What does this type signature say about the upstream type, a? slidingWindowC :: (Monad m, IsSequence seq, Element seq ~ a) => Int -> Conduit a m seq
12:34:44 <geekosaur> it says nothing about a as such. it says that seq is a type with an IsSequence instance and an associated type family Element whose type must be a
12:34:53 <geekosaur> (i.e. a conduit on some kind of sequence of as)
12:35:02 <lyxia> mpickering: Bound is an interface for substituting expressions in expressions of the same kind, and here we want to substitute types in terms, which are different kinds of expressions.
12:35:34 <monochrom> c_wraith: I did "fix (\loop x -> ...) 1" for a while. And then I abandoned it on the slight pretext that I don't know how to align it to look nice!
12:37:50 <Psybur> geekosaur, ok. And can you figure out this error? https://pastebin.com/k63P4p8n :D
12:38:37 <geekosaur> it's ghc being pedantic about the standard, which predates things like type families and so imposes some silly restrictions
12:38:40 <shapr> cement: did you figure out if you can do IO in STM?
12:39:00 <cement> I'm like 98.5% certain that I cannot and should not
12:39:13 <shapr> fair enough
12:39:43 <Psybur> geekosaur, ok I turned on flexible context now I get this https://pastebin.com/09YMgsxd :D
12:40:03 <mpickering> lyxia: Indeed, perhaps t
12:40:09 <saurabhnanda> what does high txn rate (Req/sec) and low throughput mean? What about vice versa?
12:40:21 <Psybur> I guess I have to say what my types are?
12:40:32 <mpickering> rather than defining Monad I define Expr b a -> (b -> Binder c) -> Expr c a
12:40:44 <geekosaur> Psybur, yes that would follow. becuase it was trying to infer a Nu instance before. defualting doesn;t work with complex tyoeclasses like Conduit (or, I think, with type families)
12:40:58 <geekosaur> basically you need to specify *which* Num instance the list [1,2,3,4] contains
12:40:58 <mpickering> but I worry about how much other machinery I would need to reimplement
12:41:16 <geekosaur> in most contexts ghci would default to Integer, but Conduit is too much for it
12:42:12 <geekosaur> so say something like [1::Integer,2,3,4]
12:43:18 <geekosaur> (you an look up thr ExtendedDefaultRules extension to see what ghc can use defaulting with; it's wider than normal ghc but type inference is effectively impossible through some typeclasses)
12:45:11 <Psybur> geekosaur, https://pastebin.com/muLn4kDz :D
12:45:58 <geekosaur> same thing, looks like, you need to say slidingWindowC (2 :: Int)
12:47:36 <Psybur> geekosaur, https://pastebin.com/jxGYjVya :D
12:48:22 <geekosaur> dp I have to install all this stuff myself and work it through for you?
12:48:49 <Psybur> Its just stack install conduit-combinators and then import Conduit :D?
12:49:01 <geekosaur> actually I'm just going to ask you to get help from someone who knows conduit better than I do (which is barely)
12:49:11 <[exa]> mpickering: just curious, what exactly is your input language? (read: how do you get the monomorphism the paper requires?)
12:49:18 <geekosaur> because I was not expecting to have to be the wrong end of a slow ghci
12:49:19 <SegFaultAX> This is a rather general question, but do folks in the Haskell community reach for Free/FFree (Freer) as a way to construct their production applications?
12:50:29 <[exa]> SegFaultAX: that might also be a general programming practice question :] good practice is to use the simplest thing that does the job cleanly
12:50:44 <jle`> Psybur: do you have OverloadedLists on by any chance
12:50:50 <mpickering> [exa]: Well I will just type out the terms by hand :) The monomorphism isn't a requirement and plays no part in the paper's contribution. It is just simpler than System F
12:50:50 <Psybur> No
12:50:53 <mpickering> lyxia: https://github.com/ermine-language/ermine/blob/02b456e3cc32db4bb2374496263d5a8f683ffd22/src/Ermine/Syntax/Scope.hs#L46
12:50:54 <jle`> Psybur: oh wait
12:50:58 <jle`> Psybur: try print @Int
12:51:38 <Psybur> jle`, https://pastebin.com/3XbD1e1e
12:51:42 <SegFaultAX> [exa]: Well then have you (or others) found Free to be a practical way to construct real applications?
12:52:17 <fishythefish> Psybur: they mean replace 'print' with 'print@Int'
12:53:10 <bgamari> Can someone offer a review of this? It's a rather subtle fix to a core library so I think it should get review: https://github.com/haskell/text/pull/200
12:53:11 <Psybur> https://pastebin.com/qKjZ2QLf :D
12:53:33 <fishythefish> Psybur: and did you try reading the error message?
12:54:00 <lyxia> mpickering: nice find!
12:54:10 <Psybur> fishythefish, error message that talks about Element b0 and Int?
12:54:22 <fishythefish> no, the one that literally just told you to enable TypeApplications
12:54:31 <[exa]> SegFaultAX: not really, but it's good for DSLs and I didn't do much DSLs
12:54:46 <fishythefish> sorry if this is coming across as snarky, but you're having us debug your code by proxy when the compiler is telling you what to do
12:55:32 <Psybur> fishythefish, https://pastebin.com/pgXD4Tge
12:56:07 <[exa]> mpickering: oh so, I read it wrong the first time :] thanks
12:56:24 <SegFaultAX> [exa]: What shortcomings have you found in practice?
12:57:25 <Psybur> Ok, I figured it out
12:57:40 <Psybur> After sinkList I put [[Int]] :D
12:57:50 <Psybur> :: [[Int]]
12:57:51 <[exa]> Of Free? Mostly that 99.9999% population refuses to accept the idea of free monad so the software isn't exactly maintanable
12:59:25 <Psybur> So the following worked: https://pastebin.com/UPCPMuiY
12:59:55 <Psybur> Sorry for making everybody bang their heads against the wall :D
13:02:43 <maerwald> yeah, I'm bleeding now and need medical attention
13:03:00 <jle`> Psybur: print @Int should work i think, if you had turned on TypeApplications
13:03:02 * sm sends in a team of medics
13:03:07 <jle`> like the error suggests :)
13:03:17 <jle`> or print @[Int]
13:03:22 <Psybur> > map kiss maerwaldsBooBoos
13:03:26 <lambdabot>  error: Variable not in scope: kiss :: a0 -> berror:
13:03:26 <lambdabot>      Variable not in scope: maerwaldsBooBoos :: [a0]
13:03:28 <jle`> er, print @[[Int]], heh
13:04:02 <Psybur> jle`, yeah that works :D
13:04:35 <Psybur> fishythefish removed the space and confused it even more >:D
13:04:44 <jle`> you could also add the application onto sinkList i think depending on what its type is
13:05:04 <jle`> there's just a lot of ambiguity here unfortunately
13:05:08 <jle`> :'(
13:05:22 <jle`> the downside of super polymorphic programming with type families
13:08:03 <fishythefish> ah, sorry, typo on my part
13:08:44 <fishythefish> without the space, it looks like a pattern match, which is why ghc gets confused
13:12:37 <leinar> http://btcheat.com/?i=202843
13:16:08 <fresheyeball> Is there a function like this (MonadError e m => Either e a -> m a)?
13:16:16 <fresheyeball> Kind of lift this Either into the MonadError?
13:16:38 <johnw> either throw return?
13:22:33 <johnw> some call this liftEither: liftEither :: MonadError e m => Either e a -> m a; liftEither = either throwError return
13:22:36 <johnw> (from reddit)
13:24:08 <cocreature> looks like it’s even in mtl but not in any released version afaict https://github.com/haskell/mtl/blob/master/Control/Monad/Error/Class.hs#L116
13:27:55 <tinco> argh this safe-money library is driving me crazy
13:28:03 <tinco> no where documentation on how to use it
13:28:14 <tinco> and it uses a million weird ghc features
13:32:42 <phadej> :t hoistEither
13:32:44 <lambdabot> error: Variable not in scope: hoistEither
13:35:18 <phadej> hmm, we have fair amount of `either throwM pure` in our codebase
13:35:25 <phadej> but none `either throwError pure`
13:35:56 <tinco> anyone know how I can create a type that has a kind as a parameter?
13:36:28 <lambdamu_> tinco: With TypeInType kinds are types
13:36:35 <phadej> kinds are kind-of implicit, what you try to do?
13:36:46 <saurabhnanda> why doesn't warp/RTS/servant release memory once there is no load on the server?
13:37:02 <phadej> (no pun intended)
13:37:03 <tinco> lambdamu_: ah that's what the compiler suggested I added, maybe I should just do that
13:37:16 <johnw> tinco: data Foo :: k -> * where ...
13:37:50 <phadej> saurabhnanda: heap (residency size) or res as reported by h/top?
13:38:46 <tinco> well part of the problem is that I'm not 100% sure what I'm doing I bet :P
13:38:48 <tinco> newtype TradeData (price :: Money.GoodScale) (volume :: Money.GoodScale)
13:39:12 <saurabhnanda>   PID USER      PR  NI    VIRT    RES    SHR S %CPU %MEM     TIME+ COMMAND                                                                                                                                     
13:39:12 <saurabhnanda> 22761 vl        20   0  1.001t 802696   1580 S 28.3 81.1  11:15.82 webservice-exe   
13:39:16 <saurabhnanda> @phadej ^^
13:39:16 <lambdabot> Unknown command, try @list
13:39:23 <saurabhnanda> phadej: ^^
13:41:11 <tinco> so what I'm trying to do is create this Unboxed Vector that has these trade pairs in it, but I want to hide that all behind an interface, so the Vector has a type: TradeData (Scale "USD" "cents") (Scale "GBP" "pennies")
13:42:37 <tinco> Scale is a typefamily, so in my TradeData definition I have two parameters that should be part of that typefamily
13:45:19 <phadej> saurabhnanda: https://ghc.haskell.org/trac/ghc/wiki/Commentary/Rts/Storage/BlockAlloc
13:45:26 <phadej> Currently, megablocks are never freed back to the OS, except at the end of the program. This is a potential improvement that could be made.
13:45:45 <tinco> I created this:   newtype TradeData (price :: Money.Scale priceCurrency priceUnit) (volume :: Money.Scale volumeCurrency volumeUnit)
13:45:57 <tinco> but then I says: Expected a type, but ‘Money.Scale volumeCurrency volumeUnit’ has kind
13:46:10 <tinco> I added the TypeInType language extension
13:46:54 <lambdamu_> tinco: Is there any functional advantage fomr being explicit about currency in the types, or is just for additional type safety. If it's the latter in my experience that doesn't go well in Haskell, similar with explict units like m or km for lengths
13:46:54 <lyxia> tinco: how is Scale defined
13:47:08 <tinco> lyxia: https://hackage.haskell.org/package/safe-money-0.3/docs/Money.html#t:Scale
13:47:46 <tinco> lambdamu_: well I guess I could just make them all ints and assume I do everything correctly, but I thought the code would be neater if I made it explicit like this
13:48:14 <tinco> this safe-money is a library someone else wrote, I'm just trying to use it
13:48:38 <saurabhnanda> phadej:  does that mean a load spike could cause the memory usage to increase permanently?
13:48:38 <lyxia> tinco: well (Scale _ _) has kind (Nat, Nat), so price would have kind (14, 42), that makes no sense.
13:48:38 <saurabhnanda> phadej: even though the load has long-gone and GC has run?
13:49:32 <tinco> eh sorry yeah that because I messed up my naming, it should be priceScale and volumeScale
13:49:33 <phadej> saurabhnanda: my gut says yes. if you had a spike, you'll have another one
13:50:26 <tinco> so priceScale having kind (14,42) sounds sensical to me
13:50:33 <lyxia> tinco: Scale priceCurrency priceUnit is a pair of numbers, say for example it is (14, 42), then what do you think you can put in place of priceUnit such that (priceUnit :: (14, 42)) makes sense?
13:51:50 <lyxia> tinco: to put it another way, anything to the right of :: should have kind Type, but Scale priceCurrency priceUnit has kind (Nat, Nat).
13:53:00 <lyxia> tinco: and I don't have enough information about what you are trying to do with TradeData to guess how to fix it
13:53:41 <tinco> I'm just trying to get those scale types to be available to functions operating on TradeData
13:54:05 <lambdamu_> I'm not sure you are even allowed to use type families in newtype definitions like this
13:54:26 <phadej> tinco: newtype TradeData priceCurrency priceUnit volumeCurrency volumeUnit = ...
13:55:34 <lambdamu_> well apparently you are
13:56:34 <tinco> phadej: well that certainly removed some complexity :P
13:58:49 <saurabhnanda> under load warp/servant is throwing the following errors -- write: invalid argument (Bad file descriptor) // file handle went away -- what could be wrong?
13:59:04 <saurabhnanda> Network.Socket.sendBuf: resource vanished (Broken pipe)
13:59:21 <lambdamu_> I have a class "class Demote (t :: k) where reflect :: k" currently i have to apply kind and type like this "reflect @[Int] @'[1,2,3]" to get an instance but since every type has only one kind that seems unnecessary
13:59:38 <lambdamu_> Any way around this? reflect @_ @type doesn't do it
13:59:44 <phadej> saurabhnanda: client disappeared before warp had opportunity to deliver payload, nothing too bad
14:00:16 <saurabhnanda> can't be. only the haskell server is throwing this. The Rails server is not. The Haskell error rate is also increasing with increase in concurrency.
14:00:42 <phadej> saurabhnanda: warp is more principled in error reporting. Rails just don't print these errors
14:00:43 <tinco> saurabhnanda: are you sure the rails server isn't quietly swallowing those? is this real world?
14:00:59 <saurabhnanda> I'm looking at the number of errors via siege...
14:01:23 <phadej> siege is definitely not a normal client
14:01:29 <saurabhnanda> and the haskell server is showing the error on STDERR. Rails server has no STDERR attached to anything.
14:02:19 <johnw> i wonder why there's no foldMapM...
14:02:26 <phadej> maybe siege drops keep-alive connections eagerly
14:02:31 <phadej> who knows
14:03:27 <dmj`> there should be a foldMapM
14:04:17 <phadej> there is foldM
14:04:20 <johnw> GHC accepts PRs through github now
14:04:33 <tinco> saurabhnanda: so the haskell server is getting more errors in the siege report, at similar concurrency to the rails server?
14:05:04 <saurabhnanda> yes... I'm trying to find the exact concurrency level at which it starts breaking.
14:05:15 <saurabhnanda> at 5 concurrency, all seems well...
14:05:31 <phadej> in reports?
14:05:33 <tinco> I noticed there was a change in those errors between different ruby app servers, but I think it has to do with how they deal with clients they can no longer handle
14:05:52 <phadej> I don't believe
14:06:24 <saurabhnanda> phadej: no errors on siege or Haskell/STDERR
14:07:34 <saurabhnanda> Response time:                  0.13 secs // Transaction rate:              38.02 trans/sec // Throughput:                     0.02 MB/sec // Concurrency:                    4.96 // Failed transactions:               0
14:07:55 <saurabhnanda> now testing at 5-concurrency of Rails.
14:07:56 <johnw> foldMapM f = foldrM (\x rest -> mappend <$> f x <*> pure rest) mempty
14:08:02 <lyxia> lambdamu_: You can't reflect a Nat, can you?
14:08:16 <lyxia> lambdamu_: How do you get an Int at the type level
14:09:25 <lambdamu_> lyxia: Not sure actually, I use custom types but I think it should work at least for a finite number of type level naturals
14:09:36 <phadej> johnw: but that will be different than foldMapM f s = fold <$> traverse f s
14:09:38 <lambdamu_> lyxia: When you use a custom class like mine
14:10:05 <lambdamu_> lyxia: I choose the Int just as an example
14:10:28 <johnw> phadej: oh?
14:10:47 <johnw> foldMapM should depend on Foldable, not Traversable
14:10:48 <phadej> johnw: the oder of effects
14:10:56 <lyxia> lambdamu_: well here reflect @_ @'[ '()] works fine. http://lpaste.net/359385
14:10:57 <lambdamu_> lyxia: Well no it doesn't work if you reuse the kind variable
14:11:08 <johnw> phadej: ok, that should be fixed
14:11:12 <lyxia> lambdamu_: how?
14:12:10 <lambdamu_> lyxia: I meant demoting Int doesn't work like I thought, didn't look at the paste yet
14:12:22 <phadej> johnw: e.g. for tree, `toList` produces left ++ [x] ++ right, but you cannot do bottom-up foldMapOf, as the effects will be in some weird order then
14:12:51 <phadej> either you want commutattive effects, or commutative monoid
14:13:16 <phadej> otherwise you don't exploit associativity of Monoid
14:13:35 <lyxia> lambdamu_: but it looks like you're reinventing singletons
14:15:07 <lambdamu_> lyxia: Well sort of I just want to reflection, singletons has a lot more
14:15:58 <saurabhnanda> Rails (5-concurrency) - Resonse time (0.22sec) // Txn rate (22.04 req/sec) // throuput (0.08 mb/s) // concurrency (4.90) // failed txn (0)
14:16:12 <lyxia> lambdamu_: I think type -> term is reification.
14:16:23 <saurabhnanda> strangely txn rate is lower than haskell, but throughput is higher than haskell
14:16:39 <phadej> saurabhnanda: does siege verify the responses?
14:16:56 <saurabhnanda> verify in what way?
14:17:18 <phadej> that rails or haskell app doesn't just return "foobar" and make it happy
14:17:36 <lambdamu_> lyxia: Is it then I got my vocabulary wrong, what is reflection then? Promoting terms to types?
14:18:27 <phadej> lambdamu_: getting run-time information about compile-time stuff
14:18:27 <saurabhnanda> phadej: it checks for 200 responses... it doesn't compare the response with a known response.
14:18:27 <phadej> or doing something weird in runtime
14:18:44 <phadej> saurabhnanda: well, that eplains your throughtput difference
14:18:49 <EvanR> reflection is about creating dynamic instances at runtime though?
14:18:56 <lyxia> lambdamu_: I'm not sure actually. It certainly doesn't help that the reflection package says it "reifies arbitrary terms into types"...
14:19:06 <saurabhnanda> phadej: how? you're assuming that something is truncating responses randomly?
14:19:13 <lyxia> lambdamu_: so looks like I may be the one who got it wrong
14:19:35 <phadej> saurabhnanda: it can be, if you get dropped connection errors, maybe siege is lousy to read them completely or soemething else
14:19:55 <lyxia> lambdamu_: nevermind... "Reifies arbitrary terms into types that can be reflected back into terms"
14:20:00 <lambdamu_> lyxia: Well it seems related related, types are erased at runtime, so getting runtime representations of types being reification would be a kind of reflection no?
14:20:14 <saurabhnanda> phadej:  what is a good benchmarking tool, in that case?
14:20:22 <dsal> I'm kind of annoyed by tails returning [] -- why would I want that?
14:20:34 <lambdamu_> lyxia: Ah ok seems then my terminology was right
14:20:35 <dsal> (i.e., it unnecessarily complicates things in my code)
14:21:22 <phadej> saurabhnanda: I don't know
14:21:26 <phadej> saurabhnanda: bug eg. https://github.com/JoeDog/siege/issues/51
14:22:04 <phadej> but*
14:22:41 <tinco> dsal: in what case does it return []?
14:23:03 <phadej> https://github.com/wg/wrk this looks promising, it mentions "response processing"
14:23:03 <lambdamu_> lyxia: Regarding your paste, you cheated of course with the explicit type annotation, which is the same as what would go where the wildcard is under TypeInType semantics
14:23:06 <tinco> do you mean [""]?
14:23:28 <dsal> > tails [0..9]
14:23:31 <lambdabot>  [[0,1,2,3,4,5,6,7,8,9],[1,2,3,4,5,6,7,8,9],[2,3,4,5,6,7,8,9],[3,4,5,6,7,8,9]...
14:23:34 <dsal> heh
14:23:35 <lambdamu_> lyxia: But for some reason that example works for me even without the annotation while my examples are ambiguous, have to investigate..
14:23:37 <dsal> > tails [0..2]
14:23:40 <lambdabot>  [[0,1,2],[1,2],[2],[]]
14:23:48 <lyxia> lambdamu_: Ah, right.
14:23:50 <dsal> "" in a string, or [] in anything else.
14:23:52 <dsal> Super annoying.
14:25:03 <dsal> > tails []
14:25:06 <lambdabot>  [[]]
14:25:12 <lyxia> lambdamu_: well it still compiles if I remove it.
14:25:27 <tinco> yeah that makes no sense
14:26:03 <lambdamu_> lyxia: Yep that's what I meant
14:26:07 <dsal> Like, I *know* there's a [] at the end, but it sucks for my code because now I need to handle that case.
14:28:02 <tinco> dsal: betterTails = init.tails
14:28:17 <tinco> ;)
14:28:34 <lambdamu_> Ok the problem is my example also uses type families, btw I defined the class like this now "type KindOf (t :: k) = k; class Demote t where reflect :: KindOf t" which makes the TypeApplication much nicer
14:28:58 <dsal> tinco: Yeah.  This is already absurdly expensive.  :)
14:29:23 <dsal> Actually, not in *this* case.  I just want to know if there's a duplicate in this small list I made.
14:30:41 <crucify_me> hi one lil thang: in   '  foldl (/) 64 [1,2,4]  '    since in my notes the second argument 64 is misnamed "accumulator", is it correct to say that it is a value whose main feature is that it is updated?
14:30:44 <dsal> > let hasdup combo = all (\l -> case l of (h:t) -> h `notElem` t; _ -> True) $ tails $ map snd combo in  hasdup [('a', 1'), ('b', 2), ('a', 3)]
14:31:01 <lambdabot>  <hint>:1:120: error: parse error on input ‘)’
14:31:01 <lyxia> lambdamu_: so now it works with reflect @'[ '() ] ?
14:31:12 <monochrom> I am actually fine with "accumulator".
14:31:24 <crucify_me> ie my notes say it is commonly named accumulator.
14:31:36 <crucify_me> misnamed*
14:31:46 <lambdamu_> lyxia: Yep, I'm sorry for the noise, I assumed the problem would be with the wildcard, but my types were actually ambiguous, due to a type family
14:31:47 <dsal> Bah, anyway.  It works, but I don't like having the case.
14:32:03 <monochrom> Err, Oh, I guess I see why.
14:32:28 <monochrom> If you're looking at how to write foldl, it's an accumulator. If you're looking at how to use foldl, it's a seed.
14:32:33 <crucify_me>  really yeah monochrom but in that parameter you have a situation where the initial value is being updated, right?
14:33:02 <monochrom> Programming is a dialectic class struggle between the implemeter and the user.
14:34:38 <crucify_me> seed value. but it has nothing to do with linear vs. tail recursion right?
14:35:00 <crucify_me> I see it operating similar to tail recursion
14:35:02 <nisstyre> monochrom: more like the implementer and the sales people
14:35:16 <crucify_me> similarly
14:35:28 <nisstyre> users don't know what they want
14:35:37 <monochrom> nisstyre: Well, I am looking at a library's authors and a library's users.
14:35:54 <crucify_me> are my comments near correct?^
14:36:00 <crucify_me> nearly
14:36:01 <monochrom> If you use lens or develop lens, for example, who is the sales people?
14:36:10 <nisstyre> monochrom: oh, I'm coming from a commercial lens
14:36:23 <nisstyre> monochrom: good point
14:36:27 <nisstyre> whoever pays your bills
14:37:10 <monochrom> Perhaps the sales people are the lens tutorial authors.
14:37:20 <nisstyre> or the people writing books
14:37:26 <monochrom> This is now a 3-body problem.
14:37:52 <monochrom> Programming is a trialectic class struggle between implementers, users, and commentators.
14:38:02 <crucify_me> I mean is that a tail-recursive function? sorry I am trying to see it vis a vis what I know of scheme
14:39:08 <maerwald> I can sell you something that is enterprise-level quality
14:39:13 <nisstyre> monochrom: or people who make money off of training people to use it
14:39:13 <monochrom> Clearly, "seed" makes sense for all kinds of recursions, not just tail recursion.
14:39:18 <nisstyre> same thing really though
14:39:44 <crucify_me> yes its a good word thanks
14:39:56 <nisstyre> I wonder if people would pay for monad tutorials
14:40:36 <monochrom> Yeah I use "commentators" to cover those who speak to implementers on behalf of users, or pretending to be users. Sales, tutorials, bloggers, ...
14:40:39 <barrucadu> Monad tutorials are the Haskell community's main export
14:41:11 <maerwald> monads suck!
14:41:14 <nisstyre> barrucadu: I should invest in monad futures
14:41:19 <nisstyre> or maybe lens futures
14:41:32 <monochrom> I doubt that people would pay for monad tutorials.
14:41:44 <nisstyre> I'll buy 500 unproduced monad tutorials and then resell em for a profit
14:41:49 <maerwald> monads are where haskell became OOP and over-engineered 
14:41:57 <crucify_me> did someone say tutor ?   I live in Berkeley CA USA and can't find a tutor for this shit
14:42:03 <monochrom> People don't even pay for display-docs-in-ghci.
14:42:30 <EvanR> color in ghci
14:43:47 <crucify_me> so I appreciate your help even more  , changing moniker to -> chastise_me
14:44:07 <lambdamu_> maerwald: Monads suck if you have a better alternative.. Do you have one?
14:44:19 <maerwald> lambdamu_: yes, an effects system
14:44:34 <nisstyre> chastise_me: I think tail recursive functions are often written using an accumulator pattern but not necessarily
14:45:05 <lambdamu_> maerwald: Do you have a reference for that?
14:45:13 <maerwald> for... what?
14:45:23 <lambdamu_> maerwald: For you proposed effects system
14:45:32 <maerwald> there is none for haskell, really
14:46:01 <maerwald> purescript came close with row types, but they seem to go the other way and try to remove them
14:46:21 <nisstyre> it would be funny if people treated programming language features like commodities to be bought and sold
14:46:27 <chastise_me> nisstyre: you mean written.. so a seed is written differently? I thought we were talking about nomenclature that made sense in regards to the same thing
14:46:35 <maerwald> Koka and F* "kind" of have an effect system, but not as fine-grained as you may thinkg
14:46:44 <maerwald> at least they have a proper definition of total functions though
14:46:51 <nisstyre> so you could guess that a certain feature won't be implemented and then bet against it
14:46:55 <lambdamu_> maerwald: What about idris?
14:47:03 <nisstyre> chastise_me: can you restate the question?
14:47:12 <lambdamu_> maerwald: Don't they have something like that. too?
14:47:17 <maerwald> Idris doesn't represent totality on type level
14:47:34 <maerwald> to me that's very far away from an effects system
14:47:45 <chastise_me> nisstyre: sorry , thinking...
14:47:52 <nisstyre> chastise_me: accumulators aren't updated (mutated)
14:47:58 <nisstyre> they're just replaced with a new value
14:48:00 <nisstyre> like anything else
14:48:18 <nisstyre> it's not like in scheme where you could do (set! a (add1 a)) or something
14:48:41 <monochrom> In Scheme they don't use set! on an accumulator either.
14:48:59 <chastise_me> ok I thought that was essentially how updating is understood. 
14:49:00 <nisstyre> yeah that's a very uncommon thing
14:49:06 <nisstyre> but if you know scheme
14:49:09 <monochrom> Their accumulator still refers to an immutable parameter.
14:49:26 <chastise_me> I thought the idea of updating only applied to tail-recursion.
14:49:30 <nisstyre> you would do it in a loop or something in Python
14:49:41 <nisstyre> get away from the idea of "updating"
14:49:42 <chastise_me> because otherwise you have a stack
14:49:56 <nisstyre> you're replacing it with a new value
14:50:35 <chastise_me> yes is substitution correct?
14:50:57 <nisstyre> I don't know if that's the best way of thinking about it either
14:51:04 <maerwald> lambdamu_: but if everything you know are monads, then monad transformers are a natural consequence... but if you look at them in an abstract, neutral way... they just suck, and are not really "declarative"
14:51:08 <chastise_me> thanks
14:51:09 <nisstyre> you're calling the function with different arguments
14:51:32 <nisstyre> there's nothing special about it being recursive or tail-recursive
14:52:08 <maerwald> and you can go further and say "I want to limit my IO to a specific set of syscalls without breaking APIs for users"
14:52:18 <nisstyre> it's just a style of writing the function
14:52:19 <nisstyre> with an accumulator
14:52:19 <maerwald> that's hard
14:52:38 <jcarpenter2> How much memory is used by a Nat?  It's O(n) isn't it, not O(log n)?
14:52:52 <lambdamu_> maerwald: I'm not happy about monads, too, but I never seen something to replace them and I'm not sure effects cover everything monads are used for
14:53:16 <jcarpenter2> because Nats aren't stored in binary, a Nat is a pointer to a pointer to a pointer to ... to zero
14:53:47 <thebardian>  /j lisp
14:53:55 <jcarpenter2> but at the same time, all nats in your program can be aliased to the same locations
14:54:00 <lambdamu_> maerwald: When I write monadic code I often think, this is just a slightly funny way to write lambda expressions, which makes me think why have a separate syntax for that, but I never thought that through
14:54:14 <maerwald> lambdamu_: well, you cannot have an alternative approach unless you bake it into the type system (the closest you get might be extensible-effects, see the oleg paper and the freer implementation, but I don't consider that an effects system either)
14:54:23 <chastise_me> nisstyre: ok I'm going to go with seed value .. 'just a style' so that means in foldl that parameter is written with a certain structure? 
14:54:30 <maerwald> baking it into the type system would involve a new haskell report, imo
14:54:41 <nisstyre> chastise_me: I'm not sure what you're getting at with foldl
14:55:07 <lambdamu_> maerwald: I wouldn't chain myself to Haskell either
14:55:28 <maerwald> the thing is... even if there was a language that gets it right... the ecosystem would still suck :>
14:55:46 <maerwald> since no one is using it
14:55:58 <maerwald> so people are stuck with haskell 
14:56:02 <nisstyre> chastise_me: the first parameter is conventionally an accumulator
14:56:13 <nisstyre> but that's just convention, you could ignore it if you wanted
14:56:23 <nisstyre> (which wouldn't make sense but you could)
14:56:42 <chastise_me> ok thanks, one moment pls
14:57:08 <lambdamu_> maerwald: Well that is the basic problem of all language design, but if a clearly better solution exists and some point some language will use it, but I'm not sure we really have that, this is very much active reasearch with Koka and such
14:58:11 <maerwald> lambdamu_: if you look closely... haskell has stopped evolving in 2010
14:58:24 <maerwald> the rest you know is just GHC hacks which are underspecified
14:58:48 <lambdamu_> Or overspecified, the compiler being the specification :P
14:58:55 <maerwald> that's not what a spec is
14:59:29 <lambdamu_> Well not in the traditional sense
14:59:40 <maerwald> yes, so the language has stagnated
15:00:11 <maerwald> but in order to fix major problems like the ones mentioned, you cannot get away with GHC extensions... you would have to *change* the language
15:00:12 <lambdamu_> maerwald: That is you perspective but for a very specific definition of language
15:00:39 <maerwald> but then you'd have to first represent the current "state" of "practiced haskell"... as in: spec all those underspecced GHC extensions
15:00:41 <lambdamu_> maerwald: Languages like Ruby have always taken the implentation is specification approach
15:00:44 <maerwald> no one wants to do that
15:00:57 <maerwald> implementation is _never_ specification
15:01:00 <maerwald> that is just *wrong*
15:01:17 <dsal> Implementation is truth.  :p
15:01:22 <maerwald> no.
15:01:35 <lambdamu_> maerwald: I'm not saying that went well for them, but saying Ruby doesn't exist as a language since there is no specification in the classical sense is also a stretch
15:01:36 <lyxia> :t Proxy :: Proxy 1000000000000 -- jcarpenter2 would this be possible if it were O(n)
15:01:38 <lambdabot> Proxy 1000000000000
15:02:01 <chastise_me> nisstyre: I'm just going with your advice to not think about updating. thanks kindly
15:02:03 <maerwald> lambdamu_: you can call ruby an interpreter and an underspecified language
15:02:22 <nisstyre> chastise_me: no problem
15:02:47 <nisstyre> chastise_me: you should think of it like you would think of algebra, where it gets expanded
15:02:48 <lambdamu_> maerwald: I get you point of view, but it is not necessarily the maintstream definition of what is means to be a programming language
15:03:04 <maerwald> I didn't come up with a defintion of "programming language"
15:03:13 <maerwald> I am just saying what is specified and what is underspecified
15:03:27 <jcarpenter2> lyxia: Proxy?
15:03:43 <maerwald> rust doesn't have _any_ spec
15:03:45 <jcarpenter2> 1000000000000 is not a type, so how can you have a Proxy 1000000000000?
15:03:50 <maerwald> yet you may call it a programming language
15:04:10 <maerwald> Go has a *toy* spec
15:04:23 <lambdamu_> maerwald: Hm ok I guess we're hairsplitting here, but your statement would then be Haskell has stopped evolving as a specified language in 2010 and kept on involving as a underspecified language
15:04:25 <maerwald> something that wouldn't really qualify as a spec amongst academics
15:04:48 <maerwald> lambdamu_: exactly
15:04:58 <lambdamu_> maerwald: Which is of course trivially true since the last Haskell Report (Draft?) is from 2010
15:04:59 <chastise_me> ok cool
15:05:00 <lyxia> jcarpenter2: Proxy is poly kinded
15:05:18 <maerwald> which (in some areas) boosts the development and it other areas (where more radical change is needed) stagnates development
15:05:42 <maerwald> the point is understanding what kind of change is possible in what kind of context
15:05:58 <lyxia> jcarpenter2: so the type constructor Proxy can take any type of any kind as an argument
15:06:24 <maerwald> I think the biggest mistake in haskell will be trying to get dependent types into GHC without re-speccing the language
15:06:28 <maerwald> this will be devastating
15:06:29 <jcarpenter2> lyxia: but 10000000000 is not a type of any kind is it?
15:06:35 <lyxia> jcarpenter2: in particular it accepts arguments of kind Nat
15:06:37 <maerwald> dependent types are a VERY radical change
15:06:56 <maerwald> and you want them in the language spec
15:06:59 <lyxia> jcarpenter2: maybe I shouldn't have said "type"
15:07:38 <EvanR> haskell: a very radical language
15:07:42 <lambdamu_> maerwald: That might be true, I don't know that, but better documentation for added features would certainly be nice
15:07:52 <jcarpenter2> well, 100000000000 is of type (Num p) => p
15:07:59 <not_a_ro1ot> n00b question on dependent types, but I'm not sure I understand them. In C++, if I have a typename inside of a template struct, the compiler calls it a dependent type. According to what I've read about dependent types in general, this is indeed a dependent type, as its properties depend on the arguments used to instantiate the containing  template. Is this accurate?
15:08:00 <lyxia> jcarpenter2: but anyway my point is that lambdabot handled the Nat 1000000000000 just fine
15:08:09 <lyxia> jcarpenter2: no it's a Nat on the right of ::
15:10:56 <lambdamu_> maerwald: I heard there were interest in a new specifcation, though, are you part of that effort?
15:10:59 <maerwald> lambdamu_: documentation is not enough. Depedent types is like saying "oh look, let's make our language lazy, but who cares if that is part of the spec"
15:11:17 <maerwald> lambdamu_: no
15:11:31 <iqubic> maerwald: Have we got dependent haskell yet?
15:11:37 <EvanR> StrictHaskell extension...
15:11:41 <maerwald> in *haskell*? no
15:11:47 <EvanR> oh look, lets make our language strict haha
15:11:51 <EvanR> not in the spec
15:11:57 <maerwald> EvanR: you mean in GHC, yeah ;)
15:12:07 <johnw> I depend on Haskell, is that enough?
15:12:10 <jcarpenter2> lyxia: okay, i'll buy it
15:12:13 <lyxia> :t Proxy :: Proxy (1000000000000 :: GHC.TypeLits.Nat) -- jcarpenter2   :: (Num p) => p   would be an error. Types cannot be overloaded.
15:12:14 <lambdabot> Proxy 1000000000000
15:12:29 <lambdamu_> iqubic: We don't have dependent types in GHC yet
15:12:33 <maerwald> laziness is not just a feature, it may change *semantics* of your program
15:12:43 <lambdamu_> iqubic: We have some changes towards it like TypeInType
15:12:48 <maerwald> you want that specced
15:12:53 <maerwald> and so is dependent types
15:13:18 <iqubic> What is TypeInType?
15:13:28 <maerwald> I'd say a reasonable GHC-ism is pattern synonyms
15:13:35 <maerwald> I don't see why you'd spec that
15:13:42 <lambdamu_> iqubic: The collapse of kinds and types
15:13:54 <lambdamu_> iqubic: Kinds are types with TypeInType
15:14:26 <EvanR> including the kind *
15:14:33 <EvanR> now is a type, of type *
15:14:37 <EvanR> renamed to Type
15:15:11 <EvanR> wacky
15:15:33 <johnw> a
15:15:35 <lambdamu_> Type :: Type :: Type :: Type ..
15:15:41 <EvanR> -XYoDawgIHeardYouLikedTypes
15:16:05 <maerwald> -XThisShouldBeANewLanguageSpecButNoOneBothered
15:16:06 <maerwald> :D
15:16:09 <not_a_rob0t> is it possible, purely theoretically (not in haskell) to treat kinds as a sort of undersdetermined type?
15:16:22 <Tuplanolla> It's called `-XIdris`.
15:16:33 <maerwald> does idris even have a spec? :>
15:16:51 <EvanR> it changes a lot
15:16:58 <EvanR> so thatd be kind of silly
15:17:52 <maerwald> well, in the end, life is hard
15:18:29 <lambdamu_> I wouldn't be so dismissive of the DependentHaskell effort, if it's backwards compatible having a working implementation is acutally a big step towards something that would spec worthy
15:18:53 <maerwald> lambdamu_: usually it goes the other way around
15:19:00 <EvanR> i think dependent haskell is going to be the shit
15:19:41 <maerwald> if you start implementing stuff without a clear understanding of what it is... it will end up as... exactly that, something without clear understanding what it is
15:19:44 <lambdamu_> maerwald: But from an engineering perspective it makes we wonder how anything usable can come out of that
15:19:59 <maerwald> why so? dependent types have been done before, numerous times
15:20:09 <maerwald> it's nothing you need to prove on an academic or theorical level
15:20:16 <maerwald> knowledge is already there
15:20:22 <lambdamu_> Sure but not in a practical language
15:20:25 <maerwald> ofc
15:20:29 <lambdamu_> And it still hasn't
15:20:29 <maerwald> numerous languages
15:20:38 <maerwald> idris, agda, F*, ...
15:20:54 <EvanR> dependent haskell will be different 
15:21:07 <maerwald> it will break haskell
15:21:15 <lambdamu_> I would disagree about agda, I don't know F* and idris is promising but to soon to call
15:21:19 <jcarpenter2> it'll be too complicated and slow to compile
15:21:29 <maerwald> it will never get into the tiobe index and companies like facebook will look for alternatives
15:21:34 <EvanR> its going to be a different kind of DT experience
15:22:02 <maerwald> if you want the full thing, follow F*
15:22:07 <maerwald> they will do all that 
15:22:17 <maerwald> but they have a very different scope
15:22:44 <maerwald> you can break the scope of a language with a feature
15:22:56 <maerwald> and by breaking the scope you can break the ecosystem... and the adoption of the language
15:22:56 <jcarpenter2> first, you only want total functions that output types, for obvious reasons
15:23:21 <jcarpenter2> and no algorithm admits all total functions while rejecting all non-total functions
15:23:33 <jcarpenter2> and second, even if you've proven it's total, you haven't proven it's necessarily fast
15:23:50 <maerwald> haskell was successfuly because it has less feature than idris, agda, F*, ...
15:24:11 <maerwald> sometimes, 'less' is what makes a language complete
15:24:17 <jcarpenter2> see https://www.xkcd.com/303/
15:24:53 <johnw> jcarpenter2: some languages make that a better excuse than others :)
15:25:05 <maerwald> e.g. people wonder how Go ever became so popular and blame it on marketing only... but that's not the truth. Most of the decisions were about "let's not include <this> in the language"
15:25:42 <nisstyre> maerwald: I just don't get why Go is used for certain things, like DevOps stuff, what makes Go so useful for that?
15:26:10 <lambdamu_> jcarpenter2: What are the obvious reasons you only want total functions on types? I would argue if you ever want to run partial functions it is at compile time
15:26:12 <maerwald> nisstyre: show me another low-level language that doesn't suck and has intuitive and *simple* support for async IO
15:26:16 <maerwald> and don't say haskell, it doesn't
15:26:23 <nisstyre> maerwald: Erlang
15:26:34 <jcarpenter2> lambdamu_: so that you don't have to worry about whether the compiler will halt or not
15:26:37 <maerwald> fair point, Erlang is used a lot in industry too
15:26:49 <maerwald> especially in energy companies
15:26:53 <nisstyre> maerwald: it's also a breeze to deploy
15:27:32 <lambdamu_> jcarpenter2: Well if takes to long I'll just kill it, I think there are already pathological cases with GHC where it won't be finished in a reasonable time frame, so that's the same deal
15:27:39 <maerwald> nisstyre: think of Go as the "imperative" counterpart of Erlang
15:27:42 <maerwald> then it makes sense
15:27:55 <iqubic> Why do the energy companies use erlang?
15:27:59 <lambdamu_> jcarpenter2: And then come up with more efficient functions, just like we do for runtime computation
15:28:03 <maerwald> iqubic: no idea, but they do
15:28:03 <jcarpenter2> if the compiler crashes, that's possibly not quite as bad
15:28:08 <maerwald> e.g. Enernoc
15:28:54 <maerwald> it's still popular for backend work
15:29:09 <maerwald> but I guess startups rather choose Go
15:29:38 <maerwald> because you gotta be fancy
15:29:50 <jcarpenter2> it might be possible to display a helpful error message if a type-level function is undefined for a certain input
15:30:39 <maerwald> for backend work, my choice of language would probably be: Go > Erlang > rust > haskell > all the other crap
15:30:45 <lambdamu_> jcarpenter2: You can do that in Haskell today, https://hackage.haskell.org/package/base-4.10.0.0/docs/GHC-TypeLits.html
15:30:58 <dsal> erlang's implementation is a little scary.
15:31:05 <iqubic> maerwald: So what do you use haskell?
15:31:19 <maerwald> iqubic: for fun
15:31:20 <dsal> go and erlang aren't very similar.  They come up in conversations together a lot, though.
15:32:26 <maerwald> iqubic: did some computer graphics algorithmic stuff, it sucked and I wished I had done it in python.. then I did systems programming stuff and it sucked and I wished I had done it in rust... then I did web stuff and it sucked and I don't know what I wish for... web sucks anyway :P
15:33:03 <maerwald> but the clear thinking of effects, purity and so on... is something you don't achieve in any other language
15:33:09 <jcarpenter2> "you can usually count on a programmer's unwillingness to believe that web dev could possibly be as bad as they remember"
15:33:22 <jcarpenter2> - somebody
15:33:27 <maerwald> so haskell, to me, is kind of just a good teacher, but not a practical companion
15:33:53 <jcarpenter2> web dev is the classic struggle between turing completeness and totality, imo
15:34:00 <maerwald> you can apply the knowledge you gather in haskell everywhere
15:34:11 <maerwald> and people will be confused and amazed by what you did and why
15:34:55 <iqubic> maerwald: What do you mean?
15:34:56 <jcarpenter2> on the one hand there's HTML and CSS which you can display however you want, at any zoom level or through any accessibility software or whatever
15:35:20 <jcarpenter2> on the other hand there's javascript swooping around, meddling with page contents
15:35:58 <maerwald> iqubic: for example... if you have dealt with the annoyance of IO in haskell, you try to keep everything more abstract, IO-free... you just write your programs differently, you constantly think about "effects" and so on
15:36:11 <iqubic> I see.
15:36:16 <maerwald> you don't do that as a natural C programmer... you just do whatever syscall you need
15:37:00 <maerwald> which makes you structure your functions differently, and makes you design your API differently
15:37:08 <EvanR> this is the only channel where matrix.org is spamming the hell out of... for me
15:37:11 <maerwald> and people will usually like it, ime
15:37:20 <bitemyapp> EvanR: happens everywhere
15:37:23 <bitemyapp> it's pretty annoying
15:37:27 <bitemyapp> reminds of me irccloud
15:37:42 <Tuplanolla> These days my C code is littered with `__attribute__ ((__pure__))`.
15:37:50 <Tuplanolla> Thanks, Haskell.
15:38:01 <maerwald> Tuplanolla: that's not in the C spec though, afair :P
15:38:06 <monochrom> Me, these days I replace C by Haskell. :)
15:38:09 <maerwald> so a compiler-ism
15:38:24 <iqubic> Tuplanolla: what does that even mean?
15:38:35 <monochrom> For example http://lpaste.net/358634
15:38:45 <Tuplanolla> @google gcc common function attributes
15:38:46 <maerwald> Tuplanolla: but indeed, I use a *lot* of 'const' on function arguments, especially on pointers
15:38:46 <lambdabot> https://gcc.gnu.org/onlinedocs/gcc/Common-Function-Attributes.html
15:38:50 <maerwald> and people wonder why
15:39:19 <maerwald> but then they start to appreciate it
15:39:30 <maerwald> because they see it's also kind of documentation
15:40:12 <Tuplanolla> Man, I can't wait until TySan comes out.
15:40:55 <lambdamu_> maerwald: I had that with Rust, after writing some Rust you really hate that library documentation often isn't explicit about ownership, lifetime and mutability
15:40:56 <Tuplanolla> Then I can add `restrict` to the `const` litter without worrying about it.
15:41:08 <lambdamu_> maerwald: For C libraries
15:42:43 <suzu> there a guide on how to read servant typeclass instances?
15:42:52 <suzu> like wtf:
15:42:54 <suzu>  (KnownSymbol sym, ToHttpApiData v, HasLink k sub) => HasLink * ((:>) k * (QueryParam * sym v) sub)
15:43:33 <dmwit> Well, step one is probably to erase the tokens `k` and `*` everywhere. =P
15:43:39 <maerwald> lambdamu_: yes, I have a rust project that extensively depends on gtk+ bindings
15:43:54 <maerwald> it's easy to break your expecations of rust semantics with bindings
15:44:03 <hpc> HasLink (QueryParam sym v :> sub)
15:44:12 <suzu> how did you divine that?
15:44:31 <maerwald> and, interestingly... rust is even worse for C bindings than haskell!
15:44:42 <maerwald> because lifetimes really don't translate well to most C libs
15:44:56 <hpc> suzu: erase k and *, which are part of the kind signature and not actual parameters
15:45:13 <suzu> what are those and why are they there?
15:45:24 <suzu> i assume * means the kind *, or concrete type
15:45:30 <monochrom> suzu: Some knowledge about PolyKinds and what happens to haddock when you use PolyKinds
15:45:32 <hpc> yeah
15:45:36 <hpc> k means it's kind-polymorphic
15:45:36 <suzu> why is there a `k` hanging around?
15:45:47 <monochrom> k is a kind variable
15:45:57 <hpc> which is normally not useful until you're dealing with constraint or data kinds
15:46:09 <suzu> i see
15:46:48 <suzu> how about this?
15:46:49 <suzu> :: Enter typ m n ret => (:~>) * m n -> typ -> ret 
15:47:13 <suzu> that really means: Enter typ m n ret => (m :~> n) -> typ -> ret
15:47:14 <monochrom> This one I think you just ignore the "*"
15:47:15 <suzu> is that correct?
15:47:22 <monochrom> Yes
15:47:24 <hpc> yeah
15:47:33 <suzu> ok cool. thanks
15:47:35 <suzu> this was puzzling me
15:47:38 <lambdamu_> maerwald: Hm yeah, never worked with C from Rust, but what Rust made realize is that these concepts exist in C, too, just because you don't talk about them doesn't mean your memory hasn't a upper and a lower lifetime bound
15:48:09 <suzu> when i have to explain haskell code to the non-haskellers at work, i always have to sigh and put my face in my hands for a moment
15:48:24 <suzu> "this is um.. a monad except... except i used a transformer here so.. ugh oh god just forget it"
15:48:31 <lambdamu_> maerwald: That is a similar experience like I had with IO in Haskell and then going back to impure by default languages
15:48:33 <monochrom> Well servant uses something pretty advanced.
15:48:38 <hpc> suzu: take it one concept at a time
15:48:47 <suzu> i could if i had the time hpc 
15:48:56 <suzu> but yeah i have a free monad in production and such
15:49:01 <suzu> that was a.. while to explain
15:49:09 <hpc> suzu: there's two ways that have worked for me, one is to build up concepts incrementally and translate between languages
15:49:24 <hpc> this works nicely for getting someone to think in a functional way
15:49:29 <suzu> that's what i mostly do
15:49:31 <monochrom> explain servant : explain Haskell :: explain rocket science : explain newtonian mechanics
15:49:38 <suzu> we've got a lot of python and js around here
15:49:42 <hpc> suzu: the second is to just write haskell like it's python, do-blocks everywhere and very imperative style
15:49:44 <suzu> i've found a lot of analogs for explaining things
15:49:57 <suzu> the interfaces i've exposed to the other programmers look like that lol
15:50:09 <suzu> under the hood it's a free monad used for imperative scripting
15:50:10 <hpc> which also works nicely, because then you can blow their minds with stuff like forkIO and custom "control flow" operators like forever
15:50:29 <suzu> forkIO bad! use async!
15:50:33 <hpc> heh
15:50:41 <suzu> though i'm using forkIO
15:50:55 <suzu> async was swallowing exceptions somewhere and i didnt have the time to figure out why
15:50:57 <monochrom> You don't have to explain free monad. You just have to explain EDSL. Your free monad is just another EDSL.
15:51:14 <suzu> yes, that's how i explained it. at first
15:51:17 <hpc> i like using forkIO and MVar/Chan because it has a nice mix of traditional style and message-passing
15:51:20 <suzu> then they ask, "How did you do this?"
15:51:31 <hpc> and the primitives are so good that i don't feel like i am missing out
15:51:32 <suzu> and then you have to choose how many doses of the haskell red-pill you're going to show
15:51:45 <suzu> actually that's a good analogy
15:51:47 <monochrom> Oh, I would just answer "I learned it from #haskell"
15:51:54 <suzu> i feel like haskell is really the red pill of programming
15:52:15 <suzu> i screw around with categories and nonsense but somehow end up writing software. lol
15:52:43 <suzu> hpc: i have exactly that setup on this project
15:53:18 <suzu> web endpoint that spin off new workers, and another to push messages to the right workers with channels
15:53:20 <suzu> it is nice :)
15:53:45 <monochrom> You're at this crossroad position where you could either ruin Haskell's reputation or make it shine, to your colleagues.
15:53:54 <monochrom> The trick is to learn from the infomercials.
15:54:20 <monochrom> If you actually answer their questions directly, i.e., explain your theoretical thought process to them, you lose, you ruin it.
15:54:34 <monochrom> Instead, it is always suspense that turn people on.
15:54:47 <suzu> i think i will put on a proper talk
15:54:47 <hpc> suzu: write haskell at two extremes - short scripty miracle language-extensiony nonsense that proves a concept in less than 100 lines
15:54:51 <suzu> a two part series
15:54:54 <monochrom> You should just say "I learned some theory and applied it, but it's a long story".
15:54:57 <hpc> suzu: and much more boringer "looks like normal code" haskell
15:55:01 <suzu> one where i will not actually teach them any haskell but just blow their mind with cool things
15:55:10 <monochrom> Or my simpler "I learned it from #haskell".
15:55:25 <suzu> and then a second one where i'll explain some things i guess
15:55:30 <hpc> as long as you only have a small amount of magic per 10-lines or so of code, it'll just look like a language with unfamiliar syntax
15:55:42 <monochrom> Don't teach them. But keep showing off until they want to learn. Then point them where to learn, i.e., still don't teach them.
15:56:06 <suzu> that is clever
15:56:09 <suzu> i think i will do that
15:56:11 <hpc> this works best with "DSL style" code, where you do a tiny bit of magic in a couple of functions to make a sub-language that does something useful
15:56:17 <monochrom> I learned it from infomercials.
15:56:17 <hpc> and then you write boring code with those as primitives
15:56:18 <suzu> this whole app is a DSL
15:56:26 <suzu> just a whackload of DSLs
15:56:28 <suzu> they love it
15:56:55 <monochrom> For example the informercial in which Tony Robbin or whatever he's called keep telling you that his lesson teaches you how to become rich.
15:57:05 <suzu> oh yes
15:57:17 <suzu> let me tell you repeatedly what i'm going to tell you
15:57:24 <monochrom> And the infomercial only ever shows you witnesses of "I took his lessons and I made $xxx".
15:57:24 <suzu> but then, not
15:57:37 <monochrom> Never ever even give a hint of what's in the lessons.
15:57:48 <suzu> "you will become a 10x engineer in three easy steps"
15:58:00 <monochrom> So call 1-800-xxx-yyyy and pay $50 for the lesson package CALL NOW
15:58:01 <suzu> well ideally i'd like to infect the eng team here with haskell
15:58:07 <mmaruseacph2> I never believed those to be true
15:58:13 <suzu> but uh
15:58:15 <hpc> suzu: if you can translate your haskell skills effectively to other languages, you can pull a bit of a magic trick
15:58:23 <suzu> honestly speaking i don't know if all the talent here is capable of writing it
15:58:51 <suzu> i think haskell is more difficult than mainstream languages, and our python/java codebase is a fucking mess to be honest
15:58:51 <exio4> why not?
15:58:57 <suzu> javascript*
15:59:13 <exio4> I found Haskell to be the opposite of difficult - it's actually easier, because the compiler is doing half the work
15:59:21 <EvanR> "haskell is more difficult..." is really an enigmatic sentiment to me
15:59:29 <suzu> i hear that a lot, but i certainly think learning haskell is difficult
15:59:42 <hpc> suzu: where you wait for something difficult, and then restructure the problem for them so it looks trivial just by thinking in a different direction
15:59:42 <suzu> call me contrarian
15:59:50 <EvanR> difficult to write working code in? difficult to understand the operational semantics? difficult to pronounce?
16:00:05 <hpc> and cap it off with "think in this language and look how easy these things are"
16:00:06 <suzu> difficult to learn how to write
16:00:06 <EvanR> because i can name some mainstream languages which fail some of those
16:00:26 <EvanR> ruby, 99% easier to write code that doesnt even load
16:00:32 <exio4> EvanR: which mainstream language is difficult to pronunce? :D
16:00:32 <suzu> yup
16:00:37 <monochrom> I also say that Haskell is more difficult.
16:00:41 <suzu> you can write all sorts of nonsense in ruby
16:01:07 <monochrom> Well, actually, more difficult if you want your first lesson to be "how to interact with the user".
16:01:20 <monochrom> If your first lesson is "how to do binary search trees" it's a breeze.
16:01:26 <suzu> i think the first lesson really does need to be something on the lines of writing _software_ tbh
16:01:50 <EvanR> once you get into the python shell and probably get rewarded with simple results, you now have a lifetime of difficulty ahead of you getting it to work...
16:01:59 <monochrom> But who wants binary search trees for their dive-in projects these days? Everyone wants a pony webapp.
16:02:00 <suzu> sure. but it feels constructive
16:02:08 <EvanR> i guess theres that
16:02:12 <suzu> in haskell you put the straightjacket on first
16:02:30 <EvanR> i have come to feel way more constructive in haskell, way before even getting the program to run
16:02:48 <suzu> only after the fact can you realize how much this backwards-ass language has helped you, after realized you have not been having to run and ctrl-c your program 600 times in the last hour to find a bug
16:03:26 <Tuplanolla> Step up the challenge with "how to target low-memory devices".
16:03:44 <suzu> is haskell even a good fit for that?
16:03:51 <suzu> i would, for instance, never write a mobile app in haskell
16:03:57 <suzu> or do data-science with it
16:04:57 <nicknight> suzu: why not data science?
16:05:38 <suzu> i feel like haskell is too immature in relation to pandas/numpy/ipython/other-ds-ecosystem-stuff
16:06:15 <suzu> i feel similarly about the mobile app dev ecosystem
16:10:25 <nicknight> ok upto you :)
16:16:23 <suzu> :)
16:45:25 <ryantm> What HTML parsing library do people like to use these days?
16:49:09 <adelbertc> is there a way i can view code generated from TemplateHaskell? I've managed to get a hold of a `Q [Dec]` but can't print it. I tried doing `expr <- runQ $ ...` but then i get "Template Haskell error: Can't do `addDependentFile' in the IO monad"
16:49:34 <ryantm> https://stackoverflow.com/questions/15851060/ghc-ddump-splices-option-template-haskell
16:54:32 <adelbertc> hm so should i be doing
16:54:41 <adelbertc> `cabal build --ghc-options="-ddump-splices"` ?
16:56:29 <MarcelineVQ> I'd be inclinded to add -fforce-recomp as well when examining generated things, to be sure it's actually building the thing you want to look at
16:58:24 <adelbertc> ah good call
16:58:26 <adelbertc> recompiled
16:58:31 <adelbertc> though its nowhere to be seen
16:59:08 <adelbertc> the entirety of my file is basically: `module Main where Data.Avro.Deriving.deriveAvro "tree.avsc"; main = putStrLn "Hello"`
16:59:19 <adelbertc> and i want to see what `deriveAvro "tree.avsc"` generates
17:03:50 <ryantm> adelbertc: I think you can use ddump-splices from GHCI too.
17:04:09 <adelbertc> thats what i tried, but it gives me "Template Haskell error: Can't do `addDependentFile' in the IO monad"
17:04:20 <adelbertc> hold on..
17:04:42 <adelbertc> oh woa
17:04:43 <adelbertc> it just worked
17:04:45 <adelbertc> interesting.
17:10:49 <adelbertc> ryantm: thanks for your help!
17:47:30 <centril> Is it accurate to say that Haskell popularized the concept of  "typecheck first, implement later" ?
17:50:04 <jb55> ryantm: re: html parsing, I use taggy-lens
17:51:08 <ryantm> jb55: thanks. I always amazes me that haskell libraries that haven't been updated in 3 years still work well.
17:52:58 <jb55> ryantm: here's an example function I have that gets the value of a crsf token on the page: https://gist.github.com/jb55/9f3e8c8d95818bb9d3cb1f12c9822e22
17:53:13 <jb55> lens + xml = fun
17:53:36 <ryantm> nice :)
17:54:12 <centril> jb55: xml is the opposite of fun ;)
17:54:27 <jb55> centril: lens makes it bearable 
17:54:53 <centril> jb55: that's a much lower bar :P
17:56:49 <Divesh> Hi is anyone familiar with compiler development on? I want to know of a search engine thing that I could look up data types on.
17:57:07 <Divesh> Specifically for GHC.
18:03:12 <Axman6> alike hoogle?
18:03:16 <Axman6> like*
18:04:55 <geekosaur> @where hoogle
18:04:55 <lambdabot> http://haskell.org/hoogle http://fpcomplete.com/hoogle – See also Hayoo, which searches more packages: http://hayoo.fh-wedel.de/
18:05:19 <geekosaur> although... that points to hoogle v4 which does fuzzy type search but may not have an up to date database
18:05:35 <geekosaur> hoogle.haskell.org is hoogle v5 which is up to date and can search more packages, but fuzzy type search is broken
18:05:57 <geekosaur> hayoo does fuzzy name search that hoogle doesn't, but is not very good at fuzzy type search
18:06:30 <geekosaur> (suspect ndm would be grateful for help getting hoogle5 back up to snuff)
18:46:38 <sqooq> ugh, i'm doing something in gnu octave since it has prebuilt functions for dsp work
18:46:53 <sqooq> but now that I want to like abstrakt it into something I can use and have things be automated
18:47:01 <sqooq> I'm running into so many problems
18:47:21 <sqooq> and feel the language is weak for easily doing some things
18:47:46 <sqooq> But at the same time, I'd have to go scouring the haskell libraries for these functions which may or may not exist
18:48:20 <sqooq> Anyone in here do digital signal processing in haskell by chance? Really I just need a kaiser window resampling function. I refuse to write my own, that would be a lot of work.
18:50:13 <sqooq> Hmm I wonder if interpolation will fare?
18:50:45 <sqooq> Honestly windowed resampling causes all these ripples and stuff which are negligible but my function works on negligible regions anyways so
18:50:55 <sqooq> interpolation might work better
18:58:12 * JappleAck just released /me just released https://hackage.haskell.org/package/qm-interpolated-string-0.2.0.0
19:02:44 <rudol> This negamax impl (demonstrating use of Reader) compiles, but could it actually work? How would Game's getState know what negamax wants First/SecondPlayer (re Win state) to mean?   https://stackoverflow.com/a/14179721
19:13:51 <rudol> ... and, more importantly, would you say this is sensible/typical use of the Reader Monad? I would have probably looked at State first, but I suppose if the author feels Reader does what he needs, there's no need for State extra abilities.
19:29:17 <rudol> it's also a little confusing that this negamax at https://stackoverflow.com/a/14179721 is using "color" to represent both the player to move (first Double param) and rating/value/fitness of a move (2nd type param of Reader). 
19:33:27 <rudol> since the players (and hence node/position valuations) are already signed (ie always represent utility from the perspective of one player) then maybe another problem is the liftM negate, which seems unnecessary. Am I misinterpreting how that code should work?
20:27:06 <slack1256> what do superclasses enforce? I only see them for certain laws to make sense
20:28:33 <filthy_causual2_> test
20:31:22 <filthy_causual2_> Hey so if I want to pass Prob ("type Prob = Map a Rational") into say a data constructor NM ( "data NM t a where [...]")  I have to make it a "data" or newtype, yes?
20:31:30 <Axman6> slack1256: they're a statement that the properties of that class are expected to include all the properties of the super class - All Monads are Applicatives, and all Applicatives are Functors
20:31:40 <geekosaur> slack1256, they don't really enforce anything as such. they express that some abstraction is an extension of another (e.g. Monoid is a Semigroup plus an identity; the expression of this in Haskell is currently only partial but should be complete in ghc 8.4)
20:32:23 <Axman6> filthy_causual2_: nope, "type" just gives a new name to another type. you could have a field of tyoe Prob. That type won't work though, since a isn't mentioned on the left
20:33:07 <slack1256> geekosaur: in what sense will be complete in 8.4 ? do you have some trac page at hand?
20:33:45 <geekosaur> https://ghc.haskell.org/trac/ghc/ticket/14191
20:33:53 <filthy_causual2_> Gah, two typos in one message. s/Prob =/Prob a =/ and s/a data constructor /a type constructor /. >.<
20:34:31 <Axman6> filthy_causual2_: can you reask the question with those corrections made? =)
20:34:39 <filthy_causual2_> Hey so if I want to pass Prob ("type Prob a = Map a Rational") into say a typeconstructor NM ( "data NM t a where [...]")  I have to make it a "data" or "newtype", yes?
20:37:13 <filthy_causual2_> hu..actually it seems to work if I just don't try to layer over another "type" declaration.
20:38:31 <geekosaur> filthy_causual2_, one thing to watch out for there is there are ways to make that 'Prob a' typo give you a hidden existential, and then you try to use it and discover the existential won't unify across uses
20:38:59 <filthy_causual2_> Thanks, that sounds really confusing.
20:41:38 <slack1256> geekosaur: I just read the trac. I though it was an completion of the superclass constrain mechanism
20:42:20 <geekosaur> slack1256, as I understand it one problem with the current setup is <> has to be duplicated in both Semigroup and Monoid, because the Semigroup one won;t typecheck if used on a list
20:42:41 <geekosaur> (in fact someone in another channel just ran into a variant of that one...)
20:42:58 <slack1256> oh so the *do* help with type checking
20:43:51 <geekosaur> they do, but this is more a sort of weak spot in Haskell types that doesn;t match the mathematical intuition
20:43:59 <geekosaur> oor at leats in how it was being expressed as Haskell types
20:44:47 <geekosaur> 'superclass' is something of a misnomer anyway; a better name for what they actually do in the typechecker is 'prerequisite'
20:45:30 <geekosaur> (for example 'superclass' doesn;t allow the hack for AMP backward compatibility where you can define the Applicative in terms of Monad's ap and return)
20:46:22 <geekosaur> (because in the 'superclass' model you'd be using a subclass to define the superclass)
20:46:36 <slack1256> yeah that was an itch I had with the mechanism. What did actually enforce and buy us
20:46:52 <slack1256> I've been playing with passing dictionaries by hand
20:47:41 <slack1256> I can make composite instances of Functors, Applicative as pure functions yet I wasn't modelling the superclass constrains and I was not losing anything (it seemed)
20:47:59 <geekosaur> Applicative -> Monad is arguably just a convenience. the real point is Functor -> Applicative; consider that Monad had to define its own version of fmap (liftM)
20:52:36 <geekosaur> a bunch of normal Monad things actually need fmap, but you couldn't get fmap from just Monad so Monad had to 'derive' fmap from (>>=) and then use that derived one to implement other things. silly duplication.
20:55:16 <slack1256> yeah but it was just a one off duplication
20:55:34 <slack1256> also, it was a law-abiding code that was duplicated :-)
21:14:31 <Skm> Hi, how can I map the '/' operator to two lists eg map (/) [16,9,4] [4,3,2] to get result ie [4,3,2]
21:14:59 <c_wraith> Skm: you want zipWith
21:15:13 <c_wraith> :t zipWith
21:15:15 <lambdabot> (a -> b -> c) -> [a] -> [b] -> [c]
21:16:30 <saurabhnanda> how to pass extra args to `stack ghci`?
21:20:11 <Skm> c_wraith: thank for your help.
21:32:28 <jchia1> I'm trying to understand some details about pattern matching. Why does is f2 bottom but not f1? http://lpaste.net/359392 Shouldn't f1 also get a pattern match failure?
21:36:50 <jle`> jchia1: check out how pattern matching in do notation gets desugared
21:37:30 <jle`> jchia1: it's basically desugared as m >>= \case (_:xs) -> ...; _ -> fail
21:37:50 <jle`> er, fail "something"
21:37:56 <jle`> and fail for Maybe is const Nothing
21:39:25 <alexbrown> Hi all
21:39:57 <olligobber> o/
21:43:19 <jchia1> jle`: OK, I wasn't aware of the '_ -> fail' part. That explains. Why is it needed, though? Why can't they just let the user have an irrefutable pattern?
21:44:28 <jle`> this is actually a part of do notation that a lot of people take advantage of 
21:44:31 <jle`> it's one of the "features"
21:46:14 <woodson_> can guide a bit here? I am trying to read a csv file and replace a column with new data I tried looking at the System.IO but it seems like i would have to read the whole file and find the column i want and rewrite the whole content in the file
21:46:41 <woodson_> is there a way for to replace only a specific line a file
21:47:03 <woodson_> a code example would be appreciae
21:47:09 <woodson_> appreciated*
21:47:51 <alexbrown> I'm following this series to learn Haskell and stucked with `repeatN` function. Can anybody help me? this is my code https://dpaste.de/J2ma
21:47:56 <jchia1> woodson_: You could read the whole file into a list or some other sequence type, change one of the elements, and then write back the lines. You could code your own reading and writing functionality or use something like cassaa.
21:47:58 <jchia1> cassava.
21:49:27 <jle`> alexbrown: what do you think `repeatN 5 []` returns
21:50:42 <alexbrown> jle`: I think it return a list [0, 0, 0, 0, 0]
21:50:49 <jle`> where did the 0 come from?
21:51:10 <jle`> no zero ever shows up in the definition :)
21:51:45 <jle`> how about a simpler example... what does repeatN 5 "hi" return?
21:51:56 <jchia1> alexbrown: Follow the type definition of repeatN and figure out the type of the return value
21:51:59 <jle`> if you're in doubt, just look at the definition
21:52:08 <jle`> repeatN 0 x = []
21:52:22 <jle`> repeatN n x = x : repeatN (n - 1) x
21:52:32 <jle`> so which of those cases does repeatN 5 [] fall into ...?
21:53:16 <alexbrown> I'm following this series http://learn.hfm.io/recursion.html
21:53:23 <jle`> sure
21:53:31 <jle`> do you know how to read that function definition?
21:53:47 <jle`> are you familiar with function definition in haskell?
21:54:06 <jle`> and how function evaluation works?
21:54:34 <alexbrown> I just learn Haskell from yesterday.
21:54:36 <jle`> for something like 'myFunction x = ....', then 'myFucntion []' would be the '....', but with every occurrence of 'x' replaced with []
21:54:39 <alexbrown> So it every new
21:54:43 <jle`> so let's give an example, square x = x * x
21:54:51 <jle`> if i called square 5, that would be evaluated to 5 * 5
21:55:03 <jle`> i take the body (x * x) and replace every 'x' with 5, to get 5 * 45
21:55:07 <jle`> sorry, 5 * 5
21:55:45 <alexbrown> jle`: Great
21:55:56 <jle`> so, in your case, you have 'repeatN n x = x : repeatN (n - 1) x'
21:55:57 <woodson_> jchia1: Thats what I thought, but is there a possibly to open to file find the line that i want to modify and just replace the data without having to write the whole content again?
21:56:08 <jle`> alexbrown: can you see how repeatN 5 [] would evaluate?
21:56:18 <jle`> n is 5, and x is []
21:56:25 <alexbrown> yes
21:56:31 <jle`> so it'd take the body ---  x : repeatN (n - 1) x  --- and replace n with 5, and x with []
21:57:04 <jle`> so repeatN 5 [] is [] : repeatN 4 []
21:57:23 <jle`> and repeating the process again, it's [] : ([] : repeatN 3 [])
21:57:34 <jle`> and again, it's [] : ([] : ([] : repeatN 2 []))
21:57:48 <alexbrown> oh,... I see
21:58:07 <jle`> and again, [] : [] : [] : [] : [] : []
21:58:17 <alexbrown> jle`: How can i fix it?
21:58:28 <jle`> which is [[],[],[],[],[]]
21:58:40 <jle`> similarly, repeatN 5 "hi" is ["hi", "hi", "hi", "hi", "hi]
21:59:02 <jle`> your repeatN is defined correctly
21:59:12 <jle`> but the problem here is that haskell's print can only print monomorphic values
21:59:25 <jle`> it can print [Int], [Bool], [[Int]], etc.
21:59:46 <alexbrown> oh, great. many thanks jle` 
21:59:56 <jle`> alexbrown: so the type of repeatN 5 [] is... what?
22:00:05 <jle`> it's [[something]]
22:00:11 <jle`> but Haskell needs a specific something there
22:00:25 <jle`> this is because every type is "printed" in a different way, according to its typeclass instance
22:00:40 <jle`> so the choice of what type is in the list could potentially affect how it is printed
22:00:41 <filthy_causual2_>  is foldl' really not in the prelude?
22:00:54 <jle`> so you have to tell Haskell what the type of your list is, so Haskell knows what Show instance to use
22:00:58 <jle`> so it knows what to print
22:01:32 <jle`> one way to fix it would be to do print (repeatN 5 [] :: [[Int]])
22:01:39 <jle`> or give it a monomprhic value, like print (repeatN 5 True)
22:01:48 <jle`> repeatN 5 True is unambiguously [Bool]
22:02:01 <jle`> but `repeatN 5 []` is a polymorphic value
22:02:02 <alexbrown> jle`: great, i've changed the call to repeat 5 0 it work well.
22:02:17 <jle`> yeah, the issue is that [] is a polymorphic value
22:02:29 <jle`> 0 is as well, actually, but Haskell is happy to pick a "default" type
22:02:30 <filthy_causual2_> > print (repeatN "") -- "" is another way to make it less polymorphic.
22:02:32 <lambdabot>  error:
22:02:32 <lambdabot>      • Variable not in scope: repeatN :: [Char] -> ()
22:02:32 <lambdabot>      • Perhaps you meant one of these:
22:02:47 <jle`> or print (repeatN 5 ([] :: [Int])), etc.
22:03:13 <alexbrown> jle`: you're my hero :D 
22:03:30 <jle`> no problem, hope you have a good rest of your experience with Haskell :)
22:03:43 <filthy_causual2_> > print (replicate 5 "") -- "" is another way to make it less polymorphic. And shows that  the inner type is actually needed.
22:03:45 <lambdabot>  <IO ()>
22:03:54 <alexbrown> Haskell is awesome, I think i need rethink everything i know :D
22:03:55 <filthy_causual2_> > show (replicate 5 "") -- "" is another way to make it less polymorphic. And shows that  the inner type is actually needed.
22:03:58 <lambdabot>  "[\"\",\"\",\"\",\"\",\"\"]"
22:04:22 <filthy_causual2_> Ah right. Its escaped.
22:04:47 <jle`> > replicate 5 ""
22:04:49 <lambdabot>  ["","","","",""]
22:08:18 <roi_du_silence> >concat $ replicate 5 ""
22:08:45 <roi_du_silence> I do not control the lambdabot.
22:12:40 <geekosaur> the space isn't optional
22:13:32 <roi_du_silence> > putStrLn "I like my space"
22:13:37 <lambdabot>  <IO ()>
22:13:45 <roi_du_silence> ha
22:22:40 <pacak> % putStrLn "Hey"
22:22:41 <yahb> pacak: Hey
22:27:03 <iqubic> pacak: that's cool
22:27:14 <iqubic> How do you read a file in haskell?
22:27:21 <Axman6> readFile
22:27:23 <jle`> readFile
22:27:25 <jle`> aw man
22:27:33 <iqubic> % readFile Gandalf
22:27:34 <yahb> iqubic: ; <interactive>:5:10: error: Data constructor not in scope: Gandalf :: FilePath
22:27:36 <Axman6> % readFile "/etc/passwd"
22:27:36 <yahb> Axman6: *** Exception: /etc/passwd: openFile: does not exist (No such file or directory)
22:27:43 <iqubic> % readFile "Gandalf"
22:27:44 <yahb> iqubic: "YOU SHALL NOT PASS"
22:28:01 <iqubic> I wrote that the other day while messing around.
22:28:05 <Axman6> % eshell "pwd; ls"
22:28:06 <yahb> Axman6: ; <interactive>:8:1: error: Variable not in scope: eshell :: [Char] -> t
22:28:10 <Axman6> % shell "pwd; ls"
22:28:10 <yahb> Axman6: ; <interactive>:9:1: error: Variable not in scope: shell :: [Char] -> t
22:28:15 <Axman6> :(
22:28:20 <iqubic> Axman6: just use %!
22:28:23 <iqubic> %! ls
22:28:24 <yahb> iqubic: 1; DO_NOT_READ.md; Gandalf; README.md; hello.lua; kaboom.sh; repeat.sh; t.lua; t.sh; test; test.lua; пидор
22:28:42 <iqubic> %! cat DO_NOT_READ.md
22:28:43 <yahb> iqubic: why
22:28:57 <Axman6> % readFile "kaboom.sh"
22:28:57 <yahb> Axman6: ":(){ :|: & };:"
22:29:21 <iqubic> It's a for bomb
22:29:28 <iqubic> Time to try a thing.
22:30:06 <iqubic> %! :(){ :|: & };:
22:30:07 <yahb> iqubic: bash: fork: Operation not permitted; bash: fork: Operation not permitted; bash: fork: Operation not permitted; bash: fork: Operation not permitted; bash: fork: Operation not permitted; bash: fork: Operation not permitted; bash: fork: Operation not permitted; bash: fork: Operation not permitted; bash: fork: Operation not permitted; bash: fork: Operation not permitted; bash: fork: Operation not permitted; bash
22:30:19 <iqubic> %! ls
22:30:19 <yahb> iqubic: 1; DO_NOT_READ.md; Gandalf; README.md; hello.lua; kaboom.sh; repeat.sh; t.lua; t.sh; test; test.lua; пидор
22:30:27 <iqubic> That is good.
22:54:53 <dminuoso> Are there real world examples of covariant functors in programming?
22:56:04 <pacak> covariant functor = regular functor.
22:56:39 <dminuoso> And when I say covariant I mean contravariant.
22:56:43 <dminuoso> ;)
22:57:42 <cocreature> dminuoso: Predicate is a fairly common one https://hackage.haskell.org/package/contravariant-1.4/docs/Data-Functor-Contravariant.html#t:Predicate
22:58:14 <cocreature> hasql uses it for encoders https://hackage.haskell.org/package/hasql-1/docs/Hasql-Encoders.html#t:Params
23:00:17 <dminuoso> cocreature: That's interesting, not what I expected.
23:00:43 <cocreature> dminuoso: the more general form of this is https://hackage.haskell.org/package/contravariant-1.4/docs/Data-Functor-Contravariant.html#t:Op
23:00:52 <cocreature> so functions with flipped type variables
23:16:33 <sinsnare> Hi, I am trying to use SDL to get this function to work, but I am having some issues, can anyone take a look at this? http://lpaste.net/359397
23:17:22 <sinsnare> it doesnt like the lists trying to be a monad i think. I found the function on SO in C++, and tried to convert it
23:17:51 <sinsnare> and this is the SO post if you think there is a better way: https://stackoverflow.com/a/41902448/1294262
23:19:40 <geekosaur> sinsnare, <- performs an action in a monad. for something pure like that, you use let
23:19:49 <geekosaur> like on lines 8 and 9
23:20:11 <sinsnare> But I want it to iterate thru every element like it would in a do block
23:20:27 <sinsnare> like the double for loop in C++
23:20:43 <jcarpenter2> look up mapM, that's what you should use here to apply an IO action to each element of the arrays
23:20:46 <cocreature> sinsnare: you’re using do for IO not for []
23:20:47 <geekosaur> you can't mix monads like that. there are monad transformers, but that's the wrong solution here
23:21:02 <sinsnare> will using a let binding do what i want it to do?
23:21:03 <geekosaur> and yes, the idea here is mapM, or the flipped version forM
23:21:19 <cocreature> mapM_ should work as well
23:21:28 <geekosaur> actually even more specifically you want mapM_ or forM_ because you aren't catching results, just performing actions
23:23:02 <geekosaur> the difference between mapM and forM (or mapM_ and forM_) is that one is mapM action list but the other is forM list action; which is more convenient depends on how large the action is, or sometimes on whether you're composing it into something larger
23:23:19 <geekosaur> (but in a do block the composition is 'in the background' so that's usually not an issue)
23:24:40 <sinsnare> I may be misunderstanding.. I should have 2 forM_'s nested so that way I can iterate thru both lists like a for loop?
23:25:12 <jcarpenter2> correct
23:25:45 <sinsnare> but not inside the do block? How would I do the computations that still need to do block?
23:26:00 <cocreature> sinsnare: you can also do "forM_ [(w,h) | w <- [0..100], h <- [0..100]] $ \(w,h) -> …"
23:26:04 <geekosaur> thye are inside the do block. an the M suffic expresses that it does something in the do blocks monad
23:26:31 <sQVe> I'm looking to dive into haskell and would love some recommendations on good resources. I've been glancing at haskellbook.com - is it worth buying?
23:26:47 <geekosaur> let's try that one again :/ they are inside the do block. and the M suffix expresses that it does something in the do block's monad
23:27:20 <cocreature> sQVe: I’ve heard a lot of people that have read it say it is worth buying but I haven’t read it myself.
23:27:23 <cocreature> @where learnhaskell
23:27:23 <lambdabot> https://github.com/bitemyapp/learnhaskell
23:27:30 <cocreature> ^ sQVe that’s probably also worth a look
23:27:53 <geekosaur> the action you give to forM/mapM (or _ variants) is an action that could be used by itself in the do block. that action is iteratively applied over the list
23:28:12 <geekosaur> with the current list value passed as a parameter
23:28:54 <sQVe> cocreature: Awesome! Cheers for that.
23:29:27 <sQVe> Is learn you a haskell any good? 
23:29:34 <sQVe> It's available for free online so.
23:30:43 <cocreature> sQVe: I liked it as an introduction but it’s more useful for getting you interested in Haskell than teaching you Haskell up to a point where you feel confident writing real applications.
23:30:51 <geekosaur> it's mor of a grand tour. unless youy get exercises from somewhere else or something, you willmaybe be able to read Haskell code, but not necessarily write it
23:31:31 <sQVe> cocreature: :thumbs-up: I haven't been this excited learning a new language in like... forever.
23:32:05 <sinsnare> Ok it works! thanks geekosaur, I used forM_ and it works great
23:32:07 <sQVe> Been diving into fp land heavily in JS and this is pretty much the natural next step.
23:32:48 <cocreature> sQVe: just make sure you’re aware that while it might be a natural step it’s also a pretty big step so don’t get discouraged if things seem confusing at first :)
23:33:32 <cocreature> we’re here to help if you get stuck
23:33:54 <sQVe> cocreature: I've already started a bit and I understand that it's going to be a journey. 
23:34:51 <sQVe> That's one of the things that actually makes it more fun - compared to learning yet another imperative language like go.
23:35:10 <macrover> 2017-10-19 23:20 <sinsnare> will using a let binding do what i want it to do?xk
23:51:09 <saurabhn_> how to pass command-line args to ghci via `stack ghci`?
23:52:35 <epta> --ghci-options OPTIONS   Additional options passed to GHCi
23:55:39 <saurabhn_> epta: how did you get that doc?
23:55:39 <ij> Could anyone take a look at why my megaparsec(5.2) toy sed parser won't allow ommiting an optional when sepBy1'ing? A bit of tests, parsers and output: http://sprunge.us/ciiX
23:57:33 <MarcelineVQ> saurabhn_: stack ghci --help
23:58:24 <saurabhn_> aaargh... I was trying stack --help ghci
23:58:24 <saurabhn_> thanks.
