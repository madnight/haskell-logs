00:03:50 <saurabhnanda> how exactly does one pass -fprint-potential-instances in intero or GHCi?
00:06:20 <cocreature> :set -fprint-potential-instances?
00:07:15 <saurabhnanda> thanks!
00:44:53 * hackagebot colorless 2.2.18 – Colorless | The Programmatic IDL – https://hackage.haskell.org/package/colorless
01:00:16 <`Guest00000> @let pattern P1 = Nothing
01:00:17 <lambdabot>  .L.hs:183:9: error:
01:00:17 <lambdabot>      Not in scope: data constructor ‘P1’
01:00:17 <lambdabot>      Perhaps you meant variable ‘_1’ (imported from Control.Lens)
01:19:48 <kuribas> I think part of the failure of static types is the false premisse that static typing reduces bugs.
01:20:45 <kuribas> (I mean failure of adoptation)
01:21:39 <maerwald> kuribas: I rarely hear haskellers admit this
01:22:41 <kuribas> yeah.  The real advantage IMO is that it makes finding bugs much quicker, and making programs easier to maintain.
01:24:22 <maerwald> To me, a static type system is the easiest step towards a full program verification language/process/workflow of doing software. But it's a rather small step too and not to be confused with actual program verification (which does reduce bugs :>)
01:25:34 <maerwald> so it only makes sense to embrace this step
01:25:55 <DigitalKiwi> I mean if you really want to make a duck bark you can do it in any language....but if the compiler makes it that much harder for me to do it on accident...
01:26:35 <kuribas> dynamic languages can be made bugfree by extensive testing, but I find it a very inefficient, since tests may run a long time, error messages can be confusing.
01:28:05 <DigitalKiwi> and if you really wanted to you could write any program with brainfuck, but at some point you say "isn't there a better way??"
01:28:10 <maerwald> I don't think testing can make a system bugfree, it would have to be an actual proof (inlcuding memory, not just codepaths)
01:28:33 <kuribas> maerwald: yeah, not bugfree, but less buggy 
01:28:41 <kuribas> but it's the same in haskell
01:29:01 <maerwald> I agree. I've written tons of bugs when implementing computational gemoetry algorithms in haskell
01:30:04 <DigitalKiwi> I've never seen someone claim haskell keeps you from writing incorrect programs :|
01:30:07 <kuribas> maerwald: yeah, me too.  But then that area and binary file formats aren't exactly where static types can do their best.
01:30:32 <kuribas> DigitalKiwi: many people do
01:30:53 <kuribas> "if it typechecks, it works"
01:31:01 <DigitalKiwi> more that you're less likely to write a seemingly correct incorrect program that you would in another type system
01:31:03 <DigitalKiwi> I've only ever seen that said in satire
01:31:05 <merijn> It depends on how you write code
01:31:28 <maerwald> you mean "it depends whether you write bugs", lol
01:31:34 <maerwald> everyone does
01:32:05 <DigitalKiwi> I don't 
01:32:41 <merijn> No, it depends on how much time you spend making illegal states irrepresentable
01:33:12 <maerwald> that's not the only source of bugs, I'm afraid
01:33:21 <DigitalKiwi> which states are illegal? Texas? I vote that one
01:34:38 <kuribas> maerwald: but I find eliminating the class of bugs which crash the program to be very convenient.
01:35:16 <kuribas> maerwald: my current cycle in python now is run the program, click through several GUI elements.  Fix a simple bug.  Go back repeat.
01:35:30 <maerwald> kuribas: weelll... exceptions crash my program and haskell doesn't tell me what exceptions are possible in a function ;)
01:35:45 <kuribas> maerwald: then avoid exceptions :)
01:35:52 <maerwald> in systems programming? :>
01:36:20 <kuribas> maerwald: create atomic operations which are proven to work?
01:36:29 <maerwald> like 'cp -r'? xD
01:36:51 <kuribas> you mean shell scripting?
01:36:55 <maerwald> no
01:37:02 <maerwald> recursive copying is implemented in haskell too
01:37:18 <maerwald> and it can throw a bazillion of different exceptions, since it's not atomic
01:37:27 <maerwald> is consists of several different syscalls
01:38:17 <kuribas> maerwald: well, in python they throw exceptions for everything, including pure code.
01:38:23 <maerwald> lol
01:39:28 <maerwald> https://hackage.haskell.org/package/Cabal-2.0.0.2/docs/Distribution-Simple-Utils.html#v:copyDirectoryRecursive
01:39:36 <maerwald> this is an utter joke
01:39:46 <kuribas> I've seen this "try pass argument; except ValueError: handle wrong argument", instead "if argument: pass argument; else handle wrong argument"
01:40:13 <maerwald> there is not even any documentation about the exceptions
01:40:27 <kuribas> maerwald: IO is a catch-all.  I also think it's better if the exceptions would be part of the type.
01:40:37 <kuribas> yeah, at least documentation
01:41:08 * maerwald switches to java
01:41:12 <osfameron> I'm sure I've seen a talk on system `cp` versus language libs (I think in Perl) where the conclusion was that the safest, most reliable thing is just to use system cp...
01:42:10 <kuribas> also: https://hackage.haskell.org/package/turtle :-)
01:42:15 <kuribas> maerwald: ^
01:43:23 <maerwald> kuribas: I've implemented my own versions :>
01:43:53 <merijn> kuribas: I've been trying to make a prototype functional language with checked exceptions
01:44:23 <merijn> But it keeps getting postponed due to not having time to work on it
01:44:29 <kuribas> merijn: couldn't you do something in haskell?  With advanced type hackery?
01:44:42 <maerwald> the problem is the term "type hackery"
01:44:50 <merijn> kuribas: No, don't think so
01:44:53 <maerwald> Koka has a good first approach imo
01:44:58 <merijn> kuribas: I think it has to be baked into the type system
01:44:59 <maerwald> you probably need row types too
01:47:48 <merijn> Do modules without a documentation link on Hackage still export things? i.e. GHC.Weak in base has no link to docs, but can I still import it?
01:48:01 <merijn> Or should I look a GHC.Prim for things in there?
01:56:58 <kuribas> what are the disadvantages of TH?  Does putting TH functions in a library (even when not used) restrict the library?
01:57:43 <merijn> kuribas: Compile times take longer, incremental compilation is less effective at avoiding recompiling and cross compilation becomes a PITA
01:58:26 <kuribas> merijn: what if the user uses only the non-TH functions?
01:58:43 <merijn> Then it should be fine, I think
01:59:37 <kuribas> right, thanks
02:01:05 <Athas> What's the most elegant way to obtain the bit-representation of a Float or Double as an Int32 or Int64 value?
02:09:34 <Cooler> can haskell be analyzed with klee?
02:09:43 <Cooler> haskell uses llvm backend right?
02:09:56 <Cooler> ghc uses*
02:11:03 <raichoo> You can use the llvm backend using -fllvm
02:15:14 <merijn> Cooler: GHC *optionally* uses an llvm backend, it's not the default
02:18:59 <merijn> I forget, which module exports the IO data constructor? Apparently not GHC.Exts
02:20:44 <Cooler> merijn: why not
02:20:49 <Cooler> why is it not the default
02:21:13 <merijn> Cooler: Because the default one performs better on average and the LLVM backend is...rather fiddly
02:21:33 <merijn> LLVM backend produces better numeric code
02:26:29 <MarcelineVQ> merijn: http://hackage.haskell.org/package/ghc-prim-0.5.1.0/docs/GHC-Types.html
02:28:16 <Cooler> anyone here use klee?
02:28:19 <Cooler> or llvm
02:31:29 <cocreature> Cooler: I maintain llvm-hs
02:32:56 <Cooler> cocreature: the llvm backend for ghs?
02:33:13 <cocreature> no LLVM bindings that you can use when you write your own compilers
02:33:30 <Cooler> ok
02:33:39 <Cooler> i need to install llvm 3.4
02:33:55 <cocreature> 3.4? that’s ancient :)
02:34:22 <Cooler> in order to build klee http://klee.github.io/build-llvm34/
02:37:51 <Cooler> llvm 3.4 isn't available on apt for ubuntu 16.04 lts
02:38:41 <cocreature> not surprised by that, I wasn’t kidding when I said it is ancient
02:39:14 <Cooler> current version is 5.0.0?
02:39:28 <cocreature> yep
02:58:25 <Itkovian> merijn I've tried the parMapM conduit thingie, but performance degraded from ~ 12s to ~ 18s using -N4 and mapping over 4 threads
02:59:00 <Itkovian> I think I'll just add concurrency earlier/later in the pipeline, relying on e.g., 0mq to allow me to process stuff more in parallel
03:18:40 <merijn> Itkovian: Could be, I didn't really design it for small short tasks
03:18:45 <Itkovian> :)
03:18:53 <Itkovian> but it looks nice anyway
03:18:55 <merijn> Itkovian: More for long blocking tasks :)
03:19:07 <Itkovian> yeah, that's not my area right now
03:19:12 <athan> What would be the proper way to create a `Ptr ByteString` for use with System.Posix.IO.fdReadBuf? I don't think I should use a Foreign.Ptr.nullPtr :x
03:19:36 <merijn> Itkovian: But at least it worked, so I'm happy with that :>
03:20:27 <merijn> Now I just need to fix my tests failing due to people messing up my transitive dependencies >.<
03:22:01 <Itkovian> well, I think it worked :)
03:22:07 <Itkovian> the types checked out
03:23:12 <merijn> Itkovian: Yeah, it's only broken on some specific combination of GHC and transformers...
03:23:54 <Itkovian> To be honest, I did spend two hours looking as to why it complained, only to find I had imported it qualified, so it was looking to use another parMapM ...
03:23:59 <Itkovian> and the build failed
03:24:21 <Itkovian> In my defense, it was past midnight and I had not had much sleep :)
04:16:12 * hackagebot log-warper 1.3.3 – Flexible, configurable, monadic and pretty logging – https://hackage.haskell.org/package/log-warper
04:49:13 <stevenxl> Hi folks. Where would you recommend I go for an explanation of monadio?
04:59:42 <osfameron> itsa me, monadio!
05:02:33 * hackagebot postgres-embedded 0.1.6 – Library for easily running embedded PostgreSQL server for tests – https://hackage.haskell.org/package/postgres-embedded
05:07:36 * hackagebot ghc-typelits-natnormalise 0.5.4 – GHC typechecker plugin for types of kind GHC.TypeLits.Nat – https://hackage.haskell.org/package/ghc-typelits-natnormalise
05:08:35 <drdo> I'm spawning a thread in ghci that reads data from a socket and outputs it to stdout. But when the prompt returns it seems that there's no more output from that thread
05:09:12 <drdo> If I do a threadDelay after spawing the thread, so that the prompt does not return, the messages come through
05:20:28 <roi_du_silence> ohayou
05:28:13 * hackagebot postgres-embedded 0.1.7 – Library for easily running embedded PostgreSQL server for tests – https://hackage.haskell.org/package/postgres-embedded
05:34:48 <athan> Hmm, does anyone here know how to use Data.ByteString.Internal.create, with System.Posix.IO.openFd? I'm just not sure if I can supply a length to the bytestring before I open the handle
05:35:40 <athan> I'm also going to use a lazy bytestring, but I'm just wondering if there's a way to peek ahead maybe in the file descripter, to see "how many more bytes" there's left from the seek position
05:37:59 <athan> ahh wait I think I figured it out
05:38:14 <athan> I have to check the returned offset after attempting to seek. woot!
05:39:57 * hackagebot azubi 0.2.0.3 – A simple DevOps tool which will never "reach" enterprice level. – https://hackage.haskell.org/package/azubi
06:02:36 <cocreature> drdo: do you have some minimal example? If I just run `forkIO (threadDelay (10^6) >> putStrLn "hello world")` I get back to the prompt immediately but I’m still seeing the output
06:05:14 * hackagebot accelerate-io 1.0.0.1 – Read and write Accelerate arrays in various formats – https://hackage.haskell.org/package/accelerate-io
06:06:01 <muesli4> cocreature: What do you expect?
06:06:08 <drdo> cocreature: I'll try to make one later, I have to go out now
06:06:31 <drdo> But if you want to, try setting up a UDP socket and have the thread just (forever $ recv >>= print)
06:06:35 <cocreature> muesli4: I expect exactly that, drdo claimed that they were not seeing the output of spawned threads if ghci returned to the prompt
06:06:43 <drdo> And exit the main thread after spawing that
06:06:48 <drdo> *spawning
06:06:56 <cocreature> drdo: how are you starting the main thread?
06:07:16 <drdo> By main thread I just meant whatever thread does the ghci repl
06:07:25 <cocreature> also maybe the other thread is just dying, try installing an exception handler
06:07:35 <drdo> e.g. socket *> bind *> fork (forever $ recv sock >>= print)
06:07:37 <drdo> something like that
06:07:44 <drdo> cocreature: It isn't, I checked with threadStatus
06:07:51 <drdo> And the socket was alive too
06:23:15 <etorreborre> Hi, quick question, is there a function `leftMapEitherT :: Functor m => (a -> c) -> EitherT a m b -> EitherT c m b` somewhere? I could not find it
06:26:09 <lyxia> etorreborre: bimapEitherT
06:26:41 <lyxia> ExceptT has withExceptT
06:32:11 <etorreborre> would it make sense to propose leftMapEitherT as a PR to the either package? or maybe I can just use the except package? What are people using these days?
06:32:39 <cocreature> ExceptT is in transformers
06:32:51 <cocreature> so I would say it’s the defacto standard
06:34:26 <etorreborre> ok, thanks
06:51:20 <Unhammer> trying out turtle, looks nice, except I've now spent an hour trying to turn Text into a FilePath – is there such a function ?
06:51:43 <maerwald> both are wrong formats :>
06:53:52 <Unhammer> omg fromText
06:54:05 <Unhammer> what's the word for where you find the answer right after asking …
06:55:01 <maerwald> google
06:55:57 <sm> irc rubber duck debugging
06:56:24 <Unhammer> hehe
07:10:13 <hexagoxel> Internet Remote Duck
07:25:02 * hackagebot hslua 0.9.1 – A Lua language interpreter embedding in Haskell – https://hackage.haskell.org/package/hslua
07:46:06 <royal_screwup21> I was reading up on inhabitants and I have a question about it: suppose data Either a b = Left a  | Right b. How many inhabitants would this have? I think it's two because Either can takes only 2 values...but I'm not sure
07:47:32 <cocreature> royal_screwup21: the sum of the number of inhabitants of a and b
07:47:59 <royal_screwup21> ah
07:48:00 <royal_screwup21> yeah
07:48:17 <cocreature> royal_screwup21: take "Either Bool Bool": it has the inhabitants Left False, Left True, Right False and Right True
07:48:45 <royal_screwup21> right yeah
07:48:46 <royal_screwup21> thanks!
07:49:36 <cocreature> royal_screwup21: the fact that the number of inhabitants is a sum is also the reason why they’re called “sumtypes” (or at least it relates to that, I don’t actually know the precise origin of that term)
07:50:28 <erisco> which, amazingly, is iso to (Bool, Bool)
07:50:50 <cocreature> heh, yeah that might not have been the best example
07:52:14 <royal_screwup21> suppose I have: data Void. How many inhabitants would this have? I think it's 0? Because it can't really take any values?
07:53:04 <cocreature> yep (well at least we pretend so, you can always use bottom, e.g., undefined, error, … but if you start going down that road things become messy)
07:54:50 <erisco> Haskell's null
07:55:12 <erisco> everywhere, can't get rid of it
07:56:04 <royal_screwup21> suppose I have a tuple (a,b), where a belongs to type a and b belongs to type b. Let's say a has 'x' inhabitants. b has 'y' inhabitants. How many inhabitants would (a,b) have? I think it'd be x*y, because you could have those many different combinations of (a,b)
07:56:31 <cocreature> royal_screwup21: yep, that’s right, that’s why it’s called “product type” :)
07:56:40 <royal_screwup21> cool, thanks! :)
07:57:19 <erisco> https://chris-taylor.github.io/blog/2013/02/10/the-algebra-of-algebraic-data-types/
07:57:21 <cocreature> royal_screwup21: now the slightly trickier part: suppose a has X inhabitants and b has Y inhabitants, how many inhabitants does a->b have?
07:57:42 <royal_screwup21> hmm
07:59:54 <royal_screwup21> give me a hint
08:00:33 <erisco> it is more than zero
08:00:51 <epta> and depends on X and Y
08:00:53 <EvanR> isNull :: a -> Bool
08:00:58 <erisco> if b has more than zero
08:01:03 <EvanR> isNull = solveTheHaltingProblem
08:01:42 <EvanR> actually haskells null/nil would be ()
08:02:00 <erisco> hm, no, it is bottom
08:02:06 <cocreature> royal_screwup21: do you know how to encode boolean functions, i.e. functions that take X booleans as input and produce a boolean as output, using bit vectors?
08:02:11 <EvanR> it doesnt act the same
08:02:17 <erisco> didn't say it did
08:02:24 <cocreature> eh nvm
08:02:25 <EvanR> whereas () does
08:02:45 <erisco> what is the same is 1) it is everywhere, 2) you cannot get rid of it
08:03:28 <EvanR> bottom is also everywhere you cant get rid of it in e.g. javascript
08:03:41 <erisco> and I can add 3) it precludes a basic static analysis we all want
08:03:42 <EvanR> so you could say bottom is haskells bottom
08:03:42 <royal_screwup21> cocreature: I know of AND, OR, NOR - those kinds of functions. Not sure if that's what you're talking about
08:04:18 <erisco> we want things to not be null when we dereference them, but can't check that, and we want programs to be productive when we run them, but can't check that
08:04:22 <cocreature> royal_screwup21: that was a bad example, sry not sure how to hint at the solution without giving it up completely.
08:04:37 <EvanR> but you can check for null
08:04:44 <royal_screwup21> cocreature: not sure how to proceed, what's the solution? :)
08:04:46 <cocreature> royal_screwup21: how many functions Bool -> Bool are there?
08:04:47 <erisco> not statically
08:05:02 <EvanR> oh, youre talking about null pointer
08:05:15 <royal_screwup21> cocreature: well t -> f, t->t, f ->t, f-> f, so 4
08:05:17 <erisco> null whatever
08:05:21 <royal_screwup21> oh
08:05:28 <EvanR> haskell also has that, in the form of Int keys that go nowhere
08:05:48 <cocreature> royal_screwup21: right, so now, let’s take some type Three that has three constructors how many functions "Bool -> Three" are there?
08:06:03 <royal_screwup21> 6?
08:06:12 <shloub> royal_screwup21, you can start with an example, say X is 4, then an inhabitant looks like x1 -> something, x2 -> something, x3 -> something, x4 -> something
08:07:06 <cocreature> royal_screwup21: nope it’s not 6, try enumerating them explicitely
08:07:42 <cocreature> royal_screwup21: oh also your enumeration above does not make sense, "t -> f" is not a full definition of a function Bool -> Bool
08:07:43 <EvanR> originally i thought you were talking about the dynamically typed value null
08:08:55 <erisco> actually, there is another interest in this counting wrt laziness, I think
08:09:21 <erisco> because  Void -> Bool  has two inhabitants if we're allowed to be nonstrict on the argument
08:11:09 <erisco> opposed to just the single inhabitant of \case{}
08:11:42 <EvanR> allowing bottom breaks all these funny population calculations badly
08:12:46 <erisco> I don't know how you talk about that situation without bottom, so that could be source of difference
08:14:28 <erisco> maybe you can have a language where  f :: Void -> Bool; f _ = True; f _ = False;  makes sense without bottom, but f is unusable
08:15:43 <erisco> i.e. the nonstrictness is for naught, because no Void is constructible
08:16:43 <EvanR> wait
08:16:52 <EvanR> the exponential formula doesnt work with Void ?
08:17:08 <Tuplanolla> Sure it does.
08:17:49 <EvanR> Void -> Void, 0^0 = 1, f = id
08:18:07 <EvanR> Void -> Bool, 2^0 = 1... not 2
08:19:04 <cocreature> EvanR: how do you come up with two implementations for Void -> Bool?
08:19:38 <EvanR> see above, = True, = False
08:20:03 <DigitalKiwi> what's an inhabitant
08:20:14 <cocreature> oh you’re talking about lazy functions
08:20:22 <EvanR> erm
08:20:28 <EvanR> not really
08:21:00 <EvanR> still assuming Void has no values and no bottom
08:21:43 <shloub> DigitalKiwi, i believe it is an element that belongs to the type
08:22:05 <cocreature> EvanR: well if you’re forced to pattern match on Void the only implementation is an empty case statement
08:22:14 <EvanR> there seems to be two different definitions, but in the set theory notion of function... both are the same, the empty set
08:22:30 <EvanR> ah
08:22:35 <hpc> if you allow bottom, Void -> Bool = 3^1
08:22:40 <hpc> \_ -> undefined
08:22:42 <hpc> \_ -> False
08:22:44 <hpc> \_ -> True
08:23:20 <EvanR> pattern matching breaks things
08:24:15 <hpc> i think if you're in a strict language, you have to do something like agda
08:24:18 <hpc> f :: Void -> Bool
08:24:19 <hpc> f ()
08:24:37 <hpc> (iirc)
08:27:12 <mniip> hpc, you have 3^1+1
08:27:27 <mniip> (\_ -> undefined) and undefined are distinguishable with seq
08:27:45 <EvanR> bleh
08:28:15 <mniip> EvanR, in total Hask, Void->Bool only has one inhabitant
08:28:20 <mniip> \x -> case x of {}
08:28:32 <EvanR> uh
08:28:41 <EvanR> \x -> True
08:28:42 <mniip> const False and const True are both equal to it
08:28:59 <EvanR> so thats the secret, a weird way to counting whats different
08:29:13 <mniip> in total Hask you can exercise extensional equality
08:29:15 <jmcarthur> Huh, so the presence of bottom raises Void->Bool to three inhabitants (and weak evaluation raises it again to at least four, I think).
08:29:17 <EvanR> \x -> False = \x -> True in some bizarre fashion
08:29:23 <mniip> EvanR, yes
08:29:27 <Tuplanolla> You can't look inside, EvanR.
08:29:27 <mniip> it's not bizzare
08:29:44 <jmcarthur> (weak evaluation + seq, I suppose)
08:29:54 <EvanR> function extensionality
08:30:19 <cocreature> EvanR: basically the argument is that since you can’t provide something of type Void you can’t observe that they are different
08:30:23 <Tuplanolla> It's the same reason why `x = id 42` defines the same `x` as `x = 42`.
08:30:44 <EvanR> i think the precise argument is, the functions results are equal for all inputs
08:30:52 <EvanR> which is vacuously true
08:31:25 <EvanR> there are no results
08:31:43 <EvanR> they also disagree for all inputs
08:32:36 <EvanR> so if you define that as disjoint, then an f :: Void -> Bool is disjoint from itself!
08:39:41 <EvanR> "The unit term, of type 1, is written as {\displaystyle ()} () and vocalized as 'nil', is the final object."
08:40:04 <EvanR> heh so really () is haskells null, proof by wikipedia
08:41:00 <EvanR> though that seems wrong, a term (value) isnt an object (type)
08:44:15 <mauke> :t () :: 1
08:44:17 <lambdabot> error:
08:44:17 <lambdabot>     • Expected a type, but ‘1’ has kind ‘GHC.Types.Nat’
08:44:17 <lambdabot>     • In an expression type signature: 1
08:44:26 <mauke> oh, right. that was changed
08:49:43 <Abaxvahl> For learning Haskell as a first programming language, what other things do you need to know?
08:50:05 <EvanR> substitution ...
08:50:18 <mniip> Abaxvahl, have you been good with maths at school?
08:50:21 <monochrom> http://www.vex.net/~trebla/haskell/prerequisite.xhtml
08:50:42 <monochrom> which is what EvanR and mniip said.
08:51:14 <EvanR> i was thinking of that link
08:51:28 <EvanR> typo in first line of last section
08:51:39 <EvanR> a lot other programmers do not possess that skill
08:52:10 <mniip> where's the typo?
08:52:30 <mniip> "a lot [of]" ?
08:52:35 <monochrom> Expected "of", found adjective :)
08:52:58 <monochrom> Expected grammar does not match inferred grammar. :)
08:53:42 <mniip> Parse error on input 'other' (possibly incorrect indentation or mismatched brackets)
08:54:45 <monochrom> Fixed.
08:54:58 <monochrom> No let me do it the Simon Marlow way.
08:55:05 <monochrom> Fixed in HEAD. :)
08:55:26 <mniip> closed. notabug.
09:00:19 <sm> fixed IN MY MIND.
09:03:49 <mivael_> hello all
09:07:34 <mivael_> Could anyone please advise me on meaning of stars ("*") in fmap type signature for Const?... fmap :: (a -> b) -> Const * m a -> Const * m b  (http://hackage.haskell.org/package/base-4.10.0.0/docs/Control-Applicative.html#section.i:Const)
09:09:01 * hackagebot hasql-optparse-applicative 0.2.3 – "optparse-applicative" parsers for "hasql" – https://hackage.haskell.org/package/hasql-optparse-applicative
09:09:37 <hydraz> it's the kind of a/b
09:10:13 <cocreature> it’s the kind of b
09:10:15 <hydraz> If you look at Const, it's newtype Const a (b :: k) = Const { getConst :: a }; i.e., b doesn't nescessarily have to be a type
09:10:31 <EvanR> Const is polykinded
09:10:33 <hydraz> cocreature: in the fmap type signature, it's also the kind of a
09:10:33 <mivael_> :t fmap :: (a -> b) -> Const c a -> Const c b
09:10:35 <lambdabot> (a -> b) -> Const c a -> Const c b
09:10:48 <cocreature> hydraz: right but that’s not what the * is indicating, a is always of kind *
09:11:10 <hydraz> here's hoping we have the right extensions
09:11:18 <hydraz> :t Const () :: Const () 1
09:11:19 <lambdabot> Const () 1
09:11:22 <glguy> hydraz: b has to be a type, it just doesn't have to have kind *
09:11:43 <cocreature> :set -fprint-explicit-kinds can be helpful for this
09:11:55 <cocreature> » Const :: forall k a (b :: k). a -> Const k a b
09:12:22 <cocreature> that’s what you get from :t Const in ghci
09:13:05 <cocreature> -fprint-explicit-foralls and :k Const is probably even better
09:13:25 <glguy> Const :: forall {k}. * -> k -> *
09:13:34 <mivael_> I think I need to read some introductory material first about... kinds?
09:14:01 <glguy> mivael_: The rendering of "Const * a b" is an artifact of how Haddock handles polykinded types
09:14:26 <glguy> You don't apply Const to * manually like that in actual Haskell syntax
09:14:34 <cocreature> we should really try to make haddock better at rendering fancy types
09:15:34 * hackagebot graphite 0.8.0.0 – Graphs and networks library – https://hackage.haskell.org/package/graphite
09:15:46 <cocreature> the combination of putting everything into prefix form and explicit kind arguments can make things quite hard to read
09:16:58 <Eduard_Munteanu> mivael_, not sure there's any, but you only need to know inhabited types have kind '*', (->) can form kinds, we have polykinds (polymorphic types with kind variables) and lifted kinds (types lifted to kinds) in GHC
09:17:19 <Eduard_Munteanu> The last two are PolyKinds and DataKinds.
09:18:36 <mivael_> Eduard_Munteanu: now I think I certainly should read about kinds  :)
09:19:30 <Eduard_Munteanu> So ordinary values have types in '*', functors are '* -> *'.
09:20:27 <Eduard_Munteanu> f :: * -> * isn't inhabited, but f () may be inhabited.
09:21:24 <Eduard_Munteanu> i.e. you don't have values of 'f'.
09:25:33 <mivael_> thank to you all for help
09:26:11 <mivael_> > ((+1000) <$> Just 12,   (+1000) <$> Const 12)
09:26:14 <lambdabot>  (Just 1012,Const 12)
09:44:06 <mniip> > Data.Bifunctor.first (+1000) (Const 12)
09:44:09 <lambdabot>  error:
09:44:09 <lambdabot>      Not in scope: ‘Data.Bifunctor.first’
09:44:09 <lambdabot>      No module named ‘Data.Bifunctor’ is imported.
09:44:41 <mniip> > Data.Bifunctor.first (+1000) (Const 12)
09:44:43 <lambdabot>  Const 1012
10:02:38 * hackagebot dbus-th-introspection 0.1.0.2 – Generate bindings for DBus calls by using DBus introspection and dbus-th – https://hackage.haskell.org/package/dbus-th-introspection
10:07:51 <mivael_> mniip: that's interesting!
10:08:59 <mivael_> have to go, have a nice day
10:11:27 <dsal> I'm looking at the megaparsec doc[0] pointed out here yesterday.  Already running into rot issues with just the imports.  import qualified Text.Megaparsec.Char.Lexer as L
10:11:29 <dsal> [0]: https://markkarpov.com/megaparsec/parsing-simple-imperative-language.html
10:13:04 <lyxia> what happens?
10:13:13 <glguy> dsal: Did you remember to install megaparsec first?
10:13:29 <dsal>     Failed to load interface for ‘Text.Megaparsec.Char.Lexer’
10:13:30 <dsal>     Perhaps you meant
10:13:30 <dsal>       Text.Megaparsec.Lexer (from megaparsec-5.2.0)
10:13:30 <dsal>       Text.Megaparsec.Char (from megaparsec-5.2.0)
10:13:54 <glguy> Your megaparsec is old, the current version is 6.2.0
10:14:18 <dsal> Ah.  I'm doing this stuff in exercism which uses an old stackage.
10:14:23 <dsal> reverse rot
10:14:57 <monochrom> "Published on October 13, 2015, last updated September 22, 2017"  Interesting
10:14:58 <dsal> Well, it looks like stackage 9.8 gives me 5.3.1
10:15:22 <glguy> You can simply not use stackage if it's out of date
10:15:39 <monochrom> Jailbreak.
10:16:08 <monochrom> Maybe one day I should write an article "How to jailbreak Stack".
10:16:40 <DigitalKiwi> what does that even mean 
10:17:22 <monochrom> It is a whole slew of cultural references that I'm too lazy to deliberate now.
10:18:33 <DigitalKiwi> if you call that culture?!
10:18:45 <monochrom> Yes.
10:18:51 <monochrom> You have a problem?
10:19:15 <sm> dsal: one of the main points of stack is that you can specify a resolver so that docs like this keep working "forever", but this doc doesn't take advantage of that
10:19:18 <DigitalKiwi> is that a trick quesion
10:19:59 <dsal> So, this thing has a package.yaml in which I reference megaparsec.  Is there a way I can force a version here?  (it's not by sticking -6.2 at the end, because that fails to parse)
10:20:47 <sm> this thing eh.. got a link ?
10:21:10 <sm> the version is -6.2.0
10:21:24 <dsal> I guess it's this:  https://github.com/exercism/haskell/tree/master/exercises/wordy
10:21:36 <sm> aha!
10:21:43 <dsal> When I add -6.2.0 on to the end, I get:  Unable to parse cabal file /Users/dsal/prog/exercism/haskell/wordy/wordy.cabal: NoParse "build-depends" 13
10:22:05 <sm> to the end of what ? this doesn't use megaparsec
10:22:23 <dsal> library:
10:22:23 <dsal>   exposed-modules: WordProblem
10:22:23 <dsal>   source-dirs: src
10:22:23 <dsal>   dependencies:
10:22:23 <dsal>     - megaparsec-6.2.0
10:22:27 <freeman42x> is there anything like hoogle but for C#? that would be extremely useful
10:22:47 <AndroUser> https://github.com/commercialhaskell/stack/blob/master/doc/yaml_configuration.md#packages-and-extra-deps
10:23:14 <AndroUser> I think you need to configure the version through extra-deps in stack.yaml
10:23:53 <glguy> If you were using the cabal file directly you'd add: build-depends: megaparsec == 6.2.0
10:24:09 <glguy> and if you were using packages directly you could: cabal install megaparsec-6.2.0
10:24:17 <glguy> so now you just need to figure out the indirection through these two yaml files
10:24:29 <sm> dsal: ok, you added megaparsec to the package.yaml. I don't know the library: dependencies: clause, but apparently it doesn't take a version number; it probably pulls megaparsec from the resolver specified. 
10:24:37 <monochrom> I am skeptical of the value of a doc that acomplishes "works forever" by the technicality of giving you an automatic script that merely brings in an old compiler and an old API that nobody wants to support anymore.
10:24:51 <sm> I believe only in an extra-deps: clause do you specify package versions
10:25:01 <dsal> OK.  I'll see if I can get that working.
10:25:51 <sm> uh, and I am mixing up stack.yaml/package.yaml
10:26:08 <dsal> Yeah.  I don't understand package.yaml
10:26:14 <monochrom> I have in mind the exaggerated picture of a version control tutorial that "works forever" simply by telling you what command you should use to install SCCS and then goes on to just teach you how to use SCCS.
10:26:21 <glguy> package.yaml is an unnecessary way to generate your .cabal file
10:26:43 <sm> hpack documents it. In package.yaml the syntax would be - megaparsec == 6.2.0, eg. Like in a cabal file.
10:27:22 <blackdog> monochrom: i think the real value is that it lets you separate upgrading from working on the thing. the intent is not to stay on ancient compilers and libraries indefinitely, but it really helps to have a solid place to stand when you start the upgrade process.
10:27:39 <dsal> Heh
10:27:39 <dsal>     megaparsec-5.3.1 must match ==6.2.0 (latest applicable is 6.2.0)
10:28:13 <sm> yes, because now you're conflicting with the resolver specified in stack.yaml - need to update that too
10:28:28 <dsal> Oh I see
10:28:35 <dsal> Yeah, this seems to work so far.
10:28:58 <sm> only stackage nightly has that latest megaparsec. You might not need such a new one
10:29:28 <glguy> You only need the new one if you want to follow the tutorial you're reading
10:30:00 <monochrom> You may be able to compromise for 6.0.*
10:30:22 <monochrom> "Text.Megaparsec.Char.Lexer" first appeared in 6.0.0
10:30:32 <sm> you won't need one newer than the tutorial doc
10:30:35 <monochrom> Although, I don't know what else is there.
10:30:49 <dsal> I tried nightly and it complained something about ghc versions.  I decided not to pursue that.
10:30:57 <monochrom> Ah but the tutorial is written by one of the megaparsec authors and is "September 17 2017" new.
10:31:34 <monochrom> In other words the author actually has incentive to sync tutorial with library.
10:32:04 <dsal> Good.  In my cursory glance last night, this document seemed to be the most useful introduction among the three parsers I looked at.
10:32:06 <sm> ah, guess he did. So you need a megaparsec closer to the update date
10:32:13 <monochrom> It is not like monochrom's HXT tutorials.
10:32:14 <sm> not many bloggers do that
10:32:39 <sm> but he should've mentioned the requirements somewhere
10:32:47 <c_wraith> monochrom: is the arrowness of HXT ever useful?
10:33:38 <sm> dsal: the ghc complaint I assume was telling you to run setup to get ghc 8.2
10:33:47 <dsal> Yeah.
10:35:20 <lyxia> dsal: have you tried importing Text.Megapasec.Lexer instead
10:35:41 <lyxia> with your current version of megaparsec
10:35:56 <dsal> Nah, I wanted to try to follow this tutorial.
10:35:59 <monochrom> c_wraith: I think I actually enjoy it.
10:36:35 <sm> dsal: so letting it install the required ghc is the way to go
10:36:48 <dsal> Hmm...  Alright, I'll try the nightly anyway.
10:36:53 <monochrom> I would say that if HXT gave us a monad instead I might be using >=> a lot.
10:43:08 <cwgoes> Anyone know if it's possible to get Core IR for package modules using the GHC API?
10:48:42 <monochrom> I don't know how, but I can tell you what is the maximum possible information you could ever get because it's the only information stored in the package files.
10:49:08 <monochrom> You won't get guaranteed complete Core IR because it is simply not in any files.
10:49:51 <monochrom> But it is not none either. The *.hi files contain Core IR of some code because they may be useful during inlining.
10:50:41 <monochrom> So basically the Core IR of a function is preserved iff GHC considers the function inlinable.
10:51:06 <monochrom> (Caveat emptor for "basically" as usual.)
10:51:24 <monochrom> Still, I don't know how to use the GHC API to get them.
10:58:22 <ongy> is there a state monad that only has the get function? so I can just abuse it as hidden argument in a monad stack?
10:58:36 <geekosaur> wouldnt that be Reader?
10:59:28 <ongy> that looks about right. thx
11:01:48 <cwgoes> @monochrom Thanks.
11:01:49 <lambdabot> Unknown command, try @list
11:02:55 <EvanR> theres several tricks to get hidden arguments
11:03:19 <EvanR> oh, monad stack ...
11:44:50 <N3RGY> Does something like foo' exist in the Lens ecosystem? The answer to this kind of question almost always seems to be "yes" and I just can't find it. https://gist.github.com/wyager/7c071b0e408fba7d77d15533ca0fe264
11:45:37 <N3RGY> The goal here is to combine multiple Prisms. So if a data structure has 5 constructors, I should be able to combine prisms for 2 of them and get a prism that matches on either case
11:46:06 <N3RGY> I want to eventually get to something more general with more than 2 constructors (and nested Eithers are yuck) but I'm starting here
11:46:59 <N3RGY> It feels like this might require some sort of lens between a larger data structure and a smaller one to get a fully general solution. Don't know if that has a name or exists.
11:47:45 <Gurkenglas> N3RGY, a Prism' s a is a witness that the s type is a sum of a and something else. What if a1 is a subtype of a2?
11:48:08 <Gurkenglas> Like, what should foo' _Left id be?
11:55:48 <N3RGY> Looks like id as a prism is Prism s t s t. What does that mean?
11:58:19 <N3RGY> If id as a prism just matches everything, foo' _Left id would just match Left constructors first, and if that fell through it would match Right constructors only while maintaining the full type of the Either
11:58:44 <N3RGY> In other words, it seems dumb but I don't see why it would be wrong
11:58:53 <N3RGY> (although I'm totally willing to believe this violates some lens law)
12:00:11 <N3RGY> It's also true that algebraic types are associative over addition, so I should be able to construct a prism that matches multiple constructors over your "sum type witness" interpretation
12:00:24 <N3RGY> (A + B) + (C + D) is just as valid as A + (B + C + D)
12:00:43 <N3RGY> Seems like if I have an A prism and a B prism I should be able to construct an A+B prism
12:02:21 <N3RGY> The end goal is to be able to construct an A+B+C prism by providing A,B,and C prism as well as some type isomorphic to A+B+C but not necessarily Either A (Either B C) or something ugly like that
12:03:07 <Gurkenglas> If you could add arbitrary prisms nothing would keep you from doing A+A instead, which probably breaks something, let me think
12:03:45 <N3RGY> I think it would just never match one of the two cases. You would have to provide something of the form (a -> Either a a), which will be Left or Right
12:09:35 <Gurkenglas> "failing :: Prism s t a b     -> Prism s t a b     -> Traversal s t a b" is similar to what you want, and says they must be disjoint for law compliance
12:09:42 <mniip> Gurkenglas, no
12:09:50 <mniip> or... yes
12:09:56 <mniip> actually yes that's exactly the issue
12:10:28 <N3RGY> Sweet, that does look like what I want
12:11:33 <N3RGY> And one can easily (I think?) combine types by composing the consturctor prism with an rmap <Constructor> or something
12:11:56 <N3RGY> brb
12:12:18 <Gurkenglas> Which throws away the information on which of the constructors the data came from, which explains how it's a traversal and not a prism
12:12:49 <Gurkenglas> Which means there ought to be an operator that actually constructs a prism with eithers
12:18:05 <N3RGY_2> So I see that "failing" can turn two Prisms into a Traversal, but can it turn two Prisms into a Prism?
12:18:47 <Gurkenglas> How would it turn the a into an s? How would it know which review to use?
12:20:33 <Gurkenglas> Consider fusing the two constructors you want to treat as one into actually one constructor and using an extra data declaration for distinguishing between them. Composing optics is what lens is good at.
12:20:40 <N3RGY_2> At a high level, if you have a type T1 = A + B + C and a type T2 = A + B, and prisms T1_A, T1_B, T1_C, T2_A, T2_B, I should be able to go from T1 to T2 + C
12:21:06 <N3RGY_2> Gurkenglas: Yes, I think that's exactly what I want
12:22:08 <N3RGY_2> Still not sure how to do that. Is there a way to do it with Prisms for each type as I just described?
12:23:41 <Gurkenglas> data T1 = Foo T2 | Bar C; data T2 = Baz A | Qux B
12:24:02 <N3RGY_2> For other reasons, I can't actually structure T1 in terms of T2
12:24:12 <N3RGY_2> T1 has to have separate constructors for A and B
12:24:36 <Gurkenglas> I'd like to hear more about that :P
12:28:18 <N3RGY_2> I'm building a pipes-based application. There are several categories of events that could go down the pipe. For composability and code quality, I want to be able to write pipes that only process certain kinds of events and ignore other ones. To that end, I contributed https://hackage.haskell.org/package/pipes-extras-1.0.11/docs/src/Pipes-Extras.html#select' . This is great if you only want to process 
12:28:20 <Gurkenglas> "\s -> (Left <$> proj1 s) <> (Right <$> proj2 s)" discards one of the t's
12:28:24 <N3RGY_2> *all* events moving through the pipe or only one category of event. 
12:28:58 <N3RGY_2> Gurkenglas: If they satisfy the requirement that they be disjoint constructors it's fine
12:29:07 <N3RGY_2> The second t is a subset of the first
12:30:49 <N3RGY_2> Or rather, the intersection of both ts is disjoint from the union of a1 and a2
12:30:53 * Gurkenglas .o(That "subset" doesn't seem like it should be there after the "disjoint" before it)
12:31:42 <Gurkenglas> If two ts arise, are they always equal?
12:34:01 <N3RGY_2> Just so we're on the same page: proj1 :: s -> Either t a1, proj2 :: s -> Either t a2. If these correspond to constructors, the first 't' will never equal the constructor corresponding to 'a1', and the second 't' will enver equal the constructor corresponding to 'a2'
12:36:34 <Gurkenglas> afaik t is not the thing that sums with a to s, but the sum of (s - a) and b
12:41:08 <usre21863> is there a reason why in the Foreign-Ptr docs it says "data Ptr a"
12:41:24 <usre21863> but in the System-IO docs it says "data IO a :: * -> *"
12:41:46 <usre21863> (I'm trying to generate coq wrappers based on the docs)
12:41:53 <Gurkenglas> N3RGY_2, in the subset hierarchy of sets of events pipes might want to process, are there diamonds?
12:43:32 <Gurkenglas> usre21863, talking out of my picklejar here but maybe Ptr is supposed to take parameters of arbitrary kinds, while the a in IO a is only supposed to be a type that actually contains values
12:43:57 <N3RGY_2> Gurkenglas: I don't understand. At any given point I want to be able to pick out a single subset of events to process. The heirarchy is only 1 deep, there can't be diamonds
12:44:41 <Gurkenglas> Are the subsets of events from all the given points disjoint?
12:45:23 <Gurkenglas> (Or rather, for any two such subsets that are not disjoint, must one be a subset of the other?)
12:45:46 <N3RGY_2> No. I might want to build a pipe that processes constructors A and C, and connect the output of that to a pipe that processes A and B. 
12:45:55 <Gurkenglas> usre21863, so you could have "Ptr IO" but not "IO Ptr"
12:46:14 <N3RGY_2> But at the top level, the type of every pipe term is such that it could process any of the constructors if it wanted to
12:46:28 <N3RGY_2> Which constructors the pipe touches are an internal detail
12:47:19 <N3RGY_2> Like, I might have a pipe of type "Pipe (A+B) (A+B) m r" but after wrapping it in what I'm trying to create, its type would be "Pipe (A+B+C+D) (A+B+C+D) m r"
12:47:22 <Gurkenglas> N3RGY_2, then why do you want a prism rather than a traversal
12:48:10 <usre21863> Gurkenglas: ghci says that both Ptr&IO have kind * -> * (both Ptr IO& IO Ptr fail)
12:48:12 <N3RGY_2> Because a Prism is the only way I could identify to transform between "Pipe A A m r" and "Pipe (A+B+C+D) (A+B+C+D) m r"
12:48:20 <N3RGY_2> Not sure how I would implement "select'" with a traversal
12:49:11 <N3RGY_2> You must be able to turn around the Prism to put the new values "back in" the stream
12:49:19 <N3RGY_2> Ah, perhaps I've mislead you
12:49:35 <N3RGY_2> each of the constructors are parametrized over a type
12:50:12 <N3RGY_2> It'm really going between "Pipe (A a + ...) (A a' + ...) m r" and "Pipe (A a) (A a') m r"
12:51:16 <N3RGY_2> But yeah, you need a Prism to go from A a' back to (A a' + ...). A traversL can't be turned aorund
12:51:24 <N3RGY_2> *Traversal
12:55:31 <N3RGY_2> I could construct all these things manually with prism, but it seems like this shoud be automatable somehow
13:04:10 <Gurkenglas> Ah, an a might turn into multiple bs
13:04:29 <N3RGY_2> Ah, yes
13:04:42 <N3RGY_2> Sorry, the problem has been in my head for so long I forget which constraints to communicate
13:05:58 <Gurkenglas> That sure looks like you've found a usecase that fits exactly onto prisms. Let's see what the dual problem for lenses might be, someone might already have solved it
13:07:41 <Gurkenglas> From the constructor perspective, it looks like Lens' s a -> Lens' s b -> Lens' s (a, b), though it's probably worth eventually looking at the dual to the application to pipes
13:17:26 <vectorspacealien> hey, anyone know under what conditions (//) causes an Array to be copied, in Data.Array? It seems intuitive to me that if y = x // L, and x is never referenced again and is due to be garbage collected after y is evaluated, then the array would be modified in place and no copying would occur. But I don't know if that's actually true.
13:17:54 <merijn> vectorspacealien: GHC doesn't do any escape analysis like that, AFAIK
13:18:15 <merijn> vectorspacealien: If you want to mutate arrays, why not use mutable arrays?
13:19:07 <vectorspacealien> merijn: well, if your answer had been "yes, it's modified in place," then my answer would have been "because mutable arrays are not necessary to avoid copying"
13:19:21 <vectorspacealien> but ya, guess I'll use mutable arrays
13:19:24 <N3RGY_2> vectorspacealien: I think doing that in the general case is undecidable. It might be possible to automate after getting linear types support
13:19:38 <blackdog> there's also STArrays
13:21:03 <vectorspacealien> N3RGY_2: ooh I've never heard of linear types before, from the Wikipedia article that sounds cool
13:21:44 <N3RGY_2> vectorspacealien: Yeah, they are working on adding them to GHC now. There are lots of promising opportunities for new safe mutation APIs. Also, if your data is 1-dimensional, Vector is generally preferable to AI
13:21:53 <N3RGY_2> *to Array
13:22:35 <N3RGY_2> Vector is generally better at doing things in-place. It's actually quite impressive how fast Vector code gets, especially if you're using one of the unboxed variants
13:23:14 <vectorspacealien> N3RGY_2: yeah... now that you mention it I should probably get used to Vector. My reasoning is just that Vector is used a lot by other libraries I've been interested in using. For example Casava returns vectors iirc
13:24:09 <N3RGY_2> Yes, its API is much nicer and it generally has excellent performance out of the box. It's really a treat to write some fairly abstract, complicated vector code and see it turned into a nice, tight assembly loop
13:24:20 <vectorspacealien> blackdog: thanks for the pointer, I'm not familiar with the ST monad but I'm reading the Haskell wiki article now
13:24:56 <N3RGY_2> Fun fact: if you're writing ultra-low-overhead mutable algorithms, it's often faster to use a one-length mutable Vector than to use an STRef or something. This is what the mutable-containers package is based on
13:25:20 <N3RGY_2> You can't really get zero-allocation code with STRef, but you can with Vector.Unboxed or Vector.Storable or whatever
13:25:53 <Gurkenglas> Tabooing "Pipe", it looks like select is "Prism s t a b -> (a -> [b]) -> s -> [t]"
13:26:24 <N3RGY_2> Gurkenglas: OK, I'm tentatively willing to go with that
13:26:32 <vectorspacealien> N3RGY_2: I'd like to use unboxed but I'm working on a homework problem that has to be run on integers up to 10^9, which is JUST above what Int can handle if I understand correctly. 
13:26:52 <vectorspacealien> I assume you can't put that Integer in an unboxed vector? I'm hoping there's like a long int type or something
13:27:14 <N3RGY_2> vectorspacealien: 64-bit ints can handle ~10^19
13:27:27 <Tuplanolla> > 10 ^ 9 < 2 ^ 29
13:27:29 <lambdabot>  False
13:27:47 <N3RGY_2> Where are you getting 29?
13:28:00 <Tuplanolla> The language report, N3RGY_2.
13:28:38 <monochrom> If you use GHC, Int is enough for 10^9.
13:28:44 <N3RGY_2> Am I taking crazy pills? Haskell doesn't have 29-bit ints, it uses machine words
13:28:58 <monochrom> You are taking crazy pills.
13:29:31 <monochrom> "Haskell" is ambiguous and may refer to either theoretical standard or de facto standard.
13:29:38 <vectorspacealien> https://hackage.haskell.org/package/base-4.5.0.0/docs/Data-Int.html
13:29:38 <N3RGY_2> GHC, then
13:29:53 <vectorspacealien> "data Int A fixed-precision integer type with at least the range [-2^29 .. 2^29-1]."
13:29:59 <vectorspacealien> but yeah, looking at maxBound, it's higher I think?
13:30:10 <vectorspacealien> yeah much higher
13:30:13 <merijn> GHC uses 32bit/64bit on 32/64bit architectures
13:30:31 <monochrom> The theoretical standard does not promise machine words. In fact it wants to cater for more traditional implementation tricks and so only promises "at least 30 bits, implementation-dependent".
13:30:43 <N3RGY_2> Ok, so use Int64. Unambiguous 
13:30:48 <vectorspacealien> oh!!
13:30:53 <vectorspacealien> yeah, Int64. Cool.
13:30:56 <monochrom> The idea is that there are 2 bits a lot of compilers want to reserved for tagging, GC purposes, etc.
13:31:25 <N3RGY_2> Haskell has kind-level boxity representation, I don't think we need runtime tagging for any reason
13:31:37 <N3RGY_2> (Runtime tagging on machine words)
13:31:56 <geekosaur> "Haskell" doesn't have that
13:31:57 <N3RGY_2> It's useful to tag constructor number on pointers, but I can't see any use case for integers
13:31:58 <monochrom> GHC gives you a machine word. The downside is that those taggings and GC bits go to a second machine word. Therefore GHC's Int is twice as big as what you actually use.
13:32:03 <geekosaur> ghc's implementation and extensions do
13:33:18 <N3RGY_2> monochrom: You need more than 3 bits for GC and tagging. If you don't do it the way GHC does it, you end up with Ocaml's runtime, which sucks and has bad performance problems with machine types
13:33:57 <monochrom> Sure. I forgot whether it was 2 or 3 or 4 or whatever.
13:34:01 <N3RGY_2> Every int is 31 or 63 bits and other unboxed types aren't really supported
13:34:12 <N3RGY_2> So floats/doubles are all boxed, leading to tons of performance issue with floats
13:34:15 <monochrom> The main point stands. The theoretical standard wants to give implementors more freedom.
13:34:34 <N3RGY_2> True, conceded 
13:34:39 <monochrom> But it's also OK to say "you're going to use GHC anyway".
13:34:53 <geekosaur> the theoretical standard also knows nothing of all the stuff ghc tosses on top of said standard
13:35:05 <monochrom> Programming is a dialectic class struggle between the user and the implementer.
13:35:25 <geekosaur> if *all* you are after is standard compatibility and you're not worried abotu performance (say, you're reinventing Hugs)...
13:35:34 <vectorspacealien> in my case, I know the homework grader is using GHC, so I know I'm not going to get overflow :p
13:35:48 <monochrom> My freedom is your slavery. Your ignorance is my strength.
13:35:52 <vectorspacealien> advantages of writing a program which will be compiled only once, by one known user
13:35:53 <merijn> vectorspacealien: Unless they run on a 32bit platform and you assume 64bit
13:35:59 <Ulrar> Hey, does anyone know a way to list packages that depends on something ? I'd like to find stuff using hOpenPGP or openPGP, they aren't really documented so I'm hoping to figure it out by looking at how people uses one of those
13:36:00 <merijn> :p
13:36:00 <vectorspacealien> merijn: oof
13:36:23 <geekosaur> Ulrar, http://packdeps.haskellers.com/reverse
13:36:27 <Ulrar> AH, thanks
13:36:30 <N3RGY_2> Ulrar: Are you thinking of working on hOpenPGP? That would be sweet
13:36:39 <vectorspacealien> haha, it makes me wonder how much I can learn about their computer by which submissions are marked correct
13:37:02 <Tuplanolla> We reserve one bit for parity and three bits for color charge.
13:37:05 <Ulrar> Well I'm looking to do some pgp signing at least, maybe encryptiong in haskell if I can figure out how to do that :)
13:37:09 <geekosaur> don't laugh, any more that's where all the action in computecurity (and lack thereof) is
13:37:17 <geekosaur> *computer security
13:37:48 <N3RGY_2> Tuplanolla: You only need two for color, right? Ulrar: I don't think hOpenPGP supports signing or encryption yet. I only saw verification/decryption
13:38:15 <geekosaur> that and even trickier variants thereof, like what you can learn about other stuff on the machine from timing things vs. their expected speed if the cache only held your program
13:39:14 <Ulrar> N3RGY_2: Ah. OpenPGP seems to, but how to use it is a bit obscure to me. There are a bunch of field I just don't know how to fill in the little that is documented
13:39:31 <deadbeefcafe-guy> hi
13:39:34 <geekosaur> you likely need to use the C API to figure out the Haskell one
13:41:17 <Ulrar> geekosaur: For me you mean ? I don't believe there is any C in it
13:41:47 <vectorspacealien> once I was wondering why the R gsl library had such bad documentation, then I realized I'm supposed to be reading gsl's documentation :p. I think geekosaur is talking about something like that
13:42:15 <vectorspacealien> (R's gsl library is just wrappers around the GNU scientific library)
13:42:37 <geekosaur> Ulrar, it has to be wrapping either a C library, in which case you need to understand that library, or it is wrapping calls to the executable in whjich case you need to understand the options and data formats expected by the executable
13:42:57 <Ulrar> Yeah well it does reference the RFC, which probably tells me everything I need to known .. But if I can avoid reading hundreds of pages of text ..
13:43:18 <Ulrar> geekosaur: I think it's a haskell lib, not a binding
13:43:19 <geekosaur> ...but I will note that, if the latter, pgp/gpg/etc. are kinda infamous for being a PITA to work with
13:43:21 <N3RGY_2> geekosaur: hOpenPGP is pure haskell
13:43:47 <geekosaur> oh, reimplementation? lovely
13:43:57 <Ulrar> There are bindings to pgpme and gpg, though
13:44:00 <Ulrar> And those are documented
13:44:06 <N3RGY_2> (Well, I think, the source link doesn't work)
13:44:07 <Ulrar> But it does look indeed a bit annoying to use
13:44:54 <geekosaur> (lovely way to accidentally end up not interoperable; standards often are just documenting someone;s idea of the public interface to an existing library --- in which case the documenter, and downstream users, get to hope the lib's developers agree@)
13:45:32 <Ulrar> Well there are a few different implementations of pgp, seems to work mostly fine in my limited experience with it
13:45:44 <Ulrar> I would rather avoid a call to a binary if I can avoid it though
13:46:00 <geekosaur> (bit if you want to have that kind of discussion, the rust folks are probably better at it because they came down solidly on one side and are reaping both the benefits and the pains)
13:49:01 <Ulrar> apotiki seems to use openpgp to sign stuff, looks simple enough. I'll try that out
13:52:58 <Gurkenglas> N3RGY_2, after due consideration, the implementation of "Prism s t a b -> (a -> [b]) -> s -> [t]" is, believe it or not, id.
13:55:10 <Ulrar> openpgp-crypto-api doesn't build .. And looking at the github issue, hasn't since 2015. Well, I guess I'll go with the C binding then
13:56:42 * geekosaur knows just enough abotu wha's going on in that Prism to be unsurprised
13:57:07 <geekosaur> or rather, in Prisms, not specifically that one
13:58:44 <Gurkenglas> N3RGY_2, also I think you want to relax that Prism to AffineTraversal, but not Traversal. Which means that failing turns out to be just what you want.
13:59:07 <Gurkenglas> geekosaur, (a -> [b]) is a standin for Pipe a b m r
13:59:33 <geekosaur> right, but I don't care. I care that (a -> [b]) ~ (s -> [t])
13:59:42 <geekosaur> or rather, I notice that...
14:00:17 <Gurkenglas> No, they aren't, neither Prism s t a b nor (a -> [b]) -> s -> [t] is id here, but Prism s t a b -> (a -> [b]) -> s -> [t] is
14:00:59 <geekosaur> the missing piece between what I said and what you said is more or less the definition of a van Laarhoven lens (and variants thereof such as Prisms)
14:01:46 <Gurkenglas> I sat a while there thinking that that the type signatures match up is an unfortunate coincidence and maybe I should have tabood Pipe another way lest there be confusion
14:12:06 <merijn> Fun times...GHC crashes on Travis, but the same version doesn't crash locally
14:13:29 <geekosaur> oh, I see how I confused you. I need a better shorthand for 'is isomorphic to'
14:13:40 <geekosaur> where the isomorphism here is more general than type equality
14:15:22 <Gurkenglas> a -> [b] isn't isomorphic to s -> [t] either
14:21:22 <anarcat> i have a form like this to remove empty tables in a pandoc filter: cleanBlock (BlockQuote [Table a b c d e]) = [Table a b c d e]
14:21:36 <anarcat> i find the "a b c d e" construct ugly - is there a better way?
14:21:53 <anarcat> s/empty tables/useless BlockQuote wrappers/
14:22:34 <saurabhnanda> is lifted-async considered stable for production usage?
14:23:55 <Eduard_Munteanu> anarcat, cleanBlock (BlockQuote t@[Table {}]) = t   ?
14:25:45 <anarcat> i don't know that syntax, what does it mean?
14:26:10 <Eduard_Munteanu> anarcat, @ is an at-pattern and {} is part of record syntax.
14:26:16 <anarcat> so that works
14:26:20 <anarcat> but i don't understand it at all
14:26:26 <anarcat> i guess i'll need to research those
14:26:29 * anarcat is a haskell newbie
14:27:46 <anarcat> so @ just gives you two ways of representing the same element in one construct?
14:28:31 <Eduard_Munteanu> anarcat, it binds a name to a pattern, yeah... e.g. f xss@(x:xs)   has xss as the whole list
14:28:51 <anarcat> right, so that part's easy
14:28:53 <anarcat> but {}?
14:28:57 <anarcat> it's just a wildcard?
14:29:31 <Eduard_Munteanu> anarcat, it's an empty record pattern, so it only matches the constructor without binding the fields
14:30:04 <Eduard_Munteanu> > let isJust Just {} = True; isJust _ = False in isJust (Just 5)
14:30:07 <lambdabot>  True
14:30:26 <Eduard_Munteanu> It works even if the data type isn't defined with record syntax.
14:30:55 <anarcat> i understand the explanation, but not the code, at all ;)
14:30:58 <c_wraith> anarcat: with this usage, it more or less means "ignore all the arguments to the constructor"
14:31:03 <anarcat> i never got around figuring out "Just"
14:31:07 <anarcat> c_wraith: cool, thanks
14:31:25 <anarcat> i must admit i'm having a hard time learning haskell because of all those "syntactic sugars"
14:31:35 <c_wraith> that one is a relatively uncommon one
14:31:38 <anarcat> there's always some mysterious character that pops up somewhere :)
14:31:41 <iqubic> Like what anarca?
14:31:44 <c_wraith> I don't think I've ever used it.
14:31:56 <anarcat> iqubic: well like @ and {} in this case :p
14:32:01 <iqubic> c_wraith: Are you talking about (&)?
14:32:19 <iqubic> Wait, that's a function.
14:32:22 <anarcat> i mean there's shit like <-> and god knows what
14:32:30 <c_wraith> iqubic: I mean using an empty record match to mean "match this constructor and ignore its args"
14:32:44 <Eduard_Munteanu> <-> isn't sugar that I know of
14:32:45 <c_wraith> anarcat: that one's not syntax.  If it exists, it's user-defined
14:32:46 <iqubic> c_wraith: Oh, yeah, I don't do that.
14:33:00 <anarcat> c_wraith: well there you go, i can't even tell :p
14:33:35 <iqubic> c_wraith: Why not just do "foo (constructor _) = ..."
14:33:48 <c_wraith> iqubic: for the case when the constructor has a lot of args
14:34:00 <iqubic> Oh, I see.
14:34:27 <c_wraith> I'd still write them all out, though.  Even if it's silly. :)
14:34:46 <anarcat> iqubic: in this case it does have multiple arguments, so _ doesn't work
14:34:51 <anarcat> iqubic: i could do _ _ _ _ _
14:34:57 <iqubic> anarcat: I realize that now.
14:35:01 <anarcat> but that looks silly, hence the original question (i used a b c d e)
14:35:12 <anarcat> plus pandoc has this "fun" habit of changing those arguments between versions, which breaks the filter
14:35:36 <c_wraith> in that case, you probably are better off with the empty record match
14:35:56 <anarcat> yup
14:35:57 <anarcat> thanks
14:37:07 <Eduard_Munteanu> I tend to use {..} quite a bit, but that's different.
14:37:40 <anarcat> yeah, i read up on http://book.realworldhaskell.org/read/defining-types-streamlining-functions.html
14:37:53 <anarcat> patch ends up being: https://gitlab.com/anarcat/scripts/commit/936d4d5aee69be13ff606025538c7ee44bc952ae
14:38:17 <anarcat> whole filter: https://gitlab.com/anarcat/scripts/blob/master/lwn-clean.hs
14:38:50 <anarcat> i tried to cleanup "cleanBlock (Div (_, _, _) body) = body" the same way, but for some reason "cleanBlock (Div {} body) = body" fails
14:39:44 * anarcat shrugs
14:40:08 <geekosaur> I'm not sure how you understand the {} there
14:40:23 <geekosaur> (X {}) is X followed by an arbitrary number of _s.
14:40:34 <geekosaur> you cannot intermix it with non-_s
14:41:00 <Eduard_Munteanu> If Div is defined as a record with a body field, you can write   Div { body }
14:41:07 <geekosaur> it's a degenerate case of projecting fields out of a type declared record style
14:41:51 <Eduard_Munteanu> Or Div { body = body }
14:43:12 <anarcat> Eduard_Munteanu:     Illegal use of punning for field ‘body’
14:43:12 <anarcat>     Use NamedFieldPuns to permit this
14:43:25 <geekosaur> yes that's why they ewrote it the second way
14:43:30 <anarcat> is ghc trying to do comedy here? :p
14:43:33 <Eduard_Munteanu> anarcat, yeah, you need to enable that extension.
14:43:33 <geekosaur> the first is an extension
14:43:39 <Eduard_Munteanu> :)
14:43:46 <anarcat> ha
14:43:53 <anarcat> then i get: /home/anarcat/bin/lwn-clean.hs:49:19: error: Not in scope: ‘body’
14:43:57 <anarcat> cleanBlock (Div { body = body }) = body
14:44:11 <geekosaur> (he pu here being that you are simultaneoulsly using body as a field name and as a local binding)
14:44:16 <anarcat> body = body = body = body?
14:44:22 <Eduard_Munteanu> anarcat, you need to use the actual field accessor name
14:44:26 <geekosaur> much the same way language puns are about interpreting a word or phrase in multiple ways
14:44:35 <Eduard_Munteanu> I don't know if it's 'body'.
14:44:39 <anarcat> oic
14:45:21 <anarcat> constructor should be something like this: http://hackage.haskell.org/package/pandoc-types-1.17.0.5/docs/Text-Pandoc-Definition.html#t:Block
14:45:28 <anarcat> cleanBlock (Div { body = [Block] }) = body
14:45:30 <anarcat> this also fails
14:45:36 <anarcat>     Not in scope: data constructor ‘Block’
14:45:55 <Eduard_Munteanu> anarcat, ah, you can''t really do it then
14:46:02 <anarcat> okay :)
14:46:09 <Eduard_Munteanu> Just use Div _ body
14:46:37 <anarcat> ack
14:47:23 <anarcat> Eduard_Munteanu: thanks@!
14:47:27 <anarcat> er s/@//
14:47:38 <anarcat> or @ = "" maybe? :p
15:11:46 * hackagebot translate-cli 0.1.0.0 – Translation cli tool – https://hackage.haskell.org/package/translate-cli
15:16:16 <saurabhnanda> when I call `cancel` on an async, all the child asyncs are also cancelled (irrespective of whether they were spawned via async or withAsync)?
15:16:44 <Lokathor> i think the children have to have been spawned via withAsync for it to propagate down
15:16:58 <Lokathor> otherwise they're not children at all, they're just their own loose threads
15:19:50 <c_wraith> saurabhnanda: you can also use link and link2 to ensure exceptions propagate between asyncs in whatever way you like
15:20:44 <saurabhnanda> the behaviour that I'm observing is that the children are being killed without the use of withAsync, which is why I'm confused. Is there a chance this is going to blow-up in production?
15:22:51 <Lokathor> saurabhnanda, that is quite unexpected honestly
15:24:46 <saurabhnanda> main asyncs thread A. Thread A asyncs Thread B and Thread C. Earlier, when I wasn't calling `cancel` upon exiting main, Thread A, B & C kept running in **GHCi**. Now, I'm calling `cancel` on Thread A, and the Thread B & C also appear to be getting cancelled.
15:26:07 <saurabhnanda> tried again... same behaviour. `cancel` seems to be working on children threads as well.
15:26:51 <EvanR> ghci does act differently i think
15:46:04 <saurabhnanda> if I've added a **value** based validation to an aeson field, how do I fail the parsing such that aeson can automatically report which key didn't parse? i.e. the error-string is very different when a key is missing vs when I use "fail" manually. 
15:50:30 <EvanR> validation might be better after parsing
15:50:56 <Lokathor> so do we want smaller typeclasses so that you can be more specific about your constraints, or do we want bigger typeclasses where sometimes you use a default that's technically unsound
15:51:07 <monochrom> aeson has a way for you to specify errorr messages.
15:51:09 <EvanR> honestly json parsing and attoparsec parsers error messages suck
15:51:44 <lyxia> saurabhnanda: https://hackage.haskell.org/package/aeson-1.2.2.0/docs/Data-Aeson-Types.html#v:explicitParseFieldMaybe
15:51:45 <saurabhnanda> EvanR: completely agree.
15:52:20 <EvanR> write a validator which collects all the kinds and locations of problems found in the data
15:52:40 <EvanR> found nothing = valid
16:05:40 <Gurkenglas> Looking for ([a] -> a) -> [a]
16:06:13 <EvanR> erhm... how would you use the function
16:06:18 <EvanR> the function argument
16:06:27 <EvanR> pass in [] ?
16:06:44 <monochrom> What should the function do?
16:06:51 <EvanR> how would it give an a
16:06:54 <Gurkenglas> Yep, then pass each result list to get the next element
16:07:34 <EvanR> oh
16:07:43 <EvanR> not rank 2
16:07:45 <Gurkenglas> \f -> fix $ map f . inits
16:08:03 <monochrom> @type \f -> fix (map f . inits)
16:08:04 <lambdabot> ([a] -> a) -> [a]
16:08:36 <monochrom> > (\f -> fix (map f . inits)) (sum :: [Int] -> Int)
16:08:40 <lambdabot>  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0...
16:10:17 <monochrom> > take 1 (inits undefined)
16:10:19 <lambdabot>  [[]]
16:10:25 <monochrom> > take 2 (inits undefined)
16:10:29 <lambdabot>  [[]*Exception: Prelude.undefined
16:11:42 <Tuplanolla> > take my life
16:11:45 <lambdabot>  error:
16:11:45 <lambdabot>      • Couldn't match expected type ‘[a]’ with actual type ‘Doc’
16:11:45 <lambdabot>      • In the second argument of ‘take’, namely ‘life’
16:12:21 <Tuplanolla> Cursed Asimov's laws.
16:12:39 <monochrom> > take 2 (inits (0 : undefined))
16:12:41 <lambdabot>  [[],[0]]
16:13:32 <monochrom> > (\f -> fix (map f . inits)) ((\xs -> if null xs then 4 else sum xs) :: [Int] -> Int)
16:13:35 <lambdabot>  [4,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,262...
16:14:16 <monochrom> > (\f -> fix (map f . inits)) ((\xs -> if null xs then 4 else last xs) :: [Int] -> Int)
16:14:19 <lambdabot>  [4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4...
16:15:02 <EvanR> > take my wife . please
16:15:05 <lambdabot>  error:
16:15:05 <lambdabot>      • Couldn't match expected type ‘b0 -> c’ with actual type ‘[a0]’
16:15:05 <lambdabot>      • Possible cause: ‘take’ is applied to too many arguments
16:19:55 <orzo> http://lpaste.net/644454912142344192
16:20:11 <orzo> ghci lets me assign to 5*6
16:20:34 <Tuplanolla> Wrong assessment, orzo.
16:20:48 <Tuplanolla> It lets you define another `*` that shadows the previous `*`.
16:21:04 <orzo> oh
16:21:13 <orzo> well that's wonky anyway
16:21:20 <orzo> maybe the "let" should be required for infix
16:21:39 <Tuplanolla> I think getting rid of requiring `let` in GHCi was a mistake.
16:22:26 <orzo> i was doing math and my shift key didn't work
16:22:29 <orzo> so i wrote an =
16:22:32 <orzo> then i correctedd
16:22:38 <orzo> and was getting wrong answers
16:22:46 <orzo> because i unwittingly defined a function
16:23:44 <orzo> i guess it's not really safe to use ghci as a desktop calculator anymore
16:25:14 <hpc> literally unusable :P
16:25:15 <Gurkenglas> I think requiring `let` in do blocks should also be gotten rid of.
16:25:45 <Tuplanolla> That would've been another good option.
16:25:52 <orzo> why?
16:25:55 <hpc> i think let makes a nice signal in do-blocks that this isn't a "real" line of code
16:26:16 <hpc> when i look at a do-block, the way i read code shifts to each line being a step of a computation
16:26:21 <Gurkenglas> Because my formatting's destroyed whenever a definition in a do block isn't monadic
16:26:23 <hpc> and let-in isn't one of those steps, it's just a definition
16:26:51 <orzo> you could use x <- return value
16:26:54 <EvanR> is let !x = foo bar baz a step of computation?
16:27:42 <orzo> i don't mind let in do blocks
16:27:42 <hpc> EvanR: in the context of a do-block, no
16:27:47 <hpc> it's not delimited by (>>=)
16:27:51 <Gurkenglas> orzo, that's even less nice for function definitions
16:27:54 <EvanR> erm...
16:28:08 <EvanR> yet computation will "happen there" before continuing
16:28:29 <EvanR> it matters whether you "defined" x to be an error
16:28:40 <orzo> i have an issue where i like to define things close to where they are used and scoped to where they're needed
16:28:54 <orzo> but that leads to worse efficiency in ghc
16:28:55 <hpc> EvanR: will that line call the relevant fail if the pattern match doesn't succeed?
16:29:05 <orzo> ghc prefers top-level bindings
16:29:17 <EvanR> its an x, it succeeds
16:29:27 <Gurkenglas> I'd like a definition somewhere for \f x -> iterate (>>= f) (pure x)
16:30:09 <orzo> Control.Monad.Loops.iterateM_
16:31:05 <nicknight> Hi any one using arch linux how can I install haskell on arch linux using pacman?
16:31:21 <Gurkenglas> That's (a -> m a) -> a -> m b instead of (a -> m a) -> a -> [m a] or even (a -> m a) -> a -> m [a], not all monads a strict jeez
16:31:27 <Gurkenglas> *are
16:32:27 * hackagebot data-diverse 1.2.0.0, hasql-cursor-query 0.4.3, hasql-cursor-transaction 0.6.2
16:32:27 * hackagebot  → https://hackage.haskell.org/packages/recent
16:32:32 <orzo> what would you call your dodad/
16:32:40 <hpc> nicknight: arch has had issues with haskell packaging for a while - not sure if they have been fixed yet, but you're better off not using pacman
16:32:43 <jmcarthur> nicknight: These days, I'd say it's nicest to do:   pacman -S stack; stack setup
16:32:43 * hackagebot data-diverse 1.2.0.0, hasql-cursor-query 0.4.3, hasql-cursor-transaction 0.6.2
16:32:43 * hackagebot  → https://hackage.haskell.org/packages/recent
16:32:56 <hpc> nicknight: the easiest way to get started is stack (which you can safely use through a package manager)
16:33:02 <Hafydd> What does it mean to 
16:33:07 <Hafydd> to "install Haskell"?
16:33:10 <hpc> nicknight: which will do all of its builds in a reproducible sandbox environment
16:33:26 <hpc> nicknight: or you can download ghc from haskell.org and install it manually
16:33:45 <jmcarthur> Hafydd: It just means either not knowing that Haskell is not the name of the compiler or not caring to distinguish between the language and the compiler.
16:34:04 <jmcarthur> And I'd say either is fine and understandable.
16:34:54 <orzo> long live ghc
16:35:01 <orzo> there can be only one
16:35:02 <jmcarthur> (I say in case what I said seemed to imply some sort of judgement.)
16:35:27 <jmcarthur> orzo: I wish not.
16:35:36 <hpc> vanishingly few languages nowadays differentiate between the language and the implementation
16:35:47 <jmcarthur> orzo: Long live GHC, yes, but there can be only one, no.
16:36:10 <orzo> it's the law of the hilander
16:37:09 <nicknight> ok thank you hpc  jmcarthur 
16:37:18 <jmcarthur> The Glorious Glasgow Highlander Compilation System
16:44:06 <Gurkenglas> orzo, probably iterateM for the m [a] version and maybe iteratem for the [m a] version
16:44:58 <monochrom> Even haskell.org says "download haskell"
16:47:09 <orzo> i want people to use haskell more
16:47:19 <monochrom> Why?
16:48:11 <orzo> cause i like it better than what they use
16:49:54 <orzo> we should all start shaming go devs
16:50:18 <EvanR> that would be counterproductive
16:50:26 <orzo> probably right
16:50:34 <EvanR> shaming non users is what people in other languages do
16:51:08 <orzo> people don't shame haskellers
16:51:11 <orzo> that i can tell
16:51:15 <EvanR> we should shame ourselves for not making the next  better-than-haskell
16:51:24 <orzo> naw
16:51:30 <orzo> let haskell mature
16:51:45 <orzo> every language has a life cycle
16:52:21 <MarcelineVQ> part of haskell's power is being eternally new, as long as people keep plugging on ghc anyway
16:52:53 <monochrom> I value quality not quantity. I do not want more people to use Haskell. I want instead more quality people to use Haskell, and to replace low-quality people altogether.
16:53:12 <orzo> naw
16:53:17 <orzo> we can clean up the mess
16:53:26 <orzo> the more the merrier
16:53:40 <EvanR> lol
16:53:49 <EvanR> soylent green
16:53:56 <monochrom> I have a PhD, and I really love my grad school days. This still does not imply I'll start advocating that everyone should apply for grad student. The opposite actually.
16:54:19 <orzo> meh
16:55:11 <orzo> would you rather work on bad language-x code, or would you rather work on bad haskell code?
16:55:17 <monochrom> A world in which everyone older than 25 uses Haskell and has a PhD is a dysopia of grade inflation and Haskell watering down. It is not going to be the quality utopia you are thinking of.
16:55:53 <orzo> i don't think you're correctly imagining my vision
16:56:13 <monochrom> Until the day any type error kills the programmer who caused it, Nature simply doesn't have enough selection pressure to churn out quality programmers.
16:56:28 <orzo> i jus twant ot use haskell together with my chums
16:56:40 <orzo> and they are resistent to learning it
16:57:34 <orzo> it wont matter what language they use, they're not gonna be higher quality or lower quality coders
16:57:44 <monochrom> Your "would you rather xxx or yyy" question made a flawed assumption. That Haskell would stay the same regardless of how many people, and who, start using it.
16:58:07 <orzo> you're in denial
16:58:30 <monochrom> But no, if mediocre programmers start using it, they start having their say too, they will change Haskell for the worse, they will change Haskell to bad language-x.
16:58:31 <orzo> haskell is already mainstreaming
16:58:39 <johnw> monochrom: the market really has no interest in programs, period; only the results of programs
16:59:05 <monochrom> There is not going to be any difference between "work on bad language-x code vs work on bad Haskell code", because they will turn Haskell into bad language-x.
16:59:23 <orzo> fud
16:59:28 <johnw> it would be like saying you only want to read books where author uses a particular writing process beforehand
16:59:53 <orzo> haskell is never going to be C. agre or disagree?
17:00:04 <monochrom> Unknown.
17:00:06 <johnw> orzo: what do you mean by that statement?
17:00:15 <johnw> in terms of popularity? function? market share?
17:00:40 <orzo> no, iean literally C.  no more garbage collector or laziness, unsafe pointers, the whole galore
17:00:45 <iqubic> orzo: Haskell will always be a high level programming language. It will be very hard to do low level stuff with Haskell alone.
17:00:52 <johnw> why would that transition happen, when we have C+
17:00:53 <johnw> ?
17:01:04 <orzo> it wouldn thappen. that' smy point
17:01:10 <orzo> that's why monochrome is just being silly
17:01:38 <orzo> at worst haskell will slow down or have some ugly hack tacke don here or there.  It's not going to degreade and become "langauge-x"
17:01:50 <orzo> it's a minor sacrifice, not a major one
17:01:57 <johnw> orzo: so, by haskell you mean the implementation of the runtime?
17:02:27 <johnw> because the System FC layer sure doesn't change often (though it may when dependent Haskell comes)
17:02:28 <orzo> if haskell became ubiquitous, it would not be a disaster an dthere'd be more upsides than down
17:02:41 <johnw> I think you're conflating a lot of things into the word "haskell" here
17:02:47 <iqubic> I want dependent hasell now.
17:03:03 <iqubic> orzo: What do you mean by "Haskell"?
17:03:10 <orzo> dependent haskell is pretty clearly in the works, that will happen regardless at this point
17:04:10 * hackagebot javascript-extras 0.3.2.0 – Extra javascript functions when using GHCJS – https://hackage.haskell.org/package/javascript-extras
17:04:36 <johnw> orzo: that's a confident statement
17:06:38 <orzo> does that mean you disagree, johnw?
17:09:28 <johnw> orzo: it means I'm less certain than you :)
17:09:56 <orzo> i'm pretty sure dependent types are only going to get more important
17:10:06 <orzo> generally
17:10:30 <orzo> haskell will likely have something to contribute on it
17:10:38 <johnw> have you worked in a dependently typed language?
17:10:47 <orzo> a little in idris
17:13:08 <orzo> it was hellish becaues the compiler was a little too raw
17:13:17 <orzo> the error messages were awful
17:13:31 <EvanR> its supposed to be used interactively really
17:13:41 <orzo> later i heard he implemented an error message plugin system, which sounds like a terrible idea to me, heh.
17:13:50 <orzo> yes
17:13:53 <orzo> i was using it interactively
17:13:55 <orzo> but still
17:14:03 <orzo> it was too early
17:14:21 <johnw> one of the main Coq developers announced yesterday a beta version of a library that makes dependent pattern matching far better in Coq; now that would make me use dependent types more
17:14:22 <orzo> i'm sure its in much better shape now, but i've not messed with it since
17:14:49 <iqubic> What even is Coq?
17:14:56 <johnw> what is Coq?
17:15:01 <iqubic> What the hell is a Coq proof?
17:15:09 <orzo> you want dependent haskell now and you've not heard of coq/
17:15:15 <iqubic> Is Coq a programming langague.
17:15:19 <orzo> heh
17:15:19 <iqubic> orzo: That is correct.
17:15:23 <johnw> yes and no
17:15:29 <johnw> it's a functional language, but it has no runtime
17:15:35 <iqubic> johnw: Huh???
17:15:45 <johnw> it is used to write pure, total functions only
17:15:56 <johnw> which can then be extracted to languages that support concepts like IO
17:16:10 <johnw> people are actively working on actual runtimes for Coq, but there isn't one yet
17:16:15 <johnw> you can't write hello world :)
17:16:24 <iqubic> How the heck do you check that a function is total?
17:16:31 <johnw> there are a few checks
17:16:38 <johnw> no partiality in pattern matching
17:16:49 <johnw> all recursion must be well founded
17:17:04 <johnw> there is no such thing as an "exception" or undefined value
17:17:06 <iqubic> I see. And the Coq compiler catches all this?
17:17:06 <monochrom> Today's state of dependent types mirrors 1970s state of term-level programming. That is, in the 1970s, Lisp and C programmers used lists and arrays to encode sets, rather than building an using a real set type (as an abstract type).
17:17:09 <johnw> yes
17:17:25 <johnw> as a result of its theoretic strength, it can be used to do real math
17:17:43 <iqubic> Are there any Coq tutorials around?
17:17:47 <johnw> or prove properties of functional algorithm
17:17:48 <johnw> oh yes
17:17:51 <johnw> quite an excellent one...
17:17:58 <johnw> https://softwarefoundations.cis.upenn.edu/
17:18:00 <iqubic> I want to do theoretical Coq stuff.
17:18:11 <monochrom> Today the way Idris uses a type-level list, rather than a type-level set, for its IO system is merely lifting 1970s sets from the term level to the type level.
17:18:13 <johnw> it's more fun than you'd believe possible, if you like theory and math and types
17:18:41 <monochrom> To be sure, I'm sure 20 years later this will be finally addressed. But don't expect the Dark Age to end any time soon.
17:19:06 <orzo> 20 years is about right
17:19:18 <johnw> yeah, I'd expect 20 years is a good metric
17:19:27 <johnw> Coq is now 36 years old
17:19:46 <iqubic> johnw: is that Coq tutorial free?
17:19:50 <johnw> yes
17:19:52 <johnw> free and interactive
17:19:58 <iqubic> Cool
17:20:01 <orzo> in 20 years, dependent types will suddenly be hip enough that average joe coder will have some interest
17:20:02 <johnw> and depending on where you live, there might be a study group to do exercises together
17:20:24 <iqubic> I live in Seattle.
17:20:25 <johnw> orzo: one way to look at it is that people already think in dependent types, they just can't express them in code
17:20:45 <orzo> in 40 years, there'll be a mainstream popular dpendent type language and people will laugh at the notion that it was considdered esoteric
17:21:24 <monochrom> And even then there can be another wrong turn of events.
17:21:43 <johnw> yeah, not all progress is forward in computer engineering
17:21:56 <monochrom> There is a non-zero chance that the way they fix it 20 years from now is type-level OOP.
17:23:29 <iqubic> Type-level OOP is a stupid idea
17:23:39 <johnw> iqubic: I don't see anything in Seattle area
17:23:42 <jle`> don't bash it til you've tried it
17:23:58 <iqubic> Oh, that's fine.
17:24:09 <iqubic> johnw: How were you searching
17:24:10 <iqubic> ??
17:24:14 <johnw> meetup.com
17:24:22 <WinterFox[m]> What does it mean when a datatype starts with m for example `m ByteString`?
17:24:42 <jle`> WinterFox[m]: m is a polymorphic type constructor
17:24:44 <iqubic> Can we see the full datatype declaration?
17:24:49 <monochrom> It means you can instantiate m to Maybe or [] or IO or...
17:24:50 <jle`> WinterFox[m]: have you ever seen a type like 'Maybe a' ?
17:24:56 <jle`> or 'IO a'
17:25:17 <jle`> or, like 'Maybe ByteString', 'IO ByteString'
17:25:20 <jle`> m is just a type variable there
17:25:39 <jle`> just like how 'Maybe a' can be Maybe Int, Maybe Bool, Maybe String, etc.
17:25:40 <WinterFox[m]> Oh
17:25:49 <jle`> 'm String' can be Maybe String, IO String, etc.
17:25:58 <WinterFox[m]> Ah I get it.
17:26:01 <WinterFox[m]> Thanks.
17:26:02 <jle`> 'm a' can be 'Maybe String', etc.
17:26:08 <jle`> note that it doesn't have to be 'm'
17:26:14 <jle`> it can be any valid type variable name
17:26:31 <Atomic_Mgpne> jle what about t m a?
17:26:34 <jle`> foo ByteString   -- could be Maybe ByteString, etc.
17:26:44 <jle`> Atomic_Mgpne: same deal, t m and a are all type variables
17:26:51 <jle`> so it might be 'Either Int Bool'
17:26:59 <jle`> or (,) String Double   (aka (String, Double))
17:27:10 <jle`> or Bool -> [Int]
17:27:15 <jle`> (which is (->) Bool [Int])
17:27:28 <c_wraith> Or, as you would often see with those specific letters, StateT IO Int
17:27:42 <monochrom> You may need to know the kind of t.
17:27:58 <jle`> if you see 't m a', it's no different than 'foo bar baz', with three type variables
17:28:10 <jle`> or 'a b c'
17:28:14 <Atomic_Mgpne> so if I say 'm t a' that could be equal to 'm t a'? 
17:28:31 <jle`> not necessarily, if those type variables are used in other places in a type signature
17:28:37 <jle`> but in general, type variable names are arbitrary
17:28:53 <monochrom> But clearly m t a is the same as m t a. :)
17:29:11 <jle`> like consider the function map :: (a -> b) -> [a] -> [b]
17:29:21 <jle`> we could have written the type signature as map :: (foo -> bar) -> [foo] -> [bar]
17:29:27 <jle`> or map :: (b -> a) -> [b] -> [a]
17:29:29 <jle`> oh they're gone
17:29:35 <monochrom> I hate foo bar.
17:33:04 <iqubic> monochrom: why do you hate foo bar?
17:34:10 <monochrom> Because it is worse than x y.
17:34:30 <orzo> i don't really consider OO a "wrong turn of events"
17:35:26 <monochrom> Good for you. But a lot of dependent type fans might.
17:35:28 <orzo> sometimes the lowest hanging fruits are not on the best branch over the long term
17:36:22 <EvanR> wanting sets instead of lists, or a quotient of lists, brings us back to equalities, extensionalities
17:36:38 <EvanR> man i missed a lot
17:39:05 <EvanR> computer, i want a quotient... that is... heres what i dont care about, i want to forget it and see what happens
17:39:16 <EvanR> computer says "no idea"
17:40:09 <orzo> threaten to take it to best buy
17:40:47 <EvanR> maybe this is wrong because not caring about something is a negative statement
17:41:01 <EvanR> maybe the computer is waiting to learn what we DO care about
17:57:35 <monochrom> Yes, the computer would want you to make explicit what you care about.
17:57:56 <johnw> I want to see the language that could ever express such things truly.
17:57:57 <monochrom> Or at least I do.
17:59:02 <monochrom> Because if you just asked me for "a representation of sets" but you forgot to tell me what accessors and mutators you expect, I'll just say "OK you don't have an API, so () will do".
17:59:51 <monochrom> And actually in this case it is not just me being too literal and anal and pedantic.
18:00:46 <monochrom> The API for finite sets and the API for infinite sets are very different, even opposite, even if you harp on "oh everyone knows what 'finite set API' means".
18:01:18 <EvanR> i dont know why, but answering "sets huh. what DO you care about... beyond nothing, ()"
18:01:26 <monochrom> So if you even forgot to say the word "finite", no one knows even whether you want it or not.
18:01:33 <EvanR> positively, seems a lot harder than "everything except the ordering"
18:01:40 <monochrom> And as for infinite sets, there are several incompatible options.
18:01:49 <iqubic> Why is #ghc even a thing?
18:02:17 <monochrom> Oh so this is where a training in algebraic specifications is useful.
18:02:28 <iqubic> Like why do people hang out in #ghc?
18:02:28 <geekosaur> because the ghc devs need somewhere to synchronize and discuss work in progress?
18:02:35 <iqubic> I see.
18:03:00 <iqubic> Can I join in and see what their conversation is about?
18:03:10 <jle`> iqubic: #ghc is for GHC development
18:03:11 <monochrom> Because you can now write down an equational requirement like "x `isElemOf` (insert x s) == True"
18:03:18 <EvanR> is there an algebraic theory of sets ?
18:03:35 <monochrom> Yes.
18:04:01 <EvanR> by constrast, what do you call a theory of sets based on lists that you quotient somehow
18:04:10 <iqubic> Can I peer in on the discussion going on in #ghc?
18:04:11 <monochrom> And there are a couple more laws that tells you "order doesn't matter" and "how many times inserted doesn't matter as long as it's at least once"
18:04:21 <monochrom> A model of sets.
18:04:34 <monochrom> It's very simple. "model" = "implementation".
18:05:01 <monochrom> Or construction.
18:05:18 <monochrom> Here is another example. Suppose you want to talk about the real numbers.
18:06:06 <monochrom> You can give field theory axioms plus a completeness axiom and maybe an Archimedian axiom (necessary or redundant depending on which completeness axiom you like).
18:06:28 <EvanR> field theory axioms... 
18:06:31 <iqubic> Are we talking about Peano Aritmetic here?
18:06:32 <jle`> iqubic: most channels don't mind idlers, unless they say so in their topic
18:06:44 <monochrom> The field axioms part is an algebraic theory. The completeness part isn't, but that's just because it is not an equation. The whole thing is still an axiomatic theory.
18:06:45 <EvanR> i heard those arent algebraic
18:06:53 <iqubic> jle`: That's good
18:07:11 <EvanR> because division has a "not equal to zero" in it
18:07:28 <iqubic> How do I view the topic of a channel when using glirc?
18:07:49 <monochrom> But you can also say "the reals are formed by taking Cauchy sequences of the rationals and doing a quotient thing" or "the reals are formed by taking Dedekind cuts of the rationals and doing a quotient thing".
18:07:56 <EvanR> any what does that mean anyway, that your model  / implementation can have a division by zero, and it doesnt matter what it does
18:08:04 <monochrom> Those two are "constructions", "models", "implementations".
18:08:38 <EvanR> so forgetting some difference is a construction
18:09:20 <EvanR> i think maybe its really a construction of an equality
18:09:28 <monochrom> Here is one last example before I go.
18:09:38 <monochrom> Suppose you want to talk about 2-tuples.
18:11:04 <monochrom> You can give its API: a constructor "pair" used as "pair x y", two accessors "fst" and "snd", and a few equations like "fst (pair x y) = x", "snd (pair x y) = y", and maybe also a sentence "pair x y = pair a b  iff  x=a and y=b".
18:11:20 <monochrom> So that is an axiomatic way.
18:11:55 <monochrom> But you can also say, "a 2-tuple is the set {x, {x,y}}" or whatever the typical set theory book tells you.
18:12:03 <monochrom> So that is a construction, model, implementation.
18:12:32 <monochrom> construction = model = implementation = you encode your thing in another theory.
18:13:39 <monochrom> So anyway if you look up "algebraic specification" you'll find a lot more examples and finite set is one of the stereotypical examples. There are also stacks and queues.
18:14:39 <monochrom> And stacks and queues are also cases where you run into partial functions (pop and dequeue) and there are various concessions you have to make, you're right it is no longer perfectly algebraic any more, but it's close enough, people don't really mind.
18:15:39 <monochrom> Just look at how the mathematicians have not expelled fields from their textbooks entitled "algebra".
18:16:07 <EvanR> hmm
18:17:01 <EvanR> so the simple stack spec is broken
18:18:40 <Lokathor> it's been a while so i'll ask again: should typeclasses be broken down into smaller parts so that functions can be clearer about what they really need or should typeclasses be bigger and have defaults that are sometimes faulty
18:19:19 <Lokathor> specifically, if there's a next32 method on an RNG typeclass for making Word32 values, and a next64 for making Word64, the default implementation of next64 is only sound if the period of the generator is 2^64 or more
18:53:21 * hackagebot data-diverse 1.2.0.1 – Extensible records and polymorphic variants. – https://hackage.haskell.org/package/data-diverse
19:06:58 <EvanR> attempting to follow this guide to get ghc to work on rpi http://allocinit.io/haskell/haskell-on-raspberry-pi-3/
19:07:19 <Lokathor> having trouble?
19:07:41 <iqubic> What issues are you running into EvanR?
19:08:08 <EvanR> so far, none
19:08:23 <EvanR> its like an unevaluated thunk
19:08:38 <iqubic> Oh. I see.
19:08:46 <c_wraith> and you're looking for a forcing function?
19:08:54 <iqubic> I like the metaphor.
19:09:00 <iqubic> c_wraith: It's call seq
19:09:22 <EvanR> > take 2 [1, 2, undefined `seq` 3]
19:09:25 <lambdabot>  [1,2]
19:09:58 <iqubic> > undefined `seq` 3
19:10:00 <lambdabot>  *Exception: Prelude.undefined
19:10:09 <iqubic> I broke lambdabot
19:10:37 <EvanR> were in a universal wavefunction, nothing is ever really evaluated
19:14:19 * hackagebot data-diverse-lens 0.5.0.0 – Isos & Lens for Data.Diverse.Many and Prisms for Data.Diverse.Which – https://hackage.haskell.org/package/data-diverse-lens
19:20:28 <Gurkenglas> Is there a way to write a version of .= which works for both StateT and IxStateT?
19:24:03 <Gurkenglas> ((IxMonadState im, im s t ~ m) | (s ~ t, MonadState s m)) => ASetter s t a b -> b -> m ()
19:25:12 <EvanR> i now have stack and a GHC on rpi. And hello world compiled
19:25:20 <EvanR> huzzah... ?
19:25:43 <EvanR> i guess the real challenge now is to install any deps
19:25:52 <Lokathor> EvanR, the worst part is that stack runs like a pile of tar
19:26:26 <Lokathor> and big deps will take ages to compile (and you probably need swap setup for them)
19:26:40 <EvanR> uh
19:26:54 <EvanR> swap on an SD card, that would take ages yeah
19:27:40 <Lokathor> but once the actaul program is all compiled, if you run it directly (not through `stack exec`) you'll be great
19:35:21 <EvanR> k youre not kidding...
19:35:32 <EvanR> at least things are still technically working up to this point
19:36:07 <Lokathor> yeah some deps on the pi aren't "walk and get a coffee" they're like "go for a three course meal"
19:36:14 <EvanR> or would it be faster to design a language in haskell that compiles into C code for rpi
19:36:31 <Lokathor> it's called Rust ;3
19:36:45 <EvanR> uh a language you want to write a video game in
19:36:58 <Lokathor> I'd certainly want to write a video game in rust over C
19:37:07 <EvanR> heh
19:37:19 <EvanR> "I just think in C"
19:48:17 <iqubic> Lokathor: Is Rust good?
19:48:46 <Lokathor> do you like compilation errors that are far more arcane than GHC's compilation errors?
19:48:58 <iqubic> I do indeed.
19:49:03 <Lokathor> do you like not having a REPL?
19:49:19 <EvanR> lol
19:49:49 <iqubic> Lokathor: Rust has no REPL?
19:49:57 <Lokathor> nope
19:50:04 <iqubic> Lack of REPL is why I stopped using Java
19:50:14 <Lokathor> there's some aborted attempts, but nothing even close to serious in the REPL department
19:50:40 <iqubic> What's the best language for game development? Can I use haskell?
19:51:18 <EvanR> you can try
19:51:21 <iqubic> Is Haskell the right language for game development?
19:51:28 <EvanR> i am doing that
19:51:28 <Lokathor> Haskell, if you're careful about it, will make game in the C#/Java range
19:51:43 <Lokathor> and if you're not careful about it you'll still land in the Python range at least
19:51:51 <iqubic> EvanR: What kind of game are you making? What libraries are you using?
19:51:55 <c_wraith> PyGame is popular!
19:52:05 <EvanR> arcade, SDL
19:52:08 <not_a_robot> iqubic: probably C++, if you are willing to put up with it
19:52:13 <iqubic> Lokathor: What do you mean by careful?
19:52:26 <iqubic> not_a_robot: I don't really want to put up with C++.
19:52:33 <iqubic> It's a PITA
19:52:38 <c_wraith> careful means designing everything for performance first
19:52:48 <Lokathor> idiomatic Haskell code isn't always the most memory efficient and speedy
19:52:49 <iqubic> I don't like doing that.
19:53:04 <Lokathor> the normal haskell workflow is to make it work at all, slowly, and then replace it later when it's not fast enough
19:53:15 <iqubic> Lokathor: I know nothing about Haskell Performance hacking.
19:53:41 <not_a_robot> modern C++ isn't too bad. You can even hack in typeclasses, sort of.
19:53:47 <Lokathor> just use unboxed vectors and strict values all over the place and you'll go far enough to make indie games i bet
19:54:08 <iqubic> Lokathor: I don't know what either of those things are.
19:54:17 <Lokathor> well you've got a bit to learn :3
19:54:21 <Lokathor> the path is long, but rewarding
19:55:08 <Lokathor> Rust is Sonic Boom Sonic Boom Sonic Boom Fast (https://www.youtube.com/watch?v=EYW7-hNXZlM) but it's also as thorny as a pile of barbed wire
19:55:23 <not_a_robot> I don't even use haskell, I write C++ but lurk here and read haskell code because the patterns are generally superior and a lot of them translate
19:55:25 <Lokathor> to make any language go fast you have to sit down and learn the best way to use every single part
19:57:44 <Lokathor> but also: your language doesn't always need to go fast
19:58:01 <EvanR> for games, your imagination needs to go fast
19:58:16 <EvanR> you need feedback, instant gratification
19:58:29 <EvanR> not all that is just there already in ghci
19:58:37 <EvanR> thats what missing
19:58:49 <Lokathor> i'm not sure i follow
19:58:55 <EvanR> "if i had a DSL for this, for that"
19:59:46 <EvanR> i keep thinking i need the guts to be an interpreter, then you modify a file and it reloads without recompiling or rebooting the program
20:00:13 <EvanR> maybe the final product is compiled back to haskell somehow
20:00:33 <Lokathor> Haskell need not be a goal, I think
20:00:51 <EvanR> i mean, for extra performance, if necessary
20:01:00 <EvanR> thats a backburner priority
20:01:32 <Lokathor> Haskell has good but not great performance, and a lot of it is that Haskell's memory use is usually nuts
20:02:07 <EvanR> i have avoided that most of the time luckily
20:02:21 <not_a_robot> Lokathor: why's it tend to use so much memory?
20:02:35 <EvanR> after profiling and discovering where the problem is, (not necessarily even my fault)
20:03:17 <Lokathor> not_a_robot, because when you make a new immutable value it allocates a little and forgets the old value, and when you do that a lot it adds up quick
20:03:29 <Lokathor> the actual GC process is fast, but still
20:03:36 <EvanR> if you do that a lot, youre good
20:03:45 <EvanR> if you dont forget... youre screwed
20:04:08 <Lokathor> yeah, that's why you've gotta be watchful
20:04:10 <EvanR> which is unavoidably the case with level data
20:04:18 <EvanR> or assets
20:04:23 <Lokathor> just store your entire game behind a Ptr :P
20:04:30 <EvanR> brilliant
20:04:55 <not_a_robot> Lokathor: so the compiler can't tell if the old value never gets used again, and that it'd be safe to write the new value into the old value's memory?
20:05:22 <EvanR> it can
20:05:34 <Lokathor> it might sorta do that some of the time, but it's not as assured as perhaps a person would like
20:06:03 <EvanR> not_a_robot: haskell programs allocate a large amount per second, and also it gets reclaimed as fast (unless you are accumulating data for some reason)
20:06:43 <EvanR> same phenomenon as "memory leaks" in javascript or python
20:06:50 <EvanR> or ruby
20:07:07 <EvanR> only worse since haskell must allocate to do pretty much anything at all, because immutability
20:07:31 <EvanR> otoh allocation is very cheap in haskell
20:07:55 <EvanR> so the performance of it all is not easy to judge from the arm chair
20:08:35 <EvanR> Lokathor: "hide behind a Ptr" is more properly done, now i think, with compact regions
20:08:36 <Lokathor> plus it's hard to tell when a function will magically fuse and compile to a fast loop in CPU registers or something like that
20:09:17 <EvanR> everything "behind the Ptr" is considered the same thing by the GC, but you can still use it all as normal values
20:09:51 <EvanR> so it lives and dies together efficiently
20:09:54 <Lokathor> I had a benchmark the other day that a generator i had was somewhere from 2x to 40x times faster than StdGen, depending on exactly how you ran it, I assume because some forms used a list and the allocation for the list cells was outweighing everything else
20:10:23 <EvanR> not sure what StdGen was optimized for...
20:10:30 <EvanR> mediocrity ? :)
20:10:40 <Lokathor> ah, well, hmm, perhaps
20:10:46 <Lokathor> it's got not-quite-31-bit output
20:10:51 <Lokathor> always a winner there
20:11:12 <EvanR> "not as bad a rand"
20:11:16 <EvanR> as*
20:11:40 <Lokathor> so anyway, who wants to read my huge long tirade about the random package? https://github.com/Lokathor/pseudorandom-hs/blob/master/Reasoning.md
21:29:11 <woodson> @message
21:29:11 <lambdabot> Maybe you meant: messages messages-loud messages?
21:29:14 <woodson> @messages
21:29:14 <lambdabot> You don't have any messages
22:05:09 <IERed> @guest5081 oh hey, you're close by
22:05:09 <lambdabot> Unknown command, try @list
22:28:58 <woodson> if i perform an IO action in a function can i return a generic type 'a' ? Or is it necessary that I return a IO a?
22:29:27 <jle`> woodson: note that functions in haskell never perform/execute IO actions
22:29:38 <jle`> the most they can do is take exiting IO actions and transform them into new ones
22:29:44 <iqubic> woodson: You have deal with the return type being IO a
22:30:05 <iqubic> You MAY NOT extract the a from an IO a
22:30:06 <jle`> you can't execute any IO actions within Haskell; you can only modify and transform existing IO actions
22:30:11 <jle`> there is no 'a' in an 'IO a'
22:30:17 <jle`> so it doesn't even make sense to "extract" it
22:30:25 <jle`> there is nothing to extract :O
22:30:51 <jle`> an 'IO a' does not contain an 'a' inside it, so it's not even an in-principle thing, it's a nonsensical/illogical thing
22:31:12 <woodson> sorry i never mention extracting a 
22:31:16 <woodson> maybe i wasnt clear
22:31:28 <jle`> oh i was referring to iqubic's language
22:31:34 <iqubic> jle`: People think that way because of [a]
22:31:54 <iqubic> [a] has a whole bunch of a that you can play with.
22:32:02 <woodson> so just to give you guys a bit of context
22:32:06 <cocreature> no it doesn’t, [a] might also not have an a
22:32:18 <iqubic> cocreature: Stop poking hole in my argument.
22:33:03 <jle`> iqubic: some people might think that way, but it definitely doesn't make any sense to do so...
22:33:07 <jle`> IO is nothing like []...
22:33:11 <woodson> so i am playing a bit with STM and i got this for now type Accounts = T.TMVar (Map Int User)
22:33:13 <iqubic> (a,a) has two a for you play with.
22:33:30 <iqubic> :t (,) Int
22:33:32 <lambdabot> error:
22:33:32 <lambdabot>     • Data constructor not in scope: Int
22:33:32 <lambdabot>     • Perhaps you meant one of these:
22:33:34 <woodson> and i would like to have a function that has this users :: Accounts -> [User]
22:33:40 <iqubic> :t (,) 5
22:33:41 <lambdabot> Num a => b -> (a, b)
22:33:50 <woodson> so it would return just the list of Users in the map
22:34:04 <cocreature> woodson: you can’t write this function. you either need IO [User] or STM [User] as the return type
22:34:21 <jle`> woodson: not sure how familiar you are with STM, but a `TMVar a` does not contain any a's, so it doesn't quite make sense to write a TMVar a -> a function
22:34:25 <woodson> cocreature: exactly what i am noticing
22:34:36 <iqubic> Because accessing the value of a T.TMVar is an IO action.
22:35:01 <iqubic> that is why you can't simply get [User]
22:35:16 <woodson> yes that is what i am noticing 
22:35:20 <jle`> there are ways to construct an IO action that can dereference the TMVar
22:35:26 <jle`> as an IO action
22:35:26 <woodson> but now all my function will be IO a
22:35:41 <jle`> but an Accounts -> [User] would be nonsensical
22:35:42 <iqubic> Yes. That does tend to be the case.
22:35:44 <jle`> woodson: no, they would not
22:35:57 <jle`> your "pure" functions would still not involve IO a
22:36:00 <jle`> just your IO actions
22:36:15 <iqubic> Just the function accessing the stuff inside the TMVar will be IO a
22:36:18 <jle`> usually most of your "logic" is actually pure
22:36:26 <jle`> so the functions you write to manipulate the [User]'s might be pure
22:36:36 <woodson> jle: well i consider my STM has a thread that just whole my hashTable
22:36:45 <roi_du_silence> I get /bin/sh: csound: command not found on NixOs
22:36:47 <jle`> you can manipulate [User]'s in a pure way, and your functions to use the [User]'s are all pure
22:36:52 <woodson> jle: now everytime i interact with it i would have to return IO a
22:36:54 <woodson> no?
22:36:56 <roi_du_silence> yet csound is installed
22:37:05 <roi_du_silence> I can't use csound-expression :c
22:37:19 <roi_du_silence> i'll try using stack --nix
22:37:25 <iqubic> woodson: Do you understand how Do notation works?
22:37:30 <jle`> the actual interaction is in IO, but, that's just one aspect of your code.  kind of like a frame/wrapper over your actual logic
22:37:44 <iqubic> Do you know what it means to bind a varible inside a do block?
22:37:45 <jle`> so the bulk of your logic/code/functions could be non-IO
22:38:07 <jle`> it's just the interaction with the hashtable that is an IO action
22:39:38 <jle`> ideally the IO actions you write will be IO actions, and the pure/non-IO logic you have will be non-IO
22:39:43 <woodson> jle: ok so let me give you a bit more of context, let say i have a small server and i want to interact with the stm like a data storage.
22:39:55 <woodson> so i would like to perform easy insert, get, and update
22:40:26 <woodson> and each time return the user that i interacted with
22:40:40 <woodson> would i have to always wrap it in a IO (User)
22:40:51 <woodson> since i have to interact with the stm
22:40:56 <woodson> ?
22:41:38 <jle`> i would avoid thinking of IO as a wrapper
22:41:53 <jle`> if you do an IO action, its type will be IO
22:42:03 <jle`> *if you define an IO action
22:42:10 <jle`> just like, if you define an Int, its type will be Int
22:42:22 <jle`> an insertion into a database is an IO action, so its type will be IO
22:42:36 <jle`> a 'get :: IO User' is not a User wrapped in IO
22:43:01 <jle`> it describes an IO action that gets a user from a database
22:43:07 <woodson> jle: i see i see
22:43:17 <woodson> jle: as i was playing it got clearer
22:43:28 <woodson> i just needed a bit more explanation from you guys
22:44:08 <iqubic> Here is a simple example I wrote up.
22:44:08 <jle`> think of an 'IO User' as an abstract data type that contains "instructions" on how to create a User, if executed by a computer
22:44:17 <jle`> in Haskell we don't ever actually execute IO actions.  we only define them
22:44:25 <iqubic> It shows the seperation of IO and pure functions: http://lpaste.net/6867514824968896512
22:44:38 <jle`> we define them, manipulate them, combine them, create new ones from old ones, etc.
22:44:44 <iqubic> It might not be the best example, because I am super tired.
22:45:50 <woodson> jle: so the logic would be that everytime that i interact with the outside would my return type because and IO to instruct that 
22:46:11 <woodson> an outside interaction was made to get the value i got
22:46:14 <jle`> woodson: what you 'do' with the reuslt might be a pure function
22:46:28 <jle`> but the actual IO action of retrieving the result is an IO action
22:46:33 <roi_du_silence> yeah it works
22:46:40 <roi_du_silence> just need to make a shell file for stack
22:47:46 <woodson> iqubic: thanks my functions looks like this as well 
22:48:27 <iqubic> But if you wanted to make a program that took all the usernames and make them uppercase, only the retrieving and inserting parts need to be IO a
22:48:33 <woodson> i just need to better understand why. As i was playing around with it i was starting to understand it, but i jjust needed a better explanation from you guys
22:48:45 <iqubic> The function to take a name and make it uppercase can be pure, without IO
22:49:25 <geekosaur> you can say that an IO action is a callback. it describes something that will happen at an unspecified time in the future
22:49:53 <woodson> iqubic: yes but it doesnt change the fact that the IO action that executed it needs to return an IO
22:50:11 <woodson> iqubic: which is 'test' correct?
22:50:26 <iqubic> Yes. Correct.
22:50:51 <geekosaur> and you can attach to it pure code to be applied via the callback --- thus it needs to be done 'under' the IO, representing that it's attached to the callback and not operating on the 'IO a' itself. (which we do with fmap or with >>=)
22:50:56 <woodson> wow i got that lightbulb over my head now
22:50:57 <woodson> lol
22:51:10 <woodson> finally something that clicked
22:51:50 <woodson> geekosaur: which is why we got the do notation to bind it 
22:52:02 <woodson> i think im slowly getting there
22:52:05 <geekosaur> in fact the javascript community has been playing with suff like ghcjs (haskell compiled to js) and purescript (which is a haskell-like language compiled to js) specifically because this 'callback' model makes all the callback based stuff they do look like normal code
22:53:00 <woodson> but guys wouldnt a program be filled with IO's then?
22:53:08 <jle`> not necessarily
22:53:24 <jle`> most of your logic might be pure code
22:53:27 <geekosaur> let's say you have a program that reds a line, does a pure operation on it, and prints it
22:53:34 <jle`> it's only specific points that are IO actions
22:53:37 <woodson> ah well only where it interacts with the outside world right
22:53:51 <geekosaur> the pure operation may be arbitrarily complex but can be written entirely purely; the main loop needs to be in IO but not the processing
22:53:57 <woodson> and the other parts can be pure
22:54:08 <jle`> yeah the balance of IO vs. not IO in your code is basically what parts of your code are IO actions, and what aren't
22:54:17 <jle`> and if most of your logic doesn't involve IO, then most of your code won't be IO
22:54:26 <woodson> geekosaur: yes kinda like the callback idea that you have been explaining
22:54:30 <geekosaur> in more complex programs you likely need to do more IO than that, but you still have large amounts of processing that can be written purely and then attached to the IO callbacks with fmap (or <*> which is the infix spelling)
22:54:55 <geekosaur> so we write as much as we can purely and segregate the IO
22:55:12 <woodson> i see i see
22:55:19 <jle`> also consider that for Haskell applications, the entire "product" of your code is a single IO action, which you call 'main'
22:55:44 <jle`> so your entire codebase is defining things.  that's all haskell is.  some things you define will be IO actions, some things you define won't be
22:55:59 <woodson> jle: true
22:56:59 <woodson> geekosaur, jle, iqubic: Thanks for the help its like 2am here and i finally feel like im getting it now
22:57:08 <woodson> need to play around more with it before i forget tho
22:57:10 <woodson> lol
22:57:22 <jle`> np!  and yeah it's something that gets more natural the more you play around with it
22:58:22 * hackagebot persistent-template 2.5.3 – Type-safe, non-relational, multi-backend persistence. – https://hackage.haskell.org/package/persistent-template
22:58:52 <iqubic> main = interact id
22:59:31 <iqubic> geekosaur: that's the best way to make a program that reads a line, does a pure operation, then prints it.
22:59:36 <iqubic> :t interact
22:59:37 <lambdabot> (String -> String) -> IO ()
22:59:58 <geekosaur> actually that processes a lazy stream, even more general than a line
23:00:18 <iqubic> What does that mean?
23:00:22 <iqubic> A lazy stream?
23:00:26 <geekosaur> and, well, laziness may actually end uyp being harder for you to wrap your head around
23:01:12 <iqubic> I know what laziness is.
23:01:24 <geekosaur> Haskell lists are lazy streams. you can think of the list constructor (:) as a crank, and each time you turn the crank another list element pops off the front
23:01:35 <iqubic> I see how that works.
23:01:39 <geekosaur> yeh that last was more aimed at woodson, I should have said that
23:02:22 <geekosaur> in  the case of interact, the String comes from getContents which gives you a 'pure' list with an IO action generating it behind the scenes
23:02:38 <geekosaur> (take a look at unsafeInterleaveIO)
23:02:53 <iqubic> I see. But interact doesn't give you access to the underlying list does it?
23:04:01 <geekosaur> there is no underlying list. evaluating a (:) does a read
23:04:12 <Edo> f
23:05:12 <Edo> l
23:05:18 <geekosaur> this is unsafeInterleaveIO at work; demanding the value of 'a' as the description puts it, evaluates only to the next constructor (as usual for Haskell lazy evaluation) so it reads one character and gives it to you
23:05:23 <iqubic> what's going on Edo?
23:05:38 <Edo> l
23:06:11 <Edo> l
23:06:17 --- mode: ChanServ set +o monochrom
23:06:26 --- mode: monochrom set -o monochrom
23:06:33 <iqubic> :t unsafeInterleaveIO
23:06:35 <lambdabot> error: Variable not in scope: unsafeInterleaveIO
23:06:48 <iqubic> Err...
23:09:56 <c_wraith> lambdabot doesn't do IO, let alone things with "unsafe" in the name. :)
23:10:46 <iqubic> Giving us the types should be fine though.
23:11:39 <geekosaur> :t System.IO.Unsafe.unsafeInterleaveIO
23:11:41 <lambdabot> IO a -> IO a
23:12:26 <geekosaur> it is fine with that, but unsafe* isn't in the Prelude or commonly imported modules
23:14:59 <pacak> % getDirectoryContents "." -- yahb does IO and unsafe stuff.
23:14:59 <yahb> pacak: [".","..","1","t.lua","repeat.sh","test.lua","kaboom.sh","hello.lua","t.sh","\56528\56511\56528\56504\56528\56500\56528\56510\56529\56448","test"]
23:15:56 <iqubic> What the hell is yahb?
23:16:10 <iqubic> Why does no one use it?
23:16:55 <pacak> iqubic: Second haskell bot. I used when whant to show something with unsafeCoerce for example.
23:17:12 <pacak> % unsafeCoerce [True] :: Maybe Bool
23:17:13 <yahb> pacak: Just True
23:17:33 <Edo> 1
23:17:57 <jle`> % readFile repeat.sh
23:17:58 <yahb> jle`: ; <interactive>:9:1: error:; * Couldn't match expected type `b0 -> c' with actual type `IO String'; * Possible cause: `readFile' is applied to too many arguments; In the first argument of `(.)', namely `readFile repeat'; In the expression: readFile repeat . sh; In an equation for `it': it = readFile repeat . sh; * Relevant bindings include it :: a -> c (bound at <interactive
23:18:09 <jle`> % readFile "repeat.sh"
23:18:10 <yahb> jle`: "echo \n"
23:18:27 <jle`> not sure what i expected
23:18:40 <ongy> % readSymlink "/proc/self/exe"
23:18:40 <yahb> ongy: ; <interactive>:2:1: error: Variable not in scope: readSymlink :: [Char] -> t
23:19:29 <iqubic> % readFile "\56528\56511\56528\56504\56528\56500\56528\56510\56529\56448"
23:19:30 <yahb> iqubic: "https://lamboard.neocities.org/1.html\n"
23:20:05 <iqubic> % readFile 1
23:20:05 <yahb> iqubic: ; <interactive>:6:10: error:; * No instance for (Num FilePath) arising from the literal `1'; * In the first argument of `readFile', namely `1'; In the expression: readFile 1; In an equation for `it': it = readFile 1
23:20:10 <iqubic> % readFile "1"
23:20:10 <yahb> iqubic: "*** Exception: 1: hGetContents: invalid argument (invalid byte sequence)
23:20:25 <iqubic> % readFile "t.lua
23:20:25 <yahb> iqubic: ; <interactive>:8:16: error: lexical error in string/character literal at end of input
23:20:27 <iqubic> % readFile "t.lua"
23:20:27 <yahb> iqubic: "while true do print(\"SPAM\") end\n"
23:20:39 <ongy> please don't overdo it in the channel
23:20:45 <iqubic> I won't
23:20:54 <ongy> pacak: are you running that bot?
23:21:10 <pacak> ongy: Nope.
23:21:13 <cocreature> ongy: iirc yahb is mniip’s bot
23:22:06 <mniip> yes
23:22:30 <ongy> how do you protect it against misuse? oh it doesn't answer in query?
23:22:35 <iqubic> Why does it have random files lying around that it can show us?
23:22:35 <mniip> it does
23:22:42 <mniip> iqubic, it's a public sandbox
23:22:55 <mniip> those are files some people wrote
23:23:01 <iqubic> Oh, I see.
23:23:16 <jle`> % writeFile "README.md" "Hi."
23:23:16 <yahb> jle`: 
23:23:35 <pacak> mniip: It's a very handy bot sometimes, thanks :)
23:24:09 <mniip> 1508048533 [09:22:13] <ongy> how do you protect it against misuse? oh it doesn't answer in query?
23:24:14 <mniip> Basically, magic. And it does
23:24:26 <iqubic> % readFile "README.md"
23:24:26 <yahb> iqubic: "Hi."
23:24:42 <iqubic> Looks like people can write random files to the bot.
23:25:05 <mniip> yes
23:26:38 <ongy> at least give me /proc :(
23:26:58 <iqubic> ongy: I don't think you want that.
23:27:25 <mniip> ongy, there is limited proc, what do you want
23:28:11 <ongy> there is? listDirectory "/proc" gives me a directory doesn't exist. and just poke around :) proc is mostly readonly for non-root either way
23:28:24 <mniip> % getDirectoryContents "/proc/self"
23:28:25 <yahb> mniip: [".","..","task","fd","map_files","fdinfo","ns","net","environ","auxv","status","personality","limits","sched","autogroup","comm","syscall","cmdline","stat","statm","maps","numa_maps","mem","cwd","root","exe","mounts","mountinfo","mountstats","clear_refs","smaps","pagemap","attr","wchan","stack","schedstat","cpuset","cgroup","oom_score","oom_adj","oom_score_adj","loginuid","sessionid","coredump_fi
23:28:43 <iqubic> mniip: Why is yahb a thing?
23:28:58 <mniip> iqubic, originally it was yalb, but then I managed to run haskell on it
23:29:12 <iqubic> I see.
23:29:14 <mniip> it has advantages compared to lambdabot so I decided to put it up as a separate bot
23:29:24 <iqubic> What are the advantages?
23:29:37 <mniip> IO
23:29:39 <mniip> unsafeCoerce
23:29:50 <mniip> it's a full blown ghci session
23:29:51 <ongy> % getDirectoryContents "/proc" -- what
23:29:52 <yahb> ongy: *** Exception: /proc: getDirectoryContents:openDirStream: does not exist (No such file or directory)
23:29:57 <mniip> ongy: magic
23:30:03 <iqubic> mniip: It is?
23:30:04 <ongy> how does /proc/self exist, but /proc doesn't?
23:30:08 <mniip> ongy: magic
23:30:14 <mniip> iqubic, well yes
23:30:19 <iqubic> Cool.
23:30:20 <mniip> % :set -dppr-debug
23:30:20 <yahb> mniip: 
23:30:22 <mniip> % :t id
23:30:22 <yahb> mniip: id :: a -> a
23:30:26 <mniip> hm
23:30:34 <mniip> that's not a :set option...
23:30:40 <ongy> do you do that in the bot, or did you get your system to pretend that'
23:30:43 <ongy> that's the case?
23:31:17 <mniip> ongy, er? what's the difference?
23:31:30 <mniip> :set -fprint-explicit-foralls is the thing
23:31:33 <mniip> % :t id
23:31:33 <yahb> mniip: id :: forall {a}. a -> a
23:31:48 <ongy> I would understand it's possible to have the bot pretend it, but I'm not sure how I'd get linux to do so. unless that's part of your custom kernel :)
23:32:21 <mniip> well it depends on what you consider part of the bot
23:33:14 <iqubic> How bad would it be if typed "% :q" into this channel?
23:34:12 <iqubic> Would that shut off yahb?
23:34:13 <mniip> it will just restart the ghci process
23:34:35 <mniip> it does that every time the program times out, runs out of memory, or produces too much output anyway
23:34:36 <iqubic> Oh, so you have it set up to automatically reset the process?
23:34:45 <iqubic> % :q
23:34:46 <yahb> iqubic: 
23:35:42 <ongy> and you are doing the same magic in /sys :( let me poke your system
23:35:59 <mniip> ongy, you can use %! for a bash shell
23:36:51 <MUWASEC> Testing...
23:37:37 <ongy> %! ls /
23:37:38 <yahb> ongy: ls: cannot access /: No such file or directory
23:37:49 <ongy> is the bot source accessable? I want to know what magic you are doing
23:38:06 <mniip> ongy, somewhat
23:38:31 <mniip> ongy, this should answer your questions https://github.com/mniip/sandbox
23:38:33 <iqubic> %! ls /proc/self
23:38:33 <yahb> iqubic: attr; autogroup; auxv; cgroup; clear_refs; cmdline; comm; coredump_filter; cpuset; cwd; environ; exe; fd; fdinfo; gid_map; io; limits; loginuid; map_files; maps; mem; mountinfo; mounts; mountstats; net; ns; numa_maps; oom_adj; oom_score; oom_score_adj; pagemap; personality; projid_map; root; sched; schedstat; sessionid; setgroups; smaps; stack; stat; statm; status; syscall; task; timers; timerslack_ns; uid_map; wchan
23:38:56 <iqubic> %! ls /proc
23:38:56 <yahb> iqubic: ls: cannot access /proc: No such file or directory
23:39:09 <iqubic> What the actual heck?
23:39:17 <iqubic> What magic is this?
23:41:08 <ongy> mniip: yes, that makes sense
23:41:48 <iqubic> What magic is that?
23:42:03 <ongy> #! wget ongy.net/secret
23:42:09 <ongy> %! wget ongy.net/secret
23:42:09 <yahb> ongy: bash: line 1: wget: command not found
23:42:13 <ongy> %! curl ongy.net/secret
23:42:13 <yahb> ongy: bash: line 1: curl: command not found
23:43:03 <mniip> I could probably give it a netns with a tor tunnel but I don't care enough
23:44:22 <ongy> can you route an entire netdev over tor? I thought it only supports socks
23:44:44 <mniip> I hear there are ways to fit one into another somehow
23:45:12 <mniip> at least, a friend of mine somehow ran qemu via something like that
23:57:20 * hackagebot unliftio 0.1.1.0 – The MonadUnliftIO typeclass for unlifting monads to IO (batteries included) – https://hackage.haskell.org/package/unliftio
