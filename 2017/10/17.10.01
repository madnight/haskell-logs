00:27:39 <d6e> :r
00:31:28 <jle`> Prelude>
01:11:22 <srhb> Yikes, aeson fromJSON error messages can be really unhelpful...
01:11:35 <srhb> Is there an alternative json parser with better error messages out there?
01:12:09 <Peaker> Hey, trying to use "pretty" - and horizontally concat'ing 2-liners isn't forming 2 horizontal lines but goes down 1 line in each step :-( What are some nice pretty printing libs that can "draw" more freely?
02:35:56 <schoppenhauer> hi. when using -fprof-auto, I get call-stacks on errors. however, these call-stacks do not go beyond the module in which they were called. how can I get a call stack beyond the module?
02:39:24 <schoppenhauer> those stack traces show me only the function from the module that throws the error, but not the ones that call this function, which is the thing that interests me originally.
02:41:52 <Jinxx> Hello guys, can someone please help me
02:42:40 <schoppenhauer> ah got it, -O3 was the culprit
02:43:33 <Jinxx> i moved into new apartment and there are 3 wifis here, i have password for one, after connecting when i visit 192.168.0.1 i get the password for one, 192.168.1.1 and i got the password for another wifi
02:43:42 <maerwald> schoppenhauer: the call-stack is emulated anyway
02:43:45 <Jinxx> what ip should i use to get the 3rd wifi
02:44:00 <Jinxx> i am not able to access 3rd wifi using any combination of p
02:44:02 <Jinxx> ip^
02:44:03 <srhb> Jinxx: I don't think this has anything to do with Haskell the Programming Language (the topic of this channel)
02:44:22 <srhb> Jinxx: Perhaps try to find a support channel where it's on-topic.
02:44:31 <Jinxx> no help eh ?
02:44:42 <Jinxx> okay
02:44:45 <maerwald> no, we also give no dating advice here
02:45:06 <Jinxx> i am a gay, i dont need dating
02:45:07 <Jinxx> seeyah
02:45:46 <maerwald> errr
04:59:56 <haskell_noob> i am trying to evaluate cloudhaskell : i have a dozen or so database writers and i want to distribute the location of the key upon commit/rollback. Does anyone see any issue with this approach?
05:03:16 <haskell_noob> #haskell-distributed
05:06:37 <the_2nd> I have a list of fs f1 :: a -> b and one a and would like to create a list of b
05:06:43 <the_2nd> how do I do this?
05:07:08 <the_2nd> by applying all functions in the list to a to get a list of the results
05:07:57 <tomsn> [fcn1,fcn2,...] <*> [a_item] maybe?
05:08:03 <tomsn> this will create a list of b
05:08:52 <dibblego> > sequence [(+1), (*2), (+10)] 17
05:08:55 <lambdabot>  [18,34,27]
05:10:54 <the_2nd> tomsn, dibblego both working and nice, thanks
05:13:45 <mniip> > fmap ($ 17) [(+1), (*2), (+10)]
05:13:48 <lambdabot>  [18,34,27]
05:13:49 <mniip> is what I would do
05:15:12 <mniip> though that sequence trick is nice
05:15:23 <mniip> even if it depends on Traversable [] and Applicative (->)
05:18:59 * hackagebot treefold 0.1.0.0 – <i>Added by oisdk, Sun Oct 1 12:13:01 UTC 2017.</i> – https://hackage.haskell.org/package/treefold
06:01:47 <stevenxl> monochrom: I fixed the instances we talked about for EitherT. I'm not sure why I stared at this for an hour yesterday, but it came to me in seconds today:
06:02:20 <stevenxl> https://www.irccloud.com/pastebin/6DlUkQ1E/eithert_applicative
06:02:29 <stevenxl> (Line 18)
06:04:18 <stevenxl> Hi folks. I'm trying to implement the following function: eitherT :: Monad m => (a -> m c) -> (b -> m a) -> EitherT  a m b -> m c. Here is my implementation so far (I want to refactor this later and use <=< for example, but I just want to get it working). 
06:04:19 <stevenxl> eitherT f f' (EitherT m) = m >>= \(Right b) -> f' b >>= \(Right a) -> f a
06:05:14 <stevenxl> The problem is the last lambda. it seems like a :: Either t0 a, but I'm not sure how that is the case given that f' b :: b -> m a. 
06:05:50 <stevenxl> Or am I misunderstanding the error?
06:09:56 <stevenxl> hm.. when I implement it this way it works: eitherT f f' (EitherT m) = m >>= \(Right b) -> (f <=< f') b
06:18:55 <`Guest00000> i want a humorous cheatsheet for javascript which includes things like `null >,==,<,>= 0`
06:21:50 <paolino> stevenxl, it's not intercepting the Left coming out of m >>= which should be given to f, Also the signature has a typo
06:22:22 <paolino> well 2
06:22:39 <stevenxl> paolino: Hello. Can you point out the typo?
06:23:08 <paolino> the second function I guess is b -> m c
06:24:24 <stevenxl> Hm.. I don't think that's the case. I think it's supposed to be (b -> m a), as the first function is then applied to the "a" in the "m" context.
06:25:08 <stevenxl> i might be confused
06:25:15 <stevenxl> let me look at this again.
06:25:21 <paolino> if I can follow either semantic
06:25:25 <paolino> :t either
06:25:27 <lambdabot> (a -> c) -> (b -> c) -> Either a b -> c
06:25:49 <stevenxl> paolino: I see your point. Yes I am confused. That is indeed a typo.
06:25:52 <stevenxl> Thank you!
06:28:22 <paolino> you can think of either(T) as dispatching to smash the choices (a `or` b) into a uniform type (c)
06:28:58 <paolino> so it should resolve the choice only once
06:30:21 <tomsn> hey, did sth about ghci's ":sprint <var>" command change? it always shows me "var = _" no matter if i print out the value or not. So thunks stay thunks even after evaluation?
06:30:45 <hpc> is var polymorphic?
06:31:42 <tomsn> ahhh, if i add type annotation it works
06:31:48 <stevenxl> paolino: thank you. I'm going to fix the type signature and try to come up with an implementation so i can follow that description a bit.
06:32:03 <paolino> :t \f g e -> join $ either f g <$> e
06:32:05 <lambdabot> Monad m => (a1 -> m a2) -> (b -> m a2) -> m (Either a1 b) -> m a2
06:32:20 <tomsn> hpc: i guess polymorphic means that the type isnt specified? that was the solution already. thank you!
06:32:32 <hpc> tomsn: what you've encountered is the reason for the dreaded monomorphism restriction
06:32:51 <hpc> making things monomorphic prevents re-evaluation
06:33:32 <hpc> because you know that var :: Int is always going to have the same representation all the time
06:33:46 <hpc> whereas var :: Num a => a, might be Int one moment and Integer the next
06:33:59 <hpc> or if you're lambdabot a few years ago, it might be (a -> Int)
06:34:15 <stevenxl> paolino: I think I follow:
06:34:22 <stevenxl> https://www.irccloud.com/pastebin/dPXCMPcU/
06:35:07 <stevenxl> the monad can result in a Left a value or a Right b value,  and I have two functions, one of which can be applied to the a in Left a and another to the b in Right b. 
06:35:30 <stevenxl> so depending on what the monad returns i just one or the other. 
06:35:41 <stevenxl> in fact, I can use either to do this in a nicer way i imagine
06:35:44 <paolino> can I see the edfinition of EitherT ? Is it yours ?
06:36:09 <paolino> the structure of the computation seems right, now
06:36:19 <stevenxl> paolino: yea it's all mine. these are exercises from the haskell book, i'll put it all up in a gist
06:36:28 <tomsn> hpc: im reading up on monomorphisms right now. i had sth trivial as "let x = 1 + 2" and didnt see that it could be ints, integers, .... thx again!
06:37:11 <stevenxl> paolino: https://gist.github.com/StevenXL/1ea1095afc132b5d814b45d3661fd0b2
06:38:45 <paolino> yep, for some reasons maybe you want to rewrite "e m" in "m e" in the signatures
06:40:33 <paolino> but that doesn't change anything, it's just a cosmetic fact or an help if you want to implement an instance on "e a"
06:41:07 <stevenxl> paolino: That would be much nicer yes. :-). 
06:41:10 <stevenxl> thank you for your help
06:41:23 <paolino> yw
06:46:10 * hackagebot rss-conduit 0.4.2.0 – Streaming parser/renderer for the RSS standard. – https://hackage.haskell.org/package/rss-conduit
06:49:18 <vaibhavsagar> how do I generate a .dyn_o file? https://ghc.haskell.org/trac/ghc/ticket/8104
06:50:20 <vaibhavsagar> and what is dynamicTooMkDynamicDynFlags meant to be used for, if not that?
06:51:20 <Yotam_> What would you call (a->b)->f b -> f a?
06:52:37 <hpc> Yotam_: i keep wanting to say "cofunctor", but that's definitely not it
06:53:04 <hpc> ah, contravariant functor - http://hackage.haskell.org/package/contravariant-1.4/docs/Data-Functor-Contravariant.html#v:contramap
06:53:40 <Yotam_> hpc: cool thanks
06:54:16 <hydraz> cofunctor is `(b -> a) -> f b -> f a`
06:54:34 <hpc> yeah
06:54:41 <hpc> which is Totally Not Functor(TM)
06:55:12 <hydraz> Obviously Not Functor(R)
06:59:10 <Yotam_> What is the diffrence between functor and cofunctor? (I don't see any)
06:59:18 <hpc> Yotam_: that's the joke
06:59:28 <hpc> functor and cofunctor are exactly equal
06:59:40 <Yotam_> Then why the two names?
06:59:56 <hpc> co-whatevers are the categorical dual of whatevers
07:00:07 <hpc> a very loose metaphor would be like negative numbers
07:00:14 <hpc> negative zero is the same as zero
07:00:44 <hpc> the concept of duals is independent of the concept of a functor, and technically you can compute the dual of functor
07:00:53 <hpc> it just happens to be the same as functor once you work it out
07:01:15 <maerwald> never trust functors
07:01:47 <hpc> yeah, they'll borrow your pencil and never give it back
07:02:08 <maerwald> they will break your heart even
07:16:09 <vaibhavsagar> okay, turns out all I had to do was `flip gopt_set Opt_BuildDynamicToo
07:17:39 <epta> what people use nowadays as a bindings to git? Is 'hit' still a thing? 
07:17:44 <epta> @hackage hit
07:17:44 <lambdabot> http://hackage.haskell.org/package/hit
07:18:01 <Athas> Looks dead to me.
07:19:38 <srhb> gitlib has a hlibgit2 backend
07:22:33 <epta> oh, actually there is a @hackage git 
07:22:41 <epta> @hackage git
07:22:41 <lambdabot> http://hackage.haskell.org/package/git
07:39:32 <maerwald> epta: or just spawn git commands :>
08:00:10 * hackagebot Glob 0.9.0 – Globbing library – https://hackage.haskell.org/package/Glob
08:02:23 <`Guest00000> > length + length $ "123"
08:02:25 <lambdabot>  error:
08:02:25 <lambdabot>      • No instance for (Num ([Char] -> Int)) arising from a use of ‘+’
08:02:25 <lambdabot>          (maybe you haven't applied a function to enough arguments?)
08:04:26 <saurabhnanda> in Lucid, does anyone know what the 'a' in `Html a` is for? 
08:04:35 <hexagoxel> A {a = 1, b = 2, c = 3}   or   A { a = 1, b = 2, c = 3 }
08:05:24 <liste> saurabhnanda: Html is a monad transformer
08:05:32 <hpc> saurabhnanda: without knowing anything about lucid, blaze-html does a trick with a phantom type parameter to let you write html documents in a concatenative style with do-notation
08:05:33 <lyxia> saurabhnanda: it's a hole in the HTML tree
08:05:33 <liste> so `a` is the base type of that
08:05:44 <hexagoxel> i think i prefer the more-spaced version.
08:05:54 <liste> saurabhnanda: oh wait, HtmlT is the monad transformer
08:06:00 <liste> Html is HtmlT Identity
08:06:07 <hpc> hexagoxel: i would go with the less-spaced version
08:06:09 <saurabhnanda> liste: yes, HtmlT is the monad transformer. `HtmlT m a`
08:06:51 <saurabhnanda> genererally in a monad/transformer the 'a' is the underlying value that is made available only when the monad is finally run. What is this 'a' in the `HtmlT Identity a`
08:07:05 <hpc> hexagoxel: though it probably depends a bit on what's around it, as far as readability goes
08:07:39 <`Guest00000> hexagoxel: me too
08:08:34 <saurabhnanda> lyxia: what does a "hole in the HTML tree" mean?
08:16:54 <lyxia> Sorry I was mistaken, I was thinking of blaze
08:17:08 <lyxia> lucid is a fancy Writer monad
08:22:51 <liste> saurabhnanda: it's the "result value" of the Html builder, eg foo :: Html Int; foo = pure 5
08:23:09 <liste> not sure what practical use it has
08:24:02 <saurabhnanda> liste: exactly. I'm confused. Isn't the only sensible use-case for HtmlT going to be to evaluate to an actual HTML snippet? What does `Html Int` really *mean*?
08:41:31 <benzrf> saurabhnanda: im pretty sure that the idea is that "Html A" doesnt literally mean an HTML snippet - it's an "action that you run to get an HTML snippet"
08:41:44 <benzrf> which is a trick you need if you want to have cute do-notation for html
08:43:06 <saurabhnanda> hmm okay. For using the do-notation does it *have* to be `HtmlT m a`? Isn't it possible to just hard-code it to `HtmlT m ()` and be done with it?
08:44:37 <benzrf> saurabhnanda: not sure what you mean
08:44:39 <benzrf> hard-code /what/
08:44:46 <saurabhnanda> the `a` type
08:44:54 <hexagoxel> (brittany on dev branch now uses the "A {a = 1, b = 2, c = 3}" layout if there is space in the line)
08:47:04 <bbear> hi
08:47:17 <bbear> I have a problem with infix operators, I don't quite understand how that works
08:48:15 <hpc> what in particular?
08:48:36 <bbear> if I do `take 10 . (filter odd) [1..]`
08:48:53 <bbear> I thought `.` would force to evaluate (take 10) first as a total function.
08:49:01 <bbear> but maybe I was wrong
08:49:07 <hpc> so the way that parses is
08:49:14 <bbear> maybe it will try to join `10` is filter to gether.
08:49:16 <hpc> (take 10) . ((filter odd) [1..])
08:49:20 <hpc> :t (.)
08:49:22 <lambdabot> (b -> c) -> (a -> b) -> a -> c
08:49:28 <hpc> the first argument needs to be a function of some sort
08:49:30 <hpc> :t take 10
08:49:31 <lambdabot> [a] -> [a]
08:49:38 <hpc> so that's fine
08:49:44 <hpc> :t (filter odd) [1..]
08:49:46 <lambdabot> Integral a => [a]
08:49:49 <hpc> but that's not a function
08:49:54 <hpc> :t (filter odd)
08:49:55 <lambdabot> Integral a => [a] -> [a]
08:50:11 <hpc> what you want is for the second argument to be (filter odd)
08:50:27 <hpc> and then the output of that will be some function of type (a -> c)
08:50:32 <hpc> which you pass [1..] to
08:50:37 <bbear> ok so basically
08:50:41 <hpc> > (take 10 . filter odd) [1..]
08:50:43 <lambdabot>  [1,3,5,7,9,11,13,15,17,19]
08:50:56 <bbear> take 10 . filter odd $ [1..] should work then.
08:51:01 <hpc> yep, that works too
08:51:49 <bbear> okay
08:52:41 <bbear> I started to write a blog post about monads in haskell, it ended by describing the evaluation order a little bit thoroughly.
08:57:59 <bbear> is the rightmost infix operator that have its arguments evaluated first ?
08:58:19 <hpc> it depends on the fixity of the operators
08:58:37 <bbear> I don't know what this is.
08:58:45 <hpc> and on the evaluation strategy your implementation uses, and what the definition of the operators is
08:58:59 <bbear> that will be for another blog post.
08:59:23 <hpc> in ghci, if you do :i (.), at the bottom you'll see "infixr 9 ."
08:59:35 <hpc> which says that (.) is right associative, with precedence 9
09:00:03 <bbear> ok, and so if it says infixr, it evaluates the right argument first I suppose.
09:00:04 <hpc> that affects the AST of expressions that use (.)
09:00:40 <hpc> from the AST, then you consider the evaluation strategy
09:01:06 <hpc> to make this easier, let's consider (&&)
09:01:38 <hpc> and the expression true1 && true2 && true3
09:01:57 <hpc> (i am giving them numbers to make the rest of the explanation easier)
09:02:04 <bbear> so it evaluates true3 first ?
09:02:13 <bbear> sry
09:02:21 <hpc> infixr 3 && means that it parses as
09:02:50 <hpc> true1 && (true2 && true3)
09:03:15 <hpc> in tree form, you have the outermost (&&) as the root of the tree
09:03:25 <hpc> with children true1 and (true2 && true3)
09:03:33 <hpc> where the latter is another branch
09:03:38 <hpc> makes sense so far?
09:04:07 <bbear> yes
09:04:09 <bbear> easy
09:04:30 <bbear> but it would be actually
09:04:36 <hpc> so all this gets us is from source code to how the expression is structured
09:04:43 <bbear> true1 && (true2 && (true3)), doesn't it ?
09:05:03 <hpc> now we look at the evaluation strategy
09:05:40 <hpc> we'll assume a lazy evaluation strategy, because it's pretty close to what ghc uses
09:06:07 <hpc> (strictness optimizations are a big difference between ghc and pure laziness)
09:06:59 <monochrom> Oh don't worry, the optimizer will do nothing to this example.
09:07:08 <hpc> laziness doesn't really tell us much on its own unfortunately
09:07:33 <hpc> in some sense, it defers evaluation decisions to the definitions of things
09:07:38 <hpc> so we look at how (&&) is defined
09:07:41 <hpc> @src (&&)
09:07:41 <lambdabot> True  && x = x
09:07:41 <lambdabot> False && _ = False
09:08:29 <hpc> we begin by evaluating the whole AST, and we'll recurse as needed to traverse the parts of the AST that we care about
09:08:42 <hpc> the root is (&&), so we use its patterns
09:08:50 <hpc> the first case is True && x = x
09:09:08 <hpc> so we evaluate the right of the tree and get true1, which is True by our arbitrary definition
09:09:32 <hpc> er, left
09:09:44 <hpc> so we use that case, and the evaluated result of the AST is the evaluated result of the actual right of the tree
09:09:55 <hpc> that's (true2 && true3)
09:09:59 <hpc> so we need to evaluate that
09:10:22 <hpc> we use the cases of (&&) again, get True again, and evaluate true3
09:10:23 <hpc> which is True
09:10:25 <hpc> and we're done
09:10:39 <hpc> so at first glance, it looks like things evaluate left to right
09:10:43 <hpc> but that's not really the case
09:10:49 <hpc> let's define a different (&&)
09:10:55 <hpc> x && False = False
09:10:58 <hpc> x && True = x
09:11:39 <hpc> laziness defers to the patterns of (&&) again, but we're evaluating a different thing this time to pick a case
09:12:05 <bbear> I see the point
09:12:14 <bbear> I see the topic and how lazy evaluation works.
09:12:24 <hpc> :D
09:13:13 <bbear> That's surprisingly simple 
09:13:50 <hpc> most things are once you understand them :P
09:14:14 <bbear> You first compute the AST of evaluation, and the evaluate breadth first from the root node of an expression, as long as it is needed to return a result.
09:14:24 <hpc> yeah
09:14:58 <hpc> there's one last possibility where you can still get ambiguity, btw
09:15:13 <hpc> let's define (==)
09:15:17 <bbear> wait
09:15:17 <hpc> False && False = True
09:15:21 <hpc> er
09:15:25 <bbear> I have a question
09:15:29 <hpc> sure
09:15:38 <bbear> the lower the precedence, the later its arguments are evaluated, right ?
09:16:01 <bbear> For example, `($)` has infixr 0, so its arguments are evaluated last, right ?
09:16:02 <hpc> almost
09:16:21 <hpc> precedence contributes to calculating the AST from source code
09:16:24 <hpc> in something like
09:16:29 <hpc> f . g $ x
09:16:30 <bbear> and then, the second part is evaluated last
09:16:39 <hpc> (.) and ($) fight for precedence
09:16:43 <monochrom> The precedence determines the AST only.
09:16:52 <hpc> lowest precedence divides the expression, and ($) is 0
09:16:56 <hpc> so (f . g) $ (x)
09:17:08 <bbear> and x is evaluated last
09:17:10 <hpc> left and right associativity break ties
09:17:30 <bbear> so what about your last example ?
09:17:39 <hpc> order of evaluation depends on the evaluation strategy and the definitions involved
09:17:59 <hpc> it's a good exercise to work it out yourself for (.) and ($)
09:18:01 <hpc> @src (.)
09:18:01 <lambdabot> (f . g) x = f (g x)
09:18:03 <hpc> @src ($)
09:18:03 <lambdabot> f $ x = f x
09:18:22 <bbear> well in haskell, this is lazy as a default but you can somehow enforce evaluation. BTW, does it happen that you can mess with the AST to force evaluation in some way ?
09:18:51 <hpc> what you should discover here is that you can't conclude anything about the evaluation order of f . g $ x
09:18:52 <bbear> For example, if the evaluation is made first on the left branches, you can build a special AST and then Haskell could be 100% strict ?
09:18:57 <hpc> in fact, it depends on your choice of f and g
09:19:10 <hpc> there are ways to force evaluation to happen in a particular way
09:19:15 <hpc> the big one is seq
09:19:22 <hpc> in rough terms:
09:19:34 <hpc> seq a b = evaluate a, then produce the value of b
09:20:16 <hpc> or from another perspective, seq transforms a thunk b
09:20:21 <hpc> into another thunk that evaluates a first
09:20:29 <hpc> well, "first"
09:20:56 <hpc> it's also possible for seq a b = evaluate b, then evaluate a, then produce the value of b
09:21:18 <hpc> the key thing is connecting the values together
09:21:31 <hpc> there's also pseq, which does enforce ordering iirc
09:21:35 <hpc> and a few others
09:21:53 <hpc> it's very rare that you will need them
09:26:48 <bbear> well, if I understand correctly, lefty operators enforce strictness, while right operators are not.
09:27:09 <bbear> I mean `infixl` enforce strictness because of the basic evaluation strategy in Haskell.
09:27:30 <hpc> fixity affects parsing
09:27:35 <hpc> definitions affect evaluation order
09:27:37 <epta> is there a way to run `new-repl` with some additional package that cabal project is not aware of?
09:27:38 <hpc> they're largely independent
09:27:53 <bbear> hpc: yes, you mean definition implementations.
09:28:18 <hpc> yeah
09:29:43 <hpc> specifically in definitions, pattern matching causes strictness
09:30:19 <monochrom> epta: Maybe make use of --ghc-options or --ghci-options, I haven't tried, I don't know.
09:54:13 <WarzoneCommand> hmm I have some weird issue. I just started a new project (it's a yesod site, created using stack new and some template). Now I added an additional dependency to the library section of the cabal file, and I'm trying to rebuild the app using 'stack build'. However, for some very strange reason, stack is overwriting my cabal file (thus removing the additional dependency again).
09:54:19 <WarzoneCommand> does anyone have an idea *why* this is happening?
09:55:31 <hpc> at the very least you need to tell stack about the dependency, so it can pull it into the build environment in a reproducible way
09:56:07 <WarzoneCommand> the dependency is just in LTS-9.6, and I can even just install it using stack install ....' 
09:56:32 <hpc> make sure it's in your project's stack.yaml
09:56:38 <WarzoneCommand> also, I don't think there is any excuse why stack should be modifying my stack.yaml file 
09:57:17 <WarzoneCommand> why? None of the other dependencies (that are the stackage snapshot) are in the stack.yaml file 
09:57:34 <monochrom> God and Stack work in mysterious ways. Sometimes they teach you a lesson in patience and waiting for God's message.
09:58:19 <WarzoneCommand> err the above hsould have been  'modifying my cabal file'  ofcourse 
09:58:57 <glguy> WarzoneCommand: stack will mess up your .cabal file if you have an hpack file, you can delete the hpack file and just use the cabal one
09:59:30 <dsal> I don't think atomicModifyIORef works the way I think it does.
09:59:38 <dsal> > let someioref = newIORef (0::Integer)
09:59:40 <lambdabot>  <no location info>: error:
09:59:40 <lambdabot>      not an expression: ‘let someioref = newIORef (0::Integer)’
09:59:40 <dsal> > do { r <- someioref ; atomicModifyIORef r (\x -> (x, x + 1)) }
09:59:43 <lambdabot>  error: Variable not in scope: someioref :: m t0error:
09:59:43 <lambdabot>      Variable not in scope:
09:59:43 <lambdabot>        atomicModifyIORef :: t0 -> (Integer -> (Integer, Integer)) -> m b
10:00:27 <monochrom> And lambdabot doesn't work the way you think either.
10:00:50 <dsal> Heh.  I see that.
10:00:53 <monochrom> Coincidence? Conspiracy?
10:01:36 <WarzoneCommand> ah, the package.yaml file I guess, once I got rid of the thing (which seemed to have some additonal setup info) things worked as nomral 
10:01:39 <WarzoneCommand> normal* 
10:01:41 <dsal> Doesn't seem to know newIORef anyway.
10:01:56 <c_wraith> lambdabot doesn't run IO either
10:01:57 <hpc> lambdabot doesn't perform execution
10:01:59 <dsal> Am I doing atomicModifyIORef wrong?
10:02:09 <monochrom> @type atomicModifyIORef
10:02:10 <lambdabot> error: Variable not in scope: atomicModifyIORef
10:02:18 <hpc> @hoogle atomicModifyIORef
10:02:18 <lambdabot> Data.IORef atomicModifyIORef :: IORef a -> (a -> (a, b)) -> IO b
10:02:18 <lambdabot> Data.IORef.Lifted atomicModifyIORef :: MonadBase IO m => IORef a -> (a -> (a, b)) -> m b
10:02:18 <lambdabot> UnliftIO.IORef atomicModifyIORef :: MonadIO m => IORef a -> (a -> (a, b)) -> m b
10:02:50 <hpc> just from the type, it looks like it takes an IORef, plus a function
10:02:56 <hpc> that function takes the value of the IORef as a parameter
10:02:58 <dsal> It returns the expected value, but doesn't actually modify the value in the IORe
10:03:07 <hpc> and produces a new value to put into it, plus a return value
10:03:18 <dsal> Oh.  OOOH
10:03:23 <c_wraith> dsal: that's because the function you're providing doesn't modify the value
10:03:42 <dsal> I thought the first return was a CAS type thing.  I was also wondering why it was returning a b.
10:03:54 <c_wraith> dsal: also, be very wary of keeping a counter in an IORef.  That's a good way to leak a lot of thunks
10:04:39 <dsal> Hmm...  I'm just doing an exercism thing here, but the whole thunk buildup thing is kind of invisible, yeah.
10:05:06 <monochrom> There is atomicModifyIORef' when it matters.
10:05:30 <dsal> That one's not in the docs.
10:05:31 <monochrom> Although, last time I used it in GHC 8.0.2, it did not evaluate as advertised.
10:06:00 <monochrom> It's in my copy.
10:07:00 * hackagebot lattices 1.7 – Fine-grained library for constructing and manipulating lattices – https://hackage.haskell.org/package/lattices
10:07:43 <monochrom> as >>= \a -> let l = delete a as in permutations l >>= \ls -> return $ a : ls
10:08:13 <monochrom> err wrong window
10:08:29 <hpc> oh how embarassing, you pasted haskell in #haskell :D
10:09:54 <Myrl-saki> I was trying to see how that was related with atomicModifyIORef' lol.
10:10:03 <monochrom> haha
10:32:25 <kuribas`> @hoogle (Applicative a, Monoid m) => a m -> a m -> a m
10:32:25 <lambdabot> Prelude (<*>) :: Applicative f => f (a -> b) -> f a -> f b
10:32:26 <lambdabot> Control.Applicative (<*>) :: Applicative f => f (a -> b) -> f a -> f b
10:32:26 <lambdabot> Diagrams.Prelude (<*>) :: Applicative f => f (a -> b) -> f a -> f b
10:33:48 <phadej> :t liftA2 mappend
10:33:49 <lambdabot> (Monoid c, Applicative f) => f c -> f c -> f c
10:36:45 <kuribas`> > (liftA2 (<>) (Just [1]) Nothing, <> (Just [1]) Nothing)
10:36:48 <lambdabot>  error:
10:36:48 <lambdabot>      A section must be enclosed in parentheses
10:36:48 <lambdabot>        thus: (<> (Just [1]) Nothing)
10:36:55 <kuribas`> > (liftA2 (<>) (Just [1]) Nothing, (<>) (Just [1]) Nothing)
10:36:57 <lambdabot>  (Nothing,Just [1])
10:52:07 <ertes> is there any way to reduce two church-encoded recursive data structures in parallel without doing the obvious roundtrip through a non-church encoded type?
10:52:20 <ertes> "parallel" in the sense of "coroutinely"
10:52:33 <ertes> like implementing zipWith for church-encoded lists
10:54:48 <ertes> the type in question is this one: newtype W m a b = W { runW :: forall r. (((m r -> b -> m r) -> a -> m r) -> m r) -> m r }
10:54:58 <ertes> which is a church-encoded version of MealyT from machines
10:55:33 <ertes> and i'm trying to implement (<*>) for it, which is a zip
10:56:25 <[exa]> kyou can go the pop way and pretend that a fancy decorated array type is church-encoded
10:56:33 <mustlearnhaskell> Hi, do you know a tool that can count the lines of code in a haskell project, but excludes imports and type signatures?
10:57:16 <ertes> [exa]: hmm?
10:57:41 <[exa]> mustlearnhaskell: since that requires parsing I doubt there will be one readily available. Why's not regular 'sloccount' not enough?
10:58:24 <[exa]> ertes: by "coroutinely" you mean that it's not actual parallel computation, just separated?
10:58:29 <mustlearnhaskell> [exa], i was just wondering how many "actual" lines of code i have since a lot is imports and type signatures
10:58:44 <ertes> [exa]: like coroutines
10:58:51 <ertes> the way you usually implement a zip
10:59:56 <[exa]> mustlearnhaskell: I'd go with grepping out ^import lines and counting that. Btw type signatures _are_ code.
11:00:02 <ertes> mustlearnhaskell: take a couple of small source files of yours, compute the average percentages, then apply it to your larger files =)
11:00:36 <[exa]> ertes: yeah that's also industry standard for estimating development costs :]
11:00:40 <ertes> mustlearnhaskell: also signatures can have an effect on the meaning of your code (though only a reductive one)
11:01:06 <ertes> mustlearnhaskell: some type signatures aren't even optional
11:02:06 * hackagebot fingertree 0.1.2.0 – Generic finger-tree structure, with example instances – https://hackage.haskell.org/package/fingertree
11:02:26 <geekosaur> ($) is id with a more restrictive signature, asAppliedTo and asTypeOf are both const with more restrictive signatures, ... a signature can enforce relationships between types when nothing else will
11:02:43 <hpc> @src asTypeOf
11:02:43 <lambdabot> asTypeOf = const
11:02:45 <hpc> :t asTypeOf
11:02:47 <lambdabot> a -> a -> a
11:02:48 <hpc> :t const
11:02:49 <lambdabot> a -> b -> a
11:04:04 <[exa]> ertes: about the coroutines, can you extract one "next" from each of the mealy machines?
11:04:32 <ertes> [exa]: yes, but in the church-encoded case you can only do that as part of a fold, so you can't do two at the same time
11:04:44 <Big_G> Is there a list of Haskell projects looking for developers? I've seen a few lists floating around but didn't think they were up to date
11:04:56 <dmwit> ertes: Dunno if you got an answer yet (my connection has been going nuts), but you might like Oleg's article on implementing zip with foldr.
11:05:01 <hpc> Big_G: for the most part, that list is hackage :P
11:05:19 <ertes> [exa]: the problem is basically this: how do you write zipWith for lists, when foldr is the only function you're allowed to use for reducing lists?  in particular you may not use pattern-matching or other means of extracting just a portion of the lists
11:05:27 <hpc> look for a package you think you can contribute to, then follow through to its github page
11:05:36 <ertes> dmwit: could you link me to it?
11:05:42 <[exa]> I guess dwmit has nailed it
11:05:45 <dmwit> I'm looking right now.
11:07:01 <dmwit> http://okmij.org/ftp/Haskell/zip-folds.lhs
11:07:16 <ertes> dmwit: thanks!
11:08:11 <ertes> yeah, that sounds like exactly what i was looking for
11:09:32 <dmwit> ertes: https://stackoverflow.com/q/235148/791604 also looks relevant and is a lot shorter
11:10:16 <dmwit> Oh, wow, irssi is confused. Check this out.
11:10:19 <dmwit__> who am i lol
11:10:36 <dmwit> Time for a reboot. =)
11:11:16 <[exa]> rebooting for a /disconnect, wow.
11:11:40 <geekosaur> enh. I efer to restarting the browser as a 'reboot'
11:11:48 <[exa]> lol ok
11:12:22 <geekosaur> of course modern browsers have taken so much on themselves that it pretty much is (see also the theory behind chromeos >.> )
11:13:16 <[exa]> well my browser reboots in 25s, my OS reboots in like 10s
11:13:34 <[exa]> :]
11:14:38 <geekosaur> (and then there's modern Linux desktops, where we've more or less reinvented old DOS+Windows: the OS is relegated to program loader underlying the 'real' os)
11:16:24 <[exa]> geekosaur: but with much more interpreters!
11:17:06 <tabemann> there is the old "emacs is my OS and linux is my device driver"
11:17:30 <tabemann> updated that should be "firefox is my OS and linux is my device driver
11:18:05 <[exa]> Is there a (named) foldr variant where the function can also return a function that's going to be applied to next item?
11:18:52 <[exa]> (but that way it's probably shorter without foldr, ignore me.)
11:21:40 <ertes> dmwit: ah, i see how it works, but it won't work in my case
11:23:32 <ertes> i'd have to make W more complicated for it to work…  i would have to quantify over arbitrary monad transformers over m, and then use it with something like IdentityT most of the time, and with StateT for parallel reductions
11:25:00 <ertes> newtype W m a b = W { runW :: forall r t. (Monad (t m), MonadTrans t) => (((t m r -> b -> t m r) -> a -> t m r) -> t m r) -> t m r }
11:25:02 <ertes> something like that
11:25:51 <ertes> and that would come with both a performance penalty and code bloat for everything that doesn't require it
11:28:16 <ertes> the reason it works for their church lists is that they are effectless
11:28:38 <ertes> newtype ListT m a = ListT { forall r. (a -> m r -> m r) -> m r -> m r }  -- won't work for this one
11:32:01 <[exa]> ertes: modified original question, can you extract anything from one mealy machine this way without causing an effect?
11:32:37 <ertes> [exa]: no
11:33:00 <ertes> well, yes, you can extract the action that gives you the output and the continuation =)
11:33:05 <ertes> that only requires a function application
11:33:33 <[exa]> so what about just constructing another mealy machine that would run both of them zipped?
11:33:50 <ertes> [exa]: that's exactly what i'm trying to do
11:34:14 <[exa]> oh great, I misread the question then :]
11:34:59 <[exa]> and in the "double simulation in a mealy machine", you have a way to get the "next", right?
11:39:01 <ertes> [exa]: one way to get the next is by converting to MealyT
11:39:05 <ertes> so it's certainly possible
11:40:36 <ertes> the conversion is a traversal though, and so is the back-conversion…  in other words: if i ever go from W to MealyT, i should stay at MealyT
11:41:07 <ertes> going back-and-forth could easily change the asymptotics
11:47:52 <etiago> say, if someone wanted to learn to ¨think in Haskell¨ (if that makes sense?), does anyone have recommended readings? I´m past learning syntax but somehow feel the Haskell I write still has some imperative taste to it if that makes sense
11:48:31 <hpc> good question...
11:48:39 <etiago> does anyone know perhaps some challenges in Haskell which would involve it not only being checked for correctness but also for proper Haskell idioms
11:49:35 <hpc> i don't know of any coding challenges like that
11:49:44 <[exa]> etiago: implementation of State monad is worth doing again from scratch by hand, if you didn't try yet
11:50:03 <hpc> i think as far as learning to think in haskell, just keep learning different abstractions
11:50:20 <hpc> until your brain is stretched in all the right directions
11:50:36 <etiago> [exa], just implementing my own version of the State monad?
11:50:37 <maerwald> sounds like learning patterns
11:50:46 <maerwald> which I strongly advise against :>
11:50:58 <etiago> hpc, makes sense
11:51:18 <[exa]> yeah and abstractions. There's the game 'make it an oneliner', only rule is that if you identify a pattern and write it out, you must name it sensibly.
11:52:05 <etiago> fair enough
11:52:16 <hpc> etiago: the haskell wikibook has a few, you can pick up on more by hanging out here for long enough
11:52:19 <ertes> etiago: i can give you my favourite challenge in that regard
11:52:29 <hpc> there's a fairly practical subset in RWH and those sorts of books
11:52:30 <[exa]> etiago: yeah, State is the best way to learn encoding data (programs) in functions and get used to monad syntax
11:52:39 <hpc> (varying in levels of up-to-date-ness)
11:52:47 <kuribas`> etiago: also look at how other libraries are written, how they use combinators to make abstractions.
11:53:01 <ertes> etiago: implement a reduced variant of the hangman game in haskell: one where you can guess as often as you want, until the word is completely revealed
11:53:42 <ertes> etiago: my hope is that your first version will be completely imperative with state management, and once you have that, i'm going to show you how to do it "a haskell way"
11:53:42 <maerwald> [exa]: huh? state is just hiding parameters :>
11:54:02 <hpc> etiago: one important abstraction to learn is first-class IO, to bridge the gap between purely functional abstract nonsense and "i just want to parse json"
11:54:03 <etiago> ertes, awesome :) I´ll give it a shot
11:54:26 <etiago> probably will take me a couple of days though, as I work full time
11:54:30 <[exa]> maerwald: but seems completely different right
11:54:31 <etiago> but will definitely come back to you on that
11:54:36 <maerwald> [exa]: no
11:54:49 <[exa]> (maybe from imperative perspective?)
11:54:56 <[exa]> :( ok
11:55:07 <ertes> etiago: one day i'll turn this particular exercise into a blog post…  one day…
11:55:31 <etiago> ertes, I see an opportunity here for us to do it together
11:55:36 <maerwald> the point is that people will naturally write something state-like ish (in terms of input-output parameters), but rarely refactor them to use State monad
11:55:40 <kuribas`> [exa]: about your earlier question, you can make the accumulator in foldr a function.
11:56:34 <kuribas`> [exa]: then you get a foldl with CPS
11:56:45 <[exa]> kuribas`: now I'm kindof feeling blind. :D
11:56:49 <[exa]> thanks :]
11:57:01 <kuribas`> <[exa]> Is there a (named) foldr variant where the function can also return a function that's going to be applied to next item?
11:57:35 <[exa]> kuribas`: yeah, feeling blind for not seeing the obvious place where to put the function :D
11:58:30 <ertes> etiago: for now just concentrate on the challenge =)
11:58:39 <etiago> ertes, will do :)
11:59:39 <ertes> etiago: (don't do any fancy engineering or super-cute UI…  a simple stdin/stdout-based experience will be enough…  depending on your level of haskell i estimate the time required to be somewhere between 1h and 4h)
12:01:06 <fusuyz> hello, why I can't install haskell-platform via pacman?
12:01:33 <ertes> fusuyz: you should probably just install GHC and cabal-install
12:02:03 <ertes> fusuyz: you can get everything else via cabal-install
12:02:41 <kuribas`> [exa]: or if you want a right fold with cps, you can do a foldl
12:03:29 <fusuyz> I also did that but when I run ghci, it says me "error while loading shared libraries: libtinfo.so.5: cannot open shared object file: No such file or directory"
12:04:10 <kuribas`> > foldl (\k e a -> if e == 0 then a else k (e:a)) id [1, 4, 0, 1, 2] []
12:04:13 <lambdabot>  [1,2]
12:04:21 <ertes> [exa]: you might find this useful: http://ertes.eu/tutorial/foldr.html#stateful-folds
12:04:35 <ertes> [exa]: it explains what kuribas` is talking about in detail
12:04:54 <ertes> fusuyz: sounds like there is some foreign dependency missing
12:05:06 <c_wraith> :t \f z xs -> foldr (\x k y -> k (f x y)) id xs z
12:05:08 <lambdabot> Foldable t1 => (t2 -> t3 -> t3) -> t3 -> t1 t2 -> t3
12:05:08 <maerwald> nah
12:05:21 <c_wraith> Yeah, I finally can remember how to do that without struggling through re-deriving it every time
12:05:58 <ertes> c_wraith: you might benefit from that section, too =)
12:06:34 <c_wraith> ertes: I completely understand the theory, I usually just need to go through the plumbing an extra time to make sure I got all the arguments in the right place.
12:06:47 <maerwald> libtinfo is a library that can be optionally built by ncurses separate from libncurses
12:08:49 <ertes> c_wraith: the article explains how to do it mechanically
12:09:00 <c_wraith> ertes: I know how to do it mechanically.
12:09:00 <fusuyz> Ok, let me try install it via aur
12:09:07 <ertes> c_wraith: ok =)
12:09:21 <c_wraith> ertes: the new part this time was doing it in my head without running it through the compiler several times along the way.
12:09:59 <maerwald> fusuyz: rather build from source
12:10:13 <maerwald> you won't have that problem then
12:15:38 <ertes> c_wraith: i kinda mastered that through writing that section =)
12:16:48 <geekosaur> fusuyz, actually just symlinking libncurses.so.WHATEVER to libtinfo.so.SAMETHINGHERE would probably make it work
12:17:12 <epta> is `--enable-library-coverage' supported by nix-like builds? I got an error that hps cannot find some module
12:17:23 <geekosaur> emanwhile this sounds like *another* Arch screwup; shouldn't their packaging make sure the haskeline build matches the ncurses build?
12:21:06 <epta> same for `--enable-coverage`
12:22:48 <fusuyz> Should switch distro :(
12:22:55 <maerwald> definitely
12:23:26 <maerwald> but then again, it's also a waste of time
12:24:03 <fusuyz> that's why I am sad.
12:25:44 <ertes> fusuyz: there is one option that wouldn't require switching distributions: nix…  in this particular case i'm not talking about using nix for haskell development, but just using it to get GHC and cabal-install
12:26:14 <maerwald> I think that's over the top
12:26:34 <maerwald> just building from source should be fine
12:26:56 <maerwald> and arch packages allow that
12:28:02 <fusuyz> never done that before, should I follow this documentation? https://ghc.haskell.org/trac/ghc/wiki/Building
12:28:09 <maerwald> fusuyz: no
12:28:21 <maerwald> arch allows to build from source via the PKGBUILDs
12:28:25 <maerwald> refer to the archwiki
12:29:42 <maerwald> but, I almost suspect something else is wrong :P
12:29:59 <maerwald> though I wouldn't be surprised that ghc is mispackaged in arch
12:30:04 <maerwald> but then you wouldn't be the only one complaining
12:30:34 <ertes> nix is a last resort (short of actually building GHC manually, which i advise against), if none of the distribution-specific methods work out
12:30:54 <maerwald> that might be true for people who already know nix as a tool
12:31:44 <ertes> as a simple package management/installation tool its learning curve is shallow enough
12:32:00 <ertes> and i believe it's even in AUR
12:32:19 <maerwald> I prefer not to promote tools unless necessary
12:32:39 <ertes> "shallow"?  was that the right word?
12:33:00 <maerwald> ghc is in the official arch repo and it can optionally be built from source via the provided PKGBUILD
12:33:06 <maerwald> that is not a manual build
12:33:22 <maerwald> and those are the tools he should be familiar with (since that's his distro)
12:33:33 <ertes> could you stop trying to invalidate everything i say, please?
12:33:42 <maerwald> ?
12:33:46 <ertes> it's an option, and i'm gonna mention it
12:35:06 <maerwald> if we mention every tool that is able to install ghc...
12:35:09 <maerwald> then you can also mention docker
12:35:16 <ertes> yes, you can
12:37:33 <ertes> for some people even firing up a fully fledged linux VM to get a reasonable haskell experience, or at least certain aspects of it, is an option
12:46:27 <ertes> @let dinner = undefined
12:46:29 <lambdabot>  Defined.
12:46:33 <ertes> :t dinner
12:46:35 <lambdabot> pizza
12:46:37 <ertes> > dinner
12:46:39 <lambdabot>  *Exception: pizza tonno
12:47:02 <hpc> shennanigans
12:48:10 <ertes> hey, at least i stopped changing semantics =)
12:49:43 <cloudhead> does anyone know how you'd implement a function 'askField' which would be like getField + asks? Or if this exists already?
12:50:21 <ertes> cloudhead: asks field?
12:50:31 <cloudhead> basically    getField =<< asks
12:50:46 <ertes> cloudhead: what's wrong with (getField =<< asks)?
12:50:53 <ertes> err
12:51:00 <ertes> do you mean 'ask' rather than 'asks'?
12:51:12 <cloudhead> yeah ask sorry
12:51:19 <ertes> cloudhead: what's wrong with (getField =<< ask)?
12:51:31 <cloudhead> not sure what the type would be
12:51:34 <cloudhead> compiler says it's ambiguous
12:51:43 <ertes> then getField is ambiguous
12:51:48 <cloudhead> it is
12:51:49 <ertes> or your monad is
12:51:55 <cloudhead> because it needs an @"myField"
12:52:03 <cloudhead> but I want to add that outside of the function
12:52:37 <cloudhead> current usage is like: env <- ask; foo (getField @"myField" env)
12:52:38 <ertes> you can use type application
12:52:47 <cloudhead> and I'd like to combine ask and getField in a function
12:52:58 <ertes> (getField @ "myField") =<< ask
12:53:10 <cloudhead> yeah but I want a generic function for all fields
12:53:22 <ertes> isn't that generic enough?
12:53:31 <cloudhead> that's only for "myField"
12:53:57 <cloudhead> I'd like something like: field <- askField @"myField"
12:54:00 <ertes> wait, this doesn't look correct anyway
12:54:15 <ertes> asks (getField @ "field1") >>= foo
12:54:18 <ertes> like this
12:54:43 <cloudhead> right yes :)
12:55:00 <cloudhead> but can I implement a function that does that somehow?
12:55:00 <ertes> sure, you can define (askField = asks getField), as long as you write a type signature
12:55:27 <ertes> and then use it like this:  askField @ "field1"
12:56:21 <ertes> BTW, you can use -XOverloadedLabels to replace (askField @ "field1") by #field1
12:56:37 <cloudhead> yeah I'm at loss as to how to write that type signature
12:56:51 <ertes> what's the type of getField?
12:57:03 <cloudhead> because HasField x r a -- the 'x' here is the field name
12:57:20 <cloudhead> oh didn't know about the #syntax, that's nice
12:57:41 <cloudhead> getField :: HasField x r a => r -> a
12:57:44 <ertes> it requires you to define some type class machinery
12:58:22 <ertes> askField :: forall x a m r. (HasField x r a, MonadReader r m) => m a
12:58:38 <ertes> (make the forall explicit just to make sure the label is actually the first type argument)
12:59:20 <fusuyz> Am I a bad person if I can't build ghc via PKGBUILD?
13:00:27 <geekosaur> fusuyz, arch has been screwing up its Haskell ecosystem since June. I'm not sure I'd trust *any* Arch packaging for anything Haskell related currently
13:01:14 <cloudhead> hmm that signature makes sense, but it's telling me 'x' is ambiguous
13:01:26 <ertes> cloudhead: where?
13:01:53 <cloudhead> on the function signature: 'Could not deduce (HasField x0 r a)'
13:02:07 <cloudhead> guess it's not used in the body
13:02:17 <cloudhead> I'd want to do 'getFiled @x' or something
13:02:34 <ertes> cloudhead: enable -XScopedTypeVariables
13:02:43 <ertes> together with the 'forall' you can refer to 'x'
13:03:05 <fusuyz> Ok, I will try It on debian then. That's little bit disappointing though :(
13:03:46 <ertes> fusuyz: check your GHC version on debian…  they have a history of packaging ridiculously old versions of GHC
13:05:13 <cloudhead> it still considers it ambiguous hmm
13:05:17 <geekosaur> current debian stable is not terrible version-wise
13:05:30 <ertes> fusuyz: the absolute minimum version you should install is GHC 7.10, and even that's very old already…  some libraries may no longer work with 7.10
13:05:35 <geekosaur> oldstable will likely be 7.6.3 though
13:05:52 <ertes> cloudhead: paste your exact definition of askField
13:06:52 * hackagebot opaleye 0.6.0.0 – An SQL-generating DSL targeting PostgreSQL – https://hackage.haskell.org/package/opaleye
13:06:59 <cloudhead> http://lpaste.net/358862
13:07:23 <ertes> cloudhead: and you have ScopedTypeVariables enabled?
13:07:26 <maerwald> fusuyz: it's described in the archlinux wiki
13:07:51 <cloudhead> ertes: yeah I do
13:08:53 <ertes> cloudhead: then annotate the error message, too
13:10:02 <maerwald> fusuyz: you can also use yaourt to build from source
13:11:14 <cloudhead> ertes: done
13:14:16 <ertes> cloudhead: hmm, i'm actually not sure whether ScopedTypeVariables interacts well with TypeApplications…  could you try writing a type signature for getField instead?
13:14:34 <ertes> err, you can't
13:14:37 <cloudhead> ertes: tried that already, but let me try again
13:15:27 <ertes> cloudhead: do you have a variant of getField that has an explicit proxy argument?
13:15:32 <cloudhead> yeah same issue
13:15:42 <cloudhead> mmm what do you mean?
13:16:19 <ertes> cloudhead: getFieldWithProxy :: (HasField x r a) => proxy x -> r -> a
13:16:27 <ertes> getFieldWithProxy = const getField
13:16:42 <cloudhead> ah right, no I don't
13:16:44 <kody> hi guys
13:16:52 <ertes> askField = asks (getFieldWithProxy (Proxy :: Proxy x))
13:17:07 <ertes> cloudhead: see if this variant works…  you can define getFieldWithProxy locally for askField
13:17:32 <ertes> cloudhead: although you should write its type signature like this in that case:  getFieldWithProxy :: proxy x -> r -> a
13:18:35 <ertes> err, almost
13:18:44 <ertes> getFieldWithProxy :: forall proxy. proxy x -> r -> a
13:18:46 <ertes> like this
13:19:13 <ertes> although both should work in this case
13:19:54 <cloudhead> still no works :/
13:20:16 <ertes> cloudhead: are you really sure you enabled ScopedTypeVariables?
13:20:29 <cloudhead> hold on let me paste a full example
13:20:39 <ertes> add this line to the top of the source file:  {-# LANGUAGE ScopedTypeVariables #-}
13:21:29 <cloudhead> ertes: http://lpaste.net/358862#a358865
13:22:23 <ertes> ok, i have no idea why this doesn't work
13:22:32 <cloudhead> maybe it has to do with the magic of HasField
13:22:52 <cloudhead> hmm
13:23:04 <ertes> what magic?
13:23:42 <cloudhead> well HasField is one of those "magic classes" as they call it from what I remember
13:23:47 <cloudhead> ie: it's special-cased in the compiler
13:24:34 <cloudhead> or maybe that was just for OverloadedRecordFields
13:25:07 <sm> by writing .latest.FILE state files,
13:25:11 <sm> oops
13:25:14 <ertes> i don't think HasField is magic
13:25:55 <sm> is there an easier way to make a hackage revision to bump upper bounds, than manually clicking edit package, etc. ?
13:26:32 <ertes> sm: yes, upload a new version
13:26:47 <cloudhead> ertes: this is what I'm thinking of https://ghc.haskell.org/trac/ghc/wiki/Records/OverloadedRecordFields/MagicClasses
13:26:55 <cloudhead> don't know about the usage of "magic" here though, but yeah
13:27:36 <cloudhead> I guess it's magic because the instances are generated on the fly
13:27:44 <ertes> hmm, i see…  the "special-purpose solver behaviour" might indeed be the problem
13:28:07 <cloudhead> or yeah, that :)
13:28:09 <ertes> cloudhead: you should probably report this as a bug
13:28:19 <ertes> but try with the latest GHC version first
13:28:26 <cloudhead> you mean HEAD?
13:28:30 <cloudhead> I'm on 8.2.1 already
13:28:37 <ertes> that's good enough
13:33:12 <sm> ertes: that would bump the bounds, but I want to just make a revision, keeping the smae vesrion
13:33:48 <maerwald> sm: imo it's better to bump the version, but hackage maintainers will disagree
13:34:24 <sm> maybe so, but it creates more work for me, and happens very often, so I'm ok with revisions I think
13:34:44 <maerwald> it seems currently the opposite is true :P
13:35:36 <maerwald> or is there another reason a bump creates more work?
13:35:40 <maerwald> do you have == dependencies?
13:36:06 <sm> maerwald: that was one reason.. I think I have got rid of all those now
13:36:44 <sm> it makes more work juggling changelogs and branches
13:37:12 <woodson> hi everyone, I got question. What is the front end platform that mostly used with haskell? there are a bunch of like topic about it, however, most topic ends up deviating into some other topic and never seem to quite answer the question
13:37:13 <sm> bumping versions in the hledger install script..
13:37:35 <sm> updating versions and timestamps in docs, etc.
13:37:35 <Welkin> woodson: what do you mean by "front end platform"?
13:37:46 <Welkin> if you mean the browser, then the answer is always javascript
13:38:46 * hackagebot swagger-petstore 0.0.1.2 – Auto-generated swagger-petstore API Client – https://hackage.haskell.org/package/swagger-petstore
13:38:50 <woodson> sorry i meant framework
13:39:12 <Welkin> there is no front end framework
13:39:43 <Welkin> if you mean compiling haskel to javascript, then there is ghcjs, with which you can use many different libraries (reflex-dom, miso)
13:40:03 <Welkin> there are other ways to compile haskell to javascript, but this seems to be the future
13:41:26 <sm> I worked hard to ship a robust major release yesterday, tested every which way, but literally minutes later comes a new major release of brick (also I forgot to commit some megaparsec bounds) and I'm in the doghouse with stackage again until I release again.. and this gets more frequent.. so a revision becomes attractive
13:41:46 <maerwald> sm: haha
13:42:13 * sm can see upper bounds needing an update daily at this rate
13:42:35 * maerwald avoids starting the upper bounds discussion :P
13:43:50 <cloudhea1> ertes: thanks for the help, I filed a bug: https://ghc.haskell.org/trac/ghc/ticket/14303#ticket - hopefully I get some answers :)
13:50:01 <jnape> Greetings all -- does anyone know of a function like foo :: Bifunctor bf => [bf a b] -> bf [a] [b] ?
13:50:18 <jnape> sort of like a generalization of unzip
13:50:32 <jnape> perhaps particularly useful where bf is Either
13:50:50 <jnape> (probably left-biased in that case)
13:51:14 <Tuplanolla> Looks a bit like `Bitraversable`, jnape.
13:51:24 <jnape> that sounds exactly what i'm looking for
13:51:31 <jnape> basically a sequence over two parameters
13:51:54 <Tuplanolla> :t bisequenceA
13:51:56 <lambdabot> (Applicative f, Bitraversable t) => t (f a) (f b) -> f (t a b)
13:51:56 <Welkin> does there exist a trifunctor?
13:52:01 <Welkin> or a dodecafunctor?
13:52:23 <jnape> well, hmm
13:52:24 <Eduard_Munteanu> Sure, you can come up with that.
13:52:30 <jnape> ok bisequenceA isn't quite right
13:53:30 <jnape> only asking here since I was unable to form a hoogle search that seemed to yield any results
13:54:04 <phadej> hmm, interesting. that foo does make sense for `These` too
13:54:33 <Eduard_Munteanu> @index bisequenceA
13:54:34 <lambdabot> bzzt
13:54:40 <Eduard_Munteanu> @hoogle bisequenceA
13:54:40 <lambdabot> Data.Bitraversable bisequenceA :: (Bitraversable t, Applicative f) => t (f a) (f b) -> f (t a b)
13:54:41 <lambdabot> Intro bisequenceA :: (Bitraversable t, Applicative f) => t (f a) (f b) -> f (t a b)
13:54:41 <lambdabot> Data.Bifoldable bisequenceA_ :: (Bifoldable t, Applicative f) => t (f a) (f b) -> f ()
13:55:04 <Eduard_Munteanu> Although yeah, you need it the other way around.
13:55:18 <jnape> yeh it's extremely common in a codebase I work in to have a bunch of eithers that you basically want to collect all the left or all the right values, and you want to bias left
13:55:25 <jnape> which has lead me down this path
13:55:31 <jnape> precisely
13:55:32 <phadej> jnape: there is partitionEithers
13:55:38 <phadej> :t partitionEithers
13:55:40 <lambdabot> [Either a b] -> ([a], [b])
13:55:48 <jnape> right, still not *quite* right
13:56:06 <jnape> the goal is to get back an either, so i still need to wrap in a left if _1 has any elements, or a right otherwise
13:56:29 <jnape> the fold is trivial to write, but I'd rather never have to write it twice
13:56:45 <phadej> jnape: another option is Validation, where you'll get (with sequenceA) [Either a b] -> Either (NonEmpty a) [b]
13:56:54 <Eduard_Munteanu> [Either a b] -> Either a [b] ?
13:57:11 <jnape> Eduard: that's sequence, but it only retains the first l value :/
13:57:16 <jnape> I want to preserve all failures
13:57:25 <jnape> phadej: yeh that's getting warmer for sure
13:57:32 <ertes> sm: i agree that bumping is better, because technically you're releasing a new version
13:57:46 <jnape> I was hoping to generalize it so that, while it's useful for coproducts, it's also useful for bifunctors (like tuple2 for instance)
13:58:09 <ertes> cloudhea1: sorry i couldn't really help
13:58:22 <ertes> cloudhea1: and thanks for filing the bug report
13:58:25 <Eduard_Munteanu> @hoogle f (t a b) -> t (f a) (f b)
13:58:26 <lambdabot> Darcs.Patch.Witnesses.Unsafe unsafeCoerceP2 :: t wW wX wY wZ -> t wA wB wC wD
13:58:26 <lambdabot> Graphics.Gnuplot.Frame.OptionSet viewMap :: T (T x y z) -> T (T x y z)
13:58:26 <lambdabot> Prelude unzip :: [(a, b)] -> ([a], [b])
13:59:12 <jnape> @eduard_munteanu: yep, that's about what I've found in Hoogle as well
13:59:12 <lambdabot> Unknown command, try @list
13:59:27 <jnape> whoops, sorry lambdabot
13:59:32 <cloudhea1> ertes: no prob, you gave me the confidence that this was unexpected behaviour!
14:00:28 <jnape> If this is an effectively unnamed function, do people have opinions about what to name it? My initial instinct was something like "coalesce"
14:00:41 <jnape> :t coalesce
14:00:42 <lambdabot> error: Variable not in scope: coalesce
14:00:53 <jnape> so it's available at least, it seems
14:01:53 * hackagebot strict-types 0.1.0.7 – A type level predicate ranging over strict types – https://hackage.haskell.org/package/strict-types
14:29:25 <fxk[m]> Hello
14:30:15 <maerwald> welcome
14:56:47 <filthy_causual2_> I want all the digraphs that occur two or more times in non overlapping way. (ie "ababaaa" produces ["ab", "ba"] but not "aa" because the two "aa"s over lap in "aaa").
14:57:57 <filthy_causual2_> All the digraphs, is just "zip l (drop 1 l)", but that produces ["aa","aa"] from "aaa".
15:00:16 <shloub> i believe drop 1 is tail
15:00:23 <shloub> have you considered nub or Data.Set?
15:00:33 <filthy_causual2_> > drop 1 []
15:00:35 <lambdabot>  []
15:00:40 <filthy_causual2_> > tail []
15:00:43 <lambdabot>  *Exception: Prelude.tail: empty list
15:01:01 <shloub> my bad :)
15:02:06 <filthy_causual2_> head and tail are evil, always use patern matching or drop/take.
15:02:24 <hpc> usually pattern matching
15:02:54 <filthy_causual2_> depends on if passing through nil is okay.
15:03:29 <filthy_causual2_> For example the empty list indeed contains no digraphs so..
15:04:46 <hexagoxel> map (take 1) $ group $ zip l (drop 1 l)    ?
15:05:21 <hexagoxel> not completely sure how you want stuff to count in case of overlaps.
15:05:33 <hexagoxel> would aaaa produce aa ?
15:06:58 <filthy_causual2_> Yes.
15:07:22 <hexagoxel> ah, then perhaps applying the zip twice?
15:08:08 <hexagoxel> > let f l = zip l (drop 1 l) in f (f "ababaaa")
15:08:11 <lambdabot>  [(('a','b'),('b','a')),(('b','a'),('a','b')),(('a','b'),('b','a')),(('b','a'...
15:09:33 <filthy_causual2_> and then filter (uncurry (eq))?
15:09:45 <hexagoxel> from that you can remove the overlaps easily, and then flatten and do the counting.
15:10:07 <typedrat> Is there any way to "distribute" a proxy through a type level list? Like `Proxy '[a, b, c]` to `[Proxy a, Proxy b, Proxy c]`, I can't figure out a way to phrase it that type checks
15:10:22 <pikajude> like a type-level map
15:10:24 <pikajude> not Map
15:10:26 <pikajude> but map
15:12:02 <typedrat> More specifically, I have a type level list of KnownNats, and I need to get a value level list of the numbers they represent
15:12:10 <filthy_causual2_> hexagoxel: thanks!
15:13:32 <c_wraith> typedrat: the mechanism from going from type level -> term level most directly is a type class.
15:14:17 <pikajude> you could write a typeclass for it
15:14:54 <Eduard_Munteanu> type family Map (f :: k -> l) (xs :: [k]) :: [l] where { Map f '[] = '[]; Map f (x ': xs) = f x ': Map f xs) }     -- ?
15:15:16 <cerebral_monkey> I'm a haskell noob and I'm confused about something. 0 > 0 is False, (0) > (0) is false, but (0,1) > (0, 0) is True. My intuition was that that would be equivalent to 0 > 0 && 1 > 0, but it's clearly not. Can anyone clarify why this is?
15:15:50 <hpc> in (0, 1)
15:15:56 <hpc> 0 is the most significant "digit"
15:16:05 <c_wraith> Eduard_Munteanu: sure, but that doesn't actually solve the underlying problem of reflecting the whole list down to the term level.
15:16:17 <hpc> and when those compare equal, you compare on the next "digit", which is 1 compared to 0
15:16:43 <hpc> a similar thing happens with lists
15:16:47 <hpc> > "on" > "off"
15:16:49 <lambdabot>  True
15:16:58 <cerebral_monkey> hpc: Ah, that makes sense. I appreciate your help!
15:17:05 <shloub> > "ab" > "aa"
15:17:07 <lambdabot>  True
15:17:17 <Peaker> pikajude, http://lpaste.net/358871
15:17:40 <Peaker> is there any good way to inspect/debug the type-level result of something like this?
15:18:06 <hydraz> :kind!
15:21:55 <Peaker> hydraz, that just prints their kind - I want their type("value" at the type-level)
15:22:16 <Peaker> oh, the exclamation symbol is part of it, nice, thanks! :)
15:22:27 <hydraz> "(!: also print the normalised type)"
15:23:58 <hexagoxel> filthy_causual2_: "aaaa" might still be tricky.
15:24:02 <filthy_causual2_> cerebral_monkey: Ord requires (<) to be linear.
15:24:33 <Eduard_Munteanu> It's called lexicographic ordering, btw.
15:25:01 <hpc> perhaps a simpler form of this problem is to partition the string into "matches substring" and "doesn't match" ranges
15:25:06 <filthy_causual2_> hexagoxel: I don't need to distinquish "aaaa" from "aaaaa" or "aaaaaaaaa" all I care about is if the diagraph happens _at least_ twice.
15:25:16 <hpc> after you partition the string completely, you count the number of match regions
15:25:34 <hexagoxel> filthy_causual2_: yeah i just mean if you use filter, you won't even yield "aa" from "aaaa"
15:27:31 <hexagoxel> unless you do some trickery like sentinels at the start/end
15:28:49 <hexagoxel> ("zaaaaz", where 'z' does not occur normally)
15:29:10 <filthy_causual2_> hexagoxel: concatMap f where f [] = []; f [x] = [x]; f (x:y:xs) = x:xs -- that should work. 
15:29:15 <hexagoxel> and at that point, other solutions might be prettier :)
15:30:25 <filthy_causual2_> hexagoxel: concatMap f where f [] = []; f [x] = [x]; f l = take 2 (drop 1 l) -- that should work. 
15:33:45 <hexagoxel> filthy_causual2_: right! seems good. and i had already discarded my own approach :D
15:38:00 <filthy_causual2_> And then put it in a Map A Bool where ((x,False) means once, (x, True) means twice), is there a name for the (1,Many, \_ _ -> Many) semigroup?
15:44:58 <hpc> filthy_causual2_: adding onto that question, is there a name for the thing it is that's not Monoid?
15:45:22 <hpc> Many is sort of the opposite of empty
15:47:17 <hpc> or, hmm
16:26:38 <pikajude> Peaker: http://lpaste.net/358872
17:22:51 <unclechu> hey guys, about templates, how do i declare infix `cons` expression?
17:23:13 <unclechu> for `TH.InfixE (Just x) (TH.VarE $ TH.mkName ":") (Just y)` i got error: `Illegal variable name: `:'`
17:25:52 <Cale> unclechu: It's a ConE
17:26:53 <unclechu> Cale: thanks, i just replaced `VarE` to `ConE` and now it's okay
17:30:34 <pavonia> How do you truncate a Rational to a certain amount of decimals (in floating point representation)?
17:34:01 <pavonia> Hhm, (% 100) . truncate . (* 100) seems to work
17:57:05 <woodson> @messages
17:57:05 <lambdabot> You don't have any messages
17:58:33 <pikajude> you can also use the ' syntax to get the name of the constructor you actually want
17:58:44 <pikajude> maybe? i don't remember if that works for operators
17:58:46 <pikajude> but it should
18:20:51 <typedrat> I don't know if what I'm trying to do is actually possible currently.
18:28:11 <typedrat> http://lpaste.net/7597519485578248192
18:39:37 <typedrat> the issue is how to stitch the `Biases` together into one thing, without knowing ahead of time the length and without being able to do a fold
18:47:31 <lyxia> typedrat: make All KnownNat a type class
18:48:01 <lyxia> with one instance for (:), one for []
18:52:31 <typedrat> I don't see how that helps. The issue is the polymorphism/maintaining the types at all.
18:55:00 <typedrat> I almost need to like... convert the proxy list into a list of proxies, like I said before, and then have some sort of like `class Project t where pmap :: (forall a. f a -> g a) -> t f a -> t g a` (sending a collection of `f a` to a collection of `g a` while showing that a isn't changing)
18:59:56 <lyxia> typedrat: http://lpaste.net/358883 does that help you
19:39:47 <mizu_no_oto_work> What's the right way to catch Network.HTTP.Client' HttpException when you're working with a StateT MyState IO?  MonadError isn't going to work since IO
19:40:05 <mizu_no_oto_work> IO's only a MonadError if the exception is an IOException
19:42:13 <monochrom> I would strip the StateT.
19:43:39 <mizu_no_oto_work> The main issue here is that the action is something from a library
19:44:24 <mizu_no_oto_work> and it's not really _My_State but the library's state
19:50:39 <chris_> I wrote a function but it won't compile because somehow it expects (Integer -> Integer -> Integer) and I wan't to have Num a => (a -> a -> a )
19:50:41 <chris_> http://lpaste.net/358884
19:52:12 <chris_> Is there some sort of language extension I need?
19:56:12 <chris_> it works if i replace op with (+)
19:56:28 <chris_> but I don't want to right a different function for each operator
20:00:19 <mizu_no_oto_work> chris_ the function there doesn't have an error because of the type of +
20:00:38 <mizu_no_oto_work> but you might be running into the monomorphism restriction if it's defaulting to Integer
20:01:21 <chris_> yeah it's defaulting to integer but since it's wrapped in a lispVal I thought it would be fine
20:08:28 <chris_> even with NoMonomorphismRestriction enabled
20:08:59 <chris_> it still gives ‘Integer -> Integer -> Integer’ with t
20:09:59 * hackagebot hpack 0.19.2 – An alternative format for Haskell packages – https://hackage.haskell.org/package/hpack
20:12:34 <geekosaur> the problem is the list "primitives" cannot have polymorphic items; the t in numericBinOp and numericBinOp1 is part of the type of the list, and since it must be monomorphic it gets set to Integer because of the (+) in the first element
20:13:06 <geekosaur> if I am reading this right
20:13:12 <geekosaur> hm, maybe I am not
20:13:22 <chris_> would be helpful to lpaste the gadt definition
20:13:26 <chris_> of LispVal
20:13:35 <geekosaur> ^
20:14:34 <geekosaur> I need to see LispVal to be certain what is going on. but it would not surprise me if it's not actually doing an existential and the type is escaping
20:15:05 <chris_> http://lpaste.net/358885
20:15:38 <chris_> basically I want + to operate on both Number and Float lispVal
20:17:22 <geekosaur> oh. actually I think you just need the constraint on the type t in numericBinOp{,1}
20:17:53 <chris_> How would do I do that?
20:18:16 <chris_> Num a => (a -> a -> a) ?
20:19:45 <geekosaur> roughly, yes
20:19:52 <geekosaur> not enough there ot test compile either...
20:20:42 <lyxia> mizu_no_oto_work: I'd just use stuff from Control.Exception
20:22:51 <mizu_no_oto_work> Control.Exception's stuff assumes you have an IO action, but I have a StateT s IO.  I think transformers exposes what I need, though (the ability to lift catch into StateT)
20:22:54 <chris_> http://lpaste.net/358887 I'm not really sure where to go from here 
20:22:57 <chris_> • Couldn't match type ‘a’ with ‘Integer’
20:22:57 <chris_>       ‘a’ is a rigid type variable bound by
20:22:57 <chris_>         the type signature for:
20:22:59 <chris_>           numericBinop1 :: forall a.
20:23:01 <chris_>                            Num a =>
20:23:03 <chris_>                            (a -> a -> a) -> [LispVal] -> Either LispError LispVal
20:27:58 <mizu_no_oto_work> chris_: I think your issue is the level at which Num and a are.
20:27:59 <geekosaur> ok, it needs to be rank-n
20:28:09 <monochrom> You need (forall a. Num a => a -> a -> a) -> [LispVal] -> Either LispError LispVal
20:28:12 <mizu_no_oto_work> i.e. numericBinop1 :: (forall a. Num a => (a -> a -> a)) -> [LispVal] -> Either LispError LispVal
20:28:58 <mizu_no_oto_work> Whereas what you currently have is numericBinop1 ::  forall a. (Num a => (a -> a -> a) -> [LispVal] -> Either LispError LispVal)
20:29:10 <mizu_no_oto_work> And a isn't Integer or Float
20:29:43 <lyxia> mizu_no_oto_work: monad-control provides a more general pattern to lift catch/throw
20:30:05 <chris_> Omg!!! it bloody works but what does rankntypes do
20:30:15 <geekosaur> ^ and numericBinOp needs the same but with Integral instead of Num (and you can't do Float at all, since you are using ops that require Integral --- so if you really want that to handle Float, you need to come up with a different way)
20:30:22 <geekosaur> (+) will work for either, but
20:30:24 <geekosaur> :t div
20:30:27 <lambdabot> Integral a => a -> a -> a
20:31:04 <monochrom> Rank-n types just mean predicate logic.
20:31:07 <geekosaur> enables the forall in parentheses, so the type doesn't get exposed. but you can only use values involving it in certain limited ways
20:31:09 <chris_> :t (-)
20:31:10 <lambdabot> Num a => a -> a -> a
20:31:30 <geekosaur> div, mod, quot, rem all have Integral constraint
20:32:16 <geekosaur> (/) is the Floating version of div; you're on your own for the others (although there is an fmod in Data.Fixed)
20:34:01 <chris_> is there a better way to check all constructors are the same then? http://lpaste.net/8481999877713166336
20:34:27 <jle`> chris_: you can use list comprehensions
20:34:47 <mizu_no_oto_work> chris_: a (forall a. a -> a) can be applied to multiple types within the function.  Whereas if you had a "forall a b c. (a -> a) -> b -> c -> b" aka "(a -> a) -> b -> c -> b", that (a -> a) can't be applied to anything in that function because a, b and c are all different type variables.
20:35:11 <mizu_no_oto_work> Also, a (forall a. a -> a) has to be id or something that blows up
20:35:16 <jle`> chris_: num xs = and [ True | Number _ <- xs ]
20:35:22 <jle`> er
20:35:27 <jle`> oops that doesn't do that
20:35:52 <jle`> if you have lens already imported, you can derive prisms and do `all (has _Number)`
20:36:10 <chris_> oh I see @mizu_no_oto_work 
20:36:17 <jle`> or othrewise just use normal all and lambas, num = all (\case Number _ -> True; _ -> False)
20:37:13 <jle`> > all (\case Just _ -> True; _ -> False) [Just 10, Just 3, Just 0]
20:37:15 <lambdabot>  True
20:37:18 <jle`> > all (\case Just _ -> True; _ -> False) [Just 10, Just 3, Just 0, Nothing]
20:37:20 <lambdabot>  False
20:37:50 <chris_> parse error on input ‘case’
20:38:10 <jle`> ah you probably have to turn on the LambdaCase extension
20:38:17 <chris_> oh ok
20:41:24 * hackagebot ersatz-toysat 0.2.2.0 – toysat driver as backend for ersatz – https://hackage.haskell.org/package/ersatz-toysat
21:16:49 <dmj`> jle`: o/
21:16:55 <jle`>  \o
21:26:04 * hackagebot ethereum-analyzer 2.0.0, ethereum-analyzer-cli 2.0.0, ethereum-analyzer-deps 2.0.0, ethereum-analyzer-webui 2.0.0
21:26:04 * hackagebot  → https://hackage.haskell.org/packages/recent
21:35:11 * hackagebot liblawless 0.26.0 – Prelude based on protolude for GHC 8 and beyond. – https://hackage.haskell.org/package/liblawless
21:35:11 * hackagebot lawless-concurrent-machines 0.3.1 – Concurrent networked stream transducers – https://hackage.haskell.org/package/lawless-concurrent-machines
22:13:44 * hackagebot uri-parse 0.1.0.1 – A simple library for parsing and generating URIs – https://hackage.haskell.org/package/uri-parse
22:15:26 <cheater> hi
22:16:51 <cocreature> hey cheater 
23:58:12 * hackagebot thread-hierarchy 0.1.0.0 – Simple Haskel thread management in hierarchical manner – https://hackage.haskell.org/package/thread-hierarchy
