00:00:09 <jle`> jxv: people usually call it 'Ap'
00:00:25 <jxv> sure, but ap implies applicative or monad
00:00:30 <jle`> but it's not commonly used, it's in some libraries
00:00:39 <jle`> no i mean, the typeclass you're talking about is usually called capital-A p
00:00:45 <jxv> oh
00:00:48 <jxv> hmm
00:01:08 <jxv> well that makes sense
00:01:20 <jle`> class Functor f => Ap f where (<.>) :: f (a -> b) -> f a -> f b
00:01:30 <jle`> it's sort of like a semigroup in the category of endofunctors
00:02:04 <jle`> or a lax semigroup functor
00:02:09 <jle`> monoid-without-identity
00:02:19 <jxv> Is there one without a functor constraint?
00:02:48 <jle`> usually not, because what would the laws be?
00:03:08 <jle`> the laws for Ap/Applicative only make sense in the context of 'f' being a Functor/functor
00:03:21 <jle`> so like without the Functor constraint there are no meaningful laws really
00:03:36 <towerio> Nothing stopping you from violating the laws anyway
00:04:03 <jxv> jle`, sure. but I'm trying to solve a problem not satisfy laws
00:04:04 <jle`> that's true, but the point of an abstraction is that it makes sense/is coherent
00:04:23 <jle`> an Ap without laws just isn't a useful abstraction
00:04:33 <jle`> the type itself might be a useful type
00:04:37 <jxv> alright, gotta make my own then
00:04:40 <jle`> but the typeclass wouldn't be a useful typeclass
00:04:44 <jle`> jxv: what's your problem, exactly?
00:04:51 <towerio> *curious*
00:05:03 <jle`> do you want to just write Foo (a -> b) -> Foo a -> Foo b ?
00:05:08 <jle`> if so you can just write it and give it a name
00:05:51 <jle`> then your function doesn't have to satisfy any laws, obviously, because it is just a function you wrote arbitrarily
00:06:01 <jle`> and you don't need to invoke anything silly like a useless typeclass
00:06:57 <jxv> I have a type: I'm creating a generated DSL. The type`Expr a`, where the `a` is a phantom type, has an AST underneath. A functor will force a type which I don't want.
00:07:32 <jxv> I can create an constructor with a type `Expr (a -> b)`
00:08:38 <jxv> therefore an `Ap` like typeclass could be useful for constructing something like `Expr (Int -> Int -> SomeType)`
00:09:57 <flounders> I'm wondering if anyone else has run into this and knows how to work through it? http://lpaste.net/358917 I'm running Arch x86_64.
00:14:06 <jle`> jxv: it doesn't sound like you want an Ap-like typeclass
00:14:18 <jle`> it sounds like you just want a Expr (a -> b) -> Expr a -> Expr b function...
00:14:33 <jxv> correct
00:14:41 <jle`> so having a typeclass won't bring you any benefit
00:14:52 <jxv> but if that typeclass already existed I could reuse the syntax
00:15:19 <jle`> i don't think that is any real benefit
00:15:25 <jle`> because nobody would know it anyway
00:15:26 <jxv> and it could be readily be understood by its users
00:15:28 <jle`> so you don't gain any readability
00:15:35 <jxv> good point
00:15:49 <Peaker> it would be nice if Haskell had more granular type-classes so Ap could be reused
00:15:54 <Peaker> (and less name pollution)
00:16:06 <jle`> and even if it *is* commonly used...if it has no laws, like you say, then it wouldn't be understandable by users
00:16:18 <jle`> users wouldn't be able to understand what your function does, without any laws
00:17:31 <ski> jxv : is it a GADT ?
00:17:39 <jxv> no
00:17:49 <jxv> ski, I assume you mean the `Expr`
00:18:00 <ski> existential ?
00:18:11 <jxv> nope, just a regular old newtype
00:18:20 <CHIPPY> +
00:18:38 <ski> i don't think i understand "I can create an constructor with a type `Expr (a -> b)`", then
00:18:52 * ski eyes CHIPPY
00:19:52 <jxv> It's a constructor within the DSL. Not inside haskell.
00:20:34 <jxv> The `a -> b` wasn't meant to be taken literal unlike `Int -> Int -> SomeType`
00:24:02 <ski> so you have a data constructor of type `Expr (Int -> Int -> SomeType)' (and not something more general). how is that not a GADT ?
00:27:45 <jxv> I won't know the constructors until the code is generated. Expr exists in a helper library.
00:28:08 <iqubic> How do I install a executable program binary from hackage into the global project using stack?
00:28:12 <jxv> The generated code depends on that library.
00:28:20 <iqubic> Looking to get glirc installed here.
00:28:31 <jxv> I'm generating regular functions instead
00:28:45 <osa1> iqubic: `stack install`
00:28:49 <iqubic> I want to have stack put it into the global project. Not sure how to do that, or even if that is the best way to go.
00:29:01 <iqubic> osa1: that's giving me a fair number of issues
00:29:16 <osa1> interesting, it always works for me. what issues are you getting?
00:30:16 * hackagebot morph 0.1.1.2 – A simple database migrator for PostgreSQL – https://hackage.haskell.org/package/morph
00:30:40 <iqubic> http://dpaste.com/1H5993S
00:31:39 <osa1> iqubic: you should run `stack update && stack init --resolver=lts-8 --solver` first
00:31:51 <iqubic> I will try that.
00:32:07 <osa1> it's mentioned in the README, btw
00:46:00 <ski> jxv : TH ?
00:46:28 <jxv> nope, javascript. I'm creating an IDL. github.com/jxv/colorless
00:46:58 <ski> mhm
00:47:08 <Unhammer> is it possible to make a 
00:47:10 <Unhammer> newtype X = X { fromX :: Double }
00:47:12 <Unhammer> with GeneralizedNewtypeDeriving that I can pass into a function expecting a plain Double?
00:47:20 <jxv> ski, haskell library https://github.com/jxv/colorless-haskell
00:47:27 <Cale> Unhammer: no
00:47:48 <Unhammer> ok, thanks :)
00:47:51 <towerio> @pl \l -> l \\ w == []
00:47:51 <lambdabot> (line 1, column 9):
00:47:51 <lambdabot> unexpected '\\'
00:47:51 <lambdabot> expecting variable, "(", operator or end of input
00:48:03 <Cale> Unhammer: Unless that function is a class method, and there's an instance of the class for Double, I suppose.
00:48:06 <tdammers> Unhammer: not being able to do that is kind of the whole point of newtypes
00:48:40 <towerio> @pl \l -> l \\\\ w == []
00:48:40 <lambdabot> (line 1, column 9):
00:48:40 <lambdabot> unexpected '\\'
00:48:40 <lambdabot> expecting variable, "(", operator or end of input
00:48:54 <towerio> @pl \l -> (l \\ w) == []
00:48:54 <lambdabot> (line 1, column 10):
00:48:54 <lambdabot> unexpected "\\"
00:48:54 <lambdabot> expecting variable, "(", operator or ")"
00:49:02 <tdammers> it's called newtype because it creates a new type; the new type shares internal representation with the wrapped type, but as far as the type checker is concerned, it is a different type than the wrapped one
00:49:11 <towerio> @pl \l -> (l \\\\ w) == []
00:49:12 <lambdabot> (line 1, column 10):
00:49:12 <lambdabot> unexpected "\\"
00:49:12 <lambdabot> expecting variable, "(", operator or ")"
00:49:15 <towerio> facepalm
00:49:18 <tdammers> which makes it possible to attach different constraints (typeclasses) to it
00:55:21 <iqubic> Well, NixOS + Stack is a terrible time for all.
00:55:42 <maerwald> iqubic: you should wrap nixos in docker first
00:55:54 <maerwald> and run that in a VM
00:56:01 <maerwald> not enough abstraction layers
00:56:14 <iqubic> maerwald: I am running NixOS on hardware.
00:56:37 <iqubic> currently trying to install this:https://hackage.haskell.org/package/glirc
00:58:31 <iqubic> it's being a pain in the butt.
01:00:58 <cocreature> what kind of trouble am I getting myself into if I make a MonadState instance for "ReaderT (TVar s) IO"?
01:01:19 <merijn> cocreature: Why would that be trouble?
01:01:29 <cocreature> merijn: I’m not sure, that’s why I’m asking :)
01:01:59 <merijn> cocreature: I did a bunch of benchmarks on some channels/synchronisation methods. STM is freakishly fast for most happy paths
01:02:52 <cocreature> merijn: I was more thinking about accidentally violating some property that people expect of MonadState but couldn’t come up with one
01:03:22 <merijn> cocreature: Well, something like "zoom" and temporary overwrites wouldn't work anymore
01:03:58 <merijn> cocreature: Also, your consistency model is weakened to sequential consistency
01:04:30 <cocreature> ok, that seems like a reasonable tradeoff :)
01:05:51 <merijn> Completely unrelatedly, what's people's opinion on "beta" release of a package? I'm doing a major API rework on a library before version 1.0 and I wanted people to have a look before finalising any API choices, so I was thinking of just releasing it with an unstable API as 0.x releases until I settle on something I like
01:08:06 <cocreature> just make sure that it’s clear that it’s a beta release, Haskell packages tend to stay on 0.x for ages even if they’re really not beta anymore :)
01:09:27 <merijn> cocreature: Well, I only have one reverse dependency anyway, which doesn't appear to have any docs :p
01:10:19 <cheater> hi
01:10:35 <cheater> is ghc getting linear types?
01:10:42 <cocreature> yes
01:10:55 <cocreature> well it’s very likely at least
01:10:59 <cheater> will they allow me to hang up the GC?
01:12:39 <[exa]> good question. :]
01:13:09 <cocreature> “hang up” as in dead lock or as in simply not using it?
01:13:36 <merijn> Being able to write GC free code is an explicit goal AFAIK
01:14:08 <cocreature> it might be a goal but it’s not the focus atm. the current implementation is focused on safe resource usages
01:15:22 <Athas> How would GC-free code interact with lazy evaluation?
01:24:21 <ski> Athas : i suppose one could try asking the Clean folks
01:24:41 <merijn> ski: I don't think Clean is GC free?
01:24:50 <Athas> Clean just has uniqueness types as i understand it.
01:24:58 <merijn> Athas: Right
01:25:50 <ski> i was under the impression that when you drop a unique value on the floor, an explicit deallocator is called at that point in the implementation ?
01:26:10 <merijn> ski: I dunno enough about the implementation
01:26:29 <merijn> ski: It could just be the GC calling deallocators, ala ForeignPtr, though
01:27:09 <towerio> @pl \n -> sum $ filter (==0) $ iterate (`mod` 10) n 
01:27:09 <lambdabot> sum . filter (0 ==) . iterate (`mod` 10)
01:27:31 <ski> (well. at least that's what happens in the Melbourne Mercury Compiler. but that doesn't use lazy evaluation)
01:30:06 <Peaker> ski, I think uniqueness types worry more about preventing value duplication than about losing the unique reference to a value.  I thought worrying about both is "linear types" and about duplication only is "uniqueness types"
01:30:36 <ski> .. not really
01:30:52 <Peaker> what's the difference between uniqueness types and linear types then?
01:31:17 <ski> linear (and affine) types is about not duplicating (and possibly also dropping) a value, in the future
01:31:27 <merijn> Peaker: Uniqueness types are a subset of linear types
01:31:28 <ski> uniqueness is about not having duplicated in the past
01:31:57 <ski> uniqueness enables update-in-place
01:32:08 <Athas> You can freely make a unique value non-unique, if you want.
01:32:14 <Peaker> do uniqueness types care about losing the only reference to a value?
01:32:20 * ski nods to Athas
01:32:21 <Athas> You can't make a linear value non-linear (except by copying).
01:32:38 <Peaker> linear types can also let you duplicate a value explicitly?
01:32:42 <Athas> Yes, explicitly.
01:32:50 <Athas> But uniqueness types have a straightforward subtyping relationship.
01:33:10 <Athas> Uniqueness types are *much* simpler, but probably also less interesting in the end.  They are nice for permitting in-place updates in pure languages, though.
01:33:48 <ski> Peaker : "do uniqueness types care about losing the only reference to a value?" -- no, not really
01:34:07 <Athas> Not at all, I would say!
01:34:21 <Peaker> so if the linear type system lets you share references but then infers a different (non linear) type - that means it is both linear and uniqueness typing?
01:34:47 <ski> however, if you're supposed to return a unique value of type `T', and you can't conjure one up from nothing, you'll have to return a (possibly modified version of) `T' that you got as argument
01:36:41 <ski> (typical example is `Start :: *World -> *World' in Clean, or `:- pred main(io :: di,io :: uo) is det.' in Mercury)
01:38:06 <merijn> Are there any tools for checking for redundant dependencies?
01:38:17 <ski> (`io' in Mercury corresponds to `World' in Clean. `di' is "destructive input", `uo" is "unique output")
01:38:23 <merijn> i.e. if I rip out a bunch of code, how do I figure out which dependencies are now unneeded?
01:40:19 <tdammers> merijn: best solution I've found so far is commenting everything out and then let stack build tell me which packages I'm missing
01:46:00 <jose9999> Hi!
01:46:16 <jose9999> I'm doing some basic data processing with Haskell, reading a file that is roughly 500 MB
01:46:28 <jose9999> This is followed by a few minor transformations
01:46:54 <jose9999> What I've found is that just reading the file is very slow, taking around 20 seconds or so
01:47:07 <jose9999> This strikes me as problematic
01:47:27 <merijn> jose9999: 10 dollar says you're using String
01:47:36 <jose9999> I'm using 'hGetContents' and then split on newlines
01:47:50 <jose9999> merijn: I can give you 10 pesos ;)
01:47:53 <jose9999> But, yeah, you are right
01:47:53 <merijn> jose9999: The String one? (there's multiple hGetContents around)
01:48:04 <jose9999> Yes, the String one
01:48:16 <merijn> jose9999: Ok, rule of thumb: If you ever plan to deal with large amounts of text OR want to be fast: NEVER use String
01:48:32 <merijn> jose9999: It's a linked list of Char and can take as much as 24 bytes *per character*
01:48:33 <jose9999> What do you suggest? Note that a large part of the input are strings (i.e. most of the fields in the CSV will be used as Strings)
01:48:50 <merijn> jose9999: You want to use Text (lazy or strict) from the text package
01:49:48 <merijn> jose9999: Text is for *dense* unicode text (basically, densely packed byte arrays, so 1-2 bytes per character and a bit of overhead every few kilobytes)
01:50:40 <jose9999> OK, that makes sense. Thanks!
01:51:00 <jose9999> So, I'll then transform the file into something like [(Text, Text, Int,...)]
01:51:15 <tdammers> OK, so to tone that down a bit: if you're streaming characters in a linear fashion, then String isn't so bad
01:51:19 <jose9999> But is there also a way to speed up the initial reading? That seems quite slow as well
01:51:26 <phadej> if you use CSV, use cassava
01:51:34 <phadej> and don't parse by hand
01:51:34 <merijn> jose9999: text has a hGetContents that produces Text
01:51:54 <merijn> jose9999: https://hackage.haskell.org/package/text-1.2.2.2/docs/Data-Text-IO.html
01:52:11 <merijn> jose9999: Text versions of a lot of String file operations
01:52:15 <tdammers> another thing you probably want to avoid is load the whole thing into memory at once
01:52:20 <merijn> Also, probably better to use a library, yes
01:52:52 <tdammers> so rather than getContents (or hGetContents), either use a library that can read from a file directly (which will most likely implement streaming), or read your data in chunks
01:53:04 <tdammers> e.g., CSV can be read and parsed one line at a time
01:53:21 <merijn> tdammers: Meh, depends on the kinda data processing. Reading 500MB files can be fine if you need one-of jobs
01:53:33 <merijn> Lord knows I load larger files strictly :p
01:55:24 <jose9999> It is a noticeable speedup to read files line by line as opposed to all at once?
01:56:00 <pacak> merijn: I have a few 100Gb+ csv files...
01:56:00 <merijn> jose9999: Well, it mostly about keeping memory usage low. If you wanna process files of multiple gigabytes and only care about individual lines, why bother reading it all in
01:56:02 <jose9999> Oh, and thanks for pointing me to those libraries. It's much appreciated!
01:56:15 <merijn> pacak: And I have a machine with >100 GB memory ;)
01:56:37 <jose9999> merijn: I want to read the entire file as I need all its contents
01:56:49 <merijn> jose9999: conduit and pipes are libraries for making that sorta streaming easy (I'm pretty sure cassava will have a library to work with those)
01:57:24 <tdammers> jose9999: it's a tradeoff. If you can fit all the data in the available physical memory, then it won't matter much; but if you can't, then loading it anyway will cause swapping
01:58:00 <osa1> I need something like vim's CtrlP for quickly switching between modules in ghci..
01:58:27 <jose9999> Thanks! I think I can spare half a gig of RAM
01:58:57 <tdammers> then again, you may still see a slight performance improvement for the streaming approach, due to OS-level prefetching and caching on multicore hardware
01:59:46 <tdammers> that is, if you read one line, then you can start processing right away, but the OS may prefetch the next chunk from that file for you already and put it in a buffer, and then when you ask for the next line, it's already cached, so it loads faster
02:00:06 <tdammers> meaning that disk I/O and processing effectively run in parallel
02:00:14 <tdammers> I have no benchmarks to back this up though, and YMMV
02:01:58 <jose9999> tdammers: thanks for poiting this out. I'll explore this option
02:02:05 <phadej> merijn: there is https://hackage.haskell.org/package/cassava-conduit
02:18:36 * hackagebot hledger-diff 0.2.0.11 – Compares the transactions in two ledger files. – https://hackage.haskell.org/package/hledger-diff
02:47:44 <merijn> Opinion poll: Which name do people prefer? parMapM or parallelMapM?
02:48:58 <ski> @list poll
02:48:58 <lambdabot> poll provides: poll-list poll-show poll-add choice-add vote poll-result poll-close poll-remove
02:49:32 <mniip> parallel is too long to spell
02:49:58 <mniip> ghc already contains too many contractions of parallel to "par"
02:55:16 <cocreature> merijn: parMapM because parMap is already a thing
03:08:26 <xormor> my library reservation for "Programming in Haskell" by Graham has arrived at the library.
03:10:27 <xormor> Hutton, Graham: "Programming in Haskell"
03:10:32 <oherrala> mniip: I really like some of the common lisp's long function names. it's so readable
03:11:34 <Taneb> xormor, one of the two books I have a signed copy of! I hope you enjoy it
03:12:35 <mivael_> > let a = array (1,n) ((1,1) : [(i, i * a!(i-1)) | i <- [2..n]]); n=7 in assocs a  -- recurrence in definition?...  (http://hackage.haskell.org/packages/archive/array/latest/doc/html/Data-Array.html#v:array)
03:12:38 <lambdabot>  [(1,1),(2,2),(3,6),(4,24),(5,120),(6,720),(7,5040)]
03:12:49 <xormor> Taneb, yeah. I will have to get the book before or on the 10th day of this month. I was thinking I could walk and pick up the copy, but I am tired. I need to shower today.
03:13:12 <xormor> Taneb, maybe I will get the book tomorrow.
03:18:43 <ski> mivael_ : recursive (lazy) array begets top-down dynamic programming
03:23:24 <ski> mivael_ : exercise, write `memoArray :: Ix i => (i,i) -> (i -> e) -> (i -> e)' using this idea, so that `let (memoArray (0,12) -> fibs) = \case 0 -> 0; 1 -> 1; n -> fibs (n-1) + fibs (n-2) in fibs 12' will run in linear time
03:26:20 <Geekingfrog> I have a big file where each line is a UUID (and some duplicate). I want to group identical uuid and display that. But, this runs slowly and eat up all my ram: http://lpaste.net/358919 any idea ?
03:31:18 <pacak> Geekingfrog: How big is the file?
03:31:29 <Geekingfrog> about 8GB
03:31:45 <Geekingfrog> It could fit in RAM, but I'd rather not
03:32:13 <Geekingfrog> It's a somewhat trimmed down version of the final file that I will need to process, and that one will definitely not fit in ram.
03:32:23 <pacak> And how many duplicates are there?
03:32:56 <Geekingfrog> most ids appears around 20 times, but it varies a lot
03:33:16 <Geekingfrog> a version in python run in ~3min and doesn't take much mem
03:34:08 <pacak> What is foldC?
03:34:14 <pacak> foldlC
03:34:34 <ski> @hoogle foldlC
03:34:35 <lambdabot> Conduit foldlC :: Monad m => (a -> b -> a) -> a -> Consumer b m a
03:34:35 <lambdabot> Data.ByteString.Lazy foldlChunks :: (a -> ByteString -> a) -> a -> ByteString -> a
03:34:35 <lambdabot> Data.Text.Internal.Lazy foldlChunks :: (a -> Text -> a) -> a -> Text -> a
03:35:14 <Geekingfrog> http://hackage.haskell.org/package/conduit-combinators-1.1.1/docs/Conduit.html#v:foldlC
03:36:27 <pacak> Hmm... Are you compiling with optimizations
03:38:07 <Geekingfrog> Yes. Is there a way to check that on the final binary ?
03:38:15 <mivael_> ski, thanks
03:38:20 <mivael_> > let fibs = array (1,n) ((1,1) : (2,2) : [(i, fibs!(i-2) + fibs!(i-1)) | i <- [3..n]]); n=10 in (map snd . assocs) fibs
03:38:22 <lambdabot>  [1,2,3,5,8,13,21,34,55,89]
03:41:28 <Geekingfrog> Well, time to profile that thing instead of guessing.
03:41:34 <mniip> :t memoTree
03:41:36 <lambdabot> Integral t => (t -> p) -> t -> p
03:41:38 <mniip> yay
03:41:39 <Geekingfrog> will see how it goes
03:41:45 <mniip> fit it all on an IRC line
03:42:29 <merijn> Of course fibs is much more efficient with just a closed form solution :p
03:42:57 <pacak> Geekingfrog: Other than adding bangs to lambda \!m !k -> ... I have no ideas and most likely those bangs will be redundant...
03:43:20 <mniip> @let memoTree f = lup (jn (p2 (f . negate) 0 1) 0 (f 0) (p2 f 0 1)) where jn l a x r = Free (Compose ((a,x),bool l r)); lup (Free (Compose ((b, x), f))) a = case compare a b of { LT -> lup (f False) a; EQ -> x; GT -> lup (f True) a }; p2 f i j = jn (bi f i j) j (f j) (p2 f j (2 * j)); bi f i j = let m = (i + j) `div` 2 in jn (bi f i m) m (f m) (bi f m j)
03:43:21 <lambdabot>  Defined.
03:43:44 <ski> mivael_ : you did not define `memoArray', though
03:44:00 <mniip> no wait, negative numbers don't work here
03:44:43 <ski> mivael_ : also, `listArray' and `range' might be handy
03:45:43 * hackagebot hgrep 0.0 – Search Haskell source code from the command line – https://hackage.haskell.org/package/hgrep
03:46:00 <ski> merijn : without dubious rounding ?
03:46:24 <merijn> ski: huh?
03:46:41 <merijn> ski: I think closed form isn't the exact right term for what I wanted to say
03:46:50 <merijn> ski: But I couldn't be arsed to figure out a better one
03:46:53 <opqdonut> closed form without dubious rounding, sure
03:46:59 <opqdonut> just use the Z[sqrt(5)] ring
03:47:20 * ski thinks any Haskell program is a "closed form"
03:47:34 <cocreature> merijn: how about “non-shitty”
03:47:43 <mivael_> ski, I did not.  I think I did not understood the problem, then.
03:47:48 <merijn> ski: I meant a zipWith like variation of fibs, rather than the naive exponential recursive one
03:48:03 <ski> ah
03:48:47 <ski> i was thinking you had in mind the formula involving the golden ratio
03:49:20 <mniip> @let memoTree f = lup (jn (p2 (-1) 0) 0 (p2 0 1)) where jn l a r = Free (Compose ((a, f a),bool l r)); lup (Free (Compose ((b, x), f))) a = case compare a b of { LT -> lup (f False) a; EQ -> x; GT -> lup (f True) a }; p2 i j = if i >= 0 then jn (bi i j) j (p2 j (2 * j)) else jn (p2 (2 * i) i) i (bi i j); bi i j = let m = (i + j) `div` 2 in jn (bi i m) m (bi m j)
03:49:22 <lambdabot>  Defined.
03:49:22 <mniip> there we go
03:49:23 <ski> (merijn : but note that mivael_'s solution is not exponential recursive)
03:49:49 <merijn> ski: The memoised one?
03:49:56 <ski> right
03:50:10 <merijn> I was just saying that zipWith is a much easier way to accomplish the same result
03:50:35 <ski> yea, but doesn't generalize as easily to more complex dynamic programming :)
03:50:39 <mniip> > let fib = memoTree f; f 0 = 1; f 1 = 1; f n = fib (n - 1) + fib (n - 2) in fib 100
03:50:42 <lambdabot>  573147844013817084101
03:50:49 <ski> (which was the point i was mentioning this approach)
03:51:59 <mniip> this takes log(N) time tho
03:52:06 <mniip> can't get much better than that on an open interval
03:53:40 <EvanR> exactly what is the golden ratio a ratio of
03:54:23 <Taneb> Miles to kilometers
03:55:39 <Taneb> A less facetious answer is it's the number x such that (x-1) = (1/x)
03:55:52 <Taneb> Crops up a bunch in geometry
03:56:26 <EvanR> that doesnt answer my question specifically
03:56:27 <ski> "In geometry, a golden rectangle is a rectangle whose side lengths are in the golden ratio, .."
03:56:47 <EvanR> so the answer is, the ratio of side lengths in a golden rectangle
03:57:15 <ski> "A golden triangle, also known as the sublime triangle, is an isosceles triangle in which the duplicated side is in the golden ratio to the distinct side: .."
03:57:40 <Taneb> ... Not really? The golden rectangle is defined by the ratio, not the other way around
03:57:57 <EvanR> theres more than one way to define things
03:58:25 <Taneb> The ratio between the lengths of any two points on a pentagon are integer powers of the golden ratio I think
03:58:27 <EvanR> just trying to justify the name "ratio"
03:58:41 <opqdonut> to me it's a ratio of lengths of line segments
03:58:50 <Taneb> It's also the limit in infinity of the ratio between consecutive Fibonacci numbers
03:58:53 <ski> the golden rectangle is such that if you cut off a square having side equal to the shorter rectangle side, the rectangle you obtain (though turned) as the same side ratio as the original
03:58:57 <opqdonut> because you don't really see the A/B = B/(A+B) thing in a rectangle
03:59:30 <opqdonut> unlike here: https://en.wikipedia.org/wiki/Golden_ratio#/media/File:Golden_ratio_line.svg
03:59:53 <ski> the golden triangle can be obtained by taking a regular pentagon (or pentagram), and connecting two adjacent corners to their mutual opposite corner
03:59:56 <mniip> golden ratio pops up everywhere in pentagons, dodecahedra and icosahedara
04:00:07 <opqdonut> ski: I hadn't thought of this way
04:05:28 <exio4> Geekingfrog: just installed everything, that programs runs in constant memory (the file is is 2~ GB of 1,2,..,20000 repeated over and over)
04:06:10 <mivael_> ski, actually my focus was not on DP, Instead, I was trying to understand haskell "mechanics" behind recursive definition of arrays.  (How I understand it now: it is just a recursive function with non-strictness.  But my old habit of thinking about arrays imperatively somehow confused me when I first saw that recursive array definition.)
04:06:15 <Geekingfrog> exio4: Ok, so there is something wrong in my setup. I'm currently running (and compiling) the reduced version in an isolated project
04:06:41 <exio4> Geekingfrog: I just did cabal init; added everything into dependencies and then stack init && stack setup && stack build 
04:06:58 <Geekingfrog> with -O2 I believe
04:07:00 <mniip> mivael_, it's an array of thunks
04:07:02 <exio4> Geekingfrog: I'd check optimizations, you might have enabled some debug flags, I guess, have no idea really 
04:07:06 <ski> mivael_ : i gathered. i still wanted to explicitly point out this common use of it
04:08:02 <merijn> ugh...why is naming things so hard? :\
04:08:32 <ski> mivael_ : it's not just a recursive function (it's not even a function). given an implementation employing lazyness, elements will be cached, giving dynamic programming
04:08:33 <Geekingfrog> foo and bar are not enough anymore ?
04:08:37 <MichaelVB> properly naming things is hard
04:08:42 <merijn> Geekingfrog: Not for libraries :p
04:08:57 <MichaelVB> if you want shitty names just give me a call I got tons
04:09:04 <mniip> merijn, what do you need named
04:09:15 <mivael_> ski, I see
04:09:33 <mivael_> ski, mniip: thanks!
04:10:25 <merijn> mniip: I have some primitves for parallel execution and datatypes that describe how to react to exceptions. Right now I have: http://lpaste.net/358920 but Handler clashes with Handler from Control.Exception and Action is also rather generic...
04:10:32 <ski> mivael_ : one example of using it could be attempting an approximate match between a "text" and a "pattern" (the latter typically much shorter). we want to find occurances of the pattern in the text, allowing matchings to include omitting, replacing or inserting characters in the pattern, to make it fit. such changes comes with a cost, which should be minimized
04:11:12 <exio4> merijn: the problem is even harder in Haskell
04:11:32 <ski> mivael_ : one can describe this in terms of a recursively defined two-dim. array, where every cell but the top and left fringes is defined in terms of the three cells above, to the left, and above and to the left of it
04:11:44 <exio4> merijn: in many languages, things aren't this abstract, so you can get away with stuff of the kind LoginFactory
04:12:05 <merijn> (Naming suggestions welcome, btw)
04:12:11 <exio4> feels like this, at least :)
04:12:15 <M2tias> merijn: james?
04:12:17 <mniip> merijn, ExceptionResponse
04:12:26 <mniip> CatchAction
04:12:31 <mniip> or a blend of the two
04:12:56 <mniip> could also be Reaction instead of Action
04:13:04 <mivael_> ski, I'm aquaintant with dynamic programming.  Did not do much of it in Haskell, though.
04:13:12 <Geekingfrog> s/Handler/Rescuer/ ?
04:13:31 <mniip> Catcher
04:13:31 <merijn> mniip: Reaction is still rather generic, though :) CatchAction seems ok. ExceptionResponse is so long to type :p
04:13:48 <ski> mivael_ : it may not be obvious to beginners in Haskell how one can do dynamic programming, using recursive *immutable* arrays
04:13:56 <merijn> Handler would've been great if Control.Exception hadn't stole it :p
04:14:44 <mivael_> ski, yeah, I read a very good article on this some time ago (and tried on a toy problem)
04:14:58 <mniip> I think Drop is also a bad name
04:15:03 <mniip> maybe something like Ignore
04:15:10 <merijn> mniip: Why?
04:15:19 <mivael_> ski, It was an inspiring reading, indeed.
04:15:21 <mniip> and is Terminate really terminate and not Rethrow?
04:15:28 <ski> mivael_ : ok. i'm curious about which article this was, if you have a link handy
04:16:03 <merijn> mniip: This is used in (concurrent) stream processing code, so "Drop" drops an output element. And Terminate kills all the concurrent processors
04:16:30 <mniip> I see
04:16:51 <merijn> The data constructors of Action I'm actually fairly happy with
04:17:07 <merijn> Action itself is not great, not terrible
04:17:18 <merijn> A bit generic, but still
04:17:34 <merijn> Handler I'm very unhappy with due to Control.Exception.Handler
04:20:07 <mivael_> ski, I'll find the link and share.
04:25:22 * hackagebot easytensor 0.3.1.0 – Pure, type-indexed haskell vector, matrix, and tensor library. – https://hackage.haskell.org/package/easytensor
04:25:22 * hackagebot dimensions 0.3.1.0 – Safe type-level dimensionality for multidimensional data. – https://hackage.haskell.org/package/dimensions
04:39:36 <cloudhead> hey does anyone have examples of how to organize Arbitrary instances?
04:40:00 <merijn> cloudhead: In what sense?
04:40:22 <mivael_> ski, it was the "Lazy Dynamic Programming" blog post by Tikhon Jelvis (http://jelv.is/blog/Lazy-Dynamic-Programming).  It seems to appear among the top-10 of results for "dynamic programming haskell" web search request (I think this is the way how I found it at that time).
04:40:43 <cloudhead> merijn: like, where to put them, module-wise
04:41:01 <merijn> cloudhead: I'd probably put orphan instances in the test modules
04:41:40 <cloudhead> MyProject.Test.Arbitrary?
04:42:08 <merijn> Something like that
04:42:52 <tdammers> either make them not orphan instances (which means putting them in the same module that also defines the type
04:43:03 <tdammers> or keep them strictly within the test suite
04:43:22 <tdammers> if there is only one test module that uses them, put them there, otherwise put them in a shared module that you import into all the test case modules
04:44:12 <merijn> The downside of putting them in the main module is incurring a dependency on QuickCheck for your library
04:44:12 <tdammers> just don't make them orphan instances that you expose from the "real" (non-test) library or executable
04:44:23 <cloudhead> I see
04:45:23 * hackagebot HarmTrace-Base 1.6.0.0 – Parsing and unambiguously representing musical chords. – https://hackage.haskell.org/package/HarmTrace-Base
04:46:41 <cloudhead> tdammers: so this is a no-no: https://github.com/haskoin/haskoin/blob/master/haskoin-core/src/Network/Haskoin/Test/Block.hs ?
04:47:56 <ski> mivael_ : ty
04:48:20 <tdammers> cloudhead: I would say so, yes. The Network.Haskoin.Test.Block module should be moved to the test subproject.
04:49:57 <jose555> Hi!
04:50:19 <jose555> I just encountered some rather strange behavior with Integer overflow, which is highly confusing
04:50:22 <jose555> Here's the pastebin:
04:50:31 <jose555> http://lpaste.net/3954366339203727360
04:50:36 <cloudhead> tdammers: yeah, makes sense to me - any idea why they might have done it this way? Are there any benefits?
04:50:55 <tdammers> idk, probably just didn't give it much thought
04:50:56 <jose555> In the data definition, if I use Int then the output is fine, but with Integer, I get enormous negative numbers when computing the floor
04:50:58 <cloudhead> I don't suppose they use that code in the library
04:51:06 <tdammers> most likely not
04:51:09 <cloudhead> kk, thanks :)
04:51:21 <tdammers> using Arbitrary for things that aren't testing isn't really recommended, is it
04:51:31 <jose555> I've included console output too
04:51:35 <cheater> merijn: thanks. will GC free code using linear types mean that when you enter a linearly typed thunk, the GC doesn't get run until that thunk is done evaluating?
04:52:01 <merijn> cheater: No idea
04:52:03 <cheater> merijn: people said that's an eventual goal but isn't being worked on at all right now. do you agree? do you think we'll see it soon (ish?)
04:52:21 <jose555> It would be great if someone could have a link and let me know what is going wrong. To me, it seems to be an issue with Haskell internals
04:52:47 <merijn> lambdabot: logBase seems very suspicious
04:53:01 <tdammers> I'd think that linear types would allow for deterministic deallocation, similar to RAII
04:53:45 <jose555> merijn: logBase seems to give correct output when I execute it in ghci
04:54:50 <Athas> jose555: Haskell has dubious semantics for Float/Double, and will give you bogus results if you try to convert NaNs and infinites to integers.
04:55:22 <Athas> My guess is you try to evaluate 'logBase 2 0', and then round the result.
04:55:31 <Athas> > round (logBase 2 0)
04:55:34 <lambdabot>  -179769313486231590772930519078902473361797697894230657273430081157732675805...
04:56:01 <Athas> Haskell is not... a very good language for numerics.
04:56:09 <ski> jose555 : hm, are you sure you don't want to use `ceiling' rather than `floor' ..
04:56:38 <jose555> ski: depends on how to count; it's just throwaway code so not hugely important
04:56:51 <Athas> > ceiling (logBase 2 0)
04:56:51 <jose555> Athas: is there an elegant workaround for that kind of problem
04:56:54 <lambdabot>  -179769313486231590772930519078902473361797697894230657273430081157732675805...
04:57:02 <jose555> Also, thanks for your help!
04:57:04 <Athas> jose555: well, what do you want negative infinity to round to?
04:57:16 <Athas> It's easy enough to detect infinities.
04:57:26 <Athas> > isInfinite (logBase 2 0)
04:57:30 <lambdabot>  True
04:57:34 <jose555> '0' would be good
04:57:49 <jose555> oh, I didn't know about isInfinite
04:57:51 <jose555> Thanks!
04:57:55 <Athas> Just define your own function.
04:58:07 <merijn> This use of length is rather ugly anyway
04:58:24 <jose555> Athas: how come there are no issues when I use Int in the code?
04:58:53 <Athas> jose555: are you sure?
04:58:55 <ski> hm
04:58:57 <Athas> > ceiling (logBase 2 0) :: Int
04:58:59 <lambdabot>  0
04:59:06 <Athas> Huh.  Guess it overflows differently.
04:59:07 <srhb> It underflows and saves the day!
04:59:20 <jose555> merijn: what's bad about it? I'd rather use the shorthand than typing "length xs" three times
04:59:41 <merijn> jose555: Computing length of a list is slow
04:59:53 <merijn> jose555: I consider most uses of "length" to be a design flaw
05:00:33 <tdammers> merijn: as in, you picked the wrong data structure, or the wrong algorithm
05:00:49 <merijn> tdammers: Either or both
05:02:13 <tdammers> merijn: that's OR, not XOR
05:02:25 <ski> jose555 : i suppose you want to use `logBase 2 (len+2)', not `logBase 2 len' ?
05:03:53 * hackagebot crdt 1.0 – Conflict-free replicated data types – https://hackage.haskell.org/package/crdt
05:05:03 <wz1000> I would probably do: cHeight = 1 + max (height leftSubTree) (height rightSubTree)
05:07:13 <ski>   GHC.Types GHC.Integer.Logarithms> map (\n -> I# (integerLogBase# 2 n)) [1 .. 8]
05:07:16 <ski>   [0,1,1,2,2,2,2,3]
05:07:19 <ski> apparently rounds down
05:13:01 <jose555> merijn: how would you avoid "length" in my example?
05:13:47 <ski> the simplest thing to do would be to only compute `length' once, instead of repeatedly
05:13:54 <merijn> jose555: Something like this: https://gist.github.com/merijn/c163cc106fd245d1cf2e
05:14:16 <merijn> ski: Or use tortoise and hare trick to combine splitting and building new lists into a single traversal :p
05:15:10 <merijn> Anyone know which version of GHC first had LambdaCas?
05:15:59 <saurabhnanda> is there anything apart from ExceptT = m (Either e a) that implements the MonadError e m | m -> e typeclass?
05:16:07 <ski> merijn : i was rather pondering a `halve' operation, and then attempting to figure out how to then weave back into the original ord3ering :)
05:16:08 <srhb> merijn: I think it was around 7.4
05:16:38 <merijn> ski: Mind could be lazier, but it's fairly nice
05:16:40 <srhb> merijn: Actually maybe 7.6
05:16:47 <merijn> srhb: Ah, bummer
05:17:05 <srhb> merijn: https://downloads.haskell.org/~ghc/7.6.3/docs/html/users_guide/syntax-extns.html mentions LambdaCase, same page for 7.4.2 does not
05:17:15 <ski> merijn : *nod* .. something a bit similar can be done for `stripSuffix'
05:18:28 <srhb> merijn: Just checked, ghci 7.4.2 doesn't know about -XLambdaCase
05:18:33 <merijn> srhb: Right now my code builds with 7.4, would be a shame to limit it to 7.6 just to save 3 lines of code :\
05:18:54 <srhb> Well, it's not just those three lines, it's also the profound feeling of PROGRESS. :-)
05:18:57 <ski> merijn : hmm, pondering how your would look like, in terms of delimited continuations
05:21:54 <wz1000> merijn: holy shit, I wrote the almost exact same code(down to variable names) a couple of days ago when playing around.
05:22:12 <wz1000> http://lpaste.net/358921
05:22:44 <merijn> wz1000: Well, they're not such unique variable names ;)
05:23:05 <wz1000> yes, but haskell groupthink is scary
05:29:11 <saurabhnanda> is there an ELI5 for MonadMask? Specifically -- "A class for monads which provide for the ability to account for all possible exit points from a computation, and to mask asynchronous exceptions. Continuation-based monads, and stacks such as ErrorT e IO which provide for multiple failure modes, are invalid instances of this class."
05:29:35 <saurabhnanda> “Note that this package does provide a MonadMask instance for CatchT. This instance is only valid if the base monad provides no ability to provide multiple exit. For example, IO or Either would be invalid base monads, but Reader or State would be acceptable.”
05:29:42 <saurabhnanda> ^^ what does all that mean?
05:30:31 <cocreature> saurabhnanda: basically you need a way to guarantee that finalizers are executed. for things like ExceptT you can’t guarantee that because Left shortcircuits everything and your finalizers won’t be run
05:31:27 <cocreature> you’re rarely going to use MonadMask directly but "bracket" uses it internally
05:31:59 <saurabhnanda> cocreature: any examples of finalizers?
05:32:35 <cocreature> saurabhnanda: have you used "bracket" before?
05:32:51 <saurabhnanda> cocreature:  have used throwM extensively.
05:33:00 <cocreature> that was not my question :)
05:33:14 <saurabhnanda> just offering... not used bracket directly.
05:33:20 <cocreature> :t bracket
05:33:22 <lambdabot> IO a -> (a -> IO b) -> (a -> IO c) -> IO c
05:33:43 <cocreature> bracket allows you to implement functions that allocate and cleanup resources even if exceptions are thrown
05:34:24 <cocreature> :t \path mode f -> bracket (openFile path mode) closeHandle f
05:34:26 <lambdabot> error:
05:34:26 <lambdabot>     Variable not in scope: openFile :: t -> t1 -> IO a
05:34:26 <lambdabot> error:
05:34:31 <cocreature> meh
05:34:37 <mniip> % :t \path mode f -> bracket (openFile path mode) closeHandle f
05:34:38 <yahb> mniip: ; <interactive>:1:46: error: Variable not in scope: closeHandle :: Handle -> IO b0
05:34:44 <mniip> % :t \path mode f -> bracket (openFile path mode) hClose f
05:34:45 <yahb> mniip: \path mode f -> bracket (openFile path mode) hClose f :: FilePath -> IOMode -> (Handle -> IO c) -> IO c
05:34:52 <cocreature> there you go :)
05:34:59 <cocreature> that’s "withFile"
05:35:15 <cocreature> closeHandle is the finalizer
05:35:36 * ski . o O ( `splitTwo :: [a] -> ([a],[a]); splitTwo xs = reset (go xs xs) where go :: [a] -> [a] / [a] -> ([a],[a]); go xs [] = shift c in (c [],xs); go xs [_] = shift c in (c [],xs); go (x:xs) (_:_:ys) = x : go xs ys' )
05:35:43 <cocreature> and "bracket" guarantees that even if something throws an exception, the handle will be closed (or at least attempted to be closed)
05:35:57 <cocreature> mniip: btw, that’s pretty neat, what exactly can yahb do?
05:36:13 <mniip> it's basically like a ghci session
05:36:47 <cocreature> so no SafeHaskell restrictions or things like that?
05:36:50 <mniip> no
05:36:50 <saurabhnanda> cocreature: ok, understood till this point...
05:36:57 <mniip> it's a process level sandbox not language level
05:37:00 <cocreature> nice!
05:38:27 * hackagebot language-vhdl 0.1.3 – VHDL AST and pretty printer in Haskell. – https://hackage.haskell.org/package/language-vhdl
05:39:45 <ski> @type (\path mode -> ContT (bracket (System.IO.openFile path mode) System.IO.hClose)) :: FilePath -> System.IO.IOMode -> ContT o IO System.IO.Handle
05:39:47 <lambdabot> FilePath -> GHC.IO.IOMode.IOMode -> ContT o IO GHC.IO.Handle.Types.Handle
05:40:01 <mniip> cocreature, it has a bit of a thing for memory and time limits though
05:41:02 <cocreature> ski: oh so that’s why @type is a thing if we already have :t :)
05:42:30 <ski> ?
05:42:31 <merijn> saurabhnanda: bracket is basically haskell's equivalent of python's "with" block
05:42:36 <merijn> or try/finally
05:42:38 <mniip> it does in theory keep state
05:42:41 <mniip> % x = 1
05:42:42 <yahb> mniip: 
05:42:43 <mniip> % x
05:42:43 <yahb> mniip: ; <interactive>:10:1: error: Variable not in scope: x
05:42:53 <mniip> ...in theory
05:42:56 <ski> @slap yahb
05:42:57 <lambdabot> I'd rather not; yahb looks rather dangerous.
05:45:11 <mniip> that is weird
05:45:39 <mniip> % let x = 1
05:45:40 <yahb> mniip: 
05:45:40 <mniip> % x
05:45:41 <yahb> mniip: 1
05:45:46 <mniip> not exactly sure what's going on there
05:46:33 <Geekingfrog> exio4 pacak regarding my streaming count for the big file, it seems the problem was with the hashmap implementation. Immutable map aren't good there. I switched to a mutable one, and I get the same time as the python script.
05:47:57 <pacak> Geekingfrog: Interesting... You can also try Map from containers
05:49:18 <mniip> ah isn't this awesome
05:49:36 <ski> cocreature : what do you mean ?
05:49:40 <mniip> %% :show bindings
05:49:42 <yahb> mniip: http://qp.mniip.com/y/94
05:50:19 <mniip> % x = 1
05:50:20 <yahb> mniip: 
05:50:21 <mniip> %% :show bindings
05:50:22 <yahb> mniip: http://qp.mniip.com/y/95
05:50:44 <cocreature> ski: oh nvm, for some reason I thought ":t System.IO.hClose" doesn’t work
05:51:23 <mniip> well I think it is a -fobject-code problem
05:51:41 <mniip> can reproduce locally
05:51:47 <ski> `@type' is a lambdabot thing
05:52:53 <saurabhnanda> staring at https://www.stackage.org/haddock/lts-9.0/postgresql-simple-0.5.3.0/src/Database.PostgreSQL.Simple.Transaction.html#withTransactionMode -- does it look like the "COMMIT" is being issued even if there was an exception while running the computation?
05:59:26 <bbrodriguez> ugh, using C and x86/x64 asm nearly exclusively for the last 20ish years, learning how to think this way is proving to be quite a challenge
05:59:42 <bbrodriguez> anyone got any advice or just "stick with it"?
06:00:21 <Psybur> just stick with it. Take a project you've done in the past and convert it to haskell
06:00:23 <saurabhnanda> think this way = functionally?
06:00:31 <mauke> you might want to ease up to it, maybe via Perl -> OCaml -> Haskell
06:01:01 <mauke> on the other hand, I still found the last step hard ¯\_(ツ)_/¯
06:01:42 <ski> bbrodriguez : probably you've already heard this, but "forget everything you know"
06:01:50 <ski> (about programming)
06:02:33 <ski> the point is to try to get into the mindset of learning programming all over from scratch again, suspending preconceptions and comparisions to what you already know
06:03:21 <ski> (obviously stuff do carry over, but less than one would think, not having tried a significantly different programming paradigm before)
06:04:57 <will> Does anyone know if there's a function that does the same thing as: (sequence . (fmap sequence)) - ie what sequence does but over 2 "layers"?
06:07:10 <ski> @. hoogle type sequence . fmap sequence
06:07:12 <lambdabot> Pipes.Core reflect :: Monad m => Proxy a' a b' b m r -> Proxy b b' a a' m r
06:07:13 <lambdabot> Pipes.Internal observe :: Monad m => Proxy a' a b' b m r -> Proxy a' a b' b m r
06:07:13 <lambdabot> Development.Shake.Language.C.BuildFlags (>>>=) :: Monad m => m (a -> b) -> m (b -> c) -> m (a -> c)
06:07:30 <sphalerite> I want to write a little tool with prompts that provide autocomplete. Is https://hackage.haskell.org/package/readline-1.0.1.0 a sensible choice?
06:07:31 <ski> lambdabot's Hoogle doesn't seem to find it
06:07:47 <fendor> :t sequence
06:07:49 <lambdabot> (Monad m, Traversable t) => t (m a) -> m (t a)
06:08:15 <will> ski: thanks!  I checked out hoogle and couldn't find anything very promising
06:08:33 <ski> will : how are you wanting to use it ?
06:08:57 <mnoonan> I think you could use Compose on the traversables, then sequence the whole thing
06:09:10 <will> Basically to hash a password inside a structure - ie:
06:09:11 <will> liftIO $ (sequence . (fmap sequence) . (fmap . fmap) saltPass) passwordR
06:09:16 <ski> mnoonan, point
06:09:24 <will> (where passwordR :: FormResult (Maybe Text)
06:10:03 <ski>   liftIO (mapM (mapM saltPass) passwordR)  -- how about this ?
06:10:37 <ski>   liftIO ((mapM . mapM) saltPass passwordR)  -- variation
06:10:51 <ski> @type mapM . mapM
06:10:52 <lambdabot> (Traversable t2, Traversable t1, Monad m) => (a -> m b) -> t1 (t2 a) -> m (t1 (t2 b))
06:10:59 <will> ski: huh, nice!  Thanks
06:11:15 <ski> will : that's why i asked. i was suspecting something like this
06:11:57 <ski> @type mapM (mapM return)  -- another way to spell `sequence . fmap sequence'
06:11:58 <lambdabot> (Traversable t2, Traversable t1, Monad m) => t1 (t2 b) -> m (t1 (t2 b))
06:12:16 <ski> oh, actually, not quite, it should be
06:12:21 <ski> @type mapM (mapM id)
06:12:22 <lambdabot> (Traversable t2, Traversable t1, Monad m) => t1 (t2 (m b)) -> m (t1 (t2 b))
06:12:39 <Psybur> :t (.)(.)
06:12:41 <lambdabot> (a1 -> b -> c) -> a1 -> (a2 -> b) -> a2 -> c
06:13:00 <ski> (the former should amount to just `return', at least for finite traversables)
06:14:48 <will> @type mapM . mapM
06:14:50 <lambdabot> (Traversable t2, Traversable t1, Monad m) => (a -> m b) -> t1 (t2 a) -> m (t1 (t2 b))
06:15:21 <ski> @type map . map
06:15:23 <lambdabot> (a -> b) -> [[a]] -> [[b]]
06:15:34 <ski> @type fmap . fmap
06:15:35 <lambdabot> (Functor f2, Functor f1) => (a -> b) -> f1 (f2 a) -> f1 (f2 b)
06:16:38 <Taneb> @type traverse . traverse
06:16:40 <lambdabot> (Traversable t2, Traversable t1, Applicative f) => (a -> f b) -> t1 (t2 a) -> f (t1 (t2 b))
06:17:36 <ski> @type liftM2 . liftM2
06:17:37 <lambdabot> (Monad m2, Monad m1) => (a1 -> a2 -> r) -> m1 (m2 a1) -> m1 (m2 a2) -> m1 (m2 r)
06:18:21 <Taneb> Ooh, I didn't realise liftM2 would work
06:18:56 <ski> @type zipWith . zipWith
06:18:58 <lambdabot> (a -> b -> c) -> [[a]] -> [[b]] -> [[c]]
06:19:33 <mpickering> Is there a way to name existentially quantified type variables in local definitions?
06:21:31 <tabaqui> ListT is marked as deprecated
06:21:37 <tabaqui> is there a replacement?
06:21:40 <mniip> :t fmap ((`fmap` bimap) . fmap . bimap) . bimap
06:21:41 <lambdabot> (Bifunctor p3, Bifunctor p2, Bifunctor p1) => (a1 -> b1) -> (c1 -> d1) -> (a2 -> b2) -> (c2 -> d2) -> p2 (p3 a1 c1) (p1 a2 c2) -> p2 (p3 b1 d1) (p1 b2 d2)
06:21:44 <mniip> almost as bbeautiful
06:22:30 <lyxia> mpickering: with scopedtypevariables, type annotations in patterns bind type variables
06:23:06 <tabaqui> okaay, mtl.ListT isn't
06:23:15 <tabaqui> but transformers.ListT is deprecated
06:23:17 <tabaqui> hmm
06:24:09 <merijn> tabaqui: pipes has a "ListT done right"
06:24:32 <merijn> tabaqui: The problem is that ListT doesn't play nice with many transformers
06:25:55 <tabaqui> wts? pipes lib uses MonadTrans from mmorph
06:25:59 <tabaqui> not from transformers
06:26:29 <tabaqui> spaghetti
06:27:42 <merijn> tabaqui: mmorph just reexports MonadTrans from mtl
06:28:05 <merijn> tabaqui: or transformers, whatever it is
06:28:39 <tabaqui> merijn: hm, you're right, ok
06:29:05 <tabaqui> well, pipes looks powerfull
06:29:23 <tabaqui> I mean, the whole package, not just ListT
06:29:32 <merijn> tabaqui: Yeah, pipes and conduit are nice
06:30:40 <tabaqui> thanks, I'll check both
06:31:04 <lyxia> also quiver
07:06:33 <saurabhnanda> can onException's handler throw an exception again? will bad things happen if it does?
07:07:20 <merijn> It can, but then you lose the original exception
07:08:19 <saurabhnanda> merijn: but, I can do something and re-raise it?
07:08:36 <merijn> saurabhnanda: onException already reraises
07:08:55 <merijn> It doesn't catch exceptions, it just runs a finalizer if when happens
07:09:16 <saurabhnanda> so, if I have to suppress certain kinds of exceptions, onException is not what I should be using. Something like catchIf, right?
07:09:36 <merijn> I'd use catch or handle, but yes
07:10:44 <saurabhnanda> and I can do all this within a `mask`? ( I still don't understand what `mask` really does)
07:11:54 <merijn> saurabhnanda: Mask blocks asynchronous exceptions, you need it to make sure you can do things without getting interrupted
07:12:24 <saurabhnanda> async exceptions == some random thread pawning off some exception to this thread?
07:12:29 <merijn> yes
07:13:06 <merijn> saurabhnanda: bracket blocks exceptions while allocating resource and installing the exception handler, then unmasks exceptions before running the body
07:13:31 <Eduard_Munteanu> @src bracket
07:13:31 <lambdabot> bracket before after thing = block $ do
07:13:31 <lambdabot>     a <- before
07:13:31 <lambdabot>     r <- catch (unblock (thing a)) (\e -> after a >> throw e)
07:13:31 <lambdabot>     after a
07:13:31 <lambdabot>     return r
07:13:49 <merijn> saurabhnanda: This guarantees async exceptions happen either 1) before anything is allocated or 2) after allocation *AND* after the cleanup exception handler is installed
07:14:19 <merijn> saurabhnanda: If you can't mask async exception you might get an exception AFTER allocation but BEFORE installing the handler == bug
07:14:34 <Eduard_Munteanu> (Well, mask $ \unblock -> do ...)
07:14:37 <merijn> saurabhnanda: Which is why bracket/onException/etc. need mask
07:15:11 <saurabhnanda> thanks.
07:17:11 <Eduard_Munteanu> By the way, does mask delay or simply ignore the exception?
07:17:19 <merijn> Eduard_Munteanu: Delay
07:17:33 <merijn> Eduard_Munteanu: It's actually slightly trickier
07:17:47 <merijn> Eduard_Munteanu: mask delays exceptions *while the thread isn't blocked*
07:18:00 <merijn> Eduard_Munteanu: So blocking on an MVar unmasks you
07:18:09 <merijn> Eduard_Munteanu: (To help prevent deadlocking code)
07:19:00 <Eduard_Munteanu> So it kinda turns async exceptions into sync ones if blocking.
07:19:08 <merijn> Eduard_Munteanu: If you wanna keep them blocked even there you have to use uninterruptibleMask
07:19:11 <merijn> Eduard_Munteanu: Yes
07:20:11 <Eduard_Munteanu> I'm not entirely sure how cleanup works, if it's supposed to work, with synchronous exceptions, though. You can't really mask those.
07:20:43 <Eduard_Munteanu> But they are sort of fatal anyway.
07:21:03 <merijn> Eduard_Munteanu: That's like an exception occuring in the finally of try-finally
07:21:09 <merijn> Eduard_Munteanu: At that point you're boned anyway
07:21:21 <Eduard_Munteanu> Yeah.
07:30:43 <saurabhnanda> does this look like it's doing the right thing? -- https://gist.github.com/saurabhnanda/0598a3fdb31d54e8b71fbf5e21df0d73 -- if the application raises a RedirectAndCommit, then the current db txn is committed and the error is re-raised for servant to catch it and issue a 301/302 redirect. For everything else, the db txn is rolled back?
07:33:00 <merijn> Looks reasonable
07:42:01 <saurabhnanda> merijn: thanks.
07:50:07 * hackagebot schematic 0.3.2.0 – JSON-biased spec and validation tool – https://hackage.haskell.org/package/schematic
07:51:03 <dfsafd> how do you import data constructors from modules? import ModName (ConsName) gives a Not in scope error
07:51:27 <merijn> dfsafd: "import ModName (TypeName(ConsName))"
07:51:44 <merijn> dfsafd: Or "import ModName (TypeName(..))" to import all of TypeName's constructors
07:52:19 <merijn> dfsafd: Same for import methods of a typeclass
07:52:21 <dfsafd> thank you
07:55:59 <mmaruseacph2> question: is there a way to specify in project.cabal that I want one test-suite to be built but never run when doing `cabal test`?
07:56:16 <merijn> mmaruseacph2: Don't think so?
08:01:16 <mmaruseacph2> :( then PR time or actually a good use for Acme.Dont
08:01:37 <lyxia> you could make your main take a flag to execute it
08:01:52 <mmaruseacph2> that's what I had now but wanted to get rid of the glag
08:01:53 <mmaruseacph2> *flag
08:02:06 <lyxia> stack has a --no-run-tests options, perhaps cabal too?
08:02:18 <mmaruseacph2> but I want to run the other test suites
08:02:53 <mmaruseacph2> more context: I have some QuickCheck tests which fail with some probability, marking them as expectFailure will still fail them when they don't fail
08:02:55 <merijn> mmaruseacph2: You can run individual tests using "cabal new-test name"
08:03:20 <mmaruseacph2> so I want to move those tests to a new suite and run only the tests in the other suites
08:03:24 <merijn> mmaruseacph2: Why not just eliminate/disable those tests?
08:03:38 <mmaruseacph2> merijn: that's true, but that's specifying them by name
08:04:03 <mmaruseacph2> merijn: they test a fast moving code base, don't want them to get stale by the time I update them to not fail that often
08:05:01 <mmaruseacph2> I want them to compile, just not run
08:05:08 <mmaruseacph2> guess I'll stick with the flag for a while longer
08:05:39 <merijn> mmaruseacph2: Change the main of the test-suite to "exitSuccess >> currentMain"
08:05:54 <merijn> mmaruseacph2: exit-code tests only check exit code anyway
08:06:39 <cocreature> mmaruseacph2: make it an executable instead of a test suite?
08:07:10 <mmaruseacph2> cocreature: that's it, thanks :)
08:07:21 <mmaruseacph2> one word change in the cabal file
08:07:54 <cocreature> you might also need to remove the "type: exitcode-stdio-1.0" line
08:08:04 <cocreature> not sure what happens when that is specifed for an executable
08:08:19 <mmaruseacph2> will test it in 30 mins when I get in the office
08:13:24 * hackagebot syntactic 3.7 – Generic representation and manipulation of abstract syntax – https://hackage.haskell.org/package/syntactic
08:17:39 <sphalerite> is there nothing like this maybeRead in the base library? https://hackage.haskell.org/package/cgi-3001.3.0.2/docs/Network-CGI-Protocol.html#v:maybeRead
08:20:02 <Taneb> sphalerite, there's Text.Read
08:20:07 <Taneb> .readMaybe
08:24:07 <mmaruseacph2> cocreature: not removing that line gives a warning but compilation proceeds so all is good
08:28:05 <dfsafd> this is consistent: -0*2 = 0, -0.0*2 = -0.0
08:28:11 <dfsafd> negative zeroes are lame :p
08:28:31 <ski> @palomer
08:28:32 <lambdabot> Blargh!
08:29:16 <dfsafd> INconsistent :)
08:30:05 <merijn> That's because
08:30:07 <merijn> > -0
08:30:09 <lambdabot>  0
08:30:12 <merijn> > -0.0
08:30:15 <lambdabot>  -0.0
08:30:30 <ski> > -0.0 == 0.0
08:30:33 <lambdabot>  True
08:30:46 <sphalerite> Taneb: right, thanks!
08:31:46 * hackagebot butcher 1.2.0.0 – Chops a command or program invocation into digestable pieces. – https://hackage.haskell.org/package/butcher
08:32:38 <monochrom> I should check out butcher some time.
08:51:46 <merijn> heh
08:52:18 <merijn> I have some code that parallelises tasks over forkIO. I had some simple tests to check that I do get roughly linear speedup like I should and this works fine on linux
08:52:37 <merijn> But running the exact same code on OSX is resulting in ridiculous slowdown isntead of speedup...
08:52:46 <vktec> Is there a version of foldl that passes the tail of the list to the function as well as the head? I tried Hoogling (a -> b -> [b] -> a) -> a -> [b] -> a but got nothing
08:57:30 <hexagoxel> monochrom: it is the evil brother of optparse-applicative :D
08:59:46 <monochrom> Yeah heh
08:59:46 <hexagoxel> i think there could be a library in between, with nicer parsing for subcommands but without the monad-abusing that butcher does. but i don't have time to write that one, too.
09:01:50 <infandum> Is it possible to call scikit-learn from haskell?
09:02:02 <hexagoxel> s/parsing for subcommands/interface for defining subcommands/
09:04:07 <ski> vktec : hm, if you had said version of `foldr', then i'd suggested looking into paramorphisms (`para' in `recursion-schemes', e.g.)
09:04:27 <ski> vktec : how about using `tails' or `init . tails' on the list beforehand ?
09:05:46 <vktec> Yeah, tails should work. Thanks ski
09:13:09 * hackagebot brick 0.26 – A declarative terminal user interface library – https://hackage.haskell.org/package/brick
09:16:47 <bartavelle> (I just used brick today, it is very easy to use and really handy)
09:20:38 <michalrus> Hey, if I’ve got `data Procol = MsgA { a :: A } | MsgB { b :: B }` (I know I shouldn’t probably do that, but Aeson encourages that), how can I generate random values ∀ {MsgA,MsgB,…} for documentation purposes?
09:21:21 <michalrus> Gen from QuickCheck wouldn’t necessarily give me all cases…
09:21:37 <bartavelle> michalrus: write an Enum instance :)
09:21:41 <bartavelle> and a Bounded
09:23:30 <michalrus> Nice, I’ll investigate that. (: Thanks.
09:38:35 * hackagebot geni-util 0.25.0.1 – Companion tools for use with the GenI surface realiser – https://hackage.haskell.org/package/geni-util
09:38:35 * hackagebot GenI 0.25.0.1 – A natural language generator (specifically, an FB-LTAG surface realiser) – https://hackage.haskell.org/package/GenI
09:39:50 <berkley> Haskell noob here. Can anyone tell me why the following implementation of the fibonacci sequence fails on inputs n = 0 and 1? "fib n = (xs!!(n-1)) + (xs!!(n-2)) where xs = 0:1:map fib [2..]"
09:40:26 <mnoonan> berkley: you're indexing xs at position -1
09:40:45 <berkley> mnoonan: But shouldn't xs be [0,1] at that point?
09:40:58 <berkley> oh I'm an idiot
09:41:02 <berkley> Nevermind :P
09:41:57 <berkley> Gotta actually specify the base cases.... 
09:46:10 <Psybur> Is there a much more efficient way of taking the first n elements of a list and turning them into a vector than this: V.fromListN n $ take n xs
09:49:02 <Psybur> Maybe unfoldrN ?
09:51:26 <cocreature> Psybur: https://hackage.haskell.org/package/vector-0.12.0.1/docs/Data-Vector.html#v:fromListN
09:51:51 <dfsafd> is there a hunit variant of the @?= operator for approximate equals?
09:52:22 <Psybur> Whoops, looks like my take is redundant
09:52:41 <Psybur> But would using unfoldrN be faster than using take?
09:53:42 <Psybur> I suppose not, I would imagine the better version would be whats used
09:56:54 <Psybur> Never mind, unfold wont work anyway :D
10:08:24 <mustlearnhaskell> is there something like (a >>= b) that works if a returns an IO [a] and b accepts an IO [a]? 
10:08:45 <mustlearnhaskell> i could only get it to work with single values
10:08:46 <mauke> b a
10:09:09 <mowj> azsdjxck6kqdm7oz [DOT] onion Donate Satoshibox [dot] com 1NsrmzhDdAbSCccTv39NomzZNV1mS8zV6A
10:09:11 <c_wraith> mustlearnhaskell, what type would you like?
10:09:21 <mauke> mowj: ?
10:09:30 <mustlearnhaskell> uhhh sorry, b accepts [a], not IO [a]
10:09:46 <c_wraith> mustlearnhaskell, these sorts of questions are to answer if you provide a full type
10:09:48 <cocreature> mustlearnhaskell: "a >>= b" should work in that case
10:09:59 <geekosaur> then it's >>=. show the actual code that fails and the full error.
10:10:02 <geekosaur> @lpaste
10:10:02 <lambdabot> Haskell pastebin: http://lpaste.net/
10:10:09 <c_wraith> are much easier to answer, that is.
10:10:24 <mustlearnhaskell> ok one sec
10:11:24 * hackagebot conduit-algorithms 0.0.5.0 – Conduit-based algorithms – https://hackage.haskell.org/package/conduit-algorithms
10:12:21 <mustlearnhaskell> http://lpaste.net/6368673030876430336
10:12:53 <mustlearnhaskell> getHydrantData is a Connection -> IO [HydrantData]
10:12:58 <c_wraith> mustlearnhaskell, please add the error message to it.
10:13:21 <ggVGc> haskell has no errors
10:13:25 <mustlearnhaskell> this version works. the one with >>= prints an error, one sec.
10:15:03 <c_wraith> :t fmap
10:15:05 <lambdabot> Functor f => (a -> b) -> f a -> f b
10:16:45 <mustlearnhaskell> the version that doesnt work http://lpaste.net/6368673030876430336
10:17:30 <c_wraith> mustlearnhaskell, see fmap
10:17:49 <mustlearnhaskell> ok let me think :)
10:19:30 <hexagoxel> does hackage.fpcomplete.com work properly? my cabal update timeouts.
10:19:39 <mustlearnhaskell> but doesnt map apply the function to the individual elements? listToJSONPretty is supposed to take the entire list as one
10:19:45 <mustlearnhaskell> (or fmap)
10:20:01 <c_wraith> mustlearnhaskell, fmap applies to whatever the outermost type constructor is
10:20:08 <c_wraith> in this case, that's IO
10:21:05 <c_wraith> mustlearnhaskell, so instead of lifting the operation to work on list elements, it's lifted to work on IO values
10:21:24 <jle`> fmap :: (a -> b) -> IO a -> IO b
10:21:44 <mustlearnhaskell> thanks, this works:     fmap listToJSONPretty (withResource (pgPool app) getHydrantData)
10:21:45 <jle`> fmap :: Int -> Bool -> IO Int -> IO Bool
10:21:54 <jle`> * (Int -> Bool) -> IO Int -> IO Bool
10:22:03 <jle`> etc.
10:22:28 <c_wraith> mustlearnhaskell, there's also an infix name for fmap, if you'd prefer to use it: (<$>)
10:23:42 <mustlearnhaskell> thanks. i just started with haskell a month ago. sorry to take up your time with trivial questions :)
10:24:07 <c_wraith> mustlearnhaskell, that's an important question, actually. it's a very good thing to learn
10:27:12 * hackagebot git-annex 6.20171003 – manage files with git, without checking their contents into git – https://hackage.haskell.org/package/git-annex
10:28:05 <bsamorim> Hi, total Haskell noob here. Does Haskell have a standard? If so, where can I find its reference?
10:28:13 <mauke> @where report
10:28:13 <lambdabot> http://www.haskell.org/onlinereport/haskell2010/ (more: http://www.haskell.org/haskellwiki/Definition)
10:28:33 <mauke> bsamorim: ^
10:28:35 <bsamorim> @lambdabot: thx!
10:28:35 <lambdabot> Unknown command, try @list
10:28:41 <c_wraith> note that ghc does not implement the specification 100% faithfully
10:28:44 <bsamorim> mauke: thanks!
10:28:44 <jle`> bsamorim: it does, and it's pretty readable.  however keep in mind that no modern implementation of haskell actually adheres to the standard exactly
10:29:12 <bsamorim> jle`: to the point where it's useless to read it if i'm using ghc?
10:29:15 <jle`> there is some work in progress to update the language spec to reflect recent changes in modern implementations of haskell
10:29:22 <jle`> bsamorim: it's definitely not useless
10:29:29 <jle`> it's still useful, all of it :)
10:29:41 <kuribas> What can I use to generate bezier curves for testing?  I'd like to generate different types, colinear, with cusps, loops, inflection points, degenerate, etc...
10:29:51 <bsamorim> I just wanted to find a non-cute intro to Haskell
10:30:00 <jle`> it is probably not good as an intro to haskell
10:30:05 <jle`> it's more of a very readble reference
10:30:19 <jle`> an intro to haskell should tell you how to program haskell, not what haskell is
10:30:21 <mauke> bsamorim: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/bugs.html#haskell-standards-vs-glasgow-haskell-language-non-compliance
10:30:37 <bsamorim> mauke: thanks a lot!
10:30:46 <jle`> @where learnhaskell
10:30:46 <lambdabot> https://github.com/bitemyapp/learnhaskell
10:30:56 <jle`> a good portion of these can be considered non-cute
10:31:26 <bsamorim> jle`: yeah, you're totally right!
10:31:49 <ski> @where gentle
10:31:49 <lambdabot> http://www.haskell.org/tutorial/
10:31:51 <ski> bsamorim : you might try the ^ "Gentle" Introduction to Haskell (98) in 2000-06 by Paul Hudak,John Peterson,Joseph Fasel,(rev. by Reuben Thomas)
10:32:09 <bsamorim> ski: thanks, I'll check it out. 
10:32:18 <kuribas> If I use quickcheck how can I be sure all types are generated?
10:32:23 <bsamorim> What about specifically monads? How could I learn about them? 
10:32:28 <jle`> if you start off with a language spec, you might be tempted to try to program how you used to program, but adapt it to haskell syntax. this is a sure recipe for disaster
10:32:34 <bsamorim> (Not necessarily in an Haskell environment)
10:32:34 <ski> bsamorim : that one might be too ungentle, unless you already know a bit about functional programming, though ..
10:32:47 <jle`> also effective haskell programming uses libraries too which aren't in the standard
10:32:49 <kuribas> bsamorim: I found spj's paper very enlighting.
10:32:56 <ski> bsamorim : .. also, it's somewhat old. but not that long
10:33:23 <bsamorim> kuribas: do you have a link?
10:33:32 <jle`> bsamorim: my best advice (even though it's not what you're asking for) is to not specifically set out to learn about monads, but rather to start using different monads in practical situations until you gain the inuition yourself
10:33:42 <kuribas> bsamorim: the "gentle introduction" about monads is totally useless, unless you already know monads...
10:33:53 <ski> bsamorim : learn about monads by learning about the kind of boiler-plate code they help to avoid. first make sure to grasp the basic type system, including type classes
10:34:16 <mauke> I'm not convinced "learning monads" makes sense
10:34:29 <shapr> yeah, ski has the right of it
10:34:31 <ski> kuribas : where is that ?
10:35:05 <bsamorim> jle`: yeah, I actually saw an introduction to parsec and decided to make a system in Haskell that reads music in a syntax to be defined and played the sound that it read.
10:35:24 <shapr> bsamorim: oh that sounds cool
10:35:26 <bsamorim> I suppose I would need monads for soundcard I/O, wouldn't I?
10:35:31 <shapr> bsamorim: have you seen haskore?
10:35:36 <shapr> or tidal cycles?
10:35:40 <bsamorim> shapr: no!
10:35:46 <mnoonan> maybe add "understand higher-kinded types", too.
10:36:35 <kuribas> bsamorim: I cannot find it...
10:37:01 <ski> bsamorim : in case you know any C++, then perhaps <https://www.youtube.com/results?search_query=Bartosz+Milewski+Monad> could be interesting
10:37:15 <jle`> bsamorim: you need soundcard IO for soundcard IO
10:37:26 <ski> bsamorim : parsing is a good example of a non-trivial monad
10:37:27 <jle`> whether or not it's a monad is not a part of its usefulness
10:37:28 <bsamorim> ski: I've actually learned "Learn Haskell for a Greater Good" a while ago....so I'm guess me/haskell = paul mccartney/piano: too noob to say that I actually know anything, too expert to begin from scratch
10:37:33 <jle`> for making sounds
10:37:44 <jle`> er, i guess that was phrased a little weird
10:37:59 <bsamorim> shapr: I'm checking it out right now...thanks for the tip!
10:38:06 <jle`> but if you need to do soundcard IO, you need soundcard IO.  think "where is soundcard io", not "where is the monad"
10:38:11 <ski> i think people here tend to not recommend LYAH that much, for learning i.e.
10:38:27 <shapr> bsamorim: I really like http://tidalcycles.org/
10:38:47 <ski> mnoonan : that is included in "grasp the basic type system" :)
10:38:56 <mnoonan> fair enough!
10:40:38 <bsamorim> Simply put ( and I know that this may piss off many folks - haskell is, before anything else, useful), I wanted to learn Haskell because it is SEXY!
10:40:58 <ski> (by non-basics of type system, i mean the extensions)
10:41:27 <ski> well, i found learning Haskell fun. you might as well
10:41:33 <shapr> bsamorim: it is certainly my favorite language
10:45:08 <Psybur> What would the equivalent of catMaybes be for a Vector? filter the nothings and then map fromJust ?
10:47:10 <c_wraith> I found learning haskell fun because I felt like the only new things I was running into in other languages were just needlessly complicated, like metaclasses in python. haskell showed me there was still a ton of things to learn that were no needlessly complex.
10:47:44 <c_wraith> were *not*
10:48:23 <shapr> I hit the edges of Python in a few years, I haven't yet hit the edges of Haskell
10:48:24 <mnoonan> Psybur: "concatMap (maybe empty singleton)"?
10:48:28 <ski> bsamorim : perhaps "What the hell are Monads?" by Noel Winstanley in 1999 at <http://www-users.mat.uni.torun.pl/~fly/materialy/fp/haskell-doc/Monads.html> (albeit a little bit dated, and not thorough) could start to give you an idea of what the raison d'être of monads (in programming) is
10:48:45 <bsamorim> ski: thanks, I'll check it out!
10:49:04 <Psybur> mnoonan, I was looking at that, it seems the Data.Vector doesnt have it but the other types do. Wondering if I should swtich away from Data.Vector
10:49:06 <mnoonan> Psybur: (I don't know enough about Vector's internals to know if this is a bad idea or not)
10:49:24 <Psybur> Nvm
10:49:28 <Psybur> I was looking at mapMaybe
10:49:55 <Psybur> Wait, it says it has it in the doc, maybe my ghci is whack
10:50:09 <mnoonan> oh, I just noticed that too :)
10:50:23 <geekosaur> check versions?
10:51:10 <ski> bsamorim : but you really then also need to see other, different, monads, like output/writer, input/environment/reader, exception/either, continuation, as well as more domain-specific ones like parsing, "input/output interaction" (`IO'), "state threads" (`ST'), "software transactional memory" (`STM'), &c.
10:51:18 <mnoonan> looks like it was added between 0.11.0.0 and 0.12.0.0
10:52:06 <Psybur> Im using 8.0.2
10:52:20 <ski> bsamorim : you need to see them, in order to fathom the *breadth* and generality of the concept (really, there's "very little there"), in order to not jump to premature conclusions
10:52:25 <kuribas> shapr: I hit the edges in about a week.
10:52:30 <kuribas> shapr: of python
10:52:56 <bsamorim> ski: PLS STAWWWPPP.....#ThingsToKnow_Buffer_Overflow
10:53:04 <cocreature> Psybur: check the version of vector, not the version of ghc
10:53:05 <ski> hehe, ok
10:53:12 <bsamorim> thanks a lot!
10:53:22 <bsamorim> I'll check them out!
10:53:28 <mniip> hmm
10:53:40 <mniip> has any single haskell course considered fully introducing monads before touching IO
10:54:05 <mniip> like
10:54:45 <mniip> to imply that IO fits in nicely as a monad
10:54:49 <mnoonan> "Today, we're going to write Hello World. The first thing you need to know is that a category is..."
10:54:58 <mniip> and to exclude the possibilty of associating monads with IO in general
10:55:13 <Psybur> > mapMaybe id $ fromList [Just 1,Nothing,Just 2]
10:55:15 <lambdabot>  [1,2]
10:55:27 <mniip> catMaybes
10:55:38 <kuribas> is there a library for generating datatypes for testing non-randomly?
10:55:45 <dfsafd> given a list like "ABCD" how would you generate a list of permutations like ["AA", "AB", "AC", "AD", "BB", "BC", ..., "DD"]?
10:55:52 <Psybur> mniip, vector doesnt have it
10:56:03 <ski> > replicateM 2 "ABCD"
10:56:03 <mniip> :t mapMaybe
10:56:04 <lambdabot> (a -> Maybe b) -> [a] -> [b]
10:56:06 <lambdabot>  ["AA","AB","AC","AD","BA","BB","BC","BD","CA","CB","CC","CD","DA","DB","DC",...
10:56:12 <mniip> Psybur, mapMaybe only takes lists as well
10:56:27 <Psybur> :t fromList [1,2]
10:56:29 <lambdabot> (Num (Item l), IsList l) => l
10:56:30 <mniip> mnoonan, a hello-world is really just a catamorphism of the F-algebra of lists lifted into the kleisli category of effectful functions
10:56:36 <mnoonan> +1
10:56:43 <ski> dfsafd : oh, you don't want reorderings repeated
10:56:49 <dfsafd> ski: i want only order-dependent permutations, so "AB" but not "BA"
10:56:59 <Psybur> > V.fromList [1,2]
10:57:01 <lambdabot>  error:
10:57:01 <lambdabot>      Not in scope: ‘V.fromList’
10:57:01 <lambdabot>      Perhaps you meant one of these:
10:57:44 <ski> > [[x,y] | ys@(x:_) <- tails "ABCD",y <- ys]  -- dfsafd
10:57:48 <lambdabot>  ["AA","AB","AC","AD","BB","BC","BD","CC","CD","DD"]
10:58:26 <dfsafd> ski: thanks!
10:58:59 <ski> you could also make a set of sets, i suppose, but why bother ?
10:59:11 <ski> dfsafd : i assume the original list has no duplicates
10:59:14 <dfsafd> i suppose that is combinations and not permutations
10:59:24 <ski> (hm, or a set of bags, rather)
10:59:51 <lap00zza> Hi. Is it okay to ask install related questions here? I am very new and am facing a weird issue with old-time
11:00:33 <c_wraith> lap00zza, sure.
11:00:38 <mniip> hmm
11:00:44 <mniip> does tails generalize to an arbitrary monad
11:01:09 <geekosaur> Foldable, I'd think
11:01:10 <mniip> Foldable comes to mind
11:01:11 <mniip> yes
11:01:26 <mniip> Fodable applicative
11:02:03 <mniip> well that's pretty much a list with extra steps
11:02:17 <ski> dfsafd : if you wanted to avoid drawing the same item multiple times, you'd use `x:ys <-' instead. and just use multiple `tails'-clauses, if you want to draw more than two .. it would be possible to encapsulate this monadically, so that one could use `replicateM' here as well, allowing the count to be dynamically computed
11:02:46 <lap00zza> Thing is I keep getting exit error 77 whenever I try to install old-time (for hoogle). I followed all the steps and even modified by config file. I filed an issue here: https://github.com/haskell/old-time/issues/8 which describes this better.
11:03:24 <mniip> @let replicateM' 0 xs = [[]]; replicateM' n xs = do (y:ys) <- tails xs; (y:) <$> replciateM' (n - 1) ys
11:03:26 <lambdabot>  .L.hs:176:18: error:
11:03:26 <lambdabot>      • Variable not in scope: replciateM' :: t -> [a] -> [[a]]
11:03:26 <lambdabot>      • Perhaps you meant one of these:
11:03:33 <mniip> @let replicateM' 0 xs = [[]]; replicateM' n xs = do (y:ys) <- tails xs; (y:) <$> replicateM' (n - 1) ys
11:03:35 <lambdabot>  Defined.
11:03:44 <mniip> > replicateM' 3 "ABCD"
11:03:47 <lambdabot>  ["ABC","ABD","ACD","BCD"]
11:04:06 <mniip> > replicateM' 2 "ABCD"
11:04:08 <lambdabot>  ["AB","AC","AD","BC","BD","CD"]
11:04:31 <mniip> @let replicateM'' 0 xs = [[]]; replicateM'' n xs = do yw@(y:_) <- tails xs; (y:) <$> replicateM'' (n - 1) yw
11:04:33 <lambdabot>  Defined.
11:04:40 <mniip> > replicateM'' 3 "ABCD"
11:04:42 <lambdabot>  ["AAA","AAB","AAC","AAD","ABB","ABC","ABD","ACC","ACD","ADD","BBB","BBC","BB...
11:05:14 <mniip> if you look to the right you will see enumeration of all monotonic functions
11:07:39 <Psybur> Is there a better way of going from one vector to another without creating an intermediary list?
11:07:57 <Psybur> Like to a different type of vector
11:08:00 <ski> > let use :: MonadPlus m => [a] -> m (a,[a]); use xs0 = (foldr (mplus . return) mzero) [(x,xs1) | xs1@(x:_) <- tails xs0] in replicateM 2 (StateT use) `evalStateT` "ABCD"  :: [String]
11:08:03 <lambdabot>  ["AA","AB","AC","AD","BB","BC","BD","CC","CD","DD"]
11:08:31 <ski> > let pick :: MonadPlus m => [a] -> m (a,[a]); pick xs0 = (foldr (mplus . return) mzero) [(x,xs1) | x:xs1 <- tails xs0] in replicateM 2 (StateT pick) `evalStateT` "ABCD"  :: [String]
11:08:33 <lambdabot>  ["AB","AC","AD","BC","BD","CD"]
11:09:33 * hackagebot brick 0.26.1 – A declarative terminal user interface library – https://hackage.haskell.org/package/brick
11:09:33 * hackagebot scalendar 1.2.0 – A library for handling calendars and resource availability over time. – https://hackage.haskell.org/package/scalendar
11:11:00 <ski> dfsafd ^
11:11:52 <ski> (the `(foldr (mplus . return) mzero)' and `MonadPlus m' parts aren't necessary here. it's just a generalization)
11:12:58 <Psybur> I see there is convert
11:17:46 <ahri> if i am writing a function of type `(a -> m a) -> a -> m (Either String a)`, and i have some nest 'do's, i.e. with the outer 'do' being a computation of the type `m (Either String a)` and the inner 'do' being a computation of the type `Either String a`, how do i intermingle calls to the function that i've passed in, when inside the nested 'do'? i guess this is a monad transformer sort of question but i'm 
11:17:52 <ahri> really not sure, and i'm not using any transformers - can i achieve this without them?
11:20:23 <ahri> when in the outer 'do' i can do, e.g. 'blah <- f db' because i'm in the 'm' 'do' but i can't us it in the 'm (Either String a)' 'do' and i don't know how to ask google about this
11:23:16 <ski> ahri : `return' ?
11:23:39 <kuribas> ahri: use let inside a do?
11:25:40 <mnoonan> ahri, does this help?
11:25:44 <mnoonan> > \f -> Right . f
11:25:46 <lambdabot>  error:
11:25:46 <lambdabot>      • No instance for (Typeable a0)
11:25:46 <lambdabot>          arising from a use of ‘show_M180565928824661394031968’
11:25:51 <mnoonan> :t \f -> Right . f
11:25:53 <lambdabot> (a1 -> b) -> a1 -> Either a2 b
11:26:06 <mnoonan> hm, no wait.. :)
11:26:25 <mnoonan> :t \f -> Right <$> f
11:26:26 <lambdabot> Functor f => f b -> f (Either a b)
11:27:42 * hackagebot storable-tuple 0.0.3.3 – Storable instance for pairs and triples – https://hackage.haskell.org/package/storable-tuple
11:27:57 <mnoonan> :t \f -> fmap Right . f
11:27:58 <lambdabot> Functor f => (a1 -> f b) -> a1 -> f (Either a2 b)
11:28:02 <mnoonan> there we go
11:29:24 <ahri> mnoonan: hmm, let me stare at it for a while :)
11:29:38 <kuribas> ahri: your question is rather vague.  You should give a concrete example
11:30:26 <ahri> kuribas: ok, i was trying to isolate it. i'll gist some code
11:31:06 <dmwit> ahri: I strongly suspect you want ExceptT or similar.
11:31:10 <dmwit> ?unmtl ExceptT e m a
11:31:10 <lambdabot> ExceptT e m a
11:31:16 <dmwit> ?unmtl ErrorT e m a
11:31:16 <lambdabot> m (Either e a)
11:31:25 <dmwit> (ExceptT is similar, but with slightly modified instances.)
11:31:48 <dmwit> ahri: Then you would just use normal do syntax and binding and friends; no nested do's necessary.
11:32:56 <dmwit> ahri: See also https://stackoverflow.com/q/33705941/791604
11:33:01 <int-e> @unmtl ReaderT r (WriterT w (StateT s m)) a
11:33:01 <lambdabot> r -> s -> m (a, w, s)
11:33:04 <dmwit> "How can I work in nested monads cleanly?"
11:33:09 <int-e> (the triple is a lie!)
11:34:01 <dmwit> ahri: https://stackoverflow.com/q/28857745/791604 ("How to remove `case of` from this code?") may also be relevant.
11:35:07 <Psybur> Anybody have a general idea of what improvement I can make if most of my app's time is spent in: >>=                      Data.Vector.Fusion.Util           Data/Vector/Fusion/Util.hs:36:3-18
11:36:14 <dmwit> THERE IS AS YET INSUFFICIENT DATA FOR A MEANINGFUL ANSWER
11:36:32 <ahri> kuribas (and anyone else interested!) - https://gist.github.com/ahri/70a7a04ea689914485e83361e0827e88 - this is the actual code, hopefully with enough types to make sense
11:36:37 * ystael waits 850 million years
11:36:45 <Psybur> :D
11:36:50 * mniip proves by demonstration
11:38:05 <ahri> dmwit: ErrorT does look like it would be a useful way to address the problem, i'll read those links
11:39:54 <crucify_me> https://ptpb.pw/7YOA hi on this program I think I'm confusing something with scheme. first if I may, the composition on line 4 would make this linear combination right?
11:40:25 <crucify_me> sorry I mean linear recursion
11:40:29 <ahri> dmwit: heh, the first link is pretty much the problem i'm having
11:41:21 <ski> ahri : please actually use `ExceptT', not `ErrorT', if you want to use one of them
11:41:32 <dmwit> crucify_me: Sure. Dunno why "linear recursion" is an interesting concept or what you plan to do with that fact, but the definition of it appears to fit this situation well enough.
11:41:57 <crucify_me> its a book example dmwit thanks
11:44:01 <crucify_me> I'm not used to seeing f in the expression twice
11:44:24 <ahri> ski: i was considering asking what the difference is, but also scared that someone might answer. i'm not very familiar at all with monad transformers you see
11:44:43 <crucify_me> because in linear recursion in scheme you'd just have the function itself immediately on the rhs
11:44:49 <dmwit> crucify_me: Go on, you've never seen something like `f x = 2*x^2 + 3*x + 1`? Repeating arguments is very normal.
11:45:07 <dmwit> crucify_me: But `f` isn't the recursive bit. `applyTimes` is.
11:45:35 <crucify_me> yeah thanks hold on dmwit .
11:46:24 <mnoonan> are you thinking of tail calls? your description sort of sounded like it, maybe.
11:47:47 <crucify_me> I think what I mean is that in scheme you don't explicitly have the function twice. with the composition, it's like you can visualize the stack.
11:49:06 <ski> ahri : `ErrorT' is an earlier attempt to do basically the same thing as `ExceptT'. however, it has an annoying extra restriction on instances (requiring the "exception type" to include a string-message option. this is not nice if you e.g. want to use `Integer' as the exception type). `ExceptT' is a replacement, without this annoyance
11:49:22 <n_blownapart> test
11:50:39 <n_blownapart> you seeing this dmwit ? I was disconnected
11:52:28 <n_blownapart> << crucify_me
11:54:05 <crucify_me> anyone ping me please ?
11:54:59 <HaskellLord69> anyone?
11:55:36 <crucify_me> thanks
11:57:37 <Ero> hi team. I'm really struggling with stack. For some reason any connection it tries to make to 'do the templates' times out. Does stack use Curl?
12:03:20 <cocreature> Ero: afaik it doesn’t use curl, it uses http-client which is a pure Haskell implementation. maybe try running "stack templates --verbose" to get a better idea what’s causing problems?
12:27:12 <heath> i recall seeing a site which demonstrated the evaluation of a haskell program and its visualizations were similar to the figures on this page: https://hackhands.com/lazy-evaluation-works-haskell/
12:27:20 <heath> anyone recall such a site?
12:28:32 <rotaerk> heath, this?  http://www.vex.net/~trebla/haskell/lazy.xhtml
12:29:42 <heath> also neat, but not what i had in mind
12:31:07 <shapr> I know Cale used to use something to produce graphics that showed foldl and foldr reduction trees.
12:31:19 <shapr> but I forget the name
12:31:26 <Ero> thanks cocreature i'll try that
12:31:55 <cocreature> heath: looks somewhat similar to the output you get from ghc-vis
12:32:04 <Ero> what i can tell so far is any stack command that requires a network connection spits out a 'connectiontimeout' error 
12:32:21 <Ero> this is making me really sad lol
12:32:36 <hexagoxel> Ero: quoting myself ~2h ago: "<hexagoxel> does hackage.fpcomplete.com work properly? my cabal update timeouts."
12:33:59 <shapr> stack update works for me
12:34:39 <hexagoxel> (of course hackage still works so i don't mind too much - i just disabled the mirror)
12:34:57 <heath> cocreature: ah, that's it!
12:35:41 <Ero> interesting
12:41:36 <Ero> ok thats weird stack update is working for me also
12:41:44 <shapr> heisenbug
12:41:56 <Ero> but stack templates or stack new hangs
12:53:09 * hackagebot producer 0.1.0.0 – Simple streaming datatype – https://hackage.haskell.org/package/producer
13:06:51 <haskelll> Why doesn't network-transport's library EndPointAddress datatype have an Generic instance?
13:10:39 <haskelll> Or how to define Generic instance for EndPointAddress
13:12:33 <erisco> XStandaloneDeriving  and  instance Generic EndPointAddress  is my best guess
13:12:56 <erisco> deriving instance Generic EndPointAddress   maybe... can't remember the syntax
13:21:12 <haskelll> Tnx. What is required for automatic derivation of ToJSON/FromJSON? Isn't Show and Generic enough? NodeId datatype (from distributed-process) has both and when trying to derive ToJSON/FromJSON it says EndPointAddress doesn't have ToJSON/FromJSON instance. ?
13:21:46 <haskelll> erisco:
13:22:17 <erisco> I don't know about those functions
13:23:06 <geekosaur> haskelll, you still have to derive it, same syntax as for Generic
13:23:31 <Psybur> Whats a good way to convert ByteString -> Double? It seems bytestring-read is too old D:
13:24:47 <haskelll> geekosaur: So to have an ToJSON instance your datatype needs to derive Show, Generic, and all data fields needs to have an ToJSON instance?
13:25:21 <geekosaur> or you need to derive it for those fields, yes
13:26:38 <lyxia> Psybur: binary
13:26:57 <geekosaur> but I think you will find you can't do ToJSON or FromJSON for EndPointAddress, because it wraps a ByteString and there is no single representation for that in JSON
13:27:45 <geekosaur> and Haskell is not a 'just make it happen ok I don;t care how' language
13:31:06 <EvanR> why the hell not!
13:31:07 <jle`> Psybur: what do you want that function to do?
13:31:41 <Psybur> jle`, convert a bytestring to a double. Looking into the binary package that lyxia mentioned
13:31:52 <jle`> Psybur: what conversion do you want?
13:32:06 <Psybur> jle`, ByteString -> Double
13:32:09 <jle`> like, is it ASCII representing a string representation of a double?
13:32:19 <jle`> "4.53" ?
13:32:23 <Psybur> Yes
13:32:28 <jle`> ah
13:32:32 <jle`> the 'binary' package doesn't do that
13:32:47 <jle`> it converts the binary represenation of a Double into the Double it represents
13:32:56 <Psybur> should have figured D:
13:33:02 <jle`> that's what people usually think when you say "convert a bytstring to a double"
13:33:11 <jle`> which is why i was suspicious of your original question
13:33:32 <jle`> you don't want to convert a bytestring into a double...you want to parse text as a double
13:34:12 <geekosaur> ^ and this is a  good example of why 'just make it happen ok' is a bad idea...
13:34:13 <jle`> for that you can just do the typical (read . T.unpack . T.decodeUtf8)
13:34:55 <Psybur> So if Im reading a text file, I dont get any benefit using Data.ByteString.Char8?
13:35:07 <jle`> or you can interpret as json, and use aeson's decode :: ByteString -> Maybe Double
13:35:15 <jle`> Data.ByteString.Char8 is kinda super deprecated
13:35:52 <erisco> a little extremely deprecated
13:36:33 <jle`> there is no good reason to ever use Data.ByteString.Char8 in practice. if you're lucky it'll cause you a little harm and if you're unlucky it'll cause you great harm
13:36:58 <EvanR> this is haskell, we hate convenience
13:37:18 <Psybur> I know that I wont have any problems with unicode
13:37:19 <EvanR> at the cost of sanity, reliability
13:37:37 <EvanR> or the dreaded, feature we said we would never need, then it was needed
13:37:59 <jle`> Psybur: even if you think it won't hurt you, it definitely won't help you
13:38:17 <jle`> you're listing reasons why you think it's not bad, but there isn't any reason why it's good in the first place :)
13:39:10 <Psybur> That it was supposed to be faster than Data.Text :D
13:39:31 <EvanR> i think what were talking about is an ascii text type that is backed by bytestring
13:40:09 <fbauckho> Hey everybody! Is this the right place to ask "my haskell package management doesn't work" type questions?
13:40:31 <jle`> maybe, just ask and we'll find out :)
13:40:46 <haskelll> fbauckho: Yes
13:42:03 <fbauckho> so I'm trying to compile my xmonad config, and one of the various errors is "Could not find module XMonad; There are files missing in the xmonad-0.13 package; try running 'ghc-pkg check'"
13:42:16 <ahri> dmwit, ski: it's taken me a little while to get my head around it, but i've ended up with this code that does compile: https://gist.github.com/ahri/dbaed3014082df9af926c75fbda02a5d - but now i ave a case statement to deal with the Maybe; can i avoid this, or is it as neat as it gets?
13:42:23 <fbauckho> when I run ghc-pkg check I get a bunch of warnings about haddock
13:42:51 <ahri> (i'm asking just because if i'm using ExceptT i may as well make it succinct!)
13:43:21 <fbauckho> (more specifically, "Warning: haddock-html: /user/share/doc/something doen't exist or isn't a file" for several values of something)
13:43:25 <geekosaur> fbauckho, that just means you don;t have local docs generated or installed. it's not an error
13:44:35 <geekosaur> and since the default for local building isn't to include documentation and most distribution packages also don't include it, that makes the warning mostly noise and I really wish it were disabled by default
13:45:02 <fbauckho> geekosaur ohh ok. But then, how do I find out what is wrong with my xmonad-0.13 package?
13:45:15 <jle`> ahri: i left a potential edit as a gist comment
13:45:23 <geekosaur> ignore the warnings and look for anything else.
13:45:40 <geekosaur> but if this is arch the answer is "arch can't figure out how to build valid haskell packages any more"
13:45:59 <geekosaur> they have been messing this up, not just for xmonad, since June
13:46:10 <fbauckho> geekosaur ohhh no, yes, I have arch :(
13:46:14 <fbauckho> am I doomed?
13:48:00 * vktec suggests installing xmonad through cabal instead
13:48:13 <ski> ahri : i suppose you could use `Item cps ccs cnd cmtd <- maybe (throwError . IdDoesNotExist $ ci) pure =<< getItem ci db'
13:48:17 <geekosaur> install ghc, ghc-static, and cabal and nothing else from arch packages. install everything else via cabal. (stack is also possible but getting xmonad to work with stack is still a fair amount of work; it's hard to reliably get the thing that owns your session into a sandbox without that sandbox infecting everything else)
13:48:38 <fbauckho> vktec cabal says it's installed already, should I reinstall?
13:48:49 <vktec> Uninstall the pacman package
13:49:07 <ski> @type \o -> maybe o pure
13:49:09 <lambdabot> Applicative f => f a -> Maybe a -> f a
13:49:10 <ski> @. hoogle type \o -> maybe o pure
13:49:12 <ahri> jle`, ski: thanks, i didn't realise i could still use `maybe' in this case... hmm
13:49:13 <lambdabot> Control.FromSum fromMaybeM :: Applicative m => m a -> Maybe a -> m a
13:49:13 <lambdabot> Control.FromSum fromMaybeOrM :: Applicative m => Maybe a -> m a -> m a
13:49:13 <lambdabot> Prelude (*>) :: Applicative f => f a -> f b -> f b
13:49:39 <jle`> ski: it's something i've always wanted when dealing with MaybeT as well
13:49:41 <fbauckho> vktec, do you mean uninstall a cabal package called pacman, or pacman itself? O_o
13:49:55 <ski> ahri : looks like `fromMaybeM' there is for this use of `maybe'. not sure what package that's in, though
13:49:58 <geekosaur> neither. vktec meant what I said
13:50:10 <ski> jle` : `fromMaybeM' ?
13:50:16 <jle`> 'maybe o pure'
13:50:21 * ski nods
13:50:28 <jle`> because then you have an easy Maybe a -> MaybeT m a
13:50:49 <vktec> fbauckho: Uninstall the xmonad package you installed using pacman
13:51:25 <fbauckho> vktec, ok, thanks, I'll try that!
13:53:56 <yushyin> fbauckho: https://wiki.archlinux.org/index.php/Haskell#Problems_with_linking 
13:53:56 <fbauckho> I did "pacman -R xmonad" and then "cabal install xmonad", but cabal still says xmonad is installed already
13:55:35 <vktec> Reinstall then
13:56:22 <fbauckho> vktec thanks!
13:57:09 <ski> @type fromMaybe
13:57:11 <lambdabot> a -> Maybe a -> a
13:57:16 <ski> @src fromMaybe
13:57:16 <lambdabot> fromMaybe d Nothing  = d
13:57:16 <lambdabot> fromMaybe _ (Just v) = v
13:57:26 <fbauckho> Now when compiling it says there are files missing in mtl, data-default, x11, and probably a bunch of other things. If those came from bad pacman packages, how do I find out what pacman packages to remove?
13:57:33 <ski>   fromMaybe d = maybe d id
14:02:26 <fbauckho> vktec more specifically the list of broken packages is extensible-exceptions, mtl, data-default, and x11. It looks like at least mtl might not be pacman's fault since the "mtl" pacman package isn't installed. I feel wary about force-reinstalling them since they probably have hundreds of packages depending on them. What's your advice for that kind of thing?
14:03:26 * hackagebot texmath 0.9.4.3 – Conversion between formats used to represent mathematics. – https://hackage.haskell.org/package/texmath
14:03:54 <vktec> fbauckho: If they're broken, reinstall them
14:07:49 <fbauckho> vktec they depend on other broken packages, which I'm currently adding to my list of reinstalls manually. Is there an automatic way to do that?
14:08:10 <vktec> I'm not sure
14:08:25 <vktec> Been a while since I used Arch
14:09:14 <Ero> is there a way i can test if the http-client stack is built with is broken or if stacks usage of it is broken?
14:10:41 <jakehehrlich> So refinement type systems like LiquidHaskell only pass type checking if they can prove correctness. In LiquidHaskell a decidable theory is used to make this possible but the theory is limiting. In stronger systems undecidability is a problem. Has anyone looked at implementing a "passes if can't be proven wrong" refinement type system?
14:11:11 <jakehehrlich> That is type checking passes if the compiler can't find a counter example for a given subtype relationship
14:11:15 <fbauckho> vtec Thanks a lot for your help! The tree of broken packages seems to be branching less than I expected, so it's pretty OK
14:11:31 <vktec> Glad to hear :)
14:11:43 <yushyin> fbauckho: just installed xmonad on arch, changed 3 settings as mentioned in the archwiki article which I linked, run xmonad --recompile, works.
14:12:01 <vktec> Hope you get it sorted out eventually. Bug those Arch devs about it!
14:15:34 <Denommus> I can't compile terminfo :-/
14:16:14 <Denommus> stack build gives me this: https://gist.github.com/Denommus/7f0801dc46c8fd7503eb83a8f8097f11
14:16:17 <glguy> Denommus: That's probably OK, it comes with GHC
14:16:50 <Denommus> glguy: what I'm trying to do is to install intero, and intero tries to compile terminfo
14:17:27 <glguy> Denommus: Ah, if you're trying to get emacs working well with Haskell, there's https://github.com/jyp/dante
14:17:53 <glguy> intero is mentioned at the bottom
14:18:59 <Denommus> glguy: gosh, the haskell autocompletion facilities are very fragmented, un
14:19:00 <Denommus> *uh
14:19:06 <Denommus> but okay, I'll try it
14:20:55 <fbauckho> yushyn, thanks for the pointer!
14:21:08 <fbauckho> vtec I managed to reinstall all of them! \o/
14:21:55 <fbauckho> Now I'm able to get back to my original problem, which is that I put files for my xmonad config into a cabal package that fails to install
14:22:58 <fbauckho> so firstly when I run cabal install without root, it complains about not being able to do something with dist/package.conf.inplace/package.cache.lock, is that normal?
14:24:12 <fbauckho> Secondly when I use root the error message is "cannot satisf -package-id xmonad-contrib-0.13-<something>: xmonad-contrib-0.13-something is unusable due to shadowed dependencies: xmonad-0.13-something
14:24:16 <fbauckho> "
14:24:59 <OtterCoder> Hi! I'm having odd compliation troubles. The package typed-wire-utils has conditional compilation, but it's triggering wrong via stack.
14:26:09 <Denommus> yeah, dante seems to work
14:26:12 <Denommus> thanks
14:26:30 <OtterCoder> Specifially, there's an ifdef that checks for aeson < 0.11.0, and I've got aeson 1.1.2 pulled in, but the ifdef still triggers.
14:27:39 <lyxia> OtterCoder: is aeson-1.1.2 in your stack.yaml?
14:27:53 <inkbottle> [noob] there is nothing like: import Data.Text as DT in DT.pack "xx"? That is the "in" part.
14:28:28 <OtterCoder> lyxia: No, it's in my .cabal, without a qualifier. I should try to write it in then?
14:28:37 <lyxia> OtterCoder: what resolver are you using?
14:28:55 <OtterCoder> lyxia: lts-9.6
14:29:58 <lyxia> OtterCoder: where is the ifdef
14:30:22 <OtterCoder> https://github.com/typed-wire/hs-typed-wire-utils/blob/master/src/Text/TypedWire.hs
14:30:34 <OtterCoder> lyxia: Line 44
14:30:47 <lambdamu_> Does anyone know why this function can only accumulate Char? https://hackage.haskell.org/package/text-1.2.2.2/docs/Data-Text.html#v:foldl1
14:30:59 <lambdamu_> Seems pretty odd to me
14:31:37 <geekosaur> fbauckho, (1) sounds as if you did something as root when you shouldn;t have, and now have files and/or dirs owned by root that ought to be owned by you
14:31:50 <mauke> lambdamu_: what else could it do?
14:31:59 <geekosaur> (2) using root eith cabal-install is almost never correct
14:32:04 <geekosaur> *with
14:32:07 <fbauckho> geekosaur, ohhh that makes sense, thanks!
14:33:35 <geekosaur> (3) likely root's ghc package db now has a cabal-installed xmonad-contrib in it that is the same version as one installed globally by pacman, but with different abi hash; ghc is prone to pick the wrong one in those situations, so you'r ebeing warned that it's a known screw case
14:33:46 <geekosaur> (new-build can handle this case but introduces other complexities)
14:33:47 <lambdamu_> mauke: Ah never mind
14:34:41 <geekosaur> (note that cabal-instal run as root does not install globally, it installs to root's own private package db that won't be visible to others)
14:35:09 <OtterCoder> lyxia: I updated the .cabal to require a version greater than 0.12, and it's still no good.
14:35:51 <texasmynsted> https://www.ias.edu/news/2017/vladimir-voevodsky
14:38:20 <ashylarry> hey guys, anybody here familiar with Servant?
14:39:15 <fbauckho> geekosaur I got rid of the dist directory, and now the install worked! Thanks a lot! \_O_/
14:39:35 <lyxia> OtterCoder: how odd.
14:40:03 <sinsnare> Hey, I have code like this http://lpaste.net/358931 Where I get a tuple from a function call, and i want to use them in that order as arguments, is there any cleaner way to do this?
14:40:17 <sinsnare> i saw 'uncurry' but it seemed like it only takes 2 arguments, could i make uncurry work for a 3 argument function?
14:40:20 <hexagoxel> inkbottle: you mean smaller-scoped imports? no, that does not exist.
14:40:40 <inkbottle> hexagoxel: OK, thanks
14:40:57 <geekosaur> sinsnare, no, you'd have to write your own uncurry3 or something
14:41:08 <sinsnare> geekosaur: great, just wanted to make sure. thanks :)
14:41:12 <OtterCoder> lyxia: Hang on. It may be a bug. There's another if statement that's supposed to be mutually exclusive, but it's actually concurrent.
14:41:33 <ashylarry> Trying to use QueryParam to input "BTC-LTC" in my request, https://pastebin.com/UDUCASyB
14:41:40 <ashylarry> not sure how to do that
14:41:42 <OtterCoder> lyxia:  Thanks for the help!
14:41:53 <fbauckho> I have my window manager back now! Thanks a lot vktec yushyin geekosaur!
14:42:21 <ahri> i'm still struggling with this mtl stuff. i just don't seem to have a handle on it :\ can't get it compiling: https://gist.github.com/ahri/35706de1f6765478996fa5f837395b83
14:43:42 <vktec> fbauckho: Yay!
14:43:47 <lyxia> OtterCoder: the version on hackage doesn't have the check http://hackage.haskell.org/package/typed-wire-utils-0.1.0.0/src/src/Text/TypedWire.hs
14:43:58 <ahri> i actually don't even understand the error message in that link above
14:44:59 <ashylarry> Trying to use Servant's QueryParam to input "BTC-LTC" in my request, https://pastebin.com/UDUCASyB not sure how to do that
14:46:19 <geekosaur> ahri, seems to me getRoot only promises to be 'm a' but you require it to be 'ExceptT Error m a'
14:46:19 <OtterCoder> lyxia: Oh, interesting. Either way, I'll have to bug the maintainer.
14:46:41 <geekosaur> oh wait, your quote claims line 5 but the error message cites line 6 by its content
14:46:54 <ahri> geekosaur: yeah, i have the vague feeling that i should be lifting it
14:47:00 <geekosaur> specifically writeItem
14:47:47 <ahri> geekosaur: i've edited it to add types; it's now line 11 when i execute stack build
14:47:59 <geekosaur> and yes, it is likely you need to lift it somehow --- but then the question arisis, did you think just running an m a inside an ExceptT Error m a would automatically cause the m a to suddenlow how to handle exceptions?
14:48:13 <geekosaur> *suddenly know how
14:48:48 <ahri> not really; i was trying to follow the advice i got here to see where it got me, and whether i could understand what was happening
14:50:33 <geekosaur> I suspect you can get it to typecheck just by wrapping the wriiteItem invocation in `return` ... but that means (a) you wanted to use let in stead of <- (b) it won't actually handle exceptions, it will wrap a success as if it had but will throw if an exception happened, not using ExceptT
14:50:56 <ahri> it does seem to be making the code more readable, but i've spent hours chasing my tail without it compiling, just fixing each error as it arises :) i have a limited knowledge about MTL and some small recollection that lifting allows access to different levels of a stack of monads
14:52:13 <ahri> right now this code is acting on an in-memory db, which is just a hashmap so no real IO is going on. the point of refactoring it like this is to allow me to use both this implementation and also an actual DB, which will require IO and could well throw
14:53:15 <ahri> so i'd prefer not to miss out on the benefits just to get it typechecking, but i also don't really know what you mean when you say it won't actually handle exceptions
14:53:59 <ahri> (my understanding of exception handling in haskell is extremely limited, and likely tainted by my knowledge of java/c#/etc.)
14:54:05 <geekosaur> ahri, so you will need to look at Control.Exception.try, since ExceptT doesn't come with anything that will automatically wrap and catch exceptions
14:54:47 <geekosaur> and even then, things can start to become 'interesting' when it comes to nested monads that do exception handling and external resources like database connections
14:55:18 <geekosaur> https://www.schoolofhaskell.com/user/commercial/content/exceptions-best-practices worth a read if you need to deal with exceptions
14:57:00 <Denommus> gosh
14:57:16 <koz_> Could someone suggest a bidirectional map library for Haskell?
14:57:28 <lyxia> bimap
14:57:34 <Denommus> the new Arch Linux setup for Haskell is really hard to deal with
14:58:39 <lyxia> Indeed. Hopefully we have cabal and stack.
14:58:49 <MP2E> definitely seems like it. I wonder why they changed to use -dynamic
14:59:20 <koz_> lyxia: Thank you!
14:59:44 <geekosaur> my guess is they heard that we'd fixed the non-reproducible builds issue for nix and thought that would make shared objects a win. (it doesn't)
15:00:34 <geekosaur> the real reason a distro wants shared libs is so minor changes can be slotted in without rebuildng dependents. ghc's habit of exposing guts for cross-module inlining makes that ... difficult at best
15:01:03 <geekosaur> your exposed ABI is much larger than your exposed API
15:01:24 <geekosaur> and has much tighter version constraints as a result
15:01:28 <ristos> Denommus what's the new haskell setup for arch?
15:01:54 <Denommus> ristos: they use -dynamic for everything
15:02:13 <Denommus> I'm finding myself to be completely unable to setup a new project, either with cabal sandbox or stack, that uses MFlow
15:02:19 <ristos> for community or arch haskell?
15:02:23 <hexagoxel> `ghc HelloWorld.hs` will error without -dynamic :D
15:02:40 <geekosaur> and since not exposing those innards results in slowdowns between 2x and 90x (!) it's kinda a bad idea to disable that
15:04:36 <Denommus> I made a simple `stack new <projectname>`
15:04:51 <Denommus> then I added MFlow to build-depends
15:05:28 <Denommus> and I'm getting this error: https://gist.github.com/Denommus/7096b9ae7f97fec0d38da462e7dc110f
15:06:02 <ristos> Denommus I think arch haskell should work ok, that's what I'm using
15:06:02 <ristos> I've had issues with the community packages in the past
15:07:01 <inkbottle> [noob] GHCI complains when I try to load a file containing only that line: rvs = foldl (flip (:)) []
15:07:16 <geekosaur> it's been mentioned before that having libtinfo installed causes stack to pick the wrong ghc to install on arch
15:07:22 <inkbottle> its ok if I just type le line in ghci (w. let)
15:07:37 <Denommus> ristos: ok, this might have nothing to do with Arch, but do you have any idea why it could be happening?
15:07:46 <geekosaur> (possibly it's assuming what works for debian will work everywhere?)
15:08:31 <geekosaur> inkbottle, it works in ghci because ghci has extended defaulting enabled
15:08:41 <ristos> not sure in your particular case, but I've ran into issues with builds failing if I have a mix of stack, or community or arch haskell together
15:09:01 <ristos> I pretty much just switched to use arch haskell altogether and nothing failed after that
15:09:30 <ristos> I think stack would still work ok for a local project but I'm scared to try it :/
15:09:31 <geekosaur> in a compiled program (even if it's compiled by ghci), extended defaulting is disabled, and it doesn't know what kind of Foldable to use. it would work if you had a parameter, but as it is the monomorphism restriction is forciing it to pick a type and it can't
15:10:04 <ristos> if stack was a package manager then it would be an easy solution, like npm
15:10:06 <ristos> but it isnt
15:10:58 <geekosaur> (ghci also disables the monomorphism restriction)
15:11:10 <inkbottle> geekosaur: OK, (https://kseo.github.io/posts/2017-01-04-type-defaulting-in-haskell.html)
15:11:13 <inkbottle> Ok again
15:11:39 <Denommus> perhaps it's MFlow that's broken
15:11:41 <geekosaur> it would also work with an explicit signature telling it to be polymorphic, since that overrides the MR
15:13:10 <inkbottle> geekosaur: like it doesn't want to be polymorphic?
15:13:27 <geekosaur> look up the monomorphism restriction
15:13:33 <geekosaur> if you have something like: foo = ...
15:13:38 <geekosaur> without any parameters
15:14:22 <geekosaur> generally you do this in order to get sharing/'memoization' across multiple uses. but if it is polymorphic, it will do this independently for every type it is used at, which leads to potentially wasted memory and confusion
15:14:23 <inkbottle> geekosaur: Quite polymorphic indeed
15:14:30 <geekosaur> so the MR says 'force a single type for this'
15:14:40 <geekosaur> in this case, that fails because it can;t pick a Foldable intance for you
15:14:57 <geekosaur> ghci, even with MR enabled, has a defaulting rule to use lists in that case
15:15:05 <inkbottle> OK
15:15:21 <inkbottle> that's why it worked
15:15:35 <inkbottle> reading this: https://wiki.haskell.org/Monomorphism_restriction
15:15:36 <geekosaur> ...but MR is disabled by default so it never even gets that far, it just accepts it as is
15:16:11 <geekosaur> (because when working at the prompt, you usually don't care about sharing; that's mostly useful for larger programs)
15:16:55 <c_wraith> you can enable the ghci rules when compiling non-interactively, by the way. I've done that for one project, where it was a massive improvement in one module that used a *lot* of polymorphic values with polymorphic consumers.
15:17:17 <c_wraith> but it's uncommon to be in that situation
15:17:46 <geekosaur> you can turn on the ExtendedDefaultRules extension to get ghci's behavior while keeping the MR or also add the NoMonomorphismRestriction extension to get ghci's full behavior. you may see memory leaks or surprising types with that
15:18:28 <geekosaur> (or really *weird* type errors because you gave the compiler license to do things it normally wouldn't allow and then got stuck in a corner)
15:19:35 <GH-PH-Student> I dont understand how u can use an empty list accumulator inside a foldr, i.e: takeWhile' p xs = foldr (\x n -> if p x then x:n else []) [] xs
15:20:03 <cerebral_monkey> Haskell noob here. I just learned if can be implemented like "let if :: Bool -> a -> a -> a ; if True x _ = x ; if False _ y = y" with pattern matching. I'm curious, would it be possible to implement it without pattern matching?
15:20:16 <glguy> GH-PH-Student: foldr doesn't have an "accumulator", thinking of it as having one can lead to that kind of confusion
15:21:46 <GH-PH-Student> glguy, what do you mean? takeWhile' [2,4,1] shouldnt be 2:4:[]:[]? aka 2:(4:([]:...))?
15:21:56 <c_wraith> glguy, I think I disagree with that. but it's a weird accumulator. maybe we need a new word for "this would be an accumulator in a strict language but is a lot fuzzier here"
15:22:26 <vktec> cerebral_monkey: You could do it with case, but that's still pattern matching just in a different place, or you could do it with guards
15:22:39 <glguy> OK, you can call it "weird accumulator" so that people know it's like what they expect when they think "accumulator"
15:22:47 <GH-PH-Student> c_wraith, glguy, \n the accumulator as a function that gets applied to v?
15:22:59 <GH-PH-Student> (really sorry for my bad english)
15:22:59 <cerebral_monkey> vktec: Yeah. wracking my brain if there was a way to do so without anything like that
15:23:17 <vktec> Something like 'if b x y | b = x; otherwise = y' if you wanted to use guards
15:23:31 <c_wraith> GH-PH-Student, you can think of it as accumulating a potential future. that won't help, though.
15:23:57 <glguy> GH-PH-Student: assuming you meant takeWhile' even [2,4,1] -- then the [] just before xs isn't being used in the result
15:24:13 <vktec> cerebral_monkey: You can't do it without doing *some* form of pattern matching though
15:24:21 <GH-PH-Student> How so glguy?
15:24:24 <cerebral_monkey> vktec: Hrm, ok. Thanks. I was just curious.
15:24:26 <glguy> > let takeWhile' p xs = foldr (\x n -> if p x then x:n else []) undefined xs in takeWhile' even [2,4,1]
15:24:29 <lambdabot>  [2,4]
15:25:52 <Denommus> maybe I should begin to try to use Nix as package manager
15:26:17 <GH-PH-Student> glguy, i dont get it. shouldnt the undefined be inside the foldr then?
15:26:30 <GH-PH-Student> Why isnt it used?
15:27:05 <c_wraith> because the input list has an odd number before it ends.
15:27:14 <glguy> takeWhile' even [2,4,1] ===> if p 2 then 2 : takeWhile' even [4,1] else []
15:27:41 <glguy>  takeWhile' even [4,1] ==> if p 4 then 4 : takeWhile' [1] else []
15:28:07 <glguy> and, takeWhile' even [1] ==> if even 1 then 1 : takeWhile' [] else [] ==> []
15:29:03 <glguy> To get the undefined to show up you'd need to evaluate  takeWhile' applied to an empty list: takeWhile' even [] ==> foldr (\x n -> if p x then x:n else []) undefined xs ==> undefined
15:30:39 <dmwit> ahri: Did you get an answer?
15:31:17 <GH-PH-Student> How so glguy? If i do: foldr (\x n -> x+n) v [1,2,3] i get different values, depending on v
15:31:25 <dmwit> ahri: Anyway I would write a short function `liftMaybe :: MonadError e m => e -> Maybe a -> m a` (this may even exist somewhere in an existing library). Then you can just use bind as usual instead of a `case`.
15:31:39 <GH-PH-Student> aka, v=0: 6, v=10: 16.Isnt v used anyway?
15:32:00 <glguy> GH-PH-Student: That's a different use of foldr, it unconditionally used the 'n' in the function that foldr was applied to
15:32:50 <c_wraith> GH-PH-Student, your example always uses n. glguy's example only uses it if the input matches a predicate
15:33:05 <glguy> but in the case of evaluating something like ``if True then x else y`` y will not be evaluated
15:33:51 <GH-PH-Student> Hm... Im starting to get it.
15:34:14 <glguy> GH-PH-Student: foldr processes the list from the beginning to the end, left to right.
15:34:18 <glguy> > foldr f z [a,b,c]
15:34:21 <lambdabot>  f a (f b (f c z))
15:34:40 <glguy> It's up to 'f' above to evaluate or not its second argument
15:34:52 <dmwit> cerebral_monkey: Haskell has a few built-in consumers of `Bool`, including guards, the built-in `if/then/else`, pattern-matching, and list comprehensions. And of course the standard library has several `Bool` consumers (which are implemented with pattern matching).
15:35:24 <GH-PH-Student> I got it!!
15:35:28 <dmwit> > let if' b x y = head ([x|b] ++ [y]) in (if' True "a" "b", if' False "a" "b")
15:35:30 <lambdabot>  ("a","b")
15:35:49 <GH-PH-Student> Thank you very much, glguy and c_wraith!!! :)
15:35:55 <cerebral_monkey> dmwit: Thanks, but I found specifically what I was looking for here: https://en.wikipedia.org/wiki/Conditional_(computer_programming)#Lambda_Calculus
15:36:21 <dmwit> Oh, well, if you don't mind choosing another data representation that opens things up considerably, yes.
15:37:23 <dmwit> > let if' b x y = [y,x] !! fromEnum b in (if' True "a" "b", if' False "a" "b")
15:37:26 <lambdabot>  ("a","b")
15:38:31 <dmwit> I guess `unsafeCoerce` is sort of a consumer that isn't implemented with pattern matching.
15:38:53 <GH-PH-Student> Just one more thing... After the future accumulator is made [] foldr stops iterating over the input list (xs)?
15:39:39 <GH-PH-Student> The default is never used, but nevertheless theres still the else clause with an empty list [].
15:41:17 <dmwit> % let if' b x y = head (zipWith const [x] (unsafeCoerce b) ++ [y]) in (if' True "a" "b", if' False "a" "b")
15:41:17 <yahb> dmwit: ("a","b")
15:48:03 <Denommus> I did it!
15:48:07 <Denommus> libtinfo was the culprit, somehow
15:49:30 <geekosaur> as I said earlier, somehow its presence causes stack to grab the wrong ghc or think the installed one is different
15:49:51 <geekosaur> if it's not there, stack does the right thing
16:00:25 <GH-PH-Student> Why can takeWhile' be expressed in terms of foldr (foldr (\x n -> if p x then x:n else []) [] xs) but not in terms of foldr1 (ghci gives me an error)?
16:01:04 <Denommus> GH-PH-Student: because foldr1 doesn't handle the empty list case
16:01:15 <fishythefish>  foldr1 has a different signature, but there's also the issue that you'd presumably want to be able to call takeWhile' on []
16:04:14 <GH-PH-Student> Denommus, yes, but what if i just want to call it on non-empty lists? like takeWhile' [2,4,1] (using foldr1)?
16:04:55 <fishythefish> :t foldr1
16:04:57 <lambdabot> Foldable t => (a -> a -> a) -> t a -> a
16:05:15 <fishythefish> Note the type of the combining function
16:05:38 <GH-PH-Student> :t foldr
16:05:40 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
16:05:55 <fishythefish> Intuitively, foldr1 allows you to skip specifying the initial accumulator because it can just start at the first value of your list
16:06:08 <fishythefish> However, the tradeoff is that your accumulator must now have the same type as the elements of your list
16:06:55 <GH-PH-Student> Got it. You also teached me to take a further look at the types when in doubt.
16:07:23 <fishythefish> "look at the types when in doubt" often turns out to be a good philosophy
16:10:44 <bollu> ping
16:10:52 <fishythefish> pong
16:11:03 <bollu> if we think of STG, there is no way to write "compose" without "let", is there?
16:12:03 * hackagebot rattletrap 3.0.0 – Parse and generate Rocket League replays. – https://hackage.haskell.org/package/rattletrap
16:21:29 <boogalooga> hello
16:21:43 <boogalooga> I have a couple of newb questions
16:21:47 <boogalooga> Who can help me out?
16:21:59 <geekosaur> best to just ask the question(s)
16:22:32 <boogalooga> So
16:22:37 <boogalooga> when I'm using ghci
16:22:49 <boogalooga> I'm learning from here, btw
16:22:50 <boogalooga> http://learnyouahaskell.com/starting-out
16:22:56 <boogalooga> okay, so I was using ghci
16:23:17 <boogalooga> and the tutorial I linked to says that in haskell once a name is bound to an expression
16:23:24 <boogalooga> you can't change what the name is bound to
16:23:33 <boogalooga> but I seem to be able to that in ghci
16:23:34 <boogalooga> also
16:23:40 <boogalooga> what's the difference between
16:23:40 <geekosaur> true in files. in ghci it's a bit weeirder because every prompt is a new scope
16:23:41 <boogalooga> a = 2
16:23:46 <boogalooga> and let a = 2
16:23:51 <boogalooga> ohhhh
16:23:58 <boogalooga> I thought it might be something like that
16:24:06 <boogalooga> kk thanks
16:24:19 <geekosaur> nothing in ghc 8.x. in older ghci, the former will throw a syntax error
16:24:32 <boogalooga> I see
16:24:37 <boogalooga> what about running code in a file
16:24:39 <boogalooga> any difference
16:24:40 <boogalooga> ?
16:24:47 <geekosaur> bare 'let' isn't allowed in a file
16:24:49 <boogalooga> between let a = 2 and a = 2
16:25:05 <geekosaur> top level only takes 'a = 2', the 'let a = 2' without following 'in' is only allowed in 'do' syntax
16:25:28 <boogalooga> aah, not sure what in and do are yet. I'll find out once I proceed a bit more in the tutorial
16:25:30 <boogalooga> thanks
16:25:42 <boogalooga> was there any reason why ghci didn't allow a = 2?
16:25:43 <boogalooga> initially
16:26:05 <geekosaur> they were trying to make the prompt act like the inside of a 'do' in IO
16:26:21 <geekosaur> and you cant write 'a = 2' in that context, only 'let a = 2'
16:26:28 <boogalooga> I see
16:26:30 <boogalooga> thanks
16:26:35 <boogalooga> also is this tutorial http://learnyouahaskell.com/starting-out
16:26:40 <boogalooga> the best starting point
16:26:49 <geekosaur> but things have changed since thne, ghci now allows other things illegal inside a 'do' like data declarations and imports
16:26:52 <boogalooga> I've used some scheme before when learning SICP
16:26:56 <boogalooga> if that's relevant 
16:27:23 <geekosaur> LYAH isn't really the best way to learn Haskell. it's a 2-hour movie trailer, or a 14-countries-in-14-days tour
16:28:00 <geekosaur> you get to see what it looks like but you won't be able to *write* Haskell code without something else alongside, preferably with exercises
16:28:01 <geekosaur> @where cis194
16:28:02 <lambdabot> http://www.seas.upenn.edu/~cis194/spring13/
16:28:05 <geekosaur> @where nicta
16:28:06 <lambdabot> https://github.com/nicta/course
16:28:13 <geekosaur> these are at-your-own-pace online courses
16:28:37 <EvanR> .oO( A Gentle Introduction to Haskell )
16:30:39 <boogalooga> I see
16:30:45 <boogalooga> which one do you recommend
16:30:56 <boogalooga> data61 or cs194?
16:32:08 * hackagebot docker 0.4.1.0 – An API client for docker written in Haskell – https://hackage.haskell.org/package/docker
16:33:10 <geekosaur> cis194 probably
16:33:36 <peddie> boogalooga: data61 is pretty aggressive; it's originally the materials for a three-day course taught in person, so it might be easier to start with CIS194
16:34:14 <boogalooga> I see
16:34:15 <boogalooga> thanks
16:34:17 <boogalooga> :p
16:34:43 <mniip> three day course for haskell?
16:34:51 <mniip> that is brutal
16:35:37 <peddie> mniip: https://qfpl.io/links/2017-october-fp-course/ for example
16:36:09 <EvanR> day 1, the whole of GHCs features. day 2, all of functional programming. day 3, advance haskell shenanigans
16:36:27 <mniip> wow
16:36:49 <hpc> day 4, the BASIC monad
16:36:50 <mniip> I don't believe it
16:36:58 <mniip> it's not going to work
16:37:00 <EvanR> day 5 the PHP monad
16:37:08 <hpc> @hackage acme-php
16:37:08 <lambdabot> http://hackage.haskell.org/package/acme-php
16:37:08 <EvanR> after that, you can get a real job (doing PHP)
16:37:11 <MP2E> haha :)
16:37:27 <boogalooga> haha
16:38:03 <hpc> LYAH's main strength is in making haskell as unintimidating as possible
16:38:25 <boogalooga> can I use the spring 15 lectures instead of 13?
16:38:29 <boogalooga> or are the spring 13 ones
16:38:32 <boogalooga> better or smth
16:38:44 <hpc> the 13 ones are better, the course changed a lot after that
16:38:53 <boogalooga> I see. Thanks
16:38:57 <hpc> i forget exactly how, but it wasn't for the better
16:38:58 <dibblego> haskell is taught in one hour in that course
16:40:48 <boogalooga> @dibblego
16:40:48 <lambdabot> Unknown command, try @list
16:40:53 <boogalooga> which course?
16:41:46 <dibblego> the data61 course, when delivered in person, here is the next one, coming? https://qfpl.io/links/2017-october-fp-course/
16:43:38 <ski> Data61 replaces NICTA ?
16:45:33 <boogalooga> is there a way to filter the has quit messages?
16:45:48 <Axman6> ski: yes, NICTA became Data61
16:45:58 <hpc> boogalooga: depends on your client, you'll have to google it
16:46:03 <peddie> mniip: it's worked many times :)
16:47:20 <koz_> Suppose I have f :: b -> Either e a, and I do traverse f on a list of bs. If f produces multiple Lefts from the data in my list of bs, what on earth will the result of traverse be in this case?
16:47:28 <koz_> Does it keep the first error? The last error? Somethign else?
16:47:46 <dibblego> koz_: the first Left
16:47:53 <koz_> dibblego: OK, thanks.
16:47:57 <dibblego> koz_: there is an additional Applicative, that accumulates left values
16:49:00 <ski> ok, Axman6
16:52:09 <ski> @where+ Data61 Data61 Functional Programming Course <https://github.com/data61/fp-course>,<https://qfpl.io/links/2017-october-fp-course/> by Tony Morris,Mark Hibberd
16:52:09 <lambdabot> It is forever etched in my memory.
16:53:09 <ski> ok, Axman6
16:53:26 <Axman6> ok. ski :)
16:54:37 <typedrat> How do you make GHC iterate type functions more before giving up? I think that is possible, I remember having to do it... and I think that might help it
16:54:53 <Axman6> there's a flag for that...
16:55:57 <typedrat> I know
16:56:01 <typedrat> I don't remember the flag
16:56:06 <typedrat> and I am not seeing it in the docs
16:57:50 <peddie> typedrat: -freduction-depth=<n> ?
16:59:38 <typedrat> yep
16:59:41 <typedrat> I'm not smart
16:59:44 <geekosaur> -fmax-simplifier-iterations=N -freduction-depth=N -funfolding-* -fconstraint-solver-iterations=N
17:04:36 * hackagebot colorless 2.2.0 – Colorless – https://hackage.haskell.org/package/colorless
17:40:08 <boogalooga> anyone know a good syntax highlighter for sublime
17:40:09 <boogalooga> ?
17:41:01 <Axman6> the haskell package? :\
17:42:07 <koz_> I never remember - for filter, is it 'keep the thing that match the predicate' or 'throw the things that match the predicate'?
17:43:54 <Axman6> keep
17:43:57 <Axman6> > filter even [1..10]
17:44:00 <lambdabot>  [2,4,6,8,10]
17:44:23 <Axman6> "LKeep the good stuff, filter out the bad stuff"
17:45:01 <koz_> Axman6: Thanks.
17:45:08 <koz_> I can never remember that for some reason.
17:46:39 * Axman6 feels `keep` might be a better name for filter, and also discard = keep . not
17:46:39 <geekosaur> hard to remember because every language seems to make its own decision about which it means :/
17:47:19 <koz_> geekosaur: Yeah, one of those annoying inconsistencies.
17:47:37 <Axman6> it's just a bad name for the action really
17:47:39 <koz_> Honestly, it'd be nicer if filter was written using a (a -> Maybe a), because then it's obvious.
17:47:47 <mniip> why does (==) have to be xnor and not xor
17:48:14 <nshepperd_> mapMaybe
17:48:41 <Axman6> > (\x y -> (x,y,x==y)) <$> [True,False] <*> [True,False]
17:48:42 <koz_> :t mapMaybe
17:48:44 <lambdabot> (a -> Maybe b) -> [a] -> [b]
17:48:44 <lambdabot>  [(True,True,True),(True,False,False),(False,True,False),(False,False,True)]
17:48:54 <c_wraith> mapMaybeNot
17:49:05 <koz_> c_wraith: mapIndecisively
17:49:06 <Axman6> > (\x y -> (x,y,x/=y)) <$> [True,False] <*> [True,False]
17:49:09 <lambdabot>  [(True,True,False),(True,False,True),(False,True,True),(False,False,False)]
17:49:42 <nshepperd_> I've never seen it go the other way in a programming language
17:50:12 <koz_> @unmtl StateT [t0] Maybe Bool
17:50:13 <lambdabot> [t0] -> Maybe (Bool, [t0])
17:50:37 <nshepperd_> But sometimes people say in english "filter x out" which means to get rid of x
17:52:00 <qmm> is this correct? given that foo returns "m (Foo a)", i should have the capability to manipulate Foo without without unraveling the m, given that foo is used in this way:  do {  f <- foo ... ; ... }
17:52:04 <geekosaur> because a filter is a thing that removes stuff. e.g. air filters, water filters, oil filters...
17:52:32 <geekosaur> :t fmap
17:52:34 <lambdabot> Functor f => (a -> b) -> f a -> f b
17:52:56 <geekosaur> now remember that all Monads are Applicatives and therefore Functors
17:53:04 <c_wraith> though in all cases, those filters let through the named thing.
17:53:56 <Axman6> qmm: now sure I understand the question, but in ... you have access to the value of type Foo a
17:54:59 * hackagebot texmath 0.9.4.4 – Conversion between formats used to represent mathematics. – https://hackage.haskell.org/package/texmath
17:56:03 <koz_> OK, monad transformers are doign my head in. How do I write a computation that keeps a log of type [a], but might 'crash out' with a Nothing?
17:56:19 <koz_> Or rather, what would its type be?
17:56:35 <koz_> I know I need WriterT [a] and MaybeT in there someplace, but I have no idea how I'm meant to stack them properly.
17:56:49 <Axman6> WriterT [a] Maybe a?
17:56:51 <geekosaur> that depends on what you want the log to do
17:57:01 <Axman6> @unmtl WriterT [a] Maybe a
17:57:01 <lambdabot> Maybe (a, [a])
17:57:15 <geekosaur> if the Maybe-ish is outside and the Writer-ish inside, you lose the log on a Nothing
17:57:24 <koz_> geekosaur: This is exactly what I want.
17:57:34 <Axman6> if you need the output of the writer even if it fails, I think you need MaybeT (WriterT [a]) b
17:57:43 <Axman6> @unmtl  MaybeT (WriterT [a]) b
17:57:44 <lambdabot> Plugin `unmtl' failed with: `WriterT [a] (Maybe b)' is not applied to enough arguments, giving `/\A. Maybe b (A, [a])'
17:58:03 <Axman6> @unmtl  MaybeT (Writer [a]) b
17:58:03 <lambdabot> (Maybe b, [a])
17:58:55 <koz_> Axman6: I don't wanna keep the output of the writer if it fails.
17:59:27 <Axman6> then you want the former
17:59:49 <koz_> Axman6: So WriterT [a] Maybe a?
18:00:02 <Axman6> yep
18:00:51 <koz_> What's that second a in there for?
18:01:30 <texasmynsted> dibblego: continued from different channel... What would you recommend for Haskell education?  
18:02:27 <dibblego> http://github.com/data61/fp-course and CIS194
18:02:47 <koz_> Axman6: I'm a bit confused about that second 'a' in there. 
18:02:49 <dibblego> next time you are in .au come to a free three day, intensive course, https://qfpl.io/links/2017-october-fp-course/
18:05:35 <taylskid> so, I'm writing a little HTTP server, and I just wrote this function: https://cpy.pt/5q1ECayz but I'm not really sure this is the best way to write it
18:05:38 <taylskid> any suggetions?
18:09:02 <texasmynsted> Nice I will.
18:09:12 <texasmynsted> au is a super long flight 
18:09:46 <texasmynsted> totally on my list though
18:12:29 <texasmynsted> wow a free 3 day FP course delivered by you?  :-)  Very cool!
18:13:20 <texasmynsted> good grief you must need a really big venue 
18:21:33 <moet> hi, stack question: is it possible to exclude a single dependency whose haddocks won't generate properly when doing a `stack haddock` in a project?
18:23:46 * hackagebot yarn-lock 0.3.3 – Represent and parse yarn.lock files – https://hackage.haskell.org/package/yarn-lock
18:42:01 <vc_> i'm writing a few argument flipping/rotating functions and it's hurting my small brain a bit
18:42:24 <koz_> I have a computation that can return either exactly one success of type a, or one or more errors of type e. What sort of monadic stack am I looking at?
18:42:46 <koz_> Would it just be ExceptT [e] m a?
18:43:13 <jle`> it sounds like just Either [e] a
18:43:24 <jle`> or if you're running it in m, m (Either [e] a)
18:43:38 <koz_> jle`: OK, fair enough.
18:43:41 <jle`> (if m is your 'computation')
18:43:42 <vc_> i think part of it is the type signatures rotate opposite the arguments
18:43:46 <vc_> r0 f a b c d = f a b c d
18:43:52 <vc_> r0 :: (t1 -> t2 -> t3 -> t4 -> t5) -> t1 -> t2 -> t3 -> t4 -> t5
18:43:58 <vc_> r2 f a b c d = f c d a b
18:44:06 <vc_> r2 :: (t1 -> t2 -> t3 -> t4 -> t5) -> t3 -> t4 -> t1 -> t2 -> t5
18:44:40 <vc_> now i'm trying to wrap my head around this
18:44:42 <vc_> x1 f a b c d = f c a b d
18:44:46 <vc_> x1 :: (t1 -> t2 -> t3 -> t4 -> t5) -> t2 -> t3 -> t1 -> t4 -> t5
18:44:57 * koz_ raises hand.
18:45:01 <vc_> why isn't t3 (c) the first type?
18:45:04 <moet> i have to go offline, but please /query me if you know the stack question :)
18:45:06 <vc_> in x1
18:45:09 <koz_> WHY OH GOD WHY
18:46:05 <jle`> vc_: the first type is (t1 -> t2 -> t3 -> t4 -> t5)
18:46:10 <jle`> because it's a function
18:46:49 <vc_> jle` ok..
18:46:52 <jle`> you apply it to values -- ie, f c a b d
18:46:55 <jle`> so it can't be t3
18:47:02 <jle`> haskell knows that it's some function type
18:47:10 <iqubic> Haskell and NixOS do not mix very well.
18:47:12 <jle`> hence (t1 -> t2 -> t3 -> t4 -> t5)
18:47:25 <vc_> ok yeah the function signature makes sense
18:47:39 <vc_> it's the ordering of the remaining arguments that i find confusing
18:47:46 <iqubic> I'm trying to install this: https://hackage.haskell.org/package/glirc and getting nowhere
18:47:49 <vc_> i think it's something about how things come out the reverse of the arguments
18:48:02 <vc_> but i'm having trouble tracing / reasoning through it
18:48:06 <jle`> vc_: so 'a' is the second thing you give to 'f'
18:48:12 <jle`> and f is t1 -> t2 -> t3 -> t4 -> t5
18:48:31 <jle`> so a :: t2, since f's second argument has type t2
18:48:38 <jle`> next, looking at 'b'
18:48:50 <jle`> you give b as the third argument to 'f'
18:48:58 <jle`> and f :: t1 -> t2 -> t3 -> t4 -> t5
18:49:06 <jle`> so whatever the third argument of 'f' is, is a t3
18:49:08 <jle`> so b :: t3
18:49:40 <jle`> c is the first argument, so c :: t1, d is the fourth argument, so d :: t4
18:49:53 <vc_> I think I follow
18:50:13 <vc_> it's kind of a "rank" vs. "order" distinction...
18:50:27 <vc_> i guess the key is to follow from the application side
18:50:45 <vc_> and work out how the application maps to a b c d
18:50:55 <vc_> instead of the other way around which is somehow my natural inclination...
18:51:41 <jle`> i think if you follow things logically, it is hard to get it wrong
18:51:46 <jle`> since the entire thing is a mechanical process
18:51:54 <jle`> just start filling in the blanks yourself, on pen and paper
18:52:01 <vc_> it is...
18:52:04 <jle`> there really isn't any other way to interpret it
18:52:18 <jle`> the only way you'd go wrong is if you don't even use logic and just make up a conclusion, heh
18:52:53 <vc_> i can follow it mechanically for a given permutation definition
18:53:06 <vc_> how can i work backwards, i.e. i'm trying to obtain a particular re-ordering
18:53:26 <vc_> how do i work out the right definition for it
18:53:29 <jle`> working backwards is a bit tricker
18:53:38 <jle`> because that's basically proof searching
18:54:29 <jle`> i mean, it's still possible to do mechanically for this specific situation, but not in general, and it's inherently a bit trickier
18:54:40 <jle`> @djinn (a -> b -> c -> d) -> b -> c -> a -> d
18:54:40 <lambdabot> f a b c d = a d b c
18:55:21 <jle`> ^ it's possible to do it mechanically, but djinn basically searches every potential permutation until it finds out that fits
18:55:22 <vc_> ok i'll just brute force it
18:55:24 <jle`> (in a smart way)
18:55:46 <jle`> yeah, if you're familiar with curry-howard isomorphism, or the idea of types as proofs
18:55:48 <vc_> at least i'm not imagining that it's hard to work backwards
18:55:56 <jle`> working forwards is basically like verifying a solution
18:56:17 <jle`> walking backwards is basically *creating* the solution, which is inherently trickier
18:56:21 <vc_> <- not a computer scientist, just a haskell programmer :/
18:56:45 <jle`> so it's like the difference between verifying that a suduko board is correct, vs. filling out an empty sudoki board
18:56:49 <jle`> *sudoku
18:57:33 <jle`> but, for basic flipping, it's something that you can actually do mechanically, and if you do a few of them you should sort of start seeing the pattern 
18:58:17 <vc_> thanks i'll try it
19:00:38 <iqubic> glguy: Have you pushed this commit of glirc to hackage yet? https://github.com/glguy/irc-core/commit/f8a3c86f2ee9198002b05dd0c7962db813e7b2a5
19:00:51 <vc_> solving for c -> a -> b -> d ...
19:00:52 <vc_> aha
19:01:06 <vc_> x1 f a b c d = f b c a d
19:01:39 <vc_> mnemonic that works for me is "where did that one end up"
19:01:49 <vc_> defines the type signature :)
19:02:55 <jle`> vc_: one thing that might be throwing you off is your unfortunate choice of variable names
19:03:14 <jle`> in your case, (b :: c), which is a really quick way to confuse yourself
19:04:19 * hackagebot yarn-lock 0.3.4 – Represent and parse yarn.lock files – https://hackage.haskell.org/package/yarn-lock
19:04:48 <vc_> my reasoning is "a ends up at position 3, so t3 is now arg 1"
19:05:55 <vc_> "b ends up at position 1, so t1 is now arg 2"
19:06:05 <vc_> "c ends up at position 2, so t2 is now arg 3"
19:06:17 <vc_> "d ends up at position 4 , so t4 is now arg 4"
19:07:13 <vc_> feels like one of those sadistic word vs. visual color name tests.. but it makes sense for the few seconds i can keep this in my brain
19:17:09 <iqubic> :t \ f a b c d -> d c a b
19:17:11 <lambdabot> p -> t1 -> t2 -> t3 -> (t3 -> t1 -> t2 -> t4) -> t4
19:17:18 <spikes> hi!
19:17:37 <iqubic> :t \ f a b c d -> c a b d
19:17:39 <lambdabot> p -> t1 -> t2 -> (t1 -> t2 -> t3 -> t4) -> t3 -> t4
19:18:02 <vc_> iqubic having fun? :)
19:18:07 <iqubic> Why is that second one so radically different?
19:18:12 <iqubic> vc_: Yes actually.
19:18:42 <vc_> "where did that one end up?" is the answer
19:19:12 <iqubic> What one?
19:19:30 <vc_> at least the way i finally got my brain to process it. the intuitive thing is wrong...
19:19:52 <vc_> which is to follow the letters...
19:20:00 <vc_> instead
19:20:31 <vc_> you read off the type signature by asking where each of the LHS args ends up.
19:22:10 <vc_> er also, at least keep the function position the same
19:22:59 <vc_> it's confusing enough with that constraint, so f starts on both sides
19:23:52 <vc_> believe it or not this is for a real-world problem i'm trying to solve and not some stupid sudoku brain teaser. Damn foreignPtrs ...
19:25:04 <iqubic> I now understand how that works.
19:25:10 <iqubic> I just puzzled it out.
19:25:54 <vc_> :)
19:27:07 <iqubic> \ f a b c d -> f d c b a
19:27:12 <iqubic> :\ f a b c d -> f d c b a
19:27:16 <iqubic> :t \ f a b c d -> f d c b a
19:27:18 <lambdabot> (t1 -> t2 -> t3 -> t4 -> t5) -> t4 -> t3 -> t2 -> t1 -> t5
19:27:43 <iqubic> :t \ f a b c d -> d c b a f
19:27:45 <lambdabot> t1 -> t2 -> t3 -> t4 -> (t4 -> t3 -> t2 -> t1 -> t5) -> t5
19:29:51 <vc_> I wonder if there's a better way
19:30:03 <vc_> for multi-arg foreignPtrs functions
19:30:18 <vc_> is there a better solution than nested withForeignPtr calls?
19:30:24 <vc_> this is doable but kindof cumbersome
19:30:32 <vc_> I feel like I'm writing javascript callbacks or something.
19:37:56 <qih> Hi, I am following the examples in the Programming in Haskell 2nd Ed, and I have an issue:
19:38:50 <qih> "abs n = if n >= 0 then n else -n" ... works fine for positive integers but negatives one cause an issue, why?
19:39:37 <platz> I have an existential in a record. ghc seems to forget the typeclass constraint on the field when I try to use it later http://lpaste.net/358934
19:41:49 <qih> Ah sorted, I need to "abs (-3.0)" not "abs -3"
19:42:49 * hackagebot typed-wire-utils 0.2.0.0 – Haskell utility library required for code generated by typed-wire compiler – https://hackage.haskell.org/package/typed-wire-utils
19:43:03 <Profpatsch> qih: yes, the `-` operator is afaik the only prefix operator in Haskell, and it needs parens.
19:43:30 <qih> Profpatsch: Thanks for confirmation.
19:44:38 <geekosaur> negation parsing is a hack :/
19:45:03 <qih> Ah
19:45:31 <qih> The GHCI, can I call it a REPL?
19:45:53 <iqubic> Yes.
19:45:58 <qih> iqubic: Thanbks
19:45:59 <geekosaur> yes, and a few tools even do (e.g. "cabal repl" to load a project into ghco)
19:46:05 <geekosaur> *ghci
19:47:26 <iqubic> glguy: Have you pushed this commit of glirc to hackage yet? https://github.com/glguy/irc-core/commit/f8a3c86f2ee9198002b05dd0c7962db813e7b2a5
19:47:30 <qih> OK at the REPL, if I want to type a multiline command, how can I do it? Python does multiline entry automagically.
19:47:57 <geekosaur> :{ :}, or :set +m for continuous multiline mode
19:48:18 <geekosaur> (input in the +m version has to be ended with a completely blank line)
19:48:27 <qih> Ahhh cool thanks, I saw some entries but could not get it correct
19:48:36 <geekosaur> ghci is not very smart, and haskell poses some extra difficulties
19:48:54 <iqubic> Anyone know when glguy will be back around?
19:48:57 <qih> Well that's OK, cos neither am I (smart)
19:48:59 <geekosaur> because most languages don't let you have multiple definitions that don't differ in # parameters or types
19:49:11 <qih> OK
19:49:24 <geekosaur> (which will be coalesced into a single definition using a pattern match)
19:51:43 <qih> Hmm, I tried ":set +m" for the cmd ...
19:51:59 <qih> abs n | n >= 0 = n
19:52:07 <qih> | otherwise = -n
19:52:14 <qih> but got an error
19:52:37 <dmj`> > digitToInt 'a'
19:52:40 <lambdabot>  10
19:52:42 <dmj`> > digitToInt 'g'
19:52:46 <lambdabot>  *Exception: Char.digitToInt: not a digit 'g'
19:52:58 <geekosaur> qih, what error?
19:53:13 <qih> <interactive>:42:1: error: parse error on input ‘|’
19:53:25 <geekosaur> yeh, so your ghci is older than 8.0
19:53:36 <geekosaur> you need to start definitions and bindings with 'let'
19:53:51 <qih> GHCi, version 8.2.1: http://www.haskell.org/ghc/  :? for help
19:54:20 <geekosaur> ok, did the error happen on the first line or the second?
19:54:25 <qih> Second
19:54:35 <geekosaur> if it's the second then it's indentation, which matters just as much in ghci as in code in a file
19:54:45 <qih> Ah right, der
19:55:59 <platz> interesting, I solved the existential-in-record problem by moving the existential out into it's own data type, and then including that in the record
19:58:16 <qih> geekosaur: OK, so :set +m, then "let abs n| n ...." worked correctly, thanks
19:59:31 <fresheyeball> any know how to deal with it when there are two ExceptT's in a stack?
19:59:51 <dmwit> What is there to deal with, specifically?
19:59:52 <iqubic> dmj`: digitToInt only works with valid Hexadecimal values
20:00:02 <dmwit> Perhaps: `lift`.
20:04:05 <iqubic> > digitToInt 'c'
20:04:07 <lambdabot>  12
20:04:46 <dmwit> qih: Nothing in `abs n | n >= 0 = n` triggers automatic multiline mode. You can either start it explicitly with `:{` or use a construct like `let` that does trigger automatic multiline.
20:05:35 <fresheyeball> dmwit: I have an circumstance where I have `MonadError ErrorA (ExceptT ErrorB m)`
20:05:41 <dmwit> (Arguably guards should trigger automatic multiline mode since the prevailing style involves putting separate guards on separate lines.)
20:05:44 <dmwit> (But it doesn't.)
20:05:46 <fresheyeball> and no matter what I do, it handles the wrong one
20:05:58 <qih> dmwit: Thanks, geekosaur sorted me
20:06:26 <dmwit> Yes, but geekosaur was slightly wrong (the indentation was not the problem) and I wanted to clarify that point.
20:06:41 <geekosaur> on line 2 it was indentation
20:06:45 <dmwit> nope
20:06:52 <dmwit> The problem was it hadn't started multiline mode.
20:07:02 <dmwit> It hadn't gotten to the point where it could notice the wrong indentation yet.
20:07:04 <geekosaur> no, this was in :set +m
20:07:12 <dmwit> :set +m doesn't make every line a multiline.
20:07:32 <dmwit> There's a handful of triggers that start multiline mode with :set +m and he hadn't mentioned any of them.
20:07:39 <geekosaur> it was definitely in multiline here (prompt changed to Prelude| )
20:07:53 <geekosaur> 7.10.3 fwiw
20:08:34 <dmwit> Hm. I don't see any mention of `Prelude|` in the messages starting around 19:51 that talk about :set +m. But perhaps I am missing some context.
20:09:27 <geekosaur> http://lpaste.net/358935
20:09:59 <dmwit> He didn't type `let`...
20:10:05 <geekosaur> which is my local reproduction of what was being tried. granted I cannot know that was exactly what they were doing, but on the other hand I did noting special other than :set +m
20:10:10 <geekosaur> also they are in 8.2.1
20:10:33 <qih> eventually he did type let, and then used the correct indentation
20:10:42 <qih> Yes I have 8.2.1
20:10:56 <dmwit> I'm explaining the behavior you saw without `let`.
20:11:08 <dmwit> Which I believe you did not have an explanation for before I started talking.
20:11:19 <qih> OK
20:13:16 <dmwit> You can also `abs n | n >= 0 = n | otherwise = -n`.
20:13:23 <dmwit> ...no `let` needed.
20:13:32 <qih> I killed the REPL, did it again ... :set +m & 'let abs n | n >= o = n ... puts it into multiline mode, positively
20:13:44 <qih> dmwit: OK
20:13:46 <dmwit> Yes. `let` is one of the triggers for automatic multiline mode.
20:14:33 <dmwit> When you *didn't* use `let`, you just made a definition without mentioning any of the triggers, so you didn't enter multiline mode, so your *second* line (`| otherwise = -n`) was trying to parse as its own definition rather than as a second line for the first definition.
20:14:55 <qih> OK I now understand. Well thanks for both of your help and ineresting conversation. I thought it was going to be Haskells at 10 paces
20:15:05 <dmwit> So even if you had fixed the indentation, it still would not have worked.
20:15:12 <qih> True
20:16:40 <dmwit> I believe `let`, `where`, `case/of`, and open parentheses/brackets are the triggers.
20:16:53 <dmwit> Probably \case should be (but isn't), and probably guards should be (but aren't).
20:17:14 <geekosaur> guards might actually be 'interesting' to deal with
20:17:51 <dmwit> What do you think might be hard?
20:17:54 <geekosaur> not sure how finely the grammar is factored
20:18:00 <dmwit> right
20:18:47 <geekosaur> but it seems to me that, while data decls are likely to be different enough, class decls with fundeps might be parsed just enough like guards to require a little extra care
20:19:21 <geekosaur> you certainly can;t get away with something simpleminded like just looking for unquoted |s
20:19:55 <dmwit> It's probably okay to start multiline mode for fundeps, too. It's a pretty unusual class that doesn't have a `where` soon after.
20:20:28 <dmwit> (And if it does, well, one extra keypress is pretty cheap.)
20:21:28 * hackagebot gdax 0.6.0.0 – API Wrapping for Coinbase's GDAX exchange. – https://hackage.haskell.org/package/gdax
20:22:18 <qih> This Programming in Haskell 2nd Ed uses Single Quotes in the examples but I don't know if it means ` or ' 
20:22:38 <dmwit> Both characters are used in Haskell.
20:22:40 <qih> `is below the ~ and ' is below the "
20:22:52 <qih> Interchangeably?
20:22:54 <dmwit> ' is for Char literals; ` is for turning prefix functions into infix ones.
20:23:09 <dmwit> > ['a', 'b', 'c']
20:23:12 <lambdabot>  "abc"
20:23:19 <dmwit> > 3 `elem` [1,2,3]
20:23:21 <lambdabot>  True
20:23:29 <qih> Ahhh so a list would be ['a','b','c']
20:23:54 <qih> and changing a function like add would be add` ?
20:24:14 <dmwit> ` has to go before and after.
20:24:26 <dmwit> ' is completely unrelated to lists, really. I just used a list for fun.
20:24:39 <qih> Now I see why my examples are failing, crikey
20:24:40 <dmwit> > ('a', 'b', 'c')
20:24:43 <lambdabot>  ('a','b','c')
20:24:49 <erisco> though unfortunately, arbitrary expressions cannot go in backticks =\
20:24:52 <dmwit> > Just 'a'
20:24:56 <lambdabot>  Just 'a'
20:25:37 <dmwit> ' is also used in other ways for some GHC extensions. Presumably needing to worry about that is far in your future, though.
20:25:52 <qih> I would expect so
20:26:30 <erisco> you can use ' in an identifier name, though not as the leading character
20:27:36 <qih> OK noted
20:28:54 <dmwit> > let don't x = head [return (), x] in don't $ do { putStrLn "hello"; putStrLn "world!" }
20:28:57 <lambdabot>  <IO ()>
20:29:01 <dmwit> % let don't x = head [return (), x] in don't $ do { putStrLn "hello"; putStrLn "world!" }
20:29:10 <dmwit> hm =)
20:29:16 <dmwit> Oh, yahb is gone! =(
20:29:57 <benzrf> i didnt know we had more than one hb
20:30:41 <dmwit> yahb does IO and unsafeCoerce and stuff! It's super neat.
20:30:51 <benzrf> D:
20:30:53 <dmwit> It's like \bot's naughty cousin.
20:31:12 <benzrf> _|_
20:32:22 <koz_> What is Fokkinga's prepromorphism meant to do?
20:32:31 <qih> benzrf: Did you mean ..|.. ?
20:32:35 <koz_> I'm looking at its type here: https://hackage.haskell.org/package/recursion-schemes-5.0.2/docs/Data-Functor-Foldable.html#v:prepro
20:32:41 <koz_> And I have no clue what it's trying to say.
20:32:54 <erisco> is it just me, or does the ASCII version of ⊥ look like a bird?
20:33:19 <erisco> a fitting interpretation, if I say so
20:33:40 <koz_> erisco: I think Stephen Diehl said that bottom is the compiler flipping you off.
20:35:13 <benzrf> qih: http://mathb.in/18834
20:36:09 <dmwit> oh
20:36:17 <dmwit> That joke never even occurred to me before now!
20:41:10 <qih> benzrf: Ta
20:52:56 <boogalooga> quick question: What is pattern matching
20:52:57 <boogalooga> ?
20:53:02 <boogalooga> http://www.seas.upenn.edu/~cis194/spring13/lectures/01-intro.html
20:53:09 <boogalooga> I'm seeing the term used here a lot
20:53:28 <fresheyeball> pattern matching is a techique for testing if a given value matches a pattern
20:53:56 <fresheyeball> it can be used to extract values, or make things similar to switch statements
20:57:04 <boogalooga> sumPair :: (Int,Int) -> Int sumPair (x,y) = x + y
20:57:22 <boogalooga> sumPair :: (Int, Int) -> Int
20:57:27 <boogalooga> sumPair (x,y) = x + y
20:57:32 <boogalooga> this is given as an example
20:57:41 <boogalooga> how does pattern matching play a role here
20:57:45 <boogalooga> oh wait
20:57:51 <boogalooga> is it the same as
20:57:56 <boogalooga> x, y = (1, 0)
20:57:58 <boogalooga> in Python
20:57:59 <boogalooga> ?
20:58:08 <fresheyeball> boogalooga: yes
20:58:11 <c_wraith> similar in that case
20:58:29 <boogalooga> but that is an example of pattern matching in Haskell?
20:58:43 <fresheyeball> yes
20:58:44 <c_wraith> It's an example of matching a type with only a single constructor
20:59:09 <c_wraith> Matching is also branching, when you match multiple constructors
20:59:48 <c_wraith> Matching also lets you nest patterns
21:00:08 <boogalooga> dunno what constructors in Haskell are yet
21:01:30 <c_wraith> > case Just (2, ([1..10], ())) of Just (_, ((x:xs), _)) -> xs
21:01:32 <lambdabot>  [2,3,4,5,6,7,8,9,10]
21:02:14 <fresheyeball> boogalooga: so if you are used to destructured assignment in python or javascript, that is a use case for pattern matching
21:02:27 <fresheyeball> however pattern matching is much much muuch muuuuuch more powerful
21:03:58 <boogalooga> I see
21:04:01 <boogalooga> so for now
21:04:18 <boogalooga> I'll just keep that in mind
21:04:21 <boogalooga> till I learn more
21:04:32 <c_wraith> > case 1 == 2 of True -> "I can do math" ; False -> "I can't do math"
21:04:35 <lambdabot>  "I can't do math"
21:04:43 <c_wraith> > case 1 + 1 == 2 of True -> "I can do math" ; False -> "I can't do math"
21:04:46 <lambdabot>  "I can do math"
21:07:39 <boogalooga> tbh learning a new language is pretty fun
21:07:58 <boogalooga> especially a language like Haskell which seems esoteric
21:11:41 <fresheyeball> boogalooga: esoteric is one thing. Haskell is powerful. You shouldn't learn it because it's esoteric, learn it because it rocks ;)
21:15:18 <boogalooga> fresheyeball: 2 hours into learning it, so I don't quite appreciate it's power yet
21:15:26 <boogalooga> I'm sure I will in a couple of weeks
21:15:27 <boogalooga> haha
21:16:41 <fresheyeball> boogalooga: I've been studying it dayly for 4 years
21:16:51 <fresheyeball> I am no where near appricating it's full power
21:17:04 <boogalooga> True
21:17:08 <fresheyeball> boogalooga: you have to understand, the ceiling on this language is insane
21:17:17 <boogalooga> I understan
21:17:21 <boogalooga> understand*
21:17:39 <fresheyeball> I think Python is tac tac toe
21:17:56 <boogalooga> haha, interesting
21:17:59 <fresheyeball> and Haskell is (Chess * 50)
21:18:12 <fresheyeball> both are easy to get started
21:18:17 <fresheyeball> Python easier for sure
21:18:26 <fresheyeball> but the room for growth and skill, it's no question
21:18:36 <boogalooga> it's pretty weird, but for now I don't see Haskell being too useful to me aside from being a hobby
21:18:46 <fresheyeball> boogalooga: why?
21:18:50 <boogalooga> unless I somehow get an internship programming in Haskell next summer
21:19:12 <fresheyeball> there are plenty of Haskell jobs
21:19:19 <boogalooga> internships?
21:19:23 <fresheyeball> that too
21:19:34 <fresheyeball> but you have to be productive in Haskell
21:19:41 <boogalooga> I tried pretty hard to get a fall internship writing lisp
21:19:43 <fresheyeball> and that is a bar to high for many programmers
21:19:59 <boogalooga> but ended up being hired a python software dev
21:20:01 <boogalooga> rip
21:20:07 <boogalooga> aah I see
21:20:38 <boogalooga> though I like Python, haha
21:21:01 <fresheyeball> Python is a very nice language for not being a very good language
21:21:45 <boogalooga> what does that mean?
21:21:47 <boogalooga> haha
21:21:58 <fresheyeball> most languages are not very good languages
21:22:04 <fresheyeball> they don't have sound type systems
21:22:09 <boogalooga> aah I see
21:22:14 <fresheyeball> they don't have good compiler support
21:22:29 <fresheyeball> they don't give you the tools you need to ensure your code wont fail in the client's hands
21:22:33 <fresheyeball> but of those languages
21:22:37 <fresheyeball> Python is very nice
21:24:01 <boogalooga> I see
21:24:10 <fresheyeball> just my opinion 
21:24:14 <boogalooga> isn't the type checking in Python pretty good though
21:24:19 <fresheyeball> no
21:24:38 <fresheyeball> I hardly consider Python's type system a type system
21:24:50 <fresheyeball> you will learn that very soon 
21:24:59 <boogalooga> I see
21:25:00 <boogalooga> haha
21:25:35 <fresheyeball> frankly, any lanauge in which it's common practice to do a null check
21:25:49 <fresheyeball> is not a language with a type system worthy of serious consideration
21:26:45 <fresheyeball> boogalooga: for your pleasure https://dev.to/rosstate/java-is-unsound-the-industry-perspective
21:27:40 <boogalooga> what's your favourite programming language
21:27:40 <boogalooga> ?
21:28:03 <c_wraith> I mean..  Haskell's type system is also unsound.  
21:28:12 <fresheyeball> boogalooga: I like the whole ML family of languages
21:28:20 <fresheyeball> c_wraith: because of bottom?
21:28:34 <fresheyeball> boogalooga: Haskell, PureScript, Elm, Idris, right now for me
21:28:41 <c_wraith> That's one way, yes.
21:28:44 <fresheyeball> I'm poking at Mercury
21:28:48 <c_wraith> There are others, when you start enabling extensions.
21:29:05 <fresheyeball> c_wraith: that and Incoherent Instances
21:29:11 <fresheyeball> but that's it as far as I know
21:29:26 <c_wraith> TypeInType lets you encode Girard's Paradox in the type system
21:29:38 <fresheyeball> c_wraith: I did not know that!
21:31:11 <fresheyeball> I don't know of any type system that is wholey sound, nor would I want to work in one
21:31:40 <fresheyeball> but I think there is a differnce between unsoundness that is isolated and can be reasoned about, because the system is largely sound
21:31:44 <Cale> fresheyeball: Coq and Agda try to be
21:32:14 <fresheyeball> and a type system like Python's which is so widely unsound, you actually have to do a null check on every argument of every function, to approach totality
21:32:22 <fresheyeball> Cale: I should learn those
21:32:47 <fresheyeball> Cale: which would you recommend actually? Coq or Agda? What has more real world application?
21:33:43 <Cale> If you're going to learn one, learn both. There are few enough resources on dependently typed languages, and despite the syntax of the languages being quite different, the ideas translate fairly straightforwardly.
21:34:18 <fresheyeball> Cale: well shoot. I have many many more years of learning ahead of me. And that's a great feeling.
21:34:18 <Cale> Coq has been used more in the real world, but that's mainly because it's older, I think.
21:34:42 <Cale> Neither is particularly easy to put to use for real world stuff, but it can be done.
21:36:35 * hackagebot accelerate-llvm-native 1.1.0.1 – Accelerate backend for multicore CPUs – https://hackage.haskell.org/package/accelerate-llvm-native
21:37:49 <fresheyeball> Cale: why not Idris?
21:38:13 <c_wraith> Idris is designed as a language for actually programming.
21:38:27 <c_wraith> Coq and Agda can be used for programming, but it's not their primary purpose.
21:38:33 <koz_> What is Fokkinga's prepromorphism meant to do?
21:38:35 <koz_> I'm looking at its type here: https://hackage.haskell.org/package/recursion-schemes-5.0.2/docs/Data-Functor-Foldable.html#v:prepro
21:38:36 <koz_> And I have no clue what it's trying to say.
21:38:42 <c_wraith> Their primary purpose is writing proofs
21:42:32 <iqubic> glguy: Are you around?
21:43:40 <nshepperd> haskell's type system is unsound, but in a way that doesn't generate unsafeCoerce (there might be a way if you enable some extension though)
21:44:01 <iqubic> Good Morning everyone.
21:44:02 <nshepperd> java's type system also doesn't generate unsafeCoerce but for a different reason
21:44:15 <iqubic> Java's type system is a mess.
21:44:36 <iqubic> It's so bad that the instanceof keyword is a thing.
21:45:17 <nshepperd> (because they added dynamic type checks to make mutable arrays + subtyping work iirc)
21:51:49 * hackagebot hw-kafka-client 2.0.1 – Kafka bindings for Haskell – https://hackage.haskell.org/package/hw-kafka-client
21:54:29 <DigitalKiwi> glguy I have no idea who this person is asking for you it isn't me 
22:18:10 * hackagebot ghc-events 0.7.0 – Library and tool for parsing .eventlog files from GHC – https://hackage.haskell.org/package/ghc-events
22:43:00 * hackagebot aivika-distributed 0.7.4.2 – Parallel distributed discrete event simulation module for the Aivika library – https://hackage.haskell.org/package/aivika-distributed
22:45:18 <Guest8285> Does `stack` not work with extra-deps declared? I get a `cannot satisfy -package unagi-chan-0.4.0.0` message with my extra-dep `unagi-chan` declared in `stack.yml`
22:48:20 <ski> platz : "I have an existential in a record." -- no, you had a universal in a record. completely different thing
22:58:09 <koz_> Could someone help me write the ConjF and DisjF cases of restrict's F-algebra in a less awful way? http://ix.io/AJa
23:12:36 <moet> under what circumstances does haskell stack decide to update the package index?
23:13:21 <dmwit> That sounds like a loaded question.
23:14:03 <dmwit> Having never used stack but being aware of the concept, I'm a bit surprised it ever updates the package index.
23:14:15 <dmwit> I thought the whole deal with resolvers was that they were a completely frozen package set.
23:15:11 <moet> dmwit: perhaps it's a loaded question
23:15:30 <moet> i'm trying to ask it in a way that i'll learn, rather than have it sound like a critique
23:16:45 <moet> because i was also under the impression that if i compiled at home on wifi, i wouldn't need network to continue working on my project later
23:16:59 <moet> perhaps an incorrect assuption
23:17:17 <dmwit> Well. That should be basically true, unless you add new dependencies.
23:17:51 <moet> i didn't, hence the question
23:18:14 <moet> clearly my understanding of stack is lacking
23:18:21 <dmwit> In the future, the standard "good question" format is, "I did X, expecting Y to happen, but Z happened instead".
23:18:38 <moet> ah, thank you for that recommendation
23:18:48 <dmwit> So far you've grudgingly admitted what Y was, and given a sort of vague description of X, but Z is forthcoming.
23:18:57 <moet> i'll try again
23:19:03 <dmwit> What exact command did you run while offline? What exact error did you get?
23:20:02 <dmwit> ?lpaste if the error is more than a line or two long
23:20:02 <lambdabot> Haskell pastebin: http://lpaste.net/
23:20:41 <moet> i did `nice env TMPDIR=~/tmp/ stack build -j1` once while at home, and once now while on a tethered connection.. i expected that running it now again wouldn't result in any use of the network, but instead package index was updated prior to one dependency being recompiled
23:21:15 <moet> i guess i should also include in Y: i didn't expect any dependencies to be recompiled
23:21:29 <MasseR> do you have external-deps?
23:21:54 <moet> i have one `extra-dep`
23:22:14 <MasseR> I noticed with my CI that they get cached to the project directory so a new git clone always compiles the extra-deps again and again
23:22:40 <moet> this is the same git clone directory as i built in at home a few hours ago
23:24:22 <Profpatsch> Stuffz
23:24:52 <Profpatsch> data Resolved a = Resolved { hash :: Text, resolved :: a } deriving (Functor)
23:24:53 <dmwit> Is it possible that stack is attempting to check that it has the latest version of your extra-dep?
23:25:09 <Profpatsch> data Remote = Git | File
23:25:26 <Profpatsch> data Package = { …, remote :: Remote }
23:25:42 <dmwit> Profpatsch: Please use a pastebin rather than pasting multiline code snippets in-channel.
23:25:46 <dmwit> ?lpaste for example
23:25:46 <lambdabot> Haskell pastebin: http://lpaste.net/
23:26:08 <Profpatsch> So, I’ve got a function [Package] -> Resolved [Package]
23:26:41 <Profpatsch> And the Remote kind of determines the hash.
23:26:56 <Profpatsch> So if the remote is Git, the hash will be a sha256
23:27:04 <Profpatsch> And if it’s File it will be a sha1
23:27:31 <moet> dmwit: the extra-dep is pinned to a version
23:27:45 <dmwit> I agree that behavior is strange!
23:27:53 <moet> heh
23:27:53 <dmwit> Nothing else changed in between compilations?
23:28:11 <Profpatsch> Now, I’d like to promote that information to the type level, so a (Resolved Package) carries the information that it’s a sha256 if it’s a git Remote.
23:28:39 <moet> i am on nixos, and have `nix: enable: true` set in ~/.stack/config.yaml
23:28:44 <opqdonut> Profpatsch: then you need Package to have the information on the type level too
23:28:59 <opqdonut> Profpatsch: ... unless you want to play around with haskell's dependent typing
23:29:01 <moet> i have a poor knowledge of nixos, so i don't doubt that it somehow triggered stack to rebuild things
23:29:24 <moet> but perhaps this is just poor knowledge talking, and not evidence of anything
23:29:43 <Profpatsch> If I change the hash Accessor of Resolved to hash :: (Text, Remote) for example, I will aways have to do an additional partial pattern match.
23:31:02 <Profpatsch> opqdonut: Package is taken from a module of another package.
23:32:06 <moet> in any case, the project compiled now and i need to shut off wifi. i appreciate your willingness to help despite my tone, dmwit, thank you
23:33:29 <Profpatsch> Hm, maybe I can just assume it on the value level.
23:34:32 <Profpatsch> I mean, I have to pattern match on the Remote anyway eventually, that’s also when I transform the hash to textual information.
23:35:06 <Profpatsch> It’s all about keeping information as local as possible after all.
23:40:26 <Profpatsch> Idea: the quality of software is largely determined by how local it keeps needed contextual information in every part of its code.
23:42:19 * hackagebot colorless 2.2.1 – Colorless – https://hackage.haskell.org/package/colorless
23:47:31 <pimlu> is there a general set of rules to know when haskell will recompute an expression if it occurs again?
23:47:40 <pimlu> this might be a question specific to GHC
23:48:53 <pimlu> for example, you might have funcUsedInsideMap x = Set.union x $ expensiveFunc y
23:48:54 <dmwit> Generally: names are the way to declare that you want a computation stored for reuse.
23:49:00 <pimlu> okay, exactly
23:49:14 <pimlu> I was wondering if I needed to bind expensiveFunc y to a where to be efficient
23:49:30 <c_wraith> GHC does a very, very small amount of automatic sharing of expressions
23:49:43 <c_wraith> And as little as it does, it still gets it spectacularly wrong sometimes
23:49:47 <dmwit> Yes. And you also probably want to bind it *outside* the lambda if `y` doesn't depend on `x`.
23:49:51 <pimlu> yeah
23:50:08 <dmwit> e.g. `funcUsedInsideMap = let blah = expensiveFunc y in \x -> Set.union x blah`
23:50:09 <pimlu> (meant to say "the" where)
23:50:27 <pimlu> because funcUsedInsideMap is one of a bunch of bindings in a where currently
23:50:29 <cocreature> the problem with doing common subexpression elimination automatically is that you can easily end up with spaceleaks where you keep things around longer than you expect them to
23:50:55 <c_wraith> GHC has an optimization called the full laziness transformation.
23:50:56 <Profpatsch> pimlu: are you a feather?
23:51:10 <pimlu> haha that's the first mention I've gotten outside the native channels
23:51:17 <Profpatsch> :)
23:51:22 <dmwit> (*Probably* optimizations will turn `funcUsedInsideMap x = Set.union x blah where blah = expensiveFunc y` into that. But I don't have much trust. =P)
23:51:23 <pimlu> used to practice it regularly
23:51:40 <c_wraith> If you search for people talking about that, almost every hit is going to be explanations that the terrible memory use problem someone is having is because the full laziness transformation broke. :)
23:51:41 <Profpatsch> It’s hard to not recognize gismu when you see them.
23:51:41 <cocreature> e.g. "(sum [1..1000000], product [1..1000000])". if you apply CSE you can’t GC the list because you need it for the evaluation of the other expression
23:52:14 <cocreature> so you turn something with constant space usage (assuming optimizations kick in) into something with linear space usage
23:52:36 <Profpatsch> Especially when they’re one of maybe 2% of the ones that Anki has already presented me.
23:54:05 <pimlu> yeah, I would rather the storage be predictable I guess
23:54:35 <pimlu> Profpatsch: yeah, there's a regular named vendu in ##programming but it's a coincidence I think lol
23:54:51 <cocreature> but c_wraith is right that full-laziness can still bite you and the annoying part is that there is no good way to prevent sharing in that case
23:55:48 <cocreature> some people have been advocating for disabling full-laziness altogether unless you explicitely enable it
23:56:42 <pimlu> I see
23:58:05 <cocreature> pimlu: if you’re interested, https://www.well-typed.com/blog/2016/09/sharing-conduit/ describes one of those cases
23:59:53 <tdammers> IMO the 'should we disable full laziness' / 'how useful is non-strict evaluation, anyway' discussion is a bit biased due to the fact that a disproportionate part of the community is doing rather nonstandard work in Haskell
23:59:54 <pimlu> wow, that's scary lol
