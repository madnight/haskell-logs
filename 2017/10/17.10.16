00:00:29 <srhb> woodson: You need to have a new data constructor if you want the types to be distinct, eg data B = B A
00:02:37 <woodson> srhb: so data B = B :: A?
00:02:47 <mauke> no, data B = B A
00:03:18 <woodson> mauke: thank you
00:05:41 <jle`> woodson: this is no different than, say, data B = B String
00:08:26 <jle`> (like your data A example)
00:15:19 <[exa]> ongy: class-membership predicates were once allowed for `data` but not sure how it's working now
00:19:45 <Gurkenglas> What lens oneliner runs across all entries of a map, perhaps deleting them? It's not a Traversal because of the possible deletions.
00:20:14 <Gurkenglas> "Complete the rectangle ix-each-at"
00:32:49 * hackagebot push-notify-apn 0.1.0.5 – Send push notifications to mobile iOS devices – https://hackage.haskell.org/package/push-notify-apn
00:33:10 <geekosaur> it's still possible to turn contexts in data declarations back on, but they still don't do what people expect (they only apply during construction)
00:34:05 <ertes-w> hllo
00:41:07 <srhb> ixxi
00:41:09 <srhb> Woops
00:45:14 <Gurkenglas> Might "l %~ fmap f" be faster than "l . traverse %~ f"?
00:52:52 <ertes-w> Gurkenglas: yes
00:53:58 <ertes-w> Gurkenglas: the latter is pretty much implementing 'fmap' in terms of 'traverse', so you rely on specialisation and potentially on rewriting optimisations to get the same performance
00:54:46 <Gurkenglas> Do those work for Map?
00:54:47 <saurabhnanda> is there any way to *prevent* GHCi from listing all known/loaded modules at the end of every ':l' -- my module is loading 500+ modules and the output is pretty meaningless for me, and makes discovery of compile errors irritating.
00:55:30 <cocreature> saurabhnanda: iirc GHC 8.2 hides the by default and only displays the number of loaded modules but I’m not sure if there is a way to get this behavior for older versions
00:56:58 <ij> Can nix do all the things stack did?
00:58:37 <Gurkenglas> Is Map k (Map j v) gonna be faster/smaller than Map (k,j) v and is there a third option with the second's logistical benefits?
01:00:55 <ij> Maybe some hashmap?
01:00:56 <geekosaur> the first part of that is going to depend on the data and how you use it
01:07:27 <ertes-w> ij: nix is not as portable as stack
01:07:42 <ertes-w> you won't be deploying to windows using nix
01:08:03 <ertes-w> ij: other than that i think it does everything
01:09:03 * hackagebot partial-semigroup 0.0.0.1 – A partial binary associative operator – https://hackage.haskell.org/package/partial-semigroup
01:10:13 <cocreature> nix also doesn’t do incremental builds. you’ll need to use cabal for that and if you have multi-package projects, cabal new-build which can be a bit rough around the edges
01:10:44 <ij> I was wondering about incremental builds.
01:11:12 <cocreature> ij: basically for development, you’ll be using nix to build your deps and then use cabal to build your project in a nix-shell
01:13:27 <cocreature> ij: for most usecases cabal new-build works just fine these days. I’m using it in combination with nix to build multi-package projects and it’s working great
01:14:05 <merijn> cocreature: Unless you want to rebuild your documentation :p
01:14:18 <cocreature> merijn: sometimes it works :)
01:18:34 <ertes-w> you need to combine nix and cabal (the library!) in order for incremental builds to work
01:20:36 <ertes-w> whenever this is necessary (e.g. to benchmark my code) i use a Makefile that, in a nix-shell, builds Setup, then uses './Setup configure' and './Setup build'
01:22:15 <ertes-w> (building Setup is not strictly necessary, but runghc needs a long time to boot, so compiling Setup gives an extra boost in iteration rate)
01:26:22 <merijn> ertes-w: new-build itself works fine for me
01:26:37 <merijn> cocreature: It works the first time you run new-build or new-haddock without dist-newstyle existing
01:26:56 <merijn> cocreature: new-build is a little...over-enthusiastic about caching haddock results :p
01:28:01 <dfsafd> how would you create a type alias like this: type DistanceMatrix = [(Tree a, Tree a, Double)] ?
01:31:08 <phadej> dfsafd: either `type DistanceMatrix a = ...` or `type DistanceMatrix = forall a. ...`
01:32:25 <dfsafd> thanks
01:33:32 <Gurkenglas> What lens oneliner lets me write "get >>= traverse (\x -> ...)" without brackets?
01:33:42 <ertes-w> merijn: i was answering to ij
01:46:26 <merijn> ok...I'm confused
01:46:52 <merijn> cabal finds an install plan on Travis, but GHC crashes partway through the tests
01:47:23 <merijn> So I decide to try and replicate this myself. Download the right GHC version, update cabal, run new-build locally...no install plan...huh?
01:47:40 <merijn> oh!
01:47:48 <merijn> Think I got the culprit
01:48:22 <merijn> Forgot about a flag in cabal.project.local >.>
01:51:17 <merijn> And of course I can't reproduce locally due to unix (of all package?!) not building right...
01:55:42 <ij> Are there tools that manage imports? Suppose I move a function and there are now unnecessary and missing imports now.
01:56:28 <ertes-w> ij: copy all imports, then remove all unused imports GHC warns about =)
01:56:32 <MarcelineVQ> ij: if you make one you'll be a hero
01:56:48 <ggVGc> is there a way to get 'stack test' to run faster?
01:56:55 <liste> refactoring tools for Haskell would be so great
01:56:57 <MarcelineVQ> People also desire a too, to split off modules to new packages and other sort of things
01:57:18 <ij> So there are none now? :(
01:57:58 <MarcelineVQ> dunno, there's a lot of things hiding on hackage, if you find one though be sure to mention it
01:58:23 <ertes-w> haskell-mode has some very limited refactoring capabilities, but i haven't used them
01:58:35 <ertes-w> it's mostly about removing unneeded stuff though
02:00:29 <cocreature> ggVGc: depends on what’s causing it to be slow. you can use "stack test --fast" to build without optimizations which can help quite a bit
02:00:41 <cocreature> but if the bottleneck is the runtime of your tests and not the build time then that will slow things down
02:01:42 <tdammers> a good first step would be a whitespace- and comment-preserving parser for GHC Haskell
02:01:54 <cocreature> tdammers: ghc-exactprint?
02:02:01 <merijn> ...
02:02:02 <tdammers> cocreature: oh, so it exists?
02:02:10 <cocreature> tdammers: well it’s basically GHC itself
02:02:21 <cocreature> ghc-exactprint just uses the ghc API to render the original source
02:02:35 <cocreature> but GHC’s parser preserves whitespace and comments
02:02:45 <tdammers> right, yes, that's true
02:02:48 <merijn> Ok, so anyone care to place a guess why the fuck "cabal new-build" on unix works, but installing results in an error?
02:05:50 <ij> tdammers, Could the (comment|whitespace)-preserving parser be called a concrete syntax tree parser?
02:08:41 <tdammers> ij, I guess... the important thing is that it has to be round-trippable
02:09:32 <merijn> wow...
02:09:59 <merijn> who decided that renaming the capi pragma was a great idea?! >.<
02:11:45 <ij> there's this https://github.com/RefactoringTools/HaRe, but I've yet to figure out what it's capable of
02:15:02 <ij> exactprint's made but the same alanz that made this ^
02:15:17 <ij> hehe, he's also here.
02:15:28 <alanz> did someone call my name?
02:15:58 <alanz> FWIW, I want to eventually move ghc-exactprint into GHC
02:16:08 <ij> I was wondering about import refactoring, does hare help?
02:16:18 <alanz> Not at this stage
02:16:44 <alanz> I got side-tracked into supporting ecosystem for HaRe, have lost momentum on it.
02:17:17 <ij> Does it have docs? I took a look a the github page and the cs.kent page and wasn't sure what it really can od.
02:19:10 <alanz> ij, not really
02:19:38 <alanz> but if you install it and go ghc-hare --help it will list the refactorings it can do
02:19:55 <alanz> I guess I need to go back and update the basics
02:19:56 <ij> well, that also counts
02:20:53 <merijn> Lesson learned: Testing stuff with older GHCs is a great of finding a billion packages with completely wrong dependency bounds...
02:23:06 <cocreature> merijn: why do you even go through the trouble of testing with anything more than the last three releases of GHC? I thought it was well-established practise to support only those releases
02:24:50 <merijn> cocreature: Well, it was trivial to support a huge range of GHC. Then I added some extra stuff and tests and was trying to make those work with the same range, got most of it working now, but the last broken build is being fucked over by everyone lying about their dependency bounds
02:25:11 <merijn> cocreature: And now I'm just annoyed, not from a dev perspective, but from a software conservation perspective
02:29:39 <tdammers> software conservation is a seriously underrated concern these days if you ask me
02:34:06 <merijn> tdammers: Word
02:35:15 <merijn> tdammers: Sometimes I think about not going into programming at all after finishing my phd and just going into either politics or software conservation (or, maybe combine both :p)
02:35:42 <tdammers> politics, ugh...
02:36:03 <tdammers> I don't think I'd have the moral flexibility for that
02:36:04 <merijn> tdammers: Well, someone has to stop these morons repeatedly trying dumb shit when it comes to technology
02:42:11 <ertes-w> one of the things i appreciate about nix is that i can go back to an older commit of nixpkgs, and usually it will just work…  it may require some tweaking in some cases though, mostly because some… people like to update uploaded files in place
02:45:30 <maerwald> nix?
02:46:28 <ij> nix, the package manager
02:46:35 <merijn> ok, so style question: conditional imports (i.e. CPP around dependency versions) all in a single block at the top or intermixed with regular imports (i.e. if you sort them alphabetically)
02:46:37 <maerwald> yeah, wrong channel maybe
02:49:30 <mauke> merijn: when/how was the capi pragma renamed?
02:49:53 <merijn> mauke: Naah, turns out that was a development branch of GHC and I was just mixxing up errors
03:03:01 <kahlil29> I have a value that is of type `IO String`.(Value is obtained via a 3rd party library : https://hackage.haskell.org/package/friendly-time-0.4.1/docs/Data-Time-Format-Human.html). The returned value is being passed to a function of type Html(). I cannot access the String inside. Any way to do this? I've tried liftIO and lift but both do not help me here.
03:03:23 <jle`> kahlil29: there is no String inside an IO String
03:03:42 <dfsafd> when pattern matching tuples, can you refer both to the unpacked values and the packed tuple?
03:03:42 <jle`> also, 'Html ()' is not the type of a function, so I'm not really sure what you are asking
03:03:57 <jle`> dfsafd: yup, look uo 'as patterns' :)
03:04:01 <kahlil29> Html() is the return type of my function 
03:04:10 <dfsafd> e.g somefunc (a, b) = ... how do i "get at" the whole (a, b)
03:04:31 <jle`> dfsafd: someFunc c@(a,b) = ...
03:04:36 <jle`> kahlil29: ah, that makes more sense
03:04:43 <dfsafd> awesome
03:04:45 <jle`> kahlil29: but yes, an IO String does not contain any strings inside it
03:05:26 <jle`> kahlil29: 'IO String' is the type of an IO action that, when executed, will produce a String
03:05:35 <kahlil29> for e.g. If my function return type was an instance of MonadIO, I would be able to get that string by using a bind operation right? <- 
03:06:01 <jle`> well you can use bind to sequence actions
03:06:22 <jle`> and refer the results of previous IO actions to create new ones
03:06:41 <jle`> and if Html is a MonadIO, that means that you have an IO String -> Html String function
03:07:16 <jle`> so you can use it as if it were any other Html 'action'
03:07:48 <jle`> sequence it in do notation, etc.
03:08:20 <jle`> if you gave more specific details we could probably offer more helpful advice
03:09:21 <chpatrick> do you know a good way to prevent the let-floating of an unsafePerformIO?
03:09:43 <chpatrick> if the call site is built with -fno-full-laziness then it's OK but I would like it to work in any case
03:11:00 <chpatrick> somehow I would like that expression to be re-evaluated every time it's needed
03:11:11 <chpatrick> oneShot seems related but I couldn't figure it out
03:11:25 <kahlil29> okay so to be more specific. Can I create a MonadIO instance for Identity ? https://hackage.haskell.org/package/base-4.9.1.0/docs/Data-Functor-Identity.html#t:Identity
03:11:53 <jle`> kahlil29: there is no MonadIO instance for Identity
03:12:02 <jle`> since Identity can't sequence arbitrary IO actions
03:12:16 <jle`> chpatrick: have you had any luck with {-# INLINE #-} ?
03:12:25 <jle`> oh, wait, misread your question
03:12:55 <jle`> kahlil29: MonadIO is the typeclass of things that can "perform" or sequence IO actions
03:13:04 <jle`> but Identity is definitely not one of those things
03:13:39 <jle`> kahlil29: what is Html?
03:14:03 <kahlil29> type Html = HtmlT Identity
03:14:07 <jle`> what is HtmlT ?
03:14:11 <kahlil29> https://hackage.haskell.org/package/lucid-2.9.9/docs/Lucid-Base.html#t:HtmlT
03:14:17 <kahlil29> part of the Lucid package
03:14:27 <jle`> ah so it describes HTML
03:14:57 <jle`> well HtmlT IO is a MonadIO, so you could probably sequence that
03:15:22 <jle`> but probably if you want to use the result of an IO action to make an Html, you probably actually want an IO action to create an Html
03:15:38 <jle`> you might be really looking for an IO (Html ())  -- an IO action that, when executed, produces an Html ()
03:16:03 <jle`> and if you had a (f :: String -> Html ()) function, and an IO String, you can just `fmap f`
03:16:09 <jle`> to get an IO (Html ())
03:16:17 <jle`> it depends on what you really want in the end, though
03:20:51 <jle`> an IO (Html ()) is an IO action that, when executed, produces an Html (); an HtmlT IO () describes HTML that uses IO to produce the resulting HTML
03:21:19 <foojin> Hi everyone. I have a Haskell program (which depends on mtl) with a Makefile and an extracted directory tree of haskell-mtl package from my distro's repo (*.a, *.so and *.hi files).
03:21:24 <foojin> How can I tweak the GHC invocation in the Makefile to make it find this particular mtl and compile the program?
03:21:27 <foojin> Using -i/[...]/ghc-7.10.3/site-local/mtl-2.2.1 makes it search for *.hs and *.lhs sources there and ignore *.hi files with the same name.
03:27:29 <lyxia> foojin: how about -L
03:31:38 <foojin> lyxia: Same thing, "Could not find module ‘Control.Monad.State’". According to -v it only checks for .hs, .lhs, .hsig and .lhsig.
03:41:02 <chpatrick> foojin: how come you're using a Makefile and not cabal/stack/nix?
03:45:27 <foojin> chpatrick: It's not mine, I just want to edit it slightly and recompile it. Supposedly its author didn't want to use other build tools for some reason.
03:49:40 <chpatrick> foojin: it might be easier to give it a cabal file anyway
03:53:28 <dfsafd> what do you need for a custom data type to be used as a key in a map?
03:53:54 <merijn> dfsafd: Instance of Ord
03:55:16 <dfsafd> how annoying. i just want the map to hash based on the contents
03:56:37 <Eduard_Munteanu> dfsafd, there's HashMap for that
03:57:16 <dfsafd> Deprecated: HashMap is deprecated. Please use Map instead.
03:57:46 <merijn> dfsafd: Why do you want it to be based on a hash of the contents?
03:58:07 <niklasb> dfsafd: the one from unordered-containers
03:58:07 <merijn> dfsafd: Also, how is HashMap deprecated?
03:58:20 <dfsafd> merijn: https://hackage.haskell.org/package/hashmap-1.3.2/docs/Data-HashMap.html
03:58:38 <merijn> oh, never seen that package, everyone is referring to unordered-containers
03:58:38 <niklasb> dfsafd: you are looking for Data.HashMap.Stricy/Lazy from unordered-containers
03:58:42 <Eduard_Munteanu> There's another one in https://hackage.haskell.org/package/unordered-containers
03:58:51 <niklasb> *Strict
03:58:58 <dfsafd> lol
03:59:06 <merijn> Incidentally, the hashmap package explicitly refers to unorded-containers
03:59:15 <merijn> First line in the docs: "Deprecated. in favor of unordered-containers"
04:00:14 <tdammers> on a side note, does anyone else consider the way Data.Map modules are ordered wrt strictness somewhat misleading?
04:00:32 <tdammers> particularly, Data.Map.Strict.Map and Data.Map.Lazy.Map being the exact same type?
04:01:09 <merijn> tdammers: What's the issue?
04:01:25 <niklasb> dfsafd: also, you might enjoy hashable-generics
04:01:25 <Eduard_Munteanu> Well, they do say it's value, not key strictness
04:01:55 <tdammers> well, they're the same type, and whether they follow strict semantics or not depends on the functions you call on them, not the types themselves
04:01:57 <merijn> Eduard_Munteanu: Because for a sensible map strictness of the key is obviously required?
04:02:05 <Eduard_Munteanu> Yeah.
04:02:18 <merijn> tdammers: That actually seems like a great feature to me, tbh
04:02:33 <Eduard_Munteanu> Hm.
04:02:34 <merijn> tdammers: I can strictly build a map and then pass it to any code that was written for a lazy Map
04:02:37 <tdammers> merijn: that may be so, but the way things are presented makes it not very obvious
04:02:48 <merijn> tdammers: None of the painful conversion issues with Text/ByteString?
04:02:53 <merijn> tdammers: How so?
04:03:30 <tdammers> merijn: a superficial look at the module documentation suggests that there are two map types, both offering the same (but distinct) API through the module that defines them
04:03:39 <merijn> tdammers: It's like literally the 3rd sentence in the documentation?
04:05:36 <tdammers> merijn: http://hackage.haskell.org/package/containers-0.5.10.2/docs/Data-Map.html where?
04:06:03 <tdammers> oh, I see, it's here: http://hackage.haskell.org/package/containers-0.5.10.2/docs/Data-Map-Strict.html
04:06:14 <merijn> tdammers: I was looking at the Lazy/Strict modules
04:06:19 <tdammers> yeah, figured
04:06:33 <tdammers> it doesn't say so in the most likely module people will be looking at first, Data.Map
04:06:51 <merijn> tdammers: Yeah, so that line should probably be copied to that module's docs too
04:07:36 <tdammers> it's probably too late for that now, but IMO a better layout would have been to have one module defining just the type and the operations that are the same regardless of strictness, and then two additional modules with the strict and lazy APIs
04:07:49 <tdammers> possibly re-exporting the shared stuff
04:11:27 <merijn> tdammers: Well, try and upstream a patch! ;)
04:11:54 <tdammers> meh
04:12:02 <tdammers> I said it's too late for that now, didn't I
04:12:37 <merijn> It is with that attitude! ;)
04:13:37 * hackagebot data-diverse 1.2.0.2 – Extensible records and polymorphic variants. – https://hackage.haskell.org/package/data-diverse
04:16:03 <exio4> offtopic, relying it here if anybody cares https://www.krackattacks.com/
04:25:40 <stellis[m]> it seems to me many monad transformers could have a function `t m a -> m (t Identity a)` - MaybeT for example - is there a library for something like this?
04:27:24 <merijn> stellis[m]: No, you definitelly can't do that
04:27:41 <merijn> stellis[m]: Because the behaviour of a monad stack is order dependent
04:28:22 <merijn> stellis[m]: For example (StateT s (ExceptT e m) a) and (ExcepT e (StateT s m) a) do different things
04:28:54 <merijn> stellis[m]: For generalising/mapping over internal transformers/monads there is:
04:28:58 <merijn> @hackage mmorph
04:28:58 <lambdabot> http://hackage.haskell.org/package/mmorph
04:29:59 <raynold> ahh it's a wonderful day
04:32:06 <stellis[m]> merijn: thanks, that makes sense
04:33:40 <merijn> stellis[m]: Note that mmorph can take, for example "t m a" and turn the 'm' into another transformer
04:36:15 <mivael_> hi all
04:40:17 <mivael_> Is there a known service with searchable logs of this channel?
04:40:50 <hpc> see the topic
04:41:23 <stellis[m]> merijn: I had looked at mmorph, but I don't think it helps me - my problem is that I have a bunch of monad stacks and in each, somewhere, there is an error logging transformer. And when run all of them I need to unwrap each of them, but not the error logger. So I thought I could make embedding results of stacks with error logging into other stacks with error logging a bit nicer
04:42:15 <mivael_> hpc: tunes.org you mean?
04:43:14 <hpc> yeah, you can download the full logs and search them with grep or similar
04:45:09 <mivael_> hpc: you mean to download them, one by one, manually or by using an ad hoc script?
04:47:32 <hpc> hmm, i thought rsync would work :(
04:49:10 * hackagebot follow-file 0.0.2 – Be notified when a file gets appended, solely with what was added. – https://hackage.haskell.org/package/follow-file
04:49:21 <mivael_> Is it known why the #haskell channel logs can not be searched through using a web search engine?
04:51:18 <roi_du_silence> is there a way to separate a module into twofiles ?
04:51:29 <merijn> roi_du_silence: No
04:51:44 <fakenullie> why not
04:51:50 <fakenullie> reimport from the other module
04:52:41 <roi_du_silence> Can't
04:52:53 <fakenullie> ?
04:53:00 <roi_du_silence> thanks merijn
04:54:22 <roi_du_silence> I would have two interdependent modules fakenullie
04:57:18 <kahlil29> is there any way to get the system time as UTCTime without the wrapping IO Monad? 
04:57:41 <mivael_> hpc: The topic is probably outdated: specifically, ?C=M;O=D part is actually ignored at http://tunes.org/~nef/logs/haskell/
04:57:51 <mivael_> (or maybe I used it wrong?)
04:58:01 <dfsafd> how should you implement the Ord interface for a tree data type?
04:58:25 <merijn> kahlil29: No
04:58:33 <merijn> kahlil29: Because that's inherently IO
04:58:45 <mauke> mivael_: it's not ignored
05:00:37 <mivael_> mauke: I see just a list of a directory, regardless of what parameters I use after the '?' character.
05:01:27 <mauke> mivael_: ok?
05:02:06 <mivael_> mauke: I do not understand.
05:03:01 <mivael_> mauke: You are saying they are not ignored.  So how the parameters influence the result I have?
05:03:36 <mauke> they affect the sort order
05:03:50 <mivael_> oh
05:04:13 <mivael_> is it documented somewhere?  (possible parameters)
05:04:29 <mauke> probably in some apache module
05:04:40 <mauke> but they're linked on the page itself (the column headers)
05:05:07 <mauke> presumably C=M;O=D means compare modification time, in descending order
05:05:12 <mivael_> mauke: understood, thank you
05:06:35 <mivael_> Still... why we can not (can we?) do web search through channel logs?
05:08:08 <ahihi> because this site has "Disallow: /~nef/logs/" in its robots.txt
05:10:40 <mivael_> ahihi: I mean, is it intentional?
05:10:49 <ahihi> you'd have to ask whoever runs the site
05:11:21 <mivael_> ahihi: I just hoped someone here knows the answer :)
05:15:41 <Ferdirand> i'm confused about how to use KnownNat
05:15:54 <Ferdirand> natVal :: forall n proxy. KnownNat n => proxy n -> Integer  (with n :: Nat)
05:16:17 <Ferdirand> but Proxy is defined as Proxy (t :: *) so ghc throws me a kind error
05:16:45 <Ferdirand> is there a standard NatProxy type defined somewhere ? data NatProxy (n :: Nat) = NatProxy ? 
05:17:20 <merijn> Ferdirand: Note that "proxy" is a type variable, not a type constructor from Proxy
05:17:54 <merijn> Ferdirand: Also, Proxy is polykinded in recent GHCs
05:18:09 <merijn> Ferdirand: Which GHC are you using/is PolyKinds enabled?
05:26:59 <ocramz> hullo all!
05:27:24 <ocramz> is anybody planning to go to the 2018 Haskell Exchange? 
05:28:11 <Geekingfrog> yeah, got my ticket already.
05:28:25 <ocramz> I've never been there but I've attended ICFP this year; I believe it's less formal than a conference?
05:28:39 <Ferdirand> merijn: 7.10.3, polykinds enabled, and yes i noticed it was a type variable
05:28:51 <Ferdirand> so i defined my own NatProxy but it felt not right
05:30:01 <Ferdirand> ah hold on i had a typo in my PolyKinds directive
05:30:27 <Ferdirand> it works, thanks
05:31:42 <merijn> What's the opposite of a prelude? (i.e. if a prelude comes before something, what comes after?)
05:32:31 <mauke> a lude?
05:32:57 <liste> postlude
05:33:01 <Ferdirand> epilog ?
05:33:06 <ahihi> fugue
05:33:17 <liste> yeah, epilogue would make sense
05:34:00 <merijn> epilogue/postlude, apparently
05:34:05 <merijn> Although postlude sounds dumb
05:34:11 <Ferdirand> so, epilog, e^pi . log
05:34:34 <Ferdirand> so just pi
05:41:39 <merijn> Any people here using multi-ghc-travis that are willing to act as guinea pigs? (especially people testing multiple stack resolvers)
05:44:11 <ij> Does the unix kind of "tr" exist for `String`s?
05:50:22 <merijn> ij: Isn't that just map + replace function?
05:50:26 <ij> Yeah.
05:51:17 <ij> I could make the replace via a map ((<>) =<< lookup map).
05:51:34 <ij> By map I mean Map or something lookup-able
05:52:28 <ocramz> merijn : I usually test my stuff against a couple of stackage lts and nightly; I'm not really optimizing for backwards compatibility or wide coverage though
05:52:49 <merijn> ocramz: Are you using the multi-ghc-travis script?
05:52:55 <ij> Hm, there was some monoid that chose the first one.
05:53:05 <merijn> (or did you use it to generate your initial .travis.yml)
05:53:15 <ocramz> no, not yet. I rely on stack templates for that
05:53:19 <ocramz> and change by hand
05:53:57 <merijn> ocramz: I'm looking for people to check that I didn't break that script for their setup/that my changes work for others too :)
05:53:57 <ij> First was the monoid.
06:11:20 <Ferdirand> is there a way to specify a constraint for an associated type ?
06:13:17 <lyxia> class (C (CType a)) => C a where type CType a    ?
06:14:12 <Ferdirand> lyxia: huh 
06:14:15 <Ferdirand> thanks
06:14:32 <Ferdirand> didn't expect that the context of the class head could reference the body
06:15:02 <akem> test
06:36:14 * hackagebot docker 0.4.1.1 – An API client for docker written in Haskell – https://hackage.haskell.org/package/docker
06:40:55 <merijn> Ferdirand: Ah
06:41:08 <merijn> Ferdirand: Associated type families are just convenient syntax for regular type families
06:41:19 <merijn> Ferdirand: They are not in any way scoped to a specific instance
06:46:08 <hexagoxel> emulating dynamics in reactive-banana is rather annoying.. i am not even sure anymore if translating a reflex network into a reactive-banana one is possible without a non-constant factor to code size.
07:02:36 <ertes-w> hexagoxel: reflex' API is more flexible than r-b's…  if you use that extra flexibility, you will not be happy translating
07:02:47 <ertes-w> r-b is really centered around callbacks
07:03:09 <ertes-w> but they do follow roughly the same model, so translating the pure parts shouldn't be much of a problem
07:05:30 <ertes-w> also functions like 'push', 'pull', 'merge' and 'fan' don't have direct counterparts, and you would have to reinvent Dynamic, if you use it
07:05:36 <hexagoxel> ertes-w: yeah. what i had not realized before is that the extra flexibility is necessary in certain use-cases to ensure proper separation of concerns in the network.
07:14:10 <merijn> @where+ pragma-history https://ghc.haskell.org/trac/ghc/wiki/LanguagePragmaHistory
07:14:10 <lambdabot> I will never forget.
07:27:22 <Itkovian> I'm running two threads, one for the first stage in my conduit, one for the sink. The first doing some attoparsec stuff, the second encoding the resulting data structure as JSON. The first stage uses deepseq to convert the result into normal form. or so I would assume. However, when I push in 100K entries, and use a 100K entry buffer between the two conduit threads, as per the pipelineC example from Neil Mitchell (http://neilmitchell.blogspot.be/201
07:27:22 <Itkovian> 5/07/parallelpipelined-conduit.html), the output indicates that in < 1s 100K entries have been normalised (which is not possible, criterion shows that on average it takes ~ 70usec per entry to parse, so 70 * 100K = 7M usec or 7 seconds). So either there was no forcing normal form or I'm missing something. 
07:27:34 <Itkovian> Any suggestions to figure out what happened?
07:29:23 <carbolymer> It's hard to guess without the code
07:29:42 <Itkovian> yeah, sec.
07:34:52 <Itkovian> https://gist.github.com/itkovian/9b65f891682a0d82a193a2a6d9a6d65b
07:37:04 <Itkovian> the key functions being normaliseText, normalisationConduit and runZeroMQConduit
07:37:30 <Psybur> If Im parsing large csv files, would conduit be a good choice for me? And later on I might want to use the same processing logic on a different input
07:38:34 <Psybur> My approach to loading in text files and performing large sliding windows is just not completing heh
07:38:54 <cocreature> Itkovian: you’re not actually forcing normalisation afaict. if you evaluate (let r' = r `deepseq` r in Right r') to whnf, r' won’t be evaluated at all since Right is lazy in its argument
07:39:10 <Itkovian> ok. 
07:39:24 <Itkovian> then ... how do I force this?
07:39:27 <cocreature> Itkovian: try "r `deepseq` Right r" or something like that
07:43:23 <Itkovian> hmm, does not change anything
07:56:59 <pgiarrusso> Itkovian, you demanding the result of r `deepseq` Right r ?
07:57:27 <Itkovian> eventually, yes, since it needs to be converted to JSON and shipped to 0mq
07:57:41 <Itkovian> but that demand is of course done in the _other_ thread
07:58:02 <Itkovian> hence my assuming that the deepseq does not force at the moment when it's called
07:58:15 <pgiarrusso> but it's not being called :-)
07:58:36 <pgiarrusso> if you don't force r `deepseq` Right r, that's a thunk itself
07:59:00 <pgiarrusso> sounds like only the other thread is invoking this thunk, then running deepest, and so on
07:59:33 <cocreature> if you’re in IO you can use "evaluate" to force evaluation at a specific point
07:59:48 <cocreature> deepseq and seq only control ordering they don’t actually force evaluation
08:00:03 <pgiarrusso> Itkovian: > force x fully evaluates x, and then returns it. Note that force x only performs evaluation when the value of force x itself is demanded, so essentially it turns shallow evaluation into deep evaluation.
08:00:12 <pgiarrusso> since force x = x `deepseq` x
08:00:16 <Itkovian> yes I read that
08:00:20 <pgiarrusso> those docs apply here too
08:00:28 <Itkovian> but I do not fully grok that
08:00:37 <Itkovian> _when_ the value is demanded
08:00:42 <cocreature> "x `deepseq` y" only guarantees that _if y is being evaluated to whnf_ x will be evaluated to whnf
08:01:16 <pgiarrusso> Itkovian, invoking `case foo of...` forces foo to whnf
08:01:22 <pgiarrusso> (for instance)
08:01:26 <pgiarrusso> printing forces too
08:01:38 <Itkovian> well, printing would slow me down a bit much :)
08:01:48 <lyxia> Itkovian: evaluate then yield (normaliseText m') at line 223
08:02:02 <pgiarrusso> yeah, just saying examples
08:02:06 <Itkovian> sure, I know
08:02:08 <lyxia> Itkovian: instead of yield m'  and mapping
08:02:27 <pgiarrusso> OK sorry
08:03:24 <Itkovian> lyxia but then normaliseText will be called in the 'sink thread', no?
08:03:37 <Itkovian> cocreature so I could evaluate in the normalisationConduit, right?
08:03:45 <pgiarrusso> (I was bisecting from basics to the doubt, didn't mean to imply anything)
08:05:13 <lyxia> Itkovian: which is the sink thread
08:05:18 <lyxia> ?
08:05:24 <Itkovian> lyxia no, I was misreading
08:06:13 <cocreature> Itkovian: yes that should work
08:06:37 <Itkovian> lyxia the one started on line 169
08:10:49 <ertes-w> Itkovian: it's fine to assume that only IO actions will ever initiate evaluation
08:11:04 <ertes-w> the *execution* of IO actions to be precise
08:11:52 <ertes-w> then just pretend that when you type pure value expressions into GHCi it just applies 'print' to them
08:11:58 <ertes-w> (that's pretty much what actually happens)
08:13:41 <Itkovian> OK, seems to work. Thx!
08:14:16 <ggVGc> what's the main reasons to use newtype rather than data with a single constructor?
08:14:38 <mnoonan> ggVGc: newtypes are entirely erased at runtime
08:14:55 <ggVGc> so, only for runtime performance?
08:15:20 <mnoonan> as far as I know, that's right
08:15:29 <mauke> it also affects strictness
08:15:30 <mnoonan> well, I guess there is a slight difference in semantics too
08:15:34 <mauke> yeah
08:16:20 <mauke> oh, there's also generalized newtype deriving
08:18:31 <Ferdirand> the wiki page on -XSignatureSections says (:: T) is equivalent to (\x -> x :: T). How does that allow you to replace (Proxy :: Proxy T) with (:: T) ?
08:18:56 <mniip> Ferdirand, it doesn't
08:19:40 <Ferdirand> so, the example in the wiki is wrong ? or the magic comes from their definition of typeRep ?
08:19:46 <Ferdirand> they match proxy a with (->) a a ?
08:20:00 <nicknight> hi any one here have played with linear regression problems in haskell....I am in the journey of learning haskell I want to play with others code in my area of intrest
08:20:02 <mauke> that succeeds if proxy = (->) a
08:20:14 <Ferdirand> that's disgusting :(
08:20:36 <lyxia> That won't work with other kinds than Type
08:20:36 <ertes-w> (:: Proxy T) Proxy
08:20:45 <ertes-w> err, no
08:21:14 <ertes-w> nicknight: the statistics package has linear regression
08:21:42 <ertes-w> nicknight: https://hackage.haskell.org/package/statistics-0.14.0.2/docs/Statistics-Regression.html
08:23:27 <martijn_> hello
08:24:21 <nicknight> ertes-w: ok thank you may be my espectations are different :( anyway I will try on own thanks 
08:24:52 <muesli4> Hi, is there some way to pattern match on single characters of the Symbol kind? If not, is there a way to use character literals on the type level? (E.g. `Proxy :: Proxy 'x'` is a parse error.)
08:25:12 <muesli4> (Pattern matching within a type family.)
08:27:36 <cocreature> muesli4: sadly afaik the answer to both of your questions is no
08:27:50 <ertes-w> nicknight: or you could explain what you need =)
08:27:56 <cocreature> with 8.2 we can at least append type-level symbols but there’s still no way to deconstruct them into individual characters
08:28:29 <ertes-w> muesli4: you could just regard singleton strings as characters
08:28:48 <muesli4> ertes-w: Out of fun (!) I tried to implement a printf where the format string is specified as type level string.
08:28:59 <abhiroop> Are there any Haskell libraries that define type level relational operators?
08:29:03 <ertes-w> ah, that won't quite work
08:30:31 <nicknight> ertes-w: no probelm at present I am not understanding anything in that package, I guess I need to learn haskell mre...right now I just finished initial chapters of LYAH 
08:32:21 <ertes-w> nicknight: are you going to implement LR?
08:34:54 <nicknight> ertes-w:  Yes, I want to do a time forecast with linear regresiion and curious if I can start with haskell
08:35:20 <nicknight> but my skills wont permit that at the moment I am sure :( 
08:37:18 <ertes-w> nicknight: just try it, but be prepared to invest some time into it, because LR requires solving a matrix equation
08:38:05 <ertes-w> nicknight: (or you could use a learning approach like gradient descent, which is far simpler to implement, at the expense of precision)
08:39:05 * hackagebot hasql-cursor-transaction 0.6.2.1 – An abstraction for simultaneous fetching from multiple PostgreSQL cursors – https://hackage.haskell.org/package/hasql-cursor-transaction
08:40:33 <nicknight> ertes-w: okay Thank you I will come back here soon 
09:19:43 * hackagebot servant-quickcheck 0.0.3.0 – QuickCheck entire APIs – https://hackage.haskell.org/package/servant-quickcheck
09:21:17 <jle`> muesli4: yes right now Symbols in haskell are all structureless independent types
09:21:54 <jle`> they contain no internal structure
09:32:31 <cocreature> jle`: tbh, given how annoyed everybody is that we’ve given String too much structure that’s probably not such a bad idea :)
09:33:27 <muesli4> cocreature: But it's also not too useful, not much more than unique identifiers that you can convert to strings.
09:34:08 <cocreature> muesli4: well it’s not as useful as exposing more structure but I would still say they are extremely useful atm. e.g. servant without Symbol would be really painful
09:34:39 <cocreature> leaving it opaque and providing an uncons operation might be a nice compromise but I have no idea how difficult that would be to implement
09:35:27 <muesli4> Me neither, but I guess it will be resolved with dependent types?
09:36:19 <cocreature> maybe, I haven’t kept up with the exact plans for that (if there are even any concrete plans at this point)
10:11:42 <jgt> I'm writing a little boundary layer between my app and third-party services. How should I approach this? I want to say "try and make a request over the network to this service. If it fails, try this other service. If nothing works, log some error."
10:13:07 <jgt> I would imagine it'd end up looking something like `service1 <|> service2 <|> service3`
10:26:57 <saurabhnanda> I'm absolutely confused about withAsync. Can anyone help me understand what exactly this type sig means: withAsync :: IO a -> (Async a -> IO b) -> IO b How many threads is this going to spawn, and which thread will be kills if which thread terminates prematurely?
10:27:17 <saurabhnanda> s/will be kills/will be killed/
10:28:16 <cocreature> it will create one thread and it will kill that newly created thread if the thread you call withAsync from dies
10:29:13 <saurabhnanda> and the original/parent thread doesn't need to be an async? it can be the `main` function itself, right?
10:29:57 <cocreature> yes
10:31:01 <EvanR> if the main thread dies, theres no guarantee any finalizeres on anything will run
10:31:09 <EvanR> async or not
10:31:24 <EvanR> the program ends
10:31:37 <Gurkenglas> Is there a better way to write "do s <- get; for (s ^@.. l) $ \a -> ..."?
10:31:48 <cocreature> EvanR: well if the main thread dies you know at least that the other thread will die as well :)
10:32:00 <EvanR> yeah but thats not a n async phenomnon
10:32:15 <EvanR> phenomenon
10:32:17 <EvanR> uhg
10:36:02 <cocreature> also if your main thread executes regularly (i.e. no SIGKILL or something like that) finalizers on that thread will still be run and the finalizer of withAsync waits for finalizers in the thread it kills
10:36:38 <EvanR> oh neat
10:40:14 <cocreature> however, that’s not true for all versions of async. before 2.1.1 it didn’t wait for finalizers to finish executing
10:42:08 <theNeuron> guys can anyone help me with this basic recursive function? https://imgur.com/a/IxHsX
10:42:35 <shapr> why not use lpaste for the source?
10:43:23 <theNeuron> Wanted to show the use cases where it bugged out as well without having to use separate links, sorry
10:43:30 <theNeuron> shapr: 
10:47:27 <cocreature> theNeuron: longer is missing a case for when the first list is empty but the second is longer than one element and the other way around
10:47:37 <cocreature> theNeuron: [_] only matches a list of length 1
10:53:01 <Gurkenglas> "\p -> review p ()" ought to have an alias.
10:53:20 <Gurkenglas> Something like Prolog's "." statement declaration operator
10:54:06 <Gurkenglas> (Or is there a better way to write ".~ Nothing"?)
10:56:56 <cloudhead> shapr: http://rextester.com/GAOC74085
10:57:14 <cloudhead> shapr: problem is your `[_]` pattern only matches lists with exactly one element in them
10:57:22 <brandon_> 
10:57:29 <shapr> cloudhead: I think that was theNeuron 
10:57:34 <cloudhead> but you actually want greater or equal than 1
10:57:36 <shapr> howdy brandon_
10:57:41 <cloudhead> woops you're right :)
10:57:50 <cloudhead> theNeuron: ^
10:58:24 <theNeuron> thanks cocreature shapr and cloudhead , I got it to work!
10:58:31 <shapr> hurrah!
11:04:48 * hackagebot rhine 0.1.0.0 – Functional Reactive Programming with type-level clocks – https://hackage.haskell.org/package/rhine
11:05:49 <ranberry> You should be able to simplify longer a little bit http://rextester.com/UZY37759
11:16:28 <saurabhnanda> cocreature: EvanR: what withAsync codeThatSpawnsMoreThreadWithAsync $ \asyncHandle -> finally (...) (cancel asyncHandle) -- what will happen to the *other* threads/asyncs that have been spawned?
11:16:57 <saurabhnanda> cocreature: EvanR: `withAsync codeThatSpawnsMoreThreadWithAsync $ \asyncHandle -> finally (...) (cancel asyncHandle)` -- what will happen to the *other* threads/asyncs that have been spawned?
11:17:55 <cocreature> saurabhnanda: first of all, "finally … (cancel asyncHandle)" is redundant. the whole point of using "withAsync" is that you don’t have to do that
11:18:07 <cocreature> saurabhnanda: now to your actual question, depends on how they’re spawned
11:18:13 <saurabhnanda> cocreature: okay, got that. but what about the internal threads?
11:18:20 <cocreature> if you spawn all threads with withAsync they’ll be shut down as well
11:18:42 <cocreature> if you don’t use withAsync or something like it, they’ll keep running
11:18:50 <saurabhnanda> cocreature: but withAsync doesn't allow to spawn multiple threads, it always creates a parent/child relationship
11:19:09 <saurabhnanda> cocreature: I want to spawn 2+ threads that are linked only with the original thread, not with each other.
11:19:48 <cocreature> "withAsync firstThread (\_ -> withAsync secondThread (\_ -> …))"
11:20:46 <saurabhnanda> cocreature: that's the actual code snippet -- https://gist.github.com/saurabhnanda/ea6d300059abece9104a191bf3161348
11:21:16 <cocreature> what am I supposed to do with that?
11:21:23 <saurabhnanda> cocreature: just trying to explain my problem...
11:21:35 <saurabhnanda> I need to create parent -- child1 & child2 relationship.
11:21:44 <cocreature> well I’ve given you a solution and you haven’t told me if that solution works for you and if not why it doesn’t
11:21:47 <saurabhnanda> not grantparent -- parent -- child relationship
11:21:48 <cocreature> so that should be the next step
11:25:07 <saurabhnanda> any idea how to create parent <=> (child1, child2, ... childN) relationship between threads?
11:34:26 <EvanR> saurabhnanda: i dont think it creates a grandparent situation
11:34:41 <EvanR> the body of with async is being run in the original thread
11:35:20 <EvanR> both bodies in fact, the fact that theyre nested is a red herring
11:36:43 <EvanR> to spawn N threads, ive used a recursive call to withAsync (note this will only work with a known finite number of children, not a dynamically determined unlimited number)
11:37:36 <saurabhnanda> how can you predict this behaviour from either the docs or the type signatures?
11:37:44 <saurabhnanda> don't the docs, the examples, the type-sigs suggest a nested tree in all cases?
11:38:01 <saurabhnanda> i.e. grandparent - parent - child, kind of strtucture?
11:38:37 <cocreature> saurabhnanda: note that the second argument to withAsync is run in the _original_ thread not the newly created one
11:39:28 <saurabhnanda> hang on, in that case, just for the sake of discussion, what if my question was flipped? what if I really wanted a nested tree of threads?
11:39:34 <EvanR> saurabhnanda: withAsync spawns a thread and continues in the original thread
11:39:39 <saurabhnanda> staring at the docs, I can't figure out what is really happening.
11:39:51 <EvanR> then you use withAsync from the new thread
11:40:21 <cocreature> or from the original thread if you want multiple childs of a single parent
11:40:25 <EvanR> try to draw pictures of what you think is happening
11:41:16 <saurabhnanda> let me try... and I don't need to call cancel at all?
11:41:55 <saurabhnanda> how can I not nest the `withAsync` calls if I have to use `waitEitherCatch` on them?
11:42:04 <cocreature> if you only want to kill the child thread if the parent thread exits, you don’t need to call cancel. if you want to kill it earlier, you’ll need to call it when you want to kill it
11:42:36 <EvanR> if you want to use waitEitherCatch, then you want to nest them so you can call it from the original thread
11:42:44 <saurabhnanda> cocreature: okay, got that part.
11:42:58 <EvanR> if it was grandparent - parent - etc, waitEitherCatch doesnt make sense
11:43:03 <saurabhnanda> does this have any use-case: withAsync action (const pure)
11:43:16 <cocreature> no
11:44:05 <saurabhnanda> here's more context if that helps in understanding what I'm really trying to do -- https://gist.github.com/saurabhnanda/ea6d300059abece9104a191bf3161348
11:46:57 <saurabhnanda> hang on...
11:47:11 <saurabhnanda> does this make sense? withAsync action (\threadHandle -> waitCatch threadHandle)
11:47:43 <cocreature> yes
11:47:45 <EvanR> isnt that pretty much the same as doing the action in a catch
11:47:49 <EvanR> without forking
11:48:07 <cocreature> right, I was assuming there was something before the waitCatch, sry
11:48:46 <saurabhnanda> the execution will continue after the withAsync call, right?
11:49:07 <EvanR> only after the new thread ends
11:49:24 <saurabhnanda> withAsync action1 (\a1 -> wait a1); withAsync action2 (\a2 -> wait a2) -- will both of them run concurrently?
11:49:34 <cocreature> no
11:49:39 <EvanR> no... its waiting
11:49:45 <hexagoxel> saurabhnanda: i don't think that code snippet helps understand what you want to achieve.
11:50:09 <cocreature> execution after "withAsync a f" will continue once f terminates and the thread executing "a" has been canceled
11:50:12 <hexagoxel> how many actions do you want to run concurrently? what should happen if either of them throws?
11:50:28 <hexagoxel> or finishes?
11:50:55 <cocreature> saurabhnanda: "withAsync action1 (\a1 -> withAsync action2 (\a2 -> wait a1 >> wait a2))" will execute them concurrently
11:50:57 <saurabhnanda> hexagoxel: three actions. One monitor, two workers. If monitor is killed, workers should be killed. If any worker is killed, other workers should not be affected.
11:51:37 <saurabhnanda> cocreature: what will happen to action1 if action2 exits?
11:51:45 <saurabhnanda> or vice-versa?
11:51:56 <hexagoxel> saurabhnanda: and first worker that finishes, other worker is killed, result is received by monitor?
11:52:01 <cocreature> nothing
11:52:16 <saurabhnanda> hexagoxel: no, the workers SHOULD NOT kill each other in any circumstance.
11:52:17 <cocreature> it "wait a1 >> wait a2" finishes executing both will be killed
11:52:40 <cocreature> but apart from that they don’t influence each other directly
11:52:57 <monochrom> But then if "wait a1 >> wait a2" finishes, then the two actions have already finished too
11:53:28 <monochrom> To kill a dead horse.
11:53:46 <cocreature> monochrom: no, if a1 throws an exception "wait a1" will throw an exception and a2 will be killed
11:54:25 <monochrom> Oh oops.
11:54:30 <hexagoxel> saurabhnanda: but monitor should finish if both workers finish? with Either results?
11:55:04 <saurabhnanda> hexagoxel: none of the workers will ever finish. they're in a `forever` loop. Monitor is there to ensure that the workers are respawned if they ever crash.
11:55:49 <hexagoxel> just put one monitor per worker ?
11:56:50 <hexagoxel> seems like that will make the logic much easier..
11:58:16 <saurabhnanda> hexagoxel: I have other ways to this obviously, but I'm trying to find out the correct combinator in async which establishes parent <=> (child1, child2, ... childN) relationship. Somehow, I've not understood whether withAsync does that, or not.
12:00:23 <hexagoxel> the docs at the top of the module clearly relate async and withAsync. they use the same nested pseudo-callback style used by cocreature above.
12:01:18 <saurabhnanda> so, withAsync does the parent <=> (child1..childN) thingie?
12:02:10 <monochrom> One withAsync has exactly one child. What childN?
12:02:26 <monochrom> You need to read the doc 10 more times.
12:02:30 <hexagoxel> but you explicitly want the children to run forever, so i don't see what withAsync gives you.
12:02:43 <monochrom> And read the Simon Marlow book 3 more times.
12:03:25 <cocreature> +1 for reading simon marlow’s book :)
12:03:43 <hexagoxel> forkIO $ forever $ try  seems to do the job just as well, for the described usecase.
12:04:19 <saurabhnanda> monochrom: would  you know which section of the book would deal with something like this? I'd like to get the correct solution and move on with what I was solving.
12:04:33 <monochrom> Yeah actually. If a job is meant to runs forever, there is no point using async.
12:04:54 <monochrom> async is for when you want to wait for it and get its answer or to kill it prematurely.
12:04:58 <hexagoxel> ^
12:05:08 <saurabhnanda> monochrom: there are other things that the app needs to do ... this job is meant to run in the background.
12:08:30 <hexagoxel> saurabhnanda: and how is forkIO insufficient? what aspects do you have in mind so the simpler approach would not scale?
12:09:48 <saurabhnanda> how do I kill a child thread if the parent thread is killed, while using forkIO? 
12:11:26 <hexagoxel> exitSuccess
12:12:38 <barrucadu> killThread
12:13:06 <barrucadu> Or throwTo
12:13:14 <saurabhnanda> right, so manually doing all the plumbing, which I was trying to avoid using a higher level library, i.e. async.
12:13:30 <saurabhnanda> anyways... can I catch `ThreadKilled` exception inside of my async and react to it?
12:13:49 <hexagoxel> saurabhnanda: but you are asking with a usecase that does not involve any killing?
12:14:17 <saurabhnanda> hexagoxel: let it be... I don't think this is going anywhere.
12:14:20 <barrucadu> You can catch ThreadKilled
12:14:40 <barrucadu> It's possible there is a library fro this usecase, but it's definitely not the usecase of async
12:15:03 <barrucadu> async is for the use-case of "I have some IO I want to run in a separate thread and get the result of later", not generic thread management
12:15:18 <cocreature> dunno, I don’t think there is anything wrong with just using withAsync to automatically kill child threads
12:15:52 <cocreature> but I still don’t understand why any of the solutions people have proposed in the last hour or so don’t solve the problem saurabhnanda is having so *shrug*
12:16:36 <saurabhnanda> cocreature: are you **absolutely certain** that nested withAsync are not going to create grandaprent-parent-child relationships between threads?
12:16:44 <hexagoxel> saurabhnanda: you stop asking the wrong question and i let it be.
12:16:58 * hexagoxel leaves
12:17:29 <cocreature> saurabhnanda: you’ve asked this question multiple times before and I’ve repeatedly told you how to use it such that you don’t get grandparent-parent-child relationships
12:18:01 <barrucadu> withAsync doesn't create a grandparent-parent-child relationship because the inner IO action is not run in the newly created thread.
12:18:05 <cocreature> I mean if you’re really worried about this, write some minimal example to test how it behaves if you don’t believe what people tell you
12:18:28 <cocreature> but repeatedly asking the same questions is not a particularly productive use of anybody’s time
12:20:24 <chessai> module Main where
12:20:24 <chessai> type FilePath = String
12:20:24 <chessai> type Text = FilePath
12:20:24 <chessai> type Name = Text
12:20:24 <chessai> type Story = Name
12:20:26 <chessai> type Title = Story
12:20:28 <chessai> type URL = Title
12:20:32 <chessai> is this idiomatic?
12:21:16 <fishythefish> I'd recommend newtypes
12:21:26 <barrucadu> saurabhnanda: Something like this might work (haven't tested it): https://gist.github.com/barrucadu/621237bb344c36ee0dd341e12a2e1a85
12:21:36 <chessai> thank you fishythefish
12:21:46 <fishythefish> Using `type` is the same as using String everywhere, but with aliases available
12:21:55 <fishythefish> the problem is that your typechecker sees these all as the same type
12:22:06 <chessai> it was a joke
12:22:15 <chessai> sorry
12:23:11 <Gurkenglas> Is there "(s -> t) -> (t -> (a, s)) -> StateT t m b -> StateT s m (a, b)" or some zoom-y thing that can specialize to this?
12:24:41 <Gurkenglas> (The a part isn't necessary right now but seems canonical)
12:25:00 <saurabhnanda> barrucadu: thanks. taking a look...
12:25:59 <saurabhnanda> cocreature: please try this -- withAsync (threadDelay (oneSec*30) >> traceShowM "grandparent exited") $ \_ -> withAsync (threadDelay (oneSec * 20) >> traceShowM "parent exited") $ \_ -> threadDelay (oneSec * 5) >> traceShowM "child exited"
12:26:34 <saurabhnanda> let oneSec = 1000000
12:28:22 <saurabhnanda> barrucadu: I'm sorry, but I'm back to the same question. In your example, what happens to a1 if a2 exits, and vice-versa?
12:29:25 <cocreature> saurabhnanda: what am I supposed to see here? threadDelay (oneSec * 5) terminates and then kills both of the other threads
12:30:09 <saurabhnanda> cocreature: and that's what I've been asking for so long.... the behaviour of nested withAsyncs. 
12:30:51 <cocreature> saurabhnanda: it’s not a grandparent-parent-child relationship. it’s child that’s killing parent and grandparent. if parent dies while child lives, grandparent will continue running
12:31:18 <cocreature> saurabhnanda: so if that’s not the behavior you’re looking for, what are you looking for?
12:31:48 <saurabhnanda> parent <=> (child1... childN). If parent dies, all children die. If any child dies, parent should be able to respawn it.
12:32:05 <cocreature> also what you’re calling parent and grandparent are the newly created threads, i.e., the childs
12:32:31 <cocreature> so you have "withAsync child1 $ \_ -> withAsync child2 parent"
12:32:37 <EvanR> use nested withAsyncs, its not a grantparent relationship
12:32:39 <cocreature> parent is dying so child1 and child2 are killed
12:32:43 * EvanR sets up macros 
12:32:49 <cocreature> which seems to be exactly what you’re looking for
12:34:26 <saurabhnanda> in that case, the entire model of withAsync is inverted. `main` can't use it to call a function that spawns other threads. `main` needs to spawn all children directly.
12:34:40 <saurabhnanda> but it's still problemative
12:34:50 <EvanR> any thread can use it to spawn any number of children directly
12:35:05 <EvanR> i just looked at the docs, and indeed its not explicitly saying withAsync runs the callback in the original thread
12:35:13 <EvanR> but its an inference you can make from the wording
12:35:20 <EvanR> its also the truth
12:35:26 <monochrom> The async library doesn't do respawn.
12:35:35 <saurabhnanda> withAsync childAction $ \child1 -> withAsync parentAction $ child2 -> grandParentAction <=== is this the mental model?
12:35:51 <EvanR> no
12:35:55 <EvanR> there is no grand parent
12:36:20 <saurabhnanda> it's like the bloody matrix.
12:36:23 <saurabhnanda> there is no spoon.
12:36:36 <EvanR> child1 and child2 run in separate threads, everything else is running in the original thread, the parent
12:38:16 <saurabhnanda> withAsync childAction1 $ \child1 -> withAsync childAction2 $ \child2 -> withAsync childAction3 $ \child3 -> parentAction <== is this correct?
12:38:30 <EvanR> ok, better
12:38:45 <EvanR> but the whole thing is part of "parent action" and whatever follows it is too
12:39:07 <EvanR> so rename parentAction to thingsToDoWith3Children
12:41:24 <saurabhnanda> finally! thanks EvanR
12:41:24 <saurabhnanda> and this confirms it... withAsync (threadDelay (oneSec*10) >> traceShowM "child1") $ \_ -> withAsync (threadDelay (oneSec * 5) >> traceShowM "child2") $ \_ -> threadDelay (oneSec * 20) >> traceShowM "parent exited"
12:43:03 <Psybur> EvanR, you are now on a list
12:44:13 <monochrom> What list?
12:44:16 <saurabhnanda> hmm... now, inside `thingToDoWith2ChildrenThreads` -- how do I respawn one of the threads?
12:44:28 <EvanR> respawn ?
12:44:44 <EvanR> which means what
12:45:32 <Psybur> monochrom, read what he said to rename parentAction to ;p
12:45:36 <saurabhnanda> if any of the child thread crashes then it should be restarted ad-infinitum
12:45:50 <saurabhnanda> Psybur: :)
12:46:06 <EvanR> then the child thread should be an infinite loop that spawns its own child thread and waits, ad infinitum
12:46:36 <EvanR> since its that simple, the loop thread itself cant crash
12:50:40 <shapr> I really love Haskell way more when I have to do things in other languages
12:51:39 <EvanR> inclimate weather fan?
12:51:57 <monochrom> And do you love other languages more when you have to do things in Haskell?
12:56:07 <EvanR> i love languages that havent been invented yet more when i have to do things in haskell
13:01:32 <shapr> monochrom: sadly not
13:01:34 <saurabhnanda> EvanR: +1, like Haskell + better records + better effects + better editors + non-messy-strings
13:02:02 <EvanR> we have better editors already, but not better IDEs
13:02:11 <EvanR> except for the one everyone ignores apparently
13:03:32 <saurabhnanda> EvanR: which one? HaskellForMac?
13:04:28 <EvanR> https://ro-che.info/ccc/26
13:05:04 <cocreature> EvanR: that IDE no longer exists :)
13:05:24 <EvanR> :(
13:05:28 <dsal> What was that?
13:05:30 <EvanR> why?
13:05:54 <saurabhnanda> where did the FP online IDE go?
13:06:02 <saurabhnanda> there's no post explaining why the pulled it, is there?
13:06:04 <cocreature> probably because it didn’t make enough money to justify the development efforts
13:06:37 <dsal> I've liked playing with repl.it, except the part where the library set is fixed and they don't seem to respond to requests for more.
13:07:52 <cocreature> https://www.fpcomplete.com/blog/2015/04/future-of-soh-fphc
13:07:54 <dsal> My computer is basically a terminal, chrome, emacs, and enough window manager to keep them separated.
13:10:34 <Gurkenglas> :t bool ignored id -- is there a better way to write this?
13:10:36 <lambdabot> Applicative f => Bool -> (s -> f s) -> s -> f s
13:14:00 <akem> I feel pretty confident with Standard ML, but I wanna get into Haskell. should I start with LYAH or Real World Haskell?
13:14:35 <Gurkenglas> Also something to replace flip (foldMapOf l) would be nice
13:14:58 <cement> LYAH is like a super spoilery movie trailer: it shows off all the stuff, but not in any depth
13:15:22 <jb55> akem: check out Haskell Book, also check out #haskell-beginners
13:16:52 <akem> cement: sounds like LYAH will bore me
13:16:59 <akem> jb55: will do
13:33:06 <Gurkenglas> Requesting "(Applicative f, Monoid m) => Fold' s a -> (a -> f m) -> s -> f m"
13:35:42 <Gurkenglas> -'
13:36:11 <Ljacmac> New to Haskell and just looking for a bit of help on a probably very simple problem
13:37:38 <Rembane> Ljacmac: Shoot!
13:38:38 * hackagebot katip 0.5.0.4 – A structured logging framework. – https://hackage.haskell.org/package/katip
13:38:40 <dsal> http://www.catb.org/esr/faqs/smart-questions.html
13:39:00 <Gurkenglas> :t \f -> getConst . view (folded . to (Const . f)) -- got a way, but surely there's a better one
13:39:02 <lambdabot> (Monoid c, Foldable f) => (a -> c) -> f a -> c
13:39:28 <jb55> Gurkenglas: what are you trying to do?
13:39:35 <Gurkenglas> No wait, that's obviously wrong ._.
13:40:05 <Gurkenglas> jb55, collect some results from monadic actions during a fold
13:40:17 <Gurkenglas> (actually a traversal, but that shouldnt be needed right)
13:41:18 <Ljacmac> I'm currently trying to program a function that tests a predicate, and if it comes back true, makes a change to a list AND THEN makes a recursive call. 
13:41:54 <cronokirby> what do you mean by "makes a change"?
13:42:02 <dsal> Ljacmac:  https://usercontent.irccloud-cdn.com/file/UHmDcnwq/showme
13:42:21 <Ljacmac> an alteration, just adding elements to the list
13:42:41 <cronokirby> what's the recursive call supposed to do?
13:42:54 <jb55> Gurkenglas: isn't that just foldM?
13:43:20 <dsal> Ljacmac: It'd be a lot easier to see your code, input, and expected output.
13:43:47 <Gurkenglas> jb55, I supply the lens-Fold, and that looks foldr-like, not foldMap-like
13:43:51 <Ljacmac> Where should I put my code
13:44:09 <cronokirby> hastebin / pastebin / lpaste ...etc
13:48:30 <Gurkenglas> :t \l f -> fmap fold . traverse f . toListOf l -- I mean I could do this but that'd be rather sad
13:48:32 <lambdabot> (Applicative f, Monoid b) => Getting (Endo [a]) s a -> (a -> f b) -> s -> f b
13:55:16 <lyxia> :t \l -> foldMapByOf l (liftA2 mappend) (pure mempty)
13:55:17 <lambdabot> error:
13:55:17 <lambdabot>     • Couldn't match expected type ‘(a -> f1 a) -> s -> f1 s’
13:55:17 <lambdabot>                   with actual type ‘p’
13:55:53 <lyxia> So close...
13:56:47 <lyxia> Why is foldMapByOf taking a Fold
13:57:45 <Ljacmac> http://lpaste.net/359285
14:03:28 <lyxia> :t \(l :: Fold s a) -> foldMapByOf l (liftA2 mappend) (pure mempty)
14:03:29 <lambdabot> (Monoid c, Applicative f) => Fold s a -> (a -> f c) -> s -> f c
14:04:24 <lyxia> Ljacmac: what do you think the semicolon does
14:05:28 * hackagebot liquidhaskell 0.8.2.0 – Liquid Types for Haskell – https://hackage.haskell.org/package/liquidhaskell
14:05:55 <Ljacmac> I dont really know, this is now me trying everything in desperation 
14:07:41 <lyxia> Get leftPlays and rightPlays out of the recursive call first: let (leftPlays, rightPlays) = possPlays t bor in (...)
14:10:32 <Ljacmac> Ok, what will that do?
14:12:04 <lyxia> It defines two variables, leftPlays and rightPlays, that are equal to the left and right component of possPlays
14:12:28 <lyxia> so you can then write (leftPlays ++ [h], rightPlays) or whatever inside the (...)
14:13:08 <lyxia> *left and right components of possPlays t bor
14:17:09 <jgt> I posted a question before, but I'm not sure anyone answered. Had to log off for a while. I'll post it again.
14:17:18 <jgt> I'm writing a little boundary layer between my app and third-party services. How should I approach this? I want to say "try and make a request over the network to this service. If it fails, try this other service. If nothing works, log some error."
14:17:21 <jgt> I would imagine it'd end up looking something like `service1 <|> service2 <|> service3`
14:19:11 <Ljacmac> that worked, thankyou so much!
14:21:13 <lyxia> jgt: that looks reasonable.
14:27:48 <jgt> lyxia: but what mechanism should I lean on? Are there any packages I should look at?
14:27:54 <jgt> where should I begin looking
14:28:54 * hackagebot htoml-megaparsec 1.0.1.8 – Parser for TOML files – https://hackage.haskell.org/package/htoml-megaparsec
14:30:40 <cement> so I'm trying to figure out how to avoid deadlock when I try to make the function "eachThread" in http://lpaste.net/6775747415556227072 concurrent. the plan is to use STM. can I simply wrap eachThread in atomically?
14:32:28 <jgt> lyxia: Ahh… It looks like I need MonadPlus?
14:34:19 <jgt> or maybe I just need applicative
14:34:26 <jgt> I don't know
14:34:55 <johnw> jgt: Alternative
14:35:20 <jgt> johnw: Ah! Yes! I've just noticed Alternative has (<|>)
14:35:29 <jgt> which I seemed to have somehow known without knowing?!
14:35:32 <jgt> spooky.
14:35:39 <johnw> the idea is pretty fundamental
14:35:50 <jgt> johnw: and I'm pretty nooby
14:35:52 <johnw> you know lots of mathematical concepts without knowing them :)
14:36:37 <jared-w> After all, math is merely the study of abstraction, so basically "solid design principles" are just mathematically based ones ;)
14:36:51 <cement> I still have no idea how to actually make my question make sense
14:37:10 <cement> I tried, above, but I think I'm still quite unclear
14:37:47 <johnw> cement: a well asked question is most of the answer
14:38:03 <jared-w> cement: It seems pretty clear to me.
14:38:27 <jgt> cement's comment sounds a lot like "I don't know yet what I don't know"
14:38:43 <jgt> Unknown unknowns
14:38:51 <jared-w> The issue that I see with this is you have an addtoList <- "IO" followed by things <- "IO", followed by stuff <- "IO", so you have 3 IO actions chained in a row
14:38:53 <jgt> s/comment/question/
14:39:27 <jared-w> and now you want to avoid deadlocking when executing multiple instances of eachThread in different threads
14:40:08 <jared-w> So your easiest solution is to wrap everything in atomics and then lose 90% of the benefits of threaded code
14:40:50 <jared-w> Alternatively... When I see your code I see "Grab a bunch of stuff from the environment, and then manipulate that data as it comes in"; to me, that screams "use a streaming library"
14:41:09 <cement> I'm actually grabbing stuff over the network
14:41:49 <jle`> jgt: if you have an Alternative instance then you can use asum too :)
14:43:17 <cement> so, those three IO things are all network requests. in the "real" thing, if the first fails, they all give back an empty list
14:43:41 <cement> and, by extension, newPairs is also empty
14:43:43 <jared-w> cement: even more reason to use a streaming library, to me. I'm guessing the 3 different "get" functions are grabbing from different sources/computers/whatever?
14:43:54 <cement> no, the same one
14:44:28 <jared-w> ah, okay, that simplifies things a tiny bit I suppose. Still, though, I think there's a bit of a design flaw here. How am I supposed to know that if the first fails, they all give back an empty list?
14:44:56 <cement> right, that's a problem with my example, sorry about that
14:45:04 <jared-w> I would expect some Maybes or Eithers in the return type of the 'getX' functions
14:45:29 <cement> I've got the error handling in the getX functions
14:46:01 <jared-w> As in, if the stuff breaks it returns an empty list?
14:46:40 <cement> well, there's a few common cases that aren't really a big deal, so for those, yes, it's an empty list, otherwise it throws an error (for now)
14:47:26 <cement> the main thing is that the "control" list (the one that's pattern matched on) can be refilled by any/all of the threads
14:47:35 <jared-w> That's a very C-like way to think about problems :p  to me, if a function is guaranteed to return a result, I assume that it is guaranteed to return the *right* result. An empty list should then mean I don't have any data, not "stuff broke and this is the default case"
14:48:08 <jared-w> But in threaded stuff I suppose it might be the right answer? Still seems weird to me ¯\_(ツ)_/¯
14:48:31 <cement> well, those common cases *are* "I don't have any data", the others are weird errors that I need to debug when/if they happen
14:48:59 <jared-w> Well in that case, seems like the types aren't lying then :)
14:49:33 <towerio> so the task queue can be refilled by anyone of the workers?
14:49:33 <jared-w> But yeah, I'd suggest looking at libraries like Conduit or Pipes and see if those streaming abstractions simplify your getting and manipulating of data. From there, it should hopefully be more clear on how to thread-ify the eachThread function?
14:49:42 <cement> towerio: yes
14:50:42 * hackagebot clang-compilation-database 0.1.0.0 – JSON Compilation Database Format encoding and decoding – https://hackage.haskell.org/package/clang-compilation-database
14:51:34 <towerio> No expert but my gut is you need a thread to manage the queue
14:52:24 <cement> hmm, so if the manager thread sees that all the workers are blocked and the queue is empty that it should kill everything off?
14:52:39 <jared-w> towerio: that sounds right to me. A Master/slave configuration seems like the best management strategy
14:53:30 <towerio> I mean you probably cannot use the single threaded list for that task queue
14:53:41 <towerio> Maybe look into STM.TQueue?
14:53:50 <cement> yeah, that was the plan, of course
14:55:31 <cement> as a side note, the shuffling of the data that I do pretty much requires being able to see all of the retrieved data at once, in response to Conduit/Pipes/etc
14:56:58 <cement> anyways, thanks for all your help, guys
14:58:32 <towerio> :P parallelism is hard
14:58:43 <towerio> I need to actually try it some time
14:59:00 <towerio> Like implement a parallel merge sort
14:59:13 <cement> yeah, the only reason I'm even doing it is that each recursion can take 3 seconds to complete
15:11:55 <centril> I'm working on a DeriveAnyClass (DAC) feature for Rust - how does DAC work with associated types? http://lpaste.net/359288
15:12:45 <lyxia> it does
15:12:56 <centril> Does GHC create a new type, use the self type (x), etc. ?
15:13:23 <centril> lyxia: any details would be appreciated
15:13:42 <lyxia> you add the default type as part of the class definition
15:13:46 <lyxia> like default methods
15:14:01 <lyxia> it's different from an overlappable instance like you wrote
15:14:31 <centril> I couldn't do  deriving instance Show (B D)  either
15:14:44 <lyxia> oh sorry that's not an overlappable instance, nevermind.
15:15:30 <centril> "default type as part of the class def" <-- how? and if you don't, what does GHC do then?
15:17:47 <monochrom> default type: "type A x = Int"
15:17:52 <lyxia> http://lpaste.net/359290
15:17:53 <centril> monochrom: cheers
15:18:43 <lyxia> if you don't add a type then GHC complains when users forget to define it
15:19:51 <lyxia> Hm, it's just a warning...
15:21:32 <mniip> centril, you could look at -ddump-deriv
15:23:34 <centril> lyxia: the following compiles fine: http://lpaste.net/359291
15:23:44 <centril> mniip: good idea!
15:25:57 <centril> heh, now I just have to fix ghci to work without stack :P
15:26:43 <lyxia> centril: it compiles but you can't do anything with it
15:27:06 <centril> lyxia: right, but what is  A D  ?
15:27:49 <lyxia> it's nothing meaningful
15:28:52 <centril> Aight - so what I infer from this is that: "Don't allow DAC for traits with non-defaulted associated types in Rust"
15:29:15 <lyxia> yes
15:30:08 <lyxia> in Rust you'll run into problems anyway because types are unboxed.
15:30:40 <centril> you can just panic!()
15:30:47 <centril> or unimplemented!()
15:31:36 <lyxia> at the type level?
15:33:44 <centril> no, we have a different proposal for that:   #[unimpl] impl Foo for Bar { type Assoc = Int; /* unimplemented!() for everything else */  }  
15:43:09 <bollu> @tell quchen can I use STGi's TH magic to generate out your STG format from regular haskell files?
15:43:10 <lambdabot> Consider it noted.
16:20:44 <Gurkenglas> What could cause this stack error? http://lpaste.net/2435262232246878208
16:21:29 <Gurkenglas> (Ran stack test once, went into an infinite loop as expected, inserted calls to trace, reran stack test, that
16:21:32 <Gurkenglas> *)
16:22:26 <bitemyapp> Gurkenglas: can it find MinGW libraries it needs?
16:22:40 <Gurkenglas> How do I tell?
16:22:52 <sm> Gurkenglas: running as root, then as yourself ?
16:23:16 <sm> oh windows. Never mind
16:23:18 <bitemyapp> Gurkenglas: what are you deps like?
16:23:24 <Gurkenglas> How do I run that as root? I'm on Windows
16:24:02 <Gurkenglas> bitemyapp, https://github.com/Gurkenglas/ord-graph/blob/master/ord-graph.cabal
16:24:23 <hexagoxel> Gurkenglas: first program still running?
16:24:47 <sm> aha!
16:25:00 <Gurkenglas> That was it, thanks, apparently comint-quit-subjob in that shell didn't stop it but gave me the shell again
16:25:21 <bitemyapp> RIP
16:26:21 * hackagebot duckling 0.1.3.0 – A Haskell library for parsing text into structured data. – https://hackage.haskell.org/package/duckling
16:27:17 <Gurkenglas> Can stack test let me find out where in the source the infinite loop happens? Maybe something like attaching Debug.Trace stuff everywhere and showing me a stream
16:28:06 <lyxia> The same way as with vanilla ghc, compile with rtsopts and profiling, run with +RTS -xc
16:32:20 <Nash_> can someone help me with conduit?
16:32:36 <jle`> best to just ask your quesiton :)
16:32:56 <Nash_> here goes; I have a function that returns a sink like so
16:33:29 <Nash_> function returns: "C.Sink BS.ByteString m AWS.CompleteMultipartUploadResponse", I want "C.Sink BS.ByteString m ()" -- how can I throw away the result?
16:34:20 <lyxia> void
16:34:32 <jle`> is Sink a Functor?
16:34:51 <jle`> it looks like it is
16:34:55 <jle`> :t void
16:34:57 <lambdabot> Functor f => f a -> f ()
16:35:20 <jle`> instance Functor (C.Sink BS.ByteString m)
16:35:49 <Gurkenglas> (stack test --profile looks like the right sort of complexity for me :3)
16:36:06 <Nash_> @lyxia thanks a TON!
16:36:06 <lambdabot> Unknown command, try @list
16:36:16 <Nash_> I've been stuck for hours. you're a saviour.
16:36:46 <lyxia> :)
16:36:50 <hpc> @hoogle f a -> f ()
16:36:50 <lambdabot> Control.Monad.Extra unit :: m () -> m ()
16:36:50 <lambdabot> Extra unit :: m () -> m ()
16:36:50 <lambdabot> Development.Shake unit :: m () -> m ()
16:36:54 <hpc> :(
16:37:06 <jle`> lambdabot hoogle is out of date
16:37:12 <hpc> sometimes hoogle can find what you're looking for if all you know are the in and out types you want
16:37:21 <jle`> @hoogle m a -> m ()
16:37:22 <lambdabot> Control.Monad.Extra unit :: m () -> m ()
16:37:22 <lambdabot> Extra unit :: m () -> m ()
16:37:22 <lambdabot> Development.Shake unit :: m () -> m ()
16:37:24 <jle`> aw
16:37:56 <hpc> @hoogle (a -> b -> c) -> b -> a -> c
16:37:57 <lambdabot> Prelude flip :: (a -> b -> c) -> b -> a -> c
16:37:57 <lambdabot> Data.Function flip :: (a -> b -> c) -> b -> a -> c
16:37:57 <lambdabot> CorePrelude flip :: (a -> b -> c) -> b -> a -> c
16:38:01 <hpc> that's a better example
16:38:07 <jle`> :t ($>())
16:38:09 <lambdabot> error:
16:38:09 <lambdabot>     • Variable not in scope: ($>) :: t -> () -> t1
16:38:09 <lambdabot>     • Perhaps you meant one of these:
16:38:18 <jle`> @let import Data.Functor
16:38:20 <lambdabot>  Defined.
16:38:22 <jle`> :t ($>())
16:38:24 <lambdabot> Functor f => f a -> f ()
16:38:25 <jle`> :t (()<$)
16:38:26 <hpc> :t fmap (const ())
16:38:26 <lambdabot> Functor f => f b -> f ()
16:38:28 <lambdabot> Functor f => f b -> f ()
16:38:29 <jle`> more haskell fishes
16:38:30 <Gurkenglas> :exf -u "Functor f => f a -> f ()" -- I suppose that's fair if () isn't a primitive for exf
16:38:31 <exferenceBot> fmap (\ e -> fold Nothing)
16:38:47 <Gurkenglas> Though why not mempty?
16:39:07 <jle`> presumably here if Nash_ knew that Sink was a Functor, the answer would have been obv
16:39:33 <hpc> ah, that's fair too
16:39:38 <hpc> instance lists can be sneaky at times
16:39:50 <jle`> especially when working with type synonyms
16:39:58 <hpc> i got bit hard by that over and over again when learning the time libraries
16:40:13 <hpc> "type X is useless, it has no operations on it"
16:40:20 <hpc> 5 hours later... "instance Num X"
16:40:30 <monochrom> Oh heh yeah the devil is in the instances
16:40:44 <jle`> lol.  yea it's something that i don't think a lot of introductory materials emphasize
16:40:51 <monochrom> Actually yesterday I was a bit disappointed that Day is not a Num instance.
16:41:17 <jle`> actually it would be nice if Hackage could list instances for type synonyms
16:41:28 <monochrom> OTOH the doc could have written "Please see the instances for useful operations."
16:41:34 <hpc> monochrom: that would require writing a zero-day into the standard library :P
16:41:43 <jle`> hpc: ha ha ha
16:42:20 <hpc> monochrom: ooh, yes
16:42:20 <lyxia> https://hackage.haskell.org/package/kan-extensions-5.0.2/docs/Data-Functor-Contravariant-Day.html#t:Day Totally looks like a number :P
16:42:52 <hpc> monochrom: you'd have to keep in your mind's eye what the hackage docs are going to look at in order to put that sort of thing in though
16:42:55 <jle`> i wonder if it would be feasible for hackage to include instances for type synonyms
16:43:09 <hpc> which i am admittedly guilty of not doing
16:43:47 <hpc> jle`: type CouldBeAnything x = x
16:44:11 <jle`> darn
16:44:21 <hpc> if the alias has a variable at the root of the expression, you can't do it
16:44:32 <hpc> if it's got a concrete type constructor at the root, maybe that would be worth it
16:44:39 <monochrom> Most type aliases aren't like that.
16:44:45 <jle`> yes it might help with things like 'transformers'
16:44:52 <jle`> pipes, conduit definitely 100% would benefit
16:44:54 <hpc> type ObviouslyMaybe x = Maybe x
16:44:55 <monochrom> Then again I am actually against type aliases summarily.
16:45:25 <jle`> i've been using RankN type aliases recently to simulate some subtyping
16:45:33 <jle`> but that's probably not what you mean
16:46:09 <hpc> jle`: that's the sort of evil i would expect to see in the gtk bindings
16:46:09 <jle`> but it seems to make sense for how pipes/conduit use them, even if it does make learning the libraries a bit trickier
16:46:38 <jle`> but i didn't mean to open up a discussion on the merits of type aliases
16:46:45 <hpc> eh, it's on topic
16:47:16 <monochrom> How do you simulate subtyping with rank-n types?!
16:47:28 <hpc> and "can you statically approximate the instances for a type alias" is a mildly interesting problem
16:48:27 <jle`> type Function = forall m. Monad m => Kleisli m
16:49:38 <jle`> now you can compose a 'Function b c' with any Kleisli m a b
16:49:46 <jle`> "is-a"
16:51:03 <monochrom> Oh, I guess that's the same phenomenon as edwardk drawing a UML class diagram for lens and friends.
16:51:31 <jle`> oh yea it's essentially the subtyping system that the lens library uses
16:51:33 <Gurkenglas> How do I generate a .prof file for a program in an infinite loop? I killed the process and the .prof is empt
16:52:00 <edwardk> monochrom: any finite use of bounded subtyping can be replaced with parametricity and rank-n tricks
16:52:07 <edwardk> useful trick for type systems
16:52:23 <Gurkenglas> "stack test --profile" did that, above it was said to add a -xc rts option, can I do that in the stack test command?
16:52:34 <edwardk> need ? such that * and # are both subtypes? Make * = Type Lifted, # = Type Unlifted and replace ? with Type a
16:52:45 <edwardk> er TYPE
16:52:48 <lyxia> Gurkenglas: stack test --test-arguments "+RTS -xc"
16:53:21 <lyxia> Gurkenglas: the stack trace of every exception gets printed to stdout or stderr
16:53:42 <monochrom> At that point it is subkinding >_<
16:54:30 <hpc> clearly what we need is a structural kind system
16:54:34 <monochrom> Sounds like my prophecy of type-level OOP is going to come true!
16:54:36 <jle`> it'd be nice if mtl did type State s = forall m. Monad m => StateT s m
16:54:39 <jle`> s/mtl/transformers
16:55:03 <jle`> then State s would be a subtype of StateT s m
16:55:17 <hpc> jle`: you'd never be able to fully run a state action, there's no runM that works
16:55:26 <hpc> it has to be Identity
16:55:32 <jle`> yeah you can just instantiate m ~ Identity
16:55:37 <jle`> that's the "only" way to run it
16:55:51 <jle`> which is why (forall m. Monad m => StateT s m a) ~ StateT s Identity a
16:56:01 <Gurkenglas> lyxia, thanks. Killing the process still generates no .prof data and there's no last stack trace before the program dies, how do I make it show me how it's looping?
16:56:50 <monochrom> Recall that "run :: (forall m. Monad m => StateT s m a) -> (a, s)" just needs to use Identity.
16:57:00 <lyxia> Gurkenglas: It's not going to generate any .prof data
16:57:07 <hpc> why is Identity the only one that works?
16:57:11 <hpc> m could just as easily be IO
16:57:19 <monochrom> The same way "eh :: (forall a. a -> a) -> Int -> Int" is pretty well-defined.
16:57:21 <lyxia> Gurkenglas: and the fact that it doesn't print anything is odd
16:57:34 <hpc> monochrom: oh, nvm
16:57:41 <jle`> yeah i was wrong when i said it's the 'only' way to run it
16:57:42 <hpc> i have my higher-ranked polymorphism backwards
16:57:43 <monochrom> :)
16:57:48 <Gurkenglas> lyxia, I used 'stack test --profile --test-arguments "+RTS -xc"', still not?
16:58:13 <jle`> but a (forall m. Monad m => StateT s m a) can't use any effects from any monad, it can't do any IO
16:58:14 <Gurkenglas> It does print some stuff before that, from my traces and apparently some exceptions encountered along the way
16:58:48 <lyxia> Gurkenglas: ah so it does print stuff?
16:58:50 <monochrom> (forall m. Monad m => StateT s m a) -> IO (a,s)  can be done but is just as boring as (a,s)
16:59:07 <Gurkenglas> lyxia, not in response to the killing, it's done before it goes into the infinite loop
16:59:43 <lyxia> What do you mean, profiling got rid of the loop?
16:59:45 <monochrom> But of course... run action = unsafePerformIO (runStateT action)
16:59:59 <monochrom> And I forgot that it should be s->(a,s) or s->IO(a,s)
17:00:21 <jle`> :t let runState :: (forall m. Monad m => StateT s m a) -> s -> (a, s); runState x = runIdentity . runStateT s in runState
17:00:23 <lambdabot> error:
17:00:23 <lambdabot>     • Couldn't match expected type ‘StateT s1 Identity a1’
17:00:23 <lambdabot>                   with actual type ‘Expr’
17:00:27 <jle`> :t let runState :: (forall m. Monad m => StateT s m a) -> s -> (a, s); runState x = runIdentity . runStateT x in runState
17:00:30 <lambdabot> (forall (m :: * -> *). Monad m => StateT s m a) -> s -> (a, s)
17:00:30 <Gurkenglas> lyxia, no it finishes printing stuff, then it goes into the loop. as expected, except that i'd have liked a stack trace when i killed it
17:00:42 <jle`> @let import Data.Maybe
17:00:43 <lambdabot>  Defined.
17:00:46 <jle`> :t let runState :: (forall m. Monad m => StateT s m a) -> s -> (a, s); runState x = fromJust . runStateT x in runState
17:00:47 <lambdabot> (forall (m :: * -> *). Monad m => StateT s m a) -> s -> (a, s)
17:00:54 <jle`> :t let runState :: (forall m. Monad m => StateT s m a) -> s -> (a, s); runState x = head . runStateT x in runState
17:00:56 <lambdabot> (forall (m :: * -> *). Monad m => StateT s m a) -> s -> (a, s)
17:00:57 <jle`> hehe
17:01:09 <lyxia> Gurkenglas: ah, that's strange
17:01:25 <monochrom> State s a -> Function s (a,s)  to unify two conversations. :D
17:01:29 <lyxia> Gurkenglas: is the loop in another thread?
17:01:51 <jle`> :D
17:01:55 <Gurkenglas> I don't recall forkIO anywhere but maybe the testsuite does things
17:02:27 <Gurkenglas> I've been killing it via task manager, since comint-quit-subjob in the emacs shell just gives me back the shell instead of killing and ctrl-c in the windows cmd shell doesn't seem to do anything
17:05:17 <lyxia> Hmm maybe that way of killing it doesn't throw an exception
17:05:26 <jle`> but in serious i think there are some issues with type State s = forall m. Monad m => StateT s m
17:05:51 <jle`> i remember i tried it once and then regretted it
17:06:24 <jle`> one immediate issue is that you can't use it in a constructor, so you can't have lists of them i guess, but how often does that come up
17:06:46 <lyxia> Gurkenglas: BTW I learned the profiling stuff with https://wiki.haskell.org/Debugging which makes me notice that I forgot to mention to compile with -fprof-auto
17:06:57 <Gurkenglas> You want "forall m. StateT s m a" in positive position and "StateT s Identity a" in negative
17:07:12 <Gurkenglas> stack test --profile did recompile all the stuff first
17:07:27 <Eduard_Munteanu> More commonly you just MonadState s m => m a
17:07:34 <lyxia> but I don't know whether or how that would work in windows
17:07:42 <Eduard_Munteanu> Which is even more polymorphic.
17:07:44 <monochrom> There is some chance "IO (State X Y)" has a use case.
17:08:29 <Gurkenglas> How about MaybeT (forall m. StateT s m)
17:08:38 <Gurkenglas> that's kind the point of monad transformers
17:09:00 <jle`> that'd probably be better expressed as forall m. MaybeT (StateT s m)
17:09:15 <Gurkenglas> But wouldn't work with the alias
17:09:16 <jle`> but also i wish haskell had a better story with 'impredicative' types
17:09:20 <lyxia> Gurkenglas: I mean, IIRC, --ghc-options="-fprof-auto" is also required to get actual traces.
17:09:26 <jle`> Gurkenglas: oh yea that's true that's probably where i ran into issues
17:09:49 <Camm> Hello everyone. Has anyone used digestive-functors-heist? I need to do a dynamic list, however, I'm not sure why they start the list index from (-1) that produces an extra element in my list. :-/
17:09:56 <Gurkenglas> lyxia, it did print http://lpaste.net/7968834152940175360
17:10:21 <Welkin> did anyone see the the post on hacker news today about haskell? https://news.ycombinator.com/item?id=15483195
17:10:25 <Gurkenglas> Should probably go to sleep now gotta get up in ~5 hours. lyxia could @tell me next steps or something
17:11:02 <Welkin> I'm always amused, but also saddened when I see what people outside of the haskell community think of us, and how misunderstood haskell is as a language
17:12:20 <monochrom> No, instead, I greatly misunderstood the point of Hacker News instead.
17:13:14 <Welkin> even recently I have realized that saying haskell is my favorite language immediately makes the other person see me as some kind of math nerd who is only interested in algorithms and hardcore computer science, but I actually care deeply about user experience and user interface
17:13:41 <monochrom> I have long given up advocacy since last I participated in OS/2 advocacy 20 years ago.
17:14:00 <Welkin> monochrom: the point of the article that is linked on that hacker news page is arguing that haskell *is* is a good language for teaching functional programming, but the consensus on hacker news is that it is not
17:14:47 <Welkin> for reason like "monads; too complex; not practical; too many types"
17:15:52 <monochrom> That is consistent with the Lispers vision of functional programming.
17:16:14 <johnw> monochrom: you were on OS/2 advocate?
17:16:18 <monochrom> They expect untyped lambda calculus and "everything is a list".
17:16:31 <monochrom> I was on Team OS/2.
17:16:35 <johnw> whoa, cool
17:16:42 <johnw> I heard it was an exciting thing for a while
17:18:38 <monochrom> Advocacy doesn't work. Technical merit is a low priority. You rightly pointed out yesterday that while people care a lot about the end results, they are not so concerned about the means.
17:19:27 <monochrom> Actually I think the wording of that needs improvement.
17:19:49 <bitemyapp> You just have to do both
17:19:53 <bitemyapp> have the technical merit so people stick around
17:19:58 <monochrom> Something about more concerned that the means are off-the-shelf and less concerned about the technical merits of the means.
17:20:00 <bitemyapp> but also do a good job of the softer bits.
17:20:31 <c_wraith> language advocacy seems really hard. I can't say I can point to a product that's ever succeeded or failed due to language choice.
17:20:33 <monochrom> So for example OS/2 is a better way than DOS 6 and Windows 95 to use your computer, but it is not off-the-shelf enough.
17:20:48 <bitemyapp> c_wraith: I can
17:21:01 <bitemyapp> c_wraith: I've seen projects and whole companies fail for want of things like types.
17:21:10 <bitemyapp> but using a good tool doesn't just gin up revenue
17:21:17 <bitemyapp> it's like wifi that works reliably. You don't notice it.
17:21:21 <bitemyapp> Usually, anyway.
17:21:39 <monochrom> So for example PHP programmers are more off-the-shelf than Haskell programmers if you just want to get a blog running.
17:21:41 <bitemyapp> It's possible to reflect on how much work using something has saved you. I've had moments like that with Haskell, Xmonad, Emacs...hell, an ecommerce platform.
17:27:31 <jle`> c_wraith: maybe a bit premature to call it, but how about ether
17:27:48 <jle`> *ethereum
17:27:59 <johnw> monochrom: To rephrase from yesterday: people care that when they turn the key in their car, the engine comes on. Whether it's elegant 10 Haskell controlling the ignition computer, or 1,000 lines of the worst PHP you've ever seen, they could care less -- even if you describe the difference! We're on the other side of the coin, where we care about beauty to some extent, maintainability, the respect of our peers, etc.
17:28:41 <c_wraith> that appears to be a case of succeeding (at least as far as those invested are concerned) despite solidity and their vm
17:28:49 <johnw> it's not that people don't care about quality, they just don't care about imperceptable differencies in quality
17:29:06 <jle`> c_wraith: actually you're right, that example might demonstrate the complete opposite case, heh
17:30:06 * hackagebot htoml-megaparsec 1.0.1.9 – Parser for TOML files – https://hackage.haskell.org/package/htoml-megaparsec
17:30:58 <c_wraith> I feel like language choice is a fuzzy thing that mostly is about making developers feel good, rather than something you can put a concrete price on.
17:31:27 <monochrom> I can put a concrete price on it.
17:31:42 <c_wraith> so while I have clear preferences, I tend to be skeptical of arguments that support or discredit my preferences
17:31:50 <monochrom> Just yesterday I was writing a toy program in Haskell to do a small job.
17:32:04 <monochrom> I gave up in favour of a unix command line.
17:32:40 <monochrom> The Haskell program was taking 1-2 hours to come up with. The unix command line took only a minute.
17:33:51 <monochrom> So here is the job: I will have a lot of IRC log files, filenames of the form "xxx-yyy-2017-10-15.log", they contain dates, and I want to erase, say, files 10 days or older.
17:34:34 <mniip> rsync can do the job
17:34:39 <monochrom> After an hour of trying to parse these filenames in Haskell, I decided that "find dir -name '*.log' -mtime +10" is so much simpler.
17:35:01 <edwardk> monochrom: =)
17:35:23 <edwardk> was going to ask if you had to use the dates in the filename or if the access/modtime would be enough
17:36:03 <Eduard_Munteanu> It's somewhat of a lib issue, we could definitely use more helpers for small tasks.
17:36:04 <monochrom> To be sure, there is another instance where a Haskell program is cheaper than a shell script.
17:36:36 <mniip> monochrom, yeah but what if you had to only keep the files whose names are simply typed lambda calculus expressions that reduce to a \x.x normal form
17:36:43 <Welkin> johnw: they care that their car ignition is web scale
17:37:04 <johnw> lol
17:37:34 <mniip> monochrom, oh yeah. One time I needed to implement a quick and dirty program implementing the Tarski-Seidenberg algorithm,
17:37:51 <mniip> that implies munching polynomials and math/logic ASTs
17:38:16 <Eduard_Munteanu> I imagine something like   sourceDir "dir" =$= filterRelMTime (< 10) =$= mapM delete    would definitely help.
17:38:16 <mniip> haskell was practically the only choice
17:38:34 <mniip> I wouldn't dare to write a "quick and dirty" parser in any other language
17:38:58 <Eduard_Munteanu> s/=\$= mapM/$$ mapM/
17:39:20 <mniip> except, perhaps, a language flexible enough to be able to implement combinators over makeshift 'StateT String Maybe'
17:40:20 * hackagebot htoml-megaparsec 1.0.1.10 – Parser for TOML files – https://hackage.haskell.org/package/htoml-megaparsec
17:40:54 <Eduard_Munteanu> Or arguably, one should use an actual log rotation daemon.
17:41:54 * hackagebot htoml-megaparsec 1.0.1.11 – Parser for TOML files – https://hackage.haskell.org/package/htoml-megaparsec
17:42:18 <Eduard_Munteanu> That was quick.
17:47:06 <tomsn> is there a way to apply a monadic action as long as its result is a "Just" and then get that last working value? all fcns i can find return the first Nothing
17:47:20 <johnw> monad-loops has something like this
17:47:27 <johnw> whileJust
17:48:08 <johnw> you could also achieve this with foldM
17:48:30 <Welkin> something that I want to point out that really surprised me was when someone who was not familiar with functional programming at all said that they were "blown away" by the idea of optional parameters, (like the Option or Maybe type)
17:48:39 <Welkin> and it is something that we take for granted because it is so basic
17:48:51 <johnw> it's even syntactic in C#
17:48:51 <tomsn> ah its like scanline. thanks johnw!
17:50:17 <johnw> Welkin: what I found more surprising, coming from Java/C, was types that didn't *allow* null values
17:50:42 <johnw> I'd started using boost::optional in order to get errors in C++ when I'd try to use uninitialized data
17:54:19 <tomsn> im coming from python and the honesty of maybe type still fascinates me
17:54:51 <Welkin> ADTs are life changing
17:54:59 <Welkin> you don't need a library for a list or a tree
17:55:04 <Welkin> you can write your own in a few lines
17:55:10 <Welkin> or make your own option type, etc
17:56:12 <johnw> yes, working with variants in C++ is far more work
17:58:10 * hackagebot state-codes 0.1.3 – ISO 3166-2:US state codes and i18n names – https://hackage.haskell.org/package/state-codes
18:03:13 <EvanR> i tried doing something i thought was simple in C today... and i was astounded how much crap you have to go through
18:04:11 <EvanR> library support for basic system tasks is so great in haskell
18:04:31 <Welkin> the only time I have had fun writing C was when I wrote lua bindings
18:04:48 <Welkin> it's stack-based
18:05:09 <Welkin> it's like using a C-like DSL with way too many nested pointer dereferences
18:10:15 * hackagebot semiring-num 1.6.0.0 – Basic semiring class and instances – https://hackage.haskell.org/package/semiring-num
18:22:32 <hexfive> how can i encode a Word8 into a strict bytestring? super noob here
18:23:58 <pacak> hexfive: A single Word8?
18:24:10 <hexfive> mhm, yep
18:24:18 <hexfive> this would be a literal in source
18:24:23 <boj> hexfive: Data.ByteString.singleton if it's a single Word8
18:24:28 <pacak> :t Data.ByteString.singeton
18:24:30 <lambdabot> error:
18:24:30 <lambdabot>     Not in scope: ‘Data.ByteString.singeton’
18:24:30 <lambdabot>     Perhaps you meant one of these:
18:24:30 <pacak> :t Data.ByteString.pack
18:24:32 <lambdabot> [Word8] -> BSC.ByteString
18:24:49 <geekosaur> :t Data.ByteString.singleton
18:24:50 <boj> :t Data.ByteString.singleton
18:24:51 <lambdabot> Word8 -> BSC.ByteString
18:24:51 <hexfive> ahhh i c. dunno how i missed that - thanks
18:24:52 <lambdabot> Word8 -> BSC.ByteString
18:24:53 <boj> hah
18:26:37 <jchia1> What's a small amount of code to put in a source file to force ghc to take a long time to build it (at least 10s)? I'm trying to make a test case demonstrating stack/cabal/ghc's failure to compile multiple source files in parallel and would like non-trivial source files that are not too long.
18:27:31 <Welkin> jchia1: maybe some crazy template haskell?
18:27:42 <pacak> jchia1: create a datatype with 100 (200, 1000) fields, add generic instance, derive aeson instance with generics
18:28:03 <geekosaur> a splice that starts with a threadDelay?
18:28:22 <pacak> data A a = A a a a a a a a ....
18:29:36 <pacak> jchia1: What kind of issue are you trying to replicate?
18:29:36 <iqubic> pacak: What is that?!?!
18:30:40 <pacak> iqubic: generics. Compilation time grows in a non-linear way when you increase complexity of the datatype you trying to work with.
18:32:16 <dmwit> geekosaur++
18:32:18 <jchia1> pacak: Two things are killing my builds: Lack of parallelization of ghc runs that I cannot explain and stack building who whole package even when I specify a specific executable. I'm trying to repro the first and maybe make a bug report.
18:33:47 <lyxia> :t let f x = (x, x) in f $ f $ f $ f $ f $ f $ f $ f $ f $ ()
18:33:49 <lambdabot> ((((((((((), ()), ((), ())), (((), ()), ((), ()))), ((((), ()), ((), ())), (((), ()), ((), ())))), (((((), ()), ((), ())), (((), ()), ((), ()))), ((((), ()), ((), ())), (((), ()), ((), ()))))), (((((
18:33:49 <lambdabot> (), ()), ((), ())), (((), ()), ((), ()))), ((((), ()), ((), ())), (((), ()), ((), ())))), (((((), ()), ((), ())), (((), ()), ((), ()))), ((((), ()), ((), ())), (((), ()), ((), ())))))), (((((((), ())
18:33:49 <lambdabot> , ((), ())), (((), ()), ((), ()))), ((((), ()), ((), ())), (((), ()), ((), ())))), (((((), ()), ((), ())), (((), ()), ((), ()))), ((((), ()), ((), ())), (((), ()), ((), ()))))), ((((((), ()), ((), ()
18:33:49 <lambdabot> )), (((), ()), ((), ()))), ((((), ()), ((), ())), (((), ()), ((), ())))), (((((), ()), ((), ())), (((), ()), ((), ()))), ((((), ()), ((), ())), (((), ()), ((), ()))))))), ((((((((), ()), ((), ())), (
18:33:49 <lambdabot> ((), ()), ((), ()))), ((((), ()), ((), ())), (((), ()), ((), ())))), (((((), ()), ((), ())), (((), ()), ((), ()))), ((((), ()), ((), ())), (((), ()), ((), ()))))), ((((((), ()), ((), ())), (((), ()),
18:33:51 <lambdabot> [11 @more lines]
18:34:10 <lyxia> "oops"
18:34:26 <pacak> jchia1: executable likely depends on whole library so stack will end up compiling it.
18:35:14 <jchia1> pacak: But the other executables in the same package shouldn't be built, should they? But they are getting built.
18:35:43 <pacak> Not using stack so no ideas. Wouldn't be too surprised.
18:35:43 <dmwit> lyxia: Compilation of that is probably blazing fast, though.
18:36:29 <pacak> jchia1: try configuring package with ghc-options -j8 or something like that.
18:36:46 <iqubic> pacak: What do you use?
18:37:38 <pacak> iqubic: We are using custom build system that compiles only those modules actually needed to compile an executable with some extra tricks to avoid recompilations and to compile multiple things in parallel
18:38:15 <iqubic> pacak: "We" being your company?
18:38:24 <pacak> iqubic: Yes.
18:38:35 <Welkin> does anyone use nix? Do you know why ghcjs is marked as broken?
18:39:24 <iqubic> Welkin: try asking in #nixos
18:49:41 * hackagebot partial-semigroup-test 0.1.0.1 – Testing utilities for the partial-semigroup package – https://hackage.haskell.org/package/partial-semigroup-test
18:49:41 * hackagebot partial-semigroup-test 0.1.0.1 – Testing utilities for the partial-semigroup package – https://hackage.haskell.org/package/partial-semigroup-test
19:08:39 <hexfive> context: i'm writing an instance for the Data.Binary.Get monad. will a 'fail' work anywhere or does it have to be what a do block evaluates to?
19:09:16 <hexfive> ie, `fail "something" *> return ()`
19:09:24 <johnw> that would do what you except
19:09:25 <johnw> expect
19:09:44 <johnw> i.e., it would fail
19:09:55 <hexfive> yay that makes things much easier, thanks
19:25:35 <byorgey> wait, what? fail?
19:26:32 <byorgey> oh, it has a MonadFail instance that does something sensible.  carry on =)
19:43:28 <mniip> lyxia, you can do worse
19:43:59 <mniip> let f=join(,) in let g=f.f in let f=g.g in let g=f.f in...
19:51:13 <tmciver> Hey folks. I've been trying to use an associated type as key type in a map but I get an injective error: http://lpaste.net/359297
19:52:13 <tmciver> I also tried using an existential type in a similar fashion to what this page shows: https://wiki.haskell.org/Heterogenous_collections, but I get a similar error.
19:52:28 <byorgey> tmciver: what if you give myMap a type signature?
19:52:41 <tmciver> I'm now supposing that this is not possible.  Is this true?
19:53:17 <byorgey> also, there's no reason emptyMap has to have FooKey in its type signature.  Why not just Map.Map a String?
19:55:30 <byorgey> also, why do you have a Map (FooKey a) String?    why not  Map (FooKey a) (FooValue a)?  if it's just a map with Strings as values, I don't see what the benefit is in saying that its keys are the key type of some Foo
19:56:06 <byorgey> ultimately, I don't understand what you're really trying to accomplish here.
19:57:56 <tmciver> byorgey: It's a simplified example of my actual code.  I should probably lead with that but I wanted to start with a simple example.
19:58:26 <byorgey> tmciver: right, I figured.  I guess I think it is *too* simplified. =)
19:59:08 <byorgey> tmciver: the reason the example does not compile is that it has no way to figure out what the 'a' should be in the type of emptyMap.  Just knowing that  FooKey a = String  tells us nothing about a.
19:59:15 <tmciver> Ultimately, I want client code to be able to define any type for (FooKey a) and use that as the key in the map - but I want to see if I can use *one* map for different class instances.
20:03:12 <byorgey> tmciver: well, in that case (using one map with different types of keys) you are definitely going to need some kind of existentials.  For example, see how xmonad manages a map containing persistent state of various extensions, all of different types: https://github.com/xmonad/xmonad-contrib/blob/ec5f9a9e59ed5fa6bbd4c3850e4025526155f86e/XMonad/Util/ExtensibleState.hs
20:05:16 <tmciver> byorgey: I also tried using existentials but I'm obviously doing it wrong: http://lpaste.net/359298
20:05:24 <tmciver> I'll take a look at that link though. Thanks.
20:08:24 <tmciver> Looks like it relies on Typeable.  I'll need to look into that as well.
20:30:00 <fDev2179> I have a typeclass question.  Is there a way to define a default behavior for a function which belongs to
20:30:01 <fDev2179>            the typeclass.  Take for example, a typeclass used to represent a matrix.  Consider the case of a matrix
20:30:01 <fDev2179>            of doubles vs a matrix of complex doubles.  A function which gets the size of either of those matrices
20:30:02 <fDev2179>            should be the same regardless of the type.  Is there a way to avoid repeating a duplicate implementation?
20:30:15 <fDev2179> Sorry, was trying to copy/paste.
20:31:17 <v__> can anyone recommend resources for learning to use dependent types in Haskell?
20:42:36 <fDev2179> Anybody out there?
20:42:41 <pacak> fDev2179: O_o
20:43:16 <fDev2179> Hi, pacak.  Any insights about my typeclass question?
20:43:29 <pacak> I'm having problems understanding it.
20:43:55 <fDev2179> What is unclear?  I'll try to communicate better.
20:44:03 <pacak> You usually represent matrices using datatypes with parameters.
20:44:25 <pacak> aka [Int] vs [Double]
20:44:37 <pacak> Not by Num n => List n ...
20:46:15 <fDev2179> I don't understand.  If I wanted to gather a group of functions which apply to one category of some thing (in this case, a matrix), would I not use a typeclass?
20:47:44 <pacak> You don't have to.
20:47:50 <pacak> :t Data.List.take
20:47:51 <lambdabot> Int -> [a] -> [a]
20:47:52 <pacak> :t Data.List.drop
20:47:53 <lambdabot> Int -> [a] -> [a]
20:47:54 <pacak> etc
20:48:15 <pacak> drop, take, init, inits - a bunch of functions that operate on lists
20:48:26 <pacak> but they are not parts of a typeclass
20:48:37 <fDev2179> The example I gave is made up.  I'm trying to do something different.
20:48:49 <fDev2179> I wanted to avoid having to explain the more complicated case.  
20:49:39 <pacak> Try adding a bit more details to your example maybe?
20:50:50 <woodson> hi everyone is there a language extension that auto convert Data.Text.Internal.Text to String?
20:51:12 <fDev2179> I think I see how to do what I want to do.  I should define a function which is not a member of the typeclass which has a type constraint to Matrix a for example.
20:51:38 <fDev2179> That function would be defined once rather than being reimplemented in the same way in every instance.
20:51:50 <woodson> I am getting this error: Couldn't match type ‘[Char]’ with ‘Data.Text.Internal.Text’ thats why am asking
20:53:31 <fDev2179> Thanks, geekosaur.  My initial Google search didn't turn up anything too good.  I've found some better stuff.  Thanks as well, pacak.
20:54:01 <pacak> woodson: OverloadedStrings ?
20:54:07 <geekosaur> woodson, there is no automatic type conversion
20:54:11 <geekosaur> pacak, that only works for literals
20:54:20 <geekosaur> (by wrapping them in fromString)
20:54:42 <pacak> geekosaur: I know. I suspect he gets this error with string literals.
20:54:49 <geekosaur> hypothetically you could manually wrap any expression in fromString, but that's often a bad answer because it will take a slower path
20:55:36 <pacak> woodson: Can you show a bit more context?
20:55:50 <woodson> geekosaur: tried that didnt work. I decide to just change my type to text lol. It was just out of curiosity
20:56:22 <woodson> pacak: I had a function type elmNameSpace :: NameSpace 
20:56:36 <woodson> and Namespace was a type that I made that was of type String
20:56:47 <woodson> and I am using servant-elm
20:56:53 <woodson> to generate my elm types
20:57:08 <woodson> however it wants the namespace as a Text type
20:57:32 <woodson> didnt want to import the text type but I dont want to fight it so 
20:57:36 <woodson> i just added it lol
20:58:18 <pacak> :t Data.Text.pack
20:58:20 <lambdabot> String -> Data.Text.Internal.Text
20:58:20 <pacak> :t Data.Text.unpack
20:58:22 <lambdabot> Data.Text.Internal.Text -> String
21:12:32 <EvanR> :t pack
21:12:33 <lambdabot> error:
21:12:34 <lambdabot>     • Variable not in scope: pack
21:12:34 <lambdabot>     • Perhaps you meant one of these:
21:14:13 <EvanR> > "\uD800"
21:14:16 <lambdabot>  <hint>:1:3: error:
21:14:16 <lambdabot>      lexical error in string/character literal at character 'u'
21:14:16 <EvanR> > "\xD800"
21:14:19 <lambdabot>  "\55296"
21:14:24 <EvanR> > Data.Text.pack "\xD800"
21:14:27 <lambdabot>  error:
21:14:27 <lambdabot>      Not in scope: ‘Data.Text.pack’
21:14:27 <lambdabot>      No module named ‘Data.Text’ is imported.
21:14:43 <geekosaur> > T.pack "\xD800"
21:14:45 <lambdabot>  error:
21:14:45 <lambdabot>      Not in scope: ‘T.pack’
21:14:45 <lambdabot>      Perhaps you meant ‘BS.pack’ (imported from Data.ByteString)
21:14:50 <geekosaur> feh
21:14:54 <EvanR> "\65533"
21:15:03 <geekosaur> @where L.hs
21:15:03 <lambdabot> what lambdabot has in scope is at http://silicon.int-e.eu/lambdabot/State/Pristine.hs
21:16:16 <geekosaur> Data.Text marked as todo :(
21:17:06 <pacak> % import Data.Text
21:17:07 <yahb> pacak: 
21:17:19 <pacak> % pack "\xD800"
21:17:19 <yahb> pacak: "\65533"
21:17:31 <pacak> % :q
21:17:31 <yahb> pacak: 
21:18:56 <EvanR> text encoders were complicated before unicode
21:19:02 <EvanR> encodings*
21:19:19 <MarcelineVQ> :t T.pack
21:19:20 <lambdabot> String -> T.Text
21:20:25 <MarcelineVQ> syntax for something like that is  @let import qualified Data.Text as T
21:20:44 <EvanR> > T.pack "abcd"
21:20:46 <lambdabot>  "abcd"
21:20:50 <pacak> EvanR: Right. Now that we have utf8.... Or was it utf16? utf32? UCS2... UCS4?
21:21:26 <EvanR> it became complicated than the sum of all the legacy things it aimed to replace
21:21:34 <EvanR> more complicated*
21:22:09 <pacak> https://xkcd.com/927
21:22:39 <pacak> > let (☭) = (+) in 2 ☭ 3
21:22:41 <lambdabot>  5
21:22:47 <geekosaur> they're at least related. go look at all the iso8859s. or gb, big5, etc.
21:24:29 <dsal> How does a glob of symbols know to be an operator vs. a prefix function?  It seems a little magic to me.
21:24:38 <dsal> I mean, I get the above syntax, but are there character class limitations or something?
21:24:39 <EvanR> maybe its more like a product then :)
21:25:10 <EvanR> dsal: its basic on character classes
21:25:13 <EvanR> based*
21:25:27 <dsal> Can you mix them at all?
21:25:33 <EvanR> no
21:25:44 <dsal> so you can't have a (+') ?
21:26:05 <EvanR> > let (+') = (+) in 1 +' 1
21:26:07 <lambdabot>  <hint>:1:8: error: parse error on input ‘)’
21:26:35 <pacak> > let ᐳ = 3 ; ᐸ = 4 in  ᐳ + ᐸ
21:26:37 <lambdabot>  7
21:26:45 <dsal> Are you suggesting I should try things instead of just ask questions and let other people try things?
21:26:51 <dsal> Yeah, that's what I'm talking about...
21:26:59 <EvanR> i already know +' wouldnt work
21:27:14 <EvanR> just felt like spamming lambdabot
21:27:41 <dsal> I'm sure there's a clear document describing these character classes.
21:27:51 <EvanR> me too
21:27:55 <MarcelineVQ> https://www.haskell.org/onlinereport/haskell2010/haskellch2.html#x7-180002.4
21:28:06 <dsal> I can tell I'm becoming a haskell programmer because of how lazy I'm getting.
21:28:41 <EvanR> i didnt know about the _foo unused warning thing
21:29:10 <MarcelineVQ> _foo is good practice, you'll see it in various places in base
21:29:34 <MarcelineVQ> I've seen it most often in Data.List if you want a specific spot to look at
21:29:44 <MarcelineVQ> or GHC.OldList, whatever you want to call it
21:30:27 <dsal> I read some of that HN thread earlier today.  I guess a lot of people see the beauty in javascript.  I never managed to find it.
21:30:52 <MarcelineVQ> Though, appearantly that's just foggy memory, because I'm looking at it now and there isn't really cases of that in there. so nvm that example :>
21:31:33 <EvanR> javascript ;_;
21:33:01 <dsal> I still don't understand like, most of haskell, but I feel like I could write something I could understand more easily than I could in javascript.
21:35:14 <pacak> dsal: Can you explain "[] > null", "[] == null" and "[] >= null" in javascript?
21:35:27 <dsal> I can't really explain anything in javascript.
21:35:51 <dsal> I've done a few neat things with D3, but I have mostly used it because it's ~required.
21:36:08 <pacak> d3 is somewhat nice, yes.
21:36:34 <pacak> I was wondering how to generate it from haskell using dsl of some sort.
21:36:36 <EvanR> all three are type errors in haskell, which is good, and is the answer to so many old questions now
21:36:57 <dsal> [] == null  is an error?
21:37:04 <EvanR> :t [] == null
21:37:05 <lambdabot> error:
21:37:05 <lambdabot>     • Couldn't match expected type ‘[()]’
21:37:05 <lambdabot>                   with actual type ‘[a0] -> Bool’
21:37:07 <pacak> in haskell - yes.
21:37:23 <EvanR> [] is a list, null is a function
21:37:36 <EvanR> in a == b, a and b have to have the same type
21:37:42 <dsal> Ooh, that's right.
21:37:56 <dsal> I confused null and empty
21:38:21 <dsal> ore mempty or something.  I should've stopped at "I confused"
21:38:37 <EvanR> Data.Map.empty exists
21:39:37 * hackagebot fluid-idl-http-client 0.0.0 – Http Client addon for Fluid – https://hackage.haskell.org/package/fluid-idl-http-client
21:42:21 <dsal> I knew I'd seen it somewhere.
21:43:01 <EvanR> a lot of containery data structures include an empty in the API
21:43:18 <EvanR> so its kind of defacto standard
21:43:18 <dsal> Yeah, I'd been going through exercism and had to make them.
21:43:55 <dsal> I'm stuck on the one that requires parsing.  I'm not super happily jetting through that one.
21:44:03 <dsal> megaparsec seems the easiest so far.
21:48:51 <saurabhnanda> I'm just leaving this here. Have spent the entire night and my brain is not working properly to be able to debug this. Any help would be appreciated. https://stackoverflow.com/questions/46782644/under-what-conditions-is-finallys-finalizer-not-run
22:00:54 <EvanR> megaparsec does look somewhat bad-ass
22:01:21 <Welkin> the sequel to megadeth?
22:03:36 <razorman> hi
22:03:48 <razorman> I have a question
22:04:20 <razorman> is there someone here to answer question
22:05:04 <razorman> hellooo
22:05:07 <vimalloc> Just ask the question 
22:05:13 <razorman> xD
22:05:36 <byorgey> EvanR: megaparsec is great
22:05:58 <razorman> Have there been any successful attempts to implement Haskell language for use with robotics, perhaps with Raspi
22:08:03 <peddie> razorman: you could check out https://www.seas.upenn.edu/~acowley/ including his slides at https://acowley.github.io/NYHUG/FunctionalRoboticist.pdf 
22:08:22 <peddie> looks like it was using an arduino from the slides, so maybe not too serious robotics
22:08:34 <razorman> Ooooh thank you!!!
22:08:40 <razorman> Aawe
22:08:42 <razorman> Okay
22:08:47 <razorman> I'll check it out anyway
22:08:49 <peddie> there is a company in california called kittyhawk that uses haskell to implement its flight control systems
22:09:00 <razorman> how cute
22:09:01 <Axman6> there's a fair amount of research into languages for embedded systems built in or using Haskell
22:09:03 <razorman> Kitty hawk :3
22:09:23 <razorman> yes
22:09:43 <peddie> razorman: looks like there are ROS bindings
22:09:51 <peddie> I suggest googling though
22:09:53 <Axman6> Data61/UNSW/DARPA have built flight control systems in haskell based langues/(E)DSLs
22:10:04 <razorman> Basically robotics would be like an embedded systems I guess
22:10:19 <razorman> Darpa
22:10:33 <razorman> Darpa also makes robots competition
22:10:50 <razorman> for military purposes I assume
22:10:55 <Axman6> https://smaccmpilot.org
22:11:33 <Axman6> Ivory and Tower are languages for safe systems programming and coordination of those programs, respectively,  IIRC
22:12:07 <peddie> Axman6: thanks, I was looking for SMACCM but couldn't remember the acronym
22:12:50 <razorman> safe systems programming? Why isn't everything considered as a safe system
22:13:09 <Axman6> safe (systems programming)
22:13:18 <Axman6> not (safe systems) programming
22:13:28 <MarcelineVQ> #haskell-embedded is another resource, though I expect most of the people in it to also be in here
22:13:30 <razorman> aaah
22:13:47 <peddie> razorman: is there anything in particular you want to do robotics-wise?
22:13:58 <razorman> make a robot
22:14:18 <razorman> let's say, a line following bot
22:14:29 <razorman> simple basic robit
22:14:29 <razorman> Robit
22:14:31 <razorman> Robot
22:14:56 <peddie> with photodiodes?
22:14:59 <Axman6> Copilot is alother DSL which could easily be used for that, it's been used in at least one NASA project for monitoring embedded systems
22:15:02 <razorman> inputs is a low res camera
22:15:26 <razorman> Photodiodes is a better idea
22:15:40 <peddie> Atom is yet another DSL for embedded systems, while we're listing them :)
22:16:01 <razorman> When u say DSL what this means?
22:16:03 <Axman6> doesn't Copilot build on Atom?
22:16:10 <Axman6> domain specific language
22:16:15 <razorman> Aha
22:16:18 <peddie> Axman6: I think it might use Atom for code generation
22:16:31 <razorman> I've never heard of any of these
22:16:40 <jchia1> I have a GADT "Foo a". How can I constraint it so that a must have an instance of Show? Is it possible?
22:16:43 <razorman> Atom Tower Ivory Copilot
22:17:07 <Axman6> EDSL = embedded somain specific language, generally a Haskell library which defines a languages using Haskell directly rather than defining a whole new language which needs a parser, optimiser, etc
22:17:26 <Axman6> domain*
22:17:35 <razorman> So it's an esolang?
22:17:47 <razorman> which uses Haskell as the interpreter
22:18:09 <Axman6> that would be a pretty weird way to describe it
22:18:21 <peddie> razorman: maybe better to think of it as a haskell library that gives you a little mini-language for certain kinds of programming problems
22:18:22 <razorman> ?
22:18:31 <razorman> I see
22:19:03 <razorman> I remember that Haskell is very good with renaming commands
22:19:19 <razorman> let command
22:19:52 <mniip> let-in is an expression
22:19:55 <rotaerk> renaming "commands"?
22:19:56 <mniip> we don't believe in statements
22:20:09 <razorman> yes
22:20:13 <peddie> razorman: I think most languages will let you assign a new name to a value :)
22:20:36 <razorman> but really Haskell has a step more than just renaming values
22:20:36 <mniip> peddie, yeah but not haskell
22:20:51 <razorman> let true=false is a good example
22:21:06 <peddie> mniip: I can't assign a new name to a value?
22:21:10 <dmj`> saurabhnanda: I think part of the issue is the forever block in your finally computation that is run.
22:21:27 <cocreature> it’s not so much renaming as it is shadowing the existing definition
22:21:29 <mniip> ah sorry I read that backwards
22:21:31 <peddie> mniip: I don't mean reassign an existing name to a new value . . .
22:21:35 <peddie> no worries ;)
22:22:41 <razorman> x)
22:22:55 <razorman> I prefer python
22:23:04 <razorman> *grabs popcorn*
22:23:08 <peddie> python also lets you assign a new name to a value
22:23:12 <razorman> yes
22:23:36 <peddie> unless it's a primitive type, in which case I think you have to copy it?
22:23:40 <razorman> I'm new to programming robotics
22:23:55 <razorman> primitive type as in
22:24:15 <peddie> razorman: I suspect you can get help doing robotics stuff in haskell here, but you might have more luck if you can break the problem down a bit and ask more specific questions
22:24:29 <mniip> peddie, those are indistinguishable under the data model
22:24:51 <peddie> mniip: aren't some types pass-by-value and the rest (including user-defined objects) pass-by-reference?
22:25:01 <jchia1> Regarding my earlier GADT question: http://lpaste.net/359300
22:25:12 <peddie> mniip: I might be misremembering, it's been a while since I last wasted half a day on it . . .
22:25:12 <mniip> there's no way you can distinguish 2 from the result of 1+1, so effectively they can be treted as pass by reference immutable objects
22:25:29 <razorman> the specific problem is that I dont know what programming language is going to be most reliable for creating robots
22:25:31 <peddie> OK, I see, even though they are actually passed by value
22:26:22 <peddie> razorman: what sources of unreliability are you worried about?
22:26:30 <MarcelineVQ> razorman: best to get started then figure that out, what language you like is going to depend on what is controlling your robot
22:26:40 <razorman> hmm
22:27:09 <razorman> well are there any equivalent controllers such as Raspi which is based on Haskell commercially available?
22:27:21 <mniip> my mind goes "robots sound realtimey"
22:27:26 <razorman> yes
22:27:29 <mniip> that disqualifies raspberry pi
22:27:36 <razorman> Haskell doesn't do realtimey?
22:27:45 <mniip> raspberry pi doesn't
22:27:55 <xkapastel> if i'm understanding copilot correctly, it's not like the robot is actually running haskell; you're describing a computation in haskell and compiling it to another language like C
22:27:56 <mniip> but fwiw haskell isn't great at it either
22:27:56 <razorman> but they all use raspis
22:27:56 <peddie> razorman: it has a garbage collector, so people who want real-time stuff usually generate code like we were discussing before
22:28:04 <xkapastel> it's irrelevant whether or not haskell itself runs realtime in that case
22:28:25 <mniip> aha
22:28:31 <mniip> this is where the edsl talk came from
22:29:13 <jchia1> Never mind, I found out I can just add the constraint (Show a) the normal way to Max1.
22:29:13 <iqubic> What is edsl?
22:29:27 <xkapastel> iqubic: scroll up
22:29:30 <peddie> iqubic: scroll up, or google ;)
22:29:44 <razorman_> sorry I timed out
22:29:48 <razorman_> what did I miss
22:30:07 <peddie> razorman_: not much
22:30:20 <razorman_> oky
22:30:33 <xkapastel> razorman_: you don't need to look for a device "based on haskell", you can describe a computation in any language and compile it to a target language with the realtime/performance properties you want
22:30:59 <razorman_> I didn't know this
22:31:19 <peddie> razorman_: I think you should think about your design a bit more and break it down into specific computing tasks you need your robot to do; then you can look at how to solve those problems
22:31:26 <razorman_> So which would be the best for this?
22:31:48 <xkapastel> razorman_: it's not a competition, i don't think looking for "the best" is so useful if you don't actually know what you're doing yet
22:32:02 <razorman_> I suppose not
22:32:43 <mniip> hmm
22:32:50 <razorman_> let's say I have a separate controller for accepting and processing RF signals to translate into commands for the main board, I would need this to never make a mistake
22:32:54 <mniip> I remember I wanted to do a quadcopter on STMF32s
22:33:39 <mniip> and I couldn't make up my mind on whether a single one can drive all four ETCs
22:34:16 <razorman_> What programming language would commercial drones be based on
22:34:27 <razorman_> I'm assuming probably it's C
22:35:24 <razorman_> Arduino code is even based on C
22:36:12 <jchia1> GADT question: Can I somehow express a constraint at the level of a GADT instead of once for each constructor inside that needs the constraint? http://lpaste.net/359300
22:36:36 <cocreature> jchia1: no
22:37:15 <razorman_> sounds like an optimization issue
22:38:30 <razorman_> so yea
22:38:55 <razorman_> someone said a Raspberry Pi was a bad idea for robotics that pretty much leaves me with nothing
22:39:28 <peddie> razorman_: probably depends on your requirements
22:39:28 <razorman_> I have no ideas for other embedded devices for dealing with real time robotics
22:39:37 <jchia1> cocreature: Thanks
22:39:40 <iqubic> Why is the Pi bad for robots
22:39:42 <peddie> razorman_: there are other options, but this is probably not the channel to go over them
22:40:07 <razorman_> ehm
22:40:22 <razorman_> someone said it's not a realtimey option
22:41:10 <peddie> razorman_: it probably depends on your requirements around "real-time" behavior
22:41:57 <xkapastel> i really doubt the rpi is a bad choice for any robot a hobbyist could feasibly build
22:42:03 <xkapastel> what exactly are you trying to do?
22:42:08 <razorman_> I have three basic requirements, reliability, low power consumption, speed
22:42:09 <Axman6> mniip: ETCs?
22:42:29 <mniip> electronic throttle controller
22:42:31 <peddie> razorman_: there is ##robotics but it looks pretty empty.  ##embedded looks busier.  maybe try asking there?
22:42:46 <mniip> no wait
22:42:48 <razorman_> aha okay
22:42:49 <peddie> razorman_: those aren't requirements; those are metrics
22:42:55 <razorman_> Uhm
22:43:09 <mniip> Axman6, ESC is the word I was looking for
22:43:11 <razorman_> what's an example requirement
22:43:19 <mniip> Electronic Speed Controller
22:43:35 <peddie> razorman_: an actual number, like "10Hz feedback control loop"
22:43:54 <peddie> razorman_: just saying "I require speed" isn't helpful; it's a metric because the next thing someone will ask you is "how fast, then?"
22:43:56 <razorman_> Yea.. if I knew what that was I would require it
22:44:09 <razorman_> xd
22:44:20 <razorman_> How fast? /Really fast/
22:44:40 <peddie> razorman_: I don't even know what you're measuring the speed of
22:44:49 <razorman_> processing
22:45:30 <razorman_> I'm hardly gonna use a 1Ghz single core for a robot that has thousands of commands per second
22:45:31 <Axman6> mniip: ah, thought that might be it
22:45:37 <peddie> razorman_: well then raspberry pi is probably out again ;)  but seriously, you need a notion of "what's the minimum performance I need" if you are trying to pick some hardware
22:45:48 <peddie> razorman_: I hope those other channels can help you with your hardware question
22:45:49 <razorman_> hmmmm
22:45:56 <razorman_> alrighty then
22:45:59 <razorman_> sounds good
22:46:17 <razorman_> thank u all for ur help and pointers
22:46:18 <Axman6> razorman_: the answer to "Really fast" is "Use a Xeon then"
22:46:24 <razorman_> yes
22:46:40 <peddie> razorman_: good luck -- please come back when you need to work out how to use haskell to do it ;)
22:46:48 <razorman_> I'd need a car battery and a big PSU for that
22:46:56 <razorman_> :p
22:47:08 <razorman_> Unless I learn assembly before then
22:47:10 <dsal> How do I have a noop for some Monad m => m ()   ?  This seems easy.
22:47:21 <Axman6> razorman_: I would be extremely surprised if any of the options youve mentioned have problems with the speed you need. even an arduino can do thousands of things per second if those things are simple, like following a line
22:47:31 <cocreature> dsal: "pure ()"
22:47:32 <peddie> razorman_: then you will really need the good luck wishes!
22:47:34 <razorman_> hmmm
22:47:41 <razorman_> xD
22:47:50 <dsal> cocreature: Ah, I tried that without pure...  Thanks.
22:48:33 <dsal> My parse passes all the tests, but I did kind of want the prefix operator to work as opposed to just being part of the number parser.
22:48:41 <razorman_> thanks all for ur help I'll come back some other time! :)
22:48:45 <razorman_> cyaaa
23:02:57 <jchia1> How do I make this code work? http://lpaste.net/359303
23:02:58 <jchia1> The context is that I'm having 'nodes' of different types (Node a) that are wrapped in a GADT 'Wrapper' (Wrapper :: Node a -> Wrapper). Now I need to check equality of two Wrapper values even if one is wrapping a "Node a" and the other is wrapping a "Node b" (for different types, the equality check result is always False).
23:04:27 <cocreature> jchia1: shouldn’t "Wrapper -> Wrapper -> Bool" be sufficient for that?
23:04:36 <cocreature> or "Node a -> Node b -> Bool"
23:04:46 <cocreature> you can’t implement the function you’re trying to implement
23:05:21 <cocreature> you could implement "(Typeable a, Typeable b) => a -> b -> Bool" but I doubt that’s really what you’re looking for
23:16:56 <jchia1> cocreature: To illustrate my problem: http://lpaste.net/359306
23:17:23 <jchia1> cocreature: I need to define equality comparison succintly.
23:18:19 <jchia1> The GADT "Value a" is used only for things with Show & Eq, like Int, Double, Bool, Text.
23:23:01 <cocreature> jchia1: the problem is the Max1 constructor, specifically the "a" argument of it
23:23:35 <cocreature> jchia1: http://lpaste.net/359309
23:25:59 <jchia1> cocreature: I want to treat the comparison as False if the types are different. OK. Is there a way to express the equality logic succintly?
23:27:07 <jchia1> cocreature: Also, somehow the Max1 is preventing successful standalone-deriving of the Value a. I'm not sure why.
23:27:37 <jchia1> cocreature: Never mind, I just needed to add a Eq a constraint to Max1
23:27:51 <cocreature> you can do http://lpaste.net/359310
23:28:32 <cocreature> whether that’s actually going to be useful needs more context
23:29:44 <c_wraith> cocreature: why are you using eqT instead of just cast?
23:29:59 <c_wraith> cocreature: you never need to pass the proof around anywhere
23:30:30 <cocreature> c_wraith: no particular reason but I also don’t see a clear advantage of using cast instead of eqT
23:30:52 <c_wraith> No need to annotate types with cast
23:30:59 <cocreature> fair enough
23:31:14 <c_wraith> actually, you probably don't need the annotation there, either.
23:31:36 <c_wraith> Oh, you do.  I see.
23:39:38 <jchia1> cocreature: Thanks. Can I just succinctly express "For eqValue, just use the Eq instance of Value a, if a & b are the same type. Otherwise, return False"? I'm going to have Eq instance for Value a.
23:41:39 <nano-> I'm trying to aeson FromJSON parse [[], ["a", 2], ["b", 3], []] into a collection of structures that expects Text and Int. This obviously fails when an empty array pops up in the data. Is there any way to skip this, or have my structure be a Maybe or something?
23:42:28 <nano-> Like [Maybe MyData] which would be Nothing in the case of [], and Just MyData in the proper case. Ideally I'd like to skip it, but it wouldn't be bad if I got some Nothings in there.
23:42:28 <jle`> well you can just parse it into a list of tuples, and do normal haskell processing there
23:42:42 <jle`> there are a couple of ways to combine a list of maybe's
23:42:47 <jle`> you can use sequence :: [Maybe a] -> Maybe [a]
23:43:13 <nano-> But a list of tuples would mean I would have all the entries as Text or?
23:43:29 <nano-> Or they would be aeson Value, and I had to check them myself?
23:44:05 <jle`> [Maybe (Text, Int)] perhaps?
23:44:11 <jle`> aeson lets you be flexible
23:45:17 <nano-> I have explained it more in detail here, https://stackoverflow.com/questions/46780677/aeson-with-arrays-of-arrays-of-which-some-are-empty
23:45:36 <nano-> In short, I have data ResultRow = ResultRow Text Text Text Int deriving (Show, Generic), and then [Maybe ResultRow], and that fails the decoding.
23:46:14 <nano-> with, Left "Error in $[1].data[0]: When expecting a product of 4 values, encountered an Array of 0 elements instead"
23:47:58 <jle`> hm yes the default instance for [Maybe ResultRow] might not get you what you want
23:48:21 <jle`> i'd parse it into [Value] and then fmap parseValue (or whatever it's called), maybe
23:49:41 <nano-> I'll see what happens in that direction. If you have any other ideas, just shout out, I'm in way over my head, fairly early in my learning :)
23:50:23 <jle`> yeah your issue is probably that the FromJSON instance for [Maybe ResultRow] isn't quite the behavior you want, so you'd have to write your own parser
23:50:29 <jle`> luckily that's pretty simple/straightforward
23:50:31 <cocreature> jchia1: if you’re fine with adding an Eq constraint on Max1 (which is necessary to get an Eq instance for Value a), you can use http://lpaste.net/359311
23:51:25 <nano-> jle`: If you have any reading suggestion on how writing my own parser would kind of look like, at least search terms, I'd be happy. All my google searches end up in already visited links :)
23:52:02 <jle`> nano-: look at some of the default FromJSON instances
23:52:06 <jle`> as well as the examples in the documentation
23:52:16 <jle`> parseJSON is a parser
23:52:36 <nano-> Ah, right. Thanks.
23:52:42 <jchia1> cocreature, c_wraith: I got a bit further with the problem. Now I have a problem with deriving. If I can cleanly define the Eq instance for Value a (e.g. with deriving), the problem is solved. I'm trying to avoid writing boilerplate. http://lpaste.net/359312
23:52:47 <jle`> the typeclass basically associatiates a "default parser" with every type, *but*, nothing is stopping you from just writing your own parsers, not attached to any typeclass
23:53:30 <cocreature> jchia1: not sure what the problem is, your code seems to compile?
23:54:01 <jle`> nano-: but yeah all of the example parseJSON functions are all valid parsers; you can just write your own in the same style, as a standalone parser
23:54:35 <nano-> jle`: How would I invoke it when decoding the broader structure? Declare the outer array as some type, and in the FromJSON of that outer data type map my custom parser on the elements?
23:54:59 <jle`> FromJSON is just a tool; it gives you a default parser with every type
23:55:14 <jle`> but you can just name and use parsers directly as well
23:55:18 <jle`> you can parse a Value into a [Value]
23:55:28 <jle`> and parse each of those Value's into ResultRow's
23:55:37 <jle`> with a Value -> Maybe ResultRow function
23:55:50 <jchia1> cocreature: It fails to compile. I've added annotation with the error message. http://lpaste.net/359312
23:56:22 <nano-> jle`: I like how it sounds, I just have to figure out the blanks in my head :) Thanks for the help.
23:56:27 <jchia1> cocreature: If I comment out the line with Compare, the compilation works.
23:57:28 <jle`> no problem!
23:58:07 <jgt> can someone explain this short snippet? http://sprunge.us/eORB
23:58:10 <cocreature> jchia1: there’s not really anything you can do about this: GHC can’t derive an Eq instance
23:58:54 <jchia1> cocreature: Would generic help in this case?
23:59:18 <cocreature> jchia1: no generic, can’t handle GADTs. you could probably write some TH to write these instances
23:59:39 <jchia1> cocreature: OK
