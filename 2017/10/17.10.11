00:00:28 <xormor> I have found it difficult to implement graphics in C and C++. I mostly do not bother. I would have to download some libraries and header files (*.h).
00:01:09 <xormor> I have drawn graphics in x86 assembly. It was in real mode in MS-DOS, sometimes in pure MS-DOS and sometimes in Windows (XP). In the MS-DOS window.
00:01:39 <HaskellLord69> a true graphics hacker
00:01:59 <HaskellLord69> I did squares in qbasic in high school...
00:07:16 <Squarism> xormor, i did 3d drawing programing in Turbo Pascal using FFI to assembler to enter random rotation mode of the models in 3d. Totally pointless but very time consuming for an 18 year old wo a clue. 
00:14:39 <sqooq> mfw all computers do is math
00:16:56 <xormor> sqooq, yes. I know basic Junior High School and High School math like a¬≤+b¬≤=c¬≤, c=sqrt(b¬≤+a^)
00:17:07 <xormor> and x^n+y^n=z^n
00:17:12 <xormor> Pythagoras and Fermat
00:17:32 <sqooq> learn math
00:19:00 <[exa]> all computers do is computing numbers
00:19:05 <[exa]> (completely unrelated to math)
00:19:18 * [exa] </troll>
00:24:03 <tdammers> computers can't do math
00:24:19 <tdammers> math is about infinite things, computers are finite state machines
00:26:02 <tdammers> HaskellLord69: http://hackage.haskell.org/packages/tag/graphics <- re "Haskell can't do graphics"
00:26:22 <ertes-w> ello
00:26:42 <ertes-w> what does "do math" even mean?
00:26:48 <xormor> tdammers, computers are Turing machines that operate with and upon symbols.
00:27:14 <ertes-w> computing is just as much "doing math" as algebraic reasoning
00:27:16 <tdammers> xormor: one problem though; the original Turing machine has an infinite supply of tape, computers don't
00:28:36 <tdammers> xormor: so when we use the term "Turing Complete" to describe real machines, we handwaive this concern; what we really mean in such cases is "if we ignore the fact that the machine has finite memory and exists in a finite universe, then it qualifies as Turing Complete"
00:29:25 <Squarism> cant one say arithmetics is parts of math? =D
00:29:32 <ertes-w> tdammers: a computer can be constructed such that, if it runs out of memory, it blocks waiting for the operator to insert more RAM
00:29:45 <ertes-w> you just need a cleverer addressing scheme
00:30:20 <tdammers> ertes-w: right... that's assuming you have either infinite RAM production capacity, or infinite amounts of time
00:30:32 <tdammers> ertes-w: but in practice, it looks like you have neither
00:31:03 <ertes-w> tdammers: that's not the point‚Ä¶  the computer itself is a real turing machine, but it may need more memory than you can provide
00:31:29 <ertes-w> "if you ask me to compute huge/infinite things, i will, but be prepared to pay for it"
00:32:04 <tdammers> well, considering that the universe will eventually come to a halt one way or another, *all* problems are halting in practice
00:32:27 <ventonegro>  https://en.wikipedia.org/wiki/Computer-assisted_proof#List_of_theorems_proved_with_the_help_of_computer_programs
00:32:31 <tdammers> so our computer is theoretically Turing Complete, but not practically
00:32:54 <tdammers> then again, theoretical Turing Completeness covers all the interesting qualities anyway
00:33:31 <tdammers> if an algorithm is guaranteed to run in finite time, then there's a chance we can, at some point, optimize it down to a reasonable time scale
00:33:40 <ertes-w> exactly‚Ä¶  you still can't write a theoretical turing machine that could check even for a practical turing machine whether it halts
00:34:01 <tdammers> if it's not, then no amount of optimization will help, because no matter how much finite resources or time we throw at it, it may run longer than the lifetime of the relevant host system
00:34:43 <tdammers> in practice, we don't need to know whether something runs indefinitely, we just need to know whether it will terminate before some deadline
00:35:00 <[exa]> still "doing math" is mostly about laughing how e.g. bolzano-weierstrass theorem is actually dumb after you get it
00:35:21 <tdammers> and in fact, there are a few things that are guaranteed to halt, but still take long enough to run in practice that they exceed the deadline
00:35:36 <tdammers> cryptographic hashes like bcrypt, for example
00:36:36 * hackagebot digit 0.5.1 ‚Äì A data-type representing digits 0-9 and other combinations ‚Äì https://hackage.haskell.org/package/digit
00:36:46 <ertes-w> "doing math" is mostly cryptanalysis‚Ä¶  trying to understand the broken terminology, disambiguate the ambiguous notation and infer the missing quantfiers of badly written papers‚Ä¶  that's what math really is about
00:48:54 <saurabhn_> does ByteString not have ToJSON instances?
00:49:23 <merijn> What would the JSON of a ByteString even be? Does JSON even allow for binary data?
00:49:24 <tdammers> how could it?
00:49:35 <opqdonut> base64 >:)
00:49:50 <tdammers> base64 is one possible representation, but there is no canonical one
00:49:54 <merijn> opqdonut: I'll file that under "extra reasons to hate JSON"
00:49:54 <opqdonut> yeah
00:50:13 <saurabhn_> ummm... I'm getting a ByteString from a Wreq call, and need to pass it on to another service...
00:50:29 <tdammers> another possible representation would be an array of numbers
00:50:30 <saurabhn_> ... why do I need to encode it as Text only to immediately decode it back to a ByteString?
00:50:45 <opqdonut> saurabhn_: you can obviously write your own ByteString -> Value function
00:50:52 <opqdonut> for your use case
00:51:17 <ventonegro> saurabhn_: How do you POST it to the service?
00:51:32 <saurabhn_> opqdonut: won't really work. Value = ... String !Text ....
00:51:40 <opqdonut> saurabhn_: oh right
00:51:43 <saurabhn_> ventonegro: via Wreq
00:51:53 <saurabhn_> get data via Wreq and post it to another HTTP endpoint via Wreq
00:52:06 <cocreature> well json is a textual format, bytestrings are binary data. so somewhere you need to do a conversion if you want to send json
00:52:22 <saurabhn_> seems like a perf-killer.
00:52:24 <cocreature> if you don‚Äôt insist on sending json, you can avoid the conversion
00:52:31 <saurabhn_> hoe expensive is BSL -> Text conversion?
00:52:52 <cocreature> I would be surprised if the bottleneck in your application is decoding bytestrings
00:53:21 <ventonegro> saurabhn_: Sorry, I meant how does the service consume it via HTTP... base64?
00:55:10 <saurabhn_> ventonegro: the other service that I'm posting it to? Just reads a JSON from the HTTP body.
00:55:58 <ventonegro> saurabhn_: Since binary data is not a JSON type, you must agree on an encoding somehow, right?
00:56:20 <saurabhn_> utf-8 -- if that's what you're askng
00:56:35 <merijn> saurabhn_: binary data can't be utf-8 encoded, since it's not unicode
00:57:11 <merijn> utf8 is what (well, one of the options) you use to encode unicode text into binary data
00:57:49 <saurabhn_> so, net-net -- can't take a bytestring from one wire and throw it to another wire?
00:58:05 <merijn> saurabhn_: You can, but not as JSON, because that makes no sense
00:58:28 <merijn> "can I take a binary blob and dump it to another socket?" 'sure'
00:58:45 <ventonegro> Well, it's not really a wire, it's HTTP, which is a protocol encoded as text
00:58:47 <merijn> saurabhn_: You're claiming to get a binary blob and want to send it to something that expects JSON. That doesn't work
00:59:33 <ventonegro> HTTP -> JSON
00:59:40 <merijn> saurabhn_: Because JSON doesn't support binary data. So you need to either decode the binary data and encode the data inside as JSON. Or you encode the binary data as text using, for example, base64 encoding
00:59:57 <cocreature> if you don‚Äôt insist on sending json, you can avoid the conversion
01:00:19 <merijn> cocreature: Or if you start insisting on not receiving binary data :p
01:00:31 <cocreature> right
01:00:52 <saurabhn_> forget it... BSL -> Text, it is...
01:02:30 <merijn> saurabhn_: More likely, in my opinion, is that you're confusing encodings, etc. and not telling us exactly what you're getting from where
01:07:36 * hackagebot htoml-megaparsec 1.0.1.1 ‚Äì Parser for TOML files ‚Äì https://hackage.haskell.org/package/htoml-megaparsec
01:28:18 <jophish> Does anyone know who /u/ElvishJericho is?
01:33:09 <Ferdirand> should we ?
01:43:29 <mivael> hello all
01:43:40 <mivael> > let  isDigit1, isDigit2 :: Char -> Bool;  isDigit1 = f b1;  isDigit2 = f b2;  f b ch = b $ ord ch - ord '0';  b1 n = (n >= 0) && (n <= 9);  b2 n = (fromIntegral n :: Word) <= 9  in  (isDigit1 '0', isDigit2 '0')
01:43:44 <lambdabot>  (True,True)
01:44:55 <mivael> Should I expect that isDigit1 and isDigit2 are identical regarding performance?
01:46:02 <merijn> mivael: No clue. Also, why would you bother implementing isDigit, given it already exists?
01:47:02 * hackagebot concurrency 1.2.1.1 ‚Äì Typeclasses, functions, and data types for concurrency and STM. ‚Äì https://hackage.haskell.org/package/concurrency
01:47:30 <mivael> merijn, I would not, except for the case if I needed an efficient implementation of isNonzeroDigit
01:48:12 <mivael> (as far as I know there is no such one)
01:48:55 <cocreature> mivael: "\c -> c /= '0' && isDigit c" is not sufficiently efficient?
01:51:30 <mivael> cocreature, ah, I think it is :)    (the ::Word trick would not work in this case anyway)
01:52:52 <mivael> I'm still curious why isDigit2 way is used here: http://hackage.haskell.org/package/base-4.10.0.0/docs/src/GHC.Unicode.html#isDigit
01:53:39 <mivael> Does that hint us that isDigit1's way is probably not efficient enough?
01:55:28 <mivael> merijn, I really should not bother implementing isDigit, my first question was a mistake
01:55:43 <jonge> hey i am going to implement an XML REST client library for an internal project. what is the best xml parser lib to use there?
01:56:02 <jonge> if it can nicely generate xml, too, that would be great.
01:56:36 <ertes-w> jonge: xml-conduit
01:57:23 <jonge> ertes-w: i have the impression that anything conduit related is good for processing masses of data with flat memory consumption. but the xml documents will be always small and trivially fit into memory.
01:57:35 <jonge> or is xml-conduit apart from that also very elegant for simple parsing of small docs?
01:57:55 <cocreature> jonge: you can mostly ignore the -conduit part
01:58:01 <merijn> jonge: xml-conduit is still nice
01:58:05 <cocreature> it‚Äôs there but I‚Äôve never used it
01:58:13 <jonge> ok i see. thank you, i will give it a try.
01:58:20 <jonge> thank you both ertes-w and cocreature
01:58:23 <merijn> jonge, ertes-w: Although I have to admit it doesn't work well if you have a fixed schema
01:58:35 <merijn> xml-conduit is more for schemaless XML and scraping data
01:58:45 <merijn> Since it has no validation, etc.
01:59:09 <ertes-w> well, the best way to handle XML is to convert it to JSON
01:59:19 <merijn> jonge: FWIW, I used it's little brother html-conduit (which has basically the same API) for scraping webcomics, so it works fine for small documents too :)
01:59:37 <jonge> hehe i see. thx for the input. :)
01:59:43 <ertes-w> i've come to think of XML as "enterprise" bullshit
01:59:59 <jonge> ertes-w: i agree. but the api i need to use is an xml one.
02:01:26 <ertes-w> jonge: xml-conduit should serve you well there, though as merijn points out you'll basically have to extract the data yourself
02:02:00 <jonge> ertes-w: i guess that will be fine. all the api calls will give me certain fields of data i'm interested in - and if these don't work i am fucked anyway.
02:03:07 <ertes-w> jonge: there is also xml-lens, which could help with the extraction part, but you'll have to check whether it still works‚Ä¶  last update was in 2015
02:32:29 * hackagebot data-diverse-lens 0.4.0.0 ‚Äì Isos & Lens for Data.Diverse.Many and Prisms for Data.Diverse.Which ‚Äì https://hackage.haskell.org/package/data-diverse-lens
02:34:32 <michalrus> nshepperd: oooooh! It is! Map.generateA. Thank you. :]
02:53:03 * hackagebot tasty-dejafu 0.7.0.2 ‚Äì Deja Fu support for the Tasty test framework. ‚Äì https://hackage.haskell.org/package/tasty-dejafu
02:53:04 * hackagebot hunit-dejafu 0.7.0.2 ‚Äì Deja Fu support for the HUnit test framework. ‚Äì https://hackage.haskell.org/package/hunit-dejafu
02:55:41 <mantasg> Hi guys. I'm trying to do heap profiling focusing on certain modules but having little success so far. 
02:55:41 <mantasg> First of all I compiled my application using "stack build -- my-application --profile"
02:55:41 <mantasg> Then I'm trying to run "stack exec -- my-application  +RTS -hmApplication" where Application is the module name. However that doesn't write out *.hp file as I would expect. Using -h flag produces output but it doesn't limit results to one module I'm interested in.
02:56:45 <mantasg> Does anyone have experience with memory profiling that could help me?
03:21:38 <science> hi all wtf is this code doing ?  
03:22:00 <science> >length' xs = sum [1 | _ <- xs]
03:22:42 <science> there lambdabot
03:22:45 <science> ??
03:23:06 <fakenullie> looks like some educational implementation of length
03:23:31 <science> fakenullie:  it is a snippet from learn you haskell book
03:23:36 <science> I am not understanding that
03:24:00 <tsahyt> science: it creates a list of 1s, one 1 for each element in xs, and then sums them up
03:24:07 <tsahyt> so it's the length of xs
03:24:13 <fakenullie> read about list comprehensions
03:24:37 <Cale> > [1 | x <- ["hello", "there", "world"]]
03:24:39 <lambdabot>  [1,1,1]
03:24:44 <Cale> > [1 | _ <- ["hello", "there", "world"]]
03:24:48 <lambdabot>  [1,1,1]
03:24:49 <tsahyt> > sum (map (\_ -> 1) xs)
03:24:53 <lambdabot>  error:
03:24:53 <lambdabot>      ‚Ä¢ Variable not in scope: xs :: [a0]
03:24:53 <lambdabot>      ‚Ä¢ Perhaps you meant one of these:
03:24:55 <tsahyt> yes
03:24:58 <tsahyt> > sum (map (\_ -> 1) [1..10])
03:25:03 <lambdabot>  10
03:25:19 <cocreature> mantasg: afaik you can‚Äôt limit profiling to specific modules
03:25:37 <tsahyt> although I think this isn't exactly what it desugars to, but it's equivalent
03:26:19 <mantasg> cocreature: but the GHC docs (https://downloads.haskell.org/~ghc/8.0.2/docs/html/users_guide/profiling.html) say: "-hm ‚ü®module‚ü© Restrict the profile to closures produced by the specified modules."
03:26:22 <ertes-w> science: to the left of '<-' is a pattern, and patterns always support the unnamed wildcard '_'
03:26:25 <tsahyt> > sum ([1..10] >>= \_ -> return 1)
03:26:28 <lambdabot>  10
03:26:33 <tsahyt> I think this should be it
03:27:03 <fakenullie> > foldr (+1) 0 "Hello, world!"
03:27:06 <lambdabot>  error:
03:27:06 <lambdabot>      ‚Ä¢ Couldn't match type ‚ÄòChar‚Äô with ‚Äòb -> b‚Äô
03:27:06 <lambdabot>        Expected type: [b -> b]
03:27:10 <cocreature> mantasg: oh ok, wasn‚Äôt aware of that feature. sry not sure what‚Äôs going wrong for you
03:27:47 <mantasg> Yeah, I'm a bit baffled. The modules i'm trying to profile are in library, not executable
03:27:54 <mantasg> Maybe something to do with that
03:28:11 <science> > length' xs = [1 | _ <- ["hello","haskell"]
03:28:14 <lambdabot>  <hint>:1:12: error:
03:28:14 <lambdabot>      parse error on input ‚Äò=‚Äô
03:28:14 <lambdabot>      Perhaps you need a 'let' in a 'do' block?
03:28:28 <science> > length' xs = [1 | _ <- ["hello","haskell"]]
03:28:31 <lambdabot>  <hint>:1:12: error:
03:28:31 <lambdabot>      parse error on input ‚Äò=‚Äô
03:28:31 <lambdabot>      Perhaps you need a 'let' in a 'do' block?
03:28:49 <science> Thanks all I understand but I get some error
03:29:06 <ertes-w> > let length' xs = [1 | _ <- ["hello", "haskell"] ] in length' ["this", "list", "is", "unrelated"]
03:29:09 <lambdabot>  [1,1]
03:29:34 <Cale> science: lambdabot needs expressions, if you want to give it declarations, prefix them with @let
03:29:58 <science> >let length' xs = [1 | _ <- ["hello","haskell"]]
03:30:05 <Cale> (or you can use  let <decls> in <expr> )
03:30:20 <Cale> @let length' xs = [1 | _ <- xs]
03:30:23 <lambdabot>  Defined.
03:30:29 <science> >@let length' xs = [1 | _ <- ["hello","haskell"]]
03:30:34 <science> why like that Cale 
03:30:35 <Cale> No >
03:30:47 <science> @let length' xs = [1 | _ <- ["hello","haskell"]]
03:30:49 <lambdabot>  .L.hs:164:1: warning: [-Woverlapping-patterns]
03:30:49 <lambdabot>      Pattern match is redundant
03:30:49 <lambdabot>      In an equation for ‚Äòlength'‚Äô: length' xs = ...
03:30:50 <Cale> Just because lambdabot commands normally start with @
03:31:01 <Cale> Ah, that's an error now, because I defined length' already for you
03:31:09 <Cale> @undefine -- we can clear the definitions like this
03:31:09 <lambdabot> There's currently no way to undefine just one thing.  Say @undefine (with no extra words) to undefine everything.
03:31:13 <Cale> @undefine
03:31:13 <lambdabot> Undefined.
03:31:15 <Ferdirand> > foldr (const (+1)) 0 "Hello, world!"
03:31:19 <lambdabot>  13
03:37:36 <Profpatsch> I wonder how the auhor of LYAH feels about it being constantly bashed by people
03:37:41 <Profpatsch> *author
03:43:38 <mivael> Guys, I need a little help with Parsec please...
03:43:46 <mivael> Is there a (sepBy)-like function with additional (count)-like functionality in Text.Parsec?  Or I need to write my own?
03:44:00 <mivael> I mean that I would want to parse exactly thisMany instances specified by parserElem, so that any two neighboring instances are separated by single delimiter specified by parserDelim.
03:45:25 <cocreature> mivael: you‚Äôre probably going to have to write your own
03:48:10 <cocreature> mivael: take a look at the implementation of sepBy and sepBy1. if you modify them to use "count" instead of "many" you should get what you want
03:48:21 <cocreature> (and some special handling for the zero case)
03:48:37 <mauke> nSepBy 0 _ _ = pure []; nSepBy 1 p _ = fmap (: []) p; nSepBy n p sep = liftA2 (:) p (sep *> nSepBy (n - 1) p sep)
03:48:40 <michalrus> ‚ÄúIO version of newTChan. This is useful for creating top-level TChans using unsafePerformIO, because using atomically inside unsafePerformIO isn't possible.‚Äù
03:48:45 <michalrus> Why are they even suggesting that? :(
03:50:40 <Cale> michalrus: Well, I wouldn't take it as a suggestion :)
03:51:09 <Cale> But if you ever actually find yourself backed into that corner, it's better than nothing.
03:51:16 <michalrus> Hm, hmmmm.
03:51:32 <michalrus> OK. :]
03:56:01 <cocreature> getting global variables by unsafePerformIOing their initialization can be tempting but it usually comes back to bite you (as global variables usually do)
04:00:27 <mivael> cocreature, it was a nice idea to look into the sources.  Thank you.  On the other hand, now I have more questions than before :)   I mean that I do not understand how this sepBy implementation works with <|> byt without (try ...).
04:01:41 <mivael> mauke, I like how it looks!  Struggling to understand the "liftA2 (:)" part so far...
04:02:27 <mivael> mauke, understood.  Thank you very much!
04:02:33 <Cale> mivael: liftA2 (:) x y = do v <- x; vs <- y; return (v:vs)
04:02:37 <mauke> mivael: liftA2 f px py = do { x <- px; y <- py; return (f x y) }  basically, more or less
04:03:03 <mivael> yeah, got it already
04:03:11 <tdammers> the problem isn't just that they're global
04:03:45 <tdammers> if you have multiple threads accessing that variable, you may even end up with multiple TChans
04:04:15 <mivael> cocreature, s/byt without/but without/
04:05:58 <cocreature> mivael: sepBy leaves the responsibility of wrapping things in try to the user, i.e., the parser that are passed to it
04:06:29 <cocreature> so you‚Äôre completely right that if those parsers consume input on failure, sepBy will consume that input as well
04:06:55 <mivael> cocreature, understood
04:07:51 <cocreature> eh actually I think I‚Äôm wrong, if those parsers consume input on failure, sepBy will fail as well
04:08:01 <cocreature> since <|> only uses the right side if the left fails without consuming input
04:08:25 <phadej> depends on the library, whether it backtracks automically or not
04:08:41 <cocreature> right, we‚Äôre talking about parsec here
04:17:21 <mivael> cocreature, now I'm confused.  Do you think the sepBy implementation won't work even if its users wrap the arguments in 'try'?
04:21:31 <cocreature> mivael: it depends on what you mean by work: 1. if the parsers that you pass to sepBy fail but consume input, then sepBy will fail as well instead of returning zero elements 2. if the parsers that you pass to sepBy fail without consuming input (e.g. because you‚Äôve wrapped them in "try") sepBy will return an empty list
04:26:43 <mivael> cocreature, behaviour #2 is consistent with my understanding of "work" :)  my understanding of consequences of behaviour #1 is that using sepBy with non-wrapped parsers must be avoided
04:28:13 <cocreature> mivael: you might have a parser that sometimes fails without consuming input but if a certain prefix of it matches, you want it to be an error for the rest to not be present
04:28:28 <cocreature> so instead of simply parsing an empty list, you want to produce an error in that case
04:32:53 <[exa]> Hm guys, is there some reasonable library/framework for parsing&processing sparql queries?
04:33:30 <[exa]> (target: I have a non-rdf data source and want to make it discoverable)
04:35:13 <hexagoxel> is it specified how MMR/defaulting works with non-*-kinded types? i just noticed an instance of ts :: [*] getting defaulted to '[].
04:40:35 <mivael> cocreature, can the following example be regarded as an example of practical usage of the behaviour?  Say, we are parsing decimal integers, separated by a comma.  The parser of an integer fails with consuming input if the number of digits exceeds certain value.  Thus, sepBy will also fail.
04:41:07 <cocreature> mivael: yeah that seems like a good example
04:46:34 <hexagoxel> and, if it is not specified, is that not bad? seems straightforward to construct examples where different choices all type-check but have different behaviour.
05:06:50 <hexagoxel> (ah, it might be nothing more than a bug in 8.0.2)
05:23:44 * hackagebot derive-topdown 0.0.0.7 ‚Äì Help Haskellers derive class instances for composited data types. ‚Äì https://hackage.haskell.org/package/derive-topdown
05:35:08 <dminuoso_> Does Void contain _|_?
05:35:14 <merijn> dminuoso_: Yes
05:35:32 <merijn> dminuoso_: _|_ is a member of every type
05:35:38 <dminuoso_> merijn: ah, that explains why `absurd bottom` typechecks. 
05:35:55 <fearless_man> what is the offtopic for haskell?
05:35:59 <merijn> dminuoso_: In fact, the only way to get rid of that is to sacrifice Turing completeness :)
05:35:59 <dminuoso_> merijn: Yeah, was just curious whether Void was special in that regard.
05:36:09 <merijn> fearless_man: Depends on how busy it is :p
05:36:37 <merijn> fearless_man: Anything tangentially related to functional programming, type theory, programming, and occasionally category theory works
05:37:04 <fearless_man> merijn: I'm asking for the name of the channel =)
05:37:16 <dminuoso_> merijn: so `absurd` is not so absurd after all. I mean if Void is not empty, then absurd is not the empty function
05:37:20 <merijn> fearless_man: Oh #haskell-blah or #haskell-offtopic
05:37:40 <fearless_man> merijn: are you joined there?
05:38:12 <merijn> fearless_man: Both for me :p
05:38:23 <fearless_man> I just want to ask non-haskell but related to fp
05:46:03 <tdammers> dminuoso_: Void, like all Haskell types, is a lie
05:46:10 <tdammers> dminuoso_: exactly because of bottom
05:46:24 <merijn> tdammers: But it's a morally correct lie!
05:46:31 <tdammers> dminuoso_: so when we say "Void is the empty type", we do so in the understanding that we're pretending bottoms don't exist
05:47:07 <tdammers> merijn: in order to decide that, we first need to derive formal ethics
05:47:30 <tdammers> merijn: but in order to do that, we first need to show that our method for deriving formal ethics is morally correct
05:48:52 <DigitalKiwi> since when is programming about morals
05:49:52 * hackagebot async-refresh-tokens 0.3.0.1 ‚Äì Package implementing core logic for refreshing of expiring access tokens ‚Äì https://hackage.haskell.org/package/async-refresh-tokens
05:49:57 <cocreature> at some point I should read that paper in the hope that it makes it‚Äôs more than suffisticated handwaving
05:50:06 <cocreature> *sophisticated
05:50:55 <merijn> DigitalKiwi: It's a reference to a paper
05:51:25 <merijn> cocreature: It *is* a bit more than sophisticated handwaving
05:51:48 <DigitalKiwi> it's highly sophisticated hand waving
05:52:21 <Psybur> Whats this paper
05:52:37 <cocreature> ‚Äúfast and loose reasoning is morally correct‚Äù
05:53:24 <stevenxl> Hi folks. In a haskell project, what is a "target"? Someone said that a Haskell project can have multiple targets and I'm not sure what that means.
05:53:28 <merijn> cocreature: Basically the argument boils down to "the conclussion arrived at by pretending your language is total always hold in the non-total version, assuming non-bottom inputs"
05:54:03 <cocreature> merijn: that does indeed seem like a reasonable argument
05:54:08 <merijn> cocreature: So it proves that proves based on handwaving away bottom are actually true, if none of your inputs are bottoms
05:54:18 <merijn> s/proves based/proofs based
05:55:19 <tdammers> stevenxl: a project might, for example, contain a library, a test suite, and one or more executables
05:55:59 <merijn> cocreature: So it's basically a paper proving the transferability of proofs in a total subset to the original language is valid, as long as we add conditions about non-bottom inputs to the transferred proofs
05:56:07 <tdammers> stevenxl: http://hackage.haskell.org/package/ginger-0.7.1.0/ginger.cabal <- look at this, for example
05:56:29 <mauke> stevenxl: something that can be built
05:56:35 <tdammers> three targets: library (implicitly named ginger, like the project), an executable (also named ginger, but explicitly), and a test suite
05:56:58 <stevenxl> tdammers: Thank you. Very clear example. 
05:57:02 <merijn> tdammers: You forgot that a package can have multiple test-suites (and also multiple benchmark suites)
05:57:06 <stevenxl> So the idea is that each of those targets can be compiled yes?
05:58:03 <mauke> the name probably derives from https://www.gnu.org/software/make/manual/make.html#Rule-Introduction
05:58:55 <byorgey> stevenxl: yes, each of them can be built in some way, which probably involves compilation
05:59:38 <stevenxl> i see. 
05:59:53 <stevenxl> Thank you @byorgey @mauke @tdammers 
06:00:49 <tobiasBora> Hello,
06:00:54 <tobiasBora> I'd like to know,
06:01:24 <tobiasBora> I've a function f that goes into "Either String a"
06:01:32 <hexagoxel> stevenxl: also note the term "component". target is just the component you choose to build.
06:01:56 <hexagoxel> at least that's what the cabal user guide uses..
06:02:30 <stevenxl> hexagoxel: Thank you. Yea I'm all about using the correct language. If that is what is in common usage, very helpful to know.
06:03:58 <sphinxo> Best way to create a list like [0,0,1] from ["a", "b", "c"] and "c"
06:04:49 <hexagoxel> map (boolToInt . (=="c"))
06:04:58 <tobiasBora> I've a function f that goes into "Either String a" and I'd like to use it in a structure that needs to output "IO (Either String b)". For now I do a very dirty thing with like "let a = f ... in case a of Left e -> return e; Right s -> ..." is it possible to write a better code ?
06:05:32 <sphinxo> hexagoxel: boolToInt?
06:05:52 <lyxia> tobiasBora: ExceptT
06:06:34 <hexagoxel> sphinxo: e.g. fromEnum
06:07:18 <hexagoxel> > map (fromEnum . (=="c"))  ["a", "b", "c"]
06:07:19 <nicknight> hi guys
06:07:20 <lambdabot>  [0,0,1]
06:07:28 <sphinxo> ahh wonderful, that makes sense
06:07:29 <sphinxo> thanks
06:07:35 <tobiasBora> lyxia: this means that I need to replace all my IO with exceptT ???
06:08:43 * hackagebot saltine 0.1.0.0 ‚Äì Cryptography that's easy to digest (NaCl/libsodium bindings). ‚Äì https://hackage.haskell.org/package/saltine
06:10:31 <cocreature> tobiasBora: if you only have that one case statement, just go with it. ExceptT is useful if you have a lot of "IO (Either e a)" and want to shortcircuit on Left. for a single case statement, there‚Äôs basically no benefit
06:11:44 <tobiasBora> cocreature: Well, I have a lot of them, but my code has been constructed everywhere using "IO (Either e a)", so I'm wondering if I need to change all my code or not.
06:12:26 <cocreature> if you want the behavior of ExceptT, you‚Äôre going to have to change your code
06:14:00 <merijn> How do readFile/hGetContents deal with platform specific newlines?
06:14:16 <merijn> Do they get converted or do I get some random ass mix of \r and \n ?
06:14:35 <tobiasBora> cocreature: Hum... Can I use runExceptT (ExceptT (...)) to have what I want ?
06:14:52 <cocreature> tobiasBora: that‚Äôs a noop
06:15:13 <cocreature> tobiasBora: you need to get GHC to use the Monad instance of ExceptT
06:15:13 <tobiasBora> what does it mean ?
06:15:21 <cocreature> noop = doesn‚Äôt do anything
06:16:20 <xormor_> NOOP in assembly.
06:16:27 <xormor_> NoOp=No Operation
06:16:59 <dminuoso_> xormor_: in assembly there is no noop technically. :|
06:17:04 <nicknight> damn I feel so dumbb......I didn't realise x <- [1,2,3] is same same x ‚àà [1,2,3] for one week I thought it is weird syntax but now I understand haskell very close to maths
06:17:20 <[exa]> nop = advance IP to next instruction
06:17:24 <dminuoso_> ^-
06:23:18 <tobiasBora> cocreature: So I can't turn back an ExceptT into an IO (Either String a) ?
06:23:41 <hexagoxel> :t runExceptT
06:23:42 <lambdabot> ExceptT e m a -> m (Either e a)
06:23:50 <hexagoxel> tobiasBora: ^
06:26:05 <tdammers> merijn: true. was giving examples, not an exhaustive list of possibilities.
06:26:57 <tobiasBora> hexagoxel: I don't understand, cocreature just told me that using runExceptT is a "NOOP"
06:27:55 <hexagoxel> tobiasBora: runExceptT . ExceptT is the noop
06:28:44 <hexagoxel> runExceptT $ do { ‚Ä¶ ; ExceptT ‚Ä¶ ; ‚Ä¶ } is not
06:31:31 <tobiasBora> hexagoxel: can you give me an example when I use f : a -> Either String b; and g : c -> IO (Either String d) ? I'm not familiar with this, and my brain don't like it...
06:32:19 <hexagoxel> b == c?
06:32:27 <tobiasBora> (we can suppose that b = c, that we have a "a" value at the beginning, and that we want at the end a Either String d
06:36:08 <hexagoxel> \a -> runEitherT $ do { b <- hoistEither (f a); EitherT (g b) }
06:36:34 <hexagoxel> using EitherT because ExceptT doesn't even have hoistEither.
06:39:19 <tobiasBora> great thank you, I'll study this !
06:40:54 <hexagoxel> tobiasBora: there are some of these minor difference in the interfaces of EitherT vs ExceptT, and i generally prefer the EitherT one. But you can make either work.
06:56:29 <merijn> Fun times...my parser gets stuck and I get to figured out why...yay...
06:58:31 <osa1> left recursion of course :-p I had once modified my parser to push a different integer to parsec's state in each parser so that I could debug when it started looping
06:59:57 <merijn> osa1: Naah, I'm stuck with a dumbass parallel parsers (i.e. ReadP)
07:00:08 <osa1> ooh, good luck then :)
07:00:20 <osa1> use Debug.Trace.trace :)
07:00:55 <merijn> I probably just hae to get rid of all uses of "many"
07:06:12 <shapr> what's the most elegant parsing library in Haskell?
07:06:24 <merijn> shapr: Define elegant?
07:06:25 <shapr> coworker is asking me for something motivational to inspire him to learn Haskell
07:06:46 <merijn> shapr: Probably Megaparsec, attoparsec, and trifecta are the main ones atm, I think
07:08:36 <osa1> megaparsec is pretty good
07:12:51 <ertes-w> shapr: i have started turning my usual hangman exercise into a tutorial for pure interaction design
07:13:19 <ertes-w> shapr: although it's not a tutorial into haskell
07:13:25 <shapr> is the code online?
07:13:38 <ertes-w> not yet
07:14:50 * hackagebot viewprof 0.0.0.10 ‚Äì Text-based interactive GHC .prof viewer ‚Äì https://hackage.haskell.org/package/viewprof
07:18:42 <srk> cool
07:21:34 <nicknight> shapr:  I think you should tellyour cowroker motivation should come on own ?
07:23:14 <nicknight> I feel no one can motivate me unless I am motivated...Motivation come from our desires/goals 
07:23:43 <fakenullie> buy him the haskell book
07:25:17 <bodisiw> can anyone help me fix `Failed to load interface for ëGraphics.Rendering.OpenGL.Rawí`?  `cabal install OpenGLRaw` says 'All the requested packages are already installed: OpenGLRaw-3.2.5.0'
07:25:54 <bodisiw> i cloned `https://github.com/dagit/nehe-tuts` and ran `stack run`
07:26:03 <shapr> nicknight: that's a good point
07:28:29 <kody^> noob here. what's the difference between a dependent type and a higher kinded type?
07:28:55 <merijn> kody^: Are you familiar with kind signatures, like "Maybe :: * -> *"?
07:30:10 <kody^> merijn: yes
07:30:41 <merijn> Right, so "higher-kinded" refers to "kind that take kinds other than *"
07:31:02 <merijn> kody^: So "Maybe :: * -> *" only deals with things of kind *
07:31:17 <merijn> kody^: But, for example "StateT :: * -> (* -> *) -> * -> *"
07:31:46 <merijn> kody^: So StateT takes a type with a kind other than * (a type with kind * -> * to be precise), which makes StateT higher-kinded
07:31:55 <kody^> merijn: so that means that Maybe takes a type and gives out a type, correct?
07:32:00 <merijn> kody^: Correct
07:32:07 <kody^> thats the same as a dependent type, no?
07:32:42 <Yotam_> in "instance Foo a where..." How can I force a to have type x->y?
07:32:44 <kody^> thanks for explaining what higher-kinded means
07:32:45 <merijn> A slightly simpler thing than StateT might be "data Foo f = MkFoo (f Int)" here 'f :: * -> *' (it's applied to Int afterall), so logically 'Foo :: (* -> *) -> *"
07:33:00 <ertes-w> kody^: a dependent type is a type that takes *values*
07:33:03 <lyxia> bodisiw: use either cabal or stack, not both
07:33:32 <bodisiw> lyxia, i think the issue here is that this .cabal doesn't specify versions for those libraries, and the code was written against older versions
07:33:38 <ertes-w> kody^: Vector :: Natural -> * -> *  -- in a hypothetical super-haskell this would be possible‚Ä¶  it takes both a value (a natural) and a type
07:33:41 <kody^> ertes-w: not sure what you mean..
07:33:50 <bodisiw> lyxia, also that advice has never worked out for me!
07:34:01 <ertes-w> kody^: note in particular that HKTs are possible in haskell, but dependent types are not
07:34:13 <bodisiw> especially when i clone a repo and see both stack.yaml and whatever.cabal
07:34:30 <merijn> kody^: No, dependent types deal with the fact you can have values inside your types, which let's you write types like "{a : Int} -> if a < 3 then Bool else Int" which is a function whose type is "Int -> Bool" if the 'Int' argument is less than 3 or 'Int -> Int' if the 'Int' argument is greather than or equal to 3
07:34:32 <kody^> ertes-w: so a dependent type is a type which has type signature Natural -> * ?
07:35:08 <mnoonan> a type: "Int :: *", another type: "Maybe :: * -> *", a higher-kinded type: "StateT :: * -> (* -> *) -> *", a dependent type: "T :: Bool -> *"
07:35:24 <merijn> kody^: So you can write datatypes/functions where the result type *depends* (hence the name) on the *value* passed into it
07:35:53 <merijn> kody^: Whereas higher-kinded types can't inspect values like that (unless, of course, you have dependent higher-kinded types)
07:35:55 <lyxia> bodisiw: The link you gave has no stack.yaml, and even if it had one it still wouldn't make sense to use both stack and cabal
07:36:14 <lyxia> bodisiw: both use the .cabal file. stack.yaml is a configuration on top of that for stack.
07:36:25 <ertes-w> kody^: a dependent type is something of a kind that has things other than * and (->)
07:36:26 <kody^> thanks a lot merijn and mnoonan 
07:36:33 <ertes-w> kody^: well, not quite
07:36:47 <lyxia> bodisiw: what version of stack are you using where stack run is a command?
07:36:58 <bodisiw> lyxia, it's the one plugin i've added to stack
07:37:20 <bodisiw> `stack build` gives the same error though
07:37:46 <ertes-w> kody^: a polymorphic type is a type that depends on types (something of kind * -> *, for example)‚Ä¶  a dependent type is a type that depends on values (something (hypothetical) of kind Natural -> *)
07:37:55 <merijn> kody^: Here's a good example of how to implement a type-safe "printf" using dependent types: https://www.youtube.com/watch?v=fVBck2Zngjo
07:38:53 <ertes-w> kody^: one feature of a dependently typed language is that the three levels we have in haskell (values, types and kinds) are all collapsed into a single level‚Ä¶  functions can take types as arguments, and types can take values
07:39:30 <kody^> ah so a dependent type takes values of a type and gives out types. while a higher type can take the values as types themselves.
07:39:54 <kody^> So a higher types are dependent types "one level above". Is this right?
07:40:04 <lyxia> bodisiw: add a   < 2   bound on GLURaw
07:40:06 <ertes-w> "higher-kinded type" is a bit overloaded‚Ä¶  usually it just means any type that is not of kind *
07:40:21 <kody^> ertes-w: i see what you mean
07:40:37 <ertes-w> we talk of HKTs mostly in the context of polymorphism:  "higher-kinded polymorphism" means that you can abstract over types of kinds other than *
07:40:51 <ertes-w> :t fold
07:40:52 <lambdabot> (Monoid m, Foldable t) => t m -> m
07:41:03 <bodisiw> lyxia, yeah OpenGLRaw >= 2 && < 3, will add GLURaw < 2 as well and see if it works
07:41:03 <ertes-w> see how the type 't' is of kind * -> *
07:43:36 <kody^> ertes-w: thank you
07:46:17 <ertes-w> kody^: if you want to try dependent typing for yourself, you can't do that in haskell‚Ä¶  languages with dependent types include agda and idris, where the former is more about theorem proving, while the latter is about programming
07:46:23 <bodisiw> lyxia, working now... thanks!
07:47:09 <ertes-w> the closest we get in haskell right now is the TypeInType extension
07:47:57 <ertes-w> that collapses the three levels into two (types and kinds become the same thing)
08:09:21 <kody^> ertes-w: isn't the fact that I can definte types which abstract over types (like Maybe) "stronger" in some sense than dependent typing? so if haskell has the former, why not the latter?
08:15:39 <ertes-w> kody^: dependent types are complicated to implement in a general-purpose language, and they come with a few caveats regarding inference and decidability
08:16:17 <ertes-w> kody^: with DTs the type and value languages are the same, so you actually need to interpret regular code during type checking
08:16:22 <user____2> Greetings Programs
08:16:44 <ertes-w> kody^: if we had DTs a type alias in haskell would look like this:
08:16:50 <ertes-w> TwoBools :: *
08:16:55 <ertes-w> TwoBools = (Bool, Bool)
08:17:11 <ertes-w> in real haskell it looks like this:  type TwoBools = (Bool, Bool)
08:18:39 <Ero2> but with DT's worlds can collide and there will be no prior warning
08:30:34 * hackagebot quickcheck-state-machine 0.2.0 ‚Äì Test monadic programs using state machine based models ‚Äì https://hackage.haskell.org/package/quickcheck-state-machine
08:35:58 <shapr> nicknight: you having fun learning Haskell?
08:49:36 <infandum> Does hmatrix support row and column names?
09:07:42 <sm> morning all
09:11:40 <Vq> Evening sm
09:14:38 <anelson> hi all, does it seem odd to anyone else that the `URI` type from `Network.URI` makes it so easy to construct invalid URIs? If you forget to put a `/` at the beginning of your path, or a `:` at the end of the scheme, then it will render an invalid URI, etc
09:15:46 <c_wraith> anelson: it just parses by the rules in the RFC.  It doesn't try to recover from errors.
09:16:47 <anelson> c_wraith: I'm not really familiar with the RFC, but at the very least it's not injective
09:17:37 <anelson> I don't understand why it wouldn't do things like putting the `/` at the beginning of your path etc
09:19:22 <c_wraith> It's really intended as a parsing library more than a construction library
09:19:38 <c_wraith> It does exactly what the spec says to do with the various parts
09:20:28 <anelson> it seems that you could be spec-compliant without losing type safety
09:20:52 <royal_screwup21> suppose I have a function like so: unique xs = nub xs == xs. What would be an instance when this would return false?
09:21:20 <royal_screwup21> its type definition is: unique :: Eq a => [a] -> Bool
09:22:02 <c_wraith> > let unique xs = nub xs == xs in unique [1,1]
09:22:05 <lambdabot>  False
09:22:20 <royal_screwup21> ah
09:23:29 <c_wraith> royal_screwup21: nub removes duplicates from a list, if that helps
09:23:41 <royal_screwup21> yeah I realized haha
09:23:53 <royal_screwup21> thanks!
09:23:58 <Psybur> It's also fun to call people nub
09:30:43 <orzo> I need a way to instantly flush all events out of a TChan.  Is there a method for that?
09:31:26 <c_wraith> huh.  I don't think so.
09:32:18 <c_wraith> how would it interact with dupTChan?
09:33:12 <c_wraith> I suppose it's doable if it only empties the TChan passed to it, and not any duplicates of it
09:35:04 <orzo> it should be equivelent to readTChan in a loop until the channel is empty
09:35:29 <mauke> more like tryReadTChan in a loop
09:36:05 <c_wraith> So, with TChan, you could actually write that loop and it would have the correct semantics
09:36:12 <c_wraith> thanks to STM, and all
09:36:15 <royal_screwup21> suppose I have list of 81 strings like so: [s1, s2..]. Each string is a cell of a sudoku puzzle. I need to extract 3 x 3 adjacent  "boxes" out of it, so 9 strings per box. My final output should be a list of lists of 9 strings like so: [ [s0...s9], [s0..s9]...]. How do I go about this?
09:37:09 <c_wraith> however, it would be more susceptible to failed transactions due to optimistic locking than a low-level implementation
09:38:57 <orzo> a low-level implentation should avoid looping altogether though
09:38:58 <EvanR> i welcome our new software transactional overlords
09:39:00 <c_wraith> the low-level implementation would be easy to write, except nothing exports the TChan constructor.
09:39:29 <orzo> could probably implement O(1) flushTChan
09:39:56 <c_wraith> Yes, it'd be like 2 lines
09:40:29 <c_wraith> well, 3 + the type signature.
09:45:04 <EvanR> royal_screwup21: there is a "standard" function for this, or are you trying to implement that functino
09:45:57 <royal_screwup21> EvanR: oh I didn't know there was a function for this
09:46:04 <EvanR> yeah
09:46:04 <royal_screwup21> in-built function, that i s
09:46:15 <EvanR> ... well there arent any built in functions
09:46:22 <EvanR> its in a library
09:46:32 <EvanR> Data.List.Split function chunksOf
09:46:48 <EvanR> package named split
09:46:58 <mauke> that doesn't do boxes, just lines
09:47:05 <mauke> or rows, I guess
09:47:34 <EvanR> that confused me... a list of boxes, but the "boxes" are linear lists of cells, not grouped?
09:48:28 <EvanR> "weirdest ways to use a list for stuff"
09:48:48 <royal_screwup21> so a box has should have 9 cells.  Each cells is a string. As such there'd be 9 boxes
09:48:53 <royal_screwup21> cell*
09:49:21 <EvanR> are you sure you dont want a better data type
09:53:42 <EvanR> Actually i already made one of these for something
09:53:57 <EvanR> data Nine a = Nine a a a a a a a a a
09:54:27 <EvanR> Sudoku = Nine (Nine (Maybe Int))
09:54:51 <EvanR> Nine is a Functor, Applicative, Monad, etc
10:00:36 <mniip> EvanR, I would rather use Three
10:03:00 <silas> Hi! I'm willing to return the first 10 values of a preexisting list.  Is this lazy and will calculate only 10 values or will unecessarely calculate all 100 values but print only 10?  let xs = [x | x <- [0..100], odd x]; let first10 = take 10 xs; print(xs)
10:03:01 <c_wraith> the real trick with sudoku is that you want multidimensional access to data.  Computers only naturally provide one dimension of access.  For anything else, you need to have a clever data model
10:03:41 <mauke> silas: it's lazy
10:03:53 <shapr> silas: you could add 1/0 on the end of the list, then see if breaks?
10:04:29 <mniip> c_wraith, ooh I just came up with something
10:04:48 <mauke> > let xs = [x | x <- ([0 .. 19] ++ error "evaluated!"), odd x] in take 10 xs
10:04:51 <lambdabot>  [1,3,5,7,9,11,13,15,17,19]
10:04:58 <mauke> > let xs = [x | x <- ([0 .. 19] ++ error "evaluated!"), odd x] in take 11 xs
10:05:01 <lambdabot>  [1,3,5,7,9,11,13,15,17,19*Exception: evaluated!
10:06:04 <shapr> silas: there's your answer!
10:07:01 <silas> shapr: great!!! thanks!
10:07:11 <shapr> silas: did you try it yourself?
10:07:18 <cocreature> shapr: btw 1/0 is not going to work to test this, that‚Äôs Infinity
10:07:23 <shapr> oh, thanks
10:07:36 <mauke> it's also fractional, so can't odd
10:07:38 <shapr> cocreature: oh HEY, can you explain why > floor (1.0/0.0) does what it does?
10:07:56 <EvanR> :t odd
10:07:58 <lambdabot> Integral a => a -> Bool
10:08:33 <mauke> > odd (1/0)
10:08:38 <lambdabot>  error:
10:08:38 <lambdabot>      ‚Ä¢ Ambiguous type variable ‚Äòa0‚Äô arising from a use of ‚Äòodd‚Äô
10:08:38 <lambdabot>        prevents the constraint ‚Äò(Integral a0)‚Äô from being solved.
10:09:05 <EvanR> Infinity is clearly even
10:09:37 <silas> shapr: yes, with a slightly changed example :-)
10:09:38 <geekosaur> iiirc I tracked that one down the other day to the optimized version working on what amounts to the internal representation, so inf/nan aren't handled at all
10:10:15 <EvanR> :t div'
10:10:17 <lambdabot> (Real a, Integral b) => a -> a -> b
10:10:21 <nisstyre> EvanR: I would agree
10:10:23 <silas> shapr: what would be the functional way to do that without lazy evaluation?  maybe with recursion and an accumulator?
10:10:50 <royal_screwup21> I have a 27 x 3 matrix (built out of lists). I want to reshape it to 9 x9. Is there a library/ built in function for that?
10:11:01 <shapr> silas: you mean, don't calculate a value until it's needed?
10:11:12 <nisstyre> EvanR: https://math.stackexchange.com/questions/49034/is-infinity-an-odd-or-even-number
10:12:12 * hackagebot rethinkdb-client-driver 0.0.25 ‚Äì Client driver for RethinkDB ‚Äì https://hackage.haskell.org/package/rethinkdb-client-driver
10:12:26 <shapr> silas: I'm not sure which "that" you want
10:12:31 <silas> shapr: I actually need to have the first 10 odd numbers beginning from 1.
10:12:39 <cocreature> shapr: looking at the source, floor boils uses decodeFloat which explicitely states that the behavior is undefined if isInfinite is True
10:12:40 <mauke> > chunksOf 9 (concat [[1 .. 27], [28 .. 28+26], [28+27 .. 28+27+26]])
10:12:44 <lambdabot>  [[1,2,3,4,5,6,7,8,9],[10,11,12,13,14,15,16,17,18],[19,20,21,22,23,24,25,26,2...
10:12:48 <geekosaur> that SE sounds like 'unclear on the concept'
10:13:09 <EvanR> œâ + 1 is odd ?
10:13:28 <c_wraith> by that definition, sure.
10:13:44 <EvanR> what definition
10:14:08 <tobiasBora> hexagoxel: Thank you sooo much for the example of EitherT, it's soooo nice to code now :D Maybe I'll finish to like Haskell's monad...
10:14:09 <c_wraith> the one in the first answer on that post
10:14:56 <EvanR> still hasent loaded for me
10:15:55 <c_wraith> the real trick is that "a number" is a huge family of related concepts, and when you get past a very tiny core, you have to get explicit about which concept you're actually talking about.
10:16:28 <silas> shapr: I actually have a function to calculate odd numbers (`odd` in this case, but my true problem is another) and need to generate a list with the first 10 odd numbers.  Without trusting lazy evaluation, I cannot imagine another form other than recursion and using an accumulator to keep track of how many numbers I calculated.
10:16:41 <royal_screwup21> mauk thanks!
10:16:44 <royal_screwup21> mauke*
10:16:57 <EvanR> you should totally rely on lazy evaluation if youre writing haskell
10:17:26 <EvanR> old stylmethods can be really gnarly in haskell
10:18:22 <EvanR> for instance, since you want to avoid lazy evaluation, you cant use a list at all!
10:18:34 <royal_screwup21> mauke actually I'm not a 100% sure if I understood that, but I have a simpler example. Suppose p = ["ab", "cd", "ef", "gh"]. I want to get ["abcd", "efgh"] out of p. How would I do that?
10:18:36 <EvanR> which, on the face of it, sounds silly
10:19:28 <mauke> > chunksOf 4 (concat ["ab", "cd", "ef", "gh"])
10:19:32 <lambdabot>  ["abcd","efgh"]
10:19:50 <royal_screwup21> > chunksOf 2 (concat ["ab", "cd", "ef", "gh"])
10:19:53 <lambdabot>  ["ab","cd","ef","gh"]
10:19:57 <royal_screwup21> > chunksOf 3 (concat ["ab", "cd", "ef", "gh"])
10:20:00 <lambdabot>  ["abc","def","gh"]
10:20:03 <royal_screwup21> ah okay
10:20:09 <royal_screwup21> thanks so much!
10:20:15 <silas> EvanR: I was just curious about how I'd do in a functional language without lazy evaluation.
10:20:32 <EvanR> you would retructure the entirety of the computation
10:20:40 <geekosaur> silas, that will depend on the language and what's most natural in it
10:20:45 <EvanR> or you could emulate lazy evaluation in that language
10:21:02 <geekosaur> in haskell, laziness is natural and other representations of the problem tend to be clunky
10:21:53 <silas> hmmm ok
10:21:56 <silas> thanks!
10:22:58 <silas> mauke: forgot to thank you for the example you gave me.
10:23:13 <mauke> you're welcome :-)
10:25:30 <royal_screwup21> mauke: to use chunksOF, I need to import data.List.split, right?
10:25:34 <royal_screwup21> Of*
10:25:45 <mauke> yeah
10:26:06 <royal_screwup21> Could not find module ‚ÄòData.List.Split‚Äô
10:26:42 <mauke> you may need to install split
10:27:34 <stefy> list
10:28:33 <mauke> ciao
10:28:38 <mauke> another "list" italian
10:28:51 <mauke> why is it always italians?
10:29:00 <royal_screwup21> what's italian?
10:29:02 <stefy> ciao
10:29:59 <mauke> royal_screwup21: people who join, type "list" or "!list", then leave, usually have a .it hostmask
10:30:05 <mauke> i.e. italians
10:30:45 <royal_screwup21> lol
10:31:15 <royal_screwup21> why do italians do that?
10:31:23 <mauke> I have no idea
10:37:21 <Ero2> is hspec widely used?
10:39:20 <srhb> Quite widely.
10:39:38 <srhb> Ero2: https://packdeps.haskellers.com/reverse/hspec
10:44:05 <orzo> Is there any guide to interpretting the "stack trace" given by -xc exceptions?  Particuarly things like "--> evaluated by"
10:45:39 <Ero2> ty srhb 
10:46:00 <geekosaur> orzo, if that's the specific question, I suspect the answer is 'understand STG'
11:05:33 <nicknight> shapr:  sorry was away, yes liking haskell I initially thought its sytax is bit weird bit just today I observed it is more mathematical...Hope and wish I learn it soon
11:06:14 <c_wraith> nicknight: be wary.  If you use haskell too much, you might start wishing other languages put as much effort into making sense. :)
11:09:20 <machinedgod> Or worse, end up hating your job because you start realizing exactly how much your paycheck-language sucks in comparison...
11:09:31 <machinedgod> True story. /unemployed
11:09:43 <mniip> hmm
11:09:44 <shapr> machinedgod: I've been there
11:10:35 <nicknight> c_wraith:  rght now I am using only octave apart from haskell in order to avoid any confusion...but I see now I can write better list comprehensions with python
11:11:02 <shapr> Python's list comprehensions came from Haskell, and Haskell can do WAY more stuff with list comps.
11:11:10 <ystael> machinedgod: Step 1: If your paycheck-language is not yet an acceptable Lispoid (like, say, Ruby), implement an acceptable Lisp. Step 2: Add types. :)
11:11:48 <c_wraith> nicknight: much of haskell was very deliberately designed to make sense when you learn a few basics.  I just wish other languages were designed that way.
11:11:49 <Tuplanolla> I've noticed that the only way to salvage such a situation is if the language is so comically bad that it becomes the focus instead, machinedgod.
11:11:50 <shapr> nicknight: TransformListComp bonus syntax: https://github.com/shapr/tmuxmarta/blob/master/src/Lib.hs#L65
11:12:18 <machinedgod> ystael: I'd say that the bigger issue is mentality that paycheck-languages develop. One can try to keep sanity only that long in an environment where it is perfectly acceptable to throw runtime errors as response to what should've been type errors
11:12:30 <Tuplanolla> Like developing web services with the C preprocessor only.
11:12:38 <nicknight> shapr:  sounds intresting, yesterday I was kinda frustrated but today I decided to do full time haskell and manage my Ml things only with octave with what ever I can
11:13:53 <machinedgod> Tuplanolla: That's not a bad point, although it creates segregation from the rest of the team - which isn't what most of bosses want. You become that weird, disgruntled employee who appears as if he thinks he knows everything better than anyone else.
11:14:55 <ystael> machinedgod: If you're eligible to work in USA, we're hiring! :)
11:15:28 <shapr> ystael: which company?
11:15:43 <machinedgod> ystael: Hahaha, thanks mate, but I'm not ;-) Montreal, Canada over here.
11:15:45 <mniip> hmm
11:16:41 <Ero2> im trying to run 'stack test' for the first time
11:16:45 <shapr> ystael: ah, TVision?
11:17:02 <ystael> shapr: yeah :)  Haskell/Python mix on the back end, most new dev is Haskell.
11:17:43 <Ero2> im getting this error http://lpaste.net/359149 does anyone know what this means?
11:22:25 <Ero2> doees the 'failed to load interface' part have anything to do with a cabal or stack.yaml?
11:22:46 <c_wraith> Ero2: usually that means something was installed improperly
11:24:20 <geekosaur> in this case it looks more complicated
11:24:47 <geekosaur> looks like the dependency between the test suite and the library is incorrect, so it's trying to build the tests without building the library first
11:25:12 <geekosaur> or it didn't otherwise arrange for the library to be properly visible to the test suite
11:25:33 <shapr> too bad Ed is leaving boston
11:25:39 <Ero2> geekosaur: what would i do without you?
11:39:02 <mniip> EvanR, c_wraith check this out
11:39:16 <mniip> @let checkSudoku x=and[r[x^.(c.a.d.b)|(a,b)<-v]|(c,d)<-v]&&and[r[x^.(a.c.b.d)|(a,b)<-v]|(c,d)<-v]&&and[r[x^.(c.d.a.b)|(a,b)<-v]|(c,d)<-v]where f=[_1,_2,_3];v=liftA2(,)f f;r=((==)<*>nub).catMaybes
11:39:18 <lambdabot>  Defined.
11:42:28 <monochrom> I think you can also simplify it further with the theorem: and xs && and ys = and (xs ++ ys)  (provided xs and ys have the same type)
11:43:22 <dmwit> more specifically: provided xs and ys are both lists
11:45:26 <dmwit> :t checkSudoku
11:45:29 <lambdabot> (Field1 a1 b1 (Maybe a2) (Maybe a2), Field1 a3 b2 a1 b1, Field1 a4 b3 a3 b2, Field1 s s a4 b3, Field3 a3 b2 a1 b1, Field3 a1 b1 (Maybe a2) (Maybe a2), Field3 s s a4 b3, Field3 a4 b3 a3 b2, Field2 a3
11:45:29 <lambdabot> b2 a1 b1, Field2 a1 b1 (Maybe a2) (Maybe a2), Field2 s s a4 b3, Field2 a4 b3 a3 b2, Eq a2) => s -> Bool
11:45:33 <mniip> @let goodSudoku = let l(x,y,z)=(y,z,x);f&(x,y,z)=(f x,f y,f z);a=(Just&)&((1,2,3),(4,5,6),(7,8,9));b=(a,l a,l.l$a) in (b,(l&)&b,((l.l)&)&b)
11:45:38 <lambdabot>  Defined.
11:45:40 <mniip> > checkSudoku goodSudoku
11:45:43 <lambdabot>  True
11:46:26 <mniip> there's a problem
11:46:33 <dmwit> :t goodSudoku
11:46:34 <mniip> you can't universally quantify a,b,c,d
11:46:36 <lambdabot> (Num a1, Num a2, Num a3, Num a4, Num a5) => ((((Maybe a3, Maybe a3, Maybe a3), (Maybe a3, Maybe a3, Maybe a3), (Maybe a3, Maybe a3, Maybe a3)), ((Maybe a2, Maybe a2, Maybe a2), (Maybe a2, Maybe a2,
11:46:36 <lambdabot> Maybe a2), (Maybe a2, Maybe a2, Maybe a2)), ((Maybe a1, Maybe a1, Maybe a1), (Maybe a1, Maybe a1, Maybe a1), (Maybe a1, Maybe a1, Maybe a1))), (((Maybe a4, Maybe a4, Maybe a4), (Maybe a4, Maybe a4,
11:46:36 <lambdabot> Maybe a4), (Maybe a4, Maybe a4, Maybe a4)), ((Maybe a4, Maybe a4, Maybe a4), (Maybe a4, Maybe a4, Maybe a4), (Maybe a4, Maybe a4, Maybe a4)), ((Maybe a4, Maybe a4, Maybe a4), (Maybe a4, Maybe a4,
11:46:36 <lambdabot> Maybe a4), (Maybe a4, Maybe a4, Maybe a4))), (((Maybe a5, Maybe a5, Maybe a5), (Maybe a5, Maybe a5, Maybe a5), (Maybe a5, Maybe a5, Maybe a5)), ((Maybe a5, Maybe a5, Maybe a5), (Maybe a5, Maybe a5,
11:46:36 <lambdabot> Maybe a5), (Maybe a5, Maybe a5, Maybe a5)), ((Maybe a5, Maybe a5, Maybe a5), (Maybe a5, Maybe a5, Maybe a5), (Maybe a5, Maybe a5, Maybe a5))))
11:46:39 <dmwit> yeesh
11:46:41 <HaskellLord69> lol
11:46:58 <mniip> they have different types in each list comprehension
11:47:11 <dmwit> Oh, I see! Now the `_1` through `_3` make more sense.
11:47:49 <monochrom> OK yeah I was worrying that maybe xs and ys had different types.
11:48:00 <mniip> no, they're all [Bool]
11:48:15 <monochrom> Oh!
11:48:25 <mniip> consider this
11:48:38 <mniip> and $ [f x | x <- l] ++ [g x | x <- l]
11:48:41 <mniip> you would think
11:48:47 <mniip> and [f x && g x | x <- l]
11:48:52 <mniip> but x has different types
11:49:08 <monochrom> Right.
11:50:57 <monochrom> The synergy of Haskell Sudoku tutorials and Haskell lens tutorials.
11:51:14 <monochrom> "The second Sudoku bubble"
11:51:21 <mniip> yeah the indexing scheme I used here is, goodSudoku!i!j!k!l is i,j determines a 3x3 quadrant
11:51:37 <mniip> and k,l is a cell in that quadrant, so that i,k and j,l axes are parallel
11:52:38 <mniip> now obviously the type of goodSudoku would be much better if we had a natural 'Triple a = Triple a a a' functor with instances of Field[123]
11:56:27 <LeanderK> Hey, i am playing around with singletons and got an error i don't understand currently: Could not deduce (SingI is) arising from a use of ‚Äòsing‚Äô, is is in this context (is :: [Nat]). I've used it elsewhere, so there shouldn't be a problem i think
11:57:39 <dmwit> ?lpaste a minimal reproducing example, LeanderK
11:57:39 <lambdabot> Haskell pastebin: http://lpaste.net/
11:57:48 <LeanderK> the type-level function is rather long, i can paste it in lpaste if there is no immediate idea whad i could wrondg but i think it's rather hard to understand
11:58:39 <dmwit> I mean, that usually means you are asking for a term-level representation of a type-level value that can't be known at compile time.
11:58:41 <LeanderK> ah, yeah thought so. I will try to create a minimal reproducing example, but it's going to take a while
11:58:56 <dmwit> I don't think there's much more to be said without further details, though.
11:59:33 <dmwit> Possibly just adding `SingI is` to the context will be enough.
12:01:52 * hackagebot colorless 2.2.17 ‚Äì Colorless | The Programmatic IDL ‚Äì https://hackage.haskell.org/package/colorless
12:02:43 <Zemyla> What is Opaque in GHC.Base for? It's not exported, and it's not used in anything.
12:02:51 <Zemyla> data Opaque = forall a. O a
12:07:17 <LeanderK> i am just playing around right now, i hope it's somewhat sensible http://lpaste.net/751682734941798400
12:07:57 <LeanderK> i am just experimenting right now, so this code is somewhat ugly
12:14:52 <athan> Could there ever be a version of `many` that uses Vector instead of list?
12:15:09 <athan> or is that not possible, because vectors aren't lazilly built or something?
12:15:28 <jared-w> :t many
12:15:32 <lambdabot> Alternative f => f a -> f [a]
12:16:30 <athan> @src many
12:16:30 <lambdabot> Source not found. You speak an infinite deal of nothing.
12:16:40 <athan> hrmf
12:16:43 <jared-w> https://hackage.haskell.org/package/base-4.10.0.0/docs/src/GHC.Base.html#many
12:16:54 <Ero2> does anyone here use a template that includes for hspec? (the hspec one isn't working for me?)
12:17:11 <athan> oh duy sorry it's a typeclass member
12:18:16 <jared-w> So, technically speaking, there doesn't seem anything wrong with making a vector version of the Alternative class (or just making vector versions of many and some)
12:18:46 <jared-w> Code interop might be a small issue though and you might be better off just using a list -> Vector conversion function if that works for your usecase
12:18:48 <athan> I couldn't find anything in hoogle... so I'm wondering if I should make a singleton package :D
12:19:08 <athan> well I could just duck-tape a term that works for all Alternatives
12:19:29 <athan> given that its laws are followed in the typelcass
12:19:53 <athan> jared-w: Well my issue is that it could be quite long, and I want to do a last-index on the result
12:20:19 <athan> so hopefully laziness will work in my favor to /not/ attempt parsing each line, and only go for the last
12:20:27 <jared-w> ahh... yeah that would be an issue. Is there any way to build the list backwards so that you can just take the head?
12:20:38 <athan> nah :\ it's a log file
12:20:49 <jared-w> You can't stream the file in backwards? :p
12:21:01 <athan> shoot, I don't think I can, can I?
12:21:04 <EvanR> you can build lists forwards or backwards
12:21:06 <athan> does conduit allow that?
12:22:07 <EvanR> pipe the input into the file using tac instead of cat :)
12:22:11 <EvanR> er, into the program
12:23:19 <athan> ha! thanks EvanR, never heard of that one
12:23:30 <jared-w> It's `cat` backwards :)
12:23:58 <jared-w> You can also `tac existing_log_file.log > new_log_file.log`
12:27:05 <athan> I'm just going to make a 1-off library I think, it might have uses later
12:27:53 <Zemyla> So question. Why is the definition for fixST different from the definition for fixIO?
12:28:27 <c_wraith> is it different for both types called ST ?
12:34:07 <hexagoxel> :t (fixIO, fixST)
12:34:09 <lambdabot> error: Variable not in scope: fixIO
12:34:39 <hexagoxel> :t (System.IO.fixIO, fixST)
12:34:40 <lambdabot> ((a1 -> IO a1) -> IO a1, (a2 -> ST s a2) -> ST s a2)
12:40:15 * hackagebot alternative-vector 0.0.0 ‚Äì Use vectors instead of lists for many and some ‚Äì https://hackage.haskell.org/package/alternative-vector
12:41:50 <Zemyla> c_wraith: I'm not sure what it is for ST.Lazy, but ST.Strict is a functionally identical type to IO.
12:45:14 <Psybur> So fold is a catamorphism and unfold is an anamorphism?
12:46:34 <johnw> Psybur: basically
12:47:26 <johnw> Psybur: the main difference is that a given fold knows the structure of what it's folding, while a catamorphism is generalized over any functor given an F-Algebra f a -> a
12:48:09 <Psybur> And anamorphism is a -> f a
12:48:13 <johnw> yes
12:48:50 <Psybur> How do you keep things like f algebra in your memory? Do you work in academia?
12:49:06 <johnw> I work with academics, but not directly in acamedia
12:49:41 <johnw> but f-algebra is a pretty core concept when you generalize ideas of recursion using concepts from category theory
12:52:24 <hexagoxel> Zemyla: could it have to do with forkIO but no forkST?
12:56:16 <Zemyla> hexagoxel: Well, I don't think so, given that MVar# in GHC.Prim has a state parameter, so they could as easily be used in the ST monad as in the IO monad.
12:58:55 <dsal> I did a thing with a list monad.  It's easy to use, etc...  But I don't know how to think about it.  It mostly just feels like alternative list comprehension syntax.
13:05:13 <Ero2> I can't seem to find any documentation on stacks website about how to run tests from the stack command. It will build them for me but then what?
13:05:36 <Ero2> in fact sticking 'tests' into the websites search box comes up blank!
13:05:52 <cocreature> Ero2: "stack test" will run tests
13:06:03 <bitemyapp> read the docs doesn't really have good search.
13:06:24 <cocreature> the search is not too bad, stack just managed to break it somehow
13:06:32 <cocreature> there is a fix but it‚Äôs only included in the next release of stack
13:10:59 <Ero2> cocreature when i run 'stack test' the terminal gives no output. Even if i change my Spec.hs file
13:11:15 <EvanR> what if you change Spec.hs to print something out
13:13:14 <cocreature> Ero2: by default it hides the output to avoid interleaving tests that run in parallel, it will show it if tests fail. you can also pass an explicit target to "stack test" and then it always shows the output
13:15:34 <Ero2> cocreature: i created a test that shows failure when i use runhaskell test/Spec.hs . but when i run stack test there is no output still
13:15:52 <Ero2> i feel like im definately missing something here
13:16:15 <Ero2> but i cant seem to find any documentation on how stack build --test works
13:16:47 <cocreature> Ero2: do you actually have the test suite specified in your cabal file? stack won‚Äôt magically search for files named Spec.hs
13:17:09 <Ero2> thats probably it. Thanks cocreature 
13:17:37 <Ero2> i assumed stack would do some magic on everything in test/
13:18:36 <dsal> It does, but there are a few different project templates.  Some are more bare than others.
13:18:51 <Orwell> anyone familiar with web sockets
13:19:32 <cocreature> dsal: it really doesn‚Äôt. if you use a template that specifies a test suite in test/ than it will ofc build it but that can hardly be called ‚Äúdoing magic on everything in test/‚Äù
13:20:01 <mnoonan> well, hspec-discover is a little bit magic, but that has nothing to do with stack
13:20:19 <dsal> Oh, I see.  That's not how I understood the statement.
13:20:20 <cocreature> and even hspec-discover won‚Äôt magically discover test suites.
13:20:50 <cocreature> it will discover tests magically but you still need to specify the test suite in your cabal file
13:21:24 <Ero2> tihs is what i get for reading the stack/cabal documentation last week and only caring to use that knowledge today lol
13:21:30 <dsal> I thought we were talking about the magic that happens at 'stack new' time.
13:21:42 <dsal> Ero2: I usually do it the other way around.
13:21:49 <Ero2> yes, i was dsal, i understood what you meant, thanks.
13:22:50 * hackagebot universum 0.7.0 ‚Äì Custom prelude used in Serokell ‚Äì https://hackage.haskell.org/package/universum
13:22:55 <cocreature> Ero2: basically add a section that looks somewhat like http://lpaste.net/359151 to your cabal file
13:23:06 <Ero2> my thanks cocreature 
13:55:02 * hackagebot graphite 0.7.0.0 ‚Äì Graphs and networks library ‚Äì https://hackage.haskell.org/package/graphite
14:28:24 * hackagebot hexpat-lens 0.1.6 ‚Äì Lenses for Hexpat. ‚Äì https://hackage.haskell.org/package/hexpat-lens
14:56:57 <GlobalAtom> anyone good with bash 
14:57:40 <king_idiot> ish
14:58:03 <king_idiot> what's up
15:03:26 <geekosaur> and, er, why in #haskell?
15:12:28 <michalrus> Can I do this or does it look silly? :c `fromMaybe mempty . (userStatuses <$>) <$> TMap.lookup ‚Ä¶`
15:12:49 <johnw> brain hurty
15:12:51 <michalrus> :c
15:12:55 <michalrus> OK.
15:14:44 <hexagoxel> isnt that.. `maybe` ?
15:14:53 <michalrus> Aahhhhhhhh, yes.
15:14:55 <michalrus> Thank you!
15:16:04 <johnw> good catch, hexagoxel 
15:27:15 <mniip> ooooh
15:27:23 <mniip> hmm
15:27:24 <mniip> no
15:58:45 <Subeff> Hello guys is there utiliti function that will allow me to call a function that accepts two arguments with just that is repeated two times. I know how to do it on my own but thought there is such?
15:59:07 <Subeff> with just one * that is repeated two times
15:59:12 <erisco> Subeff, join
16:00:08 <Subeff> isn't join used to get rid of two layers of Monads and make it one?
16:00:37 <c_wraith> > join (+) 3
16:00:40 <lambdabot>  6
16:01:10 <Subeff> amazed!
16:01:24 <Subeff> thank you guys! <3
16:01:49 <c_wraith> Subeff: you are correct about its job.
16:01:53 <geekosaur> Subeff, it is. the monad here is ((->) e)
16:01:56 <c_wraith> Subeff: but functions have a monad instance
16:02:06 <geekosaur> that is, function application.
16:02:14 <geekosaur> so when you join it, you pass 'e' twice
16:03:00 <Subeff> alright alright I think I read that somewhere but didnt actually realize it up until now :o
16:03:28 <cloudhead> What is the typical way of combining Eithers in an 'and' fashion, ex: a `and` b `and` c must be Right, or return Left?
16:03:43 <cloudhead> is it through the monad instance?
16:04:32 <erisco> cloudhead, how do you want to combine them? What is  Right 1  combined with  Right 2  ?
16:05:10 <cloudhead> erisco: hmm in that case it wouldn't matter as much, but let's say Right 2
16:05:30 <erisco> it matters, and in that case, >>
16:05:50 <cloudhead> yeah I mean for my use case
16:05:56 <cloudhead> erisco: and if I wanted Right 1?
16:06:01 <erisco> <<
16:06:07 <cloudhead> oh haha
16:06:18 <cloudhead> thanks
16:06:36 <erisco> or *> and <* respectfully
16:06:45 <geekosaur> respectively?
16:06:57 <c_wraith> and respectfully
16:07:03 <erisco> respect the Applicative
16:07:29 <cloudhead> erisco: in the case of Either, is there any difference between *> and >>?
16:08:06 <geekosaur> in general there should not be a difference between them
16:08:57 <geekosaur> there's actually a comment in the Prelude source about how (>>) ought to be defined as (*>), but for historical reasons retrofitted Applicative instances define (*>) as (>>) so it can't be safely done
16:09:06 <c_wraith> I'm less sure about << and <* though
16:09:13 <cloudhead> oh I see
16:09:19 <c_wraith> > Just 1 << Just 2
16:09:21 <lambdabot>  error:
16:09:22 <lambdabot>      ‚Ä¢ Variable not in scope:
16:09:22 <lambdabot>          (<<) :: Maybe Integer -> Maybe Integer -> t
16:09:30 <c_wraith> Oh.  well, there's that too.
16:09:56 <erisco> maybe there is no definition for it, hum
16:10:02 <cloudhead> it matters though if *> is used in a Monad way vs Applicative no?
16:10:17 <c_wraith> cloudhead: they really should do the exact same thing
16:10:55 <c_wraith> cloudhead: there are types for which *> is defined and >> isn't, but if they're both defined, they should do the same thing
16:11:05 <cloudhead> hmmm, are the differences only with <*> and >>= then?
16:11:26 <erisco> @check (\a b -> a >> b == a *> b) :: Either a b -> Either a b -> Bool
16:11:27 <lambdabot>  :-1:-1:Ambiguous infix expression
16:12:43 <erisco> @check (\a b -> (a >> b) == (a *> b)) :: Either Int Char -> Either Int Char -> Bool
16:12:45 <lambdabot>  +++ OK, passed 100 tests.
16:13:11 <cloudhead> hmm
16:13:14 <c_wraith> 100 tests - proof positive
16:13:34 <erisco> 100 cases is more than any programmer needs
16:13:52 <cloudhead> So why is it that applicative-do and monad-do behave differently in some cases?
16:14:31 <c_wraith> they should only behave differently if <*> and ap are not the same
16:15:09 <erisco> @check liftA2 (==) <$> (>>) <*> (*>) :: Either Int Char -> Either Int Char -> Bool
16:15:12 <lambdabot>  +++ OK, passed 100 tests.
16:15:13 <erisco> I can't resist
16:15:26 <MP2E> I think cloudhead might be alluding to haxl using applicative for concurrency, monad for sequential stuff
16:15:33 <cloudhead> ^ yes
16:15:39 <cloudhead> wondering about this
16:15:55 <Tuplanolla> Don't leave a job half-finished, erisco.
16:15:58 <erisco> well then haxl is a liar
16:17:02 <c_wraith> haxl decides to take the viewpoint that if the end results are the same, it's ok to have different operational semantics
16:17:11 <c_wraith> and that's fine.
16:17:14 <Tuplanolla> @check (liftA2 . liftA2) (==) (>>) (*>) :: Either Int Char -> Either Int Char -> Bool
16:17:18 <lambdabot>  +++ OK, passed 100 tests.
16:17:20 <c_wraith> Quickcheck takes a larger liberty than that.
16:17:35 <c_wraith> Gen is only a monad if you decide that all randomly-generated values are equivalent
16:19:56 <geekosaur> so, with Applicative you can't observe in <*> that something changed its constructor (e.g. Just to Nothing). with Monad you can. a side effect of this is Applicative can be done in parallel knowing it won't change the outcome, but Monad has to serialize in case the constructor changed and would affect the rest of the computation. it's kinda 'meta-reasoning'
16:20:43 <cloudhead> yeah that makes sense
16:21:11 <cloudhead> but still not sure how to reason about *> vs >>, ie when does it matter
16:21:36 <geekosaur> it should never matter, except in the case where you can't use (>>) at all in which case its irrelevant
16:22:13 <geekosaur> and in the specific case of defining either of them in terms of the other, where you have to watch out for accidentally defining it as itself because the other definition does so
16:22:33 <cloudhead> right, so when there are instances of both, then it doesn't matter, and when it's only monad, then they will both behave differently?
16:22:53 <geekosaur> uh? you can;t have Monad without Applicative
16:23:02 <geekosaur> so if the Monad instance exists then (*>) must be the same as (>>)
16:23:09 <geekosaur> but you can have cases where only Applicative exists
16:23:12 <cloudhead> right sorry, that's what I mean
16:23:16 <cloudhead> was thinking of IO
16:23:23 <geekosaur> so if you want your Applicative code to be fully general you should use (*>)
16:23:33 <geekosaur> so it still works even if there is no Monad instance
16:23:37 <cloudhead> if I use *>, it's the equivalent of using sequencing there
16:23:38 <cloudhead> yeah
16:23:46 <cloudhead> cool, makes sense
16:23:58 <cloudhead> thanks
16:24:26 <geekosaur> otherwwise, a lot of what you see in actual code is just historical because Monad didn;t start requiring Applicative until farly recently
16:24:43 <geekosaur> so a lot of code uses (>>) because it could only rely on Monad existing in the past
16:24:48 <cloudhead> yeah that's what tripped me up
16:24:49 <erisco> haxl is not a liar if they are functionally equivalent
16:25:41 <cloudhead> I should really think of (>>) as just an alias for (*>) at this point
16:25:51 <erisco> though, that does suggest we may want to state a stronger equality between Applicative and Monad
16:25:51 <geekosaur> pretty much
16:26:06 <Ero2> I was going to use the digitToInt function from Data.Char but i wondered if the 'first' excersize expects me to do something simpler than import a module to complete it?
16:26:16 <Ero2> im doing week1 homework1 ex1 for CIS194
16:26:38 <erisco> you should not think of it as an alias syntactically because they have different precedences
16:26:41 <geekosaur> as witht he Prelude comment I mentioned earlier: that is the correct way to think about it, but because of retrofitted historical code which was written when only Monad existed/was present you have code that 'knows' that (>>) is the real one
16:27:06 <cloudhead> erisco: oh, good to know - but yes I meant semantically
16:27:46 <Ero2> am i fretting to much over nothing i wonder lol
16:28:50 <erisco> Ero2, just implement it yourself, then?
16:30:05 <erisco> digitToInt = subtract 48   probably
16:30:33 <erisco> or  subtract 48 . ord
16:30:39 <erisco> but then you need Data.Char anyways
16:31:11 <Ero2> lol
16:31:30 <Tuplanolla> Can you `unsafeCoerce` a `Char` into an `Int`?
16:32:12 <Tuplanolla> It might just work by accident.
16:33:00 <geekosaur> I, er, doubt unsafeCoerce is intended in week 1 homework >.>
16:33:35 <geekosaur> but yes, if you assume ghc, it is guaranteed to work
16:33:46 <nisstyre> geekosaur: I've seen situations where someone would find a thing like that by googling and use it without really understanding the ramifications
16:33:55 <nisstyre> just to get the code to compile
16:34:20 <geekosaur> that said, here it would 'work' (typecheck) but be incorrect semantically
16:34:28 <nisstyre> geekosaur: is it applied to the unboxed values of both Char and Int then?
16:34:30 <geekosaur> it gives you the codepoint, not the integer value
16:34:50 <Ero2> i checked the source for ord and saw # . I'm going to guess im supposed to import Data.Char lol
16:35:14 <nisstyre> it would work the same way as it does in Tuplanolla 
16:35:18 <nisstyre> *in C
16:35:58 <geekosaur> nisstyre, I am not sure I understand your question. it doesn't touch the value at all; it changes the typechecker's idea of what it is looking at. since both Char and Int have exactly one constructor and a machine-word value following, it is always safe
16:36:04 <nisstyre> Ero2: you can write your own function to convert a list of digits into an Int
16:36:14 <nisstyre> it's not too difficult, but I don't know if it would be expected
16:36:26 <geekosaur> but recognizing this requires that you know how ghc represents both internally
16:36:34 <nisstyre> geekosaur: yes that makes sense
16:36:44 <Ero2> i dont think i have to convert a list of digits to an int
16:36:47 <erisco> if your digit is a Char, and you need an Int, then you need some Char -> Int function, and those are in Data.Char
16:36:49 <Ero2> so thats all good
16:37:04 <nisstyre> I think what I meant is that it wouldn't actually convert anything, it would just treat the values differently
16:37:04 <erisco> however, you can also write ord yourself for just the cases you need
16:37:08 <Ero2> yea i'll just import data.char and be done with it :P
16:37:19 <erisco> ord '0' = 48; ord '1' = 49; ord '2' = 50; ‚Ä¶
16:37:34 <Ero2> moving swiftly on. Gentlemen *bows*
16:37:45 <geekosaur> p.s. ord is fromEnum with a more specific type constraint
16:38:20 <erisco> oh
16:38:48 <erisco> well, that fixes things ‚Ä¶ there is a Char -> Int function in Prelude
16:39:11 <nisstyre> Ero2: do you know about hoogle?
16:39:18 <Ero2> how long have you lot been haskelling? And how does that length of time compare to how long you lot have been in computer science
16:39:34 <Ero2> i do nisstyre, i used it to locate digitToInt :)
16:39:38 <geekosaur> some of us are going to badly skew that :p
16:39:42 <Ero2> i searched for a Char -> Int
16:39:57 <dsal> cabal is severely confusing me.  It seems to think I have xmonad installed.  Also, I have xmonad installed from the system, but that one doesn't work.   I rm -rf'd ~/.cabal -- why would "cabal install" tell me a package alredy exists?
16:40:18 <geekosaur> dsal, because that's not the right directory
16:40:33 <geekosaur> .cabal is where cabal keeps its work. .ghc is what knows what is registered/installed
16:40:33 <dsal> Where's it putting stuff?
16:40:54 <geekosaur> ghc, not cabal, owns the package database
16:41:02 <dsal> OK.  rm -rf .ghc and xmonad works again.  *whew*
16:41:15 <geekosaur> @where sicp
16:41:16 <lambdabot> http://mitpress.mit.edu/sicp/ | http://swiss.csail.mit.edu/classes/6.001/abelson-sussman-lectures/ | http://www.vex.net/~trebla/haskell/sicp.xhtml -- "Storage and Identification of Cabalized
16:41:16 <lambdabot> Packages"
16:41:26 <geekosaur> last link there (vex.net)
16:41:27 <Ero2> for context: i've been studying haskell on and off for about a year and a half now. I've learnt a lot about computer science but have barely programmed anything yet lol
16:41:53 <geekosaur> so I've been working with haskell for 11 years now. CS formal education: none
16:41:55 <dsal> geekosaur: Thanks.  This didn't work how I expected.  :)
16:42:14 <nisstyre> Ero2: I used it a lot more a few years ago when I worked for a professor that had his entire research project written in it
16:42:25 <Ero2> thats cool :)
16:42:33 <nisstyre> before that I had learned it on my own and there was about a 4-6 month learning curve before things really made any sense tbh
16:43:33 <erisco> computer science and programming are related like physics and civil engineering
16:43:39 <nisstyre> Ero2: just take stuff you've done in other languages and rewrite it in Haskell
16:43:44 <nisstyre> if you don't have any ideas
16:44:10 <Ero2> I had this crazy idea about half a decade ago. What would be the the shortest set of instructions a human would need to follow to go from paper to the perfect computational system
16:44:26 <nisstyre> the sad thing is that for most people unless it somehow provides value for their job, then you don't get too much of a chance to write in languages like Haskell
16:44:38 <geekosaur> "insufficient data for meaningful answer"
16:44:59 <nisstyre> Ero2: how about something like brainf*ck or unlambda?
16:45:03 <Ero2> yea :D that might be the reason i had such a though geeq
16:45:04 <Ero2> geekosaur: 
16:45:13 <Ero2> what are those, nisstyre ?
16:45:16 <erisco> some of the CS masters students I worked with were poor programmers, frankly, but effective in their research
16:45:26 <nisstyre> Ero2: programming languages
16:45:37 <Ero2> I like haskell, its fun
16:45:45 <nisstyre> http://www.madore.org/~david/programs/unlambda/
16:46:19 <nisstyre> https://esolangs.org/wiki/Brainfuck
16:46:44 <Ero2> spoiler: in my.. 15 years? of programming i've barely done enough programming to fit into half a year
16:46:58 <nisstyre> are you counting hours?
16:47:08 <nisstyre> most people don't spend most of their time actually writing code
16:47:15 <nisstyre> most of it is spent waiting tbh
16:47:18 <Ero2> heh
16:47:33 <erisco> I hope most of it is spent thinking
16:47:40 <nisstyre> waiting on people to respond, waiting for something to finish building, or reading something to try and fix something
16:48:01 <geekosaur> (or having lightsaber battles...)
16:48:11 <Ero2> tbh for something like systems, i think its worth spending a good chunk of years discovering the best way of doing things, before investing into something subpar?
16:48:16 <erisco> third party libraries are the bane of my existence
16:48:35 <Ero2> unix philosophy and all that
16:48:47 <erisco> a good way to lose a week of time is to have an issue with a 3rd party lib for which there are no answers you can look up
16:49:29 <nisstyre> erisco: and a month without access to the source and the company is out of business
16:49:34 <nisstyre> or the developer retired
16:50:32 <Ero2> there is still so much improvment to me made on systems usage. for instance discovery is crap, trust is crap, portability is crap
16:51:21 <erisco> Ero2, the most likely road to success, to profit, is to solve a problem you already know the answer to
16:51:32 <Ero2> anyway nisstyre i didnt spend 14.5 years waiting lol. Mostly thinking
16:51:49 <nisstyre> Ero2: and how do you pay your bills?
16:51:54 <nisstyre> wait how old are you?
16:52:02 <Ero2> 28 and a half
16:52:07 <nisstyre> ah ok
16:52:10 <nisstyre> that makes more sense
16:52:19 <Ero2> i work 30 hours a week managing the stocks for a private hospital
16:52:31 <nisstyre> so you're a fund manager
16:52:51 <nisstyre> wait do you mean literal stocks or stock market stocks?
16:52:58 <Ero2> and ive been hoping and dreaming since i was 15 to be successful with something cool in IT
16:53:04 <Ero2> i mean literal
16:53:07 <Ero2> im a box-mover
16:53:07 <nisstyre> ah lol
16:53:17 <nisstyre> you should get an education
16:53:25 <Ero2> I am educated ~~
16:53:32 <nisstyre> what did you do?
16:53:33 <Ero2> i just dont have a piece of paper confiming it for you
16:53:35 <erisco> you're ready to execute when you see both "that could be better" and "I know how to do it"
16:53:49 <Ero2> im working on the latter, erisco 
16:53:51 <nisstyre> Ero2: I don't think it makes people smarter
16:53:57 <nisstyre> the value is more in who you meet
16:54:12 <Ero2> a fair point
16:54:34 <nisstyre> there are a lot of opportunities for networking, that's the real value
16:54:47 <Ero2> I often feel missing out on a RL social circle with people such as yourselfs has slowed things down
16:54:49 <monochrom> Education made me smarter.
16:55:08 <erisco> keep learning or find easier problems, but keep learning anyways ;)
16:55:08 <Ero2> but at the same time it has given me alot of intelletual lucidity
16:55:15 <nisstyre> education gave me some tools for questioning things
16:56:07 <nisstyre> Ero2: I really like this podcast https://partiallyexaminedlife.com/
16:56:11 <nisstyre> to get way off topic
16:56:23 <nisstyre> it helped me write some last minute papers even
16:56:24 <Ero2> is that a hint? lol
16:56:36 <nisstyre> well if you want to learn interesting stuff
16:56:50 <nisstyre> they're very good
16:56:52 <Ero2> about computer science?
16:56:59 <nisstyre> not really
16:57:04 <nisstyre> but they cover logic
16:57:31 <nisstyre> I think it helps you be a better programmer by being able to question things
16:57:35 <Ero2> in complete modesty. I'm comfortable with what i know & think about a wide spectrum of things
16:58:43 <Ero2> its like i have evaluated fully to IO a lol
17:00:15 <tobiasBora> Hi again,
17:00:27 <tobiasBora> I've a question : I'm trying to load EitherT using:
17:00:29 <Ero2> nisstyre: what last minute papers did it help you to write?
17:00:29 <tobiasBora> import Control.Monad.Trans.Either (runEitherT, EitherT)
17:01:09 <tobiasBora> However I've an error : "Data constructor not in scope: EitherT [...] Perhaps you want to add ‚ÄòEitherT‚Äô to the import list in the import of ‚ÄòControl.Monad.Trans.Either‚Äô)
17:01:15 <tobiasBora> But I already did that !
17:01:21 <tobiasBora> What did I do wrong ?
17:01:32 <geekosaur> you adeed the type constructor, likely
17:01:34 <nisstyre> Ero2: a paper on Gottlob Frege (the logician)
17:01:35 <geekosaur> EitherT(..)
17:01:40 <geekosaur> or EitherT(EitherT)
17:01:42 <nisstyre> also Kant
17:01:48 <Ero2> thats cool :)
17:01:53 <nisstyre> (I hated that class so much)
17:02:04 <nisstyre> I liked Frege though, apart from him being a raging antisemite
17:02:08 <Ero2> what class did you have to do that for?
17:02:20 <nisstyre> it was a seminar on the history of analytic philosophy
17:02:24 <Ero2> oo
17:02:27 <Ero2> i like philosophy
17:02:33 <nisstyre> so we read some of Russell, Frege, G.E. Moore, and others
17:02:42 <nisstyre> Wittgenstein too
17:03:05 <Ero2> i dont have the formal vocabulary for philosophy but i have an opinion on everything :D 
17:03:05 <nisstyre> there is a spinoff of Haskell for the JVM called Frege btw
17:03:24 <tobiasBora> geekosaur: Great, thanks !
17:03:27 <hpc> that sounds like the .net version of brainfuck
17:03:29 <nisstyre> Ero2: you can buy some cheap textbooks and read up on it fairly easily
17:04:05 <boris> hey, is this a good place to ask specific haskell questions?
17:04:12 <nisstyre> absolutely
17:05:07 <boris> awesome! i was wondering how to best deal with this: i need to compute distances between two (lat, lng) points. the signature looks like (Lat, Lng) -> (Lat, Lng) -> Miles
17:05:50 <boris> i have a few implementations for the distance computation (using haversine, basic pythagorean, etc.)
17:06:02 <Ero2> nisstyre: i think im happy to simply look stupid when i tell people 'i like philosophy' and then have no idea how to talk about philosophy with them lol
17:06:32 <nisstyre> Ero2: a lot of it is unintentionally funny
17:06:40 <boris> i added 2 new implementations that get distance using google maps and mapbox apis. that changes the signature, because now there's a network request: (Lat, Lng) -> (Lat, Lng) -> IO (Maybe Mi)
17:06:42 <Ero2> oh?
17:06:49 <nisstyre> I mostly just read memes nowadays rather than read any serious stuff
17:06:53 <nisstyre> if I had more time I would though
17:06:56 <Ero2> lol
17:06:57 <hpc> boris: you'll want to use a distance formula that works on spherical geometry
17:07:21 <Ero2> nisstyre: do you align with any particular school of thought?
17:07:25 <hpc> boris: look at https://en.wikipedia.org/wiki/Great-circle_distance
17:07:33 <nisstyre> Ero2: I'm analytic mostly but other than that not really
17:07:42 <nisstyre> I have opinions on specific issues though
17:07:43 <dmwit> hpc: I think he hasn't asked his question yet, and he appears to know the right formulas...
17:07:51 <dmwit> Let's not jump the gun on advice. =)
17:08:00 <boris> what's a good way to abstract over the 2 signatures, so i can nicely compute distances between pairs of points for an arbitrary set of implementations? is the best option to lift everything to (Lat, Lng) -> (Lat, Lng) -> IO (Maybe Miles)?
17:08:12 <Ero2> i tihnk being analytical doens't exclude you from much of anything really
17:08:13 <hpc> oh derp, i saw pythagoras
17:08:28 <dmwit> boris: I think that's just about the sanest, yes.
17:08:32 <Ero2> nisstyre: do you like to discuss religion?
17:08:43 <erisco> boris, probably  Monad m => (Lat, Lng) -> (Lat, Lng) -> m Miles  where the trivial case is m = Identity
17:08:45 <nisstyre> Ero2: the analytic school of philosophy is something associated with a specific tradition of mostly Western philosophers
17:08:50 <nisstyre> in the 20th century mostly
17:09:05 <dmwit> boris: I think I might change it to `... -> IO Miles`, and have the versions that use the web implement a fallback for when they get no response.
17:09:06 <boj> Ero2, nisstyre - taaddd offtopic :)
17:09:11 <nisstyre> it's usually credited to Frege or Bernard Bolzano
17:09:13 <nisstyre> or both
17:09:14 <boris> erisco: it would be m n Miles, because it's IO (Maybe Miles), no?
17:09:16 <hpc> erisco: that doesn't open up the ability to do IO
17:09:17 <Ero2>  /q
17:09:20 <nisstyre> boj yeah I know sorry
17:09:23 <hpc> erisco: it only gives you (>>=) and friends
17:09:37 <erisco> boris, correct, no, because you can use  m = MaybeT IO
17:09:41 <nisstyre> Ero2: /j #haskell-offtopic if you wanna discuss it more
17:11:08 <erisco> hpc, boris what I am inferring is "I want to make more functions using some method of calculating distance"
17:11:42 <erisco> so, under merely the assumption the distance is under some Monad, then we can unify all the various methods of calculating distance described
17:12:18 <boris> erisco: yes, and i'd like a uniform interface for them. i'm trying to find a general interface. i'm not sure i understand how IO (Maybe Miles) can become m Miles
17:12:33 <erisco> I told you: m = MaybeT IO
17:12:43 <dmwit> :t MaybeT :: IO (Maybe miles) -> MaybeT IO miles
17:12:45 <lambdabot> error:
17:12:45 <lambdabot>     Not in scope: type constructor or class ‚ÄòMaybeT‚Äô
17:12:45 <lambdabot>     Perhaps you meant ‚ÄòMaybe‚Äô (imported from Data.Maybe)
17:12:50 <dmwit> bummer
17:13:07 <hpc> boris: the type (MaybeT m a) is a wrapper around (m (Maybe a))
17:13:44 <boris> hpc: hmm ok i see
17:13:49 <dmwit> boris: In short: `IO (Maybe Miles)` can't unify with `m Miles`. But you can convert from `IO (Maybe Miles)` to another type that *does* unify with `m Miles`.
17:14:11 <hpc> boris: this is a trend with all of mtl, the types end up a bit inside-out when you expand them out
17:14:20 <dmwit> So you are right, and erisco/hpc are also right.
17:14:21 <boris> what's the best way to lift the result of (Lat, Lng) -> (Lat, Lng) -> Miles to (Lat, Lng) -> (Lat, Lng) -> m Miles ?
17:14:31 <dmwit> boris: return
17:14:33 <hpc> :t return
17:14:35 <lambdabot> Monad m => a -> m a
17:14:37 <hpc> apply that to the result
17:14:44 <boris> ah. perfect
17:15:12 <boris> thanks for the help hpc/dmwit/erisco
17:15:24 <hpc> :t pure -- another one to be aware of that's the same as return, but you can use it in more places
17:15:26 <lambdabot> Applicative f => a -> f a
17:15:51 <hpc> that detail probably won't matter for this, but it's something to remember down the line
17:29:19 <tobiasBora> Is there a better way in a EitherT monad to run a putStrLn than doing "EitherT $ do {putStrLn "Hi !"; return ()} ?
17:29:21 <tobiasBora> "
17:29:40 <dmwit> liftIO (putStrLn "Hi !")
17:30:01 <dmwit> `lift (putStrLn "Hi !")` also works if there is just one layer of nesting.
17:31:16 <dmwit> :t EitherT
17:31:18 <lambdabot> error:
17:31:18 <lambdabot>     ‚Ä¢ Data constructor not in scope: EitherT
17:31:18 <lambdabot>     ‚Ä¢ Perhaps you meant variable ‚Äòeither‚Äô (imported from Data.Either)
17:31:23 <dmwit> ?hoogle EitherT
17:31:24 <lambdabot> Control.Monad.Trans.Either newtype EitherT e m a
17:31:24 <lambdabot> Control.Monad.Trans.Either EitherT :: m (Either e a) -> EitherT e m a
17:31:24 <lambdabot> package EitherT
17:31:59 <tobiasBora> dmwit: Great thank you !
17:32:26 <dmwit> (As a nitpick: you probably meant `return (Right ())`. Then you could also `EitherT (Right <$> putStrLn "Hi !")`. But the other ways are better.)
17:32:53 <tobiasBora> ok thanks
17:35:26 <mnoonan_> So I‚Äôve been using this pattern that I suspect might have a nicer alternative using Compose or some such: I have a type FooT :: (* -> *) -> * -> * that I want to use as a ‚Äúfunctor transformer‚Äù, in the sense that Functor f => Functor (FooT f)
17:35:51 <mnoonan_> furthermore, ‚ÄúFooT f t‚Äù is isomorphic to ‚ÄúFooF (f t)‚Äù for some honest functor FooF
17:36:33 <mnoonan_> and I want to tinker with fmaps at both layers
17:37:01 <mnoonan_> any ideas?
17:37:04 <dmwit> "tinker with fmaps"?
17:37:27 <dmwit> Also might be worth saying why you are not using `type FooT = Compose FooF`.
17:39:18 <mnoonan_> tinker with fmaps meaning that I want to have both of these:  `fmap :: Functor f => (a -> b) -> FooT f a -> FooT f b` and `otherFmap :: (f a -> f b) -> FooT f a -> FooT f b`
17:40:21 <mnoonan_> I think I just don‚Äôt quite get how Compose is used in practice
17:41:00 <dmwit> :t \f -> Compose . fmap f . getCompose
17:41:02 <lambdabot> forall k2 k1 (f :: * -> *) (g1 :: k2 -> *) (a1 :: k2) (g2 :: k1 -> *) (a2 :: k1). Functor f => (g1 a1 -> g2 a2) -> Compose f g1 a1 -> Compose f g2 a2
17:41:13 <dmwit> This is `otherFmap`.
17:42:13 <mnoonan_> yuk
17:42:30 <dmwit> It's not that bad if you ignore all the kind-polymorphism gunk.
17:42:45 <mnoonan_> the type signature bothers me less than the value, honestly
17:43:04 <dmwit> :t let otherFmap :: Functor f => (g a -> g b) -> Compose f g a -> Compose f g b; otherFmap f = Compose . fmap f . getCompose in otherFmap
17:43:06 <lambdabot> forall k1 (f :: * -> *) (g :: k1 -> *) (a :: k1) (b :: k1). Functor f => (g a -> g b) -> Compose f g a -> Compose f g b
17:44:28 <dmwit> :t let otherFmap :: forall (a :: *) b f g. Functor f => (g a -> g b) -> Compose f g a -> Compose f g b; otherFmap f = Compose . fmap f . getCompose in otherFmap
17:44:30 <lambdabot> Functor f => (g a -> g b) -> Compose f g a -> Compose f g b
17:44:33 <dmwit> there we go
17:45:40 <mnoonan_> ok, thanks. that seems straightforward enough.
17:47:56 <randomclown> Is there a way to pass -dynamic to GHC by default via environmental variables or via some system wide configuration?
17:48:15 <randomclown> for > ghc 8
17:51:52 <dmwit> I think it's possible to do something like that if you compile it yourself.
17:52:30 <dmwit> And you can set something in your ~/.cabal/config that will affect what flags cabal passes to ghc.
17:52:41 <dmwit> But that won't apply to invocations of GHC that don't come from cabal, of course.
17:53:58 <dmwit> I think it's `executable-dynamic: True` for the cabal config one.
17:54:49 <mniip> oh yeah
17:54:59 <mniip> in arch ghc can't compile anything without -dynamic
17:55:23 <randomclown> mniip: yeah it's so retarded
18:04:25 <tobiasBora> Hum...
18:04:33 <tobiasBora> I've a problem with Aeson (to parse json)
18:05:00 <tobiasBora> Most of the time I'm expecting a list of objects, so I get it using:
18:05:01 <tobiasBora> items :: [JT.Object]  <- media JT..: "items"
18:05:18 <Lis> hey everyone, is haskell on windows delivered as zip archive somewhere?
18:06:08 <tobiasBora> However, sometimes the items are empty in the json, so I get an error "Error in $.caption: expected HashMap ~Text v, encountered Null". How can I deal properly with this error, so that null is considered as an empty list (or here empty HashMap) ?
18:06:20 <geekosaur> I only see tar.xz
18:07:13 <Lis> in binary format?
18:07:26 <Lis> i mean haskell in binary without installer, just a zip file
18:07:27 <geekosaur> https://downloads.haskell.org/~ghc/8.2.1/ghc-8.2.1-x86_64-unknown-mingw32.tar.xz
18:07:35 <Lis> ty
18:07:51 <geekosaur> or i386 instead of x86_64 for 32 bit
18:07:54 <lyxia> tobiasBora: media JT..: "items" <|> return []    ?
18:14:04 <tobiasBora> lyxia: no, I still get an exception...
18:14:20 <tobiasBora> hum...
18:14:22 <tobiasBora> wait
18:14:30 <tobiasBora> the bug is quite strange, let me check
18:15:31 <lyxia> actually that won't work because media is already an Object
18:15:54 <lyxia> the <|> should go somewhere higher
18:22:49 <suzu> holy fuck free monads are super confusing
18:23:10 <Ero2> suzu: whats a free monad?
18:23:22 <suzu> i'm trying to add an action into a free monad that'll take a success action and a failure action, and a parser
18:23:34 <suzu> if the parser passes, exec the success action
18:23:37 <suzu> otherwise, run the fail
18:23:42 <lyxia> It's a monad that's unbound.
18:23:59 <suzu> the `free` package is TH-ing my constructor into a `:: Parser a -> m (Maybe a)`
18:24:06 <suzu> ??
18:25:22 <suzu> maybe i should stop messing with free monads and use tagless final instead..?
18:25:41 <suzu> lyxia: do you know anything about the `free` package?
18:25:43 <lyxia> suzu: what are your constructors
18:25:47 <lyxia> I do
18:26:03 <lyxia> and what type did you expect to get
18:26:21 <suzu> i have a constructor like this:
18:26:46 <suzu> data AgentF next where { RunParser :: (Parser p) -> (p -> next) -> next -> AgentF next }
18:27:04 <suzu> after `makeFree ''AgentF` i get:
18:27:07 <suzu> runParser :: MonadFree AgentF m0 => Parser p0 -> m0 (Maybe p0)
18:27:36 <suzu> reading the `Documentation` section on https://hackage.haskell.org/package/free-4.12.4/docs/Control-Monad-Free-TH.html
18:27:47 <suzu> seems to say that yes i'll get a Maybe or an Either depending on the signature of the constructor
18:27:54 <lyxia> Interesting.
18:28:02 <suzu> except i don't know if that's what i want, and i don't know what to do in the case that this is how it should be done
18:29:13 <lyxia> this looks correct to me
18:29:41 <suzu> if i have: (Parser p) -> (p -> next) -> (p -> next) -> AgentF next
18:29:53 <suzu> then i get an m (Either p0 p1)
18:30:13 <suzu> it looks 'correct' to me too, in that this is what the library says i'll get
18:30:18 <suzu> but i don't know what this means or how to work with it
18:30:55 <lyxia> Uh, it should be m (Either p p)
18:31:04 <suzu> err yeah that's what it is
18:31:07 <suzu> p0 p0, my bad
18:32:14 <lyxia> For your first type where the return type of runParser is a Maybe, what it did is pass Just and Nothing to the RunParser constructor, in addition to the Parser argument.
18:32:42 <suzu> pass Just and Nothing to the _constructor_?
18:32:57 <lyxia> RunParser theParser Just Nothing
18:33:26 <suzu> wtf.
18:33:57 <suzu> and in my second type, it's RunParse theParser Left Right?
18:34:01 <lyxia> Yes
18:34:14 <suzu> what is that supposed to do?
18:34:36 <suzu> pattern match on the outside?
18:34:42 <suzu> or, enable pattern matching on the outside?
18:34:49 <lyxia> the latter, yes
18:35:11 <suzu> case (runParser myParser) of { Just a -> yay parser worked; Nothing -> oh no }
18:35:25 <cobreadmonster> Hey guys.
18:35:26 <suzu> is how i could write code in the free monad, i'm guessing
18:35:55 <lyxia> almost. runParser myParser >>= \x -> case x of ...
18:36:48 <suzu> and when doing my catamorphism, i pass the first func the result of the parse if there is one, otherwise evaluate the second monad
18:37:22 <suzu> the first would come out into the Just, and the second is just the continuation inside the Nothing
18:37:31 <suzu> err yeah forgot the `>>=` to unwrap the m
18:38:39 <suzu> lyxia: is that correct ^?
18:38:50 <lyxia> yes
18:38:57 <lyxia> you got it
18:38:59 <suzu> cool. that is a bit mind-boggling
18:39:02 <suzu> how did you divine that?
18:39:12 <suzu> there's no way i could've just known this to work this way
18:39:52 <lyxia> It's always weird at first.
18:40:22 <suzu> ?
18:41:06 <suzu> did you read through some code somewhere to figure this out? or was there a piece of documentation i had skipped over when reading?
18:41:49 <lyxia> Not really. It's just intuition from experience with the concept.
18:42:07 <suzu> hmm. okay
18:42:28 <suzu> i had seen Either and Maybe used in working with type decls somewhere in TH-land but it didn't click when thinking about this.
18:42:57 <suzu> lyxia: if i were to have a third argument, would i get an Either (p, Either (p,p)) ?
18:43:26 <lyxia> I don't know actually, but that is possible.
18:43:28 <suzu> * wrapped in an m
18:43:39 <suzu> okay. that'll be a bitch to work with
18:43:51 <lyxia> I mean, if you were to write the code by hand you could use that.
18:44:04 <suzu> i -- guess so
18:44:15 <suzu> one more thing
18:44:29 <suzu> so now that i'm getting an `m (Maybe p)`
18:44:46 <suzu> if i wished to nest some logic underneath the Just/Nothing, and then underneath that Just/Nothing
18:44:54 <suzu> i think i'm going to be getting some ugly staircasing
18:45:04 <suzu> can i apply a MaybeT here inside my free monad?
18:45:11 <lyxia> Sure
18:45:18 <lyxia> MaybeT m p
18:45:40 <suzu> and then runMaybeT :: MaybeT m p -> m (Maybe p)?
18:45:50 <lyxia> exactly
18:45:53 <suzu> sweet.
18:46:09 <suzu> should i even be using free monads, or is tagless final a better choice?
18:47:14 <suzu> that is, just write my "constructors" as functions under a typeclass: runParser :: AgentMonad m => Parser p -> (p -> m a) -> (p -> m a) -> m a
18:47:48 <suzu> and just swap typeclasses out to have different interpreters. `instance MonadIO m => AgentMonad m` for execution.. etc
18:49:43 <lyxia> I'm more used to the final thing, but in principle both are fine.
18:51:08 <suzu> ok. might move everything over to that later on, depending how i still feel about this project
18:51:15 <suzu> thanks a lot for your help, lyxia 
18:53:09 * hackagebot open-union 0.3.0.0 ‚Äì Extensible, type-safe unions. ‚Äì https://hackage.haskell.org/package/open-union
18:53:21 <lyxia> suzu: I'd recommend free just so I can see more of it out there!
18:56:39 <Ero2> stack is telling me my build plan has failed because "must match -any, but the stack configuration has no specified version
18:56:47 <Lokathor> how do you specify the minimal definition for a typeclass?
18:56:53 <Lokathor> isn't it some pragma thingy?
18:57:15 <Ero2> Lokathor: are you talking about implementing an instance of a typeclass?
18:57:24 <lyxia> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#minimal-pragma Lokathor 
18:57:32 <Lokathor> no i'm talking about writing a typeclass and specifying what its minimal definiton is
18:57:42 <Lokathor> a ha
18:57:45 <MarcelineVQ> Lokathor: you can also ask base :>   http://hackage.haskell.org/package/base-4.10.0.0/docs/src/GHC.Base.html#Applicative
18:57:47 <Lokathor> yes, what lyxia said
18:58:09 <Lokathor> MarcelineVQ, I tried to find Eq in base but it was not there to be an example for me :(
18:58:19 <MarcelineVQ> Eq is a jerk.
18:59:44 <suzu> lyxia: writing code for work so won't be out there :(
19:00:19 <lyxia> Ero2: stack uses snapshots to pin the versions of packages. The error you get means that a dependency is not part of the snapshot specified by the resolver in stack.yaml, so you need to add it as an extra-deps
19:00:24 <suzu> trying to show off the best of haskell so that i can sell my employer here on it
19:00:27 <suzu> :)
19:00:43 <boogalooga> Can someone help me out
19:00:43 <boogalooga> ?
19:00:45 <boogalooga> https://imgur.com/a/oJgKi
19:00:52 <boogalooga> Why does this give me the error
19:01:08 <boogalooga> Variable not in scope: skips :: [Integer] -> t
19:01:17 <boogalooga> When i try to run skips [1, 2, 3]
19:01:31 <MarcelineVQ> Ero2: what lyxia said.   + or that something about your project isn't quite set up right resulting in a spurious error. hard to say without more of the error, or a gander at your project's cabal and stack files
19:01:50 <mniip> boogalooga, how are you loading it in ghci?
19:02:02 <boogalooga> :r
19:02:11 <boogalooga> well :l Golf
19:02:12 <boogalooga> first
19:02:17 <boogalooga> oh wait a minute
19:02:32 <boogalooga> I think I'm still on a file which was loaded for the previous problem set
19:02:34 <boogalooga> ohhh
19:02:38 <boogalooga> wow, I'm stupid
19:02:39 <boogalooga> sorry
19:03:08 <suzu> :D
19:03:17 <boogalooga> that was quite silly
19:11:44 <Ero2> thkanks MarcelineVQ / lyxia . turns out i have a capital letter in a build-depends when it should have been lower case?? I'm not sure why that is but hey
19:12:26 <Ero2> my library exposes Ex1 but the test file build-depends needed to be ex1 and not Ex1. Why is  that?
19:14:15 <lyxia> Do you mean that your library is named Ex1, or do you mean that it exposes a module named Ex1?
19:14:16 <MarcelineVQ> build-depends aren't modules they're packages/libraries. if your project is called ex1 then so is your project's library regardless of the modules it contains.
19:15:21 <Ero2> lyxia: the library clause of my .cabal has a line saying exposed-modules : Ex1
19:16:05 <Ero2> ah i think i've figured it out now that you have brought my attention to that lyxia 
19:28:55 <jchia> Anybody using the package 'algebraic-graphs' (alga)? How can I give labels to the nodes and arcs?
19:32:50 <suzu> i dont know anything about algebraic-graphs but i just looked at the haddock
19:33:07 <suzu> you can maybe give labels to nodes by encoding them into your `Graph a`
19:33:35 <suzu> as in, a `Graph Text` would be a graph where the vertices are Texts
19:33:38 <jchia> suzu: OK, but arcs still have no labels.
19:33:48 <suzu> yes, arcs have no labels. i dont think you can do that.
19:33:58 <jchia> suzu: Thanks
19:34:08 <suzu> i could be wrong but yyw
19:34:09 <suzu> yw *
19:36:58 <roi_du_silence> does gloss with glfw backend actually work ?
19:44:14 <ackpacket> In an interview the other day I couldn't help but think "This could be done in 3 lines of haskell.  One for the work, one for the base case, one for the type declaration"
19:44:37 <ackpacket> I've been infected
19:45:31 <tmerr1> should i turn back now before it's too late
19:45:52 <suzu> i remember i solved a problem in two lines of haskell in an interview
19:46:02 <ackpacket> suzu, then they asked you wtf haskell is?
19:46:17 <suzu> it was "can-a-knight-on-a-chess-board-get-to-x',y'-from-x,y"
19:46:43 <suzu> so i ran the get-next-move function n times in the list monad
19:46:59 <suzu> replicateM n get-next-move or something
19:47:08 <suzu> ackpacket: lol, yes.
19:47:19 <suzu> i explained what it did and showed it in ghci
19:47:23 <suzu> on my laptop
19:47:28 <suzu> :P
19:48:44 <ackpacket> suzu, quite honestly, you didn't bypass the interview -- you just turned it away from x% can he code, y% can he communicate, to 95% can he communicate
19:48:53 <suzu> you're absolutely correct
19:49:09 <suzu> i was lucky in this instance in that the interviewer had seen a little bit of haskell before and thought it was really cool
19:49:27 <ackpacket> If you were able to explain monads to someone during an interview, hats off
19:49:35 <suzu> oh yeah that's easy
19:49:39 * suzu brings a burrito to the interview
19:49:43 <suzu> ;)
19:49:58 <tmerr1> how did you prevent infinite recursion? or did you just know how to choose an n that was sufficiently large
19:50:16 * tmerr1 doesnt know haskell ha-ha
19:50:59 <suzu> they gave me the n
19:51:20 <tmerr1> oh, ok
19:51:44 <ackpacket> suzu, what was get-next-move?
19:52:20 <Ero2> i'd like to make my function point free. But orders of precedence make less sense at 4am. Please help?
19:52:21 <suzu> \(x,y) -> [(x+2, y+1), (x+1, y+2), ...]
19:52:24 <Ero2> sumDigits       :: [Integer] -> Integer
19:52:24 <suzu> however a knight moves
19:52:27 <Ero2> sumDigits xs       = foldr (+) 0 $ concat $ map toDigits xs
19:52:44 <suzu> hmm try
19:52:58 <suzu> sumDigits = foldr (+) 0 . concat . map toDigits
19:53:13 <Ero2> aha
19:53:20 <suzu> i just lifted the `xs` off both ends :)
19:53:23 <Ero2> i had a $ after 0 when i triedthat
19:53:36 <Lokathor> Ero2, ask lambdabot
19:53:43 <Lokathor> @pl \x y -> x+y
19:53:43 <lambdabot> (+)
19:53:52 <suzu> pl?
19:54:10 <iqubic> suzu: A knight moves two steps in on direction, and then one step in an orthogonal direction
19:54:13 <suzu> (P)ointfree-this-i-am-too-(L)azy?
19:54:30 <suzu> iqubic: yes, i know
19:54:43 <Ero2> ~~
19:54:51 <suzu> oh i was not asking a question - i was answering ackpacket's question
19:57:52 <ackpacket> Any tips for accessing a 1-5M hashmaps many times?  I have no idea how cache coherrency works in haskell
19:57:54 <Ero2> is that really what it stands for? ~~
19:58:45 <geekosaur> it's more the joke, pointfree = pointless
19:58:53 <iqubic> ackpacket: is that 1 to 5 million?
19:59:00 <Ero2> phew, my pride :)
19:59:06 <Lokathor> ackpacket, assume that it's all cache misses :P
19:59:17 <ackpacket> iqubic, 1 million to 5 million
19:59:18 <Lokathor> that's why you're supposed to use Vector over Map when you can :3c
19:59:19 <geekosaur> referring to the fact that pointfree i often harder to understand than the original, especially when it starts flipping its dots at you
19:59:41 <suzu> as soon as a pointfree has a dot
19:59:47 <geekosaur> (or is that, going flipping dotty?)
20:00:11 <suzu> i dont think i've pointfree-d in a very long time
20:00:15 <suzu> it's all the same to the compiler
20:00:19 <suzu> but it's definitely not all the same to me
20:00:39 <geekosaur> sometimes you can get better code because the compiler can optimize it better. but I think that's relatively rare these days
20:00:45 <erisco> pl is a tool and does not speak for all pointfree code
20:00:47 <MarcelineVQ> it's also not the same to the compler, but don't worry about that
20:00:52 <Ero2> i still struggle to correctly identify how $ or . is going to affect the application of my function
20:01:06 <suzu> a pointfree function? i thought it does compile down to the same thing after passes
20:01:31 <Ero2> surely beta reduction equalises point free and... not-point-free?
20:01:39 <Lokathor> suzu, there's a thing called a Constant Applicative Form, and if you point-free your function into being a CAF, it changes how the code works at runtime
20:01:52 <suzu> oh i think i've seen those in benchmarks
20:02:03 <suzu> main.CAF, somethingOrOther.CAF
20:02:07 <Lokathor> you get the same outputs, but it does fiddly things to memory usage and memoization and stuff
20:02:56 <tmerr1> in haskell i thought . was an infix operator? is it prefix in your knoghts example suzu? i am having a hard time reading the fold 
20:03:22 <tmerr1> i was assuming it was function composition
20:03:27 <suzu> ? i didn't use a . in my knights example
20:03:36 <suzu> and yes, . is infix function composition
20:04:02 <tmerr1> oh, i see, you were helping Ero2
20:04:13 <Ero2> i need lots of that :)
20:06:50 <tmerr1> ok beautiful people, i am trying to get started with my first haskell program, but when i try to cabal install my dependency it gives me an error
20:06:53 <tmerr1> http://lpaste.net/359166
20:07:49 <tmerr1> do these errors ring any bells?
20:08:35 <glguy> Looks like you deleted some of the library files that you get from installing GHC
20:08:51 <glguy> unless this is Arch Linux?
20:08:55 <tmerr1> it is ARch
20:09:01 <glguy> Arch broke its GHC install
20:09:10 <glguy> you'll need to consult its wiki as usual
20:09:19 <tmerr1> aha. thanks for the pointer, i'll check it out
20:10:16 <lyxia> The amount of issues this is causing is so absurd.
20:10:39 <glguy> It's part of the Arch experience
20:11:15 <iqubic> glguy: Have you pushed version 2.24 of glirc to hackage yet?
20:11:35 <glguy> iqubic: There's no way to know
20:11:50 <iqubic> What does that mean?
20:12:54 <iqubic> I'm on NixOS and glirc only compiles and installs if I disable the test phase.
20:13:13 <iqubic> I think this is an artifact of 2.23 having test that don't quite work.
20:13:17 <glguy> yeah
20:15:12 <tmerr1> that wasn't too hard, fixed. thanks!
20:15:20 <iqubic> You can even get this behavior with nix on other OSes.
20:18:40 <Ero2> MarcelineVQ: i'm ready for my score now :)
20:19:04 <MarcelineVQ> 7
20:19:17 <Ero2> what D:
20:19:26 <Ero2> but...
20:20:33 <tmerr1> nice! cabal is usable. i'm running hello world. this is exciting
20:21:09 <tmerr1> time to tell all my friends about monads
20:21:27 <Ero2> dont forget to mention how they are monoids in the category of endofunctors
20:21:32 <iqubic> LOL
20:21:51 <EvanR> that...
20:21:58 <EvanR> no
20:22:12 <EvanR> tell your friends about Functors instead
20:22:27 <Ero2> i was tihnking about that the other day and BAM it made sense
20:22:55 <iqubic> Ero2: Makes no sense to me.
20:23:20 <Ero2> well....
20:23:22 <EvanR> its a random observation about monads
20:23:41 <Ero2> the monoid bit is easy
20:23:42 <EvanR> not useful or impressive
20:23:57 <EvanR> monoid objects are not that simple
20:25:15 <Ero2> i watched brian beckman explain how clocks are a monoid
20:25:28 <Ero2> monoids were my best friends after that
20:25:33 <Ero2> i started seeing monoids everywhere
20:25:41 <erisco> many Linux distros teach you about computers by giving you perpetual bug fixing opportunities
20:25:47 <iqubic> Ero2: You have a link to the video>
20:26:05 <Ero2> https://www.youtube.com/watch?v=ZhuHCtR3xq8
20:26:27 <EvanR> time of day is a monoid? ...
20:26:43 <boogalooga> https://imgur.com/a/wnFr4
20:26:44 <EvanR> doesnt seem to make sense
20:26:54 <boogalooga> anyone know how I can write this without recursion
20:27:01 <boogalooga> so using filter/reduce/map
20:27:04 <boogalooga> or smth
20:27:08 <tmerr1> seems like monoids are mathematically simple, they're just not that interesting, unless you're proving things about them
20:27:26 <erisco> it is funny how the same questions get asked in a short interval of time
20:27:41 <EvanR> "monads are a way to solve the XY problem in haskell" (probably mishearing hilarious)
20:27:49 <EvanR> ly
20:28:28 <Ero2> go to 20:50 iqubic / EvanR 
20:28:34 <erisco> boogalooga,  zip3 xs (drop 1 xs) (drop 2 xs)  will give you a list of elements in their adjacency context
20:30:46 <EvanR> ok, adding numbers on the clock, mod 12, pretending 12 stands for zero, now you have a monoid, 12 is the identity
20:30:59 <Ero2> yup you got it :P
20:31:31 <EvanR> but in this example you also have a group
20:31:31 <boogalooga> wow
20:31:35 <boogalooga> interesting
20:31:49 <EvanR> whats an everyday example of a monoid that is not a group
20:32:04 <Ero2> i created a monoid to show a players hand for a card game
20:32:23 <erisco> also you may want to be careful about your condition, because it excludes plateaus, even if the plateau is maximal
20:32:25 <tmerr1> i bet u see jesus in toast
20:32:26 <iqubic> Ero2: How did you do that?
20:32:42 <Ero2> lets see if i can remember...
20:32:52 <erisco> consider  x > y && x >= w  instead
20:34:17 <iqubic> Are lists a monoid with mappend = (++) and id = ([])?
20:34:24 <boogalooga> so you mean for something like [1, 1, 0] 1 should be a plateau
20:34:25 <boogalooga> ?
20:34:37 <boogalooga> sorry *local max
20:35:05 <EvanR> iqubic: can you prove it
20:35:34 <erisco> it isn't good enough because when descending you can hit a plateau, but it is not maximal
20:35:43 <iqubic> How would I prove that?
20:35:53 <erisco> so really you want to compress plateaus into a single element, and this can be done by grouping
20:36:07 <erisco> :t Data.List.NonEmpty.group
20:36:09 <lambdabot> (Eq a, Foldable f) => f a -> [Data.List.NonEmpty.NonEmpty a]
20:36:26 <EvanR> you need to argue why the monoid laws are followed for any combination of lists, and those operations
20:36:40 <iqubic> I know that they are.
20:36:48 <erisco> > Data.List.NonEmpty.group [1,1,0]
20:36:52 <lambdabot>  error:
20:36:52 <lambdabot>      Not in scope: ‚ÄòData.List.NonEmpty.group‚Äô
20:36:52 <lambdabot>      No module named ‚ÄòData.List.NonEmpty‚Äô is imported.
20:37:07 <EvanR> I know nothing
20:37:11 <rotaerk> jon snow
20:37:26 <Ero2> iqubic: ive forgotten... but i did do it ;)
20:37:31 <erisco> I don't know the import command for lambdabot
20:37:41 <Ero2> i'll remember it for next time :D
20:37:57 <iqubic> @let import Data.List.NonEmpty.Group
20:37:58 <lambdabot>  .L.hs:104:1: error:
20:37:58 <lambdabot>      Could not find module ‚ÄòData.List.NonEmpty.Group‚Äô
20:37:58 <lambdabot>      Perhaps you meant Data.List.NonEmpty (from base-4.10.0.0)
20:38:02 <iqubic> @let import Data.List.NonEmpty
20:38:03 <lambdabot>  .L.hs:174:23: error:
20:38:03 <lambdabot>      Ambiguous occurrence ‚Äònub‚Äô
20:38:03 <lambdabot>      It could refer to either ‚ÄòData.List.nub‚Äô,
20:38:13 <EvanR> interesting kind of monoid that can be used as a parser https://www.youtube.com/watch?v=Txf7swrcLYs
20:38:14 <iqubic> Well, that's the syntax for that.
20:38:19 <erisco> @let import qualified Data.List.NonEmpty as NonEmpty
20:38:21 <lambdabot>  Defined.
20:38:31 <erisco> > NonEmpty.group [1,1,0]
20:38:34 <lambdabot>  [1 :| [1],0 :| []]
20:38:42 <EvanR> a monoid that can be used as a "shower" would be interesting
20:39:07 <iqubic> Why are you talking about bathroom things?
20:39:14 <iqubic> LOL I just misread that.
20:39:22 <EvanR> i was wondering what the joke response to that would be
20:39:30 <Ero2> iqubic: it had something to do with rather than a players hand consisting of cards, it consisted of 'card actions' where 'gain a card' or 'lose a card' were actions
20:39:47 <iqubic> Ero2: I see.
20:39:53 <EvanR> and "do nothing" i guess
20:40:13 <iqubic> Ero2: That's an odd way to formulate that.
20:40:25 <erisco> and, since you really do not care about the duplicates
20:40:39 <erisco> > fmap NonEmpty.head (NonEmpty.group [1,1,0])
20:40:42 <lambdabot>  [1,0]
20:40:43 <iqubic> EvanR: "do nothing" would be id.
20:40:57 <Ero2> and there were only a few types of cards, i could lift a single card into a hand type, and then fold over the changes to a players hand
20:41:40 <erisco> now your criteria should work
20:41:47 <Ero2> for some reason at the time it was a good way to do it but i cant remember why
20:42:05 <tmerr1> an example of a monoid that's not a group is the set of integers >= 0, under addition. since x + y is associative, has an identity element 0, but it's not a group since you would need invertability for all elements but you need negative numbers to invert positive nubmers
20:42:25 <erisco> why?
20:42:41 <erisco> you just need the inverse property
20:42:46 <Ero2> by group we dont mean semi-group?
20:43:42 <tmerr1> yes a group is just a monoid + inverse property
20:43:45 <tmerr1> there's a table somewhere
20:44:06 <tmerr1> here ya go https://en.wikipedia.org/wiki/Monoid#ref_Alpha
20:44:07 <Ero2> once upon a time i knew what a magma was
20:44:20 <iqubic> I wish I knew more about Catagory Theory.
20:44:25 <MarcelineVQ> it's the snot that comes out of a dragon with a flu
20:44:48 <Lokathor> lava and magma are melted rocks
20:44:55 <Lokathor> something about one is under the ground and one is above the ground
20:45:21 <erisco> yes, that's right, last I heard in elementary geology class
20:45:33 <erisco> or was it from Ms. Frizzle‚Ä¶ hard to remember
20:45:51 <MarcelineVQ> geology, with the friz? no way.
20:46:21 <Lokathor> I have it on good authority from a Toad that if you make a forge out of Bauxite you can heat it with magma and your forge won't melt while you use it
20:46:31 <Lokathor> saves a bundle on coal
20:47:28 <erisco> I have video evidence that you can make a forge out of a loaf of bread
20:47:32 <MarcelineVQ> The material you use to make a workshop doesn't impact envrionmentals, you can make it out of wood
20:47:55 <MarcelineVQ> you want to use bauxite or cinnabar or w/e to craft mechanisms that won't melt
20:48:00 <Lokathor> ah, hmm, only one of you knew what i was talking about. Shame on you erisco :P
20:48:23 <erisco> of course I have no idea what you are talking about‚Ä¶ I am just stating something else interesting :P
20:48:37 <Ero2> well, we arent NERDS like you, Lokathor !!
20:48:59 <Lokathor> http://www.bay12games.com/dwarves/
20:49:08 <erisco> iirc bauxite is a name for unrefined ore, or a particular kind of, maybe what they get aluminium from
20:49:16 <Lokathor> it is
20:49:17 <Lokathor> correct
20:50:05 <glguy> I remember that because a certain high school tech teacher tried to explain that aluminum couldn't be an element because it was made from bauxite
20:50:08 <erisco> oh, that game‚Ä¶ the graphics are great but the mechanics are super clunky
20:50:18 <Ero2> i was going to ask tmerr1 what invertibility buys a group but looks like he couldnt take the humour
20:50:18 <Lokathor> folks I have a package called hexes, and it started as a curses-like library for grid-based textual display. It's supposed to be a joke that it's a hex and not a curse, but people think it's for hexadecimal or hexagons
20:50:32 <Lokathor> If i were to do a big rewrite, should I also come up with a new name?
20:50:48 <EvanR> nitrogen cant be an element because its made from air
20:51:04 <EvanR> hydrogen cant be an element because its made from the big bang
20:51:16 <Lokathor> erisco, i think you have the mechanics/graphics a little reversed there pal (says the one who just brought up his lib that essentially makes DF graphics)
20:51:49 <EvanR> astronomical society makes hydrogen a minor element
20:51:56 <Ero2> night all
20:52:15 <aijony> Bon nuit!
20:52:39 <Lokathor> bonan nokton
20:54:02 <Ero2> Lokathor: something to do with battle isle probably
20:54:06 <Ero2> nn again
20:54:20 <Lokathor> no, esperanto for "good night"
20:55:00 <Lokathor> so if someone were writing a replacement for the random library
20:55:09 <Lokathor> and they wanted to have a "split" funciton because it really is a good idea
20:55:23 <Lokathor> would you split it into a seperate typeclass that's a subclass of RNG
20:55:23 <EvanR> i would think that a grid of rectangular image stamps was the simplest possible graphical thing to make from scratch
20:55:38 <Lokathor> or keep it in the main class even though not every generator supports sane splitting
20:56:19 <Lokathor> EvanR, it's rather easy once you know how. Giving it a good interface and also a good API is always the trick :P
20:56:28 <EvanR> the question was if any RNG supports sane splitting
20:56:47 <Lokathor> well, the PCGen family of RNGs does, for sure
20:56:54 <EvanR> really?
20:57:21 <Lokathor> they have an internal state, and an internal "inc", which controls the number stream they're within. To split you just adjust the inc value
20:58:06 <EvanR> s/sane/has provably correct statistical behavior/
20:58:28 <Lokathor> adjusting the inc value will provably move you into a new, fully distinct number stream
20:58:47 <EvanR> im asking for a paper on that or something
20:59:19 <Lokathor> http://www.pcg-random.org/ has lots of friendly info, http://www.pcg-random.org/paper.html is the paper
21:03:01 <erisco> EvanR, I don't think anyone has an emotional attachment to hydrogen, though
21:03:21 <iqubic> H2O has too many names.
21:03:49 <erisco> it covers most of our planet‚Ä¶ it deserves a few
21:04:15 <MarcelineVQ> I call mine evany
21:04:36 <iqubic> Hydrogen Oxide. Hydroxide Acid. Hydrogen Hydroxide. Dihydrogen Monoxide. Water.
21:05:07 <EvanR> Dasani (R)
21:05:20 <erisco> and "wader", for those who flap
21:05:22 <iqubic> Agua.
21:05:27 <iqubic> Mayim.
21:05:30 <EvanR> OK
21:05:50 <iqubic> Too many names.
21:05:57 <Lokathor> is a typeclass that extends another called a "subclass"
21:06:00 <Lokathor> or is that too OO?
21:06:23 <erisco> "extends"? how obscene!
21:06:28 <iqubic> Lokathor: It is called a subclass.
21:07:19 <iqubic> You mean something like: Class (Functor f) => Applicative fa where .....
21:07:51 <iqubic> Applicative is a subclass of Functor.
21:08:19 <Lokathor> yes like that
21:08:23 <Lokathor> class RNG g => SplitRNG g where
21:09:49 <erisco> classes are not types, and so if you are going to borrow the terminology then be wary of that
21:10:36 <Lokathor> i didn't name it classes with instances
21:10:44 <Lokathor> that's one of the simons you should blame
21:11:26 <EvanR> typeclasses are not types... oop classes are not types...
21:11:36 <EvanR> types are not types
21:11:42 <EvanR> paradox
21:12:04 <Lokathor> type Class = NotType
21:12:09 <erisco> I don't know if that was motivated by OOP, though, whereas you stated that as your motivation
21:12:30 <Lokathor> I was afraid of being Object Oriented largely in jest
21:14:46 <erisco> I am more inclined to see it as implication, though you have to read the arrow the other way
21:14:57 <erisco> I am not sure what the official wording is
21:15:30 <Lokathor> Things before the => are "constraints", i'm told
21:15:42 <Lokathor> I read the => as "allows" when I need to read a signature out loud
21:17:35 <erisco> you can read it forward, like it is a constraint function
21:17:43 <EvanR> => is backwards in the class syntax
21:17:58 <erisco> class A => B where ‚Ä¶  says "give me A and I'll give you B"
21:18:01 <EvanR> "if you have this, then you have this", is backwards
21:18:14 <EvanR> no
21:18:26 <erisco> yes
21:18:34 <Lokathor> with classes, it's "requires", not "gives", instances are "gives"
21:18:35 <EvanR> class A => Foo B where
21:18:43 <erisco> I've had this discussion before
21:19:02 <EvanR> blurg
21:19:32 <erisco> eh sure whatever, "Foo" is just the name of the function
21:19:38 <EvanR> class Foo a => Bar a where
21:20:32 <EvanR> given a Bar implementation for a, you get a unique Foo implementation, or something is horrible wrong
21:20:37 <EvanR> horribly
21:20:59 <erisco> yes, so?
21:21:16 <EvanR> so its like, Bar a => Foo a
21:21:29 <EvanR> if you think about implication or functional
21:22:02 <erisco> that is a perspective, it is all the same thing
21:22:20 <erisco> you could just be observing the injectivity, from the other view
21:22:35 <mniip> EvanR, "C =>" in a type implies that it's required that C holds
21:22:45 <EvanR> injectivity would be a different phenomenon
21:23:31 <EvanR> C => "in a type" ?
21:24:01 <EvanR> you mean, in a class declaration
21:24:05 <mniip> in either
21:24:11 <mniip> (==) :: Eq a => a -> a -> Bool
21:24:11 <EvanR> it doesnt mean that in a type sig
21:24:16 <mniip> class Eq a => Ord a where
21:24:30 <EvanR> Eq a is not required to hold for all a
21:25:02 <EvanR> it also doesnt mean that in an instance declaration
21:25:12 <mniip> yeah for all other a's you can't use this
21:25:30 <EvanR> you could write an instance whose antecedents are impossible
21:25:45 <EvanR> but it compiles
21:25:56 <mniip> so?
21:26:07 <Lokathor> whose antecedents are impossible ?
21:26:13 <nshepperd> 'f :: Eq a => a -> a -> Bool' means that there's a function that takes Dict (Eq a) and produces a -> a -> Bool
21:26:27 <EvanR> so youre only talking about the special snowflake "retromeaning" of C => in a class declaration
21:26:37 <nshepperd> 'class Eq a => Ord a' means that there's a function that takes Dict (Ord a) and produces Dict (Eq a)
21:26:54 <mniip> nshepperd, actually
21:26:55 <EvanR> agree with nshepperd 
21:26:56 <mniip> the inverse
21:27:23 <nshepperd> mniip: which inverse
21:27:59 <cocreature> nshepperd: class Eq a => Ord a gives you a Dict (Eq a) for each Dict (Ord a)
21:28:16 <nshepperd> cocreature: yes... that's what I said
21:28:28 <cocreature> oh right I can‚Äôt read, sry
21:29:01 <EvanR> yeah and that function is injective, properly injective, and reading it the other way gives you a not-even-a-function
21:29:30 <EvanR> its really wacky!
21:30:04 <mniip> well, in an 'instacnce C => I'
21:30:05 <EvanR> not that i can think of a better way to spell it
21:30:16 <mniip> you have a function that takes a C dict and returns an I dict
21:30:23 <EvanR> right
21:30:29 <mniip> 'class D => I' is like passing an implicit dict D to all instances
21:31:09 <mniip> and as a consequence, a Dict I -> Dict C function can be constructed
21:31:23 <EvanR> er... its all global
21:31:35 <EvanR> except in polymorphic functions
21:31:53 <erisco> EvanR, how is that not a complete reversal of what you were saying before?
21:32:01 <erisco> if you agree with nshepperd, that is
21:32:05 <EvanR> no
21:32:33 <EvanR> for concrete I C D you dont need to pass dictionaries around
21:32:39 <mniip> sure
21:33:09 <mniip> for a simple enough program you don't need to execute it, you can know the answer right away
21:33:20 <EvanR> and the function from Dict (Ord a) to Dict (Eq a) is global, and it can see all instances
21:33:20 <nshepperd> The only way I can see to justify the direction of the arrow is
21:33:34 <mniip> EvanR, "see all instances"?
21:33:35 <erisco> okay, well, I don't know what I C D is about, but I did not specify what my A B ranged over, though the answer is constraints
21:34:08 <erisco> and when you said "Foo B" I should have said "Foo" is the name of a constructor
21:34:15 <nshepperd> 'class Eq a => Ord a' creates the function Dict (Ord a) -> Dict (Eq a)
21:34:16 <EvanR> calling it a constraint doesnt really help much, since the instance selection thing is so simplistic
21:34:25 <mniip> indeed, it does
21:34:41 <mniip> Dict (Ord a) constains Dict (Eq a) as a field
21:35:06 <nshepperd> whereas 'f :: Eq a => a -> a -> Bool' creates an obligation to create the function Dict (Eq a) -> (a -> a -> Bool), by implementing f
21:36:07 * hackagebot tomlcheck 0.1.0.1 ‚Äì Command-line tool to check syntax of TOML files ‚Äì https://hackage.haskell.org/package/tomlcheck
21:36:08 <EvanR> class Ord a < Eq a where
21:36:09 <nshepperd> which at least results in the Dict (Eq a) being in the 'positive' position again
21:36:17 <erisco> instances are part of the implementation, not that relevant to what I was trying to say
21:36:19 <nshepperd> if only in some weak-ass 'morally' way
21:37:22 <mniip> data Ord a = Ord (Eq a) (a -> a -> Ordering)
21:37:45 <EvanR> you could see => as being a less that or equal sign!
21:37:54 <EvanR> but the equal wouldnt make sense
21:38:08 <dpn__> hey.. somewhat noob here.. I'm trying to use the Network.AMQP lib that lets you consume from rabbitmq. Unfortunately the consumer takes a callback... not great for doing something with a collection of results
21:38:21 <dpn__> coudl i use a state monad + coroutines or something to deal with this?
21:38:47 <dpn__> https://github.com/rabbitmq/rabbitmq-tutorials/blob/master/haskell/receiveLogsTopic.hs#L36
21:38:51 <dpn__> that's the offending call
21:39:55 <cocreature> dpn__: I would probably write to a Chan from within that callback and then have a separate thread read from that chan
21:41:31 <dpn__> cocreature: ok thanks.. i was looking at solutions like that too... I guess I would have essentially implemented something that would have done that
21:41:36 <dpn__> didn't know about chan.. thanks
21:42:39 <cocreature> dpn__: which chan you use probably doesn‚Äôt matter, base has Chan and TChan for unbounded chans and TQueue for bounded chans. there is also the unagi-chan package which provides chans that are potentiall a bit faster but for this usecase I doubt it matters
21:43:21 <EvanR> you could also use an MVar as a very bounded chan
21:44:35 * hackagebot tomlcheck 0.1.0.2 ‚Äì Command-line tool to check syntax of TOML files ‚Äì https://hackage.haskell.org/package/tomlcheck
21:53:23 <Lokathor> >> There is a single, implicit, global random number generator of type StdGen, held in some global variable maintained by the IO monad. It is initialised automatically in some system-dependent fashion, for example, by using the time of day, or Linux's kernel random number generator.
21:53:38 <Lokathor> the source code says... that's somewhat a lie :P
21:54:36 <Lokathor> oop! no, i take it back, it's just split into two parts
21:54:55 <iqubic> Isn't StdGen the same from one run of a program to the next?
21:55:10 <Lokathor> nope
21:55:21 <iqubic> Or is that a lie that LYAH fed me.
21:55:24 <iqubic> ??
21:55:37 <Lokathor> the global StdGen value is set with: createStdGen (sec * 12345 + psec + ct + o)
21:55:48 <Lokathor> where ct, sec, and psec are all set based on system time info
21:55:48 <iqubic> I see.
21:56:10 <Lokathor> "12345" sounds super technical and fact checked
21:56:16 <Lokathor> i trust that constant
21:56:26 <iqubic> but want if I want two different random numbers in my program?
21:56:51 <Lokathor> well each use advances the generator as it produces an output, so you can just call randomIO twice, for example
21:56:52 <iqubic> I can't just say "randomNum = 4" can I.
21:57:03 <Lokathor> you cannot, using the global RNG is an IO operation
21:57:35 <iqubic> But 4 is a great random number. I got it from a D6 just now.
21:57:39 <Lokathor> but we do all know that 4 is the most random number, at least
21:57:44 <Lokathor> yes
21:58:05 <iqubic> It's an XKCD reference.
21:58:12 <Lokathor> i know >_>
21:58:47 <Lokathor> so the question is if we WANT a global RNG
21:58:58 <Lokathor> sadly, as much as it hurts my soul to say it, i think we do, just for simplicity
21:59:02 <iqubic> I think we do.
21:59:20 <iqubic> How else would one get a random number?
21:59:44 <Lokathor> the System.Random global RNG is set by the time, which isn't too "secure", in the crypto sense
21:59:58 <Lokathor> and it's not very good for seeding for some generators (dunno about StdGen specifically)
22:00:09 <Lokathor> you can ask the OS for stuff from its CSPRNG
22:00:35 <iqubic> But can you do that in haskell?
22:00:38 <Lokathor> but then you have to do conditional compilation to pick the right system calls and stuff (GHC can ask the system for the time for you)
22:00:47 <Lokathor> yeah Haskell can make a C call
22:01:40 <iqubic> Oh. But that's more complex than what the average Haskeller wants to do.
22:01:56 <Lokathor> so much less than you'd think with the HOT AND SLICK inline-c package
22:02:03 <Lokathor> write your C code like it was just an IO action away
22:02:37 <Lokathor> https://github.com/Lokathor/galaxy-break/blob/master/src/ConcurrentConsole/Win32.hs#L50 Type signature like Haskell, guts like C
22:02:40 <Lokathor> what a monster
22:02:51 <iqubic> But that requires you to know C.
22:03:02 <Lokathor> so does life
22:03:03 <iqubic> Can't we just wrap that up in a function?
22:03:14 <iqubic> One that does the right calls for you,
22:03:15 <Lokathor> I don't understand the question
22:03:35 <Lokathor> yes, well, you can
22:03:41 <Lokathor> but like, you know, someone has to do it at some point
22:03:47 <Lokathor> and not everyone has always done it already
22:04:38 <iqubic> Are you proposing that we change the way randomness works in haskell?
22:05:16 <Lokathor> Well, yes, but actually that's not part of the system calls being different on different platforms issue
22:09:56 * hackagebot madlang 2.4.2.14 ‚Äì Randomized templating language DSL ‚Äì https://hackage.haskell.org/package/madlang
22:13:12 <Lokathor> Folks I just want to say
22:13:31 <Lokathor> haddock looks slightly worse than rustdoc, but generated haddock looks 1000x better than generated rustdoc
22:14:57 <osa1> what do you mean by "generated haddock"?
22:15:14 <Lokathor> the HTML output
22:17:33 <Lokathor> iqubic, the worst part about inline-c is that your editor never understands what's going on
22:17:39 <Lokathor> poor editor
22:27:09 * hackagebot recursion-schemes-ext 0.2.1.0 ‚Äì Amateur addenda to recursion-schemes ‚Äì https://hackage.haskell.org/package/recursion-schemes-ext
22:38:54 <roi_du_silence> hello
22:38:58 <Lokathor> yo
22:40:29 <roi_du_silence> trying to build gloss with the gflw = true flag yields me this error : Module ‚ÄòGraphics.UI.GLFW‚Äô does not export ‚ÄòWindowValue(..)I have looked at the source code and indeed it doesn't, even in the lowest version of GLFW-b gloss supports (1.4.1). I wonder if I overlooked something or if Graphics.Gloss.Internals.Interface.Backend.GLFW is broken 
22:40:59 <Lokathor> I unfortunately have absolutely no idea
22:59:12 <roi_du_silence> I'd be glad if someone tried to build gloss with the glfw backend to see if it's only on my end or not.
23:30:48 <jchia> How can I automatically get an Eq instance for this GADT? I seem to be getting an error on GreaterThan. http://lpaste.net/359171
23:32:31 <jchia> Strangely, the code works if I replace Eq with Show.
23:34:31 <geekosaur> jchia, not strange at all
23:34:36 <geekosaur> Show needs only the current value
23:35:01 <jchia> geekosaur: Could you elaborate? What do you mean by "current value"?
23:35:02 <geekosaur> the forall in there is an existential; you cannot compare values under it with values under a different Foo value
23:36:25 <geekosaur> if you make a Show instance for a Foo a, 'show' only needs the 'a' for the value you are showing
23:37:04 <geekosaur> Eq needs to compare two Foos. it cannot look under the constructor.
23:37:34 <jchia> geekosaur: Do you mean they are trying to allow comparing 'Foo Bool' with 'Foo Double'? I want this comparison to return False. I'm essentially trying to compare two expression trees here. How can I make it work?
23:38:31 <geekosaur> no, I do not mean that. it is complaining about the GreaterThan constructor, not PriorDouble
23:39:36 <jchia> geekosaur: How come when there are two Foos they can't look under the constructor?
23:39:55 <cocreature> it can look under the constructor but then it doesn‚Äôt know what "a" is
23:40:02 <opqdonut> jchia: you can define a function like this
23:40:04 <geekosaur> ^
23:40:43 <geekosaur> you are using a GADT, it has an existential buried within it. you cannot look inside an existential unless you have a typeclass constraint on it (in this case, on 'a')
23:40:44 <opqdonut> jchia: http://lpaste.net/359171 see my annotation
23:41:05 <geekosaur> and even then you can only do what methods of the typeclass(es) allow
23:41:18 <geekosaur> you can't get at the actual value
23:43:15 <jchia> OK, so the implicit existential on the GreaterThan is a forall, and they don't know what type the forall is, they can't pick a constructor to do the Eq at the next level?
23:43:42 <jchia> opqdonut: Thanks. I'm trying to avoid boilerplate. If I can't derive, I'll do something like that.
23:43:51 <cocreature> jchia: Eq can only be applied if the two things have the same type but in this case you could have Foo a1 and Foo a2
23:43:58 <geekosaur> (also, I should note that deriving is not especially smart; depending on what exactly you are doing, sometimes you could write a manual instance that the compiler is not smart enough to derive. the derivation for Eq is not very smart; you can see it on line 31 and what it wants to do is illegal)
23:44:10 <jchia> cocreature: I suppose they are not smart enough to figure out that it can only be Bool or Double?
23:44:18 <geekosaur> cocreature, the definiion of GreaterThan seems to prevent that
23:44:43 <geekosaur> this looks like a case where a manual instance could be written but the 'recipe' for deriving Eq is too simplistic
23:45:28 <cocreature> geekosaur: how so? the problem is that "GreaterThan a b == GreaterThen a' b' = a == a' && b == b'" doesn‚Äôt typecheck because a and a' could have different types
23:45:55 <geekosaur> Foo a -> Foo a -> Foo Bool, no?
23:46:19 <cocreature> geekosaur: I‚Äôm talking about the types of a and a' not a and b
23:46:46 <geekosaur> mrh. I'm getting confused
23:47:00 <cocreature> as opqdonut demonstrated you can actually write some kind of heterogenous equality operation here so you can implement it manually but GHC won‚Äôt do that for you
23:47:57 <geekosaur> anyway opqdonut's code is what I meant earlier by saying one could do it manually but deriving isn't smart enough
23:48:35 <opqdonut> also note that equal has a more general type than (==)
23:48:55 <opqdonut> you could of course define "instance Eq (Foo a) where (==) = equal" after this
23:49:24 <opqdonut> but that won't let you do "PriorBool True == PriorDouble 1.0"
23:52:16 <jchia> opqdonut: Yes, I noticed. I think I'll end up defining the Eq instance manually.
23:57:27 <cocreature> jchia: if boilerplate is what you‚Äôre worried about, you should be able to write some TH to write this code for you but you‚Äôll need a lot of these instances or very large types for the required effort to pay off
