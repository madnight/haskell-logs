00:02:09 <Railalis> dmwit: so earlier you said something about forM_ being mangled?
00:02:14 <Railalis> what id dyou mean by that?
00:02:49 <dmwit> I couldn't make sense of what you wanted to happen with `setCursorPosition -> putStr "□"`.
00:03:03 <Railalis> ah
00:03:22 <kuribas> I'd like to test my bezier curve library.  Is it better to use quickcheck or hunit?  I'd like to test every type of curve (with/without inflection, loops, colinear, degenerate, ...)
00:03:37 <Railalis> so like how does forM_ work? M_ isn't a substitution for anything?
00:04:25 <dmwit> M and _ are just part of the name. They were chosen to be part of the name because it works on monads (the M) and doesn't return an interesting value (the _).
00:04:29 <dmwit> ?src forM_
00:04:29 <kuribas> Railalis: Monad the underscore means it returns ()
00:04:30 <lambdabot> forM_ = flip mapM_
00:04:33 <dmwit> ?src mapM_
00:04:34 <lambdabot> mapM_ f as = sequence_ (map f as)
00:04:49 <kuribas> :t forM_
00:04:50 <cocreature> kuribas: I generally use both, QuickCheck is great when your tests fit into QuickCheck’s scheme but some tests don’t and usually I also want to have a few explicit tests to sanity check that I’m not doing something stupid
00:04:51 <lambdabot> (Monad m, Foldable t) => t a -> (a -> m b) -> m ()
00:05:27 <kuribas> cocreature: I am just wondering how useful quickcheck is with floating point values
00:05:32 <Railalis> hmm.
00:06:20 <cocreature> kuribas: that depends on your code and the properties you specify. obviously exact equality is probably not going to work but QuickCheck doesn’t stop you from using relative distance and some epsilon value
00:06:35 <kuribas> :t for_
00:06:37 <lambdabot> (Applicative f, Foldable t) => t a -> (a -> f b) -> f ()
00:08:40 <kuribas> cocreature: I think the difference between 2.5 and 2.6 is going to have no effect, but between 2.5e-3 and 2.5e10 would have an effect.
00:09:24 <kuribas> Railalis: forM_ is there mostly for historical reasons.
00:09:45 <Railalis> ok
00:09:50 <kuribas> Railalis: because every monad is also applicative, you can always use for_
00:10:36 <Railalis> I roughly understand what they are, haven't really gotten into the usage and why bit. I don't know what you mean by applicative.
00:10:41 <Railalis> I'm pretty new.
00:11:05 <cocreature> kuribas: sure that’s why I suggested using the relative difference
00:11:31 <kuribas> cocreature: then wouldn't it try to go from 2.5, 2.6, 2.7, etc.. ?
00:11:49 <cocreature> kuribas: sry, I’m not following. what is “it”
00:12:09 <Railalis> so how do I use forM_ with a function that takes a second param?
00:12:42 <kuribas> cocreature: quickcheck
00:13:05 <cocreature> kuribas: quickcheck randomly generates input so it probably won’t choose 2.5, 2.6, 2.7, …
00:13:09 <cocreature> that doesn’t look very random
00:13:27 <cocreature> but I think I still don’t quite understand why you think QuickCheck would be unsuitable
00:13:56 <Railalis> cocreature: https://xkcd.com/221/ relevant.
00:14:02 <kuribas> cocreature: well, the chance it would be generating a colinear curve would be zero.
00:14:30 <cocreature> kuribas: if you want to generate specific data, write your own generators that have a high probability of generating the data you care about
00:14:55 <kuribas> cocreature: right, that's a good idea
00:15:38 <cocreature> I completely agree that the default generators are not suitable in some cases
00:15:47 <cocreature> but that doesn’t mean QuickCheck is not suitable :)
00:16:07 <kuribas> yeah
00:16:47 <kuribas> I'll first select on the type, then generate parameters for each type.  
00:17:08 <kuribas> And also a arbitrary linear transform
00:18:20 <Railalis> so is it possible to do some kind of forM_ [blah] $ func, where func :: blah -> something else -> ()?
00:18:24 <kuribas> cocreature: now I wonder if every bezir can be created by a finite set of types and arbitrary transform.
00:18:32 <kuribas> (linear transform)
00:18:42 <Railalis> probably.
00:19:43 <kuribas> Railalis: the type of func must be `a -> f b`
00:20:21 <Railalis> hm
00:20:34 <kuribas> Railalis: a -> IO () would work for example
00:20:47 <Railalis> can I create a temporary function within a do block?
00:20:58 <kuribas> Railalis: yes, with let
00:21:04 <Railalis> sweet I'll do that
00:21:18 <kuribas> do a <- action; let f x = function; ...
00:21:41 <kuribas> Railalis: if you function returns just (), it will do nothing
00:22:09 <Railalis> it returns IO ()?
00:22:50 <kuribas> Railalis: if it return IO (), then it can do a side effect
00:23:14 <Railalis> Isn't that the point of IO?
00:23:18 <kuribas> yes
00:23:30 <Railalis> I don't see the issue.
00:24:29 <kuribas> Railalis: IO () is fine.  The type you showed before not...
00:24:38 <kuribas> :t for_ [1, 2, 3] $ (\a b -> ())
00:24:41 <lambdabot> p -> ()
00:25:01 <Railalis> that was an example I found, I've modified it a bit..
00:25:02 <Railalis> sec
00:25:27 <dmwit> Railalis: You asked, "is it possible to do forM_ blah func where func :: blah -> something -> ()?". kuribas is pointing out that you probably meant "func :: blah -> something -> IO ()" (note the extra IO).
00:25:30 <Railalis> `let drawFloor x = drawChar x floorTile;  forM_ [(x, y) | y <- [y $ topLeft r .. y $ botRight r], x <- [x $ topLeft r .. x $ botRight r]] drawFloor`
00:25:52 <Railalis> where `drawChar :: (Int, Int) -> String -> IO ()`
00:26:16 <Railalis> kinda sad considering I'm going to throw this function away probably.
00:26:27 <kuribas> Railalis: you can do that, but it doesn't do what you think it does
00:26:49 <Railalis> what should I be looking for then?
00:27:31 <Railalis> plain old map?
00:28:17 <kuribas> Railalis: well, that's fine.
00:28:48 <kuribas> Railalis: I just meant you shoudln't pass forM_ a two argument function
00:29:00 <kuribas> Railalis: one argument is fine
00:29:14 <Railalis> well I made the temp function do manage that.
00:29:31 <Railalis> cause I'd rather have a generic function for other render functions.
00:29:53 <Railalis> drawChar (int, int) -> String -> IO()
00:30:32 <kuribas> Railalis: or use (flip drawChar floorTile) directly
00:30:42 <Railalis> :t flip
00:30:44 <lambdabot> (a -> b -> c) -> b -> a -> c
00:31:21 <kuribas> Railalis: it makes the second argument the first argument
00:31:41 <Railalis> hm..
00:32:11 <kuribas> some people prefer (`drawChar` floorTile)
00:32:20 <Railalis> oh infix
00:32:28 <kuribas> yeah :)
00:32:45 <Railalis> would that work? `map [] `func` 2ndparam`
00:32:48 <dmwit> I mean, you can also just write `\coord -> drawChar coord floorTile` or whatever.
00:33:03 <dmwit> Lambdas are super lightweight.
00:33:20 <Railalis> what does `\thing ->` do?
00:33:29 <kuribas> Railalis: that means (func (map []) 2ndparam)
00:33:43 <kuribas> Railalis: lambda
00:33:44 <dmwit> `\x -> e` is a function which accepts an argument, names it `x`, and returns `e` (where `e` is an expression that may mention `x`).
00:34:03 <kuribas> Railalis: https://wiki.haskell.org/Anonymous_function
00:34:04 <dmwit> `f x = e` and `f = \x -> e` do the same thing up to a stupid detail about types.
00:34:14 <Railalis> got it
00:34:30 <kuribas> dmwit: which detail?
00:34:32 <Railalis> some how avoid lambda's in haskell.
00:34:37 <Railalis> avoided*
00:34:54 <Railalis> *ptsd of lisp*
00:34:55 <dmwit> kuribas: If `\x -> e` is typeclass polymorphic, `f = \x -> e` will be monomorphized (or cause an error).
00:35:06 <kuribas> dmwit: oh, right
00:35:34 <kuribas> Railalis: with lambdas you can write: for_ [1, 2, 3] $ \num -> action_with_num
00:35:46 <kuribas> Railalis: note how much that looks  like ruby blocks
00:35:52 <kuribas> Railalis: what's you previous language?
00:36:30 <Railalis> a couple, but I have the most experience with modern php
00:36:46 <Railalis> more than a couple really
00:37:28 <Railalis> though I haven't gotten around to ruby
00:37:35 <kuribas> Railalis: well, I find that more readable than let temp num = action_with_num; for_ [1, 2, 3] action_with_num.
00:38:02 <Railalis> It's more compact
00:38:24 <Railalis> still trying to wrap my head around it though
00:38:56 <kuribas> Railalis: it binds num to each number, then runs action_with_num
00:39:20 <Railalis> I get the lambda thing, I'm trying to see how $ affects it..
00:39:55 <geekosaur> just precedence
00:40:06 <kuribas> Railalis: $ is there only because you cannot write for_ [1, 2, 3] \num -> action
00:40:12 <kuribas> (I wish you could)
00:40:18 <Railalis> yea
00:40:23 <dmwit> `for_ [1,2,3] (\num -> action_with_num)` would work just as well.
00:40:48 <Railalis> ok
00:40:50 <Railalis> I get it
00:41:20 <Railalis> and is for_ placeholder?
00:41:23 <dmwit> ($) gets used primarily as a stupid parser trick, mostly. It doesn't do anything semantically interesting.
00:41:39 <dmwit> No, `for_` is an actual function.
00:41:40 <dmwit> :t for_
00:41:43 <lambdabot> (Applicative f, Foldable t) => t a -> (a -> f b) -> f ()
00:41:44 <Railalis> yea I know, it's syntactic sugar.
00:41:47 <dmwit> It is basically the same as `forM_`.
00:42:14 <Railalis> weird, when I threw that in my prompt it said variable not in scope
00:42:14 <dmwit> It's sort of a historical accident that we have both `forM_` and `for_`.
00:42:23 <dmwit> Yes, you have to import something.
00:42:24 <dmwit> ?index for_
00:42:25 <lambdabot> Data.Foldable
00:42:33 <Railalis> think kuribas mentioned that
00:42:41 <kuribas> Railalis: it's not sugar
00:42:45 <Railalis> the historical accident 
00:42:48 <dmwit> I see no reason to avoid `forM_` for now.
00:43:08 <dmwit> The advantages of `for_` are going to be entirely academic, since you know you're using `IO`.
00:43:16 <kuribas> Railalis: https://hackage.haskell.org/package/base-4.10.0.0/docs/Data-Foldable.html#v:for_
00:45:18 <Railalis> so in my case, `forM_ [] $ \temp -> drawChar temp floortile`?
00:45:25 <kuribas> I like for and for_, because it's more descriptive
00:45:32 <kuribas> Railalis: yeah
00:46:20 <Railalis> :t for_
00:46:22 <lambdabot> (Applicative f, Foldable t) => t a -> (a -> f b) -> f ()
00:46:24 <Railalis> :t forM_
00:46:26 <lambdabot> (Monad m, Foldable t) => t a -> (a -> m b) -> m ()
00:46:30 <shionda> wow.
00:46:38 <shionda> First time in IRC, everyone. Hello.
00:46:44 * dmwit waves
00:46:44 <systemfault> Welcome
00:46:46 <Railalis> Hello
00:46:55 <shionda> I heard this was a really good channel. I.. can't believe I figured it out. 
00:47:00 <shionda> Hey!
00:47:16 <shionda> I heard such good things. Everybodys super welcoming. I wanted this to be my first place. cheers.
00:47:21 <shionda> (sorry for interupting.) :)
00:47:29 <Railalis> you're fine
00:47:37 <shionda> is this server encrypted?
00:48:27 <dmwit> There are publicly available logs of everything said in this channel.
00:48:51 <dmwit> (Yes, I know I did not answer your question.)
00:49:32 <Railalis> I mean it doesn't make sense to encrypt the data stream if the data is public
00:50:02 <shionda> right I was just wondering
00:50:13 <shionda> I was trying to connect using linux to a server
00:50:22 <shionda> and I kept getting a timeout because of something to do with SSL
00:50:34 <shionda> so right now i'm just on OS using adium
00:50:44 <shionda> actually no thats a lie. I'm on a broswer.
00:50:57 <shionda> wow, my opsec is just great right now.
00:51:04 <shionda> haha.
00:51:04 <Railalis> so Applicative vs Monad?
00:52:03 <shionda> Railalia, are you talking to me? sorry
00:52:18 <shionda> this is seriously my first time in an IRC.
00:52:45 <shionda> I've been doing so much stuff on the computer, especially in regards to pentesting etc
00:52:49 <Railalis> shionda: in general :) I'll mention you if talking directly
00:52:53 <shionda> and not once have i ventured out in an old land.
00:53:01 <dmwit> shionda: We do try to stay on the topic of Haskell in here. If you haven't got questions or discussions related to Haskell, can I ask you to find a more appropriate channel?
00:53:23 <shionda> Ah, alright- Apologies! Continue.
00:56:23 <Railalis> oh god I ran it.. what did I do to my shell
00:56:37 <Railalis> progress.
01:01:48 <Railalis> https://img42.com/5oVBi probably a bad choice in character.
01:01:57 <drdo> Let's say you want to write some server ∷ (Socket → IO a) → IO Void, where the first argument is the callback for a new connection. How do you do hand-over of that Socket over there? To ensure that it's properly closed even in the presence of async exceptions
01:03:36 <Railalis> it's being the call back or the handle function for the data?
01:04:05 <drdo> Hmm?
01:04:53 <Railalis> nvm I don't think I can really help you much anyways
01:04:58 <drdo> I want the Socket to be the responsibility of the user as soon as it's passed via the callback
01:05:33 <drdo> The thing is that you can get an async exception right there before you can establish an exception handler
01:06:03 <Railalis> make a timeout for creating the connection so once it's complete you have an exception handler?
01:06:03 <drdo> It would be possible to call the callback with a masked state and pass the restore function, but that would be horrendous
01:06:27 <Railalis> yea
01:07:06 <kuribas> shionda: you're welcome to talk about anything in #haskell-offtopic :)
01:07:37 <kuribas> shionda: except trolling of course
01:08:49 <kuribas> Railalis: every Monad is Applicative
01:09:16 <Railalis> ok
01:09:58 <Railalis> think my simple terminal renderer is like... well crap.
01:20:42 <Railalis> Think I am going to call it a night. thanks everyone.
02:33:42 <Profpatsch> I wonder how I’d log Warning output from an Aeson parser.
02:34:16 <Profpatsch> Something like instance FromJSON (Writer [Text] Mytype) where ?
02:35:11 <Profpatsch> But then parseJSON is :: Vaule -> Parser (Writer [Text] Mytype)
03:17:15 <Profpatsch> Welp, adding a WriterT adds a lot of noise.
03:19:32 <t7> @hoogle Maybe a -> Either a ()
03:19:33 <lambdabot> Agda.Utils.Either maybeToEither :: Maybe a -> Either () a
03:19:33 <lambdabot> Foreign.Ruby.Helpers runscript :: String -> IO (Either String ())
03:19:33 <lambdabot> System.Console.Readline setStartupHook :: Maybe (IO ()) -> IO ()
03:21:00 <barrucadu> @type maybe (Right ()) Left
03:21:02 <lambdabot> Maybe a -> Either a ()
03:55:48 <t7> i have a (Map a b) and a (Set a), i would like to get a subset of the map using the keys from the set
03:56:29 <t7> i could use filter i guess
03:57:29 <t7> filterWithKey
03:58:27 <cocreature> t7: withoutKeys
03:58:41 <cocreature> oh nvm, I can’t read
03:58:49 <cocreature> that’s the wrong way around
03:58:54 <t7> restrictKeys
03:59:00 <cocreature> yep
04:00:25 <t7> need a new containers version :O
04:10:33 <Ulrar> Anyone knows of an haskell lib that would have an equivalent to the getent linux command ?
04:10:52 <mniip> :t M.intersectionWith
04:10:55 <lambdabot> Ord k => (a -> b -> c) -> M.Map k a -> M.Map k b -> M.Map k c
04:11:57 <Ulrar> You mean read the /etc/hosts myself and use intersectionWith to get values from that ?
04:11:58 <mniip> :t \m s -> M.intersectionWith const m $ M.fromSet (const ()) s
04:12:00 <lambdabot> Ord k => M.Map k c -> S.Set k -> M.Map k c
04:12:06 <mniip> t7, ^
04:12:13 <mniip> I am convinced this is more effective
04:12:13 <Ulrar> Ah, not me, allright
04:12:26 <mniip> oh, restrictKeys is just that
04:12:26 <mniip> sorry
04:13:03 <t7> :)
04:21:11 <royal_screwup21> noob question: I'm trying to write a simple if statement without pattern guards like so: let check x y = if x==y then "equal". I'm getting an error  - "parse error (possibly incorrect indentation or mismatched brackets)". What am I doing wrong/
04:22:05 <royal_screwup21> it's on the ghci interpreter, and I'm pretty sure there's no indentation errors
04:24:37 <t7> Set.map (Map.mapKeys (\k -> Map.findWithDefault k k s)) ts
04:24:39 <srhb> royal_screwup21: There are no if statements.
04:24:46 <t7> is it line noise yet? 
04:24:57 <srhb> royal_screwup21: it's always `if x then y else z`
04:25:22 <royal_screwup21> ahh thanks! :)
04:26:10 <manjaro-kde5> I have ap roblem with emacs haskell mode. When I open hs file it says "Could not find module `Prelude` There are files missing in the `base-4.10.0.0` package..."
04:27:08 <manjaro-kde5> And if I run C-c C-l I get "Haskell process command errored with:  (error "Unexpected response from haskell process.")"
04:34:41 <kuribas> manjaro-kde5: try #haskell-emacs
05:49:05 <Cooler> anyone here done symbolic execution?
05:49:15 <Cooler> is this the right channel to talk about that
05:59:42 <lyxia> No idea, but I'm interested
06:02:11 <Cooler> i am looking to implement it myself
06:02:27 <Cooler> to understand it better
06:42:25 <Alovenom> dmwit, thank you
06:44:05 <Alovenom> I saw the lambdabot message as well as the issue you raised on GitHub. I also read the source code and understood the bug itself
06:44:52 <Alovenom> I'll also work out most of my unsafePerformIO abuse =)
07:04:42 <royal_screwup21> does the position of where below a function matter?
07:05:49 <royal_screwup21> I know the sub function under where have to aligned, but does the position of "where" itself matter?
07:06:21 <merijn> royal_screwup21: Not really
07:06:31 <merijn> royal_screwup21: There are some rules, but rather flexible
07:06:50 <merijn> royal_screwup21: I recommend reading the indentation rules here: https://en.wikibooks.org/wiki/Haskell/Indentation
07:06:59 <royal_screwup21> thanks!
07:30:00 <ph88_> how do a let a haskell program return with an exit code ?
07:30:29 <ph88_> also what should i use for exit code scheme ?
07:32:58 <merijn> ph88_: *nix? Use the unix package
07:33:12 <ClaudiusMaximus> ph88_: System.Exit? https://hackage.haskell.org/package/base-4.10.0.0/docs/System-Exit.html
07:34:31 <ClaudiusMaximus> ph88_: though in GHC it needs to be called from the main thread to actually exit the program
07:34:41 <merijn> ClaudiusMaximus: Doesn't let you control the exit code, though
07:34:51 <ClaudiusMaximus> yes it does
07:35:07 <ClaudiusMaximus> data ExitCode = ExitSuccess | ExitFailure Int
07:36:15 <ph88_> i have a few things that could go wrong, should i just put them on exit codes 1 and up ?
07:44:19 <hpc> ph88_: yes
07:45:15 <hpc> ph88_: you can probably define a bunch of exit codes at once by doing something like [exitFoo, exitBar] = map (exitWith . ExitFailure) [1, 2]
07:45:36 <hpc> i think that works at top-level
07:50:00 <ph88_> cool
07:51:08 <ph88_> i didn't know i could break down lists like that
07:51:24 <ph88_> hpc can i use an infinite list on the right hand side ?
07:51:26 <ggVGc> ph88_: imo exit codes have no value unless there's also a lookup for them, in a man page or similar. Otherwise I'd just use 1 for error and 0 for okay
07:52:35 <Alovenom> ph88_ : it's map therefore it's 1:1. you'd have to use an infinite list on both sides. which ... doesn't work
07:53:38 <cocreature> well you could use "(exitFoo : exitBar : _) = …"
07:53:53 <cocreature> but then you can just as well use a finite list
07:54:50 <ggVGc> I really don't understand the point of a list of exit codes whose size is not known at compile time
08:00:12 <Alovenom> ^
08:13:14 <ondrejs> hello. I am comfortable with applicatives and monads but there are tricks such as https://twitter.com/Brun0Cad/status/915297109544448001 I would have never thought of. Is there something like 99haskell problems but specialized on applicatives and monads so I can practice this?
08:14:42 <hpc> ph88_: you should be able to, if you change the LHS accordingly
08:14:55 <hpc> (exitFoo : exitBar : _) = map (exitWith . ExitFailure) [1..]
08:15:17 <hpc> and i agree with ggVGc about documenting the exit codes
08:20:12 <cocreature> ondrejs: tbh, I wouldn’t worry too much about this. over time you learn some of these one liners and some actually make sense but most of the time a more readable solution is preferable to a slightly shorter one
08:25:35 <monochrom> @type (sequence >>=)
08:25:38 <lambdabot> (Monad m, Traversable t) => (m (t a) -> t (m a) -> b) -> t (m a) -> b
08:25:57 <monochrom> Oh oops, the other way
08:26:05 <monochrom> @type (>>= sequence)
08:26:05 <ondrejs> cocreature: ok, thanks
08:26:08 <lambdabot> (Traversable t, Monad m) => m (t (m a)) -> m (t a)
08:27:41 <cocreature> ondrejs: to be more specific, using (=<<) for "concat (map …)" is something that’s relatively commond and you’ll get used to it. I’ve personally never used sequence for turning (1,[2,3,4]) into [(1,2),(1,3),(1,4)] so while I understand why it behaves that way, I would never use it myself in this context
08:28:36 <monochrom> Yeah, this one uses "instance Traversable ((,) a)" which is under fire.
08:29:00 <monochrom> Because people cannot accept:
08:29:07 <monochrom> > length ('x', 4)
08:29:10 <lambdabot>  1
08:33:24 <monochrom> > (+ (2*3)) 1
08:33:27 <lambdabot>  7
09:06:56 <pupp> >stack install mtl
09:06:56 <pupp> No compiler found, expected minor version match with ghc-8.0.2 (x86_64) (based on resolver setting in C:\sr\global-project\stack.yaml).
09:06:56 <pupp> To install the correct GHC into C:\Users\User\AppData\Local\Programs\stack\x86_64-windows\, try running "stack setup" or use the "--install-ghc" flag.
09:07:25 <pupp> my ghc has version 8.2.1
09:08:39 <geekosaur> then you need to set the nightly resolver
09:08:53 <geekosaur> there are no lts resolvers using 8.2.1
09:09:14 <pupp> what is nightly resolver?
09:09:18 <monochrom> Or accept that you have to go back to 8.0.2.
09:09:56 <pupp> "cabal install mtl" said that it's already installed...
09:10:02 <pupp> weird
09:10:10 <geekosaur> yes. you're using stack not cabal. stack maintains its own stuff
09:10:14 <cocreature> pupp: resolvers specify a consistent snapshot of the a subset of packages on hackage
09:10:24 <monochrom> stack and cabal share nothing.
09:10:30 <geekosaur> and that snapshot includes a specific compiler version they work with
09:10:32 <cocreature> lts resolvers stick to a major release of all libs
09:10:40 <cocreature> nightly resolvers don’t
09:10:43 <monochrom> Stack is like Atkins diet. You have to stick to it and deviate never.
09:11:01 <monochrom> God and Stack work in mysterious ways.
09:11:29 <DigitalKiwi> isn't that kind of like saying they don't
09:11:44 <monochrom> No, it's worse than that.
09:12:03 <monochrom> Every difficulty is a test from God and Stack.
09:12:15 <DigitalKiwi> I knew they were in cahoots! 
09:12:51 <geekosaur> there are certainly people who confuse them...
09:19:57 <test2432432> What is the -fdicts-cheap ghc option doing? I haven't found web-sources explaining the flag, are there any?
09:20:08 <xenon-> hi. can someone recommend me a template haskell tutorial? i've been learning haskell for about a year and I know my way around it, and i have some experience with metaprogramming (CL kind), but I didn't bother trying template haskell before
09:20:10 <xenon-> hi. can someone recommend me a template haskell tutorial? i've been learning haskell for about a year and I know my way around it, and i have some experience with metaprogramming (CL kind), but I didn't bother trying template haskell before
09:20:15 <xenon-> sorry for double message
09:20:44 <test2432432> ghcs manual says "A very experimental flag that makes dictionary-valued expressions seem cheap to the optimiser. " what is meant by this?
09:21:40 <geekosaur> test2432432, this is a better question for the ghc-users mailing list or possibly the ghc dev channel
09:22:31 <geekosaur> but I can say it's not going to mean much unless you understand how ghc implements typeclasses, and maybe not even then
09:25:11 <geekosaur> very briefly: typeclass methods accessed via a dictionary (because it couldn't be inlined or it involves polymorphic recursion) incur a double pointer dereference instead of a direct jump. the optimizer knows this. -fdicts-cheap tells the optimizer to ignore it.
09:29:42 <AWizzArd> The paper „Tackling the Awkward Squad” is still a very nice read, after all those years.
09:51:27 <monochrom> It was lecture notes for a summer school. I was there.
09:52:08 <monochrom> Although, during the summer school the lecture notes you see now weren't there yet. But we had slides. I think you can find those slides too.
09:53:29 <AWizzArd> monochrom: I found the remarks interesting how IO was done in the past.
09:54:19 <monochrom> Hmm, it has that? I didn't notice. :)
09:54:41 <monochrom> I got my dose of I/O history from Andrew Gordon's thesis.
10:07:45 <xenon-> can I get a recommendation for template haskell resources for someone who knows haskell and has experience with CL macros (but zero experience with scheme macros, and i get the impression that template haskell ressembles those more than macros in CL)
11:06:18 <Hijiri> I haven't used TH much but from what I can tell it is closer to lisp macros since you are explicitly manipulating an AST
11:08:27 <Hijiri> whereas scheme macros seem to be more pattern-matching based
11:08:58 <Hijiri> you have to explicitly create unique names too
11:09:16 <Hijiri> (in TH and lisp macros)
11:38:34 <geekosaur> ^ that basically. the only difference from lisp macros is that the AST format is the same as the source format in lisp
11:46:30 <csd_> why isn't the expression (\x -> x) (*) 3 1  equivalent to \x -> x * 3 1?
11:47:19 <LKoen> because -> has lower precedence
11:47:25 <csd_> it seems like the latter is evaluated right to left
11:48:16 <csd_> LKoen: ghci :i (->) doesn't show a precedence value.. is there a way for me to query that from ghci?
11:49:46 <LKoen> https://stackoverflow.com/questions/12238836/how-to-check-haskell-infix-operator-precedence
11:50:05 <LKoen> oh, that's only for infix operators
11:50:30 <LKoen> I suppose lambda expressions 's precedence is only defined in the manual :-)
11:51:14 <geekosaur> wired in syntax extends as far as it can
11:51:27 <geekosaur> (effectively, lower precedence than everything else)
11:51:46 <csd_> LKoen: looks like lambda expressions have precedence of 10, which would be higher https://www.haskell.org/onlinereport/exps.html
11:52:01 <csd_> exp10	->	\ apat1 ... apatn -> exp	(lambda abstraction, n>=1)
11:52:20 <geekosaur> ah, they actually specify it then. missed that
11:52:54 <csd_> so lower precedence doesn't explain why the two expressions above evaluate differently, no?
11:54:38 <csd_> i think i must be misinterpreting the report
11:59:24 <csd_> LKoen: the reason the second expression fails is because haskell tries to apply `3` as a function to `1`
12:03:15 <jle`> csd_: it's ((\x -> x) (*)) 3) 1
12:03:28 <geekosaur> right, (*) is operator by name, * without is operator application
12:03:35 <jle`> csd_: but your second is (\x -> x * (3 1))
12:03:54 <geekosaur> er, * without the () is
12:04:30 <jle`> csd_: so your first one is ((\x -> x) (*) 3) 1   ==>   ((*) 3) 1   ==> 3 * 1
12:04:50 <csd_> jle`: but what causes them to be evaluated differently?
12:04:53 <jle`> your second one is a lambda abstraction (\x -> x * (3 1)), something pretty different
12:04:57 <jle`> they're different expressions...?
12:05:07 <jle`> that's like asking why 3 + 7 and 7 > 8 are evaluated differently
12:05:11 <jle`> they're just completely different things
12:05:22 <csd_> lol but what is the rule by which it thinks that 3 is a function
12:05:31 <csd_> grammatically
12:05:48 <jle`> if haskell sees 'x y', that is syntax for applying the value 'y' to the function 'x'
12:06:00 <jle`> but function calls associate from the left
12:06:11 <geekosaur> that * without the parens is always operator application, thus followed by a term which is `3 1` which can only be application of 3 as a fulction to `
12:06:28 <jle`> so your first one is (((\x -> x) (*)) 3) 1
12:06:45 <jle`> you can think of "space" as a function application operator
12:06:55 <geekosaur> whereas (*) with the parens is always (\x y -> x * y)
12:07:12 <geekosaur> (and the same for all infix operators)
12:07:31 <jle`> csd_: i'm adding in your parentheses without thinking 'is this a function' or 'is this a value'
12:07:40 <jle`> i'm  just adding in the parentheses wherever things associate
12:07:45 <jle`> haskell doesn't look at types when it parses
12:08:07 <jle`> \x -> x * y z is (\x -> x * (y z))
12:08:19 <jle`> no matter what the type of anything is, just because function application "binds" tighter than *
12:08:50 <jle`> it doesn't matter if y is a function or a non-function
12:08:53 <csd_> jle`: oh because when * isn't wrapped in () it thinks it's being used infix, but with () it applies leftfix?
12:09:11 <geekosaur> I guess I've been muted...
12:09:13 <jle`> yeah an operator without () is infix syntax
12:09:32 <csd_> geekosaur: sorry i'm not ignoring you, just trying to grok this all and you both are coming at it differently
12:10:09 <csd_> geekosaur: looks like you were basically saying the same thing as what i just wrote 
12:10:49 <csd_> and so what about \x -> x (*) 3 1
12:11:36 <barrucadu> That's \x -> ((x (*)) 3) 1
12:12:32 <jle`> csd_: yes, (*) refers to the operator as a *value*, a value that you can pass to other functions
12:12:43 <jle`> just like how 'show' and other functions in haskell are values
12:13:04 <jle`> all functions in haskell are values that you can pass to other functions, etc.
12:13:14 <jle`> so (*) refers to that multiplication function as a value
12:13:31 <jle`> but `x * y` refers to the application of that operator using infix operator syntax
12:14:05 <csd_> oh interesting. i didn't realize it was being dereferenced like that
12:14:46 <jle`> yes, 'x * y' can actually be considered syntactic sugar
12:14:58 <jle`> it doesn't "exist" in the core haskell language
12:15:07 <jle`> it's only provided for humans to be able to read nicely
12:15:41 <jle`> but `x * y` syntax is syntactic sugar for `(*) x y`, which is the function (*) applied to x, and then applied to y
12:15:46 <jle`> just like 'f x y'
12:16:50 <jle`> so x * f y is parsed as x * (f y), which is sugar for (*) x (f y)
12:17:01 <csd_> jle`: and so in \x -> x (*) 3 1, as barrucadu typed it out, does the righthand side of the lambda naturally just get simplified before the lamda is applied?
12:17:13 <csd_> and so that's why it's interpreted as it is?
12:17:24 <jle`> i'm not quote saying it gets simplified
12:17:27 <jle`> i'm talking about how it's parsed
12:17:48 <jle`> `x (*) 3 1` is *parsed* as a function x, which takes at least three arguments, being applied to (*), 3, and then 1
12:18:52 <jle`> it's the same, syntacitcally, as \f -> f x y z
12:19:04 <jle`> or \f -> f 1 2 3
12:20:29 <jle`> since in haskell, (*) is just a normal value (representing the multiplication function)
12:21:00 <jle`> that is, (*) is parsed as a value, so it has the same parsing role as 'x', '1', 'True', 'f', etc.
12:21:51 <hpc> zx
12:22:03 <hpc> zx
12:22:23 <csd_> jle`: pardon me if i bungle the lambda calculus terminology, but essentially \x -> x (*) 3 1 has the RHS beta reduced before the lamda is applied, yes?
12:23:42 <srhb> csd_: I think you're confused with precedence.
12:23:47 <srhb> That is x applied to three arguments
12:23:53 <srhb> What would you reduce?
12:26:09 <csd_> oh i think i see
12:26:15 <csd_> jle`: geekosaur: thank you
12:36:14 <nicknight> Hi all what rank do you give to haskell in terms of speed compared to all languages?
12:36:32 <mauke> gemini
12:37:03 <Tuplanolla> A mean of C and Java, but not telling which mean, nicknight.
12:37:36 <Taneb> Somewhere between "Very fast" and "A little on the slow side" depending on how good you are
12:37:40 <Tuplanolla> (Languages don't have speeds though; implementations do.)
12:39:43 <nicknight> Tuplanolla:  okay 
12:40:40 <Tuplanolla> What performance goal are you trying to meet, nicknight?
12:42:18 <nicknight> Tuplanolla:  learning haskell and just interested to rate it in terms of speed....One can say undoubtly c is fastest and I thought if there is any resource that can give ratings/ranks
12:42:54 <Tuplanolla> @google programming language implementation shootout
12:42:56 <lambdabot> http://benchmarksgame.alioth.debian.org/
12:42:56 <lambdabot> Title: The Computer Language Benchmarks Game
12:43:22 <Tuplanolla> That one's not the worst.
12:45:33 <beastie`> how to read this in english: data RequestBody = forall a. RequestBodyClass a => RequestBody a
12:45:33 <beastie`>  
12:45:50 <nicknight> Tuplanolla:  I already have it but I need to compare individually everyone :( I am doing and feel bad haskell lost to rust
12:45:58 <beastie`> so 'a' is of REquestBodyClass
12:46:00 <Cale> Back when we had Don Stewart competing for Haskell's sake on the shootout, GHC was often at the top for many of the benchmarks :)
12:46:24 <beastie`> why not just (RequestBodyClass a =>)
12:46:36 <Cale> beastie`: The forall a. brings a into scope
12:46:53 <Cale> Notice that it doesn't occur on the left of the = sign, and so isn't mentioned in the type being defined.
12:48:22 <Cale> So, when you pattern match on the RequestBody data constructor, and extract its argument, you won't have any information about which type of value you get out, apart from the fact that it's some instance of RequestBodyClass
12:48:23 <beastie`> Cale: can i put the contraint of a on the left ?
12:49:39 <Cale> There is a version where you put it on the left, but that doesn't mean what most people would want it to mean. It just restricts the type of the data constructors, without giving any information back when you pattern match on values of the type.
12:49:55 <Cale> (also you'd need to parameterise the type then)
12:50:14 <beastie`> ok
12:50:14 <Cale> It might be easier to understand this type definition using the GADT syntax
12:50:15 <beastie`> thanks
12:50:20 <Cale> data RequestBody where
12:50:25 <geekosaur> also I sense some confusion here re the (RequestBodyClass a =>); a typeclass is not a type, it is roughly an interface
12:50:35 <Cale>   RequestBody :: forall a. RequestBodyClass a => a -> RequestBody
12:51:04 <Eduard_Munteanu> beastie`, for all 'a' there's a value 'RequestBodyClass a' which is a 'RequestBody'.
12:51:14 <geekosaur> you still need a type implementing the interface, and that's what 'RequestBodyClass a => ' means: given some type a that implements RequestBodyClass, ...
12:51:16 <Cale> what?
12:51:35 <Cale> Eduard_Munteanu: n... no
12:51:44 <Eduard_Munteanu> Er, for all 'a' such that RequestBodyClass a
12:51:56 <geekosaur> and the foirall means that 'a' is only in scope within the definition; you can;t access that type from outside, all you can do is use the known interface
12:52:00 <Eduard_Munteanu> I mixed up the class and constructor.
12:52:25 <Cale> Yeah, for all types a such that there's an instance RequestBodyClass a, you may apply the RequestBody data constructor to a value of type a in order to get a value of type RequestBody.
12:53:43 <Eduard_Munteanu> It's more obvious in  GADT syntax:   data RequestBody where RequestBody :: forall a. (RequestBodyClass a) => a -> RequestBody
12:53:46 <Cale> Since 'a' itself is forgotten in this process, when you later pattern match using a pattern like (RequestBody x), you don't get to assume anything about the type of x, except that you know it's an instance of RequestBodyClass, and so the methods of that class may be applied to x.
12:54:51 <beastie`> still can't get around my head why a is not visible
12:54:53 <Eduard_Munteanu> Note how that's completely different from   (forall a. RequestBodyClass a => a) -> RequestBody.
12:56:02 <Cale> beastie`: Because the type being defined is RequestBody, rather than RequestBody a
12:56:36 <beastie`> data RequestBody = RequestBodyClass a( => RequestBody a
12:56:36 <beastie`>  
12:56:40 <Cale> beastie`: It might help if we named the data constructor differently from the type constructor
12:57:35 <beastie`> data RequestBody =  (RequestBodyClass a) => RequestBody a
12:57:41 <beastie`> is the above wrong?
12:58:04 <Cale> You'll get an error about 'a' not being in scope
12:58:08 <Eduard_Munteanu> data TypeCtor = forall a. SomeClass a => DataCtor a
12:58:26 <Cale> The explicit forall is required, just to prevent cases where you do that accidentally
12:58:41 <Cale> You usually wouldn't want to accidentally form an existential type
13:00:02 <Eduard_Munteanu> e.g. if a :: Int and SomeClass Int then DataCtor a :: TypeCtor    (note there's no param to TypeCtor)
13:08:08 <pierrot> Hi, how can I enable ExistentialQuantification in GHCi?
13:08:31 <dmj`> :set -XExistentialQuantification
13:09:01 <pierrot> dmj`: Thanks
13:12:45 <pierrot> If I define "data T = forall a. MkT a" as in the documentation and then I do :t MkT in GHCi, the displayed type is MkT :: a -> T. Why isn't it MkT :: forall a. a -> T ?
13:13:10 <geekosaur> because it's at top level
13:13:13 <c_wraith> pierrot: :set -XExplicitForall
13:13:22 <c_wraith> ...  I hope that's the name of the extension
13:13:36 <geekosaur> I am wonder if you mean -fprint-explicit-foralls
13:13:41 <geekosaur> *wi=ondering
13:13:43 <c_wraith> yeah, that'd be it
13:13:46 <geekosaur> ... typing pfeh
13:15:04 <pierrot> Thanks c_wraith and geekosaur 
13:15:18 <geekosaur> oh, I missed this is the smw e kind of thing as before, no a on the left
13:15:31 <c_wraith> typing is not your friend today
13:15:39 <geekosaur> no, no it is not
13:15:47 <geekosaur> but that still seems like it might be buggy in that case since the forall actually means something here
13:24:37 <pola> I've an issue with builderNewFromFile from GI.Gtk, everything compiles, but every file I gave to build from it returns in a segmentation fault
13:24:52 <mivael_> hello all
13:24:55 <pola> is it probably a library issue isn't it?
13:29:16 <mivael_> Module `Text.Parsec.Char' does not export `endOfLine'
13:29:28 <mivael_> Does someone know how to find out the reason why this compilation error occurs?
13:32:08 <mivael_> (At least, local 'hoogle' reports me that the function should be there: Text.Parsec.Char endOfLine :: (Stream s m Char) => ParsecT s u m Char)
13:32:13 <Eduard_Munteanu> mivael_, what flavor of Parsec is that? Plain Parsec?
13:32:59 <mivael_> Eduard_Munteanu: I'm not sure I understand what Plain Parsec is.  How to find out?
13:33:23 <Eduard_Munteanu> I mean plain or normal Parsec. What package is it in?
13:35:54 <mivael_> All I can say at this point is that there are libghc-parsec3-dev and libghc-parsec3-prof (version 3.1.3-3+b1) packages are installed on my Debian GNU/Linux system.  Is it plain or normal Parsec, I'm not sure.
13:35:55 <Eduard_Munteanu> Or maybe it's using a really old version.
13:36:48 <Eduard_Munteanu> https://hackage.haskell.org/package/parsec-3.1.3/docs/Text-Parsec-Char.html
13:36:59 <Eduard_Munteanu> There's no endOfLine there.
13:37:06 <mivael_> oh
13:37:25 <mivael_> thank you, I'll look into it
13:40:19 <mivael_> Eduard_Munteanu: it is present in 3.1.11 docs, thus now the compilation error is explained.  Why my local 'hoogle' instance sees endOfLine is another question...
13:44:28 <geekosaur> use stack? with different projects having different resolvers? not sure if that can leave you with a miixed hoogle db
13:51:09 <monochrom> Does Hoogle even know where to find your stack-installed packages?
13:52:42 <geekosaur> building docs builds hoogle db if hoogle is installed. I don;t know offhand where stack puts the hoogle db in that case but I could see it being linked together and made accessible from outside for convenience
13:53:54 <monochrom> Ah OK.
13:57:00 <geekosaur> for that matter, installing some things via stack and others via os package manager's a lovely way to cause such confusions, no matter what tooling you use
13:57:30 <geekosaur> there's a reason perl, python, ruby, etc. won't support people installing other modules/eggs/gems into an OS installation
13:58:39 <geekosaur> the OS package manager *will* overwrite things the first time you have a collision, especially if building things like hoogle dbs is done by a postinstall script (file overwriting, at least, usually gets you at least a warning) 
13:59:28 <hpc> not with yum
13:59:59 <geekosaur> both stack and cabal will avoid the global package db in that case, but hoogle didn't have things thought out quite that fully last time I checked (only one db)
14:14:55 <balor> I see some code using the (:::) operator when defining types `type X = Y ::: Z ::: ()`.  What is the (:::) operator called?
14:15:17 <hpc> @hoogle (:::)
14:15:18 <lambdabot> Yi.MiniBuffer newtype (:::) t doc
14:15:18 <lambdabot> Data.Monoid.MList type (:::) a l = (Option a, l)
14:15:18 <lambdabot> CLaSH.NamedTypes type (:::) (name :: k) a = a
14:15:20 <erisco> domino
14:15:37 <geekosaur> it's not one of the standard operators
14:15:47 <geekosaur> (yes, haskell allows user defined operators)
14:16:08 <balor> thanks. I couldn't find it via the hoogle web interface.
14:16:13 <geekosaur> or, in this case, user defined infix constructors
14:16:39 <geekosaur> I suggest hayoo; hoogle often needs to be told to search more packages, whereas hayoo searches all of hackage
14:16:44 <geekosaur> @where hayoo
14:16:44 <lambdabot> http://hayoo.fh-wedel.de/ -- See also Hoogle: http://haskell.org/hoogle http://fpcomplete.com/hoogle
14:17:01 <hpc> hayoo is a bit slower, and doesn't always sort things conveniently
14:17:12 <hpc> i usually start with hoogle and then try hayoo if i don't get what i want
14:17:15 <geekosaur> and also is not as good at type searches
14:49:43 <Ero> Greetings Haskelletors. Can one of any recommend a freely available ebook on formal logic?
15:44:25 <centril> Ero: don't know if it's free, but maybe your university (if you attend one) can give you Logic in Computer Science in e-book form?
15:48:02 <nut> i
15:51:21 <najla> A
15:59:42 <Ero> ty centril 
16:00:14 <Ero> have you read this book yourself,centril ?
16:00:37 <centril> Ero: Parts of it. It is course material for http://www.cse.chalmers.se/edu/course/DAT060/
16:21:32 <dingus> has anyone tried to implement proarrow equippments in haskell, and would that be a helpful/worthwhile thing to do?
16:22:16 <dingus> im trying to learn haskell from a math background and I want to make something thats actually useful
16:25:16 <jle`> are you implementing them for fun and want to ask if it was a good exercise for learning?
16:25:26 <jle`> and in what sense of 'useful' do you mean?
16:25:44 <jle`> useful from a math research perspective, or for a every-life utility kind of thing
16:27:55 <wuwu> hi
16:28:45 <wuwu> i need help with functions
16:29:06 <wuwu> anyone?
16:29:36 <erisco> wuwu, ask away
16:30:08 <wuwu> so im trying to make my own monte carlo tree
16:30:16 <wuwu> data Node = Node { state :: Board, -- Current state                    action :: Move, -- action you took to get to this state                    value :: Int -- Current value of state                  } deriving (Show)  data Tree a = Empty | Data Node [Tree a] deriving (Show)
16:30:28 <wuwu> sry that came out bad
16:30:35 <wuwu> data Tree a = Empty | Data Node [Tree a] deriving (Show)
16:30:39 <erisco> wuwu, use lpaste.net for sharing long examples
16:32:11 <wuwu> I have a function: createChildren :: Tile -> Tree -> Tree which returns a tree after adding children nodes to it
16:32:23 <wuwu> createChildren tile Data (Node s a v) [Empty] = Data (Node s v) x
16:32:32 <wuwu>      where x = [Tree Data (Node ns m 0) [Empty] | m <- (validMoves s), ns <- (put s tile m)]
16:33:15 <wuwu> This seems logical to me, yet I'm getting an error:  • Expecting one more argument to ‘Tree’       Expected a type, but ‘Tree’ has kind ‘* -> *’     • In the type signature:         createChildren :: Tile -> Tree -> Tree
16:34:05 <wuwu> I don't see how I'm missing any arguments to my tree argument case in: createChildren tile Data (Node s a v) [Empty]
16:34:26 <Welkin> what is your definition for `Tree`?
16:34:33 <Welkin> it looks like it must be `Tree a`
16:34:36 <wuwu> data Tree a = Empty | Data Node [Tree a] deriving (Show)
16:34:38 <Welkin> yes
16:34:40 <Welkin> there you go
16:34:52 <Welkin> you need to supply an `a`
16:35:12 <Welkin> or just specify the `a` in your type
16:35:29 <Welkin> `Tree` is not a type, but `Tree a` is
16:35:44 <wuwu> oh...
16:36:06 <wuwu> except couldn't i just put everything after tree in parantheses
16:38:31 <wuwu> oh damn
16:38:41 <wuwu> lol i wasnt even looking at my function definition
16:38:43 <wuwu> facepalm
16:43:45 <dingus> jle well it would be just for learning purposes but I was curious if they would have any everyday-life utility
16:44:30 <dingus> functors and profunctors have utitlity so it seems like being able to talk about them in a nice unified framework could be helpful
16:49:42 <pierrot> I have the following implementation of the tails :: [a] -> [[a]] function: tails [] = [[]], tails ys@(x:xs) = ys : tails xs
16:49:53 <pierrot> I had never seen that @ before
16:50:07 <pierrot> What's ys@(x:xs) ?
16:51:10 <joomy> pierrot: It’s called an as-pattern
16:51:15 <byorgey> pierrot: ys@(x:xs)  matches the pattern (x:xs), but also gives the whole thing the name ys
16:51:27 <byorgey> pierrot: it's as if you pattern-matched both (x:xs) and ys at the same time
16:52:12 <byorgey> > case [1,2,3] of ys@(x:xs) -> (ys, x, xs)
16:52:14 <lambdabot>  ([1,2,3],1,[2,3])
16:52:39 <pierrot> Thanks joomy and byorgey :)
16:55:38 <pierrot> so that line could be rewritten as tails (x:xs) = (x:xs) : tails xs
16:55:56 <pierrot> @ is only for simplify the notation, right?
16:56:06 <pierrot> or is there any purpose apart from that?
16:56:08 <jle`> semantically, yes
16:56:14 <jle`> but there are some operational benefits
16:56:18 <jle`> using as-patterns allows sharing
16:56:38 <jle`> tails (x:xs) = (x:xs) : tails xs will create a new cons cell in memory (x:xs)
16:57:01 <jle`> but `tails ys@(x:xs) = ys : tails xs`, the 'ys' points to the original list in memory
16:57:14 <pierrot> Hmm.. I see
16:57:18 <jle`> actually there are some semantic differences too
16:57:25 <jle`> so i lied
16:57:52 <byorgey> pierrot: you have the right idea though =)
16:58:08 <jle`> oh nvm in the context of the original definition, there are no semantic differences
16:59:17 <jle`> so 'denotionally' they refer to the same thing.  but the process of GHC evaluating them can be different
17:26:55 <proofskiddie> I've noticed lpaste has some really helpful error / warning messages. Any way to get this in intero?
17:29:47 <slack1256> When coding I always got firefox open with (local) haddock pages. It usually ends up a mess of tabs with duplicated tabs.
17:30:14 <slack1256> what is the alternative? everybody just does that?
17:31:36 <geekosaur> proofskiddie, I think you can configure flycheck to run hint
17:31:45 <geekosaur> er, hlint
17:33:30 <proofskiddie> Awesome, it appears the package in emacs is called 'hlint-refactor'
18:01:44 <N3RGY> Can anyone explain what's happening here? Using point-free style makes GHC claim my type is incorrect. Extremely short 4-line example: https://gist.github.com/wyager/c15c24888c017a66488e3d0f4d372905
18:02:07 <N3RGY> My guess is that the type of (.) interacts badly with universal quantification, but I'm not sure how.
18:03:30 <geekosaur> you just missed my explanation of much the same thing n -beginners
18:04:28 <geekosaur> hm, no, this isn't the same thing
18:04:57 <geekosaur> oh, yes it is.
18:05:22 <geekosaur> so, when you use a thing that takes a rank-2 type with (.), ghc has to make what is called an impredicative type
18:05:43 <geekosaur> ghc has never had working impredicative types. at this point they've given up.
18:06:28 <geekosaur> now: if you could phrase it in terms of ($) instead of (.), there is a special hack in the typechecker to let it work despite the impredicative type; this works only because ($) is really simple
18:07:18 <N3RGY> Interesting. I'm familiar with impredicative types, but I'm not seeing the connection here. I'm familiar with the ($)-boxity hack; is it the same one you're talking about?
18:07:25 <geekosaur> (tis is for example why you never see runST used in point-free form; it can;t typecheck)
18:07:46 <geekosaur> (.) as applied to hoist has to have an impredicative type
18:08:18 <geekosaur> likewise, if you try (runST . ...), it won;t typecheck. ghc cant generalize (.) to the required impredicative type
18:08:30 <geekosaur> but runST $ ... works because of the typechecker hack
18:10:33 <N3RGY> Interesting. I'm a bit tired right now; could you help me come up with a minimal example that would result in composition generating an impredicative type? It seems like any universal quantifiers in my example would only show up inside arrows, which as I understand GHC can handle fine
18:11:30 <geekosaur> I am really not the best person to ask (and I'm more or less parroting and may have it wrong; my types-fu doesn't extent to impredicativity)
18:12:03 <N3RGY> Ok, well thanks anyway. I'll think on it
18:12:10 <c_wraith> N3RGY: yes, it's just higher-rank.  That's enough that it still can't be inferred
18:12:45 <c_wraith> N3RGY: and when you try to annotate the types, you discover just how much you depend on inference on every subexpression
18:13:11 <N3RGY> Why can't GHC infer it even with RankNTypes turned on?
18:13:43 <c_wraith> It's not decidable in general.  It's fragile to get even a piece of it working.
18:13:59 <c_wraith> It's much easier for users if you just say "this isn't inferred" than if you say "sometimes this is inferred"
18:14:15 <N3RGY> Interesting. I was not aware of that.
18:18:33 <c_wraith> N3RGY: the reason it's not decideable is that it's ambiguous.  Consider something like this:    foo f x y = (f x, f y)
18:18:59 <c_wraith> N3RGY: that could have the type foo :: (a -> b) -> a -> a -> (b, b)
18:19:44 <c_wraith> N3RGY: or it could have the type foo :: (Num b, Num c) => (forall a. Num a -> d) -> b -> c -> (d, d)
18:20:10 <c_wraith> N3RGY: neither of those types is a generalization of the either.
18:20:29 <N3RGY> Ah, got it
18:21:35 <N3RGY> Well thanks for the help guys, I'll stick with point-ful syntax then!
18:22:25 <c_wraith> whoops.  for the record, foo :: (Num b, Num c) => (forall a. Num a => a -> d) -> b -> c -> (d, d)
18:22:42 <c_wraith> Just in case someone finds it while searching. :)
18:51:26 <Bish> people still awake here?
18:52:29 <geekosaur> sorta
18:52:41 <Bish> can a pure function result in a different "return value" if its pure?
18:53:00 <Bish> if no ⇒ does everything reading a file not apply as a pure function?
18:53:05 <Bish> trying to get my head around that
18:53:09 <geekosaur> correct
18:53:29 <geekosaur> you need to read a file in IO. although there's the lazy I/O stuff which loksk pure but secretly isn't
18:53:38 <Bish> hm, thats odd since that makes the full pureness thing pretty broken, doesnt it?
18:54:27 <Bish> or better question: a function using that function that reads a file, cant be pure either, right?
18:54:32 <geekosaur> not as much as you would think. see http://www.vex.net/~trebla/haskell/IO.xhtml
18:54:33 <Bish> well it can be sure, but neccessarely is
18:54:43 <Bish> but not*
18:55:03 <geekosaur> (the trick: conceptually you're building a program that gets shipped off to an impure interpreter)
18:55:53 <Bish> how does that make it any better :(
18:56:20 <c_wraith> Bish: it makes types like IO (IO ()) make sense. :)
18:56:40 <Bish> i learned so many languages, haskell is such a barrier to me :(
18:57:31 <Bish> just wanted something to think about before going to bed, thanks guys
18:57:44 <blackdog> Bish: the pattern you usually use is a very thin shell that does reading, writing etc, and that calls pure functions to work out what to do. obviously you need to read and write stuff _somewhere_ - you just don't want it infecting the whole codebase.
18:57:55 <erisco> maybe shelf IO and learn simpler things first
18:57:59 <Bish> blackdog: thats how i imagined it
18:58:16 <Bish> i usually learn languages by writing a bot in it, or http server
18:58:20 <Bish> WAI looks fun
18:58:30 <Bish> i mean not http server.. more like a webpage
19:01:49 <blackdog> Bish: i would say that's a pretty bad way of learning haskell, unless you've played around with related languages like ML before
19:02:09 <erisco> in my opinion, that is a muddy way to learn functional programming because it incorporates unnecessary noise
19:02:25 <blackdog> if you've done ruby, python/php/perl/javascript will all be pretty easy - you're just learning names for familiar concepts
19:02:54 <blackdog> in haskell there's a good chance you're encountering some programming concepts for the first time. go slow and learn the basics.
19:03:18 <erisco> it would be better to engage with the unfamiliarity on the simplest terms, because that contains the least to learn, and build up
19:05:46 <erisco> i.e. how you think now, what you find familiar, may not be aligned with how you need to be thinking for FP
19:06:27 <erisco> so, I'd recommend the road map one of the Haskell books lays out
19:07:38 <erisco> they gone to the trouble of reconstructing, from their experience, a path from simple beginnings to greater complexities
19:09:26 <erisco> Haskell is far enough disjointed from procedural programming that this more holistic approach is warranted
19:10:35 <Bish> erisco: im actually researching haskell quite a while now..
19:10:54 <Bish> as i said, i did a lot of languages, also studied a bit cs.. i think know i am getting into
19:11:21 <Bish> without a practical use i find it hard to learn languages, i mean at one point i gotta start coding?
19:12:20 <Bish> erisco: WAI is pretty similiar to other thinks i now, like rack from ruby? i think it even inspired it?
19:14:37 <erisco> you can use a lot of languages and never leave procedural programming, because there are many procedural programming languages
19:15:16 <erisco> I lump OOP in there as well as an extension of procedural programming
19:18:02 <erisco> the idea of "practical use" is entirely subject to the practitioner
19:19:40 <erisco> I think you can accept as a premise that languages are designed to fit some ideal, though that does not preclude them from tackling problems in other domains
19:22:44 <erisco> if you succeed in making a web server with Haskell I hope that you manage to bump into the various ideals, reasons, and benefits of Haskell, and FP more generally
19:23:20 <erisco> otherwise you've merely ended up with another web server written with some different syntax
19:24:15 <erisco> so, it is a project you can choose to explore Haskell, i.e. creating a web server, but I think a more simplified and direct approach, one which takes you straight to the heart of Haskell, will serve you more effectively and efficiently
19:29:46 <erisco> a further opinion I have: programming languages garner a community of ideas and methodologies, and to speak of a PL usually also includes the community
19:30:30 <erisco> from that, and broadly speaking, procedural programming sees programs as a tool to rearrange inputs to produce outputs
19:31:23 <erisco> so, a program is something you create to interact with the world in a fashion like this
19:31:57 <erisco> I think the propensity to write effectful programs such as web servers is an example of this
19:33:36 <erisco> functional programming, or at least particularly Haskell (because it is the community I am most familiar with), sees programs as a mathematical exercise
19:34:27 <erisco> so, a program is something you can create to understand more about computation. In fact, as I and others joke, what's the point of actually running a program?
19:35:27 <erisco> however, as I said earlier, regardless of intentions of a language (by the designers or practitioners) it can be used in other domains
19:35:55 <erisco> so, you can study procedural programming in an analytic, mathematical setting, or you can use Haskell as a tool to rearrange inputs to produce outputs
19:36:15 <erisco> and there is plenty use and understanding to be had either way
19:37:05 <marvin3> way to reinforce stereotypes that haskell is impractical langauge not usable for real tasks
19:38:53 <erisco> if that is what someone manages to excise after reading my whole discussion then I think they had their mind set beforehand ;)
19:41:20 <erisco> some of what I am most interested in right now is an example of procedural programming… particularly operational semantics
19:42:20 <erisco> it can be difficult to understand what the whole program does, but the benefit is that one can readily specify and then use instructions
19:43:29 <erisco> now we're seeing more of how to tackle the problem of understanding procedural programs
19:47:10 <jmcarthur> Sometimes I have functions like  Foo a -> Foo X  where Foo is a GADT and some cases require reconstructing the same thing on the right side that was just matched on the left side. Is there either a way to avoid this or to be guaranteed that GHC will just share the input instead of reconstructing it?
19:47:20 <jmcarthur> In this case I want to be really really sure it's actually shared.
19:47:30 <erisco> marvin3, I think it is good to inspire people to think about computation as a means to its own end, rather than a means to something else
19:48:36 <jmcarthur> unsafeCoerce would do what I want, but if there is a lighter hammer I would prefer it.
19:53:16 <erisco> jmcarthur, there is a safe coerce http://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Coerce.html but I have seen this used for newtype coercions rather than GADT coercions
19:53:58 <erisco> I am suspect about the claim that a GADT at different types has the same representation
19:54:14 <S11001001> jmcarthur: doing the match should prove that a ~ X, so returning the argument should work
19:54:25 <jmcarthur> erisco: Really? I can't think of any reason they would have different representations.
19:54:32 <jmcarthur> S11001001: It does not.
19:55:18 <erisco> UNPACK comes to mind, but there may be other specialisations, I am not sure. The point is I do not have any evidence they are the same representation, either
19:55:21 <jmcarthur> S11001001: In this case, matching doesn't prove anything about a, because the constructor doesn't constraint it at all. However, that means reconstructing it would result in the desired type.
19:55:27 <jmcarthur> *constrain
19:55:49 <geekosaur> Data.Coerce relies on a magic typeclass that ghc makes instances for when it sees a newtype
19:55:50 <jmcarthur> I think that this is a GADT might not even be relevant.
19:56:05 <jmcarthur> Other than that it isn't a newtype, that is.
19:58:16 <erisco> newtypes are guaranteed to have the same representation, so maybe you can rearrange your problem to leverage that
19:58:35 <erisco> the same representation as the underlying type
20:00:19 <jmcarthur> I believe I have done all the rearranging that I can. In fact, the only reason I am using a GADT is to combine two types into one without losing type safety, so I can eliminate constructors that just convert from one type to the other. I'm using newtype to recover my original types.
20:04:54 <jmcarthur> I found this. https://ghc.haskell.org/trac/ghc/ticket/9291
20:05:30 <erisco> jmcarthur, here is an idea: newtype AorB a b = AorB (forall r. (a -> r) -> (b -> r) -> r)
20:05:46 <jmcarthur> I was hoping for something like rwbarton's idea (OCaml has it, and I use it a lot there), but it doesn't seem to be what we got.
20:06:29 <jmcarthur> erisco: Unfortunately, I have to avoid higher order representations, because that is also an easy way to lose sharing.
20:06:43 <jmcarthur> erisco: Also, I don't see how this would help me anyway.
20:06:56 <erisco> *shrug* okay
20:11:35 <erisco> sounds like the type system needs a better understand of equivalence
20:11:40 <erisco> I wonder what type theory could help there
20:11:50 <kaychaks> erisco: on the point of projects with direct approach, do you have some e.g. in mind ?
20:12:19 <erisco> kaychaks, the free Haskell books have examples and problems to work through
20:17:00 <jmcarthur> Well, I went with unsafeCoerce for now, even though it violates the contract... I promise I won't give this to anybody else without looking into it further. :)
20:19:51 <geekosaur> suspect you'll find out soon enough if it was the wrong move
20:20:31 <erisco> or in 20 years when becomes default software in millions of OS installs
20:20:37 <erisco> then you make headlines! :)
20:20:57 <geekosaur> equifax style?
20:26:20 <linoge> you mean like leaving admin/admin because you know, I'll change it later this night
20:27:00 <erisco> in the Spongebob narrator voice: "Many years later…"
21:02:13 <Railalis> hm xmonad irc is kinda dead.
21:02:40 <Li[m]1> whos gonna make a wayland rewrite?
21:03:01 <Railalis> wayland?
21:03:19 <Li[m]1> I was alludiing to xmonad
21:03:26 <Li[m]1> waymonad
21:03:42 <Railalis> never heard of it referenced in such a awy
21:04:04 <Li[m]1> well, the x in xmonad refers to the X display server
21:04:08 <Li[m]1> I suppose
21:04:22 <Li[m]1> im just playing with words here
21:04:24 <Clint> https://github.com/xmonad/xmonad/issues/38
21:04:40 <Railalis> alright haha
21:07:15 <Li[m]1> have you guys ordered your librem phones? https://puri.sm/shop/librem-5/
21:07:27 <Li[m]1> I missed the novena laptop, but I wont miss the phone :P
21:07:52 <Railalis> what dis
21:08:57 <Railalis> 'spensive
21:09:09 <Li[m]1> not if they use the i.mx8 soc
21:09:12 <Li[m]1> then its a bargain
21:09:21 <Li[m]1> still uncertain thou
21:09:26 <Railalis> their laptops rather
21:09:37 <Li[m]1> ahh yes, I have zero interest in x86
21:09:45 <Li[m]1> f*** intel
21:10:48 <Railalis> chromebook +  rdp
21:10:50 <Li[m]1> hakell in ma pocket !
21:11:02 <Railalis> glorified portable shell
21:11:19 <Li[m]1> the laptop is obsolete
21:12:50 <Railalis> I think someone mentioning there was a haskell based OS
21:13:45 <geekosaur> house (defunct), halvm (galois experiment)
21:14:13 <Railalis> just curious as to what they look like and function
21:14:18 <Alovenom> so expensive, I cry
21:14:20 <Railalis> seems like quite the undertaking though.
21:15:31 <Li[m]1> aye lets write a haskell matrix client library
21:15:41 <Li[m]1> riot sucks
21:15:43 <Railalis> doesn't that already exist?
21:15:48 <Alovenom> Is waymonad going to be a thing ?
21:15:54 <Li[m]1> I hope so
21:15:59 <Alovenom> I really do
21:16:06 <Alovenom> because I really like xmonad and I really dislike X
21:16:08 <Li[m]1> Ill send some  donation to it
21:16:08 <geekosaur> unlikely, since most of us think wayland needs to go back in the cooker for another couple years
21:16:15 <Alovenom> aw
21:16:22 <Railalis> I wanted to try xmonad..
21:16:26 <Alovenom> I don't know anything about wayland tbh 
21:16:26 <Li[m]1> its already better than x
21:16:40 <Railalis> but I'm a big vim guy, so I was looking around for vim-esque keybinds (many flavors fortunately)
21:16:49 <Li[m]1> the main reason for qubesos was the insecurity of x
21:16:50 <Railalis> however idk how to even start the dang thing.
21:16:52 <geekosaur> and, given rh;s overreach, I dont trust wayland to reliably work with anything but gnome because I trust the gnome devs to modify wayland as they see fit to suit themselves at the expense of everyone else
21:17:11 <Railalis> gnome is good though?
21:17:18 <Alovenom> Eh HE
21:17:20 <Li[m]1> wayland is a pretty open slate
21:17:29 <Alovenom> I dunlike gnome
21:17:53 <Li[m]1> if it keeps ppl from using windoze. my gf likes it
21:18:25 <Railalis> ... so a wasp flew in my room... I killed it with a network card..
21:18:39 <Railalis> cause it was the closest thing next to me I could kill it with at the time 
21:18:42 <Railalis> this concerns me.
21:19:31 <Railalis> I want games to run better on linux
21:19:34 <Railalis> need to learn wine.
21:19:58 <Li[m]1> everybody is going with vulkan now, so its gonna happen
21:20:20 <Railalis> well they are patching for vulkan
21:20:58 <Railalis> their engines aren't changing I don't think.
21:23:17 <Li[m]1> when war engulfs the world, you'll look back at your time playing video games as lost opportunity. just saying. plant food thats more fun
21:24:15 <Railalis> ok prepper you.
21:24:19 <Li[m]1> https://github.com/begla/Intrinsic
21:25:04 <Railalis> I think a lot of studios already have custom engines though built on like c++ etc.
21:28:47 <Railalis> huh can't close buffer 1 in weechat
21:52:57 <vivekramaswamy> Hello I have a quick question with regards to type inference. please see http://lpaste.net/359028 and comment on why one statement works and why other does not
21:55:33 <Eduard_Munteanu> vivekramaswamy, Ord is a typeclass, not a type. You probably want  myAbs :: (Ord a, Num a) => a -> a
21:55:54 <monochrom> A class is not a type.
21:56:08 <Eduard_Munteanu> You also need Num because of 0.
21:59:42 <monochrom> You should also believe the error message.
22:00:34 <monochrom> While the part about "Ord has kind * -> Constraint" is too advanced, the part about "expected a type" at least is obviously saying that Ord is not a type, so you can't use it where you should use a type.
22:05:37 <vivekramaswamy> Thanks you all, I get it now
22:42:31 <trev_> Having trouble getting helm properly setup on OSX, so I'm trying out building via docker image: https://github.com/freebroccolo/docker-haskell, has that worked out for anyone else? Still downloading the image and such
22:53:50 <suzu> what is helm Tuplanolla ?
22:53:59 <suzu> sorry! trev_ *
22:54:17 <suzu> oh.. they're gone
22:54:22 <suzu> ~_~
22:54:25 * suzu dies of embarassment
22:55:13 <vivekramaswamy> Now Num is also a type class like Ord, then how does this work as I don't give any types either to it. http://lpaste.net/359029
22:58:51 <Cale> vivekramaswamy: That's what makes type classes better than ad-hoc polymorphism. You can define type class polymorphic functions just by using type class polymorphic functions.
23:00:22 <Cale> :t sort
23:00:25 <lambdabot> Ord a => [a] -> [a]
23:01:07 <Cale> So just by using the order comparison operations like (<=), we get a sort function which can sort lists of any type that has those operations defined on it.
23:01:20 <vivekramaswamy> agreed Cale, bu in that case even this should have worked http://lpaste.net/359028
23:01:39 <Cale> Ah, Ord isn't a type
23:02:01 <Cale> It's a type class -- a property that might or might not be satisfied by any particular type
23:02:15 <vivekramaswamy> And so is Num, which is alo a typeclass as opposed to a type
23:02:17 <Cale> You can write  myAbs :: (Ord a, Num a) => a -> a
23:02:36 <Cale> Ord -> Ord doesn't make sense though
23:02:56 <Cale> If you remove the type signature from your definition, you can ask ghci  :t myAbs
23:02:58 <vivekramaswamy> But what what I can't undesratnmd is why can't I write myAbs::(Num a )=>a->a
23:03:01 <Cale> and it'll give you the type that I gave
23:03:11 <Cale> Because you used >=
23:03:13 <Cale> :t (>=)
23:03:16 <lambdabot> Ord a => a -> a -> Bool
23:03:19 <Cale> ^^ needs Ord
23:03:44 <Cale> For example, if a were some type of complex numbers, there might not be an instance of Ord
23:04:17 <Cale> So you need both Ord (for the (>=)) and Num (for the negation) in order for that definition to work
23:05:15 <Cale> Oh, also for the 0
23:05:17 <Cale> :t 0
23:05:19 <lambdabot> Num p => p
23:05:25 <vivekramaswamy> ok, so what I am saying here is (Num a, Ord a) is that this function can take an input which has a type derived from Num and Ord type class is that correct
23:05:45 <Cale> A type which is an instance of both the Ord and Num type classes
23:05:52 <Cale> yeah
23:06:00 <Cale> and it produces a result of the same type
23:06:15 <vivekramaswamy> ok I get it, thank you very much I was quite confused on this one
23:06:19 <Cale> Note that this is an advantage of this notation over having a syntax like  Ord -> Ord
23:06:35 <Cale> In that you can be particular about whether those are the same type or not
