00:19:00 <ertes-w> hell
00:27:32 <dyreshark> sorry, this isn't hell
00:27:43 <dyreshark> though given that this channel is computer-related, i can see how you might get confused
00:34:10 <osa1> saurabhnanda: I don't know what IResult is but if Either is OK that's something like `parseEither parseJSON`
00:34:27 <osa1> parseEither parseJSON :: FromJSON b => Value -> Either String b
00:34:28 <saurabhnanda> osa1: need to specify a parser by hand. and not depend on typeclass.
00:34:42 <saurabhnanda> osa1: found the answer.It's not well documented. Had to use iParse 
00:34:53 <osa1> saurabhnanda: just write a function `Value -> Either String a` ?
00:35:12 <saurabhnanda> what's the best way to drop chars that satisfy a predicate from the end of the String (not Text)... or better yet, how to remove trailing slashes from a FilePath?
00:35:43 <osa1> > :t dropWhile isSpace
00:35:46 <lambdabot>  <hint>:1:1: error: parse error on input ‘:’
00:36:11 <osa1> oh you said trailing...
00:36:50 <saurabhnanda> found it... https://hackage.haskell.org/package/filepath-1.4.1.2/docs/System-FilePath-Posix.html#v:dropTrailingPathSeparator
00:37:58 * hackagebot mackerel-client 0.1.0 – An API client library for Mackerel – https://hackage.haskell.org/package/mackerel-client
00:37:58 * hackagebot bitset-word8 0.1.0.1 – Space efficient set of Word8 and some pre-canned sets useful for parsing HTTP – https://hackage.haskell.org/package/bitset-word8
00:48:12 <piyush-kurur> has any one managed to get an "import Foo" in the Haskell code extracted via Coq
00:49:19 <piyush-kurur> s/via/from/
01:19:23 <saurabhnanda> what's the best way to transform an HTML in haskell? i.e. find a div with a specific ID and replace it with Lucid.Html
01:22:27 <saurabhnanda> can tagsoup or html-parse EMIT html? or are they only for parsing?
01:31:49 <ertes-w> is there a well-understood concept of switching folds?  like: fold with one algebra until a certain condition becomes true, then switch to a different algebra?
01:33:12 <ertes-w> saurabhnanda: tagsoup is not a good choice, because it "forgets" the structure of the document…  it's only really useful for extracting information from messy/underspecified documents
01:34:12 <saurabhnanda> ertes-w: is HaXML the answer? But all parsing over there seems to be working on String data type. Not sure if that is a good idea.
01:34:32 <ertes-w> saurabhnanda: i don't know, sorry…  all libraries i know can either parse or render, but not both
01:35:14 <saurabhnanda> HaXml could be the answer -- Haskell utilities for parsing, filtering, transforming and generating XML documents
01:35:30 <ertes-w> saurabhnanda: in any case, HTML5 is probably not well-formed XML
01:35:43 <alp> saurabhnanda, note that some libraries come in '-lens' variant, and if you see traversals and lenses in those, it means you can transform the HTML
01:35:45 <ertes-w> saurabhnanda: parsing HTML5 into a tree requires semantic knowledge of the document
01:36:07 <ertes-w> for example the fact that <br> is really equivalent to <br />, despite the lack of an end tag
01:36:07 <saurabhnanda> from https://hackage.haskell.org/package/HaXml-1.25.4/docs/Text-XML-HaXml-Html-Parse.html -- This is a parser for HTML documents. Unlike for XML documents, it must include a certain amount of error-correction to account for HTML features like self-terminating tags, unterminated tags, and incorrect nesting. The input is tokenised by the XML lexer (a separate lexer is not required for HTML).
01:36:14 <saurabhnanda> don't know how well it works TBH
01:36:42 <ertes-w> saurabhnanda: sounds reasonable…  HTML5 is reasonably well specified, so it might just work
01:37:03 <saurabhnanda> only one way to find out...
01:37:24 <ertes-w> saurabhnanda: i'd probably look for a lens variant
01:37:29 <ertes-w> or write one, if none exists
01:41:32 <saurabhnanda> found one which has lenses
01:41:38 <saurabhnanda> Text.Taggy and Text.Taggy.Lens
01:42:26 <saurabhnanda> no easy way to do an xpath lookup or css lookup
01:45:50 <saurabhnanda> in https://www.schoolofhaskell.com/school/starting-with-haskell/libraries-and-frameworks/text-manipulation/tagsoup -- what is the {-hi-} pragma for?
01:48:08 <ertes-w> why do you need xpath, if you have lenses?
01:48:17 <merijn> saurabhnanda: THat's not a pragma
01:48:24 <merijn> saurabhnanda: At least not a compiler pragma
01:48:38 <merijn> saurabhnanda: Pragma's start with {-#
01:48:42 <merijn> {- is just a comment
01:48:46 <saurabhnanda> ah okay
01:49:15 <saurabhnanda> ertes-w: coun't find a lens which is the equivalent of findElementById()
01:49:28 <merijn> saurabhnanda: scanning the paragraph above mentions "these changes are highlighted", so I suspect they were supposed to highlight the relevant code on the webpage, but shit broke
01:49:48 <saurabhnanda> ah okay...
01:50:00 <saurabhnanda> I guess it's build using hakyll, is it?
01:50:46 <ertes-w> saurabhnanda: i'm assuming that you need to use 'attributed' for that
01:51:29 <merijn> saurabhnanda: I don't have experience with tagsoup, but xml-conduit/html-conduit can easily do "find element by id"
01:51:43 <saurabhnanda> playing with HaXml right now... seems to have parsed a full-fledged webpage without throwing a fit...
01:52:19 <saurabhnanda> what's Prolog in HaXml
01:52:21 <merijn> saurabhnanda: If you're doing scraping (i.e. no "hard" schema's just messy webpages I can recommend html-conduit, it's worked very well for me
01:53:08 <saurabhnanda> merijn: need HTML transformation. Microservice is giving an HTML "shell". The Haskell code needs to replace div#content with the actual content and serve it to the browser.
01:53:24 <saurabhnanda> shell = logo + header + fotoer
01:53:34 <merijn> saurabhnanda: I wrote a small scraper for a webcomic a while ago, the orphan MonadIO instance for Concurrently has bitrotted, but the rest is ok: https://gist.github.com/merijn/d8188ddd129718ffcfb0#file-scraper-hs-L55-L59
01:54:09 <merijn> saurabhnanda: The highlight is literally doing "findElementById" (find all divs with id "comic")
01:54:22 <merijn> saurabhnanda: Should be possible, although I haven't really tried outputting html again
01:55:48 <saurabhnanda> merijn: you are correct. So the next step for me will be to replace a div with Lucid.Html and output the html again.
01:59:21 <saurabhnanda> should this do it? https://hackage.haskell.org/package/xml-conduit-1.7.0/docs/Text-XML-Stream-Render.html
02:00:07 <merijn> saurabhnanda: Yeah, like I said, it has support for outputting stuff after modification, I just haven't played with it, so can't say how nice it is
02:00:21 <saurabhnanda> where is the modification stuff?
02:01:36 <ertes-w> merijn: would you recommend html-conduit over tagsoup?
02:02:46 <merijn> ertes-w: Well, I haven't used tagsoup, so I can't say if it's better
02:02:55 <merijn> ertes-w: Only that html-conduit didn't suck :p
02:02:57 <ertes-w> ah, ok
02:03:16 <merijn> ertes-w: But really only for unstructured scraping, since it doesn't have any kind of schema's, etc.
02:03:28 <ertes-w> that's good enough…  i'm not overly fond of tagsoup =)
02:03:47 <ertes-w> it's slow, and the API is awkward
02:04:33 <merijn> ertes-w: html-conduit is modelled after XSLT selectors
02:05:06 <merijn> ertes-w: You need to stare at the docs a bit to figure out how it fits together with >=>, but it's not particularly tricky
02:09:51 <saurabhnanda> I found what I need in HaXml but god knows how to use it... https://hackage.haskell.org/package/HaXml-1.25.4/docs/Text-XML-HaXml-Combinators.html
02:10:33 <saurabhnanda> why does stuff like this pass for good documentation -- "In the algebra of combinators, none is the zero, and keep the identity. (They have a more general type than just CFilter.)"
02:10:50 <saurabhnanda> "These XML transformation combinators are described in the paper ``Haskell and XML: Generic Combinators or Type-Based Translation?'' Malcolm Wallace and Colin Runciman, Proceedings ICFP'99."
02:11:10 <merijn> saurabhnanda: Who says it passes for good documentation?
02:12:55 <saurabhnanda> wow, there are **Netscape** screenshots at https://www.cs.york.ac.uk/fp/HaXml/icfp99.html -- how old is this library?!
02:13:16 <merijn> I'm gonna take a wild guess and say...1999?
02:15:40 <saurabhnanda> lol... stepped right into it :)
02:15:46 <saurabhnanda> ICFP 99
02:18:45 <saurabhnanda> hah... I'm not alone :) https://www.reddit.com/r/haskell/comments/1q4o4d/help_haxml_tries_to_kill_me/ -- "I read the HaXml documentation on Hackage for about two hours, but still do not understand how to do anything practical with it"
02:19:09 <Cale> saurabhnanda: It passes for good documentation because the only people who will ever read it are programming language researchers ;)
02:19:54 <merijn> It passes for good documentation, because no one was paying the authors to write anything better :p
02:20:23 <saurabhnanda> some HSoC projects should really focus on this aspect.
02:20:30 <ertes-w> it passes for good documentation, because it has "algebra" and "identity" in it
02:20:44 <merijn> Same reason by work code has 0 comments and 0 docs :p
02:22:52 <saurabhnanda> could this help me in replacing div#content within xml-conduit? https://hackage.haskell.org/package/xml-html-conduit-lens-0.3.2.3/docs/Text-Xml-Lens.html
02:26:50 <saurabhnanda> how does one fix this dependency resolver issue? 
02:27:12 <saurabhnanda> Error: While constructing the build plan, the following exceptions were encountered:        In the dependencies for xml-html-conduit-lens-0.3.2.3: xml-conduit-1.5.1 must match >=1.1 && <1.5 (latest applicable is 1.4.0.4) needed due to webservice-0.1.0.0 -> xml-html-conduit-lens-0.3.2.3
02:30:50 <saurabhnanda> in stack how does one override the version of a single library?
02:36:09 <barrucadu> In your stack.yaml, you add package-version to your extra-deps
02:36:51 <barrucadu> https://docs.haskellstack.org/en/stable/yaml_configuration/#extra-deps
02:41:04 <saurabhnanda> barracuda: also needed to supply the version in the cabal file.
02:48:05 <merijn> Where's all the beginners who are always asking "What should I program in Haskell?" because I got some ideas :p
02:48:15 <LKoen> hi
02:48:18 <LKoen> I'm a beginner
02:49:24 <merijn> LKoen: Implement a version of https://github.com/hvr/multi-ghc-travis that works with cabal.project files, I'll love you forever ;)
02:49:35 <maerwald> merijn: they are all gone, since they have been recommended to hack on GHC
02:50:33 <LKoen> merijn: hmmmmmmm just to be clear, I wasn't being humble when I said "beginner". I don't know what cabal is
02:51:26 <merijn> LKoen: It's the build tool for Haskell projects (well, I suppose these days it's *a* build tool, since there's also stack)
02:52:26 * hackagebot c-mosquitto 0.1.2.0 – Simpe mosquito MQTT binding able to work with the Amazons IoT – https://hackage.haskell.org/package/c-mosquitto
02:53:30 <LKoen> merijn: if the readme is any indication, this is way above my head
02:54:22 <merijn> LKoen: In terms of actual programming it's probably doable, but the documentation and info you need is...a bit of a mess :p Which is why I was hoping not to have to do it ;)
03:01:27 <LKoen> merijn: so what's your next idea?
03:02:51 <merijn> That was the only one I really had, so it was mostly for comedic effect :p
03:12:07 * hackagebot hslua 0.9.0 – A Lua language interpreter embedding in Haskell – https://hackage.haskell.org/package/hslua
03:43:14 <graperoot> I have a love/hate relationship with stack
03:50:24 <erikd> anyone have any clues on how to parse JSON with Aeson so that the parser adds a predefined field? Eg parsing int say "data X = X a b c d e" where b .. e comes from the parsed JSON, but a is supplied by the caller?
03:51:21 <erikd> or should I parameterize the X type with a?
03:56:44 <merijn> graperoot: Have you played with cabal new-build?
03:57:03 <merijn> I couldn't be arsed to learn stack, but new-build is nice :)
04:01:31 <phaazon> goddammit
04:01:37 <phaazon> ftp-client sucks so hard
04:01:42 <phaazon> I need a better library
04:04:54 <tdammers> or a better protocol :x
04:05:30 <phaazon> <no location info>: error:
04:05:30 <phaazon>     Ambiguous module name ‘Network.FTP.Client’:
04:05:30 <phaazon>       it was found in multiple packages: ftp-client-0.5.0.0 ftphs-1.0.9.2
04:05:33 <phaazon> GODDAMMIT :D
04:05:38 <phaazon> how can I resolve that?
04:06:16 <phaazon> do I need to unregister the package I don’t want?
04:06:30 <int-e> phaazon: you can hide packages
04:06:43 <phaazon> how?
04:07:00 <int-e> phaazon: ghc-pkg hide ftp-client. this affects ghci
04:07:21 <Tuplanolla> Also `PackageImports`, phaazon.
04:07:32 <phaazon> Tuplanolla: oh yeah I remember that
04:07:36 <phaazon> thanks guys
04:08:07 <geekosaur> or use a cabal file
04:08:55 <phaazon> I’m using stack
04:08:57 <phaazon> and stack ghci
04:09:01 <phaazon> but yeah, I figured it out
04:09:12 <phaazon> btw, ftphs is way better than ftp-client
04:10:47 <geekosaur> stack uses cabal files. if you're relying on the global project and no cabal fle then yes, you will have to use -package or something
04:10:59 <geekosaur> roughly, same rules as for the script interpreter
04:21:03 <saurabhnanda> aargh... falling back to regex-replace for HTML tranformation!
04:22:24 * geekosaur sends shoggoth repellent
04:24:36 <saurabhnanda> any help on this would be appreciated -- https://github.com/snoyberg/xml/issues/115
04:29:35 <saurabhnanda> finally. Good documentation -- http://regex.uk/tutorial
04:33:32 <phaazon> @hoogle bracket
04:33:32 <lambdabot> Control.Exception bracket :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c
04:33:32 <lambdabot> Control.Exception.Base bracket :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c
04:33:32 <lambdabot> Control.Monad.Catch bracket :: MonadMask m => m a -> (a -> m b) -> (a -> m c) -> m c
04:49:46 <xormor> I have Graham Hutton's Programming in Haskell the book.
05:22:24 <Psybur> Whats the best way to turn a column of a file into a vector? I dont think the constand prepending is good and i dont think its efficient to make a list and then convert to vector
05:22:58 <xenon-> hi
05:23:05 <opqdonut> Psybur: lazy lists are kind of like iterators, they are efficient in that sense
05:23:46 <xenon-> how likely is it that data fields will become methods instead of functions? by methods i mean functions that are stored in separate namespace
05:23:56 <opqdonut> Psybur: I expect something like this to be fairly efficient: Data.Vector.fromList (map getColumnValue (lines contents))
05:24:35 <stevenxl> Good morning folks.
05:24:46 <opqdonut> xenon-: your question doesn't make sense to me ... could you try rephrasing?
05:24:58 <Psybur> opqdonut, ok ill give it a shot thanks
05:25:03 <stevenxl> I am trying to find the declaration for `MonadTrans (MaybeT)` but I can't find the source. (I'm trying to compare it to my own implementation).
05:25:05 <stevenxl> I tried here: https://hackage.haskell.org/package/transformers-0.5.5.0/docs/Control-Monad-Trans-Class.html#t:MonadTrans
05:25:34 <stevenxl> But when i click on the source link I go to a page w/o mention of MaybeT.
05:25:54 <opqdonut> stevenxl: here: https://hackage.haskell.org/package/transformers-0.5.5.0/docs/src/Control-Monad-Trans-Maybe.html#line-191
05:26:13 <opqdonut> stevenxl: I clicked on MaybeT, and then on the # Source button for the instance
05:26:24 <xenon-> opqdonut . data Person { name :: String; age :: Int } <- put name into separate namespace Person. this would be an easy fix to current problem of name :: Person -> String clashing with name :: Filename -> String (just made that up but you get the point)
05:26:42 <stevenxl> @opqdonut Thank you very much.
05:26:42 <lambdabot> Unknown command, try @list
05:27:03 <opqdonut> xenon-: ah right
05:27:51 <xenon-> I think something like this was proposed a while ago
05:27:59 <opqdonut> there's some discussion about namespacing, see e.g. https://ghc.haskell.org/trac/ghc/wiki/Records/NameSpacing, but nothing you can use yet AFAIK
05:28:12 <geekosaur> you can do that, just put the data decl in a different module and always import that qualified. But it's annoying. And do you really want module and type namespaces to overlap like that?
05:28:38 <opqdonut> some people just manually prefix the type name
05:28:48 <opqdonut> like data Person { personName :: String; ... }
05:31:15 <xenon-> i do that too but i'm not a great fan of it
05:31:35 <opqdonut> yeah
05:32:21 <xenon-> I guess I could manually create module Person, but then I'd need a separate module for every data I have.. not great either
05:32:59 <MichaelBurge> If you're writing a QuickCheck instance and want to "shrink" to a simpler constructor("A String" to "B Int"), is there a better way to use "arbitrary" to generate arguments than to hardcode a seed?
05:37:26 <opqdonut> MichaelBurge: there's this thing but I've never used it.... https://hackage.haskell.org/package/QuickCheck-2.9.2/docs/Test-QuickCheck.html#t:Shrinking
05:39:57 <lyxia> MichaelBurge: derive the Int from the string?
05:40:07 <lyxia> A s -> B (length s)
05:40:26 <MichaelBurge> opqdonut: That would work, though it's a bit heavy.
05:43:06 <sulemankhalid> hi, why am I getting exception "*** Exception: Prelude.read: no parse" when I say read "True" at the ghci prompt?
05:43:42 <opqdonut> because of defaulting
05:43:48 <geekosaur> because ghci is defaulting it to type ()
05:43:49 <Geekingfrog> sulemankhalid: try `read "True" :: Bool`
05:44:03 <opqdonut> yeah
05:44:09 <geekosaur> read does not decide its type based on the String, it gets its type from how it is called and parses accordingly
05:44:12 <xenon-> why does it default to () instead of throwing ambuguity error?
05:44:20 <geekosaur> ExtendedDefaultRules
05:44:35 <geekosaur> and even without that, standard defaulting would get you Integer
05:44:59 <xenon-> that would at least be useful sometimes
05:44:59 <geekosaur> because typeclass Read is one of those that standard defaulting 'sees through'
05:45:17 <xenon-> I can't see ever wanting () Read instance
05:45:59 <saurabhnanda> does anyone know how to insert a script/src tag with Lucid?
05:47:24 <saurabhnanda> found my own issue from 9 months ago! https://github.com/chrisdone/lucid/issues/30#issuecomment-270068863
05:53:28 <stevenxl> hm.. so I ran a command `stack build scotty`. My understanding is that this will look through a series of places (local packagets, and eventually hackage) and install the package if found. How do I uninstall it?
05:55:23 <maffh> Is it possible to "map" over a tuple of arbitrary?  
05:55:28 <maffh> length
05:57:29 <lieven> since each element of a tuple has a different type, you would need to supply a corresponding tuple of functions
05:57:39 <magthe> stevenxl: AFAIU `stack install` builds and then copies executables to some local dir, ~/.local/bin on my Linux machines, and the only way to uninstall is to remove the binaries
05:58:37 <stevenxl> maffh: Not without getting fancy. Each tuple is its own type which encodes the length in teh type itself. (a, a)  is a different type than (a, a, a)
05:58:41 <stevenxl> Because of the size.
05:59:18 <stevenxl> magthe: thanks. i know where on my machine they are. I wonder if I can clean them out and not have stack break on me. (I'm fine if it has to re-download stuff).
05:59:43 <stevenxl> maffh: That's very much unlike a list, which doesn't mention the size at the type level. [a] can be empty or infinite.
05:59:49 <fakenullie> magthe: where do you get those tuples from?
05:59:50 <stevenxl> or anything in between
05:59:53 <lyxia> maffh: one-liner gives you the Generic stuff for that
05:59:56 <xenon-> doesn't lens have a function that "maps" over tuples of length up to 9 or so
06:00:16 <xenon-> s/function/lens|whatever
06:00:34 <tdammers> stevenxl: deleting ./.stack-work in a stack project, or ~/.stack/global-project for things installed outside a project should do the trick
06:00:55 <lyxia> (\f -> gmap @((~) a) f) :: (a -> a) -> (a,a,a,a) -> (a,a,a,a)
06:01:09 <lyxia> It doesn't allow the type to change yet
06:01:33 <stevenxl> tdammers: thanks. I'll do that. There are others directories too which I see take up a lot fo space. I shouldn't have gotten a 120gb mac.
06:01:34 <stevenxl> :-(
06:02:05 <maffh> That's too bad:(
06:02:12 <maffh> But thx for the tips:)
06:02:22 <tdammers> stevenxl: there's a few others that you can clean out, I think
06:02:39 <stevenxl> tdammers: yea. if it breaks jsut a change to learn more
06:02:41 <stevenxl> ;-)
06:03:09 <tdammers> stevenxl: I think the only thing you'll want to keep is config.yaml, everything else can be rebuilt as needed
06:03:15 <maffh> The types of the tuple are also arbitrary. Because I need something like this: mapTuple :: (a -> b, a -> c, a -> d) -> a -> (b,c,d)
06:03:15 <maffh> mapTuple (b,c,d) a = (b a, c a, d a)
06:03:15 <maffh> mapTuple' :: (a -> b, a -> c, a -> d, a -> e) -> a -> (b,c,d, e) mapTuple' (b,c,d, e) a = (b a, c a, d a, e a)
06:03:23 <stevenxl> tdammers: perfect. just what i wanted to hear. 
06:03:24 <stevenxl> thank you
06:03:43 <tdammers> .stack/programs is probably a good candidate too; that's where all those ghc versions are installed to
06:04:18 <tdammers> at some point I had about 20 versions in there
06:06:03 <byorgey> maffh: you could write   ((,,) <$> b <*> c <*> d) (x,y,z)
06:06:20 <byorgey> maffh: but it sounds to me like you might want to make a new data type instead of using a tuple anyway.
06:06:36 <byorgey> anything above 2-tuples is fairly suspect.
06:06:51 <tdammers> byorgey: easy, just nest 2-tuples as needed
06:07:04 <tdammers> (a, (b, (c, (d, (e, Void)))))
06:07:07 <byorgey> i.e. if you have more than 2 things together, you should package them up into a semantically meaningful data type.
06:07:19 <byorgey> oh, shush =)
06:07:54 <opqdonut> surely not Void
06:08:04 <tdammers> >:->
06:08:18 <tdammers> but, yeah, you probably want () there
06:08:18 <magthe> stevenxl: yes, removing the binaries shouldn't break anything... I'm fairly sure of it :/
06:08:23 <lieven> tdammers: what lens operator is that?
06:08:30 <byorgey> quick, what is  2 * 3 * 9 * 206 * 23 * 99 * 143 * 0 ?
06:08:40 <opqdonut> hah
06:09:23 <John882> lol
06:10:24 * hackagebot network-transport-tests 0.2.4.2 – Unit tests for Network.Transport implementations – https://hackage.haskell.org/package/network-transport-tests
06:10:24 * hackagebot distributed-process-tests 0.4.11 – Tests and test support tools for distributed-process. – https://hackage.haskell.org/package/distributed-process-tests
06:11:26 <tdammers> byorgey: just don't ever try to evaluate it fully
06:11:29 <stevenxl> magthe: cool. thank you
06:11:36 <maffh> byorgey: Thanks, I think you're right, and that I should define a new data type instead of using a  n-tuple. 
06:12:09 <tdammers> > fst . snd $ ((1, (2, (3, undefined))) :: (Int, (Int, (Int, Void))))
06:12:11 <lambdabot>  2
06:12:14 <tdammers> no problem
06:13:26 <LKoen> tdammers: are the parentheses redundant with the $ here?
06:13:33 <LKoen> aren't
06:14:49 <ongy> try it
06:14:59 <hexagoxel> mildly certain that you can't do it with lens. you cannot even write the type without hlist stuff.
06:17:07 <hexagoxel> "HList ts -> x -> HMap (HApply x) ts" or something in that direction
06:17:24 <stevenxl> https://www.irccloud.com/pastebin/KlRtptCe/MonadTrans
06:17:42 <stevenxl> Is there a more idiomatic way to write teh above instance of MonadTrans for EitherT?
06:18:55 <EvanR> is EitherT different at all from ExceptT
06:19:22 <stevenxl> EvanR: I don't think so. I'm going through the Haskell Book and I **think** they said no.
06:19:41 <EvanR> peachy
06:19:41 <Cale> lift x = EitherT (fmap Right x)
06:20:20 <stevenxl> ahh - dang. ok thank you. I can see that. Lift right over the monad structure.
06:20:22 <stevenxl> I like it.
06:20:27 <stevenxl> thank you @Cale 
06:21:01 <Cale> I'd also be tempted just to write it out with do-notation.
06:21:15 <Cale> lift x = EitherT $ do
06:21:17 <Cale>   v <- x
06:21:21 <Cale>   return (Right v)
06:22:07 <stevenxl> Yea. I like the non-do versioin better but I think that's a personal preference. The good thing is that I understand both of those alternatives, so maybe stuff is clickign.
06:22:13 <Cale> But in a definition which is as unchanging as this one, it's perhaps nicer to choose the more points-free form.
06:22:37 <hexagoxel> is there a maintained HList library ?
06:24:55 <moneypower> hellooo guys........
06:24:56 <Cale> stevenxl: One thing I've noticed in real-world codebases, is that if you grep the code for occurrences of >>= and then ignore anything which is followed by \case (as that's a reasonable idiomatic usage), most of what's left will be terrible code. :)
06:26:15 <moneypower> helo cale..can you tell me this irc channel is for what??
06:26:39 <Cale> moneypower: Discussion of the functional programming language Haskell.
06:26:41 <stevenxl> @Cale so you are suggesting that whenever I do that on my own, I should us it as an indication that there is likely a better way. 
06:26:42 <lambdabot> Unknown command, try @list
06:27:01 <stevenxl> because i'm doing it right now with StateT. 
06:27:14 <Cale> stevenxl: Well, when you're starting out, it's sometimes helpful to see things written out that way, but usually you want to actually use do-notation
06:27:21 <stevenxl> OK. 
06:27:30 <Cale> and then most of the rest of the time =<< is going to be more readable at least
06:27:34 <stevenxl> That's very helpful. Yes I want to get the semantics first and then I can refactor it.
06:28:30 <Cale> So, for example,  lift m = EitherT $ pure . Right =<< m  as a very minimal change is probably slightly easier to read than what you had (at least I think so)
06:29:11 <Cale> but then whenever you have  return . f =<< x  or  pure . f =<< x  you can always replace that by  fmap f x
06:30:10 <Cale> >>= is only nicer if your continuation (the second argument) is long, but if it is long, then do-notation is probably better
06:30:55 <stevenxl> OK I hear you. Yea I still don't have those ideas down yet. I use fmap when the exercises are in the fmap chapter, but I still don't recognzie when to use it "in the wild", if you get my drift. I'm hoping that comes with time as I leave Haskell Book and start writing real world code.
06:31:55 * hackagebot fastparser 0.3.1 – A fast, but bare bones, bytestring parser combinators library. – https://hackage.haskell.org/package/fastparser
06:33:01 <ertes-w> stevenxl: you named a result 'x', but you're consistently using a modified result (f x)
06:33:14 <ertes-w> stevenxl: do x <- c; … f x …
06:33:41 <ertes-w> stevenxl: that's when you use fmap:  do y <- f <$> c; … y …
06:33:42 <EvanR> does fastparser take memory proportional to the input size
06:33:53 <EvanR> like attoparsec
06:34:19 <ertes-w> stevenxl: a common special case: (do x <- c; pure (f x)) = f <$> c
06:34:23 <kahlil29> In Opaleye, I want to have a dummy restrict (for the Nothing case of my case-match ). What would give me a true of type PGBool ? https://hackage.haskell.org/package/opaleye-0.6.0.0/docs/Opaleye-PGTypes.html#t:PGBool
06:34:34 <EvanR> fmap f c
06:34:56 <EvanR> easier on the wrists ;)
06:34:56 <stevenxl> ertes-w: Hm... that's exactly what I am seeing now. thanks.
06:35:15 <Cale> There's this continuum between on the one hand making everything points-free, tidily avoiding naming any intermediate results, and avoiding case expressions in favour of other combinator functions, and on the other hand, naming all the intermediate results and using lots of explicit do, let and case
06:37:11 <Cale> Code which is subject to later change, you'd often prefer the latter style, because it's like all the wiring is exposed, so it's somewhat easier to modify things. Also, whenever there's an opportunity to name an intermediate result meaningfully, that can be useful documentation.
06:37:55 <Cale> However, there are also obvious advantages to the former style -- it's often easier to see that it's correct, or to manipulate it algebraically with laws.
06:38:21 <mnoonan> I have some AST manipulating code that is built on an F-algebra, so that I can uniformly do things like attach metadata to nodes, punch out holes in an AST, etc. I want to put a link to a simple introduction to F-algebras and perhaps recursion schemes. Any suggestions?
06:40:05 <mnoonan> Bartosz's stuff would be too abstract for the intended audience, probably
06:40:31 <Cale> There is probably some early functional pearl, but I don't have a reference off hand
06:40:43 <ertes-w> i tend to gravitate toward the former style…  it's quite easy to read after some training
06:41:05 <ertes-w> in fact now i find the latter style harder to read, because if everything is named, i need to keep track of those names
06:41:20 <ertes-w> whereas with the former it's pure data flow patterns
06:41:39 <stevenxl> All good stuff folks. I tried to put it into practice here: 
06:41:45 <stevenxl> https://www.irccloud.com/pastebin/6xERoV6o/
06:41:58 <ertes-w> mnoonan: the 'recursion-schemes' library might have some references
06:42:01 <graperoot> is there a better way to use fonts in gloss than this ?
06:42:03 <graperoot> http://lpaste.net/4910455664502898688
06:42:03 <stevenxl> which was incorrect because of the `mempty`.
06:42:10 <stevenxl> i was throwing away data.
06:42:36 <Cale> ertes-w: It really depends on what sort of code you're writing. For stuff that is likely to be written once and then never again modified because it is correct, I totally agree.
06:43:06 <ertes-w> Cale: even for that i wouldn't go fully with the latter
06:43:16 <ertes-w> but rather a compromise between the two
06:43:27 <stevenxl> Time for day-job. Thanks again.
06:44:05 <Tuplanolla> From a Day job to a day job.
06:44:26 <Cale> mnoonan: There's this, but it's not quite what you're looking for http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.101.4131&rep=rep1&type=pdf
06:47:01 <ertes-w> mnoonan: originally i wanted to write a full-blown F-algebra tutorial, but it was a lot of work, so i went with a foldr tutorial instead…  i might revisit this some day
06:47:40 <mnoonan> yeah, I wish I could remember the resources that helped me "get it" the first time around.
06:48:09 <mnoonan> (and hopefully my path to understanding didn't depend on "1.) get a PhD in mathematics")
06:55:53 <mantasg> Hi guys. Is it possible to somhow rewrite requestBody of WAI Request on the way in ? (as a Middleware or smth)
07:03:24 <brynedwards> mantasg: There's middleware in wai-extra to rewrite request path and queries, I'd say you could use the code from it to write your own middleware, it looks simple enough
07:03:44 <brynedwards> mantasg: here is the middleware from wai-extra https://hackage.haskell.org/package/wai-extra-3.0.20.0/docs/Network-Wai-Middleware-Rewrite.html
07:04:02 <tdammers> request body is a bit trickier because it is provided in a streaming fashion
07:04:25 <mantasg> Yep, 
07:04:29 <brynedwards> oh right, sorry
07:04:31 <mantasg> Rewrite takes in: PathsAndQueries -> RequestHeaders -> PathsAndQueries
07:05:12 <mantasg> Basically the reason I want to do this is to allow gzipped request body to be passed on to Servant
07:05:31 <mantasg> So I want to decompress and rewrite the body
07:05:52 <mantasg> Ideally I'd do that at reverse proxy level, but Nginx doesn't seem to do that out of the box
07:06:05 <tdammers> still possible with middleware, but a bit trickier
07:06:44 <mantasg> tdammers do you by that mean some custom middleware or something that already exists?
07:06:59 <tdammers> mantasg: no, I've just been fiddling with wai middlewares a lot
07:07:33 <tdammers> essentially you would have to dig into the request data structure and wrap the request body accessors so that the request body gets unzipped as you read it
07:08:17 <mantasg> tdammers thanks, that pretty much confirms my suspicions
07:11:55 <brynedwards> :r
07:13:15 <shapr> brynedwards: my brain reloaded, happy now?
07:13:20 <brynedwards> :D
07:14:08 <brynedwards> using tmux to script stuff isn't very reliable...panes can only be referenced by number so closing and reopening panes messes up stuff and sends commands to random windows
07:14:47 <shapr> huh, I use byobu, but all my Haskell things happen in emacs
07:16:41 <brynedwards> I'm using kakoune which tries to use other unix tools like tmux etc...in practice it can be a bit finicky...
07:18:04 <ertes-w> why don't you just use your window manager?
07:19:31 * hackagebot derive-storable 0.1.1.1 – Derive Storable instances with GHC.Generics. – https://hackage.haskell.org/package/derive-storable
07:19:44 <brynedwards> I have to use Windows so I do development in a linux VM with putty. Otherwise I'd use xmonad of course
07:20:43 <ertes-w> in that case work on the "have to use windows" part =)
07:21:04 <shapr> brynedwards: that sounds frustrating
07:21:09 <ertes-w> BTW, windows works just fine in a VM
07:21:21 <shapr> hi cement !
07:21:36 <cement> yeah, sorry we couldn't make it
07:21:44 <shapr> no worries
07:21:49 <Big_G> Is there a traditional way to have Succ loop around when deriving Enum?
07:21:51 <shapr> come on down next week or the week after
07:23:15 <Big_G> If I had "data Direction = North | East | South | West deriving (Enum, Show)", how do I make succ West = North
07:24:04 <ertes-w> Big_G: 'succ' is *expected* to fail after maxBound
07:24:29 <ertes-w> Big_G: unless you don't have a Bounded instance
07:24:34 <Big_G> Is there a version of succ that doesn't?
07:24:44 <ertes-w> Big_G: (+)
07:24:58 <Big_G> Ah. Is that something that can be derived?
07:25:07 <ertes-w> yes, but not for your type
07:25:19 <ertes-w> you could define a modulo 4 ring over it, but it's kinda arbitrary
07:25:20 <Big_G> So I have to manually input all the steps?
07:25:39 <ertes-w> you can write a variant of 'succ' that loops
07:26:04 <ertes-w> @let cyclicSucc x | x == maxBound = minBound | otherwise = succ x
07:26:06 <lambdabot>  Defined.
07:26:06 <Big_G> but I'd have to do that manually with pattern matching on all four cases?
07:26:22 <Big_G> Ah, that's much more convenient
07:26:26 <ertes-w> > iterate cyclicSucc (250 :: Word8)
07:26:28 <lambdabot>  [250,251,252,253,254,255,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,2...
07:27:41 <Big_G> Are there any laws that use that exceptional property of succ or is it just highly recommended?
07:27:55 <ertes-w> Big_G: it's a law
07:28:01 <ertes-w> https://hackage.haskell.org/package/base-4.10.0.0/docs/Prelude.html#t:Enum
07:28:32 <ertes-w> not sure what the rationale behind it is, but it's there
07:29:10 <merijn> It's awful, yes
07:30:16 <merijn> Anyone aware of a project that uses cabal.project for using multiple packages in the same repo with a Travis CI setup (other than cabal)?
07:31:37 <ezyang> https://github.com/int-index/slay/ 
07:33:13 <merijn> ezyang: hmm, that only builds with 1 ghc version, no? I'm trying to figure out how to make hvr's multi-ghc thingy play nice with cabal.project
07:33:38 <merijn> I think cabal does that, but cabal's travis config is way to fucking complicated for me
07:34:00 <ezyang> merijn: Why doesn't setting up a Travis matrix DTRT 
07:34:49 <merijn> ezyang: The multi-ghc travis script nukes cabal.project and doesn't test sdist for different packages
07:35:41 <ezyang> what I am saying is, it's not that difficult to do multi-ghc by hand 
07:36:21 <merijn> ezyang: I was hoping someone had already done that so I can crib what they wrote. Especially since the documentation of the travis.yml is atrocious
07:36:51 <merijn> (I mean travis' documentation on what's in there) so I don't understand what half the stuff produced by multi-ghc-travis does
07:37:15 <merijn> Which means I don't really feel confident modifying it
07:38:13 <merijn> ezyang: Also, I asked in #hackage, but the cabal.project format's parser isn't in a library I can use, is it? I figured I might as well fix the multi-ghc script if I figure out what to change
07:40:19 <ezyang> I'm guessing, multi-ghc doesn't work because it assumes it's only building a single package? 
07:40:36 <merijn> ezyang: Yeah
07:41:32 <merijn> It mostly works since "new-build all" and "new-test" all do the right thing, but some things still need to be tests per package (i.e. sdist)
07:42:10 <merijn> But that means looping over all packages, which involves somehow extracting them from cabal.project
07:43:10 <merijn> (which involves grabbing a list of all packages, hence my cabal.project parsing question)
07:43:24 <merijn> I can probably just "grep" to get the info from cabal.project, but that's rather hacky
07:44:46 <scones> I suspect the replies to this question might be a little like drinking from a firehose, but here it goes.  Presently, I can write in Java, Python, with a smattering of other languages basics, but I'd like to learn Haskell.  Is there a book or three that the community seems to recommend for this purpose?
07:44:55 <tinytusk> Hi. I noticed that there are packages like lifted-base and lifted-async which serve to generalize the Monad in which the respective library operates. If you are writing a *new* library, should you make it general by default?
07:45:45 <merijn> scones: Richard Bird's book has gotten good recommendations, same for haskellbook.com although I disagree a bit with the order things are introduced in that
07:45:56 <hexagoxel> merijn: as for hacky solutions, just looking for **/*.cabal might be more reliable (excluding dist-newstyle)
07:46:36 <merijn> hexagoxel: Yeah
07:48:23 <scones> merijn: Interesting.  Thanks!  Definitely looking for hard copies to get the foundation.  For whatever reason that seems to be the best medium for me to establish a foundation.
07:48:40 <hexagoxel> cabal does not have the equivalent of `stack ide targets` yet, either, it seems :(
07:49:51 <ezyang> merijn: I still maintain that doing it from scratch will be easiest, but I'm sorry I can't think of a multiple package project with multiple GHC versions off the top of my head 
07:50:08 <brynedwards> hexagoxel: At least cabal can actually build specific components/targets :P
07:50:16 <ertes-w> scones: graham hutton's "programming in haskell" also received very good reviews
07:50:29 <saurabhnanda> does anyone know how to guide the compiler to pick a specific type while using ExtendedDefaultRules?
07:50:42 <saurabhnanda> ...which would prevent the verbose warning as well
07:50:47 <ertes-w> @where pih
07:50:47 <lambdabot> I know nothing about pih.
07:51:48 <merijn> ezyang: Yeah, but I was hoping to avoid having to wade through the mess that is Travis' documentation. Oh well...
07:52:14 <ertes-w> scones: if you'd prefer a more immediate and hands-on experience, check this one out: https://www.cis.upenn.edu/~cis194/
07:53:24 <scones> ertes-w: Cool.  Thank ya much!
08:02:24 <iqubic> What's the best framework for drawing and exploring fractals?
08:05:08 <saurabhnanda> is there any way to un-import some stuff in GHCi?
08:05:38 <hexagoxel> :m -My.Module
08:14:12 <ertes-w> iqubic: drawing as in live rendering?
08:16:34 <ertes-w> iqubic: gloss-raster is an easy to learn library for displaying and interacting with pixel graphics…  if you need lower-level control or better (control over) performance, there is sdl2
08:17:13 <iqubic> ertes-w: Drawing as in just displaying simple geometric shapes and pixels
08:19:48 <saurabhnanda> hexagoxel: thanks
08:20:26 <nso_> there's something like `data IOResult = Done | Error String`?
08:21:11 <ertes-w> iqubic: the gloss library lets you draw shapes, optionally textured
08:21:26 <ertes-w> iqubic: drawing "pixels" in such a framework amounts to drawing little circles or squares
08:21:34 <iqubic> I'll have to look into that.
08:21:48 <iqubic> ertes-w: Yeah, I figured pixels would be like that.
08:21:51 <ertes-w> nso_: you could use IO exceptions
08:22:29 <ertes-w> iqubic: if you want to draw actual pixels, as in drawing into a discrete video buffer, then you need gloss-raster, but i believe you can't mix the two
08:22:47 <iqubic> No. I'm fine with just gloss.
08:23:32 <ertes-w> iqubic: if you need more than gloss, you should probably look into sdl2 anyway, perhaps with OpenGL…  but both of them have a learning curve
08:23:46 <ertes-w> gloss is super-easy
08:23:59 <iqubic> ertes-w: I might need that in the future, but I'm fine with gloss right now.
08:24:07 <iqubic> glguy: Are you around?
08:26:50 <jle`> nso_: looks like `Maybe String` to me
08:27:27 <jle`> or Either String ()
08:27:51 <bolver> return [1..3] gives [1,2,3], but [5] : return [1..3] gives [[5], [1,2,3]].  why does return behave differently in the two cases?
08:27:58 <nso_> jle`: yep but at the end I'm going to use IOException
08:28:20 <monochrom> No, [5] behaves differently from 5
08:28:20 <phadej> bolver: because it's different `return` :: a -> IO a, and a -> [a]
08:28:30 <phadej> you are using GHCi and tricked by that fact
08:28:34 <jle`> bolver: return [1,2,3] is f [1,2,3], for some Monad f
08:28:41 <jle`> it's not [1,2,3]
08:28:45 <jle`> :t return [1,2,3]
08:28:46 <lambdabot> (Num a, Monad m) => m [a]
08:29:01 <jle`> sorry, f [a]
08:29:14 <jle`> return :: Monad m => [Int] -> m [Int]
08:29:38 <jle`> bolver: return is "polymorphic"
08:29:47 <jle`> > return [1,2,3] :: Maybe Int
08:29:50 <lambdabot>  error:
08:29:50 <lambdabot>      • Couldn't match type ‘[Integer]’ with ‘Int’
08:29:50 <lambdabot>        Expected type: Maybe Int
08:29:51 <bolver> jle`: i am not quite sure what are trying to tell me
08:29:56 <jle`> > return [1,2,3] :: Maybe [Int]
08:29:58 <lambdabot>  Just [1,2,3]
08:30:09 <jle`> bolver: i'm telling you that return [1,2,3] is definitely *not* [1,2,3]
08:30:22 <jle`> what makes you believe that it is?
08:30:32 <bolver> jle`: but that's what it gives for me
08:30:37 <jle`> what is 'it' ?
08:30:37 <ertes-w> jle`: the confusing way GHCi defaults monads
08:30:43 <Cale> jle`: Because ghci is running the IO action
08:30:46 <jle`> are you writing haskell source files?
08:30:49 <jle`> are you using ghci?
08:30:52 <bolver> ghci
08:30:54 <Cale> and then printing the result immediately
08:30:54 <jle`> are you asking someone?
08:31:06 <ertes-w> bolver: try this:  return [1,2,3] :: [[Integer]]
08:31:09 <bolver> i am using ghci
08:31:11 <jle`> bolver: ah, okay.  yeah, ghci interprets `return [1,2,3]` as return :: a -> IO a
08:31:20 <jle`> at least the way you're using it
08:31:31 <bolver> jle`: ok, that makes sense
08:31:37 <jle`> it gives the no-op IO action that only produces [1,2,3] and does nothing else
08:31:42 <Cale> bolver: ghci will try to interpret your input as an IO action, and if it succeeds at that, will execute the IO action and, in addition to whatever effects it has, also print its result
08:31:50 <jle`> but 'return' is polymorphic, it works for any Monad instance
08:32:01 <jle`> > return [1,2,3] :: Maybe [Int]
08:32:02 <bolver> Cale: ok
08:32:03 <lambdabot>  Just [1,2,3]
08:32:06 <jle`> > return [1,2,3] :: [[Int]]
08:32:08 <lambdabot>  [[1,2,3]]
08:32:16 <jle`> > return [1,2,3] :: Either Bool [Int]
08:32:18 <bolver> jle`: i see
08:32:19 <lambdabot>  Right [1,2,3]
08:32:25 <Cale> bolver: In this case, when presented with return [1,2,3], it's regarding that as the IO action which does nothing except to produce [1,2,3] as its result, executing it, and then printing the result, which is [1,2,3]
08:32:35 <jle`> in the second example, type inference says that return :: [Int] -> [[Int]]
08:32:37 <bolver> Cale: i see
08:32:47 <bolver> jle`: yes, correct
08:32:50 <Cale> But return [1,2,3] itself isn't [1,2,3], it's simply the result of the no-op IO action which was built.
08:33:08 <jle`> because you're using it somewhere haskell expects a list, so type inference tells haskell that the return you're using is the return :: a -> [a] one
08:33:14 <bolver> Cale: what is this no-op?
08:33:18 <ertes-w> bolver: as a beginner you should always question the type of what you're writing, and with the ':t' command GHCi will happily tell you the type
08:33:22 <ertes-w> :t return [1,2,3]
08:33:23 <lambdabot> (Num a, Monad m) => m [a]
08:33:32 <bolver> ertes-w: i very much did
08:33:47 <bolver> ghci type info by the way didn't give a damn clue
08:34:05 <jle`> an 'IO a' describes an IO action that produces an 'a'
08:34:13 <ertes-w> bolver: now you can't run/evaluate polymorphic code like that, because GHC actually needs to know which 'm' and which 'a' you mean, because that will determine the exact semantics
08:34:18 <jle`> so an IO String might describe an IO action that produces a string, like getting something from stdin, maybe
08:34:32 <jle`> 'return x :: IO a' is the *no-op* IO action...the IO action that does nothing
08:34:33 <ertes-w> bolver: now for your convenience GHC defaults 'a' to Integer and 'm' to IO
08:34:42 <bolver> ertes-w: i see
08:34:53 <ertes-w> bolver: this is *usually* a convenience, but if you don't know that, it may be very confusing =)
08:34:54 <bolver> jle`: i see
08:34:59 <jle`> if you're familiar with assembly, 'return x' is analogous to NOP
08:35:10 <bolver> ertes-w: yeah it was
08:35:52 <bolver> jle`: i am rather young, you know ... i don't write assembly code :)
08:36:09 <jle`> just trying to grasp for a potential connection/analogy :)
08:36:31 <shapr> I think tweens are old enough for assembly!
08:36:47 <earthy> definitely
08:36:53 <bolver> shapr: may be, but i am not
08:37:01 <ongy> tween? 20+?
08:37:14 <jle`> maybe < 13?
08:37:28 <bolver> yeah, jle`, ertes-w, Cale -- thanks for the help indeed
08:37:46 <shapr> bolver: yeah, lots of things I've still not learned, and I'm only in my twenties in hexadecimal :-P
08:37:50 <jle`> np
08:38:08 * shapr hops cheerfully
08:38:10 <shapr> yay Haskell!
08:38:32 <bolver> shapr: good for you ... be careful though ... you may want to remain young for a looong time
08:38:56 <ongy> shapr: would it be obvious hex? or still < 2a?
08:38:56 <shapr> There's a nurse who started coming to my weekly Haskell meetup, he's decided to learn programming with Haskell!
08:39:05 <shapr> He's on chapter 3 of haskellbook.com, and having lots of fun
08:40:00 <nicknight> shapr: How Haskell useful to nurses ? May be Datascience more useful ? I guess
08:40:18 <jle`> nicknight: presumably the same parts of haskell that are useful to all human beings
08:40:19 <shapr> nicknight: he does want to take the data science direction, in Haskell
08:40:41 <ongy> automate simple tedious tasks. you'd be surprised how much you could optimize some things with simple scripts
08:41:04 <bolver> one more question ... one evasive thing about haskell is the thunk-build up and space leaks ... i read somewhere they are trying to improve GHC to minimize this stuff.  do you know if that work is still on?
08:41:24 <shapr> the answer to that is large
08:41:31 <ongy> my mom and brother (ab)use excel a lot at work, and impress their coworkers with simple things. imagine someone who knows haskell
08:41:35 <nicknight> I wish someone find a way to predict glaucoma...may be nureses/doctors like him can dit soon
08:41:36 <shapr> bolver: I can feel the thunks building as I formulate an answer :-P
08:41:44 <Athas> bolver: That's just strictness analysis, isn't it?
08:41:58 <bolver> shapr: that was a gooood one from you
08:42:07 <Athas> GHC already does a lot of it, but it's hard.  I'm not sure whether anyone is presently working on making it significantly better.
08:42:26 <shapr> bolver: but seriously, a recent thing is that you can make a whole module strict: https://ghc.haskell.org/trac/ghc/wiki/StrictPragma
08:42:48 <bolver> Athas: no, no ... strictness analysis is old daddy lying around in GHC ... i am talking about a paper by SPJ on optimistic evaluation
08:42:51 <shapr> but I find it easier to write non-strict code, and mark data strict where I need it.
08:43:01 <jle`> you could already make a whole module strict.  -XStrict just makes it more syntactically convenient
08:43:14 <shapr> bolver: oh, that was the spec_eval fork of ghc, I think that ran out of interest
08:43:21 <shapr> bolver: I assume you mean the paper/thesis by Robert Ennals?
08:43:34 <bolver> shapr: why write code in a lazy language when you finally end up making everything strict?
08:43:42 <bolver> shapr: yes
08:43:46 <jle`> haskell's benefits come from more than just its laziness :O
08:43:47 <nicknight> shapr:  but I did a lot of research for couple of days eventhough Haskell is very good datascience not popular or no way will be popular with haskell I feel due to heavy community ofpython/r/matlab and kid julia 
08:43:59 <jle`> the main benefit of haskell for me comes from the type system
08:44:05 <jle`> its expressivity
08:44:18 <jle`> and its ease of refactoring and maintainability, its correctness
08:44:25 <shapr> nicknight: I know people who do use Haskell for data science, and I know the drawbacks of writing code in Python.
08:44:28 <jle`> and how the type system guides you as you write your code to make writing code really easy
08:44:34 <shapr> yeah, what jle` says
08:44:41 <bolver> jle`: i want to write code in haskell and not worry all the time about space leaks
08:44:43 <jle`> only a small portion of my benefit of using haskell comes from laziness
08:44:56 <jle`> bolver: i don't worry about space leaks too often when i'm writing haskell
08:45:02 <shapr> nicknight: I am often frustrated by Python code where parts could not possibly have ever worked, but they weren't tested or type checked.
08:45:27 <jle`> but you asked why you would write in a lazy language just to make everything strict...the answer is that laziness is only one small part of the benefits
08:45:46 <shapr> nicknight: R-style data frames are available in Haskell: https://github.com/acowley/Frames
08:45:55 <shapr> IHaskell lets you do Haskell inside jupyter
08:45:59 <bolver> jle`: if you read SPJ's paper, you will see that he recognizes space leaks as one key reason that puts off beginners in haskell
08:46:15 <jle`> sure, i'm not arguing about that
08:46:18 <jle`> i'm just answering your question
08:46:27 <jle`> about why someone would write code in a lazy language and finally make everything strict
08:46:28 <phadej> bolver: for me it thinks, that's anylsis paralysis "i don't dare to write Hasksell, because it will be full of space leaks"
08:46:41 <jle`> that's like asking why someone would eat an apple only to not eat the skin
08:46:50 <jle`> the skin is nice, but the rest of the apple is probably the main reason why it's good
08:47:02 <bolver> phadej: i am sorry i have to dismiss your conclusion entirely
08:47:07 <jle`> or asking why someone would eat an egg without eating the egg white
08:47:19 <jle`> the entirety of the egg is nice, and you get benefits even if you only eat the yolk
08:47:22 <shapr> bolver: try it, I think laziness will rarely cause problems.
08:47:59 <bolver> shapr: i have tried it ... just take a look at the number of questions on space leaks in stackflow
08:48:00 <jle`> bolver: you're talking to people who write haskell every day, and some who owrite it professionally
08:48:10 <jle`> not to beginners
08:48:15 <shapr> bolver: what problems have you had with laziness?
08:48:27 <dsal> The first time I noticed laziness was when I tried to do something that I expected to take four cores and it only took one.
08:48:58 <bolver> jle`: i am talking about people like myself trying to pickup haskell
08:49:29 <bolver> i am not here to question anyone's expertise
08:49:33 <shapr> bolver: I don't think laziness is much of an issue for beginners, I think an imperative mindset is a much larger obstacle for most.
08:49:52 <jle`> bolver: i'm just suggesting that you consider phadej's conclusion without dismissing it
08:49:55 <saurabhnanda> what's an efficient way to replace a substring inside a lazy-bytestring with another lazy-bytestring?
08:50:01 <shapr> bolver: also, the rare times laziness has bitten me, I was able to fix it, or get a quick solution here on #haskell
08:50:09 <jle`> bolver: consider an analogous argument with performance in C
08:50:21 <jle`> look how many questions on stack overflow are about why someone's C/Java code is slow
08:50:34 <jle`> am i going to not write C because of the potential for slow code?
08:50:44 <bolver> shapr: that's because i guess, in addition to being rather young, you are probably a haskell expert :)
08:51:08 <shapr> bolver: ha, I'm not sure I qualify as either, but you too can become as much an expert as I am by spending time here learning and asking questions.
08:51:21 <EvanR> reason not to use haskell: it's too hard i dont get it. reason to use haskell anyway: IRC can fix any issue
08:51:26 <jle`> it's possible to write leaky code in haskell, but it's also possible to write leaky code or slow code in C, java, python, etc. as well
08:51:26 <shapr> yeah!
08:51:31 <bolver> jle`: i don't write c because i don't want to worry about pointers and manula memory allocation
08:51:36 <EvanR> this doesnt look like a good balance, objectively speaking
08:51:46 <nicknight> shapr: Sorry  disconnected I read you last line about using haskell in jupyter
08:51:52 <jle`> bolver: any code you write in any language, when you start out, will have potential issues
08:52:00 <jle`> bolver: that's just the nature of learning
08:52:05 <monochrom> Haskell is a premium language.
08:52:11 <shapr> nicknight: that's all I said about data science in Haskell, have you tried doing data science in Haskell?
08:52:16 <jle`> bolver: for haskell, you might struggle with space issues at first.  for other languages, it'll be performance issues or maybe even other space issues
08:52:18 <bolver> jle`: but you are NOT answering my question
08:52:24 <shapr> what is the exact question?
08:52:32 <bolver> i am not here to criticize haskell
08:52:42 <EvanR> monochrom: it costs extra?
08:52:48 <monochrom> Yeah!
08:52:51 <EvanR> lol
08:52:58 <jle`> i did answer one question, about why someone would write in a lazy language but use strictness eventually ;_;
08:53:02 <bolver> i am only asking if you are aware of any further work going on in GHC based on SPJ's paper
08:53:11 <nicknight> shapr:  but on resume for data science with haskell and octave can impress interviewers? I have to learn haskell to do data sciece in haskell
08:53:32 <shapr> I'm not sure, I think I usually talk most interviewers into hiring me.
08:53:50 <shapr> bolver: I don't know of any further work on the spec_eval branch Robert Ennals wrote.
08:53:51 <nicknight> shapr:  Your primary language Haskell?
08:54:00 <EvanR> haskell needs to be a compile time flag on the resume
08:54:09 <EvanR> include it or not depending on the audience
08:54:14 <shapr> nicknight: er, I don't know. I usually get paid to write Python. But I can write other languages too.
08:54:15 <monochrom> haha
08:54:16 <dsal> nicknight: are you concerned that learning things may not help you get a job?  I find learning things always helps me.
08:54:31 <nicknight> shapr: but how to you take advantages of deeplearning librararies like theano,tensorflow etc?
08:54:34 <bolver> as far as i know, that whole business of "optimistic evaluation" fizzled out in GHC
08:54:49 <shapr> nicknight: https://github.com/tensorflow/haskell
08:54:56 <monochrom> Oh optimistic evaluation fizzled out everywhere in the world.
08:55:18 <shapr> and we were so optimistic about it :-/
08:56:00 <nicknight> dsal:  I agree to you....but I heard learning haskell first can help but haskell I  feel a bit risk coming to industry
08:56:01 <EvanR> two optimistics cancelled out and became a neutral? is this the group with 2 elements
08:56:45 <dsal> nicknight: fear of learning is a risk. I don't see how learning can be a risk.
08:57:04 <nicknight> dsal:  aesome quote :) Thanks
08:57:11 <monochrom> My friend did a MSc thesis on optimistic auto-parallelization for Java. So, every method call is run in a new thread and of course there are proper locks in place. And of course for most code it degenerates to sequential execution plus locking overhead. So, no a great idea. But it's OK for an MSc thesis to say "we implemented this for real and we showed that it doesn't work out"
08:57:12 <dsal> If everyone doing a thing is doing it one way, the person who knows to ways has an advantage.
08:57:57 <dsal> s/to/two/
08:58:15 <blackdog> shapr: i think part of the problem is that when performance matters, it really matters - it's why you sometimes end up checking Core to see if fusion rules fired
08:58:25 <bolver> monochrom: i am not surprised ... these days you see a lot of that
08:58:52 <blackdog> if you don't know whether optimistic evaluation speeds things up in your inner loop, an average speedup is no good. you need guarantees.
08:58:59 <shapr> blackdog: yeah, fair point. But for learning, I don't think that's even on the horizon.
08:59:38 <shapr> blackdog: you visiting the southeast anytime soon?
09:00:29 <blackdog> shapr: ya agreed
09:00:32 <Athas> monochrom: also sounds like the first experiments with parallel Haskell!
09:00:52 <blackdog> no current plans. i'm starting a new job next week, so no pleasure trips for a while.
09:01:56 * hackagebot hslua-aeson 0.3.0.1 – Allow aeson data types to be used with lua. – https://hackage.haskell.org/package/hslua-aeson
09:06:34 <nicknight> shapr: dsal why I am so concerned is right now I am into support role in an office I wanted to apply for developer poistion mostly into data science...I am very good with maths but now implementing algorithms I will need language which on reasearch I found python is famous but I liked haskell for fancy reasons..So if I am good with main theory/algorithms and I learn haskell to solve those algorithms will I
09:06:37 <nicknight> stand chances...yes it is more fear of failure question only :(
09:08:52 <monochrom> There is always risk in investments, and investments include learning.
09:09:24 <monochrom> And by risk in investments we really mean: risk in your choice of investments.
09:10:31 <monochrom> Your money and your time are a zero-sum game. There is always opportunity cost. If you decide to learning PHP this week, you lose the opportunity to learn Haskell this week. And vice versa. You are always making a bet, and you always stand the chance of losing.
09:11:40 <blackdog> pragmatically, introducing haskell into an existing organisation usually requires some political capital. learning haskell will teach you some things in a fairly efficient way: you might not be able to apply those lessons directly, though.
09:11:56 <monochrom> And in fact you are already losing the chance of going to a culinary school this week. Who knows, maybe that's where you really belong.
09:13:39 <bolver> jle`, shapr, phadej -- thanks for your help ... if i have come across rather abrupt, i do apologize
09:16:23 <bolver> monochrom: you speak of "fear", but if you notice carefully, "fear" is everywhere, whether you make "good" or "bad" choices
09:16:26 <nicknight> monochrom:  thanks I didnt read your messages and you didnt mention my name now I read
09:17:08 <bolver> i am just being a bit philosophical ... if you understand what i mean
09:17:12 <monochrom> No I do not speak of fear.
09:18:10 <bolver> risk = fear
09:18:19 <monochrom> I agree to disagree.
09:18:31 <bolver> you worry all the time about risks when you have fear
09:19:16 <monochrom> OK that only establishes worry = fear at best.
09:19:54 <bolver> monochrom: what i am saying is not something to "tink" about ... you've to investigate it
09:20:06 <bolver> i meant "think"
09:20:49 <monochrom> Oh investigation takes time too. Perhaps this one is a transaction cost.
09:21:50 <bolver> monochrom: well ... i will leave it at that
09:22:06 <monochrom> But I think i can turn it into an opportunity cost if I say "investigating today which programming language to learn loses the opportunity of investigating today which culinary school to go to" >:D
09:23:26 <bolver> monochrom: what i am saying is that you approach is an endless loop ... you'll be "trying" to maximize your benefits all the time ... see where it will end up
09:23:42 <bolver> it has no end
09:23:56 <monochrom> At any rate maybe you personally have fear about risk but frankly neither I nor the lot of Wall Street quants have that feeling about risk. We quantize, contain, move on.
09:24:18 <monochrom> I'm sorry, my approach? What approach?
09:24:59 <monochrom> Where did I say or imply to maximize anything?
09:25:09 <monochrom> Show me a quote.
09:25:10 <bolver> monochrom: well, good for you and wall street ... i hope it will all work out fine for you in the end
09:25:50 <bolver> monochrom: well, you speak of opportunity costs ... 
09:25:55 <monochrom> And so?
09:26:07 <monochrom> Show me a quote.
09:26:22 <monochrom> Are you putting words into my mouth?
09:26:28 <bolver> so i felt that that means you want to maximize your gains and minimize your risks
09:26:36 <bolver> monochrom: NO
09:26:40 <monochrom> OK that's your feeling, not mine.
09:26:53 <bolver> monochrom: alright
09:26:59 <monochrom> Mine is really much darker than that, though I haven't said it.
09:27:39 <monochrom> I am explaining all these opportunity cost to tell people it's all hopeless. You don't even know whether culinary is better for you.
09:28:07 <bolver> monochrom: i see ... well, that's quite wise
09:28:11 <monochrom> And a wake-up call to the illusion of "oh learning carries no risk".
09:28:29 <monochrom> Sounds nice but is wrong.
09:28:33 <bolver> monochrom: sorry, i got you all wrong
09:29:09 <dsal> I've ended up in dead ends before, but I don't think I've ever felt like I've wasted time learning. I've wasted time not learning.
09:30:16 * hackagebot dotenv 0.5.1.0 – Loads environment variables from dotenv files – https://hackage.haskell.org/package/dotenv
09:34:08 <EvanR> alright...
09:34:23 <EvanR> lets say you want a function of this type
09:34:41 <EvanR> [Op] -> S -> ([Output], S)
09:35:11 <EvanR> how do you implement it in a way that produces the output list lazily?
09:35:11 <nicknight> dsal: I like the way you talk
09:36:23 <EvanR> this is a writer plus state, basically. but I feel like writer wont do what i want
09:36:49 <nicknight> can I have a example how can I create two  matrices and doing their dot product in haskell ?
09:37:44 <phadej> EvanR: (Op -> S -> (Output, S)) -> [Op] -> S -> ([Output], S) ?
09:38:18 <EvanR> ok
09:38:26 <phadej> do you want something like that?
09:38:34 <EvanR> that would do it
09:38:36 <lyxia> EvanR: Perhaps the AccumT transformer helps
09:38:47 <EvanR> how does it work?
09:39:13 <phadej> EvanR: my gut feeling is that if you write that naively, it will produce the [Output] lazily, if you don't force the result S too early
09:39:23 <EvanR> really?
09:39:34 <EvanR> that would be amazing
09:39:58 <iqubic> How do I check what the latest commit pushed to Hackage is, for a specific package?
09:40:01 <EvanR> wait
09:40:24 <EvanR> phadej: so what naive way are you thinking of appending each single Output to the accumulator?
09:41:07 <iqubic> I mostly want to know what the latest commit pushed to this project is: https://hackage.haskell.org/package/glirc
09:41:24 <phadej> EvanR: sec
09:42:24 * hackagebot strive 4.0.0 – A client for the Strava V3 API. – https://hackage.haskell.org/package/strive
09:45:07 <sm> iqubic: go to the repo, look for a tag corresponding to the latest version
09:45:19 <iqubic> I will do that.
09:45:31 <sm> morning all
09:46:01 <iqubic> sm: How do I get to the repo from the hackage page? Is there a link or something?
09:46:19 <EvanR> phadej: i see how to do it and have the output be backwards
09:46:35 <sm> iqubic: usually, if the cabal file is well maintained
09:46:54 <phadej> EvanR: http://lpaste.net/7307706852064624640
09:46:59 <sm> I have to ask, have you looked at http://hackage.haskell.org/package/glirc ? :)
09:47:16 <iqubic> sm: I have.
09:47:27 <iqubic> Are all the tests passing for version 2.24?
09:47:38 <sm> ok. Sometimes it's under Source repository, but glirc has the repo under Home page
09:47:47 <phadej> EvanR: and iirc, lazy State does essentially that
09:48:05 <sm> (*and* Source repository)
09:48:15 <EvanR> phadej: this would seem to produce the output backwards?
09:48:43 <sm> (but the Source repository url used is a hard one to click)
09:49:07 <EvanR> hrm wait...
09:49:56 <EvanR> i see, it computes the rest "first" then prepends the first output 
09:50:00 <EvanR> brilliant
09:51:36 <iqubic> So, I assume "build passing" means that all the tests have passed too?
09:52:58 <phadej> EvanR: I added `State` based example: http://lpaste.net/7307706852064624640
09:54:11 <phadej> EvanR: and now as oneliner
09:54:16 <EvanR> haha
09:56:07 <phadej> the `bar` doesn't classify as most naive version, maybe intermediate+?
09:59:11 <EvanR> head explode
10:01:53 <kogu> #bitcoin
10:02:22 <shapr> no
10:02:44 <shapr> kogu: http://www.michaelburge.us/2017/08/17/rolling-your-own-blockchain.html
10:07:29 <monochrom> phadej: The hardest part is done in foo and it is naïve or idiomatic Haskell i.e. how any beginner would write code so it's alright. The rest is just dressing.
10:08:07 <monochrom> And if you just naïvely import Control.Monad.Trans.State you get the Lazy version, so there is also that.
10:10:07 <monochrom> EvanR: It's also how Data.List.partition pulls it off.
10:10:43 <monochrom> > case partition even [0..] of (xs, _) -> take 10 xs
10:10:47 <lambdabot>  [0,2,4,6,8,10,12,14,16,18]
10:10:58 <monochrom> Terminates despite infinite input.
10:12:33 <monochrom> OTOH it is also a potential source of space leak. And historically it leaked more space in the past than now because in-between someone recognized this idiom and figured out how compilers should cope.
10:13:54 <iqubic> :t partition
10:13:56 <lambdabot> (a -> Bool) -> [a] -> ([a], [a])
10:16:38 <EvanR> my faith in haskell has ben affirmed
10:17:07 <glguy> > take 10 $ snd $ mapAccumL (\acc x -> (acc+x, acc+x)) 1 [1..]
10:17:11 <lambdabot>  [2,4,7,11,16,22,29,37,46,56]
10:17:28 <glguy> I don't know if that's relevant or not, I haven't read the whole backlog
10:23:18 <EvanR> phadej: do you really need a lazy pattern match using case?
10:23:28 <EvanR> which part would get the ~
10:23:49 <EvanR> surely not the ( , )
10:24:13 <bolver> i have some code @ http://lpaste.net/358963
10:24:48 <bolver> what would be the type signature of the `go` function in the code?
10:26:00 <bolver> appreciate any help
10:28:49 <EvanR> also wont consume the lazily generated output list build up a bunch of memory until you decide to look at the final state
10:29:19 <EvanR> no never mind
10:29:43 <fishythefish> bolver: at a glance, go :: Num b => b -> [a] -> m [a]
10:30:13 <fishythefish> Er, that Num b => b is actually just Int, never mind
10:30:45 <bolver> fishythefish: let me check it out
10:30:48 <fishythefish> in any case, you should be able to get ghc to tell you the type
10:31:37 <bolver> fishythefish: how? `go` is within the where clause ... how can i tell ghci to give me the type?
10:33:50 <bolver> fishythefish: that type signature does not work
10:35:03 <bolver> once again, code @  http://lpaste.net/358963 ... looking for type signature of `go` function
10:35:05 <fishythefish> bolver: with a type hole (unless they don't work in where clauses)
10:35:12 <fishythefish> bolver: how are you using that type signature?
10:35:32 <fishythefish> do you have ScopedTypeVariables enabled?
10:35:44 <bolver> fishythefish: what do you mean?  i am not understanding what you are asking?
10:35:53 <fishythefish> which bit?
10:36:16 <bolver> fishythefish: i just want to put a type signature for go in my code ... that's all
10:36:34 <fishythefish> then the first thing you need is to enable the ScopedTypeVariables extension
10:36:44 <bolver> ok, i did that
10:36:52 <fishythefish> otherwise, the m and a in the type signature of go won't refer to the m and a from the signature of replicateM'
10:37:21 <bolver> fishythefish: have you noticed that the call to `go` in the code? 
10:37:51 <bolver> replicateM' n op = go n []
10:38:33 <bolver> because of that empty list, i am not able to define a type signature for `go`
10:39:58 <bolver> fishythefish: btw, ScopedTypeVariables is already enabled in my code
10:41:34 <glguy> bolver: http://lpaste.net/358963
10:41:43 <Maurdekye> hello all
10:42:01 <Maurdekye> division is awkward
10:42:12 <glguy> bolver: The "forall" is important, it makes the m and a use scoped behavior
10:42:28 <Maurdekye> is there any way, if I have an arg with only the Num constraint, where i can always divide?
10:42:52 <Maurdekye> > (5 :: (Num a) => a) / 3
10:42:55 <lambdabot>  1.6666666666666667
10:43:18 <Maurdekye> hmm
10:43:22 <fishythefish> bolver: sorry, was AFK. with ScopedTypeVariables, did you quantify m and a
10:43:27 <glguy> Maurdekye: No, not all Num instances support division
10:43:28 <fishythefish> i.e. forall m a. ...?
10:43:57 <bolver> fishythefish: no, i didn't ... just taking a look at glguy's code
10:44:00 <Maurdekye> is there a subset of Num that encapsulates all instances which support division?
10:44:15 <glguy> :t (/)
10:44:16 <lambdabot> Fractional a => a -> a -> a
10:44:17 <fishythefish> :t (/)
10:44:19 <lambdabot> Fractional a => a -> a -> a
10:44:23 * fishythefish sighs
10:44:28 <fishythefish> glguy is too fast for me
10:44:33 <Maurdekye> just fractional?
10:45:05 <Maurdekye> hmm
10:45:26 <bolver> glguy: hey, thanks much ... your code WORKS!!!
10:45:31 <Maurdekye> what classes are Fractional instances of that Num isnt?
10:45:47 <Maurdekye> in other words, what am i losing by using Fractional instead of Num?
10:45:59 <fishythefish> you lose some instances
10:46:04 <fishythefish> but otherwise, Num a => Fractional a
10:46:06 <Maurdekye> which ones, specifically?
10:46:18 <fishythefish> you can check with :i <typeclass>
10:46:25 <Maurdekye> :i Fractional
10:46:26 <fishythefish> it'll depend on what you have in scope
10:46:34 <Maurdekye> > :i Fractional
10:46:37 <fishythefish> (i meant in your ghci)
10:46:37 <lambdabot>  <hint>:1:1: error: parse error on input ‘:’
10:46:45 <Maurdekye> okay
10:46:53 <fishythefish> by default, Fractional is just Float and Double
10:47:07 <kosmikus> Maurdekye: Int and Integer, primarily
10:47:18 <fishythefish> however, you can do things like (/) `on` fromIntegral depending on your needs
10:47:37 <Maurdekye> is there a way that a function could accept both floats and integers, and do division on them?
10:47:58 <bolver> glguy: one question -- why couldn't the type signature be go :: Int -> a -> m [a]?
10:48:16 <glguy> That's what it is 
10:48:17 <fishythefish> bolver: without the forall, m and a aren't introduced into the scope for the signature of go
10:48:50 <glguy> bolver: Oh a instead of [a]?
10:48:57 <bolver> fishythefish: yeah, i see that
10:49:40 <fishythefish> bolver: you could write a function with that signature, but the semantics wouldn't be the same
10:49:54 <bolver> glguy: i mean, why couldn't the type signature be go :: Int -> m a -> m [a]
10:49:56 <bolver> ?
10:50:01 <glguy> bolver: In order for you to be able to apply reverse to acc in ``go 0 acc = return $ reverse acc``, then the type of acc must at least be [b] for some b
10:50:24 <glguy> bolver: It can't be ``m a`` instead of ``[a]`` because you're using it as a list and not something else
10:50:35 <fishythefish> oh, derp, we're talking about go, not replicateM'
10:50:38 <glguy> The types have to match how you're using stuff
10:51:12 <bolver> glguy: i see, so by the time you get into `go`, you're in the list monad, you mean?
10:51:25 <glguy> bolver: no, the [] and m are unrelated
10:51:26 <fishythefish> nope
10:51:37 <fishythefish> the "do" block is still in the m Monad
10:51:57 <bolver> ok, i am a bit confused
10:52:22 <fishythefish> you're not using lists monadically here
10:52:23 <fishythefish> just as lists
10:52:56 <fishythefish> the second argument to go is just a list, not a list wrapped in a Monad
10:53:05 <bolver> ok, now i get it ... i was trying to wrongly think that the second argument to `go` should have the same type as the second argument to replicateM'
10:53:12 <fishythefish> and it's also not an 'a' wrapped in the m Monad
10:53:29 <bolver> fishythefish: yes, you are quite correct
10:53:59 <bolver> btw, is there anyway, i can ask ghci for the type of `go`?
10:54:55 <Maurdekye> bolver: use ":t"
10:55:01 <bolver> glguy: you derived m [a] for `go`, because the final type returned by `go` should match replicateM`, right?
10:55:35 <fishythefish> bolver: correct
10:55:59 <bolver> Maurdekye: `go` is within a where clause
10:56:01 <glguy> It needs to match, but that's not why. the implementation itself enforces that type
10:56:04 <glguy> ``go 0 acc = return $ reverse acc``
10:56:33 <glguy> that line forces a number first argument, a list second argument and some Monad instance m for the return type
10:57:02 <bolver> glguy: yes
10:57:12 <glguy> It has to be the particular m from the outer type signature because of the way ``op`` is used in the next clause
10:57:28 <bolver> glguy: that's what i was saying
10:58:18 <bolver> glguy: is there anyway to get ghci to spit out type of `go`?
10:58:37 <monochrom> ":type" will not work for local bindings. But go to the GHC Users Guide and look for ":type-at". Equivalently, emacs haskell-mode can also do it for you with haskell-mode-show-type-at
10:58:42 <glguy> yeah, but the best way to acheive that is via editor integration
10:58:48 <glguy> computing :type-at manually is annoying
10:59:14 <EvanR> is an attempt to lazily generate a list from a parsec parser doomed by the need to check for errors
10:59:16 <fishythefish> bolver: write replicateM' n op = _ n [] and ghc will give you a message about a type hole and what type should go there
10:59:29 <fishythefish> although in this case, i suppose it won't figure out that the list is [a] specifically
10:59:38 <monochrom> Yes EvanR. Or rather, incremental parsing.
10:59:49 <bolver> monochrom: i see ... i am using emacs haskell-mode, but didn't knwo about that
11:00:55 <glguy> bolver: That's C-c . in dante https://imgur.com/a/HlUqP
11:01:17 <monochrom> But you can use Cont/ContT to mitigate it. See my http://www.vex.net/~trebla/haskell/parsec-generally.xhtml#ContT
11:01:18 <bolver> fishythefish: i see ... thanks
11:01:31 <EvanR> what if you know the parse will work (if it doesnt work... you see a bottom in the stream)
11:01:41 <EvanR> what can you do
11:01:59 <Clint> get out of the water
11:02:06 <monochrom> hahaha
11:02:19 <EvanR> lol, jaws music
11:02:45 <bolver> glguy: you know ... your link is pretty cool
11:04:14 <EvanR> is there an accepted technique for doing the parse twice, first time generates nothing but scans for errors, second time assumes there are no errors and outputs a definite working stream to consume
11:04:33 <EvanR> you wouldnt do the second part if the first part fails
11:04:56 <EvanR> would save memory it seems to me
11:05:06 <bolver> glguy: in emacs haskell-mode, i suppose you can do the same?
11:05:26 <monochrom> It isn't bound to a key by default. But it exists.
11:05:28 <bolver> i just have to look at the key bindings
11:05:38 <bolver> monochrom: i see
11:05:44 <monochrom> You will have to create your own key binding.
11:06:18 <bolver> monochrom: i have to hack the elisp code and bind it to a key, i suppose
11:07:47 <bolver> glguy: thanks much for your time & help
11:08:05 <bolver> fishythefish: thanks much for your help as well
11:08:22 <bolver> one question i have
11:08:55 <bolver> the forall quantification -- why was it needed?  is that something GHC demands?
11:09:09 <fishythefish> it's part of using ScopedTypeVariables
11:09:15 <fishythefish> the forall introduces those variables into the inner scope
11:09:18 <bolver> fishythefish: i see
11:09:24 <fishythefish> otherwise, it's as if you never enabled ScopedTypeVariables at all
11:09:34 <bolver> fishythefish: i see
11:10:00 <fishythefish> note that it doesn't actually change the type of replicateM', by the way
11:10:05 <bolver> fishythefish: ah, now when i think about it, the forall makes absolute sense
11:10:12 <fishythefish> the forall m a. is already implicitly in the type sig
11:10:27 <bolver> fishythefish: i see
11:12:26 <bolver> fishythefish: are you familiar with replicateM?  the reason i am sking is that this code for replicateM' is supposed to be a more efficient implementation of replicateM.  but frankly when i compared replicateM to replicateM', i couldn't see any difference.
11:14:42 * hackagebot scuttlebutt-types 0.1.0 – generic types for Secure Scuttlebutt – https://hackage.haskell.org/package/scuttlebutt-types
11:15:19 <noteventime> I'm playing around a bit with floating point rounding modes (using foreign primops), is there some fusion-type trick I could do to avoid switching it back and forth when there's a sequence of numeric operations using the same rounding mode? 
11:15:37 <bolver> i posted code for both replicateM as well as replicateM' @ http://lpaste.net/358963
11:16:18 <noteventime> I would need to stop the runtime from pre-empting before the rounding mode is restored 
11:19:57 <fishythefish> bolver: why do you expect replicateM' to be more efficient?
11:21:58 <fishythefish> also, how are you measuring efficiency?
11:22:23 <a6a3uh> Hi! f :: (a->b)->(c->d)->IO(); how to get function like f' :: (a->m b)->(c->m d)->m (IO()) m being (Writer Sting) monad if it matters
11:22:51 <bolver> fishythefish: i didn't "expect" anything ... this was a performance bug reported by some users of replicateM, and they offered replicateM' as a solution, which they said performed much better
11:23:15 <fishythefish> bolver: do you have a link for that?
11:23:33 <erisco> a6a3uh, what does that function do?
11:23:34 <bolver> fishythefish: i couldn't, in my analysis, see why replicateM' and replicateM should be any different
11:23:36 <fishythefish> seems like replicateM' performs an unnecessary reversal
11:23:52 <dsal> The haskell docs are showing me lookup and (!?) in Data.Sequence, but I don't have these.  How does one grab things from them?
11:23:57 <erisco> a6a3uh, it looks like you may want >=> or <=< though it is unclear
11:24:48 <bolver> fishythefish: see /u/ klao @ https://github.com/Gabriel439/Haskell-Pipes-Library/issues/100
11:24:56 <a6a3uh> erisco: f is a play function of Gloss.Interface.Pure.Game and it takes 2 handlers which I converted to Writer monads to get logs from them
11:25:33 <nicknight> I don't know why you all liking haskell so much it is kinda frustrating tome when I start :( may be I am not intelligent enough to learan haskell
11:25:36 <erisco> a6a3uh, it just doesn't make sense to me
11:25:41 <erisco> a6a3uh, what is the implementation of f?
11:26:17 <dsal> nicknight: The part that's frustrating is your brain bulldozing some new pathways.
11:26:20 <fishythefish> bolver: they're not talking about all monads, just specific ones
11:26:39 <fishythefish> bolver: it has to do with which way the bind associates
11:26:47 <nicknight> dsal:  bulldozing means
11:26:49 <nicknight> ?
11:27:00 <bolver> fishythefish: yes, could you elaborate a bit?
11:27:39 <bolver> fishythefish: i thought they were talking about list monads
11:28:07 <dsal> nicknight: You know, like making a road on a hill:  https://www.youtube.com/watch?v=QHW7YAkqeHA  -- it's scary, different from anything you've ever heard of, but sure makes it easy to to get up the hill after you go through the initial effort.
11:28:24 <bolver> at least that's what he describes as the problem in that link ... he had a 10K-element list, where performance bogged with replicateM
11:28:37 <a6a3uh> erisco: implementation of play function is closed in some library it just called once at top level in Main file than it calls handlers when appropriate. it just gets 2 handlers. one for event and one for gamestep. I made those handlers to return Writer monads instead of pure values. Now I want to get the log and put into a file.
11:28:56 <fishythefish> bolver: he's talking about the Proxy monad
11:29:10 <fishythefish> lists are involved only because replicateM necessarily produces one (wrapped in a monad)
11:29:15 <erisco> a6a3uh, there is nothing to be done by having a  g :: a -> b  and  h :: c -> d
11:29:19 <bolver> fishythefish: i see
11:29:42 <erisco> a6a3uh, it may as well be  f :: IO ()
11:30:10 <a6a3uh> erisco: handlers are functions that gets event and world state and returns new worldstate. I can provide full signatures maybe I oversimplified
11:30:12 <bolver> fishythefish: so the performnace hit is for the Proxy monad?
11:30:22 <fishythefish> bolver: and other similarly structured monads
11:30:32 <erisco> a6a3uh, if those are not the correct types then yes, you oversimplified
11:30:48 <bolver> fishythefish: but not for the list monad?
11:31:16 <nicknight> ok dsal I wish I have some good videos for haskell though
11:31:35 <fishythefish> bolver: no
11:31:49 <erisco> a6a3uh, g2g. Ask your question again with the correct types and someone else can help you
11:32:08 <dsal> nicknight: There are lots of videos, but many are just fancy things.  Doing simple things isn't that hard, you just may have to unlearn some bad habits.
11:32:13 <bolver> fishythefish: thanks ... i am just learning haskell ... i do not know anything about Proxy monad
11:32:28 <dsal> nicknight: What are you finding difficult?
11:32:37 <bolver> fishythefish: but thanks for clearing this up ... 
11:32:47 <isBEKaml> nicknight: You might want to take up a MOOC course on Haskell, squarely aimed at newbies. 
11:33:00 <isBEKaml> nicknight: there's one going on week 2 right now from University of Glasgow
11:33:02 <fishythefish> bolver: it's not really about the Proxy monad; that's just the bug report you happened to find
11:33:41 <nicknight> dsal:  bad habbits like what ??
11:33:46 <a6a3uh> In order to have logs I did: handleEvent :: G.Event -> StateT GameWorld (Writer String) (); handleGameStep :: Float -> StateT GameWorld (Writer String) (). But final play function is as follows play :: (G.Event -> GameWorld -> GameWorld) -> (Float -> GameWorld -> GameWorld) -> IO (). Ho to put that together?
11:33:57 <bolver> fishythefish: he mentions that proble is akin to performance hit with ++  ... i just didn't understand where that was happening
11:34:18 <fishythefish> it's an analogy; he's not talking about lists monadically there
11:34:23 <nicknight> dsal: I am reading from here https://www.seas.upenn.edu/~cis194/fall16/   and its not good
11:34:37 <nicknight> isBEKaml:  can you post url please?
11:34:44 <fishythefish> if you're appending lists a, b, and c, then you can do a ++ (b ++ c) or (a ++ b) ++ c
11:34:54 <dsal> nicknight: Making giant complicated functions mixing side effects with computations, etc...
11:34:58 <fishythefish> the former is more efficient
11:35:19 <bolver> fishythefish: yeah, that bit about ++ i know
11:35:21 <dsal> nicknight: Try this:  http://learnyouahaskell.com/chapters
11:35:35 <a6a3uh> I want to put it together in a way that will save my logs at the level of calling play in some reasonable way to put it into a file at the end
11:35:48 <isBEKaml> nicknight: https://www.futurelearn.com/courses/functional-programming-haskell
11:36:08 <bolver> fishythefish: but my confusion was that -- in that bug report link, i couldn't understand where exactly was the performance issue
11:36:16 <fishythefish> what the bug report is saying is that the standard replicateM definition builds up a similar recursive expression which associates to the right
11:36:39 <isBEKaml> nicknight: you might find cis194 hard going if you are not already familiar with programming concepts
11:36:40 <fishythefish> if your monad is written such that right-association is more efficient than left-, then this is fine
11:37:05 <fishythefish> however, the Proxy monad would prefer left-associativity, so the standard replicateM is O(n^2)
11:37:13 <bolver> fishythefish: if you use the list monad with replicateM, i didn't see any such pattern in my analysis
11:37:27 <nicknight> ok thank you isBEKaml  I am checking that url 
11:37:27 <fishythefish> once again, this is not about the list monad
11:37:33 <bolver> fishythefish: i see
11:37:57 <bolver> fishythefish: now i get what you are saying
11:38:00 <nicknight> dsal:  many people here yesterday gave bad review on leran you haskell book so not checking that at all
11:38:00 <fishythefish> the only purpose of the list append example was to show that left- and right-associativity can have difference performance characteristics
11:38:10 <bolver> fishythefish: i see
11:38:57 <dsal> nicknight: For me, learning comes mostly from practice.  I don't think LYAH is super bad, but it'll at least get you practicing.
11:39:08 <fishythefish> LYAH shows you what haskell looks like without making it seem scary
11:39:16 <fishythefish> it's not the best for learning/teaching
11:39:16 <bolver> fishythefish: standard replicateM is O(n^2) for proxy monad, because replicateM "leans to the right"?
11:39:42 <fishythefish> yeah, he just means "associates right"
11:39:45 <monochrom> @stack monochrom
11:39:45 <lambdabot> I don't perform such side effects on command!
11:39:49 <monochrom> :)
11:40:16 <fishythefish> Proxy would prefer for replicateM to associate left
11:41:29 <bolver> when you say replicateM associates to the right, is that evident from replicateM's code?
11:42:40 <fishythefish> yes
11:42:52 <nicknight> ok thank you dsal  see you again after a hour or more of learning/studying haskell
11:44:43 <bolver> fishythefish: i looked at replicateM's code @ http://lpaste.net/358963 -- i couldn't see the right association -- may be i am missing something
11:45:43 <fishythefish> the last line is `return (x:xs)` where xs is the recursive case
11:45:45 <a6a3uh> erisco: does that statement makes sense now? is it clear what Im trying to do?
11:46:17 <bolver> fishythefish: i see
11:47:17 * hackagebot hs-bibutils 6.2 – Haskell bindings to bibutils, the bibliography conversion utilities. – https://hackage.haskell.org/package/hs-bibutils
11:47:17 * hackagebot wiringPi 1.0.1.1 – Access GPIO pins on Raspberry Pi via wiringPi library – https://hackage.haskell.org/package/wiringPi
11:47:40 <bolver> fishythefish: thnaks a bunch
11:47:47 <bolver> thanks a bunch
11:47:48 <fishythefish> bolver: consider reading http://okmij.org/ftp/Haskell/zseq.pdf
11:48:16 <dsal> Oh, I see.  The useful operations for Data.Sequence didn't arrive until after the version in the LTS.
11:49:06 <bolver> fishythefish: thanks
11:51:04 <bolver> fishythefish: this problem was not relevant to anything i was working on, but i accidently stumbled on it and got curious and wanted to understand the issue
11:51:21 <fishythefish> it happens :)
11:51:44 <bolver> fishythefish: thanks for your help anyway ... you seem to be very quick at haskell, btw
12:00:01 <a6a3uh> Hi! I'll try to state my problem one more time hopefully more clear :) I have play function provided by library that takes 2 handlers: play::(Event->World->World)->(Time->World->World)->IO(). It gets called once at top level and than handles all the process until the end of game. Now I implemented handlers adding log capability though Writer monad: handleEvent::Event->StateT World (Writer String) (); handleStep::Time->StateT World
12:00:02 <a6a3uh>  (Writer String) (). How to combine those handlers with play function provided by library and save the logs to file?
12:03:40 <a6a3uh> I can combine them loosing all logs easily this way: play (liftM (snd . fst . runWriter) . runStateT . handleEvent) (liftM (snd . fst . runWriter) . runStateT . handleStep). But that not exactly what I want to achieve ) 
12:04:01 <Cale> a6a3uh: You're using gloss?
12:04:06 <a6a3uh> yes
12:04:33 <Cale> You'll want playIO
12:04:43 <Cale> play isn't capable of saving anything to a file
12:06:41 <a6a3uh> Cale: hmm interesting. this will make my handlers impure. is it possible still to have them pure writing to Writer monad? having tham IO I dont really need Writer. I can just rite straigh to file inside those handlers.
12:08:06 <Cale> You can just apply return to the result of your handlers in order to trivially make them into IO actions, but since you want to write to a log file sometimes as well, that won't quite be sufficient.
12:08:55 <Cale> But yeah, you can runWriter, and write whatever was written out to a file
12:09:51 <a6a3uh> Cale: thanks! thats clearly a solution to make both handlers IO. but I'm still curious is it possible to leave them pure.
12:16:43 <Cale> a6a3uh: Well, you can write an intermediate function which takes pure handlers and does what limited IO you actually want to do
12:17:07 <Cale> But if you want to perform IO, there's no way around using the IO version of the function *somehow*
12:18:35 <a6a3uh> I just thought normal play could be lifted somehow to get what is written by both handlers and then placed back to IO() writing data to file on the way
12:22:03 <erikd> anyone have any clues on how to parse JSON with Aeson so that the parser adds a variable predefined field? Eg parsing something into say "data X = X a b c d e" where [b..e] comes from the parsed JSON, but `a` is supplied by the caller?
12:36:49 <a6a3uh> I think it comes down to having function f::(a->b)->c and g::a->m b get h::(a->m b)->m c. Is it possible?
12:38:21 <mniip> what is m
12:38:36 <a6a3uh> m is monad. Writer monad in particular
12:39:03 <Cale> a6a3uh: You can runWriter in the function where you use playIO
12:40:14 <mniip> something seems fishy about such a function
12:40:27 <mniip> I don't think it's possible
12:41:32 <geekosaur> generically it's not possible. if you know the specific m then you may be able to do it, depending on the operations in question
12:41:44 <mniip> I don't think it's possible with Writer w
12:41:46 <mniip> for an arbitrary w
12:41:53 <a6a3uh> Writer Sting?
12:42:08 <mniip> String is the free monoid so the problem is the same
12:43:02 <monochrom> erikd: data declarations cannot be created during run time.
12:44:20 <a6a3uh> Cale: seems you variant is the only possible:) will make my handlers IO then. thanks -- geekosaur and -- mniip!
12:45:00 <mniip> ok
12:45:40 <geekosaur> a6a3uh, what mniip is hinting at is that, depending on what you expect h to do, you may find yourself with a disconnected Writer. (State has the same problem.) it will typecheck but the result will be lost because it's off in its own little universe
12:45:43 <mniip> h f g = return $ f (fst . runWriter . g)
12:45:47 <mniip> but that is boring
12:47:09 <a6a3uh> mniip: you loose all the data :) I see what you mean
12:47:56 <mniip> if you're expecting h ($ x) g = g x
12:48:06 <mniip> then that might as well be provably impossible
12:48:49 <erikd> monochrom: i am well aware of that and that is not what I am trying to do
12:51:08 <geekosaur> erikd, if you have control over the FromJSON instance then you could poentially do it... but you have to get the 'a' into it somehow and that probably means an ugly global IORef via the unsafePerformIO hack or something
12:52:17 <geekosaur> you can't override an existing FromJSON instance to do it; your only option there is to treat the values from the JSON parse as an intermediate format and use a postprocessing step to generate the final data with inserted field values 
12:55:48 <monochrom> Maybe you really mean "data X a b c d e = X a b c d e" and "instance (FromJSON a, FromJSON b, FromJSON c, FromJSON d, FromJSON e) = FromJSON (X a b c d e) where ..." and then at a certain point in your program you get to say "decode :: Maybe (X Int Bool Char String Text Doulbe)"?
13:00:04 <erikd> geekosaur: thannks. yes, thats what i was worried about
13:18:32 <a6a3uh> when moving from import Graphics.Gloss.Interface.Pure.Game to
13:18:32 <a6a3uh> Graphics.Gloss.Interface.IO.Game I added (return .) before pure 'draw' 'handle' and 'step' functions.  And game got crazy. It was normal snake game before and now it draws its parts of snake randomly. Maybe this is a known pattern? Why is it not a good decision to add (return .) to all 3 pure functions to make them IO?
13:22:54 <mauke> (return .) usually indicates that you wanted to use fmap somewhere instead
13:22:55 <fishythefish> a code snippet would make this clearer, but prepending `return .` is not the same as `return`ing the output value
13:23:02 <mauke> but that's unrelated to your question
13:24:02 * hackagebot ansigraph 0.3.0.4 – Terminal-based graphing via ANSI and Unicode – https://hackage.haskell.org/package/ansigraph
13:24:51 <Tuplanolla> You're being too literal. If that particular case compiles, it should be fine.
13:25:07 <Tuplanolla> There's something else going on here.
13:25:39 <fishythefish> which is why a code snippet would be nice
13:25:46 <fishythefish> i've said all i can say based on the question so far
13:25:48 <Wirehead_Wannabe> Does anyone know how to retrieve attachments from emails using HaskellNet?
13:25:57 <Wirehead_Wannabe> There's very little documentation
13:26:20 <a6a3uh> it compiles but not works as it was working before I switched from play (https://hackage.haskell.org/package/gloss-1.11.1.1/docs/Graphics-Gloss-Interface-Pure-Game.html) to playIO (https://hackage.haskell.org/package/gloss-1.11.1.1/docs/Graphics-Gloss-Interface-IO-Game.html) by just prepending with (return .) thre functions with changed signatures
13:27:22 <Tuplanolla> This provides no extra information.
13:28:01 <mauke> a6a3uh: why are you repeating yourself?
13:28:20 <fishythefish> at the *very least*, can you provide a snippet showing the signatures of your functions and the call to playIO?
13:28:33 <fishythefish> showing the logic would be even better
13:28:50 <monochrom> mauke: The same reason why I repeated an attempt at Windows Creator Update :)
13:29:48 <monochrom> Actually I think I tried 3 times too. Shame on me twice. :)
13:30:49 <a6a3uh> sorry guys! tweaking around my code I broke something before. just figured it out.(
13:31:43 <monochrom> Research shows that talking to the rubber fishy fish solves 74% of your problems. :)
13:32:20 <iqubic> I like the rubber fishy fish approach.
13:32:54 <a6a3uh> It one of very rare situations where my code compiles but does not what I expected it to do. and I did not noticed when it becomes broken
13:33:15 <a6a3uh> usually haskell types helped me )
13:33:28 <fishythefish> am i the rubber fishy fish
13:33:44 <iqubic>  Yes a6a3uh that is really rare.
13:34:04 <EvanR> its kind of rare.. more like uncommon
13:34:15 <EvanR> and it sucks when it does
13:34:22 <fishythefish> > length (1, 2)
13:34:25 <lambdabot>  1
13:34:28 <EvanR> ...
13:34:30 <fishythefish> Foldable/Traversable instances for (,) are fun like that
13:34:50 <EvanR> acknowledging that that exists should be banned
13:35:00 <monochrom> fishythefish: hehehe
13:35:13 <EvanR> why would you even use that instance
13:35:24 <EvanR> regardless of what it did
13:35:37 <fishythefish> okay but like maybe i'm coming from c and
13:35:40 <fishythefish> > sum(1, 2)
13:35:42 <lambdabot>  2
13:35:44 <fishythefish> wait
13:36:22 <iqubic> > length ((1,2),(3,4))
13:36:24 <lambdabot>  1
13:36:32 <iqubic> That's odd
13:36:36 <monochrom> It is "instance Foldable ((,) a)" so it disregards the 1st component and instead treats the tuple as a 1-element container of the 2nd component.
13:36:42 <fishythefish> not if you understand how the instance is defined
13:36:47 <fishythefish> the mailing list discussions on this are fun
13:37:20 <unit73e> hey. I'm trying to make an hdevtools package for archlinux and I have http://lpaste.net/4733757256791752704 but when I execute I get http://lpaste.net/358971. Why?
13:37:27 <fishythefish> it's an internally consistent definition, but it doesn't seem externally consistent, particularly to beginners
13:38:39 <EvanR> this definition is inconsistent
13:38:40 <monochrom> I think very few people actually use it. So it may be better off not provided to begin with.
13:39:05 <geekosaur> unit73e, because arch's haskell packages are broken
13:39:06 <EvanR> its probably necessary to get foldable to apply to more things
13:39:21 <EvanR> that contain tuples somehow
13:39:31 <unit73e> geekosaur, yeah I guess it's a mess but it's what I have :\ no solution?
13:39:33 <monochrom> At any rate examples like "sum (1,2)" can be misleading too. Consider "sum ('x', 2)" instead.
13:39:37 <geekosaur> unit73e, look carefully at what arch's pkgbuilds do
13:40:13 <geekosaur> (basically they use ghc in a non-default mode and do not arrange for that to becme the default, so virtually any use of ghc without knowing to adjust it for arch's hacks will fail)
13:40:59 <unit73e> so I guess of the dynamic thing that hdevtools assumes it's not dynamic?
13:41:55 <geekosaur> likely it needs to be patched to look for the dynamic version of things, yes
13:42:16 <unit73e> bah.. sometimes arch just pisses me off...
13:42:37 <geekosaur> but that may not actually work very well. there's good reasons why ghc is not dynamic by default, and arch chose to ignore those reasons. the result is a mess
13:43:04 <motching> hi. beginner here. I'd like to put data through a TCP connection but it seems every Char gets sent in a separate packet, instead of all being in one
13:43:06 <motching> hPutStr handle "This is a test"
13:43:23 <geekosaur> motching, if it's TCP then there is no concept of packet
13:43:23 <motching> I guess I need some form of strictness but I could not find how to enforce
13:43:33 <mauke> geekosaur: eh?
13:43:34 <unit73e> nixos is looking better each day :\
13:43:42 <EvanR> should Arbitrary generate only valid data, what if you want to test a validator
13:43:54 <mauke> motching: I think you need to not use Handles and Strings
13:44:03 <geekosaur> mauke, it's a stream. you don;t see packets, you don't control packets, packets are a thing managed by the network stack and intervening routers and invisible to apps
13:44:04 <unit73e> thanks
13:44:19 <mauke> geekosaur: TCP is packets
13:44:26 <mauke> I remember this from school
13:44:27 <monochrom> motching: No, this is more about buffering or unbuffering than strictness.
13:44:30 <geekosaur> sigh
13:44:32 <geekosaur> read what I said
13:44:42 <LysergicDreams> unit73e: hdevtools works for me on Arch when installed via stack. Maybe have your aur package build it using stack instead?
13:44:42 <mauke> you're talking about stream sockets
13:44:48 <geekosaur> TCP is stream sockets'
13:44:52 <mauke> no
13:44:55 <geekosaur> UDP is packetized sockets
13:44:57 <monochrom> Also, you should probably post actual code.
13:44:59 <mauke> stream sockets can be implemented on top of TCP
13:44:59 <glguy> The packets are an implementation detail, it's a stream protocol. The issue in this case might be that the handle needs to have its buffering mode changed from NoBuffering to line or block buffering
13:45:08 <geekosaur> TCP/IP is the name of the whole protocol, which is admittedly confusiing
13:45:18 <monochrom> I mean in case you dismissed some other factor that actually is the cause.
13:45:25 <geekosaur> but the interface t TCP sockets is SOCK_STREAM
13:45:27 <unit73e> LysergicDreams, I wouldn't even know how to begin. Maybe I'll just use stack too and forget the package.
13:45:44 <mauke> geekosaur: not if you're doing TCP manually :-)
13:45:58 <motching> hm I see. thanks I'll try to change the buffering mode
13:46:17 <monochrom> Oh and it could also be very well the buffering mode on the receiving end.
13:46:33 <motching> I see
13:47:17 <LysergicDreams> unit73e: Yeah stack makes it super easy to install packages as normal users, just run `stack install hdevtools` & add `.local/bin` to PATH.
13:47:17 <monochrom> All is lost. You will probably have to write up a complete procedure for a third party to successfully reproduce your experiment!
13:48:15 <LysergicDreams> unit73e: For an AUR package, you could just run `stack setup && stack build` in the repo & copy the built executable from `.stack-work`
13:48:38 <monochrom> And maybe after 10 hours of an international troublshooting effort, maybe the cause is found to be "oh you're on a cruise ship using super-slow satellite Internet"... :)
13:49:09 <geekosaur> don't laugh. there's an article floating around the internet of the problems the south pole research stations have with internet
13:49:34 <geekosaur> s/south pole/antarctic/
13:49:34 <monochrom> That too.
13:50:12 <qwebirc25350> I also have problem with internet connection but I'm not in antartica
13:50:24 <monochrom> <motching> Nah, I'm climbing the Himalayas, learning Haskell in spare time.
13:50:29 <monochrom> :)
13:50:53 <mauke> *antarctica
13:51:10 <monochrom> "The first Haskeller to climb the HImalayas"
13:51:27 <geekosaur> and sometimes you have someone doing something dumb like unconditionally disabling the Nagle algorithm
13:53:45 <geekosaur> (TCP_NODELAY --- good for interactive things like ssh or telnet, bad for any other usage)
13:55:58 <iqubic> What's the Nagle algorithm?
13:57:46 <Arguggi> I'm trying to use diff (from the ad package) with polyInterp (from the polynomial package). I'm getting type errors when applying diff to a partially applyied polyInterp: (diff (polyInterp myPoints)),  not sure how I'm supposed to get a AD s (Forward a), any help?
13:59:43 <glguy> You should post both the code that you expected to work and the raw error message you got to a pastebin if you want help with either
13:59:53 <ertes> geekosaur: TCP is not necessarily a stream protocol…  for example around the time when the trojan sub7 was popular i tried to write a fake server for it and noticed that it's actually using TCP as a datagram protocol…  you had to send messages such that they would cause exactly one read, and when reading messages you had to assume that each individual read is a full message =)
14:00:46 <geekosaur> you just have to implement your own framing and can't assume that a read syscall will return a full message but instead have to provide your own read that does your framing
14:01:50 <Tuplanolla> That's nice, but what does the specification say, ertes?
14:02:00 <ertes> Tuplanolla: the what?
14:02:16 <motching> yeah I realized networking is more complicated than I thought. I am considering trying UDP now
14:02:17 <Tuplanolla> I guess the RFC.
14:03:03 <ertes> i had to reverse-engineer the spec…  was fun times trying to figure out how the hell sub7 framed messages
14:04:18 <ertes> mobile wasn't a thing back then, and i guess fragmentation was sufficiently unlikely…  but more likely the original author didn't have a clue about networking
14:04:50 <Tuplanolla> Was I that unclear? I thought the discussion was about whether TCP can exist without packets.
14:05:00 <geekosaur> the sort of program that 'worked' until your connection went across someone else's misconfigured router and it all went to hell because it split the packets
14:05:14 <geekosaur> (i.e. MSS set too small)
14:05:20 <ertes> Tuplanolla: i thought you were joking
14:05:50 <ertes> geekosaur: even then the packets were tiny, so most of the time it just worked
14:08:16 <fishythefish> just because something tries to use TCP as a datagram protocol doesn't mean that TCP is a datagram protocol
14:08:46 <fishythefish> i can implement reliable, in-order delivery over UDP, but god help you if you expect those guarantees by default
14:09:46 <glguy> Arguggi: (\xs -> diff (polyInterp xs)) :: (forall a. Fractional a => [(a,a)]) -> Double -> Double
14:10:00 <glguy> Arguggi: That version of the type helps hide the AD parts
14:10:02 <monochrom> I count as one of those clueless people who just assume that one write corresponds to one read because it worked like that 20 years ago in most places, not knowing that the general case doesn't promise this.
14:10:42 * geekosaur hands monochrom 20 years ago's connection from Europe to Australia >.>
14:10:44 <monochrom> (Oh and of course I never tried a 10MB write.)
14:11:29 <monochrom> Yeah I only played with connections across 3 university campuses in the same large city.
14:11:46 <monochrom> (U of Toronto Scarborough, U of Toronto, York U)
14:12:07 <monochrom> err the middle one is more precisely U of Toronto St. George Campus
14:13:34 <monochrom> So with the modern luxury of Haskell we should just conduit/pipes it and then attoparsec it?
14:14:22 <geekosaur> (... but, at least if you were talking to a university or a large company, the connection from the US west coast to australia was often faster than connections from US west to east coast!)
14:14:34 <monochrom> I mean 20 years ago I had to use C so it was super annoying if one write splits to multiple reads.
14:15:03 <monochrom> Oh w00t that's interesting.
14:15:15 <Tuplanolla> That reminds me of another project idea for beginners.
14:15:18 <monochrom> Yeah why did that happen?
14:15:44 <isBEKaml> hey, anyone going to Haskell Exchange, London next week? 
14:15:58 <nicknight> after 4 hours I feel haskell I can master one day
14:16:05 <isBEKaml> I'm around the area, but can't go - oof, expensive tickets -_-
14:16:09 <Tuplanolla> If latency is not a problem, you can get a way higher-bandwidth connection from USA to Europe through encrypted file storage on your Google drive.
14:16:30 <nicknight> hi isBEKaml  if I recall you gave me that mooc right?
14:16:46 <nicknight> Thanks it is so easy 
14:16:48 <geekosaur> well, actually literally 20 years ago from now you actually had fiber connections reliably across the US. 25 years ago, there were still copper segments along most of the routes
14:16:52 <isBEKaml> nicknight: yeah, I gave you a link. But I didn't give any MOOC. :-)
14:17:02 <isBEKaml> nicknight: Glad it helped :-)
14:17:19 <Tuplanolla> I'm talking about going from 100 kB/s to 100 MB/s.
14:17:32 <monochrom> Oh OK super-slick fibre over the Pacific, but still older tech on the continent.
14:17:35 <geekosaur> australia got a fiber connection to the US well before the US finished replacing its internal infrastructure with fiber
14:19:13 <nicknight> monochrom:  you used c 20 years back ?? really ?? 20years of software experience OMG
14:19:29 <monochrom> No I was a student.
14:19:46 <monochrom> Also it's more like 20 years of grad school.
14:20:14 <monochrom> Almost qualified for "tenured grad student" if there were such a position!
14:20:22 <jakehehrlich> So Vladmir Voevodsky died. Does anyone know how he died so young?
14:20:23 <fishythefish> professional grad student
14:20:31 <ertes> fishythefish: in case it didn't get across, i'm joking
14:21:01 <nicknight> but I am starting coding at the age near to 30 very late to the party :(
14:21:48 <fishythefish> ertes: I picked up on that, but in a conversation where people are legitimately debating the point, I like to clarify :)
14:21:57 <monochrom> Ah but I haven't revealed how old I am now or back then. So it's not like "20 years ago I was 18-months old and playing with C and sockets".
14:22:21 <fishythefish> that'd be irresponsible parenting. handing something as dangerous as c to a toddler
14:22:28 <ertes> fishythefish: i don't think anyone here really thought that TCP was a datagram protocol =)
14:22:31 <ertes> not even mauke =)
14:22:39 <nicknight> monochrom:  I assume you are in 20's at that time for sure 
14:22:46 <monochrom> Actually maybe I should claim that.
14:22:51 <nicknight> now you are old :P
14:23:33 <Tuplanolla> As his name implies, he's from the time before color existed, nicknight.
14:23:50 <nicknight> I dont know what his name mean
14:24:32 <nicknight> and I dont know what do you mean by color?
14:24:36 <ertes> "i was born in 2050 AB"
14:24:45 <mauke> wow
14:24:54 <mauke> try explaining the concept of color over IRC :-)
14:24:58 <dyreshark> "our baby has been speaking ever since he started programming C at 3 months. sadly, the contents of his speech were uninitialized, so it sounded like nonsense."
14:25:10 <monochrom> haha
14:25:27 <isBEKaml> nicknight: color or colour, it's the same thing. One in America (spelled color), rest of the world spells it "Colour"
14:25:42 <glguy> Much of the "rest" of the world has a completely different language
14:26:00 <nicknight> isBEKaml:  I know I am saying ifhe is referingto color movies or html/css colors
14:26:07 <mauke> I also spell it color
14:26:12 <ertes> "he was quite the quick walker, but all he did was non-sense…  now, 40 years later, he's still causing us pain every day"
14:26:13 <fishythefish> real life
14:26:15 <isBEKaml> glguy: yeah, America's the lonely blubbering idiot. Everyone tries to follow, though
14:26:21 <fishythefish> all pictures are color pictures, but the world used to be black and white
14:26:36 <fishythefish> Calvin's dad isn't wrong about this stuff
14:26:38 <glguy> isBEKaml: o.O uh, ok
14:27:09 <glguy> The world's a going to be a scary place for you when you find out how many things are different
14:27:12 <isBEKaml> glguy: Nah, I'm kidding. :P
14:27:13 <nicknight> ok back to work see you again 
14:27:27 * geekosaur *eyeroll*
14:27:59 <geekosaur> (also afraid to ask what they think of someone who was writing C in the 80s >.> )
14:28:26 <isBEKaml> geekosaur: you only have to ask Pike
14:28:34 <monochrom> heh
14:29:14 <boj> heh
14:29:35 <ertes> "you know, we have ML now, right?"
14:30:34 <monochrom> Using ML back then was fairly inconvenient. You had to pay for Allegro Common Lisp because ML was written in it.
14:31:04 <ertes> "you know, we have common lisp now, right?"
14:31:08 <monochrom> I know because I played with and old version of HOL back then.
14:31:29 <monochrom> (HOL was and is written in ML. SML now, the older ML back then.)
14:32:04 <monochrom> Aw but Common Lisp is inferior to ML. Look at the type systems. Look at how functions are not quite first-order in Lisp.
14:32:12 <ertes> BTW, you suggested i try HOL…  i tried to try it, but found it quite difficult to try
14:32:18 <monochrom> (It is not just Common Lisp.)
14:32:30 <ertes> i switched to coq now
14:32:47 <ertes> with a glimmer of hope that lean will get mature soon
14:32:55 <ertes> (coq is incredibly inconvenient)
14:33:09 <[exa]> y u no agda
14:33:32 <ertes> [exa]: agda is great from a purist's perspective…  not so much, if you want to get stuff done =)
14:33:53 <[exa]> I was afraid of that. :D
14:34:03 <ertes> i know, because i wrote a basic category theory library, and at some point i got really really really bored of passing 6-8 universe level arguments around =)
14:34:14 <mauke> monochrom: how are functions not first order in lisp?
14:34:17 <[exa]> lol
14:34:28 <Tuplanolla> First-class, mauke.
14:34:36 <monochrom> Oh oops, first-class.
14:34:52 <ertes> "illegal function: must take a function argument"
14:35:21 <ertes> would be a nice way to force people into FP =)
14:35:36 <ertes> a language where first-order functions are banned
14:35:50 <monochrom> :S
14:36:09 <[exa]> oh yes, pure lambda calculus without the damned integers!
14:36:23 <[exa]> :D
14:37:25 <[exa]> monochrom: btw did you mean the (defun) ugliness or something else?
14:37:33 <geekosaur> abandoning Church is the first step on the road to hell?
14:39:30 <[exa]> :D
14:45:47 <pie_> idk how to feel about this lol http://www.willamette.edu/~fruehr/haskell/evolution.html
14:46:28 <geekosaur> it's more a joke about how people learn than about haskell, tbh
14:46:58 <Arguggi> glguy, ok that seems to work but now the problem is I get a [(Double,Double)] from parsing a file and I want to pass it to the function but I'm not sure how to get a (forall a. Fractional a => [(a,a)]) . (never really understood forall very well :/ )
14:48:31 * hackagebot scuttlebutt-types 0.2.0 – generic types for Secure Scuttlebutt – https://hackage.haskell.org/package/scuttlebutt-types
14:50:01 <monochrom> Take a look at realToFrac
14:50:44 <ertes> @let newtype IntC = IntC { runIntC :: forall r. (r -> r) -> r -> r }
14:50:46 <lambdabot>  Defined.
14:50:53 <ertes> @let fromIntC (IntC f) = f (\go x y dy -> go (y + dy) x (negate dy)) (const . const) 0 1 (-1)
14:50:54 <lambdabot>  Defined.
14:51:07 <ertes> @let toIntC x0 = IntC $ \f z -> let go 0 = z; go x = f (f (go (x - signum x))) in (if x0 < 0 then f else id) (go x0)
14:51:09 <lambdabot>  Defined.
14:51:30 <ertes> i will never abandon church
14:52:15 <monochrom> @type fromIntC
14:52:16 <lambdabot> Num t => IntC -> t
14:52:22 <monochrom> @type toIntC
14:52:24 <lambdabot> (Num p, Ord p) => p -> IntC
14:52:47 <ertes> @let fromIntC :: IntC -> Integer
14:52:49 <lambdabot>  Defined.
14:52:54 <ertes> @let toIntC :: Integer -> IntC
14:52:56 <lambdabot>  Defined.
14:53:32 <ertes> > map (fromIntC . toIntC) [-5..5]
14:53:35 <lambdabot>  [-5,-4,-3,-2,-1,0,1,2,3,4,5]
14:53:50 <monochrom> > runIntC (toIntC 2) (\s -> () : s) []
14:53:52 <lambdabot>  [(),(),(),()]
14:54:04 <monochrom> > runIntC (toIntC (-2)) (\s -> () : s) []
14:54:07 <lambdabot>  [(),(),(),(),()]
14:54:15 <Tuplanolla> > (fromIntC . toIntC) maxBound
14:54:17 <lambdabot>  error:
14:54:18 <lambdabot>      • No instance for (Bounded Integer)
14:54:18 <lambdabot>          arising from a use of ‘maxBound’
14:55:05 <Tuplanolla> > (fromIntC . toIntC) bigBound
14:55:11 <lambdabot>  mueval-core: Time limit exceeded
15:15:50 <tinytusk> Hi. I am operating within the Monad “ExceptT RpcError IO”, and I want to call a function which has a class constraint MonadMask.
15:16:10 <tinytusk> Since ExceptT doesn’t work with MonadMask (due to multiple exits), this doesn’t type check.
15:16:23 <tinytusk> Is there a standard workaround for this problem?
15:20:25 <nicknight> Hi I just started haskell and just wanted to check how solution looks for this in haskell https://leetcode.com/problems/two-sum/description/  can some one please give me solution
15:20:26 <jle`> tinytusk: you need to find an instance of MonadMask that can be converted into an IO (Either RpcError a)
15:22:32 <monad_cat> Is there a way to pretty-print a lens-json parsed value?
15:26:23 <tinytusk> jle`: Hmm. IO is an instance of MonadMask.
15:26:40 <tinytusk> Surely I can take an IO a and convert it to a IO (Either RpcError a).
15:31:06 <jle`> tinytusk: indeed
15:35:00 <tinytusk> jle`: 
15:35:25 <tinytusk> jle`: It would seem then that I can just (fmap Right) and be done.
15:36:24 <hexagoxel> :t lift
15:36:26 <jle`> mhm or alternatively just use liftIO
15:36:26 <lambdabot> (Monad m, MonadTrans t) => m a -> t m a
15:36:48 <tinytusk> bah!
15:37:00 <tinytusk> That was embarrassingly simple.
15:37:08 <tinytusk> And it type checks now. Thank you.
16:11:54 <nub_> @pl foldr combiner base tree
16:11:54 <lambdabot> foldr combiner base tree
16:12:21 <nub_> @pl foldr combiner base tree = foldMap combiner tree base
16:12:22 <lambdabot> foldr = flip . foldMap
16:17:24 <jle`> tinytusk: no problem!
16:44:51 <JappleAck> hi guys, can i compile stack-scripts to binary file? i mean just using a command, without creating a project around it?
16:45:55 <geekosaur> hypothetically one could use the default globa project just liek the scripts themselves use, with stack exec ghc -- ...
16:49:00 <JappleAck> geekosaur, yep, i can compile using global config from ~/.stack but i'd be happy if i could compile script with resolver and packages specified inside this script
16:49:44 <geekosaur> don't think it provides a way to do that. the documentation for adding that to scripts made it pretty clear that it was a hack, last time I looked
16:51:14 <geekosaur> ok, maybe not quite that obvious. https://docs.haskellstack.org/en/stable/GUIDE/#stack-configuration-for-scripts and following
16:52:58 <geekosaur> noting in particular the runghc example they point to, which is the more painful but less hacky way to set things up and should be more amenable to compiling
16:57:18 <crucify_me> hello recently I've been studying some cases of the infinite type error. how can we know that a ~ [a] creates a *nested* recursion [[[[a]]]] ...   and not something else?  
16:58:15 <mniip> your question makes no sense
16:58:30 <crucify_me> if you had to explain it logically
16:58:45 <mniip> hindley-milner is only consistent while the "occurs check" holds
16:59:12 <crucify_me> please explain mniip 
16:59:50 <crucify_me> ie why is it not [a] -> [a] -> [a] .....
17:00:10 <monochrom> In "a ~ [a]" there is no "->"
17:00:37 <crucify_me> right ok
17:00:51 <mniip> crucify_me, are you familiar with ~
17:00:59 <mniip> and how typechecking works in general
17:01:05 <monochrom> Similarly, "d ~ d->d" would not mean "...[[[d]]]..." because in "d ~ d->d" there is no "[]".
17:01:43 <crucify_me> ok monochrom good call
17:01:46 <crucify_me> mniip ...
17:01:58 <monochrom> When you see a recursive equation, you don't just add extra ingredients out of the blue for the solution.
17:02:09 <monochrom> Unlike culinary.
17:02:37 <mniip> instantiation, constraint generation, constraint solution, tidying, generalization
17:03:17 <monochrom> in which if you follow a recipe for roast beef with red-wine-sauce it's OK to suddenly say "I love chocolate, I'll add chocolate, screw the recipe" at a whim.
17:03:27 <monochrom> Programming doesn't work this way.
17:03:42 <mniip> monochrom, I think you mean "unlike calculus"
17:04:13 <mniip> x=x' therefore we'll grap some exponents
17:04:42 <monochrom> Ooohhhh that's a different story. Finding anti-derivatives you mean? That's a feat of reverse engineering so you do have to guess and check.
17:05:03 <mniip> also huh
17:05:09 <mniip> does roast beef require a recursive recipe
17:05:29 <monochrom> No.
17:06:04 <crucify_me> Ok I'll leave you two alone
17:06:07 <monochrom> OK how about washing your hair with shampoo? The bottle does have an iterative instruction. Close enough.
17:06:57 <monochrom> While you're following its simple loop it's OK to suddenly say "I love Cologne, I'll add Cologne, screw the instruction".
17:07:04 <monochrom> How do you like that? :)
17:07:36 <crucify_me> what a bummer
17:07:47 <mniip> idunno where you live but here shampoo instructions aren't turing-complete
17:08:47 * hackagebot primes-type 0.2.0.2 – Type-safe prime numbers. – https://hackage.haskell.org/package/primes-type
17:08:47 * hackagebot vector-space 0.12 – Vector & affine spaces, linear maps, and derivatives – https://hackage.haskell.org/package/vector-space
17:08:48 <monochrom> Oh do you really want me to go technical and tell how we mean the smallest solutions to recursive equations so we can't add anything extra.
17:09:22 <monochrom> That would be so boring compared to fantasy stories of chocolate roast beef and cologne shampooing.
17:11:11 <Profpatsch> Apart from thread delay, is there a nice way to schedule IO actions?
17:12:33 <monochrom> I don't know of one. I've only checked base. I wrote my own "sleep 30 seconds, is it 10AM yet? repeat" loop.
17:13:20 <EvanR> when i do stack exec foo, i am not able to type on stdin and hit control D to continue
17:13:22 <monochrom> It is possible that Unix has a function for that, but I don't know how well it mixes with GHC RTS.
17:13:37 <EvanR> if i run foo directly, from deep inside the .stack-work dir it works
17:13:45 <monochrom> Wait, control D? why is it not return?
17:13:57 <EvanR> T.getContents
17:13:58 <monochrom> Oh OK, dunno.
17:14:06 <monochrom> God and Stack work in mysterious ways.
17:14:33 <geekosaur> I wonder if that's another manifestation of the hSetBuffering weirdness
17:14:46 <monochrom> Oh true.
17:14:49 <geekosaur> check if backspaces actually work, or the program reads the backspaces
17:15:33 <EvanR> backspace causes ^?
17:15:41 <EvanR> when running from stack exec
17:16:17 <EvanR> since i have to control C to get out, i dont know what it reads
17:16:26 <geekosaur> right. so, stack exec turns off input buffering. ghc, for some reason, conflates this with termios and sets the terminal to raw mode, so ^D is just a character and so is the delete key
17:16:40 <geekosaur> but it leaves isig turned on, so ^C works
17:16:48 <monochrom> I have just found out why the Haskell Platform "full" linux tarball gives you broken packages.
17:17:24 <geekosaur> (pedantically, it sets -icanon vmin 1 vtime 1, which disables line editing and end of line/end of file processing)
17:17:26 <EvanR> ok that explains it
17:17:40 <EvanR> stack exec foo < input-file works fine
17:19:01 <EvanR> next mysterious, what justifies "stackification" and "cabalization" to have different suffixes
17:19:05 <EvanR> mystery*
17:19:20 <balor> I have a large codebase and I'd like to know how much of it is used by a simple program.  Can I generate an AST of my simple program and get a call-graph, or do I need to generate a callgraph using -rtsopts at runtime?
17:21:34 <EvanR> i am looking through my project and i dont see where it is specifying the GHC version... like .ruby-version does
17:21:50 <EvanR> is it resolver: lts-9.6  in the .stack file?
17:22:07 <geekosaur> yes
17:22:28 <EvanR> ok then should be shippable
17:22:30 <geekosaur> a resolver specifies a ghc version and a set of package versions known to work with that ghc version and with each other
17:24:37 <geekosaur> balor, in theory you could just dump the STG from the compiler. but this won't tell you what paths will be followed in practice, just what graph nodes are linked to each other
17:24:49 <balor> geekosaur, thanks
17:25:05 <geekosaur> it can;t tell you what inputs will produce what coverage
17:37:08 <monochrom> Correction: Actually I don't know how Haskell Platform's build process did it, I only know what intermediate result makes GHC unhappy.
17:38:43 <monochrom> It's this: If you have a Haskell Platform installation, say the linux one, and the full one, do a "ghc-pkg field vector abi-depends". You'll see one of them goes "primitive-....=inplace" as opposed to the normal "pkgname-...=hexhashstring". That's how.
17:39:17 <monochrom> I'm now going to see whether the Windows build has the same problem.
17:40:24 <monochrom> But I'm completely at a lost how to produce it. I mean I know one way, but it's very artificial and unnatural, you have to go out of your way to be a mad scientist to build anything this way.
17:41:22 <monochrom> This problem doesn't affect the "core" version. It's only the extra libraries in the "full" version.
17:42:41 <monochrom> And only some of the extra libraries. Exact criterion: a library that depends on other extra libraries.
17:44:50 <Profpatsch> monochrom: Yeah, I think it’s kinda hard to schedule inside the RTS
17:44:52 <monochrom> Oh haha it's 2.6GB (the installer dialogue box says)
17:45:17 <Profpatsch> I wonder what an easy way to split a list into chunks of the same length is.
17:45:58 <monochrom> You mean you want to split into 5 chunks and you don't know the list length a priori?
17:46:03 <Profpatsch> yeah
17:46:11 <Profpatsch> No, 5-element chunks
17:46:43 <Profpatsch> chunk 3 [1,2,3,4,5] => [[1,2,3],[4,5]]
17:46:45 <geekosaur> :t chunksOf
17:46:46 <lambdabot> Int -> [e] -> [[e]]
17:46:54 <geekosaur> Data.List.Split
17:47:03 <Profpatsch> No way. d)
17:47:36 <monochrom> Oh, then Data.List.Split (package "split") or Control.Parallel.Strategies (package "parallel") have something for you
17:47:55 <Profpatsch> It also exists in Text
17:48:47 <monochrom> If you're splitting chunks for the sake of par'ing then just go directly to Control.Parallel.Strategies.parListChunk, don't pass Go, don't collect $200.
17:51:03 <Wirehead_Wannabe> Any idea why this is apparently crating an infinitely long string?
17:51:04 <Wirehead_Wannabe> removeJobSearch :: String -> String
17:51:04 <Wirehead_Wannabe> removeJobSearch a = concat $ filter ("Job search" `isPrefixOf`) (lines a)
17:52:01 <monochrom> > concat $ filter ("Job search" `isPrefixOf`) (lines "a\nb\nb")
17:52:04 <lambdabot>  ""
17:52:10 <monochrom> Cannot reproduce.
17:52:46 <Wirehead_Wannabe> What's the \nb\nb ?
17:52:55 <Wirehead_Wannabe> oh
17:52:55 <geekosaur> depends where 'a' is coming from. if it's a getContents / hGetContents then it's a lazy String that will just keep going until the input runs out, which it won't for a socket or terminal until the sender closes the socket or you ^D on the terminal (but also see the earlier discussion about hSetBuffering...)
17:52:56 <Wirehead_Wannabe> nvm
17:52:56 <monochrom> \n is newline
17:52:58 <Wirehead_Wannabe> im dumb
17:53:02 <Wirehead_Wannabe> yeah
17:55:08 <Wirehead_Wannabe> It's the result of an an IO that's been bound to a name
17:55:48 <Wirehead_Wannabe> recentmess <-(fetch con $ last msgs)
17:55:48 <Wirehead_Wannabe>   let recmesstext = Data.ByteString.Char8.unpack recentmess
17:55:48 <Wirehead_Wannabe>   putStr $ formatCSV recmesstext
17:56:47 <monochrom> Oh strange, the Windows version doesn't have the problem.
17:57:00 <Wirehead_Wannabe> Huh
17:57:09 <Wirehead_Wannabe> Idk what it is then
17:57:35 <monochrom> No, I'm referring some earlier monologue I made before you came.
17:57:39 <Wirehead_Wannabe> the last line produces a file that will crash both text editor and LibreOffice if I try to open it
17:58:42 <monochrom> How big is the file?
17:58:44 <geekosaur> how many times does that get run? because if you're doing it once per input line, you are likely producing a single very long line that many line-oriented programs will have trouble working with
17:58:58 <geekosaur> (putStrLn might be your friend)
17:59:28 <Wirehead_Wannabe> it only gets run once
17:59:53 <Wirehead_Wannabe> It worked just fine until I added removeJobSearch as a step
17:59:54 <geekosaur> oh, concat on result of lines. maybe you wanted unlines?
18:00:10 <Wirehead_Wannabe> oh, yeah, let me try that
18:00:16 <geekosaur> because that's still just one long line if you use concat
18:01:29 <Wirehead_Wannabe> That fixed it, thanks
18:02:19 <monochrom> Oh strange it's because the Windows version simply doesn't have "abi-depends" at all!
18:03:50 <monochrom> Why oh why would the Windows version not have it but Linux would?!
18:09:11 <lukeshu> On arch linux, I'm trying to build shellcheck.  But it can't find Prelude (among other things); tacking on `-v` to `runhaskell Setup build` gives me a ghc command, and tacking `-v` on to that, I see that it's searching the non-existent /usr/lib/ghc-8.2.1/base-4.10.0.0/Prelude.hi, but not the Prelude.dyn_hi that does exist.
18:09:58 <lukeshu> And I'm too much of a newbie with haskell to really know how to proceed.
18:10:23 <geekosaur> you need to force -dynamic because arch broke its setup
18:11:20 <geekosaur> https://wiki.archlinux.org/index.php/Haskell#Problems_with_linking
18:15:38 <lukeshu> geekosaur: thank you.  I had the --enable-shared and --enable-executable-dynamic flags, but was missing --disable-library-vanilla 
18:19:05 <lukeshu> Oddly, I got the command I was running from Arch's PKGBUILD for shellcheck.
18:21:12 <monochrom> Ooohhh, maybe the Windows version was built by an older Cabal library.
21:09:46 --- topic: 'https://www.haskell.org | https://wiki.haskell.org/IRC_channel | Paste code/errors: http://lpaste.net/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D | https://www.reddit.com/r/haskell | Admin: #haskell-ops | Offtopic: #haskell-offtopic | https://downloads.haskell.org | https://summer.haskell.org Summer of Haskell 2017'
21:09:46 --- topic: set by mauke!5lzdiZJQGk@p3m/member/mauke on [Mon Jul 31 05:45:11 2017]
21:09:46 --- names: list (clog cpup hackagebot quazimodo ggherdov robotroll Guest63586 chriswk nelll mgttlinger jonrh meinside befuddled dan_f_ Masaomi[m] benzrf MoarSpaceFi CoderPuppy benl23_ jw358 ian_andrich albel727 otto_s_ lambda-11235 conal schoppenhauer coot____________ coup systemfault hexfive felixsch__ rschmukler serendependy okuu darjeeling_ Harekiet1 olligobber vuto begriffs muesli4 cyphase catern pelegreno_ sleffy SCHAPiE chu MindlessDrone papapishu Hijiri baetheus)
21:09:46 --- names: list (oldsk00l carlomagno grahf[m] Guest72950 pharaun runawayfive scde shikhin clinton __main__ houli tarcwynne__ Tehnix_ ncl28_ Tspoon_ supki_ Deaddy Randy alanz lagothri1 crobbins KoH Jonno_FTW ijp bogdanteleaga ephemeron kipras banc mad[m] abbiya sirius[m] naviknair7[m] Guest312594[m] moonrunes[m] innaytool[m] srenatus fgaz[m] ycy[m] Dako300[m] mark_c reactormonk[m] LucasFrancesco[m bustillo[m] ninegua[m] rizo[m] dirb[m] JHBrannam[m] MarkusK[m] subz[m])
21:09:46 --- names: list (mascht[m] thisLight[m] sebisebi[m] magog[m] ramirezD[m] ajtowns[m] TimWolla[m] trikl[m] mrhania[m] trevorriles[m] dlandau[m] KevinMGranger cheshircat jzl yushyin Atlantic777 lambdabot Frankablu Remy terrorjack dminuoso GreySunshine langkid1 ck_y stig notshloub cdal mstruebing ids1024 caw__ Raynes heyj mikeplus32 dhtns sbauman rodarmor libbyk bitemyapp Ninja3047 gnusosa vimto Frans-Willem logicmoo Willis nighty- etiago NinjaTrappeur rossberg freusque)
21:09:46 --- names: list (megaTherion vikram__________ tumdedum davean noexcept_ nek0- amx chaetopterus[m] _Adluc_ SegFaultAX cbaines solarus__ huonw jared-w dpepsilon suppi h30_ knmae datajerk slester felixonmars maerwald Guest33209 sanitypassing telser japesinator jan-sipr nahra` prooftechnique connrs sns padre_angolano thoughtpolice zph bigs tazjin bitonic edofic tjpeden fingerzam xplat|work peteretep wyvern MitchellSalad xnyhps fbauckho chelfi kensan tomus jmct simony filwisher)
21:09:46 --- names: list (S11001001 mbeidler twomix joel135 yaknyasn localhorse__ redcedar flux toblorone emilypi MarcelineVQ erikd cpennington lambdamu Arcaelyx kuttifunk ahihi plutoniix zero_byte srk KaneTW byte512 Unode M2tias xpoqp dh__ iomotoko brynedwards SaneGoatBot lukeshu justanotheruser HMPerson1 heurist`_ asthasr__ albertus1 mantovani codesoup thunderrd toby1851 balor orion augur_ Kristof_HT soniku markus1199 xaviergmail Qommand0r theDon Athas nakal Xal ycheng SuprDewd)
21:09:46 --- names: list (Noldorin Jesin sagax Fairy beerdrop hiratara akermu al-damiri stoopkid__ jchia_1 ninedotnine monochrom freeman42y mkoenig jedws erisco Maxdamantus nick123 _kit_ dfeuer HaskellLord69 cyborg-one ertes jcjf LysergicDreams urodna m0rphism dxld noteventime djapo rfmind slackman ghost83 mda1 gawen mmhat gxt twopoint718 aarvar whitephoenix tpreston ehubinette Orbstheorem M16_29[m] ThomasQM texasmynsted eacameron mzf acarrico leat taylskid Hafydd pacak bennofs)
21:09:46 --- names: list (lkolstad wagle bweston92 youtmon sdothum guest69[m] hvr araujo hive-mind glguy OnkelTem ekr anoe kmicu juhp zariuq gfixler bsmt boj jounaz^__ tnks wonko7 qmm infinity0 robogoat eruditass a3Dman xdelv tg isenmann Khisanth kefin chindy Tuplanolla hrnz Jaak cow-orker kosmikus pandem Ranhir Gothmog_ SpaceKnight Clint aphprentice niklasl sigmundv atomi RGamma Zialus Lord_of_Life Enigmagic Shatnerz seccus Philonous mingc Bashmetim harmaahylje sleepynate gehmehgeh)
21:09:46 --- names: list (Cthalupa ortmage StoneToad raynold ssarah shadowdaemon m1dnight_ logcat xh_ rembo10 abrar tv bilal80 piyush-kurur foolswood noam Guest30919 hdurer[m] Soft rootnode SAL9000 Majiir mniip yahb Fekinox zolamusic JoelMcCracken Cale voiceftp akkad dibblego chrzyki alexbiehl GGMethos fr33domlover spludgemaster athan joeytwiddle geekosaur AndreasK duncan^ hgost epta myme bjs Guest82765 earthy ziman athaller_ inkbottle Durbley jakehehrlich lavalike ddima mnoonan qzo)
21:09:46 --- names: list (leah2 Makinit[m] shutdown_-h_now sw1nn rblaze1 mdupont sudom0nk[m] ftop badzergling gienah ixian xplat kculpis yeeve ericsagnes Laney mk-fg owickstrom zenspider Wamanuz2 acowley_away Robin_Jadoul bbaren Ferdirand alienaut przemkovv Sigyn mek42 apeyroux karce CurryWurst salva peddie[m] uelen esph omilu tessier urdh tomku xinming bshelden Scapin[m] jfredett noah_ jophish APic Benzi-Junior mak` jrabe calloc cheater _flow_ Guest34903 m4lvin mivael Bane^ dancek)
21:09:46 --- names: list (kyren Neo TimWolla max-m Natch pierrot fluxit perrier-jouet lidenbrock Ewout Nik05 sheyll chrissl riatre magthe AbjectsGuest1779 nshepperd mceier HallaSurvivor Foritus prg318 michalrus Guest21598 cjwelborn LnL sausage_ nullifidian_ bydo atk fxk[m] jimmyrcom_ dmwit trosa WarzoneCommand fakenullie grumble newman[m] liyang mikosty troydm bartavelle Litom[m] catsup mutsig kaychaks Klumben Vq grayhatter sm kshannon dedgrant ichor jorj alexelcu Meanirelli Draggor)
21:09:46 --- names: list (Sgeo_ joebetz1 centril armyriad quicksilver sgoody[m] forker m00n zaquest vaibhavsagar Brando753-o_O_o lassulus risz inr icen[m] falafel DexterLB Morgawr pita Tesseraction ph88^ theorbtwo verement zenzike akfp mitch_ ahf Rembane smyds zeroed jbalint AWizzArd ab9rf devpav[m] marble_visions jrslepak wamaral jdt kini hiptobecubic ClaudiusMaximus Li[m]1 esssing joehillen bgamari RayNbow`TU Axman6 R0b0t1_ aidecoe ggVGc klugez beaky rotty mitchty dave24 hanna)
21:09:46 --- names: list (besenwesen danieli ninegrid Sose DustyDingo packetbiompm[m] divVerent iw00t aweinstock Stumbler adamCS wto alp iross WhereIsMySpoon_ andrewmcveigh linduxed Paks bxc noctux Blkt Jaxan int-e peddie fergusnoble raid SuperTux88 Intensity fall_ kloeri cjay- dysfun Drezil nopf c0dehero comboy jonge Quintasan abbe pdgwien tortal hydraz rom1504 Elsi jinblack orcus ski richi235 AntiSpamMeta sivs jle` LOLBOW ethercrow Flecheck[m] a_t notemerson jtcs Dykam tangled_z[m])
21:09:46 --- names: list (pringlescan carter zgrepc jorendorff dstockwell thi_ ebutleriv zpconn__________ Guest4509 cansis ReinH kyagrd mbrock nkpart SaidinWoT carc ij dsal bbielsa_ tharper_ andrew_n_ angerman georgew stasku cdornan_ spicydonuts elvishjerricco TabAtkins Bengi CARAM___ codedmart iravid Argorok gothos isaac__ mbrcknl_ mindtree gridaphobe wenzowski cstrahan trig-ger avdi akl capicue afcondon_ gsingh93 incomprehensibly paf31 noxd reem kipd frew lynn kgadek)
21:09:46 --- names: list (killtheliterate sdemos poga yminsky Tallenz prefork hansihe Heero__ baamonde Scorchin shans_ joedevivo darthThorik twold metalrain prizim ericbmerritt_ rizary customminer bytesighs jxv @ChanServ tomaw SolarAquarion rann oldsnakey armlesshobo SolitaryCypher zyla \u so PHO reptar_ exio4 bvad ManiacTwister croben wz1000 mgaare nilOps Tristan-Speccy shapr kfish nikolah d3lxa odamn betawaffle coeus suzu Ring0` blackdog dyreshark Jello_Raptor przembot zachary12)
21:09:46 --- names: list (thoros qz buoto1 MasseR eL_Bart0 Xnuk DDR amuck Guest60956 Biohazard yarou Oipo gabiruh absence quakestor emmflo hjklhjklhjkl TallerGhostWalt banjiewen brent80_plow xa0 Desoxy cjh` skeuchel alek platz Nikotiini EvanR raek zomg ec2-user_ bengt_ arkeet hsyl20 tek0 oleks Boreeas niko abra0 geal int0x27h brennie andjjj23 majoh_ noplamodo edwardk nshepperd1 bno2 bind1 Jinxit Twey Netwolf lieven Nycatelos discrttm reinh1 RazorX fuziontech niveus si14 runeks Tritlo)
21:09:46 --- names: list (TyOverby__ avn unsymbol e libscott phaazon micro_ Yaiyan Eliel lpsmith dqd DigitalKiwi orzo zerokarmaleft ezyang tctara monty hexagoxel ft dpn` nemesit|znc da-x cross bananagram koala_man lukexi Geekingfrog johnw Solarion ynyounuo Logio bus000 tippenein wizonesolutions pygospa ChongLi magnuson trcm tdammers Xandaros julmac madsj dredozubov Fuuzetsu ircbrowse Tourist admwrd L8 jackhill rubberduckreynir michaelw zebrah Profpatsch wayne Igloo_ Saizan hegge_)
21:09:46 --- names: list (sbrg stefan- NocnaShada dgpratt mmaruseacph2 relrod miklcct oherrala aatxe burp naudiz nerteren pleiosaur lokydor mearnsh ocramius scopedTV ctag Flonk RevJohnnyHealey posco codebje matthavener stux|RC-only jix bbee Fylwind petercommand edwtjo fredsir malthe Chousuke Zowlyfon agrif mattp__ Voldenet tolt_ fnurglewitz earldouglas Chobbes Ornedan dschoepe chirpsal1 syamaoka juri_ HalfEatenPie eikke magicman zymurgy fairfieldt wtw nonzen andromeda-galaxy dan64)
21:09:46 --- names: list ([swift] vodkaInferno c-rog integral aib sa1 nbouscal thoradam mystfox monad_cat gornikm dgonyeo wavewave spinda noobst ryantm solidsnack feltnerm bgyss mkurkov_ mpickering lumimies billstclair jml adelbertc ocharles Xorlev OliPicard PotatoGim bjobjo idupree2 angular_mike___ Bigcheese intelux_ scav pmade exferenceBot oberste1n aaron7 nisstyre scinawa gesindel u-ou Squarism edran TakumoKatekari ByronJohnson cpallares ntinos statusfailed heinrich5991 ljhms)
21:09:46 --- names: list (kubrat Gabemo nikivi squisher guios markhuge akemot SiCC LeaChim brisbin xacktm sclv StianL twk- crosleyt jlouis ralu tomasmu wladz jokester tolt chaosdav hsiktas jrm rootmos danzimm asm89 jlewis gareth_ kav lispy luigy cesardv navilan aminb carbolymer pasukon janne swhalen treehaqr michalisko kiboneu greymalkin MalfaitRobin_ vin-ivar adjivas cfoch-al1 vimalloc tsahyt Deewiant Ke dfranke Moyst Arguggi niklasb Ulrar raatiniemi wedify ccase zmanian numberten)
21:09:46 --- names: list (rofer sdrodge michi7x7 pyrtsa uwap pikajude joeyh newsham erratum cic tjbp procgen tabaqui1 bmeynell sleblanc heath tekacs mngrm4 x1n4u ventonegro ongy joachifm trevorriles spoonm l_zzie pmn Zoddo worch happy0 liste nshepperd_ stephe micmus lexi-lambda JSharp pchiusano JoJoen marcel Cir0X johtso milessabin etrepum rgrinberg jzelinskie strmpnk Kamuela Meow-J ryanbooker flebron AlainODea niluje MagneticDuck kaffepanna acfoltzer_ unidan brolin_empey greeny__)
21:09:46 --- names: list (stass grandy____ raibutera bod_ dt343gs[m] rexor[m] unknownln jyp[m] bennofs[m] monomon[m] trevortknguyen[m M-berdario pellegrino jmnoz tfc[m] spacekitteh[m] turt2live berton bb010g unlmtd hendrik[m] MatrixTraveler[m aer[m] aspiwack[m] davidar_ cutie tester668[m] davidar herzmeister[m] WilliamHamilton angelbeats[m] M-BostonEnginerd ollieh sn[m] lysgaard[m] Aidan[m] M-kevinliao drasich[m] TylerCecil[m] Soif[m] zaphar_ps[m] M-krsiehl hpd_m MohdSKhoeini[m])
21:09:46 --- names: list (goodboy[m] kritzcreek Nuva[m] undu[m] hakan[m] rellen MikasiCoyote[m] romanofski[m] piluex[m] fib11235[m] arslanatajanov[m SuperW[m] s0ra[m] Mike[m]1 thejonny[m] redviking[m] Alexander_Hansen octalsrc[m] M-whoops sudoreboot[m] schplaf[m] slartibartfast[m LangeOortjes[m] ElyKar[m] TFX[m] riadvargas[m] dtcristo strixy[m] Matthew[m] wizzup[m] thekyriarchy idnar[m] Obscurity[m] M-Illandan etcinit[m] puffnfresh Rifa[m] crapman[m] equalunique[m] khac[m])
21:09:46 --- names: list (wubbalubbadubdu4 M-ms plll[m] M-schmittlauch phil_frontal[m] CryptoCalsius[m] futpib[m] Asiannoodles42[m ketanhwr Novitsh[m] romanzolotarev[m mith[m] zukonake[m] masaeedu[m] closures999[m] toumi124[m] ItevNabdifNi[m] Adau[m] kilian[m] yashi[m] spotter[m] kimchi[m] testtt55[m] NickSeagull[m] lkh[m] zhangjiji[m] pingfreud[m] lonokhov[m] ddbbuu[m] stites[m] phittacus Maikel_Experius[ elpfen[m] psYchotic[m] roninkaizen[m] rydia5[m] jacobleach[m] wisn[m])
21:09:46 --- names: list (tommy0010[m] okkk emme[m] softashell ttk2[m] levzhazeschi[m] Michi[m] synopz[m] dkellner[m] AX3L[m] memoryruins[m] ltq520[m] talesmantovani[m el_tejon[m] mtncoder[m] Barnabas[m] Deleh[m] M-rgh laaksoan[m] intheclouddan[m] beemo[m] ThousandLions[m] M-herah Nerka[m] Akito[m] chominist[m] lucnx[m] TristanBKildaire moka[m] superobserver[m] Naughtmare[m] WolfLightning[m] adampaigge[m] schum[m] unclechu Courage[m] WinterFox[m] magnap SansFr[m] cuddly[m] saci[m])
21:09:46 --- names: list (thekyriarchy__ tobim[m] Luguber[m] jvalleroy[m] rcat[m] joncfoo[m] mlainz[m] felipeac[m] riaqn polux[m] Shaunthesheep[m] XertroV[m] pyrtheibarit[m] DavesTestingAcco Cadey[m] pacmansyu[m] ya-alex[m] antiless[m] razvanc-r[m] caro401 Drakonis[m] djquant[m] mrdaak[m] jsgrant[m] nine-h[m] goolord[m] scanleft[m] astronavt[m] gylpm[m] km42[m] mrgraffe[m] Niboor[m] adziahel[m] BartGroeneveld[m asm[m]1 howsiwei[m] peel[m] nimbus[m] Zarthalan[m] M-HirmeS sphalerite)
21:09:46 --- names: list (dbramucci[m] am2on lixiang4u[m] ArrayWindrunner[ kebertx[m] mrhunky[m] guest121[m] M\u202e[m] psan[m] toa[m] Guest340521[m] M0xfiras[m] shekel[m] JohnnyReb[m] KENNYNR1[m] prot[m] joakimf95[m] Jasonjunsu[m] Andry976[m] ElliotKiyomizu[m zmre[m] ptek[m] mk[m] boash[m] akshay7777[m] Monad[m] yaspoon[m] hesiodos[m] jnonpony[m] seto[m] Guest1573[m] scrypso[m] sssi1ver[m] rimon[m] Vipernet1220[m] Bimmie[m] rprospero[m] Rubas[m] eyenx Guest291964[m] nwf gspia)
21:09:46 --- names: list (tabaqui vfs toppler Mcpurplemuffin[m jchia rdococ dumptruckman Kneiva mou fiddlerwoaroof opqdonut nekomune amerlyq wting brixen himmAllRight[m] gilbertw1 staffehn iphy anishathalye pdxleif lyxia bencryption statusbot Zemyla bollu ps-auxw Emantor nathyong drdo Taneb sdhand jameseb etXzat[m] phadej changyj Deadhand echoreply BytesAndCoffee asjo mikedlr rjungemann sujeet altooid nyuszika7h soncodi valkyr2e cocreature S007 Guest17559 asenski[m] fbreitwieser[m])
21:09:46 --- names: list (canta rbocquet gareth__ aniketd[m] NemesisD vikraman Niamkik gleber_ minad dsm__ cgag paroxp mendez bwe Limeth_ Purlox o0o[m] nullset[m] kg hanDerPeder mathu tokik dogui barrucadu amatecha Ankhers cynick Akii zekt rjeli Xe hpc nick1234 rotaerk dustinm jluttine Immune Reisen dxtr madknight reu teqwve Pilfers bsima amf nille mdarse milli pikhq dolio swalladge oozz[m] Forkk c0ff33[m] cschneid _6a68 bs sdx23 arw pfoetchen charlag[m] malt3 obiwahn ons jsonhigh[m])
21:09:46 --- names: list (Reyu[m] mt xxpor thomashoneyman leothrix ego aijony hiredman nesqi defanor dpacbach[m] Verandetten[m] Squidnyan[m] bramvdbogaerde[m M-kitsune hiq[m] m3tti[m] jgornick dashed thallada dmj` coup_de_shitlord geetam Tharbakim srhb acro Mistv[m] otulp solatis caasih ambrosia cchalmers jdnavarro lopex Adeon SlashLife ephemera_ wisha[m]1 electrocat wrengr_away sqrt2 bluepixel MitchW avatias0[m] g2 electrostat fonadius[m] froztbyte byorgey dsfox mauke Someguy123)
21:09:46 --- names: list (Vorpal mlen bastelfreak butterthebuddha Fubar^ jdevlieghere dysfigured mulk mjamal14[m] Burnout641_ implementation seliopou_ lachenmayer kloplop321 jamiis_ CindyLinz fxrs Guest18532 bcoppens eagleflo amiri_ Liskni_si destiny__ [exa] fgaz frontendloader hongminh1e cods a3f Raptor8m3_ benonsoftware levex mimi_vx ramatevish henrytill koz_ eddsteel nurupo wadadli c_wraith spion_ Sornaensis anhduy __name__ anderson Cathy fryguybob tsani Velpoman garphy`aw vili)
21:09:46 --- names: list (zipper sveit meck kwantam hodapp marienz Amadiro runde cyberlard osfameron Lokathor Warrigal hugogomes[m] bezik)
21:16:29 <MUWA> testing...
21:17:06 <MUWA> testing admin...
21:17:21 <srhb> Uh..
21:18:31 <rotaerk> they're performing tests on an admin; we must free the admin!
21:19:53 <MUWA> i just testing dude...
21:21:30 <MUWA> so, this channel is really quiet...
21:21:45 <jared-w> It's one of the most active channels on freenode, just not at this time of night on a thursday usually
21:22:16 * jared-w is currently highly peeved that his prime factorization program in Curry is not the 3 lines his professor suggested it would be
21:23:12 <MarcelineVQ> do it in one out of spite if he didn't give you execution time limits
21:23:33 <MUWA> jared-w: i think just in your place, in here is friday afternoon!
21:24:00 <jared-w> MarcelineVQ: I have no idea how to do a prime factorization program in one line :p
21:24:31 <jared-w> MUWA: ah well in that case, most of #haskell tends to be in the London, Eastern US or Western US timezones :)
21:25:00 <MUWA> jared-w: but not in asian :(
21:27:36 <MUWA> jared-w: what's the point of discustion in this channel ?
21:27:45 <jared-w> It's about the programming language, Haskell
21:29:41 <MUWA> jared-w: not about hacking ?
21:29:52 <jared-w> Nope, not at all
21:31:12 <MUWA> jared-w: so, are you pro on HASKELL ?
21:31:52 <jared-w> Not particularly; I kinda suck at Haskell, to be honest, but I'm getting better at it
21:33:02 <MUWA> jared-w: is that for website or something ?
21:33:45 <jared-w> Haskell is a general purpose programming language, you can use it for whatever you want to
21:34:18 <MUWA> jared-w: u mean anything ?
21:34:34 <jared-w> Sure
21:36:38 <MUWA> jared-w: are you just good at haskell ?
21:37:35 <jared-w> I would say I'm at a high beginner to low intermediate level (if I'm being optimistic...)
21:39:05 <MUWA> jared-w: well, good for u...but i gotta go cuz i use my school computer
21:39:08 <MUWA> bye
21:39:27 <MarcelineVQ> :>
21:39:35 <jared-w> Well okay then...
21:39:51 <jared-w> Nice of you to cleverly avoid that conversation, MarcelineVQ :p
21:40:29 <MarcelineVQ> I bow to the high beginner to low intermianiate haskell experts in the room in cases like these muahaha
21:40:35 * jared-w has a sudden irrational urge to recreate his old mutt config for email and update it for no reason
21:40:51 <jared-w> pffhhh
21:41:31 <jared-w> That was an extremely generous assessment, anyway :p just because I know what a monad is doesn't mean I'm useful at programming in Haskell yet. I haven't done near enough of it to really get anywhere, I've just been book learning
21:42:04 <MarcelineVQ> ehe I just liked the wording that wasn't a jab
21:44:41 <jared-w> yeah I figured, I just wanted to clarify lest anyone read the logs later and decided I was being an idiot or whatever ¯\_(ツ)_/¯
21:47:43 <jared-w> So whatcha been up to, MarcelineVQ?
21:50:56 <MarcelineVQ> looking into making a small cnc mill for house projects and, to keep on topic, what that might entail once set up programming wise. such as using ghc to as an optomizser for generated g-code to run the device
21:53:31 <jared-w> oh nice, CNC mills are legit. My dad's more into woodworking but I think I'd be more into the metal and 3D printing stuff... I won't know until I have a real house with a garage, though
21:53:46 <MarcelineVQ> a lot of paths for the cutting tools can be quite wasteful in their movements time-wise, so I predict needing something to assistr with that once I get going
21:54:27 <jared-w> Do you have a DSL/library already plotted out or are you going to make one once you get some g-code to work with?
21:59:04 <MarcelineVQ> Didn't find a whole lot, I​ looked around but not too closely. I can use a simulator to see if the paths are being improved but it's alot of work to improve a system that isn't actually doing anything yet
22:00:02 <MarcelineVQ> There's a lot more incentive when you're waiting for the thing to stop making noise
22:01:07 <jared-w> fair enough :p
22:01:18 <jared-w> Or you could just become deaf like me, then bam, no motivation to fix something you can't hear...
22:03:38 <MarcelineVQ> jared-w: you should joine #haskell-offtopic or your favorite offtopic channel and we could speak more about it if you want to
22:03:56 <jared-w> sure, I'll pop over there
22:43:49 <joebetz1> anyone know any good example projects that use servant + acid-state?
22:44:46 <joebetz1> or can summarize how to share a single database connection across requests :)
22:47:05 <joebetz1> or
22:49:25 <joebetz1> tell me whether this is the wrong approach, and that a connection should be opened and closed with each request. but I've already run into file locking issues under light load, so assumed there was a better way.
22:51:21 <joebetz1> there must be
22:51:49 <boj> joebetz1: you probably want to use a pool library which opens N connections and shares them amongst your requests
22:52:28 <boj> joebetz1: i believe resource-pool is the commonly used one
22:53:00 <joebetz1> thanks, I'll check it out
22:53:19 <boj> sadly i don't know much about how acid-state works, but this is a common pattern for other dbs
22:53:23 <joebetz1> okay
22:53:28 <joebetz1> I think acid-state is a bit different
22:53:37 <joebetz1> in that you load your db into memory on init
22:54:36 <joebetz1> and then create snapshots periodically
22:55:07 <liste> there's 2 ways to use acid-state: as a library or as a server
22:55:56 <joebetz1> huh
23:00:01 <joebetz1> boj: <checks it out> yeah, this is how I'm used to doing it too, by way of SQL. but I think the problem I'm having is independent of in memory data vs connection pool, and it's in figuring out to actually give whichever one to the http server to use when handling requests.
23:01:39 <joebetz1> https://github.com/parsonsmatt/servant-persistent/blob/master/app/Main.hs#L32 <-- basically, what's happening here
23:03:37 <boj> joebetz1: you'd want to use that to avoid opening/closing connections over and over and exhausting your file descriptors on the OS
23:04:06 <joebetz1> I can probably puzzle it out from that, but yeah, would be nice to have an example project
23:06:54 <joebetz1> right
