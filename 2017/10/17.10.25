00:12:49 <cocreature> ekr_: https://wiki.archlinux.org/index.php/haskell#Building_statically_linked_packages_with_Cabal_.28without_using_shared_libraries.29
00:12:58 <cocreature> ekr_: also the package is called QuickCheck not quickcheck
00:23:47 <Lokathor> tdammers, i suspect (rather, know) that it will have like a hundred items one day :P
00:24:10 <ekr_> liste_: i removed everything related to haskell, and reinstalled from scratch, just ghc, ghc-libs, ghc-static, cabal-install and their dependencies
00:24:32 <tdammers> Lokathor: 100 modules to re-export?
00:24:56 <liste> ekr_: using pacman?
00:25:03 <Lokathor> no, the module will export its own 100 definitons as well as one of its imports
00:25:04 <ekr_> yes, using pacman
00:25:18 <tdammers> Lokathor: but you can export the module itself wholesale as well
00:25:21 <ekr_> would installing cabal from source be a better idea?
00:25:27 <tdammers> Lokathor: and you can import all of its imports into the same namespace
00:25:46 <Lokathor> tdammers, the module being re-exported will have its own ~1000 definitions :P
00:25:55 <tdammers> module P where (module P, module Q); import Foo.Bar as Q; import Foo.Baz as Q; import Blah.Something as Q; ...
00:25:58 <ekr_> the issue should be reproducible on all arch systems with up-to-date packages
00:27:01 <Lokathor> tdammers, I'm making a "gl-simple" package, so each version imports the last version, adds its own stuff new to that version, and then exports it all
00:27:33 <Lokathor> it's not like a tree really, it's more like a linked list
00:28:03 <Lokathor> the trouble is just writing every single new thing into the export list each time is all
00:28:21 <tdammers> and I'm telling you you don't have to
00:28:26 <tdammers> you can just export modules wholesale
00:29:06 <Lokathor> so it's all under Q, in the example?
00:29:13 <tdammers> P and Q, yes
00:29:19 <tdammers> P is the module itself, Q is the imported module
00:29:36 <tdammers> importing just these two exports everything in them that can be seen from inside P
00:29:49 <tdammers> i.e., everything in P, and everything you've imported into Q
00:30:07 <Lokathor> tricky
00:33:11 <Lokathor> my other niggle is that haddock won't link symbols that aren't in scope even if they're within the package as a whole
00:33:42 <Lokathor> so if you put all the types in a module just for them, when their doc says "use this type with funcFoo", it won't highlight funcFoo
00:34:56 <centril> Given:   class Head2 (a :: *) (b :: *) where ;  and  data D2 a = D2 deriving (Head2 a)  then the variable a in Head2 refers to the variable in D2, right?
00:35:49 <centril> So; with DeriveAnyClass  you'd get  instance  Head2 a (D2 a) where ;  ?
00:42:13 <ertes-w> hllo
00:43:35 <ertes-w> Lokathor: it will, if you use the fully qualified name
00:43:48 <HotFelonJeremyMe> what is your story?
00:43:56 <ertes-w> Lokathor: "Use this type with 'My.Module.funcFoo'"
00:44:32 <ertes-w> Lokathor: caveat: it can't tell type constructors from value constructors
00:46:17 <Lokathor> ertes-w, NEAT!
00:55:21 <jchia> Is there a simple way to list all known operators in ghci? I'm looking for operators with precedence 3 and lower.
00:57:01 <HotFelonJeremyMe> is it possible to find a job just with php and mysql?
01:01:22 <liste> HotFelonJeremyMe: try asking that in ##programming
01:01:44 <HotFelonJeremyMe> i cant enter
01:01:57 <carbolymer> HotFelonJeremyMe, /j #php
01:02:36 <HotFelonJeremyMe> im asking for your personal opinion, because someone told me i have to know like a ton other languages as well
01:03:12 <HotFelonJeremyMe> @carbolymer invite only
01:03:13 <lambdabot> Unknown command, try @list
01:03:29 <HotFelonJeremyMe> @list
01:03:29 <lambdabot> What module?  Try @listmodules for some ideas.
01:03:59 <HotFelonJeremyMe> @listmodules
01:03:59 <lambdabot> activity base bf check compose dice dict djinn dummy elite eval filter free fresh haddock help hoogle instances irc karma localtime metar more oeis offlineRC pl pointful poll pretty quote search
01:03:59 <lambdabot> slap source spell system tell ticker todo topic type undo unlambda unmtl version where
01:04:20 <HotFelonJeremyMe> @list where
01:04:20 <lambdabot> where provides: where url what where+
01:04:35 <HotFelonJeremyMe> @list ?
01:04:35 <lambdabot> compose provides: @ ? . compose
01:05:08 <tdammers> HotFelonJeremyMe: you may want to talk to lambdabot in private. /msg lambdabot ...
01:09:29 <HotFelonJeremyMe> tdammers, can i talk to u in private? ')
01:09:41 <HotFelonJeremyMe> sexy
01:09:53 <tdammers> no
01:10:18 <HotFelonJeremyMe> :D dobt be so shy
01:11:43 <HotFelonJeremyMe> come on baby
01:11:49 <HotFelonJeremyMe> give it to me
01:12:08 <HotFelonJeremyMe> im so horny
01:12:41 * tdammers sighs
01:12:43 <tdammers> @where ops
01:12:43 <lambdabot> byorgey Cale conal copumpkin dcoutts dibblego dolio edwardk geekosaur glguy jmcarthur johnw monochrom quicksilver shachaf shapr ski
01:14:11 <HotFelonJeremyMe> @where ops
01:14:11 <lambdabot> byorgey Cale conal copumpkin dcoutts dibblego dolio edwardk geekosaur glguy jmcarthur johnw monochrom quicksilver shachaf shapr ski
01:15:06 --- mode: ChanServ set +o dibblego
01:15:36 --- mode: dibblego set +b *!*@gateway/web/cgi-irc/kiwiirc.com/ip.80.154.24.146
01:15:39 --- kick: HotFelonJeremyMe was kicked by dibblego (HotFelonJeremyMe)
01:16:59 <MarcelineVQ> phpmysql giveaways aside, it's interesting how you can tell exactly where things are going to go with a user just by whether they @list when lambdabot tells them to.
01:26:30 <ertes-w> and no, you can't find PHP/mysql jobs, at least not for sensible definitions of "job"…  if you're lucky, you can only just pay your therapist
01:27:23 <jvliwanag> Given an `Iso' a b`, is there an easy way to make this an `Iso' (Maybe a) (Maybe b)`?
01:28:12 <merijn> jvliwanag: That seems like it'd just be wrapping both conversions with "fmap"?
01:28:17 <tdammers> ertes-w: no, *YOU* can't find PHP/MySQL jobs that don't lead to extensive therapy sessions (nor could I)
01:29:01 <jchia> @tdammers: I heard FB is in need of lots of therapists :)
01:29:01 <lambdabot> Unknown command, try @list
01:29:06 <ertes-w> tdammers: true…  i forget that other people have much stronger stomachs than me
01:29:17 <jchia> tdammers: I heard Facebook is in need of lots of therapists :)
01:29:21 <merijn> jvliwanag: Looks like it already exists: Control.Lens.Iso.mapping
01:29:24 <tdammers> ertes-w: I file it under 'blissful ignorance'
01:29:25 <merijn> jvliwanag: "This can be used to lift any Iso into an arbitrary Functor."
01:30:50 <jvliwanag> ooh. nice. Hrm, quite confused with the `AnIso` bit. How is AnIso diff from an Iso?
01:31:33 <ertes-w> jvliwanag: if a function is asking for AnIso, it's asking for an Iso
01:31:34 <fabien> I want to do a game of life in haskell . i don't know which container use for my 2d grid . On internet i found different solutions but no one seems to agreed. Can someone help me ? Thanks
01:32:22 <ertes-w> fabien: if you're new to haskell, start with Set
01:32:41 <fabien> set ?
01:32:45 <merijn> ertes-w: Not (Int)Map?
01:32:53 <merijn> ertes-w: I don't see how you can use Set for a grid?
01:32:54 <ertes-w> fabien: the type (Set (Int, Int)) is equivalent to a bit field
01:32:55 <jchia> fabien: Not familiar with details. Is your grid finite or infinite?
01:32:58 <fabien> i'm learning haskell , i already read like 90 pages of learn haskell good ......
01:33:02 <ertes-w> a 2D bit field
01:33:04 <fabien> finite
01:33:29 <merijn> ertes-w: Oh, right, game of life...my brain skipped that and went straight for "2D grid for arbitrary game"
01:33:29 <ertes-w> merijn: Set (Int, Int) ≃ Int -> Int -> Bool
01:33:37 <ertes-w> =)
01:33:48 <merijn> ertes-w: Yeah, I was just imagining an issue where you store more than a Bool :)
01:34:11 <fabien> Ok, thank you 
01:34:25 <fabien> i dont understand exactly
01:34:26 <ertes-w> fabien: the Set interface is also very easy to learn…  you really just need to read the docs
01:34:28 <jchia> fabien: For set, I suppose it could be Set (Int, Int) denoting which cells are 'on'. You could also use a Vector (Vector Bool)) or Vector Bool where you do your own transformation between Int and (Int, Int) using mod. But, Vector Bool could be wasteful.
01:34:33 <fabien> ok ok
01:34:36 <ertes-w> fabien: https://hackage.haskell.org/package/containers-0.5.10.2/docs/Data-Set.html
01:35:25 <fabien> so Set is for checking if the cell is true or false and the (int , int) for coord
01:35:39 <fabien> so i should use a Vector for my grid ?
01:35:46 <fabien> list.Vector ?
01:35:49 <ertes-w> fabien: a (Set (Int, Int)) is a set of values of type (Int, Int)
01:35:55 <ertes-w> no, use Set
01:36:00 <fabien> oh ok
01:36:07 <fabien> sorry i missunderstood
01:36:17 <fabien> ill read the doc first 
01:36:20 <fabien> Thanks
01:36:20 <ertes-w> not your fault…  too many teachers =)
01:36:30 <fabien> y
01:37:24 <ekr_> so, my apologies if this is an easily google-able issue, but this is my log file: http://lpaste.net/359525
01:37:46 <ekr_> i can't seem to get it to work. should i try in a docker container with a ubuntu image?
01:38:14 <ertes-w> ekr_: are you using the 'cabal' command to build?
01:38:32 <ekr_> i'm using cabal to install QuickCheck from hackage
01:38:47 <ekr_> are people around here generally using stack? 
01:38:53 <ertes-w> ekr_: are you familiar with sandboxes?
01:39:03 <ekr_> yes, this is in a sandbox
01:39:08 <jchia> I only use stack. I'm completely lost about how to use cabal
01:39:15 <ertes-w> ekr_: many people use stack, but not everybody, e.g. i don't use it
01:39:25 <jchia> Although I started learning only about 2 years ago
01:39:27 <jvliwanag> tnx ertes-w  merijn for clearing up the Iso stuff. :)
01:39:45 <jchia> I'm guessing people who started early tend to use cabal more.
01:40:21 <ertes-w> ekr_: is this a package you're writing in the sandbox?
01:40:42 <ongy> I'm clearly not early and use cabal. Still eagerly awaiting new-install though
01:40:52 <fabien> There is something i don't understand i don't know why too . nothing about what i asked before . its the $ , i don't get it , all the explications on internet confused me 
01:42:12 <ekr_> hmm, apparently doing a force-reinstall of random-1.1 solved the problem, but the warning of breaking a number of other packages isn't too comforting
01:42:23 <ertes-w> fabien: a (Set Int) is a set of integers…  if you "import qualified Data.Set as S", then you can create sets through 'S.empty', 'S.singleton' and 'S.fromList'
01:42:32 <ertes-w> > S.fromList [1,2,3] :: S.Set Int
01:42:34 <lambdabot>  fromList [1,2,3]
01:42:45 <ertes-w> fabien: you can query for set membership
01:42:56 <ertes-w> > S.member 2 (S.fromList [1,2,3])
01:42:59 <lambdabot>  True
01:42:59 <ertes-w> > S.member 4 (S.fromList [1,2,3])
01:43:02 <lambdabot>  False
01:43:26 <ertes-w> fabien: and there are some fancier set operations you can do, but those are irrelevant to game of life
01:43:42 <tdammers> fabien: ($) is complicated in practice due to the way it needs to be polymorphic, but from a usage point of view, it's really simple. If you have a (b c), you can rewrite it as a $ b c. That's pretty much all there is to it - it does "nothing", just changes precedence
01:44:26 <ertes-w> ekr_: you may want to look at new-build, which supposedly does this a lot better – i haven't used it myself, but people i respect are praising it =)
01:44:37 <ertes-w> search for "cabal new-build"
01:45:44 <ertes-w> fabien: do you see how a (Set (Int, Int)) can represent the 2D grid of the game of life?
01:45:59 <fabien> i'm trying to do it 
01:46:06 <ongy> new-build is nice, and the cabal.projects also work well, but it's way more project based than "old" cabal, even with sandboxes
01:46:30 <fabien> and thanks you for the $ . i understand for the a(b c) but for example why there is really often a $ for the print 
01:46:36 <fabien> like print $ array
01:49:14 <ertes-w> fabien: it's just a style choice
01:49:22 <ertes-w> print (1 + 2)
01:49:24 <ertes-w> print $ 1 + 2
01:50:33 <Cale> f $ x = f x
01:50:45 <Cale> and $ is just defined to have really low precedence
01:50:45 <fabien> print 1 + 2 
01:50:50 <fabien> doesnt wor k?
01:50:58 <Cale> print 1 + 2 would mean (print 1) + 2
01:50:59 <ertes-w> fabien: print 1 + 2 = (print 1) + 2
01:51:07 <fabien> oh ok 
01:51:12 <fabien> i remember from the book
01:51:24 <Cale> The most important thing to remember about precedence is that whitespace binds more tightly than any infix operator
01:51:33 <Cale> (i.e. function application)
01:52:01 <fabien> binds more tightly
01:52:02 <fabien> ?
01:52:10 <ertes-w> fabien: "has higher operator precedence"
01:52:23 <Cale> Effectively has higher precedence, yeah
01:52:29 <Cale> though it's not actually an operator
01:52:45 <ertes-w> it kinda is =)
01:52:47 <Cale> f x * g y = (f x) * (g y) no matter which operator the * is
01:52:54 <ertes-w> there is just no visible symbol
01:53:12 <fabien> ok ok .
01:54:00 <ertes-w> imagine that in function applications there is an invisible symbol between a function and its argument…   this operator has the highest precedence among operators
01:55:15 <fabien> ok , i already understood that
01:55:26 <fabien> i think i see for the $ its ok =)
01:59:55 <fabien> if i want to create my 2 grid like for example with x = 10 and y = 10 
02:00:01 <fabien> how do i init my Set
02:00:06 <fabien> fromList ?
02:01:14 <jchia> fabien: Is it empty? If so, just use mempty.
02:01:28 <jchia> fabien: you can use fromList, too.
02:01:47 <fabien> All the cells are bool , i want to set all to False
02:01:52 <fabien> its mutable right ?
02:02:06 <ertes-w> fabien: the Set-based grid does not have fixed dimensions
02:02:19 <ertes-w> in fact if you use (Set (Integer, Integer)), it's an actual infinite grid
02:03:10 <ertes-w> the empty set is the grid that has all fields set to "false", or in conway terms "dead"
02:03:26 <ertes-w> and no, it's not mutable
02:04:40 <ertes-w> the way you set a field to alive or dead is by adding or removing its coordinates to/from the set, respectively
02:05:52 <ertes-w> > S.fromList [(0, 1), (1, 0), (-1, -1), (0, -1), (1, -1)]  -- this is the famous game of life "glider"
02:05:54 <lambdabot>  fromList [(-1,-1),(0,-1),(0,1),(1,-1),(1,0)]
02:08:05 <fabien> i dont understand everything
02:08:39 <fabien> if its true you add it in the list and if its not you dont , if it was true and you want to set it to false you just delete it from the Set so ?
02:08:52 <ertes-w> fabien: correct
02:09:18 <fabien> oh ok .
02:11:44 <fabien> what the fromList do ?
02:11:52 <fabien> the doc you sent isnt real explaining it
02:11:56 <fabien> the doc you sent isnt really explaining it
02:12:05 <ertes-w> :t S.fromList
02:12:07 <lambdabot> Ord a => [a] -> S.Set a
02:12:20 <ertes-w> fabien: any idea what it does?
02:12:28 <ertes-w> by looking at the type
02:12:41 <ertes-w> and perhaps the name
02:12:47 <fabien> it take a list and create a Set from it i guess
02:12:48 <fabien> aha
02:13:02 <ertes-w> there you go =)
02:13:20 <ertes-w> fabien: fromList is equivalent to starting from an empty set and adding the given elements to it
02:13:34 <fabien> ok ok
02:14:35 <ertes-w> fabien: or, for the sake of diversity, it's also equivalent to turning a list of elements into a list of singleton sets, and then taking the union of all those sets
02:15:30 <ertes-w> > S.singleton 1 `S.union` S.singleton 2 `S.union` S.singleton 3
02:15:33 <lambdabot>  fromList [1,2,3]
02:15:43 <ertes-w> > S.unions (map S.singleton [1,2,3])
02:15:45 <lambdabot>  fromList [1,2,3]
02:15:51 <ertes-w> > S.fromList [1,2,3]
02:15:53 <lambdabot>  fromList [1,2,3]
02:17:05 <fabien> for the game logic i'm forced to use it the imperative way no ? like going through coordinate and see if the actual coordinate is in the Set etc
02:17:25 <fabien> for the printing i mean
02:17:54 <fabien> i do it on term .
02:20:31 <ertes-w> fabien: the game logic works like this: take all the live cells (that's just the current set), turn it into a list of all relevant neighbours (foldMap), then filter the set of neighbours by whether they are alive in the next iteration
02:20:40 <ertes-w> s/list/set/
02:21:23 <fabien> oh
02:21:51 <fabien> intelligent , and for print it ? how am i supposed to use the coordinate without looping ?
02:22:02 <ertes-w> for display for now it's easiest to just pick a window and draw it line by line, column by column
02:22:25 <fabien> its my first real little prog in functional =(
02:22:27 <fabien> ok
02:23:26 <ertes-w> for example draw everything in the rectangle (-15, -15) to (15, 15)
02:24:55 <ertes-w> @let neigh (x0, y0) = S.fromList [ (x, y) | x <- [x0 - 1 .. x0 + 1], y <- [y0 - 1 .. y0 + 1] ]
02:24:57 <lambdabot>  Defined.
02:25:04 <ertes-w> > neigh (4, 7)
02:25:06 <lambdabot>  fromList [(3,6),(3,7),(3,8),(4,6),(4,7),(4,8),(5,6),(5,7),(5,8)]
02:25:17 <ertes-w> these are all the neighbours of (4, 7), including itself
02:25:46 <ertes-w> > foldMap neigh (S.fromList [(-1,-1),(0,-1),(0,1),(1,-1),(1,0)])
02:25:48 <lambdabot>  fromList [(-2,-2),(-2,-1),(-2,0),(-1,-2),(-1,-1),(-1,0),(-1,1),(-1,2),(0,-2)...
02:25:55 <ertes-w> these are all the neighbours of the glider
02:44:46 <fabien> ok
02:44:52 <fabien> aha don't do everything =)
02:44:58 <fabien> Thanks you anyway
02:59:35 <ertes-w> fabien: i wasn't going to ;)
02:59:41 <ertes-w> this is just to give you the idea
02:59:54 <fabien> thank you , it really helped me
03:00:04 * ertes-w is giving up brick once again…  going back to vty-ui
03:00:57 <ekr> ertes-w: thanks for the new-build suggestion, and for the assistance
03:11:39 <merijn> Does Data.Set not have a symmetric difference function?
03:22:09 <liste> merijn: what's symmetric difference?
03:22:48 <merijn> liste: "difference (union a b) (intersection a b)"
03:22:58 <merijn> liste: i.e. any element that is not in both
03:23:05 <liste> oh, so like XOR
03:23:08 <merijn> yeah
03:37:17 <mikail_> Is the concept of Functor in Haskell equivalent to the concept of a Functor in category theory?
03:42:23 <liste> mikail_: https://stackoverflow.com/a/3273484/1283954
03:42:30 <cocreature> mikail_: no, Haskell functors are endofunctors on the category Hask. you can’t express arbitrary category theory functors via the Haskell typeclass
03:43:11 <mikail_> cocreature: that's confirmed my thinking - there is only one category so the category-theoretic definition is a mute
03:43:37 <cocreature> well endofunctors are interesting even in category theory
03:43:58 <liste> there can be other functors emerging in Haskell code besides Functors
03:44:34 <mikail_> liste: which other ones?
03:44:39 <liste> mikail_: http://www.haskellforall.com/2012/09/the-functor-design-pattern.html
04:14:48 <_sras_> What is the "ghc-worker" process that is eating 100% of my cpu, when I am running a Servant web application in an open GHCI instance?
04:25:18 <Profpatsch> So, I want to do a generator for values, a bit like QuickCheck’s arbitrary.
04:26:07 <Profpatsch> I’m using recursion-schemes’ ListF as base functor to build the generated list.
04:27:07 <Profpatsch> Now, when generating a list of ints, I have two cases: One that generates the empty list and one that generates a list with elements.
04:27:40 <Profpatsch> Am I correct in that I need a futumorphism to build this?
04:30:02 <Profpatsch> Oh, apo seems to be enough.
04:31:13 <na2th> Do you have a resource where I could read about those concepts? i.e., futuremorphism and ... apomorhism(?)
04:31:27 <na2th> I have no idea on how to help you, clearly
04:32:01 <Profpatsch> na2th: Oh, if you don’t know these concepts already, it will be a bit hard to help me. :)
04:32:18 <Profpatsch> Took me about a week to get a basic intuition on how that stuff works.
04:32:56 <Profpatsch> na2th: But if you are interested, here’s an awesome 4-part introductory series http://blog.sumtypeofway.com/an-introduction-to-recursion-schemes/
04:34:54 <na2th> Profpatsch: Thank you very much! I'll take a look and enjoy the week thinking about it
04:35:07 <Profpatsch> have fun. :)
04:42:10 <samae> Where is a list of hints to be used with hlint (and where do I find an explanation of how the .hlint.yaml configuration file works)?
04:42:20 <lyxia> If you have a fixed seed ana or apo works, but I can't see how to do it with an opaque monadic Gen
04:42:35 <Profpatsch> lyxia: No monadic Gens or anything.
04:42:40 <Profpatsch> Just plain values.
04:42:46 <Profpatsch> So no typeclasses.
04:43:38 <Profpatsch> I basically have a map of „types“ (aka strings) to Coalgebras.
04:43:50 <Profpatsch> These can recursively call each other.
04:45:19 <Profpatsch> Simple types like bool just do it like `const (Cons [True False] Nil)`
04:46:15 <lyxia> ok
04:46:43 <Profpatsch> ints are `i: (Cons [i, (-i)] (i+1))`
04:47:04 <Profpatsch> [0, -0, 1, -1, 2, -2, ..]
04:47:58 <Profpatsch> lists should be something like `const (Cons [] (Cons (??) Nil))`
04:49:00 <Profpatsch> To skip the inference part, assume the type is not generic over elements, but something fixed like [Int]
04:50:01 <Profpatsch> (I have type inspection, so I can get the wrapped type and recurse on that with decremented depth)
04:52:01 <Profpatsch> I get the feeling I need to either switch to something like a rose tree functor instead of ListF, or maybe recurse with ana/apo at the ?? part.
05:00:00 <Profpatsch> Oh, I think I solved it.
06:13:37 <Psybur> Anybody know of the best way to represent Text as a Storable?
06:14:33 <EvanR> a Vector.Storable ?
06:14:54 <Psybur> Yes
06:15:18 <EvanR> for some value of best, encode the text as utf8 then convert the bytestring to storable vector of word8
06:15:48 <Psybur> EvanR, thanks
06:18:15 <c_wraith> A bunch of libraries expect UTF-16, like basically all windows libraries and libicu
06:18:30 <c_wraith> Be sure that the format you're using is compatible with what the library expects
06:19:14 <c_wraith> (and when dealing with UTF-16, you suddenly have to deal with endianness too)
06:19:23 <EvanR> yay
06:19:49 <EvanR> (why in the world did windows go with utf16)
06:20:11 <c_wraith> It decided on 16-byte characters in the same period as java did.
06:20:44 <Profpatsch> Diiiid you know that Text …
06:20:46 <c_wraith> and retroactively decided they meant UTF-16 when it turned out there were more than 65536 characters.
06:21:21 <Psybur> You know these Texts are date times. It might be less of a hassle to just parse them and convert to seconds
06:21:24 <ventonegro> Windows started with UCS-2, then moved to UTF-16
06:21:26 <c_wraith> Well, except windows doesn't even default to UTF-16, exactly.  It defaults to 16-bit characters.  How they're interpreted is a function of the language setting
06:21:47 <c_wraith> Like, if you have windows set to use Big5, it's not even unicode.
06:21:48 <Profpatsch> c_wraith: That sounds like the worst of both worlds.
06:21:57 <Profpatsch> While at the same time the least amount of work.
06:22:06 <EvanR> Psybur: how about LocalTime instead?
06:22:08 <c_wraith> Profpatsch: it's an unfortunate reality when dealing with systems that don't want unicode
06:22:13 <Psybur> EvanR, is LocalTime storable?
06:22:18 <EvanR> or UTCTIme
06:22:21 <Profpatsch> c_wraith: Unicode as in UTF-8? ;)
06:22:24 <Psybur> I know data.thyme has Unbox but I dont see storable
06:22:35 <EvanR> Text isn storable
06:22:56 <EvanR> storable is when you can poke it into a fixed size cell of memory
06:22:58 <c_wraith> Profpatsch: unicode as in the specification.  There are windows language settings that don't use it.  Or ASCII.  Things like big5
06:24:30 <EvanR> Psybur: you could represent a utc date time as a day number and seconds past midnight, or a Word64 number of seconds
06:25:02 <EvanR> the number of seconds is actually ambiguous but is standard on unix
06:25:14 <Profpatsch> EvanR: Leap seconds?
06:25:32 <c_wraith> Profpatsch: Big5 represents a character set that is neither a subset nor superset of unicode.  It's handled by some windows language settings.  I imagine that's as ugly as it sounds.
06:25:35 <EvanR> which nobody supports
06:26:02 <c_wraith> POSIX time pretends leap seconds don't exist.  I think that's why it's popular.
06:26:46 <c_wraith> but that also means it's ambiguous and non-monotonic.  Fun!
06:26:50 <EvanR> the various abstract versions of time and their interactions are funny!
06:26:54 <Profpatsch> “The inability of ASCII to support large character sets such as used for Chinese, Japanese and Korean led to governments and industry to find creative solution”
06:26:56 <Profpatsch> *s
06:27:51 <Profpatsch> “creative solutions” must be the biggest euphemism ever used to describe character encodings.
06:28:04 <ertes-w> wow, i forgot how annoying it is to make widget-based UIs
06:28:22 <c_wraith> Yeah, for all the terror unicode has unleashed...  It is actually an improvement over previous systems.
06:38:20 <Psybur> Hmm, so a tuple of storables isnt storable? D;
06:38:54 <Psybur> Guess more than one storable would overflow a memory cell huh
06:39:14 <opqdonut> weird
06:39:29 <opqdonut> what do you mean by overflowing a memory cell?
06:39:34 <c_wraith> The original intended use for Storable is representing C data structures
06:39:48 <c_wraith> Tuples don't correspond to a C data structure.
06:40:17 <opqdonut> the instance for ratios is pretty much the instance you'd write for tuples, https://hackage.haskell.org/package/base-4.10.0.0/docs/src/Foreign.Storable.html#line-236
06:40:33 <Psybur> Suppose you dont know a cheeky way of packing 4 CDoubles into one number :D?
06:40:37 <Psybur> Or one storable
06:41:10 <opqdonut> just write the storable instance?
06:41:45 <Psybur> opqdonut, capital idea :P
06:42:25 <opqdonut> I'm not quite clear myself on when to use Storable vs. Binary
06:42:49 <opqdonut> there is a (Binary a, Binary b) => Binary (a, b) instance
06:42:54 <c_wraith> Storable is for marshalling a data structure for bidirectional use in the FFI
06:43:17 <c_wraith> If all you want is to serialize data, that's much easier.
06:43:20 <Psybur> opqdonut, in my case I need storable because Im using a C library D; Starting to think maybe I should just use C heh
06:44:13 <Psybur> Trying to get a sliding window of ~5000 on two million lines to actually finish -_-
06:45:21 <c_wraith> In particular, a type should be Storable if it exactly corresponds to a C data type, either primitive or from a library.
06:45:48 <Psybur> Tried loading up the entire file's columns into large storable vectors then slicing them up in windows, that didnt even complete on small windows. The other approach of creating a bunch of vectors after using lists for the windows actually completed (but not for large windows)
06:46:18 <c_wraith> 2 million lines isn't that much data, unless the lines are *really* long...
06:46:46 <c_wraith> Are you sure you aren't having issues on the processing side instead?
06:47:45 <Psybur> Most of the apps time before was dealing with the vectors
06:47:56 <Psybur> I saw 20% time there, and everywhere else was small
06:48:26 <Psybur> I see theres a storable-tuple package already made :o
06:53:30 <meinhof> what is haskell's philosophy for type bindings?
06:54:15 <cocreature> meinhof: I don’t understand that question, can you be a bit more specific?
06:55:02 <meinhof> like what is the main reason behind haskell's usage of inference
06:55:53 <cocreature> well having to specify types everywhere can get annoying so it’s nice to have the compiler do it for you
06:56:12 <meinhof> just trying to sort some things up
06:59:05 <EvanR> theres a lot of inspiration from math, the type of every variable in math is not explicitly declared. people learn to infer the type to save space on the page and make it easier to read at a glance
06:59:28 <oherrala> and there's really no point in stating the obvious
06:59:38 <EvanR> ^
07:00:08 <oherrala> if it looks like a number, then the type probably is some kind of number
07:00:44 <Profpatsch> Now that sounds like duck typing. :)
07:01:34 <EvanR> record types / object types are basically a sound version of duck typing, and a lot can be inferred
07:01:34 <oherrala> Profpatsch: If it qucks, it's probably duck
07:03:31 <EvanR> x.foo, looks like x is a record or object with a foo field
07:03:43 <Profpatsch> HasFoo
07:03:46 <Profpatsch> class Fooer
07:03:48 <EvanR> uhg
07:04:04 <Profpatsch> cluck typing
07:04:46 <Profpatsch> That’s great, I will declare that the official name for using HasX classes everywhere.
07:04:56 <Profpatsch> Cluck Typing
07:16:18 <saurabhnanda> how do I turn only this into an error ==> -Wmissing-fields	
07:17:22 <lyxia> You can only turn all enabled warnings into errors
07:18:13 <cocreature> that’s no longer true with 8.2
07:18:23 <cocreature> you can use -Werror=missing-fields
07:18:31 <cocreature> but before that lyxia is right :)
07:49:54 <anelson> hi all, how do I evaluate a type family in GHCi? I.e. I have a type `type Foo = SomeTypeFamily Bar Baz` and I want to see what that type "evaluates to", is that possible? Because in GHCi it's just showing me the original definition
07:50:20 <sbrg> yes, `:kind! <type>`
07:50:51 <anelson> sbrg: ah, thanks! that did it
07:54:46 <lyxia> cocreature: :O
07:55:04 <lyxia> Nice!
07:57:40 <Profpatsch> Huh, what’s a functional (non-index-based) way to create a tupled list of two lists, like (,) <$> [1,2] <*> [3,4], but “fair”
07:57:57 <cocreature> Profpatsch: “fair”?
07:58:40 <Profpatsch> Where fair in this case would be (indices) [(0,0), (1,0), (0,1), (2,0), (1,1), (0,2), ..]
07:59:00 <Profpatsch> Intuitively diagonals from the left corner.
08:06:18 <glguy> ertes-w: Why the brick->vty-ui switch?
08:07:42 <Profpatsch> Hm, the law seems to be that you list all elements of the same “depth” first.
08:07:54 <cement> is there a way to show the number of open handles?
08:07:58 <ertes-w> glguy: because it would have taken me a lifetime to display a bunch of sequential modal lists with multi-select
08:08:40 <ertes-w> glguy: in fact i even gave up vty-ui, because it was marked as broken in nixpkgs (i didn't investigate why)…  ultimately i did it with a shell script and 'dialog'
08:09:38 <glguy> vty-ui is probably broken because it's unmaintained in favor of brick
08:10:08 <ertes-w> glguy: i wish it wasn't…  i didn't think there is anything wrong with vty-ui
08:10:12 <c_wraith> doesn't brick depend on vty-ui?
08:10:25 <byorgey> no, it depends on vty
08:10:29 <c_wraith> ah, ok
08:10:39 <byorgey> on the Hackage page for brick it says "This package deprecates vty-ui"
08:11:00 <c_wraith> some packages claim to deprecate something they depend on. :)
08:11:43 <ertes-w> it wasn't as cleanly designed as brick for sure, but honestly i felt like with vty-ui you could actually get stuff done, and it was very easy to write the glue code between vty-ui and FRP frameworks
08:15:02 <ertes-w> Profpatsch: check out the 'logict' package
08:15:27 <Profpatsch> ertes-w: Yes, that’s what I have open actually. :)
08:15:29 <Profpatsch> https://hackage.haskell.org/package/logict-0.6.0.2/docs/src/Control-Monad-Logic-Class.html#%3E%3E-
08:16:09 <Profpatsch> I should probably copy the implementations, expand and specify to []
08:16:26 <ertes-w> Profpatsch: why not just depend on logict?
08:16:36 <Profpatsch> But thanks for confirming that I’m going in the right direction. :)
08:17:12 <Profpatsch> Ah, because I’m doing a naïve reimplementation of smallcheck in nix
08:33:35 <saurabhnanda> lyxia: cocreature: thanks.
08:41:18 <Matthias__> Hi!  I'm getting a bunch of linker errors (looks like they have something to do with PIE?) when trying to build my stack project on ArchLinux: http://lpaste.net/359536
08:41:50 <Matthias__> The closest thing I found online was https://github.com/commercialhaskell/stack/issues/2712 but that was from last year, and their fix/workaround didn't really work for me.
08:46:20 <Profpatsch> ertes-w: You were right [1,2,3,4,5] >>- \i -> [1,2,3,4,5] >>- \j -> pure (i+j)
08:46:22 <Profpatsch> [2,3,3,4,4,4,5,5,6,5,5,6,6,7,6,6,7,7,8,7,8,8,9,9,10]
08:46:34 <Profpatsch> while [1,2,3,4,5] >>= \i -> [1,2,3,4,5] >>= \j -> pure (i+j)
08:46:36 <Profpatsch> [2,3,4,5,6,3,4,5,6,7,4,5,6,7,8,5,6,7,8,9,6,7,8,9,10]
08:47:10 <Profpatsch> I have no idea how that works, though. The definitions are simple enough.
08:48:09 <ertes-w> Profpatsch: it's probably doing diagonalisation
08:49:11 <Profpatsch>     m >>- f = do (a, m') <- maybe mzero return =<< msplit m
08:49:12 <Profpatsch>                  interleave (f a) (m' >>- f)
08:50:38 <Profpatsch> It looks at the first element (inserting [] if none) and interleaves the fn with the rest recursively.
08:50:43 <Profpatsch>     interleave m1 m2 = msplit m1 >>=
08:50:44 <Profpatsch>                         maybe m2 (\(a, m1') -> return a `mplus` interleave m2 m1')
08:51:01 <nicknight> Hi, I read somewhere on internet....if one can learn haskell in 9 months he can learn rest all the languages in 2 months lol is it true?  But I learned basics from a mooc in 2 weeks
08:51:03 <Profpatsch> So the logic has to be in interleave?
08:52:51 <Profpatsch> Hm, interleave recurses in the reverse direction, maybe that’s it?
08:54:00 <ertes-w> Profpatsch: if i were to implement this, i'd most likely start with a fair 'join'…  disclaimer: not sure if it will be any better or work at all
08:55:42 <ertes-w> @let fairJoin = join . transpose
08:55:44 <lambdabot>  Defined.
08:56:06 <ertes-w> @let xs >>- f = fairJoin (map f xs)
08:56:07 <lambdabot>  Defined.
08:56:45 <ertes-w> > "abcd" >>- \c -> "1234" >>- \n -> [[c,n]]
08:56:47 <lambdabot>  ["a1","b1","c1","d1","a2","b2","c2","d2","a3","b3","c3","d3","a4","b4","c4",...
08:56:53 <ertes-w> ah, nevermind
08:57:26 <ertes-w> but yeah, with fairJoin you should be able to define (>>-) like that
08:57:37 <Profpatsch> > [1,2,3,4] >>= \i -> [1,2,3,4] -> \j -> pure (i+j)
08:57:40 <lambdabot>  <hint>:1:31: error: parse error on input ‘->’
08:57:46 <Profpatsch> > [1,2,3,4] >>= \i -> [1,2,3,4] >>- \j -> pure (i+j)
08:57:50 <lambdabot>  [2,3,4,5,3,4,5,6,4,5,6,7,5,6,7,8]
08:58:39 <mud> nicknight: Doubt it
08:59:46 <Matthias__> nicknight: eg C++ will take you much longer to learn then Haskell.  (Just say No.)
09:00:00 <mlehmk> what is it, when a function + data is applied to a state that results into a new state?
09:00:00 <Profpatsch> Haskell’s core is pretty small.
09:00:38 <Profpatsch> > [1,2,3,4] >>- \i -> [1,2,3,4] >>- \j -> pure (i+j)
09:00:42 <lambdabot>  [2,3,4,5,3,4,5,6,4,5,6,7,5,6,7,8]
09:01:04 <Profpatsch> > [1,2,3,4] >>- \i -> [1,2,3,4] >>= \j -> pure (i+j)
09:01:06 <lambdabot>  [2,3,4,5,3,4,5,6,4,5,6,7,5,6,7,8]
09:01:19 <Profpatsch> Ah, nvm.
09:01:32 <Profpatsch> That’s all just >>= in this case.
09:01:54 <Profpatsch> But it seems to be enough to use >>= >>- or >>- >>= in this case.
09:03:01 <byorgey> join . transpose  is not particularly fair.
09:03:12 <Matthias__> Profpatsch: I'd say OCaml is pretty small.  Haskell has a lot more you need to know in order to read a wide variety of code.  (The core needed to write code is small-ish, yes.)
09:03:22 <nicknight> Matthias__:  c++ tough than haskell  ? 
09:03:34 <Matthias__> nicknight: C++ is definitely harder than Haskell.
09:03:42 <Matthias__> Harder to learn and harder to write and harder to read.
09:04:08 <cement> I've never met people who were happy to use C++
09:04:31 <Matthias__> cement: May God bless your soul.  I've met people who do _like_ C++.
09:04:49 <Matthias__> Anyone have an idea how to fix my linker problems?  http://lpaste.net/359536
09:05:13 <Matthias__> Am having those problems on x64 archlinux recently with stack.
09:06:01 <Matthias__> nicknight: And alas, most of what makes C++ tougher is not hard concepts, but a haphazard design of the language (if you want to call it design).
09:10:39 <Profpatsch> Matthias__: No difference between assignment and definition makes the language a lot more lightweight than most others.
09:11:13 <Matthias__> Profpatsch: Haskell does have assignment, but we seldom use it.
09:11:26 <Matthias__> Assignment is necessary to work with IORefs.
09:11:34 <Profpatsch> Exactly. And it’s not built-in the main syntax.
09:11:35 <Matthias__> And similar.
09:11:58 <Matthias__> So I'd say, avoiding assignment most-of-the-time makes the language simpler. :)
09:12:08 <Profpatsch> It’s done via primitives that are interpreted by the runtime system and concretely typed.
09:12:44 <Matthias__> One big problem with C++ is that the language effectively has no abstraction mechanisms whatsoever.
09:12:48 <Profpatsch> As in: Can only be used in very explicit contexts (aka runSt and similar)
09:12:57 <Matthias__> What I mean by that is that basically all of its abstractions 'leak'.
09:13:21 <Matthias__> Hmm, forcing the use of the system ghc didn't help my linker problems..
09:13:31 <cement> I dunno, most libraries that I use end up requiring me to rtfs
09:14:07 <Matthias__> cement: What's rtfs?
09:14:23 <cement> "Read The **** Source"
09:15:11 <cocreature> Matthias__: do you have libtinfo installed?
09:15:48 <Matthias__> cocreature: I think so.  At least libtinfo was also just updated by arch (but it was broken before the update).
09:16:17 <cocreature> Matthias__: what’s the output of "pacman -Qs tinfo"
09:16:30 <Matthias__> cocreature: local/libtinfo 6-24
09:16:37 <cement> well, I should be fair, I haven't had to look at the source for Text or ByteString (except to laugh at that one unholy function)
09:16:46 <cocreature> try removing that and then run "stack setup --reinstall"
09:17:13 <Matthias__> Also, system ghc gives ghc --version -> 8.2.1, and stack ghci -- --version gives 8.0.2
09:17:16 <Matthias__> cocreature: will try.
09:17:31 <Matthias__> cocreature: remove the system tinfo?
09:17:31 <cocreature> stack doesn’t care about your system ghc (by default)
09:17:34 <cocreature> yes
09:18:07 <Profpatsch> cement: I have hackage source tabs open all the time.
09:18:16 <Profpatsch> Especially for class implementations and the like.
09:18:23 <mlehmk> Matthias__: https://github.com/commercialhaskell/stack/blob/master/doc/faq.md#i-get-strange-ld-errors-about-recompiling-with--fpic
09:19:26 <cement> the idealist in me wants every function and data type to be a black box, so needing to rtfs irks me somewhat
09:19:43 <Matthias__> mlehmk: Looks pertinent!
09:21:07 <Matthias__> cocreature: I'll try your suggestion first, and if that doesn't fix it, will try installing ncurses5-compat-libs as per mlehmk's link
09:22:15 <mlehmk> Matthias__, I don't know if that fixes it or what ncurses5-compat has to do with position dependent code
09:22:55 <Matthias__> mlehmk: me neither, but it specifically mentions the linker errors I'm getting _and_ archlinux.  So it's worth a try for me.
09:23:04 <Matthias__> I can work on understanding the black magic, if/when it works.
09:23:23 <cocreature> mlehmk: ncurses5-compat causes stack to choose different binary distribution which doesn’t suffer from these problems
09:24:48 <Matthias__> cocreature: Thanks.
09:25:03 <nicknight> Ok Matthias__  anyway I may never use c++ in my life
09:25:27 <Matthias__> nicknight: I sometimes let my employers talk me into C++, if they pay enough.
09:25:50 <jle`> everybody is a C++ programer...it's just a matter of price
09:26:03 <nicknight> Matthias__:  but I see all softwares were built in c++ right example most computing softwares
09:26:27 <Matthias__> jle`: Though to be honest, for the price I need for C++ you could hire someone who's actually good at it.
09:26:35 <Matthias__> nicknight: ?
09:26:55 <Matthias__> nicknight: a lot of software is written in C++, but not all, and not even the majority, by far.
09:27:07 <nicknight> 70% of chess engines in c++ octave,openfoam etc in c++
09:27:27 <nicknight> Due to speed may be
09:27:37 <nicknight> or performance*
09:27:50 <Matthias__> Performance (or perceived performance), inertia, local expertise.
09:28:28 <Matthias__> For my last employer (Bloomberg) those were the main causes, though not necessarily in that order.  (And with a big emphasis on perceived performance / perceived need for performance.)
09:28:28 <nicknight> any idea about rust ? I heard it is also super fast and alternative to c++ ?
09:28:41 <Matthias__> nicknight: Rust is fun.  Not sure if it's ready for the limelight.
09:28:47 <Matthias__> It's basically Haskell with C++ syntax. :)
09:28:55 <Matthias__> Lots of Rust people are ex-C++.
09:29:15 <cement> rust is actually pretty nice
09:29:27 <cement> it's got Maybe and Either (under different names
09:29:34 <Matthias__> I like Haskell a lot more than OCaml, but OCaml is probably an easier sell as a C++ alternative.
09:29:43 <Matthias__> (Mostly because OCaml has more predictable performance.)
09:30:09 <Matthias__> cement: even C++ can now do something like Maybe and Either etc.  (And there are working on adding even better support.)
09:30:19 <Matthias__> The main problem with C++ is not what you can do, but what you can _not_ restrict.
09:30:22 <nicknight> ocaml even used in indutry or acdemia I dont know 
09:30:41 <Matthias__> nicknight: OCaml has some uses in industry.  My last job was OCaml.
09:30:52 <Matthias__> But OCaml is a lot smaller community than even Haskell.
09:31:06 <mlehmk> C++98 already had every result being an Either anyway. A function could return a result or throw
09:31:25 <mlehmk> that's basically an Either
09:31:36 <Matthias__> mlehmk: Oh, I meant that C++ is adding better support for arbitrary sum types.
09:31:39 <nicknight> if SOme one primary language is haskell then what other languges he can check I will just set them as target after haskell 
09:31:55 <Matthias__> nicknight: what do you mean by that?
09:32:09 <nicknight> I like programming but I am not a programmer
09:32:13 <cement> my first language is/was haskell, and I liked what I saw when I was trying out rust
09:32:44 <Matthias__> nicknight: Excel is the world's most popular (functional) programming language.
09:32:54 <nicknight> so I tried python though easy I never liked its just 2 weeks haskell I am liking 
09:32:56 <Matthias__> cement: my first one was Commodore 64 basic.
09:33:11 <nicknight> I hate excel :(
09:33:13 <Matthias__> nicknight: if you want to learn Python, I can highly recommend "Think Python".
09:33:25 <nicknight> Matthias__:  I dont want to learn python
09:33:37 <Matthias__> ok. :)
09:33:53 <nicknight> Because every one like python too much which make me hate it 
09:34:03 <Matthias__> In any case, you can tell that Think Python (http://greenteapress.com/thinkpython2/html/index.html) is a good book for introducing CS, because even with Python they introduce function calls and recursion before loops.
09:34:06 <nicknight> Some uncommon reason and same with Java
09:37:53 <mutantmell> Does anybody know the reason AccumT (from transformers) doesn't have a monoid instance?
09:38:09 <mutantmell> I'm not sure if there's a limitation, or if it just doesn't have one.
09:38:42 <Matthias__> cocreature: Hmm, when I'm trying to install sudo aura -A ncurses5-compat-libs I'm getting complaints about unknown public keys.  You don't happen to know a hint about how to add that key?
09:39:03 <Matthias__> mutantmell: Could you write one?
09:39:39 <cocreature> Matthias__: try "gpg --recv-keys <keyid>"
09:39:41 <mutantmell> I believe so, not right now because I don't have the time
09:40:27 <mutantmell> Hoping someone knew offhand :P
09:40:37 <Matthias__> cocreature: That's seems to have done something.
09:41:13 <Matthias__> mutantmell: can you give me a link to AccumT on hackage, I'll have a look, perhaps I can tell.
09:41:41 <lyxia> https://hackage.haskell.org/package/transformers-0.5.5.0/docs/Control-Monad-Trans-Accum.html Matthias__ 
09:42:30 <mutantmell> Matthias__: sure, it's basically WriterT (implemented same as StateT)
09:42:38 <mutantmell> Matthias__: https://hackage.haskell.org/package/transformers-0.5.5.0/docs/Control-Monad-Trans-Accum.html
09:42:42 <Matthias__> mutantmell: What would the monoid instance do?
09:42:47 <lyxia> mutantmell: I think the issue is that there is no consensus on whether to pick (>>) or liftA2 (<>)
09:42:49 <Matthias__> You'd need to mappend the second parameter?
09:43:07 <Matthias__> lyxia: Exactly. :)
09:43:12 <mutantmell> ah, thanks
09:43:28 <mutantmell> that makes sense :)
09:44:04 <Matthias__> Same reason WriterT wouldn't have a Monoid instance, wouldn't it be?
09:45:08 <mutantmell> right
09:45:25 <mutantmell> time to make a newtype wrapper then
09:45:25 <lyxia> It's a way to avoid accidents. Sometimes there is an interesting monoid structure that arises in other ways, and then it's worth putting an instance for it.
09:45:31 <lyxia> like for lists
09:45:57 <mutantmell> ZipList vs List
09:46:00 <mutantmell> right?
09:46:15 <lyxia> But then there is another debate of whether every Alternative functor should be a Monoid
09:46:42 <lyxia> mutantmell: no, I mean the type of lists is a Monoid with the binary operation (++)
09:47:42 <Matthias__> lyxia: though be careful, we usually just say list, but Haskell makes a difference between [a] and [].
09:47:44 <Psybur> lyxia, is there a case when an Alternative wouldnt be a monoid?
09:47:57 <Matthias__> [a] can be a Monoid, but [] can't: wrong kind.
09:48:06 <Matthias__> And that's the problem with AccumT here, sort-of.
09:48:06 <lyxia> Psybur: no
09:48:58 <Matthias__> cocreature: the gpg thing worked, but curses5-compat-libs didn't fix my linker errors.
09:49:06 <Matthias__> (Even after stack setup --reinstall.)
09:49:07 <lyxia> Matthias__: that's not the problem.
09:49:10 <Matthias__> Too bad.
09:49:53 <Matthias__> lyxia: I mean, it's obvious that the Monoid instance for AccumT a b should do mappend on the a; but what it should do on the b ain't clear.
09:50:22 <lyxia> I don't think there's a need to be careful here. The fact that "[] is a Monoid" is ill-kinded just means there's less room for ambiguity, which is fine.
09:50:48 <lyxia> Matthias__: Sure.
09:51:42 <Matthias__> lyxia: yes, and that's why we can be a bit sloppy when talking.  Just like mathematicians get away with not carefully distinguishing between f and f(x) most of the time.
09:58:46 <Matthias__> cocreature: Success!  The sed manipulations of https://github.com/commercialhaskell/stack/issues/2712 did the trick.
09:59:02 <Matthias__> (I remember them not working the last time, but perhaps it was only together with the compat package that they did?)
09:59:56 <cocreature> someone needs to come up with a better solution for how stack selects a GHC bindist
10:03:18 <raynold> ahh it's a wonderful day
10:04:18 * sm high-fives raynold 
10:04:41 <Matthias__> cocreature: I'd complain more, if I didn't get all the stack and ghc stuff for free..
10:13:30 <average> https://twitter.com/wsdookadr/status/923232092116328448
10:13:49 <average> do Haskell programmers ever feel the kind of memorable moments depicted in that gallery?
10:14:28 <shapr> average: sad to say, Gabriel Claramunt (creator of classic programmer paintings) is a Haskeller
10:14:53 <average> oh really? I didn't know
10:14:59 <average> well in that case, I'm a haskell programmer too
10:15:03 <average> I wrote like very basic stuff in Haskell
10:15:08 <average> so I get to call myself a haskell programmer
10:16:56 <sm> yes you do!
10:17:10 <Psybur> average, thats a fun website
10:17:54 <Psybur> I chained a resourcet, conduitm, rwst io do I get to call myself a haskell programmer? ;D
10:18:32 <sm> if it compiled, yes!
10:18:42 <Psybur> !
10:19:22 <Psybur> If I put haskell on my linkedin and resume will I be flooded by recruiter calls? >:D
10:19:35 <average> Psybur: yes, you are hereby granted the title "Haskell Programmista"
10:19:57 <average> Psybur: yes, you will be called by recruiters that expect the 10x programmer
10:20:29 <cement> I once did mapConcurrently over a list with 27,000 items, does that make me a haskell programmer?
10:20:56 <average> cement: yes, you sir are a Senior Haskell Scientist
10:21:35 <c_wraith> I will say, Haskell on the resume sure gets attention. even if it's irrelevant to the job in question.
10:21:36 * shapr hugs cement 
10:21:39 <Psybur> So how did you program a haskell? I made a forex strategy backtesting framework that fails to finish when I try to test a strategy based on support/resistance correlation breaking. Where support resistance is found using kmeans clustering. D;
10:21:53 <cement> unfortunately, the function I mapped opened that many sockets, so the program would then promptly crashed, but now I get to learn about Semaphores
10:21:59 <shapr> ooh, cool
10:22:35 <Psybur> Well, doesnt finish for any meaningfully large windows of time D;
10:23:42 <average> cement: shouldn't one know Semaphores from previous endeavours instead of learning them in the complexity monstruosity that is Haskell?
10:23:53 <average> I mean.. semaphores are not something specific to Haskell
10:24:02 <shapr> what if Haskell is your first programming language?
10:24:03 <average> they're specific to concurrent programming
10:24:09 <cement> haskell is my first language~
10:24:12 <average> shapr: why would it be? that would be insanity imo
10:24:21 <shapr> average: why would that be insanity?
10:24:32 <shapr> average: I teach programming really often, and people find Haskell much easier to learn.
10:24:33 <average> actually I take that back, I'm interesting how it plays out
10:24:37 <average> *interested
10:25:01 <shapr> average: thing is, Haskell code is like an equation, you can substitute in until you get the exact code
10:25:21 <shapr> That's not the case for Python, because lots of other things can be happening at the same time
10:25:24 <cement> well, I made this program from scratch and it crawls a network concurrently and makes a graphviz graph of the lldp neighbors
10:25:29 <shapr> some other code could modify your variable, etc
10:25:47 <average> cement: what's LLDP?
10:25:49 <monochrom> Haskell is a great first language if you grok highschool algebra. Haskell is a horrible first language if you flunk highschool algebra.
10:26:12 <average> cement: https://en.wikipedia.org/wiki/Link_Layer_Discovery_Protocol ?
10:26:17 <cement> yes
10:26:23 <average> oh, mkay
10:27:03 <c_wraith> monochrom, what if I learned to program before learning algebra?
10:27:20 <monochrom> Then I don't know.
10:27:34 <cement> relatedly, I'm having trouble finding a function that will return the current number of open handles
10:28:25 <c_wraith> I don't know if there is such a function.
10:28:30 <friendzoner> im definately in the wrong channel
10:29:04 <c_wraith> in theory you could get that info out of the IO manager... but just to complicate things, there can be multiple IO managers
10:29:43 <c_wraith> actually, I take that back. the IO manager can only tell you how many are in use, not open.
10:32:30 <Psybur> Anybody know if there is a way to unzip a conduit?
10:33:36 <average> https://i.imgur.com/LJ3SR6k.png
10:33:39 <average> ^^ from that website
10:33:57 <average> is there any truth to that?
10:34:14 <Psybur> This channel is one of the largest on freenode isnt it
10:34:15 <c_wraith> Psybur, that sounds like it would be a fanout operation, with all the trouble that implies in the conduit model.
10:35:34 <Psybur> c_wraith, that gave me zero ideas :D
10:37:00 <cement> can the IO manager close all unused handles?
10:38:08 <cocreature> Psybur: the easiest solution is usually to write things to a Chan (or two Chans) and then have multiple conduits read from those Chans
10:38:16 <average> https://i.imgur.com/uHc35LH.png
10:38:19 <average> how about this? ^^
10:44:44 <Psybur> cocreature, are you talking about stm-conduit ?
10:46:30 <cocreature> Psybur: no, you don’t need any specific package for that. you can do IO in a conduit so you can just write to a Chan normally. stm-conduit might make this easier, dunno
10:46:57 <Psybur> I cant find this Chan you speak of
10:47:19 <c_wraith> Control.Concurrent
10:48:36 <Psybur> cocreature, I see
10:48:41 <cocreature> I was more talking about the concept of Chans than any specific implementation. you can choose whatever you like here Control.Concurrent.Chan, Control.Concurrent.SMT.TChan, Control.Concurrent.Chan.Unagi, …
10:48:42 <Psybur> c_wraith, thanks
10:48:54 <cocreature> Psybur: btw hoogle is helpful for finding this stuff http://hoogle.haskell.org/?hoogle=Chan
10:49:28 <Psybur> cocreature, I was searching for conduit chan heh I didnt know about Chan already
10:49:41 <c_wraith> Psybur, fanout is generally problematic for conduit, though.
10:50:08 <Psybur> Yeah IM starting to think what I had before using conduit was better D:
10:50:30 <tinytusk> Psybur: I’m about to use conduit for a project. Are you having a bad time?
10:50:36 <c_wraith> Psybur, conduit is demand-driven. adding fanout makes that super-complicated and more likely to waste a lot of memory.
10:51:33 <Psybur> tinytusk, no a conduit is a pretty solid and scalable concept for the most part. Im just running into problems doing large sliding windows on ~2 million lines
10:52:03 <tinytusk> ah
10:52:05 <Psybur> I just remember my pre conduit code and some early conduit code I had would at least complete for some smaller windows I was using :D
11:01:55 <sm> c_wraith: agreed, I got hired for a php job due to mentioning haskell
11:02:49 <sm> so.. \o/ ?
11:03:06 <average> sm: you're the trendiest mofo the world has ever seen
11:04:05 <shapr> average: are you writing something neat in Haskell?
11:08:04 <average> shapr: yes, I wrote an empty program in Haskell, and sold it for $300
11:08:09 <shapr> huh, neat
11:08:20 <average> shapr: and I will soon market it
11:08:25 <shapr> good to hear
11:08:27 <average> shapr: there's already 30 interested customers
11:08:32 <shapr> marvelous
11:08:38 <shapr> What libraries did you use?
11:08:39 <average> shapr: and I'm soon starting a marketing campaign
11:08:43 <average> I used no libraries at all
11:08:49 <shapr> I've been digging into proto-lens
11:08:51 <Tuplanolla> That does sound like modern art.
11:08:52 <average> the program is 100% correct
11:08:59 <average> it has no faults, no syntax errors
11:09:02 <average> it just works
11:09:04 <sm> IN YOUR MIND
11:09:11 <average> not in my mind, in reality
11:09:41 <average> and I've invested in proving its correctness, I've spent 0 seconds on that
11:09:44 <average> and $0
11:09:48 <average> and I was able to prove it was correct
11:10:03 <shapr> I get to build a prototype at work, and Haskell is an acceptable option
11:10:32 <monochrom> This is why I don't like empty programs. They're too easy.
11:10:47 <average> I might even publish the proof soon, it's similar to this article https://twitter.com/wsdookadr/status/689483650115633153
11:10:49 <sm> I had to generate some labels with a very specific layout yesterday, and considered using diagrams
11:11:18 <monochrom> Did you know: Some C compilers accept empty programs too. With this, the empty program is the shortest quine.
11:11:28 <tinytusk> quine?
11:11:33 <monochrom> quine.
11:11:45 <Tuplanolla> This program won a competition, monochrom.
11:11:50 <monochrom> Yeah!
11:11:56 <Clint> the quine competition?
11:12:28 <average> it's the best program..
11:12:36 <average> no doubt
11:12:39 <shapr> average: have you used protobuf3?
11:12:42 <mutantmell> bug free
11:12:50 <sm> but instead I used a drawing program. A php script overlays data on the background pdf. I wonder how easy that is in haskell
11:13:02 <average> shapr: does protobuf3 have more than zero bytes? if it does, i don't want to know about it
11:13:19 <average> it must surely have bugs if it has bytes, and I want my programs to be perfect
11:13:26 <shapr> you can have protobuf values that are zero bytes, does that count?
11:13:47 <average> well, no, because you can have errors at serialization/deserialization
11:13:51 <average> or erros in transmission
11:13:59 <average> and that's too huge of a risk to take
11:14:25 <romanix> average, yes it can "launch the missiles"
11:14:31 <monochrom> There is no risk. You can't damage your computer by mere Haskell programs.
11:14:38 <average> romanix: yes, it could even do that, it's way too risky
11:14:48 <mutantmell> > ((++)<*>show)"((++)<*>show)"
11:14:51 <average> monochrom: you probably can, too risky
11:14:51 <lambdabot>  "((++)<*>show)\"((++)<*>show)\""
11:15:07 <average> plus.. who has time to solve bugs
11:15:10 <monochrom> OK, maybe you can, but I cannot, so I feel pretty safe.
11:16:05 <monochrom> The most dangerous thing I ever did is http://lpaste.net/358634
11:16:27 <shapr> average: do you want to build real actual programs in Haskell?
11:16:32 <shapr> that have more than zero lines?
11:17:07 <romanix> my longest haskell program:
11:17:12 <romanix> main = main
11:17:12 <average> shapr: I am selling my empty program for quite a bit of money
11:17:26 <Psybur> monochrom, wat
11:17:28 <average> why would I want to risk delivering excellence to my clientele
11:17:33 <monochrom> tee hee hee!
11:17:42 <Clint> how is this conversation still going
11:17:43 <shapr> average: in that case, perhaps move discussion of your empty program to #haskell-offtopic?
11:17:47 <shapr> Clint: it's not
11:17:58 <average> ok fine
11:19:01 <monochrom> The only time I heard the word "clientele" used when "clients" would perfectly fit, was when it referred to gangsters.
11:20:36 <monochrom> Anyway I have shown how to use Haskell to make curry for C.
11:21:34 <average> monochrom: that's because I am a gangster
11:21:55 <average>  #thuglife #eyeglasses-and-joint-slide-down-on-my-face
11:22:07 <average> ok, enough of this
11:22:13 <average> let's discuss some catamorphisms
11:22:14 --- mode: ChanServ set +o shapr
11:23:07 <tinytusk> http://www.haskellforall.com/2012/08/the-category-design-pattern.html <— The conclusion of this article says, “In future posts, I will expand upon this post with the following topics:”
11:23:29 <tinytusk> Does anyone know if a follow up exists, besides the post on the Functor design pattern?
11:29:13 <sm> after fixing todays random network issue, I proceed to hackage to satisfy my pdf curiousity, and the likeliest-sounding lib is FermatsLastMargin, by this Shae Erisson guy
11:29:37 <sm> uploaded 2008, should be stable I guess ?
11:29:41 <jle`> tinytusk: i have been following that blog pretty closely and iirc there wer eno further posts
11:29:52 <tinytusk> ok :(
11:30:00 <jle`> tinytusk: but also you can always ask gabriel on twitter, he's pretty active :)
11:30:11 <jle`> he used to be active on this channel too but not so much anymore
11:30:24 <tinytusk> I see.
11:30:32 <shapr> sm: oh man, that's so old
11:30:44 <shapr> sm: I really need to flush that and redo it
11:30:44 <tinytusk> jle`: May I PM you a question?
11:31:06 <sm> stack and cabal: NO WAY
11:31:07 <shapr> sm: I did find one or two pdf libs recently when looking into rewriting FLM
11:31:07 <jle`> sure! but if it's a technical one then you might get faster answers on this channel
11:31:40 <shapr> I know davean was looking for such libs at one point
11:31:42 <sm> shapr: yeah I see a good few of them now. One of them probably makes overlaying on a pdf easy
11:32:53 <shapr> I think I'd chosen one at some point as a good option, but I forget which one
11:37:23 * EvanR bows down to shapr's headgear
11:38:38 --- mode: shapr set -o shapr
11:38:43 <shapr> hats off!
11:38:52 <tinytusk> Does anyone here use Cloud Haskell in production?
11:48:35 <johnw> I'd forgotten about CH...
11:49:16 <lyxia> tinytusk: What does it do
11:49:46 <tinytusk> lyxia: It brings Erlang-style concurrency to Haskell.
11:50:17 <tinytusk> e.g. Processes can have “mailboxes” on which they send/receive messages, and the transport layer is handled for you.
11:50:40 <johnw> it even goes to the extent that you can pass functions in messages, as long as the remote side knows that function
11:51:02 <johnw> StaticPointers were added to GHC to support this use case
11:51:39 <johnw> so, a little more integrated than serializing values across RabbitMQ
11:52:05 <lyxia> oh yeah that's cool.
11:54:52 <lyxia> Cloud Haskell makes it sounds like it's kind of a different language, but isn't it just a library?
11:55:01 <johnw> just a library and some tooling
11:55:05 <tinytusk> It’s a suite of libraries.
12:02:23 <mutantmell> https://github.com/haskell-distributed
12:10:55 <pie_> im trying to figureout the signature i want for this but im not sure:
12:11:24 <pie_> i have a 2d array for which i want to write a recursive function that searches for elements in the array and returns a list of coordinate pairs
12:11:57 <pie_> for simplicity's sake we can just use the 1d case
12:12:40 <pie_> ([a]->b) -> iterator_state -> [a] -> [b]
12:12:42 <pie_> i think?
12:15:11 <lyxia> How do you know whether an element is one you are looking for? (a -> Bool)?
12:15:12 <romanix> pie_, perhaps something using Writer?
12:15:34 <pie_> *sorry i forgot to mention im using scheme xD
12:15:49 <Mins> Hello, I want to code a Queue without Lists (with constructors). Here is my code: http://lpaste.net/2019395847648706560 I don't know, what I need to do. Just started coding in Haskell.
12:16:07 <ski> "searches for elements in the array" is a bit vague
12:16:10 <pie_> romanix, whats that like?
12:18:10 <ski> Mins : data constructors (presumably `createQueue' and `enq') must start with upper case letter (or `:', in case they're infix operators)
12:18:56 <ski> do you want to define an operation `createQueue :: Queue a' (distinct from the data constructor) ?
12:19:14 <romanix> pie_, i'm guessing your function could have a signature [a] -> Writer [a] [a]
12:19:35 <romanix> pie_, where 'a' is your 1d coord type
12:20:06 <Mins> ski: Ops. No... 
12:20:31 <ski> hm, same question for `enq :: Queue a -> a -> Queue a' as well
12:21:50 <ski> Mins : any further question ? got it under control, now ?
12:22:38 <pie_> i think im finally starting to figure out why this seems a bit difficult
12:22:57 <pie_> so usually one does recursive stuff like this by consing the n-1 case to the current results
12:23:05 <pie_> *usually does recursive stuff by
12:23:42 <pie_> but i think i want to const the n-1 to the results while having the function return not just the result...
12:23:51 <pie_> because i need it to return the result and the iteration state?
12:24:53 <pie_> ill have a snippet in a moment i think
12:26:12 <romanix> pie_, that's why i suggest the Writer monad (or the State monad)
12:26:46 <pie_> ok, ill have to look into those at some point :) (im pretty new)
12:26:52 <cement> ok, somewhere my logic went wrong, because somehow my code is finding 12,216,687 IP addresses on a small-ish workplace network
12:26:54 <romanix> pie_, they allow you to carry around some context from function call to function call (in your case the search results)
12:27:19 <pie_> ive been using scheme just so that i cna get my head around recursion a bit better and then ill start haskell for the type system
12:27:51 <romanix> pie_, if you want to learn haskell why not start with haskell?
12:28:03 <pie_> i just didnt feel comfortable
12:28:17 <cement> scheme helped me wrap my head around recursion, it's not an inherently bad idea
12:28:20 <Mins> ski: I don't know what I'm doing. It's my homework and I've never coded in Haskell. I need to do it with Lists and with constructors, but the one with constructors I can't do.
12:28:24 <cement> SICP is still gold
12:28:56 <sm> what's the big deal about recursion ? 8-]
12:28:58 <pie_> this is what i have right now http://paste.call-cc.org/paste?id=9cd39e4d6072d3a9562e9839ff2adcbc266faddc
12:29:09 <romanix> pie_, well, that's why I'm learning haskell :)
12:29:20 <ski> Mins : apart from your (presumed to intended to be) data constructor names starting with lowerl case, and that you have separate type signatures for them (i'd say either you want to remove those type signatures, or you want to have those be separate operations, meaning you'll either have to rename those two operations, or the data constructors (which you'll need to rename anyway)) ..
12:29:32 <pie_> i figure i could just branch on whether the last result is a done signal and then return the whole result?
12:30:15 <ski> Mins : .. apart from that, the specification of the second data constructor is wrong. you should not mention values `x' and `xp', but rather the *types* of those, there in the `data' type definition
12:31:06 <Mins> sky : Thanks, I'll change it. The first constructor I've renamed to "CreateQueue", but the second i don't know how I should name it.
12:31:14 <ski> Mins : have you see how to use `data' type definitions before ? any particular examples ?
12:31:35 <ski> well, you could rename it to `Enq' (or `Enqueue', being less brief), for now
12:32:19 <ski> (i'd probably also rename `CreateQueue' to `Empty' or `EmptyQueue' or something like that. but you do as you wish)
12:33:31 <pie_> ok i think this should work? http://paste.call-cc.org/paste?id=9cd39e4d6072d3a9562e9839ff2adcbc266faddc#a1 (the bottom one)
12:34:55 <Psybur> Mins, have you seen http://learnyouahaskell.com/making-our-own-types-and-typeclasses ? Look at the data List a = part you could prbably modify that to make a queue
12:35:00 <ski> Mins : there's also a syntax error on line `11' in the paste
12:35:10 <Mins> "CreateQueue" and "Enq" is given by my teacher. I've used it to create the natural Numbers by "Null" and "Succ Nat"
12:35:51 <Mins> Thanks @ Psybur
12:36:42 <cement> if I'm making a list from a statement like "Set.toList (Set.difference (Set.union newSet (Set.fromList newList)) oldSet)", I should have a guarantee that the resultant list won't have duplicates, right?
12:37:23 <cocreature> cement: yes the result of Set.toList never contains duplicates
12:37:28 <Mins> Psybur : I'm not allowed to use list.
12:38:45 <peter789> :r
12:38:49 <peter789> oops, sorry :)
12:39:24 <Mins> ski : I've updated the code: http://lpaste.net/2019395847648706560
12:39:36 <Psybur> Mins, I mean you can modify that data type. That data type is not [] or what I think you are referring to as list. Thats just an example on how you would make your own list type
12:41:11 <cement> ok, so what does it mean when ghci terminates with its final message being just "Killed" on its own line?
12:41:16 <ski> Mins : (a) you forgot to adapt the data constructors in the patterns in the definitions of `isEmpty',`front',`dec'
12:41:57 <cocreature> cement: probably that it got a sigkill
12:42:03 <ski> (b) you wanted the `Enqueue' to store two things, right ? a queue, and an item that's enqueued after the end of it. in the `data' specification, after each data constructor, you specify types of the arguments/components you want it to store
12:43:29 <Psybur> Mins, but yeah I wonder if basically making your own List type and then making methods that only allow add/pop/peek is what your teacher wants. Because theres no guarantee that someone couldnt make their own function to access things in the middle of a value of that type D:
12:43:37 <ski> Mins : now, `a' is the parameter type (so if you have a `Queue Integer', then that's a queue of *integers*. in that case `a' is `Integer'), but the first thing, `Queue' is not a concrete type. you're saying "queue of". a queue of what ? a queue of integers, a queue of strings, &c. .. what should the type of the first component be ?
12:44:09 <ski> cement : maybe OOM ?
12:44:17 <Psybur> Now youve got me interested if its possible to ensure only push/pop/add can be enforced with types directly
12:44:33 <Mins> Ski: Okay, thanks... 
12:44:49 <rick-sanchez> Hello, is somebody using Esqueleto? do you know about some way to unValue tuples? e.g. (Value x, Value y, Value z) = (x,y,z) or some generic way to run functions in tuples? 
12:45:00 <cement> if my program somehow managed to actually collect data from 42000 ips, then maybe...
12:45:22 <Mins> Psybur : I'm still stuck. "Undefined type constructor "Entry"". Now I need to define the constructor Entry..?
12:45:51 <Mins> And ski : I've updated it in the patterns
12:46:17 <Psybur> I suppose this is where instances come into play?
12:47:02 <ski> `Enqueue Queue a (Entry a)' is now specifying that the data constructor `Enqueue' should take/pack three arguments/components, one of type `Queue' (no such thing, that's an error), one of type `a', and one of type `Entry a' (you haven't defined that type)
12:47:03 <Psybur> instance Queue f a ?
12:47:20 <ski> Psybur : no type class in sight ..
12:48:11 <ski> Mins : where did you get `Entry' from .. ?
12:48:44 <Mins> ski : nowhere, my teacher has written a constructor like this on the board...
12:49:03 <Mins> Basically I don't know what I'm doing now
12:49:13 <lilred> Noob question: if I have a type that supports operations like `get :: k -> Future v` and `put :: k -> v -> Future ()`, how can I represent it with optics? (Bonus: what if it's iterable, as something like `[Future (k, v)]`?)
12:49:30 <ski> Mins : you had a type signature for `enq', could you repeat it here ?
12:49:53 <Psybur> Mins, so you have to use algebraic data types to ensure FIFO?
12:50:16 <cocreature> lilred: sounds like you’re asking how you can make lenses when the getter and the setter need to perform side effects in which case the answer is sadly, you can’t
12:50:23 <Psybur> You cant make an instance using a traversable or something :D
12:50:25 <Mins> ski : enq :: Queue a -> a -> Queue a
12:50:28 <ski> ok
12:50:31 <Mins> Psybur : yes
12:50:38 <lilred> cocreature: so what would the right abstraction be here?
12:50:39 <Mins> How can I refer to someone here?
12:50:53 <ski> so this is saying that `enq' is supposed to take two arguments, one of type `Queue a', and one of type `a', before returning a result of type `Queue a'
12:51:04 <Mins> yes
12:51:30 <ski> now you've renamed `enq' to `Enqueue' (making it a data constructor). the format for specifying a data constructor is a little bit different from a plain type signature
12:51:40 <Psybur> ski, is it possible for an ADT to ensure FIFO? That seems like something an instance would be used for to me
12:52:05 <ski> (well, there is a way in which you could specify it with a type signature, using a language extension. it's not really that hard, but let's not go there just yet)
12:52:24 <Psybur> Theres no way in vanilla haskell? D:
12:52:43 <ski> Mins : you already have `data Queue a = ...', which means that the result type of all the data constructors in there will already be `Queue a'
12:52:57 <cocreature> lilred: what exactly are you trying to abstract over? do you have an example of the code you’re trying to simplify?
12:53:07 <Mins> ski : Yes...
12:53:26 <ski> Mins : now you need to specify the types of the *arguments* that `Enqueue' is supposed to take, after the `Enqueue' inside the `data' declaration
12:53:41 <Psybur> Mins, whats stopping you from using: data Queue a = Empty | Cons a (Queue a) deriving (Show, Read, Eq, Ord)
12:53:50 <lilred> cocreature: an instance would be a dictionary that's only available over the network, or the system environment variables (in which case the monad would be IO)
12:53:56 <ski> basically, like `Enqueue x xp', except that instead of `x' and `xp', you write the *types* of them
12:54:22 <Mins> And my type is "a"?
12:54:23 <lilred> cocreature: basically something that you can treat as a mutable dictionary when you're inside the right `do` block
12:54:32 <Psybur> @let data Queue a = Empty | Cons a (Queue a) deriving (Show, Read, Eq, Ord)
12:54:36 <ski> (btw, you forgot to upcase one of your data constructors in one of your function definitions)
12:54:36 <lambdabot>  Defined.
12:55:04 <ski> Psybur : they don't seem to want a `Cons'
12:55:05 <Mins> ski : I forgot two
12:55:22 <ski> oh, right
12:55:39 <cocreature> lilred: maybe just make a typeclass that provides the operations you care about?
12:55:52 <cocreature> or pass around a record
12:56:13 <ski> Mins : you should have two types after `Enqueue', in the `data' declaration of `Queue', because `Enqueue' is supposed to take/pack two arguments/components
12:56:13 <lilred> cocreature: but this is a *really* common pattern in my experience, so I was wondering if there was a particular abstraction that was best fit for it
12:56:49 <cocreature> lilred: it might be a relatively common pattern but I’m still not sure what you hope to gain by abstracting over this pattern
12:57:07 <lilred> cocreature: what do we ever gain by abstracting over patterns ;)
12:57:17 <cocreature> also the details tend to vary significantly, e.g., which operations can fail, …
12:57:34 <Mins> Eh... I think it's working now..?
12:57:49 <Mins> Updated it @ ski & Psybur
12:58:23 <cocreature> lilred: depends on the pattern, in the end you usually want to either be able to make something more reusable or simplify some code but in this case I just don’t see how either of that really applies
12:58:24 <ski> Mins : looks ok, yea
12:58:30 <cocreature> which is why I was asking for an example :)
12:58:39 * ski would still rename `CreateQueue' to `Empty'
12:59:02 <Psybur> @let enq Empty a = a `Cons` Empty
12:59:03 <lambdabot>  .L.hs:201:5: error:
12:59:03 <lambdabot>      Ambiguous occurrence ‘Empty’
12:59:03 <lambdabot>      It could refer to either ‘Lens.Empty’,
12:59:04 <lilred> cocreature: the idea would be to be able to swap out data sources without changing the code
12:59:16 <lilred> cocreature: anyway, thanks for helping me along :)
12:59:25 <Mins> ski: tbh me too. But... my teacher want's it like this. I want to write "dequeue", etc too.
12:59:34 <Psybur> @let data Queue a = QEmpty | QCons a (Queue a) deriving (Show, Read, Eq, Ord)
12:59:36 <lambdabot>  .L.hs:200:1: error:
12:59:36 <lambdabot>      Multiple declarations of ‘Queue’
12:59:36 <lambdabot>      Declared at: .L.hs:192:1
12:59:52 <cocreature> lilred: sounds like something I would make a typeclass for or pass records around
12:59:54 <ski> Mins : another thing is that one could use the standard type `Maybe' to represent that `front' and `deq' (or `dequeue') could fail, when passed an empty queye (what you called `CreateQueue')
13:00:07 <ski> Mins : ok
13:00:08 <EvanR> record-as-interface ftw
13:00:20 <EvanR> record type as interface, record value as implementation
13:00:23 <Mins> ski : we didn't learn "Maybe" yet
13:00:37 <Mins> It's our third lesson in Haskell
13:00:55 <ski> Mins : one could also make a combined operation from `front' and `deq', using `Maybe', so that one doesn't have to check two `Maybe' results ..
13:00:59 <ski> ok
13:01:23 <ski> using `Maybe', `isEmpty' isn't really needed
13:01:44 <Psybur> Mins, yeah looks like your ADT looks like that List ADT I referenced you to. Did that link I sent help or did ski help you get that far :D
13:01:54 <Mins> Thank you both! It's working. "front (Enqueue (Enqueue CreateQueue 2) 1)" is giving out the 2...
13:02:30 <Mins> The constructor I got there... but sky did the most to get me here
13:03:05 <Psybur> Mins, I noticed your isEmpty is more verbose than it needs
13:03:17 <ski> Mins : another issue is that, while this code works, it's not that efficient. basically your `Queue' is a (backwards) list, and everytime you `front' and `deq' it, you have to traverse all of it (enqueueing is fine, you just wrap the given queue, and the element that is to be put last, using a data constructor)
13:03:21 <Psybur> instead of isEmpty (Enqueue x xp) = False, I think you can do isEmpty _ = False
13:03:33 <Psybur> Anything thats not a CreateQueue would be a False right
13:03:39 <ski> well, or `isEmpty (Enqueue _ _) = False'
13:03:55 <ski> `_' means "ignore this input (or part of input)"
13:04:04 <Mins> Yes, a wildcard
13:04:16 <Mins> ski : I know it's... O(n) I think
13:04:20 <Psybur> Yeah I suppose you wouldnt want isEmpty 1 to work
13:04:26 <ski> with Psybur's suggestion, the *ordering* of the defining equations becomes important. with mine, it doesn't
13:04:51 <ski> it may not matter much here, but it's something to keep in mind as a trade-off
13:05:11 <Mins> I've done it with a wild card. In the "right" order.
13:05:55 <ski> (i suppose one should say that it's not just the ordering, but that `isEmpty _ = False' can't be understood in isolation. you can't just read it as a true fact about `isEmpty', you have to be aware of which inputs are caught by defining equations above)
13:06:38 <ski> Mins : anyway, now i'd like to show the alternative way to define `Queue', using type signatures for the data constructors :
13:06:42 <ski>   data Queue a
13:06:43 <ski>     where
13:07:14 <ski>     Empty   ::                 Queue a
13:07:25 <ski>     Enqueue :: Queue a -> a -> Queue a
13:07:42 <ski> (well, or with `CreateQueue' instead of `Empty')
13:07:56 <Mins> You can continue with "Empty"
13:08:19 <cement> what school are you at that they actually teach haskell?
13:08:54 <ski> so in this style, you list the type signatures directly, after `where', instead of listing data constructors (followed by types of arguments), separated by `|', after `='
13:09:23 <Psybur> ski, are we at the FIFO enforced by types part yet? :D
13:09:43 <ski> this style with signatures is called GADT (Generalized Algebraic Data Type) style. the style in your paste is called (plain) ADT (Algebraic Data Type) style
13:09:47 <Mins> ski: Ah, okay. With lists it's much easier
13:10:22 <ski> to actually try out the GADT style, you'll need to add `{-# LANGUAGE GADTs #-}' as the first line in your file, to turn on the `GADTs' language extension
13:10:38 <johnw> or just GADTSyntax, right?
13:10:44 <Mins> cement: In one with a very involved teacher... he want us to "learn" Haskell, Prolog and Sather-K this year... for learning the concepts of programming languages
13:10:45 <johnw> if you don't use any actual GADT features
13:10:51 <jle`> structurally enforced FIFO
13:10:56 <jle`> i have been nerdsniped
13:11:04 <jle`> oh wait you mean FILO, right
13:11:10 <jle`> er oh yeah, FIFO.
13:11:13 <jle`> ok
13:11:25 <Hafydd> Can't you just use {-# LANGUAGE GADTSyntax #-}?
13:11:44 <ski> (it's called *generalized* because you can define types in a more general way using this style, than with the ordinary style. but here you're not doing that. i was just thinking that perhaps you thought the GADT style looked easier to understand, here. anyway, it might be nice to know about, but you'll probably not going to need it in a while ..)
13:11:45 <Hafydd> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#declaring-data-types-with-explicit-constructor-signatures
13:11:58 <EvanR> jle`: the stack laws...
13:12:07 <EvanR> er, queue laws
13:12:08 <jle`> FILO is just lists
13:12:18 <ski> Hafydd : oh, i forgot about that
13:12:28 <ski> johnw
13:13:13 <jle`> i mean i guess the old double-stack method can be used for FIFO
13:13:19 <ski> Psybur : not quite sure what you want to enforce ?
13:13:26 <jle`> which is amortized efficient
13:13:41 <Psybur> ski, I thought you said it would be possible to enforce FIFO behavior in a type signature
13:13:49 <Psybur> Maybe I misunderstood something
13:13:49 <cement> somehow my program basically invented 12 million IPs and then ate 13.8 GB of RAM
13:14:04 <ski> you said
13:14:08 <ski> <Psybur> Now youve got me interested if its possible to ensure only push/pop/add can be enforced with types directly
13:14:36 <jle`> cement:  :v
13:14:41 <Psybur> Ah so it isnt possible? ;[
13:14:47 <ski> i don't know
13:15:00 <EvanR> jle`: im interested in proving properties of simple inefficient implementations that somehow carry over to the more efficient implementation
13:15:00 <ski> i don't even know what it is exactly that you want to enforce
13:15:24 <mizu_no_oto> jle`: double-stack is only amortized efficient if you use it ephemerally
13:15:26 <EvanR> like, assoc list vs data.map
13:15:33 <jle`> mizu_no_oto: is that true
13:15:36 <jle`> that makes me sad
13:15:47 <ski> @where PFDS
13:15:48 <lambdabot> http://www.amazon.com/Purely-Functional-Structures-Chris-Okasaki/dp/0521663504
13:16:06 <mizu_no_oto> Well, you can do the expensive step as many times as you want in a functional setting
13:16:49 <jle`> i guess you can use a skew heap where everything has the same priority
13:16:54 <mizu_no_oto> There's some more clever encodings that are amortized efficient even when used persistently. - see PFDS
13:17:39 <Psybur> Mins, so if somebody passed you one of your queues, they could directly access arbitrary elements. Like so: qSnd (Enqueue (Enqueue CreateQueue _) x) = x
13:18:12 <mizu_no_oto> https://www.cs.cmu.edu/~rwh/theses/okasaki.pdf <- Okasaki's thesis, which was fleshed out into his book
13:18:17 <Mins> Okay
13:18:34 <ski> @where Okasaki
13:18:34 <lambdabot> http://www.cs.cmu.edu/~rwh/theses/okasaki.pdf
13:18:52 <Psybur> ski, I think if you wanted to lock down FIFO in the type you send, youd have to lock it up in an instance?
13:19:16 <ski> i'm still not sure why you keep mentioning instances
13:20:21 <mizu_no_oto> jle`: see section 3.3
13:20:39 <Psybur> How would you prevent somebody from accessing random places in a Queue type you made? As Ive shown you can still do random access with the ADT. But if you make an instance Queue, the only way to access the elements is through the instance functions?
13:21:14 <jle`> mizu_no_oto: thanks :)
13:21:19 <geekosaur> you can just make it abstract the way Data.Map is: export only the type and accessor/mutator functions but not the data constructors
13:21:30 <mizu_no_oto> jle`: np :)
13:21:32 <ski> they could just dequeue repeatedly, to access "random places", no ?
13:21:45 <ski> are you going to forbid dequeueing ?
13:21:45 <Psybur> ski, no thats using the queue properly
13:21:58 <Psybur> I mean skipping elements and leaving the queue intact
13:22:22 <Psybur> What geekosaur said is valid I guess
13:23:03 <Psybur> But what if that wasnt an option? Would you need to make an instance?
13:23:08 <ski> you could convert the queue to a list, remove an element from the middle, then convert back to a queue, no ?
13:23:31 <Psybur> ski, thats still using a queue as a queue
13:24:02 <Psybur> What Im saying is if you have a queue type, how do you enforce that within the "queue context" FIFO is enforced
13:24:24 * ski is still not understanding ..
13:24:57 <geekosaur> they want to forbid access by any means not under control of your implementation code
13:25:19 <ski> by some means other than abstract data types ?
13:25:49 <Psybur> ski, well if it was possible with ADTs thatd be fine but none of us know if it is possible to enforce that strictly with ADTs
13:25:50 <geekosaur> the point being that using an exported function to make a list from it is fine, but directly pattern matching to get at the innards is not
13:26:04 <geekosaur> but using an accessor like dequeue is again fine
13:26:25 <geekosaur> Data.Map is an example of why and how you'd do this
13:26:59 <geekosaur> (in that cse 'why' is 'to maintain an invariant', which for Map is that it's sorted and kept reasonably balanced)
13:27:30 <ski> > M.insert 2 3 (M.insert 0 1 (M.insert 4 5 M.empty))
13:27:33 <lambdabot>  fromList [(0,1),(2,3),(4,5)]
13:28:05 <ski> shows how to do `Show' without leaking implementation (/ representation) details, in such a case
13:29:16 <Mins> Another question...
13:29:17 <Mins> Next question: I need to make a function nSqrt::Int->Int, which just get the root of n. If there is no exact root for n, it needs to be i² <= n < (i+1)² with i element of natural numbers.
13:29:30 <Mins> http://lpaste.net/3284232358764478464
13:30:09 <ski> you probably need an idea for an algorithm
13:30:23 <ski> how would you do this, with pen and paper ?
13:30:24 <Mins> Should I use the "sqrt"-function of Haskell?
13:31:02 <ski> i'd probably not use that
13:31:10 <Psybur> > isInt 2.5
13:31:13 <lambdabot>  error:
13:31:13 <lambdabot>      Variable not in scope: isInt :: Double -> t
13:31:24 <Tuplanolla> No, Mins.
13:31:34 <cement> there's a good example of an algorithm for that in SICP
13:31:45 <tdammers> a function to check the type of something at runtime is a rather silly idea in Haskell, isn't it
13:31:48 <cement> though SICP is a scheme book
13:32:02 <Psybur> @let isInt x = x == fromInteger (round x)
13:32:05 <lambdabot>  Defined.
13:32:06 <Psybur> > isInt 2.5
13:32:09 <lambdabot>  False
13:32:11 <Psybur> > isInt 2
13:32:15 <lambdabot>  True
13:32:17 <Mins> y= sqrt x -> if y isn't natural: round off
13:32:36 <Tuplanolla> > 4 ^ 3
13:32:39 <lambdabot>  64
13:32:42 <Mins> @ Ski
13:32:45 <Tuplanolla> > floor (64 ** (1 / 3) :: Double) -- Thus this ought to be 4.
13:32:48 <lambdabot>  3
13:33:01 <Psybur> > isInt (1/0)
13:33:04 <lambdabot>  True
13:33:18 <Tuplanolla> Similar counterexamples exist for `sqrt`, Mins.
13:33:49 <ski> there's an easy algorithm, involving odd numbers
13:34:13 <EvanR> @let isInt q = let (_, x) = properFraction q in x == 0
13:34:14 <lambdabot>  .L.hs:212:1: warning: [-Woverlapping-patterns]
13:34:14 <lambdabot>      Pattern match is redundant
13:34:14 <lambdabot>      In an equation for ‘isInt’: isInt q = ...
13:34:57 <Psybur> > isInt (1/0)
13:35:00 <lambdabot>  True
13:35:02 <EvanR> @let isInt2 q = let (_, x) = properFraction q in x == 0
13:35:05 <lambdabot>  Defined.
13:35:11 <Psybur> > isInt2 (1/0)
13:35:11 <EvanR> > isInt2 (1/0)
13:35:14 <lambdabot>  True
13:35:14 <lambdabot>  True
13:35:17 <EvanR> \o/
13:36:14 <ski> Mins : unless they suggested you could use floating-point numbers (or `sqrt' directly), i'd try another approach
13:36:39 <Mins> I must use "Int".
13:36:49 <mutantmell> NaN is an int now? :P
13:36:51 <Psybur> Have a good one, ladies~
13:36:54 <EvanR> yes
13:37:17 <EvanR> > isInt2 (0/0)
13:37:20 <lambdabot>  True
13:37:34 <geekosaur> properFraction is documented to not do the right thing with NaN or Int
13:37:37 <geekosaur> er Inf
13:37:45 <EvanR> whats the right thing?
13:37:49 <geekosaur> basically because there *is* no right thing
13:37:54 <EvanR> lol
13:38:05 <ski> Mins : have you ever tried putting square cards (or cube blocks) (all of the same size) into larger squares ?
13:38:05 <EvanR> undefined behavior?
13:38:06 <geekosaur> except being partial (i.e error "no proper fraction for this value")
13:38:11 <mutantmell> The right thing is for math to say "no thanks, I'm good"
13:38:57 <EvanR> the real line extended with points at infinity...
13:39:07 <Mins> ski : Eh... idk what you want to say me
13:39:10 <EvanR> inf + 0 = inf, seems legit :)
13:39:31 <mutantmell> the integers are a circle :P
13:40:08 <mutantmell> I remember when I first saw the complex plane + infinity projected onto the unit sphere
13:40:09 <geekosaur> math is unconfortable with infinities anyway :p
13:40:16 <mutantmell> That took a bit to accept :P
13:40:22 <geekosaur> as limits yes, as 'values' no
13:40:45 <ski>   0123⋯
13:40:47 <ski>   1123⋯
13:40:50 <ski>   2223⋯
13:40:52 <ski>   3333⋯
13:40:53 <ski>   ⋮⋮⋮⋮⋱
13:41:02 <ski> Mins : i mean like this
13:41:29 <ski> first you add the one marked `0'. then you add the ones marked `1', then the ones marked `2', then `3', &c.
13:42:35 <ski> now, if you're given a square, but you don't know "how big", this could give a method to determine the square side length (being the square root of the number of individual small "numbered" squares in there)
13:44:14 <EvanR> that grid looks like a cloud of danger in nethack
13:44:38 <Mins> ski: So I need recursion? And I look every time if n is bigger than the number..?
13:44:54 <ski> you probably need some way to iterate, yes, such as recursion
13:45:07 <Mins> ops. yes, iterate.
13:45:11 <ski> you could add, or you could subtract. up to you
13:45:45 <mutantmell> EvanR: I forget what numbers were in Nethack
13:45:47 <ski> this is not the most efficient algorithm, but it's fairly easy to understand
13:46:06 <mutantmell> oh right, there was a hat of warning or something
13:46:36 <mutantmell> *ring of warning
13:47:04 <ski> danger decreases the closer you get to the centre ?
13:47:10 <Mins> ski: I think I can't do it in Haskell. I can't use variables..?
13:47:23 <geekosaur> you can use parameters
13:47:29 <ski> Mins : have you heard of "accumulators" ?
13:47:37 <geekosaur> bindings (what you are likely thinking of as 'variables') are immutable
13:48:03 <Mins> ski: no
13:48:33 <Tuplanolla> What actually is the most efficient algorithm here, ski? For example Newton--Raphson suffers from gradient overflows on large inputs.
13:48:57 <ski> Tuplanolla : istr there's something that involves bit twiddling, that should be better than the above at least
13:49:18 <Tuplanolla> I've certainly never seen the general case.
13:49:55 <ski> (there is a (paper) square root algorithm that's a bit similar to the division algorithm, btw)
13:51:04 <dmwit> http://hackage.haskell.org/package/arithmoi-0.6.0.0/docs/Math-NumberTheory-Powers-Squares.html -- ?
13:51:41 <ski> <https://en.wikipedia.org/wiki/Square_root_algorithm#Digit-by-digit_calculation> (see the examples below)
13:52:21 <Tuplanolla> It uses `Integer`, dmwit.
13:52:41 <dmwit> Is that a problem?
13:52:55 <Tuplanolla> Considering the goal was to not, yes.
13:53:30 <dmwit> I... think we are having parallel conversations about very similar things.
13:53:52 <Tuplanolla> <Mins> I must use "Int".
13:54:22 <dmwit> http://hackage.haskell.org/package/arithmoi-0.6.0.0/docs/src/Math-NumberTheory-Powers-Squares.html#isqrtInt'
13:54:31 <dmwit> Heh, it uses actual `sqrt`.
13:54:38 <dmwit> I guess for `Int` that's probably fine.
13:54:50 <glguy> sqrt isn't accurate enough for large Int values on 64-bit machines
13:55:56 <dmwit> It always checks the value of `truncate . sqrt` and one neighbor, which it claims is enough.
13:56:05 <glguy> Tuplanolla: It'd be worth checking on that assumption. The originally offered solution was to go via sqrt and round off, so perhaps only the outside interface is expected to require Int
13:56:38 <tinco> can I have an Int be a type level argument to a function? so the int argument determines the return type?
13:56:40 <dmwit> Anyway, http://hackage.haskell.org/package/arithmoi-0.6.0.0/docs/src/Math-NumberTheory-Powers-Squares-Internal.html#karatsubaSqrt seems like it could be adapted to work on `Int`.
13:57:05 <glguy> dmwit: Oh, I wasn't accounting for performing fixups afterward, just that sqrt isn't accurate enough on its own
13:57:09 <dmwit> tinco: https://stackoverflow.com/q/46718726/791604
13:57:20 <tinco> I want a function generateIntervalData :: Data -> Interval -> IntervalData Interval
13:58:51 <tinco> eh oh.. hmm that's no problem I guess
13:59:02 <lyxia> type IntervalData a = a ; generateIntervalData = const id
13:59:37 <Tuplanolla> @let integerSqrt n = let f x y | y < x = f y ((y + n `quot` y) `quot` 2) | otherwise = x in f n ((n + 1) `quot` 2) :: Integer -- ...but that would be boring, glguy.
13:59:39 <lambdabot>  Defined.
13:59:53 <Tuplanolla> > fmap integerSqrt [1 .. 32]
13:59:57 <lambdabot>  [1,1,1,2,2,2,2,2,3,3,3,3,3,3,3,4,4,4,4,4,4,4,4,4,5,5,5,5,5,5,5,5]
14:00:18 <WinterCame> Hey folks! I'm new to haskell, and was curious if there are any packages for numerical computation on the level of numpy (python), for haskell?e.g. are Vector and Numerical good enough?
14:00:27 <mutantmell> > fmap integerSqrt [0..-2]
14:00:34 <lambdabot>  e
14:00:42 <dmwit> what
14:00:46 <mutantmell> e
14:00:48 <mutantmell> clearly
14:01:07 <dmwit> > "> fmap integerSqrt [0..-2]"
14:01:09 <lambdabot>  "> fmap integerSqrt [0..-2]"
14:01:15 <dmwit> > [0..-2]
14:01:17 <lambdabot>  error:
14:01:17 <lambdabot>      • Variable not in scope: (..-) :: Integer -> Integer -> a
14:01:17 <lambdabot>      • Perhaps you meant ‘...’ (imported from Control.Lens)
14:01:21 <mutantmell> WinterCame: I don't think there's a package as complete as numpy for haskell
14:01:27 <dmwit> mutantmell: cheater
14:01:37 <dmwit> You secretly ?undefined it!
14:01:47 <mutantmell> apparently :P
14:02:06 <mutantmell> > fmap integerSqrt [0..(-2)]
14:02:10 <lambdabot>  []
14:02:29 <EvanR> lol
14:02:42 <WinterCame> Mutantmell: Is any of the above mentioned ones suitable for building Deep Learning models? I need to build something for a class project, and would be allowed to use only the bare minimum of pre-existing packages (So HLearn, Grenade are right out)
14:02:44 <dmwit> Actually, no, I still don't understand. Surely no matter what funny business you did with `integerSqrt` and `(..-)`, the return type would be `[A]` for some `A`.
14:02:53 <dmwit> How did the `Show` instance for that arrive at `e`?
14:03:00 <mutantmell> dmwit: I have no idea what I did either, if that helps :P
14:03:02 <mniip> showList
14:03:07 <glguy> dmwit: It seem slike lambdabot just printed the first letter of the error message and died
14:03:11 <Mins> I'm still not knowing anything.
14:03:50 <glguy> Mins: You can either write your own or use the one dmwit linked to
14:03:59 <mniip> @let data D = D
14:04:01 <lambdabot>  Defined.
14:04:15 <mniip> @let instance Show D where show D = "D"; showList _ = "Ds"
14:04:17 <lambdabot>  .L.hs:171:22: error:
14:04:17 <lambdabot>      • Couldn't match type ‘[Char]’ with ‘String -> String’
14:04:17 <lambdabot>        Expected type: ShowS
14:04:33 <mniip> @let instance Show D where show D = "D"; showList _ = "Ds" ++
14:04:33 <lambdabot>  Parse failed: Parse error in expression: "Ds" ++
14:04:38 <mniip> @let instance Show D where show D = "D"; showList _ = ("Ds" ++)
14:04:40 <lambdabot>  Defined.
14:04:44 <dmwit> mniip: Phew, that's a lot of cleverness to pack into a privmsg in under a minute!
14:04:45 <mniip> > [D, D, D]
14:04:47 <lambdabot>  Ds
14:04:49 <Mins> glguy: Ah, I haven't seen it. Thanks @dmwit!
14:05:07 <dmwit> If that's what mutantmell actually did, I'm wildly impressed.
14:05:27 <dmwit> It's like... three separate cute corners of Haskell in one wild puzzle.
14:05:27 <mutantmell> I did nothing, I was just legitimately curious
14:05:51 <mutantmell> I mean, yes, I am a Haskell genious, and not someone just poking at lambdabot
14:05:54 * mutantmell shifts eyes
14:06:08 <dmwit> mutantmell++ Haskell genious [sic]
14:06:30 <mniip> :t integerSqrt
14:06:33 <lambdabot> Integer -> Integer
14:06:37 <mniip> well no, that's impossible
14:06:49 <mutantmell> > integerSqrt 0
14:06:53 <lambdabot>  0
14:06:55 <mutantmell> > integerSqrt (-1)
14:06:58 <lambdabot>  -1
14:06:59 <dmwit> mniip: He could have ?undefine'd it and redefined it with a different type. So add one cute corner of \bot to the three cute corners of Haskell.
14:08:48 <shapr> @seen wli
14:08:48 <lambdabot> wLi
14:08:50 <shapr> bah
14:09:00 <geekosaur> or anyone else could have
14:09:08 <dmwit> sure
14:09:11 <geekosaur> the downside of it being a shared sandbox
14:09:43 <monochrom> Almost all sandboxes in real life are shared public sandboxes in public parks.
14:10:15 <monochrom> Only a few very rich families actually order private sandboxes.
14:10:29 <dmwit> geekosaur: I can think of fixes, and all the ones I can think of would be confusing in other ways.
14:10:31 <monochrom> Apparently they prefer private pools to private sand.
14:10:52 <Tuplanolla> I want to unsubscribe from sand facts.
14:10:54 <geekosaur> yep
14:11:13 * geekosaur hands Tuplanolla a sand-filled boot
14:11:31 <glguy> Tuplanolla: Fun sand fact: most people want to unsubscribe
14:11:40 <monochrom> haha
14:13:24 <prooftechnique> I feel like private sandboxes were common in my childhood. Four wood planks and some sand doesn't seem wildly pricey.
14:13:46 <MarcelineVQ> it's the space to put it that's pricey now
14:14:12 <prooftechnique> Oh, maybe it's a rural thing, then.
14:14:39 <prooftechnique> Though I guess you could fit a small sandbox in most apartments if you were motivated
14:14:43 <geekosaur> once upon a time it wasn't. then came inflation and safety regs, etc.
14:15:20 <geekosaur> and even when I was a kid, there were relatively few sandboxes because parents would install one and then discover this meant snad constantly being tracked into the house
14:15:29 <geekosaur> or carried on clothes or even bare skin
14:15:53 <mud> Also, cats crap in them.
14:16:14 <tinytusk> Does anyone have any good reading for reflecting on free monads?
14:16:43 <tinytusk> I want to analyze a program without running it.
14:16:59 <monochrom> Just use pattern matching?
14:17:11 <Sornaensis> you and everyone else
14:18:05 <tinytusk> I spoke about this last night. I wish to generate a PNG from a program showing all the execution paths.
14:23:45 <dmwit> tinytusk: https://en.wikipedia.org/wiki/Control_flow_analysis might be a worthwhile starting point if you have literally no idea about the state of the art in that domain
14:24:01 <dmwit> If you do have a bit of knowledge, then you might want to ask a more targeted question.
14:27:33 <tinytusk> Last night I was told that if “f” in (Free f a) was a polynomial functor, I can achieve my goals.
14:28:21 <tinytusk> While I understand the basic algebra (Data Maybe a = Nothing | Just a) ==> 1 + x, and (a -> b) ==> b^a, I don’t understand why this is the case.
14:28:39 <tinytusk> What makes polynomial functors special?
14:30:21 <monochrom> You know that with "data Maybe a = Nothing | Just a" you can do pattern matching, right?
14:30:57 <tinytusk> Sure
14:31:00 <monochrom> If I have "xxx :: Free Maybe Int" you can actually use pattern matching and a few other common functions to find out what's in xxx, you know that?
14:31:27 <tinytusk> Yes.
14:31:37 <monochrom> That is all.
14:31:55 <tinytusk> But, why did people bring up “polynomial functors"?
14:32:45 <monochrom> Because Maybe generalizes to polynomial functors.
14:33:11 <monochrom> If I have "yyy :: Free ((->) Float) Int" you'll have a harder time.
14:33:24 <tinytusk> Ah, ok
14:33:25 <monochrom> And ((->) Float) isn't a polynomial functor.
14:36:22 <monochrom> This is the problem with asking general questions.
14:36:55 <monochrom> General questions beget abstract answers and rabbit holes of generalized theories of PhD levels.
14:37:33 <monochrom> "How do I integrate x^3?" --> "Look up the power rule"
14:37:47 <monochrom> "How do I integrate functions?" --> "Look up the Risch algorithm"
14:39:03 <glguy> "The complete description of the Risch algorithm takes over 100 pages." :(
14:53:13 <tinco> I want to split a vector in groups according to some function f, and then fold over each group, and put the results of those folds in a new vector, functions could I use for that?
14:57:14 <jle`> presumably some of the ones from the Data.Vector module :)
14:58:45 <jle`> there aren't too many actually
15:00:16 <tinco> haha thanks jle` ;)
15:00:30 <tinco> I think I should recursively call span :P
15:00:33 <jle`> it sounds like you have the right terminology to look in the right places
15:00:39 <jle`> er wait, why span?
15:01:00 <tinco> well to get the partitions I think
15:01:12 <jle`> ah you probably would use 'partition' maybe
15:01:15 <tinco> the input vector is nice and ordered, so I can just split
15:01:20 <jle`> ah, ok
15:14:34 <felixschl> hey, so I cannot get my head around this: the following piece of code works when I uncomment the "traceShowM", but stops working when I comment it out: https://pastebin.com/wigninDs
15:15:30 <felixschl> if I remove the "traceShowM" the parser fails with "not enough input" on a large file. If I leave it in, however, it works just fine!
15:16:44 <felixschl> the error message attoparsec reports shows me that the bytestring it received was in deed too short
15:17:24 <lyxia> that's... an interesting behavior.
15:17:43 * geekosaur hopes that's not more accursedUnutterable... shenanigans...
15:18:03 <felixschl> lyxia: the wrong kind of unteresting, unfortunately :P
15:18:29 <Tuplanolla> What extensions do you have on, felixschl?
15:18:42 <tinco> ahh I missed working in Haskell, it's so nice
15:19:08 <felixschl> OverloadedStrings, LambdaCase, ScopedTypeVariables and FlexibleContexts
15:19:29 <Tuplanolla> Put `NoMonomorphismRestriction` on.
15:19:30 <monochrom> What is runEffect?
15:19:48 <felixschl> runEffect comes from the "pipes" library
15:19:57 <monochrom> What is PB?
15:20:11 <felixschl> Tuplanolla: no dice
15:20:17 <felixschl> sorry, i'll upload with imports
15:20:42 <lyxia> Tuplanolla: how would MMR cause problems here
15:20:58 <felixschl> https://pastebin.com/Hhzm9Vi6
15:21:00 <amf> anyone with more inside knowledge of ghc know if blog writeup is still accurate for ghc 8.0+? i see GHC.ForeignPtr.ForeignPtrContents has changed since. http://blog.johantibell.com/2011/06/computing-size-of-hashmap.html
15:21:08 <Tuplanolla> I worry `parseRecord` or some part of it would not generalize correctly, lyxia.
15:21:33 <felixschl> the bytestring I get in `parseRecord` is definitly a strict one
15:21:34 <Tuplanolla> It's easy to try before thinking.
15:22:13 <lyxia> felixschl: what's the type of stockV2Parser
15:22:32 <felixschl> lyxia: just an attoc parser
15:22:34 <lyxia> Tuplanolla: that's true
15:22:39 <felixschl> attoparsec parser
15:22:51 <felixschl> stockV2Parser :: Parser StockV2
15:23:43 <geekosaur> attoparsec is streaming, reifing the whole input could mask a bug in handling partial results?
15:24:19 <geekosaur> ('forcing' if you prefer)
15:25:08 <hexagoxel> Tuplanolla: but MMR does not generalize (?) do you have an example where both compile, but MMR has bad behaviour?
15:25:48 <Tuplanolla> Oh, it wasn't a type error!
15:26:08 <Tuplanolla> Nap time.
15:30:42 <hexagoxel> felixschl: does `evaluate x` have the same effect as `traceShowM (length x)` ?
15:31:25 <monochrom> You may not be able to use "evaluate" because you may not be in IO here.
15:31:52 <hexagoxel> eh, right.
15:32:09 <monochrom> But you may be able to make it a "seq".
15:32:12 <hexagoxel> x `seq` pure () ?
15:32:35 <monochrom> x `seq` case parseOnly ...  seems more reliable.
15:32:41 <hexagoxel> or just seq without *>-
15:32:51 <hexagoxel> yeah
15:33:01 <joeyh> added to my stack.yaml's packages a location: git. That works, but now each time I run stack build it seems to rebuild a set of packages that themselves depend on that
15:34:10 <monochrom> But overall I have trouble believing that evaluation is the cause. Because x is an eager bytestring.
15:34:27 <felixschl> i just noticed i still get errors but at later lines of the input, there must be sth else going on... :/
15:35:20 <monochrom> BS.length causes wholesome evaluation, but so does the parser. And the parser (and attoparsec) can't tell the difference between thunk and value. Very few people can.
15:35:28 <hexagoxel> eager just means that seq behaves like deepseq
15:35:32 <monochrom> s/wholesome/wholesale/
15:36:21 <hexagoxel> or is this just one slice of a large, eager bytestring or something?
15:37:11 <monochrom> That is true. There is a "view PB.lines PB.stdin".
15:40:25 <ryantm> I have a data type Blah: Blah { _messages = Vector Message} and Message has a username: Message { _username :: Text} Using Control.Lens, I'm trying to construct a lens from Blah to a Vector Text (for the usernames). I've tried a couple different things. blah ^.. messages . traverse . username is a lens to [Text]. How can I make it be a Vector like the container it traversed?
15:40:28 <monochrom> Slicing doesn't make an eager bytestring less eager.
15:40:39 <hexagoxel> exactly..
15:41:12 <felixschl> monochrom: I'd by lying if I said I understood how pipes-bytestring actually works...
15:41:25 <hexagoxel> but if it is _not_ a slice, but an element of a lazy bytestring, then it may very well be not forced yet.
15:41:38 <monochrom> Oh I don't know pipes either. But I know bytestring and lazy evaluation.
15:41:39 <felixschl> the types check out and it comiles so I figured I put the pieces together the right way
15:42:07 <hexagoxel> monochrom: heh, perhaps we should both shut up :D
15:42:47 <monochrom> Well, the way eager bytestring is coded up, there are simply certain tricks one can't pull.
15:44:16 <monochrom> For example "can I insert unsafeInterleaveIO somewhere so that my eager bytestring, coming from hGetContents, is shorter or longer depending on how early/late I hClose?"
15:44:31 <monochrom> You can pull that trick with lazy bytestring.
15:45:09 <monochrom> But eager bytestring, it is not "shorter vs longer" in the usual sense, it's "empty vs the whole file".
15:45:31 <hexagoxel> are you sure that holds before it is forced?
15:46:26 <monochrom> If you force before hClose, you get the whole file. If you hClose before force, you get emptiness.
15:46:52 <monochrom> It will not be "you may get 3 bytes as opposed to 10 bytes".
15:47:08 <lyxia> felixschl: the bytestrings you are getting out of "view lines stdin" are still only chunks of lines
15:47:22 <hexagoxel> oh, and "whole file" is certainly wrong.
15:47:22 <Cale> ryantm: (\v -> Blah (fmap Message v)) <$> (fmap _username . _messages) ?
15:47:26 <Cale> oops
15:47:50 <hexagoxel> if i read a lazy bytestring of a large file, and then call `toChunks`, i will get lots of strict bytestrings that don't contain "whole files"
15:47:59 <Cale> ryantm: \b -> (\v -> Blah (fmap Message v)) <$> (fmap _username $ _messages b)
15:48:11 <lyxia> felixschl: I think the problem then is that your parser is not guaranteed to receive a complete line
15:48:20 <monochrom> Oh, that.
15:49:05 <monochrom> OK, you get 3 chunks or 10 chunks.
15:49:06 <hexagoxel> and pipes, most likely, does something roughly along those lines internally (i.e. uses toChunks)
15:49:39 <hexagoxel> you assume that the list of strict bytestrings is not itself lazy
15:49:39 <Cale> oh, derr
15:49:41 <lyxia> felixschl: the lines are separated by constructors of the FreeT transformer
15:49:47 <Cale> forgot to actually apply the function :)
15:49:50 <monochrom> But either the 4th chunk exists and contains 100 bytes, or it doesn't exist. There is no "the 4th chunk exists but it may have 9 bytes or 100 bytes".
15:49:51 <lyxia> felixschl: and concats is losing that separation.
15:49:52 <hexagoxel> which i would questio as well.
15:50:15 <felixschl> lyxia: i think i need to do this: https://github.com/Gabriel439/Haskell-Pipes-Group-Library/blob/master/src/Pipes/Group.hs#L391
15:50:24 <felixschl> lyxia: then keep feeding into the parser
15:50:31 <monochrom> parseRecord is given one single chunk. Either someone calls parseRecord with one chunk, or parseRecord is not called at all.
15:50:31 <Cale> ryantm: \f b -> (\v -> Blah (fmap Message v)) <$> f (fmap _username $ _messages b)
15:51:05 <Cale> ryantm: I think that typechecks :)
15:51:12 <hexagoxel> but the chunk maybe still be the output of an unforced unsafeInterleaveIO
15:51:16 <monochrom> No, I'm already assuming that the list spine is lazy and even has an unsafeInterleaveIO behind it.
15:51:39 <lyxia> felixschl: yes that would be one way
15:52:13 <felixschl> lyxia: is there another way u can think of?
15:52:25 <felixschl> the lines are short enough to fit entirely into memory and of fixed length
15:52:26 <hexagoxel> ah, i think you are correct.
15:52:33 <hexagoxel> monochrom: thanks for persisting.
15:52:36 <lyxia> felixschl: I don't know but I'm looking for it
15:53:10 <hexagoxel> you mean the list must already be forced to either [] or (:), and that involves forcing the length of the next strict bytestring.
15:53:27 <monochrom> Yeah.
15:53:33 <hexagoxel> good :)
15:53:55 <Cale> Prelude Control.Lens Data.Vector Data.Text> :t \f b -> (\v -> Blah (fmap Message v)) <$> f (fmap _username $ _messages b)
15:53:55 <Cale> \f b -> (\v -> Blah (fmap Message v)) <$> f (fmap _username $ _messages b)
15:53:55 <Cale>   :: Functor f => (Vector Text -> f (Vector Text)) -> Blah -> f Blah
15:54:19 <lyxia> felixschl: So far yours looks like the only way
15:54:41 <felixschl> there's no monoid instance for parse results, so not sure how to seed the fold function accumulator :/
15:55:15 <felixschl> I guess (Maybe Result a), meh...
15:55:57 <Cale> The general pattern is \f x -> replace <$> f (extract x)  where replace is a function that replaces the thing in the hole, and extract is a function that obtains the value in the hole
15:56:43 <lyxia> felixschl: I was thinking of using fold to get all the chunks of a line in a list and concatenate them
15:57:37 <felixschl> lyxia: hah, of course :)
16:12:12 <ryantm> Cale: Thanks for the reply! I think I misspoke when I said I was trying to make a lens. I was just trying to chain together existing  things in the Lens library to get out the Vector Text. Maybe that's not possible though, and I need to make my own lens?
16:13:35 <glguy> ryantm: You can't make such a lens without cutting a few corners, you get a lens with some side-conditions about preserving the size of the vectory
16:13:37 <glguy> -y
16:15:53 <glguy> unless both your Blah and Message types only have exactly one field each and that wasn't just an artifact of an artificial example
16:16:24 <ryantm> Having one field was just an artifact.
16:17:03 <glguy> OK, in that case you can't do it well. You can force your way there using ''partsOf'', however
16:17:27 <glguy> but it's not something that's OK to do in general due to the condition on preserving the Vector length
16:20:49 <lyxia> ryantm: So you needed just a "getter"? a lens is both a getter and a setter.
16:21:16 <ryantm> lyxia: Yes.
16:22:36 <glguy> In that case: to (fmap _username . _messages)
16:30:47 <ryantm> I'm have duplicate record fields do I cannot use those accessor functions but this works:   blah ^. messages . to (fmap (view username))
16:33:45 <ryantm> Thank you!
16:41:27 <felixschl> is there a function that maps the left hand side of either? in purescript we have bifunctors for that, was surprised this didnt exist in haskell?
16:41:45 <felixschl> just `either f id`?
16:42:04 <glguy> :t Data.Bifunctor.first
16:42:06 <lambdabot> Bifunctor p => (a -> b) -> p a c -> p b c
16:42:50 <felixschl> oO
16:43:44 <felixschl> thanks, i don't know how i overlooked that, guess was too focused on finding "lmap"
16:44:16 <glguy> :t lmap -- that's something else
16:44:17 <lambdabot> Profunctor p => (a -> b) -> p b c -> p a c
16:46:22 <dmwit> We can proliferate classes further. Bifunctors are covariant in both arguments; profunctors are contravariant in their first argument and covariant in their second; but do we have classes for both-contra or co and contra?
16:49:41 <contiver_> Hi! I've been passing around some configuration using Reader, but might want to add some state for more complex computations. Should I switch to State, or use monad transformers to keep my read-only config in Reader, and the new things in State?
16:51:09 <Eduard_Munteanu> contiver_, if you use the MonadReader and MonadState classes you can add that where you need it and only change the runner function
16:51:12 <lyxia> If we have   class Functor f c d where fmap :: c a b -> d (f a) (f b)   then Contravariant is just an Op away.  Contravariant f c d = Functor f (Op c) d
16:52:29 <contiver_> Eduard_Munteanu, so I keep the class polymorphic, without specifying which one, and need to change only the "runReader" part?
16:52:37 <pacak> contiver_: There's RWS/RWST - can be a bit faster than reader + writer separately.
16:52:45 <contiver_> type *, not class def.
16:53:19 <Eduard_Munteanu> contiver_, yeah... like   (MonadReader Conf m, MonadState S m, MonadIO m) => m Something
16:54:01 <Eduard_Munteanu> Instead of    ReaderT Conf (StateT S IO) a
16:54:19 <Eduard_Munteanu> s/ a/Something/
16:56:06 <contiver_> Eduard_Munteanu, sounds good, I'll keep it in mind, thanks!
16:56:45 <contiver_> pacak, you mean this https://hackage.haskell.org/package/mtl-2.2.1/docs/Control-Monad-RWS-Lazy.html ?
16:57:01 <pacak> contiver_: Yep.
16:58:23 <contiver_> pacak, noted, I'll do some reading on those two and see what I end up using, thanks.
16:58:23 <Cale> I tend to avoid leaving MonadReader and MonadState constraints lying around in code. Typically, I'll invent some new class (if I need one at all) that describes the operations I want in my application better, and then potentially use ReaderT/StateT to implement those operations.
16:59:27 <Eduard_Munteanu> You can use constraint synonyms if you want to.
16:59:28 <pacak> contiver_: It's not one or the other. You can still use (MonadFoo m, MonadBar m) style constraints with RWS/RWST.
16:59:38 <Cale> It's not about constraint synonyms
16:59:39 <pacak> It's about runner function
16:59:49 <Cale> It's about having classes that actually mean something
17:00:40 <Cale> Like "this is a monad in which we have access to a database", and then having a bunch of operations for querying the DB or executing SQL statements, even if underlying that is just a ReaderT of the connection pool.
17:01:16 <Cale> (well, more likely a ReaderT of the actual connection)
17:03:02 <Cale> So perhaps take the time to think about why you're carrying the state around, and what the valid ways are to manipulate it, and then have a class for those, and then implement an instance of the class for your application's monad (or if you're getting really modular, some monad transformer you write as a newtype of StateT)
17:03:41 <Cale> Usually there's something better than "I have an arbitrary value of type s and it could change in any way imaginable."
17:06:06 <louispan> I have a question about naming. Is there a name for things that are kind *; and name for kind (* -> *); and name for kind (* -> * -> *)?
17:06:24 <contiver_> Cale, for the time being, I just want it to gather some information on some stuff I parsed. I could use a fold/recursion and might be enough, but I have basically an abstract syntax tree, and thought state might make it easier to handle.
17:07:00 <Cale> Ah, so you're transforming your parser monad?
17:07:34 <Cale> Or transforming the code which consumes the syntax tree after that?
17:07:44 <louispan> I think kind * is also called monotypes, but I don't know what the higher level kinds are called
17:08:15 <Cale> louispan: Not really in general... type functions?
17:08:38 <Cale> parametric types
17:08:46 <contiver_> Cale, to be more concrete, I have several types modelling parts of CSS, say values, declarations, rules, etc.
17:09:11 <contiver_> I was using Reader to minify them, carrying around a bunch of options (enable this minification, disable that one, etc.)
17:09:32 <Cale> ahh
17:09:45 <contiver_> now I wanted to explore improving gzip compression of the final result, and for that I wanted to, for example, have the frequency of the characters used.
17:10:02 <contiver_> I thought state could help with that.
17:10:43 <louispan> Cale: Thanks, I'll make do then :)
17:11:03 <Cale> louispan: If you want to remove all doubt, feel free to say types of kind * -> *
17:11:16 <Cale> louispan: Some such types are functors.
17:11:21 <Cale> (but not all of them)
17:12:31 <structuralist> Is there any react+flux library right now for GHCJS that's production-ready and actively maintained?
17:13:12 <structuralist> react-flux seems abandoned: https://bitbucket.org/wuzzeb/react-flux/pull-requests/12/
17:15:25 <structuralist> I'm just looking for something like Elm, basically
17:16:21 <Cale> contiver_: Yeah, possibly. I suppose it depends on how much code we're talking about. Personally, I'm not sure I'd have bothered with Reader just for passing around config, but if you're doing sufficient amounts of building modular blocks of stuff, it could turn out nice.
17:16:40 <Cale> structuralist: Have you checked out reflex-dom? :)
17:17:04 <Cale> structuralist: We're using reflex-platform in production where I work, and it's great.
17:17:20 <structuralist> Cale: A little bit, it looks cool! But I do need something Elm-style for my particular application
17:17:20 <louispan> Cale: Does unary kind and binary kind make sense?
17:17:59 <structuralist> Unfortunately Elm lacks higher-kinded polymorphism
17:18:16 <Cale> structuralist: Like Elm's older FRP? Or something else? I must admit I haven't really looked closely at Elm recently.
17:19:02 <Cale> louispan: "unary type-level function" maybe?
17:19:27 <louispan> Okay, I'll go with that. Thank you
17:19:56 <structuralist> Cale: Not FRP... the way it works now with `view : Model -> Html Msg` and so on
17:20:02 <Cale> structuralist: Ah, okay
17:20:39 <Cale> So just collecting all the state globally, and then using that to determine the view
17:20:45 <structuralist> Yep
17:20:49 <structuralist> https://guide.elm-lang.org/architecture/
17:21:12 <Cale> Personally, I'd still be tempted to use reflex, but perhaps I'm biased ;)
17:22:17 <Cale> You could just have one top-level holdDyn, and then pass the resulting Dynamic around. If you don't want to deal with merging Events carefully or anything, you could use EventWriterT
17:23:04 <Cale> (or top level foldDyn, if you want to use the event and the old state to determine the new state)
17:23:45 <structuralist> hmmm
17:24:07 <Cale> and then you have widgets that make use of the resulting Dynamic t Model or whatever
17:24:16 <Cale> to determine how to display themselves
17:25:04 <structuralist> Okay, I guess I will try reflex
17:25:06 <Cale> It's sort of a degenerate way to use the FRP system, but it'd work :)
17:25:16 <structuralist> Haha yeah
17:25:29 <structuralist> Could you recommend a learning resource to get started?
17:26:34 <Cale> https://github.com/reflex-frp/reflex-platform -- maybe start with the tutorial that's here?
17:26:47 <Cale> https://blog.qfpl.io/posts/reflex/basics/introduction/ -- Dave Laing has been writing some blog posts
17:28:38 <structuralist> Cool, thanks!
17:28:44 <Cale> Though, I don't know, perhaps what you'd really want is a tutorial in just using a very limited set of features of it :)
17:28:55 <Cale> But yeah, check it out, it's quite good
17:29:57 <structuralist> Is it pretty much the uncontested leader in frontend libraries for GHCJS? Or are there any contenders I should maybe look at?
17:32:14 <Cale> There is something called miso that I haven't really had time to look closely at.
17:33:53 <Cale> It says that it's inspired by Elm, so it might be sort of what you're looking for
17:34:24 <structuralist> Oh yeah, very interesting
18:04:01 <dmj`> someone say miso?
18:04:54 <dmj`> structuralist: miso is focussed on fast DOM manipulation and dead simple use, it’s inspired by Elm but differs somewhat internally
18:05:09 <structuralist> I'm checking it out now :)
18:05:58 <structuralist> I love the pre-made stack.yaml btw
18:06:32 <dmj`> structuralist: heh :) 
18:12:10 <Lokathor> so i'm making simplified set of wrappers for the gl functions
18:12:42 <Lokathor> they're all prefixed "gl", and i want to keep the capitalization on the names the same, so i can't just drop "gl" entirely, but i want to change the prefix so you can see when you've got the wrapped version
18:13:05 <Lokathor> would 's' be fine? a weird letter like 'x', 'q', or 'z'? something else?
18:25:12 <dsal> I'm a little surprised quickcheck doesn't do bounds by default.
18:25:26 <Lokathor> like maxBound and all that?
18:25:47 <dsal> > quickCheck ((\(NonZero x) -> abs x > 0) :: NonZero Int8 -> Bool)
18:25:50 <lambdabot>  error:
18:25:50 <lambdabot>      • Couldn't match expected type ‘Test.QuickCheck.Random.QCGen’
18:25:50 <lambdabot>                    with actual type ‘NonZero Int8 -> Bool’
18:25:56 <dsal> well damn.
18:26:05 <dsal> That mostly passes.
18:26:25 <dsal> > abs  minBound :: Int8
18:26:28 <lambdabot>  -128
18:26:33 <Lokathor> :(
18:26:43 <dsal> I've had bugs from this sort of thing in the past.
18:26:53 <Lokathor> > abs (minBound::Word8)
18:26:56 <lambdabot>  0
18:26:57 <Lokathor> :D
18:29:24 <dsal> > abs minBound :: Int
18:29:26 <Lokathor> I'll go with 's' for the new prefix
18:29:28 <lambdabot>  -9223372036854775808
18:30:08 <Lokathor> the abs of the minbound for any signed type will be negative, because there's an even number of number slots and 0 takes up one of them
18:30:48 <ski> @check \(NonZero x) -> abs x > 0
18:30:53 <lambdabot>  +++ OK, passed 100 tests.
18:30:58 <dsal> I'd think any qc run should include min and max bounds, 1 off of those, 0, 1, 2, -1, -2 and then random stuff
18:31:23 <Lokathor> well, it's not the first haskell lib to end up being a hair unsound :P
18:31:35 <ski> @check \(NonZero x) -> abs x > (0 :: Int8)
18:31:38 <lambdabot>  +++ OK, passed 100 tests.
18:32:10 <ski> *** Failed! Falsifiable (after 30 tests):
18:32:11 <ski> NonZero {getNonZero = -128}
18:32:23 <Lokathor> the random lib we all use every day is also suspect ;)
18:32:26 <jchia> Is there a simple way to get the arity of a value constructor? E.g. for "data Foo = Bar Int Double | Baz Char", I want to get 2 for Bar and 1 for Baz. I need a way that works also for value constructors from a GADT. More generally, is there a way to get the arity of a function?
18:32:55 <dsal> It's arity a thing?
18:33:16 <dsal> (phone is typoing for me)
18:33:20 <ski> is `undefined' a function ?
18:33:50 <jchia> ski: I suppose this arity function can give bottom when given bottom (undefined)
18:33:59 <monochrom> :)
18:34:06 <ski> how about the arity of `id' ?
18:34:08 <jchia> ski: This probably is not a regular function
18:34:19 <monochrom> @quote monochrom 17-ary
18:34:20 <lambdabot> monochrom says: I am 17-ary, going on 18-ary, I can take curry of you
18:34:20 <jchia> it doesn't have a specific type
18:34:28 <monochrom> That's for id :)
18:34:36 <ski> `forall a. a -> a' is a specific type
18:34:36 <jchia> f :: * -> Int
18:34:46 <jchia> ski: OK
18:34:59 <jao> don't all functions in haskell have arity 1?
18:35:36 <monochrom> Yes if we speak technically.
18:35:41 <jchia> jao: You can do partial application to get another function with an arity that's lower by one.
18:35:55 <Lokathor> jao, i suspect they mean "becomes a non-function value when applied to this many other values"
18:36:07 <AfC> I have a newtype over Int64. Nothing unusual. Then a user asks me for an instance of Unbox (from vector package). Since there's already an Unbox Int64 instance, shouldn't I be able to just derive it automatically?
18:36:27 <jchia> jao: What I mean is after you apply arguments as much as possible, how many arguments will you have provided
18:36:42 <Lokathor> AfC, yes, the GeneralizedNewtypeDeriving extension is what you want (if i remember the name right)
18:36:44 <jao> it's tricky... foo x z = \y -> x + y + z
18:36:54 <monochrom> But morally you would like to say that (+) take two parameters. Code optimization cares about this too. It would suck if "1 + 3" really generated code for the intermediate "(+) 1" function.
18:37:46 <Lokathor> AfC, better add Storable while you're at it
18:37:54 <AfC> Lokathor: heh
18:38:14 <AfC> Lokathor: so I have that on already. What happens is it walks up to the required superclass, and goes *boom* 
18:38:21 <jchia> OK, so does this "f :: forall a.a -> Int" exist?
18:38:34 <Lokathor> AfC can you make a paste of the error?
18:38:38 <AfC> Lokathor: "No instance for (G.Vector Vector Thing arising from the superclasses of an instance declaration"
18:38:39 <monochrom> An optimizing compiler, or even just at the STG stage, makes a big fuss about "is this saturated" which is another way to say it's aware that morally there are arities other than 0 and 1.
18:38:55 <Lokathor> jchia, it does, but it also returns a constant Int value
18:39:09 <AfC> Lokathor: so I throw in `deriving instance G.Vector Vector Thing` and boom
18:39:17 <AfC> Lokathor: yeah
18:39:41 <jao> monochrom, good point
18:39:53 <Lokathor> this sounds beyond my level to fix, but once there's a paste of it linked then others jump in the water and check it out a lot of the time :3
18:42:01 <AfC> Lokathor: http://lpaste.net/359547
18:42:35 <AfC> y'know, down the rabbit hole that one.
18:43:20 <Lokathor> so are you adding an unbox instance or a vector instance?
18:43:58 <AfC> the user asked for an Unbox instance for Thing (because their probability work feeds on Unboxed Vectors)
18:44:10 <monochrom> "foo x z = \y -> x + y + z" is a tricky case, or at least the basis of a tricky case. If you have just that, I think the optimizer will treat it as "foo x z y = x + y + z". But by the time you enhance it to "foo x z = let xz = x + z in \y -> y + xz" the optimizer will hesitate to modify it because the general idiom of "f x = let ... in \y -> ..." is an indication that you're trying to do some memoization.
18:44:24 <ski> > arity (id `asAppliedTo` not)
18:44:28 <lambdabot>  2
18:44:34 <jchia> ski: Arity of id is 1 but if you give it another function, the story gets complicated.
18:44:58 <AfC> which I thought would be no biggie, but the definition of Unbox is class (Vector Vector a, MVector MVector a) => Unbox a
18:45:33 <AfC> where I'm stuffed is that there are (necessarily) Int64 instances for those things. So...
18:46:27 <Lokathor> what happens when you just put Unbox into the deriving part of the newtype declaration?
18:46:49 <ski> jchia .. ^
18:47:02 <Lokathor> I'm afraid I don't really know what else to do >_>
18:48:01 <AfC> Lokathor: that's where I started.  `No instance for (M.MVector MVector Thing)` 
18:48:44 <Lokathor> the patron saint Newtype has failed us
18:48:51 <Lokathor> may our gundams rot and crumble
19:40:20 <lyxia> AfC: You can reuse the underlying implementation but looks like you'll have to write everything by hand
19:47:20 <boogalooga> best way to remove duplicates from a list of ints?
19:48:21 <hexfive> nub
19:48:26 <geekosaur> define "best". fastest and most general way is to load the list into a Set and re-extract it as a list
19:48:42 <hexfive> ^^ don't use nub its pretty slowlorus
19:48:49 <geekosaur> for short lists nub will probably be faster; it is certainly easier. but it is slow
19:48:50 <AfC> lyxia: yeah. That's what I just did. A lot of boilerplate. Oh well.
19:49:02 <geekosaur> short lists it ends up a wash, longer ones the Set route will be faster
19:49:18 <geekosaur> also nub is lazy so sometimes that beats slow.
19:49:38 <ggVGc> also, nub is only 3 letters to write
19:49:48 <geekosaur> (nub works with only an Eq constraint instead of Ord like Set requires, which is why it's slow. but for [Int] you don't care about the Ord constraint)
19:50:33 <geekosaur> but going through Set will be strict instead of lazy since it has to load the entire list into the Set before it can produce output
19:50:46 <ggVGc> I have an idea
19:50:55 <ggVGc> don't put the duplicates in the list in the first place!
19:51:02 <ggVGc> (fastest)
19:57:24 <jchia> There is a class BlazeBuilder that apparently has an IsString instance (L3) but ":i IsString" doesn't tell me about it. Why? http://lpaste.net/359549
19:58:14 <jchia> s/class BlazeBuilder/type BlazeBuilder/
19:58:16 <jchia> Too much C++
19:58:21 <hexfive> isn't that what {-# LANGUAGE OverloadedStrings #-} uses?
19:58:57 <hexfive> oh lol
19:58:59 <hexfive> nvm
19:59:41 <Axman6> jchia: have you imported the module BlazeBuilder is defined in?
20:00:07 <jchia> Axman6: I did "import Data.Builder"
20:00:18 <jchia> That's all
20:00:55 <Axman6> that's not where BlazeBuilder is defined though...
20:01:16 <jchia> https://hackage.haskell.org/package/chunked-data-0.3.0/docs/Data-Builder.html
20:01:42 <Axman6> that
20:01:48 <Axman6> that's a Text builder...
20:02:16 <jchia> Axman6: "type BlazeBuilder = Builder"
20:02:27 <jchia> And Builder is this: https://hackage.haskell.org/package/binary-0.8.3.0/docs/Data-Binary-Builder.html#t:Builder
20:02:49 <Axman6> oh sorry, yes, moused over the wrong link
20:03:20 <jchia> I also don't understand why the haddock doesn't list IsString instance for Data.Binary.Builder.Builder.
20:03:57 <jchia> But then, for that matter, it doesn't for Text, either. Now I'm wondering how can I find out whether a type has an IsString instance.
20:04:55 <jchia> Actually scratch that, for Text, it does list IsString, right at the bottom
20:05:00 <jchia> orphaned instance
20:05:32 <jchia> but for Data.Binary.Builder.Builder, the haddock doesn't list the IsString instance
20:06:34 <Axman6> I can't find an IsString instance for it
20:07:02 <jchia> Axman6: But it should have IsString instance, shouldn't it? Otherwise, L3 wouldn't work.
20:07:41 <Axman6> hmm, yes
20:13:56 <MarcelineVQ> https://hackage.haskell.org/package/bytestring-0.10.8.2/docs/Data-ByteString-Builder.html#v:-36-fIsStringBuilder
20:15:09 <MarcelineVQ> the hyperlink to https://hackage.haskell.org/package/binary-0.8.3.0/docs/Data-Binary-Builder.html#t:Builder is incorrect, in the source it is  import qualified Data.ByteString.Builder as BB      type BlazeBuilder = BB.Builder
20:16:55 <jchia> MarcelineVQ: Thanks. Confused by haddock. Still, do you know why :i IsString doesn't list Builder/BlazeBuilder?
20:18:06 <boogalooga> what's a good way to implement this -> https://en.wikipedia.org/wiki/Sieve_of_Sundaram
20:18:13 <boogalooga> https://imgur.com/a/P7tJf
20:18:17 <boogalooga> here's what I did
20:18:24 <boogalooga> it's really inedfficiant 
20:18:37 <Axman6> boogalooga: you might find lpaste useful in future:
20:18:37 <boogalooga> it's really inefficient 
20:18:39 <Axman6> @where lpaste
20:18:40 <lambdabot> http://lpaste.net/
20:18:58 <boogalooga> oh nice thanks
20:20:08 <Axman6> boogalooga: if x must be less than y, why not use ... x <- [1..n], y <- [x .. n] and remove that check from cond?
20:20:33 <boogalooga> ohh smart
20:20:52 <boogalooga> that's what I would usually do in a nested for loop
20:20:53 <boogalooga> haha
20:22:09 <Axman6> does x + y + 2xy vactor into (x+y)*(x+y)?
20:22:19 <iqubic> *factor
20:22:20 <Axman6> factor*
20:22:25 <iqubic> And yes.
20:22:25 <boogalooga> no
20:22:42 <boogalooga> ?
20:23:00 <iqubic> Wait, that's X^2 + 2XY + Y^2 = (X + Y)^2
20:23:41 <Axman6> yeah
20:24:42 <boogalooga> I know I could prob use a set
20:24:47 <boogalooga> to make the elem 
20:24:51 <boogalooga> check much faster
20:24:56 <Axman6> that would definitely be faster
20:25:11 <Axman6> makes that check go from O(n) to O(log n)
20:25:17 <boogalooga> oh wait
20:25:22 <boogalooga> does haskell have hashsets
20:25:23 <boogalooga> ?
20:25:23 <Axman6> but the creation is O(n) anyway
20:25:39 <MarcelineVQ> jchia: it's kind of a pain in the ass, appearantly, you have to import the thing that defines the instance for it to show up in the list.  e.g.  import Data.Functor.Cont   or  import Data.Bytstring.Builder
20:25:51 <MarcelineVQ> *Const
20:26:25 <geekosaur> HashSet and HashMap are in the unordered-containers package
20:26:52 <boogalooga> so if I don't want to use a set
20:26:56 <boogalooga> is what I did the best way
20:26:57 <boogalooga> ?
20:27:09 <boogalooga> best == most elegant/efficient 
20:34:45 <jchia> MarcelineVQ: OK
20:35:08 <MarcelineVQ> I dunno if :info is that conservative on purpose or if it's an oversight
20:36:08 <MarcelineVQ> ah, of course.
20:36:16 <MarcelineVQ>  :info! IsString
20:38:54 <Gurkenglas> :t (\\) -- boogalooga Data.List already gives an implementation as asymptotically slow as yours
20:38:55 <lambdabot> Eq a => [a] -> [a] -> [a]
20:39:03 <jchia> MarcelineVQ: Of course, didn't think about that. I almost never use :info!
20:42:03 <boogalooga> how do I import it
20:42:03 <boogalooga> ?
20:42:07 <boogalooga> never done it before
20:43:27 <jle`> `import Data.List` at the top of your file
20:43:36 <jle`> are you following any tutorial or introduction to haskell?
20:44:01 <boogalooga> cis 194
20:44:11 <boogalooga> oh so that's how I tried to import before
20:44:18 <jle`> ah. i suppose you're still at the point where they haven't talked about imports yet
20:44:19 <boogalooga> but it gave me a bunch of errors
20:44:25 <boogalooga> now that I read the errors
20:44:35 <boogalooga> I realize that I have functions with the same names
20:44:39 <jle`> reading errors often helps :)
20:44:42 <boogalooga> as defined in Data.List
20:44:43 <boogalooga> :p
20:45:05 <boogalooga> and not really talked about imports yet
20:45:23 <boogalooga> true
21:13:00 <sebastian> Is there a way to disable color output from Stack
21:13:02 <sebastian> ?
21:13:14 <Guest92752> as in, remove the ANSI escape codes from the output?
21:13:41 <MarcelineVQ> a quick stack --help  says --color never
21:13:50 <Guest92752> ah, thanks. Sorry, I didn't see it!
22:34:36 <osa1> is it possible to :load output of a shell command in ghci? I tried `:load !<shell_cmd>` but it didn't work
22:38:21 <geekosaur> not directly
22:40:58 <d6e> Could the type declaration operator `::` be implemented as an infix function? Or is that crazy talk?
22:41:41 <liste> is :: really an operator?
22:41:49 <geekosaur> not currently
22:41:54 <osa1> geekosaur: I want to use fuzzy finders like fzf in ghci to load files, do you know if this is possible somehow?
22:41:55 <d6e> what would you call it if not an operator?
22:42:03 <geekosaur> :: ssections are in development possibly for 8.4.1
22:42:31 <geekosaur> d6e, it's syntax. it doesn't have a declared precedence, can't be made into a section, etc.
22:42:45 <d6e> geekosaur: do you have a link for that, perchance?
22:42:50 <geekosaur> 'operator' in Haskell means more than 'looks operator-ish'
22:44:24 <d6e> hmm what's operator-ish look like? A `+` is an operator, right?
22:45:03 <jle`> the best answer to that is probaby in the Report
22:45:20 <geekosaur> https://ghc.haskell.org/trac/ghc/ticket/10803
22:45:39 <geekosaur> looks like it got bumped to 8.6
22:46:37 <geekosaur> and what jle` said re what is actually an operator
22:47:09 <geekosaur> osa1, I could see a macro that ran something to a temp file and loaded it, but cleaning up that temp file after might be a pain
22:47:18 <jle`> there is way to replicate some functionality of type annotations using a custom defined operator
22:47:25 <jle`> or custom defined function
22:47:50 <jle`> @let the :: a -> a; the = id
22:47:52 <lambdabot>  Defined.
22:48:00 <jle`> oh i forgot that lambdabot doesn't have TypeApplications on yet
22:48:06 <jle`> the @Int (read "3")
22:49:36 <iqubic> What is a TypeApplication?
22:49:51 <jle`> it lets us manually/explicitly pick type variables
22:50:06 <iqubic> huh?
22:50:14 <jle`> :t fmap
22:50:16 <lambdabot> Functor f => (a -> b) -> f a -> f b
22:50:26 <jle`> fmap @[] will give us fmap :: (a -> b) -> [a] -> [b]
22:50:34 <jle`> fmap @Maybe will give us fmap :: (a -> b) -> Maybe a -> Maybe b
22:50:50 <iqubic> Ah, function specialization.
22:50:58 <jle`> read @Int :: String -> Int
22:51:48 <iqubic> read @Float :: String -> Float?
22:51:54 <iqubic> Is that right?
22:52:07 <jle`> yea
22:52:09 <jle`> :t read
22:52:11 <lambdabot> Read a => String -> a
22:52:16 <jle`> so giving it @Int will pick a ~ Int
22:52:34 <osa1> geekosaur: so it seems like the problem is I can't get a string back from `:!` otherwise I could do this in a macro
22:54:56 <osa1> hmm I can write a function for that but I that'd require `process` package probably
23:03:10 <nshepperd> heh. what would the type of (::) be, if it was a function?
23:04:35 <nshepperd> a -> (a :: Type) -> a is one option I suppose
23:04:46 <nshepperd> that would make (::) sections work as expected
23:10:29 <jle`> maybe now since we have parameterized TypeRep it could work
23:10:50 <jle`> but only for Typeable a
23:11:09 <jle`> oh, i guess we don't even need that, we could just use Proxy
23:11:24 <jle`> a -> Proxy a -> a
23:11:47 <jle`> @let (:::) :: a -> Proxy a -> a; x ::: _ = x
23:11:47 <lambdabot>  Parse failed: Left-hand side of type signature is not a variable: (:::)
23:12:08 <Axman6> 9type?
23:12:12 <Axman6> s/9//
23:12:34 <jle`> @let (:::) :: a -> Proxy a -> a; (:::) = const
23:12:34 <lambdabot>  Parse failed: Left-hand side of type signature is not a variable: (:::)
23:12:40 <jle`> why, haskell
23:13:00 <jle`> oh yeah
23:13:24 <jle`> @let (~::) :: a -> Proxy a -> a; x ~:: _ = x
23:13:26 <lambdabot>  Defined.
23:13:37 <jle`>  > read "3" ~:: Proxy @Int
23:13:39 <jle`>    3
23:13:50 <jle`> meh
23:15:25 <jle`> but, at least this works with polymorphic type variables
23:19:42 <jle`> hm maybe not
23:27:08 <nshepperd> yeah, this doesn't actually capture (::) properly where foralls are involved
23:27:14 <nshepperd> because impredicative
23:28:31 <Lokathor> :t traverse
23:28:33 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
23:29:03 <Lokathor> :t traverse putStrLn Nothing
23:29:04 <lambdabot> IO (Maybe ())
23:30:03 <Lokathor> would that print when there's something and not print when there's nothing? or do you have to do some other fiddly step?
23:30:44 <Axman6> ~%it'll print if you have Just <some string>
23:30:53 <jle`> Lokathor: that'll do it
23:30:55 <Axman6> it'll do nothing otherwise
23:30:59 <jle`> but usually people would use traverse_
23:31:00 <Lokathor> neat
23:31:08 <Lokathor> oh, right
23:31:08 <jle`> :t traverse_ putStrLn Nothing
23:31:11 <lambdabot> IO ()
23:32:11 <Lokathor> :t flip traverse_
23:32:13 <lambdabot> (Applicative f, Foldable t) => t a -> (a -> f b) -> f ()
23:32:13 <jle`> often done using the for_ Nothing $ \x -> ... pattern, too
23:32:20 <jle`> or forM_
23:32:26 <Lokathor> yeah
23:35:12 <olligobber> hmm, throwing correct exceptions seems like too much work for this project, I think I'll just use error
23:48:26 <olligobber> oh, I can't return an ioError in a function that returns String -> String
23:48:33 <olligobber> error will be fine then
23:50:35 <Axman6> what's wrong with either Maybe or Either?
23:51:41 <cocreature> throwing exceptions in pure code is a usually a bad idea
23:51:49 <cocreature> where pure = outside of IO
