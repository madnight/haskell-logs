00:00:22 <saurabhn_> dkim: TH is one possible solution, perhaps.
00:00:39 <dkim> nvm, just googled and found a blogpost using different techniques
00:00:44 <saurabhn_> dkim: something *could* be built around overlapping type-class implementations. 
00:00:48 <saurabhn_> dkim: please share.
00:00:50 <dkim> typeclass hackery and the like, yeah
00:00:55 <dkim> http://chriswarbo.net/blog/2015-11-12-calculating_arity.html
00:01:15 <saurabhn_> dkim: exactly what I had in mind
00:02:33 <dkim> ok a quick perusal of the post yields: polymorphic types are still an issue?
00:05:22 <saurabhn_> try overlapping instances of the following type `instance {-# OVERLAPS #-} HasArity (a -> b -> c -> d) where....` and `instance {-# OVERLAPS #-} HasArity (a -> b -> c) where`
00:05:29 <saurabhn_> see if the compiler can figure it out...
00:05:33 <saurabhn_> downside = boilerplate
00:07:19 <dkim> haven't used or seen that pragma before lol
00:08:02 <cocreature> dkim: do you have an example of what you are actually trying to do?
00:08:14 <cocreature> i.e. is there some underlying problem that you are trying to solve by computing the arity?
00:09:02 <dkim> i'd have to dig to find it, but IIRC i was trying to write something that did arbitrarily nested 'loops'
00:09:28 <dkim> like, take a function that takes 4 args, loop over 4 containers of things, apply
00:09:35 <dkim> i tried to bind one thing at a time
00:10:16 <dkim> i'm not sure if that was a good description. in any case there's probably a simpler way to do what i wanted
00:10:38 <cocreature> computing the arity separately is usually not very helpful. instead you want to use the typeclass induction directly to implement the functionality you care about instead of first computing the arity and then trying to do something with that info
00:10:41 <dkim> i'd still want to know how to do this since i feel like with all these extensions, it should be possible?
00:10:51 <dkim> ah
00:11:39 <dkim> so you mean bake the cases into each instance?
00:12:17 <dkim> haven't really made typeclasses for this before, so i guess i'll just have to try
00:13:35 <dkim> thanks btw
00:24:02 <cocreature> dkim: make a typeclass for the operation that you actually want to implement, then make instances for the different types that you want to handle
01:37:52 <kuribas> > fix (each (const l) . head) [1, 2, 3] :: [(Int, Int)]
01:37:55 <lambdabot>  error:
01:37:55 <lambdabot>      • Couldn't match expected type ‘[Integer] -> [(Int, Int)]’
01:37:55 <lambdabot>                    with actual type ‘[s0]’
01:38:24 <kuribas> > fix (each (const [1, 2, 3]) . head) :: [(Int, Int)]
01:38:27 <lambdabot>  [(1,1),(1,2),(1,3),(2,1),(2,2),(2,3),(3,1),(3,2),(3,3)]
01:39:12 <kuribas> > fix (each (const [1, 2]) . head) :: [(Int, Int, Int, Int)]
01:39:15 <lambdabot>  [(1,1,1,1),(1,1,1,2),(1,1,2,1),(1,1,2,2),(1,2,1,1),(1,2,1,2),(1,2,2,1),(1,2,...
01:47:10 <cocreature> kuribas: neat :)
01:47:41 <kuribas> I was surprised it works with the empty list too :)
01:47:49 <kuribas> > fix (each (const []) . head) :: [(Int, Int, Int, Int)]
01:47:52 <lambdabot>  []
01:48:06 <kuribas> but apparently head never gets called
01:49:30 <kuribas> lenses are so powerfull...
01:50:06 <kuribas> but there is always the tradeoff with readability and beginner-unfriendlyness
03:12:39 <ptek> Hi everyone. Over at the lobsters channel we have had an interesting discussion yesterday about run times of "hello world" created by different languages. I have gotten curious and tested it with the 3 ghc versions. A surprising thing to me was, that on linux it behaves very nicely and the program runs in ~1ms, on macOS though, every compiler version increases the time significantly. ghc 7.10.3 binary runs in 5 ms whereas ghc
03:12:39 <ptek>  8.2.1 is at around ~24.5 ms
03:13:03 <ptek> dies anyone know what could be the reason?
03:13:10 <ptek> here is a gist with the results: https://gist.github.com/ptek/933a4ace5d02790f0ee9cc3e7c638331
03:15:08 <zebr> Hi all. I've got an ugly expression, liftA2 (\t u -> t <*> pure u) :: (Applicative f, Applicative g) => f (g (a -> b)) -> f a -> f (g b). Is there a nicer way of doing this?
03:15:21 <zebr> In my specific usage, g is Maybe
03:17:33 <zebr> I've got a feeling it might make more sense if I used something Monadic...
03:23:24 <rudol> I read that fmap. fmap = fmap fmap fmap. ":t" confirms the types match. I can easily derive the type of fmap . fmap :: (s->t)->f(g s)->f(g t) with pen & paper, by substitution. 
03:23:34 <rudol> When I try the same for fmap fmap fmap I get as far as fmap fmap :: f (p->q)->f(g p->g q) but get stuck at the next step, fmap fmap fmap. I want to match f(p->q) with (s->t->h s-> h t) and then substitute into (h s - h t). Does anybody know what the missing technique is?  
03:24:31 <rudol> f,g,h are obviously all Functor's
03:25:52 <int-e> :t (. fmap pure) . (<*>) . fmap (<*>) -- probably not
03:25:54 <lambdabot> (Applicative f2, Applicative f1) => f2 (f1 (a -> b)) -> f2 a -> f2 (f1 b)
03:26:06 <c_wraith> rudol: you need to unify the types
03:26:29 <rudol> that must be the "technique" I am missing. What does it mean ? ;)
03:27:18 <c_wraith> well, start by allowing every fmap to have a different type.
03:27:19 <int-e> rudol: fmap for the reader functor a |-> (r -> a) is the same as (.)
03:27:32 <rudol> in the fmap . fmap version, you don't hit that requirement 
03:28:30 <int-e> rudol: so the only thing you need to figure out is why that's the only functor possible for the first  fmap  in  fmap fmap fmap.
03:28:43 <rudol> c_wraith I assume you mean more than just using different type var names for each, right?
03:28:51 <c_wraith> rudol: yes
03:29:24 <c_wraith> rudol: then the key is that in the first application of fmap, the second argument needs to unify with the type of fmap
03:29:34 <rudol> c_wraith, that is what I did first a,b & f, then p,q & g then s,t & h
03:30:22 <c_wraith> rudol: so you have something like f a ~ ((s -> t) -> h s -> h t)
03:30:34 <rudol> int-e I fuzzily guessed that is the sort of thing I need to do (specialise a bit, to what _can_ make sense), but I am still missing it  
03:30:58 <c_wraith> rudol: it helps if you rewrite the function type in prefix notation...
03:31:28 <c_wraith> f a ~ ((->) (s -> t) (h s -> h t)
03:31:34 <c_wraith> )
03:32:05 <c_wraith> So then you use generativity and get f ~ ((->) (s -> t)) and a ~ (h s -> h t)
03:33:00 <c_wraith> and that's enough to pick the instance of Functor in use
03:33:43 <c_wraith> And then you look that up and determine that fmap for that Functor instance is (.)
03:34:03 <rudol> so does that mean that fmap . fmap is good for all functors but fmap fmap fmap has constraints on the first fmap
03:34:20 <c_wraith> No.  they're identical.
03:34:31 <c_wraith> the first fmap in fmap fmap fmap *must* be (.)
03:35:14 <rudol> right, in which case, it becomes a pretty obvious equivalence!
03:36:08 <rudol> I will play with that on paper, thank you c_wraith & int-e, and let you know if I need more "subtle hints" ;)
03:37:04 <rudol> btw, is there something to read for this type of derivation or types?
03:37:44 <rudol> especially that goes into more "unify"ing or other non-trivial techniques?
03:38:35 <rudol> I guess the type inferers would be one place to look, but that may be a bit heavy to pick out the practical, useful bits
03:39:19 <rudol> where useful = simple techniques that you can use when intuition alone is not enough to guess the type
03:39:20 <c_wraith> Indeed.  I was trying to think of a well-organized practical intro.  I can't think of one.
03:39:50 <c_wraith> That doesn't mean they don't exist.  They probably do.
03:40:31 <c_wraith> It just means I learned this all through paying attention when other people did it. :)
03:40:51 <rudol> where did you come across this?
03:41:19 <rudol> or who "did it" in front of you? 
03:41:22 <c_wraith> Here, blog posts, stack overflow answers, etc
03:41:46 <rudol> OK, so it is something people like todo on paper, from time to time
03:42:07 <c_wraith> Often it was 1. Someone asks a question.  2. Someone else answers it.  3. I tried to absorb everything I could from the exchange
03:45:32 <rudol> My intuition is that the fact you can do this sort of derivation would be a key reason to what makes haskell so appealing (and  reason'able)
03:46:22 <c_wraith> It's certainly part of it.
03:46:37 <rudol> I expect it would be quite an attractive document (how to derive types), if it existed, for people experiemnting with haskell
03:46:49 <rudol> how to derive types by pen and paper
03:46:58 <rudol> or pencil, in my case
03:48:17 <rudol> there was an SO answer somewhere (I can't find it just now) that gave a nice intro, but this sort of unification (and most likely other techniques that may exist) are not easy to discover working alone
03:48:48 <c_wraith> https://stackoverflow.com/questions/44134833/order-of-type-variables-in-instance-declarations/44139690#44139690 is one example
03:50:37 <rudol> and the comment to it applies here too, thank you!
03:51:55 <c_wraith> but I don't know of a comprehensive intro.  It is a totally obvious thing to have.  I wish I knew of one.  (I hope there is one that I don't know of)
03:52:36 <zebr> I've ended up replacing `liftA2 (\t u -> t <*> pure u)` with `liftA2 (<*>) t (fmap pure u)`, which I think might be a bit less ugly? Not sure how they compare efficiency-wise though.
03:52:48 <c_wraith> I'm also starting to lose coherence as I've been awake about 20 hours.  oops.  :)
04:07:04 <saurabhn_> does stack download preloaded binaries of project-deps or does it download the source and build them? If the latter, what/who decides the GHC options that are used to build the package-deps?
04:07:15 <saurabhn_> s/preloaded/pre-built/
04:19:38 <romanix> saurabhn_, judging from the time in takes to install i'd say it builds from source
04:20:28 <romanix> saurabhn_, but don't quote me on that :)
04:22:04 <cocreature> it builds from source
04:23:23 <cocreature> the options depend on various factors such as an implicit default, the cabal file of the deps, options in your stack.yaml file, cli options, …
04:27:11 <rudol> cocreature, fyi, successfully adapted the "Game" and applied that negamax you helped with to TTT as well (a game I cannot claim to have invented). Thanks.  
04:27:51 <cocreature> rudol: nice!
04:28:39 <saurabhn_> if the cabal file also has ghc-options and they are also passed in via stack --ghc-options, which ones are respected? 
04:29:24 <rudol> the most confusing thing in that minmax impl is probably the use of color:: Double to represent player and fitness value. Also, whether the first arg to negamax is player just moved, or player to move took a bit of working out in the context of FirstPlayerWin and SecondPlayerWin states. 
04:29:37 <rudol> s/minimax/negamax
04:30:55 <olligobber> is there a function that will find the integer part of log_2 of an Integer? Basically count the number of bits the number has?
04:31:35 <olligobber> there's GHC.Integer.Logarithms which has integerLog2# but ghci throws errors about the # when I try to use it
04:32:25 <olligobber> > import GHC.Integer.Logarithms
04:32:28 <lambdabot>  <hint>:1:1: error: parse error on input ‘import’
04:32:44 <olligobber> > integerLog2# 1024
04:32:47 <lambdabot>  error:
04:32:47 <lambdabot>      Variable not in scope: integerLog2# :: Integer -> t
04:53:24 <_sras_> After I compile two haskell source file using the -dynamic flag, "ghc  -dynamic Main.hs Lib.hs ", how can I execute the resulting executable even after delting the object file for Lib? Isn't that required to load Main since it is dynamically linked?
04:54:03 <_sras_> I mean, how come I can still execute the executable even after deleting the object file for Lib?
04:58:00 <olligobber> :exf Int# -> Integer
04:58:00 <exferenceBot> could not parse input type: ParseFailed (SrcLoc "inputtype.hs" 1 6) "Parse error: ->"
04:58:11 <olligobber> oops
04:58:33 <cocreature> :t fromIntegral . Int
04:58:35 <lambdabot> error:
04:58:35 <lambdabot>     • Data constructor not in scope: Int :: a -> Integer
04:58:35 <lambdabot>     • Perhaps you meant one of these:
04:58:37 <cocreature> meh
04:58:49 <cocreature> @let import Data.Int
04:58:50 <lambdabot>  Defined.
04:58:50 <cocreature> :t fromIntegral . Int
04:58:52 <lambdabot> error:
04:58:52 <lambdabot>     • Data constructor not in scope: Int :: a -> Integer
04:58:52 <lambdabot>     • Perhaps you meant one of these:
04:59:00 <cocreature> @let import GHC.Types
04:59:01 <lambdabot>  .L.hs:135:1: error:
04:59:01 <lambdabot>      GHC.Types: Can't be safely imported! The module itself isn't safe.
04:59:01 <lambdabot>      |
04:59:10 <cocreature> % :t fromIntegral . Int
04:59:11 <yahb> cocreature: ; <interactive>:1:16: error:; * Data constructor not in scope: Int :: a -> Integer; * Perhaps you meant variable `int' (imported from Text.PrettyPrint.HughesPJ)
04:59:18 <cocreature> % import GHC.Types
04:59:18 <yahb> cocreature: 
04:59:19 <cocreature> % :t fromIntegral . Int
04:59:20 <yahb> cocreature: ; <interactive>:1:16: error:; * Data constructor not in scope: Int :: a -> Integer; * Perhaps you meant variable `int' (imported from Text.PrettyPrint.HughesPJ)
04:59:30 <cocreature> % :t fromIntegral . I#
04:59:30 <yahb> cocreature: ; <interactive>:1:16: error:; * Couldn't match a lifted type with an unlifted type; When matching the kind of `GHC.Prim.Int#'; * In the second argument of `(.)', namely `I#'; In the expression: fromIntegral . I#
04:59:34 <cocreature> well I give up
05:00:31 <olligobber> :exf GHC.Prim.Int# -> Integer
05:00:31 <exferenceBot> could not parse input type: ParseFailed (SrcLoc "inputtype.hs" 1 15) "Parse error: ->"
05:01:12 <olligobber> cocreature, should fromIntegral . Int do it?
05:02:16 <cocreature> olligobber: "\x -> fromIntegral (I# x)" should do it
05:03:43 <olligobber> cocreature, finally got that working, ty
05:04:38 <olligobber> cocreature++
05:13:43 <olligobber> the need for -XMagicHash is kind of annoying
05:19:22 <zennist> is Codensity useful for FreeT ?
05:19:29 <zennist> note: FreeT not Free
05:20:03 <zennist> I suspect it should still be useful, so the structure is not traversed again and again for mappings; but I'd like to hear people's thoughts
05:20:50 <c_wraith> zennist: https://hackage.haskell.org/package/free-4.12.4/docs/Control-Monad-Trans-Free-Church.html
05:21:05 <c_wraith> zennist: that basically is inlined Codensity
05:22:24 <zennist> wow didn't know this. the type signature requires a bit of mental digestion though
05:22:34 <zennist> is there any reference about this 'church encoding of free'?
05:22:45 <zennist> I suspect Edward Kmett's blog?
05:22:50 <_sras_> I have two source files. Main.hs and Lib.hs, how can I compile them using GHC so that stuff in Lib is dynamically linked to the final executable?
05:23:32 <c_wraith> zennist: church encoding of a data type is a mechanical transformation.
05:24:44 <c_wraith> zennist: you should be able to find a lot of explanations of that
05:25:31 <zennist> actually the doc page of Control.Monad.Free.Church contains the links - thanks!
05:38:00 <prietoj> I'm having some issues using left joins in Opaleye and I was wondering weather someone more experienced than me could help. I created a stackoverflow question about it: https://stackoverflow.com/questions/46853074/left-join-in-opaleye
05:46:09 <mxf> Hi *, are there any libs on hackage to provide me with a monotonically increasing identifier (Word32/Word64) with a monadic interface?
05:46:41 <lyxia> mxf: StateT
05:48:02 <mxf> lyxia, well, yes, I could roll my own. Just thought that maybe this was an already solved subproblem :)
05:50:02 <srhb> mxf: It's basically a oneliner with state, so I doubt there's a package for it already.
05:50:32 <cocreature> mxf: you can use https://hackage.haskell.org/package/monad-supply-0.6/docs/Control-Monad-Supply.html
05:51:52 <lyxia> prietoj: what's the error on the first attempt
05:52:17 <mxf> cocreature, ah, that looks useful :)
05:52:24 <mxf> thanks, y'all.
05:58:16 <lamdevhs> hello, i'm trying to use the alternative methods over the type (a -> Maybe b), or more generally, over (Alternative f => a -> f b), so that i can transform a [a -> Maybe b] into (a -> [Maybe b])... but it doesn't work, even if i try using ReaderT and such...
05:58:41 <lamdevhs> wait no i want to transform [a -> Maybe b] into (a -> Maybe b)
06:00:07 <lyxia> :t asum . sequence
06:00:09 <lambdabot> (Foldable t, Monad t, Traversable f, Alternative f) => f (t a) -> f a
06:00:38 <lyxia> hmmm not quite
06:00:43 <lyxia> :t fmap asum . sequence
06:00:45 <lambdabot> (Monad f2, Traversable t, Alternative f1) => t (f2 (f1 a)) -> f2 (f1 a)
06:00:51 <lyxia> very readable
06:02:22 <lamdevhs> lyxia: perfect :)
06:02:43 <lamdevhs> i just found there's an instance Alternative m => Alternative (ReaderT * r m)
06:02:56 <lamdevhs> what's the star in the definition?
06:03:42 <lamdevhs> :t asum
06:03:43 <lyxia> It's because ReaderT is polykinded
06:04:21 <int-e> :t asum
06:04:29 <lambdabot> (Alternative f, Foldable t) => t (f a) -> f a
06:04:46 <lamdevhs> oh it's in foldable then?
06:05:01 <lyxia> lamdevhs: ReaderT k r (m :: k -> *) (a :: k) === (r -> m a)      a does not have to be a type (something of kind *)
06:05:15 <lamdevhs> lyxia: polykinded?
06:05:34 <lyxia> but morally everything else in transformers and mtl assumes it is, so I'm not sure why they generalized it.
06:06:06 <lamdevhs> lyxia: you mean a could be (* -> *) in that definition, or sth?
06:06:09 <lyxia> lamdevhs: yeah
06:06:37 <lyxia> lamdevhs: kinds are to types what types are to values
06:07:09 <lamdevhs> lyxia: wow i can barely wrap my mind around that idea... but then what does that star exactly means in (ReaderT * r m)?
06:07:42 <ph88> what's a good data format & library for spreadsheet like calculations ?
06:08:42 <lyxia> lamdevhs: * is the kind of types. Here, it's saying that  a  must be of kind  *
06:09:32 <lamdevhs> lyxia: do you have examples of m such that m :: ((* -> *) -> *)?
06:09:36 <_sras_> I have two source files. Main.hs and Lib.hs, how can I compile them using GHC so that stuff in Lib is dynamically linked to the final executable?
06:10:06 <lamdevhs> lyxia: but why is it after ReaderT and before r m ? i don't get that notation
06:11:12 <lyxia> lamdevhs: data M f = M (f Int)   now you can have ReaderT (* -> *) r M Maybe
06:12:18 <lyxia> lamdevhs: it's an additional parameter to ReaderT, and the convention is that kinds come before types.
06:13:10 <unyu> Is kind polymorphism specified in the Haskell Report, or a GHC extension?
06:14:01 <int-e> unyu: the latter
06:15:02 <hpc> unyu: you should read the report if you haven't, it's a pretty easy read for the most part
06:15:05 <hpc> @where report
06:15:06 <lambdabot> http://www.haskell.org/onlinereport/haskell2010/ (more: http://www.haskell.org/haskellwiki/Definition)
06:17:41 <lamdevhs> lyxia: ok! so, in (ReaderT * r m), the first parameter implies a does is of kind (*), right?
06:17:52 <lyxia> yes
06:17:59 <ph88> can anyone recommend a library for matrix calculations? there are quite a few ^^
06:18:46 <lyxia> ph88: hmatrix, it's a bit clunky but does the job
06:19:01 <ph88> why do you recommend that one ?
06:20:24 <ph88> i see it has a lot of commits on github ^^
06:20:25 <ocramz> hullo
06:20:35 <ph88> hai
06:20:57 <ocramz> I'd need to write the Storable instance of a tuple type: `instance (Ord i, Eq e) => Ord (COOElem i e)`
06:21:24 <ocramz> since `i` and `e` are in general different, what would the `alignment` be?
06:21:37 <lamdevhs> ok, thanks a lot lyxia! :)
06:21:51 <ocramz> sorry, pasted the wrong line
06:22:03 <ocramz> this is the type I need to make Storable : newtype COOElem i e = CooE (i, i, e)
06:23:00 <ocramz> is the `alignment` the sum of the type sizes?
06:23:48 <lyxia> ph88: it's the only one I remember trying :)
06:24:26 <lyxia> ocramz: it should be the max.
06:25:10 <ocramz> right, thanks lyxia
06:25:24 <ph88> can you mmap files directly if the type was Storable ?
06:25:55 <lyxia> ph88: I think you can but I don't know the details offhand
06:26:47 <hpc> ocramz: you might want to look at the C struct alignment rules - i thiiiiiiink that's what Storable is based on
06:26:49 <lamdevhs> lyxia: m :: ((* -> *) -> *) makes me think of the cont monad... is there an implementation of monads at the type level? not that i'm sure what use one would have for it...
06:27:47 <tsakatsaka> hey guys, anyone up to answer a n00b question?
06:27:57 <ocramz> hpc : thanks, any .. uh, pointers to relevant documentation?
06:28:54 <hpc> not for C, i try to avoid it wherever possible
06:29:05 <lyxia> lamdevhs: no idea
06:29:55 <tsakatsaka> is there a haskell function that takes n elements including and after a given index m?
06:30:19 <hpc> :t \n m -> take n . drop m
06:30:20 <lambdabot> Int -> Int -> [a] -> [a]
06:30:27 <hpc> > take 5 . drop 10 $ [1..]
06:30:32 <lambdabot>  [11,12,13,14,15]
06:30:56 <lamdevhs> something like Return (a :: k) :: ((k -> *) -> *), Bind (ma :: (k -> *) -> *) (kleisli :: k -> (k' -> *) -> *) :: (k -> *) -> * ... it's not very readable though...
06:31:10 <tsakatsaka> thanks hpc :)
06:31:32 <tsakatsaka> thanks guys
06:31:50 <hpc> tsakatsaka: keep in mind that it has complexity of n+m, and it's not a terribly natural operation to perform on linked lists
06:32:40 <hpc> tsakatsaka: so if you need it too extensively, also consider tweaks to your algorithm
06:32:40 <tsakatsaka> right. that's not very important to me at the meantime, optimisation comes later.
06:32:53 <tsakatsaka> thank you though
07:01:07 <ph88> how can i sum a column with hmatrix ?
07:35:08 <eschnett> lamdevhs: would ‘[] be an instance of this? are you looking for an operation to convert ‘[[Int]] to ‘[Int] ?
07:42:55 <epta> 'stack build' says 'Unknown fields: autogen-modules', but it seems to be that cabal-2.0.0.2 is used, since 'Generating .stack-work/dist/x86_64-osx/Cabal-2.0.0.2/build...'
07:43:01 <epta> what is wrong with it?
07:43:02 <cocreature> ph88: not sure I understand your question, do you want to sum all entries in a column?
07:53:54 <Gurkenglas> How do I tell intero (or just stack) to accept "import Graphics.Gloss" in a .hs file outside a project?
07:54:41 <cocreature> run "stack build gloss" outside of a project
08:07:44 <stevenxl> Hi folks. I am trying to use Hspec's automatic spec discovery feature (https://hspec.github.io/hspec-discover.html). I have set up the Spec.hs file as directed in the instructions, and I have set up two files. The second file is nested under a subdirectory of test, which according to the directions should work, but when I run stack build test it says that the second file cannot be found.
08:07:52 <stevenxl> here is the actual code: https://github.com/StevenXL/todo/tree/06-add-skeleton-test-suite
08:10:02 <EvanR> brilliant
08:10:05 <EvanR> oops
08:11:45 <stevenxl> dang it. seems like moving stuff into a subdir is not working.
08:18:11 <cocreature> stevenxl: hspec-discover is working just fine. the problem is that you are missing test/features in hs-source-dirs
08:21:43 <stevenxl> cocreature: Thank you. I poked around a bit, and it seems like it's an issue with directory naming. If I change the directory from `features` to `Features`, and the file name from `TestingFeatureSpec` to `Features.TestingFeatureSpec`, it gets picked up.
08:26:06 <cocreature> stevenxl: it’s not so much an issue as it is just different behavior. if you are telling cabal the module is named TestingFeatureSpec but there is no module by that name in hs-source-dirs the build fails. if you are telling it you have a module Features.TestingFeatureSpec cabal finds that module because hierarchical modules are searched in subdirectories by that name. hspec-discover is completely
08:26:08 <cocreature> irrelevant to this
08:26:58 <cocreature> but hierarchical modules are the better solution for this imho
08:27:10 <stevenxl> cocreature: Got it. Thank you very much! That is going to save me a TON of pain in the future.
08:27:29 <stevenxl> Just like the fact that modules without a module clause default to Main. That bit me once too.
08:27:32 <stevenxl> Thank you
08:31:28 <adamretter> Could someone suggest to me how I would manage an asymetrical locking pattern in Haskell, something like 1) lock collection, 2) get document from collection, 3) lock document, 4) release collection lock, 5) do something with document, 6) release document lock
08:33:06 <dsal> adamretter: that sounds like a complicated thing.  Can you use STM instead?
08:34:09 <cocreature> adamretter: looking into STM as dsal suggested is probably a good idea but if you really want/need to stick to that pattern, you could make an "MVar [MVar Document]" which stores the documents and then the inner mvars are responsible for locking the individual documents
08:34:16 <adamretter> dsal: actually the problem I am trying to solve is in Java 8, but now that I have some functional facilities in Java 8. I wondered how one would create such a sensible pattern in Haskellk. So er, STM is probably out
08:35:23 <cocreature> I don’t think looking at Haskell concurrency patterns is going to be particularly helpful if you’re actually interested in Java
08:36:00 <cocreature> mostly it’s going to result in you being incredibly frustrated at how easy this is in Haskell and how painful it is in Java :)
08:36:36 <adamretter> cocreature: probably... hehe well I sometimes adopt concepts from Scala and Haskell and use those patterns in Java
08:36:50 <adamretter> cocreature: obviously there is only so far you can push that ;-)
08:37:32 <cocreature> adamretter: yeah I’m not saying that taking ideas from Haskell is a bad idea in general but for concurrency that works particularly badly since concurrency concepts are tied relatively closely to the language
08:38:20 <cocreature> e.g. Haskell has lightweight threads, STM, immutability by default, … all of which influence the way we handle concurrency quite heavily and none of those is easily translatable without language support
08:38:51 <adamretter> cocreature: hmmm, I just wondered initially if IO had anything to help with this, i.e. acquiring a resource, and then releasing it. just like a database connection. But mixing acquisition/release of two resource types asymetrically
08:40:11 <cocreature> adamretter: resourcet (https://hackage.haskell.org/package/resourcet-1.1.9/docs/Control-Monad-Trans-Resource.html) allows safe resource management without limiting you to stack-based resource allocation so you could try to use something like that
08:40:29 <adamretter> cocreature: okay cool thanks, I will take a look
08:40:41 <cocreature> but I’ve never seen anybody use that to manage locks
08:40:53 <adamretter> cocreature: An approach I hacked together is at the end of this Stackoverflow question if anyone wanted to take a look - https://stackoverflow.com/questions/46864834/best-design-pattern-for-managing-asymmetrical-resource-use
08:49:21 <unyu> Why does Python need a fancy metaprogramming library just to sanely define data types? http://www.attrs.org/en/stable/
08:50:32 <sedeki> :-)
08:51:13 * unyu does like the API, though.
08:54:00 <adamretter> cocreature: the ability to call release early for resourcet, looks kinda like what I want. Thanks
08:55:22 <unyu> Oops, wrong channel.
08:59:58 <monochrom> Scheme and Racket also need fancy metaprogramming to define algebraic data types and pattern matching.
09:00:29 <monochrom> But you can play it up as their strength.
09:01:45 <stevenxl> making progress folks! had to download selenium server and chromdriver but heck it's all in the instructions.
09:01:46 <stevenxl> ;-)
09:14:30 <ph88> cocreature, yes i want to sum all entries in a column
09:15:15 <cocreature> ph88: first extract the column vector (either by multiplying with an appropriate vector or by using (¿)) and then use sumElements
09:16:22 <ph88> cocreature, i can't find the documentation for (¿)
09:16:37 <cocreature> ph88: http://hoogle.haskell.org/?hoogle=(%C2%BF)
09:16:41 <ph88> thx
09:16:58 <spark712> hey guys I have a compiler frontend question. in haskell it really doesn't seem like much people seperate the lexing and parsing passes. is that a thing in haskell compiler dev, or am I just looking in all the wrong places? I'm trying to do a project building a compiler from scratch in haskell. And I'd prefer to handcraft everything (excluding the backend which i'll be using LLVM for.) 
09:17:03 <cocreature> the hmatrix author seems to hate people who don’t know how to input unicode symbols
09:17:09 <ph88> i was making my own (¿) because i couldn't find it  lol
09:17:59 <hpc> spark712: alex and happy impelement a more traditional lexer/parser combination
09:18:21 <hpc> but a lexer is really just a special case of a parser where the output is just a list of tokens
09:19:31 <ph88> cocreature, can i use hmatrix with arbitrary precision for financial calculations? i worked with this before http://php.net/manual/en/book.bc.php
09:20:16 <spark712> hpc: so overall the haskell community avoids the situation by making it part of the parser run? 
09:21:20 <hpc> yeah
09:21:29 <cocreature> ph88: as long as you can provide an instance of Numeric, it should work
09:21:32 <hpc> a combined parser tends to look the same as what a split-out parser would be
09:21:53 <hpc> but you don't have to worry about having a /second/ parser that's basically fancy words
09:22:02 <hpc> > words "let x = 5 in x"
09:22:04 <lambdabot>  ["let","x","=","5","in","x"]
09:22:09 <ph88> cocreature, can you recommend a haskell library for financial calculations ?
09:22:22 <cocreature> ph88: no, never had the need for one :)
09:22:41 <Tuplanolla> Then again, nothing stops you from adding more stages either, spark712.
09:23:35 <monochrom> GHC uses alex and happy. So it does two stages.
09:24:20 <monochrom> But libraries like parsec make it so much convenient to merge them into one stage.
09:24:38 <spark712> Tuplanolla: true, but honestly if I keep adding more stages it gets nasty. 
09:25:19 <monochrom> Actually maybe GHC doesn't use alex. I am not sure about that part. It is certainly two stages, maybe three---layout needs special treatment.
09:25:36 <cocreature> monochrom: I’m fairly sure it uses alex :)
09:25:54 <monochrom> You use whichever number of stages that keeps your whole thing well-organized.
09:26:27 <monochrom> It just turns out that the yacc style is more organized with two stages, and the parsec style is more organized with one stage.
09:27:10 <monochrom> And even then that statement is only usually true, not always true.
09:27:57 <spark712> ahhh fair enough
09:28:56 <spark712> how would I approach handcrafting a parser, though? so often it automatically jumps to the ready-made tools. but sometimes you just want to take the scenic route for education, you know?
09:31:20 <Tuplanolla> You start with functions of the type `Stream s -> Maybe (Stream s, a)` and define some types and instances to make them easy to use, spark712.
09:33:09 <spark712> Thanks for the answer, and I appreciate the response especially with what seems like sass XD 
09:37:57 <Tuplanolla> You see, a parser is just a function that takes a `Stream` of tokens `s` and gives you either `Nothing` to indicate an error or a truncated `Stream` with the result `a` removed.
09:38:10 <nicknight> hi any old wise man above 50 here ? I want to talk
09:39:04 <spark712> yeah I suppose it was a pretty poor question
09:39:09 * hdurer[m] sent a long message: hdurer[m]_2017-10-21_16:38:46.txt <https://matrix.org/_matrix/media/v1/download/matrix.org/RjWzKzJgoMCNOiNCqlnKYtfK>
09:40:34 <kl_5> hi
09:41:06 <kl_5> i'm trying to understand hmatrix's type-level operations for checking matrix-vector computations
09:41:41 <kl_5> having trouble understanding what's happening here https://mstksg.github.io/hmatrix/src/Internal-Static.html#line-51
09:42:13 <kl_5> which seems like a key part of the implementation
09:51:41 <sm> ph88: how about hledger-lib or safe-money
09:54:24 <sm> spark712: I have the impression multi-stage parsing makes it harder to provide precise error messages
09:55:04 <sm> while single-stage parsing can become a nightmare of fiddly whitespace/line end handling, unless you are systematic perhaps
10:02:19 <wuss> What's the easiest way to have two wuss websocket clients talk to one another? I basically need to share data from one websocket client to the the other. I'm thinking of using Pub/Sub but I'm not sure if there's a cleaner way in Haskell.
10:04:38 <lyxia> kl_5: there's not much going on at the type level here. The KnownNat n constraint provides a value level representation of n that you can access with natVal.
10:05:20 <lyxia> kl_5: So a value of type Dim n a is serialized as n followed by the wrapped a value.
10:06:53 <kl_5> lyxia - what's with the recursive k <- get?
10:07:39 <kl_5> also is there a good explanation of Proxy? I get that it's for exchanging information between value and type level
10:08:12 <lyxia> kl_5: get is overloaded. The instance is defining "get @(Dim n a)", i.e., "get" for the type "Dim n a", which relies on "get @Integer" (the first call) and "get @a" (the second one).
10:08:26 <kl_5> but it seems a lit like black magic (the use of Proxy)
10:09:35 <lyxia> kl_5: data Proxy a = Proxy, so as a value it is like (), it's just there so there is a value to pass around but otherwise carries no information at runtime.
10:10:18 <kl_5> are proxies and singletons the same thing?
10:10:23 <lyxia> no
10:10:33 <lyxia> kl_5: Something that one would like to write, for example with integers, is   class KnownNat n where natVal :: Integer
10:10:50 <spark712> sm: how could I ensure being systematic? 
10:10:58 <lyxia> kl_5: meaning that for every type-level natural, there  is an Integer value representing it. Does that make sense?
10:11:11 <kl_5> yes that makes sense
10:11:40 <kl_5> is that what proxy is for?
10:11:52 <lyxia> kl_5: the problem with that definition I just wrote is that the type of natVal is ambiguous. If you use it, there is no way too infer what n you want
10:12:34 <lyxia> kl_5: for example, what is the output of   print natVal ?
10:13:15 <kl_5> you would have to write print (natVal :: Nat 3) or something right? 
10:13:21 <lyxia> no natVal :: Integer
10:14:09 <kl_5> hm I was confused so the type of natVal is Integer
10:14:27 <lyxia> kl_5: I mean, in the definition of KnownNat I wrote it is. 
10:14:28 <kl_5> but what you want is some mapping betwen the Nat kind types
10:14:32 <lyxia> But in GHC it's not
10:14:41 <kl_5> and get natVal integers... is how i understood it
10:15:31 <kl_5> so what's the problem with print natVal? if natVal is just an Integer?
10:15:47 <lyxia> which Integer is it?
10:16:16 <kl_5> I guess I'm confused where natVal is defined
10:16:57 <kl_5> how does one write down the definition of natVal so it maps to the Kind types?
10:17:15 <lyxia> it's defined by the compiler, but you can imagine that there are instances like this:   instance KnownNat 0 where natVal = 0    instance KnownNat 1 where natVal = 1   etc.
10:17:44 <glguy> Are you talking about: natVal :: KnownNat n => proxy n -> Integer  ?
10:17:55 <glguy> or a local definition not from GHC.TypeLits
10:17:55 <lyxia> yeah I'm trying to explain why there's proxy
10:18:04 <glguy> oh, OK
10:18:06 <lyxia> and so I started with the naive way of no proxy
10:18:14 <kl_5> ok yes I see the ambiguity I think
10:18:28 <kl_5> or rather it's overloaded across types
10:19:27 <kl_5> so natVal is the function that has to be implemented for kind KnownNat, it takes no arguments
10:19:37 <kl_5> so natVal alone could correspond to any concrete implementation
10:19:59 <kl_5> right?
10:20:23 <lyxia> That doesn't sound quite right.
10:20:27 <lyxia> KnownNat is a typeclass
10:20:38 <lyxia> In the constraint KnownNat n, n has kind Nat
10:21:16 <kl_5> Okay I was confused between the typeclass and the kind
10:21:22 <lyxia> natVal is an overloaded Integer, and there is one implementation for every value of n.
10:21:58 <LoveCoinz> https://cryptosrevolution.wixsite.com/beta
10:22:15 --- mode: ChanServ set +o glguy
10:22:15 --- mode: glguy set +b *!*@vps-0105.uppersafe.net
10:22:15 --- kick: LoveCoinz was kicked by glguy (spam)
10:22:40 <lyxia> kl_5: and the problem is that there is no way to infer which implementation to use when you write natVal
10:22:59 <kl_5> abstractly speaking is it necessary to have both kinds and typeclasses? it seems they are both specifications of sets of types.
10:23:42 <EvanR> neither are really about sets
10:24:08 <EvanR> is it necessary to have both types and kinds, no
10:24:18 <EvanR> hence the TypeInType extension
10:24:32 <kl_5> I haven't gotten to TypeInType yet...
10:24:42 <kl_5> isn't a Kind a set of types?
10:25:36 <kl_5> lyxia coming back to your statement yes that makes sense that the implementation of natVal can't be inferred without more context regarding which KnownNat is being referred to
10:25:56 <lyxia> Sets is a too coarse grained way of looking at kinds and type classes.
10:26:30 <kl_5> fair enough, what's a better definition of kind, if not a set of types?
10:26:37 <lyxia> By analogy, it's like saying that types, functions "a -> Bool", and "Set a" are all ways of defining sets of values.
10:26:52 <lyxia> well it's true, but they serve different purposes.
10:27:48 <kl_5> what is the purpose of a typeclass vs. the purpose of a kind?
10:28:22 <glguy> typeclasses allow us to define values whose implementations vary by their types, kinds allow us to ensure that our type expressions are well formed
10:28:48 <kl_5> @glguy that works for me.
10:28:48 <lambdabot> Unknown command, try @list
10:29:40 <kl_5> so regarding proxy then, how does it solve the ambiguity problem?
10:29:55 <lyxia> kl_5: natVal is ambiguous because n did not appear in its type.
10:30:29 <lyxia> kl_5: so you make it a constant function, so that n can appear in the type of the dummy argument
10:30:59 <kl_5> what do you mean by "appear"? in the implicit typeclass definitions you mentioned, n does appear
10:31:13 <lyxia> kl_5: natVal :: Integer    <- there is no n
10:31:43 <kl_5> yes 
10:32:10 <kl_5> ok so a constant function where the "indexed" typed appears
10:32:14 <kl_5> how does that look?
10:32:33 <lyxia> natVal :: proxy n -> Integer
10:33:25 <kl_5> where does the Proxy type come in, couldn't I have done this directly
10:33:35 <kl_5> for example, if I'm defining Vector n
10:33:40 <Jenaf> hi there! I'm confused, I get a "read error on "where" in this file: http://lpaste.net/359424
10:33:41 <lyxia> done what?
10:33:43 <kl_5> natVal :: Vector n -> Integer
10:33:51 <Jenaf> it's propably an indentation issue 
10:33:55 <kl_5> why do I need the Proxy type itself?
10:33:58 <Jenaf> fml
10:34:00 <Jenaf> I'm stupid
10:34:16 <Jenaf> feel free to ignore me
10:34:39 <lyxia> kl_5: well the integer you get has nothing to do with the vector
10:34:58 <lyxia> what if you don't have a vector lying around?
10:36:26 <kl_5> ok so how does the Proxy type interact with the type of interest?
10:36:44 <kl_5> so natVal :: Proxy n -> Integer
10:36:57 <kl_5> gives you the value corresponding to the type n
10:37:20 <kl_5> how do you apply that to the type of interest that's not Proxy
10:37:46 <kl_5> oh I think I see
10:37:48 <kl_5> n is shared
10:38:25 <kl_5> for the instance declaration right?
10:39:33 <lyxia> yes it's the same n.  class KnownNat n where natVal :: Proxy n -> Integer
10:39:39 <kl_5> is that always the pattern of usage, that Proxy is used in the context of instance declarations?
10:41:45 <lyxia> To avoid ambiguous types, yes.
10:42:23 <kl_5> more generally, are value level checks on types always implemented as typeclass instance declarations?
10:42:58 <lyxia> BTW, since last year, we have TypeApplications, so with the ambiguous definition of natVal :: Integer, we could instead write   natVal @42  to select the right instance 
10:43:32 <kl_5> yikes I'm still trying to catch up to 2012 Haskell :(
10:43:34 <sQVe> Is anyone using VSCode and Haskero when coding Haskell?
10:43:50 <sQVe> Trying to read the install instructions for Haskero but the repo seems to be missing now.
10:44:08 <kl_5> sQVe not yet but i'm flirting with transitioning from spacemacs 
10:44:12 <sm> spark712: eg consistently having all parsers eat leading whitespace or something, I haven't mastered it myself. If it were me, I would go read megaparsec's tutorials
10:44:35 <sQVe> kl_5: You should try VSCode. It's very very good
10:45:22 <kl_5> sQVe - does it work with ghci? i opened it up once and wasn't sure how to get the repl open
10:46:09 <sQVe> kl_5: I'm unsure how well it works with Haskell and it's tooling. I've used it mainly for JS development.
10:46:31 <sQVe> It's what I use daily when coding.
10:47:23 <lyxia> kl_5: Yes, typeclasses are how we pass type information as values
10:48:08 <kl_5> I see somehow that wasn't clear from tutorials but I probably missed that
10:48:23 <spark712> sm: thanks for the advice
10:51:12 <sm> spark712: no problem. I'm referring to https://markkarpov.com/learn-haskell.html#megaparsec-tutorials and discussion like https://markkarpov.com/megaparsec/parsing-simple-imperative-language.html
11:02:40 <spark712> thanks
11:05:47 <asthma[m]> hello
11:05:55 <sedeki> hello
11:06:29 <asthma[m]> I'm trying to learn haskell with the book from first principles, any advice you can give me about it or is it a good way of learning haskell?
11:07:31 <sedeki> I'm also reading it
11:07:37 <kl_5> asthma[m] that's the book to use :)
11:07:37 <sedeki> i really like it
11:08:01 <kl_5> don't skimp on the exercises or you will need to backtrack 
11:08:24 <kl_5> it's a great book
11:09:12 <Zemyla> ZipList doesn't have Eq1/Ord1/Show1/Read1 instances.
11:09:51 <kl_5> sedeki asthma[m] how far along are you? I got to about Reader and took a break to work on some projects
11:10:38 <cocreature> Zemyla: sounds like you have an excuse to make your first contribution to "base" (or your nth if you’ve contributed before) :)
11:11:08 <sedeki> kl_5 I'm on the chapter on monoids and semigroups
11:11:13 <sm> asthma[m]: what kind of advice do you need ?
11:11:17 <asthma[m]> I'm at recursion, I'm wondering when I'll have enough foundation to start programming
11:11:57 <asthma[m]> sm: if the new book is the canonical way of doing it, and if the channel has feedback on it
11:13:00 <sm> HPFFP is the most thorough and most popular way. HTAC is a little known faster way that's also good.
11:13:04 <sm> @quote FAQ books
11:13:04 <lambdabot> FAQ says: What are some good books for learning haskell ? Haskell Tutorial And Cookbook (HTAC), Programming In Haskell (PIH), Programming In Haskell (PIH)
11:13:23 <sm> hm
11:13:35 <sm> @quote FAQ htac
11:13:35 <lambdabot> FAQ says: What are some good books for learning haskell ? Haskell Tutorial And Cookbook (HTAC), Programming In Haskell (PIH), Programming In Haskell (PIH)
11:14:27 <Zemyla> I don't know how to contribute to base.
11:15:00 <sm> fixed @quote FAQ books
11:16:52 <Zemyla> Also, I submitted a proposal to the libraries mailing list.
11:18:35 <ski> sm : <https://leanpub.com/haskell-cookbook> ?
11:19:50 <lyxia> asthma[m]: have you read this http://www.haskellforall.com/2017/10/advice-for-haskell-beginners.html
11:20:50 <sm> @quote FAQ authoritative book
11:20:50 <lambdabot> FAQ says: What's an authoritative book for learning haskell ? Programming In Haskell (PIH) http://www.cs.nott.ac.uk/~pszgmh/pih.html
11:20:53 <sm> @quote FAQ thorough book
11:20:54 <lambdabot> FAQ says: What's a thorough book for learning haskell ? Haskell Programming From First Principles (HPFFP) http://haskellbook.com/
11:20:56 <sm> @quote FAQ fast book
11:20:57 <lambdabot> FAQ says: What's a fast book for learning haskell ? Haskell Tutorial And Cookbook (HTAC) https://leanpub.com/haskell-cookbook
11:21:01 <sm> yup
11:21:07 <jkachmar> I'd caution people against the "fast path" towards the language fwiw.
11:21:20 <jkachmar> I tried that a few ways and ended up nowhere useful with not much other than wasted time.
11:21:34 <ski> @where HPFFP
11:21:35 <lambdabot> "Haskell Programming: from first principles - Pure functional programming without fear or frustration" by Chistopher Allen (bitemyapp),Julie Moronuki at <http://haskellbook.com/>,#haskell-beginners
11:21:37 <ski> @where books
11:21:38 <lambdabot> See `LYAH',`RWH',`YAHT',`HR',`wikibook',`PCPH',`HPFFP',`non-haskell-books'
11:22:13 <bitemyapp> I discussed some of the learning resources here: http://bitemyapp.com/posts/2014-12-31-functional-education.html
11:22:24 <fresheyeball> hey out there
11:22:28 <MarcelineVQ> authoritative? hmm
11:22:37 <fresheyeball> Anyone have experience with Exinst?
11:22:47 <sm> MarcelineVQ: got a better word to differentiate it ? I didn't want to say academic
11:23:12 <fresheyeball> I have a circumstance where I need to go from an existentialized singleton
11:23:19 <sm> ski: nice. These schemes have pros and cons
11:23:23 <fresheyeball> to a type class via Dict
11:23:28 <ski> schemes ?
11:23:29 <fresheyeball> that is based on a type family
11:23:40 <fresheyeball> and for some reason, I can't annotate myself to freedom
11:23:41 <jkachmar> I need to give HTAC a more thorough readthrough, but at first glance the first section strikes me as too short to meaningfully educate people with no background in typed FP.
11:24:03 <sm> jkachmar: if you read it, let us know how it goes
11:24:21 <sm> not every book works for everyone, nobody is promising that
11:24:49 <sm> I think it's among the best three, currently
11:24:53 <MarcelineVQ> sm: ehe not having read it I've no idea really, I'm just a bit of a rebel
11:25:11 <stevenxl> what is htac?
11:25:22 <sm> MarcelineVQ: it was one of the first, and has been consistently rated as excellent 
11:25:31 <ski> stevenxl : "Haskell Tutorial and Cookbook" by Mark Watson in 2017-09-04 at <https://leanpub.com/haskell-cookbook>
11:25:51 <jkachmar> sm my main concern is that it's a few hundred pages, but tries to bootstrap people up from no knowledge through REST APIs, DB interfacing, NLP, and web scraping.
11:25:51 <stevenxl> ski: Thank you. 
11:26:00 <ski> @where+ HTAC "Haskell Tutorial and Cookbook" by Mark Watson in 2017-09-04 at <https://leanpub.com/haskell-cookbook>
11:26:00 <lambdabot> It is forever etched in my memory.
11:26:01 <EvanR> subtitle, a gentle introduction hehe
11:27:02 <jkachmar> There's a lot of code slung at the reader, but (again, at first glance) a dearth of exercises which are absolutely crucial for education.
11:27:22 <sm> jkachmar: I understand your concern, but not every reader wants exercises
11:27:36 <jkachmar> That's fine, but they are _objectively_ the best way to reinforce education of a novel concept.
11:27:48 <MarcelineVQ> a reader might not, but a learner should :X
11:27:57 <stevenxl> I am looking at the author post on reddit, and he says that it covers network programming, so hopefully helps me do websites
11:27:58 <stevenxl> lol
11:28:01 <sm> a long book is not objectively always the best way to teach
11:28:02 <jkachmar> If you're coming from a point of knowledge, a lack of exercises is fine. If you want a cookbook that's great! And that's half of what HTAC purports itself to be.
11:29:18 <crucify_me> hi   I guess you can't use eta reduction with (!!) i.e.  third_elem = (!!) 2 .. you would need third_elem list = (!!) list 2 .   why is that?
11:29:48 <stevenxl> I'm very much looking forward to Intermediate Haskell and Haskell Almanac. Thing is I can't wait around to learn all of this before building stuff. I'm trying to contribute to small libraries and, through that, hopefully have people better than me showing me how to improve.
11:29:49 <EvanR> third_elem = flip (!!) 2
11:30:22 <EvanR> eta conversion works like f x = g y x => f = g y
11:30:27 <MarcelineVQ> :t (!!)  -- eta reduction reduces the last argument, put loosely, the list is the first argument
11:30:29 <jkachmar> stevenxl Sure, but I'm assuming at this point you already have some basis of knowledge that allows you to program in the language, right?
11:30:30 <EvanR> your arguments are in the right order for tht
11:30:31 <lambdabot> [a] -> Int -> a
11:30:34 <ski> @where PIH "Programming in Haskell" by Graham Hutton in 2007-01-15,2016-09-01 at <http://www.cs.nott.ac.uk/~pszgmh/pih.html>
11:30:34 <lambdabot> I know nothing about pih.
11:30:37 <ski> @where+ PIH "Programming in Haskell" by Graham Hutton in 2007-01-15,2016-09-01 at <http://www.cs.nott.ac.uk/~pszgmh/pih.html>
11:30:37 <lambdabot> Nice!
11:31:11 <crucify_me> they're in the right order? EvanR 
11:31:29 <EvanR> you cant drop the argument 'list' , its not last
11:31:30 <stevenxl> jkachmar: Yea. I mean, I still get freaked out by Monad Transformers, and I still don't know how to pass a dbConnection into my Servant handlers, but I believe there are examples that I can follow and, very slowly, tease out what is going on.
11:32:03 <fresheyeball> oh shit
11:32:08 <fresheyeball> I see what it wont work
11:32:09 <EvanR> youd have to flip (!!) 
11:32:20 <fresheyeball> you can't have a typeclass parameterized on a type family
11:32:24 <ski> @where+ books See `LYAH',`RWH',`YAHT',`HR',`PIH',`wikibook',`PCPH',`HPFFP',`HTAC',`non-haskell-books'
11:32:24 <lambdabot> Okay.
11:32:44 <EvanR> crucify_me: actually you could do f = (!! 2), a section
11:32:59 <fresheyeball> class Foo (f :: k -> k) where doesn't work
11:33:06 <crucify_me> interesting EvanR thanks. hold on I'm waking up
11:33:08 <jkachmar> stevenxl The way of Servant lies madness, but I still end up using it so saying as much makes me a hypocrite :P
11:33:10 <fresheyeball> type family Bar a :: *
11:33:20 <fresheyeball> instance Foo Bar where -- makes no sense to GHC
11:33:41 <stevenxl> jkachmar: LOL. They pulled the wool over my eyes then.
11:33:44 <jkachmar> stevenxl Transformers get easier with extended use though, possibly worth drilling through those chapters again and/or the Scotty exercises.
11:34:02 <sm> stevenxl: for making websites, the yesod book is good
11:34:05 <crucify_me> so the argument must be last unless we use that section
11:34:17 <sm> for making web applications, anyway
11:34:17 <jkachmar> stevenxl Servant's type errors are absolutely hellacious. When things go wrong I usually end up commenting whole blocks out to tease out which part is actually causing the type error.
11:34:22 <crucify_me> ski I bought that book btw
11:34:29 <ski> which of them ?
11:34:34 <crucify_me> Hutton
11:34:36 <ski> ok
11:34:39 * ski haven't read it
11:34:44 <jkachmar> It's very much trial and error, and I've been using Servant on/off for about a year at this point
11:34:51 <stevenxl> jkachmar: Yea. I understand them conceptually, and I can write me a few transformers MaybeT, StateT, ReaderT, but they are isolated, tiny examples. The real world is a different beast that you just need to go out and do it.
11:35:18 <crucify_me> why were you referencing it above? curious ski
11:35:24 <stevenxl> hellacious? Today I Learned. Nice. 
11:35:57 <jkachmar> stevenxl Yeah, for sure. I mean your Servant dbConnection example is the perfect place to use `ReaderT`, buuuut now you've got to learn about natural transformations and some of the other stuff that Servant needs to make it happy.
11:36:16 <sm> crucify_me: we were gathering haskell book recommendations
11:36:23 <jkachmar> Also if you need auth, RIP in Peace
11:36:39 <stevenxl> jkachmar: I'm trying to build a "production" quality to-do app. Just started it last night, because I want to see how one would write an app with haskell from beginning to end. 
11:36:40 <stevenxl> https://github.com/stevenxl/todo/tree/06-add-skeleton-test-suite
11:37:34 <stevenxl> It's really for my own reference, since I have a fabulously scattered brain. Remembering is hard.
11:37:46 <fresheyeball> is there any way to do a typeclass lookup on an existentalized type that does not have the constrain existentialized as well?
11:37:52 <EvanR> https://twitter.com/mattoflambda/status/921058216816951296
11:37:57 <stevenxl> At any rate, it's too nice a day to hang around inside. Gonna get myself to teh park.
11:38:06 <stevenxl> talk to you another time jkachmar .
11:38:22 <MarcelineVQ> EvanR: I like the transformer one a lot
11:38:38 * jkachmar waves
11:38:51 <MarcelineVQ> https://pbs.twimg.com/media/C8QejJ1VoAAQgDE.jpg:large
11:39:15 <jkachmar> EvanR: trashlord followup here https://twitter.com/jusrin00/status/921059968362541056
11:42:17 <kl_5> asthma[m]  I think around 1K pages into haskellbook is about critical mass
11:45:14 <crucify_me> kl_5, what happens then?
11:45:47 <kl_5> crucify_me IMO you can be fairly productive working on projects around that point
11:46:46 <crucify_me> kl_5, thanks, I am new to programming and after page 420 or so I switched to the Hutton book (at 350 pages)
11:47:42 <sm> crucify_me: that or brain explodes :)
11:48:01 <sm> how do you like the hutton book
11:49:02 <crucify_me> yeah it was so daunting.. the hutton book is well written to be sure, however the exercises are pretty tough since I've never programmed for real
11:49:08 <crucify_me> sm
11:49:10 <EvanR> if your brain isnt exploding, you cant have been paying attention :)
11:50:56 <jkachmar> asthma[m] kl_5 Imo Monad Transformers is about where I started to get productive, but I was doing "real" coding (i.e. Servant stuff) by 17 or 18 (Applicative and Monad)
11:51:41 <jkachmar> Eh. "real" is a bad way to put that. I was doing practical application outside of the book by that point*
11:52:06 <crucify_me> like the simplest things like eta reduction question ^ .. EvanR 's explanation "   f x = g y x => f = g y  "  I have to study that now.
11:54:38 <sm> crucify_me: I wonder how you'd get on starting with elm
11:55:13 <MarcelineVQ> that's eta reduction,  f x = g y x  can become  f = g y     your isse was that !!, your g, is in the form of g x y
11:55:26 <sm> or, going back and forth. Some people recommend learning by reading two books on a topic (simultaneously)
11:55:42 <MarcelineVQ> so you need to flip it to change the argument order, or use a section to provide the y ahead of time
11:56:10 <jkachmar> sm Ergh. Please no.
11:56:22 <sm> stay out of this jkachmar :)
11:56:25 <jkachmar> Learning multiple languages at once is an awful idea.
11:56:59 <crucify_me> so is eta reduction simply to be elegant MarcelineVQ ? or what advantage that is based on purity, math, what-have-you ?
11:57:15 <sm> actually elm doesn't look that good for a first time programmer, though people often say it's a good step towards haskell
11:57:46 <crucify_me> somewhere on irc I heard it is poor sm
11:58:31 <jkachmar> crucify_me If you're interested in Haskell, please stick with Haskell Programming from First Principles. If you're interested in another language, that's fine too! But I'd recommend focusing your effort on learning thoroughly from good texts, and sticking with a single course of education until you've reached a good stopping point.
12:01:05 <crucify_me> with deep humility, whenever I hear about 'from first principles' it sounds like promotion beyond recommendation. also when I'm reading about it. why is that? jkachmar 
12:01:13 <EvanR> crucify_me: sometimes the extra argument is just extraneous, or its clearer to think of some functions as defined by partial application
12:01:19 <EvanR> f = map (+1)
12:01:26 <MarcelineVQ> crucify_me: Not sure I've given it a lot of thought, it's probably mostly to be elegant, in that you can write haskell just fine without ever using it.
12:01:33 <EvanR> as opposed to, f xs = map (+1) xs, it doesnt really gain much
12:01:45 <jkachmar> Since this is #haskell I'll recommend something expressive and safe like Haskell or PureScript over languages like Go or Elm, but regardless of the choice of language I'd ultimately implore people to stick with it until they've learned something to take away from the endeavor. Hopping around between languages, or even textbooks for languages, is an easy way to spin your wheels and burnout.
12:01:57 <EvanR> Go o_O
12:02:42 <jkachmar> crucify_me What do you mean "promotion beyond recommendation". The name's just meant to say that there's no prior knowledge needed to learn from this text.
12:02:45 <MarcelineVQ> there's CAFs and combinators and other ideas that are related to eta reduced functions, but those aren't useful topics to what you're working on
12:03:53 <crucify_me> jkachmar, good point I do feel like I've spun my wheels but the hutton book gels with me, its very clear baby-steps.  jkachmar I didn't mean the title 
12:04:55 <jkachmar> I just ended up wasting time on things like LYAH when I was starting out, and I'd rather more people not waste their time when we actually have a good educational resource available to us now.
12:07:12 <sarna> hey, can somebody help me with some simple code? it's the second day of advent of code 2015, 24 lines
12:07:19 <sarna> my math is off but I don't know where
12:07:37 <crucify_me> jkachmar, thanks kindly. I really don't understand programming much at all, I'm not coming from another language except a little scheme, but you can imagine how an 1800 page book that turns one into a programmer in haskell could seem daunting.
12:08:24 <jkachmar> crucify_me Kind of. I mean ostensibly in order to _barely_ be considered an engineer, you need 4 years of university, and really even then you're not actually qualified.
12:08:41 <kl_5> jkachmar yes that was about where I was too
12:08:50 <kl_5> (applicative & monad)
12:09:06 <EvanR> to be an engineer you only need to read 1800 pages?
12:09:18 <EvanR> what have i been doing ...
12:09:20 <kl_5> crucify_me i think that's fair to say it's a bit daunting
12:09:53 <MarcelineVQ> You don't need to read them to be an engineer, you just need to have them, you just check the chart when you're not sure
12:10:03 <kl_5> crucify_me but look at it this way, 1) it can be done, just step by step 2) as we were saying, once you're at around 900-1000 you can start working on things
12:10:36 <kl_5> seems like a lot of pages, but probably doable in a months, or a few months if you're working gradually
12:10:46 <crucify_me> I thought the hutton book I could do in a few months, then attack *the* book
12:11:10 <kl_5> is hutton easier than first principles? (haven't read it)
12:11:18 <crucify_me> a month? kl_5 I must confess, I'm 55 years old
12:11:31 <kl_5> it's good to see totally new people taking a stab
12:11:39 <crucify_me> at 55, no one does anything in a month
12:11:45 <kl_5> it depends how much of your time is set aside for it
12:12:08 <crucify_me> time I have a lot of. and you people are very encouraging thanks !
12:12:08 <kl_5> whether it's a weekend thing, full-time, etc.
12:12:22 <kl_5> it doesn't really matter as long as you're making progress
12:12:42 <kl_5> what were you doing before this, and how did you come across haskell as a first language?
12:12:56 <crucify_me> I try to spend 2 hours a day. But I get sidetracked a lot with little things, like why is it that way? sometimes I put in 3 hours a day
12:13:41 <kl_5> that's pretty good
12:13:49 <crucify_me> I read an article on what the y-combinator was, and I started scheme since SICP was such a famous book
12:14:28 <crucify_me> but scheme got into linear algebra and combinatorics and I bailed
12:14:34 <crucify_me> *SICP did
12:14:55 <kl_5> still consider myself a beginner in spite of "playing" with it for a while now
12:15:29 <crucify_me> I'm 55, but I'm unique in that I'm a taoist yogi type and don't age much  har har
12:15:53 <crucify_me> my memory is actually improving lately
12:15:56 <kl_5> are you coming from a math background? it's unusual for a non-programmer to jump in via y-combinator/sicp/haskell
12:15:56 <jkachmar> crucify_me Personally, I'd still recommend going with the HPfFP. At 2 hours per day you should be able to get through 1 chapter per week roughly.
12:16:16 <jkachmar> I attended a study group that was keeping to the 1 chapter per week schedule, and I was certainly less studious than 2 hours per day
12:16:31 <kl_5> same here
12:16:37 <crucify_me> jkachmar, where in the world did you find a study group?
12:16:39 <kl_5> wonder if taoists are overrepresented in Haskell
12:16:46 <crucify_me> :)
12:16:59 <kl_5> are you in a city? tend to find them there
12:17:13 <jkachmar> crucify_me A friend started one in NYC, some of the people who finished up last year are looking to restart it.
12:17:17 <kl_5> this is an approximation of a study group, although it'd probably work better with a schedule
12:18:36 <crucify_me> I live in Berkeley CA and work at UCB. I haven't been able to find *anyone* to help me in person. people are intensely busy and, er, rarefied 
12:19:01 <kl_5> hehe, probably a decent concentration of haskellers there
12:19:10 <kl_5> but they're probably doing startups or grad school
12:19:18 <kl_5> or google
12:19:26 <crucify_me> never met anyone who know haskell, by admission anyway
12:20:41 <crucify_me> the irc is great, sometimes I get it right away, but as a venue it doesn't replace in person. I find it hard to keep up between getting help here and putting it into ghci etc
12:20:48 <kl_5> you're not going to run into them on the street
12:20:54 <kl_5> there's a pretty active twitter community
12:21:37 <crucify_me> kl_5, really I need to join twitter then.
12:22:52 <kl_5> crucify_me don't *have* to but it's one more venue, it's pretty easy to find the hub of haskell people there
12:24:17 <fresheyeball> darn this problem
12:24:38 <fresheyeball> is there no way to conditionally use a typeclass at runtime?
12:25:03 <fresheyeball> as in something like
12:25:22 <fresheyeball> case magic (Proxy :: Proxy (Show a) of
12:25:34 <fresheyeball>   Just Dict -> show x
12:25:42 <fresheyeball>   Nothing -> "no show instance"
12:25:46 <fresheyeball> ?
12:26:43 <geekosaur> not at all easily. I think dmwit has a hack to reify dictionaries for inspection, but in general the typesystem tries to prevent this because it makes the typesystem inconsistent
12:27:12 <fresheyeball> geekosaur: Exinst got me real close
12:28:18 <fresheyeball> dmwit: you around?
12:28:25 <fresheyeball> I need Dict reification magic
12:28:37 <geekosaur> basically, if you can see the machinery then you can interfere with it, and now you can do things like use multiple Ord instances to build a Map --- in effect hiding multiple maps inside of it or otherwise deranging it
12:29:21 <fresheyeball> geekosaur: I don't see how I would do that, or why it's a risk
12:29:28 <fresheyeball> Maps have a concrete key
12:30:03 <geekosaur> there's one example that is already unavoidable: try storing NaN in a Map Double whatever
12:30:38 <geekosaur> if you can swap Ord instances when calling Map.insert to one that compares reverse, you get one Map that secretly has two inside it
12:31:34 <fresheyeball> I don't think so
12:31:48 <fresheyeball> because you would have the previous instance in scope
12:31:52 <fresheyeball> it would be overlapping
12:31:54 <geekosaur> but you can only access the second if you do the lookup with the reversed Ord instance by reifying the dictionary passed to Map.lookup and replacing its Ord instance functions with the reversed ones
12:31:59 <fresheyeball> and so you would need a newtype
12:32:01 <crucify_me> kl_5, et al   really appreciate your time 
12:32:05 <fresheyeball> which would be a different type
12:32:27 <geekosaur> you really need to look at what dmwit did. this *avoids* that
12:32:33 <geekosaur> it breaks the typesystem
12:32:44 <fresheyeball> Anyway
12:32:52 <geekosaur> which is why the typesystem tries to prevent it, and dmwit had to use hackery to get at the machinery
12:33:02 <fresheyeball> I have singleton of type `x :: Sing mt`
12:33:09 <fresheyeball> err
12:33:17 <kl_5> kl_5 no problem good luck with the learning
12:33:18 <fresheyeball> `x :: Sing (mt :: ModuleType)`
12:33:26 <fresheyeball> and a type family
12:33:29 <EvanR> do we have an extension to construct and pass dictionaries explicitly
12:34:01 <geekosaur> not as such but you can combine existing extensions to make the dictionary visible, or create your own and then 'sink' it into an expression
12:34:03 <fresheyeball> `type family Mod2Tmp (mt :: ModuleType) :: (t :: TemplateType)`
12:34:30 <fresheyeball> There is an instance of typeclass Foo for all members of TemplateType
12:34:38 <fresheyeball> so I should be able to use that singleton
12:34:45 <fresheyeball> to bring Foo into scope
12:35:10 <fresheyeball> for (Mod2Tmp mt :: TemplateType)
12:35:32 <fresheyeball> I believe the type system wont let me
12:35:47 <fresheyeball> because I have not proven that there is an instance of Foo for (Mod2Tmp mt)
12:36:27 <fresheyeball> it could be the case (though it's not) that some of `Mod2Tmp mt` do not have an isntance of Foo
12:36:30 <geekosaur> typeclasses are open
12:36:40 <fresheyeball> still I can't figure out how to get out of this situation
12:36:48 <geekosaur> you can't prove you have all instances because someone could add one later
12:36:57 <fresheyeball> Right, I know
12:37:08 <fresheyeball> I just need to prove that there is an instance for `Mod2Tmp mt`
12:38:31 <fresheyeball> geekosaur: actually this type class is closed, since `TemplateType` is finite ADT, and `Foo :: (t :TT emplateType) -> Constraint`
12:38:35 <fresheyeball> rrr
12:38:48 <fresheyeball> `Foo :: (t :: TemplateType) -> Constraint`
12:39:16 <crucify_me> why is the last else statement required here? http://lpaste.net/359429
12:40:05 <fresheyeball> crucify_me: because what if x == False?
12:40:14 <fresheyeball> we would not progress to the inner if clause
12:40:26 <iqubic> wht's the best resource to recommend to a Haskell noob who wants to learn haskell?
12:41:07 <iqubic> @learnhaskell
12:41:07 <lambdabot> Unknown command, try @list
12:41:16 <iqubic> @where learnhaskell
12:41:16 <lambdabot> https://github.com/bitemyapp/learnhaskell
12:41:54 <crucify_me> so that is for the first if statement fresheyeball ? 
12:42:03 <fresheyeball> crucify_me: right
12:42:03 <crucify_me> that bookends the first one?
12:42:08 <crucify_me> ok thanks
12:42:12 <fresheyeball> all if statements must have a `then` and an `else`
12:42:25 <fresheyeball> crucify_me: otherwise, the function is not total
12:42:44 <fresheyeball> crucify_me: also, just fyi
12:42:52 <fresheyeball> technically Haskell does not have "statements"
12:43:00 <fresheyeball> so it's an `if` expression
12:43:32 <crucify_me> excellent thanks I did read that 
12:43:49 <fresheyeball> now that said
12:43:58 <fresheyeball> your code can be much more elegant
12:44:19 <crucify_me> yeah its a book example to use if/then
12:44:26 <fresheyeball> oic
12:44:39 <crucify_me> it goes on from there
12:44:57 <fresheyeball> ok cool
12:45:28 <crucify_me> may I inquire about your nick fresheyeball ? it's funny
12:45:34 <fresheyeball> oh sure'
12:45:49 <fresheyeball> I've had it since 5th grade, when I had to find an email address in yahoo for school
12:46:00 <fresheyeball> I didn't want mine to have lots of ugly numbers and such after it
12:46:06 <fresheyeball> in those days everyone was on yahoo
12:46:12 <fresheyeball> and all the names where taken
12:46:20 <fresheyeball> I spent hours trying to find one that was not taken
12:46:21 <crucify_me> except fresheyeball
12:46:30 <fresheyeball> yup, that was the one I found
12:46:46 <fresheyeball> then with life online, I've needed to pick a name many times
12:46:53 <fresheyeball> and I don't want to remember different ones
12:47:05 <fresheyeball> lucky for me, no one has ever picked fresheyeball except me
12:47:18 <crucify_me> nice I have chastise_me and n_blownapart. it says a lot about a person since its all we have to go on here!
12:47:19 <fresheyeball> I standardized accross all accounts :)
12:47:37 <fresheyeball> and now I am stuck
12:47:43 <fresheyeball> can't escape it for a better one
12:47:48 <fresheyeball> would be a ton of work to back out
12:47:52 <crucify_me> may you always have 20/20 or better
12:47:59 <fresheyeball> haha
12:55:49 <Cale> Well, the parts of a do-block are called "statements" in the Report. But there's no special "if" statement.
13:14:41 <crucify_me> its always something: I named a function (&&') but get an error on the second parenthesis; I've been using ' all along.. (&&>) works fine what's the beef?
13:15:06 <crucify_me> (&&') :: Bool -> Bool -> Bool
13:15:46 <crucify_me> is that conflicting with some haskell def?
13:16:16 <Cale> ' is considered a non-symbol character for the purposes of identifiers
13:16:25 <Cale> So that you can name things like foo'
13:17:06 <Cale> (as such, it can't belong to infix names)
13:17:12 <hpc> conanO'Brian
13:17:42 <crucify_me> strange Cale.. oh the infix nature is the problem, ok
13:17:42 <hpc> it's also like digits in that you can't start an identifier with it
13:17:45 <crucify_me> thanks
13:18:22 <crucify_me> I like (&&>) anyway
13:20:57 <mniip> @let times1'024 = (* 1024)
13:20:59 <lambdabot>  Defined.
13:33:51 <crucify_me> mniip thanks how is that valid then ? (went to store)
13:34:35 <mniip> like hpc said, ' is most similar to a digit
13:36:39 <crucify_me> ok I missed that thanks
14:04:24 <tobiasBora> Hello,
14:04:39 <tobiasBora> I think to rememember that there is an OS that work in a functionnal way
14:04:55 <tobiasBora> and that is based on a tool that you can install on any linux
14:05:24 <tobiasBora> and that this tool lets you install locally any file for a given user
14:05:31 <tobiasBora> do you know the name of this program ?
14:06:29 <EvanR> nix ?
14:06:43 <Rembane> Lisp machine OS?
14:07:25 <lassulus> tobiasBora: nixos.org
14:07:35 <tobiasBora> great, thank you !
14:08:11 <lassulus> there is also #nixos on freenode and https://nixos.wiki
14:15:08 <monochrom> Lisp OS would not be a functional OS. It would just be an "everything is a list" OS. The functionalness of Lisp was an afterthought.
14:15:30 <TommyC> Emacs is the only Lisp OS that I need.
14:15:32 * TommyC runs
14:18:12 <geekosaur> as opposed to the unix 'everything is a string' OS?
14:18:28 <EvanR> a bytestring
14:18:39 <geekosaur> true
14:19:28 <EvanR> everything is an object, a function, a set, a morphism
14:21:37 <ski> @quote everything.is.actually
14:21:37 <lambdabot> quicksilver says: It's also the same thing as the Yoneda lemma.  That's the thing about maths. Everything is actually the same.
14:24:46 <mniip> 1508620495 [00:14:55] <monochrom> Lisp OS would not be a functional OS. It would just be an "everything is a list" OS. The functionalness of Lisp was an afterthought.
14:24:53 <mniip> me and a friend are coming up with a LISP CPU
14:25:07 <mniip> funnily,
14:25:09 <mniip> everything is cons
14:25:18 <mniip> the heap, the stack, the machine code
14:25:26 <geekosaur> so, you;re reinventingt he cpu lisp was originally developed on?
14:25:42 <EvanR> you dont need cons... just use lambdas!
14:25:51 <monochrom> It is an obvious thing that a lot of people can reinvent.
14:26:11 <monochrom> "car" and "cdr" were assembly-level names.
14:26:12 <mniip> geekosaur, hmm, linky?
14:26:48 <geekosaur> http://www.iwriteiam.nl/HaCAR_CDR.html for one
14:26:55 <monochrom> Namely, the "a" there stood for "address", and the "r" there stood for "register".
14:27:32 <geekosaur> basically CAR was one half of an index register, CDR the other half, representing an address and an offset (decrement)
14:27:34 <EvanR> do people pronounce CDR in some wacky way
14:28:52 <monochrom> Oh people have ingenious ways to pronounce CDR, SQL, SCSI, and Tcl/Tk. I personally want to hear them pronounce PCMCIA one day.
14:29:06 <mniip> geekosaur, no on that cpu's instruction set
14:29:10 * ski . o O ( "cudder" )
14:29:21 <monochrom> Perhaps like "pokemoncia"?
14:29:32 <geekosaur> ski, but then you have to ask how they pronounce cadr and/or cddr :p
14:29:40 <EvanR> the pulse code modulation central intelligence agency
14:29:40 * ski . o O ( <https://en.wikipedia.org/wiki/PCLSRing> )
14:29:55 <ski> geekosaur : simply stutter more for the latter one
14:29:57 <geekosaur> mniip, I have a vague memory that the CPU in question was IBM 604, but I don;t trust that recollection much
14:30:24 <geekosaur> some IBM minicomputer architecture for the initial implementation though
14:32:14 <mniip> geekosaur, that looks like a von-neumann machine to me
14:32:59 <mniip> well, I mean,
14:33:04 <mniip> we have a more LISP-y ISA
14:33:42 <mniip> our instructions are CONS, CAR, CDR, SETCAR, SETCDR, STACK, CALL, RET,
14:33:47 <mniip> and just a tiny bit of arithmetic
14:34:16 <EvanR> lisp machines
14:34:22 <monochrom> Oh! "IS" means "instruction set" not "industry standard" :)
14:34:37 <monochrom> (Remember the predecessor of PCI? :) )
14:34:46 <mniip> monochrom, Iosiph Stalin
14:35:04 <monochrom> :S
14:35:14 <geekosaur> mniip, that's fine, it's just the microcode level for the macrocode >.>
14:35:23 <EvanR> was there a soviet lisp ?
14:35:26 <geekosaur> or, if you prefer, RISC underneath CISC
14:35:29 <monochrom> This Halloween, are you going to dress up as Stalin to scare people? >:)
14:35:44 <mniip> geekosaur, yeah see we have nothing under the CONS/CAR/CDR
14:35:50 <mniip> they're the fundamental instructions
14:36:04 <mniip> there's no "array of words" memory
14:36:06 <mniip> only the heap
14:36:11 <monochrom> "It's silicon lasagna all the way down"
14:36:12 <mniip> hardware allocated and refcounted
14:36:52 <EvanR> ref counting o_O
14:37:30 <mniip> yes!
14:37:45 <EvanR> so you lose loops of memory until a reboot
14:37:48 <mniip> I'm currently thinking of how to make the GC incremental
14:38:03 <mniip> why yes
14:38:08 <mniip> you should be careful!
14:38:30 <guillaum2> Hi there. I recall having read something about the fact that a thunk can be evaluated many times in a concurrency context (for example, two threads who want to evaluate the thunk at the same time). I'm unable to find a reference to this behavior, do you have a better memory than me?
14:38:36 <EvanR> is memory mutable
14:38:39 <mniip> yes
14:38:43 <mniip> SETCAR/SETCDR
14:40:48 <freeman42x> is there any `skipWhile` function? I can only find `takeWhile`. `skipWhile` would skip all the elements while a condition is true and then return everything after the condition becomes false
14:40:58 <mniip> EvanR, I've had some example assembly somewhere
14:41:05 <monochrom> Perhaps dropWhile.
14:41:25 <monochrom> But really, the doc of dropWhile is right next to the doc of takeWhile.
14:42:37 <freeman42x>  > Perhaps dropWhile.
14:42:38 <freeman42x> yup, cheers
14:44:37 * geekosaur is now imagining nconc as a machine primitive...
14:45:21 <mniip> nconc?
14:45:44 <geekosaur> maclisp function that setcdr-s the tail of a list to its head, producing a cycle
14:45:57 <mniip> ah
14:46:54 <mniip> hmm, is piratepad.net down for anyone else...
14:49:22 <EvanR> an infinite list which has been fully evaluated...
14:49:28 <EvanR> head explode
15:05:33 <Gurkenglas> http://downforeveryoneorjustme.com/piratepad.net (yes)
15:36:38 <lkg> any checking using Proxy is going to be a runtime check - is this correct?
15:37:47 <geekosaur> bzuh? Proxy is a carrier for a type with "no" runtime value (actually, as a value it is equivalent to ())
15:38:36 <geekosaur> as such it is a compile time / typechecker thing, with the runtime minimized in a way that should optimize out
15:39:32 <geekosaur> Typeable typeclass is an example of something that is runtime, since it (potentially) has to be resolved by use of a runtime typeclass dictionary
15:46:47 <zzo38> Is there a X resource manager implementation in Haskell? I have implemented X resource manager in JavaScript. One idea for implementing it in Haskell might be that the database has type (XRM x y), which has resources of type ([(Binding,x)],y) where the first half of the pair is the key and the second part is the value. (So, you can't have duplicate keys.) (The type (XRM String String) will be the usual way, although this doesn't allow for XrmUniqueQ
15:47:48 --- mode: ChanServ set +o mauke
15:47:48 --- kick: ptek_not_here was kicked by mauke (no nick spam, please)
15:48:15 <geekosaur> zzo38, limited bindings via xhb or X11
15:49:09 <geekosaur> I've wanted to do something with that for xmonad for a while but it's a fair ways down the priority list 
15:49:48 --- mode: mauke set -o mauke
15:49:49 <zzo38> geekosaur: I mean implemented purely in Haskell; it is not necessary to use the ones from Xlib. (My implementation in JavaScript is implemented purely in JavaScript.)
15:50:17 <geekosaur> unless it's part of xhb, no
15:51:00 <zzo38> What is xhb? Is that the Haskell implementation of a X client library?
15:51:17 <geekosaur> 'X Haskel bindings' generated the same way xcb is generated from the X11 protocol specification
15:51:42 <geekosaur> as distinct from Xlib which hides the protocol layer
15:52:12 <geekosaur> but xrm is not actually part of the server protocol so I would not actually expect xhb to have much to do with it
15:52:21 <zzo38> (And the X resource manager doesn't actually depend on X. Even the Xrm functions in Xlib don't require a Display* argument, because it doesn't need X to work.)
15:52:41 <zzo38> Yes, as I said; it is not necessary for an implementation of X resource manager to have anything to do with X.
15:52:52 <geekosaur> right, essentially the only interaction there is defaulting stuff from X root window resources
15:53:34 <zzo38> Yes, and in that case you could perhaps use xhb functions to retrieve it as a string so that it can be passed, I suppose.
15:53:45 <geekosaur> (specifically the WM_CLASS and RESOURCE_MANAGER properties)
15:55:30 <geekosaur> but the only currently extant implementations are a minimal one in X11 (which is an Xlib wrapper) and XRM (which is a more complete wrapper for just Xrm, but still assumes that XrmInitialize defaults stuff via Xlib lookups of those two root window properties I mentioned)
15:56:06 <zzo38> Yes, and that seems easy enough to do. Both are prenumbered atoms, so it should be easy enough to write a wrapper code which retrieves that data, so that you can them pass it in to the XRM implementation.
15:56:41 <geekosaur> and to be honest, most people don;t care any more; neither Gtk/Gnome nor Qt/KDE use Xrm
15:57:20 <zzo38> Yes, although I don't like either Gtk/Gnome or Qt/KDE, and prefer Xaw (or even direct) myself.
16:05:45 <Gurkenglas> I'm thinking to look into using an ML library, perhaps hext, to add ham classification to an IRC client, perhaps glirc. Does anyone want to suggest doing something else instead?
16:15:21 <zzo38> One possible way to make XRM in Haskell might be similar to what I have done in JavaScript, so it might be like:  data XRM x y = XRM { xrmLoose :: Map (Maybe x) (XRM x y), xrmTight :: Map (Maybe x) (XRM x y), xrmValue :: y };
16:16:14 <ids1024> I'm trying to write a parsec parser, but it's failing a runtime:
16:16:16 <ids1024>     unexpected end of input
16:16:18 <ids1024>     expecting white space, ";", end of input or new-line
16:16:34 <ids1024> That error seems a bit contradictory...
16:17:18 <geekosaur> you might want to try switching to megaparsec, or making sure you have the very latest parsec. that sounds like a known bug in parsec that megaparsec fixed
16:17:26 <zzo38> (The key Nothing indicates what is called "?" in Xlib and in the JavaScript implementation; but here, due to the way the types are working, instead I put Maybe.)
16:17:39 <geekosaur> and at least some of those fixes made it into the latest parsec
16:22:10 <jle`> ids1024: can you reproduce it with some simple code and input?
16:23:19 <zzo38> Oops, it should be "xrmValue :: Maybe y" not "xrmValue :: y"
16:29:34 <dmj`> jle`: o/
16:32:29 <Gurkenglas> Where in "stack exec cabal install -- --dep" can I add "--package-db " followed by the output of "stack path --local-pkg-db"?
16:35:11 <zzo38> The (XRM x) type I defined does seem to be a Functor.
16:41:30 <EvanR> paper that defines a partiality monad with weak bisimilarity without "setoid hell" by using HoTT HIITs
16:41:34 <EvanR> https://arxiv.org/pdf/1610.09254.pdf
16:42:53 <EvanR> to avoid an axiom of countable choice
16:43:14 <EvanR> things that keep type theorists up at night
16:46:13 <Guest49592> what's the best way to reference a local package in Stack? Not one pushed to Hackage or GitHub or anything
16:46:34 <lyxia> Guest49592: add the path to it under the packages: field
16:47:16 <Guest49592> lyxia: when I did so, I had to add the extra-deps for the referenced package to my new package
16:47:41 <Guest49592> lyxia: made me think that I was then treating it like it was part of the source for the new package
16:48:04 <MarcelineVQ> then you have to add  extra-dep: true  under the entry
16:49:28 <MarcelineVQ> if you create a fresh stack project the stack.yaml should contain explamples you can reference if you're not sure what that should look like
16:53:44 <Guest49592> MarcelineVQ: cool, that got further. Can't see the exported packages though (thought package.yml from the haskeleton exported everything by default?) so I'm tackling that now
16:58:22 <S0m3Guy> Can anyone confirm this code snippet will take out GHC 8.2.1 (meaning exhaust all memory)? http://lpaste.net/359434
17:07:42 <spark712> thanks to all who assisted me earlier. spent the last few hours trying to understand parser combinators, thanks to you guys i'm finally getting somewhere.
17:10:33 <hexfive> parser combinators r cool
17:15:59 <spark712> yeah, i'm reading about them now and really enjoying even the simple 'revelations' borne from my lack of knowledge about functional programming. It... has helped me see the whole 'building in both directions' idea in haskell, which I heard about in how lisp is supposed to be done - you try and grow the language to support your actual project.
17:25:29 <zzo38> Do you know my way to make a MonadPlus out of any Comonad?
17:33:26 <jle`> what is your way?
17:34:01 <jle`> tell us and then we can let you know if we know it or not :)
17:50:12 <dilinger>  
17:50:59 <olligobber>  
17:52:43 <dsal> /j #whitespace
18:13:31 <EvanR> is there a way to know how many file handles are left before you run out
18:15:31 <geekosaur> system dependent but in theory yes
18:16:25 <geekosaur> on unixlikes look for bindings for ulimit() or getrlimit()
18:18:18 <geekosaur> preferably the latter as it's better specced and POSIX compliant; ulimit is theoretically more backward compatible but I suspect you'd have trouble getting ghc to work on systems that have it but not getrlimit
18:24:48 <EvanR> nice
18:26:17 <EvanR> RLIMIT_NOFILE   The maximum number of open files for this process.
18:26:40 <EvanR> so you could check this at the beginning of the program, but how do you know how many are in use at any given time
18:33:47 <geekosaur> the hard way: loop from 0 to the current soft limit - 1, trying an operation that does nothing (or returns an error other than EBADF, such as lseek(fd, 0L, SEEK_CUR)) and counting the non-(-1/EBADF) returns
18:35:12 <geekosaur> translating that to Haskell likely easiest by binding the C functions directly yourself rather than dealing with the IOException interface
18:37:09 <EvanR> mkay
18:38:02 <geekosaur> alternately, on linux read it out of /proc/pid/fd or on BSD use libkvm 
18:38:42 * edwardk goes to install 8.2 because 8.0 crashing whenever i have a pattern synonym referencing a pattern synonym is driving me bonkers
18:38:48 <edwardk> hopefully it has gotten better
18:40:52 <edwardk> been sitting here trying to figure out if i could get a simple 'garbage collector that does some evaluation' story by compiling down to combinators and only doing 'work-safe' rewrites, like the wadler class of gc hacks that forwards fst (a,b) ~> a
18:40:53 <kadoban> I have an Array Int [Int]   that I'm building up that's getting too large for memory, is there any cute replacement for [Int] I could use there that'll let me append, but use less memory? The lists are mostly small, maybe 2-5 elements, the max is probably like 20ish elements? The array is around 10^8 elements
18:41:34 <edwardk> but in a combinator calculus like ski, so K x y ~> x   and I x ~> x  are both 'work safe' rewrite rules
18:42:10 <edwardk> they always take something present on the heap and replace it with something else that'd also have to be moved to the to-space so a gc forwarding them like that duplicates no work and moves less stuff to to-space
18:42:31 <edwardk> but i was kinda hoping that if i did so then church-encoded pairs would automatically rewrite
18:42:44 <edwardk> unfortunately, it looks like they don't quite pass my work-safe test.
18:43:01 <edwardk> i have to write some kind of super-combinator rules that let me rewrite those
18:44:04 <edwardk> testing https://www.irccloud.com/pastebin/l47RVN5b/SKI.hs
18:44:45 <Gurkenglas> kadoban, have you considered using a type smaller than Int?
18:46:19 <edwardk> er, sorry for pinging you ski =)
18:46:22 <kadoban> That could be possible ... I think my values are mostly pretty tiny, like 50 or less. But in GHC [Word8] is still about the same size, right? I could use ... can I do ByteString maybe?
18:46:47 <sm> kadoban: or an unboxed array (vector ?)
18:47:07 <geekosaur> [] itself is a very wasteful way to store stuff. I'd think unboxed vector, yeh
18:47:13 <geekosaur> or Storable vector
18:47:31 <MarcelineVQ> edwardk: he likes it
18:47:52 <kadoban> That sounds promising, I forgot about vector. I'll give that a peek for the elements
19:07:51 <Gurkenglas> Where in "stack exec cabal install -- --dep" can I add "--package-db " followed by the output of "stack path --local-pkg-db"?
19:11:55 <geekosaur> you don't? unless you like trashing stack and fighting with both stack and cabal overriding each other
19:13:46 <MarcelineVQ> I don't think you can, "Use the flag --package-db to specify a package database (it can be used multiple times)"means instead of GHC_PACKAGE_PATH, I don't think it means to over-ride GHC_PACKAGE_PATH
19:16:50 <Gurkenglas> How should I build glirc when I use stack?
19:27:18 <MarcelineVQ> looks like a bit of a pita,   stack unpack glirc && cd glirc-2.24 &&  stack init --solver --resolver=nightly-2017-10-21 && stack build
19:44:49 <boj> is there a nice function or library to merge two records?
19:45:40 <dsal> What kind of records?  What kind of merge?
19:47:17 <boj> say, data R = R { a :: Maybe Int, b :: Maybe Text }, i'd like to say (R (Just 1) (Just "foo")) `merge` (R Nothing (Just "baz"))
19:47:43 <jean-lopes> Hello, I have a question about stack + .ghci config file... when I use `stack exec ghci` outside a project folder, it loads up my .ghci file.. but inside a project it does not, is there a way to make stack load it?
19:48:55 <dsal> boj: What's that merge do?
19:48:56 <MarcelineVQ> boj: a Monoid instance for your record?
19:49:24 <boj> i'm currently doing something like that by hand to override config vars with env vars, but it's tedious
19:50:13 <dsal> Ah.  fmap of the maybe would prefer Nothing, so I don't think the thing I'd expect to happen would be what you want.
19:51:20 <geekosaur> jean-lopes, you can probably pass something in --ghci-options but your best bet might just be to ":script .ghci"
19:52:55 <Gurkenglas> MarcelineVQ, http://lpaste.net/4163840733272342528
19:53:32 <MarcelineVQ> That's not what I wrote.
19:53:55 <zzo38> The documentation for mzero still isn't fixed. "mplus >>= f = mzero" is implied by the monad laws, while "v >> mzero = mzero" is wrong.
19:54:20 <jean-lopes> I see, thanks for the help geekosaur!
19:54:35 <zzo38> Why didn't you fix this yet?
19:56:48 <MarcelineVQ> Gurkenglas: if you still get that error after typing  stack init --solver --resolver=nightly-2017-10-21  make sure your stack is up to date, version 1.5.1 or newer
20:00:43 <Gurkenglas> "stack install cabal-install" should be run outside the project, right?
20:01:56 <MarcelineVQ> if you want it to use the resolver in .stack/global-project/stack.yaml then yes, you already have cabal-install though don't you?
20:02:56 <MarcelineVQ> are you trying to update cabal? if it needs 2.0 to do a job stack should fetch that itself, is your stack up to date?
20:04:43 <Gurkenglas> Upgraded it 5-7 minutes ago
20:05:19 <MarcelineVQ> so curently  stack --version says  1.5.1 or newer?
20:06:19 <Gurkenglas> Here's some recent logs, it said it upgraded to 1.5.1 http://lpaste.net/8360711736440913920
20:06:45 <Gurkenglas> (Waiting for the download to finish to check stack --version)
20:07:52 <MarcelineVQ> it got past the cabal parsing issue so it likely upgraded
20:08:06 <Gurkenglas> (Specifically "Warning: Installed version of cabal-install (1.22.9.0) doesn't support custom-setup clause, and so may not yield correct results. To resolve this, install a newer version via 'stack install cabal-install'." is relevant)
20:10:53 <MarcelineVQ> that was without specifying nightly, it may not have been neccesary, duno. it doesn't hurt to have 1.24.2 or whatever you upgraded to though
20:14:39 <Gurkenglas> Does --install-ghc have to log like 10k lines of "Extracting" to console? …
20:22:56 <Gurkenglas> http://lpaste.net/4487276943464464384 (including already pasted logs)
20:23:04 <Gurkenglas> *MarcelineVQ
20:25:23 <lamdevhs> hello, i'd like to know if there's a way to handle newtypes elegantly, because i'm all for more type-level precision, but having to manually unwrap and then rewrap everytime i do something with wrapped values seems completely useless (and very verbose/obfuscating).... how can i tell when it's necessary to use a newtype versus a mere type synonym? i read the former was in general a better choice but it's hard to manage for me...
20:25:53 <boj> lamdevhs: look into Data.Tagged
20:26:13 <Gurkenglas> lamdevhs, Data.Coerce often allows you to pretend everything's unwrapped
20:28:08 <lamdevhs> ok i'll look into them, thanks... do you use those tools yourselves?
20:29:00 <jle`> lamdevhs: it depends on your situation, but sometimes you can abstract over newtypes that you just use as wrappers like that
20:29:20 <jle`> some libraries offer some ways to make that smoother
20:30:46 <lamdevhs> use as wrappers like that?
20:32:31 <jle`> lamdevhs: you're talking about using newtypes as "wrappers" for type-safety
20:32:45 <jle`> that's just one usage pattern for newtypes
20:33:26 <lamdevhs> i'm looking at Data.Tagged, and i don't really understand how it's solving anything... i mean it's a phantom newtype, and i'll have to wrap and unwrap all the time the same way, right? (on top of adding more verbosity at the type level)
20:33:41 <boj> lamdevhs: i've replaced newtypes with tagged in all of my code
20:33:43 <lamdevhs> jle`: what are other usages?
20:33:59 <zzo38> newtype CodensityAsk f x = (forall z. f z -> (x -> z) -> z); -- This is always a Monad. Also, if (Comonad f), then (MonadPlus (CodensityAsk f)). Has anyone else written about this (possibly with a better name than "CodensityAsk", which isn't a very good name I think)?
20:34:14 <jle`> they're used to play with typeclass instance selection
20:34:41 <jle`> and also sometimes to enable typeclass instances by re-arranging type parameters
20:34:50 <jle`> and sometimes also as simple data types
20:35:12 <Gurkenglas> lamdevhs, lens allows you to "focus" instead of wrapping after and unwrapping before
20:35:19 <edwardk> zzo38: how does the MonadPlus look?
20:35:52 <edwardk> i presume the monad is just the usual Cont thing ignoring the 'f z'?
20:35:54 <lamdevhs> jle`: well type class instances rely on different semantics at the type level, that's a bit the same thing... but true it's not for type safety per se
20:35:57 <zzo38> edwardk:  mzero = CodensityAsk (\q _ -> extract q); mplus (CodensityAsk f) (CodensityAsk g) = CodensityAsk $ flip (\y -> flip f y =<= flip g y);
20:36:32 <edwardk> interesting
20:36:33 <jle`> lamdevhs: indeed haskellers have found many different usages for the humble newtype mechanic
20:37:08 <jle`> definitely surpassing the expectations of the people who originally envisioned newtypes
20:37:43 <lamdevhs> Gurkenglas: hm yeah i haven't gotten to delving into the lens class yet, but i guess that could work too...
20:38:32 <MarcelineVQ> Gurkenglas: guess your global resolver isn't super recent and stack isn't being helpful about it, what a hassle, guess you'll need to  stack install cabal-install --resolver=lts9.10  to get a new enough cabal :<
20:38:36 <jle`> lenses can be used to abstract over things that "contain" things, so there are some nice combinators for working with newtypes in a nice way
20:39:30 <Gurkenglas> Is there a simple command that tells stack to switch everything over to the newest resolver in the global project?
20:39:48 <zzo38> For example, (CodensityAsk Identity) becomes the Maybe monad (and it results the correct MonadPlus instance), while (CodensityAsk Predicate) is a "infinite-search" monad (but not a MonadPlus).
20:40:09 <jle`> can you prove the laws
20:40:22 <jle`> at least the Alternative/monoid ones
20:40:41 <MarcelineVQ> Gurkenglas: no, hopefully it won't get one either, you edit  .stack/global-project/stack.yaml  to a resolver you choose from https://www.stackage.org/
20:41:16 <MarcelineVQ> Though I do think stack should have a way to let you know what recent resolvers there are
20:42:34 <MarcelineVQ> *  stack install cabal-install --resolver=lts-9.10
20:42:54 <lamdevhs> overall the strategy for dealing with newtypes is to create a class or use only one type with a phantom parameter, and then use polymorphic (adhoc or not) functions to fmap over the value in the newtype?
20:43:32 <zzo38> edwardk: Oops, I missed your other question. Yes, the monad is like Cont and Codensity.
20:43:50 <lamdevhs> i mean only one function
20:44:39 <EvanR> that... sounds like something you could do with newtypes. but thats not "the" strategy, i think
20:45:27 <Gurkenglas> zzo38, isn't the way the MonadPlus instance looks evidence it should be (forall z. (x -> z) -> f z -> z)?
20:45:57 <glguy> Gurkenglas: This stack.yaml will build glirc http://lpaste.net/9012058808372953088
20:46:26 <glguy> You should still get your cabal-install executable updated so that stack isn't broken, but that should get you going in the meantime
20:46:45 <Gurkenglas> Should that be put in the github repository?
20:46:54 <glguy> No, it just gets out of date
20:47:14 <glguy> I'd recommend installing with cabal-install and avoiding that process
20:48:43 <lamdevhs> EvanR: well that was my question, i wondered if there were other strategies... i'm looking at data.coerce and i'm not sure i understand how it works... i see one function and a class, but the source depends on GHC.prim and types, and i can't seem to find it... is it written in haskell?
20:48:47 <Gurkenglas> Is there a way to run cabal commands using stack if one doesn't have cabal installed? "stack exec cabal install -- --dep" complained about something with GHC_PACKAGE_PATH and --package-db
20:48:59 <jle`> lamdevhs: Coerce is a GHC thing yes
20:49:18 <EvanR> lamdevhs: i think the practice you need is when to avoid newtypes to simplify your experience
20:49:19 <zzo38> Gurkenglas: Well, that will obviously work too, and yes I can see why you say that, so if other people write about such thing you can do that if you want to do.
20:49:44 <EvanR> like using Int judiciously and not a newtype for EvenPositiveIntThatAreAPrimePower
20:51:22 <EvanR> i dont know how Data.Coerce helps
20:52:32 <lamdevhs> EvanR: actually it's more a question of having complex types like (a -> b, maybe (c, d)), which i don't want to rewrite everywhere, and which i'd rather alias because otherwise it soons becomes very unreadable (and the type sigs become really really long...)
20:52:35 <Gurkenglas> coerce :: Compose Identity Identity a -> a
20:53:30 <EvanR> lamdevhs: ok, thats not a newtype situation
20:53:33 <Gurkenglas> lamdevhs, there are type aliases as opposed to newtypes which do not introduce constructors
20:53:45 <lamdevhs> Gurkenglas: Compose f g a is isomorphic to f (g a)?
20:53:53 <EvanR> you really want a record type or at least a full data type with its own support functions
20:54:12 <Gurkenglas> :t Compose
20:54:16 <lambdabot> forall k1 k (f :: k -> *) (g :: k1 -> k) (a :: k1). f (g a) -> Compose f g a
20:54:42 <Gurkenglas> What's that forall good for?
20:54:50 <mniip> hmm, I think I just found a vulnerability in lambdabot or something
20:55:08 <jle`> Gurkenglas: mostly there to indicate what kinds are going on
20:55:17 <lamdevhs> Gurkenglas: yeah but i heard they were problematic, esp wrt having the typechecker silently replace the aliases by their values in type errors... or something...
20:55:18 <jle`> that sort of forall is "implicit"
20:55:28 <EvanR> lamdevhs: you have multiple components... mutiple cases... why not make a proper data type
20:55:37 <jle`> Coerce exists for performance reasons
20:55:44 <MarcelineVQ> mniip: poor robut :(
20:55:46 <jle`> but it can be abused as a generic interface for newtypes yes
20:55:56 <jle`> i'm not sure if that's a recommended usage
20:56:10 <lamdevhs> EvanR: what's the difference with a newtype? and having to unwrap every time i need the inner function?
20:56:22 <lamdevhs> EvanR: multiple cases?
20:56:27 <EvanR> it sounds like lamdevhs is asking about basic usage of newtypes vs type vs data, not looking into experimental new stuff
20:56:52 <Gurkenglas> lamdevhs, yep that's sure annoying in lens. It's probably a really easy fix too if someone was dug into that code and wasn't entangled in red tape and cared about our suffering
20:56:57 <EvanR> lamdevhs: in your example, the Maybe
20:56:57 <mniip> @let import Data.Coerce
20:56:59 <lambdabot>  .L.hs:81:1: error:
20:56:59 <lambdabot>      Data.Coerce: Can't be safely imported!
20:56:59 <lambdabot>      The module itself isn't safe.
20:57:06 <mniip> @let coerce x = view coerced x
20:57:07 <ahf> √joe
20:57:08 <lambdabot>  Defined.
20:57:11 <jle`> lamdevhs: show us a specific usage and we can help you make it nicer perhaps :)
20:57:20 <EvanR> lamdevhs: a record would probably be better for that random example
21:01:06 <lamdevhs> actually i think i have an idea that could work for my particular case... i'll check it out
21:03:48 <Gurkenglas> With the stack.yaml glguy pasted: http://lpaste.net/3436475660778864640
21:04:13 <roi_du_silence> I love haskell, fuck.
21:04:18 <roi_du_silence> <3 you guys
21:04:24 <zzo38> edwardk: You can tell me if you have other ideas about this perhaps? And if you have any webpages or whatever to write about stuff like this, you can show that too, I suppose.
21:04:33 <mniip> roi_du_silence, please, this is a family friendly channel
21:04:46 <glguy> Gurkenglas: You can't build that package on windows
21:05:09 <roi_du_silence> I think I need to read the Reader Monad now because passing values around is becoming quickly tiresome
21:05:10 <glguy> that package being unix
21:05:20 <Gurkenglas> oh. ah, well. so much for this project
21:05:41 <glguy> the vty package doesn't support windows, either
21:05:54 <zzo38> What is the following theorem called:  Any category that has more than one object has N+1 or more monads if N is the number of final objects that that category has.
21:08:55 <Gurkenglas> Hm, stack could have said that a few hours ago, when I first tried stack init
21:09:24 <mniip> hmm
21:10:53 <mniip> I wonder what safehaskell-trustworthy module could contain a newtype whose abstraction could be broken with coercible
21:13:16 <Gurkenglas> mniip, related https://github.com/ekmett/lens/issues/661
21:15:23 <MarcelineVQ> glguy: would "if !os(Linux):\n  buildable: False" would make sense for the .cabal file
21:15:33 <MarcelineVQ> Linux/darwin
21:16:19 <MarcelineVQ> dunno why I didn't write   if os(windows) ...
21:25:12 <edwardk> zzo38: generally category theorists talk about 'the' terminal or final object,  and consider all of those 'final' objects the same one, as it is unique up to isomorphism. such a theorem would be an 'evil' theorem so it probably doesn't have a name.
21:25:15 <edwardk> ... and he's gone
21:27:38 <bsima> anyone use persistent? I keep getting a runtime error: "(getByValue: Author does not have any Unique)"
21:28:04 <bsima> not sure what this means because persistent should generate AuthorId by default, no
21:28:07 <bsima> ?
21:35:45 <bsima> well, seems I fixed it by manually adding a unique constraint to my Author model
21:36:09 <bsima> I juse used `UniqName first last`, i don't really need an id for my authors anyway
22:02:23 <zzo38> Now I tried making the implementation of X resource manager in Haskell. I do not have Haskell on this computer, and also have not made any programming in Haskell for some time, so, I don't know if it is correct, or even if it will compile, or if it is good. However, it is:  http://sprunge.us/hEbZ
22:02:35 <zzo38> (It is public domain, in case you wish to use it)
22:12:43 <zzo38> Do you think this is good?
22:16:47 <EvanR> plato.stanford is suggesting a more historically appropriate name for currying would be "fregeing" lol
22:19:25 <zzo38> O, maybe, I didn't know that
22:19:38 <nshepperd_> @package acme-schoenfinkel
22:19:38 <lambdabot> http://hackage.haskell.org/package/acme-schoenfinkel
22:21:49 <nshepperd_> Ah, frege was even earlier than schoenfinkel
22:32:50 <EvanR> right
22:33:02 <EvanR> begriffschrift
23:09:22 <takitus> Curry was clearly the best name to become a verb, considering the options.
23:10:45 <portnov> heh
23:11:38 <portnov> "say thanks that this operation is not called sheinfinkeling"
23:11:56 <geekosaur> @quote curry.of.y
23:11:56 <lambdabot> monochrom says: I am 17-ary, going on 18-ary, I can take curry of you
23:12:28 <angerman> portnov: "shein"? You clearly mean "schön" :-)
23:12:49 <portnov> not sure how to write this correctly :)
23:13:34 <portnov> correct form is probably in idish.
23:14:00 <angerman> yiddish?
23:15:17 <angerman> portnov: that is indeed interesting. And I did not know about the spelling differences.
23:15:27 <takitus> Any function name that requires installing new fonts to type should be vetoed :)
23:16:41 <cocreature> takitus: what kind of font doesn’t have ö?
23:16:46 <MarcelineVQ> I don't even know how people type those letters :(
23:16:51 <angerman> portnov: assuming he wrote http://www.digizeitschriften.de/dms/img/?PID=GDZPPN002270110 himself though, he would have written Schönfinkel ;)
23:16:59 <MarcelineVQ> u+0n000
23:17:03 <takitus> cocreature: I meant the Yiddish version.
23:17:08 <cocreature> ah :)
23:17:37 <angerman> MarcelineVQ: just get the "correct" keyboard :D
23:18:31 <MarcelineVQ> I used to have a fancy keybaord, it kepts switching to french mode when you pressed ctrl+shift. coincidentally you happen to hit ctrl+shift a lot when playing a game
23:18:58 <takitus> "you are now gaming in French mode. Bon chance."
23:19:01 * angerman is kinda envy of the Hungarians with their tilted dots on the o... as in ő
23:21:02 <cocreature> angerman: do they also have one with the dots tilted in the other direction? :)
23:21:37 <angerman> cocreature: no. only with a right slant and the one we know as well.
23:22:01 <angerman> portnov: Found: Schönfinkel (Yiddish: שײנפֿינק(ע)ל‎ Sheynfinkel, Russian: Шейнфинкель Šejnfinkeľ), maybe it satisfies your curiosity :D
23:22:20 <portnov> ._.
23:23:53 <lamdevhs> hello, i added a dependency package (transformers) to my .cabal file but "stack ghci" does not download or compile it... what else should i do so that it takes it into account? as a side question, if i want to use MonadIO do i really need transformers on top of mtl?
23:25:01 <cocreature> lamdevhs: maybe try a "stack build" before you run "stack ghci"
23:25:12 <cocreature> lamdevhs: also make sure you are running "stack ghci" in the directory of your project
23:25:13 <angerman>  wow. looks like some actually really try to use the cross compilers. That's good.
23:25:43 <MarcelineVQ> it's reaonably often I see someone asking about arm haskell
23:25:53 <lamdevhs> nevermind, apparently transformers is part of mtl, and i forgot the '.Class' after Control.Monad.IO
23:26:13 <lamdevhs> but thanks anyway cocreature :)
23:34:33 <angerman> MarcelineVQ: the whole binary dist stuff is still in it's infancy... 
23:34:41 <angerman> MarcelineVQ: but I think we are making some progress...
23:38:15 <mniip> 1508653097 [09:18:17] <MarcelineVQ> I used to have a fancy keybaord, it kepts switching to french mode when you pressed ctrl+shift. coincidentally you happen to hit ctrl+shift a lot when playing a game
23:38:21 <mniip> usually the OS does that for you?
23:38:36 <mniip> Ctrl-Shift or Alt-Shift usually
23:39:30 <MarcelineVQ> I can't say, it was a fair time ago, keyboards hadn't done that to me before that point though
