00:07:38 <tdammers> xmonad works fine with multiple monitors, but you kind of have to subscribe to the "dispatch workspaces onto physical monitors" paradigm
00:08:07 <tdammers> having a large number of workspaces (I have 13 of them) works really well
00:08:38 <tdammers> each workspace is one "context", and with 2 monitors, you just select the two contexts you want to be looking at
00:08:45 <tdammers> e.g., web browser + coding environment
00:08:50 <tdammers> or chat + browser
00:08:53 <tdammers> or whatever
01:40:40 <dysfigured> Okay I'm kind of still beginner, and I'm kinda high right now but what if music was a monad
01:43:23 <tdammers> in what sense?
01:44:03 <tdammers> (>>=) :: Music a -> (a -> Music b) -> Music b; return :: a -> Music a -- what would that even mean?
01:44:46 <dysfigured> I was thinking about some sort of DSL for music notation that's not a clusterf of latex and scheme
01:45:04 <tdammers> you mean like lilypond?
01:45:16 <dysfigured> Lol
01:45:36 <tdammers> seriously, "clusterf** of latex and scheme" pretty much describes lilypond
01:45:46 <tdammers> although the quality of its output is pretty much breathtaking
01:45:53 <dysfigured> Very
01:46:28 <tdammers> anyway, yes, a typed DSL for music notation would be nice, and I'll probably take a stab at it again at some point in the future, but I don't see how the Monad typeclass would fit in there
01:47:13 <tdammers> there's going to be a bunch of Functors and Monoids there, probably also Semigroups, but I don't see any obvious cases of Monad there
01:48:09 <dysfigured> Well you need some way to take a steam if input from the player, and make changes to the rhythm and pitch, also time signatures tempo etc
01:48:15 <tdammers> for example, you could have multiple alternative systems of tonality, and then a notehead would be polymorphic over the pitch type, making it a Functor
01:48:20 <dysfigured> *stream
01:48:39 <tdammers> sure, and that stream is going to be a Monoid, most likely
01:48:51 <tdammers> but that doesn't make it a Monad
01:48:52 <dysfigured> Hm yeah
01:48:59 <dysfigured> Tru ok
01:49:17 <tdammers> you will however use some sort of Monad stack for the application code that reads it from an input and writes the result back out
01:49:30 <tdammers> the parser is also going to be a monad, most likely
01:49:42 <dysfigured> Parsec I hear is good
01:49:45 <tdammers> but none of that is specific to music, and I don't see how that would make music itself a monad
01:49:56 <tdammers> Parsec, Megaparsec, Attoparsec, yes, one of those most likely
01:49:59 <tdammers> or maybe trifecta
01:49:59 <dysfigured> Ok sorry
01:50:11 <tdammers> (they're all monadic, btw)
01:50:22 <dysfigured> Ofc
02:05:58 <merijn> Megaparsec mostly obsoletes parsec
02:06:36 <merijn> For new projects I would recommend it over Parsec, I think the main use of Parsec right now is backwards compat
02:07:30 <dysfigured> Oh ok cool I'll look into it
02:11:11 <merijn> dysfigured: Basically, parsec development stalled and it's an *old* library, so it conflicts with several "modern" haskell inventions
02:11:29 <merijn> dysfigured: Such as shadowing operators from Alternative which didn't exist when it started
02:12:02 <merijn> dysfigured: Megaparsec is a fork of parsec that was (backwards incompatibily) updated to match "modern" haskell and then had active feature development on top of that
02:14:15 <dysfigured> sounds good
02:20:39 <dysfigured> Wait what if the note was the monad
02:27:05 <cocreature> dysfigured: try first figuring out what kind of operations you want to perform and then see if they fit an existing pattern instead of doing it the other way around
02:27:14 <blubberdi_> Hello, I have a problem installing/compiling a haskell package. Perhaps someone could please give me a hint what could be wrong. As far as I see all dependencies are there. http://lpaste.net/2482075022131200000
02:38:47 <AWizzArd> How is   <=<   pronounceds
02:39:12 <merijn> AWizzArd: "reversed fish"?
02:39:19 <merijn> AWizzArd: >=> is usually call the fish operator
02:39:31 <AWizzArd> Hmm okay, then maybe indeed reversed fish ;-)
02:39:38 <merijn> Although, tbh, I don't pronounce operators all that much
02:51:07 <merijn> Is there a portable way to do dupTo?
02:51:26 <merijn> I don't think it exists on windows...
02:52:07 <merijn> Or, to avoid XY problems: I want to intercept the output of an IO action (I only care about the output to stdout/stderr, not arbitrary files)
02:53:38 <LiaoTao> How would you use duplicate file descriptors?
02:54:10 <geekosaur> dup stdout elsewhere, reopen stdout to a temp file, run IO action, close stdout, dup saved one back
02:54:18 <merijn> LiaoTao: dupTo doesn't duplicate, it lets you redirect an existing file descriptor to a new one
02:54:30 <merijn> LiaoTao: What geekosaur said :)
02:54:45 <geekosaur> see for example the dance configure scripts do to capture output (look for 'exec' with only redirections)
02:54:52 <merijn> It's a fairly elegant solution, but doesn't work on windows, afaict
02:55:04 <merijn> Or I just say "sod that" and only test unix :p
02:57:06 <merijn> geekosaur: Don't even need the temp file, you can just dup to a pipe :)
02:57:06 <LiaoTao> Hmm
02:57:12 <geekosaur> https://msdn.microsoft.com/en-us/library/windows/desktop/ms724251(v=vs.85).aspx
02:57:33 <geekosaur> note that it talks about sending it to a different process, but documents semantics for the reciver being the same process
02:57:56 <merijn> geekosaur: I'm not aware of a haskell lib that exports that, though?
02:59:06 <LiaoTao> Wrapper time!
02:59:20 <merijn> Actually, I guess I have a simpler solution. Probably not too much work to slam a ReaderT throughout this code
03:00:31 <geekosaur> mm, doesn't look like it. but given windows supports it, I'd expect that (given ghc on windows uses msys2) cygwin/msys2 canexpose the posix functionality
03:00:49 <geekosaur> i.e. fcntl(fd, F_DUPFD, ...)
03:01:01 <geekosaur> dup2() is an old compatibility hack
03:01:16 <merijn> geekosaur: Yeah, but I can't even test if that works, since I don't have any way of testing windows :p
03:01:18 <geekosaur> (granting that it does do one thing the fcntl one can;t, I don;t *think* that is an issue here)
03:03:34 <royal_screwup21> so I'm trying to really grasp what monoids are. I'm familiar with constructs from Python, including classes, and so I was wondering if there was *analogy* I could draw between the two? I'm looking at this https://www.schoolofhaskell.com/user/mgsloan/monoids-tour tutorial, but I'm having a hard time
03:03:37 <geekosaur> enh. doesn't matter, I'd hoped unix-compat would export it
03:03:40 <geekosaur> it doesn't
03:03:41 <royal_screwup21> hard time "getting it" *
03:04:01 <geekosaur> a monoid is just a combining operation with an identity
03:04:04 <merijn> royal_screwup21: monoids aren't anything. They're a description of an interface
03:04:11 <geekosaur> the canonical ones are (+, 0) and (*, 1)
03:04:19 <statusbot> Maintenance update: Restarting Hackage now... -- http://status.haskell.org/pages/maintenance/537c07b0cf1fad5830000093/59f6f8c7492413049c577e1b
03:05:35 <geekosaur> for lists, (++, []) is the canonical example monoid
03:06:32 <portnov> tdammers: consider Eutherpea 
03:07:58 <royal_screwup21> geekosaur: you mean, ++ -> mappend, and [] -> mempty
03:08:10 <royal_screwup21> ?*
03:08:10 <lambdabot> Maybe you meant: v @ ? .
03:08:16 <geekosaur> merijn, maybe the most annoying thing abo8ut portability is that the next fallbck for emulating it is forkProcess... which is no-go on Windows
03:08:29 <geekosaur> for lists, yes
03:09:32 <geekosaur> note that there is no default Monoid instance for numbers in Haskell, in keeping with number theory definitions: to have "numbers" you need to have both (+, 0) and (*, 1) (and a distributive rule relating them)
03:10:13 <geekosaur> but we have Sum and Product newtypes instead, to let you specify which one you want
03:10:49 <statusbot> Maintenance update: Hackage operational again -- http://status.haskell.org/pages/maintenance/537c07b0cf1fad5830000093/59f6f8c7492413049c577e1b
03:12:13 <geekosaur> anyway: as far as theory goes, monoids are an aspect of number theory / abstract algebra, not really an everyday thing. But the concept has uses nonetheless, for generalizing operations, so Haskell supports it
03:13:17 <geekosaur> a practical example might be how xmonad uses <+> to let you build up most config entries from parts, even they all have different types
03:13:43 <geekosaur> (<+> is how xmonad spells mappend as an operator; it predates <>)
03:15:46 <royal_screwup21> cool, thanks geekosaur
03:18:14 <royal_screwup21> so I'm looking at a super easy "example" on Monoidshttps://thepasteb.in/p/xGhmv4DW93nIM My question is 1) how do I "use" this (if use is even the right term)? I mean, I tried running it as is and I got this error on GHCI https://thepasteb.in/p/8qhOqZ96PWNi0 2) I'm trying to play around with this concept, so what are some baby steps I can take to un
03:18:14 <royal_screwup21> derstand it better?
03:18:35 <royal_screwup21> https://thepasteb.in/p/xGhmv4DW93nIM (the link)
03:19:27 <geekosaur> right, you're not going to be able to do that because you can't hide the existing Monoid instance for lists
03:20:03 <royal_screwup21> ah so I need to somehow override the existing one
03:20:11 <geekosaur> you would have to import Prelude hiding (Monoid) and then define your own Monoid class and instances
03:20:21 <tdammers> dysfigured: when you're saying "A is a monad", then "an A of something" must make sense, because Monad implied * -> *
03:20:29 <tdammers> s/implied/implies/
03:21:07 <tdammers> "IO is a Monad" implies that "an IO action of String" makes sense (and it does, e.g. getLine); "List is a Monad" means that "A List of Apples" makes sense
03:21:09 <tdammers> etc. etc.
03:21:46 <tdammers> but if you're saying "Note is a Monad", then you have to have some sort of notion of "A Note of something", and I don't see how that would make sense
03:22:01 <tdammers> and I can't really think of a meaningful semantics for monadic binds of notes
03:22:22 <geekosaur> suddenly I'm reminded of that library that used to abuse Monad so it could use (>>)
03:22:30 <tdammers> geekosaur: blaze?
03:22:30 <geekosaur> and threw if you tried to use (>>=)
03:22:39 <geekosaur> I think so?
03:23:27 <tdammers> I actually do think making something like blaze monadic makes sense, but it would have to be a monad transformer, allowing you to compose HTML on top of some monad stack
03:23:45 <tdammers> then you can do things like interleave IO with producing HTML output, similar to how template engines in imperative languages do it
03:24:01 <tdammers> (but still enforcing some degree of well-formedness)
03:30:18 <macrover> xk
03:39:54 <merijn> Is there an operator/nicer way to write "foo <*> pure x"? (i.e. to eliminate the pure)
03:42:12 <carbolymer> if you're wrapping x into Applicative, how it is possible without pure?
03:42:32 <royal_screwup21> suppose a had [a] inhabitants and b has [b] inhabitants. I'm trying to figure out how many inhabitants  a -> b would have. How do I go about this? I mean if I had to find out for (a,b), I know it's |a|*|b|, because you could |a| elements in the first position, and |b| in the second. Not sure how to apply the same concept  to the one I'm trying to f
03:42:33 <royal_screwup21> igure out
03:43:02 <carbolymer> merijn, you can use return instead of pure, but I think that's not what you want
03:43:46 <Cale> :t \f x -> f <*> pure x
03:43:48 <lambdabot> Applicative f => f (a -> b) -> a -> f b
03:43:53 <Cale> :t \f x -> fmap ($ x) f
03:43:55 <lambdabot> Functor f => f (a -> b) -> a -> f b
03:45:40 <merijn> Cale: Yeah, I came up with that too, but not sure if that ends up being any more readable :\
03:46:40 <geekosaur> royal_screwup21, if -> is the function arrow (as opposed to, say, implication) then you can't determine it that way
03:47:05 <Cale> royal_screwup21: Did you mean to ask that in ##math? There are |B|^|A| (mathematical) functions A -> B
03:47:44 <royal_screwup21> geekosaur it was ->"
03:47:50 <royal_screwup21> as opposed to =>
03:47:58 <liste> royal_screwup21: (ignoring bottoms) maybe start by enumerating all possible functions a -> b
03:48:06 <liste> royal_screwup21: and see if you can count them
03:49:08 <Cale> royal_screwup21: You're making a choice of an element of B for each of the elements of A. So it's the same as counting |A|-tuples of elements of B
03:51:08 <royal_screwup21> cool, I got it, I drew an analogy with how many binary bit combinations you can form a given number of bits. thanks folks!
03:52:27 <Cale> As a followup, consider how many functions from the empty set to itself there are. :)
03:55:05 <blink4> hello
04:28:15 <orion> Cale: Is that Void -> Void?
04:31:01 <tdammers> orion: no, more like () -> ()
04:31:22 <tdammers> unless you consider bottom a proper inhabitant of any type
04:40:06 <Cale> orion: yes, though in Haskell, Void isn't quite empty.
04:42:14 <tdammers> oh, you meant "the empty set" as in "the empty type"
04:44:05 <olligobber> :exf () -> ()
04:44:06 <exferenceBot> id
04:44:17 <olligobber> :exf [a] -> [b]
04:44:20 <exferenceBot> (Control.Applicative.<*>) (join mempty)
04:45:28 <olligobber> > (Control.Applicative.<*>) (join mempty) [1,2]
04:45:32 <lambdabot>  []
04:45:50 <olligobber> hmm, why does my ghci say Not in scope: ‘join’...
04:46:09 <ahihi> it's in Control.Monad
04:55:29 <olligobber> ahihi++
05:01:18 <orion> Cale: 
05:01:24 <orion> Cale: Sure, _|_
05:03:53 <olligobber> orion, I tried :k _|_ in ghci and I get parse error on input ‘|’
05:04:28 <olligobber> and if I do :t undefined I get t
05:05:18 <opqdonut> :t undefined :: Void
05:05:19 <lambdabot> Void
05:05:26 <opqdonut> not sure what the context was here
05:05:57 <Cale> olligobber: _|_ isn't Haskell syntax, it's ascii art for mathematical notation.
05:05:58 <geekosaur> olligobber, bottom/_|_ is a conceptual thing, not a representable value]
05:06:01 <geekosaur> it means nontermination
05:06:08 <olligobber> oh
05:06:11 <opqdonut> undefined is usually a good replacement though
05:06:14 <Cale> Well, it is a representable value...
05:06:25 <geekosaur> esception, infinite loop, core dump, ...
05:06:29 <geekosaur> *exception
05:06:34 <olligobber> oh I see
05:29:41 <carbolymer> I'm trying to build statically linked binary stack build --ghc-options="-fPIC" but i am getting error:
05:29:54 <carbolymer>  /usr/bin/ld.gold: error: cannot find -lgmp
05:30:10 <carbolymer> wtf, I have libgmp.so in my /usr/lib
05:30:22 <carbolymer> any ideas?
05:31:23 <opqdonut> stack might be overriding the library search path
05:31:25 <geekosaur> you said statically linked
05:31:31 <geekosaur> you need libgmp.a
05:31:35 <opqdonut> heh right
05:34:05 <geekosaur> (a .so does not contain enough information for static linking)
05:34:05 <Eduard_Munteanu> It's quite annoying that Linux toolchains still can't use one single lib variant for both static and dynamic linking.
05:34:28 <geekosaur> uh, mosty toolchains don't
05:34:59 <Eduard_Munteanu> Although to be fair, I'd rather have a way to just bundle up the dynamic libs in the executable or close by.
05:35:39 <[exa]> static and dynamic libraries have to be compiled differrently because they are initialized and used differently
05:35:57 <[exa]> (not to mention various side annoyances like -PIC etc)
05:36:07 <geekosaur> AIX used to do that but it came at a price: they had to start from the static library / archive and dynload each object in it individually, which meant either lots of padding or some very weird memory mappings
05:36:40 <geekosaur> you can put PIC objects in a static archive. AIX did that (in fact PPC pretty much required it for user-mode code)
05:36:42 <Eduard_Munteanu> What does GHC do?
05:37:05 <[exa]> PIC is becoming default btw
05:37:10 <Eduard_Munteanu> I don't recall seeing static Haskell libs.
05:37:32 <Eduard_Munteanu> PIC is natively supported on x86-64, that helps.
05:37:34 <geekosaur> uh? static is default for haskell libs
05:37:40 <geekosaur> *.a files
05:38:02 <geekosaur> (this is also why arch has been causing endless headaches of late...)
05:38:13 <|Lupin|> Hello, Haskell friends.
05:38:19 <geekosaur> https://wiki.haskell.org/Shared_libraries_and_GHC
05:38:20 <Eduard_Munteanu> Really? Do they ship both .so and .a in GHC?
05:38:47 <geekosaur> yes. and the .so is normally used only for things like TH
05:39:19 <geekosaur> hvr's ghc packages for ubuntu used to split the dynamic ones out, but too many packages these days use TH
05:39:22 <Eduard_Munteanu> Hi, |Lupin| 
05:39:27 <|Lupin|> I have a question about how ghc's testsuite is driven.
05:39:35 <|Lupin|> It's not about running tests.
05:39:51 <|Lupin|> I wrote a tset driver for the OCaml compiler and I am writing a paper about it.
05:39:58 <geekosaur> you may want to ask in #ghc
05:40:10 <|Lupin|> So I'm trying to write the state of the art part and I was wondering how things are done in Haskell.
05:40:14 <|Lupin|> in ghc, sorry.
05:40:33 <|Lupin|> geekosaur: ah good idea, thanks a lot, was not aware of that channel
05:40:36 <geekosaur> or on glasgow-haskell-users mailing list http://mail.haskell.org/cgi-bin/mailman/listinfo/glasgow-haskell-users
05:40:39 <carbolymer> geekosaur, hm, where can I find .a?
05:40:45 <|Lupin|> hi Eduard_Munteanu 
05:41:12 <geekosaur> carbolymer, that's up to your OS.
05:41:16 <|Lupin|> geekosaur: sin't that more a dev thing?
05:41:20 <Eduard_Munteanu> carbolymer, depends on your distro. Some don't ship almost any .a's.
05:42:12 <geekosaur> |Lupin|, ghc-users is kinda a semi-devel list; Haskell users are normally on the Haskell lists rather than the ghc ones
05:42:59 <carbolymer> http://lpaste.net/6626904928776355840 1.2GB  for libgmp.a (and bunch of stuff I don't need) :|
05:43:12 <geekosaur> carbolymer, note that ghc uses OS packages for libgmp whenever possible because ghc is BSD-licensed and libgmp is not LGPL. you can link for personal use but distribution has legal ramifications
05:43:33 <carbolymer> eh, stupid licensing models
05:44:00 <Cale> carbolymer: what? You're looking at gap-packages
05:44:08 <Cale> That has nothing to do with gmp
05:44:14 <geekosaur> and you can blame arch's near worship of shared libs for that one
05:44:35 <carbolymer> Cale, weird, pkgfile found gap-pagackes as only source of libgmp.a
05:44:43 <Cale> It's like, a litany of extra packages for the GAP computer algebra system
05:44:49 <carbolymer> yep
05:44:52 <geekosaur> haskell has been pretty much broken on arch since June because they decided the static Haskell libs are evil.
05:44:58 <|Lupin|> geekosaur: okay, will give it a try, thanks a lot!
05:44:58 <carbolymer> lol
05:45:16 <carbolymer> that's hearthwarming
05:45:30 <geekosaur> (I linked to an explanation of why that doesn't work just after you joined the channel)
05:46:20 <carbolymer> geekosaur, yep, thanks
05:49:17 <carbolymer> so basically, if everything is dynamically linked, how do you guys ship binaries? build on target host?
05:49:44 <merijn> carbolymer: My recommendation would be: Build on target, link everything static
05:50:07 <merijn> carbolymer: Dynamic linking is a great way to find yourself debugging obscure linking and configuration problems
05:51:31 <Eduard_Munteanu> You can build in a VM / container matching your target.
05:52:19 <Eduard_Munteanu> That's how I build for Raspberry Pi, for example.
05:55:16 <carbolymer> i'll try this way
05:55:58 <remix2000> Hey, I'm trying to learn some basics, how can I shorten this, while keeping `fmap`? ``optionSum o = fmap (\t -> show (foldl (\acc x -> acc + (read [x] :: Int)) 0 t)) o``
05:56:52 <int-e> "there is no reason in principle that Haskell should be limited to integral precedences in the range 1 to 10" -- isn't it 0 to 9? (last sentence in https://www.haskell.org/onlinereport/haskell2010/haskellch10.html )
05:56:57 <Cale> You could replace the foldl with sum
05:57:14 <Cale> (and map)
05:58:29 <Cale> int-e: Yeah, it's 0 to 9
06:04:38 <Psybur> @pl (\x -> [x])
06:04:38 <lambdabot> return
06:06:15 <Eduard_Munteanu> @hoogle singleton
06:06:16 <lambdabot> Data.ByteString singleton :: Word8 -> ByteString
06:06:16 <lambdabot> Data.ByteString.Char8 singleton :: Char -> ByteString
06:06:16 <lambdabot> Data.ByteString.Lazy singleton :: Word8 -> ByteString
06:06:53 <Eduard_Munteanu> Or just the monkey operator... (:[])
06:08:21 <Eduard_Munteanu> > (:[]) "🍌"
06:08:27 <lambdabot>  mueval-core: Time limit exceeded
06:08:56 <Younder> flatpack (https://github.com/flatpak/flatpak) might be usable for distributing Haskell programs with dynamic link libraries.
06:10:46 <Eduard_Munteanu> They don't really focus on things other than desktop applications, though. But there are alternatives.
06:11:17 <Eduard_Munteanu> I think Snap aims to support servers/services too.
06:11:37 <nek0> hi folks, IS there a way to convert the first page of a pdf file to an image, preferably png?
06:12:52 <Eduard_Munteanu> nek0, there's pdftoppm on my system, then you can convert the ppm with imagemagick.
06:13:00 <Younder> with imagemagic "convert -density 300 -depth 8 -quality 85 a.pdf a.png"
06:14:08 <Psybur> ertes, when are you going to make a language that lives in a right fold? :D
06:14:28 <nek0> Eduard_Munteanu, Younder: Is imagemagick the only option I have?
06:14:48 <Eduard_Munteanu> That makes it sound like an infection. :P
06:15:11 <Eduard_Munteanu> nek0, maybe gimp?
06:16:08 <nek0> Eduard_Munteanu: I am looking for a library, because I want to use it on a hosting service I am writing.
06:16:44 <Eduard_Munteanu> Hm.
06:17:14 <Eduard_Munteanu> I wonder if Pandoc can do it.
06:17:27 <Eduard_Munteanu> If you want a Haskell lib.
06:19:39 <nek0> Eduard_Munteanu: Pandoc can create PDFs, but not read them, unfortunately.
06:22:19 <ertes> Psybur: richard bird beat me to that =)
06:22:50 <ertes> Psybur: search for "bird bananas lenses"
06:23:36 <geekosaur> nek0, look for pdftk or poppler/poppler-utils?
06:24:02 <geekosaur> one way or another you are likely to end up with some variant of ghostscript; a pdf is a *program*
06:24:15 <geekosaur> (imagemagick's delegate for PDF is gs)
06:25:41 <Psybur> ertes, I always get a few paragraphs into that paper then get lost with all the symbols :D
06:26:21 <ertes> identify algebraic types as fixed points of functors, then producing and consuming those correspond to F-coalgebras and F-algebras…  that's where terms like "anamorphism" and "catamorphism" come from, and it's basically a language of unfolds and folds together with algebraic properties
06:26:43 <nek0> geekosaur: thanks for the poppler hint.
06:27:34 <ertes> Psybur: next time you read it, you should implement as you read =)
06:28:06 <Psybur> So the crossed circle is an arbitrary function? I need a key of these symbols heh\
06:28:41 <ertes> Psybur: the idea to identify recursive types as fixed-point-like things of flat "template" or "layer" types is actually quite common…  do you know free monads?
06:29:15 <Psybur> Ive read about them, I forget how theyre defined
06:29:52 <ertes> Psybur: learn those first – ironically i find them easier to learn, which is probably because there is a lot more learning material around for them
06:30:01 <ertes> Psybur: and they are more readily practically applicable
06:30:14 <remix2000> Cale: Like this? ``optionSum o = fmap (sum . map (\y -> (read [y] :: Int))) o``
06:30:19 <Psybur> ertes, ok
06:30:55 <ertes> Psybur: free monads are a DSL toolkit and very useful…  and once you understand them, the recursion schemes of bird's paper will be much less alien
06:31:39 <Eduard_Munteanu> remix2000, you can remove the 'o' parameter
06:32:20 <Eduard_Munteanu> optionSum = fmap (sum . map (read . (:[])))
06:32:28 <tdammers> nek0: pandoc kind of cheats wrt pdf; it doesn't generate them itself, it just produces latex and then feeds it to pdflatex
06:32:44 <ertes> Psybur: oh, and once you understand those you will no longer have to read my long foldr tutorial =P
06:33:06 <ertes> except perhaps the section on "stateful folds" and "reverse state"
06:33:26 <Psybur> ! but I felt so proud of myself with maybe (const 0) id (Just (^2)) 5 :D
06:34:23 <ertes> Psybur: that's fine…  the new information you will gain is how exactly 'maybe' is the 'foldr' equivalent for Maybe =)
06:40:39 <remix2000> Eduard_Munteanu, Cale: Thank you kindly :)
06:58:05 <merijn> ugh...
06:58:27 <merijn> So, if I have two "SomeException", is there a decent way to check if they're equal?
07:09:31 <geekosaur> I think the best you can do is check if the String produced by show is the same. (Conceptually they probably *shouldn't* ever be the same)
07:21:59 <antsanto> I'm trying to learn Haskell now, and I came with this code : https://pastebin.com/KBmuVfhk. I didn't quite it right I guess, how come creating two let statements myLength doesn't re-assign the function? And also how it recursively calls!?
07:23:39 <geekosaur> you didn;t do anything recursive there
07:23:44 <Cale> antsanto: You shouldn't have it in two separate lets like that, that shadows the first definition of myLength with the second
07:23:53 <Cale> and yeah, you used length, rather than myLength
07:24:17 <Cale> Also, you should avoid using tail -- pattern match against (x:xs) instead
07:24:43 <geekosaur> if you are doing this in ghci, you need to arrange for both definitions to be part of the same 'binding group', either by doing them both on onbe line separated by semicolons, or using multi-line input (:set +m, or :{ :})
07:24:57 <geekosaur> *on one line
07:25:04 * shapr binds geekosaur into a Haskell group
07:25:24 * geekosaur looks around --- er, I'm already bound to #haskell?
07:25:27 <geekosaur> :p
07:25:31 <antsanto> Cale: Oh yeah thanks!
07:25:37 <antsanto> so basically like this
07:25:38 <antsanto> let myLength [] = 0 ; myLength xs = 1 + myLength (tail xs)
07:25:51 <Cale> geekosaur: It worked!
07:25:54 <antsanto> I'm very new to haskell and using Intellij plugin to run my codes. 
07:26:51 <liste> d
07:26:59 <Cale> antsanto: myLength (x:xs) = 1 + myLength xs -- better way to define it
07:27:04 <liste> sorry bout that ↑
07:27:27 <Cale> antsanto: The thing about tail is that if you ever accidentally apply it to an empty list, your program crashes with an exception.
07:27:34 <geekosaur> ...so I've been bound and you've been listed?
07:27:58 <Cale> (and then if your program is large and you use tail a lot, you're quite unhappy, because it's really hard to tell where the problem is)
07:28:20 <Cale> So generally try to avoid head and tail.
07:28:29 <Cale> Pattern matching is much better generally.
07:29:15 <antsanto> Cale: Oh the code myLength (x:xs) = 1 + myLength xs seems to be so cool. But wondering , how does that work? So everytime ur pattern matching an first element of the list (in x) and recursively calls myLength . Is that what happening here?
07:29:50 <Cale> antsanto: Yeah, (x:xs) is a list with at least one element, whose first element is x, and whose tail is xs
07:31:06 <Cale> and so just as when you write myLength [] = ... and it only uses that definition when the input list is empty, the  myLength (x:xs) = ... will only match a nonempty list, and will split it into the first element and the remainder.
07:32:42 <antsanto> Cale: Oh thanks again! I guess i have now got my head around it.
07:33:10 <antsanto> Now a noob questions, is there is a way to see / debug / stacktrace on pattern matching in haskell? I guess that would help me very much!
07:33:40 <merijn> antsanto: You're crashing on an incomplete pattern?
07:33:50 <eacameron> I have a bunch of union types acting as primitive enums. I also have a function that cases on each one and converts it to a specific numeric code. Sometimes I map over a list of enums and convert them to codes. Is the pattern match on n enum choices O(n) in lookup time?
07:34:15 <ski> antsanto : an example reduction/evaluation sequence, using `myLength' :
07:34:17 <antsanto> merijn: Nope, just to see how it works. Because to a beginner like me in haskell, such a tool would be useful. 
07:34:17 <merijn> eacameron: EUNSPECIFIED :)
07:34:24 <ski>      myLength [6,28,496]
07:34:31 <ski>   =  myLength (6:28:496:[])
07:34:37 <ski>   =  1 + myLength (28:496:[])
07:34:42 <ski>   =  1 + (1 + myLength (496:[]))
07:34:46 <eacameron> merijn: What does that mean?
07:34:47 <merijn> eacameron: The Haskell report doesn't specify anything about how this is implemented. Realistically, speaking about GHC it's almost certainly NOT going to be O(n)
07:34:49 <ski>   =  1 + (1 + (1 + myLength []))
07:34:55 <ski>   =  1 + (1 + (1 + 0))
07:34:55 <geekosaur> eacameron, you can check Core. I think it's usually compiled to a jump table
07:34:56 <eacameron> merijn: Ahh
07:35:00 <ski>   =  1 + (1 + 1)
07:35:03 <ski>   =  1 + 2
07:35:05 <ski>   =  3
07:35:09 <merijn> eacameron: I would expect a jump table, like geekosaur mentions
07:35:15 <geekosaur> (the COre may not show the jump table as such, you;d have to look at cmm or something)
07:35:27 <merijn> eacameron: Because a linear scan over patterns would be a ridiculously stupid way of doing things
07:36:02 <eacameron> merijn: Haha "Doing it that way would be ridiculously stupid" is enough reason to believe that's not how it's done at this point in GHC's maturity
07:36:04 <ski> antsanto : the first step is just desugaring the notation `[6,28,496]' to what it really means, `6:28:496:[]' (which, if we add brackets, means `6:(28:(496:[]))')
07:36:19 <antsanto> ski: Oh thanks a ton, that makes a lot of sense
07:36:44 <geekosaur> antsanto, one thing you can do is to use the runtime option -xc to show a stack trace when an exception is thrown (+RTS -xc)
07:36:58 <merijn> eacameron: From a compiler perspective "case-of" looks a lot like "switch" in C, so I would expect a similar compilation strategy
07:37:02 <geekosaur> not sure how you;d do that from intellij though
07:37:22 <ski> antsanto : in the next step, we use the second defining equation of `myLength' (Cale's version), so `x' is bound to `6' and `xs' to `28:496:[]', so that equation `myLength (x:xs) = 1 + myLength xs' becomes `myLength (6:28:496:[]) = 1 + myLength (28:496:[])'
07:37:25 <antsanto> geekosaur: sure, I can fall back to ghci when needed and use this option. 
07:37:54 <eacameron> merijn: Good to know. I wasn't sure if true union types messed that up somehow.
07:37:54 <merijn> eacameron: Just think of constructors as the "label" of a switch (of course, if you have complex/nested patterns you might need to do a bit of additional computation to see if something matches)
07:37:54 <ski> antsanto : in the next step, we use the same defining equation again, but now the (fresh/new) variables `x' and `xs' are bound to `28' respectively `496:[]'
07:37:56 <geekosaur> I still wish we had a way to invoke an alternative Prelude or whatever with 'callstacks' (not really, but close enough) enabled
07:38:19 <shapr> geekosaur: oh, callstacks wrapped around everything?
07:38:23 <geekosaur> most things use errorWithoutStackTrace :(
07:38:29 <shapr> geekosaur: that would be a great newbie tool
07:38:33 <shapr> do it!
07:38:47 <ski> antsanto : and in the next step, we one more time use this defining equation (with `xs' being `[]' here). the following step uses the `myLength [] = 0' defining equation. the remaining steps are just arithmetic (definition of addition)
07:38:49 <merijn> eacameron: But in the simple case of a union of constructors simple constructors will be treated as just integer tags inside GHC, most likely
07:38:50 <geekosaur> if only it were that simple.
07:39:00 <shapr> geekosaur: why isn't it?
07:39:17 <merijn> geekosaur: Eh, aren't you just describing the profiling runtime?
07:39:25 <geekosaur> it's not just Prelude, and rpelacing all of base is ... difficult
07:39:27 <merijn> geekosaur: Profiled executables always have stack traces
07:39:35 <ski> antsanto : note that i added extra brackets around the result of the recursive calls, when i expanded them, to show that we really have to "get to the end" of the list here, before any incrementation can happen
07:39:38 <antsanto> ski: thanks again. But binding many times x doesn't cause any issue? Or its just x would be replaced by the first element of the list?
07:39:40 <geekosaur> great, so now you need a ghci built for profiling
07:39:59 <eacameron> merijn: Good; I was afraid of having to build "Map"s for these which would be super annoying. I won't bother.
07:40:11 <ski> antsanto : an alternative version of `myLength' would start incrementing as it goes, without waiting to get to the end. perhaps try and see if you can define such a version of `myLength' that does that ?
07:40:19 <merijn> eacameron: Well, you could always resort to TH to generate the map at compile time if you find yourself needing that :)
07:40:28 <merijn> eacameron: But I'd try the simple way first
07:40:54 <eacameron> merijn: Interesting idea. Yeah I go with naive for now. If performance hits I'll take a look at that.
07:41:02 <ski> antsanto : each `x' there is conceptually a new variable. if you're writing such reduction sequences, you could rename them to `x0',`x1',`x2',... in order to keep them straight in your head
07:41:09 <ski> antsanto : and ditto for `xs'
07:41:54 <antsanto> ski: oh that makes thing much more clear to me, 
07:43:19 <ski> antsanto : each time a function is called, the local variables of it (including ones bound by patterns in defining equations (or `case' patterns), and ones bound inside `where'- or `let'- bindings) are conceptually to be treated as freshly created variables, distinct from any previous variables
07:44:15 <remix2000> How can I map only elements matching certain condition?
07:44:18 <antsanto> ski: Thanks !! 
07:44:28 <ski> antsanto : so if you have a function `f' defined in terms of a variable `x', which calls a function `g' also defined in terms of a variable `x', then these two `x's are unrelated to each other. now, when `f' and `g' are the same function (so recursion), the `x' of the initial call is still a different variable from the `x' of the recursive calle
07:45:20 <antsanto> ski: oh.. thanks for the clear explanation. 
07:46:04 <ski> antsanto : if one wanted to be more clear, one could distinguish between a syntactic variable in the program text (there's only one `x' in the definition of `myLength') and an *activation* of it at run-time, which is what's actually bound to a value (or a computation which will eventually yield a value, if forced) -- there can be several activations of the same syntactic variable
07:46:58 <antsanto> ski: Thanks. I'm planning to implement all list function myself using pattern matching, that would be a good excerise for me. 
07:47:02 <antsanto> as a beginner. 
07:47:05 * ski nods
07:47:19 <ski> antsanto : if you want to, you could also ponder the exercise i suggested above
07:47:35 <antsanto> ski: Yes, i will try and let you know. 
07:48:25 <shapr> @seen quchen
07:48:25 <lambdabot> Qu(|-|EN
07:48:26 <shapr> bah
07:48:31 <shapr> oh well
07:49:35 <ski> (Last seen  : Oct 27 14:52:10 2017 (2d 23h 56m 40s ago))
07:49:39 <shapr> oh, thanks!
07:49:47 <shapr> tack saa mycket ski!
07:50:07 <ski> varsågod :)
08:05:03 <one_poor_fellow> Hello all  is it easy to work as a freelancer consultant ?
08:05:17 <shapr> one_poor_fellow: do you have experience writing Haskell?
08:05:39 <one_poor_fellow> shapr:  Yeah
08:05:52 <one_poor_fellow> if not soon
08:06:38 <shapr> one_poor_fellow: do you have code up on github that demonstrates what you can do?
08:07:31 <shapr> one_poor_fellow: I've seen plenty of advertisements for Haskell jobs
08:07:38 <one_poor_fellow> shapr:  dummy code I have on github nothing own modules etc
08:07:45 <ventonegro> Is this related to https://dirtcheaphaskell.io/
08:07:56 <shapr> ventonegro: oh wow, that's awesome
08:08:49 <one_poor_fellow> shapr:  I live in city for earning/job nw I want to go back my village and live with my parenst/relatives .....only thing I thought is freelance consultancy but I dont know how to start
08:09:54 <shapr> one_poor_fellow: when I was self-employed, most of my work started small. When I had a positive reputation with several people, they'd recommend me to others.
08:10:52 <one_poor_fellow> how you started self employment?
08:10:59 <one_poor_fellow> shapr: ^^
08:12:18 <shapr> one_poor_fellow: I asked people if they needed work done, showed 'em things I'd built, and we talked money
08:14:14 <one_poor_fellow> asked where ?
08:14:21 <one_poor_fellow> online
08:14:27 <shapr> one_poor_fellow: people I knew who might need work done
08:14:28 <one_poor_fellow> or you went to some places etc?
08:14:35 <shapr> I've found it much easier to ask people I know in person.
08:19:33 <one_poor_fellow> shapr:  I will try in freelancer/udesk
08:19:37 <one_poor_fellow> odesk*
08:19:59 <shapr> one_poor_fellow: if you start putting up fixes for GHC and other Haskell libraries, that will raise your street cred
08:21:03 <one_poor_fellow> cred means?
08:21:11 <one_poor_fellow> street cred ?
08:21:50 <one_poor_fellow> shapr:  I am thinking to contribute to some opensource
08:22:10 <one_poor_fellow> and add it to my profile
08:23:16 <shapr> one_poor_fellow: I think that will help
08:23:30 <k0ral> http://lpaste.net/359644 => How would you name this type ? Can it be built by combining existing semigroups from standard libraries, rather than handwriting the instance ? Is it useful ?
08:23:53 <k0ral> http://lpaste.net/359644 => How would you name this type ? Can it be built by combining existing semigroups from standard libraries, rather than handwriting the instance ? Is it useful ?
08:25:11 <one_poor_fellow> Ok thank you shapr  
08:25:19 <cocreature> k0ral: https://hackage.haskell.org/package/these-0.7.4/docs/Data-These.html
08:25:39 <k0ral> cocreature: Semigroup instance for These is not behaving like what I pasted
08:26:28 <cocreature> oh right
08:26:35 <cocreature> I haven’t seen the instance you defined
08:41:25 <Henson> hi folks, I used to know this but forget how to do it.  What's the way to lift a "Maybe a" value into the MaybeT monad.  Something like "IO Maybe a -> MaybeT IO a"
08:42:15 <ski> @type MaybeT
08:42:17 <lambdabot> m (Maybe a) -> MaybeT m a
08:42:56 <cocreature> Henson: IO (Maybe a) -> MaybeT IO a or Maybe a -> MaybeT IO a?
08:43:01 <ski>   newtype MaybeT m a = MaybeT (m (Maybe a))
08:43:23 <ski> @type MaybeT . return
08:43:25 <lambdabot> Monad m => Maybe a -> MaybeT m a
08:43:39 <Henson> cocreature: the former: IO (Maybe a) -> MaybeT IO a
08:43:48 <ski> @type MaybeT . liftM Just
08:43:50 <lambdabot> Monad m => m a -> MaybeT m a
08:44:17 <ski> (the latter one is `lift', in the `MonadTrans MaybeT' instance)
08:45:02 <cocreature> Henson: in that case just use the MaybeT constructor as ski showed you
08:45:18 <ski> (data constructor)
08:46:05 <Henson> cocreature, ski: ok, thank you both
08:46:12 <ski> yw
08:52:08 <dmwit> ski: I don't think the latter one is `lift`. `lift` would be `IO a -> MaybeT IO a`.
08:53:57 <dmwit> I don't think we have a generalized name for "go from the non-transformer version to the transformer version", though `hoist generalize` from the mmorph package will get you there if your non-transformed version is actually a wrapper around `Identity`.
08:55:12 <dmwit> ...oh, maybe when you said "latter", you meant the latter of your two examples. I see.
08:55:35 <dmwit> I read it as a reply to his comment demanding "the former" and got confused. Apologies.
09:02:58 <ski> the latter of my *three* examples, yes :)
09:04:38 <dmwit> Ouch, does "latter" even apply when there are three choices? heh
09:06:44 * ski . o O ( latter day quaints )
09:18:06 <theobromine> hi i'm thinking about using postgrest in my application but don't really know haskell (so i would be using it as a shrinkwrapped application) and need some guidance on how to handle authentication. some forum post suggested #haskell was a good place to ask...
09:19:30 <dmwit> This is a fine place to ask if you have a question about Haskell...
09:20:22 <geekosaur> dmwit, http://hackage.haskell.org/package/postgrest
09:20:51 <jle`> Henson: i'm not super satisfied with any current built in solution
09:21:01 <jle`> Henson: but i've used 'maybe mzero return' often
09:21:09 <jle`> because it respects the semantics
09:21:31 <jle`> it feels a little more meaningful than MaybeT . return
09:22:14 <jle`> > length "maybe mzero return"
09:22:16 <lambdabot>  18
09:22:18 <jle`> > length "MaybeT . return"
09:22:21 <lambdabot>  15
09:22:56 <jle`> the downside :(
09:23:09 <dmwit> Okay. I don't know enough about postgrest to say what tools it has for authentication.
09:23:43 <Henson> jle`: fortunately, the MaybeT constructor works in my case.
09:24:25 <jle`> Henson: yes, they do the same thing
09:24:37 <jle`> :t MaybeT . return
09:24:39 <lambdabot> Monad m => Maybe a -> MaybeT m a
09:24:40 <jle`> :t maybe mzero return
09:24:42 <lambdabot> MonadPlus m => Maybe a -> m a
09:25:04 <jle`> but i feel like maybe mzero return is more meaningful; MaybeT . return feels kinda newtype-hacky
09:25:33 <jle`> 'maybe mzero return' says "if it's Nothing, fail; if it's Just, succeed"
09:45:09 <rotaerk> jle`, the length comparison is irrelevant IMO
09:45:30 <rotaerk> what matters is understandability; shorter length correlates with that, but doesn't determine that...
09:46:17 <rotaerk> and I do think that "maybe mzero return" is more expressive
09:49:51 <ocramz> hullo!
09:50:00 <ocramz> anybody familiar with `cryptonite`?
09:51:12 <ocramz> I'd like to know how to feed a RSA private key into the PrivateKey type, which is encoded as integers: https://hackage.haskell.org/package/cryptonite-0.24/docs/Crypto-PubKey-RSA-Types.html#t:PrivateKey
09:52:53 <dminuoso> What `WinCompose` alternative would you folks recommend for OSX? I really do want lambdas. :(
09:53:07 <rotaerk> ocramz, I don't know cryptonite, but just checking:  did you see Crypto.Tutorial?
09:57:18 <ocramz> hi rotaerk , thanks but yes; problem is that Crypto.Tutorial generates the key on the fly; I already have one
09:58:52 <glguy> ocramz: It will matter what format you have the RSA key in, then you'll need to use a package that understands that format
09:59:09 <rotaerk> ocramz, what form does it take?  can you not manually construct the PrivateKey type?
09:59:12 <ocramz> it's PEM encoding I think
10:00:13 <ocramz> as in GPG keys; there are + and = signs and alphanumeric data
10:00:18 <Johulk> Hi guys
10:00:20 <Johulk> can someone help me?
10:00:24 <Johulk> when I use this function
10:00:24 <Johulk> http://lpaste.net/359648
10:00:29 <Johulk> sometimes it works
10:00:44 <rotaerk> Johulk, try to put more on one line instead of a few words per message
10:00:48 <ocramz> glguy : iiuc the x509 packages handle this kind of stuff
10:01:55 <Johulk> Sorry. Basicly when I do this -----> iSort [6,40,3,80,50,5,3000] , it returns [6,3,5,40,50,80,3000]
10:01:59 <glguy> Johulk: That's not a correct algorithm for sorting a list, is that what it's supposed to do?
10:02:04 <Johulk> Yes.
10:02:18 <geekosaur> logic error
10:02:31 <geekosaur> think about what your code is doing
10:02:33 <Johulk> What's it supposed to be?
10:02:53 <Johulk> I mean, I'm going to guess it gives that error because it only checks against the next element
10:03:01 <glguy> Johulk: There are lots of sorting algorithms, this just isn't one of them
10:03:02 <geekosaur> it's more than that
10:03:07 <glguy> > iSort [2,5,1]
10:03:09 <lambdabot>  [2,1,5]
10:03:17 <glguy> There's a smaller failure case
10:03:38 <[exa]> Johulk: ....but you're on a good way to bubblesort!
10:03:39 <glguy> 2 < 5 doesn't justify 2 being emitted as the first element
10:03:44 <Johulk> bubblesort? xD
10:03:44 <rotaerk> how'd lambdabot know about iSort?
10:03:49 <Johulk> I have no idea
10:03:53 <geekosaur> probably a @let in pm
10:03:58 <rotaerk> k
10:04:03 <ski> @help letlpaste
10:04:03 <lambdabot> letlpaste <paste_id>. Import the contents of an lpaste.
10:04:14 <geekosaur> ah, right
10:04:20 <Johulk> So, what do I do to fix it?
10:04:25 <Johulk> just point me in the direction
10:04:43 <rotaerk> what you do is think through the logic of it and understand why it's returning what it does
10:04:48 <rotaerk> and then fix it
10:04:52 <Johulk> Alright
10:04:57 <[exa]> Johulk: which sorting algorithm is that code supposed to implement?
10:05:16 <Johulk> basicly, grabs any list of numbers and sorts it from lower to higher
10:05:23 <glguy> rotaerk: You could look up known sorting algorithms on Google and pick one if you're interested in implementing a sorting algorithm by hand
10:05:34 <glguy> err, Johulk
10:05:58 <Johulk> sort [2,5,1]
10:06:03 <Johulk> Thanks bot.
10:06:04 <Johulk> :(
10:06:07 <[exa]> you need >
10:06:17 <Johulk> >sort [2,5,1]
10:06:21 <Johulk> > sort [2,5,1]
10:06:23 <lambdabot>  [1,2,5]
10:06:29 <Johulk> aw ffs xD
10:06:35 <ski> `iSort' ?
10:06:57 <rotaerk> "Hey, why don't I just do iSort = sort :3"
10:07:06 <Johulk> I know
10:07:09 <Johulk> I asked the teacher about it
10:07:16 <Johulk> he laughed and said " Instant fail"
10:08:00 <foojin> Hi everyone. I'm trying to use GHC and Stack (as distro packages) to install some libraries and have a quick way to run scripts and try out one-liners in GHCi. I've read about Haskell Platform and how using Stack is better than installing it, but it does have some useful packages for working with text and html.
10:08:00 * ski smiles
10:08:06 <foojin> So, are those available through Stack _as a set_ or do I have to write a script to obtain a list of them and install them one-by-one? The Platform's website suggests that the list changes from version to version, so not having to script around that would be nice.
10:08:20 <[exa]> Johulk: you're probably going the right way but it's certainly not implemented in the way it'd sort anything. Anytime your list starts with a smaller number than the second, the smaller number will be first in the result as you see
10:08:36 <[exa]> Johulk: no matter if there's a smaller number later in the list, which should go first instead
10:09:19 <[exa]> Johulk: I greatly recommend looking at https://en.wikipedia.org/wiki/Bubble_sort and trying to reimplement it
10:09:30 <Johulk> It's not supposed to be Bubble sort xD
10:09:39 <Johulk> it's supposed to be the same as "sort"
10:09:58 <[exa]> the result will be exactly the same
10:11:17 * ski . o O ( `iSort' being "insertion sort" ? )
10:11:47 <rotaerk> nope, Apple sort
10:12:29 * ski sorts apples according to hue
10:14:24 <mnoonan> foojin: stack will take care of installing sandboxed versions of whatever package dependencies you need
10:16:54 <[exa]> last time I was in Bayern there was a supermarket where tomatoes were 2D sorted according to sweetness (left-right) and color (bottom-top)
10:17:02 <[exa]> I love sorting.
10:17:26 <[exa]> Johulk: anyway, the implementation of haskell's sort is here http://hackage.haskell.org/package/base-4.10.0.0/docs/src/Data.OldList.html#sort
10:18:05 <[exa]> it's part mergesort and some preprocessing by monotonicity detection
10:20:11 <c_wraith> it's 99% bottom-up mergesort, with a smarter first pass than making everything a singleton list.
10:21:42 <foojin> mnoonan: I'm trying to use it slightly differently, installing most of whatever I can possibly need in ~/.stack and then coding without having to manage packages or have an working Internet connection. Hence the question about the Platform stuff being available as a single package / small set of packages.
10:22:45 <mnoonan> foojin: I see. fwiw, stack caches your downloaded packages, so you won't be hitting the internet after the initial downloads.
10:23:59 <mud> That sure is pretty short for a practical sorting implementation. I expected a lot more magic to be honest.
10:27:57 <inkbottle> [just for the fun of it] let fix :: (a -> a) -> a; fix f = f (fix f) in fix (\f x -> case x of {0 -> 1; _ -> x * f (x-1)}) $ 5 -- https://en.wikipedia.org/wiki/Fixed-point_combinator#Lazy_functional_implementation
10:28:41 <mud> Hey, I guessed right what that does, huzzah.
10:28:44 <mud> :t fix
10:28:46 <lambdabot> (a -> a) -> a
10:28:53 <mud> That's the same fix, right? You don't actually have to define it first.
10:29:06 <inkbottle> ... ok
10:29:14 <ski> @src fix
10:29:14 <lambdabot> fix f = let x = f x in x
10:29:28 <ski> or, equivalently
10:29:32 <ski>   fix f = x
10:29:34 <ski>     where
10:29:36 <ski>     x = f x
10:30:36 <foojin> mnoonan: So it seems that I do need to either discover the needed packages as I go or somehow process the Haskell Platform build files to get a reasonable approximation of "batteries included". If only there was a better way...
10:30:55 <ski> in a by-need implementation, this version of `fix' will make `fix (0 :)' only make one cons cell. the recursive `fix' version wouldn't
10:31:36 <inkbottle> ski: yes it fits the equation too, nice.
10:31:56 <mnoonan> foojin: you might find this useful: https://groups.google.com/forum/#!topic/haskell-stack/LHG9DSrz8k8
10:32:38 <mnoonan> or maybe here, more directly: https://github.com/ndmitchell/offline-stack#readme
10:38:49 <foojin> mnoonan: Seems like overkill, but it does solve the problem. I'll try that if extraction fails.
11:33:13 <cosmos_> Any change to enable the dark mode in Phabricator by /settings/builtin/global/page/display/ ?
11:33:18 <cosmos_> `chance
11:33:44 <geekosaur> try in #ghc
11:37:53 <cosmos_> thy
11:39:10 <geekosaur> hm, or maybe it's just version differences? I see it on https://phabricator.haskell.org/settings/user/geekosaur/page/display/ and I doubt the global default would be changed for one user
11:43:51 <cosmos_> well, i guess others are also happy about a simple solution
12:04:20 <biglambda> Quick question: Currently when I compile with cabal it compiles every file twice, the second time each object file is .p_o  I think this means I have profiling enabled but I don’t know where it is enabled. Any ideas?
12:04:48 <geekosaur> ~/.cabal/config
12:05:05 <geekosaur> alternately if you are using a sandbox it can be configured in the sandbox config
12:05:52 <monochrom> Actually that's a bit surprising because cabal's default doesn't enable profiling.
12:06:13 <monochrom> But yes if you see *.p_o it's definitely profiling.
12:06:43 <royal_screwup21> I'm trying to define a new datatype on GHCI like so: "let data Suit = Heart | Diamond deriving(show)" It says " parse error on input 'data'. How do I fix this? I looked this up but couldn't find anythign specific to my question - lots of suggestions involved using a "let" binding, which I did, so that wasn't of much help
12:07:29 <geekosaur> royal_screwup21, don't use 'let' for 'data'
12:08:07 <geekosaur> let makes bindings (including function bindings)
12:08:45 <royal_screwup21> https://thepasteb.in/p/Z4hPgVEq07xFG
12:08:46 <geekosaur> also if you have an older ghci then it may not accepot 'data' at the prompt, but I think that one goes back to 7.2 so you should be okay there
12:09:04 <geekosaur> case matters
12:09:12 <geekosaur> tyepclass names are initial capitals
12:09:31 <geekosaur> you are not deriving the method name, you are deriving the typeclass
12:09:41 <royal_screwup21> ohh
12:09:47 <royal_screwup21> right, cool, thanks!
13:05:22 <daey> running ghc-pkg check returns a lot of warnings. is that normal? http://lpaste.net/359656
13:06:00 <geekosaur> it will always wartn about haddocks if you don;t have things configured to build local docs
13:07:05 <daey> ok
13:11:47 <llinguini> So, if you have a purely functional program, does that mean that everything is calculated at compiletime?
13:12:43 <EvanR> monotone functions (domain theory)  give semantics for lambda calculus programs. but i just realized ... what exactly is the domain for these functions?
13:13:07 <EvanR> bottom + what
13:13:13 <[exa]> llinguini: depends on what the input of the function is. It may e.g. depend on user input.
13:13:54 <llinguini> So assuming there is none, then the entire program can be calculated at compiletime?
13:14:06 <mud> llinguini: Not if you consider haskell purely-functional. Otherwise, it's questionable what all of my haskell programs are doing, they should all complete running immediately.
13:14:14 <daey> wouldnt any other compiler handle it the same way?
13:14:17 <[exa]> llinguini: haskell programs are (in an extremely simplified view) functions of type RealWorld -> RealWorld
13:14:37 <EvanR> if your "program" is type Int (not a function) yes it can be computed at compile time
13:14:51 <EvanR> but watch out for bottom, the compiler will freeze
13:15:08 <EvanR> if its a function, its computed, and now waiting for input
13:15:25 <geekosaur> hypothetically yes. in practice no, because most useful programs do I/O. (which in Haskell is done by a trick: you appear to be writing I/O stuff but you're actually having your program build a program for an impure I/O engine)
13:15:44 <[exa]> llinguini: anyway if you don't require to interact with RealWorld, AND you have some way to force the compiler to let the compile-time partial evaluation loose, you will receive the result right from the compiler as constant
13:16:34 <[exa]> llinguini: problem is that "let it go" means that you will hit halting problem
13:17:04 <EvanR> halting would be a good problem to have
13:17:44 * EvanR renames it to the non-halting problem
13:18:38 * [exa] discards computability jargon
13:21:35 <daey> i wrote this simple haskell program. it parses a svg file and searchs/counts for all partno appearances. The problem is, it is terribly slow (the python version runs 50x faster :P). What did i do wrong? http://lpaste.net/359657 
13:23:39 <EvanR> daey: using String, which is [Char]
13:24:01 <EvanR> among other things, map length on a [String] is gonig to be slow
13:24:27 <dsal> Isn't cmbn ~= zip?
13:24:31 <EvanR> probably use Text, starting at the file reading part
13:25:04 <EvanR> cmbn is zip
13:25:23 <EvanR> if they are the same length
13:25:36 <dsal> Yeah, it looks like it fails otherwise.
13:27:12 <sm> daey: compile it with -rtsopts and run it with +RTS -S to see some useful stats
13:28:07 <dsal> The last time I ran the profiler on a benchmark, it told me that criterion was using most of the CPU in my benchmark run.  So, woo.
13:30:03 <inkbottle> I suppose it is not possible to put a typeclass for 'positive' Integral? (I'd say because only concrete types are initial)
13:31:28 <EvanR> you could define a typeclass with certain laws, but they are unlikely to be enforced by the compiler
13:33:59 <daey> sm: i compiled it with 'ghc -rtsopts counter.hs'. But i am unsure how to run it with the flags you mentioned './counter +RTS -S input.svg' returns something that looks like a helpfile
13:35:35 <inkbottle> Because I'm looking for an operator that does: toThePow = \f n -> case n of {0 -> id; _ -> f.(toThePow f (n-1))}
13:35:52 <inkbottle> and I would like to search it through its type
13:36:36 <Hafydd> inkbottle: you can achieve this using iterate and (!!).
13:36:53 <sm> daey: do either  ./counter +RTS -S -RTS input.svg, or  ./counter input.svg  +RTS -S (+RTS stuff at end)
13:37:01 <inkbottle> Hafydd: OK, thanks
13:37:26 <daey> sm: yeah figured it out a sec earlier :^)
13:38:09 <daey> that being said, what am i looking for in this gigantic stack of numbers?
13:38:41 <sm> you might see that it's allocating a really unreasonable amount, which would suggest it's wasting memory
13:38:53 <sm> but moving on: to generate a time & space profile, and how many times things are called, compile it with -prof and run it with +RTS -p
13:38:56 <daey> sm: yeah the memory allocation is 'funny' 562 MB total memory in use (0 MB lost due to fragmentation)
13:39:32 <EvanR> daey: i am pretty sure its the use of String here
13:39:39 <sm> I will tell you that it's recompiling the regexp every time, which is slow - you could compile that once
13:40:06 <EvanR> large files being processed in a non trivial way is just not going to work out
13:40:06 <daey> msk :: String -> AllTextMatches [] String > you mean that string?
13:40:22 <EvanR> as a linked list of Chars
13:40:47 <daey> so strings and [strings] should be avoided in general?
13:41:20 <dsal> I use String.  It's fine if you don't need performance.
13:41:33 <Hafydd> :t \n -> ((!! n) .) . iterate
13:41:35 <lambdabot> Int -> (c -> c) -> c -> c
13:41:56 <Hafydd> Maybe it would be preferable to have a separate name, if you want exactly that.
13:42:48 <daey> sm: how can i avoid the regex recompilation?
13:43:09 <Hafydd> :t \n f x -> iterate f x !! n -- This is the more natural way to write it.
13:43:12 <lambdabot> Int -> (a -> a) -> a -> a
13:43:30 <sm> daey: actually don't believe me, believe what your profile tells you
13:43:46 <daey> oh, i totally believe you :D
13:44:33 <sm> I'm trying to follow my own advice and actually measure. I think my first profile was no good
13:44:47 <sm> the point is, the real answer is to measure
13:45:39 <pikajude> "the nth f of x"
13:46:07 <inkbottle> Hafydd: I'm still trying to write my own version with the operators you suggested
13:50:33 <inkbottle> Hafydd: I wrote that: \f n x -> (iterate f x) !! n
13:50:50 <inkbottle> same as yours
13:50:54 <Hafydd> @pl \f n x -> (iterate f x) !! n
13:50:54 <lambdabot> flip . ((!!) .) . iterate
13:51:31 <sm> daey: also #haskell likes debugging performance in small reproducible programs. Yours is small, +1, but it's not clear to me how to reproduce "terribly slow"
13:51:48 <inkbottle> Hafydd: What did you do here?
13:52:12 <Hafydd> inkbottle: I used lambdabot's facility to obtain a point-free version of a function definition.
13:52:20 <inkbottle> OK
13:52:34 <Hafydd> inkbottle: it's probably not that useful in this case, but may be interesting to note.
13:53:09 <inkbottle> Hafydd: I like it; was that the @pl thing?
13:53:32 <Hafydd> inkbottle: yes. "@pl" stands for "pointless", as some overly opinionated people like to call it.
13:53:51 <inkbottle> OK
13:54:01 <sm> I ran it on a large svg file.. enough ? But I still see only 0 or 1 entries in the profile.
13:54:23 * sm figuring out if he can quickly profile a haskell program yet
13:54:58 <daey> sm: im running it on a 14mb svg file
13:55:10 <sm> ok, I tried a 2mb
13:55:42 <sm> well, time up for me - somebody else ?
13:55:51 <inkbottle> Hafydd: pointless but awesome
13:55:59 <EvanR> Hafydd: i resemble that remark
13:56:28 <inkbottle> I can't have that im my REPL?
13:56:48 <Hafydd> Not without modifying it, AFAIK.
13:56:54 <inkbottle> OK
13:57:13 <daey> sm: the reason im using String is that 'getAllTextMatches' returns [] String, which i cant change as its the external regex function. (at least thats my logic)
13:57:18 <Hafydd> But you can use it by PM with lambdabot on freenode, at least, or run lambdabot yourself.
13:57:19 * sm also would like to know why cabal install --enable-profiling regex-posix gives compilation errors, and stack install --profile regex-posix doesn't, both installing 0.95.2
13:58:09 <daey> the cmbn function is definitely not the problem. i removed it, and the program still needs roughly the same amount of time.
14:02:08 <dsal> daey: The profiler should tell you that.  Mainly, it's just unnecessary code since it does approximately what zip does.
14:02:25 <dsal> My rule of thumb is to never ask a human which of two things a computer will do faster, though.  :)
14:02:41 <zenspider> damn good rule
14:03:10 <daey> dsal: my problem is, i dont understand any of that: http://lpaste.net/359658http://lpaste.net/359658 :P
14:03:46 <dsal> Heh.  I'm not sure what that is.  That doesn't look like profiler output to me.  :)
14:04:22 <daey> thats what i get when i run './counter +RTS -S -RTS dummy_drawing.svg'
14:05:10 <daey> heres the end of the output http://lpaste.net/359659
14:05:24 * sm correction: should have said +RTS -s, not +RTS -S
14:06:47 <sm> do the profiling thing daey, it will tell you more
14:17:22 <daey> regarding the profiling. i compiled the program with 'ghc -rtsopts -fprof-auto counter.hs' and running with './counter +RTS -p -RTS dummy_drawing.svg'.  Which doesn't seem to work
14:17:42 <daey> i've read that i might have to reinstall external packages due to the profiling feature
14:17:58 <daey> is that still true? the post was older
14:18:24 <dsal> I've only done it with stack. :/
14:23:32 <reptar_> i'm trying to resize a calculator gui with gtk, but the buttons won't get bigger
14:23:42 <reptar_> buttons are in a grid
14:24:04 <reptar_> they resize automatically in vertical direction, but not horizontal
14:24:46 <sm> daey: it's "ghc -prof -fprof-auto counter.hs" (I think the -rtsopts is implied by -prof)
14:25:47 <sm> and yes, this will fail if you haven't got all the deps profiling libs installed. "stack install --profile regex-posix" worked for me
14:29:08 <foojin> I have a shell script which uses curl to download files and I'm writing a simplified version in Haskell using Wreq.
14:29:11 <foojin> The server often closes the connection when a certain amount of data is transferred (curl: (18) transfer closed with 42288 bytes remaining to read). I can then use "curl -C -" to continue.
14:29:18 <foojin> When invoked with the same URL, Wreq throws Error_Packet with no partial result. How do I get it to retrieve the bytestring in several requests?
14:32:21 <sm> I'm guessing the wreq package doesn't provide that
14:34:41 <foojin> The only thing I can think of is to use HEAD to get the length, some header magic to GET it chunk by chunk and then concatenate.
14:41:32 <foojin> sm: The exception comes from a lower level (it's defined in Network.TLS) and it merely wraps a human-readable string, so I'm wondering how low-level is it going to get.
14:45:04 <sm> foojin: I don't know how you do ranged GET with HTTP, I guess you set some request header in the Options parameter. You could trace curl's requests..
14:45:50 <sm> http://httpwg.org/specs/rfc7233.html
14:46:50 <btqr> If I want to pass a list to a function that takes a certain number of paramters, say 3, is there anything wrong with defining a function like this? "f (a : b : c : _) = ...
14:47:01 <sm> warning: right after you finish debugging this, you will probably find an easy lib on hackage that does it. You won't be able to find it until then. :)
14:48:07 <ski> btqr : `f' will also accept any list with more elements
14:52:39 <sm> foojin: there's also http://hackage.haskell.org/package/download-curl :)
14:52:45 <btqr> ski : If I'm fine with ignoring the additional values is there anything else? it seems  very cumbersome to access the values with (!!)
14:53:27 <sm> btqr: f (a:b:c:[]) 
14:53:52 <sm> and f _ = ..handle bad call..
14:54:46 <btqr> sm : thanks!
14:54:55 <sm> but consider taking a tuple instead ? f (a,b,c) = ...
14:55:30 <cement> that looks like a function that looks at what getArgs gives back?
14:59:43 <foojin> sm: Thanks, I'll try doing it with ranges to see if it works. Going with curl would likely mean writing more code, but it's good to know it's an option.
15:01:20 <sm> foojin: no problem. Hard to see how reimplementing curl's resume-download in your script will make it shorter, but I have not tried the lib in question so ..
15:10:41 <Johulk> Hello guys! I need help doing a function that grabs 2 strings and returns a bool checking if the first string is lower on the lexical (?) order than the second string
15:10:46 <Johulk> I have no idea where to start
15:10:53 <Johulk> after defining the type
15:12:40 <iqubic> Johulk: Try using ord.
15:12:40 <Johulk> I have no idea if haskell has a function to separate a string into various Chars
15:12:48 <Johulk> I did
15:13:22 <Johulk> Let me paste the error
15:13:41 <erisco> String is exactly a list of Chars, so is that separated to you?
15:13:56 <Johulk> http://lpaste.net/359661
15:14:12 <iqubic> Johulk: Just use this: isLower a b = (compare a b) == LT
15:14:33 <iqubic> That returns true if the first string is lower on the lexical ordering.
15:15:03 <iqubic> Johulk: Do you see why that works?
15:15:39 <erisco> it is idiomatic to use  a < b  rather than  compare a b == LT
15:16:11 <Johulk> I had no idea you could "compare" a and b to LT
15:16:15 <Johulk> I dont even know what LT is
15:16:29 <Johulk> Oh nvm
15:16:33 <Johulk> It wont work
15:16:37 <Johulk> I have to do it recursivly
15:16:43 <Johulk> Recurssively*
15:17:07 <iqubic> Johulk: That should work.
15:17:18 <Johulk> is that a reccursive function?
15:17:22 <iqubic> Can you paste your code.
15:17:24 <Johulk> Yea
15:17:40 <Johulk> I mean
15:17:41 <iqubic> Johulk: It uses recursion to do the comparison, but not explicitly.
15:17:42 <Johulk> the code works
15:17:57 <Johulk> it gives true when I give it a test case like it is supposed to give
15:18:07 <Johulk> but it isnt explicitly recurssive
15:18:14 <Johulk> so idk if it is allowed
15:18:43 <iqubic> Johulk: Why do you need recursion?
15:18:57 <Johulk> Gonna be honest, no f. idea
15:18:59 <Johulk> but alas
15:19:04 <Johulk> it's how my exam will be
15:19:11 <Johulk> basicly the teacher gave us 50 questions
15:19:11 <monochrom> If you just write "a<b" it already uses lexicographical ordering.
15:19:18 <monochrom> Here is an example:
15:19:25 <Johulk> in the exam we are given 2 out of those 50 to do at random
15:19:26 <monochrom> > "abc" < "abcd"
15:19:29 <lambdabot>  True
15:19:41 <Johulk> (I can get #2 and #6, you can get #35 and #47)
15:19:43 <monochrom> Perhaps this one too:
15:19:50 <monochrom> > "abc" < "bad"
15:19:52 <lambdabot>  True
15:19:57 <Johulk> but the teacher gives us the 50 questions prior
15:20:15 <Johulk> so what I'm doing is doing all 50 questions
15:21:18 <Johulk> The question asks explicitly for a reccursive implementation of isLower
15:21:36 <Johulk> so I'm not sure something like "compare a b" would do
15:21:37 <monochrom> OK but I saw no recursion in your code.
15:22:12 <monochrom> And you only showed "menor'" not "isLower".
15:23:09 <monochrom> But tl;dr so-called "string" in Haskell is [Char] and so if you know how to do pattern matching on [Anything] you have enough tools.
15:23:09 <Johulk> menor is portuguese
15:23:19 <Johulk> for isLower
15:27:51 <Johulk> so yea
15:28:00 <Johulk> I have no idea if that will work exam wise
15:28:03 <Johulk> not code wise
15:28:52 <erisco> lets simplify what you have written already
15:29:01 <erisco> if p then True else False = p
15:29:41 <erisco> ord a < ord b = a < b  I think
15:30:17 <Johulk> I think the way I can make it recursive is to compare each letter in pairs
15:30:20 <Johulk> as in
15:30:22 <erisco> so, menor' a b = a < b  thus  menor' = (<)
15:30:48 <Johulk> the first letter of each string
15:30:51 <erisco> your type error is, I am guessing, that you said in another place that  menor' :: String -> String -> Bool
15:31:02 <Johulk> It's not a type error
15:31:06 <Johulk> I think
15:31:09 <iqubic> Yes it is.
15:31:17 <erisco> but  ord :: Char -> Int
15:31:26 <Johulk> yea, not [Char]
15:32:21 <erisco> if you want an explicitly recursive solution then give it a go
15:32:53 <Johulk> if I state that a string being a list , ("a" : b) would lock the first element just to the letter a right?
15:32:57 <Johulk> and not any letter 
15:33:05 <Johulk> because I can't use "_" to compare
15:33:06 <monochrom> Right.
15:33:22 <monochrom> And it's 'a':b, not "a":b.
15:33:32 <monochrom> But why hardcode the letter 'a' anyway?
15:33:41 <Johulk> its not meant to be hard coded
15:33:55 <monochrom> I'm a bit surprised that you haven't thought of the most obvious a:b
15:34:07 <Johulk> that works..?
15:34:09 <Johulk> ._.
15:34:21 <Johulk> I'm dumb
15:34:24 <Johulk> let me give that a go
15:34:46 <Hafydd> "a:b" is bad style. Consider "c:cs" instead.
15:34:55 <monochrom> It is a mystery to be why in the same pattern you think that one part can be variable but another part has to be a constant.
15:35:33 <erisco> the constructor must be constant
15:35:46 <erisco> might be fun if otherwise
15:36:07 <monochrom> I know that, erisco.
15:36:15 <erisco> I know you know that
15:36:51 <iqubic> How would that work?
15:36:59 <monochrom> It wouldn't.
15:37:20 <erisco> it would have implications in the type system
15:37:49 <Johulk> http://lpaste.net/359662
15:38:31 <monochrom> You have to make up your mind whether you want to call it c or you want to call it a.
15:38:42 <monochrom> Also you don't need ord.
15:38:44 <glguy> Johulk: Are you asking what the words "Variable not in scope" mean?
15:38:47 <Johulk> oh lol
15:38:55 <Johulk> I forgot to change it
15:39:34 <Johulk> IT WORKS
15:39:35 <Johulk> :D
15:39:40 <glguy> It's also wrong
15:40:02 <Johulk> Ehh?
15:40:04 <Johulk> Its working
15:40:07 <Johulk> how could it be wrong
15:40:16 <erisco> maybe let them go
15:40:21 <erisco> let the prof inform them
15:40:25 <glguy> Oh, OK.
15:41:18 <ratherAnonymous[> O . o
15:41:24 <ratherAnonymous[> Lisp?
15:46:22 <Johulk> Okay
15:46:23 <Johulk> Another one
15:46:28 <Johulk> now it MSets´
15:46:40 <Johulk> actually, ncm
15:46:41 <Johulk> nvm
15:46:44 <Johulk> Ima try to fix it on my own
15:48:19 <Johulk> I mean. It.. "works" just backwards ._.
15:48:28 <Johulk> http://lpaste.net/359663
15:49:08 <Johulk> constroiMSet "aaabccc" would be [('a',3),('b',1),('c',3)]
15:49:38 <Johulk> it's giving me [('c',3),('b',1),('a',3)]
15:51:14 <erisco> does it have to be explicitly recursive?
15:51:19 <ski> reverse at the end ? or let `insereMSet' insert at the start, if not present already ?
15:51:43 <Johulk> These ones do not
15:51:56 <erisco> investigate the  group  function then
15:52:51 <Johulk> Wierd.
15:53:00 <Johulk> reverse works for 3 elements
15:53:01 <Johulk> not for 4
15:53:09 <Johulk> if I add a "ddd" at the end
15:53:39 <Johulk> it does d,3 c,3 b,1 a,3
15:53:41 <Johulk> if I reverse
15:53:44 <Johulk> its a,c,d,b
15:55:31 <ski> did you add a *single* reverse ?
15:55:40 <Johulk> Yes
15:55:56 <Johulk> reverse( insereMSet a (constroiMSet as))~
15:59:25 <Johulk> ehehehehe
15:59:26 <Johulk> I fixed it
15:59:32 <Johulk> added a sort
15:59:38 <Johulk> TIL that works
16:00:16 <erisco> I am getting the impression that you are trying things randomly until something gives the appearance of working
16:00:56 <ski> Johulk : looks like you added the `reverse' into the recursive case of `constroiMSet', making it happen always, *except* at "the end" (the base cases) -- not what i'd call a *single* reverse
16:01:22 <Johulk> erisco: Pretty much, yes.
16:01:26 <Johulk> But not at random
16:01:49 <erisco> how did you determine that adding a sort works?
16:02:03 <erisco> and how did you think that adding a sort might work?
16:02:20 <Johulk> My train of thought was "well, the only thing is that the letters arent ordered. I just used ord before, so letters have a order, so I can sort the letters, which supposedly haskell already does and follows the alphabet"
16:02:23 <Johulk> so
16:02:25 <Johulk> a,b,c,d
16:02:30 <Johulk> no longer a,c,b,d
16:02:52 <erisco> does the question say that the letters will be in lexicographic order?
16:03:46 <Hafydd> "Lexicographic order" for scalar values is an interesting idea.
16:04:45 <erisco> Hafydd, when 2 comes after 10
16:04:53 <Johulk> no, but the example states that aaabccc returns a,b,c
16:05:13 <Johulk> Last problem I think
16:05:21 <Johulk> doing a recursive of \\
16:05:26 <erisco> what does that mean? are you saying with input "aabccc" the output is "abc", or what?
16:05:31 <Hafydd> erisco: I wasn't aware that "10" was a letter.
16:05:31 <Johulk> No
16:06:16 <Johulk> imput "aaabccc" is supposed to give the [['a,3],... ] etc
16:06:26 <erisco> try again, that is a type error
16:06:43 <Johulk> I already got it to work
16:06:45 <Johulk> with sort
16:07:03 <erisco> how did you determine it works?
16:07:08 <Johulk> I added sort
16:07:20 <Johulk> and under the same imput, aaabccc
16:07:34 <Johulk> before sort would be the c 3, b 1, a3
16:07:47 <Johulk> with sort it became a3 b1 c3
16:07:49 <erisco> does the question say that is the only input or is that merely an example of one of the possible inputs?
16:07:56 <Johulk> example
16:07:57 <erisco> if the latter, how did you determine your solution works for all inputs?
16:08:11 <Johulk> Faith
16:08:27 <erisco> if only faith could change reality
16:08:34 <Johulk> Well
16:08:38 <Johulk> adding random letters works
16:08:49 <Johulk> I just did "aaabcccdddaac" and it returned correctly
16:08:59 <erisco> and what did that return?
16:09:11 <Johulk> a 5, b 1, c 4, d 3
16:09:19 <erisco> what does the question say that should return?
16:09:37 <Johulk> the question does not pose that example
16:09:42 <Johulk> its a random imput
16:09:44 <Johulk> on the same vien
16:09:46 <Johulk> vein
16:09:48 <erisco> post the question, I want to read it
16:09:56 <Johulk> Its in portuguese
16:10:00 <Johulk> but okay
16:10:05 <Johulk> nothing google wont help with
16:10:51 <Johulk> http://lpaste.net/359664
16:12:07 <erisco> based on the question, I don't know why you care about the order of the 2-tuples in the list
16:14:49 <erisco> do you know what a set is?
16:15:46 <Johulk> Isn't it a way to store multiple chars , for example 'a' and the times they are repeated?
16:15:52 <Johulk> in a certain string
16:16:21 <erisco> a set is a mathematical object which you can learn about by studying set theory
16:17:58 <erisco> but, without going deep on that, lets say a set is a collection of objects. An example is  {A, B, C}  for a set of three objects A, B, and C
16:17:58 <fishythefish> by default, "set" means "unordered set", so the order of pairs in the output shouldn't matter
16:18:21 <erisco> there is the property that the order of elements in the set are irrelevant, so  {A, B, C}  is the same set as  {B, A, C}
16:18:40 <Johulk> I see
16:18:54 <erisco> also, repetitions of the same element are unimportant, so  {A, B, C}  is the same set as  {A, A, B, C}
16:19:18 <fishythefish> erisco: mmm, that last point doesn't apply here
16:19:36 <erisco> yes it does, it says so in the question
16:19:39 <Johulk> http://lpaste.net/359665  gives me non-exaustive patterns when running the imput
16:19:52 <fishythefish> the problem says we're representing a multi-set, and no two pairs have a coinciding first component
16:20:02 <erisco> multisets are sets
16:20:09 <Johulk> and no second component is less or equal to 0
16:20:11 <merkilsa> Can anyone write a script that is able to brute-force 502125100290 + xxxx xxx 
16:20:13 <fishythefish> mathematically, yes
16:20:13 <merkilsa> So the first few numbers are constants and the last x's are unknowns that need to be bruteforced
16:20:15 <merkilsa> There s also a 4 digit pin
16:20:21 <fishythefish> but i'm talking about the constraints the problem explicitly puts on the representation
16:20:42 <daey> i can only come to one conclusion. the getAllTextMatches implementation of haskell sucks
16:21:04 <erisco> the character of a multiset is described by the question
16:21:35 <erisco> the idea is that, because repetitions of elements are not recognised by sets, we can use a multiset to count elements
16:21:56 <erisco> so  {(A, 3), (B, 1), (C, 2)}  is like saying we have 3 A's, 1 B, and 2 C's
16:22:04 <fishythefish> I understand
16:22:05 <daey> http://lpaste.net/359666 theres no way im making a mistake here. *hopefully*
16:22:15 <erisco> I am speaking to Johulk
16:22:20 <fishythefish> i'm saying the statement "repetitions of the same element are unimportant" is false here
16:22:32 <Johulk> I see
16:22:35 <erisco> it is not false, but I am going to help Johulk first
16:23:12 <erisco> now, sets are mathematical objects, and we have various choices of how to give them a representation on computers
16:24:02 <erisco> one such way is to use a Haskell list, which is not itself exactly like a set, but if we add some rules to how we use the list then we can treat it like a set
16:24:37 <erisco> for example,  [A,B,C]  must be the same as  [B,A,C]  if we are treating the list as a set
16:24:46 <erisco> and  [A,A,B,C]  must be the same as  [A,B,C]
16:25:33 <Johulk> ahh
16:25:36 <Johulk> so order wouldnt matter
16:25:39 <Johulk> but oh well
16:25:39 <erisco> so, because the question asks us to compute a multiset, it does not matter if we answer  [A,B,C]  or if we answer  [C,B,A]  or any other order
16:25:42 <Johulk> better be safe than sorry
16:26:02 <Johulk> Okay
16:26:04 <Johulk> Heres another
16:26:19 <erisco> I'd balk at that concept, but I've had profs where I might take similar precautions -.-
16:27:06 <erisco> fishythefish, it is not false because if we treat lists as sets then  [A,A,B,C]  must be the same as  [A,B,C]
16:27:09 <Johulk> http://lpaste.net/359667
16:27:28 <fishythefish> i agree
16:27:32 <fishythefish> except we're talking about multisets here
16:27:37 <Johulk> The function is supposed to be the same as the \\ operator
16:27:44 <erisco> the same applies to multisets... I'll say again that multisets are sets
16:27:47 <fishythefish> no
16:27:49 <fishythefish> sets are multisets
16:27:50 <erisco> yes
16:27:53 <fishythefish> a multiset is a generalization
16:27:59 <Johulk> where it extracts the first appearance of any element of the second list on the first list
16:28:06 <fishythefish> a multiset is a set only in the same way everything in math can be expressed as a set
16:28:23 <Johulk> so [1,2,3,1] [1,2] would be equal to [3,1]
16:28:37 <Johulk> or 
16:28:53 <Johulk> [1,2,3,4,5,1] [5,1] would be [2,3,4,1]
16:29:11 <Johulk> Any idea?
16:29:24 <erisco> fishythefish, fine, you are arguing a finer point than I anticipated
16:29:32 <fishythefish> erisco: the problem explicitly states that no two pairs may have a common first element
16:29:36 <fishythefish> if you want a more pragmatic reason
16:29:57 <fishythefish> so the semantics are decidedly different from that of a simple set
16:30:24 <erisco> a common realisation of multisets is as a set, so that is an assumption I was making
16:30:51 <erisco> it is possible to have other implementations, no argument
16:31:15 <erisco> if we say a multiset is a set and then we use lists as sets, then what I said applies
16:31:17 <fishythefish> Johulk: your barraDupla function doesn't handle all possible input cases
16:31:40 <Johulk> Which cases would I be missing?
16:31:48 * JuanDaugherty was wondering if there had been any implementations surviving current of child's extended sets
16:32:04 <Johulk> I already compared a to b and c
16:32:16 <fishythefish> your first two lines handle the cases where either argument is empty
16:32:33 <fishythefish> your last line handles the case where the first argument has length >= 1 and the second has length >= 2
16:32:37 <fishythefish> what if they have lengths 1 and 1?
16:32:43 <Johulk> Ohh
16:32:44 <Johulk> I see
16:32:50 <Johulk> Lets see if that fixes it.
16:33:07 <erisco> fishythefish, I interpreted the question as merely clarifying the character of a multiset as a set
16:33:43 <Johulk> Nope, same result
16:34:13 <Johulk> Any more ideas?
16:34:14 <Johulk> xD
16:34:24 <fishythefish> Johulk: not saying that fixes your logic, just your warning about not handling all patterns
16:34:25 <jle`> Johulk: upload your new code :)
16:34:32 <Johulk> Alright
16:34:45 <erisco> fishythefish, and maybe what you were not considering is that I am saying [A,A] is the same as [A], not that [(A,1),(A,2)] is the same as anything
16:35:08 <Johulk> http://lpaste.net/359667
16:35:11 <fishythefish> erisco: so there are two transformations here: multiset -> set, and set -> list
16:35:26 <fishythefish> multiset -> set is the straightforward one of grouping equal elements and tagging them with their count
16:35:53 <fishythefish> if i understand you correctly, you're trying to point out that there are multiple possible set -> list transformations because we can freely repeat elements in a set
16:36:19 <fishythefish> i'm saying that the problem does place a restriction on how this transformation can work
16:36:39 * JuanDaugherty ( http://thoughtcrime.biz/pub/ExtendedSets.pdf )
16:36:43 <erisco> I don't know what is being said anymore, so lets move on
16:36:46 <Johulk> is there a "or" for if statements without it being a bool?
16:37:02 <Johulk> so I can state the or after it is compared so I can remove b or c?
16:37:10 <fishythefish> what type would "or" apply to, if not Bool?
16:37:34 <Johulk> well, in this case for the definition
16:38:33 <Johulk> if (a == b) then recursive without b or if (a==c) then recursive without c
16:39:43 <Johulk> because
16:39:47 <Johulk> if I do the code like this
16:40:03 <fishythefish> that's what would normally be expressed with multiple if/then/elses in other languages
16:40:03 <Johulk> http://lpaste.net/359667
16:40:08 <fishythefish> guards would be more appropriate here
16:40:19 <Johulk> then I get an error for non-exaustive patterns
16:40:51 <fishythefish> that's because you still haven't handled the general case of your second argument having length 1
16:41:33 <Johulk> its on top of it
16:41:38 <Johulk> [a] [b]
16:41:45 <fishythefish> no, that handles the case of both arguments having length 1
16:42:05 <Johulk> OH
16:42:08 <Johulk> Thanks
16:45:07 <Johulk> Now it gives an error while compiling
16:45:38 <Johulk> http://lpaste.net/359667
16:45:49 <fishythefish> you probably mean [b], not (b)
16:46:36 <Johulk> Oh
16:46:40 <Johulk> ._.
16:46:46 <Johulk> I swear these dumb mistakes will give me a 0
16:46:58 <Johulk> well
16:47:05 <Johulk> now it dun goofed
16:47:20 <Johulk> barraDupla [1,2,3,4,5,1] [1,5] -> [1]
16:47:22 <Johulk> ._.
16:48:11 <fishythefish> first, i'm gonna advise you clean up your code and eliminate redundant cases before trying to assess the overall logic
16:48:50 <fishythefish> next, trying manually evaluating that expression per the code you've written
16:52:22 <Johulk> WOO
16:52:24 <Johulk> It works
16:52:26 <Johulk> Thanks
16:52:31 <Johulk> That manual thing really helped
16:52:41 <Johulk> I noticed I was throwing out the a's after comparing them
16:52:45 <Johulk> even if they werent equal
16:52:47 <Johulk> thanks ;D
16:56:04 <Johulk> Well guys
16:56:07 <Johulk> Thanks :D
16:56:14 <Johulk> Lets hope I get the question right
16:56:20 <Johulk> if I do I'll be back here more often
16:56:29 <Johulk> if I fuck up I'll be here next year
16:58:12 <Johulk> Thanks everyone!
16:59:05 <johnw> k
16:59:10 <johnw> sorry, wrong window :)
17:04:22 <huda[m]> I would like to define a Map monadically (as opposed to using fromList), but I can't seem to access the Map data constructor (Data.Map.Lazy.Map).
17:04:37 <johnw> Maps aren't monadic
17:04:41 <jle`> what does it mean to define a map monadically
17:04:57 <mauke> Map has no public constructors
17:05:11 <johnw> even if the constructors were available, just try to define return
17:05:15 <huda[m]> Using do notation.
17:05:34 <jle`> huda[m]: define a map using do notation?
17:05:41 <jle`> myMap = do (M.fromList [1,2,3]) ?
17:05:49 <jle`> > myMap = do M.fromList [1,2,3]
17:05:50 <ski> > do return (M.singleton () ()) :: [M.Map () ()]
17:05:52 <lambdabot>  <hint>:1:7: error:
17:05:52 <lambdabot>      parse error on input ‘=’
17:05:52 <lambdabot>      Perhaps you need a 'let' in a 'do' block?
17:05:53 <lambdabot>  [fromList [((),())]]
17:08:24 <jle`> > let myMap = do M.fromList [1,2,3] in myMap
17:08:27 <lambdabot>  error:
17:08:27 <lambdabot>      • No instance for (Num ((), ())) arising from a use of ‘e_1123’
17:08:27 <lambdabot>      • In the expression: e_1123
17:09:05 <jle`> > let myMap = do M.fromList [('a',1),('b',2)] in myMap
17:09:08 <lambdabot>  fromList [('a',1),('b',2)]
17:10:40 <huda[m]> Hmm, I think I was quite a bit off base thinking of monads first. I'm just trying to figure out how to define a Map without fromList
17:10:52 <johnw> huda[m]: with a fold
17:11:10 <jle`> huda[m]: check out the functions in the Data.Map module
17:11:16 <jle`> and see the ones that return a Map
17:11:37 <jle`> https://hackage.haskell.org/package/containers-0.5.10.2/docs/Data-Map-Lazy.html
17:11:55 <johnw> huda[m]: note that using a fold vs. generating a list and then using fromList, might end up being optimized to the same thing
17:12:09 <jle`> Map is what we call an abstract data type
17:12:44 <jle`> it models some mathematical ideal of a data structure, and we're supposed to use its public API to work with that ideal
17:13:27 <jle`> its internal implementation isn't meant to be used, or even be meaningful
17:13:55 <jle`> if you want to create a Map, think about the Map you want to make, and then use the functions in its public API (the Data.Map module) to make it :)
17:14:22 <ski> > M.union (M.singleton 3 "three") (M.singleton 2 "two")
17:14:25 <lambdabot>  fromList [(2,"two"),(3,"three")]
17:14:57 <jle`> > M.unions [M.singleton 3 "three", M.singleton 2 "two"]
17:15:01 <lambdabot>  fromList [(2,"two"),(3,"three")]
17:16:32 <huda[m]> I'll keep digging through the Data.Map docs. Thanks!
17:18:05 <ski> > tabulateMap [0 .. 9] (\n -> n * (n+1) `div` 2)
17:18:09 <lambdabot>  fromList [(0,0),(1,1),(2,3),(3,6),(4,10),(5,15),(6,21),(7,28),(8,36),(9,45)]
17:22:02 <merkilsa> Hey how would you go about writing a script that is able to brute-force 502125100290 + xxxx xxx
17:22:10 <merkilsa> So the first few numbers are constants and the last x's are unknowns that need to be bruteforced
17:22:17 <merkilsa> Number: 502125100290 + xxxx xxx
17:22:35 <merkilsa> Pin is: xxxx
17:22:42 <merkilsa> https://i.imgur.com/eB0RWmS.png
17:22:47 <merkilsa> Basically bruteforce a fake login form
17:22:55 <merkilsa> Thats just an example
17:23:54 <mauke> with a loop?
17:25:09 <merkilsa> mauke: Can you show me the loop or pseudocode?
17:25:32 <merkilsa> There is no bruteforce protection in place either
17:25:36 <merkilsa> unlimited tries
17:27:11 <mauke> how much Haskell do you know?
17:32:16 <nshepperd> (confused #haskell for #hacking?)
17:32:53 <hpc> yeah, i find it hard to imagine that this question is above board
17:33:02 <mud> They seem to just be asking everywhere. They're in at least 2 other channels I'm in, asking the same thing, and I'm not in that many.
17:33:14 <mud> Which adds to the sketchy factor.
17:33:30 <johnw> very much so
17:39:59 <jmcarthur> > liftA2 (,) (map ("502125100290"++) (replicateM 7 ['0'..'9'])) (replicateM 4 ['0'..'9'])
17:40:02 <lambdabot>  [("5021251002900000000","0000"),("5021251002900000000","0001"),("50212510029...
17:40:09 <jmcarthur> Thought I might try to be helpful. :)
17:41:22 <Tuplanolla> @where cpdt
17:41:22 <lambdabot> "Certified Programming with Dependent Types" by Adam Chlipala (aka Smerdyakov) (in progress) at <http://adam.chlipala.net/cpdt/>, "about practical engineering with the Coq proof assistant"
17:41:53 <Tuplanolla> It's very easy, merkilsa. If you want to become a hacker, all you need to do is read and understand this book. Good luck!
18:01:24 <merkilsa> <jmcarthur> Is that just showing the possible combinations?
18:03:26 <merkilsa> > liftA2 (,) (map ("502125100290"++) (replicateM 7 ['0'..'9'])) (replicateM 4 ['0'..'9'])
18:03:28 <lambdabot>  [("5021251002900000000","0000"),("5021251002900000000","0001"),("50212510029...
18:29:37 <halogenandtoast> Is there any way to make something like this work: https://gist.github.com/halogenandtoast/c54a17286e674cb0ea679b47f473028b
18:29:58 <halogenandtoast> Currently some variables like `loginEnctype` are out of scope
18:41:49 <lyxia> halogenandtoast: where would you like it to be in scope?
18:42:15 <halogenandtoast> in the renderHome function
18:42:24 <halogenandtoast> Just trying to extract the duplicated behavior
18:43:00 <halogenandtoast> It's really just a simple example (the real logic would probably be different in this case, but I have others where I want to render the same thing given multiple branches)
18:46:15 <lyxia> Do you have a working example that you are trying to deduplicate?
18:46:43 <halogenandtoast> Like a whole Yesod application?
18:47:10 <halogenandtoast> I don't currently have something smaller.
18:47:29 <halogenandtoast> but it's basically a lexical scope problem
18:47:36 <halogenandtoast> So I guess I could make something quickly
18:47:40 <lyxia> I just don't understand what you're trying to do here
18:48:01 <lyxia> make renderHome a function?
18:48:38 <halogenandtoast> it's this
18:48:38 <halogenandtoast> {-# INLINE doThing #-}; doThing = print x; main = let x = 5 in doThing
18:48:57 <halogenandtoast> x is not in lexical scope in doThing
18:49:00 <lyxia> doThing x = print x
18:50:15 <halogenandtoast> Yes that is an option, it wasn't what I was looking for in this situation
18:51:00 <halogenandtoast> but I appreciate the attempt
18:52:21 <geekosaur> move renderHome into a let inside of postSessionR after the names are bound
18:55:34 <halogenandtoast> geekosaur: thanks, that works
18:55:39 <halogenandtoast> and makes sense
18:57:15 <monochrom> lyxia: I'm wonder if the splice made by $(widgetFile "homepage") contains code that refers to loginEnctype but the way it creates such a variable name messes up.
18:57:58 <monochrom> Actually who am I kidding? If this splice is outside postSessionR, then it has to mess up.
18:57:58 <geekosaur> even via TH it would not be in scope as originally written
18:58:13 <monochrom> Yeah.
18:59:19 <monochrom> The good old days of dynamic scoping!
19:01:25 <halogenandtoast> monochrom, geekosaur I was hoping inlining it would unroll the code during the lexical shceck
19:01:46 <halogenandtoast> I started looking into specifying the phase for inlining, but I think that happens afterwards as well
19:02:06 <halogenandtoast> e.g. {-# INLINE[0] renderHome #-}
19:03:26 <geekosaur> even then you might well want scoping, so now you'd need to invent a way to expose only some bindings
19:03:41 <geekosaur> or you are looking for textual macros
19:03:55 <halogenandtoast> Probably textual macros
19:04:16 <geekosaur> (or as hinted, dynamic scoping --- but that's a lovely way to go wrong unexpectedly)
19:05:44 <halogenandtoast> I think the let is fine for now
19:06:46 <geekosaur> and more to the point, there is no guarantee as written that you won't decide to using that binding in a place where thiose bindings are not in scope; there would need to be a new kind of declaration (or pragma) indicating that additional type information
19:07:02 <geekosaur> at which point they might as well just be normal parameters
19:07:21 <geekosaur> (indeed, that's actually already supported: implicit parameters)
19:09:02 <geekosaur> but I bet you can't easily get at them from Yesod splices, and I'm not sure if you can get at them readily from TH at all
19:12:43 <codygman_> I was considering using the Earley parser, So I look up it's reverse dependencies. How is a little put off by a comment I saw for a lua parser using it: 'This parser works but is extremely slow and memory-intensive." - https://github.com/mitchellwrosen/language-lua2/blob/master/README.md
19:12:44 <codygman_> Does earley have it bad or unpredictable performance?
19:12:44 <halogenandtoast> Yeah I was just looking for a way to mitigate as much duplication as possible.
19:16:13 <geekosaur> anyway, presuming you don't need to get at it from inside the splice, you could hve done it with implicit params, just precede each use of the bindings --- including in the let that binds them --- with ?
19:17:17 <geekosaur> for splices it's harder because, even if it's possible (likely it is but I don't know how offhand; I am no TH expert), you'd need a different AST node to access an implicit parameter and yesod is probably not set up to generate those
19:18:07 <geekosaur> oh, and the type signature includes the binding *in the context*: foo :: (?name :: Its Type Here, ...) => ...
19:18:34 <geekosaur> which is heavier weightt han just passing it as a parameter, which si why implicit params aren't often used
20:31:01 <dink_> @1+1
20:31:01 <lambdabot> Unknown command, try @list
20:31:16 <dink_> @ (+) 1 1
20:31:37 <geekosaur> it's @run or "> " prefix
20:31:50 <dink_> > (+) 1 1
20:31:53 <lambdabot>  2
20:32:01 <dink_> Huzzah
20:32:02 <dink_> !
20:32:54 <dink_> > pl \a b c -> (a b) (a c)
20:32:57 <lambdabot>  <hint>:1:4: error: parse error on input ‘\’
20:33:23 <dink_> > pl \v1 v2 -> sum (zipWith (*) v1 v2)
20:33:25 <lambdabot>  <hint>:1:4: error: parse error on input ‘\’
20:33:30 <Welkin> fuzzy wuzzy
20:33:33 <dink_> > pl \\v1 v2 -> sum (zipWith (*) v1 v2)
20:33:34 <Cale> @pl \a b c -> (a b) (a c)
20:33:34 <lambdabot> flip =<< ((.) .)
20:33:35 <lambdabot>  <hint>:1:12: error: parse error on input ‘->’
20:33:54 <Welkin> @pl ((.) .)
20:33:55 <lambdabot> ((.) .)
20:33:56 <Welkin> lol
20:34:00 <Cale> pl isn't a Haskell function, it's a lambdabot command
20:34:05 <Welkin> @pl (.).(.)
20:34:05 <lambdabot> (.) . (.)
20:34:08 <Welkin> I know
20:34:16 <Welkin> oh, you were talking to dink_ 
20:34:19 <Cale> There's nothing to points-free there, you need a lambda :)
20:34:33 <Welkin> Cale: I wanted to see if lambdabot changed anything
20:34:39 <dink_> Ah. Trying to read this transcript in the wiki.
20:34:55 <geekosaur> more precisely, you need to specify the points to be removed; to pl, everything not built-in syntax is a point
20:34:59 <Welkin> "how can you be point-free if you have all these points!?"
20:35:36 <dink_> What I was really wondering about is how to remove a point that appears in the definition more than once.
20:35:54 <Welkin> through eta reduction
20:35:54 <Cale> dink_: By using the Monad or Applicative instances for (->) e usually
20:36:00 <mauke> @pl \x -> f x (g x)
20:36:01 <Welkin> there is a very good video that explains the process
20:36:01 <lambdabot> ap f g
20:36:03 <dink_> Like I figured out how to do it if it's just there once with a bunch of (.) and flip and whathaveyou.
20:36:08 <Welkin> both for eta reduction and eta substitution
20:36:17 <dink_> Video?
20:36:34 <Welkin> https://www.youtube.com/watch?v=seVSlKazsNk
20:36:41 <Welkin> this is the best video on point-free I have seen
20:36:47 <Welkin> it really helped me understand a lot
20:38:01 <dink_> Off there now; thanks for the help, Cale, Welkin, geekosaur.
22:24:16 <Lokathor> anyone here use gitlab ci with stack?
22:24:54 <jle`> github has ci? :O
22:25:11 <jle`> oh sorry, completely misread
22:25:26 * jle` makes note to checkout gitlab
22:25:55 <Lokathor> gitlab is like github in almost every way, but free private repos and integrated CI instead of travis CI
22:26:44 <Lokathor> i'm just keeping my libs on github and my binary projects on gitlab, since my binaries never end up seeing the light of day anyway
22:33:34 <vimalloc> i really like gitlab ci
22:33:49 <vimalloc> Haven't used it with stack, but use it all the time at my work. it's a breeze
22:33:55 <vimalloc> (python)
22:35:12 <Lokathor> well, i think maybe i picked a docker image that'll work
22:35:21 <Lokathor> but it's taking what i would think is a long time
22:37:06 <MrSkeltal> hey jle`
22:37:19 <MrSkeltal> ever get around to figure out the Generic thing?
22:37:46 <pacak> The Generic thing? O_o
22:38:30 <MrSkeltal> the "thing"
22:40:20 <bsima> if I have a many-to-many relationship like this https://github.com/yesodweb/persistent/blob/master/persistent-test/src/CompositeTest.hs#L60-L72 will persistent automatically populate the CitizenAddress table with the appropriate data?
22:44:18 <jle`> MrSkeltal: um can you remind me? :)
22:45:12 <MrSkeltal> jle`, Generic Finite
22:47:11 <jle`> ah
22:47:18 <jle`> um i think i put down my opinion in the github issue
22:48:54 <jle`> i'm not exactly sure why I put in a Generic instance originally, but whatever reason i gave must have been misguided
22:49:22 <jle`> s/gave/had
22:53:36 <Lokathor> i solved it!
22:53:59 <Lokathor> http://lpaste.net/359675
22:54:30 <jle`> Lokathor: congrats :D
22:59:21 <jchia1> Can I define a function f :: a -> b -> Bool that returns True if i) a & b are the same ii) a (& b) has Eq instance and iii) (==) returns True for the two arguments, and False otherwise?
22:59:56 <jle`> a and b, the type variables?
22:59:56 <MrSkeltal> no
23:00:04 <jchia1> jle`: Yes, type variables.
23:00:07 <MrSkeltal> breaks parametericity
23:00:46 <jle`> yeah that's a pretty textbook case of parametricity breaking, but in practice you can do something with constraints/contects
23:00:56 <jle`> f :: (Typeable a, Typeable b) => a -> b -> Bool
23:01:13 <jle`> basically this is like carrying around a runtime witness for the types of 'a' and 'b'
23:01:54 <geekosaur> doesn't help with the Eq instance, I think
23:01:55 <jchia1> jle`: I'll try that.
23:02:17 <MrSkeltal> suppose 'g :: Proxy a -> Bool; g = f (Proxy :: Proxy ())'
23:02:24 <jle`> oh yeah, you can't get an Eq instance from that
23:02:27 <MrSkeltal> g :: forall a. Proxy a -> Bool
23:02:33 <jle`> f :: (Typeable a, Typeable b, Eq a) => a -> b -> Bool
23:02:40 <MrSkeltal> g should be uniform in a. but it's not
23:02:49 <geekosaur> also fails since they want False if there's no Eq instance
23:02:55 <jchia1> geekosaur: Would it help if I change f to "f :: (Eq a, Eq b) => a -> b -> Bool"?
23:03:15 <geekosaur> no, becuase that says 'must have an Eq instance to typecheck'
23:03:23 <jle`> i think it depends on how you parenthesize jchia1's requests
23:03:43 <jchia1> I know a and b have their Eq instance.
23:03:47 <jle`> it's (  i), ii), iii) ...) and False otherwise
23:03:48 <jchia1> instance(s)
23:04:02 <jle`> or i), ii), (   iii) ... and False otherwise )
23:04:09 <geekosaur> then why did you include iii ?
23:04:11 <geekosaur> hm
23:04:18 <jchia1> all i-iii must be satisfied to return True
23:04:32 <jchia1> iii) is meaningless without i & ii
23:04:48 <MrSkeltal> (Eq a, Typeable a, Typeable b) =>
23:04:49 <MrSkeltal> perhaps
23:05:07 <MrSkeltal> f x y = Just x == cast y
23:05:28 <geekosaur> still gives no way to produce False if there is no Eq instance
23:05:36 <MrSkeltal> shruh
23:05:38 <MrSkeltal> shrug
23:05:52 <MrSkeltal> spice up with IfCxt?
23:06:17 <MrSkeltal> anyway, jchia1, what are you trying to do on a larger scale
23:06:23 <MarcelineVQ> why is this being done? what is the next step after this one is solved?
23:06:28 <MarcelineVQ> oop :>
23:06:43 <MrSkeltal> the fact that you've run into this issue suggests that you're trying to do something wrong
23:07:00 <jchia1> MrSkeltal: Generally, writing some sort of compiler, representing nodes in an expression graph using GADT, and trying to dedupe the nodes to eliminate duplicate expressions.
23:07:25 <jchia1> The (==) is for checking whether two nodes are equivalent.
23:07:36 <MrSkeltal> sounds like a and b would be the exact same type in your case
23:08:04 <MrSkeltal> namely your GADT
23:08:44 <jchia1> MrSkeltal: I have a GADT "Node a), in which there is: Cmp :: (Computable a, Ord a) => Ordering -> a -> a -> Node Bool.
23:09:28 <jchia1> I may end up trying to compare a "Cmp EQ (_ :: Node Int) (_ :: Node Int)" with a "Cmp EQ (_ :: Node Double) (_ :: Node Double)" for equivalence.
23:09:36 <MrSkeltal> well with that definition you can't equate that existentional
23:09:42 <jchia1> Node a is a node that outputs a result of type a.
23:10:02 <MrSkeltal> perhaps if you constraint Cmp with Typeable?
23:10:11 <MrSkeltal> constrain*
23:10:27 <jchia1> MrSkeltal: Yeah, there are details that I didn't mention. Typeable could be a detail I'll have to add.
23:11:33 <jle`> if you're doing a gadt sort of thing then you probably don't have to resort to Typeable
23:11:37 <jle`> you an take advantage of your GADT
23:12:52 <MrSkeltal> jchia1, well it's not salvageable without adding some sort of detail
23:13:36 <MrSkeltal> hmm, relevant question:
23:13:38 <jchia1> jle`: Not sure how, or what I'm doing wrong with the definition. Any thoughts? http://lpaste.net/359676
23:13:57 <MrSkeltal> the precise mathematical definition of "continuity" over a forall comes from the categorical definition of a profunctor end, right?
23:14:26 <jchia1> jle`: OK, Just edited the lpaste to add the Cmp1 & Cmp2.
23:15:03 <jle`> and what do you want to do with those again?
23:15:15 <jchia1> jle`: So, eventually, I need to apply (==) on two "Nl a" values.
23:15:38 <jchia1> See if the two nodes are equivalent and can be merged into one.
23:15:44 <jle`> also what is Computable?
23:16:01 <jchia1> Computable is just the class of result types that the Nodes can compute
23:16:59 <jchia1> jle`: Just added Computable to the lpaste
23:17:49 <MrSkeltal> what methods does Computable have
23:18:07 <jchia1> MrSkeltal: Just added the Computable-related code to the lpaste
23:18:11 <jchia1> No methods
23:18:19 <jchia1> Just packaging multiple constraints
23:19:31 <jle`> jchia1: are those three your only instances?
23:19:38 <MrSkeltal> that would be better off with a type synonym
23:19:43 <jchia1> jle`: Yes
23:20:10 <jchia1> MrSkeltal: How do I replace 'that' with a type synonym?
23:20:13 <MarcelineVQ> happy halloween everybody
23:20:28 <MrSkeltal> type Computable a = (Eq a, Typeable a, Show a)
23:20:36 <jle`> happy halloween MarcelineVQ 
23:20:44 <jchia1> MrSkeltal: OK, good point, I'll do that
23:20:49 <geekosaur> and ConstraintKinds extension, iirc
23:20:54 <jchia1> happy halloween, MarcelineVQ
23:21:12 <MrSkeltal> MarcelineVQ, you'll have good bones and calcium but only if you say thank MrSkeltal in this thread
23:21:28 <jle`> jchia1: if those are your only three instances then you can just use a closed ADT, heh
23:21:39 <jle`> data Computable = CDouble Double | CInt Int | CBool Bool
23:21:39 <jchia1> jle`: What's a closed ADT?
23:21:57 <MrSkeltal> jle`, I was thinking something along the lines of..
23:22:08 <jchia1> jle`: There are two more instances with some custom type.
23:22:10 <jle`> typeclasses are usually a solution for "open" situations
23:22:12 <MrSkeltal> data F f = FDouble (f Double) | ...
23:22:26 <jle`> but here you only have three instances, it's meant to be "closed"
23:22:30 <jle`> so an ADT is probably more suitable
23:22:51 <MarcelineVQ> MrSkeltal: the scariest thing about halloween is the reminder that in each and every one of us is a spoopky skeleton just waiting to get out
23:23:08 <jle`> open as in, you can't enumerate the instances and nobody can add new instances
23:23:26 <jchia1> jle`: Definitely closed for my use case.
23:23:59 <MarcelineVQ> jchia1: have you seen http://conal.net/papers/jfp-saig/compile-dsel.pdf btw?
23:24:13 <jchia1> jle`: What do I do with the "data Computable". E.g. how do I take that to defined the Cmp1 and Cmp2 nodes?
23:24:22 <jle`> well
23:24:35 <geekosaur> for some of us, what the skeleton is supporting is easily spookier >.>
23:25:38 <jle`> is it very bad if you just got rid of Computable a => ... completely, and just use 'Nl a's instead of a's, and have constructors for Bool's and Int's
23:25:49 <jchia1> MarcelineVQ: No, scanning it now
23:25:52 <jle`> jchia1: like how you already have InputDouble
23:26:04 <jle`> why not have InputInt and InputBool, and get rid of naked a's altogether?
23:26:11 <MarcelineVQ> jchia1: hehe scan it later when these guys are done but it should at least have useful leads if it's not completely relevant
23:26:53 <jchia1> jle`: You mean replace things like Cmp1 & Cmp2 with monomorphic versions like Cmp1Int, Cmp1Double, Cmp2Int, Cmp2Double?
23:27:23 <MarcelineVQ> though it is relvant to "writing some sort of compiler, representing nodes ... and trying to dedupe the nodes to eliminate duplicate expressions."
23:27:23 <jle`> no i mean just have only Cmp2, without the constraint
23:27:53 <jchia1> Cmp2 :: Ordering -> ? -> ? -> Nl Bool?
23:28:12 <jle`> Cmp2 :: Nl a -> Nl a -> Nl Bool
23:28:23 <jle`> er sorry, Ordering ->
23:28:42 <MrSkeltal> jle`, still has the same issue? no?
23:29:06 <MrSkeltal> (Cmp2 a b c) == (Cmp2 d e f) = ?
23:29:29 <jle`> i think only the cases that make sense would typecheck
23:29:43 <jchia1> jle`: It makes sense if I only have Bool, Double & Int for Computable, but there is a custom types I didn't mention that is also 'Computable' that has no Ord. Cmp2 on it would not make sense.
23:30:22 <jle`> oh i thought you said that those were the only instances
23:30:40 <jchia1> It's closed, with two more instances for custom types.
23:31:01 <MrSkeltal> jchia1, anyway, you could do the following:
23:31:15 <MrSkeltal> data F f = FDouble (f Double) | FInt (f Int) | ...
23:31:28 <MrSkeltal> Cmp2 :: Ordering -> F Pair -> Nl Bool
23:31:49 <MrSkeltal> that's the same as writing out monomorphic Cmp2Int/Cmp2Double
23:31:51 <MrSkeltal> but more compact
23:39:04 <jchia1> jle`, MrSkeltal, MarcelineVQ, geekosaur: Thanks for the discussion. I'm going to work on the code.
23:43:41 <jle`> good luck! :)
