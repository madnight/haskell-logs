00:16:08 <olligobber> >let a = a
00:16:28 <liste> > let a = a in a
00:16:31 <lambdabot>  *Exception: <<loop>>
00:16:55 <liste> > let a = a in ()
00:16:58 <lambdabot>  ()
00:29:44 <olligobber> > let a = a
00:29:47 <lambdabot>  <no location info>: error: not an expression: ‘let a = a’
00:30:17 <olligobber> ghci doesn't mind it -_-
00:30:31 <geekosaur> lambdabot is not ghci
00:31:03 <geekosaur> @run wants expressions. not do-style let bindings, not data Foo ..., etc.
00:31:07 <lambdabot>  <hint>:1:24: error: parse error on input ‘do’
00:31:19 <geekosaur> heh
00:32:09 <liste> > runIdentity (do let a = a; return 5) 
00:32:12 <lambdabot>  <hint>:1:36: error: parse error on input ‘)’
00:32:55 <geekosaur> and that one needs extra braces to compensate for no layout
00:33:05 <geekosaur> > runIdentity (do let {a = a}; return 5) 
00:33:08 <lambdabot>  5
00:33:37 <liste> geekosaur: thanks :)
00:35:28 <ski> > do let {a = a}; 5
00:35:30 <lambdabot>  5
00:36:51 <MrSkeltal> > let in do 5
00:36:54 <lambdabot>  5
00:38:11 <geekosaur> > do 5
00:38:15 <lambdabot>  5
00:39:15 <liste> geekosaur: how does that "do 5" work?
00:39:26 <ski> @undo do 5
00:39:26 <liste> is "do x" just "x" always?
00:39:26 <lambdabot> 5
00:39:38 <ski> @undo do let {a = a}; 5
00:39:39 <lambdabot> let { a = a} in 5
00:39:45 <geekosaur> liste, yes
00:40:00 <liste> cool. well it makes sense
00:40:12 <liste> no need for >>= so no need for Monad
00:40:33 <ski> no need for a type of shape `m a', even
00:41:34 <Younder> Monads should not be used as an excuse to avoid functional thinking.. (I think)
00:41:36 <ski> > do let {() | let = ()}; ()
00:41:39 <lambdabot>  ()
00:42:41 * geekosaur wondered what that had to do with anything.
00:42:49 <geekosaur> (especially in the days of ApplicativeDo)
00:43:00 <geekosaur> which is another reason it doesn't infer a constraint automatically
00:43:25 <Younder> geekosaur, just a reaction to >>= which seems overused
00:54:52 <tdammers> functional thinking should not be used as an excuse to avoid imperative models if and when appropriate
00:55:37 <tdammers> and of course, neither monads nor do notation necessarily imply "imperative", at least not beyond a very thin surface
01:11:01 <Cale> Monads are generally excellent examples of functional thinking.
01:26:40 <merijn> I don't suppose there's an easy construction with transformers where I can have a Writer with an early abort/shortcircuit?
01:38:21 <vaibhavsagar> merijn: some combination of Writer + Maybe?
01:39:06 <merijn> vaibhavsagar: Not quite, because the Monoid for Maybe is wrong and doesn't abort the future effects
01:40:30 <carbolymer> :O
01:41:37 <MrSkeltal> merijn, is MaybeT (WriterT w Identity) not what you want?
01:41:51 <merijn> > Nothing <> Just "2"
01:41:54 <lambdabot>  Just "2"
01:42:09 <MrSkeltal> that's not what I said
01:42:18 <merijn> MrSkeltal: No, that was an example for vaibhavsagar 
01:42:58 <merijn> MrSkeltal: The problem is that I have, effectively, two writers. One whose output I always need, even in case of short-circuit and one whose output I only need if it never errors
01:43:18 <knupfer> Can I hint GHC that I want a certain expression to be floated to top level in core?
01:43:32 <MrSkeltal> @unmtl Writer w
01:43:32 <lambdabot> Plugin `unmtl' failed with: `Writer w' is not applied to enough arguments, giving `/\A. (A, w)'
01:43:35 <MrSkeltal> @unmtl Writer w a
01:43:35 <lambdabot> (a, w)
01:43:40 <MrSkeltal> errr
01:43:46 <MrSkeltal> @unmtl WriterT w m a
01:43:46 <lambdabot> m (a, w)
01:44:02 <MrSkeltal> WriterT w1 (MaybeT (WriterT w2 Identity))
01:44:06 <knupfer> foo x = GHC.toToplevel (costly 22) + x
01:44:08 <ski> @unmtl WriterT w0 (MaybeT (Writer w1)) a
01:44:08 <lambdabot> (Maybe (a, w0), w1)
01:44:30 <knupfer> in the sense, that different calls of foo share the result of `costly 22`
01:44:56 <knupfer> (without defining anything additional outside of foo)
01:45:04 <MrSkeltal> knupfer, that can be more easily done with a where-binding
01:45:17 <MrSkeltal> unless of course foo is polymorphic
01:45:39 <ski> (bounded polymorphic)
01:46:04 <knupfer> MrSkeltal: Would this work as well with let bindings?
01:46:19 <knupfer> I would want to do this with rewrite rules...
01:52:30 <knupfer> Hm, I'll just try and stare core
01:53:52 <ski> (knupfer : i guess <https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#static-pointers> would probably work, but it may be overkill ..)
01:55:13 <knupfer> ski: That's great!
02:07:43 <vaibhavsagar> merijn: would using the Last newtype help?
02:08:16 <vaibhavsagar> actually nvm, I don't think it would
02:17:53 <vaibhavsagar> is there a ShortCircuit monoid where ShortCircuit a <> ShortCircuit Nothing = ShortCircuit a; ShortCircuit a <> ShortCircuit b = ShortCircuit b?
02:18:19 <merijn> Not that I'm aware of, but I suppose I can invent my own :)
02:18:31 <merijn> I'll have to consider whether it obeys the monoid laws, though...
02:18:53 <vaibhavsagar> yeah, I'm wondering if it would be unlawful somehow
02:22:38 <MrSkeltal> vaibhavsagar, Last
02:22:52 <MrSkeltal> % :info Data.Monoid.Last
02:22:53 <yahb> MrSkeltal: newtype Last a = Last {getLast :: Maybe a} -- Defined in `Data.Monoid'; instance Applicative Last -- Defined in `Data.Monoid'; instance Eq a => Eq (Last a) -- Defined in `Data.Monoid'; instance Functor Last -- Defined in `Data.Monoid'; instance Monad Last -- Defined in `Data.Monoid'; instance Monoid (Last a) -- Defined in `Data.Monoid'; instance Ord a => Ord (Last a) -- Defined in `Data.Monoid'; instanc
02:26:45 <vaibhavsagar> MrSkeltal: thanks, I saw that but it isn't quite what I want
02:27:11 <MrSkeltal> is it not?
02:27:32 <MrSkeltal> you want it to be non-strict in the lhs of <>?
02:27:35 <vaibhavsagar> my definition was wrong: I want something that stops at the last Just before a Nothing
02:28:24 <MrSkeltal> I'm afraid that's not a monoid
02:28:34 <Ferdirand> that does not sound associative
02:28:55 <MrSkeltal> mconcat [mconcat [Just 1, Nothing], Just 2, Nothing] != mconcat [Just 1, Nothing, Just 2, Nothing]
02:29:25 <vaibhavsagar> hmm, makes sense
02:33:30 <merijn> You could get one that was the last Just
02:33:39 <merijn> But you'd need to define a new identity
02:34:01 <merijn> I think I can make a lawful monoid for the situation I have
02:38:01 <merijn> http://lpaste.net/359683
02:38:21 <merijn> I'm reasonably sure that's a lawful monoid
02:48:23 <doneir> hoi
02:49:16 <doneir> <-- senior software engineer, diverse background in R&D for peeps what up
02:51:05 <liste> Haskell's up
02:51:25 <doneir> is this channel full of 1668 people or bots who do not want to interact with others?
02:51:31 <doneir> yo
02:52:18 <tdammers> we interact all the time, but we like to keep quiet when there is nothing meaningful to say
02:52:38 <doneir> are you one of the many who utilised the haskell programming lang in the eariyl 2000's? ;P
02:53:08 <tdammers> no... I picked up Haskell in 2008 IIRC
02:53:29 <knupfer> Result of optimizing my library: the simplifier doesn't like me anymore and goes into a loop :(
02:53:38 <doneir> tdammers: fair one, how abouts we statr a conversation for people to interact with?
02:53:57 <doneir> tdammers: damn man, really? that's somewhat cool, never got into Haskell myself
02:54:26 <tdammers> doneir: would you like to?
02:54:28 <doneir> my early days was applescript
02:54:53 <doneir> wha? To interact with others, certainly
02:55:06 <tdammers> no, I meant to get into Haskell
02:55:26 <doneir> neg, I'm into C, C++ and Python now
02:55:30 <doneir> some ASM
02:55:39 <doneir> some GPU progs
02:55:58 <fakenullie> Why are you here then
02:56:02 <doneir> gotta use what's best right
02:56:18 <doneir> heard this was a good community to talk with
02:56:21 <doneir> hard to find
02:56:24 <liste> Haskell's best in great many cases :)
02:56:36 <doneir> why so?
02:56:37 <liste> this is a great community to talk about Haskell with
02:56:39 <tdammers> arguably and subjectively, but yes
02:57:04 <doneir> best tool for the job sbv
02:57:08 <doneir> *obv
02:57:22 <tdammers> but anyway, this is #haskell, so if you want to interact on some topic that is not related to haskell, this might not be the best place
02:57:36 <liste> doneir: Haskell allows for high level in abstraction, leading to fast development and highly readable code, while still maintaining guarantees that allow reasoning about your code
02:57:41 <doneir> actually I do have a question, related to mathematics
02:57:51 <doneir> is thta okay?
02:58:01 <liste> doneir: if it's not related to Haskell, ##math is a better place
02:58:11 <doneir> kk
02:58:20 <doneir> thank you for being polite
03:23:59 <orion> I have a grand vision for a Haskell project, but it's half baked and needs fleshing out with people in the community.
03:24:11 <knupfer> orion: go on
03:24:12 <orion> But I'm also worried that someone might patent the idea and prevent me from using it.
03:24:19 <knupfer> nah
03:24:24 <orion> So I don't know what to do.
03:25:25 <knupfer> orion: publicize the idea, let's say on github, with a free software license, and voila, it's unpatentable
03:25:48 <orion> By everyone including me?
03:26:00 <knupfer> I think no
03:26:29 <knupfer> A patent must be your original idea, so by making it public, you're the only one left to that claim.
03:26:52 <orion> But don't I have to actually build a MVP first?
03:26:54 <knupfer> (disclaimer: I'm no lawyer)
03:27:43 <knupfer> nope, there are a lot of things patented without implementation
03:28:00 <orion> Alright.
03:28:25 <knupfer> You're patenting ideas, and not products.
03:28:53 <knupfer> For products, that would be more something like trademarks etc.
03:29:36 <knupfer> (or a product which depends on a patent)
03:31:08 <orion> Makes sense.
03:37:36 <merijn> knupfer: No, publically publishing it like that will render it unpatentable for you too
03:37:55 <knupfer> merijn: Ah, ok.
03:38:17 <merijn> knupfer: You can register a "pending patent" which sort of a "dibs" on a patent registration, which lets you publish it without losing the right to patent it later
03:38:50 <merijn> orion: Also, the EU (and lots of countries other than the US) don't recognise software as patentable, so a patent won't protect you against people there copying your idea anyway
03:39:02 <merijn> Patents also cost a shitload of money to register
03:39:16 <orion> I'm interested in using patents defensively.
03:39:25 <orion> I am not interested in being an asshole.
03:40:13 <knupfer> orion: If that's the case, just publish it. No one will be able to patent it and you can do what you want.
03:40:41 <orion> I See.
03:41:59 <knupfer> (If you don't want to defend yourself from other patents by amanacing with your patent)
03:42:32 <knupfer> s/amanacing/menacing
03:42:55 <knupfer> lol, I'm not spanish...
03:59:09 <Ulrar> So is there a way to list files and directories in a given path ? Everything I find seems to return only a list of string, which doesn't tell me which is a file and which is a directory
04:07:18 <MrSkeltal> Ulrar, you'll have to 'stat' it yourself
04:07:58 <MrSkeltal> the original 'readdir' POSIX interface does not immediately give you the file type
04:08:50 <Ulrar> pathwalk seems to do it fine, I'll go with that I think
04:10:13 <MrSkeltal> % filterM isDirectory $ getDirectoryContents "."
04:10:17 <yahb> MrSkeltal: ; <interactive>:1:9: error:; * Variable not in scope: isDirectory :: a -> m Bool; * Perhaps you meant `listDirectory' (imported from System.Directory); <interactive>:1:23: error:; * Couldn't match expected type `[a]' with actual type `IO [FilePath]'; * In the second argument of `($)', namely `getDirectoryContents "."'; In the expression: filterM isDirectory $ getDirectoryContents "
04:11:20 <MrSkeltal> % filterM doesDirectoryExist $ getDirectoryContents "."
04:11:22 <yahb> MrSkeltal: ; <interactive>:1:30: error:; * Couldn't match expected type `[FilePath]' with actual type `IO [FilePath]'; * In the second argument of `($)', namely `getDirectoryContents "."'; In the expression: filterM doesDirectoryExist $ getDirectoryContents "."; In an equation for `it': it = filterM doesDirectoryExist $ getDirectoryContents "."
04:11:33 <MrSkeltal> % filterM doesDirectoryExist =<< getDirectoryContents "."
04:11:33 <yahb> MrSkeltal: [".",".."]
04:23:14 <mbrock> https://hackage.haskell.org/package/lens-4.15.3/docs/Control-Lens-Plated.html#v:...
04:23:23 <mbrock> opaque function how does it work :(
04:23:31 <mbrock> the name leads me to believe it should be useful and idiomatic
04:38:37 <olligobber> I'm surprised how often I've used `main = interact id` lately
04:38:45 <olligobber> I like how short it is
04:41:47 <cocreature> it’s also kind of useless? :)
04:44:51 <olligobber> cocreature, that's why I'm surprised I've used it twice in the past couple of months
04:47:41 <mbrock> is it because you made a slow reimplementation of "cat" twice in the past couple of months?
04:48:09 <olligobber> one was for a haskell program to test something random on
04:48:29 <olligobber> the other was a submission where I needed the input but could only see the output
04:48:59 <olligobber> I guess I could have done that second one more easily by adjusting the shell script
04:51:12 <merijn> If a function's type changes should it's @since notation be updated to match that of the new type?
05:00:54 <merijn> Or is there a different annotation for that?
05:24:21 <dredozubov> I feel like I've seen associated newtypes somewhere, but parser gives me an error :(
05:24:55 <dredozubov> I want to transform GADT into a class with associated newtypes, to give constructors Coercible instance somehow
05:25:26 <dredozubov> I think I can get away with unsafeCoerce, but I don't want to do that
05:29:52 <ski> dredozubov : `data' in the type class, `newtype' in the instance ?
05:30:02 <pranz> dredozubov: how do you mean with associated newtype? Declaring the newtype in the class instance? I don't think that works. Just use associated types and declare all newtpyes and associate like normal
05:30:56 <dredozubov> ski: brilliant, parser is happy at least
05:31:07 <dredozubov> have to fix some code down the line to see if it works
05:31:30 <pranz> seems I was in the wrong, sorry  for the clutter
05:31:51 <merijn> Opinion poll: If a module exports a "config" record should I prefix it's accessors to make it less likely I clash with common names or use short names that could clash and just rely on people to import qualified?
05:32:16 <dredozubov> merijn: I would prefix it
05:50:16 <nicknight> hi lambdabo is written in haskell ?
05:50:25 <merijn> nicknight: Yes
05:50:33 <nicknight> Can I find its source?
05:50:51 <tdammers> https://wiki.haskell.org/Lambdabot
05:51:11 <tdammers> hmm wait that seems outdated
05:51:29 <tdammers> http://hackage.haskell.org/package/lambdabot
05:51:44 <nicknight> and I never worked with bots and any chance can i use lambdabot in slack ?
05:51:56 <k0001> merijn: I would prefer to import it qualified, no prefix in the names.
05:52:55 <Clint> nicknight: it's not exactly designed sanely
05:54:14 <tdammers> Clint: that seems to be an unwritten law with chat bots :D
05:55:26 <nicknight> ok 
05:55:40 <Clint> tdammers: anything chat-related, really
06:01:56 <Psybur> > foldr f k [u]
06:01:59 <lambdabot>  f u k
06:02:12 <MarcelineVQ> you win a prize
06:02:20 <Psybur> :D
06:02:37 <MarcelineVQ> > foldl f k [u]
06:02:40 <lambdabot>  f k u
06:03:02 <Psybur> > foldr n u [o]
06:03:05 <lambdabot>  error:
06:03:05 <lambdabot>      • Couldn't match expected type ‘Expr -> Expr -> Expr’
06:03:05 <lambdabot>                    with actual type ‘Expr’
06:03:27 <MarcelineVQ> :>
06:03:54 <Psybur> D;
06:03:56 <MarcelineVQ> :t f
06:03:59 <lambdabot> FromExpr a => a
06:04:10 <MarcelineVQ> :t n
06:04:12 <lambdabot> Expr
06:04:18 <Psybur> !
06:04:37 <MarcelineVQ> trickery from simple-reflect  https://hackage.haskell.org/package/simple-reflect
06:05:06 <MarcelineVQ> specifically https://hackage.haskell.org/package/simple-reflect-0.3.2/docs/Debug-SimpleReflect-Vars.html
06:05:08 <mbrock> hmm, I can't find any way with FGL to get the subgraph reachable from a node
06:05:46 <mbrock> there's BFS.bfe for finding the edges in a BFS traversal but it gives undirected edges back
06:06:19 <mbrock> what I really want to do is get the toposort of vertices reachable from a node
06:06:53 <mbrock> ahh, I can use the subgraph function combined with the bfs function
06:08:54 <merijn> ok, suppose I have a tree and do a monoidal fold on it. I can track the number of elements below a specific level by just having each leaf/node be "Sum 1". But can anyone think of a way that I can determine how elements are at a *specific* level?
06:09:50 <merijn> (the fold mappend is mappending breadth-first, so all nodes on level N get mappended before that result is mappended with any other result)
06:11:29 <Psybur> Do you mean how many elements are at a specific level?
06:11:53 <Psybur> You dont want to know how theyre doing right? ;D
06:12:27 <merijn> Psybur: I'm talking about a rose tree, so when I'm dealing with a node I want to know the number of *direct* children, rather than all descendants
06:16:29 <merijn> hmmm, maybe I can do it by keep a list and appending to it on each level
06:16:53 <merijn> Then I can check the number of nodes on the current level simply by checking the first count in the list...
06:19:39 <Psybur> merijn, are you using Data.Tree?
06:21:28 <Psybur> Theres a levels function in Data.Tree
06:21:37 <Psybur> https://hackage.haskell.org/package/containers-0.5.10.2/docs/src/Data.Tree.html#levels
06:29:16 <merijn> Psybur: No, there's no real tree in reality
06:29:31 <merijn> There's just a fold of a conceptual tree
06:31:40 <ski> using `Foldable' ?
06:31:44 <ski> hm
06:32:21 <merijn> ski: No, it's a custom fold that I can only pass fold functions into
06:32:29 <ski> iiuc, associativity means you can't keep track of depth/nesting/levels
06:32:51 <MarcelineVQ> can this conceptual tree's nodes track their parents and ask their parents how many kids they have?
06:33:03 * ski was pondering something with `Data.Tree.foldTree' .. but that's not a monoidal fold
06:33:32 <merijn> MarcelineVQ: No. There's one function called for every node with children which gets as input the monoidal fold of folding it's children
06:34:16 <merijn> So I think I might be able to define a custom monoid for lists, every new node simply adding a new count of 1 for it's level and mappend doing a pairwise sum on those lists
06:34:22 <ski> so the children results are monoidally combined, and then passed to this function ?
06:34:37 <merijn> ski: Yeah
06:34:53 <ski> ok. so it's not just a monoidal combination of all elements in the tree, then
06:35:35 <merijn> ski: This fold basically: https://hackage.haskell.org/package/tasty-0.11.3/docs/Test-Tasty-Ingredients-ConsoleReporter.html#v:foldTestOutput
06:37:16 <Psybur> merijn, I think tasty is also having a hard time. Their build is failing :D
06:37:55 <merijn> Psybur: Only one of them
06:38:07 <merijn> And it's stack, so no one cares :p
06:44:22 <ski> merijn : hm, what if you pass `\_ ns -> [length ns]' as second argument, and `\_ _ _ -> [1]' as first ?
06:44:57 <merijn> ski: I think that's what I was thinking off?
06:45:45 <merijn> ski: http://lpaste.net/359688 and then append (1:) in every "wrap" of the monoid
06:49:05 <ski> > foldTree (const length) (Node [0] [Node [0,0] [Node [0,0,0] [Node [0,0,0,0] [],Node [0,0,0,1] []]],Node [0,1] [],Node [0,2] [Node [0,2,0] [Node [0,2,0,0] [Node [0,2,0,0,0] []]]]])
06:49:08 <lambdabot>  3
06:49:09 <ski> > foldTree ((. mconcat) . (\_ ns -> [length ns])) (Node [0] [Node [0,0] [Node [0,0,0] [Node [0,0,0,0] [],Node [0,0,0,1] []]],Node [0,1] [],Node [0,2] [Node [0,2,0] [Node [0,2,0,0] [Node [0,2,0,0,0] []]]]])
06:49:12 <lambdabot>  [3]
06:49:51 <mbrock> say you have a buffer, and a set of (nonoverlapping) byte ranges to delete from that buffer -- is there a name for this problem or a ready solution? (the issue being that once you delete one range, the indexes for the remaining ranges need to change)
06:50:30 <mbrock> I guess splitting at the boundaries and then repasting would be an easy way to code it
06:51:09 <ski> merijn : i was thinking of just `instance Monoid [a]'
06:51:19 <mbrock> otherwise some kind of fold that accumulates an index-shifting function...
06:51:39 <merijn> ski: I'm not sure that does the right thing?
06:52:35 <ski> seems to do the right thing for the `foldTree' example above (composed with a `mconcat' for combining the children results, to simulate your situation)
06:54:00 <ski> i think you should get a singleton list as result (assuming there's a top-level test group containing everything)
07:00:22 <merijn> ski: Doesn't seem any more elegant/simple than my version, though, tbh
07:06:39 <ski> merijn : what would the first two arguments be in your version ?
07:07:18 <merijn> ski: First two arguments of what?
07:07:41 <ski> `foldTestOutput' ?
07:08:00 <merijn> ski: Rather...messy functions :)
07:08:24 * ski thinks `\_ ns -> [length ns]' and `\_ _ _ -> [1]' doesn't look that messy
07:08:41 <ski> (but maybe you didn't want to ignore all those arguments ?)
07:09:55 <merijn> ski: Those arguments are the IO actions that produce tasty's console output for tests. I'm using those to build new outputs and I want some of the output to depend on the number of children at a certain level
07:10:45 <merijn> ski: My version boils down to "\_ (Depth ls) -> Depth (1:ls)" and "\_ _ _ -> Depth [1]"
07:10:59 <merijn> ski: The messiness is all the surrounding stuff :)
07:11:13 <ski> hm, ok, so you want to compute both number of direct children, at each level, as well as some other result, involving these extra arguments
07:12:04 <merijn> ski: Basically I'm implementing a "folding" mechanism that should fold any node with more than N children, hence why I needed the child count in some way
07:27:39 <Gurkenglas> How do I get a profiling report at least as comprehensible as the source code file with every token colored according to the ressources spent on it?
07:28:16 <merijn> Gurkenglas: Not sure if profiling can attribute cost to specific lines?
07:29:07 <Gurkenglas> Coverage reports can do the corresponding
07:30:14 <Gurkenglas> What is a profiling report but a Bool -> Integer transformation of a coverage report?
07:39:16 <sm> Gurkenglas: you'll have to build that tool.. (sounds nice)
07:40:58 <sm> look at how profiles' "cost centers" are generated and see if they have source positions attached I guess
07:45:49 <antsanto> Hello all, I'm trying to implement my own version of cycle using pattern matching. Here is the code : https://repl.it/N5T1/1
07:46:06 <antsanto> the result was supposed to be [1,2,3,1,2,3,1,2,3]
07:46:12 <antsanto> however I got [[1,2,3],[1,2,3],[1,2,3]]
07:46:33 <antsanto> Is there a way to flatten the list? Or I'm doing something wrong here?
07:46:41 <Cale> antsanto: That's because you used [x] where you should have used x
07:46:55 <Cale> cycle1 x = x ++ cycle1 x
07:47:20 <Cale> [x] is the list of length 1 whose only element is x
07:48:14 <antsanto> Cale: So thats a silly mistake! 
07:48:54 <antsanto> Thanks! And also in this case, how does myTake 3 (cycle1 [1,2,3]), stops the cycle1 at right time? Because its bit confusing to me ..
07:50:20 <Cale> Well, let's calculate it
07:50:26 <Cale> myTake 3 (cycle1 [1,2,3])
07:50:30 <Cale> = myTake 3 ([1,2,3] ++ cycle1 [1,2,3])
07:50:41 <Cale> = myTake 3 (1 : ([2,3] ++ cycle1 [1,2,3]))
07:50:54 <Cale> = 1 : myTake 2 ([2,3] ++ cycle1 [1,2,3])
07:51:14 <Cale> = 1 : myTake 2 (2 : ([3] ++ cycle1 [1,2,3]))
07:51:33 <Cale> = 1 : 2 : myTake 1 ([3] ++ cycle1 [1,2,3])
07:51:54 <Cale> = 1 : 2 : myTake 1 (3 : ([] ++ cycle1 [1,2,3]))
07:52:04 <Cale> = 1 : 2 : 3 : myTake 0 ([] ++ cycle1 [1,2,3])
07:52:14 <Cale> = 1 : 2 : 3 : []
07:53:17 <Cale> An important thing to remember is that we always reduce the *outermost* thing that we can
07:53:48 <Gurkenglas> I ran "stack exec -- parrot-exe +RTS -p", waited for my RAM to get up to 90%, and killed it through task manager. Where's the .prof file?
07:53:57 <antsanto> Cale: Thats amazing, thanks so much. So basically, its myTake who is terminating the process here.. 
07:54:09 <Cale> yeah
07:54:12 <Cale> on that first line, myTake 3 (cycle1 [1,2,3]), the myTake is going to pattern match the list, but cycle1 [1,2,3] isn't yet of the form [] or (x:xs), so we don't know which pattern matches.
07:54:20 <Cale> So that's why we need to evaluate cycle1
07:54:40 <merijn> Gurkenglas: afaik killing a program results in no profiling report
07:54:43 <Cale> So we evaluate cycle1 [1,2,3] by a step to get [1,2,3] ++ cycle1 [1,2,3]
07:54:52 <Cale> but then that's still not quite in the form (x:xs)
07:55:01 <Cale> So we use the definition of (++)
07:55:03 <ski> @src (++)
07:55:03 <lambdabot> []     ++ ys = ys
07:55:03 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
07:55:03 <lambdabot> -- OR
07:55:03 <lambdabot> xs ++ ys = foldr (:) ys xs
07:55:15 <Gurkenglas> merijn, how am I supposed to find space leak causes?
07:55:31 <antsanto> Cale: Oh that makes a lot more sense now! Haskell seems to be so good for a person like me, who is coming from java / js background.. Thanks !
07:55:40 <Cale> and note that [1,2,3] is syntax sugar for (1:(2:(3:[]))), so it *does* match (x:xs)
07:55:41 <merijn> Gurkenglas: Can you add some way to do a graceful exit?
07:56:16 <Gurkenglas> You mean catch the Ctrl-C signal and respond to it by calling System.exit? If it's that simple why isn't it available by default :I
07:56:39 <hexagoxel> iirc if you interrupt via ctrl-c, it writes profiling stuff.
07:56:56 <merijn> Gurkenglas: I'm not sure how/when it's written so I'm not sure how you can make it work
07:57:03 <Gurkenglas> Ah, so that does something different from the task manager, thanks ill try again
07:57:33 <merijn> Gurkenglas: You could just have the main thread blocking on "hGetLine" and exit after that returns then press enter when you want it to exit?
07:58:08 <Gurkenglas> Aborted through Ctrl-C, where's the .prof file?
07:58:46 <hexagoxel> in cwd
07:58:54 <Gurkenglas> merijn, I haven't written any hGetLine's in there
07:59:06 <Gurkenglas> Where's cwd?
07:59:41 <Gurkenglas> https://docs.haskellstack.org/en/stable/GUIDE/ and https://www.fpcomplete.com/blog/2015/04/ghc-prof-flamegraph mention nothing of a cwd :I
07:59:48 <hexagoxel> in the directory you executed the program from.
08:00:14 <Gurkenglas> ls lists no such directory in the project
08:00:43 <Gurkenglas> which is where I ran stack exec -- parrot-exe +RTS -p
08:00:44 <hexagoxel> cwd = current working directory
08:00:51 <icassina> cwd := current working directory
08:01:14 <Gurkenglas> ls lists no .prof file in the project directory
08:01:21 <icassina> ls -a
08:01:31 <icassina> files starting with a dot are "invisible"
08:01:49 <Gurkenglas> neither does ls -a, though .git and .stack-work did appear
08:01:49 <hexagoxel> profs don't start with a dot though, normally
08:01:52 <Gurkenglas> (and . and ..)
08:02:18 <hexagoxel> Gurkenglas: perhaps you should try profile something that definitely terminates regularly
08:02:31 <hexagoxel> as sanity-checking the process works
08:03:44 <sm> yes, alter the program so it terminates sooner
08:04:33 <sm> or, apparently you can get a live-updating view of heap usage, GHC user guide profiling chapter has details
08:04:58 <hexagoxel> nah, don't go for the fancy stuff is you have not got the basics working yet.
08:05:17 <Gurkenglas> Currently waiting on parrot-strip-logs to finish profiling, compiled without profiling this worked in iirc a second or less
08:05:29 <Gurkenglas> there we go, about a minute
08:05:40 <hexagoxel> normal overhead i'd say.
08:05:41 <Gurkenglas> No .prof file
08:07:19 <MarcelineVQ> are you compiled with a relveant -prof setting?
08:07:36 <hexagoxel> RTS would complain otherwise, would it not..
08:07:43 <MarcelineVQ> I'd hope so
08:07:46 <Gurkenglas> stack build --profile, surely it would
08:08:01 <sm> I like hexagoxel's advice: down-shift and sanity check. Practice with a trivial program
08:09:55 <MarcelineVQ> heck for all we know stack puts prof files in  .stack-work/dist/ .../Cabal- .../build/   have you done a find like  find . -iname "*prof*"
08:09:58 <sm> echo 'main = putStrLn "hello"' > a.hs && stack exec -- ghc -prof -fprof-auto a.hs && ./a +RTS -p && ls -l a.prof
08:09:59 <Gurkenglas> Sure, waiting on "stack new profiletest" to produce a helloworld.
08:10:30 <sm> ^ tested
08:10:49 <hexagoxel> MarcelineVQ: even with "stack exec" ? that would be horrible. but indeed, something is off so one of the unexpected guesses will be right eventually..
08:11:13 <MarcelineVQ> hexagoxel: it puts plenty of other things in there, all the -ddumps for sure
08:11:20 * sm has money on PEBKAC
08:11:23 <Gurkenglas> MarcelineVQ, 'find . -iname "*prof*"' in the project directory runs through without output
08:11:48 <Gurkenglas> sm, where do I run this?
08:11:58 <sm> anywhere
08:12:09 <sm> you can see what it does, no ?
08:12:27 <hexagoxel> MarcelineVQ: yeah, but that's part of "stack build", which (can) have much more control.
08:12:59 <MarcelineVQ> hexagoxel: he's running in a project though so it adds some mystery :X
08:13:16 <Gurkenglas> Okay, in a copy of profiletest. I don't know what effect the project I run this in would have on it, so I asked
08:14:02 <Gurkenglas> sm, http://lpaste.net/8048438279395082240
08:14:20 <hexagoxel> could `stack exec -- pwd` to test if cwd is changed..
08:14:47 <Gurkenglas> Outputs /c/Users/Gurkenglas/Haskell/parrot, the project directory
08:14:52 <sm> Gurkenglas: ok, you're on windows - my command is invalid there
08:15:03 <sm> can you translate it to windowese ?
08:15:36 <toby1851> i just came across some code that chains multiple type constraints together with => does that mean anything different than the usual parenthesized list of constraints?
08:15:44 <hexagoxel> i think it is msys though. i give it some chance to work, actually.
08:15:47 <Gurkenglas> Uhh I can put that hello into an a.hs and runs the other && operands one by one
08:15:51 <sm> that's it
08:16:42 * hexagoxel reads the lpaste .. ah
08:17:32 <sm> and instead of ls -l a.prof, dir a.prof, etc.
08:17:46 <Gurkenglas> cat a.hs indicates that's already there, stack exec -- ghc -prof -fprof-auto a.hs fails with the lpasted error, opening the a.hs, waiting on intero
08:18:16 <sm> so complicated.. :/
08:18:22 * sm glares at intero
08:18:36 <Gurkenglas> intero failed to start, a.hs opened, removing '' around the code
08:19:52 <Gurkenglas> stack exec -- a +RTS -p works instead of the ./ thing
08:20:07 <Gurkenglas> No .prof file in the same directory as a.hs
08:20:34 <hexagoxel> which ghc version is this?
08:20:38 <sm> I would remove the "stack exec -- " bit, that could run a different a
08:20:53 <Gurkenglas> stack exec -- ghc --version says 8.0.2
08:21:22 <Gurkenglas> Removed stack exec --, a.prof is generated
08:21:23 <sm> just "a" (without quotes) works right ? and prints hello ?
08:21:30 <Gurkenglas> yep
08:21:32 <sm> ha
08:21:51 <Gurkenglas> So I suppose I tell stack to install instead of build and then run the exe without stack exec --?
08:22:17 <sm> I think you should get clear on what exactly stack build/install/exec do
08:22:54 <sm> in particular, stack exec EXE looks for EXE in special paths
08:24:56 * sm stalling for time
08:25:33 <sm> what's your next objective ? get a prof from "parrot-exe", right ?
08:25:48 <Gurkenglas> right, currently running the installed parrot-exe
08:26:03 <MarcelineVQ> I wonder how well behaved -- is in windows
08:26:05 <Gurkenglas> It fails to explode in RAM size
08:26:37 <Gurkenglas> emacs seems to be using 26.5% (1/4 cores?) of cpu, it's only supposed to be running the parrot-exe
08:27:52 * sm wonders what shell Gurkenglas  is using
08:28:03 <Gurkenglas> (parrot still at .1% cpu, 314 mb ram)
08:29:10 <auto_complete_> :q
08:29:30 <hexagoxel> (but if "stack exec -- foo +RTS -p" did not complain about not being built with -prof, and finished cleanly, then where did the prof go?)
08:29:34 <Gurkenglas> Stopped processing logs, is now actually yelling to #parrot
08:29:48 <hexagoxel> (what does "stack exec -- foo +RTS garbageLASJDLKJ" do ?)
08:31:03 <sm> https://github.com/commercialhaskell/stack/issues/2022 and https://ghc.haskell.org/trac/ghc/ticket/13287 seem to be about this, a quick read suggests GHC 8.2 might be the fix
08:31:18 <Gurkenglas> Oh right I gave it the minimized logs produced by a recently modified and just run-for-a-test version of parrot-strip-logs <.<
08:31:46 <Gurkenglas> And the only reason it took that long in the first place was probably the profiling
08:31:54 <MarcelineVQ> 8.0.2 is where that should be fixed but what matters is which ghc version built his stack
08:32:05 <sm> ah
08:32:32 <MarcelineVQ> reccomend stack upgrade --git which should be on 8.0.2
08:32:35 <sm> worth trying the latest stack first I guess
08:32:53 <sm> downloading a binary probably faster
08:33:09 <MarcelineVQ> ye, if the bin is made with 8.0.2
08:35:26 <greymalkin> Any suggestions for getting 128 and higher bit Integers from ByteStrings?
08:35:28 <Gurkenglas> Fixed log, properly eats my ram now, generated a .prof file
08:35:40 <merijn> greymalkin: What format are they stored in?
08:36:05 <Gurkenglas> stack exec -- foo +RTS garbageLASJDLKJ says that executable wasn't found on path
08:36:20 <Gurkenglas> foo, that is
08:36:38 <Gurkenglas> sure, let's run stack upgrade --git
08:36:46 <sm> Gurkenglas: "generated a .prof file" - does that mean you've solved the issue ?
08:36:46 <MarcelineVQ> try something on your path then, hexagoxel is trying to see if stack is eating your rts options
08:37:06 <Gurkenglas> sm, yes, copying the bins and running -p without stack exec in front did it
08:37:12 <sm> ah, right
08:37:29 <Gurkenglas> MarcelineVQ, should I abort stack upgrade?
08:37:47 * sm would try latest from https://haskell-lang.org/get-started/windows
08:38:01 <sm> or actually, just "stack upgrade"
08:38:11 <sm> should get a quick binary I think
08:38:36 <greymalkin> merijn: Big-endian -- specifically crypto-related numbers
08:38:39 <MarcelineVQ> Gurkenglas: you can check what hexagoxel was after without aborting anything
08:38:40 <hexagoxel> (my suggestions should be obsolete given then issues sm referenced. was ghc bug in windows)
08:39:59 <merijn> greymalkin: I don't think there's anything existing for that, since I don't think there's an Int128 defined anywhere. You could parse them one byte/word at a time and shift them into an Integer?
08:40:20 <hexagoxel> and stack upgrade seems like a good idea.
08:40:22 <Gurkenglas> hexagoxel, stack exec -- parrot-strip-logs +RTS garbageLASJDLKJ is running without having complained. Obsolete, got it
08:40:45 <sm> ah, PR #3012 seems to add a --rts-options flag to stack exec, as a workaround: https://github.com/commercialhaskell/stack/pull/3012/commits/569fbb293958a7d6fa875511eb1953ed4eb51952#diff-e705c8fadf1193ab59443a5e6c8cbe8bR68
08:41:18 <MarcelineVQ> sm: note that the prebuilt binaries only require ghc 7.10.* as min so using them isn't a guarantee of a recent enough rts
08:41:29 <MarcelineVQ> *currently only
08:42:05 <merijn> greymalkin: For getting individual bytes/words out of a ByteString I'd recommend using binary's Data.Binary.Get
08:42:13 <sm> MarcelineVQ: ok. I think what's needed is just a stack new enough to have the --rts-options flag
08:42:17 <hexagoxel> without having read the whole issue thread, wouldn't "stack --RTS exec -- parrot-strip-logs +RTS -s" also work, as a workaround?
08:42:38 <Gurkenglas> http://lpaste.net/226938203540553728 <- is this a not-windowsese thing? :I
08:42:40 <sm> and then use it something like stack exec --rts-options="-p" foo, I guess
08:42:54 <MarcelineVQ> dunno, windows uses a different way to take in args than linux that was part of the problem iirc
08:43:17 <MarcelineVQ> * hexagoxel: dunno, 
08:43:31 <sm> don't know Gurkenglas, have a look in the prof file
08:43:45 <sm> does it look valid ?
08:44:13 <hexagoxel> MarcelineVQ: yeah, it comes down to exactly how broken windows rtsopts parsing is.
08:44:57 <Gurkenglas> sm, yep
08:45:34 <sm> Gurkenglas: about the original "no .prof" issue. I don't know if you caught all that. Summary: make sure "stack exec --help" includes the --rts-options flag, and use that instead of --/+RTS
08:45:54 <Gurkenglas> Before the -- delimiter, yes?
08:45:55 <Ferdirand> what does it mean when stack install aborts with "dependencies for x: .... needed for unknown reason - stack invariant violated. Plan construction failed." ?
08:47:14 <MarcelineVQ> Ferdirand: that's a new one to me. pastebin the whole log and your project's cabal file if you're in a project and see if anyone has an idea. what were you stack install-ing?
08:47:41 <Ferdirand> MarcelineVQ: trying to install idris
08:48:20 <Ferdirand> my local install may be foobared though.. with pieces of an old stack in /usr/local and another in $HOME/.local
08:48:54 <MarcelineVQ> nah that's common, just make sure the .local comes up sooner in your $PATH
08:49:04 <Ferdirand> it does
08:49:45 <Ferdirand> oh wait
08:50:10 <Ferdirand> i'm setting the path using stack path --bin-path from .bashrc
08:50:50 <MarcelineVQ> you probably wanted stack path --local-bin
08:51:21 <MarcelineVQ> I'd be inclinded to write it manually though, so the path you mean is what ends up in $PATH
08:51:46 <Ferdirand> i'm not sure what i want
08:51:58 <Ferdirand> --bin-path gives me several bin directories under .stack
08:51:59 <MarcelineVQ> I think local in is in --bin-path too so it's probably okay, dunno
08:52:13 <Ferdirand> it is
08:52:19 <MarcelineVQ> anyway, it's not likely to be the issue you're having
08:52:51 <MarcelineVQ> are you writing  stack install idris  outside of any project directory?
08:53:02 <Ferdirand> .... yes ?
08:53:05 * sm lost his bet on PEBKAC. Problem Exists Between GHC And Windows, it seems. 
08:53:31 <MarcelineVQ> Okay what resolver is listed in .stack/global-project/stack.yaml if you have one
08:53:47 <Ferdirand> lts-8.4
08:55:52 <MarcelineVQ> alrighty, I'd bump that to 9.11 just to see if the version changes help
08:57:03 <Ferdirand> i will try, thanks
08:57:08 <Ferdirand> what is a resolver anyway ?
08:57:20 <Ferdirand> hmm, seems to be working
08:57:46 <sm> Gurkenglas: re the ghc-prof-flamegraph error, I get the same with a trivial .prof. That tool was last uploaded in 2015, it's out of date. Seems fixed in git: https://github.com/fpco/ghc-prof-flamegraph/issues/4
08:57:58 <MarcelineVQ> a stackage resolver is a curated set of hackage packages known to build together
08:58:28 <MarcelineVQ> It's a way to reduce build conflicts by choosing a specific set of package versions to work with
08:59:07 <MarcelineVQ> resolver 8.* isn't actually on the official list anymore that I can see so I figured bumping to another resolver was a good idea, hopefull it works out
08:59:13 <merijn> Can I hyperlink words in Haddock?
08:59:20 <Gurkenglas> The ALLOC parts tell me what got RAM for any amount of time, not what is hogging RAM until the program crashes, right?
08:59:25 <MarcelineVQ> Well, it's there, it's just not one of the reccomended ones on the front page here https://www.stackage.org/
08:59:48 <Ferdirand> terminfo fails to build, but that is probably because i'm missing some headers on this machine, thx
09:00:27 <MarcelineVQ> I've also been having terminfo issues and ncurses and all kinds of nonsense related to being on arch that I'm getting a little annoyed at by this point :X
09:01:16 <Gurkenglas> What does the indiv portion of the .prof information on an identifier represent?
09:02:05 <MarcelineVQ> Ferdirand: the point of mentioning that annoyance is just that if you're on arch you might run into issues with ghc related things, the people running the show over in arch-land aren't quite on the ball this year
09:05:32 <Ferdirand> MarcelineVQ: this machine is on qubes with a debian template
09:05:52 <Ferdirand> so every apt install at the system level requires a reboot of the container :/
09:18:55 <pmade> Would someone with Groundhog experience help me write a type signature for this utility function: https://github.com/lykahb/groundhog/issues/74
09:22:31 <meijiJAPAN> i did write my ai homework in haskell and just because of that the ta who grades us started learning to understand my code lol 
09:22:40 <meijiJAPAN> another foot soldier for the glorius haskeller army
09:25:48 <vrederv> Has Haskell changed much since 2011?
09:27:00 <liste> vrederv: GHC Haskell has
09:27:03 <liste> a lot
09:27:31 <vrederv> and the language itself?
09:27:58 <vrederv> Basically is lyah still a good starting resource?
09:27:59 <liste> well the latest Language Report is 2010
09:28:05 <vrederv> oh
09:28:09 <vrederv> nvm
09:28:21 <liste> but nobody uses standard haskell
09:28:28 <liste> they use GHC
09:28:31 <tdammers> lyah still works
09:28:39 <tdammers> although people have written better materials since
09:28:53 <vrederv> for example?
09:29:19 <dsal> http://haskellbook.com/
09:29:30 <tdammers> ^ yep, this one
09:29:59 <dsal> I'm greatly enjoying the read, even though I've not got to much I don't already know, the *way* I know it is improving a lot.  :)
09:30:54 <tdammers> also, I highly recommend this one as a companion to whatever learning material you use: http://dev.stephendiehl.com/hask/
09:31:42 <meijiJAPAN> what about real world haskell?
09:31:52 <vrederv> haskellbook has 1000+ pages?
09:31:53 <tdammers> good book, but outdated
09:32:15 <dsal> I didn't get as much out of Real World Haskell.  It's more of a gallery than a way to learn things well.
09:32:45 <tdammers> RWH is a good read if you need to see some examples of Haskell being put to practical use... it did make things click for me
09:33:58 <dsal> I still struggle a bit with attoparsec/parsec.  I've seen things done, but I don't typically know where to begin.  I've had some success with megaparsec just because that one tutorial is quite good.
09:34:02 <mud> vrederv: It's quite long, yes.
09:34:44 <mud> dsal: Then use megaparsec? It's quite similar to the others, especially parsec. It's essentially a better fork of parsec, so might as well just skip that one.
09:35:21 <dsal> Yeah.  I've not had any really strong needs, but attoparsec sounds small. heh
09:35:32 <tdammers> dsal: it helps to write a basic parser-combinator thingie yourself, see if you can figure it out
09:35:52 <mud> Yeah, going through the NICTA course, the parser part was quite enlightening to me.
09:36:05 <vrederv> Well I just bought lyah and am starting to lmahfgg.
09:36:14 <mud> Er, they changed the name of that thing didn't they, what's it called now *ponders*
09:36:22 <johnw> I really enjoyed LYAH
09:37:28 <vrederv> Are any popular web apps written in Haskell?
09:37:28 <mud> I enjoyed parts of LYAH like I enjoy reading popular science books. They're fun, but it's not like they're going to make me a physicist or an astronomer. Different material is necessary to actually be able to do anything in haskell for me.
09:37:42 <tdammers> LYAH didn't do it for me
09:37:48 <mud> pandoc and xmonad are probably the most well known ones
09:38:06 <tdammers> they're not web apps though
09:39:55 <Psybur> :t absurd
09:39:57 <lambdabot> Void -> a
09:40:13 <Psybur> Teehee
09:40:28 <meijiJAPAN> i believe that the main reason of haskell being a niche language is that it lacks tutorials about real world scenarios
09:41:12 <meijiJAPAN> for example it was very hard to find a source that explains multithreading in haskell
09:41:42 <mud> http://chimera.labs.oreilly.com/books/1230000000929
09:41:46 <Psybur> http://book.realworldhaskell.org/read/concurrent-and-multicore-programming.html
09:41:47 <tdammers> I think the main reason is that haskell refuses to allow people to Get Stuff Done™ by throwing correctness or certainty out the window
09:42:42 <johnw> tdammers: I think that characterization is making some assumptions
09:42:49 <johnw> I throw stuff out the window using calls to 'error' all the time
09:43:18 <johnw> it's a just a little more explicit that I'm throwing up my hands
09:44:11 <vrederv> Well thanks guys, I'll return when I have some questions.
09:45:19 <EvanR> i kind of want an impossible case
09:45:44 <EvanR> instead of Impossibru -> error "impossible"
09:45:53 <dsal> meijiJAPAN: Parallel and Concurrent Programming in Haskell is pretty grand.  Control.Concurrent.Async is a set of primitives I've always wanted, but `using` is almost spooky.  I've sped up code just by sticking "`using` ParList rdeepseq" or something at the call site.
09:49:39 <Cale> EvanR: What would the difference be?
09:49:43 <mantovani> I have docker on my osx but it didn't create a network interface between osx and the docker image
09:50:09 <Cale> EvanR: Are you talking about for cases involving type equality constraints or something, so the compiler can prove that the pattern is impossible?
09:52:46 <Psybur> @src absurd
09:52:47 <lambdabot> Source not found. Maybe you made a typo?
09:52:58 <Psybur> @pl absurd
09:52:59 <lambdabot> absurd
09:53:13 <Psybur> > absurd
09:53:16 <lambdabot>  error:
09:53:16 <lambdabot>      • No instance for (Typeable a0)
09:53:16 <lambdabot>          arising from a use of ‘show_M10771139586558754161108’
09:53:24 <hydraz> Void -> a
09:53:48 <Psybur> I know the type, I was just curious how that cheeky haskeller implemented it here
09:54:25 <hydraz> ah
09:55:08 <raynold> ahh it's a wonderful day
09:59:08 <Psybur> Found it :D https://hackage.haskell.org/package/void-0.6.1/docs/src/Data-Void.html#absurd
09:59:24 <mantovani> how do I create an interface on osx to see the docker images ?
09:59:28 <mantovani> it suppose to be there...
09:59:47 <dsal> #docker?
10:00:18 <mantovani> ops
10:00:19 <mantovani> sorry
10:01:07 <meijiJAPAN> how good is hlearn compared to spark's mllib?
10:04:19 <Psybur> Good how?
10:08:23 <meijiJAPAN> i want to implement some basic classification models for an introduction to machine learning course 
10:09:23 <Psybur> HLearn might be better for that since you wont have to also teach about spark/hadoop/mapreduce
10:11:06 <Psybur> But you might be better using python and scikit learn honestly heh
10:11:14 <meijiJAPAN> i was really surprised when i found out that scala lacks a proper ml library though
10:11:31 <meijiJAPAN> most of the people on the internet hates (or don't like) mllib
10:12:58 <meijiJAPAN> Psybur, i am not comfortable with python
10:13:16 <meijiJAPAN> and i don't understand why python became so popular in data science
10:13:28 <meijiJAPAN> isn't fp supposed to excel in that kind of stuff?
10:14:19 <Psybur> Yes. Why dont you go and convert scikit learn, pandas, and numpy to haskell :D?
10:19:10 <EvanR> matlab?
10:20:14 <nicknight> Psybur:  May be I do that soon :P after learning haskell
10:20:40 <nicknight> and hope I will take haskell to next level 
10:20:54 <centril> Hmm, so I have   {-# LANGUAGE TypeApplications #-} import Data.Proxy ; ofType = Proxy ; :t ofType @Int   <-- gives me  "Cannot apply expression of type `Proxy t0' to a visible type argument `Int'"  no idea why this doesn't work when  :t Proxy @Int  works perfectly fine
10:21:14 <EvanR> nicknight: https://jezenthomas.com/static/img/profunctoroptics.jpg
10:21:50 <byorgey> centril: what does  :t ofType  say?
10:22:04 <centril> byorgey: ofType :: Proxy t
10:22:26 <centril> Then @Int should apply the type to  Proxy  giving me back  Proxy Int
10:23:51 <byorgey> centril: ah, I think if you want to be able to use explicit type application you have to declare the type with an explicit forall
10:24:45 <byorgey> this works for me:  {-# LANGUAGE ExplicitForAll #-}   ofType :: forall t. Proxy t; ofType = Proxy
10:24:56 <byorgey> then :t ofType @Int  yields  Proxy Int  as you would expect
10:25:43 <byorgey> if I recall correctly, the reason for this restriction is that otherwise it is not necessarily clear what order the type arguments should go in
10:25:59 <centril> byorgey: o.O that feels like a bug...  Proxy t0  means  forall t0. Proxy t0
10:26:36 <centril> byorgey: but nonetheless solves the issue
10:26:45 <byorgey> centril: it's not a bug.  Yes, of course Proxy t0 means  forall t0. Proxy t0.  But does   Foo a b  mean   forall a b. Foo a b, or  forall b a. Foo a b  ?
10:27:13 <byorgey> normally it wouldn't matter, but with ExplicitTypeApplications it does.
10:27:44 <centril> byorgey: is there some real ambiguity here? I'd always pick  Foo a b  to mean  forall a b. Foo a b
10:27:57 <nshepperd_> You may need to at least add a type signature to that the arguments go in *some* order
10:28:20 <mrCyb0r6> I thought it
10:28:44 <byorgey> centril: it can quickly get very tricky.  What if   type Bar a b = (b,a),  now what does    Foo (Bar a b) c  mean?   does a come first, or b?
10:29:05 <nshepperd_> I wouldn't expect TypeApplications to work with an inferred type
10:30:13 <centril> byorgey: both could work, but you can decide on an ordering that always works - either you first expand type aliases or you do it after -   I'd say that a comes first
10:31:14 <byorgey> centril: yes, you certainly *could* specify some rules to say what order the type variables will be.  But this would (a) be complicated for users to remember, and (b) unnecessarily constrain the compiler implementation.  It's much simpler just to require the forall to be explicit, then we don't have to worry about any of this.
10:31:41 <centril> byorgey: OK; I buy this ;)
10:33:44 <humanoyd> does FlexibleInstances imply TypeSynonymInstances?
10:36:52 <Gurkenglas> stack upgrade --git: http://lpaste.net/5154169108358496256
10:40:45 <Gurkenglas> When trying to install https://github.com/fpco/ghc-prof-flamegraph : http://lpaste.net/6245426199833608192
10:42:10 <Gurkenglas> The README says to use cabal, how do I tell stack to act as cabal?
10:47:45 <mud> Gurkenglas: In your first one, it looks like it got permission denied to overwrite whatever\\local\\bin\\stack.exe in case you didn't notice
10:48:47 <mud> Gurkenglas: stack install should usually work, it appears that that repo has a stack.yaml in it
10:48:54 <mud> If there is no stack.yaml, you'd do stack init first
10:50:32 <mud> Oh I see the errors at the bottom of that now. Uhm, I don't know what those are. It seems like the .cabal file refers to some file that doesn't exist? The package sounds broken. I don't know how hard it would be to fix.
10:51:39 <mud> Oh, there's git submodules. How did you clone that? I think you probably need to git clone with --recursive
11:04:09 <sm> Gurkenglas: re your stack upgrade failure on windows, search the stack issue tracker for that error message
11:09:17 <cocreature> Gurkenglas: have you initialized the submodule in the ghc-prof-flamegraph repo?
12:05:07 <remix2000> Hey, how can I use map, but only for elements matching certain condition? Is there any way other than lambda or custom function?
12:06:08 <EvanR> > map (\x -> if even x then x + 1 else x) [0..9]
12:06:10 <lambdabot>  [1,1,3,3,5,5,7,7,9,9]
12:06:35 <EvanR> is the question how to do it another way?
12:06:59 <remix2000> EvanR: Yes. This one uses lambda :/ 
12:07:14 <shapr> filter?
12:07:18 <shapr> :t filter
12:07:19 <lambdabot> (a -> Bool) -> [a] -> [a]
12:07:21 <EvanR> @pl (\x -> if even x then x + 1 else x)
12:07:21 <lambdabot> join (liftM2 if' even (1 +))
12:07:31 <EvanR> unlambdad
12:07:37 <MarcelineVQ> :<
12:08:21 <remix2000> EvanR, shapr: Thank you :>
12:09:42 <EvanR> bonus credit understand how TF that works
12:10:23 <remix2000> Let me think..
12:11:10 <humanoyd> remix2000: if it is a list you are mapping over, you can also use list comprehensions [x + 1 | x <- [1..10], even x]
12:11:50 <remix2000> humanoyd: but then I'll lose other items
12:12:02 <EvanR> ok so the question wasnt quite specific enough
12:12:04 <fakenullie> :t if'
12:12:06 <lambdabot> error:
12:12:06 <lambdabot>     • Variable not in scope: if'
12:12:06 <lambdabot>     • Perhaps you meant ‘f'’ (imported from Debug.SimpleReflect)
12:12:09 <shapr> oh hey, I have a Haskell question! I teach intro workshops for Python and Haskell where the task is to download a book from gutenberg, cut it into words, then display the ten most frequent words
12:12:19 <shapr> What would you consider the most readable/teachable way to do that in Haskell?
12:12:37 <EvanR> shell out to wget ? :)
12:12:40 <shapr> I've already written something in Haskell, but I'd love to hear more ideas
12:12:47 <shapr> EvanR: good idea
12:13:07 <shapr> and then read in a file's contents?
12:13:12 <EvanR> there is a System.Process function which returns the result as a String
12:13:18 <shapr> ah, that would be easy
12:13:20 <EvanR> not sure if that is good
12:13:37 <shapr> I've previously used wreq
12:14:02 <shapr> EvanR: how would you split the text and count the words?
12:14:08 <geekosaur> someday someone needs to fix @pl to use bool now that it exists
12:14:11 <geekosaur> :t bool
12:14:13 <lambdabot> a -> a -> Bool -> a
12:14:24 <shapr> @src bool
12:14:25 <lambdabot> bool f _ False = f
12:14:25 <lambdabot> bool _ t True  = t
12:14:39 <EvanR> shapr: well, words ?
12:14:48 <mud> I never use 'bool', I can never remember which value is which.
12:14:57 <shapr> right is 'right' by convention
12:15:30 <shapr> EvanR: ok, how would you count them?
12:16:01 <Forlorn> Hi, I told my CTO that I really want to use Haskell for work, then he told me I may only use Javascript, Golang, or PHP, unless if I give him a very good reason why to use Haskell for work.
12:16:14 <EvanR> monad transformers ? :)
12:16:34 <Forlorn> How could I possibly convince him?
12:16:34 <EvanR> for each word, consult the Data.Map of counts so far
12:16:43 <shapr> Forlorn: write it in PHP and then change jobs and leave it for other suckers?
12:16:56 <shapr> Forlorn: what's the task?
12:17:09 <shapr> If there's good library support for your task, that could help
12:17:17 <MarcelineVQ> he should give you a very good reason to use php, muahaha
12:17:34 <ystael> Forlorn: did you know about this position when you took the job?
12:17:38 <MarcelineVQ> 'course it would be "it keeps you employed"
12:17:42 <Forlorn> "Facebook uses PHP as backend" therefore it is the "best".
12:17:46 <Forlorn> ^ his reasoning
12:17:47 <shapr> yeah, I like ystael's question
12:18:00 <shapr> Forlorn: that doesn't sound like the T in CTO stands for "Tech"
12:18:07 <[exa]> Forlorn: there's no reason why you couldn't do functional programming in PHP
12:18:40 <geekosaur> shapr, CTOs are managers of techies, not necessarily techies
12:18:56 <shapr> geekosaur: I guess I've been lucky
12:19:02 <Forlorn> ystael, nope.
12:19:47 <Forlorn> Ramda is the library that I rely upon when using JS
12:19:49 <shapr> Forlorn: managers hire tech people because they trust them to make good tech decisions, right? Do you get to influence the CTO's managerial decisions?
12:20:10 <shapr> Forlorn: do you have lots of experience writing Haskell?
12:20:16 <Forlorn> shapr, no.
12:20:30 <Forlorn> There are only two jobs in my country for Haskell it seems.
12:21:33 <Forlorn> shapr, Yes, I do get to influence the CTO if I have good arguments.
12:21:39 <shapr> hm, that's something
12:21:52 <[exa]> Forlorn: apply do-oism?
12:22:42 <[exa]> you basically want to get to "hey I have that done in haskell 10liner here, it will take X time and Y LOC to get it to PHP"
12:22:50 <eacameron> I'm looking for some Generic or TH that will define To/FromJSON instances that are very compact. I want to throw away field names, for example, and just use indexes.
12:22:59 <shapr> ooh, I like [exa]'s approach
12:23:17 <Forlorn> If I use JS then the pros are that any one could jump in to my project, easier to find someone who can replace me in case I am sick or on holidays. Same for Golang and PHP. 
12:23:41 <ystael> Forlorn: use Idris JS backend? :)
12:23:44 <Forlorn> for Node.js it has too high ram usage for microservices
12:23:46 <Gurkenglas> http://lpaste.net/2078113556733100032 how should I handle this?
12:24:12 <[exa]> Forlorn: anyway no idea about your age, but you WANT to be easily replaceable
12:24:21 <Forlorn> so he recommends using Golang, for microservices. I want to use Rust, but he refuses.
12:24:46 <Forlorn> [exa], currently, I am not easily replacable, they are highly dependant on me
12:25:35 <[exa]> Forlorn: well that creates some friction surface, doesn't it. :]
12:27:08 <[exa]> anyway, best way from that is to prototype stuff in haskell. Prototyping is a good practice, writing Haskell and then rewriting to simpler language is better than hacking in simple language, and if there will be problems with it, worst that can happen is that you see that CTO was partially right
12:27:17 <shapr> Yeah, I get to do that next week
12:27:33 <EvanR> haskell that outputs PHP code
12:27:39 <shapr> EvanR: yeah, data.map.strict is what I used for the word count
12:28:09 <EvanR> i have heard some pushback that haskell doesnt have nice syntax for Data.Map
12:28:35 <EvanR> but its the right tool for the job
12:29:48 <Forlorn> [exa], that's good advice
12:30:56 <tdammers> johnw: yes, maybe I put that in way too absolute terms
12:31:04 <Gurkenglas> This compilation fails with "Segmentation fault/access violation in generated code": http://lpaste.net/8597015614386601984
12:31:36 <remix2000> EvanR: so liftM2 applicates function over every element from both sets?
12:31:57 <EvanR> :t liftM2
12:31:59 <lambdabot> Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
12:32:20 <EvanR> its a Monad utility function, equivalent to liftA2 if you're familiar with Applicative
12:32:22 <Gurkenglas> [exa], why does he want to be easily replacable?
12:32:35 <EvanR> so what it does depends on the monad
12:32:54 <EvanR> what monad is relevant in your case?
12:34:12 <remix2000> I'm not familiar with monad, the true is
12:34:20 <remix2000> *truth
12:35:06 <remix2000> Monad is typeclass, so every deriving type has own implementation?
12:35:21 <Psybur> > liftM2 (+) (Just 1) (Just 2)
12:35:23 <lambdabot>  Just 3
12:35:35 <EvanR> each instance of Monad has its own implementation
12:35:49 <EvanR> Psybur's example was the Maybe instance
12:35:54 <EvanR> of Monad
12:36:17 <Psybur> > liftM2 (+) [1] [2,3]
12:36:18 <remix2000> > liftM2 (+) Nothing (Just 10)
12:36:20 <lambdabot>  Nothing
12:36:21 <lambdabot>  [3,4]
12:36:34 <shapr> EvanR: since your approach to word count matches my own, I'll go with it.
12:37:35 <remix2000> hmm, but every instance is about application of some function, right?
12:38:41 <Psybur> > Just 1 >> Nothing >> Just 2
12:38:43 <lambdabot>  Nothing
12:39:29 <Psybur> Monad is more about chaining things together right? Applying functions is more to do with Functors and Applicatives right?
12:41:23 <Ferdirand> until you notice that all monads are also applicatives
12:44:52 <remix2000> And then join? That's a bit confusing, as I came from languages, where that means joining array into string..
12:45:14 <EvanR> yes
12:45:41 <EvanR> > join [[1,2,3],[4,5,6],[7,8,9]]
12:45:44 <lambdabot>  [1,2,3,4,5,6,7,8,9]
12:45:47 <EvanR> :)
12:46:03 <remix2000> oh, ok :>
12:46:14 <EvanR> which is unrelated to your situation, since its not the same monad
12:46:26 <EvanR> > join (Just (Just 1))
12:46:28 <lambdabot>  Just 1
12:46:32 <EvanR> > join (Just Nothing)
12:46:35 <lambdabot>  Nothing
12:46:43 <EvanR> join is a flattening operation
12:46:48 <EvanR> of some sort
12:46:51 <EvanR> :t join
12:46:53 <lambdabot> Monad m => m (m a) -> m a
12:48:12 <remix2000> And then, is if' implemented in some module? I didn't see it in Prelude..
12:48:15 <Ferdirand> :t (>>= id)
12:48:17 <lambdabot> Monad m => m (m b) -> m b
12:48:20 <EvanR> @src if'
12:48:20 <lambdabot> Source not found. Where did you learn to type?
12:48:25 <EvanR> @src bool
12:48:26 <lambdabot> bool f _ False = f
12:48:26 <lambdabot> bool _ t True  = t
12:48:56 <geekosaur> if' is a @pl-specific hack that doesn't exist
12:49:12 <geekosaur> but bool was added some time back, it's the same thing except for parameter order
12:49:32 <geekosaur> (the Bool is the first parameter for if' as @pl imagines it)'
12:50:47 <remix2000> so, I need lambda anyway?
12:51:39 <EvanR> at some point the functions named in the @pl solution need to be defined
13:24:56 <remix2000> EvanR: I'm still a bit confused, what exactly does `join' do there.. Is it about 
13:25:20 <remix2000> *filling second argument with same input?
13:29:48 <remix2000> ok, that seems to be true.
13:30:29 <Ferdirand> :t join
13:30:31 <lambdabot> Monad m => m (m a) -> m a
13:30:42 <geekosaur> @src join
13:30:42 <lambdabot> join x = x >>= id
13:30:44 <Ferdirand> replace m with (e ->)
13:31:15 <Ferdirand> join :: e -> e -> a -> (e -> a)
13:31:52 <Ferdirand> now, because of parametricity, there is not a hundred different things this function can do
13:32:35 <johnw> (e -> (e -> a)) -> (e -> a)
13:32:38 <Ferdirand> (btw that should be (e -> e -> a) -> (e -> a), sorry)
13:32:42 <johnw> that's a rather different type
13:34:09 <remix2000> Thank you, I think that I understood.
13:34:31 <Psybur> @pl (>=>) (\a -> [show a]) (\a -> [read a]) 1 :: [Double]
13:34:32 <lambdabot> ((return . show) >=> (return . read)) 1 :: [Double]
13:36:09 <ivans> good morning haskell people
13:36:25 <shapr> GOOD MORNING!
13:36:41 <ivans> I've heard that haskell has a point-free style of programming that is similar to J's tacit style
13:37:18 <ivans> is there a good introduction to haskell that would show-case this style?
13:38:32 <Psybur> @pl (1 + 2) * 3 / 4
13:38:33 <lambdabot> 9 / 4
13:38:43 <Psybur> @pl (a + b) * c / d
13:38:43 <lambdabot> (a + b) * c / d
13:39:01 <ivans> that is impressive
13:39:05 <Psybur> xD
13:39:11 <dsal> ISTR haskellbook.com covering it a bit, but it's more of a thing that just evolves as you go.  Especially if you think about what you could reduce.
13:39:11 <ivans> I'm sold!
13:39:25 <dsal> i.e., when I write code, before I commit, I like to look to see what I can remove.
13:39:27 <sternmull> is there a good library for asynchronous stuff? I have to manage multiple external processes that depend on each others output and have to be called in some order that is determined at runtime.
13:39:30 <sternmull> I tried Elixir/Erlang and like the actor model. But unfortunately OS-processes can flood the erlang VM with their output if they just produce enough... killing the VM and/or the OS as result.
13:39:45 <dsal> sternmull: Control.Concurrent.Async
13:39:48 <ivans> in J you can basically write (f + g) like in calculus with the same meaning
13:39:52 <tdammers> point-free style is not unconditionally a good thing
13:39:53 <johnw> dsal: that's not multi-process
13:40:17 <ivans> but if I need to learn basics of haskell before appreciating point-free programming in haskell that's okay
13:40:17 <dsal> Oh, multi OS process.  I read async and erlang and stopped reading.
13:40:50 <dsal> ivans: In haskell, that's    f.g -- but note quite the same thing as point-free in general.
13:41:12 <ivans> that is function composition if I'm not wrong?
13:41:40 <dsal> Yeah.  I don't know J.  Is that not what you meant?
13:42:11 <ivans> if you have functions f and g and you want to express (f x) + (g x)
13:42:14 <ivans> for example
13:42:20 <tdammers> point-free style revolves about the observation that you can remove free variables from the end of both sides of an equation, that is, if you have f x = g x, then that is equivalent to f = g
13:42:33 <sternmull> dsal: Yes.. i don't need parallel performance, just concurrency to manage multiple OS-processes in a sane way. Python with asyncio is the least evil solution i have so far. But i am not really happy with it.
13:42:35 <ivans> tdammers: that sounds exactly like tacit style in J
13:42:48 <ivans> you can compose functions in lots of different ways
13:43:00 <Psybur> :t (+) . (*) . (/) . (**)
13:43:02 <lambdabot> (Num (((a -> a) -> a -> a) -> (a -> a) -> a -> a), Num ((a -> a) -> a -> a), Fractional (a -> a), Floating a) => a -> (((a -> a) -> a -> a) -> (a -> a) -> a -> a) -> ((a -> a) -> a -> a) -> (a -> a)
13:43:02 <lambdabot> -> a -> a
13:43:03 <ivans> and create new functions, without referring to the parameters
13:43:07 <tdammers> in this trivial example, it's better to say that f = g (i.e., f and g are the same function) than to say "for all x, applying f to x is equivalent to applying g to x"
13:43:18 <ivans> in Haskell so far I've stumbled onto just basic compositions
13:43:39 <paolino> :t liftA2 (+) 
13:43:41 <lambdabot> (Num c, Applicative f) => f c -> f c -> f c
13:43:42 <tdammers> particularly because x doesn't really add to understanding here
13:44:24 <tdammers> sternmull: how about http://hackage.haskell.org/package/process ?
13:44:49 <ivans> if I have f and g, how would I create f x (g x)
13:44:53 <tdammers> sternmull: for subprocesses, that is. you probably still want to use threading primitives from the Control.Concurrent hierarchy
13:44:56 <ivans> in J this is just (f g)
13:45:04 <paolino> :t (<*>)
13:45:06 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
13:45:10 <dsal> ivans: what are the types of f, x, and g there?
13:45:20 <Psybur> @pl f x (g x)
13:45:20 <lambdabot> f x (g x)
13:45:28 <melop> hm, Hello. I've a function that has an "Ambiguous type signature t0", and the following type sig: ":: t0 [String] -> IO ()". Since I want it to work with list, what is the class that can specify that t0 is a list?
13:45:28 <dsal> It looks like f x is a function.
13:45:42 <johnw> @pl \x -> f x (g x)
13:45:42 <lambdabot> ap f g
13:45:45 <ivans> dsal: x can be a scalar or an array, f takes two parameters, g takes one
13:45:54 <melop> (Sorry if it's not the time or the place to ask such precise beginer questions.)
13:45:57 <ivans> johnw: !!!!!
13:46:06 <johnw> you have to name the points for @pl
13:46:19 <ivans> that looks just like the thing
13:46:22 <johnw> @pl \f g x -> f x (g x)
13:46:22 <lambdabot> ap
13:46:22 <ivans> I'll read about ap
13:46:26 <dsal> ivans: Oh, I see.
13:46:28 <dsal> :t ap
13:46:29 <lambdabot> Monad m => m (a -> b) -> m a -> m b
13:46:50 <paolino> ivans: it's (<*>)
13:46:52 <ivans> @pl \f g h x -> g (f x) (h x)
13:46:53 <lambdabot> (ap .) . flip (.)
13:46:59 <ivans> paolino: thank you!
13:47:00 <geekosaur> melop, you have the list there. you haven't provided the full error but I suspect it's inferring a Trraversable
13:47:11 <ivans> Haskell seems to be very rich in operators :)
13:47:13 <dsal> I think that's a good example of point free not being clearer.  :)
13:47:16 <geekosaur> if you actually wanted just a list, it's *probably* [[String]]
13:47:30 <geekosaur> but you should include actual code and full error
13:47:36 <melop> “prevents the constraint ‘(Foldable t0)’ from being solved.”, @geekosaur
13:47:40 <ivans> dsal: it's often not the clearest way in J either, but it can be educational
13:47:48 <Psybur> @pl \a b c d -> (a +b) / c / d
13:47:48 <lambdabot> ((((/) .) . (/)) .) . (+)
13:47:49 <dsal> Yeah, I've learned a lot of good stuff from @pl
13:47:51 <dsal> Some bad stuff.
13:48:01 <ivans> I'll take the bad with the good
13:48:09 <melop> actually yes, but isn't it a general way using the class binding syntax, =>, ?
13:48:19 <ivans> <*> and `ap` seem like good things to learn
13:48:28 <Tuplanolla> Hey, ivans. Do you actually use J for something?
13:48:45 <dsal> ivans: hoogle in general, though the operator stuff seems a bit broken at the moment.
13:48:52 <geekosaur> ok, inferred Foldable instead. same answer.
13:48:59 <ivans> Tuplanolla: mainly for project euler
13:49:20 <ivans> Tuplanolla: double zero?
13:49:24 <dsal> @hoogle f x (g x) -> f' x
13:49:26 <lambdabot> Darcs.Patch.Witnesses.Unsafe unsafeCoerceP :: a wX wY -> a wB wC
13:49:26 <lambdabot> Darcs.Patch.Witnesses.Unsafe unsafeCoercePStart :: a wX1 wY -> a wX2 wY
13:49:26 <lambdabot> Darcs.Patch.Witnesses.Unsafe unsafeCoercePEnd :: a wX wY1 -> a wX wY2
13:49:26 <sternmull> tdammers: That process packages looks interesting. I already looked at "Parallel and Concurrent Programming in Haskell" and got the impression that i don't really want to build something like actors from the primitives.
13:49:34 <dsal> There, just import darcs.
13:49:37 <Tuplanolla> Oh, that's a shame, because I used it for a similar purpose years ago, ivans.
13:49:56 <Tuplanolla> I've yet to find anyone who actually builds large software systems with J.
13:50:18 <ivans> for me, project euler is so far the most important application of any programming language
13:50:36 <ivans> if you read the J forums, you'll hear that some people are using it for real world stuff
13:50:37 <dsal> ivans: I've mostly liked exercism for a bit, though they missed some good opportunities in tests.
13:51:11 <ivans> after C and J, Haskell is my third language
13:51:14 <dsal> euler has the problem of having the answer just be like, a number.  Can't do terribly complicated things.
13:51:17 <Tuplanolla> Some vague or proprietary things that might as well not exist, usually, ivans.
13:51:24 <ivans> Tuplanolla: fair enough
13:51:34 <dsal> Man, you skipped S and R and other single letters and jumped straight into Haskell?
13:51:38 <ivans> project euler is very not-real-worldy for sure
13:51:46 <ivans> dsal: I've heard of K as well :D
13:51:56 <tdammers> sternmull: you don't need to make it super complex usually
13:52:00 <ivans> some haskell solutions on the euler forums have impressed me
13:52:05 <Tuplanolla> There's D and F on the way too, dsal.
13:52:22 <dsal> I hear D is still a thing.
13:52:36 <dsal> I liked it until I tried using it for real.
13:52:40 <tdammers> last time I checked D was on the verge of becoming two things, and not in a good way
13:52:44 <ivans> there were a few in particular that were jsut [ ... | ... ] expressions in haskell
13:52:48 <ivans> that were *so* readable
13:53:16 <ivans> lazy lists are one thing that I can't handle easily in C or J
13:53:17 <dsal> Yeah, I was doing euler in lhs and some of the solutions were pretty much "I guess I should write this thing I did in ghci down"
13:53:36 <dsal> heh, your Turing machine doesn't have infinite tape?
13:53:40 <ivans> I'm already converging to using ghci instead of jconsole as a calculator
13:53:44 <ivans> )
13:54:23 <ivans> the main thing that has been holding me back has been that I really love tacit J
13:54:36 <ivans> but I see that haskell can be very terse as well
13:54:47 <paolino> ivans: https://wiki.haskell.org/Typeclassopedia , about standard composition in haskell
13:55:16 <Tuplanolla> Take a look at `Data.Function` if you haven't already, ivans.
13:55:34 <sternmull> tdammers: I hope so. This project got me to look around for languages/runtimes with elegant solutions for some basic concurrency features. And so far i couldn't find one that i am comfortable with.
13:55:49 <dsal> ivans: this extension can shorten your lines a bit, as well:  https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#unicode-syntax
13:55:56 <ivans> Tuplanolla: I haven't, I will, thank you
13:56:09 <ivans> dsal: J is all about being APL within just ascii ;)
13:56:31 <dsal> Oh, that sounds familiar.  I've managed to avoid that one.
13:56:35 <ivans> paolino: am I right in understanding that type classes are a bit like interfaces in java or c++?
13:56:50 <dsal> I wouldn't say that.
13:57:06 <dsal> They're a bit more like interfaces in go, but I wouldn't say that, either.
13:57:26 <ivans> okay, thanks
13:57:27 <dsal> I think if you think of type classes as "being like" you might be confused.
13:57:27 <lavalike> type classes are sets of types
13:57:40 <ivans> interfaces in other languages are also sets of type
13:57:42 <ivans> types*
13:57:56 <ivans> "type T implements interface I" == "T belongs to set I"
13:58:32 <ivans> I know that trying to draw analogies between wildly different languages can be a bad idea
13:58:42 <ivans> but I think it can also be useful
13:58:42 <mizu_no_oto> ivans: typeclasses are similar to interfaces, but there's some important fundamental differences
13:58:44 <dsal> This is a case where it'll be confusing.
13:58:45 <Tuplanolla> > on steroids negate 42 13
13:58:48 <lambdabot>  (-42,-13)
13:58:52 <pikajude> :t steroids
13:58:54 <lambdabot> a -> b -> (a, b)
13:59:03 <ivans> > on (,) negate 42 13
13:59:05 <lambdabot>  (-42,-13)
13:59:09 <pikajude> :k anabolic steroids
13:59:10 <ivans> I'm so on steorids
13:59:10 <lambdabot> error: Not in scope: type variable ‘anabolic’
13:59:10 <lambdabot> error: Not in scope: type variable ‘steroids’
13:59:15 <pikajude> psh
13:59:20 <Tuplanolla> Steroids, a product, pikajude.
13:59:37 <mizu_no_oto> ivans: The fundamental difference between interfaces in e.g. java and typeclasses is 'where does the implementation live?'
14:00:11 <dsal> You can't like, make a list of things that have Show instances.
14:00:26 <pikajude> ghci knows what has a Show instance!
14:00:33 <mizu_no_oto> with interfaces, you have a large 'object' that holds onto its own implementation. e.g. an object with methods
14:00:36 <ivans> you can't do that in most language I don't think
14:00:47 <ivans> "list classes/types that implement interface I"
14:01:11 <dsal> > [1, "two"] :: [Show]
14:01:14 <lambdabot>  error:
14:01:14 <lambdabot>      • Expecting one more argument to ‘Show’
14:01:14 <lambdabot>        Expected a type, but ‘Show’ has kind ‘* -> Constraint’
14:01:40 <mizu_no_oto> With typeclasses, implementation is *seperate* from your data.  Instead, the language passes the correct implementation to anywhere that needs it. (where the implementation is looked up via the type of your data).
14:02:40 <mizu_no_oto> So they're similar in that they allow you to write polymorphic code that abstracts over the kinds of operations you can do on your data.
14:02:54 <ivans> mizu_no_oto: I'll need a few minutes to process that
14:02:56 <mizu_no_oto> but they have different capabilities
14:03:06 <implementation> what package is "steroids" from?
14:03:38 <mizu_no_oto> One of the big things about typeclasses is that since the implementation isn't stored with your data, it's easy to extend types with new typeclasses
14:03:39 <int-e> :t steroids
14:03:41 <lambdabot> error: Variable not in scope: steroids
14:03:54 <int-e> implementation: somebody playing with @let
14:04:09 <implementation> ah
14:04:13 <dsal> in go, interfaces should never be declared by the thing that satisfies them.  They used by callers.  Haskell feels a little more like this, except the interface ends up being an actual type.
14:07:26 <ivans> interesting
14:07:44 <yushyin> in java interfaces are dispatched at run-time this alone is a fundamental difference to haskell’s type classes
14:08:18 <ivans> in C++ you can also define implementations (or specializations) for classes that you don't control, for interfaces that you have defined
14:08:26 <EvanR> the dictionary passing implementation of type classes is basically the same thing
14:08:57 <mizu_no_oto> ivans: another thing that's easy with type classes but typically not possible with interfaces is the ability to conditionally implement a type class based on the classes a generic parameter implements.  For example, there's an instance for `Ord a => Ord [a]`, which means that e.g. [Int] can be compared for order but [Int => Int] (lists of functions of type Int to Int) can't.
14:09:44 <ivans> mizu_no_oto: that sounds like something C++ might be able to do, in at least some cases
14:10:00 <ivans> you can specify that "pointer to T" support some interface, for any T
14:10:13 <ivans> or "vector<T>"
14:10:19 <dsal> "something C++ might be able to do" is not really a metric.  They try to make sure C++ can do anything.
14:10:26 <mizu_no_oto> Whereas in Java, you can't say that List<A> implements Comparable<List<A>> iff A implements Comparable<A>.
14:10:29 <ivans> we sure do
14:10:39 <ivans> mizu_no_oto: duly noted
14:11:03 <ivans> so far I only have experience with a dynamically typed J and a statically typed C/C++
14:11:16 <ivans> I'm willing to accept that haskell is not comparable to either one
14:11:32 <ivans> but learning the similiraties will help learn the differences
14:11:44 <MrSkeltal> haskell is pretty close to C++ templates
14:11:54 <mizu_no_oto> Also, as yushyin alludes to, type classes are actually entirely static
14:11:58 <MrSkeltal> but there's actual math behind it not just gut feelings and SFINAE
14:12:01 <sternmull> ivans: C++ templates use "ducktyping", Haskell doesn't.
14:12:31 <MrSkeltal> sternmull, you mean duck-kinding?
14:12:42 <MrSkeltal> or lack of constraints?
14:12:43 <mizu_no_oto> In that the correct implementation is passed to use sites at compile time.
14:12:45 <ivans> duck duck
14:13:09 <mizu_no_oto> whereas interfaces are generally dynamic
14:13:15 <MrSkeltal> mizu_no_oto, well that depends
14:13:23 <MrSkeltal> 0 is a function that takes a context dictionary
14:13:35 <Tuplanolla> Don't C++ compilers generate specialized code for each instance of a template?
14:13:48 <ivans> Tuplanolla: yes
14:13:53 <MrSkeltal> the call can be inlined if used in a monomorphic context
14:14:01 <Tuplanolla> We don't usually do that.
14:14:19 <ivans> Tuplanolla: but you can avoid that, and for example create just one implementations for each "pointer to T"
14:14:40 <sternmull> MrSkeltal: In C++ there is no direct constraint for a template parameter like "has to support a specific interface" instead the code just uses methods on it (like doing T x; x.read();). You have to read the documentation of the class template to know what T has to support. In Haskell this is forced by requiring T to implement a type class.
14:15:01 <MrSkeltal> sternmull, right
14:15:15 <ivans> sternmull: are the type class requirements checked by the compiler?
14:15:26 <sternmull> yes
14:15:41 <MrSkeltal> ivans, they aren't only checked but it like wouldn't work at all without them
14:15:52 <mizu_no_oto> ivans: another really fun thing is that because typeclasses are statically determined, they allow you to be polymorphic in the *return type* of functions, and allow you to get polymorphic values.
14:15:57 <mizu_no_oto> :t 0
14:15:58 <lambdabot> Num p => p
14:16:04 <mizu_no_oto> >0 :: Float
14:16:09 <mizu_no_oto> > 0 :: Float
14:16:11 <lambdabot>  0.0
14:16:14 <mizu_no_oto> > 0 :: Int
14:16:17 <lambdabot>  0
14:16:42 <ivans> > 0 :: Boolean
14:16:46 <lambdabot>  error:
14:16:46 <lambdabot>      Not in scope: type constructor or class ‘Boolean’
14:16:48 <ivans> > 0 :: Bool
14:16:51 <lambdabot>  error:
14:16:51 <lambdabot>      • No instance for (Num Bool) arising from the literal ‘0’
14:16:51 <lambdabot>      • In the expression: 0 :: Bool
14:16:55 <ivans> hoooo
14:16:56 <mizu_no_oto> > 0 :: Complex Float
14:16:58 <lambdabot>  0.0 :+ 0.0
14:17:05 <MrSkeltal> > 0 :: CReal
14:17:07 <lambdabot>  0.0
14:17:08 <ivans> I will need to digest this
14:17:16 <MrSkeltal> well 0 is boring
14:17:20 <mizu_no_oto> Booleans aren't numeric in Haskell ^
14:17:24 <sternmull> MrSkeltal: "duck typing" basically means that you call things by a name and hope that it does what you think the name should do. If you call "quack" on something then you expect it to do so.
14:17:37 <MrSkeltal> sternmull, yeah that's kind of what traits are trying to address
14:18:10 <mizu_no_oto> one of the cool things about that is you can define a new numeric type (scientific notation?) and the built in numeric literals will Just Work(tm) for it.
14:18:16 <MrSkeltal> ivans, check this out
14:18:22 <MrSkeltal> > return "foo" :: Maybe String
14:18:25 <lambdabot>  Just "foo"
14:18:26 <MrSkeltal> > return "foo" :: [String]
14:18:29 <lambdabot>  ["foo"]
14:18:40 <MrSkeltal> > return "foo" :: WriterT () Identity String
14:18:43 <lambdabot>  WriterT (Identity ("foo",()))
14:18:58 <ivans> MrSkeltal: I'm opening another beer just for this
14:19:00 <dsal> :t return
14:19:00 <mizu_no_oto> Or, for something that you probably shouldn't use
14:19:01 <lambdabot> Monad m => a -> m a
14:19:12 <mizu_no_oto> > read "True" :: Bool
14:19:14 <lambdabot>  True
14:19:19 <mizu_no_oto> > read "True" :: Int
14:19:21 <lambdabot>  *Exception: Prelude.read: no parse
14:19:24 <implementation> > (return "Baum") 5
14:19:27 <lambdabot>  "Baum"
14:19:33 <dsal> readEither "True" :: Either String Bool
14:19:35 <dsal> > readEither "True" :: Either String Bool
14:19:38 <lambdabot>  error:
14:19:38 <lambdabot>      • Variable not in scope: readEither :: [Char] -> Either String Bool
14:19:38 <lambdabot>      • Perhaps you meant one of these:
14:19:45 <ivans> darn
14:19:46 <dsal> heh.  I like that error.
14:19:46 <implementation> > snd (return "Baum")
14:19:49 <lambdabot>  error:
14:19:51 <lambdabot>      • Ambiguous type variable ‘a0’ arising from a use of ‘return’
14:19:53 <lambdabot>        prevents the constraint ‘(Monoid a0)’ from being solved.
14:20:20 <MrSkeltal> gotta monomorphize
14:20:52 <implementation> > fst (return "Baum") :: String
14:20:55 <lambdabot>  ""
14:21:13 <MrSkeltal> ivans, actually I recently came up with a fairly fascinating framework
14:21:21 <MrSkeltal> where you assemble a polymorphic monad
14:21:21 <ivans> > (return "Baum") :: (String, a)
14:21:25 <lambdabot>  error:
14:21:25 <lambdabot>      • Couldn't match type ‘a1’ with ‘[Char]’
14:21:25 <lambdabot>        ‘a1’ is a rigid type variable bound by
14:21:30 <MrSkeltal> and depending on which type you use it at,
14:21:37 <MrSkeltal> it's either a parser or enumerator of all sentences
14:21:50 <ivans> o_O
14:22:17 <Tuplanolla> > over (from enum) (\ x -> 1 - x) False -- Booleans don't need to be numeric where we're going.
14:22:20 <lambdabot>  True
14:22:26 <implementation> MrSkeltal: what's its name?
14:22:31 <[exa]> MrSkeltal: sounds a bit like prolog
14:22:36 <MrSkeltal> implementation, well it's built on top of yoctoparsec
14:22:47 <implementation> might be useful for me :)
14:23:00 <MrSkeltal> I go from "FreeT ((->) t) b a" to "FreeT (y t) b a"
14:23:14 <MrSkeltal> where, no pun intended,
14:23:21 <MrSkeltal> y~Reader to read, y~Writer to write
14:24:09 <[exa]> MrSkeltal: ok sorry for marking it as prolog :]
14:24:11 <MrSkeltal> there it is
14:24:15 <MrSkeltal> @letlpaste 358149
14:24:17 <lambdabot>  Defined.
14:24:33 <MrSkeltal> now lemme fit my crappy digit parser
14:25:02 <MrSkeltal> it needs an Omega monad among other things because [] cannot diagonalize infinite lists
14:26:15 <implementation> what is the Omega monad?
14:26:37 <implementation> ah, found it on hackage
14:27:32 <ivans> @pl f g x y -> f x (g y)
14:27:32 <lambdabot> (line 1, column 11):
14:27:32 <lambdabot> unexpected '>'
14:27:32 <lambdabot> expecting operator
14:27:49 <ivans> @pl \f g x y -> f x (g y)
14:27:49 <lambdabot> flip . ((.) .)
14:27:56 <ivans> "okay"
14:28:15 <geekosaur> it's gone flipping dotty again >.>
14:28:24 <ivans> @pl \f g h x y -> g (f x y) (h x y)
14:28:25 <lambdabot> (liftM2 ap .) . flip ((.) . (.))
14:28:27 <implementation> MrSkeltal: thanks a lot, I tried to build something like this a while ago, but failed with my approach
14:28:34 <MrSkeltal> found it
14:28:44 <ivans> (.) . (.)
14:28:51 <ivans> am flipping
14:30:14 <MrSkeltal> @let digit = asum $ map (\x -> x <$ token (intToDigit x)) [0..9]
14:30:16 <lambdabot>  Defined.
14:30:19 <MrSkeltal> @let int = fmap (foldl (\x y -> x * 10 + y) 0) int' where int' = fmap return digit <|> liftA2 (:) digit int'
14:30:21 <lambdabot>  Defined.
14:30:23 <MrSkeltal> :t int
14:30:25 <lambdabot> error:
14:30:25 <lambdabot>     Ambiguous occurrence ‘int’
14:30:25 <lambdabot>     It could refer to either ‘Text.PrettyPrint.HughesPJ.int’,
14:30:27 <MrSkeltal> :t L.int
14:30:29 <lambdabot> (Functor (f Char), YMode f, MonadPlus b) => FreeT (f Char) b Int
14:30:30 <ivans> @ty fmap fmap fmap
14:30:33 <lambdabot> (Functor f2, Functor f1) => (a -> b) -> f1 (f2 a) -> f1 (f2 b)
14:30:59 <missourimorphism> does anyone know if there is a well accepted library for knowledge bases, logic, etc to be used for implementing an expert system?
14:31:04 <MrSkeltal> so yeah, consider this
14:31:13 <MrSkeltal> > runOmega $ parse int "123"
14:31:16 <lambdabot>  error:
14:31:16 <lambdabot>      Ambiguous occurrence ‘int’
14:31:16 <lambdabot>      It could refer to either ‘Text.PrettyPrint.HughesPJ.int’,
14:31:18 <MrSkeltal> > runOmega $ parse L.int "123"
14:31:22 <lambdabot>  [(1,"23"),(12,"3"),(123,"")]
14:31:25 <MrSkeltal> > runOmega $ enumerate L.int
14:31:29 <lambdabot>  [(0,"0"),(1,"1"),(0,"00"),(1,"01"),(2,"2"),(0,"000"),(10,"10"),(1,"001"),(11...
14:31:46 <implementation> very nice indeed
14:32:19 <implementation> and probably great for computational morphology
14:32:40 <MrSkeltal> now I wish I could make YMode less awkward
14:32:57 <MrSkeltal> it's a functor of variable variance....
14:33:01 <ivans> @ty (***)
14:33:03 <lambdabot> Arrow a => a b c -> a b' c' -> a (b, b') (c, c')
14:33:57 <MrSkeltal> oh I know what it is
14:34:08 <MrSkeltal> it's like lens
14:34:10 <MrSkeltal> but for parsers
14:34:36 <MrSkeltal> you give it a co/contra variant reader/writer and it gives you a co/contra variant reader/writer for a larger structure
14:34:58 <MrSkeltal> how crazy is that
14:35:12 <ivans> quite crazy if you ask me
14:35:22 <ivans> crazy enough that I have no idea what you said
14:35:33 <implementation> did you try to find an YMode implementation for Either? maybe that could do something sensible too (don't ask me what)
14:35:34 <MrSkeltal> well it would make more sense if you knew what lens is
14:36:32 <ivans> I'm still reading step 1. Understand the types
14:36:40 <ivans> I'm sure I'll get to lens later
14:37:07 <MrSkeltal> implementation, hmm
14:37:13 <MrSkeltal> that would be a weird twist on FreeT
14:38:11 <MrSkeltal> I'm fairly sure it's just Free b a
14:38:59 <MrSkeltal> much like "Fix (Compose (a,) (a,))" is still Stream a
14:38:59 <ivans> a freebie?
14:39:16 <MrSkeltal> ivans, that's a datatype
14:39:39 <implementation> "tkn = Left" and "tkn = Right . pure" don't really make any sense :/
15:07:40 <ivans> @pl \e f g h x y -> e x (g (f y) (h y))
15:07:40 <lambdabot> (. ((ap .) . flip (.))) . (.) . (.) . flip . ((.) .)
15:07:48 <ivans> lambdabot: t
15:08:32 <ivans> (I'm trying to express what in J is (e f g h))
15:12:32 <u0_a262> whsts news ?
15:13:49 <ratherAnonymous[> This meme is the reason I'm here lol: https://www.youtube.com/watch?v=RqvCNb7fKsg
15:14:17 <Tuplanolla> @google haskell weekly news
15:14:18 <lambdabot> https://haskellweekly.news/
15:25:44 <erisco> \e f g h -> liftA2 e <$> pure <*> pure (g <$> f <*> h)
15:26:40 <ivans> so much pure
15:26:48 <ivans> I like my code a bit dirty
15:26:57 <erisco> use const, then
15:28:07 <Tuplanolla> :t dirty -- This is what you need then.
15:28:08 <lambdabot> Comonad w => w a -> a
15:28:26 <ivans> ofcoursethatsathing
15:29:13 <ivans> I think I'm ready to start appreciating haskell on its own and forget J-to-haskell conversions
15:30:04 <hpc> Tuplanolla: that's almost as funny as hasslich from acme-schoen
15:31:42 * ivans laughs in russian
15:33:37 <merijn> ivans: You mean you realised that code should sometimes consist of more than 30 unicode characters? :p
15:34:15 <ivans> merijn: that's what certain APL guys realized in the early 90's :P
15:34:18 <ivans> J is all ascii
15:35:11 <merijn> ivans: I know, but still!
15:35:48 * [exa] finally found time to appreciate the acme-php homepage
15:37:07 <merijn> ivans: I was at a workshop on array programming a few years back where a guy was presenting a compiler for an APL-derived language, in said language. He was proudly saying "here's one compiler pass, look how elegant it is". And it was basically an 80x25 character block of line noise >.>
15:37:19 <ivans> come on, http://code.jsoftware.com/wiki/Essays/Game_of_Life is way more readable than https://dfns.dyalog.com/c_life.htm
15:37:27 <merijn> [exa]: You should see the source! :p
15:37:32 <hpc> [exa]: i totally forgot i added that
15:38:20 <ivans> whether my last line needs a /s tag is up to each reader
15:39:08 <[exa]> oh noes
15:39:09 <[exa]> too good
15:39:14 <merijn> ivans: You know...it might've been Dyalog (I couldn't recall anything beyond something involving a D, Y, and A)
15:39:38 <ivans> dyalog APL has adopted some features from J very recently
15:39:42 <ivans> as in, in the past 5 years
15:39:44 <merijn> hpc: Nice
15:40:12 <merijn> hpc: I just remembered I registered lambdacats.org to save it for posterity
15:40:39 <ivans> but I find it funny that in math single-letter names like R, Q, Z, N are completely normal, while in programming those would be "unreadable"
15:41:10 <ivans> learning programming with a math background is fun
15:41:22 <hpc> merijn: i remember you talking about that years ago
15:41:23 <erisco> meh, programmers can suck it up
15:41:26 <merijn> ivans: That's not true in Haskell :)
15:41:33 <ystael> ivans: tried a couple times to learn J, bounced off each time due to nothing I really wanted to make it do
15:41:41 <merijn> @quote the.first.26.are
15:41:42 <lambdabot> No quotes match. Abort, Retry, Panic?
15:41:44 <merijn> hmm
15:41:46 <ystael> but I left with the impression that Ken Iverson was a mad genius ... emphasis on "mad"
15:41:47 <merijn> @quote the.first.26
15:41:47 <lambdabot> No quotes match.
15:42:08 <ivans> I'd emphasize genius
15:42:12 <hpc> @quote my.first.26
15:42:13 <lambdabot> alexbagel says: i find that my first 26 variables are always easy to name. after that it becomes a bit harder.
15:42:29 <ivans> floor, ceiling, and some other math notations were pioneered by him
15:42:34 <merijn> Clearly he hasn't heard of Cantor ;)
15:42:35 <ivans> now they're obvious
15:42:48 <[exa]> acme-php is full of hate, 41
15:43:05 <[exa]> me saves it for students in the next semester
15:43:14 <merijn> I'm a big fan of acme-dont and acme-lookofdisapproval
15:43:18 <ivans> Knuth's books keep pointing out how "K. Iverson invented this thing in the early 60's"
15:43:20 <hpc> wait, you're going to /teach/ with acme-php?
15:43:50 <merijn> Although my favourite thing of acme-lookofdisapproval is the fact that it's wrong for GHC to compile it due to an obscure bug in the Haskell spec :p
15:44:47 <[exa]> hpc: it's for 4th semester bachelor students, they are only starting to feel that something is wrong with PHP
15:45:13 <ystael> [exa]: my brain has been seared and you are responsible for any resulting medical bills
15:45:27 <[exa]> oh how?
15:45:28 <[exa]> :D
15:45:59 <[exa]> hpc: making fun of it is a great start of trying to fix it
15:46:28 <merijn> In that case I'm fixing so many things!
15:51:26 <[exa]> "Control.Comonad is a double-dual module name. This package fixes that."
15:51:40 <[exa]> guys srsly
15:52:01 <[exa]> this is too good
15:58:02 <MrSkeltal> in the ghci debugger, is it possible to "block" an exception?
15:58:11 <hpc> what do you mean by block?
15:59:59 <MrSkeltal> well I'm using -fbreak-on-exception and a Ctrl-C
16:00:09 <MrSkeltal> I would like to not propagate the Ctrl-C
16:01:03 <hpc> ah, i don't know if that's actually an exception
16:01:18 <hpc> i think it gets handled as a posix signal kind of thing
16:01:19 <merijn> ctrl-c is a signal
16:01:29 <merijn> The default signal handler for ctrl-c throws an exception
16:01:30 <MrSkeltal> it seems to be turned into an exception
16:01:37 <merijn> You can just change that signal handler, though
16:02:45 <merijn> System.Posix.Signals from the unix package
16:02:53 <merijn> No clue how windows comes into it
16:03:44 <geekosaur> https://downloads.haskell.org/~ghc/latest/docs/html/libraries/Win32-2.5.4.1/System-Win32-Console-CtrlHandler.html
16:03:59 <MrSkeltal> cannot set breakpoint on sig: module interactive:Ghci1 is not interpreted
16:04:03 <MrSkeltal> oh fascinating
16:06:17 <MrSkeltal> well
16:06:18 <MrSkeltal> this sucks
16:06:41 <geekosaur> did you use -fobject-code? tat will kinda defeat breakpointing
16:06:46 <MrSkeltal> no
16:07:12 <hpc> i bet the default signal handler is compiled
16:07:23 <geekosaur> oh. yes
16:08:00 <MrSkeltal> funny
16:08:10 <MrSkeltal> breaking on a signal handler produces... cruious results
16:09:12 <MrSkeltal> ugh
16:09:20 <MrSkeltal> how hard is it to obtain a stacktrace anyway
16:10:40 <ivans> a stack you say
16:11:30 <MrSkeltal> one of these days it's going to drive me insane
16:11:47 <geekosaur> haskell doesn;t actually have a call stack. it has an evaluation/reduction/pattern matching stack
16:11:50 <ivans> it's easier if you're already insane and have nothing to lose
16:11:55 <MrSkeltal> geekosaur, I know that very well
16:11:57 <geekosaur> which is why it's kinda hard to get anything useful
16:12:19 <MrSkeltal> geekosaur, where's my evaluation stack?
16:13:35 <geekosaur> hm, right, there is https://downloads.haskell.org/~ghc/latest/docs/html/libraries/base-4.10.0.0/GHC-ExecutionStack.html if the rts was built for it
16:14:57 <MrSkeltal> well it wasn't
16:14:59 <geekosaur> and you have 8.2.x
16:15:14 <MrSkeltal> I do have 8.2.1
16:15:21 <MrSkeltal> yet still
16:15:36 <geekosaur> https://downloads.haskell.org/~ghc/latest/docs/html/libraries/base-4.10.0.0/GHC-Stack.html
16:15:37 <MrSkeltal> I have had to pull the evaluation stack out of registes before
16:15:44 <MrSkeltal> it escapes me why no one implemented that yet
16:15:59 <geekosaur> but profiling call stacks requires a profiled build (of ghci in your case)
16:16:43 <MrSkeltal> profiling call stacks try to imitate imperative call stacks
16:17:50 <MrSkeltal> I understand the overhead/instrumentation required for that
16:18:15 <MrSkeltal> evaluation stack requires the same effort as 'bt' in gdb
16:18:25 <MrSkeltal> walking a linked list and translating addresses to symbol names
16:30:32 <ironChicken> can anyone point to an example of how to do one of those newtype wrapper things to avoid the orphaned instance ghc warning?
16:33:48 <ironChicken> i'm thinking of those ones where you create a record value constructor with with a single "un..." field, but i just can't find any examples
16:34:09 <fishythefish> ironChicken: don't have an example offhand, but what's the confusion?
16:34:55 <fishythefish> use newtype to wrap the type you're trying to define the instance for, then implement the instance for it
16:35:21 <fishythefish> the "un..." field is a common idiom that is separate from the question of orphan instances
16:36:06 <Axman6> ironChicken: there's plenty of Monoids that do this, like Sum, Prod, First, Last, Endo, Const
16:36:17 <fishythefish> newtype WrapperType = WrapperType { unWrap :: BaseType }
16:36:35 <fishythefish> instance Foo WrapperType where ...
16:39:19 <ironChicken> fishythefish: thanks, i think i can do that
16:42:05 <crucify_me> hi there's something I've tried to read about but still don't get : the core functions in ghci are referred to only by the signature; one cannot see how they are written . there is the signature and examples (in hoogle and the zvon site). what am I missing? 
16:43:09 <crucify_me> so should I assume that it doesn't matter as long as you get the expected result?
16:45:17 <ironChicken> http://lpaste.net/359705
16:45:30 <ironChicken> not really sure what i'm doing
16:46:48 <ironChicken> Stream is from parsec
16:48:21 <fishythefish> crucify_me: can you give an example function?
16:49:08 <crucify_me> like    find :: (a -> Bool) -> [a] -> Maybe a
16:49:41 <crucify_me> I wrote find as an exercise using key/value pairs
16:49:45 <dmwit> source for `find` is here: https://hackage.haskell.org/package/base-4.10.0.0/docs/src/Data.Foldable.html#find
16:50:10 <dmwit> You can get this yourself by searching for `find` in Hoogle, clicking the correct result, then clicking the "Source" link to the right of its type signature.
16:50:31 <fishythefish> dmwit is too fast for me
16:50:39 <reem> so has anyone seen the toy interview problem about how to serialize and deserialize a binary tree with parens? e.g. (1, (2, (3, 4)), 5)
16:50:47 <crucify_me> dmwit: thanks its a different signature 
16:50:53 <reem> Serialization is pretty straightforward recursion
16:51:08 <reem> But deserialization has me pretty curious - it should be possible to do this in linear time
16:51:14 <fishythefish> crucify_me: that's because of FTP
16:51:22 <reem> But I’m struggling to see how to structure my zipper to do that
16:51:23 <dmwit> reem: Recursive descent should work fine for such a simple grammar.
16:51:28 <fishythefish> it's the function you're looking for, but you can look at an older version of base
16:51:46 <Axman6> crucify_me: that ptobably means you're using an older GHC version
16:52:00 <reem> dmwit: yeah, I guess what I mean is that I know how to do it (it’s not a very hard problem) but I’m curious how I would do this in like, the most Haskell way
16:52:10 <crucify_me> really? I thought it was current
16:52:16 <reem> i.e. how do I this using a zipper and in linear time
16:52:23 <dmwit> reem: The most Haskell way? Probably Parsec will already get you linear time.
16:52:27 <reem> And not O(n log(n))
16:52:40 <fishythefish> ironChicken: your newtype should just be wrapping Vector a
16:53:06 <fishythefish> it doesn't make sense to wrap Stream ... since Stream is not a datatype
16:53:17 <reem> dmwit: wouldn’t straightforward recursive descent still get you O(n logn) here? You need to pop log(n) stack frames to go back up the tree to insert the next sibling
16:53:39 <fishythefish> crucify_me: what is your ghc version?
16:53:48 <dmwit> No, you need only pop 1 stack frame per closing parenthesis, not log(n) frames.
16:55:24 <reem> Am I just thinking about this wrong because the serialized form is actually O(n * log(n)) in length
16:55:29 <reem> If n = the number of nodes in the tree
16:55:48 <dmwit> The serialized form is not n*log(n) long. It is O(n) long.
16:56:24 <reem> Sorry I think I’ve just confused myself
16:56:33 <reem> Trying to be fancy
16:56:45 <crucify_me> fishythefish: stack --version => 1.5.1
16:57:10 <fishythefish> crucify_me: that's your stack version, not ghc/base
16:57:11 <reem> My thought process was something along the lines of: parse the string into basically an upside down representation of the tree, then construct the actual tree in one go from there
16:57:17 <crucify_me> onee sec
16:57:21 <reem> But I guess I can just use the stack to represent the upside down tree
16:57:28 <reem> And just construct the tree as I go back up the stack
17:01:51 <crucify_me> fishythefish: $ stack ghc --version    => Version 1.5.1 x86_64 hpack-0.17.1
17:02:42 <crucify_me> I run everything on stack ghc with an alias
17:02:56 <Axman6> which version of ghc?
17:03:15 <fishythefish> crucify_me: then which resolver are you using?
17:03:24 <Axman6> the stack version doesn't mean anything because it supports many GHC versions
17:04:10 <crucify_me> I don't know does ghc-8.0.2 sound right?
17:04:33 <crucify_me> the above command gives me a long output
17:04:40 <fishythefish> 8.0.2 is your ghc version, yes
17:04:46 <fishythefish> the resolver will begin with lts...
17:05:42 <dmwit> ?undefine
17:05:43 <lambdabot> Undefined.
17:06:03 <dmwit> ?let import qualified Text.ParserCombinators.Parsec as P
17:06:05 <lambdabot>  Defined.
17:06:07 <fishythefish> crucify_me: and running :t find in your ghci gives you find :: (a -> Bool) -> [a] -> Maybe a?
17:06:17 <dmwit> ?let data LTree a = Leaf a | Branch (LTree a) (LTree a) deriving (Eq, Ord, Read, Show)
17:06:19 <lambdabot>  Defined.
17:06:32 <dmwit> > let tree = do { P.char '('; l <- tree; P.char ','; r <- tree; P.char ')'; return (Branch l r) } <|> (Leaf <$> P.anyChar) in P.parse (tree <* P.eof) "" "(1,(2,3))"
17:06:35 <lambdabot>  Right (Branch (Leaf '1') (Branch (Leaf '2') (Leaf '3')))
17:06:43 <dmwit> reem: ^^
17:07:22 <reem> nice
17:08:20 <crucify_me> no its the longer signature with foldable as dmwi*t  (after import Data.List)
17:08:34 <crucify_me> posted
17:09:10 <fishythefish> right, okay
17:09:34 <fishythefish> er, I think I missed something
17:09:39 <fishythefish> how did the old signature get involved?
17:11:13 <foobar_> Is there a clean way to recover from a C call to exit() from a Haskell FFI call?
17:11:18 <crucify_me> sorry, I think it was a dumb-down version for a textbook assignment to write my own .. thanks I can go with new version .. I need to study foldables more thanks fishythefish
17:11:27 <foobar_> I can't seem to avoid execution halting right then and there.
17:11:41 <geekosaur> there is not
17:11:47 <fishythefish> crucify_me: don't feel pressured to make the jump straight to Foldable. I believe GHC.OldList contains the old definitions
17:12:02 <geekosaur> exit is a system call, tells the kernel to terminate the process immediately
17:12:17 <fishythefish> crucify_me: alternatively, look at the source for an old version of Base
17:12:22 <Tuplanolla> Can you not instruct the linker to replace `exit` before starting, geekosaur?
17:12:32 <crucify_me> I went through foldl foldr .. so I get the main gist thanks
17:12:44 <foobar_> geekosaur ok so the only thing to do is prevent the exit condition...
17:12:59 <foobar_> Tuplanolla how would you even instruct a linker to do  such a thing
17:13:19 <geekosaur> Tuplanolla, maybe if you are careful about ut. not sure you can have it repalce only some of them, and it'd be kinda bad if the runtime also can't shut the process donw
17:13:51 <Tuplanolla> Read up on `LD_PRELOAD` and `dlfcn.h`, foobar_.
17:13:57 <geekosaur> foobar_, by changing what symbols dynamic loading uses (obviously this won't work if it's static)
17:17:35 <ironChicken> fishythefish: thanks, yes, i see what i was doing wrong and now it's all working and i have 0 compiler warnings :-)
17:25:06 <foobar_> geekosaur Tuplanolla never came across that, is there a precedent for doing that, seems kind of dicey to swap out such a basic operation
17:25:13 <foobar_> thanks I will look into it btw
17:25:32 <geekosaur> I did say it was something of a bad idea
17:25:39 <Tuplanolla> It's a fragile idea, but better than nothing, foobar_.
17:25:59 <Tuplanolla> (For example SELinux will give you a hard time if you try.)
17:26:10 <foobar_> well the alternative is manually dealing with the preconditions prior to the FFI call
17:26:31 <foobar_> which is probably the route I'll go. if there was a way to catch the exit condition as an exception
17:26:44 <foobar_> that would be less work, but it sounds like there's not a straightforward way of doing that
17:26:55 <geekosaur> exceptions from different languages don;t usually mix
17:27:13 <geekosaur> and C doesn't have exceptions as such. it has signals but exit isn't a signal
17:27:33 <foobar_> was thinking more along the lines of the capturing the C exit() as a Haskell exception
17:28:23 <geekosaur> how were you expecting arbitrary C code to throw a Haskell exception?
17:30:00 <foobar_> I wasn't expecting it... that's why I asked the question. and it's not arbitrary per se, it's a specific condition - system calls to exit.
17:33:04 <foobar_> on another topic, does microlens (or some other "mini"-lens library) cover tuple accessors?
17:33:45 <Tuplanolla> Yes to `microlens`.
17:33:59 <foobar_> not looking for anything fancy, really just  looking for clean nice accessor api
17:34:15 <foobar_> which module in microlens has tuple getters?
17:34:43 <foobar_> oh I think I see
17:34:49 <foobar_> ^. in Lens.Micro it seems
17:37:45 <Axman6> that seems unlikely, in the lens package  the accessors are _1, _2 etc
17:38:24 <geekosaur> I would be very surprised if ^. did something completely different in microlens than it does in lens
17:39:11 <Axman6> right, ^. is the functions which takes a value and an lens and reutrns the focus pointed to by that lens in value
17:55:41 <foobar_> Axman geekosaur meant tupVar ^. _1 
17:55:58 <foobar_> which I guess is the same as lens
17:58:52 <foobar_> is there a way to overload those tuple accessors
17:58:53 <foobar_> ?
17:59:22 <foobar_> in microlens. For example if I have a type MyType { x :: (Int, Int, Int) } 
17:59:25 <Axman6> in lens they are, they each come from a typeclass
17:59:40 <foobar_> I can do something like MyType (1,2,3) .^ _2
17:59:56 <foobar_> instead of x (MyType (1,2,3)) .^ _2
18:00:01 <foobar_> which is easy enough but more verbose
18:00:20 <Axman6> so you could have instance Field1 MyType Int where _1 = to x . _1
18:00:32 <Axman6> (maybe to isn't the right thing)
18:00:55 <Kiro> does anyone here know any good game engines in haskell? I came across helm but dont know how good it is
18:01:44 <Kiro> I have to do a final project in haskell for a class and I'm a beginner, so not sure if a game is the best idea, unless anyone else has suggestions for project ideas
18:01:46 <foobar_> Kiro helm is universally _not_ recommended
18:01:54 <Kiro> oh lol
18:02:18 <foobar_> game is a challenge but probably doable  but I would keep aspirations light as it's not a common problem
18:02:34 <Axman6> there's been a few projects to build games in haskell but I wouldn't say there are any really good "engines"
18:02:36 <foobar_> probably the simplest thing is gloss or not-gloss + FRP
18:02:39 <Kiro> any other project suggestions for beginners?
18:02:48 <foobar_> gloss or not-gloss
18:03:03 <foobar_> if you want to be ambitious can try SDL/opengl, but I wouldn't recommend that for a beginner
18:03:17 <Kiro> oh im just looking for 2D, like tetris or something
18:03:24 <foobar_> this seems at the level of a class project - https://www.youtube.com/watch?v=-IpE0CyHK7Q
18:04:02 <Kiro> thanks for the link, whoa that seems cool
18:04:07 <foobar_> might be a little out of date, but i wouldn't tackle much more than that for a class
18:04:43 <foobar_> nowadays reflex seems to be more in vogue than yampa for FRP (although it's a pita to get up and running it seems)
18:05:10 <Kiro> my main interest is in machine learning, which i do in python, but im nowhere near ready in haskell to tackle a project like that
18:05:21 <foobar_> Kiro my main interest is machine learning as well
18:05:38 <foobar_> i'm actually working on an ambitious-ish project in that
18:05:48 <Axman6> Grenade exists for ML in Haskell, it's pretty neat
18:05:55 <Kiro> in haskell? yea came across that
18:06:25 <foobar_> yes in haskell, also related to deep learning, but not ready for public consumption
18:06:44 <foobar_> ping me in about 6-8 weeks. hopefully people will like it when it's ready
18:07:11 <Kiro> sure haha
18:08:09 <foobar_> good luck with the game ;-)
18:09:02 <foobar_> btw if you want to find some inspiration for the upper-end of graphics in haskell see https://github.com/ekmett/quine
18:09:10 <Kiro> thanks. normally id go for something like lambda calc or idk but those ideas were taken :(
18:09:12 <foobar_> i wouldn't try to take that on for a school project though
18:09:26 <Kiro> damn lol
18:09:28 <Axman6> going graphics in Haskell is the reason lens exists btw
18:09:50 <Axman6> Ed wanted a nice way to talk about vectors
18:10:08 <foobar_> Axman6 really I didn't know the history. i know kmett has an interest in both but that man has an interest in everything
18:10:26 <Axman6> yes he does
18:10:49 <Kiro> there isnt any computational neuroscience in haskell, im assuming, right?
18:11:07 <foobar_> i'm excited for the machine learning + haskell space though... there's something in the air I think
18:11:15 <Axman6> it wouldn't surprise me if there were someone doing it
18:11:18 <foobar_> potential that hasn't been tapped
18:11:33 <Kiro> well most of it is done in python which makes sense
18:11:47 <foobar_> Kiro hmm bio + haskell is scarce right now
18:12:04 <Kiro> yea i tried looking around
18:12:14 <foobar_> there's probably like <10 people that are tackling it seriously and I'd be surprised if any of them happen to be doing neuro
18:12:32 <foobar_> what there is seems to be spurts in 'omics
18:12:37 <Axman6> checko out bioshake. it's more an EDSL for the tools which do bio stuff, but still really cool and being build for that particular area
18:12:44 <foobar_> but it's mostly one or two smart people at a time that tackles it and then gets bored
18:12:46 <Kiro> sure will do
18:13:11 <foobar_> there's less of a critical mass for haskell+bio than there is for haskell+data science
18:13:36 <foobar_> i'd only consider bio if you have a project that's relatively standalone and green field.
18:14:36 <foobar_> e.g. you're implementing some custom simulation from scratch or something like that... or doing some statistical modeling that you could offload to stan or something.
18:14:57 <Kiro> stan?
18:15:49 <foobar_> covers all of bayesian stats
18:15:59 <foobar_> probabilistic programming DSL
18:16:06 <Kiro> oh thanks, ill check that out anyways
18:16:22 <foobar_> the nice thing is if you can use Stan you don't need all the stats ecosystem. there's the beginnings of an interface at:
18:16:29 <foobar_> https://github.com/diffusionkinetics/open
18:16:39 <foobar_> see the stanhs folder
18:16:56 <foobar_> and background on stan http://mc-stan.org/
18:17:29 <Kiro> whoa thats dope. thank u@
18:17:30 <Kiro> !
18:17:33 <foobar_> that's an interesting thing about these DSLs, you can circumvent needing a language-specific ecosystem if you can create pleasant interfaces to the DSLs
18:17:59 <foobar_> bayes/stan is a much better way to do stats anyway
18:20:17 <foobar_> Kiro do you have contact info? might want to get in touch when this project I'm working on is flipped to public...
18:20:35 <Kiro> how do u private message?
18:20:41 <foobar_> use /msg
18:20:58 <foobar_> also if you're doing machine learning stuff check out https://gitter.im/dataHaskell/Lobby
18:31:42 <halogenandtoast> \q
19:34:51 <riaqn> https://hackage.haskell.org/package/containers-0.5.10.2/docs/Data-Map-Strict.html
19:35:02 <riaqn> I want to use alterF, but intero told me it's not exported..
19:39:37 <riaqn> never mind, I add a newer version to extra-dep
19:39:44 <riaqn> seems the stackage version is very old
19:41:12 <geekosaur> check your resolver
20:03:49 <dsal> Anyone have any advice on parsing well-formed JSON with invalid UTF-8 characters?
20:04:30 <Welkin> invalud?
20:04:34 <Welkin> invalid?
20:05:25 <Welkin> I recently had to fix up some messed up stringified code before I could parse it. I just ran if through a script first to make it valid
20:05:27 <dsal> Error in $: Failed reading: Cannot decode input: Data.Text.Internal.Encoding.decodeUtf8: Invalid UTF-8 stream
20:05:31 <Welkin> ran it*
20:05:57 <dsal> Yeah, I can probably hack up something external, but I'm hoping to not run into a lot of things I can't do with haskell.
20:06:18 <Welkin> you can fix it in haskell
20:06:54 <Welkin> you just need to know which part of wrong
20:07:13 <Welkin> read it in as whatever format it is in
20:07:15 <Welkin> then convert it
20:07:19 <Welkin> that may also work
20:08:26 <geekosaur> you may also like decodeUtf8With and https://hackage.haskell.org/package/text-1.2.2.2/docs/Data-Text-Encoding-Error.html#g:2
20:09:02 <dsal> I think it's just garbage strings people shoved in because of JSONYOLO
20:19:23 <okuu> Surely someone here must have read “Seemingly Impossiblen Functional Programs”. One of the main ideas of the paper is that (types that denote) compact spaces admit exhaustive search in a finite amount of time. In topology, the archetypal compact space is the closed unit interval. Is there some way to define a Haskell type that behaves for all intents and purposes like the unit interval?
20:20:06 <okuu> s/blen/ble/
20:20:55 <LiaoTao> okuu: That sounds very mindboggling
20:22:30 <dsal> @hoogle Text -> ByteString
20:22:31 <lambdabot> Data.Text.Encoding decodeASCII :: ByteString -> Text
20:22:31 <lambdabot> Data.Text.Encoding decodeLatin1 :: ByteString -> Text
20:22:31 <lambdabot> Data.Text.Encoding decodeUtf8 :: ByteString -> Text
20:22:37 <dsal> Super not useful results here.  :(
20:22:54 <dsal> Is there a shortcut from a Text to a ByteString?
20:23:27 <okuu> LiaoTao: It is, but (0) I'm enjoying topology, like, way more than analysis, (1) I get along with the professor as well (again, unlike analysis), and (2) I'm looking for potentially useful material for my thesis.
20:23:27 <geekosaur> you want the encode* functions
20:23:38 <geekosaur> https://hackage.haskell.org/package/text-1.2.2.2/docs/Data-Text-Encoding.html#g:5
20:23:51 <dsal> Oh.  That's convenient.  :)  Thanks.
20:25:15 <Hijiri> okuu: I don't think so, at least not in the sense of being able to do arithmetic with all of the numbers
20:26:07 <dsal> Error in $: Failed reading: satisfy
20:26:10 <dsal> Well that message sucks.
20:27:00 <Hijiri> there are numbers which can't be approximated to arbitrary degree in a turing equivalent (or lower) system
20:31:11 <dsal> oooh.  This means I'm past the UTF 8 errors and just made too many assumptions about the JSON from having read the first line.
20:31:40 <okuu> Hijiri: Oh. Dang. :-|
20:37:36 <dsal> It seems aeson just can't parse this.
20:38:29 <dsal> Yeah, I fixed up the bad utf8ness, but aeson still won't have it.
20:53:11 <dsal> jq -a . file.json | python -mjson.tool > whatever
21:02:57 <codygman> Can anyone help me figure out how to use amazonka-s3 to list a certain bucket? I think I need to customize listBuckets (https://hackage.haskell.org/package/amazonka-s3-1.4.5/docs/Network-AWS-S3-ListBuckets.html#v:listBuckets) with lenses... but from looking at the source I can't figure out what the field names would even be.
21:09:24 <Axman6> dsal: by definition, it's not well formed JSON if it doesn't have utf8 encoded strings
21:10:14 <Axman6> codygman: do you want to list the contents of a bucket?
21:10:17 <dsal> Yeah, that's true.  I cleaned them up with decodeUtfWith at least, but still wouldn't go.
21:10:30 <Axman6> if so, you want ListObjects
21:11:40 <codygman> Axman6. Ah, okay. That's a little more obvious to use ;)
21:11:44 <Axman6> send (listObjects "my-bucket") <&> lorsObjects will give you back all the objects
21:11:56 <Axman6> listBuckets lists the buckets you have access to
21:12:17 <Axman6> uh, get lorsObjects*
21:24:20 <dsal> Argh.  At what point is this test framework thing just interfering with my ability to write tests?
21:40:12 <Lokathor> I want to store rooms in a game. Room have an ID number. I'm thinking that I want to store them all in an IntMap. Question: Should the room's ID number be part of the room? If so, the room data and storage location within the map could become out of sync
21:41:41 <monochrom> Really?! You mean room ID can change?!
21:42:11 <Lokathor> rather, a room's roomid should not change, but it would be possible within the code to write such a line that would change a room's roomid
21:42:37 <Lokathor> I think this is one of those, "things that should not exist should not be reprisentable" sort of deals
21:47:31 <Lokathor> monochrom, anyway if you have an alternate idea of how to handle it that'd be cool
21:48:17 <Lokathor> Like some sort of... sorted sequence where the new values put in place after an update are checked for ordering and the sequence fixes itself
21:48:31 <Lokathor> though that sounds expensiveish
21:52:34 <jle`> Lokathor: sounds similar to the goal of fgl
21:55:21 <Lokathor> jle`, this library, as with many haskell libraries, seems potentially very powerful
21:55:29 <Lokathor> but a little hard to grasp :/
21:56:26 <jle`> i guess to clarify
21:56:37 <jle`> i mean, it sounds like you want a graph
21:56:53 <jle`> and fgl is one of the noble attempts at implementing a persistent one in haskell
21:57:49 <Lokathor> well what i want is a way to make a mud-like world, so there's rooms, and rooms have objects and creatures, and also rooms have exits to other rooms, which are usually two-way but also one-way in some cases (like jumping down without a ladder back up)
21:58:08 <jle`> yeah, sounds like some sort of graph data structure
21:58:20 <Lokathor> or _full blown ECS_
21:58:41 <jle`> which is one of those things that is really "easy" in OOP/an imperative setting with pointers
21:58:57 <jle`> but a little frustrating still in haskell
21:59:03 <jle`> unless you are an fgl wizard
21:59:16 <jle`> or well, can use fgl :)
21:59:28 <jle`> i've attempted to take a few whacks at this in the past as well
21:59:40 <Lokathor> well as i recall, you're a lot better at haskell than me
22:00:05 <jle`> i mean, whacks at making a graph library in haskell
22:00:10 <Lokathor> consider an alternate design: type World = IntMap Room; -- then we use lookupWithKey and such as necessary when the key is needed
22:00:22 <jle`> yeah that's essentially what fgl is implemented as
22:00:25 <Lokathor> then the Room value doesn't contain its own roomid
22:00:32 <pacak> Right now ghc allows you to pin thread to specific capability with forkOn, I'm writing something to allow to allow ghc to restrict migration between several capabilities. Which version would you personally prefer -(a)  64 bit bitmask as a parameter, setting bits 0 and 1 will allow ghc to migrate it to caps with ids 0 (also 64, 128, etc if there's more) and 1 (65, 129) or (b) a list of specific capability ids [0,1,2] - to allow running on 0, 1 and 2 only (with
22:06:19 <Lokathor> jle`, the docs here seem to indicate that Data.IntMap is already a Graph? or it's wrapped by the Gr type? or something like that
22:08:42 <jle`> yeah fgl is a bit liberal with type synonyms
22:09:17 <jle`> but yeah IntMap is meant to be an internal representation of a graph
22:10:51 <jle`> well, it represents the nodes.  and you also need some way to represent the edges
22:11:15 <Lokathor> I was going to have each Room have a container of edges
22:11:27 <Lokathor> probably like, a Vector Int, or something
22:11:50 <Lokathor> either Vector Int and then 0 is reserved for null, or Vector (Maybe Int)
22:12:21 <jle`> or maybe just IntSet
22:12:33 <jle`> something like IntMap (a, IntSet) ?
22:12:57 <Lokathor> IntSet?, i'm not sure what that does
22:12:59 <jle`> basically an adjacency matrix with tagged items
22:13:06 <jle`> IntSet is just a `Set Int`
22:13:11 <Lokathor> right but
22:13:30 <Lokathor> well, okay, so each direction from a room (there are 6 directions) has one other room it might lead to
22:13:45 <Lokathor> in some cases there are special portals as well, but that wouldn't be covered by the directions
22:13:54 <Lokathor> so there's just 6 directions that each might link to one other room
22:14:11 <jle`> in the IntMap (a, IntSet) representaiton of a graph, each node contains edges to other node's addresses
22:17:31 <Lokathor> but how does the IntSet keep what direction leads to what room straight?
22:21:22 <jle`> well, it's a directed graph
22:21:28 <jle`> the node only saves outward edges
22:21:41 <jle`> the IntSet contains all of the edges going outwards from that node
22:21:55 <Lokathor> but each edge is associated with a direction, and must stay that way
22:22:04 <Lokathor> north is a specific room and east is a specific other room
22:22:32 <jle`> oh yeah that north-south-east-west relationship is not encoded directly here
22:22:46 <Lokathor> but that's one of the most important parts :(
22:22:49 <jle`> there is no structure to this
22:22:57 <jle`> but you can make your 'own' in 'a'
22:23:03 <jle`> IntMap (a, Vec 4 Int)
22:23:33 <jle`> um, essentially yoru Vector (Maybe Int) idea
22:23:51 <jle`> but also if your structure is that rigid, you can just encode your rooms as a Matrix
22:23:55 <Lokathor> Vector (Maybe Int) seems good
22:24:09 <Lokathor> uh, what is this Matrix type
22:24:14 <jle`> 2d array
22:24:35 <Lokathor> i also considered that, but i wasn't sure if i'd end up with a densely packed set of rooms
22:24:41 <jle`> and then `Vec 4 Bool`
22:24:55 <Lokathor> i suspect that i would not, and also that not all rooms would map to one other room
22:25:16 <Lokathor> example, a ring of rooms for a moat, and at one point you can go "into" the castle, but that castle is much more than 1 room big
22:25:18 <jle`> hm.  actually i think in fgl the edges are labeled, too
22:25:35 <jle`> so it might be something like IntMap (NodeContents, IntMap EdgeLabel)
22:25:42 <jle`> so you could have (IntMap Direction)
22:25:59 <jle`> er, or, Map Direction Int
22:28:11 <Lokathor> yeah with only 6 directions, and fixed like that, i think a plain vector would be better
22:28:31 <Lokathor> and autoconverting Direction -> Int with like, fromEnum or whatever it is
22:40:06 <vrederv> Python code is called pythonic when it adheres to Python's principles, is there an equivalent adjective for Haskell?
22:41:51 <jokester> can "haskell-ish" be close to that?
22:43:22 <mud> haskelly? Mostly though you just talk about good code. Making the name of the language into an adjective describing good code is kind of just a python thing I think.
22:43:41 <vrederv> Thanks good code will do.
22:43:42 <nshepperd_> Haskellescent
22:45:55 <takitus> Well-Curryed?
22:46:50 <mud> I am wicked well curried at the moment. I had 2 helpings.
22:48:27 <vrederv> I have a function that takes one Char as its argument. What's the best way to enforce that it only takes ['a'..'z']?
22:50:24 <vrederv> I guess I could use guards and return Nothing if it's out of range.
22:51:23 <vrederv> Can you define a data type to be a subset of Char?
22:52:13 <mud> vrederv: You can make a newtype wrapper of Char, and don't expose the constructor. Just expose a function  :: Char -> Maybe RestrictedChar   that checks for validity.
22:52:52 <mud> But that's a bit more boilerplate and protocol than is usually worth it. Just making it  blah :: Char -> Maybe Whatever is probably good enough
22:55:02 <vrederv> thanks
22:56:44 <jle`> you can use the finite-typelits library and have your function work on `Finite 26` instead
22:57:07 <nshepperd> options include: 1. extend the function to be meaningful outside of 'a'..'z'; 2. return Nothing if out of range; 3. throw an error if out of range; 4. define a newtype wrapper to represent subset of Char
22:59:04 <nshepperd> (for an example of 1, toUpper from the standard library leaves non-alphabetical characters unchanged)
22:59:55 <nshepperd> i think which of these is best depends on the situation
23:00:23 <Lokathor> vrederv, when haskell code conforms to haskell's principles we just call it "good" :P
23:00:55 <Lokathor> though do note that at least one other language has an equivalent to pythonic: in rust code can be "rusty"
23:02:21 <mbrock> Lokathor: I dunno your design constraints, but I like to start with a simple semantic approach -- you have a set of connections between rooms, so you store a `Set (Room, Connection, Room)`
23:03:01 <mbrock> preferrably keeping that data type abstract except for a module of accessing functions, so that you can switch to another representation if needed for performance reasons
23:04:56 <Lokathor> http://lpaste.net/359710 this seems like my starting point
23:05:07 <Lokathor> i want to put an Show instance on Exits but i'll have to custom write that one
23:06:49 <vrederv> Making Direction derive Ord doesn't make sense to me.
23:07:48 <Lokathor> I would expect there to be _an_ ordering among directions, even if it's not a particularly sensical one
23:08:36 <vrederv> Why would you expect it?
23:08:37 <mbrock> that may be a fine representation... I have a bias for avoiding the "OOP-ish" tendency to store relational data in records, because that's such a strong meme but often kind of confusingly asymmetric
23:08:47 <mbrock> (e.g., why does a room contain its exits, but not its entries?)
23:09:07 <Lokathor> mbrock, because when you're in a room you want to know where you can go from there
23:09:23 <Lokathor> so the order of the relations is that you store where you can to go from where you are
23:09:34 <mbrock> fair enough :)
23:10:01 <Lokathor> that way you're looking at one vector for exit data instead of every single other room in the game for who says they can take you to here, or something
23:10:07 <Lokathor> also not all exits are reflective
23:10:51 <Lokathor> vrederv, an Enum instance makes a thing "Int-like", and Ints have an order
23:11:11 <Lokathor> so you can use fromEnum on both values and compare the ints, or you can just make the ordering be directly on the type
23:12:11 <vrederv> The question is why you would want to numerically compare directions.
23:12:56 <Lokathor> oh, they're an Enum because (1) why not? it's better to have more instances than less almost all of the time, (2) they're the indexes into the Exits vector
23:16:12 <nshepperd> often you give things an Ord instance just so that you can put them into maps and sets
23:16:52 <Lokathor> fun fact: all values in Erlang are ordered with all other values in Erlang even across types for exactly that reason
23:18:21 <vrederv> Why do maps and sets need an order?
23:18:30 <jle`> in Haskell?
23:18:34 <jle`> mostly for performance reasons
23:18:38 <Lokathor> because they are binary tree sets and binary tree maps
23:18:44 <jle`> well, for the `containers` package at least
23:18:54 <jle`> but there are other packages that implements maps and sets that don't require orderable items
23:19:06 <Lokathor> you can also have hashsets and hashmaps, but they have a different performance profile that's better in more imperative languages
23:32:48 <codygman> Thanks for the help Axman6. 
23:35:35 <codygman> Is there a way to get an absolute s3://url given a https://hackage.haskell.org/package/amazonka-s3-1.4.5/docs/Network-AWS-S3-Types.html#t:Object? It needs to have the prefix right?
23:36:56 <codygman> I've been using turtle to call "aws s3 ls" and I'm trying to figure out how to replace that with amazonka. Absolute s3 urls were central to how my program worked. I KNow how to get objects now and filter them, but I don't know how to convert an object to an S3 url to integrate with my existing program.
23:38:11 <Lokathor> http://lpaste.net/359711 and now our rooms have exits
