00:21:12 <theYellowRacer> I have a wrapper function that is supposed to take a String as input, and try to find it in a Data.Map, which contains (String, String) pairs. What's a reasonable way to write the function header?
00:21:36 <theYellowRacer> I want to have both Data.Map and String as arguments
00:22:14 <liste> theYellowRacer: so the Data.Map has Strings as keys and Strings as values?
00:22:24 <theYellowRacer> Yes, that's correct liste
00:22:44 <liste> and you want to look up by key?
00:22:48 <theYellowRacer> yes
00:23:49 <liste> so basically a monomorphic version of this https://hackage.haskell.org/package/containers-0.5.10.2/docs/Data-Map-Lazy.html#v:lookup (or the strict variant) ?
00:25:16 <theYellowRacer> Yes, except I implement some extra logic, hence my use of a wrapper function. 
00:25:30 <theYellowRacer> I don't know if this is the proper way to do this. 
00:26:08 <liste> well then the type signature would be a monomorphic version of lookup's signature, with k ~ String and a ~ String
00:26:15 <liste> depending on what the extra logic is
00:30:31 <theYellowRacer> so right now I have 
00:30:35 <theYellowRacer> translation :: String -> (Map -> String)
00:30:36 <theYellowRacer> translation :: String -> (Map -> String)
00:30:42 <theYellowRacer> sorry for flood
00:30:58 <theYellowRacer> Map is a qualified import of Data.Map.Lazy
00:31:22 <liste> just "Map" isn't a concrete type
00:31:27 <liste> you need to specify the type parameters
00:32:27 <theYellowRacer> Should I have String -> (Map String -> String) ? My map has strings for both key and values. 
00:32:45 <liste> Map has 2 type parameters, so Map String isn't enough
00:32:56 <theYellowRacer> Map String String?
00:32:58 <liste> yes
00:33:36 <liste> also, what do you want to do when an entry isn't found?
00:34:11 <theYellowRacer> I have a case in my function, where if map returns Nothing, I return empty string ""
00:34:42 <theYellowRacer> it's a little sloppy
01:15:33 <skm_baig> Hi, can ghci be used in place of hugs? or does it have a hugs/haskell-98 compatible mode etc?
01:16:03 <mivael> hello all
01:21:07 <Cale> skm_baig: It generally is. Hugs hasn't really been used in many years now.
01:21:54 <Cale> skm_baig: It's been over a decade since the last release of hugs.
01:23:41 <mivael> Are there known reasons why one would want to REFRAIN from using the multi-parameter type classes GHC extension?  (-XMultiParamTypeClasses)
01:24:09 <Cale> Not really.
01:26:56 <[exa]> mivael: it can produce more cryptic messages if beginners do something wrong
01:27:06 <[exa]> but that's not a valid reason :]
01:27:19 <mivael> [exa]: agree :)
01:27:48 <mivael> Cale: why do you think it is not in Haskell standard then?
01:28:20 <mniip> the haskell report is suppsoed to be simple to implement
01:29:40 <[exa]> complexity of implementing MPTCs is quite insignificant even when compared to the base typeclass-aware typesystem
01:31:00 <mivael> mniip, [exa]:  Understood.  I think I have enough of information at this stage :)
01:31:25 <[exa]> going to raise standardization effort? :D
01:32:11 <mivael> [exa]: me? No. I'm a beginner :)
01:35:27 <mivael> How it is supposed to work around absense of multi-parameter type classes?
01:40:17 <Cale> mivael: It's sort of nice to have the language broken up into extensions so that new implementations can begin to benefit from some libraries even before they have all the features implemented
01:40:35 <Cale> mivael: It would be nice to document the extension in the Report though.
01:41:29 <Cale> I think the next version of the Report really ought to try to document all the most commonly used extensions
01:42:03 <Cale> But in the meantime, there's the GHC User's Guide and there are papers discussing most of the extensions in greater detail.
01:42:15 <MarcelineVQ> they can copypaste http://dev.stephendiehl.com/hask/#language-extensions
01:43:17 <mniip> yeah but if you implement the common kitchensink extensions,
01:43:42 <mniip> you'll find that you've reinvented system FC with no kinds
01:43:52 <mniip> and thus your code is isomorphic to GHC
01:50:15 <[exa]> :]
01:52:05 <mniip> does lambdabot do TypeInType yet
01:59:12 <[exa]> I often arrive to question why shouldn't all type inference get solved just by automatically rewriting the problem to a built-in prolog and letting it go
02:01:46 <mniip> performance
02:01:57 <mniip> backtracking in constraint solving = super super super exponential time
02:02:21 <mniip> halting problem perhaps?
02:05:19 <[exa]> mniip: dependent-types people love that! :]
02:08:04 <mivael> Cale: is there a resource where -XMultiParamTypeClasses is discussed? I tried the GHC User Guide for this matter and I failed to find answers to my questions (particularly, what are the work-around design patterns for the ones who do not use the extension).
02:12:56 <[exa]> mivael: https://www.researchgate.net/profile/Martin_Sulzmann/publication/221323263_Principal_Type_Inference_for_GHC-Style_Multi-parameter_Type_Classes/links/09e415110019531727000000.pdf?origin=publication_detail
02:13:14 <[exa]> (sorry for linking it through researchgate, I can't find a better link)
02:13:33 <[exa]> oh
02:13:35 <[exa]> https://lirias.kuleuven.be/bitstream/123456789/131526/1/aplas06.pdf
02:14:13 <[exa]> (strange how posting an imperfect solution to IRC instantly causes google to return a good result)
02:16:59 <mivael> MarcelineVQ: thanks for the link!
02:21:06 <mivael> [exa]: looked it through, thank you
02:23:38 <mivael> As I understand from the link by MarcelineVQ (which led to http://dev.stephendiehl.com/hask/#multiparam-typeclasses), I should learn about type families and try to use them if I want to avoid multi-parameter type classes.
02:32:09 <mivael> oh... type families is another GHC extension, isn't it?  ;)
03:07:49 <madknight> Data.String has a (length) function and Data.Array has a (length) function too, is there a higher structure such as monoid, which defines length?
03:08:56 <lynn> Foldable
03:09:11 <lynn> https://hackage.haskell.org/package/base-4.10.0.0/docs/Data-Foldable.html#v:length
03:09:54 <madknight> lynn, thx
03:11:16 <Xion_> Foldable.length is O(n) though whereas specialized length for Data.Array is IIRC constant
03:12:12 <Xion_> Oh, nevermind, length is an optional method so it can be specialized in instances.
03:13:06 <lynn> I'm not sure Data.Array even has a (length)?
03:13:09 <lynn> https://hackage.haskell.org/package/array-0.5.2.0/docs/doc-index.html
03:13:18 <mauke> IArray?
03:13:30 <mauke> oh, bounds
03:13:43 <Xion_> http://hackage.haskell.org/package/array-0.5.2.0/docs/Data-Array.html#t:Array -- has a Foldable instance
03:13:56 <lynn> ah, there we go
03:15:30 <madknight> lynn, writing purescript https://pursuit.purescript.org/packages/purescript-arrays/4.1.1/docs/Data.Array#v:length
03:16:08 <madknight> lynn, and i think i need this function length :: forall a b f. Foldable f => Semiring b => f a -> b
03:20:31 <madknight> okay but thats a bit unfortunate Data.String is not a Foldable in Purescript
03:24:09 <phadej> I think it's more unfortunate that it is in Haskell :)
03:24:32 <phadej> e.g. Text isn't foldable
03:28:31 <madknight> phadej, but string is only considered bad because of performance reasons isn't it? i mean conceptually there's nothing wrong with list of chars
03:33:28 <phadej> as an implementation no, but `instance MyClass String` doesn't work, so we are stuck with various work-arounds for tht
03:33:55 <phadej> newtype String = String [Char] would be already an improvement
03:34:42 <phadej> ... and that won't be Foldable
03:37:52 <ggVGc> why is foldable not called Mapable?
03:38:08 <ggVGc> wiat, sorry
03:38:15 <ggVGc> I mixed up functor and foldable for some reason
03:38:20 <ggVGc> why is functor not called mapable
03:38:40 <Gurkenglas> Because the laws come from the Functor laws from category theory
03:39:09 <Gurkenglas> Why would you expect Mappable to have a law "map (x . y) = map x . map y"?
03:40:36 <ggVGc> becuase that would be the definition of mapable and I'd learn that while learning haskell
03:41:15 <phadej> Gurkenglas: law is bad argument, Traversable has laws as well
03:41:56 <ggVGc> I'd be okay with Monad being called Bindable too
03:42:17 <ggVGc> Bindable sounds less exotic
03:42:35 <Gurkenglas> I don't know a categorical concept traversable's based on
03:43:06 <ggVGc> I'm just saying, just because something has a foundation in something else, doesn't mean we have to name it that
03:43:06 <phadej> ggVGc: I don't think it would really change anything
03:43:31 <ggVGc> Monad already defines some stuff that isn't strictly according to CT right?
03:43:32 <phadej> ggVGc: OTOH, why try to invent new names, where there is one already?
03:43:36 <ggVGc> I don't really know any CT
03:44:10 <phadej> it doesn't
03:44:51 <ggVGc> phadej: well, because it adds incoherency to the vocabulary of haskell in a sense. Since haskell is not a "category theory language". It's a programming language with a lot of roots in CT
03:45:02 <ggVGc> so we have things like Monad, but then we also have things like Traversable
03:45:58 <ggVGc> sorry, inconsistency I meant
03:47:03 <madknight> i use this cheat sheet https://i.stack.imgur.com/zAu87.png
03:47:45 <phadej> we could call Applicative "LaxMonoidalFunctor", neither one give any intuition anyway
03:48:39 <phadej> so naming is hard, and changing over 10 year old names, ... I don't really think any value
03:48:51 <mniip> we could call Applicative:
03:49:08 <mniip> Monoid (NT (->) (->)) Day
03:49:19 <phadej> :)
03:51:19 <the_2nd> I bet there is a function for this already, does someone know it?  [1, 2, 3, 4, 5] -> [1, 3, 6, 10, 15]   (value is some of values before)
03:52:31 <phadej> it's scan
03:52:33 <phadej> e.g. https://www.stackage.org/haddock/lts-9.10/foldl-1.2.5/Control-Foldl.html#v:scan
03:53:43 <mniip> wow that's a weird package
03:53:49 <mniip> why not use base:
03:54:02 <mniip> > scanl (+) 0 [1,2,3,4,5]
03:54:04 <lambdabot>  [0,1,3,6,10,15]
03:54:19 <int-e> > scanl1 (+) [1..]
03:54:21 <mniip> > scanl1 (+) [1,2,3,4,5]
03:54:21 <phadej> ah it's scanl, didn't knew it's there somewhere too
03:54:22 <lambdabot>  [1,3,6,10,15,21,28,36,45,55,66,78,91,105,120,136,153,171,190,210,231,253,276...
03:54:25 <lambdabot>  [1,3,6,10,15]
03:55:00 <the_2nd> mniip, exactly what I was just typing :)
03:57:25 <phadej> I knew that it's some "scan", but didn't knew it is in base. TIL
04:50:29 <Gurkenglas> I'm on Windows and would like to hack a ham filter into some IRC client in haskell. What IRC client would you recommend?
04:51:31 <Gurkenglas> Can Bash for Windows make the unix package buildable?
04:51:47 <sm> Gurkenglas: how about glirc
04:51:55 <Gurkenglas> sm, doesn't build on Windows
04:52:08 <sm> ah
05:01:35 <Gurkenglas> Perhaps I don't need to hack into a client. What library should I use to watch the lines another program (irc client) writes into a file? (channel log)
05:03:16 <kuribas> If I want to test functions that are not exported, do I need to put them in another module?  Like Stroke and Stroke.Intern?
05:04:30 <kuribas> or is there a way with macros to create a "testable" version of a module?
05:10:07 <lyxia> I like to have Internal modules that export everything
05:10:21 <lyxia> and then non-Internal ones just reexport the stable subset of it
05:11:00 <lyxia> If you want, you can hide Internal modules behind a cabal flag so that normal users don't have access to it
05:12:46 <kuribas> it's kindof ugly, but that would work
05:14:51 <lyxia> I'd just leave them exposed.
05:40:11 <codeshot> Is there a neat function for monads that makes them forget their structure? ie [1,2] >> forget >> [3,4] == [3,4]  instead of [3,4,3,4] ?
05:41:43 <Hafydd> > [1,2] >> (const $ return ()) >> [3,4]
05:41:45 <lambdabot>  error:
05:41:45 <lambdabot>      • Couldn't match expected type ‘[a0]’
05:41:45 <lambdabot>                    with actual type ‘b0 -> m0 ()’
05:41:50 <Hafydd> Whoops.
05:42:15 <codeshot> I tried mplus
05:42:29 <lyxia> codeshot: no there isn't a general combinator like that
05:42:31 <codeshot> but that doesn't have an instance for (,a)
05:42:34 <codeshot> blast
05:43:10 <lyxia> what would it do for (,) a
05:44:42 <codeshot> That's what I'm aiming for, it would make it look as if you'd done just pure with the latest value
05:45:42 <codeshot> for (,a) then it would take (x,y) to (mempty,y)
05:46:07 <codeshot> I guess
05:49:34 <codeshot> I mean for ((,) a)
05:49:40 <lyxia> codeshot: (x,y) >> forget   would do that? it would break monad laws and parametricity
05:50:50 <lyxia> well anyway, you're looking for more structure than monad offers
05:51:00 <codeshot> Oh, so it would have to be only on a class Applicative a => ApplicativeForget a ? 
05:51:45 <codeshot> Then I'll write myself such a class
05:51:54 <codeshot> and think about its laws
05:52:43 <lyxia> No I mean, it could still be a subclass of Monad, but I doubt you'll be able to implement it for (,) a
05:53:55 <codeshot> yeah, so I'll make an operator and if it looks like a useful tool (so far it does) I'll see who to send a proposal to for do notation to support it
05:54:33 <ph88> does haskell have a library to solve equations like   https://www.wolframalpha.com/input/?i=solve(+d+%3D+l+*+(1%2Br)%5En+-+p+*+((1%2Br)%5En-1)+%2F+r,+p+)   ??
05:57:14 <Gurkenglas> I'm in intero in emacs, working on a standalone .hs file. How do I go about finding the sourcecode that defines a given token?
05:57:29 <codeshot> Actually, I think this is a kleisli-like composition
06:00:07 <Gurkenglas> codeshot, forget x y = y lets you do forget [1,2] [3,4], but why would you want to do that?
06:00:55 <Jenaf> I'm brainfarting again
06:01:02 <Jenaf> I get an error on this one: 
06:01:03 <Jenaf> aValues1fromb n = map (- (n+1)) primes2k
06:01:28 <Gurkenglas> Try map (+ (-(n+1)))
06:01:40 <Gurkenglas> Or map (subtract (n+1))
06:02:14 <Jenaf> and why does it not work with the - sign? is the infix messing thigns up?
06:02:28 <lyxia> you can't write right sections of (-), it gets parsed as a unary minus.
06:02:44 <Jenaf> oh
06:02:46 <Jenaf> thanks
06:02:47 <Gurkenglas> > [1,2] >> return () >> [3,4] -- Hafydd, return () must not have an effect
06:02:50 <lambdabot>  [3,4,3,4]
06:03:43 <Gurkenglas> codeshot, why have [1,2] in the first place if you want to forget it?
06:08:04 <codeshot> In case someone gives you that and you want to reset and begin again on some condition.
06:08:50 <codeshot> For any Monad or Applicative that it makes sense for (eg, List, (,), etc) - obviously not IO
06:09:45 <codeshot> then instead of special functions for parser's like "do try $ p" you could use ... ohhhhh
06:09:49 <codeshot> lol
06:09:59 <codeshot> it's pointless isn't it :D
06:11:29 <codeshot> It could only be useful with a pushSavepoint function to go along with it
06:11:43 <codeshot> Maybe I'll think about that stuff later then
06:25:48 <royal_screwup21> Suppose I want to sort a list by the absolute value of each element. How do I customize "sort" function to suit my purpose? (I know I can convert the list to positive values then apply sort, but I want to learn to customize sort)
06:25:49 <Jenaf> another brainfarting I guess
06:25:59 <Jenaf> I get an error I can't decypher on this one:
06:26:00 <Jenaf> aValuesClean = takeWhile (<= 1000) (dropWhile (< 3) theaValuesmerged)
06:27:37 <Jenaf> oh wait
06:27:38 <[exa]> royal_screwup21: use something like sortWith or sortOn
06:27:49 <[exa]> :t sortWith
06:27:51 <lambdabot> error: Variable not in scope: sortWith
06:27:56 <Jenaf> now i get it -.- I'm on [[Int]] and not on [Int]
06:29:15 <[exa]> royal_screwup21: oh it's sortBy
06:29:18 <[exa]> :t sortBy
06:29:19 <lambdabot> (a -> a -> Ordering) -> [a] -> [a]
06:30:18 <lakitu> super code productivity super-saijan tip: Kate "snippets" custom snippet-autocomplete plugin is the dang-usefulest coding feature i've found so far. you can save all the programmatic structures like if-else-then and while-loops to quick names. some oft-used snippets could be 30 or 90 lines long . . .  i just fill in all the variable text with "##" or "##description-here", so i know what to fill in after i invoke it. the last thing i'll say is do the ki
06:32:55 <Hafydd> While loops...
06:37:12 <MagneticDuck> I wonder if there would be a way for the language itself to support abstraction so you don't have almost identical 90-line long structures declared everywhere.
06:41:06 <ph88> is there a way to show possible aliases of types that ghci infers ?
06:44:55 * codeshot grabs lens
06:45:02 * codeshot kisses lens
06:45:07 <MagneticDuck> ph88: to get the type that a particular alias refers to, try :i
06:46:12 <ph88> the other way around :p
06:47:03 <Gurkenglas> How do I handle intero's M-. saying "No tags containing rectangleSolid"?
06:48:42 <Gurkenglas> What would be the magnitude of a project to make the compiler handle goto-definition?
07:04:48 <nschoe> Hi everyone, I am trying to develop a GUI application in which the user will manipulate a sort of graph. Basically he'll have "boxes" that he will link with "arrows" via a drag'n'drop interface. I have some experience with the `gtk` and `gtk3` hackage package for the interface. But I am wondering what I can use for drawing the graph.
07:05:15 <nschoe> The yED editor (https://www.yworks.com/) somewhat looks like what I have in mind.
07:06:23 <nschoe> I first thought to implement this in a very raw manner, on a Gtk Drawing Area with cairo, but then it becomes quite complicated to handle the fact that the user clicked on a box, or clicked on a link between boxes ("arrow") to edit some properties.
07:06:49 <nschoe> So I'm thinking that a slightly higher-level library exists. Can anyone recommend a package?
07:19:34 <ph88> how do i  move to another module in ghci ?
07:20:00 <nschoe> No suggestions?
07:20:11 <Gurkenglas> nschoe, gloss might work, but I'm not sure how to tell what object contains the coordinates that a user clicked on.
07:20:44 <sm> nschoe: this might be easier in javascript/a browser view ?
07:22:06 <sm> otherwise, you might want to search http://hackage.haskell.org/package/fltkhs , it has quite a mature set of features
07:22:23 <nschoe> Gurkenglas, okay I will check gloss, thank you.
07:23:06 <nschoe> sm, yes this would clearly be easier, but the GUI is only one part, to generate the graph. Graph "boxes" are actually functions, etc. and then execution should follow the graph.
07:23:20 <nschoe> sm, will check fltkhs too, thanks.
07:25:25 <Utonto> ciao a tutti
07:25:31 <Utonto> !list
07:26:26 <Jenaf> I get an invalid type signature one Lister :: [(Int,Int)] -> [((Int,Int),Int)]
07:26:35 <Jenaf> anyone knows why?
07:27:13 <sm> nschoe: just to make your task bigger.. ghcjs, perhaps with reflex-dom or something, could be another way to combine browser rendering/rich js libs/haskell code
07:28:00 <Jenaf> oh i was stupid again
07:28:02 <Jenaf> -.-
07:28:38 <nschoe> sm, will this allow me to write a complex program basically whose GUI is implemented in a browser, in JS and whose backend is in Haskell? How do I handle the interaction between the GUI and the backend?
07:28:50 <marvin2> 36 year old feminist is no longer sexually harassed in public.. misses it.. and blames patriarchy for missing it https://i.redd.it/o71ecspak7tz.jpg
07:28:58 <nschoe> sm, how to I visualize some of the result from the backend in my GUI, in "real time"?
07:29:16 <sm> nschoe: absolutely, a simple matter of programming
07:29:22 * sm waves hands vigorously
07:30:08 <sm> some haskell & reflex/react users may speak up in a bit
07:30:13 <nschoe> sm, it sounds nice, but how do I make the GUI and the backend communicate?
07:30:22 <sm> afk, sorry
07:30:50 <nschoe> sm, for instance, the "boxes" in my GUI are actually Haskell functions that work on matrices (hmatrix). I need to be able to visualize the current content of the matrix in the GUI. Can I do that easily?
07:32:10 <Tuplanolla> I think Blender or other such programs use this technique for building shader graphs, nschoe.
07:32:57 <nschoe> Tuplanolla, thanks for answering. By "use this technique", you mean the GUI is implemented in the browser?
07:33:18 <nschoe> Tuplanolla, I've neer used blender personally, but I think it's a GUI application, no browser involved?
07:33:32 <Tuplanolla> It's not in the browser, but it's still something you could look at.
07:33:41 <ph88> how come only the first two variables work ?  https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/ghci.html#ghci-cmd-:set%20prompt
07:34:02 <Tuplanolla> If it's built as a custom widget, you'll just need to change the renderer.
07:34:58 <nschoe> Tuplanolla, hum, sorry I am a bit confused. What do you mean by changing the renderer?
07:35:50 <Tuplanolla> Whatever library does the "draw rectangle here and text there" thing shouldn't matter much.
07:36:39 <nschoe> Tuplanolla, okay I see.
07:37:19 <nschoe> Tuplanolla, just to be sure, what I'm trying to have is an interface, in which I can draw smth like this: https://extremeistan.files.wordpress.com/2014/09/diffuse_normal_ao_metalness_graph.png . Here we can see rectangles (the "boxes") that are linked together with bezier curves.
07:38:50 <nschoe> That's exactly what I'm trying to do, not necessarily as beautiful as in the picture, but I need to be able to click on a rectangle or on a curve to edit some properties. If I just draw everything with cairo, this is just a canvas, the boxes and curves don't really mean anything, so it's quite complex to "click to edit".
07:38:56 <Tuplanolla> This is from Blender.
07:39:02 <nschoe> Tuplanolla, indeed.
07:39:37 <Tuplanolla> My suggestion was to look at how they did it.
07:40:13 <nschoe> Tuplanolla, so I'm either looking for a library that I can use with gtk to integrate in my interface, in Haskell ; or as sm suggested, find a way to do this in the browser. But then I need to make the WebApp and Haskell communicate, in "real time".
07:40:38 <nschoe> Oh okay, yes I can take a look. This might take a long time to narrow it down, but I will do this, yes. I was coming here in case the use-case was familiar to someone :)
07:43:14 <fakenullie> you'll have to use canvas in html too
07:43:22 <fakenullie> so not much advantage over gtk with cairo
07:43:59 <nschoe> fakenullie, well yes and no. There are logs of drawing libraries in js. Things such as d3, etc.
07:44:05 <nschoe> So that's handled.
07:51:45 <pie_> so someone had the idea that design patterns (a la OOP) are really maskings of language failings, which i found quite convincing at the time, but is this really something i should think?
07:52:56 <romanix> no
07:53:28 <Tuplanolla> I want to say yes, pie_.
07:53:32 <jmcarthur> Some design patterns make sense as "language features," but maybe not all.
07:54:00 <romanix> exactly, "not all"
07:54:12 <jmcarthur> Also not clear that just because it can be a language feature then it should be.
07:54:31 <pie_> ive been a bit interested in how to d osoftware architecture right for a while, but i havent really found anything i could "study"
07:54:36 <Tuplanolla> Are folds a design pattern? Are lenses a design pattern?
07:54:55 <pie_> and the usual advice is practice
07:54:59 <jmcarthur> Tuplanolla: I would say yes and yes.
07:55:27 <Tuplanolla> I'd say no, because they are first-class in a sense. You can reuse the same functions and modules to get them.
07:56:01 <jmcarthur> Well, you can use the same name, but the implementation can vary.
07:56:10 <jmcarthur> It's just a shared interface.
07:56:10 <jchia_3> Is there a better or shorter way to write "typeRep (Proxy :: Proxy Int)"?
07:56:14 <Tuplanolla> Design patterns, then, would represent those cases where doing so is impossible.
07:58:04 <Tuplanolla> In object-oriented languages design patterns like this tend to be class hierarchies, because you cannot do class hierarchy metaprogramming.
07:58:47 <pie_> (for the record i dont actually know a whole lot about oop design patterns)
07:59:01 <lyxia> jchia_3: typeRep (Proxy @Int), typeRep @Int Proxy
07:59:54 <jchia_3> lyxia: Thanks. Yeah, I should have thought of TypeApplications.
08:00:31 <lyxia> with an ambiguous typeRep we could write just  typeRep @Int  of course
08:01:08 <pie_> alternatively since i cant really find anything (thoguh that might just be my failing) on learning software architecture, i guess systems architecture / engineering might be something to look into
08:01:31 <lyxia> Type.Reflection is a better interface without ambiguity, and you can also write   typeRep @Int
08:01:32 <Tuplanolla> @where aosa
08:01:32 <lambdabot> I know nothing about aosa.
08:01:38 <Tuplanolla> @google aosa book
08:01:39 <lambdabot> http://aosabook.org/
08:01:39 <lambdabot> Title: The Architecture of Open Source Applications
08:02:03 <Tuplanolla> @where+ aosa The Architecture of Open Source Applications <http://aosabook.org/>
08:02:03 <lambdabot> It is forever etched in my memory.
08:03:15 <pie_> Tuplanolla, is case studies the only way to go? (not that theres anything wrong with that i guess)
08:03:37 <Tuplanolla> I don't know.
08:03:40 <plugin> I'm trying to understand how this indexing mechanism works in hvect: https://github.com/agrafix/hvect/blob/master/src/Data/HVect.hs#L148.  I can't seem to understand how to get an Int to an SNat so I can index out an element.  Can anyone provide prodding? 
08:03:55 <Tuplanolla> How often do you read books without examples?
08:08:30 <jchia_3> lyxia: Actually the second way doesn't work. typeRep has two type params, proxy & a, so it should be "typeRep @Proxy @Int Proxy".
08:08:40 <lyxia> jchia_3: oh right
08:08:42 <lyxia> damn
08:08:53 <lyxia> typeRep @_ @Int Proxy then?
08:09:51 <lyxia> plugin: case intToSNat 2018 of AnySNat n -> (use n here)
08:11:24 <jmcarthur> I'm a little surprised that in practice it seems like there aren't very many types that have interesting instances of  class Abs a where abs :: (a -> a) -> a  or  class Abs1 f where abs1 :: (f a -> f b) -> f (a -> b)  other than when an explicit goal is implementing the lambda calculus. Maybe it's because Monad and Category/Arrow are so often powerful enough and more convenient?
08:11:29 <kuribas> ph88: I have a linear equation solver, not sure that's what you're after?
08:11:47 <jmcarthur> I feel like that wasn't a well put together observation/question, but the gist is there.
08:12:05 <ph88> kuribas, ye sounds cool, does it include a parser ?
08:12:09 <kuribas> ph88: you can interleave linear equations and angular equations with non-linear evaluation in my library.
08:12:24 <kuribas> ph88: no, it implements Num, etc...
08:12:33 <ph88> oh ok
08:12:34 <jchia_3> lyxia: However, I can still define "tr :: forall a. Typeable a => TypeRep; tr = typeRep Proxy" and use "tr@ Int".
08:12:50 <plugin> lyxia: if I use an explicit forall:  Can't match 'n1' with 'n' if not:  Can't match 'p' with actual type 'SNat n'
08:13:28 <kuribas> ph88: why do you need it?
08:15:36 <ph88> kuribas, nice to be able to "reverse" a formula some time .. especially when it's a long one it's tedious to do manually
08:15:40 <jmcarthur> I guess it may just be that application is normally the only way to observe an abstraction, which means you might as well just keep it as a Haskell function instead of lifting it into the DSL.
08:16:01 <kuribas> ph88: use maxima?
08:16:30 <ph88> ah cool, never heard of that
08:17:12 <kuribas> ph88: I often use it when I am to lazy to work it out by hand, or if I want to assure that it's correct.
08:17:37 <ph88> is that possible to do with haskell functions as well ?
08:18:35 <kuribas> ph88: well, it would be nice to have something like sympy in haskell
08:18:43 <kuribas> Sadly there isn't
08:19:21 <ph88> i mean .. reorder the actual haskell functions ..
08:19:43 <kuribas> hmm, I don't think so
08:20:35 <kuribas> perhaps for a subset of haskell functions
08:21:11 <kuribas> ph88: you may be interested in the functional logic language curry.
08:21:24 <kuribas> it's sort of bidirectional
08:21:50 <kuribas> like prolog, but it looks like haskell.
08:22:14 <ph88> is @pl based on it ?
08:23:00 <kuribas> @pl?
08:23:00 <lambdabot> (line 1, column 1):
08:23:00 <lambdabot> unexpected end of input
08:23:00 <lambdabot> expecting white space, "()", natural, identifier, lambda abstraction or expression
08:23:08 <kuribas> shut up
08:23:43 <ph88> yes that guy
08:24:09 <ski> kuribas : "angular equations" ?
08:25:44 <kuribas> ski: like sin(theta) = 0.5, or finding the angle from a rotation matrix.
08:26:13 <ski> in Mercury, functions may (at least sometimes) be run backwards, i.e. given the function result (and perhaps some of the function arguments), compute possible values for the remaining function arguments
08:26:47 <ski> oh, trigonometric stuff
08:27:07 <Tuplanolla> I think the J compiler can also derive inverses in some cases.
08:27:20 * ski was for a moment wondering whether "angular equations" referred to inequations, using `<',`=<',`>',`>=', rather than `='
08:27:49 <kuribas> ski: I wrote it for a specific perpose, namely graphics.
08:28:05 <lyxia> plugin: show your code
08:29:50 <plugin> lyxia: https://gist.github.com/o1lo01ol1o/81f9b035e9a7b0df5df0eab6e2ad77db
08:32:48 <mivael> What are the ways for working around the compilation error ("Could not deduce..." in http://lpaste.net/359442) without using GHC extensions?
08:33:16 <cyberdudee> Hello Devs I m New here
08:35:16 <lyxia> plugin: if you want to return it you must keep it wrapped in an AnyNat
08:36:46 <mivael> I mean that I think I understand WHY my compilation error occurs.  I'm just in trouble on what design pattern(s) is(are) used to work that around similar issues?
08:37:17 <plugin> lyxia: ah, ok.  can you gloss why?
08:37:33 <mivael> s/to work that around/to work around/
08:40:42 <lyxia> plugin: What you want to return has n existentially quantified, not universally ("forall").
08:41:07 <lyxia> plugin: AnySNat is how this existential type is encoded in Haskell
08:41:50 <plugin> lyxia: right, ok, I understand that the quantification depends on the AnySNat now
08:48:49 <ski> mivael : your method signature `toOutput :: forall b. Builder b => b -> o' means that `toOutput' is required to accept *any* `b' which is an instance of `Builder', but your instance with `o' being `Str' expects `b' to be `SS' (also, that method implementation doesn't use `buildDecimalInt', so why do you require `Builder b' ?)
08:49:59 <puregreen> glguy: I had just spent half an hour trying to add a row to a GTK TreeView, and things were looking rather hopeless, but then I stumbled upon your CookieCalculator and got it working by looking at your code
08:50:06 <puregreen> thanks a bunch <3
08:53:25 <contiver> Is x *> pure y always the same as x $> y? Or is there some case in which they differ?
08:55:18 <felix1> contiver: if the laws are being followed for the applicative instance then it's always the same
08:55:20 <mbwgh> If I have some function `f :: (MonadSomething m a, Num a) => m (Maybe a); f = runMaybeT $ (*) <$> MaybeT ma <*> MaybeT mb`, can `MaybeT` be replaced with something more general? Would that be something like `generalize` from the mmorph package?
08:55:44 <puregreen> contiver: it might be slower but not sure
08:57:19 <ski> mivael : what is the purpose of trying to use type classes here ? do you want to be able to write generic code that works for both `SS',`Str', and for `BL.Builder',`TL.Text' ? or would simply defining `decimalIntToSS',`outputStrFromSS' and `decimalIntToBuilder',`outputTextFromBuilder' work ?
08:58:10 <mivael> ski: yes, I'm trying how it would be to write generic code
08:58:18 <contiver> puregreen: that's possible, but that would depend on each instance, and if they use the default definition from Functor (which says that (<$) is fmap . const), or they redefine it in some more efficient way.
08:58:27 <ski> mivael : another potential idea might to pass around (possibly different implementations of) functions like `buildDecimalInt',`toOutput' (perhaps together in a record ?), instead of using type classes
08:58:40 <ski> mivael : generic in what way ?
08:58:55 <contiver> felix1: thanks, that's good to know. I was thinking about doing a pull request for Hlint to suggest that, but needed to be sure.
09:00:05 <felix1> contiver: i think that would be handy! not that sometimes `<$` might be easier to read, so might want to suggest both in the message
09:00:21 <felix1> s/not /note /
09:00:24 <ski> mbwgh : .. not sure i follow your question
09:00:32 <mivael> ski: in a way in which one way of output could be easily replaced by another, without having to change code which uses those classes
09:00:37 <contiver> felix1, my idea is adding the four permutations, i.e. those two, and those including >>
09:00:48 <felix1> contiver: cool!
09:01:17 <xdccFriend_[8350> ciao
09:01:19 <xdccFriend_[8350> !list
09:01:20 <contiver> I guess I'll open an issue and if I have the ok, I'll get right on it. Thanks!
09:04:00 <mivael> ski: I know what toOutput signature means (and what the compilation error means, as I wrote earlier).  I put into that code an idea I would want to implement and what I need is an advise HOW to implement it right.
09:04:02 <ski> mivael : how about if you have something like `data InteractionOps build output = MkIOps {interact :: (output -> output) -> IO (),buildDecimalInt :: Int -> build,toOutput :: build -> output}' (not sure if you'd necessarily want the type `output' as argument of the callback passed to `interact' there) ?
09:04:48 <ski> mivael : then perhaps your code could take an `InteractionOps build output' as input (being polymorphic in `build' and `output', at least most of the time)
09:05:23 <mivael> ski: I'm thinking this over...
09:06:16 <ski> mivael : a variant here would be to use an existential `data InteractionOps = forall build output. MkIOps {interact :: (output -> output) -> IO (),buildDecimalInt :: Int -> build,toOutput :: build -> output}' (but in this case the `output' callback argument really is useless. you either want to add more fields, or to change that to another type, or both)
09:07:08 <ski> mivael : of course, the former here isn't that different from `class InteractionOps build output where interact :: (output -> output) -> IO (); buildDecimalInt :: Int -> build; toOutput :: build -> output' ..
09:08:34 <mbwgh> ski: Say you have a function which returns a result `m (Maybe a)` or `m (Either e a)` in some Monad m. You can use runMaybeT and the like to locally add a transformer layer to make error propagation easier. But if you call functions with return type `Maybe a` or `Either e a`, you'll have to turn them into their transformer equivalents first by wrapping them in MaybeT or ExceptT at their call sites. I just 
09:08:41 <mbwgh> wanted to know whether this can be generalized or if I am doing some obvious mistake.
09:08:44 <ski> with the existential, you get ensured that the code that takes an `InteractionOps' as input *can't* depend on the actual types `build',`output' being used. only the one that passes the `InteractionOps' will have access (in the "field implementations" to the innards of values of those types)
09:08:45 <mivael> ski: ...but class InteractionOps build output would require using GHC extensions, as I understand...
09:08:59 <ski> this might be good, or it might be bad, depending on what you want to do
09:09:08 <mivael> s/class InteractionOps build output/"class InteractionOps build output"/
09:10:45 <ski> mivael : yes .. as far as i can understand from what you want (i'm not sure about this), it seems like it's either that, or pass around records (or maybe there is a simpler solution ..)
09:11:56 <mivael> ski: I will think the InteractionOps possibility, thank you.
09:12:29 <mivael> (think ... over, I meant)
09:14:11 <ski> mbwgh : in general, monads do not compose. `Monad m' and `Monad n' does not yield `Monad (Compose m n)' (where `newtype Compose f g a = Compose (f (g a))')
09:14:58 <ski> mbwgh : .. not sure how `generalize' from `mmorph' would help ?
09:20:56 <glguy> puregreen: Oh cool, glad that the example helped
09:23:34 <mbwgh> ski: They use `hoist generalize :: (Monad m, MFunctor t) => t Identity b -> t m b` to change the Identity base monad to another one. So this isn't the same. What I was looking for is a way to generalize the transformer constructors themselves. I.e. going from `m (TransformerT Identity a)` to `TransformerT m a`.
09:26:46 <mbwgh> ski: Would this be of type (MonadTrans t, Monad m) => m (t Identity a) -> t m a ?
09:28:21 <ski> mbwgh : "they" ?
09:29:35 <ski> i don't think you could go (reverse direction) from `t m a' to `m (t Identity a)' like that, anyway
09:30:48 <mbwgh> ski: There are some examples in the library documentation. Specifically, I was referring to the "Generalizing base monads" example.
09:31:15 <mbwgh> "They" are Tekmo most likely :)
09:32:41 <mbwgh> Most likely I am overthinking this.
09:38:13 <ski> mhm
09:55:19 <MitchellSalad_> hello all, does anyone know what this generationless allocation means in the output of -S? http://lpaste.net/359445
09:55:29 <MitchellSalad_> "640" here
09:55:32 <MitchellSalad_> line 16
09:57:07 <lamdevhs> hi, i need help, i don't understand my mistake: http://lpaste.net/359446
09:58:10 <lamdevhs> btw if a pre-existing version of "eitherWay" exist, that would be great, no point in reinventing the wheel
10:00:03 <Gurkenglas> (forall a. a -> b) must ignore its argument
10:00:37 <lamdevhs> i think my mistake is that eitherWay expects a fully polymorphic function, not an ad-hoc one... is there a way to write eitherWay to allow ad-hoc polymorphic functions, regardless of the class?
10:00:41 <Gurkenglas> Therefore, eitherWay f _ = f undefined
10:02:50 <lamdevhs> sth like eitherWay :: forall (k :: Constraint) y a a' . (k a, k a') => (forall x. k x => x -> y) -> Either a a' -> y
10:02:59 <lamdevhs> ?
10:06:54 <alex1981> hi
10:07:15 <Gurkenglas> it would be k :: * -> Constraint
10:10:03 <Gurkenglas> How do I handle intero's M-. saying "No tags containing rectangleSolid"?
10:12:59 <Gurkenglas> I remember that there was a package about applying functors to every field of a record, it might help with eitherWay
10:19:10 <romanix> Gurkenglas, -XDeriveFunctor?
10:19:57 <Gurkenglas> No, something that transforms between {x :: f a, y :: f b} and {x :: g a, y :: g b} and that sort of thing
10:20:02 <Gurkenglas> It's an actual package
10:20:15 <romanix> oh, i see
10:24:29 <forker> ok, I know it has been asked many times before, but I have to do it: what do you guys use as an IDE? (ide name + ghc-mod version(s))
10:25:38 <sm> (intellij IDEA/emacs) + ghcid
10:30:23 <ertes> forker: (emacs + haskell-mode + haskell-interactive-mode) + none
10:30:34 <Gurkenglas> emacs + intero, dunno about ghc-mod stuf
10:30:36 <Gurkenglas> *f
10:30:54 <ertes> emacs users generally don't need ghc-mod
10:31:10 <ptek> forker: emacs + intero and sometimes sublime3 + SublimeHaskell
10:32:15 <kadoban> If I have some function f, and a constant k  and I do f k  in two separate places, does GHC ever memoize that? I know it usually doesn't, but I'm seeing memory usage that I can't otherwise explain at the moment. If it does that, can I tell it not to somehow?
10:32:38 <ertes> kadoban: try -fno-cse
10:33:01 <ertes> kadoban: if that doesn't help, then CSE is not the cause
10:33:10 <kadoban> Thanks, let me give that a try
10:33:10 <takitus> forker: Do you also ask mathematicians what they use for pencils?
10:34:01 <ertes> takitus: do you think it's a bad idea for mathematicians to talk about their tools?
10:34:10 <forker> takitus: I see no issue with that kind of question
10:34:52 <sedeki> what was the question?
10:35:51 <ertes> sedeki: <forker> ok, I know it has been asked many times before, but I have to do it: what do you guys use as an IDE? (ide name + ghc-mod version(s))
10:36:17 <sedeki> VS Code has pretty good haskell support I believe
10:36:31 <sedeki> I also use haskell-mode with emacs
10:36:42 <sedeki> however, I'm just a haskell beginner
10:37:22 <ertes> sedeki: i've been using haskell-mode for 10 years =)
10:37:42 <takitus> ertes: A theorem is pretty much the same theorem whether it's written out with a generic pencil or a Super Auto-Theorem Prover rapidograph :)
10:37:58 <ertes> takitus: that doesn't answer the question
10:38:19 <ertes> takitus: and no, i guarantee you, they're not the same ;)
10:38:30 <ertes> except perhaps in easy cases
10:42:25 <sm> pencils are a commodity item, haskell ides are not
10:43:23 <ptek> In mz opinion, the tools matter when you need to work with some industrial code - it is usually boring, sometimes repetitive, and not as concise as a theorem
10:43:28 <ptek> *my
10:44:10 <takitus> ptek: Indeed.
10:44:19 <kadoban> ertes: Ya, that didn't seem to change much. Something else must be up, I'll do some profiling I guess.
10:45:25 <lamdevhs> Gurkenglas: thanks, i abandoned though and just wrote either show show ^^
10:51:49 <forker> Thanks guys! You made me give emacs+intero another chance. It seems to work amazingly for me now :)
10:54:40 <mivael> ski: this is how I implemented your InteractionOps suggestion: http://lpaste.net/5659178020221485056
10:56:51 <mivael> ski: I'm not yet sure if it would scale well, but it really works!  (And it does not require any usage of GHC extensions).  Thank you very much.
10:57:43 <mivael> ski: Is it a name which is usually used to refer to such design pattern in Haskell?
10:58:02 <mivael> s/Is it/Is there/
11:05:55 <maffh> I using the library Data.Vector and data.Matrix and I am writing to write the function fromVectors : vector (vector a) -> Matrix a. It should be similar as the fromLists function from the Data.Matrix module. Currently, I have the following implementations http://lpaste.net/359447. It turns out that this code requires a lot of memory.  I have a tried all of the different folds, but it still requires a lot of memory. However, when I converted vector 
11:05:55 <maffh> to matrix with the following Data.Matrix.fromLists $ Data.Vector.toList, it was much faster and uses less memory. What's the best way to convert a vector to a matrix?
11:14:38 <Ariakenom> curl https://www.veins.you/blood
11:52:18 <lyxia> no thanks
11:54:35 <mxf> Hi *, to get a function Int(64) -> ByteString, I used Data.ByteString.Builder. To get the inverse, do I have to use bitshifts, masking, … using Data.Bits or is there a better way?
11:55:24 <geekosaur> if you're doing a lot of this, binary or cereal package may be of interest
11:59:46 <mxf> geekosaur, already using binary. Re-reading the docs and I'm thinking I might be able use decodeOrFail to stream over my ByteString
12:03:34 <mxf> But I really wish it wouldn't use String as an Error-"type"
12:09:00 <mxf> ah, there's an incremental Get interface.
12:09:18 <mxf> thanks again geekosaur for making me look at the docs again, heh.
12:13:45 <geekosaur> right, the usual way to do this is the Get monad which you can think of as a simple binary parser monad.
12:13:55 <ph88> how can i keep track of parenthesis count while parsing with megaparsec ?
12:16:35 <geekosaur> that's one of the things the user state parameter is for. (which in most cases is left at type () because it's not being used)
12:19:27 <ph88> https://bpaste.net/show/cddc84a8c7e5
12:21:13 <lyxia> ph88: doesn't parens take care of that
12:21:29 <ph88> i would think so ^^
12:24:47 <geekosaur> I suspect the real problem is elsewhere. just scanning it, I am wondering if you need a try on line 135: if it fails parsing funcExpr but after consuming some input, it won't 'unconsume' it before trying the Var alternative
12:25:09 <lyxia> yeah that looks like it
12:26:40 <geekosaur> (so then Var fails parse because it wants an identifier but funcExpr consumed it and it's looking at the ';')
12:27:53 <lyxia> Var just isn't tried because funcExpr failed after consuming input
12:29:23 <ph88> oh yes , thanks guys !
13:09:56 <ivegotasthma> hello
13:11:21 <ivegotasthma> I'm trying to figure out why a function produces a list result
13:11:49 <ivegotasthma> I have this: map (read . return) (show x) where x is an Int, and this returns [Int]
13:12:06 <glguy> :t map
13:12:07 <lambdabot> (a -> b) -> [a] -> [b]
13:12:10 <suzu> map uses []
13:12:15 <suzu> and so return has to use [] too
13:12:23 <ivegotasthma> an alternative is to use :[] for return, how does that work?
13:12:40 <hpc> suzu: not quite
13:12:50 <Lokathor> ivegotasthma, :[] doesn't seem like a type :/
13:13:04 <ivegotasthma> replacing return with (:[]) produces the same result
13:13:14 <Lokathor> oh i see, yes
13:13:26 <hpc> the function to map is relatively unconstrained
13:13:27 <ivegotasthma> I understand that the lambda reads a char and returns it
13:13:28 <hpc> :t read
13:13:29 <Lokathor> foo:[] is the same as [foo]
13:13:30 <lambdabot> Read a => String -> a
13:13:31 <ivegotasthma> this creating a list at the end
13:13:43 <hpc> read uses String, which is [Char], and composing that with return is what constrains that bit
13:13:56 <hpc> the result of the read is Int, which sets b = Int in the type of map
13:14:00 <hpc> resulting in [Int]
13:14:29 <ivegotasthma> I understand the return version
13:14:39 <ivegotasthma> I don't get the :[] one, what's :[]?
13:14:45 <hpc> :t (:)
13:14:47 <lambdabot> a -> [a] -> [a]
13:14:50 <hpc> :t (: [])
13:14:50 <ivegotasthma> Lokathor: this would produce a list of lists
13:14:52 <lambdabot> a -> [a]
13:14:56 <hpc> :t (:[])
13:14:58 <lambdabot> a -> [a]
13:15:14 <hpc> ivegotasthma: it plonks a value into a list of just that value
13:15:19 <hpc> by consing it with the empty list
13:15:27 <Lokathor> the (:) operator is being combined with the [] value
13:15:33 <Lokathor> it's like +2, but :[] instead
13:15:39 <hpc> it's an operator section
13:15:48 <Lokathor> whatever ends up on the left side will be in a 1 element list as the result
13:15:50 <ivegotasthma> :t (read . (:[]))
13:15:52 <lambdabot> Read c => Char -> c
13:16:01 <Lokathor> > 8 : []
13:16:03 <ivegotasthma> the hell
13:16:05 <lambdabot>  [8]
13:16:27 <ivegotasthma> flood from matrix?
13:16:43 <hpc> that happens a lot
13:17:35 <ivegotasthma> thanks for the help guys
13:20:47 <ph88> hoopl looks nice
13:27:23 <yas> hi guys I should write a thing to render graphs is there any library recommended? 
13:30:33 <test2342432> Hey, can anybody help me with my stack problem, I sincerely have no clue what I'm doing wrong. I've tried to read stacks docs but haven't figured out what my problem is. http://lpaste.net/5513955065590710272
13:30:44 <Cale> yas: There's a really nice library for 2D vector graphics called diagrams, and depending on which sort of graphs you mean, there's a library called Chart which might be useful, and it has a diagrams backend.
13:31:54 <Cale> test2342432: That's odd... perhaps a byte order mark or something weird like that?
13:32:56 <test2342432> Cale: what do you mean with "byte order mark"?
13:32:56 <hpc> does it need --- at the top?
13:33:10 <hpc> test2342432: it's a unicode thing that indicates the endianness of the file
13:33:17 <int-e> od -tx1 path/stack.yaml | head  could confirm this.
13:33:56 <geekosaur> test2342432, if you are on Windows, some editors will put a byte order mark at the start of a text file to indicate that it is UTF8 instead of ISO8859.
13:34:04 <int-e> (if the first two bytes are EF BB BF then there's a byteorder mark there
13:34:22 <int-e> s/two/three
13:34:23 <geekosaur> this includes many versions of Windows Notepad
13:35:08 <monochrom> I agree. Use a hex editor to see. Don't trust text editors, they lie all the time.
13:35:11 <test2342432> im using the haskell-vim-now package for vim on linux 
13:35:26 <Cale> Try int-e's command
13:35:29 <geekosaur> vim might well hide it for compatibility
13:36:11 <geekosaur> iirc vim treats it as part of the file encoding, and you can use a :set command to change the buffer encoding to one that doesn't include an initial BOM
13:36:49 <test2342432> hexdump looks fine (obtained via hd stack.yaml | less) http://lpaste.net/9135457281826095104
13:40:13 <Cale> test2342432: hmm, I don't know
13:41:07 <int-e> weird. can the location information of that error be trusted? (I don't know)
13:41:15 <test2342432> when i both delete the '.' and '- acme-missiles' lines it doesnt throw the error
13:41:57 <monochrom> Put them back. Will they cause an error again?
13:42:14 <test2342432> i use the mousepad editor to add the - acme-missiles-0.3 line and i get the same error again
13:42:20 <int-e> could there be mixed line ending conventions?
13:42:26 <monochrom> (And yes I'm going for "the BOM was there but the act of editing a file cleared it".)
13:43:05 <monochrom> What did you use to delete them?
13:47:18 <int-e> oh beautiful... the error seems to come from a piece of C code.
13:47:51 <int-e> (which, btw, knows about BOMs)
13:49:00 <test2342432> here is the whole hexdump i cannot spot any fishy newline symbol around the acme-missiles line nor can is see a bom http://lpaste.net/6295578541538934784
13:50:07 <monochrom> Yeah there is no "0d" so it is not a CR problem.
13:59:34 <hpc> is it using endashes?
13:59:51 <hpc> oh, there's a full dump
14:01:56 <hpc> the original location info was line 0 column 0
14:02:04 <hpc> whoops, scrolled up :(
14:04:22 <hpc> the original paste validates when i put it in a yaml validating website, fwiw
14:04:35 <int-e> test2342432: did you build stack yourself?
14:06:38 <test2342432> int-e: i installed it like its described in the docs https://docs.haskellstack.org/en/stable/README/
14:09:14 <test2342432> i run stack in a vm where i have the project laying in a shared folder, but i executed the hexdump command also in this vm so this shouldnt make a difference, should it?
14:26:07 <int-e> test2342432: sorry, no clue, except that it smells like a bug. It appears that the error is generated here (the string is unique in the stack executable): https://github.com/snoyberg/yaml/blob/master/libyaml/reader.c#L411-L418 ... and you have no characters in that range in your file. (Hmm, could the data come from another file?)
14:27:55 <tinco> jeez why is Vector.Unboxed so weird?
14:28:32 <tinco> it seems like there's loads of weird boilerplate to get an arbitrary type into an unboxed vector
14:28:54 <tinco> is it really such a complex thing?
14:28:54 <test2342432> int-e: do you know how i could workaround the extra-deps section not workign for me?
14:30:37 <jmcarthur> tinco: What's so weird about it?
14:30:55 <lyxia> tinco: they have to get into the vector unboxed, which is something standard Haskell has no notion of
14:32:32 <tinco> jmcarthur: well to put an arbitrary type in it, you have to define a new instance of the Vector class yourself, instead of it just being generic
14:32:43 <tinco> and then in the implementation you need a pragma:    {-# INLINE basicLength #-}
14:32:59 <int-e> test2342432: not really. I mean, I have crazy ideas... one of them is to strace the stack executable to verify that the error is in *that* .stack file; the other crazy idea is to edit the comments to change the offset of the apparently offending date.
14:33:31 <tinco> oh wait maybe that's not necessary
14:33:34 <tinco> that just inlines I guess?
14:34:43 <test2342432> int-e you are a stack dev?
14:37:10 <int-e> test2342432: no
14:37:15 <int-e> not even a stack user
14:37:38 <int-e> I just like digging into source code... to some extent at least
14:38:08 <test2342432> you just gave me an idea
14:38:13 <test2342432> <- stupid
14:38:48 <test2342432> <- wont use stack, wont have this problem....
14:42:33 <test2342432> int-e: you are the best :)
14:56:13 <Lokathor> worst part about a new LTS version is the compiling
15:03:40 <thoughtpolice> tinco: It could be made easier, certainly. I'd wager the real issue is "Most people don't write Vector instances directly but leverage the existing ones, so nobody cares about the ergonomics". Admittedly, this is rather cyclical reasoning, but *shrug*
15:03:55 <thoughtpolice> tinco: You can do much better specifically in the Unboxed case, however, with this package: http://hackage.haskell.org/package/vector-th-unbox
15:05:07 <thoughtpolice> Which essentially lets you write an Unbox instance for an arbitrary type by just providing a mapping between an existing instance, e.g. Complex a <-> (a, a)
15:05:20 <ph88> how come if i put files in a subdirectory of src that i can't load them directly with :load  anymore ?
15:07:54 <geekosaur> use -i src
15:08:05 <geekosaur> although maybe :load still won;t do that because it wants a pathname
15:10:18 <ph88> geekosaur, i can load the file with    :l src/testing/Test.hs    but then it can not find the modules which it depends on which are in the same folder ..
15:11:25 <Tuplanolla> I guess you could `:cd src` first, ph88.
15:11:42 <geekosaur> then you'd need -ik src/testing since 'testing' is not a valid module prefix
15:11:45 <geekosaur> er -i ...
15:12:02 <geekosaur> remember it does not have a file name, it has a module name. you need to tell it where to look for the file
15:12:12 <geekosaur> it's not going to search the whole project tree to find it
15:17:27 <ph88> how are the mappings from directories to module names done ?
15:18:41 <geekosaur> '.'s in the module name converted to '/', '.hs' appended, then directories specified in -i options are searched (default is -i .)
15:19:22 <hpc> ph88: in ghci, i generally use "import" instead of :l or :m
15:19:41 <hpc> or rather, "ghci Foo/Bar.hs"
15:19:54 <geekosaur> if using :load you likely need the actual path
15:20:09 <hpc> it makes :r behave predictably too
15:22:50 <ph88> i renamed the path to    src/Hoop/Test.hs  and inside of Test.hs i tried module name   Test and Hoop.Test    tried   import Test   and   import Hoop.Test   .. nothing gets loaded ^^
15:23:28 <hpc> try ghci -i src
15:23:50 <hpc> and module Hoop.Test
15:26:01 <ph88> ok
15:26:56 <ph88> nope still nothing
15:27:15 <ph88> perhaps i should add  src/Hoop  to  hs-source-dirs  in the cabal file ?   src is already there
15:28:04 <geekosaur> if you add src/Hoop then the module name you import in source has to be Test
15:28:31 <ph88> doesn't work either
15:28:42 <geekosaur> I don;t think import will work for this in ghci, ghci assumes you are importing from a package not your project
15:29:09 <geekosaur> in short, I don;t think you get to use a shorthand, you need a path for :load
15:29:11 <ph88> oh it worked now
15:29:50 <ph88> i used   :l src/Hoop/Test.hs    but that only started working after i added the src/Hoop directory to the cabal file ... it can now find the dependency Module's in the same directory
15:30:27 <ph88> so is it normal that all source files must be in the same directory? Or else how am i suppose to import a Module when i can only use :load  ?
15:38:47 <hexagoxel> ph88: why would that mean that all must be in the same directory?
15:43:00 <hexagoxel> and src/Hoop as hs-source-dir looks like a pseudo-workaround.
15:56:42 <mbwgh> Could somebody please explain to me how to extend an already existing interpreter for a free monad? That is, for each pattern match on the functor, do something with the arguments and the results of an already existing interpreter? For instance, add logging?
15:56:57 <monochrom> If you have "module A.M" in xxx/A/M.hs and you have "ghci -ixxx" then ":load A.M" works.
15:57:24 <monochrom> And no space between "-i" and "xxx". It's "-ixxx" in one piece.
15:57:30 <ph88> ah ok
15:57:38 <monochrom> This is different from gcc for example.
15:58:12 <monochrom> In fact "ghci -ixxx A.M" works too for that matter.
16:00:49 <ph88> ah ok i have to rename the Module and also rename it's dependencies import and add a prefix there
16:17:29 <Lokathor> when will stack and/or cabal know about rust so that I can write my FFI libs using rust instaed of C :(
16:18:02 <EvanR> when rust supports C linkage?
16:22:39 <Axman6> Lokathor: great question, I also want to know that answer
16:23:51 <Lokathor> EvanR, rust supports that out of the box though
16:24:35 <Lokathor> but i need stack and cabal to be smart enough to see that i'm linking against rust code and invoke rustc instead of gcc, for example
16:25:41 <monochrom> stack and cabal can't do much. It is GHC who needs to know FFI-to-Rust.
16:26:38 <monochrom> And it is GHC who is the one calling gcc.
16:27:42 <geekosaur> not entirely true, if you have C sources in your project then cabal calls gcc
16:27:46 <Lokathor> ah, hmm. Well rustc can produce a c-compatible library (called a "cdylib" in rust speak), so GHC doesn't need to learn a new ABI, just a new way to invoke the compiler
16:27:59 <Lokathor> oh
16:28:18 <monochrom> But take a look at $prefix/lib/ghc-8.2.1/settings to see if you can just tell it "my C compiler's name is rustc"
16:28:29 <Lokathor> well, whoever calls gcc just needs to learn to compile a properly configured rust project and then they'll get a .dll or .so file
16:29:02 <Lokathor> I suspect a lot of other options would need changes :/
16:29:08 <monochrom> After taming GHC, then it is meaningful to talk about cabal support.
16:29:41 <Lokathor> Well I'll just use Vector.Storable until someone does it :P
16:35:25 <monochrom> No, cabal still calls GHC for the C files.
16:36:26 <monochrom> I have "c-sources: src/x.c" and it leads to /usr/local/haskell/ghc-8.2.1-x86_64/bin/ghc -c -fPIC -odir dist/build -Idist/build/autogen -Idist/build/global-autogen -Idist/build -optc-O2 -hide-all-packages -package-db dist/package.conf.inplace -package-id base-4.10.0.0 src/x.c -split-sections
16:36:54 <hpc> Lokathor: a direct rust FFI is something i would like to see as well
16:37:18 <monochrom> Oh the last "-split-sections" is just because I have a "ghc-options: -split-sections" in my $HOME/.cabal/config
16:37:21 <hpc> Lokathor: new-ish GHCs can do the linear family of type systems, so it's theoretically possible to make a typesafe FFI
16:37:55 <hpc> someone just needs to do the work and see if it ends up being pleasant in practice, and i am not smart enough though :(
16:38:12 <monochrom> Approximately the only time cabal bypasses GHC is when creating the *.a file and it calls ar directly.
16:38:31 <hpc> (rust's mutability and borrow checkers form an affine type system)
16:38:34 <monochrom> That is, even to create the *.so file cabal still calls GHC.
16:39:22 <Lokathor> hpc, rust has a totally non-stable abi though ;_;
16:39:27 <hpc> yeah that too
16:49:26 <monochrom> Oh GHC is no stranger to unstable ABI :D
16:51:00 <Camm> Does anyone know how to parse an integer in the whole string with Megaparse? I'm doing this: `parse (many digitChar *> pure True) "" "12x"` and it always returns `Right True` because it parses `12`. However, I wan't it to fail because of the `x` present there.
16:51:34 <hpc> ghc feature request: randomized ABI - nothing links unless you build all of it at once
16:52:17 <hpc> Camm: you want to parse "end of file"
16:52:26 <hpc> which i thiiiiink is just eof
16:52:46 <hpc> parse (many digitChar *> eof *> pure True) "" "12x"?
16:53:02 <hpc> https://hackage.haskell.org/package/parsec-3.1.11/docs/Text-Parsec.html#v:eof
16:53:07 <Camm> Cool thanks
16:53:33 <Axman6> also, you can use <$ to make that a bit shorter: True <$ many digitChar <* eof (I think)
16:53:37 <Axman6> :t (<$)
16:53:39 <lambdabot> Functor f => a -> f b -> f a
16:53:57 <MarcelineVQ> if eof isn't what you want note that it's made with  notFollowedBy  which probably is what you want
16:54:03 <hpc> Camm: if you use a more complete parser runner, you should find that it parses the prefix of the string and produces a remainder of "x"
16:54:24 <hpc> (which is a useful behavior to have for stream parsers, as well as just being part of what makes parsers compose)
17:08:15 <Lokathor> odd fact
17:08:30 <Lokathor> performing a record update on an error value doesn't trigger the error at the point of the update
17:09:02 <EvanR> makes sense
17:09:16 <EvanR> an error value does nothing until it is evaluated
17:09:28 <Lokathor> yes
17:10:03 <Lokathor> but i didn't think that the record update would work on it, i thought it'd like, you know, see that an undefined was there and fail to update and become a new error or something
17:10:23 <EvanR> you can see that something is an error ahead of time
17:10:26 <EvanR> cannot*
17:11:11 <Lokathor> let me rephrase: I thought that record updating forced at least enough to discern undefined from not-undefined
17:11:30 <EvanR> why :)
17:12:37 <Lokathor> because of the way that the syntax looks visually :P
17:13:10 <EvanR> r { field = x }
17:13:29 <Lokathor> yeah
17:13:29 <EvanR> doesnt look like it uses (field r) at all
17:13:46 <EvanR> r { field = f (field r) } is another story
17:14:06 <Lokathor> the worst part about record updating is that it isn't a function :(
17:14:18 <EvanR> its not first class :(
17:14:28 <Lokathor> modifyIORef theConfig (\oldConfig -> oldConfig {_framebufferSize = (fbx,fby)})
17:14:30 <Lokathor> such sadness
17:15:19 <EvanR> Record { field $= f }, idris syntax for a function that can be applied to any record with field field, and updates the field by applying f to the current value :)
17:15:29 <EvanR> erm... lowercase record
17:15:44 <Lokathor> now the hard part
17:15:48 <Lokathor> actually doing math
17:35:31 <dmwit> geekosaur, fresheyeball: I thkn you've got the wrong guy. I know very little about reification.
17:38:45 <dmwit> Lokathor: Huh, I would also have expected a record update to force the constructor.
17:39:02 <dmwit> ?let data Test = A { a :: Bool } | B { b :: Int }
17:39:04 <lambdabot>  Defined.
17:39:08 <dmwit> > A { b = 3 }
17:39:12 <lambdabot>  error:
17:39:12 <lambdabot>      Ambiguous occurrence ‘b’
17:39:12 <lambdabot>      It could refer to either ‘Debug.SimpleReflect.b’,
17:39:17 <dmwit> ?undefine
17:39:18 <lambdabot> Undefined.
17:39:37 <dmwit> ?let data Test = A { fieldA :: Bool } | B { fieldB :: Int } deriving (Eq, Ord, Read, Show)
17:39:39 <lambdabot>  Defined.
17:39:41 <dmwit> > A { fieldB = 3 }
17:39:43 <lambdabot>  error:
17:39:43 <lambdabot>      • Constructor ‘A’ does not have field ‘fieldB’
17:39:44 <lambdabot>      • In the expression: A {fieldB = 3}
17:39:54 <dmwit> > let x = A in x { fieldB = 3 }
17:39:57 <lambdabot>  error:
17:39:57 <lambdabot>      • Couldn't match expected type ‘Test’
17:39:57 <lambdabot>                    with actual type ‘Bool -> Test’
17:40:07 <dmwit> yikes, I can't Haskell today
17:40:17 <dmwit> > (A True) { fieldB = 3 }
17:40:19 <lambdabot>  *Exception: <interactive>:3:1-23: Non-exhaustive patterns in record update
17:40:41 <dmwit> That certainly *looks* like it has to force the value being updated.
17:41:04 <dmwit> Lokathor: I suspect the *actual* problem here is that you are noticing the semantics of imprecise exceptions.
17:41:28 <Lokathor> dmwit, you're doing a branching record
17:41:36 <dmwit> Lokathor: Namely: if an expression can be evaluated to different exceptions in different evaluation orders, any of those exceptions is allowed.
17:41:41 <Lokathor> probably changes it quite a bit
17:43:05 <Lokathor> maybe, i was doing an IO thing and an IO operation did a modifyIORef record up date on a value that was an error
17:43:12 <dmwit> ?let data Test2 = A2 { fieldA2 :: Bool } deriving (Eq, Ord, Read, Show)
17:43:14 <lambdabot>  Defined.
17:43:35 <dmwit> > (error "a") { fieldA2 = True }
17:43:38 <lambdabot>  *Exception: a
17:44:18 <dmwit> I don't see how a record update could avoid forcing the value it's updating (for data, newtype is another story of course).
17:44:20 <Lokathor> fun, but still quite different, because you're immediately forcing it all for displaying
17:44:39 <dmwit> Oh, well. If you don't force it at all of course you will not get an exception.
17:44:47 <dmwit> > let x = (error "a") { fieldA2 = True } in x
17:44:50 <lambdabot>  *Exception: a
17:44:54 <dmwit> > let x = (error "a") { fieldA2 = True } in 3
17:44:56 <lambdabot>  3
17:44:57 <Lokathor> :P
17:45:11 <dmwit> > let x = (error "a") { fieldA2 = error "b" } in 3 -- still no exception
17:45:15 <lambdabot>  3
17:46:05 <dmwit> Okay, rereading, now I don't know what you mean by "performing a record update on an error value doesn't trigger the error at the point of the update".
17:46:49 <Lokathor> using modifyIORef to do a record update on an error will just keep the error, it won't exception
17:46:53 <dmwit> The only way I can read that doesn't make sense, because by analogy, no pure computation triggers an exception, ever.
17:47:33 <dmwit> Oh, your complaint is that modifyIORef doesn't force the thunk in the IORef? There's a strict analog of modifyIORef.
17:47:58 <dmwit> It's right below `modifyIORef` in the documentation. ;-)
17:48:06 <dmwit> (And it has the name you would guess: `modifyIORef'`.)
17:48:57 <Lokathor> yeah yeah
17:49:12 <dmwit> I mean what I'm saying is that it has nothing to do with record updates.
17:49:15 <Lokathor> i don't care in this case, because the normal case is that you have initialized the system and it won't error :P
17:50:36 <Lokathor> dmwit, have you ever had an experience where you, with absolutely no bassis for it, simply assumed something to be some way, for ages, and then one day it's not that way? Without violating any actual facts you held before (because you had none before anyway)
17:51:01 <machinedgod> h/7
17:51:23 <dmwit> Oh yeah, definitely! And in those situations, it's important to identify exactly what you were wrong about. And you were not wrong about record updates.
17:51:38 <Lokathor> but i was! :3
17:51:49 <dmwit> No, you were wrong about modifyIORef.
17:51:57 <Lokathor> oh no, i knew that it was lazy
17:51:57 <dmwit> Record updates *do* force the thing they're updating.
17:52:16 <Lokathor> only when they themselves are forced though
18:16:57 <monochrom> Use modifyIORef' if you want evaluation.
18:17:28 <monochrom> But "const 4 (seq undefined undefined)" is just going to be 4.
18:18:45 <monochrom> And "const 4 (seq (seq undefined undefined) (seq undefined com'on_evaluate_this_already))" is not going to be different despite the seq's piling higher and deeper.
18:37:48 <Lokathor> it is shockingly non-trivial to just print out the contents of an IOVector in ghci
18:38:48 <Lokathor> monochrom, i know about the strict version but don't actaully care about the evaluation being sooner or later
18:40:54 <Lokathor> my chief concern was actually that it would overwrite the error instead of causing it to occur
19:19:35 <maskedlure> C:\Windows\system32>for /f %i in (C:\Users\holmes\Desktop\hostnames1.txt) do C: \Users\holmes\Downloads\PSTools\psexec.exe \\%i -d "C:\Windows\System32\cmd.exe  smc -stop" & "C:\Windows\System32\cmd.exe  smc -stop"
19:19:44 <maskedlure> Is there a way I can run this command on multiple computers using psexec which runs the command smc -stop and then smc -start?
19:19:47 <maskedlure> (this is for symantec endpoint protection)
19:19:51 <maskedlure> i need to use psexec
19:20:10 <felix1> i cannot figure this out for the life of me (ambigious type error): https://pastebin.com/wgAXiuEx
19:26:37 <lyxia> felix1: ent in the type signature is not bound to ent in the function definition
19:27:01 <felix1> lyxia: how come?
19:27:07 <lyxia> felix1: you need to enable RankNTypes, ScopedTypeVariables, and to add a "forall ent" at the start of the signature
19:27:09 <felix1> i have scopedtypevariables on
19:27:14 <dmwit> maskedlure: That doesn't sound much like a Haskell question...
19:27:18 <felix1> ah
19:27:30 <glguy> lyxia: Where did RankNTypes come in?
19:27:39 <dmwit> Everybody forgets the forall their first time with ScopedTypeVariables. =P
19:27:51 <felix1> lyxia: THANKS!
19:27:52 <dmwit> We ought to have like an FAQ entry for it or something.
19:27:59 <felix1> lyxia: the explicit forall did the trick :D :D :D
19:28:10 <MarcelineVQ> Or maybe some sort of manual explaining these things, hmm..
19:28:21 <dmwit> heh
19:28:50 <lyxia> glguy: oh right ExplicitForAll seems to be implied by ScopedTypeVariables already
19:28:50 <maskedlure> dmwit: i am wondering how it would look in haskell
19:28:59 <maskedlure> can psexec be used in haskell?
19:29:44 <lyxia> felix1: so RankNTypes is unnecessary. But the forall must be explicit, as otherwise turning on ScopedTypeVariables alone could change the meaning of a program
19:30:42 <lyxia> I'm only guessing the reason... the more I think about it the less sound it sounds.
19:32:00 <felix1> lyxia: anyway, it compiles now, I am super happy. was stuck on that far too long
20:18:11 <dmwit> maskedlure: Sure, check out the process package.
20:18:13 <dmwit> ?hackage process
20:18:13 <lambdabot> http://hackage.haskell.org/package/process
20:19:54 <maskedlure> dmwit: Can you show me an example?
20:21:45 <dmwit> createProcess (proc "C:\Users\...\psexec.exe" ["first-hostname", "-d", "C:\\Windows\\System32\\cmd.exe smc -stop", "C:\\Windows\\System32\\cmd.exe smc -stop"])
20:35:29 <skm_baig> Hi, can anyone plz let me know why '(* 5 6)' is an error?
20:35:58 <glguy> that's equivalent to (* (5 6))
20:36:10 <glguy> which expands out to \x -> x * (5 6)
20:36:21 <glguy> and presumably you didn't want to apply 5 to 6
20:37:36 <skm_baig> glguy: but * is an operator. And if I'm correct operator == function application in haskell. Isn't it?
20:37:58 <dmwit> You can turn infix operators into prefix operators with extra parentheses.
20:38:02 <dmwit> > (*) 5 6 -- is ok
20:38:04 <lambdabot>  30
20:38:05 <dmwit> > 5 * 6 -- is ok
20:38:08 <lambdabot>  30
20:38:14 <dmwit> > * 5 6 -- is not ok
20:38:17 <lambdabot>  <hint>:1:1: error: parse error on input ‘*’
20:38:48 <dmwit> Function names that contain only punctuation are infix by default. Function names that contain only non-punctuation are prefix by default.
20:39:20 <skm_baig> dmwit: So this means haskell differentiates between infix and prefix functions/operators.
20:39:27 <dmwit> (And, to complete the story, though you didn't ask, you can use a prefix name as an infix operator by surrounding it with backticks.)
20:39:30 <dmwit> skm_baig: Yes.
20:39:45 <skm_baig> dmwit: can we define our own infix operators/funcitons?
20:39:46 <geekosaur> yes, but provides ways around it.wrap an operator in parens to use it prefix, wrap a function in `` to use it infix
20:39:49 <dmwit> skm_baig: Yes.
20:40:08 <dmwit> > let a +*+ b = (a + 3) / b in 5 +*+ 7
20:40:10 <lambdabot>  1.1428571428571428
20:40:39 <geekosaur> btw  I would not have said 'by default' there because you can't defne it differently
20:41:06 <dmwit> geekosaur: I guess "by default" was to hint that you can switch with parens or backticks.
20:41:10 <geekosaur> that is, you can't define an infix alphanumeric operator at all. but you can define an alphanumeric function and use it infix by wrapping in ```
20:41:43 <dmwit> ...but thank you for clarifying that, as I can see how that might be confusing.
20:43:08 <geekosaur> Haskell likes its character class-based stuff. this, or treating names starting with uppercase as constructors, etc,
20:49:33 <skm_baig> dmwit: so is this differentiation between infix and prefix notation only syntactic in nature, as under the hood both probably act as function application?  Or is there some deeper meaning to it?
20:49:58 <dmwit> Yes, it is only syntactic. And as mentioned there are syntactic conversions between the two forms.
20:51:22 <skm_baig> dmwit: ok thanks.
20:52:02 <geekosaur> skm_baig, when you support things like partial application, the compiler kinda needs syntactic hints as to how to parse things
20:52:52 <geekosaur> there are ways around it but they lead to other kinds of problems (possibly including the compiler not being able to figure out what you meant at all)
20:52:59 <Lokathor> Segmentation fault/access violation in generated code
20:53:01 <Lokathor> delicious
20:54:11 <alhariel> so im trying to run this: stack install apply-refact --resolver=nightly
20:54:18 <alhariel> and i get this https://pastebin.com/6N5njPMM
20:54:56 <geekosaur> what kind of system is this?
20:55:05 <geekosaur> I mean what linux distro
20:55:09 <alhariel> manjaro
20:55:13 <alhariel> its arch for noobs
20:55:20 <geekosaur> right, you have to remove the tinfo package
20:55:32 <alhariel> hm ok
20:55:38 <geekosaur> stack uis assuming what works for debian works for arch/manjaro and instals an incompatible ghc
20:55:43 <geekosaur> which produces those errors
20:55:57 <foojs> hello to smartest people on the planet 
20:56:08 <foojs> and the smartest language
20:56:35 <bitemyapp> nah I use Haskell cuz I'm dumb.
20:57:25 <alhariel> i was getting this, which is why ive tried installing the tinfo package https://pastebin.com/L3Du61ar
20:57:29 <alhariel> which is also what i get now
20:57:32 <geekosaur> (tinfo6 is a compatibility package; hopefully you don't actually need it)
20:58:33 <geekosaur> that sounds like something else built wrong. and that something else is being used via TH.
20:59:37 <foojs> i'm learning FP to learn pure math.
21:00:13 <alhariel> so what do i do s:
21:01:01 <foojs> and being surrounded by you people makes me do something worthy :)
21:01:44 <geekosaur> aaaand the package in question is ghc (that is, ghc as a library). :( this might be an 8.2 issue; last I checked tinfo was only needed by haskeline, not ghc-api itself
21:02:47 <alhariel> so do i wipe .stack and try again?
21:03:25 <geekosaur> no, it'll just repeat the problem
21:03:36 <geekosaur> this is a stack bug
21:03:52 <alhariel> ugh
21:03:59 <foojs> i love philosophy alot :)
21:04:01 * geekosaur digs a bit deeper
21:04:37 <MarcelineVQ> back when I was still mucking with setups on arch I had to install libtinfo6 off the AUR at some point to get things to click properly
21:04:43 <geekosaur> ok, so the actual error indicates that ghc is telling gcc to use short relocations instead of long ones
21:04:59 <alhariel> the first time i ran the command it complained about a missing libnuma.so.1, so then i installed numactl
21:05:02 <geekosaur> if you can find the settings file for the ghc stack is using, you could look for -fpic and replace it with -fPIC
21:05:34 <geekosaur> then you'd need to reinstall libtinfo6
21:06:31 <Lokathor> HA
21:06:37 <Lokathor> didn't have a current GL context
21:06:38 <Lokathor> of course
21:07:01 <geekosaur> but I don;t see -fpic in mine... hope it's not being added by ghc itself :/
21:07:59 <geekosaur> and I was also kinda hoping maybe unix-compat was doing it, but it's not
21:08:07 <geekosaur> at least not explicitly, which would have been fixable
21:08:21 <geekosaur> so this could be stack or it could be ghc 8.2
21:08:26 <alhariel> hm
21:08:29 <geekosaur> (ro possibly Cabal)
21:10:01 <MarcelineVQ> Lokathor: is this where you create a Monad that manages the context for you so you always have one?
21:10:23 <Lokathor> no this is the new version where it's got a gobal IO ref ;3
21:18:49 <MarcelineVQ> alhariel: what version is your stack btw? when encountering build errors the first two steps to make are often   stack upgrade && stack setup  --resolver=whateveroneyou'rehavingtroublewith
21:19:08 <mud> There's about to be a new release of stack it seems too
21:21:54 <alhariel> Version 1.5.1, Git revision 600c1f01435a10d127938709556c1682ecfd694e (4861 commits) x86_64 hpack-0.17.1
21:25:16 <alhariel> guess ill have to wait for the new version
21:26:01 <MarcelineVQ> waiting isn't the best bet for this problem unless you've found a git issue saying it's solved next release.
21:26:40 <MarcelineVQ> in which can you could do  stack upgrade --git  and laugh at the foolish plebians who know not your power.
21:27:01 <MarcelineVQ> But you'd need that solved git issue for that.
21:27:31 <mud> Well, you could just try it too and hope for the best, but obviously that's more of a guessing game.
21:27:58 <alhariel> i dont even know what the issue is lel
21:29:02 <Lokathor> MarcelineVQ, good news, I can already draw a huge monochrome window!
21:30:33 <MarcelineVQ> Lokathor: you've made it
21:30:50 <Lokathor> naw, now i need to make it do more than one color
21:57:43 <PCChris> In .cabal/config, how do with-compiler and program-locations/ghc-location interact?
21:58:50 <felix1> i am using persistent and am looking for a migration library. any recommendations? My only real requirement is that I can execute both sql migrations and from haskell code
22:00:09 <felix1> i wouldn't mind if whatever tool i end up using could simply generate the .sql script from haskell and I dump that into my migrations directory. In fact, I think that would be superior
22:01:08 <foojs> you generate from haskell .sql? felix1 
22:02:10 <foojs> i do this often mysql -uroot -pmypwd> dump.sql'
22:05:42 <felix1> foojs: sorry no i mean generating the sql code from a persistent query
22:05:56 <foojs> ** with db name after password :P
22:06:11 <felix1> sort of capture what it would send to the database and dump that into a sql file
22:10:28 <Lokathor> i wish that haddock would cajole me to document even my private functions
22:11:51 <lyxia> Lokathor: https://haskell-haddock.readthedocs.io/en/latest/markup.html#module-attributes ignore-exports
22:14:39 <Lokathor> oh my gosh
22:16:33 <Lokathor> hmm, but i want it to show only the exported things in the generated docs, just bug me in the terminal output when i'm less than 100%
22:16:40 <Lokathor> oh well, i can turn it off and on
22:26:27 <felix1> db migrations seems to be such a fundamental issue, how do you guys deal with it? should deriving a sql script from persistent be possible?
22:26:59 <felix1> digging into the TH stuff now that creates the migrations (since they have a `printMigration` command for it, so hoping there's sth there)
22:31:16 <osa1> migrations are hard if you're using persistent because persistent doesn't let you run a query on an arbitrary table (e.g. you can't pass a table name to  `selectList`)
22:32:52 <osa1> some other db libraries like serde (which is probably not production-ready, btw) allows this
22:33:57 <osa1> felix1: I had some migration examples here: https://github.com/osa1/migration-test
22:36:54 <felix1> osa1: thanks, so pretty much roll your own?
22:38:28 <osa1> felix1: there're some solutions on Hackage if your migrations can be done in SQL. if you need to run code during migrations then I think you're on your own, yeah.
22:39:11 <osa1> if you search for "migration" on hackage you'll see some libraries, IIRC all of them are only for pure SQL migrations, e.g. the whole process should be done in an SQL script
23:11:29 <felix1> osa1: sorry, i don't get notifications on ubuntu when i get mentioned here on weechat :/ still haven't figured out an acceptable IRC workflow
23:12:48 <felix1> osa1: that's a bit of a bummer for anything but trivial migrations :/
23:18:48 <osa1> felix1: it's hard to generate notifications from terminal IRC clients because terminal focus-gained/focus-lost events are (1) not supported by all terminals (2) doesn't work in tmux (3) usually not precise enough (e.g. switching to another workspace may not trigger focus-lost etc.)
23:20:24 <osa1> felix1: do you know any other languages with good migration libraries? last time I checeked I couldn't see a library with a migration API for running code (e.g. non-SQL stuff) during migrations
23:23:39 <felix1> osa1: django is pretty awesome
23:23:45 <felix1> osa1: and knex for JS is good
23:24:05 <felix1> osa1: yeah I'm on tmux
23:27:18 <osa1> felix1: both of these examples are dynamically typed, I haven't worked on a DB library in Haskell but I can guess that it'd be much harder to do. in any case I have some working examples in the git repo I showed. there's actually a way to do something similar using persistent but it's a bit verbose (but type-safe). I should probably update the repo sometime.
23:28:24 <felix1> osa1: woa, yeah i'd be keen to see that
23:31:53 * dysfun too
23:32:15 <dysfun> i would like to say i don't agree django migrations are awesome though
23:32:53 <felix1> dysfun: how come?
23:32:59 <dysfun> i recently inherited a django codebase which shall we say 'experienced extreme organic growth'
23:33:23 <dysfun> and the atrocities committed in the name of migrations i have seen can never be bleached off my brain
23:33:33 <felix1> dysfun: yeah, to be honest i have not worked on a django project in a team
23:33:42 <felix1> haha xD
23:33:59 * dysfun is porting it to elixir/phoenix, whose migrations thing i don't completely hate
23:50:56 <osa1> dysfun: where can I see elixir/phoenix migration code/documentation? I checked docs and guides pages
23:56:10 <dysfun> osa1: ah, it's part of 'ecto', the library phoenix uses for DB stuff
23:56:18 <dysfun> or rather the library they default to
23:57:22 <dysfun> https://hexdocs.pm/ecto/Ecto.Migration.html#content
