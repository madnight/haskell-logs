00:52:02 <ggVGc> is there a better alternative than ghc-mod for haskell devleopment in vim?
01:05:53 <erisco> ggVGc, better than this, specifically? https://github.com/eagletmt/ghcmod-vim
01:10:02 <ggVGc> erisco: yeah, that's what I've been using for years, but ghc-mod is quite a pain since it keeps breaking on my system, and doesn't play well with stack
01:10:27 <erisco> no idea, sorry
02:59:40 <unga> hi folks! I dont' get why this (https://gist.github.com/giulioungaretti/f5508169a8ac8cccc683c42fdde7870f ) is not correct
03:01:46 <unga> I would expect that function to always return  type float
03:05:28 <srhb> unga: You don't get to choose that, the caller does
03:05:40 <srhb> You're implying that plus will work for ANY Num a that the caller chooses
03:05:47 <srhb> That is untrue, since it will only work for Float.
03:05:51 <srhb> The compiler is calling you out on that.
03:06:24 <unga> srhb: then I am utterly confused 
03:06:34 <srhb> Say that I choose a ~ Int
03:06:54 <srhb> Do you agree that c + b + d is a type error then?
03:07:51 <unga>  kindof :/ 
03:07:59 <srhb> > (1 :: Float) + (1 :: Int)
03:08:03 <unga> I mean I can do 0 +0.1 
03:08:03 <lambdabot>  error:
03:08:04 <lambdabot>      â€¢ Couldn't match expected type â€˜Floatâ€™ with actual type â€˜Intâ€™
03:08:04 <lambdabot>      â€¢ In the second argument of â€˜(+)â€™, namely â€˜(1 :: Int)â€™
03:08:11 <srhb> Yes, but then the first 0 is a Float too
03:08:19 <unga> right
03:08:21 <srhb> Or at least some floating point type.
03:08:29 <unga> that make sense
03:08:43 <srhb> Values don't automagically cast, but literals have a form of polymorphism
03:08:55 <srhb> When you write 0 it's actually fromIntegral 0
03:09:13 <srhb> :t 0
03:09:15 <lambdabot> Num p => p
03:09:17 <unga> ah that explains it 
03:09:31 <srhb> But this doesn't happen outside of literals at all.
03:09:42 <srhb> And your signature contains an implicit forall
03:09:52 <srhb> forall a, where a has a Num instance, Test a -> Float
03:10:07 <srhb> But this is untrue, as I can show by choosing a ~ Int
03:10:11 <srhb> The compiler does the same.
03:10:31 <unga> thanks! now I got this
03:10:34 <srhb> Cool :)
03:10:42 <unga> the :t 0 explained 
03:11:36 <unga> is there then a way to have that function reutrn a "Num" ?
03:11:50 <srhb> Not with that type and semantic.
03:12:07 <srhb> As long as you're adding a Float somewhere, it will always be Float, because...
03:12:11 <srhb> :t (+)
03:12:14 <lambdabot> Num a => a -> a -> a
03:12:32 <unga> ah, perfect 
03:12:33 <srhb> pick any a that has a Num instance, but both arguments AND the result will have the same type.
03:15:06 <unga> great
03:15:09 <unga> thank you so much 
03:15:12 <srhb> You're welcome.
03:15:16 <unga> very helpful !
04:07:31 <kuribas> writing types first seems like a form of test driven development
04:08:25 <srhb> It's some kind of TDD, only the T is types!
04:08:29 <srhb> Er, type.
04:10:05 <kuribas> type driven development :)
04:11:53 <Maxdamantus> The tests just happen to consist of an infinite number of cases.
04:12:23 <DigitalKiwi> that's a lot of tests, how does the suite ever complete?
04:13:09 <Maxdamantus> With ease.
04:14:10 <DigitalKiwi> but they're infinite!
04:17:21 <kuribas> DigitalKiwi: by induction :)
04:18:03 <srhb> #inductionisalie
04:18:51 <DigitalKiwi> keep your filthy twitter tags on twitter
04:19:16 <Maxdamantus> #nomorehashtags
04:20:15 <liste> #lets #assume #things  that start with # are channels on IRC
04:21:05 <kuribas> srhb: although Type driven development is more like programming with typed holes.
04:28:55 <geekosaur> and not random lispvals?
04:44:43 <lambdamu> Is it possible to remove a finalizer from a foreignptr?
04:54:26 <shafox> I am getting error: parse error on input ‘do’ on this block of code: https://gist.github.com/shadow-fox/242a1dc920e83e76c2288d936e2e7492 .  What is wrong ?
04:55:05 <lyxia> shafox: you can't apply a function to a do directly
04:55:21 <lyxia> tagNoAttr "revision" $ do ...
04:56:59 <shafox> lyxia, oh, thank you. 
04:59:04 <xormor> I think Haskell works like a line-by-line functional calculator, that has the option to edit the lines as wished by the programmer.
04:59:41 <xormor> now that I have learned how to do some Haskell, it seems quite terse and compact - and a bit dry and boring.
05:00:04 <nicknight> haskell is the only language where I didn't write "hello world" as my first line 
05:00:05 <xormor> cbmbasic is more exciting to me, because it brings me back childhood memories.
05:00:11 <xormor> nicknight, yeah
05:01:15 <mniip> xormor, I find excitement in both high level abstract functional programming, and low-level bit hackery
05:01:30 <xormor> mniip, yeah
05:02:06 <xormor> mniip, me too - except my favorite languages are C, C++, asm (both x86 and amd64).
05:02:23 <xormor> mniip, I would probably like to learn other assembly languages as well.
05:02:42 <mniip> x86 and amd64 in one sentence huh
05:03:32 <merijn> xormor: x86 and amd64 are the only assemblies you know and you still like it? :p
05:03:44 <merijn> Those are dreadful instruction sets :p
05:04:07 <xormor> merijn, well.. I never owned an Amiga nor a C64.
05:04:12 <mniip> merijn, most common ones
05:04:20 <merijn> xormor: 8088 was also prety nice :p
05:04:36 <mniip> I started with 8086 I think
05:04:46 <mniip> at some point consciously learned x86
05:05:18 <xormor> merijn, my PC hardware have been x86 and amd64 hardware, x86_64 or i586, i686, ... I had an i486 in the '90's and still had it in 2004 until the power source broke down.
05:05:20 <mniip> then learning arm and aarch64 was a matter of days
05:05:35 <xormor> We had an i386 too, and a 286 - they were in the '80's.
05:06:05 <xormor> I like difficult things on computers - I become depressed if everything goes too well and easily.
05:06:35 <xormor> Sometimes I do weird stuff on my GNU/Linux systems for the purpose of breaking and repairing the software.
05:06:56 <merijn> xormor: I can give you and endless supply of my problems to fix :p
05:08:11 <xormor> merijn, great :D
05:08:41 <xormor> merijn, I fixed a very minor display bug on omega-rpg for Debian.
05:08:58 <xormor> merijn, then I started translating the game's messages into Finnish.
05:12:35 <merijn> xormor: You can fix ghc-mod (or any of the other vim supporting tools for error highlighting) to work with new-build :p
05:13:10 <xormor> merijn, ok..
05:13:14 <xormor> merijn, what does that mean?
05:14:05 <merijn> xormor: cabal-install has a new Nix inspired method for compiling projects and using local dependencies, but none of the tools like ghc-mod for automatically highlighing compile errors work with it yet
05:14:23 <merijn> xormor: And some related commands, like new-haddock and new-install don't work/aren't implemented yet :p
05:24:07 <xormor> merijn, is here a clue for the missing features? ---> https://pastebin.com/ANhYUCAN
05:31:37 <Tuplanolla> Which package should I use for homogeneous tuples?
05:34:44 <ShalokShalom_> Are type annotations important, when I use imperative programming in Haskell?
05:34:48 <ShalokShalom_> Like here: https://gist.github.com/gatlin/9696088
05:35:09 <merijn> ShalokShalom: I'd say type annotations are always important, imo
05:35:15 <ShalokShalom> so?
05:35:28 <merijn> So, "yes"? :)
05:35:32 <ShalokShalom> type inference?
05:35:46 <ShalokShalom> I mean, can i code without?
05:35:59 <merijn> ShalokShalom: Type inference can infer them, but the reason to write them is because else the reader has to infer them too
05:36:07 <ShalokShalom> yes
05:36:17 <merijn> ShalokShalom: Type annotations are useful because it makes code easy to read, imperative or not
05:36:32 <ShalokShalom> to me, it adds clutter
05:36:36 <ShalokShalom> thanks
05:36:39 <Tuplanolla> There are cases when type annotations are required, but not here, ShalokShalom.
05:36:56 <ShalokShalom> Thanks a lot
05:37:32 <merijn> xormor: I don't really know a minimal example of when things stop working, but I also don't know what haskell-mode uses for error highlighting
05:37:40 <hpc> ShalokShalom: there are a couple of good exercises that show how helpful types are
05:37:58 <hpc> ShalokShalom: one is to write a complicated type and try to write a value of it
05:38:07 <hpc> another is to write a complicated value and try to figure out its type manually
05:38:09 <ShalokShalom> to me, a clutter free experience is one of the fundamental important things to mee
05:38:11 <ShalokShalom> me
05:38:26 <hpc> those will usually happen on their own as you code
05:38:34 <ShalokShalom> I am used to fsharp, the IDE shows which type is used, when I hover over it
05:38:36 <ShalokShalom> 2017
05:38:40 <ShalokShalom> :)
05:38:42 <kuribas> One is not having to click through a UI just to find a simple type error (several times).
05:38:51 <ShalokShalom> hover
05:39:20 <merijn> ShalokShalom: I never touch my mouse during programming, so that'd be annoying
05:40:08 <Tuplanolla> If you have code that gets inferred a type requiring, say, `FlexibleContexts` and you want to expose it without the requirement, you need type annotations to specialize it, ShalokShalom.
05:40:11 <hpc> i do it often enough that i don't like having latency greater than an eye twitch to figure out the type of something
05:40:25 <ShalokShalom> merijn: you can do it in several other ways too
05:40:34 <Tuplanolla> If you need higher-rank polymorphism, that one will never be inferred, so you have to add annotations to generalize it too.
05:40:55 <ShalokShalom> Tuplanolla: This sounds more like special cases
05:41:06 <ShalokShalom> To me, a clutter free experience is essential
05:41:10 <kuribas> Another advantage of types is that errors are much more clear
05:41:18 <Tuplanolla> Depends how special your work is.
05:41:52 <Tuplanolla> If you live in types, these will not be special cases anymore.
05:42:06 <Tuplanolla> They come up quite often.
05:44:02 <hpc> it depends on what is "clutter" and what is "information"
05:44:20 <hpc> you might find it more clutter-free to organize your IDE in the opposite direction
05:44:29 <hpc> show only names and types by default, and collapse definitions
05:44:48 <hpc> :t forkIO -- this definition might be a dozen lines long, but with a name and type signature you know exactly what it does
05:44:51 <lambdabot> error: Variable not in scope: forkIO
05:44:56 <hpc> oh right
05:45:01 <hpc> forkIO :: IO a -> IO ThreadId
05:45:50 <merijn> hpc: *bzzt* :p
05:45:59 <Tuplanolla> We'll talk again once you've met `MonadBaseControl`, ShalokShalom.
05:46:08 <hpc> good luck figuring out what that does from this:
05:46:08 <hpc> forkIO action = IO $ \ s ->
05:46:08 <merijn> forkIO, annoyingly is "IO () -> IO ThreadId" :p
05:46:09 <hpc>    case (fork# action_plus s) of (# s1, tid #) -> (# s1, ThreadId tid #)
05:46:09 <hpc>  where
05:46:09 <hpc>   action_plus = catch action childHandler
05:46:28 <hpc> merijn: it should be IO a, imo
05:46:42 <merijn> hpc: I agree, but still
05:49:09 <hpc> actually, that's a perfect example
05:49:18 <hpc> just looking at that definition, you would never know if it took IO () or IO a
05:49:29 <hpc> you're forced to ask the IDE
05:49:45 <hpc> and if you need to debug that on another computer you're hosed
05:50:50 <hpc> or maybe the bug causes forkIO itself to have the wrong type, how do you notice that?
05:51:01 <hpc> ghc will tell you the error is at the call site
06:02:52 <ShalokShalom> hpc: Once again, i rely on the IDE because its helpful
06:03:08 <ShalokShalom> Not because I feel 'forced to'
06:03:33 <nicknight> haskell have any ide ?
06:04:18 <hpc> nicknight: vim/emacs plugins, mainly
06:04:23 <nicknight> specific one like eclispe to java, pycharm to python*
06:04:35 <nicknight> hpc:  Ok only vim.emacs :)
06:04:47 <hpc> there's also leksah, but i have no idea how good it is
06:06:02 <nicknight> hpc:  no problem anyway vim is favouritfor many
06:08:03 <nicknight> i heard we do very less debugging/or very least when come to haskell true?
06:08:25 <nicknight> due to its no side effects
06:09:48 <Athas> nicknight: true.  Or rather, debugging is simpler.
06:09:48 <hpc> yeah, the combination of purity and a good type system catches large classes of bugs at compile-time
06:10:33 <Athas> Debugging larger Haskell programs, especially those that operate on large complicated data structures, can still be hard.
06:10:34 <hpc> all of the "did i handle null / numbers / strings" debugging vanishes
06:11:05 <hpc> purity makes it easier to reason about things in isolation as well, so when you have an error in your application you can often pinpoint it to within a few lines of code and then just stare at it for a few minutes
06:11:30 <hpc> instead of breaking out your runtime inspector of choice like gdb or a browser's f12
06:12:21 <hpc> you can get this level of easy debugging in other languages as well, you just have to make sure you're manually doing the things a compiler would for you
06:12:35 <hpc> and as always, writing good abstractions helps as well
06:12:53 <nicknight> ok 
06:13:55 <balac> nicknight: sublime text has some plugins for haskell
06:14:28 <nicknight> ok balac 
06:16:31 <Dougger> Would I be able to get a hand making a type an instance of FromHttpApiData: http://lpaste.net/359036
06:17:14 <Dougger> I'm not sure how to implement the definition.
06:18:25 <hpc> https://hackage.haskell.org/package/http-api-data-0.3.7.1/docs/src/Web-Internal-HttpApiData.html#line-570 - these are the pre-existing instances
06:18:59 <Dougger> I need one of the type PName from the Stache package
06:20:04 <Dougger> https://hackage.haskell.org/package/stache-1.2.1/docs/Text-Mustache-Type.html#t:PName
06:20:48 <hpc> you'll most likely want something like
06:21:12 <hpc> instance FromHttpApiData PName    where parseUrlPiece = runReader readPNameThatYouWriteYourself
06:21:34 <hpc> you can use the sources on https://hackage.haskell.org/package/text-1.2.2.2/docs/Data-Text-Lazy-Read.html to help you write that custom function
06:22:20 <Dougger> I'll look in that direction thanks.
06:24:43 <Dougger> So if I understand it correctly runReader will take the PName and return a value I specify after I write 'readPNameThatYouWriteYourself'
06:26:03 <hpc> i think it'll take a string and return the PName
06:27:48 <Dougger> I'm still figuring out the types, but I may be able to just return the PName directly, or I may need to return Text
06:28:29 <Dougger> I'm capturing a PName from the URL and passing it to a renderTemplate function. The renderTemplate function takes a PName
06:44:11 <dgpratt> I wanted to play around with this https://github.com/alanz/vscode-hie-server but "stack install" complained about not finding "happy" and referenced this issue https://github.com/commercialhaskell/stack/issues/595 -- I managed to get it working via "stack install happy", but I was wondering since I also wanted to play with the stack/nix integration if there was a way to do it in a more nix-like fashion, such as
06:44:11 <dgpratt> mentioning some package in the nix packages section of stack.yaml ?
07:17:47 <roi_du_silence> heyo.
07:18:19 <roi_du_silence> Trying out gflw-b on nixos; I don't know what to put in the nix config
07:18:20 <mdupont> my second haskell ghci bug report  https://ghc.haskell.org/trac/ghc/ticket/14334 the GHCi fails on large static objects
07:18:54 <roi_du_silence> for gloss it was  packages: [ mesa, freeglut,zlib.dev, zlib.out, pkgconfig]
07:19:12 <roi_du_silence> but stacks yells at me that I'm missing the following C libraries : 
07:19:25 <roi_du_silence>  X11, Xi, Xrandr, Xxf86vm, Xcursor, Xinerama
07:19:31 <roi_du_silence> anyone has an idea ?
07:22:36 <mdupont> stack overflow created as well https://stackoverflow.com/questions/46632135/haskell-8-03-ghci-getlabelbc-ran-out-of-labels
07:22:46 <roi_du_silence> nvm I found it. 
07:22:46 <lambdamu> roi_du_silence: try xorg
07:23:18 <roi_du_silence> yeah =)
07:25:04 <roi_du_silence> xorg.libX11, etc
07:25:13 <roi_du_silence> I'm not used to nix yet
07:25:20 <roi_du_silence> but I love it so far
07:52:50 <stephenmac7> Hey, I have an old Haskell project that has an out-of-date cabal file so it refuses to build. How would I go about updating the listed dependencies in it? It's a yesod project so it has a fair amount of dependencies, so I'm not really interested in manually updating the versions.
07:56:37 <roi_du_silence> did you try -any
07:59:40 <stephenmac7> roi_du_silence: Yeah, but it reaches the max number of backjumps
08:02:10 <ertes> stephenmac7: cabal doesn't force you to be specific about the version numbers, except for 'base'
08:03:09 <ertes> something like this will try to come up with a set of requisites preferring the newest versions of each dependency:  build-depends: base >= 4.8 && < 4.11, lucid, snap-server, â€¦
08:04:18 <snub> hi
08:04:25 <snub> i need help on IO
08:04:31 <stephenmac7> ertes: Okay, I'll try that
08:04:34 <snub> i have a function that returns a type called Move
08:04:41 <snub> I need to return IO Move
08:04:47 <snub> Move is a custom type of (Int,Int)
08:04:54 <snub> how do I do IO move on it?
08:05:02 <ertes> snub: does that function actually have IO effects?
08:05:06 <ertes> s/have/need/
08:05:20 <snub> when i call IO on it i get the error: Data constructor not in scope: IO :: Move -> IO Move
08:05:48 <user____2> hi all. I'm trying type the specification of a card game as i read the rules. The first thing is to describe a full deck as a type. http://lpaste.net/359039 . The type for a full deck seems fine but how to i properly delcare the type for a character card? (the given line is guff)
08:05:55 <ertes> snub: there is a way to IO-ify pure values, but before you do that answer my question
08:07:19 <snub> no io effects
08:07:29 <ertes> Ero: i'm not familiar with the gameâ€¦  could you give a short explanation of the kinds of cards that exist?
08:07:38 <ertes> snub: then you don't need to IO-ify it
08:07:50 <ertes> snub: you can apply pure functions to IO actions using 'fmap'
08:07:57 <ertes> snub: fmap :: (a -> b) -> IO a -> IO b
08:10:12 <ertes> snub: let's say your function is of type (move :: Foo -> Move), then (fmap move :: IO Foo -> IO Move)
08:10:31 <snub> oh
08:10:32 <user____2> Oops
08:11:04 <ertes> user____2: i'm not familiar with the gameâ€¦  could you give a short explanation of the kinds of cards that exist?
08:11:16 <user____2> yes, thx
08:12:32 <ertes> is there a way to add stuff to @where?
08:14:17 <ertes> ah, i figured it out
08:14:33 <ertes> @where+ iotut https://www.vex.net/~trebla/haskell/IO.xhtml
08:14:33 <lambdabot> It is forever etched in my memory.
08:14:45 <ertes> @where iotut
08:14:45 <lambdabot> https://www.vex.net/~trebla/haskell/IO.xhtml
08:14:55 <ertes> snub: ^ check out this tutorial
08:15:05 <Ero2> a deck is made of cards, each card contains a character. I wanted to declare a fulldeck as its own type. a fulldeck contains several copies of all the characters. I dont want to describe a CharacterCard with a type variable 'a' because i have a well defined set of types that a CharacterCard can have. thats all i wanted to express at this point. Do i need to use GADT's?
08:15:45 <ertes> Ero2: can you come up with an enumeration type for all characters?
08:15:52 <Ero2> Yes, I can
08:15:58 <ertes> data Character = Alice | Bob | Carol | â€¦
08:16:34 <ertes> Ero2: then a deck is just a collection of those cards with copies?
08:16:37 <Ero2> Although i'm not sure how to declare the type of an actual character card, whilst being able to declare a full deck as its own type
08:17:56 <Ero2> ertes: I'd like to state that a deck isnt a collection of characters, but a collection of (Character -> Card)
08:18:10 <ertes> Ero2: what is a Card?
08:18:29 <ertes> i thought cards and characters are the same thing
08:18:36 <Ero2> something that could be shuffled, drawn, held face down etc
08:18:58 <ertes> Ero2: the enumeration type Character represents all possible individual cards, correct?
08:19:04 <snub> this is my earlier code: https://github.com/8Gitbrix/gomoku/blob/master/src/Player/GigaBot.hs. When calling fmap i get a function type error
08:19:55 <Ero2> the game has alot of reasons to treat a card as a generic card, without knowing the specific character on it. I'm sure i could do it the other way but... I was interested in practising type programming  (for formal proofs?)
08:20:32 <Ero2> ertes: yes, every card in the game would be a type of character card
08:20:36 <ertes> Ero2: from what i gathered about the game, in my mind a deck is a (Seq Character)
08:20:51 <ertes> Ero2: where Seq is from Data.Sequence
08:21:15 <Ero2> maybe ive got this all wrong in my head lol
08:21:32 <Ero2> this is what i get for forgoing academia
08:21:40 <ertes> Ero2: Seq is like [], except that you can efficiently do appends and splits
08:21:56 <Ero2> i understand, thank you
08:21:57 <ertes> snub: strategy is the function in question, right?
08:22:17 <ertes> snub: ah, noâ€¦  adjMove?
08:22:50 <snub> yea 
08:23:01 <ertes> Ero2: at this point i suggest not going into formal proofs yetâ€¦  learn the basics first =)
08:23:30 <ertes> snub: adjMove :: Board -> Tile -> Int -> Move
08:23:32 <Dougger> I have a function which accepts Data.Text.Internal.Text and I need to lowercase all the characters. Hackage doesn't seem to list much in the way of such functions for this package. Do I need to convert the type first or something of that nature?
08:23:42 <ertes> that's: adjMove :: Board -> (Tile -> Int -> Move)
08:23:49 <ertes> Dougger: see 'map' from Data.Text
08:24:14 <ertes> Dougger: and 'toLower' from Data.Char
08:24:16 <snub> that function strategy has to return IO Move, i'm super close but calling IO or fmap on the output of adjMove hasnt worked.. Oh
08:24:30 <ertes> snub: adjMove :: Board -> (Tile -> Int -> Move)
08:24:38 <ertes> snub: fmap adjMove :: IO Board -> IO (Tile -> Int -> Move)
08:25:41 <ertes> snub: but all you really need in your case is 'pure'
08:25:44 <ertes> pure :: a -> IO a
08:26:19 <snub> u mean i can just call pure on the return value of adjMove
08:26:39 <ertes> snub: yes
08:26:59 <ertes> 'pure' converts any value into an IO action that returns that value without any effects
08:28:12 <snub> thank you!!!!!
08:29:43 <ertes> snub: read the tutorial anyway
08:30:17 <snub> yea i will
08:30:55 <Dougger> ertes: Good suggestion. It compiles now. Thanks
09:15:49 <csd_> why does foldl take a b->a->b instead of the a->b->a that foldr takes
09:17:52 <ertes> csd_: that's not exactly what foldr takes
09:18:09 <csd_> err a->b->b that foldr takes
09:18:12 <csd_> same question
09:18:37 <ertes> csd_: to answer your question there is no technical reasonâ€¦  you could call it an aesthetic choice
09:18:51 <ertes> foldr (+) 0 [a,b,c] = a + (b + c)
09:18:59 <ertes> foldl (+) 0 [a,b,c] = (a + b) + c
09:19:39 <ertes> if foldl's function were flipped, we would have:
09:19:46 <ertes> c + (b + (a + 0))
09:19:57 <ertes> rather than:  ((0 + a) + b) + c
09:20:30 <csd_> oh yeah that makes some sense from an aesthetic perspective
09:36:04 <csd_> ertes: so with both foldr and foldl, because traversal is done separately from folding, i'm guessing that each suffer from stack buildup, yes?
09:37:57 <fDev2179> I have a question about data types and typeclasses.  Code here: http://lpaste.net/359042
09:40:00 <fDev2179> I have a typeclass for Basis named BasisType (could come up with a better name probably).  I have defined an instance of the BasisType typeclass for a Lagrange basis.  Now, I want to use the Basis to build up a shape function as shown in the module ShapeFcns.
09:40:33 <shafox> Not able to pass the compiler: https://gist.github.com/shadow-fox/23b40ab18e8bb398c58fd4875acc8907 Can someone help me get through this ?
09:40:44 <ertes> csd_: nope, that's misleading
09:40:52 <ertes> csd_: in particular foldl' is a special case of foldr
09:41:25 <fDev2179> The shape function is dependent upon the basis used.  
09:42:18 <fDev2179> Hence, the newtype TensorProduct b = TensorProduct b.  In this case, I intended b to be a basis such as Lagrange 1.
09:42:28 <ertes> csd_: you may be interested in my "little" fold tutorial
09:42:31 <ertes> @where foldrtut
09:42:32 <lambdabot> http://ertes.eu/tutorial/foldr.html
09:42:49 <csd_> ertes: little indeed ;)
09:42:51 <fDev2179> Now, I'm trying to define the getBasis function for the TensorProduct type, but can't seem to get it working.  
09:42:58 <fDev2179> Any pointers on what I'm doing wrong?
09:46:38 <alp> fDev2179, I think your ShapeFcn instance needs a BasisType a => constraint
09:46:48 <alp> or actually... hang on
09:47:03 <alp> I think your getBasis function is a bit too ambitious
09:47:07 <ertes> fDev2179: just a wild guess: your instance (ShapeFcn (TensorProduct a)) *for all* 'a'â€¦  that's probably not your intention
09:47:47 <fDev2179> ertes, you are correct.  That is not my intention.  A should be constrained to BasisType.
09:47:51 <alp> it's basically saying, assuming 'f' = 'TensorProduct' for simplicity: for any TensorProduct, I can give you a value of anything that implements the BasisType typeclass
09:48:11 <alp> and the caller gets to chose
09:48:14 <ertes> shafox: if you paste with an extension of '.hs', we get some syntax highlighting =)
09:48:41 <ertes> shafox: and when you get a compiler error, please add that error to the paste as a comment
09:48:45 <fDev2179> I think I see what you are saying, alt.
09:48:51 <shafox> ertes, updated. 
09:48:52 <ertes> shafox: ideally at the bottom, so the line numbers match up
09:49:51 <shafox> ertes, updated with the whole file. 
09:50:02 <alp> fDev2179, do you instead want a function that says "given a 'TensorProduct a' where 'a' is some BasisType, I can hand you the corresponding 'a' ?
09:50:14 <alp> "
09:50:23 <fDev2179> Yes.  That is what I was going for, alp.
09:51:49 <alp> there are several ways to do this. 1/ class ShapeFcn f where getBasis :: f a -> a and then the instance that you wrote would work.
09:51:54 <ertes> shafox: parseMediawiki :: MonadThrow m => Consumer Event m [WikiDoc]
09:52:04 <ertes> shafox: tag' :: MonadThrow m => NameMatcher a -> AttrParser b -> (b -> ConduitM Event o m c) -> ConduitM Event o m (Maybe c)
09:52:32 <ertes> shafox: look at the result typesâ€¦  do you see the problem?
09:52:45 <alp> 2/ (enabling the MultiParamTypeClasses extension) class ShapeFcn f basis where getBasis :: f -> basis
09:52:47 <fDev2179> Agreed with 1, alp.
09:53:28 <alp> 3/ (enabling the TypeFamilies extension) class ShapeFcn f where { type Basis f :: * ; getBasis :: f -> Basis f ... }
09:54:00 <alp> 1/ is obviously the simplest, if you can afford to have all potential 'f's be of kind * -> * (that is, "parametrized by a type")
09:54:26 <shafox> ertes, so I have to adhere the type and return the same Maybe [WikiDoc]. 
09:54:51 <fDev2179> Interesting.  I agree that 1 is the simplest.  
09:55:07 <ertes> shafox: either that or handle the potential Nothing right away
09:55:33 <shafox> ertes, that's what I am failing to do so. How do I acheive that ?
09:55:52 <ertes> shafox: one option is to pattern-match on the result of 'tag'
09:56:23 <fDev2179> alp, I would like to have a typeclass constraint so that the parameter must belong to the BasisType typeclass. 
09:56:27 <ertes> parseMediawiki = do mxs <- tag â€¦; case mxs of Nothing -> â€¦; Just xs -> pure xs
09:57:15 <alp> fDev2179, well, you could have class ShapeFcn f => getBasis :: BasisType a => f a -> a
09:57:24 <alp> which is different from what you had before
09:57:43 <alp> because before it was just f -> a. so given a f, you're supposed to be able to produce any old 'a'.
09:58:00 <babu> Question regarding emacs haskell mode: When I load (C-c C-l) File.hs (which has import Mod1), I get an error "Failed to load interface Mod1", but on a shell "stack ghci File.hs" works. Do I need to update .ghci file? I thought "hs-source-dirs: src" means all files in the src directory are available.
09:58:24 <fDev2179> alp, I agree it was incomplete before.
09:58:37 <alp> whereas now it's saying (with 'BasisType a => f a -> a'): give me an 'f' with 'a's in it, and I'll give you an 'a'
09:59:04 <alp> so you already have 'a's to start with, which definitely makes it much more likely for you to be able to yield back just a single 'a'
09:59:32 <ertes> babu: haskell-mode only looks at the cabal file in cabal mode, but if it finds a cabal file, it goes to that mode automatically, so it should work
10:00:19 <ertes> babu: unless you have customised haskell-process-type
10:01:16 <ertes> babu: note that the developers of stack have created a stack-specific emacs mode called 'intero', which is supposed to "just work", as far as i know
10:02:45 <alp> fDev2179, to conclude: this new, slightly different definition, says something about the structure of 'f', regardless of the choice of 'a'. Before, your instance was 'instance ShapeFcn (TensorProduct a) where ...', now it's 'instance ShapeFcn TensorProduct where ...' so even the code shows that it's now about a fundamental property of 'TensorProduct' as a parametrized type
10:03:32 <alp> and not a property of 'TensorProduct Int' or something.
10:03:45 <fDev2179> alp: agreed.  
10:03:59 <fDev2179> I do get an error when I try what you suggested though.
10:04:22 <alp> fDev2179, can you paste what you have now?
10:04:33 <fDev2179> yeah, gimme a sec.
10:04:47 <babu> ertes: No, I have not customized haskell-process-type. I used intero for a while and went back to haskell-mode. I will try intero again and see if it works.
10:06:18 <ertes> babu: my approach is to set haskell-process-type to ghci and write a little wrapper script for nix-integration, which means that i have to parse the cabal-file myselfâ€¦  i do so in a rather hacky way, but it's just good enough to get my nix integration to work
10:07:00 <fDev2179> class ShapeFcn f => getBasis :: BasisType a => f a -> a
10:07:06 <fDev2179> instance ShapeFcn TensorProduct where 
10:07:12 <fDev2179>   getBasis TensorProduct a = a
10:07:33 <fDev2179> alp, trying to load into GHCI, I get the following: ShapeFcns.hs:14:21: error:
10:07:33 <fDev2179>     Malformed head of type or class declaration: getBasis
10:07:34 <fDev2179> Failed, modules loaded: Basis.
10:07:57 <alp> fDev2179, it should be "where" instead of "=>" between 'f' and 'getBasis'
10:08:32 <alp> and it should be getBasis (TensorProduct a) = a
10:08:40 <alp> and then you should be good to go
10:08:54 <fDev2179> It works.  Thanks so much.  
10:09:05 <fDev2179> Now time to think more about what I was doing wrong.
10:10:13 <alp> well, it's just a bit of syntax to internalise, that'll come rather quickly don't worry =)
10:10:20 <fDev2179> Thanks, alp!
10:23:55 <babu> ertes: switched back to intero, works fine. Thanks.
10:24:45 <shafox> ertes: I am not able to grasp the Maybe type how to handle the Nothing part.
10:26:56 <cloj_dev> I'm playing around with monoids (am newb), is it up to the programmer to ensure mappend returns the same value when the identity value is passed in as a parameter ? 
10:27:38 <srhb> cloj_dev: Yes, we generally don't have the kind of power to enforce rules of that specificity.
10:28:14 <cloj_dev> yeah, ok makes sense, so if my monoid's mappend doesn't obey this property, I should expect nonsense when doing more advanced stuff, I suppose
10:29:16 <monochrom> You will find that msum gives weird answers sometimes.
10:29:33 <srhb> cloj_dev: And people will scream at you, a lot, on occasion, if it doesn't :-)
10:29:48 <cloj_dev> haha, indeed
10:31:28 <ertes> shafox: then my suggestion is to go through a tutorial of haskell's basics, in particular algebraic types and pattern-matching
10:33:25 <nicknight> hi 2 months really ideal time for Haskell ? I already did 3/4 days and knoe few concepts but still I am so excited to know how long it can take me to master 
10:34:25 <srhb> nicknight: "master" ? Years, in my opinion. Though, maybe I'm just dense. :-)
10:34:26 <ertes> nicknight: to learn?  a few weeks or monthsâ€¦  to master?  a long time
10:35:13 <nicknight> srhb: ertes  I will really not need haskell to master but I am learning it to think like better programmer so in uderstand haskell then mostly into python
10:35:22 <nicknight> So to understand and write basic programms
10:35:43 <nicknight> 2 months wont be ideall ? Also if time permits to use haskell with data science
10:36:41 <cloj_dev> what programs do you want to write ? 
10:36:46 <ertes> nicknight: if you're learning haskell, why not just use haskell?  python is a particularly poor language to apply your haskell knowledge in
10:36:59 <csd_> ertes: in your tutorial, with the mApply exercise, is it solvable without using pattern matching?
10:37:03 <csd_> if so, how?
10:37:07 <ertes> nicknight: i've had the distinct displeasure to work with python for a while, and it was pure frustration
10:37:23 <nicknight> ertes:  but I already lost my present job so I would need a new job and no jobs in haskell
10:37:40 <monochrom> No. Clearly, 2 months is not ideal. Ideal is you have a USB 3.0 port on your head and you just plug in and download, takes only a few minutes.
10:38:04 <ertes> nicknight: if you know where to look and which people to talk to, you will find haskell jobsâ€¦  but i agree it's much easier to find python jobs
10:38:57 <ertes> csd_: yes, it's possibleâ€¦  try to use the derivation method i introduced
10:41:04 <nicknight> ertes:  I see no one solvs problems in job interviews in haskell, Or I will just risk I will learn haskell for 2/3 months and along with that will learn  machine learning algorithms and will try to implement them in haskell and will try if I can get any job based on that
10:41:19 <ertes> nicknight: learning haskell will have a massive impact on your python style, to the point where you might actually annoy most other python users
10:41:49 <nicknight> ertes:  to be honest I am beginner in python also and I dont liked it and felt boring so I am here 5 days back
10:42:19 <ertes> nicknight: every python module you write will start with importing asyncio, functools and itertoolsâ€¦  and you will constantly complain in #python about the poor support for sensible patterns =)
10:42:35 <csd_> ertes: you need to lift the Maybe (a->b) from the Maybe expr.. not sure how to do that
10:42:44 <ertes> csd_: no lifting required
10:42:59 <ertes> csd_: if you can't figure it out, the solution is at the bottom
10:43:02 <nicknight> ertes:  so areyou asking me not to learn haskell or python I am confused :(
10:43:31 <nicknight> I see many people do python for living and haskell for fun
10:43:33 <nicknight> I asuume
10:43:53 <ertes> nicknight: i think right now you should do whatever gets you a job =)
10:44:06 <ertes> nicknight: once you have a job, you can start learning haskell
10:45:47 <nicknight> ertes:  but I will be doing Ml on the other hand right where I will cover octave and python libraries like numpy and other deep learning libraries like keras,teano and tesorflow...I will spend 3 hours everyday for Ml and only 1hour for Haskell (assuming it makes me better programmer on the side)
10:46:30 <nicknight> I heard Machine learning really dont need programming lnaguge but ability to write own hypothesis/model
10:47:16 <ertes> yes, for ML the language hardly mattersâ€¦  it only starts to matter when you're integrating the method into an actual application
10:47:31 <Cale> If you have to worry about getting a job quickly, Haskell isn't really the way to go about it. If you're more interested in advancing your ability and don't care about applying it immediately, then Haskell might actually be a better vehicle for that than many other choices.
10:47:34 <csd_> ertes: the solution seems to me like it requires more experience in haskell than i have..
10:48:04 <ertes> nicknight: although i have a genetic learning framework that strongly benefits from being in haskell, because it uses an applicative interface
10:48:12 <monochrom> ertes: May I see your derivation too? :)
10:48:49 <nicknight> ertes:  what is that genetic framework ?
10:48:56 <ertes> csd_: if that's the case, i have to revisit that exerciseâ€¦  in that case, i'm sorryâ€¦  just ignore it and continue with the rest =)
10:49:17 <ertes> monochrom: which one?  i have a few thousand derivations in my store
10:49:19 <ertes> SCNR =P
10:49:25 <ertes> monochrom: but what do you mean?
10:49:30 <monochrom> The one you showed csd_
10:49:38 <csd_> ertes: not sure what level you're gearing that tut towards but intuitively knowing to refactor `f x` to f $ x` is non obvious for a newbie
10:49:40 <nicknight> Cale: to be honest now I am serving notice period so no prob for 3 months and then I can stay without a job for a month or more so I would Ideally get 5months and wanted to shoot haskell along with ML
10:53:14 <ertes> csd_: it's not a total newbie tutorialâ€¦  it assumes that you know basic haskell, but you're struggling with foldr
10:53:37 <ertes> monochrom: mApply defY Nothing x = _n
10:53:57 <ertes> monochrom: the only option here is (_n = defY)
10:54:13 <ertes> monochrom: mApply defY (Just f) x = _j f
10:54:25 <ertes> here you have multiple options, but only one agrees with the test cases
10:54:42 <ertes> _j f = f, i.e. _j = id
10:55:08 <ertes> err
10:55:26 <ertes> _j f = f x, i.e. _j = ($ x)
10:56:19 <ertes> csd_: note that a solution like (_j = \f -> f x) is totally fine
10:56:29 <monochrom> I wonder what GHC suggest for that hole.
10:57:14 <ertes> csd_: you don't really need to know how to refactor applications of ($) here, but you do need to know how to look at context: "what's the type of my goal?  and what values of what types are visible from here?"
10:57:40 <ertes> csd_: in fact GHC can help you there
10:58:04 <ertes> csd_: you can literally give this code to GHC:  mApply defY mf x = maybe _n _j mf
10:58:20 <ertes> csd_: it will tell you the types of _n and _j along with the types of things that are in scope
10:58:33 <ertes> you can then update the code iteratively
10:58:43 <ertes> mApply defY mf x = maybe _n _j mf
10:58:47 <csd_> i see.. thanks
10:58:50 <ertes> mApply defY mf x = maybe defY _j mf
10:58:56 <ertes> mApply defY mf x = maybe defY (\f -> _) mf
10:58:56 <csd_> will work through the rest of the tut after i see the new blade runner :)
10:59:01 <ertes> mApply defY mf x = maybe defY (\f -> f _) mf
10:59:05 <ertes> mApply defY mf x = maybe defY (\f -> f x) mf
10:59:21 <csd_> thats a clever method
11:01:04 <ertes> rapid type-protoing =)
11:08:07 <nicknight> Cale: ertes  just last question out of small fear...considering 5 months you won't suggest me to proceed with Haskell  to become okay level programmer who can solve basic algorithms problems in job interviews If I seriously study everyday ?
11:09:35 <ertes> nicknight: the thing is that you said that you're a beginner in both python and haskell, and that you're trying to find a python job
11:09:53 <ertes> nicknight: i absolutely recommend that you learn haskell, but now might not be the best time
11:10:07 <nicknight> ertes:  I am mostly wanted ML job where python is widely used
11:10:50 <ertes> nicknight: are you a beginning programmer in general?
11:11:40 <ertes> nicknight: oh, i forgot about your question:  my genetic framework constructs genetic algorithms from "blueprints"
11:11:53 <nicknight> ertes:  I can code in python say I can carse xml/json and write small small programs now in haskell I know till lists/tuples
11:12:19 <maerwald> if you are going for jobs, forget haskell
11:12:22 <nicknight> I know a bit of js/go also but not efficient
11:12:38 <nicknight> maerwald: I want ML job not any language job
11:12:41 <ertes> nicknight: focus on a language that will get you a job
11:12:49 <maerwald> haskell is the thing people write in job descriptions but don't actually want you to do
11:12:56 <nicknight> but at the same time I want to become better programmer for my self satisfacyion
11:13:05 <nicknight> ertes:  ok Thank you
11:13:06 <monochrom> Learning ML to get an ML job  <--- Greatest tautology ever!
11:13:16 <ertes> nicknight: you can always come back to haskell once your livelihood is secure
11:13:28 <ertes> heh
11:13:44 <maerwald> nicknight: haskell is not ML
11:13:49 <nicknight> Okay 
11:13:52 <Cale> nicknight: I wouldn't recommend optimising for job interview questions either. You probably don't want an employer who puts much stock in those if you can avoid it. Work on building a little portfolio of code that you can show someone to give them an idea of what your code looks like and convince them you can do useful work.
11:13:54 <nicknight> maerwald:  I know 
11:13:56 <ertes> maerwald: ML = Machine Learning
11:14:01 <ertes> not the language
11:14:04 <maerwald> ah
11:14:31 <maerwald> don't know whether haskell is popular in ML, I'd rather suspect weirdly optimized C++ stuff there
11:14:38 <monochrom> "haskell is not ML" is still true :)
11:14:47 <ertes> maerwald: python is very popular for ML these days
11:15:11 <ertes> there is also a lot of lisp going on, but i think that's slowly dying
11:15:34 <monochrom> Yeah, probably weirdly optimized C++ code that you never touch but instead you just FFI-call it from Python glue code.
11:15:49 <maerwald> yep, even weirder
11:16:00 <ertes> C/C++ along with shaders for actual computation
11:16:13 <ertes> a lot of ML is done on the GPU these days
11:16:54 <ertes> (given that you could probably get very far without writing a single line of natively-compiled code)
11:18:22 <ogkloo> why is the GPU so popular for ML stuff? Isn't it because of floating point calculations or something?
11:18:36 <ertes> ogkloo: parallelism
11:18:43 <ogkloo> ah
11:18:53 <monochrom> @tell erisco Could you write a PHP binding for the tensorflow library, so that Wordpress users can finally do some machine learning in their blogs?  (Just kidding!)
11:18:53 <lambdabot> Consider it noted.
11:19:06 <cerebral_monkey> Is there some place that I can find how elemIndex is actually implemented?
11:19:16 <nicknight> ok Thanks Cale,  ertes  maerwald ...WHy I ponting and asking is I can spend time for both what I wanted and haskell also,,,but according to ertes  he said if i learn haskell I will be frustrated with python so I am woried to learn both at a same time...and I cant risk myself 2/3month....on the other hand I also herad we can learn haskell first it is easy but very hard if we come from imperative languages
11:19:18 <nicknight> ...so asking till now I guess I have my answer thanks a lot
11:20:19 <Eduard_Munteanu> cerebral_monkey, http://hackage.haskell.org/package/base-4.10.0.0/docs/src/Data.OldList.html#elemIndex
11:20:21 <maerwald> that's a myth
11:20:30 <maerwald> haskell is always harder to learn than e.g. python
11:20:41 <cerebral_monkey> Eduard_Munteanu: Awesome! Thank you.
11:21:05 <Eduard_Munteanu> cerebral_monkey, or start at http://hackage.haskell.org/package/base-4.10.0.0/docs/Data-List.html#v:elemIndex and click the Source link at the right.
11:21:19 <ertes> cerebral_monkey: visit the hackage page of 'base', visit the module documentation and click 'Source' at the item you're interested in
11:21:30 <cerebral_monkey> I appreciate it! I'll definitely be consulting this resource often
11:21:58 <kirillow> in rust what do you use to build a terminal interface if your needs are really simple and performance is most important?
11:22:03 <kirillow> oops
11:22:05 <kirillow> sorry
11:22:30 <ertes> nicknight: well, if you have some control over your feelings, you can still *use* python, even with haskell experience =)
11:23:05 <monochrom> erisco learned Haskell and is still fine working in PHP.
11:23:18 <monochrom> If that can be achieved, nothing can't be achieved.
11:23:28 <ertes> nicknight: however, it will strongly impact on your style, as i said earlierâ€¦  you will find yourself using generators and coroutines a lot, for example
11:23:41 <ertes> nicknight: and you will abstract over functions a lot
11:24:03 <ertes> nicknight: also you will avoid OOP a lot
11:24:29 <kuribas> unfortunatly my team has decided on a very OOP style.
11:24:40 <kuribas> They love it...
11:25:06 <maerwald> kirillow: there is Cursive, ncurses-rs and pancurses
11:25:37 <maerwald> kuribas: I am going for go. I mean, polymorphism? lol. Interfaces suck. But hey, no OOP!
11:26:11 <kuribas> maerwald: perhaps I'd be better of in a C# or scala job...
11:26:50 <ertes> kuribas: i think that's a common progressionâ€¦  i used to love OOP, until i hit the abstraction boundary, at which point the spiral began: using ever crazier and more verbose design patterns, hitting the boundary again, repeat
11:27:16 <kuribas> ertes: I liked OO 10 years ago.
11:27:22 <ertes> yeah, same here
11:27:28 <kuribas> ertes: yeah, that's how our code looks.
11:27:35 <nicknight> ertes: may be I am noob or what I dont know a year back I had to work on Java (spring framework) I dont like oop, I like functions in python than classes
11:27:38 <kuribas> And it even kinda works!
11:27:42 <monochrom> https://twitter.com/mosheroperandi/status/856946180810354688 is how you regain polymorphism in Go. :)
11:28:03 <ertes> kuribas: at some point i found myself hacking through the abstraction boundary, and telling myself: "it will be fine"
11:28:10 <ertes> it wouldn't be fine
11:29:10 <ertes> hahahaha
11:29:27 <kuribas> well they had code that took 45 minutes just to create a report.  It had a mess of observers, and 100ds of queries to the database.
11:30:07 <kuribas> I'd think that generating a report for 3000 accounts would take not more than a few seconds.
11:30:13 <monochrom> Oh report generation was also what got edwardk into Haskell.
11:30:22 <edwardk> ?
11:30:42 <edwardk> i worked on reporting stuff in ermine, but i found haskell because of perl
11:31:26 <monochrom> Speaking of which, everyone is learning machine learning now because they think there are a lot of job openings in maching learning. It's a hot topic now.
11:31:30 <edwardk> i blame my finding of haskell on audrey tang
11:31:47 <kuribas> monochrom: there aren't?
11:31:49 <edwardk> monochrom: yeah, its nice that the world discovered automatic differentiation, but i feel it is a bit much =)
11:32:16 <monochrom> But it seems there is this dark market (as in dark matter) of report generation that's even bigger than machine learning or whatever the hot topic of the day is.
11:32:42 <kuribas> isn't it solved with sql?
11:33:07 <srhb> kuribas: The new goodness in project m36!
11:33:13 <monochrom> Well yeah but somehow they still have to hire people to write code.
11:33:25 <srhb> sql is so last century.
11:34:16 <kuribas> I actually think the relational DB model is great.
11:34:32 <Eduard_Munteanu> It is, SQL on the other hand...
11:35:17 <kuribas> is there an alternative?
11:35:21 <monochrom> I mean in the same sense restaurant serving is also a solved problem but the trick is to hire people to actually do it.
11:35:34 <nicknight> monochrom:  I am learning machine learning because I like it and I like applying maths to real life  and true many job posting on Ml/DL
11:36:26 <monochrom> Anyway it seems like a lot of big shots are big shots today because they once went through report generation in the past.
11:36:35 <hpc> https://blog.jooq.org/ - this is a surprisingly good source for learning a lot about sql
11:36:39 <Eduard_Munteanu> kuribas, not really, no. But if I were to design one, I'd probably go with submitting some portable bytecode to the DB for processing.
11:36:40 <monochrom> I mean even Perl began from report generation.
11:37:03 <hpc> i have to agree about liking sql and relational models, they work really well as a declarative language
11:37:16 <Eduard_Munteanu> And make it less obnoxious to store blobs in the DB.
11:37:21 <hpc> and abstract to the point where you can do some very sophisticated optimizations
11:37:25 <monochrom> Report generation: The much ignored pervasive dominant dark matter of the programming universe.
11:38:40 <Eduard_Munteanu> Assuming you even want to have a separate DB in the first place and not simply run a query in-process.
11:39:09 * Eduard_Munteanu thinks IxSet is kinda great
11:40:00 <srhb> Eduard_Munteanu: The haskell interface to project:m36 is pretty cool
11:40:15 <Eduard_Munteanu> I'll have to look that up, hm.
11:40:16 <ertes> so that's how it startedâ€¦  audrey tang is the reason i'm hooked on Codensity, FreeT and lensâ€¦
11:40:38 <srhb> Eduard_Munteanu: One helluva alternative to sql :)
11:41:56 <ertes> i can no longer write a build-depends without any edwardk librariesâ€¦  like a junkie eating from the generous hands of his loving, caring dealerâ€¦  thanks for that, audrey!
11:43:04 <edwardk> hahahah
11:44:09 <ertes> OH, AND DID I FORGET MACHINES?!
11:44:25 <ertes> how'd that happenâ€¦  i stopped using pipesâ€¦
12:15:20 <tippenein> hmmm, stack gave me addWatch: resource exhausted (No space left on device)
12:15:37 <tippenein> Do I have to manually kill some inotify watches?
12:16:24 <hpc> did you run out of disk space or inodes maybe?
12:59:56 <k0ral> Hello
13:00:08 <xormor> k0ral, hello
13:01:10 <k0ral> I need to build and maintain a spanning tree (not necessarily a minimal one) within a dynamic graph where edges can disappear only
13:01:37 <k0ral> where would you suggest I start in terms of libraries/algorithms ?
13:02:27 <k0ral> are there idiomatic tools in haskell to handle this kind of problems ?
13:24:43 <Ero2> hey team
13:25:23 <Ero2> Is there a way to declare a data type with no constructors? Is this what is called a nullary type? (my vocab is poor)
13:26:47 <hpc> you need the EmptyDataDecls extension
13:26:48 <Ero2> i think what i mean is: how do i declare a type constructor with no data constructors?
13:26:49 <hpc> and then you can do 
13:26:51 <hpc> data Void
13:26:52 <geekosaur> 'data Foo' works fine. it's even part of the haskell 2010 standard
13:27:03 <Ero2> oh
13:27:03 <hpc> oh, i suppose you can do that by default now
13:27:13 <Ero2> You know i didnt even bother to try i just assumed it wouldn't work
13:27:14 <geekosaur> but it won't work in something like hugs which hasn't had a release since 2007 or thenabouts and only implements haskell98
13:27:37 <Ero2> My gratitude, as always geekosaur 
13:30:26 <Ero2> I have a type constructor which can only possibly have one data representation, but still it is a lengthy type. Is there a way that haskell can derive the singular representation? I'll provide an Lpaste
13:30:48 <Ero2> i may be wrong about there only being one implentation, but that is what i am gunning for
13:31:40 <Ero2> http://lpaste.net/359056
13:32:14 <hexagoxel> are "#include" statements in .chs evaluated by c2hs or does some preprocessor expand them first?
13:34:32 <Ero2> i pester this channel so much lately lol. I hope there is a way i can maintain good faith with its users. My progress with haskell has rapidly increased since i decided to be cheeky and ask questions here instead of spending hours searching the net
13:34:51 <hexagoxel> Ero2: can you.. -XDataKind itself? :D probably not..
13:35:35 <Ero2> i'm going to look up what -XDataKind does and then find out
13:36:06 <hexagoxel> Type constructor â€˜Fooâ€™ cannot be used here (it is defined and used in the same recursive group)
13:36:10 <hexagoxel> meh :(
13:36:56 <Ero2> i guess thatmeans i shouldn't bother lol
13:36:58 <Ero2> thanks anyway
13:38:14 <ertes> hpc: EmptyDataDecls is standard since h2010
13:44:21 <xormor> what should I program in Haskell?
13:48:11 <Ero2> xormor: why do you use haskell?
13:48:45 <xormor> Ero2, lazy-typing, mathematics-like syntax.
13:49:11 <xormor> Ero2, I already know how to program some BASIC, x86_64 asm, C and C++.
13:49:26 <Ero2> and what, xormor, caused you to decide that those features were beneficial?
13:49:33 <hpc> xormor: whatever you're about to program next :P
13:49:56 <Ero2> hpc's answer is 'well defined' but mine is more fun
13:49:59 <Ero2> listen to me! :D
13:50:02 <xormor> Ero2, C/C++ requires me to declare types to my variables and constants. Haskell does not. Haskell is like an advanced functional calculator to me.
13:50:28 <Ero2> what sort of things did you program in c and c++, xormor ?
13:50:29 <xormor> hpc, maybe tic-tac-toe
13:50:49 <xormor> Ero2, mathematics, mostly, simple Junior High School and High School mathematics.
13:51:01 <xormor> Ero2, and the omega-rpg game, Debian version.
13:51:18 <Ero2> you made that game?!
13:52:07 <xormor> Ero2, no. I fixed a bug in it and partially translated game messages to Finnish from English.
13:52:16 <Ero2> thats so cool
13:52:37 <Ero2> are you more interested in using haskell for maths or for games.. or for both?
13:52:51 <xormor> Ero2, the bug is that dataprint() is not called at the time the player goes for a heal in the Order of Paladins guild building.
13:53:00 <xormor> Ero2, more for maths.
13:54:14 <Ero2> xormor: you may have fun solving some project euler questions, in that case. I did a few a week ago and i found it to be pretty fun. You can always jump a bunch of questions to get to some that would be a nightmare to solve in c, but can be done fluently in haskell
13:54:20 <xormor> Ero2, https://pastebin.com/Yg9fW88f
13:56:44 <Ero2> xormor: challenge accepted
13:58:06 <hpc> project euler will probably vary widely in difficulty
13:58:22 <xormor> Ero2, https://pastebin.com/rQ9E7R81
13:58:29 <erisco> Question 1) How do you pronounce "Euler"?
13:58:30 <hpc> some problems are mainly optimization problems, some do demand heavier math than a typical programmer will know
13:58:37 <hpc> haha
13:58:53 <xormor> erisco, you-ler
13:59:07 <duncan^> xormor: Ugh, NO!
13:59:12 <xormor> oiler?
13:59:47 <duncan^> it is a German name
14:00:28 <erisco> I think it is read right to left, so re-loo
14:02:50 <hpc> "ooler", obviously :P
14:03:58 <Tuplanolla> One of my unused project names is Yooler.
14:04:26 <Tuplanolla> One day I will find a match for it.
14:04:55 <erisco> I want to name something "Oiler" and get angry when people don't pronounce it "Yewler"
14:05:26 <Ero2> xormor: challenge unaccepted
14:05:30 <Ero2> I can do that, right?
14:05:36 <hpc> Tuplanolla: i hope you also have "lebnits" on that list :P
14:06:34 <Tuplanolla> Maybe it could even be Prophet Yooler, right alongside Cautshi Serious, hpc.
14:06:45 <erisco> how about "Peano"
14:07:42 <hpc> Tuplanolla: DJ Scratchers?
14:10:48 <Ero2> how come i can't find a 'readInt/readNum' or something on hoogle with the type 'Num a => [Char] -> Maybe a
14:11:16 <erisco> Ero2, maybe you want read
14:11:25 <erisco> :t read :: String -> Int
14:11:26 <lambdabot> String -> Int
14:11:37 * Ero2 head explodes
14:11:46 <c_wraith> :t readMaybe
14:11:48 <lambdabot> error: Variable not in scope: readMaybe
14:11:54 <c_wraith> does that exist somewhere?
14:12:05 <erisco> yes, there is a more sophisticated reading API in base
14:12:06 <Ero2> read :: String -> Maybe a
14:12:13 <Ero2> :t read :: String -> Maybe a
14:12:14 <lambdabot> error:
14:12:14 <lambdabot>     â€¢ No instance for (Read a1) arising from a use of â€˜readâ€™
14:12:14 <lambdabot>       Possible fix:
14:12:17 <erisco> though off the top of my head I do not recall what it is
14:12:28 <hexagoxel> :t Text.Read.readMaybe
14:12:29 <lambdabot> Read a => String -> Maybe a
14:12:46 <Ero2> haha
14:12:51 <Ero2> haskell is awesome
14:13:24 <hpc> > Text.Read.readMaybe "True" :: Maybe Boolean
14:13:26 <lambdabot>  error:
14:13:26 <lambdabot>      Not in scope: â€˜Text.Read.readMaybeâ€™
14:13:26 <lambdabot>      No module named â€˜Text.Readâ€™ is imported.error:
14:13:34 <hpc> @let import Text.Read
14:13:36 <lambdabot>  Defined.
14:13:36 <erisco> readMaybe is in Text.Read which is in base since 4.6.0.0
14:13:39 <hpc> > Text.Read.readMaybe "True" :: Maybe Boolean
14:13:42 <lambdabot>  error:
14:13:42 <lambdabot>      Not in scope: type constructor or class â€˜Booleanâ€™
14:13:59 <hpc> it's been a long day :/
14:14:12 <hpc> > Text.Read.readMaybe "True" :: Maybe Bool
14:14:14 <lambdabot>  Just True
14:14:17 <hpc> > Text.Read.readMaybe "ooger booger" :: Maybe Bool
14:14:20 <lambdabot>  Nothing
14:14:56 <pierrot> Hi. Is there a way to hide everything from a module except one specific function with the import statement? I mean, import only that function.
14:15:16 <erisco> > reads "True" :: [(Bool, String)]
14:15:19 <lambdabot>  [(True,"")]
14:15:43 <erisco> the more sophisticated API is the one which uses ReadS
14:15:46 <lyxia> pierrot: import Module (function)
14:15:50 <erisco> > reads "True ooger booger" :: [(Bool, String)]
14:15:53 <lambdabot>  [(True," ooger booger")]
14:16:02 <hpc> yeah
14:16:45 <pierrot> lyxia: oh, that simple. Thanks
14:38:10 <erisco> today I get to figure out why ghc is on my path and cabal is not
14:38:25 <monochrom> Yay, why?
15:06:40 <Ero2> xormor: http://lpaste.net/359060
15:06:59 <Ero2> xormor, screw that other thing though. I'm not touching it in haskell lol
15:08:06 <Ero2> xormor, program will die if it gets strings that aren't valid integers though. Otherwise it follows your original programs interface pretty close
15:10:42 <Ero2> wow Lpaste gives syntax recommendations... Thats embaressing ~
15:15:03 <c_wraith> Ero2: those are from the tool hlint
15:15:09 <c_wraith> Ero2: you can run it yourself, if you like. :)
15:16:12 <Ero2> c_wraith, someday soon I will be brave enough to get a better editor than gedit lol
15:16:37 <c_wraith> hlint is a standalone tool.  Don't need to run it from your editor. :)
15:18:43 <Ero2> my phobia extends to changing my toolchain lol
15:19:06 <Ero2> though, its the next step in my haskell journey i think
15:23:35 <fizbin> Can someone tell me whether https://github.com/jaspervdj/acme-cofunctor is a joke? I figure that one of three things is true: itâ€™s a joke; the author is missing something; or Iâ€™m missing something.
15:23:51 <hpc> it's a joke
15:23:53 <hpc> cofunctor = functor
15:23:57 <c_wraith> all packages that start with acme are jokes
15:24:14 <c_wraith> https://hackage.haskell.org/package/acme-dont-1.1/docs/Acme-Dont.html
15:24:28 <hpc> i like acme-schoenfinkel
15:24:56 <Ero2> hpc: sounds tastier than acme-curry
15:25:09 <hexagoxel> `don't` is actually useful if you want to disable something temporarily without running into unused-bindings
15:25:53 <hexagoxel> not that i'd add a dependency for one line.
15:28:13 <hpc> acme-now is useful for debugging too
15:28:41 <hpc> enough that i actually would add the dependency if my problems were difficult enough
15:29:38 <k0ral> what does acme stand for ?
15:31:10 <int-e> "ACME is a fictional corporation that features prominently in the Road Runner/Wile E. Coyote cartoons as a running gag featuring outlandish products that Wile E. misuses in complicated contraptions fail catastrophically."
15:33:10 <hpc> http://www.etymonline.com/index.php?term=acme
15:33:45 <k0ral> you just got my bed-time postponed by a fair hour
15:33:46 <hpc> there's a similar etymology for "nimrod", which had its meaning distorted in a similar way by elmer fudd
15:34:01 <hpc> :D
15:34:37 <hpc> there's a bit where bugs calls elmer "nimrod" sarcastically, but nimrod is actually the greek god of the hunt
15:35:56 <hpc> chuck jones was big on historical references in his cartoons
15:38:38 <k0ral> how have I been ignoring that over the past years ?
15:38:45 <isaac__> hpc: Artemis is the greek god of the hunt, Nimrod is an abrahamic figure
15:39:37 <isaac__> Or goddess, I should say
15:40:59 <hpc> ah, that's what it was
15:56:28 <jle`> hpc: is acme-now useful for debugging?
15:58:04 <hpc> jle`: put it in Debug.Trace output to know when your pure debugging happens
15:59:28 <jle`> does that work if you have more than one usage?
15:59:51 <jle`> or is it mostly for single traces
16:07:52 <nicknight> hi whats up all ?
16:11:58 <hpc> jle`: iirc it gets re-evaluated every time
16:12:48 <jle`> ah so it's like always-inlined?
16:13:53 <nicknight> its is very hard for me in linux to open two terminals one to write haskell code and another to run it through ghci is there any other easy way ?
16:15:10 <jle`> nicknight: sometimes your eidtor might integrate ghci
16:15:24 <jle`> but for me personally i use a terminal multiplexer like tmux/screen
16:15:37 <jle`> one pane is vim and the other is a ghci session
16:15:53 <nicknight> jle`:  I am using vim  
16:16:00 <nicknight> ok tmux good idea
16:16:05 <nicknight> thanks
16:16:17 <jle`> yeah so you can switch back and forth with a key combination
16:16:26 <jle`> but i'm really forced into this because i do all my development over SSH
16:16:34 <jle`> if you are acually on a linux desktop there might be better GUI options
16:17:09 <nicknight> jle`:  any way i will get this habbit because my machine very old and soon or later I will use vps to work
16:32:18 <johnw> jle`: have you ever tried mosh?
16:32:54 <jle`> i think i installed it but i haven't actually tried it myself
16:33:11 <jle`> ssh has never gotten sufficiently annoying
16:34:55 <johnw> the perception of interactivity when doing things at the shell is a bit better
16:35:21 <johnw> but the security story isn't as well established
16:36:14 <jle`> yes i do have moments with ssh sometimes with bad connections at coffee shops.  maybe i'll give it a try next time, thanks for reminding me
16:46:58 <johnw> one cool feature it has is that it's over UDP, so you can actually be doing work at the coffee shop, close your laptop, drive home, open the laptop, and it's seamless -- as if you'd never gone away
16:47:54 <jle`> you mean it won't be like ssh where sometimes i accidentally type in my ssh private key password and it types it onto my irc client without me knowing it?
16:48:15 <jle`> not that i've ever done that of course
16:48:23 <jle`> nope not ever
16:48:54 <monochrom> Oh wow there is such a thing!
16:48:54 <geekosaur> you make a lousy cat :p
16:49:50 <monochrom> So it probably needs to do its own sequencing.
16:56:23 <felixschl> hey all
17:02:28 <Ero2> johnw: if its over UDP isn't there concerns about missing packets?
17:02:44 <johnw> as monochrom said, it must do its own sequencing
17:03:38 <monochrom> See https://mosh.org/#techinfo . It's very interesting. Doing its own sequencing is the most boring bit. :)
17:05:35 <johnw> neat, the skipping intermediate frames part sounds very smart
17:06:23 <monochrom> Yeah it completely forsakes the "there are two streams" model and suddenly the design space is widely open.
17:10:13 <mbeidler> Does anyone know the rationale behind specifying specific package versions in a root stack.yaml?
17:11:56 <mbeidler> I thought the main idea behind stack was that you can specify a specific snapshot rather than deal with the headaches associated with package bounds.
17:15:12 <blackdog> mbeidler: you do, mostly
17:15:32 <blackdog> the point is that sometimes you want mostly a particular resolver but with a few exceptions, or packages that aren't on hackage or whatever
17:21:08 <mbeidler> Yeah, that makes sense. The particular package I'm referring to is `servant-auth` where it seems that most of the dependencies specify specific versions.
17:25:48 <Ero2> I have a GADT, and i want to make it an instance of a typeclass. How do i handle the error the compiler gives me?
17:26:15 <c_wraith> that would depend on the error :)
17:26:26 <Ero2> herewegoagain.wav
17:26:30 <c_wraith> GADTs can be instances of type classes, so long as everything type checks.
17:26:36 <c_wraith> There's no fundamental problem.
17:26:46 <erisco> down the only road I've ever knownâ€¦
17:27:44 <c_wraith> However, there certainly are ways for a GADT to not be able to correctly type-check a particular class, no matter what you do.
17:28:15 <c_wraith> So...  Can you put together a paste with the type, the class/instance, and the error?
17:28:34 <c_wraith> (If it's a standard class, you can skip that part)
17:29:15 <Ero2> someone please explain to me if im barking up the wrong skyscraper *bows* http://lpaste.net/359061
17:29:59 <Ero2> i may be mistreating the idea of GADT's to be honest
17:30:23 <erisco> the instance says it works for  Character a  which means it works for all 'a'
17:30:33 <c_wraith> Yeah, you can't create an Enum instance for that type.
17:30:38 <geekosaur> yes. sadly those all have to produce the same type, and *you* don;t get to specify which
17:30:39 <erisco> you cannot, then, choose 'a' to be anything particular such as Duke or Assassin
17:30:40 <geekosaur> the caller does
17:30:52 <blackdog> mbeidler: servant-auth broke horribly recently i think - or at least,  i remember having to specify a bunch of stuff to get it to work.
17:31:08 <Ero2> i suddenly feel a great inertia right behind my navel
17:32:23 <Ero2> well at least now i dont have to figure out how to get a fold to work with FullDeck as the starting value
17:32:27 <erisco> are you a Carebear?
17:32:45 <Ero2> in a manner of speaking...
17:33:08 <Ero2> i find myself sexier than a Carebear, though
17:35:34 <Ero2> erisco: geekosaur c_wraith I assume then if i wanted to create type class instances for my type, i would have to use type families, rather than GADTs?
17:35:56 <c_wraith> You'd still have the same problem.
17:36:07 <Ero2> what? damn
17:36:19 <mbeidler> blackdog: Yeah, I'm bumping servant-auth up to jose 6 at the moment.
17:36:27 <c_wraith> Which is that toEnum requires that the caller chooses the return type.
17:36:33 <erisco> I think you should just remove the type parameter from Character, based on what I am seeing
17:36:43 <c_wraith> Basically, to do what you want, you would need a dependently-typed version of the Enum class.
17:36:48 <c_wraith> Which is, well, unlikely
17:37:26 <blackdog> mbeidler: check the PRs on servant-auth - from memory, someone's done it and it just hasn't been merged yet
17:37:32 <erisco> heterogeneous enumerations
17:37:55 <mbeidler> blackdog: I checked the PRs but didn't see it. Maybe I missed it...
17:38:20 <erisco> if you can enumerate the types, and the values of those types, then I wager such a thing could be defined
17:39:36 <mbeidler> Yeah, checked again, no one's updated the jose stuff that I can see.
17:40:24 <Ero2> right, the amount of over-my-head has just breached the reach of my pogo stick. Goodnight All
17:41:20 <Ero2> oh, also, is anyone from this channel going to the freenode conference in bristol this month? I'm volunteering there at the FSF booth and wanted to hang out with some people :)
17:41:33 <blackdog> mbeidler: i think it was this: https://github.com/rikvdkleij/servant-auth/commit/2b97bf0aa85dca7db05ed2b5c21795e8bff592e3
17:41:40 <blackdog> might not be an actual PR though
17:45:27 <mbeidler> blackdog: Yeah, that fixes some of the issues by relaxing the package bounds, but it's still not using the latest Jose version (6) which has breaking changes from 5.
17:45:55 <mbeidler> That requires more extensive changes.
17:52:36 <mate_amargo> Hi!
17:53:45 <mate_amargo> I'm on archlinux, I was trying to compile somethin that uses "System.Random" but ghc says it can't find the module. I can use the module with ":m ..." on ghci btw
17:54:51 <blackdog> mbeidler: ah, fair enough.
17:55:39 <mate_amargo> ghc-pkg recache didn't help
17:59:30 <byorgey> mate_amargo: how are you compiling it?  By calling ghc directly on the command line, using cabal, using stack, ... ?
17:59:56 <mate_amargo> byorgey: By calling ghc directly on the command line
18:01:39 <byorgey> mate_amargo: can you paste the output of ghc (including the command line you are using to call it) on lpaste.net ?
18:02:13 <erisco> soâ€¦ if I want strict bytestrings and not lazy bytestrings, because why do I want lazy IO, I can't use Data.Binary?
18:02:35 <Axman6> I thought it supported both
18:02:37 <Axman6> these days
18:03:15 <erisco> it doesn't talk about strict anywhere I can find
18:06:50 <jle`> you can use Data.Binary, but i think you'd have to toStrict it
18:07:21 <c_wraith> lazy bytestrings are still a reasonable way to build a strict bytestring from multiple parts of various sizes without precomputing the size first
18:07:34 <c_wraith> (as opposed to precomputing it later?)
18:07:53 <erisco> retroactive soothsaying
18:08:10 <jle`> lazy io might be an orthogonal issue altogether
18:08:53 <erisco> I know the size
18:12:02 <Axman6> erisco: you can always use execPut and run the Builder with a known buffer size
18:12:29 <erisco> I think I have to craft my own Binary instance
18:14:06 <nicknight> http://lpaste.net/1825025500645425152   what is wrong in this?
18:14:06 <erisco> bleh, this is just painful
18:14:26 <Axman6> hmm, I swear there was a way to specify the size of the chunks in Builders
18:14:49 <Axman6> nicknight: it's one very long line
18:15:01 <erisco> maybe attoparsec can do this
18:15:40 <nicknight> Axman6:  I am wring fizzbuzz using list comprehension
18:15:49 <nicknight> in a single line
18:15:58 <Axman6> nicknight: if you want help with code, then you need to tell us what problem you're having
18:16:23 <nicknight> pasting error
18:16:25 <nicknight> one min
18:16:41 <Axman6> there's lots of things wrong with it, it uses snake_case, it's not C++, it's not a poem, it's not written in assembly. "wrong" has many different meanings
18:16:55 <nicknight> http://lpaste.net/1825025500645425152
18:17:08 <nicknight> Axman6:  telling to me?
18:17:15 <monochrom> I don't think we should pick on snake_case.
18:17:17 <Axman6> nicknight: well, start off by writing out the type of the function
18:17:25 <blackdog> Axman6: it's not in C++? wash your mouth out :)
18:17:32 <nicknight> monochrom:  what is snake_case?
18:17:52 <monochrom> but the part about '... then "buzz" else x' is not going to float because x is not a string.
18:17:54 <Axman6> blackdog: well, if the problem was "Write fizzbuzz in C++" it would clearly be wrong =)
18:18:11 * Axman6 feels people have missed his point
18:18:23 <blackdog> Axman6: no, i'm just having fun :)
18:18:45 <Axman6> nicknight: what do you think the type of fiz_buzz should be?
18:18:48 <Axman6> zz*
18:18:57 <nicknight> 1,2,fizz,....
18:18:58 <blackdog> but yeah - nicknight, think about the types going in and coming out, and then the mistake will become clear.
18:18:59 <nicknight> like that 
18:19:06 <monochrom> OK! I don't think we should pick on assembly either! There! :)
18:19:07 <blackdog> so what type does 1 have?
18:19:34 <nicknight> blackdog:  I am begiiner and finished learyouhaskell till tuples only I am practising so far what I have learnt
18:19:40 <nicknight> Didnt touched types yet
18:20:05 <Axman6> that would surprise me a lot, since they're fundamental to making working programs
18:20:18 <monochrom> IIRC LYAH covers types pretty early.
18:20:21 <nicknight> I learned list cpmprehensions and so trying this whichI thought will work
18:20:37 <nicknight> monochrom:  I finished only first chapter
18:20:42 <nicknight> type chapter 2
18:20:44 <monochrom> Or at least mentions that there is such a thing as type.
18:21:04 <monochrom> And that if you have incompatible types you're toasted.
18:22:15 <nicknight> ok time to go to idiotic office will check evening bye all
18:34:08 <mate_amargo> byorgey: Thanks. I solved it by adding the Arch Haskell Repo and doing a reinstall of ghc
18:52:50 <jchia> How can I easily get the 8-element IEEE-754 ByteString representing a Double? I probably can use cereal but I'm looking for a lightweight solution.
18:57:19 <peddie> jchia: put the double in a Storable vector; cast the ForeignPtr in the Storable Vector and make a bytestring out of it?
18:57:46 <peddie> jchia: I expected Double to have a Bits instance, but it doesn't seem to
18:58:18 <jchia> peddie: That involves IO, right?
18:58:59 <jchia> I prefer a pure way.
18:59:18 <peddie> jchia: it technically involves IO, but it's not actually doing I/O operations
18:59:22 <peddie> jchia: https://hackage.haskell.org/package/crackNum-1.9/docs/Data-Numbers-CrackNum.html might help you?
19:01:58 <jchia> peddie: I think I'll use Data.ByteString.Builder.doubleLE from the bytestring package. That's how cereal does the conversion.
19:04:10 <peddie> ah, if bytestring already has a conversion function . . . seems like a good way to go :)
20:36:49 <fresheyeball> has anyone out there gotten haddock to build for ghcjs-dom?
20:38:14 <hamishmack> fresheyeball: ghcjs-dom is basically empty (it just reexports modules from jsaddle-dom or ghcjs-dom-jsffi depending on the compiler used)
20:39:07 <fresheyeball> ok, well jsaddle-dom then
20:39:11 <hamishmack> https://hackage.haskell.org/package/jsaddle-dom-0.9.2.0/docs/doc-index-A.html
20:40:04 <fresheyeball> hamishmack: what the heck?
20:40:11 <fresheyeball> How come it works for the index
20:40:20 <fresheyeball> but the modules show as unclickable in the contents
20:40:24 <hamishmack> Where it says JSDOM.Generated or JSDOM.Custom think GHCJS.DOM
20:40:33 <hamishmack> Oh you have to scroll down
20:40:49 <fresheyeball> oh shit!
20:40:53 <fresheyeball> I am a dumbass
20:42:54 <hamishmack> We should rename Generated to Auto so they apear nearer the top
20:45:10 <saurabhn_> are there any known good solution for the deploy+restart problem when it comes to Haskell webapps?
20:50:49 <fresheyeball> hamishmack: that's a good idea actually
21:21:02 <hooglenoob> hello all
21:21:40 * heath waves hello
21:22:57 <hooglenoob> trying to implement worstsort but still pretty new to haskell, here's the problematic part http://lpaste.net/359063
21:23:49 <c_wraith> hooglenoob: I'm assuming permutations returns a list of lists?
21:23:59 <hooglenoob> yeah it's Data.List permutations
21:24:52 <hooglenoob> I can post up the entire file if you'd like to try and compile
21:25:14 <c_wraith> hooglenoob: well, then.  the recursive call to worstsort passes in [[a]], so it has to return [[a]], but in order to type-check, it needs to be [a]
21:26:31 <hooglenoob> i'm a bit confused about that part, as it's declared [a] to [a] so it should be able to handle [[a]] to [[a]] when recursively called, right?
21:26:59 <c_wraith> sure, that's not the problem.  The problem is that the return type doesn't match the required return type
21:27:21 <thebigj> Can anyone suggest good resources to learn Haskell? Is http://learnyouahaskell.com/ good resource?
21:27:24 <thebigj> Thanks!
21:27:44 <c_wraith> that's generally not considered a great resource.
21:27:45 <hooglenoob> ohhhh i understand now
21:27:51 <LiaoTao> thebigj: That one is sort of adequate but not great
21:27:57 <LiaoTao> People recommend some fancy book nowadays
21:28:07 <c_wraith> or the CIS194 course
21:28:39 <DigitalKiwi> what about real world haskell
21:28:55 <hooglenoob> so in general worstsort is [a] -> [[a]] but in the base case k=0 it's [a] -> [a]
21:28:58 <hooglenoob> that seems problematic
21:29:07 <c_wraith> hooglenoob: it is definitely problematic.
21:29:29 <c_wraith> DigitalKiwi: it's not a bad intermediate book.  It's not a great intro.  It's also kind of out-of-date by now.
21:31:15 <thebigj> c_wraith: I don't know any functional programming language. My goal is to know what difference a functional programming lanuge make
21:31:15 <DigitalKiwi> I need something free that I can read fast enough to hold my interest and learn enough that I can actually start doing stuff and also interesting enough to keep my attention :|
21:32:00 * DigitalKiwi rather needy and adhd
21:34:11 <hooglenoob> ah, it seems i've misinterpreted how to implement worstsort. pretty hilarious algorithm
21:37:17 <hooglenoob> c_wraith: thanks for all your help! have a good night/day
21:40:18 <peddie> DigitalKiwi: try Write Yourself a Scheme in 48 Hours?
21:52:20 <DigitalKiwi> yeah that's the one I was kind of trying a bit ago
22:07:48 <Axman6> hooglenoob: you might find this fun: http://www.bowdoin.edu/~ltoma/teaching/cs231/spring14/Material/broder86pessimal.pdf
22:08:27 <Axman6> looks at producing the worst case implementation of a given task which is still productive, and doesn't do unnecessary work
22:10:26 <Myrl-saki> Has anyone here worked on a device with 4GB RAM? I'm looking for a laptop, and yeah.
22:26:03 <jle`> well i mean...presumably most of us have worked on a device with 4GB within our lifetimes
22:26:41 <jle`> what sort of questions did you have?
22:26:57 <roi_du_silence> heyo
22:27:16 <jle`> hi roi
22:33:19 <Myrl-saki> jle`: Basically, I've had builds(autogenerated) where 3GB wasn't enough.
22:33:50 <Myrl-saki> jle`: I was thinking if I should get a 4GB device or an 8GB device. I know that the 4GB device is very underpowered, but I'm fine with that.
22:34:08 <Myrl-saki> Core M, etc.
22:41:09 <jle`> yeah 4GB is probably not enough for modern day haskell/ghc/stack
22:41:54 <dfarm> Hey all, I'm trying to 'stack build' a project from Github on Windows and I'm being bitten by OpenSSL issues (missing C libraries eay32, ssl32). Can anyone tell me where to find better logs on what exactly it's trying to link to etc?
22:42:38 <hooglenoob> Axman6: forgot I was in IRC, I'll give it a read.
22:42:39 <dfarm> I've tried stack build --cabal-verbose, but even that isn't very informative. I guess I need more cabal level logging rather than stack (to see what it's asking ld / gcc to do)
22:42:41 <geekosaur> it told you. those are different names for the openssl libraries on windows (eay32 is the old one)
22:43:15 <hooglenoob> Ah, I've read the excerpt about slowsort before
22:43:15 <dfarm> geekosaur: I've already installed OpenSSL, I have eay32 and ssl32 and I've put the paths to them in to extra-lib-dirs -- it is still not working. 
22:43:59 <dfarm> My question is not about openssl; it's about how do you get stack to tell you exactly what it's doing so I can debug it. 
22:44:03 <geekosaur> you may not have done it right, then
22:44:28 <geekosaur> were this cabal it'd be -v3, I dont know if the same works for stack
22:44:44 <geekosaur> but all it'd how you is its trying to compile a stub with -leay32 and then with -lssl32
22:44:49 <geekosaur> *show you
22:44:51 <Cale> I recently upgraded my laptop from 16GB to 32GB of memory for the sake of being able to do some builds of our larger projects on it without relying on a server elsewhere. It's mostly comfortable, but leave a few ghcids running, and I can still come close to running out of memory. :)
22:45:24 <Myrl-saki> jle`: Yeah, thanks.
22:45:33 <Myrl-saki> Cale: Wait. What.
22:45:46 <Myrl-saki> Cale: Let me guess. 16 cores?
22:45:54 <Myrl-saki> cores/threads
22:45:55 <geekosaur> and the -L options taken from extra-lib-dirs
22:46:04 <Cale> 8
22:47:16 <Myrl-saki> Cale: How do you use 16 GB of RAM in compiles?
22:47:21 <ongy> ... I have 4 GB in my laptop. And I ran out of ram configuring xmonad before
22:47:45 <Myrl-saki> Cale: The most I've used in a moment is probably like 4-6.
22:48:01 <Myrl-saki> OTOH, I haven't really measured, but there was no slowdown in my system.
22:48:52 <Cale> Myrl-saki: I honestly don't really know why it needs so much memory. Even just the linking step is stupidly expensive with large Haskell projects.
22:49:42 <Myrl-saki> Cale: I see. So it's the project build itself rather than the dependencies?
22:49:49 <Cale> yeah
22:50:24 <Myrl-saki> Cale: Thanks. I guess I'm safe from that. For now.
22:51:20 <Cale> Well, sometimes it's the dependencies -- if nix wants to build a bunch of stuff, it tends to be pretty good at being concurrent, which is hard on memory requirements.
22:52:12 <Cale> But mostly I rely on binary caches shared with the rest of my coworkers for that stuff.
22:52:24 <Myrl-saki> Cale: Ah. w.r.t. build server?
22:53:51 <Cale> Well, nix is what we use for building all our projects, and if for whatever reason the binary cache doesn't have the compiled deps already, then my laptop's going to start trying.
22:54:55 <Myrl-saki> Cale: Does everyone there use Nix? If so, some other Linux or NixOS?
22:55:20 <Cale> I'm using Linux Mint on my laptop
22:55:31 <Cale> A lot of my coworkers use NixOS
22:55:46 <Cale> but it's too annoying to get the desktop configuration I want with it still
22:56:10 <Myrl-saki> Cale: Ah. Also. Does everyone pin to a certain version?
22:56:53 <Cale> Each project pins the version of nixpkgs it's using
22:56:57 <Cale> (and reflex-platform)
22:57:21 <Cale> and then individual packages get overrides as necessary
22:57:56 <Myrl-saki> Cale: Ah.
22:59:47 <Cale> and of course, we bump the reflex-platform version reasonably often, but nixpkgs is a bigger deal to change.
23:00:35 <Cale> ah, another thing I forgot about with respect to explaining memory usage is that we have a bunch of template haskell
23:00:49 <Maxdamantus> Because of assumptions of the structures of sets used in overrides?
23:01:16 <Myrl-saki> Cale: What makes TH very resource consuming?
23:02:02 * Myrl-saki hasn't checked so much on Haskell compiling
23:02:34 <Cale> and not only does that tend to result in stuff that makes ghc work hard as it is (you can automatically generate fairly large definitions in some cases and make the simplifier work hard), but in the case of ghcjs, that means spinning up node to run the javascript which gets compiled to generate the splices
23:03:00 <Myrl-saki> Oh right.
23:03:16 <Myrl-saki> Reminds me that node/ghcjs has like 2-5 seconds startup time on my laptop lol
23:03:27 <Myrl-saki> Or more.
23:03:34 <Myrl-saki> Which is really really fun when compiling dependencies. /s
23:05:30 <Cale> Just to see, I fired up a ghcid with one of our backends and that's sitting at 3.2 GB, and then started a frontend build, and ghcjs is currently using 4.4 GB on its own and then node is fluctuating between 1-2 GB.
23:06:49 <Myrl-saki> Cale: How do you daemonize ghci?
23:06:52 <Cale> Usually I'd also have a ghcid for the frontend running in the background too regardless of whatever else I was compiling
23:07:19 <Cale> https://hackage.haskell.org/package/ghcid
23:07:43 <Myrl-saki> TIL. Thanks.
23:08:24 <Cale> I really wish that ghcid could also be a little bit interactive and let you use ghci whenever the build was successful
23:08:37 <Cale> I should look into what that might involve at some point
23:10:45 <Myrl-saki> Cale: How do you run ghcid on nix?
23:10:47 <Profpatsch> Everytime I read this tutorial, I feel like I know less afterwards https://haskell-lang.org/tutorial/exception-safety
23:10:56 <Myrl-saki> Cale: `--command 'nix-shell -p ghci'`?
23:10:58 <Myrl-saki> Err
23:11:01 <Myrl-saki> --run*
23:11:08 <Myrl-saki> Cale: Or you do a nix-shell for then run ghcid?
23:11:11 <Profpatsch> Concretely: What the fuck should I use for everyday exception handling.
23:11:31 <Profpatsch> And who the fuck cares about async exceptions in most cases?
23:11:44 <Cale> Myrl-saki: We have a shell script which runs a nix-shell that starts ghcid right away
23:12:02 <Profpatsch> Such a confused piece of writing. :(
23:12:07 <Myrl-saki> Cale: Ah. THanks.
23:12:08 <jle`> Profpatsch: i usually just use Control.Exception
23:12:40 <Myrl-saki> This reminds me that I like how the Haskell site looks like.
23:12:44 <jle`> Profpatsch: but also the exceptions chapter in simon marlow's book (parallel and concurrent programming in haskell) is pretty useful
23:12:53 <Cale> Profpatsch: If you expect that the user of your definition will almost always want to handle the exceptional condition, use Either or some other explicit representation of failure.
23:13:17 <Profpatsch> In my concrete case Iâ€™m using the http-client stuff to fetch a simple URL.
23:13:55 <Cale> Ah, so you're the user of the library and just trying to handle exceptions?
23:13:59 <jle`> yeah i'd probably just use Control.Exception for that
23:14:01 <Profpatsch> And I have no idea whether bracket finally onException catchError catch catchJust catches etc pp should be used.
23:14:12 <jle`> but what do you actually want to do
23:14:26 <Profpatsch> Just get a lazy bytestring out of that library.
23:14:34 <Cale> Yeah, that library has some rather obnoxious exceptions in some cases where you almost always want to deal with the error
23:14:36 <Profpatsch> Can be in-memory for all I care.
23:14:50 <jle`> if you just want to catch an exception that an IO action might throw, you can just use Control.Exception
23:15:19 <Cale> Lazy bytestrings will make dealing with exceptions that occur in the middle of the stream tricky
23:15:31 <Cale> (tricky enough that you probably don't want to do it)
23:15:55 <Cale> But if that's not a concern, then I would just use 'try'
23:16:23 <jle`> lazy bytestrings wouldn't cause too much trouble as long as you don't use lazy io
23:16:32 <Cale> Well, right.
23:17:19 <Cale> ah, httpLbs doesn't actually try to make use of the laziness :)
23:19:57 <Cale> But yeah, the way that http-client library uses exceptions is particularly confusing.
23:20:45 <Cale> I feel that a lot of its exceptions really shouldn't be thrown at all, but represented as part of the result of various actions directly.
23:22:13 <Cale> Also: is anyone ever really going to pattern match on the cases of HttpExceptionContent all at once? That design seems questionable. Many of those things can't actually happen at the same time.
23:22:45 <Cale> (I mean, from the same point in the code)
23:23:43 <Cale> Making all the exceptions that can be thrown by various parts of the library all one big type means that you have a hard time knowing what you need to handle when you do try to catch them.
23:24:27 <Cale> But it's frustrating, because I'm not sure there's anything better at present to replace this.
23:25:23 <Profpatsch> v confusing, yes.
23:26:09 <Profpatsch> Funny thing: TlsNotSupported is in that ADT. But there is a seperate package providing TLS in the first place.
23:26:13 <Profpatsch> Seems like an ugly hack.
23:26:27 <Cale> yep
23:26:28 <Profpatsch> Why split the packages if they are entangled anyway.
23:26:58 <Profpatsch> So you have to deal with exceptions and then pattern match anyway.
23:27:36 <Profpatsch> I just wrap that ADT in an Either and pass it out. Calling function will most probably just print it, anyway.
23:27:48 <Profpatsch> Or pattern match on a few cases and provide a default.
23:28:56 <Cale> Yeah, the annoying thing is that if you wrap any individual thing in a try or catch or whatever, you can't be sure which options might need handling, because it's always the same monolithic exception type.
23:30:10 <Profpatsch> Well, thatâ€™s part of the expression problem, isnâ€™t it.
23:31:10 <Profpatsch> Could go with existential exception trees all the way, but that brings its own problems, right?
23:31:52 <Cale> There would be not much downside to having a bunch of individual exception types corresponding to the various points at which exceptions can occur.
23:32:18 <Cale> You can define a sum of those if you want, and make that an instance of Exception which catches any of them.
23:33:02 <Cale> In some sense, the Exception library already contains a bit of a solution to the expression problem
23:39:13 <Cale> http://lpaste.net/359066
23:39:39 <Profpatsch> If there is a way to parse in URLs, why do the http functions still throw an InvalidURLError anyway. :(((
23:40:29 <Profpatsch> Cale: Ah, and depending on the inferred Exception type used by the outside code, it will catch different exceptions.
23:40:32 <Profpatsch> Nice, yes.
23:40:39 <Cale> yep
23:40:44 <Profpatsch> I wonder how that is implemented.
23:40:49 <Cale> Typeable
23:40:53 <Profpatsch> Can Typeable access the inferred type?
23:41:40 <Profpatsch> Then it probably checks equality with the actual type it gets at runtime.
23:41:40 <Cale> Basically, yeah
23:41:59 <Profpatsch> And rethrows if not equal.
23:42:03 <Cale> and allows for "safe" coercion
23:42:17 <Profpatsch> Hm, but how does it handle subtypes?
23:43:03 <jle`> the documentation for Control.Exception shows how you can make a subtype hierarchy
23:43:06 <Cale> Well, if you want a subtype, you can define your own new exception type, and then define fromException such that it will succeed when given certain values of the larger exception type.
23:43:33 <Cale> (projecting out whatever information you wanted)
23:43:35 <jle`> but basically it comes from picking clever usage of fromException
23:44:19 <Cale> At one point I wrote a module which had each of the cases of IOError split out into their own types.
23:44:23 <Myrl-saki> What do you guys think of UNIX philosophy?
23:44:31 <Myrl-saki> Specifically on IPC.
23:44:37 <xormor> Myrl-saki, I like it.
23:44:54 <Profpatsch> Ah, you have to implement the subtyping manually then.
23:44:54 <Cale> Myrl-saki: treating everything as a sequence of bytes sucks a bit
23:45:13 <Myrl-saki> I'm still having a hard time choosing between small but many programs and one monolithic program.
23:45:18 <Cale> Myrl-saki: But apart from that, the idea of having simple programs which are composable is a good one
23:45:36 <Myrl-saki> One monolithic program -> using a library, I mean.
23:45:37 <Profpatsch> â€œtext sequences are the universal data structureâ€ â€“ Well, of course ByteString is, silly.
23:45:51 <Profpatsch> There is not any less semantic information to be had, after all.
23:46:22 <Myrl-saki> Cale: What about in cases where the protocol is non-standard, and a client-server pair only makes sense with each other?
23:46:31 <Profpatsch> Myrl-saki: The problem with Unix tools is exactly that boundary where you use any and all information except from conventional.
23:46:37 <Myrl-saki> And that the client-server can as well be merged.
23:46:45 <Myrl-saki> s/can/may/
23:46:54 <Profpatsch> There is exactly zero compatibility (say: type) checking going on.
23:47:01 <Myrl-saki> I'm giving too much thought about window managers. Lol.
23:47:20 <Profpatsch> Not any better than duct-taping stuff if you ask me.
23:47:38 <Myrl-saki> Case in hand. I'm thinking of making a window manager. I'm thinking of separating actual window management and window positioning to different programs.
23:47:44 <Cale> Myrl-saki: An abstraction is only useful once it has at least a second instance.
23:48:02 <Profpatsch> Myrl-saki: Have you looked at Wayland? Maybe what you want to write is a compositor.
23:48:23 <Myrl-saki> Profpatsch: I've checked Wayland, and it's too low level for my skills right now.
23:48:23 <Profpatsch> Window managers are so 1970s.
23:48:47 <Myrl-saki> Profpatsch: :P
23:49:00 <Myrl-saki> Profpatsch: Oh, right. Wayland is too safe to, so I can't use something like Plover.
23:49:04 <Profpatsch> Myrl-saki: A first step is writing a nice XMonad config, thatâ€™s a little more high-level.
23:49:05 <Myrl-saki> too safe too*
23:49:11 <Cale> Myrl-saki: If you can imagine writing a second version of one or both of those components which operates differently, maybe the separation can be made worthwhile.
23:49:36 <Myrl-saki> Cale: Right. This is giving me some thoughts now.
23:50:06 <Myrl-saki> Cale: I got a bit inspired by wmii which exposed a Plan 9 interface.
23:50:20 <Cale> I need someone who hates tiling to use XMonad and take the time to write a good configuration that operates like an ordinary window manager, and then only uses tiling for certain windows.
23:50:47 <Cale> I'd be okay with having most of my terminal windows tiled, but other stuff, I'd rather not.
23:51:13 <Myrl-saki> My problem with XMonad is that it disrespect some protocols.
23:51:18 <geekosaur> sadly that won't work well
23:51:23 <Myrl-saki> ...
23:51:29 <Myrl-saki> s/disrespect/doesn't respect/
23:51:34 <geekosaur> the floating layer was an afterthought, more or less. it behaves *really* badly
23:51:37 <Myrl-saki> THat sounded wrong. Lol.
23:52:16 <Myrl-saki> geekosaur: You can't even have (proper) window decorations on floating windows without patching :D
23:52:18 <geekosaur> there's a layout that does float everything it receives (and can be wrapped in another layout that captures to tile specific windows, like ComboP. don't expect the result to behave sanely :(
23:52:31 <Cale> geekosaur: Yeah, I've seen some crazy stuff, like on my friend's machine, I tried to move the Steam login window, and it started shaking back and forth more and more wildly until it flung itself off the screen
23:52:32 * geekosaur hates the StackSet
23:52:50 <Myrl-saki> Cale: Pffft. That's child's play. Try using WINE under XMonad.
23:52:50 <Cale> It was pretty funny actually
23:53:11 <Myrl-saki> OTOH, I still love XMonad.
23:53:21 <Cale> Well, right, I want someone to go do all the window decoration stuff
23:53:36 <Myrl-saki> Cale: I'm trying to make something with reflex.
23:53:39 <Myrl-saki> :D
23:53:44 <geekosaur> Steam I'm not sure about. I know nothing that uses mono will work, because it doesn't work under nonreparenting window managers at all
23:53:48 <Cale> Hah, that would be cool
23:54:30 <geekosaur> Java at least has some hacks to behave under nonreparenting window managers (although if you don;t deploy those hacks then it too can behave rather poorly)
23:54:37 <Myrl-saki> Let me check if I have it on github..
23:54:46 <Cale> geekosaur: Well, there must be *some* amount of effort which could be put in to make that work sanely, in principle.
23:55:03 <Myrl-saki> I don't.
23:55:19 <geekosaur> yes, the i3 method which is to reparent with windows that are hidden under the real ones. unfortunately it'd break hgalf of our contribs, which know there are no such windows
23:55:31 <geekosaur> and assume there's nothing between the root and the application window
23:55:35 <Cale> Myrl-saki: Oh, actually, right, it was wine steam
23:55:40 <geekosaur> basically the opposite of the java/mono problem 
23:55:46 <Myrl-saki> Cale: Yay. :D
23:55:52 <Myrl-saki> I haven't tried wine steam yet.
23:56:04 <Myrl-saki> But I didn't expect it to work.
23:56:06 <LiaoTao> geekosaur: Wow, x11 is a shitshow
23:56:21 <geekosaur> (and yes, wine will have it as well. it's essentially the same problem in all cases: they use Windows addressing for canvases, which is screen relative. for X11 it has to be window relative
23:56:24 <Cale> It works pretty well actually... less well under XMonad it seems, but still okay.
23:56:43 <geekosaur> so they look for a frame window so as to get the offset right, don't fdind it, and ... what exactly happens depends on which API, it seems
23:57:01 <Cale> At one point the steam icon which is meant to appear in the notification area appeared on top of the game display, and I had to quit the game and restart steam to make it go away.
23:57:18 <Myrl-saki> Oh wait.
23:57:23 <Cale> The weird thing being that it appeared sort of in the middle of the top left quadrant of the screen.
23:57:24 <geekosaur> sometimes it gives up and draws outside the window (which you won't see because of clipping), sometimes it goes into an infinite loop, sometimes it does weirder things
23:57:45 <Myrl-saki> Oh yay. I *do* have it setup.
23:57:56 <geekosaur> and if they disable window clipping then it could end up drawing somewhere else
23:58:40 <Myrl-saki> Cale: https://github.com/adrianparvino/reflex-xhb/blob/master/app/Main.hs
23:59:24 <Cale> hah!
