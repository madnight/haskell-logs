00:20:30 <ertes-w> helo
00:48:39 <Barry_> Hi I was yesterday already here and received great knowledge from here, so I will try today too to understand an assignment I have to do
00:49:33 <Barry_> Does someone know a bit about prefix notation and can help me discuss about translating this function into the prefix notation: add3 1 2 3
00:49:54 <ertes-w> Barry_: hiâ€¦  it is already in prefix notation
00:50:03 <ertes-w> > replicate 4 'a'  -- prefix
00:50:06 <lambdabot>  "aaaa"
00:50:11 <ertes-w> > 4 `replicate` 'a'  -- infix
00:50:14 <lambdabot>  "aaaa"
00:51:28 <Barry_> oh I see thanks, I though they wanted me to use the (+) Operator. Hence something like this: (+)3 ((+) 1 2)
00:52:02 <ertes-w> yeah, that's prefix
00:53:19 <ekr> hi, isn't there a bitwise not operator in haskell? Data.Bits doesn't seem to have any
00:54:22 <ertes-w> ekr: complement
00:54:24 <cocreature> ekr: complement?
00:55:21 <ekr> yeah, that's the one. thanks
00:55:37 <Barry_> So one of those functions that are supposed to be translated into prefix is: x + 3 * y * z. Which I solved as (+) x $ (*) z $ (*) 3 y
00:55:57 <Barry_> Thats still in prefix right?
00:56:11 <ekr> now, were Ints in haskell something like 29 bits long? that's, a at least a bit inconvenient
00:56:56 <ekr> oh, there's Int32, and Int64
00:56:56 <cocreature> > finiteBitSize (0 :: Int)
00:56:59 <lambdabot>  64
00:56:59 <ertes-w> Barry_: it's "prefix enough" in that you're using prefix notation for (+) and (*)
00:57:08 <ertes-w> Barry_: but you're using ($) in infix form
00:57:09 <cocreature> but it varies on different architectures
00:57:26 <phadej> ekr: depends, report says they should be at least of that size
00:57:53 <phadej> ekr: but as cocreature points out, it's not the case for GHC now
00:57:58 <ertes-w> Barry_: also this is blatant overuse of ($)â€¦  it's close to incomprehensible
00:58:19 <phadej> ekr: though, it's better to use Int32/64 because Int is different on different machines
00:59:43 <Barry_> ertes-w: Ty than I have to change it to (+) x ((*) z ((*) 3 y)). But that looks even more incomprehensible
00:59:54 <ekr> i know, coming from C, with stdint.h ...
00:59:55 <ertes-w> Barry_: no, it's much better
01:00:09 <cocreature> Barry_: rewriting everything in prefix form is not exactly a way to make your code more comprehensible
01:00:21 <ertes-w> cocreature: it's an assignment
01:00:30 <cocreature> oh ok
01:00:55 <Barry_> I think that it is supposed to allow leaving out parameters and thats probably what we are supposed to learn
01:02:13 <ertes-w> Barry_: section syntax is much more common for that
01:02:29 <ertes-w> > map ((+) 5) [1,2,3]  -- prefix
01:02:32 <lambdabot>  [6,7,8]
01:02:35 <ertes-w> > map (5 +) [1,2,3]  -- section
01:02:39 <lambdabot>  [6,7,8]
01:07:29 <Barry_> oh okay
01:27:41 <phaazon> hey
01:27:59 <phaazon> anyone here using elm-export?
01:28:01 <phaazon> or an author?
01:28:08 <phaazon> thereâ€™s a problem with the Header stuff
01:28:32 <phaazon> it turns a type like "route" :> Header "Foo" Foo into a function that expects a Foo
01:28:38 <phaazon> while it should expect a Maybe Foo
01:28:42 <phaazon> I might patch this
01:28:50 <phaazon> anyone interested?
01:31:16 <opqdonut> sounds reasonable, without knowing anything about elm-export
01:32:31 <phaazon> oh i guess it servant-elm
02:08:03 <ph88> stack has a version for libgmp4 see https://docs.haskellstack.org/en/stable/install_and_upgrade/#manual-download_2  how can i compile my own program the same? i want to distribute it to some people who run an old OS
02:41:24 <AndreasK> What prevents Data.Set from using member as a elem implementation? I know Foldable doesn't have the Ord constraint, but we know we need one to construct a Set so can't we access that one some way?
02:44:12 <sphinxo> Best way to set nth element in a list?
02:44:31 <AndreasK> Not using a list :(
02:46:46 <sphinxo> AndreasK: what to use instead?
02:47:02 <AndreasK> https://hackage.haskell.org/package/containers-0.5.10.2/docs/Data-Sequence.html
02:47:07 <AndreasK> or Vector
02:47:36 <sphinxo> ahh ok
02:47:40 <geekosaur> sphinxo, a list is a linked list. you do not want to do random access on it.
02:48:25 <AndreasK> I've run into the desire to update a single element of a list a few times. The Answer always turned out as don't use a List.
02:48:34 <ertes-w> AndreasK: no, because only with Ord you can do O(log n) membership test
02:48:49 <ertes-w> AndreasK: you need Ord to decide which branch to pick in the tree
02:48:49 <sphinxo> I have a list of "Instructions" that are like: set 3rd element of [a] to the product of the 6th and 9th
02:49:10 <sphinxo> which are applied one after the other
02:49:43 <ertes-w> sphinxo: use Data.Sequence or a mutable vector
02:50:17 <sphinxo> ok thanks, I'll do that
02:52:01 <jchia> I'm trying to newtype BlazeBuilder, simply so that I can define a Show instance that builds the LByteString and shows that, so that data structures containing the newtype can also have a Show instance. However, I also need the Builder instance. Is there a simple way to derive the corresponding Builder instance for my newtype? Maybe I need certain language extensions? http://hackage.haskell.org/package/chunked-data-0.3.0/docs/Data-Builder.html
02:52:50 <AndreasK> ertes-w: I know, but afaik we can't have a Set that has no Ord instance. So I wondered why we couldn't use/access that one.
02:53:19 <phadej> jchia: google for GeneralizedNewtypeDeriving
02:53:49 <ertes-w> AndreasK: sets don't have an Ord instance
02:53:50 <jchia> phadej: I tried that, I think it doesn't work. The Builder class has 2 type params: builder & lazy
02:53:58 <AndreasK> Well their elements do
02:54:03 <ertes-w> AndreasK: only operations use Ord
02:54:23 <ertes-w> a Set is just a tree structure with values
02:56:14 <AndreasK> I guess a madman could use Set.Internal to construct a Set on elements that don't have the Ord instance.
02:56:14 <ertes-w> jchia: StandaloneDeriving might work
02:56:47 <ertes-w> AndreasK: (5 :: Integer) does not have an Ord instanceâ€¦  it's just a value
02:57:05 <ertes-w> AndreasK: 'compare' uses the (Ord Integer) instance to compare values
02:57:31 <ertes-w> AndreasK: in fact some operations don't need an Ord instance
02:57:35 <ertes-w> :t S.singleton
02:57:37 <lambdabot> a -> S.Set a
02:57:41 <ertes-w> :t S.toList
02:57:42 <lambdabot> S.Set a -> [a]
02:58:12 <jchia> ertes-w: Didn't work. The error message suggested DeriveAnyClass, but that didn't help
02:58:31 <jchia> "Functional dependencies conflict between instance declarations"
02:59:29 <AndreasK> Let me rephrase the question: If I have a x of some type (Set a) where there exists a Ord instance for a. What prevents the Functor instance to check if such a instance exists and if so use it.
02:59:43 <ertes-w> AndreasK: here is a challenge:
02:59:52 <jchia> I think fundamentally I can only have one builder type that matches LByteString for Builder class
03:00:12 <ertes-w> AndreasK: write a function (isSorted :: [a] -> Bool) that can determine whether a list of type [Integer] is sorted
03:00:19 <jchia> because of the functional dependency
03:00:27 <jchia> is that a correct explanation?
03:02:57 <ertes-w> AndreasK: do you see the problem?
03:03:36 <AndreasK> ertes-w: I think you try to explain the wrong thing. I'm pretty sure it's not possible (maybe with reflection or similar trickery) and there is a similar reason to the member/elem thing. I just wonder what would be required to be able to do so.
03:03:57 <AndreasK> Eg what prevents me from defining a function that says if a has a ord instance use this code otherwise that code
03:04:06 <ertes-w> AndreasK: you could encode the Ord instance in the Set
03:04:14 <ertes-w> but why would you do that?
03:06:05 <ertes-w> data SetWithOrd a = SetWithOrd { setOrd :: Dict (Ord a), setSet :: Set a }
03:06:24 <ertes-w> memberWithOrd :: a -> SetWithOrd a -> Bool
03:06:39 <ertes-w> memberWithOrd x (SetWithOrd Dict xs) = member x xs
03:07:46 <ertes-w> not only would that be a performance hit, but it's also rather pointlessâ€¦  'member' needs Ord, so it should just ask for Ord
03:08:05 <royal_screwup21> I'm trying to run this module https://thepasteb.in/p/66hVYpwgyzoSW When I do "l <name of file>", it compiles, but nothing shows up. If I'm understanding correctly, it's supposes to print out stuff
03:08:15 <ertes-w> AndreasK: also now you need Ord for *everything*
03:08:25 <ertes-w> singletonWithOrd :: (Ord a) => a -> SetWithOrd a
03:08:34 <ertes-w> notice how 'singleton' for Set does not need Ord
03:09:50 <ertes-w> this is really just an exercise in wasting timeâ€¦  both engineering time and CPU time
03:09:57 <AndreasK> I understand that. My main question I guess is what is missing to write conditional code depending on the existance or lack of an instance.
03:10:10 <ertes-w> you can't do that in haskell
03:10:23 <Tehnix> royal_screwup21: In GHCI? You need to call `main` manually also
03:10:57 <AndreasK> Hence the question why/what is missing that would enable such a thing.
03:12:12 <ertes-w> AndreasK: such a thing simply wouldn't be consistent, because of the open world model of type classes
03:13:13 <ertes-w> AndreasK: the idea is that instances *always* existâ€¦  they may just be out of scope
03:13:27 <royal_screwup21> Tehnix: ah, thanks! I'm trying to run it in GHCI, yup. So I typed in "l filename", then "*Main>"  showed up, to which I just typed "main". Nothing's happening
03:15:00 <lyxia> make sure you saved the file and you are loading the right file
03:17:08 <Tehnix> AndreasK: Something like `if hasOrd t then orderIt t else head t` (or whatever container operation that doesn't require a typeclass)
03:17:14 <ertes-w> AndreasK: class MaybeC c where maybeC :: Maybe (Dict c)  -- something like this could work, because it's consistent with the open world model: you *always* write an instance, and the instance itself delivers a class dictionary or not
03:17:39 <Tehnix> I would suspect you would need some unsafe operations if even possible. I was currently reading up on unsafeCoerce to see if it'd guide me to something else that you could use
03:18:13 <ertes-w> AndreasK: but notice how MaybeC is disconnected from the actual existence of a suitable instanceâ€¦  you don't *test* whether the instance exists, you *decide* whether it exists
03:19:51 <ertes-w> instance MaybeC (Ord Integer) where maybeC = Nothing  -- here i decided that the (Ord Integer) instance doesn't exist (in terms of MaybeC's notion of "existence")
03:21:20 <AndreasK> But that would require to write a instance for each type it should work on which doesn't seem practical. (But then if there where a practical way to do such things I guess I would have come across one)
03:21:48 <ertes-w> there can't beâ€¦  not in terms of type classes
03:22:24 <ertes-w> AndreasK: it's much more practical to take the (Maybe (Dict (Ord a))) argument directly
03:22:47 <ertes-w> but then you could just as well write two functions, because you're implementing two different algorithms anyway
03:23:11 <Tehnix> Could he use Data.Dynamic and Typyable?
03:23:22 <ertes-w> nubMaybeFast :: Maybe (Dict (Ord a)) -> [a] -> [a]
03:23:29 <ertes-w> err
03:23:34 <ertes-w> nubMaybeFast :: (Eq a) => Maybe (Dict (Ord a)) -> [a] -> [a]
03:23:43 <ertes-w> nubSlow :: (Eq a) => [a] -> [a]
03:23:50 <ertes-w> nubFast :: (Ord a) => [a] -> [a]
03:23:57 <ertes-w> i'd go with writing the separate functions
03:24:38 <AndreasK> Well the goal would be for eg a library to have a user call nub, and have the compiler pick the fastest implementation based on the argument
03:27:05 <Tehnix> AndreasK: You might wanna look into Data.Typeable (exposes a `typeOf`) and Data.Dynamic then. A neat writeup is at <https://medium.com/@paul_meng/what-are-data-typeable-and-data-dynamic-in-haskell-43e279051396> :slightly_smiling_face:
03:27:24 <AndreasK> Just seemed strange to me that when the type "a" and hence the instance in scope are known we can't access that information in a sensible way. But I guess that's the way it is and it doesn't come up often
03:27:30 <Tehnix> Dunno if that's exactly what you are looking for, and honestly there may be other ways that are smarter than mine :3
03:28:00 <AndreasK> Tehnix: Thanks will check it out. It's mostly curiosity not a practical need at the moment.
03:30:32 <Tehnix> AndreasK: It peaked my curiosity too ^_^ As he mentions in the article, there are valid areas such as receiving unknown data over the network etc that could utilize such a dynamic approach
03:31:11 <lyxia> The instances in scope are only known at compile time though.
03:33:00 <Tehnix> lyxia: I guess if you can figure out the type, and then cast it, you would already know the typeclasses from lookup pre-runtime. As in, you get an `a`, you inspect it as a type of `Int` and  now you actually know it's type class instances since you have access to that information separately. It does need some assumptions, but I guess that's just how dynamic programming works
03:33:42 <lyxia> Tehnix: with Typeable you can only check equality with one concrete type at a time
03:34:09 <lyxia> AndreasK wants automatic switching depending on what instance is visible
03:49:07 <Tehnix> Hmm, I don't see how that couldn't be achieved with matching on the result of `typeOf`, although admittedly that doesn't give you *direct* info about the instances available.
03:57:00 <ertes-w> AndreasK: i understand why it would be nice to have, but we're not gonna have it through the current type class system
03:57:30 <ertes-w> and Data.Typeable doesn't *really* helpâ€¦  you could only use it to branch on specific types, but not type classes
03:58:16 <ertes-w> you could only pick faster implementations for a hand-picked selection of types
03:58:28 <ertes-w> which is of course not very practical
03:58:46 <pie_> do do blocks have naything to do with continuation passing style
04:00:32 <AndreasK> I think for specific types one could also use type families?
04:06:00 <Tehnix> AndreasK: Something like that <https://gist.github.com/Tehnix/f1f547a4224d70fe567101eb20d585a3> ?
04:06:44 <ertes-w> pie_: no
04:06:55 <pie_> ok
04:07:08 <ertes-w> pie_: unless you use them for a CPS monad like ContT or Codensity
04:07:27 <pie_> sure but thats tautological :D
04:08:07 <ph88> stack has a version for libgmp4 see https://docs.haskellstack.org/en/stable/install_and_upgrade/#manual-download_2  how can i compile my own program the same? i want to distribute it to some people who run an old OS
04:11:01 <cocreature> ph88: compile on that OS
04:11:12 <cocreature> docker can be handy for that
04:11:42 <ph88> hmzz that's more difficult, no cross compile or link to specific lib ?
04:12:09 <cocreature> cross compiling is a lot more difficult than spinning up a docker container :)
04:14:19 <cocreature> you probably can get it working somehow but itâ€™s definitely not going to be simpler
04:15:57 <Tehnix> cocreature: I wonder if when we have a bit nicer setup for <http://hackage.mobilehaskell.org> if we could trivialize cross-compiling for such things :3
04:21:01 <cocreature> Tehnix: you canâ€™t really make cross-compiling trivial, things like TH are inherently hard when cross-compiling since often it is simply unclear where the code should be executed
04:22:46 <cocreature> but for those devices you actually have a good reason to cross-compile since the devices are often fairly slow. if you just want to build on an older system, cross-compiling is just a bunch of trouble thatâ€™s easily avoidable
04:25:47 <ph88> cocreature, how does it work with the docker container ?
04:26:39 <cocreature> ph88: find a docker image for the system you care about and build inside of that
04:26:57 <cocreature> stack even has support for building in docker images built in that you should be able to use
04:28:16 <ph88> cocreature, ok but where to find it? first page of google i don't see anything .. perhaps there is a specific website for it ?
04:28:25 <cocreature> ph88: for what?
04:29:12 <ph88> fedora 14
04:29:18 <ph88> docker image
04:32:24 <cocreature> wow thatâ€™s old indeed, you might just need to setup a vm in that case or figure out how to setup a docker image yourself
04:32:35 <ph88> alright, thanks for the help cocreature 
04:34:38 <AndreasK> Tehnix: Thats the idea just with type classes. But there might be no good way to do that
04:38:05 <ph88> i've read that Integer is based on libgmp .. since libgmp supports decimal numbers too can i use arbitrary precision numbers with decimals in haskell? Or do i need yet another library for that?
04:40:27 <cocreature> ph88: https://hackage.haskell.org/package/base-4.10.0.0/docs/Data-Ratio.html#t:Rational
04:42:00 <mxf> Hi *, when I exec `stack hoogle` what does the "Packages missing documentation: â€¦" error/warning mean?
04:43:13 <mxf> Because all the listed packages *do* have Documentation. Well, most of them have some kind.
04:44:06 <ph88> cocreature, there are also these packages: numbers, haskell-mpfr, scientific, FixedPoint-simple and maybe others .. just wanna make sure i make the right choice with Data.Ratio .. speed is important
04:44:40 <cocreature> if speed is important, as usual the right solution is to benchmark
04:44:46 <mxf> https://qu.cx/~/missing_docs.txt
04:48:40 <ph88> "Installing GHC..."  ... so slow :(
04:52:19 <ph88> cocreature, https://bpaste.net/show/95b4b4d139fd
04:52:51 <Phillemann> Is there a shortcut for "maybe mempty pure"?
04:53:26 <mxf> also, somewhat offtopic: since stack fixes the packagelist to a specific compiler: why do I still have to compile packages? :<
04:55:54 <ph88> i think it's because i have to install libgmp3-devel
05:03:15 <stevenxl> Hi everyone. I am trying to wire-up a Haskell web app with a DB connection. I have the following code: 
05:03:23 <stevenxl> https://www.irccloud.com/pastebin/H5cZ1yQ2/
05:03:49 <stevenxl> But I am getting a type error, about IO not having an instance of MonadLogger.
05:04:39 <stevenxl> I can write an orphaned instance of MonadLogger IO that does nothing, which I know is a bad practice. My question is, what would be the easiest way forward.
05:04:48 <stevenxl> I'd like to avoid using monad transformers if possible.
05:04:52 <stevenxl> I don't understand them yet.
05:05:45 <Athas> Defining an orphaned instance would be easiest.
05:06:12 <Athas> Orphan instances are not dangerous/unsafe in themselves; they are just a potential problem for larger programs, because they can end up with multiple instnaces.
05:06:55 <stevenxl> Athas: Got it. Out of curiosity, if you didn't want to go the orphaned instance route, what would be the next step? 
05:08:35 <stevenxl> Someone pointed me to the (runStdoutLoggingT) function, which requires a value of type LoggingT m a. I tried  to create such a value, but I got confused when I saw the type declaration: runLoggingT :: (Loc -> LogSource -> LogLevel -> LogStr -> IO ()) -> m a
05:09:45 <stevenxl> I don't know how to get an IO (Pool Connection) with `runStdoutLoggingT`.
05:10:49 <Athas> stevenxl: I'm not familiar with the library you're using.  But I would use a monad transformer, like LoggingT.
05:11:07 <Athas> But you might want to learn about monad transformers before you go that way.  (They are not that complicated to use, really.)
05:12:10 <stevenxl> Athas: ok thank you .
05:14:53 <romanix> stevenxl, complicated or not you need them to work with web frameworks in haskell :)
05:15:29 <romanix> stevenxl, if you get monads you will have no problems with transformers though
05:16:18 <jhrcek> What's somme easy way to convert Int -> Text? Is there something better than (pack . show)?
05:20:04 <stevenxl> romanix: understood. any tutorial you can point me to or should i google it?
05:23:44 <alp> jhrcek, if you're formatting a bunch of different things into a big pile of text, https://hackage.haskell.org/package/text-format-0.3.1.1/docs/Data-Text-Format.html
05:23:51 <alp> otherwise, pack . show will do :)
05:23:58 <kuko> jhrcek: showt from text-show package
05:24:31 <romanix> stevenxl, take a look at http://dev.stephendiehl.com/hask/#monad-transformers
05:24:46 <stevenxl> Great.
05:24:50 <stevenxl> Thank you, romanix 
05:24:59 <romanix> stevenxl, np
05:24:59 <jhrcek> alp, kuko, thanks I'll check those out
05:25:47 <quchen> hvr: I managed to build the Report, woo! To reproduce: `nix-build`, wait, done :-)
05:26:51 <quchen> https://github.com/haskell/haskell-report/pull/2
05:32:31 <ertes-w> is there a strict, unboxed variant of IORef?
05:32:48 <ertes-w> i.e. a very cheap memory cell for small values
05:39:23 <quchen> ertes-w: I think Simon Marlow is working on something like that
05:39:29 <quchen> (Or was, one year ago)
05:44:12 <cocreature> these days ryan newton is working on it iirc
05:48:14 <Psybur> @pl (\x y -> (x+1) : y)
05:48:14 <lambdabot> (:) . (1 +)
05:50:24 <Psybur> ertes-w, so here's the solutions to your exercise: https://pastebin.com/CqEwEVLP but I cheated cuz I copied some of your examples without fully understanding how they work :D
05:50:57 <Psybur> How does "mempty" fit into \x go c1 c2 ?
05:54:30 <Psybur> Hmm maybe the pairwise flip doesnt actually work :D
05:55:18 <Psybur> It gives strange behavior on an infinite list
06:00:37 <royal_screwup21> Suppose I have a list like so: [1,2,3]. I want to transform it to [[1],[2],[3]] using foldl.  I tried something like: func list = foldl (/acc x -> acc ++[x]) [] list -- but this return back the original list itself. I understand why, but I'm not sure how to extend the concept so as to make a list on every element
06:01:42 <Psybur> > foldr (\x a -> [x]:a) [] [1,2,3]
06:01:45 <lambdabot>  [[1],[2],[3]]
06:02:11 <ertes-w> Psybur: does pairWiseFlip actually satisfy the specification?
06:02:28 <ertes-w> Psybur: pairWiseFlip "abcd" = "badc"
06:02:31 <ertes-w> Psybur: pairWiseFlip "abcde" = "badce"
06:02:32 <royal_screwup21> > foldl (\a x -> [a]:x) [] [1,2,3]
06:02:33 <sphinxo> say I have [6,4,3] and ["x", "y", "z"] and given "z" I want 3
06:02:35 <lambdabot>  error:
06:02:35 <lambdabot>      â€¢ Occurs check: cannot construct the infinite type: a ~ [[a]]
06:02:36 <lambdabot>        Expected type: [a]
06:02:47 <ertes-w> Psybur: the way you wrote it i don't think so =)
06:02:49 <sphinxo> elemIndex + !! ?
06:03:19 <Psybur> ertes-w, it works for finite lists
06:03:39 <ertes-w> Psybur: altPlusOne looks fine
06:03:39 <Psybur> royal_screwup21, youll want to use foldr if youre constructing a list.
06:03:52 <ertes-w> Psybur: so (pairWiseFlip "abcde" = "badce")?
06:04:03 <Psybur> ertes-w, yes
06:04:17 <ertes-w> Psybur: okâ€¦  but it has to work on infinite lists as well =)
06:04:28 <Psybur> But, take 3 $ pairWiseFlip [0..] gives [1,0,3] :D
06:04:41 <ertes-w> that's correct
06:05:13 <royal_screwup21> Psybut hmm. Why not foldl? I mean, it's basically the same thing except you traverse the list from the other direction? (I looked at the top answer: https://stackoverflow.com/questions/1757740/how-does-foldr-work)
06:05:13 <lynn> > lookup "b" (zip ["a", "b", "c"] [1, 2, 3])  -- sphinxo
06:05:16 <lambdabot>  Just 2
06:05:28 <ertes-w> Psybur: take 4 (pairWiseFlip [0..]) = [1,0,3,2]
06:05:35 <ertes-w> that's the expected response
06:05:51 <Psybur> royal_screwup21, no, foldr does not start at the right and work its way left :D
06:06:07 <ertes-w> Psybur: kinda interesting that you used the same approachâ€¦  i would have used a very different approach for that one
06:06:21 <lynn> but consider if maybe you want a Data.Map instead! lookups are far nicer and faster for those
06:06:35 <sphinxo> thanks lynn 
06:06:50 <royal_screwup21> Psybur wow lol, 60 upvotes for the wrong answer on SO
06:07:27 <Psybur> royal_screwup21, if it started at the right and worked its way left how would this work
06:07:35 <ertes-w> > foldr (\x go -> maybe (go (Just x)) (\y -> x : y : go Nothing)) F.toList [0..] Nothing
06:07:40 <lambdabot>  [1,0,3,2,5,4,7,6,9,8,11,10,13,12,15,14,17,16,19,18,21,20,23,22,25,24,27,26,2...
06:07:47 <Psybur> > take 3 $ foldr (:) [] [0..]
06:07:50 <lambdabot>  [0,1,2]
06:08:17 <royal_screwup21> ah
06:08:37 <ertes-w> @where foldrtut
06:08:37 <lambdabot> http://ertes.eu/tutorial/foldr.html
06:08:39 <lynn> I think "start at the right" is a figure of speech (but not a very useful one)
06:08:40 <ertes-w> royal_screwup21: ^
06:09:00 <ertes-w> royal_screwup21: in any case all folds go from left to right
06:09:46 <lynn> foldr (+) z [a,b,c] = (a + (b + (c + z)))  -- the fact that "c + z" is the innermost expression is what makes this person say foldr "starts at the right", I think
06:09:55 <lynn> but that doesn't correspond to how Haskell evaluates it
06:12:57 <phaazon> hey
06:13:01 <lynn> to a human being it's meaningful to *reason* about the outcome starting from the right. compute (c+z) first, then (b+) that, then (a+) that... but of course, Haskell doesn't care!
06:13:08 <phaazon> what is the name of a semigroup with a zero?
06:13:11 <phaazon> I KNEW this
06:13:15 <phaazon> but I forgot :(
06:13:17 <lynn> monoid
06:13:19 <phaazon> no
06:13:22 <phaazon> a monoid has a one
06:13:26 <lynn> err? oh
06:13:29 <phaazon> (N, +, 0) forms a monoid
06:13:30 <lynn> I see
06:13:32 <phaazon> (N, *, 0) forms aâ€¦
06:13:37 <phaazon> I knew this :(
06:14:05 <Psybur> When you say a "one" do you mean identity? Or is it really called a "one" heh
06:14:13 <Logio> I don't think (N, *, 0) can mean anything different than (N, *, 1)
06:14:18 <lynn> https://en.wikipedia.org/wiki/Null_semigroup
06:14:19 <phaazon> Psybur: neutral element
06:14:22 <ertes-w> phaazon: the zero is called an annihilator
06:14:36 <phaazon> ertes-w: Iâ€™m looking for the name of the structure
06:14:42 <phaazon> like a monoid
06:14:46 <pzp> Is there a way to cause QuickCheck to fail a test after a timeout of 1 second?
06:14:52 <phaazon> but with an annhilator only
06:14:57 <phaazon> Iâ€™m sure that has a name
06:15:00 <ertes-w> phaazon: what lynn said
06:15:01 <phaazon> since I saw it a few weeks ago :(
06:15:03 <pzp> I'm trying to see what the bad input is, but I can't if the tests don't finish running
06:15:13 <phaazon> oh
06:15:16 <phaazon> null semigroup
06:15:25 <phaazon> I donâ€™t recall that, but, ok, thanks
06:15:38 <lynn> oh wait a null semigroup is something... sillier
06:15:42 <lynn> haha
06:15:52 <ertes-w> phaazon: does the annihilator happen to be the identity of another semigroup?
06:16:04 <lynn> check out that exciting cayley table
06:16:28 <phaazon> ertes-w: no itâ€™s not
06:16:37 <phaazon> itâ€™s (const zero)
06:16:42 <phaazon> if you want to see it as a function.
06:18:15 <knupfer> any news on linear types
06:18:23 <nohTo> phaazon: It doesn't seem to have an agreed upon name. Semigroup with zero, maybe?
06:18:37 <phaazon> nohTo: I saw one :(
06:18:40 <lynn> https://www.reddit.com/r/haskellquestions/comments/33tncq/semigroup_with_absorbing_element/
06:19:20 <nohTo> phaazon: Are you sure it wasn't (N, +, *, 0, 1)?
06:19:27 <phaazon> thatâ€™s a ring
06:19:34 <phaazon> no
06:19:35 <lyxia> knupfer: https://www.reddit.com/r/haskell/comments/791qy7/linear_haskell_practical_linearity_in_a/ ?
06:19:36 <phaazon> it wasnâ€™t that
06:19:59 <pzp> Alternatively, it would be useful if verboseCheck printed out the inputs *before* running the test. Anyway to get that behavior?
06:20:00 <knupfer> lyxia: thanks
06:23:07 <ertes-w> phaazon: no, i mean: can you find a monoid where the zero is the identity?  because then it's a semiring
06:23:19 <ertes-w> (if one of the monoids distributes over the other)
06:23:28 <phaazon> where the zero is the identity?
06:23:35 <phaazon> (N, +, 0) ? :â€“â€“â€“â€™)
06:23:41 <ertes-w> phaazon: (â„•, +, *)
06:23:43 <phaazon> itâ€™s a monoid and 0 acts as neutral
06:23:53 <ertes-w> 0 is the identity for (+) and the annihilator for (*)
06:23:54 <phaazon> ertes-w: thatâ€™s not a monoid
06:23:58 <ertes-w> and 1 is the identity of (*)
06:24:03 <ertes-w> it's two monoids
06:24:05 <phaazon> yes.
06:24:08 <phaazon> so you lied.
06:24:12 <phaazon> so youâ€™re gonna burn in hell.
06:24:12 <phaazon> :D
06:24:14 <phaazon> <3
06:24:14 <ertes-w> why did i lie?
06:24:24 <phaazon> you said a monoid!
06:24:28 <phaazon> not two! :P
06:24:44 <ertes-w> alright then
06:27:54 <ertes-w> quchen: hmm, i've been trying to find simon marlow's work on that, but with little success =/
06:28:19 <ertes-w> quchen: do you have a reference?
06:28:51 <ertes-w> i found an unboxed-ref package, but i have never heard of the author, so i'd need to audit and benchmark it first
06:29:36 <ertes-w> unboxed-ref does seem to do exactly what i need
06:29:43 <cocreature> ertes-w: I think quchen is referring to the mutable constructor fields proposal https://github.com/simonmar/ghc-proposals/blob/mutable-fields/proposals/0000-mutable-fields.rst
06:31:24 <ertes-w> ahâ€¦  that's not quite what i need
06:31:42 <ertes-w> although it would be nice to have that as well
06:33:46 <Psybur> ertes-w, so your version of the alternator actually produces the same output as mine on an infinite list
06:34:04 <Psybur> > foldr (\x go -> maybe (go (Just x)) (\y -> x : y : go Nothing)) F.toList [0,1,2] Nothing
06:34:07 <ertes-w> Psybur: yep
06:34:07 <lambdabot>  [1,0,2]
06:34:29 <Psybur> > take 3 $ foldr (\x go -> maybe (go (Just x)) (\y -> x : y : go Nothing)) F.toList [0..] Nothing
06:34:34 <lambdabot>  [1,0,3]
06:34:58 <quchen> ertes-w: My reference is talking to him :-/
06:35:01 <quchen> â€¦one year ago
06:35:11 <ertes-w> ah, ok
06:47:08 <Psybur> ertes-w, thats another mind blowing moment. F.toList Nothing :D
06:47:22 <royal_screwup21> what's a simple example that demonstrates the difference between foldl and foldr?
06:48:38 <quchen> > foldr const 1 [2..]
06:48:43 <lambdabot>  2
06:48:46 <int-e> :t foldl (:)
06:48:49 <lambdabot> error:
06:48:49 <lambdabot>     â€¢ Occurs check: cannot construct the infinite type: a ~ [a]
06:48:49 <lambdabot>       Expected type: [a] -> [a] -> [a]
06:48:50 <int-e> :t foldr (:)
06:48:53 <lambdabot> Foldable t => [a] -> t a -> [a]
06:48:54 <int-e> :-P
06:49:10 <Psybur> > foldr f z [a,b,c]
06:49:15 <lambdabot>  f a (f b (f c z))
06:49:17 <Psybur> > foldl f z [a,b,c]
06:49:21 <lambdabot>  f (f (f z a) b) c
06:49:24 <Psybur> royal_screwup21, ^
06:49:27 <ertes-w> :t foldr (const . Just) Nothing
06:49:30 <lambdabot> Foldable t => t a -> Maybe a
06:50:16 <quchen> royal_screwup21: foldl is arguably Haskellâ€™s for-loop; foldr is the canonical way of consuming a list element by element. foldl can be implemented via foldr (but not the other way round).
06:50:52 <ertes-w> i'd say foldr is haskell's for-loop
06:50:59 <ertes-w> foldl is too special
06:51:15 <Psybur> When is a lazy left fold useful?
06:51:25 <ertes-w> :t foldr (\x go -> print x >> go) (pure ())
06:51:29 <lambdabot> (Show a, Foldable t) => t a -> IO ()
06:52:01 <ertes-w> Psybur: when you construct something that is already fully evaluated
06:52:08 <ertes-w> 'reverse' is an example
06:52:11 <Psybur> > foldr (\x go -> print x >> go) (pure ()) [1,2,3]
06:52:13 <quchen> Psybur: Everyone who ever had to use a lazy left fold remembers that specific day. That should tell you something about how common it is.
06:52:16 <lambdabot>  <IO ()>
06:52:53 <ertes-w> and even then foldl' doesn't really hurt
06:52:55 <Psybur> > r <- foldr (\x go -> print x >> go) (pure ()) [1,2,3]
06:53:00 <lambdabot>  <no location info>: error:
06:53:00 <lambdabot>      not an expression: â€˜r <- foldr (\x go -> print x >> go) (pure ()) [1,2,3]â€™
06:53:03 <quchen> The syntax for foldl is Â»foldl â€¦ -- yes itâ€™s really foldl and not foldl' and here is the story about why that isÂ«
06:55:08 <ertes-w> > foldr (\x go xs -> go (x : xs)) id "abcde" []
06:55:13 <lambdabot>  "edcba"
06:56:33 <royal_screwup21> I still don't get why this - foldr (\x a -> [x]:a) [] [1,2,3] - is valid while the equilvalent foldl expression isn't. What's the first computations that happens with foldr? I'm trying to visualize it...
06:57:03 <lyxia> > foldl (\x a -> [x] : a) [] [1,2,3]
06:57:09 <lambdabot>  error:
06:57:09 <lambdabot>      â€¢ Occurs check: cannot construct the infinite type: a ~ [[a]]
06:57:09 <lambdabot>        Expected type: [a]
06:57:22 <lyxia> > foldl (\a x -> [x] : a) [] [1,2,3]
06:57:25 <lambdabot>  [[3],[2],[1]]
06:58:20 <lyxia> royal_screwup21: foldl is like foldr, but the function it takes as an argument is flipped
06:59:16 <royal_screwup21> ah
06:59:22 <ertes-w> and also itâ€¦  doesâ€¦  something else =)
06:59:55 <royal_screwup21> >  foldr (\x a -> [x]:a) [] [1,2,3]
06:59:58 <lambdabot>  [[1],[2],[3]]
07:03:49 <Psybur> So ertes-w in your reverse foldr thing, in the first iteration we get: "e" id (unapplied) as arguments? And that creates: id ("e" : (unapplied)) ?
07:06:04 <Psybur> And the second iteration creates "d" (id ("e" : (unapplied))) (unapplied) as arguments? Which creates... ?
07:06:26 <Psybur> Or am I getting this wrong :D
07:06:47 <Psybur> Oh Im starting on the wrong end too huh?
07:07:42 <ertes-w> Psybur: foldr (\x go xs -> go (x : xs)) id [a,b,c] [] = (\x go xs -> go (x : xs)) a (foldr (\x go xs -> go (x : xs)) id [b,c]) [] = foldr (\x go xs -> go (x : xs)) id [b,c] [a]
07:08:11 <ertes-w> this is a stateful fold starting with the initial state [] and prepending element by element
07:10:11 <Psybur> @src foldr
07:10:11 <lambdabot> foldr f z []     = z
07:10:11 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
07:10:21 <Psybur> @src foldl
07:10:21 <lambdabot> foldl f z []     = z
07:10:22 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
07:10:48 <Psybur> I suppose actually remembering the source for foldx would help ;p
07:11:39 <Taneb> I'm using QuickCheck and I have a test that occassionally fails, and it writes "Randomized with seed 1741453704". How can I use that seed to replay the test
07:13:55 <lyxia> Taneb: quickCheckWith  and set the replay field in Args
07:14:28 <lyxia> I guess mkQCGen will get you the seed
07:15:36 <lyxia> Taneb: for a less hacky approach, maybe this helps https://hackage.haskell.org/package/quickcheck-with-counterexamples ?
07:18:39 <Taneb> lyxia: I couldn't seem to get quickCheckWithArgs working
07:19:23 <lyxia> :(
07:43:09 <Tehnix> Anyone here that uses nix that has `nix-shell -p arcanist` working? Failing for me to build the PHP dependency(???) and I'm off to a pretty shitty start on nix so far -.-
07:44:05 <Taneb> Tehnix: might have better luck asking in #nixos
07:45:50 <quchen> Tehnix: Works here. Did you update your nix sources?
07:45:55 <Tehnix> Taneb: Yeah, thought I'd give it a shot here though since it was recommended for ghc PR
07:45:59 <quchen> nix-channel --update
07:46:24 <shapr> Any critiques on this three line run length encoding solution? http://lpaste.net/359570
07:47:43 <quchen> shapr: Yes, itâ€™s too long
07:47:44 <quchen> > let rle = map (\x -> (length x, head x)) . group in rle "hellloo"
07:47:49 <lambdabot>  [(1,'h'),(1,'e'),(3,'l'),(2,'o')]
07:48:14 <quchen> shapr: And it maps twice over the input (gstring)
07:48:21 <shapr> quchen: how would you turn that into the result string "h1e1l3o2" ?
07:48:34 <shapr> quchen: yeah, your approach is better
07:49:13 <quchen> > let rle = concatMap (\x -> head x : show (length x)) . group in rle "hellloo" -- shapr
07:49:18 <lambdabot>  "h1e1l3o2"
07:49:48 <quchen> Note that head is safe here because group never returns empty lists
07:49:48 <shapr> quchen: much nicer
07:50:01 <shapr> quchen: thanks!
07:50:11 <quchen> Are you interviewing for a Haskell position?
07:50:14 <Taneb> let rle = group >=> ((:) <$> head <*> (show . length)) in rle "hellloo"
07:50:22 <Taneb> > let rle = group >=> ((:) <$> head <*> (show . length)) in rle "hellloo"
07:50:28 <lambdabot>  mueval-core: Time limit exceeded
07:51:40 <Taneb> > let rle = group >=> (:) <$> head <*> show . length in rle "hellloo"
07:51:44 <lambdabot>  "h1e1l3o2"
07:57:16 -etorreborre(~etorrebor@x5ce68f05.dyn.telefonica.de)- Quick question for @ekmett, is this a valid Alt instance for MonadError? https://gist.github.com/etorreborre/3adef4b5a7a96bc07a0fcb1d965f2b94. Am I missing something, somewhere?
07:58:21 <htse> is there a difference between ^ and ** or is it just like || and or ?
07:58:43 -etorreborre(~etorrebor@x5ce68f05.dyn.telefonica.de)- Quick question for Edward Kmett, is this a valid Alt instance for MonadError? https://gist.github.com/etorreborre/3adef4b5a7a96bc07a0fcb1d965f2b94. Am I missing something?
07:59:28 <sphinxo> htse: https://wiki.haskell.org/Power_function
07:59:56 <htse> oh ** accepts floats
08:00:52 <sphinxo> yeah htse, the types: https://stackoverflow.com/a/6400628
08:02:19 <Psybur> ertes-w, how long did it take you to be able to see a foldr and see this: (\x go c1 c2 -> c1 x (go c2 c1)) 0 ((\x go c1 c2 -> c1 x (go c2 c1)) 1 mempty) (:) ((:) . (+1)) and then also "just get it" heh
08:02:52 -etorreborre(~etorrebor@45.56.149.45)- Quick question for @ekmett, is this a valid Alt instance for MonadError? gist.github.com/etorreborre/3adef4b5a7a96bc07a0fcb1d965f2b94. Am I missing something?
08:03:23 <MrSkeltal> huh
08:03:27 <lyxia> How do you end up talking via Notice
08:03:52 <ertes-w> Psybur: hard to measureâ€¦  i'd have to say months, but that includes also the overall experience of learning haskell
08:05:03 <etorreborre_> I am trying to ask a question but I have been banned from the channel because I was apparently sending spam. Is that a known Freenode bug?
08:05:21 <etorreborre_> I posted a link to a github gist, is that the reason?
08:05:33 <MrSkeltal> it sounds like your client is bugged or you're not using it appropriately
08:06:13 <etorreborre_> I've had this with both LimeChat and the web interface (where I am now)
08:06:20 <MrSkeltal> well
08:06:23 <MrSkeltal> you sent channel notices
08:06:46 <MrSkeltal> those are frowned upon because many clients tend to alert on these
08:07:31 <etorreborre_> I am definitely new to IRC :-), a notice is like a message marked as "important"?
08:07:47 <MrSkeltal> not....really
08:07:53 <MrSkeltal> just don't use notices
08:10:10 <etorreborre_> my question is for Edward Kmett (or whoever has an opinion): is this a valid Alt instance for MonadError? gist.github.com/etorreborre/3adef4b5a7a96bc07a0fcb1d965f2b94. Am I missing something?
08:12:37 <etorreborre> ok I understand I indeed sent a notice by pressing ctrl+enter in limechat, thanks MrSkeltal
08:12:40 <MrSkeltal> etorreborre_, it seems to associate but you can't really write than as an instance
08:12:46 <cocreature> etorreborre: since MonadError has no laws but Alternative has laws, itâ€™s not valid
08:13:00 <MrSkeltal> that*
08:13:21 <cocreature> oh maybe I didnâ€™t look closely enough at it
08:14:22 <etorreborre> maybe I need to quickcheck the laws but the Alt laws seems to be ok to me
08:18:02 <etorreborre> my intention is to be able to define: f1 :: (MonadError e, Semigroup e) -> m a; f2 :: MonadError e -> m a; f2 :: MonadError e -> m a; f1 = f2 <!> f3
08:18:15 <cocreature> assuming I didnâ€™t screw up too badly what you need to prove is http://lpaste.net/359573 and I donâ€™t see how that could work without any laws about throwError and catchError
08:22:37 <etorreborre> oh I am actually suprised to see that there are no laws for catchError/throwError. I was expecting for example: catchError ma throwError = ma
08:24:22 <lyxia> I suspect there's a counterexample with State
08:26:27 <lyxia> ... maybe not
08:27:45 <etorreborre> that would be a counterexample with something like EitherT e (State s) a?
08:28:53 <lyxia> That's what I thought earlier yes.
08:31:20 <ertes-w> {-# NOINLINE x, y #-}(x, y) <- unsafePerformIO
08:31:25 <ertes-w> {-# NOINLINE x, y #-}
08:31:25 <etorreborre> or maybe a less controversial law would be: catchError (throwError e) f = f e. If catchError doesn't do that I don't see what it's good for :-)
08:31:29 <ertes-w> (x, y) <- unsafePerformIO â€¦  -- is this safe?
08:31:52 <ertes-w> or should i create them separately?
08:31:56 <lyxia> ertes-w: is this even allowed
08:32:09 <ertes-w> err
08:32:12 <ertes-w> s/->/=/
08:33:20 <ertes-w> xy@(x, y) = unsafePerformIO â€¦  -- or should i do this and NOINLINE xy instead?
08:33:32 <ertes-w> hmm, noâ€¦  that doesn't really make sense
08:34:03 <ertes-w> xy = unsafePerformIO â€¦; x = fst xy; y = snd xy;  {-# NOINLINE xy #-}
08:34:04 <ertes-w> this might work
08:34:44 <etorreborre> on the other hand I wonder how to specify that catch should not trigger the handler if m a "doesn't throw"
08:39:56 <etorreborre> maybe this: let ea = catchError (Right <$> ma) (pure . Left) in catchError ea undefined = ea
08:41:36 <etorreborre> edwardk what do you think?
08:41:39 <lyxia> To avoid undefined you can use a universal quantification. "for all k :: the right type, catchError ma k = ma"
08:42:03 <etorreborre> oh cool
08:45:44 <etorreborre> I don't think that brings me close to proving what cocreature pasted though
08:53:26 <lyxia> It helps if you can commute 'catchError's: catchError (catchError m k2) k1 = catchError m (\e -> catchError (k2 e) k1)   dunno how general that is
08:56:48 <Ero> hey dudes
08:57:47 <etorreborre> right that seems to be the key to proving the Alt laws. I also don't know if it is reasonable to ask this from catchError in all cases
08:59:18 <etorreborre> it "seems" reasonable. How would you go about making this a law? Take all the existing instances and see what breaks and what doesn't?
09:00:05 <lyxia> etorreborre: yes
09:00:49 <Ero> whats the word that identifies binary functions that operate on a single type from binary functions that operate on seperate types?
09:01:00 <Ero> is it... endomorphic?
09:01:21 <Ero> mono...
09:01:53 <lyxia> I'm not sure there's a general word for that
09:02:04 <Ero> hey lyxia :D and ok, thx
09:02:47 <etorreborre> that's what I feared, something like 10 properties to check. Hopefully I don't have to test both strict and lazy state?
09:04:04 <lyxia> Ero: I've seen "internal binary operation" vs "external binary operation" before, but I don't know whether that will suit whatever you are doing.
09:04:49 <lyxia> etorreborre: Indeed, it's better not to worry about laziness at first
09:05:15 <drdo> Ero: You could always call it "algebraic"
09:05:32 <Ero> algebraic it is
09:05:51 <etorreborre> ok, that looks like a good week-end project, thanks for the help
09:05:55 <drdo> I just made that up, never seen that use in any standard way :P
09:05:58 <drdo> *used
09:06:01 <Ero> i'm practising my vocab so that when i meet other nerds in real life i dont lose face lol
09:07:07 <Ero> so far i know that a monad is just a monoid in the category of endofunctors but that seems to be the only thing i can remember? Must be because its easier than the rest
09:08:45 <lyxia> for some definition of easy... :D
09:08:59 <Ero> there exists!
09:09:58 <Ero> is it possible to define instances of typeclasses locally to a function, say in a where clause, and if not, is there an inherant reason why this can't isn't done?
09:10:15 <Ero> i want to define throw-away monoids
09:10:26 <lyxia> nope
09:10:43 <lyxia> you can look at reflection if you absolutely need it
09:11:09 <Ero> i know just enough about reflection to find it scary
09:12:07 <lyxia> Ero: Consider Set from containers. If you build a Set using one local Ord instance, and you use it using another, then everything explodes.
09:13:19 <Ero> but wouldn't the point of me defining it locally be that i only intend to use it locally?
09:14:41 <mizu_no_oto> Ero: A binary function of type `a -> a -> a` is a magma
09:14:45 <Ero> i think i have missed your point
09:14:53 <Ero> thanks mizu_no_oto 
09:15:37 <mnoonan> Ero: you could imagine defining function-local instances as an extension of defining function-local types, but there are complications. you wouldn't want to let a locally-defined type escape the function scope, for one thing. ezyang mentions other issues here: https://www.reddit.com/r/haskell/comments/4k84go/data_declarations_in_where_statements/d3dkljo/
09:16:01 <mizu_no_oto> https://en.wikipedia.org/wiki/Magma_(algebra)
09:16:18 <mizu_no_oto> Not the most common term, though
09:17:06 <Ero> oh cool post, thanks mnoonan 
09:19:03 <jle`> Ero: what if your function returns the set as a result?
09:20:37 <mizu_no_oto> Ero: the most common technique is creating a newtype, then defining the instance on the newtype
09:22:01 <Ero> aah i see jle` . Yes it makes sense now
09:22:20 <Ero> the rules for the typeclass would effectively escape its defined scope
09:23:12 <Ero> where as this wouldn't be a problem for anonymous functions because their behaviour is... well defined? everywhere
09:23:22 <Ero> (is that correct?)
09:25:46 <Ero> is it possible for a function in a hom set to be inhabited by bottom?
09:26:17 <Ero> wait i think i answered my own question
09:26:19 <Ero> nevermind
09:26:34 <Ero> i was being stupid for a second
09:28:42 <mizu_no_oto> Ero: the most common technique for 'local' typeclasses is defining the instance on a newtype
09:28:45 <mizu_no_oto> > getFirst $ foldMap First [Nothing, Just 1, Just 3]
09:28:49 <lambdabot>  Just 1
09:29:19 <mizu_no_oto> > getLast $ foldMap Last [Nothing, Just 1, Just 3, Nothing]
09:29:24 <lambdabot>  Just 3
09:31:31 <liste> > ala Sum foldMap [1,2,3] -- lens has some nice tools for working with newtype wrappers
09:31:34 <lambdabot>  6
09:31:40 <liste> > ala Product foldMap [1,2,3]
09:31:42 <lambdabot>  6
09:37:21 <mnoonan> liste, perhaps not the best example case :)
09:37:29 <liste> mnoonan: yeah :D
09:37:31 <mizu_no_oto> Ero: Also, if you want to know more about the reflection thing, edwardk talked about it briefly in https://youtu.be/hIZxTQP1ifo?t=4977
09:38:31 <mizu_no_oto> Ero: also, just so you know, "A monad is a monoid" isn't talking about the same kind of monoid as Data.Monoid
09:39:46 <mizu_no_oto> A Data.Monoid is just a monoid [object] in the [monoidal] category Set
09:40:32 <mizu_no_oto> https://en.wikipedia.org/wiki/Monoid_(category_theory)
09:41:45 <edwardk> i work through the monad is a monoid in the category of endofunctors at the start of https://www.youtube.com/watch?v=cB8DapKQz-I when using it to motivate day convolution, applicatives and their contravariant cousins
09:43:28 <Ero> mizu_no_oto its not? are there other definitions for monoid?
09:44:30 <Ero> when i grow up i'm going to be an edwardk
09:44:37 <mizu_no_oto> Data.Monoid is monoids a la abstract algebra.  There's also monoids a la category theory.
09:45:08 <mizu_no_oto> Where monoids a la category theory generalize monoids a la abstract algebra
09:51:22 <gleber_> Do type classes have a fitting counterpart in category theory?
09:51:23 <a6a3uh> if I have computation of type WriterT w (ReaderT r m). Can I run it inside computation that returns something like StateT s (WriterT w (ReaderT r m))? Saving contexts for Writer, Reader and m?
09:52:13 <a6a3uh> without manually unwrapping all the stuff
09:56:14 <mizu_no_oto> gleber_: I think typeclasses were invented in Haskell to solve the practical problem of making ad hoc polymorphism less ad hoc
09:56:41 <mizu_no_oto> i.e. 'how do we overload + and == in a reasonable way'
09:57:29 <mizu_no_oto> And there's nothing particularly typeclassy anywhere in CT
09:59:12 <gleber_> mizu_no_oto: that was also my impression and based on my very limited CT knowledge I could not come up with any fitting concept from CT, thanks!
09:59:29 <ertes-w> and now that we have type classes i wish so much that we had plain, simple, stupid ad hoc polymorphism =)
09:59:30 <Psybur> Is there a version of take that returns a tuple of the constructed list and the last element of that list?
09:59:44 <ertes-w> (not instead of classes, but in addition)
10:00:04 <ertes-w> it would solve 99% of the named field overloading problem
10:00:18 <Psybur> Guess I can make a foldr that passes a boolean around, or uses one of ertes fancy stateful folds D;
10:00:59 <ertes-w> Psybur: you could splitAt at one index less, then pattern-match on the snd
10:01:23 <mizu_no_oto> Don't typeclasses and lens already solve 99% of the named field overloading problem?
10:01:27 <ertes-w> > foldr (const . Just) Nothing <$> splitAt 5 "abcdefg"
10:01:32 <lambdabot>  ("abcde",Just 'f')
10:01:38 <ertes-w> Psybur: ^ like that
10:02:07 <ertes-w> mizu_no_oto: imagine doing that without TH
10:02:17 <Psybur> > foldr (const . Just) Nothing <$> splitAt 6 "abcdefg"
10:02:20 <lambdabot>  ("abcdef",Just 'g')
10:05:09 <ertes-w> a6a3uh: just use runStateT/evalStateT/execStateT
10:06:23 <a6a3uh> thats what Im calling unwrapping stuff. I just was curious if those monads are so similar is there a way to run one inside another without this manual boilerplate code
10:06:55 <ertes-w> a6a3uh: what?  you don't have to unwrap anything
10:07:02 <ertes-w> :t runStateT
10:07:04 <lambdabot> StateT s m a -> s -> m (a, s)
10:07:14 <ertes-w> a6a3uh: now replace 'm' by your monad
10:09:00 <Ero> :t <$>
10:09:01 <a6a3uh> ertes-w: for example k1 ::  WriterT w (ReaderT r m) and k2 :: StateT s (WriterT w (ReaderT r m)). And I want to execute k1 inside do block of k2. not the way around
10:09:03 <lambdabot> error: parse error on input â€˜<$>â€™
10:09:30 <ertes-w> a6a3uh: ahâ€¦  use 'lift'
10:09:34 <romanix> a6a3uh, by unwrapping, do you mean using lift once? that's all the boilerplate i can see
10:09:44 <ertes-w> :t lift
10:09:47 <lambdabot> error:
10:09:47 <lambdabot>     Ambiguous occurrence â€˜liftâ€™
10:09:47 <lambdabot>     It could refer to either â€˜Control.Monad.Writer.liftâ€™,
10:09:50 <Psybur> ertes-w, I actually want 'abcdef','f'.
10:10:01 <ertes-w> :t Control.Monad.Trans.Class.lift
10:10:03 <lambdabot> (Monad m, MonadTrans t) => m a -> t m a
10:10:23 <Psybur> I want to avoid using "last" :D
10:10:29 <Ero> i got it
10:10:33 <ertes-w> a6a3uh: lift :: WriterT w (ReaderT r m) a -> StateT s (WriterT w (ReaderT r m)) a
10:10:54 <ertes-w> Psybur: that's why i said: splitAt one index less
10:11:22 <a6a3uh> ertes-w: yes! lift! Many thanks. Looks like I spend too much time with my laptop today...
10:11:37 <Psybur> > foldr (const . Just) Nothing <$> splitAt 5 "abcdefg"
10:11:43 <lambdabot>  ("abcde",Just 'f')
10:12:02 <Psybur> In that case I would want Just 'e'. Problem is I want the list to also have that element
10:12:14 <Psybur> Adding it back to the list would be inefficient wouldnt it
10:13:46 <ertes-w> > foldr (\x go n -> if n >= 1 then fmap (x:) (go (n - 1)) else (Just x, [x])) (const (Nothing, [])) "abcdefg" 5
10:13:49 <lambdabot>  (Just 'f',"abcdef")
10:13:53 <Ero> foldr (\l e -> (l ++ map e, e) (,) . take 5 "abcdef"
10:14:06 <ertes-w> Psybur: ^
10:14:11 <ertes-w> waitâ€¦
10:14:15 <Psybur> :D
10:14:21 <ertes-w> > snd $ foldr (\x go n -> if n >= 1 then fmap (x:) (go (n - 1)) else (Just x, [x])) (const (Nothing, [])) [0..] 5
10:14:26 <lambdabot>  [0,1,2,3,4,5]
10:14:30 <a6a3uh> ertes-w: btw . how then I can transform Reader context with function f? Something like zoom from lens? can it be applied for arbitrary nested monad transformer?
10:14:38 <ertes-w> > foldr (\x go n -> if n >= 1 then fmap (x:) (go (n - 1)) else (Just x, [x])) (const (Nothing, [])) [0..] 5
10:14:42 <lambdabot>  (Just 5,[0,1,2,3,4,5])
10:15:20 <ertes-w> Psybur: i'm not entirely sure if that's lazy enoughâ€¦  if you want to make sure, use this instead of fmap:  lazyFmapTuple f ~(x, y) = (x, f y)
10:16:05 <ertes-w> a6a3uh: for ReaderT you need 'magnify' instead of 'zoom'
10:17:46 <ertes-w> @src (a, b) _2
10:17:47 <lambdabot> Source not found. My mind is going. I can feel it.
10:17:53 <ertes-w> can you?
10:28:09 <a6a3uh> ertes-w: thank you. reading the docs on magnify. nether used it. only had experience once with zoom for transforming the state. will magnify find Reader or should it be pointed which layer of transformers it is?
10:34:02 <shapr> aw, quchen is offline
10:34:37 <shapr> @tell quchen soon to be grads are interviewing with us, I try to solve all the questions in Haskell ahead of time so I'm sure I understand them.
10:34:37 <lambdabot> Consider it noted.
11:00:18 <shiro`> HELLO
11:03:42 <Rembane> EHLO
11:10:41 <shapr> > let rle = group >=> ((:) <$> head <*> (show . length)) in rle "hellloo"
11:10:44 <lambdabot>  "h1e1l3o2"
11:10:52 * shapr thinks about that
11:10:58 <barrucadu> Fancy
11:11:26 <jle`> > let rle = group >=> ((:) <$> head <*> (show . length)) in rle "heeeeelllooooooooooooo"
11:11:31 <lambdabot>  "h1e5l3o13"
11:11:35 <shapr> barrucadu: credit to Taneb
11:11:49 <shapr> I was just wondering if I could make it applicative instead of monadic
11:11:50 <barrucadu> And there I was, about to share it in a channel which has Taneb
11:12:30 <pmade> Is there a channel for the Groundhog package?
11:12:33 <Cale> The Pipes library defines some type synonyms for Server and Client, but does anyone have any examples of actually writing values of those types?
11:12:40 <shapr> pmade: is that like the hedgehog package?
11:12:42 <monochrom> > let rle = group >=> ((:) <$> head <*> (show . length)) in rle "4111116668888888888888"
11:12:46 <lambdabot>  "411563813"
11:12:51 <monochrom> >:)
11:13:18 <barrucadu> Oh no
11:13:18 <jle`> >:(
11:13:30 * monochrom knows of an expanding sequence based on that
11:13:40 <Cale> pmade: I don't think there's a specific one, but I *might* be able to help. :)
11:13:48 <monochrom> > let rle = group >=> ((:) <$> head <*> (show . length)) in iterate rle "1"
11:13:51 <lambdabot>  ["1","11","12","1121","122111","112213","12221131","1123123111","12213111213...
11:13:53 <jle`> @let rle = group >=> ((:) <$> head <*> (show . length))
11:13:56 <lambdabot>  Defined.
11:14:34 <monochrom> It's also a favourite puzzle of the kind "what's the next number in this sequence?"
11:14:34 <jle`> > iterate rle "\""
11:14:37 <lambdabot>  ["\"","\"1","\"111","\"113","\"11231","\"112213111","\"11222113113","\"11223...
11:15:44 <jle`> > head . dropWhile (not . any (== '9')) $ iterate rle "1"
11:15:51 <lambdabot>  mueval-core: Time limit exceeded
11:15:59 <monochrom> Actually the one I know of is based on "1h5e" rather than "h1e5" but it's the same idea.
11:16:05 <jle`> > head . dropWhile (not . any (== '5')) $ iterate rle "1"
11:16:12 <lambdabot>  mueval-core: Time limit exceeded
11:16:18 <jle`> > head . dropWhile (not . any (== '4')) $ iterate rle "1"
11:16:24 <lambdabot>  mueval-core: Time limit exceeded
11:16:27 <jle`> am i doing this wrong
11:16:29 <pmade> Cale: well, I have a type that has a few DefaultKey fields.  I'd like a way to fetch all of the records those keys refer to so I can have a ToJSON instance that contains everything.  As of right now, the only way I can think of doing that is by having another type that has all the same fields, but with the `DefaultKey a` fields replaced with `a`.
11:16:32 <Tuplanolla> @let runLength = iso (fmap (length &&& head) . group) (concatMap (uncurry replicate))
11:16:34 <lambdabot>  Defined.
11:16:36 <jle`> > head . dropWhile (not . any (== '3')) $ iterate rle "1"
11:16:41 <lambdabot>  "112213"
11:16:50 <jle`> lambdabot timesout before it can find one with 4
11:16:55 <jle`> does it ever reach 4 ???
11:17:07 <fakenullie> @pf tupled' = cap >>= \a -> rev >>= \b -> return (a,b)
11:17:07 <lambdabot> Maybe you meant: pl bf
11:17:18 <Cale> pmade: I don't think I've ever defined a datatype which has DefaultKey a fields in it.
11:17:31 <jle`> > "hello" ^. runLength
11:17:37 <lambdabot>  [(1,'h'),(1,'e'),(2,'l'),(1,'o')]
11:17:50 <jle`> boo
11:18:02 <Cale> pmade: Oh, right, Groundhog doesn't have the Id type that we use here...
11:18:03 <Cale> :)
11:18:03 <shapr> Tuplanolla: is that the iso from lens?
11:18:10 <Tuplanolla> Yes, shapr.
11:18:19 <jle`> > over runLength tail "hhheelllllooooooooo"
11:18:23 <lambdabot>  "eelllllooooooooo"
11:18:24 <pmade> Cale: what are you using?
11:19:01 <jle`> > "hello" & runLength . _1 +~ 1
11:19:05 <lambdabot>  error:
11:19:05 <lambdabot>      â€¢ No instance for (Field1
11:19:05 <lambdabot>                           [(Int, Char)] [(Int, ())] Integer Integer)
11:19:13 <jle`> > "hello" & runLength . mapped . _1 +~ 1
11:19:16 <lambdabot>  "hheellloo"
11:19:43 <Cale> pmade: We use groundhog where I work, but there's a bunch of other internal stuff that we've piled on top. Anyway, it's not important. I see what you mean.
11:19:57 <monochrom> Probably no 4.
11:20:19 <Cale> pmade: I think generally we do have separate types for "what gets stored as a database row" vs. "the actual tree structure we wish the database could deal with"
11:20:30 <jle`> fakenullie: looks like just liftA2 (,) cap rev
11:20:36 <jle`> or (,) <$> cap <*> rev
11:20:52 <pmade> Cale: That's what I was afraid of.  Thanks.
11:21:00 <fakenullie> jle`: yeah
11:21:28 <jle`> i'm still wondering if the iterate rle "1" will ever reach a string with 4 in it
11:21:30 <Cale> pmade: If you *really* wanted to, you could parameterise your type over a choice of type function, and use Identity vs. DefaultKey
11:21:36 <jle`> if so, that would be a huge jump
11:21:41 <Cale> pmade: But that's obviously awful.
11:22:01 <pmade> Cale: I tried that.  GHC doesn
11:22:04 <monochrom> I think I can prove that there cannot be a 4.
11:22:27 <jle`> > length . takeWhile (not . any (== 1)) $ iterate rle "1"
11:22:30 <lambdabot>  error:
11:22:30 <lambdabot>      â€¢ No instance for (Num Char) arising from the literal â€˜1â€™
11:22:30 <lambdabot>      â€¢ In the second argument of â€˜(==)â€™, namely â€˜1â€™
11:22:33 <jle`> > length . takeWhile (not . any (== '1')) $ iterate rle "1"
11:22:35 <pmade> GHC doesn't like it because DefaultKey is a type family with multiple type arguments
11:22:37 <lambdabot>  0
11:22:38 <jle`> > length . takeWhile (not . any (== '2')) $ iterate rle "1"
11:22:41 <lambdabot>  2
11:22:42 <jle`> > length . takeWhile (not . any (== '3')) $ iterate rle "1"
11:22:45 <lambdabot>  5
11:22:53 <pmade> So, two types it is.
11:23:03 <jle`> > length . takeWhile (not . any (== '4')) $ iterate rle "1"   -- never happens?
11:23:03 <monochrom> Suppose you have "14" at some point for example. Then the predecessor had "1111". But then why was it not more simply "12"? Contradiction.
11:23:10 <lambdabot>  mueval-core: Time limit exceeded
11:23:25 <monochrom> Similarly if you have "24" or "34" etc.
11:24:33 <jle`> the 1111 might be straddling two different parts
11:24:35 <fakenullie> > rle "1"
11:24:38 <lambdabot>  "11"
11:24:55 <jle`> interesting series, though.  0, 2, 5, infinity
11:25:04 <monochrom> No, run-length encoding doesn't see two different parts.
11:25:13 <fakenullie> > take 10 $ iterate rle "1"
11:25:16 <lambdabot>  ["1","11","12","1121","122111","112213","12221131","1123123111","12213111213...
11:25:31 <monochrom> "1111"'s predecessor would be "11". But rle on that would be "12".
11:27:00 <jle`> i'm trying to construct 1111 somehow without using '11'
11:27:05 <jle`> but it is difficult.
11:27:16 <jle`> > rle "21"
11:27:21 <lambdabot>  "2111"
11:27:22 <monochrom> OK, maybe you want eleven 1's to escape my argument.
11:28:00 <jle`> > rle "211111111111"
11:28:03 <lambdabot>  "21111"
11:28:37 <Cale> Hmm, this is interesting. Pipes' Proxy doesn't seem to invert control as much as I'd expect it to somehow. If I have functions (b' -> a') and (a -> b), and want a component that forwards a request and then forwards the response to it via those functions, it's not obvious how to get a Proxy a' a b' b m () which does this.
11:28:52 <monochrom> But now you have the more challenging problem of causing "11111111111" to happen in the first place.
11:28:55 <Cale> (at least not obvious to me)
11:29:31 <Cale> Maybe I should just work with Pipe values, and transform those.
11:29:41 <fakenullie> > length . takeWhile (not . any (== '5')) $ iterate rle "1"
11:29:47 <lambdabot>  mueval-core: Time limit exceeded
11:31:34 <nshepperd> I think it's impossible to make a run of more than three this way
11:34:55 <dmwit> monochrom, jle`, fakenullie: You all are going to love https://web.archive.org/web/20061224154744/http://www.uam.es/personal_pdi/ciencias/omartin/Biochem.PDF
11:35:28 <fakenullie> kolakoski sequence
11:35:31 <monochrom> Aw, why would anyone use this for biochem and DNA
11:35:38 <dmwit> In this variant, you can't reach 4 (unless you start with one), but things go completely bonkers in this paper shortly after that proof.
11:35:53 <jle`> dmwit: thanks :)
11:35:54 <dmwit> monochrom: Nobody does, actually. I think you will be delighted by what they *actually* do.
11:36:13 <monochrom> Oh I see, it is math.
11:36:25 <fakenullie> right
11:36:45 <monochrom> "look-and-say biochem" means we're doing biochem on this sequence not on real DNA.
11:36:54 <nshepperd> any run size will become two runs of 1. "an". unless a = n, then it's a run of two. if the previous digit is different but appears n times also, that's a run of three
11:37:05 <monochrom> like "John Conway biology" >:)
11:37:51 <monochrom> Conway biology, STG chemistry, and darc physics.
11:37:54 <nshepperd> any longer run would require either the preceding or following digit to be the same as a, in which case it would be part of the original run
11:38:45 <tdammers> theoretical biology, just like theoretical physics
11:41:09 <Sornaensis> simple tagless g machine chemistry
11:41:52 <dsal> Coverage tool is telling me that 'otherwise' is always true.  :/
11:42:24 <Sornaensis> otherwise is defined as True
11:43:45 <c_wraith> there is literally a definite imported by Prelude that says otherwise = True
11:43:50 <c_wraith> *definition
11:44:20 <dsal> Yeah.  Just like... not very helpful to point that out in my coverage report.
11:45:14 <Hafydd> That's how you determine to stop using a coverage tool.
11:46:12 <dsal> ha
11:46:50 <dsal> I do enjoy the coverage game at times.  Doing an obligatory, "I guess I should cover this case since it's easy." found a pretty awful bug in my code last night.
11:47:36 <dsal> I had a thing that would work with a String or a Text.  I somehow did an incredibly bad job on the Text one.
12:13:51 <Psybur> ertes, is going through a list and building up a function, and then evaluating that function faster than just going through a list twice?
12:14:23 <Psybur> Cuz the first way is like your going through two lists of size n, one of elements and one of functions right :D
12:15:40 <Psybur> I suppose one really long function isnt quite like a list of functions I guess
12:16:41 <Psybur> I didnt get any speedup from passing around a list and its last element vs just passing the list and calling last in the receiver :D
12:16:52 <infandum> There is a library with a data structure and automatically derived Show. How can I have an "automatically derived" Read without editing that person's library?
12:17:07 <infandum> Is there an instance I can use that is "automatic"?
12:19:32 <liste> infandum: you can have standalone deriving statements with an extension
12:19:37 <liste> IIRC it was StandaloneDeriving
12:20:08 <infandum>  deriving instance (Read a) => Read (Type a)?
12:20:26 <liste> infandum: worth a try
12:21:24 <infandum> liste: Nice, it compiled. Thank you!
12:21:42 <liste> infandum: you're welcome!
12:23:22 <liste> note that it's an orphan then
12:27:27 <infandum> Is binding lazy? So if I never explicitely need a file, but I have file <- readFile "file", should file be evaluated?
12:28:53 <geekosaur> depends on the Monad. IO is strict --- but if that is in (or invoked from) e.g. an 'if' branch that does not get evaluated then it won;t be done
12:29:35 <geekosaur> if that is in code that speculatively opens a file but never actually uses the opened file, the file will still be opened
12:31:04 <infandum> ah, I see
12:32:44 <Liskni_si> infandum: you might also want to know that readFile uses unsafeInterleaveIO so the file is opened, but not necessarily read in its entirety
12:33:39 <geekosaur> yes. in fact not read at all, but it will be opnened and it will throw an IOException if it doesn't exist
12:33:55 <geekosaur> (unless you evaluate 'file' at some point, then it will read)
12:37:10 <infandum> That's only if it's opened but THEN not used, if the whole function is underneath an if statement, where that statement has no IO, then there is no issue, right?
12:39:29 <Psybur> infandum, wonder if you can figure out how to track file opening events in your operating system and try it out? :D
12:41:16 <geekosaur> you might show actual code. but I already answered that question...
12:49:15 * liste gets some weird'n'crazy LazyIO ideas
12:50:51 <rick-sanchez> Hello, is there some easy way to transform a tuple into a constructor/function? e.g. f (x,y,z) = T x y z ? it is a bit like curry, but for n-size tuples
12:54:47 <hpc> f = uncurry3 T?
12:54:51 <hpc> :t uncurry3
12:54:53 <lambdabot> error:
12:54:53 <lambdabot>     â€¢ Variable not in scope: uncurry3
12:54:53 <lambdabot>     â€¢ Perhaps you meant one of these:
12:54:59 <geekosaur> not generically, as tuples are not iterables (eveyr tuple is its own ad hoc type)
12:55:02 <hpc> maybe not?
12:56:05 <liste> why is there no uncurry3
12:58:18 <dsal> @hoogle uncurry3
12:58:19 <lambdabot> Data.Tuple.HT uncurry3 :: (a -> b -> c -> d) -> ((a, b, c) -> d)
12:58:19 <lambdabot> Data.Tuple.Lazy uncurry3 :: (a -> b -> c -> d) -> ((a, b, c) -> d)
12:58:19 <lambdabot> Data.Tuple.Strict uncurry3 :: (a -> b -> c -> d) -> ((a, b, c) -> d)
13:01:42 <rick-sanchez> in what hoogle is that? :o I searched in haskell.org hoogle but I didn't find
13:02:07 <cocreature> rick-sanchez: http://hoogle.haskell.org/?hoogle=uncurry3
13:02:51 <rick-sanchez> https://www.haskell.org/hoogle/?hoogle=uncurry3 mmm interesting, is it a different database?
13:03:45 <cocreature> hoogle.haskell.org indexes all of stackage
13:03:53 <cocreature> haskell.org/hoogle only has a very small set of packages
13:04:08 <cocreature> the type search is worse in some regards for hoogle.haskell.org but everything else is significantly better
13:04:29 <mauke> http://hayoo.fh-wedel.de/?query=uncurry3
13:05:47 <geekosaur> haskell.org/hoogle is hoogle 4 with an older database. hoogle.haskell.org is hoogle 5 alpha (type search known broken/deficient) with up to date database
13:06:03 <rick-sanchez> I see
13:06:04 <geekosaur> hoogle4 also has to be told explicitly which package database to search
13:06:39 <geekosaur> (its max database size is small so it can only search smallish package groups)
13:07:31 <rick-sanchez> Talking about curry, I guess that solution is only for tuples of 3 elements, and there is no solution (appart from exotic packages) to get curry4,5...
13:08:19 <liste> @hoogle uncurry4
13:08:20 <lambdabot> Text.XML.HXT.DOM.Util uncurry4 :: (a -> b -> c -> d -> e) -> (a, b, c, d) -> e
13:08:20 <lambdabot> Agda.Utils.Tuple uncurry4 :: (a -> b -> c -> d -> e) -> (a, b, c, d) -> e
13:08:20 <lambdabot> Data.Text.Titlecase.Internal uncurry4 :: (a -> b -> c -> d -> e) -> (a, b, c, d) -> e
13:08:26 <pikajude> you could of course use TH to generate them
13:10:54 <rick-sanchez> yes, I think the best is to generate them, it is not a good idea to add those dependencies just for one function
13:12:52 <fakenullie> do you need it for just one tuple size?
13:17:03 <rick-sanchez> I think a solution that works for n-size can be better
13:21:42 <nek0> hi folks. Has anyone of you ever used the ivory language (https://ivorylang.org)? I need to include a header, but I don't know how.
13:24:17 <rick-sanchez> https://hackage.haskell.org/package/tuple-0.3.0.2/docs/Data-Tuple-Curry.html#v:curryN that can be enough 
13:24:23 <rlgod> hey guys
13:25:08 <rlgod> can someone help me with this? https://pastebin.com/GR41q2LH
13:25:16 <fishythefish> nek0: based on the hello world example at https://ivorylang.org/ivory-introduction.html, you don't include headers; you just import the functions you need from them
13:25:21 <rlgod> im trying to run it on repl.it
13:25:48 <fakenullie> when does the need for huge tuples arise?
13:25:55 <liste> rlgod: then why don't you paste the repl.it ?
13:26:05 <rlgod> it doesnt work hahaha
13:26:07 <liste> link
13:26:13 <rlgod> parse error (possibly incorrect indentation or mismatched brackets)
13:26:21 <liste> you can get a link even if it doesn't work
13:26:21 <nek0> fishythefish: yes, I understood it so far, but compilation fails, because a header requires another header to be loaded first.
13:26:31 <rlgod> https://repl.it/NVvK/0
13:26:40 <fakenullie> this is broken
13:26:53 <liste> rlgod: you're missing a do
13:27:18 <rlgod> like "let plusminzero array = do "
13:27:43 <rlgod> ?
13:27:43 <liste> rlgod: yes, for starters. there's plenty of other mistakes too
13:28:01 <liste> rlgod: secondly, top-level definitions don't have "let"
13:28:08 <liste> so just plusminuszero array = ...
13:29:13 <rlgod> thought i had to do it because of the interpreter
13:29:14 <cocreature> there is also a missing let before total, missing parentheses in the calls to putStrLn, typeerrors since you canâ€™t use / on Int, a syntax error in [1...3] (you need to use [1..3])
13:29:38 <liste> rlgod: the left-side file is just a regular Haskell file
13:29:46 <liste> rlgod: you only need the let for ghci
13:29:52 <liste> on the right side
13:30:52 <rlgod> oh i got it
13:31:18 <Psybur> @src take
13:31:19 <lambdabot> take n _      | n <= 0 = []
13:31:19 <lambdabot> take _ []              = []
13:31:19 <lambdabot> take n (x:xs)          = x : take (n-1) xs
13:31:29 <fishythefish> rlgod: there are a few problems; you probably want something like https://repl.it/NVvK/1
13:31:56 <rlgod> wow
13:32:04 <rlgod> ill look into your code and learn from it
13:32:07 <rlgod> thanks guys
13:32:11 <rlgod> <3
13:32:13 <rlgod> much love
13:32:50 <fakenullie> you may want to get a book
13:34:30 <liste> rlgod: if you don't understand the type signature of divide in fishythefish's version yet, you can replace it with "divide :: Int -> Int -> Double"
13:35:22 <fishythefish> the tl;dr is that (/) works for Float and Double. We can't divide two Ints directly, so we convert them first
13:35:55 <rlgod> i dont pretend using haskell very often it was just out of curiosity
13:36:20 <rlgod> but Ill look more into it after work
13:38:16 <fishythefish> nek0: hmm, seems like that's the header's fault for not including its dependency
14:04:30 <royal_screwup21> I'm trying to pack consecutive duplicates into a sublist. Like so: [1, 2, 2, 3] -> [ [1], [2.2], 3] ]. Here
14:04:46 <royal_screwup21> Here's what I tried: https://thepasteb.in/p/JZhpE6NP5o7ig
14:05:33 <royal_screwup21> but the compiler spew out an error: https://thepasteb.in/p/Q1hBj20m2XYC8
14:06:16 <fishythefish> > group [1, 2, 2, 3]
14:06:20 <lambdabot>  [[1],[2,2],[3]]
14:06:35 <fishythefish> or is this an exercise to reimplement group?
14:06:42 <royal_screwup21> it's an exercise haha
14:07:05 <royal_screwup21> I can't make sense of the error
14:07:10 <fishythefish> you have a few problems
14:07:18 <fishythefish> for one, you need to spell your function name consistently
14:07:39 <fishythefish> to prepend x to an empty list, the syntax is either 'x : []' or '[x]', but not '[x] : []'
14:08:30 <fishythefish> head is a function, so x `elem` head doesn't make sense
14:09:11 <fishythefish> if you insist on using that where binding to deconstruct the list as head:tail, then head is a single element, so that usage still doesn't make sense
14:09:28 <fishythefish> and as before, [x] : acc doesn't make sense; you probably want x : acc
14:10:46 <royal_screwup21> say x= 3. I want to build a new list like so: [[3]]
14:10:58 <fishythefish> so to return to your error: in the definition of func [] x, you return [[x]], so the return type is [[a]]
14:11:17 <royal_screwup21> yup
14:11:29 <fishythefish> but in func acc x, you try to produce x : head : acc
14:11:56 <fishythefish> you need this to also have type [[a]], but x is a single element, not a list
14:13:23 <fishythefish> (disregard my previous assertions about consing [x] to the head of the list; it turns out *those* are the correct ones and line 5 is the error)
14:15:14 <royal_screwup21> (x:head):acc -- this compile successfully
14:16:39 <Denommus> gosh, just uninstalled everything haskell-related and installed stack-static in my Arch Linux box
14:16:43 <Denommus> MUUUUUCH easier
14:17:33 <fishythefish> royal_screwup21: let's step through the types of everything. Can you start by providing a type signature for func?
14:18:38 <royal_screwup21> so func takes a list and int x, and gives out [[x]]
14:19:05 <fishythefish> what kind of list? use haskell syntax to give a type signature
14:19:18 <royal_screwup21> func :: [t] -> t1 -> [[t1]]
14:19:32 <fishythefish> does that type make sense?
14:20:33 <royal_screwup21> in the context of the problem? I think it does...because I'm trying to build a new sublist for every different element that I hit with foldl
14:20:49 <fishythefish> why are t and t1 different?
14:21:38 <royal_screwup21> t could be a list, and t1 is always an Int
14:22:18 <fishythefish> then say Int, not t1 (although you could generalize from Int to a variable)
14:22:35 <fishythefish> if x :: Int, can acc have type [Char]?
14:26:27 <royal_screwup21> I'll just lay out my logic for this problem: so suppose I have list = [1,2,2,3]. I'm doing to a foldl over it so that [[1]] on the first iteration (?), then [ [2], [1] ] on the second iteration, then [ [2,2] [1]] on the third iteration, then finally [[3], [2,2], [1]]
14:26:50 <fishythefish> i understand your logic and i've already fixed your code in my own editor
14:26:55 <fishythefish> i'm trying to get you to understand what's happening
14:27:29 <fishythefish> if all you want is for your code to compile, then change x : head : acc to (x : head) : acc
14:28:13 <royal_screwup21> yup did that :) but apparently I'm missing missing a pattern because I'm getting " Non-exhaustive patterns in function func"
14:28:29 <fishythefish> did you see what i said about spelling?
14:29:52 <royal_screwup21> holy shit
14:30:31 <fishythefish> as far as ghc was concerned, you only defined the func [] x case. fun was some other unrelated function
14:33:09 <royal_screwup21> thanks! so I ran the module on [1, 2,2, 3] - and I got back [[3],[2,2],[2],[1]]. It makes sense, I know where I've gone wrong...I need to figure to how to cons the 2 to the head and NOT create another sublist out of that
14:33:54 <royal_screwup21> because my desired output is: [[3],[2,2],[1]]
14:36:41 <Psybur> > reverse $ group [1,2,2,3]
14:36:44 <lambdabot>  [[3],[2,2],[1]]
14:37:11 <royal_screwup21> eh, I'm trying to implement it from scratch as an exercise :)
14:37:22 <royal_screwup21> using foldl
14:37:57 <Psybur> > foldl (
14:37:59 <Psybur> ops
14:38:01 <lambdabot>  <hint>:1:8: error:
14:38:01 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
14:38:26 <Psybur> > foldl (\(g,xs) x -> 
14:38:30 <lambdabot>  <hint>:1:21: error:
14:38:30 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
14:38:46 <Psybur> my keyboard situation is whack at the momeny sorry
14:41:50 * geekosaur resembles that
14:41:58 <geekosaur> new keyboard arriving tomorrow though
14:42:13 <geekosaur> won't fix the typoes but will at least fix the dropouts
14:42:28 <ertes> Psybur: building up a function and then using it is just a conceptual notionâ€¦  if you actually evaluate a stateful fold by hand, you'll see that you're never actually "building" and then "evaluating" that functionâ€¦  it's rather just a symbolic manipulation process
14:43:06 <ertes> Psybur: in particular foldl' (yes, the strict one) can be written in terms of foldr using this exact approach
14:43:14 <Psybur> ertes, I see
14:44:34 <ertes> Psybur: at this point you should really just read my foldr tutorialâ€¦  i'm really repeating sections from that tutorial to you
14:44:40 <royal_screwup21> Is it even possible to do this with foldl?  Suppose I have list = [1,2,2,3]. I'm doing to a foldl over it so that I get [[1]] on the first iteration, then [ [2], [1] ] on the second iteration, then [ [2,2] [1]] on the third iteration, then finally [[3], [2,2], [1]]?  The way I see it, once you have [ [2], [1]], it's only possible to create [ [2,2],
14:44:40 <royal_screwup21> [2], [1]] on the next fold, not [[2,2], [1]]
14:44:50 <ertes> @where foldrtut
14:44:50 <lambdabot> http://ertes.eu/tutorial/foldr.html
14:44:52 <ertes> Psybur: ^
14:47:56 <ski> royal_screwup21 : seems possible
14:48:21 <ski> (i just did it, hence it seems possible)
14:48:24 <fishythefish> royal_screwup21: it's definitely possible. by the way, do you mean for the order of the output to be reversed? if not, use foldr
14:51:13 <royal_screwup21> fishythefish: hmm, no the order doesn't matter, I just need the correct sublists
14:52:37 <royal_screwup21> got it!!
14:52:47 <royal_screwup21> thanks y'all!
14:54:24 <Psybur> >  foldl (\(g,ys) x -> case g of [] -> ([x],ys); gs@(z:zs) -> if (z == x) then (x:gs,ys) else ([x],gs : ys)) ([],[]) [1,2,2,3,4,4,4,5]
14:54:27 <lambdabot>  ([5],[[4,4,4],[3],[2,2],[1]])
14:54:29 <Psybur> royal_screwup21, ^
14:55:18 * ski idly wonders whether this was homework
14:55:37 <durg> can i write hello world in haskell?
14:55:48 <ski> > "hello world"
14:55:52 <lambdabot>  "hello world"
14:56:11 <durg> > "Hello lambdabot"
14:56:14 <lambdabot>  "Hello lambdabot"
14:56:25 <durg> nice
14:57:02 <ski> > hello world
14:57:04 <lambdabot>  goodbye world
14:57:26 <durg> why?
14:58:07 <geekosaur> IO is "special"
14:58:49 <durg> can i write a for loop in the chat counting from 1 to 1000?
14:58:57 <geekosaur> (actually it's a trick: you are in effect purely manipulating I/O instructions that are run outside of Haskell, so we can do 'I/O' in a pure language)
14:59:15 <ski> > [1 .. 1000]
14:59:17 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
14:59:29 <erisco> is this your longstanding perspective geekosaur or a recent one?
14:59:41 <geekosaur> reasonably longstanding
14:59:53 <geekosaur> I keep trying to come up with better ways to convey it
15:00:11 <geekosaur> and trying to void the low level one that doesn't actually help understanding much (e.g. "IO inside")
15:00:15 <geekosaur> *avoid the
15:00:45 <durg> > [4 .. 5]
15:00:48 <fishythefish> that's always been my view of IO
15:00:49 <lambdabot>  [4,5]
15:00:52 <ski> do you mean the `data IO :: * -> * where HGetChar :: Handle -> IO Char; ...' approach ?
15:00:54 <geekosaur> and that form and the callbacks form are really the same thing if viewed from a sufficiently high level >.>
15:00:59 <fishythefish> is the alternative that IO is a special word that magically makes stuff impure?
15:01:03 <geekosaur> ski, roughly yes
15:01:13 <Tuplanolla> Here's one, geekosaur: `main` is a ball of yarn with one end of the string hanging out, which the runtime system then yanks.
15:01:46 <durg> can i count in step of 2?
15:01:48 <geekosaur> last time I tried to use a yarn analogy I got back 'I leave that to my grandmother' :p
15:01:56 <ski> > [4,6 .. 5]
15:01:56 <erisco> IO is a ball of timey... whimey... stuff
15:02:00 <lambdabot>  [4]
15:02:05 <Tuplanolla> Lazy evaluation is tensile stress traveling up the string inside the yarn.
15:02:09 <durg> > [1 .. 10 : 2]
15:02:12 <lambdabot>  error:
15:02:12 <lambdabot>      â€¢ No instance for (Enum [Integer]) arising from a use of â€˜e_11102â€™
15:02:12 <lambdabot>      â€¢ In the expression: e_11102
15:02:21 <geekosaur> > [1, 2 .. 10]
15:02:23 <lambdabot>  [1,2,3,4,5,6,7,8,9,10]
15:02:28 <geekosaur> > [1, 3 .. 10]
15:02:31 <lambdabot>  [1,3,5,7,9]
15:02:47 <durg> oh, it guesses
15:02:48 <geekosaur> (which turns into enumFromThenTo)
15:02:55 <geekosaur> guesses?
15:03:02 <durg> how to complete the numbers
15:03:09 <erisco> it is the only reasonable explanation of IO that I have come across, geekosaur
15:03:37 <geekosaur> it just uses the difference. it's not going to infer e.g. fibonacci
15:03:49 <geekosaur> > enumFromThenTo 1 3 10
15:03:53 <lambdabot>  [1,3,5,7,9]
15:03:55 <erisco> if we're talking specifically about the interaction between a system and its environment
15:04:06 <erisco> versus, say, what we might call side effects within the system itself
15:05:50 <geekosaur> also the [ .. ] syntax isn't general; it only supports specific forms which turn into specific Enum member functions
15:06:10 <erisco> and it simply stems from the fact that what the system has domain over is part of the system
15:06:38 <erisco> so, any delineation is going to be made on what the system can not control, can not assure
15:07:14 <Tuplanolla> > [1 â€¥ end]
15:07:16 <lambdabot>  [42]
15:11:29 <erisco> in such a reality, the best the system can do is express its wishes by output and wait for fulfillment by input
15:15:37 <dsal> Hmm...  So what does .. do?
15:15:38 <dsal> > ['a', 'c' .. 'z']
15:15:42 <lambdabot>  "acegikmoqsuwy"
15:16:00 <geekosaur> the [x, y, .. z] form translates to enumFromThenTo x y z
15:16:15 <dsal> Oh.  I remember seeing that function.
15:17:02 <dsal> Oh cool, and I can decide what that means in Enum.
15:17:19 <ertes> > ['a', 'c' ..]
15:17:21 <lambdabot>  "acegikmoqsuwy{}\DEL\129\131\133\135\137\139\141\143\145\147\149\151\153\155...
15:17:41 <geekosaur> right, but other things that use it might break if you don't do what they expect
15:19:05 <erisco> "wishes" may be too loaded of a word... I question whether ascribing intent to IO is wise
15:20:41 <monochrom> Oh generally anthropomorphizing the computer is unwise.
15:21:08 <dsal> Mine gets super pissed when I do that.
15:21:13 <monochrom> hehe
15:21:18 <ertes> @src xyz
15:21:18 <lambdabot> Source not found. Just what do you think you're doing Dave?
15:21:28 <ertes> you mean like that?
15:21:39 <erisco> it can be difficult to scrub all the humanity out of our language when describing something
15:23:16 <erisco> what I mean is that we are creating a program with intent, but it shouldn't then be said that the program itself has intentions
15:26:05 <erisco> I mean that in a less lofty way than it may sound
15:27:41 <erisco> it could make a difference in how you create the program, if you do not perceive some IO action like "open file" to be the intention of opening a file
15:28:55 <erisco> that's the programmer's intention, and that's the bridge they're imagining between the IO action and the file handle they want, but this can fool you into missing the other possibilities
15:30:15 <erisco> when an IO action becomes just a request, a suggestion, and input comes whenever and however, that's a more troublesome but more accurate picture
15:31:35 <Zemyla> How is the unboxed type (# a #) represented at runtime? Because it seems you can make sure that a function which returns a (# a #) is evaluated by unboxing the tuple, without necessarily evaluating the single value inside the tuple.
15:32:58 <erisco> well, "request" and "suggestion" are loaded too, heh... hard to let go of!
15:33:30 <erisco> outputs are making your own noises and inputs are listening to other's noises
15:34:21 <geekosaur> Zemyla, it's just a raw machine word
15:34:25 <geekosaur> no box
15:34:48 <geekosaur> well. it's a raw whatever a is. a is usually itself an unboxed type like Word#
15:35:10 <geekosaur> and (# a, a #) is two of them side by side, still with no box
15:38:06 <srpx> Î»-calculus + forall = extremely complete language with a dependent type system generalizes any type system you can think of
15:38:39 <srpx> is there any answer to my question of: "interaction combinators + ???? = extremely complete language with a type system that does it all"?
15:39:02 <srpx> I know some of you might have thought about this so I wonder if any progress was made
15:40:23 <Zemyla> geekosaur: So how is it that, when it's used in indexArray#, that it can read a value in an array and return a potential thunk that has no reference to the original array?
15:41:28 <geekosaur> it creates a new single-element array as a thunk
15:42:02 <geekosaur> er, no, I am misreading that
15:42:58 <geekosaur> basically if the specific element of type a is boxed and was not yet evaluated, it will still not be evaluated
15:43:31 <geekosaur> but if the type a is itslef unboxed then it was evaluated when put into the array
15:43:49 <geekosaur> what it avoids is wrapping it in an *extra* box
15:46:42 <iqubic> What are the best packages for haskell dev in Haskell
15:47:04 <MarcelineVQ> I'd probably but base as the best overall
15:47:06 <MarcelineVQ> *put
15:47:36 <iqubic> As in, base emacs?
15:47:45 <erisco> what is an "interaction combinator"?
15:47:57 <MarcelineVQ> as in base for ghc, was your question about emacs?
15:48:12 <erisco> and how does lambda calculus and a quantifier generalise any type system you can think of?
15:48:52 <erisco> even in the realm of dependent typing there are different systems
15:49:50 <geekosaur> I suspect it was as it was a bit redundant oherwise
15:50:54 <erisco> though I don't know the details of, I am pretty sure Godel showed that "doing it all" is illogical
15:51:12 <maerwald> Godel?
15:52:10 <geekosaur> your hypothetical type system that can generalize any imaginable type system is guaranteed to be either incomplete or inconsistent
15:52:41 <durg> what's better?
15:52:41 <geekosaur> (or possibly both)
15:53:59 <erisco> that's like... do you want to eat glass or put your head in a beehive
15:54:26 <maerwald> eat glass
15:54:34 <monochrom> No, I don't think incompleteness is that horrible.
15:54:36 <maerwald> depending on your stomach, you may survive
15:55:04 <monochrom> For what it's worth, paraconsistent logics also show that inconsistency is not all that horrible either.
15:57:34 <geekosaur> ^
15:57:53 <geekosaur> we'd be swinging from trees if this were a *real* problem
15:59:15 <erisco> no one goes out of their way to add incompleteness or inconsistency to a system
15:59:22 <monochrom> Wait, our ancestors did swing from trees. So was this a real problem to them? Or am I making the logical error of conflating "implies" with "implied by"? >:)
15:59:52 * geekosaur mansged to lose 'still' in that
16:00:02 <maerwald> monochrom: your ancestors were squirrles?
16:00:12 <dmwit> Do squirrels swing?
16:00:30 <geekosaur> only if they muyst
16:00:43 <dmwit> s/muyst/lust/
16:01:19 <erisco> ah, spring, when love is in the air and the squirrels are swinging in the trees
16:01:53 <monochrom> Oh IMO people outside paraconsistent logics do go out of their way to add incompleteness. They just euphemize it as "I'm just going out of my way to avoid inconsistency".
16:01:53 <maerwald> and people eat glass
16:06:41 <dmwit> I have a coworker that likes to learn languages. He always wants to know how to say "I can eat glass, it doesn't hurt me." first, because he figures if he says that people will assume he's crazy instead of bad at speaking their language.
16:09:01 <durg> sounds like an good idea
16:10:10 <durg> i actually never tried it, maybe it tastes better than i think
16:14:04 <fishythefish> maybe start with the sugar glass they use for stunts and work your way up
17:50:58 <n_blownapart> hi crestfallen here after about 50 pages of excellent simple haskell principles and prelude functions the book suddenly flies through this example. I really really do not understand computer books sometimes, how they decide on pedagogy : http://lpaste.net/359582   extremely frustrated:  any comments appreciated.
17:51:55 <Welkin> ...what?
17:52:34 <Welkin> you never specified what book you are talking about
17:52:41 <Welkin> or what your question is
17:53:34 <Welkin> if it's about the "haskell from first principles" book, ask bitemyapp since he is the one who wrote it
17:53:43 <Welkin> better yet, go ask in #haskell-beginners, which is the channel for that book
17:53:45 <MarcelineVQ> it's not
17:55:05 <Welkin> and yes, most examples from a textbook will suck
17:55:20 <sm> which book, "crucify_me" ?
17:55:36 <MarcelineVQ> shunting someone off to somewhere else probably isn't the best first step hehe :> crucify_me it is a pretty vague statement though. there's not much to say without people knowing what you know. Keep in mind that as you progress through any text the things you see next will always be challenging you, because the point of a text is to keep you learning
17:56:25 <crucify_me> yeah but it doesn't make sense at all. it went from an elegant example of finding prime numbers to that
17:56:26 <MarcelineVQ> If something seems out of nowhere and makes no sense, well work on it one line at a time, the next thing will probably be like that too
17:56:41 <Welkin> crucify_me: you still never told us what book it is, or what your question is
17:57:19 <crucify_me> Welkin: just giving vent. its a well-regarded book by prof. Hutton
17:57:45 <sm> @quote FAQ PIH
17:57:45 <lambdabot> FAQ says: What are some good books for learning haskell ? Haskell Tutorial And Cookbook (HTAC), Programming In Haskell (PIH), Haskell Programming From First Principles (HPFFP)
17:57:58 <crucify_me> I like how its written but find this like a "weeder" example
17:57:58 <sm> um.. yes, that one
17:58:03 <htse> why doesn't this eta reduction work in list comprehensions? I can do [even n | n<- [0..10]] but not [even | n <- [0..10]] like I'd expect :s
17:58:04 <Welkin> this isn't the place to vent
17:58:05 <crucify_me> sm its there PIH
17:58:13 <sm> and, what's the problem  ? :)
17:58:51 <Welkin> htse: I'd avoid list comprehensions insce they use a special syntax that isn't often the best way to express something
17:59:17 <Welkin> you can write the same function using fmap and filter
18:00:06 <Welkin> eta reduction doesn't make sense in list comprehensions, and I don't think there is any support for it because it is a special syntax
18:00:15 <Welkin> eta reduction works on regular functions
18:00:50 <Welkin> > filter even [1..10]
18:00:53 <lambdabot>  [2,4,6,8,10]
18:01:09 <Welkin> > filter (\a -> even a) [1..10]
18:01:13 <lambdabot>  [2,4,6,8,10]
18:01:50 <crucify_me> so people cannot give vent here -- understood
18:03:34 <htse> well the even is just a quick function I thought of, just thought it was weird that that language feature didn't reach there
18:03:53 <MarcelineVQ> people vent here all the time, but it's best to vent with the goal of working towards a soution. "man, this is lame I can't update the containers version I use when I'm using stack" and the someone else goes "did you try using extra-deps?"
18:04:06 <htse> but I'm probably not understanding *why* said feature is there
18:04:12 <MarcelineVQ> your vent is just too vague for people to work towards a solutuon for
18:04:16 <Welkin> htse: list comprehensions are rarely used
18:04:42 <Welkin> sometimes they can be useful, but I have never found them better than composing a few functions together
18:04:49 <crucify_me> MarcelineVQ: thanks, line by line I understand pretty much all of it, as I said I just don't understand how books are written, honestly don't see why they would do that.
18:05:10 <Welkin> I don't know why it exists either
18:05:17 <Welkin> it may be a historical artifact
18:05:43 <MarcelineVQ> what are you talkin, comprehensions are very common <_<
18:07:06 <htse> I cqn imqgine them being fast and useful for doing something to a list of strings, like capitalisation and such
18:08:33 <crucify_me> htse I like them because they were written - I believe - to resemble mathematical notation
18:09:35 <Welkin> I dislike list comprehensions
18:09:41 <Welkin> I never use them or find a use for them
18:09:50 <MarcelineVQ> I like them because they let you pattern match in useful concise ways
18:10:07 <MarcelineVQ> @let data Werb a b c = Geb a | Wub b | Bon
18:10:09 <lambdabot>  Defined.
18:10:15 <MarcelineVQ> > [x | Geb x <- [Geb 6, Wub "c", Geb 9]]
18:10:17 <lambdabot>  [6,9]
18:10:20 <Welkin> I have only seen one case for which they were slightly easier to read than an equivalent function composition
18:11:14 <crucify_me> true, I see how they work, but I don't find them particularly easy to read either
18:42:27 <dougger> What is the recommended way to store the result of an IO action for future use (thus avoiding more IO actions)? 
18:43:04 <dougger> The result would be called very frequently and from various parts of the code base. Once set, the data would be read only.
18:43:13 <Welkin> ReaderT
18:44:02 <Welkin> but that needs to be set up at the start of your program
18:44:21 <Welkin> if you need to set it after that point, use StateT
18:45:01 <dougger> Interesting. How early into the start of the program?
18:45:08 <Welkin> ReaderT is often used to store configuration information like database connection credentials, hostname, etc.
18:45:23 <dougger> Sounds like a perfect fit then
18:45:25 <Welkin> you'll see it set to a type alias such as App
18:46:14 <dougger> Sounds like it's exactly what I need. I'll get reading. Thanks.
20:14:59 <slack1256> the first one can be faster with optimizations because can be deforested and not actually allocating any list
20:25:35 <Lokathor> :t map (toEnum.fromEnum)
20:25:36 <lambdabot> (Enum a, Enum b) => [a] -> [b]
20:25:41 <Lokathor> the best op
20:25:46 <slack1256> On megaparsec, how do I put a custom error on a term?
20:26:24 <slack1256> Say my parser is `Parsec Int Text a` Is there any combinator like label to error Ints ?
20:28:15 <jkachmar> `label`/`(<?>)`?
20:28:58 <slack1256> those put Strings 
20:29:49 <Hijiri> if you're using ReaderT and IO, you could just use ReaderT with IORefs
20:36:53 <lyxia> slack1256: fancyFailure
20:39:58 <lyxia> somehow it seems like the only way. Perhaps noone is using that e parameter?
20:45:28 <slack1256> that is just what I thought
20:52:04 <Lokathor> @pl \vaos -> withArrayLen vaos glDeleteVertexArrays
20:52:04 <lambdabot> flip withArrayLen glDeleteVertexArrays
20:56:08 <MarcelineVQ> were you looking for (`withArrayLens` glDeleteVertexArrays)
20:59:44 <MarcelineVQ> is vaos the lens?
21:00:03 <Lokathor> it's the data
21:00:18 <Lokathor> but i forgot i have to unwrap it first since it's newtyped
21:00:26 <MarcelineVQ> ah okay then  vaos `withArrayLens` glDeleteVertexArrays  is pretty nautral
21:00:31 <Lokathor> (cursed newtypes and not _actually_ being a zero cost abstraction)
21:00:59 <Lokathor> http://lpaste.net/359586
21:01:31 <MarcelineVQ> oh Len
21:02:39 <Lokathor> just 8 more wrappers and i'll be able to draw a triangle!
21:02:42 <Lokathor> this is drudgey
21:11:42 <MarcelineVQ> Lokathor: http://lpaste.net/359586
21:12:40 <Lokathor> yeah that feels less clear :3
21:13:04 <MarcelineVQ> both would be clear with documentation above hehe
21:13:31 <mmaruseacph2> reminder that  the deadline for submitting contributions to the next edition of HCAR is next wednesday 
21:15:46 <Lokathor> HCAR?
21:15:53 <MarcelineVQ> haskell community activities report
21:16:08 <MarcelineVQ> it's full of neat stuff, have a google for previous entries
21:17:13 <Maxdamantus> Sure it's a zero-cost abstraction: https://hackage.haskell.org/package/base-4.8.0.0/docs/src/Data-Functor-Identity.html#line-83
21:17:16 <Lokathor> are they frequent?
21:18:01 <MarcelineVQ> biyearly
21:18:21 <Lokathor> Maxdamantus, you can optimize away the wrap/unwrwap into Identity, but (as i understand it) you still do the fmapping if you've got a list of newtype values and you walk the list to unwrap the values
21:18:21 <MarcelineVQ> twice-yearly I should say,depending on whos description of biyearly you use
21:19:08 <Maxdamantus> Lokathor: well, the `coerce` is there for pretty much that reason.
21:19:09 <MarcelineVQ> first you have to find out if there's even a list there at all after compilation
21:19:35 <Maxdamantus> Lokathor: it's coercing, eg, a function `a -> b` into `Identity a -> Identity b`
21:20:04 <Lokathor> hmm
21:20:34 <mmaruseacph2> Lokathor: November and May every year
21:21:00 <mmaruseacph2> though last year the November one was pushed to near end of December due to some scheduling issues
21:21:39 <Lokathor> Maxdamantus, http://lpaste.net/359589 so here is an example. there's two fmap composed (through IO then though List)
21:21:49 <Lokathor> but you say that it just plain skips the list walk?
21:22:20 <Lokathor> mmaruseacph2, i'm afraid i only have halfbaked ramblings :P
21:22:32 <Lokathor> though i wrote a long rant about how the random package is basically falling down on the job >_>
21:24:10 <Lokathor> I didn't actually complete the package that would replace it
21:26:31 <Maxdamantus> Lokathor: no, I'm saying that you might be able to skip it if you coerce, like `Functor Identity` and related instances do.
21:28:31 <Maxdamantus> Lokathor: if you have some `[Foo]` where `newtype Foo = Bar`, it should be just as safe to coerce it to `[Bar]` as it is for Identity's Functor instance to coerce from `a -> b` to `Identity a -> Identity b`
21:28:51 <Lokathor> ah ha
21:28:57 <Lokathor> well it types checks :P
21:29:12 <Lokathor> I'm gonna guess that this just works for the moment
21:29:25 <Maxdamantus> Lots of additional things type check with `coerce` \o/
21:30:21 <Maxdamantus> I guess it might not be as safe in some sense .. since `Functor Identity` is part of base, you might be able to consider its implementation specific to some version of GHC or something, dunno.
21:32:30 <Lokathor> well, coerce itself doesn't depend on the Identity type
21:32:46 <Lokathor> in fact they specifically point out my exact case, " But it also works in more complicated settings, e.g. converting a list of newtypes to a list of concrete types."
21:33:08 <Maxdamantus> Right, coerce just has an evil nonsensical type that lets you do things that appear to be, and often are, insane.
21:33:34 <Lokathor> i thought that one was reserved for unsafeCoerce
21:33:52 <Maxdamantus> I wonder if someone's considered creating a language extension that introduces a safe form of coerce for those cases.
21:34:28 <Maxdamantus> safeCoerce :: Newtype A B => f a -> f b
21:34:35 <Maxdamantus> er
21:34:41 <Maxdamantus> safeCoerce :: Newtype a b => f a -> f b
21:35:29 <Maxdamantus> Where declarinf `newtype Foo = Bar` also gives you conceptual instances `Newtype Foo Bar` and `Newtype Bar Foo`
21:36:29 <geekosaur> er?
21:36:46 <geekosaur> are you talking about the same coerce?
21:37:22 <geekosaur> the one Lokathor is talking about has the compiler create Coercible instances for each newtype, and coerce operates based on the Coercible instances
21:38:22 <geekosaur> https://downloads.haskell.org/~ghc/latest/docs/html/libraries/base-4.10.0.0/Data-Coerce.html
21:38:42 <geekosaur> note that the compiler prevents you from making your own Coercible instances
21:41:49 <Maxdamantus> Oh wow, didn't know that. I thought coerce was just unsafeCoerce.
21:45:32 <Lokathor> unsafeWith :: Storable a => Vector a -> (Ptr a -> IO b) -> IO b
21:45:57 <Lokathor> Vector.Storable and Vector.Storable.Mutable both have this, but they don't share a typeclass between them for it
21:46:00 <Lokathor> so i have to write it
21:46:40 <Maxdamantus> Ah, Coercible is relatively recent .. GHC 7.8.1
21:46:43 <Lokathor> http://lpaste.net/359590 is this how one would write it?
21:46:55 <Lokathor> er, oop
21:47:07 <Lokathor> okay paste fixed
21:57:00 <Lokathor> if it asks for me to turn on TypeSynonymInstances is that a sane move to do?
21:58:01 <MarcelineVQ> Lokathor: in case it matters note that they're really the same thing,   unsafeWith (MVector _ fp) = withForeignPtr fp        unsafeWith (Vector _ fp) = withForeignPtr fp
21:59:15 <Lokathor> hmm
21:59:21 <Lokathor> i'll tackle this later
22:02:30 <Lokathor> i mean it accepts the instance being for IOVector
22:02:39 <Lokathor> but it can't pick the instance to use sizeOf with
22:18:02 <slack1256> lpaste.net/359594
22:19:23 <slack1256> on that function, if I construct a `let go = mkInterestingChecker coolset` on my code, will haskell construct once the iwatch Set and share it between calls?
22:22:22 <geekosaur> I don't think it will float iwatch out beyond mkInterestingChecker unless you force it to be inlined?
22:26:04 <slack1256> yeah, but I just want different calls to `go here` `go there` work sharing the work on coolset and not constructing it everytime there is a call
22:28:53 <geekosaur> hm. maybe I am thinking abotu this wrong and it will be shared if go is
22:29:12 <geekosaur> guess you can test it with timings and a hack to delay evaluaton or something
22:29:34 <slack1256> Mmm I will test. But i think I can make my question clearer
22:29:43 <slack1256> http://lpaste.net/359595
22:29:50 <slack1256> are there two programs equivalent?
22:29:53 <geekosaur> or not even. just use Debug.Trace.trace
22:30:39 <geekosaur> that I am not sure of
22:31:02 <geekosaur> things get tricky around there
22:31:08 <slack1256> Cool, thanks for your honesty !
22:31:22 <slack1256> I will try to debug and benchmark to try to answer that 
22:55:34 <MarcelineVQ> interesting, the prep and simpl of those two are fairly different
23:03:14 <MarcelineVQ> hmm, not that different, prep is just spelling things out for stg it seems.
23:04:43 <MarcelineVQ> slack1256: http://lpaste.net/359595
23:11:45 <bbzq8> hi, can anyone recommend a library that can do url encoding for post requests?
23:12:00 <bbzq8> from key/ value pairs
23:40:03 <Guest38635> hi all, can you point some resources where I could learn what "->" means in a do block ?
23:40:35 <cocreature> Guest38635: do you mean "<-"?
23:40:56 <Guest38635> no
23:41:23 <MrSkeltal> Guest38635, do you have an example?
23:41:45 <Guest38635> http://lpaste.net/359597
23:42:04 <Guest38635> is it anonymous function ? 
23:42:16 <cocreature> yep, thatâ€™s just a regular lambda
23:42:49 <Guest38635> I'm used to (\name -> body) 
23:43:16 <cocreature>  thatâ€™s exactly whatâ€™s happening here only without the parentheses
23:43:43 <Guest38635> ok, I understand 
23:43:46 <Guest38635> thanks
23:48:57 <cocreature> bb010g: https://hackage.haskell.org/package/http-types-0.10/docs/Network-HTTP-Types.html#v:renderQuery and https://hackage.haskell.org/package/http-api-data-0.3.7.1/docs/Web-FormUrlEncoded.html#v:urlEncodeForm should both be able to do this
