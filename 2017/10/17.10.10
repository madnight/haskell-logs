00:00:06 <anuj_> hey saurabhn
00:01:50 <pacak> Hmmm...
00:02:04 <pacak> An interesting way of getting information.
00:06:37 <dyreshark> well, they wanted to know if anyone was here
00:06:44 <dyreshark> they got their answer, clearly
00:27:36 <jonge> hey there. in https://hackage.haskell.org/package/base-4.10.0.0/docs/src/GHC.Base.html#%3C%7C%3E i see that for `[]`, bind is defined as `xs >>= f = [y | x <- xs, y <- f x]`. why is it not `xs >>= f = map f xs`? for `>>` they are also just using the `*>` implementation.
00:38:26 <geekosaur> jonge, you probably want to find the referenced Note
00:38:53 <geekosaur> the definition used to be (flip concatMap)
00:39:15 <jonge> geekosaur: where to find that note?
00:39:39 <geekosaur> -- See Note: [List comprehensions and inlining]
00:39:39 <geekosaur> -- | @since 2.01
00:39:39 <geekosaur> instance Monad []  where
00:39:43 <geekosaur> from the source you pointed to
00:40:06 <jonge> yeah it says "see note: xxx". where do i find that if i want to go see?
00:40:32 <jonge> oh wait it just comes later. sorry.
00:40:37 <geekosaur> it;s in the same file, around the Monoid instance that it also applies to
00:40:42 <geekosaur> (it's also noted for Applicative)
00:41:33 <geekosaur> and you should probably get used to that style when reading internals, as the ghc source and the compiler Commentary also use it extensively
00:41:48 <geekosaur> (https://ghc.haskell.org/trac/ghc/wiki/Commentary/Compiler)
00:42:32 <jonge> geekosaur: seems legit. thx! just started reading the fundamental definitions to understand my parsers better...
00:43:04 <geekosaur> you might do better with the ones from the Report; ghc likes to use versions of things optimized for how it is implmented
00:43:16 <geekosaur> the stuff in the Report is pedagogical and generally more easily understood
00:43:24 <geekosaur> @where haskell2010
00:43:24 <lambdabot> http://www.haskell.org/onlinereport/haskell2010/
00:43:38 <jonge> geekosaur: ok, i was not aware of that. 
00:43:48 <jonge> good to know, thank you
02:17:24 <maerwald> has there been a decision on the haskell mascot yet?
02:17:48 <maffh> I have a memory problem with my program. So, to debug this I wanted to use the profiling tools. In order to start the profiling it I have to build my program using: "stack build --profile". However, this command uses a lot amount of memory (over 6gb), which my laptop cant handle. Are there any other ways to use these tools?
02:31:02 <merijn> maffh: 6gb? In a single process? Or is it, e.g., running lots of GHC processes?
02:33:24 <merijn> maffh: (Just wondering if stack build is running a parallel build, in which case you could try running it without parallelisation to save memory)
02:36:53 * hackagebot Allure 0.6.2.0 – Near-future Sci-Fi roguelike and tactical squad game – https://hackage.haskell.org/package/Allure
02:36:53 * hackagebot LambdaHack 0.6.2.0 – A game engine library for roguelike dungeon crawlers – https://hackage.haskell.org/package/LambdaHack
02:37:41 <maffh> merijn: Yes, it creates several processes
02:38:18 <merijn> maffh: Ah, I don't know stack, but a wild ass guess is: Try "stack build --profile -j1" (-j usually controls parallelism in build tools)
02:38:40 <merijn> (This obviously takes longer)
02:39:53 <maffh> Thank you, I will try that
02:44:23 <maffh> merijn, it works! Thanks!
03:16:25 * hackagebot cryptoids 0.0.0, postgres-embedded 0.1.3, uuid-crypto 1.0.0, cryptoids-types 0.0.0
03:16:25 * hackagebot  → https://hackage.haskell.org/packages/recent
03:25:35 <zblkf> hello there, what would you recommend for logging with the ability to use custom formats (e.g. json), timestamps and concurrency ready ? I have looked at multiple of them (fast-logger, monad-logger, simple-logger), none of them seem to fit those requirements (unless I missed something)
03:29:37 <osa1> zblkf: fast-logger logs bytestrings so you could certainly use it as the backend
03:30:10 <osa1> zblkf: monad-logger is simple enough that I think you can use as a starting point for the high-level logging API.
03:30:44 <osa1> so if none of the existing solutions do it I'd (1) use fast-logger as backend (2) fork and modify monad-logger based on my needs
03:32:25 <osa1> any tips & tricks for debugging a code that somehow requires a constraint? I have no idea where does that constraint come from even after looking at definitions of functions that the expression used
03:33:19 <osa1> zblkf: also make sure to check katip: http://hackage.haskell.org/package/katip
03:34:19 * hackagebot private-hackage-uploader 0.2.3.0 – Upload a package to the public or private hackage, building its docs – https://hackage.haskell.org/package/private-hackage-uploader
03:44:58 <osa1> to be more concret, I'm wondering where does `BaseBackend backend ~ SqlBackend` constraint in this code come from: http://lpaste.net/359101 (Esq is esqueleto)
03:45:03 <osa1> concrete*
03:55:57 <athan> osa1: are you asking "how do I find out where a constraint has been introduced?"
03:56:21 <athan> because if that's the case, this one might be literally added ad-hoc, arbitrarilly constrained more than the most-general-unifier
03:57:11 <athan> Or the other case, that `backend` has something constraining it, while being used as a ReaderT value - like with `local` or something
03:58:58 <merijn> osa1: tbh, I stopped using esqueleto because I found it to be both 1) very confusing and 2) not nearly flexible enough, so I just started using persistent's rawSql functions
03:59:09 <osa1> athan: yes that's what I'm asking
03:59:19 <athan> which `this` :|
03:59:27 <osa1> merijn: it works great in my case, I can express joins I need
03:59:37 <osa1> athan: "how do I find out where a constraint has been introduced"
04:00:11 <athan> Ahh okay, you could just remove it and see what throws the compile error
04:01:10 <osa1> athan: the constraint is not used in my code at all so I can't remove it. it should be coming from one of the functions.
04:02:03 <athan> I mean in the library itself - just unpack esqueleto with `stack unpack`, and drill down in it isolated
04:02:32 <osa1> athan: the constraint isn't used in esqueleto either :-) I think the only place it's used is in persistent but I can't find it
04:02:42 <athan> I think ghc accumulates the polymorphic typing information as it walks expressions, but I have no idea :)
04:02:59 <athan> wait...
04:03:15 <osa1> like, if you grep for that constraint in esqueleto source you don't get any matches
04:03:55 <athan> but `select` returns something with that constraint, doesn't it?
04:04:00 <osa1> yeah
04:04:02 <athan> Or at least a type family around that constraint
04:04:09 <athan> then you can remove it from `select`, can't you?
04:04:16 <athan> where select is defined in the esq. lib
04:04:32 <osa1> athas: select :: ( SqlSelect a r , MonadIO m ) => SqlQuery a -> SqlReadT m [r]
04:04:44 <osa1> similarly SqlSelect doesn't mention that constraint
04:04:50 <lyxia> osa1: SqlReadT
04:04:56 <athan> ah! I bet it's in that type alias
04:05:04 <athan> SqlReadT ~ ReaderT X
04:05:08 <athan> where X has something in there I bed
04:05:21 <athan> bet*
04:05:30 <osa1> ah!
04:05:34 <osa1> you're right
04:05:34 <athan> :)
04:05:42 <lyxia> SqlReadT m a = forall backend. SqlBackendCanRead backend => ReaderT backend m a
04:05:43 <osa1> type SqlReadT (m :: * -> *) a = forall backend. SqlBackendCanRead backend => ReaderT backend m a
04:06:24 <athan> lyxia out here, defeating race conditions before they happen
04:06:43 <osa1> hmm so I had some persistent code which was backend agnostic, now they require SqlBackend because I used esqueleto even though they're doing the same things as before
04:07:59 * hackagebot orgstat 0.1.1 – Statistics visualizer for org-mode – https://hackage.haskell.org/package/orgstat
04:10:42 <maerwald> is there no library that implements all the different sorting algorithms and lets me chose which one to use?
04:11:08 <ertes-w> maerwald: vector-algorithms has a bunch of them
04:14:23 * hackagebot postgres-embedded 0.1.4 – <i>Added by ilya_murzinov, Tue Oct 10 11:08:50 UTC 2017.</i> – https://hackage.haskell.org/package/postgres-embedded
04:47:07 <zblkf> thanks osa1
05:02:24 <AndreasK> Can someone help me out why ghc doesn't find the instance for "pretty (undefined :: Expr [Int])"  given a instance definition like "instance Show a => Pretty (Expr a) where {...}"
05:02:53 <merijn> AndreasK: What's the exact error?
05:03:35 <AndreasK> merijn: "* No instance for (Pretty (Expr [Int])) arising from a use of `pretty'"
05:04:18 <merijn> hmmm
05:04:31 <AndreasK> Also fails for Expr Int for what it's worth
05:04:41 <merijn> AndreasK: Are you sure the instance is in scope?
05:05:48 <AndreasK> merijn: I should take a break, that was the issue. Thank you
05:17:30 <merijn> hmmm, what's the best way to report an N-way set difference? i.e. I have N sets of values and if they're not all identical I need to report which elements are missing where
05:19:09 <athan> merijn: you could accumulate a map of sets, where the index is the set's name :s
05:19:18 <athan> then just rely on HashSet.difference >.>
05:20:02 <mniip> merijn, diff :: Universe i => (i -> Set s) -> i -> Set s
05:21:03 * hackagebot uuid-crypto 1.1.0 – Reversable and secure encoding of object ids as uuids – https://hackage.haskell.org/package/uuid-crypto
05:21:03 * hackagebot cryptoids 0.1.0 – Reversable and secure encoding of object ids as a bytestring – https://hackage.haskell.org/package/cryptoids
05:21:13 <mniip> diff f = (u `subtract`) <$> f where u = union (f <$> universe)
05:21:44 <merijn> mniip: Where is universe from?
05:22:11 <athan> universe-base? :s
05:23:56 <ertes-w> merijn: alternatively:  diff :: (Ord a, Ord k) => Set k -> (k -> Set a) -> k -> Set a
05:26:01 <ertes-w> @let diff ks xss = S.difference u . xss where u = foldMap xss ks
05:26:03 <lambdabot>  Defined.
05:26:05 <ertes-w> :t diff
05:26:07 <lambdabot> (Foldable t, Ord a1) => t a2 -> (a2 -> S.Set a1) -> a2 -> S.Set a1
05:26:14 <ertes-w> merijn: ^
05:27:00 <merijn> hmm, I have a function that takes two Bool values, which is a bit confusing, boolean blindness and all. I'm think of replacing them with specific ADTs, but I don't really know how to make that play well with when/unless
05:27:26 <merijn> i.e. only running an action if it matches one specific constructor
05:28:14 <ertes-w> merijn: or avoid the booleans in the first place, if you can
05:28:31 <Xion_> merijn: Use Lens with `is` perhaps
05:28:34 <ertes-w> renaming them makes it less confusing, but doesn't solve the boolean blindness
05:28:35 <merijn> ertes-w: That's the question: I'm planning to replace them, but then the code becomes annoying
05:28:40 <merijn> Xion_: lens is a nogo
05:28:59 <merijn> ertes-w: I meant replacing the Bool with a specific ADT
05:29:03 <Xion_> Then provide the boilerplate isFoo functions yourself.
05:29:17 <merijn> Xion_: lens is an unacceptable dependency
05:29:34 <Xion_> Or do `case ... _ -> return ()` instead of when
05:29:35 <merijn> ertes-w: But if I have a specific ADT then doing something for only one case of that ADT becomes annoying
05:29:37 <lyxia> Use (==)?
05:29:49 <ertes-w> merijn: so you mean something other than a Bool-isomorphic type?
05:29:50 <merijn> lyxia: Yeah, that was my plan B, but it feels unelegant :\
05:30:00 <Xion_> Oh, they'd be simple enums?
05:30:03 <Xion_> Then totally just use ==
05:30:07 <merijn> ertes-w: That's not possible, since it's inherently a Bool-isomorphic value
05:30:41 <ertes-w> merijn: one option is to take them together in a product, so you can use field names…  creating Bool-isomorphic types is inconvenient
05:31:08 <merijn> ertes-w: Yeah, I thought about that too
05:41:23 * hackagebot uuid-crypto 1.1.0.1 – Reversable and secure encoding of object ids as uuids – https://hackage.haskell.org/package/uuid-crypto
05:41:23 * hackagebot cryptoids 0.1.0.1 – Reversable and secure encoding of object ids as a bytestring – https://hackage.haskell.org/package/cryptoids
05:46:18 <merijn> ertes-w: ugh, naming sum types is hard >.>
05:47:52 <ertes-w> merijn: you're going with the sums?
05:48:15 <merijn> ertes-w: Eh, I meant to type product, but apparently there was a neuron misfire :p
05:49:24 <ertes-w> hehe
05:49:33 <ertes-w> merijn: if your function is named 'blah', call it 'BlahCfg'
05:54:49 <ShalokShalom> a friend of mine is asking me, how an in-place selection in Haskell looks like
05:55:24 <ShalokShalom> In specific, he likes to see, i quote: "In each pass, it will find the smallest and the greatest item in an array of items."
05:55:40 <Psybur> You mean selection sort?
05:55:46 <ShalokShalom> Yes
05:57:42 <Psybur> ShalokShalom, havent looked too hard but theres an answer here that might be useful https://stackoverflow.com/questions/41130707/how-can-i-generalize-this-in-place-selection-sort
05:57:47 <ShalokShalom> thanks
05:58:03 <ShalokShalom> boah, this looks complex
05:58:24 <Psybur> yeah, I dont think its a "good" answer :D
05:58:48 <ShalokShalom> I see
05:59:46 <ShalokShalom> For him, Haskell and others with a functional approach seem to him overcomplicated, when it comes to such easy tasks.
05:59:49 <Psybur> I might be able to whip something up. The way Ive seen these in place sorts done in haskell is through the use of a mutable vector
06:00:12 <Psybur> ShalokShalom, Ive seen it said that the easy things can be hard in haskell, but hard things are easy xD
06:00:24 <ShalokShalom> aha
06:00:39 <ShalokShalom> thanks a lot
06:00:39 <merijn> Psybur, ShalokShalom: tbh, the solution is to just use the right sorting algorithm
06:01:05 <merijn> selection/insertion sort, just like quicksort aren't great for purely functional languages due to lack of mutability
06:01:12 <merijn> But that's ok, since those sorts are shit anyway
06:01:17 <merijn> mergesort == best sort
06:01:48 <Athas> Bitonic sort == more better merge sort.
06:02:01 <Athas> merijn: haven't you seen all those quicksorts in Haskell?
06:02:04 <Athas> Well.  "Quicksort".
06:02:09 <Psybur> Even the in place quicksort isnt good?
06:02:17 <merijn> Psybur: Quicksort is never good, imo
06:02:25 <Psybur> Does haskell have a timsort? :D
06:02:25 <merijn> Psybur: I don't get why everyone is so infatuated with it
06:02:32 <Athas> Psybur: which one?  The ones I've seen look really ugly, and are still not all that fast.
06:02:37 <Athas> (In Haskell.)
06:03:01 <Psybur> https://hackage.haskell.org/package/vector-algorithms-0.7.0.1/docs/Data-Vector-Algorithms-Tim.html
06:03:59 <merijn> Psybur: QuickSort has a bunch of problems: 1) It's really easy to get subtle logic errors in the splitting, 2) tricky index computation, 3) O(n^2) worst case performance, 4) poor cache behaviour
06:05:04 <merijn> Psybur: Mergesort is 1) simpler, 2) has really nice cache behaviour, 3) O(n log n), 4) cache friendly access patterns, 5) trivial to parallelise, 6) works well with immutable data structure, 7) can be implemented in-place too if necessary
06:05:56 <ClaudiusMaximus> anyone used  pandoc beamer lhs2TeX  all at once?  pandoc beamer seems simple for markdown->slides, lhs2TeX on its own seems like i'd need to write tons of beamer latex markup myself
06:06:12 <merijn> Psybur: Hence, mergesort == best sort
06:06:23 <Psybur> merijn, but what about timsort?!
06:06:24 <merijn> Psybur: And the implementation is trivial to remember too :)
06:07:17 <merijn> Psybur: timsort is just mergesort with the last few recursion steps replaced with insertion sort
06:07:37 <mbwgh> I am currently reading the "Fun with Type Functions" paper. It states that MultiParamTypeClasses describe non-function many-to-many relations, whereas type-constructors express functional relations between types. If I have a "class IsWrapper w a where { wrap :: a -> w, unwrap :: w -> a }" without fundeps, what exactly are the domain and the codomain here? I could argue that I can make [] and Identity 
06:07:43 <mbwgh> instances of IsWrapper, which would, for `wrap`, assign some choice of a to either [a] or Identity a. But then it isn't clear to me why the non-functional many-to-many relationship is an intrinsic property if MultiParamTypeClasses, since this reasoning would apply to pure :: Applicative f => a -> f a as well. Would a better example be something like class IsList l a where { nil :: l ... }, which would 
06:07:49 <mbwgh> require a fundep | l -> a for nil to not be ambiguous?
06:08:36 <Psybur> merijn, which is the best implementation of merge sort you know? The ones Im seeing looks like it would take 3 passes over the list just to split it in half heh
06:08:41 <kosmikus> ClaudiusMaximus: perhaps http://www.informatik.uni-marburg.de/~rendel/pandoc-lit/, but I've never looked at it
06:08:49 <merijn> Psybur: In haskell or in general?
06:08:54 <Psybur> merijn, haskell
06:08:59 <kosmikus> ClaudiusMaximus: there's also been an attempt to add a markdown mode to lhs2tex, but that's probably not what you actually want
06:09:15 <merijn> Psybur: The source in base has several versions of sort in it, with comments about performance, etc.
06:09:34 <merijn> Psybur: It's worth a look: https://hackage.haskell.org/package/base-4.10.0.0/docs/src/Data.OldList.html#sort
06:10:58 <Psybur> merijn, that doesnt look so simple to remember ;p
06:11:31 <merijn> Psybur: That's an optimised version of mergesort
06:12:21 <ClaudiusMaximus> kosmikus: thanks, pandoc-lit looks a bit proof-of-concept at first glance, but i'll give it a go
06:12:27 <ShalokShalom> merijn: Arnt there use cases, where such a selection sort is needed?
06:12:51 <merijn> ShalokShalom: Why would you need to use selection sort specifically?
06:13:03 <ShalokShalom> how to implement such a in place merge sort?
06:13:33 <Psybur> When would you need an inplace merge sort? When you have a tiny stack?
06:13:47 <ShalokShalom> merijn: this guy is imperative style used and i like to show him the benefits of functional languages like Haskell
06:14:21 <merijn> Psybur: It's not about stack, but memory in general
06:14:35 <merijn> Psybur: If you're sorting 16GB you don't want to use 2 the memory to sort
06:15:35 * hackagebot selda 0.1.11.1 – Type-safe, high-level EDSL for interacting with relational databases. – https://hackage.haskell.org/package/selda
06:15:35 * hackagebot postgres-embedded 0.1.5 – <i>Added by ilya_murzinov, Tue Oct 10 13:08:08 UTC 2017.</i> – https://hackage.haskell.org/package/postgres-embedded
06:19:33 <ShalokShalom> He says: " That's how most sorting algorithms are implemented, because it avoids memory overhead and is faster. Some are in-place, some require copying. E.g. merge sort is not in-place and can be very fast, because it can be parallelized, but uses twice the amount of memory. Heap sort is in-place and also quite fast, but not stable.
06:19:33 <ShalokShalom> This is just one typical example with a rather simple algorithm that is hardly used in applications, because it is slow."
06:19:37 <ShalokShalom> About "why in place"
06:20:01 <Psybur> ShalokShalom, I think getting into the nitty gritty of sorting algorithms might not be the best approach if you want to proselytize about fp heh In place operations are possible in haskell
06:20:15 <ShalokShalom> ?
06:20:21 <merijn> ShalokShalom: You can merge in place: http://akira.ruc.dk/~keld/teaching/algoritmedesign_f04/Artikler/04/Huang88.pdf
06:20:35 <ShalokShalom> merijn: Yes, I see. 
06:20:36 <merijn> In fact, we've known how to do efficient in-place merging since, apparently, 1988
06:20:46 <ShalokShalom> How does this look like in this case?
06:21:41 <ShalokShalom> And this merge in place sorting does compare nicely with the Java counterpart?
06:23:06 <Athas> Most in-place algorithms are ugly in Haskell.
06:23:17 <Athas> I'm not sure what "Java counterpart" you are referencing.
06:23:28 <ShalokShalom> what he refers to..
06:23:45 <ShalokShalom> in place sorting algorithms
06:24:04 <tdammers> Athas: can always write them in imperative style though
06:24:12 <ShalokShalom> he says, its nice readable in imperative languages
06:24:22 <xenon-> Athas what makes them ugly?
06:24:23 <Athas> tdammers: sure, that's what's ugly!
06:24:24 <ShalokShalom> tdammers: What i assumed
06:24:43 <ShalokShalom> imperative style in Haskell looks declarative?
06:24:53 <tdammers> Athas: well, in-place algorithms are inherently imperative, so I don't think writing them in an imperative style is necessarily ugly
06:24:53 <Athas> xenon-: they tend to look more noisy than in your run-of-the-mill sequential language, and they feel more clumsy to work with.
06:24:55 <Psybur> ShalokShalom, maybe your friend just doesnt need haskell for what he does? I always thought haskell was more about making things that just work
06:25:09 <Athas> It's mostly because you end up having a lot of monadic glue combinators, I think.
06:25:27 <ShalokShalom> He seems to think this this kind of implementation makes Java superiour at all
06:25:32 <Athas> Maybe it is possible to define a set of heavily overloaded operators that would make it nicer to read in Haskell.
06:26:17 <ShalokShalom> He challanges me, to create such an implementation in Haskell, in order to compare it to one in C++
06:26:31 <Psybur> ShalokShalom, tell your friend to at least use scala if he's going to use the jvm :P
06:26:47 <ShalokShalom> How does it look in Scala?
06:27:02 <Psybur> ShalokShalom, scala is java so pretty much the same as it does in java
06:27:07 <ShalokShalom> I see. 
06:27:31 <Psybur> Scala is java plus a lot of functional programming concepts added
06:27:55 <ShalokShalom> So, his description of in place implementations are accurate?
06:28:32 <ShalokShalom> That they avoid memory overhead 
06:28:37 <ShalokShalom> and that they are faster?
06:29:27 <Psybur> ShalokShalom, yes they avoid memory overhead but I can't make any assertions on being faster.
06:29:48 <ShalokShalom> So, how do you avoid memory overhead in functional implementations?
06:30:01 <ShalokShalom> and how do they look like?
06:30:17 <Psybur> You can use mutable vectors in haskell to achieve in place operations
06:31:25 <ShalokShalom> And how would such an implementation look like?
06:31:31 <ShalokShalom> Can you show me some?
06:31:33 <Psybur> But if you need to squeeze nanoseconds and bytes out of your program maybe you dont need to be using haskell heh you might end up getting killed by garbage collection after all your efforts :P
06:32:10 <ShalokShalom> E.g how does it look like, implementing the above mentioned "In each pass, it will find the smallest and the greatest item in an array of items."
06:32:10 <ertes-w> ShalokShalom: haskell is an imperative language
06:32:15 <ShalokShalom> Aha, ok
06:32:23 <ertes-w> ShalokShalom: in fact you can make the code look like C++, if you really want to
06:32:26 <ShalokShalom> ertes-w: functional implemented?
06:32:32 <ShalokShalom> ok, can you do?
06:32:36 <ShalokShalom> i am unexperienced
06:32:38 <ShalokShalom> yet
06:32:39 <Athas> ShalokShalom: have you seen the first answer here? https://stackoverflow.com/questions/5268156/how-do-you-do-an-in-place-quicksort-in-haskell
06:32:44 <ShalokShalom> yes
06:32:50 <ShalokShalom> looks quite confusing
06:32:55 <Athas> That's what it looks like.
06:33:01 <ertes-w> ShalokShalom: by "haskell is an imperative language" i mean that you can do imperative programming in haskell…  it's just not the default style
06:33:01 <ShalokShalom> i am sure, he will come up with a simpler solution
06:33:06 <ShalokShalom> no more readable solution?
06:33:27 <ShalokShalom> including "non- in place" solutions
06:33:37 <Athas> A Java solution may be more "readable" (depending on subjective taste) because Java has built-in syntax for indexing arrays and such, but the logic is the same.
06:33:38 <ShalokShalom> ertes-w: Yes, I know. 
06:34:08 <ertes-w> you can establish a similar syntax in haskell, if you really really want to
06:34:26 <ertes-w> it's just a matter of using symbolic operators instead of words
06:34:37 <ertes-w> look at lens code with StateT
06:35:32 <ertes-w> > execState (do _1 += 5; _2 += 17; _3 . traverse %= toUpper) (10, 100, "hello!")
06:35:37 <lambdabot>  (15,117,"HELLO!")
06:35:45 <Athas> To be fair, those suffer from cognitive complexity and poor error messages, don't they?
06:35:55 <Athas> > execState (do _1 += 5; _2 += _2; _3 . traverse %= toUpper) (10, 100, "hello!")
06:36:00 <lambdabot>  error:
06:36:00 <lambdabot>      • No instance for (Typeable f0)
06:36:00 <lambdabot>          arising from a use of ‘show_M90581295877889613646724’
06:36:27 <Athas> Well, that's clear.
06:36:29 <ertes-w> Athas: poor error messages, yes, but the cognitive complexity goes away once you learn lenses properly
06:37:04 <ShalokShalom> ertes-w: I simply like to see a simply sorting algorithm
06:37:26 <Athas> ShalokShalom: The StackOverflow answer contains the simplest in-place quicksort you are likely to find for Haskell.
06:37:32 <ShalokShalom> :(
06:37:35 <ertes-w> ShalokShalom: my first address would be the source code of the 'vector-algorithms' library
06:37:40 <ShalokShalom> And not in place?
06:38:00 <ertes-w> the SO answer looks terrible
06:38:08 <ShalokShalom> Why do I need a library, to do such a simple sorting? oO
06:38:29 <ShalokShalom> Is it really so hard, to implement something that easy?
06:38:29 <ertes-w> quicksort can look much simpler, if you implement it straightforwardly
06:38:32 <Athas> The simplest (and slow) sort in Haskell is probably the classic example: http://wiki.c2.com/?QuickSortInHaskell
06:38:32 <Psybur> http://hackage.haskell.org/package/vector-algorithms-0.4/docs/src/Data-Vector-Algorithms-Intro.html#sort
06:38:34 <ShalokShalom> Ok, how?
06:38:39 <ShalokShalom> ertes-w: How does this look like?
06:38:51 <ShalokShalom> In this case. 
06:38:53 <ShalokShalom> "In each pass, it will find the smallest and the greatest item in an array of items.""
06:39:17 <ertes-w> ShalokShalom: i don't have time to implement it right now, but it would look pretty much like the C++ variant
06:39:23 <ShalokShalom> Thanks a lot. 
06:39:32 <ShalokShalom> I would be happy, to show him that. 
06:39:34 <Psybur> http://hackage.haskell.org/package/vector-algorithms-0.7/docs/src/Data-Vector-Algorithms-Insertion.html#sort
06:39:38 <ertes-w> ShalokShalom: about your library question…  why wouldn't you need a library?
06:39:43 <ShalokShalom> This is exactly, what he denies. 
06:40:27 <phadej> sorting isn't simple, there's a volume of TAOCP dedicated to that :)
06:40:30 <ertes-w> ShalokShalom: i think you're wasting your time
06:40:38 <ShalokShalom> ertes-w: I mean, because its something abvious simple?
06:40:45 <ShalokShalom> I guess its part of the default lib
06:40:57 <ertes-w> ShalokShalom: if you go and show him the haskell code, he will just find another reason to dislike haskell
06:41:00 <phadej> vector-alogirthms is a library because there's many differnet sorts, because none is obviously & always better than other
06:41:07 <ShalokShalom> ertes-w: I am fine with that one then.
06:41:11 <ShalokShalom> He is simply curious
06:41:16 <Psybur> This is in place right? https://hackage.haskell.org/package/vector-algorithms-0.7.0.1/docs/src/Data-Vector-Algorithms-Insertion.html#sort
06:41:24 <ClaudiusMaximus> anyone has a favourite simple example of a mutually recursive pair of functions?
06:41:28 <ShalokShalom> And it seems to be founded..
06:41:39 <phadej> ClaudiusMaximus: many + some
06:42:02 <ertes-w> ClaudiusMaximus: the main page of haskell.org has one =)
06:42:02 <ShalokShalom> phadej: I am talking about something very basic..
06:42:16 <ShalokShalom> So I guess, its possible to find a simple implementation. 
06:42:27 <ertes-w> ClaudiusMaximus: ah, no, it doesn't
06:43:00 <phadej> some & many are quite basic :(
06:43:31 <ertes-w> ClaudiusMaximus: basically anything that "switches" would be a good example…  comes up quite often in stream processing and parsing
06:44:16 <ClaudiusMaximus> phadej: many + some seems good, thanks!
06:45:16 * hackagebot ekg-core 0.1.1.3 – Tracking of system metrics – https://hackage.haskell.org/package/ekg-core
06:46:02 <ertes-w> ShalokShalom: trying to convince a C++ programmer of haskell is like trying to convince a combinatorics person of category theory…  if they're arguing about the beauty and speed of sorting algorithms, don't even bother =)
06:46:32 <ertes-w> yes, it's possible to get there in haskell, but still…  don't bother
06:46:49 <Psybur> ertes-w, even then, garbage collection
06:47:19 <ertes-w> GC, managed OS threads, …
06:47:44 <ertes-w> the only language you might be able to convince them of is rust
06:47:57 <ertes-w> but that's just a better C++
06:48:42 <maerwald> rust is nothing like C++
06:49:05 <ertes-w> it's much closer to C++ than to haskell though
06:49:07 <maerwald> C++ programmers like the language, because it isn't actually a language, but a semi-random toolbox to assemble your own language
06:49:22 <Athas> Hey, that's Lisp!
06:49:35 <maerwald> and then being exposed to a lot of implementation details
06:49:49 <merijn> ertes-w: Right, I finally got to the N-way diff and I'm not sure I actually get your version :)
06:50:04 <ShalokShalom> ertes-w: You say, its basically the same.
06:50:04 <maerwald> they will argue they can do anything you can do in haskell with <feature X> in C++ anyway
06:50:18 <ertes-w> merijn: it's the same as mniip's, except it doesn't require an extra dependency =)
06:50:42 <mniip> I wasn't implying to use universe exactly
06:50:45 <ShalokShalom> i simply ask for a simple implementation of a simple sort 
06:50:57 <merijn> ertes-w: Yeah, I don't even look at the universe stuff :p
06:50:59 <mniip> but rather expressed the idea that it's a function that maps a family of sets to a family of sets
06:51:00 <AWizzArd> I have seen something which may be an infix operator:  #.            Can someone enlighten me what this is?
06:51:00 <ertes-w> merijn: foldMap f xss = S.unions (tmap f (S.toList xss))
06:51:17 <ertes-w> construct the union of all, then 'difference' it
06:52:00 <merijn> ertes-w: Ah, something like that was my original plan, although I guess I might want to intersect all and then difference
06:52:43 <AWizzArd> I saw this here: (Endo #. f)       in   foldr f z t = appEndo (foldMap (Endo #. f) t) z
06:52:55 <ertes-w> merijn: the only real reason i gave an implementation is to demonstrate the way i would use sharing
06:53:11 <ertes-w> merijn: notice that the 'where' is on the function level
06:53:13 <merijn> ertes-w: I don't think sharing is going to be important
06:53:28 <ertes-w> merijn: if you don't share, each query will recompute the union
06:53:32 <merijn> ertes-w: I don't expect more than (at most) several tens of sets with several tens of elements
06:54:32 * hackagebot log-base 0.7.3.0 – Structured logging solution (base package) – https://hackage.haskell.org/package/log-base
06:56:04 <ertes-w> merijn: BTW, i think this is actually an Iso, if you want =)
06:56:16 <ertes-w> ah, not quite
06:56:24 <merijn> ertes-w: lens is a nogo anyway :p
06:56:25 <ertes-w> wait, yes, it is
06:58:01 <ertes-w> merijn: i've been wondering…  why?  still on your quest to minimise dependencies?
06:59:33 <merijn> ertes-w: Because I'm working on hvr's multi-ghc-travis script and his rule for that is "no non-standard packages and works with GHC 7.0 through 8.0"
06:59:51 <ertes-w> ouch
07:01:13 <merijn> ertes-w: Ah, actually I see why I didn't get your diff! Because it doesn't actually do what I meant to do :p
07:02:17 <ertes-w> it doesn't?
07:03:37 <ertes-w> > diff (S.fromList [EQ, GT, LT]) (\k -> case k of EQ -> S.fromList "abc"; GT -> S.fromList "cde"; LT -> S.fromList "def") EQ
07:03:40 <lambdabot>  fromList "def"
07:03:47 <ertes-w> > diff (S.fromList [EQ, GT, LT]) (\k -> case k of EQ -> S.fromList "abc"; GT -> S.fromList "cde"; LT -> S.fromList "def") GT
07:03:52 <lambdabot>  fromList "abf"
07:04:16 <merijn> It builds a set of every element in the input set, then difference that with the set generated from another input, right?
07:04:28 <ertes-w> merijn: the set at GT is "cde", so it's missing "abf"…  is that not what you need?
07:06:14 <ertes-w> merijn: the second argument is a family of sets, and the first argument is a set of indices into that family
07:06:29 <_sras_> I get these linker errors http://lpaste.net/359106, when I try to do the build inside a docker container that has all the required packages preinstalled. How can I fix this?
07:09:11 <ertes-w> @let diff' = diff; diff' :: (Ord k, Ord a) => Set k -> (k -> Set a) -> k -> Set a
07:09:13 <lambdabot>  .L.hs:164:28: error:
07:09:13 <lambdabot>      Not in scope: type constructor or class ‘Set’
07:09:13 <lambdabot>      Perhaps you meant one of these:
07:09:21 <ertes-w> @let diff' = diff; diff' :: (Ord k, Ord a) => S.Set k -> (k -> S.Set a) -> k -> S.Set a
07:09:24 <lambdabot>  Defined.
07:10:15 <ertes-w> (i always forget that Set is Foldable)
07:10:52 <merijn> ertes-w: I think it's far more complicated than what I actually need. I think I can probably get away with just intersected all N sets and then individually diffing each with the result
07:14:29 <pierrot> Hi. I'm implementing these functions: https://glot.io/snippets/eueyd7n7te. In the definition of replicateTree, how can I make the declaration of distributeNodes local to replicateTree? I tried with a nested where but didn't work.
07:15:21 <merijn> That paste looks unreadable here
07:16:34 <geekosaur> pierrot, since next is a definition, you can add a where to it. it must be indented beyond the beginning of 'next (n m)'
07:17:13 <geekosaur> oh, sorry, missed the other use. but it should be possible to add it there. what is 'didn't work'?
07:18:07 <geekosaur> just adding it to the existing where clause compiles here
07:18:17 <geekosaur> remember that indentation matters
07:24:21 <ertes-w> merijn: sounds like the same complexity to me =)
07:24:54 <ertes-w> merijn: "intersect all, 'diff' each" vs. "union all, difference each"
07:25:17 <merijn> ertes-w: Yeah, except the way you implemented is stil confusing as fuck :p
07:27:25 <ertes-w> @let readableDiff ks xss = (\k -> S.difference everything k)  where everything = S.unions (map xss (toList ks))
07:27:28 <lambdabot>  .L.hs:184:41: error:
07:27:28 <lambdabot>      Ambiguous occurrence ‘toList’
07:27:28 <lambdabot>      It could refer to either ‘F.toList’,
07:27:34 <ertes-w> @let readableDiff ks xss = (\k -> S.difference everything k)  where everything = S.unions (map xss (S.toList ks))
07:27:37 <lambdabot>  Defined.
07:27:40 <ertes-w> merijn: better? =P
07:28:20 <ertes-w> err, that's wrong
07:28:31 <ertes-w> @let actualReadableDiff ks xss = (\k -> S.difference everything (xss k))  where everything = S.unions (map xss (S.toList ks))
07:28:34 <lambdabot>  Defined.
07:28:47 <pierrot> geekosaur: Thanks! Looks like I had done something wrong...
07:29:08 <pierrot> merijn: why unreadable?
07:29:26 <merijn> pierrot: I have to think to hard to read it
07:29:36 <merijn> I program Haskell so I don't have to think >.>
07:29:46 <ertes-w> in the original version i'm just using Monoid for the unions
07:30:02 <hexagoxel> I think i managed to write a reader/writer/state transformer stack abstraction where reader is superclass of state. no more ask, just get/set/tell.
07:30:15 <ertes-w> S.unions (map xss (S.toList ks)) = foldMap xss ks
07:30:19 <hexagoxel> and now doubts set in, because not even the extensible-effects implementations are this mad..
07:30:39 <merijn> ertes-w: It's mostly the "k -> Set a" usage that annoys me :)
07:30:40 <ongy> do I want to rfind out how hsboot files work, or create a module for a single data definition?
07:30:53 <ertes-w> merijn: it's a family of sets
07:31:02 <ertes-w> that doesn't seem like a strange notion to me
07:31:12 <ertes-w> 'diff' converts a family of sets into a family of sets
07:31:14 <merijn> ongy: You should feel oddly compelled to fix GHC to properly support cyclic imports automatically
07:31:17 <pierrot> merijn: well, it's an exercise and it was mandatory to use a function like unfoldTree. I know it's an unnatural way of implementing those functions
07:31:34 <ongy> merijn: but that would take long
07:31:50 <ertes-w> ongy: no, it's easy…  you can do it!
07:31:50 <merijn> pierrot: Oh wait, that was about my earlier remark
07:31:56 <hexagoxel> hsboot is easy. sometimes tooling breaks around it, though.
07:32:05 <merijn> pierrot: The paste looks unreadable because it's rendering the entire source on a single line here
07:32:19 <merijn> ongy: But you'd make everyone happy!
07:33:14 <pierrot> meinside: ah, I had misunderstood you
07:33:43 <pierrot> merijn *
07:36:58 <ongy> do I need to mention the .hs-boot file in my .cabal file?
07:38:15 <ongy> ah, had to remove dist-newstyle for it to work
07:39:04 <mrkgnao> how do I verify a downloaded file against a PGP .sig?
07:39:27 <mrkgnao> I'm looking at hOpenPGP now, but the Hackage docs seem to be broken. :(
07:39:29 <Cale> ongy: What was happening? It wasn't including the hs-boot file in the sdist?
07:40:06 <ongy> didn't have it in the build directory. probably because the file that got the hs-boot attached already compiled earlier and cabal didn't pick it up to recompile
07:40:07 <merijn> Cale: new-build has a tendency to be a bit...aggressive in it's caching
07:40:33 <merijn> Cale: Which leads to it occasionally concluding that nothing has to be done despite files having been changed
07:40:43 <mrkgnao> plus it seems like it hasn't been updated in a while.
07:40:51 <Cale> merijn: ahhh
07:41:09 <mrkgnao> does anyone know what I could use here, or should I just shell out?
07:41:22 <ongy> I never changed the input files for module A, I added a new one, that the main file doesn't know about
07:41:32 <ongy> so I'm not that surprised it didn't pick it up for recompilation
07:48:47 <chuzz[m]> anybody here has used http://lambda.inf.elte.hu/fp/UsersGuide_en.xml ? It looks nice, but does not build with stack
07:56:43 <dragon_> is there such a thing as a map comprehension
07:56:54 <ertes-w> mrkgnao: i'd shell out
07:57:16 <dragon_> is there a better way to do this : [ x | x <- toList $ Map.filter pred amap]
07:57:53 <ertes-w> dragon_: toList (Map.filter pred amap)
07:57:54 <_sras_> Using stack,  how can I see if a package is present in the global package db?
07:58:04 <dragon_> isn't it the same ? 
07:58:34 <ertes-w> dragon_: yes, it is, but it's "better", because less syntactic redundancy =)
07:58:43 <ahihi> [ x | x <- xs ] is the same as xs
07:58:46 <sm> _sras_: stack exec -- ghc-pkg list PKT
07:58:48 <sm> PKG
07:58:48 <ahihi> did you intend something different?
07:59:29 <dragon_> no no I just "cut" the list comp a fair bit
08:00:58 <merijn> hmmm, should I use Text.Read, Text.ParserCombinators.ReadP or Text.ParserCombinators.ReadPrec?
08:03:46 <roi_du_silence> hhmmm
08:04:01 <roi_du_silence> is it more efficient to use the HashMap foldr on the values
08:04:14 <_sras_> sm:  is this command supposed to download the build plan?
08:04:22 <roi_du_silence> on the map itself*
08:04:23 <roi_du_silence> or is it the same as using the list foldr on the values 
08:05:09 <roi_du_silence> eg DHS.foldr min minval amap vs foldr min minval $ toList amap
08:05:19 <roi_du_silence> sorry, tired.
08:22:38 <sm> _sras_: no ?
08:23:34 <sm> did you mean ghc-pkg's (local) global package db, or the stackage or hackage package dbs ?
08:23:38 <_sras_> sm: Ok. Finished downloading of the index. I can see the packages now. 
08:24:19 <_sras_> sm: But the problem I am having now is these packages fail to link with the generated executable in the build step....Can you think of any reason for that?
08:24:38 <ertes-w> roi_du_silence: folding the data structure directly is at least as efficient as converting to list first
08:25:00 <ertes-w> roi_du_silence: in the best case they're equal, in the worst you pay for the conversion (e.g. if fusion doesn't kick in)
08:25:15 <sm> _sras_, you'll need to show more details
08:28:35 <_sras_> sm: I am trying to prepare a docker container with all the haskell package dependencies (for our app) preinstalled.  I was able to build the image using the 'stack-docker-image-build' tool. But when I do the build using it, it generate all these linker errors.
08:28:48 <sm> like in http://lpaste.net/359106 ?
08:28:51 <_sras_> sm: http://lpaste.net/359106
08:28:59 <_sras_> sm: Yes
08:31:48 <sm> I don't know the reason, maybe https://github.com/ekmett/distributive/issues/9 has some ideas
08:37:33 <roi_du_silence> ertes-w: thanks
08:44:08 * hackagebot uuid-crypto 1.1.1.0 – Reversable and secure encoding of object ids as uuids – https://hackage.haskell.org/package/uuid-crypto
08:44:08 * hackagebot cryptoids 0.2.0.0 – Reversable and secure encoding of object ids as a bytestring – https://hackage.haskell.org/package/cryptoids
08:52:39 * hackagebot classy-prelude 1.3.0, classy-prelude-conduit 1.3.0, classy-prelude-yesod 1.3.0
08:52:39 * hackagebot  → https://hackage.haskell.org/packages/recent
08:57:56 <Yotam_> data Foo = Foo { baz :: Int -> Int, bam :: Int -> Char }, data Bar = Bar { baz :: Int -> Int } is there a way to pattern match baz from both types?
09:00:02 <NemesisD> i'm confused about DuplicateRecordFields. data Person = Person { name :: String}; data Pet = Pet { name :: String }, putStrLn (name (Person "bob")) gives me an ambiguous occurrence "name"
09:00:16 <NemesisD> how is this not inferrable?
09:01:35 <NemesisD> however putStrLn (name (Person "bob" :: Person)) works. i don't understand why that specification would be necessary
09:03:54 <osa1> I'm considering switching to hpack -- anyone aware of any drawbacks of using hpack compared to good old .cabal files?
09:05:17 <sm> added complexity (extra build step, extra commits))
09:05:59 <sm> to make it worthwhile, your cabal file should probably be non-trivial 
09:06:27 <c_wraith> NemesisD: DuplicateRecordFields does *no* inference.
09:06:36 <sm> well, that's a bit strong. Some might prefer it in all cases
09:07:12 <c_wraith> NemesisD: it will only work when there is a specified (not inferred) type for its argument
09:09:16 <osa1> sm: fair enough. btw I think stack can directly run hpack project without requiring an extra step for generating .cabal manually
09:09:35 <sm> yes, it does
09:09:39 <Athas> Yeah, it's great.
09:09:44 <Athas> I don't have a .cabal file at all.
09:09:57 <sm> Athas: you mean, you don't commit it ?
09:10:03 <Athas> sm: yes.
09:10:10 <osa1> sm: yes
09:10:24 <sm> this must be a project not published on hackage I guess
09:10:42 <Athas> Right.  This is a program, not a library.  Putting it on Hackage isn't useful anyway.
09:10:51 <NemesisD> c_wraith: is it not possible to do the inference in the future? doesn't really seem worth using if you have to annotate all call sites
09:11:08 <Athas> Although to be honest, the .cabal file generated by hpack is not uglier than the one I would write by hand.
09:11:22 <Athas> I would not hesitate to commit it to the repository if I wanted to go on Hackage.
09:11:39 <sm> for hackage packages, you need the cabal file.. which means committing both package.yaml and *.cabal updates.. which is a slight pain. It would be nice if cabal could read package.yaml natively
09:11:44 <lyxia> NemesisD: it is possible but GHC is looking for a not-too-ad-hoc solution
09:12:08 <c_wraith> NemesisD: The plan was for 3 extensions.  DRF is just the first.  Plans got derailed after it, though.  So the current story is "someday"
09:12:09 <Athas> sm: or alternatively, if the .cabal format was better.
09:12:10 <johnw> I really like hpack, I use it in all my projects now
09:12:13 <johnw> it pretty much always reduces the amount of things I have to type and maintain
09:12:22 <sm> yep, it's great
09:12:23 <NemesisD> i see. thanks
09:12:32 <Athas> It's not that I care particularly much about package definition formats, but .cabal just has too much bloody duplication.
09:13:33 * hackagebot free-er 0.1.0.0 – An extensible effects library – https://hackage.haskell.org/package/free-er
09:13:42 <sm> it's more machine friendly, less human friendly than hpack's format
09:14:35 <Athas> What do you mean?  Hpack's format can be read by more programs than the .cabal format, so empirically it seems _more_ machine friendly!
09:15:24 <sm> I'm thinking of some arguments I read about how the cabal format is more precise and well specified. It might have been hvr
09:15:52 <johnw> hpack does infer more things
09:15:58 <johnw> so to write a machine reader for you, you have to build that inference
09:16:05 <Athas> YAML is a bit of a messy and complicated format, that's true.
09:16:28 <sm> sure seems to be working fine though.
09:16:52 <hexagoxel> "Plain fields are not allowed in between stanzas"
09:18:24 <c_wraith> the main problem with YAML is that it's a ruby format.  Using it outside of ruby implies you're not using the whole thing.
09:18:53 <NemesisD> you probably don't want to use the "full" YAML that ruby has. its a nightmare
09:19:15 <c_wraith> if you're using something sane, don't call it YAML.  :P
09:20:11 <blackdog> somebody needs to release NotQuiteYAML that only supports the sane bits that 99% of people use.
09:20:19 <sm> isn't that toml
09:20:24 <roi_du_silence> how is yaml insane ?
09:20:30 <NemesisD> its basically just an easier to type json with comments
09:20:30 <blackdog> that's in the windows .ini format, isn't it?
09:20:49 <blackdog> ugh, forgot "sane/insane" is knda ablist
09:20:56 <NemesisD> roi_du_silence: ruby yaml lets you execute code, has stuff for pickled ruby values, weird reference resolution things
09:21:19 <roi_du_silence> sounds like fun
09:21:38 <roi_du_silence> merged TH and .yaml file ? :p
09:21:49 <Athas> While YAML is ugly, I'd rather maintain my 117-line package.yaml than the 767-line .cabal file generated by hpack.
09:22:05 <c_wraith> There was that time when rails would automatically parse yaml-formatted POST arguments.  This led to remote code execution!
09:22:29 <NemesisD> rails, the Extremely Helpful web framework
09:22:46 * hexagoxel slightly related, even more offtopic: http://georgemauer.net/2017/10/07/csv-injection.html
09:23:01 <blackdog> Athas: it's not that yaml is ugly, particularly (i rather like it) - it's more that it's way bigger than you think it is.
09:23:24 <c_wraith> hexagoxel: yeah, I read that and frowned.  I've opened csv files from clients in excel before.  Apparently I should not do that.
09:23:57 <bitemyapp> I like hpack even if yaml is terrifying.
09:24:07 <bitemyapp> toml is much smaller if you want a small-yaml
09:24:36 <blackdog> hexagoxel: oh wow, that's great
09:25:32 <NemesisD> i think hpack approached the problem well: seems like there was no traction in making a more usable cabal specification so they picked a well-known format and did the dang thing. better to discuss format changes once you have something that's working well IMO
09:26:31 <sm> yes. A yaml subset was a pragmatic choice, but it could easily move to another format in future
09:27:12 <sm> doubt it ever will, but it could..
09:28:08 <Athas> NemesisD: totally agreed.  In practice I have had no problems with the choice of YAML, even if I may be ideologically opposed to it.
09:28:40 <Athas> It's interesting how alternative tooling is being built around Cabal-the-library.
09:29:02 <roi_du_silence> there are so many options but none that ditch cabal entirely
09:29:48 <Athas> Cabal-the-library is fine, I understand it.
09:29:54 <Athas> It's also wired into GHC, isn't it?
09:30:15 <roi_du_silence> Is it ?
09:30:22 * sm has been assuming hpack's yaml is a nice safe haskell implementation, but in fact it seems to embed https://github.com/yaml/libyaml which supports I know not what
09:30:28 <Athas> ghc --make certainly seems to invoke Cabal.
09:30:30 <NemesisD> i think there's just a tension there. seems like cabal either by design or circumstance likes to move slow and deliberately and folks get sick of waiting for it or can't get what they want done done
09:30:52 <NemesisD> see stack
09:33:14 <sm> <crickets>
09:34:04 <Athas> Did the stack hackers (FP Complete?) try to get their ideas into cabal-install?  I'm not familiar with the runup to the whole thing.  I'm just a happy user.
09:36:00 <roi_du_silence> I mostly use stack because it makes it easy to crosscompile
09:36:33 <Athas> I mostly use it because it simplifies the compilation instructions for my Haskell program.
09:36:54 <Athas> My users are not (necessarily) Haskell programmers.
09:36:58 <sm> same
09:37:21 <roi_du_silence> I don't have the user problem yet but I totes see how that could help
09:38:47 <Athas> The only thing missing is that 'stack install' should automatically download GHC if necessary (i.e. no 'stack setup').  I think that's either coming or in there now, though.
09:39:12 <NemesisD> by cross compile do you mean static linking? because i've not had an easy time with that an i'm currently provisioning a cloud build machine for this very reason :(
09:39:21 <roi_du_silence> why is the GHC download from stack so slow 
09:41:10 <roi_du_silence> NemesisD : I have my haskell projects on a separate partition. I can just run stack install on Linux/win 
09:41:44 <roi_du_silence> I can also run wine stack install and wine64 stack install 
09:42:07 <roi_du_silence> What are your problems with static linking ?
09:43:41 <NemesisD> roi_du_silence: it does not seem to have first-class support. i saw some article claiming you could pass --ghc-options with optl-static and i think a pthreads flag but that immediately ran into issues and it would seem i would need to blow away my project and global stack caches and recompile everything
09:45:05 <roi_du_silence> huh hoh
09:46:00 <roi_du_silence> I never tried to static-link.. but maybe I should
09:46:12 <NemesisD> https://github.com/commercialhaskell/stack/issues/3420 has more info. its being looked at but it sounds like internally they need to arrange things so that the statically linked artifacts are separated
09:50:17 <roi_du_silence> I was totally unaware of this
09:54:49 <roi_du_silence> Hope you manage to find a solution ! =)
09:57:52 <michalrus> Hey, it’s the n-th time I’m writing `(\i -> (i,) <$> findCreateBCast i) `traverse` [1,2,3]` — how to shorten that?
09:58:50 <michalrus> I.e. for some keys return a map from those keys to vals, given `find :: key -> m val`
10:00:30 <michalrus> I’m hoping maybe for something using (&&&) or I dunno. =b
10:00:44 <lyxia> :t (&&&)
10:00:46 <lambdabot> Arrow a => a b c -> a b c' -> a b (c, c')
10:01:20 * michalrus scratching head
10:01:42 <lyxia> not really
10:03:05 <lyxia> let is = [1,2,3] in zip is <$> traverse find is  ?
10:04:20 <lyxia> for is $ \i -> (i,) <$> find i    looks neater, maybe?
10:04:50 <michalrus> Nice! Avoids \, but I still need to bind with let to use the list once only, hmmm.
10:04:55 <michalrus> :t (for)
10:04:56 <lambdabot> (Applicative f, Traversable t) => t a -> (a -> f b) -> f (t b)
10:05:15 <michalrus> Ü, flipped traverse. (ﾉ^_^)ﾉ
10:06:09 <michalrus> OK, thank you! I need to go, if anyone has any idea, please highlight me and I’ll make sure to read all them! Thank you!
10:06:46 <michalrus> s/any ideas/some more idea/, forgive that passive aggressive wording, lyxia. =)
10:06:55 <michalrus> *ideas arghhh
10:09:06 <lyxia> haha
10:11:22 <bgamari> If anyone has some time, a review of this would be appreciated: https://github.com/haskell/text/pull/200
10:11:41 <bgamari> It's an important correctness fix and more eyes are better
10:15:05 <onceuponatimeloo> hello haskellers I heard haskell not at a good language to learn algoithms with true?
10:16:38 <nshepperd_> michalrus: maybe this could be a Data.Map function. generateA :: (Applicative f) => [a] -> (a -> f b) -> f (Map a b)
10:17:48 <Myrl-saki> is `:: [Char]` really that bad/
10:17:53 <inkbottle> [noob] is/has: "a type is an instance of a typeclass" vs. "type a has an instance of Eq"; I don't understand the terminology "has"
10:18:12 <mnoonan> onceuponatimeloo, possibly true. lots of algorithms are often describe as using mutable state, which is not quite straightforward.
10:18:29 <mnoonan> e.g. the very first algorithm on the wikipedia page
10:18:42 <Myrl-saki> I don't see much problem with `:: [Char]`. I find it convenient that a lot of functions work on it. Can someone change my view?
10:19:03 <onceuponatimeloo> mnoonan:  so with haskell we cant solve algorithms then what we will do ?
10:19:49 <aarvar> onceuponatimeloo: heard from who
10:19:58 <mnoonan> onceuponatimeloo: you can, it is just either noisier (for a direct translation) or more subtle (for a translation to pure data structures). so if you are learning algorithms for the first time from a typical source, imo haskell would mostly just add obstacles.
10:21:02 <onceuponatimeloo> aarvar:  google
10:21:37 <inkbottle> [is/has] It seems I have some answer here: https://www.quora.com/In-Haskell-is-it-technically-correct-to-say-X-has-an-instance-of-typeclass
10:24:11 <_sras_> What is actually happening when a 'stack build' errors out with a linker error such as "/usr/bin/ld: cannot find -lHSopaleye-0.5.4.0-BRLCqVY9AJXBFXQwXTO0hf "?
10:27:28 <nshepperd_> Myrl-saki: [Char] is very inefficient in time and memory
10:28:20 <Myrl-saki> nshepperd_: Right, but it's also the most flexible to handle, right?
10:28:31 <onceuponatimeloo> mnoonan:  so what can be good language to learn algorithms with ?
10:28:44 <nshepperd_> But it's not really bad if the strings in your program are only short things like "hello world"
10:29:12 <aweinstock> Haskell's pretty good at stateful algorithms, just use Control.Monad.ST
10:29:17 <aweinstock> (and Data.STRef)
10:29:36 <nshepperd_> Myrl-saki: well, Data.Text has functions for everything you can do with lists
10:30:22 <mnoonan> aweinstock: *cough*UNION-FIND*cough*
10:31:07 <aweinstock> mnoonan: I thought that union-find's asymptotic efficiency was one of the motivations for ST in the first place?
10:32:42 <dsal> So, I've got taffybar installed from cabal, but it complains about -rtsopts not being enabled.  How do I make that not be the case?
10:32:43 <mnoonan> aweinstock: i guess it's ok, except that all of the users of your disjoint-sets have to work in ST too. but now that I say it out loud, it doesn't seem so bad.
10:33:29 <aweinstock> mnoonan: that's correct; reading the disjoint set needs to be able to mutably update the parent pointers, so it needs to live in ST for type-safety
10:34:18 <mnoonan> fair enough, I take back my snarky cough :)
10:37:20 <Myrl-saki> nshepperd_: Thanks.
10:45:01 <_sras_> Why can't stack build link to globally installed haskell pacakges?
10:46:16 <onceuponatimeloo> aweinstock: mnoonan  should I continue with haskell then ?
10:51:10 <_sras_> When stack compiles an external package listed in the .cabal file, where does it place the generated .so file in? Where are the .so files for globally installed packages?
10:54:30 <aweinstock> onceuponatimeloo: your choice, it depends on what your goals are
10:54:56 <onceuponatimeloo> aweinstock:  my goals are to get a job in programming
10:55:04 <aweinstock> some of Haskell's tradeoffs/design choices are easier to appreciate once you've known a variety of languages
10:55:07 <onceuponatimeloo> if possible top companies
10:57:20 * hackagebot dhall 1.7.0 – A configuration language guaranteed to terminate – https://hackage.haskell.org/package/dhall
10:58:27 <sm> python and haskell are both good for learning
10:59:01 <shapr> but Haskell is powerful magic
10:59:06 <shapr> python is ... well it's okay.
10:59:24 <shapr> I mean, I teach Python twice a week to my coworkers, and only once a week to anyone in Atlanta
10:59:56 <aweinstock> python's ok until you get to more than 100 lines or you end up wanting parallelism
11:00:12 <shapr> I agree
11:00:35 <shapr> I recently had to fight some TCP fragment reassembly code in Python, I gave up after a month.
11:01:58 <maerwald> python is nice for prototyping
11:02:06 <maerwald> if you use it for something else, then you are an odd person :>
11:02:11 <shapr> I usually prototype my Python code in Haskell
11:02:18 <maerwald> you are odd
11:02:28 <shapr> not even!
11:03:28 * hackagebot monad-persist 0.0.1.3 – An mtl-style typeclass and transformer for persistent. – https://hackage.haskell.org/package/monad-persist
11:04:51 <onceuponatimeloo> shapr:  do you eventeach online?
11:05:27 <shapr> nah, I teach in person
11:08:36 * hackagebot monad-persist 0.0.1.4 – An mtl-style typeclass and transformer for persistent. – https://hackage.haskell.org/package/monad-persist
11:09:52 <onceuponatimeloo> I have a algorithms course a mooc but it uses only psedo code, If I dont know any language and can learn algorithms with psedo code what are my chances of obtaining job ?
11:10:36 <lyxia> low
11:11:02 <Ero2> why does hackagebot occassionally talk about a package?
11:11:12 <hydraz> it announces updates, presumably
11:11:43 <onceuponatimeloo> lyxia:  to me
11:15:27 <tdammers> hackagebot used to announce all hackage uploads, but I believe it has been rate limited now
11:17:22 <lyxia> when there are a lot at the same time it squashes them
11:18:06 <sm> yes, it was taken over and enhanced by (nick, anyone ?) and now does a better job of eliding large batch uploads
11:18:18 <sm> but it does seem not to be active all the time
11:21:45 <sm> it's a https://github.com/lfairy/hircine bot now
11:28:37 <maerwald> wasn't there an experimantal MS language that started with 'k' something?
11:28:51 <maerwald> or 'c'?
11:28:52 <maerwald> :>
11:29:30 <maerwald> ah, it was Koka 
11:33:57 * hackagebot dhall-json 1.0.7 – Compile Dhall to JSON or YAML – https://hackage.haskell.org/package/dhall-json
11:34:23 <sm> soo, how about that https://github.com/volhovM/orgstat#examples eh
11:41:20 * hackagebot dhall-bash 1.0.5 – Compile Dhall to Bash – https://hackage.haskell.org/package/dhall-bash
11:54:31 * hackagebot dhall-text 1.0.3 – Template text using Dhall – https://hackage.haskell.org/package/dhall-text
12:00:56 <cocreature> any ideas what could be causing “too many pending signals”?
12:01:12 <cocreature> I first thought it might be unsafe FFI calls but after sed’ing them all to safe, I still have the same problem
12:01:47 <monochrom> Maybe something is blocking all signals?
12:01:57 <monochrom> Or maybe some signals.
12:02:11 <cocreature> right, my question was is there some standard Haskell construct that I might be using that blocks signals?
12:02:17 <cocreature> because I’m not deliberately blocking them :)
12:04:06 <monochrom> No I don't think there is one. I'm thinking of the C side. Some C function decides to block signals.
12:04:26 <cocreature> hm okay
12:05:06 <cocreature> sadly LLVM is not exactly a minimal example making this quite painful to debug :/
12:21:29 <cocreature> wtf, strace suggests that the signals are SIGSEGV
12:21:40 <cocreature> I really shouldn’t be allowed to do FFI
12:22:07 <mnoonan> a whole pile of segfaults backing up.. impressive :)
12:23:01 <cocreature> I’m not sure how that’s even possible, afaik I only have one thread and I’m not sure how a single thread can segfault multiple times …
12:29:28 <orzo> Is there a defined ThreadId value that is invalid?
12:31:31 <nicknight> postponing to learn haskell due to the fear of security :(, anyway feeling proud I tried and learned something in a week
12:31:33 <orzo> How expensive is it to update a single field of a fairly large record?
12:31:44 <mnoonan> security?
12:32:09 <nicknight> Yuppp noy cyber secury financial sec*
12:32:36 <nicknight> I see haskell is hard to implement
12:33:41 <orzo> i'd trust a haskell ap over a C one
12:33:48 <orzo> typically
12:33:58 <nicknight> ap ??
12:34:01 <orzo> program
12:34:11 <orzo> application
12:34:38 <orzo> what language do you consider more secure?
12:35:44 <nicknight> orzo:  rght now python because all fucking emplaoyers look for only them these days when considered to atleast machinelearning...i see so many job adds 
12:36:01 <orzo> hm, that's crazy to my thinking
12:36:06 <nicknight> why ?
12:36:12 <nicknight> whats crazy ?
12:36:30 <orzo> feeling more secure with python over haskell
12:36:39 <orzo> my bias would be opposite
12:36:49 <nicknight> orzo:  I am taking talking about code
12:36:54 <nicknight> not*
12:37:33 <orzo> what else is there?
12:37:39 <nicknight> code haskell is more safe as I found but I am talking about reality/industry
12:38:28 <nicknight> Any language will die if it is not productive[people dont use it]
12:38:31 <zillolo> nick is talking about job security I believe
12:38:36 <orzo> oh
12:38:53 <orzo> haskell is not going anywhere imo
12:39:31 <nicknight> zillolo: yeah
12:39:34 <WarzoneCommand> Is anyone here using stack on FreeBSD? 
12:39:45 <nicknight> orzo:  anywhere == forward or backward?
12:40:19 <orzo> anywhere = to the grave
12:40:34 <orzo> anytime soon
12:40:48 <nicknight> WHat is the use only if few smart people use it
12:40:57 <[exa]> WarzoneCommand: I attempted it successfully like 3 months ago, but don't have the installation handy
12:41:06 <orzo> a few years ago maybe i'd agree
12:41:12 <[exa]> nicknight: would you say the same about cobol?
12:41:25 <WarzoneCommand> the binary that it produces (of my project) crashes during runtime with an "Illegal instruction (core dumped)". From some quick googling that may have to do something with some different versions of llvm being available or so, but I don't fully understand what's happening there.
12:41:29 <nicknight> [exa]:  cobol isnt dead ?
12:41:31 <orzo> but nowadays i can bring up haskell to a random programmer and they'll be familiar and have some thoughts on it
12:41:56 <[exa]> nicknight: sadly not :D just wildly unpopular, just like haskell was few years ago
12:42:15 <[exa]> nicknight: haskell programmers are just beginning to get mainstream in fact
12:42:32 <orzo> yes, that's my impression
12:42:37 <orzo> we're going mainstream
12:44:05 <nicknight> [exa]:  Even I wanted to work on haskell but I can't risk/invest my time as I did for one week because at the end of the day all are not phd guys or well setteled programmers.....to people who are depended on jobs cant seriously go things like haskell...I checkes haskell 2 years back but till now I am the same 
12:44:34 <nicknight> checked*
12:44:45 <nut> Anyone knows how to change file name with the Turtle script? for example, change file.mp4 to file.mp3 ?
12:45:26 <[exa]> nicknight: that sounds rough, don't you have like 30 minutes every other day to play with stuff?
12:46:23 <[exa]> btw I might be biased but I don't believe in investing time to learn something. you just keep a book+console around and it comes itself
12:47:10 <nicknight> [exa]:  yes, because I am already doing a fake job evethough I resigned I have to managethat job and also get new one in couple of months or my life will be hell...in fact I am spending 15hours learning Ml and 0.5/1 hr here at IRC to relax
12:47:24 <nicknight> 5*
12:48:38 <nicknight> anyway its not even important I willbe back to haskell soon
12:48:59 * [exa] sends a virtual beer to augment minor relief
12:49:51 <yushyin> nut: https://hackage.haskell.org/package/turtle-1.4.4/docs/Turtle-Prelude.html#v:mv
12:53:29 <nut> yushyin:i'm suffering from reading that doc
12:54:13 <nut> not many example usage
12:58:34 <orzo> what's a good word for the inverse probability, so (1 - p) where p is the "bias" or "weight" ?
12:59:47 <shloub> complement?
13:00:33 <orzo> i'm thinking "aversion" or "cost" but i'm unsatisfied
13:00:43 <orzo> don't care for "compliment" either
13:00:58 <shloub> antibias?
13:01:06 <orzo> i like that
13:03:02 <tobiasBora2> Hello,
13:03:43 <tobiasBora2> I'd like to know, is it possible to map an array into a list like that
13:03:51 <tobiasBora2> (a -> b) -> Array a -> [b]
13:07:31 <[exa]> :t \f -> foldr ((:).f) []
13:07:33 <lambdabot> Foldable t => (a1 -> a2) -> t a1 -> [a2]
13:07:49 <[exa]> tobiasBora2: this ^^ should be applicable on Array (which is Foldable)
13:12:03 <dmwit> :t \f -> Data.Array.elems . fmap f
13:12:05 <lambdabot> (a -> e) -> Array i a -> [e]
13:12:42 <yushyin> nut: I’m not familiar with the turtle library but nevertheless here an example https://paste.xinu.at/5TQ/
13:14:18 <tobiasBora2> [exa]: dmwit ok thanks ! Is there any interest to use one or the other ?
13:17:46 <[exa]> tobiasBora2: depends on whether you mind array-specificity and on exact behavior of Array's Functor instance which I can't find now, but I guess actual difference will be minor
13:18:07 <tobiasBora2> ok thanks [exa] 
13:48:10 <balor> I've been browsing http://git.haskell.org/ghc.git to find tests for modules in Prelude (I like to read test code to see idiomatic use of a function). It appears that there is no requirement to write a unit test for a given module in Prelude i.e. not all modules (very few in fact) have associated unit tests.  Am I looking in the wrong place? Or is it the case that there is no policy for unit testing modules?
13:52:15 <orzo> there should be a contramap-based deriving mechanism.  So you specify a function that converts to a type and it shares the instance for that type with your new type
14:02:30 <royal_screwup21> is there a built-n function to extract boxes out of a matrix? For example, if I have a 9 x 9 matrix, I want 3 x3 "boxes" out of it, just like in a sudoku puzzles
14:02:34 <royal_screwup21> built in*
14:07:31 <Hafydd> royal_screwup21: what is the type of your "matrix"?
14:07:58 <royal_screwup21> just a list of lists
14:08:20 <Hafydd> royal_screwup21: there isn't a built-in function just for that, but you can do it with take, drop, and fmap.
14:08:49 <Hafydd> The middle submatrix would be "fmap (take 3 . drop 3) . take 3 . drop 3".
14:09:22 <Hafydd> ...or just "map" instead of "fmap".
14:09:40 <royal_screwup21> hmm
14:16:04 <royal_screwup21> Hafydd: how'd you approach the problem
14:16:16 <royal_screwup21> I'm having a hard time figuring this out
14:25:12 <Logio> royal_screwup21: are you building a sudoku puzzle, or something else?
14:25:49 <royal_screwup21> a sudoku puzzle
14:26:55 <Logio> it might be easier to just use a single list, and build suitable indexing functions for it 
14:26:59 <Hafydd> royal_screwup21: what is it that you want to do, exactly?
14:27:25 <Hafydd> For example, do you want to extract a single submatrix, or do you want a list of all submatrices?
14:27:33 <Logio> if you don't want to get into any more complicated data types, that is 
14:27:34 <royal_screwup21> all submatrices
14:28:18 <Logio> royal_screwup21: all possible submatrices, or adjacent blocks?
14:28:21 <royal_screwup21> hmm for that I might have to refactor most of my code, but that seems interesting, using indexing functions
14:29:23 <royal_screwup21> sorry yeah that's an important distinction. I need adjacent blocks
14:30:56 <Tuplanolla> How about a `Map (a, a) a`, royal_screwup21?
14:32:47 <Hafydd> royal_screwup21: http://lpaste.net/359123
14:33:03 <Hafydd> royal_screwup21: this is a more efficient version that uses splitAt, but that's equivalent to using take and rop.
14:33:07 <Hafydd> *dro
14:33:07 <Hafydd> ...*drop
14:33:16 <Hafydd> > drop 1 "drop"
14:33:19 <lambdabot>  "rop"
14:34:06 <Tuplanolla> You could select the subregion at `x` with `filterWithKey (\ y _ -> dist x y <= 1)`.
14:35:27 <Tuplanolla> There the metric `dist` would determine the shape and size.
14:36:09 <royal_screwup21> Hafydd: are you a genius
14:36:30 <Hafydd> royal_screwup21: I hope one doesn't have to be a genius to write or understand that code.
14:37:00 <royal_screwup21> lol nice backhanded compliment
14:37:16 <Hafydd> royal_screwup21: is it clear how it works?
14:37:35 <royal_screwup21> yeah I might have to write it out and visualize it first
14:37:37 <royal_screwup21> but thanks!
14:38:05 <Hafydd> Very well.
14:49:34 <hexagoxel> what is rationale behind the convention of putting the in-package imports last?
14:50:34 * hackagebot uuid-crypto 1.2.0.0 – Reversable and secure encoding of object ids as uuids – https://hackage.haskell.org/package/uuid-crypto
14:54:24 <Cale> hexagoxel: Well, sometimes they're the only thing you care about, so it's nice for them to be separate.
14:54:41 <Cale> hexagoxel: First or last doesn't particularly matter
14:54:49 <geekosaur> also it supports use of project templates
14:54:55 <geekosaur> and global templates
15:06:04 <hexagoxel> yeah, separation makes perfect sense. i only seem to prefer explicit imports last, and in-package are implicit mostly.
15:14:02 * hackagebot uuid-crypto 1.3.0.0 – Reversable and secure encoding of object ids as uuids – https://hackage.haskell.org/package/uuid-crypto
15:30:47 <royal_screwup21> Suppose I have a datatype like so: data FOO = [Int]. So it's a list of ints. Now I want to add 1 to every element to FOO [1,2,3] like so: map (+1) FOO [1,2,3]. But this returned an error https://thepasteb.in/p/1jhnN0poqmjSB What am I doing wrong?
15:38:29 <mpickering> There are a few things that look wrong
15:39:19 <mpickering> I presume you have written data FOO = FOO [Int]
15:39:28 <dmwit> > map (+1) [1,2,3] -- I propose that you skip all the FOO stuff entirely
15:39:30 <lambdabot>  [2,3,4]
15:40:10 <royal_screwup21> ah yes data FOO = FOO [Int] shit I'm sorry, I'll be more careful next time
15:40:37 <royal_screwup21> but even so
15:40:52 <dmwit> In that case you probably just need more parentheses.
15:40:57 <dmwit> ?let data FOO = FOO [Int]
15:40:59 <lambdabot>  Defined.
15:41:19 <dmwit> Ah. No, there is another problem: `map` applies only to lists, not to `FOO`s.
15:42:03 <dmwit> So you will need to unwrap the list from the `FOO` type first if you want to use `map`.
15:42:16 <dmwit> e.g. you could write `unFOO :: FOO -> [Int]; unFOO (FOO x) = x`.
15:42:36 <dmwit> > let unFOO (FOO x) = x in map (+1) . unFOO $ FOO [1,2,3]
15:42:39 <lambdabot>  [2,3,4]
15:42:57 <dmwit> ?undefine
15:42:58 <lambdabot> Undefined.
15:43:06 <dmwit> ?let data FOO = FOO [Int] deriving (Eq, Ord, Read, Show)
15:43:08 <lambdabot>  Defined.
15:43:12 <dmwit> > let unFOO (FOO x) = x in FOO . map (+1) . unFOO $ FOO [1,2,3]
15:43:16 <lambdabot>  FOO [2,3,4]
15:46:45 * hackagebot htoml-megaparsec 1.0.0.4 – Parser for TOML files – https://hackage.haskell.org/package/htoml-megaparsec
15:49:31 <royal_screwup21> I was trying to piece together small parts of my module but I guess it'd be a better idea if I just showed the whole thing. This is it https://thepasteb.in/p/66hVYgPrr6PCW Now I *have* to use the data mentioned in the first 2 lines. When I try to compile it, I get this error: https://thepasteb.in/p/Vmh0oE2l6ZmH4 I'm doing something wrong with the d
15:49:31 <royal_screwup21> atatypes in the last function, but I'm not sure what.  I wrote it assuming "cells" is a list of list of characters
15:53:40 <lyxia> royal_screwup21: what is the type of cols
15:54:08 <royal_screwup21> cols :: Sudoku -> [[Cell]]
15:54:10 <lyxia> royal_screwup21: it expects a Sudoku as an argument
15:54:14 <lyxia> royal_screwup21: map ... is a list
15:55:11 <royal_screwup21> oh
15:58:18 <royal_screwup21> lyxia so is this wrong as well "map (bundle 3) cells"? I think it is because "cells" is a Sudoku list of list of characters, and map works on vanilla lists, not on Sudoku lists
16:11:30 <lyxia> cells is a list
16:12:10 <lyxia> It's the field of the Sudoku constructor, which has type [Cell]
16:12:47 <royal_screwup21> ah okay, so that line would work
16:20:40 <royal_screwup21> To break up the problem, I tried this: https://thepasteb.in/p/Mjhx4L2BOXKFV This compiles. But when I type in on the interpreter "rows Sudoku ["123","456"]", it gives me an error: https://thepasteb.in/p/k5hYzRkyX4jiE
16:22:21 <lyxia> what you typed is rows applied to two arguments, Sudoku and ["123","456"]
16:22:27 <royal_screwup21> oh shit I didn't put parantheses
16:29:38 <felix1> esod
16:30:00 <felix1> sorry, irc client slow, was joining #yesod :)
16:31:19 <felix1> anyway, very quite in #yesod and my question could be understood more generally: in other web frameworks there's often the idea of internal events so that subsystems can be loosly coupled (I am thinking of an audit log)
16:31:40 <felix1> How would I go about approaching this in #yesod or in Haskell more generally speaking
16:31:53 <felix1> s/#yesod/Yesod/
16:44:03 <Tehnix_> felix1: yesod is usually quite dead :/
16:45:45 <Tehnix> felix1: could you expand a bit more on that? Or perhaps examples from other places?
16:52:03 <felix1> Tehnix: of course, for example in Django we have "Signals". The API is actaully quite shoddy but it's useful none the less https://docs.djangoproject.com/en/1.11/topics/signals/
16:53:30 <felix1> Tehnix: in wordpress you have "hooks" which are quite different but solve the same problem to some degree
16:55:12 <felix1> Tehnix: I am not set on the idea of this, but the problem I need to solve is adding logging and keeping an audit log without sprinkling the logic everywhere
17:09:46 <Tehnix> felix1: Ah, so a way to set up signals all over the place, and then later on register handlers for them?
17:09:56 <Tehnix> I don't think there's anything inherently unique about it
17:12:21 <Tehnix> You could have a Signal datatype, then create a signal function that you call supplying whatever type matches your event. The signal could then case on each Signal type and handle ones you have anything to do on
17:13:23 <Tehnix> This will mean that you have all your Signal types at one place, and at least the glue code for the handlers there too, but the handler code itself could just be from an import 
17:14:02 <Tehnix> Dunno if you were hoping for more separation, which would take some other approach that my coffee riddled mind hasn't come up with yet
17:15:50 <felix1> Tehnix: no what you described is what I am after. I guess I would use conduit or pipes for the job?
17:16:14 <felix1> With some custom type class constraint on my `m`s everywhere?
17:16:58 <felix1> I guess what I am unsure about is just how it will fit into the Yesod way of doing things, I have not fully grasped how a process is spawned in rsponse to a request
17:17:13 <felix1> It would need to fork a computation somewhere to handle each event in parallel
17:18:21 <felix1> For example, I could use pipes-concurrent to set up a channel, then send to that channel from my handlers etc. Then `runEffect` the producer the channel gives me (fromInput) and handle each event
17:19:09 <felix1> I was hoping for some examples of it or if there's sth more high level, or things to watch out for (for example db handle sharing, not sure what sort of guarantees around locking yesod provides me with here)
17:19:33 <Tehnix> felix1: IIRC each request in Yesod spawns a thread (light weight in Haskell) which handles the request and response
17:23:50 <Tehnix> You would in your handler then call `signal $ NewUser username` where your signal function could be `signal NewUser username = forkIO something..`
17:24:41 <Tehnix> felix1: You could do queues either in DB/Redis or in memory in Channels
17:25:09 <Tehnix> For scalability I would go with DB/Redis, else you're blocking yourself from horizontal scaling later on
17:25:09 <felix1> queues in DB/Redis?
17:25:33 <felix1> Could you explain that concept to me, that's new to me
17:26:33 <Tehnix> Basically a job queue. You would put each signal into a table and then process them separately. 
17:26:52 <Tehnix> Not my finest code, but I did some quick thing a while ago like that https://github.com/hvisk/campaigns/blob/master/Job/Dispatch.hs
17:27:10 <felix1> nice man :D
17:28:38 <Tehnix> Jesus my code is cluttered ._. I'll compose a quick gist of some code locations
17:29:21 <felix1> don't go out of your way, what's there is more than i could've asked for
17:29:27 <felix1> a new world jsut opened up
17:35:33 <Tehnix> felix1: https://gist.github.com/Tehnix/2feed7479c2e534d59556dbc3ea02bab
17:35:44 <Tehnix> Should save you some digging in the code
17:35:46 <felix1> Tehnix: thank you
17:36:37 <Tehnix> That said, there might be better approaches. https://www.reddit.com/r/haskell/comments/5zvrwz/eve_extensible_eventdriven_application_framework/ looks interesting, and your pipes idea sounded cool too :)
17:37:38 <Tehnix> You could also skip all of this, and simply wrap up some common DB operations you're going to do with the additional logging you want
17:38:25 <Tehnix> Or https://hackage.haskell.org/package/persistent-audit for example
17:41:47 <felix1> I did come across eve, but felt I had to understand the problem  a bit better first. that audit package looks interesting. i wonder though why all packages that are not super popular fall behind in maintenance... just not enough uptake?
17:42:27 <Tehnix> yeah, that is a super annoying thing with Yesod
17:43:03 <Tehnix> It's definitely being actively used (Yesod), but juuuuuust too little for people to keep maintanence on their packages in the long term beyond their own need :/
17:53:32 * hackagebot sessiontypes 0.1.1 – Session types library – https://hackage.haskell.org/package/sessiontypes
18:05:45 * hackagebot htoml-megaparsec 1.0.1.0 – Parser for TOML files – https://hackage.haskell.org/package/htoml-megaparsec
18:25:26 <royal_screwup21> So I wrote up a function that, given a sudoku matrix, return elements in adjacent 3 x 3 blocks. I'm not sure if it's right though https://thepasteb.in/p/zmh8oymYmBLhZ I was hoping if someone could point me to the right track
18:39:35 <szehk> hi all, i'm reading on Haskell NG  ; https://stackoverflow.com/questions/29033580/how-do-i-use-the-new-haskell-ng-infrastructure-on-nixos
18:40:28 <szehk> i have read the stackoverflow , Journey Part I Part II , however , i don't know how to start, does anyone know a step by step guide?
18:41:12 <szehk> the author has too many assumptions on the expertise of the users
18:45:13 * hackagebot colorless-scotty 0.0.2 – Scotty server add-on for Colorless – https://hackage.haskell.org/package/colorless-scotty
19:22:24 <funmler> Hi, I was looking at the source code for the Decimal package and I am trying to understand the allocate function. 
19:22:40 <funmler> https://hackage.haskell.org/package/Decimal-0.4.2/src/src/Data/Decimal.hs
19:47:58 * hackagebot validation 0.6.0 – A data-type like Either but with an accumulating Applicative – https://hackage.haskell.org/package/validation
19:52:16 <moet> hello, is there any difference between these two approaches to doing a type assertion (eg. to tets a type family) at compile time? http://lpaste.net/359129
19:52:41 <moet> i think i know of one difference, using `id` doesn't seem to work with Nat-kinded types
19:52:53 <moet> but i'm wondering if maybe somebody knows why?
19:55:36 <slack1256> let say I have a type newtype Mio m a = Mio { runMio :: StateT Int (StateT Char m) a }
19:56:14 <slack1256> to access the inner StateT I defined a helper `mioState = Mio $ lift get`
19:56:56 <slack1256> is there a way to just use make get infer the correct layer for the monad?
20:01:23 <geekosaur> derive MonadState
20:01:32 <geekosaur> oh, te inner one
20:01:44 <geekosaur> not really, unfortunately; MonadState can't find both
20:02:40 <geekosaur> but this is one of those places where I'd argue StateT is not the right solution specifically because it treats both equally. here, you likely want an API based not on structure but on function
20:03:58 <geekosaur> similar to how you might use a generic type variable when something is naturally very polymorphic, but for specific tasks you may want to use a more specific name to help keep things straight
20:04:13 <geekosaur> or likewise for value level bindings
20:15:14 <slack1256> I see. Well is not too bad
20:20:22 * hackagebot tomlcheck 0.1.0.0 – Command-line tool to check syntax of TOML files – https://hackage.haskell.org/package/tomlcheck
20:39:11 <Camm> How to handle `*** Exception: divide by zero`
20:39:12 <Camm> ?
20:39:31 <pacak> Don't divide by zero...
20:40:39 <pacak> @hoogle DivideByZero
20:40:40 <lambdabot> Control.Exception DivideByZero :: ArithException
20:40:40 <lambdabot> Control.Exception.Base DivideByZero :: ArithException
20:40:40 <lambdabot> Network.Google.Sheets DivideByZero :: ErrorValueType
20:41:00 <pacak> :t catch
20:41:02 <lambdabot> Exception e => IO a -> (e -> IO a) -> IO a
20:41:15 <Camm> LOL. I mean using `Control.Exception.Base`. I see functions that are attached to `IO` like http://hackage.haskell.org/package/base-4.10.0.0/docs/Control-Exception-Base.html#v:try 
20:41:34 <monochrom> Yes, you can only catch exceptions in IO.
20:41:40 <Camm> `div 1 0` is not `IO`
20:41:48 <Camm> :/
20:41:53 <pacak> You can't catch exceptions in pure code.
20:41:57 <monochrom> Also, if you don't understand lazy evaluation, you won't even know where to put the catching code.
20:42:16 <monochrom> So you are really better off not letting it happen in the first place.
20:42:27 <pacak> AKA don't divide by zero.
20:43:11 <monochrom> Also, "LOL" is not going to change what we tell you.
20:43:35 <pacak> monochrom: It sure can :)
20:46:37 <Camm> Ok, thank you. The explanation was good. I'm sorry if the question was silly.
20:47:34 <pacak> > 1 / (0 :: Double)
20:47:37 <lambdabot>  Infinity
20:47:45 <pacak> Camm: This might also work.
21:10:59 * hackagebot papa-base-implement 0.3.1 – Useful base functions reimplemented – https://hackage.haskell.org/package/papa-base-implement
21:30:46 * hackagebot servant-static-th 0.1.0.6 – Embed a directory of static files in your Servant server – https://hackage.haskell.org/package/servant-static-th
21:39:48 <dmwit> :t catch
21:39:50 <lambdabot> Exception e => IO a -> (e -> IO a) -> IO a
21:42:11 <dmwit> % catch (Just <$> evaluate (1 `div` 0)) (\(SomeException e) -> return Nothing)
21:42:11 <yahb> dmwit: Nothing
21:43:01 <dmwit> % catch (evaluate (1 `div` 0)) (const (return 3) :: Control.Exception.ArithException -> IO Int)
21:43:02 <yahb> dmwit: 3
21:43:05 <dmwit> yey
21:47:17 * hackagebot papa-base 0.3.1 – Prelude with only useful functions – https://hackage.haskell.org/package/papa-base
21:51:21 * hackagebot papa-bifunctors 0.3.1, papa-bifunctors-export 0.3.1, papa-lens-implement 0.3.1
21:51:21 * hackagebot  → https://hackage.haskell.org/packages/recent
21:52:12 <tippenein> I'm confused about an error from hspec https://hastebin.com/adurenegej.hs
21:53:39 <tippenein> It looks like I'm not fully applying something? I guess I'm not sure how to interpret Arg (m0 ())
21:54:39 * hackagebot papa-lens-export 0.3.1, papa-semigroupoids-export 0.3.1, papa-semigroupoids-implement 0.3.1
21:54:39 * hackagebot  → https://hackage.haskell.org/packages/recent
21:57:01 * hackagebot papa-x 0.3.1, papa-x-export 0.3.1, papa-x-implement 0.3.1
21:57:01 * hackagebot  → https://hackage.haskell.org/packages/recent
21:58:33 <fvr> How does tasty framework handle resources when running in parallel? Does it use the same resource, or creates one for each thread?
22:00:10 * hackagebot papa 0.3.1 – Reasonable default import – https://hackage.haskell.org/package/papa
22:02:57 <sqooq> agh I can't wrap my head around this function I need to write
22:05:10 <erisco> make it smaller, then
22:05:45 <_sras_> Is there any way to force Stack to download the package index from a particular url (want to use a url that is cached locally).
22:06:04 <sqooq> erisco: true
22:06:11 <sqooq> I can't even like type what it is
22:06:20 <sqooq> It's so simple in my head, I can do it manually but like
22:06:30 <sqooq> it rests on future results
22:06:47 <nisstyre> sqooq: that's what undefined is for
22:06:55 <sqooq> i need to check if the result of some math, is closer than the last result
22:07:09 <sqooq> closer to the last result to some number 
22:07:14 <nisstyre> what's your base case?
22:07:14 <sqooq> closer than**
22:07:46 <nisstyre> what is the smallest case as well
22:07:52 <sqooq> I guess if it's greater than last result it just returns the result of the operation
22:08:09 <nisstyre> you could always expand small cases by hand
22:08:15 <nisstyre> to see the structure of it
22:08:20 <sqooq> agh wait that won't work either, what I just said
22:08:24 <sqooq> I'm kind of intoxicated
22:08:29 <sqooq> maybe I should wait till tomorrow
22:08:42 <nisstyre> you could also try using wolfram alpha to generate it :p
22:08:52 <nisstyre> if you can express it as a recurrence relation
22:09:03 <sqooq> I'm trying to find the closest number of a math formula, to an integer
22:09:28 <sqooq> so the target may be 3, the first result may be 1, the second 2.5, the third 3.1, so you know the third is the closest
22:09:31 <nisstyre> I'm sorry I don't really get it
22:09:32 <sqooq> they always increase
22:09:36 <nisstyre> oh
22:09:46 <nisstyre> so you're doing an optimization problem
22:09:47 <sqooq> but like if the third was 3.6
22:09:56 <sqooq> then it should choose 2.5 instead
22:09:58 <sqooq> because that's closer
22:10:15 <sqooq> nisstyre, yeah i guess so
22:10:20 <nisstyre> this sounds like something you would use calculus for
22:10:21 <erisco> you can use maximumBy but it will not short-circuit
22:10:54 <nisstyre> https://en.wikipedia.org/wiki/Gradient_descent
22:12:03 <erisco> or minimumBy
22:12:38 <nisstyre> oh if you just have a list of numbers and you want to find the closest one then yeah use minimumBy or maximumBy
22:12:45 <nisstyre> I thought it was more general than that
22:13:10 <sqooq> I don't think maximumBy is right
22:13:19 <sqooq> it's not maximum number, it's closest number
22:13:22 <nisstyre> you can approximate it with the Rational type maybe too
22:13:33 <sqooq> also i can in fact make a list first, but it will be infinite
22:13:48 <sqooq> a list of the "results" that need to be checked against the desired number
22:13:52 <nisstyre> sqooq: actually I have some code that might do exactly what you want
22:13:55 <erisco> minimumBy for the smallest difference
22:14:22 <sqooq> hmm maybe I should learn how they work first
22:14:23 <nshepperd_> The answer will be either the first number in the list that is greater than 3 or the one just before it
22:14:48 <sqooq> nshepperd_, that is true
22:15:01 <nisstyre> sqooq: you want a Float that is close but not quite equal to an Integer right?
22:15:04 <nshepperd_> So, get those two numbers first, then return whichever of those it's closest
22:15:31 <nshepperd_> (minimumBy won't work on an infinite list)
22:17:48 <sqooq> nisstyre, yes
22:18:09 <sqooq> by doing 2**(num/constant), where num increments evertime
22:18:17 <nisstyre> sqooq: how do you define "close enough" though?
22:18:20 <sqooq> or that can be thought of as the list of numbers to check with
22:18:24 <sqooq> but it's infinite of course
22:18:39 <sqooq> nisstyre: doesn't matter if it's way off, just whichever is closest
22:18:49 <nisstyre> sqooq: this is super old code but it still works https://gist.github.com/nisstyre56/3909034
22:18:57 <nisstyre> it generates something called the stern-brocot tree
22:19:05 <nisstyre> which is an infinite binary search tree of all rational numbers
22:20:57 <nisstyre> so you could search the tree
22:21:02 <nisstyre> and then stop when you get close enough
22:21:17 <nisstyre> you just do normal binary search
22:21:42 <nshepperd_> head . dropWhile ((<3) . snd) $ zip xs (tail xs)
22:22:45 <nshepperd_> ^^ this returns two numbers, one of which is the closest to 3. On the assumption that the list is monotonic increasing
22:22:59 <nisstyre> the tree search may be more efficient
22:23:07 <nisstyre> you can also use Farey sequences
22:23:36 <erisco> that fails when you only have one number
22:24:33 <nshepperd_> I leave the case length xs < 2 as an exercise for the reader
22:24:48 <sqooq> this works
22:24:50 <sqooq> 'minimumBy (comparing (\x -> abs(x-3))) [2**(n/12)|n<-[1..500]]
22:24:51 <sqooq> '
22:24:53 <sqooq> but it's finite
22:25:57 <erisco> do we have a function for difference?
22:26:04 <nisstyre> that's what I was trying to figure out
22:26:13 <nisstyre> if you're looking long enough you'll eventually just get 3.0 for 3
22:26:15 <nisstyre> or whatever
22:26:31 <nisstyre> or 3.000000..1
22:26:37 <nshepperd_> If you have a formula f indexed by an integer, you can also use binary search in the same way
22:27:16 <nisstyre> nshepperd_: https://en.wikipedia.org/wiki/Stern%E2%80%93Brocot_tree
22:27:19 <nshepperd_> nisstyre: I'm assuming that the sequence being searched in is fixed because of some properties required of the answer
22:27:49 <nshepperd_> Ie. It has to be of form 2^(n/12) for whatever reason
22:27:57 <nshepperd_> Not just an arbitrary rational
22:28:05 <nisstyre> oh ok
22:28:15 <nisstyre> I am a bit confused about the requirements here
22:28:20 <nisstyre> what's the actual use of this?
22:29:20 <sqooq> it's for creating timbres that are consonant relative to some tuning
22:30:03 <nshepperd_> search (\n -> f n >= 3) -- 'search' from the binary-search package, returns the first integer n such that f n is at least 3
22:30:24 <nisstyre> if you use stern brocot to approximate e for example, you get this as the process: [2.0,3.0,2.5,2.6666666666666665,2.75,2.7142857142857144,2.727272727272727,2.7222222222222223,2.72,2.71875]
22:30:29 <nshepperd_> Then the answer is either f n or f (n-1), whichever is closer
22:30:40 <erisco> I am going for   \x -> head . last . groupBy (\a b -> a `diff` x < b `diff` x)
22:30:48 <erisco> where  diff a b | a < b = b - a | otherwise = a - b
22:31:37 <nshepperd_> (where f is \n -> 2**(fromIntegral n / 12) in this case)
22:31:56 <erisco> undefined for empty lists, as expected
22:32:20 <sqooq> ok so
22:32:28 <sqooq> i guess this is harder than it seems lmao
22:32:42 * erisco *shrugs*
22:32:45 <erisco> you can steal mine
22:32:49 <sqooq> does that work
22:33:45 <erisco> it is undefined on infinite lists
22:33:46 <nshepperd_> erisco: doesn't that solution fail for infinite lists again
22:35:19 <erisco> explicit recursion may be the most reasonable
22:35:55 <sqooq> shoot
22:35:56 <sqooq> k
22:36:11 <sqooq> i'll see what I can do
22:37:07 <erisco> what you have here is actually hill climbing
22:37:36 <sqooq> should I go the infinite list route
22:37:43 <sqooq> or just build the increment directly into the function
22:38:59 <erisco> climb :: Ord a => NonEmpty a -> a
22:41:51 <nshepperd_> Is the answer likely to be close to the front of the list, such that binary search wouldn't be much faster?
22:41:56 <erisco> first define climb using recursion to find the first peak, sqooq
22:42:02 <fvr> t
22:42:11 <erisco> then the answer to the rest of your problem will become evidently, or hopefully will
22:42:54 <sqooq> idk what you mean by first peak
22:43:07 <erisco> are you familiar with hill climbing?
22:44:16 <sqooq> nope :(
22:44:19 <erisco> a better definition is probably  climb :: Ord a => NonEmpty a -> ([a], a, [a])
22:45:24 <erisco> or  climb :: Ord a => [a] -> ([a], [a])  for possibly empty lists
22:45:46 <nshepperd_> climb :: Ord a => (Integer -> a) -> Integer
22:46:11 <erisco> *shrug* same thing
22:46:35 <sqooq> So Integer is the number I'm checking against?
22:46:40 <nshepperd_> Bonus: has an O(log n) solution if the peak is a global maximum
22:46:52 <erisco> climb :: Ord a => (Integer -> a) -> Integer -> (Integer, a)  for giving a starting point, even
22:47:26 <sqooq> i'm confused
22:47:34 <sqooq> what is climb doing
22:47:41 <erisco> Wikipedia hill climbing
22:47:44 <sqooq> I did
22:47:49 <sqooq> I'm reading it, I kind of understand
22:48:00 <sqooq> I want to know the context of climb to my problem
22:48:10 <sqooq> so this isn't the point that recursion comes in, is it
22:48:25 <erisco> you pick any starting point, and you explore around that point
22:48:43 <erisco> if you find a nearby point which is higher than the previous, you then assume this new point, and keep going
22:48:54 <erisco> eventually you'll reach a local maxima, i.e. a peak, if there is one
22:49:10 <nshepperd_> sqooq: you want to find the integer n such that 2^(n/12) is closest to your target, right
22:49:29 <nshepperd_> Or some variation on that formula
22:49:59 <erisco> so, with the (Integer -> a) version, you start at some x and check x + 1 and x - 1
22:50:17 <sqooq> nshepperd_, close. I want to find the number 2^(n/12) where n increments, closest to another integer m
22:50:19 <erisco> if one is greater than x and the other is not, move to the greater point
22:50:28 <sqooq> so I actually want the result
22:50:30 <sqooq> basically
22:50:31 <erisco> if both are greater, choose the greatest, and if they are the same, choose one arbitrarily
22:50:47 <erisco> if they are all equivalent, stop
22:50:52 <erisco> if both are less, stop
22:51:06 <sqooq> What's the difference between the versions
22:51:15 <sqooq> Caring about empty lists is pointless
22:51:17 <nisstyre> sqooq: so 2**(19.065893/12) == 3.0080414
22:51:19 <sqooq> and my list is ordered
22:51:21 <nisstyre> would that be a valid solution
22:51:23 <nisstyre> for 3
22:51:25 <sqooq> no
22:51:32 <nshepperd_> sqooq: ok, and you can easily get that is you know the right n
22:51:35 <sqooq> n has to be an integer
22:51:35 <nisstyre> why?
22:51:36 <erisco> Integer -> a  is similar to  [a]
22:51:43 <nisstyre> ah ok
22:51:45 <nisstyre> that's harder
22:51:47 <nisstyre> I forgot
22:52:30 <sqooq> erisco: ok erisco, thanks I'm going to try
22:53:35 <erisco> you can keep going if they are all equivalent, biased in one direction, if you wish, it depends
22:54:09 <sqooq> i only evaluate at the end i'm guessing?
22:56:56 <erisco> if you know the approximate real solution, then you can just test the integers that bound it
22:59:31 <erisco> and if you need to find the approximate real solution, there are several numerical methods for that
22:59:37 <erisco> you can change it into a problem of finding roots
23:00:25 <nshepperd_> True. You can just solve 2^(x/12) for *real* x then the answer is either n = floor x or ceiling x
23:00:35 <nshepperd_> Whichever is closer
23:01:12 <erisco> within some margin of error, I should think
23:02:10 * nshepperd_ pretends that floating point numbers are real numbers
23:02:17 <erisco> I suppose if the real is close to an integer it doesn't matter what side it lands on
23:02:32 <erisco> because the close integer will be the answer, and it will exist as either the ceil or floor
23:03:02 <erisco> it only matters if the margin of error is greater than... what... 0.5?
23:03:10 <sqooq> It has to be integers
23:03:27 <sqooq> 2^(x/12) | x elm Int
23:03:44 <erisco> what do you think ceil and floor are for, sqooq?
23:03:46 <sqooq> also in the future I would like to change 12, for now I'm letting it be
23:04:23 <sqooq> erisco: o true. Does that actually work?
23:04:28 <sqooq> That's way easier
23:04:38 <sqooq> let me test, for whatever reason my intuition tells me this can't be true
23:04:43 <nisstyre> sqooq: for 150, would 2**(87/12) be acceptable?
23:05:04 <sqooq> looks so yeah
23:07:57 <sqooq> n=12ln(x)/ln(2) where x is the integer I want to reach
23:08:34 <sqooq> and then how do I do the ceiling floor thing
23:09:38 <sqooq> ceiling or floor doesn't work
23:09:41 <sqooq> has to be like, round or something
23:09:50 <nshepperd_>   n1 = floor (12 * logBase 2 x), n2 = ceiling (12 * logBase 2 x)
23:10:19 <sqooq> O do both then do | n1 < n2 = n1 | n2 < n1 = n2
23:10:23 <sqooq> ayyy
23:10:27 <sqooq> that'll work for sure
23:10:30 <nshepperd_> The answer is either 2^(n1/12) or 2^(n2/12)
23:10:39 <nshepperd_> Return whichever one is closer to x
23:10:40 <nisstyre> sqooq: so I wonder if this works https://ideone.com/Aoclnu
23:10:41 <sqooq> o derp log base 2
23:10:45 <sqooq> idk why i'm using natural log
23:10:49 <sqooq> forgetting my change of base shit
23:10:51 <nisstyre> it doesn't check which one is closer though (floor or ceil)
23:10:59 <nisstyre> but it gets you close enough
23:11:22 <sqooq> why is it so long
23:11:35 <nisstyre> I adapted it from my other code
23:11:39 <nisstyre> I could probably shorten it a lot
23:11:50 <nisstyre> I was just curious if it would actually work
23:12:12 <sqooq> do you actually want me to test it or
23:12:17 <sqooq> try it with "5"
23:12:33 <sqooq> you should get 28, or if you're doing floor, 27
23:12:36 <Lokathor> is there a haskell trick so that you can prevent a value that you're actually using from escaping a scope?
23:12:48 <Lokathor> I know about the ST and s deal, but you don't use s yourself in that situation
23:12:49 <nisstyre> sqooq: 28?
23:13:01 <nisstyre> I get 28
23:13:18 <sqooq> with floor??
23:13:20 <nisstyre> yeah
23:13:28 <sqooq> wtf sweet that works better than expected
23:13:36 <sqooq> what about 6?
23:13:42 <sqooq> should get 31
23:13:43 <nisstyre> 31
23:13:48 <sqooq> o shit
23:13:55 <sqooq> i'm gonna write my own
23:13:57 <sqooq> in much less lines lmao
23:14:09 <nisstyre> yeah you can get rid of the data type
23:14:13 <nisstyre> and just search it directly
23:20:53 <nshepperd> http://lpaste.net/359130
23:26:40 <sqooq> what I tried is a mess
23:28:06 <nisstyre> the logBase solution is probably what you want
23:29:59 <sqooq> yeah I mean I got it to work
23:30:05 <sqooq> I just feel it's ugly but maybe not
23:30:06 <sqooq> hold up
23:30:07 <nisstyre> but if you want to have like an arbitrary formulate later
23:30:20 <nisstyre> then some other more general solution
23:30:35 <nisstyre> *formula
23:31:40 <ongy> what's the extension called that makes 1e6 a valid integer literal? I forgott the name
23:31:41 <sqooq> there's a function to flip the arguments fo a function right
23:32:12 <nshepperd> λ> solve 1000                                                                                 
23:32:14 <nshepperd> "2^(120 / 12)"
23:32:22 <nshepperd> :)
23:32:57 <nisstyre> nshepperd: that's nice
23:33:10 <nisstyre> what does Numeric.Search do?
23:33:35 <nisstyre> oh just binary searches
23:33:41 <nshepperd> https://hackage.haskell.org/package/binary-search-1.0.0.3/docs/Numeric-Search-Integer.html
23:33:52 <ongy> found it, NumDecimals
23:33:55 <Maxdamantus> ongy: apparently "NumDecimals"
23:33:56 <Maxdamantus> eh, nvm.
23:33:58 <nisstyre> I never knew about that library
23:34:01 <nshepperd> search p returns the first Integer such that p is true
23:34:05 <sqooq> agh shoot, i'm so stupid
23:34:17 <sqooq> how do I do the function over and over up to some number n
23:34:23 <sqooq> This seems trivia
23:34:27 <sqooq> It's getting l8
23:34:29 <nisstyre> sqooq: iterate?
23:34:31 <sqooq> my brain stop working
23:34:38 <sqooq> nisstyre, if that's the term sure
23:34:41 <sqooq> like you give it 20
23:34:48 <Maxdamantus> takeWhile (<n) f
23:34:52 <sqooq> and it finds the integers for you for 1 2 3 4 ...
23:34:56 <Maxdamantus> takeWhile (<n) . iterate f
23:35:18 <nisstyre> yeah
23:35:36 <Maxdamantus> or if you meant `n` times, then `take n . iterate f`
23:36:02 <nshepperd> I should say, "smallest" Integer, it works for negative numbers too
23:36:02 <sqooq> Idk takeWhile (<n) f didn't seem to work
23:36:17 <nshepperd> and does some fancy binary / exponential search behind the scenes
23:36:19 <Maxdamantus> sqooq: that was a mistake. I meant to write my second expression.
23:36:23 <nisstyre> :t iterate
23:36:25 <lambdabot> (a -> a) -> a -> [a]
23:36:46 <nshepperd> λ> solve (0.2)                                                                                
23:36:48 <nshepperd> "2^(-28 / 12)"
23:36:50 <sqooq> idk "take n . iterate f" didn't work either seemingly
23:37:05 <not_a_lawyer> Hi! Can anyone help me with a license question?
23:37:07 <Maxdamantus> > let g = takeWhile (<1000) . iterate (2*) in g 3
23:37:10 <lambdabot>  [3,6,12,24,48,96,192,384,768]
23:37:33 <ongy> Maxdamantus: thanks anyways
23:37:46 <Maxdamantus> ongy: np
23:38:07 <sqooq> what does iterate do
23:38:09 <not_a_lawyer> I want to use the implementation of `Data.List.intersperse` in the standard library for a language I'm contributing to, but I'm not sure what conditions I have to fulfill if I do
23:38:24 <sqooq> when I tried "iterate (2*) 1" I get an endless console printing of a bunch of numbers
23:38:35 <Maxdamantus> > take 5 $ iterate f x
23:38:38 <lambdabot>  [x,f x,f (f x),f (f (f x)),f (f (f (f x)))]
23:38:50 <sqooq> what the
23:39:00 <nisstyre> sqooq: yeah because it just does 2*1, 2*2, 2*4, etc
23:39:31 <sqooq> I can't figure out how to make this work with my function
23:39:39 <sqooq> it needs to do [f 1, f 2, f 3, f 4]
23:39:44 <sqooq> . . .
23:39:54 <nisstyre> map f [1..] ??
23:39:55 <Maxdamantus> Maybe you want `map f [1..]`
23:39:58 <nisstyre> lol
23:39:59 <sqooq> derp
23:40:02 <sqooq> I told you I was tired
23:40:05 <sqooq> and this was trivial
23:40:06 <nisstyre> I overthought it
23:40:07 <sqooq> lol
23:40:34 <sqooq> ayyy
23:40:37 <sqooq> perfect
23:41:18 <nisstyre> \m/
23:42:24 <sqooq> http://lpaste.net/359131
23:42:29 <sqooq> that's what mine ended up being
23:42:43 <sqooq> it seems to work
23:43:26 <nisstyre> can't sy I know what Edo means but looks fine
23:45:16 <sqooq> it's just changing the "12" in 2**(n/12)
23:45:26 <sqooq> edo means "equal division of the octave"
23:46:03 <sqooq> if you're ultimately curious
23:46:04 <sqooq> http://sethares.engr.wisc.edu/paperspdf/cmj98.pdf
23:49:29 <nshepperd> not_a_lawyer: probably none. it's a trivial snippet and you'll have to rewrite it anyway if you're using it in a language other than haskell. but the license is https://hackage.haskell.org/package/base-4.10.0.0/src/LICENSE
23:50:46 <nisstyre> sqooq: cool stuff
23:51:07 <sqooq> ye
23:52:57 <HaskellLord69>  does everyone feel like a wizard the first time they use the state monad
23:53:17 <HaskellLord69> because thats how I feel right now
23:54:06 <xormor> Haskell is like a line-by-line (commandline) scientific functional mathematical and symbolic "calculator"/"computer" to me.
23:54:37 <xormor> it is best suited for mathematics and characters. I do not think it can draw graphics. Am I wrong?
23:55:50 <HaskellLord69> John Carmack rewrote Wolfenstein 3D in haskell if that is any indication
23:57:12 <xormor> HaskellLord69, ok
23:57:26 <HaskellLord69> I know very little about graphics personally so hopefully someone else can give you a better answer
23:57:34 <Maxdamantus> Yeah, who needs maths for doing graphics anyway?
23:58:18 <Maxdamantus> Trigonometry is a scam.
23:59:07 <xormor> Maxdamantus, I used trigonometry to draw green triangles in Turbo Pascal, that was in the end of the '90's or the early 2000's.
23:59:20 <xormor> Maxdamantus, the triangles were in 3 dimensions.
23:59:52 <xormor> Maxdamantus, Turbo Pascal trigonometric 3D green triangles
