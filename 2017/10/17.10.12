00:00:50 <jchia> opqdonut: I think I'll run into similar trouble again on the GreaterThan if I define the Eq instance manually. http://lpaste.net/359171 (annotation)
00:01:04 <jchia> cocreature: Yeah, my grammar is that complicated yet.
00:01:57 <cocreature> jchia: you can’t define the Eq instance directly, you need to define opqdonut’s equal function and then set (==) = equal in your Eq instance
00:02:10 <cocreature> (you can ofc define equal in a where clause)
00:05:51 <jchia> cocreature: OK, I get the problem
00:22:06 <roi_du_silence> asking again in case some people see this : can someone try to build gloss with the glfw backend enabled ?
00:22:20 <roi_du_silence> doesn't work for me.
00:34:35 <ertes-w> helo
00:39:25 <roi_du_silence> h e l o
00:41:07 <opqdonut> ehlo
00:48:49 <DigitalKiwi> why are there mail servers here :<
00:55:47 <maerwald> halo
00:56:01 * maerwald segfaults
00:57:24 <DigitalKiwi> QUIT
00:59:33 * roi_du_silence is puzzled
01:04:55 <DigitalKiwi> roi_du_silence ehlo and helo are what you send to start a conversation with a mail server, quit terminates it
01:05:08 <DigitalKiwi> https://www.port25.com/how-to-check-an-smtp-connection-with-a-manual-telnet-session-2/
01:06:22 <roi_du_silence> Thanks DK !
01:08:32 <DigitalKiwi> and I have too much experience with mail servers to want to be reminded about them which is why I was sad everyone was a mail server ;p
01:14:09 <ventonegro> It's just the channel keep-alive
01:14:39 <ventonegro> But you may as well ask which is better: Cabal or Stack
01:17:12 <roi_du_silence> stack is love stack is life
01:18:16 <merijn> ventonegro: No, because that just brings out pedants like me that point out Stack uses Cabal and you are probably confusing things with cabal-install :p
01:23:23 <ventonegro> merijn: The goal was achieved either way ;)
01:49:09 <sordina> Hi Haskellers, I've been developing a small workshop idea focused around solving bugs, and would ideally like it to be interactive. I've used try-haskell as the backend, but that only seems to allow for one-liners. Is there another similar service that could safely evaluate multi-line experssions?
01:49:34 <ertes-w> ventonegro: you offended me there…  have you flipped a coin to decide which one to name first?  did you flip it fairly?  was there even a single witness?  if not, i ask you to reflip with video proof, and in the clip make no wrong move
01:49:56 <sordina> Code: https://github.com/sordina/crashkell#crashkell
01:50:27 <ertes-w> that's the internet argument groove
01:50:41 <ventonegro> ertes-w: You sir are a pro
01:51:48 <ertes-w> ventonegro: you offended me there…
01:53:36 <DigitalKiwi> he sorted alphabetically 
01:53:37 * maerwald hugs ertes-w
01:53:55 <DigitalKiwi> you wouldn't understand what that means though because you're from the internet
01:54:12 <ertes-w> awwww
01:54:39 <DigitalKiwi> never attribute to malice what you can attribute to a proper sort function
01:54:51 <ertes-w> no, wait!
01:54:55 <ertes-w> maerwald: you offended me there…
01:55:13 * maerwald hugs ertes-w even closer
01:56:30 <cocreature> sordina: iirc codepad.org can run haskell code
01:56:30 <DigitalKiwi> that's how you get an assault charge
01:57:08 <merijn> Any opinions on how to linewrap long explicit imports?
01:57:10 <sordina> cocreature: is that open source? I should have clarified, I'm running try-haskell
01:58:00 <cocreature> sordina: I don’t think so
01:58:51 <sordina> cocreature: doh
01:59:49 * ertes-w flips through the tsundere guide
01:59:55 * ertes-w blushes
02:00:27 <sordina> codepad seems to take an interestin tactic for code-execution safety:
02:00:29 <sordina> http://codepad.org/about
02:01:44 <sordina> Try-Haskell leans on mueval
02:07:16 <ertes-w> merijn: my method is to pretend that it's prose and indent every continuation line by four spaces
02:07:56 <merijn> ertes-w: Right, so you keep going until you hit max line length and then just wrap from there?
02:08:10 <ertes-w> merijn: yeah, or rather my editor does
02:09:38 <ertes-w> merijn: this style is only useful, if you have some sort of fill function in your editor though…  if i change the imports, i can just hit M-q and have it refill it for me
02:09:45 <ertes-w> maintaining that manually would be a PITA
02:10:33 <merijn> ertes-w: Oh, you keept them after the import statement? I've started putting the name list on the next line if it doesn't fit a single line
02:10:50 <merijn> Gives you more space before having to linewrap too
02:11:55 <ertes-w> merijn: yeah, but i think either style is fine…  if you can auto-fill, it doesn't really matter
02:12:14 <ertes-w> so i just go with the shortest version =)
02:12:53 <ertes-w> merijn: but honestly i'd be much more likely to use a qualified import
02:13:13 <ertes-w> or use 'hiding' on other imports
02:15:39 <ertes-w> (i wish haskell had agda's module system…  it's so very much more betterer)
02:17:04 <sordina> gotta go, thanks for the help
02:23:12 <merijn> Any people here using cabal.project? I need some example files to test my parser
02:32:58 <fommil> is there a way to call hxt-xpath's getXPath at compiletime? Nothing more annoying than a runtime parse error of a compiletime literal
02:34:10 <merijn> fommil: Are you dealing with schemaless XML or do you need schema validation?
02:35:00 <fommil> merijn: schemaless... just avoiding dumb typos would be good enough (but doing it with schema validation would be really awesome in general)
02:35:27 <merijn> fommil: Right, I can't help you with HXT, but for schemaless XML I can recommend xml-conduit, since it's far easier to understand
02:36:03 <merijn> fommil: Which has functions modelled after xpath, so you can write xpath traversals using regular functions rather than strings
02:36:16 <merijn> https://hackage.haskell.org/package/xml-conduit-1.7.0/docs/Text-XML-Cursor.html
02:38:57 * hackagebot llvm-hs 5.1.0 – General purpose LLVM bindings – https://hackage.haskell.org/package/llvm-hs
02:42:36 <michalrus> It’s not possible to do qualified reimports, is it? :b
02:42:46 <michalrus> Wait, re-exports!
02:43:04 <cocreature> michalrus: sadly it’s not possible
02:43:09 <michalrus> Okkay!
02:43:13 <merijn> ugh...
02:43:26 <merijn> So can someone explain the first type parameter in ReadP? https://hackage.haskell.org/package/Cabal-2.0.0.2/docs/Distribution-Compat-ReadP.html#t:ReadP
02:45:19 <merijn> Or why (<++) has "ReadP a a" as opposed to "ReadP r a", because it's really messing up my code...
02:49:48 <tdammers> newtype Parser r s a = R ((a -> P s r) -> P s r) -- is probably important
02:57:36 <Profpatsch> Is it possible to write a correct Traversable instance for the following?
02:57:38 <Profpatsch> newtype Constrain t = Constrain { unConstrain :: ((Char -> Bool) -> t) }
02:58:09 <Profpatsch> GHC doesn’t auto-derive it with DeriveTraversable, but I’m not sure it cannot be done manually. My brain is too small, though.
02:58:43 <Profpatsch> I at least need traverse specified to [] for this type.
03:00:21 <fommil> is there a way to build a hoogle database for stack's global-ghc ?
03:00:23 <Profpatsch> So (a -> [b]) -> Constrain a -> [Constrain b]
03:00:36 <Profpatsch> But my brain is even too small for that. d(
03:01:36 <cocreature> Profpatsch: Traversable implies Foldable which needs toList which doesn’t work in your code
03:03:36 <Wizek> Hello! Anyone knows how to build packages that have custom c libraries (not installable via mingw32) as dependencies on windows?
03:04:22 <Wizek> I'm trying to install https://hackage.haskell.org/package/lmdb-0.2.5
03:05:05 <Profpatsch> cocreature: Right; but can the specialized version be done w/o toList?
03:08:18 <cocreature> Profpatsch: no, the length of the resulting list would need to be independent of the (Char -> Bool) function which means that you can’t get the "a" to apply the function to
03:08:18 <dpn`> cocreature: yeah agreed re: chans - thanks worked well
03:09:12 <cocreature> Profpatsch: well at least you can’t come up with a reasonable implementation. you can ofc always return an empty list :)
03:11:26 <Profpatsch> cocreature: Thanks!
03:11:58 <Profpatsch> I think I can get away with extracting by (const True) for my use case.
03:12:09 <Profpatsch> (Implementing this interface https://hackage.haskell.org/package/text-zipper-0.10.1/docs/Data-Text-Zipper-Generic.html#t:GenericTextZipper)
03:12:23 <Profpatsch> The problem arises with the a -> ConcreteType functions.
03:12:58 <Profpatsch> Especially with the toList function. :P
03:14:57 <Wizek> Initially I get an error like this when I try to `stack build` it: `Cabal-simple_mPHDZzAJ_1.24.2.0_ghc-8.0.2.exe: Missing dependency on a foreign library: * Missing C library: lmdb`
03:15:58 <Wizek> so I tried to follow its instructions and try to point to the library with `--extra-include-dirs=` and/or `--extra-lib-dirs=`
03:16:13 <Wizek> and it still doesn't seem to find the library
03:16:37 <Wizek> what is it looking for? A folder containing library_name.h?
03:17:02 <Profpatsch> Wizek: this looks like a case of “time to dig into the code”
03:17:13 <Profpatsch> Wizek: Maybe start with Cabal to remove the stack layer of indirection.
03:18:23 <LeanderK> Hey, I am playing around with singletons and i got an error i don't really understand: Could not deduce (SingI is) arising from a use of ‘sing’, "is" should be :: [Nat], so I don't understand why the compiler is choking. I am just experimenting, so don't expect the best code. I am trying to write something comparable to a record with optional names, here is a quick minimal example that doesn't compile: http://lpaste.net/751682
03:18:24 <LeanderK> 734941798400
03:18:28 <Wizek> Profpatsch: okay, trying with cabal now
03:19:13 <cocreature> Wizek: how have you built the lib?
03:23:11 <Wizek> cocreature: I think I've either did `gcc lmdb.h` or `make` in its folder. I'm trying to remember and reproduce now.
03:23:34 <Wizek> Profpatsch: to my surprise, cabal seems to give a different error; investigating
03:23:39 <cocreature> "gcc lmdb.h" doesn’t make sense. you don’t compile headers
03:24:29 <Wizek> cocreature: Yeah, I was hoping that someone might point me in a direction that can make sense, I don't have much experience with C as it stands.
03:24:42 <lyxia> LeanderK: where is the error
03:25:03 <Profpatsch> Wizek: Maybe use Berkley DB bindings instead?
03:25:14 <LeanderK> ah, sorry the error is in: src/Extra/Row3.hs:90:37: error: Could not deduce (SingI is) arising from a use of ‘sing’
03:25:20 <Profpatsch> Can’t imagine that not coming with mingw in one version or another.
03:25:59 <lyxia> LeanderK: can you add the full error to that paste
03:26:08 <Wizek> Profpatsch: I'm trying to build an app on Windows that uses https://hackage.haskell.org/package/vcache-0.2.6, which is built on top of lmdb
03:26:30 <LeanderK> i try, i am not sure how
03:26:39 <jonge> hey there. i am using text.xml.cursor from xml-conduit. what i need is a function like `Cursor -> [(attr1 :: String, attr2 :: String)]` for a specific node. but i do not know how to combine "attribute "attr1"" and "attribute "attr2"" on a cursor in order to get this.
03:27:06 <lyxia> LeanderK: oh actually you're indeed missing that one constraint
03:28:49 <lyxia> LeanderK: add SingI is at the end of your GetSliceNamedConstraints
03:29:33 <LeanderK> ok, yeah i think thats the solution
03:30:04 <LeanderK> i don't know why that's required. It wasn't required in another case
03:32:55 <LeanderK> why is it not required in row 81?
03:35:54 <Wizek> cocreature: So, it turns out that what I did to build it is going to its directory and run `make` from an `MSYS2 MinGW 64` terminal, which completes without errors. Here is the Makefilet: https://github.com/LMDB/lmdb/blob/mdb.master/libraries/liblmdb/Makefile
03:37:37 <lyxia> LeanderK: because there is no implementation to type check against
03:37:53 <lyxia> LeanderK: if you write an instance using is you'll get the error
03:38:55 <Wizek> cocreature: and here is what it executed: https://gist.github.com/Wizek/7f139b58aa4483f0f89457b7e2382e2a
03:40:13 <Wizek> cocreature: Does that seem correct? Or have I made a mistake there?
03:41:32 <cocreature> Wizek: looks reasonable, and the directory that you passed to --extra-lib-dirs contains liblmdb.so?
03:42:31 <Wizek> cocreature: it does indeed
03:42:58 <cocreature> Wizek: hm weird, not sure what’s going wrong. what’s the error that you get from cabal?
03:43:19 <Wizek> cocreature: its a linker error, pasting it in a sec
03:45:04 <LeanderK> lyxia ah i though because :: Nat has a Singl instance ::[Nat] should have one. Is it because of limitations of the type system, singletons or an design decision?
03:48:18 <lyxia> LeanderK: A bit of the first and a bit of the third. Singleton is making the most it can out of the "limited" features available in GHC Haskell.
03:49:49 <Wizek> cocreature, Profpatsch: Here is the linker error I get when trying to build via just cabal: https://gist.github.com/Wizek/d0d9f17806799cb7a66420a7f550ed80
03:50:15 <LeanderK> lyxia thank you, i think i understood the problem now
03:52:05 <lyxia> LeanderK: a constraint SingI (is :: [Nat]) is basically an *argument* of type [Nat] to a function
03:52:26 <lyxia> LeanderK: this can't be derived from another Nat value.
03:52:47 <Profpatsch> Wizek: Wait, aren’t those libc calls?
03:52:52 <Profpatsch>  undefined reference to `mmap'
03:53:54 <Profpatsch> Wizek: /nix/store/pqqmm39y5qar550nwab2ndszb6m02c82-glibc-2.25-dev/include/sys/mman.h for me
03:54:29 <Profpatsch> Time to check MinGW headers I’m afraid.
03:55:21 <Profpatsch> Maybe you have to give Cabal the path to these headers manually. There’s options to add linker flags.
03:55:37 <Profpatsch> I forget, but you can find them in the Cabal user manual.
03:59:01 <merijn> Eternal gratitude for whoever figures out a way to (re)implement https://hackage.haskell.org/package/Cabal-2.0.0.2/docs/Distribution-Compat-ReadP.html#v:-60--43--43- with a less annoying type...
04:18:26 <tomsmalley> Does anyone have experience with using PolyKinds and DefaultSignatures together? It seems they don't play well, but I might be misunderstanding something. Code and error in this gist: https://gist.github.com/tomsmalley/eec3b2c793c080fd7d51f8e0b84197a4
04:24:03 <fommil> I'm trying to do pattern matching in a list of a list for an XHT text element, but the compiler warnings are confusing me... I'm probably doing something dumb (just translating how I'd do it in scala to haskell)... could somebody please help? http://lpaste.net/359185
04:24:37 <fommil> I can't figure out any better way to extract the expected data shape out of the result of the XPath
04:24:57 <fommil> (good old XML, always returning a list of list of things)
04:25:44 <fommil> XText is one of these https://hackage.haskell.org/package/hxt-9.3.1.16/docs/Text-XML-HXT-DOM-TypeDefs.html#t:XmlTree
04:39:39 <lyxia> tomsmalley: I'm not sure about it either, but this seems to be a bit of progress, and the error now looks like a GHC bug https://gist.github.com/Lysxia/7b3d9f4ef6c20c45781aaf4ed0fa1e12
04:43:56 <lyxia> tomsmalley: yours looks like a bug too
04:47:19 <tomsmalley> lyxia: ah, I will see if I can find anything already reported
04:48:36 <tomsmalley> I got ghc to print: Expected kind 'forall k. k -> *', but 'Void1' has kind 'forall k. k -> *', so I thought as much
05:09:52 <Ero2> could someone confirm for me? I've done the first 4 excersizes of CIS194 week1 hw1. ex4 suggests to use all definitions required for the previous 3 excersizes but I can't figure out how to get one particular function in there. I have described my question more completely as a comment in the code: http://lpaste.net/359186
05:12:37 <Profpatsch> Ero2: Maybe in the place where you reverse two times?
05:13:08 <Profpatsch> Ero2: Convention is also to give more descriptive names than “magic”. :)
05:13:10 <Ero2> Profpatsch: i thought that but.. the types dont line up? Am i thinking about this correctly?
05:13:29 <Ero2> Profpatsch: i'm really bad at names but i will improve on this xD
05:14:36 <Ero2> perhaps my whole implementation of doubleEveryOther is not optimal
05:15:09 <Profpatsch> Ero2: Yes, reverse is O(n), as you can see in https://hackage.haskell.org/package/base-4.10.0.0/docs/src/GHC.List.html#reverse
05:15:28 <Profpatsch> It has to traverse the list and build a new one.
05:16:29 <Ero2> yea. I couldn't figgure out how to do it better. Perhaps i have to traverse the list to create a pair of (Int,Bool) and then pass it to a doubling function
05:16:37 <Ero2> that seems better
05:16:54 <saurabhn_> what happens if I use withResource and pass the resource to an async thread? Does the resource "escape" the withResource bracket/block? (the resource in question is a DB connection)
05:17:48 <Profpatsch> Ero2: Well, you write (doubleEveryOther . toDigits). doubleEveryOther already starts with reverse, so if you replace it my its definition it says:
05:17:59 <Profpatsch> (reverse . magic . reverse . toDigits)
05:18:03 <merijn> saurabhn_: Are you waiting for the async in the same thread you call the async?
05:18:28 <Profpatsch> It mostly depends on what you want to express, really.
05:18:58 <Ero2> thanks Profpatsch, i'll give it another go
05:19:06 <Profpatsch> Of course you can replace (reverse . toDigits) with toDigitsRev: (revrese . magic . toDigitsRev)
05:19:10 <saurabhn_> merijn: no, the async is supposed to keep running forever... the main thread goes on to do other things. Once of which is spawning a webserver, which again, will continue running forever. Neither is supposed to be end.
05:25:48 <merijn> saurabhn_: In that case the resource will get freed whenever withResource terminates, regardless of what the async is doing with it
05:26:24 <saurabhn_> merijn: so, it'll go back into the pool... get re-assigned to some other thread, and all hell will break loose when two threads start sharing the same DB connection?
05:26:52 <merijn> saurabhn_: I have no clue whatever library you're using and what it does, so who knows
05:27:32 <saurabhn_> hmmm... I'm assuming Rust solves for this problem.
05:42:52 <Profpatsch> RUST.SOLVES.EVERYTHING
05:43:05 <Profpatsch> (oxidizing metal I mean)
05:44:16 <Profpatsch> ((once you beat the borrow checker))
05:44:30 <Profpatsch> (((and the lifetime checker)))
05:45:40 <stevenxl> Hi folks. I'm trying to setup a stack project manually just to understand how things are working. I'm having problems with my command `stack test`.
05:45:44 <stevenxl> Here is the repo: https://github.com/StevenXL/minimal-stack-cabal/tree/05-create-test-suite
05:46:19 <stevenxl> This is the error when I actually run `stack test`: 
05:47:30 <stevenxl> http://lpaste.net/359187
05:47:34 <stevenxl> Any ideas?
05:54:16 <stevenxl> Hm.. When i changed the main file from `Spec.hs` to `Main.hs` it worked.
05:55:09 <stevenxl> (I over-wrote the repo so please don't check that anymore)
05:55:40 <lyxia> stevenxl: your test-suite says that the main module is (main-is) Main.hs
05:56:43 <stevenxl> lyxia: I'm very sorry. I over-wrote pushed -f on that branch, so depending on when you saw it, it no longer has an error. I thought I had main-is: Spec.hs, but I could be wrong. 
05:57:40 <lyxia> I'm still seeing it.
05:58:01 <lyxia> even with your push 3 secs ago
05:58:29 <lyxia> but of course now it works because you renamed test/Spec.hs to test/Main.hs
05:58:48 <lyxia> stevenxl: I was referring to the contents of the cabal file
05:59:31 <stevenxl> lyxia: Oh I see. Thank you. 
05:59:33 <stevenxl> :-)
06:00:33 * hackagebot tyfam-witnesses 0.1.1 – Provide proof witnesses for closed type family evaluation – https://hackage.haskell.org/package/tyfam-witnesses
06:06:03 <cmotoche> Is the use of type aliases or type synonymous a good practice? For instance: `type Price = (Integer, Integer)`.
06:06:59 <cmotoche> The type is only used in the same module where it is defined.
06:07:50 <merijn> cmotoche: Usually not, IMO
06:08:16 <cmotoche> Why not?
06:10:15 <merijn> cmotoche: In my experience it just gets confusing trying to figure out WTF a function wants as argument
06:10:47 <merijn> It seems nice now, but 5 months from now when you forgot how "Price" is defined you have to look up it's definition (and all other synonyms)
06:11:08 <merijn> cmotoche: It gets even worse when people define synonyms using synonyms so you get to hunt through six or seven layers of names
06:11:33 <merijn> Personally I only use synonyms to alias really long types (for example, a long function type that I use in multiple places)
06:12:28 <cmotoche> merijn, Thanks for the explanation.
06:17:43 <Profpatsch> Yeah, it’s very nice if you use ExceptT ExceptionFoobar IO a like 5 or 6 times in a function.
06:18:27 <Profpatsch> Just to document all where clauses, alias it to ExcFoobar or something and use that locally.
06:32:00 <merijn> Profpatsch: Man...I wish something as short as that was the longest type I had to worry about
06:33:12 <Profpatsch> merijn: Examples! I demand examples!
06:34:07 <merijn> Profpatsch: hmm, not sure if I have something like that online atm
06:41:20 <Profpatsch> merijn: As an aside, [mεɹɪd͡ʒn] or [mεɹɪxn]
06:42:05 <merijn> ?
06:42:54 * ski thinks Profpatsch is asking about how to pronounce it
06:44:02 <Profpatsch> merijn: basically if the j is pronounced like in jungle or in a spanish way.
06:44:15 <maerwald> like tarzan
06:44:19 <merijn> Profpatsch: Mu
06:44:25 <Profpatsch> heh
06:44:29 <Ero2> haha, finding opportunities to use circular references in basic haskell homework is like returning to earlier dungeons to find the secrets
06:44:41 <ski> [mεɹɛi̯n], perchance ?
06:44:56 <merijn> The question has a mistaken assumption
06:45:00 <ystael> Ero2: you mean it's full of palette swaps of earlier programs with really annoying status infliction abilities?
06:45:12 <Ero2> y-yes...
06:45:22 <ski> (the assumption that the answer is one of the two given suggested ones)
06:45:25 <nshepperd_> The same way you pronounce your tensor indices
06:45:33 <merijn> The real question is, how do you pronounce the letter 'ĳ'
06:45:57 <ski> like always in dutch ?
06:46:15 <merijn> And the answer is: Exactly the same as in Dijkstra, of course everyone always gets that one wrong too ;)
06:46:46 <Ero2> ... ystael whats a palete swap?
06:47:08 <nshepperd_> I wish ScopedTypeVariables would also let us have local type synonyms
06:47:13 <merijn> ski: Well, there's some deviations for historical/archaic spellings (like De Bruijn, which is pronounced like "De Bruin")
06:47:43 <maerwald> I just pronounce you however I want, I will only spell you correctly
06:47:48 <ystael> Ero2: standard JRPG design technique: same monster, different color scheme. saves on art.
06:47:49 <ski> ok
06:48:01 <ski> (and "Dyck" ?)
06:48:22 <Ero2> oh yea
06:48:38 <ski> ystael : heh
06:49:13 <ski> (and sometimes that's the upgraded version of the game)
06:49:27 <Ero2> sad times
06:50:01 <merijn> ski: No, that's still pronounced the same (well, assuming you mean Dijck, since "Dyck" would never happen, unless it's a Dutch name after a few generations of American butchery)
06:50:26 <Eduard_Munteanu> Local type synonyms would be easily accomodated by first class modules.
06:52:17 * nshepperd_ just googles it: https://en.wikipedia.org/wiki/IJ_(digraph)
06:52:51 <merijn> I used to link to Google Translate in the past, but their text-to-speech for Dutch has really gone down hill a lot, so it's pretty bad now
06:53:46 <maerwald> I pronounce it Mary Jay Ann
07:01:02 <ventonegro> Sounds just like "ei" https://upload.wikimedia.org/wikipedia/commons/c/c0/Nl-IJ.ogg
07:01:30 <Profpatsch> merijn: now I am insecure whether I ever pronounced Dijkstra correctly; the wikipedia IPA-sound examples basically add 
07:01:39 <Profpatsch> insult to injury
07:02:17 <merijn> Profpatsch: It's a pretty reasonably assumption that anyone who is not a native Dutch speaker has never pronounced Dijkstra or De Bruijn correct :p
07:02:30 <Profpatsch> that was my impression, yes. :D
07:02:48 <merijn> The wikipedia sound file is pretty reasonable for his name
07:03:30 <Profpatsch> I can’t even make out single sounds in this one. Then again, that corresponds to my experience with Dutch speakers.
07:04:12 <merijn> Profpatsch: In fact, most non-native Dutch speakers would probably be unable to tell whether someone else was pronouncing it correctly too. Since most people I've discussed pronounciation with are literally unable to distinguish some sounds :)
07:04:53 <Profpatsch> That also resembles my (small) experience with Dutch. :D
07:05:15 <maerwald> fascinating, now pronounce 包子 correctly
07:05:23 <Sornaensis> dike struh
07:07:21 <Eduard_Munteanu> daiku staru
07:07:45 <Profpatsch> Japanese pronounciation is pretty simple in all honesty.
07:07:52 <maerwald> japanese?
07:08:16 <etiago> surprisingly I can pronounce both Dijkstra and 包子 correctly :p
07:08:17 <Profpatsch> Well, you didn’t explicitely say it’s not http://jisho.org/search/%E5%8C%85%E5%AD%90 :)
07:08:28 <Profpatsch> Chinese, uuuuuh
07:08:49 <etiago> <- lived in the Netherlands, wife's Chinese
07:08:59 <etiago> ^ 包子 is delicious
07:09:04 <maerwald> :>
07:09:08 <Profpatsch> Now I want some.
07:09:12 <Clint> me three
07:10:27 <etiago> you can make them from scratch without thaaat much effort
07:10:53 <Profpatsch> Oh, I think I know what 包子 is.
07:11:02 <Profpatsch> Probably. Not sure.
07:11:15 <Profpatsch> Are they served in wooden boxes?
07:11:45 <tdammers> merijn: you mean, 'ei' vs 'ij' vs 'eij'?
07:12:02 <merijn> tdammers: Man, people can't even tell ui/eu/oe/ou apart
07:12:05 <Clint> ĳ
07:12:23 <Eduard_Munteanu> There's some Vietnamese thing here called Banh Mi served in a wooden box.
07:13:36 <tdammers> "ui" is easy, just try to pronounce all the vowels you know at the same time
07:14:02 <Eduard_Munteanu> It's quite cool to have a name that looks like tensor notation and indices.
07:14:22 <tdammers> "eu" and "oe" aren't even diphtongs, they're just plain old /ø:/ and /u:/
07:15:35 <tdammers> then again, how most Dutch people cannot remember the difference between u and ü in German eludes me - just accept that the dots don't mean in German what they mean in Dutch and deal with it
07:16:16 <etiago> tdammers , are there actually any Dutch words that use the umlaut?
07:16:22 <Ke> what are the dots in dutch then?
07:16:25 <etiago> don't remember coming across any tbh
07:16:33 <shapr> ij is the most common Dutch ligature
07:16:39 <Ke> I haven't seen any either
07:16:51 <shapr> it was written as lower case y with dots on top
07:17:02 <shapr> sounds like Fonzy's ayyy sort of
07:17:05 <Ke>  and I do remember reading dutch based on my german skills
07:17:20 <etiago> IJ used to be a character in itself iirc
07:17:34 <etiago> like a self-standing character in the alphabet
07:17:34 <ij> true
07:17:44 <Ke> you mean write ij as ü ?
07:17:49 <lieven> etiago: things like allergie\"en
07:17:51 <tdammers> etiago: the dots are a trema in Dutch, not an Umlaut, it signals that the vowel doesn't combine with other surrounding vowels
07:17:54 <shapr> to stay on topic here, are there any font design tools in Haskell?
07:17:54 <etiago> as æ
07:18:00 <etiago> as ÿ
07:18:08 <lieven> etiago: its used to separate vowels and stop them from becoming diphtongs
07:18:21 <etiago> shapr haha
07:18:22 <tdammers> "ideas" is "ideeën" in Dutch
07:18:26 <etiago> fair enough
07:18:29 <etiago> oh yeah
07:18:30 <etiago> right
07:18:59 <tdammers> umlaut is only used in some German loanwords, and usually incorrectly
07:19:06 <tdammers> "apfelstrüdel", brrrr
07:19:13 <lieven> and in Heavy Metal group names :)
07:19:54 <tdammers> ÿ is another peculiarity, because it's actually ĳ, a ligature of i and j, but considered a single letter
07:19:59 <maerwald> good to know you can trigger haskellers with pronounciation nitpicking :>
07:20:02 <shapr> ha
07:20:11 <tdammers> it is often written as an umlauted y though, especially in handwriting
07:21:03 <tdammers> linguistics and typography work well on haskellers as nerd sniping weapons
07:22:26 <shapr> https://hackage.haskell.org/package/SVGFonts ?
07:23:30 <crlane> shapr told me interesting things happened here
07:23:40 <shapr> hello crlane !
07:23:45 <shapr> Would you like to learn Haskell?
07:23:53 <Ero> is there a higher order function for circular programming/reference recursives?
07:24:08 <shapr> Ero: something like fix? or what?
07:24:14 <crlane> shapr of course - learning is my favorite thing to do
07:24:20 <Eduard_Munteanu> :t fix
07:24:21 <lambdabot> (a -> a) -> a
07:24:37 <Ero> I'll look into it, thx shapr 
07:24:41 <shapr> crlane: there's a weekly Haskell learning meetup in Atlanta
07:24:42 <crlane> I have probably done maybe 50% of the learn you a haskell book
07:24:44 <shapr> and lots of online resources
07:24:47 <shapr> oh good!
07:25:19 <Ero> i started with learn you a haskell, i think it did a good job of propelling me into what was to come tbh
07:25:32 <Ero> but by no means was it enough on its own
07:25:34 <shapr> I prefer "Haskell from First Principles" at the moment
07:25:41 <Eduard_Munteanu> > fix $ \rec -> 1 : rec
07:25:44 <shapr> but I also have "Programming in Haskell" by Graham Hutton
07:25:46 <shapr> both editions!
07:25:46 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
07:25:59 <etiago> learn you a haskell frustrates me
07:26:00 <shapr> > let ones = 1 : ones in take 5 ones
07:26:03 <lambdabot>  [1,1,1,1,1]
07:26:11 <etiago> not enough challenges/proper exercises
07:26:20 <mnoonan> tdammers: is SPJ just constantly sniping the community with his font choices, then?
07:26:26 <ertes-w> etiago: i remember giving you one =P
07:26:27 <shapr> crlane: yesterday at the Haskell meetup we built a super simple website in Haskell's flask equivalent, Spock
07:26:32 <Profpatsch> LYAH did it’s job for me (but I like to just quickly read to stuff and am mostly too lazy for excercises)
07:26:36 <Profpatsch> *its
07:26:44 <etiago> ertes-w yep :) still sitting half finished in my editor
07:26:53 <etiago> planning on getting busy with it tonight
07:27:23 <ertes-w> etiago: if you run out of things to do, learn about the Monoid type class…  you will need it very soon =)
07:27:24 <Ero> jeez etiago keep it U please
07:27:36 <etiago> :')
07:28:10 <Ero> you'll scar my little functors
07:28:30 <etiago> ertes-w yeah, atm I'm trying to figure out how to get from the IO monad to a Maybe [Char]
07:28:38 <etiago> monads are still a bit foreign to me
07:28:54 <etiago> so I'll need to do further reading on that
07:29:03 <Ero> lambdabot, what is a monad?
07:29:12 <Profpatsch> etiago: You can’t really escape IO
07:29:19 <Ero> i'm actually kind of disappointed
07:29:20 <Profpatsch> You can just do stuff inside it.
07:29:29 <ertes-w> etiago: do you know why 'getLine' is of type (IO String) and not of type String?
07:29:30 <Profpatsch> Ero: lambdabot is no rudybot
07:29:56 <etiago> Profpatsch I thought you should escape IO as much as possible... because as soon as you get it, it's like herpes :p it stays with you
07:30:05 <Clint> does rudybot go to notre dame?
07:30:12 <etiago> ertes-w because it has side effects and it is not a pure function?
07:30:16 <Ero> etiago: you should definately write as much of your functions as you can without assuming IO
07:30:19 <ertes-w> etiago: is it a function?
07:30:24 <etiago> (the side effect being whatever the user put in)
07:30:32 <ertes-w> etiago: if it were a function, you could apply it, right?
07:30:39 <Ero> and then when it comes to needing to make your program interact with your system, you insert those functions into IO
07:30:43 <etiago> ...yes?
07:30:43 <ertes-w> etiago: and no, side effects aren't the reason
07:31:13 <ertes-w> etiago: it's not a function, and it's not exactly because of side effects…  let's say getLine were indeed of type String…  that means that getLine would be a string, correct?
07:31:30 <etiago> yep
07:31:34 <ertes-w> etiago: which string is it?  answer in the form of an equation
07:31:52 <etiago> it's any string input by the user
07:31:59 <ertes-w> etiago: that's not an equation, that's prose
07:32:04 <ertes-w> getLine = ?
07:32:16 <etiago> IO String
07:32:17 <etiago> :')
07:32:38 <etiago> I can't think of an equation that can represent any string
07:32:42 <ertes-w> etiago: getLine is not a string for the same reason the 'ls' command is not a list of files =)
07:32:51 <Ero> etiago, a function that has type (IO a ) is a set of instructions for obtaining something of type a
07:33:05 <glguy> IO a is not the type of a function
07:33:27 <ertes-w> etiago: getLine is what we often call an "action" that produces a String
07:33:28 <etiago> so what is getLine then if its type is IO String?
07:33:49 <ertes-w> etiago: and note how this has nothing to do with monads…  it's just understanding IO
07:34:33 <glguy> etiago: You could call it an IO action or action. Functions have type (a -> b) for some a and b
07:34:51 <ertes-w> etiago: other common terms are "program" or "recipe"
07:35:05 <ertes-w> getLine is a "program that produces a String", or a "recipe for a String"
07:35:11 <etiago> hmm so, could you say that a Maybe a is a Maybe action? they seem to have similar types, except one is using the IO monad and the other a Maybe monad?
07:35:22 <ertes-w> executing that action/program/recipe involves real-world effects, and the end result is a String
07:35:41 <ertes-w> yeah, we use the term "action" that way
07:35:45 <ertes-w> Nothing is a Maybe action
07:36:09 <Ero> imporant to note etiago is that we can only assume we have the string if we remain inside of IO
07:36:43 <Ero> its not possible to have 'gotten the string' if the functions operating on said string dont exist within the assumption of IO
07:37:03 <etiago> okay, I think I got it now
07:37:13 <Ero> once we leave IO, we leave any possibility of obtaining something to work on
07:37:35 <etiago> Ero, and basically what's left to work with is what was there at compile time I guess
07:39:54 <michalrus> Hey, how about ```cancel `traverse_` (catMaybes . (snd <$>)) internalThreads```? Is this terrible style? I mean… it’s kind-of readable if you ignore the symbols.
07:39:55 <tdammers> mnoonan: mocking, I would call it
07:40:04 <tdammers> mnoonan: or maybe trolling
07:40:54 <Profpatsch> Oh no, his sense for æsthetics is just im-pec-ca-ble
07:41:06 <mnoonan> first comment on the first hit for "simon peyton jones comic sans": "Maybe he just doesn't care about types."
07:42:33 <fizzgig> hi, can anyone tell me why test1 blocks nicely waiting for input here, but test2 ends up with an exception: thread killed? http://lpaste.net/359192
07:43:26 <fizzgig> test1 is from here https://ghc.haskell.org/trac/ghc/ticket/3997
07:44:08 <Ero> before i waste my entire afternoon getting my head around circular programming: is using circular programming to traverse a structure only one considerably more efficient than traversing that structure 2 or 3 times?
07:52:03 <rien> Does anyone have a fleshed out example of a Servant route fully annotated with Data.Swagger and Servant.Swagger ?
07:52:05 <c_wraith> Ero: it can be better or worse.
07:52:19 <rien> I'm having trouble understanding how to use the summary lens on it
07:52:34 <c_wraith> Ero: it depends on how bad it is to keep the whole thing in memory.
07:53:21 <c_wraith> Ero: and whether the version without knot-tying can stream nicely
08:00:04 <Ero> thx c_wraith 
08:00:33 <ertes-w> @where iotut
08:00:33 <lambdabot> https://www.vex.net/~trebla/haskell/IO.xhtml
08:00:36 <ertes-w> etiago: ^
08:00:51 <c_wraith> Ero: some simple examples of where it is a win include things like cycle
08:00:53 <c_wraith> @src cycle
08:00:54 <lambdabot> cycle [] = undefined
08:00:54 <lambdabot> cycle xs = xs' where xs' = xs ++ xs'
08:00:55 <Ero> im assuming if i have to reverse a list, and reverse it back again, that would not stream nicely at all lol
08:01:05 <c_wraith> No, that does not stream nicely. :)
08:01:27 <Ero> thx 
08:01:28 <ertes-w> Ero: multiple (computational) traversals are always expensive, not necessarily because the traversal itself is, but because of the terrible cache behaviour
08:01:42 <Ero> oh thats interesting
08:01:43 <c_wraith> Ero: most of the time you can avoid a double-reverse with a slightly more clever traversal though.
08:02:34 <c_wraith> Ero: like..  dropNEnd n xs = zipWith const xs (drop n xs)
08:03:07 <ertes-w> Ero: BTW, multi-traversal concerns are largely orthogonal to recursiveness
08:03:24 <c_wraith> It's still a double traversal, but it's not a double-reverse anymore, at least
08:04:06 <ertes-w> regarding 'cycle': it's not always a win to retraverse
08:04:27 <ertes-w> computing a list is often much cheaper than reading it from memory
08:04:36 <ertes-w> pathological example:
08:04:42 <ertes-w> > cycle (replicate 1000 'a')
08:04:45 <lambdabot>  "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa...
08:05:16 <ertes-w> this will perform horribly, and it will get worse the longer the argument list is
08:06:18 <c_wraith> that doesn't get better if you change the implementation of cycle, though.
08:06:23 <etiago> ertes-w cheers, going home now and will have a read later :)
08:07:00 <c_wraith> because the result of replicate 1000 'a' is still going to be shared
08:08:53 <c_wraith> So no matter how you implement cycle, you're going to need to traverse the result of the replicate
08:10:23 <c_wraith> I don't see any case where tying the knot makes cycle worse.  It's just bad on large input no matter what.
08:10:37 <ertes-w> c_wraith: you would have to change the type, yeah
08:10:57 <ertes-w> unsharedCycle :: (() -> [a]) -> [a]  -- something like that perhaps
08:11:18 <ertes-w> although optimisations could kill its performance regardless
08:11:18 <c_wraith> and then hope that GHC doesn't optimize out the clearly useless function. :P
08:11:23 <ertes-w> yeah =)
08:12:05 <ertes-w> i kinda wish GHC would just consider functions of () as "this is clearly a sharing-related hack, so i'm not gonna optimise it away"
08:12:23 <ertes-w> (or perhaps something other than (), because that one is used in many cases where you'd *want* to optimise it)
08:12:52 <Ero> ertes-w: if i understand you correctly, multiple traversal concerns only need to consider recursive solutions if the whole data structure needs to be evaluated per traverse, which would ruin the automatic benefit of lazy evaluation?
08:13:49 <Ero> otherwise, its as you said, largely orthogonal to recursion?
08:14:39 <ertes-w> Ero: consider that a non-recursive structure is really just a structure with a static recursion depth
08:14:54 <ertes-w> Ero: data Vec4 a = Vec4 a a a a
08:14:55 <Ero> i see
08:15:16 <ertes-w> traversing this certainly does take time, and traversing it twice will take at least twice the time
08:15:20 <dsal> I have a list monad that takes from several lists, runs several guards and then emits...  Is it possible to trivially parallelize this?
08:15:44 <ertes-w> dsal: s/monad//
08:16:07 <ertes-w> dsal: your description is too vague to answer that…  could you paste your code?
08:16:13 <dsal> https://repl.it/M3Wd/6 <- line 70
08:16:19 <EvanR> ertes-w: i keep wanting (without good justification) a way to traverse something multiple times, but by not remember the data structure between them to reduce memory usage
08:16:21 <dsal> The mechanism is kind of magic to me.
08:16:30 <EvanR> like, clone a thunk
08:16:59 <c_wraith> dsal: list is inherently difficult to parallelize, as it's a serial structure.
08:17:07 <cocreature> there is an embarrasingly long GHC trac ticket on explicit “unsharing” but last I checked no conclusion was reached
08:18:00 <ertes-w> EvanR: do you need to traverse sequentially?
08:18:02 <dsal> c_wraith: Understand.  This case feels like it'd be parallelizable since it's conceptually a sort of filter over a zip.
08:18:02 <EvanR> its interesting that sharing and unsharing can both speed shit up
08:18:59 <EvanR> ertes-w: in the case of a lazily generated list, yes
08:19:28 <cocreature> EvanR: isn’t that a pretty common pattern when it comes to speeding shit up? optimization would be a lot easier if things that sometimes speed up shit couldn’t also slow down your code
08:19:39 <ertes-w> well, it's a fairly common time/memory trade-off that in other languages you would make by (not) caching
08:20:10 <ertes-w> haskell just happens to have that sort of caching built-in
08:20:15 <EvanR> it makes sense, but i guess ive been off coffee so long i cant instantly see all the reasons for it
08:20:46 <EvanR> its not just a time memory trade off
08:20:47 <ertes-w> but sometimes i find myself in a situation where i'd really like to unshare
08:20:57 <EvanR> because using more memory in haskell equals a time penalty due to GC
08:21:15 <ertes-w> sharing in GHC-haskell is a one-way deal unfortunately
08:21:43 <ertes-w> you took it as a function argument, so tough luck, it's shared now
08:22:27 <ertes-w> EvanR: using more memory is not necessarily GC-heavy, if it's sufficiently short-lived, but it is a cache penalty
08:27:05 <simg_> Hi, anyone familiar with servant? I'm working through the servant-persistent example/tutorial (here: https://github.com/haskell-servant/example-servant-persistent) trying to work out how to combine more than one api. so far I've come up with this: http://lpaste.net/359195
08:27:22 <simg_> I'm just completely missing how to wire this up.
08:29:54 <EvanR> ertes-w: I mean, if you have a lazy, small generator of a lot of data
08:30:13 <EvanR> doing two things with all of it will mean a lot of memory
08:30:27 <EvanR> if you could suspect GC during all the time, maybe youre right but that sounds insane
08:30:30 <EvanR> suspend
08:30:55 <EvanR> i think the idiomatic way to deal with this is, combine all the things you want to do with it into the one traversal?
08:30:58 <EvanR> like average
08:31:09 <eman0n> Hi there, I am new to haskell, is it necessary to follow the advises of HLint?
08:31:14 <EvanR> thats highly non-decomplected
08:31:33 <Atomic_Mgpne> sman
08:31:36 <c_wraith> eman0n: it's not necessary.  but many of them are good ideas.
08:32:11 <eman0n> Hlint suggests me to use eta reduce when I try to apply map
08:32:38 <c_wraith> eta reduction is usually a good idea
08:32:47 <c_wraith> it trains you to think of functions as real values
08:33:16 <EvanR> real valued functions
08:33:23 <eman0n> please explain it in specifically?
08:33:34 <c_wraith> EvanR: sorry, we don't have those.  we're using computers. :P
08:33:34 <eman0n> please explain it specifically*
08:34:16 <c_wraith> eman0n: let's say you had a function like incrementAll :: [Int] -> [Int] ; incrementAll xs = map (+1) xs
08:34:53 <eman0n> this is not eta reduce form?
08:34:57 <c_wraith> eman0n: if you rewrite that as incrementAll = map (+1) it's training you think about things a bit differently
08:35:30 <c_wraith> eman0n: in particular, it trains you to think of "map (+1)
08:35:47 <c_wraith> err.  "map (+1)" as a value by itself, that happens to be a function
08:35:51 * ski values functions
08:36:11 <c_wraith> Functions are values.  They aren't just things that are applied to arguments.
08:36:27 <eman0n> I am trying to understand it..
08:36:39 <ski> sometimes, function composition will look good
08:37:13 <ski> `map (+1)' is the function that, when given a list of numbers, will produce the corresponding list where all the numbers have been incremented by one
08:38:02 <ski> instead of defining `incrementAll' to be the function that, when given a list `xs', applies the function `map (+1)' to that list (and yields the result of that function application) ..
08:38:17 <ski> .. we can simply define `incrementAll' to *be* the function `map (+1)', directly
08:38:56 <nicknight> Hello ski 
08:39:00 <ski> hello nicknight
08:39:17 <eman0n> ok, thank you!
08:39:21 <nicknight> whats up ?
08:39:41 * ski is hungry ..
08:40:23 <nicknight> Ok carry on :)
08:40:41 <ranberry> Haha, I'm glad I wasn't the only one who had to read through the section on Currying a few times when starting to learn Haskell
08:41:03 <fizzgig> can I resume reading off a getChanContents after killing off a thread that was evaluating it before? signs point to no but I don't understand why if it works with getContents
08:41:33 <c_wraith> getChanContents is weird.
08:41:35 <ski> eman0n : typically, we think of `map' as taking two arguments, one function and one list. however, all Haskell functions take exactly one argument. so, sometimes it can help to think of `map' directly as a function that takes an argument (a function) and returns a new function (taking a list and returning a list) .. which is what it actually is
08:42:16 <fizzgig> c_wraith: yeah but so's getContents. I don't know why they're not the same kind of weird :)
08:42:27 <ski> ranberry : note that "Haskell has currying" is a misunderstanding. curried style is a *convention* (for how to represent multiple-argument functions)
08:42:51 <c_wraith> ski: haskell does have a function application syntax that is very friendly with currying. :)
08:42:57 <ski> indeed :)
08:43:47 <ski> also, you can define a function `f' like `f x y = ..x..y..', rather than having to say, say, `f x = \y -> ..x..y..' or `f x = g where g y = ..x..y..'
08:44:07 <ranberry> So to make sure I understand, currying is more of a way to interpret multi-argument function than a valid representation of what is going on behind the scenes?
08:44:30 <ski> (in (plain) Scheme, you can't say `(define ((f x) y) ..x..y..)', you have to say `(define (f x) (lambda (y) ..x..y..))')
08:44:57 <dsal> ranberry: It gets easier once you realize that functions have one argument and return one value.
08:45:14 <ranberry> Oh I totally understand that part
08:45:37 <ski> ranberry : s/interpret/represent/. the separate passing of the arguments to successively returned functions may be optimized by an implementation
08:46:11 <ski> the other common style for representing multiple-argument functions (e.g. in Haskell) is tupled style, when you say `f (x,y) = ..x..y..'
08:46:43 <ski> sometimes one style is more convenient, sometimes the other. in case it doesn't matter much, Haskell tradition is to use curried style
08:48:08 <ski> (tupled style may be more convenient, when you want to group some arguments together, as a unit. it means that you don't have to deconstruct them into inedividual components. it also means that you directly can "chain" a couple of results from one function, passing them as a compound argument to another)
08:49:17 <ski> when using curried style, it may pay off to briefly consider whether it's more likely to want to partially apply it to one argument over another. the arguments that "change less often" should typically be earlier (curried) arguments
08:49:44 <ski> making the type signature look more pretty may also be a factor in argument ordering, e.g.
08:50:09 <ski>   map :: ( a  ->  b )
08:50:10 <ski>       -> ([a] -> [b])
08:50:58 <ski> this means that one can nicely chain it with itself
08:51:01 <ski> @type map . map
08:51:03 <lambdabot> (a -> b) -> [[a]] -> [[b]]
08:51:11 <ski> @type fmap . fmap
08:51:13 <lambdabot> (Functor f2, Functor f1) => (a -> b) -> f1 (f2 a) -> f1 (f2 b)
08:51:19 <ski> @type liftA2 . liftA2
08:51:21 <lambdabot> (Applicative f2, Applicative f1) => (a -> b -> c) -> f1 (f2 a) -> f1 (f2 b) -> f1 (f2 c)
08:52:06 <ski>   liftA2 :: Applicative i => (  a ->   b ->   c)
08:52:07 <ski>                           -> (i a -> i b -> i c)
08:52:55 <ski> (see how `liftA2' "promotes" a function, taking an `a' and a `b' into a `c', into a corresponding function taking an `i' of `a', and an `i' of `b', into an `i' of `c')
08:54:04 <ski> ranberry : what `liftA2', or `fmap' actually does, may not be familiar to you yet. hopefully the prettiness argument is getting through, though
09:02:35 <ranberry> I understand how to use liftA2 and fmap from a practical point of view, but it might take me a few minutes to really understand the point that you are trying to make. Thanks for the thoughtful explanation!
09:05:31 <ski> one could have imagined that instead of saying `liftA2 f blah bleh', one'd say `liftA2 blah bleh f'. but then instead of `(liftA2 . liftA2) f blah bleh' (which is the same as `liftA2 (liftA2 f) blah bleh'), one'd have to do the more awkward `liftA2 blah bleh (\x y -> liftA2 x y f)'
09:15:36 <ranberry> Right, I definitely think I'm starting to understand your point Ski.
09:29:05 <aarvar> Is there a reason why there's no function extensionality for Coercions? i.e. why there's no function of type (forall x. Coercion (f x) (g x)) -> Coercion f g ?
09:34:12 <lyxia> what would that be good for
09:37:24 <aarvar> lyxia: the example I ran into is I have data PairOf a b f = PairOf (f a) (f b) and can't seem to coerce PairOf a b (Compose f g) to PairOf a b (f :.: g)
09:37:55 <aarvar> though I can if I define PairOf as a newtype of a tuple instead at least
09:41:39 <AWizzArd> Where can I find GHC’s implementation of Traversable for functions?
09:42:58 <Psybur> AWizzArd, https://hackage.haskell.org/package/base-4.10.0.0/docs/src/Data.Traversable.html ?
09:43:57 <AWizzArd> Psybur: I looked at that one. Can’t spot it.
09:44:31 <aarvar> AWizzArd: functions arent traversable
09:45:03 <aarvar> or at least, ((->) r) isn't traversable for all r
09:45:16 <aarvar> so presumably you cant find it anywhere :)
09:45:28 <AWizzArd> I saw this:  sequence :: Monad m => [m a] -> m [a]
09:45:37 <AWizzArd> And thought that functions are Monads.
09:46:02 <AWizzArd> And I have a list of fns, i.e. [a -> b]
09:46:03 <aarvar> the traversable there is []
09:46:13 <aarvar> oh, then you're looking for the Traversable [] instance
09:46:25 <aarvar> ((->) a) is the applicative there
09:46:47 <aarvar> :t sequenceA
09:46:49 <lambdabot> (Applicative f, Traversable t) => t (f a) -> f (t a)
09:47:24 <AWizzArd> Oki, will look for applicatives.
09:49:11 <peter789> hi there!
09:49:43 <kody^> peter789: heelo!
09:50:32 <peter789> i've just been reading the CA Comonad blog post on sigfpe...
09:50:45 <edwardk> ?
09:50:48 <peter789> can any kind of zipper be made into a comonad?
09:51:15 <edwardk> you can talk about a data type with a single hole as a pair of the 'hole' and the surrounding path that gets you there
09:51:27 <edwardk> so you first have to open a thing up, it might not have any positions
09:51:44 <edwardk> but once you have that then yes, the result is trivially a 'coreader' or environment comonad
09:58:05 <peter789> edwardk: thanks, I think I see. It's that simple? :) I kind of suspected it when I saw the ((,) e) instance
09:58:29 <peter789> so the hard part is figuring out how to define duplicate on a particular data structure, i guess?
09:59:39 <peter789> i'd also like to point out that I'm pretty new to haskell, so please bear with me :)
10:00:33 <edwardk> peter789: viewed as (,) e  the zipper is boring, make a copy of the path.
10:00:44 <edwardk> that is not the same as the comonad for
10:00:55 <edwardk> data Zipper a = Zipper [a] a [a]  -- for lists for instance
10:01:12 <edwardk> so you need to be careful
10:02:14 <edwardk> one way to think about the zipper for lists is to realize we can put the elements into a number line and have so many elements
10:02:34 <peter789> right, but that wouldn't work in say a tree
10:02:48 <edwardk> so that zipper is isomorphic to data Zipper a = Zipper (Natural -> a) Natural
10:02:55 <edwardk> then this zipper is a store comonad
10:05:51 * hackagebot hpack 0.19.3 – An alternative format for Haskell packages – https://hackage.haskell.org/package/hpack
10:23:43 <peter789> edwardk: thanks for pointing me in the right direction, very interesting, even though I don't understand half of it :)
10:25:45 <Psybur> Lets say I have a data T = I Int | C Char. If a function takes in a [[T]], is there an easy way to tell the compiler that in [a,b] a is a [I] and b is a [C] ?
10:26:26 <mnoonan> Psybur: what problem are you actually trying to solve?
10:26:55 <aarvar> Psybur: [fmap I a, fmap C b] ?
10:27:30 <Psybur> I transposed a list of heterogenous lists to get a list of homogeneous lists. I was wondering if I could coerce the types instead of having to fmap
10:27:35 <EvanR> do you want ([Int], [Char]) instead ?
10:28:24 <EvanR> the transpose of that is [(Int,Char)]
10:29:17 <Psybur> I want separate lists of I and C. I suppose I might have to refactor
10:29:33 <EvanR> yep
10:29:45 <EvanR> you dont have to separate what you didnt merge together 
10:29:46 <Psybur> I guess instead of using a list before transposing I should have used a tuple?
10:30:34 <Psybur> I couldnt transpose a list of tuples into lists of lists could i heh
10:30:37 <EvanR> since you have that uniform structure going, list of tuple or tiple of lists would express that
10:30:56 <EvanR> doesnt sound like a hetero list
10:32:00 <Psybur> Is there a builtin for transposing this datastructure? Or am i gonna have to write my own function :o
10:32:21 <EvanR> theres probably a pithy one liner (or two syllabler)
10:32:49 <EvanR> (map fst xs, map snd xs)
10:33:01 <EvanR> and
10:33:02 <EvanR> :t zip
10:33:04 <lambdabot> [a] -> [b] -> [(a, b)]
10:33:30 <EvanR> :t curry
10:33:32 <lambdabot> ((a, b) -> c) -> a -> b -> c
10:33:36 <Psybur> Hmm but what about a triple or quadruple
10:33:43 <EvanR> :t zip3
10:33:45 <lambdabot> [a] -> [b] -> [c] -> [(a, b, c)]
10:34:25 <EvanR> in the limit...
10:34:49 <Psybur> :t zip5
10:34:51 <lambdabot> [a] -> [b] -> [c] -> [d] -> [e] -> [(a, b, c, d, e)]
10:34:55 <EvanR> (,,,,) <$> as <*> bs <*> cs <*> ds <*> es
10:34:57 <EvanR> and so on
10:35:27 <EvanR> but i question your need for triples and quadruples
10:35:59 <Psybur> EvanR, reading in a csv, turning columns into vectors
10:36:13 <EvanR> a csv has a dynamic number of columns
10:36:21 <Psybur> This one does not
10:36:31 <EvanR> then you should define a record type for a row
10:36:44 <aarvar> EvanR: the applicative for lists doesnt zip
10:36:46 <EvanR> and a function which turns a row into a record of the correct type
10:36:58 <EvanR> aarvar: oh...
10:38:01 <EvanR> e.g. ... readRow :: ByteString -> Maybe (MyRow, ByteString)
10:38:19 <EvanR> returns the converted, verified row, and the rest of the csv data
10:38:34 <EvanR> or fails miserably
10:39:11 <EvanR> based on an edk video i watched last night, though, i would want a way to get as many valid rows as i can
10:40:59 <Psybur> EvanR, I already do something like this. It seems like all of my apps time is spent converting my initial data structures into the storable vectors I create later on. Was going to just try creating the storable vectors up front. Line 64 and 65 https://github.com/jrciii/money-machine/blob/master/src/MoneyMachine/ClusterStrategy.hs and the file is read and parsed at the top of https://github.com/jrciii/money-machine/blob/maste
10:40:59 <Psybur> r/src/MoneyMachine/Backtest.hs
10:41:18 <Psybur> But maybe Im missing something else
10:41:52 <EvanR> well tuples doesnt sound like the best way to go about skipping that step
10:42:53 <Psybur> Right now it goes Lists of row -> vectors of row -> vectors of the columns of row
10:43:24 <Psybur> Was seeing if I could just get rid of vectors of row heh but I guess Im just creating some different datastructure in the middle
10:43:36 <EvanR> if you have a list of row, and field accessors for the row record, then you can just fmap to get the list of field
10:43:53 <EvanR> and then vectors
10:44:03 <EvanR> should be lazy and the lists almost dont exist
11:29:39 <Athas> Anyone got an examples of a Stack-based project with multiple packages?
11:29:52 <Athas> Is there anything in particular I should be aware of?
11:30:56 <sm> hledger
11:31:12 <sm> some tools won't handle it, eg all the IDE addons
11:32:15 <sm> release practices are a bit more tricky - branches, changelogs, do you release all together, what if you need to update one
11:32:35 <Athas> Hm, and keeping the version numbers consistent across all the packages...
11:32:59 <Athas> I use hpack, so I wonder if YAML supports importing another file.  It has so much other crud.
11:33:13 <Athas> Seems not.
11:33:35 <Psybur> Is it possible to start a vector off with an initial size?
11:33:37 <sm> I think you'll end up needing a custom version bumping script, it appears in so many places
11:33:52 <Athas> Drat.  I'm really annoyed with Cabal's poor support for multiple executable targets, and I hoped this would be a handy workaround.
11:34:09 <sm> it works great, these are just some of the challenges
11:34:50 <Athas> Releases are rare enough that the bumping can be scripted easily enough.
11:36:17 <Psybur> I see basicUnsafeGrow happening a lot in my profiling results. Wondering if this is avoidable
11:45:33 <sheyll> @peter789 only if the thing cannot be empty
11:45:33 <lambdabot> Unknown command, try @list
11:46:18 <iqubic> sheyll: No need to use at here.
11:46:48 <sheyll> @peter789 because extract :: w a -> a cannot possibly be implemented if a (w a) can be empty
11:46:48 <lambdabot> Unknown command, try @list
11:47:04 <sheyll> ah ok
11:48:52 <Athas> Man, I have too many executables.  I should probably generate even my package.yamls!
11:49:13 <sheyll> Athas: Multi-package stack projects work great, I just regret that we used git submodules for the packages in our project setup
11:50:22 <Athas> sheyll: do you maintain the package.yaml/foo.cabal files by hand?
11:50:37 <Athas> I guess it's not the end of the world.
11:50:39 <sheyll> yeas
11:51:19 <sheyll> I which there would be more versioning tooling 
11:51:42 <Athas> I will give it a try.
11:52:34 <Athas> My current project is a big library and ten executable targets.  I think I could split it into one small library package, a big library package, and ten executable packages with little issue.
11:52:38 <sheyll> but we manage the versions through git-branches/tags and generate executables that we put into rpms with those versions, effectivly we dont use the cabal versions at all
11:53:06 <Athas> Okay.  I'll want to maintain the same version number across all my sub-packages.
11:53:25 <sheyll> right now we have version 0.1.0.0 on every package ;)
11:54:04 <peter789> sheyll: right, but in that case couldn't you always wrap it in a Maybe ?
11:54:22 <sheyll> uhm .. a maybe is not a comonad
11:54:48 <sheyll> lists also are not a comonad
11:55:51 <peter789> oh, i see what you mean
11:56:51 <sheyll> there needs to be a place for a hole in a zipper, and that hole must always be available in every clause of the data type
11:56:54 <peter789> I meant, you could have extract return a Nothing or [] when there's nothing to return. does that make sense>
11:57:10 <sheyll> no 
11:57:15 <sheyll> extract :: w a -> a
11:57:25 <sheyll> so if it returned Nothing
11:57:28 <Psybur> If I have a definition that gets used multiple times, sequentially, in a function, is that definition going to be recreated each time its used?
11:57:35 <sheyll> it would be w a -> w a
11:57:38 <Psybur> let a = blah
11:57:49 <Psybur> let a = blah; b = f a; c = g a
11:57:49 <sm> Athas: I would think really hard about whether you need so many packages, when you consider the overhead of releasing/packaging/keeping bounds current for each one
11:58:04 <sheyll> sm: yes
11:58:10 <Psybur> Is a going to be evaluated twice?
11:58:28 <Psybur> (lets say b and c both get used)
11:58:42 <Athas> sm: I suppose I could shrink their number a bit.  Maybe make one package for things that I rarely want to build.
11:58:58 <fishythefish> Psybur: that's an implementation detail, really
11:58:59 <peter789> ah, now I get it
11:59:03 <sm> why do you want more than one package, eg ?
11:59:04 <Athas> However, I will probably need at least five packages, and then I might as well have twenty, as I will need automated tooling anyway.
11:59:14 <fishythefish> but purity generally means that it doesn't have to be re-evaluated, and in practice, expressions that are bound to a name will typically be evaluated once
11:59:47 <Athas> sm: I have ten executable targets (and will have more in the future), and Cabal wants to touch all of them.
12:00:06 <pie___> whats the best language to embed in a haskell app for scripting?
12:00:14 <fishythefish> more haskell :)
12:00:22 <pie___> you can embed haskell?
12:00:28 <pie___> i mean runtime
12:00:50 <sm> Athas: so you could have one package containing ten executables, but you feel splitting it up will speed up your builds ?
12:01:07 <yushyin> pie___: maybe husk-scheme?
12:01:16 <Athas> sm: yes.
12:01:22 <Athas> I have one package with ten executables at the moment.
12:01:24 <sheyll> pie___: https://hackage.haskell.org/package/hint
12:01:29 <pie___> Athas, oh yay scheme
12:02:11 <sm> could you make them subcommands of one executable ?
12:02:33 <sheyll> pie___: in hint there is a function interpret :: (MonadInterpreter m, Typeable a) => String -> a -> m a 
12:02:52 <Athas> sm: no.
12:02:59 <sm> just brainstorming
12:03:06 <sheyll> pie___: it might be a heavy dependency though l(
12:03:52 <sm> I don't think my multi-package project wastes time building parts I'm not currently working on. I tell it which executable or lib section I want to build
12:03:55 <pie___> sheyll, haha i figure
12:04:06 <pie___> sheyll, as long as its an optional dependency
12:05:07 <Boarders> this is a dopey/nooby question so apologies:
12:05:14 <Boarders> say I have something like
12:05:29 <Boarders> newtype Matrix a = Mat{rows :: [[a]]}
12:06:47 <Boarders> I want it so if I have a function like f::[[a]] -> [[b] -> [[c]] then I can wrap that to f: Matrix a -> Matrix b -> Matrix c
12:07:09 <Boarders> if it were just a wrapper with some records I would know how to do it with applicative so I was wondering if there is a general answer like that
12:08:08 <Athas> sm: stack copies all of the executable at the end of a 'stack build'.
12:08:13 <Athas> That can take a long time.
12:08:23 <sm> seriously ? how big are they ?
12:08:23 <hexagoxel> Athas: what do you mean by "Cabal wants to touch all of them" ?
12:08:46 <sm> and there's a --no-copy-bins flag
12:09:11 <Athas> sm: ~30MiB each, I suppose.
12:09:39 <sm> that wouldn't take long on my macbook
12:09:50 <ClaudiusMaximus> i have a sandbox with gtk in it, amongst other things.  now whenever i install anything in it it reinstall gtk2hs-buildtools (same version each time).  what's up with that?
12:10:15 <Athas> hexagoxel: it might actually be stack that wants to copy them from some temporary location to .stack-work/install/x86_64-linux-nopie/nightly-2017-09-01/8.2.1/bin.
12:10:22 <sheyll> If f changes the structure of the matrix you cannot use an applicative because of the applicative law, but what you seem to want is lenses, that define a 'row' lens
12:10:24 <Athas> --no-copy-bins does not help.
12:11:14 <Boarders> oh cool, thanks
12:11:14 <sheyll> Boarders: ... just write a wrapper function, that might be easier :)
12:11:31 <Boarders> wouldn't mind trying to learn lenses so maybe this is a way in
12:12:17 <hexagoxel> Athas: what kind of overhead do you see that would benefit from splitting up the package, though? or is it just that stack is too stupid to target single components?
12:13:11 <zipper> Hello, might anyone know why my `install` section runs before my `before_install` section here https://raw.githubusercontent.com/urbanslug/blog/master/.travis.yml
12:14:07 <Athas> hexagoxel: the latter is currently my main concern, assuming that Cabal is otherwise smart enough to avoid unnecessary recompilation.  However, there may also be organisational benefits in not having one mega-library that does everything.
12:14:31 <Athas> I'm writing a compiler, and it might be nice not to have to compile e.g. all the code generator backends every time.
12:16:37 <hexagoxel> (neither Cabal-the-library nor Cabal-the-format does any building..)
12:18:30 <Athas> Actually, I'll just report these unnecessary copies as a bug/feature request for Stack.  It looks like that even after splitting the repository, doing a "rebuild" of a single executable after touching its file still takes 30s, versus 1m07s before.
12:18:59 <sm> why did you say --no-copy-bins doesn't help ? didn't that stop the copies ?
12:19:40 <sm> I don't think copying files is causing slowness
12:20:37 <Athas> sm: --no-copy-bins doesn't stop the copies, no.  And I can follow along in the terminal and see that the copies are what's taking the time.
12:20:41 <dmwit> Boarders: `coerce :: ([[a]] -> [[b]] -> [[c]]) -> Matrix a -> Matrix b -> Matrix c` ?
12:20:51 <Atomic_Mgpne> has someone else issues with stack on arch? On Ubuntu I typed "stack exec name-of-the-exe" and it launch the app, on arch I have to specify the location in .stack-work/../
12:21:00 <dmwit> ?hoogle coerce
12:21:00 <lambdabot> GHC.Prim coerce :: Coercible a b => a -> b
12:21:00 <lambdabot> System.Unsafe coerce :: a -> b
12:21:00 <lambdabot> Agda.TypeChecking.Conversion coerce :: Term -> Type -> Type -> TCM Term
12:21:13 <Athas> Stack may copy each *twice*.  Once (unconditionally) from some temporary directory to a 'bin' dir in .stack-work, and then optionally to $HOME/.local/bin.
12:21:22 <dmwit> Boarders: The GHC.Prim one.
12:22:26 <sm> ah.. --no-copy-bins probably stops the copy to $HOME/.local/bin (which "build" doesn't do by default)
12:23:43 <Boarders> I am more scared of figuring out something about coerce than I am reading a lens tutorial
12:24:28 <sm> Athas: I'm curious how long does "stack build oneexe" take, after a code change/touching file/no change
12:24:32 <dmwit> coerce is perfectly safe. After all, it isn't unsafeCoerce. ;-)
12:25:03 <Athas> sm: 1m07s, including the copies.  Less than 30s without those copies.
12:25:06 <Athas> (Estimated.)
12:25:18 <sm> why is there more than one copy if you're just building one executable ?
12:25:34 <Athas> Who knows?
12:25:38 <sm> and there should be no copy if nothing has changed
12:25:40 <dmwit> Copying files around is taking 37s? Something is broken, unless your files are gigs big.
12:25:50 <sm> I think measurement is important here
12:25:59 <dmwit> ...is something on a network filesystem?
12:26:19 <sm> "Estimated" is not a good reason to create a zillion packages and the corresponding headaches for the rest of time :)
12:27:10 <dmwit> Even cheap hard drives ought to be able to sustain about 50MiB/s.
12:27:12 <dmwit> > 50*37
12:27:16 <lambdabot>  1850
12:27:57 <qmm> i'm working with a few people who only want to use python, and i want to use haskell. what are some ways of allowing me to write haskell and allow others to write python for controlling the software?
12:28:49 <qmm> i don't think i'd want to call into python
12:29:59 <Athas> sm: the estimate is definitely an upper bound, because that's what it takes when I remove all but one executable.
12:30:44 <sm> stack build -v shows each action timestamped, btw
12:31:53 <Athas> Ah, right.  That shows it's definitely the copying that takes time.
12:31:53 <sheyll> qmm: where I work we had a python/haskell project, and the python code just generated yaml and called the executable written in Haskell
12:32:14 <Athas> I agree my disk is weirdly slow, but such is life.
12:32:32 <sm> defrag that sucker!
12:32:41 <dmwit> qmm: I can't speak for everybody here, but for me, I'm not touching that question with a 10-foot pole. It sounds too much like "everybody has asked me not to do X, how can I do X anyway without pissing them off?".
12:33:05 <sheyll> qmm: after a while, seeing the safety of Haskell vs the burden of extra unit tests etc und Python, the team voted for a collective Haskell course, I was the only Haskell programmer and I wasnt in the room ;)
12:33:23 <dmwit> The correct answer is not "here's how to do X", it's "maybe you should talk to them about why they don't want you to do X and address those concerns first".
12:34:18 <qmm> dmwit: haha. this isn't true. i should have instead stated that i'm _going_ to be working with people who have familiarity with python and c, but no experience in haskell, and i don't think they would bother learning haskell from my experience with them. 
12:34:37 <qmm> dmwit: i understand your sentiment though :)
12:34:58 <sheyll> qmm: you should just demonstrate haskell, by using it side by side, if they agree
12:34:59 <qmm> sheyll: very nice
12:35:17 <sheyll> qmm: do one part of the project in haskell and offer to remove it any time
12:35:56 <sheyll> qmm: never ever push them
12:36:02 <sm> prototype in haskell, also deliver a python translation, but use the haskel prototype for everything
12:36:26 <mnoonan> you can make your component into a shared library, export a C interface, and let the python side call it through the python FFI
12:36:35 <mnoonan> (but also +1 to dmwit's comment)
12:36:45 <sheyll> sm: this too is what we do now where I work, we have some java and erlang, and we do prototypes in haskell sometimes
12:36:53 <sm> there's also force. Tell them you will write haskell and they will like it or be out of a job ?
12:37:26 <sm> you did ask for "some ways" :)
12:37:33 <sheyll> sm: the strongest force is the if the tool fits the job
12:37:44 <qmm> heh. thanks for the conversation everyone. this is good enough for me
12:38:15 <prasad> Can someone explain me how insert works in https://www.cs.kent.ac.uk/people/staff/smk/redblack/Untyped.hs. I am specifically looking at "where" clause
12:38:25 * sm got started using haskell for functional test scripts
12:38:29 <shapr> sm: wow, really?
12:38:50 <sm> shapr: you should know, you showed me one and got me totally hooked
12:39:04 <shapr> wait, it was me?
12:39:09 <sm> yup it was you
12:39:12 <shapr> dang
12:39:15 <sm> and, thank you :)
12:39:19 <shapr> yay? :-)
12:40:20 * hackagebot codec-rpm 0.2.0 – A library for manipulating RPM files – https://hackage.haskell.org/package/codec-rpm
12:42:52 <_sras_> Is there a tool to find out all the unused modules (modules that are not imported in any other module) in a stack/cabal project?
12:46:00 <cocreature> _sras_: https://github.com/ndmitchell/weeder#readme
12:48:40 <_sras_> cocreature: 'Weeder' requires the project to be in a buildable state, right?
12:49:37 <cocreature> not sure what the exact requirements are but I doubt it works if your project is completely messed up
12:50:01 <dminuoso> Well it does say that weeder builds your project.
12:55:19 <ElectronFreeAtom> haskell made me lose my hair
12:56:09 <Atomic_Mgpne> I'm starting lossing my hair now that I understood Lenses
13:21:59 <not_a_robot> Is there a well known typeclass or pattern for accumulating diffs to a state, throwing out or patching certain diffs based on known constraints, and then applying the grand total diff to the prior state to get a new one?
13:23:48 <Eduard_Munteanu> acid-state kinda does that.
13:24:13 <Eduard_Munteanu> What do you need it for?
13:27:49 <not_a_robot> I'm kind of just exploring the pattern, and the use cases are secondary concerns. Right now I'm just moving a character on a screen and having the movement keys append diffs, then on each frame the final diff is summed, normalized wrt top speed, and scaled back to avoid violating collision constraints. Ultimately I'd like to scale up to a graph and play around with something like exploring lazy 
13:27:55 <not_a_robot> non-deterministic Kripke models. It's for a toy, in other words.
13:33:49 * hackagebot data-diverse-lens 0.4.0.1 – Isos & Lens for Data.Diverse.Many and Prisms for Data.Diverse.Which – https://hackage.haskell.org/package/data-diverse-lens
13:49:58 * hackagebot data-diverse 1.0.0.1 – Extensible records and polymorphic variants. – https://hackage.haskell.org/package/data-diverse
14:11:28 <Benzi-Junior> hey so how come haskell fucks up character encodings on read for String values
14:11:39 <Benzi-Junior> and what is the quick and easy way to fix that 
14:12:08 <geekosaur> afaik it doesn't. if you are having encoding issues, check $LANG
14:14:02 <dmwit> Benzi-Junior: You'll need to supply further details about what you tried (including the exact code you ran), what you expected, and what happened instead if you want debugging help.
14:14:40 <geekosaur> and the input (be careful with pastebins, not all of them will be byte-correct)
14:14:53 <dmwit> It's usually considered polite to do a little work up front to produce a minimal, complete reproducing example. Put it on lpaste or a similar pastebin for us to look at.
14:15:55 <Benzi-Junior> dmwit, (read "\"þæö"" :: String)
14:15:58 <Tuplanolla> I can try reading your mind, Benzi-Junior: the encoding is fine, but you don't understand what escaping is.
14:16:13 <dmwit> Benzi-Junior: That's a parse error.
14:16:27 <Benzi-Junior> dmwit, (read "\"þæö\"" :: String)
14:16:42 <dmwit> Okay. What do you expect to happen? What happens instead?
14:16:48 <dmwit> It appears to give the correct result here.
14:16:53 <Benzi-Junior> I'd expect that to retur "þæö"
14:17:00 <dmwit> It does here.
14:17:12 <sbrg> Benzi-Junior: it just shows you the unicode codepoints
14:17:17 <sbrg> if you're doing this in ghci
14:17:19 <Tuplanolla> > text (read "\"þæö\"" :: String)
14:17:23 <lambdabot>  þæö
14:17:27 <Benzi-Junior> instead I get :"\254\230\246"
14:17:45 <dmwit> Benzi-Junior: And in what way do you believe that differs from "þæö"?
14:17:53 <dmwit> > "\254\230\246" == "þæö"
14:17:56 <lambdabot>  True
14:18:32 <dmwit> Benzi-Junior: N.B. ghci implicitly uses `print` to show return values. For String, you may prefer `putStrLn`.
14:18:47 <dmwit> Benzi-Junior: e.g. try `putStrLn (read "\"þæö\"")`.
14:19:24 <Benzi-Junior> dmwit, hmmm 
14:20:33 <Benzi-Junior> dmwit, ah now I see so the problem is caused by show not read
14:20:43 <geekosaur> show is supposed to produce valid source. about the only source format that doesn't run into encoding issues is one limited to printables \x20-\x7e
14:20:53 <geekosaur> so that is why show on String uses escapes
14:21:07 <geekosaur> *potential encoding issues, if your encoding differs from the origina;
14:21:37 <Benzi-Junior> geekosaur, ye that sounds reasonable
14:32:13 <fizzgig> I solved my resumable getChanContents problem from earlier with this dubious revision if anyone's interested http://lpaste.net/359205
14:32:34 <fizzgig> I don't think I have the chops to suggest it as a patch tho
14:34:24 <fizzgig> now you can chuck your lazy io stream between threads, hooray
14:42:28 * hackagebot htoml-megaparsec 1.0.1.2 – Parser for TOML files – https://hackage.haskell.org/package/htoml-megaparsec
14:58:38 * hackagebot gargoyle 0.1 – Automatically spin up and spin down local daemons – https://hackage.haskell.org/package/gargoyle
15:07:43 * hackagebot gargoyle-postgresql 0.1 – Manage PostgreSQL servers with gargoyle – https://hackage.haskell.org/package/gargoyle-postgresql
15:24:43 <teurastaja> is it normal if an eager SK combinator compiler results in an infinite loop with "\SK", "\KS", "\KK" or "\SS" ?
15:27:56 <mniip> no?
15:28:02 <mniip> neither of those are reducible expressions
15:31:27 <teurastaja> mniip: why not? it has "\"
15:33:23 <mauke> what is "\"?
15:33:33 <wagle> i forgot how i installed haskell (via brew on macos) and gitit (via homebrew's cabal). now that I upgraded macos to high sierra, cabal won't install gitit.  should I force/hack it, or do it some new "right" way?
15:33:34 <teurastaja> application
15:33:47 <wagle> s/haskell/ghc
15:36:22 <mniip> teurastaja, ??
15:37:00 <mniip> you mean I ?
15:37:09 <teurastaja> i dont have I yet
15:37:14 <mniip> ISK = SK
15:37:20 <teurastaja> just S, K and \
15:37:25 <mniip> the hell is \
15:37:26 <fishythefish> \ still doesn't make sense
15:37:28 <mauke> application
15:37:37 <fishythefish> thanks mauke 
15:37:38 <mauke> it makes sense if you don't have parens
15:37:45 <mniip> ok
15:37:49 <mniip> then \SK is irred
15:38:39 <mauke> \\\Sxyz = \\xz\yz or something
15:38:40 <mniip> you can only reduce \\\Sxyz and \\Kxy
15:39:13 <teurastaja> but \xy?
15:39:17 <mniip> no?
15:39:45 <fishythefish> x and y are variables; you can't reduce that application generally
15:39:58 <fishythefish> (i'm still a little unclear on the definition of \ - can anyone explain?"
15:40:07 <mauke> what's unclear?
15:40:12 <mniip> fishythefish, imagine polish notation for the juxtaposition operator
15:40:16 <fishythefish> ah
15:40:16 <mniip> instead of infix and parens
15:40:33 <teurastaja> wiki says reduce \xy results in \(reduce x) (reduce y)
15:40:39 <fishythefish> yeah, i straight up just didn't know what the arity was supposed to be
15:41:07 <teurastaja> i meant reduce \xy results in reduce(\(reduce x) (reduce y))
15:41:27 <mauke> what does that have to do with your original examples?
15:41:30 <mauke> you can't reduce S
15:41:55 <teurastaja> i know. it should return S
15:41:56 <fishythefish> if x and y are redexes then sure, but if you just ask about \xy with no context, those are just variables
15:42:01 <Wizek> For debugging reasons, could I have an `a -> Maybe Text` function that would call `show` on the `a` if it has a Show type class instance, and otherwise return Nothing? 
15:42:02 <teurastaja> but it doesnt
15:42:43 <Wizek> Without having to put that in as a constraint?
15:43:54 <geekosaur> Wizek, not really
15:43:56 <Wizek> I remember reading somewhere on reddit that if/then/else may be possible based on what is available in the instance dictionary.
15:44:03 <geekosaur> remember that typeclass instances are dictionaries
15:45:14 <geekosaur> and things are only added to the dictionary if they are known to be needed, i.e. there is a type constraint to be satisfied
16:40:09 <codeshot> Does anyone know why (ParsecT s u m a) doesn't have a Monoid instance defined. I expected to find that (pure <$> letter) <> (pure <$> letter) = do { f <- letter; s <- letter; (pure f) <> (pure s) }
16:41:15 <lyxia> Did you mean pure (f <> s)?   liftA2 (<>) letter letter
16:41:16 <codeshot> I mean: do { f <- letter; s <- letter; pure $ (pure f) <> (pure s) }
16:41:51 <codeshot> let me think a moment
16:42:21 <lyxia> you could define the Monoid instance for any Applicative functor
16:42:39 <lyxia> not sure why it's not done for parsec
16:42:41 <codeshot> I can remove genericity:  ((:[]) <$> letter) <> ((:[]) <$> letter) = do { f <- letter; s <- letter; pure $ [f] <> [s] }
16:43:14 <codeshot> ((:[]) <$> letter) <> ((:[]) <$> letter) = do { f <- letter; s <- letter; pure [f,s] }
16:43:48 <simon> ((:[]) looks like a man with a mining helmet and a square jaw.
16:44:20 <simon> just sayin'.
16:44:30 <codeshot> This way (<>) will sequence the parsed values together and I don't have to bother with all the "f <-...; s<-...; pure ..." noise
16:45:46 <codeshot> If I'm returning a Monoid that adds integers then (<>) will sum the parsed integers, etc
16:50:27 <lyxia> It looks like a general enough pattern that it deserves its own combinator
16:52:44 <codeshot> yeah, I'm gonna make my own "one = pure", "pempty", "pappend", and "pconcat"
16:53:10 <codeshot> maybe send the to the parsec maintainer
16:57:33 <codeshot> I guess for instance Monoid a => Monoid (ParsecT s u m a) to be in the library there has to be just one really obvious choice for the instance members' implementations
17:01:53 <mniip> codeshot, usually if (Alternative F) then you'd expect Monoid (F a) with no restrictions on a
17:02:10 <mniip> because that's just what Alternative is
17:15:05 <codeshot> It's not necessarily the right monoid choice
17:15:11 <codeshot> mniip
17:16:00 <codeshot> Not all alternatives have append == other choices
17:16:59 <lyxia> Is Applicative the right choice as a basis of Monoid for parsec?
17:17:08 <codeshot> for parsers you can see from the equality above that perhaps monoid shouldn't model "choice" like alternative does - instead it probably should model append of parse results
17:17:10 <lyxia> It all seems quite subjective
17:17:15 <ertes> mniip: i don't make that assumption, and i don't think i should have to
17:17:17 <codeshot> They often are
17:17:32 <codeshot> only a few instances are mathematically "necessary"
17:17:55 <lyxia> codeshot: what equality above? The one you currently need?
17:18:02 <codeshot> But sometimes there's an overwhelming case (eg, most of [a]'s instances)
17:18:06 <ertes> mniip: most often when i define (Alternative F), i'm much more likely to define a *useful* Monoid instance rather than just a copy of Alternative, like this:  instance (Monoid a) => Monoid (F a)
17:18:08 <lyxia> Doesn't that sound arbitrary?
17:18:21 <codeshot> This equality: Not all alternatives have "append" == "other choices"
17:19:42 <codeshot> As I gave the name "append" from Monoid's mappend I hoped that it would strongly suggest a relationship with "many" rather than (<|>)
17:20:50 <lyxia> I don't understand your last two messages
17:20:57 <dsal> hlint (which I discovered today) is suggesting I use &&& instead of my lambda.  This kind of seems like a bad idea.  http://lpaste.net/2530466599043858432
17:21:09 <dsal> I don't really understand it, but it looks like, more complicated.
17:21:45 <codeshot> I can see how to improve the last one, but not the penultimate
17:21:52 <ertes> dsal: ignore it
17:22:11 <dsal> Yeah, it seems ignorable.  I'm trying to even understand why it'd be desirable.  Just learning about this thing.
17:22:20 <ertes> dsal: some of hlint's suggestions are hugely subjective
17:22:50 <dsal> A couple of them have taught me things.  This one is threatening to teach me too much.
17:22:50 <lyxia> codeshot: Did you mean that not all Alternatives have Monoid instances that do the same thing
17:23:08 <codeshot> yes
17:24:16 <lyxia> Well, I guess that's true.
17:24:26 <codeshot> and that for parsers, Monoid's "mappend" - representing "append" strongly suggests that the results of parsers should be appended rather than that an alternative parsers should be appended
17:25:14 <lyxia> I just imagine that the name "mappend" came from the generalization of (++)
17:25:59 <ertes> dsal: it's useful to know the alternatives, but once you do i think you can safely just skip hlinting your code…  its default rules are clearly geared toward a very specific style of haskell code
17:26:21 <codeshot> which is only one possible Alternative - it models ordered nondeterminism where (<>) == (<|>) is necessary
17:26:21 <lyxia> codeshot: I don't think it's meant to be a particularly meaningful name otherwise.
17:26:38 <dsal> ertes: My style has been "this looks good to me" so having any input at all is helpful.
17:27:25 <erisco> it wants you to use inc &&& inc ?
17:27:26 <MarcelineVQ> you can prefer <> if there's too much connotation in mappend
17:28:06 <dsal> erisco: Yeah,  I cant' really parse    inc &&& inc
17:28:24 <ertes> dsal: f &&& g = \x -> (f x, g x)
17:28:26 <lyxia> codeshot: https://github.com/haskell/parsec/issues/80
17:28:36 <dsal> ertes: Oh.  That seems silly, yeah.
17:28:38 <ertes> dsal: (for (->))
17:29:02 <lyxia> codeshot: https://github.com/mrkkrp/megaparsec/pull/203/files
17:29:08 <erisco> why not ((,) <*> id) . inc
17:29:27 <mniip> (,) <*> id ?
17:29:29 <mniip> you mean
17:29:31 <mniip> join (,)
17:29:33 <ertes> why not join (&&&) inc?
17:29:41 <dsal> ha.  I tend to throw my lambdas through @pl
17:29:45 <erisco> join was too plain
17:29:58 <dsal> :t join
17:30:00 <lambdabot> Monad m => m (m a) -> m a
17:30:14 <codeshot> lyxia: If only github allowed me to use authentication syndication I would finally make an account and suggest a justification for it being the obvious Monoid instance :D
17:31:45 <codeshot> This is why the monoid instance is so appropriate:
17:31:46 <codeshot> identifier = lexeme p
17:31:46 <codeshot>  where p = Identifier <$> ((one letter) <> many1 (letter <|> digit))
17:32:27 <dsal> What does "eta reduce" mean?
17:32:42 <erisco> get rid of them abstractions!
17:32:43 <mniip> (\x -> f x) into f
17:33:00 <dsal> I assume this has something to do with η which I've heard mentioned in a category theory lecture I didn't understand.
17:33:31 <dsal> I know what it wants from me, I just don't know why it's called "Eta reduce"
17:33:52 <ertes> dsal: for all f and g, if for all x, f x = g x, then f = g
17:34:08 <erisco> mathematicians despise names longer than one character
17:34:26 <dsal> ertes: Yeah, that makes sense.
17:34:53 <MarcelineVQ> using multiple letters leads to trouble; you end up with words like mappend
17:35:23 <erisco> right, I am sure if all of Prelude contains single letter names it would be much clearer
17:35:31 <MarcelineVQ> disclmaimer: multiple letters are a good idea for variable names, people who say otherwise are trying to eat you
17:35:32 <Ero> I DID IT
17:35:48 <ertes> dsal: it's not a universal rule, but in haskell it's fine
17:35:56 <MarcelineVQ> Ero: you are to blame?
17:36:05 <erisco> I think it is more that maths is to be written, programs are to be typed
17:36:18 <ertes> dsal: meaning that it will never be false, but you can't necessarily make this inference in logic
17:37:02 <Ero> I am the culprit. I implemented doubleEveryOther with a single traversal!(?)
17:37:10 <MarcelineVQ> you madman
17:37:26 <MarcelineVQ> good job, what does it look like
17:37:39 <dsal> Lot of good suggestions from hlint.  Mostly I use too many parens for it.
17:38:10 <ertes> oh yeah, hlint haaaaaates parentheses
17:38:14 <Ero> MarcelineVQ: http://lpaste.net/359207
17:38:36 <dsal> Also, it prefers to partially apply infix functions over using flip.  Which feels weird, but it does seem easier to read.
17:39:36 <Ero> I spent all damn day 
17:40:02 <erisco> Ero, why is your code running away from the declaration names? yikes
17:40:06 <Ero> looking at an example of circle programming applied to some other problem and trying to understand it
17:40:17 <Ero> erisco, i have no idea :D
17:40:39 <erisco> which are you using? doubleEveryOther or doubleEverOther' ?
17:41:03 <Ero> well, validate implements the non-prime version
17:41:12 <Ero> validate uses*
17:41:32 <erisco> primes? I clearly don't know what is going on then
17:41:56 <Ero> i thought the ' was refered to as "prime"
17:42:13 <Ero> as a convention for naming an alternate version of somehting which is essentially the same
17:42:14 <erisco> yes, it does, okay
17:42:51 <erisco> is the prime version your revised solution?
17:43:23 <Ero> the non-prime is my revised solution, i believe it only traverses the given list once 
17:44:09 <erisco> so, the crux of it is that you want it to double every other element from the end, not the beginning?
17:44:16 <Ero> to be honest, i only managed to get it working due to following the binding errors that ghc spat at me
17:44:33 <Ero> yes erisco, thats it. every 2nd from the rightmost
17:45:34 <Ero> i wasnt happy with a function that had reverse in it twice. I recalled reading about circular programming a month or so ago 
17:45:44 <erisco> well, I don't see how you're going to avoid effectively looking at the list twice
17:46:16 <ertes> Ero: why don't you just use Data.Sequence instead?
17:46:32 <erisco> but, you can do it with one traversal, it just considers every element twice
17:46:54 <erisco> and that is, you make both possible lists, and then when you reach the end you've determined which one is correct
17:47:14 <Ero> ertes: its a toy program for the CIS194 homework
17:47:18 <MarcelineVQ> ertes: This is the very first set of problems in cis196, in other words the first exposure a person has, it's a pretty impressive solution
17:47:31 <ertes> ah, i see
17:47:49 <Ero> heh, thanks MarcelineVQ 
17:47:54 <erisco> or maybe this works out to just once … have to look closer at the laziness
17:48:01 <Ero> that is a cool idea though erisco
17:48:36 <MarcelineVQ> tbh I can't quite follow what this is doing yet, but it works, so it's going in the scrapbook collection of these I keep
17:55:43 <codeshot> lyxia: Lol, I just saw my original noisy "do"-based code ended up with this: "pure $ h:t" <- fate was telling me to find an alternative but I didn't notice :D
17:59:02 <erisco> I can't recall how the fusion technique worked for sum xs / length xs
18:02:08 <ertes> @let mapEveryOtherEnd f = (\((xs, ys), b) -> if b then xs else ys) . foldr (\x (~(xs, ys), b) -> ((f x : ys, x : xs), not b)) (mempty, False)
18:02:11 <lambdabot>  Defined.
18:02:18 <dsal> Haskell: The Craft of Functional Programming (International Computer Science Series) https://www.amazon.com/dp/B015YA15LI/ref=cm_sw_r_cp_apa_uab4zbDMHV0KQ
18:02:38 <dsal> I can rent that on Kindle for $120. That seems weird.
18:06:30 <erisco> this is my solution using the power of the Church list! http://lpaste.net/359209
18:07:33 <dsal> https://usercontent.irccloud-cdn.com/file/bD07uhDo/book.png
18:07:42 <erisco> to get that snoc goodness
18:10:37 <erisco> you can nab this library here for a more general version http://hackage.haskell.org/package/fmlist-0.9/docs/Data-FMList.html
18:12:26 <erisco> whether this seriously ends up as less work than just computing the length, I don't know, I don't think so
18:16:00 <rotaerk> FMList, FML...
18:19:38 <erisco> you can also use foldl, or I guess foldl', in my doubleEveryOther
18:20:37 <erisco> that eliminates the explicit recursion, so hurrah
18:23:25 <erisco> with some more thinking, I think a foldr solution without Church Lists, or whatever snoc solution, is possible, hm
18:25:26 <erisco> ah indeed, that is easy
18:27:13 <erisco> like this http://lpaste.net/359212
18:30:08 <dsal> :t either
18:30:11 <lambdabot> (a -> c) -> (b -> c) -> Either a b -> c
18:31:20 <erisco> you could also use, say, bimap instead to define f
18:31:35 <erisco> so  f x = bimap (2 * x :) (x :)
18:31:48 <erisco> oh, but that does not swap Left/Right
18:31:54 <erisco> @hoogle Either a b -> Either b a
18:31:56 <lambdabot> Data.Either.Combinators swapEither :: Either e a -> Either a e
18:31:56 <lambdabot> Data.EitherR flipEither :: Either a b -> Either b a
18:31:56 <lambdabot> Puppet.Utils strictifyEither :: Either a b -> Either a b
18:32:13 <erisco> so, need something like that too
18:34:15 <Axman6> :t \f g -> either (Right . f) (Left . g)
18:34:18 <lambdabot> (a1 -> b) -> (a2 -> a3) -> Either a1 a2 -> Either a3 b
18:34:36 <Axman6> :t \f g -> iterate . either (Right . f) (Left . g)
18:34:38 <lambdabot> error:
18:34:38 <lambdabot>     • Couldn't match type ‘Either a2 b’ with ‘a3 -> a3’
18:34:38 <lambdabot>       Expected type: Either a a1 -> a3 -> a3
18:34:48 <erisco> yeah but that is a tad fugly
18:34:55 <Axman6> :t \f g -> iterate ( either (Right . f) (Left . g))
18:34:57 <lambdabot> (a1 -> a2) -> (a2 -> a1) -> Either a1 a2 -> [Either a1 a2]
18:37:25 <erisco> why iterate?
18:38:58 <Axman6> just making the types do what I wanted
18:42:29 <erisco> (const . const . const) []  works as well ;)
18:46:53 <iqubic> :t (const . const . const) []
18:46:55 <lambdabot> b1 -> b2 -> b3 -> [a]
18:47:04 <iqubic> What the heck?
18:47:26 <iqubic> It just gobbles up three parameters and returns []???
18:48:15 <MarcelineVQ> try it
18:49:06 <Cale> iqubic: of course
18:49:24 <Cale> It's the constant function which gives the constant function which gives the constant function which gives [] :)
18:50:01 <iqubic> > ((const . const . const) []) "HELLO" 1 (Left Nothing)
18:50:05 <lambdabot>  []
18:50:17 <iqubic> Well. That's interesting.
19:17:24 <wagle> whats the current way to install ghc on macos these days?  haskell-platform seems dead?
19:17:52 <Axman6> I tend to just let stack do it
19:18:21 <boogalooga> is there a way in haskell(built in) to replace every occurrence of something 
19:18:23 <boogalooga> in a list
19:18:26 <boogalooga> to something else
19:19:10 * wagle tries Axman6's  way
19:19:53 <Axman6> boogalooga: not really, but it is just map (\x -> if p then f x else x)
19:20:55 <boogalooga> yea I know
19:21:10 <boogalooga> the assignment is asking me to do everything in as few lines as possible
19:21:11 <boogalooga> :p
19:21:14 <Axman6> :t filtering
19:21:16 <lambdabot> error: Variable not in scope: filtering
19:21:22 <Axman6> :t filtered
19:21:24 <wagle> (last time I tried to install stuff with stack, I made a big ugly non-functional mess..  but that was years ago, and stack is the bees knees, apparently)
19:21:24 <lambdabot> (Applicative f, Choice p) => (a -> Bool) -> Optic' p f a a
19:21:48 <Axman6> :t traverse . filtered (== 'a') .~ 'A'
19:21:51 <lambdabot> Traversable t => t Char -> t Char
19:22:31 <Axman6> wagle: I wouldn't say that, but it can make life simpler for new projects (I can make life more difficult for projects which don't use it though)
19:26:33 <Axman6> > "Hello wald!" & traverse . filtered (== 'a') .~ 'A'
19:26:36 <lambdabot>  "Hello wAld!"
19:28:21 <iqubic> :t (&)
19:28:25 <lambdabot> a -> (a -> b) -> b
19:28:56 <iqubic> That's like function application with the function second? Why is that a thing?
19:29:15 <Axman6> because it works nice syntactically
19:29:20 <iqubic> x & f = f x
19:29:44 <iqubic> :t let x & f = f x 
19:29:45 <Axman6> "here's foo and do this thing, and do this thing, and do this thing", where often "do this thing" is some lens operation
19:29:46 <lambdabot> <no location info>: error: not an expression: ‘let x & f = f x’
19:30:04 <iqubic> :t let x & f = f x in x & f
19:30:08 <lambdabot> FromExpr t => t
19:30:18 <iqubic> How do I get that to work properly?
19:30:57 <Axman6> :t let x & f = f x in (&)
19:31:00 <lambdabot> t1 -> (t1 -> t2) -> t2
19:31:07 <iqubic> Cool
19:35:02 <Cale> iqubic: I would tend to agree with the sentiment "Why is that a thing?" -- most of the time it's simply less readable.
19:35:40 <geekosaur> well. it arguably makes lens expressions a bit more comprehensible
19:35:42 <Cale> There's *one* case where I don't mind it, and that's where you're basically using lens to mimic record update syntax, and updating multiple fields.
19:35:59 <geekosaur> I would argue that's the only place you would use it
19:36:02 <Axman6> which happens to be the primary usecase for it
19:36:03 <Cale> Even in all the other cases involving lens, I prefer the usual way around.
19:36:49 <iqubic> How often do you guys use TH to make lenses?
19:36:57 <Axman6> most of the time
19:37:00 <Cale> Essentially all of the time
19:37:24 <iqubic> I thought TH was slow.
19:37:26 <Cale> However, lately I've started to think it might be more cost effective to write them by hand
19:38:07 <Cale> Because the small increase to compile time * number of times you build the project can easily add up to the time it would take by hand
19:38:59 <wagle> Axman6: wow, they really hide the existence of "stack setup"
19:39:21 <Axman6> -ddump-splices, ^C ^V
19:39:32 <Cale> There's a better one than -ddump-splices
19:39:34 <Axman6> wagle: eh? pretty sure it tells you right away if you try to use it without running that
19:39:38 <iqubic> So how hard is it to write TH to do things?
19:40:02 <wagle> well, I'm just trying to install ghc
19:40:05 <wagle> hahaha
19:40:22 <wagle> maybe i'm thinking wrong
19:40:42 <Cale> Let me dig it up... I always forget the name
19:40:52 <Cale> I found it by reading ghc's source code
19:41:11 <benzrf> could they implement some sort of caching
19:41:12 <lyxia> Does that mean it's not documented
19:41:30 <Cale> -dth-dec-file
19:41:37 <Cale> it is documented
19:41:42 <wagle> apparwntly i was thinking wrong..  bizarre world i have now
19:41:42 <Gurkenglas_> But if you're not sure now, Moore's law should decide that in a few years time, right? Also doing it manually means more moving parts that might fail
19:41:43 <Cale> It's just not entirely obvious what the difference is
19:41:48 <Cale> unless you're reading the source code
19:42:22 <wagle> Axman6: so no ghc and ghci commands now, just stack ghc and stack ghci, etc?
19:42:32 <Cale> The resulting .th.hs can be included directly back into your source.
19:42:49 <Axman6> wagle: yeah
19:43:09 <Cale> whereas if you use -ddump-splices, the result isn't quite compileable code
19:43:17 <wagle> Axman6: thanks!
19:44:04 <Gurkenglas> Is there a case that's more unambiguously in favor of writing anything by hand?
19:44:08 <lyxia> Cale: that option sure looks useful
19:44:19 <Axman6> Cale: does GHC recodnise .th.hs as a haskell file, whose module name should be the but proceeding the suffix?
19:45:26 <Cale> Axman6: GHC does nothing special to recognise that extension. You can do something like:
19:45:34 <Cale> #ifndef USE_TEMPLATE_HASKELL
19:45:41 <Cale> #include "Foo.th.hs"
19:45:43 <Cale> #endif
19:46:15 <Cale> and just put that at the end of the corresponding .hs file
19:46:23 <Gurkenglas> Why is deriving lenses of all things slow, anyway? 
19:46:31 <Cale> It's not just lenses
19:47:22 <Cale> TH is slow, because you have to compile the file a bunch of times for each location where there's a splice
19:47:46 <Cale> and if you're using ghcjs then it's *really* slow
19:48:08 <Cale> because it fires up a node instance to run the javascript code it compiled from your splices
19:48:22 <Axman6> Cale: huh, interesting. so that file only has the splices? Do you need to wrap the template haskell calls so they don't confuse things?
19:49:14 <Cale> Axman6: Yeah, we just use a CPP flag to control whether the part with the TH code in it gets built, or the .th.hs gets included
19:49:49 <Cale> It's horrid, but it's sort of the only solution to making TH work for mobile cross-compilation right now.
19:50:32 <Axman6> right, makes sense. I assume ins most cases the TH generated is portable
19:50:46 <wagle> ok, whats the answer to the question "if you have stack installed, what's the correct way to install stuff with cabal?"  (everything I've seen so far immediately goes on and on about how to start new projects, etc)
19:50:54 <Cale> Yeah, obviously if your TH code relies on being run on the host, then this approach just doesn't work.
19:51:07 <Cale> er, on the target rather ;)
19:51:26 <Axman6> wagle: stack i very much project based. you can run `stack install foo` and then you can use foo in stack repl outside a project though
19:51:27 <Gurkenglas> So if you have 10 makeLenses statements, that's 10 splices, meaning it compiles the file that contains 10 splices once for each of the 10 splices?
19:51:28 <mud> wagle: Install what, libraries into stack's ideas of snapshots?
19:51:46 <mud> I'd imagine the answer is "don't", if so.
19:51:59 <Cale> Gurkenglas: It compiles the part above the first splice, along with the first splice, and evaluates that, puts the splice in, and then continues again
19:52:37 <Gurkenglas> the humanity
19:52:43 <wagle> I'm trying to successfully execute the command "cabal install gitit -fplugins"
19:52:59 <Axman6> Cale: ah, that explains why TH introduces ordering restrictions in files
19:53:05 <Cale> Axman6: yeah
19:53:19 <geekosaur> wagle, what mud said. stack specifically exists to manage those things itself; it will break down if you modify them yourself. (this is also why they disrecommend the flag to use a system ghc; it limits how much they can prevent 'stack hell')
19:53:21 <wagle> before that, its yaks all the way up
19:53:31 <Cale> The worst is when you can't just move all the TH to the top or bottom, but it *needs* to be at some special place in the middle
19:54:00 <geekosaur> but you should be able to do the stack equivalent of that install command
19:54:50 <geekosaur> stack install gitit --flag gitit:plugins
19:55:14 <geekosaur> (you need to specify the package again so it knows not to send the flag to any dependencies, which might do something different with it)
19:55:49 <wagle> cool
19:55:50 <Gurkenglas> Shouldn't it be able to fuse adjacent makeLenses declarations into one splice because it's all independent boilerplating of data declarations? Like a rewrite rule
19:56:04 <wagle> now I'm try to decude that from the copious docs
19:56:22 <wagle> now I'm try to *deduce* that from the copious docs
19:56:31 <geekosaur> https://docs.haskellstack.org/en/stable/GUIDE/#flags-and-ghc-options
19:56:58 <wagle> checking proof much easier..  8)
19:57:26 <geekosaur> generally yes. proofs follow rules. people and the toys they make mostly don't do so very well. >.>
20:00:21 <Cale> Gurkenglas: Actually, yes. It's generally a good strategy to accumulate a bunch of declaration splices and insert them in a single top-level splice operation.
20:01:00 <Gurkenglas> So instead of "makeLenses ''A; makeLenses ''B" you should write "(++) <$> makeLenses ''A <*> makeLenses ''B"
20:01:06 <Cale> But even if you do that, I think it's still slower than if you're using static source by a decent margin.
20:01:27 * geekosaur kinda wishes zeroth hadn't bitrotted
20:02:34 * Axman6 wishes makeLenses just took a list of names, or had list versions
20:02:57 <geekosaur> makeLenseses ...
20:03:26 <aarvar> pasteLensesIntoSource
20:03:35 <geekosaur> but owuldn't that splice be something like $(makeLenses ''A; makeLenses ''B; ...)
20:03:41 <Gurkenglas> What was the correct thing to do when you see "fmap concat . sequence"?
20:05:03 <geekosaur> that might even work as a map of some kind, if those all have the same type (Q Dec?)
20:05:13 <Gurkenglas> Ah, ala alt foldMap.
20:05:30 <Gurkenglas> alaf alt foldMap makeLenses [''A, ''B]
20:05:31 <Cale> I dunno, we have some fmap concat $ mapM ... [ ... ]
20:05:48 <Cale> fmap concat is easily more readable :P
20:06:11 <Gurkenglas> *Alt
20:06:25 <wagle> hm.  how long should I expect "stack solver" to run?  LOL
20:07:09 <MarcelineVQ> not long if your hackage index is up to date
20:07:56 <wagle> hrm.  hackage index?  now you see why I'm LOL'ing
20:08:19 <wagle> (fresh computer, kinda sorta)
20:08:50 <wagle> then upgraded to high sierra, and trying to fix whats b0rkt
20:09:22 <MarcelineVQ> it can take a bit if it hasn't been done recently because it needs to download an index make sure the packages it's solving with are up to date
20:09:29 <MarcelineVQ> *index to
20:09:36 <wagle> ah
20:09:59 <wagle> plus its one of the 8 cpus
20:10:06 <wagle> plus its using one of the 8 cpus
20:10:15 <geekosaur> there may also be some cdn problems slowing things down, potentially. just had a report in #hackage of a package whose docs don't load right in the browser, which turns out to be a cdn host saying 'sorry, I was decommissioned; no files here'
20:10:37 <wagle> oooo
20:10:48 * wagle is having a good timee
20:11:46 <geekosaur> (note that which cdn is also a question; stack's metadata is on amazon s3, hackage's is on cloudflare. it is not clear whether the warning message in my browser's error log is from cloudflare, or from locally generated and uploaded docs using their own choice of cdn that is now gone)
20:11:59 <Gurkenglas> Can we use the Functor-deriving machinery for lens?
20:13:43 * hackagebot path-text-utf8 0.0.0.2 – Read and write UTF-8 text files – https://hackage.haskell.org/package/path-text-utf8
20:21:54 <mud> So ... persistent arrays. Can anyone link me reading material? I'm trying to implement a persistent union-find data structure, and I need one with somewhat weird requirements. So far the best persistent array I can think of is just Data.Map (or Data.IntMap), which is ... not amazing.
20:22:23 <saurabhnanda> Does hitting ctrl+c not terminate all async threads?
20:22:40 <mud> https://www.lri.fr/~filliatr/ftp/publis/puf-wml07.ps I'm reading this, but their persistent arrays are not going to work for me, I need more than just backtracking, I need multiple futures.
20:22:47 <iqubic> So, thwew was some talk about randomness yesterday.
20:22:58 <iqubic> *there
20:23:14 <iqubic> Lokathor: I think you might like this video: https://www.youtube.com/watch?v=C82JyCmtKWg
20:25:27 <iqubic> It talks about how computers create random numbers
20:30:03 <iqubic> What method does haskell use to get a set of random numbers?
20:30:35 <c_wraith> There are a bunch of random libraries that work differently
20:32:27 <iqubic> How does prelude work?
20:32:52 <c_wraith> there are no random number generators in base
20:33:17 <iqubic> What about stdGen?
20:33:21 <olligobber> iqubic, prelude is some haskell code that defines a lot of useful stuff
20:33:23 <c_wraith> not  part of base
20:33:32 <olligobber> prelude /= base
20:33:34 <geekosaur> iqubic, thats from a package called random
20:33:40 <olligobber> I think
20:33:43 <iqubic> geekosaur: I see.
20:34:03 <mniip> well prelude is slightly more than a haskell code
20:34:05 <geekosaur> it's a ghc bootlib (i.e. one needed for ghc itself), so it comes with every installation; but it is not part of base
20:34:12 <mniip> some of its things are hardwired into the compiler
20:34:37 <olligobber> til
20:34:51 <iqubic> So how does the package random generate random numbers?
20:35:01 <mniip> you can find out
20:35:07 <olligobber> iqubic, look at its code!
20:36:00 <mud> It must be doing something fairly interesting, because the ability to split a seed is pretty novel, AFAIK.
20:36:16 <iqubic> The Middle-Square algorithm is the simples thing I believe
20:36:24 <geekosaur> you can look at the source. but it's basically a simple linear congruential random generator, which can be fed from a seed you supply (mkStdGen) or from an IORef maintained by the routines that use it
20:36:40 <geekosaur> (I think it's still lcong...)
20:36:58 <iqubic> geekosaur: How does it pick an M, A, C, and Seed to use?
20:37:12 <geekosaur> 'split' is the main thing it has different from other RNGs, yes, and at the tie it wasn't well characterized or even known if it was truly safe
20:37:40 <geekosaur> here I'm just going to tell you to look at the code yourself
20:37:49 <geekosaur> I don;t see much point in reading it to./for you
20:38:13 <iqubic> I'll do that when it's not 3 AM. I'm super tired now.
20:49:00 <Axman6> geekosaur: iqubic has chronic googlephobia, which makes him unable to find answers to questions on his own. He has been working on this problem for several months, and has improved a lot, but sometimes needs someone else to do the trivial tasks we would all do without thinking
20:49:54 <iqubic> Axman6: I'll do it on my own this time.
20:52:29 * Axman6 claps
21:00:07 <Welkin> is the world ending?
21:00:13 <Welkin> iqubic: what have you done?
21:00:22 <Welkin> Axman6 has never been sarcastic before
21:01:12 <Axman6> I'm totally never sarcastic
21:05:17 <Hail_Spacecake> hello
21:05:38 <Hail_Spacecake> I'm reading Bartosz Milewski's blog posts about category theory for programmers
21:06:04 <Hail_Spacecake> and he makes a point of stating that it is not hte case that haskell types are sets
21:06:11 <Hail_Spacecake> becuase of something pertainingto Bottom
21:06:13 <Hail_Spacecake> that I don't quite understand
21:07:04 <Hail_Spacecake> why can't you just say that Haskell types are sets, all of which happen to contain Bottom?
21:07:13 <Hail_Spacecake> why do you need to make a Hask category to describe that?
21:07:28 <wagle> .. for the viewers at home, the stack solver command is still running
21:08:09 <wagle> i guess i will kill it in the morning
21:12:21 <Axman6> that definitely shouldn't be happening
21:13:57 <c_wraith> Hail_Spacecake: I don't really understand it myself, but there are other examples of things that aren't sets in Haskell types.  hyperfunctions are described as not being sets, for instance
21:14:43 <c_wraith> I guess a hyperfunction is an infinite exponential - I can see why that would be too big to be a set
21:15:28 <c_wraith> newtype Hyper a b = Hyper (Hyper b a -> b)
21:15:37 <mniip> no, they definitely are sets,
21:15:46 <mniip> it's just that Hask isn't a category of all sets
21:15:56 <mniip> and its morphisms aren't all functions
21:16:14 <mniip> I guess the latter is why bartosz emphasized that they're not sets
21:16:17 <mniip> Hail_Spacecake, ^
21:16:59 <mniip> only monotonic (wrt bottom) functions can be defined in haskell
21:17:28 <Hail_Spacecake> oh so hask is specifically the category of sets that have Bottom in them, then?
21:17:33 <mniip> no
21:17:40 <mniip> that would be the category of pointed sets
21:17:48 <mniip> unlike Set, Hom_Hask(X, Y) is always countable
21:18:00 <Hail_Spacecake> what's Hom_Hask?
21:18:09 <mniip> the hom-set...
21:18:20 <mniip> the set of all morphisms from X to Y
21:18:46 <Hail_Spacecake> so, the set of all morphisms from X to Y in the category Set
21:18:48 <Hail_Spacecake> is uncountable
21:18:59 <Hail_Spacecake> becuase there are sets of cardinality alpeh-0
21:19:08 <mniip> 1507868308 [07:18:28] <Hail_Spacecake> so, the set of all morphisms from X to Y in the category Set
21:19:11 <mniip> for particular X and Y
21:19:31 <mniip> Hom(N, N) is uncountable, yes
21:19:36 <Hail_Spacecake> in this case X and Y are particular sets, right?
21:19:55 <Hail_Spacecake> so we could say X is a set of cardinality aleph-0 and so is Y, and hten there are uncountably many morphisms between them
21:20:01 <Hail_Spacecake> but that's not true of Haskell types, I suppose
21:20:04 <mniip> yes
21:20:09 <Hail_Spacecake> so that's enough to say that Hask is a different thing than Set
21:20:24 <mniip> and different from Set* too
21:20:35 <Hail_Spacecake> oh, right, the morphisms in Hask are haskell functions, not arbitrary mathematical functions like they are for Set
21:21:14 <Hail_Spacecake> but, hm, if you had, say, Integer -> Integer
21:21:22 <mniip> also there are different levels of "abstraction" of Hask
21:21:32 <Hail_Spacecake> aren't there aleph-1 ways to write a haskell function that maps them?
21:21:34 <mniip> some more honest, some more easy to reason about
21:21:41 <mniip> Hail_Spacecake, actually no
21:21:44 <Hail_Spacecake> or is that not true becasue a haskell function needs to be finitely sized b/c it needs to be executable?
21:21:50 <mniip> yes
21:22:15 <Hail_Spacecake> okay
21:22:24 <Hail_Spacecake> what is Set*, btw?
21:22:35 <mniip> the category of pointed sets
21:22:46 <Hail_Spacecake> what is a pointed set?
21:22:56 <mniip> the category of all sets that contain a certain element usually called *
21:23:05 <mniip> with morphisms - functions such that f(*) = *
21:23:43 <mniip> probably the simplest category with an example of zero morphisms
21:25:20 <Hail_Spacecake> how can a category have zero morphisms?
21:25:29 <Hail_Spacecake> there needs to at least be the self-morphism right?
21:25:36 <Hail_Spacecake> unless you had a category with no members and no morphisms
21:25:37 <Lokathor> mud, there are other generators that can be split besides StdGen
21:25:37 <mniip> "zero morphism" is a term
21:25:55 <Lokathor> doing it in a way that doesn't cause accidental loops back to a previous generator state is perhaps tricky
21:26:01 <Hail_Spacecake> oh "zero-morphism" okay
21:26:06 <Lokathor> (but probably not tricky)
21:26:26 <Welkin> only treaty?
21:26:41 <mud> Ya, I mean you can kind of trivially do it with any of them, but proving it makes sense and has certain properties sounds hard.
21:27:06 <Lokathor> the PCG family of generators has builtin multi-stream support
21:28:13 <Hail_Spacecake> also is the function unit ::  a -> () supposed to exist in the std prelude?
21:28:27 <Hail_Spacecake> bartosz talks about it like it's   a thing in haskell already
21:29:15 <rotaerk> unit = const () ?
21:29:18 <mud> `const ()` I guess, but I don't think it has a name in Prelude
21:29:19 <Welkin> the prelude is nothing special
21:29:41 <mniip> Hail_Spacecake, no
21:29:51 <Welkin> it is just a there to make it easy for someone to import basic functions
21:30:17 <mud> It's not exactly a very useful function practically, as far as I know. The closest that I can think of ever using would be 'void'
21:30:22 <mud> :t void
21:30:24 <lambdabot> Functor f => f a -> f ()
21:30:30 <Lokathor> void is very useful
21:30:36 <Welkin> lol
21:30:43 <Welkin> I've only used void in purescript so far
21:30:54 <mniip> I might have used void once
21:30:56 <mniip> in IO
21:31:00 <mud> Yes, it is. But AFAIK unit isn't.
21:31:27 <Welkin> mniip: yes, that is the only use case I can think of
21:31:56 <Welkin> but it is often easier to just use pattern matching `_ <- ...`
21:32:12 <Welkin> although sometimes you end up needing to ad an extra `pure ()` at the end...
21:32:17 <Welkin> thus, `void`
21:33:29 <Lokathor> yeah you gotta fit into those control structure things sometimes
22:24:22 <zqvt8> has anybody here read the "haskell data analyis cookbook?"
22:28:52 <Axman6> I've got it and read bits of it. it's a nice little cookbook, but leaves a lot out too IIRC
22:37:32 <osa1> anyone know why my putStrLns don't appear in the stdout when I'm using LoggingT with fast-logger as backend?
22:37:49 <osa1> if I replace putStrLn with logDebug it works
22:37:57 <johnw_> are you flushing?
22:38:00 <osa1> no
22:38:02 <johnw_> fast-logger doesn't write out synchronously
22:38:12 <johnw_> it buffers internally
22:38:12 <Lokathor> the logger might be taking over stdout and ... yes they explained it
22:38:20 <osa1> do you mean fast-logger changes buffering settings for stdout?
22:38:29 <johnw_> it maintains its own message queue, I believe
22:38:39 <johnw_> hence the "fast" part
22:42:46 <DigitalKiwi> it's like using 1 day shipping and then the postal person puts a note on your door that you have to come to the post office tomorrow to get it
22:42:58 <osa1> it should be somehow manipulating the stdout fd but I can't see that code
22:58:13 <dminuoso_> Is there some conventional name for functions one passes to foldl/foldr ?
22:59:04 <Axman6> not that I'm aware of
23:00:38 <peddie> accumulator possibly?
23:01:54 <dminuoso_> peddie: It doesn't quite fit, because that function does not "accumulate", it just folds two values into one.
23:02:52 <cocreature> reducer?
23:03:13 <Lokathor> haskell's polymorphism is "parametric" right?
23:03:14 <dminuoso_> cocreature: Oh! That's what we have been calling these in redux for a while.
23:03:37 <cocreature> I guess reducer is a bit more generic but it seems to fit here
23:03:41 <cocreature> Lokathor: yes
23:04:23 <cocreature> Lokathor: because you can’t do “type-casing”, i.e., implement a different behavior for certain types (without changing the signature)
23:07:18 <ongy> argh, I hate library bindings that don't expose internals :/
23:07:36 <dminuoso_> cocreature: Is there some convention to name specific instanes of such function? For a while I've been calling them "intoXYZ", such as "intoParity" - unsure whether that was a wise thing.
23:08:51 <dminuoso_> "parityReducer" would be.. weird.
23:09:20 <cocreature> I’d probably just call it "parity"
23:10:40 <wagle> Axman6: finally terminated with reams of error messages, appearing to indicate that is searched my ENTIRE disk for *.cabal files and getting nowhere
23:11:01 <wagle> just so you know..  LOL
23:11:31 <Axman6> yeah that's not supposed to happen
23:12:57 <peddie> dminuoso_: I don't know if it's perfect, just something I've heard people call it
23:13:33 <cocreature> I call the value that is passed along the reducer the accumulator not the reducer itself
23:15:04 <DigitalKiwi> so other than some obvious cases (though some have caveats) of places it absolutely would not make sense or be feasible, are there some particular classes of problems haskell would not be a good choice for?
23:15:11 <dminuoso_> peddie: Im just beginning to learn folding as structural transformation
23:15:44 <peddie> cocreature: I like that nomenclature better
23:15:48 <peddie> "reducer" is a good one
23:17:25 <cocreature> thinking about it, I think I use “reducer” mostly for strict left folds and not for right-folds that just produce a new structure
23:17:38 <cocreature> e.g. if you implement map using foldr, I wouldn’t call the function passed to foldr a reducer
23:19:01 <erisco> foldr takes a cons case and a nil case
23:24:47 <wagle> wow, i'm underwhelmed..  but, unfortunatly cabal is b0rkt
23:25:36 <wagle> stack seems mostly for new projects, not installing existing packages
23:28:07 <Axman6> I'm not sure what problem you're running into, I do this all the time
23:28:35 <cocreature> wagle: you’ll have to give us a bit more details, what problem are you seeing?
23:28:38 <wagle> yeah, i must be thinking wrong, somehow..  wish i knew how
23:30:01 <wagle> trying to do "stack install gitit"..  it directs me to modify the global config to adds 4 extra-deps
23:30:26 <wagle> in the middle of doing that, but I have the feeling i'm making a mess
23:31:02 <cocreature> you can also just add them locally, e.g., "stack install gitit dep1 dep2 dep3 dep4"
23:31:48 <Axman6> stack is not amazing when you're working with things which aren't on stackage
23:32:31 <cocreature> it’s not great but it’s also not that much trouble ime
23:33:27 <wagle> i installed them one at a time, but the gitit install is still complaining about a hoauth2 dep
23:35:17 <wagle> $ stack install hoauth2-0.5.9
23:35:17 <wagle> hoauth2-1.3.0: configure
23:35:17 <wagle> hoauth2-1.3.0: build
23:35:17 <wagle> hoauth2-1.3.0: copy/register
23:35:20 <Axman6> do them all at once you you can get consistent versions
23:35:38 <wagle> i dont gitit..  
23:36:10 <wagle> 1.3.0 is too old
23:36:53 <Axman6> did you try "stack install gitit hoauth2 <other deps stack complains about>?
23:37:14 <Lokathor> https://hackage.haskell.org/package/random-1.1/docs/src/System-Random.html#randomIvalInteger why does this function use a case with a single pattern?
23:38:00 <wagle> i think i just got somewhere
23:38:46 <Axman6> Lokathor: why not?
23:39:22 <Axman6> it could also be a let, but I think this might be more likely to ensure the tuple doesn't get allocated, because the result can be inlined into the call of f
23:39:39 <Lokathor> well, what does it accomplish compared to, you know, doing like: let (v, rng') = (f 1 0 rng) in fromInteger (l + v `mod` k), rng'
23:39:53 <Lokathor> ah, hmm
23:40:00 <wagle> (put the wrong version of hoauth2 in ~/.stack/global-project/stack.yaml..  fixed that, and now maybe its gonna work)
23:41:05 <Lokathor> Axman6, it seems to be making a probabilistic result?
23:41:31 <Lokathor> where the output isn't necessarily uniform based on the genRange and (l,h) they just hope it is
23:41:41 <Axman6> wagle: hmm, I'm not convinced that's the right thing to do...
23:41:54 <wagle> Axman6: hahaha  nor I
23:42:18 <Axman6> I've never had to add any packages to the global config
23:42:36 <Lokathor> i do it with stack
23:42:47 <Lokathor> because it's secretly not actually a global config anyway
23:42:53 <wagle> yeah, but its what it suggested..  will try it all in one line
23:44:28 <Lokathor> that's what i had to do to get sdl2-ttf and sdl2 both installed at the same time
23:45:35 <mbrock> if you have some time to spare maybe you could try updating gitit to work with hoauth2 1.3.0
23:47:08 <wagle> egads..  i'm actually trying to move forward to gitit2 or some hybrid thereof
23:48:06 <wagle> hmm..  hoauth2 must be an oauth, which I know little about
23:48:16 <mbrock> oh! ok, wasn't aware of gitit2 :)
23:48:38 <wagle> gitit2 is cleaner design, but hardly any features
23:49:03 <wagle> so I gotta figure out gitit, and port stuff to gitit2..  or something
23:49:47 <wagle> why hoauth2.1.3.0?
23:51:39 <mbrock> just figured it would be a useful maintenance thing, but if gitit is being deprecated then it might not feel worthwhile
23:52:12 <mbrock> it also looked from the hoauth2 commit log like the 1.0 bump wasn't a big rewrite or anything so you might not even need to change anything
23:52:35 <wagle> he doesnt have time to work on it anymore, but has a few of us poking at it with 10-foot poles
23:53:38 <wagle> i have too much to do, so I doubt I'll worry about authorization for a while
23:54:03 <wagle> I'm just using gitit as a private wiki..
23:54:45 <wagle> but you could hack the yaml to accept earlier versions of hoauth2 to see what happens
23:54:50 <saurabhn_> why does the following snippet block indefinitely on a takeMVar, but works fine with a readMVar - https://gist.github.com/saurabhnanda/3bd3172ecf19157142e45282fbf23a8b
23:56:45 <wagle> no idea yet, but https://hackage.haskell.org/package/base-4.10.0.0/docs/Control-Concurrent-MVar.html has a bunch of words that include "block"
23:58:43 <wagle> mhmm..  latest results indicate that ghc is not upward compatible..  'magine that!
23:59:03 <wagle> (ie, my plugins won't compile any more)
