00:13:30 <saurabhn_> what's the easiest way to generate a non-type-safe / throwaway nested Aeson.Value?
00:31:48 <vaibhavsagar> use the constructors?
00:32:13 <vaibhavsagar> can you give me an example of what you're trying to do?
00:40:49 * hackagebot strict-types 0.1.1 – A type level predicate ranging over strict types – https://hackage.haskell.org/package/strict-types
01:01:47 <saurabhn_> vaibhavsagar: let it be... got it. I just had to use the `object` function. It got me what I wanted.
01:03:28 <vaibhavsagar> cool, glad it worked out
01:53:36 <ertes-w> hllo
01:53:51 <vaibhavsagar> hi!
01:55:15 <ventonegro> hmmm... Intero is broken
01:55:36 <ventonegro> "Configuring intero-0.1.23... Warning: This package indirectly depends on multiple versions of the same package. This is highly likely to cause a compile failure."
01:55:49 <ventonegro> And indeed it doesn't compile.
02:04:45 * hackagebot prometheus-effect 1.0.0 – Instrument applications with metrics and publish/push to Prometheus – https://hackage.haskell.org/package/prometheus-effect
02:07:01 <saurabhn_> ventonegro: give me some more details.
02:07:06 <saurabhn_> ventonegro: i might be able to help.
02:07:15 <saurabhn_> ventonegro: day 0 question. are you using stack?
02:07:34 <ventonegro> saurabhn_: yep
02:08:12 <saurabhn_> OT -- anyone here familiar with webpack and the craziness of the JS build system. Need a quick tutorial on how exactly to find out the filename of the compiled JS files, with SHA1 checksums, et. al.
02:08:22 <ventonegro> saurabhn_: resolver lts-9.0
02:08:41 <saurabhn_> ventonegro: `which intero` ?
02:09:04 <saurabhn_> `intero --version`
02:09:07 <ventonegro> Ah ha, the stack.yaml file has extra deps on binary-0.8.5.1, which conflict with intero
02:09:23 <ventonegro> saurabhn_: Found the issue, thanks for the help :)
02:09:52 <saurabhn_> ventonegro: heh, i was just the rubber duck for you.
02:10:12 <ventonegro> saurabhn_: which is also help :)
02:12:02 <phadej> -wg #ghc 
02:13:24 <merijn> Is there a convenient name for "const $ return ()"? I keept writing it out all over the place
02:20:07 <maerwald> keep it written that way, it reads very intuitive
02:21:22 <vaibhavsagar> merijn: Control.Monad.void?
02:21:29 <vaibhavsagar> :t Control.Monad.void
02:21:31 <lambdabot> Functor f => f a -> f ()
02:21:44 <merijn> vaibhavsagar: That's not quite the same
02:21:48 <saurabhn_> vaibhavsagar: what will you call `void` on?
02:21:50 <merijn> :t const (return ())
02:21:51 <lambdabot> Monad m => b -> m ()
02:22:45 <vaibhavsagar> I see
02:23:23 <ertes-w> is there a weaker version of Contravariant?  something like this:  class Component f where component :: ASetter' a b -> f a -> f b
02:24:21 <ertes-w> use case (reduced to the gist):  newtype Meter a = Meter { modifyMeter :: (a -> a) -> STM () }
02:24:42 <ertes-w> this is neither Functor nor Contravariant
02:25:09 <merijn> hmm, am I missing something in Map's API? I wanna do a conditional insert...
02:25:43 <merijn> oh, I think I just want insertLookupWithKey
02:26:23 <ertes-w> merijn: see also 'alter' and 'alterF'
02:26:47 <merijn> ertes-w: alter doesn't return the resulting value for the key
02:26:59 <merijn> ertes-w: So I end up doing alter followed by lookup
02:27:07 <ertes-w> merijn: alterF can do that
02:28:17 <merijn> ertes-w: alterF with tuple as functor you mean?
02:28:44 <ertes-w> merijn: yeah
02:29:18 <ertes-w> merijn: or f = DatabaseTransaction, write the result to the database, then read it back out =P
02:30:19 <ertes-w> alterF is pretty much (k -> Traversal' (Map k a) (Maybe a)), so you can do anything you want
02:31:01 <ertes-w> actually not quite:  s/Traversal/Lens/
02:34:02 <ertes-w> is there anything useful that is weaker than functor for cases like 'Meter' from above?
02:42:36 <alienaut> Is there version manager for haskell compiler like rbenv or nvm?
02:42:51 <saurabhn_> alienaut: stack
02:42:53 <merijn> alienaut: What would you want it to do?
02:43:08 <merijn> Don't need stack for multiple GHC versions
02:44:13 <alienaut> Just wonder
02:44:17 <saurabhn_> alienaut: I'll just reiterate 'stack' and get out of the discussion. Using stack will keep you away from making choices that you nothing of, right now. Once you know enough, you can switch to any other tool that matches your exact use-case.
02:44:18 <merijn> alienaut: Most of those tools are just working around the fact that their compiler package manager designs are broken. GHC uses a version specific package database, so if you have multiple different GHC versions installed it "Just Works". I just install different versions into different directories and switch by adjusting my path
02:44:27 <merijn> alienaut: cabal-install just uses the first GHC on your path
02:45:10 <merijn> alienaut: So if I wanna switcht to 7.10 I just do "PATH=~/ghc710/bin:$PATH" and it "just works"
02:45:54 <ventonegro> alienaut: Just use `stack`
02:52:12 <ertes-w> alienaut: you mean for the compiler itself?
02:53:07 <ertes-w> alienaut: if yes, there are basically two well known solutions right now:  nix and stack
02:57:01 <ertes-w> alienaut: nix is a more general tool and is designed to manage versions of everything, including foreign libraries or utilities, so it has a steeper learning curve, and it's practically linux-only right now…  stack is haskell-specific and very easy to learn, so you can get results quickly, but it's less flexible by design and opinionated about development/deployment patterns
02:57:31 <ertes-w> so choose your poison =)
02:57:40 <merijn> And then there's just cabal-install and cabal-install2.0 :p
02:59:16 <ertes-w> merijn: well, cabal doesn't really *manage* compilers…  by that logic the OS is the actual compiler version manager, because PATH is an OS thing =)
02:59:34 <merijn> ertes-w: It doesn't really have to, though
02:59:50 <merijn> hmmm
03:00:44 <merijn> It seems suspicious that parallelising something 10 times reduces the runtime by more than 10 times...
03:00:54 <ertes-w> merijn: depends…  say you have a backend/frontend combination…  to build the whole project you need more than just cabal-install…  the poor man's nix solution would be to write a Makefile that sets paths properly, assuming you have GHC and GHCJS already preinstalled at well-known locations
03:01:14 <merijn> ertes-w: new-build can  handle that I'm pretty sure
03:01:59 <ertes-w> i believe even new-build doesn't manage compilers, but i might be wrong there
03:03:47 <ertes-w> by "manage" i mean: it gets the right compiler and the right version and uses it transparently…  you just tell it which compiler you want to use, and you can say stuff like: "use the latest GHCJS you know about at major version 7.10"
03:04:24 <ertes-w> or stuff like: "see if you can build this with these compilers"
03:18:16 <maerwald> it can handle haskell build-tools, but not external dependencies
03:22:43 * hackagebot ngx-export 0.8.0.7 – Helper module for Nginx haskell module – https://hackage.haskell.org/package/ngx-export
03:25:48 <AWizzArd> What is the runtime complexity for   mconcat [Just "1", Just "2", Just "3"]    ? Is this efficient and not concatenating the Strings under the hood via ++?
03:26:32 <ertes-w> AWizzArd: instance (Monoid a) => Monoid (Maybe a)
03:26:37 <ertes-w> AWizzArd: does that answer your question?
03:30:15 <maerwald> mconcat xss = [x | xs <- xss, x <- xs]
03:30:43 <maerwald> there's also a note that it might translate more efficient than the foldr method
03:31:48 <mniip> :t ($ mempty) . appEndo . mconcat . map (Endo . (<>))
03:31:49 <ertes-w> that's not quite mconcat for [Maybe String]
03:31:49 <lambdabot> Monoid c => [c] -> c
03:31:55 <mniip> or even
03:32:08 <mniip> :t fmap (($ mempty) . appEndo) . mconcat . map (fmap (Endo . (<>)))
03:32:09 <lambdabot> (Monoid (f (Endo b)), Monoid b, Functor f) => [f b] -> f b
03:32:58 <mniip> Endo is equivalent to the hughes list
03:33:35 <ertes-w> :t \xsss -> [ (x :: Char) | xss <- xsss, xs <- maybe [] pure xss, x <- xs ]
03:33:37 <lambdabot> [Maybe [Char]] -> [Char]
03:33:38 <AWizzArd> maerwald: that looks as if it works nicely for a list of strings, but not for a list of Maybe Strings.
03:34:02 <ertes-w> err, even that is wrong
03:35:02 * hackagebot fingertree 0.1.2.1 – Generic finger-tree structure, with example instances – https://hackage.haskell.org/package/fingertree
03:35:33 <ertes-w> newtype EndoCat a b = EndoCat { endoCat :: Endo a -> Endo b }
03:35:44 <ertes-w> what i was looking for earlier is a functor from EndoCat to (->)
03:36:18 <ertes-w> so it's still a functor, just not a Functor
03:38:28 <mniip> you mean natural transformation
03:38:47 <mniip> or a functor between these categories?
03:39:05 <mniip> or is that even the same notion
03:41:13 <mniip> hmm
03:41:26 <noobie_> how does "head :: [Char] -> Char" not evaluate to a value with type Char when applied to "head [] :: Char"?
03:41:45 <mniip> how do you define composition
03:42:03 <mniip> \(EndoCat f) (EndoCat g) -> EndoCat (f . g) ?
03:42:34 <mniip> I'm convinced there might be a monoidal composition somewhere there
03:42:38 <noobie_> Is there someone I should address specifically with my question?
03:42:59 <mniip> noobie_, I'm fairly convinced it does
03:43:01 <mniip> :t head [] :: Char
03:43:03 <lambdabot> Char
03:43:15 <noobie_> head [] :: Char
03:43:26 <brynedwards> > head [] :: Char
03:43:29 <lambdabot>  *Exception: Prelude.head: empty list
03:43:45 <noobie_> thanks
03:44:39 <noobie_> How does this "*Exception" fit into the type system? I am assuming it doesn't.
03:44:47 <mniip> sure does
03:45:03 <noobie_> Does the exception have type Char?
03:45:14 <mniip> every lifted type has an extra inhabitant called bottom
03:45:22 <mniip> bottom is what you get for nontermination or exception
03:45:25 <mniip> for example, 
03:45:29 <mniip> 'fix id' is a bottom
03:45:46 <mniip> it is also a proof that every type is inhabited by a bottom
03:45:48 <mniip> :t fix id
03:45:50 <lambdabot> a
03:45:58 <mniip> see, eny type a has an inhabitant, namely 'fix id'
03:46:09 <mniip> any*
03:46:35 <Ferdirand> > ['a', 'b', 'c', error "boom"]
03:46:38 <lambdabot>  "abc*Exception: boom
03:47:07 <mniip> exceptions are also bottoms
03:47:34 <noobie_> Ooh is this what they refer to in "Gentle Introduction" as "bot"?
03:47:41 <mniip> probably
03:47:46 <mniip> also commonly denoted _|_
03:47:48 <noobie_> Wow thanks so much!
03:48:31 <mniip> yeah, there's also this thing that bottoms are generally indistinguishable from pure code
03:49:06 <mniip> you can't tell exceptions apart or tell an exception from a nontermination
03:49:26 <mniip> all haskell functions are "monotonic" in the bottom partial order
03:49:42 <mniip> if you defined a partial order 
03:50:33 <mniip> if you defined a partial order '<' denoting "is more defined"
03:51:01 <mniip> what I mean by that is,  _|_ < (_|_, _|_) < (_|_, 3) < ('x', 3)
03:51:17 <mniip> but (_|_, 3) is e.g incomparable with ('x', _|_)
03:51:32 <mniip> then all haskell functions would satisfy x < y => f x < f y
03:51:50 <mniip> that implies that no haskell function can distinguish a bottom from a non-bottom
03:51:59 <mniip> i.e there's no pure "catch"
03:52:59 * hackagebot servant-rawm 0.2.0.0 – Embed a raw 'Application' in a Servant API – https://hackage.haskell.org/package/servant-rawm
03:53:07 <mniip> so yeah, bottoms despite being odd have a well-designed non-paradoxical place in the typesystem
03:53:30 <noobie_> That's great, magic drives me crazy.
03:55:20 <merijn> Note that this has some surprising properties
03:55:32 <merijn> (which is why they're called "imprecise" exceptions)
03:55:42 <mniip> oh yeah
03:55:46 <mniip> Hask is not cartesian closed
03:56:08 <noobie_> when you say there is no pure "catch", you mean no pure "catch" of bottoms, right? As opposed to the Control.Monad.Error which can be caught in a pure function.
03:56:16 <mniip> yes
03:56:43 <merijn> noobie_: He's referring specifically to Control.Exception.catch, yes
03:57:01 <mniip> let's see if I can recall a proof...
03:57:22 <merijn> noobie_: Anyway, note that when pure code can evaluate to a *set* of possible exceptions (for example, due to a branch), it may evaluate to ANY of them
03:57:57 <gonekiwi> mniip you misspelled #lua when you joined channel
03:58:26 <merijn> So if we have 'case True of True -> error "foo!"; False -> error "bar!"' we may actually end up seeing 'error "bar!"'
03:59:01 <mniip> merijn, doesn't evaluational semantics of haskell include bottom processing
03:59:04 <merijn> noobie_: Since, from a compiler perspective those two errors are identical (bottom)
03:59:28 <merijn> mniip: The proper term you want is probably "operational semantics"
03:59:33 <mniip> probably
03:59:51 <merijn> mniip: And, not quite, because the compiler might optimise the case away into a single 'error "bar!"'
03:59:55 <mniip> I mean, bottoms should be like regular values except that (case bottom of {...}) = bottom
04:00:01 <merijn> mniip: So the case doesn't have to exist at runtime
04:00:12 <mniip> huh
04:00:18 <mniip> I'd like a source on that
04:00:32 <merijn> mniip: There's some in the papers and this SO post: https://stackoverflow.com/questions/11070690/how-do-exceptions-in-haskell-work
04:00:46 <merijn> mniip: If all branches of a case are bottom, then the entire case evaluates to bottom
04:00:57 <merijn> and which bottom is irrelevant (since all bottoms are denotationally equivalent)
04:01:01 <mniip> ah okay
04:01:06 <mniip> that makes some sense
04:02:15 <merijn> mniip: The reason is that if we have "f :: Foo -> Bar -> Bool" and 'f' is strict in both arguments, what would the result of 'f (error "bar!") (error "foo!")' be?
04:02:39 <merijn> Haskell explicitly does NOT define an evaluation order, so we have no guarantee that it checks the first or second argument first
04:02:56 <noobie_> Thanks so much for the help, I just wanted to let you know that at this point you have lost me.
04:03:01 <merijn> Therefore, denotionally we can't know whether it evaluates to "bar!" or "foo!"
04:03:55 <merijn> noobie_: Well, the last bit of stuff is mostly detailed/pedantic stuff on the mathematical interpretation of bottoms and funky results it can lead to
04:04:31 <merijn> noobie_: If you want, you can pretend the last 20 lines I wrote said: "never use 'throw' or 'error', but use 'throwIO' when producing exceptions"
04:04:52 <mniip> ok, I think I recall a proof that hask is not cartesian
04:07:25 <mniip> suppose data Pair a b = { fst :: a, snd :: b } is a product of a and b, then for any object c with f :: c -> a and g :: c -> b there has to be a unique mediating morphism h :: c -> Pair a b, with f = fst . h, g = snd . h
04:07:52 <mniip> suppose a ~ b ~ c ~ (), and f = g = const undefined
04:08:18 <mniip> then besides the obvious candidate h x = (f x, g x), there is h' x = undefined, satisfying the composition conditions
04:09:29 <mniip> data Pair a b = { !fst :: a, !snd :: b }
04:09:33 <mniip> also isn't a product
04:10:03 <mniip> if f = const (), g = const undefined, there's no h
04:10:59 <mniip> I believe similarly Either isn't a sum, Void isn't an initial object and () isn't terminal
04:11:23 <merijn> mniip: Are you familiar with Fast and Loose Reasoning is Morally Correct?
04:11:51 <mniip> sounds familiar
04:12:23 <merijn> mniip: It's basically a mathematical justification for "pretending Haskell is a total language is useful"
04:12:33 <mniip> right
04:12:38 <mniip> I never said it isn't
04:12:58 <mniip> if we imagine all types are unlifted and all functions are computable, we obtain a cartesian closed Hask
04:13:24 <mniip> albeit with an artefact that 2^(2^N) ~ N
04:17:06 <ertes-w> mniip: i'm sure it's a functor
04:17:36 <ertes-w> if it's a natural transformation, from which functor to which functor would it be?
04:17:52 <mniip> EndoCat profunctor to (->) profunctor
04:18:21 <ertes-w> mniip: ah
04:19:34 <ertes-w> anyway, i was wrong…  it needs to be a *contravariant* functor in my case
04:21:49 <ertes-w> yeah, that works
04:22:43 <mniip> you sure?
04:22:50 <ertes-w> yes
04:23:47 <ertes-w> http://lpaste.net/358890
04:24:22 <ertes-w> that's really ugly though
04:26:23 <ertes-w> it's ugly, because it requires EndoCat wrapping
04:31:44 <merijn> Whoo! Caching my sequential runtimes cuts ages out of my speedup tests :)
04:34:43 * hackagebot secp256k1 0.5.1 – Bindings for secp256k1 library from Bitcoin Core – https://hackage.haskell.org/package/secp256k1
04:37:46 <merijn> Anyone here familiar enough with tasty to help me figure out how to do 2 things? 1) Make some longer running tests optional (i.e. only run with a specific commandline flag) and 2) specify how I can default it to some -j argument?
04:39:43 <ertes-w> merijn: for the latter you can probably just use -with-rtsopts=-N
04:40:30 <merijn> ertes-w: No, I mean tasty generates tests that have a -j command for parallel test execution, but I don't know how to default it so that it actually does that when I do "cabal test"
04:40:44 <merijn> ertes-w: Your suggestion just deals with using multiple capabilities
04:44:37 <ertes-w> merijn: yes, i believe tasty just uses as many threads as there are capabilities, and -j really just sets the number of capabilities…  not entirely sure, but try it
04:45:04 <ertes-w> at least the default value for -j seems to be the number of capabilities
04:49:05 <mniip> ok apparently my intuition was wrong
04:49:07 <mniip> > filter (\fmap -> all (\f -> all (\g -> (fmap f . fmap g) `eq_bf` fmap (g . f)) all_bf) all_bf) all_bff
04:49:10 <lambdabot>  [<(Bool -> Bool) -> Bool -> Bool>,<(Bool -> Bool) -> Bool -> Bool>,<(Bool ->...
04:51:01 <merijn> ertes-w: Anyway, I'm more interested in being able to only selectivelly run long tests
04:52:56 * hackagebot styx 1.3.1 – A generator of nix files – https://hackage.haskell.org/package/styx
04:52:56 * hackagebot concurrency 1.2.1.0 – Typeclasses, functions, and data types for concurrency and STM. – https://hackage.haskell.org/package/concurrency
04:53:04 <mniip> oh wait no
05:03:11 <merijn> I can't be the only one who wants to activate tests conditionally :\
05:13:34 <maerwald> afais this shouldn't be hard in hspec
05:20:06 <maerwald> e.g. it has a --match option
05:20:08 <maffh> Is there an way to select all the records of the data type except one?  It should be determined dynamically. I think I could use lenses, but I prefer not to use it. 
05:20:37 <maerwald> and --skip
05:20:38 <merijn> maerwald: So does tasty, but you can't control that from "cabal test"
05:20:58 <maerwald> --PROG-options?
05:24:04 <maerwald> or --test-options
05:26:48 <ertes-w> maffh: "select"?
05:29:09 <maffh> Could you maybe give me an example or a link where I find more about "select"
05:29:36 <ertes-w> maffh: no, i mean: what do you mean by "select"?
05:29:44 <ertes-w> hence the quotes
05:30:40 <maffh> Oh, haha, sorry! Let's say we have a data type: data Person= Person {name :: String, age : Int, Money :: Int} and I want all the fields except for the Name
05:31:33 <ertes-w> because you don't care who it is, as long as they're young and have money =P
05:31:36 <ertes-w> SCNR =)
05:31:58 <ertes-w> well, what would the type of the thing that you want be?
05:32:40 <maffh> [Int]
05:32:51 <ertes-w> why [Int] and not (Int, Int)?
05:33:33 <ertes-w> anyway, one option would be to use feature classes
05:33:48 <ertes-w> class HasAge a where age :: Lens' a Int
05:33:59 <ertes-w> class HasMoney a where money :: Lens' a Int
05:34:02 <maffh> Because actually the Person is dynamic. It could also be data Dog = Dog {age :: Int, randomField :: Int, another :: Int}
05:34:15 <ertes-w> myF :: (HasAge a, HasMoney a) => a -> …
05:34:21 <ertes-w> you could just give myF a Person
05:34:48 <ertes-w> so you want all Int fields?
05:35:23 <maffh> Uhm not really, it could be any arbitrary type
05:35:32 <ertes-w> so you want all fields of a certain type?
05:35:53 <maffh> uhm nope. It could also be the case that it needs to be converted
05:36:21 <ertes-w> so you want all fields that can be converted to Int?
05:37:02 <maffh> No, I want to have all the functions except for one
05:37:35 <maffh> But I think I am going to do it slightly different. I don't think it is possible
05:37:56 <maffh> Anyway, thanks for your help!
05:38:09 <ertes-w> almost everything is possible, but your problem is underspecified…  how do you distinguish the field you *don't* want?
05:38:41 <ertes-w> the most ad hoc solution would be a traversal
05:39:37 <maerwald> almost sounds like he wants row types
05:40:03 <ertes-w> yeah, probably…  but row types suck in haskell
05:40:36 <maffh> Uhmm, for example: I receive the function "name" of person. Then with some magic I should receive the values of the other functions
05:40:59 <maerwald> that sounds... weird
05:42:25 <ertes-w> maffh: something like that is probably possible with a label-based approach, but it's not gonna be pretty
05:42:31 <ertes-w> maffh: why don't you just explain your use case?
05:54:05 <merijn> hmmm
05:54:26 <merijn> Any clue why GHC.Conc.getNumProcessors would return "1" on a machine that does not, in fact, have only one CPU?
05:54:36 <maffh> Sorry, I disconnected
05:55:07 <erisco> I don't know nothing about anything but is that based on the machine GHC was compiled on?
05:55:40 <merijn> erisco: Actually, I think I'm an idiot. The code is in a library and the library users doesn't have -threaded as a flag
05:56:38 <erisco> yay, we can be numpties together!
05:57:17 <ertes-w> maffh: why don't you just explain your use case?
05:58:45 <maffh> I want to apply feature selection on records https://en.wikipedia.org/wiki/Feature_selection
05:59:18 <maffh> and one of the variables I want to use to predict and the other variables as independent variables
06:01:14 <maffh> But I will probably just split the independent from the dependent variables
06:01:25 <maffh> Makes it much easier
06:08:51 <ertes-w> maffh: yes, you should definitely do that
06:12:01 <maffh> Will do that, thanks:)
06:17:24 <dfsafd> I think I have found aa bug in Text.Regex
06:17:46 <dfsafd> matchRegex (mkRegex "\\w") "€" -> no match, matchRegex (mkRegex "\\W") "€" -> no match
06:18:28 <phadej> dfsafd: IIRC it doesn't know Unicode, use text-icu
06:21:16 <dfsafd> isn't there a switch to make it unicode-aware?
06:21:54 <phadej> regex-tdfa also says it knows how to handle unicode
06:22:11 <phadej> which I'd use is need regexp
06:22:25 <phadej> *if needed (user supplied) regexp
06:23:18 <dfsafd> i dont need user supplied regexps, only regexps that can distinguish alpha numeric characters from non-alpha numeric characters
06:23:38 <phadej> then use Data.Char.isAlphaNum :)
06:24:01 <phadej> with or without parser-combinator lib, like e.g. megaparsec
06:25:03 <dfsafd> i know/hope you are joking
06:25:12 <merijn> dfsafd: Doubt it
06:25:30 <merijn> dfsafd: I would never recommend using regexes instead of just parsers
06:25:45 <merijn> Regexes are just unreadable parsers that are a bitch to maintain
06:26:20 <tdammers> regexes are great for ad-hoc stuff, when writing a program would be overkill
06:27:08 <dfsafd> regexps work great for tokenizing words in most other languages...
06:27:15 <tdammers> fsvo "great"
06:27:23 <erisco> I must insert my obligatory endorsement of regular expressions as a simple, effective, tool
06:27:34 <merijn> dfsafd: No one has bothered to write nice regex bindings for Haskell because almost no one uses them regularly
06:28:38 <dfsafd> merijn: and no one cares about correctness? that the builtin regex engine is broken?
06:28:41 <tdammers> I think the question is not "why do people not use regexes in Haskell", but rather, "why do people use them so much in other languages"
06:28:51 <merijn> dfsafd: Which builtin regex engine?
06:28:53 <tdammers> dfsafd: it's not built in
06:29:10 <dfsafd> merijn: the one in Text.Regex which does not support unicode
06:29:13 <merijn> dfsafd: You're just using whatever regex library you decided to add to your project
06:29:19 <merijn> dfsafd: Text.Regex isn't builtin
06:29:33 <merijn> Seems to be in the regex-posix package
06:30:11 <tdammers> there is no regex support whatsoever built into the language itself, and there are no regex functions in base either
06:30:29 <phadej> note, there is regex-applicative which I'd recommend to use
06:30:43 <phadej> but the interface is essentially the same as with parser combintor lib, so the difference is small
06:30:46 <erisco> I should make a regex library to prove everyone wrong here... hm... but that's... work
06:31:39 <merijn> erisco: Sure, go ahead. I mean, regex is a lot like a very limited parser combinator library, tbh
06:31:57 <merijn> * = many, ? = optional, etc.
06:32:06 <phadej> indeed, that's what regex-applicative does
06:32:11 <erisco> it is not much more limited than other parser combinators, only that it must be regular language
06:32:31 <tdammers> which is a pretty harsh limitation ;)
06:32:42 <merijn> But I'd rather just write many/optional/etc. with do notation than writing it as strings
06:32:48 <tdammers> but then, many regex flavors out there aren't really regular anymore anyway
06:32:51 <phadej> merijn: ApplicativeDo
06:32:54 <erisco> meh, there are lots of regular languages in use
06:32:59 <phadej> btw
06:33:18 <erisco> you could argue that CFLs are harshly restricted because they are not CSLs
06:33:21 <merijn> Whoo, cut my tests down from 10 minutes to 31s :)
06:33:23 <erisco> well, they are... you know what I mean
06:33:26 <dfsafd> idea: use your parser combinator library to write a proper regex engine *with* unicode support
06:33:45 <phadej> dfsafd: it's not trivial, e.g. many (many anyChar)
06:33:54 <merijn> dfsafd: Parser combinators already have all the stuff regexes do, just without the string syntax
06:34:17 <phadej> ... and provide way better error messages than (POSIX) regexps
06:34:28 <phadej> (which is essentially: "didn't match")
06:34:42 <phadej> IMHO error messages is already a good reason to use parser combinator lib
06:35:15 <dfsafd> phadej: if it is not trivial, why is using parser combinators insteaad of regexps suggested?
06:35:43 <merijn> dfsafd: Can you write an example of what your regex should catch?
06:35:45 <phadej> dfsafd: because for general case it's non-trivial, but if regex isn't user input, then it's not general case
06:35:51 <tdammers> also two elephants in the room: 1) parser combinators are typed, if you say "I want this to produce a list of integers" but it doesn't, then it won't compile; and 2) regex is strictly limited to parsing character streams (or byte streams) into match group sets (or subsets thereof)
06:36:17 <phadej> tdammers: 2) isn't true. See regex-applicative
06:37:10 <erisco> regex-applicative... the restriction of regular language with the verbosity of parser combinators... lose/lose! :P
06:37:20 <dfsafd> phadej: there you go. you cant replace parser combinators with regexps
06:37:57 <phadej> dfsafd: the only thing where I use regex-applicative are like `many anySym *> somethingSpecific`
06:37:59 <merijn> dfsafd: I'm pretty sure I can write out a parser for your regex in like a minute if you told me what it was
06:38:37 <tdammers> phadej: regex-applicative, mm, ok, but I'd consider that a bit of a hybrid...
06:39:19 <phadej> actually, `few anySym *> somethingSpecific`, where few is non-greedy many
06:40:09 <dfsafd> merijn: roughly like "(abcd)o(fghi)\\1-\\2"
06:40:19 <phadej> dfsafd: please say what you want to write with regexp, we can have a speed competition with merijn who will make the parser fastest :)
06:40:40 <merijn> phadej: Naah, because I'm also trying to speedup my test-suite
06:40:42 <phadej> dfsafd: btw, that's not even a regexp, as it uses capture groups
06:40:53 <merijn> phadej: So I'm only paying attention when waiting for my tests :p
06:41:02 <erisco> dfsafd, does that do what you think it does? because that is just one sentence oO
06:41:16 <erisco> it only recognises abcdofghi\1-\2
06:41:31 <phadej> do { g1 <- string "abcd"; _ <- char o; g2 <- string "fghi"; _ <- string g1; _ <- char '-'; _ <- string g2; return ... }
06:42:07 <phadej> erisco: I think it's meant to recognise abcdofghiabd-fghi
06:42:11 <phadej> erisco: I think it's meant to recognise abcdofghiabcd-fghi
06:42:35 <erisco> oh, back-references... nonregular...
06:42:40 <phadej> yep
06:42:50 <phadej> the sign when regexp are the wrong tool :)
06:42:58 <dfsafd> i forgot the brackets: "([abcd])o([fghi])\\1-\\2"
06:43:12 <erisco> my advocation only extends to the regular part of regular expressions
06:43:20 <dfsafd> if you can't w rite a parser combinator for that it is funny :)
06:43:28 <erisco> there is a beautiful, simple syntax to express regular languages, and that is what is appealing about them
06:43:31 <phadej> do { c1 <- oneof "abcd"; _ <- char o; c2 <- oneof "fghi"; _ <- char c1; _ <- char '-'; _ <- char c2; return ... }
06:43:39 <erisco> by the time you add these extensions... meh...
06:43:45 <merijn> dfsafd: Writing a parser combinator for that is easy. Writing a regular expression is impossible
06:44:08 <phadej> ^ done
06:44:11 <merijn> dfsafd: (The fact that you use PCRE stuff that *claims* to be a regular expression, but isn't, is irrelevant)
06:44:54 <phadej> (dependening on parsing lib the combinator names may vary, but I'm sure there is such, or easy to write)
06:45:17 <merijn> phadej: You forgot quotes around 'o' :p
06:45:23 <merijn> But yeah, that looks about right
06:45:36 <phadej> merijn: thanks :)
06:45:50 <phadej> oneof = choice . map char -- IIRC
06:46:41 <erisco> by the way, speaking of back-references, this is something monadic parsing enables... do we know that class of languages?
06:47:17 <erisco> it should correspond to a grammar notation where we can bind earlier nonterminals and re-use them later in the same production
06:48:17 * hackagebot secp256k1 0.5.2 – Bindings for secp256k1 library from Bitcoin Core – https://hackage.haskell.org/package/secp256k1
06:48:42 <erisco> such as  S ::= (x = A) "b" x; A ::= "a" A | ε  for sentences with equal number of 'a' on either side of 'b'
06:49:05 <erisco> I guess "later" here is biased to left-to-right
06:49:28 <phadej> erisco: that language is CFG: a^n b a^n
06:50:09 <erisco> that isn't an expression of a CFL that I am familiar with, but it may be CFL, sure... clearly I am describing something more general though
06:50:32 <mnoonan> but the language class is weaker or noncomparable to CFLs, since a^n b^n can't be done with capture groups
06:51:08 <phadej> but monadic parsing is more powerful, essentialy as we can do { x <- many anyChar; either fail pure (decide x); } -- recursively enumerable
06:51:20 <erisco> oh I suppose with monadic parsing we have arbitrary computation between the binding and any later uses
06:51:25 <erisco> whoops
06:51:45 <phadej> and there is context-sensitive in between, and IIRC you can do that with infinite applicatie parsers
06:51:48 <mnoonan> oh, you were wondering about the strength of monadic parsing in general, or just the strength of regex + capture groups?
06:52:30 <dfsafd> regex-compat-tdfa claims it support unicode, but it doesn't either
06:52:40 <erisco> mnoonan, well, I was wrongly thinking of a too simple monadic parsing... so forget that... but yes, where does RL + backrefs come in?
06:54:13 <erisco> it is not the same as indexing
06:54:53 <erisco> like I was showing, this is like binding the expansion of a NT and re-using it later
06:55:55 <erisco> indexing can be explained somewhat like this but it is restricted to referring to the length of the expansion, not the terminals
06:56:33 <mnoonan> not sure, but looking around found this nice observation: you can replace a regex with capture groups by a normal regex, with extra symbols representing each group, then follow matching by homomorphic replacement
06:57:15 <mnoonan> so the expression from before would become "XoYX-Y" followed by X -> [abcd] etc
06:58:09 <erisco> I do not follow
06:58:25 <ertes-w> regarding the parsers vs. regexes discussion earlier:  i found a nice library for these small ad-hoc use cases: appar
06:59:42 <ertes-w> and before that i reinvented it many times just to avoid writing regexes
06:59:59 <phadej> mnoonan: you can do such "ad-hoc" post-processing when capture groups are of known and non-variable length; but when you have kleene star in there, your idea falls apart
07:00:11 <phadej> especially when X and Y may overlap
07:00:20 <ertes-w> (it's really just (MaybeT (State i)))
07:00:23 <phadej> (e.g. both are "a*"
07:00:38 <phadej> ertes-w: why won't just use parsec?
07:00:53 <ertes-w> phadej: because parsec is massive
07:01:05 <mnoonan> phadej: sure, I'm just trying to get a handle on the class of languages that can be recognized, not to implement the matcher
07:01:54 <phadej> ertes-w: I disagree, http://hackage.haskell.org/package/parsec-3.1.11/docs/Text-Parsec-Char.html and http://hackage.haskell.org/package/parsec-3.1.11/docs/Text-Parsec-Combinator.html aren't that big modules; few screenfuls
07:02:41 <ertes-w> phadej: it's not about the modules…  this is what i mean: https://hackage.haskell.org/package/parsec-3.1.11/docs/src/Text.Parsec.Prim.html#ParsecT
07:02:51 <phadej> ertes-w: but why would you care about internals?
07:02:59 <ertes-w> phadej: because speed
07:03:14 <phadej> ertes-w: well, parsec approach *is* faster than naive MaybeT (State i)
07:04:00 <erisco> ertes-w, I think merijn has a parser combinator to sell you!
07:04:05 <merijn> phadej: btw, you're working on cabal, right?
07:04:10 <phadej> in fact, it's "just" cps-ised s -> Either Error (a, s)
07:04:35 <phadej> which is ExceptT Error (State i) - if you want to use transformers :)
07:05:13 <phadej> (there are two continuations, as it differs between empty and non-empty constructions, so many (many anySym) throws an exception)
07:05:31 <phadej> unfortunately you can fool it anyway
07:06:08 <phadej> merijn: I do, when I have time
07:06:20 <merijn> phadej: Do you know if I can make new-test run in parallel?
07:06:53 <ertes-w> phadej: i'll see if i can verify that through a benchmark, but what i can tell you is that appar gives me the same speeds as if i had broken the string apart myself using regular ByteString functions
07:07:26 <phadej> ertes-w: if everything is small and in a single module then GHC just inlines everything
07:07:37 <merijn> ertes-w: I finally have my parallel conduit and pipe working :) (Although I gave up on the single universal interface) And my parallel Consumer for pipes is still borked
07:07:46 <merijn> But at least I know why :p
07:08:12 <merijn> phadej: Also, if I run "cabal new-test all" it will happily tell me all suites failed if only one does...
07:08:46 <ertes-w> phadej: but just the number of fields and potential branches disagrees with that assessment, even though CPS might provide a speedup for highly nesty and loopy parsers
07:09:14 <ertes-w> phadej: i'll benchmark anyway – next time i need it =)
07:09:37 <ertes-w> phadej: any particular reason you recommend parsec over megaparsec?
07:09:55 <ertes-w> merijn: so you didn't go with the fold approach?
07:10:02 <merijn> phadej: Also, relatedly is detailed-1.0 actually working in cabal? Or is exit-code the only way to go
07:10:41 <merijn> ertes-w: I used the fold, but that's not quite universal enough for both pipes and conduit
07:10:45 <phadej> ertes-w: please use megaparsec if you like it more, I use trifecta in my own projects for better error messages etc.
07:11:40 <ertes-w> phadej: i use trifecta as well…  haven't considered using it for those small cases though
07:11:56 <phadej> merijn: I don't know about new-test; I use it only in CI; locally is do poor-mans cabal new-run (i.e. $(find dist-newstyle -type f -name test-name))
07:12:30 <ertes-w> merijn: well, nothing is universal enough for pipes…  you need pipes-parse
07:12:40 <ertes-w> unless you changed your approach altogether
07:12:44 <phadej> ertes-w: it works for them as well. Or to put differently, as you actually use `parsers`, you can switch to attoparsec when you need more speed
07:12:51 <merijn> ertes-w: Naah, I just return "Producer -> Producer" as result
07:12:57 <merijn> ertes-w: Doesn't need pipes-parse
07:13:38 <ertes-w> merijn: that's pretty much pipes-parse, just without the StateT =)
07:13:57 <merijn> ertes-w: Perhaps, but cuts out dependencies :p
07:14:21 <merijn> Sadly I think I need to give up on my "Consumer" and Make that "Producer -> Effect" to make it work
07:15:09 <ertes-w> merijn: all of that is the reason i no longer use pipes
07:15:46 <merijn> ertes-w: Conduit's inability to do push is annoying too, though :\
07:16:46 * hackagebot schematic 0.3.1.0 – JSON-biased spec and validation tool – https://hackage.haskell.org/package/schematic
07:16:53 <merijn> phadej: The problem is that the tests are rather slow, so running them in parallel helps when checking locally :)
07:16:54 <ertes-w> merijn: you want the producer to have control instead of the consumer?
07:17:02 <merijn> ertes-w: Sometimes
07:17:47 <merijn> Anyway, gym time. I'll cleanup the code tomorrow :)
07:17:57 <ertes-w> have fun =)
07:18:29 <phadej> merijn: I see. I usually run only single test-suite at the time (the one I'd expect to fail). That unpolishedness of new-test is unfortunate though. I have no idea if anyone have it their todo-list though
07:18:51 <phadej> I doubt, it works "well enough". (it's not that far, that we didn't had new-test at all)
07:19:04 <mnoonan> erisco: "A formal study of practical regular expressions" http://137.149.157.5/Articles/index.php?aid=1
07:20:56 <mnoonan> erisco: Theorem 2 and 3 prove regex+capture are context-sensitive, but incomparable to the CFLs
07:21:38 <erisco> well I know they are context-sensitive, i.e. not context-free
07:22:32 <mnoonan> they also prove a pumping lemma, fwiw
07:23:09 <erisco> well, the result they are context-sensitive is a bit interesting because I am not immediately sure how I'd implement that
07:24:10 * hackagebot urlpath 6.0.4 – Painfully simple URL deployment. – https://hackage.haskell.org/package/urlpath
07:26:43 <erisco> I am aware of a technique where you can, essentially, propagate a message with nonterminals across terminals
07:27:28 <erisco> and so you can communicate back and forth... but coming up with a scheme to communicate the exact string to match later on... not sure
07:28:15 <erisco> it all seems pretty silly in practicality anyways
07:30:02 <erisco> I suspect you need something like singletons, but between terminals and nonterminals
07:30:12 <erisco> and then some nonterminal to signify juxtaposition
07:34:15 * hackagebot markup 4.0.2 – Abstraction for HTML-embedded content – https://hackage.haskell.org/package/markup
07:34:15 * hackagebot graphite 0.4.2.0 – Graphs and networks library – https://hackage.haskell.org/package/graphite
08:15:48 <kuribas> What's the advantage of a service layer over just having an API that implements the non-UI parts (business logic)?
08:16:25 <kuribas> hmm, probably offtopic...
08:17:29 <cloudhead> kuribas: service layer?
08:17:52 <kuribas> cloudhead: https://en.wikipedia.org/wiki/Service_layer_pattern
08:18:05 <mauke> service lair
08:18:44 <cloudhead> ah I see
08:18:53 <cloudhead> that link kind of explains the advantage actually
08:19:40 <cloudhead> a service layer can reduce the surface area of an api quite a bit
08:19:52 <cloudhead> making it simpler to use
08:20:33 <kuribas> I fail to see how it can be simpler than an API?
08:20:48 <cloudhead> it can expose a subset of the API
08:21:09 <cloudhead> or package the api data in a way that works specifically for the user of that layer
08:22:00 <cloudhead> it's quite likely that the frontend has to do something with the api data before displaying it
08:22:07 <cloudhead> the service layer can take care of that
08:22:16 <cloudhead> making the frontend smaller/simpler
08:25:19 <kuribas> how is it different from just a public API?
08:27:29 <cloudhead> kuribas: an API is still something you have to manipulate to make useful
08:27:40 <cloudhead> if you just want a view on something, you don't want an api
08:28:32 <cloudhead> ex: if I point my browser to http://foo.com/blah, I just want a view on that, having to query an api and render blah on the client is extra work
08:32:41 <kuribas> cloudhead: but a service layer doesn't do any rendering?
08:34:09 <kuribas> If I can read/write/modify data using the browser, then I consider it an API.
08:35:38 <cloudhead> kuribas: are there any restrictions to what a service layer does?
08:35:55 <cloudhead> kuribas: then everything is an API and you've answered your question
08:36:29 <cloudhead> but an API is something more specific, a UI allows you to read/write/modify data, it's still not an API
08:36:44 <Yotam_> A while back I saw a project that represented objects as functions "Point -> Bool", anyone know where can I find more information on this?
08:38:36 <kuribas> cloudhead: https://www.infoq.com/articles/apis-soa
08:38:43 <ertes-w> kuribas: i don't understand that article, to be honest (the wikipedia one)
08:39:01 <kuribas> ertes-w: neither do I
08:39:59 <ertes-w> seems to be one of those "OOP-specific solutions to OOP problems"
08:40:48 <alx741> Yotam_: not sure what you mean, but have you tried: https://www.stackage.org/lts-8.4/hoogle?q=Point%20->%20Bool
08:41:49 <Yotam_> alx741: I saw it in some lecture online. Not sure I'm remembering it right or that someone published a library of it.
08:43:06 <Yotam_> It was encoding a circle with a "Point->Bool" function and then rendering it
08:43:27 <lyxia> Yotam_: JuicyPixels can do that
08:43:50 <ertes-w> Yotam_: do you see how (->) can be a representation for immutable arrays?
08:43:56 <lyxia> https://hackage.haskell.org/package/JuicyPixels-3.2.8.3/docs/Codec-Picture.html#v:generateImage and withImage convert between images and functions
08:44:13 <lyxia> It's Point -> Pixel though
08:44:17 <Yotam_> ertes-w: not sure I undrestood you
08:44:51 <ertes-w> Yotam_: type Array = (->)
08:45:00 <ertes-w> Yotam_: myObject :: Array Point Bool
08:45:09 <mnoonan> Yotam_: that sounds like some of Conal Elliott's "denotational semantics" talks and papers
08:45:26 <ertes-w> Yotam_: now if Point is something like (Int, Int), then what you have is essentially a grid of booleans
08:45:50 <ertes-w> myObject (5, 7)  -- this is the boolean at position (5, 7)
08:47:04 <Yotam_> oh nice
08:47:35 <dfsafd> can you write unit tests in hunit, which aren't as "chatty" as in this example:
08:47:39 <dfsafd> https://courses.cs.washington.edu/courses/cse341/10wi/haskell/UnitTestExample.hs
08:48:30 <dfsafd> do you have to write a "message" for each assertEqual test and do you have to create a new function for each test you write?
08:48:36 <Yotam_> ertes-w: I am going to use something something similar but Doubles instead of booleans to optimise boundry finding
08:48:45 <phadej> dfsafd: you can use @?= or @=? to make assertions
08:48:58 <lyxia> dfsafd: you can inline test1 .. test5 inside tests
08:52:47 <dfsafd> phadej: that solves my first problem but what about the other, more than one @?= in a single test case?
08:54:51 <lyxia> dfsafd: just put many of them in a do block
08:55:17 <lyxia> (@?=) :: _ => a -> a -> IO ()
08:56:56 <dfsafd> aha, thanks
08:57:56 * hackagebot find-clumpiness 0.2.3.1 – Find the clumpiness of labels in a tree – https://hackage.haskell.org/package/find-clumpiness
08:58:05 <mivael> hello all
08:58:41 <Yotam_> :mivael hello
09:04:41 <ertes-w> Yotam_: sure, and that's the beauty of using (->) as an abstraction for arrays: it extends beyond arrays, because now your bit fields can be dense
09:04:47 <mivael> Should I expect that (length . group . sort) is a fast enough way to count unique values in a list of 10^5 Int values?
09:05:22 <ertes-w> Yotam_: (Rational, Rational, Rational) -> Bool  -- this type can represent a rational sphere *exactly*
09:05:30 <the_2nd> I'm sure there's a nicer syntax for this: maximumBy (\x y -> snd x `compare` snd y)
09:05:31 <Yotam_> mivael: What about a map? like dictionaries in python
09:05:45 <the_2nd> can I simplify the lambda?
09:05:49 <ertes-w> Yotam_: f (x, y, z) = x^2 + y^2 + z^2 <= 1  -- this is the unit sphere
09:05:57 <lyxia> the_2nd: comparing snd
09:06:21 <lyxia> the_2nd: or,  compare `on` snd
09:06:38 <mivael> Yotam_, I tried Data.Set for that, with no speed boost.
09:07:06 <the_2nd> lyxia, comparing is nice, thanks
09:07:37 <Yotam_> mivael: Have you tried Data.Map?
09:09:02 <Yotam_> mivael: the problem I have with your suggestion is that sorting that many values would take a lot of time no matter what
09:09:26 <Yotam_> mivael: What is the range of the values?
09:09:27 <mivael> Yotam_, no.  Should I?  Note that I do NOT need to count number of occurrences of each value.
09:09:58 <jle`> mivael: i'd benchmark against S.size . S.fromList
09:10:01 <Yotam_> This is the one I know. Not really sure about its speed though
09:10:09 <jle`> although that does build the entire tree of unique values in memory
09:10:31 <jle`> in your case you do sort anyway so have to bring the whole list into memory anyway
09:10:40 <mivael> Yotam_, order of 10^5, too.
09:10:41 <Yotam_> What is the range? If it is somewhat small there is a O(1) solution
09:10:48 <Yotam_> oh bummer
09:11:11 <marvin3> mivael are you building list in both cases or did you replace list with Data.Set example?
09:11:26 <marvin3> in the other example*
09:11:36 <mivael> marvin3, I build a Set instead of list
09:11:58 <jle`> > randoms (mkStdGen 58734) :: [Int]
09:12:01 <lambdabot>  [2854707070257699373,-2684223684393297929,-3412070929086802828,-617061364102...
09:12:23 <jle`> > IS.size . IS.fromList . take 10000 $ randoms (mkStdGen 89524)
09:12:25 <lambdabot>  10000
09:12:49 <jle`> > IS.size . IS.fromList . take 10000 $ randomsRs (1,1000) (mkStdGen 89524)
09:12:52 <lambdabot>  error:
09:12:53 <lambdabot>      • Variable not in scope:
09:12:53 <lambdabot>          randomsRs :: (Integer, Integer) -> StdGen -> [IS.Key]
09:12:57 <jle`> > IS.size . IS.fromList . take 10000 $ randomRs (1,1000) (mkStdGen 89524)
09:13:00 <lambdabot>  1000
09:13:18 <jle`> i guess i can't make an interesting example using prng's
09:14:15 <jle`> > IS.size . IS.fromList . take 10000 $ zipWith (+) (randomRs (1,10000) (mkStdGen 89524)) (randomRs (1,10000) (mkStdGen 589234))
09:14:17 <lambdabot>  7371
09:14:31 <jle`> hm i'll take it
09:14:35 <mivael> jle`, what "IS" is?   :)
09:14:41 <jle`> it's IntSet
09:14:47 <jle`> Set specialized for Ints
09:14:58 <mivael> I did not try IntSet.  Only Set.
09:15:08 <jle`> i think they should have the same asymptotics
09:15:15 <jle`> IS just might have better constant factors
09:15:33 <mivael> understood
09:16:17 <jle`> but as you can see, lambdabot's sandboxed evaluator was able to count unique values in 10000 items ranging from 1 to 10000 without much issue, but i'd still benchmark
09:16:37 <jle`> also consider using a vector (immutable or mutable) of length 10000
09:16:48 <Yotam_> mivael: Can you store a list with all the possible values? if so you can remove from it the values you have
09:16:53 <BaNzoun3t> When you're using Haxl is it possible to compare an Haxl Int with an Int?
09:16:59 <jle`> and just incrementing the index of each number you find
09:17:01 <dfsafd> how would you write length (filter (\(a,b) -> a == b) (zip [1,2,3,12] [3,2,3,12])) (== 3) in a better way in haskell?
09:17:17 <jle`> possibly an unnecessary optimization tho, i'd profile first :)
09:17:45 <jle`> dsal: well as it is i don't think it's valid haskell
09:18:04 <jle`> so one way to make it better would be to write it in valid haskell :)
09:18:15 <monochrom> wrong nick completion
09:18:21 <jle`> oh thank you
09:19:55 <monochrom> length (filter id (zipWith ...
09:20:04 <monochrom> err
09:20:08 <monochrom> length (filter id (zipWith (==) ...
09:20:08 <jle`> in situations like this it'd be nice if there was a canonical [()]/Nat type
09:20:15 <jle`> *peano nat
09:20:31 <Yotam_> Can someone help me understand the pattern matching in line 27 https://gist.github.com/nh2/bd5983ff692aaf50c690813ccb4bda07
09:20:58 <jle`> Yotam_: look up "View Patterns"
09:21:25 <Yotam_> jle`: oh right, thanks
09:21:26 <glguy> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#ghc-flag--XViewPatterns
09:21:39 <mivael> jle`, I thought about a vector but in seemed to me somehow... unhaskellish  :)
09:22:02 <mivael> s/in seemed/it seemed/
09:22:27 <jle`> i mean it's something i'd probably do after writing the program and then profiling to find the bottlenecks
09:23:08 <jle`> but if it's for like a toy project or a class assignment i wouldn't bother :)
09:23:22 <mivael> Yotam_, I think you had in mind a vector/array?  Not a list.
09:25:28 <mivael> jle`, fair enough
09:25:47 <mivael> thanks, guys!
09:27:14 <mivael> jle`, IntSet actually did the thing  :)
09:27:39 <mivael> It is kind of a toy project:   https://www.codechef.com/submit/complete/15587313
09:28:32 <mivael> oops, wrong link
09:29:00 <Yotam_> I meant list, as you remove more items from it you'll free space for your computer
09:29:03 <mivael> https://www.codechef.com/viewsolution/15587313
09:30:43 <mivael> Yotam_, this would be O(N^2) solution (or worse) because one needs O(N) to find a value in a list.
09:33:28 <fakenullie> I love how ghci prints infinite lists and not just hangs
09:36:03 <Gurkenglas> I don't like how it seems that all the Haskell web interfaces seem to hang when asked to print an infinite list.
09:36:40 <c_wraith> Gurkenglas, you're just using them wrong. they all *could*. :P
09:36:42 <eacameron> Gurkenglas: How do Python web interfaces react when asked to run an infinite loop?
09:37:15 <Gurkenglas> eacameron, they correctly print bottom :P
09:37:39 <Xnuk> sum [1..] `assertEqual` (-1/12)
09:38:37 <monochrom> No, some of those webapp libraries make finitary normal-form assumptions too.
09:38:51 <c_wraith> Gurkenglas, seriously though. set chunked encoding, provide a generator in the underlying streaming abstraction.
09:38:54 <eacameron> Gurkenglas: repl.it doesn't :D
09:39:00 <eacameron> Gurkenglas: It just hangs
09:39:32 <Gurkenglas> eacameron, which is how you print bottom as opposed to a (lazy) infinite list
09:39:33 <c_wraith> browsers may not handle infinite input that well..
09:39:45 <eacameron> Gurkenglas: lol
09:39:52 <c_wraith> but other clients certainly could.
09:40:12 <monochrom> Aw, semantics.
09:41:12 * hackagebot ip 0.9.3 – Library for IP and MAC addresses – https://hackage.haskell.org/package/ip
09:41:12 * hackagebot log-warper 1.2.3 – Flexible, configurable, monadic and pretty logging – https://hackage.haskell.org/package/log-warper
09:42:28 <monochrom> Oh noes, 8.2.2 RC1
09:42:40 <monochrom> This recompiles everything again.
09:44:54 <c_wraith> some of those bug fixes looked pretty important
10:05:06 <fresheyeball> anyone know if there is a IRC channel for "stack"?
10:05:18 <fresheyeball> Or is it appropriate to ask stack questions here?
10:05:45 <ski> how about #haskell-stack ?
10:05:55 <ski> i think Stack questions are ok here as well
10:06:22 <fresheyeball> so the "stack path" command gives back a bunch of paths
10:06:35 <fresheyeball> which one does it use to find external non-haskell dependencies?
10:09:18 <Gurkenglas> monochrom, not webapp libraries, websites that provide a ghci
10:19:19 <sm> fresheyeball: that would be $PATH, I think
10:19:22 <lambdamu_> Can I download the haddock generated files for some package from hackage as an archive?
10:22:23 <Jenaf> hi! I forgot that shorthand for set operations wich was somethign like [x|predicate <- set] or so, and I'm to stupid to find it online (yeah it's the most basic thing most ppl talk about haskell but I'm brainfarting hard atm)
10:22:38 <Jenaf> can s
10:22:40 <Jenaf> ome
10:22:50 <Jenaf> can someone pls enlighten me?
10:23:29 <mnoonan> "list comprehensions"
10:23:41 <shloub> > [x^2 | x <- [0..10]]
10:23:43 <lambdabot>  [0,1,4,9,16,25,36,49,64,81,100]
10:23:59 <shloub> > [x^2 | x <- [0..10], odd x]
10:24:01 <lambdabot>  [1,9,25,49,81]
10:26:58 <Jenaf> kthy
10:27:27 <Jenaf> so basucaly [f x|x<-set,predicate x]
10:27:47 <shloub> basically
10:28:05 <Jenaf> thank you dear sir or lady
10:31:57 <Jenaf> oh great... I jsut figured a faster solution to my project euler problem; but I'd had to rewrite a lot, basically fusing a merge sort with the generation of my list; then I can do \\ on two sorted lists. (I'd do it "by hand" to ensure the benefit I get from the two lists beeing sorted
10:32:20 <Jenaf> I'm generating sorted sublists, so merging them properly should be a good idea...
10:37:28 <bollu> Hey everyoe
10:37:29 <bollu> everyone
10:37:49 <bollu> does anyone have resources on compiler construction in haskell? I've moved simplexhc to C++, and I'm way way way more productive
10:37:54 <bollu> I'm distressed by this fact
10:37:58 <bollu> so I want to see what I'm missing
10:38:05 <bollu> when it comes to writing a compiler in haskell
10:38:25 <bollu> is it that I don't know how to structure things correctly? do I phrase stuff in mutable patterns? I don't know
10:39:24 <Yotam_> from the top of google http://dev.stephendiehl.com/fun/
10:39:39 <Yotam_> And you can allways check out GHC docs
10:39:44 <tdammers> also
10:39:46 <tdammers> @where scheme
10:39:46 <lambdabot> https://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours
10:40:16 <tdammers> you may also want to check out the source code for pandoc - not really a compiler, but the overall architecture is similar
10:40:35 <Yotam_> tdammers: what does the where command do?
10:41:05 <tdammers> lambdabot has a bunch of relevant URLs stored, and you can make it say them using @where
10:41:22 <Yotam_> you have a ref to this list?
10:41:43 <proofskiddie> Is there a way to import from an absolute path? e.x. 'import "../../taco.hs"'
10:41:47 <tdammers> there probably is one somewhere, but I just remember a few that I find particularly useful
10:42:05 <Yotam_> @where help
10:42:05 <lambdabot> Got the code? Got the info? Then we've got the help for you!
10:42:24 <Yotam_> @where list
10:42:24 <lambdabot> I know nothing about list.
10:42:26 <tdammers> Yotam_: try @help in a private message to lambdabot
10:42:36 <dfsafd> does haskell have a ternary if equivalent?
10:42:36 <Yotam_> k
10:42:58 <mnoonan> dfsafd, we call it "if" :)
10:43:29 <Jenaf> I like haskell because of abominations liek this:
10:43:36 <Jenaf> mergeSorter [] stuff = stuff
10:43:37 <Jenaf> mergeSorter stuff [] = stuff
10:43:39 <dfsafd> it has so many other tools for obfuscating code, so why no ? operator :)
10:43:57 <Yotam_> proofskiddie: Pretty sure you need it compiled to an object file, or just use stack/cabal
10:44:35 <tdammers> Yotam_: https://wiki.haskell.org/Lambdabot is also worth reading
10:44:47 <Yotam_> I'll check it
10:44:54 <tdammers> Jenaf: why do you consider that an abomination?
10:45:09 <Jenaf> donne some ppl think its bad calling stuff jsut stuff
10:45:10 <Yotam_> Jenaf: the type of `staff` must be a list
10:45:29 <Yotam_> stuff*
10:45:33 <tdammers> Jenaf: that is not specific to Haskell though, people use bad variable names in all languages
10:45:35 <Jenaf> the function hasnor guards, it's single purpose thingy
10:46:00 <Jenaf> the lsits also need to be sorted and i want call that one outside of the defined frame wher ei can guarantee to feed it sorted lists
10:46:11 <Jenaf> or else it will propably blow up
10:46:24 <Yotam_> But it has no side effects
10:46:25 <Jenaf> at least cause wierd thigns to happen
10:46:31 <Jenaf> no side effects
10:46:36 <tdammers> well, if a variable has no other meaning than "the thing that we use in this position", then the best variable name is probably just 'x'
10:46:37 <Jenaf> I don't liek side effects
10:46:42 <Yotam_> so no blowing things up
10:47:05 <tdammers> anyway; if you want type-level guarantees of list sortedness, then things get a bit tricky
10:47:07 <Jenaf> yeah, btu it will spit out ... garbage.. but garbage in most likely always cuases garbage out anyway
10:47:25 <Jenaf> and it'
10:47:34 <Jenaf> s jsut a project euler problem 
10:54:27 <erisco> here is a fun one…
10:54:35 <erisco> :t join (flip . foldr . const . const)
10:54:37 <lambdabot> Foldable t => t a -> t a -> t a
10:57:03 <erisco> that is a possible mappend for a list Monoid, mempty = []
10:57:47 <erisco> was inspired by the partial function Jenaf provided
10:58:07 <Jenaf> lol
10:58:34 <Jenaf> I admit i don't udnerstand it, btu it's fun to inspire someone
10:58:34 <monochrom> > join (flip . foldr . const . const) [1,2,3] [4,5,6]
10:58:38 <lambdabot>  [1,2,3]
10:58:55 <monochrom> I want my money back.
10:59:00 <erisco> it is a good example of unusual function compositions
10:59:02 <Jenaf> haha
10:59:11 <Jenaf> yeah I saw that one, but I could nto follow it
10:59:16 <Yotam_> :t const
10:59:17 <lambdabot> a -> b -> a
10:59:23 <erisco> it is just the First Monoid
10:59:30 <monochrom> > join (flip . foldr . const . const) [1,2,3,4] [5,6]
10:59:33 <lambdabot>  [1,2,3,4]
10:59:56 <monochrom> Hrm, so I wonder why it is not t a -> b -> t a
10:59:59 <Jenaf> getPermuter seq = foldr (.) id $ map (uncurry swap) $ zip over under
11:00:05 <Jenaf> thats one I actually wrote once
11:00:15 <erisco> monochrom, because [] is an identity
11:01:03 <erisco> > join (flip . foldr . const . const) [] [5,6]
11:01:05 <lambdabot>  [5,6]
11:01:11 <monochrom> @type flip . foldr . const . const
11:01:12 <lambdabot> Foldable t => c -> t a -> c -> c
11:01:18 <Jenaf> now I get it
11:01:29 <monochrom> Oh! OK.
11:01:30 <Jenaf> it onle works for emtpy lists in oen argument
11:01:50 <erisco> > join (flip . foldr . const . const) [1,2,3] []
11:01:52 <lambdabot>  [1,2,3]
11:02:39 <erisco> @pl \xs ys -> foldr (\_ _ -> xs) ys xs
11:02:39 <lambdabot> flip =<< foldr . const . const
11:03:10 <erisco> @unpl join (flip . foldr . const . const)
11:03:10 <lambdabot> (\ b0 y -> foldr (\ _ _ -> b0) y b0)
11:03:43 <erisco> the derivation is fun
11:04:13 <erisco> \xs ys -> foldr (\_ _ -> xs) ys xs == \xs ys -> flip (foldr (\_ _ -> xs)) xs ys == \xs -> flip (foldr (\_ _ -> xs)) xs
11:04:22 <erisco> now the goal is to join and eta reduce xs
11:04:31 <erisco> == \xs -> ((flip . foldr) (\_ _ -> xs)) xs
11:04:55 * ski never understood why people use `==' rather than `=' in situations like this
11:04:57 <erisco> == \xs -> ((flip . foldr) ((const . const) xs)) xs  -- one of the fun steps
11:05:07 <erisco> ski, I usually use = but I felt like == today
11:05:18 <monochrom> Use ===
11:05:19 <ski> that kind of day, ok
11:05:26 <erisco> yeah, I am reading how to program in Rust
11:05:37 <erisco> == \xs -> (((flip . foldr) . (const . const)) xs) xs -- the really fun step
11:05:50 * ski suggests using five dashes
11:06:07 <erisco> fun because (.) forms a Category and so it is associative
11:06:37 <monochrom> Nooooooo
11:06:55 <erisco> then the rest is obvious... my notes stop there :P
11:06:57 <monochrom> The causality is backwards. (.) is associative and so it forms a Category.
11:07:23 <erisco> hm, I don't know how I implied causality one way or the other
11:08:09 <erisco> A human is a mammal and so it does not lay eggs.
11:08:32 <tdammers> uhm
11:08:38 <tdammers> there are egg-laying mammals, you know
11:09:10 <erisco> well, my interest in biology stopped in about grade 8 :P
11:13:11 * hackagebot postgresql-query 3.3.0 – Sql interpolating quasiquote plus some kind of primitive ORM using it – https://hackage.haskell.org/package/postgresql-query
11:18:52 <erisco> also fun… const, const id, const (const id), const (const (const id)), …
11:19:03 <dmwit> ski: === is nice because = and == are common Haskell syntax but === isn't
11:19:17 <dmwit> (It is allowed syntax, but very uncommon.)
11:19:47 <jle`> sometimes i use ==>
11:20:00 <cocreature> hm do we have something in base for "if b then f x else x"?
11:20:06 <dmwit> :t bool
11:20:08 <lambdabot> a -> a -> Bool -> a
11:20:31 <cocreature> dmwit: not quite, I’m looking for something that abstracts over duplicating "x" in that expression
11:20:39 <dmwit> :t \f b -> foldr (.) id [f | b]
11:20:41 <lambdabot> (b -> b) -> Bool -> b -> b
11:20:51 <dmwit> is joke
11:20:52 <dmwit> do not use this
11:20:57 <cocreature> heh, I won’t :)
11:21:01 <jle`> fromMaybe x $ f x <$ guard b
11:21:08 <jle`> oh
11:21:13 <dmwit> :t \f -> bool id f
11:21:14 <lambdabot> (a -> a) -> Bool -> a -> a
11:21:17 <cocreature> it’s easy enough to write it myself, I just felt like I’ve encountered this significantly often that there might be something in base for this
11:21:19 <jle`> maybe x f (x <$ guard b)
11:21:29 <dmwit> cocreature: `bool id` seems pretty short.
11:21:44 <cocreature> dmwit: yeah I like that, thanks!
11:21:53 <jle`> i find bool pretty unreadable in general because i always have to think about which constructor is first
11:21:58 <jle`> since it's the opposite of if/then/else
11:22:11 <jle`> and "the" ternary operator from other languages
11:22:12 <dmwit> There is that.
11:22:21 <erisco> also,  (const . const) id = const . const id
11:22:37 <jle`> i understand that it is how it is to be consistent with maybe/either
11:23:50 <jle`> and also foldr too i suppose
11:24:07 <jle`> weird that Nil is typically considered the second constructor
11:24:11 <dmwit> List *all* the catamorphisms!
11:24:41 <dmwit> uncurry! (or curry? who can remember which way they go)
11:24:42 <jle`> actually does ghc actually order the constructors?
11:24:43 <monochrom> "forall a. a -> a -> a" \∩/
11:25:01 <jle`> hm Nil should actualyl really be the first constructor
11:25:04 <dmwit> jle`: Well, `unsafeCoerce` is a thing. So, yes?
11:25:10 <monochrom> GHC goes with the order in the data declaration.
11:25:13 <int-e> jle`: consider `deriving Ord`
11:25:15 <jle`> because then the automatically derived Ord instance would be correct
11:25:21 <jle`> yea
11:25:31 <jle`> so then the arguments to foldr should be flipped
11:25:33 <dmwit> % unsafeCoerce Nothing :: [Int]
11:25:34 <yahb> dmwit: []
11:25:37 <dmwit> \o/
11:25:44 <erisco> could you spend a whole day playing with const and id? probably
11:26:01 <jle`> foldr is a lie
11:26:04 <dmwit> agreed
11:26:07 <monochrom> So for example if you have "data X = C | D" then when you write a term like "case x of D -> ...; C -> ..." GHC will re-order your term to "case x of C -> ...; D -> ..."
11:26:33 <jle`> i jusn't sure if data [a] = [] | a:[a] was actually written in base or was internally defined
11:26:45 <int-e> jle`: would you prefer to call it foldw instead of foldr? ("wong" instead of "right" ;-) )
11:27:02 <monochrom> So for example in Data.Map source code you actually see a comment on why they wrote their data declaration in the order they chose.
11:27:16 <jle`> neat
11:27:47 <jle`> int-e: foldw is taken by foldwombo
11:28:24 <ski> dmwit : fwiw, i like `=' *because* it is common Haskell syntax
11:29:27 <ski> (namely that defining equations, under some caeats, are *supposed* to represent valid equalities in the language)
11:29:45 <dmwit> I think there is a place for beginning with unambiguous rules/syntax and moving to concise syntax once there is enough experience for the reader to disambiguate on their own.
11:29:47 <monochrom> A certain clause forces "data [] a = [] | a : [] a" to be unexpressible in base. Because : is a reserved word.
11:30:02 <monochrom> Err, a certain clause in the Haskell Report!
11:30:16 <jle`> a legally binding clause
11:30:47 <dmwit> (Relatedly: when I am teaching the rules of go, I teach area scoring instead of territory scoring, even though territory scoring is by far more popular in the US and generally quicker to do. This is because there are several rule ambiguities that simply don't arise in area scoring. If the player comes back a few times, then I can show territory scoring as a shortcut and it makes immediate sense, and the question of how to resolve the ambiguities
11:32:41 <erisco> put (.) in there too and you can project any argument you want
11:33:23 <dmwit> ?pl \a b c d e f g -> d
11:33:24 <lambdabot> const (const (const (const . const . const)))
11:33:44 <dmwit> ?pl \a b c d e f -> d e a d b e e f
11:33:45 <lambdabot> (const .) . flip flip id . ((flip . (ap .)) .) . flip flip id . ((flip . (ap .)) .) . flip . (flip .) . join . (flip .) . flip flip
11:33:53 <dmwit> ?botsnack
11:33:53 <lambdabot> :)
11:34:07 <erisco> well that wasn't a projection, lol, but nice
11:41:18 <dmwit> hm
11:41:26 <dmwit> % putStrLn "\1588\1587"
11:41:26 <yahb> dmwit: شس
11:41:57 <dmwit> I guess it's probably up to my terminal whether that displays in the right order or not.
11:43:42 <erisco> :t let l = const; r = (.) const; done = id in (l . l . l . r . r) done
11:43:43 <lambdabot> b1 -> b2 -> b3 -> a -> b4 -> b5 -> a
11:43:56 <erisco> drop three arguments on the left, two on the right
11:46:03 <mniip> % putStrLn "\1588" >> putStrLn "\1587"
11:46:04 <yahb> mniip: ش; س
11:46:15 <mniip> ahh the ; got RTLd
11:47:39 * hackagebot byteunits 0.3.0.2 – Human friendly conversion between byte units (KB, MB, GB...) – https://hackage.haskell.org/package/byteunits
12:28:07 <presci00> Hi how can i define a function that takes char array and set of char as input
12:28:30 <erisco> f charArray charSet = ...
12:28:40 <ski> what is the problem you're having, more specifically ?
12:30:14 <presci00> func :: (Char a) => [a] -> (Set a) -> Bool
12:30:21 <ski> (dmwit : fwiw, cut off near ".., and the question of how to resolve the ambiguities")
12:30:30 <ski> presci00 : `Char' is a type, not a type class
12:30:41 <ski> `(Char a) =>' makes no sense
12:30:58 <presci00> Yeah i figured that out
12:30:59 <ski> how about `func :: [Char] -> Set Char -> Bool' ?
12:31:08 <ski> (btw, that's a list, not an array)
12:31:49 <presci00> Yeah i want to write a function if the list of char is instance of palindrome
12:32:35 <presci00> Thanks ski let me try it
12:33:10 <cocreature> why do you need a Set of Chars to check if a list of chars is a palindrome?
12:33:19 <erisco> palindrome season…
12:33:28 <erisco> I guess because it is September?
12:33:33 <erisco> October*
12:33:42 <prg318> Is there a standard function like "cycle" that takes a single thing instead of a list of things?
12:33:48 <prg318> sort of like unix "yes" ?
12:34:04 <cocreature> :t repeat
12:34:05 <lambdabot> a -> [a]
12:34:08 <cocreature> ^ prg318 
12:34:12 <prg318> thanks cocreature !!! :D
12:34:22 <prg318> awesome
12:35:11 <presci00> The chars can be random not necessarily palindrome
12:35:51 <presci00> Have to check if it can be a palindrome
12:35:59 <cocreature> sure if they were always a palindrome, checking that they are a palindrome is a bit redundant. but I’m still not sure what you need the Set for
12:37:08 <presci00> "Tacooacts" is a instance of palindrome
12:37:31 <presci00> The chars  are random
12:37:48 <erisco> that doesn't look like a palindrome
12:37:57 <nshepperd> you're talking about a string that is an anagram (permutation) of a palindrome
12:38:07 <presci00> No it isnt a palindrome
12:38:35 <presci00> We have to find if it is char would make a palindrome
12:38:45 <presci00> Chars*
12:39:52 <presci00> So we take out the duplicate chars and at the end the size of list should either be 1 or 0
12:40:19 <presci00> That would make it instance of palindrome
12:42:55 <monochrom> Where can I read the original verbatim unabrideged unbutchered question?
12:42:57 <erisco> is it that you have to determine if a string is an anagram of a palindrome?
12:43:22 <erisco> the whole cow, please
12:43:59 <mniip> that sounds like (< 2) . filter odd . map length . group . sort
12:44:38 <monochrom> Yeah.
12:44:49 <cocreature> that doesn’t sound like a palindrome check
12:44:59 <mniip> anagram of palindrome tho
12:45:08 <monochrom> But with students always permuting the letters in the original question, you never know.
12:45:18 <monochrom> (Yes, pun intended!)
12:45:27 <monochrom> (Semantic pun :) )
12:45:29 <lyxia> @where xy
12:45:30 <lambdabot> http://xyproblem.info/
12:45:31 <nshepperd> mniip: you missed a length
12:45:38 <mniip> yes
12:45:59 <nshepperd> i guess "sounds like" is accurate :)
12:46:02 <mniip> lyxia, you literally have xy in your name
12:46:06 <mniip> (anagram intended)
12:46:29 <mniip> heh
12:46:33 <mniip> (palindrome intended)
12:46:46 <cocreature> (anagram of palindrome intended)
12:46:47 <erisco> that is what I thought of too, and it is clear that given at most one odd count how you can construct a palindrome
12:47:25 <presci00> http://www.geeksforgeeks.org/check-characters-given-string-can-rearranged-form-palindrome/
12:47:35 * ski . o O ( "anagramme, catagramme" )
12:47:52 <erisco> is it as clear that all palindromes have at most one odd count, though? have to think carefully how to construct palindromes
12:48:08 <mniip> ski, histogram?
12:48:25 <mniip> zygohistogrammic preprogram
12:48:46 <mniip> greek is crazy
12:48:59 <ski> @wn zygo
12:49:00 <lambdabot> No match for "zygo".
12:49:37 <presci00> So my solution is to create the set, add if the char is not in the set , delete if exist. And check the size of the set if it is more than 2 return false or return true
12:49:54 <lyxia> mniip: :)
12:50:10 <mniip> ζῠγόν • (zugón): in general, anything which joins two pieces together: cross-bar, plank, beam
12:50:41 <mnoonan> presci00, it seems like you're describing a helper function with type "helper :: Char -> Set Char -> Set Char" there
12:50:41 <monochrom> Oh neat, now we can pronounce <> as zugon.
12:51:03 <monochrom> And monoid homomorphism can be renamed as zugonmorphism.
12:51:18 <mniip> monochrom, the correct latinization already in use is zygo-
12:51:37 <erisco> ε is a palindrome (empty string). Any letter is a palindrome. If A and B are palindromes, then ABA is a palindrome.
12:52:09 <mniip> erisco, do I sense a recursviely enumerable language
12:52:43 <presci00> import Data.Set (Set)
12:52:43 <presci00> import qualified Data.Set as Set
12:52:44 <presci00> ispalindrome :: [Char] -> (Set Char) -> Bool
12:52:44 <presci00> ispalindrome [] x
12:52:44 <presci00> | Set.size x > 1 = False
12:52:44 <presci00> | otherwise = True
12:52:44 <presci00> ispalindrome (x:xs) Set.empty =
12:52:45 <presci00> ispalindrome xs (Set.fromList [x])
12:52:45 <presci00> ispalindrome (x:xs) g
12:52:46 <presci00> | Set.member x g = ispalindrome xs (Set.delete x g)
12:52:46 <presci00> | otherwise = ispalindrome xs (Set.insert x g)
12:53:17 <erisco> presci00, next time, use lpaste.net please
12:53:38 <mniip> is Set.empty a pattern
12:53:54 <monochrom> erisco: Wait a second, I don't think you want ABA to be a palindrome.
12:53:56 <nshepperd> erisco: any palindrome is either ε, a letter x, or xAx for some palindrome A
12:54:16 <erisco> monochrom, no? is that a goof? seems okay
12:54:21 <monochrom> Yeah what nshepperd said.
12:54:45 <monochrom> Ah OK I see.
12:55:02 <erisco> I was aware of that option but this one seemed more interesting :P
12:55:05 <nshepperd> the ABA rule is also valid but results in an ambiguous parse
12:55:13 <erisco> parse? who's parsing? :P
12:55:29 <presci00> Sorry about that
12:55:43 <nshepperd> someone, somewhere, always parsing, always watching
12:56:32 <mniip> :t foldr (liftA2 . (==)) (const False)
12:56:32 <presci00> http://lpaste.net/358902
12:56:34 <lambdabot> error:
12:56:34 <lambdabot>     • Couldn't match type ‘Bool’ with ‘b -> c’
12:56:34 <lambdabot>       Expected type: f c -> f c -> b -> c
12:56:45 <mniip> :t foldr (liftA2 xor . (==)) (const False)
12:56:46 <lambdabot> (Eq a, Foldable t) => t a -> a -> Bool
12:57:21 <mniip> getting a count out of (a -> Bool) sounds problematic
12:58:11 <presci00> Not able to match Set.empty
12:58:38 <tsani> I had this palindrome anagram problem in an interview last week. I solved it used a histogram (mod 2) of the letters.
12:59:03 <mniip> ha!
12:59:07 <mniip> histo-gram
12:59:10 <mniip> get it
13:01:22 <mniip> :t (<2) . M.size . foldr (M.alter (maybe (Just ()) (const Nothing))) M.empty
13:01:23 <lambdabot> (Ord k, Foldable t) => t k -> Bool
13:02:16 <tsani> there's an extra consideration for the length of the input string: if it's odd then one of the counts must be odd; else all counts must be even.
13:02:46 <mniip> tsani, not sure if that's supposed to help anyhow
13:02:58 * ski . o O ( "Because it contains ζῠγόλ, verily the worst enemy of bacteria." )
13:02:59 * tsani shrugs
13:04:29 <tsani> mniip: I was talking generally, not in response to your latest code. I'll admit to not really following what your latest program does.
13:04:59 <mniip> tsani, it stores the histogram mod 2 as keys in a Map Char ()
13:05:10 <mniip> using alter to simultaneously add and remove keys
13:07:36 <recursion-ninja> I'm tryiong to build something with `cabal` and it fails in the linker phase but doesn't tell be with what command it invoked the linker. How do I make it output the linker command that failed?
13:08:05 <erisco> let |S| be the number of odd counts in the string S. For all strings A, B, |AB| = |BA| and |AA| = 0, and if |A| = 0 then |AB| = |B|
13:08:36 <foobar_> hello, why this function doesn't terminate: http://lpaste.net/7044103818388176896
13:09:18 <monochrom> recursion-ninja: Add -v
13:09:27 <erisco> hm, need something else…
13:09:57 <lyxia> foobar_: let (x, d) = divMod x 10 in   ....   <- x is defined recursively here
13:10:18 <foobar_> lyxia: this works in ML
13:10:25 <lyxia> you want    let (x', d) = ...   or let (_, d) = ...
13:10:27 <lyxia> Haskell is no ML
13:10:38 <presci00> http://lpaste.net/3511536313130024960 found the solution, thanks guys
13:10:38 <geekosaur> ML isn;t lazy and you need 'let rec' to get that behavior
13:10:39 <monochrom> ML's "let" is different.
13:10:51 <lyxia> all lets are recursive in Haskell
13:11:02 <erisco> I need stronger swapping than the sort of commutativity thing there
13:11:02 <foobar_> lyxia how can i get non-recursive let?
13:11:10 <monochrom> There is none.
13:11:14 <jared-w> Don't use let, then it's not recursive ;)
13:11:16 <erisco> for all strings A B C D, |ABCD| = |ACBD|
13:11:22 <recursion-ninja> monochrom: Thanks for the suggestion, but neither the -v flag nor the --verbose=3 flag output the linker command that was invoked.
13:11:24 <foobar_> i thought default recursive lets are a bad idea ..
13:11:44 <jared-w> Nah they're a great idea. Extending a lambda calculi with the letrec primitive enables a lot of optimizations
13:12:00 <monochrom> Maybe a bad idea in ML, sure.
13:12:02 <ski> > let ?x = 0 in let ?x = ?x + 1 in ?x
13:12:04 <lambdabot>  1
13:12:08 * ski whistles innocently
13:12:19 <jared-w> Then since normal let is also needed to be a primitive for efficiency or constructed natively in LC... Well, no point in having a non recursive let in a lazy language, tbh
13:12:21 <erisco> then for palindromes we get to |ABA| = |AAB| (by swapping), |AAB| = |B| (by |AA| = 0), and by the inductive hypothesis |B| < 2
13:12:27 <geekosaur> in a strict language it's generally a terrible idea. in a lazy one it can be very useful 
13:12:53 <lyxia> foobar_: I personally agree, but it is what it is...
13:12:53 <presci00> Yes erisco
13:13:05 <erisco> so, |ABA| < 2
13:13:17 <monochrom> Or maybe you're just taken in by someone who made "recursive let is a bad idea" a religious thing.
13:13:30 <presci00> Yes
13:13:31 <jared-w> > fst $ divMod 10 25
13:13:34 <lambdabot>  0
13:13:39 <monochrom> err, add "default" there, obviously.
13:13:59 <ski> > snd (divMod 10 0)  -- :/
13:14:01 <lambdabot>  *Exception: divide by zero
13:14:03 <erisco> now we can go prove these theorems in Coq :P
13:14:09 <presci00> (presci00) http://www.geeksforgeeks.org/check-characters-given-string-can-rearranged-form-palindrome/
13:14:10 <foobar_> monochrom: i shouldn't have to need a new name there
13:14:24 <monochrom> Why are you arguing?
13:14:58 <jared-w> foobar_: Why do you need a new name when you can just write the function slightly differently?
13:15:01 <foobar_> monochrom: you just claimed it's religious thing
13:16:01 <EvanR> hardcopy of The Blind Spot: Lectures on Logic by Girard just came in
13:16:02 <ski> > let tensDigit x = head [d | (x,d) <- [divMod x 10]] in [tensDigit x | x <- [0 .. 19]]
13:16:04 <lambdabot>  [0,1,2,3,4,5,6,7,8,9,0,1,2,3,4,5,6,7,8,9]
13:16:25 <mnoonan> I understand why, but from 10,000' it is a little funny that lets are recursive by default and binds aren't, e.g.
13:16:27 <ski> foobar_ : if you really want to shadow `x', you can use `do', or a list comprehension
13:16:32 <mnoonan> let f = \x -> do { x <- return (length x); print x } in f [1,1,1]
13:16:43 <mnoonan> > let f = \x -> do { x <- return (length x); print x } in f [1,1,1]
13:16:45 <lambdabot>  <IO ()>
13:17:12 <mnoonan> :|
13:18:15 <ski> > let f = \x -> do { x <- return (length x); tell [x] } in f [1,1,1]  :: Writer [Int] ()
13:18:18 <lambdabot>  WriterT (Identity ((),[3]))
13:18:34 <monochrom> Actually I see all kinds of people making all kinds of mistakes caused by having multiple different things having the same name to confuse themselves.
13:19:20 <monochrom> If you favourite language allows it, I still wouldn't recommend counting on it.
13:20:16 <ski> > let ?x = 0; ?x = ?x + 1 in ?x  -- whoops
13:20:18 <lambdabot>  mueval-core: internal error: PAP object entered!
13:20:19 <lambdabot>      (GHC version 8.2.1 for x86_64_unknown_linux)
13:20:19 <lambdabot>      Please report this as a GHC bug:  http://www.haskell.org/ghc/reportabug
13:20:22 <monochrom> If you have one "x" that refers to 5 and another "x" that refers to 6 and they are close together, it is just disaster waiting to happen. Even when --- or rather, esepcially when --- the 6 is obtained from 5+1.
13:20:54 <monochrom> Oh I'm pretty sure at the time of writing it made great sense to you to call them both "x".
13:21:24 * ski is a bit intrigued by Mercury's "state variable" notation
13:21:30 <monochrom> That's the defining criterion of write-only code. Made perfect sense at the time of writing only.
13:22:23 <mniip> monochrom, ha!
13:22:24 <mniip> x'
13:22:51 <mniip> ski, huh curious
13:22:52 <isBEKaml> hey guys, is parsec still the recommended way of using parser combinators? Or is Megaparsec the way to go?
13:22:52 <ski> if you pass `!X' as an argument to a procedure (a predicate), that amounts to passing two parameters, the previous and the next "version" of `X' (both being immutable). typically the former would be an input parameter, wbhile the latter would be an output parameter
13:23:09 <mniip> % let ?x = 0; ?x = ?x + 1 in ?x
13:23:09 <yahb> mniip: ; <interactive>:6:1: error:; * Unbound implicit parameter (?x::Integer) arising from a use of `it'; * In the first argument of `print', namely `it'; In a stmt of an interactive GHCi command: print it
13:23:27 <dmwit> > all not $ M.fromListWith (/=) [(c, True) | c <- "abcabc"]
13:23:28 <erisco> now to define the function  f : |s| < 2 -> Palindrome s
13:23:29 <lambdabot>  True
13:23:50 <ski> so, if you say `foo(!X),bar(!X)', this conceptually involves three different variables. this corresponds to the explicit `foo(X0,X1),bar(X1,X2)', where presumably `X1' is computed from `X0' and `X2' from `X1'
13:23:52 <mniip> dmwit, woah
13:24:27 <dmwit> (/=) is addition mod 2. ;-)
13:24:29 <foobar_> monochrom: having two bindings of the same thing in environment instead of one is just a disaster waiting to happen not the other way around
13:24:45 <foobar_> same as in derived from the same thing
13:24:59 <shapr> what's the best Haskell cabbage for protobuf3 ?
13:25:16 <dmwit> ?remember shapr what's the best Haskell cabbage?
13:25:16 <lambdabot> Okay.
13:25:21 <foobar_> shadowing makes perfect sense in those cases.
13:25:23 <shapr> :-)
13:25:23 <ski> so, when you see a variable name prefixed by a `!', you know that this corresponds to a sequence of versions (values) being associated (lexically) with `X' .. of course, `X' can't "change" without you explicitly passing `!X' to a procedure
13:25:31 <shapr> dmwit: cabal package -> cabbage, right?
13:25:39 <dmwit> love it!
13:25:50 <dmwit> shapr: To be honest, I'm a bit surprised there's more than one cabbage for protobuf3.
13:26:56 <shapr> I can't tell if they're all protobuf2 or not
13:26:56 <ski> foobar_ : hm, you mean as in potential space-leak ?
13:27:08 <isBEKaml> they are all proto2, as far as I can see
13:27:11 <erisco> dmwit is using the famous xor trick
13:27:24 <foobar_> ski: i mean not accidentally using the old value x instead of x'
13:27:26 <isBEKaml> but protobuf *might* be compatible with proto3
13:27:33 <sm> heh. And on stackage, it's a.. stabbage ?
13:27:40 <isBEKaml> https://github.com/alphaHeavy/protobuf *not sure at all*
13:27:49 <shapr> yeah, last update a year ago
13:28:11 <foobar_> anyway it probably makes sense in lazy language; off to dig more
13:28:29 <ski> foobar_ : i suppose the standard way, at least in more involved situations, to handle this in Haskell would be to use a state monad to hide the progression of versions
13:30:02 <erisco> given a list of integers where all integers in the list occur an even number of times, except one, find the exception in memory proportional to the integer width in time proportional to the list length.
13:30:09 * ski is also reminded of some attribute grammar systems, which allow threaded-state attributes
13:31:01 <erisco> I guess time is more like m*n for integer width and list length, but w/e
13:31:18 <erisco> original question as I saw it asked was limited to 32 bit
13:31:19 <dmwit> :t foldr xor 0
13:31:20 <lambdabot> (Num b, Bits b, Foldable t) => t b -> b
13:31:37 * nshepperd discovered some old python code for generating haikus that are also palindromes
13:31:59 <nshepperd> only 50% sure I understand how it works
13:32:01 <erisco> and what is neat is that, if you look at the properties of xor (and I forget exactly what it falls into) there is an operation of sets you can define with the same properties
13:32:15 <dmwit> Is there a `foldWhichever` that lets the `Foldable` implementation decide which way is more efficient?
13:32:16 <erisco> only, if you use the set operation, you find all odd occurring elements
13:33:34 <erisco> oh yeah, it is just the xor of sets, (A∪B)\(B∩A)
13:33:54 <nshepperd> symmetric set difference
13:34:09 <erisco> any idea what abstract algebra that falls into?
13:34:31 <erisco> every object is its own inverse
13:34:40 <monochrom> The boolean ring uses xor for + and intersection for *
13:34:52 <monochrom> involution?
13:35:00 <recursion-ninja> bye
13:35:54 <erisco> so we just need an identity, a binary operator, and every object is its own inverse
13:36:02 <erisco> an associative binary operator
13:36:17 <dmwit> For your proposed applications, it also matters that it is commutative.
13:36:32 <erisco> you are right! commutative too
13:37:10 <erisco> so, something a bit more than an Abelian group
13:37:33 <dmwit> Sets with symmetric difference is the free such structure.
13:37:46 <dmwit> So there shouldn't be all that many interesting ones, really.
13:37:46 <erisco> neato
13:40:58 * dgpratt wonders if explicit type annotations for top-level definitions would fall out of favor if/when code editors capable of displaying inferred types become available/commonplace
13:41:37 <orzo> Suppose I build without -threaded.  It's my understanding that a blocking FFI call will block all haskell threads.  Is this true of both forkIO and forkOS ?
13:41:54 <merijn> orzo: FFI calls, by default, happen in a separate thread
13:42:20 <orzo> so they don't block haskell threads?
13:42:24 <merijn> orzo: Even the non-threaded runtime uses multiple threads
13:42:28 <merijn> orzo: Yes
13:43:00 <merijn> orzo: Unless you do an unsafe foreign import your foreign calls won't block Haskell threads
13:43:02 <orzo> is my understanding out of date or it never was this way?
13:43:25 <merijn> orzo: It hasn't been that way in at least a decade, maybe longer
13:43:43 <cocreature> I don’t think that’s true for bound threads
13:44:18 <merijn> cocreature: What is?
13:44:24 <monochrom> I don't believe it. I'm going to do an experiment. Any good FFI call I should try it on?
13:44:29 <cocreature> that ffi calls are run in separate threads
13:45:48 <orzo> unistd.h sleep()
13:45:50 <erisco> dgpratt, ultimately, if we can get out of the stone age of text files, it would be an irrelevant distinction
13:46:08 <merijn> cocreature: the RTS document and ezyang's blog mention foreign calls running in separate threads from Haskell code. I imagine (with bound threads, etc.) that the *real* logic is "capability gets released, then foreign call is made" and one of the "foreign call threads" picks up the now idle capability
13:46:36 <erisco> dgpratt, because if TLTDs are helpful to the compiler then they can be inserted automatically and the programmer can choose to see them or not
13:47:09 <orzo> monochrom: I await your results, unistd.h sleep() is a good choice
13:47:11 <erisco> code folding is the primordial ooze from which this kind of feature may evolve
13:48:21 <monochrom> Yeah, writing code now.
13:48:32 <dgpratt> erisco: are you thinking of something along the lines of http://www.lamdu.org/ ? I quite like that project, at least in concept, but for some reason the UX looks/feels a bit awkward to me (probably just something that requires getting used to)
13:48:47 <merijn> monochrom: So, I'm not sure enough to claim the foreign call gets run from a different thread, just that the RTS keep a pool of additional threads for making foreign calls and that foreign calls don't block Haskell execution (unless done unsafely)
13:48:53 <monochrom> Gosh, it's "foreign import" not "import foreign" haha
13:49:12 <shapr> I wish I could find protobuf3 support without having to write it myself.
13:49:25 <shapr> where do I send money to get libraries written?
13:49:31 <monochrom> BTW for those who're critiquing error messages: "parse error on input 'foreign'" that's it.
13:49:32 <erisco> thanks for reminding me the name of it… projectional editing has been an idea for a long time, dgpratt, and it has not worked yet
13:49:40 <merijn> monochrom: I imagine it could also be like I said above, foreign call happens in the current OS thread, but capability gets yielded and picked up by one of the threads in the foreign call pool
13:49:51 <merijn> shapr: Here
13:49:58 <cocreature> monochrom: I actually tried fixing that error message a while back and it’s annoyingly hard to fix.
13:50:01 <monochrom> Aw I hate whoever decided that forkIO wants IO().
13:50:10 <merijn> shapr: Although I require a rather big amount of money
13:50:26 <ski> monochrom : rather than ?
13:50:26 <shapr> hm
13:50:38 <merijn> ski: IO a
13:50:50 <ski> oh
13:51:24 * ski thinks `Data.Functor.void' ought to be renamed ..
13:51:34 <mniip> it would be cool if forkIO was IO a -> IO (IO a)
13:51:38 <shapr> Data.Functor.abyss ?
13:51:46 <mniip> then you could join the thread with, wait for it,
13:51:47 <mniip> join!
13:51:51 <ski> or `ignore' (as in SML, iirc)
13:52:10 <ski> imho using the name "void" for this should be relegated to the FFI modules, if used at all
13:52:15 <monochrom> Hahaha shapr wins.
13:52:22 <orzo> a actually wish forkIO took a String label equivelent to running labelThread on the returned ThreadId
13:52:25 <ski> (i also want `void' as a synonym for `absurd')
13:52:27 <erisco> dgpratt, I think, just using better parsing technology (better error recovery) you can keep the comfort of the textual interface and benefit from non-textual representations
13:52:36 <orzo> I'd rather label all the forks
13:54:05 <monochrom> http://lpaste.net/358903
13:54:33 <merijn> orzo: Define a forkIO wrapper that includes labelThread?
13:55:17 <orzo> pretty much, yeah
13:55:44 <orzo> but you could tell monochrome to implement a wrapper to remove the IO () restriction
13:55:51 <orzo> we were nitpicking forkIO interface
13:55:51 <merijn> Control.Concurrent is really just low level primitives, intended to be wrapped by higher level libraries, tbh
13:56:04 <merijn> (like async)
13:56:16 <monochrom> Please reload. New edit for forkOS, funny must-read!
13:56:38 <erisco> editing ASTs is largely a convenience for the editor, not for the programmer, and that is certainly an opinion
13:57:16 <monochrom> OK anyway so the sleep() call is interrupted.
13:57:40 <dgpratt> we just implemented Prettier -- my impression is these auto-formatting tools are becoming a lot more practical/popular and it seems like one less reason to use a text-based editor (can't even control the format/layout of the code)
13:58:44 <isBEKaml> dgpratt: is this coming from Go/Rust circles?
13:58:50 <erisco> it is just the malleability of editing text, not about the final product
13:59:10 <monochrom> OK I'm going to write a ridiculously exponential time fibonacci thing in C and see what happens.
13:59:24 <dgpratt> isBEKaml: not sure, but I first heard about this type of tool being widely adopted for Go
13:59:27 <erisco> when you're being shown a purely textual representation of an AST it is not so intuitive
14:00:01 <erisco> Lamdu, iirc, improves this by showing boxes to signify AST nodes
14:00:41 <puregreen> can anyone help me with Esqueleto? I'm simply trying to get the ID of the i-th row but I'm getting a bunch of errors. A piece of code and the errors are here: http://lpaste.net/8739795583029477376
14:00:47 <monochrom> BTW C style war: Should I write "unsigned fib(unsigned n) {" or should I put the "{" on the next line? >:)
14:00:51 <erisco> but, you start doing that and you discover there is a lot of visual pain in something simple like  1 + 2 * 3 / 4 ** 5
14:00:56 <orzo> why would sleep be interrupted?  That's not anything like what I expected
14:01:08 <ski> monochrom, yes
14:01:29 <hexagoxel> monochrom: prefix the semicolons, too!
14:01:37 <erisco> and the projectional editing I have seen has made exceptions so expressions such as those can be edited as text
14:01:48 <monochrom> Oh God I forgot how to write C. Almost just wrote "if n==0 then"
14:02:07 <shloub> don't forget the fi
14:02:29 <orzo> heh
14:02:32 * ski knows some people, to the annoyance of other people, inserts space before the function call open bracket, in C
14:02:38 <monochrom> No, screw "if".  n <= 1 ? n : fib(n-1) + fib(n-2)
14:03:26 * hexagoxel thought he would evade the arch linking stupidity by using a cabal sandbox and -w to a manually installed ghc - apparently not.
14:03:57 <monochrom> OK it hangs.
14:04:14 <monochrom> OK it doesn't even respond to ctrl-c now.
14:04:28 <monochrom> OK second ctrl-c kills it
14:04:47 <orzo> your test is very strange to me, monochrome.  Not only does the sleep() call stop with "9 seconds to go" but it does so immediately, so it exhausts the first second instantly.  I guess it rounded the elapsed time upward?
14:05:04 <monochrom> Yeah.
14:05:40 <monochrom> See also "man 3 sleep". It responds to signals. So the RTS may have set up some periodic alarm signal that sleep saw and stopped.
14:05:55 <dancek> Hi! I'm a newbie and can't find a nice idiom for filtering only specific type of data from a list and extracting it. Can anyone recommend something better than this? e.g.  (\(AInstr (ARef x)) -> x) <$> filter (\case (AInstr (ARef _)) -> True; _ -> False) prog
14:06:08 <orzo> so you have a new version now?
14:06:14 <isBEKaml> dgpratt: Yeah, Go started it with a very opinionated formatter. Rust followed it saying "a lot of people seem to want it" 
14:06:23 <isBEKaml> There's rustfmt, I guess.
14:06:34 <c_wraith> @src catMaybes
14:06:34 <lambdabot> catMaybes ls = [x | Just x <- ls]
14:06:35 <orzo> did you prove merijn wrong?
14:06:49 <mniip> yeah RTS uses plenty of signals
14:06:50 <c_wraith> dancek, ^ regarding catMaybes
14:06:50 <isBEKaml> dgpratt: https://github.com/rust-lang-nursery/rustfmt
14:07:06 <orzo> is it documted what signals it uses?
14:07:31 <monochrom> http://lpaste.net/358903#a358905
14:07:32 <mniip> something like SIGVTALRM for periodic GC ticks or something
14:08:04 <mniip> maybe more
14:08:06 <dancek> c_wraith: I don't understand how I could use catMaybes here, though I'm familiar with the function.
14:08:23 <c_wraith> dancek, no, I meant take inspiration from its implementation
14:08:29 <mniip> I've had plenty of "fun" with that in yahb's sandbox
14:08:31 <orzo> monochrom: is the the right URL? I don't see a change
14:08:34 <puregreen> dancek: [x | AInstr (ARef x) <- prog]
14:08:34 <monochrom> SIGVTALRM, but do use strace to check it
14:08:43 <monochrom> Scroll down
14:08:45 <c_wraith> dancek, if the pattern match fails, it goes to the next element
14:08:55 <dancek> ah, the moment of enlightenment. Thank you c_wraith and puregreen!
14:08:56 <erisco> dgpratt, it is tough because to have really good error recovery the parser has to incorporate semantic analysis
14:09:34 <erisco> dgpratt, by "error recovery" I am largely referring to incomplete code, as that is the program looks like most often as we're typing it in
14:09:40 <monochrom> You should be able to see "fib 100" and some simple C code in the comments.
14:10:29 <orzo> monochrom: your annotation is not showing for me
14:10:47 <erisco> if you are looking at  f x  is this the beginning of a function declaration, so it will look like  f x = ...  or is it just a function application expression?
14:10:54 <monochrom> OK maybe http://lpaste.net/358905 alone?
14:11:29 <erisco> that is just one example of how to get tripped up … and a possible resolution is to use semantics to realise that f and x are in scope, so this is probably application and not the start of a declaration
14:11:31 <orzo> damn, maybe i need to enable some javascript
14:11:54 <hexagoxel> "Failed to install fail-4.9.0.0" he he he  .. :(
14:12:14 <orzo> oh i have it now
14:12:26 <monochrom> Naw even wget and see it :)
14:15:39 <orzo> is there a bot to share this your paste with merijn when he returns?  He seems badly misinformed.
14:16:12 <monochrom> Yeah lambdabot can take messages.
14:16:37 <lyxia>  @tell user your message
14:16:38 <monochrom> @tell merijn http://lpaste.net/358905
14:16:38 <lambdabot> Consider it noted.
14:17:15 <ski> (there's also `/msg MemoServ send someone message ..')
14:18:17 <jared-w> But @tell is way more convenient :p
14:19:19 <tinytusk> Hi. I am writing a function to consume input from a Handle, line by line, until a specific string is found. If I make this recursive, will I blow up the call stack?
14:19:23 <ski> it has the advantage of (possibly) being public, and (iirc) notifying on activity
14:19:30 <tinytusk> (eventually)
14:20:05 <ski> tinytusk : is this `IO' ?
14:21:12 <monochrom> Better show actual code.
14:21:28 <ski> @paste
14:21:28 <lambdabot> Haskell pastebin: http://lpaste.net/
14:26:22 <tinytusk> monochrom / ski: http://lpaste.net/3962520394744725504
14:27:25 <monochrom> This one is most likely to use O(1) stack space.
14:27:27 <ski> tinytusk : depends on what `m' is exactly, when you call this
14:27:36 <tinytusk> IO
14:27:44 <ski> then it's ok
14:27:51 <monochrom> But yeah with m being abstract I can't be 100% sure.
14:28:05 <ski> (but not necessarily if it's something wrapping `IO')
14:28:38 <tinytusk> Given any Monad, what properties am I searching for that will allow me to evaluate whether or not it will blow up?
14:29:06 <monochrom> The actual implementation of that monad.
14:29:07 <tinytusk> s/am I searching/should I search
14:29:39 <jared-w> monochrom: well yeah, but what's magical about the implementation of IO that makes it okay and likely to use O(1) stack space vs other monads?
14:29:47 <tinytusk> Ok, what *is* it about IO that makes it fine?
14:29:57 <monochrom> Except for IO. Too much GHC internal code to read. Just assume that IO is like Scheme.
14:30:06 <jared-w> lol
14:30:18 <monochrom> But if you have StateT and stuff then read the source code of StateT and stuff.
14:30:43 <monochrom> IO restores imperative programming.
14:30:55 <ski> tinytusk : instead of `[[_, uri]] -> maybe (consumeUntilURI handle) return (parseURI uri)', you could use `[[_,parseURI -> Just uri]] -> return uri'
14:31:03 <hexagoxel> (ah, it had nothing to do with the arch situation.. i think i run into ghc #12759)
14:31:06 <tinytusk> ski: Ha, nice catch.
14:31:19 <ski> (needs `ViewPatterns')
14:32:57 <tinytusk> If this function were modified so that it took an additional argument of type Int (consumeUntilURI :: Handle -> Int -> m URI), and that Int increased monotonically for each function call, would it still run in O(1)?
14:33:57 <ski> jared-w : `ReaderT r IO' or `StateT s IO' is also ok, e.g. .. but not `WriterT w IO' or `RWST r w s IO'
14:34:09 <monochrom> jared-w: So basically the compiler and the runtime system implement IO in a way that resembles what MLs and Scheme do. For example "TCO" is a thing once again. For example code order becomes effect order.
14:35:01 <ski> the issue, in the latter cases, is that the implementation of `(>>=)' ends not by calling the bind continuation, but by `return'
14:35:21 <monochrom> But of course, even IO's "return (repeat ())" is different from Scheme's. But I'm referring to >>=.
14:35:57 <ski> tinytusk : it would still run in constant *stack*, yes
14:36:31 <jared-w> gotcha, that makes sense
14:36:48 <monochrom> If you have "xxx n = print n >>= \_ -> xxx (n-1)" the "xxx (n-1)" is a tail call in the usual imperative sense because IO tries to give you back imperative programming.
14:36:56 <tinytusk> ski: Is there any small change I could make that would cause me to lose O(1)?
14:37:30 * ski thinks one ought not to think of it as an optimization .. but rather as a language property, mandating a certain (abstract) behaviour of implementations (as is the case in Scheme)
14:38:15 <ski> tinytusk : add something else (like a `return' call) after the recursive call, in a `do' (or when using `(>>=)')
14:38:32 <tinytusk> Ah! Makes sense now. Because then I can't use TCO.
14:38:49 <ski> because then the recursive call isn't a tail call
14:38:55 <ski> (scratch the "O")
14:39:55 * hackagebot light 0.2.0.1 – a simple physics engine – https://hackage.haskell.org/package/light
14:40:12 <tinytusk> Got it. Thanks!
14:41:26 <monochrom> But see http://lpaste.net/77374
14:42:06 <jared-w> ಠ_ಠ
14:42:15 <ski> note that in `loop x = blah x >>= \y -> loop (f x y)', the recursive `loop' call can be considered to be a tail call, depending on the monad used. e.g. if we assume `State s', then we really have `runState (loop x) s0 = let (a,s1) = runState (blah x) s0 in runState (loop (f x y)) s1', making the recursive call to `loop' (or at least this `runState'&`loop' combination) a tail call. remember that `runState' is a no-op
14:42:58 <ski> conceptually we think of something similar happening in the `IO' case, even though the details are too hairy to exhibit
14:44:03 <ski> (perhaps one should say "tail call modulo `(>>=)'", here ?)
14:44:40 * ski . o O ( "Tail Call Modulo Cons(tructor), TCMC" )
14:46:11 <monochrom> tail call w.r.t. >>=
14:46:28 <ski> hm, could be better english
14:46:59 <monochrom> Not to say that it has any significance until you actually know which monad it is.
14:47:39 * ski nods
14:48:06 <monochrom> And for many monads, i.e., the user-definable ones that don't use IO, it is insignificant. You expand it back to lambda calculus, then it's just lazy evaluation where tail call isn't the point.
14:48:17 <ski> what i meant was : tail-call modulo unfolding the particular definition of `(>>=)' that will be used
14:49:09 <ski> (not merely the position indicated by `<...>' in `... >>= \x -> <...>' .. which indeed is pretty useless, without knowing the particular monad being used)
14:49:36 <monochrom> Well yeah both State.Strict and State.Lazy unfold to tail calls. But they have opposite space costs and time costs.
14:49:39 <ski> well, tail calls are still relevant in by-need
14:50:01 <ski> a tail recursive loop must be bulky, can't be incremental
14:53:03 * hackagebot hpio 0.9.0.0 – Monads for GPIO in Haskell – https://hackage.haskell.org/package/hpio
14:55:54 <ski> monochrom : hmm .. how about `WriterT w Maybe' ?
14:58:52 <Ero> hi team
15:00:16 <Ero> when i run stack new or stack templates the process occupies the terminal  without returning anything
15:00:34 <Ero> i imagine it does the same for other commands too. --help works, though
15:02:34 <ski>   Control.Monad.Writer> execWriterT (let loop :: Integer -> WriterT [Integer] Maybe (); loop 0 = return (); loop i = tell [i] >>= \_ -> loop (i-1) in loop (10^8))
15:02:37 <ski>   *** Exception: stack overflow
15:02:50 <monochrom> ski: They both yield non-tail calls. The Lazy version uses heap now and stack later. The Strict version uses stack now.
15:02:58 <puregreen> Ero: both those commands query a list of templates from some git repo, afaik
15:03:12 <puregreen> if they can't connect to Github for some reason, they might block
15:03:16 <puregreen> do try other commands
15:04:19 <ski> monochrom : "they" being `State.Strict' vs. `State.Lazy' ?
15:04:43 <monochrom> Writer.Lazy and Writer.Strict
15:06:18 <ski> i was thinking this was a counter-example to "for many monads, i.e., the user-definable ones that don't use IO, it is insignificant. You expand it back to lambda calculus, then it's just lazy evaluation where tail call isn't the point."
15:07:26 <ski> (iow showing that (lack of) tail call is indeed the point here)
15:08:33 <jle`> Ero: what OS are you on?
15:09:12 <jle`> there are some issues with initializing the haskell runtime in the Windows linux bridge
15:10:09 * ski bewoes Voevodsky
15:12:28 <monochrom> Well OK, Maybe.
15:12:52 <ski> surely it would count as user-definable, no ?
15:13:06 <monochrom> Yes.
15:14:58 * ski . o O ( <https://en.wikipedia.org/wiki/Eros_operating_system> )
15:15:26 <Ero> jle`: im on parabola/arch
15:15:32 <Ero> linux
15:16:42 <angelingyawn> Question: I've tried to do a simple exploratory programme that uses ForkIO to dump messages to channels, but I've misapplied forever and my functions are only being invoked once rather than, well, forever. Can anyone see my oopsie? Code @ https://pastebin.mozilla.org/9069076
15:17:02 <jle`> angelingyawn: haskell runtime exits as soon as the main thread exits
15:17:21 <angelingyawn> I did a horrible getLine job to prevent that
15:17:25 <angelingyawn> I'm sure it's not the best approach
15:17:26 <jle`> so it'll exit after getLine >>= putStrLn is done
15:17:28 <jle`> ah i see
15:17:31 <angelingyawn> But I'll cross that bridge when I get there
15:17:50 <angelingyawn> I was actually under the impression that forkIO a `concurrently` forkIO b would stop that
15:17:56 <angelingyawn> But it didn't so I bodged it for now
15:18:11 <jle`> if you use concurrently i don't think you'd use forkIO
15:18:22 <jle`> concurrently handles that for you i believe
15:18:34 <jle`> the async library is kind of meant to abstract over raw usage of forkIO
15:19:14 <jle`> concurrently *would* return the results of both, but the results of forkIO x is a ThreadID
15:19:23 <jle`> so forkIO x returns immediately
15:19:26 <angelingyawn> Ah
15:19:29 <angelingyawn> That'd do it
15:19:56 <angelingyawn> How do I fix this? Use Control.Concurrent.Async.async instead?
15:20:17 <jle`> what part do you want to fix?
15:20:29 <jle`> just drop the forkIO and it should work
15:21:26 <angelingyawn> If I drop the forkIO don't I end up with two functions that will run until interrupted and only one thread to run them in?
15:21:51 <ski> <jle`> if you use concurrently i don't think you'd use forkIO  <jle`> concurrently handles that for you i believe
15:21:55 <angelingyawn> ...no I don't because they're combined into one action by concurrently
15:22:55 * hackagebot butcher 1.1.1.0 – Chops a command or program invocation into digestable pieces. – https://hackage.haskell.org/package/butcher
15:23:16 <Eduard_Munteanu> concurrently waits for the results of the two threads, no?
15:23:22 <angelingyawn> Yes
15:23:24 <angelingyawn> Well, nop
15:23:30 <angelingyawn> It waits for the results of two IO actions
15:23:36 <angelingyawn> They don't have to be threaded
15:24:22 <Eduard_Munteanu> They run concurrently, so I expect at least one extra thread is created.
15:24:51 <Eduard_Munteanu> :t concurrently
15:24:52 <lambdabot> error: Variable not in scope: concurrently
15:24:58 <Eduard_Munteanu> @hoogle concurrently
15:24:58 <lambdabot> Distribution.TestSuite concurrently :: Test -> Bool
15:24:58 <lambdabot> Control.Concurrent.Async concurrently :: IO a -> IO b -> IO (a, b)
15:24:58 <lambdabot> Control.Concurrent.Async.Lifted concurrently :: MonadBaseControl IO m => m a -> m b -> m (a, b)
15:26:25 <angelingyawn> It's not clear to me whether it uses a greenthread to facilitate running the operations concurrently or just runs first the one, then the other before returning
15:27:20 <Eduard_Munteanu> That can't work if the two actions are supposed to talk to each other.
15:27:32 <ski> i don't think `liftM2 (,)' would merit the name `concurrently'
15:27:43 <Ero> yea jle` im getting a timeout to git. is there a way to create a stack project using a template i already have projects for?
15:29:11 <angelingyawn> Meh I'll sleep on it. Thanks all. I'm sure some sensible-ish poking or example googling will fix
15:29:50 <Eduard_Munteanu> https://hackage.haskell.org/package/async-2.1.1.1/docs/src/Control-Concurrent-Async.html#concurrently
15:30:34 <Eduard_Munteanu> It uses forkIO in concurrently'
15:30:52 <angelingyawn> That seems reasonable
15:30:56 <angelingyawn> I think I might have misused forever
15:33:44 <c_wraith> > forever Nothing
15:33:46 <lambdabot>  Nothing
15:33:48 <Ero> is anyone else able to use stack new?
15:36:12 <jared-w> Ero: I am
15:36:40 <kadobann> Ero: You can specify in config a local template file and you can set that as the default
15:37:18 <kadobann> That's probably the only choice if the github site isn't possible to contact
15:38:31 <jared-w> I can download new templates just fine ¯\_(ツ)_/¯
15:39:02 <kadobann> I've heard it doesn't work for some. Not really clear why
15:39:30 <jared-w> No idea
15:39:42 * jared-w is the chosen one
15:42:44 * hackagebot simple-smt 0.7.1 – A simple way to interact with an SMT solver process. – https://hackage.haskell.org/package/simple-smt
15:48:42 <throwaway3431> Hi!
15:48:48 <throwaway3431> I have a problem with Data.Map
15:49:02 <throwaway3431> Look at this:
15:49:03 <throwaway3431> insertWithKey f 5 "a" (fromList [(5, []), (3,[])])
15:49:11 <throwaway3431> f key new_value old_value = new_value : old_value
15:49:27 <throwaway3431> Why is this a type error, when "a":[] is perfectly acceptable?
15:49:47 <Rembane> throwaway3431: Which types does the typechecker expect and which does it get?
15:50:13 <throwaway3431> Here's the error message:
15:50:14 <throwaway3431>     Couldn't match type ‘Char’ with ‘[Char]’     Expected type: t -> [Char] -> [Char] -> [Char]       Actual type: t -> [Char] -> Char -> [Char]     In the first argument of ‘insertWithKey’, namely ‘f’     In the expression:       insertWithKey f 5 "a" (fromList [(5, []), (3, [])])
15:50:41 <c_wraith> throwaway3431, you need to watch type variables a bit more closely
15:50:48 <c_wraith> :t (:)
15:50:50 <lambdabot> a -> [a] -> [a]
15:51:04 <c_wraith> :t (++)
15:51:06 <lambdabot> [a] -> [a] -> [a]
15:51:18 <c_wraith> which one of those matches what you have?
15:51:57 <benzrf> throwaway3431: the problem is that insertWithKey wants the thing you're inserting to be the same type as what's already there
15:52:19 <benzrf> you're not just using f to combine "a" with the existing value - you may have to insert "a" as-is
15:52:35 <benzrf> so "a" needs to have the same type as what you're combining it with
15:53:40 <throwaway3431> Great, thanks for your help!
15:53:44 <benzrf> no problem
15:54:45 * hackagebot strict-types 0.1.2 – A type level predicate ranging over strict types – https://hackage.haskell.org/package/strict-types
15:54:59 <benzrf> however, this works:
15:55:21 <benzrf> er, one second
15:55:49 <Neo> hello
15:56:23 <benzrf> > over (at 5 . non []) ("a":) (Data.Map.fromList [(5, []), (3, [])]) -- throwaway3431 
15:56:26 <lambdabot>  fromList [(3,[]),(5,["a"])]
15:56:38 <benzrf> (this is almost certainly massive overkill, though - especially if you don't already know about lenses)
15:56:51 <benzrf> bbl
16:02:46 <tinytusk> https://www.stackage.org/haddock/lts-9.6/attoparsec-0.13.1.0/Data-Attoparsec-ByteString-Char8.html#v:isEndOfLine
16:02:55 <throwaway3431> Oh man, I'm scratching my head here... Sorry if I sound stupid, but I just came across this behavior:
16:03:02 <tinytusk> Is it just me, or should this type signature actually be Char -> Bool instead of Word8 -> Bool?
16:03:13 <throwaway3431> I create the following map: M.insert (5, 1) ["b"] $ M.singleton (3,2) []
16:03:26 <throwaway3431> I get the keys via M.keys
16:03:59 <throwaway3431> ...but I can't access the values: M.lookup (3, 2) test_map  leads to "Just []"
16:04:33 <throwaway3431> It's the same when I access one of the keys directly: M.lookup (head $ M.keys test_map)  test_map
16:05:43 <throwaway3431> Does anybody have any idea what's wrong?
16:07:02 <jared-w> tinytusk: Attoparsec is built on speed. Word8 is more efficient than Char iirc
16:07:15 <geekosaur> throwaway3431, that looks right to me?
16:07:28 <geekosaur> you have [] (aka "") as the value for key (3,2)
16:07:32 <tinytusk> jared-w: But that's why Data.Arroparsec.ByteString exists. I'm looking specifically at Data.Attoparsec.ByteString.Char8.
16:07:57 <geekosaur> if I M.lookup (5.1) then I get Just ["b"]
16:08:14 <throwaway3431> geekosaur: Of course. I really need to go to bed. Thanks for your help!
16:08:57 <geekosaur> hm, that aka wasn;t needed, I managed to confuse myself along the way
16:10:18 <jared-w> tinytusk: It's for Char8, not Char. Haskell's Char supports unicode and so is actually "wider" than Char8; Word8 is isomorphic to Char8 and so it's the more correct type to use :)
16:11:22 <tinytusk> So if you wanted to consume a complete line, what would you do? I wanted to do takeTill isEndOfLine, but I had to settle on takeTill (== '\n')
16:20:06 <jared-w> Why does isEndOfLine not work?
16:32:53 <tinytusk> Because Word8 is not Char.
16:35:21 <jared-w> Hmm, I thought for sure I've seen some code that used isEndOfLine just fine. In either case, takeTill (== `\n') isn't too bad I suppose. Although the usage of Char for most things and Word8 for only 3 things in the library does strike me as particularly odd
16:36:08 <Ero> thanks kadobann 
17:10:34 <poliquin> I'm confused .. maximum (zip [1,2,4,3] [0..]) --> (4,2) but docs say maximum is a straight list .. Help appreciated
17:10:50 <benzrf> poliquin: "straight list"?
17:11:05 <poliquin> not a list of tuples
17:11:08 <jmcarthur> I'm confused about -XEmptyCase. It just lets me write  case a of {}  with no warning, even if the type of a is not empty, and even with -Wall.
17:11:45 <jmcarthur> I guess there are no empty types in Haskell, but I figure this is still the whole point of the extension...
17:12:03 <hpc> jmcarthur: i think the idea is to let you write more constructive-looking bottoms
17:12:16 <hpc> i don't know why it would be useful, at least in haskell's current state
17:13:00 <koala_man> poliquin: maximum :: Ord a => [a] -> a  , so it can take a list of anything that can be compared
17:13:23 <jmcarthur> That stinks. I've appreciated refutation cases in OCaml.
17:13:46 <jmcarthur> Strictness perhaps makes it easier there.
17:14:03 <jmcarthur> And of course total languages also don't have this problem.
17:14:33 <poliquin> That make sense but is is very specific .. it looks for the maximum of the first element of the tuple and returns the rest (I've tried it with a 3 tuple). I can't find the code that does this.
17:14:38 <geekosaur> :t maximum
17:14:39 <lambdabot> (Ord a, Foldable t) => t a -> a
17:15:00 <hpc> in proofs, empty case is the principle of explosion as well
17:15:02 <geekosaur> anything that has an Ord instance has a maximum
17:15:10 <hpc> you match on every value of the empty type, and the result is unconstrained
17:15:21 <geekosaur> tuples have an Ord instance if their component types have Ord instances
17:15:25 <jmcarthur> poliquin: Nah, that's not what it does. It's using the Ord instance on tuples, which considered both components.
17:15:46 <jmcarthur> > maximum [(1,1), (1,5)]
17:15:49 <lambdabot>  (1,5)
17:16:57 <poliquin> maximum (zip [1,2,4,3,4,3,3,3,3,3] [0..]) -> (4,4) which implies it's only looking at the first element for max
17:17:31 <benzrf> poliquin: it will look at the second element, but only if the first elements are the same
17:17:42 <hpc> > (zip [1,2,4,3,4,3,3,3,3,3] [0..])
17:17:45 <lambdabot>  [(1,0),(2,1),(4,2),(3,3),(4,4),(3,5),(3,6),(3,7),(3,8),(3,9)]
17:17:46 <benzrf> poliquin: like comparing words in a dictionary
17:17:58 <hpc> > compare (4,2) (4,4)
17:18:00 <benzrf> axe comes before bat, even though x comes after a
17:18:00 <lambdabot>  LT
17:18:03 <jmcarthur> It's lexicographic order.
17:19:04 <poliquin> Ok .. Thanks! So all the 'code' for this is in the Ord instance of Tuple?
17:19:07 <benzrf> yup
17:19:41 <poliquin> Wow. Someday I might be a Haskell programmer .. Maybe
17:19:46 <jmcarthur> :t \(a1, b1) (a2, b2) -> compare a1 a2 <> compare b1 b2
17:19:48 <lambdabot> (Ord a2, Ord a1) => (a1, a2) -> (a1, a2) -> Ordering
17:19:51 <benzrf> :)
17:20:06 <poliquin> Thanks very much!
17:20:24 <benzrf> no problem
17:20:38 <ski> jmcarthur : hm, i would have thought `-fwarn-incomplete-patterns' would do the trick, but it seems not ..
17:22:00 <jmcarthur> ski: me too
17:33:09 <monochrom> No, EmptyCase is meant to go well with EmptyDataDecl so if you have "data X" you can have "case x of {}" to go with it. It is not meant to give you more ways to write partial functions. Or at least, not if I had a say on this.
17:35:06 <monochrom> Now of course if you don't turn on warnings, "case Nothing of {}" is just as partial as "case Nothing of {Just _ -> blah}" and both are problematic. And if you turn on the relevant warnings, both should lead to the same warning.
17:35:44 <monochrom> So I would say that -fwarn-incomplete-patterns is supposed to warn you about "case Nothing of {}".
17:48:26 <theotherben> hey, I'm hoping someone can help me understand how to read cabal's error messages?
17:48:34 <theotherben> I'm trying to install ghc-mod with cabal install ghc-mod
17:48:46 <theotherben> and I'm getting cabal: Could not resolve dependencies:
17:48:46 <theotherben> trying: ghc-mod-5.8.0.0 (user goal)
17:48:46 <theotherben> next goal: base (dependency of ghc-mod-5.8.0.0)
17:48:46 <theotherben> rejecting: base-4.10.0.0/installed-4.1... (conflict: ghc-mod => base<4.10 &&
17:48:46 <theotherben> >=4.6.0.1)
17:48:46 <theotherben> rejecting: base-4.10.0.0, base-4.9.1.0, base-4.9.0.0, base-4.8.2.0,
17:48:46 <theotherben> base-4.8.1.0, base-4.8.0.0, base-4.7.0.2, base-4.7.0.1, base-4.7.0.0,
17:48:47 <theotherben> base-4.6.0.1, base-4.6.0.0, base-4.5.1.0, base-4.5.0.0, base-4.4.1.0,
17:48:47 <theotherben> base-4.4.0.0, base-4.3.1.0, base-4.3.0.0, base-4.2.0.2, base-4.2.0.1,
17:49:08 <jle`> jmcarthur: to clear up some confusion, EmptyCase is *supposed* to give warnings
17:49:12 <jle`> but in previous GHC versions, it did not
17:49:21 <jle`> i think it was 8.0 or 8.2 that it started actually giving warnings
17:49:40 <jle`> so some of the confusion might come from the fact that we might all be using different ghc versions
17:50:08 <jle`> jmcarthur: it should warn with -Wall, but old ghc versions did not
17:50:46 <theotherben> ...Oops, I know see the pastebin link.
17:51:24 <theotherben> Anyway, any idea how to read this error? http://lpaste.net/358906
17:51:58 <jle`> theotherben: it looks like whatever ghc-mod you are trying to install is incompatible with the version of base (and therefore the version of ghc) you have
17:52:20 <theotherben> I see; what's the recommended way to downgrade?
17:52:42 <jle`> you can use the 'stack' tool to manage multiple ghc versions on your machine simultaneously
17:52:56 <jle`> actually ghc's don't normally interact each other
17:53:10 <jle`> so it's probably possible to just install ghc-8.0, and then set it in your $PATH
17:53:13 <jle`> or symlink it
17:53:27 <theotherben> I see -- I'm having trouble getting a good mental model of stack vs. cabal
17:53:40 <theotherben> I have a project that doesn't build with stack, it only does with cabal
17:54:00 <hpc> the basic idea of stack is that it builds everything in a reproducible environment
17:54:23 <hpc> it controls the version of ghc, all your packages and other tools, sometimes foreign dependencies
17:54:45 <hpc> and you give exact versions of everything (or something that maps to a version like a stack LTS)
17:54:55 <hpc> then it does its thing
17:55:19 <hpc> cabal is like most other language package managers
17:55:34 <theotherben> And do either of those operate globally?
17:55:37 <hpc> it'll download things from hackage, register them in a user or global database, and so forth
17:55:41 <theotherben> Like, stack install seems to install some stuff globally
17:55:44 <jle`> the particular issue here is that the ghc that cabal is using is incompatible with the latest version of ghc-mod
17:55:56 <jle`> theotherben: stack install can build binaries and put them in your local $PATH
17:56:04 <jle`> but, it doesn't actually globally expose packages
17:56:13 <jle`> it's the just the binaries that they produce (if any) that are "global"
17:56:17 <dmwit> You can request another ghc with the `-w` flag, as in `cabal install ghc-mod -w ghc-7.10.3` or whatever.
17:56:23 <theotherben> So, if I wanted to just get an older GHC, stack install ghc-8.0 should work
17:56:39 <jle`> er not quite; you'd have to edit your "global" stack project to use a snapshot with ghc 8.0
17:56:58 <jle`> usualyl in ~/.stack/globa-project/stack.yaml
17:57:11 <jle`> set the snapshot to be, say, lts-9.6
17:57:19 <jle`> then 'stack setup' will set up the ghc's necessary
17:57:32 <jle`> and then stack install in a naked directory will use the global project stack.yaml, and use ghc 8.0
17:57:47 <jle`> cabal is also more than capable is switching ghc's too
17:58:03 <theotherben> @jle` but to do that, I need to install it first?
17:58:03 <lambdabot>  Parse failed: TemplateHaskell language extension is not enabled. Please add ...
17:58:16 <jle`> theotherben: install stack?
17:58:25 <theotherben> No, I have stack
17:58:29 <theotherben> I mean install ghc-8.0
17:58:30 <jle`> then what is 'it'?
17:58:51 <theotherben> If i'm understanding right: I need to install ghc-8.0 via stack, then do `cabal install ghc-mod -w ghc-8.0`
17:58:53 <jle`> ah, yeah, no, the ghc is tied to the stackage snapshot you use
17:59:01 <theotherben> Oh, i see
17:59:14 <jle`> oh, yeah, if you use 'cabal', then you'd need to install 8.0 somehow, but you can install it side-by-side with 8.2
17:59:22 <theotherben> That's fine by me
17:59:29 <jle`> ghc doesn't really ever mess with any global configurations so cabal just uses whatever one you point it to
17:59:37 <theotherben> Ahhh
17:59:58 <theotherben> How do I install ghc-8.0 from cabal?
18:00:13 <jle`> i don't think it is recommended to build ghc from cabal unless you're doing ghc dev
18:00:24 <jle`> you can find a ghc binary online for your computer probably
18:00:38 <jle`> if you're on ubuntu there are some pretty convenient ppk's you can aptitude install
18:00:50 <kadobann> If you're going to be using stack, you won't often be using cabal directly. Probably better to pick one or the other. stack installs ghc to some internal place
18:01:19 <jle`> yeah, i'm talking about the 'all cabal' method, but you could also do the 'all stack' method; they're pretty much separate and independent build tools
18:01:28 <theotherben> Ach, okay.
18:01:35 <theotherben> I see the benefits of using stack, but one of the projects I'm using is all cabal
18:01:49 <jle`> this is kind of weird, i'd expect it to work with stack if it works with cabal
18:01:55 <jle`> unless it's a really esoteric kind of project
18:02:22 <theotherben> I'm still new to this stuff, but 2 things I noticed: 1) stack build don't work, init solver etc didn't get it done
18:02:24 <jle`> but also remember that if your goal is ghc-mod, ghc-mod is just a binary
18:02:26 <theotherben> and cabal build does
18:02:33 <jle`> so it doesn't matter if you use stack or cabal to build it
18:02:47 <theotherben> Okay, the second problem then
18:02:49 <jle`> if you are just using either to install ghc-mod, you can just build it and then use the binary
18:03:01 <theotherben> since I don't really know what I'm doing: ghc-mod can't resolve a package
18:03:13 <theotherben> so, let's say I do stack install ghc-mmod
18:03:43 <theotherben> I get http://lpaste.net/358907
18:03:46 <theotherben> even though cabal build works fine
18:03:49 <geekosaur> you will probably have to run it with stack exec ghc-mod, in the context of the stack project you are working with if any
18:04:01 <theotherben> @geekosaur there's no stack project
18:04:01 <lambdabot> Unknown command, try @list
18:05:00 <jle`> i believe you can run it with cabal to "set up" the environment and let it find the packages too
18:05:05 <jle`> but i myself only know the stack way
18:05:09 <kadobann> theotherben: That's the error from stack from 'stack install ghc-mod' ?
18:05:30 <theotherben> kadobann: that's the error from ghc-mod .
18:05:30 <geekosaur> looks like it, yes. so my remark about running it wasn't relevant
18:05:34 <theotherben> err, `ghc-mod .`
18:05:41 <geekosaur> ok, now it is relevant
18:05:47 <geekosaur> use stack exec ghc-mod
18:06:08 <jle`> yeah, you either have to use stack or cabal to run ghc-mod in a context where it will be aware of all project packages
18:06:22 <jle`> otherwise ghc-mod looks in global packages i believe
18:06:26 <geekosaur> otherwise it cannot see the packages that stack has installed
18:06:40 <geekosaur> even for global packages it won't work if it's a stack-installed ghc
18:07:03 <geekosaur> because that ghc will get its global packages from the environment stack sets up for it
18:07:14 <theotherben> Oh boy, okay. I think I'm starting to get an understanding?
18:07:15 <geekosaur> and 'stack exec' is how you get stack to set up that same environment for other programs
18:07:20 <theotherben> I have a stack-installed ghc
18:07:24 <theotherben> and a stack-installed ghc-mod
18:07:32 <geekosaur> so try: stack exec ghc-mod .
18:07:53 <theotherben> I'm in a project that only builds with cabal, not with stack. Both 'stack exec ghc-mod check .' and 'cabal exec ghc-mod check .' give the same error, the one i posted
18:08:00 <theotherben> And cabal build works fine
18:08:27 <geekosaur> if you installed ghc-mod with stack, you're going to have real problems using it with a cabal project
18:09:01 <theotherben> Achhhh, okay. Then if I want to install ghc-mod with cabal, which I originally was asking about, I need to get an older version of ghc
18:09:28 <pacak> theotherben: There's also hdevtools that solves similar problem.
18:10:37 <kadobann> geekosaur: Is that true, the binary itself behaves differently depending on which builds it? Hm
18:11:09 <geekosaur> it's ghc as a library. its run enviironment has to be the same as the build environment, with respect to ghc config
18:11:26 <geekosaur> if you used a stack-installed ghc then you can only reproduce that build environment with stack exec
18:12:01 <geekosaur> but then it will only work with stack packages, because cabal packages have their own build environment that stack doesn't know about
18:12:30 <geekosaur> and stack and cabal use the same mechanisms to tell ghc (and ghc-mod) the buld environment, so mixing them doesn't go well; they conflict with each other
18:12:44 <theotherben> okay, how do i go to an older version of ghc using stack?
18:13:02 <geekosaur> specify an older resolver that has that ghc, usually
18:13:11 <geekosaur> you can try searching on stackage.org
18:16:28 <geekosaur> (and using ghc as a library makes ghc-mod fast but absurdly picky about that environment)
18:19:37 <theotherben> Thank you all for the help -- a lot to learn here :)
18:19:40 <theotherben> starting to get the hang of it
18:30:01 <dumptruckman> Can strictness and laziness intersect?
18:31:48 <ski> > "strictness" `intersect` "laziness"
18:31:50 <lambdabot>  "siness"
18:32:04 <dumptruckman> oh i see
18:32:54 <jle`> dumptruckman: not sure what you mean exactly, but it isn't uncommmon to see strictness and laziness used together in the same program or even the same function
18:33:13 <dumptruckman> i mean like
18:33:23 <dumptruckman> is strictness the antithesis to lazyness
18:33:44 <dumptruckman> Haskell wiki leads me to believe so
18:33:48 <dumptruckman> "Basically laziness == non-strictness + sharing."
18:34:36 <ski> laziness is an implementation strategy for a non-strict denotational semantics
18:34:45 <ski> @where lazy
18:34:46 <lambdabot> http://www.vex.net/~trebla/haskell/lazy.xhtml
18:35:41 <ski> Haskell is non-strict. that doesn't mean every function expressible in it is non-strict, though
18:35:46 <dumptruckman> ah, i see
18:36:14 <dumptruckman> so
18:36:47 <dumptruckman> strict == not lazy
18:36:58 <dumptruckman> not strict \= lazy
18:37:10 <ski> no
18:37:40 <dumptruckman> really?
18:38:21 <parsnip> the set A is non-strict if some x in A is non-strict?
18:38:42 <ski> strict vs. non-strict is about denotational semantics. lazy (aka by-need) vs. otherwise is about small-step operational semantics
18:39:24 <dumptruckman> but if it's denoted as strict, it can't be computed lazily, right?
18:39:36 <ski> "strict == not lazy" makes no sense, is like comparing apples to oranges
18:39:40 <jle`> i think we're just using different definitions for ==
18:39:54 <dumptruckman> apples and oranges can be compared
18:40:00 <jle`> you might mean to say something like "strict ==> not lazy"
18:40:01 <dumptruckman> they're both fruits, for instance
18:40:07 <jle`> as in, strictness implies not lazy
18:40:07 <dumptruckman> yes, jle`
18:40:20 <dumptruckman> that's a better way to say what i meant
18:40:26 <jle`> strict == not lazy usually is interpreted as `strict <=> not lazy`
18:40:33 <dumptruckman> good point
18:40:41 <theotherben> Ugh, geekosaur, I just finished getting `cabal install ghc-mod` to work, but I still get the same error from `cabal exec ghc-mod check .` as before
18:40:54 <c_wraith> perhaps you wanted strict -> not lazy. :)
18:40:55 <dumptruckman> strict implies not lazy, but not strict doesn't imply lazy
18:40:58 <theotherben> http://lpaste.net/358907
18:41:48 <geekosaur> dumptruckman, there are a few operations that are fundamentally strict (like numeric operations that compile directly to CPU operations such as (+) on Int, Double, etc.). otherwise you get strictness by pattern matching, or by performing an operation in IO that needs the value
18:43:08 <pacak> > foldl (+) (0 :: Double) [1..10000000]
18:43:14 <lambdabot>  mueval-core: Time limit exceeded
18:43:14 <pacak> > foldl' (+) (0 :: Double) [1..10000000]
18:43:18 <lambdabot>  5.0000005e13
18:43:23 <geekosaur> theotherben, is this directory where you are running that a cabal sandbox, or just a source directory with a cabal file in it?
18:43:30 <theotherben> the latter
18:43:49 <geekosaur> what is the output of: ghc-pkg list
18:43:57 <jle`> > foldl' (+) (0 :: Integer) [1..10000000]
18:43:59 <lambdabot>  50000005000000
18:44:15 * ski . o O ( `addIntC# 0# 0# = ...; ...' )
18:44:30 <theotherben> geekosaur: http://lpaste.net/358908
18:45:01 <pacak> ski: Only when ghc manages to figure it out, not always.
18:45:16 <geekosaur> hm. does the cabal file specify a ghc version?
18:45:38 <ski> pacak : referring to ?
18:45:52 <pacak> strict addition of ints
18:46:04 <geekosaur> (also it would be nice if that output had the abi hashes in it... sigh)
18:46:18 <theotherben> geekosaur, I don't see that it does
18:47:31 * ski doesn't follow the "not always"
18:48:27 <geekosaur> theotherben, what does this say: ghc-pkg field aeson-1.2.2.0 key
18:49:12 <theotherben> key: aeson-1.2.2.0-EgdsAG3iF1hHs6qNH5FOqC
18:49:43 <geekosaur> huh. so ghc-mod is still somehow using the wrong package db
18:50:10 <geekosaur> you might .. hm, you did stack install. maybe it's stil lusing that one
18:50:26 <vc> as a general rule, should FFI memory allocations always be IO operations?
18:50:28 <geekosaur> cabal exec ~/.cabal/bin/ghc-mod .
18:50:44 <vc> or is that a case where unsafePerformIO gets used?
18:51:21 <geekosaur> unsafePerformIO should only be used there if the memory is also freed within the same unsafePerformIO-d code
18:51:21 <c_wraith> vc: depends on which allocator is doing it.
18:51:27 <geekosaur> (to be safe)
18:51:33 <c_wraith> vc: if you're using a foreign allocator, it should be in IO.
18:52:12 <c_wraith> Yeah, that's also true.
18:53:07 <vc> c_wraith that's the safe option of course
18:53:28 <vc> but it can be somewhat awkward to work with. by contrast, haskell makes allocations all the time but they aren't IO
18:53:41 <vc> but i can def see that for the unmanaged case
18:53:46 <c_wraith> One thing I think isn't done enough...  putting FFI'd code into ST
18:54:00 <c_wraith> Mostly because it requires things like unsafeIOToST
18:54:09 <vc> what about in cases where the allocation is managed by foreign pointers?
18:54:12 <c_wraith> But often, ST gives you the properties you actually want
18:54:36 <vc> then would it be acceptable to have the allocation outside of IO?
18:54:55 <c_wraith> That doesn't say what allocator creates it.
18:55:12 <c_wraith> You can have foreign ptrs to memory allocated in a number of ways
18:55:45 <theotherben> geekosaur, i removed the stack ghc-mod
18:55:55 <theotherben> geekosaur, i removed the stack ghc-mod
18:56:06 <vc> suppose it's allocated with newForeignPtr with the appropriate single-point-of-entry destructor
18:56:19 <vc> also all mutating FFI operations are annotated as FFI
18:56:43 <vc> then is it reasonable to have the allocating operation (a function wrapping newForeignPtr) to use unsafePerformIO?
18:56:57 <vc> above should read all mutating FFI operations are annotated as IO
18:58:17 <ski> vc : generally no, since `instance Eq (ForeignPtr a)'
18:58:20 <geekosaur> hrm. I have no idea then. were I doing this I'd probably be strace-ing it to check which package databases it is looking at
18:58:35 <vc> ultimately, i'm writing an api that wraps FFI library and I'd prefer it to operate as natively as possible
18:58:44 <c_wraith> vc: are you sure you don't want to unsafeIOToST your operations into ST and then use that instead?
18:59:43 <vc> if everything has to be monadic just by virtue of the fact that it's FFI
19:00:00 <vc> i can see how that's safer, but it also makes the library more awkward to work with
19:00:20 <ski> "everything has to be monadic just by virtue of the fact that it's FFI" -- no
19:00:51 <c_wraith> Everything has to be of a type that accurately reflects its semantics.
19:01:00 <c_wraith> Or else it's broken. :P
19:01:03 <vc> c_wraith i haven't used ST much before
19:01:43 <ski> c_wraith : hm, point. perhaps there should be modules under `Foreign' giving an `ST' interface to some operations ..
19:02:02 <vc> c_wraith, well i'm trying to write the API such that the entrypoints are sufficiently managed
19:02:07 <c_wraith> ski: that'd be pretty cool, actually
19:02:42 <vc> the semantics reflect the signatures... hence these questions
19:02:48 <ski> i suppose `foreign import' should ideally also work with an `ST' return type
19:03:58 <c_wraith> ski: I suppose, but you do need to be more careful with it.  IO is roughly "anything goes".  ST would mean "this will all go horribly wrong if you do anything other than allocate memory, mutate it, and then clean up after yourself"
19:04:39 <ski> vc : anyway, allocating a `ForeignPtr a' (as well as a `Ptr a', an `IORef a',`STRef s a',`MVar a',`TVar a',&c.) allocates a new reference, which can be compared for identity (irrespective of what `a' is). this alone means that you can't (in general) avoid the effectful interface
19:05:22 <ski> c_wraith : ditto with stuff like `foreign import "math.h" sin :: CDouble -> CDouble'
19:05:56 <vc> ski what if you wrap the pointer and don't expose that to the API
19:06:04 <vc> end-user API 
19:06:10 <ski> vc : that might work, perhaps
19:06:22 <vc> in some wrapper type that hides the foreignPtr
19:06:22 <c_wraith> ski: well, that's true.  the FFI already has the ability to write implicitly unsafe things
19:07:14 <vc> i imagine hmatrix must be doing something like this although ihaven't looked under the hood yet
19:07:19 <monochrom> Noooo! The FFI has the ability to make C great again. http://lpaste.net/358634
19:09:34 <vc> hrm ffi is dicey stuff... but gotta try =P
19:10:23 <nshepperd> vc: that is what I would normally do. wrap the ForeignPtr in some data type. then write some operations that act on it under unsafePerformIO
19:11:10 <nshepperd> only export the abstract data type along thing such operations that are 'morally' pure
19:11:44 <vc> nshepperd ok, this is what i was thinking would make sense. i get that it can get iffy, it relies a lot on the library author to seal things up well.
19:12:38 <vc> but this is my first foray into a big FFI project so i wasn't sure what the norms are
19:14:40 * ski idly ponders the meaning of "morally", in math
19:16:01 <vc> whatever it means, i'm way beyond redemption with my C-whoring...
19:17:44 <vc> but this is my first foray into a big FFI project so i wasn't sure what the norms are
19:17:49 <vc> whoops wrong copy-paste
19:18:49 * hackagebot urlpath 7.0.0 – Painfully simple URL deployment. – https://hackage.haskell.org/package/urlpath
19:32:04 <iqubic> rotaerk: How do you combine Haskell and NixOS. Do still use stack or what?
19:40:05 * hackagebot markup 4.0.3 – Abstraction for HTML-embedded content – https://hackage.haskell.org/package/markup
19:40:34 <athan> iqubic: I've heard cabal is the way to go. Google should be helpful, there's a lot of kit
19:40:57 <iqubic> athan: Actually Stack is better.
19:41:18 <Axman6> there are ways to take a stack project and make a make a nix expression from it
19:41:29 <Axman6> iqubic: I wouldn't go that far
19:41:57 <Cale> iqubic: Stack seems sort of pointless if you're using nix.
19:42:20 <Cale> It's basically doing what nix is doing, but on a smaller scale. You might as well just let nix do it.
19:42:26 <iqubic> How does one use Nix to manage haskell deps?
19:42:44 <Cale> Turn them into nix derivations with cabal2nix
19:43:36 <Cale> Which uses the cabal library (that both cabal-install and stack use) to construct a nix expression for building the package.
19:46:54 <Axman6> how does Nix aboid the "cabal hell" problems of inconsistent dependencies between different projects?
19:46:58 <chris_> Stack is cabal with nix features bolted onto it
19:47:14 <Axman6> chris_: and now so is cabal-install
19:47:45 <eacameron> chris_: Stack is actually not cabal with nix. Stack is cabal with a frozen dependency solution
19:48:02 <Cale> Axman6: Well, if the dependencies are *actually* inconsistent, you're still screwed, there's no way around that.
19:48:54 <Cale> Axman6: But all the nix packages you build are identified by their hashes, and it doesn't have any trouble dealing with separate builds of the same package version.
19:49:02 <Axman6> i mean, with stack deps are basically segregated between projects, with sharing of packages in the snapshot you're using, and anything else is project local - what does Nix offer there?
19:49:27 <eacameron> Axman6: Nix offers that but for all packages for all time
19:49:36 <Cale> It's basically the same in that regard, except it does this not only for Haskell dependencies, but for everything.
19:49:48 <Axman6> so right, ok
19:50:23 <eacameron> Axman6: The basic idea that nix offers is that packages are not identified by their name and version. They are defined by a deterministic hash of all the inputs that produce them.
19:50:24 <Axman6> so I guess you also get the advantage that if you have two projects which use packages "not in the shapshot", those will also be shared if they are identical.
19:50:42 <eacameron> Axman6: right; and even across all the computers in the world.
19:50:55 <Cale> If you need a package whose derivation has exactly the same hash as one which has already been built, then nix will use the one which is already built and in your store.
19:51:51 <Axman6> I'm pretty sure I already knew this and had a brainfart
19:52:33 <eacameron> Axman6: Brainfarts are why haskell was created. We all have them.
19:53:52 <Cale> It does tend to result in a fair amount of possibly-unnecessary recompilation though. It will be nice when we can dissolve the package boundary and treat individual modules as nix derivations.
19:54:12 <Cale> (that is, if you're editing modules which are part of a dependency of your overall project)
19:56:04 <Cale> Actually, even the module boundary is a bit silly... :)
19:56:40 <eacameron> Cale: I think that's why it is yet unsolved. "Where" that boundary properly exists is hard to determine
19:56:55 * ski idly considers Nix hashes of run-time Haskell values
19:57:27 <eacameron> memoization at a global scale
19:58:13 <eacameron> (when we all get gigabit internet...)
20:06:34 <eacameron> What's the easiest way to grab a value out of a ReaderT with a lens?
20:06:41 <eacameron> Like "asks" but with lenses
20:08:42 <eacameron> asks (^. field) I suppose
20:20:20 <mengyu9900> hi
20:22:52 * dmwit waves vaguely
20:24:09 <mengyu9900> hi
20:41:08 <suleman> hi getting 'Not in scope' error while defining "maximum' :: (Ord a) => [a] -> a" on Prelude.
20:41:35 <geekosaur> @paste
20:41:35 <lambdabot> Haskell pastebin: http://lpaste.net/
20:41:39 <pacak> on Prelude? O_o
20:41:43 <geekosaur> ^ full code and full error
20:41:56 <geekosaur> neecomers fdont; know 'ghci', they know a prompt that says 'Prelude'
20:42:09 * geekosaur eyes his typing
20:43:43 <dmwit> suleman: At a guess: you are in ghci, and are wishing to write `maximum' :: ...` on one line and `maximum' = ...` on the next. But ghci doesn't work like that.
20:43:59 <dmwit> suleman: Try `:{` to start multiline mode and `:}` to end it.
20:44:27 <dmwit> suleman: Or write the whole definition on one line with semicolons; e.g. `maximum' :: ...; maximum' [] = ...; maximum' (x:xs) = ...`.
20:44:50 <geekosaur> note thatif your ghc is older than 8.0 you'll need to start that line with 'let '
20:45:12 <suleman> dmwit: thanks. let me try.
20:46:13 <suleman> geekosaur: when I use let it says "type signature lacks accompanying binding."
20:46:26 <geekosaur> you still do them all on one line
20:47:07 <c_wraith> and in one let
21:02:18 <byorgey> suleman: it might be easier to put your definition in a .hs file and then use the  :load  command to load it into ghci to test it
21:04:33 <Axman6> > let foo :: Int -> Int; foo x = x^7 -- suleman, or you can use :{\nfoo :: Int -> Int\nfoo x = x^7\n:}
21:04:36 <lambdabot>  <no location info>: error:
21:04:36 <lambdabot>      not an expression: ‘let foo :: Int -> Int; foo x = x^7 -- suleman, or yo...
21:04:47 <Axman6> (That works in GHCi, not lambdabot)
21:35:47 * hackagebot yarn-lock 0.3.2 – Represent and parse yarn.lock files – https://hackage.haskell.org/package/yarn-lock
21:48:57 * hackagebot aivika-distributed 0.7.4.1 – Parallel distributed discrete event simulation module for the Aivika library – https://hackage.haskell.org/package/aivika-distributed
21:56:03 * hackagebot hoauth2 1.4.0 – Haskell OAuth2 authentication client – https://hackage.haskell.org/package/hoauth2
22:05:09 * hackagebot hol 1.2 – Higher order logic – https://hackage.haskell.org/package/hol
22:37:56 <osa1> I still confuse elem and member because containers use one base uses the other
22:44:41 * hackagebot th-data-compat 0.0.2.5 – Compatibility for data definition template of TH – https://hackage.haskell.org/package/th-data-compat
22:50:46 * hackagebot th-reify-compat 0.0.1.3 – Compatibility for the result type of TH reify – https://hackage.haskell.org/package/th-reify-compat
23:04:01 * hackagebot openflow 0.3.1 – OpenFlow – https://hackage.haskell.org/package/openflow
23:32:04 <towerio> @pl \a b -> filter (`notElem` b) a
23:32:05 <lambdabot> flip (filter . flip notElem)
23:55:55 <jxv> :t ap
23:55:57 <lambdabot> Monad m => m (a -> b) -> m a -> m b
23:56:05 <jxv> :t (<*>)
23:56:06 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
23:56:53 <towerio> @pl \(a, b) -> (a, reverse b)
23:56:53 <lambdabot> second reverse
23:57:17 <jxv> would anybody know what's the applicative without the pure function is called? I just want the eqv of <*> without reinventing the wheel.
23:58:31 <systemfault> Hmm, <*> is "ap" IIRC but... IIRC, you have to implement Applicative to implement Monad... which has "ap"
23:58:41 <towerio> Functor?
23:58:42 <systemfault> I'm still a noob so I could be wrong.
23:58:52 <towerio> :t fmap
23:58:53 <lambdabot> Functor f => (a -> b) -> f a -> f b
23:59:27 <systemfault> <*> is not fmap, <$> is.
23:59:55 <jxv> `f (a -> b) -> f a -> f b` without giving access to a pure function. I have my own custom pure functions which implies a set of rules.
