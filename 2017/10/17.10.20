00:27:19 <Lol> Hi herr
00:32:48 <ertes-w> hell
00:33:04 <Lol> Hell
00:33:20 <ventonegro> gel
00:43:47 <Lol> LIST #freenode -min 50
00:44:22 <sordina> Does chris done hang out here?
00:45:09 <Lol> Are there any active channels on freenode?
00:45:27 <osa1> wow 5 years of Haskell and I think I used WriterT for something useful for the first time. used All as the monoid.
00:45:43 <sordina> osa1: what did you use it for?
00:47:00 <joncol> Is there a way of using multiline templates in Hamlet? I want what's inside of #{...} to be spread on multiple lines in the source text.
00:47:02 <osa1> sordina: I had a loop that updated a data structure, and needed to check a condition on the way. I used Any as the monoid and used `tell condition_holds_here` in each iteration.
00:47:19 <mniip> Lol: freenode is a network for Free and Open Source Software, is there anything specific you're interested in?
00:47:51 <Lol> Miniio, I just want to go to a more active room.
00:48:13 <sordina> osa1: sounds useful!
00:48:37 <ertes-w> osa1: better make sure your All value isn't building up in memory
00:48:44 <sordina> I've only ever used it as a logging style thing
00:48:50 <osa1> ertes-w: ah! good point
00:49:01 <mniip> Lol: try ##chat or something
00:49:04 <ertes-w> osa1: i'd prefer StateT
00:49:07 <osa1> hmm that's related with how WriterT is implemented, right?
00:49:16 <ertes-w> osa1: yeah
00:49:27 <ertes-w> osa1: in particular strict WriterT isn't strict the way one would imagine
00:51:20 <osa1> ertes-w: do you mean using strict WriterT wouldn't fix that for me?
00:51:28 <ertes-w> osa1: yes
00:51:46 <osa1> ugh. back to parameter passing with a bang pattern then.
00:51:48 <osa1> sigh
00:53:16 <sordina> later!
00:53:29 <ertes-w> lazy WriterT:  c >>= f = WriterT $ do ~(x, lx) <- runWriterT c; ~(y, ly) <- runWriterT (f x); pure (y, lx <> ly)
00:53:38 <ertes-w> strict WriterT:  c >>= f = WriterT $ do (x, lx) <- runWriterT c; (y, ly) <- runWriterT (f x); pure (y, lx <> ly)
00:54:14 <osa1> hmm yeah I need a seq at `lx <> ly` before pure
00:54:31 <ertes-w> the WriterT that you *would* need:  c >>= f = WriterT $ do (x, !lx) <- runWriterT c; (y, !ly) <- runWriterT (f x); let !l = lx <> ly in pure (y, l)
00:54:35 <mniip> so it's stict/lazy in the "spine"
00:54:43 <osa1> right
00:55:04 <ertes-w> and then of course you still can't use it with String =)
00:55:24 <ertes-w> or lazy Text
01:13:29 <phadej> check http://hackage.haskell.org/package/writer-cps-mtl-0.1.1.4/docs/Control-Monad-Writer-CPS.html
01:17:21 <ertes-w> why is the constructor hidden?
01:18:13 <saurabhn_> what's the specific GHC (i.e. not -Wall) to turn on errors for non-exhaustive patterns? Can it be applied on a per-function basis?
01:18:29 <saurabhn_> s/specific GHC/specific GHC flag/
01:19:13 <osa1> -Werror=incomplete-patterns with 8.2.1
01:19:23 <osa1> not possible pre-8.2.1
01:19:43 <osa1> unless you turn all warnings into errors
01:19:49 <ertes-w> also how is that even CPS?  this is just StateT
01:22:16 <saurabhn_> osa1: anything similar that is possible by strictness?
01:22:57 <phadej> ertes-w: for the same reason why DList's one
01:23:13 <phadej> ertes-w: too easy to break invariants if it's exposed
01:23:41 <phadej> ertes-w: if you cps writer you get state
01:25:16 <ertes-w> phadej: i don't consider DList to be CPS, and no, you don't get state…  if you CPS ReaderT you get StateT
01:25:29 <ertes-w> newtype WriterT w m a = WriterT { runWriterT :: forall r. (a -> w -> m r) -> m r }
01:25:35 <ertes-w> this is CPS-ed WriterT
01:30:11 <phadej> true, but I don't know better name for "[] -> DList" kind of transformation
01:30:40 <phadej> you can discuss that with Daniel :)
01:31:00 <ertes-w> well…  the D stands for "difference" =)
01:31:32 <ertes-w> but honestly i don't think that's a really good name either
01:32:16 <ertes-w> in any case it shouldn't misleadingly be called CPS…  i already found the type of 'tell' highly suspicious, because if it were indeed CPS-ed, then there would be no Monad constraint
01:32:27 <mniip> it is a kind of fold
01:32:47 <mniip> you leave the (:) as is but make the nil a hole
01:33:35 <osa1> saurabhn_: I don't think so, I don't see how strictness is relevant to it. one case where strictness turns warnings into errors is when you make a record field strict you can no longer avoid initializing that field in { ... } syntax
01:33:56 <saurabhn_> osa1: just a shot in the dark...
01:33:59 <ertes-w> what does the "S" in ShowS stand for?
01:35:18 <phadej> good question
01:37:57 <MarcelineVQ> pretty sure it's just short for String
01:38:18 <MarcelineVQ> And by pretty sure I​ mean wildly guessing
01:40:52 <mniip> ReadP
01:41:48 <MarcelineVQ> read parser? string shower?
01:42:39 <mniip> P is coS and S is coP
01:42:41 <mniip> evidently
01:44:40 <phadej> I'm not sure whether P is for Parser or Precendence, maybe both
01:45:15 <MarcelineVQ> there's also a ReadS
01:46:21 <mniip> o indeed
01:49:50 <MarcelineVQ> no help from the report either
01:58:28 <ertes-w> the show shower?
02:01:06 <_sras_> Can optimizations like -O and -O1 make a difference in the performance of a typical database backed web application?
02:04:00 <phadej> a lot
02:04:33 <phadej> not only "can", they will.
02:10:32 <_sras_> phadej: Isn't optimizations mostly done by inlineing functions. If that is so, 
02:11:16 <_sras_> How can a webapplication benifit so much from it (unlike something like a video game where there are a lot of tight loops and stuff where inlining can make a big difference)
02:12:13 <phadej> e.g. serialisation of data to JSON (using `aeson`) will be very slow if you don't let optimised to its tricks
02:12:47 <phadej> and even `aeson` is compiled with optimisations, so should be you app (where you define instances)
02:15:46 <_sras_> phadej: Yes. Makes sense.
02:18:54 <_sras_> Is there a way to build part of a web application as a library, and have executable dynamically link to this library? What I am trying to do is to reduce the size of the final executable that needs to be deployed after a code change (that does not touch the big library).
02:21:54 <liste> _sras_: sure, just as any other applications. https://stackoverflow.com/questions/38863005/how-do-i-get-stack-to-use-dynamic-linking
02:21:59 <liste> works for non-stack setups too
04:29:16 <stevenxl> Hi everyone. I have a question on the instance of Applicative that I wrote for the (StateT s m) type.
04:29:21 <stevenxl> The code is here (http://lpaste.net/359401).
04:29:33 <stevenxl> It starts on Line 13.
04:29:56 <stevenxl> It feels "dirty" to me have the Monad typeclass constraint on the m. 
04:30:23 <stevenxl> But I couldn't find any other way to manipulate the first value in the tuple. 
04:31:16 <stevenxl> Is it possible to implement applicative w/o bind?
04:34:33 <ertes-w> stevenxl: no, you need Monad
04:34:39 <mpickering> lyxia: I also feel like I need to implement a bind method with type "Expr c a -> (forall x . a -> Expr x b) -> Expr c b" to say that the substitution doesn't modify the wrong variables
04:34:49 <stevenxl> ertes-w: thank you!
04:35:10 <mpickering> So I'm ending up with a monomorphic version of bound
04:35:43 <ertes-w> stevenxl: it's not that uncommon to have stronger (or sometimes even weaker) constraints on the underlying functor
04:36:14 <ertes-w> stevenxl: so nothing dirty about it…  it's rather natural =)
04:38:32 <ertes-w> stevenxl: instance Monad (ContT r m)  -- here is an example with a weaker constraint
04:38:43 <stevenxl> ertes-w: Thank you. Yea I get hung up on that sometime, but luckily I have the helpful folks in this chan and reddit :-)
04:43:05 <int-e> (If you look closely, ContT isn't a transformer at all, it's just a type-restricted Cont with a type-restricted runCont. But transformer/MTL stupidly implements Cont as ContT ... Identity.).
04:43:38 <lyxia> mpickering: Doesn't that say that you are substituting 'a's with expression having no free variables other than 'b's?
04:43:46 <Psybur> So right now I am doing an execRWST on a recursive function + list. Anybody know how to translate that to a conduit? :D
04:44:25 <liste> hmm, maybe I'll grok Cont someday. is there some good materials on that?
04:44:36 <ertes-w> newtype ContT r m a = ContT { fromContT :: Cont (m r) a }
04:46:32 <Psybur> Perhaps a foldMapMC ?
04:46:33 <int-e> ertes-w: yes I'd prefer that. (you can add a 'deriving (Functor,Applicative,Monad)')
04:46:48 <ertes-w> liste: have you tried implementing Cont/ContT?
04:47:11 <liste> ertes-w: no. thanks for the suggestion
04:47:21 <liste> I've done CPS though
04:47:27 <liste> is that useful at all?
04:47:32 <ertes-w> liste: yes
04:47:55 <mpickering> lyxia: This all makes my head hurt
04:48:08 <liste> hmm, should I first try to understand call/cc (on Scheme) and use that knowledge for Cont?
04:48:16 <liste> or is it any help
04:48:19 <ertes-w> liste: no, just start with ContT
04:48:23 <liste> okay :)
04:49:03 <mpickering> The case I was having trouble with was "TAb (Binder () (Flip Expr a) b" so the case which binds the "other" variables. I wanted to implement it like this "TAb t = TAb  (hoistScope2 (\(Flip f) -> Flip (bindExpr f k))  t) "
04:49:17 <mpickering> But can only do so with this more specific type of bind
04:49:23 <ertes-w> liste: callCC (as it's called in haskell) isn't even that useful with ContT, because there are usually better ways to achieve what you need =)
04:49:52 <ertes-w> liste: it's more useful in scheme, because it's really the only way to even access continuations
04:50:35 <liste> ertes-w: thanks!
04:51:51 <mpickering> "hoistScope2" should be  "hoistScope :: (forall x . f x -> g x) -> Scope c f a -> Scope c g a"
05:23:19 <stevenxl> in a cabal project, at the root dir, is the idiomatic directory name api-tests ApiTests, apiTests, or something else?
05:23:53 <stevenxl> nevermind
05:23:54 <stevenxl> https://wiki.haskell.org/Structure_of_a_Haskell_project#Directory_Structure
05:24:04 <stevenxl> looks like apitests would map to what that wiki call testsuite
05:25:35 <hexagoxel> that wiki structure does not separate lib/exe hs-source-dirs, though.
05:26:46 <hexagoxel> (and GHC as a references is strange, as it uses a rather advanced build-system..)
05:27:32 <eman0n> :t curry
05:27:34 <lambdabot> ((a, b) -> c) -> a -> b -> c
05:27:41 <eman0n> long live lambda bot
05:28:56 <stevenxl> hexagoxel: So you don't suggest I name it apitests ?
05:32:20 <ph88> how can i make this function so that i can give it an empty list ?  https://bpaste.net/show/ca4d82059208
05:33:06 <hexagoxel> stevenxl: eh, it is fine. test/api/ would be nice if you later decide to add another suite.
05:33:39 <stevenxl> hexagoxel: that's what i'm doing actually so I'll change it to that.
05:33:42 <stevenxl> Thansk. 
05:36:28 <cocreature> ph88: you can’t do that if you want to keep it polymorphic. you’ll need to provide an explicit type annotation.
05:36:46 <ph88> REALLY ? omg :/
05:37:01 <cocreature> ph88: well how do you expect GHC to figure out which instance it should use?
05:37:06 <ph88> it's to generate a html table so sometimes i want to pass strings and sometimes Int and sometimes Double and a lot of types
05:37:31 <Psybur> Anybody have an idea on how to turn a ConduitM i o m (f r) into a ConduitM i o m r :D?
05:37:31 <ph88> who cares which instance to use if the list is empty? :|
05:37:42 <cocreature> GHC does :)
05:37:48 <ph88> the basterd :P
05:37:54 <ph88> any way to trick ghc into it ?
05:38:52 <ph88> some extension, some unsafe function ..
05:39:09 <ph88> "disable type checker here please"
05:39:13 <hexagoxel> type annotation is not so bad, "htmlTable@Int"
05:39:48 <cocreature> if you really find yourself using that very often, just make a separate function that’s not polymorphic and doesn’t accept the first parameter
05:40:59 <ph88> htmlTableStringInt htmlTableStringDouble  like that ?
05:41:19 <cocreature> no htmlTable' :: Markub b -> [[b]] -> Html
05:41:33 <cocreature> eh *Markup b =>
05:41:38 <ph88> what about the first parameter ?
05:41:51 <hexagoxel> "htmlTableNil"
05:42:08 <cocreature> ph88: that function behaves as if you pass an empty list to htmlTable
05:42:14 <cocreature> so there is no need for the first parameter
06:04:02 <angerman> who's up for some Cross Compiler Testing?
06:04:28 <angerman> (e.g. install cross compiler bin lists, and tell me how badly they break?)
06:05:50 <cocreature> angerman: do I need to posess some target device?
06:06:11 <angerman> would be useful to run the binary. But not necessarily to build the binary.
06:06:30 <angerman> new linux and macOS bin dists are available on http://hackage.mobilehaskell.org now.
06:14:04 <cocreature> angerman: I’m confused. I downloaded the aarch64 android bindist since that would be the target architecture that I have a device for but ./configure says that build, host and target are inferred as aarch64-unknown-linux-android so I guess that’s not the bindist I should use?
06:14:37 <angerman> cocreature: ./configure --prefix=... && make install should be fine.
06:15:21 <angerman> cocreature: should put some aarch64-unknown-linux-android-ghc into that folder :)
06:15:47 <angerman> cocreature: and that binary should run on your x86_64 arch.
06:16:29 <cocreature> angerman: configure seems to run through http://sprunge.us/UKOP but "make" is telling me I need to run configure
06:17:52 <angerman> ohh great... is that configure script that ends up in the bin dist botched? stupid build system.
06:19:17 <cocreature> it might very well just be me being incredibly stupid :)
06:19:58 <angerman> so you got http://hackage.mobilehaskell.org/x86_64-linux/aa5f532/ghc-8.3.20171020-aarch64-unknown-linux-android.tar.xz, and unpacked it, ran ./configure --prefix=... and make install? and it fails at configure.
06:20:19 <cocreature> yep
06:21:00 <skm_baig> hi, can anyone let me know what is the practical significance of "Just" something rather than a bare value?
06:21:20 <mniip> skm_baig, being able to not have the value
06:22:16 <skm_baig> mniip: wouldn't we use a Maybe for that?
06:22:31 <mniip> Just is a constructor of Maybe...?
06:22:57 <cocreature> "Maybe a" is the type, "Just x" is a value of type "Maybe a" if "x" is of type "a"
06:24:03 <ertes-w> skm_baig: in other words: a value of type (Maybe a) can be in one of two shapes:  Nothing, or (Just x), where (x :: a)
06:24:46 <mniip> if only there was a more concise way to say that, oh wait
06:24:49 <mniip> @src Maybe
06:24:49 <lambdabot> data Maybe a = Nothing | Just a
06:24:59 <angerman> cocreature: hmmm looks like the stupid ghc renaming breaks the triple. Turns "aarch64-unknown-linux-android" into "aarch64-linux-android", and then fails, because the "unknown" vendor becomes "linux", and "linux-android" becomes "android"... what a mess.
06:25:21 <Skm_> cocreature: in ghci, :t Just returns "Just :: a -> Maybe a".
06:25:37 <cocreature> Skm_: so?
06:25:46 <angerman> cocreature: can you try ./configure --target=aarch64-unknown-linux-android --prefix=...
06:26:26 <ertes-w> Skm_: Just serves two purposes: as a constructor for pattern-matching (when analysing a Maybe-value), and as a function to construct Maybe values
06:26:37 <ertes-w> you're looking at the type of the Just *function*
06:26:59 <mniip> hypothetically if we get dependent types Just could be a pattern as well
06:27:11 <cocreature> angerman: doesn’t seem to help http://sprunge.us/WAND
06:27:38 <mniip> you could have "foo :: (a '-> Either a a) -> Bool; foo Left = False; foo Right = True"
06:28:11 <benzrf> mniip: thats not what dependnt types do
06:28:30 <benzrf> that's totally orthogonal
06:28:31 <mniip> benzrf, that's one of the things they introduce
06:28:37 <benzrf> no it isnt!!
06:28:51 <benzrf> coq is founded on dependent types and you definitely cant match on function types
06:29:22 <mniip> well, have you seen goldfire's thesis on dependent haskell
06:29:29 <benzrf> no
06:29:42 <mniip> he introduces a distinction between matchable and non-matchable abstraction quantifiers
06:30:02 <mniip> (->, forall. and pi.)
06:30:04 <benzrf> oh - by "dependent types" you mean specifically a particular "dependent haskell"?
06:30:13 <mniip> eeeewelll yes
06:30:15 <benzrf> aight
06:30:20 <ertes-w> mniip: i'm pretty sure this could be done without DTs as well
06:30:33 <benzrf> bbl
06:30:50 <mniip> ertes-w, yes I suppose
06:31:41 <mniip> though if haskell gets DT, and synonymizes functions with type families then you have a problem
06:31:53 <mniip> because functions can be partially applied and type families can't
06:32:46 <rudol> http://lpaste.net/6346775513779929088   This little snippet was posted to https://stackoverflow.com/a/14179721 (and subsequently edited to compile) as a Reader Monad example.
06:32:52 <rudol> I am trying to learn about this, but before I get to Reader ... the code does indeed compile now, but if anybody is familiar with negamax, could you please confirm that this could not work as is - how would Game's getState possibly know what the negamax function wants First/SecondPlayer (re Win state) to mean? 
06:33:01 <rudol> And, there is a second thing re the use of "color" (representing player) to also mean fitness/score/valuation which I think may be causing a 2nd problem. I would appreciate any thoughts.
06:38:40 <angerman> cocreature: ohh that does look a bit better already :)
06:38:52 <angerman> cocreature: can you try ./configure --target=aarch64-unknown-linux-android --build=x86_64-pc-linux-gnu --host=x86_64-pc-linux-gnu --prefix=...
06:39:10 <rudol> So, I guess a more direct first question would be, in http://lpaste.net/6346775513779929088, how would Game#getState know what the negamax function is currently expecting to represent FirstPlayer in FirstPlayerWin? Is there some Reader bind magic that I have not appreciated? 
06:39:16 <angerman> (yes, that *is* stupid to have to pass all those... but hey... early days...)
06:40:52 <rudol> s/magic/"magic"
06:41:16 <cocreature> angerman: we seem to be making progress, now it’s complaining about not finding "ar" http://sprunge.us/FVXh
06:42:12 <angerman> cocreature: ahh, yes. You need to clone https://github.com/zw3rk/toolchain-wrapper, and run ./bootstrap in it. And then put it into $PATH
06:42:26 <angerman> cocreature: and you'll need the android SDK :-)
06:42:29 <angerman> NDK.
06:42:58 <cocreature> ah I thought I had to put the bootstrap script in my PATH
06:43:50 <angerman> no. the bootstrap script *generates* the symlinks to the `wrapper` script.
06:44:04 <angerman> e.g. <triple>-ar and friends.
06:45:37 <rudol> would using State here, instead of Reader give any benefit in this case?
06:46:12 <cocreature> angerman: the bootstrap script produced "aarch64-linux-android-ar" but "configure" is searching for "aarch64-unknown-linux-android-ar"
06:46:29 <angerman> welp.
06:47:25 <angerman> cocreature: what happens if you provide --target=aarch64-linux-android to configure?
06:47:47 <angerman> this GHC triple naming stuff is awful. Why didn't we simply stick with the auto tools naming...
06:48:10 <cocreature> angerman: success!
06:48:46 <angerman> cocreature: could you just check that you can compile `main = putStrLn "Hello World"`, and the compiler doesn't just segfault?
06:49:05 <angerman> not that you would able to run the resulting binary... but that's a different story.
06:49:26 <thoughtpolice> All this cross compilation nonsense makes me glad I have an AArch64 machine that's powerful enough to just compile GHC itself, for all my needs.
06:50:14 <rudol> is there an alternative realtime forum I can get some advise on this?
06:50:32 <rudol> s/advise/advice
06:51:39 <cocreature> angerman: well the good news is it didn’t segfault http://sprunge.us/PiPZ
06:51:50 <cocreature> rudol: just stick around for a bit and ask again in an hour or so
06:52:27 <angerman> thoughtpolice: awe... thanks?
06:52:59 <thoughtpolice> angerman: You're braver than I am :) But I also don't need direct mobile device support...
06:53:01 <angerman> cocreature: well. that looks like the NDK is missing or not in the correct place :)
06:53:25 <cocreature> angerman: I did install something that claimed to be the android ndk :)
06:54:06 <angerman> cocreature: there is the android.toolchain file in the toolchain wrapper folder, which might not point to the right place.
06:54:31 <rudol> cocreature I tried about 12 hours ago too. But thanks - I assume there's nothing inappropriate about the question then, or trying the same question again here when people are less preoccuppied.
06:54:32 <angerman> cocreature: toolchains are a mess, unless you ship everything together. But I didn't feel like bundling android+llvm+ghc.
06:55:23 <angerman> thoughtpolice: thanks! Yes. this is kind of a specific use case. And if you can run host native, there's certainly less use for cross compilation. (Unless you want to stay away from the host/os combination :-)
06:57:07 <rudol> here's the code again that I am trying to make work, in case anybody gets a chance to take a look in the meantime, ta.
06:58:50 <cocreature> angerman: hm, that changed the error message somewhat http://sprunge.us/RjRT
07:03:50 <angerman> cocreature: ahh. so you are missing iconv. I should probably package that up as well. The udiv and clear_cache stuff looks a bit suspicious right now.
07:04:23 <cocreature> angerman: sorry I’m not being more helpful here :/
07:05:18 <angerman> cocreature: that's alright. I just wanted to know that the very basics did work. Consider this some alpha pre-release :)
07:05:55 <angerman> the -lgcc, stuff is likely some ndk mismatch.
07:19:43 <jchia_> I'm trying to use Haskell to generate code that I can run from C/C++, so probably a .so dynamic library. The code that I want to generate simply takes some input value at run-time and calculates some output values using a DAG where each node is some primitive operation. It's like an expression tree except that there are multiple inputs and outputs and it's a DAG instead of a graph. I think I could generate the C++ source code, but maybe
07:19:43 <jchia_>  there's a better way, e.g. using LLVM. Any suggestions about which packages I can use to accomplish this? cocreature: Any comments on whether llvm-hs is suitable for this?
07:20:32 <jchia_> s/DAG instead of a graph/DAG instead of a tree/
07:21:06 <jchia_> I already have the DAG expressed in Haskell.
07:22:42 <angerman> cocreature: thanks, with your help I've now written up the following: https://medium.com/@zw3rk/ghc-cross-compiler-binary-distributions-490bb2c0c411 :D
07:23:14 <EvanR> angerman: ive been successfully compiling anything not involving lens on rpi!
07:23:24 <hodapp> progress \o/
07:24:07 <angerman> jchia_: you want to call your haskell function from C/C++ or do you want to "produce code with haskell" to link with and run with C/C++? 
07:24:25 <angerman> EvanR: lens requires TH? I don't remember right now.
07:24:26 <jchia_> angerman: I want to produce code with Haskell that C++ can call.
07:24:30 <jchia_> Probably a dynamic library
07:24:41 <angerman> jchia_: so you want to build a compiler?
07:24:54 <EvanR> this is non cross compilation so it doesnt matter
07:24:56 <angerman> EvanR: using the provided binary distributions?
07:24:57 <jchia_> angerman: Sort of, for my specific domain.
07:25:08 <EvanR> its compiling directly on there
07:25:09 <angerman> EvanR: ahh "on". sorry.
07:25:17 <angerman> my bad. I failed to read that right.
07:25:30 <EvanR> of course, i cant use a lot of stuff 
07:25:43 <jchia_> angerman: I say sort of because I'm not planning to generate the assembly myself.
07:26:08 <angerman> jchia_: hmm. Yes. maybe llvm-hs is an option.
07:26:38 <EvanR> so im sort of thinking moving the SDL stuff into a separate process programmed in C
07:26:42 <angerman> or you could just build an interpreter ...
07:26:50 <EvanR> but it would be a lot more convenient to use just haskell
07:28:19 <jchia_> angerman: Interpreter in C++? I expect that would require a similar amount of work as writing a compiler in Haskell.
07:29:35 <angerman> jchia_: except, you can just build the haskell library with ghc, and link that with c/c++.
07:29:56 <angerman> And you wouldn't need to produce any intermediate or assembly code :)
07:30:53 <jchia_> angerman: Doesn't it mean that when C++ runs the haskell code, the GHC runtime needs to be involved along with GC, etc? That may be too slow for my application. This is for a soft-realtime application.
07:32:19 <theobromine> is there an idiomatic way to go from haskell types to json and back?
07:32:24 <jchia_> angerman: I thought of generating C++ source code with Haskell. I'm trying to investigate what benefits I can get with llvm-hs.
07:32:57 <jchia_> theobromine: aeson has ToJSON & FromJSON
07:33:26 <theobromine> does it Just Work?
07:33:42 <angerman> jchia_: yea. cocreature is likely your best bet.
07:34:00 <angerman> jchia_: https://twitter.com/rightfold/status/829808427421593601 SCNR :)
07:35:10 <jchia_> angerman: I wish I could use Haskell for everything, but that day hasn't come yet.
07:35:45 <cocreature> jchia_: you are aware that you can call Haskell libraries from C/C++ right?
07:36:15 <theobromine> jchia: have you tried rust?
07:36:28 <jchia_> cocreature: I'm under the impression that that involves using the RTS and GC. Is that right? I cannot tolerate > 100us latency.
07:36:50 <theobromine> jchia_: you really should look at rust based on what you are saying
07:37:09 <jchia_> theobromine: Still, I have an expression graph at hand to translate into something.
07:37:33 <cocreature> jchia_: right I was just checking you have a good reason to generate code over just calling a Haskell lib :)
07:37:37 <Cale> jchia_: There's an llvm binding for Haskell.
07:37:43 <jchia_> theobromine: The libraries I need to use, unfortunately are all in C++.
07:37:55 <Cale> https://hackage.haskell.org/package/llvm
07:38:02 <theobromine> jchia_: https://github.com/Geal/nom ?
07:38:09 <geal> ohai
07:38:09 <cocreature> Cale: that package is dead
07:38:32 <foojin> Hello everyone. Does prepending an equation with a "constant-like" pattern (which would never match) to the list of equations make the function as a whole strict in the corresponding argument?
07:38:36 <foojin> If not, why something like let { f _ 0 = undefined; f x _ = x } in f 1 <$> [1,2,3,undefined] prints three ones even though the second argument is unused in the second equation?
07:38:44 <theobromine> jchia_: how many libs and what
07:38:46 <Cale> cocreature: Oh what, really?
07:39:02 <jchia_> Cale: Last updated in 2013
07:39:04 <Cale> oh, yeah
07:39:07 <Cale> llvm-general
07:39:13 <Cale> https://hackage.haskell.org/package/llvm-general
07:39:14 <Cale> this one
07:39:19 <cocreature> that one is dead too :)
07:40:07 <cocreature> https://hackage.haskell.org/package/llvm-hs is the one that’s still being maintained (disclaimer: I’m the maintainer :))
07:41:59 <Cale> ah :)
07:42:18 <cocreature> jchia_: llvm-hs should definitely be suitable for code generation. whether it’s easier to use than generating C code depends on how easy it is to map your code to C (LLVM gives you more flexibility) and how familiar you are with LLVM.
07:43:02 <cocreature> jchia_: as to benefits: LLVM has clearer semantics, a proper type system and you can do things like JIT your LLVM IR on the fly
07:43:41 <Cale> foojin: It turns into a guard that tests for equality, so yes.
07:43:41 <black0range> Hey if i wanna make a stack project with ghcjs but keep both the client and server in the same package. Is it possible to tell stack to only build one of the "executables"
07:44:09 <Cale> foojin: that'll be like  f _ y | y == 0 = undefined; f x _ = x
07:47:19 <jchia_> cocreature: Thanks. Since LLVM is so low-level (the language looks like assembly language to me), it seems that I will miss out on optimization opportunities that a C++ compiler could provide on high-level code?
07:48:07 <foojin> Cale: Thanks.
07:49:00 <cocreature> jchia_: clang does pretty much no optimzations on the C code level and everything on LLVM. for C++ it probably does a bit more on that level but the bulk of the work is still in LLVM
07:49:52 <cocreature> clang doesn’t even bother preserving loop information from C and instead searches for loops in LLVM
07:56:12 <jchia_> cocreature: OK. I need to learn LLVM some time.
07:56:53 <cocreature> jchia_: LLVM is definitely worth learning imho but tbh if it’s easy to map your code to C that’s a reasonable solution and is probably simpler than having to learn LLVM :)
07:57:25 <jchia_> cocreature: Yeah, that's what I think. LLVM presents a learning curve for me whereas C/C++ doesn't.
08:28:22 <lyxia> mpickering: I'll take a closer look at the problem over the weekend.
08:39:41 <rudol> As previously mentioned, whilst looking for non-trivial Haskell Reader Monad use-cases I came across http://lpaste.net/6346775513779929088 (SO url inlined - a little negamax impl). The code compiles. Can someone give me a hand to understand how Game#getState could possibly know what the negamax function expects to be "First Player" (as in the GameStates  FirstPaleyerWin etc)? Or more simply, how would you write getState to make that 
08:41:17 <radone> Hello, 
08:41:54 <EvanR> rudol: a Reader is simply an extra argument passed in
08:42:21 <radone> Trying to run quickCheck in prelude and having "Variable not in scope: quickCheck :: (Int -> Bool) -> t" error 
08:43:01 <radone> shouldn't quickCheck be available ?
08:43:11 <EvanR> rudol: besides that, im not sure i understand your question
08:44:21 <radone> and when I try to :load it it says <no location info>: module `Test.QuickCheck' is a package module  Failed, modules loaded: none.
08:45:31 <radone> (:m fail as well)
08:45:42 <rudol> EvanR - that negamax impl attributes some meaning to PlayerFirst and PlayerSecond. It gets the related GameState    (FirstPlayerWin, for example) from Game#getState
08:46:27 <rudol> I do not see how getState can know what negamax is considering to be First or Second Player
08:48:27 <rudol> since negamax traverse the tree of all moves to the end of each line, from that impl, and it alternates between "color" at each level of the tree, how would gameState know who negamax is calling FirstPlayer. Does that make more sense?
08:49:39 <rudol> if you try to implement getState, in the case where there is a winner, how do you answer the question: who won, First or Second Player?
08:49:43 <EvanR> not really. you are essentially getting the Game, then getting the GameState from that
08:50:07 <EvanR> it uses getState, which gives a GameState, which is a single flat value
08:50:16 <rudol> yes, and the Game knows if there is a winner, say X or O, or a Tie or if the game continues
08:50:25 <EvanR> yeah
08:50:43 <rudol> but how does it know who negamax is calling First Player?
08:51:11 <cocreature> Game doesn’t know if there is a winner. Game just has a function getState that given a position can tell you the winner
08:51:31 <rudol> yes, I should have said Game's getState function
08:51:56 <EvanR> how does "what" know what?
08:52:21 <rudol> so, say getState knows that X wonin position 1, how does it know what negamax wants back (is First or Secon Player Win?) 
08:52:23 <cocreature> I think it might be helpful if you rephrase your question without “know”. that only makes things more confusing
08:52:43 <EvanR> haha
08:53:01 <EvanR> how does getState... know... what negamax.. wants
08:53:11 <cocreature> rudol: are you asking how the code you’ve shown us works or if it works at all?
08:53:12 <EvanR> these functions are very needy
08:53:43 <rudol> if X has won, getState can work that out. But shoud it set the GameState that negamax is asking for to First or Secon PW?
08:53:45 <theschmitzer> Hi I'm having a layout problem can someone suggest correct order/layout http://lpaste.net/3570914343371407360
08:54:00 <EvanR> oh, is the naming bad? X vs First, O vs Second, ?
08:54:05 <rudol> cocreature - I am questoining whether it can work
08:54:17 <EvanR> when i did tic tac toe, i called it PlayerX and PlayerO
08:55:39 <rudol> EvanR - well there are a few things actually, but ... are you saying that First Player is always X (assuming X always starts)?
08:55:40 <EvanR> who goes first is really arbitrary, or an additional layer of rules
08:56:00 <EvanR> no im not
08:56:12 <EvanR> im suggesting a renaming so its less confusing, more explicit
08:56:46 <EvanR> how do we "know" who goes first?
08:57:05 <rudol> but is that maintining the semantics. I thought negamax is calling the player to move at the current root node First Player (so could be X or O, regardless of who staed the game) 
08:57:33 <EvanR> i dont see X or O anywhere
08:57:47 <rudol> it claims to be a generic negamax
08:57:56 <rudol> so no X and O 
08:58:16 <EvanR> color is a double? o_O
08:58:54 <rudol> EvanR - that's a second issue - color's semantics are overloaded
08:59:01 <rudol> but first ...
08:59:25 <cocreature> rudol: afaict first and second player stay constant
08:59:30 <cocreature> so they don’t swap in each iteration
08:59:58 <cocreature> hm or maybe they do
09:00:05 <cocreature> it’s been too long since I’ve looked at negamax
09:00:15 <rudol> I think you see my question now
09:00:57 <cocreature> rudol: one solution would be to encode the current player in the position
09:01:02 <rudol> line 28 at http://lpaste.net/6346775513779929088  seems to expect that getState would return the "right" First or Second PW GameState
09:01:06 <Psybur> Anybody happen to have an article on running an rwst on a conduit? :D
09:01:08 <rudol> right, 
09:01:22 <cocreature> and then getNext takes care of swapping the player
09:01:31 <rudol> but I am trying to see if http://lpaste.net/6346775513779929088 could possibly work
09:01:52 <cocreature> you don’t need to change that code to do that
09:01:54 <rudol> well, get next is easier (depending on the game, that may be derivable from the position)
09:01:59 <cocreature> it’s up to the Game to do this
09:02:34 <rudol> well not really - if there are 3 Xs and 3 Os, in TTT for example, who's turn next?
09:02:47 <cocreature> e.g. for tic tac toe define a type that stores the board and the current player, then define getNext such that it always swaps the current player
09:02:57 <cocreature> throw that into this algorithm and everything works out
09:03:11 <rudol> but how does getState know the current player?
09:03:17 <cocreature> from the position
09:03:26 <rudol> pls seee above
09:03:31 <rudol> f there are 3 Xs and 3 Os, in TTT for example, who's turn next?
09:04:09 <rudol> or in Chess, if nobody is in Check, who's turn is it?
09:04:15 <cocreature> rudol: "data Field = Empty | X | O; data Position = Position [[Field]] CurrentPlayer"
09:05:02 <cocreature> tttGame :: Game Position; tttGame = Game { getNext = …; getState = \(Position fields currentPlayer) -> _ }
09:05:15 <rudol> cocrature, I agree that would be useful. But I am first trying to establish if http://lpaste.net/6346775513779929088 could possibly work?
09:05:20 <Ferdirand> in TTT, if there are 3 Xs and 3 Os, by convention, it is X's turn next
09:05:22 <Ferdirand> since X starts
09:05:33 <cocreature> rudol: you don’t need any changes to that code to use what I just wrote
09:05:43 <rudol> TTT is a read-herring ;)
09:05:53 <cocreature> rudol: that code allows you to use an arbitrary definition of position. including the one I just showed that stores the current player
09:06:13 <cocreature> the code delegates the responsibility of keeping track of the player and swapping it to the Game
09:06:37 <rudol> OK, so then negamax would include next player in the params to getState
09:07:59 <rudol> ie that info is in Position
09:08:27 <cocreature> rudol: take a look at http://lpaste.net/4251388358791528448
09:08:39 <cocreature> you get access to the current player in the definition of getNext and getState
09:08:44 <cocreature> and the existing code is completely unchanged
09:09:06 <cocreature> (I’m too lazy to actually implement next and state :))
09:09:41 <cocreature> you can then call "negamax 1 (Position emptyField First) tttGame"
09:10:30 <rudol> cocreature, that's nice, thanks. Does that assume that negamax always assumes First Player is X?
09:10:48 <rudol> (wrt to line 28)
09:11:37 <cocreature> no you could just as well call "negamax 1 (Position emptyField Second) tttGame"
09:11:42 <rudol> it seems that color is being abused on line 32 too (although I can see the idea behind it - it is being used as the fitness function)
09:11:56 <cocreature> I should probably have named First and Second PlayerX and PlayerO
09:11:58 <cocreature> bbl
09:12:20 <rudol> but that ties you to TTT type games
09:12:50 <cocreature> I don’t mean to change GameState, I mean to change the definition of CurrentPlayer that I use to define tttGame
09:13:07 <EvanR> PlayerA PlayerB
09:13:28 <EvanR> PlayerEast PlayerWest
09:13:37 <EvanR> hehe
09:13:40 <rudol> I get that point, but ...
09:14:18 <rudol> I will try again to see if I can get negamax and getState to talk the same protocol (in terms of what First and Second PW mean)
09:15:43 <rudol> I had previously tried a similar idea to cocreature's but I still could work out which GameState getState should return, because it seemed to me that negamax had a different interpretation of First and Second at every call 
09:16:03 <rudol> (I should say, on every call to *it*)
09:24:19 <Psybur> Does anybody know how to search github's source code? Trying to find an example of using rws in conduit. Im so close, theres execRWSC but I cant quite get it :D
09:37:28 <Psybur> Love that feeling when you get something to compile and you have no idea how you did it :D
09:42:04 <amf> if i wrap a computation in Control.Exception.try, am i gauranteed that an call to `error` will be caught?
09:47:44 <Gurkenglas> Requesting "Monad m => StateT (s1, s2) m a -> StateT s1 (StateT s2 m) a".
09:52:26 <c_wraith> amf, usually not. try only catches thing raised during the execution of the IO action
09:52:57 <c_wraith> amf, in many cases, calls to error will be hidden inside things not evaluated while executing the IO action
09:55:54 <Gurkenglas> Why is Data.Seq.viewl not Seq a -> Maybe (a, Seq a)?
09:57:51 <c_wraith> Gurkenglas, there's nothing wrong with using local types.
09:59:04 <Gurkenglas> It makes me unable to use the interfaces other libraries provide, such as Control.Monad.Loops or StateT (the latter through the absence of a MonadPlus instance)
09:59:48 <c_wraith> Gurkenglas, also, the combination of ViewL and ViewR is nice, because they're otherwise isomorphic to each other structurally, but with opposite semantics
09:59:53 <amf> c_wraith: i suspect my code is hitting an exception, or some other unlogged reason. despite having most of my code wrapped in SlaveThread's forkFinally
10:00:38 <Gurkenglas> In my world, viewr would have the same type as viewl
10:00:56 <c_wraith> Gurkenglas, yes, that's what I'm suggesting is misleading
10:02:36 <Gurkenglas> Yep, the interpretations of "left data, right state" and representing relative position clash. The former butters interfaces, the latter makes pretty code.
10:02:44 <c_wraith> really, though, that family of functions is actually the poster child for pattern synonyms.
10:03:43 <cocreature> these days there are pattern synonyms for this
10:06:19 <Gurkenglas> Doesn't restore the tidyness of StateT uncons
10:08:56 <Psybur> Anybody happen to know how to skip a line using conduits? dropC 1 seems to just destroy everything :D
10:09:41 <cocreature> Psybur: what do you mean by “destroys everything”
10:09:53 <Psybur> I get no output
10:10:03 <Psybur> If I remove the dropC 1 I get all the lines
10:10:10 <Psybur> If I add it back in, nothing
10:10:33 <cocreature> you’ll have to show us some code
10:10:48 <Tuplanolla> ...and by some he means all.
10:11:30 <cocreature> well at least the relevant parts :)
10:12:50 <Gurkenglas> WriterT with listen usually sounds to me like it should be StateT, but is (`runStateT` mempty) the usecase for it?
10:16:35 <Psybur> cocreature, https://pastebin.com/PG4L6C2z
10:16:47 <Psybur> Thats a ghci session
10:17:01 <Psybur> First line you see gives no output, second one gives output
10:17:09 <mnoonan> is there a way I can manipulate the order of libraries passed to the linker? (or even see the exact link line that ghc is using?)
10:18:59 <cocreature> Psybur: use "dropC 1 >> printC"
10:19:32 <Psybur> cocreature, also no output
10:19:55 <cocreature> Psybur: I tested this and it works. what exactly is the code you’re running?
10:20:14 <cocreature> Psybur: eh add parentheses around this
10:20:37 <Psybur> Ok, that worked
10:20:46 <Psybur> thx
10:20:54 <Psybur> I guess I need to figure out what >> is :D
10:21:02 <cocreature> :t (>>)
10:21:04 <lambdabot> Monad m => m a -> m b -> m b
10:21:07 <cocreature> it’s not specific to conduit
10:21:24 <cocreature> x >> y = x >>= \_ -> y
10:21:27 <amf> does `error` only halt the current thread?
10:21:37 <cocreature> amf: yes
10:23:19 <cocreature> Psybur: basically "dropC 1" is a conduit that consumes one element and then stops. but since you’re adding it somewhere in the middle of your pipeline the whole pipeline stops at that point. what you need is something that continues after dropping one element
10:23:35 <cocreature> >> combines two conduits such that the second runs after the first has finished
10:24:19 <rudol> cocreature and co, I tried your suggestions: http://lpaste.net/5632170402575810560 . If I managed to implement what you meant, can you see why this still does not give the expected results? The game is, start with 0, each player can add 1 or 2. Player making pot 5 wins. 
10:24:40 <rudol> you can just copy paste and run main
10:27:40 <Eduard_Munteanu> amf, error results in an exception. If your threads are linked to throw further exceptions like with 'async', more threads may die.
10:28:45 <amf> i think something is calling error in main, but my worker threads are correctly handling it
10:29:03 <rudol> by my calculation, first player always wins by starting with move " add 2"
10:32:21 <rudol> but negamax says -0.0, ie Tie. cocreature - am I flipping CurrentPlayer the way you envisaged?
10:34:44 <rudol> runF0 means player First starts, and the game starts with "pot" 0. runS0 means Second starts.
10:37:55 <erisco> reminds me of a game called "ten" in which two or more players take turns adding 1, 2, or 3, and the player who is forced to say "ten" (you cannot add to a higher number than this) loses
10:38:29 <erisco> though it was actually called "dix" and this was a way they fooled us into learning French
10:39:41 <rudol> erisco, I just invent this one, we can call it cinq, just to test this negamax inpl I have suspisions about (my main aim was to get some Reader <onad practice, btw ;)
10:41:16 <rudol> but it could be that I have not implemented the Game record functions correctly (hopefully I got next right!) at http://lpaste.net/5632170402575810560#line45
10:42:11 <erisco> the player who says neuf wins, so the player who says six, sept, or huit loses
10:42:41 <erisco> therefore the player who says cinq wins, so the player who says deux, trois, or quatre loses
10:42:58 <erisco> so the player who says un wins
10:43:01 <rudol> erisco - yours is way too advanced - I just made up the simplest possible game to test this negamax impl I found
10:43:53 <erisco> lets play… un
10:44:12 <erisco> gg
10:44:19 <rudol> in "my" game, you can add 1 or 2 to the pot. Pot starts at 0. Whoever gets the pot to 5 wins. very simple rules and gametree  - and very quick for any minimax (or negamax ) to resolve
10:44:39 <rudol> un
10:44:46 <erisco> damn
10:44:52 <erisco> you're too good!
10:44:58 <rudol> p1 has to plat deux
10:45:08 <rudol> and then he/she always wins
10:46:14 <rudol> but this negamax can't work it out, or my get... function impls in agame ( http://lpaste.net/5632170402575810560#line45 ) are not doig what negamax expects
10:46:37 <rudol> doig - I think that's what we should call this game!
10:46:44 <eschnett> does someone have an example of an interesting contravariant functor that is not (->)?
10:46:53 <erisco> in your game, the player who says 4 wins, so the player who says 3 or 2 loses, so the player who says 1 wins, which the first player to play can do
10:47:05 <eschnett> i find it difficult to design one since contramap essentially requires storing a function.
10:47:12 <rudol> no ericso, that's in your game ;)
10:47:27 <rudol> in doig, the first to make the pot 5 wins
10:47:38 <erisco> oh I see, they're the winner, well in that case
10:47:41 <rudol> see the code for the rules ;)
10:47:55 <rudol> it's 2 lines
10:48:15 <cocreature> rudol: I think you are outputting the wrong winner: for a winning game you have "[Position First 0, Position Second 2, Position First 3, Position Second 5]" and now you say Second has one but it was First who made the turn
10:48:20 <erisco> the player who says 5 wins, so the player who says 4 or 3 loses, so the player who says 2 wins, so the player who says 0 or 1 loses
10:48:26 <erisco> meaning the second player always wins
10:48:31 <cocreature> so if the current position is won it’s the other player that has made the turn
10:48:55 <erisco> okay, you first :)
10:49:31 <cocreature> 2
10:49:48 <rudol> cocreature - exactly what I was wondering (as question 2 or 3) re that negamax - the first Double passed in to negamax looks more like player just moved than player to move - WDYT?
10:50:15 <rudol> player  represented by color (as Double)
10:50:21 <erisco> oh right, the pot starts at zero, I guess that is something different then
10:50:35 <erisco> 0 is not a valid move
10:50:53 <rudol> doig is a unique game - I never broke any copyright
10:50:56 <erisco> the player who says 2 wins, which the first player to act can do, so the first player always wins
10:50:58 <cocreature> rudol: just change it to http://lpaste.net/359403
10:54:39 <rudol> cocreature - looks promising - let me invent a more complex game and give it a shot. PS I like the way you analysed the problem to come up with a suggestion -thank you
10:57:08 <rudol> I invented a new game called doig-trois. Your fix works there too!
10:57:47 <rudol> Maybe I am better at inventing sophisticated games than at Haskell!
10:58:14 <cocreature> you just need to find some way to combine the two :)
11:00:24 <rudol> is there any downside to {-# LANGUAGE MultiWayIf #-}
11:00:51 <erisco> well, there's the if's
11:03:52 <jared-w> lol
11:04:12 <cocreature> you can take MultiWayIf from my cold dead hands
11:05:19 <rudol> I think it looks OK - I already discovered that I couldn't use | in a lambda after -> so I was not happy with the way my if block looked
11:07:30 <Boomerang> Hey! I have a function with type similar to [a] -> [b] that works lazily. I have some initial 'a's to feed into the function but then I would like to create new 'a's depending on the returned 'b's + some IO. How should I go about it? Multi-threaded, BChan, conduit, other? :)
11:09:17 <opqdonut> you can also just use laziness and recursion
11:09:25 <opqdonut> just like how people use interact
11:09:27 <opqdonut> :t interact
11:09:28 <lambdabot> (String -> String) -> IO ()
11:09:45 <jared-w> laziness + IO is usually something terrible waiting to happen :p
11:10:13 <opqdonut> oh right, I missed the "some IO" part
11:10:28 <johnw> btw, lazy I/O can be just the ticket sometimes
11:10:34 <johnw> it has an overly bad rep
11:10:53 <johnw> I recently rewrote some pipes code using lazy I/O, and it became FAR easier to read and reason about
11:11:04 <jared-w> oh sure, it can be exactly what you want. But only sometimes :p
11:11:29 <jared-w> just out of curiosity, though, why was the lazy IO version much easier to read and reason about? What made that better than the pipes solution?
11:11:40 <Boomerang> I have thought about interact but I'm not sure how I could make something similar with IO along the way
11:12:03 <johnw> because I was able to write it monadically in I/O and if I were just looping over a lazy input with a (while !eof) type loop
11:12:17 <johnw> err /as if/
11:12:28 <johnw> one sec, I'll show you
11:12:31 <cocreature> I buy “easier to read” but “easier to reason about” seems questionable
11:12:50 <Boomerang> If I can move away from lazy IO I'd be happy but I'm stuck with this infinite list to infinite list interface
11:12:54 <johnw> I meant: the logic of what was happening was much clearer
11:13:03 <Boomerang> s/can/could
11:14:04 <jared-w> Boomerang: do streaming libraries not work with infinite list style interfaces?
11:14:30 <jared-w> I thought one of the whole points of a stream type is that it's basically a non-finite list?
11:14:35 <johnw> here are the two versions: https://gist.github.com/jwiegley/4e24d31e483ba7b6b869e82d486cf208
11:14:36 <Boomerang> Yeah conduit has a list interface, I'm just not too sure if that fits my problem. I have never used conduit before
11:14:38 <EvanR> theres a better lazy stream than literally list for doing lazy IO
11:14:53 <EvanR> so you can detect and react to errors
11:15:55 <jared-w> But the pipes version is less lines and more terse! How on /earth/ is it less readable? /s
11:15:59 <johnw> haha
11:16:19 <johnw> really depends on how familiar you are with pipes-parse, pipes and pipes-binary
11:16:30 <johnw> the lazy I/O version is a simple "loop over the input data"
11:16:54 <jared-w> Well I've not used pipes yet, so I'll see if I can decode what the pipes one means
11:17:12 <johnw> also, it took me 2 hours to figure out how to even write the pipes one
11:17:22 <johnw> where the lazy I/O exactly matches my understanding of what's happening
11:17:50 <Boomerang> To give more details about my problem, I want that function to be run as part of/alongside a sdl loop when the 'a's would get some sdl inputs and the 'b' would help generate the next frame.
11:17:59 <johnw> and the type errors each time I got the pipes version wrong were impossible to understand
11:18:11 <johnw> p.s., I really like pipes and use it a lot
11:18:18 <johnw> I'm just saying that for some problems, lazy I/O is perfectly fine
11:18:21 <jared-w> So, stream from the stdout stdout... for the input, decode it, and chunk it into packet segments. Then if anything fails, output something in the stderr, otherwise encode the segment?
11:18:27 <EvanR> data LazyIOStream a e = Stuff a LazyIOStream | Error e | End
11:19:08 <Boomerang> s/sdl inputs/sdl events/
11:19:17 <jared-w> (that's what I got out of the pipes one); although the lazyIO one is clearer to me by a lot since it doesn't require knowing as much of the codebase to figure out what's happening
11:21:04 <hexagoxel> knot-tying via fixIO/mfix does not qualify as lazy IO though, does it? that seems to be sufficient for Boomerang's usecase.
11:21:46 <Boomerang> When I try mfix/mdo I get "thread blocked indefinitely in an MVar operation
11:22:00 <Boomerang> But that could just be something stupid I'm doing
11:23:19 <Boomerang> Then I moved on to using Chan and I am getting the same error
11:23:24 <johnw> show us code?
11:24:45 <int-e> mmm.
11:25:10 <hexagoxel> take 10 <$> mfix (\xs -> pure @IO (1 : xs))  ->  [1,1,1,1,1,1,1,1,1,1]
11:25:17 <Boomerang> http://lpaste.net/359405 run function is where it's happening
11:26:03 <Boomerang> That's the Chan version
11:26:55 <johnw> I don't see initializeAll
11:27:57 <hexagoxel> ah no, mfix is not sufficient in general. my bad.
11:29:06 <Boomerang> johnw: initializeAll is the first line of run :)
11:29:28 <johnw> what does it do?
11:29:33 <Boomerang> Did you mean the definition? It's in the sdl package
11:29:36 <johnw> ah
11:29:57 <Boomerang> It initialises the SDL environment, I thought you were saying I forgot to use it :)
11:30:10 <johnw> i don't see the problem
11:31:21 <cocreature> johnw: do you actually need "observe" in that piece of code? I didn’t even know that existed up until now and now I’m scared that I’ll rely on the laws somewhere and forget to use observe :/
11:31:34 <Boomerang> Basically the application runs for whatever input I give up front, so the function [a] -> [b] work and everything's fine up until I actually need to produce the 'a's dynamically in order to continue
11:31:43 <johnw> cocreature: observe is a local definition I didn't include because it's immaterial to the demonstration
11:32:02 <cocreature> johnw: oh I got confused because pipes has an "observe" function as well https://hackage.haskell.org/package/pipes-4.3.5/docs/Pipes-Internal.html#v:observe
11:32:03 <johnw> it just changes the prevailing state based on the which packets are being seen
11:32:24 <johnw> cocreature: ah
11:33:13 <johnw> if you use the safe api, you're OK :)
11:34:54 <cocreature> great :)
11:35:15 <cocreature> oh the docs even say that, I should learn to read properly
11:45:44 <stevenxl> Hi folks. I'm trying to use quickcheck but there are too libraries - quickcheck and test.quickechk.
11:46:27 <hexagoxel> Boomerang: maybe you want FRP. there is reflex-sdl2, even though it looks rather basic.
11:46:58 <cocreature> stevenxl: the package is called QuickCheck and the module is called Test.QuickCheck
11:47:04 <hexagoxel> Boomerang: but your problem seems to be that you don't provide any initial input. based on what input is the first output supposed to be created?
11:47:14 <stevenxl> cocreature: many thanks. 
11:47:16 <hexagoxel> (unless i miss something in that code)
11:47:16 <stevenxl> ;-)
11:47:23 <int-e> stevenxl: see also https://hackage.haskell.org/package/QuickCheck
11:47:39 <int-e> stevenxl: (which provides documentation of the package that may come in handy)
11:47:58 <stevenxl> int-e: will do
11:52:15 <Boomerang> hexagoxel: FRP might be the way to go, it seemed a bit heavy for such a simple project though. I am actually providing some initial input. 10 frames worth of input just to be on the safe side. After experimenting a bit with the timer it looks like it fails after only one frame though.
11:52:25 <Boomerang> Thank you all for your inputs! :)
12:00:43 <Psybur> using conduit gave me zero speedup. probably a slowdown :D
12:01:15 <Psybur> Guess I wasnt being so naive with my patterns after all D:
12:02:06 <Psybur> Actually, I take that back. I think in my sliding window I am recreating large vectors from scratch when I could probably just pass the vector around and pop the top and append the new value
12:02:21 <Boomerang> hexagoxel: I fixed it!!!
12:02:54 <Psybur> So hard to say if that blaring problem is overshadowing any help conduit may or may not have been :D
12:03:11 <Boomerang> Turns out my sdlPump function returning IO [Input] is not lazy :p
12:03:49 <Boomerang> I just had to move the writeChan part to be inside sdlPump
12:06:15 <matt-> Hi! Anybody know which package has the most standard (in your opinion) instance of `Pair a = Pair a a`?
12:06:51 <johnw> matt-: I've never yet used that type
12:07:22 <Boomerang> matt-: Do the packages provide nice functions to go with it? Otherwise just make your own :)
12:08:18 <johnw> sounds like the diagonal functor
12:08:28 <matt-> johnw: Yeah, me neither, but a coworker wanted to map over a tuple, so there you go. I can just define `Pair a = Pair a a deriving Functor` in our utils but we're trying to be enterprise, you know? If somebody is already maining some nice instances for it I'd rather just steal that.
12:08:33 <hexagoxel> Boomerang: nice, i guess that makes sense. not trivial to catch, i'd say :)
12:08:55 <johnw> matt-: i see, then he really wanted a diagonal functor
12:08:59 <matt-> Boomerang: Yeah, that's another way to ask it. Is there a package which has some nicely maintained functions for the type.
12:09:07 <matt-> johnw: is that right? Going to go look that up.
12:09:59 <matt-> johnw: How would you define that in Haskell?
12:10:10 <matt-> And how is it different from `Pair`?
12:10:12 <johnw> data Pair = Pair a a
12:10:12 <johnw> :)
12:10:19 <johnw> I'm just identifying the pattern your co-worker reached for
12:10:26 <johnw> it's not "a functor over a tuple"
12:10:37 <matt-> hehehe, yes indeed
12:10:56 <matt-> Was I misleading though?????????????
12:11:13 <matt-> I think we're on the same page.
12:11:18 <johnw> not at all
12:12:10 <johnw> do you guys use lens?
12:12:30 <matt-> Sparingly, but I'd love to know the lens solution if you have one.
12:12:34 <matt-> Wait, is that called `both`?
12:12:37 <johnw> there's also the Bifunctor instance for (a, a), where bimap offers what you'd want
12:13:07 <johnw> > (1, 2) & both +~ 3
12:13:10 <lambdabot>  (4,5)
12:13:10 <matt-> But then to map you do `bimap f f tuple` instead of `f <$> pair`.
12:13:25 <johnw> > (1, 2) & both %~ f
12:13:29 <lambdabot>  error:
12:13:29 <lambdabot>      • Ambiguous type variable ‘b0’ arising from a use of ‘show_M749181868543...
12:13:29 <lambdabot>        prevents the constraint ‘(Show b0)’ from being solved.
12:13:33 <matt-> Yeah, that was my _actual_ suggestion to my coworker, using bimap ;)
12:14:23 <matt-> > over both (+3) (1, 2)
12:14:26 <lambdabot>  (4,5)
12:14:30 <matt-> neat, thank you!
12:14:36 <MarcelineVQ> much import, very sadness
12:14:44 <MarcelineVQ> > let (<$$>) f (a,b) = (f a, f b) in (+1) <$$> (5,6)
12:14:47 <lambdabot>  (6,7)
12:15:31 <matt-> > :i (<$$>)
12:15:36 <lambdabot>  <hint>:1:1: error: parse error on input ‘:’
12:15:41 <johnw> he just defined it there
12:15:52 <matt-> ahh, thanks
12:15:52 <Tuplanolla> @let newtype Join f a = Join {getJoin :: f a a}
12:15:55 <lambdabot>  Defined.
12:16:03 <Tuplanolla> @let instance Bifunctor f => Functor (Join f) where fmap f = Join . join bimap f . getJoin
12:16:04 <lambdabot>  Defined.
12:16:52 <EvanR> window 21
12:17:13 <Tuplanolla> > (getJoin . fmap negate . Join) (42, 13)
12:17:15 <lambdabot>  (-42,-13)
12:17:28 <Tuplanolla> There's another way, matt-.
12:18:20 <matt-> Tuplanolla: very nice! I'm all ears
12:18:57 <johnw> matt- = Pair ear
12:19:04 <matt-> boooo
12:19:08 <Gurkenglas> > under (iso getJoin Join) (fmap negate) (42, 13)
12:19:10 <Tuplanolla> That was it.
12:19:11 <lambdabot>  (-42,-13)
12:19:49 <Tuplanolla> Your `lens` also provides the `ala` mechanism for this.
12:21:29 <Gurkenglas> I don't see it, implement pls?
12:22:45 <Tuplanolla> Here's hoping lambdabot can handle it.
12:23:03 <matt-> > ala Join negate $ (42, 13)
12:23:06 <lambdabot>  error:
12:23:06 <lambdabot>      • Couldn't match expected type ‘(Integer, Integer)’
12:23:06 <lambdabot>                    with actual type ‘Unwrapped (Join (,) Integer)’
12:23:09 <Tuplanolla> @let instance (t ~ Join b) => Rewrapped (Join a) t
12:23:10 <matt-> hmm
12:23:11 <lambdabot>  .L.hs:170:37: error:
12:23:11 <lambdabot>      • Expecting one more argument to ‘Join a’
12:23:11 <lambdabot>        Expected a type, but ‘Join a’ has kind ‘k0 -> *’
12:24:07 <Tuplanolla> @let instance (t ~ Join g b) => Rewrapped (Join f a) t
12:24:09 <lambdabot>  .L.hs:170:10: error:
12:24:10 <lambdabot>      • Could not deduce (Wrapped (Join f a))
12:24:10 <lambdabot>          arising from the superclasses of an instance declaration
12:24:42 <Tuplanolla> Oh, I need the other instance first.
12:25:22 <Tuplanolla> @let instance Wrapped (Join f a) where type Unwrapped (Join f a) = a; _Wrapped' = iso getJoin Join
12:25:23 <lambdabot>  .L.hs:171:37: error:
12:25:23 <lambdabot>      • Expected a type, but ‘a’ has kind ‘k’
12:25:23 <lambdabot>      • In the type ‘a’
12:25:36 <Tuplanolla> Whatever. Someone else figure it out.
12:28:17 <matt-> Cool tricks, Tuplanolla. Very educational, thank you. :)
12:28:17 <Gurkenglas> Tuplanolla, ala is au . _Wrapping, so you can submit a custom iso to au
12:28:31 <Gurkenglas> (also alaf vs auf)
12:30:50 <Cale> All the ala stuff is too memey for me to actually use.
12:31:27 <Tuplanolla> I never use it for anything proper either.
12:34:07 <carbolymer> I have weird issue with laziness, I have similar code: https://repl.it/MyoU/0 but I'm invoking infoL within RWST (with IO as inner) monad. The problem is that two invocations of infoL display the same timestamp (despite being run with the few seconds difference). Any ideas what is going on?
12:35:04 <carbolymer> on the repl.it or ghci it is not reproducible
12:36:35 <stevenxl> Hi folks. I needed to create an instance Arbitrary Text. (Arbitrary is a typeclass defined in QuickCheck).
12:36:37 <stevenxl> Is this cheating?
12:36:38 <stevenxl> http://lpaste.net/359406
12:38:09 <tom-md> No, building off of other instances is often the best way to go.
12:38:25 <tom-md> There can be higher-performance solutions sometimes but in cases like this it is rarely worth the effort.
12:38:51 <stevenxl> tom-md: :-)
12:39:02 <stevenxl> dang it feels good to write real haskell
12:40:17 <stevenxl> ok - back to r
12:40:23 <stevenxl> React*; gotta eat somehow
12:40:25 <geekosaur> carbolymer, seems to work here? what exactly are you doing that works vs fails? and what ghc version?
12:43:06 <carbolymer> geekosaur, yep, works on repl it. GHC 8.2.1
12:43:33 <geekosaur> no, I compiled it (with and without -O) here and then ran it in ghci. 8.0.2
12:44:59 <sm> is there a programmatic way to get the same stats shown by +RTS -S, eg somewhere in http://hackage.haskell.org/package/ghc ?
12:47:39 <carbolymer> geekosaur, hm, I am using it in backend of my webserver using servant
12:47:56 <carbolymer> could the threads spawned by servant be the issue? 
12:49:37 <geekosaur> possibly... and come to think of it, possibly in a tricky way
12:50:14 <geekosaur> I am wondering what happens if you mark the binding for infoL with {-# PRAGMA NOINLINE #-}
12:50:50 <geekosaur> really if you can;t rreproduce it with your example then the example isn;t good enough... but it's probably not helpful to provide the whole app, either
12:51:02 <geekosaur> minimizing test cases / examples is :(
13:02:25 <carbolymer> geekosaur, nope, i've tried marking with {-# NOINLINE #-} getLogger, but without success, also I am getting "Unrecognised pragma" when I'm using {-# PRAGMA NOINLINE #-} warning
13:03:58 <geekosaur> oh, needs th be told the binding (here, infoL) --- but now I owonder if it even works in that context :(
13:04:04 <geekosaur> sorry
13:05:48 <geekosaur> also I have this feelingI'm seeing the right possible issue but not the right way to fix it :(
13:06:19 <carbolymer> no prob
13:06:25 <carbolymer> at least you have that feeling ;)
13:07:33 <Psybur> So there is no faster way to append to a vector than snoc? :{
13:07:43 <Psybur> Am I stuck with O(n)?
13:07:58 <EvanR> yeah vectors are not for appending
13:08:29 <Psybur> hmm, its not like a java arraylist? :D
13:08:39 <EvanR> there is no magic
13:08:45 <Cale> Psybur: Perhaps you'd like to involve Data.Sequence somehow?
13:08:57 <Cale> I don't know what Java's arraylist does
13:09:10 <EvanR> it keeps extra space for you to insert at the end
13:09:16 <Psybur> The problem is I have to make a large vector for each of my window in a sliding window
13:09:45 <EvanR> you can use a mutable buffer and unsafe create vector slices into it
13:09:57 <Psybur> I was trying to find the best way to make that vector between windows. Seems I get no added benefit from passing the last vector to the next window and popping the head and appending the newest element
13:10:01 <Cale> looking at it, ArrayList's append is also linear time?
13:10:04 <EvanR> but if you mess up its very bad (tm)
13:10:44 <Cale> You either have to be very clever to do appends in sublinear time, or you have to compromise access performance badly
13:11:09 <Psybur> So the big o for appending on vector is in regards to what I am appending
13:11:14 <EvanR> sounds like you want a ring buffer?
13:11:15 <Psybur> Not in the size of the existing vector?
13:11:55 <Cale> Psybur: Ohh, I see, they manage to have it the other way around there.
13:12:18 <Cale> Psybur: No, it'll be on the order of the size of the old vector, since you're going to copy that.
13:13:03 <Cale> A Strict Vector is just a contiguous block of memory -- nothing too fancy
13:13:12 <Psybur> Oh, it gets copied each time? its not in java where it grows a fixed amount so you can do some more adds without growing the vector
13:13:18 <Cale> A lazy Vector is basically just a lazy list of strict ones
13:13:28 <Cale> Psybur: It's immutable
13:13:32 <_n_> in a list comprehension, what order are the predicates evaluated
13:13:34 <Psybur> I see
13:13:46 <Cale> _n_: left to right
13:14:03 <_n_> neat, cheers
13:14:04 <Psybur> So if I pass a mutable vector around and then convert to the storable vector maybe that will work?
13:14:05 <EvanR> you can arrange for a fancy backing of immutable vectors supporting appending 1 thing a time, but eventually youll have to copy it all
13:14:44 <Psybur> Hmm, but thats also going to involve a memory copy isnt it
13:14:46 <EvanR> but you really want C at this point right
13:15:04 <Cale> EvanR: yeah, I suppose you could do something rather like the old DiffArray
13:15:09 <EvanR> no, if you have space, you insert  the new thing an create a new slice
13:15:15 <Cale> except with regard to the length of the thing, rather than mutations
13:15:17 <EvanR> until you run out of space
13:15:41 <EvanR> but i dontk now how to make that pure
13:15:42 <Cale> But then you have the problem of what happens when you append a second time to an old version of the array
13:15:46 <EvanR> right
13:15:51 <Cale> Then you need to copy again
13:16:07 <Cale> It could be done
13:16:21 <Cale> I think you'd end up making all the old versions of the vector progressively slower to access
13:16:27 <Cale> but that might be okay in some applications
13:16:37 <Cale> DiffArray was very rarely the correct choice though
13:16:50 <Cale> and it eventually got dropped because very few people used it
13:18:13 <Cale> (it was an immutable array type backed by a mutable array, and updates would actually write the mutable array, but update the old version of the array with an indirection that contained the reverse patch)
13:18:34 <Psybur> So right now, my algo is this: in my sliding windows, where in each window I need a storable vector of the elements of the window. I see no performance difference between just making a new sotrable vector each time vs passing it around and drop 1 and snocing. Your proposed solution would probably see a performance increase?
13:18:48 <Cale> The constant factors were such that it was worse than most other options most of the time
13:19:39 <Cale> Psybur: Perhaps.
13:20:11 <Cale> Psybur: It might be better to investigate just storing a larger amount of the data, and altering just a pair of indices into it
13:20:26 <Cale> (which you would use to offset the index operations)
13:20:37 <Cale> I believe the drop 1 already does that.
13:21:17 <Cale> Psybur: You could create a large Vector, and then slice it in O(1)
13:21:27 <Psybur> Hmm, so you think maybe making one large storable vector and then slicing it for each window
13:21:32 <Cale> yeah
13:21:48 <Cale> slice doesn't copy
13:23:05 <Cale> (just constructs a new vector with the same array, but a different initial offset and length)
13:23:27 <Psybur> I suppose i could load all 100 mb into memory no problem :P
13:24:16 <EvanR> thats nothing o_O
13:24:52 <Cale> Depends on how much it gets inflated by indirections :)
13:24:52 <Psybur> Yeah makes me wonder why my currently inefficient method doesnt finish within 4 hours heh
13:25:11 <Cale> Psybur: Well, you're probably copying 100MB of data over and over
13:25:18 <Cale> well, maybe not 100MB
13:25:24 <Cale> Maybe a much smaller window
13:25:59 <EvanR> somehow load it packed, then create windows into it
13:27:15 <Psybur> Cale, EvanR this is the gist of what I have now :D https://pastebin.com/awVcZkZ3
13:27:55 <Psybur> Eh, you can probably ignore, doubt thats going to mean much to you :D
13:28:42 <stevenxl> Hi folks. For those of you familiar with the JavaScript ecosystem, is there an equivalent to the Prettier library in Haskell? (A code formatter; I believe Elm has one as well).
13:29:14 <Cale> stevenxl: You can use haskell-src-exts to parse and prettyprint Haskell code
13:29:44 <Cale> stevenxl: There's a library called groom which is a trivial application of this (seriously, look at its source code) which just does the round trip for you.
13:30:01 <Cale> (useful at the ghci prompt for pretty printing anything showable)
13:30:38 <stevenxl> Cale: thank you. I'll take a look at both of 'em.
13:30:39 <stevenxl> ;-)
13:36:25 <absurd[m]> Hi, a newbie question, why there is a popular room for haskell here? Is it so useful for something, what you can't do with other languages?
13:37:12 <Cale> absurd[m]: Not sure I understand the question.
13:37:15 <dysfun> it's good for being sure your software actually works
13:37:24 <Cale> absurd[m]: Haskell is a very good programming language in general.
13:38:00 <absurd[m]> Is Haskell the 'deepest' language?
13:38:06 <Psybur> Hmm, now how would a turn a conduit of say yieldMany [[1,2,3],[4,5,6]] into [[1,4],[2,5],[3,6]] :o
13:38:38 <Psybur> Or [Vector [1,4], Vector [2,5] etc :D
13:38:44 <Cale> absurd[m]: At the company I work for, we develop web and mobile applications for a variety of clients, and we build almost everything in Haskell, from the backends (compiled to native x64 code, running on AWS machines), to the frontends (compiled to Javascript for the web, or ARM code to run on iPhones and Android devices)
13:39:10 <dysfun> i don't know what a 'deep' languae is
13:39:23 <Cale> absurd[m]: I'm not sure how you'd measure depth, but probably not? There are other languages which go farther in terms of what their type system can do.
13:39:26 <absurd[m]> Thanks
13:39:28 <dysfun> it's rooted in academia, there are a lot of concepts
13:40:12 <_n_> is there a way in a list comprehension to skip numbers that are already in the list im building
13:40:14 <Cale> absurd[m]: It's a really good language for getting things done in, if you care about having a good type system which actually helps rather than hinders you.
13:40:15 <absurd[m]> Yes, I work there, but we dont use it...
13:41:11 <absurd[m]> Hmm, maybe I should try it, I know LISP, functional too
13:42:03 <Cale> Definitely. It's quite different from LISP, but if you've read something like SICP, you'll find a lot of what were design patterns in LISP became language features in Haskell.
13:43:50 <hexagoxel> stevenxl: if the "as a library" part is not important, there are hindent and brittany.
13:44:31 <stevenxl> hexagoxel: Yea I'm sorry. The as a library part is not important. OK thanks. I have tried hindent but I got too lazy to learn how to turn it off for contributing to projects with another style
13:44:41 <stevenxl> but I got so used to automatic formatting that I need it. 
13:47:35 <hexagoxel> sounds more like an issue with editor integration :p
13:48:46 <hexagoxel> i had to configure my editor manually to reformat on some keypress.
13:49:46 <_n_> i reformat on save, but have a keybind to disable it
14:12:20 <dsal> Hmm....  Playing around with hoogle.  I'm surprised by this:
14:12:25 <dsal> @hoogle a -> [a]
14:12:25 <lambdabot> Prelude head :: [a] -> a
14:12:25 <lambdabot> Prelude last :: [a] -> a
14:12:26 <lambdabot> Data.List head :: [a] -> a
14:12:35 <dsal> What does that give me Data.List head?
14:14:45 <lyxia> hoogle's type search is a bit fuzzy
14:14:59 <lyxia> sometimes it gives interesting results
14:16:48 <Clint> @hoogle Int -> [Int]
14:16:49 <lambdabot> GHC.OldList length :: [a] -> Int
14:16:49 <lambdabot> NumericPrelude.Base length :: [a] -> Int
14:16:49 <lambdabot> Data.Edison.Seq.ListSeq size :: [a] -> Int
14:18:28 <dsal> Yeah, some of these results are just kind of obviously wrong.  Makes the type search thing not be very helpful.
14:19:41 <mniip> hmm that only happens with the new hoogle
14:19:43 <mniip> not the old one
14:20:14 <dsal> oh good.  "That's just a bug" is fine.
14:21:16 <geekosaur> new hoogle's known to have problms with its type search though
14:32:25 <zenspider> OK... I'm a newb at this and probably asking the question wrong, but I'm trying to do the first `random` problem in the 99 problems list (#23) and while I have code that now typechecks, I can't write a test for it. I'd be totally happy using mkStdGen w/ a fixed seed but just can't figure out how to write a function that'll allow me to test it outside of IO
14:35:14 <lyxia> zenspider: why don't you want to test it in IO
14:36:05 <zenspider> lyxia: 1) don't know how, 2) don't know why, 3) because the rest of my tests work this way
14:36:13 <zenspider> sec... lemme try to get the right words
14:36:24 <Tuplanolla> @paste all of it
14:36:24 <lambdabot> Haskell pastebin: http://lpaste.net/
14:36:34 <lyxia> Yeah I still don't understand your problem
14:36:41 <zenspider> I'm using HUnit and have `tests :: Test` w/ a bunch of ~=? exprs
14:37:28 <zenspider> and the new one fails w/ • Couldn't match expected type ‘[Char]’ with actual type ‘IO [Char]’ 
14:38:07 <zenspider> http://lpaste.net/5020437424627515392
14:39:47 <Tuplanolla> :t \ xs n -> take n [ xs !! x | x <- randomRs (0, length xs - 1) (mkStdGen 24)]
14:39:49 <lambdabot> [a] -> Int -> [a]
14:40:34 <Tuplanolla> Just drop the `return` like I did there, zenspider?
14:40:46 <tom-md> zenspider: You have declared `rndSelect` as `IO` but there is no good reason for that.
14:41:25 <zenspider> I did it at the time from a wiki page on haskell.org and/or because the typechecker is a big bully
14:41:55 <nisstyre> zenspider: one tip for trying to work through type checking issues, comment out any type declarations and then check what the inferred type is in ghc
14:41:58 <nisstyre> *ghci that is
14:42:09 <nisstyre> or just check it directly in ghci
14:42:11 <zenspider> ok. fantastic... now I just need to parameterize the random generator to make this real code :)
14:42:36 <nisstyre> then you can specialize the type signature if necessary and put the declaration back in
14:42:40 <zenspider> nisstyre: when stuck I've been making everything Int and seeing how wrong I am :)
14:42:46 <lyxia> zenspider: "abc" ~=? rndSelect "abcdefgh" 3   you are comparing a string "abc" with a random generator of strings, which is not itself a string.
14:43:05 <nisstyre> zenspider: that will tell you what it failed to unify but I mean
14:43:09 <zenspider> I'm in emacs + flycheck + hlint so I get a lot of live feedback
14:43:17 <nisstyre> you can just check it with :t in ghci too
14:43:30 <zenspider> the hlint stuff is interesting because I write something that works and then it comes along and says why not X? neat way to discover
14:43:46 <zenspider> tho lately it's been a lot of Arrow stuff and I don't think I'm ready for that
14:43:54 <nisstyre> there's probably a plugin that could do on-line type inference I bet
14:44:09 <nisstyre> I don't use emacs personally
14:46:04 <lyxia> zenspider: you need to learn to use IO before doing that exercise
14:47:58 <dsal> I don't think &&& is clearer than (f x, g x)
14:48:06 <zenspider> lyxia: hrm?
14:48:35 <dsal> :t f &&& g
14:48:36 <lambdabot> (FromExpr (a b c'), FromExpr (a b c), Arrow a) => a b (c, c')
14:48:47 <dsal> :t f &&& g 3
14:48:49 <lambdabot> (FromExpr (a b c'), FromExpr (a b c), Arrow a) => a b (c, c')
14:49:05 <dsal> > succ &&& pred 3
14:49:08 <lambdabot>  error:
14:49:08 <lambdabot>      • No instance for (Typeable b0)
14:49:08 <lambdabot>          arising from a use of ‘show_M71816491171386582797082’
14:49:14 <dsal> > (succ &&& pred) 3
14:49:16 <lambdabot>  (4,2)
14:49:56 <zenspider> yeah. I don't find it clearer (yet) and don't need it (yet) so I'll stick to the level where I'm at and make hlint skip those suggestions
14:50:06 <zenspider> skipping &&&, <&>, and <> for now
14:50:19 <zenspider> turned on generalise tho, so I'm switching to fmap now
14:50:23 <tom-md> <> is much simpler (and more common) than the others.
14:50:31 <zenspider> baby steps :P
14:50:32 <lyxia> zenspider: or change the signature of rndSelect to take a seed as an argument instead of being in IO
14:50:59 <zenspider> lyxia: I've dropped the IO and it works for now... I'm changing it now to pass in a StdGen so it isn't useless code
14:51:49 <zenspider> nice: "ffd" ~=? rndSelect "abcdefgh" 3 (mkStdGen 42)
14:53:23 <zenspider> thanks everyone. that was a hair-ripper
14:53:37 <zenspider> esp given the number of google hits that just say "not possible outside of IO"
14:56:34 <lyxia> real programs get randomness with IO.
14:58:19 <zenspider> I haven't figured that one out yet... luckily I'm not writing real programs yet 
14:58:43 <nisstyre> sure you are
14:59:01 <nisstyre> zenspider: although if you're not set up with stack yet then I highly recommend doing that
14:59:10 <zenspider> nah. 99 problems is just thought exercises / koans so far
14:59:11 <nisstyre> it will save you a lot of frustration later
14:59:34 <dsal> zenspider: note:
14:59:34 <dsal> > ['a','b','c','d','e','f','g','h','i','k']
14:59:36 <nisstyre> zenspider: project euler is also a good way of practicing but maybe a bit too much work
14:59:38 <lambdabot>  "abcdefghik"
14:59:43 <zenspider> already fixed  that :)
14:59:46 <zenspider> but thank you
14:59:53 <dsal> I got pretty far into euler before picking up exercism.
15:00:05 <zenspider> eventually (maybe)... I'm much more satisfied with haskell than I am with rust... that was horrible
15:00:08 <dsal> The test cases are great.
15:00:23 <zenspider> on exercism? cool. I'll do that next
15:00:26 <nisstyre> zenspider: yeah you don't have to deal with different pointer types and ownership issues
15:00:29 <tom-md> Poor rust, making the curve extra special.
15:00:39 <dsal> "pretty far" is an exaggeration.  I got a little bored by euler because it ended up being a bunch of math stuff.  I didn't want to just do math.
15:00:47 <zenspider> tom-md: they did that to themselves... ON PURPOSE. I just don't get it. 
15:00:51 <nisstyre> zenspider: code kata is good too
15:00:57 <nisstyre> http://codekata.com/
15:01:01 <zenspider> I wanted to write a simple lexer and fuuuuuck was it horrible painful
15:01:03 <tom-md> zenspider: I was being sarcastic. I like most of rust's decisions.
15:01:07 <nisstyre> the bloom filter one is fun
15:01:23 <zenspider> I haven't done/seen codekata. cool. thanks
15:01:36 <zenspider> tom-md: um... then... me too. sarcasm... yeah
15:01:44 <dsal> exercism is nice because it hands you a stack project with a readme, a basic intro src thing, and a test suite.  You just have to make the tests pass.
15:01:59 <dsal> Though sometimes the problems are a little underspecified and you have to infer what they mean by reading the tests, but that's normal.
15:02:10 <zenspider> yup. I like it generally... now that they're addressing pedagogy it should get better
15:02:38 <zenspider> I help out with ruby and am/was a maintainer for racket
15:02:52 <dsal> Oh awesome.  I did like.. the first racket problem.
15:02:58 <dsal> I'll probably get back to that once I finish haskell.
15:03:08 <nisstyre> Racket is another of my favourite languages
15:03:14 <dsal> I've done ~73 haskells and one racket.
15:03:36 <zenspider> I love me some racket. Just went to racketcon a couple weekends ago
15:03:43 <nisstyre> Racket has some things that no other language comes with really
15:03:43 <zenspider> (it was in my hometown, so that helped)
15:03:57 <nisstyre> like for example built in support for delimited continuations
15:04:11 <zenspider> I love the meta language aspect of it
15:04:43 <nisstyre> I'm writing a clone of fabric (python build tool) in it, and you can build a pretty expressive DSL in less than 40 loc
15:04:52 <nisstyre> using parameters and macros
15:05:43 <nisstyre> https://github.com/nisstyre56/Bolt
15:07:22 <zenspider> nisstyre: I suggest you do a `raco new Bolt` (somewhere else) and pull in a lot of the infrastructure it gives you. Add your deps to info.rkt etc.
15:07:35 <nisstyre> zenspider: yeah this was just an experiment really
15:07:41 <nisstyre> zenspider: thanks for the advice
15:07:49 <nisstyre> I'm going to be modifying the ssh library too probably
15:07:52 <zenspider> that's pretty cool tho
15:08:04 <nisstyre> I want it to support controlpersist, not sure if it does already
15:23:19 <Zemyla> So why is True >= undefined not True?
15:24:26 <slack1256> > True >= undefined
15:24:29 <lambdabot>  *Exception: Prelude.undefined
15:26:07 <slack1256> Zemyla: what do you think it should be?
15:26:49 <slack1256> oh, you mean it should be True
15:27:21 <Zemyla> Yeah. I mean, shouldn't True >= long_complicated_expression_that_takes_10_seconds_to_run return True immediately?
15:27:28 <Tuplanolla> > maxBound >= undefined -- I would expect this to always hold.
15:27:30 <lambdabot>  *Exception: Prelude.undefined
15:27:46 <slack1256> it is  conservative choice I guess
15:28:00 <slack1256> you can always define a new instance via newtypes that does what you want
15:28:31 <Zemyla> Yes, but shouldn't the default do the right thing?
15:29:07 <slack1256> personally, given that you can't pattern match against undefined value and (>=) intuitively does a equality , it ought to pattern match against undefined and know that is undefined (impossible)
15:29:54 <slack1256> to me is the right thing, although I understand why somebody would think it isn't
15:30:24 <monochrom> Zemyla: Have you looked at the source code?
15:30:41 <dsal> :t (>=)
15:30:42 <lambdabot> Ord a => a -> a -> Bool
15:30:49 <lyxia> Now every Int comparison gets an equality check with maxBound
15:30:52 <dsal> It doesn't suggest it's bounded.
15:30:56 <lyxia> Yay
15:31:27 <Tuplanolla> You could put in a rewrite rule.
15:31:58 <lyxia> What rewrite rule?
15:32:24 <Tuplanolla> One that takes care of the constant cases.
15:32:36 <lyxia> The problem is not constant case, precisely.
15:33:20 <dsal> It seems the "right" thing is to short-circuit any test when you know the RHS can't be greater than the LHS
15:33:28 <Tuplanolla> The rest can stay undefined.
15:35:15 <lyxia> I guess you want that, if for all defined x, f x = y for the same y, then f _|_ = y.
15:35:40 <lyxia> but apart from being pretty what good is it?
15:36:01 <lyxia> This kills performance
15:38:10 <Zemyla> Tuplanolla: Rewrite rules don't always work.
15:41:04 <monochrom> But you will be happy to know this:
15:41:18 <monochrom> > (1, undefined) == (2, undefined)
15:41:20 <lambdabot>  False
15:41:57 <dsal> > (True, undefined) > (False, undefined)
15:41:59 <lambdabot>  True
15:44:59 <Welkin> > (0, 1) > (1, 0)
15:45:03 <lambdabot>  False
15:45:09 <Welkin> > (0, undefined) > (1, undefined)
15:45:11 <lambdabot>  False
15:45:13 <Welkin> :D
15:50:38 <mnoonan_> so I’ve made a bit of progress towards figuring out why some of my funky “are these values actually the same thing in memory” tests started to fail from ghc 8.0.2 -> 8.2.1. Now I can see exactly how the simple core and stg has changed, but I’m not sure why. Can anybody advise about how to get more visibility into the decisions ghc is making?
15:51:30 <Tuplanolla> > (undefined :: ()) == (undefined :: ()) -- This is also surprising.
15:51:33 <lambdabot>  *Exception: Prelude.undefined
15:51:52 <MP2E> mnoonan_ : this doesn't necessarily answer your question, but a recent bug on the tracker sounds like it might be related to the issue you are experiencing
15:51:55 <MP2E> mnoonan_: https://ghc.haskell.org/trac/ghc/ticket/14346
15:52:10 <MP2E> the title is incorrect
15:52:13 <MP2E> you don't need FFI to trigger it
15:55:36 <mnoonan_> MP2E: interesting, thanks for the tip! I’ll try some of the tweaks there and see if it responds in a similar way
15:58:57 <pie_> so i just realized that you actually dont need that much to bind Qt to a usable level, if you support setting stylesheets and the xml import functionality
15:59:12 <pie_> add signals/slots, and youre mostly covered i think?
15:59:25 <pie_> niceness is a different question, but its sufficient
16:18:26 <c_wraith> pie_, that sounds like https://hackage.haskell.org/package/hsqml
16:21:20 <plakband> Is there a language whose syntax you prefer over Haskell's?
16:24:00 <lyxia> purescript
16:24:07 <lyxia> idris
16:24:40 <Raquai> anyone know where the error "No instance for (Fractional Int) arising from a use of `/'" could have come from?
16:24:48 <Raquai> it was caused by this code:
16:24:49 <Raquai> findFirstEmpty board = ((mod resultaat 9), ( floor (resultaat/9) ))     where resultaat = fromMaybe (-1.0) ( findIndex ( == 0 ) (concat board) )
16:25:11 <glguy> from resultaat/9
16:25:25 <Fekinox> you're trying to divide a floating point value by an int in resultaat/9
16:25:37 <glguy> :t findIndex
16:25:38 <lambdabot> (a -> Bool) -> [a] -> Maybe Int
16:26:43 <Raquai> oh yeah that -1.0 used to be just a -1 but that gave the same error
16:26:57 <glguy> It doesn't help your type error, but you can use ''elemIndex 0'' instead of ''findIndex (0==)''
16:27:11 <glguy> resultaat has to be an Int because that's what findIndex returns
16:27:53 <Raquai> yeah but I've got the same error for floor:
16:27:54 <glguy> instead of ''floor (x/9)'' you can use ''x `div` 9''
16:28:18 <glguy> It doesn't make sense to take the floor of an Int
16:28:39 <Raquai> yeah I tried the div already, didn't work
16:28:44 <Raquai>  No instance for (RealFrac Int) arising from a use of `floor'
16:28:47 <Raquai> that's the floor error
16:28:58 <glguy> When you delete floor from the definition you won't get an error about it
16:29:59 <glguy> Ints don't have factional parts, so you don't need to floor them
16:30:35 <glguy> > divMod 20 9
16:30:40 <lambdabot>  (2,2)
16:30:49 <glguy> > divMod 21 9
16:30:52 <lambdabot>  (2,3)
16:31:49 <Raquai> oh wow, that's actually exactly the function I need
16:32:19 <Raquai> thanks haha!
16:34:06 <hpc> if you don't care about negatives, quotRem is faster
16:34:28 <Raquai> where would there be negatives?
16:35:42 <Raquai> but yeah, I tried both and they both work
16:35:45 <Raquai> thanks a lot
16:39:39 <monochrom> I like quotRem.
16:40:03 <monochrom> But people try to give me guilt about "but it is wrong for negative numbers"
16:40:11 <Tuplanolla> I like `quotRemE`. Too bad it doesn't exist.
16:41:24 <Tuplanolla> That would be Euclidean division with an always-positive remainder.
16:41:46 <monochrom> Causes me to be cynical towards all ideologies and programming religions and perfectionism.
16:42:28 <monochrom> And even the whole notion of "code smell".
16:48:59 <monochrom> Hmm, is divMod not Euclidian division with positive remainder?
16:49:08 <monochrom> > divMod 5 (-2)
16:49:11 <lambdabot>  (-3,-1)
16:49:15 <monochrom> Ah.
16:49:27 <monochrom> > quotRem 5 (-2)
16:49:29 <lambdabot>  (-2,1)
16:51:04 <monochrom> > quotRem (-5) 2
16:51:07 <lambdabot>  (-2,-1)
16:51:26 <monochrom> Ah, so this one is when quotRem gives you a negative remainder.
16:51:29 <monochrom> > quotRem (-5) (-2)
16:51:32 <lambdabot>  (2,-1)
16:51:41 <monochrom> And this one is simply strange. :)
16:52:58 <glguy> > [ (x,y,divMod x y) | x <- [-3,3], y <- [-2,2] ]
16:53:01 <lambdabot>  [(-3,-2,(1,-1)),(-3,2,(-2,1)),(3,-2,(-2,-1)),(3,2,(1,1))]
16:53:09 <glguy> > [ (x,y,quotRem x y) | x <- [-3,3], y <- [-2,2] ]
16:53:12 <lambdabot>  [(-3,-2,(1,-1)),(-3,2,(-1,-1)),(3,-2,(-1,1)),(3,2,(1,1))]
20:14:36 <Fekinox> it's amazing how much learning haskell has affected my programming elsewhere
20:14:47 <Fekinox> it now physically hurts to type out a for/while loop
20:28:56 <jcarpenter2> my next project with haskell is gonna be to learn more about what the compiler does
20:29:36 <jcarpenter2> the main reason i'm not writing my various projects in haskell is just that i don't understand it well enough...
20:30:59 <dsal> That's the best reason to do it!
20:33:13 <jcarpenter2> i mean projects that i need to finish
20:37:27 <l0dey> IT IS THE L0DE RADIO HOUR AGAIN!!! #LRH at irc.efnet.org
20:37:27 <l0dey> Call the show at 415-349-5666
20:37:27 <l0dey> his live show @ https://www.youtube.com/watch?v=rXWx3lPlwgE
20:37:27 <l0dey> WE ARE TRYING TO INCREASE PARTICIPATION IN THIS SHOW | (don't be a nigger) PLEASE CALL AND PARTICIPATE.
20:40:14 <dsal> Oh man, I need to go watch whatever that show is.  I'm all about spam, caps, and racism.
20:40:37 <jcarpenter2> oh yes
20:40:49 <jcarpenter2> i like lode runner
20:43:33 <jcarpenter2> oh noes, i can't cabal-install Data.Nat
20:43:41 <jcarpenter2> haskell is too strict :/
20:44:30 <jcarpenter2> this is the other reason why i haven't used haskell for official-level projects, i can't figure out cabal
20:44:52 <jcarpenter2> i'm like "cabal install X", cabal is like "no"
20:45:43 <dsal> Haskell is hardly strict at all!
20:45:57 <jcarpenter2> well that's true
20:46:22 <jcarpenter2> it DOES have undefined in it
20:47:09 <dsal> :t undefined
20:47:10 <lambdabot> a
20:47:15 <jcarpenter2> lol
20:47:24 <dsal> @src undefined
20:47:24 <lambdabot> undefined = error "Prelude.undefined"
20:47:27 <Welkin> a?
20:47:32 <jcarpenter2> type variable
20:50:50 <dsal> :info (.)
20:51:04 <Welkin> lambdabot is not ghci
20:51:22 <dsal> Yeah.  I had to open my own ghci for that.
20:53:28 <Welkin> fuzzy wuzzy was a bear
20:55:39 <jcarpenter2> fuzzy wuzzy took a dare
21:00:12 <NHX> fuzzy wuzzy wasn't a puzzy, was he?
21:08:43 <jcarpenter2> tarnation, i can't install data-nat because my base is too new
21:10:22 <jcarpenter2> data-nat was last updated 5 years ago and requires <semigroups-0.9 when we have semigroup-0.18
21:10:32 <jcarpenter2> semigroups*
21:10:59 <jcarpenter2> :k Nat
21:10:59 <Welkin> you could update it yourself
21:11:00 <lambdabot> error:
21:11:00 <lambdabot>     Not in scope: type constructor or class ‘Nat’
21:11:05 <jcarpenter2> i plan to
21:11:16 <jcarpenter2> is data-nat the module everybody gets Nat from?
21:11:28 <Welkin> I haven't used Nat before
21:11:37 <Welkin> it is very easy to define your own though
21:11:43 <jcarpenter2> yeah
21:11:47 <Welkin> data Nat = Succ Nat | Z
21:11:50 <jcarpenter2> but i want all the nice implementations
21:11:58 <jcarpenter2> e.g. for Show, Num
21:12:28 <hg_w> having a hard time finding good pedagogical materials for type level / dependent type programming
21:12:42 <Welkin> hg_w: have you looked at idris?
21:13:09 <hg_w> Welkin would not learn a whole other language to learn one topic in haskell =/
21:13:25 <jcarpenter2> yeah, Idris has a neat well-typed interpreter example
21:13:44 <Welkin> idris is not much different from haskell
21:13:55 <Welkin> it is haskell with dependent types (and a few minor differences)
21:14:11 <Welkin> strict instead of lazy
21:14:15 <Welkin> swaps :: and :
21:14:22 <hg_w> yeah i've followed idris from afar
21:14:36 <Welkin> there are materials about idris you could read
21:14:46 <Welkin> and you should be able to understand, to learn about dependent typing
21:15:13 <jcarpenter2> one application i found for dependent types was for collisions in physics engines...
21:15:21 <hg_w> still i'm trying to get work done ... maybe i will try it, but i'd rather work through some good tutorials for haskell
21:15:41 <jcarpenter2> you've got a CollisionShape data type, then you can have CollisionPoint : CollisionShape -> Type
21:16:04 <jcarpenter2> because the point at which a collision happens is expressed differently per collision shape
21:16:13 <hg_w> if there are some but learning materials on this seem pretty thin so far, even though it's only a beginner-intermediate level topic
21:17:04 <jcarpenter2> e.g. a point on a circle vs a point on a convex hull
21:51:12 <jcarpenter2> yeah, sorry guys but i can't understand how haskell code executes
21:51:39 <Cale> Can I help somehow?
21:51:55 <jcarpenter2> idk probably not
21:52:40 <jcarpenter2> i don't understand the semantics of haskell code as it relates to the machine instructions that are
21:52:45 <jcarpenter2> generated
21:53:06 <Cale> have you read the STG machine paper?
21:53:23 <jcarpenter2> no
21:53:24 <Cale> https://www.dcc.fc.up.pt/~pbv/aulas/linguagens/peytonjones92implementing.pdf
21:53:42 <Cale> That should help a bunch, for the low level picture
21:53:50 <jcarpenter2> i will take a look
21:53:53 <jcarpenter2> thank you Cale
21:54:17 <Cale> I don't actually think at that level all that often, I prefer to think in terms of term reduction or, if that doesn't suffice, graph reduction.
21:55:02 <Cale> You can imagine running Haskell code as rewriting expression graphs, and this actually gives you a very nearly correct performance model.
21:55:52 <Cale> (Once you understand that expressions are reduced outermost-first, and any evaluation done to a variable bound to an expression is shared between its occurrences)
21:56:57 <Cale> jcarpenter2: That STG machine paper is fairly out of date relative to GHC, but it still gets you *pretty* close, and discusses the design space for how things get done a bunch
21:59:13 <cocreature> jcarpenter2: you might also find https://github.com/quchen/stgi#readme helpful
21:59:37 <Cale> jcarpenter2: The gist of it is that unevaluated expressions (bound to variables or in fields of data structures) are at runtime represented by pointers to code. The first time the value is needed (almost always because the thing is being pattern matched), that code is entered, and the first thing it does is rewrite the pointer to point at a "black hole" (which will throw an exception if entered, detecting an infinite loop), and then 
21:59:37 <Cale> compute the value, and finally rewrite the pointer to point at a short piece of code which will return the already computed value immediately (for next time)
22:00:44 <jcarpenter2> interesting, i need tea
22:00:50 <Cale> (before returning the computed value)
22:02:33 <Cale> Evaluation is driven forward largely by pattern matching -- when you have a case expression, its scrutinee needs to be evaluated up to determining the topmost data constructor, in order to figure out which branch matches.
22:03:38 <Cale> and so most commonly the continuation on the stack you'll be returning to will basically correspond to some pattern match
22:04:22 <Cale> The other case being where you have a function applied to an argument and the function is some expression which needs further evaluation before we can apply it (essentially, before it's a lambda)
22:05:26 <Cale> and, well, there are a few other sorts of things which can be on the stack in GHC, but those are the main ones :)
22:06:24 <jcarpenter2> this makes sense
22:06:39 <jcarpenter2> i might need to sleep on it in order for it to integrate into my knowledge
22:16:06 <zenspider> rigid type variable? where do I read about this? googs isn't helping or I'm not getting it
22:16:51 <zenspider> group :: forall a. Ord a => [Int] -> [a] -> [[a]] But: Expected type: [[a]] Actual type: [[[a]]] 
22:17:44 <zenspider> My guess: there are certain error patterns I don't know how to properly interpret yet and this means something else
22:18:37 <zenspider> my test data is strings, splitting them into substrings, and I'm wondering if it is getting pissy about sub-sub-lists
22:24:54 <Cale> zenspider: A rigid type variable is one which occurs as a variable in a user-provided type signature, so it can't be unified with a more specific type
22:27:02 <zenspider> the code SEEMS to work when run manually ... so it is most likely a problem with my decl?
22:27:28 <Cale> zenspider: Yeah, if the function does the thing you want it to do, the problem is that your type signature is incorrect
22:28:35 <Cale> You can try removing the type signature and asking ghci what it thinks the type is with  :t group
22:29:42 <zenspider> too many []s
22:30:52 <jcarpenter2> Let's say you have two vars, 'foo = Foo 4' and 'foo2 = Foo (2+2)', and apply the same function to both, 'g = f foo' and 'g2 = f foo2'.  Does the runtime evaluate both 'f foo' and 'f foo2' or can it determine that foo is identical to foo2 and only evaluate 'g foo' once?
22:31:12 <jcarpenter2> aye, there's the rub
22:31:43 <zenspider> is nub happier with pre-sorted data or does it not give a shit?
22:32:11 <jcarpenter2> Not all expressions that are the "same expression" can be unified statically
22:32:47 <zenspider> esp in a lazy language. it might not know until down the road. 
22:32:52 <jcarpenter2> consider 'foo = Foo 4' and foo2 defined by user input but also equal to 'Foo 4'
22:33:56 <Cale> jcarpenter2: It evaluates it twice
22:34:21 <jcarpenter2> iiiiiinteresting
22:34:40 <Cale> jcarpenter2: in fact, if you have something like  f x + f x  it'll evaluate f x twice
22:34:50 <jcarpenter2> why would that be?
22:34:56 <Cale> jcarpenter2: while if you have let y = f x in y + y, it'll evaluate it once
22:35:24 <jcarpenter2> i see
22:36:17 <jcarpenter2> so it doesn't memoize there
22:36:28 <Cale> For the reason why, well, first of all, notice that if we effectively memoised all functions, by remembering their results after computing them, then we could basically never garbage collect anything
22:36:47 <Cale> Secondly, this is not always an optimisation
22:37:04 <Cale> (for basically the same reason, but let's have a look at an example)
22:37:08 <Cale> consider this function:
22:37:31 <Cale> subsequences [] = [[]]; subsequences (x:xs) = subsequences xs ++ map (x:) (subsequences xs)
22:37:43 <jscool> hi
22:37:47 <jcarpenter2> classic power set
22:37:50 <Cale> yeah
22:37:54 <zenspider> hrm... if I can do > take 5 $ ...stuff... and it comes back nearly instantly, why does length $ ...stuff... get bogged down?
22:38:03 <Cale> So, now you might see the right hand side of the second equation there and think:
22:38:07 <jscool> is eml part of haskell?
22:38:13 <jscool> elm
22:38:17 <zenspider> ...stuff... also includes `sort $` so I would think that laziness isn't part of it
22:38:20 <Cale> subsequences (x:xs) = let ys = subsequences xs in ys ++ map (x:) ys
22:38:24 <jcarpenter2> jscool: no, elm is not part of haskell
22:38:36 <Cale> jscool: no, it's not the same language even, it's just haskell-esque
22:38:49 <jscool> esque?
22:39:08 <jcarpenter2> -like, -ish
22:39:08 <Cale> jscool: as in it looks somewhat similar syntactically, and has many of the same features
22:39:17 <jscool> k i found elm channel thanks guys 
22:39:21 <jscool> have a great day
22:39:28 * jcarpenter2 tips hat
22:39:53 <zenspider> length $ nub $ fmap (multisplit [2,2,5]) $ sort $ permutations ["aldo","beat","carla","david","evi","flip","gary","hugo","ida"]
22:39:56 <zenspider> seems innocuous enough
22:40:23 <jcarpenter2> Cale: that's exactly what i would think
22:41:19 <Cale> jcarpenter2: But this is a terrible idea, because there are 2^(n-1) subsequences you then can't begin to garbage collect (half of all of them) until you make your way through the first half of the resulting list
22:41:29 <Cale> jcarpenter2: So this will explode in space usage
22:41:48 <Cale> and, because it does so much allocation, it will also be slower
22:41:57 <jcarpenter2> inteeeeeresting
22:43:16 <Cale> With the version in which subsequences xs occurs twice, we can (potentially) start garbage collecting the elements of the list as soon as we generate them, assuming there's only one consumer of the list.
22:44:01 <jcarpenter2> haskell begins to feel more low-level
22:45:37 <Cale> Well, you have the same space/time tradeoffs that you would have anywhere else.
22:45:58 <Cale> It's a fundamentally hard problem and the compiler doesn't try to solve it for you.
22:47:01 <Cale> It will frequently reorganise the evaluation order though when it can prove that the result of evaluating some expression will certainly be needed, so you can't rely on it having lazy evaluation exactly.
22:47:28 <Cale> Haskell has non-strict semantics, which means that the results of evaluation and termination behaviour must match that of lazy evaluation
22:48:05 <Cale> But the compiler is allowed to evaluate expressions immediately if it can see you're going to pattern match them for sure.
22:48:48 <Cale> Thankfully, any order of evaluation which terminates will produce the same result.
22:49:17 <jcarpenter2> yeah, there's a term for that....
22:49:38 <jcarpenter2> rewrite system such that a term evaluates to the same normal form no matter how you normalize it
22:50:33 <Cale> "confluence"
22:51:05 <Cale> Also, if some order terminates, then outermost-first terminates
22:51:40 <Cale> and more pragmatically, if you imagine that lazy evaluation is what's going on, then you'll rarely be disappointed or very surprised by what GHC does
22:52:36 <Cale> It will evaluate some things strictly, but it tends to be in places where this just improves constant factors in space and time a bit.
22:53:09 <Cale> (avoiding the "thunk" that represents the unevaluated expression at runtime)
22:55:44 <zenspider> remove the map fn and replace with id... fast as hell. remove the map... fast. sort... fast. it's nub... is there a better way to go about this?
22:58:19 <zenspider> test list works out to be 362880 before nub... that doesn't seem THAT big... is there a better way to `unique` a list?
22:59:28 <Cale> nub is O(n^2) in the worst case, because it only relies on Eq
22:59:47 <Cale> If your list is sorted, you probably want  map head . group
23:00:07 <zenspider> sortUniq?
23:00:10 <monochrom> I would use sorting somewhere. Maybe a sorted list or a binary search tree (Data.Set)
23:00:37 <Cale> If the order of the list is important to you or you need the function to work on infinite lists, it's possible to implement an O(n log n) ordNub using Data.Set like this:
23:00:43 <zenspider> shit. that's a package... I'm trying to use core only
23:01:01 <zenspider> it's only important for me to write tests
23:01:12 <monochrom> Data.Set comes with GHC.
23:01:44 <Eduard_Munteanu> 'uniq' would be nice, i.e. eliminate consecutive duplicates, let the user sort if it's needed.
23:01:49 <monochrom> Everything is a package. Prelude is in the "base" package.
23:02:07 <Cale> > foldr (\x xs s -> if S.member x s then xs s else x : xs (S.insert x s)) (const []) "mississippi" S.empty
23:02:09 <lambdabot>  "misp"
23:02:30 <monochrom> Even your own code is put into a default package during compilation.
23:02:36 <Cale> Note that this preserves the order of the first occurrences of the elements in the original list, and that it'll work on infinite lists:
23:02:42 <Cale> > foldr (\x xs s -> if S.member x s then xs s else x : xs (S.insert x s)) (const []) [1..] S.empty
23:02:44 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
23:03:23 <zenspider> monochrom: sure... but I mean what ships with ghc
23:03:38 <Cale> Does ghc not ship with containers?
23:04:44 <zenspider> I assume lists of Eqs are also Eq?
23:05:01 <Eduard_Munteanu> Yes.
23:05:02 <Cale> There's an instance Eq a => Eq [a]
23:05:18 <Cale> It uses lexicographic ordering
23:05:27 <Cale> er, heh, the corresponding Ord instance does
23:05:46 <Cale> The Eq instance just compares corresponding elements in the obvious way
23:06:31 <zenspider> is there no constructor from [a] -> Set a ?
23:06:38 <zenspider> not sure I am reading this stuff right yet
23:06:47 <monochrom> "fromList"
23:07:03 <monochrom> Yes, reading comprehension would help.
23:07:39 <zenspider> gotcha... I looked at Constructors, not Conversions
23:07:42 <zenspider> thanks
23:09:13 <Cale> zenspider: btw, follow the advice at the top of the documentation when importing:
23:09:23 <Cale> import Data.Set (Set)
23:09:23 <Cale> import qualified Data.Set as Set
23:10:05 <zenspider> muuuch faster: length $ sort $ toList $ fromList $ fmap id $ permutations ...
23:10:08 <Cale> If you ever need set difference (\\), you might want to put it in the unqualified import list as well
23:10:20 <Cale> what?
23:10:27 <Cale> why sort?
23:10:33 <zenspider> do BOTH of those?
23:10:37 <zenspider> can you explain?
23:10:42 <Cale> yeah
23:10:51 <Cale> Well, the first import imports the type, unqualified
23:10:58 <Cale> So you can just write Set and not Set.Set in types
23:11:06 <Cale> and the second imports everything else qualified
23:11:09 <zenspider> I did: import qualified Data.Set as S (fromList, toList)
23:11:17 <Cale> ah, fair enough
23:11:32 <Eduard_Munteanu> You'll have S.Set in types then.
23:11:38 <zenspider> might bite me later as I continue though this tho
23:11:46 <Cale> Eduard_Munteanu: No you won't ;)
23:12:01 <Eduard_Munteanu> Oh, right.
23:12:06 <Cale> (because you didn't import the type at all, so it had better not be mentioned in signatures)
23:12:12 <zenspider> Cale: sort... just for writing tests
23:12:27 <Cale> S.toList . S.fromList will already sort
23:12:35 <zenspider> ah. cool
23:12:41 <Cale> but for what you're doing  map head . group . sort  is faster
23:12:55 <Cale> > sort "mississippi"
23:12:57 <lambdabot>  "iiiimppssss"
23:13:02 <Cale> > group . sort $ "mississippi"
23:13:05 <lambdabot>  ["iiii","m","pp","ssss"]
23:13:09 <Cale> > map head . group . sort $ "mississippi"
23:13:12 <lambdabot>  "imps"
23:13:40 <Cale> The members of the list produced by group are guaranteed to be nonempty, so it's safe to apply head to them.
23:14:01 <Cale> (I would usually advise against using the head function, but it's okay in idioms like this one)
23:16:05 <cocreature> you can also use head and group from Data.List.NonEmpty
23:29:54 <zenspider> map head group sort feels about as slow as Set from to
23:30:17 <zenspider> dunno how to properly bench stuff yet
23:30:29 <parsnip> is corecursion the same as bottom-up recursion?
23:30:45 <parsnip> is #haskell the best place to ask this? ;)
23:33:00 <parsnip> or is it easier to say something like, "there is some overlap in bottom-up recursion and corecursion", or, "they are sort of the same".
23:33:50 <cocreature> parsnip: I’ve never seen a definition of “bottom-up recursion” but it sounds like a reasonable description of corecursion at least
23:35:52 <parsnip> okay thanks. and i guess i'll use them as rough descriptions, and never claim to understand their precise definitions.
23:53:17 <saurabhn_> Hi, I'm putting together a talk and series of blog posts about writing non-trivial (large-scale) webapps in Haskell. Please ping me with any particular topics that you'd like to see covered.
23:56:46 <dkim> is there a way to write a type-level function that computes the arity of a function?
23:58:31 <geekosaur> 'arity' is a very loose concept in Haskell
23:59:18 <dkim> how about just for monomorphic functions?
