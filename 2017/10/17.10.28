00:13:48 <Lokathor> what's the one where you can reuse a polymorphic variable in a function body after declaring it in the signature?
00:13:54 <Lokathor> there's a GHC extension for it
00:16:41 <liste> Lokathor: a type variable? ScopedTypeVariables
00:16:53 <Lokathor> ugh that doesn't do it
00:16:56 <Lokathor> i mean that's the right one
00:17:04 <Lokathor> but it doesn't make GHC know what I mean :P
00:18:55 <Lokathor> http://lpaste.net/3909485554458165248 i'm trying to do something like this
00:19:27 <Lokathor> abstract over the fact that there's two kinds of storable vectors with a typeclass that lets you get their size and get a pointer to the start of the vectro
00:20:59 <Lokathor> but it won't let me pick the instance for sizeOf properly in the IOVector instance declaration
00:26:52 <Lokathor> WELL
00:27:00 <Lokathor> you can do it with unsafePerformIO 
00:27:01 <Lokathor> :D
00:35:16 <osa1> anyone know how to load a test-suite into ghci with stack repl?
00:37:28 <Unhammer> is there (can there be) a combinator or something that will do "case m of Nothing -> empty ; Just x -> return x" ? (generalising maybeToList)
00:38:24 <Lokathor> Unhammer, what is "empty"
00:39:11 <Unhammer> from Alternative
00:39:17 <MrSkeltal> Unhammer, 'asum'
00:39:22 <MrSkeltal> :t asum
00:39:24 <lambdabot> (Alternative f, Foldable t) => t (f a) -> f a
00:39:35 <Unhammer> ooh thanks
00:39:48 <Unhammer> so foldable is the more general thing than maybe here ‚Ä¶
00:39:55 <MrSkeltal> hmm, no
00:40:00 <MrSkeltal> that is slightly different
00:40:15 <Lokathor> sizeOf (unsafePerformIO $ VSM.unsafeRead vec 0) * len -- whee
00:40:19 <Unhammer> oh wait yeah
00:40:27 <Unhammer> t(f a), wanted t a
00:40:29 <MrSkeltal> asum . fmap pure
00:40:37 <MrSkeltal> but I think there must be a combinator that does exactly that
00:40:59 <MrSkeltal> (Foldable t, Alternative f) => t a -> f a
00:41:00 <MrSkeltal> of some sort
00:41:47 <Unhammer> https://hackage.haskell.org/package/monadplus-1.4.2/docs/Control-Applicative-Alternative.html#v:afold maybe
00:42:01 <Unhammer> agh new dependency
00:42:02 <MrSkeltal> yes
00:42:13 <MrSkeltal> just use 'asum . fmap pure'
00:42:18 <MrSkeltal> :t asum . fmap pure
00:42:20 <lambdabot> (Functor t, Alternative f, Foldable t) => t a -> f a
00:42:45 <Unhammer> mm, thanks :)
00:42:46 <MrSkeltal> :t foldMap pure
00:42:48 <lambdabot> (Applicative f, Monoid (f a), Foldable t) => t a -> f a
00:42:50 <MrSkeltal> this could work too
00:43:10 <MrSkeltal> but this uses Monoid, instead of Alternative monoid family
00:45:27 <Unhammer> huh, cool
00:46:05 <MrSkeltal> hmm no
00:46:14 <MrSkeltal> :t foldr (<|>) empty
00:46:16 <lambdabot> (Alternative f, Foldable t) => t (f a) -> f a
00:46:25 <MrSkeltal> :t foldr ((<|>) . pure) empty
00:46:27 <lambdabot> (Alternative f, Foldable t) => t a -> f a
00:46:42 <MrSkeltal> this is better than 'asum . fmap pure' because Foldable isn't a subclass of Functor apparently
00:54:24 <Unhammer> seems monadplus uses Data.Foldable.asum . map pure . Data.Foldable.toList
00:54:29 <Unhammer> :t Data.Foldable.asum . map pure . Data.Foldable.toList
00:54:30 <lambdabot> (Foldable t, Alternative f) => t a -> f a
00:55:10 <Taneb> I'm surprised there isn't some newtype WrappedAlternative with instance Alternative f => Monoid (WrappedAlternative f a) lurking about
00:56:50 <MrSkeltal> % :info Alt
00:56:52 <yahb> MrSkeltal: type role Alt representational nominal; newtype Alt (f :: k -> *) (a :: k) = Alt {getAlt :: f a}; -- Defined in `Data.Monoid'; instance Alternative f => Alternative (Alt f) -- Defined in `Data.Monoid'; instance Applicative f => Applicative (Alt f) -- Defined in `Data.Monoid'; instance forall k (f :: k -> *) (a :: k). Eq (f a) => Eq (Alt f a) -- Defined in `Data.Monoid'; instance Functor f => Functor 
00:57:07 <MrSkeltal> %% :info Alt
00:57:12 <yahb> MrSkeltal: http://qp.mniip.com/y/99
00:57:29 <MarcelineVQ> that link is amazing
00:57:32 <MrSkeltal> would you please
00:57:32 <Unhammer> uh-oh
00:57:39 <Taneb> MrSkeltal, ooh, cool
00:57:52 <MrSkeltal> http://qp.mniip.com/y/1
00:57:55 <MrSkeltal> is what I mean
00:58:25 <MrSkeltal> I should somehow exclude startup time from the timeout
00:58:38 <Taneb> Unhammer, so getAlt . foldMap Alt would work
00:59:32 <Taneb> Actually I haven't read logs
00:59:35 <Taneb> Ignore me
01:00:17 <Taneb> :t maybe pure empty
01:00:19 <lambdabot> (Alternative ((->) a1), Applicative f) => Maybe a1 -> a2 -> f a2
01:00:24 <Taneb> :t maybe empty pure
01:00:28 <lambdabot> Alternative f => Maybe a -> f a
01:06:13 <ocramz> hullo!
01:06:13 <MarcelineVQ> doh ho ho, you won't trick me freenode, I‚Äã know you're planning on turning all atendees into frogs
01:13:32 <ongy> I wouldn't mind to be a frog
01:13:35 <ongy> forgs have fingers, right?
01:14:09 <MarcelineVQ> sure
02:29:19 <Anthony> hi
02:31:06 <olligobber> hi
02:37:08 <osfameron> webbed fingers iirc
02:37:50 <MarcelineVQ> omy
02:38:22 <tdammers> forgs, hmhm
02:38:32 <tdammers> those are aphmibians, iirc
02:38:53 <tdammers> they have fnigers though, not fingers
02:41:02 <MarcelineVQ> last time I tried to explain that to someone I got banned for a month
02:52:57 <MrSkeltal> pls
03:46:40 <meinhof> i homebrew haskell-platform apm the required packages for haskell's atom setup
03:47:10 <meinhof> however it says ghc-mod is missing something 
03:47:41 <meinhof> i can run ghc, cabal and stack stuff in the terminal doesn't that mean that these things are in the path and the linter should be able to locate it?
03:47:47 <JuanDaugherty> so 'homebrew' meant use an apple pkg mgr?
03:48:00 <JuanDaugherty> apple/mac
03:48:02 <meinhof> yes 
03:48:09 <JuanDaugherty> ah
03:50:47 <cocreature> meinhof: ghc-mod is a separate tool, that you have ghc, cabal and stack available does not mean that you have ghc-mod installed
03:52:03 <meinhof> i can't stack ghc-mod either
03:52:16 <meinhof> it says that it couldn't locate a compiler to begin with
03:52:29 <cocreature> have you run "stack setup"?
03:53:48 <meinhof> doesn't stack setup install the ghc and required packages?
03:53:51 <meinhof> i already have them?
03:54:18 <cocreature> stack installs its own copy of ghc
03:54:25 <MarcelineVQ> it checks to make sure you have what it needs, that may mean using what you've already installed or it maybe mean isntalling its own
03:54:54 <cocreature> by default it never means using what you‚Äôve already installed outside of stack
04:01:19 <MarcelineVQ> note for once you get going, when using atom it's best to run  stack build ghc-mod  from the directory of each new project you create instead of doing stack install ghc-mod
04:26:18 <burgundy[m]> Hi
04:28:37 <meinhof> what is the difference between stack and cabal?
04:28:44 <meinhof> and what is hackage?
04:29:47 <sbrg> meinhof: hackage is basically haskell's "package repository". stack is a build tool for haskell which uses cabal-the-library and uses packages from stackage, which is a curated set of packages known to compile correctly together
04:37:55 <maerwald> stack can also use hackage, afair
04:38:09 <sbrg> yep, and git repos iirc
04:39:01 <MarcelineVQ> yes, though there's ocassional issues with git entries being rebuilt when it shouldn't be neccsary
04:45:50 <sbrg> is that still in there?
04:46:13 <sbrg> that sucks
04:46:47 <ongy> is there a fold variant that lets me do something special to the last element? or do I have to write that as explicit recursion?
04:46:49 <sbrg> that issue deadlocked me once because it kept recompiling some heavy library i had to pull in via git and every compile took so long i couldn't really get anywhere. at least I have a faster computer now
04:48:02 <ongy> some packages do (which I don't like) create files in the src directory during compile, which may trigger recompile since there's *some* difference to the git HEAD
04:49:16 <geekosaur> ongy, explicit recursion or zip your Foldable with something that indicates last element
06:14:15 <Tuplanolla> Does `Backwards` help, ongy?
06:24:44 <buttbutter> ambigious/shitty question: There's that GHCI setting that lets you still have "access" to the types and stuff you've defined in a .hs file even if it fails to compile...what's the setting again?
06:26:02 <MarcelineVQ> -fdefer-type-errors
06:26:27 <MarcelineVQ> you can also use  :load! file  or :reload!
06:27:02 <buttbutter> Oh, cool. :D
06:27:08 <buttbutter> Thanks, exactly what I wanted :) 
06:45:33 <mmaruseacph2> Lokathor: sorry, I left yesterday. I'd be interested to read the rant about the random package, if you have a link, please :)
07:00:31 <cheater> hi
07:35:16 <sm> MarcelineVQ: neat!
07:35:40 <sm> +1 to whoever added that shortcut
07:40:53 <sm> though, -2 for not adding it to user guide or release notes ?
07:42:37 <MarcelineVQ> twas Benjamin Bykowski via thomie it was
07:44:09 <MarcelineVQ> it's in the manual, it's just not at the first spot you see the word :load
07:44:16 <MarcelineVQ> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/ghci.html#ghci-cmd-:load
07:46:25 <MarcelineVQ> :> it's also in the release notes  https://downloads.haskell.org/~ghc/8.0.1/docs/html/users_guide/8.0.1-notes.html#ghci
07:46:45 <contiver> anybody knows how to have a working ghc/stack/cabal in arch linux? it seems an update messed everything up (as far as I read, arch packages aren't statically linked anymore), and now I can't even build using stack :/
07:47:14 <Tuplanolla> Now we just need `-fdefer-syntax-errors` and `:load!!`, not to mention `-fdefer-everything` and `:load!!!`.
07:47:23 <sm> thanks! the [] threw me off. And I searched wrong 8.0.x notes
07:47:41 <contiver> I tried just uninstalling all the arch packages, download a statically linked stack from stackage, and use stack to build, but still no luck.
07:47:41 <mud> contiver: :( I hear so much "fun" going on on arch all the time.
07:48:03 <mud> contiver: What's the actual error? There's a few bug reports, some with suggested fixes.
07:48:29 <contiver> mud: I'll upload it to pastebin.
07:48:49 * sm starting to think about installing arch, can't miss out
07:48:58 <mud> Throw in what version you're on if you can. stack --version
07:49:07 <mud> sm: I hear that misery loves company, so it seems like the right thing to do.
07:49:29 <geekosaur> even avoiding the arch packages, stack can pick tje wrong ghc to install if libtinfo6 is installed
07:50:02 <sm> life is just too boring.. I haven't had a haskell install battle in months
07:50:23 <contiver> geekosaur, so if I uninstall libtinfo6 that might help?
07:50:28 <contiver> mud: https://pastebin.com/Y6eGAC9i
07:50:29 <geekosaur> we can find you an old aix box to try to install ghc on >.>
07:50:54 <sm> 8-)
07:51:00 <geekosaur> contiver, you can try it at least
07:51:17 <geekosaur> someone did habve a different error recently without it, but it seems to work for most people
07:51:47 <fakenullie> looks like broken gcc
07:51:55 <geekosaur> nope
07:52:46 <mud> Hm, the network package rings bells, I think there was one for that ... was that the libtinfo6 thing? *looks*
07:52:50 <geekosaur> although it is related to how ghc configures gcc
07:53:03 <fakenullie> does nixos work good these days?
07:53:23 <MarcelineVQ> fakenullie: a question that general is best asked in #nixos :>
07:53:51 <maerwald> MarcelineVQ: well, you'll likely just get "yes" answers there ;p
07:54:13 <MarcelineVQ> maerwald: sure, but it's a more relevant yes
07:54:18 <geekosaur> this one is not strictly arch's fault btw. it's because the ghc binary distributions are created on debian and arch doesn't follow the same rules
07:55:18 <geekosaur> so none of the bindists quite match what arch needs
07:55:28 <mud> contiver: Maybe this one? https://github.com/commercialhaskell/stack/issues/3488 or maybe this one: https://github.com/commercialhaskell/stack/issues/2712
07:56:18 <contiver> mud: I'll try with that too, thanks.
07:56:41 <geekosaur> (likewise not really stack's fault. at some point it's going to be necessary to make separate bindists for every linux distribution because they all do different things these days)
07:57:40 <mud> Recently it seems like the most common problem people have with stack, it's pretty unfortunate.
07:59:53 <fakenullie> geekosaur: can't you just ship statically linked executables?
08:00:39 <geekosaur> (a) doesn't help when linking programs you build with it (b) doesn't help with things like distributions requiring position independent executables
08:25:48 <buttbutter> If I have something with type m String and I want to convert it to m Integer using liftM and read, how exactly do I specify that I want read to conver the String to an Integer? Normally I'd do something like foo = read "123" :: Integer, but I don't know how to do that in context of liftM and monads.
08:26:28 <buttbutter> Oh I guess I could just do :: m Integer, huh?
08:27:03 <ski>   liftM (read :: String -> Integer) blah  -- or like this ?
08:27:03 <buttbutter> Yeah, that worked, derp
08:27:05 <buttbutter> Nevermind :D
08:27:14 <buttbutter> ski: Oh, I didn't know you could do that :) 
08:27:19 <buttbutter> I like your way better. I'll do it like that.
08:27:57 <ski> note that in case your string doesn't parse correctly, `read' will error out
08:29:11 <buttbutter> ski: That's impossible since I construct the string essentially using a grammar :) 
08:29:24 <buttbutter> (i.e. not from IO or anything)
08:29:58 <ski> mhm
08:30:14 <Fuuzetsu> why not construct the integer straight away?
08:30:35 <mnoonan_> ah, the impossible. one of my favorite things to see happen, even though it isn‚Äôt very rare.
08:31:18 <Fuuzetsu> the impossible has happened!
08:31:21 <buttbutter> Fuuzetsu: I could do that, but I actually need its constiuents, i.e. digits, in Char form so
08:31:49 <Fuuzetsu> converting Integer -> [Char] is total, [Char] -> Integer is not
08:32:03 <buttbutter> Oh, that's true.
08:32:14 <buttbutter> Maybe I'll do it the other way around.
08:32:22 <buttbutter> Really doesn't matter though, in this context. :) 
08:32:43 <Fuuzetsu> it should be faster if anything and removes "impossible" things
08:33:18 <buttbutter> "impossible" things that are outside the input set 
08:33:20 <Fuuzetsu> also liftM = fmap
08:49:44 <fakenullie> do you really need them in their char form?
08:55:05 <nshepperd> Alright, I uploaded https://aur.archlinux.org/packages/cabal-static/
08:56:00 <nshepperd> which basically just installs cabal from the bootstrap script
08:56:21 <nshepperd> so installing that, ghc, ghc-static and removing everything else should work
08:58:01 <nshepperd> hm, I guess ghc-static should be a build dep
08:58:59 <tinco> I wrote some simple processing code, and I just ran it for the first time and it's using 300% CPU
08:59:10 <tinco> is haskell automagically making it parallel?
08:59:30 <tinco> it's also using 35GB of memory..
08:59:36 <tinco> so I'm going to kill it now :P
08:59:58 <geekosaur> there's no automagic parallelization, no
09:00:30 <tinco> hmm I thought putting everything in Vector's was going to limit the memory use, but that doesn't seem to have worked out
09:01:14 <tinco> maybe I should make the vectors strict
09:13:19 <tinco> lol so dumb, I forgot the basecase
09:14:03 <mud> Heh
09:14:12 <Welkin> if you do corecursion, you can never forget the base case
09:14:20 <Welkin> because you start with it
09:14:43 <Ero> hi peeps
09:15:00 <Ero> i've been wondering about seeing forall said in some haskell code
09:15:32 <Ero> i thought that as long as 'a' is a type variable, with no type class constraints, it is considered 'for all a' by default?
09:15:37 <Ero> is this not true?
09:15:43 <Welkin> yes, mostly
09:15:54 <Welkin> you need to enable a compiler extension to use explicit forall
09:16:07 <Welkin> you need to be explicit abou the forall for higher-ranked types
09:16:08 <Ero> What is the benefit of explicitt for all?
09:16:11 <Welkin> like in ST
09:16:12 <Ero> oh
09:16:14 <Ero> thx
09:16:26 <Ero> i havn't a clue about that stuff yet
09:16:26 <tinco> Welkin: I've never heard of corecursion, is it good stuff?
09:16:34 <Welkin> some people prefer to be explicit all the time
09:16:37 <Welkin> it is more math-like
09:16:43 <Ero> is there a good introduction to the purpose of higher ranked types?
09:16:49 <Welkin> I enjoy not having to type `forall ...` all over the place personally
09:17:00 <Welkin> Ero: look up the ST monad
09:17:03 <mud> You can use it with like, ScopedTypeVariables which isn't that advanced, or there's an extension you can turn on to just be able to explicitly specify it with no other actual change in meaning (AFAIK)
09:17:27 <Ero> ok fair, thanks.
09:17:56 <Welkin> tinco: it is similar to recursion, but you start with the base case
09:18:09 <mnoonan_> Ero: the position of the forall is important. For example, you can‚Äôt write the signature (forall t. t -> t) -> Int with the implicit foralls, because they always scope over the entire type
09:18:21 <Welkin> > let fib a b = a : fib b (a + b) in fib 0 1 -- tinco
09:18:21 <mnoonan_> (this is the rank-N types business)
09:18:26 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
09:18:51 <Welkin> it only really works in a lazy language like haskell
09:19:49 <mnoonan_> Ero: rank-N types are there to support the case where you want to pass a polymorphic function as an argument (as opposed to *specializing* a polymorphic function and then passing one of its monomorphic specializations)
09:22:31 <mud> Welkin: Are other similar definitions also corecursion? Like is  let f = 0 : 1 : zipWith (+) f (tail f)  -- corecursion?
09:22:45 <mud> I've never been quite clear on exactly what the definition is.
09:22:47 <Ero> .. so in this way the higher order function is free of type class restraints in its type signature? ,mnoonan_ ?
09:23:56 <Welkin> mud: if it is a function that calls itself, but starts with the base case rather than terminating on the base case, then it is co-recursive
09:24:14 <mud> So it must be a function?
09:24:15 <Welkin> that's how I understand it
09:24:27 <Welkin> what else would it be if not a function?
09:24:36 <mud> Well, my 'f' isn't a function
09:25:05 <mud> It is recursive though ... and it starts with the base case? *shrug*
09:25:20 <Welkin> I'm not sure about that one
09:25:27 <mnoonan_> Ero: no, it‚Äôs orthogonal to type classes. consider the function foo f = (f 42, f ‚Äúhello‚Äù). what type would you give foo?  you might guess foo :: (a -> a) -> (Int, String) would work, but it is problematic (e.g. the caller could instantiate ‚Äòa‚Äô at Int and do ‚Äúf (+1)‚Äù or something)
09:25:29 <Welkin> you are constructing a value recursively
09:26:08 <mnoonan_> foo is using f polymorphically, so you need to have foo :: (forall a. a -> a) -> (Int, String)
09:26:47 <mnoonan_> as opposed to foo :: forall a. ((a -> a) -> (Int, String)), which is what the original type signature I wrote means
09:26:49 <mud> I'm thinking it might count, at least according to what I'm reading on wikipedia (whatever that's worth). Some of the python examples it's using look pretty similar.
09:27:19 <mud> Wait ... some of these aren't even recursive at all. Maybe they're not supposed to be positive examples of corecursion.
09:30:19 <mud> Screw it, I'll just assume it is as long as it builds up from the base case.
09:31:31 <monochrom> In other languages, only functions may use recursion.
09:31:45 <monochrom> In Haskell, all values may use recursion.
09:32:31 <mud> Maybe that's why some aren't recursive, because they chose to use python for some. But then ... is anything that builds up a possibly infinite structure corecursion?
09:33:32 <monochrom> Yes.
09:34:19 <mud> Oh. Alright cool, thanks.
09:34:57 <monochrom> OCaml also allows recursive value definitions, but you have to turn it on by a command line flag.
09:35:27 <monochrom> After turning it on, "letrec x = 0 : x" is allowed just as in Haskell "x = 0 : x".
09:35:57 <mud> Ah, interesting. I'm so used to it just being totally allowed and fine it bugs me in other languages now when you can't ... though of course it makes sense why not usually.
09:36:54 <Welkin> you get that a lot when you have used haskell for a while and then try to use another language
09:37:06 <Welkin> everything seems like it is missing basic features
09:37:42 <fakenullie> heh
09:38:43 <monochrom> You don't need Haskell experience to feel that. Any experience with an ML variant, or even Algol 60 experience, will do.
09:39:04 <Athas> Whenever I use ML I miss operator sections.
09:39:11 <monochrom> Namely, nested function definitions are natural in them, and then you go to C and find that you can't do it anymore.
09:39:25 <Athas> I think much of Haskell's perceived niceness is due to the smooth syntax.
09:39:25 <monochrom> And of course lambda.
09:39:44 <fakenullie> especially confusing why new languages miss these features
09:40:05 <monochrom> Yeah, bear in mind Algol 60 predates C.
09:40:35 <Welkin> fakenullie: there is a move toward ML languages recently
09:40:46 <Welkin> the javascript ecosystem is moving toward that mostly because of facebook
09:41:00 <tinco> is this true? firstStamp + interval > coarseStamp | firstStamp = coarseStamp - (coarseStamp `mod` interval)
09:41:03 <Welkin> they use ocaml heavily, and react is now completely written using their ocaml variant ReasonML
09:41:25 <Welkin> which looks kind of like javascript and ocaml mixed together
09:41:56 <fakenullie> react is written in ocaml?
09:41:58 <Welkin> but we are still recovering from the c+/java/oop disaster from the 80s/90s/2000s
09:42:04 <Welkin> yes
09:42:08 <Welkin> it is compiled from ocaml to javascript
09:42:25 <Welkin> also, 50% of facebook's messenger app is written in reasonml/ocaml
09:42:31 <fakenullie> i need to consider job at facebook
09:43:05 <hpc> emphasis on "consider", sadly
09:43:21 <hpc> aside from a few technology choices, they're not a great place to work
09:43:31 <fakenullie> yeah, that was putting me away
09:43:43 <JuanDaugherty> no? as bad as amazon?
09:43:45 <fakenullie> also I've heard they still use php a lot and I don't want to touch that
09:43:49 <Welkin> lol amazon
09:43:53 <tinco> I've visited their office in london, was pretty cool
09:44:02 <fakenullie> tinco: facebook?
09:44:06 <hpc> i heard amazon varies
09:44:07 <tinco> yeah
09:44:07 <Welkin> amazon is a sweat shop from what I have heard
09:44:11 <tinco> facebook london
09:44:22 <hpc> it's got some pretty terrible jobs, but a few interesting projects aren't terrible
09:44:23 <fakenullie> amazon's office is london isn't great
09:44:32 <hpc> but i don't have a whole lot of info on that
09:44:45 <JuanDaugherty> well if good people don't stay more than a year or two that says a lot
09:45:21 <exio4> I would check wages too
09:45:28 <JuanDaugherty> 3-4 years at amazon seems to be a longer tenure
09:45:42 <tinco> the person who invited me there moved back to the states when his job was sort of done there I think, not sure if he disliked london, or just wanted to get back to the states
09:45:46 <exio4> the better you pay people the more likely they are going to stay if the place sucks, up to a point, of course :)
09:45:52 <Welkin> typical length of stay for any engineer at a software company is 2-3 years
09:46:10 <tinco> also since that office was dead center london, you'd have to negotiate quite a wage to be able to afford to live anywhere close to the office
09:46:25 <JuanDaugherty> i bet it's a lot longer at google and likely fb too
09:46:36 <Welkin> JuanDaugherty: not from what I have seen
09:46:45 <Welkin> big or small company, doesn't seem to matter
09:46:45 <JuanDaugherty> but not like ibm way back when
09:46:52 <exio4> the place where I had an interview yesterday had quick a lot of people which had been there for 5+ years, and it's a software company 
09:47:14 <tinco> I just resigned from my first real IT job after >8 years
09:47:22 <tinco> I think I stayed a bit too long :P
09:47:29 <Welkin> outside of major metro areas it's likely to be longer because of lack of jobs
09:47:37 <JuanDaugherty> staying decades with the same employer in IT still happens, just not a lot
09:47:39 <Welkin> you can just hop around every year
09:47:42 <Welkin> can't*
09:47:47 <hpc> back onto the implicit topic, if you want to work somewhere that you can use languages like haskell or the various MLs, look for someplace where a new project can make that sort of large technology decision at the start
09:48:16 <Welkin> tinco: yes, that is very long
09:48:22 <hpc> rather than having that decision being made for you by "well, this group of programmers refuses to learn something new" and "well, we just did 3 other projects in java"
09:48:29 <Welkin> lol
09:49:02 <JuanDaugherty> hs is the trendy thing nowadays
09:49:02 <tinco> hpc: I was in that position for a while, the rest of the company was not open to Haskell at all, you also need the company culture to agree to your choice of tech, even if you're a manager/architect
09:49:10 <Welkin> I have never been an employee. I've been doing consulting, and the client I work with now has a small team of programmers who only know java and don't want to learn anything new
09:49:38 <hpc> tinco: it's less about "agree to your choice" and more "agree that there is a choice"
09:49:40 <tinco> Welkin: to be fair, I got different responsibilities ever 2-3 years
09:49:42 <fakenullie> java programmers doing some other languages is worse
09:49:47 <Welkin> JuanDaugherty: haskell is something that a lot of people liek to talk about (and gossip about) but very few actually use it
09:49:53 <Welkin> but the people who do use it really love it
09:49:55 <Welkin> I like that
09:49:58 <hpc> tinco: if there's a project where haskell is probably wrong but rust is more suitable, you'll still get to use an interesting language
09:49:59 <JuanDaugherty> prolly peaked the way st had at this point in the 90s but only a very rough analogy, since computing is quite different now
09:50:22 <hpc> tinco: and the next project might be better in haskell, but then you still aren't stuck on rust because the culture lets you decide individually
09:50:46 <JuanDaugherty> same with st, was used in high profile places, some nyc area fin tech, etc.
09:50:50 <JuanDaugherty> like hs now
09:50:52 <hpc> having the company culture "agree with your choice" sounds a lot like "we will only agree if you pick the thing we picked"
09:51:07 <hpc> the key point is evaluating on technical merit instead of opinion
09:51:17 <Welkin> I don't understand the hesitation that people (who have never used anything besides mainstream languages) have when I mention something like haskell, or purescript, or even reasonml
09:51:26 <Welkin> it's not that large of a leap
09:51:43 <JuanDaugherty> one word: "corecursion"
09:51:48 <Welkin> they are worried that their programmers are too lazy to learn a new language or that it is "too hard"
09:51:58 <Welkin> that says something bad about their team or the company
09:52:00 <hpc> that's a sign of a bad programmer imo
09:52:04 <tinco> true, though it could be a gray area, picking Haskell means everyone has to learn it, that might be worth it, or it might not be, regardless of whether haskell is the optimum choice technically
09:52:16 <hpc> when i started at my current job, i ended up learning 4 or 5 languages all in quick succession
09:52:26 <Welkin> a common strawman argument I hear is "it will be hard to find new programmers"
09:52:36 <hpc> like, one a month over the usual period of growing into a new job
09:52:36 <JuanDaugherty> anybody who seriously thinks hs is going to make a serious dent on the computing masses, with its generational turnover and what not is deluded
09:52:44 <ZukoOnFire> hi
09:52:51 <hpc> and it was easy, because each choice was the right language for the job
09:52:57 <Welkin> so they would rather hire bad or mediocre programmers who can write some half-working javascript rather than someone who knows how to write very good functional programs
09:53:14 <hpc> i didn't have to learn 4 different ways of shoehorning incompatible ways of thinking
09:53:40 <hpc> i would argue it was easier that way than to learn a single language that expressed all 4 things
09:53:44 <JuanDaugherty> having ct as ur model of computation is just a poor match for generation js
09:54:12 <ZukoOnFire> I was learning about mempty, and I'm confused on how I would define mempty on a data that has a bool field
09:54:42 <hpc> ZukoOnFire: it depends on how you define mappend for that type
09:55:13 <Welkin> ZukoOnFire: not everything can be a monoid
09:55:19 <Welkin> it might be a semigroup instead
09:55:19 <hpc> look at the laws to know what you have to implement
09:55:26 <hpc> if you can't implement that, yeah look at semigroup
09:55:32 <hpc> or no class instance at all
09:55:42 <ZukoOnFire> I'm trying to define a monoid instance of data C { opt :: Bool ext :: [String] thd :: Int}, and I thought for the mempty definition it would just be mempty = C True [] 0 
09:56:15 <Welkin> why should it be a monoid?
09:56:28 <Welkin> if you just want to combine it, you can use semigroup
09:56:34 <Welkin> you don't need an empty case then
09:56:37 <hpc> it's impossible to know if that's a valid mempty without the rest of the definition and evaluating if it follows the monoid laws
09:57:00 <hpc> how do you know thd shouldn't be 1?
09:57:10 <hpc> it might be the (*) monoid instead of (+)
09:57:10 <ZukoOnFire> oh... i didnt think about the thd either
09:57:15 <ZukoOnFire> ur right
09:57:27 <hpc> you need to consider both operations together
09:57:31 <hpc> and the monoid laws
09:57:47 <hpc> otherwise no single definition is constrained enough to start with first
09:58:20 <ZukoOnFire> but wouldnt a bool always be true for mempty? that's where im confused
09:59:02 <fakenullie> mempty for Or monoid would be False
09:59:35 <cheshircat> Hey, I'm getting linking errors while compiling a yesod application
09:59:39 <fakenullie> :t Any
09:59:41 <lambdabot> Bool -> Any
09:59:46 <cheshircat> do you think any of you could help me?
10:00:20 <hpc> > mempty :: Any
10:00:22 <fakenullie> > mempty :: Any
10:00:24 <lambdabot>  Any {getAny = False}
10:00:24 <hpc> > mempty :: All
10:00:25 <hpc> lol
10:00:26 <lambdabot>  Any {getAny = False}
10:00:28 <lambdabot>  All {getAll = True}
10:00:41 <ZukoOnFire> ^ are those monoids defined for booleans?
10:00:48 <hpc> yes
10:00:52 <hpc> > mempty :: Sum
10:00:55 <lambdabot>  error:
10:00:55 <lambdabot>      ‚Ä¢ Expecting one more argument to ‚ÄòSum‚Äô
10:00:55 <lambdabot>        Expected a type, but ‚ÄòSum‚Äô has kind ‚Äò* -> *‚Äô
10:00:56 <hpc> > mempty :: Sum Int
10:00:59 <lambdabot>  Sum {getSum = 0}
10:01:01 <hpc> > mempty :: Product Int
10:01:04 <lambdabot>  Product {getProduct = 1}
10:01:24 <hpc> most types don't have a single monoid instance
10:01:31 <ZukoOnFire> oh..
10:03:14 <hpc> this is why you need to think about the combination of mempty and mappend - you can't look at a definition of one and ask "is this correct" without knowing the other
10:03:48 <hpc> you have to pick both at once, then test that they follow the monoid laws, then decide if it's useful
10:03:52 <hpc> in that order
10:04:18 <hpc> (both mempty and mappend)
10:04:36 <ZukoOnFire> oh yea i gotcha
10:04:37 <ZukoOnFire> thanks!
10:05:31 <hpc> ZukoOnFire: if this is your first encounter with writing a type class instance, a lot of them are like this
10:06:05 <ZukoOnFire> i got confused when using multiple fields of a data type as opposed to a single field haha
10:06:11 <ZukoOnFire> yea im new to this
10:07:11 <hpc> it's a new way to think if you're used to a lot of other languages
10:07:51 <hpc> the big benefit of these sort of type classes is that as a user, all you need to know about them is the laws
10:08:27 <hpc> so you have a lot of freedom to write stuff that uses monoid or functor, and know that they're going to behave the same in those specific documented ways
10:11:08 <eman0n> Hi there, what is the usage of the colon in the value constructor of data type?
10:11:25 <eman0n> For example, in this section of code:
10:12:09 <eman0n> data Prop = Var Name | F | T | Not Prop | Prop :|: Prop | Prop :&: Prop deriving (Eq, Ord)
10:12:34 <eman0n> what is the usage of :|: and :&: ?
10:12:37 <Welkin> it allows you to create infix constructors
10:12:40 <hpc> those are defining value constructors that are operators, (:|:) and (:&:)
10:13:03 <hpc> the colon at the beginning is required because it is the only "upper-case" symbol character in the language
10:13:13 <Welkin> the colon at the end is not required
10:13:35 <hpc> and constructors always start with something upper-case
10:13:44 <Welkin> for Data.Sequence we have :> and :<
10:14:38 <hpc> also known as grin and moustache
10:14:59 <eman0n> is colon a upper-case character?
10:15:08 <hpc> it's the only one
10:15:17 <Welkin> I mean :<| and :|>
10:15:33 <hpc> (unless there's something else obscure in unicode that nobody uses)
10:15:42 <Welkin> oh yeah, :> and :< are also used
10:17:40 <eman0n> how could we apply this?
10:18:19 <hpc> it's used for exactly the thing you're asking about - defining infix constructors
10:19:02 <monochrom> Your "data Prop = ... | Prop :|: Prop | ..." is already an example.
10:19:08 <hpc> so you can write T :|: F, for instance
10:19:57 <eman0n> ahh..I understand
10:20:15 <eman0n> so :|: is just the name of value constructor when I call it
10:20:21 <hpc> yeah
10:20:27 <qmm> how is convo of type Reader String String? https://gist.github.com/egonSchiele/5752172 and why is $ necessary?
10:20:29 <hpc> and that data Prop line is what defines it
10:20:38 <liste> and :|: is symbolic, so it's written infix
10:20:42 <liste> unlike eg. Var
10:21:16 <monochrom> > case (4 `Just`) of Just x -> x
10:21:20 <lambdabot>  4
10:21:27 <monochrom> >:)
10:21:33 <eman0n> the colon marks the following chars as infix constructor 
10:21:38 <eman0n> thanks
10:21:43 <geekosaur> qmm, the $ is needed because application is higher precedence than almost anything else so it would otherwise parse as (return c1) ++ c2
10:22:20 <geekosaur> I'm not sure what you mean by the other question. what else would it be?
10:22:31 <qmm> geekosaur: i meant for line 19: runReader convo $ "adit"
10:22:55 <geekosaur> because it needs to be (print . runReader convo) "adit"
10:23:17 <monochrom> Oh haha
10:23:17 <geekosaur> otherwise it would be print . (runReader convo adit) which is a type error
10:23:30 <qmm> yeah, i'm not grasping how a reader works
10:23:41 <monochrom> The problem of taken a few words out of context.
10:24:08 <monochrom> Learn operator precedence.
10:24:11 <geekosaur> it carries a read-only value around. you retrieve it with the action "ask", or part of it with "asks" and a selector (useful when the environment is a record)
10:25:10 <qmm> monochrom: i understand operator precendence. i saw (print . runReader convo) "adit" when i read that line, but i don't quite understand how a reader works yet
10:25:41 <qmm> why does it need String String in this case?
10:25:50 <geekosaur> environment is a String, result is also a String
10:26:04 <geekosaur> the environment could be something else instead
10:26:37 <geekosaur> > runReader (asks snd) (1,2)
10:26:42 <lambdabot>  2
10:27:18 <geekosaur> :t runReader ?act (1,2)
10:27:20 <lambdabot> (Num b, Num a1, ?act::Reader (a1, b) a2) => a2
10:27:34 <Samuel__> Is it possible to check whether two custom types are equal on run time? I don't know the type in advanced
10:27:58 <geekosaur> you're going to have bigger problems if you don't know the type in advance
10:28:00 <monochrom> Yes iff both are instances of Typeable.
10:28:38 <monochrom> See the doc of Data.Typeable.
10:28:52 <qmm> https://hackage.haskell.org/package/mtl-2.2.1/docs/Control-Monad-Reader.html#t:Reader helps a lot more than pictures and longer explanations
10:29:00 <qmm> longer explanations = books, blog posts
10:29:01 <Samuel__> Oke thanks. I will take  a look
10:29:42 <qmm> geekosaur's patience also helps :)
10:33:19 <Jack_The_Bittern> HEEEEEEEEEEEEYOOOOOOOOOO!
10:33:47 <Jack_The_Bittern> Bonsoir je m'appelle Jack!
10:34:23 <erisco> Hello Jack, this is an English speaking channel
10:34:47 <terminalcommand> Hello Jack, you might want to check out http://learnyouahaskell.com/ if you're new to haskell
10:35:24 <Jack_The_Bittern> okay sorry, hello my name is Jack and i'm the new bie :)
10:35:41 <fakenullie> is better than http://haskellbook.com/?
10:35:59 <systemfault> No
10:36:11 <systemfault> LYAH's only advantage is its price.
10:36:12 <erisco> it is free, though
10:36:13 <fakenullie> oh, free
10:36:18 <shafox> Is there any example of parsing xml using hexpat ? I cant seem to find any in the hackage. 
10:36:35 <Jack_The_Bittern> can i ask one question?
10:36:45 <systemfault> Yes
10:37:07 <Tuplanolla> Your reading choice depends on whether you want a tour, a course or a project.
10:37:12 <Jack_The_Bittern> and please my english is really bad, i beg, be patient :)
10:37:52 <JuanDaugherty> wir konnen hochdeutsch und est gibt #haskell-de 
10:37:56 <JuanDaugherty> (i think)
10:38:03 <hpc> or #haskell-fr?
10:38:04 <maerwald> haha
10:38:06 <fakenullie> he sounded more like fr
10:38:23 <JuanDaugherty> the host is .de
10:38:27 <systemfault> He/She wrote in french but the IP is from germany.
10:38:37 <Tuplanolla> Right now LYaHfGG is the tour, CIS 194 is the course and HPfFP is the project.
10:39:10 <erisco> such scrutiny
10:39:15 <Welkin> there are many other books
10:39:23 <Jack_The_Bittern> systemfault: vpn do you know that? ;)
10:39:26 <Welkin> and a lot of the best material is in papers and blog posts
10:39:44 <Jack_The_Bittern> so let's talk about my question :)
10:39:51 <Tuplanolla> Of course, but that's overwhelming, Welkin.
10:40:17 <monochrom> Blog posts also have a lot of the worst material.
10:41:01 <monochrom> There is a chicken-egg problem of "so how do I know which blog posts to avoid"
10:41:09 <Jack_The_Bittern> how can i create an infinite list that contains multiples of 3
10:41:19 <Welkin> that is not a chicken and egg problem
10:41:22 <hpc> > [0, 3 ..]
10:41:23 <Welkin> also, the egg came first
10:41:25 <lambdabot>  [0,3,6,9,12,15,18,21,24,27,30,33,36,39,42,45,48,51,54,57,60,63,66,69,72,75,7...
10:41:27 <hcarr> Can someone explain the constraint on Free?  instance (Eq (f (Free f a)), Eq a) => Eq (Free f a) where
10:42:17 <hpc> @src Free
10:42:17 <lambdabot> Source not found. You untyped fool!
10:42:37 <hpc> data Free f a = Pure a | Free (f (Free f a))
10:42:47 <hcarr> It seems circular: the constraint depends on what is to the right of =>
10:42:56 <hpc> hcarr: to compare values of type (Free f a) for equality, you need to be able to compare the constructors (which it has)
10:43:02 <hpc> hcarr: and the fields of the constructors
10:43:09 <hpc> hcarr: which are a and (f (Free f a))
10:43:15 <Jack_The_Bittern> nope i talking about something like [1^3, 2^3, .... ]
10:43:55 <hpc> hcarr: it's circular because Free is circular
10:44:03 <monochrom> I wonder if Free Maybe Int is inferred to be in Eq despite the circularity.
10:44:16 <JuanDaugherty> welkin, right that's the kind of thing that trips up dummies. The last non-chicken laid the first chicken egg.
10:44:34 <monochrom> But where did you find "instance (Eq (f (Free f a)), Eq a) => Eq (Free f a)"?
10:44:35 <liste> > map (^3) [1..] -- JuanDaugherty 
10:44:39 <lambdabot>  [1,8,27,64,125,216,343,512,729,1000,1331,1728,2197,2744,3375,4096,4913,5832,...
10:44:40 <liste> Jack_The_Bittern: ^
10:44:42 <liste> not JuanDaugherty 
10:45:11 <Gurkenglas> Why are types boxed in the first place?
10:45:27 <hcarr> https://hackage.haskell.org/package/free-4.12.1/docs/src/Control-Monad-Free.html#Free
10:45:34 <monochrom> For both polymorphism and GC.
10:45:42 <hpc> and laziness
10:45:49 <monochrom> Err yeah, I missed that one.
10:46:30 <monochrom> 1^3, 2^3, ... n^3, ... are cubes.
10:46:31 <hcarr> so I guess I am asking how GHC resolves the circularity
10:47:25 <Gurkenglas> I suppose since boxes allowing bottoms makes sense, I don't need to understand how the first two require boxes.
10:48:12 <monochrom> C++ doesn't box your values, so its parametric polymorphism story (templates) requires duplicating code.
10:48:43 <monochrom> There are two ways to compile "f :: a -> a; f x = x".
10:48:55 <monochrom> One way is that all types (values?) are boxed.
10:49:24 <Gurkenglas> Makes sense, assembly instructions that depend on operand length are the culprit :3
10:49:37 <monochrom> Another way is to generate code for f::Int->Int, for f::[Int]->[Int], and f::Bool->Bool.
10:49:37 <Jack_The_Bittern> soory i have lost my connection
10:50:10 <monochrom> GHC does the former, C++ does the latter.
10:50:41 <Jack_The_Bittern> please help me
10:50:41 <monochrom> And it is emphatically, intentionally, deliberately why they call it "template". They really clone the template ad infinitum.
10:50:43 <Gurkenglas> hcarr, it just uses the provided instance in the implementation, yielding recursion. Yes, this means it may go into an infinite loop if the instances are defined that way.
10:51:14 <Jack_The_Bittern> i try to create a list like [3, 8, 27, 64, ... ]
10:51:26 <liste> > map (^3) [1..] -- Jack_The_Bittern these are cubes, not multiples of 3
10:51:29 <lambdabot>  [1,8,27,64,125,216,343,512,729,1000,1331,1728,2197,2744,3375,4096,4913,5832,...
10:51:42 <hcarr> @Gurkenglas - simple!  thx
10:51:42 <lambdabot> Unknown command, try @list
10:52:23 <Jack_The_Bittern> lambdabot: can i do it like you show or i have to change something?
10:52:51 <JuanDaugherty> it's not that smart
10:52:51 <liste> Jack_The_Bittern: you can do it just like that, "map (^3) [1..]"
10:52:59 <liste> lambdabot's a bot
10:53:10 <mud> > "am not"
10:53:13 <lambdabot>  "am not"
10:53:35 <liste> > text "I am not a bot"
10:53:38 <lambdabot>  I am not a bot
10:53:48 <monochrom> And now, how to practice parametric polymorphism in Go: https://twitter.com/mosheroperandi/status/856946180810354688
10:54:29 <mud> monochrom: :-/
10:55:01 <Jack_The_Bittern> lambdabot: he is right, you are a bot, i remember now, i have seen you in haskell-fr
10:55:20 <hpc> there are only bots in #haskell-fr donchaknow
10:56:18 <Jack_The_Bittern> i don't think so, i was there and they were very helpful
10:57:59 <Jack_The_Bittern> "bot"
10:58:12 <Jack_The_Bittern> text "bot"
10:59:18 <fakenullie> > putStrLn "No, you"
10:59:20 <lambdabot>  <IO ()>
10:59:58 <Jack_The_Bittern> I want to do a function that takes a number as an argument and tests if there is another number n such that sum of n ^ 3 ranging from i to n equals to m
11:00:47 <Tuplanolla> Sounds like number theory, Jack_The_Bittern.
11:01:07 <Jack_The_Bittern> Tuplanolla: it is not
11:01:34 <monochrom> OK so success, (==) on Free Maybe Int works fine.
11:02:21 <monochrom> Also it's an undecidable instance so the most important loop is at compile time.
11:02:34 <Jack_The_Bittern> Tuplanolla: i justt wanna write this function, i have already try something but it does not work correctly, you know!
11:02:53 <monochrom> As for run-time loop it's no worse that (==) for [Int].
11:02:56 <Jack_The_Bittern> Tuplanolla: https://repl.it/NXP7/1
11:03:32 <Jack_The_Bittern> i know, that's really wrong!
11:03:39 <monochrom> I'm actually surprised that I don't have to turn on FlexibleContext
11:03:47 <qmm> when is it appropriate to use STM instead of the State monad?
11:03:48 <Tuplanolla> I think you're approaching the problem from the wrong angle, Jack_The_Bittern.
11:03:56 <tinco> lol someone on this exchange made a transaction with volume 0
11:04:00 <tinco> how is that even possible...
11:04:16 <Jack_The_Bittern> Tuplanolla: i think so
11:04:23 <monochrom> tinco: Wrong channel?
11:04:34 <tinco> monochrom: oh sorry.. I'm parsing exchange data in haskell :P
11:05:22 <monochrom> I guess you'll have to get used to redundant but harmless syntax in Haskell. For example:
11:05:25 <Jack_The_Bittern> tinco: you don't
11:05:27 <monochrom> > let {} in 5
11:05:32 <lambdabot>  5
11:05:49 <Jack_The_Bittern> let {} in 5
11:06:03 <Gurkenglas> monochrom, looks like templating could be replaced by passing the size of the parameter types to polymorphic functions https://github.com/ollef/sixten
11:06:19 <monochrom> So that's like a set of local definitions with 0 definitions. Analogous to a transaction that does nothing.
11:06:23 <Jack_The_Bittern> monochrom: why the lambdabot don't working with me?
11:06:35 <monochrom> Are you a programmer?
11:07:58 <Jack_The_Bittern> monochrom: Yep but not a haskell programmer, i try to become one at the moment!
11:08:15 <monochrom> Do you have attention to detail?
11:08:26 <athan> Jack_The_Bittern: mind the greentext
11:09:06 <monochrom> Because a programmer is supposed to have attention to detail.
11:10:29 <Jack_The_Bittern> monochrom: i don't, if i suppose, that isn't useful yet
11:10:52 <Tuplanolla> @let sq = join (*)
11:10:54 <lambdabot>  Defined.
11:10:59 <Tuplanolla> @let sumOfCubesFromTo a b = let f n = quot (sq (n * (n + 1))) 4 in f b - f (a - 1) -- This is how I would approach it, Jack_The_Bittern.
11:11:02 <lambdabot>  Defined.
11:11:08 <athan> Jack_The_Bittern: lambdabot recognizes commands based on usually a prefix
11:11:09 <Tuplanolla> > sumOfCubesFromTo 13 20
11:11:11 <lambdabot>  38016
11:11:15 <monochrom> OK that explains why. You need to be able to see how my input and your input differ by two characters.
11:11:23 <Jack_The_Bittern> athan: can you be a little more explicit? 
11:11:25 <athan> there's some commands that start with @foo, while evaluating a haskell expression can be done with `> ...`
11:11:32 <Tuplanolla> It's number theory from start to finish.
11:11:35 <monochrom> That is the attention to detail that is expected of programmers.
11:11:58 <athan> @undefine -- >:D
11:11:58 <lambdabot> There's currently no way to undefine just one thing.  Say @undefine (with no extra words) to undefine everything.
11:12:07 <monochrom> Yes it is a big deal because no matter which language you use, if you're writing code to validate user input, two characters make a big difference.
11:12:08 <athan> agh psh the command parser doesn't support comments?
11:12:36 <jle`> athan: the comand parser doesn't parse haskell syntax...
11:12:43 <monochrom> Or writing code to read CSV, or writing code to output CSV, or whatever.
11:12:45 <jle`> even if it does support comments, it might not be with --, heh
11:12:48 <athan> it should :|
11:12:51 <athan> higher order commands
11:13:03 <jle`>  @undefine is already not haskell syntax :o
11:13:27 <athan> agh crap you got me
11:13:47 <Tuplanolla> Could you use Template Haskell to unsplice things, jle`?
11:13:54 <geekosaur> athan, some commands support comments, others don't
11:13:57 <Jack_The_Bittern> Tuplanolla: i try to learn haskell for 1 Day ago, please can you explain your syntax and the meaning?
11:14:10 <geekosaur> it just passes the whole rest of the line to the function
11:14:26 <Tuplanolla> I solve the problem with pen and paper and wrote the solution as a Haskell function, Jack_The_Bittern.
11:15:35 <athan> Jack_The_Bittern: I think you should read up on it, it'll be hard scavanging for proactive help on here. #haskell-beginners might also be better
11:15:48 <athan> well, not hard, but... maybe a bit too quick :)
11:16:21 <Tuplanolla> I second athan's advice. Asking us to solve problems will give you interesting solutions, but no insight beyond that, Jack_The_Bittern.
11:17:58 <Jack_The_Bittern> Tuplanolla: please can you link me your Solution?
11:19:23 <kuko1> Jack_The_Bittern: see e.g. https://proofwiki.org/wiki/Sum_of_Sequence_of_Cubes ; there is a closed formula for a "sum of cubes", so there is no need to compute the sum by gradually adding up all the terms
11:20:31 <kuko1> Jack_The_Bittern: next, if you know how to compute S(n) = sum from 1 to n, but you want a sum from a to b, it's just S(b)-S(a-1)
11:22:55 <Jack_The_Bittern> kuko1:I know how to express a sum in mathematics. the problem does not come from there. in any other imperative language like C ++, I will have solved this problem in 5sec, I needed your help to show me how does it with Haskell syntaxes
11:24:22 <kuko1> Jack_The_Bittern: see the code Tuplanolla gave you: sumOfCubesFromTo a b = let f n = quot (sq (n * (n + 1))) 4 in f b - f (a - 1)
11:25:13 <Jack_The_Bittern> kuko1: that is why i ask for explanation. what is sq and quot?
11:25:39 <kuko1> sq x = x * x -- a square of a number
11:25:53 <monochrom> If you solved it in 5 second using C++, you must have been typing at 30 words per second.
11:26:14 <kuko1> https://hackage.haskell.org/package/base-4.10.0.0/docs/Prelude.html#v:quot
11:26:27 <kuko1> quot is quotient (integer division)
11:32:21 <Tuplanolla> Actually `sq (quot (n * (n + 1)) 2)` would be more sensible.
11:32:38 <Jack_The_Bittern> it's sq or seq because I can not find sq in Hoogle
11:33:00 <monochrom> sq. The code for sq was shown a few lines above.
11:39:34 <Jack_The_Bittern> Tuplanolla: please, you mean you have written the solution with pen and paper, can you give me a link? üôÉ
11:40:03 <Tuplanolla> You just got the same explanation from kuko1, Jack_The_Bittern.
11:41:25 <monochrom> But you have to give a link!
11:41:35 <Jack_The_Bittern> Tuplanolla: i want to see the code of sq
11:41:49 <Jack_The_Bittern> please give me the link
11:42:00 <Tuplanolla> You've been given it twice already, Jack_The_Bittern.
11:43:27 <monochrom> I guess we just have to wait for ircbrowse.net to catch up.
11:43:29 <Tuplanolla> > please give the codes
11:43:35 <lambdabot>  join (*)
11:43:58 <monochrom> Then we can give a link to the line when kuko1 wrote the one-liner.
11:44:13 <Tuplanolla> Quick thinking, monochrom.
11:45:40 <Jack_The_Bittern> Tuplanolla:  sumOfCubesFromTo a b = let f n = quot (sq (n * (n + 1))) 4 in f b - f (a - 1) is that the link, that you mean? i was thinking pen and paper was a online IDE
11:46:59 <kuko1> Jack_The_Bittern: "pen and paper" as an actual "pen" and "paper", like this: http://assets2.bigthink.com/system/idea_thumbnails/54952/size_1024/shutterstock_131815385.jpg?1398799624
11:47:23 <monochrom> Oh great. In two generations, kids will assume that "farming" is a Steam game, too.
11:47:35 <athan> monochrom: thank you
11:47:40 <mauke> I thought "offline" was an ISP
11:47:57 <Welkin> lol what lambdabot 
11:48:02 <Welkin> > please give the codes
11:48:03 <monochrom> But who am I kidding? People already think that "dash board" means control panel.
11:48:05 <lambdabot>  join (*)
11:48:08 <Welkin> is that a secret message?
11:48:33 <athan> @type please
11:48:35 <lambdabot> p1 -> p2 -> p3 -> Doc
11:48:39 <Welkin> o.o
11:48:41 <athan> ooohhhhh
11:48:58 <athan> @src codes
11:48:59 <lambdabot> Source not found.
11:49:01 <athan> mer
11:49:12 <Welkin> hi athan 
11:49:16 <Jack_The_Bittern> kuko1: now i understand, apparently you do not know "pen a paper" the IDE online to share the code, I thought that's where he had written
11:49:17 <monochrom> @type codes
11:49:19 <lambdabot> Doc
11:49:19 <athan> Sup Welkin, how've you been man
11:49:26 <Jack_The_Bittern> @test
11:49:26 <lambdabot> Maybe you meant: tell list let leet
11:49:34 <Jack_The_Bittern> @retest
11:49:37 <lambdabot> Unknown command, try @list
11:49:51 <Welkin> athan: good. I'm doing some opengl in haskell today
11:50:08 <athan> :O that sounds cool, with glfw?
11:50:12 <Welkin> sdl2
11:50:16 <athan> nice
11:50:19 <Jack_The_Bittern> @type opengl
11:50:19 <fakenullie> @source please
11:50:21 <lambdabot> error: Variable not in scope: opengl
11:50:21 <lambdabot> Unknown command, try @list
11:50:28 <Welkin> I find it nicer than using C for the same thing
11:50:32 <Welkin> even with the extra marshaling
11:50:51 <Jack_The_Bittern> @build cabal
11:50:51 <lambdabot> Can't find 'cabal'
11:51:03 <Jack_The_Bittern> @help
11:51:04 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
11:51:12 <Welkin> Jack_The_Bittern: you can play with lambdabot in a private message, but please don't spam the channel
11:51:14 <Jack_The_Bittern> @list
11:51:14 <lambdabot> What module?  Try @listmodules for some ideas.
11:51:27 <athan> Jack_The_Bittern: could you message lambdabot privately?
11:51:35 <Jack_The_Bittern> Yep
11:51:40 <athan> right arm :)
11:51:40 <Jack_The_Bittern> sorry1
11:57:44 <Jack_The_Bittern> so let thanks for tonight, I will come back when when the book will destroy me again ‚úåÔ∏è
11:58:32 <Jack_The_Bittern> :quit
11:58:43 <Jack_The_Bittern> @quit
11:58:43 <lambdabot> Not enough privileges
12:10:07 <Garmy> Hello.
12:12:01 <Garmy> I have a problem and I came up with an ugly solution to it
12:12:21 <Garmy> And I wanted to ask for a hint how to improve it.
12:13:26 <mud> Garmy: Sounds fun. lpaste it?
12:15:37 <Garmy> Currently doing that, and removing unnecessary lambdas :)
12:16:06 <Garmy> http://lpaste.net/5220797807899705344
12:17:56 <Garmy> I have a function that takes a string or something, extracts some parts of it, and returns all possible combinations of extracted parts and leftover string
12:19:04 <Garmy> And now I want to "deconstruct" the whole string into those parts. The "combinations" function in the paste does this but I have the feeling I'm missing something obvious.
12:20:22 <jle`> @letlpaste 5220797807899705344
12:20:24 <lambdabot>  Defined.
12:20:51 <athan> rofl
12:20:55 <mud> Garmy: You only use 'pref' once, so naming it seems unimportant. The part whene you check if something is null is usually better done via pattern matching, so probably a case statement I guess.  case combinations prefixes rest of [] -> whatever   xs -> whatever else
12:20:58 <jle`> > combinations (\n -> [ (n, k) | k <- [1..n]]) 10
12:20:59 <athan> can you reserve lpaste keys?
12:21:05 <lambdabot>  mueval-core: Time limit exceeded
12:21:09 <jle`> > combinations (\n -> [ (n, k) | k <- [1..n]]) 2
12:21:15 <lambdabot>  mueval-core: Time limit exceeded
12:21:28 <jle`> hm am i using this incorrectly
12:21:31 <jle`> just want to see how it works
12:22:00 <jle`> > combinations (\n -> if n == 0 then [] else [(n, n - 1)]) 3
12:22:04 <lambdabot>  [[3,2,1]]
12:22:06 <Garmy> > combinations (\s -> take 2 . drop 1 $ zip (inits s) (tails s)) "abcd"
12:22:09 <lambdabot>  [["a","b","c","d"],["a","b","cd"],["a","bc","d"],["ab","c","d"],["ab","cd"]]
12:22:31 <jle`> > (\s -> take 2 . drop 1 $ zip (inits s) (tails s)) "abcd"
12:22:34 <lambdabot>  [("a","bcd"),("ab","cd")]
12:22:47 <jle`> hm
12:23:02 <jle`> looks just like some iterateM for StateT a []
12:24:52 <Garmy> Thanks so far
12:25:04 <jle`> hm
12:25:11 <jle`> no it's more like WriterT a []
12:26:52 <jle`> actually nvm :) it doesn't fit quite perfectly into either pattern
12:34:34 <Garmy> Something like this already looks a little better, heh http://lpaste.net/5422909519921414144
12:41:23 <buttbutter> What's the most elegant way to take something like  monadic values m a1, m a2, m a3  (all of the same type) and combine them into m (a1 ++ a2 ++ a3)? I guess that was sort of notation bastardization, but do you get what I mean :D?
12:42:04 <buttbutter> I know you can do it (super ugly) with liftM2... (so liftM2 (++) (m a1) (m a2))...but that sucks! :D
12:42:26 <buttbutter> (You'd need a second call to liftM2 after that first one to add the m a3 value in)
12:44:01 <Rembane> buttbutter: What about `ap`?
12:44:12 <Rembane> buttbutter: Or mapM?
12:44:15 <Rembane> :t mapM
12:44:17 <lambdabot> (Monad m, Traversable t) => (a -> m b) -> t a -> m (t b)
12:44:31 <Rembane> ...if you have something traversable.
12:44:40 <buttbutter> Oh, right. Of course. :) 
12:44:45 <buttbutter> My haskell is so rusty >:D
12:44:47 <buttbutter> Thanks./
12:46:09 <Welkin> buttbutter: maybe you are confused with rust
12:46:30 <Lokathor> Anyone care to sanity check my module? Only about 50 lines https://github.com/Lokathor/gl-simple/blob/master/src/Graphics/GL/Simple/Types.hs#L31
12:46:54 <Lokathor> i just wanted to have an abstraction against the mutable and immutable versions of storable vectors, and I'm pretty sure i did it right
12:47:52 <buttbutter> Welkin: I wish, but I don't even know rust :( 
12:48:12 <buttbutter> but 8/10 pun
12:48:27 <Lokathor> buttbutter, do you know java/C style code? rust is pretty easy to get into if you're a Haskell user
12:52:32 <buttbutter> Lokathor: I'm very well aquainted with C.
12:52:50 <buttbutter> acquainted*
12:52:59 <Rembane> buttbutter: No worries.
12:53:02 <Lokathor> then you could pick up rust fairly quickly if you were so inclined
12:53:02 <buttbutter> But at the moment I'm not so interested in learning it. Maybe later :) 
12:53:23 <Lokathor> it's like haskell but faster and with worse type errors!
12:53:42 <Lokathor> and worse compile times too
12:53:44 <Welkin> it's not like haskell at all
12:53:45 <Welkin> o.o
12:53:50 <Welkin> rust is not  functional language
12:54:02 <Welkin> it has a cool type system though
12:54:05 <Lokathor> Hmm, it's like how I use haskell then ;P
12:54:49 <hodapp> I am rather impressed with the amount of practical design that was put into Rust.
12:55:24 <Welkin> yes, I will very likely use rust next time I need a language with manual memory management like C
12:59:28 <HoloIRCUser> hello
12:59:42 <dmj`> HoloIRCUser: hello
12:59:47 <HoloIRCUser> what is haskell?
13:00:09 <HoloIRCUser> not trolling, serious
13:00:47 <htse> it's a programming language
13:01:30 <dmj`> HoloIRCUser: https://www.haskell.org/
13:02:12 <Welkin> dmj`: you linked to the correct website
13:02:22 <HoloIRCUser> what is good about haskell compared to other programming languages?
13:02:38 <Welkin> HoloIRCUser: read the page to find out
13:03:31 <Lokathor> We make ivory towers out of better ivory than all the other ivory towers are made of
13:03:38 <dmj`> HoloIRCUser: purity, immutability, concurrency, laziness (depending on which haskell person you ask), advanced type system (compared to mainstream languages)
13:04:08 <Welkin> I recently saw someone link to haskell-lang.org instead of the official haskell website and it made me remember that whole debacle
13:05:03 <dmj`> Welkin: similar color scheme :)
13:05:16 <hodapp> Lokathor: was that a pun because Ivory and Tower are both Haskell libraries from Galois? >_>
13:05:45 <Lokathor> the concept of an "ivory tower" is a very old one
13:05:55 <Lokathor> i've never heard of that company
13:05:56 <HoloIRCUser> i will try it
13:06:02 <hodapp> HoloIRCUser: what is your existing programming experience like?
13:06:04 <Welkin> Lokathor: have you heard of the person?
13:06:11 <hodapp> Lokathor: you're in Haskell and haven't heard of Galois?!?!
13:06:23 <HoloIRCUser> i am more of a sysadmin
13:06:26 <Welkin> I wouldn't expect anyone to know the company
13:06:33 <Welkin> but ther mathematician, yes
13:06:39 <Welkin> the*
13:06:40 <htse> I know Gauloises
13:06:40 <hodapp> and I wouldn't expect anyone to know Haskell but here we are :P
13:07:08 <Lokathor> Welkin, nope. google says they were some math person from long enough ago that their picture is in pencil
13:07:15 <HoloIRCUser> lil bit of java
13:07:24 <hodapp> HoloIRCUser: any scripting?
13:07:36 <Welkin> Lokathor: Galois created Galois Theory. He died at age 24 in a pistol duel
13:07:42 <HoloIRCUser> i can use shell scripts
13:07:44 <Lokathor> HoloIRCUser, Haskell is pretty different from java. in fact it's about as far from java as you can go
13:07:49 <HoloIRCUser> is that scripting?
13:08:12 <Lokathor> hodapp, why would i have heard of G man?
13:08:22 <hodapp> HoloIRCUser: Java is statically-typed (as Haskell is) but Haskell's type system is much more advanced
13:08:31 <hodapp> so it may be quite a transition
13:08:33 <Welkin> all languages are statically typed
13:08:36 <Welkin> :P
13:08:42 <Welkin> the terminology is bad
13:08:43 <Welkin> all around
13:08:45 <hodapp> Welkin: not in any useful sense
13:08:50 <Welkin> scripting language?
13:08:58 <hpc> "all types are static" maybe?
13:08:58 <Welkin> everything is a scripting language these days
13:09:22 <Welkin> "dynamically-typed" languages either have no type system, or they have a type system with exactly one type
13:09:22 <hpc> that also addresses the silliness of things like "type error" exceptions in dynamic languages
13:09:48 <Lokathor> Welkin, we know that but this is a beginner so we gotta take baby steps as we explain
13:09:50 <hodapp> Welkin: that's not really a definition that's of any practical usefulness
13:10:12 <Welkin> I generally just say they have no type system
13:11:26 <Welkin> in javascript, did you know that NaN is a number? and 1 + true = 2
13:11:28 <Welkin> anything is possible
13:11:39 <HoloIRCUser> woah
13:12:49 <Welkin> the same is true in python (and perhaps ruby)
13:13:29 <fakenullie> but what does TypeError mean if it only has one type?
13:14:50 <Welkin> the "types" are tags applied at runtime to the values
13:15:12 <Welkin> and they can change
13:16:01 <fakenullie> you're right, python only has objects
13:17:13 <fakenullie> and javascript has polymorphic objects
13:18:03 <Welkin> polymorphic?
13:18:15 <Welkin> javascript has hash tables
13:18:24 <Welkin> arrays are just hash tables
13:18:26 <Welkin> like in lua
13:18:37 <Welkin> indexed only by strings
13:18:59 <fakenullie> numbers are not hash tables
13:19:09 <Welkin> oh I see
13:19:11 <Welkin> yes
13:19:14 <hpc> everything is polymorphic if you can't statically determine what type it is
13:19:44 <HoloIRCUser> what is a good use for haskell?
13:19:56 <hpc> writing programs :P
13:20:01 <Lokathor> HoloIRCUser, server stuff that doesn't need to interact with the user through a GUI
13:20:04 <HoloIRCUser> on the web, local code, scripting?
13:20:15 <Lokathor> so, data processing, network servers, database programs, things like that
13:20:47 <ertes> is there a performance advantage to using strict MutVar# fields instead of strict IORef fields?
13:21:35 <contiver> if the latest version of a package in hackage is 1.0, and the previous one is, say, 0.5, is it possible to upload a 0.5.1 (say, to fix something), and will hackage keep them in the correct order? (0.5, 0.5.1, 1.0)
13:21:43 <hpc> contiver: yes
13:21:47 <fakenullie> hmm, even property assignment does not work on numbers in javascript
13:21:56 <contiver> hpc, thanks
13:22:26 <ertes> for example i notice that IORef actually uses a *boxed* MutVar#, and that looks like it would be an extra indirection that i could eliminate by using MutVar# directly
13:24:16 <Lokathor> ertes, you probably have to profile
13:24:34 <Lokathor> see how much it inlines
13:29:59 <Welkin> Lokathor: that is not true
13:30:04 <Welkin> haskell can be used to write anything
13:30:11 <Welkin> it is great for writing GUIs as well
13:30:18 <Welkin> the best GUI these days is the browser
13:31:05 <Cale> I spend quite a bit of my time at work working on web frontends in Haskell, using reflex-dom. :)
13:31:42 <Cale> Well, web and mobile
13:32:23 <cvon> Im having trouble with a monoid conversion function. I'm getting this error: No instance for (Monoid Bool) arising from a use of ‚Äòmempty‚Äô. Has anyone gotten this before?
13:32:58 <Cale> It makes a fair amount of sense to use the DOM as a GUI for desktop and mobile apps as well, especially if you control the DOM directly with native code rather than Javascript.
13:33:01 <mnoonan_> cvon: I think you have to pick your monoid instance via Any or All
13:33:23 <Cale> Yeah, Bool doesn't have a monoid instance, but Any and All do.
13:33:55 <HoloIRCUser> what is DOM?
13:34:05 <Welkin> Document Object Model
13:34:12 <codeshot> Bool has several good choices for monoid instances so not one of them has been hard coded as *the* choice
13:34:14 <Welkin> it is the api used in the browser
13:34:33 <cvon> Thanks , yea i noticed. But when I try to add Any before my True in my mempty definition of the monoid instance definition, I get the error: Couldn't match expected type ‚ÄòBool‚Äô with actual type ‚ÄòAny‚Äô
13:34:59 <mnoonan_> cvon: your result will now be an Any, too.
13:35:19 <mnoonan_> you might want to look into the ‚Äònewtype‚Äô package
13:35:21 <codeshot> cvon, you probably should use newtype even if Any and All work because newtype will document the meaning of the way Bools are rolled up
13:35:41 <codeshot> you have some function that wants a Bool instead of a Monoid
13:35:48 <cvon> yea
13:35:53 <Cale> Our mobile apps actually run 3-4 times faster compiled to native code running on phones than they do running in the browser on a desktop machine when compiled to Javascript.
13:35:54 <codeshot> either change it to accept a Monoid or convert the Any to Bool
13:36:05 <codeshot> and then pass it in
13:36:38 <mnoonan_> > Any `op` mempty
13:36:41 <lambdabot>  False
13:36:47 <mnoonan_> > All `op` mempty
13:36:50 <lambdabot>  True
13:36:52 <mud> Cale: I need to try that part. Is the mobile stuff easy enough for random people to do? It's not internal-only for you all, right?
13:36:56 <codeshot> > getAny $ Any True
13:36:56 <dmj`> Cale: when it runs on the phone, it‚Äôs run in a WebView right?
13:36:58 <lambdabot>  True
13:37:06 <Cale> dmj`: correct
13:37:22 <Cale> mud: We recently released support for iPhone and Android in reflex-platform
13:37:42 <mud> Awesome
13:37:51 <fakenullie> is it like react-native?
13:37:57 <fakenullie> or just web
13:37:59 <dmj`> Cale: ah, so is the JS just loaded into the WebView? Or does the WebView fetch the js from a server
13:38:33 <Cale> fakenullie: I don't know how react-native works well enough to answer that question. It compiles your Haskell to native ARM code that controls a web view widget.
13:38:50 <Cale> There's no JS (or at least, there doesn't have to be any)
13:38:56 <codeshot> cvon, I find it works out nicely to use getAny at the last sensible moment then functions working on Monoids just compose together naturally
13:39:35 <fakenullie> > getAny True
13:39:39 <lambdabot>  error:
13:39:39 <lambdabot>      ‚Ä¢ Couldn't match expected type ‚ÄòAny‚Äô with actual type ‚ÄòBool‚Äô
13:39:39 <lambdabot>      ‚Ä¢ In the first argument of ‚ÄògetAny‚Äô, namely ‚ÄòTrue‚Äô
13:40:00 <fakenullie> > getAny mempty
13:40:00 <monochrom> It's getAny (Any True)
13:40:02 <lambdabot>  False
13:40:20 <Cale> That's why the app version of our projects on actually runs faster on phones than the web version runs on a desktop machine -- it's native ARM code that's controlling everything rather than Javascript.
13:40:23 <fakenullie> getAny (True <> False)
13:40:28 <fakenullie> > getAny (True <> False)
13:40:34 <lambdabot>  error:
13:40:34 <lambdabot>      ‚Ä¢ Couldn't match expected type ‚ÄòAny‚Äô with actual type ‚ÄòBool‚Äô
13:40:34 <lambdabot>      ‚Ä¢ In the first argument of ‚ÄògetAny‚Äô, namely ‚Äò(True <> False)‚Äô
13:41:23 <fakenullie> somehow I thought there's some "magic" that converts Bool to corresponding monoid when you use getAny
13:41:54 <monochrom> Naw, wrong direciton. getAny :: Any -> Bool, not Bool -> Any.
13:42:05 <codeshot> > getAny $ mconcat (Any <$> [True, False])
13:42:08 <lambdabot>  True
13:42:13 <fakenullie> that one
13:42:20 <fakenullie> ah, no
13:42:25 <monochrom> Instead, Any :: Bool -> Any is the one converting Bool to the Any monoid.
13:42:32 <codeshot> but be warned:
13:42:38 <codeshot> getAny $ mconcat (Any <$> [])
13:42:44 <codeshot> > getAny $ mconcat (Any <$> [])
13:42:47 <lambdabot>  False
13:42:54 <monochrom> > Any (5>0) <> Any (5<0)
13:42:57 <lambdabot>  Any {getAny = True}
13:43:02 <codeshot> which might not be what you want. If this case is not defined then use a semigroup
13:43:23 <fakenullie> I think what you wanted to show is All
13:43:41 <codeshot> > getAny $ sconcat $ fromList (Any <$> [])
13:43:45 <lambdabot>  error:
13:43:45 <lambdabot>      ‚Ä¢ Variable not in scope: sconcat :: t0 -> Any
13:43:45 <lambdabot>      ‚Ä¢ Perhaps you meant one of these:
13:43:47 <fakenullie> > getAll $ mconcat (All <$> [])
13:43:50 <lambdabot>  True
13:43:56 <fakenullie> this one confuses people
13:44:10 <monochrom> Sure. But people are wrong.
13:44:15 <fakenullie> I know
13:44:21 <monochrom> There are still a lot of people who expect product [] = 0
13:44:49 <codeshot> oh semigroup isn't available in lambdabot
13:45:09 <fakenullie> does semigroup bottoms in this case/
13:45:10 <monochrom> I would attempt to refer them to my http://www.vex.net/~trebla/homework/empty.html but if afterwards they're still stubborn I'm done with them.
13:45:11 <fakenullie> ?
13:45:51 <codeshot> no, NonEmpty bottoms
13:46:01 <codeshot> no, NonEmpty.fromList bottoms
13:46:21 <codeshot> because you can't define a nonempty list from an empty list :)
13:46:36 <monochrom> Or do you mean semigroup's mconcat?
13:46:48 <codeshot> sconcat is for semigroup
13:47:00 <fakenullie> that page is over my math level
13:47:21 <codeshot> It's actually really easy stuff but all the descriptions are written in academese
13:47:29 <fakenullie> yeah
13:47:46 <codeshot> which is designed to make other people feel like idiots to maintain teaching positions :D
13:47:56 <fakenullie> heh
13:48:22 <monochrom> No, I don't think it's worse than say MCSE jargonism.
13:48:47 <Welkin> in particular, papers by Simon Peyton Jones are incredibly easy to read
13:48:55 <Welkin> he really excels at teaching
13:49:21 <Welkin> it's easy to write something incomprehensible, but difficult to write something that everyone can understand
13:49:25 <codeshot> yeah, I got a lot of insight just by reading one of Mr. Peyton-Jones's papers
13:49:33 <monochrom> where mathematicians say "algebraic structure" all the time, a Windows admin say "deploy" all the time.
13:49:54 <Welkin> monochrom: that is true as well, for specific domains
13:50:42 <monochrom> or maybe "the registry" is a better example.
13:51:06 <codeshot> It's a shame we don't have pointed functors or you would be able to have getAny $ sconcat $ fromList (pure <$> [...])
13:51:35 <cvon> http://lpaste.net/2468998083665461248 - Is my code, when I test my conversion function toMyConfig   mempty == mempty, I get the error: No instance for (Monoid Bool) arising from a use of ‚Äòmempty‚Äô Since bool is not a monoid. When i try the getany function to convert it I still get the same error
13:51:45 <codeshot> then you can define the append strategy at the point of use and nowhere else
13:52:45 <monochrom> Ah sconcat insists on a non-empty list already. It won't see the bottom caused by [].
13:53:15 <codeshot> And actually why don't we have type-specific functors ? Is that nonsensical or something ?
13:53:28 <monochrom> Err Haskell is a non-strict language, sconcat will totally see that bottom, just that it isn't responsible to do anything.
13:53:32 <codeshot> monochrom, Sensible types for the win!
13:54:10 <codeshot> monochrom, you don't know sconcat will see the bottom. You got bottom so the Hask category no longer says what happens next
13:54:23 <fakenullie> what's wrong with "deploy"?
13:54:24 <codeshot> bottom -> end of Hask
13:54:55 <monochrom> It just means "install" but it's now so dressed-up military operation.
13:55:17 <codeshot> Funnily enough I said to my manager a couple of months ago something like "We should test or something before we deploy it" and he was like "What does deploy mean?" as if I was a intellectualist twat
13:55:28 <codeshot> :D
13:56:01 <Welkin> "deploy", "API", "PR", "CI server"
13:56:05 <Welkin> I use those all the time
13:56:53 <fakenullie> because it's a military operation
13:57:10 <codeshot> deploy is more than install
13:57:27 <Welkin> can you ploy?
13:57:31 <codeshot> deploy includes preparation of people and processes, training materials, etc
13:57:47 <codeshot> install is just the change to one or two computers
13:58:33 <codeshot> Which explains why my Boss thought "deploy" was something I made up to sound smarter than him
13:58:44 <codeshot> Because he would never imagine doing those things :D
13:59:19 <fakenullie> you have to ploy when your deploy fails
13:59:28 <Welkin> codeshot: is your boss the guy from the dilbert cartoons?
13:59:37 <fakenullie> heh
14:00:03 <codeshot> worse
14:00:06 <codeshot> he's hands-on
14:00:15 <Welkin> is he an engineer?
14:01:11 <codeshot> We can't figure it out, his past is software engineering and test but his stories and knowledge seem to indicate his career has been spent elsewhere
14:01:58 <hpc> i think that happens more than a lot of people think
14:02:07 <monochrom> There can only be one sci-fi explanation. His body has been taken over by an alien.
14:02:18 <hpc> i had a CS professor who was in the army band for 20 years before quitting to teach
14:02:26 <codeshot> hpc: lol
14:02:37 <Welkin> when you get deep into an organization, you realize that all companies are dysfunctional kindergartens
14:02:52 <codeshot> Welkin: more lol
14:02:53 <Welkin> it's a wonder how anything ever gets done
14:02:56 <hpc> Welkin: or a sweatshop for grownups
14:03:00 <Welkin> or how the company continues to exist
14:03:05 <cvon> or a monarchy # apple
14:03:27 <monochrom> I know how. As developed countries we actually have surplus food.
14:03:43 <hpc> harsh
14:04:23 <Welkin> and how incompetent most of them are
14:05:09 <codeshot> lol
14:05:19 <Welkin> it makes for easy money if you stick around though
14:05:19 <exio4> monochrom: even with surplus you can be very inefficient when it comes to handling resources :)
14:05:41 <codeshot> exio4, he means there's no pressure to eliminate them
14:08:20 <cvon> http://lpaste.net/2468998083665461248 - Is there an error with my mappend definition in Config? Because my toMyConfig function basically converts a type to another type with the same fields. I still get the error: No instance for (Monoid Bool) arising from a use of ‚Äòmempty‚Äô when testing: toMyConfig   mempty == mempty  
14:09:59 <cvon> sry i mean my mempty definition not my mappend
14:12:06 <slack1256> Any cool uses of free applicative functors apart from validation forms?
14:12:20 <monochrom> I can't spot an error. What is the verbatim unabridged error message?
14:12:34 <ertes> slack1256: not many, because they are really just glorified free monoids
14:12:41 <codeshot> you create a GConfig using a Bool and GConfig defines mempty to initialise that Bool with mempty - where there isn't one
14:12:55 <monochrom> Oh! That one.
14:13:00 <cvon> So when I run: toMyConfig   mempty == mempty, I get this error:  ‚Ä¢ No instance for (Monoid Bool) arising from a use of ‚Äòmempty‚Äô     ‚Ä¢ In the second argument of ‚Äò(==)‚Äô, namely ‚Äòmempty‚Äô       In the expression: toMyConfig mempty == mempty       In an equation for ‚Äòit‚Äô: it = toMyConfig mempty == mempty
14:13:07 <cvon> oh
14:13:54 <codeshot> Maybe the parameter of Config should be All instead of Bool
14:14:16 <slack1256> ertes: that runAp_ function with the monoid contraint should have told me 
14:15:16 <codeshot> And you can define it as cAggregateOpt and define cOpt = getAall . cAggregateOpt
14:15:19 <codeshot> I think
14:16:40 <jle`> cvon: i looks like there is no instance of Monoid for MyConfig
14:17:49 <cvon> @codeshot Thanks! I'll try that
14:17:49 <lambdabot> Unknown command, try @list
14:18:03 <cvon> MyConfig is just a type alias
14:18:10 <jle`> cvon: that's what i mean
14:18:22 <jle`> there is no Monoid instance for GConfig Bool [String] Int
14:18:37 <jle`> none is provided or written
14:18:45 <jle`> so you can't use mempty for it :)
14:19:33 <codeshot> Are you sure you want a Monoid for this?
14:19:53 <cvon> its not that I want, I'm required to do so for an assignment
14:19:57 <codeshot> I would have too, but I can't see a non-clunky way to do it
14:21:01 <pie_> hi guys, does haskell have anything for named arguments?
14:21:18 <jle`> pie_: not natively, but you can simulate it using records
14:21:20 <codeshot> Should it be "Last" instead of "All" - so the last appended config value chooses the cOpt value ?
14:21:31 <pie_> jle`, is that comfortable?
14:21:31 <codeshot> lots of choices here
14:21:45 <Welkin> pie_: define a datatype
14:21:56 <jle`> cvon: does your assignment require you to use mempty for MyConfig?
14:22:02 <pie_> i mean i feel like im going to miss that from python
14:22:05 <cvon> The only things i can change are under the define in my code, nope
14:22:23 <Welkin> pie_: trust me, you won't miss anything from python
14:22:28 <jle`> cvon: i mean, your code is fine
14:22:29 <fakenullie> heh
14:22:33 <pie_> ok >_< xp
14:22:35 <jle`> it's just `toMyConfig mempty == mempty` doesn't make sense
14:22:35 <codeshot> below line 15 ?
14:22:39 <jle`> since MyConfig has no Monoid instance
14:22:46 <codeshot> Then you can't forward the mempty to your Bool
14:22:49 <jle`> GConfig Bool [String] Int doesn't have a Monoid instance
14:22:53 <jle`> it's meaningless
14:23:14 <codeshot> You have to be explicit in MyConfig's mempty and mappend implementations how to append the boolean field
14:23:16 <pie_> also i wanted to pick up haskell a while ago but anytihng i want to work on really works with binaries and i cant really find any libraries that will let me deal with bit streams and the like
14:23:27 <pie_> everything i found is only for byte level / byte aligned stuff
14:23:51 <jle`> cvon: oh, do need to *define* MyConfig?
14:23:53 <cvon> line 37, 41, 44, 18-19 is only what i can change. 
14:23:57 <cvon> yea
14:24:00 <jle`> so that its monoid instance is the same as Config?
14:24:02 <jle`> ah okay
14:24:12 <cvon> yea
14:24:20 <codeshot> Oh my
14:24:24 <fakenullie> pie_: current computers work on byte level stuff
14:24:26 <codeshot> I misread your code originally
14:24:29 <codeshot> I may have mislead you
14:24:39 <jle`> so check out the instance for GConfig
14:24:42 <pie_> fakenullie, ok but that doesnt really solve my problem
14:24:43 <cvon> ah no problem lol, i appreciate any help rly. 
14:24:47 <prohobo> wololoooo
14:24:48 <jle`> and the instance for Config
14:24:54 <jle`> compare the two
14:24:56 <codeshot> I got mixed up with Config and GConfig etc
14:25:02 <jle`> for the first field, you mappend using &&
14:25:09 <fakenullie> pie_: https://hackage.haskell.org/package/bitarray-0.0.1.1/docs/Data-BitArray.html ?
14:25:12 <jle`> the second field you mappend using ++
14:25:19 <jle`> the third field you mappend using +
14:25:30 <jle`> so you just have to pick types that have the appropriate Monoid instances to give you that behavior
14:25:36 <pie_> fakenullie, hm that might work thanks
14:25:39 <jle`> so you can use GConfig All [String] (Sum Int)
14:25:40 <codeshot> line 30 and line 37 conflict
14:25:55 <jle`> type MyConfig = GConfig All [String] (Sum Int)
14:25:57 <fakenullie> pie_: https://hackage.haskell.org/package/bitstring-0.0.0/docs/Data-BitString.html
14:25:59 <cvon> Sum Int? - u mean that only allows sum operations
14:26:00 <codeshot> 37 says the gcOpt is Bool and line 30 says the gcOpt is a Monoid instance
14:26:11 <jle`> cvon: (Sum Int) is a newtype wrapper over Int where mappend = (+)
14:26:12 <codeshot> This is the crux of the problem
14:26:36 <jle`> cvon: instance Monoid (Sum Int) where mempty = Sum 0; mappend (Sum x) (Sum y) = Sum (x + y)
14:26:44 <jle`> so that gives you the mempty/mappend that you want
14:26:48 * pie_ hopes he wont have to switch to rust :D
14:27:10 <cvon> oh i see. im assuming there also a one for mult int. thanks
14:27:18 <jle`> mhm
14:27:22 <jle`> no problem
14:27:31 <jle`> but then you have to be a bit more sophisticated with toMyConfig and fromMyConfig
14:27:33 <fakenullie> cvon: Product?
14:27:40 <pie_> fakenullie, ah i didnt think to search hackage just for "bit" i kept loking fo rvariations on binary
14:27:44 <jle`> but yeah, 'All' is a Bool whose Monoid instance is mappend = (&&)
14:27:49 <pie_> now i found some thinkgs that look more promising
14:27:54 <jle`> and 'Sum Int' is an Int whose Monoid instance is mappend = (+)
14:28:05 <codeshot> cvon, if you make MyConfig = GConfig Any ... and make toMyConfig and fromMyConfig use All and getAll does it solve your problem?
14:28:08 <jle`> > All True <> All False
14:28:10 <fakenullie> pie_: you have to learn Haskell first
14:28:11 <lambdabot>  All {getAll = False}
14:28:14 <jle`> > All True <> All True
14:28:17 <lambdabot>  All {getAll = True}
14:28:19 <jle`> > Sum 2 <> Sum 8
14:28:23 <lambdabot>  Sum {getSum = 10}
14:28:31 <pie_> fakenullie, well...yeah XD
14:28:40 <codeshot> ah jle` is on this I see, good man
14:28:44 <codeshot> or woman
14:28:47 <codeshot> or boy or girl
14:28:51 <fakenullie> pie_: it's not like learning another imperative language
14:29:00 <pie_> fakenullie, i actually had a round at scheme first
14:29:16 <pie_> because round 0 of an attempt at haskell faile dmiserably due to being mindf***ed by recursion :)
14:29:24 <cvon> Codeshot let me try that
14:29:48 <codeshot> jle` already saw further than me
14:30:12 <fakenullie> pie_: scheme won't help much
14:30:31 <pie_> fakenullie, ah... :P well at least i can handle recursion now
14:30:35 <pie_> at least on some level
14:30:55 <jle`> "luckily" in practice, recursion isn't an everyday thing in haskell
14:32:57 <iqubic> jle`: What do you mean? I thought recursion was all over the place in haskell.
14:33:17 <codeshot> I'm suprised there's no predefined "None" ie it's false until true is seen then it stays true
14:33:25 <jle`> well, i mean explicitly writing recursion
14:33:35 <jle`> codeshot: do you mean Any ?
14:33:39 <iqubic> jle`: Yeah, I do that all the time.
14:33:48 <jle`> iqubic: yeah, it's not a common thing in actual haskell
14:33:50 <fakenullie> you have to learn very much to stop using recursion explicitly
14:33:55 <jle`> explicit recursion is the GOTO of functional programming
14:34:01 <iqubic> It is?
14:34:07 <fakenullie> I agree
14:34:10 <iqubic> But how do you do loops and such?
14:34:17 <jle`> higher-order functions
14:34:17 <hpc> iqubic: it is - it's what you start with and then you build abstractions on top of it
14:34:19 <jle`> :t forever
14:34:21 <lambdabot> Applicative f => f a -> f b
14:34:23 <jle`> :t foldr
14:34:25 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
14:34:28 <jle`> etc.
14:34:34 <codeshot> For an option I'd expect either "None", First, or Last rather than All
14:34:42 <hpc> same way loops in imperative languages are made out of... actual GOTOs
14:34:57 <hpc> label
14:34:58 <hpc> code
14:35:00 <codeshot> an option flag is usually set to the value found when it first appears, last appears or if it appears at all
14:35:01 <hpc> if condition, goto label
14:35:15 <jle`> instead of explicit recursion, you'd use higher-order functions and combinators
14:35:21 <iqubic> jle`: I see/
14:35:23 <codeshot> not only switched off if it appears
14:35:29 <jle`> codeshot: First/Last make sense for actual values
14:35:39 <jle`> that's why they do exist in base, but they're parameterized by types
14:35:43 <jle`> you have 'First a', which gives the first 'a' found
14:35:49 <jle`> and 'Last a', which gives the last 'a' found
14:36:06 <codeshot> jle` yeah, I was imagining options like -f[no-]blah too
14:36:09 <iqubic> What if I want to keep taking input from the user until the string given matches a predicate foo, and then return that?
14:36:31 <jle`> iqubic: you'd probably first look for a higher order function
14:36:31 <pie_> oh...
14:36:40 <iqubic> I usually use explict recursion for that.
14:36:43 <jle`> and if you don't find a suitable one, you might use explicit recursion
14:36:46 <codeshot> for "switch-on" only I expect a "None" type
14:36:49 <pie_> <iqubic> But how do you do loops and such?
14:36:49 <pie_> <jle`> higher-order functions
14:36:57 <pie_> yeah i was usually trying to do that but it didnt always work out :P
14:36:57 <iqubic> jle`: What would you do in that case?
14:37:51 <fakenullie> iqubic: head . filter pred
14:38:01 <monochrom> I am not as extreme in advocating to avoid handwritten recursion, but it is always valuable to recognize that you're reinventing map or foldr for example.
14:38:19 <iqubic> fakenullie: But where do you take the user's input?
14:38:35 <jle`> iqubic: there are some higher order functions in http://hackage.haskell.org/package/monad-loops-0.4.3/docs/Control-Monad-Loops.html, for instance
14:38:45 <jle`> in this case it might be simpler to just use explicit recursion, but
14:39:04 <jle`> the cases where explicit recursino is simplest or the easiest to read are rarer than the cases where you'd use higher order functions
14:39:57 <iqubic> What I do is: "getInput = do input <- getLine; if isValid input then return input else getInput;
14:40:24 <jle`> yes, that's not particularly bad, but do you see how it is essentially GOTO?
14:40:26 <cvon> @ Codeshot @jle` thank you! it worked
14:40:36 <iqubic> jle`: Yeah, I do.
14:40:43 <jle`> cvon: no problem!
14:41:03 <cvon> whats the equivalent of @ in irc?
14:41:05 <jle`> in simple cases not too bad, but in even slightly complex cases it leads to hard to read/hard to debug/unmaintainable code
14:41:08 <hpc> cvon: this
14:41:17 <cvon> hpc: this ?
14:41:20 <hpc> yep
14:41:23 <hpc> you can even tab-complete
14:41:40 <iqubic> In most irc clients you can.
14:41:45 <cvon> oh lol, im new to irc
14:41:50 <cvon> ive used slack though ..
14:42:01 <jle`> welcome to irc :)
14:42:04 <iqubic> jle`: Is there a higher order function to replace what I just wrote?
14:42:41 <codeshot> cvon, have you understood what's going on?
14:42:52 <jle`> iqubic: what you wrote is basically 'untilJust' from monad-loops
14:43:00 <iqubic> Wait really?
14:43:21 <iqubic> jle`: The page you linked is not valid/
14:43:21 <jle`> untilJust (mfilter isValid . Just <$> getLine)
14:43:28 <jle`> @hackage monad-loops
14:43:28 <lambdabot> http://hackage.haskell.org/package/monad-loops
14:43:34 <codeshot> cvon, just using the nick name in your line is enough for many clients, using at the front is especially good
14:43:42 <codeshot> mine does this when I tab complete
14:43:53 <codeshot> cvon, then I can type after the comma
14:44:33 <pie_> cvon, you just say the persons nick
14:44:51 <cvon> nickname?
14:44:56 <pie_> pie_ is my nick
14:45:03 <pie_> thats what the username is called
14:45:14 <jle`> nick is irc's term for username/handle/etc.
14:45:20 <codeshot> no, your nick and username can be different
14:45:30 <fakenullie> you juts say whatever is in front of messages to which you reply
14:45:34 <jle`> oh, nvm, you're right.  it's been a while since i did this v.v
14:46:19 <pie_> codeshot, i never actually bothered to figure out the difference >_>
14:46:42 <iqubic> There is a difference?
14:46:52 <iqubic> :t mfilter
14:46:54 <lambdabot> MonadPlus m => (a -> Bool) -> m a -> m a
14:47:03 <iqubic> What does that do??
14:47:21 <monochrom> Read the doc.
14:48:59 <iqubic> I see how that works.
14:50:49 <iqubic> I like "untilJust (mfilter isValid . Just <$> getLine)
14:50:58 <iqubic> :t Just <$> getLine
14:51:00 <lambdabot> IO (Maybe String)
14:51:18 <iqubic> Wait, what?!?!
14:51:47 <iqubic> Why is that the type?
14:52:09 <iqubic> :t <$>
14:52:11 <lambdabot> error: parse error on input ‚Äò<$>‚Äô
14:52:15 <iqubic> :t (<$>)
14:52:17 <lambdabot> Functor f => (a -> b) -> f a -> f b
14:52:19 <iqubic> :t getLine
14:52:21 <lambdabot> IO String
14:52:34 <iqubic> :t Just
14:52:36 <lambdabot> a -> Maybe a
14:52:57 <fakenullie> it's fmap
14:53:03 <Clint> now you understand
14:53:14 <iqubic> I get it.
14:54:56 <iqubic> > (+5) <$> (Just 10)
14:54:58 <lambdabot>  Just 15
14:57:12 <Eduard_Munteanu> > (*2) <$> (+1) $ 3
14:57:15 <lambdabot>  8
14:57:53 <fakenullie> > (*2) <$> (+1) <*> 3
14:57:55 <lambdabot>  error:
14:57:55 <lambdabot>      ‚Ä¢ No instance for (Typeable a0)
14:57:55 <lambdabot>          arising from a use of ‚Äòshow_M364512682179909534827680‚Äô
14:58:20 <Eduard_Munteanu> it's (.)
14:58:51 <codeshot> You can't multiply (+1) by 2
14:59:04 <fakenullie> > (*) <$> Just 2 <*> Just 3
14:59:08 <lambdabot>  Just 6
14:59:53 <fakenullie> > (*) <$> 2 <*> 3
14:59:56 <lambdabot>  error:
14:59:56 <lambdabot>      ‚Ä¢ Ambiguous type variable ‚Äòf0‚Äô arising from a use of ‚Äòshow_M480411106328...
14:59:56 <lambdabot>        prevents the constraint ‚Äò(Show (f0 Integer))‚Äô from being solved.
15:00:49 <monochrom> This shows that $ can't buy you <*>
15:00:53 <htse> how does haskell define wether to use the IO action or String return type of printf? I put printf in my main entry point and it never prints, I always need to put a putStrLn
15:01:25 <Eduard_Munteanu> htse, printf would better be called sprintf, it only gives you a string.
15:01:35 <iqubic> :t printf
15:01:37 <lambdabot> PrintfType r => String -> r
15:01:48 <iqubic> Or not really.
15:02:08 <Eduard_Munteanu> > printf "%d" 3 :: String
15:02:11 <lambdabot>  "3"
15:02:17 <Eduard_Munteanu> > printf "%d" 3 :: IO ()
15:02:20 <lambdabot>  <IO ()>
15:02:31 <Eduard_Munteanu> Hm, there's an instance for that?
15:02:43 <htse> so I need to specify what it needs to become?
15:02:50 <iqubic> > printf "%d" 3 :: Int
15:02:53 <lambdabot>  error:
15:02:53 <lambdabot>      ‚Ä¢ No instance for (PrintfType Int) arising from a use of ‚Äòprintf‚Äô
15:02:53 <lambdabot>      ‚Ä¢ In the expression: printf "%d" 3 :: Int
15:02:55 <monochrom> Show actual code? main = printf "%s\n" "abc" works for me.
15:03:42 <fakenullie> > printf "%d%d" 3
15:03:45 <lambdabot>  error:
15:03:45 <lambdabot>      ‚Ä¢ Ambiguous type variable ‚Äòa0‚Äô arising from a use of ‚Äòshow_M734721288290...
15:03:45 <lambdabot>        prevents the constraint ‚Äò(Show a0)‚Äô from being solved.
15:03:59 <htse> main = (printf "you have: %0ig %0is %0ic" gold silver copper) where         
15:03:59 <htse>               (gold,silver,copper) = (toWowMoney 30101)
15:04:07 <htse> the gold silver coper are just Int
15:04:19 <htse> I' just playing around with lots of stuff
15:04:20 <fakenullie> but IO String does not print
15:04:54 <Eduard_Munteanu> > printf "%d" 3 :: IO String
15:04:56 <iqubic> No, it's an IO action that gets a string
15:04:57 <lambdabot>  error:
15:04:57 <lambdabot>      ‚Ä¢ Couldn't match type ‚Äò[Char]‚Äô with ‚Äò()‚Äô
15:04:57 <lambdabot>          arising from a use of ‚Äòprintf‚Äô
15:05:30 <monochrom> I don't have code for toWowMoney to reproduce your error.
15:05:32 <fakenullie> > printf "%d" 3 :: IO ()
15:05:36 <lambdabot>  <IO ()>
15:05:40 <Eduard_Munteanu> htse, you need a newline at the end
15:05:55 <monochrom> Either give the code or post the verbatim unabridged error message.
15:06:13 <Eduard_Munteanu> I suspect without a newline it just puts it into the output buffer without flushing.
15:06:38 <monochrom> Ah but the RTS will flush before quitting.
15:07:24 <htse> that actually does it yes
15:07:33 <htse> that's very weird behaviour :/
15:08:10 <Eduard_Munteanu> Standard output is normally line-buffered.
15:08:18 <mud> htse: It's called buffering, it's ... fairly common. It's a good strategy for performance usually.
15:08:42 <monochrom> OK so I have main = printf "%s" "abc"
15:08:46 <Eduard_Munteanu> @src putStr
15:08:46 <lambdabot> putStr s = hPutStr stdout s
15:08:56 <mud> htse: You can configure it not to do that (hSetBuffering) if you want.
15:09:06 <monochrom> I get abctrebla@figaro$ in which the "trebla@figaro$" part is my unix prompt.
15:09:19 <monochrom> Meaning it does print my "abc" successfully but maybe you didn't spot it.
15:10:26 <htse> if I put a newline in my formatstring then it basically prints only up to the newline
15:10:53 <monochrom> Perhaps your unix prompt is set up to eat it?
15:10:55 <htse> so it flushes and then fills the buffer again?
15:11:20 <htse> what stdout?
15:11:48 <monochrom> No. Terminal escape codes that request "clear the line"
15:13:12 <monochrom> I just don't believe the fairy tale that "under line buffering if you don't have \n you'll have data loss".
15:13:38 <mud> Naw, that doesn't sound right, not even close to what I've experienced.
15:13:48 <monochrom> And I have already showed an experiment to support my belief.
15:13:57 <htse> if that where the case then I couldn't let it print 2 lines under any circonstance
15:14:18 <htse> since it'd use \n every time right?
15:14:58 <Eduard_Munteanu> I'm not sure what you mean, you can use \n twice or more in a format string.
15:15:51 <Eduard_Munteanu> Or printf multiple times.
15:16:07 <pie_> is there something up with ivorylang.org
15:16:34 <Fairy> monochrom: I'm not a tale!
15:16:52 <monochrom> Oh I just mean tales about you. :)
15:17:11 <Fairy> But those are supposed to be secret!
15:17:27 <htse> if I put main = (printf "money: %0ig %0is %0ic\nTry again tomorrow!" 1 1 1) then it doesn't print "Try again tomorrow!"
15:17:51 <htse> it only prints until the first \n
15:18:02 <Eduard_Munteanu> htse, sure, you need a newline for each line. :)
15:18:21 <monochrom> This one is an "ambiguous type variable" error.
15:18:32 <htse> if I don't put a newline it prints nothing
15:19:19 <htse> with say putStrLn it works fine so a String is properly returned, it just seems weird behaviour to me
15:19:32 <Eduard_Munteanu> Hmmm... are you doing it in ghci?
15:19:35 <htse> no
15:19:40 <htse> in ghci it works fine
15:19:51 <htse> this is compiled with ghc
15:20:08 <monochrom> What does your echo $PS1 say?
15:20:38 <monochrom> Because so far I cannot reproduce any of your observation.
15:20:47 <htse> %F{113}%n@%m%f %F{208}Œª%f %F{cyan}%~%f ${ruby_info[version]} ${node_info[version]} ${python_info[virtualenv]}
15:20:50 <htse> %(!. %B%F{red}#%f%b.)${editor_info[keymap]} 
15:20:53 <monochrom> In the case of the latest one, it's a type error.
15:20:54 <htse> I use a zsh shell here
15:21:30 <monochrom> OK I don't know zsh. But supposedly you could walk me through it.
15:21:41 <monochrom> What does %F(113) mean?
15:22:54 <monochrom> I almost thought it's in base 8, until I saw "208" later.
15:23:24 <monochrom> Or maybe it is zsh itself that clears the line?
15:23:25 <htse> it's a foreground colour
15:23:45 <monochrom> So try another shell?
15:23:47 <Clint> monochrom: it does depending on the settings of PROMPT_CR and PROMPT_SP
15:23:48 <htse> everything prints fine when using for example putStrLn
15:25:06 <Clint> htse: try doing ./yourprogram;print
15:25:06 <htse> in bash it works as I expect it would
15:25:16 <monochrom> OK so zsh problem.
15:25:39 <htse> so why does putStrLn work then?
15:25:47 <monochrom> Why not?
15:25:53 <htse> shouldn't it output the exact same thing both times?
15:26:04 <monochrom> "Clear this line" does not mean "also clear two previous lines".
15:26:26 <Eduard_Munteanu> htse, try the equivalent of   echo -n 'foo'   in zsh
15:26:50 <prohobo> what do you guys use haskell for?
15:26:53 <monochrom> /topic zsh is wrong
15:27:03 <Clint> also if you haven't changed your zsh defaults you are using zsh from ancient times
15:27:06 <prohobo> is it useful in web dev?
15:27:06 <monochrom> I use Haskell to write Haskell tutorials :)
15:27:08 <Eduard_Munteanu> It could be that zsh simply clears the current line before printing the prompt.
15:27:22 <Clint> yes, that's what it used to do by default
15:27:24 <Eduard_Munteanu> prohobo, I've done a bit of web dev in Haskell, yes.
15:27:54 <prohobo> i guess you wrote a haskell script for some data processing server-side?
15:27:57 <Eduard_Munteanu> @src putStrLn
15:27:57 <lambdabot> putStrLn s = do putStr s; putChar '\n'
15:28:04 <htse> Clint ;print corrects the behaviour
15:28:05 <Eduard_Munteanu> htse, ^
15:28:20 <Clint> htse: so you are using zsh 3.0.5 or something
15:28:27 <prohobo> i just dont understand where functional programming can be useful
15:28:29 <htse> I'll check
15:28:30 <prohobo> its confusing
15:28:32 <Eduard_Munteanu> @src print
15:28:33 <lambdabot> print x = putStrLn (show x)
15:29:11 <monochrom> My perspective, functional programming is clear to me (imperative programming is the confused one) so I find it useful for everything.
15:29:18 <Eduard_Munteanu> prohobo, I'd say it's generally useful, not a particular niche or anything
15:29:44 <prohobo> hm interesting
15:30:09 <Eduard_Munteanu> PHP and Haskell are overlapping tools built on different ideas, not complementary tools.
15:30:21 <prohobo> so you would feel comfortable to, for example, write a REST API with Haskell?
15:30:22 <htse> I use zsh 5.4.2 
15:30:29 <Eduard_Munteanu> I do.
15:30:31 <Clint> htse: so you have changed the defaults
15:31:12 <htse> hmm I installed prezto to use one of those themes, I guess that did it
15:31:16 <prohobo> cool
15:31:26 <prohobo> im gonna learn haskell
15:31:50 <Welkin> but you are a pro hobo!
15:31:55 <Welkin> why not stick with that?
15:32:03 <Welkin> what does a hobo need haskell for?
15:32:18 <monochrom> Perhaps it's just a nick.
15:32:24 <monochrom> I'm not a chrom either.
15:32:39 <prohobo> dude ill have you know that i own a fully fitted cardboard box work station
15:33:00 <prohobo> i program at mcdonalds
15:33:05 <dminuoso> Hi. Is there a reason why Functor does not require some variant of `pure/return` ?
15:33:24 <dminuoso> I mean categorically a Functor not only maps morphisms, but also objects.
15:33:36 <htse> I think I better switch back to bash
15:33:56 <Eduard_Munteanu> dminuoso, the objects map is the functor type function itself
15:33:58 <Welkin> prohobo: that is a surprisingly common occurrence,
15:34:08 <Eduard_Munteanu> It belongs to types, not values.
15:34:12 <monochrom> The "maps objects" part is already covered by the type, e.g., the Maybe functor maps object Int to object Maybe Int.
15:35:42 <dminuoso> monochrom: Is that type constructor enough?
15:36:01 <monochrom> I don't understand the question. But everything I've said is true.
15:36:03 <dminuoso> Or is it just assumed that the type must have meaningful data constructors?
15:36:07 <dminuoso> Mmm
15:36:12 <Welkin> is there an easy way to flip the pixels loaded in by juicypixels? I need to load the data in reverse order
15:36:30 <Eduard_Munteanu> dminuoso, no
15:36:36 <monochrom> We consider IO to be a functor without meaningful data constructors.
15:36:37 <Welkin> just reversing the "rows"
15:36:59 <monochrom> And perhaps ((->) Double) is a better example of a functor without data constructors.
15:37:08 <Welkin> IO has a data constructor, but it is hidden
15:37:15 <monochrom> A functor won't talk about data constructors.
15:37:25 <Eduard_Munteanu> As long as you can write a lawful fmap, it's a functor.
15:37:36 <Welkin> a fmunctor
15:37:55 <Welkin> sometimes haskell shounds like dr seuess
15:38:09 <Eduard_Munteanu> Well, they couldn't have call it fap. :)
15:38:11 <monochrom> In the case of the Haskell Functor class, objects are types and nothing talks about values and data constructors.
15:38:16 <fakenullie> what's (-> Double)?
15:38:31 <Eduard_Munteanu> fakenullie, Double ->
15:38:35 <Eduard_Munteanu> Er.
15:38:51 <monochrom> Well, you can rewrite "Double -> Bool" as "((->) Double) Bool". That.
15:38:51 <Eduard_Munteanu> fakenullie, I need some context
15:39:24 <monochrom> > let { f :: ((->) Double) Bool; f x = x > 1 } in f (-3)
15:39:27 <lambdabot>  False
15:39:35 <dminuoso> monochrom: Ah okay that -> example was helpful
15:39:46 <fakenullie> > fmap id (\x -> 3.9)
15:39:49 <lambdabot>  error:
15:39:49 <lambdabot>      ‚Ä¢ No instance for (Typeable p0)
15:39:49 <lambdabot>          arising from a use of ‚Äòshow_M609887589293880596328855‚Äô
15:39:59 <fakenullie> nevermind
15:40:02 <Eduard_Munteanu> :t let f :: (->) Double Bool; f = undefined in f
15:40:03 <dminuoso> o_O
15:40:03 <lambdabot> Double -> Bool
15:40:29 <fakenullie> but what does ((->) Double) functor do?
15:40:48 <monochrom> I don't think id would fit the required type in your example.
15:41:19 <Eduard_Munteanu> It's pretty much the same thing as Reader Double, if you know Reader.
15:41:31 <monochrom> Its fmap behaves like (.)
15:41:45 <fakenullie> isn't it fmap of any function?
15:41:59 <monochrom> To see this, use the type (a -> b) -> (Double -> a) -> (Double -> b)
15:42:16 <Welkin> for a functor (->) c, fmap is the same as any other functor
15:42:20 <Welkin> :t fmap
15:42:21 <lambdabot> Functor f => (a -> b) -> f a -> f b
15:42:37 <Welkin> here, the `f` is `(->) c`
15:42:41 <Eduard_Munteanu> > (+ 1) . (* log 10) $ 100
15:42:43 <monochrom> Oh, id always fit the required type.
15:42:44 <lambdabot>  231.25850929940458
15:42:53 <Welkin> so it becomes (.)
15:42:55 <Welkin> :t (.)
15:42:57 <lambdabot> (b -> c) -> (a -> b) -> a -> c
15:43:10 <fakenullie> :t fmap (undefined :: x -> Double)
15:43:11 <lambdabot> Functor f => f x -> f Double
15:43:14 <Welkin> well, with the variables swapped around
15:43:27 <Welkin> you can work it out on paper to make it more clear
15:43:51 <fakenullie> :t fmap id (undefined :: x -> Double)
15:43:53 <lambdabot> x -> Double
15:44:03 <Eduard_Munteanu> (->) is just a profunctor, really. :P
15:49:12 <Welkin> let's take a poll: How many of you pronounce common typeclass members phonetically? For example: mempty. Is this "em-empty", or "mem-ty"?
15:49:27 <Welkin> what about mappend? "mah-pend" or "em-append"?
15:49:34 <monochrom> I pronounce em empty and em append.
15:49:37 <Welkin> I recently heard someone saying "mem-ty"
15:49:41 <Welkin> and thought it was strange
15:49:45 <Eduard_Munteanu> mem-ty, mah-pend
15:49:47 <Welkin> do they also say "muh-pend"?
15:50:07 <htse> did you just assume their spelling? :P
15:50:17 <Welkin> Eduard_Munteanu: do you also pronounce "fmap" as "fuh-map"?
15:50:30 <monochrom> I also used to pronounce "es queue ell" for years.
15:50:57 <Eduard_Munteanu> Welkin, pretty much. But I'm not a native English speaker, so I might throw off the stats.
15:51:54 <tac-tics> I pronounce empty as "identity"
15:52:14 <Welkin> tac-tics: says the dyslexic breath mint
15:52:24 <tac-tics> indeed
15:55:45 <Welkin> what is the best way to reverse the "rows" in a storable vector just given the length of a row, and the number of rows
15:55:53 <Welkin> for a one-dimensional vector
15:56:16 <Welkin> I could do it in-place with a very imperative algorithm, but that seems bad
15:56:37 <Welkin> I don't really like any of the options I see in https://hackage.haskell.org/package/vector-0.12.0.1/docs/Data-Vector-Storable.html#t:Vector
15:57:06 <Welkin> I could use `slice` or split in some way
15:57:24 <monochrom> I would consider both the in-place algorithm and "generate"
15:58:06 <monochrom> If I don't care about speed, it's "generate". If I care about speed, I code up both then choose the faster one.
15:58:27 <Welkin> if I had a function :: Vector a -> Int -> [Vector a]
15:58:37 <Welkin> to split the rows
15:58:43 <monochrom> The formula to give to "generate" is of course a bit contrived, but I'll survive.
15:58:43 <Welkin> then I could reverse and concat
15:59:16 <monochrom> Yeah I think it would be nice. Either than, or ...-> Vector (Vector a)
16:00:33 <jle`> Welkin: i say mempty and mappend like they are spelled
16:00:46 <jle`> mappend like "mah-pend"
16:01:14 <fakenullie> sometimes I pronounce in my head like "monoidal empty"
16:01:34 <fakenullie> but it should be "monoid empty"
16:01:52 <jle`> it it was like mEmpty i'd probably raed it as em-empty
16:02:05 <Welkin> sometimes I like to onvert to a list so I can use http://hackage.haskell.org/package/split-0.2.3.2/docs/Data-List-Split.html#v:chunksOf
16:02:12 <Welkin> but I don't know if that is wise
16:02:12 <jle`> also empty and append are pretty bad names for the Monoid methods anyway
16:02:24 <Welkin> this is pixel data for a texture that opengl will render
16:02:29 <Welkin> and there will probably be tons of them
16:02:43 <Welkin> but juicypixels loads the data in backward
16:02:58 <jle`> i think saying em-empty and em-append give the wrong idea
16:03:06 <Welkin> I could fix this in the chaders, but then every single shader will need to reverse the rows
16:03:08 <jle`> it's as if mempty is some sort of "empty", and mappend si some sort of "append"
16:03:14 <jle`> but in reality mempty is no empty, and mappend is no append
16:03:19 <jle`> so in my mind they are just nonsense words
16:03:37 <jle`> so i don't accidentally think that mempty means 'empty' or mappend means 'append' (which they don't)
16:03:48 <Welkin> shaders*
16:21:07 * Digit still being a programming/haskell noob, has once again reached beyond his grasp, searching the terms (along with haskell), nlp, natural language, natural language processing, natural language programming, and know/presume 'twil be too much for him
16:21:47 * Digit dreams of holy (red dwarf's computer), in haskell.
16:22:14 <JuanDaugherty> and yet ... .
16:22:26 <Digit> holy...  haskell's only language lamda...   :3
16:24:02 <codeshot> mempty = mid
16:25:22 <codeshot> mappend = mleap ?
16:25:47 <fakenullie> what
16:25:57 <codeshot> see discussion of 20 minutes ago
16:26:35 <codeshot> My thoughts on the matter. mempty is a monoid category's identity morphism
16:26:39 <fakenullie> but I don't understand mid and mleap
16:26:45 <Lokathor> Welkin, yo yo buddy, what do you mean the pixel data is backwards
16:27:00 <codeshot> mid could be an alternative name without unnecessary connotations
16:27:08 <Welkin> Lokathor: textures render upside down
16:27:16 <Lokathor> oh classic
16:27:19 <fakenullie> ah, monoid identity
16:27:25 <fakenullie> but mleap?
16:27:31 <Lokathor> Welkin, didn't my guide have a fix for that?
16:27:35 <codeshot> and I thought mleap could be an alternative name for mappend which similarly has no unnecessary connotations
16:27:47 <codeshot> maybe mmorph would be better even than mleap
16:27:58 <fakenullie> mop
16:28:08 <Welkin> Lokathor: yes, but I would prefer to data to be correct before getting to the shaders
16:28:23 <Welkin> otherwise I need to perform extra operations in every shader that uses textures
16:28:33 <Lokathor> one whole subtraction
16:28:34 <codeshot> mopapply perhaps
16:28:37 <codeshot> but not mop
16:28:58 <Welkin> it is error prone
16:29:06 <Welkin> and I will at some point forget to add it in
16:29:08 <Welkin> it's just not nice
16:30:23 <fakenullie> reverse your textures before loading?
16:30:26 <Lokathor> guess you just gotta chunk it, flip the rows, and unchunk it
16:30:30 <fakenullie> I mean store them reversed
16:30:37 <Lokathor> if it's just during a texture load then that's not /too/ crazy
16:30:45 <Lokathor> obvs don't do that every frame
16:30:47 <Welkin> Lokathor: the best solution looks like swapping data in-place
16:30:52 <codeshot> The operator is spoken of in definition of a category but once you're in the realms of using the morphisms then they're just morphisms and since this is a type class I think one would want to stay abstract
16:31:10 <Lokathor> fakenullie, that's also an option but makes editing a pain
16:31:24 <fakenullie> change model texture coordinates?
16:31:43 <Lokathor> fakenullie, they consider that option error prone
16:32:00 <monochrom> codeshot: I would think "mbinop" carries the least baggage. "leap" has its connotation too.
16:32:25 <fakenullie> monoid has no other operation
16:32:44 <fakenullie> mapply maybe
16:32:48 <monochrom> But maybe I'm wrongly equating "least connotation" with "maximum tautology"?
16:32:59 <fakenullie> heh
16:33:06 <Welkin> is this pronunciation discussion still going?
16:33:26 <monochrom> I'm also happy with "mop".
16:33:39 <Lokathor> em'ap'end
16:33:48 <codeshot> I know: <>
16:33:51 <codeshot> :D
16:34:00 <Lokathor> !_!
16:34:04 <monochrom> But now it has the connotation of "mop the floor in mid August"
16:34:41 <codeshot> Funny, I didn't mop the floor even once in August
16:34:47 <codeshot> it was pretty grim
16:35:19 <codeshot> eh-map-PEND
16:57:31 * athan thinking about making a haskell implementation of tinder - calling it "hinder"
16:57:48 <paraseba> why there is no splitAt in Data.Array? Shouldn't it be implementable in O(1) for immutable arrays?
16:58:32 <Lokathor> paraseba, no because the array doesn't necessarily, uh, "exist" in the traditional sense
16:58:44 <Lokathor> like it might not be a memory blob
16:58:57 <Eduard_Munteanu> I'm looking towards expanding my fmap material.
16:59:45 <paraseba> Lokathor: but after splitAt it could continue to "not-exist", it would just require index arithmetic before dereferencing
17:00:32 <fakenullie> you can implement that other array
17:00:37 <fakenullie> s/other/over/
17:01:08 <fakenullie> I mean array arithmetic is something additionall
17:02:15 <mud> paraseba: You can do it via ixmap, but it's not O(1) I am pretty sure.
17:03:07 <paraseba> mud: oh interesting, I missed ixmap completely 
17:03:32 <paraseba> and it's even in the "derived arrays" documentation section ...
17:04:00 <monochrom> athan: Haha "hinder"
17:04:07 <mud> Heh, yep. It's a 1/2way useful function. Though the source sure makes it look like it's going to make essentially a copy.
17:04:38 <monochrom> On the bright side, recall that "hinderland" is a very supportive, positive thing.
17:07:23 <monochrom> I posit that Data.Array splitAt doesn't exist because it would have unclear or maximal-surprise semantics.
17:07:58 <monochrom> Like if my array is from (1,1) to (10,10), what would it mean to splitAt (3,7)?
17:08:42 <monochrom> I mean you can give it a meaning I'm sure. But it's going to be strange, and I expect a lot of disagreement from other people.
17:08:42 <prohobo> wat
17:08:49 <codeshot> I got ghc 8.0.2 but for some reason I can't fathom (IO ()) is an instance of Monoid but not of Semigroup
17:08:56 <codeshot> I'm quite baffled by this
17:09:04 <mud> monochrom: I think the version I would expect to exist would strictly shrink the range of indicies, not actually do splitAt
17:09:05 <fakenullie> oh, multidimensional arrays
17:09:05 <Welkin> codeshot: Semigroup is new
17:09:18 <codeshot> it's now required that all Monoid instances are also Semigroup instances
17:09:19 <mud> monochrom: So you could just give new bounds (as long as they're strictly smaller)
17:09:21 <monochrom> You do realize that Data.Array allows super-general indexes, right? Indexes don't have to be simple numbers, you know that, right?
17:09:21 <geekosaur> codeshot, the other half of Semigroup migration is in 8.2
17:09:26 <codeshot> you can't breach that in your own code
17:10:06 <mud> monochrom: Yes, but they have a concept of in-range and out of range.
17:10:09 <Welkin> instead of Array, try Vector
17:10:14 <Welkin> it has a more comprehensive api
17:10:18 <mud> Which I think is all you'd need for this to make sense.
17:10:19 <paraseba> monochrom: I guess splitAt is a simplified version "slice", which can probably be defined properly
17:10:27 <Welkin> it is also indexed by integers
17:10:43 <codeshot> So now I will have to add a Semigroup instance for Semigroup a => IO a
17:10:48 <Welkin> codeshot: why?
17:11:35 <mud> I tried to figure out if it'd make sense in the source, but I got to GHC.Prim and now I don't know what anything means anymore.
17:12:39 <codeshot> because I have a Semigroup newtype to decorate behaviours of the contained semigroup
17:12:52 <codeshot> This should be at the forefront of a haskell developers mind
17:12:54 <fakenullie> you can get a slice of a multidimensional array, but not split it
17:13:36 <Welkin> I have never use any instance of IO other than functor and monad
17:13:49 <monochrom> Oh I think slice is only worse.
17:13:58 <joe____> test
17:14:01 <mud> What's wrong with slice?
17:14:37 <monochrom> I want the slice from (2,8) to (7,4). What would it mean? And bear in mind that there are at least two possible meanings, one from row-major and another from column-major.
17:14:40 <fakenullie> I think split is worse, because you have to decide how to make the other half
17:15:27 <fakenullie> monochrom: rectangle with these corners?
17:15:43 <monochrom> Yeah! So how do you get a community consensus?
17:15:55 <fakenullie> what's the other meaning?
17:15:59 <mud> monochrom: I can't figure out what else it would mean except the rectangle with those corners. Help?
17:16:20 <monochrom> row-major interpretation and column-major interpretation.
17:16:48 <fakenullie> multidimensional array doesn't have to have linear representation
17:17:33 <monochrom> OK so now you go look at the methods of Ix. Are they strong enough to imply slicing out a rectangle?
17:18:03 <fakenullie> inRange is enough to defined "rectangle"
17:18:06 <monochrom> Recall that all Data.Array operations have to be generically coded to just needing Ix methods to decide what to do.
17:18:25 <monochrom> Let me think.
17:18:39 <monochrom> @type inRange
17:18:40 <lambdabot> Ix a => (a, a) -> a -> Bool
17:19:03 <paraseba> there is even range
17:19:03 <monochrom> Oh God it's going to try it on a million indexes?!
17:19:20 <fakenullie> yeah, there's range which is slice
17:19:26 <monochrom> @type range
17:19:28 <lambdabot> Ix a => (a, a) -> [a]
17:19:32 <fakenullie> not really, heh
17:19:53 <mud> monochrom: All it has to do is replace the lower bound with the new lower and the upper bound with the new upper. If you want it can check that the two new bounds are actually in the original. Or it can just crash like a bunch of its other stuff does.
17:20:31 <monochrom> Oh I see, delay the inRange check until someone does a (!)
17:20:43 <paraseba> right
17:20:55 <monochrom> OK I have less objection.
17:21:14 <mud> On the other hand, I use the hell out of Data.Array and I don't recall ever actually needing this.
17:21:33 <monochrom> But no one wants to improve Data.Array anymore. That's probably the real cause.
17:21:42 <mud> :( but it's so nice
17:22:05 <paraseba> here is my rationale for wanting some for of slicing in Array: currently reading chapter 4 of bird's, there is an Array algorithm and it's horribly broken. The reason why it's broken is array indexes are hard, having slice available the algorithm would be just a copy of the list version
17:22:11 <monochrom> What would be super nice would be to add this Ix power to the vector library.
17:22:45 <paraseba> sorry chapter 4 of Bird's "Pearls of functional algorithm design"
17:23:05 <monochrom> Yeah I was going to ask "is it the Pearl book or the Haskell book" :)
17:24:12 <paraseba> I don't know, maybe it worked with an older version of GHC, but right now it's broken, and fixing takes some time, and changing several lines. Index arithmetic is tricky, being able to slice avoids a lot of that
17:26:37 <monochrom> > range ((2,5), (5,2))
17:26:41 <lambdabot>  []
17:26:58 <monochrom> > range ((2::Int,5), (5,2))
17:27:02 <lambdabot>  []
17:27:26 <monochrom> > range ((5::Int,2), (2,5))
17:27:29 <lambdabot>  []
17:27:31 <paraseba> it probably doesn't know how to change "direction" in the index?
17:28:01 <monochrom> > range (1,1), (4,4))
17:28:03 <lambdabot>  <hint>:1:12: error: parse error on input ‚Äò,‚Äô
17:28:05 <monochrom> err typo
17:28:07 <monochrom> > range ((1,1), (4,4))
17:28:11 <lambdabot>  [(1,1),(1,2),(1,3),(1,4),(2,1),(2,2),(2,3),(2,4),(3,1),(3,2),(3,3),(3,4),(4,...
17:29:06 <monochrom> Right, it doesn't want to treat ((2,5), (5,2)) as ((2,2), (5,5))
17:29:27 <monochrom> The (,) instance I mean.
17:29:33 <mud> Yeah
17:30:18 <monochrom> That could be one more obstacle to clear up before you can have Ix-based slicing.
17:30:52 <mud> Well, it's already kind of how it works originally, like if you create an array with those bounds it'll already just be empty.
17:31:17 <monochrom> Oh good Ix is a subclass of Ord, it can be readily fixed.
17:32:18 <mud> Should it even be fixed? Hm. I suspect you wouldn't want it to be. Because sometimes you really do want to end up with an empty array.
17:32:22 <paraseba> even with a single dimension, Ix instance for Int only traverses the index "up"
17:33:01 <paraseba> being able to reverse an Array in O(1) sounds useful
17:33:37 <monochrom> Oh, maybe don't change the semantics of inRange, but slice can certainly permute the coordinates nicely before submitting to inRange.
17:34:15 <paraseba> true
17:38:30 <monochrom> Onoes, not true, a generic slice algorithm doesn't know your index looks like (2,5), it only knows you're using a mysterious type T and "instance Ix T".
17:39:51 <monochrom> This road is very rough.
17:42:46 <isiah> @type fmap fmap fmap fmap fmap
17:42:48 <lambdabot> Functor f => (a1 -> b) -> (a2 -> a1) -> f a2 -> f b
17:43:00 <isiah> @type fmap fmap fmap
17:43:01 <lambdabot> (Functor f2, Functor f1) => (a -> b) -> f1 (f2 a) -> f1 (f2 b)
17:43:12 <isiah> @type fmap fmap fmap fmap fmap fmap fmap
17:43:14 <lambdabot> (Functor f3, Functor f2, Functor f1) => f1 (a -> b) -> f1 (f2 (f3 a) -> f2 (f3 b))
17:43:18 <isiah> @type fmap fmap fmap fmap fmap fmap fmap fmap fmap
17:43:20 <lambdabot> (Functor f4, Functor f3, Functor f2, Functor f1) => f1 (f2 (f3 (a -> b))) -> f1 (f2 (f3 (f4 a -> f4 b)))
17:43:36 <isiah> @type fmap fmap fmap fmap fmap fmap fmap fmap
17:43:37 <lambdabot> (Functor f3, Functor f2, Functor f1) => (a -> b) -> f1 (f2 (f3 a)) -> f1 (f2 (f3 b))
17:43:49 <isiah> @type fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap
17:43:51 <lambdabot> (Functor f2, Functor f1) => (a1 -> a2 -> b) -> f1 a1 -> f1 (f2 a2 -> f2 b)
17:44:02 <isiah> @type fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap
17:44:03 <lambdabot> (Functor f3, Functor f2, Functor f1) => f1 (a -> b) -> f1 (f2 (f3 a) -> f2 (f3 b))
17:44:09 <isiah> @type fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap
17:44:11 <lambdabot> (Functor f3, Functor f2, Functor f1) => (a -> b) -> f1 (f2 (f3 a)) -> f1 (f2 (f3 b))
17:44:25 <monochrom> You should PM lambdabot instead.
17:44:51 <geekosaur> too late, sigyn had its say
17:45:08 <monochrom> Aw
17:47:16 <monochrom> OK, so someone gone to the trouble to make GHC use English in error messages.
17:47:33 <monochrom> I mean this: "plus four others" rather than "plus 4 others"
17:47:54 <monochrom> (when it's listing potential instances)
17:48:49 <monochrom> Also, I suck in English. Either "has gone" or "went".
17:49:12 <monochrom> I hate English. GHC should use Chinese.
17:49:15 <athan> monochrom: usually the latter in that case :)
17:49:16 <athan> hahah
17:49:21 <athan> grammatical framework
17:52:56 <eacameron> Is there something like "local" for StateT?
17:53:25 <eacameron> I want to run one StateT inside another but I don't want to interleave the states in any meaningful way.
17:53:43 <athan> eacameron: why not run it, and discard the state?
17:53:53 <athan> but hold on I think i see what you mean
17:54:00 <athan> @type local
17:54:02 <lambdabot> MonadReader r m => (r -> r) -> m a -> m a
17:54:53 <athan> so more like `MonadState s m => MonadState s' m' => (s' -> s) -> (s -> s') -> m s -> m' s'`...?
17:54:57 <athan> not sure if that's right
17:55:12 <athan> because technically the stack's type would change if the state's type changed
17:55:49 <athan> uy mine probably makes 0 sense, sorry. Half baked answer
17:56:32 <monochrom> Maybe mapStateT or withStateT is close to what you want?
17:58:03 <eacameron> monochrom: athan: Thanks. Trouble is I'm not exactly sure what I want. I just want to runStateT inside some other runStateT. The nested one needs to know nothing at all about the parent.
18:02:44 <monochrom> At this point it looks like this:
18:02:57 <monochrom> First you do a "s0 <- get"
18:03:37 <monochrom> Then you can do a "(a1, s1) <- lift (runStateT innerthing s0)"
18:04:02 <monochrom> And finally you may or may not want to "put s1", I don't know. But you're done.
18:04:33 <eacameron> monochrom: Ahh, so I lift myself *out* of statet, run some other statet, and then drop back in
18:05:06 <monochrom> mapStateT can do this (and more) but I think it insists on the last "put s1".
18:05:41 <eacameron> monochrom: Ahh... I think a new aspect of MTL has just become clear to me....
18:06:03 <Lokathor> monochrom, perhaps GHC should use Esperanto
18:06:33 <Lokathor> "plus kvar alioj"
18:06:40 <Lokathor> ;P
18:08:02 <eacameron> monochrom: If I'm in a polymorphic "stack" (MonadState m, MonadThat m), is `lift` safe? It doesn't seem like it would predictably give you the same monad
18:08:48 <geekosaur> lift always goes one level back/down/however you think about it
18:09:15 <geekosaur> if you need toworry, well, this is why typeclasses like MonadState and MonadIO exist; they figure it out for you
18:10:52 <eacameron> geekosaur: I see. So if I need to `lift` should I make my function *not* polymorphic over the monad that I want to "peel" off?
18:11:16 <geekosaur> I am unclear what iss bothering you
18:11:30 <eacameron> I.e. `(MonadThat m) => StateT s m a` instead of `(MonadState s m, MonadThat m) => m a`
18:11:42 <geekosaur> if you need to lift, either you must know statically how far or you need to use a typeclass that figures it out for you
18:12:12 <geekosaur> how polymorphic the next level is isn't relevant unless that polymorphism *could* include the one you're trying to reach
18:12:13 <eacameron> geekosaur: Ahh, so `MonadState` actually knows how to lift all the way *out* of that monad?
18:12:30 <eacameron> How ever many lifts that may be?
18:12:44 <geekosaur> MonadState has instances of all the mtl monads, such that they will relay 'get' etc. through until they reach a MonadState instance that doesn't just 'lift'
18:13:04 <geekosaur> (meaning, StateT or RWST)
18:13:23 <geekosaur> likewise MonadIO instances just 'lift' except for the instance for IO itself which is 'id'
18:13:35 <eacameron> geekosaur: Ah. That makes sense
18:13:46 <geekosaur> which gies you a type=-safe way to reach an arbitrary monad from any level
18:14:07 <geekosaur> provided the instances exist. (also newtype deriving will automatically add a 'lift'-ing instance)
18:16:25 <eacameron> geekosaur: I'm excited to use this new knowledge. I didn't realize I could use the same monad twice if they don't need to interleave. That is very useful.
18:17:11 <geekosaur> eh? there is still a rpoblem with reusing, sinsofar as if you have MonadState Foo over MonadState Bar then get will always reach the closest of them.
18:18:28 <eacameron> geekosaur: Right and that makes sense and hopefully Foo and Bar are different enough that you'll get type errors if you try that.
18:19:26 <eacameron> geekosaur: But I can move up/over/down and back to get around that
18:20:37 <geekosaur> sometimes I wish there were corresponding methods get' = lift get' (in a non-MonadState), get' = lift get (in a MonadState) --- but rarely; usually if I need to stack things like that, either I should combine them into a record or I am doing something special that provides its own liift-around (e.g. liftX in xmonad)
18:22:06 <geekosaur> hm, or maybe a more general tunnel x = lift (tunnel x), tunnel x = lift x
18:22:11 <geekosaur> wjhich could itself be tunneled
18:22:22 <geekosaur> but at that point you more or less have the original problem back, so.
18:23:06 <geekosaur> hm, guess that definition is too general, would need specific ones for each tunneled monad anyway :(
18:23:49 <geekosaur> this is getting to be too much like work...
18:24:59 <eacameron> geekosaur: Haha having monads adds a whole new world of fun!
18:25:29 <iqubic> Anyone in here use emacs?
18:29:24 <Gurkenglas> me
18:30:01 <Gurkenglas> but you should know better than asking questions to determine whether you should ask a question
18:32:38 <iqubic> Gurkenglas: What packages do you use to edit haskell code? Intero, or GHC mod + haskell-mode?
18:32:47 <Gurkenglas> intero
18:32:58 <iqubic> Why?
18:33:30 <geekosaur> there is also dante
18:33:34 <Gurkenglas> I think because of the hearsay about intero's quality that made me try emacs in the first place
18:33:43 <geekosaur> https://github.com/jyp/dante
18:33:55 <iqubic> How hard was it to install intero?
18:34:33 <Gurkenglas> Don't remember any difficulties, but I don't remember a lot of things.
18:35:15 <iqubic> How hard is it to use intero on a daily basis?
18:36:12 <iqubic> And doesn't it take a while to build set-up each new stack project when using intero?
18:38:22 <Gurkenglas> (You may find some if you look through the channel logs.) Easy. Best Haskell development environment I've had yet, which may not mean much. Project set up looks like "git clone foo; cd foo; stack init && stack build; (sometimes wait for dependencies, often abort because windows can't build this or that)" and wait a few seconds for intero when I first open a .hs
18:39:16 <iqubic> Do you ever create stack projects from scratch?
18:40:26 <Gurkenglas> When I write original stuff, I usually do it in a top-level .hs file, which intero can also do though you need to M-x intero-restart after each new package is added to the global project
18:40:39 <Gurkenglas> -also do though +also work with though
18:41:59 <Gurkenglas> Things I miss from IDEs for other languages: Call tree, graphical debugger.
18:42:25 <iqubic> I see.
18:48:06 <Gurkenglas> (the first meaning means to examine the graph generated by goto-definition)
18:52:26 <iqubic> Gurkenglas: I know what a Call Tree is.
18:53:15 <Gurkenglas> I wanted observers who don't know what that is to become annoyed that we don't have it
18:58:30 <Gurkenglas> Other graphs that need examinability: Types and their specializations, #haskell users and how often they highlight each other, perhaps (#haskell users and how well machine learning can classify lines that they are likely to reply to) in the nodes and (how well that dataset predicts whether another person will reply to it) in the edges
18:59:10 <Gurkenglas> Rephrasing the edge: How well the model that predicts A can predict B.
19:02:40 <Lokathor> I have MonadIO m => GLenum -> String -> m (Either String ShaderID) and MonadIO m => ShaderID -> ShaderID -> m (Either String ProgramID), i want to run the first twice and pipe them into the second
19:02:50 <Lokathor> but Control.Monad.Trans.Except seems to be giving me trouble
19:03:07 <Lokathor> first, am i even looking in the right place?
19:03:42 <Gurkenglas> Hm, perhaps I shall write a chatbot that watches #haskell, attempts to classify the lines that each person is likely to reply to, and posts their nicks to its own public channel so if they joined that channel, they get alerted that something interesting was posted.
19:04:59 <geekosaur> Lokathor, example code and full error?
19:05:11 <geekosaur> I mean that *sounds* like liftM2/liftA2
19:05:21 <geekosaur> (probably M here)
19:05:33 <Lokathor> geekosaur, i got it! i was mixing up the except constructor and ExceptT constructor
19:05:33 <geekosaur> hm, actually the A should work, duh
19:06:03 <geekosaur> that would do it
19:06:14 <nicknight> Gurkenglas:  areyou machine learning engineer?
19:06:38 <Lokathor> geekosaur, https://github.com/Lokathor/gl-simple/blob/master/src/Graphics/GL/Simple/Utils.hs#L58
19:07:01 <Gurkenglas> No, CS student. But this sounds like a relatively dumb learner might do well. I mean, the state of the art everyone uses goes no further than "alert me when these words are said"
19:15:09 <Lokathor> if i have a list, and i want to make a Vector.Storable.Mutable, what's the best way to convert the list into that?
19:16:22 <Lokathor> fromList and then thaw, I guess
19:21:27 <Gurkenglas> Why does http://hackage.haskell.org/package/vector-0.12.0.1/docs/Data-Vector-Generic.html#t:Vector have a v parameter if it's always Vector?
19:26:12 <geekosaur> because there are multiple Vector-s. Primitive, Unboxed, Storable, ...
19:26:34 <geekosaur> this doc doesn't show it well, it's got a touch of Henningskell to it >.>
19:27:27 <geekosaur> but compare the link in the first one (Prim a => ...) to the second (Bool) and the 17th (Storable a => ...)
19:28:05 <geekosaur> Data.Vector.{Primitive,Unboxed,Storable}.Vector
19:30:30 <geekosaur> this is another case where I wish Haddock were smart enough to notice the collisions and qualify the colliding names
19:32:24 <riaqn> maybe it's me doing wrong
19:32:37 <riaqn> but I can't start intero..
19:32:54 <riaqn> https://ptpb.pw/i9bw
19:33:04 <riaqn> the whole log. The project is brand new template "simple"
19:33:12 <geekosaur> you're on arch, right?
19:33:32 <riaqn> yep. how do you know?
19:33:36 <geekosaur> try removing the libtinfo6 package and reinitializing stack
19:33:54 <geekosaur> becuase this is a known incompatobility between the ghc distributions (which are built on debian) and arch
19:34:24 <geekosaur> so stack installs one of two ghc distributions, and each can fail in a different way on arch
19:34:30 <riaqn> wierd.. this package is not installed..
19:34:53 <geekosaur> if it sees tinfo6 installed it uses one and fails this way. if it doesn't, it installs the other and can get a differnt linker error
19:35:05 <geekosaur> odd
19:35:33 <geekosaur> it is obviously finding libtinfo6 library because that's what triggers it to use x86_64-linux-tinfo6-nopie
19:35:35 <riaqn> geekosaur: even better, pacman -Ss tinfo  returns nothing
19:35:37 <geekosaur> whcih tne fails this way
19:35:44 <geekosaur> *which then...
19:35:50 <riaqn> do you get the package name right?
19:37:48 <HoloIRCUser3> haskell has issues on arch?
19:37:51 <geekosaur> I thought that was the right package but I'[m not an arch user
19:38:06 <geekosaur> I am seeing a suggestion to install ncurses-full from AUR as a workaround
19:38:17 <riaqn> OK.. well there wasn't a trouble month ago
19:38:20 <riaqn> OK, let me try
19:38:33 <geekosaur> specifically you need libtinfo.so.6
19:38:56 <geekosaur> HoloIRCUser3, arch has been broken for Haskell in various ways since June
19:39:05 <geekosaur> in particular the distribution packages are fubar
19:39:20 <riaqn> wait.. don't you mean I need it removed?
19:39:27 <HoloIRCUser3> saved me some anxiety down the road
19:39:59 <geekosaur> well. this particular ghc build should work if you have it and it's actually compatible (which I think means not a linker script hack)
19:40:06 <TipsyMe> I prefer my anxiety down the road
19:40:12 <geekosaur> if it's missing, it should try one of hte other ghc builds
19:40:29 <geekosaur> but then it can fail a different way and I don;t think we've fgured that one out yet :(
19:40:32 <HoloIRCUser3> arch is a rolling release so it might break again?
19:40:32 <riaqn> wait.. I just found libtinfo.so.6.0 in my system..
19:40:46 <geekosaur> .6 not .6.0
19:40:54 <HoloIRCUser3> i did a small compile with ghc and it worked
19:40:54 <riaqn> would it be different if I say "system-ghc:true"?
19:41:01 <riaqn> .6 is linked to .6.0
19:41:04 <HoloIRCUser3> a hello world app to be precise
19:41:08 <geekosaur> the one witht he extra version is the runtime one, without is the compile time/link time one
19:41:23 <geekosaur> riaqn, that just gets you the broken Arch bui;d
19:41:43 <geekosaur> for which you will need to make sure you install ghc-static and install NO other Haskell libraries via pacman, build them locally
19:41:58 <geekosaur> because you will get missing library errors
19:42:27 <geekosaur> (because in their infinite wisdom they removed all the static libs for their Haskell packages. but left ghc expecting to link Haskell libraries statically)
19:42:49 <riaqn> OK I'm enough for this
19:42:49 <geekosaur> basiclaly Haskell on Arch is currently a cluster****
19:43:07 <riaqn> no program for you, haskell!
19:43:11 <geekosaur> probably easier to run ubuntu in a vm
19:43:21 <riaqn> but I hate ubuntu
19:43:28 <riaqn> maybe get back to gentoo
19:43:39 <geekosaur> did gentoo ever fix its incompatibilities with stack?
19:43:46 <riaqn> I actually know the arch haskell packager in person
19:43:55 <riaqn> maybe I will talk to him
19:44:09 <HoloIRCUser3> can someone explain how http POST requests work?
19:44:16 <riaqn> I don't know. switched to gentoo before I use haskell.
19:44:27 <riaqn> HoloIRCUser3: that's pretty off-topic
19:45:09 <HoloIRCUser3> sorry, is this channel haskell only?
19:45:11 <geekosaur> you should point out to them that haskell shared libraries are a very bad idea because ghc leaks internals into the library's ABI so different compiles do NOT create compatible shared libraries unless the build is 100% unchanged. meaning, you can;t use shared objects to slipstream fixes like you can with C shared libraries
19:45:31 <geekosaur> which I suspect is why they want to use shared libraries so badly. with ghc this won't work
19:45:46 <geekosaur> (and never will because turning off cross-module inlining has a severe performance impact)
19:46:14 <riaqn> OK I will forward this to him.
19:46:37 <geekosaur> at some point I still need to do the full write-up on this for people not familiar with ghc internals :/
19:46:50 <geekosaur> and the complexities of linking in the presence of those internals
19:47:19 <geekosaur> HoloIRCUser3, yes, this is #haskell not #web or whatever
19:47:45 <riaqn> so basically I will be haskell-sober for several weeks
20:19:44 <riaqn> geekosaur: just a feedback, installing stack-static from AUR instead of stack from repo, works
20:22:12 <geekosaur> yeh, just don't install anything else (unles syou want to try the ArchHaskell repo, which is distinct from the main one)
20:22:34 <iqubic> geekosaur: Yes. Gentoo and stack are fine together.
20:25:20 <geekosaur> would someone like to read https://www.dropbox.com/s/71p3wey2a1dp9og/ghc-dyn-inline.txt?dl=0 for comprehensibility? (granting that this kind of thing is usually difficult to being with; it makes Haskell look easy to figure out :p )
20:25:25 <geekosaur> *begin with
20:25:33 <geekosaur> and for typoes
20:25:57 <geekosaur> (it's about the shared library / cross-module inlining issue)
20:26:20 <geekosaur> it could also use a sanity check but I suspect I'd have to ask in #ghc for that
20:29:38 <geekosaur> riaqn, you might want to pass the above link to the Arch Haskell package maintainer (presuming that's not the ArchHaskell *repo* maintainer, who's already doing the right thing), at least after it's been betaed...
20:30:20 <eacameron> geekosaur: Great little writeup. Very informative!
20:30:41 <riaqn> geekosaur: done. Thanks.
20:31:04 <geekosaur> the really sad part is this is about a third of what really needs to be written
20:32:17 <geekosaur> the missing parts being (a) static linking Haskell libs vs. static linking system libs, anoither topic that comes up in here every couple months (b) what's up with -split-objects/-split-sections, why the former makes for more compact executables but drives linkers to 10GB+ RAM usage
20:32:34 <eacameron> geekosaur: "GHC exports module internal code" -> "GHC exports each module's internal code"
20:32:43 <eacameron> Also maybe split that sentance in two. It's long.
20:33:08 <eacameron> geekosaur: I suppose it all depends on what your goal is. It's long enough to make me smarter...so that's something! ;)
20:35:29 * geekosaur split that sentence and added a bit more clarification
20:36:19 <geekosaur> (this is why I asked for readers. I'm also prone to multi-clause sentences which can drive other people up the wall)
21:09:19 <angerman> geekosaur: do not forget to mention -staticlib, please :)
21:10:12 <iqubic> Arch Haskell and ArchHaskell are two distict things?
21:11:21 <geekosaur> I'm not writing up that part yet. but I'm not sure that is entirely relevant to the discussion; (a) above was more about people trying to force static linking on Linux and ending up with a statically linked glibc, which is something of a no-no
21:11:41 <geekosaur> iqubic, there are Haskell packages in the main repo, Haskell packages in AUR, and Haskell packages in a separate ArchHaskell repo
21:12:57 <geekosaur> the latter is an alternative to the packages in the main repo, and mixing packages from them will likely not end well.
21:13:58 <geekosaur> ok, put the article on the wiki: https://wiki.haskell.org/Shared_libraries_and_GHC
21:15:54 <geekosaur> iqubic, https://wiki.archlinux.org/index.php/ArchHaskell
21:32:36 <nickels2> @type map
21:32:38 <lambdabot> (a -> b) -> [a] -> [b]
21:33:21 <nickels2> @undo do {h <- hs; g2 <- (nodeChildren <=< (take 1)) h; (s $ return $ g2:h) <> hs}
21:33:21 <lambdabot> hs >>= \ h -> (nodeChildren <=< (take 1)) h >>= \ g2 -> (s $ return $ g2 : h) <> hs
21:35:39 <iqubic> nickels2: map is just fmap specialized to lists.
21:35:42 <iqubic> :t fmap
21:35:43 <lambdabot> Functor f => (a -> b) -> f a -> f b
21:35:59 <iqubic> let f be list and you get map.
21:36:46 <iqubic> In fact the instance for that looks like: Instance Functor [a] where fmap = map
21:38:57 <nickels2> iqubic: Ah, thank you. Um, I was hoping that only lambdabot could see that stuff. msg lambdabot @... didn't do anything. Is these a way to use it privately on IRC?
21:39:25 <iqubic> try putting a slash before that. 
21:39:35 <iqubic> /msg lambdabot
21:39:43 <iqubic> /msg lambdabot message goes here
21:40:12 <nickels2> that's what I did
21:40:21 <nickels2> I just don't get a response
21:40:25 <iqubic> What client do you use?
21:40:29 <nickels2> irssi
21:40:33 <geekosaur> hm. are you registered with nickserv?
21:40:39 <iqubic> Oh, I think that should work.
21:40:45 <nickels2> yep, I'm registered
21:41:03 <geekosaur> it used to but freenode force-set the option to only accept /msg from identified users a bit ago due to spam
21:41:45 <iqubic> /msg lambdabot :t fmap works for me
21:41:58 <geekosaur> registered but nickserv says you're not logged in
21:42:14 <iqubic> How can that be?
21:42:39 <nickels2> oh wait I think I msg'd NickServ with pass but forgot "Identify"....
21:42:41 <geekosaur> didn't set the protect option, so nickserv doesn;t auto-Guest someone using the nick?
21:43:16 <geekosaur> anyway ident withj nickserv and see if it works.
21:43:40 <geekosaur> (and if it does I'll leave a message for the bot's master to disable the antispam option)
21:44:25 <iqubic> Do you know who maintains lambdabot?
21:45:00 <Axman6> int-e I think
21:45:12 <Axman6> @where your master
21:45:13 <lambdabot> I know nothing about your.
21:45:20 <Axman6> @where master
21:45:21 <lambdabot> I know nothing about master.
21:45:37 <geekosaur> yes, it's int-e
21:45:43 <iqubic> Axman6: that finds which module a function is in.
21:45:47 <iqubic> @where mfilter
21:45:47 <lambdabot> I know nothing about mfilter.
21:45:57 <iqubic> @where fmap
21:45:57 <lambdabot> I know nothing about fmap.
21:45:58 <Axman6> @where lpaste
21:45:58 <lambdabot> http://lpaste.net/
21:46:06 <geekosaur> iqubic, no, that's @index. @where was intended for URLs but can do general text
21:46:09 <MarcelineVQ> @index fmap
21:46:09 <lambdabot> Data.Functor, Control.Monad, Prelude, Control.Monad.Instances
21:46:13 <Axman6> where is just a key value map
21:46:30 <iqubic> @index mfilter
21:46:30 <lambdabot> Control.Monad
21:46:39 <geekosaur> (there used to be @fact for a general text lookupwith categories but just using @where turned out to be easier)
21:47:06 <iqubic> I know very little about lamdabot.
21:47:20 <Axman6> go read the source =)
21:47:21 <iqubic> nickels2: did you get the /msg lambdabot to work?
21:47:57 <iqubic> Axman6: is that available anywhere?
21:47:57 <geekosaur> I never ran the one in here but I used to run a separate instance. the help file I assembled for it is still occasionally useful; it doesn;t mention the haskell-speciifc plugins but has better docs for everything else, including admin commands
21:47:58 <nickels2> Axman6: still trying to figure-out NickServ
21:48:16 <geekosaur> /msg nickserv identify <yourpasshere>
21:48:33 <TipsyMe> https://youtu.be/PYfWm0bGP-8?t=6
21:48:34 <geekosaur> if you were using a nick other than your normal one, you;d have to include your nickserv-registered nick as well
21:49:38 <nickels2> no response from nickserv
21:50:39 <geekosaur> it may be in a different tab
21:50:46 <geekosaur> but nickserv's info command thinks you are authed now
21:55:10 <nickels2> geekosaur: nickserv and lambdabot were, indeed, each in respective tabs
21:55:26 <iqubic> nickels2: Does "/msg lambdabot message here" work now?
21:55:31 <geekosaur> ah, so it was actually working before but you didnt see it?
21:56:05 <geekosaur> /query can be more useful as it opens a new tab if needed and switches you to it
21:56:20 <geekosaur> e.g. /query lambdabot
21:56:57 <nickels2> yes, it was working the whole time.
21:57:27 <nickels2> geekosaur: and thank for the /query tip
21:57:36 <geekosaur> (and this kind of thing is why I dislike irssi. hexchat can also open stuff itself but at least it highlights it)
22:01:33 <nickels2> I can't remember the last time I felt so embarassed...dang, though - irssi gives no indication whatsoever. May have to switch to hexchat. (like to keep everything in the terminal if possible tho)
22:02:48 <geekosaur> I was never very happy with terminal based IRC clients. although there's some possibilities that as far as I know nobody has implemented, like making a terminal chat client work with tmux (and for example using its highlighting/status line)
22:04:07 <iqubic> geekosaur: What irc client do you use.
22:04:23 <geekosaur> hexchat, as I said earlier
22:04:24 <iqubic> ???
22:04:42 <iqubic> When did you say that?
22:04:48 <iqubic> I'm so confused.
22:06:15 <geekosaur> [29 04:57:14] <geekosaur> (and this kind of thing is why I dislike irssi. hexchat can also open stuff itself but at least it highlights it)
22:07:04 <iqubic> Oh. I see.
22:07:12 <iqubic> I like glirc quite a bit.
22:11:40 <Gurkenglas> Which public #haskell logs are the most complete?
22:11:58 <Eduard_Munteanu> Hexchat also supports SASL out of the box.
22:13:12 <Gurkenglas> What IRC bot library should I use? Ideally it would have an interface like gloss's play.
22:42:04 <Gurkenglas> I just made a github project (only a readme inside) and cloned it, how do I make stack put a project in there?
22:42:13 <Gurkenglas> stack new says the folder already exists
22:42:48 <mud> Gurkenglas: Go inside and use --bare
22:46:42 <Gurkenglas> Oh right licenses. If I haven't thought too much about licenses, and just want to use that license that I can later relax into any other, I use AllRightsReserved, right?
22:47:18 <geekosaur> not sure how github is with that on a free account
22:47:35 <geekosaur> since it's kinda incompatible with being visible
22:47:57 <geekosaur> (otoh they may just leave it to you to deal with it)
22:48:03 <cocreature> Gurkenglas: "stack init"
22:48:18 <tyler569> github TOS says that up using their service you consent to people forking your code at least
22:48:28 <tyler569> by using*
22:48:31 <cocreature> stack init is for creating stack.yaml files for existing cabal repos, stack new is for creating completely new projects
22:48:50 <mud> Gurkenglas: That should correspond to no license I'd hope. Make sure you check what's in the LICENSE file, or delete it.
22:48:53 <cocreature> oh nvm I didn‚Äôt read your post quite clearly, sry
22:50:32 <Gurkenglas> Can I simple take the licenses file of AllRightsReserved, and replace "All rights reserved." with "As many rights as possible reserved."? Or should I get a law degree first :s
22:51:01 <geekosaur> (b) generally any time you're thinking of modifying an existing license. if the alligators don;t get you the shoggoths will >.>
22:51:58 <geekosaur> (or "sharks" in place of alligators which is better for alliteration too...)
22:51:59 <Gurkenglas> Or just replace the whole file with "I'd like the initial object in the category of licenses, please."
22:52:21 <MarcelineVQ> shogarks
22:53:23 <Gurkenglas> Though that poses the question on whether each of two distinguishable licenses can be relaxed into all others.
23:01:14 <Gurkenglas> "To automatically update stack.yaml, rerun with '--update-config'" <- that should cache the result so I don't have to wait through the solving again :I
23:02:42 <MarcelineVQ> it'll write the needed hackage packages to the exta-deps section of your stack.yaml
23:03:16 <MarcelineVQ> are you saying between runs it should remember what it said before if nothing changed?
23:03:25 <MarcelineVQ> that would be nice
23:10:46 <geekosaur> what happens if you add something that changes the solver? that might be hard to determine beforehand such that it would know it could skip
23:10:53 <geekosaur> er, changes the solution
23:14:15 <Gurkenglas> Maybe it should provide an extra command that'll update the config with the result of the last run, and point that one out instead of saying "rerun with --update-config"
23:15:14 <MarcelineVQ> er what, that's what --update-config does, it's an extra command that updates the config with the result of the last run
23:23:54 <Gurkenglas> No it reruns stack solver and uses the result
23:26:41 <MarcelineVQ> what is adding another command solving?
23:28:05 <MarcelineVQ> put another way, you only have to learn about --update-config once.
23:28:54 <MarcelineVQ> if a person doesn't go  stack solver --help  in the first place they're probably not going to stumble on the specialty command  stack solveittoconfig  ahead of time either, now there's a command for no one taking up dev and maintenance time
