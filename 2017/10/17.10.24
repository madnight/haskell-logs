00:42:44 <ertes-w> ello
02:52:25 <simon> @pl not . any
02:52:25 <lambdabot> not . any
02:52:30 <simon> is there a none?
02:54:11 <fendor> hi, is there a best practice library for cli's? 
03:05:16 <michi7x7> simon: not . any is as performant as it gets
03:06:26 <ertes-w> are there any reasons to shell out to 'dd' over just reading/writing to device files directly?  no conversions are necessary, just simple block-by-block copying
03:08:27 <MarcelineVQ> :t ((not .) . any)
03:08:28 <lambdabot> Foldable t => (a -> Bool) -> t a -> Bool
03:10:08 <osa1> maybe dd is optimized to use sendfile() or something like that when possible?
03:10:31 <centril> fendor: I prefer optparse-applicative
03:11:19 <centril> fendor: what are you trying to do? build a terminal program that parses command line arguments and does something?
03:11:23 <fendor> centril, this is for command line parsing but if i want some kind of repl? like asking during execution what the internal state is, more like an admin shell
03:11:33 <[exa]> ertes-w: dd gains some performance by being as zero-copy as possible, but I guess you'll be able to judge the actual result using strace
03:12:38 <centril> fendor: for command args parsing go with optparse-applicative, for a REPL it depends on the language the REPL is for I guess
03:13:25 <fendor> centril, it is not a real repl, when running a webserver we want to be able to pass commansd during exeuction like, quit, print all connections, print state of the webserver
03:13:32 <ertes-w> makes sense
03:14:49 <centril> fendor: so I would start perhaps mocking up a grammar for what you want, or perhaps some demos of input/output sequences and then build a grammar from that, and then you can implement it in Haskell with a parsing lib
03:15:52 <centril> fendor: perhaps: https://hackage.haskell.org/package/repline
03:15:53 <ertes-w> thanks
03:17:45 <fendor> ok, so you would implement a parser? the library seems to be nice 
03:18:08 <jerin2> http://lpaste.net/359484
03:18:08 <jerin2> The output I get is in comments
03:18:12 <jerin2> What could be going wrong
03:18:27 <centril> fendor: might not be perfectly suited for a REPL tho, it's mostly for command line arguments, but you can probably use it
03:18:52 <centril> (use it to parse individual lines to the repl)
03:19:16 <fendor> well command line parsing is kind of similar, i'd say
03:19:56 <centril> fendor: so here's a program I wrote using optparse-applicative for command line parsing which can be instructive: https://github.com/Centril/repisodes/blob/master/Args.hs
03:20:03 <centril> (part of the program)
03:21:30 <fendor> yeah this is nice for command line parsing, thanks
03:21:31 <fendor> !
03:24:38 <centril> fendor: these might also interest you:  https://hackage.haskell.org/package/Shellac   https://hackage.haskell.org/package/HCL    
03:24:43 <centril> fendor: also, generally:  https://hackage.haskell.org/packages/tag/user-interfaces
03:28:01 <jerin2> http://lpaste.net/359484
03:28:01 <jerin2> shouldn't forM_ work for all? Why am I seeing only one printed
03:30:59 <centril> jerin2: what happens if you do   matchJournal = do p <- getJournal "journal" ; forM_ p putStrLn   ?
03:31:00 <fendor> centril, shellac looks very promising! will take a look at it right now
03:31:05 <centril> fendor: =)
03:31:13 <fendor> centril, thanks a lot :)
03:31:18 <centril> fendor: yw!
03:32:25 <centril> lambdabot: forM_ [1, 2] print
03:32:57 <fendor> > forM_ [1,2] print
03:33:00 <lambdabot>  <IO ()>
03:33:09 <fendor> @pl forM_ [1,2] print
03:33:09 <lambdabot> forM_ [1, 2] print
03:34:03 <leafgreen> Anyone know if it might make sense to use a strict hashmap of strict hashmaps instead of some array as a 2D lookup table?
03:34:16 <centril> fendor: I guess it makes sense that lambdabot doesn't allow arbitrary IO
03:34:20 <leafgreen> I haven't done this in Haskell before so I don't know if there's a ridiculous performance penalty.
03:34:45 <opqdonut> leafgreen: shouldn't be too bad. might even be faster for sparse data
03:34:49 <jerin2> centril: do you mean output or conceptually?
03:34:52 <opqdonut> measure
03:35:10 <jerin2> centril: I'm getting required output if it's the code fragment alone
03:35:11 <jerin2> :|
03:35:43 <leafgreen> thanks, I guess I should just try it out (if only I had more time to be casual...)
03:35:48 <centril> jerin2: reduce to a smaller bit of code to see where the problem is coming from and to ensure stuff does what you think it should do
03:36:22 <centril> leafgreen: what's your use case?
03:37:10 <jerin2> could the hakyll do statement be creating problems
03:39:10 <centril> jerin2: does forM_ work if you replace remove  hakyll $ do ...  ?
03:39:19 <jerin2> Yes.
03:39:23 <jerin2> centril: Interestingly
03:39:26 <jerin2> :|
03:39:54 <centril> jerin2: do you get any exception?  try to put an IO action after the entire forM_ bit
03:40:47 <centril> like a dummy putStrLn
03:41:17 <jerin2> centril: Nope, dummy putStrLn is also not working
03:41:18 <leafgreen> centril: I'm just trying to implement little heuristic solvers for NP-hard problems. Homework type of stuff
03:41:27 <jerin2> centril: So an exception is getting silently ignored?
03:41:32 <leafgreen> Python is convenient to write in but it performs terribly
03:41:51 <jerin2> centril: Compilation happens for the first entry without errors btw
03:41:52 <centril> jerin2: that's what I'm inferring yes
03:41:59 <jerin2> centril: I can see that in the log
03:42:03 <jerin2> stdout log
03:42:30 <centril> jerin2: so keep removing bits until you find the offending action in hakyll $ do ..
03:42:43 <jerin2> But, How do I know if something is offending?
03:42:43 <centril> bottom up
03:43:06 <fendor> centril, it does when asking correctly, can't recall though what was the correct way
03:43:39 <centril> jerin2: if you see   a/notes/**  b/notes/**   c/notes/**   then it is working, so if it is not working, then remove a line until it is
03:43:59 <centril> jerin2: i.e: try to find a minimally failing program
03:44:58 <centril> leafgreen: so, if you are dealing with matrices and stuff and flat data parallelism is good, then consider REPA
03:45:25 <centril> but probably not
03:49:57 <jerin2> centril: It's not just my fragment - whatever comes after hakyll $ do block doesn't work
03:49:59 <jerin2> Even in main
03:50:01 <leafgreen> I was reading about that one. If I need something like numpy it seems good
03:50:04 <jerin2> centril: Any idea why?
03:50:29 <leafgreen> I just did an A* solver that wasn't very complicated but the memory usage in Python was ridiculous.
03:50:48 <leafgreen> I was thinking of taking a weekend to redo it as well as I could in C++ and Haskell for sake of comparison.
03:51:56 <leafgreen> All right, well thanks. Gotta go
04:06:13 <MUWA> testing...
04:09:15 * ski blinks
04:09:50 <MUWA> test ???
04:10:01 <ski> untest ...
04:12:15 <MUWA> ski: i just how many people in here :)
04:12:24 <centril> jerin2: none :(
04:16:54 <hexagoxel> any reflex users that have an explanation as to why  "R.tag beh2 counterE" does not behave the same as "R.switch $ (<$ counterE) <$> beh2" ?
04:17:20 <hexagoxel> full testcase at http://lpaste.net/359488
04:17:57 <centril> So, given   class Head2F (f :: * -> * -> *) where ;  and  data D3 a b = D3 deriving (Head2F)  , why can't Head2F  be derived? 
04:18:36 <centril> Seems D3 must either be :: *  or :: * -> *  but why is :: * -> * -> *  a problem ?
04:18:39 <hexagoxel> in that paste are four pieces. the first behaves as expected, but fires more often than desired.
04:19:22 <hexagoxel> the other three all should (?) have the same behaviour, but don't, in a strange way.
04:19:43 <hexagoxel> this is on HEAD of both reflex and reflex-host.
04:20:38 <hexagoxel> i'd be glad if someone could at least confirm that this smells like a bug..
04:22:37 <hexagoxel> @tell leafgreen C++? eww, at least use rust :)
04:22:37 <lambdabot> Consider it noted.
04:22:46 <centril> hexagoxel++
04:23:00 <centril> was going to say that
04:23:39 <centril> hexagoxel: coincidentally, I'm working on semantics for DeriveAnyClass in Rust
04:27:38 <hexagoxel> centril: any further complications? i remember you had some associated type question before.
04:28:43 <hexagoxel> (but then i don't even use really use DeriveAnyClass in haskell, so i might be the wrong to ask..)
04:28:53 <centril> hexagoxel: I solved the associated type question
04:29:04 <centril> hexagoxel: It's mainly as a tool for typecheck before implementing
04:30:32 <centril> hexagoxel: so I'm mainly trying to figure out how to make generics + DeriveAnyClass (#[derive_unfinished(Trait)]) work soundly
05:46:03 <lyxia> centril: Head2F D3 is being derived just fine with DeriveAnyClass
05:49:24 <centril> lyxia: hmm... I get "The last argument of class `Head2F' does not have kind * or (* -> *)"
05:49:41 <centril> lyxia: changes in newer GHCs?
05:55:44 <Daniel_> I want to use https://hackage.haskell.org/package/clock-0.7.2/docs/System-Clock.html module to measure the time of a compution. However,the function diffTimeSpec results into seconds and nanoseconds, but I want it to be in seconds rounded with 2 decimals. What's the best to convert the nanoseconds to seconds(With rounding)?
05:57:11 <fakenullie> Daniel_: fromInteger x / 1000000
05:57:35 <lyxia> centril: is that just with those two lines of code?
05:58:02 <Daniel_> fakenullie: Thank you!
06:06:19 <centril> lyxia: oh sorry, http://lpaste.net/359494
06:21:48 <saurabhn_> is there any time helper library to allow for easy data/time arithmetic?
06:22:18 <johnw> saurabhn_: thyme is the best I know so far, even if the docs aren't great
06:23:04 <johnw> it lets you view time as an vector space
06:23:25 <saurabhn_> I need something that can allow me to do t + 3.days
06:24:43 <saurabhn_> found one -- https://hackage.haskell.org/package/timing-convenience-0.1/docs/Data-Time-Convenience-Calculators.html
06:26:33 <saurabhn_> what's the quickest way to try a new pacakge in a stack project without mucking around with the stack.yaml or cabal file?
06:29:59 <lyxia> centril: interesting, 7.10 compiles it but has some debug output showing it's not very happy about it, 8.0 fails with your error, and 8.2 is fine.
06:30:19 <centril> lyxia: o.O
06:30:30 <centril> I guess I need to update my compiler then
06:30:41 <centril> like tomorrow cause I'm super tired :P
06:30:47 <centril> lyxia: thanks for the help!
06:31:01 <lyxia> centril: the user guide for 8.2 says "-XDeriveAnyClass is no longer limited to type classes whose argument is of kind * or * -> *."
06:31:15 <centril> lyxia: oh, nice
06:31:59 <centril> lyxia: So I'm doing this as research for a sound implementation of DeriveAnyClass for Rust
06:32:12 <lyxia> I remember that :)
06:32:26 <centril> lyxia: ;)
06:32:31 <centril> lyxia: so far:  https://github.com/Centril/rfcs/blob/rfc/derive-unimpl/text/0000-derive-unimpl.md
06:32:45 <lyxia> I was about to ask where I could follow progress :)
06:32:56 <centril> hehe ^,-
06:33:56 <Psybur> Anybody know the difference between .| and =$= ?
06:34:39 <centril> lyxia: I sneaked in some usage of "Alonzo" for a struct =P
06:34:59 <Psybur> *Anybody know the difference between .| and =$= in conduit?
06:36:24 <lyxia> Psybur: looking at the source, they're the same.
06:36:37 <Psybur> lyxia, thanks I had a feeling.
06:36:38 <lyxia> Psybur: .| is fuse which is =$=
06:37:56 <lyxia> The changelog mentions that they're "reskinning" conduits.
06:38:30 <merijn> Psybur: =$= is basically outdated
06:38:39 <Psybur> I see
06:38:44 <centril> lyxia: haven't made the RFC tho yet, I'll try to remind myself to notify you when I am ;)
06:38:48 <merijn> Psybur: Conduit used to have a bunch of different combinators which got replaced by a single one at some point
06:38:56 <portnov> https://github.com/portnov/heavy-logger/blob/master/examples/TestTH.hs
06:38:57 <merijn> Psybur: So it's just backwards compat
06:38:59 <centril> lyxia: Perhaps I'll do GeneralizedNewtypeDeriving as well
06:58:01 <Psybur> No matter what I try I cannot figure out how to get any kind of vector with: sinkVector :: (MonadBase base m, Vector v a, PrimMonad base) => Consumer a m (v a).
07:00:11 <Psybur> When I run: runConduit $ yieldMany [1,2] .| sinkVector :: V.Vector Int I get Expected type: V.Vector Int
07:00:12 <Psybur> , Actual type: V.Vector (v0 b0)
07:01:24 <Psybur> No matter what I google I cannot seem to find an example of anybody using this Sink o.o;
07:04:00 <lyxia> Psybur: runConduit will have a return type of the shape (m (v a))
07:04:39 * ski . o O ( `runConduitPure' ? )
07:04:57 <Psybur> When I run that I get No instance for (Control.Monad.Primitive.PrimMonad Identity)
07:04:57 <Psybur>         arising from a use of `sinkVector'
07:06:30 <jchia_> What's a good way to 'show' an Int to a ByteString, i.e. to ASCII encoding? Is there a better way than "encodeLatin1 . tshow"?
07:06:33 <ski> i suppose try with `ST' ?
07:07:10 <jchia_> "encodeLatin1 . tshow" involves an intermediate conversion, so it's not optimal.
07:08:21 <Psybur> ski, are you saying runST $ runConduit ?
07:08:30 <sm> saurabhn_: stack install NEWPKG, stack exec -- ghci, import New.Pkg ?
07:08:51 <ski> if that's what you want to do
07:09:17 <saurabhn_> ah okay... 
07:09:22 <saurabhn_> stack ghci won't do that, right?
07:09:23 * ski isn't familiar with `conduit'
07:09:38 <sm> I think not
07:11:48 <Psybur> ski, u r so smrt. runST $ runConduit $ yieldMany [1,2] .| sinkVector :: V.Vector Int worked
07:11:51 <Psybur> How did you know?!
07:12:31 <byorgey> ski is actually an advanced AI running in the cloud
07:12:47 <lyxia> jchia_: Data.ByteString.Builder.intDec
07:13:05 <ski> i looked a little bit at <https://hackage.haskell.org/package/conduit-1.2.12.1/docs/Data-Conduit.html>. lyxia mentioning the return type of `runConduit' also helped
07:13:46 <Psybur> ski, but how did you ST would work if Identity didnt?
07:14:07 <ski> `ST s' is an instance of `PrimMonad'
07:14:27 <ski> (which i also looked up, to check)
07:14:30 <byorgey> I suppose the confusing bit about the error message is that since Vector is an instance of Monad, it was getting unified with the 'm', but that is actually the "wrong" choice
07:15:25 <ski> (of course, it would be possible to `IO'. but it sounded like you might not want to get stuck in `IO' here)
07:16:37 <ski> i wonder whether there's a nicer way to do it, without `ST'
07:16:56 <Psybur> ski, what do you mean by `IO`? This doesnt work in ghci:  r <- runConduit $ yieldMany [1,2] .| sinkVector :: V.Vector Int
07:17:17 <ski> use `IO (V.Vector Int)' in the ascription ?
07:17:39 <ski> <lyxia> Psybur: runConduit will have a return type of the shape (m (v a))
07:17:55 <jchia_> lyxia: Thanks
07:18:11 <Psybur> That worked. I must have missed a tutorial somewhere heh
07:19:41 <jchia_> Psybur: When you add type to a "<-" line, the type to use is not the type of the LHS of the '<-' but the type of RHS.
07:20:08 <ski> it might be nicer to write `r :: V.Vector Int <- runConduit (yieldMany [1,2] .| sinkVector)' .. but you need `ScopedTypeVariables' to enable that syntax (formerly, `PatternSignatures' was needed)
07:20:39 <ski> `res <- act :: M T' is parsed as `res <- (act :: M T)'
07:25:44 <cocreature> I still find it confusing that ScopedTypeVariables allows me to write signatures on patterns
07:26:26 <johnw> cocreature: each name binding is a new scope for type variables
07:27:17 <cocreature> johnw: yeah I get why it’s that way but 95% I don’t even use any type variables in the pattern signatures I write
07:28:32 <cocreature> pattern signatures is one of those things that should just be on by default imho and then ScopedTypeVariables can affect how the scoping works
07:29:25 <johnw> so, without ScopedTypeVariables you'd want to be able to write a signature, but if you said "forall a." that 'a' would only have meaning within that specific type declaration, and no other meaning relating to before or after the type declaration?
07:30:00 <johnw> that seems reasonable; perhaps we should include this in the next report
07:30:07 <johnw> I wonder why it's not that way now
07:30:23 <cocreature> something like that, tbh I mosty care about the “writing pattern signatures without enabling anything” part
07:30:24 <johnw> where you can put type annotations should be orthogonal to the scope of their type variables
07:30:32 <cocreature> I very rarely use the actual scoping for pattern signatures
07:32:44 <johnw> cocreature: here's the proposal for this feature: https://github.com/haskell/rfcs/pull/14
07:33:40 <cocreature> ah nice
07:37:34 <ski> unfortunately, `ScopedTypeVariables' doesn't allow one to put result type ascriptions on function definitions, something which `PatternSignatures' used to allow, iirc
07:46:04 <shapr> chessai: oh, I know you
07:46:15 <chessai> shapr: oh, I know you too
07:46:22 <shapr> hi!
07:46:25 <chessai> hi
07:46:41 <chessai> i just followed you on github
08:11:55 <Psybur> Is there a better way of getting a linecount in conduit than foldMapC (\_ -> Sum 1)
08:13:40 <Psybur> Alternatively, does anybody know how to turn read all lines into a vector in one pass without sinkVector :D Otherwise I have to find the number of lines first to do conduitVector
08:14:43 <dumptruckman> Hey, how can I create an algebraic data type that takes an argument that is a Num?
08:15:55 <Psybur> I might be able to roll my own conduitVector based on the conduitVector size code :o
08:16:04 <lyxia> dumptruckman: it sounds like you are looking for GADTs
08:16:41 <dumptruckman> yeah, i think so too but i can't figure out how to use it
08:17:31 <lyxia> dumptruckman: can you explain more what you are trying to do with it
08:17:33 <dumptruckman> trying to do something like this https://ghostbin.com/paste/td57d
08:17:55 <lyxia> how would you use Constant?
08:18:33 <lyxia> why not just put an Integer
08:18:54 <dumptruckman> i want to allow any type of number
08:19:03 <cocreature> Psybur: a bit overkill if all you want is a linecount but for more complex stuff a combination of https://hackage.haskell.org/package/conduit-extra-1.2.0/docs/Data-Conduit-Foldl.html#v:sinkFold and https://hackage.haskell.org/package/foldl-1.3.3/docs/Control-Foldl.html#v:length is great
08:19:48 <dumptruckman> lyxia: in any case, changing Constant to Constant :: Double doesn't fix the error
08:19:57 <Psybur> I wonder which is faster, going through the file to get a line count and then allocating a vector of that size exactly, or going through once and resizing the vector as you go
08:21:42 <lyxia> dumptruckman: but if you can put any type of number how can you then get it out? All you would know when pattern matching on Constant is that it contains something that has a Num instance.
08:22:45 <dumptruckman> okay, let's pretend it's just a Double
08:23:24 <lyxia> dumptruckman: If I look past that detail, GADT declarations consist of constructors annotated with their types
08:23:25 <dumptruckman> it still says "illegal generalized algebraic data type declaration"
08:23:32 <vim15years> does a problem exist, that can't be solved efficently on a non deterministic turing machine?
08:24:11 <lyxia> dumptruckman: Perhaps you mean   Multiply :: Token, for instance?
08:24:29 <dumptruckman> lyxia: well, i have an Operator algebraic type
08:25:14 <dumptruckman> changing Operator to Token doesn't change anything it seems
08:25:23 <lyxia> dumptruckman: http://lpaste.net/359497
08:25:45 <lyxia> although it doesn't use any advanced feature of GADTs now
08:25:55 <dumptruckman> right
08:26:04 <dumptruckman> it also still doesn't compile
08:26:53 <lyxia> What does the error message say
08:28:44 <dumptruckman> "illegal generalized algebraic data type declaration"
08:29:29 <lyxia> vim15years: If by "efficiently" you mean "polynomial time", there are indeed problems whose witnesses have more than exponential size. I think theorem proving is an example but I don't have a reference off hand.
08:29:47 <lyxia> dumptruckman: have you enabled the GADTs extension
08:29:53 <dumptruckman> no
08:29:57 <dumptruckman> didn't know that was a thing
08:30:16 <lyxia> dumptruckman: doesn't the error message say to "use GADTs"
08:30:31 <lyxia> I guess it's not obvious that's meant to be an extension
08:30:43 <dumptruckman> yeah
08:30:51 <dumptruckman> oh well, not gonna use it then
08:31:02 <dumptruckman> sticking with Double makes GADT pointless anyway
08:31:18 <lyxia> yes
08:31:23 <lyxia> good idea
08:32:51 <dumptruckman> Thanks lyxia
08:34:14 <nicknight> Any one here ever used haskell in kaggle competitions ?
08:44:01 <Lokathor> surely there's a builtin for safeGet :: [a] -> Int -> Maybe a
08:44:10 <Lokathor> what name is it under?
08:44:13 <vim15years> lyxia, so these problems would be harder than np-hard?
08:45:00 <lyxia> vim15years: yes
08:45:37 <lyxia> Lokathor: in base, the closest thing is to compose drop and listToMaybe
08:47:24 <dsal>     Orphan instance: instance Arbitrary BC.ByteString  --  Do I care about this?  This seems like a useful pattern, but the suggestions (wrapping it in a newtype) seem painful.
08:48:02 <EvanR> actually i like newtypes for Arbitrary
08:48:33 <EvanR> you will likely want different generators for String Text and ByteString
08:49:03 <Lokathor> @pl (\index list -> listToMaybe $ drop index list)
08:49:03 <lambdabot> (listToMaybe .) . drop
08:49:28 <cocreature> dsal: depends on where you decare it. if you declare it in a test suite or in an executable you should be fine since nobody can depend on you
08:49:30 <EvanR> listToMaybe .: drop
08:49:35 <cocreature> in libs you probably want to avoid it
08:49:49 <crobbins> didn't there used to be an archlinux package for ghc-mod?
08:50:02 <cocreature> dsal: you might also be interested in https://hackage.haskell.org/package/quickcheck-instances
08:50:25 <ggVGc> really wish I was writing something in haskell
08:50:30 <ggVGc> instead of javascript...
08:50:36 <dsal> Neat, thanks.
08:50:42 <a6a3uh> Hi! Is it possible to write synonym for constraint (not type) as I have to repeat it many times for many functions. for example I have constraint of this kind repeated for each of many functions: (Integral n, Real r, MonadReader Cost m, MonadMemo (n, n, n) [r] m)
08:50:45 <ggVGc> has anyone here written any trading helpers or bots in haskell?
08:50:58 <dsal> So, why is it bad for me to have an instance of someone else's type in my lib?
08:51:17 <dsal> e.g., if I provide functionality that includes a class and want to set up a bunch of defaults, isn't that like, normal?
08:51:45 <ggVGc> EvanR: aren't newtypes basically mainly used for hacks in the type system?
08:51:53 <cocreature> a6a3uh: yes, enable -XConstraintKinds and then you can use things like "type C a = (Show a, Eq, a, Ord a)" 
08:51:54 <ggVGc> I never really used newtypes
08:52:15 <cocreature> dsal: because there could then be multiple instances for a single type
08:52:33 <EvanR> newtypes are used for a few things
08:52:48 <a6a3uh> #cocreature: thanks! will look at this.
08:52:54 <EvanR> but it boils down to, do you want the typechecker to consider the wrapped type and the new type different
08:53:13 <EvanR> and the runtime to consider them the same
08:53:44 <dsal> cocreature: Oh, I see the point.  It still seems like a good idea for a lot of things.
08:56:37 <Psybur> So if I have a conduit of one large vector and I wanted to efficiently create a sliding window from it, would unfoldC be the way to go?
08:58:39 <Psybur> Hmm, maybe its actually still a fold
08:58:56 <Psybur> Wait, maybe not :D
08:59:53 <jgt> how would I use a CSV file as a data source for Hakyll?
09:03:10 <jgt> oh, this kind of thing looks promising: https://groups.google.com/forum/#!topic/hakyll/LBYfdBc8eHU
09:48:46 <senorsmile> Greetings!  Decided to learn haskell as my first functional language this morning.  Going through the book "learnyouahaskell" but running into an inconsistency.     When I try 5 /= 5, I get the error "Cannot modify an immutable Int (5)" 
09:49:21 <mauke> how are you running this code?
09:50:24 <dsal> senorsmile: http://haskellbook.com/ is a super  nice intro.  But I think you're not typing what you think you're typing.
09:50:27 <dsal> > 5 /= 5
09:50:29 <tinco> senorsmile: what's 5 /= 5 supposed to do?
09:50:32 <lambdabot>  False
09:50:36 <mauke> ^ that
09:50:38 <tinco> ah not equals woops
09:51:13 <dsal> > 5 = 5
09:51:15 <lambdabot>  <hint>:1:3: error:
09:51:15 <lambdabot>      parse error on input ‘=’
09:51:15 <lambdabot>      Perhaps you need a 'let' in a 'do' block?
09:51:27 <dsal> I'm trying to figure out how you got that error.  heh
09:51:35 <mauke> dsal: it's not a haskell error
09:51:54 <mauke> haskell has no modification, hence there's nothing to be misinterpreted as a modification attempt
09:52:03 <dsal> Ocaml?
09:52:15 <mauke> ocaml doesn't have an Int type
09:52:43 <dsal> I look forward to seeing how this mystery unrolls.
09:52:48 <tinco> :P
09:52:59 <senorsmile> I tried several combinations to no avail
09:53:07 <mauke> senorsmile: answer my question
09:53:12 <senorsmile> I even copy pasted from the html version of the book online and got the same error
09:53:15 <mauke> senorsmile: how are you running this code?
09:53:17 <dsal> senorsmile: What are you doing?
09:53:20 <senorsmile> ah sorry
09:53:22 <senorsmile> ghci
09:53:36 <mauke> screenshot?
09:53:44 <mauke> I need to see this
09:53:45 <senorsmile> huh, it's working fine now
09:53:48 <dsal> Prelude> 5 /= 5
09:53:48 <dsal> False
09:53:53 <senorsmile> I closed my terminal and reopened it
09:54:21 <dsal> perl6 !
09:54:26 <senorsmile> assumption: I was in some other REPL and am basically going insane
09:54:35 <platz> can i lift an (Either String a) into a (Parser a) with some kind of lift, or do i just write P.either P.fail (pure . P.id)
09:54:50 <senorsmile> @dsal you're probably right.
09:54:50 <lambdabot> Maybe you meant: keal eval
09:54:56 <mud> Ya, it was some other repl. In another language that might mean  5 = 5 / 5, which is then kind of nonsensy in most.
09:55:18 <mauke> perl6 is weirdly plausible
09:55:20 <hydraz> it was perl6
09:55:29 <mauke> especially the "Cannot ..." part
09:55:45 <senorsmile> just fired up perl6 and confirmed, that's exactly the same error.  Problem solved :-|
09:56:00 <mauke> heh
09:56:11 <mauke> if we had a ghcdiag, we could add this as an entry :-)
09:56:12 <senorsmile> Thanks everyone!  (slowly moves back to my corner)
09:57:31 <dsal> Where's the thing that gives me a recursive descent of filesystems?
09:57:39 <mauke> for perl, 'perldoc perldiag' shows you all the diagnostics emitted by perl with a short explanation
09:57:53 <mauke> it has a few "category (A)" ones: https://metacpan.org/pod/perldiag#%s:-Command-not-found
09:57:59 <mauke> (alien, not from perl)
09:58:24 <dsal> https://hackage.haskell.org/package/filepath-1.4.1.2/docs/System-FilePath-Posix.html looks like a start.
09:59:02 <dsal> No, these are all just names.
10:00:53 <dsal> I think System.Directory.Tree probably has what I'm looking for in some way.
10:55:37 <schell> o/
10:55:50 <schell> is hackage building docs again?
10:58:46 <geekosaur> been fixed for a couple years now. but it still doesn;t build if you have weird prerequisites like some C library that isn't part of a normal install
10:59:29 <schell> geekosaur: good to hear - know about how long it takes? is there an api endpoint i can hit to check the status?
11:00:06 <geekosaur> links on the page for a package, or see https://matrix.hackage.haskell.org/
11:01:51 <schell> geekosaur: very cool - thanks :)
11:02:48 <rick-sanchez> does somebody else have problems with intero on emacs? it disappeared from the packages after I restarted it :o 
11:11:27 <schell> rick-sanchez: i’ve been using dante instead of intero and have been mostly happy
11:11:43 <fakenullie> intero works for me
11:14:11 <rick-sanchez> I was not aware of dante, I will try it
11:15:26 <schell> geekosaur: i’m not allowed to queue my package on matrix.hackage.haskell.org, and i don’t see it automatically queued - will it be queued eventually or do i have to do something?
11:16:49 <schell> funny, it just did it!
11:16:55 <schell> okay, nvm geekosaur 
11:20:05 <dsal> So, criterion has this 'nf' function that looks like this:         :: deepseq-1.4.2.0:Control.DeepSeq.NFData b => (a -> b) -> a -> Benchmarkable
11:20:22 <dsal> I can't see how to make an instance of NFData, though
11:21:01 <shapr> Does anyone live stream Haskell coding on twitch or some other website?
11:21:14 <schell> shapr: that would be fun
11:21:16 <EvanR> NFData from deepseq is a normal type class, you implement the method rnf. But you can also auto derive the instance using Generics
11:21:17 <dsal> Wait.  No idea what I was looking at before.  *sigh*
11:21:20 <shapr> Does that just require a podcast-quality mic and some screencasting software?
11:21:29 <maerwald> shapr: never understood why anyone would watch other people code, unless edk is coding
11:21:32 <dsal> EvanR: Yeah, I missed that.  Something I was looking at before showed it with no methods and it confused me.
11:21:58 <shapr> I've watched edwardk code, it's more bewildering than anything else.
11:21:58 <schell> would be fun for a game jam like the ludum dare
11:22:16 <maerwald> shapr: like a david lynch movie?
11:22:24 <shapr> maerwald: ok, it's not THAT bad
11:22:27 <maerwald> xD
11:22:34 <Tuplanolla> I imagine people watching me would quickly get sick of jumping between buffers.
11:23:10 <shapr> I've been teaching (Python) to coworkers twice a week at lunch, it's way more fun than I expected, so I'd like to try streamcoding.
11:23:24 <shapr> streamcoding Haskell, of course
11:24:00 <shapr> Tuplanolla: yeah, coworkers say my use of emacs is confusing, they can't keep track of what went where.
11:24:08 <shapr> So viewers might hate me, who knows
11:24:12 <chessai> shapr: i would surely watch that
11:24:13 <maerwald> is there anything to teach in python?
11:24:31 <maerwald> the oddities you catch up while yo go
11:24:32 <shapr> maerwald: yeah, the people who come to my free class have zero coding experience
11:24:36 <maerwald> the rest is just... well
11:24:49 <Cale> maerwald: Surely as much as there is in Haskell, just, most of it isn't as valuable
11:24:53 <shapr> today we did markov chains, next week or so we'll be doing stylometry
11:27:04 <Cheery> a quick question, what's the exact meaning of (Num a) => a -> a -> a  in the (+)?
11:27:31 <Cheery> broadest meaning I can come up with.. is that input and output arguments have to come with Num typeclass.
11:27:39 <fakenullie>  it takes two arguments of type a and returns value of type a
11:27:47 <schell> Cheery: exactly
11:27:49 <fakenullie> a must be an instance of Num typeclass
11:27:50 <Psybur> And type a has to be a Num
11:28:09 <shapr> a is a Num... sounds like an object instance
11:28:39 <fakenullie> without OOP nonsense though
11:28:53 <dsal> ah.  units.  heh.    It went from 14ns to 10µS and I was like, "wtf, how did it get faster?"  I think I succeeded at NFDataing this.
11:29:10 <Cheery> When I write down :t 1, it gives me explanation that 1 returns a 'Num'
11:29:22 <shapr> Cheery: yeah, it's giving you the most general type
11:29:43 <shapr> Cheery: so it's not going to decide whether you want float, or int, or integer... not until you give more constraints by using it with other code
11:29:48 <shapr> :t 1
11:29:49 <lambdabot> Num p => p
11:29:55 <Cheery> but if I do 1 + 2, it's still Num
11:29:55 <fakenullie> :t 1 / 1
11:29:57 <lambdabot> Fractional a => a
11:30:03 <shapr> :t (+)
11:30:05 <lambdabot> Num a => a -> a -> a
11:30:13 <shapr> Cheery: because + isn't any more specific than Num
11:30:16 <shapr> but / is!
11:30:31 <EvanR> Cheery: if you actually manage to evaluate 1 + 2, then you will necessarily have a concrete type
11:30:46 <EvanR> because what + does depends on the specific type
11:30:53 <dsal> I made my structs strict and gained an entire new SI symbol.
11:30:56 <EvanR> and for that matter, what 1 and 2 mean
11:30:57 <schell> Cheery: the literals ‘1’ and ‘2’ are both (Num a => a), until you use the result in another computation that picks the concrete type of ‘a’
11:31:23 <shapr> Cheery: did that help any?
11:31:30 <EvanR> > 257 :: Word8
11:31:33 <lambdabot>  1
11:31:44 <Cheery> yup, this is friendly and helpful.
11:32:01 <Cale> shapr: ahh, that sounds more interesting than just the language itself :)
11:32:15 <shapr> Cale: well, I'm teaching *programming* not just Python
11:32:17 <shapr> that would be boring
11:32:18 <EvanR> fromInteger 257 for Word8 does something wildly different from fromInteger 257 for Int
11:32:31 <shapr> though I think we'll use 'rare pairs' instead of principal component analysis
11:32:38 <jle`> Cheery: hindley-milner tries to pick the most polymorphic type possible
11:32:47 <jle`> Cheery: so (1 + 2) can really be interpreted as any instance of the Num typeclass
11:32:54 <Cheery> if I have a vector, it can also belong to a Num typeclass?
11:33:12 <jle`> it depends on where the vector type is coming from
11:33:14 <EvanR> as in V2 Int
11:33:19 <jle`> and if the person who wrote it wrote a Num instance
11:33:20 <EvanR> thats a Num
11:33:22 <Cheery> jle`: how does the repl decide which concrete type it selects for eval?
11:33:24 <jle`> any type can "have a Num instance" in Haskell
11:33:31 <jle`> you just need to declare it :)
11:33:35 <jle`> instance Num MyVector where ...
11:33:39 <EvanR> Cheery: defaulting rules
11:33:48 <EvanR> 1 + 2 will default to Integer
11:33:49 <jle`> Cheery: in specific cases there are "default options"
11:34:00 <jle`> but in the general case Haskell can't always decide
11:34:31 <jle`> it's actually one of the more common errors that comes up in haskell code -- you write your code too polymorphic, but haskell requires a specific type when actually compiling/evaluating
11:34:54 <Cheery> ok.. If I do 1 + x where x is a Vector, how does '1' know to turn into a vector?
11:35:03 <jle`> because of the type of (+)
11:35:10 <jle`> (+) takes two values of the same type
11:35:10 <EvanR> type inference
11:35:32 <jle`> if (x :: Vector), then it means that, in (+) :: Num a => a -> a -> a, 'a' must be Vector
11:35:42 <jle`> so (+) :: Vector -> Vector -> Vector, so (1 :: Vector)
11:36:19 <Cheery> okay
11:36:29 <EvanR> "how does it know" is kind of a big question, depending on what that means :)
11:36:37 <Cheery> so 'a' must resolve into a concrete type to evaluate.
11:37:00 <jle`> well, if you want to print it at least
11:37:04 <Cheery> and it's kind of decided from the context.
11:37:13 <jle`> if you want to print a value, you need to pick a specific 'a'
11:37:14 <Cheery> through unification
11:37:15 <EvanR> in this case yes because Num a needs to be a concrete instance 
11:37:16 <test123123> Why is parsec rolling its own (<|>) and "many" functions and not instantiating Control.Applicative.Alternative for GenParser?
11:37:24 <jle`> because every type is "printed" in a different way
11:37:28 <jle`> depending on its Show instance
11:37:41 <jle`> so the choice of type changes how a value is printed...so you need to pick a specific 'a'
11:37:55 <jle`> test123123: parsec predates Applicative/Alternative
11:38:02 <shapr> test123123: yeah, by very much
11:38:28 <EvanR> printing it is kind of beside the point here, you can evaluate without printing
11:38:39 <EvanR> haskell kind of is annoying with the Show class
11:38:52 <EvanR> you can evaluate without needing a Show instance
11:38:54 <jle`> EvanR: yeah, my point was that i think it's not necessarily true that you have to pick a specific 'a' to "evaluate" in general
11:38:55 <Cheery> EvanR: yes, it's big question but I kind of like to understand it in broad context.
11:39:02 <jle`> so you can evaluate without picking a specific type
11:39:08 <jle`> but if you *print* it, then yes, you do need to pick a specific type
11:39:18 <EvanR> you do have to pick an instance in order to do +
11:39:22 <EvanR> but not to print it
11:39:23 <Cheery> I'm still kind of wondering how 1 concretely turns into a vector with '1' at each row.
11:39:36 <jle`> Cheery: that's from the Num instance of Vector
11:39:39 <EvanR> we just dont have a generic way to display data
11:40:04 <EvanR> Cheery: see in the Num class, it has a method fromInteger
11:40:06 <jle`> it's probably instance Num Vector where fromInteger x = a row of x's
11:40:07 <EvanR> :t fromInteger
11:40:08 <lambdabot> Num a => Integer -> a
11:40:36 <EvanR> that is secretly used to give a meaning to number literals like 1
11:40:51 <Cheery> ok thanks.. I think I'm able to understand this right now.
11:40:54 <jle`> the 1 literal is syntactic sugar for (fromInteger (1 :: Integer))
11:40:54 <test123123> shapr, jle`would parsecs <|> and many functions meet the specification of the Alternative typeclass?
11:41:07 <jle`> test123123: indeed, they are actually one of the inspirations for the Alternative typeclass
11:41:35 <shapr> I don't remember, I use megaparsec these days.
11:41:41 <test123123> jle`: Why is this not changed in the newer parsec releases?
11:41:52 <jle`> parsec isn't super actively maintained
11:41:55 <EvanR> so in the haskell code (1 :: Integer), the expansion is (fromInteger (1 :: Integer) :: Integer) ? :)
11:41:59 <EvanR> descent into madness
11:42:03 <shapr> yeah, what's Daan doing these days? He's in Denmark or something?
11:42:17 <jle`> test123123: parsec isn't really a choice you'd make if you are looking for a modern library
11:42:34 <shapr> on the good side, parsec source was very easy to understand last time I dug into it.
11:42:38 <test123123> What would i use instead?
11:42:43 <jle`> currently in haskell it is more of a historic relic than an actual modern real world library these days
11:42:45 <shapr> MEGPARSEC!
11:42:47 <jle`> test123123: megaparsec
11:42:48 <shapr> at least, I like it
11:43:08 <jle`> well, megaparsec is the direct spiritual successor of parsec, but there are other modern parser combinator libraries out there as well
11:43:32 <shapr> oh, Daan is working at Microsoft on Koka?
11:43:34 <test123123> Is megaparsec the most similar too parsec?
11:43:39 <Cale> I like attoparsec
11:43:43 <Cheery> I'm trying to find or think up a nice way to overload operators in a dynamically typed language.
11:44:00 <shapr> Cale: what advantages does attoparsec have over megaparsec?
11:44:14 <mud> test123123: Should be, it's *very* similar.
11:44:16 <maerwald> automatic backtracking?
11:44:27 <maerwald> afair in megaparsec is depends whether it backtracks
11:44:31 <maerwald> I find that annoying
11:44:33 <EvanR> Cheery: the classic way where + is a method on the first argument... is really bad
11:44:34 <Cheery> EvanR: Ended up concluding that plain dispatch tables and simple types aren't going to work.
11:44:58 <Cheery> yeah. the Python approach is also bad.
11:45:17 <EvanR> it boils down to this, you want + to mean different things at different times
11:45:29 <EvanR> the choice haskell made is that, you always want both arguments to be the same type
11:45:38 <EvanR> other than that, anything goes
11:46:33 <EvanR> + is just a function, and you can provide different implementations by using different (first class) functions. and the type class mechanism just provides a way to do it without passing functions around explicitly
11:46:41 <Cheery> EvanR: haskell doesn't have type promotion?
11:46:45 <EvanR> no
11:47:01 <Cheery> so to multiply a vector by scalar, what do you do?
11:47:07 <EvanR> there is no tower of number types, because they dont really form any sane ordering anyway
11:47:16 <Cheery> well.. that I found out.
11:47:27 <Cale> shapr: Mainly just that it's simple and fast, though if I wanted really pretty parse errors, megaparsec is better for that.
11:47:57 <Cale> It sounds a bit like megaparsec has been working on performance lately though :)
11:48:08 <jle`> Cheery: you'd use a function for multiplying scalars by vectors
11:48:11 <EvanR> Cheery: you could use a different operator, like scalar *. vector
11:48:15 <jle`> Cheery: like scale :: Scalar -> Vector -> Vector
11:48:47 <maerwald> Cale: if I want fast parsing, I do C
11:48:51 <dmwit> Or you'd give your vector a `Functor` (or similar) instance, and use `fmap (scalar*) vector`.
11:48:54 <jle`> or you could explicitly have a toVector :: Scalar -> Vector function
11:48:56 <geekosaur> Cheery, vector packages provide their own operators. The mathematical concept of addition is more general than you can capture in a type system while retaining usability of that type system
11:49:04 <EvanR> emotionally, scalar multiplication is different from regular multiplication
11:49:27 <EvanR> so deserves a different operator
11:49:35 <geekosaur> I mean, you could design such a thing but now yu have to pass aroudn type level proofs that what you are doing is valid, instead of using simpler constraints that can be checked automatically like making everything be the same type
11:49:35 <jle`> yes can you imagine all the bugs that would probably come up
11:49:54 <jle`> if scalar multiplication and vector multiplication were the same opeartor/function?
11:49:54 <geekosaur> it's a trade-off
11:50:13 <jle`> i don't have to imagine, because such bugs have bitten me several times in dynamically typed languages
11:50:24 <EvanR> all the bugs that come up when (everything) is called + :)
11:50:28 <dmwit> I hate Matlab for exactly this reason.
11:50:49 <jle`> also imagine how hard it would be to read *any* code
11:50:53 <jle`> that uses that operator
11:51:00 <jle`> you'd never know what operation is actually being used
11:51:02 <dmwit> So many bugs happening because it tried really hard to interpret my code as sensible when really what I wanted was a complaint "you can't do addition between vectors and matrices" or whatever.
11:51:06 <jle`> (again i don't have to imagine, i speak from experience :) )
11:51:14 <Cale> maerwald: ew
11:51:51 <Cale> maerwald: I can imagine generating C maybe, but eh, if you're going to go that far, maybe just use LLVM
11:51:58 <dmwit> EvanR: You know about the universal combinator(s)?
11:52:10 <maerwald> Cale: there are parser combinator libs for C
11:52:11 <EvanR> uh which ones
11:52:36 <maerwald> hammer for example, written by the LANGSEC guys
11:52:45 <Cale> Just because you can do something doesn't mean you should :)
11:52:47 <dmwit> EvanR: There's a handful of different ones. But the magic property of each is that it is a single, Turing-complete combinator.
11:52:49 <dsal> $ is really weird.  You start off thinking it's just magic for "( until the end", but then you section it.
11:53:02 <dmwit> EvanR: Your comment about "what if everything is called +" brought that to mind.
11:53:06 <maerwald> Cale: I was talking about performance
11:53:12 <EvanR> dmwit: in which case, you are encoding the program as the parentheses?
11:53:13 <Cale> dsal: It's just id, specialised to functions, with low precedence.
11:53:15 <dmwit> EvanR: You actually can have a language where everything is called + and still do computation...
11:53:23 <Cale> f $ x = f x
11:53:27 <EvanR> might as well just use the parentheses :)
11:53:31 <maerwald> if you want performance you *should* do C
11:53:33 <dmwit> yes, perhaps =)
11:53:43 <EvanR> i still dont understand unlambda
11:53:51 <EvanR> it has no parens
11:54:02 <dsal> Cale: Yeah. As I learn more haskell, the magic really starts to die down.
11:54:06 <Cale> maerwald: Well, C is sort of awkward, in that you'd usually rather generate it than write it, but it's not a very good compiler target language.
11:54:12 <geekosaur> just for example, stack langages don't need parens
11:54:20 <jle`> dsal: that's good news! :)
11:54:45 <Cale> maerwald: Almost anything I can imagine myself using C for, I'd probably rather just use LLVM.
11:54:53 <jle`> writing modern C is its own unique beast, though
11:55:02 <jle`> very different than the C you'd learn if you want to generate C
11:55:25 <jle`> it's the difference between living in a country vs. stopping by for a layover
11:55:55 <EvanR> generate C... just use globals and a tons of gotos in the main function? :)
11:55:58 <Cheery> EvanR: There's one thing I am kind of surprised about. It's what I found out in Go and Rust.
11:55:58 <jle`> i can imagine parser combinators being not-too-bad in a modern C
11:56:01 <maerwald> I haven written directly in llvm yet, so cannot comment
11:56:22 <pikhq> jle`: Rather awkward though.
11:56:37 <Cheery> EvanR: Go really ignores there's a need to extend meaning of '+'
11:56:38 <pikhq> There's a reason C programmers still mostly use parser generators.
11:56:46 <shapr> same for java
11:56:52 <pikhq> Even if the popular one, yacc, is *really* showing its age.
11:57:13 <Cale> C shouldn't even try to be a high level language, it's just hopeless in that regard.
11:57:14 <EvanR> Cheery: well, the classic way is to design the language with 2 or 3 kinds of +
11:57:14 <Cale> It was okay as a portable assembly language, but we have better things for that now
11:57:20 <jle`> it's not just because they don't want to learn functional programming?
11:57:52 <shapr> My C coding friends glaze over instantly when they look at Haskell syntax.
11:57:56 <pikhq> There's still precious few languages that even try to handle memory failure in a way that isn't just crashing.
11:58:08 <pikhq> ... *That said*, most C programmers don't do any better either.
11:58:16 <EvanR> OCaml smashed the tradition by having + mean only 1 thing, and +. mean the other
11:58:29 <EvanR> and you have to live with it
11:58:31 <EvanR> still
11:58:42 <Cheery> EvanR: well.. I already dropped in concatenation.
11:58:52 <maerwald> pikhq: what do you consider memory failure?
11:59:01 <EvanR> thats not even addition...
11:59:18 <pikhq> maerwald: OOM
11:59:27 <Cheery> EvanR: true, but you talk about 3 kinds of +
11:59:36 <EvanR> numeric addition
11:59:44 <maerwald> pikhq: so basically also memory leaks due to laziness
11:59:53 <pikhq> Wha?
12:00:16 <pikhq> No, I mean "computers are finite. Therefore, all memory allocation can fail. Most languages handle this by just crashing."
12:00:43 <maerwald> not sure that's a very interesting property to reason about
12:01:05 <EvanR> finite stuff is hard
12:01:14 <dmwit> pikhq: There's rarely anything more sane to do than crashing.
12:01:22 <Cheery> EvanR: in which way + can be split into three? If you ignore separating it for int+int, fract+fract, float+float as a solution.
12:01:30 <pikhq> dmwit: It seems important to be *able* to do something else.
12:01:35 <EvanR> Cheery: thats what im talking about
12:01:37 <maerwald> dmwit: yeah, because it means you failed your *system* architecture
12:01:50 <Cheery> EvanR: oh.. okay
12:02:01 <pikhq> I mean, the world isn't all "oh, it crashed, we'll spin up another dozen containers".
12:02:12 <EvanR> language designers chose their favorite additions and now you must live with them
12:02:14 <mud> pikhq: Important, but ... hard. Like what do you even do? Especially because most things you'd want to do are going to require allocating at least a bit more to deal with it.
12:02:23 <EvanR> and rename your new arithmetic operations something else
12:02:29 <EvanR> coolAdd(x,y)
12:02:30 <mud> It's also a *huge* pain to test.
12:02:33 <pikhq> mud: This is, indeed, the reason most language designers punt on it.
12:02:42 <Cheery> so one proposition to solve this is to not cram everything into a small box.
12:02:54 <pikhq> mud: Which means that if you *do* care about handling it, you're basically stuck with C.
12:03:03 <Tuplanolla> C is best used without `malloc`, which isn't hard at all.
12:03:22 <mud> pikhq: At least languages less abstract than haskell probably, yeah.
12:03:40 <EvanR> Cheery: in math, they regularly get the point across using + to mean all kinds of things, distinguishable by context. they dont bother attempting a globally unique name for everything
12:03:40 <pikhq> (okay, there are other languages that handle it. C's just a notable one.)
12:03:57 <pikhq> Not that I can really blame e.g. Haskell for not handling it.
12:04:19 <pikhq> It's basically not feasible in conjunction with its other design goals, after all.
12:04:20 <Tuplanolla> I, too, wish there was a language that offered that without being a big mess.
12:05:04 <EvanR> how much memory something will need, in general, is undecidable and anyway too concrete?
12:05:26 <EvanR> thats way in the back of the implementation
12:05:28 <Cheery> EvanR: I kind of see where the convention in Haskell's numbers may have come from. It's ML heritage with a nice idea of turning '1' into a representation for many things.
12:05:43 <shapr> test123123: got more questions?
12:05:45 <EvanR> is that what ML did?
12:06:05 <EvanR> i recall seeing custom addition as "add x y" everywhere
12:06:08 <Cheery> The 'a -> a -> a' type signature is from somewhere in that direction.
12:06:19 <pikhq> EvanR: This is more the sort of thing I get grumpy at Rust at, TBH.
12:06:39 <EvanR> OM?
12:06:41 <EvanR> OOM?
12:06:42 <mud> Is rust in the camp that pretty much just crashes?
12:06:46 <pikhq> mud: Yes.
12:06:53 <EvanR> thats... counterintuitive
12:07:01 <pikhq> Humorously, Erlang has a fairly decent answer to it. Processes can crash, but that's not your whole program.
12:07:08 <mud> That's somewhat unfortunate
12:07:08 <geekosaur> sad. I thought that was one of the things it was supposed to be providing a better answer for
12:07:22 <Cheery> I don't get a thing about Rust.. I also did look at how they solve this problem about arithmetic overloading.
12:07:29 <maerwald> crashing cleanly is safe
12:07:33 <maerwald> rust cares about safety
12:07:40 <test123123> shapr, thx that was all :)
12:07:44 <EvanR> so make sure everything you do is atomic
12:07:47 <EvanR> transactional
12:07:48 <Cheery> They try to cram traits into the set, and I can see it's not much better than multimethod dispatch.
12:07:54 <shapr> test123123: ok, feel free to ask more questions!
12:08:21 <mud> Cheery: They handle it pretty much like haskell does, no? (just different "typeclasses" for numbers)
12:08:59 <Cheery> anyway the gist of this all seems to be.. AVOID type promotion semantics.
12:09:10 <EvanR> automatic conversion
12:09:20 <EvanR> its very confusing to me
12:09:48 <EvanR> it sounds very much like "do what i want, but i dont know what that is"
12:10:16 <shapr> type towers are hard
12:10:32 <EvanR> if you put a float into an Int function... what does a sane person expect to happen?
12:10:42 <Cheery> hm.. could that be an useful rule for this all?
12:10:46 <maerwald> EvanR: crash :P
12:10:50 <EvanR> lol
12:11:22 <EvanR> or vice versa
12:12:07 <Cheery> EvanR: well the problem in here is that you would kind of want to convey that broad semantic meaning that '+' has in mathematics.
12:12:09 <maerwald> I am thinking about a compiler that just crashes on type errors instead of giving actual information
12:12:15 <EvanR> Cheery: ... which is?
12:12:29 <EvanR> by broad meaning, do you mean vaguely defined meaning
12:12:36 <Cale> Javascript quiz: parseInt(null, 10) = NaN. What is parseInt(null, 30)? How about parseInt(null, 31)?
12:13:02 <Cheery> EvanR: when the symbol is chosen, it is chosen for a reason.
12:13:17 <EvanR> haskell is cool for asking you to think about these things seriously
12:13:28 <Cheery> you have bunch of symbols to use, even textual names, when you pick '+', why do you pick it?
12:13:29 <EvanR> questioning your prejudices
12:13:30 <mud> Cale: That's a good one xD
12:13:49 <pikhq> EvanR: Probably that. It'd be nice if it meant a specific thing on something very abstract (say, the abstract algebra notion of an associative and commutative operation on a set), but...
12:14:04 <Cheery> EvanR: that's a definitely cool feature about Haskell.
12:14:09 <pikhq> Pity IEEE floats don't quite meet that.
12:14:49 <EvanR> addition is assoc and commutative when it appears, yeah. floats violate one of those
12:14:57 <EvanR> if you dont need commutative, theres Monoid <>
12:14:58 <Cale> associativity
12:15:22 <Cale> (floating point arithmetic is commutative, but that's basically it)
12:15:57 <EvanR> besides those properties im not sure what the commonality of all usages of + is
12:16:05 <Cheery> EvanR: the problem why I ended up to think about this again is in vector types.
12:16:13 <pikhq> (to be fair, though, that's probably unavoidable without omitting the properties of it that make it actually *nice* for numerical computatation)
12:16:20 <EvanR> or if there are some which are wildly not like addition, but still assoc and comm
12:16:35 <Cheery> EvanR: I extended my floating point three-element vectors into parametric vectors, in my language.
12:16:41 <EvanR> pikhq: i wonder if unums could do better here, in terms of laws
12:16:51 <ksdjfig> jle`: is there something *wrong* with parsec, or just that there's not much active development?
12:17:22 <Cheery> EvanR: then I went to think what addition means now.
12:17:27 <Tuplanolla> It's been deprecated in favor of Megaparsec, ksdjfig.
12:17:30 <Cheery> that was an error.
12:17:45 <Cheery> if you want to avoid thinking that is.
12:18:00 <EvanR> Cheery: in another language, you could define a vector type indexed by its size... Vect :: Nat -> Type -> Type.  Vect 3 Float for instance
12:18:29 <ksdjfig> Tuplanolla: Is that true? I don't see a deprecation notice on hackage or github.
12:18:40 <EvanR> actually, at some point that language will be Haskell :)
12:18:58 <Cheery> EvanR: well.. I didn't do it yet, but I plan introducing this kind of way to use vectors in my language: ivec3 = vec(int, 3); ivec3(1, 2, 3)
12:19:18 <Cheery> EvanR: but that really threw a wrench into my multimethod dispatch.
12:19:28 <EvanR> you can do that in idris almost exactly
12:19:38 <EvanR> IVec3 = Vect 3 Int
12:19:42 <maerwald> EvanR: at that point I'll finally give up on haskell... I mean *GHC*
12:19:47 <greymalkin> Using cryptonite: I need to read a client-generated public key, (ECC, but not 256R) to verify messages -- but can only find a 'pointFromBinary', for 256R -- am I missing something?
12:19:55 <EvanR> maerwald hates dependent types!
12:20:10 <maerwald> EvanR: no
12:20:20 <maerwald> I explained it probably 2 times for you ;)
12:20:21 <ksdjfig> http://hackage.haskell.org/package/microstache is an example of a new library which actually forks to switch *from* megaparsec *to* parsec
12:20:32 <maerwald> I care about properly designed languages
12:20:32 <EvanR> im kidding
12:21:17 <maerwald> which is also why I find it sad that rust will not have a spec for a very long time
12:21:25 <bitemyapp> Same
12:21:30 <maerwald> at the point it gets one... it might be too late
12:21:37 <bitemyapp> Yeah.
12:21:40 <EvanR> standard rust
12:21:43 <bitemyapp> maerwald: what are some language specs you like?
12:21:51 <maerwald> haskell? :>
12:22:18 <maerwald> Java is actually not that bad either I've heard, but haven't actually read it
12:22:42 <bitemyapp> maerwald: you like the Haskell Report?
12:22:49 <maerwald> sure
12:22:55 <bitemyapp> I really liked the JLS but found the Report to be not very useful
12:24:09 <maerwald> I like java a lot actually... the typesystem is nice, I like the exception system, the extensibility
12:24:13 <maerwald> I just don't want to program java xD
12:25:02 <user3382> hi
12:25:09 <user3382> does anyone here develop languages?
12:25:56 <user3382> not as in write for languages but write languages such as haskell themself
12:27:41 <EvanR> that is very likely
12:27:50 <EvanR> Cheery: do you know about dictionary passing?
12:28:24 <nshepperd_> Haskell spec is great except for the parser rule about "insert a closing brace if leaving it out would cause parse error"
12:29:28 <user3382> are any of the haskell devs here
12:29:38 <tdammers> define "the haskell devs"
12:29:54 <Cale> nshepperd: Wadler's law :)
12:30:04 <user3382> people who wrote the haskell language specification and implementation
12:31:32 <Cale> Simon Marlow is in #ghc as JaffaCake
12:32:25 <Cale> Though I'm not sure if he was involved in the Report
12:32:38 <Cale> Sometimes Lennart Augustsson is here
12:32:47 <Cale> (usually as augustss)
12:33:43 <Cale> oh, Simon Marlow was involved on the 2010 report :)
12:33:47 <Cale> He was the editor
12:33:54 <user3382> Cale
12:33:58 <user3382> https://imgur.com/l14m1li thoughts?
12:34:33 <user3382> I would link the google doc of it
12:35:27 <Cale> user3382: The niche that C would rightly fill in my mind makes LLVM a killer for it.
12:35:29 <Tuplanolla> Here's the checklist: http://colinm.org/language_checklist.html
12:35:43 <user3382> I want to kill c
12:35:55 <Cale> It's already doing a pretty good job of that on its own
12:36:21 <user3382> kind of, but most of the languages which have arisen to replace it inherent the semantics of c
12:36:21 <maerwald> user3382: there is already D, llvm, rust, ...
12:36:26 <user3382> which, hear me out
12:36:35 <Cale> But yeah, if we're talking about compiler target languages, LLVM is pretty much the go-to thing.
12:36:42 <user3382> the semantics of C are the biggest problem with it, in my opinion.
12:36:46 <Cale> yes
12:37:11 <user3382> It's not what C can do or can't do, it's how much the code resembles gibberish until that neural network dedicated to understanding it in your brain kicks in
12:37:18 <user3382> and that network tends to be pretty big and pretty inefficient
12:37:21 <Cale> It's trying too hard to be a high level language which you'd write source code for by hand, while at the same time avoiding all the things which would make that nice.
12:37:36 <Cale> That's an awkward position to be in, and that makes it not very good at anything.
12:37:38 <maerwald> parametric polymorphism :/
12:37:49 <user3382> Are you talking about the imgur link or about C ?
12:37:56 <Cale> I'm talking about C
12:38:18 <user3382> oh well please, forget about the problems with C and read the document I wrote.
12:38:20 <user3382> or part of it, anyway.
12:38:56 <hydraz> I'd read it, but you decided to upload text-heavy images as jpegs and now they're screwed
12:38:58 <maerwald> you might get more prominent answer to post such a thing on the haskell-cafe mailing list maybe (in an appropriate format)
12:39:32 <Cale> user3382: Implicit conversions are awful.
12:40:24 <Cale> (whether in a high level or low level language, dynamically or statically typed, they just turn mistakes into subtler ones which bite you when you least expect it)
12:41:07 <Cale> user3382: Is the goal of your language to be a target for compilers?
12:41:28 <Cale> I don't see a lot of the things I would expect appproaching things from that direction.
12:43:08 <user3382> https://pastebin.com/bJ8QvWLH checklist filled out
12:43:10 <user3382> no cale
12:43:35 <user3382> i dont know why you immediately jumped to talking about compilers, llvm, and non-human comprehensible language
12:43:51 <user3382> Because i did not imply at any time i was going to talk about one of those thins
12:43:56 <Cale> user3382: Because that's mainly what C is good at
12:43:59 <Tuplanolla> This checklist worries me greatly.
12:44:15 <user3382> hydraz:  I can link the google document.
12:44:26 <hydraz> user3382: You seem to have reinvented PHP, but somehow worse.
12:44:33 <Tuplanolla> You want to, for example, combine implicit type conversions with dependent types.
12:44:44 <user3382> https://docs.google.com/document/d/1WvagoCqr1YOEzTgJBfjS4rQcNMKRWazMRC2DRXLwoAM/edit?usp=sharing
12:44:46 <maerwald> hydraz: that's a little bit too harsh, surely... there is nothing worse than PHP :P
12:45:27 <Cale> user3382: C is okay as a sort of portable assembly language for compilers to target if they want to be able to generate code for many different platforms, because it's sort of low-level and it has implementations on every platform under the sun.
12:45:29 <user3382> C used to be good at everything. Now it's not, and why it's not.. well.. that's what we're talking about :D
12:45:37 <user3382> forget about C
12:45:42 <dsal> Does anyone use literate haskell?  I found it kind of nice back when I was doing project euler stuff a bit.
12:45:45 <Cale> user3382: C was always annoying and awful to write by hand.
12:46:02 <hydraz> user3382: "[X] implicit type conversion [X] dependent types" what?
12:46:04 <Tuplanolla> It's nice when you know what you're doing, dsal.
12:46:14 <Cale> That didn't stop people from doing it, but it didn't mean that it was a good idea for them to do so :)
12:46:16 <Tuplanolla> That doesn't happen often.
12:46:16 <hydraz> dsal: I use it for writing posts sometimes
12:46:49 <cocreature> user3382: if you need to check “without justification” and “unsupported” then maybe you should go back and try to justify your claims
12:46:50 <hydraz> bird style, with prose written in (as?) pandoc markdown
12:46:59 <Cale> Often it was the only choice because language implementations were scarce on early platforms
12:47:03 <hydraz> heh, I should fill out the checklist
12:47:20 <user3382> cocreature: that document is a joke doc thou..
12:47:21 <Cale> and then it got picked just because other, earlier things were written in C
12:47:36 <user3382> hydraz:  yes, both implicit type conversion and dependent types.
12:47:56 <user3382> For example: object(requires object as string);//cannot be called with a non string
12:48:10 <user3382> object(expects object as string);//will attempt a conversion.
12:48:35 <Cale> user3382: If you're going to write that, why not just write the conversion?
12:48:53 <user3382> listen, and listen good, before i call you one of many different possible cuss words just because i feel like it.
12:48:58 <user3382> I am a frustrated programmer and you are too.
12:49:05 <geekosaur> ...
12:49:08 <user3382> I channeled ALL of my frustration into this document and it is a product of that.
12:49:26 <Cale> I'm not that frustrated, I write Haskell in my day job :)
12:49:32 <user3382> There is a reason for everything i have included here. Making excuses for not doing so like (so well not do X) makes edge cases more convoluted.
12:49:49 <user3382> We want to cover the broadest possible set of reasonable situations in the specification, so that most code is simple to write.
12:49:52 <hydraz> ...
12:49:53 <Cale> I get to develop web applications with functional reactive programming and strong static types :)
12:49:56 <cocreature> go to bed and come back when you’re less frustrated
12:49:56 <geekosaur> fine, weve established your opinions are by definition as important as anyone else's facts.
12:50:06 <maerwald> Cale: except web applications suck
12:50:12 <user3382> The way that I wrote this is to express the conversion as a property of the object.
12:50:20 <shapr> oh wow, proto-lens has prototbuf3 support, I can use this at work!
12:50:21 <Cale> maerwald: Eh, it can be pretty fun when you're writing them in Haskell :)
12:50:26 <hydraz> hmm
12:50:29 <user3382> You're STILL thinking in C.
12:50:30 <chessai> Cale: I do the same thing, with reflex-dom
12:50:42 <Cale> chessai: yep, reflex-dom here too :)
12:50:43 <maerwald> Cale: I'd rather do that in Go, less framework cancer
12:50:44 <cement> writing webapps in haskell is really nice
12:50:47 <Cale> (I work for Obsidian)
12:50:50 <user3382> Even when you're coding in haskell, you're thinking in C, and to me, that's convoluted. Why not think in cobol or ruby or python?
12:51:01 <Cale> user3382: I think in Haskell.
12:51:01 <chessai> maerwald: You probably haven't tried reflex-dom
12:51:10 <cement> I think in C? I don't even *know* C
12:51:24 <Cale> user3382: Actually more often, I think in mathematics, and write Haskell.
12:51:25 <maerwald> chessai: I just said *framework cancer* and you say "reflex-dom"...
12:51:26 <maerwald> ok.
12:51:32 <user3382> Why say write the conversion when the act of converting is casting?
12:51:42 <chessai> maerwald: define "framework cancer"
12:51:45 <user3382> object1 is object2 as int;//explicit cast to int
12:51:47 <Cale> maerwald: You don't like reflex-platform?
12:51:55 <cement> because being explicit makes you sure of what you're doing
12:52:08 <user3382> My language has implicit as well as explicit typing
12:52:13 <Cale> maerwald: It's sort of annoying, I'll admit, but the mobile stuff really makes it necessary.
12:52:33 <cement> being forced to be explicit means you're far less likely to do something horrific
12:52:35 <user3382> You can both write "define stringexampleobject as string" and also "definestringexampleobject is "stringcontents"
12:52:50 <Cale> maerwald: The setup for cross compilation for Android and iOS is just not something you want to have to go through yourself, so we needed to have some way to encode it all once and for all.
12:52:58 <cocreature> Cale: I wish the reflex devs were a bit better at doing hackage releases so people at least had a chance of not using reflex-platform if they don’t care about mobile stuff
12:53:23 <maerwald> Cale: I like to combine simple functionality to something bigger. While haskell is very well suited for "combining functions"... doing so on library level is a lot less common, because people have this thing where they want to solve everything with a huge DSL, a witty framework or a library with so specific over-engineered types that you cannot possibly combine it with something else
12:53:29 <maerwald> without using everything else from the same author
12:53:35 <shapr> user3382: is your language implementation on github?
12:53:40 <Cale> cocreature: Yeah, I think Ryan might be gearing up for another release? I agree they could be a little more often.
12:53:55 <chessai> cocreature: http://web.mit.edu/greghale/Public/reflex/html/reflex/index.html
12:54:10 <chessai> cocreature: http://web.mit.edu/greghale/Public/reflex-dom-new/html/reflex-dom/index.html
12:54:19 <Cale> maerwald: Well, I'm not sure I agree that reflex can't be used in other ways :)
12:54:24 <maerwald> Cale: this isn't actually a language property, more of a ecosystem one
12:54:29 <cocreature> chessai: so? the last hackage release was > 1.5 years ago
12:54:37 <cocreature> and there has been a ton of development since
12:54:43 <Cale> maerwald: I know we've yet to really prove it, but eventually we expect to have reflex-sdl and reflex-gl and so on.
12:54:54 <hydraz> user3382: Type inference for dependent types is very undecidable
12:54:58 <user3382> shapr you wish
12:55:00 <chessai> cocreature: I know, I'm just letting you know that I use these when working with the most recent dev version of reflex
12:55:10 <shapr> user3382: be nice
12:55:12 <Cale> maerwald: and reflex-dom itself, I'm not sure it's worth splitting it into smaller packages?
12:55:17 --- mode: ChanServ set +o shapr
12:55:27 <chessai> cocreature: they should definitely do what you suggested, but for the time being these links are helpful
12:55:29 <user3382> I'm sorry, but i'm one of those people who understand programming just well enough to be frustrated with it. You may think that makes me underqualified to talk about language design, but i think it gives me an edge.
12:55:48 <user3382> I can see the mental convolutions that an experienced dev won't, and I see them as frustration.
12:55:55 <maerwald> Cale: my point is... most languages/ecosystems (including rust, really) try to solve web development with frameworks
12:56:06 <shapr> user3382: so, implement your language?
12:56:16 <user3382> I havn't written an implementation. I would absolutely be overjoyed if someone were to consider implementing it on any platform.
12:56:18 <cocreature> chessai: oh sure, you can definitely find your way around. I just would hope that it would be a bit easier :)
12:56:25 <Cale> user3382: Most languages out there are designed by people who thought their lack of knowledge about programming language theory gave them an edge in designing a new language ;)
12:56:35 <maerwald> Go kind of doesn't need it and web frameworks are actually frowned up, although they do exist... which is kind of refreshing
12:56:46 <Cale> user3382: But yeah, go for it and implement your language, if nothing else, you'll learn something :)
12:56:48 <shapr> user3382: I think you'll have to implement it yourself, that's the only way I've seen new languages get created.
12:56:53 <user3382> That's not true cale. Most languages out there were written by C coders trying to do something with less work.
12:56:56 <hydraz> user3382: Programming language implementation is a very hard thing to do, especially at a low level like you're trying to; You definitely come off as unqualified, and will probably end up creating PHP^WGo 2.0
12:56:57 <shapr> Same for business ideas, learn to code and make it happen.
12:57:03 <maerwald> I think this might be related to the async properties
12:57:25 <user3382> Don't be a collective of negative nancies. I shared my thoughts, and all you've reflected is criticism.
12:57:26 <cement> I'm a fan of rust for lower level stuff
12:57:28 <maerwald> e.g. async in rust is hard, so they have to hide the complexity in frameworks
12:57:30 <Cale> maerwald: Well, we don't do any of the boring stuff that web frameworks usually do
12:57:44 <cement> criticism isn't always a bad thing
12:57:52 <maerwald> async in Go is easy, so there is nothing really that needs to be hidden
12:58:09 <maerwald> then again, abstraction capability are non-existent :>
12:58:10 <Cale> maerwald: Are you talking about Go -> Javascript compilation?
12:58:13 <EvanR> hiding is good, when it completes the hiding process
12:58:21 <Cale> maerwald: Or backend-only stuff?
12:58:23 <user3382> I don't want to learn C or languages like C. The entire point of this language which I am trying to define is to express that those things which need to be learned to implement it, which make C and other languages complicated, are what make those languages bad, and those things also manage to make their way into new languages.
12:58:25 <maerwald> Cale: rather backend
12:58:58 <maerwald> C is not complicated
12:59:00 <EvanR> user3382: things which make languages less complicated can be very complicated to implement, unfortunately
12:59:03 <Cale> maerwald: Okay, well, I kind of think the Haskell libraries for backend web development are reasonably modular. They're organised into frameworks, but they don't usually need to be used like that.
12:59:05 <user3382> You want to try some test code to see what it would do, well, I am the implementation. I am the interperter and the compiler.
12:59:16 <shapr> user3382: You could implement your language in almost any language, pick one and implement it?
12:59:28 <user3382> sigh
12:59:39 <user3382> yes, but all the languages i look at are part of the problem
12:59:50 <user3382> they all functionally rely on C to bootstrap their first implementation
12:59:55 <Cale> maerwald: There's very little which prevents anyone from mixing and matching stuff from Snap and Happstack, Scotty, and even Yesod (though Yesod is more opinionated than the rest, even it's pretty well broken up into parts)
13:00:16 <maerwald> Cale: broken is the right word there, haha
13:00:20 <Cale> haha
13:00:22 <cement> well yeah, C is about as close as you can get to hardware without being either bit-bashing or writing assembly
13:00:22 <shapr> There exist many self-hosted languages that do not compile via C
13:00:23 <user3382> and if I learned C to kill C, i'd spend the next two decades wasting my time with something literally a million people already know better than me
13:00:29 <EvanR> the only thing you "need" C for is the bits that connect to the OS, and even though you dont really need C
13:00:31 * raichoo fetches popcorn
13:00:37 <shapr> raichoo: haha
13:00:42 <hydraz> ooh, good idea
13:00:43 * johnw just finished some popcorn
13:00:47 <EvanR> even then
13:00:50 <Cale> user3382: Do you know Haskell? Learn Haskell to kill C.
13:00:58 <maerwald> well, but even with Snap you don't really handle async manually, so you still are fairly "high-level" there, right?
13:01:00 <shapr> user3382: perhaps this discussion belongs on #haskell-offtopic? this isn't about Haskell
13:01:18 <maerwald> so Go is kinda more low-level, without actually being more complicated, imo
13:01:21 <johnw> shapr++
13:01:29 <Cale> user3382: If nothing else, most people can agree that Haskell is a pretty damn good language to write compilers in.
13:01:39 <chessai> ^
13:01:41 <cement> parsing is so beautiful
13:01:46 <johnw> having worked on compilers in Haskell, very much agreed
13:01:54 <hydraz> oh, definitely
13:02:07 <raichoo> yup, building compilers in Haskell is fun ^^.
13:02:13 <user3382> well, yea, That's kind of why i'm here. I like what i see in haskell enough to steal some of it.
13:02:15 <shapr> user3382: If you want to learn Haskell, this is the venue, but if you want to discuss building your own language, please move the discussion to #haskell-offtopic
13:02:23 <shapr> user3382: oh good!
13:02:34 <shapr> user3382: I like haskellbook.com
13:02:38 <cement> ^^^
13:02:54 <user3382> I was wanting feedback from haskell developers how to improve the reference to make a better language with regards to semantics
13:03:06 <user3382> with a prospect for a future of a language implemented in haskell
13:03:08 <Cale> user3382: At the same time, it's a very inspiring language in terms of what features it has already. When I started out learning Haskell, I was constantly thinking "oh, someone should make an imperative language with such and such Haskell feature", until eventually I realised that they already did, and that language is also called Haskell.
13:03:11 <user3382> I will take that discussion to haskell-offtopic
13:03:16 <shapr> user3382: thank you!
13:03:20 <maerwald> Cale: mars!
13:03:37 --- mode: shapr set -o shapr
13:07:37 <shapr> Is anyone doing protobuf3 in Haskell?
13:09:23 <codeshot> Hi, I have a Parsec parser and I want to weave an interpreter through it so it parses, interprets and can fail accordingly at each marker for end-of-statement ('\n' or ';' perhaps). Can I do that without changing the parser ?
13:09:26 <jxv> shapr, are you looking for an IDL?
13:09:43 <codeshot> shapr, Woah, still around after all these years ?
13:09:50 <shapr> aw man, busted
13:09:54 <shapr> codeshot: how many years has it been?
13:10:02 <codeshot> 10 or more
13:10:12 <codeshot> Perhaps I was maihem or PonderStibbons then
13:10:16 <shapr> oh right
13:10:22 <shapr> now I remember you
13:10:38 <shapr> good discworld references
13:11:10 <shapr> now I have to go hide for a few months :-P
13:11:42 <codeshot> This is so I can have a full file parse or an interactive shell with the same syntax
13:12:09 <codeshot> or even a coders REPL, all parameterised
13:12:20 <EvanR> you could parse each line separately?
13:12:33 <codeshot> That doesn't get good full file parsing
13:12:35 <EvanR> use the statement parser instead of the full file parser (because its split up right??)
13:12:52 <codeshot> My syntax is non-traditional it seems
13:13:05 <codeshot> so it's using mostly primatives
13:13:32 <codeshot> Can I use a combinator to modify the parser from the outside?
13:13:42 <codeshot> or the monadic return type?
13:14:27 <maerwald> megaparsec is a transformer
13:14:58 <maerwald> oh, parsec is too
13:15:43 <codeshot> I'm not so familiar with transforming monads so I wonder if someone can tell me if that's a neat way to get the kind of variety of behaviours using composition instead of parameters
13:15:57 <codeshot> so I know whether to study it hard or not
13:18:41 <codeshot> In a sense I suppose I want to render the parser state all the time as an alternative complete parse, transform it if it's valid and discard it if not. and have a compile failure if any alternative parses would have been possible which don't finish a statement at the same point.
13:18:50 <tdammers> monad transformers are a pretty common architecture
13:18:54 <tdammers> if that's what you're asking
13:19:11 <codeshot> No this is: " I have a Parsec parser and I want to weave an interpreter through it so it parses, interprets and can fail accordingly at each marker for end-of-statement ('\n' or ';' perhaps). Can I do that without changing the parser ?"
13:19:16 <EvanR> parsec doesnt let you do incremental parsing
13:19:38 <codeshot> ok, thanks
13:20:01 <codeshot> Out of interest, what is it about the Parsec types that means it's not possible?
13:20:34 <EvanR> once you start a parsing, it completes with either "passed" and its over, or "failed" and ... its also over
13:21:00 <geekosaur> attoparsec might be of interest though
13:21:35 <codeshot> I don't think attoparsec isn't good for this kind of parse. I recall it's good for binary file formats
13:21:54 <EvanR> attoparsec also works on Text and String now, which i find a lot easier to use than parsec
13:22:12 <EvanR> but it does have worse failure messages
13:24:23 <nshepperd_> I reckon you could make parsec do incremental parsing by implementing an appropriate  Stream instance for a monad and using ParsecT
13:24:32 <nshepperd_> But I've never actually bothered to try
13:26:51 <tdammers> for limited cases, you can abuse lazy evaluation to turn parsec into an incremental parser of sorts
13:31:20 <codeshot> tdammers, thanks
13:31:24 <shapr> tdammers: that's neat, do you know of any code that does that?
13:31:51 <tdammers> I've done it myself for some quick hack jobs
13:32:00 <codeshot> Does it turn hacky?
13:32:05 <tdammers> quite
13:32:16 <Cheery> EvanR: I don't know what dictionary passing is.
13:32:53 <tdammers> the idea is that you set up a lazy input stream that you can interact with, and then you have some sort of ParsecT over IO that evaluates and outputs things as it goes
13:32:58 <nshepperd_> Basically, uncons s = Cont (\k -> Ask s k)
13:33:07 <codeshot> oh, like a fixedpoint?
13:33:11 <codeshot> hm
13:33:24 <codeshot> I will think. It might be possible without hackery
13:33:49 <nshepperd_> With your usual incremental parsing datatype being Ask s k | Done a
13:34:28 <ksdjfig> Is there a "simplest" parsing library? Like whose code is most uncomplicated?
13:34:33 <tdammers>  for anything serious I'd really use some parsing library that supports proper incremental parsing
13:34:48 <pharaun> attoparsec?
13:34:51 <nshepperd_> So whenever the parser asks for another character, it returns with Ask and you feed in text in the usual way
13:36:48 <codeshot> I can't help thinking that I should be able to lift an outer monad where I can claim "end-of-statement" to keep the hacks to a minimum with only a very small change to the parser.
13:37:00 <nshepperd_> It's a bit weird that parsec has this whole monadic Stream thing that nobody uses
13:37:09 <codeshot> I plan to
13:37:54 <codeshot> Currently I just give it a string but I want to give it a SourceFile value containing details about where it came from, etc.
13:38:41 <codeshot> so error messages can be really neat, and customised to using the language embedded in an App so instead of a file name I can report a web page, or even a graph of some code's provenance
13:51:11 <jle`> ksdjfig: there are some bugs too if i recall correctly
13:52:09 <royal_screwup21> I'm trying to pad a string to a given n. Supoose n =3 and string = 1 -> 001. Or n =3 and string = 01231 -> 1231. Here's my function: https://thepasteb.in/p/Y6hk2r0rA0Df7 The compiler spews an error though: https://thepasteb.in/p/qjhLjq4qDR7UB I'm not sure where I'm going wrong - I'd love a pointer or two in the right direction :)
13:52:57 <royal_screwup21> wait, for the second example: if n =3 and string = 01231, then my output is 231***
13:53:10 <jle`> royal_screwup21: it'd be helpful to give your top-level functions type annotations
13:53:38 <jle`> in any case, what do you think 'pad string xs n' is supposed to be?
13:53:46 <jle`> or pad '0' : string n, for that matter
13:54:55 <royal_screwup21> so I want it take in a string and an int, then return a string. So: [char] -> n -> [char]?
13:55:56 <jle`> [Char] -> Int -> [Char] you mean?   (or String -> Int -> String)
13:56:09 <royal_screwup21> yup
13:56:29 <jle`> alright, so do you see why 'pad string xs n' doesn't make sense?
13:56:41 <jle`> 'pad' takes two arguments, but why are you giving it four?
13:58:24 <royal_screwup21> pad '0' : string n -- I thought this was applying 'pad' on a string (with 0 prepended to it) and n - so 2 arguments
13:59:45 <royal_screwup21> oh
13:59:59 <royal_screwup21> yes I see what you mean
14:00:15 <royal_screwup21> thanks!
14:01:53 <Cale> royal_screwup21: If there's one thing to remember about infix operators in Haskell it's that function application (whitespace) binds more tightly than any infix operator can
14:02:20 <jle`> royal_screwup21: pad '0' : string n is (pad '0') : string n
14:02:21 <Cale> royal_screwup21: So  f x * g y  is always going to be  (f x) * (g y), regardless of which operator the * is
14:02:26 <jle`> er, (pad '0') : (string n)
14:02:47 <royal_screwup21> ouch
14:03:21 <royal_screwup21> pad ('0' : string) n  -- this should hopefully work then
14:37:01 <michowski> Hello everyone. I'd like to ask why I can't use Traversal' from lens library like this: Either String (Traversal' J.Value J.Value). It gives me: Illegal polymorphic type: Traversal' J.Value J.Value       GHC doesn't yet support impredicative polymorphism     • In the type signature:         traverseJson :: JsonPathSegments                         -> J.Value -> Either String (Traversal' J.Value J.Value)
14:37:41 <jle`> michowski: Traversal' is a type synonym of something that is illegal to put in a type constructor
14:38:07 <jle`> in particular, you can't use a RankN type as a parameter to a type constructor
14:38:12 <Gurkenglas> You can use ATraversal' or LensLike' with a single specified Applicative
14:38:52 <Gurkenglas> You can also use a version of Either that is constructed from (->), if you're using RankNTypes
14:39:15 <michowski> Thanks. I can not really find any information on what is ATraversal.
14:39:24 <jle`> http://hackage.haskell.org/package/lens-4.15.4/docs/Control-Lens-Traversal.html
14:39:39 <jle`> or also you can fidn it in the lens package index :)
14:39:42 <Gurkenglas> Which would replace Either String (Traversal' J.Value J.Value) with (String -> a) -> (Traversal' J.Value J.Value -> a) -> a
14:40:04 <Gurkenglas> or via http://hayoo.fh-wedel.de/?query=ATraversal%27
14:40:19 <jle`> EIther String (ATraversal' J.Value J.Value)
14:41:05 <Gurkenglas> Though, looking at it, "When you see this as an argument to a function, it expects a Traversal." is pretty bad documentation.
14:41:09 <michowski> Damn, I was looking at ATraversal and not ATraversal'. Thank you.
14:42:02 <jle`> alternatively depending on what you really want, you can just your function return Traversal' J.Value J.Value, and the 'Left' case could be an empty traversal
14:45:50 <Gurkenglas> Why doesn't RankNTypes allow polymorphic types in any data type that wasn't constructed as a GADT? After all, sum and product types can be constructed via (->) and then handled by RankNTypes.
14:47:28 <lyxia> @let data Y = Y (forall a.a)
14:47:30 <lambdabot>  Defined.
14:47:43 <lyxia> That looks allowed
14:47:54 <zenspider> is there a local/offline doco solution? I'm about to spend 3-4 hours on a train
14:48:55 <lyxia> like, local haddocks?
14:49:26 <Gurkenglas> lyxia, I mean "Either Int (forall a. Show a => a)"
14:49:37 <zenspider> I guess? preferably something with search as I'm still in discovery mode
14:49:54 <lyxia> Gurkenglas: What does that have to do with GADTs
14:49:56 <zenspider> I'm used to racket and ruby and having nearly everything local and searchable
14:50:26 <Gurkenglas> lyxia, nothing, therefore it should be handled by RankNTypes, as "(Int -> b) -> (forall a. Show a -> b) -> b" is.
14:51:10 <geekosaur> Gurkenglas, I think because it needs to include a dictionary in there, so it needs more of a 'handle' on it?
14:52:48 <lyxia> I think type inference is the main issue with impredicativity. Perhaps there is something else?
14:53:34 <Gurkenglas> lyxia, if there is no type inference problem with combinations of (->), then there cannot be a type inference problem with combinations of (->), (,) and Either
14:54:13 <Gurkenglas> geekosaur's line sounds like the beginning of an actual explanation though :D can you elaborate on that?
14:55:23 <geekosaur> not really, I know some things at that level but not much. the key pont is that the problems start rolling in when you proceed from the conceptual level you'e been poking at, to the implemtation level
14:56:00 <geekosaur> hypothetically a system could be desfigned without these, but it would be much more complex and a LOT slower
14:56:08 <Gurkenglas> implemtation level, my nemesis ;_;
14:56:14 <geekosaur> and nearly impossible to debug
14:56:44 <jle`> Gurkenglas: i seem to remember that it isn't necessarily a theoretical limitation, but rather an implementation thing
14:56:57 <jle`> as in nobody working on ghc has gotten around to properly implementing it
14:57:35 <jle`> oh geekosaur just said the exact same ting
14:57:39 <geekosaur> heh
14:58:17 <Gurkenglas> Hm. What's the most pop-science buildyouahaskell that implements RankNTypes? or is there a better way to poke at trying to solve this
14:58:49 <jle`> how i imagine it in my head is that it's not that bad to implement but nobody has decided to do it yet
14:58:58 <geekosaur> anyway it's not quie what jle` says either, because even designing an implementation that handles this is difficult. wheras the current solution satisfies 99% of the problems people run into, while being relatively easy to implement
14:58:58 <michowski> How can I make a Traversal' from ATraversal'? Docs of lens doesn't help me too much.
14:58:59 <jle`> this is probably not accurate
14:59:07 <geekosaur> the good is the enemy of the perfect, etc.
14:59:10 <jle`> michowski: you can use cloneTraversal
14:59:24 <michowski> Thank you
14:59:26 <jle`> michowski: you're right it's a little tricky, the type signature is ATraversal s t a b -> Traversal s t a b
14:59:48 <jle`> usually i just CTRL+F ATraversal (or whatever type i'm looking at) to find functions that work with it
15:00:19 <Gurkenglas> http://hayoo.fh-wedel.de/?query=ATraversal+s+t+a+b+-%3E+Traversal+s+t+a+b <- but i cheated, I looked up cloneTraversals type signature then searched for it
15:00:43 <jle`> well the function you're looking for has type ATraversal' s a -> Traversal s a
15:00:50 <michowski> Thank you. I was actually looking for "ATraversal'" and thus I had 0 results
15:01:07 <jle`> so i guess the mental jump is looking for ATraversal s t a b -> Traversal s t a b instead
15:01:15 <jle`> yeah that's one of the weird things about type synonyms
15:01:19 <Gurkenglas> Which hayoo should make unnecessary
15:01:22 <jle`> it breaks how i search for things, heh
15:01:27 <zenspider> so no local docs?
15:01:43 <Gurkenglas> You can build hoogle on your machine
15:02:05 <geekosaur> zenspider, you can configure to build local docs, and stack should even detect this and download  local docs for the stackage snapshot you are using
15:03:07 <geekosaur> install haddock and hoogle locally, there's a ~/.cabal/config knob 'enable-documentation: true' and cabal will then build docs and doc indexes for everything. stack should have equivalents but I don;t know them
15:03:25 <geekosaur> you also need to make sure however you installed the compiler and core libraries installed docs
15:03:51 <geekosaur> (for a system package manager this is often separate packages from the compiler and libs themselves)
15:04:40 <zenspider> oh my god... so many dependencies
15:05:02 <geekosaur> (and sure enough, if I insall ruby fro a package manager I have to install additional packages to get the docs you expect out of the box)
15:05:40 <zenspider> for a LINUX package manager... sure... but you're fighting dogma at that point. plain ruby out of the box has working doco
15:05:56 <zenspider> (same with racket)
15:06:05 <zenspider> I'm just impressed with how much is needed to install hoogle
15:07:57 <zenspider> aaaalll the crypto... multiple loggers... socks?!? really?
15:08:02 <zenspider> (do people still use that?)
15:08:07 <glguy> hoogle?
15:08:24 <glguy> I'm not sure how common it actually is
15:08:38 <glguy> for people to install it locally and use it
15:10:21 <Gurkenglas> How do I even find out how to find out where RankNTypes is defined? ._.
15:10:49 <MarcelineVQ> defined in what sense?
15:11:20 <Gurkenglas> Implemented, right.
15:11:52 <MarcelineVQ> I ​mean are you looking for ghc code?
15:13:12 <zenspider> fantastic... `hoogle map` seems to work w/ prelude and others. and I should have it hooked into emacs now. thanks!
15:17:34 <codeshot> When I run a parsec parser in the list monad instead of the identity monad I just get a singleton parse result - so no visible effect in a couple of cases I thought to try
15:17:50 <codeshot> What effects can this have that I'm not able to trigger?
15:18:07 <codeshot> ... that I'm not able to trigger so far?
15:18:39 <byorgey> codeshot: what exactly do you mean by "run a parsec parser in the list monad"?
15:18:58 <byorgey> do you mean run something of type  ParsecT s u [] a ?
15:19:14 <codeshot> yep
15:20:30 <byorgey> well, there aren't going to be any list effects unless you make them yourself, and e.g. lift them into ParsecT s u [] a  via 'lift'.  ParsecT s u [] a  means you are *adding* parser effects on top of the list monad.  It does not change the way the parsing works.
15:22:58 <codeshot> I think I'm understanding
15:23:08 <codeshot> new to monad transforers
15:26:44 <codeshot> oh ho
15:26:45 <codeshot> nice
15:28:13 <iqubic> How do Monad Transformers work?
15:29:42 <johnw> iqubic: you may want to google for one of the many tutorials
15:30:45 <koala_man> they're like enchiladas. you take a burrito and add something on top
15:31:25 <iqubic> LOL
15:31:31 <johnw> I think that's just enchilada style
15:31:50 <johnw> a real enchilada is made a different way!
15:33:23 <iqubic> Why are monads not in lisp?
15:33:27 <ggVGc> is anyone else on arch? I am not able to build terminfo using stack
15:33:36 <ggVGc> wonder if it's my system of it the package is broken
15:34:01 <ggVGc> iqubic: they can be...
15:34:13 <ggVGc> iqubic: also, monads "are" in everything
15:34:15 <johnw> iqubic: they really require types and purity to be useful enough; otherwise, they're more of a hassle to setup and use for little benefit
15:34:19 <ggVGc> if something is a monad or not is an inherent property
15:34:42 <johnw> you could write a monadic interface using CLOS, for example
15:34:56 <johnw> and then a library in terms of that interface
15:35:19 <johnw> but you'd have very few useful instances
15:35:43 <johnw> the complexity of use/education would not "pay off"
15:35:58 <johnw> people have coded them up in many other languages; note that they have taken off in none of them
15:36:16 <codeshot> ah ha, so I think with ParsecT s u IO a I can make some IO be done when a statement cannot be parsed but then continue parsing
15:36:27 <johnw> codeshot: exactly
15:36:40 <codeshot> including call/cc
15:36:48 <johnw> the transformer lets you "interleave" the IO behavior with the parsing behavior
15:36:51 <codeshot> so the outer code can control
15:36:52 <codeshot> it's nice
15:37:30 <hexagoxel> ggVGc: i just successfully built terminfo using stack on arch. not sure if that answers your question.
15:37:40 <Cale> iqubic: Because lisp doesn't have type classes, and so you'd have to give an extra argument to everything
15:37:42 <ggVGc> hexagoxel: is your system up to date?
15:38:41 <Cale> iqubic: In Haskell, we get to pass the instances around invisibly based on the type information, but that wouldn't fly in lisp, you'd have to be explicit about it and the syntax would suck
15:39:34 <greymalkin> Is there a cryptonite function equivalent to oct2point for any arbitrary curve? (Specifically those listed in Crypto.PubKey.ECC.Types.CurveName)
15:39:55 <hexagoxel> ggVGc: yes, roughly two days since last full update.
15:40:02 <ggVGc> :(
15:40:06 <ggVGc> wonder what's up for me then
15:41:39 <Gurkenglas> zenspider, you may already have M-x hayoo in emacs
15:45:01 <hexagoxel> ggVGc: i manually installed stack though. and i am not sure if i use system ghc or not.
15:45:21 <hexagoxel> ggVGc: you really should share more info if you want help..
15:45:51 <ggVGc> yeah I'm using system stack, that might be it
15:45:58 <ggVGc> why did you install it manually?
15:46:32 <hexagoxel> because i avoid any haskell stuff in arch repo, due to the dynamic linking mess.
15:47:04 <Welkin> it's best to avoid anything haskell outside of stack/cabal/bindist
15:47:07 <ggVGc> yeah... that's probably what I'm experiencing
15:47:21 <ggVGc> I'll try to do a manual install of stack, thanks
15:47:30 <Welkin> it's too important to leave to something like a random package manager
16:08:40 <Gurkenglas> MarcelineVQ, yes
16:11:28 <ggVGc> hexagoxel: if I do stack unpack terminfo && cd terminfo && stack init && stack build, I get this in config.log, https://gist.github.com/c49e7581552063a40bba00400d973ee6
16:11:38 <ggVGc> not sure what on my systme could be broken
16:11:50 <ggVGc> fully up to date and using manually installed stack now
16:12:04 <ggVGc> maybe that "fully up to date" part is the issue..
16:13:24 <geekosaur> is this the libtinfo6 thing again?
16:13:34 <hexagoxel> probably
16:13:39 <geekosaur> (confuses stack into loading the wrong ghc)
16:14:22 <geekosaur> or rtaher, upstream doesn't provide for this case very well and stack picks the wrong 'generic' bindist to start from as a result
16:15:42 <geekosaur> it is not currently possible to provide a single generic linux binary distribution of ghc, because there are too many permutations of things that are or aren't present, or different linker default configs (position independent executables "PIE" vs. not), etc.
16:16:33 <ggVGc> why is hexagoxel's system fine then, if he's also up to date and using stack?
16:16:55 <ggVGc> rahter, what could I do to get my system to also be fine :)
16:17:04 <geekosaur> the trick here is whether the libtinfo6 package is installed or not. stack tries to figure out which bindist to use based on its presence instead of its necessity
16:17:22 <geekosaur> (on arch it's a compatibility library, not an essential one)
16:17:40 <ggVGc> yep I have it..
16:17:45 <geekosaur> but testing 'essential' in this case is rther difficult
16:18:03 <geekosaur> so try removing it and doing 'stack init && stack build' again
16:18:50 <ertes> i really wish haskell would allow bindings in the final statement of a do-block
16:18:51 <hexagoxel> ggVGc: because i have ncurses5-compat-libs installed, perhaps.
16:18:55 <geekosaur> in practice, having that package on arch causes it to pick the wrong bindist to use and the result is linker errors, because it can;t tell that on arch libtnfo6 doesn't mean you need something else
16:19:00 <Welkin> ertes: _ <- ...
16:19:02 <geekosaur> but on some other linuxes it does
16:19:13 <ertes> > do _ <- [()]
16:19:14 <Welkin> ertes: oh
16:19:15 <lambdabot>  error:
16:19:15 <lambdabot>      The last statement in a 'do' block must be an expression _ <- [()]
16:19:18 <ertes> Welkin: nope
16:19:27 <Welkin> yeah, oh well
16:19:58 <Welkin> I guess it doesn't make sense
16:20:06 <Welkin> because you are binding something and the not using it
16:20:07 <geekosaur> it depends in part on how they split packages up and in part on how they configured the ncurses package, so the rules about libtinfo6 depend on the distro instead of being generic linux
16:20:09 <geekosaur> (or 5)
16:20:25 <hexagoxel> (also, libtinfo-5, and perhaps other stuff - installing ghc bindists required adaptions in the past for me already)
16:20:45 <geekosaur> long story short, trying to be 'generic linux' is currently a cluster****
16:20:55 <ggVGc> :(
16:21:00 <geekosaur> and the bindists are mostly made on debian which has different rules from arch
16:21:03 <ggVGc> how'd we get into this situation
16:21:04 <Welkin> I use mac for development
16:21:07 <Welkin> even that runs into issues
16:21:10 <ertes> Welkin: why wouldn't that make sense?
16:21:31 <ggVGc> hexagoxel: thanks, trying that out
16:21:39 <Welkin> ertes: a <- ma is the same as ma >>= \a -> ...
16:21:50 <Welkin> why would you bind the `a` if you aren't using it?
16:21:57 <geekosaur> debian/ubuntu/mint does one thing, rh/fedora another, arch/manjaro a third, ...
16:21:59 <ertes> Welkin: because iterative development
16:22:16 <Welkin> you could always end your do blocks with pure ()
16:22:24 <ertes> yes, and that's annoying
16:22:34 <ertes> hence my wish
16:23:20 <ggVGc> sweet
16:23:23 <ggVGc> hexagoxel: that fixed it
16:23:27 <ggVGc> good times
16:23:31 <ggVGc> only took 2 hours of my life
16:24:25 <Welkin> it spent 2 hours of my life getting fonts to load last week
16:25:54 <hexagoxel> lovely how the stack issue tracker treats it like "oh there is a workaround? issue closed!"
16:26:02 <ggVGc> now I have completely no motivation whatsoever to actualy write the code I wa soging to write
16:26:05 <ggVGc> :((((
16:26:17 <Welkin> ggVGc: pick up tomorrow
16:26:19 <geekosaur> the real lesson here is probably that arch is important and common enough that ghc, stack, etc. should include it in testing
16:26:28 <Welkin> happens to me a lot with nix/ghcjs things
16:26:47 <ggVGc> oh, I'm never going down the ghcjs hole again
16:26:49 <hpc> the real real lesson is that packaging isn't an afterthought when developing software
16:26:50 <ggVGc> screw that
16:26:53 <ggVGc> I got it working once
16:27:03 <hexagoxel> arch users love bleeding edge though. and bleeding edge means cabal new-build, not stack.
16:27:12 <hexagoxel> :p
16:27:34 <dmj`> hpc: spot on
16:27:34 <ggVGc> I honestly don't love bleeding edge, but I like the "flatness" of arch
16:27:41 <ggVGc> not sure what term to use
16:27:52 <ggVGc> I'd rather arch wasn't so damn bleeding edge
16:28:22 <dmj`> ggVGc: nix-shell -p ‘haskell.packages.ghcjs.ghcWithPackages (p: with p; [ ghcjs-base ])'
16:28:23 <ggVGc> also, after using a distro for something like 10 years it's a bit too much effort to switch
16:28:29 <dmj`> should be that simple
16:28:33 <ggVGc> dmj`: nope, stay away demon
16:28:35 <johnw> when my edges bleed, it's my blood
16:29:14 <Welkin> ggVGc: not for me... I used ubuntu for ages, but dropped it for macos. I even went back to windows for a year...
16:29:18 <dmj`> johnw :)
16:29:35 <dmj`> ggVGc: resistance is futile
16:29:57 <ggVGc> Welkin: I can do different OSes, and I actively work across all three majors regularly
16:30:14 <ggVGc> but switching my everyday linux distro isn't something I'd do lightly
16:35:04 <ertes> dmj`: with recent cabal2nix all you need is:  nix-shell --argstr compiler ghcjs
16:35:33 <Welkin> I thought all you need is love
16:36:41 <codeshot> It seems with the monad transformer features, runParserT has no need for the name and user state parameters
16:44:54 <nicknight> hi do we find exteremly hard to use something like L-BFGS algorithms in haskell ?
16:45:17 <Welkin> I don't know what that is
16:45:22 <Welkin> but there is nothing you cannot do in haskell
16:45:40 <EvanR> other than the usual
16:45:49 <Welkin> you can access pointers, have unboxed values, mutate data, etc.
16:45:59 <EvanR> a working isBottom :: T -> Bool
16:46:21 <Tuplanolla> My guess would be "something breadth-first graph search".
16:46:42 <Welkin> bfs and dfs are trivial to write in haskell
16:46:46 <Tuplanolla> Maybe "left".
16:50:26 <nicknight> Welkin:  trivial meaning ?
16:51:11 <Welkin> nicknight: easy. you can do it in 10-15 lines of code
16:51:13 <nicknight> haskell channel dont use tab to mention a person :P 
16:51:15 <Welkin> or less
16:51:20 <nicknight> ok cool Welkin 
16:51:31 <nicknight> Thanks 
16:52:39 <Tuplanolla> Do I get a mind reading award for that?
16:53:50 <nicknight> for what ?
16:54:55 <nicknight> https://en.wikipedia.org/wiki/Broyden%E2%80%93Fletcher%E2%80%93Goldfarb%E2%80%93Shanno_algorithm   
16:55:17 <Tuplanolla> I guess not.
16:55:51 <Tuplanolla> Still, I don't see why this would be particularly difficult.
16:56:06 <nicknight> Ok I dont know
16:56:06 <Gurkenglas> EvanR, also everything not computable
16:56:45 <EvanR> which boils down to that function
16:57:02 <nicknight> Tuplanolla: because in language like octave they are pre-defned so wanted to know if I can find libraries preimplemented in haskell Tuplanolla 
16:57:14 <nicknight> typed your name twice sorry
16:57:46 <Tuplanolla> @hackage optimization
16:57:46 <lambdabot> http://hackage.haskell.org/package/optimization
16:57:48 <Gurkenglas> EvanR, there are uncountably many sets and countably many programs that can be written with access to a working isBottom
16:58:03 <Tuplanolla> There it is, nicknight.
16:58:11 <Gurkenglas> *uncountably many functions one might want to compute, let's say.
16:58:23 <EvanR> for some value of "there are"
16:58:44 <nicknight> ok thank you Tuplanolla 
16:58:46 <Gurkenglas> Fine, there are uncountably many sets of strings, so not enough programs for each of them to be decidable
16:59:06 <Gurkenglas> Even given any number of oracles you like
16:59:46 <Welkin> how can a finite universe contain infinite things?
17:00:07 <EvanR> you could simplify it to there are uncountably many infinite strings
17:00:11 <Gurkenglas> Welkin, we are talking about what Haskell can do, not what GHC can do
17:00:38 <EvanR> and this sentence is grammatically correct, but i am unsure about its semantics
17:01:23 <EvanR> which string "exists" that haskell cant output
17:01:41 <EvanR> seems like an old and unsettled conundrum
17:02:26 <Gurkenglas> Haskell can output any given string, but Haskell does not allow you to write a program that computes any given function
17:03:03 <EvanR> that sounds like an indirect contradiction
17:03:33 <Gurkenglas> The confusion comes from the difference only being in the order of the quantors
17:04:04 <EvanR> take one of the uncomputable functions (which i could ask a similar question about) and ask haskell to output the string that contains all the answers for the function
17:04:16 <EvanR> then seek to the answer
17:04:24 <EvanR> suddenly it computed the uncomputable
17:04:49 <Gurkenglas> Oh, I was wrong, the confusion came from me still working with finite strings
17:05:00 <Gurkenglas> Okay, here's a string that haskell cannot output:
17:05:20 <EvanR> yeah arbitrary sets of finite strings seems even more ridiculous than "any infinite string"
17:05:46 <EvanR> because we believe in sets so big
17:06:19 <EvanR> (wait theres only countably many finite strings)
17:10:06 <Gurkenglas> [1-(binary !! i) | binary <- zip [0..] some_enumeration_of_all_haskell_programs_that_generate_infinite_binary_strings]
17:10:22 <Gurkenglas> *"(i, binary) <-", of course
17:11:19 <Gurkenglas> (That was diagonalization, application of the principle "Anything that tries to predict itself and do the opposite fails somewhere")
17:11:42 <EvanR> what
17:11:55 <EvanR> ok imagning the fixed code
17:12:20 <EvanR> so why cant it compute that ?
17:12:45 <Gurkenglas> Assume there was a Haskell program that generated this infinite binary string. It would disagree with itself in the spot where it appears in the enumeration.
17:13:27 <EvanR> oh, some_enumeration_of_all_haskell_programs_that_generate_infinite_binary_strings is a contradiction
17:14:18 <Gurkenglas> You can enumerate them. Just take an enumeration of all finite strings (you admitted there's countably many of them), and filter for those that compile to a Haskell value of type [Int]
17:14:29 <EvanR> you cant do that filter
17:14:37 <EvanR> its like isBottom
17:14:57 <Gurkenglas> Why can't you do that filter? Compilation halts.
17:15:39 <EvanR> theres something like the halting problem which stops you from detecting interesting properties of programs... but youre right
17:15:47 <EvanR> whats wrong with this picture
17:17:22 <EvanR> i intuitively expect that list to not be RE
17:17:45 <EvanR> oh
17:17:54 <EvanR> [Int] doesnt tell you if its an infinite list or not
17:17:55 <Gurkenglas> Hm, I suppose some of the programs in the list would evaluate to bottom 
17:18:06 <EvanR> isFinite is like isBottom
17:18:09 <Gurkenglas> That's not the problem, replace [Int] with Stream Int
17:18:36 <EvanR> ok, some streams will contain bottoms, or be bottom itself
17:18:56 <EvanR> then the diagonalization wouldnt be able to continue
17:19:23 <EvanR> you could skip the bottoms, and have bottom in that spot of the diagonalization
17:19:31 <EvanR> but youre screwed if the stream itself is bottom
17:19:37 <Gurkenglas> replace (binary !! i) with (if isBottom (binary !! i) then 0 else binary !! i])
17:20:04 <EvanR> brilliant
17:20:24 <Gurkenglas> Remember, in the specification of the string Haskell isn't supposed to be able to print, I'm allowed to do things you can't do in Haskell :P
17:33:26 <EvanR> Gurkenglas: what about the equivalent experiment in idris, where the list is of total programs with the type Stream Int
17:33:45 <EvanR> if it type checks and totality checks...
17:33:59 <Gurkenglas> You just proved there's no idris program that can output that string
17:34:45 <Gurkenglas> There's a Haskell program that can output that string, though.
17:34:46 <EvanR> its a recipe for generating the input to the diagonalization
17:34:50 <EvanR> not a program
17:35:04 <EvanR> so its a paradox
17:35:36 <EvanR> before you failed to even produce the list
17:35:46 <Gurkenglas> I don't follow.
17:36:07 <EvanR> go through all finite strings, try to compiled each one, if it checks, put it in the list
17:36:10 <Gurkenglas> Is your explanation compatible with there being a Haskell program that produces the idris string?
17:36:21 <EvanR> this time, we even know its a working program
17:36:38 <EvanR> then the diagonalization proves it still doesnt exist
17:37:03 <EvanR> i probably messed up the setup and conclusion completely
17:37:18 <Gurkenglas> Yep, you'll find that no idris program you try to write for that will pass the totality checker.
17:37:47 <EvanR> what
17:38:20 <EvanR> the program producing the list_of_all_idris_program_that_output_infinite_strings could be written in haskell
17:38:31 <EvanR> but whats the problem
17:38:40 <Gurkenglas> And if you then translate it to idris, it'll fail the totality checker.
17:38:46 <EvanR> i dont think so
17:39:06 <Gurkenglas> Wanna bet?
17:39:11 <EvanR> o_O
17:39:14 <Gurkenglas> 10 paypal dollars
17:39:23 <EvanR> its a simple test on an RE stream
17:39:45 <Gurkenglas> Anything that tries to predict itself and do the opposite must fail somewhere
17:39:49 <EvanR> (the totality check here is actually a productivity test)
17:40:24 <EvanR> i think i am missing the original statement that is disproved
17:40:46 <Gurkenglas> What do you suppose will the idris program output in the spot where it appears in the enumeration?
17:41:36 <nshepperd_> Can an idris compiler even be written in idris?
17:41:53 <EvanR> it wont appear because the idris interpreter is written in haskell :)
17:42:08 <johnw> nshepperd_: same way GHC can be written in Haskell
17:42:15 <Gurkenglas> I suppose the totality checker will fail the totality checker.
17:42:19 <EvanR> lol
17:42:26 <EvanR> no
17:42:31 <nshepperd_> johnw: i thought there was an issue with totality
17:43:28 <johnw> nshepperd_: but Idris is fine with partial definitions
17:43:35 <nshepperd_> Something something theorem about dependent typing being undecidable
17:43:43 <EvanR> and you could prove the compilation process is total
17:43:46 <EvanR> hypothetically
17:43:51 <EvanR> oh right
17:43:54 <johnw> oh, you want to establish the metatheory using only the metatheory of Idris?  That you can't do.
17:44:30 <EvanR> the type checker refuses to continue with partial functions at the type level
17:44:47 <EvanR> so this generator scheme can still work
17:45:03 <EvanR> when it encounters a hypothetical idris version of idris
17:46:44 <EvanR> assuming this program can call out to an external compiler, which terminates, eventually this program will appear inthe list. then what?
17:47:27 <Gurkenglas> Then paradox. So one of your assumptions was wrong. I suppose it was that the compiler terminates.
17:47:45 <EvanR> its supposed to 
17:47:50 <EvanR> unless bugs
17:48:35 <EvanR> i find it hard to believe this proves the necessity of a bug
17:49:04 <Gurkenglas> The totality checker won't be able to believe that the external compiler terminates
17:49:35 <Gurkenglas> The totality checker of the external compiler, that is
17:49:59 <Gurkenglas> If you can override the totality checker, then there are programs in the list that don't terminate
17:50:07 <EvanR> for the sake of argument, it does terminate. and let the one use of a "cheat" be used for the call to that program
17:50:14 <EvanR> so the checker will accept i
17:50:39 <Gurkenglas> If you used a cheat to call to that compiler, your program won't appear in the list
17:50:48 <EvanR> why
17:51:36 <Gurkenglas> If the list contains only idris programs that don't cheat, yours isn't in it. If it allows idris programs with cheats, there are other programs that exploit this to not terminate
17:51:42 <EvanR> the cheat is only allowed when asking to compile a program
17:51:50 <EvanR> any program can use it
17:51:54 <EvanR> but only for that
17:52:44 <Gurkenglas> I mean, you're trying to build a perpettum mobile here, but that's fun, because it's a source of interestingly eldritch bugs that keep squishing out where you haven't looked
17:52:47 <EvanR> idris itself is probably overcomplicating this scenario. list_of_all_programs_in_total_language_x_that_produce_infinite_strings
17:53:05 <Gurkenglas> It's like having a time turner and trying to kill your grandpa
17:53:23 * nshepperd_ observes that Halting Oracle O that solves the halting problem for language L, does not solve the halting problem for L + O
17:53:45 <EvanR> why do you need an oracle here
17:53:45 <nshepperd_> Generally
17:54:06 <Gurkenglas> He just means that O isn't in L
17:54:14 <EvanR> can we not postulate a language which realistically can only produce infinite streams
17:54:21 <EvanR> that is always productive
17:54:33 <Gurkenglas> Then you can't write a compiler of itself in it
17:55:10 <EvanR> if thats what that argument proves... i want to know where the screw up is :)
17:55:31 <EvanR> compilers shouldnt really need turing completeness should they
17:55:50 <Gurkenglas> No, there's languages weak enough that compilers for them still aren't turing complete
17:55:56 <johnw> EvanR: CompCert doesn't need it I don't think
17:56:03 <Gurkenglas> You can even squish countably many layers in there
17:56:08 <nshepperd_> Well, how do you ensure productivity
17:56:25 <Gurkenglas> But each compiler has to be more powerful than the last
17:56:28 <EvanR> honestly i dont know how idris does it
17:56:51 <EvanR> looks for only recursion guarded by a constructor
17:56:52 <Gurkenglas> I think "In idris, it must be in the totality checker, because get rid of that and you get Haskell" but I'm not sure
17:57:04 <nshepperd_> You can impose some strong syntactic requirements, which results in a weak language that can barely do anything
17:57:42 <Gurkenglas> I wonder what happens when you try to resist diagonalization by having a totality checker that outputs a probability of the program being total
17:57:51 <EvanR> o_O
17:57:56 <nshepperd_> You have a complicated totality checker, in which case it's too complicated to prove its own totality
17:58:17 <EvanR> shouldnt totality checking be provably total
17:58:31 <EvanR> what stops that proof from passing the checker
17:58:56 <EvanR> is this really as meta as it sounds
17:59:28 <Gurkenglas> it's exactly one quant of meta, right?
17:59:34 <EvanR> i dont know
17:59:36 <nshepperd_> Lol
17:59:46 <EvanR> i was under the impression you could encode whatever you want with dependent types
17:59:53 <EvanR> whatever you want to say
18:01:43 <EvanR> if you cant do this, what is the correctness of a totality checker even based on
18:01:59 <Gurkenglas> The correctness of the totality checker above it
18:02:04 <EvanR> o_O
18:02:25 <EvanR> the same checker with a different hat on?
18:02:36 <Gurkenglas> That it can't prove its own totality doesn't mean that some better totality checker can't do it. Eventually, you prove the totality of one of them manually in ZF
18:02:51 <geekosaur> this is like watching someone tilt Gödel's windmill >.> 
18:02:54 <EvanR> that doesnt sound right at all
18:03:24 <Gurkenglas> And then you ask yourself whether ZF is actually consistent, and sit down to prove ZF's consistency in ZF, and whoops, you didn't halt
18:03:29 <geekosaur> * tilt at
18:04:29 * nshepperd_ pushes over the windmill
18:04:31 <EvanR> might be a better question for agda
18:04:57 <Gurkenglas> Whoops turns out nshepperd_'s standing on a bigger windmill
18:06:01 <Gurkenglas> So we take a probabilistic totality checker, and apply it to itself. I guess 50% comes out?
18:06:34 <EvanR> exactly how do you arrive at a totality probability
18:06:49 <johnw> that wouldn't be a totality checker, just an estimator
18:06:50 <nshepperd_> Gurkenglas: hm, reminds me of miri's logical induction thing
18:06:57 <Gurkenglas> nshepperd_, that's where I got the idea
18:08:03 <nshepperd_> Gurkenglas: they require that the output has to be a continuous function of the probability though, to prevent shenanigans
18:08:04 <EvanR> run the program for N steps, if it hasnt halted yet, do N/infinity and declare approx 0% chance its total?
18:09:50 <Gurkenglas> EvanR, a computable logical reasoner whose credence in any universal statement tends to 100% as it keeps being confirmed will systematically underestimate the busy beaver function.
18:14:50 <Gurkenglas> nshepperd_, actually I think I got the idea from some earlier post on lesswrong where someone talked about using probability stuff to get around Löb's theorem, but that might have led into the logical induction paper
18:16:16 <johnw> what does it mean to "get around Löb's theorem"?
18:18:21 <Gurkenglas> To design a mathematical system that does not halt melt and catch fire when trying to talk about its own soundness
18:25:05 <Gurkenglas> Ah, here's the lesswrong post I got the idea. http://lesswrong.com/lw/h1k/reflection_in_probabilistic_set_theory/
19:03:07 <iitalics> anyone here use arch + haskell + emacs? emacs-mode stopped working and i haven't been able to get it to work since
19:03:34 <iitalics> "haskell process command errored with: (wrong-type-argument stringp nil)"
19:15:57 <slack1256> well, it seems a wront-type error
19:16:46 <orion> Is it possible (in theory) to automatically generate a PNG image from a program represented as a Free Monad?
19:16:55 <orion> erm
19:17:08 <orion> (The PNG image would be a flow chart of the program)
19:17:14 <johnw> sure
19:17:27 <johnw> if it's an initial encoding of the free monad, so that you can fully reflect on its structure
19:17:35 <johnw> as in, the type data Free f a = ... approach
19:18:30 <Cale> Well, still only maybe?
19:18:33 <slack1256> I think it would be easier to output some kind of .dot graph and the use graphviz for generating the png
19:18:35 <Cale> There might be functions in there
19:18:58 <Cale> Depends on which functor the free monad is over
19:19:38 <orion> But what separates a (Free) Monad from a (Free) Applicative is the notion that future computations can depend on the results of previous computations.
19:20:46 <orion> If my goal is to generate a complete/full flow chart of every possible instruction, why am I not limited to this?
19:20:52 <orion> Why am I not resigned to Applicative?
19:21:17 <johnw> Cale: oh, right!
19:21:57 <iitalics> welp
19:21:59 <lol-md5> what's wrong with my definition of Knuth's up-arrow notation? https://hastebin.com/isaxihepoj.hs
19:22:02 <iitalics> i guess im probably never using haskell again
19:22:08 <lol-md5> iitalics, what why?
19:22:33 <iitalics> emacs mode doesn't work, cabal is a nightmare and i can't get anything to install
19:22:49 <sha1> rip
19:23:21 <Cale> orion, consider something like  data MyIO a = Done a | GetChar (Char -> MyIO a) | PutChar Char (MyIO a)
19:23:43 <Cale> orion: (this is basically a free monad, I just flattened it by hand)
19:23:58 <Cale> orion: It's going to be tough to print out the Char -> MyIO a bits
19:25:02 <iitalics> installing "ghc-mod" tells me there are major conflicts with my "base", and if i try --allow-newer i get a bunch of errors blaming toplevel imports
19:25:28 <iitalics> emacs-mode gives me elisp errors when i load files
19:25:49 <iitalics> i tried installing another mode and it ran into a problem while running a configure script
19:26:25 <orion> johnw: Cale seems to disagree with you.
19:26:36 <johnw> I'm agreeing with Cale
19:26:37 <Cale> <johnw> Cale: oh, right!
19:26:50 <johnw> I forgot about f = (->), for example
19:26:56 <orion> I see.
19:27:03 <johnw> err, (->) e
19:27:27 <Cale> Free monads over polynomial functors will work though, but those are basically "trees"
19:27:53 <johnw> yep
19:27:54 <Cale> of course, there can still be recursion
19:28:55 <sha1> here's the error message i get with that function: https://hastebin.com/libavacami.hs
19:32:25 <orion> Polynomial... is that a reference to the notion that "data Mayba a = Nothing | Just a" is kind of like "1 + x"?
19:33:54 <EvanR> yeah
19:34:53 <mniip> orion, they're free of exponents and discontinuous functions
19:35:24 <EvanR> or are they
19:36:13 <EvanR> surely you could do :) 1 + x + x^2 + x^3 + ...
19:36:35 <monochrom> Not allowed when you say specifically "polynomial functor".
19:36:37 <orion> That's exactly what I think of when I hear the word "polynomial".
19:36:52 <monochrom> I mean sure, if you say the broader "algebraic data type" you have that.
19:37:08 <monochrom> which is clearly analytic rather than algebraic.
19:38:18 <monochrom> By the time you write "newtype X = Ctor (X -> X)" it's downright transcendental.
19:38:53 <orion> Am I correct in saying that "data Foo a = OpA Int | OpB Bool" is *not* a polynomial functor, but "data Bar a = OpC (Int -> Int)" is?
19:38:57 <mniip> EvanR, that's continuous
19:39:19 <benzrf> orion: that's polynomial, it's K Int + K Bool
19:39:23 <nshepperd> 1 + x + x^2 + ... + x^n for some n is polynomial
19:39:26 <monochrom> Both are.
19:39:33 <orion> hmm, ok
19:39:43 <johnw> K Int * x^0 + K Bool * x^0?
19:39:52 <benzrf> if you prefer :)
19:40:02 <mniip> "Int -> Int" is polynomial in x
19:40:10 <monochrom> Basically "p(x) = 10 + 14 + 5^5" is a polynomial.
19:40:49 <orion> What is an example of a functor which I can't graphically visualize when a Free Monad is defined over it?
19:41:39 <monochrom> I can't graphically visualize anything.
19:41:57 <EvanR> not after 9PM
19:42:08 <EvanR> mniip: its exponential though
19:42:08 <monochrom> So "newtype C a = MkC ()" will do. :)
19:42:30 <mniip> EvanR, not in x
19:42:39 <mniip> or you mean
19:42:43 <EvanR> oh, exponential means ->
19:42:52 <EvanR> goofy
19:42:58 <iqubic> What about "Data NonEmpty a = NonEmpty a [a]" How does that fit into the algebra we're discussing?
19:44:19 <iqubic> I think that's X + X^2 + X^3 + X^4 ...
19:44:27 <iqubic> Correct me if I'm wrong. 
19:45:03 <EvanR> + X^infinity
19:46:08 <iqubic> Yeah, I think that's right.
19:46:55 <mniip> orion, hypothetically,
19:46:59 <mniip> you could look into functions
19:49:47 <orion> ?
19:50:35 <Axman6> > (fromIntegral (maxBound :: Word64)) ^ (maxBound :: Int) :: Integer
19:50:42 <lambdabot>  mueval: ExitFailure 1
19:50:48 <iqubic> What?!?!
19:50:57 <iqubic> what does that error code mean?
19:51:05 <Axman6> > length . show $ ((fromIntegral (maxBound :: Word64)) ^ (maxBound :: Int) :: Integer)
19:51:12 <lambdabot>  mueval: ExitFailure 1
19:51:45 <Axman6> > length . show $ ((fromIntegral (maxBound :: Word64)) ^ (maxBound :: Int8) :: Integer)
19:51:47 <lambdabot>  2447
19:51:49 <mniip> orion, there's some introspection you can do with GHC.Prim and a lot of bit twiddling
19:52:48 <orion> That doesn't seem mathematically elegant.
19:52:56 <Gurkenglas> orion, IO is a functor
19:53:08 <cheater> say i am using a library that exposes function f (only). this library loads some resource x to use it in its internal function y. the loading of x and passing it onto y happens in g, which is called from f. Now, without modifying f or g, i would like to have access to the values x and y from the scope that utilises f in my client code. (obviously f and g would have to be built to support this). is ...
19:53:14 <cheater> ... there an abstraction that is made for doing this sort of thing?
19:54:12 <Gurkenglas> orion, perhaps less eldritchly, State s is a functor
19:54:24 <cheater> i am talking about some sort of abstraction that would let me look "inside of" f and see it for the composition of things that it is (among others x and y)
19:55:15 <Gurkenglas> What does it mean to not modify f and g for this when they are designed for this?
19:55:33 <cheater> right
19:56:20 <cheater> so you know how you can do eg u <$> v to modify a value w that's inside v using u? similarly here i'd like to have such access to all things that compose to make the function f, not just one special value
19:57:19 <Gurkenglas> Would you like this access to be unlocked by providing some further parameters to f? Otherwise, why not just have the library export x and y?
19:58:05 <cheater> well you don't provide further parameters to v when using Functor to perform u <$> v. And what's inside v isn't exported either.
19:59:07 <cheater> so i don't like either option - i'd much rather have something like Functor that allows me to work with a deeper structure than just a single value. maybe like a call tree or something like that.
19:59:33 <Gurkenglas> Why not have the type inside the functor be a triple of the three valus you want to be able to access?
19:59:43 <cheater> that's an option
19:59:49 <cheater> but it feels kludgy
20:00:07 <cheater> also, i would like it to compose
20:00:38 <cheater> so if f uses g inside it, and g uses h inside it, then in my client code, if i have f, then i would like to access f's g, f's g's h, and so on
20:01:31 <cheater> so i could do something like foo ... <$> (... <$> (... <$> f))
20:02:33 <Gurkenglas> I am reminded of Context' a s ~= (a -> s, a) https://hackage.haskell.org/package/lens-4.15.4/docs/Control-Lens-Lens.html#t:Context-39-
20:02:35 <cheater> but that's just silly, i'd much rather do something like multiMap f componentPath foo
20:02:43 <cheater> Gurkenglas: hmm
20:02:51 <cheater> Gurkenglas: right
20:03:12 <cheater> that gave me some food for thought
20:03:13 <cheater> thanks
20:03:20 <cheater> i wonder one thing though
20:03:51 <cheater> if i have to somehow export all those things inside f so that they're available in the tuple in the Functor by hand, that's kind of bad
20:04:14 <cheater> i wonder if there's a way to write normal code using monadic syntax, and have every value used inside exported at once
20:04:29 <cheater> maybe i could use a free monad or something like that, and have a DSL for composing functions like that
20:04:38 <cheater> that might be fun
20:04:42 <Gurkenglas> lens specializes in packing the features of many values into one
20:04:55 <cheater> right yeah
20:08:15 <Gurkenglas> "foo ... <$> (... <$> (... <$> f))" is "foo ... . ... . ... <$> f"
20:12:10 <fDev2179> \part
20:12:12 <fDev2179> \part
21:06:50 <cobreadmonster> Hello.
21:20:18 <boogalooga> anyone know 
21:20:23 <boogalooga> why this is failing
21:20:24 <boogalooga> https://imgur.com/a/qVhYG
21:20:35 <boogalooga> failing to compile*
21:20:47 <boogalooga> if there's a logical error I'll deal with that later
21:21:09 <mniip> boogalooga, the types don't match
21:21:15 <boogalooga> Expected type: a -> a -> a         Actual type: a -> b -> a
21:21:19 <boogalooga> This is the error
21:21:26 <boogalooga> I don't understand why not
21:21:29 <boogalooga> mniip
21:21:37 <mniip> foldr receives an (x -> y -> y) type function as argument,
21:21:45 <mniip> and you give it an (a -> b -> a) function
21:21:54 <mniip> it infers x ~ y and thus a ~ b
21:21:56 <boogalooga> oops
21:21:59 <boogalooga> it's the opposite
21:22:01 <boogalooga> I see
21:22:01 <mniip> but latter is an error because a and b are skolem
21:22:02 <boogalooga> thanks
21:22:18 <mniip> or rigid, if you prefer
21:23:11 <boogalooga> not sure what rigid means
21:23:17 <boogalooga> http://www.cis.upenn.edu/~cis194/spring13/hw/04-higher-order.pdf
21:23:24 <boogalooga> I'm at this stage of cis194
21:25:27 <mniip> boogalooga, when you use a polymorphic function you can substitute anything you want for the type variables,
21:25:47 <boogalooga> ahuh
21:25:58 <mniip> when you write a polymorphic function you must ensure the above can be satisfied and thus the type variables in the type of the function you write are rigid
21:26:12 <boogalooga> I see
21:26:14 <boogalooga> I see
21:26:15 <mniip> meaning if it is required of them to be any specifc type that's a type error
21:26:32 <boogalooga> I see
21:26:38 <boogalooga> also is my logic fine
21:26:38 <boogalooga> ?
21:26:57 <mniip> well, can you check?
21:27:04 <mniip> I mean prove
21:27:45 <eacameron> Is there a typeclass like Show/Read that never puts double quotes around string-like types (String, Text)?
21:28:23 <boogalooga> well, if there's no elements
21:28:25 <boogalooga> it returns the base
21:28:27 <boogalooga> so that's fine
21:29:58 <boogalooga> and assuming that the it folds a list of length n correctly
21:30:56 <boogalooga> in the next step, it should return the expected value I guess
21:31:00 <boogalooga> so it should work?
21:31:05 <boogalooga> not sure how to prove everything
21:31:09 <boogalooga> mniip
21:32:34 <mniip> well a proof would look like,
21:32:56 <monochrom> I think it's a bad idea to ask someone "can you prove it?" when we clearly know it's going to be wrong.
21:33:17 <mniip> I assumed they flipped the f
21:33:19 <boogalooga> lol
21:33:23 <boogalooga> oh I did
21:33:26 <boogalooga> flip it
21:33:54 <boogalooga> https://imgur.com/a/ADVJ9
21:33:56 <mniip> monochrom, or is there something else i'm not seeing
21:33:57 <boogalooga> looks like this now
21:34:44 <monochrom> No. When you saw "also is my logic fine" you should have simply answered "no, if there is a type error, clearly the logic is wrong".
21:35:22 <monochrom> As opposed to "well can you prove it?" which is evilly misleading because it gives out a false hope.
21:35:36 <boogalooga> well, I fixed the type error...
21:35:41 <monochrom> If they don't fix the code first, there is nothing to prove. Nothing positive anyway.
21:36:01 <boogalooga> I see what you're saying though
21:36:09 <boogalooga> so how would I go about proving it
21:36:10 <boogalooga> ?
21:37:15 <monochrom> You prove by list induction that for every list xs, myFoldl f base xs = foldl f base xs.
21:37:33 <monochrom> And in the process you do a lot of algebra.
21:38:17 <boogalooga> I see 
21:38:24 <boogalooga> so pretty much what I was kind of getting at
21:38:25 <boogalooga> base case
21:38:28 <boogalooga> nth step
21:38:31 <boogalooga> n + 1th step
21:38:33 <boogalooga> I guess
21:38:37 <boogalooga> True
21:38:54 <boogalooga> thanks
21:39:18 <monochrom> I wouldn't do a prove this early.
21:40:11 <boogalooga> I see
21:40:17 <monochrom> I would do a few examples like what happens to myFoldl (/) 1 [2,3,4] and what happens to foldl (/) 1 [2,3,4] and see whether they match up and get a feel of what's the intermediate steps.
21:40:43 <boogalooga> also, seems like the assignment might have wanted me to use just foldr
21:40:52 <monochrom> That experience will help see what's going on in the proof when I finally try.
21:40:53 <boogalooga> and not use reverse
21:41:11 <boogalooga> so I'll try implementing the function using only foldr
21:42:56 <mniip> 1508906223 [07:37:03] <monochrom> You prove by list induction that for every list xs, myFoldl f base xs = foldl f base xs.
21:43:24 <mniip> I was thinking of leaving out the proof that every finite list is either [] or (xs ++ [x])
23:32:15 <Lokathor> is there a way for a module to re-export another module without using an export list?
23:32:45 <Lokathor> specifically, i want to export everything defined in a module and also one of the imports it has
23:34:33 <osa1> I don't think so -- in fact I was considering submitting a ghc proposal for that at some point
23:34:40 <suzu> there is not
23:34:44 <Lokathor> dag
23:34:45 <Lokathor> oh well
23:35:03 <suzu> but you can wrap the module and that import into larger module and re-export from that
23:35:25 <suzu> maybe that's good enough for you
23:39:01 <Lokathor> i just wanted to avoid the export list thing since it will end up being long one day
23:39:03 <Lokathor> but no worries
23:39:10 <Lokathor> PS: what is a `pattern`?
23:39:32 <osa1> Lokathor: pattern synonym
23:39:43 <Lokathor> never heard of that
23:39:55 <tdammers> you can re-export modules wholesale though
23:40:05 <Lokathor> tdammers, in the export list, right
23:40:19 <tdammers> module P where (module P, module Q); import Foo.Bar.Baz as Q; -- more P stuff here
23:40:21 <tdammers> yes
23:40:22 <Lokathor> osa1, seems to be basicalyl like a constant?
23:40:39 <tdammers> so you still have an export list, but it doesn't list every single identifier you export, just entire modules
23:40:52 <osa1> Lokathor: no because it binds variables when used in a pattern
23:40:58 <tdammers> take a look at some of the custom preludes out there, they tend to use this trick a lot
23:41:01 <osa1> check the ghc manual I think it had some simple examples
23:41:06 <MarcelineVQ> it does https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#ghc-flag--XPatternSynonyms
23:41:16 <Lokathor> pattern GL_ACCUM_BUFFER_BIT = 0x00000200 -- this is the example i'm looking at
23:42:05 <MarcelineVQ> neat, like #define
23:42:10 <Lokathor> yeah
23:42:46 <Lokathor> tdammers, unless I can re-export a whole module _without_ defining an export list there's no point to any of that for my case :P
23:49:56 <tdammers> why is an export list so prohibitive?
23:55:59 <ekr_> hello, anyone using arch linux? i'm trying to do a "cabal install quickcheck", and it fails complaining that there's no System.Random module. I removed .cabal, .ghc, and ghc, ghc-libs, ghc-static and still no luck
23:56:43 <ekr_> any ideas?
23:58:12 <liste> ekr_: what Haskell packages did you install using pacman?
23:58:34 <liste> and did you remove all of them?
