00:03:07 <pierrot> But since I defined the signature as `lookupNode :: k -> Node k a -> a', then it always return a1, a2 or a3
00:03:33 * ski nods
00:04:03 <pierrot> So I don't understand when if fails a call like the one with "Canada"
00:04:08 <pierrot> it*
00:04:36 <ski> if it's to return a plain `a', then it can't fail
00:04:58 <ski> what gives ?
00:05:36 <pierrot> shoud it `be lookupNode :: k -> Node k a -> Maybe a' ?
00:05:45 <ski> tias ?
00:06:41 <poi___> :t '()
00:06:43 <lambdabot> error:
00:06:43 <lambdabot>     • Syntax error on '()
00:06:43 <lambdabot>       Perhaps you intended to use TemplateHaskell or TemplateHaskellQuotes
00:12:18 <pierrot> ski: :)
00:12:33 * ski blinks
00:12:33 <pierrot> lookup "Brasil" (Succ (Succ (Zero "Uruguay" (Node2 "Chile" (Node3 "Argentina" 43.9 "Brasil" 207.7 "Chile" 17.9) "Uruguay" (Node2 "Colombia" 48.7 "Uruguay" 3.4)))))
00:12:40 <pierrot> -> Just 207.7
00:12:59 <pierrot> lookup "Venezuela" (Succ (Succ (Zero "Uruguay" (Node2 "Chile" (Node3 "Argentina" 43.9 "Brasil" 207.7 "Chile" 17.9) "Uruguay" (Node2 "Colombia" 48.7 "Uruguay" 3.4)))))
00:13:03 <pierrot> -> Nothing
00:13:20 <pierrot> lookup "Canada" (Succ (Succ (Zero "Uruguay" (Node2 "Chile" (Node3 "Argentina" 43.9 "Brasil" 207.7 "Chile" 17.9) "Uruguay" (Node2 "Colombia" 48.7 "Uruguay" 3.4)))))
00:13:33 <pierrot> -> Just 17.9
00:13:38 <pierrot> lol
00:15:36 <ski> ok .. looks pretty close, though
00:16:02 <pierrot> as my lookupNode function always return an 'a'
00:16:18 <pierrot> it returns the most close to the given key
00:17:32 <jcarpenter2> i'm trying to write this but ghc doesn't like line 3: http://lpaste.net/359960
00:17:34 <pierrot> ski: thank you *very much* for your help and patience. it was very instructive for me.
00:17:38 <jcarpenter2> it doesn't recognize (t) as a 1-tuple
00:18:34 <jcarpenter2> Conflicting declarations, it says.  It thinks I'm saying "type instance TupleMap f t = f t"
00:18:48 <ski> jcarpenter2 : that's the same thing
00:19:20 <ski> `(t)' is the same as `t'. it's not an unituple type
00:19:24 <jcarpenter2> can i add some syntax to make GHC see it as a 1-tuple?
00:19:32 <dysfun> what's a 1-tuple?
00:19:38 <jcarpenter2> a tuple with 1 value
00:19:44 <dysfun> why would you have one of htose?
00:19:52 <jcarpenter2> reasons
00:20:07 <ski> i don't recall whether there's any unituple type in the guts of GHC
00:20:15 <jcarpenter2> i'm making a special Javascript thing
00:20:17 <dysfun> it's not a standard offering that i'm aware of
00:20:21 <ski> (there are *unboxed* unituples, though)
00:20:33 <jcarpenter2> okay, maybe i need to just make my own type for that case
00:20:42 <jcarpenter2> data Tuple1 t = Tuple1 t
00:21:19 <jcarpenter2> that's slightly annoying
00:21:20 <ski> pierrot : np. i hope i gave an appropriate amount of nudging in the right direction, in addition to the explanations
00:21:30 <jcarpenter2> ugh, it's so ugly now
00:21:32 <ski> @type (# () #)
00:21:33 <lambdabot> (# () #)
00:22:03 <jcarpenter2> what's that?
00:22:10 <ski> unboxed unituple
00:22:15 <jcarpenter2> ah i see
00:22:19 <ski> pierrot : i think it should be possible to get `Nothing', when the key's not in the tree
00:22:51 <ski> (i can see one obvious way that should work, i think. perhaps there's a neater way, though)
00:24:10 <ski> mayhaps this would be nicer, if the search-tree invariant you're using was changed in some way (i'm not sure)
00:25:00 <pierrot> ski: you gave me the most amazing help I've ever received on IRC. it was awesome. I really appreciate it :)
00:25:11 * ski bows
00:25:49 <pierrot> all your examples were very helpful and your orientation on this exercise was indispensable for me to get a solution
00:26:29 <ski> i hope you learned something :)
00:27:22 <pierrot> I did. And I'll reread all this conversation for sure in the future :)
00:31:17 <pierrot> Can I modify my code to still use fmap? I think I can't, because since I use fmap the signature of lookupNode must be `lookupNode :: k -> Node k a -> a'
00:31:22 <pierrot> and that never fails
00:31:45 <ski> well, the question is whether `lookupNode' should be able to fail or not
00:32:46 <pierrot> But if it never fails, I will always have this problem
00:33:00 <pierrot> or not?
00:34:39 <ski> if the `k' "before" a tree is the greatest key for that tree, then in `Node2 k0 a0 k1 a1', `k1' is the greatest in this tree. so `key' in `lookupNode' must already be less than or equal to `k1'. the only question is whether it's also less than or equal to `k0' as well
00:34:46 <ski> and similarly for `Node3'
00:35:36 <ski> so, it seems, with the invariant you have, `lookupNode' can't fail -- since it's a precondition of calling it that the key you're searching for is less than or equal to the greatest key for the tree
00:36:04 <ski> (and that precondition will get initialized by the `Zero k t' case, where you only investigate `t' when `key <= k')
00:36:37 <ski> i didn't think of this at first, hence i was thinking that your `lookupNode' would have to have the ability to fail
00:37:04 <ski> (.. but perhaps there's an alternate way to do the invariant where `lookupNode' would have to be able to fail)
00:38:17 * ski is still wondering about getting an exact match
00:46:54 <pierrot> ski: this is my current code https://glot.io/snippets/evdzkaj1gy
00:48:29 <pierrot> I don't like that `lookupNode' is not total since the guards don't consider all the possible cases
00:50:03 <pierrot> it also has the problem that, for example, `lookup "Ecuador"' returns a value when "Ecuador" isn't in the tree
00:50:24 <ski> well, it is total, given a precondition on the input
00:50:54 <ski> what if `lookup' returned both the key and the value ?
00:51:32 <ski> (or rather, renaming `lookup' into a helper function, which does the work, and making a new `lookup' that simply wraps that one)
00:52:06 <pierrot> yes, that would be a possibility. but lookup must return the value because that's the interface
00:52:16 <ski> yes, hence the rename
00:53:13 <pierrot> why returning the pair (key, value) would solve the problem?
00:53:44 <ski> if you have the most accurate key (the closest one), then you could do a final check for equality
00:54:20 <pierrot> oh, I see
00:54:25 <ski> it seems like there could be a nicer solutions .. but at least this would seem to work
00:57:23 <ski> hm .. i suppose one could handle the last tree level separately ..
00:57:36 <ski> not really elegant, though
00:58:59 <pierrot> but isn't that what we do with `lookupNode' ?
00:59:48 <ski> i mean like having two versions of `lookupNode'
00:59:59 <ski> one which uses `(<=)', and one which uses `(==)'
01:00:19 <pierrot> hmm I see
01:00:33 <ski> the latter would only be used for the last layer in the tree passed to `lookup' (which wouldn't be recursive itself, but call a recursive helper)
01:00:39 <pierrot> but how do you know when you're at the last tree level?
01:01:00 <ski> well, the first `Zero'/`Succ' corresponds to the last tree level
01:01:09 <ski> so, you'd handle that seprately
01:01:21 <ski> as i said, not exactly elegant
01:04:08 <ski> the recursion here is in some sense, backward
01:04:33 <ski> first you traverse the initial `n-1' levels, then the level under those
01:05:26 <ski> (as opposed to first reaching one level down, then letting recursion deal with all the levels beneath, as with a recursion on an "ordinary" tree type)
01:05:26 <pierrot> yeah, I realized that once my brain was already seriously damaged :P
01:06:07 <ski> if you want to, you could play with a CPS version of it
01:06:47 <pierrot> I don't even know what CPS is
01:06:53 * pierrot is googling
01:07:07 <ski> that's where you don't return the `a' directly, but rather pass it into a callback function (the "continuation"), which will in turn return the "final answer" (of a new, unknown, type)
01:07:13 <ski> Continuation-Passing Style
01:07:55 <ski> so, the point is that, instead of building up things to do, after the recursive calls, you'd instead put that stuff into the continuation that you pass to the recursive call
01:08:12 <ski> something like
01:08:31 <ski>   lookupCPS :: Ord k => k -> Tree k a -> (a -> o) -> Maybe o
01:09:17 <pierrot> I think I've have enough with the polymorphic recursion 😃. I need to assimilatea all this information
01:09:19 <ski> hm, or maybe
01:09:24 <ski>   lookupCPS :: Ord k => k -> Tree k a -> (a -> Maybe o) -> Maybe o
01:09:34 <ski> if the continuation needs the ability to fail
01:09:49 <ski> in the recursive case, you'll have `Node k a' instead of `a', as before. so your continuation will then have type `Node k a -> o' (or `Maybe o' instead of `o')
01:10:25 <ski> for the `elemsOf' case, the CPS would be
01:10:49 <ski>   elemsOfCPS :: PBBT a -> (a -> o) -> [o]
01:11:47 <ski> the recursive call would call `elemsOfCPS' at `PBBT (a,a) -> ((a,a) -> o) -> [o]' -- so you'd not get a `[(a,a)]' back as before
01:12:15 <ski> perhaps it's less of a help here than i was thinking, actually
01:12:50 <heronhaye> I'm writing some code to manipulate finite automata, and having trouble with the types. All my code deals with abstract [state] types, and converting between an NFA and a DFA with the powerset construction makes the new set of states of type [[state]]
01:13:16 <ski> (well, CPS can help with making early failure more efficient, "short-circuiting", skipping "interpretative" parent recursice calls, like exceptions skipping out to a handler)
01:13:19 <heronhaye> my issue is, how do I take the union of two NFAs with different "state types"?
01:13:32 <mniip> use an Either state type
01:13:34 <pierrot> ski: I'll look into it later
01:13:36 <heronhaye> because they won't typecheck if I try to union the set of states together
01:14:24 <heronhaye> mniip: so the set of states would be [Either stateA stateB]?
01:14:32 <mniip> I suppose so, yes
01:14:47 <heronhaye> right, that makes sense. thanks.
01:14:58 <mniip> what's your FA datatype looks like?
01:15:37 <heronhaye> mniip: https://hastebin.com/igugayebuf.pl
01:16:05 <mniip> I'm imagining  data DFA s t = DFA (s -> Bool) (s -> t -> s)
01:16:32 <mniip> and  data ADFA t = forall s. ADFA (DFA s t)
01:17:00 <heronhaye> sorry, what does the second line mean? 
01:17:16 <mniip> well a datatype of a DFA where we don't know/care about the state type
01:17:28 <ski>   ADFA :: DFA s t -> ADFA t  -- it means this
01:17:33 <mniip> you can have
01:17:47 <mniip> union :: DFA s1 t -> DFA s2 t -> DFA (Either s1 s2) t
01:17:49 <mniip> or you can have
01:17:56 <mniip> union :: ADFA t -> ADFA t -> ADFA t
01:17:57 * ski thinks an `ADFA' would be pretty useless, without a starting `s'
01:18:04 <mniip> ski, well yes, that
01:18:54 <heronhaye> huh
01:18:55 <mniip> and if you want to be super finite
01:19:02 <heronhaye> "forall" is syntax? what is this called
01:19:06 <mniip> you'd wanna have Eq s =>
01:19:15 <ski> (conceptually, `ADFA t' above is `exist s. DFA s t', iow a DFA for *some* state type `s', that has been forgotten/hidden)
01:19:15 <mniip> and use Map s (Map t s)
01:19:19 <mniip> and Set s
01:20:22 <ski> (therefore `union :: ADFA t -> ADFA t -> ADFA t' conceptually is `union :: (exists s. DFA s t) -> (exists s. DFA s t) -> (exists s. DFA s t)', where the there `s's bound by different `exists' may be different. if we call the first two `s0' and `s1', then the last one may be chosen by `union' to be `Either s0 s1')
01:20:50 <mniip> looks like it's a little early to explain that
01:21:24 <ski> mayhaps
01:22:05 <mniip> hmm
01:22:13 <mniip> what's the point of a FA union anyway
01:22:31 <mniip> oh right, it does make sense for NFAs
01:25:13 <heronhaye> can an ADFA be used just like a regular DFA then?
01:27:15 <ski> not quite, since the state type has been forgotten
01:28:23 <ski> using the data constructor `ADFA' on a value of type `DFA Int Char', will give you a value of type `ADFA Char', where there's no trace left of the fact that `Int' was used as a state type
01:29:22 <ski> so, if you have a value of type `ADFA Char', and unpack it using a pattern `ADFA dfa', then you only know that `dfa' has type `DFA s Char' for *some* (unknown) type `s'. there exists some type `s' here but you don't know what it is
01:29:53 <ski> it's abstract/opaque/hidden
01:31:06 <ski> (which is why the type `ADFA t' above conceptually wraps values of type `exists s. DFA s t')
01:34:18 <Taneb> ...accelerate code is tricky to debug
01:34:36 <Taneb> Actually I'm going to rephrase that as a question
01:35:03 <Taneb> I've written a short accelerate function that crashes at runtime and I'm unclear why. Are there any tools/guides for debugging it?
01:41:55 <Athas> Taneb: not that you'd like.  How does it crash?  Is there an error message?  Which backend do you use?
01:42:29 <Taneb> Athas, I'm using the interpreter in the "accelerate" package
01:43:37 <Taneb> There's an error message, it says "inconsistent valuation @ shared 'Exp' tree with stable name 17;\n  env' = [15]"
01:44:08 <Taneb> Which is... completely unhelpful to me
01:47:01 <pierrot> ski: this would be the implementation of your first suggestion (to make a function that returns the closest pair (key, value) and then make lookup to take the first argument): https://glot.io/snippets/eve16ofg1s
01:47:21 <pierrot> s/first/second/
01:47:32 <Athas> Taneb: that is a bug in Accelerate.
01:47:41 <Athas> (Or at least not an error I've ever seen before.)
01:50:24 <Taneb> Athas, https://arin.ga/wTFwUK is my code
01:50:38 <ski> pierrot : yea. you could note that `lookupNode' doesn't use `k'
01:51:14 <ski> so it would be possible to factor that projection out of the call to `lookupNode'
01:51:16 <pierrot> True. I could have used _ instead
01:51:23 <ski> matter of taste
01:51:45 <ski> (using `_' isn't what i meant :)
01:52:22 <Taneb> Athas, might it be because I'm building up arrays inside of a call to generate?
01:53:06 <pierrot> ski: what did you mean?
01:53:07 <Athas> Taneb: yes, that looks like nested parallelism.  But usually Accelerate gives a more meaningful error message in such cases.
01:53:14 <Athas> You should report it to the Accelerate devs.
01:53:25 <ski> something like `fmap (lookupNode key . snd)' ?
01:54:01 <pierrot> oh, yeah
01:54:14 <ski> as i said, matter of taste
01:55:15 <pierrot> I'm surprised of how much succinct is the code after all
02:01:09 <Taneb> Athas, I'll make a bug report
02:05:00 <Taneb> Athas, I've made a bug report for that
02:25:25 <erisco> succinctness is a good sign that you've done it right
02:27:28 <codeshot> Is there a reason there's no PairT ?
02:29:00 <mniip> codeshot, ReaderT Bool?
02:29:17 <codeshot> oh, I see
02:29:23 <erisco> what is a PairT?
02:29:25 <codeshot> I must understand ReaderT more
02:29:49 <codeshot> erisco, it would be a monad transformer for (a,)
02:30:06 <erisco> huh, my inclination is to think "so what"
02:30:22 <erisco> is it any different than Identity?
02:30:34 <codeshot> I don't know
02:30:41 <codeshot> I was curious about the omission
02:30:58 <codeshot> erisco, if you prefer I can avoid being curious when you're in the channel
02:33:05 <erisco> you were asking why it does not exist, and I am pointing out that it doesn't seem to be much different than Identity
02:34:04 <codeshot> I was responding to your previous reply of 17 seconds earlier 'huh, my inclination is to think "so what"'
02:35:06 <mniip> 1510396175 [13:29:35] <codeshot> erisco, it would be a monad transformer for (a,)
02:35:08 <mniip> err that's not
02:35:14 <mniip> that's WriterT a
02:35:38 <mniip> usually Pair means data Pair a = Pair a a
02:35:41 <mniip> not (,)
02:35:45 <codeshot> ah
02:35:59 <codeshot> My apologies for the confusion
02:36:10 <codeshot> CommaT
02:36:11 <mniip> WriterT a requires Monoid a
02:36:13 <erisco> you could also add something like  get :: PairT s m s  and  put :: s -> PairT s m ()  but this seems suspiciously familiar
02:36:33 <codeshot> mniip, it's sounding matchly
02:36:34 <mniip> erisco, no you can't
02:36:59 <mniip> erisco, get/put are StateT and this isn't StateT
02:37:05 <codeshot> speaking of State
02:37:25 <codeshot> how come modify doesn't let you return an answer as well as modifying state?
02:37:51 <codeshot> That results in doing two computations often when one would do
02:37:53 <mniip> because that's not needed for most cases
02:38:04 <mniip> "two computations" you mean two lines of code
02:38:17 <mniip> those sure don't map directly onto "computations"
02:38:18 <codeshot> no, two lookups in Map, for example
02:38:28 <mniip> use get/put
02:39:01 <mniip> modify' f = do s <- get; let (s', r) = f s; put s'; return r
02:39:03 <codeshot> I understood haskell won't automatically share the search inside the map data structure and will repeat it
02:39:19 <mniip> automatically no but if you write it right it will
02:39:23 <erisco> put s' = return (Pair (s', ()))
02:39:39 <erisco> but 'get' is not implementable, as I see it
02:39:41 <mniip> erisco, ap = ?
02:40:03 <erisco> why is that relevant?
02:40:15 <mniip> erisco, hoping you realize it's just WriterT
02:40:21 <codeshot> modify :: (a -> s b) is one case of (a -> s ()) because it's allowed for b == ()
02:40:33 <codeshot> the only difference is that the type is less generic
02:40:38 <mniip> sorry what
02:40:45 <mniip> a -> s b?
02:41:05 <codeshot> umm
02:41:11 * codeshot looks sheepish
02:41:30 * codeshot codeshot gives away his level of haskell experience
02:42:34 <codeshot> my memory can't keep all the types in it because I haven't got the full intuitive mapping yet
02:42:53 <erisco> I need to clean up my downloads folder oO
02:44:39 <erisco> "A Flexible Framework for Effects" by Tate & Leijen
02:44:52 <seccus> Hey, is it possible to `stack new` in an existing non-stack non-cabal project?
02:45:13 <erisco> as an example they go through the various combinations of reading and writing
02:46:45 <codeshot> erisco, thanks
02:48:05 <erisco> that's a paper about effect systems, not Haskell exactly … I was just telling mniip that I am aware :P
03:03:04 <Taneb> Athas, good news! I tried to write this function a different way and it works right off the bat!
03:04:01 <Athas> Taneb: it's unfortunately not the last time you'll get similar errors.  Not too many people write high-performance computational code in Haskell, so the libraries are not too well tested.
03:04:40 <Taneb> Athas, all I can do to improve that is learn the libraries, report my problems, and eventually learn to fix them
03:06:41 <erisco> and then learn how to make someone else fix them
03:07:04 <Taneb> :)
03:09:30 <Athas> Taneb: the basic design of Accelerate is pretty good, so I don't expect you'll have to wait too long for fixes.
03:11:02 <Taneb> Anyway, I have working matrix-vector, vector-matrix, and matrix-matrix multiplication functions!
03:13:55 <Taneb> The way I'm doing it now worked out far neater as well
03:23:27 <erisco> codeshot, it would be said that  a -> s ()  is a specialisation of  a -> s b  so in the other direction of your statement
04:04:20 <simendsjo> Hi. I have a simple test where the memory usage seems to grow very fast, but I need it to stay below 1M (it's a simple programming kata thing). I've tried running the memory profiler, but I'm unable to interpret the result. What are some good resources to learn about memory profiling and how to reduce memory usage? Here's my program and a bit of information: https://gist.github.com/simendsjo/502a9ff89a53b1bbd13a2890b3b068e5
04:04:37 <simendsjo> I've tried to sprinkle a lot of bang patterns in there without any luck.
04:07:19 <simendsjo> I actually have a time issue too. I was hoping GHC would be a supercompiler, knowing that sum [1..10] is the same as a previously computed sum [1..9] + 10 :)
04:07:49 <Rembane> simendsjo: You generally need to give GHC the names of things it should remember.
04:08:04 <drdo> I don't GHC does that level of magical analysis :P
04:08:07 <drdo> *don't think
04:08:30 <Rembane> simendsjo: For instance: let s19 = sum [1..10] in s19 + 10
04:08:31 <simendsjo> I don't expect it to, but it would have made my life easier :)
04:08:46 <Rembane> My example was really bad, nevermind.
04:10:22 <simendsjo> Looks like it runs in about 1.6M usage at most even when I increase the sample input. I just need it below 1 :/ And when I begin to cache to get below 1 second, I might need a bit more leeway too.
04:11:05 <drdo> simendsjo: I would focus on analysing the actual problem instead of doing those bruteforce sums
04:11:06 <Rembane> simendsjo: Do you read the whole file at the same time?
04:12:32 <simendsjo> drdo: Good point. The solution is probably to just do the math on paper. But this is the first time I'm looking at memory profiling in Haskell, which is quite interesting on its own.
04:19:11 <lyxia> "sum" is implemented with foldl, which is bad
04:19:44 <drdo> simendsjo: If you're getting constant small memory usage, I don't really see what's there to analyse
04:20:02 <drdo> if you want that fast you shouldn't be doing those sums in the first place :P
04:20:51 <fakenullie> foldl or foldl'?
04:21:47 <fakenullie> simendsjo: if you need profiler while solving kata, your approach is wrong
04:23:17 <simendsjo> Yes, I see that I cannot brute force it with those numbers. But the memory profiler looks quite limiting. It just gives me a static view of the program over time. Are there any tools which allows me to look at discrete times to see the usage? I've used dotMemory for C#, which is pretty nice.
04:26:20 <MarcelineVQ> How do you know it's under 1.6M, what's your method I mean. Two programs that I wrote just now claim 2.5M and 11M useage in ps aux and they're just   main = threadDelay 10000000
04:26:39 <MarcelineVQ> interestingly the 11M had -dynamic flag
04:31:41 <mxf> hi *, looking for a IPC module to do IO () actions on the main thread from any other thread (I'm using OpenGL, certain things I have to do on the main thread). Or should I just spin my own using MVars?
04:32:14 <drdo> mxf: You can use channels
04:33:43 <mxf> like Control.Concurrent.Chan?
04:34:33 <simendsjo> MarcelineVQ: I just looked at the generated top of the heap profile result. Shouldn't that be the maximum resident memory?
04:35:33 <int-e> MarcelineVQ: the dynamic version is expected to be larger (in terms of RSS) because it mmaps all the shared objects for its libraries, whereas the static version only links the parts that are needed.
04:36:03 <MarcelineVQ> simendsjo: I'm not sure but if you have a memory limit that might not be the value you have to keep under, depends how the limit is going to be enforced
04:36:30 <MarcelineVQ> int-e: neato thank you
04:37:39 <mxf> drdo, thanks this is more like what I need, I guess. Is there also a nonblocking version of channels?
04:38:26 <drdo> mxf: channels don't block on writes
04:39:01 <int-e> MarcelineVQ: on the other hand, the shared libraries are shared, so if you run several haskell programs at the same time, the libraries that they have in common will be loaded into memory only once. so there's a trade-off with no clear winner.
04:39:02 <mxf> drdo, but they do on reads
04:39:17 <drdo> mxf: There's a tryRead or something named similarly if you really need that
04:39:48 <drdo> mxf: https://hackage.haskell.org/package/stm-2.4.4.1/docs/Control-Concurrent-STM-TChan.html#g:3
04:39:51 <mxf> drdo, only available for MVars :/
04:40:03 <drdo> tryReadTChan
04:40:39 <mxf> hm, guess I'll use the stm, then :)
04:40:50 <mxf> drdo, thank you for your help
04:50:24 <rios> Hello everybody. I need to parse ByteString to a Day (from Data.Time). ByteStrings looks like "24.12.2017" or "1.1.2018". When I try (parseTimeOrError True defaultTimeLocale "%d.%m.%Y" "24.12.2017") :: Day a get correct answer. But with "1.1.2018" I get exception: parseTimeOrError: no parse of "1.1.2018". I have found that changing format from "%d.%m.%Y" to "%e.%m.%Y" helps with days but I can not find anything similar for months. Please 
04:50:24 <rios> can you help me?
04:50:48 <rios> Hello everybody. I need to parse ByteString to a Day (from Data.Time). ByteStrings looks like "24.12.2017" or "1.1.2018".
04:50:55 <rios> When I try (parseTimeOrError True defaultTimeLocale "%d.%m.%Y" "24.12.2017") :: Day a get correct answer. But with "1.1.2018" I get exception: parseTimeOrError: no parse of "1.1.2018".
04:50:57 <rios> I have found that changing format from "%d.%m.%Y" to "%e.%m.%Y" helps with days but I can not find anything similar for months. Please can you help me?
04:52:07 <rios> It seems like there is no format for month without leading zero.
04:56:06 <Taneb> It'd be cool if there was a version of accelerate with dimensions in the types
04:56:38 <MarcelineVQ> rios: modifiers   "%e.%_m.%Y"
04:59:56 <rios> MarcelineVQ: Thank you very much. That is what I was looking for.
05:00:00 <codeshot> I've found via hoogle and hackage that there are multiple ListT variants, some correct, some incorrect. How does one make sure you're using a correct one?
05:00:44 <ezyang> codeshot: First, why do you want ListT? 
05:00:55 <codeshot> to experiment
05:02:00 <codeshot> I'm toying with Psybur's memoising fib and trying incorporate list monad, IO, and State in one monad using lift and (lift . lift)
05:05:01 <ezyang> Second, list-transformer should be fine 
05:09:20 <codeshot> I don't plan to use code that is thought to be wrong. I have too much to learn at once anyway
05:09:51 <codeshot> If I make it more difficult by adding in problems that I don't understand then I'll be on the slow path for ever
05:11:06 <codeshot> Why will an incorrect list-transformer be unconditionally fine, and if it is, why do people say it's not correct?
05:11:18 <codeshot> and does list-transformer mean "ListT" ?
05:35:57 <dminuoso> codeshot: https://hackage.haskell.org/package/list-transformer
05:36:27 <dminuoso> Perhaps *shrugs*
05:37:01 <dminuoso> codeshot: As for your last question: https://wiki.haskell.org/ListT_done_right#Examples
05:38:37 <dminuoso> Though I think list-t is the common implementation
05:38:48 <ph88> can i build a project with stack that has just a cabal file ? or do i need to use cabal only ?
05:42:09 <Athas> Taneb: you mean sizes?  Like dependent typing?
05:42:37 <Taneb> Athas, yeah, precisely
05:43:01 <MarcelineVQ> ph88: the usual step for adding stack to packages with just a cabal file is  stack init --solver
05:43:03 <Athas> Is Haskell's type system strong enough for that to work?
05:43:08 <Taneb> Most of the errors in my code I was running into was because the sizes of the matrices I was constructing wasn't matching what I thought they were
05:44:08 <Athas> Multi-dimensional arrays are surprisingly tricky to support well, considering that they're usually seen as trivial.
05:44:35 <MarcelineVQ> isn't that what Shape's are in accerlate?
05:44:46 <dminuoso> Athas: Haskell has no dependent types
05:45:01 <tiganul80> hi, I'm looking for a function with this prototype f::[IO ()]->IO ()  
05:45:22 <dminuoso> tiganul80: Have you tried hoogle
05:45:23 <marvin2> :t sequence
05:45:25 <lambdabot> (Monad m, Traversable t) => t (m a) -> m (t a)
05:45:26 <erisco> const (return ())
05:45:39 <Athas> dminuoso: Stephanie Weirich would disagree!
05:45:50 <erisco> but probably you want  sequence_
05:45:58 <marvin2> yeah sequence_
05:46:08 <tiganul80> :t sequence_
05:46:10 <lambdabot> (Monad m, Foldable t) => t (m a) -> m ()
05:46:12 <marvin2> :t sequence (undefined :: [IO ()])
05:46:13 <lambdabot> IO [()]
05:46:24 <marvin2> :t sequence_ (undefined :: [IO ()])
05:46:25 <tiganul80> yes, this is it 
05:46:25 <Athas> MarcelineVQ: Accelerate models the rank, not the exact sizes.
05:46:26 <lambdabot> IO ()
05:46:49 <tiganul80> thanks
05:47:15 <Athas> In Accelerate, the type of a matrix multiplication will specify that the two arguments must have a rank of two, but it will not specify that the inner dimension of the first argument must match the outer dimension of the second argument.
05:47:33 <MarcelineVQ> Athas: I see thank you
05:50:25 <ph88> does someone know if this got any follow up?  http://homepages.inf.ed.ac.uk/slindley/papers/gvhs-draft-june2016.pdf
05:51:33 <MarcelineVQ> ferdinandvw has a couple takes
05:51:42 <MarcelineVQ> https://hackage.haskell.org/package/sessiontypes  https://hackage.haskell.org/package/sessiontypes-distributed
05:52:56 <MarcelineVQ> though, looking closer, dunno if it follows that paper as it's not linked in the docs
05:53:13 <kahlil29> how do I convert from a String to a Aeson.Data.Value type? 
05:53:33 <lyxia> what's in the String
05:53:42 <MarcelineVQ> Ferdirand: is that your lib or just a name coincidence?
05:55:05 <lyxia> kahlil29: can you expand on what you want that conversion to do
05:56:02 <kahlil29> lyxia: a search parameter that I need to convert to a JSON. {"tag": searchParam} using the object function to do `object ["tag" .= (searchParam)]` 
05:56:44 <kahlil29> but the search doesn't seem to be working so I have my doubts about whether that searchParam variable is getting inserted into the JSON correctly
05:56:51 <lyxia> kahlil29: you mean the string you have is "{\"tag\": ...}" ?
05:57:18 <lyxia> kahlil29: do you assume it's ASCII
05:57:53 <kahlil29> no no. I want to insert the string I have into a json of the structure of {"tag" : myString}
05:58:04 <kahlil29> lyxia: 
05:58:53 <codeshot> dminuoso, so my original question was how to make sure I'm not using a faulty ListT. Is that to merely avoid importing Control.Monad.Trans.List?
05:59:06 <lyxia> kahlil29: searchParam = String (Text.pack myString)  ?
05:59:32 <kahlil29> okay will try.
06:00:50 <codeshot> why to choose the list-transformer package instead of https://hackage.haskell.org/package/list-t-1.0.0.1/docs/ListT.html ?
06:26:54 <dminuoso> codeshot: list-t and because it does not make proper monads.
06:27:23 <dminuoso> codeshot: Monads have laws, and if a monad transformer does not give you a monad back, its going to bite you back later on when you make code decisions based on the assumption of such laws.
06:29:08 <codeshot> I didn't understand this sentence properly "list-t and because it does not make proper monads."
06:29:24 <codeshot> You prefer list-t of list-transformer ?
06:29:32 <codeshot> You prefer list-t over list-transformer ?
06:31:53 <dminuoso> codeshot: Did you bother to read the last link I gave up?
06:33:11 <codeshot> I didn't see it
06:33:24 <codeshot> what's with "did you bother" ?
06:34:08 <joncfoo> Is there a facility in GHC or another tool by which I can list all the values and functions in a file along with their types?
06:34:21 <lyxia> dminuoso: aren't both list-t and list-transformer both lawful
06:34:57 <joncfoo> (assuming the file compiles) - I don't need partial capabilities
06:35:00 <lyxia> joncfoo: ghci has a :browse command
06:35:18 <dminuoso> lyxia: Yes.
06:35:25 <dminuoso> lyxia: My point was just wrt ListT.
06:35:31 <joncfoo> sorry I should be more specific - I'd like to get a listing of all values within functions as well
06:35:38 <dminuoso> lyxia: And I just mentioned list-t over list-transformer out of popularlity. No other reason
06:36:43 <codeshot> <codeshot> why to choose the list-transformer package instead of https://hackage.haskell.org/package/list-t-1.0.0.1/docs/ListT.html ?
06:36:43 <codeshot> <dminuoso> codeshot: list-t and because it does not make proper monads. ... <codeshot>30 I didn't understand this sentence properly "list-t and because it does not make proper monads."
06:37:05 <codeshot> it's not a real conversation
06:37:14 <dminuoso> codeshot: Oh. My eyes were twisted.
06:37:25 <codeshot> it happens
06:38:55 <Arko_> hi
06:39:47 <lyxia> joncfoo: what for?
06:42:39 <joncfoo> lyxia, I'm working on some examples that I publish as html and I'd like to provide type information on hover for all the values, operators, and functions in the source - e.g. https://joncfoo.neocities.org/spock/hello.html
06:44:37 <nshepper1> Also there's LogicT when you mainly want a list transformer for nondeterminism
06:45:59 <codeshot> What are the odds of Control.Monad.Trans.List being replaced with a correct ListT?
06:46:43 <codeshot> Where I'm from, people rapidly start saying "I know my monad disobey's the monad laws but that's normal - look at Control.Monad.Trans.ListT"
06:48:10 <nshepper1> Heh
06:48:44 <nshepper1> It says it's deprecated, so maybe it will just be removed and let people choose their own from a library
06:51:53 <codeshot> That works for C++ but I'm not sure it'll work so well for Haskell. Ubuntu, for example, provides the faulty one but not the correct ones - while for C++ it typically provides the correct ones and less often the faulty ones
06:52:23 <codeshot> except small faults - but where people don't compose up to big programs those don't matter
06:53:33 <codeshot> And it doesn't tell you it's deprecated in ghci when you tab-complete your way to the module
06:53:59 <codeshot> while google and hoogle don't reliably tell you about all the things you need to know
06:54:13 <codeshot> everything's an island, linked only by maths papers
06:56:31 <haskellnoob> hi can I find any live online haskell classes
06:57:00 <Arko_> hi there
06:57:20 <Arko_> not sure but I'm interested too
06:57:44 <haskellnoob> Arko_:  ok
06:59:12 <haskellnoob> haskell is so easy for me when I concentrate but concentrating is the problem
06:59:25 <haskellnoob> I am also so lazy like haskell
06:59:34 <haskellnoob> I wish I know haskell without any effort
06:59:56 <Arko_> :)
07:00:18 <int-e> main = putStrLn "Hello, world!" -- that's how far most people get without any effort
07:01:20 <lyxia> joncfoo: Seems like you just need a parser, like haskell-src-exts provides
07:01:23 <erisco> drink more orange juice, but don't mix it with water
07:02:38 <haskellnoob> int-e:  till now I didnt learned to say "hello world" before that I leared lists/tuples/ defining data types
07:02:51 <__Lorn__> hi
07:04:11 <joncfoo> thanks lyxia, I'll have a look at it
07:04:29 <lyxia> joncfoo: actually, it is trickier if you need information about types and stuff...
07:05:26 <lyxia> joncfoo: template-haskell's reifyModule seems useful
07:05:53 <lyxia> joncfoo: or you could somehow postprocess the hyperlinked source generated by haddock
07:08:35 <haskellnoob> I am still doing haskell because I like its syntax ??  Haskell syntax is beautiful to me what about you guys ?  COmpared to Java c++ I like haskell syntax
07:09:03 <codeshot> haskellnoob, same here, but also I find the type system beautiful
07:09:32 <erisco> Semantics make a language nutritious; syntax makes a language palatable.
07:09:33 <codeshot> unfortunately C++, javascript, java, everything else has education done so much better
07:09:33 <haskellnoob> codeshot:  initially I didnt liked but I like  "something :: sometype"
07:10:06 <codeshot> maybe it's because of what's required in the eductation, but from a scale where 1 == effective, haskell's educational material is far behind
07:10:36 <codeshot> Just things like quality diagrams and animations embedded or linked in the right places in the function and type documentation would have a huge effect
07:10:50 <codeshot> interactive diagrams
07:10:59 <codeshot> that kind of thing
07:11:08 <haskellnoob> codeshot:  that is not a problem for me because I never stufied java/c++ before or have any formal computer education...Problem to only higly educated
07:12:22 <codeshot> haskellnoob, I will study your haskell education with enthusiasm
07:12:39 <haskellnoob> mine ??
07:12:45 <joncfoo> lyxia, AFAICT haddock doesn't store any type info in the docs themselves - thanks for the pointers though.  while type info on hover is nice I think I'll flesh out more examples :)
07:12:52 <codeshot> What's your educational, employment and philosophical background?
07:14:06 <haskellnoob> codeshot:  May be doesnt matter past now, All I needed is somehow learn haskell but I just lazy that is only the problem..and not able to focus on reading :(
07:14:51 <codeshot> I stop reading when it's using up my time and I don't know if it's worth it
07:15:09 <codeshot> They won't give you the time back once you find out it didn't help
07:15:25 <codeshot> I made that mistake on haskell as it was in 2001
07:15:38 <codeshot> time is the most expensive thing I have
07:16:34 <codeshot> but the haskell standard is to throw time away falling into a black hole every time you sit down to learn
07:16:39 <haskellnoob> codeshot:  I am not understanding what you are saying are you haskelller from 2001?
07:16:50 <lyxia> joncfoo: I mean that you can extract some from the links it generates.
07:16:55 <MarcelineVQ> it's almost like haskell is a research language or something
07:16:59 <codeshot> I tried, but the monad tutorials weren't helpful
07:17:11 <haskellnoob> I dont have any problem with learning haskell I felt so easy so far, but my problem is not with haskell but paying attention and reading
07:18:00 <codeshot> After a career that led me to more philosophical aspects of engineering (managing information, concepts, other's expectations, etc) I came to find category theory mapped to that and then was able to start to understand haskell
07:18:14 <sm> good day ladies and gentlemen
07:18:55 <haskellnoob> codeshot:  If I were doing anything from 2001 that is nearly 9 years then I would have been exceptional ...but I never studied any thing more than 10 days in my life so far
07:19:06 <codeshot> MarcelineVQ, no it's not, a research language has even better materials because there are no vocational routes to education
07:19:15 <sm> haskellnoob: sounds like you just need the right motivation
07:19:28 <MarcelineVQ> I don't mean a language for doing research, I​ mean a language that is the research
07:19:45 <codeshot> I stopped trying haskell
07:19:48 <codeshot> for a long time
07:19:59 <__Lorn__> 3hi
07:20:04 <codeshot> me too
07:20:12 <MarcelineVQ> __Lorn__: 3hey
07:20:30 <haskellnoob> sm:  I have motivation I like chatting watching movies etc than reading something weird to you guys
07:20:42 <codeshot> If it's research it must be explained very well because you can't get people delivering products with senior engineers showing you the ropes
07:20:55 <codeshot> if it's not explained very well then it can't be research
07:21:31 <__Lorn__> 5:)
07:21:35 <codeshot> it could be a time sink though
07:21:49 <codeshot> maybe it's research into time sinking
07:21:55 <haskellnoob> when I was in school, my maths/physics teacher teach and I never studied read anything..with what I heard in classes I passed all my exams
07:22:05 <haskellnoob> that is how I have no practise of reading
07:22:12 <sm> haskellnoob: great! be happy :)
07:22:40 <haskellnoob> reading/studying is something I have never did in my life which is not good to me now
07:22:58 <sm> not everyone learns by reading
07:23:05 <haskellnoob> now I must focus and read and learn on own which really I am not able to do
07:23:31 <haskellnoob> sm:  May be school I should have developed discipline which I failed
07:23:37 <sm> reading group ? reading buddy ? (and, why must you ?)
07:23:49 <codeshot> haskellnoob, that's no problem, haskell authors are no good at writing. They think it's all about words describing a program line by line from top to bottom like a football commentary
07:23:56 <xcthulhu> haskellnoob: What book are you reading now?
07:24:23 <haskellnoob> learnyouhaskell I finished 3 chapters 
07:24:33 <codeshot> that's because of the literate programming fallacy
07:24:49 * sm couldn't read that one either
07:25:13 <haskellnoob> I finished in 2 weeks but I feel so lazy to move next
07:25:13 <codeshot> haskellnoob, the best material I've seen
07:25:28 <codeshot> followed by a some good folks here
07:25:51 <haskellnoob> codeshot:  ?? haskellbook you say ?
07:26:03 <codeshot> haskellnoob, if you get tired of reading on a subject you're excited about then there's something wrong with the material
07:26:17 <haskellnoob> codeshot:  I like typing than reading
07:26:20 <codeshot> Boredom is an economic emotion
07:26:46 <codeshot> haskellnoob, no I said "haskellnoob"
07:27:15 <xcthulhu> haskellnoob: Maybe try working on a project in Haskell, then hit the books again
07:28:13 <haskellnoob> xcthulhu:  is that really possible?
07:28:16 <sm> @quote FAQ haskell-cookbook
07:28:16 <lambdabot> FAQ says: What's a fast book for learning haskell ? Haskell Tutorial And Cookbook (HTAC) https://leanpub.com/haskell-cookbook
07:29:00 <xcthulhu> haskellnoob: TBH I haven't written any haskell since 2012, but then for my own project I wanted to write it in Haskell, so now I'm hitting the books and learning lenses and monad transformers
07:29:00 <mauke> I'm a fan of the "write 2000 useless tiny programs" approach
07:29:02 <codeshot> haskellnoob, read chapter 9
07:29:03 <haskellnoob> xcthulhu:  because haskell is very different language and I think learn by doing doesnt apply here
07:29:15 <xcthulhu> haskellnoob: lol watch me
07:29:33 <sm> we should have a Basic Computer Games for haskell
07:29:36 <codeshot> and play around with all the comparitive examples, and push a little futher to explore what changes you can make and where it fails
07:29:57 <haskellnoob> codeshot:  chapter 9 where which book ?
07:30:26 <xcthulhu> haskellnoob: Here's a dumb exercise in Haskell - write a program to compute the millionth fibonacci number.
07:30:38 <haskellnoob> xcthulhu:  Can you help me to read a csv from haskell 
07:31:04 <xcthulhu> haskellnoob: Uh... all of sudden I remembered I was procrastinating
07:31:07 <mauke> csv is a really, really hard problem regardless of language
07:31:13 <haskellnoob> I think I tried that but felt hard with haskell without basics
07:31:30 <mauke> I do not recommend it as an exercise for beginners
07:32:22 <codeshot> haskellnoob, your book, learnyouahaskell
07:33:59 <codeshot> mauke, Is that because of lots of nuance?
07:34:08 <codeshot> I never noticed csv being difficult before
07:34:09 <xcthulhu> haskellnoob: Okay, so I recommend breaking that problem down - first parse the file into an array of lines
07:34:25 <xcthulhu> haskellnoob: (you can use `getLine`)
07:34:32 <codeshot> or because of ambiguity - which doesn't seem to have any standard tools in haskell
07:34:55 <mauke> xcthulhu: no, you can't
07:34:59 <haskellnoob> codeshot:  now I see and basically in other languages that is chapter 1 printing helloworld is first program and I am liking haskell because it is different
07:34:59 <mauke> fields can contain literal newlines
07:35:17 <codeshot> something I'm continually suprised by given that in haskell this is just maths in operation which we've been doing for hundreds of years and if we don't know how it goes by now then there's some funnybusiness going on
07:35:46 <xcthulhu> mauke: Or we could assume that they don't and not worry about that
07:35:56 <mauke> yeah, but then you're not doing CSV
07:36:05 <xcthulhu> easy-CSV
07:36:08 <xcthulhu> He just wants to learn
07:36:16 <xcthulhu> You can take it easy-CSV I think
07:36:37 <mauke> ok, then we can also assume a fixed delimiter (',')
07:36:38 <codeshot> haskellnoob, yep, but if you've got switched off then something a little practical could be a help
07:36:46 <codeshot> also, consider looking at FRP
07:37:19 <codeshot> Maybe explore what these do: https://github.com/gelisam/frp-zoo
07:37:29 <codeshot> This got me zinged again
07:37:33 <haskellnoob> xcthulhu:  my point is I have some data in csv read it then plot that data and do some matrix multiplications
07:37:37 <haskellnoob> I feel so hard
07:38:29 <mauke> if it's really just numbers separated by commas, one record per line, it gets a lot easier
07:38:46 <codeshot> mauke, newlines are easy if you look for quotes before newlines
07:38:47 <haskellnoob> mauke:  Right now just numbers
07:39:04 <xcthulhu> haskellnoob: Okay, so like I said, after you parse the file into a `[String]`, parse each string into `http://en.wikipedia.org/wiki/Special:Search?go=Go&search=String`, and then convert each string in that into an int or double
07:39:16 <mauke> codeshot: what
07:39:18 <xcthulhu> umm...
07:39:28 <xcthulhu> I meant `[ [ String ] ]`
07:39:40 <xcthulhu> I need another IRC client
07:39:44 <codeshot> newlines in fields isn't a problem if you parse by looking for either newline or quote
07:40:01 <mauke> codeshot: you're welcome to show me your code and I'll write you a CSV that breaks it
07:40:12 <codeshot> I don't have any to hand
07:40:19 <mauke> :t map (splitOn ",") . lines
07:40:20 <lambdabot> String -> [[[Char]]]
07:40:27 <codeshot> but if I accepted that challenge I bet you wouldn't break it :)
07:40:37 <mauke> :t map (map read . splitOn ",") . lines
07:40:38 <lambdabot> Read b => String -> [[b]]
07:40:46 <codeshot> unless there is the aforementioned ambiguity problem
07:41:08 <xcthulhu> haskellnoob: If you look at what mauke is typing up there it's a good start
07:41:34 <xcthulhu> (don't worry about poorly formatted CSVs)
07:42:18 * mauke rubs hands, mentions documents with text encodings that vary *between fields*
07:42:28 <haskellnoob> xcthulhu:  Ok  reading chat again to understand
07:49:35 <haskellnoob> xcthulhu:  I read chat again and I didnt understand on google search I found something on hackage like cassava/Data.csvetc anyway to understand them also I would need some more basics I guess
07:58:04 <haskellnoob> disconnected 
07:58:24 <rios> \query lambdabot
07:59:47 <mauke> /, not \
08:11:18 <Psybur> @pl \f s -> runStateT (mapM (\x -> fmap (*3) (f x)) s
08:11:18 <lambdabot> (line 1, column 50):
08:11:18 <lambdabot> unexpected end of input
08:11:18 <lambdabot> expecting variable, "(", operator or ")"
08:11:54 <Psybur> @pl \f s -> runStateT (mapM (\x -> fmap (*3) (f x)) s)
08:11:55 <lambdabot> (runStateT .) . mapM . (fmap (3 *) .)
08:12:49 <Psybur> @pl \f s l -> runStateT (mapM (\x -> fmap (*3) (f x)) l) s
08:12:49 <lambdabot> flip . (runStateT .) . mapM . (fmap (3 *) .)
08:13:11 <sm> haskellnoob: do you want to write a csv parser from scratch or just parse csv ? http://hackage.haskell.org/package/csv-0.1.2/docs/Text-CSV.html is very easy
08:13:18 <Psybur> Dont think thats more readable haha
08:13:39 <sm> and you could look at its source
08:14:35 <haskellnoob> sm:   just parse csv and then plot graphs...but now I am learning chapter 4(more funsctions) in LYAH 
08:15:09 <haskellnoob> sm:  I wantedto do that so that I implement a project in haskell but i feel it is hard without basics
08:15:28 <sm> haskellnoob: have you looked at the other books we suggested ?
08:15:54 <sm> HPFFP and HTAC in particular ?
08:16:06 <haskellnoob> sm:  I am so soory I might missed that chat/ I never noticed other books you mentioned
08:16:27 <sm> @quote FAQ haskell-cookbook
08:16:28 <lambdabot> FAQ says: What's a fast book for learning haskell ? Haskell Tutorial And Cookbook (HTAC) https://leanpub.com/haskell-cookbook
08:16:35 <sm> @quote FAQ haskellbook
08:16:35 <lambdabot> FAQ says: What's a thorough book for learning haskell ? Haskell Programming From First Principles (HPFFP) http://haskellbook.com/
08:16:54 <sm> a lot of people have said they read LYAH and still didn't know how to code haskell
08:17:54 <fr33domlover> Hey sm
08:18:19 <Psybur> Does the State monad rely on its functor and applicative instances? From what I've been seeing in the source it doesnt seem like it
08:18:23 <sm> hey fr33domlover
08:18:33 <Psybur> Or would I say its classes?
08:19:03 <haskellnoob> sm:  but now I am confident with lists comprehensions able to write any list/list comprehension etc so far covered in in LYAH and that haskellbook I checked it is not free and 1000pages the other book also not free :(
08:19:08 <Psybur> The State monad IS_A applicative IS_A functor. And applicative/functor in this case are classes or instances?
08:19:49 <codeshot> haskellnoob, FYI, I never said "haskellbook", I said "haskellnoob"
08:19:50 <fr33domlover> Psybur, they're classes and State is an instance of them
08:20:19 <fr33domlover> sm, how are you doing? I haven't been around much in a long time ^_^
08:20:22 <haskellnoob> codeshot:  not you sm mentioned two books
08:20:28 <codeshot> oh
08:20:56 <fr33domlover> haskellnoob, there is also the Haskell Wikibook, I used it to learn Haskell and it was great
08:21:10 <Psybur> So does the State monad instance rely on Functor and Applicative? Now every Monad is a Functor and Applicative, but does not necessarily depend on definitions in its parent class?
08:21:32 <Psybur> I dont see fmap being used in state's applicative/monad instances
08:24:49 <haskellnoob> sm:  fr33domlover  I really never wanted another book as I am more lazy to read any book...but however I really appreciate any haskell book that teaches along with data science/Machine Learning/Artificial Intelligence etc.....Like AI in Haskell etc 
08:25:22 <haskellnoob> or something that have real world project 
08:26:00 <fr33domlover> haskellnoob, personally I read the book and at the same time experiemnted with Haskell using the new skills I got
08:26:28 <fr33domlover> haskellnoob, for example my first project was a dumb program that lets you get and set a number or so
08:26:30 <haskellnoob> fr33domlover:  that haskellwikibook you mentioned
08:28:37 <haskellnoob> fr33domlover:  ACtually I am taking a Machine Learning course on edx and wanted to solve home work problems of it I checked something called hmatrix but I am not understanding how to use...but now when trying to read haskell from scratch it is lengthy
08:30:10 <fr33domlover> haskellnoob, Haskell is a language with a relatively steep initial learning curve, many new concepts to learn and understand, you need to take the time to follow at least 1 of these books, at least the first few chapters
08:31:32 <haskellnoob> in my home work I have a dataset which is a .csv file which I need to read and plot a graph then use something called gradient descent algorithm to fit a straight line...I wanted to implement it in haskell because of which I am learning haskell but I feel it is so lengthy......if languages like python even if I dont learn them I can get a lot of code internet and when I read it I can understand what is happening but with haskell
08:31:45 <haskellnoob> ok fr33domlover 
08:32:46 <sm> haskellnoob: HTAC can be read for free
08:34:03 <haskellnoob> sm:  https://leanpub.com/haskell-cookbook  ?
08:34:13 <ruuns> Wouldn't a good numerical library sufficient? (maybe hmatrix). I've done a machine learning course on the university and we just used octave/matlab and matplotlib/python for visualisation :)
08:34:34 <haskellnoob> ruuns:  I am using octave
08:34:39 <haskellnoob> wanted to try haskell
08:34:54 <haskellnoob> ruuns:  any ML books based on haskell
08:34:55 <codeshot> Psybur, it's common to use a type-specific function instead of the typeclass methods
08:35:04 <sm> yes.
08:35:23 <sm> Free To Read Online
08:35:25 <codeshot> because, although it's often helpful to be generic, when you're definitely not generic then you can sometimes be wasting your time to use generic functions
08:35:32 <haskellnoob> I cant read free
08:35:51 <haskellnoob> can u give me url I will just check once as I see NLP topic mentioned in contents
08:36:09 <sm> and you're right, HPFFP is expensive, though the authors have been known to discount it heavily
08:37:25 <fr33domlover> haskellnoob, also play with GHCi, keep it open and try things and see what happens
08:37:34 <sm> https://leanpub.com/haskell-cookbook -> Free To Read Online -> https://leanpub.com/haskell-cookbook/read 
08:44:31 <Psybur> codeshot, do you happen to have an example of where you could use a generic function from a typeclass but its better not to?
08:51:03 <haskellnoob> Thanks sm  I already started playing with it
08:51:15 <exio4> Psybur: if you are using the same function (from a typeclass) many different times, but with different types, it might become a bit hard to read/follow
08:51:20 <exio4> @type fmap fmap fmap
08:51:22 <lambdabot> (Functor f2, Functor f1) => (a -> b) -> f1 (f2 a) -> f1 (f2 b)
08:51:23 <exio4> @type fmap . fmap
08:51:25 <lambdabot> (Functor f2, Functor f1) => (a -> b) -> f1 (f2 a) -> f1 (f2 b)
08:51:54 <codeshot> Psybur when you're saying "append" while typing "<>" - there you should use "++"
08:53:19 <codeshot> if your function is a list appender and nothing else, write ++ - if it is merely a combiner of multiple values according to a regular pattern then use <>
08:53:25 <nshepperd> i prefer to use the generic functions if available
08:53:54 <nshepperd> it means less search-and-replace if i want to change the type later
08:53:55 <codeshot> I often do, but only because it's good to learn their uses and limits
08:54:10 <codeshot> when I want to say "list append", I'm going to use (++)
08:54:39 <codeshot> However, I'm finding that most problems are neater using functors, etc and thus generic functions
08:55:30 <codeshot> but it doesn't make sense to do that when it only works with list append
08:55:33 <Psybur> nshepperd, thats a good insight
08:55:45 <Psybur> And I also see ++ being clear for appending instead of <>
08:56:07 <Psybur> > "abc" <> "def"
08:56:09 <fendor> @type (fmap fmap fmap)
08:56:09 <lambdabot>  "abcdef"
08:56:10 <lambdabot> (Functor f2, Functor f1) => (a -> b) -> f1 (f2 a) -> f1 (f2 b)
08:56:16 <nshepperd> otherwise i guess it depends
08:56:21 <nshepperd> readability is subjective
08:56:23 <fendor> @type (fmap fmap fmap) (+1) (Just (Just 2))
08:56:24 <codeshot> Psybur, if you're doing something that would work with preprend, or sorting items directly into a tree, then use <>
08:56:25 <lambdabot> Num a => Maybe (Maybe a)
08:56:31 <fendor> > (fmap fmap fmap) (+1) (Just (Just 2))
08:56:33 <lambdabot>  Just (Just 3)
08:56:51 <codeshot> but if it's a list with a specific order or else your function is wrong then use (++)
08:57:30 <codeshot> this way you can leave the container type as m a instead of [a] and let the context in which it's used determine the actual data structure
08:57:43 <nshepperd> if I'm using bytestrings or Text i'm definitely going to use (<>) because who even has time to import the special append operator for those types
08:57:50 <codeshot> and you can program assuming that knowing that when it won't work you'll get a type error because there you used (++)
08:58:51 <nshepperd> oh, there isn't even an operator but there's an append function
09:01:34 <Psybur> Which do you guys prefer? foldr (*) 1 [1,2,3] or getProduct $ foldMap Product [1,2,3] ? :D
09:01:52 <Psybur> or product [1,2,3] :D
09:02:48 <nshepperd> foldl' (*) 1
09:02:55 <codeshot> what's the goal of the function?
09:03:04 <nshepperd> actually maybe that's the same as product
09:03:04 <Psybur> Multiply everything together
09:03:07 <codeshot> are the numbers representing some items?
09:03:13 <codeshot> or are you doing pure maths?
09:03:16 <nshepperd> if you'with -O
09:03:19 <Psybur> Pure math :D
09:03:27 <codeshot> product [1,2,3]
09:03:51 <codeshot> unless the operator is an option
09:03:51 <fr33domlover> what codeshot said :)
09:04:44 <fr33domlover> Psybur, the getProduct thing is good when you gradually accumulate values
09:04:58 <codeshot> Psybur, of course I know you're trying to learn and I get the impression your drive is similar to mine, so I'd suggest doing all three and seeing whether it fits until you're working in production
09:04:59 <fr33domlover> and finally extract the product from there
09:06:48 <codeshot> getProduct is also good when you want to program in an optimisation - eg, implementing geogebra where you want to do proofs
09:07:42 <Psybur> Geogebra? Thats a new word for me heh
09:07:51 <codeshot> it's a geometry app in java
09:08:39 <codeshot> really good *except* it doesn't seem to have re-ordering functionality (such as you would use to compile non-strict lambda to strict machine instructions)
09:09:21 <codeshot> and some other things where ambiguities are enforced preventing certain features of a diagram
09:10:04 <codeshot> while Haskell's very mathematical nature would be an amazing language to implement the same (using an FRP package to render and accept interaction)
09:14:12 <erisco> all the ways to write fac are here https://www.cs.utexas.edu/~cannata/cs345/Class%20Notes/10%20Haskell%20Programmer%20Evolution.html
09:22:00 <Psybur> erisco, I lost it at refold
09:22:30 <Psybur> Lost it as in started to laugh, lost the game
09:22:45 <erisco> something something all computation can be expressed as an unfold and fold
09:23:20 <Psybur> This is where ertes pops in with some crazy fold
09:26:50 <codeshot> Does anyone have a good recommendation for FRP libraries
09:27:15 <codeshot> I'd like to avoid being forced into IO (so I can use FRP on pure test samples)
09:27:56 <jared-w> I'm not quite sure that FRP can really be done "pure". Like, how do you react to an event that you can't sample/poll/monitor?
09:28:05 <codeshot> And I'd like to be able to use standard functions and operators where they make sense (ie, it should have all the right instances)
09:28:40 <codeshot> I could query an FRP value giving a time
09:28:47 <jared-w> Time is IO though :)
09:29:04 <codeshot> no, currency is IO
09:29:27 <jared-w> https://github.com/gelisam/frp-zoo  does this help at all?
09:29:35 <codeshot> not entirely
09:29:43 <codeshot> I have some tools to judge the advice I receive
09:30:14 <codeshot> but it's not enough to decide which ones work out really well and which don't, and I imagine someone here has already spent the time necessary to figure it out
09:30:25 <codeshot> in which case it doesn't make sense for me to figure it out
09:30:48 <codeshot> because then you're all delayed in receiving any economic advantage I'll deliver from my skills development
09:32:13 <jared-w> Reflex is typically the FRP library I see used the most, honestly
09:33:34 <jared-w> although reactive-banana is another one I hear about a lot
09:34:51 <codeshot> ok, thanks
09:34:58 <codeshot> I'll go study them carefully
09:35:19 <codeshot> Early googling only gave me grapefruit which I enjoyed playing with
09:35:22 <jared-w> There's also a frp channel on freenode somewhere. #haskell-frp I think it is
09:35:26 <codeshot> ooh
09:35:28 <codeshot> ta
09:35:59 <jared-w> There's a large foxus on reflex and I know that #reflex-frp is a thing, but they also probably know more about FRP libraries for haskell in general
09:37:42 <codeshot> reflex training materials are a no
09:39:04 <jared-w> Reflex has decent learning materials, doesn't it?
09:39:31 <codeshot> I went to their hackage page and found nothing, plus their linked webpage and found git sources
09:39:44 <codeshot> the links there were not promising
09:40:12 <jared-w> queensland FP lab has quite a bit of stuff out there. It's a little hard to find unfortunately
09:40:42 <jared-w> https://blog.qfpl.io/projects/reflex/
09:41:12 <jared-w> The series of blog posts at the top is pretty great, and there's all of the rest of the blog posts as well
09:41:37 <codeshot> But the blog post tells me about what the person writing it needed to know at specific times
09:41:47 <codeshot> I need to go from what I need to know at this time
09:41:59 <codeshot> like msdn
09:42:01 <ertes> codeshot: i recommend reflex
09:42:02 <jared-w> oh, all of these blog posts ar tutorials, sorry for not being clear
09:42:27 <ertes> codeshot: it's a flexible, efficient library with a pure semantics
09:42:32 <codeshot> you mean where they say "type this" "then this" "then this", now run it?
09:42:57 <jared-w> No, they go step by step through the philosophy of FRP, how it works, how the parts of the library work together, etc
09:43:19 <jared-w> I have a high threshold for considering tutorials useful
09:43:29 <codeshot> ertes, is it intuitive for a haskell dev? You've probably seen my level (functors, monads, monad transformers, no deep mathematical terminology)
09:43:30 <hexagoxel> i think neither reflex nor reactive-banana have non-IO stuff by default. The respective "reference implementations" might be, but they won't be optimized.
09:43:44 <codeshot> jared-w, this sounds like good stuff
09:43:51 <codeshot> I'll put it at the top of my list
09:44:33 <ertes> codeshot: you can learn the full semantics from Reflex.Class, and the way you connect an FRP system to the real world is via Reflex.Host.Class
09:44:50 <ertes> codeshot: i can explain it in more detail when i get back
09:45:22 <hexagoxel> (i.e. reflex:runSpiderHost is IO, as is banana:compile/actuate)
09:45:28 <codeshot> ertes, thanks. The site jared-w pointed me at is by far the best haskell site I've ever seen
09:45:38 <codeshot> so probably won't need much help but thanks anyway
09:53:06 <jared-w> Kinda hilarious that this qualifies as the best site ever. Sometimes I forget how low the bar is for Haskell until I wander off into web dev stuff for a bit and then it's quite noticeable again
09:54:29 <codeshot> +1
09:54:58 <codeshot> I think we need better tools suited to Haskellers
09:55:02 <jared-w> Like, webdev is a steaming pile of ugly and horrific shit, but it's an incredibly polished shit-turd and there's a ton of machinery all over the place to make things easier to use and easier to get stuff done
09:55:25 <codeshot> While haskell should scale up to the rafters because of the lambda calculus, and yet ...
09:55:45 <drdo> jared-w: I thought they said you can't polish a turd!
09:56:07 <codeshot> you can lacquer it
09:56:16 <jared-w> drdo: they do a fine job of polishing the turd; the problem comes when you try to use the turd. If it cracks open in any way all that stink comes flying out again :p
09:56:26 <Tuplanolla> Material physics tells us that you can polish any solid surface, drdo.
09:56:38 <codeshot> turds aren't solid
09:56:48 <drdo> Depends on what you eat!
09:56:52 <codeshot> oh ho
09:56:57 <Tuplanolla> Great insight.
09:57:07 <jared-w> Also, LC merely means that the underpinning of haskell is "fairly theoretically sound" but the von neumann machine architecture (ie the turing machine) is also similarly sound and consistent
09:57:16 * codeshot goes to eat some different things... grabs a tupperware box for later
09:57:59 <jared-w> Haskell's scaling comes, I think, mostly from local reasoning. The ability to locally reason (accurately) about code is a *huge* thing people don't talk enough about. I hate working in JS sometimes because no matter how const and immutable I make crap, state still changes somewhere 7 layers down if I'm not super careful
09:58:25 <jared-w> me to JS: "does this do what I want?" JS: "maybe... maybe not... maybe go fuck yourself"
09:58:36 <codeshot> lol
09:58:54 <Hafydd> data Bool = True | False | FuckYourself
09:59:02 <drdo> jared-w: well, lazyness kinda puts a nail in the local reasoning coffin
09:59:04 <int-e> :-(
09:59:15 <jared-w> drdo: I'd say that laziness actually helps a lot
09:59:26 <drdo> How so?
09:59:28 <jared-w> with referential transparency + laziness you get the property that equational reasoning is /always/ valid
09:59:48 <codeshot> if there were a neato "delve :: (a -> b) -> Hask (a -> b)"
09:59:50 <jared-w> extracting something in a function to a where clause will always work correctly. That's huge
09:59:56 <drdo> oh sure, things will work, but thinking about time and especially space is harder
10:00:02 <codeshot> so we could lazily reason about strictness
10:00:04 <jared-w> https://www.reddit.com/r/haskell/comments/78zuul/documentation_for_simplified_development/  <-- this is the best method to set up reflex that I know of, codeshot. Tooling in haskell is a bit tricky :p
10:00:24 <codeshot> I meant tooling for training systems
10:00:39 <jared-w> drdo: but that's not the type of reasoning you're usually doing. Local reasoning is super hard (usually) when reasoning about correctness. It's trivial in Haskell and that's huge to scaling
10:00:49 <cocreature> jared-w: tbh I’m not sure if ghcjs is a good example of the general state of Haskell tooling
10:00:53 <jared-w> Unfortunately you trade local reasoning about space and time for local reasoning about correctness and behavior
10:01:12 <drdo> jared-w: I'm not sure lazyness has anything to do with reasoning about correctness
10:01:16 <jared-w> cocreature: it's not, but it's a necessary wart to deal with if you want to get anything done with reflex, web stuff, etc... So, like it or not, it gets lumped in with Haskell
10:01:41 <jared-w> drdo: It's the laziness + referential transparency = unconstrained ability to equationally reason that gives you that local correctness reasoning properties
10:01:50 <codeshot> outside of haskell people avoid scaling code, so they scale up the pure maths in the heads of scaled up developer-base and the ones that have booboos with the least chaotic behaviour are the winners
10:02:04 <jared-w> Without laziness, equational reasoning is not always valid
10:02:10 <codeshot> the developers don't even know that pure maths has been put into their heads
10:02:31 <drdo> jared-w: Technically true, but ultimately not important in practice I'd say
10:03:37 <jared-w> I suppose. After all, the equational reasoning only ceases to be valid in the presence of bottom in a non-lazy language... PureScript seems to do pretty well for scaling, although I haven't seen any truly massive things in it yet
10:07:28 <monochrom> For scaling I go to my dentist. <duck>
10:07:45 <jared-w> lol
10:08:27 <drdo> About lazyness, what's the nice way to debug stuff in haskell?
10:08:40 <drdo> I'm a big fan of printf debugging
10:08:47 <monochrom> ghci's debugger and Debug.Trace help.
10:09:16 <jared-w> Honestly, equational reasoning... There's /some/ stuff out there, some tracing stuff you can do, etc. But most of it is pretty terrible compared to what people are used to in languages like Java
10:09:41 <drdo> I've never really used any debugger in any interesting way
10:09:59 <drdo> But losing the ability to sprinkle some printfs here and there really harms my debugging ability :P
10:10:24 <hpc> debugging most things is fairly similar in haskell (algorithmic complexity and correctness being the main ones i have to do)
10:10:36 <hpc> debugging issues with strictness/laziness is totally different from debugging say, a malloc leak in C
10:10:40 <hpc> despite them having similar symptoms
10:10:47 <drdo> I'm only talking about correctness now
10:10:50 <acidjnk> I was fine with vim and no debugger for my own programs in Java, but when I started to work on code of others, I needed a debugger, flow analysis and so on.
10:11:02 <hpc> ah then yeah, equational reasoning is the best skill to work on
10:11:48 <hpc> you only really need to bring out printf-style debugging when the types aren't helping you
10:12:00 <monochrom> But I'm hardcore and I debug by knowing lazy evaluation, and when code optimization may deviate from my naive lazy evaluation model, I read Core.
10:12:22 <hpc> like if you haven't structured your problem as well as you could have (fixable), or if you have a massive tangle of numeric code (not always fixable with types)
10:12:29 <drdo> Well, just the other day I had a bunch of complicated functions calling each other recursively in interesting ways
10:12:39 <monochrom> @where lazy
10:12:39 <lambdabot> http://www.vex.net/~trebla/haskell/lazy.xhtml
10:12:45 <monochrom> That. :)
10:12:47 <jared-w> monochrom: #realHaskellProgrammersUseButterflies
10:12:52 <drdo> And all I wanted to do was know what the value of some variable was in the middle of one of them
10:13:17 <drdo> Instead I spent a bunch of time working it out by hand on paper to find the bug
10:13:26 <jared-w> I think the tracing stuff would've helped? idk
10:13:29 <cocreature> drdo: Debug.Trace is helpful for that kind of stuff
10:14:06 <drdo> cocreature: You still need to force the trace for that work though
10:14:26 <cocreature> ghci also has a debugger which can be useful although I always forget how to use it
10:14:44 <cocreature> drdo: sure but ime finding something that is evaluated and slapping a traceShow in front of it is not too hard
10:15:15 <monochrom> I have used Debug.Trace. I still haven't needed ghci's debugger.
10:16:55 <monochrom> If you get a wrong answer and the process of getting the wrong answer doesn't trigger a trace you wrote, well that's valuable information, it means your code doesn't care.
10:17:31 <drdo> I've tried trace in the past, and I don't remember exactly what the problem was, but I remember being dissatisfied
10:19:19 <Ferdirand> MarcelineVQ: complete coincidence, sorry
10:20:30 <MarcelineVQ> her smile and optimism, gone
10:25:53 <jmcarthur> Does anybody have strong opinions on when it's better to have monomorphic/polymorphic inputs/outputs? For example, consider functions that could have types like   (Integral a, Integral b) => a -> b.  This unfortunately maximizes the chances of running into ambiguous types, so most people would consider making the input, output, or both monomorphic.
10:26:27 <jmcarthur> Is there are good rule of thumb and what are the exceptions? I seem to recall seeing a blog post about this somewhere, but don't remember who wrote it.
10:26:30 <Welkin> it depends on what you are writing
10:26:34 <Welkin> is it a library, or an application?
10:26:39 <hpc> libraries shouldn't try to read the user's mind
10:26:43 <hpc> applications should do whatever works
10:26:52 <Welkin> if it's an application, use the most specific type that you need instead of trying to generalize for no reason
10:27:02 <drdo> In a library I believe you should have the most general type possible
10:27:43 <jmcarthur> I usually like to generalize even if only to maximize parametricity. In this case, under the hood it just gets converted to a concrete type anyway.
10:27:59 <drdo> Maybe with type synonyms for the common/simple case to make so people don't freak out
10:28:08 <drdo> s/to make//
10:28:52 <codeshot> if it's easy and obviously right, make them polymorphic
10:29:52 <jared-w> If it's some trickery magic, and only exists to do some business logic in your app a little nicer, you should probably lock down the types as much as possible; it'll make it harder for things to go wrong, actually, since only the types you 'want' will work with the code
10:29:55 <jmcarthur> So in an ideal world,   replicate :: Integral a => a -> b -> [b]   and   length :: (Foldable f, Integral b) => f a -> b   ?  Seems actually annoying to use.
10:30:06 <jared-w> :t length
10:30:07 <lambdabot> Foldable t => t a -> Int
10:30:19 <drdo> I still don't understand why lengths are an Int in haskell
10:30:22 <drdo> it irks me
10:30:26 <Welkin> why?
10:30:28 <MarcelineVQ> :t genericLength
10:30:30 <lambdabot> Num i => [a] -> i
10:30:32 <drdo> You had Word
10:30:34 <drdo> Just use Word
10:30:40 <Welkin> oh, I see
10:30:41 <Welkin> yeah
10:30:46 <jared-w> I don't understand why a ton of the prelude uses overly specific numeric types
10:30:47 <jmcarthur> lol, genericLength is not strictly more generic than length
10:30:49 <Welkin> Vector uses Int for length and indexing
10:30:56 <drdo> Welkin: Everything does
10:31:02 <Welkin> I suppose because C uses signed integers as well
10:31:08 <cocreature> genericLength also has an extremely shitty implementation
10:31:11 <drdo> Somehow that's the "official" indexing type in haskell
10:31:22 <Welkin> for Array you can use anything
10:31:25 <codeshot> What's does length do when you're passing it's result to a function that takes a float?
10:31:39 <jared-w> Vector also has a ton of efficiency concerns, so that sort of makes sense. I'd prefer libraries to be as general as possible and then have the efficiency black magic in the compiler
10:31:41 <lyxia> > genericLength [] :: Float
10:31:43 <lambdabot>  0.0
10:31:48 <monochrom> Parametric polymorphism increases correctness for those who understand it, and simply loses those who don't. It also adds a chance for inefficiency.
10:32:05 <codeshot> lyxia, that's not enough to demonstrate floating point relationships
10:32:14 <lyxia> codeshot: what
10:32:24 <codeshot> eh?
10:32:38 <lyxia> what relationship do you want demonstrated
10:34:00 <jared-w> length returns an int. What happens if you pass length into a function that wants a float? The answer is that it breaks because the types don't match, just like any other type mismatch
10:34:59 <jared-w> length /should/ be a strict left fold whose accumulator is a Num, but it's not ¯\_(ツ)_/¯
10:35:05 <codeshot> jared-w, I meant genericLength
10:35:28 <cocreature> jared-w: and genericLength isn’t either :)
10:35:32 <jared-w> :t genericLength
10:35:34 <lambdabot> Num i => [a] -> i
10:35:37 <jared-w> cocreature: they're both wrong ಠ_ಠ
10:35:58 <jared-w> codeshot: oh, right; in that case it just gets turned into a float
10:36:04 <jared-w> > :t 3
10:36:06 <lambdabot>  <hint>:1:1: error: parse error on input ‘:’
10:36:12 <jared-w> > 3
10:36:14 <lambdabot>  3
10:36:16 <jared-w> > 3 :: Float
10:36:18 <lambdabot>  3.0
10:36:35 <codeshot> ah but theres no just on floats
10:36:45 <codeshot> lots of maybe, but no just
10:36:50 <jared-w> no just on floats?
10:37:10 <codeshot> "just gets turned into a float"
10:37:12 <jmcarthur> With a reasonable genericLength, the following holds:  (genericLength $ replicate (2^24) () :: Float) == fromIntegral (2^24)
10:37:20 <jmcarthur> However, the following does not:   (genericLength $ replicate (2^25) () :: Float) == fromIntegral (2^25)
10:37:24 <codeshot> nothing about floats warrants "just"
10:37:52 <codeshot> as soon as you try to compute with them everything goes wrong
10:38:03 <jmcarthur> I wouldn't say *everything*.
10:38:11 <jared-w> oh, right, my wording. My wording was a bit vague. Think of the Num i from genericLength as being "any number that fulfills the Num interface"
10:38:27 <jmcarthur> The use of floats I think should be more niche than they are in practice, but they have their uses.
10:38:46 <jared-w> then if you pass that number into a concrete type like Float, it says "give me the Float representation of 3"
10:38:51 <cocreature> jared-w: well length does at least have a decent implementation. it just might be less general than you would like. the implementation of genericLength is just completely wrong for pretty much all instances of Num that you care about and then it’s fixed for some specific types
10:39:32 <drdo> Why does genericLength return a Num anyway?
10:39:38 <codeshot> yeah, but that's like "what happens if I shoot someone?" "Well then they die", really what happens is "they die and your life goes wrong"
10:39:46 <drdo> At first glance it seems to make sense to just make it an Integral
10:40:04 <jared-w> drdo: because Num is the most general and Integrals can't be turned into Floats
10:40:06 <jmcarthur> Num is more general.
10:40:11 <monochrom> No, they die and the rest of us have more natural resources.
10:40:28 <codeshot> Bottom is even more general still, that's no excuse
10:40:30 <jared-w> 3 + 0i is a valid complex number representation of 3, after all. Why does it need to be an Integral just because it's always a whole number?
10:40:48 <monochrom> Always look for the silver lining >:)
10:41:07 <jared-w> also lol generic length uses explicit recursion
10:41:14 <codeshot> monochrom, lol
10:41:34 <drdo> jared-w: What the hell is a Num anyway
10:42:04 <drdo> I know it's something that implements Num, but what's the idea?
10:42:05 <jared-w> A Num in Haskell is technically a Ring, because Haskell people are biased towards algebra, apparently, and they all like Rings and Fields
10:42:24 <codeshot> a Num is a thing with +, -, /, *, neg, signum
10:42:36 <jared-w> Anything that is a Ring can have a num instance, regardless of how much sense it makes to think of it as a number
10:42:40 <drdo> jared-w: Then it doesn't make any sense for genericLength to return a Num
10:42:41 <codeshot> probaby a couple of laws regarding transitivity
10:42:56 <drdo> How the hell do you convert a positive integer to an arbitrary ring?
10:43:15 <Welkin> jared-w: I think you are confused with purescript, where all of the type classes are category theory and abstract algebra names that make everyone runs for the hills
10:43:26 <jared-w> drdo: sure it does, just don't think of Num as what it actually is and think about it as what it was intended to be (or whatever floats your boat)  :p
10:43:31 <int-e> drdo: 1+1+1+1+...
10:43:38 <codeshot> I don't think Num requires that + and * form a ring
10:43:44 <drdo> int-e: What if my ring has no 1
10:43:55 <Welkin> Num is just a typeclass
10:44:04 <int-e> drdo: then it's not a ring (I realize that mathematicians are divided over that matter)
10:44:08 <Welkin> it doesn't need to be anything directly from math
10:44:51 <drdo> int-e: So you mean that Num is a unital ring?
10:45:50 <int-e> drdo: as a first approximation. but the abs and signum operations kind of spoil this picture.
10:47:10 <jared-w> I should've said "num is mostly a ring, heavily inspired by a Field, but in reality it's a bunch of stuff in a typeclass that was supposed to be convenient"
10:47:20 <drdo> int-e: yep, because it's not really mean to be a ring :P
10:47:40 <codeshot> It's really unfortunate that some key operators have been consumed by Num
10:47:43 <int-e> (at least you can define  abs 0 = 0, abs _ = 1 and signum x = x  to get a kind of law abiding instance for any ring (with 1))
10:47:46 <Psybur> @pl \f g h -> \x -> f g (h x)
10:47:47 <lambdabot> ((.) .)
10:47:51 <drdo> Appears to be a half-baked "abstraction" intended for the common numbers we use
10:47:58 <drdo> *meant
10:48:11 <geekosaur> Num is a hack to make numbers behave the way the Haskell language committee thought people expected them to behave, and justifications layered on after the fact
10:48:13 <jared-w> Yeah, it was (in retrospect) a dumb decision
10:48:36 <jared-w> However, PureScript's approach might be a bit too extreme for some people, so... yeah
10:49:15 <int-e> class (Show a, Eq a) => Num a where ... -- yay
10:49:24 <jared-w> I think that once we figure out a way to deal really nicely with deep hierarchies, a way to locally "rename" typeclasses, etc., that would allow them to be a bit more useful
10:50:20 <codeshot> and a way to delve down
10:50:39 <drdo> I wonder why monoid wasn't fixed in the same way when they did the monad applicative thing
10:51:02 <jared-w> drdo: iirc it was mostly a "how much stuff do we break vs how much stuff do we fix/deal with now" tradeoff
10:51:27 <jared-w> codeshot: indeed. Although it'd be ideal if that sort of thing were automated as much as possible. Not sure how that'd work or if it was even possible, but it'd sure be nice
10:51:32 <Welkin> jared-w: I have a feeling you would enjoy classy-prelude and anything written by snoyberg. His libraries have typeclasses up to your eyeballs
10:51:50 <Welkin> drdo: you mean semigroup and monoid?
10:51:56 <drdo> Welkin: sure
10:51:59 <jared-w> Welkin: I like the idea of typeclasses and very fine grain control. I hate the reality of them. 4 lines of type signature aren't my idea of readable code :p
10:52:09 <codeshot> jared-w, I don't think it's possible to automate much
10:52:12 <jared-w> Plus it breaks tons of inference, error messages get worse than useless...
10:52:13 <johnw> drdo: that fix is coming
10:52:24 <johnw> i just don't know when exactly
10:52:33 <drdo> Will we get a nice prelude too?
10:52:35 <johnw> or at least, I thought that I had heard that
10:52:45 <johnw> Prelude is not likely to change much very soon
10:52:55 <drdo> (++) = (<>) do it
10:52:57 <Welkin> drdo: there are many alternative preludes and you can disable implicit import of the prelude in your cabal file
10:53:05 <drdo> map = fmap do it
10:53:07 <drdo> etc
10:53:08 <jared-w> There's two thoughts: Break the shit out of everything with Base 5.0.0.0 and modernize Haskell's prelude in one fell swoop
10:53:12 <codeshot> if you've got declared rules then you can somewhat but then you still have ambiguities in reporting. and if you ever want to go dependently typed ...
10:53:28 <drdo> jared-w: I think doing one big breaking change is the saner option
10:53:39 <jared-w> The other thought is: Wait for Haskell 2.0 which will roll in a ton of pragmas as default, upgrade a ton of things, and not worry about backwards compatibility with Haskell 1.0
10:53:43 <geekosaur> the foundation for semigroup/monoid fix is in 8.2, the actual fix for that is scheduled for 8.4
10:53:50 <jared-w> (aka Haskell' or Haskell Prime)
10:54:04 <Welkin> what is 2.0?
10:54:14 <drdo> It's like 1.0, but better!
10:54:21 <Welkin> we are on 8.2
10:54:22 <geekosaur> actualy skip "scheduled for". 8.4 release branch has been cut and has SMP phase 2 in it
10:54:23 <jared-w> Haskell Prime, the mythological next version of Haskell that's supposed to cure cancer :)
10:54:25 <Welkin> far past 1.0
10:54:33 <jared-w> https://prime.haskell.org/
10:54:34 <monochrom> @type 2.0
10:54:35 <lambdabot> Fractional p => p
10:54:38 <monochrom> That. :)
10:54:45 <codeshot> as users we need to do such things. Need to say class Bar a => Foo a partof Monad a where
10:55:02 <codeshot> unless a heirarchy isn't needed
10:55:10 <codeshot> at all for anyone
10:55:23 <drdo> Any word about the monomorphic IO in everything?
10:56:23 <jared-w> eh... I don't think monomorphic IO is going to change, honestly. Unless some amazing thing comes out where we figure out how to "100% magically fix algebraic effects and make them super duper awesome"  (likely not going to happen for several theoretical reasons)
10:57:47 <jared-w> Otherwise it's just arbitrarily splitting up IO and tagging it with different categories that some language designer somewhere said "yeah these are the splits everyone's gonna use, k?"
10:58:06 <drdo> Changing the subject a bit. Is there a lib to make handling resource "ownership" and stuff in the presence of concurrency (and async exceptions) easy?
10:58:15 <Welkin> I actually found it very annoying to use tagged IO in purescript
10:58:27 <Welkin> it didn't have any added benefits
10:58:32 <Welkin> just made the types more verbose
10:58:42 <jared-w> Can you make your own tags for IO? Or do you just use the pre-defined set of "magic tags"?
10:59:21 <Welkin> you could make a type alias for IO with a phantom type
10:59:22 <cocreature> drdo: resourcet if you need something more complicated, "bracket" from Control.Exception if it fits your resource allocation patterns
10:59:24 <Welkin> and then you have tags
10:59:34 <jmcarthur> I'm sad about pattern matching on records. I want to use nice things like RecordWildCards, but I don't get warnings when I forget to use fields and such.
10:59:38 <drdo> cocreature: That doesn't really work with concurrency
10:59:54 <jared-w> jmcarthur: records just kinda suck in Haskell, honestly
10:59:59 <drdo> Say you have a thread allocate a resource, but then wants to hand over responsibility to some other thread
11:00:18 <drdo> Simple example: server loop
11:00:18 * jared-w inserts obligatory rant about "records /= data, why do we have this horrible hack to pretend they are"
11:00:38 <cocreature> drdo: right in that case, you need to use resourcet https://hackage.haskell.org/package/resourcet-1.1.9/docs/Control-Monad-Trans-Resource.html#v:resourceForkIO
11:01:10 <drdo> cocreature: I don't want both threads to own the resource though
11:01:35 <Welkin> drdo: cloud haskell
11:01:40 <drdo> I want the first thread to transfer ownership to the second, i.e. the second thread is now responsible for cleanup and so on
11:01:59 <Welkin> that is exactly what erlang (and cloud haskell) does
11:02:11 <drdo> Welkin: It is?
11:02:21 <cocreature> it’s really not or I don’t understand what Welkin is referring to
11:02:27 <drdo> How would do a server loop like that?
11:02:33 <Welkin> processes can take over where some other process left off
11:02:39 <drdo> i.e. transfer ownership of the socket
11:02:57 <drdo> That's the simplest example I can think of, can get pretty complicated
11:03:09 <Welkin> what is the use case here though?
11:03:11 <drdo> And async exceptions make this harder
11:03:16 <Welkin> what is this srver doing that it needs that?
11:03:19 <drdo> Welkin: I just gave you a concrete use case!
11:03:27 <drdo> Imagine a generic server loop
11:03:29 <Welkin> you described what you want to do
11:03:33 <Welkin> but what is the server for?
11:03:36 <drdo> generic
11:03:41 <Welkin> that makes no sense
11:03:46 <Welkin> why does it need to transfer ownership?
11:03:49 <drdo> server ∷ Socket → (Socket → IO a) → IO Void
11:04:02 <drdo> Like this for example
11:04:07 <Welkin> web servers are supposed to be stateless (at least through http)
11:04:25 <drdo> Where the second argument takes an individual client connection and does whatever it wants
11:05:38 <drdo> Welkin: How would you write that server function?
11:05:56 <cocreature> drdo: not sure why resourcet doesn’t work for you. you can use resourceForkIO to spawn the new thread and then release it in the main loop
11:10:06 <drdo> cocreature: And then you release everything that isn't the socket in the child thread as well?
11:11:23 <cocreature> drdo: depends on how long you want the resources to live. if the child thread exits, they will be released anyway so if you don’t want to release them before that you don’t need to do anything
11:12:09 <drdo> Well, in a library setting you do.
11:12:33 <cocreature> huh?
11:13:08 <drdo> Who knows what resources are in that context, you can't just hog it forever in the new thread
11:13:43 <cocreature> *shrug* you seem to have more problems with resource handlings than I do, 99% of my usecases are covered by bracket :)
11:14:01 <drdo> Things get complicated in complicated concurrent situations :P
11:15:00 <drdo> That's just a simple one 
11:25:34 <jared-w> Hmm... There's Control.Concurrent.Async; is there any way to easily limit concurrent requests (for example: getting a bunch of URLs at a rate of no more than 10 requests at a time)?
11:26:33 <EvanR> you can make a semaphore, you have a bag (mvar) of 10 capability tokens. when youre done, put the token back
11:26:44 <EvanR> if there are no tokens right now, block
11:27:14 <cocreature> or just use Control.Concurrent.QSem instead of implementing a semaphore on top of an mvar yourself
11:27:23 <jared-w> I was wondering if someone had already did that :)
11:27:29 <cocreature> it’s even in base
11:27:37 <jared-w> pffh, shows how well I can search
11:28:01 <EvanR> well dang
11:28:02 <mauke> sounds like a TVar Int to me
11:28:20 <EvanR> yeah
11:28:44 <cocreature> jared-w: there is also an async-pool package but after having recommended it to someone else a while back only to discover that it seems to have a few bugs while not being particularly well maintained, I’m cautious to recommend it again :)
11:29:12 <jared-w> Sounds fair :)  I see a SafeSemaphore pakage as well
11:30:08 <jared-w> mfw I search for "QSem" and don't get Control.Concurrent.QSem... 
11:30:45 <mauke> http://hayoo.fh-wedel.de/?query=QSem
11:30:56 <cocreature> http://hoogle.haskell.org/?hoogle=QSem
11:31:07 <jared-w> I wasn't using Hayoo, I just used the hackage search
11:31:46 <jared-w> Although I suppose it wouldn't really show up, being inside of base...
11:31:53 <hpc> hayoo has a more complete index, but doesn't always order results as well and is a bit slower
11:32:08 <cocreature> jared-w: base is on hackage
11:32:31 <cocreature> the problem is that the hackage search searches only for package names afaik
11:32:34 <cocreature> maybe also descriptions
11:32:42 <cocreature> but definitely not modules or even types in those modules
11:32:52 <jared-w> Yeah, that's what I was trying to get at. Very limited search, unfortunately
11:33:11 <sternmull> I wish System.Process would offer something like Pythons Popen.pid to get the PID of the spawned subprocess. I see no good reason why this is not exposed in the Haskell API.
11:33:38 <jared-w> Also apparently SafeSemaphore hasn't been updated since 2014
11:34:18 <cocreature> jared-w: looking at the linked ghc trac ticket, the problems in QSem that resulted in SafeSemaphore have since been fixed
11:34:19 <EvanR> you get a ProcessHandle
11:34:28 <EvanR> i guess PID is unix-specific
11:34:46 <jared-w> ahh, okay, so just using the base library is fine then 
11:34:58 <cocreature> iirc you can get a PID from a process handle
11:35:15 <cocreature> it’s a bit ugly but it’s not completely hidden
11:35:19 <carbolymer> quick question, why when I'm doing  read "dupa" :: Text  in ghci I am getting Prelude.read: no parse
11:35:20 <carbolymer> ?
11:35:39 <carbolymer> Text is an instance of Read, so wtf?
11:35:40 <sternmull> EvanR: It isn't, on Windows there is GetProcessId
11:35:59 <hpc> > show (T.pack "blah")
11:36:02 <lambdabot>  error:
11:36:02 <lambdabot>      Not in scope: ‘T.pack’
11:36:02 <lambdabot>      Perhaps you meant ‘BS.pack’ (imported from Data.ByteString)
11:36:08 <hpc> > show (Text.pack "blah")
11:36:10 <lambdabot>  error:
11:36:10 <lambdabot>      Not in scope: ‘Text.pack’
11:36:10 <lambdabot>      No module named ‘Text’ is imported.
11:36:15 <hpc> hmm
11:36:24 <cocreature> > show (Data.Text.pack "blah")
11:36:26 <lambdabot>  error:
11:36:27 <lambdabot>      Not in scope: ‘Data.Text.pack’
11:36:27 <lambdabot>      No module named ‘Data.Text’ is imported.
11:36:28 <carbolymer> hpc, yes, I know about pack, but shouldn't read work as well?
11:36:31 <cocreature> @let import Data.Text
11:36:32 <lambdabot>  .L.hs:214:46: error:
11:36:32 <lambdabot>      Ambiguous occurrence ‘map’
11:36:32 <lambdabot>      It could refer to either ‘Data.List.map’,
11:36:33 <cocreature> > show (Data.Text.pack "blah")
11:36:34 <lambdabot>  error:
11:36:35 <lambdabot>      Not in scope: ‘Data.Text.pack’
11:36:35 <lambdabot>      No module named ‘Data.Text’ is imported.
11:36:39 <cocreature> …
11:36:46 <mauke> I'm going to start kicking people
11:36:47 <jared-w> It's funny how the QSem ticket is closed as "wontfix" but it's fixed... lol
11:36:49 <EvanR> PHANDLE = CPid on not windows, PHANDLE = Ptr () on windows
11:36:59 <sternmull> cocreature: I found this https://stackoverflow.com/questions/33446996/guaranteed-termination-of-external-process-in-haskell but i am not sure it will work on windows. It could return the value of the native handle instead of the PID.
11:37:13 <hpc> carbolymer: where i was going with it was, the way text is printed is probably not such that you can just read any arbitrary string
11:37:15 <mauke> carbolymer: dupa is not valid Haskell syntax
11:37:56 <carbolymer> mauke, so which string is valid Haskell syntax
11:37:57 <carbolymer> ?
11:38:01 <Welkin> phandalin?
11:38:17 <EvanR> yes you can get the pid out of the ProcessHandle if you break it open and dont use windows
11:38:18 <carbolymer> hpc, hm, interesting
11:38:21 <hpc> show (pack "test")
11:38:22 <hpc> "\"test\""
11:38:32 <Welkin> > show "test"
11:38:34 <lambdabot>  "\"test\""
11:38:38 <hpc> read "\"test\"" :: Text
11:38:38 <hpc> "test"
11:38:46 <EvanR> but now, do you really want to use System.Process
11:39:04 <sternmull> EvanR: What is the alternative?
11:39:11 <EvanR> the unix bindings
11:39:22 <mauke> carbolymer: "dupa" is valid syntax. in a string to read from, that would be "\"dupa\""
11:39:23 <EvanR> like, what would you do with the pid otherwise
11:39:42 <michaelsingh[m]1> 😎
11:39:52 <carbolymer> mauke, hpc, oooh, I see it now, thanks!
11:40:19 <michaelsingh[m]1> /msg nickserv identify anu0 qwerty
11:40:26 <geekosaur> "oops"
11:40:29 <sternmull> EvanR: My program should launch subprocesses and report their PIDs, and that for Linux and Windows. With the available API i don't see a way to do that.
11:40:31 <michaelsingh[m]1> You gotta be shitting me
11:40:38 <michaelsingh[m]1> What a shit client
11:40:47 <EvanR> PID on windows?
11:40:48 <mauke> why would you type your password in a channel window
11:41:01 <hpc> i bet it was an alias that went wrong
11:41:03 <michaelsingh[m]1> It’s this Riot app.
11:41:11 <sternmull> EvanR: Yes, see for example https://msdn.microsoft.com/en-us/library/windows/desktop/ms683215(v=vs.85).aspx
11:41:15 <michaelsingh[m]1> What a piece of shit.
11:41:26 <jared-w> at least you had a terrible password, so nothing of value was lost :)
11:41:28 <EvanR> i see
11:41:30 <mauke> doesn't it support query windows?
11:42:18 <sternmull> mauke: What do you mean by "query"?
11:42:19 <EvanR> sternmull: if you look in System.Process's code youll see how it selects System.Win32 or System.Posix with macros... you could go for that
11:42:30 <jared-w> On my client, if I use the wrong msg query (nickserv instead of NickServ for example) it doesn't even go through to the chat window, it pops up an error for me in my server buffer
11:42:52 <mauke> sternmull: what I get with /query NickServ
11:42:57 <mauke> not sure how your client handles it :-)
11:43:15 <geekosaur> jared-w, that sounds really broken. nicks are case preserving but case independent
11:43:59 <jared-w> seems like an oxymoron
11:44:48 <geekosaur> no? same way most 'case independent' filesystems work: the case used byw hatever created it is remembered, but case independent matching is done subsequently
11:45:03 <jared-w> ah, makes sense I suppose
11:45:23 <jared-w> oh whoops, I read the error message wrong. Messaging nickserv worked fine, but I sent it "hi" which was an invalid command
11:45:26 <no_fri3nds> I have never seen a line of Haskell. Where should I start?
11:45:45 <sternmull> EvanR: Hm, maybe. Until now I didn't try to access internals of haskell modules. I have no idea if the API even allows that. And i am sure i don't want to modify standard packages to get the PID of subprocesses...
11:46:02 <jared-w> no_fri3nds: Haskell Programming From First Principles if you want to do it right. LYAH from first principles if you want to do it wrong, and the CIS 194 course from 2013 if you want to do it for free
11:46:07 <EvanR> you wouldnt be modifying anything
11:46:30 <EvanR> you would be selectively accessing platform specific functionality, going through the standard ProcessHandle value
11:46:47 <sternmull> and there is no restriction in accessing internals of the module?
11:46:49 <EvanR> on posix, the PHANDLE is what you want
11:47:04 <EvanR> on win32, you pass the PHANDLE to that GetProcessID call
11:47:27 <sternmull> ok, will try that.
11:48:23 <EvanR> the constructor seems to be exported
11:48:48 <sternmull> yes, it is.
11:49:06 <EvanR> ah, the main module hides it
11:49:23 <EvanR> but you could import System.Process.Common i think
11:49:35 <geekosaur> S.P.Internals
11:49:56 <sternmull> yes, Internals it is in my version... Common in later versions.
11:50:24 <EvanR> its both
11:50:43 <EvanR> internals seems righter
12:09:27 <asivitz_> I'm looking for advice on how to use randomness in an FRP network (specifically, reactive-banana). The idea of 'randomness' doesn't make sense to me as a Behavior or Event. Maybe I could throw a RandGen in an IORef, but then how do I pull it out/update it during an event fire?
12:10:56 <EvanR> here is how randomness appears in video poker
12:12:32 <EvanR> there is a random number valued variable that is updating at a very high speed, without regard to power usage. the rest of the program samples it in response to user input, like to produce another shuffle of cards. or the deck of cards variable is also being continually updated
12:13:08 <EvanR> theoretically thats all unnecessary if you just get a new random value when its needed, but if you know the RNG seed, you break the game
12:13:46 <EvanR> anyway, a discrete numeric value can change randomly with time at some frequency and that might solve your problem
12:15:47 <EvanR> randomness in shaders is another example, you dont have RNGs because you dont have state. but you can sample a signal composed of many "arbitrary" frequency and phase shifted sine waves
12:15:55 <EvanR> which approximates real life noise
12:16:13 <EvanR> that could also work in FRP
12:18:08 <jmcarthur> It seems like that would have problems with simultaneous sampling, which is something more FRP libraries support.
12:18:13 <asivitz_> Yea that makes sense. My worry is that I pull the value more often than it updates, but I guess in most cases I could pull the value once to seed a generator and then use that to compute all the random numbers I need in that part of the network. Or I could have it update more often like your example, but I would worry about performance. Not sure if I should care about that yet
12:18:13 <jmcarthur> *most
12:19:20 <asivitz_> I guess I'm looking for an event generator to perform side effects? Is that a terrible idea?
12:19:35 <jmcarthur> e.g.  liftA2 (+) randomBehavior randomBehavior  would be the same as  fmap (2*) randomBehavior
12:19:44 <EvanR> well yeah, if you sample it at a given time, its the same value
12:19:51 <EvanR> makes sense
12:20:37 <EvanR> and if you think you want a supply of random numbers, which are dequeued during an event, what happens when multiple events do that at the same time?
12:21:15 <EvanR> who gets which
12:21:34 <asivitz_> well to me it doesn't matter :]
12:21:45 <EvanR> if you can make it deterministic somehow... you win
12:21:59 <EvanR> randomness is too important to leave to chance!
12:22:45 <sternmull> without knowing anything about FRP this sounds like an equivalent of /dev/urandom is needed
12:22:50 <EvanR> simultaneous taking from a supply in indeterminate order seems to violate some laws to me
12:24:41 <EvanR> if you need 2 random numbers at the same time, you could have 2 different random signals
12:24:51 <EvanR> or map one random number to 2
12:32:29 <EvanR> half off topic, what is a decent replacement for Data.Map Int in C ?
12:32:58 <Welkin> what?
12:33:07 <Welkin> int-indexed Map?
12:33:11 <EvanR> yes
12:33:12 <Welkin> an array
12:33:22 <EvanR> an incredibly large array?
12:33:25 <Welkin> yes
12:33:29 <Welkin> as large as you need
12:33:34 <EvanR> how do you iterate through it
12:33:35 <hpc> if you don't mind having a huge sparse array (for a sparse map)
12:33:41 <hpc> or you use some map-like data type
12:33:59 <EvanR> with a loop i guess
12:34:08 <Welkin> EvanR: you could store the valid keys in another array
12:34:18 <EvanR> ah
12:34:35 <Welkin> there are container-like libraries for C and C++
12:34:40 <Welkin> but from what I have seen they suck
12:34:50 <EvanR> what is a standardish such library for C
12:35:09 <Welkin> stl? boost?
12:35:16 <EvanR> uhm
12:35:29 <Welkin> lol
12:35:35 <Welkin> I never used any libraries in C
12:35:52 <Welkin> besides things like math and stdio
12:36:19 <EvanR> maybe this calls for haskell-as-a-library
12:37:50 <Welkin> why do you need C?
12:38:02 <Welkin> could you use haskell with the c ffi? or rust?
12:39:14 <EvanR> i am a weenie and have not taken the plunge to get lens to compile on RPI, which sdl2 bindings transitively depend on
12:39:28 <Welkin> ...
12:39:32 <EvanR> so i was writing the graphics wrapper as a separate process in C
12:39:38 <Welkin> I omplaied about that a long time ago
12:39:51 <Welkin> you can grab the older version of sdl2 which were the raw bindings only
12:39:55 <Welkin> I even forked it back then
12:40:15 <Welkin> I never touch the high-level sdl2 bindings and think they were a stupid idea and a huge waste
12:40:17 <mauke> I used to have a splay tree implementation somewhere ...
12:40:19 <Welkin> I just use Raw
12:40:21 <asivitz_> regarding my frp question: I found an example where mapAccum is used to keep a local stdgen state for an event generator (https://github.com/HeinrichApfelmus/reactive-banana/blob/74bac0f86ed172f95bb6f6a31041992fc161cf79/reactive-banana/doc/examples/SlotMachine.hs)
12:41:00 <EvanR> honestly it would probably simplify matters greatly to stay in haskell only
12:42:31 <Welkin> EvanR: http://hackage.haskell.org/package/sdl2-1.3.1 raw-bindings only with no lens dependency
12:43:01 <mattyw_> hi folks, I've been playing with a brainfuck interpreter for a few weeks, It's working but I've been trying to make it fast. I was going to post code an profile output somewhere (like reddit/r/haskell or codereview.stackexchange) to get some view. But I wondered if anyone here had better ideas
12:43:13 <mattyw_> (for where I could post it)
12:43:31 <Welkin> on your github
12:44:00 <EvanR> really... that might work
12:44:22 * EvanR thinks very hard
12:44:43 <zereraz> hi, if I have a deeply nested ADT, various sum types, if I have to convert them to json, then I have to write deriving ToJSON for all of them or is there a simpler way to do it?
12:45:04 <mauke> http://lpaste.net/359965 ah, here it is
12:45:07 <zereraz> I just want to use the default representation
12:45:08 <Welkin> zereraz: auto-derive ToJSON for each type
12:45:18 <mauke> well, it's a whitespace interpreter but it contains a splay tree implementation
12:45:26 <zereraz> @Welkin so no way to do it in one place?
12:45:26 <lambdabot> Unknown command, try @list
12:48:43 <EvanR> zereraz: its possible to write a TH that expands a list of data types into separate standalone deriving declarations
12:49:00 <EvanR> or searches the module for data types to do that to
12:49:19 <zereraz> hmm ok, thanks!
12:49:27 <zereraz> I can give the exact context where I need
12:50:26 <zereraz> if I want to convert this https://github.com/purescript/purescript/blob/3103dbf317c84e103384243944a377f0a0594774/src/Language/PureScript/AST/Declarations.hs#L222 to JSON
12:50:42 <zereraz> it seems very hard as there are so many of them defined across various files
12:53:40 <asivitz_> @zereraz well I don't believe haskell provides any help for 'derive instances for all these types', so I think you either need to use TH or some other preprocessor (shell script that searches for data declarations and makes instance declarations?)
12:53:40 <lambdabot> Unknown command, try @list
12:53:55 <zereraz> asivitz_: ok thanks!
12:58:59 <EvanR> Welkin: otoh i think theres a different GL library on RPI and so i might need to use C anyway
13:42:45 <Psybur> @src mapM
13:42:45 <lambdabot> mapM f as = sequence (map f as)
13:42:46 <sternmull> How do i add a dependency in my .cabal only for the windows build?
13:43:07 <Psybur> @src sequence
13:43:08 <lambdabot> sequence []     = return []
13:43:08 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
13:43:08 <lambdabot> --OR
13:43:08 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
13:43:53 <Psybur> @src liftM2
13:43:54 <lambdabot> liftM2 f m1 m2 = do
13:43:54 <lambdabot>     x1 <- m1
13:43:54 <lambdabot>     x2 <- m2
13:43:54 <lambdabot>     return (f x1 x2)
13:50:06 <ericdwhite> @src liftA2
13:50:06 <lambdabot> liftA2 f a b = f <$> a <*> b
13:50:22 <ericdwhite> This is something I found comes up a lot
13:50:32 <erisco> I talked about it just this morning
14:03:48 <lyxia> sternmull: if !os(windows)\n    build-depends: my-dependency
14:04:07 <lyxia> oh wait, only for windows,  if os(windows)
14:04:22 <unclechu> hey guys, how can i know where function defined, i mean which package provides this function in ghci repl (run from `stack repl`)? 
14:04:25 <lyxia> sternmull: https://www.haskell.org/cabal/users-guide/developing-packages.html#conditions
14:04:44 <unclechu> `:i` shows module path but not package
14:04:59 <sternmull> lyxia: I found that... but is there a way to have only some dependencies conditiional? At the moment i have to write two "build-depends" lists that only differ in one item.
14:05:29 <Psybur> @pl \x y -> maybe (Left x) Right y
14:05:29 <lambdabot> flip maybe Right . Left
14:05:45 <n_blownapart> hi anyone walk me through this ? its re: quotient types  .. sort of lost with it.  https://ptpb.pw/Io1F
14:06:34 <sternmull> lyxia: Oh! 3.3.2.12. explains what i need. Thanks!
14:07:47 <lyxia> unclechu: ghc-pkg find-module
14:08:26 <lyxia> crucify_me: which sentence do you not understand
14:09:30 <unclechu> lyxia: thanks, works for me
14:09:38 <crucify_me> well..
14:09:55 <codeshot> crucify_me, Z/3Z: 0=3 and 0=6, and 1=4, and 2=5, and 3=6
14:10:31 <codeshot> crucify_me, Z/2Z: 0=2, and 0=4, and 1=3, and 2=4
14:11:02 <crucify_me> one moment please
14:12:11 <codeshot> as if the numbers are points on a corkscrew, their value is their position by height, an if you look down the corkscrew they're equal if they are at the same point on the circle that the corkscrew forms
14:13:18 <codeshot> that's how I read it
14:13:48 <codeshot> But it doesn't make sense with all I understand about maths
14:14:04 <crucify_me> hold on thanks a lot I am working on it
14:14:13 <jared-w> codeshot: https://en.wikipedia.org/wiki/Quotient_type this should clean things up a lot re Quotient Types
14:14:19 <jared-w> s/clean/clear/
14:14:37 <codeshot> it makes sense as a constructor for Z/nZ from Z
14:15:01 <codeshot> but not for a type itself o.O
14:15:25 <jared-w> A simple example of a Quotient Type that makes sense to me is "clock time"
14:15:38 <jared-w> (ie 12 hour AM/PM time)
14:15:52 <crucify_me> I omitted the first two words of the paragraph: For mathematicians,
14:16:03 <crucify_me> well yeah I get the clock arithmetic 
14:16:25 <jared-w> http://www.hedonisticlearning.com/posts/quotient-types-for-programmers.html this is my favorite post about quotient types
14:17:22 <jared-w> The more mathematical way to think about it is you're given an equivalence relation on which to compare numbers. Essentially, quotient types allow you to define a function which must treat certain "different" inputs as the same
14:17:44 <codeshot> but in Z/4Z are 2 and 6 the *same* number because they're equal? That would be okay for me
14:18:34 <codeshot> or that is to say Z/(2^32)Z is a 32bit unsigned twos-complement number (c's uint32_t)
14:18:35 <jared-w> In a function with an appropriate quotient type for that example, the function doesn't need to say that 2 and 6 are the *same* number. However, they're in the same equivalence class and so the function is not allowed to *distinguish* between the two
14:19:07 <erisco> codeshot, not sure what Z/4Z is but if we're talking about mod 4 then sure, that is a fine way to recognise it
14:19:30 <codeshot> erisco, crucify_me's link
14:19:45 <codeshot> crucify_me = n_blownapart
14:19:52 <crucify_me> this much I understand courtesy of jared-w this much : quotient types allow you to define a function which must treat certain "different" inputs as the same
14:20:05 <jared-w> You could also define the Integers as a pair of naturals n,m and the pair represents 'n-m'.  2-3 and 1-2 should be the "same number"
14:20:09 <erisco> yes with quotient types those are equal
14:20:46 <codeshot> so they have the same size even?
14:20:56 <erisco> size? what do you mean by that?
14:21:29 <codeshot> that in Z/4Z the number 2 and the number 6 are both the same distance from 0
14:22:00 <erisco> yes that's right
14:22:26 <crucify_me> need very elementary explanation if possible. really hope to get this.. doesn't look hard
14:22:50 <jared-w> That was the elementary explanation :)
14:23:00 <crucify_me> !! dang
14:23:13 <erisco> there are two things that make up the quotient type
14:23:22 <crucify_me> ok
14:23:27 <codeshot> from what erisco has said, the numbers go from 0 to (n-1) then back to 0
14:23:40 <erisco> the numerator is some other type, in this case Z, and the denominator is an equivalence relation, in this case I guess called 4Z
14:24:12 <erisco> the equivalence relation tells you what is equal in Z, so it tells you 2 = 6
14:24:14 <jared-w> codeshot: for quotient types that represent modulo numbers, yes
14:26:10 <erisco> the idea of a quotient is that you are dividing the elements into equivalence classes
14:26:55 <erisco> one of the equivalence classes contains 2, 6, 10, 14, and so on
14:27:44 <crucify_me> so in the case of the first example ... - = -3 = 0 = 3 = 6 .....
14:27:56 <crucify_me> For Z/3Z
14:28:32 <crucify_me> youre saying that the Z in the numerator is some other type? I thought we are talking integers
14:28:48 <erisco> you can have a quotient with any type
14:29:06 <crucify_me> ok, since...
14:29:28 <crucify_me> its number theoretic I believe, at least in this case...
14:30:12 <jared-w> It works for anything, not just numbers. We're just using numbers in this example
14:32:56 <crucify_me> sorry. in the first case there, why does 0 = 3 ?
14:33:34 <erisco> because  0 `mod` 3 = 3 `mod` 3
14:34:08 <crucify_me> thanks one moment
14:35:47 <crucify_me> erisco so k there would be the modulus ?
14:35:55 <crucify_me> in that description
14:37:53 <crucify_me> ok at least I can see the mod operating now ..
14:38:11 <erisco> maybe this explanation will help http://www.cs.cornell.edu/info/Projects/Nuprl/cs671/cs671-fa99/typed%20logic/node42.html
14:38:13 <crucify_me> n is the modulus, correct?
14:38:36 <crucify_me> thanks kindly..
14:38:42 <crucify_me> is ^ correct?
14:38:55 <erisco> I don't know where you see an n
14:39:10 <crucify_me> https://ptpb.pw/Io1F
14:39:50 <crucify_me> if you didn't see that earlier
14:40:42 <erisco> the modulus is what remains after division, also called the remainder
14:40:52 <erisco> modulo is the name of the operator
14:41:30 <erisco> in  a `mod` b   a is called the dividend and b is called the divisor
14:44:35 <crucify_me> really appreciate it erisco. I'll have this in a day or so.
14:44:52 <erisco> I expect a full report delivered on my desk by noon Monday
14:44:55 <crucify_me> the divisor is 3, n
14:45:07 <crucify_me> excellent it will be my pleasure, seriously
14:45:53 <crucify_me> so you're dividing both Z's on either side of  ' / '
14:47:16 <erisco> 4Z  is a name for a equivalence relation on Z, it is not 4 and Z separately
14:47:58 <crucify_me> sorry where are you getting 4Z? 
14:48:13 <erisco> 3Z, nZ, whatever
14:48:16 <crucify_me> ok
14:50:02 <nshepperd> in Z/4Z the 4Z can be read as 4*Z = {4z | z <- Z}
14:50:32 <nshepperd> the equivalence classes are {n + 4Z for each n in Z}
14:51:31 <crucify_me> really appreciate it still working ...
14:51:45 <erisco> my point is that  Z/nZ  is not  1/n  if that is what you were thinking
14:52:22 * ski . o O ( `Z - 2Z' )
14:53:15 <crucify_me> thanks .. sorry confused but I can see the modulo working in those 3 examples 
14:54:23 <erisco> I don't know any type systems that have quotient types
14:56:21 <crucify_me> erisco given the corkscrew analogy...
14:56:26 <nshepperd> computing equivalence classes on infinite sets would seem too inefficient for anyone to implement it in a type system
14:56:58 <nshepperd> i mean, for a programming language to want it
14:57:32 <nshepperd> instead we have things like the Mod type which only works on nats
14:57:36 <erisco> is that needed? I would think at worst you just redirect the equality being used
14:57:39 <crucify_me> if you look down the corkscrew of say mod 3 , you would have, at one interval, -3, -6 and -9, correct?
14:57:51 <erisco> so comparing Z's uses integer equality, and Z/nZ uses the equality defined by nZ
14:58:04 <nshepperd> Integer `Mod` 7 gives you Z/7Z
14:58:09 <erisco> presumably then membership of nZ is computable
14:59:11 <erisco> all I know about corkscrews is utility knives and rollercoasters
14:59:53 <crucify_me> sorry who was it with the corkscrew analogy up there?  :)
15:02:29 <erisco> data Quot a b = Quot ((Equivalence b, b a) => a)  that is a possibility that I sketched up, using ConstraintKinds
15:03:21 <erisco> here http://lpaste.net/359897
15:05:00 <crucify_me> I mean, the math is close correlation to simple modular arithmetic, right?
15:05:30 <ski> Mercury allows you to define quotient types. but you'll have to ensure yourself that your supposedly equivalence relation (on the representation type) that you supply as equality for the quotient type actually is an equivalence relation. if it isn't, the implementation may generate bad code
15:06:06 <erisco> ouch… but other type systems are expressive enough to define equivalence relations, so what gives
15:07:08 <ski> also, matching on the (non-injectice) data constructor for it is a (committed-choice) non-deterministic operation. that non-determinism either needs to be explicitly promised away (iow, you promist that at a certain stage, you can't distinguish between different representations of the same value) ..
15:08:08 <ski> .. or else you make that non-determinism part of your I/O behaviour, allowing the implementation to detect a different representation each time the program is executed
15:08:30 <crucify_me> << ski see moniker
15:09:31 <ski> (committed-choice means that it won't enumerate all possible representations of the value. it'll use the one that is currently used (which is allowed to change at run-time, by optimizations))
15:10:12 <ski> crucify_me : sorry ?
15:10:43 <erisco> hm, pattern matching would be odd
15:10:51 <crucify_me> no just joking like see my nick to gauge how Im feeling
15:11:09 <crucify_me> nick == moniker
15:11:14 <erisco> what if you pattern match on the equiv class, but I am not sure how that would look
15:13:00 <erisco> and that probably has different computability concerns… it would mean being able to enumerate the class, or I would think
15:13:08 <erisco> as well as the classes
15:14:36 <erisco> maybe not enumerate the class… it could be a predicate function
15:14:59 <lyxia> Higher inductive types <3
15:15:03 <erisco> then the question is what the classes are, i.e. so you know what can be pattern matched
15:16:11 <erisco> so you need some function  a -> a -> Bool
15:16:29 <EvanR> o_O
15:16:42 <EvanR> theres const True and const False
15:16:46 <erisco> f x  returns a predicate function characterising the equivalence class with x
15:16:47 <vk> hello
15:17:17 <EvanR> do you mean a has decidable equivalence
15:17:31 <vk> anyone use singletons much? i'm trying to figure something out - I'm able to pattern match on Sing values
15:17:34 <EvanR> DecEquiv => a -> a -> Bool
15:17:39 <EvanR> DecEquiv a => a -> a -> Bool
15:17:49 <vk> but I need to specialize some parameters depending on the sing value branch
15:17:53 <vk> in order to do something useful
15:18:18 <erisco> it isn't stellar pattern matching, but it at least makes sense
15:18:24 <ski> with HITs, one can do something like
15:18:28 <ski>   data ℤ : Set
15:18:30 <vk> problem is I get errors like Could not deduce: blah ~ foo
15:18:36 <ski>     where
15:18:44 <ski>     p - n : ℤ  ⊣  p : ℕ , n : ℕ
15:18:56 <ski>     ℤ≡ p₀ n₀ p₁ n₁ eq : p₀ - n₀ ≡ p₁ - n₁  ⊣  eq : p₀ + n₁ ≡ p₁ + n₀
15:18:59 <ski>                                 ℤ                          ℕ
15:20:11 <vk> ski are you replying to me or EvanR ?
15:20:37 <ski> then when pattern-matching on a ⌜ℤ⌝, one needs both to define the operation on a pattern ⌜p - n⌝, as well as the transport of the operation on a pattern ⌜ℤ≡ p₀ n₀ p₁ n₁ eq⌝
15:20:44 <ski> vk : neither
15:21:27 <erisco> what is a HIT
15:21:33 <erisco> higher inductive type?
15:21:40 <ski> yes
15:22:51 <erisco> I don't know how to read that… the precedences
15:23:22 <erisco> with Haskell's type system I am thinking of a possible emulation
15:23:25 <ski> so, we have a constructor, subtraction, for integers. and we also have a constructor for equality proofs over integers. the equivalence relation we're after is the reflexive-symmetric-transitive closure of the relation the latter constructor is implemented in terms of
15:23:58 <erisco> Quot (a -> Bool)  is an idea but you can't tell which equivalence class it is, so that isn't much point I don't think
15:25:05 <erisco> ski, add parens for me
15:25:29 <ski> (⌜-⌝ binds tighter than ⌜≡⌝ (both the ⌜ℤ⌝ and the ⌜ℕ⌝ version), which binds tighter than the syntactive operator ⌜:⌝, which binds tighter than the syn. op ⌜,⌝, which binds tighter than the syn. op. ⌜⊣⌝)
15:25:49 <ski> (s/syntactive/syntactical/)
15:26:37 <Mizunno> Hello, do you recommend "Programming in Haskell" by Graham Hutton?
15:26:58 <erisco> what is  p₀ n₀ p₁ n₁ eq  ?
15:27:04 <ski> (⌜ℤ≡⌝ is not an infix operator, just an ordinary prefix constructor (well, a constructor not of the data type in question, but of equality proofs of that))
15:27:08 <jared-w> Mizunno: It's pretty decent. A bit on the ivory tower side of things, I suppose
15:27:09 <ski> variable names
15:27:35 <erisco> I think possibly my client is not rendering these characters correctly
15:28:05 <ski> `p's (for positive) and `n' (for negative), subscripted with zero and one
15:28:26 <ski> they could be renamed, with no change in meaning
15:29:25 <erisco> why are we interested in subtraction and addition? I am far missing the plot
15:30:04 <ski> the data constructor for the integers *is* subtraction (of one natural number from another natural number)
15:30:43 <erisco> okay. I am not aware of constructors for integers
15:30:58 <ski> the data constructor for equality on integers ensure that ⌜(p + k) - (n + k)⌝ is equal to ⌜p - n⌝
15:31:44 <ski> e.g. that ⌜5 - 3⌝ is equal to ⌜4 - 2⌝ is equal to ⌜3 - 1⌝ is equal to ⌜2 - 0⌝
15:32:13 <ski> and similarly, ⌜2 - 5⌝ is equal to ⌜1 - 4⌝ is equal to ⌜0 - 3⌝
15:32:34 <erisco> why is this construction of integers appealing?
15:33:06 <ski> it's a formulation of integers, as a quotient type, in terms of a HIT formulation
15:33:28 <erisco> how is it a quotient type? I am definitely confused
15:35:34 <crucify_me> "with an appropriate quotient type... , the function doesn't need to say that 2 and 6 are the *same* number. However, they're in the same equivalence class and so the function is not allowed to *distinguish* between the two."   so I think I get this, numbers (in this case) in a quotient type abide by cycles in modular arithmetic and not by their own numeric value.   
15:35:36 <erisco> Peano Nats are constructed by Z and S n, and you are saying Integers can be constructed by two naturals, one subtract the other
15:35:42 <erisco> I am asking why that is an appealing construction
15:36:20 <crucify_me> is that correct? ^
15:36:22 <ski> the constructor for the equality on integers claims that the integer `p0 - n0' is equal to the integer `p1 - n1', when the natural `p0 + n1' is equal to the natural `p1 + n0'
15:37:05 <erisco> yes fine, I am not talking about the higher inductive part yet
15:37:18 <crucify_me> I quoted jare*d-w
15:37:49 <ski> instead of writing `p - n', one could write `Minus (p,n)'. the equivalence relation on the pairs of the shape `(p,n)' yields the equality on values of shape `Minus (p,n)', aka `p - n'
15:39:33 <ski> erisco : well, i can imagine two other simple constructions of the integers. one would be basically a natural, and a sign bit. however, `+0' and `-0' should not be distinguished, so either we'll need to identify those using an equivalence relation, or we need to use something akin to two's complement
15:40:03 <Mizunno> jared-w: I am want to buy It, or "Real World Haskell". Thanks for the answer.
15:40:13 <erisco> positive and negative zero is annoying, but with  p - n  you have all sorts of redundancy
15:40:16 <Mizunno> I want*
15:40:17 <jared-w> if it's between the two DEFINITELY pick the Hutton book
15:40:29 <erisco> that is why it did not seem like an intuitive choice
15:40:31 <ski> (e.g. so that `(+,n)' is interpreted as `+n', and `(-,n)' as `-(n+1)', avoiding the overlap)
15:41:02 <jared-w> and I misspoke, the Hutton book is not super ivory tower, books by Bird are on the ivory tower side of things. The Hutton book is a decent middle road between "super practical but potentially black magic" and "enlightening but not clear how to apply to real code"
15:41:22 <ski> the other construction is to say that an integer is a pair of naturals, where at least one of them is zero -- but then that requires subset types
15:41:50 <crucify_me> Mizunno: I'm liking the Hutton book but I'm not a programmer. 
15:41:50 <erisco> you could also define as  1 + n | 0 - n
15:42:20 <erisco> like a sign bit, but we've carefully deduped our zero
15:42:38 <ski> erisco : i think the quotient definition of an integer as a subtraction `p - n', of naturals `p',`n', subject to an equivalence relation, is pretty reasonable/appealing ..
15:43:02 <jared-w> erisco: funny you should mention that, there's a fascinating construction of the Natural numbers which avoids zero (it's strictly positive) and uses a binary encoding split between Odd and Even nats
15:43:05 <ski> ok, you don't like the redundancy
15:43:18 <ski> quotient types are all about possible redundancy in representation
15:43:34 <ski> (in some cases you can canonicalize. but not always)
15:43:57 <jared-w> They use that in order to gain a reasonable amount of efficiency yet still keep the capability to perform logical narrowing on an infinite number type that has operations performed on it. In fact, it proves efficient enough that they encoded the Integers in it as well as 0 | Pos Nat | Neg Nat
15:44:07 * ski nods to erisco re deduping
15:44:08 <Mizunno> Okay okay, I just want a book to improve my haskell's skills. I am a beginner, just three months with Haskell.
15:44:14 <HaskellLord69> haskellbook.com
15:44:44 <HaskellLord69> unfortunately not printed yet, but available as a pdf
15:44:44 <sm> @quote FAQ books
15:44:44 <lambdabot> FAQ says: What are some good books for learning haskell ? Haskell Tutorial And Cookbook (HTAC), Programming In Haskell (PIH), Haskell Programming From First Principles (HPFFP)
15:46:02 <Mizunno> Thanks a lot.
15:46:13 <erisco> jared-w, sounds fun!
15:46:28 <ski> erisco : the point here was rather encoding quotient types as HITs, in general, rather than particular cases (like integers, rationals), where you actually can canonicalize (remove the redundancy)
15:46:52 <crucify_me>  " quotient types are all about possible redundancy in representation " ski so that is why they are used to describe Int mod n  ? because the representation is redundant  but the numbers are changing ?
15:46:54 <ski> integers was just a relatively familiar example of what can be cast as a quotient type
15:46:56 <erisco> ski, well you were taking  p - n  further to define something else, and I was just unfamiliar with  p - n  itself
15:47:02 <jared-w> erisco: the people implementing a compiler from Curry (logical functional language) to Haskell did that. It's in the kics2 compiler :)
15:47:24 <ski> crucify_me : i don't know what you mean by "the numbers are changing"
15:48:19 <ski> erisco : instead of writing `Minus (p,n)', i preferred writing `p - n', for the integer constructed as the natural `n' subtracted from the natural `p'
15:48:44 <ski> you could use the other notation, if you prefer
15:49:47 <crucify_me> well mod 3 is  :   ...-6, -3, 0, 3, 6 ... for example -- by representation you mean 3, which is redundant in an arithmetic progression
15:49:51 <erisco> I get what you are saying now
15:49:52 <ski> the HIT definition specifies that an integer is a subtraction of two naturals, and also specifies a non-trivial way in which two such subtractions can be equal
15:50:12 <erisco> I don't have experience with HITs though, and I don't know how the equivalence works wrt pattern matching
15:51:03 <erisco> we pattern match on  p - n  and what do we see?
15:51:14 <ski> crucify_me : yes, if an implementation wanted to, it should be able to (silently) replace one representation, say `6', with another equivalent representation, say `3', at run-time
15:51:18 <erisco> well we can't see  p  and  n  themselves
15:51:19 <jcarpenter2> last i heard it's sort of an open research area
15:51:33 <ski> erisco : yes we can
15:51:44 <jcarpenter2> it would be tough to pattern match on an HIT, since you would need to make sure that equal patterns evaluate to equal results
15:51:54 <erisco> why? I thought the whole point was to hide them?
15:52:22 <ski> but we must ensure that if `(p0,n0)' and `(p1,n1)' are equivalent, then our pattern-matching operation on `p0 - n0', vs. on `p1 - n1', will produce equal results (possibly equal in a nontrivial way)
15:52:51 <erisco> that is why I said we shouldn't see  p  or  n  themselves
15:53:02 <erisco> but, like you said before, maybe a nondeterministic semantics is possible
15:53:08 <EvanR> if the equality involves a proof of something, you cant hope to automatically detect equality or inequality
15:53:15 <ski> yes, but we must be able to access the underlying naturals, in order to perform arithmetic on them
15:53:18 <erisco> and so you see all the possibilities … but that changes the language a lot, I'd think
15:53:46 <erisco> well what I was suggesting is that maybe there is some way to know which equivalence class it is
15:54:14 <erisco> so, for example, with 4Z, we don't know if it was 0 or 4 or 8 or whatever, but we know it was from that equivalence class
15:54:15 <monochrom> Um, I think you mean which element of the equivalence class.
15:54:17 <crucify_me> that's interesting I'm a step closer now. thanks ALL
15:54:27 <erisco> no I mean which equivalence class
15:55:09 <EvanR> not all equivalence classes have a identifiable representative
15:55:23 <EvanR> or normalization
15:55:24 <crucify_me> glad I got you all thinking , you were getting a little soft there for a while ...  :)
15:55:31 <jcarpenter2> they do with the axiom of choice :V
15:55:37 <erisco> it would muck with the computability a lot, I reckon, but it was an idea
15:55:39 <EvanR> uh huh...
15:55:40 <jcarpenter2> idk if that axiom applies or not
15:55:53 <EvanR> which is why quotients make me knee jerk think its just a bunch of classical logic
15:56:40 <EvanR> and HITs dont correspond to anything computable
15:57:01 <ski> jcarpenter2 : i'd like extensional AoC to apply ..
15:57:07 <erisco> it is difference from the nondeterministic version because we get to observe the class itself as an object, like a list of elements, say
15:58:04 <erisco> if you have some decidable equality  a -> a -> Bool  then applying once gives you an equivalence class (characterised by the predicate function)
15:58:18 <erisco> unfortunately, with this representation I don't see any way to know which equivalence class you've got
15:58:29 <erisco> but you can at least tell if something is in it or not… *shrug*
15:58:38 <erisco> if that is good enough then at least it is something
15:59:04 <EvanR> you can ?
15:59:13 <EvanR> only if you have 2 things in the class to begin with
15:59:14 <ski> in the formulation i mentioned, there is no equivalence classes mentioned. just nontrivial equalities
16:00:03 <crucify_me> this is the article that I was trying to get through on quotient types  http://www.hedonisticlearning.com/posts/quotient-types-for-programmers.html
16:00:24 <EvanR> yeah theres a big leap from equality to equivalence class, set language
16:01:16 <erisco> ski, I was just being particular to what is possible in Haskell
16:02:13 <monochrom> ski: In HIT, is there any guard that ensures that I am really defining an equivalence relation?
16:02:29 <monochrom> or maybe s/ensures/checks/
16:03:34 <erisco> if you can compute a canonical representative for the equiv class, though, then you do have the possibility of knowing which class it is
16:04:00 <erisco> though "which" is maybe too strong to say, as you don't necessarily have a way to enumerate all the classes / canonical representatives
16:04:30 <EvanR> you are labeling it with the representative
16:04:38 <EvanR> so that answers the question
16:05:36 <monochrom> erisco: Your question is deep. But you may like to start with asking it of Data.Ratio, the poster boy of quotient types right in Haskell.
16:05:41 <ski> monochrom : you automatically generate the reflexsive-symmetric-transitive closure of the relation specified, is my understanding
16:05:46 <EvanR> monochrom: on page 201 of my hott book, it defines a quotient by a relation as a HIT... where you must provide a proof of equality for any two things that are related
16:06:20 <ski> here's how `negate' on integers could be defined
16:06:25 <ski>   negate k : |Z  -|  k : |Z
16:06:30 <ski>   negate (n - p)  =  p - n
16:06:35 <ski>   map== negate (|Z== p0 n0 p1 n1 eq)  =  |Z== n0 p0 n1 p1 (symm (n0 + p1) (n1 + p0) (comm+ n1 p0 . eq . comm+ p1 n0))
16:06:55 <EvanR> but it doesnt say that it must be an equivalence relation
16:06:59 <erisco> heh, swap is kind of nice
16:07:14 <ski> the last equation defines the transport of `negate' over the nontrivial equality (coming from the integer equality constructor `|Z==')
16:08:25 <EvanR> erisco: the unordered pair ?
16:08:33 <jared-w> That kinda trickery is used to good effect in the numeric representation for the kics2 compielr of Curry :p
16:08:49 <ski> `comm m n' is a proof that `m + n' is equal to `n + m'. `.' is transitivity of equality. `symm x y eq' is a proof that `x' is equal to `y', given that `eq' is a proof that `y' is equal to `x'
16:09:13 <erisco> monochrom, good call
16:09:51 <erisco> EvanR, n - p  becomes a nice construction of integers at least because negate becomes merely a swap, is what I am saying
16:10:13 <EvanR> yeah
16:10:33 <EvanR> integers are two nats plus an equivalence
16:10:41 <ski> monochrom : .. at least, that's how it's done in "Categorical Logic and Type Theory", by Bart Jacobs
16:11:24 <erisco> if we did  n - p  like ratios then we'd decrement n and p until at least one is zero
16:11:34 <erisco> that becomes the canonical representative
16:11:45 <EvanR> yes there is a recipe to get a representative
16:12:12 <ski> erisco : addition of two integers `p0 - n0' and `p1 - n1' will similarly be defined as `(p0 + p1) - (n0 + n1)'
16:12:37 <jared-w> and subtraction becomes swap of addition, another nice win :)
16:12:46 <EvanR> if you visualize the space as an infinite chess board, thats the horizonal line going through 0
16:13:19 <erisco> so if you have a function  canon :: a -> a  such that  canon x  is the canonical representative of the equiv class containing x, that's a sensible way to implement quotients
16:13:25 <EvanR> the set of "canonical" reps
16:13:45 <EvanR> thats the fallback way :(
16:13:47 <erisco> ski, reminds me of complex numbers
16:14:00 <EvanR> its all we really have, and it doesnt work in general
16:14:23 <EvanR> it doesnt turn out nice in dependent types, at least for integers and rationals
16:14:34 <ski> erisco : .. ratios *could* also be done as a quotient. to determine whether `n0 / d0' is equal to `n1 / d1', you don't need to cancel common factors in the numberator and the denominator. you can just check whether `n0 * d1' is equal to `n1 * d0'
16:15:07 <erisco> when playing infinite chess, on which square lies your king? and when you castle where are the final places for the king and rook? :P
16:15:56 * ski . o O ( quotients could be done as quotients )
16:17:02 <erisco> yes
16:17:09 <erisco> I don't know what is allowed when defining the equality
16:17:24 <erisco> I am used to defining an inductive equality
16:17:32 <EvanR> anything goes
16:17:33 * ski suggests as an exercise to check that multiplication of integers, using the above representation, is well-defined ..
16:17:45 <ski> anything goes, yes
16:18:11 <erisco> (p0 - n0)*(p1 - n1)  you mean?
16:18:21 <ski> yes
16:19:12 <erisco> (p0*p1 + n0*n1) - (n0*p1 + p0*n1)
16:19:15 <ski> to show that it is well-defined, you have to show that multiplication of two integers, represented in two different ways, yield as respective results two integer representations, which represent the same integer
16:19:31 <ski> erisco : that's the easy part :)
16:19:53 <erisco> well I like to show progress
16:20:02 * ski nods
16:21:40 * ski idly ponders definition of higher coinductive types, coinductive types with a nontrivial apartness
16:21:49 <erisco> that showed it was closed
16:25:34 <erisco> an exercise in FOILing… or I am not seeing the easy way
16:26:02 <EvanR> you used the distributive law on a symbolic constructor? :)
16:26:35 <erisco> I have a license
16:35:47 <lkj> is there a good tutorial / example for how to use the Decide module in singletons?
16:48:07 <EvanR> i am working on a dynamically typed, hard to parse, undebuggable, featureless, slow version of haskell in order to quickly see changes to my program without having to go through a recompile relink step and get feedback quickly
16:48:12 <EvanR> what am i doing wrong
16:48:46 <MarcelineVQ> you forgot to check if https://hackage.haskell.org/package/rapid was enough to get you going
16:50:11 <monochrom> Dynamically typed Haskell? Where did you get that?
16:50:45 <EvanR> what happens if you dont also implement a type system
16:50:50 <MarcelineVQ> inspired by angelscript(tm)
16:50:58 <EvanR> ^
16:51:39 <EvanR> but not common lisp
16:52:59 <jcarpenter2> soundfs like Greensupn's 10th rule
16:54:48 <EvanR> im not sure if rapid will require more or less engineering to get ahead
16:55:36 <EvanR> at least, the hard to parse part would be simplified by using lisp syntax... but then its hard to type
17:31:00 <suzu> EvanR: hahahahah
17:50:35 <EvanR> interesting
17:50:58 <EvanR> stack does not seem to like sdl2-1.3.1
17:52:26 <EvanR> something to do with the snapshot?
17:55:02 <EvanR> is it possible to override the version of sdl2 listed in the lts
18:07:14 <suzu> yes
18:07:47 <suzu> add the one you want to `extra-dep`s in stack.yaml, and then sdl2 with the version you want to your .cabal
18:08:54 <zachk> sdl and haskell on windows is a living nightmare, maybe it is better with msys2, dunno
18:11:17 <EvanR> hmm
18:12:26 <EvanR> back to thinking it might be simpler to write a C file and FFI to it
18:26:52 <codeshot> Psybur, you here?
18:28:29 <codeshot> I did some variations on Psybur's memoisation study but ghc memoises well without me doing anything: https://pastebin.com/kd8PhjvA
18:28:46 <codeshot> How come? And why does it take forever to exit the program?
21:34:32 <vaibhavsagar> does ghc --make not follow modules in the current directory?
21:48:02 <jcarpenter2> > show "\""
21:48:04 <lambdabot>  "\"\\\"\""
22:39:46 <jcarpenter2> @pl \f a b c -> f c a b
22:39:46 <lambdabot> (flip .) . flip
22:39:54 <jcarpenter2> you don't say
22:41:14 <jcarpenter2> @pl \f -> \a b c -> f c a b
22:41:14 <lambdabot> (flip .) . flip
22:43:34 <jcarpenter2> @bl \f c a b -> f a b c
22:43:34 <lambdabot> Maybe you meant: pl bf
22:43:39 <jcarpenter2> @pl \f c a b -> f a b c
22:43:39 <lambdabot> flip . (flip .)
22:44:03 <jcarpenter2> amazing
22:45:48 <jcarpenter2> i hesitate to actually write "flip . (flip .)", it's too terse
22:47:18 <clever> are there docs on what lambdabot can do?
22:47:38 <clever> ah, https://wiki.haskell.org/Lambdabot
22:50:07 <ziman> hello, on Arch Linux, it seems I can't stack-install any packages with C code in it (?), with error: "relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC". I spent so much time googling and trying out stuff but I still don't understand what's going on and how to fix it. What does everyone else on Arch do? (I suspect it's a recent ghc/gcc version clash.)
23:10:36 <cocreature> ziman: for some people installing ncurses5-compat-libs and then running "stack setup --reinstall" seems to help
23:12:05 <cocreature> ziman: https://github.com/commercialhaskell/stack/pull/3521 also seems relevant
23:22:43 <nshepperd> codeshot: what's the type of fibs? if it's not something polymorphic, it will be saved and reused at each reference
23:25:17 <xacktm> is `data MyType = A | B | C` and `data MyType = B | C` supported by DuplicateRecordFields ?
23:25:33 <ziman> cocreature: thank you so much! adding "ghc-build: nopie" to ~/.stack/config.yaml seems to have helped
23:25:55 <nshepperd> also, memoizing fib like that will only reuse the memoized result if it is called on the same exactly input. so, [fib 400000, fib 400001] -> no benefit
23:25:59 <ziman> i think it would be tinfo-nopie or similar otherwise
23:28:00 <xacktm> (or is that something for OverloadedRecordFields?)
23:28:23 <xacktm> I might have to add a dummy suffix/prefix or soemthing hmm
23:29:55 <cocreature> xacktm: afaik DuplicateRecordFields does only cover record fields as the name suggest, it does not cover constructors
23:30:42 <xacktm> ok thanks (I wasn't sure what that was called)
