00:00:00 <opqdonut> well `V3 <$> f a <*> f b <*> f c`
00:00:09 <geekosaur> :t liftA3
00:00:11 <lambdabot> Applicative f => (a -> b -> c -> d) -> f a -> f b -> f c -> f d
00:00:33 <dminuoso> geekosaur: Im unsure how to handle `f`
00:00:56 <dminuoso> opqdonut: Yeah, I had that originally but switched to `pure` because it felt a bit cleaner
00:01:08 <geekosaur> you're thinking of some kind of map loop? the problem with that in the general case is you might need a polymorphic list
00:01:20 <geekosaur> in the specific case you might not, but I suspedt you also don't gain anything
00:01:27 <dminuoso> geekosaur: Well something similar to `sequenceA (V3 fa fb fc) = (liftA3 V3) fa fb fc`
00:01:51 <dminuoso> (I also wish I could write that without the fa/fb/fc points, but I dont think thats possilbe)
00:02:11 <geekosaur> you dont need the parens there
00:02:20 <geekosaur> liftA3 V3 fa fb fc
00:02:39 <dminuoso> geekosaur: Yeah, also had that originally, it's hard to get used to memorizing all the fixity.
00:02:58 <geekosaur> this isn't fixity, just how application works
00:03:12 <nshepperd> data V3 a = V3 a a a deriving (Functor, Traversable)
00:03:13 <geekosaur> f a b c = (((f a) b) c)
00:03:15 <dminuoso> Oh..
00:03:29 <dminuoso> nshepperd: The rules of the assignment were to not derive it from Traversable. :P
00:03:38 <nshepperd> (:
00:05:05 <nshepperd> you could define a function 'on3' that's like the ternary version of 'on'
00:05:27 <nshepperd> and do, (liftA3 V3 `on3` f) a b c
00:05:40 <nshepperd> but imo that looks worse
00:05:44 <dminuoso> nshepperd: Yes! Thats precisely what I was somehow looking for.
00:05:52 <dminuoso> (Not that I wanted it, Im just trying to explore different ideas)
00:07:48 <dminuoso> nshepperd: Though Im beginning to realize that the "elegant" thing Im looking for, is what Im implementing.
00:08:06 <dminuoso> i.e. `traverse` is exactly that. 
00:10:36 <nshepperd> yes
00:11:20 <mniip> hmm
00:11:31 <mniip> seriously contemplating naming a module Foo.Internal.Internal
00:12:25 <nshepperd> traverse sort of defines what it means to uniformly act on the contained values, so it's unlikely that you can get that information from elsewhere
00:13:24 <nshepperd> without using Generic or DeriveTraversable to pull out 'uniformly' and 'contained' from the type definition
00:15:54 <nshepperd> mniip: so if importing Foo.Internal means I accept API breakage, does importing Foo.Internal.Internal unleash demons?
00:16:19 <mniip> more like
00:16:24 <mniip> Foo is a nice API
00:16:30 * nshepperd . o O (Foo.Infernal)
00:16:36 <mniip> Foo.Internal - bits of C ffi start leaking out
00:17:02 <mniip> Foo.Internal.Internal - the Internal API is a lie created by the NSA
00:18:11 <nshepperd> heh
00:18:43 <mniip> I'm wrapping a C API that has an opaque value that has to be passed to all functions,
00:19:05 <mniip> the Internal.Internal module handles that value
00:19:21 <nshepperd> well, if it's an ostensibly stable (if low level) api, you could call the middle level Foo.Raw. or something
00:20:52 <ertes-w> hell
00:21:48 <ertes-w> dminuoso: correct…  now as you saw, if you use 'traverse' with f = Identity, then it acts like 'fmap'…  in other words it acts like a "setter"
00:22:46 <ertes-w> dminuoso: the magic of lenses has two components: the first component is that you can actually compose these "setters" using ordinary function composition
00:23:30 <ertes-w> > runIdentity (traverse (\x -> Identity (x^2)) [[1,2], [4,5], [3,2]])
00:23:32 <lambdabot>  error:
00:23:32 <lambdabot>      • No instance for (Num [Integer])
00:23:32 <lambdabot>          arising from a use of ‘e_12124532’
00:23:33 <ertes-w> err
00:23:40 <ertes-w> > runIdentity ((traverse . traverse) (\x -> Identity (x^2)) [[1,2], [4,5], [3,2]])
00:23:42 <lambdabot>  [[1,4],[16,25],[9,4]]
00:25:54 <ertes-w> (.) :: ((c -> F d) -> (s -> F t)) -> ((a -> F b) -> (c -> F d)) -> ((a -> F b) -> (s -> F t))
00:26:52 <ertes-w> and it just happens to work out in a way such that the composition can kinda be read in reverse order
00:28:07 <jcarpenter2> Why is the error caught in the first case but not the second? http://lpaste.net/359859
00:28:41 <ertes-w> dminuoso: the second component is that there are other choices for 'f' with different semantics…  in particular there is a choice that makes the whole thing act like a "getter", but not in an obvious way…  to figure that out i'll give you a second exercise:
00:29:23 <ertes-w> dminuoso: exercise 2: write a function that only traverses the first component of a V3 while leaving the two other fields alone
00:29:35 <ertes-w> dminuoso: call it 'traverseX'
00:29:44 <ertes-w> dminuoso: (as in a traversal for the x coordinate)
00:32:03 <ertes-w> dminuoso: part of that exercise is coming up with a suitable type signature
00:34:00 <mniip> @. pl undo do m <- get; f m x
00:34:00 <lambdabot> flip f x =<< get
00:44:39 <kamikz> hello there
00:45:43 <kamikz> can anyone help with a beta reduction explanation?
00:47:03 <ventonegro> kamikz: You'll have better luck by asking the question
00:48:02 <kamikz> Thanks: λz(λm.λn.m)(z)((λp.p)z) why is λz irreducible? i.e., can we not subsitute (λp.p)z into it?
00:48:08 <kamikz> thanks ventonegro 
00:49:24 <opqdonut> lambda usually binds everything to the right
00:50:06 <opqdonut> so that's (\z -> (((\m n -> m) (z)) ((\p -> p) z))) fully parenthesized
00:50:22 <opqdonut> in other words, the (λp.p)z is inside the λz
00:51:14 <kamikz> Ahhh, I see, I was reading up on the left associtiveness of lambda, that -left-ness threw me off a bit. 
00:53:50 <jesyspa> Hi, I'm trying to install agda on Arch, and I'm running into some issues due to the whole dynamic linking thing: basically, any cabal packages I install system-wide only have the .dyn_hi files, so if I install agda via the package manager it complains about the Numeric.IEEE package being broken.
00:54:32 <kamikz> thanks opqdonut. 
00:54:33 <geekosaur> install only ghc and ghc-static (and either cabal or stack) from arch, install everything else via stack or cabal
00:54:42 <jesyspa> I thought of just installing everything I need via cabal manually, but it gets confused and tries to use the system-wide libraries anyway.  Is there some way of telling cabal not to search those?  Or some standard solution to that problem?
00:54:46 <jesyspa> Ah, thanks
00:55:02 <geekosaur> remove the system-wide ones other than ghc and ghc-static; they will only cause pain
00:55:28 <geekosaur> and beat the arch haskell maintainer over the head until they read and understand https://wiki.haskell.org/Shared_libraries_and_GHC
00:55:30 <jesyspa> Hm, so I don't need cabal-install installed via the system, either?  I thought that would be necessary for cabal.
00:55:48 <geekosaur> cabal-install you need, yes. although you could get it via bootstrap install if needed
00:56:09 <geekosaur> or stack, in which case I think I'd recommend installing via their installer instead of using the arch one
00:56:24 <jesyspa> Both cabal-install and stack have a bunch of dependencies that mess things up :(
00:56:30 <jesyspa> I'll take a look at their own installer.
00:59:07 <jesyspa> Oh, I guess this is what I want? https://aur.archlinux.org/packages/stack-static/
01:01:35 <terrorjack> Simply dropping the stack executable on your PATH is sufficient
01:02:04 <terrorjack> s/on/onto
01:02:11 * mbrock tries to decide how to do a simple `Text` parsing task like extracting the type and indices for a declaration like "int[8][32]"
01:02:36 <mbrock> I don't yet have a dependency on a regexp or parsing library
01:02:37 <jesyspa> Ah, thanks, I'll try that as well.
01:03:50 <terrorjack> Speakong of cabal-install, there are some flags for cabal configure to shadow global/user package database
01:04:49 <mbrock> sometimes in Haskell I just write some manual state machines to avoid having to choose and learn a regexp library
01:05:31 <terrorjack> I usually go for some libpcre binding
01:06:30 <mbrock> hmm, I try to avoid new native libraries because it usually means I have to mess around with the awful thing that makes a static binary of my program :)
01:09:35 <mbrock> think I'll go for parser combinators
01:09:50 <liste> parser combinators are definetely the way to go
01:10:01 <terrorjack> Parser combinators are great except when you need to read from a file
01:10:09 <terrorjack> On runtime
01:10:25 <mbrock> I don't in this case, but out of curiosity why's that a problem?
01:11:04 <terrorjack> You'll need to reinvent some surface syntax and construct the parser combinators on the fly
01:11:20 <liste> oh, so determining the parser expressions dynamically?
01:11:22 <mbrock> oh, you mean like having the "grammar" in a file?
01:11:26 <mbrock> :)
01:11:29 <terrorjack> Yup
01:12:07 <mbrock> good thing my grammar is a timeless and eternal Platonic form
01:12:46 <mbrock> now I just have to use the axiom of choice on the set of parser combinator libraries
01:13:15 <terrorjack> I once even went as far as invoking ghc api, so you can write an attoparsec parser in a .hs script and use it on runtime
01:21:29 <ertes-w> mbrock: one advantage of parser combinators is that once you have learned one of them, you'll more or less be able to pick up any of them
01:22:45 <mbrock> yeah, I'm familiar with them, but I don't really know whether to go for Parsec, Attoparsec, Trifecta, or some other one
01:22:53 <mbrock> it's not a big problem because either will probably be fine
01:24:16 <mbrock> it's a bit curious that parsing is a strength of Haskell but it's also an area where you're immediately faced with a lot of choices
01:24:30 <ertes-w> mbrock: trifecta for human languages (best failure diagnostics), attoparsec for machine languages (fast, but little to no failure diagnostics), megaparsec sits somewhere in the middle (easy to learn, reasonably fast, simple diagnostics)
01:24:46 <mbrock> ah, didn't know about megaparsec :)
01:24:53 <ertes-w> mbrock: and parsec is…  just go with megaparsec, if you want to go for the middle ground
01:25:06 <mbrock> ok yeah, sounds good
01:26:27 <terrorjack> so you never need to remember to 'try'
01:26:55 <terrorjack> attoparsec has auto backtracking
01:27:30 <cocreature> megaparsec is getting to a point where it is at least close to attoparsec when it comes to performance and diagnostics have also been improved recently
01:27:48 <cocreature> so maybe we’ll get to a point where it can supersede both attoparsec and trifecta
01:27:54 <mbrock> happy to hear about a nice default choice!
01:31:21 <mbrock> it has a simple `parseMaybe`, that's very nice :)
01:38:09 <mniip> in FFI, how do I pass a haskell value to C as an opaque void*?
01:39:53 <merijn> mniip: Well, you could pass any Ptr a, but that's probably wrong. What are you trying to do?
01:39:57 <cocreature> mniip: StablePtr
01:40:11 <merijn> mniip: Is the goal to have C hold a pointer to a Haskell value that later gets passed back to Haskell?
01:40:17 <merijn> mniip: If yes, see cocreature's answer
01:40:23 <mniip> merijn, void set_callback(void (*cb)(void *), void *);
01:40:27 <mniip> that kinda thing
01:40:33 <merijn> mniip: Yes, StablePtr
01:40:52 <merijn> mniip: That prevents your Haskell value secretly getting moved/garbage collected and segfaulting your code
01:41:00 <cocreature> if the callback is coming from Haskell you can also just ignore the void* since you can capture things in closures
01:41:05 <merijn> (if your lucky, silent memory corruption otherwise)
01:41:35 <merijn> nullPtr combined with "const myCallback" would also work, yeah
01:41:40 <mniip> cocreature, can I?
01:41:51 <mniip> that doesn't sound... good
01:42:07 <merijn> mniip, cocreature: Yes, you can, but you'll have to dynamically get the function pointer
01:42:12 <mniip> yeah
01:42:20 <cocreature> right
01:42:28 <mniip> I'm not sure if that's a good idea
01:42:31 <cocreature> why not?
01:42:53 <mniip> well, what is that, intrinsically?
01:43:03 <mniip> a pointer to a specially allocated piece of executable memory?
01:43:18 <cocreature> I have no idea :)
01:43:21 <cocreature> but it works™ ;)
01:43:25 <mniip> something in this whole idea throws me off
01:43:28 <merijn> mniip: And what's the problem if it is?
01:43:33 <merijn> mniip: I have an example using it
01:43:47 <merijn> mniip: https://github.com/merijn/SNet2.0/blob/master/SNet/Interfaces/C.hs#L22-L23
01:44:07 <merijn> The wrapper: https://github.com/merijn/SNet2.0/blob/master/SNet/Interfaces/C.hs#L52 the usage
01:44:30 <mniip> are those collected
01:44:33 <mniip> and if so how
01:45:33 <merijn> mniip: I recommend consulting the oracle. By which I mean, the GHC manual
01:45:41 <cocreature> they’re not collected
01:45:48 <cocreature> there’s a freFunPtr or something like that somewhere
01:45:57 <cocreature> *free
01:48:20 <infinisil> Ahhh I need help
01:48:44 <infinisil> I need to program something kinda simple, with another person
01:49:15 <infinisil> And I really wanna use haskell, it's perfect for the taks
01:49:39 <infinisil> But the other person can't program, the only thing he ever did was a bit of python
01:50:09 <infinisil> Note that this is in the 5th semester of Computer Science bachelor..
01:50:19 <cocreature> teach them
01:50:56 <infinisil> I just taught them about ssh keys yesterday.. it was horrible, he just nodded the whole time, i don't think he got it
01:51:21 <ertes-w> infinisil: you can't just explain
01:51:27 <ertes-w> you have to ask questions
01:51:40 <ertes-w> give them exercises
01:52:23 <infinisil> I'm not there to teach them though, it's like I'd have to guide him through programming :(
01:52:46 <fabien> Hi everyone , how can i print output of some constants ? i saw many solutions on internet but i don't which one use and it's not working like i want
01:53:08 <fabien> Which one is the easiest , i just want to print few things to understand more what i'm doing
01:53:13 <ertes-w> infinisil: i have a feeling that the language won't really matter, and in fact haskell might actually be the best choice anyway
01:53:15 <Ferdirand> doing it alone yourself will take you less effort then
01:53:36 <ertes-w> fabien: 'print'?
01:53:38 <infinisil> ertes-w: You could be right
01:54:20 <infinisil> Ferdirand: I'm afraid of having to undo/correct every one of his commits (assuming he manages to understand git to that point€
01:54:31 <fabien> in a guard function ?
01:54:47 <Ferdirand> shouldn't be too hard to cherry pick based on username :p
01:55:11 <Ferdirand> seriously though, why not contact the teaching staff ?
01:55:28 <ertes-w> infinisil: this right there might be your biggest mistake…  if you want/need to work with someone, you should have faith in them, regardless of their skill…  you're a team; act like one
01:55:44 <infinisil> I knoww...
01:55:48 <Ferdirand> generally when they want you to work in pairs, they want the pairs to be balanced
01:55:58 <ertes-w> fabien: if this is strictly about debugging, you can use Debug.Trace
01:56:14 <bartavelle> is there a liquidhaskell channel, or can I ask questions here (if anybody uses it ...) ?
01:56:41 <Deaddy> fabien: You are probably running into the problem that the variables/constant do not have the correct type for e.g. putStrLn, which takes a String and puts it into IO(). However, often you can precompose the "show" converting many data types into a representable string
01:56:48 <alp> bartavelle, I know they're quite reactive on the issue tracker, maybe they welcome questions there?
01:56:56 <infinisil> Well actually, we're a team of 6, but this guy decided he wanted to work with me on the server side (which is much smaller than the client)
01:57:33 <infinisil> Well I'll see how it goes, gonna ask him about if he'd like to use haskell instead
01:58:35 <infinisil> And teach him to an extent i can bear, and correct all his mistakes lol
01:58:48 <fabien> ok ill try
02:05:59 <AWizzArd> I wished every Haskeller read this and implemented those steps about how to write good docs: https://www.divio.com/en/blog/documentation/
02:06:18 <fabien> im trying to print my Set with in a guard function but it's not working |trace (print myset) length mymap == 0 = False
02:06:29 <fabien> the type are incorrect
02:07:14 <phadej> AWizzArd: lead by an example
02:07:29 <AWizzArd> Si.
02:07:49 <phadej> fabien: you probably want to use traceShowId
02:08:09 <mniip> fascinating
02:08:14 <phadej> or traceShow
02:08:14 <mniip> foreign export ccall call_haskell_hook :: Ptr CString -> Ptr CString -> StablePtr ([String] -> [String] -> IO Eat) -> IO CInt
02:08:14 <mniip> foreign import ccall "&call_haskell_hook" ptr_call_haskell_hook :: FunPtr (Ptr CString -> Ptr CString -> StablePtr ([String] -> [String] -> IO Eat) -> IO CInt)
02:09:34 <fabien> traceShow does the name , my Set isnt the good type , im not sure to understand
02:09:40 <fabien> • Could not deduce (Show t1) arising from a use of ‘traceShow’
02:10:00 <fabien> Set derived show , i saw it in the docs 
02:10:36 <phadej> Show t1 => Show  (Set t1)
02:10:49 <phadej> the elements must be showable too
02:11:09 <fabien> what does it mean ?
02:11:10 <fabien> aha
02:11:14 <fabien> its a Set
02:12:48 <mniip> merijn, how am I supposed to properly link stuff?
02:13:16 <mniip> if I'm implementing a shared object that exports a couple C functions
02:13:37 <merijn> mniip: Are you linking a Haskell lib into a C executable, or a C lib/C object files linked into a Haskell executable
02:13:48 <mniip> the former
02:14:11 <merijn> The easiest way, is to have GHC do the linking for you
02:14:36 <merijn> mniip: Minimal example using a C main file here: https://gist.github.com/merijn/4a0fee2b3a5ef3476aa4
02:14:38 <mniip> well currently my commandline looks like -L/usr/lib/ghc-8.2.1/rts/ -L/usr/lib/ghc-8.2.1/containers-0.5.10.2/ -lHSrts-ghc8.2.1 -lHScontainers-0.5.10.2-ghc8.2.1
02:14:45 <mniip> which I expect is not how it's supposed to be
02:15:24 <merijn> mniip: Well, if you use GHC for linking than GHC is responsible for passing all the right linker flags, so you don't have to think about it
02:15:33 <mniip> but then it doesn't work
02:15:43 <merijn> mniip: Can you define "doesn't work"?
02:15:43 <mniip> my .so doesn't DT_NEEDED the rts
02:15:50 <mniip> and dlopen fails with undefined symbols
02:16:43 <mniip> if this were a C program I'd rightfully add -l onto the 'gcc -shared' commandline
02:16:50 <merijn> mniip: Right, but then you're still having GHC build a .so, yes? As I said the easiest solution is to have GHC link the final executable. You can have GHC build a standalone .so too, but I don't know the exact details. I think monochrom has a page with the relevant linker voodoo?
02:17:07 <mniip> oh er
02:17:11 <mniip> I don't control the executable
02:17:13 <mniip> that loads the .so
02:17:43 <merijn> mniip: ok, then you will have to tell GHC to link the RTS into the .so, but I don't remember how to do that
02:19:24 <mniip> monochrom, ?
02:21:05 <MarcelineVQ> merijn, mniip: if dat boys awake right now I'd be pretty surprised.   http://www.vex.net/~trebla/haskell/so.xhtml
02:23:36 <razvanc-r[m]> helllllooo
02:23:38 <razvanc-r[m]> quick question
02:23:56 <razvanc-r[m]> has anyone had success with reflex + stack with latest version of ghcjs/stak lts etc.?
02:24:01 <hariOm> hello all
02:24:56 <merijn> razvanc-r[m]: Yes, no, maybe? :)
02:25:08 <hariOm> I am trying to run distributed-process-simplelocalnet example given here https://hackage.haskell.org/package/distributed-process-simplelocalnet-0.2.4/docs/Control-Distributed-Process-Backend-SimpleLocalnet.html
02:25:09 <razvanc-r[m]> that is what I was afraid of :)
02:25:12 <merijn> razvanc-r[m]: If you have a specific question you're probably better off asking that
02:25:37 <hariOm> but the master program is not detecting the slave nodes as mentioned there in troubleshout
02:25:43 <razvanc-r[m]> merijn: well how should I put this, I need a stack.yaml working file :D if anyone has around
02:25:58 <merijn> razvanc-r[m]: Also, for really specific questions about libraries the haskell-cafe mailing list might have a better chance at reaching someone that uses that combo, compared to "whoever happens to be online here"
02:26:38 <razvanc-r[m]> I know you can set packages to be downloaded and built from github with build-dep: true, I have no idea how to use those tho'... to be visible as libraries in the my haskell source code, I'm new to stack :D
02:26:48 <razvanc-r[m]> an example stack.yaml would be the easiest I guess, but I didn't find any :(
02:27:16 <merijn> I don't use stack, so I can't really help you there :)
02:27:16 <razvanc-r[m]> the mailing list hmm, I'll check it out, thanks
02:27:19 <hariOm> anyone having proper knowledge how to do that please help me its urgent for me I have very less time
02:28:36 <ggVGc> too bad, programming usually takes a lot of time
02:28:37 <ggVGc> :(
02:33:43 <tdammers> more like, programming takes time, and if you rush it, it tends to take even more time
03:05:16 <chrisdotcode> test
03:17:40 <hariOm> I am trying to run distributed-process-simplelocalnet example given here https://hackage.haskell.org/package/distributed-process-simplelocalnet-0.2.4/docs/Control-Distributed-Process-Backend-SimpleLocalnet.html but the master process is not recognising the slave process
03:18:29 <hariOm> This msg is given in the troubleshoot option on that page but I am unable to remove the error
03:19:26 <hariOm> please help me if possible ... its urgent for me
03:19:44 <hariOm> I am using linux debian jessie as the OS with stack
03:21:20 <tdammers> hariOm: it would probably help your case a lot if you could lpaste the code you're trying to run, how you compile it, how you run it, and what exactly the error message is you're getting
03:22:55 <tdammers> hariOm: also, have you read the "Troubleshooting" remark?
03:23:06 <tdammers> "If you try the above example and the master process cannot find any slaves, then it might be that your firewall settings do not allow for UDP multicast (in particular, the default iptables on some Linux distributions might not allow it)."
03:28:26 <mniip> damn, this is going to hurt lots
03:28:49 <mniip> I need my shared object to link with ghc
03:38:03 <Philonous> Is there consent on how to choose between hspec and tasty? 
04:08:54 <merijn> Philonous: Well, with tasty you get to use/test my fancy Travis CI output stuff for tasty ;)
04:09:42 <merijn> I dunno if there's any important/crucial differences. Tasty seems simple enough
04:10:32 <merijn> at a quick glance hspec seems to be to fancy with it's pseudo DSL
04:18:13 <toby1851> i've got a structure with a Maybe field inside it - assuming the structure is big enough that i'd rather not write out a positional pattern match, is there a better way to match on that field than this? http://lpaste.net/359866
04:19:34 <merijn> toby1851: Eh, you don't have to positional matching for records
04:20:18 <merijn> toby1851: "getAllAccounts LoginData{ loginAccount = Just i } = ..." works
04:20:28 <Philonous> merijn, Oh, where do I get that? And does it work with other CI systems (gitlab's in particular? )
04:21:04 <Philonous> hspec-wai is pretty useful, though. But Maybe that can be used in tasty?
04:21:10 <ecart> Seeing this area ... value: 85 million BRL. whatssap: +55 71 992846919 gmail: unbelievable.lab@gmail.com I accept Bitcoin
04:21:10 <ecart> http://prntscr.com/h7ao07
04:21:10 <ecart> http://prntscr.com/h7aogb
04:21:13 <ecart> sorry
04:21:33 <merijn> Philonous: No, this is Travis specific, in that they do some post-processing on output that I abuse
04:21:46 <Philonous> Oh, OK then. I don't use travis.
04:22:07 <toby1851> merijn: you're right, thanks! Today I Learned... :)
04:22:42 <merijn> toby1851: You may also wanna consult the GHC manual on the RecordWildCards and NamedFieldPuns extensions
04:24:06 <MarcelineVQ> another option toby1851, just for another tool to have, is called pattern guards.  http://lpaste.net/359866
04:24:51 <merijn> MarcelineVQ: Presumably you meant "Just account <- loginAccount loginData"? :)
04:25:31 <MarcelineVQ> merijn: I think yes hehe
04:26:25 <MarcelineVQ> what that lets you do is match a guard if there'e a  Just x  and will bind that x to a name, account in this case, skipping the isJust and let
04:27:56 <merijn> pattern guards are underrated
04:28:00 <toby1851> MarcelineVQ: also thanks - that's a 2010ism it seems (i mainly know 98)
04:28:03 <MarcelineVQ> very yes
04:43:25 <supercynic> is (Maybe . Maybe) more expensive than a custom ternary type?
04:44:04 <tdammers> doubt it
04:44:11 <supercynic> data MaybeMaybe a = Unknown | NotNow | Now a  -- like this
04:44:25 <tdammers> I'd optimize for readability, not performance here
04:44:37 <supercynic> no, i definitely need to optimise this for performance
04:44:46 <supercynic> hmm, i guess it has to be more expensive, because Just is non-strict
04:44:51 <Philonous> Then you want to benchmark and profile anyway
04:44:58 <tdammers> ^ this, pretty much
04:45:19 <supercynic> Philonous: gonna do that anyway…  i just wanted to save myself from having to refactor everything later, if someone knows the answer =)
04:47:03 <tdammers> my gut feeling is that algorithmic complexity and strict vs. non-strict evaluation are what's going to make the difference
04:47:03 <mantasg> Is there a way to automate bumping up package version number in *.cabal file?
04:48:08 <Philonous> You could start with your custom data type and replace it with pattern synonyms when you want to try a different representation
05:05:50 <supercynic> Philonous: good idea!
05:07:10 <betawaffle> what is the most underrated haskell package?
05:11:39 <pacak> base?
05:12:19 <bartavelle> betawaffle: those I wrote!
05:12:29 <bartavelle> obviously
05:12:40 <hpc> acme-microwave, definitely
05:12:48 <hpc> for all those times when you really just need 200 to be less than 170
05:13:13 <merijn> hpc: I dunno, I always liked acme-php :)
05:13:26 <hpc> merijn: sure, but that package is a joke
05:13:36 <hpc> just you wait, haskell will be the leading language among microwave manufacturers
05:13:50 <betawaffle> ok, now what about packages that aren't included in the standard platform but that everyone uses?
05:14:44 <Philonous> I don't think such a package exists
05:15:20 <betawaffle> i don't literally mean everyone
05:15:45 <hpc> yeah, i am having trouble thinking of any packages that are underrated
05:15:47 <betawaffle> is there somewhere that lists packages by popularity?
05:15:49 <ahihi> GotoT-transformers
05:16:17 <hpc> all the packages i have used were all to fill a purpose, and if there's a difference between packages it comes from a difference in need
05:16:32 <hpc> like the various parser combinator packages, none is strictly better than the others
05:16:51 <bartavelle> there are the great divides though, I am used to conduit-*, but some people use pipe-*
05:16:52 <hpc> and there hasn't really been any sort of popularity contest among packages either
05:17:13 <Philonous> betawaffle, Maybe you would be interested in the old 24 days of hackage posts 
05:17:17 <MarcelineVQ> bartavelle: the cool kids are using  machines
05:17:28 <betawaffle> Philonous: maybe?
05:17:29 <hpc> bartavelle: i haven't actually used either of those yet, though i would expect i would pick which one to use on a per-project basis
05:17:39 <MarcelineVQ> *machines-*
05:18:20 <Philonous> betawaffle, Also, you can sort packages on hackage byt DLs, which is an approximation of popularity : https://hackage.haskell.org/packages/browse
05:18:47 <bartavelle> downloads is completely bogus
05:18:57 <bartavelle> it correlates with the numbers of versions you released
05:19:34 <merijn> betawaffle: It might be more helpful to elaborate why you're asking this :)
05:20:35 <betawaffle> merijn: well, i learned haskell many years ago somewhat superficially (mainly because i didn't have stuff to use it for), and now i'm getting back into it
05:21:11 <betawaffle> but i don't know about "all the stuff everyone knows about already"
05:21:33 <merijn> betawaffle: ah, but that's not quite the same as underrated
05:21:46 <betawaffle> sure, i'm sorta asking for both things
05:22:13 <betawaffle> by underrated, i mean favorite packages people have that may be unusual
05:22:20 <bartavelle> betawaffle: there is this thing https://github.com/Gabriel439/post-rfc/blob/master/sotu.md that lists use cases, relative maturity of the ecosystem, and a selection of libraries
05:22:26 <merijn> betawaffle: Useful stuff to look at if you've been away for a while would be: megaparsec (a more modern/polished version of parsec), pipes/conduit (libraries for doing streaming processing of input), lens (for doing basically anything in a single perl expression)
05:22:50 <merijn> betawaffle: oh, the "async" library
05:24:40 <betawaffle> so, i know about conduit, i know about async, i've heard of lens but i don't quite understand it yet
05:26:36 <betawaffle> also... i stumbled on some stream fusion stuff in vector that i can't seem to find documentation on
05:27:27 <betawaffle> is this just an internal sort of thing, or am i supposed to be able to use this? http://hackage.haskell.org/package/vector-0.12.0.1/docs/Data-Vector-Fusion-Stream-Monadic.html#t:Stream
05:28:08 <merijn> betawaffle: Bit of both?
05:28:25 <merijn> betawaffle: It is exposing internals on purpose, so people can extend it with their own stuff
05:28:34 <bartavelle> you probably can just ignore that
05:28:38 <merijn> betawaffle: But it's not supposed to be a particularly easy to use interface
05:29:05 <merijn> betawaffle: More of a "I investigated the internals of vector and wanna add my own fancy stuff on top integrating with those"-deal
05:29:44 <tabaqui> is there any monad transform for exception handlers chains?
05:29:51 <tabaqui> like so:
05:30:09 <tabaqui> I have a list of IO actions
05:30:17 <bartavelle> betawaffle: servant is nice if you write webservices or SPAs
05:30:31 <tabaqui> and in any moment I can get async exception from outside
05:30:57 <tabaqui> and handler have to depend of the current position in this list
05:31:11 <betawaffle> oh yeah, i was gonna ask, is there any good actor-y sort of library?
05:31:14 <merijn> tabaqui: Wrap every element in the list with their own handler?
05:32:07 <tabaqui> merijn: not sure what you mean, but there is a case with forever
05:32:07 <supercynic> tabaqui: do you need cascading?
05:32:13 <tabaqui> supercynic: maybe, dunno
05:32:24 <tabaqui> forever can cause memory leak
05:32:43 <supercynic> tabaqui: i mean something like this:
05:32:46 <tabaqui> but I want that it will "reset" the handler
05:32:52 <bartavelle> betawaffle: not that I know of, and it depends on what you mean by "actor library" ;)
05:33:39 <supercynic> :t foldr (\(open, close) go -> bracket open close (const go)) (pure ())
05:33:41 <lambdabot> Foldable t => t (IO b1, b1 -> IO b2) -> IO ()
05:33:48 <supercynic> tabaqui: ^
05:33:54 <betawaffle> bartavelle: writing a program as actors that communicate and can be supervised/restarted
05:34:22 <betawaffle> i know that's a pretty big topic
05:34:26 <supercynic> tabaqui: first open all, then close each that was successfully opened
05:34:37 <supercynic> (till the first failure)
05:34:45 <tabaqui> hmm, not bad
05:34:57 <tabaqui> but how could I "forever" this?
05:35:03 <bartavelle> betawaffle: depending on what you mean by that, you can "roll your own" with bounded channels and threads, but it is not especially nice, and you will have to handle the "supervision" part
05:35:12 <bartavelle> betawaffle: I don't think it is very idiomatic haskell
05:35:21 <betawaffle> ok, that's what i figured
05:35:28 <supercynic> tabaqui: perhaps what you need is not a list, but an actual monad, such that you can use (>>=) instead of (:=
05:35:31 <supercynic> instead of (:)
05:35:34 <bartavelle> betawaffle: OTOH you have the STM, that rocks
05:35:42 <supercynic> tabaqui: Codensity is a more composable version of this
05:36:15 <supercynic> @let import Control.Monad.Codensity
05:36:16 <lambdabot>  Defined.
05:36:19 <supercynic> :t \open close -> Codensity (bracket open close)
05:36:21 <lambdabot> IO a -> (a -> IO b) -> Codensity IO a
05:37:08 <supercynic> tabaqui: this one you can 'forever', but of course if you try to open infinitely many times, it will run out of memory
05:37:26 <betawaffle> should I feel bad for relying on GHC extensions?
05:37:48 <supercynic> betawaffle: no…  i just relied on RankNTypes in the example above =)
05:37:59 <srhb> betawaffle: You should feel awesome, and like a forerunner of technology!
05:38:00 <merijn> betawaffle: It Depends (TM)
05:38:14 <tabaqui> supercynic: right, and I need some "reset" function
05:38:25 <tabaqui> thanks, I'll check the codensity
05:38:29 <supercynic> tabaqui: what's the purpose of 'reset'?
05:38:49 <tabaqui> drop current "close" chain back to "pure ()"
05:39:11 <betawaffle> i'm still trying to get my head around RankNTypes, it doesn't seem like it should be complicated
05:39:35 <supercynic> tabaqui: you need a way to release some resources before you reach the end of the transformer?
05:39:49 <tabaqui> kind of
05:40:09 <supercynic> tabaqui: Codensity can't do that…  once you're in a bracket, the only way to leave is to leave the transformer
05:40:20 <supercynic> tabaqui: for that you need something like ResourceT from the 'resourcet' package
05:40:41 <tabaqui> okaay
05:40:44 <supercynic> betawaffle: i have a tutorial on RankNTypes, if you're interested: https://ocharles.org.uk/blog/guest-posts/2014-12-18-rank-n-types.html
05:40:52 * betawaffle reads
05:41:02 <tabaqui> maybe swap forever and go can solve too
05:41:26 <betawaffle> supercynic: ah, this is good, thanks
05:41:55 <supercynic> "This is the one – the type system extension to rule them all."
05:42:09 <supercynic> i just realised that i wrote this before TypeInType =)
05:42:48 <erisco> which one is that?
05:43:18 <supercynic> erisco: RankNTypes
05:43:24 <supercynic> although the two are more or less orthogonal
05:43:33 <erisco> which is the other?
05:43:42 <supercynic> TypeInType
05:45:57 <erisco> :t id :: forall a. a -> a
05:45:58 <lambdabot> a -> a
05:46:08 <erisco> :t id :: (forall a. a -> a) -> (forall a. a -> a)
05:46:09 <lambdabot> (forall a1. a1 -> a1) -> a -> a
05:46:21 <erisco> :t id :: ((forall a. a -> a) -> (forall a. a -> a)) -> ((forall a. a -> a) -> (forall a. a -> a))
05:46:22 <lambdabot> error:
05:46:22 <lambdabot>     • Cannot instantiate unification variable ‘a1’
05:46:22 <lambdabot>       with a type involving foralls: (forall a. a -> a) -> a0 -> a0
05:48:10 <betawaffle> supercynic: quick question... "if we see the type a -> a, we know that the corresponding value must be the identity function." could you not have an addOne function with the same type?
05:48:35 <merijn> betawaffle: No, because you can't use "+" on all 'a'
05:48:43 <merijn> :t (1+)
05:48:44 <lambdabot> Num a => a -> a
05:48:48 <betawaffle> oh, you're right
05:48:50 <betawaffle> wow
05:48:52 <merijn> betawaffle:  ^^ note the "Num a =>" constraint
05:49:27 <betawaffle> fascinating
05:50:58 <erisco> TypeInType was forged deep within the bowels of Mount Inconsistency. It was also not forged deep within the bowels of Mount Inconsistency.
05:52:43 * hodapp looks at erisco
05:53:07 <erisco> I didn't start the Tolkien!
06:00:39 <buhman> I've seen distributions doing strange installation strategies for haskell packages, where cabal is a runtime requirement. Can ghc also emit golang-style dependency-less binaries?
06:00:59 <merijn> buhman: That's the default for GHC
06:01:11 <buhman> nice!
06:01:22 <merijn> buhman: GHC defaults to linking all haskell libraries statically and linking C/system libs dynamically
06:01:42 <merijn> buhman: Some distros *cough* Arch *cough* changed this, and fucked up their entire Haskell ecosystem
06:01:45 <buhman> yeah
06:01:54 <buhman> actually I'm talking about arch specifically then :)
06:02:11 <merijn> buhman: Yeah, Arch being stupid with their Haskell packages is a known problem
06:02:44 <merijn> buhman: My solution, generally, is to just install GHC's bindist, install cabal and then use those two to deal with installing everything Haskell
06:02:58 <merijn> buhman: This avoids distros being dumb
06:10:34 <betawaffle> supercynic: in your random function example, can GHC actually do that at compile time, or would it be passing some kind of lookup table?
06:13:40 <fabien>  Could not deduce (Show t1) arising from a use of ‘traceShow’
06:13:40 <fabien>       from the context: (Num t1, Num t, Enum t1, Enum t, Ord t, Ord t1)
06:13:57 <fabien> what can i do , i want to print my constant with debug.traceshow ..........
06:14:27 <supercynic> betawaffle: depends on whether it inlines
06:14:39 <betawaffle> if it doesn't inline, is the answer no?
06:15:01 <bartavelle> fabien: add a Show constraint
06:15:15 <fabien> in the signature ?
06:15:16 <supercynic> betawaffle: operationally without inlining the polymorphic function will take one extra argument called a type class dictionary per class
06:15:26 <bartavelle> fabien: yup
06:15:29 <fabien> How 
06:15:40 <bartavelle> fabien: put your function on lpaste, I'll show you
06:15:44 <betawaffle> in your example, i'm imagining your function asking for a table of two function pointers (in the non-inlined case)
06:15:54 <fabien> realLoop :: (Num t1, Num t, Enum t1, Enum t, Ord t, Ord t1) => [(t1, t)] -> Set (t1, t) -> Bool
06:16:11 <bartavelle> add (Show t1) in the parens
06:16:25 <betawaffle> ah, is that how GHC does polymorphic functions?
06:16:35 <supercynic> betawaffle: only the Random constraint mentions a higher-rank type variable
06:16:42 <supercynic> betawaffle: so only one dictionary needs to be passed
06:17:04 <supercynic> betawaffle: regular polymorphism can also do specialisation
06:17:25 <fabien>  Could not deduce (Show t) arising from a use of ‘traceShow’
06:17:31 <fabien> i put show t1
06:17:35 <bartavelle> fabien: then add a (Show t) :)
06:17:41 <supercynic> higher-rank polymorphism can't do that, unless inlining is used, so either you get full inlining, or the outer function is inlined, in which case specialisation can kick in
06:17:42 <betawaffle> in the inlined case, is there no dictionary at all? it can specialize both calls?
06:17:49 <fabien> omg
06:17:51 <fabien> thanks
06:18:06 <fabien> can you explain to me how does it work ? and thank you 
06:18:30 <bartavelle> fabien: the part on the left of the => are constraints, it means that "t" could be anything, as long as it has a "Show" instance
06:18:33 <betawaffle> fabien: your function makes use of show
06:18:39 <bartavelle> basically  means it can be printed
06:18:42 <supercynic> betawaffle: in the fully inlined case (both the randomPlayer gets inlined and genR gets inline within randomPlayer) all the class machinery is gone
06:18:46 <betawaffle> so it needs another constraint
06:18:54 <bartavelle> fabien: you need to look up on typeclasses to get the whole picture
06:19:12 <fabien> its related to deriving right ?
06:19:17 <bartavelle> not really
06:19:24 <supercynic> betawaffle: in the case where only randomPlayer is inlined, GHC can do specialisation of the genR function…  that's another way dictionaries can be erased
06:19:25 <bartavelle> but you can derive instances
06:19:30 <fabien> ok ok
06:19:32 <fabien> thanks
06:19:46 <betawaffle> supercynic: is there any annotation needed to help GHC know it should try to inline that?
06:19:54 <bartavelle> deriving (Show) creates a Show instance for you, if you are just starting with Haskell, don't worry too much about it, it will be clear when you learn about typeclasses
06:20:16 <supercynic> betawaffle: GHC decides whether to inline on some heuristics, and usually it does a good job at that…  if you want to force inlining, you can use the INLINE pragma
06:20:52 <betawaffle> the genR function is the one i would want to be sure was specialized
06:21:26 <betawaffle> ie. i'd want my randomPlayer body to call two separate specialized functions
06:21:31 <supercynic> betawaffle: then you must inline randomPlayer…  in that case the choice on whether genR is inlined depends on where it comes from
06:22:15 <supercynic> betawaffle: let { myGenR = …; {-# INLINE myGenR #-} } in randomPlayer myGenR
06:23:05 <supercynic> alternatively:
06:23:11 <betawaffle> ok, so rank-n *can* be a performance concern if you're not careful, or is it the same risk as all polymorphism?
06:23:35 <betawaffle> like. is rank-1 stuff more likely to avoid dictionaries?
06:23:47 <supercynic> let { myGenR = …; {-# SPECIALISE myGenR :: (Double, Double) -> IO Double #-} } in randomPlayer myGenR
06:24:05 <supercynic> yes, rank-1 stuff is more likely to avoid dictionaries
06:24:26 <betawaffle> ok cool
06:24:44 <supercynic> rank-1 stuff has no interaction between inlining and specialisation, while starting with rank-2 specialisation depends on inlining
06:25:14 <supercynic> BTW, if you're writing a library you should INLINABLE rather than INLINE
06:25:46 <betawaffle> yeah, i know that at least
06:26:05 <lyxia> supercynic: why
06:26:23 <betawaffle> lyxia: gives the user of your library more control
06:26:40 <supercynic> if you inline everything, the code becomes larger, which can outweigh the performance gain of inlining/specialisation
06:27:14 <supercynic> if the code becomes so large that an inner loop no longer fits into the instruction cache, your performance will drop horribly
06:27:25 <betawaffle> do you know how much overhead a lookup in one of those dictionaries adds?
06:27:45 <supercynic> betawaffle: it's the same as accessing an ADT field
06:27:56 <betawaffle> wow, shit
06:28:02 <lyxia> supercynic: isn't that a reason not to INLINE everything rather than use INLINABLE instead?
06:28:02 <betawaffle> ADTs are that slow?
06:28:06 <fabien> I have a little problem of algorithm , do someone has some time for helping me ?
06:28:18 <supercynic> betawaffle: data Monoid a = Monoid { mappend :: a -> a -> a, mempty :: a }  -- a dictionary looks quite literally like this
06:28:26 <betawaffle> ah, ok
06:28:31 <supercynic> betawaffle: no, i didn't say it's slow =)
06:28:37 <supercynic> i said it's the same as an ADT lookup
06:28:52 <supercynic> lyxia: that's what i'm saying =)
06:28:53 <betawaffle> are we talking one or two pointer indirections?
06:29:28 <supercynic> lyxia: hence INLINABLE rather than INLINE, so GHC doesn't just inline everything unconditionally, but still emits the interface code to allow the user of the library to inline
06:29:31 <betawaffle> my guess would be two
06:29:51 <betawaffle> open the box -> read the field
06:29:54 <supercynic> betawaffle: good question…  i would assume one, because there is no reason for a class dictionary to be non-strict
06:30:20 <supercynic> hmm
06:30:22 <supercynic> actually there is
06:30:37 <lyxia> supercynic: hm. Okay, thanks.
06:30:42 <betawaffle> since genR would be boxed
06:30:52 <betawaffle> (i assume)
06:31:18 <supercynic> betawaffle: this is just a model though…  GHC is really good at doing class-specific optimisations
06:31:45 <supercynic> so take everything i say with a grain of salt, and run benchmarks or look at the core output to get actual numbers
06:32:02 <betawaffle> ok
06:32:14 <betawaffle> i'm just trying to understand worst-case behavior
06:33:13 <supercynic> worst case is that you pass an ADT around and pick fields from it…  it drops to a newtype for classes with a single member, in which case you don't pay wrapping costs
06:56:34 <dfeuer> Ping edwardk
07:02:57 <supercynic> well, i am
07:03:01 <supercynic> AFRP can capture this
07:03:36 <MarcelineVQ> oops
07:03:40 <supercynic> whoops
07:12:04 <AWizzArd> Anyone here who has experience using Haskell to query an Oracle DB? (probably via ODBC)
07:14:38 <phaazon> hey, with persistent, do I have to write and maintain my DB outside of the Haskell code?
07:15:03 <phaazon> I mean, since it takes a connection string, it must have the db created somewhere, it dosen’t create it by itself, right?
07:15:06 <phaazon> selda does that
07:15:11 <phaazon> (which comes handy
07:15:12 <phaazon> )
07:15:22 <merijn> phaazon: With SQLite it does create it
07:15:45 <phaazon> I can’t use it, only postgresql
07:15:56 <phaazon> so I guess I have to bootstrap the database with empty tables?
07:16:13 <phaazon> or just create the database, and leave the postgresq/persistent code handle that for me?
07:21:23 <brynedwards> phaazon: persistent has migration functionality which will create your schema for you, it's described here https://www.yesodweb.com/book/persistent
07:38:33 <Redrield> I have neco-ghc and intero-neovim set up for my development environment, and there are some strange errors getting spammed from neco-ghc when I open any .hs file https://hasteb.in/cemesukoxi.dos
07:38:56 <Redrield> I don't know why that's happening, and the recommended `ghc-pkg check` just seems to spit out stuff about missing documentation
07:39:08 <Redrield> I'm using Arch Linux and I got ghc, stack, and cabal from the official repos
07:41:23 <fakenullie> Arch has broken something, many users are complaining
07:41:42 <merijn> This doesn't look like the standard arch problem
07:41:56 <merijn> This just looks like you managed to trash your installation of base/ghc
07:41:57 <fakenullie> Yeah
07:43:34 <Redrield> The wiki mentions an unofficial repo "ArchHaskell"
07:43:41 <Redrield> Should I use that, or should I manage my installation with Stack?
07:45:01 <hexagoxel> but the standard arch problem _is_ that ghc will appear broken with static linking enabled.
07:45:22 <hexagoxel> or am i missing some detail about how these errors?
07:46:41 <merijn> hexagoxel: I only skimmed the errors, so maybe you're right
07:50:02 <benjwadams> Is there a recommended category theory book for people with decent math and comp sci background who aren't mathematicians?  A former professor recommended "Categories for the Working Mathematician", but I felt it needed a more formal mathematics background than what I came from
07:50:50 <benjwadams> I figured haskellers would have some recommendations
07:51:49 <merijn> benjwadams: I haven't found one I like yet...
07:51:56 <merijn> benjwadams: Have you seen Bartosz' blog series?
07:52:27 <benjwadams> I think I've read a few of his pieces.
07:53:17 <fabien> Do someone have some time helping me with my implementation , i see that there is many things i can do better and i'm stuck on something 
07:53:20 <fabien> Someone ?
07:55:36 <hexagoxel> Redrield, merijn: i just tested; I get errors very close if trying to use stack + system-ghc.
07:55:42 <helpmepls> if I want to define a new (+) function for a newtype, how do i go about adding those two variables if not with + ?
07:58:09 <hexagoxel> Redrield: the problem is the one described at "https://wiki.archlinux.org/index.php/Haskell#Problems_with_linking"
07:59:09 <hexagoxel> i don't use/endorse stack sufficiently to give further advice.
07:59:36 <Taneb> helpmepls: you need to define a Num instance for your newtype, and you can pattern match on the newtype-wrapped values to get the underlying values
08:01:02 <helpmepls> Taneb: is there a way to explain that easier, or do you have a tutorial? i am quite new
08:01:19 <Taneb> helpmepls: ah, sorry! How are you learning Haskell?
08:02:04 <Taneb> If you're using a specific guide, telling me where you're up to will help me know what you do and don't already know
08:09:05 <theobromine> i'm working on a web project which requires a REST backend. i'm debating between writing the backend in rust and writing it in haskell. any thoughts?
08:10:22 <beepbeep_> Beginner here. One of the things I like about object oriented programming is how I can guard certain business rules in objects. For example, if I'd have an absurd business rule that a blogpost title can't start with the letter 'A', I can easily guard that business rule in the constructor of my object. How would you do something like this in Haskell?
08:11:30 <portnov> beepbeep_: this is called "smart constructor". Just do not export actual constructor of your data type, and export the function which will perform all checks.
08:11:41 <phaazon> anyone with enough experience with persistent’s migrations here?
08:11:47 <phaazon> I’m wondering how the migrations get generated
08:11:54 <phaazon> (especially the diff)
08:12:05 <phaazon> and whether they’re transactional (rollback possible? state machine?)
08:12:15 <helppls> Taneb: can you repeat what you wrote, I had a dc and lost all logs
08:12:42 <Taneb> helpmepls: ah, sorry! How are you learning Haskell?
08:12:45 <Taneb> If you're using a specific guide, telling me where you're up to will help me know what you do and don't already know
08:12:58 <beepbeep_> portnov, thx :)
08:13:25 <portnov> theobromine: i have some experience writing rest server in haskell+scotty, and it's pretty easy. But i do not have any experience in rust.
08:13:32 <helppls> Taneb: learning haskell with a very long pdf from my uni prof
08:13:43 <portnov> eh
08:13:54 <portnov> helppls: this can be pretty boring :)
08:14:09 <Taneb> helppls: ah! Do you think it's one your professor prepared themselves or one they took from elsewhere?
08:14:09 <helppls> Taneb: but there is only a tiny amount of info on newtype in it, that's why I don't know how to define a new (+) function for a newtype of float
08:14:24 <helppls> Taneb: he prepared it himself I think
08:14:41 <portnov> professors tend to write large and boring pdfs :)
08:15:13 <Taneb> helppls: one thing you can do is if you have "newtype Foo = Foo Float" (for example) you can write "plus :: Foo -> Foo -> Foo; pluss (Foo x) (Foo y) = Foo (x + y)"
08:17:04 <helppls> I'm supposed to implement all calculation operations from the type Num, so I think it's supposed to implement (+) and not plus ?
08:17:45 <Taneb> helppls: yeah, (+) is what it should be if you're doing that!
08:18:04 <helppls> therefore if i do (+) :: otherType -> otherType -> otherType; (+) (K a) (K b) = K (a + b)                    but that doesn't work 
08:18:22 <helppls> because of "Ambiguous variable occurrence "+""
08:19:22 <Taneb> helppls: I think I know what the issue is here but I'm having a little trouble putting it into words
08:19:36 <Taneb> helppls: firstly the types should begin with a capital letter
08:19:52 <helppls> they do, they are called Kurs
08:20:00 <johnw> you can't redefine (+) like this outside of its typeclass
08:20:12 <Taneb> helppls: So it should be (+) :: Kurs -> Kurs -> Kurs
08:20:19 <helppls> it is Taneb 
08:20:33 <Taneb> helppls: OK then
08:20:39 <Taneb> helppls: the second issue is what johnw said
08:21:11 <helppls> how do I define (+) inside of the new typeclass? or is that not possible
08:21:19 <Taneb> helppls: roughly (this explanation is technically incorrect but good enough for now) you're overwriting (+) rather than adding a new implementation of it
08:21:20 <johnw> you'd have to hide Prelude to do that
08:21:29 <johnw> this is road I don't think you want to go down
08:21:30 <Taneb> You need to write "instance Num Kurs where"
08:21:38 <johnw> yes, or make Kurs a Num
08:21:54 <Taneb> helppls: and then do "  (+) (K a) (K b) = ..." (the spaces at the beginning are important)
08:22:33 <helppls> then it tells me that Type signature declarations not permitted in instance declaration :/
08:22:46 <monochrom> That's right.
08:22:48 <Taneb> Have you tried removing the type signature?
08:23:06 <monochrom> This is an error message well said.
08:23:15 <helppls> i removed all type signatures now and it loads without errors, thanks 
08:23:22 <Taneb> Happy to help :)
08:23:26 <Taneb> Glad you got it sorted
08:50:20 <mniip> okay question
08:50:46 <mniip> I'm again getting "    Could not find module ‘Prelude’    There are files missing in the ‘base-4.10.0.0’ package,"
08:50:52 <mniip> but this time I'm using the ghc api
08:58:24 <johnw> interesting
08:58:30 <mniip> hmm
08:58:41 <mniip> did addWay' WayDyn
08:58:47 <mniip> (that's equivalent of -dynamic right?)
08:58:48 <mniip> "    Could not find module ‘Prelude’    Perhaps you haven't installed the "dyn" libraries for package ‘base-4.10.0.0’?"
08:58:49 <johnw> i haven't yet used ghc api
08:59:09 <mniip> though Prelude.dyn_hi is clearly ther
09:11:20 <helppls> how can I implement fromInteger correctly for my new typeclass Taneb ?
09:11:45 <dysfun> by making it convert from an integer?
09:13:27 <Taneb> helppls: you need to somehow take the integer, convert it to a Float, and then make that a Kurz
09:14:02 <Taneb> helppls: it should work out pretty simple, it's obvious when you've seen how it's done
09:14:39 <Taneb> helppls: but you should give it a solid go first
09:15:33 <fragamus> rejecting: haskell-mpfr-0.1 (conflict: base =>
09:15:33 <fragamus> integer-gmp==1.0.0.1/installed-1.0..., haskell-mpfr => integer-gmp>=0.2 &&
09:15:34 <fragamus> <0.6)
09:15:53 <fragamus> How do I get around that ^^^
09:17:23 <helppls> after implementing that, is the correct way to call it K (fromInteger 3) ?
09:18:09 <helppls> forgot to tag Taneb, look prev message please
09:18:53 <Taneb> helppls: if the only integer you want to convert is 3
09:19:11 <Taneb> helppls: I think the answer to the question you meant to ask is "yes" though
09:19:14 <helppls> well any integer at position of 3 for that matter Taneb
09:19:32 <Taneb> helppls: yes
09:19:58 <helppls> thanks Taneb, you were of great help
09:20:10 <Taneb> :)
09:21:00 <fragamus> im just trying to use haskell-mpfr but it seems to depend on something that conflicts with what stack decided to pull in
09:22:47 <sm> fragamus: if you were using cabal, you could try --allow-newer=integer-gmp. (I don't know how to do that with stack)
09:23:59 <sm> haskell-mpfr needs an update, it is specifying an out of date version of integer-gmp
09:25:12 <sm> http://hackage.haskell.org/package/hmpfr looks more up to date
09:30:53 <karuu6> hai
09:51:39 <fragamus> edwardk can you tell me how to include haskell-mpfr in my stack project
09:54:57 <fragamus> (see above error)
10:03:14 <edwardk> fragamus: not sure I ever finished it
10:04:24 <edwardk> I tried writing 2-3 different versions over the years and hvr eventually fixed my gc issues for me
10:04:40 <edwardk> But I never went back and applies that to my code
10:05:53 <edwardk> My focus has since shifted to working lazily with nested homographic transformations rather than mpfr as it gives a nicer story for laziness.
10:06:18 <edwardk> E.g. If you need more precision you can continue turning the crank
10:09:12 <EvanR> nested homographic transformations?
10:17:31 <dminuoso> 09:25        ertes-w | (.) :: ((c -> F d) -> (s -> F t)) -> ((a -> F b) -> (c -> F d)) -> ((a -> F b) -> (s -> F t))
10:17:47 <dminuoso> Can someone tell me what possible (.) this was about? (The subject was lenses and traversables)
10:18:13 <mniip> dminuoso, Prelude..
10:18:21 <dminuoso> mniip: mm?>
10:18:33 <int-e> dminuoso: it's ordinary function composition at a special type
10:18:36 <mniip> :t (Prelude..)
10:18:37 <lambdabot> (b -> c) -> (a -> b) -> a -> c
10:18:42 <mniip> specialized to a long type
10:18:54 <dminuoso> mniip: what is thaaaat.
10:18:55 <dminuoso> o.o
10:19:08 <mniip> function (.) in module Prelude
10:20:42 <dminuoso> int-e: Oh, so ertes just replaced "b" with (c -> F d) and so on?
10:20:50 <int-e> dminuoso: yes.
10:21:07 <dminuoso> int-e: Oh. I kept looking at Category to figure out what instance this could have been about.
10:21:46 <byorgey> answer: it can only possibly be about the (->) instance of Category  =)
10:21:57 <int-e> dminuoso: the point was probably that the types (c -> F d) -> (s -> F t) etc. are Lens s t c d  etc, with a concrete functor substituted for f. (type Lens s t a b = forall f. Functor f => (a -> f b) -> s -> f t).
10:22:11 <betawaffle> can someone explain to me how anyone could do this for a living? https://blogs.msdn.microsoft.com/wesdyer/2008/01/10/the-marvels-of-monads/
10:23:00 <byorgey> betawaffle: do what for a living?
10:23:10 <betawaffle> whatever that language is
10:24:05 <byorgey> C#?  I imagine anyone can write C# for a living much like anyone does anything for a living.  Some parts are joyous, some parts are drudgery.
10:24:47 <MarcelineVQ> C# is one of the better ones really
10:24:57 <johnw> yeah, it's not so bad
10:26:03 <byorgey> regardless of the inherent merits of C#, in general bashing other languages (if that was the intent) is not appropriate for this channel
10:26:18 <betawaffle> it wasn't my intent
10:26:34 <byorgey> OK, glad to hear it =)
10:26:37 <MarcelineVQ> unless it's php
10:27:43 <betawaffle> is there a good explanation of SelectT somewhere? what is it for and how to use it
10:28:47 <byorgey> SelectT as in https://hackage.haskell.org/package/transformers-0.5.5.0/docs/Control-Monad-Trans-Select.html ?
10:29:09 <Zemyla> I really wish that Bits had a method that optionally linked to the finiteBits instance.
10:29:10 <betawaffle> yes
10:29:12 <dminuoso> int-e: Ahh okay. Okay getting a bit ahead of myself.
10:29:20 <byorgey> betawaffle: have you tried reading the papers linked at the top of that page?
10:29:33 <a6a3uh> Hi! Is there a way to make diagrams (I mean diagrams package) interactive? I found Animation stuff in the docs (ability to react on changed time). But no word about interactivity ie ability to react on events (key presses or mouse clicks). 
10:29:34 <dminuoso> Thank you for your insights though, they ahve been noted. Once I advance into lens territory further I hope to decipher this.
10:29:53 <betawaffle> byorgey: math-y papers are very difficult for me to follow
10:30:24 <byorgey> betawaffle: ok, that's fair.  I seem to recall seeing a blog post or two on it somewhere, let me see if I can dig something up...
10:33:34 <byorgey> betawaffle: you might have luck starting with http://math.andrej.com/2007/09/28/seemingly-impossible-functional-programs/ .  Honestly I am not aware of any actual real-world applications of SelectT.
10:33:43 <byorgey> hi a6a3uh!
10:34:41 <byorgey> a6a3uh: diagrams has no direct support for interactivity (though it's something I've wanted to think about for a while).  But you can make basic interactive things "by hand" using e.g. the GTK backend and getting mouse clicks.
10:34:50 <byorgey> the library can help you figure out what was clicked on
10:35:12 <byorgey> a6a3uh: see https://archives.haskell.org/projects.haskell.org/diagrams/blog/2015-04-30-GTK-coordinates.html for an example of how to do that
10:35:34 <betawaffle> ok, so i should just ignore SelectT then?
10:35:48 <byorgey> betawaffle: it depends.  What are your goals?
10:36:27 <betawaffle> byorgey: learn about all the stuff in the platform packages
10:37:05 <a6a3uh> byogrey: Cool! Many thanks for working example! As I'm choosing now the right framework for my task that is very visual intensive. And diagrams looks like a perfect fit except for lack of interactivity!
10:37:58 <byorgey> betawaffle: but why are you doing that?  e.g. just because you like learning about cool stuff, or because you want to be able to quickly choose the right tools to get practical work done, or ... ?
10:38:34 <betawaffle> well, primarily the former, but the latter as well
10:39:04 <byorgey> a6a3uh: cool, let us know how it goes or if we can answer any other questions!  Feel free to ask questions in #diagrams as well (I will always see things posted there and respond eventually).
10:39:33 <byorgey> betawaffle: well, if your goal is to learn about cool stuff, then you should definitely learn about SelectT.  It is mind-bendingly cool.
10:39:43 <betawaffle> well shit
10:40:15 <betawaffle> i really need an example to look at
10:40:24 <betawaffle> (where i actually understand the example)
10:40:27 <EvanR> edwardk: is that related to mobius transformations
10:40:57 <byorgey> betawaffle: ok, well, maybe come back to it later?
10:43:28 <Zemyla> So why does setting prompt2 in GHCi not work?
10:46:05 <cocreature> Zemyla: 8.2?
10:53:37 <Tuplanolla> It was renamed for some reason, Zemyla.
11:01:36 <betawaffle> ah, hmm, SelectT isn't included in the current version of the platform?
11:04:45 <raynold> Ahh it's a wonderful day
11:07:03 <pierrot> Hi. What encoding does Prelude.readFile assume?
11:08:42 <cocreature> pierrot: depends on your locale
11:08:46 <Zemyla> Tuplanolla: What's the new name?
11:09:00 <cocreature> Zemyla: prompt-cont
11:09:47 <pierrot> cocreature: Oh, thanks. Then it should be UTF-8 in my case
11:10:06 <humanoyd> Is there an easy way in ghci to see how an expression is parsed that involves operators with varying binding precedence? Something like :magicCommand 2 + 2 * 3 + 1 == 2 + (2 * 3) + 1
11:21:52 <geekosaur> no command. possibly a flag like -ddump-ds (I think that might be late enough), but that'd be fairly ugly
11:28:13 <humanoyd> geekosaur: thanks
11:29:03 <Tuplanolla> You could use TH to get another ugly version, humanoyd.
11:30:11 <Tuplanolla> First `import Language.Haskell.TH` and then `runQ [| 2 + 2 * 3 + 1 |]`.
11:33:17 <inkbottle> > data Cat = Cat {name :: String} deriving (Eq, Show)
11:33:18 <inkbottle> > let c = Cat {name = "Kity"}
11:33:19 <lambdabot>  <hint>:1:1: error: parse error on input ‘data’
11:33:21 <lambdabot>  <no location info>: error:
11:33:21 <lambdabot>      not an expression: ‘let c = Cat {name = "Kity"}’
11:34:35 <humanoyd> Tuplanolla: interesting, thanks
11:36:18 <inkbottle> The c = Cat {name = "Kity"} is accepted by GHCi, but as what?
11:37:35 <inkbottle> because if afterward I type c, GHCI tell me fields are not filled
11:42:37 <inkbottle> hum, there is a ticket about that, I should use a newer version... (https://ghc.haskell.org/trac/ghc/ticket/13847)
11:44:27 <Zemyla> Hmm, should the definitions of min and max for (for instance) Maybe be changed?
11:44:45 <Zemyla> min Nothing _ = Nothing; min _ Nothing = Nothing; min (Just a) (Just b) = Just $ min a b
11:46:49 <johnw> and what would max be?
11:47:29 <Zemyla> johnw: max Nothing b = b; max a Nothing = a; max (Just a) (Just b) = Just $ max a b
11:48:06 <lyxia> isn't it already that
11:48:06 <johnw> hmm..., I like it so far
11:48:41 <Zemyla> lyxia: No, it's defined using (<=), which is in turn defined using compare, due to it simply being deriving (Ord).
11:49:20 <johnw> Zemyla: suggest it to haskell-libraries
11:49:45 <lyxia> Is it something beyond a matter of strictness?
11:49:57 <cocreature> suggest it to haskell-libraries and experience endless bikeshedding
11:52:52 <betawaffle> hmmm, anyone know of a function that looks like this? (k -> v) -> Map k v -> k -> (v, Map k v)
11:53:39 <betawaffle> i would expect a name like lookupOrInsertDefault
11:53:48 <lyxia> what does that do
11:54:12 <betawaffle> ensures that a map has a value for a given key
11:54:33 <betawaffle> only calculating the value if it doesn't exist 
11:55:25 <c_wraith> why does it take a k -> v instead of just a v? laziness works
11:55:30 <betawaffle> like findWithDefault but where it stores the new value
11:55:41 <lyxia> c_wraith++
11:55:41 <jonge> hey there. i have a TCP client written in haskell/conduit, and i am not happy with how i assemble my outgoing packets to bytestrings. what is the best way to assemble your packet format when you need to match things bytewise?
11:55:56 <betawaffle> yeah, you're correct c_wraith
11:56:49 <lyxia> betawaffle: insertWith (const id)
11:57:14 <betawaffle> but that won't return the existing value
11:58:04 <lyxia> ah right. then something with alterF.
11:58:52 <c_wraith> yeah, you can use alterF with f = ((,) v)
12:01:32 <betawaffle> hmmm, do i really want to be using something like Control.Lens.At?
12:02:06 <c_wraith> most lens operations on Map are implemented with alterF, for what it's worth. :)
12:02:42 <betawaffle> ah, ok
12:03:10 <betawaffle> that answers my question then
12:03:13 <c_wraith> lenses would work. whether they're what you "really want" depends entirely on whether you want to use lenses or not.
12:04:57 <mniip> is it possible to tell cabal to compile C code with cflags from  pkg-config?
12:09:07 <raynold> ahh it's a wonderful day
12:10:16 <hvr> mniip: you mean beyond using http://cabal.readthedocs.io/en/latest/developing-packages.html#pkg-field-pkgconfig-depends ?
12:10:41 <mniip> hvr, that doesn't put the -I's on the commandline
12:11:21 <mniip> $ pkg-config --cflags glib-2.0
12:11:21 <mniip> -I/usr/include/glib-2.0 -I/usr/lib/glib-2.0/include
12:11:33 <hvr> mniip: strange... cause cabal does query --cflags
12:11:43 <hvr> I'd expect them to get used *somewhere*
12:12:55 <mniip> I don't see any pkg-config invocations with -v
12:13:28 <hvr> it's supposed to add --libs and --cflags to the respective build-info block the pkgconfig-depends is in
12:14:00 <mniip> I'm building a foreign-library - perhaps that complicates this?
12:14:34 <hvr> mniip: maybe; can you try if it would have done the right thing for a "normal" component, like library or executable?
12:14:55 <hvr> this could be an oversight/bug in the foreign-lib mode
12:16:02 <NextHendrix> is there a config file for ghc where i can always add a certain flag, globally every time its run
12:16:16 <mniip> hvr, indeed, seems to work fine for 'executable'
12:16:26 <hvr> mniip: please file an issue then
12:26:34 <roltheo> @> foldr
12:26:34 <lambdabot> Maybe you meant: v @ ? .
12:26:39 <roltheo> @ > foldr
12:27:18 <roltheo> @type foldr
12:27:19 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
12:27:28 <roltheo> Good bot
12:33:09 <hexagoxel> @botsnack
12:33:09 <lambdabot> :)
12:42:00 <Psybur> Anyone know how to get a day of week from a LocalTime?
12:42:36 <EvanR> by itself thats not well defined
12:42:59 <EvanR> do you want to treat it as UTC ?
12:43:08 <Psybur> No, as a localtime
12:43:39 <EvanR> a local time could correspond to two (three?) different days
12:43:46 <EvanR> its local
12:44:07 <Psybur> I want the day that it is in the timezone the localtime is?
12:44:20 <EvanR> local time doesnt have a time zone, its a day + time of day
12:44:43 <EvanR> you can take the day out, and get the day of week of that, which corresponds to GMT
12:45:11 <EvanR> midnight of that day
12:45:43 <jcarpenter2> Psybur: Date.Time.Format.formatTime
12:46:33 <Psybur> I see I thought localtime was time local to a timezone heh but thats zonedtime
12:46:50 <EvanR> yeah zoned time is local time + offset
12:48:30 <Psybur> EvanR, dont see a day of week in the Day class
12:49:17 <EvanR> take a day, diff it with a given sunday, then mod by 7
12:49:48 <Psybur> But then how do I get a sunday haha
12:50:01 <geekosaur> http://hackage.haskell.org/package/time-1.8.0.3/docs/Data-Time-Calendar-OrdinalDate.html
12:50:05 <geekosaur> might be of interest
12:50:18 <EvanR> fromGregorian 2017 11 5
12:51:46 <Psybur> EvanR, but my app is traversing many weeks. Im not going to write it in such a way that I supply the first sunday and it takes it from there heh
12:55:50 <Psybur> geekosaur, I suppose sundayStartWeek would work
13:01:16 <mniip> oh wow
13:01:24 <mniip> I just fell victim to unsafeCoerce
13:01:29 <mniip> err
13:01:32 <mniip> unsafePerformIO
13:01:38 <mniip> this never happened before
13:01:47 <MarcelineVQ> unsafeInterleaveCoerce
13:02:02 <MarcelineVQ> what happened?
13:02:04 <mniip> name = unsafePerformIO $ newCString "Haskell"; desc = unsafePerformIO $ newCString "Haskell"
13:02:10 <mniip> I think you can guess what went wrong here
13:03:13 <Psybur> Im trying to compose a boolean expression. How would I do something like (>0) && (<6)) . snd $ (1,2)
13:03:26 <MarcelineVQ> mniip: it couldn't be freed?
13:03:36 <mniip> Psybur, liftA2 (&&) (> 0) (< 6)
13:03:49 <edwardk> day 3 of playing around with backpack: finally tagless: https://github.com/ekmett/coda/tree/522b8231055c7647b10eac33c57043162c126bdf/ref/symantics
13:04:09 <mniip> MarcelineVQ, the two values were CSE'd into one
13:04:11 <mniip> double free happened
13:05:21 <MarcelineVQ> mniip: :X
13:06:01 <Psybur> mniip, thanks
13:06:59 <hexagoxel> mniip: what approach/rule would prevent that, other than -fno-cse? does NOINLINE prevent CSE?
13:07:29 <mniip> (name, desc) = unsafePerformIO $ ...
13:08:53 <hexagoxel> that's a rather local solution, though.. you have to remember to do the same when adding a third instance.
13:09:06 <MarcelineVQ> edwardk: hooray!
13:09:14 <geekosaur> this sounds rather similar to the unsafeInlineIO (aka accursedUnutterable...) saga
13:09:36 <codeshot> mniip, thanks for your help with hoist
13:10:00 <edwardk> MarcelineVQ: you can get some shockingly ml-like code out of backpack without giving up typeclass niceties
13:10:12 <codeshot> This is the function I wanted:
13:10:12 <codeshot>         deFaultStatement :: forall a. Except String a -> IO a                                         
13:10:12 <codeshot>         deFaultStatement = (either (throwIO . ProgramError) pure) . runExcept                         
13:10:13 <geekosaur> (which in turn suggests NOINLINE might well help)
13:11:04 <MarcelineVQ> I don't really follow this at all having still not read Finally Tagless but I'm glad ezyang's backpack is getting some stretching out
13:11:24 <codeshot> If I were to save the action on IO for later then I would do it by using a more sophisticated monad than the IO monad and I think the code would turn out the best that way as I build up it's feature set
13:11:57 <codeshot> I've come to understand monads in a whole new way just because of the hoist challenge
13:12:37 <edwardk> MarcelineVQ: my major use case so far is that backpack can let me write code against an abstract signature that includes involving {-# unpack #-} pragmas against types in that signature
13:12:40 <edwardk> then i can reuse that code
13:12:45 <MarcelineVQ> edwardk: though, is there an easy way to explain what ml-like code means? my functional ponds are basically just haskell and idris so far
13:12:52 <edwardk> and get multiple copies of it without cutting and pasting
13:13:46 <edwardk> MarcelineVQ: well, you can instantiate 'data' types from the signatures as any type that meets the constraints, e.g. () or (Foo,Bar), etc.
13:13:49 <edwardk> not just data
13:14:15 <edwardk> so it feels a lot like the ml-like instantiation of a type where you'll often just pick that it is equal to a pair of things
13:14:30 <edwardk> consider this signature: https://github.com/ekmett/coda/blob/522b8231055c7647b10eac33c57043162c126bdf/ref/symantics/Symantics.hsig
13:14:46 <edwardk> and this very very direct instantiation of it https://github.com/ekmett/coda/blob/522b8231055c7647b10eac33c57043162c126bdf/ref/symantics/R.hs
13:15:04 <edwardk> notice 'type Repr a = a' -- there is not even any newtype noise
13:15:18 <edwardk> similarly https://github.com/ekmett/coda/blob/522b8231055c7647b10eac33c57043162c126bdf/ref/symantics/Q.hs
13:15:46 <edwardk> in https://github.com/ekmett/coda/blob/522b8231055c7647b10eac33c57043162c126bdf/ref/symantics/P.hs i _do_ need a data type
13:21:50 <MarcelineVQ> edwardk: thanks for your explanations, was just going over it all trying to see how things fit. I've gotta go for now but will have another look later
13:38:48 <verlet64> codeshot: the hoist challenge?
13:42:53 <codeshot> The challenge to my understanding
13:43:41 <verlet64> I see
13:43:56 <codeshot> The cluestick truly hit when I asked for an equivalent to hoist to use my default function with plain monads and the answer was "id"
13:43:58 <codeshot> :D
13:44:05 <verlet64> They way it sounded, I thought it was the Haskell equivalent of the ice bucket challenge ;)
13:44:14 <codeshot> It's exactly the same thing
13:44:35 <verlet64> Haha
13:46:09 <mniip> :t maybe
13:46:11 <lambdabot> b -> (a -> b) -> Maybe a -> b
13:46:18 <verlet64> That's a great bot
13:48:16 <codeshot> id is a bit different to hoist thought because id works for m _ -> n _ while hoist only works for m a -> n a
13:48:24 * shapr hops monotonically
13:48:29 <codeshot> well, that's not true
13:48:56 <codeshot> I don't know the syntax necessary to describe my understanding
13:49:32 <codeshot> id works for m specific -> n specific but hoist only works for m universal -> n universal
13:50:29 <codeshot> I wonder if there's a function to yoink hoist out of the transformer to apply to monads so I can apply my same functions with the same tight constraints
13:50:44 <codeshot> yoink is the next important function in haskell
13:50:54 <codeshot> after lift and hoist
13:51:06 <codeshot> followed by teleport
13:51:10 <codeshot> mindmeld
13:51:11 <EvanR> zoiks
13:51:14 <codeshot> and dream
13:51:33 <codeshot> ooh, ascend
13:51:41 <codeshot> warp
13:51:48 <codeshot> dive
13:51:58 <codeshot> swim
13:52:00 <EvanR> these functions with verb names seems terribly imperative
13:52:09 <codeshot> of course
13:52:30 <codeshot> Everything is just imperative definitions in the "discourse" category
13:52:42 <perimysium> is this haskell discord server ran by the same people from here? https://discord.gg/w7wPY2
13:53:06 <shapr> who runs here?
13:53:10 <EvanR> good call, i really should seek out other haskell communities online
13:53:14 <perimysium> idk that's why i'm asking
13:53:20 <perimysium> the discord server is pretty large
13:54:00 <shapr> I've seen reddit, slack, irc, and mailing list Haskell communities.
13:54:08 <shapr> I've seen some overlap in userbase, but not much in admin
13:54:26 <perimysium> oh, i just found that haskell discord through the r/haskell sidebar
13:54:36 <shapr> perimysium: on the other hand, if you find a good community, keep it going!
13:54:38 <perimysium> wondered if it was all tied together
13:54:46 <shapr> not that I've heard
13:54:57 <EvanR> haskell second life ?
13:55:03 <shapr> EvanR: that one never took off
13:55:08 <EvanR> :(
13:55:11 <shapr> was only like five people last I checked
13:55:15 <mniip> daily unexpected Traversable appearance
13:55:24 <mniip> suppress True m f = catch (Just <$> m) (\e -> return Nothing `const` (e :: SomeException)) >>= traverse f
13:55:43 <shapr> perimysium: hey if the discord server is awesome, I want to hear about it :-)
14:01:40 <dsal> Woo, I've got haskell building on arm linux on my desktop machine.  Sucks trying to do this on my laptop.
14:02:02 <perimysium> shapr: it seems nice so far
14:34:10 <verlet64> I'm floating somewhere between beginner and intermediate with Haskell; I can build stuff, its a bit ugly sometimes, I'm a bit slow, but I grok most of the concepts involved. 
14:34:10 <verlet64> I was wondering, what would you guys suggest in terms of open source projects to look at and understand more 'production' code - even better if they're needing contributions!
14:37:09 <[exa]> verlet64: this might be irrelevant but there's notmuch-web thing that would deserve improvements
14:38:19 <verlet64> exa: where would I find it? 
14:38:30 <[exa]> https://bitbucket.org/wuzzeb/notmuch-web/src
14:38:38 <verlet64> exa: I know of notmuchweb from hackernews
14:38:42 <[exa]> it's a nice web interface for notmuch
14:38:51 <[exa]> pretty good for lots of mail
14:39:00 <verlet64> Yeah that's why I know of it
14:39:03 <Welkin> wuzzeb?
14:39:15 <verlet64> A lot of people trying to uh, get off the major email providers on HN
14:39:41 <[exa]> there are no reasonable implementations of fulltext search and mail tags on premises
14:40:11 <Welkin> I use fastmail
14:40:31 <verlet64> I too, use fastmail
14:40:48 <verlet64> I also use gmail because the transition is painful as i slowly move stuff over
14:40:50 <[exa]> is it on-premises and opensource?
14:41:09 <verlet64> off premises I believe
14:41:10 <Welkin> fastmail is a SaaS
14:41:45 <[exa]> ->   :(
14:41:56 <[exa]> but it's nice indeed
14:42:08 <verlet64> It helps that they do email and thats it
14:42:16 <verlet64> As a company
14:42:45 <verlet64> For the more privacy concious
14:43:38 <verlet64> I mean I just did it offhand to be honest, didn't really have a good reason
14:43:56 <Welkin> I needed email for a business
14:44:05 <Welkin> and (Free) gmail didn't cut it
14:44:18 <Welkin> I have several domains mapped to a single inbox for fastmail
14:44:25 <EvanR> email tycoon deluxe
14:47:37 <verlet64> Hm
14:47:48 <verlet64> exa: This repository says it has implemented search?
14:47:56 <verlet64> Is it not fulltext search? 
14:48:01 <Welkin> are you a vervet monkey?
14:48:29 <verlet64> https://en.wikipedia.org/wiki/Verlet_integration
14:48:30 <verlet64> :)
14:50:59 <geekosaur> holumbus (the search backend behind hayoo) does full text search fwiw
14:56:56 <mniip> dammit unsafePerformIO
14:57:01 <mniip> now it executing twice
14:57:21 <Xe> you broke it so you get to keep both parts
14:57:29 <Xe> :P
14:58:14 <mniip> hmm
14:58:34 <Zemyla> mniip: Sounds like you're having idempotence problems.
14:58:38 <Zemyla> You should take some Viagra.
15:00:03 <mniip> can't I declare multiple libraries in a single cabal file - one depending on another
15:04:08 <mniip> aha!
15:04:13 <mniip> just a quirk of cabal
15:10:03 <sm> just one library, as many executables as you like
15:17:33 <mniip> how do I specify which .cabal file to use?
15:25:29 <EvanR> can I make an unboxed vector of strict pairs
15:26:11 <Welkin> you can only unbox primitives
15:26:45 <EvanR> storable vector of storable pairs?
15:27:07 <EvanR> unpacked vector of strict pairs... gimme something here
15:27:44 <Welkin> if you pairs are an array of length two
15:27:46 <Welkin> perhaps
15:27:48 <Welkin> your*
15:28:01 <EvanR> hetero pair
15:34:11 <mniip> ok, here's a dilemma
15:34:30 <mniip> I need a global variable
15:34:33 <mniip> in the C sense
15:34:50 <mniip> should retain value when dlopen'd multiple times
15:35:01 <EvanR> a constant, an initialize-once, or mutable at any time by any thing
15:35:50 <mniip> a global IORef
15:36:01 <mniip> the last one, yes
15:36:22 <EvanR> dang, ive been making whole separate processes for stuff like that
15:36:34 <EvanR> only function is to serve a single value, or be updated
15:50:55 <EvanR> if i dont care about performance, is there a nice alternative to Double
15:51:21 <EvanR> has the same operations, but not NaN Infinity, and other weirdness
15:52:29 <verement> what's wrong with NaN and Infinity
15:52:49 <EvanR> they arent real numbers
15:53:28 <EvanR> division by actual zero should be an error
15:53:35 <hpc> both in the sense that they're awful and also in that they aren't in the set of real numbers
15:55:14 <mtjmullen> EvanR: does Rational work for your case?
15:55:24 <EvanR> no sqrt or trig
15:55:28 <verement> EvanR: you may be interested in http://hackage.haskell.org/package/decimal-arithmetic
15:55:49 <verement> EvanR: it still has NaN and Infinity, but definitely less weirdness, and you could catch division by zero exceptions
15:56:00 <mtjmullen> aeson uses Scientific
15:56:06 <Tuplanolla> See the manual page for `fenv`, EvanR.
15:56:51 <EvanR> scientific cant do 1/3
15:57:13 <mtjmullen> converting to Floating Point at the boundaries doesn't make sense?
15:57:32 <mtjmullen> I think Scientific can do that for 1/3, but I may be misremembering
15:57:55 <EvanR> it just frozen my computer
15:58:29 <EvanR> verement: right, this is just a change of base...
15:59:07 <ClaudiusMaximus> scientific doesn't do math (1 + 1e1000000 will probably explode in a similar way, though both 1 and 1e10000000 are both reasonably-sized values in terms of RAM usage)
15:59:10 <EvanR> Tuplanolla: so FFI to modify the global floating point env?
15:59:20 <ClaudiusMaximus> scientific's numeric instances should be burninated
15:59:45 <mniip> huhhmm
15:59:55 <mniip> even staticptr's are failing me
16:00:00 <Tuplanolla> If you want decent performance and compatibility with other things, EvanR.
16:00:09 <mniip> though, this explains the issue
16:00:22 <mtjmullen> Alright, I misremembered
16:00:25 <mniip> StaticPtrInfo {spInfoUnitId = "hexchat-0.0.0.0-A6xmOqRFXRP6bnxjDUsAkl", spInfoModuleName = "HexChat.Internal.Internal", spInfoSrcLoc = (121,99)}
16:00:26 <mniip> versus
16:00:27 <mniip> StaticPtrInfo {spInfoUnitId = "main", spInfoModuleName = "HexChat.Internal.Internal", spInfoSrcLoc = (121,99)}
16:00:32 <Tuplanolla> Otherwise try the `cyclotomic` package.
16:00:36 <ClaudiusMaximus> does fenv and ghc's threaded runtime go well together?
16:00:40 * EvanR runs to that package
16:01:19 <EvanR> holy crap
16:02:08 <mtjmullen> cyclotomic looks neat
16:04:13 <EvanR> hmm so it can do trig, unless you do trig on a square root
16:07:51 <EvanR> > sqrt 2
16:07:53 <lambdabot>  1.4142135623730951
16:08:00 <EvanR> toReal $ sqrtRat 2
16:08:05 <EvanR> Just 1.414213562373095
16:08:07 <EvanR> interesting
16:09:45 <fakenullie> > toReal $ sqrt (-1)
16:09:47 <lambdabot>  error:
16:09:47 <lambdabot>      • Variable not in scope: toReal :: Double -> t
16:09:47 <lambdabot>      • Perhaps you meant one of these:
16:10:03 <EvanR> Nothing
16:10:39 <mniip> is it possible to obtain a package's UnitId at compile time?
16:14:16 <mniip> ....is nothing sacred?
16:14:28 <mniip> I'm observing two StaticPtr's with same Fingerprint in the same process
16:15:00 <Axman6> > showCReal 50 (sqrt 2)
16:15:02 <lambdabot>  "1.41421356237309504880168872420969807856967187537695"
16:15:43 <Tuplanolla> :t showCereal
16:15:44 <lambdabot> Int -> CReal -> String
16:16:34 <mniip> I could do with a workaround perhaps...
16:16:57 <Axman6> > showCReal 80 (sqrt 2)
16:16:59 <lambdabot>  "1.4142135623730950488016887242096980785696718753769480731766797379907324784...
16:20:27 <plakband> I have a function `cast :: Castable m => m a -> m b`. Why can I do `Proxy @Int`, but not `(cast Proxy) @Int`?
16:24:09 <Axman6> what is the initial type of proxy supposed to be?
16:24:32 <Axman6> also, what error do you get?
16:27:36 <plakband> Axman6: Cannot apply expression of type ‘Proxy b0’ to a visible type argument ‘Selected’
16:27:53 <plakband> s/Selected/Int
16:29:12 <plakband> In this case the type would just be Proxy a, but `(cast (Proxy :: Proxy Bool)) @Int` gives the same error
16:29:29 <plakband> `(cast Proxy :: Proxy a) @Int` works though
16:30:57 <Axman6> what about (cast (Proxy :: Proxy a)) @Int or (cast (Proxy :: Proxy Bool)) @Int?
16:32:14 <plakband> same error
16:33:23 <Axman6> You might need some @_'s
16:33:43 <Axman6> since what about using @_ @_ @Int (or only one)
16:35:52 <plakband> same error.. also, this works: `(Proxy) @Int` but not `(id Proxy) @Int`
16:39:11 <lyxia> I think it's by design
16:40:48 <Axman6> id @Int Proxy should work though
16:42:34 <plakband> Couldn't match expected type ‘Int’ with actual type ‘Proxy t0’
16:43:00 <plakband> :t id @Int Proxy
16:43:01 <lambdabot> error:
16:43:01 <lambdabot>     Pattern syntax in expression context: id@Int
16:43:01 <lambdabot>     Did you mean to enable TypeApplications?
16:43:13 <Axman6> right, because that would be saying a in id :: a -> a is Int, not Proxy Int
16:44:53 <mniip> % :t id @Int Proxy
16:44:53 <yahb> mniip: ; <interactive>:1:9: error:; * Couldn't match expected type `Int' with actual type `Proxy t0'; * In the second argument of `id', namely `Proxy'; In the expression: id @Int Proxy
16:45:53 <MarcelineVQ> "Visible type application is available to instantiate only user-specified type variables. This means that in data Proxy a = Proxy, the unmentioned kind variable used in a‘s kind is not available for visible type application."
16:46:08 <lyxia> The inferred type of  id Proxy  is of type  Proxy b0, not  forall b. Proxy b  so the type application is not allowed
16:46:37 <plakband> I see
16:46:47 <plakband> Is there a definition for id that would work?
16:47:29 <lyxia> id :: (forall b. Proxy b) -> forall b. Proxy b
16:48:02 <lyxia> Just write id (Proxy @Int) though
16:52:29 <plakband> lyxia: that works for `id`, but not for `cast`
16:52:55 <plakband> but tyvm, it works with the foralls written out like that
16:54:55 <lyxia> plakband: you can change the application order of type variables for cast with an explicit forall  cast :: forall a b m. ...
17:01:46 <plakband> I ended up doing class Cast m where cast :: m a -> forall b. m b
17:02:32 <mniip> that's the same as just saying 'm a -> m b'
17:02:37 <mniip> for which there's a typeclass already
17:04:37 <mniip> hmm
17:04:38 <mniip> this is new
17:04:56 <plakband> mniip: That gives the original error
17:05:07 <mniip>   <no location info>: /usr/bin/ld.gold: error: cannot find -lghc_16   <no location info>: collect2: error: ld returned 1 exit status      `gcc' failed in phase `Linker'. (Exit code: 1)
17:08:23 <jchia> ghc warning options question: There's -W___ to turn on a specific warning and -w to turn off all warnings. Is there an option to turn off a specific warning? I can't find anything in the doc. https://downloads.haskell.org/~ghc/8.2.1/docs/html/users_guide/using-warnings.html
17:09:04 <mniip> jchia, -Wno-
17:09:24 <jchia> OK, thanks
17:11:45 <jchia> I wish -Wname-shadowing has a variant where the warning shows up only if the type matches.
17:15:07 <Tuplanolla> It's more convenient to consult `ghc --show-options | grep fun` than the manual, jchia.
17:43:33 <amadhavan1> Anybody using brittany as code formatter in emacs to format their haskell code ?
17:48:23 <jchia> Tuplanolla: OK. I tried --help but missed the reference to --show-options at the bottom.
18:11:02 <hauzer> What's the recommended way of creating, parsing and modifying complex binary structures? I'm a Haskell newbie and I'd like to get into it by writing a simple PE parser.
18:13:30 <Gurkenglas> Is andM exactly "return . and . map unsafePerformIO"?
18:13:48 <Gurkenglas> (When specialized to IO, that is)
18:14:26 <lyxia> not at all
18:14:42 <lyxia> return doesn't evaluate
18:14:43 <mniip> that sounds like a recipe for disaster
18:15:52 <lyxia> and if you make return strict, exceptions would be raised when evaluating the IO action, not when executing it
18:16:43 <Gurkenglas> "evaluate . and . map unsafePerformIO", then?
18:17:18 <mniip> again no
18:18:01 <Gurkenglas> What input [IO Bool] does it behave differently on?
18:19:33 <mniip> :t foldr (\x y -> x >>= bool (return False) y) (return True)
18:19:34 <lambdabot> (Monad m, Foldable t) => t (m Bool) -> m Bool
18:19:35 <mniip> something like this
18:20:51 <Gurkenglas> That's not an [IO Bool] that tells "andM" from "evaluate . and . map unsafePerformIO", your answer doesn't have the right type
18:23:13 <mniip> it does thought
18:23:37 <Gurkenglas> "t (m Bool) -> m Bool" does not unify with "[IO Bool]"
18:23:51 <mniip> ...
18:24:13 <mniip> ok, take [print "" >> return True, print "" >> return True]
18:24:17 <mniip> and add list fusion
18:24:19 <mniip> and CSE
18:25:19 <Axman6> hauzer: attoparsec may be a good place to start
18:27:24 <Axman6> hauzer: representing the structures is usually quite natural in Haskell. What's PE?
18:30:57 <hauzer> Axman6: PE stands for Portable Executable. I'll look into attoparsec.
18:33:02 <Gurkenglas> Indeed, "" is only printed once. Interesting.
18:46:56 <_cyril_> hauzer: additionally, I think you might want to have a look at the cereal and binary packages
18:47:24 <pfurla> RUnning doctest, can't somehow make it show which tests are being ran?
18:54:06 <spikey> Hey can anyone help me install hsdev through cabal? I am getting many errors that there are files missing and when I try to install those modules, it says its already installed?
18:54:12 <spikey> I'm on Arch also.
18:54:33 <geekosaur> and all the missing files end in .a ?
18:55:38 <spikey> No the first one missing is Control.Monad.STM in the stm package
18:57:17 <spikey> All of the missing files have "Control.*" at the beginning of them though
18:57:19 <glguy> spikey: When you're asking for help online, put the actual error messages on a pastebin as you're asking for help initially
18:57:37 <glguy> don't make people drag information piecewise from you in paraphrased form
18:58:20 <spikey> Oh sorry! Ill get the pastebin
19:00:01 <spikey> https://pastebin.com/80L3QhAS
19:34:06 <crucify_me> hi in a guard structure if you have   | m <= 0, n <= 0 = 0   , the comma too close to the 0 causes a hang (infinite loop?) why is that?   
19:34:40 <crucify_me> so a space fixes it, but in list comprehensions I don't think that's essential
19:36:16 <mniip> what
19:36:16 <crucify_me> scratch that. very strange now it works without an added space
19:36:25 <mniip> that makes no sense
19:36:41 <geekosaur> sounds wrong to me too
19:39:24 <crucify_me> https://ptpb.pw/hm_6    I was having problems with the comma following the zero, now it works . strange thanks for checking in
19:48:17 <sean-hulse> exit
19:51:22 <sean-hulse> Hey
20:03:24 <_sras_> In Digestive functors library How can I convert  a `Formlet Text m Day` to `Formlet [Text] m Day`. I need this becasue the built in function `dateFormlet` returns a value of type `Formlet Text m Day` instead of `Formlet v m Day` like other functions that return formlets such as `text` and `string`.
20:04:13 <RedMachine> Hi
20:19:37 <tabemann> I am surprised by how quick it took to get this IRC client from not compiling to actually being usable
20:20:19 <tabemann> (it's in Haskell of course)
20:23:30 * jcarpenter2 shamelessly self promotes this stackoverflow post https://stackoverflow.com/questions/47153651/catch-program-errors-in-happstack-request-handler
20:28:56 <_sras_> In Digestive functors library How can I convert  a `Formlet Text m Day` to `Formlet [Text] m Day`. I need this becasue the built in function `dateFormlet` returns a value of type `Formlet Text m Day` instead of `Formlet v m Day` like other functions that return formlets such as `text` and `string`.
20:39:32 <_sras_> How can I actually validate something using a Form in Digestive Functor library. Where is this `runForm` function defined?
20:41:57 <geekosaur> in the adapter module
20:42:36 <geekosaur> digestive-functors-{happstack,snap,scotty,...} (and Spock-digestive because it had to be Different)
21:59:36 <dminuoso> Maybe Im on the wrong track here. Is something along the lines of (Just (+3)) <*> [3] somehow possible?
22:00:45 <dmj`> dminuoso: what would be the expected result
22:01:03 <dminuoso> [6] I guess...
22:01:47 <geekosaur> I'm trying to figure out why the Just is there...
22:02:03 <geekosaur> i.e. what exactly are you trying to accomplish?
22:03:39 <dmj`> > forM (Just (+3)) $ \f -> pure f <*> [3]
22:03:41 <lambdabot>  [Just 6]
22:04:21 <dmj`> > [ x | Just x <- forM (Just (+3)) $ \f -> pure f <*> [3] ]
22:04:22 <geekosaur> if the Maybe goes away completely then there is no generic answer, only one directly involving Maybe
22:04:24 <lambdabot>  [6]
22:12:05 <dmj`> > maybeToList (Just (+3)) <*> [3]
22:12:07 <lambdabot>  [6]
22:23:11 <hphuoc25_> Hello. I was playing with async and persistent and wanted to see how they work so I wrote this http://lpaste.net/359844. It's built and run with -threaded and +RTS. It's consuming a lot of memory (10+gb RAM) since mappool's creating all threads at the same time and then wait.
22:24:36 <hphuoc25_> What I wanted is to have 50 threads at any time and waiting jobs should start as soon as a connection becomes available in the pool.
22:24:45 <hphuoc25_> How can I do this with async?
22:35:27 <Axman6> you may need to write a new version of mamConcurrently which accepts a semiphore and calls wait before calling the async function to fork a new thread (Can't remember what it's called)
22:35:31 <cocreature> hphuoc25_: the async-pool package probably does the right thing
22:35:48 <cocreature> Axman6: it’s called "async" :P
22:35:56 <Axman6> yeah I thought it may be :P
22:36:49 <Axman6> also that function would need to ensure that signal is calledafter the passed in function returns (and not sure what the right thing to do about exceptions is, should you always signal or only if there's no exceptions?)
22:38:14 <Axman6> async-pool definitely looks like the right answer though
22:39:25 <hphuoc25_> thanks for suggestion. I'll try it out.
22:40:28 <Axman6> it has mapConcurrently :: Traversable t => TaskGroup -> (a -> IO b) -> t a -> IO (t b)
22:41:22 <cocreature> hphuoc25_: but unless you are doing this for learning purposes, a batch insert in the style of https://hackage.haskell.org/package/postgresql-simple-0.5.3.0/docs/Database-PostgreSQL-Simple.html#v:executeMany will probably be significantly faster (don’t ask me how you can do this with persistent)
22:41:54 <Axman6> I believe persistant provides a function called insertMany
22:42:23 <Axman6> but IIRC for SQLite it's the same as making many inserts
22:43:04 <Axman6> uh, not sure where I thought that you might be using sqlite, since it's cleary postgres
22:43:06 <cocreature> judging by the imports, hphuoc25_ is using postgres and not sqlite :)
22:43:45 <cocreature> also do yourself the favour and don’t read the source code of "executeMany"
22:43:51 <hphuoc25_> yes I'm learning async so I want to simulate some tasks similar to js promise
22:44:18 <Axman6> hphuoc25_: have you read Simon Marlow's book?
22:45:10 <Axman6> http://chimera.labs.oreilly.com/books/1230000000929 whicvh can be read online for free.
22:46:46 <hphuoc25_> Yes I've heard of that
22:47:03 <Axman6> hmm, was that written before he released async? Lookms it basically takes you through the implementation of the async package
22:59:30 <hellothere> hello
23:00:39 <cocreature> there
23:31:47 <alfredo> hellothere guys
23:32:56 <alfredo> (actually, "everyone" is more gender neutral, I don't want to rub anybody the wrong way ;) )
23:42:42 <dminuoso> ertes: What you have said is really difficult to grasp. I mean I have implemented traverseX in a naive way. The thing is, I already know which functor you will be getting at (Const), but I'm not sure Im on the right track here: https://gist.github.com/dminuoso/2ba40edde324ad37b46f8118f6c35c5d
23:43:24 <dminuoso> But.. oh.. wait..
23:43:30 <dminuoso> No way.
