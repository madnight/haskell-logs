00:00:08 <pacak> I suspect it's not really alive. v0.1 with 112 downloads...
00:01:55 <fragamus> cocreature  its ./global-project/stack.yaml right?
00:03:02 <cocreature> fragamus: if you want to install it globally then yes but usually you have a stack.yaml in each project you’re working on and edit that
00:03:42 <fragamus> yah i just want it in ghci for now and i dont mind it affecting everything
00:03:55 <cocreature> alright then ~/.stack/global-project/stack.yaml is correct
00:58:19 <utdemir> Hey. I found some 10 line (incorrect) haskell module that makes ghc go into an infinite loop. I want to make a bug report, however the code requires Servant. I failed to create a reproducible example without it. Do you think should I report to GHC's issue tracker or Servant's? 
00:59:14 <Yotam_> Can you give a link to the code?
01:01:06 <utdemir> Yotam_: https://gist.github.com/utdemir/92d8c4bc3725d52dc01738ab9e4b4bab
01:17:42 <Yotam_> utdemir: I tried it in stack and it just fails on the import line, saying it can't load the interface
01:17:59 <jcarpenter2> is there any way to get a source code line number out of SomeException?
01:18:42 <utdemir> Yotam_: Do you mean it can not find Servant?
01:19:12 <Yotam_> It finds it as I can import Servant.API from ghci
01:20:06 <utdemir> Yotam_: Maybe we have different Servant versions (I have servant-0.11). Maybe you can import "Servant.Server"?
01:20:45 <jcarpenter2> (without writing 'assert' statement on every source code line)
01:24:13 <MarcelineVQ> utdemir: hmm, Servant isn't the name of a module in servant-0.11
01:25:04 <MarcelineVQ> it doesn't ever seem to have been one, your code as written is a little suspicious :X
01:27:04 <MarcelineVQ> ah haha okay, it's from servant-server silly me
01:28:01 <utdemir> MarcelineVQ: Yotam_: Oh, sorry, I think it comes with servant-server: https://github.com/haskell-servant/servant/blob/master/servant-server/src/Servant.hs
01:29:28 <Yotam_> utdemir: always check your cabal file
01:30:36 <MarcelineVQ> how do you make this never terminate, what is the step to 'run' server
01:31:02 <MarcelineVQ> sidenote, should a server terminate on its own?
01:31:33 <MarcelineVQ> or is loading the code what never finishes?
01:31:46 <utdemir> MarcelineVQ: When you compile it with GHC 8.0.2, compilation never finishes. Or GHCi.
01:32:13 <utdemir> I checked and it does terminate on GHC 8.2.1. So it may not even worth a bug report.
01:33:01 <MarcelineVQ> interesting, if you did end up making a report I'd do it to servant before ghc in this case
01:34:28 <utdemir> MarcelineVQ: Thank you. I will.
01:36:06 <Unhammer> Hi, with stack, how would I depend on a local checkout of https://github.com/haskell-gi/haskell-gi , which in turn defines a bunch of packages (in particular, gi-gdkpixbuf)? I tried http://sprunge.us/giWF where I bump the gi-gdkpixbuf version to ensure I have the local copy, but stack doesn't seem to find it, just says "Didn't see gi-gdkpixbuf-2.0.15 in your package indices"
01:36:57 <Unhammer> (bumped the gi-gdkpixbuf version in ./haskell-gi/bindings/GdkPixbuf/pkg.info)
01:38:35 <MarcelineVQ> idk about your setup exactly but it sounds like you want subdirs, in particular subdirs of your haskell-gi checkout  https://docs.haskellstack.org/en/stable/yaml_configuration/#complex-package-locations-location
01:41:45 <Unhammer> aha
01:41:54 <utdemir> jcarpenter2: I don't think you can do that. But you can probably get hold of a `CallStack` there and extract a `SrcLoc` from it if you control the place exception is thrown: https://hackage.haskell.org/package/base-4.9.0.0/docs/GHC-Stack.html#t:CallStack
01:42:40 <jcarpenter2> ah yes, I ran currentCallStack from inside the exception handler, but it had length 0...
01:44:36 <utdemir> jcarpenter2: Docs says `The implementation uses the call-stack simulation maintined by the profiler, so it only works if the program was compiled with -prof and contains suitable SCC annotations (e.g. by using -fprof-auto). Otherwise, the list returned is likely to be empty or uninformative.`. I guess you need to use `HasCallStack` and pass the stack via the implicit parameters to get it without `-prof`.
01:53:30 <jcarpenter2> well, 'callStack' didn't work either, it was an empty list
01:53:42 <jcarpenter2> compiling with -prof and -fprof-auto to see if that helps
01:54:00 <jcarpenter2> or rather, "stack build --executable-profiling"
01:54:10 <jcarpenter2> since stack wants me to use that instead of -prof
01:54:20 <jcarpenter2> alright stack, whatever you say
01:54:24 <jcarpenter2> :V
01:55:38 <jcarpenter2> also: feel free to answer this question https://stackoverflow.com/questions/47119100/hslogger-disable-output-to-console
01:19:39 <Unhammer> so. subdirs doesn't seem like enough - haskell-gi doesn't actually have a .cabal for gdkpixbuf, but has this cabal.project that mentions it
01:21:44 <MarcelineVQ> that cabal.project would tell you where the gdkpixbuf cabal file is
01:22:46 <MarcelineVQ> weird that it's not there :(
01:23:11 <MarcelineVQ> not quite sure how that works
01:33:52 <portnov> hi all
02:18:45 <verlet64> Hello
02:20:54 <bobismijnnaam> Hello everyone
02:23:54 <bobismijnnaam> Design question: I'm at the stage of developing my compiler that I know have a typechecked AST of a c-like language. Now I need to output x64 assembly. Are there any sources on how to structure assembly code generation in haskell? I tried googling but all I can find are sources talking about getting ghc to output x64 code; nothing about patterns for x64 code generation
02:28:14 <bobismijnnaam> Or maybe there are open source projects that do this well and I can take a peek at?
02:39:58 <cocreature> bobismijnnaam: do you want to implement the actual code generation yourself or is using LLVM an option?
02:46:17 <bobismijnnaam> Its for educational purposes, so I'd rather not use llvm. I mostly finished the c backend, and now I'd like to progress to a backend that's not as straightforward
02:47:06 <cocreature> I only know of tutorials for LLVM, sry
02:47:51 <verlet64> Question: trying to get up to speed with mtl and the general idea of abstracting effects using typeclasses
02:47:55 <verlet64> http://lpaste.net/3366694085875204096
02:47:57 <cocreature> although if you do it yourself it probably still makes sense to first translate to some IR that’s somewhat close to LLVM and then implement the code generation from that
02:47:58 <verlet64> How off base am I
02:48:02 <verlet64> and how do I get on base
02:49:08 <bobismijnnaam> @cocreature i'm compiling a *very* simple c-like language, so it's actually very similar to llvm at this stage
02:49:08 <lambdabot> Unknown command, try @list
02:50:02 <cocreature> bobismijnnaam: your language probably doesn’t force users to write their code in SSA form :)
02:52:56 <bobismijnnaam> cocreature: definitely not! But its translation to x64 is awkwardly straightforward tho
03:07:08 <masaeedu[m]> > No instance for (Show (IO b0)) arising from a use of `print'
03:07:10 <lambdabot>  <hint>:1:4: error: parse error on input ‘instance’
03:07:12 <masaeedu[m]> Can't quite figure this out
03:07:53 * masaeedu[m] sent a long message: masaeedu[m]_2017-11-05_11:07:30.txt <https://matrix.org/_matrix/media/v1/download/matrix.org/ZEVgIfscEKQmeYqilfoNEexc>
03:08:16 * masaeedu[m] sent a long message: masaeedu[m]_2017-11-05_11:07:53.txt <https://matrix.org/_matrix/media/v1/download/matrix.org/XUHggqNIEeuYBIDfXUlazaDh>
03:08:48 * masaeedu[m] sent a long message: masaeedu[m]_2017-11-05_11:08:25.txt <https://matrix.org/_matrix/media/v1/download/matrix.org/TaVgmEyRhmSayTUluuZVvgUy>
03:09:36 * masaeedu[m] sent a long message: masaeedu[m]_2017-11-05_11:09:12.txt <https://matrix.org/_matrix/media/v1/download/matrix.org/HLZurumBBLPunXiDRftjPbFp>
03:10:06 <cocreature> masaeedu[m]: what do you mean by “perform” here?
03:10:15 <cocreature> how do you perform a polymorphic IO action
03:10:34 <masaeedu[m]> When you do `putStrLn "foo" >> putStrLn "bar"`
03:10:40 * masaeedu[m] sent a long message: masaeedu[m]_2017-11-05_11:10:17.txt <https://matrix.org/_matrix/media/v1/download/matrix.org/ayvamwPlnoGRWxNEeAAoehhI>
03:10:44 <cocreature> if you specify a type annotation it works
03:10:57 <masaeedu[m]> What do I annotate it as?
03:11:22 <cocreature> depends on what you want, "x <> y :: IO (Sum Int)" would be one option
03:18:54 <masaeedu[m]> Thanks
03:36:54 <verlet64> How can I reconcile something like MonadError with multiple exception types? Like if I have an IO instance, that is going to throw an IOException, 
03:55:20 <codeshot> I've got a funtion exceptToIO :: Except String (IO ()) -> IO (IO ()) which returns either the IO action that has been successfully defined or an IO action that explains the failure
03:56:03 <codeshot> Trying to use it with hoist I have a problem that hoist is free over all mT a and I can't constrain it to mT (IO a)
03:56:20 <codeshot> How do other people solve this?
03:56:47 <codeshot> and then why can't I constrain it?
03:57:03 <mniip> given opaquity of IO, is there really any difference between your type and Except String (IO ()) -> IO ()   ?
03:57:53 <cocreature> mniip: sure there is, IO (IO ()) gives you a choice when to execute the inner IO action
03:58:01 <mniip> yeah I know
03:58:09 <codeshot> I intend to have this choice
03:58:12 <mniip> but do you need the outer IO executed at that moment
03:58:34 <mniip> codeshot, ok what are you hoisting this into
03:58:53 <codeshot> And I don't have an Except String (IO a), I have a StateT s (Except String) (IO a) so hoist seems like the correctly descriptive function
04:00:03 <codeshot> I'm refactoring to move the "IO" out of my core code
04:01:06 <codeshot> mniip, so  StateT s (Except String) (IO a) -> StateT s IO a
04:01:15 <mniip> that's different
04:01:22 <codeshot> mniip, so  StateT s (Except String) (IO a) -> StateT s IO (IO a)
04:01:22 <mniip> there's only one layer of IO now
04:01:27 <mniip> no you can't do that
04:01:50 <codeshot> the second one, my first was a typo
04:02:08 <mniip> right, the second type you can't do with hoist
04:02:40 <codeshot> in my next few minutes I will lift the result to apply it immediately but in the minutes after that I will move the IO out so the same core code can work on two different monads
04:02:53 <codeshot> hoist exceptToIO >>= lift
04:03:47 <codeshot> that's my next step to see that I still have the same behaviour now that I've replaced IO's "fail" with a proper Except throwE
04:05:34 <codeshot> Am I going about this the wrong way ? It feels very right
04:05:50 <codeshot> or is hoist unnecessarily refusing to partially specialise
04:06:43 <codeshot> (IO a) would seem to match hoist's qualifier forall a in (forall a. m a -> n a) -> t m b -> t n b
04:06:59 <codeshot> exceptToIO Meets that qualifier's restriction
04:07:30 <codeshot> (IO ()) matches it, even
04:07:48 <codeshot> because (IO ()) is definitely an 'a'
04:08:26 <mniip> no
04:09:03 <mniip> that 'a' is a rigit type variable
04:09:08 <mniip> rigid
04:09:51 <codeshot> is that because forall a is inside the parentheses instead of outside?
04:09:54 <mniip> yes
04:10:05 <codeshot> Meaning the argument must support being applied to any type
04:10:22 <mniip> see, when you write f :: forall a. a -> a, that means the caller can put any type for a
04:10:52 <mniip> when you write g :: (forall a. a -> a) -> X, that means you must provide a function, whose caller (i.e g) can substitute any type for a
04:11:11 <codeshot> Is the type of hoist correct? ie, shouldn't it allow to be used when you want to do (m a -> n a) -> t m a -> t n a?
04:11:16 <mniip> no
04:11:37 <codeshot> It's looking like an important thing to want to do
04:11:49 <mniip> that's not how monad transformers work
04:12:10 <mniip> suppose
04:12:11 <codeshot> how would you transform from Except String to IO?
04:12:19 <mniip> fmap (+1) :: Maybe a -> Maybe a
04:13:05 <mniip> hoist (fmap (+1)) :: MaybeT Maybe a -> MaybeT Maybe a     = ?
04:13:17 <codeshot> I need to create a value for the Except's failure case: runExcept :: Except e a -> Either e a
04:15:02 <codeshot> why couldn't hoist from your example forward the type of (+1) to be hoist (fmap (+1)) :: Num a => MaybeT Maybe (Num a) -> MaybeT Maybe (Num a) ?
04:15:22 <mniip> how would it "forward" the implementation
04:15:41 <mniip> ok, let's try something else
04:15:49 <codeshot> Isn't it clear I don't know enough about this to answer your questions?
04:16:07 <mniip> well I'm just trying to show the impossibility of what you're suggesting
04:16:10 <mniip> remember:
04:16:16 <mniip> MaybeT m a = m (Maybe a)
04:16:21 <mniip> not Maybe (m a)
04:16:35 <codeshot> If I can't imagine the implementation in immediate demand it doesn't show me that it's impossible
04:16:45 <codeshot> Only that I'm inexpert
04:17:03 <mniip> well in haskell implementations are usually either dead simple or impossible
04:17:12 <codeshot> That has not been my experience
04:17:21 <mniip> @unmtl StateT s (Except String) (IO a) -> StateT s IO (IO a)
04:17:21 <lambdabot> StateT s (Except String) (IO a) -> StateT s IO (IO a)
04:17:25 <mniip> dammit
04:17:33 <mniip> @unmtl StateT s (Except String) (IO a)
04:17:33 <lambdabot> s -> Except String (IO a, s)
04:20:42 <mniip> codeshot, okay here's your problem:
04:20:49 <mniip> @unmtl StateT s (ErrorT String Identity) (IO a)
04:20:49 <lambdabot> s -> Either String (IO a, s)
04:20:50 <mniip> @unmtl StateT s IO (IO a)
04:20:50 <lambdabot> s -> IO (IO a, s)
04:21:11 <mniip> if your argument returns a (Left e) indicating error
04:21:17 <mniip> where will you get the 's' from?
04:21:46 <mniip> from the input state?
04:21:49 <codeshot> I thought hoist would do that
04:22:00 <mniip> hoist would do what
04:22:02 <mniip> it's not magic
04:22:17 <mniip> it can't bring values into existence out of nowhere
04:22:40 <mniip> hoist for StateT is dead simple:
04:22:58 <mniip> hoist f (StateT g) = StateT (\s -> f (g s))
04:23:09 <codeshot> You're confusing me a lot
04:24:00 <mniip> which part
04:24:02 <codeshot> I can make lots of expressions without a value for state that are valid StateT s IO (IO a)
04:24:26 <codeshot> and I give them to runStateT e s <- and here they get their s
04:25:09 <mniip> in those expressions you reuse the s that you're given
04:25:24 <codeshot> I want to do that here
04:25:39 <codeshot> doesn't hoist convert anything to (StateT s) ?
04:25:45 <mniip> then you can't do it over an arbitrary monad stack
04:25:47 <codeshot> because 's' is unknown ??
04:25:58 <mniip> you'll have to deal with StateT specifically
04:26:02 <codeshot> oh
04:26:32 <codeshot> I thought I only had to deal with Except specifically
04:28:45 <codeshot> I can't see how the type of hoist allows me to do that
04:29:42 <codeshot> the function I give it is required to be forall a :: m a -> n a where neither of m nor n are StateT s o
04:30:13 <codeshot> I only have m = Except String, n = IO, and a = IO ()
04:30:59 <codeshot> Since I have to create a value in case of Except's failure condition a cannot be free
04:31:15 <codeshot> Does that mean hoist cannot hoist Except?
04:33:08 <codeshot> or that it can't hoist to StateT s ?
04:34:36 <codeshot> Is there some documentation on Monad Transformers that explain how to convert from t m a to t n a ?
04:36:19 <codeshot> The current documentation makes it look like hoist works for this situation but clearly there are two situations and I can't see what works when a is and must be known
04:39:18 <codeshot> I need an equivalent for hoist where forall a. (m a -> n a) -> t m a -> t n a. For the first argument I don't care what outer monad it's in, I can use "return"/"pure" just fine if necessary but I would have thought hoist
04:40:06 <codeshot> hoist was given to me as the way to convert between transformer stacks so I'm confused what to do now
04:40:07 <mniip> codeshot, hoist can hoist both
04:40:09 <mniip> but you're using it wrong
04:40:31 <mniip> "I need an equivalent for hoist where forall a. (m a -> n a) -> t m a -> t n a" <- impossible
04:40:49 <codeshot> so my program is impossible?
04:40:58 <mniip> no I'm not saying that
04:41:13 <mniip> ok, can you write the de-transformer-ized function?
04:41:36 <codeshot> I've got a t m (IO ()) and I need a t n (IO ()), and I've got a (m (IO ()) -> n (IO ()))
04:41:39 <mniip> (s -> Either String (IO (), s)) -> s -> (IO (IO s), s)
04:41:52 <mniip> oops
04:41:55 <mniip> (s -> Either String (IO (), s)) -> s -> (IO (IO ()), s)
04:42:20 <mniip> no wait, wrong again
04:42:27 <mniip> (s -> Either String (IO (), s)) -> s -> IO (IO (), s)
04:43:13 <codeshot> I don't want to tie my function to StateT
04:43:26 <codeshot> :(
04:43:38 <mniip> if you want to be parameteric in the outer monad,
04:43:40 <mniip> i.e
04:43:41 <codeshot> I wanted to use it with any t
04:43:54 <codeshot> Which one's the outer?
04:44:06 <mniip> forall t. (MonadTrans t) => t Either (IO ()) -> t IO (IO ())
04:44:08 <codeshot> inner outer a or outer inner a ?
04:44:14 <mniip> then hoist is your only tool,
04:45:22 <mniip> considering the behavior of exceptToIO,
04:45:34 <mniip> and the fact that it's inexpressimble as a natural transformation
04:45:47 <mniip> I'm estimating that it's impossible to write your function in general
04:45:52 <codeshot> o.O
04:45:53 <mniip> but instead only specific to StateT
04:48:46 <codeshot> I've just wasted a lot of time using monad transformers
04:49:03 <mniip> you're trying to do untransformerly tasks
04:49:10 <codeshot> It doesn't seem like it
04:49:19 <mniip> not really it does
04:51:04 <codeshot> I've got some monadic expresssions that update state with the ability to fail, and some monadic expressions that have state and an ability to do IO, and I want to run the failable stuff with the state of the IO-able monad then when it's done and I've decided whether it fails or not I just want to create some IO and perhaps decide to lift it
04:51:21 <codeshot> so I wanted to convert the failable bit to IO-able
04:51:26 <codeshot> but not the state bit
04:51:40 <mniip> you realize that in your monad stack when you fail state is lost?
04:51:52 <codeshot> rly?
04:51:55 <mniip> yes
04:52:01 <mniip> the fail-able monad doesn't return state in case of  failure
04:52:27 <codeshot> is that the actual nub of the problem I'm having?
04:52:51 <codeshot> hang on, Except has a catchE doesn't it
04:52:55 <codeshot> do de-fail ?
04:52:56 <mniip> @unmtl StateT s (ErrorT String Identity) a
04:52:56 <lambdabot> s -> Either String (a, s)
04:53:21 <codeshot> so I can solve this with (hoist (trivial)) . (catch fixup)
04:53:39 <codeshot> moving the fixup out of exceptToIO leaving only the trivial bit
04:53:46 <codeshot> do I understand now?
04:54:01 <codeshot> or lift catch fixup
04:54:01 <mniip> look at catchE again
04:54:20 <mniip> :t catchE
04:54:21 <lambdabot> error:
04:54:21 <lambdabot>     • Variable not in scope: catchE
04:54:21 <lambdabot>     • Perhaps you meant one of these:
04:54:32 <mniip> :t Control.Monad.Trans.Except.catchE
04:54:33 <lambdabot> Monad m => ExceptT e m a -> (e -> ExceptT e' m a) -> ExceptT e' m a
04:55:17 <mniip> if your 'handler' function constrains 'a' then you can't plug this into hoist
04:56:47 <codeshot> It's looking to me that (t Except a -> t m a) can't be done
04:57:39 <codeshot> because getting a value out of except requires inventing a value for 'a' in case there's an Exception
04:57:54 <codeshot> Is there a name for this class of Monad ?
04:58:05 <codeshot> where it can't be hoisted ?
04:59:20 <codeshot> I think it needs to be clearer in the documentation
05:13:56 <portnov> http://hackage.haskell.org/package/heavy-logger
05:39:04 <ongy> what's the intended way to go from a FFI CString to Text? decodeUTF8 takes a ByteString
05:41:16 <codeshot> mniip, I've been looking at the code for StateT's hoist implementation
05:41:27 <cocreature> ongy: you can get a bytestring using packCString
05:41:52 <codeshot> It's becoming a little clearer although to support more than a few hundred haskell developers who have uncommon I think the documentation should be improved
05:42:57 <codeshot> a in my function needs to be (IO a, s)
05:43:14 <ongy> codeshot: thx
05:43:24 <ongy> I was looking at Foreign.C.String and didn't find anything useful
05:43:35 <codeshot> ongy, my comment was for an earlier conversation
05:43:38 <cocreature> Foreign.C.String is in base and bytestring is not in base
05:44:08 <cocreature> ongy: if you’re worried about a performance you might also want to take a look at unsafePackCString or even better unsafePackCStringLen
05:44:24 <cocreature> the latter being O(1) so if you know the length it’s really cheap
05:45:53 <ongy> cocreature: I know a maximum length, but not the real one
05:46:20 <ongy> at least for the current case, but I think I'll need to use it a bit more either way
05:47:04 <cocreature> oh apparently there is also https://hackage.haskell.org/package/text-1.2.2.2/docs/Data-Text-Foreign.html#v:peekCStringLen
05:47:14 <cocreature> didn’t know about that one
05:48:19 <ongy> I've seen that, but I'd need the length. Though that should be simply strlen, so it should be cheap enough
05:49:08 <Xion_> I set -threaded and -with-rtsopts="-N2" in GHC-Options: in .cabal file but the program still panics at forkOS.
05:49:13 <Xion_> Any ideas what else should I do?
05:49:37 <cocreature> does unicode allow for null-bytes? otherwise I don’t see why it can’t figure out the length itself if it needs to do a linear traversal anyway
05:49:51 <cocreature> Xion_: panics?
05:50:41 <ongy> cocreature: unicode isn't an encoding. utf8 doesn't, utf16 does. But the comment says it's utf8, so not sure why they don't have a CString version next to the CStringLen
05:51:01 <cocreature> ongy: make a PR :)
05:51:01 <Xion_> cocreature: "user error (RTS doesn't support multiple OS threads (use ghc -threaded when linking))"
05:51:14 <cocreature> Xion_: can you show us your cabal file?
05:51:38 <Xion_> cocreature: https://hastebin.com/otafegivor.scala
05:51:53 <cocreature> Xion_: all of it
05:52:10 <Xion_> https://hastebin.com/zaratimepu.http
05:52:13 <mniip> 1509886594 [15:56:34] 18<codeshot> It's looking to me that (t Except a -> t m a) can't be done
05:52:26 <Xion_> Rest is pretty standard I think
05:52:29 <mniip> hoist (either (const Nothing) Just)
05:52:55 <cocreature> Xion_: hm looks fine, I was just making sure you haven’t specified it on a lib instead of on an executable. maybe try cleaning to force a rebuild?
05:53:20 <Xion_> Good idea :)
05:56:47 <codeshot> let {fn :: M N A -> M N A = \doo -> do {do do do doo}; fn2 :: M N A -> M N A = \doo -> do {do doo}; fn3 :: M N A -> M N A = \doo -> do {do do do do do do do do do do do do do do do doo};}
05:57:33 <Xion_> cocreature: stack clean seems to do the trick, heh
05:57:42 <Xion_> Thanks!
05:58:11 <codeshot> This is my new state of mind
05:58:26 <codeshot> 100 years ago they would have said that haskell had driven me insane
05:59:23 <hpc> they would still say it today, but they would have said it 100 years ago too ;)
06:00:06 <codeshot> https://www.youtube.com/watch?v=RFkYhBs5eNc
06:03:35 <codeshot> A muppet show sketch about a conversation on #haskell﻿
06:04:24 <Fuuzetsu> M N A M N A
06:05:58 <codeshot> doo doo do do do
06:11:27 <portnov> beethoven's fifth?
06:15:00 <codeshot> portnov, check the muppet show video. This is what learning haskell is like
06:15:13 <codeshot> see the url above
06:15:46 <codeshot> the pink ones are the people that know how to use haskell, the ginger haird one is me
06:15:53 <codeshot> *haired
06:16:26 <codeshot> it starts of well, and I can join in the song but soon a fell maths falls upon me
06:16:44 <codeshot> my fingers are darkened
06:17:12 <codeshot> and an undefined evil overcomes my mind
06:17:58 <codeshot> At the end I get a job at the same place as the haskell experts so I can call their extension directly ;)
06:41:31 <sm> codeshot: I think you might be on to something here..
06:42:27 <sm> singing muppets monad tutorial, anyone ?
06:43:28 <portnov> sm: «— the question is: what is a monad? — The question is: who cares?»
06:45:20 <sm> ha
06:47:33 <sm> monadmonad.. doo doo do do do..
06:50:46 <[exa]> oh no get the monad song out of my head
06:54:01 * sm can't decide if brown guy or pink ones are the monad/FP evangelist
07:27:28 <arianvp2> > 2%5 - (2%10 + (8%10 * 17%64))
07:27:30 <lambdabot>  error:
07:27:30 <lambdabot>      • No instance for (Integral (Ratio Integer))
07:27:31 <lambdabot>          arising from a use of ‘e_1252108101764’
07:27:34 <arianvp2> > 2%5 - (2%10 + (8%10 * 17%64))
07:27:36 <arianvp2> which is this a type error
07:27:36 <lambdabot>  error:
07:27:36 <lambdabot>      • No instance for (Integral (Ratio Integer))
07:27:36 <lambdabot>          arising from a use of ‘e_1252108101764’
07:27:38 <arianvp2> All terms are Ratio
07:28:17 <arianvp2> ah parentheses, nvm
07:45:18 <fabien> Hi everyone , if i want to create a list , append to it things inside a function and after returned it , am i forced to create this list before and send it to my function as parameter ? or can i create it "on the fly" inside the function (this function is recursive ofc)
07:54:20 <fabien_> no one ?
07:55:15 <Rembane> fabien_: You can create it on the fly. 
07:56:13 <Rembane> fabien_: Like this for instance:  f i = i : f (i-1); f 0 = []
07:57:02 <fabien_> this create a new one
07:57:04 <fabien_> oh ok
07:58:21 <fabien_> I'm using Set for a little project , and i don't understand how to go through it like (hd:tl) for list
07:58:52 <fabien_> like a function take a list on parameter i can just put (hd:tl) as parameter and use it like i want , how can i do that with Set ?
08:02:12 <jle`> what would you want to do that for?
08:02:22 <jle`> are you trying to iterate over every item in a set?
08:02:46 <jle`> if so, you can use toList first
08:02:58 <jle`> it depends on what you really want to do
08:06:03 <inkbottle> > [2,1..3]
08:06:05 <lambdabot>  []
08:06:40 <inkbottle> Probably syntax error, strange result though?
08:06:48 <fabien_> its what im doing
08:06:56 <fabien_> i was thinking its quite dirty no ? aha
08:14:39 <lyxia> > [2,1 .. -3]
08:14:41 <lambdabot>  [2,1,0,-1,-2,-3]
08:15:09 <lyxia> inkbottle: that's no syntax error.
08:15:49 <inkbottle> lyxia: OK, I think I understand
08:16:08 <inkbottle> yes, of course
08:16:22 <inkbottle> thanks
09:01:37 <KermityFreg> Seems like a nice language.
09:04:57 <KermityFreg> >++++++++++ [>+++++++++++>+++++++++++>++++++++++>++++++++++>++++++++++>+++++++++++>++++++++++++><<<<<<<<-] >>----->+++>+++>+>++++>-----> <<<<<<<< >.>.>.>.>.>.>.
09:09:25 <Welkin> that frog has issues
09:11:51 <Ferdirand> yes, this implementation is clearly sub-optimal
09:12:02 <hpc> frogs make the best programmers
09:12:05 <hpc> they eat bugs for breakfast
09:29:40 <dyreshark> i find they hop to conclusions maybe too quickly, though
10:01:52 <dminuoso> What exactly is the purpose of Data.Functor.Identity?
10:02:59 <[exa]> dminuoso: State x = StateT x Identity, not much more in fact
10:03:14 <mud> dminuoso: It's so you can write code that's generic over a Functor in some way, and if the user of your code doesn't actually need a Functor, just a single value, that's what Identity is. A Functor that adds nothing.
10:03:23 <dminuoso> mud: Ah.
10:09:33 <ertes> say i have an unsafely created top-level IORef with unconstrained polymorphism, (ref :: IORef (Maybe a)), and i mark it as NOINLINE, will it be shared among users, even if they pick different instantiations?
10:10:16 <ertes> (it will never be written to, and it will always hold Nothing)
10:11:28 <ertes> dminuoso: example: a lens is a function of type:  myLens :: (Functor f) => (a -> f b) -> s -> f t
10:11:45 <ertes> dminuoso: if you pick f = Identity, it will act as a setter, effectively becoming:  (a -> b) -> s -> t
10:12:02 <dminuoso> ertes: Heh, Im precisely trying to understand lenses (or rather how they are constructed)
10:12:07 <dminuoso> Using them seems rather intuitive OTOH.
10:12:28 <ertes> dminuoso: do you understand how 'traverse' works?
10:14:05 <dminuoso> ertes: Not exactly
10:15:08 <ertes> @let data V3 a = V3 !a !a !a  deriving (Eq, Foldable, Ord, Show)
10:15:10 <lambdabot>  Defined.
10:15:20 <ertes> dminuoso: exercise: write a Functor and a Traversable instance for V3
10:15:52 <ertes> without deriving them ;)
10:17:23 <Welkin> traverse is mapM for applicative
10:22:20 <dsal> I'm using attoparsec on Text.   How do I take 4 of a particular character?  My input has two sets of four characters from a specific set.  take doesn't seem to distinguish, and all of the "in class" kinds of things seem to want to keep going.   e.g. I have 12345678 and want to parse  1234 and then 5678
10:22:31 <dsal> I can just take 4 and then verify them, I guess.
10:24:23 <amateur_hour> what's wrong with something like take 4 . filter predicate
10:24:55 <Tuplanolla> Use `replicate`, dsal?
10:25:11 <dsal> I need the parser to fail if the next four digits aren't part of a particular set of data.
10:25:27 <ertes> dashed: you can take and then use B.all
10:25:33 <ertes> *dsal
10:25:41 <dsal> Yeah, I think I'm doing something like that.
10:26:29 <Tuplanolla> :t replicateM 4 (Text.Parsec.oneOf ['0' .. '9'])
10:26:31 <lambdabot> Stream s m Char => ParsecT s u m [Char]
10:26:47 <ertes> dsal: although using replicateM_ with 'satisfy' could be faster, depending on how attoparsec is implemented, because using 'take' requires actually constructing the bytestring
10:28:58 <dsal> Hmm...  I'll see where that takes me.  That doesn't seem too bad.
10:41:05 <hjdskes> Hi! I need to learn Haskell (and rather quickly at that) for a new project and was wondering which book is best suited for this, between Haskell Programming from First Principles and Programming in Haskell. I am somewhat familiar with functional programming, have an academic background in computer science and a few years of programming experience. Can you tell me which of these two (or any other suggestion) is most suited?
10:42:09 <Tuplanolla> Sounds like you could go with LYH since you don't need hand holding, hjdskes.
10:42:39 <monochrom> I'll abbreviate the two books as HFFP and PIH.
10:43:07 <sternmull> i want to write a program that understands commandlines like "myprog mode1 foo --bar" and "myprog mode2 123 --bla blabla". Can you suggest a commandline-parsing packages that makes this easy?
10:43:08 <Tuplanolla> You mean HPFP.
10:43:27 <cocreature> sternmull: optparse-applicative
10:43:35 <monochrom> HFFP is large because it fills in what most people lack from academic CS. So it's probably too slow for you. PIH is faster.
10:43:54 <mud> LYAH skips more than just hand holding. It skips the entire part where it teaches you how to write code.
10:44:12 <ertes> hjdskes: perhaps a more tutorial-style format would suit you
10:44:23 <monochrom> I wonder if LYAH is too short and missing something you actually need though.
10:44:30 <ertes> hjdskes: https://www.seas.upenn.edu/~cis194/
10:45:20 <ertes> hjdskes: i believe this is the quickest intro to haskell where you learn for the most part by doing exercises
10:45:30 <monochrom> Anyway I'm skeptic of quick learning altogether.
10:45:35 <mud> I still don't even see a problem with HPFP. If some parts are easy, then just go quickly through them and make sure you're doing the exercises to check.
10:45:38 <mud> Yeah, also that ^
10:46:06 <ertes> i don't think there is anything wrong with quick learning, as long as it's still comprehensive…  also it's not so much "quick" as it is "at your own pace"
10:46:08 <monochrom> (Says him who learned Scheme in one night from one of the standard tutorial or was it the standard document?)
10:46:15 <mud> Trying to learn something quick mostly means you get frustrated and it's at least as slow as if you had taken your time.
10:46:17 <sternmull> cocreature: Thank you. Its "commands" look like the thing i need.
10:46:18 <ertes> while something like HPFFP is unconditionally slow
10:46:36 <monochrom> Anyway I learned Haskell from The Gentle Introduction. But not fast, Haskell was different and difficult.
10:46:57 <ertes> i learned haskell from "a haskell road to logic"
10:47:14 <monochrom> If you aren't born with lazy evaluation then Haskell cannot be learned fast, period.
10:47:33 <fakenullie> hjdskes: the Haskell Book, just skip chapters that feel obvious (and return when you find out they weren't)
10:47:37 <hjdskes> monochrom: "rather quickly" may be wrongly worded; I meant it to mean that I'd like to skip some of the absolute basics
10:47:43 <Welkin> give it at least 3 months
10:47:50 <ertes> hjdskes: don't do that
10:48:04 <Tuplanolla> Install the compiler and start using it then, hjdskes? That's how it goes for most technologies.
10:48:07 <Welkin> possibly 6 months before you will feel comfortable writing programs
10:48:08 <ertes> hjdskes: unless you're already familiar with a lazily evaluated language with a haskell-like type system
10:48:22 <sternmull> my primary source for learning haskell was the wikibook. I also used "learn you a haskell" but that is bit too much talking for my taste.
10:49:06 <monochrom> Mind you I already had Lisp Perl SML under my belt before I learned Haskell. And it was still not fast.
10:49:27 <monochrom> So yeah basically lazy evaluation and IO.
10:49:35 <Welkin> a lot of it has to do with learning the compiler extensions, the libraries, and the programming style
10:49:52 <dsal> I've got a couple bits of attoparsec doing     <|> A.string ""    -- is this the right way to say "might have one of these things?"
10:49:53 <Welkin> and the build system setup, packages, etc
10:50:15 <monochrom> The IO system is great but it's also non-obvious.
10:50:28 <Welkin> you can learn the absolute basics of haskell (the syntax, really) in an afternoon
10:50:34 <Welkin> but you won't be able to do anything with it
10:50:45 <monochrom> Oh and I already had an MSc in CS before I started.
10:51:16 <Welkin> it's about the journey, not the destination, though
10:51:31 <Welkin> you'll enjoy it as much as any of us
10:52:03 <ertes> a came to haskell from mainly C++ and PHP with no academic background…  i needed a few months before i could really do anything, but it may be different today with more modern learning resources available
10:52:04 <monochrom> Yes, the journey is more important than the destination.
10:52:15 <ertes> back then things like the gentle intro were pretty much the only options
10:52:21 <hjdskes> thanks guys, these suggestions are plenty food for thought, especially the discussion about "learning quickly" and the journey :)
10:52:21 <monochrom> Because you might not survive to the destination.
10:52:30 <monochrom> I should totally sell this idea to despair.com
10:53:42 <takitus> hjdskes: Also, check out Richard Bird's books. They're rigorous and worth every hour. :)
10:53:44 <monochrom> My trick for learning Haskell was I designated no destination. (My trick for learning pretty much anything actually.)
10:54:22 <monochrom> Or rather, you could say that I just begin by deciding how much time I want to spend, then just learn whatever can be learned in that time.
10:54:30 <ertes> also haskell is the kind of language where if you're somewhat into programming languages or CS, or you find haskell's approach fascinating (as i did), there is a strong tendency to procrastinate: learn all the things, but never use any
10:54:34 <Welkin> I started learning haskell with no intention of using it for anything other than "learning functional programming". Today I use to to write almost everything (mostly web apps)
10:54:53 <ertes> if you can keep yourself from procrastinating, haskell can actually be surprisingly fast to learn
10:55:13 <monochrom> None of those "At the end of this chapter you will have accomplished the following bullet point learning objectives" nonsense!
10:55:27 <Tuplanolla> Having just programmed Scheme and a handful of term rewriting systems for a while, I read LYH in pretty much one sitting. This was enough to easily coast through the university course on the subject, but writing useful things did not begin until a year later.
10:56:55 <Tuplanolla> Then again, I did particularly plan to adopt Haskell. It just happened when I found Scheme to be too distasteful to keep using it.
10:57:06 <ertes> for example there was a time when i was somewhat productive with haskell, and then i learned about FRP…  my productivity went downhill immediately and only recovered when i implemented my own FRP framework =)
10:57:13 <Welkin> Tuplanolla: no Racket?
10:57:13 <Tuplanolla> (Replace "did" with "did not" there.)
10:57:29 <Welkin> ertes: netwire?
10:57:33 <ertes> Welkin: yeah
10:57:40 <Tuplanolla> It was mostly CHICKEN, Welkin.
10:57:50 <boogalooga> Hi
10:58:00 <boogalooga> I'm trying to understand the difference between
10:58:06 <boogalooga> newtype and data
10:58:10 <boogalooga> can someone help me out
10:58:11 <boogalooga> ?
10:58:18 <Welkin> newtype is the same as data, but with exactly one field
10:58:30 <ertes> boogalooga: newtype MyInt = MyInt { fromMyInt :: Int }
10:58:31 <Welkin> newtype is automatically unwrapped, so it reduces overhead
10:58:47 <boogalooga> what's unwrapping?
10:58:51 <ertes> boogalooga: MyInt is operationally completely equivalent to Int…  the constructor is operationally meaningless
10:58:58 <Welkin> I mean, exactly one data constuctor with exactly one field
10:59:12 <boogalooga> ahuh
10:59:16 <ertes> boogalooga: its main purpose is to create wrapper types either for type safety or for custom instances
10:59:32 <ertes> s/custom//
10:59:39 <boogalooga> wait why not just use data with a single constructor?
10:59:46 <Welkin> boogalooga: it adds overhead
10:59:49 <boogalooga> I don't understand the part with the unwrapping
11:00:01 <ertes> boogalooga: because 'data' isn't free, and it's also semantically different
11:00:18 <ertes> boogalooga: newtype vanishes at compile time
11:00:35 <boogalooga> I see
11:00:47 <boogalooga> so if I have newtype MyInt = MyInt Int
11:00:51 <sternmull> hjdskes: I suggest to play around with haskell from the beginning. Play with ghci and write small programs to get a feeling for it. Many things look very complicated when i read about them but are quite simple in practice. I often have to remind myself to stop reading and start using what i know so far (before i forget it while continuing reading...).
11:00:55 <boogalooga> Then at compile time it's treated as just Int
11:01:04 <Welkin> boogalooga: you'll want to name the field so you can extract the Int though
11:01:10 <ertes> boogalooga: after type checking
11:01:14 <monochrom> No, after compile time.
11:01:50 <boogalooga> you'll want to name the field so you can extract the Int though
11:01:54 <hjdskes> sternmull: thanks :)
11:01:54 <boogalooga> not sure what ^^ means
11:02:10 <ertes> boogalooga: newtype MyInt = MyInt { fromMyInt :: Int }
11:02:10 <Welkin> boogalooga: ertes named the field `fromMyInt` above
11:02:21 <ertes> boogalooga: fromMyInt :: MyInt -> Int
11:02:33 <ertes> the compiler writes it for you
11:02:58 <boogalooga> http://www.cis.upenn.edu/~cis194/spring13/hw/05-type-classes.pdf
11:03:04 <boogalooga> I'm looking at the definitions of
11:03:10 <boogalooga> MinMax and Mod7 on page 4
11:03:25 <Welkin> sternmull: yes, and avoid tring to use Arrow when you first start out :P
11:03:43 <Welkin> does anyone remember when Arrows were the hot thing?
11:03:50 <monochrom> Yes.
11:04:20 <johnw> like 2006?
11:04:30 <Welkin> lol johnw 
11:04:34 <boogalooga> wait what do you mean by avoid using arrows?
11:04:34 <Welkin> what about arrowized frp?
11:04:50 <ertes> Welkin: i don't know when exactly, but they were introduced to implement a parser framework that can drop impossible branches immediately
11:04:51 <boogalooga> like the ones you see when you declare functions?
11:05:03 <monochrom> No, the Arrow class in Control.Arrow
11:05:09 <boogalooga> oh
11:05:14 <boogalooga> that reply wasn't to me
11:05:16 <boogalooga> makes sense
11:05:23 <monochrom> Avoiding -> would be impossible.
11:05:27 <boogalooga> haha
11:06:39 <Welkin> maybe it was just netwire at the time then (2014)
11:07:14 <Welkin> and some older hakyll guides (from when it used Arrow)
11:07:36 <ertes> Welkin: yampa was before netwire
11:07:42 <Welkin> yes
11:07:57 <Welkin> I am talking about when I was just learning haskell and stumbled upon Arrow
11:08:08 <ertes> ah
11:08:43 <Welkin> I used netwire to write my first game (a pong clone)
11:09:04 <ertes> heh, nice =)
11:09:05 <monochrom> Today people don't stumble upon Arrow, because no one mentions it anymore. Just look at the past whole month of this channel until you brought it up.
11:09:19 <monochrom> However, people today stumble upon lens all the time.
11:09:30 <ertes> that's probably because Arrow is horrible
11:09:35 <Welkin> haha
11:09:43 <monochrom> So the up-to-date advice is "don't worry about lens when you first start out".
11:10:21 <sternmull> is there an alternative to lens if i want to access/update datastructures in a sane way?
11:10:25 <Welkin> the other thing I hear about too often is Free monads
11:10:26 <ertes> i wish there was an Int64Map
11:10:45 <Welkin> sternmull: why do you need an alternative to lens?
11:10:54 <Welkin> any alternative would just be lens
11:11:27 <monochrom> newtype Int64Map a = Ctor (IntMap (IntMap a))
11:11:28 <Tuplanolla> ...or `microlens`, being a subset of `lens`.
11:11:36 <ertes> sternmull: lens is the de facto van laarhoven lens library…  there is microlens, but it's really just lens with lots of missing pieces…  and there are the lens-family* libraries, which are also really just lens with lots of stuff missing
11:11:37 <sternmull> "However, people today stumble upon lens all the time." sounded like there where alternatives.
11:12:00 <Welkin> the alternative is to not use lens
11:12:11 <Welkin> and just use regular record update/access syntax
11:12:32 <ertes> sternmull: well, the beauty of van laarhoven lenses is that all those libraries are actually compatible…  you can write those lenses without depending on any library at all, and people can still use your lenses with 'lens', 'microlens' or 'lens-family'
11:12:57 <sternmull> but that gets painful really fast. Especially when there are different data types with fields that use the same name.
11:13:09 <Welkin> I have grown to like lens, even though I stayed away when I started out because it looked too complex
11:13:13 <ertes> sternmull: honestly i write most of my lenses by hand
11:13:31 <johnw> I use lens all the time nowadays
11:13:44 <johnw> I'm forgetting how to interact with Data.Map directly, in fact
11:14:18 <jared-w> lol
11:14:33 <jared-w> mfw lens is the jQuery of haskell
11:14:35 <sternmull> i few months ago i tried to have two data structures with a few fields that reused a name. I got it working with lens. But only with the help of this channel and a lot of trial and error and quite some effort.
11:14:47 <ertes> except jQuery is not nearly as powerful as lens
11:15:07 <jared-w> Well of course not, but it's an amusing parallel
11:15:12 <Welkin> I thought there was a new compiler extensions for record field names?
11:15:32 <johnw> lens reminds me of why I liked Groovy: so much composition
11:16:00 <sternmull> there was "OverloadedRecords" or something like that even when i did my experiment. But there where multiple different extensions and all with some drawbacks... if i remember correctly.
11:16:10 <jared-w> Welkin: there's like 2-3 out there, I think? They all sort of suck
11:17:21 <ertes> i will say this every time this comes up:  haskell needs type-directed name resolution
11:17:28 <Welkin> sternmull: do you records have 138 fields?
11:17:30 <Welkin> your*
11:17:32 <jared-w> But yeah, it's unfortunate... I think the best method out there is still to just not clash your names for now :|
11:17:38 <jared-w> ertes: that would be awesome
11:17:59 <sternmull> and there also multiple ways that lens generated its accessors, and and it took a while to find the right template haskell call to get what i expected.
11:18:02 <ertes> forget all the name punning or overloaded labels stuff that is in GHC…  TDNR would make all of them obsolete in an instant
11:18:18 <Welkin> the only time I have seen Cale get upset is when someone was asking a question about their record type with 130+ fields
11:18:29 <jared-w> ertes: However, wouldn't a `name :: String` field in one record still clash with `name :: String` in another record?
11:18:35 <sternmull> Welkin: No, but there are names like "name" or "id" that are just common.
11:18:51 <ertes> jared-w: no, because you're using it as (X -> String) and (Y -> String)
11:19:02 <jared-w> oooh, gotcha
11:19:27 <hpc> what if data types created a scope for their record fields?
11:19:35 <Welkin> ertes: TDNR?
11:19:35 <jared-w> And even records that were strict subsets would not clash. Nice!
11:19:39 <ertes> hpc: how do you access that scope?
11:19:44 <hpc> data Foo = Foo {unFoo :: String} -- declares Foo.unFoo
11:19:47 <Tuplanolla> You'd have Coq on your hands, hpc.
11:19:56 <jared-w> hpc: pretty sure that's effectively TDNR aka "type directed name resolution"
11:20:16 <hpc> jared-w: TDNR is implicit
11:20:17 <ertes> hpc: that, to me, is the same as just prefixing…  slightly more convenient, but doesn't solve the core problem
11:20:24 <Tuplanolla> @google coq "local open scope"
11:20:25 <lambdabot> https://coq.inria.fr/library/Coq.Numbers.Integer.NatPairs.ZNatPairs.html
11:20:25 <ertes> Welkin: type-directed name resolution
11:20:47 <jared-w> hpc: true, but if it was explicit, it'd be the same thing wouldn't it? 
11:20:47 <monochrom> And every time TDNR is brought up, I have to say this: https://www.mail-archive.com/haskell-cafe@haskell.org/msg84162.html
11:20:54 <ertes> while we're at the topic of coq:  i wish we had an equivalent to coq 'Section'
11:21:17 <hpc> jared-w: in the same way that if type inference is explicit, it's the same as not having type inference :P
11:21:26 <jared-w> monochrom: that is a great rebuttal
11:21:40 <jared-w> hpc: I suppose I should've said "optionally explicit" then :p
11:21:49 <hpc> i am not in favor of TDNR
11:21:51 <monochrom> Thanks!
11:21:54 <Welkin> buffalos
11:22:11 <monochrom> And I'm most proud of the part about "import Verbs(buffalo,buffalo)"
11:22:21 <monochrom> Stroke of genius.
11:22:38 <hpc> i have been using rust lately, and it does the new scope thing not just for record fields but constructors as well
11:22:39 <Welkin> monochrom: is that your email?
11:22:45 <monochrom> Yes.
11:22:51 <jared-w> Welkin: don't sign him up to any fun sites now....
11:23:06 <hpc> so far i haven't torn my hair out, but that coding style is also not nearly as heavy on pattern matching
11:23:10 <ertes> monochrom: practically speaking i think that's a non-problem…  it's one of those "but…  but…  but…  i can still arbitrarily construct a potential problem" arguments, and it doesn't even do a fair comparison of the cost of TDNR against its advantages
11:23:25 <monochrom> Oh I think Welkin means "is that your email message". I don't think my email address is shown.
11:23:46 <jared-w> ertes: you would also have to see how easy it is to make "buffalo buffalo" style code in existing haskell
11:23:59 <monochrom> Unless you mean "is haskell-cafe@haskell.org your email address?" in which case I'm going to naughtily answer "yes!"
11:24:19 <hpc> monochrom: if he sends an email there, you receive it
11:24:21 <hpc> monochrom: ergo it is yours
11:24:23 <jared-w> copious name shadowing, recursive lets, and a few wheres can probably get you pretty far into ridiculous obfuscation category
11:24:43 <nicknight> how can I get email with haskell.org ?
11:25:12 <ertes> jared-w: how easy it is is not really relevant…  it's already easy enough to make confusing code with haskell without TDNR…  the question is how likely this is to become a problem in production, and what options are available to limit it
11:25:14 <monochrom> Subscribe to haskell-cafe. Then tell people to email you at haskell-cafe@haskell.org :)
11:25:16 <hpc> nicknight: the joke is that's a mailing list
11:26:16 <monochrom> To be fair you have to let people use it before you can take data on how have you gained and what have you harmed.
11:26:23 <jared-w> ertes: well sure. That's what I was getting at; you phrased it better than me though :)
11:26:53 <ertes> jared-w: look at OOP…  they've had TDNR for ages, and i've never once considered it a problem even in massive code bases…  the only context where it became problematic was dynamic dispatch
11:26:55 <jared-w> Now, I do have a question. Would something like row polymorphism, row types, or algebraic subtyping aleviate the record issues at all?
11:27:17 <monochrom> OOP also has zero type inference.
11:27:40 <monochrom> OK, not zero, but as little as our universe's ground state vacuum energy.
11:27:49 <hpc> ertes: it instantly becomes a problem with polymorphism
11:27:49 <jared-w> True, but most OOP languages have such weak typing systems that it barely matters?
11:27:50 <ertes> jared-w: good question
11:28:06 <hpc> once something can be multiple types at runtime, you don't know which overloaded method is going to be called
11:28:11 <monochrom> At the very least you have to cite OCaml for a better estimate.
11:28:38 * jared-w always forgets OCaml technically has OOP in it
11:28:57 <hpc> in OOP, the problem of overloads is solved with interfaces
11:29:04 <hpc> which are in a lot of ways similar to type classes
11:29:11 <monochrom> And OCaml has restricted "TDNR", restricted to only when you write the "o.x" syntax. And OCaml has to give up a small share of type inference, too (then again it's just because subclassing)
11:29:12 <ertes> i think we should just try it…  all these counterarguments are based on the theory that we will use it in the most terrible ways, and that there will be clashes everywhere
11:29:15 <ertes> i don't buy that
11:30:13 <ertes> and if you're really that worried, make it record-field-only
11:30:21 <monochrom> My hunch is that TDNR would cause Haskell type inference uncomputable.
11:30:25 <hpc> ^
11:30:35 <monochrom> @quote monochrom 17-ary
11:30:35 <lambdabot> monochrom says: I am 17-ary, going on 18-ary, I can take curry of you
11:30:44 <jared-w> lol
11:30:50 <monochrom> We already have that much mess without TDNR.
11:30:58 <jared-w> It's 16 and 17 in the movie
11:30:59 <hpc> imo even if it doesn't, it makes it significantly more difficult for humans, even in "simple" cases
11:31:07 <ertes> monochrom: with record fields there is always a monomorphic disambiguator
11:31:13 <hpc> because you always have to think about if anything you use could possibly be overloaded
11:31:20 <monochrom> Ah, 16->17 is for the girl, 17->18 is her boyfriend.
11:31:26 <ertes> so make it record-only…  i mean this is for the most part to disambiguate record fields
11:31:26 <sternmull> i have a vague memory of a monad transformer library that uses type classes (i think) that where named like "HasIO" or similar to cope the the many possible combinations of monads. Could anyone give me a hint what that was called? I fail to find it.
11:31:39 <monochrom> The boyfriend sang "I am 17, going on 18, I can take care of you"
11:31:47 <ertes> sternmull: mtl?
11:31:53 <ertes> sternmull: even base has MonadIO now
11:31:54 <hpc> sternmull: https://hackage.haskell.org/package/base-4.10.0.0/docs/Control-Monad-IO-Class.html#t:MonadIO
11:32:09 <sternmull> thanks!
11:32:16 <jared-w> oh right, you're quoting the lad here :)
11:32:27 <monochrom> RFTDNR = record field type directed name resolution = DuplicateRecordLabels
11:32:55 <jared-w> monochrom: is that really what DRL does?
11:33:01 <ertes> except DuplicateRecordLabels doesn't use inference…  for the most part you have to patronise it anyway, and it's really frustrating to use
11:33:07 <monochrom> Actually I haven't checked again.
11:33:41 <ertes> s/Labels/Fields/
11:33:43 <jared-w> Yeah inference seems key to the whole TDNR bit
11:33:47 <jared-w> Otherwise what's the point?
11:33:57 <ertes> exactly
11:34:03 <Welkin> wtf did I come back to? o.o
11:34:20 <Welkin> boyfriends?
11:34:27 <hpc> Welkin: the monthly "records have one or two shortcomings" discussion
11:34:31 <ertes> with record fields there is always a type-level disambiguator: the record type
11:34:36 <ertes> so just use inference
11:35:58 <ertes> you don't have to do the whole type generalisation story of general TDNR, if it's limited to record fields
11:36:27 <hpc> ertes: does what you propose let me write a record with an "id" field?
11:37:01 <ertes> hpc: you could write one, but if you use it as 'id', it will tell you that it's ambiguous (even if it could, in theory, disambiguate)
11:37:28 <ertes> hpc: it would only do TDNR among field accessors…  if there is anything else in scope, it would fail
11:37:33 <monochrom> No no, I know what we need now.
11:38:04 <monochrom> We need record access syntax "r.x" or SML's "r#x".
11:38:24 <hpc> monochrom: ooh, yes
11:38:30 <monochrom> Because whatever nice semantic thing you want to do to record access, you want to do it on that syntax only.
11:38:47 <hpc> monochrom: i don't care if anyone actually using that record syntax, but it would mean people have to put spaces around (.)
11:38:47 <ertes> let's make it r->x
11:38:55 <ertes> {-# LANGUAGE -XPHP #-}
11:38:55 <Welkin> ertes: pointers?
11:39:05 <hpc> ertes: even C uses that syntax
11:39:28 <monochrom> For example if you say "TDNR but it's just for record access" then it's simplest to use syntax to indicate this.
11:39:55 <ertes> monochrom: i don't see why it would require special syntax
11:40:36 <monochrom> Maybe it doesn't, but I do.
11:40:46 <monochrom> I want it this way, OK?
11:40:52 <Welkin> what's wrong with ^. ?
11:41:03 <monochrom> But I have good reason. Both implementation and explaining to users are simpler.
11:41:16 <ertes> monochrom: you can't have it this way, because i want it my way
11:41:19 <hpc> and just by looking at it in a piece of code, you know what it is
11:41:46 <ertes> monochrom: ah, explaining to users…  so that's why the AMP went through =)
11:42:20 <ertes> haskell is a difficult language…  we don't have to pretend that it's easy =)
11:42:29 <monochrom> Because the alternative "whenever you see 'f x', TDNR may or may not trigger based on factors #1, #2, and #3" is more complicated. Doable, but complicating.
11:42:30 <hpc> we don't have to make it harder either
11:43:06 <ertes> i would probably end up never using it, if it were that way
11:43:12 <monochrom> Like how when you're making a watch you decide to add months and days-of-month and then you add a provision for leap years and then...
11:43:26 <hpc> what monochrom just said is really the key argument - being able to look at a piece of code in isolation and know for absolute fact certain properties about it
11:45:06 <ertes> i'd be fine with some kind of wrapper syntax for TDNR, but please please please without any binding to the argument
11:45:07 <monochrom> Also I have a  status-quo argument. Everyone who desires TDNR point to other languages' ability to do this to "r.x". None of them can point to another language that does it to general function application "f x".
11:45:20 <ertes> !field! x
11:45:37 <ertes> the problem with x.field is that now i have to write:  \x -> x.field
11:45:42 <ertes> instead of just 'field'
11:46:05 <monochrom> What is the answer to :type !field! ?
11:46:40 <ertes> either ambiguity or two types
11:46:43 <monochrom> I don't think even an SML REPL wants to answer that.
11:47:12 <hpc> ertes: one of the properties of haskell that keeps things sane is that every expression has a single type
11:47:18 <monochrom> Because, you know, in SML the naked "#field" actually exists, IIRC.
11:47:34 <monochrom> Or at least "#1".
11:47:47 * monochrom rubs hands and evil-smiles
11:48:02 <monochrom> This is where the fun begins, because #1 is good for all tuples.
11:48:17 <monochrom> (x,y)#1 = x.  (x,y,z)#1 = x.  etc
11:48:30 <sternmull> what i don't understand (coming from C++): Why can functions not be overloaded by their argument type? What is the problem having "myField x" picks the one valid "myField" function, and gives a compiler error if it is ambiguous or does not exist?
11:48:46 <monochrom> In Haskell you have to load up the lens library to do this. Or a lens library. Whatever.
11:48:54 <ertes> i think ':t !field!' should be ambiguous
11:49:16 <ertes> i mean how do you ask for the type of 'field' anyway, even with the dot syntax?
11:49:17 <hpc> sternmull: in haskell, or in general?
11:49:28 <monochrom> Ah I need to crack open my ML textbook to see what's legal and what's not.
11:49:38 <ertes> what :t answers is completely unrelated to whether you use my approach or the dot syntax
11:49:46 <sternmull> hpc: Yes in haskell. I don't understand why overloading is not possible in haskell.
11:49:50 <hpc> sternmull: it's a possible feature to add to a language, but it adds way too much if-then-else to the reader's brain when trying to piece together what even a simple expression means
11:50:07 <hpc> in haskell it's not possible because it hasn't been added
11:50:15 <hpc> this discussion is over if it's a good idea to add
11:50:22 <hpc> and what we would gain and lose from adding it
11:51:02 <monochrom> sternmull: C++ has minimal type inference, Haskell has maximal. That makes a difference to how much something is implementable to begin with.
11:51:41 <monochrom> Haskell's answer to function overloading is classes.
11:51:49 <jared-w> Also, overloading a function on its type completely fucks up currying, does it not?
11:52:42 <monochrom> And it avoids majorly harming type inference by going for "(+) :: Num a => a -> a -> a". (Compare with overloading + in C++.)
11:53:13 <hpc> jared-w: as a special case of messing up an identifier's type in general, yes (the special case being how many (->)s are on the right of the function's type's AST)
11:53:22 <monochrom> And even then it already minorly harms type inference. Now "1 + 2" is ambiguous, it's "Num a => a" with "a" unknown.
11:53:44 <sternmull> As i understand it the classes that are generated by lens basically let me overload the field accessors. The ugly part is that it uses template haskell magic to generate them. So it looks like there is already a mechanism to have nice overloading. It is just very difficult to find out how to get it working.
11:53:45 <hpc> monochrom: see also, type defaulting
11:53:48 <monochrom> And in the good spirit of XY problems, Haskell mitigates it with "type defaulting"
11:53:53 <hpc> heh
11:53:54 <jared-w> lol
11:54:26 <jared-w> "but this messes you up, so we only default to a limited extent in code; but the repl is going to be super friendly and default a ton of extra shit for you"
11:54:36 <jared-w> "oh and forget about making your own defaults for things, that's useless"
11:55:17 <monochrom> See why I'm so fond of the narrative of the watchmaker who wants to add a month-day feature.
11:55:32 <hpc> the repl simultaneously defaults more and less for you
11:55:38 <monochrom> In science, every answer to an old question begets a new question.
11:55:55 <hpc> you can do top-level definitions in a file that would default, and make the same definition in ghci and it's polymorphic
11:55:59 <monochrom> In watchmaking and language design, every feature begets a new feature.
11:56:25 <hpc> monochrom: there's no transitive closure of language features? ;)
11:56:36 <monochrom> Also someone pointed out that watchmakers are wise enough to say "add this complication" where we software makers say "add this feature".
11:57:40 <monochrom> So yes for example adding a month-day thing to a watch is "a complication". And then if you decide to support automatic leap years too then it's "one more complication".
11:58:34 <hpc> monochrom: a good way to bring the metaphor back around is that software is like making one really complicated watch and telling everyone to share
11:58:50 <hpc> you don't pay the cost of the complication until you make that second watch
11:59:07 <hpc> (or have to fix the first watch)
12:02:07 <monochrom> So yes lens uses the class system to overload accessors too. You or it make a "HasYummy" class which is good for several types that all have their respective "yummy" fields.
12:02:38 <monochrom> And then recently this approach appears in GHC too.
12:03:03 <monochrom> But it's pretty clumsy to set up.
12:03:19 <Eduard_Munteanu> TDNR?
12:03:28 <sternmull> What do you mean by "appears in GHC"?
12:06:15 <monochrom> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#record-field-selector-polymorphism
12:07:35 <monochrom> Oh I guess Chris Done thought up that part about using a type-level string for the field name.
12:11:24 <Eduard_Munteanu> Cool.
12:16:02 <Guest11184> \join #brasil
12:43:28 <rick-sanchez> Hello, is there some operator that does this [] _ [1,2] = [1,2] and [3] _ [1,2] = [3]???, for a moment I thought that <|> would do the trick, but no, it just concat
12:44:06 <jle`> can you be more specific about what you want it to do?
12:44:17 <Tuplanolla> Choose the first nonempty list?
12:44:27 <rick-sanchez> yes
12:44:59 <rick-sanchez> like: if null xs then ys else xs 
12:45:36 <jared-w> Seems pretty simple to write your own operator that does that although I've got no clue what you'd want to use it for ¯\_(ツ)_/¯
12:45:57 <jle`> yes i don't really know of a common operator that does it
12:46:09 <jle`> but you can take advantage of Maybe's Alternative instance with uncons, i suppose
12:46:18 <jle`> > uncons [] <|> uncons [1,2]
12:46:20 <lambdabot>  error:
12:46:20 <lambdabot>      Ambiguous occurrence ‘uncons’
12:46:20 <lambdabot>      It could refer to either ‘Data.List.uncons’,
12:46:28 <jle`> @let import Data.List as L
12:46:30 <lambdabot>  Defined.
12:46:34 <jle`> > L.uncons [] <|> L.uncons [1,2]
12:46:37 <lambdabot>  error:
12:46:37 <lambdabot>      Ambiguous occurrence ‘<|>’
12:46:37 <lambdabot>      It could refer to either ‘Control.Applicative.<|>’,
12:46:40 <jle`> what, why
12:46:42 <jared-w> lol
12:46:57 <cocreature> > toList (nonEmpty [] <|> nonEmpty [1,2])
12:46:58 <Tuplanolla> Someone imported Parsec earlier, jle`.
12:46:59 <lambdabot>  error:
12:46:59 <lambdabot>      Ambiguous occurrence ‘toList’
12:46:59 <lambdabot>      It could refer to either ‘Lambdabot.Plugin.Haskell.Eval.Trusted.toList’,
12:47:01 <jle`> ah i see
12:47:05 <jared-w> > L.uncons [] Control.Applicative.<|> L.uncons [1,2]
12:47:07 <cocreature> > Data.Foldable.toList (nonEmpty [] <|> nonEmpty [1,2])
12:47:07 <jle`> > uncons [] <|> uncons [1,2]
12:47:08 <lambdabot>  error:
12:47:08 <lambdabot>      Not in scope: ‘L.uncons’
12:47:08 <lambdabot>      Perhaps you meant one of these:
12:47:10 <lambdabot>  error:
12:47:10 <lambdabot>      • Variable not in scope: nonEmpty :: [a0] -> [a]
12:47:10 <lambdabot>      • Perhaps you meant data constructor ‘NonEmpty’ (imported from Lambdabot...
12:47:12 <lambdabot>  Just (1,[2])
12:47:15 <jle`> > uncons [3] <|> uncons [1,2]
12:47:18 <lambdabot>  Just (3,[])
12:47:22 <cocreature> > Data.Foldable.toList (Data.List.NonEmpty.nonEmpty [] <|> Data.List.NonEmpty.nonEmpty [1,2])
12:47:23 <lambdabot>  error:
12:47:24 <lambdabot>      Not in scope: ‘Data.List.NonEmpty.nonEmpty’
12:47:24 <lambdabot>      No module named ‘Data.List.NonEmpty’ is imported.error:
12:47:28 <MarcelineVQ> okaynow
12:47:35 <cocreature> @let import Data.List.NonEmpty
12:47:36 <lambdabot>  Defined.
12:47:38 <cocreature> > Data.Foldable.toList (Data.List.NonEmpty.nonEmpty [] <|> Data.List.NonEmpty.nonEmpty [1,2])
12:47:39 <lambdabot>  [1 :| [2]]
12:47:46 <Tuplanolla> I wish lambdabot got their imports sorted out.
12:48:14 <Tuplanolla> They're a perpetual annoyance.
12:48:27 <MarcelineVQ> start every sesh with
12:48:29 <MarcelineVQ> @undefine
12:48:29 <lambdabot> Undefined.
12:52:20 <rick-sanchez> I think I will have to keep the if null ... or headMay on the lists, actually I wanted to do something like `head $ xs <|> ys` where both are lists, but ys is never empty
12:56:09 <jared-w> Wouldn't it be easier to just use a safeHead z xs? (where z is the default value)
12:58:04 <rick-sanchez> it works for one of my cases, however I had something like: head $ xs <|> ys <|> zs, I rewrote to: headMay xs <|> ...
12:58:17 <jle`> if ys is never empty, why would you have <|> zs ?
12:59:53 <rick-sanchez> ys in this case can be empty, it was not empty in the example of 2 lists, but in the example of 3 it is, the last one in both cases is not empty
13:00:10 <jle`> in that case it's a bit weird to throw it in the mix with the others
13:00:26 <rick-sanchez> sorry
13:00:29 <jle`> don't think about zs as a list...think about whatever the first item in z's is
13:00:36 <jle`> since you aren't really talking about it as a list anymore in this case
13:00:48 <jle`> in that case you can just use listToMaybe and then asum, perhaps :)
13:01:02 <jle`> > asum (map listToMaybe [[],[],[1,2,3]])
13:01:04 <lambdabot>  Just 1
13:01:07 <jle`> > asum (map listToMaybe [[5],[],[1,2,3]])
13:01:10 <lambdabot>  Just 5
13:01:17 <rick-sanchez> I can show you the whole example, maybe there is better ideas
13:01:20 <jle`> or listToMaybe xs <|> listToMaybe ys <|> listToMaybe zs
13:01:22 <jle`> etc.
13:03:26 <rick-sanchez> listToMaybe is the same as headMay of classyprelude? 
13:04:51 <Cale> "<Welkin> the only time I have seen Cale get upset is when someone was asking a question about their record type with 130+ fields" -- hahahaha, I wasn't even really that upset ;)
13:05:19 <Cale> (but I think the solution to a lot of problems with records that large is just to break up the type into smaller ones)
13:05:51 <jle`> rick-sanchez: not sure what headMay from classyprelude is, but check out the type
13:05:57 <jle`> :t listToMaybe
13:05:58 <lambdabot> [a] -> Maybe a
13:06:05 <jared-w> They're equivalent, jle`
13:06:11 <rick-sanchez> great
13:06:25 <MarcelineVQ> records like that I've seen have tended to be mirrors of the api in use, ban api's with 130 fields in a request
13:06:52 <jle`> > foldMap (Alt . listToMaybe) [[],[5],[1,2,3],[]]
13:06:55 <lambdabot>  Alt {getAlt = Just 5}
13:06:57 <jared-w> Or they're mirrors of the business logic you're using. If your business logic requires 130... anything... It's probably poorly thought out :p
13:06:57 <MarcelineVQ> not that I've seen 130 though, that's quite a lot :X
13:08:26 <rick-sanchez> I think I will use the asum solution, thank you for your help :) 
13:08:44 <michowski> Hello everyone. I can't believe you can't rewrite this code using monad operators. But I still fail to do so:
13:08:48 <michowski> https://gist.github.com/michowski/37fbaf6965b355455b91d06e2bf05497
13:09:00 <michowski> Any idea?
13:09:24 <michowski> This code duplication for error handling looks so ugly...
13:09:43 <jared-w> That's a pretty classic case of the either monad, iirc
13:09:59 <michowski> Indeed, when I have such a stuff, it's always straightforward bind: >>=
13:10:19 <michowski> In this case tho, lambda with \encode -> can not go into case ... of
13:10:23 <michowski> And my mind is blown..
13:12:04 <jle`> michowski: i've added a couple of suggestions in the gist
13:12:09 <jle`> you can use >>=, but you have to "process" the either somehow
13:13:12 <jared-w> :t either
13:13:13 <lambdabot> (a -> c) -> (b -> c) -> Either a b -> c
13:13:26 <boxscape> Is there a somewhat common operator whose definition is 'flip'?
13:13:28 <jle`> you can either do straight up pattern amatching or use 'either'
13:13:30 <jared-w> Is that the scott encoding of the either data-type?
13:13:36 <jle`> scott and church :o
13:13:44 <jle`> michowski: i just updated with both pattern matching alongside 'either' :)
13:13:45 <codeshot> :info (&)
13:13:48 <jle`> boxscape: (&)
13:13:50 <codeshot> :t (&)
13:13:51 <lambdabot> a -> (a -> b) -> b
13:13:54 <boxscape> :t flip
13:13:55 <lambdabot> (a -> b -> c) -> b -> a -> c
13:13:59 <jle`> well, it's a restricted version of flip
13:14:03 <boxscape> I see
13:14:37 <codeshot> `flip` :D
13:14:51 <michowski> Thank you so much :) .
13:14:54 <jle`> er sorry, actually, (&) = flip id
13:14:57 <boxscape> ah
13:14:58 <jle`> which isn't flip
13:14:58 <boxscape> ok
13:16:18 <jared-w> ($) <$> encode' <*> x -- this is why people hate haskell :p
13:16:27 <johnw> hah
13:16:45 <johnw> isn't that the same as encode' <*> x?
13:16:53 <jle`> :O
13:17:28 <michowski> Hold on guys... I'm getting lost haha
13:17:32 <jle`> michowski: updated to fix a typo and also yes, encode' <*> x is probably 'better' than ($) <$> ecnode' <*> x :)
13:18:33 <jared-w> michowski: okay so all of the examples are equivalent to each other, for starters :)
13:19:08 <jared-w> The first example is the most explicit. You basically write out the either function by hand. The second example is the first example using the either function
13:19:26 <michowski> The third one is awesome..
13:19:34 <jared-w> The third example uses <*> really elegantly
13:19:37 <jared-w> :t (<*>)
13:19:38 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
13:20:20 <michowski> Thanks guys :) . It's awesome.
13:20:25 <michowski> Exactly what I was looking for.
13:20:34 <jared-w> The last example should be the super awesome one
13:20:56 <jle`> michowski: your hunch was right, it does look like a monadic or applicativey process
13:21:08 <jared-w> The last example is to the third as the second was to the first. That is, anytime you have an explicit casing, you can use a function that abstracts out the case
13:21:11 <jle`> michowski: so we do "build" the final Either monadically/applicative
13:21:25 <jle`> michowski: but the difference from what you might normally see is how we "use" the final Either
13:22:06 <michowski> Yes... I have this sense for functors and monads, as I always can imagine their usage. I don't have it for applicative yet.
13:22:08 <jle`> the thought is kinda build up an Either monadically => post-process the resulting Either
13:22:12 <michowski> But well.. now I see it :)
13:23:16 <michowski> Way too awesome!
13:25:27 <michowski> And now after seeing what `either` does I DO question every of my pattern matching on Either...
13:26:23 <michowski> but it seems that either to pattern match on Either is exactly like if' function to if ... then ... else construct
13:26:41 <Tuplanolla> :t list -- There's this too, michowski.
13:26:42 <lambdabot> b -> (a -> [a] -> b) -> [a] -> b
13:26:55 <michowski> The latter may be more appropriate syntax, sometimes.
13:26:58 <jared-w> That's where my comment about scott/church encoding comes into play :)
13:26:59 <michowski> Am I right?
13:27:08 <jared-w> :t maybe
13:27:10 <lambdabot> b -> (a -> b) -> Maybe a -> b
13:27:20 <michowski> Yeah this one was already in my mind!
13:27:31 <jared-w> :t either -- this is merely the either equivalent
13:27:33 <lambdabot> (a -> c) -> (b -> c) -> Either a b -> c
13:27:38 <michowski> Yeah
13:27:47 <michowski> Still analyzing the list function
13:27:48 <jared-w> You can methodically write these functions out for any datatype
13:28:25 <michowski> I'm lost. What does list do?
13:28:47 <jared-w> it might help to think of it as similar-ish to a fold and thn look at the data construction for a list (ie data List a = Nil | Cons a (List a) )
13:28:56 <Tuplanolla> @let nullish = list True ((const . const) False)
13:28:57 <lambdabot>  Defined.
13:29:01 <betawaffle> does haskell have a built-in type class for morphisms?
13:29:04 <Tuplanolla> > nullish []
13:29:07 <lambdabot>  True
13:29:21 <michowski> Still not there. Damn.
13:29:27 <Tuplanolla> > nullish [(), ()]
13:29:29 <lambdabot>  False
13:29:31 <jared-w> :t list
13:29:32 <lambdabot> b -> (a -> [a] -> b) -> [a] -> b
13:29:45 <michowski> I guess it's too late for me, haha
13:29:48 <codeshot> where is the "list" function defined?
13:30:11 <jle`> betawaffle: what would such a class look like?
13:30:11 <jared-w> default value,  (given an a, and a list of a's, give me a b), list I'm operating on, resulting b
13:30:26 <jared-w> :t foldr
13:30:29 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
13:30:33 <jared-w> :t foldl
13:30:35 <lambdabot> Foldable t => (b -> a -> b) -> b -> t a -> b
13:30:40 <betawaffle> jle`: something that can map a to b
13:30:42 <jle`> foldr is the "church" encoding, list is the "scott" encoding
13:30:51 <jle`> betawaffle: i mean, what would the class look like
13:30:54 <jle`> what would its methods be
13:30:54 <jared-w> right, m'bad
13:31:53 <jle`> betawaffle: you might be looking for Category, which has identity (id :: cat a a) and composition ((.) :: cat b c -> cat a b -> cat a c)
13:31:54 <michowski> I still don't see similarity with folds
13:32:08 <michowski> Why is it
13:32:08 <michowski> (a -> [a] -> b)
13:32:14 <michowski> and not (a -> a -> b)
13:32:16 <betawaffle> maybe like: class Morphism m a b where; morph :: m -> a -> b
13:32:20 <betawaffle> jle`: let me see
13:32:46 <jared-w> because you're operating on a list :)
13:33:06 <tesan> I'm looking for an alternative to Matlab for my projects @ the university I am studying at. Any suggestions from Haskell?
13:33:12 <iqubic> What function are we looking for?
13:33:21 <michowski> :t list
13:33:22 <lambdabot> b -> (a -> [a] -> b) -> [a] -> b
13:33:28 <michowski> :t foldr
13:33:29 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
13:33:49 <iqubic> What does the list function even do?
13:33:51 <jared-w> (the foldr was a bad example since the types don't line up right)
13:33:52 <Tuplanolla> I've tried that and Haskell was unpleasant to work with, tesan. Octave or SciPy work much better.
13:33:53 <jle`> tesan: what sort of alternative are you looking for?
13:34:01 <jle`> tesan: if you mean "a free alternative", try octave
13:34:14 <jle`> what parts of matlab are the parts that you don't like?
13:34:28 <jle`> (if the part that you don't like is the licensing, then, octave is an answer)
13:34:28 <michowski> Array indexing from 1
13:34:29 <michowski> I suppose
13:34:30 <michowski> haha
13:34:31 <betawaffle> jle`: what i'm looking for is a function with this signature: (a -> b) -> (a -> a) -> (b -> b)
13:34:35 <betawaffle> (i think)
13:34:56 <jle`> betawaffle: the only one i can think of is foo _ _ = id
13:35:05 <iqubic> betawaffle: What are you trying to do?
13:35:35 <tesan> Matlab itself. I can't just randomly make it part of custom servers .etc because of licensing. I also wanted to use it as an opportunity to improve my knowledge about Haskell.
13:35:49 <jle`> what sort of work are you doing?
13:35:52 <betawaffle> iqubic: convert a mapping from a -> a to a mapping from b -> b using a mapping from a -> b
13:36:14 <jle`> betawaffle: that's not possible in general
13:36:22 <jle`> except for the trivial mapping
13:36:27 <jle`> \_ _ -> id
13:36:33 <betawaffle> huh?
13:36:34 <jle`> unless you had specific types in mind
13:36:37 <iqubic> why do you need that?
13:36:40 <tesan> jle`: My practical maths subject uses it to teach us maths. We'll certainly expand it to use it with our IoT projects for data analysis.
13:36:48 <jle`> tesan: what kind of maths?
13:37:10 <jle`> betawaffle: it's impossible, given only (a -> b) and (a -> a), to get a (b -> b)
13:37:17 <jle`> betawaffle: unless you know more details about 'b' or 'a'
13:37:18 <betawaffle> jle`: think of them like maps instead of functions?
13:37:22 <jle`> except for the trivial mapping
13:37:28 <tesan> jle`: "Any" would be a good way to describe it. Basic linea algebra, matrix manipulations, interpolation ...
13:37:36 <jle`> tesan: not like, abstract algebra
13:37:43 <iqubic> betawaffle: What is the use case for this function?
13:37:44 <jle`> logic?
13:37:56 <jle`> set theory, category theory?
13:38:13 <jle`> or do you mean simply numerical analysis
13:38:28 <tesan> jle`: We did numerical analysis, also some image-manipulations.
13:38:32 <jle`> by linear algebra, do you mean actually linear algebra, or like linear arithmetic?
13:38:41 <betawaffle> ok, so imagine i've got a Map k v
13:39:14 <betawaffle> i want to convert a function k -> k into a function v -> v. oh now i see
13:39:15 <jle`> tesan: ah i see, so mostly numerical stuff
13:39:19 <betawaffle> i need two mappings?
13:39:24 <betawaffle> forward and reverse?
13:39:24 <iqubic> If you have maps, then that is a whole lot more specific than (a -> a)
13:39:47 <jle`> betawaffle: yeah
13:40:13 <betawaffle> ok, so (a -> b) -> (b -> a) -> (a -> a) -> b -> b
13:40:21 <jle`> tesan: in that case at this point, the path of least friction would probably be octave (OSS matlab) or numpy/scipy
13:40:33 <Tuplanolla> You have discovered `iso` from `lens`, betawaffle.
13:40:44 <jle`> tesan: haskell has some nice tools too at the moment, but there is a bit of a less clear ecosystem path at this point in time
13:40:55 <betawaffle> Tuplanolla: i don't get it
13:41:19 <iqubic> betawaffle: Just know that your function will work.
13:41:20 <jle`> betawaffle: the 'Iso' type from the lens library 'packages up' an (a -> b) and (b -> a) pair for you to use
13:41:31 <Tuplanolla> > over (iso ord chr) (+ 13) 'a' -- Example, betawaffle.
13:41:34 <lambdabot>  'n'
13:41:34 <betawaffle> iqubic: huh?
13:42:06 <jle`> tesan: if you're curious and want to see what haskell can offer in numerical analysis/statistics at the moment, check out http://www.datahaskell.org/
13:42:35 <jle`> betawaffle: the `Iso' a b` type from the lens library is basically an (a -> b, b -> a) tuple
13:42:44 <betawaffle> ok, cool
13:42:45 <jle`> and you can use "over" to utilize it
13:42:45 <iqubic> (a -> b) -> (b -> a) -> (a -> a) -> b -> b will work.
13:42:54 <betawaffle> so i'm not crazy
13:42:58 <jle`> over :: Iso' a b -> (b -> b) -> (a -> a)
13:43:11 <jle`> under :: Iso' a b -> (a -> a) -> (b -> b)
13:44:02 <tesan> jle`: I checked it out before, I was just a bit overwhelmed by the ammount of packages there. What would they use to visualize the data?
13:44:13 <jle`> betawaffle: you can construct an Iso' using the iso function, iso :: (a -> b) -> (b -> a) -> Iso' a b
13:44:46 <jle`> tesan: "yes", but it's less smooth than what's currently out there in the python ecosystem
13:45:59 <iqubic> :t under . iso 
13:46:01 <lambdabot> error:
13:46:01 <lambdabot>     • Couldn't match type ‘b0 -> t0’
13:46:01 <lambdabot>                      with ‘Control.Lens.Internal.Iso.Exchange a1 b a1 (Identity b)’
13:46:13 <iqubic> :t iso . under
13:46:14 <lambdabot> (Functor f, Profunctor p) => AnIso s t1 a b1 -> (b2 -> t2) -> p (b1 -> a) (f b2) -> p (t1 -> s) (f t2)
13:46:25 <iqubic> Err?!?!
13:46:41 <Tuplanolla> :t under .: iso
13:46:42 <lambdabot> (s -> a) -> (b -> t) -> (t -> s) -> b -> a
13:47:04 <iqubic> :t (.:)
13:47:05 <lambdabot> (b -> c) -> (a1 -> a2 -> b) -> a1 -> a2 -> c
13:47:15 <iqubic> What is that even?
13:47:29 <Tuplanolla> It's the owl operator.
13:47:29 <MarcelineVQ> no more than it looks like
13:48:16 <iqubic> Tuplanolla: Is that like the boob operator?
13:48:30 <iqubic> :t ((.).(.))
13:48:30 <jle`> (f .: g) x y = f (g x y)
13:48:31 <lambdabot> (b -> c) -> (a1 -> a2 -> b) -> a1 -> a2 -> c
13:48:47 <iqubic> Owls are isomorphic to boobs.
13:49:35 <tesan> Looks like I'll have a hard time getting a practical approach to Haskell during my studies, as they skipped Functional Programming Languages at my course. At least I'll be able to use it eventually for server coding...?
13:50:39 <jle`> tesan: for what it's worth, haskell was very beneficial for me, as a physics major specializing in computational physics, with understanding the wide range of numerical analysis and processes i had to learn
13:50:48 <jle`> i used it over matlab for everything
13:51:12 <jle`> but i put in a bit of upfront work to be able to get to the point where it was "more useful" than other tools
13:51:31 <jle`> it's something i'd definitely recommend as a personal journey
13:51:54 <jle`> but i'm not sure if i'd pick it for instruction for a general audience
13:52:08 <tesan> That's what I imagined. So do you have any suggested "Starting-point" or "Waypath"?
13:52:38 <jle`> i did it on a case-by-case basis
13:52:50 <jle`> but also learning haskell "in general" was a nice way to recognize common patterns
13:53:00 <tesan> We have spoken like 3 months ago when I had my first attempt at grasping Haskell, people happened to tell me that I'd probably learn Haskell at my programming subject @ university.
13:53:19 <tesan> Alas, that will never be the case in the university I am at rn.
13:53:20 <jle`> for example, when i took a course on stochastic processes, i used mealy/moore machines (that were trendy in haskell at the time) to model continuous and discrete time markov chains
13:53:23 <Tuplanolla> I took the same journey as jle` and my conclusion is the opposite. Haskell is an absolutely horrible choice for quantum Monte Carlo, discrete--finite element methods and other mutation-heavy computational physics.
13:53:45 <tesan> Markov Chains?  That was a recent exercise of mine.
13:54:10 <jle`> interestingly enough my first real haskell project was metropolis-hastings monte carlo models for quantum mechanics
13:54:32 <jle`> well, for markov chains, haskell gave me a way to understand them on a more algebraic level
13:55:29 <jle`> when i say it was beneficial, i say that it did help me understand what i was doing a bit better and give me some insight that a tranditional untyped imperative aproach might not have given me
13:55:51 <jle`> but at substantial up-front cost
13:56:01 <jle`> hopefully one day things will be different
14:00:58 <awoken> ?
14:01:06 <Tuplanolla> If you want fast compilation, you have to fight with the tooling, and if you want fast execution, you have to fight with code generation. Neither problem is fundamental.
14:02:21 <tesan> Fast compilation would help in the learning phase and during production. Fast execution would be important for the projects.  What do you mean with "fundamental problem"?
14:03:45 <Tuplanolla> If we poured a million man-hours into GHC, we could solve at least one of these problems.
14:06:07 <tesan> That sounds horrible.
14:09:48 <Tuplanolla> That's how Mathematica did it for example. Deep down it's just a mediocre proprietary term-rewriting M-Lisp.
14:10:54 <ongy> Can I specify the package a module is from in an import statement? (I have clashing module names :/)
14:11:05 <Tuplanolla> It would have never taken off if Wolfram Research hadn't hired an army of people to translate droves of mathematical literature into it.
14:11:14 <hpc> ongy: PackageImports iirc
14:12:22 <monochrom> Yes but you're much suggested to use cabal to control which package you use to begin with.
14:12:38 <ongy> hpc: thx.
14:12:57 <hpc> also what monochrom said, if you're not doing that already
14:13:22 <tesan> Tuplanolla: I see. Too bad that a noob like me wouldn't be able to do anything about it, until in let's say a few years time.
14:13:51 <ongy> I am, but I'm to lazy to push my modules down a level, so I got 1 clashing name. Which is lazier to resolve this way for me.
14:16:01 <monochrom> There is also a Backpack rename-the-module solution too...
15:01:52 <Naughtmare[m]> Is it possible to compile a haskell library to a .so file and then load it in ghci and then call functions from that library like normal haskell functions?
15:03:54 <Welkin> just import the library in ghci
15:11:05 <Naughtmare[m]> Welkin: I get variable not in scope errors
15:12:23 <Naughtmare[m]> I build my project with cabal install --enable-shared, then run ghci dist/dist-sandbox-1a0b1d3/build/libHSmylibrary-ghc8.2.1.so, then try to call functions from my package, but that doesn't work.
15:12:26 <Welkin> add the library to your .cabal file, then use `stack repl` or `cabal repl`
15:12:40 <Welkin> then `import LibraryName`
15:13:30 <monochrom> I don't think "ghci something.so" is supposed to do what you think.
15:13:50 <Naughtmare[m]> Welkin: No I want to be able to only use the shared object file. I want other people to be able to execute my library functions without having the source code.
15:14:14 <monochrom> Then the user has to install the package.
15:14:45 <monochrom> And after installing, "ghci" alone will already know about it.
15:14:57 <Welkin> Naughtmare[m]: I am having trouble understanding why anyone would even want that
15:15:11 <Welkin> let alone why you want to do it
15:15:23 <Welkin> when all you need to do is install the library
15:15:26 <monochrom> In fact since you have already done your own "cabal install", your ghci should know about it too.
15:15:54 <monochrom> So at this point I'm suspecting an XY problem.
15:16:47 <Welkin> a male chromosome problem?
15:17:00 <lavalike> maybe this is relevant https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/ghci.html?highlight=compiled#loading-compiled-code
15:17:04 <monochrom> That's for another day.
15:19:26 <Naughtmare[m]> Ok, here's my actual problem: I want to provide a command line inside my application where the user can input their own commands, but I want them to be able to use normal haskell syntax so a custom parser is not really possible. But I also don't want to make the user install the entire ghc toolchain on their computer, let alone make sure that he has my application installed at all times.
15:19:54 <Naughtmare[m]> I forget a bit: I intend to use hint to evaluate the commands.
15:20:13 <Rembane> Naughtmare[m]: Why Haskell syntax? And have you looked into the library that powers lambdabot?
15:20:13 <monochrom> Any user of hint is also forced to install GHC.
15:21:06 <monochrom> Well, unless the user never uses any type or thing from base such as numbers and strings, but I doubt it.
15:21:27 <monochrom> Even a simple "1+1" in hint already requires the presence of GHC.
15:21:50 <monochrom> So yeah, your specification is a self-contradiction. You have to give up one thing.
15:22:15 <Naughtmare[m]> monochrom: I guess the compiling and running itself also requires GHC so avoiding that doesn't really work, but I still want to avoid having the user manage cabal packages.
15:22:31 <Welkin> what kind of application is this?
15:22:40 <monochrom> You can roll your own installer.
15:22:45 <Welkin> where someone is programming, but they aren't a programmer?
15:22:47 <Welkin> I don't get it
15:22:51 <Naughtmare[m]> https://github.com/yi-editor/yi
15:23:21 <Welkin> what about yi?
15:23:32 <Naughtmare[m]> That's the application
15:23:33 <monochrom> But even your own installer has to include like 90% of GHC.
15:23:55 <monochrom> Any use of the GHC API (hint is just an example) forces this.
15:24:08 <monochrom> You can't change this by talking to me.
15:24:24 <Naughtmare[m]> We currently have a hard coded list of commands or a custom -hint flag, but that requires managing cabal packages.
15:24:35 <monochrom> But you can change this by writing your own parser and interpreter and giving up "I don't want to write my own parser and interpreter".
15:24:42 <monochrom> You can also consider Hugs.
15:26:58 <Cale> Well, I think the point of yi is to be configurable in Haskell, just like xmonad is, right?
15:27:12 <Cale> So requiring the user to have GHC doesn't seem so bad.
15:27:53 <Welkin> and they are almost certainly using it to write haskell
15:27:57 <Welkin> so what's the problem?
15:31:44 <Naughtmare[m]> Okay, so maybe yet another problem is that if Yi is built with stack and has hint support enabled, then  if it is not launched inside a stack environment (with `stack exec yi`) then hint will not find the yi package.
15:32:00 <Naughtmare[m]> I guess I should improve my ability to ask the right questions...
15:32:16 <sm> Naughtmare[m]: it's tricky stuff, no harm in exploring
15:32:24 <monochrom> Sure, stack default behaviour is pretty much a walled garden.
15:32:27 <sm> at what point would the user be required to manage cabal packages ?
15:33:11 <monochrom> So skip stack, or find out non-default stack settings that suit your purpose.
15:33:26 <Naughtmare[m]> sm: The user is required to have the yi package installed globally, otherwise hint cannot find it.
15:33:48 <Naughtmare[m]> Some users don't want to install anything globally.
15:34:22 <sm> shouldn't you have a custom script that starts yi in the proper context, ensuring required packages are present etc.
15:35:20 <Naughtmare[m]> sm: That is a very good idea, but how would it work? Should it call `stack exec` under the hood?
15:35:26 <sm> perhaps
15:35:40 <monochrom> Yeah, "#!/bin/sh  exec stack exec yi" is not rocket science.
15:35:57 <sm> whatever you would do manually as an expert, it should automate for the average user
15:36:19 <monochrom> However, "auto-detect whether you're using cabal or is it stack and whether you're sandboxing etc etc" is rocket science.
15:36:38 <sm> you could consider using/customising stack's cross platform installer script too, it's pretty good
15:37:19 <Cale> Naughtmare[m]: Maybe something involving nix could work...
15:37:45 <monochrom> That's sounds worse.
15:37:54 <Cale> Hah, possibly.
15:37:59 <sm> yeah it does. :)
15:38:22 <monochrom> I mean up to this point we're already looking at "so I have to inflict ghc and hint and stack and cabal on the end-user?!" and now you add "yeah and nix too!"
15:38:47 <sm> well. As long as its hidden behind a script, and it works, anything goes ?
15:38:49 <Cale> Well, it depends on the reason that this was a problem
15:38:52 <monochrom> Although I'm skeptical about the "I'm inflicting cabal on the end-user" part.
15:39:19 <Cale> If the concern is that installing stuff globally might interact in bad ways with existing installations, then nix might be a solution to the problem
15:39:23 <monochrom> Clearly you can build binaries and just tarball up the binaries. I did this to my own build of Haskell Platform.
15:39:39 <Cale> If the concern is disk space, nix is definitely not the solution.
15:40:55 <sm> Naughtmare[m]: you want a reliable easy setup process for users ? cross platform ?
15:41:33 <sm> without relying on system packages ?
15:42:17 <Welkin> sm: that doesn't exist
15:42:21 <monochrom> There are also more fun bed-time stories about the use of GHC API.
15:42:48 <Welkin> even the "reliable, easy setup process" by itself doesn't exist
15:43:39 <monochrom> If your code (lib or exe, doesn't matter) uses GHC API, the user has to use the same matching GHC version as what you used to build the binary.
15:43:41 <sm> Welkin: I guess it's a matter of degree, but I think hledger's install script isn't bad now
15:43:52 <Welkin> sm: I meant for any software
15:44:37 <sm> well let's not be extreme and throw up our hands...
15:44:51 <monochrom> Actually more than that, but let's say you try to grok that first.
15:45:42 <monochrom> This is why you have to rebuild ghc-mod every time you switch to another GHC version.
15:46:46 <monochrom> And this is also probably why the intero people said "screw it, we'll insist on stack" and let the walled-gardenness eliminate the question.
15:48:29 <johnw> monochrom: that, and a main author of intero is from FP Complete
15:51:01 <Naughtmare[m]> I guess writing an interpreter for a small haskell-like language might be the easiest solution.
16:03:24 <inkbottle> Where can I find information about ((->) a) monad? (So far I can't find a way to google about it)
16:04:37 <mud> inkbottle: It's also called the "Reader" Monad, conceptually. Though actualy Reader is implemented a bit differently than just a wrapper.
16:04:41 <lyxia> inkbottle: ghci > :i (->)
16:05:41 <inkbottle> mud: lyxia: thanks, I will use that for a first step
16:07:22 <lyxia> You have to dig a bit more than usual on Hackage to get to the source, but here it is with colors: https://github.com/ghc/ghc/blob/master/libraries/base/GHC/Base.hs#L804
16:08:13 <royal_screwup21> what's the difference between func (x) and func $ x?
16:08:35 <Axman6> nothing
16:08:40 <inkbottle> lyxia: tx, nice
16:08:42 <Axman6> @src ($)
16:08:43 <lambdabot> f $ x = f x
16:08:45 <Cale> inkbottle: If you try to write the instance of Monad for it, you'll find out that you can only do it in one possible way that will typecheck, so it's a good exercise to figure out for yourself what return and (>>=) (and fmap, join, some others) do
16:09:33 <Axman6> royal_screwup21: $ is useful when you are composing functions - f (g (h x)) = f . g . h $ x, a little easier to type because you don't need to match parens
16:10:35 <inkbottle> Cale: yes, good exercise
16:12:56 <johnw> I like to use $ to separate "domains". So, I almost always write return $ x + y, to show that x + y is in one domain (pure, in this case), while the return expression is in another (monadic).
16:15:59 <Cale> I've gotten quite used to return . f . g $ x
16:17:17 <royal_screwup21> Axman6: I'm trying to write a transpose function like so: https://thepasteb.in/p/RghnWGqYP47Hz <- this works but
16:17:35 <royal_screwup21> https://thepasteb.in/p/oYhlYD39AORIZ this doesn't
16:18:38 <royal_screwup21> here's the error: https://thepasteb.in/p/mwh1lpNrv8nf5
16:19:14 <royal_screwup21> all I've done is replaced the () with $...what am I doing wrong in the latter case?
16:19:59 <geekosaur> $ is lowest precedence, so the implied parentheses apply all the way back to the =
16:20:00 <Cale> royal_screwup21: $ has lower precedence than other operators
16:20:08 <geekosaur> and the parens in (map head x) aren't needed
16:20:10 <Cale> in particular, it has lower precedence than :
16:20:23 <geekosaur> because normal function application is highest precedence instead of lowest
16:20:36 <Cale> function application (whitespace) effectively has higher precedence than any infix operator can have
16:22:12 <royal_screwup21> so there is a difference after all
16:22:31 <geekosaur> well, any time you use an infix operator, it has a precedence
16:22:46 <geekosaur> otherwise you don't know what it operates on
16:24:11 <Tehnix> Is there a limit on nested lambdas in GHCI, or did I stare myself blind? `let add = \n -&gt; \n' -&gt; \f -&gt; \x —&gt; n f (n' f x)` complains about `parse error on input ‘—&gt;’`
16:24:33 <mniip> that's an em-dash
16:24:45 <geekosaur> that is an html-magled paste
16:25:01 <geekosaur> not sure the em dash is in the oiginal. certainly haskell's not going to translate the html entity :p
16:25:24 <geekosaur> i.e. please try to get a less manged paste so we can see what is actualluy there
16:25:29 <geekosaur> *mangled
16:26:00 <Tehnix> mniip: ah, good catch! Dunno how that ended up there ._.
16:27:54 <monochrom> Fortunately I can read HTML raw cold.
16:28:01 <monochrom> There is no limit.
16:28:17 <monochrom> But yeah GHC is not going to read HTML.
16:28:46 <Tehnix> Haha, I think I had alt/option pressed while typing - which yields – (the em dash)
16:28:52 <monochrom> Or the emdash for that matter.
17:36:16 <mbwgh> So, I posted a question on /r/haskell an forgot to mention category theory in the title: https://www.reddit.com/r/haskell/comments/7b1fbk/do_mtlstyle_effect_classes_really_pull_their/ . Actually I might change the title, but I can't. Anyway, is there an obvious reason my post would get downvoted immediately? I have encountered this before, and see it on other posts where people genuinely ask for advice in 
17:36:22 <mbwgh> a constructive manner. Is this just how reddit works?
17:37:28 <lyxia> yes
17:38:39 <mbwgh> I should ask my questions on 4chan then...
17:39:14 <lyxia> Some have ridiculous standards about what should be on their front page, others like blue arrows. *shrug*
17:40:23 <lyxia> reddit also has some randomization of scores
17:44:05 <mbwgh> Still, the overall impression I got from following this subreddit for maybe a year now is that it is very elitist, in the way that it's more important to chase after the next big abstraction rather than taking the more mundane problems seriously as well. I read a comment by bos in which he stated something along these lines as the exact reason to why he chooses not to actively participate in the community 
17:44:11 <mbwgh> anymore.
17:47:14 <zomg> almost all subs I've followed tend to turn into cliques
17:47:56 <zomg> which is a shame as when that hasn't yet happened or perhaps is on a break there can be some interesting content to be found
17:52:07 <sm> mbwgh: I think if you look at the history you'll see a lot of diverse topics including "mundane" problems
17:55:43 <mbwgh> sm: I didn't claim that they don't exist. But they get a fraction of the attention. Furthermore, absolute beginners get redirected to advanced libraries or papers. Telling a beginner who is wrestling with his first monad transformer stack that monads don't commute in general and they should check out extensible-effects really grinds my gears.
17:56:37 <iqubic> Anyone have a good Monad Transformer tutorial I can read/watch?
17:57:02 <iqubic> I'm fine with a textual thing, or a video tutorial.
17:57:38 <sm> mbwgh: I'm a bit lost
17:58:41 <mbwgh> iqubic: You should check out extensible- just kidding. I found the "Monad Transformers Step by Step" paper very helpful, as well as this gist : https://github.com/kqr/gists/blob/master/articles/gentle-introduction-monad-transformers.md
17:58:51 <mbwgh> sm: How so?
17:59:10 <sm> your complaint is multi-pronged and a bit unclear to me :)
17:59:34 <sm> basically haskellers are kind of diverse.. yes, certain subgroups are louder than others, that's just how it is
17:59:44 <iqubic> :t lift
17:59:46 <lambdabot> (Monad m, MonadTrans t) => m a -> t m a
18:00:37 <TipToP> Anyone Alive
18:01:12 <Rembane> Yes
18:01:16 <mbwgh> sm: Don't mind me. I'm just frustrated :)
18:01:35 <TipToP> Good most of these channels are dead
18:01:42 <sm> been there.. I hear you
18:02:02 <TipToP> Anyone familar with CyberArk
18:02:26 <TipToP> lol^
18:03:21 <sm> btw an hour-old haskell reddit post won't have a meaningful score yet
18:03:29 <sm> usually takes a day at least
18:04:13 <TipToP> whats a good channel to task a Pentester a few questions
18:04:23 <TipToP> An experienced one
18:06:05 <mbwgh> sm: Yeah I get that the world wasn't waiting for me to show up :) But if you write a question, carefully try to list pros & cons, things you have tried, etc. And in the end you mention that you would like to avoid introducing additional complexity by using another concept like free/operational monads (I wonder why I would write that). And then you get downvoted and the first comment suggests freer 
18:06:11 <mbwgh> monads... You know?
18:06:42 <sm> your question is long and complicated, maybe somebody misunderstood
18:06:59 <TipToP> you talking to me
18:07:08 <sm> and maybe the downvote was random. As somebody said, it fluctuates..
18:07:46 <sm> (stupid reddit)
18:09:29 <mbwgh> TipToP: I am not sure you're in the right place. This is a channel about the Haskell programming language.
18:10:21 <mbwgh> sm: Yeah I shouldn't overthink this. But as you said, my question is longish, and I initially intended not to whine, but to ask if there was room for improvement.
18:10:51 <sm> and yes! haskell attracts CS geeks who love to discuss advanced stuff. To ward them off you must ask carefully worded questions and wear garlic :)
18:11:09 <sm> see what comments come overnight
18:11:50 <mbwgh> Hey I got upvoted again!
18:11:57 <sm> some folks ask on stack overflow. I don't know which one gets better answers.
18:12:20 <worch> TipToP: look for some infosec channel, or maybe a channel specific to the domain e.g. #networking for networks
18:13:04 <mbwgh> sm: To be honest I am not quite sure why i asked on reddit instead of SO. I made that choice for my previous question half a year ago, but I forgot why. Maybe I thought reddit was more active.
18:13:25 <TipToP> Thank I just new this was a popular channel filled with geeks(like myself) figured id ask here 
18:13:31 <TipToP> thanks *
18:16:45 <sm> and furthermore, not to beat a dead horse, but that first answer seems nothing to complain about
18:17:39 <sm> you got some fast input from a highly experienced and helpful guy, be grateful ?
18:17:55 <worch> TipToP: #security might be what you're looking for
18:18:04 <TipToP> Ill give it a try 
18:20:13 <sm> mbwgh: also (just can't drop this can I.. so sorry :) have you tried IRC ? Sometimes you'll have more luck with some interactive discussion
18:21:15 <mbwgh> sm: That's why I chose not to comment on it yet, after having thought more thoroughly on it. But I did write that at least for this particular problem, I would like not to have to learn another library. I did talk about this here on #haskell yesterday, and I also tried to mention this.
18:22:10 <mbwgh> sm: Or rather that urged me to ask my question in the first place. I get the impression that on #haskell, simpler solutions are preferred, whereas you get a totally different impression if you only read blog posts or reddit threads.
18:22:56 <mbwgh> But both assertions are of course overly general.
18:23:05 <whoman> i find it helps to reduce the problem into boolean algebra first 
18:23:35 <mbwgh> You mean write an EDSL for sequent notation?
18:24:40 <sm> ooh, simpler preferred on #haskell ? I wouldn't take that bet :)
18:25:12 <sm> depends on time of day, phase of moon, sugar level of participants..
18:25:28 <mbwgh> sm: Yeah I did encounter the opposite as well? So you're using a TVar, eh? You should have a look at the machines library...
18:29:26 <pacak> asum [foo, bar, baz, ...] is not the same as foo <|> bar <|> baz <|> ....  :(
18:33:26 <lyxia> pacak: oh? infinite list?
18:34:25 <pacak> lyxia: On finite number of elements when failure contains meaningful info and all variants fail - when you parse stuff.
18:34:30 <pacak> @src asum
18:34:30 <lambdabot> Source not found. Maybe if you used more than just two fingers...
18:34:44 <pacak> asum = foldr (<|>) empty
18:36:06 <lyxia> pacak: because you don't have  x <|> empty = x  ?
18:36:54 <pacak> because asum [x] is not x when x fails
18:38:18 <lyxia> that's sad.
18:47:19 <mbwgh> I decided to have a look at the `freeer-effects` library. In this module: https://www.stackage.org/haddock/lts-9.11/freer-effects-0.3.0.1/Control-Monad-Freer-Coroutine.html it says "stability: broken". What does that mean?
18:48:43 <jle`> pacak: er wait, if you have a lawful Alternative instance, asum [x] = x
18:49:01 <sm> mbwgh: good question. It might be that it didn't build (on hackage) with latest GHC, as I see at https://matrix.hackage.haskell.org/package/freer-effects
18:49:29 <jle`> pacak: since asum [x] = x <|> empty = x
18:49:48 <pacak> Hmmm...
18:50:03 <jle`> if not, it breaks the laws
18:50:22 <pacak> > asum [Left "Either's Applicative instance is bad then."]
18:50:26 <lambdabot>  Left ""
18:50:49 <jle`> oh yes that is definitely an unlawful Applicative instance
18:51:11 <jle`> the real one should be asum (Left e1) (Left e2) = Left (e1 <|> e2)
18:51:12 <mbwgh> sm: I don't see anything on that page :/
18:51:40 <jle`> *unlawful Alternative instance
18:52:08 <jle`> * Left e1 <|> Left e2 = Left (e1 <> e2)
18:52:44 <sm> coloured table appears after a second here. javascript error ? maybe another browser ?
18:54:17 <mbwgh> sm: Even if I can't see it, looking at the repo https://github.com/IxpertaSolutions/freer-effects and especially the issues, it appears it isn't actively maintained at the moment :(
18:57:46 <jchia> Question about cassava: I already have "data Value = Value { foo :: Int, bar :: Double }" and I need to read Value rows from a CSV file with 3 (not 2) columns, where the first column is a key and the last 2 columns are the Value. I want to read rows with key matching some key value I specify. I don't think I can use cassava to read (Text, Value) generically and let it automatically sort out how to read the fields properly. I could define a "data Row = Row { key
18:58:29 <sm> mbwgh: quite possible
18:59:46 <mbwgh> sm: The developers actually say so here: https://github.com/IxpertaSolutions/freer-effects/issues/38
19:02:08 <jchia> ...define a "data Row = Row { key :: Text, foo :: Int, bar :: Double}" and how to copy from a Row to a Value, use cassava to read to a Row generically and then copy the Rows want projecting into Value. But that's quite verbose. Is there a better way?
19:09:21 <iqubic> Does a type of ListT IO a make any sense as a thing to do?
19:09:34 <iqubic> s/to do/to have/
19:11:46 <iqubic> :t ListT
19:11:47 <lambdabot> error:
19:11:47 <lambdabot>     • Data constructor not in scope: ListT
19:11:47 <lambdabot>     • Perhaps you meant ‘List’ (imported from Control.Lens)
19:12:08 <iqubic> Looks like ListT is not a thing lambdabot knows of.
19:15:39 <lyxia> jchia: using the (,,) triple type instead of Row would spare you a data and instance declaration
19:18:50 <lyxia> iqubic: yes, and it's called pipes or conduits nowadays.
19:19:59 <mbwgh> iqubic: ListT isn't used as often as, say, StateT or ReaderT. ListT and WriterT from the `transformers` package both come with their own problems. WriterT cannot work in constant space, meaning that it is possible to get a space leak even with the .Strict version. And ListT doesn't obey the monad laws. Like lyxia said, pipes /conduit is used for streaming stuff, and the former also exports a working ListT 
19:20:05 <mbwgh> implementation and comes with great documentation. The work-around for WriterT is to just use StateT instead.
19:21:00 <johnw> for simpler streaming needs, I really like the 'streaming' library
19:21:02 <mbwgh> iqubic: Alternative names for working ListT implementations are LogicT, ListT done right, and I believe SelectT from newer transformer versions.
19:22:32 <mbwgh> Or you can just YOLO it with mapM...
19:23:37 <iqubic> lyxia: Thank you for that.
19:24:02 <iqubic> I thought pipe and conduits were for server programming for some odd reason.
19:24:22 <johnw> they can be used for any sort of "chunk at a time" programming
19:24:27 <johnw> even in the browser, if you use ghcjs
19:25:47 <Praenomen> @pl (c==)
19:25:47 <lambdabot> (c ==)
19:26:02 <Praenomen> @pl (f (c==))
19:26:02 <lambdabot> f (c ==)
20:26:02 <heath> "Session types in Cloud Haskell" https://dspace.library.uu.nl/handle/1874/355676
20:26:19 <heath> https://github.com/Ferdinand-vW/sessiontypes-distributed
20:26:42 <heath> "If we could somehow allow for multi-party sessions, then we can session type the entire Cloud Haskell program instead of only two processes defined within that program."
20:28:44 <Welkin> wow, thanks for the link heath 
20:29:15 <heath> 👍
22:58:12 <jcarpenter2> anybody got a function that divides a list into buckets based on some property?
22:58:36 <jcarpenter2> bucket :: (Eq b) => (a -> b) -> [a] -> [(b, [a])]
22:58:39 <jcarpenter2> is what I want
22:59:15 <jcarpenter2> sorting a list into equivalence classes
23:01:22 <whoman> hoogle 
23:01:28 <jcarpenter2> no results found
23:01:38 <whoman> hmmm
23:03:09 <mud> jcarpenter2: I think that's uhm ...  map (f &&& id) . groupBy ((==) `on` f) . sortBy (comparing f)    if you're okay with an Ord constraint instead of an Eq one.
23:04:14 <jcarpenter2> Ord is fine
23:05:33 <mud> I screwed up the map path, more    map (f . head &&& id)
23:09:27 <jcarpenter2> okay, that makes sense
23:09:28 <orzo> if you mark a class member as INLINE, but then pass it to a polymorphic function that uses the instance method without knowing the exact type, are you forcing ghc to specialize the function?
23:13:05 <jcarpenter2> map (f &&& id) . groupBy ((==) `on` f) . sortBy (comparing f) even
23:13:10 <jcarpenter2> lol
23:13:12 <jcarpenter2> -even
23:13:17 <Axman6> there's also some cool SQL like syntax for list comprehensions with an extension
23:13:32 <jcarpenter2> i mean: map (f &&& id) . groupBy ((==) `on` f)
23:14:00 <Axman6> groupBy doesn't group together all values with the same value, it groups consecutive values
23:14:32 <Axman6> > groupBy (<) [1,2,3,4,3,2,1,2,3,4,5,3,2,1,0]
23:14:34 <lambdabot>  [[1,2,3,4,3,2],[1,2,3,4,5,3,2],[1],[0]]
23:15:43 <jcarpenter2> > groupBy id [1,2,3,4,3,2,1,2,3,4,5,3,2,1,0]
23:15:46 <lambdabot>  error:
23:15:46 <lambdabot>      • Occurs check: cannot construct the infinite type: a ~ a -> Bool
23:15:46 <lambdabot>        Expected type: a -> a -> Bool
23:16:05 <jcarpenter2> > groupBy (==) [1,2,3,4,3,2,1,2,3,4,5,3,2,1,0]
23:16:07 <lambdabot>  [[1],[2],[3],[4],[3],[2],[1],[2],[3],[4],[5],[3],[2],[1],[0]]
23:16:31 <jcarpenter2> i see
23:16:53 <Axman6> https://downloads.haskell.org/~ghc/6.10.2/docs/html/users_guide/syntax-extns.html#generalised-list-comprehensions might be useful
23:16:57 <MarcelineVQ> though above you did sort beforehand
23:17:10 <MarcelineVQ> > groupBy (==) (sort [1,2,3,4,3,2,1,2,3,4,5,3,2,1,0])
23:17:12 <lambdabot>  [[0],[1,1,1],[2,2,2,2],[3,3,3,3],[4,4],[5]]
23:17:47 <Axman6> yeah, I was pointing that out because the sort is important
23:17:52 <joebetz> Frandkey91
23:18:17 <Axman6> might wanna go change that joebetz
23:18:20 <mud> When you're doing groupBy it's fairly important you be careful what you're sorting by as well. Pretty easy to get that wrong.
23:18:20 <joebetz> gah, wrong window
23:26:47 <jcarpenter2> > pl \f -> map (f . head &&& id) . groupBy ((==) `on` f) . sortBy (comparing f)
23:26:50 <lambdabot>  <hint>:1:4: error: parse error on input ‘\’
23:27:11 <jcarpenter2> > pl \x y -> x y
23:27:13 <lambdabot>  <hint>:1:4: error: parse error on input ‘\’
23:27:37 <mniip> it's @pl
23:27:47 <mniip> and no >
23:28:07 <jcarpenter2> @pl \f -> map (f . head &&& id) . groupBy ((==) `on` f) . sortBy (comparing f)
23:28:08 <lambdabot> ap ((.) . map . (&&& id) . (. head)) (ap ((.) . groupBy . ((==) `on`)) (sortBy . comparing))
23:28:20 <jcarpenter2> nice
23:31:16 <erisco> jcarpenter2, you may be interested in a function that I have dubbed "gang"
23:31:32 <jcarpenter2> erisco: what's that?
23:35:00 <erisco> I sent this letter to the author of list-extras but could not get the mail delivered
23:35:09 <erisco> now this function is squarely in limbo
23:35:18 <erisco> here is the implementation, anyways http://lpaste.net/359821
23:36:17 <jcarpenter2> oh lovely
23:38:35 <erisco> and if you have a similar situation but without labels, then group from http://hackage.haskell.org/package/base-4.9.0.0/docs/Data-List-NonEmpty.html may help
23:39:56 <erisco> it recognises that groups are non-empty, so the later map to a 2-tuple is unnecessary
23:40:12 <jcarpenter2> oh cool
23:40:48 <erisco> another possible type for gang is (Eq a, Foldable t) => t (a, b) -> [(a, NonEmpty b)]
23:42:50 <|{ame> hello, what is the closest thing to a c++ std::map in haskell?
23:43:07 <erisco> maybe Data.Map.Strict
23:44:02 <|{ame> thank you!
23:44:14 <|{ame> it's exactly what I wanted
23:45:06 <erisco> jcarpenter2, there is also a little fun with strictness in the implementation of gangBy, to make it as nonstrict as group is
