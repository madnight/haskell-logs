00:00:34 <AliasSpider> no
00:01:27 <taktoa> is there a pre-existing commonly used type isomorphic to (a -> m b, b -> m a) for some Monad m
00:01:40 <taktoa> like some kind of kleisli Iso
00:02:01 <dminuoso> Okay this is interesting. Parametricity guarantees that for any two functors there exists a natural transformation between them?
00:02:09 <dminuoso> (In Haskell)
00:04:49 <taktoa> ah, just needed a bit more type tetris: `Control.Lens.Iso a (m a) (m b) b ~ (a -> m b, b -> m a)`
00:21:42 <ertes-w> ello
00:40:33 <dminuoso> https://gist.github.com/dminuoso/c58de671e131856fbcdc0b68bab1f99f
00:40:43 <dminuoso> What bizarre rule makes Haskell default to Integer?
00:41:08 <codeshot> Tuplanolla, I was thinking more about the category of Haskell, in terms of implementing the typed lambda calculus
00:41:34 <codeshot> I realised there's two categories involved, and one is not an embedding in the other
00:42:10 <dmwit> dminuoso: https://stackoverflow.com/q/32496864/791604
00:42:16 <codeshot> In one category, which I think people call "Hask", types are objects and values (including functions) are morphisms
00:44:06 <codeshot> In the other category, values are objects and I'm not entirely certain what are the morphisms - it's not exactly a thunk that's a morphism but it's close
00:45:43 <dmwit> koz_: Generate all the swaps as ST actions, then use `modify` as before to apply those swaps all at once to the vector. You will need `newtype Action a = Action (ST s a)` or similar to preserve the full polymorphism of the reads and writes in your swaps.
00:45:52 <AliasSpider> ok/ Ĉ
00:46:06 <codeshot> Tuplanolla, Our lambda expressions describe a morphism in Hask -- \x -> 1 + x :: Int -> Int -- for example
00:46:12 <koz_> dmwit: I already figured it out. Thanks!
00:46:37 <dmwit> The vector package has at least three different modules that define the name MVector. =(
00:46:41 <dmwit> This is terrible API design.
00:47:00 <EvanR> theres even more Vectors
00:47:04 <codeshot> but then once it's being executed it's in another category where the values are objects
00:47:23 <EvanR> and that one guy named literally every type in sight T
00:47:39 <EvanR> disambiguated by modules, which have names
00:47:46 <dmwit> Yeah, but at least the module names in his packages are descriptive.
00:47:50 <AliasSpider> no
00:48:11 <athan_> Could extensional equality be pushed to differentiable lambdas? Like, a function over differentials vs differentiably applying a value to a function. Asking for a friend
00:48:30 <dmwit> AdditiveRing.C vs Monoid.C is totally memorable (provided you know what a ring and a monoid are). But quick! Which MVector is the one in Data.Vector.Generic.Mutable.Base and which is the one in Data.Vector.Mutable?
00:49:21 <EvanR> its not a rexporting?
00:49:26 <dmwit> noooope
00:49:49 <EvanR> i never understood vector package entirely
00:50:01 <AliasSpider> ร
00:50:35 <EvanR> AliasSpider you're making me uncomfortable now
00:50:50 <LiaoTao> EvanR: It's likely a bot
00:50:52 <AliasSpider> 랕
00:50:53 <LiaoTao> Already banned from ##math
00:51:24 --- mode: ChanServ set +o dmwit
00:51:28 <AliasSpider> why?
00:52:35 <dmwit> AliasSpider: Do you have anything substantive to contribute?
00:53:23 <jason85> What are the advantages and disadvantages of using infix notation instead of prefix notation?
00:53:45 <dmwit> jason85: Aesthetics only.
00:53:55 <dysfun> jason85: well, infix looks more like math that we're used to, prefix requires less parsing
00:53:56 <dminuoso> jason85: prefix notation is usually a bit more expressive if you consider currying, and `infix` more expressive for applying two arguments in a row.
00:53:58 <AliasSpider> thx
00:54:09 --- kick: AliasSpider was kicked by dmwit (AliasSpider)
00:54:22 --- mode: dmwit set -o dmwit
00:54:27 <EvanR> unless you have a single associative operator, prefix notation gets old really fast
00:54:37 <EvanR> if you do, you can factor it all out like lisp +
00:54:43 <dminuoso> jason85: At least for some anyway. For example if I just care about lifting a function I use `fmap`, and I want to lift and apply, I use <$>
00:54:48 <dysfun> *shrug* i write a lot of lisp and i don't mind prefix notation
00:55:04 <ventonegro> dysfun: +1
00:55:04 <EvanR> imaging mixing , and grouping in
00:55:15 <EvanR> [[h,0,0,0],[h,0,0,m],[h,0,0,h],[h,0,0,h]]
00:55:36 <EvanR> here , can be considered a prefix operator
00:55:40 <EvanR> er infix
00:55:43 <dysfun> in fact the only thing i've come to learn about syntax is that it doesn't matter that much
00:56:05 <EvanR> but yeah its entirely a human cultural thing
00:56:46 <dysfun> i *like* infix syntax, but i *like* powerful macros
00:57:06 <dysfun> i mean i suppose we have template haskell, but nobody likes TH
00:57:06 <ventonegro> Scheme is still the best in the syntax department. No crazy indentation offset rules, just the code. Ah, and macros. But yeah, kinda subjective...
00:57:27 <EvanR> really
00:57:32 * dysfun has done 5 years of clojure, i prefer it
00:57:51 <EvanR> so you would rather program using just haskell algebraid data syntax :)
00:58:30 <dysfun> hah, actually my pet language doesn't have ADTs as such, it has ad hoc unions and data constructors that are nonalgebraic
00:58:54 <EvanR> (ignoring for the moment haskell has infix ctors)
00:59:22 <dysfun> but i like code as data, so describing everything as a big data structure is great
00:59:43 <Guest91429> Regarding code as data, are there any plans to bring hygienic macros to haskell?
00:59:48 <dysfun> and let's not talk about the fusion nasties we have to do to make that efficient ;)
01:00:04 <dmwit> I find that laziness plays a similar role to macros in many of the common use-cases for macros.
01:00:05 <EvanR> its about pretty vs structurally nice
01:01:43 <dysfun> yes, quite often macros are just used to suppress evaluation, not a problem we have with laziness
01:01:43 <EvanR> 2017-11-15 vs an (, x (, y (, z nil))) where x y and z are some expansion of the numbers in terms of their prefix constructors
01:02:16 <ventonegro> EvanR: ?
01:02:30 <EvanR> concrete syntax is an extension of pretty printing
01:02:46 <EvanR> your brain wants to see something brainwashed into you from school
01:03:05 <ventonegro> I'm afraid I lost you
01:03:06 <EvanR> no matter how little sense it makes to the computer
01:03:16 <dysfun> if i ever have a kid, i'm going to brainwash them into doing math in lisp
01:03:22 <EvanR> ;_;
01:04:04 <dysfun> or forth
01:04:07 <EvanR> i am saying its not limited to the large scale syntax of the language
01:04:24 <dysfun> 1 2 3 4 5 6 7 + / - * / + -
01:04:34 <LiaoTao> I'll train mine to use underscores instead of spaces
01:04:54 <LiaoTao> That way he won't ever use windows file names under *nix
01:05:00 <ertes-w> ventonegro: scheme's syntax is appealing, until you start actually using it…  then you're gonna use indentation to keep it readable, which makes the parens redundant
01:05:21 <EvanR> your editor does the indentation for you
01:05:33 <dysfun> ertes-w: however, whitespace sensitive languages are more prone to accidental breakage during edit
01:05:37 <ventonegro> ertes-w: That's plainly false because I used it a lot and it's still appealing.
01:06:10 <codeshot> AliasSpider failed the turing test while so many other mathematicians manage to pass it lol
01:06:22 <dysfun> this is actually an area where C does very well, the {} is unambiguous during a refactor
01:06:28 <ertes-w> ventonegro: sure, it's a matter of taste…  i just don't like redundancy in syntax, and scheme really makes me use something like paredit to keep my parens consistent
01:06:50 <dysfun> ertes-w: clojure's less bad, it's a lot less paren-heavy
01:07:07 <EvanR> the more redundant things you must type, the more likely its right!
01:07:11 <EvanR> (at a cost)
01:07:18 <ertes-w> perhaps…  i haven't used clojure for anything real
01:07:23 <ventonegro> ertes-w: Yes, I also use paredit, which is a big plus, right?
01:07:43 <EvanR> i started using paredit for haskell
01:07:45 <dysfun> i never persisted with paredit long enough
01:07:46 <codeshot> EvanR, we need a language based on ECC
01:07:48 <ertes-w> ventonegro: i didn't really *use* paredit more than i *had to* use it
01:08:05 <EvanR> codeshot: right
01:08:06 <dysfun> the problem is unless you have a printed shortcut list you have to exit paredit to fix things occasionally
01:08:14 <ertes-w> paredit gets me to a state where i can edit lisp as quickly as something like haskell
01:08:17 <EvanR> full multi redundancy is technically a waste
01:08:21 <ventonegro> "Let me move this whole if-expression which takes 5 lines one level up..."
01:09:10 <codeshot> So we can target the ideal redundancy for the number of mistakes we will accept in our code
01:09:12 <dysfun> what i want for christmas is a haskell indentation mode that does what i want
01:09:32 <dysfun> codeshot: yes, by simply picking a language carefully
01:09:33 <ertes-w> ventonegro: that's just deleting a rectangle of spaces with haskell, which emacs has a command for
01:09:49 <dysfun> e.g. java is very much in the 'constantly assert in types' mindset
01:10:06 <codeshot> like a kid picks up a kitten so tenderly before placing it very precisely into a bag of rocks?
01:10:31 <ventonegro> ertes-w: Not if the if starts in the same line as another expression
01:11:32 <ertes-w> ventonegro: again, it's a matter of taste, so this discussion is pointless…  i use layout anyway, so might as well make the layout meaningful and not have to have extra characters
01:11:36 <codeshot> Or a 1970s doctor so carefully selects Primodos for an expectant mother: http://www.independent.co.uk/news/uk/home-news/new-evidence-pregancy-drug-hormone-birth-defects-primodos-thalidomide-compensation-yasmin-qureshi-a7637616.html
01:11:36 <codeshot> careful is not enough
01:11:54 <ertes-w> ventonegro: if you want to do something like that in haskell, there is structured-haskell-mode, which is a paredit equivalent for haskell, but i didn't like it
01:11:58 <EvanR> youre all wrong! ascii source code is ancient stone age tech!
01:12:03 <dmwit> dysfun: FWIW, I find preserveindent+autoindent is generally 0-1 keypresses per line away from what I want.
01:12:08 <ventonegro> ertes-w: True, there is no final answer to these questions
01:12:20 <dysfun> dmwit: hrm, i'll try that, thanks
01:12:36 <codeshot> EvanR, but when we try to use steel tools our other equipment all breaks into pieces
01:12:45 <ertes-w> (for a rather ridiculous reason: it has this horrible list/tuple/record syntax harcoded, where you start lines with commas)
01:12:55 <EvanR> i still dont understand why
01:13:13 <EvanR> is that a problem with the source code or the other tools
01:13:21 <EvanR> or the whole universe
01:13:26 <codeshot> editors, knowledge of unicode names for charaters
01:13:33 <codeshot> diff tools
01:13:37 <codeshot> search tools
01:13:41 <ertes-w> if structured-haskell-mode gave me the freedom to use my own style, i would probably use it
01:13:56 <codeshot> (regex search is a bitch on unicode so we all just do it wrong and look all pleased with ourselves)
01:14:05 <EvanR> i was thinking of the "fungibility" of various gimmicks we use
01:14:18 <EvanR> source code, CSV, json, ...
01:14:29 <codeshot> In gasworks they never use steel, only copper and bronze
01:15:20 <EvanR> i dont really see unicode as an improvement fundamentally 
01:15:30 <EvanR> for the issue of technical text data
01:15:51 <EvanR> its still a linear sequence of characters
01:16:53 <EvanR> we need a begriffschrift package
01:18:50 <codeshot> EvanR, whole universe
01:19:13 <EvanR> so the only answer is to flush it down a black hole
01:19:15 <ertes-w> EvanR: unicode is just an association between numbers and specific characters or modifiers
01:19:25 <codeshot> EvanR who says we're not already there?
01:19:47 * codeshot looks behind himself and sees the future
01:20:41 <ertes-w> EvanR: would you rather go back to individual "codepages" for each language?
01:20:53 <EvanR> for prose its great
01:21:18 <EvanR> but its not advancing beyond ascii for data
01:21:26 <EvanR> or formal language
01:21:51 <EvanR> your programming language of choice is a formal language isnt it
01:21:58 <ertes-w> unicode isn't about text, layout or grammar…  it only knows characters
01:22:02 <codeshot> ertes-w, for japanese I think people are still using shift-jis
01:22:10 <EvanR> well unicode does deal with layout too
01:22:16 <codeshot> unicode doesn't know characters
01:22:43 <EvanR> the standards refer to characters among other things, but doesnt really define it
01:22:43 <tdammers> it does, but it carefully avoids the word, because 'character' means different things to different people in different situations
01:22:57 <codeshot> it only knows codepoints
01:23:00 <tdammers> so it talks about 'code points', 'glyps', etc. instead
01:23:08 <codeshot> although there is *some* characteriness
01:23:17 <ertes-w> it's not unicode's job to lay out paragraphs of text on a 2D space
01:23:25 <ertes-w> that's what you build on top of unicode
01:23:33 <tdammers> unicode definitely knows more than just code points, on both sides
01:23:39 <EvanR> part of that is defined in unicode
01:23:50 <EvanR> since some languages are totally wrong without layout
01:23:54 <codeshot> it has diacritics
01:24:03 <ertes-w> it also knows direction
01:24:05 <codeshot> so any codepoint can be used in many characters
01:24:17 <tdammers> 'below' code points, unicode defines encodings and such
01:24:47 <codeshot> tdammers, true
01:24:52 <codeshot> got to go, bye
01:24:56 <EvanR> theres a simplified version of unicode we would rather have, and we can have it by reading each section about "a unicode application may do ... but doesnt have to" as "ok i wont"
01:25:11 <tdammers> 'above' code points, unicode defines semantics for code points, how to combine them into meaningful units, how to normalize sequences of code points, and even, in part, how to render them and how to lay them out in flow text
01:25:51 <ertes-w> you have a bunch of space widths, and there is even a code point that flips the text direction, but that's about the furthest you can go in terms of encoding layout
01:26:02 <tdammers> text direction, spacing, combining diacritics, character substitutes, normalization, equivalency, etc.
01:26:20 <ertes-w> for example i see no issue with using unicode with latex to render very complicated formulas
01:26:20 <earthy> collation rules...
01:26:38 <EvanR> why are we talking about layout
01:27:07 <EvanR> i guess thats how it started
01:27:46 <ertes-w> this is what i was responding to: <EvanR> i dont really see unicode as an improvement fundamentally <EvanR> for the issue of technical text data <EvanR> its still a linear sequence of characters
01:28:09 <EvanR> rather than a tree (?) of structured data
01:28:19 <EvanR> adhering to a formal language
01:28:30 <ertes-w> why would you encode that tree on the level of unicode?
01:28:47 <EvanR> why would you encode it on the level of ascii?
01:28:56 <ertes-w> i wouldn't
01:29:00 <EvanR> exactly
01:29:13 <ertes-w> i would use unicode for representing text and then a level above that for representing structure
01:29:29 <EvanR> we should forgot all that and just have the structure
01:29:46 <EvanR> you can kind of do that in lisp
01:29:58 <EvanR> but they are still using ascii
01:30:08 <tdammers> ascii or unicode is a detail
01:30:22 <EvanR> an array of chars
01:30:40 <tdammers> both are conceptually arrays of some enum
01:31:06 <ertes-w> lisp is a level above that
01:31:21 <EvanR> if you take the 80 col line seriously, its a rectangular matrix!
01:31:39 <tdammers> yes, but it doesn't really matter whether you implement lisp syntax on top of ascii or unicode
01:31:48 <EvanR> no
01:32:09 <EvanR> but we havent managed to forget about the array
01:33:15 <tdammers> right, but that's because that's how our current OS paradigms work - *all* the data we can feed into our compiler or interpreter has to be a linear stream of bytes at some point
01:33:21 <ertes-w> lisp is defined in terms of text…  of course you use "arrays" (sequences)
01:33:50 <EvanR> i would have found lisp much easier to understand if it was defined in terms of expressions
01:33:57 <ertes-w> feel free to define something like lisp, where words are something other than text, and then it makes sense not to use unicode
01:34:18 <tdammers> ertes-w: most of lisp actually doesn't care about the array representation; s-expressions are fundamentally tree-shaped, the textual representation isn't all that important
01:35:08 <ertes-w> lisp is fundamentally just this:  data SExp a = Word a | Paren [a]
01:35:31 <ertes-w> and you're basically complaining that we use a = ByteString all the time…  well, feel free to use something else
01:35:44 <EvanR> the linear stream of bytes is fungible, but not for any fundamental reason, thats just what we did
01:36:05 <EvanR> you build things on top of it, and the various implementations of that stream exist in a bunch of weird forms we dont care about
01:36:20 <EvanR> 256-QAM etc
01:36:21 <ertes-w> err
01:36:32 <ertes-w> data SExp a = Word a | Paren [SExp a]
01:38:12 <EvanR> its such a good abstraction that many people think its real 
01:38:46 <EvanR> ok its too early in the morning for such irony
01:39:26 <tdammers> the linear memory layout *was* real for quite a while
01:40:29 <EvanR> not necessarily of bytes though
01:40:32 <tdammers> and even when it wasn't, it was the simplest possible interface to the various incompatible memory layouts out there that you could possibly come up with
01:40:43 <tdammers> no, not bytes; machine words
01:40:51 <EvanR> heh, 7-bit protocols
01:41:33 <tdammers> 7 bits is the lowest common denominator for machine words, that's why ASCII is 7-bit
01:42:32 <tdammers> all machines at the time had at least 8 bit words, either signed or unsigned, so 7 useful bits aligned on 8-bit boundaries was a reasonable choice
01:43:41 <tdammers> and then unix and C happened and basically cemented these choices into the holy scriptures of programming and OS design
01:43:56 <EvanR> so i am speaking blasphemy
01:44:12 <EvanR> my work is done
01:46:56 <tdammers> not really
01:47:26 <tdammers> questioning the choice for "linear stream of bytes" as the fundamental data model for everything is perfectly reasonable
01:47:47 <ertes-w> unfortunately unix and C made sense back then, but we never really evolved past them…  not far anyway
01:49:03 <EvanR> i can easily see a particular sum type, whatever it may be, engineered to pass through a wireless channel or fiber channel
01:49:36 <EvanR> but maybe not as fast as numbers mod 2^something
01:53:40 <ertes-w> i see no reason not to encode data as a list of bits
01:53:58 <ertes-w> … until we get quantum computers
01:54:12 <EvanR> because a list of bits is a crap format
01:54:26 <ertes-w> what would be a better format?
01:55:00 <EvanR> a simply typed lambda calculus program that produced those bits!
01:55:12 <EvanR> or whatever the case may be
01:55:24 <ertes-w> and how exactly do you send such a program through a wire that really only understands "on" and "off"?
01:55:49 <EvanR> at least coax cable dont understand on and off
01:56:12 <EvanR> theres a dense complex of radiation zipping to and fro
01:56:29 <Athas> The universe is (usefully) three-dimensional, so the most natural format would be a grid of bits.
01:56:50 <EvanR> an evenly distributed sphere of bits
01:56:56 <Athas> Yes!
01:57:00 <EvanR> lol
01:57:12 <Athas> A stream of bits is merely an inefficient projection of the most innately efficient representation.
01:58:51 <EvanR> a function from S^2 -> Bool can only be const True or const False, so i think were on the right track
02:00:05 <ertes-w> EvanR: i think you're severely confusing levels of representation…  there is no reason not to encode a stream of bits as a STLC expression and then encode that expression as a list of bits to send through the wire
02:00:25 <ertes-w> unless you come up with a new communication device that supports something other than a stream of bits
02:00:30 <EvanR> but its not a fundamental thing
02:00:51 <EvanR> stream of bits is just another abstraction
02:00:56 <ertes-w> it kinda is…  the bit is the smallest discrete unit of information
02:01:29 <EvanR> actual devices will use whatever is more efficient, like QAM
02:02:47 <ertes-w> well, almost all of our hardware is clocked and stores/transmits information as a list/stream of bits
02:02:57 <EvanR> you can get 1/2 a bit of information
02:03:18 <EvanR> no thats the API
02:03:22 <ertes-w> at least that's the interface visible to us
02:03:53 <ertes-w> how do you even represent half a bit of information discretely?
02:04:19 <EvanR> you dont represent information
02:04:25 <EvanR> youre talking about data
02:05:37 <EvanR> the smallest unit of data would be, besides zero i guess, the ... unit data () = ()
02:07:33 <EvanR> if you turn the tone transmitter on, someone detects it, they get message with payload (). turn it off, they get another
02:10:54 <ertes-w> EvanR: "information" and "data" are the same thing to me
02:11:08 <EvanR> the 1/2 bit information comes from information theory
02:12:37 <EvanR> if you sent 1k of 1s or 0s always, people arent getting more information than 1 bit
02:12:42 <taktoa> anyone know what's going on in http://lpaste.net/360059
02:13:40 <taktoa> (I've tried enabling AllowAmbiguousTypes, but that just defers the error elsewhere, so I suspect the problem is there)
02:16:19 <osa1> you need `Ord (ThreadId m)` constraint
02:16:56 <taktoa> osa1: MonadConc has (Ord (ThreadId m)) as a superclass
02:16:58 <taktoa> http://hackage.haskell.org/package/concurrency-1.2.0.0/docs/Control-Monad-Conc-Class.html#t:MonadConc
02:17:01 <osa1> ah
02:17:26 <taktoa> (and I already tried that anyway)
02:18:11 <osa1> what happens if you replace `fromMaybe` with a case expression?
02:18:55 <taktoa> osa1: I can define the function as `lookupVC tid m = 0` and it gives the same error
02:19:40 <EvanR> whats the use of scoped type variables there
02:19:51 <taktoa> just for the explicit forall
02:20:09 <taktoa> removing the explicit forall doesn't change the error
02:21:04 <EvanR> ok
02:21:08 <EvanR> injectivity
02:21:40 <EvanR> you arent passing in a value of type monad, so for a given use case of this function, with just threadIds, like Int, it has no way to know what instance you want
02:21:53 <EvanR> since ThreadId is not necessarily injective (invertible)
02:22:28 <EvanR> two MonadConcs may have the same thread ID type
02:22:29 <osa1> isn't `MonadConc.ThreadId monad` or the map argument enough to know what instance you want?
02:22:33 <taktoa> oh so I need a witness to that monad type
02:22:36 <EvanR> no
02:22:50 <EvanR> the function only uses the thread IDs
02:23:18 <EvanR> but if you use AllowAmbiguousTypes you might be able to fix it up at the use site
02:23:24 <EvanR> i dont know how though
02:23:53 <EvanR> but yeah try to include a proxy
02:25:36 <taktoa> EvanR: would it be possible to make an injective data family that wraps the threadid type or something like that
02:26:01 <EvanR> i have heard of injective families but i dont know how they work or what they can accomplish (though the name sounds promising)
02:26:28 <EvanR> it only has a chance of working if you plan on using a custom type for the thread ID
02:27:02 <taktoa> all I really care about is that the thread ids have an Ord instance, they are totally abstract otherwise
02:27:20 <EvanR> unfortunately thats not enough for instance selection to work
02:27:35 <taktoa> excellent, the Proxy fix worked
02:27:49 <EvanR> which is silly since you arent even using functionality from MonadConc there
02:28:04 <EvanR> (so why is it in the sig)
02:28:32 <osa1> ah it makes sense. there's no value of type `monad` here.
02:28:46 <EvanR> yeah
02:29:10 <EvanR> but ... are you really trying to put a type on lookupVC tid m = fromMaybe 0 (Map.lookup tid m)
02:29:39 <EvanR> shouldnt that be lookupVC :: Ord a => a -> Map a Int -> Int
02:30:10 <EvanR> alternatively, delete the signature?
02:30:15 <taktoa> well that type was the result of type alias expansion
02:30:22 <taktoa> there's a VC type alias over Map in my code
02:30:32 <EvanR> oh
02:30:33 <taktoa> and I figure that I might want to replace it with a newtype later
02:31:14 <EvanR> er, if the Map is the result of an expansion... how is that code polymorphic... the explicit Data.Map.lookup
02:31:28 <EvanR> nevermind im asking too many questions
02:32:12 <taktoa> EvanR: I'm writing an API that _looks_ like that of an abstract datatype, except the type happens to be a type alias for something concrete
02:32:44 <taktoa> instead of the usual thing where you define a datatype and don't expose the constructors
02:33:07 <taktoa> anyway yes, MonadConc is a stronger constraint than necessary, Ord (MonadConc.ThreadId monad) would suffice
02:33:49 <taktoa> though `MonadConc.ThreadId monad` is a stuck type family when `MonadConc monad` isn't derivable, so I'm not really losing anything
02:34:42 <EvanR> leaving only Ord (ThreadId monad) => would confuse me
02:35:13 <EvanR> if you delete the sig, the truth will be told on :t
02:36:57 <taktoa> EvanR: I'm _intentionally_ making this interface more monomorphic than the code it is defined by, so that it is easier to create an abstraction boundary later
02:37:55 <EvanR> that seems backwards, but ok
02:38:24 <EvanR> zzzzz
02:40:37 <taktoa> the point is that in the future I may change the API so that you cannot do any Map-like operation with a VC (e.g.: by switching it to a newtype)
02:40:50 <taktoa> this newtype will be monomorphic (except for the monad parameter)
02:41:06 <taktoa> therefore I would have to monomorphize all the code when I do that change
02:41:17 <taktoa> I can avoid that work by writing the code in a monomorphic way to begin with
02:48:25 <ertes-w> what's MonadConc?
02:48:35 <ertes-w> i've seen it mentioned a few times now
02:49:18 <Taneb> ertes-w: the one in dejafu?
02:49:33 <Taneb> ertes-w: http://hackage.haskell.org/package/concurrency-1.2.2.0/docs/Control-Monad-Conc-Class.html#t:MonadConc
02:49:39 <Taneb> It's part of a concurrency verification suite
02:50:10 <ertes-w> ah
02:51:08 <ertes-w> it's that really just a super-awkward form of MonadBaseControl?
02:51:55 <Taneb> Basically, if you express your concurrent code using MonadConc m => m a rather than IO a, you can get a bunch of concurrency testing stuff
02:52:32 <Taneb> ertes-w: barrucadu is the one to ask, he's the author of dejafu
02:52:35 <ertes-w> why isn't IO good enough?  is there a rank-2 type involved somewhere?
02:53:07 <taktoa> ertes-w: ConcST is an instance of MonadConc
02:53:10 <barrucadu> ertes-w: IO isn't good enough because you can't break apart and inspect IO actions to see, eg, "this is a readMVar"
02:53:36 <ertes-w> ah, i see
02:54:30 <ertes-w> that's why you need MonadConc with all the concurrency actions explicitly listed
02:54:32 <barrucadu> The testing implementation has a sum type for various primitives and is built up out of continuations, so it can then try out different schedules
02:54:35 <barrucadu> Yeah
02:54:45 <ertes-w> makes sense now, thanks
02:55:07 <barrucadu> I suspect if I were starting it from scratch now, rather than two years ago, I'd have a look at backpack for this
02:55:54 <taktoa> barrucadu: btw, what do you think about making ThreadId et al. data families rather than type families?
02:56:36 <barrucadu> taktoa: COuld be reasonable. I picked type families because I didn't (and still don't) know anything about data families
02:57:12 <taktoa> my understanding of data families is that instead of creating a type alias per instance like type families, they create a data definition per instance
02:57:38 <taktoa> which means that a data family is necessarily injective, I think
02:57:58 <barrucadu> Ahh, that could be a help
02:58:41 <barrucadu> `peekTicket' :: proxy m -> Ticket m a -> a` in MonadConc is like that because `Ticket` isn't injective so the `m` needs to be supplied somewhere
03:02:59 <taktoa> barrucadu: btw, thanks a lot for `concurrency`/`dejafu`, I think it will help a lot on this actor model concurrency / vector clock / distributed snapshot project I'm working on for my concurrent programming language theory class
03:03:20 <dysfun> concurrent programming language theory is a whole class now?
03:03:54 <Athas> Why wouldn't it be?
03:04:14 <Athas> You could spend an entire class just on CSP, let alone the traditional semaphore-based synchronisation tricks.
03:04:16 <taktoa> dysfun: it's taught by the guy who first formalized actor semantics in Carl Hewitt's research group
03:04:25 <dysfun> cool!
03:04:34 <sbrg> we had a class called "concurrent programming"
03:04:36 <barrucadu> taktoa: Great!  I'm just happy that some people are actually using it
03:04:42 <sbrg> it was a travesty, and used Java and a book from the early 00s
03:05:07 <sbrg> pretty sure they took it behind the shed and put it out of its misery, but not before I had to endure it :( 
03:05:29 <dysfun> so the university i almost went to dropped their haskell course the year i was set to start
03:05:35 <dysfun> in favour of more java
03:05:40 <taktoa> yikes
03:05:45 <LiaoTao> Disgusting
03:06:07 <taktoa> the first semester they started using haskell in the PLT course at my school happened to be the semester I took it
03:06:24 <taktoa> (the required undergraduate PLT course, to clarify)
03:06:36 <sbrg> the first semester I was able to take haskell, it was almost dropped because they didn't have a haskell dude to TA it. so I TA'd the class while I was taking it :o
03:06:43 <taktoa> lol
03:06:47 <sbrg> that was kind of weird
03:06:49 <ertes-w> taktoa, barrucadu: you can use TypeFamilyDependencies to get the same effect while still being able to use the underlying types directly without wrappers
03:07:02 <ertes-w> so with IO you can use ThreadId
03:07:32 <taktoa> ertes-w: yeah, but I suspect that a data family is preferable anyway, since ThreadId is meant to be abstract
03:07:50 <taktoa> idk that much about data families though, so I might be wrong
03:08:30 <ertes-w> it doesn't really make much of a difference, unless you specifically want to hide the underlying ThreadId…  i wouldn't do that though
03:08:57 <ertes-w> effectively it just makes implementing the IO instance easier
03:11:28 <quchen> Is it a good idea to use »unsafeInterleaveIO . wait =<< async <action>«?
03:11:52 <quchen> Fork immediately, but trigger waiting only if the value is demanded, leading to a non-blocking wait
03:13:03 <ertes-w> quchen: why don't you just pass the Async itself around?  or an action to wait?
03:13:11 <ertes-w> wait <$> async c
03:14:12 <ertes-w> (also you should probably use withAsync anyway)
03:14:22 <quchen> ertes-w: When I trigger wait, I have to, well, wait. I don’t want to do that, I want the result of the wait available as a pure value, possibly at a later point in time.
03:14:44 <quchen> Use case: querying multiple webservices, where some depend on others.
03:15:23 <quchen> I just want to fork all the things, and then trigger the waiting when the data is required, so I don’t have to care about ordering or prematurely blocking things.
03:15:51 <mlehmk> I don't think you block by using wait in Haskell
03:16:09 <quchen> Sure, wait waits for the async to return a result
03:16:10 <ertes-w> quchen: well, you get the usual lazy I/O problem
03:16:14 <mlehmk> it is just the the current flow of execution is suspended and other flows continue
03:16:50 <mlehmk> thinking synchronous, where async is first class in Haskell, isn't it?
03:16:55 <quchen> Nope, wait blocks the executing thread
03:17:05 <quchen> async is an ordinary IO action
03:17:12 <quchen> async :: IO a -> Async a
03:17:17 <mlehmk> it'd susprise me if wait actually blocks the executing thread
03:17:32 <ertes-w> mlehmk: then be prepared to be surprised
03:17:42 <mlehmk> okay, wow!
03:17:51 <ertes-w> 'wait', as the name implies, waits for the thread to finish
03:18:06 <quchen> mlehmk: unsafeInterleaveIO . wait <- does not block
03:18:35 <quchen> The price is having lazy IO of course. But I can’t come up with a reason not to do that.
03:18:42 <quchen> I should re-read the dangers of lazy IO.
03:18:49 <ertes-w> quchen: the problem is that there is a good chance that the threads fail, and 'wait' throws an exception…  you get something rather unpredictable
03:19:03 <mlehmk> isn't there something like continueWith in Haskell that appends actions after an async?
03:19:20 <ertes-w> quchen: also you give up all control over the threads themselves…  in particular you can't stop them once you have retrieved all the data you need
03:19:32 <quchen> ertes-w: Let’s not worry about exceptions, that can be put in later via waitCatch or similar things
03:19:42 <quchen> Hmm.
03:20:15 <mlehmk> exceptions in Haskell also seem to be weird to me
03:20:17 <ertes-w> quchen: i would probably go for a design, where the threads push the data by themselves
03:20:41 <quchen> Push them where?
03:20:53 <ertes-w> to an IORef/MVar/TVar/…
03:21:02 <sbrg> mlehmk: you can just start another thread. `continueWith as next = async $ wait as >> next` i guess
03:21:07 <mlehmk> I could understand an exception for something like division by zero in a pure function
03:21:42 <mlehmk> sbrg, I think I'd flip the arguments
03:21:51 <tdammers> exceptions and modules feel weirdly unidiomatic in Haskell
03:21:54 <ertes-w> quchen: alternatively there is a design based on fixed points which i often use…  i can explain it later, if you want
03:22:04 <sbrg> mlehmk: that'd probably be useful yes
03:22:26 <mlehmk> but it still uses wait
03:22:47 <quchen> ertes-w: I guess phenomenologically, I want to just fork all the service calls, and have their results available as pure values, but not do redundant service calls.
03:22:56 <mlehmk> anyone familiar with the concept of promise (js), future (java), task (c#) in other languages?
03:23:01 <quchen> And more importantly, not do redundant waits.
03:24:06 <sbrg> mlehmk: what does it matter? it has the correct semantics. 
03:24:30 <sbrg> promises and such are just the same thing except they often have baked-in language support like the `async` keyword
03:24:57 <mlehmk> i thought that functional programming would make all that work of dealing with a threadpool, a scheduler and handling parallel tasks easy
03:25:30 <sbrg> it is pretty easy to do a threadpool in haskell. 
03:27:40 <quchen> ertes-w: What about this? http://lpaste.net/360060
03:28:34 <quchen> ertes-w: The chain of service calls is fully broken up in parallel chunks; the laziness can be taken away when foo returns in the end
03:29:21 <quchen> ertes-w: The lazyWait for async2 is necessary so we don’t unnecessarily block waiting for a redundant call
03:29:42 <quchen> ertes-w: The lazyAsync is used so that the service call is only triggered when the resulting async is actually used (i.e. waited for)
03:30:07 <quchen> edit: fixed some typos
03:30:44 <quchen> Maybe I’m reinventing Haxl in bad here
03:43:52 <WinterFox[m]> What does the variable t0 mean when I see it in error messages?
03:45:39 <taktoa> WinterFox[m]: it's a type variable that was generated during unification
03:45:53 <taktoa> i.e.: it never unified with any concrete type or type variable during typechecking
03:48:25 <WinterFox[m]> I'm trying to sort an array by string length with `sortBy (comparing length) ["aaaa", "aa", "aaaaaaaaa"]`
03:48:36 <WinterFox[m]> Getting the error `Variable not in scope: sortBy :: t0 -> [[Char]] -> t`
03:48:44 <sbrg> @hoogle sortBy
03:48:45 <lambdabot> Data.List sortBy :: (a -> a -> Ordering) -> [a] -> [a]
03:48:45 <lambdabot> Data.List.NonEmpty sortBy :: (a -> a -> Ordering) -> NonEmpty a -> NonEmpty a
03:48:45 <lambdabot> GHC.OldList sortBy :: (a -> a -> Ordering) -> [a] -> [a]
03:48:48 <sbrg> import Data.List
03:48:54 <sbrg> also, `comparing` is from Data.Ord
03:49:00 <sbrg> in newer base, you also have `sortOn`
03:49:03 <sbrg> @hoogle sortOn
03:49:03 <lambdabot> Data.List sortOn :: Ord b => (a -> b) -> [a] -> [a]
03:49:03 <lambdabot> GHC.OldList sortOn :: Ord b => (a -> b) -> [a] -> [a]
03:49:03 <lambdabot> BasePrelude sortOn :: Ord b => (a -> b) -> [a] -> [a]
03:49:04 <tdammers> WinterFox[m]: t0 in this context is just an intermediate type variable that GHC inferred while figuring out the type of sortBy
03:49:20 <sbrg> > sortOn length ["1", "333", "22"]
03:49:20 <WinterFox[m]> Ah
03:49:22 <lambdabot>  ["1","22","333"]
03:49:39 <tdammers> WinterFox[m]: since sortBy isn't in scope (which is what the error message says), GHC will still try to infer its type, generating new type variable names on the fly as needed
03:50:24 <WinterFox[m]> Makes sense.
03:50:34 <tdammers> WinterFox[m]: that type signature tells you that GHC has inferred that sortBy's type must be t0 -> [[Char]] -> t for some types t and t0, and that it doesn't know anything more about these types
03:50:35 <sbrg> that error is actually kind of annoying. I have been trying to fix a type error which was seemingly caused by a missing import several times
03:50:51 <sbrg> (because there were a lot of errors, and i missed that one import was missing)
03:51:02 <sbrg> IMO, ghc shouldn't be trying to typecheck rest of the code if a function is missing
03:51:25 <tdammers> sbrg: it can be useful though, in a type-driven workflow
04:09:01 <royal_screwup21> I'm trying to define a class like so: https://thepasteb.in/p/NxhV3EyyOV3CN The compiler throws an error "parse error on input where". What am I doing wrong?
04:09:38 <sbrg> royal_screwup21: "Class"
04:09:41 <sbrg> should be "class"
04:11:23 <royal_screwup21> cool, thanks sbrg
04:14:06 <ertes-w> quchen: why would you unsafeInterleave 'async'?
04:14:30 <ertes-w> quchen: ah, i got it
04:15:45 <ertes-w> quchen: you can combine them into a single action, i think
04:16:30 <ertes-w> quchen: lazyAsync c = unsafeInterleaveIO (async c >>= wait)
04:16:38 <quchen> Hmm!
04:17:37 <ertes-w> quchen: i'm be kinda ok with that design, if you actually use waitCatch instead of wait there
04:17:42 <ertes-w> i'd*
04:18:08 <quchen> waitCatch still has problems when the >>= throws
04:18:17 <quchen> withAsync is probably the way to go
04:18:24 <quchen> or withAsyncCatch or whatever it’s called
04:21:17 <ertes-w> quchen: lazyAsync c = unsafeInterleaveIO (withAsync c waitCatch)
04:22:02 <ertes-w> i'm kinda fine with that…  it still has the unpredictability issue…  i'm not overly fond of the idea that evaluating a value might launch the missiles
04:22:46 <quchen> I think if one is careful to force the final result of the computation so that missiles are to be launched no later than a certain point it’s okay
04:26:25 <royal_screwup21> I'm trying to recreate how the Eq class and its instances are defined https://thepasteb.in/p/NxhV3EygR46iN Am I on the right track?
04:27:41 <quchen> royal_screwup21: Looks good! The third clause for (==) has a different number of arguments than the other clauses though, that’s not allowed.
04:27:48 <quchen> Conceptually you’re right though.
04:27:53 <quchen> Just use dummy »_« arguments.
04:28:12 <cocreature> you also need to indent the definition of (==)
04:28:12 <royal_screwup21> cool, thanks quchen
04:32:12 <Psybur> If I have a T Int, is the only way to get the Int out of T to pattern match?
04:33:15 <ertes-w> Psybur: in principle yes, but there is syntax to predefine an accessor function
04:33:29 <ertes-w> newtype T a = T { fromT :: a }
04:33:32 <ertes-w> fromT :: T a -> a
04:33:51 <Psybur> I see. I should probably change all these to newtypes anyway
04:35:38 <tdammers> actually, it depends how T is defined
04:36:00 <tdammers> type T a = a -> () -- no way to "get the a out"
04:36:31 <tdammers> but if it's something like newtype T a = T a, then yes
04:38:00 <Psybur> Yes switching to newtype helped
04:38:27 <tdammers> what were you using before?
04:38:36 <tdammers> just type T a = a?
04:39:40 <ktms> Out of the two book "Introduction to functional programming in haskell - Richard Bird" and "Programming in haskell -Graham Hutton" which one should I buy to start my haskell learning
04:40:04 <sbrg> www.haskellbook.com
04:40:06 <sbrg> is the one
04:41:50 <ktms> sbrg: Is that in pdf?
04:42:00 <sbrg> not sure which format it comes in. 
04:42:10 <ktms> have you read it?
04:42:34 <sbrg> i read some early chapters of it back when it was newish
04:43:24 <ertes-w> ktms: compare the dates and buy the newer one
04:44:02 <ertes-w> ktms: haskellbook (HPFFP) isn't necessarily the best one, but it is the one that covers the most ground
04:44:25 <ertes-w> on the other hand it goes sloooooooooooooooow…  if you like that, then it's for you
04:45:08 <ktms> ertes-w: I want a comprehensive book
04:46:09 <ertes-w> ktms: comprehensive to what extent?
04:46:24 <ktms> haskell book covers trivial topics in deep and only touches tough topic 
04:46:31 <Psybur> tdammers, data T = T a
04:46:33 <ktms> that i read in a review
04:46:49 <tdammers> Psybur: data T a = T a, I take it?
04:47:02 <gfixler> Why is this a lie? https://twitter.com/EvilHaskellTips/status/930523264505573376
04:47:08 <Psybur> tdammers, data Points = Points Double deriving (Show)
04:47:15 <ktms> ertes-w: comprehensive like SICP
04:47:16 <tdammers> Psybur: ah ok
04:47:28 <ertes-w> ktms: first decision is what pace you want to learn with
04:47:33 <tdammers> Psybur: so no type vars
04:47:44 <ktms> ertes-w: slow pace
04:48:06 <tdammers> Psybur: anyway, newtype and data behave the same this way, you can also do data Points = Points { unPoints :: Double }
04:48:14 <ertes-w> ktms: i don't think HPFFP teaches programming the way SICP does…  it's more about understanding haskell concepts
04:48:16 <tdammers> and that gives you unPoints :: Points -> Double
04:50:49 <ertes-w> ktms: something like SICP is also kinda difficult to write for haskell, because there are just so many ways to express yourself…  you could write a whole book just about fixed points
04:52:20 <ktms> ertes-w: I think this https://www.goodreads.com/book/show/3791460-introduction-to-functional-programming book does that
04:56:57 <Psybur> Is there a way to combine "forever $ do" and State? Like each iteration modifies the state and the beginning of the next iteration depends on that state?
04:57:42 <Psybur> Yes I think I found something
04:57:43 <ertes-w> ktms: bird and wadler are definitely respected names
04:58:08 <ktms> That is why i thought about going with their book
04:58:32 <ertes-w> Psybur: what do you mean, "combine"?
04:58:56 <Psybur> ertes-w, my solution looks like runStateT (forever go) s
05:02:57 <codedmart> I forgot how to go from `Scientific -> Integer`
05:03:17 <codedmart> I can't seem to find it this morning.
05:05:20 <codedmart> Nevermind
05:11:44 <raynold> ahh it's a wonderful day
05:28:24 <Psybur> Is there anyway I can combine a guard on a single alternative in a pattern match?
05:28:28 <Psybur> Like case lastTime of Nothing | Just time | time /= thisTime
05:29:24 <quchen> ertes-w: I’m having trouble imagining the differences between »unsafeInterleaveIO (withAsync action wait)« and »unsafeInterleaveIO action« though.
05:29:39 <quchen> ertes-w: Both don’t block, okay, but what does the async actually buy us here?
05:29:40 <osa1> Psybur: `if lastTime /= Just thisTime then ...`
05:29:51 <Psybur> So I have to use an if? Fine then D;
05:30:11 <quchen> I guess the answer should be an obvious »async makes each IO action run in its own thread«, but I can’t deduce that.
05:30:21 <quchen> Can you? :-)
05:30:40 <quchen> I mean (\action -> withAsync action wait) is id, no?
05:31:14 <quchen> That makes the unsafeInterleaveIO change its argument’s behavior in a way
05:31:17 <ertes-w> Psybur: guards are effectively 'if's
05:31:35 <Psybur> Yes but guards are fewer characters :D
05:31:38 <ongy> hm, can't I pattern match with a {} to ignore all other fields in a type? I thought (View v {}) should match no matter how many other fields exist, but I get a Parse error on that pattern
05:31:38 <ertes-w> quchen: nothing
05:31:46 <Psybur> Actually maybe not because of otherwise heh
05:32:34 <ertes-w> quchen: perhaps you should look into 'shake'
05:37:32 <Psybur> Hmm Im getting variable not in scope, t in: Nothing | Just t -> if (t /= thisTime) then do
05:39:34 <Psybur> Hmm, figured out a better way to control this
05:41:25 <gfixler> nm, figured it out
05:42:11 <Psybur> Changed it to Just t | (t == thisTime) ->, and _ -> :D
05:45:23 <ertes-w> ongy: only by field name
05:45:32 <ertes-w> ongy: View { blah = v }
05:46:34 <ertes-w> Psybur: that's just 'if' in disguise…  might as well use it
05:46:35 <ongy> thx
05:46:46 <ongy> it's a bit more annoying than I hoped, but it works
05:46:58 <ertes-w> Psybur: if mx == Just thisTime then _y else _n
05:48:03 <Psybur> Gotcha
05:48:37 <dminuoso> ski: By the way, when I woke up today - the first thought that popped into my head was "Oh.. I just understood his [yours] nickname"
05:51:11 <dminuoso> ski: After a bit I took some papers and rewrote the laws on paper and just put them into commutative diagrams. That helped make sense of it all. :)
05:51:50 <ertes-w> dminuoso: so now you can write lazy k programs =)
05:51:52 <dminuoso> (Interestingly I just took natural transformations, and came up with the commutative diagram for them as well -> and it turned out that it matched with the one from wikipedia and some other source)
05:52:36 <dminuoso> So everything fell into place thanks to the help I've gotten in here.
05:52:54 <dminuoso> ertes-w: heh I still have to implement those combinators in haskell.
05:52:57 <Sonmi> t
05:53:05 <dminuoso> Wasn't it even you who tasked me to write a y-combinator a while ago?
05:53:11 <Sonmi> oops
05:53:29 <Sonmi> i forgot i had these on autojoin
05:53:37 <ertes-w> dminuoso: you already have them
05:53:47 <ertes-w> dminuoso: (<*>), pure, id
05:53:56 <dminuoso> ertes-w: No wait.. what. This cant be.
05:54:17 <ertes-w> > (f <*> g) x
05:54:20 <lambdabot>  error:
05:54:21 <lambdabot>      • Could not deduce (Show a0) arising from a use of ‘f’
05:54:21 <lambdabot>        from the context: FromExpr t
05:54:25 <ertes-w> > (f <*> g) x :: Expr
05:54:29 <lambdabot>  error:
05:54:29 <lambdabot>      • Ambiguous type variable ‘a0’ arising from a use of ‘f’
05:54:29 <lambdabot>        prevents the constraint ‘(Show a0)’ from being solved.
05:54:44 <ertes-w> (f <*> g) x = f x (g x)
05:54:50 <ertes-w> pure x y = x
05:54:54 <ertes-w> id x = x
05:55:55 <ertes-w> dminuoso: that's also why @pl uses applicative combinators a lot
05:56:06 <ertes-w> @pl \x -> f x (g x)
05:56:06 <lambdabot> ap f g
05:56:12 <ertes-w> ap = (<*>)
06:04:11 <dminuoso> ertes-w: I dont pretend to understand SKI combinators (yet), but I think with this in mind I might be tempted to study them next.
06:04:57 <ertes-w> dminuoso: the point of SKI is that you can eliminate all lambdas
06:05:58 <ertes-w> dminuoso: there is a compilation strategy based on that…  if there are no lambdas, then your entire program becomes a single large expression with only two supercombinators (S and K) to express functions
06:07:24 <ertes-w> there are in fact at least two esoteric programming languages, unlambda and lazy k, based on that…  you have to express your entire program in terms of S, K and I
06:10:54 <dminuoso> ertes-w: I've already read some introductionary hints that monad have a lot of meaning in terms of algebras. Is this related?
06:11:33 <dminuoso> (The hints I read claimed that monadic bind could in some particular be seen as substitution in an expression tree)
06:14:38 <dminuoso> Im a bit concerned that my wobbly path might leave me with just knowing some half truths because I neither have an academic background, nor do I have any particular book guiding me through this learning process. It's mostly just "oh this looks interesting. category theory cant be that hard, now can it"
06:40:27 <Psybur> anybody run any apps on AWS EC2? Any recommendations on instance/AMI combos for small apps? Seems I cant get stack to work on the t2.nano instance. Get segfaults. I got it to work on an m3 before
06:40:53 <Psybur> Looks like the amazon linux image isnt supported. Got it running on it on the m3
06:41:53 <cocreature> Psybur: I would just build a docker image locally or somewhere else and then deploy that rather than trying to build on aws
06:42:07 <Psybur> cocreature, interdasting
06:42:33 <cocreature> stack even has builtin support for creating docker images
06:43:06 <Psybur> With all the extra libraries included?!
06:43:15 <Psybur> Like the .so files etc
06:43:51 <Wizek> Hello. I have lists that are potentially quite long, and I only care if they are longer or shorter than n items long. So using length can potentially be lengthy to run. Then I thought: What if I could exploit laziness to my advantage here? I thought of writing a listLongerThan function, which could return as early as it knows the answer. Then it occurred to me that then I'd have to write lt, gt, lte, gte, eq variants.
06:43:51 <Wizek> Then I thought further, couldn't I make this composable by using church encoded natural numerals? That way I could have `list & lengthNat & (>= 3)` given Nat has Num and Ord instances. Now here comes my question: Is GHC sufficiently optimizing to notice what I am doing here and optimize away allocations for the Nat and produce core similar to `case list of _:_:_:_ -> True; _ -> False`?
06:44:25 <cocreature> Psybur: it won’t automatically install extra foreign libs but you can choose the base image that it places the Haskell executable in, so you can just make a base image that contains the foreign libs you need
06:53:53 <ij> Can I require a string have two valid interpretations with megaparsec? (I'll try to find it, but asked here first.)
06:54:10 <ij> Hm, that might not even be what I'm looking for.
06:58:01 <Psybur> cocreature, happen to know what this is all about? Following the tutorial and I get this when I run stack build after setting docker: true. No such object: fpco/stack-build:lts-9.5
06:59:23 <cocreature> Psybur: maybe try a "stack docker pull" but note that stack has two different kinds of docker integration: one for building your project in a docker container and one for creating a docker container containing the final executable. what you are enabling via docker: true is the former not the latter
06:59:23 <Psybur> cocreature, trying stack docker pull that might fix.
06:59:44 <Psybur> I see
07:01:05 <Psybur> So I use image: not docker:
07:03:48 <ertes-w> dminuoso: no, it's the truth
07:04:26 <ertes-w> dminuoso: here is a simple example:  data Expr a = Add (Expr a) (Expr a) | Mul (Expr a) (Expr a) | Lit Integer | Var a
07:04:42 <ertes-w> dminuoso: this is an arithmetic expression type, and it's a monad…  exercise: write a Monad instance for it
07:04:56 <ertes-w> dminuoso: once you have it (>>=) is variable substitution
07:14:07 <ertes-w> Wizek: if you use a church-encoded variant of Nat, then perhaps
07:14:59 <ertes-w> Wizek: you can use (newtype Nat = Nat { runNat :: forall r. (r -> r) -> r -> r }), or (Mu Maybe) from the recursion-schemes library
07:15:18 <Psybur> so cocreature, I just use add: to add in the libraries?
07:16:31 <ertes-w> Wizek: this is also how list fusion works: unfolds are rewritten to church encoding, and then folds are just function application
07:18:32 <cocreature> Psybur: what kind of libraries are we talking about?
07:20:05 <Psybur> I have 5 library files in /usr/local/lib that I want to add
07:20:12 <Psybur> .a,.la,.so*
07:20:22 <cocreature> in that case, make a docker image that contains these libs and change the base image
07:20:48 <cocreature> take a look at https://docs.haskellstack.org/en/stable/GUIDE/#docker for a config example
07:33:30 <peter84> How can I define a string that has patterns, for example how do I define the string "aaa 1 aaa 2 ... aaa 9 aaa 10"
07:35:05 <cocreature> > intercalate " aaa " (map show [1..10]) -- peter84 
07:35:08 <lambdabot>  "1 aaa 2 aaa 3 aaa 4 aaa 5 aaa 6 aaa 7 aaa 8 aaa 9 aaa 10"
07:35:22 <cocreature> ah I guess that’s missing the aaa at the beginning but it’s easy to prepend that
07:37:41 <peter84> cocreature: thanks
08:16:08 <ertes-w> > concatMap (("aaa " ++) . show) [1..10]
08:16:11 <lambdabot>  "aaa 1aaa 2aaa 3aaa 4aaa 5aaa 6aaa 7aaa 8aaa 9aaa 10"
08:16:23 <ertes-w> arrrrrrr!
08:18:03 <ertes-w> > unwords (map (\x -> ["aaa", show x]) [1..10])
08:18:06 <lambdabot>  error:
08:18:06 <lambdabot>      • Couldn't match type ‘[Char]’ with ‘Char’
08:18:06 <lambdabot>        Expected type: [String]
08:18:49 <ertes-w> > unwords (concatMap (\x -> ["aaa", show x]) [1..10])
08:18:51 <lambdabot>  "aaa 1 aaa 2 aaa 3 aaa 4 aaa 5 aaa 6 aaa 7 aaa 8 aaa 9 aaa 10"
08:23:34 <krokodil> Is it possible to make a Category instance of pairs of types and pairs of functions?
08:23:55 <krokodil> `instance Category ((->), (->))` isn't even valid Haskell
08:24:14 <krokodil> I want something that could easily compose (f,g) with (h,i), where f,g,h,i are functions
08:28:07 <ertes-w> krokodil: data ProductCat c d a b = ProductCat (c a b) (d a b)
08:30:21 <shapr> I was part of a twitter thread listing pragmas for teaching. I've started using GADTSyntax already. Other suggestions were: InstanceSigs, TypeApplications, OverloadedStrings, and ScopedTypeVariables
08:30:25 <shapr> Anyone else have suggestions?
08:30:27 <ertes-w> krokodil: there is also a generalised version of it, but for that you also need a generalised Category class
08:30:35 <ertes-w> krokodil: https://hackage.haskell.org/package/hask-0/docs/Hask-Category-Polynomial.html#t:Product
08:30:56 <ertes-w> krokodil: however, you can also just compose functions of tuples
08:31:02 <Xion_> shapr: LambdaCase and various Flexible* extensions are often used
08:31:37 <shapr> Xion_: got any code you could link to as an example of "clearer with this extension" ?
08:31:40 <Xion_> You may also want RecordWildCards though it is somewhat debatable
08:31:59 <shapr> I've not tried LambdaCase, though the examples I've seen look nice
08:32:09 <ertes-w> shapr: honestly i don't like any of those, except perhaps GADTSyntax =)
08:32:18 <shapr> On the other hand, I did use TransformListComp and alanz said "You're the only person who uses that" :-)
08:32:23 <ertes-w> shapr: and perhaps InstanceSigs
08:32:26 <Xion_> Well I've got https://github.com/Xion/spiteful/blob/master/src/Spiteful/Features.hs#L43 at most
08:32:35 <Xion_> It's basically about not repeating the function name needlessly
08:32:42 <ertes-w> shapr: thing is: you need to be able to understand regular ADT syntax anyway
08:33:20 <shapr> ertes-w: for teaching I prefer as much consistency as possible, and GADTSyntax seems to do that
08:33:27 <shapr> It helped in my Haskell class yesterday.
08:33:44 <Xion_> TransformListComp is like, weird
08:33:48 <shapr> I put the non-GADTSyntax in a comment above
08:34:02 <ertes-w> shapr: it depends on how you explain ADTs
08:34:09 <shapr> Xion_: yeah, my use was: https://github.com/shapr/tmuxmarta/blob/master/src/Lib.hs#L65
08:34:16 <shapr> ertes-w: how would you explain ADTs?
08:34:28 <shapr> I just call 'em structs and enums for the C/C++ people in the audience
08:34:41 <ertes-w> shapr: "a value of type [a] is either of the form [] or of the form (x : xs), where (x :: a) and (xs :: [a])"
08:35:06 <ertes-w> shapr: "a value of type (Maybe a) is either of the form Nothing or of the form (Just x), where (x :: a)"
08:35:15 <ertes-w> this has worked consistently for me
08:35:37 <shapr> I started with data Temp = Cold | Hot
08:35:47 <shapr> and then data Person = People Name Age
08:35:54 <Xion_> shapr: It is rather odd to read, I'd probably revert to `do` notation at this point tbh :)
08:36:01 <shapr> and then data Tree a = Nil | Node (Tree a) a (Tree a)
08:36:03 <humanoyd> is there an extension like LambdaCase for `if`?
08:36:21 <Xion_> PatternGuards?
08:36:32 <dibblego> RebindableSyntax
08:39:23 <shapr> Xion_: yeah, after alanz said that zero libraries in hackage use TransformListComp, I figured I should take it out.
08:40:28 <Xion_> Talk about obscure
08:40:42 <Xion_> Are there some stats about the usage of all extensions handy btw?
08:41:02 <jchia_> Question about record libraries, like vinyl, superrecord, labels: Which record libraries allow me to easily have Generic instances of their 'record' type?
08:41:19 <jchia_> I think labels doesn't
08:43:37 <shapr> Xion_: no, but that would be useful information
08:43:51 <shapr> probably not too hard to script up
08:47:01 <krokodil> ertes-w: Thanks! I feel stupid now :). So it is not really possible to not wrap (->) into a ProductCat?
08:48:12 <AWizzArd> Is the OverloadedLists extension a) causing worse runtime performance? Or is this *purely* syntactic sugar that b) just lets me write more literals with the list notation?
09:00:09 <cocreature> AWizzArd: worse runtime performance than what?
09:02:18 <mnoonan> shapr: EmptyCase, if you're going to do anything with Curry-Howard
09:04:16 <AWizzArd> cocreature: worse than without it, i.e. are there conversions to and from lists happening at runtime?
09:05:35 <cocreature> AWizzArd: but how do you write literals without it?
09:06:34 <cocreature> e.g. for vector, you basically have to use Vector.toList and at that point there is little difference
09:07:09 <Rixxx> ciao
09:07:26 <Rixxx> !list
10:06:50 <Barry_> Hallo guys, I got an assignment where I have to remove all Nothing out of a list, using foldl
10:06:56 <Barry_> or foldr
10:07:26 <Barry_> So I figured I can do sth like this: catMaybes :: [Maybe a] -> [a] catMaybes xs= foldl (\state (Just a)-> (:) a state) [] xs
10:08:37 <Barry_> But my function is not catching the Nothing case, so I wanted to ask if I can extend this function by sth like \state (Nothing) -> state
10:09:14 <mniip> no
10:09:23 <mniip> you need to do case-analysis explicitly
10:09:28 <mniip> or let another function do it for you
10:10:21 <mniip> :t foldr (maybe id (:)) []
10:10:24 <lambdabot> Foldable t => t (Maybe a) -> [a]
10:11:05 <Barry_> hm thanks
10:11:51 <mniip> hmm
10:14:22 <mniip> :t (`appEndo` []) . foldMap (foldMap (Endo . (:)))
10:14:24 <lambdabot> (Foldable t2, Foldable t1) => t1 (t2 a) -> [a]
10:15:50 <mniip> :t ($ []) . alaf Endo (foldMap . foldMap) (:)
10:15:51 <lambdabot> (Foldable t2, Foldable t1) => t1 (t2 a) -> [a]
10:17:47 <mniip> !
10:17:48 <mniip> :t foldr (alaf Endo foldMap (:)) []
10:17:50 <lambdabot> (Foldable t2, Foldable t1) => t1 (t2 a) -> [a]
10:19:56 <Akii> Hi! Currently trying to understand free monads and also the category theory aspect of it (https://joashc.github.io/posts/2016-03-23-free-monads.html).
10:20:24 <Akii> I'm almost understanding it, I think. Currently trying to get a good understanding of forgetful functors though.
10:20:48 <Akii> is the function `maybe` something like a forgetful functor? It does "forget" about the optionality of values.
10:21:06 <EvanR> maybe the function is not a Functor
10:21:23 <EvanR> Maybe the type ctor is a Functor, mapping types to types
10:21:40 <EvanR> (and fmap maps functions a -> b to Maybe a -> Maybe b
10:21:47 <Akii> hm 
10:22:17 <EvanR> i am not sure what a forgetful endofunctor would be like
10:22:34 <Akii> and by that you mean what it would look like in Haskell
10:22:44 <mniip> I wouldn't say Maybe is forgetful
10:22:55 <mniip> Akii, no like
10:23:00 <Akii> because Hask being the category and all functors being endofunctors
10:23:15 <Akii> I might very well be mixing up a lot atm :D
10:23:18 <mniip> not really specific to Hask
10:23:25 <EvanR> if Hask were really a category you could try to form a functor out of it into a simpler category with less structure
10:23:32 <mniip> a forgetful functor usually goes between two model categories
10:23:40 <mniip> where one model is a subset of the other
10:24:03 <mniip> where by models I really mean signatures I think
10:24:42 <EvanR> but forgetful doesn't have a precise definition, its just half of an adjuction
10:24:50 <EvanR> adjunction
10:25:11 <mniip> I thought free is the adjunction to forgetful?
10:25:19 <EvanR> free is the other half
10:25:23 <Akii> let me ask differently: anyone got a good resource on adjunctions and forgetful functors?
10:25:37 <mniip> EvanR, no like chicken and egg
10:25:39 <mniip> what comes first
10:25:42 <EvanR> neither
10:26:05 <Akii> need to lvl up my category theory :D
10:26:22 <EvanR> its cycle [0,1] all the way down
10:26:39 <mniip> cycle []
10:26:47 <EvanR> > cycle []
10:26:49 <lambdabot>  *Exception: Prelude.cycle: empty list
10:27:46 <pavonia> Why isn't that just []?
10:28:18 <mniip> there are a handful of values which you could ask why isn't this that
10:28:28 <mniip> with no obvious better one
10:28:44 <EvanR> what laws do we expect from a cyclic list
10:29:03 <geekosaur> de facto we expect it to be infinte :)
10:29:20 <geekosaur> (which is to say, we really want a cyclic NonEmpty)
10:38:30 <mnoonan> there is at least some way to make the notion of forgetting a little more precise: https://ncatlab.org/nlab/show/stuff%2C+structure%2C+property
10:39:00 <mnoonan> (also featuring the terrific term "amnestic functor")
10:41:15 <mizu_no_oto> Barry_: you could also move the lambda into a named function in a where block and pattern match in that definition - see http://lpaste.net/360065
10:42:38 <mizu_no_oto> That's a fairly clean way to write that sort of thing "from scratch" (i.e. without relying on additional combinators like maybe )
10:43:46 <Akii> thanks mnoonan 
11:25:37 <shapr> is an amnestic functor the same as a forgetful functor?
11:27:11 <joeoeoe> Hello, why is the random package not included in ghc anymore?
11:30:07 <mud> joeoeoe: Isn't it? But either way, depending on how you're building stuff it really shouldn't matter if it is or not. Neither cabal-install or stack are going to make it hard to use the 'random' package
11:31:42 <geekosaur> joeoeoe, things bundled with the compiler can't easily be upgraded, as a general rule; you have to upgrade ghc
11:34:26 <joeoeoe> Okay thanks, and no it was removed in a recent version
11:35:08 <joeoeoe> It just seems slightly beginner hostile, but it's not too bad (cabal is so easy to use)
11:35:12 <geekosaur> that would make some sense, with the changes for deterministic building
11:36:00 <joeoeoe> Is there any way to find if a type is an instance of a typeclass in ghci?
11:36:54 <mud> joeoeoe: :i TheType  lists them (might have to import the module(s) first)
11:37:06 <geekosaur> ghc needs to do some rather invasive optimizations to get reasonable performance, which leads to much tighter version constraints than you might otherwise expect. which is why anything shipped with ghc is hard to upgrade. details here if you care (it's about a related topic): https://wiki.haskell.org/Shared_libraries_and_GHC
11:37:55 <joeoeoe> mud: Thanks :)
11:38:18 <joeoeoe> geekosaur: ah right, I did not realise that
11:55:11 <danielsmw> does anybody have any experience nesting derivative operations with ad?
11:59:31 <danielsmw> in particular, does anyone know how to make sense, at the type level, of using the same Scalar at two different levels of nesting during automatic differentiation?
12:06:08 <statusfailed> does a programming language have to be turing complete in order to have a self-interpreter?
12:06:48 <Tuplanolla> Do you accept the empty language as an answer, statusfailed?
12:07:09 <statusfailed> Tuplanolla: I'm not sure, because i'm not sure if it counts as self interpretation :-)
12:07:17 <statusfailed> I would say no
12:07:34 <Tuplanolla> It can interpret every program in the language.
12:07:44 <statusfailed> but, there are no programs in the language
12:07:49 <statusfailed> so it's not possible to write a self-interpreter
12:07:51 <statusfailed> :-)
12:08:41 <Tuplanolla> How about the singleton language, where the only program interprets itself, then?
12:09:44 <statusfailed> Tuplanolla: you mean for example, it has one term "eval", which reads its input and evaluates it?
12:09:52 <lyxia> danielsmw: What's the problem
12:10:07 <Tuplanolla> Something like that, yes.
12:10:12 <Tuplanolla> I'd expect that Turing completeness isn't required, but I don't have a proof handy.
12:10:22 <statusfailed> Tuplanolla: I suspect the same, but I also don't have a proof :D
12:10:39 <Tuplanolla> Maybe extending these trivial examples enough could get you there.
12:11:10 <statusfailed> true, but it's surprising this doesn't seem to have an easily google-able answer
12:11:21 <codeshot> Can anyone explain why people say Hask isn't a category? I've seen this justified by the fact that not "undefined . id == undefined" but how do they know this if they've used bottom?
12:11:27 <danielsmw> lyxia: so, i wrote a function roughly of type (forall s . Reifies s Tape => Reverse s (Complex Double) -> Reverse s (Complex Double), which which I can readily use the grad and jacobian and so on functions from ad
12:12:13 <danielsmw> lyxia: but later on, i needed to include a derivative operation with the function i was differentiating
12:12:36 <Tuplanolla> Now, then. Can you think of a language that has two programs, one of which is a self-interpreter and another one that isn't, statusfailed?
12:12:48 <danielsmw> lyxia: what this meant was that I really couldn't specify the base type anymore, because that second derivative operation actually needed to be operation on Reverse (Reverse (Complex ...)) or something like that
12:13:16 <lyxia> > (undefined . id) `seq` ()
12:13:19 <lambdabot>  ()
12:13:27 <lyxia> > undefined `seq` ()  -- codeshot 
12:13:31 <lambdabot>  *Exception: Prelude.undefined
12:13:34 <danielsmw> lyxia: I can successfully write a program with generic enough types that I can take second derivatives like that, but the problem is that once I've done this I don't know how to bring in outside scalars
12:13:36 <codeshot> ah, bottom
12:13:45 <danielsmw> in a typeconsistent way
12:13:51 <codeshot> from falsity anything
12:14:15 <codeshot> ie, you can't prove Hask is not a category if you get bottom during your proof
12:14:48 <danielsmw> lyxia: here's a minimal-ish example: https://pastebin.com/RCaYmSfU
12:15:00 <lyxia> danielsmw: auto (auto myScalar) ?
12:15:44 <codeshot> or is it just enought to say "undefined" -> bottom, therefore haskell is not a category?
12:16:41 <codeshot> ie, if any morphism is bottom then it's not a morphism and thus the category that contains it isn't a category
12:16:53 <lyxia> codeshot: That's not it.
12:17:02 <lyxia> A morphism being bottom is not the problem.
12:17:22 <lyxia> the problem is that "id . f = f" is not true
12:17:37 <codeshot> how do you know that undefined . id isn't bottom?
12:17:50 <codeshot> if it's bottom it can produce any result and still be equal to the other bottoms
12:17:59 <lyxia> codeshot: I just showed you two programs that do different things
12:18:06 <codeshot> that's what bottom does
12:18:13 <codeshot> so they're both bottom
12:18:21 <lyxia> No it's not
12:18:51 <codeshot> it so is!
12:19:01 <codeshot> bottom leads to any outcome
12:19:10 <codeshot> from falsity anything
12:19:15 <lyxia> It doesn't.
12:19:16 <MarcelineVQ> any outcome?
12:19:25 <codeshot> yup
12:19:40 <Tuplanolla> It seems that you're confusing bottom in the language and bottom in your logic, codeshot.
12:19:40 <MarcelineVQ> I see, we might use the word any different, how do you mean it?
12:20:03 <codeshot> Tuplanolla, maybe but is there a difference?
12:20:05 <lyxia> Bottom is not C's undefined behavior.
12:20:15 <codeshot> indeed, it's worse
12:20:23 <Tuplanolla> Just because you cannot use Haskell for reasoning about Haskell doesn't mean you can't use a consistent logic for reasoning about Haskell, codeshot.
12:20:41 <lyxia> It's just one more value that's in the semantics, it doesn't lead to an explosion of your semantics to mean everything
12:21:57 <codeshot> is there a consistent logic that says that an undefined morphism has the same effect every time?
12:22:33 <codeshot> for example, the 500th time I run undefined in ghci I get bored and stop, while the 499th one caused my to type it again
12:22:55 <codeshot> the effect of it's interpretation on the equipment attached to the computer was different
12:23:05 <codeshot> this is before we even get to its bottomness
12:23:40 <danielsmw> lyxia: I think the problem is that I want to compute d(f + df). It seems that this forces f to have an inconsistent type
12:24:12 <codeshot> category theory doesn't cover semantics
12:24:41 <lyxia> danielsmw: what's the error message
12:25:53 <danielsmw> lyxia: Couldn't match type Complex Double with Reverse s (Complex Double)
12:26:02 <lyxia> danielsmw: where
12:27:07 <danielsmw> lyxia: I have a function aZ that operates on and returns Reverse s (Complex Double). The error message appears in my function daZ, at the aZ in the statement"jacobian (\ t -> aZ t) x"
12:28:35 <danielsmw> lyxia: presumably this is because aZ has had the type Reverse s CNumber specified in a type signature, but jacobian needs another level of Reverse s (Reverse s CNumber) or something like that.
12:29:10 <lyxia> danielsmw: so what's wrong with using auto to lift it to a Reverse?
12:29:45 <danielsmw> lyxia: maybe I don't understand where you're suggesting that i use auto
12:30:31 <lyxia> danielsmw: wherever there is a Complex Double but a Reverse s (Complex Double) is expected
12:31:28 <lyxia> If you show me code that I can compile I could try to be more precise
12:31:34 <danielsmw> lyxia: so in jacobian (\ t -> aZ t) x, t will naturally have this double-Reverse structure, because jacobian itself needs to return a single-Reverse value
12:31:51 <danielsmw> sure, let me grab a minimal set of code
12:33:32 <codeshot> MarcelineVQ, bottom is a standard term: https://en.wikipedia.org/wiki/False_(logic)
12:34:03 <codeshot> And due to the Curry-Howard correspondence, that means undefined, nontermination, etc
12:34:30 <codeshot> no further program behaviour is defined
12:35:46 <Tuplanolla> You just had to mix "LLVM poison" kind of bottom into the mess too, codeshot.
12:36:06 <codeshot> Not my fault, blame the universe
12:38:43 <danielsmw> lyxia: https://pastebin.com/PkkXK6rm
12:39:20 <codeshot> so, unless "contains a bottom morphism" -> "not a category", then I haven't seen a reason to think Hask isn't a category
12:39:33 <codeshot> I'll take that last one if someone says it
12:40:05 <codeshot> if someone can show that "undefined" isn't bottom, though, then I'll revise my position
12:41:47 <codeshot> Mind, you, I don't think Hask is the category of haskell programs
12:42:06 <lyxia> Well it's supposed to be the category of Haskell functions...
12:42:25 <Akii> types, I think
12:43:43 <geekosaur> ^
12:44:18 <danielsmw> lyxia: since I was trying to extract a minimal example, I forgot to include this part, but it's pretty important that I want to be able to add aZ and daZ together at some point.
12:45:32 <slack1256> where does the Monoid constrain from `:t view _Left` on lens ?
12:45:57 <slack1256> the "subtyping" lens does is really confusing for me
12:47:19 <codeshot> lyxia, and in that category seq is equal to flip const, only in the category of evaluation of haskell programs do they differ
12:47:30 <codeshot> which isn't hask
12:49:06 <codeshot> evaluation is a functor from Hask to the real world
12:49:56 <slack1256> the real world is a category?
12:50:05 <codeshot> It's a monoid
12:50:19 <codeshot> well, changes to the real world
12:50:33 <codeshot> unfortunately it's a nondeterminism monoid
12:50:47 <codeshot> which is why we stop doing maths at some point and do engineering
12:53:19 <codeshot> it must be a monoid because every morphism is  o -> o  and all change in the real world is because of the current state which is itself the result of previous change
12:53:31 <codeshot> only a monoid describes that
12:53:58 <codeshot> I think
12:54:58 <codeshot> it might be a semigroup which doesn't have id, but only if all morphisms including id increase entropy and I don't know why I'd think that. id wouldn't increase entropy by definition
12:55:22 <codeshot> so it can be a monoid in that case
12:56:58 <danielsmw> I think it depends on whether you want to model the classical world or the fine-grained quantum world
12:57:17 <codeshot> I'm not talking about a model
12:57:25 <danielsmw> in the quantum case things definitely should be entirely local and so on, but you should also have inverses since everything depends on unitary evolution
12:57:30 <codeshot> I'm talking about the real thing :) Actual execution of programs
12:57:32 <danielsmw> entropy is only a statistical concept
12:57:37 <codeshot> not imagining their execution
12:58:18 <lyxia> danielsmw: how do you add a vector (daZ) and a complex number (aZ)
12:58:21 <drdo> What's the standard way to forcefully type cast something with a phantom type?
12:58:43 <lyxia> drdo: Data.Coerce
12:58:45 <drdo> I could actually write the same expression twice and it works
12:58:50 <danielsmw> lyxia: sorry, I started messing with types before I gave that to you to try to simplify things. it would be sufficent to add daZ to (V2 aZ 0)
12:58:50 <drdo> It's just the phantom
12:59:12 <danielsmw> lyxia: so, daZ ^+^ (V2 aZ 0)
12:59:45 <danielsmw> codeshot: well, we have to pick a model for the world if we're going to talk about making an equivalence to a mathematical structure!
13:00:26 <drdo> lyxia: nice, that's exactly the magic I needed, thanks
13:01:45 <lyxia> danielsmw: aZ is already a V2 though? But anyway http://lpaste.net/360068 typechecks
13:03:05 <lyxia> It was more involved than I thought
13:03:35 <danielsmw> i see you ended up extracting the mode away all together
13:03:43 <codeshot> danielsmw, ah, a "supposition" to be tested, yes I agree of course
13:03:49 <danielsmw> which was something I probably figured needed to happen a long time ago, but I didn't really have the guts to do it
13:04:14 <codeshot> but were not analysing whether a model is a monoid
13:04:51 <danielsmw> lyxia: anyway, thanks! I'm sure I'll have the same problem throughout my codebase, but I think what you have here will get me the answers, under inspection
13:04:54 <danielsmw> lyxia: appreciate your time.
13:05:45 <danielsmw> codeshot: we have no way to interact with the world /except/ through models of it, so I'm not sure how one would go about it otherwise
13:05:48 <lyxia> danielsmw: I think the takeaway is that you want to generalize anything having to do with the type "Reverse s z"
13:06:06 <codeshot> danielsmw, this is why I concluded that it was a monoid
13:06:14 <codeshot> not just modelled by one, but actually is one
13:06:24 <codeshot> it's fun but rather pointless :D
13:06:27 <danielsmw> codeshot: why wouldn't you conclude that it's, say, a group?
13:06:46 <codeshot> only if it's all groups
13:07:21 <danielsmw> quantum mechanics is reversable, but our statistical observations of it aren't :P
13:07:36 <codeshot> feynmann diagrams are reversible
13:07:40 <codeshot> it's not the same thing
13:08:01 <danielsmw> lyxia: cool. I actually started writing this code a while ago and was surprised that I couldn't really find many resources/tutorials on ad beyond the readme
13:08:10 <danielsmw> lyxia: which isn't particularly in depth
13:08:22 <lyxia> danielsmw: you only instantiate with that type when you need to do differentiation with the functions in ad, but otherwise all your code is "Floating"-polymorphic.
13:09:04 <lyxia> Yeah someone should write more documentation about it.
13:09:29 <danielsmw> lyxia: I think the other thing you did that I would never have figured out was setting CNumber to Scalar \zeta in the final function. getting complex numbers in without making them explicitly complex numbers was what puzzled me the most
13:09:35 <danielsmw> but the type signature makes sense now that i see it
13:10:12 <danielsmw> lyxia: oh, also, sorry if the unicode slowed you down :P
13:10:30 <lyxia> heh
13:10:54 <danielsmw> i was actually making this as a latex'd .lhs so I could share it in a readable way with my research group
13:10:59 <lyxia> danielsmw: You're lucky I have some shortcuts setup
13:11:39 <danielsmw> honestly, though, it's probably going to end up being a tragedy that I ever found set-input-method TeX in emacs
13:40:28 <Mins> Hello. I need to rewrite the "zip" and "unzip" function. I need to use "case" in one code and "let" in the other. "Case" is done, but I don't know how to do it with "let": http://lpaste.net/335879426233335808
13:41:34 <ph88> hey guys, i'm working on a parser and i have a type for my tokens (terminals) which has a lookahead if there should be a space after the token or not. This works great .. but when generating Arbitrary tokens with QuickCheck i don't know how to build in the same "lookahead" into the Arbitrary instance ... anyone have an idea how i could solve this problem ?
13:42:48 <drdo> ph88: It sounds like your "lookahead" is just a Bool?
13:43:15 <ph88> it inspects the next character and matches it with a set of characters and then returns true or false
13:43:57 <drdo> What's the type of this lookahead?
13:45:16 <ph88> drdo, https://hackage.haskell.org/package/megaparsec-6.2.0/docs/Text-Megaparsec.html#v:lookAhead
13:47:24 <drdo> ph88: What are you trying to test?
13:47:35 <ph88> the parser
13:47:38 <drdo> Or rather, what are you trying to implement Arbitrary for
13:47:45 <ph88> the AST
13:48:14 <drdo> And what's the type of that?
13:48:25 <drdo> You just linked me a typeclass
13:48:26 <ph88> it's composed out of a lot of types
13:48:54 <ph88> you mean the type of a token ?
13:48:55 <ph88> it's Text
13:49:14 <drdo> I mean the type of whatever it is that you are trying to implement an Arbitrary instance for but can't
13:49:33 <ph88> i'm trying to implement Arbitrary for all the different types in the AST
13:49:41 * drdo facepalms
13:49:47 <drdo> And what's the problem?
13:50:06 <drdo> Where are you stuck?
13:50:17 <ph88> that i can't do the lookahead with Arbitrary like i can do with the parser
13:50:27 <drdo> What does that mean?
13:50:32 <ph88> the parser works on a stream of characters .. so there is a lookahead functionality
13:50:54 <ph88> the Arbitrary is just generating random structures
13:50:56 <drdo> But what does the parser have to do with this?
13:51:11 <ph88> that the Arbitrary now generates invalid syntax
13:51:28 <ph88> that's why i say "the parser works great"
13:51:38 <drdo> To generate an Arbitrary AST you don't need a parser
13:51:43 <ph88> true
13:51:48 <drdo> The AST has nothing to do with the parser
13:51:48 <ph88> but the AST is wrong
13:51:59 <drdo> I don't understand what your parser's functionality has to do with this
13:52:14 <ph88> i need to generate an AST that represents valid syntax
13:52:26 <drdo> That should be encoded in your types
13:52:32 <drdo> That's what they are there for
13:52:49 <danielsmw> lyxia: so, actually, there's one further problem with the code you sent me. since daZ didn't constrain \zeta to be a Mode, one can't take derivatives of daZ. So indeed one can add aZ to daZ, but you can't /then/ take the derivative.
13:52:56 <drdo> You still wouldn't need types for this, but they are there to help you
13:52:57 <ph88> but i only know on runtime what token is going to be followed by which other token
13:53:10 <drdo> ?
13:53:15 <danielsmw> lyxia: that's my fault for not really clarifying the problem, but ultimately that's why i asked in the beginning about nested derivatives.
13:53:38 <Mins> Hello again... I need to do homework and rewrite the "zip" and "unzip" function. I need to use "case" in one code and "let" in the other. "Case" is done, but I don't know how to do it with "let": http://lpaste.net/335879426233335808
13:53:57 <drdo> ph88: You're trying to generate Arbitrary AST, then you print it and check if parsing the resulting string gives the same AST, right?
13:53:57 <ph88> drdo, suppose i have token "A" and it can be followed by token "B" to token "Z" how are you going to encode in the types that there are special conditions for some of those tokens ?
13:54:08 <ph88> drdo, yes that's exactly right
13:54:22 <drdo> So why does generating an AST care about the parser?
13:54:39 <ph88> because i don't want to create invalid AST for the moment
13:54:44 <drdo> Then don't
13:54:48 <ph88> i don't know how
13:54:51 <ph88> that's my question
13:54:54 <drdo> Well, it's your language lol
13:55:15 <drdo> Can't really help much there without some details
13:55:45 <ph88> ok suppose i'm using an OO language to generate my random AST
13:56:15 <ph88> i can implement a Node in such a way that i can go to it's siblings (left and right)
13:56:52 <danielsmw> Mins: you might consider looking up how the function "fix" works. might give you some clues as to what they're looking for with the let implementation.
13:56:53 <ph88> then after generating some random node i can check if the previous node (left) needs an extra space .. then i can just mutate this node
13:57:00 <ph88> and i'm done ..
13:57:12 <ph88> shall i make a drawing ?
13:57:35 <drdo> Why don't you generate only valid pairs?
13:57:57 <drdo> You generate a random right node
13:58:07 <drdo> (including if it needs space or not)
13:58:37 <drdo> And then if you got a right node that needs space, you generate a random left node that is compatible with this
13:58:46 <drdo> and the same if you got a right node that doesn't need space
14:00:04 <ph88> because then i need to define UP FRONT for every possible combination whether two things together need a space or not. And it's much easier if i can just inspect what has been randomly generated to see if that needs a space in between or not
14:00:14 <Mins> danielsmw: Thank you, zip2 is done!
14:01:33 <drdo> ph88: But if you have a function that can check if it needs a space, you can do this
14:03:17 <drdo> genNeedsSpaceNode = genNode >>= \n → if needsSpace n then pure n else genNeedsSpaceNode
14:03:25 <drdo> I don't quite understand the issue
14:03:36 <ph88> drdo, look my AST https://imgur.com/a/ytAQP
14:03:48 <drdo> ph88: It doesn't really matter what it is
14:03:56 <drdo> If you have some property you can check
14:03:58 <ph88> oh there is a mistake in my image ... i meant for the right "B" to be a "("  ok ?
14:04:14 <drdo> You can generate nodes that have that property just by filtering from a completely random generation
14:04:24 <ph88> yes how am i going to determine "needsSpace" what you put there
14:04:47 <drdo> "if i can just inspect what has been randomly generated to see if that needs a space in between or not"
14:04:50 <drdo> You said this yourself
14:05:09 <ph88> "A" and "B" (on the left) need a space,  on the right "A" and "(" don't need a space
14:05:11 <drdo> That's what "needsSpace" is
14:05:26 <ph88> but how do i inspect it ? i don't know, that's what i'm asking
14:05:37 <drdo> inspect what?
14:06:01 <Mins> I'm still fighting with what I should write in unzip2: http://lpaste.net/edit/335879426233335808
14:06:55 <ph88> drdo, the characters in the other node
14:07:37 <drdo> I'm not sure what you mean by inspect
14:07:38 <ph88> they are not in the scope of my Arbitrary function
14:07:47 <dmwit> ph88: 1. Having parentheses as strings in your AST smells bad. 2. Surely "whether a space is needed or not" is a thing to worry about in the pretty-printer, not in the AST generator.
14:07:48 <ph88> each node has it's own arbitrary function
14:07:50 <Mins> Aaaand my unzip1 is not right, too.
14:08:15 <drdo> ph88: you generating top down
14:08:17 <drdo> *you are
14:09:10 <ph88> yes
14:09:21 <ph88> this is a better image  https://imgur.com/a/tR7tw
14:09:22 <drdo> r <- genNode
14:09:22 <drdo> l <- if needsSpace r then genNeedsSpaceNode else genNode
14:09:40 <drdo> ph88: The details aren't important
14:09:41 <drdo> It's a tree
14:09:43 <ph88> if i'm the yellow right node arbitrary function then i don't know what was before it
14:10:12 <drdo> ph88: But when you generate the top node you do
14:10:22 <dmwit> ph88: Show us the code for your actual AST. Presumably you have one, since you say you have a parser.
14:10:44 <drdo> I mean, this isn't even about haskell, just a misunderstanding about basic recursion
14:10:46 <dmwit> Or, for bonus points, a minimized AST that only has the kinds of nodes that make things difficult.
14:11:07 <Psybur> So I have a function that returns a StateT. How can I wrap this function in a catch without getting errors about everything now expected to be IO and not StateT D:
14:11:32 <ph88> drdo, yes when i have the top node (which is the end result of the arbitrary AST generation) i have all the information there ... then i could traverse the entire AST somehow .. but then i still don't know how to piece together the RED arrow in my image
14:12:32 <dmwit> Psybur: There is MonadBaseControl. But beware that the semantics of catch and similar things is generally "it does what the code does", not "we thought about what we wanted to happen generally and then made sure that happened".
14:12:37 <Psybur> Reading https://www.schoolofhaskell.com/user/snoyberg/general-haskell/exceptions/exceptions-and-monad-transformers hopefully this will help
14:14:28 <drdo> Psybur: Use Control.Exception.Lifted
14:14:35 <drdo> But read that too
14:15:12 <ph88> dmwit, here is a small part of the code https://bpaste.net/show/7f5a05bd5ced
14:15:14 <dmwit> (N.B. Control.Exception.Lifted uses the MonadBaseControl mechanisms I mentioned above, with the same caveats.)
14:16:42 <ph88> drdo, how do i know which node represents the previous and next node in relation a given node ?
14:17:07 <drdo> What does previous and next mean?
14:17:14 <drdo> Remember we're talking about trees here
14:17:18 <drdo> That's what the T in AST means
14:17:25 <Mins> I need help. Zip1/Unzip1 is working. Zip2 and Unzip2 are getting pattern errors, because I'm using "head". Idk what to do.
14:17:26 <ph88> it means when i have some tokens like "A" "B" that token "B" follows (next) token "A"
14:17:42 <ph88> drdo, so "A" is the previous token of "B" when the sequence is "AB"
14:18:19 <drdo> ph88: Work it out 
14:18:37 <ph88> i don't have a relation between the tokens anymore when i have the tree
14:18:51 <dmwit> ph88: I'm guessing that your issue is about how to generate t_space for T.
14:18:58 <drdo> Wait, you have spaces in the AST?
14:19:00 <ph88> if i had a double linked list of tokens together with the tree i could move easily and inspect previous and next
14:19:13 <ph88> dmwit, yes i need to insert some t_space sometimes
14:19:15 <drdo> ph88: Are you sure you're familiar with the idea of an AST?
14:19:23 <dmwit> ph88: So I would write two `Gen`erators, one for `T`s that need space and one for `T`s that don't.
14:19:38 <drdo> dmwit: That's the first thing I said :P
14:19:47 <ph88> drdo, yes i have spaces in my AST .. it's in fact not an abstract syntax tree but a concrete syntax tree. Maybe i should have mentioned that before ^^
14:19:49 <dmwit> ph88: Then the `arbitrary`s for types that contain `T`s can call the appropriate one.
14:20:13 <drdo> ph88: But why is it a tree then?
14:20:28 <dmwit> ph88: e.g. `arbitrary = do { nt <- arbitrary; t <- if needSpacesesBefore nt then tWithSpaces else tWithoutSpaces; return (GTD t nt) }`
14:20:48 <ph88> dmwit, in the arbitrary functions of a type i don't know which token will be following
14:21:12 <drdo> ph88: Where's the tree?
14:21:14 <dmwit> ph88: Your `Gen`erators do not need to be named `arbitrary`. You can pick any old name you like.
14:21:44 <ph88> drdo, the tree is on line 1 in https://bpaste.net/show/7f5a05bd5ced where T is one branch, (NT Identifier) is another branch.
14:21:49 <dmwit> ph88: `arbitrary` is for when there is one canonical `Gen`erator for that type. If you do not have one canonical `Gen`erator, don't use `arbitrary.`
14:21:53 <dmwit> oh no
14:21:58 <dmwit> I put the . inside the quotes by accident
14:22:06 <ph88> drdo, tree is also in this image https://imgur.com/a/tR7tw where starting at blue and to to another blue and a yellow
14:22:18 <drdo> wait what
14:22:29 <drdo> That's literally a fixed structure tree
14:22:47 <drdo> technically a tree I suppose
14:22:54 <ph88> dmwit, i defined all terminals that they hold the spaces AFTER the terminal, so i can not insert spaces with the same terminal
14:23:20 <drdo> I understand the issue even less
14:23:26 <dmwit> ph88: I do not understand this complaint.
14:23:40 <ph88> :(
14:23:42 <dmwit> What does "insert spaces with the same terminal" mean and why do you think you need to do it?
14:24:07 <ph88> dmwit, i was responding to your code   arbitrary = do { nt <- arbitrary; t <- if needSpacesesBefore nt then tWithSpaces else tWithoutSpaces; return (GTD t nt) }
14:24:16 <ph88> what's "tWithSpaces"  ?
14:24:35 <dmwit> Code you write of type `Gen T`, which sets `t_space` to have some spaces in it.
14:24:47 <ph88> t_space is only for spaces that follow the terminal
14:24:52 <dmwit> Meanwhile, `tWithoutSpaces :: Gen T` and sets `t_space` to something which may not have spaces in it.
14:25:04 <drdo> ph88, dude come on now
14:25:06 <dmwit> ph88: I don't understand why that matters.
14:25:41 <ph88> if needSpacesesBefore nt then tWithSpaces     Code you write of type `Gen T`, which sets `t_space` to have some spaces in it.
14:25:43 <dmwit> Or rather, I do understand why that matters and believe I addressed that.
14:26:04 <ph88> if needSpacesBefore then (tWithSpacesAfter)  ??
14:26:07 <dmwit> Specifically: you need not generate a `T` before you know what follows it, and my proposed code in fact does not.
14:27:02 <Mins> Could someone help me? I don't know how to use "let" and need to send my homework in 34 minutes. http://lpaste.net/335879426233335808
14:27:08 <ph88> i had some specific reasons to put the spaces after the terminal .. i'm gonna look in my code i thought i made a comment about it
14:27:40 <dmwit> But why are you going to check that? I have accepted that you want to put spaces after the terminal.
14:27:44 <dmwit> You don't need to convince me.
14:28:03 <drdo> ph88: Dude, it doesn't matter
14:28:12 <drdo> generate the right, check if it needs spaces
14:28:20 <drdo> if yes generate something with space, if not ...
14:28:54 <dmwit> Mins: Okay, I'll bite. Why not write `unzip2 = unzip1`?
14:29:16 <Mins> dmwit: because we need to use "let" and "case".
14:29:32 <Mins> I could use "zip"/"unzip" also, but we need to write it with cases and lets
14:29:43 <ph88> thinking ..
14:29:49 <Mins> zip1/unzip1 works. zip2 and unzip2 don't work
14:30:23 <dmwit> Mins: In zip1 and unzip1, you check whether various lists are empty. Where do you do these checks in zip2 and unzip2?
14:30:50 <Mins> line 15/16 in zip2?
14:31:15 <dmwit> Mins: Also: in zip2, when you write `zip2 xs ys = let zip2 ... = ... in ...`, you have redefined `zip2`. I very much suspect you did not mean to do this.
14:31:31 <Mins> Ah, oh. So I need to look for that before I write "let"?
14:31:35 <dmwit> ?let x = let x = 3 in 4
14:31:36 <dmwit> > x
14:31:37 <lambdabot>  Defined.
14:31:39 <lambdabot>  error:
14:31:39 <lambdabot>      Ambiguous occurrence ‘x’
14:31:39 <lambdabot>      It could refer to either ‘Debug.SimpleReflect.x’,
14:31:43 <dmwit> ?undefine
14:31:43 <lambdabot> Undefined.
14:31:51 <dmwit> ?let example = let example = 3 in 4
14:31:52 <lambdabot>  Defined.
14:31:53 <dmwit> > example
14:31:55 <lambdabot>  4
14:32:13 <Mins> edited.
14:32:14 <ph88> dmwit, so i need two functions, an arbitrary for GTD and a needSpacesBefore (nt :: NT Identifier)  right ?  but is it possible to derive this using generics? because this will be the same repitions everywhere
14:32:16 <dmwit> ?let moreComplicatedExample = let moreComplicatedExample = 3 in (moreComplicatedExample, 4)
14:32:18 <lambdabot>  Defined.
14:32:20 <dmwit> > moreComplicatedExample
14:32:23 <lambdabot>  (3,4)
14:32:30 <ph88> drdo, thanks for being patience, i just have a hard time to explain it
14:32:59 <Mins> dmwit: [(ERROR - C stack overflow
14:33:07 <dmwit> I don't know whether it can be derived, but I sort of doubt it, since this is a question about the meaning of your values and not their structure.
14:33:44 <ph88> :'(
14:34:10 <ph88> if i implement it like this, it will add like 2000 lines of code ... for something that was on the parser just 1 lookahead
14:34:15 <dmwit> Mins: Guess what `let xs = drop 1 xs` does? =)
14:34:21 <ph88> that's why i'm very stuck with this
14:34:25 <dmwit> > let xs = drop 1 xs in xs
14:34:29 <lambdabot>  *Exception: <<loop>>
14:34:52 <adrien91> Hey guys I was wondering how I could implement an infinite grid, my first thought was an infinite list of infinite lists, but that doesnt work. Any other suggestions? Thanks
14:34:57 <Mins> Oops. Corrected, it works!
14:34:59 <Mins> Thanks!
14:35:14 <Mins> I think I'll get unzip2 aswell
14:35:28 <drdo> ph88: Honestly, I would go back and learn some basic programming, pick a good book
14:35:30 <EvanR> adrien91: there is a package called total map somewhere
14:35:31 <Welkin> all you need is gzip
14:35:49 <danielsmw> adrien91: how about an infinite list of (x,y) tuples?
14:35:50 <EvanR> adrien91: a total map with keys in (Integer,Integer) would be an infinite grid. 
14:35:51 <Welkin> drdo: haskell is a good language to learn for someone who knows nothing about programming
14:36:04 <adrien91> EvanR: thanks Ill check that
14:36:05 <drdo> Welkin: I don't care about the language, just programming in general
14:36:07 <Welkin> I would say ti is more difficult to learn if you already know a language
14:36:20 <Welkin> because you already have ideas about what "programming" is
14:36:24 <drdo> Basic programming techniques
14:36:25 <danielsmw> lyxia: hey, I am still working on the ad problem.
14:36:26 <dmwit> ph88: Well, it will be a lot easier if you do not demand that `prettyprint . parse = id`. =)
14:36:36 <dmwit> ph88: (Though relaxing that is not always an option.)
14:36:46 <Welkin> EvanR: total map? Like a total body workout?
14:36:50 <danielsmw> lyxia: as i mentioned, the issue was that I needed to take the code you got to compile, but take a derivative of aZ + daZ
14:36:51 <EvanR> yeah
14:37:14 <Welkin> drdo: you mean assembly?
14:37:20 <Psybur> Is all that ridiculous boilerplate at the end of this article really necessary to wrap a stack in catch? https://www.schoolofhaskell.com/user/snoyberg/general-haskell/exceptions/catching-all-exceptions
14:37:21 <drdo> Welkin: no
14:37:29 <EvanR> (Integer,Integer) -> a would also work, and is more flexible, but less performant on updates
14:37:35 <Mins> Nah, I can't do it :( 
14:37:35 <Mins> http://lpaste.net/335879426233335808
14:37:42 <Mins> unzip2 still didn't work
14:38:22 <dmwit> Mins: Okay. Try running `unzip2 [(3,4)]` by hand.
14:38:27 <Psybur> nvm, seems its a bunch of stuff for the async library
14:38:34 <dmwit> Mins: You will v. quickly see what went wrong, I promise.
14:38:45 <Mins> Ah, okay
14:38:52 <dmwit> Mins: Or turn on all the warnings and GHC will tell you what went wrong. =)
14:38:56 <Mins> [(d,e)] -> ([d],[e])
14:40:59 <Mins> It works. Thank you dmwit!
14:41:12 <Mins> No
14:41:15 <Mins> ._.
14:41:24 <Mins> forgot the "2" at "unzip" :x
14:41:29 <butterthebuddha> Has anybody here done hw5 of CIS194/Spring13
14:42:31 <butterthebuddha> How do I avoid the "Ambiguous occurrence" error when I import StackVM?
14:43:57 <dmwit> I don't know much about HW5 of CIS194. But "ambiguous occurrence" happens when you import two modules that both define a name, and then refer to that name. Mitigations are to hide that name from one of the imports or to use a qualified name to disambiguate.
14:44:39 <Psybur> This seems a bit excessive to have to have a dependency on async to do the catchAny in that article haha
14:45:00 <dmwit> I have a detailed introduction to Haskell's module system here that may be useful to you: https://stackoverflow.com/a/8331995/791604
14:45:42 <dmwit> (You can obviously stop reading at the paragraph that says "Here ends the bare basics you need to understand about the module system.".)
14:47:07 <Mins> I'm trying, but I don't get it dmwit
14:47:50 <dmwit> Mins: Okay. Let's try together. We're going to evaluate `unzip2 [(3,4)]`.
14:47:56 <dmwit> Mins: What is the first evaluation step?
14:48:37 <Mins> I look if it's an empty list
14:48:48 <dmwit> Right. Is it an empty list?
14:48:53 <Mins> and it's not, so ->
14:49:12 <Mins> headxy is now my head of the list... x is now the first element of the head, y the second
14:49:23 <Mins> yx is now the list without the head
14:49:29 <dmwit> all right so far
14:49:52 <Mins> and now I take (x,y) and (:) with the next element
14:49:58 <dmwit> whoa whoa whoa
14:50:03 <Mins> What's wrong here?
14:50:17 <dmwit> I don't see `(x,y)` anywhere in the definition of `unzip2`.
14:50:27 <dmwit> Are we looking at http://lpaste.net/335879426233335808 ?
14:50:54 <Mins> Yes...
14:51:36 <dmwit> Okay. I don't see `(x,y)` anywhere in the definition of `unzip2`.
14:51:50 <dmwit> If I read it carefully, what *I* find is that the next thing we do is return the value of `unzip2 yx`.
14:52:03 <dmwit> And you told me `yx` was the list `[(3,4)]` without its head, which is...?
14:52:55 <Mins> []?
14:53:13 <dmwit> Right. So I think where we have arrived now is `unzip2 [(3,4)] = unzip2 []`.
14:53:16 <dmwit> Whoops!
14:54:01 <Mins> Aaaah...
14:54:12 <Mins> And I still don't know how to correct
14:54:25 <dmwit> Take some inspiration from unzip1. =)
14:55:02 <Mins> To be honest I don't see it
14:56:02 <dmwit> Hm. Well, I'm not sure at this point how I can give further hints without giving away the whole shebang.
14:56:17 <Welkin> the whole #!
14:56:33 <dmwit> Perhaps this: you have defined `x` and `y`, but not used them anywhere in the answer. That can't be right; so think about how you can use them.
14:57:02 <EvanR> so an XY problem
14:57:14 <Welkin> what's that?
14:57:22 <EvanR> nevermind
14:57:38 <alexteves> https://meta.stackexchange.com/questions/66377/what-is-the-xy-problem
14:58:09 <Mins> I think with "(x, y)" I've used it?
14:58:34 <Mins> I got three minutes to send my answer >.<
15:00:04 <Welkin> Mins: what is this? a hostage negotiation?
15:00:09 <dmwit> Mins: You've used it, but it doesn't mean what you want it to mean.
15:00:10 <alexteves> roflmao
15:00:48 <dmwit> Mins: Also, harsh as it sounds, Welkin is right: your urgency is not our fault nor our responsibility.
15:00:55 <Mins> I know
15:01:12 <Mins> But I'm looking at the code and I don't know what I'm meaning here
15:01:24 <Mins> So what I've written that doesn't work like I want to have it
15:02:37 <dmwit> The outermost function call in your result is `(:)`. That is the constructor for lists. You want to return a tuple. The constructor for tuples is `(,)`, not `(:)`.
15:03:13 <dmwit> (This kind of type-oriented programming is frequently useful, by the way.)
15:03:49 <Mins> But I want to concatinate the tuples... or not?
15:04:03 <dmwit> (Where you look at what type you want to return, and try to pick a constructor for that type and then fill in the "holes" with a value of the types needed for each argument to that constructor.)
15:04:03 <Mins> In a list?
15:04:32 <dmwit> I don't really feel comfortable saying much more, I'm afraid.
15:04:40 <Mins> Okay. Thank you
15:05:41 <Mins> I don't know how I can make a list of [xs] and [ys]
15:10:58 <pacak> Mins: Out of what?
15:11:16 <dmj`> :t zip
15:11:18 <lambdabot> [a] -> [b] -> [(a, b)]
15:11:39 <pacak> @src zip
15:11:39 <lambdabot> zip (a:as) (b:bs) = (a,b) : zip as bs
15:11:39 <lambdabot> zip _      _      = []
15:12:01 <pacak> pattern match on both lists and repeat
15:12:24 <Welkin> write a recursive function to learn how it works first
15:12:29 <Welkin> rather than just using `zip`
15:12:59 <Welkin> implement your own `zipWith`
15:14:31 <Mins> It's working now
15:14:47 <Mins> Thank you
15:15:44 <dmj`> Mins: did the 3 mins expire?
15:15:51 <Mins> Yes
15:16:03 <dmj`> Mins: what happens now
15:16:14 <Mins> Now I got 0 points
15:17:29 <Welkin> I would hate to take a haskell class in uni
15:17:35 <Welkin> because then haskell becomes work
15:17:35 <EvanR> o_O
15:17:44 <Welkin> the class ruins it (like most things)
15:17:46 <EvanR> i thought you did haskell for work
15:17:47 <Welkin> same thing happened with math
15:18:03 <Welkin> I have used haskell for a client before, but I mostly do js and ruby right now
15:20:55 <altron> Hi, I'm trying to build ncurses but I'm getting an error saying "no location info error: module UI.NCurses cannot be found locally."
15:32:29 <orion> Welkin: Math at a university ruined it for you?
15:32:54 <Welkin> ruined math
15:33:18 <Welkin> a terrible programming class also almost ruined programming
15:34:07 <EvanR> undergrads are rarely in a position to evaluate the quality of their environment
15:34:57 <EvanR> allegory of the cave maybe
15:35:41 <alexteves> yeah, I didn't know at the time, but I'm pretty sure nowadays that most of my teachers sucked at programming
15:37:16 <Welkin> EvanR: the classes were objectively terrible, even looking back on them now
15:37:36 <boj> had a professor miss half his classes for skiing, late 15 minutes the rest of the time, and outright told me the people doing the best work in his class weren't even coming and just doing homework out of the textbook :(
15:37:50 <EvanR> all universities are a racket, the best you can do is learn to learn by yourself as fast as possible and drop out
15:38:02 <Welkin> I did drop out
15:38:12 <Welkin> but only because I was forced due to lack of funding
15:38:20 <Welkin> after 4 years of studying though
15:38:45 <Welkin> I took a lot of random classes that I enjoyed, like anthropology and philosophy
15:38:51 <EvanR> you could have spent 4 years surveying the courses without spending all the money
15:39:00 <Welkin> I almost switched my major to anthropology
15:39:04 <boj> hindsight
15:39:08 <Mattshu> coulda shoulda 
15:39:19 <Welkin> I am still paying off the loans
15:39:22 <Welkin> but no degree :P
15:39:28 <Welkin> it doesn't make any difference though
15:40:03 <EvanR> luckily haskell is peppered with $
15:43:15 <Hafydd> Haha.
16:22:24 <Donovan> working my way through this example, I'm running across a type error when i try to implement Tim's pretty printer: http://www.timphilipwilliams.com/posts/2013-01-16-fixing-gadts.html has anyone here gone through this before?
16:22:46 <Donovan> specifically, it's on the line `alg (Add x y)    = (\x y -> parens $ x <+> text "+" <+> y) <$> x <*> y`
16:29:12 <Welkin> has anyone successfully used markdown with literate haskell?
16:33:45 <EvanR> ok
16:34:29 <EvanR> Applicative for r -> a is giving me hope
16:34:58 <pacak> Welkin: I used it to make slides for a talk. Kind of worked.
16:35:20 <benzrf> EvanR: it's pretty good
16:36:48 <EvanR> poor mans FRP: http://lpaste.net/360076
16:38:28 <Welkin> I found this https://passingcuriosity.com/2008/literate-haskell-with-markdown-syntax-hightlighting/
16:38:39 <benzrf> shipTheta more like shipTheseus
16:38:41 <Welkin> but even still, I lose markdown syntax highlighting
16:38:54 <EvanR> what use is the Reader monad ?
16:39:04 <Welkin> I can have haskell syntax highlighting anf formatting, or markdown, but not both
16:39:26 <Welkin> EvanR: ReaderT is very useful for storing database connection information and API keys
16:40:04 <EvanR> ok theres that
16:40:05 <Welkin> in my editor*
16:40:09 <benzrf> EvanR: its useful as a transformer
16:40:40 <orion> I want to make a CLI based application whose UX is similar to mitmproxy: http://docs.mitmproxy.org/en/stable/_images/mitmproxy-intercept-options.png Will this be painful in Haskell?
16:41:04 <Tuplanolla> Brick should make it quite pleasant, orion.
16:41:33 <Welkin> I have been looking at brick recently for writing a rogue-like and it looks very good
16:41:35 <orion> Oh, cool.
16:41:42 <orion> Never heard of it before.
16:42:13 <EvanR> its a freakin spreadsheet (tm)
16:50:57 <theobromine> something i don't understand is why chisel/scala seems to be a 'popular' language for hardware design but haskell isn't,... what gives?
16:59:33 <sm> orion: I would call that a TUI or curses-style UI
17:00:16 <sm> and +1 for brick
17:35:29 <seafood> Could anyone here provide me a link to some reasonable documentation on the -fexternal-intepreter flag of GHC?
17:40:04 <dmwit> ?pl \w -> eqForce (wEqns w) w
17:40:04 <lambdabot> eqForce =<< wEqns
17:40:20 <dmwit> EvanR: You found a use for the Reader monad and didn't even recognize it.
17:41:05 <EvanR> well
17:41:35 <EvanR> great
17:41:55 <EvanR> but i dont want to be using monad tricks wildly in the main code
17:42:14 <dmwit> That is a sensible choice.
17:43:16 <seafood> Anyone?
17:47:19 <dmwit> I don't see that flag in the flag reference documentation here https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/flags.html
17:48:52 <MarcelineVQ> dmwit: it's a flag for ghci looks like a documentation oversight to not have it in the flags listing though
17:48:54 <dmwit> ...so I suspect it may not be documented anywhere.
17:49:01 <MarcelineVQ> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/ghci.html#stack-traces-in-ghci
17:49:36 <MarcelineVQ> additional info https://simonmar.github.io/posts/2016-02-12-Stack-traces-in-GHCi.html
17:49:47 <MarcelineVQ> ^ seafood
17:49:59 <dmwit> Yay, I'm wrong!
18:06:01 <kerrhau> I'm learning haskell using lyah but dont really have any applications for haskell
18:07:06 <kerrhau> what are some practical applications for haskell?
18:07:35 <seafood> MarcelineVQ: Thanks. Those were just what I needed.
18:11:44 <zRecursive> kerrhau: You can try xmonad first.
18:40:58 <pavonia> In a Parsec parser "sepBy1 p (char '-')", how do you make p parse some other parser q or the empty string?
18:44:57 <geekosaur> (optional p) ?  but that sounds like an odd thing to do in the context of sepBy1
18:45:36 <pavonia> Yeah, maybe that's not even the right combinator in the first place
18:45:40 <geekosaur> did you actually intend zero or more? if so you probably wanted sepBy
18:46:23 <pavonia> What I want to do is to parse number of lines where each line can be of a certain format or empty. The empty lines should be discarded
18:50:01 <geekosaur> probably use optional and then fmap catMaybes over the result?
18:51:47 <pavonia> Sounds good, thanks
18:54:05 <geekosaur> you could do it without that but you won't be able to reuse sepBy1; you'd have to make your own combinator with the skip-empties logic built into it
18:54:29 <cps> Hello! I am curious if these docs on monad performance are still up to date: https://wiki.haskell.org/Performance/Monads
18:54:50 <cps> It links to folk from 2007 verifying the claim: http://r6.ca/blog/20071028T162529Z.html
18:55:05 <cps> But I don't know what has happened in the 10 years since then.
18:55:28 <cps> Also, is GHC just better at optimizing functions than other things?
18:55:39 <cps> I don't feel I have an intuition for why this might be true.
18:59:35 <cps> Anyone have thoughts on the CPS questions?
19:06:08 <cps> Okay, I'll come back and try again later!
19:06:50 <Golden_Skittle> if I am using stack, can I use ghci to run functions from anywhere in my fileset
19:06:59 <Golden_Skittle> like main, lib, etc.
19:24:30 <lyxia> "stack ghci"?
19:34:40 <codedmart> Anyone familier with http-api-data? I am trying to use `FormUrlEncoded` and one of my record attrs is `[(Text, Text)]` which there isn't an instance of `ToHttpApiData`.
19:35:37 <codedmart> I see that `ToHttpApiData` has `toUrlPiece` which is `a -> Text`. But I am not sure how `[(Text, Text)]` should translate for proper url encoding.
19:36:54 <Axman6> how do you want [("foo","bar"),("lol","ok")] to be encoded?
19:37:21 <codedmart> Axman6: That is what I am not sure about? I don't know what the proper encoding for that is.
19:37:41 <Axman6> well, what is it?
19:37:48 <codedmart> I am trying to post to an api that accepts application/x-www-form-urlencoded
19:38:35 <Axman6> so they're key, value pairs?
19:39:15 <geekosaur> this isn't a language question. you need to figure out what the api wants to see for that
19:39:39 <Axman6> what are you _actually_ trying to do? are you making a request to some service?
19:39:52 <Axman6> if so, why not use something like wreq?
19:42:15 <codedmart> You are right. This isn't really a haskell question.
19:42:17 <codedmart> Sorry for that.
19:42:30 <codedmart> Basically I have something like this. https://gist.github.com/codedmart/cd8e6ba5676e254803530498f988a3b0
19:42:39 <codedmart> `No instance for (ToHttpApiData ExtraData)`
19:43:39 <codedmart> I understand I need to add a `ToHttpApiData`. I am just not sure what the final `Text` should look like. So I will research that more.
19:43:40 <codedmart> Thanks
21:11:22 <Lokathor> http://taylor.fausak.me/2017/11/15/2017-state-of-haskell-survey-results/#question-21
21:11:35 <Lokathor> DeriveFunctor outranked GeneralizedNewtypeDeriving :/
21:11:36 <Lokathor> what
21:12:15 <cps> Has anyone experimented with CPS conversion of monad transformers?
21:12:26 <LiaoTao> As a Newbie I've already used OverloadedStrings, GADTS and DeriveGeneric
21:12:32 <cps> I found https://wiki.haskell.org/Performance/Monads today and was kind of surprised.
21:12:36 <LiaoTao> Maybe BangPatterns
21:13:04 <Lokathor> sure, sure, but have you used DeriveFunctor and _not_ used GeneralizedNewtypeDeriving ?
21:13:25 <cps> In my case, I am interested in using it for a stack of ErrorT, StateT, and IO
21:13:36 <cps> Has anyone tried something like this?
21:13:41 <LiaoTao> Lokathor, No idea :)
21:13:54 <Lokathor> :P
21:16:24 <cps> Who might know about this sort of stuff?
21:16:34 <cps> Is there some time it'd be better to come back?
21:17:00 <LiaoTao> cps, Patience
21:17:33 <lyxia> cps: daytime over the Atlantic ocean
21:18:14 <cps> lyxia: to catch EU and NA both awake I guess
21:18:18 <cps> Makes sense :)
21:19:30 <lyxia> cps: Your question is also quite broad
21:19:45 <lyxia> Do you have a more specific problem?
21:21:05 <jle`> cps: people do do it
21:21:17 <jle`> cps: well
21:21:31 <jle`> actually people usually use it to define their own monads 'from scratch'
21:21:32 <emmanuel`>  hello there, I've just installed ghc-8.2.1, and I'm seeing that a lot of packages can't be installed (GHC is reporting missing files in a number of packages already installed)
21:21:40 <jle`> cps: instead of using monad transformers
21:21:44 <cps> Basically, I have a quite a lot of code that uses a custom monad. I'd like to make it faster, but it'll be quite a big time commitment to try it out. So it's risky and I was wondering if others have had good experiences
21:21:58 <emmanuel`> Has this happened to anyone else? 
21:22:03 <jle`> cps: ah yes, that's what i mean
21:22:10 <jle`> but i don't think it's as big a commitment as you think it might be
21:22:21 <jle`> all you have to do is change the type definition?
21:22:25 <jle`> the external interface would still be the same
21:22:38 <cps> My monad is kind of odd, so I'm not sure it's totally possible
21:22:41 <cps> One sec
21:23:05 <jle`> cps: but yeah, i was confused at first.  `StateT s (ExceptT e IO) a`, for instance, is not a monad transformer
21:23:17 <jle`> but you can define an equivalent monad from scratch in CPS style
21:23:23 <jle`> and people do do similar things for performance reasons
21:24:03 <cps> Do you know why it is so much faster? That's the part that I don't really get. It seems like generating tons of closures would be costly.
21:24:20 <cps> I think that's part of why I am curious about this topic
21:24:29 <cps> (Also, working on getting a concrete example.)
21:26:22 <jle`> i'm not quite sure actually
21:26:35 <jle`> i just know that people usually make these transformations after much profiling
21:26:46 <jle`> and benchmarking
21:29:17 <cps> http://lpaste.net/4416051237347131392
21:29:25 <lyxia> cps: closures are almost as cheap as algebraic datatypes in terms of memory usage. Just replace the constructor tag with a pointer to the function to call.
21:29:56 <cps> I've had success in CPS converting a parser, but I am not sure the case I have can do it.
21:30:20 <jle`> is Bag anything special?
21:30:22 <lyxia> cps: and calling them is just a jump without lookup, as opposed to pattern-matching
21:30:23 <cps> Even anonymous functions turn into function pointers?
21:30:27 <cps> Not really
21:30:39 <cps> one sec
21:30:54 <cps> It is (data Bag a = Empty | One a | Two (Bag a) (Bag a))
21:31:10 <cps> So it's basically a list, but with O(1) append
21:31:42 <jle`> so like a Seq wit O(n) uncons? :)
21:31:45 <cps> that means I can get warnings from different code paths and it isn't O(n) in the number of warnings to merge them
21:31:45 <jle`> *with
21:32:12 <EvanR> if you dont care about ordering...
21:32:20 <cps> Well, I never do uncons, so it's not even defined. But yeah, that'd be the asymptotics of it :)
21:32:32 <lyxia> I think there's also more inlining possible, partly because of laziness, I don't remember a good example offhand.
21:32:40 <cps> Order is maintained
21:32:56 <EvanR> i mean if you dont care about ordering you might be able to unbag stuff faster
21:33:10 <cps> Ah, gotcha
21:33:20 <cps> Probably not my bottleneck
21:33:34 <cps> So the problem I see is that I think I do not follow the monad laws
21:33:43 <cps> But it's actually pretty important not to
21:33:50 <cps> At least as far as I can tell
21:33:57 <jle`> so it looks like overall you have something like ExceptT e (Writer (info, Bag warning))
21:34:15 <jle`> i am pretty sure this can be cps'd
21:34:27 <cps> Basically, you want to report as many errors as possible, so if you fail immediately, it is leaving a bunch of things unreported
21:34:39 <cps> That's the crucial difference with ExceptT
21:34:57 <cps> So the Functor and Applicative actually merge errors
21:35:13 <cps> But in the Monad instance cannot do that
21:36:01 <cps> In other words, laws are broken, but it means I can get much more complete error messages. So finding a way to implement Applicative with CPS is the hard part I think
21:36:11 <cps> Does that make sense?
21:37:16 <lyxia> If it's "just" error reporting, it's not that bad
21:37:31 <lyxia> The monad laws are satisfied "up to" failure states
21:38:24 <cps> Yeah, it's only for the error reporting
21:38:45 <dmwit> cps: http://hackage.haskell.org/package/these-0.7.4/docs/Control-Monad-Chronicle.html
21:39:07 <lyxia> If you're still worried about them you can define an actually lawful Applicative instance and provide the error-merging combinators separately
21:39:34 <lyxia> Maybe even an Applicative-but-not-Monad newtype.
21:39:36 <cps> And it's more that (f <$> ra <*> rb) is not the same as (do { a <- ra; b <- rb; return (f a b) }) and I'm not actually seeing any laws about that anywhere
21:40:35 <cps> The difference is that the first case may give errors from ra and rb, but the second case would stop if ra had errors.
21:40:51 <lyxia> cps: Exporting a separate operator is what I did for aeson https://github.com/bos/aeson/pull/597
21:42:04 <lyxia> cps: https://hackage.haskell.org/package/base-4.10.0.0/docs/Control-Monad.html that law can be derived from   pure = return, (<*>) = ap
21:42:11 <dmwit> cps: Also, the law of relevance here is probably `(<*>) = ap`.
21:42:23 <cps> Interesting. Well, it sounds like the next step is to figure out a CPS way to make liftA2 accumulate both sets of errors :)
21:42:56 <dmwit> ?src ap
21:42:56 <lambdabot> ap = liftM2 id
21:42:59 <cps> lyxia and dmwit, okay, that makes sense! I knew it was bad :)
21:43:32 <dmwit> cps: But do check out MonadChronicle (and especially ChronicleT). I have used it for storing multiple errors in a parser before with great success.
21:43:38 <cps> Hmm, actually, isn't liftM2 defined as liftA2 now? I get the picture though
21:43:51 <cps> Looking through now :)
21:44:46 <dmwit> No, liftM2 is Monad-specific even in the latest base. https://hackage.haskell.org/package/base-4.10.0.0/docs/src/GHC.Base.html#liftM2
21:45:29 <dmwit> "Caution: since this may be used for `liftA2`, we can't use the obvious definition of liftM2 = liftA2."
21:45:46 <cps> Is the trick in chronicle that Data.These accumulates errors alongside successes?
21:45:53 <dmwit> yes
21:46:31 <cps> Now when CPS converting, it seems like the perf comes from avoiding error allocations
21:46:32 <dmwit> So it has both This (for errors that should abort parsing) and These (for errors that should be accumulated and continue parsing).
21:46:40 <cps> So maybe there's two closures?
21:48:13 <dmwit> (Or, well, confess and disclose.)
21:49:24 <cps> newtype Chronicle a = Chronicle { _run :: forall e r. (Bag e -> a -> Either (Bag e) r) -> Either (Bag e) r }
21:49:31 <cps> Maybe?
21:50:00 <dmwit> Oh, well, I suppose there ought to be three continuations, one each for the three constructors of These.
21:51:04 <dmwit> But I've always been terrible at CPS.
21:51:32 <cps> return a = Chronicle (\k -> k Bag.empty a)
21:51:39 <cps> dmwit: me too :)
21:51:46 <jle`> (a, b) =>  forall r. (a -> b -> r) -> r
21:52:04 <jle`> Either e a => forall r. (e -> r) -> (a -> r) -> r
21:52:29 <cps> failure e = Chronicle (\k -> k (Bag.one e) ....)
21:52:36 <cps> Okay, so that one doesn't work
21:52:55 <jle`> so what you have is (w, Either e a) => forall r. (w -> (e -> r) -> (a -> r) -> r) -> r, i'd think?
21:52:55 <cps> So yeah, I guess it needs at least two.
21:53:10 <cps> Yeah, I think so!
21:53:16 <jle`> oh i think i did that wrong
21:53:35 <cps> (Bag e -> a -> r) for the second one
21:54:17 <jle`> yeah, replace w with (info, Bag w), and e with (Bag e)
21:54:18 <cps> Is having two possible continuations fine for perf? I always feel weird about that.
21:55:08 <jle`> only way to answer is to benchmark :)
21:55:18 <cps> forall r. (info -> Bag w -> (Bag e -> r) -> (Bag e -> a -> r) -> r
21:56:03 <jle`> forall r. (info -> Bag w -> (Bag e -> r) -> (a -> r) -> r) -> r, i'd think
21:56:29 <jle`> hm
21:56:33 <cps> I'll have to play with it. I guess the failure jumps back to wherever it needs to be.
21:56:44 <jle`> i am doubting myself
21:57:57 <a6a3uh> Hi! if I have 'm' which is a MonadState and MonadError. Which is an "idiomatic" way to repeat it until it throws an exception and get the state then?
21:58:22 <jle`> cps: yes i'm pretty sure that what i wrote was wrong
21:59:03 <jle`> a6a3uh: easiest way might be to just use explicit recursion?
21:59:43 <a6a3uh> jle`: I just thought there are some mote fun ways to do this)
21:59:47 <cps> I am so bad at CPS :D
22:00:26 <cps> It always feels slightly outside of my brain
22:01:19 <jle`> cps: heh sorry i don't have too much practice with this either.  we can take it step by step, though
22:01:56 <jle`> knowing that (a, b) => forall r. (a -> b -> r) -> r, and Either e a => forall r. (e -> r) -> (a -> r) -> r, the then you can just "plug" it in
22:02:08 <jle`> and then....we do some rearrangements....
22:02:19 <cps> I've got this at the moment:
22:02:39 <cps> forall r. ( (info -> Bag w -> Bag e -> r) -> (info -> Bag w -> Bag e -> a -> r) -> r )
22:02:59 <cps> so it's two cases, both can propegate info, warnings, and errors
22:03:24 <cps> Also, it's not actually equivalent to Either
22:03:32 <cps> I don't think
22:04:41 <jle`> oh hey that looks right i think
22:04:52 <jle`> except without the Bag e in the second one
22:05:57 <cps> I think I have fmap
22:06:05 <cps> I'll see if I can get liftA2
22:06:55 <dmwit> If I have `data Foo = Foo { foo :: Int }`, can I export `foo :: Foo -> Int` the selector without exporting `foo` the record updater?
22:09:17 <cps> jle`: here is fmap http://lpaste.net/5950888080092168192
22:09:30 <cps> Struggling with liftA2 though :)
22:11:06 <cps> Do you have the liftA2 for Either around?
22:11:18 <MarcelineVQ> dmwit: possibly by only exporting a synonym, see if this mention of selector here makes any sense https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#record-pattern-synonyms
22:11:19 <jle`> are you talking about the accmulatey liftA2 ?
22:11:21 <cps> Or for <*>
22:11:26 <cps> Yeah
22:11:29 <MarcelineVQ> dmwit: I know nothing about the subject however
22:11:58 <cps> I cannot figure out how to write any version of it though :)
22:11:59 <jle`> cps: Left e1 <*> Left e2 = Left (e1 <> e2)
22:12:14 <jle`> cps: Left e1 <*> Right _ = Left e1; Right _ <*> Left e2 = Left e2
22:13:03 <dmwit> MarcelineVQ: Thanks, looks relevant.
22:15:09 <jle`> cps: let me try to give it a shot
22:27:42 <cps> I think I got it jle` !
22:27:46 <cps> One sec
22:28:15 <cps> http://lpaste.net/1347945279344607232
22:33:05 <cps> Does it look correct?
22:35:07 <HaskellLord69>  I'm having trouble building my project in the haskell:8 docker container, it keeps complaining about a compiler mismatch
22:35:15 <HaskellLord69> found ghc-8.2.1 (x86_64), but expected minor version match with ghc-8.0.2 (x86_64)
22:35:28 <HaskellLord69> the resolver in my stack.yaml is lts-9.12
22:35:31 <HaskellLord69> how do I fix this
22:37:15 <cps> I think I have the Monad instance now as well
22:37:19 <jle`> cps: does it typecheck?
22:37:27 <cps> Haha, no idea :D
22:37:31 <cps> I'll check
22:37:35 <jle`> that's something yu should have, heh
22:37:38 <jle`> *you should try
22:37:58 <jle`> it's good to develop with the typechcker helping you
22:38:04 <jle`> that way you can use things like typed holes to help with development
22:38:54 <jle`> it makes things a lot smoother :)
22:40:00 <Axman6> HaskellLord69: try using haskell:8.0.2
22:40:14 <Axman6> see the other available tags on https://hub.docker.com/r/library/haskell/tags/
22:41:55 <cps> The part I showed you worked fine
22:42:12 <cps> (I tend to do pretty well not using the type checker for a while)
22:42:37 <cps> I didn't get the Monad instance right though
22:43:39 <HaskellLord69> Its getting pretty late... I didn't even see that tags tab up there. Thanks Axman6.
22:44:10 <HaskellLord69> I tried the ones listed in the readme, but it looks like 8.0.2 is doing the trick.  I got my gitlab CI working now.
22:47:38 <cps> jle`: here is the full thing http://lpaste.net/1347945279344607232
22:48:05 <cps> (I used lists to make it so I didn't have to figure out imports)
22:49:00 <cps> Verrrry curious to benchmark it. Gotta do some other clean up work first though.
22:49:28 <Axman6> have you seen the mtl-c package?
22:49:39 <dminuoso> ertes https://gist.github.com/dminuoso/dee20f83832ba02161c0445c0b73917a
22:49:39 <cps> Anyway, thanks a ton for talking through this! I feel more confident with CPS based on seeing the (,) and Either examples
22:50:21 <cps> Axman6: cool!
22:50:23 <cps> I have not
22:50:42 <cps> I don't think it'll cover the exact case I have, but I can probably use it elsewhere
22:51:36 <Axman6> if you keep playing with this stuff, be warned that the CPS versions are not exactly equivalent, there are things you can do with the non CPS versions which you can with CPS. like implement some of the mmorph classes
22:52:27 <cps> Should one of those "can"s be a can't?
22:52:40 <dminuoso> ertes: That `Var` is still a bit elusive for some reason. Im not exactly sure how this could be utilized.
22:53:00 <cps> (I don't know what mmorph is though, so probably it's okay?)
22:53:23 <Axman6> uh yeah
22:53:29 <dminuoso> Although I suppose the next thing I could do is construct an evaluator.
22:54:16 <cps> (Also, I am guessing it's the 2nd one, but I'm not super clear on everything here!)
22:54:59 <cps> Why does mtl-c say "Very strict CPS'd transformers"
22:55:08 <cps> I don't see any extra strictness yet
22:55:58 <dminuoso> Okay here might be a silly question but... if I constrain `data Num a => Expr a = ...` and define an instance Monad Expr, why is it not using the Num constraint?
22:57:17 <dminuoso> Relevant code: https://gist.github.com/dminuoso/19f61b0b3b665d08712cb9eef7dd11a8
22:57:58 <dmwit> Because that is the surprising and stupid semantics of DatatypeContexts.
22:58:16 <dmwit> The generally accepted best practice is to avoid that extension.
22:58:26 <dmwit> Put the `Num` constraint on the values that need it, instead.
22:58:43 <hphuoc25> Is it normal if my program uses 50% cpu for a task that is mainly I/O? The I/O mostly comprised of blocking read on a resource pool and insert to db using persistent.
23:02:53 <dmwit> dminuoso: Also, your question is wrong. You ask "why is it not using the Num constraint?". In fact, it is using it, by demanding that you prove that `return` only be applied to `Num` instances. You can't prove that, because `return` is allowed to be applied to any old value.
23:04:09 <dmwit> That is: you are constructing a value of type `Expr a` in the implementation of `return`, and so must show that `Num a` holds.
23:04:12 <dminuoso> dmwit: Ohhh. So essentially Im forced to constrain the data constructors.
23:04:46 <dmwit> My comment about "stupid and surprising" above is about the other direction, which is more surprising: if you have a value of type `Expr a`, GHC still won't know `Num a`, even though you had to prove that to make the given value.
23:05:09 <dminuoso> dmwit: For constraint on data type constructors I need GADTs right?
23:05:15 <mniip> after four years I think it's time for me to finally figure out what the hell is Cont
23:05:15 <dminuoso> *data constructors
23:05:23 <dmwit> I don't know what you mean by "constrain the data constructors". The data constructors are already constrained.
23:05:38 <dmwit> Check the type of `Var` in ghci and you'll see the constraint plain as day.
23:07:02 <Widdershin> Hi everyone. I'm a relative newbie to Haskell. I'm writing a language that compiles to WebAssembly. I started with Parsec as my parser, but after a bit more research I am now in the process of migrating to MegaParsec. I'm a bit stuck on something that I suspect is relatively trivial. Would anyone please be able to help me?
23:07:09 <dminuoso> dmwit: Ohh heh. I neither knew (and out of confusion ignored your remark) that it even requires an extension.
23:07:56 <dmj`> w
23:08:00 <dmj`> Widdershin: sure, ask
23:08:24 <dmwit> dminuoso: Huh! How did you make it far enough to get that error if you didn't know it needed an extension?
23:09:06 <dminuoso> dmwit: I just figured "this feels like a natural way of constraining my data type". Surprisingly ghc errors out on return *before* I get the Illegal datatype context error.
23:09:18 <dminuoso> I think this could be a bug?
23:09:26 <dminuoso> Or at the very least poor diagnostics.
23:10:20 <dminuoso> dmwit: When you said to put the constraint on the values that need it, do you mean to only constrain that type in a function that requires a to be Num?
23:10:35 <Widdershin> The MegaParsec docs recommend setting up a type synonym for Parser and ParseError. I have done so like this: http://lpaste.net/360078
23:10:38 <dminuoso> I guess this makes sense, because my Monad instance really does not care whether its Num or not..
23:11:03 <Widdershin> I think that where they have Void in the docs, I'm not supposed to actually use Void, but rather to use something that implements the ErrorComponent instance
23:11:13 <dmwit> dminuoso: right
23:11:18 <Widdershin> Or perhaps that I should use Void imported from somewhere else
23:11:27 <Widdershin> I can provide the full source code if desired
23:11:46 <Widdershin> I also included the compile error I'm experiencing in the above paste
23:14:12 <dmj`> Widdershin: full source link would be great
23:14:39 <jle`> @tell cps here's what I got :) http://lpaste.net/360080
23:14:39 <lambdabot> Consider it noted.
23:16:19 <Widdershin> @dmj` https://github.com/forest-lang/core/blob/megaparsec/src/Lib.hs :)
23:16:19 <lambdabot> Unknown command, try @list
23:19:00 <dmj`> Widdershin: try replacing Void with Dec
23:20:54 <dmj`> instance ErrorComponent Dec -- Defined in `Text.Megaparsec.Error'
23:22:19 <Widdershin> dmj`: that solved that set of errors, thank you so much! Now I have some errors from moving from String to Text that I can handle :)
23:22:45 <Widdershin> If it's not too much trouble, could you please explain what Dec is and why that fixed that, or point me at some documentation I can read to learn for myself?
23:22:56 <cps> Not sure if jle` is still around, but I made a few mistakes
23:23:08 <cps> I think I got it in the new one if you want to see
23:23:09 <cps> LMK
23:24:02 <dmwit> TIL you can chain record updates
23:24:12 <dmwit> a { b = c } { d = e }
23:25:15 <cps> jle`: http://lpaste.net/1347945279344607232
23:25:49 <cps> You gotta track the info and warnings to do the primitives
23:26:10 <cps> The neat thing is that you only do computation regarding the info and warnings on relevant functions!
23:26:17 <cps> Otherwise it just passes through
23:27:22 <jle`> cps: not sure if you got my last message but, i worked out http://lpaste.net/360080
23:27:25 <cps> I forget who told me about mtl-c but are the benchmarks available anywhere
23:27:30 <cps> I saw! :D
23:28:17 <cps> I had something very similar until I tried `return`
23:28:27 <jle`> mk i actually just recently fixed a mistake i made
23:28:55 <cps> Someone pointed out https://hackage.haskell.org/package/mtl-c which was helpful to see
23:29:04 <Railalis> what was the newer version of xmonad?
23:29:15 <Railalis> that's like currently in development?
23:30:16 <dmwit> There's a repo on github; perhaps you're thinking of that.
23:30:33 <cps> Hmm, our results are pretty different now....
23:30:44 <Railalis> I thought it was something else.. like not based on x-server stuff
23:30:46 <cps> Yours looks correct to me though...
23:30:55 <jle`> it might just be a styling thing
23:31:08 <jle`> also be aware that if you want a Monad instance, you can't have an accumulating Applicative
23:31:43 <jle`> er not sure if you did that last time or not
23:31:56 <cps> Yours is like this:
23:31:58 <cps> newtype Foo w e a = Foo   { runFoo :: forall r. (w -> e -> r) -> (w -> a -> r) -> r }
23:32:02 <cps> Mine is like this
23:32:19 <cps> newtype Result i w e a =   Result (     forall r.       [i]       -> [w]       -> ([i] -> [w] -> [e] -> r)       -> ([i] -> [w] -> a -> r)       -> r   )
23:32:22 <cps> Gah
23:33:04 <cps> newtype Result i w e a = Result (forall r. [i] -> [w] -> ([i] -> [w] -> [e] -> r) -> ([i] -> [w] -> a -> r) -> r)
23:33:05 <dmwit> Railalis: Doesn't ring a bell. But then I haven't been keeping up with xmonad news for a while. You might ask in #xmonad, too.
23:33:26 <cps> Notice the two extra arguments, in addition to the continuations
23:33:28 <Railalis> last time I hopped over there it pretty dead.
23:33:49 <dmwit> Suit yourself.
23:33:50 <cps> That allows me to skip doing a (<>) on the info and warnings on every single step
23:34:05 <jle`> cps: our types are the same
23:34:15 <jle`> er well, there is one thing different
23:34:24 <cps> Because of the Monid instance?
23:34:29 <cps> I don't see it
23:34:45 <cps> (I mean, I see that you collapsed i and w, which is equivalent)
23:35:15 <jle`> oh was reading hte wrong thing
23:35:38 <cps> I think my latest one is here http://lpaste.net/1347945279344607232
23:36:01 <jle`> yeah, i'm trying to model your original type
23:36:10 <jle`> but your original type doesn't have the extra two parameters at tehb eginning
23:36:24 <jle`> i don't think they correspond to anything
23:36:37 <cps> I think our solutions are equivalent
23:36:49 <jle`> mine is yours without the extra two things at the beginning
23:37:03 <jle`> the extra two arguments at the beginning make yours different from your original type
23:37:11 <cps> The difference manifests only in implementation
23:37:21 <cps> I think
23:37:22 <jle`> i'm not so sure about that
23:37:31 <jle`> in general, (a -> b) is different than (c -> a -> b)
23:38:33 <jle`> to got what i got, you start out with (w, Either e a)...then you can distribute the w to turn that into Either (w, e) (w, a)
23:38:49 <jle`> which is forall r. ((w, e) -> r) -> ((w, a) -> r) -> r
23:38:51 <cps> See the implementation of your (<<*>>) vs my `ap`
23:39:41 <cps> yours needs a (<>) on the warnings, but in mine, the continuation will add the warnings
23:40:15 <cps> A similar thing seems to be happening in https://hackage.haskell.org/package/mtl-c-0.1.1/docs/src/Control.Monad.RWS.CPS.html#RWST
23:40:36 <Railalis> what is a good graphics engine?
23:41:41 <jle`> cps: do you think that the two parameters at the start of yours correspond to the Writer log?
23:41:48 <cps> So I think they are equivalent, but for with different cost tradeoffs
23:42:03 <jle`> the writer log is handled by w in the (w -> e -> r) and the w in the (w -> a -> r) 
23:42:10 <jle`> so the extra w at the beginning...what does it correspond to?
23:42:11 <dmj`> Widdershin: status?
23:42:21 <jle`> if you have w -> (w -> e -> r) -> (w -> a -> r) -> r
23:42:24 <Widdershin> status: dinner :)
23:42:36 <jle`> the writer log is already handled by the w's in (w -> e -> r) and (w -> a -> r)
23:42:38 <cps> jle`: I don't know, but I don't think that means it is wrong...
23:42:42 <Widdershin> if you responded earlier I would have missed it because my laptop shut off, sorry!
23:42:51 <cps> Check out the mtl-c implementations
23:43:05 <jle`> you mean of RWS?
23:45:13 <cps> Yeah, and in the State one
23:45:29 <cps> The RWS has a var for `w`
23:46:03 <jle`> ah yeah, i see what you mean.  that's because it doesn't "store" a w like typical Writer, it actually treats it like State
23:46:13 <cps> I'm not sure the Writer implementation is correct...
23:46:46 <cps> nah, nvm
23:46:54 <cps> it does the mappend on every other operation
23:46:59 <jle`> so typically Writer is like a (w, a), but in this case they're basically implementing Writer the same way you'd implement State
23:47:10 <cps> Isn't it state though?
23:47:16 <jle`> well, state is more general
23:47:44 <jle`> State gives you modify :: (s -> s) -> State s ()
23:47:46 <cps> Gotcha, so the public API limits the use, not the implementation
23:47:56 <jle`> yeah, it's basically like State except they don't give you modify
23:48:09 <cps> For the sake of avoiding (<>) I guess
23:48:12 <jle`> they only give you tell :: w -> Writer w (); tell x = modify (<> x)
23:48:22 <jle`> well, you still need to <>
23:48:23 <cps> I feel like that's actually a pretty docont savings though
23:48:32 <cps> Only on a "tell" or whatever though
23:48:43 <jle`> well, on Writer, you also only <> on tell
23:48:46 <jle`> the difference is the associativity
23:49:05 <jle`> although i suppose you (<> mempty) on pure and stuff
23:49:10 <jle`> but the main cost savings is the associativity
23:49:18 <cps> I don't understand
23:49:28 <cps> In my case I can just cons I think
23:49:35 <cps> And then reverse at the very end
23:49:50 <jle`> because Writer's log ends up looking like ((((x <> y) <> z) <> a) <> b) <> c
23:50:04 <jle`> which is...awful for things like lists
23:50:19 <jle`> but if you use the State-with-limited-API, you get things associated the other way
23:50:22 <cps> Haha, right :)
23:50:42 <jle`> which is very fast for things like lists 
23:50:44 <cps> This has been super interesting! :D
23:51:04 <cps> It sounds like the riddle is solved now too?
23:51:07 <jle`> yeah, i didn't quite consider this earlier.  but i'm not sure if i would call it a "CPS'd Writer"
23:51:24 <cps> Rather a CPS'd State
23:51:39 <cps> CPS'd State + tricks
23:51:52 <cps> Technical terminology :)
23:52:13 <cps> Anyway, thanks a ton! I feel like I understand this stuff a lot better now!
23:53:08 <jle`> no problem :)  i've gotten rusty in this so it's been interesting to review too
23:55:37 <jle`> cps: but yeah, their `r -> s -> (a, s)` becomes `r -> s -> ((forall x. a -> s -> x) -> x)` which becomes `forall x. r -> s -> (a -> s -> x) -> x`
23:55:48 <jle`> plug in (w, s) for 's', and you get exactly what they have there
23:57:46 <jle`> if you want to do this with your situation, it's w -> (w, Either e a), which is w -> Either (w, e) (w, a), which is w -> (forall r. (w -> e -> r) -> (w -> a -> r) -> r), which is forall r. w -> (w -> e -> r) -> (w -> a -> r) -> r
23:58:16 <jle`> cps: which is, yeah, actually what you have :)  it's just a more "powerful" type that let you do more with 'w' than just <>-ing it
