00:02:47 <cps> :D
00:02:49 <cps> Thanks again.
00:02:57 <cps> I gotta get to bed!
00:03:00 <a6a3uh> I stuck a bit with the following.
00:03:01 <a6a3uh> I have stp which is of MonadError typeclass which I want to iterate until it throws an error:
00:03:01 <a6a3uh> stp' = do { stp; return True }
00:03:01 <a6a3uh> simulate = do { p <- stp' `catchError` const (return False); when p simulate }
00:03:03 <a6a3uh> but it iterates unstoppable. What Im doing wrong? any advise?
00:03:07 <JJJollyjim> Hi all, I'm using stack and getting some version conflict messages I don't quite understand:
00:03:11 <cps> Excited to give this all a try tomorrow :D
00:03:11 <JJJollyjim> In the dependencies for array-0.5.1.1:     base-4.10.0.0 must match >=4.5 && <4.10 (latest applicable is 4.9.1.0) needed due to tuner-0.1.0.0 -> array-0.5.1.1
00:03:30 <JJJollyjim> I'm using an lts which has base 4.9
00:03:38 <JJJollyjim> so what is requiring 4.10 in this situation?
00:04:15 <JJJollyjim> (my dependency is `base >= 4.7 && < 5`, so it isn't me)
00:07:10 <jle`> JJJollyjim: can you paste your cabal file
00:07:31 <jle`> it does sound like tuner is suspect
00:07:46 <jle`> oh, hm
00:07:59 <jle`> yes, paste that cabal file, and a stack file too :)
00:08:22 <JJJollyjim> http://lpaste.net/360084
00:09:07 <jle`> and are all of those packages on stackage?
00:09:29 <jle`> did you have any extra deps in your stack file?
00:09:51 <jle`> a6a3uh: well, does stp ever throw an error?
00:10:46 <JJJollyjim> yep looks like they're all in 9.13 (which is what's specified in stack.yaml), and no extra deps
00:10:51 <a6a3uh> jle`: yes. it throws error just before taking a head from empty list. but with simulate I get only empty list exceptions from Prelude
00:11:11 <jle`> a6a3uh: how are you throwing the error.  can you paste some more code?
00:11:29 <JJJollyjim> The yaml, unmodified from stack init http://lpaste.net/8638391911977058304
00:11:46 <a6a3uh> jle`: when (world ^. snake == []) (throwError ZeroLength)
00:13:01 <jle`> how about just stp = throwError ()
00:13:09 <jle`> does that terminate?
00:14:56 <jle`> JJJollyjim: this is a bit puzzling to me, maybe try asking down at #haskell-stack?
00:15:52 <a6a3uh> jle`: it does terminates. I only made "stp = throwError ZeroLength" as it was complaining about ()
00:16:15 <jle`> a6a3uh: so it looks the looping process does work
00:16:38 <jle`> your problem is that stp just always succeeds
00:16:48 <jle`> if stp is what you posted, then i wouldn't be surprised
00:16:55 <mniip> oh wow
00:16:59 <jle`> since world and snake are unchanging values?
00:17:10 <jle`> if they don't == [] at one point, then they will never == []
00:17:20 <jle`> * world ^. snake
00:17:20 <dmj`> Widdershin: enjoy dinner :)
00:17:51 <Widdershin> back now, going to tackle my compiler errors
00:17:53 <jle`> if 'world' is an immutable value, than world ^. state should always give the same thing.
00:18:01 <a6a3uh> jle`: world is a state. my monad is MonadState as well. so it changes.
00:18:23 <jle`> the problem is probably with your state updating logic
00:20:03 <jle`> oh
00:20:06 <a6a3uh> jle`: I only can imagine that it not throws an error while there are some empty list head out there which is not checked. thanks for advise! will look further. 
00:20:17 <ertes-w> hell
00:20:26 <jle`> a6a3uh: actually it might be with how your monad handles state after an error occurs
00:20:32 <hphuoc25> Is it normal for my program to use 50% cpu for a task that is mainly I/O? The I/O mostly comprised of blocking read on a resource pool and insert to db using persistent.
00:20:44 <jle`> a6a3uh: what MonadState/MonadError instance are you using?
00:21:27 <jle`> a6a3uh: for some instances, catchError would reset the state
00:21:55 <jle`> you just need to make sure you are using an instance where it doesn't reset the state
00:22:15 <a6a3uh> jle`: it does nothing with state when throwing an Error. As I assume computation gets interrupted on throwError. And then my simulation should be interrupted hopefully as well.
00:22:21 <a6a3uh> my instance is
00:22:23 <a6a3uh> newtype Game s r a = 
00:22:23 <a6a3uh>     Game { unwrap :: ExceptT Error (StateT s (ReaderT r (WriterT Log (MemoQV Int Double)))) a }
00:22:25 <a6a3uh>     deriving ( Functor
00:22:25 <a6a3uh>              , Applicative
00:22:27 <a6a3uh>              , Monad
00:22:27 <a6a3uh>              , MonadError Error
00:22:29 <a6a3uh>              , MonadState s
00:22:29 <a6a3uh>              , MonadReader r
00:22:31 <a6a3uh>              , MonadWriter Log )
00:23:14 <ertes-w> hphuoc25: both resource-pool and persistent have a cost, so if your Is and Os are small and frequent, then yes, it could happen
00:23:25 <a6a3uh> type MemoQ n r = MemoT (n, n, n) [r]
00:23:26 <a6a3uh> type MemoV n r = MemoT (n, n, n) r
00:23:27 <a6a3uh> type MemoQV n r = MemoQ n r (MemoV n r Identity)
00:25:05 <Widdershin> dmj`: Compiles and works now, thanks so much for your help :)
00:25:06 <hphuoc25> ertes-w: can you take a look at this program http://lpaste.net/360085
00:25:26 <dmj`> Widdershin: awesome :)
00:25:31 <dmj`> np :P
00:26:03 <Widdershin> Sorry if I missed any explanation while disconnected, but what is Dec?
00:26:10 <dminuoso> ertes-w: Oh. You keep switching usernames it seems. At any rate, https://gist.github.com/dminuoso/dee20f83832ba02161c0445c0b73917a
00:26:24 <Widdershin> I tried but couldn't find where it was defined, doesn't seem to be in the MegaParsec documentation nor did I have to import anything
00:27:07 <jle`> a6a3uh: hm, i guess all i can say is try to confirm that 'world' changes like you think it should as you repeat
00:27:18 <jle`> a6a3uh: also, why are you taking the head of a list?
00:27:23 <jle`> try pattern matching instead
00:27:27 <ertes-w> hphuoc25: another cost factor is MVar…  you're using quite a few abstractions there that aren't free
00:27:33 <jle`> case world ^. snake of
00:27:43 <jle`>   [] -> throwError ZeroLength
00:27:43 <Widdershin> Hoogle seems to think it's from TemplateHaskell but that would suprise me as I don't think I'm using TemplateHaskell (http://hackage.haskell.org/package/template-haskell-2.12.0.0/docs/Language-Haskell-TH-Syntax.html#t:Dec)
00:27:48 <jle`>   x:xs -> ...
00:27:57 <ertes-w> dminuoso: i'm ertes, but i don't check highlights for ertes that often =)
00:28:10 <ertes-w> dminuoso: that looks correct to me
00:28:16 <hphuoc25> ertes-w: I only have 1 MVar
00:28:32 <ertes-w> hphuoc25: i'm counting at least two
00:28:58 <jle`> a6a3uh: or (x,xs) <- maybe (throwError ZeroLength) return $ uncons (world ^. snake)
00:29:02 <ertes-w> hphuoc25: but it's not the number of MVars that counts, it's the way you use them
00:29:08 <a6a3uh> jle`: well I check if the list is not empty and only then taking a head. and if it is empty I'm throwing an error assuming computation will not go further after that. Are my assumptions wrong? Doing your way will add one tab to my code :)
00:29:12 <hphuoc25> ertes-w: the mvarpool is a resource pool. Sorry for bad naming. 
00:29:21 <hphuoc25> what did I do wrong?
00:29:22 <jle`> the second way saves a tab
00:29:32 <a6a3uh> jle`: agree :)
00:29:32 <jle`> but in general checking-if-empty-then-taking-head is bad haskell style, heh
00:29:47 <jle`> exactly for situations like this
00:30:08 <jle`> because in your mind you think there might not be a runtime error, but there ends up being one anyway
00:30:23 <jle`> if you pattern match, GHC will make sure for you that there is no runtime empty list error
00:30:32 <hphuoc25> ertes-w: currently the way it works is on the main thread, I try to acquire a resource from the pool and if it succeeds, I spawns a thread to do an I/O. This will limit the number of concurrent threads at 50 at any time
00:30:34 <a6a3uh> jle`: thank you! will refactor my code a bit) maybe it will solve an issue
00:31:09 <jle`> the idea is that every time you use a partial function, you have to "prove to yourself" that things work, and give up GHC's ability to check for you.  in this case you do prove to yourself, but apparently your proof is wrong (?).  in general, better to just let GHC hold our hands :)
00:31:10 <ertes-w> hphuoc25: my answer to that is more philosophical than technical: i'm not a big fan of persistent
00:31:34 <dminuoso> ertes-w: Is this monadic interface used when dealing with expression trees?
00:31:36 <jle`> a6a3uh: it probably won't magically make the issue go away, but it'll help expose where your reasoning might be astray :)
00:31:46 <hphuoc25> ertes-w: I see
00:31:57 <ertes-w> hphuoc25: i would probably have used postgresql-simple (or more likely sqlite-simple depending on the application)
00:32:20 <ertes-w> dminuoso: exercise: write a function that substitutes a certain variable by an expression
00:32:32 <ertes-w> dminuoso: that function must not be recursive
00:32:37 <a6a3uh> jle`: sure those are good advises. Im just learning haskell so I appreciate for your lessons :)
00:33:26 <dminuoso> ertes-w: How would that variable be identified? By position in a tree or by it's "name" ?
00:33:33 <ertes-w> dminuoso: name
00:36:03 <ertes-w> dminuoso: before you even start, what's the type of that function?  call it 'subst'
00:37:19 <tolt> Does hackage seem slow for anyone else rightn ow?
00:38:10 <dminuoso> ertes-w: It would be some (a -> Integer) -> Expr a -> Expr a
00:39:17 <ertes-w> dminuoso: no
00:39:42 <ertes-w> dminuoso: substitute one *specific* variable by an *expression*
00:39:51 <dminuoso> ertes-w: Ahh, I misunderstood.
00:40:33 <hphuoc25> ertes-w: I tried replace persistent with postgresql-simple, the CPU usage still the same
00:41:38 <ertes-w> hphuoc25: then it's probably just the frequency/size ratio
00:41:54 <ertes-w> hphuoc25: also make sure that it's actually the application and not, say, the database
00:42:21 <hphuoc25> yea htop reports that process taking 50%, not postgres process
00:44:02 <hphuoc25> ertes-w: what is frequency/size ratio?
00:45:05 <ertes-w> hphuoc25: smaller, more frequent I/O → higher CPU usage
00:45:23 <ertes-w> compare reading a file byte by byte to reading it in 4K chunks
00:45:28 <a6a3uh> jle`: FYI. Issue was resolved after refactoring. Thanks again!
00:48:21 <mniip> hmm
00:48:51 <mniip> so callCC is something like passing a recovery jmp_buf into a function (in C)?
00:53:13 <ertes-w> mniip: except that the continuation can escape the callCC
00:53:29 <mniip> ?
00:55:04 <mniip> ertes-w, you mean like the callee can return the continuation
00:55:15 <mniip> and if something tries to apply it you go into an infinite loop?
00:55:27 <mniip> hmm that doesn't sound right
00:55:44 <ertes-w> mniip: if you traverse up past setjmp's calling function, longjmp will likely cause a memory violation
00:56:26 <ertes-w> mniip: but it's totally fine to communicate the continuation past the lifetime of the callCC and still use it, in which case it returns to the point just after callCC
02:57:50 <osa1> anyone know any tools to find out unused pragmas in modules?
02:59:06 <pacak> osa1: hlint?
03:02:23 <osa1> thanks pacak
03:06:19 <osa1> it printed 336 hints @_@
03:07:21 <c_wraith> you can customize its ruleset if you disagree with some of the things it's telling you
03:07:52 <osa1> I'm not disagreeing with it (because I haven't checked what it's saying yet) but I need to find a way to run only pragma lints
03:07:57 <osa1> I just want to remove redundant pragmas for now
03:09:28 <osa1> `hlint . | grep pragma` worked
03:31:34 <drdo> How can I prevent GHC from optimising away Debug.Trace.trace?
03:36:00 <tolt> drdo: do you have an example on what's not working?
03:36:42 <drdo> sep_ _ | trace "sep_" False = undefined
03:36:50 <drdo> Just added this as usual
03:37:34 <drdo> With no optimisation the traces work, but with -O2 they're  gone
03:41:05 <drdo> fine, I'll just rename stuff and force it to go through the trace
03:41:49 <pariah> Has there been any activity on the JIT compiler for Haskell since this: https://github.com/nominolo/lambdachine ?
03:42:19 <pariah> Last commit seems to be in 2014.
03:53:12 <orion> Has anyone used the Streaming package, and if so, did you enjoy it?
04:03:39 <orion> The README is quite... aggressive: http://hackage.haskell.org/package/streaming
04:04:19 <orion> "I get, for example: ... and can dispense with half the advice they will give you on #haskell. It is only a slight exaggeration to say that a stream should never be "extracted from IO"."
04:06:09 <EvanR> heh
04:09:09 <mniip> hold on
04:09:17 <mniip> is it not the case
04:09:25 <mniip> that ContT r m a = Cont (m r) a
04:16:01 <Taneb> mniip: the two types are equivalent but they may have different instances
04:16:16 <mniip> right
04:16:27 <Taneb> e.g. we have MonadIO (ContT r IO) but not MonadIO (Cont (IO r))
04:17:01 <drdo> Is it possible to tell GHC to ignore cost centres from certain modules when generating profiling info?
04:17:28 <EvanR> i think so
04:17:48 <drdo> Can't find anything about it in the docs
04:17:52 <EvanR> or i may be mixing that up with manually placing cost centers
04:18:00 <drdo> Just wanna get rid of the long list of trivial stuff
04:26:52 <supercynic> orion: i'm not overly fond of the design of 'streaming'
04:28:40 <cocreature> recommendation for machines in 3 2 1 …
04:29:14 <supercynic> orion: you might as well just use 'free', because then you can use a more suitable domain-specific representation as well as better performance
04:29:21 <tabaqui> what is the estimated time of migrating from nightly to lts in stackage?
04:34:31 <mniip> Taneb, I'm quickchecking right now...
04:34:57 <mniip> the applicative instance matched up
04:35:53 <mniip> indeed
04:36:15 <mniip> recall that Monad (ContT r m) doesn't place any constraint on m
04:36:29 <mniip> so it can't do much except for the same as Monad (Cont (m r))
04:36:37 <orion> supercynic: The README claims to have better performance.
04:37:05 <supercynic> orion: better than 'free'?  that sounds implausible
04:37:19 <supercynic> orion: for a simple reason: it *is* 'free'
04:42:58 <RayNbow> hmm, I haven't used Haskell in a while... what's currently the common practice to deal with duplicate field names?
04:43:18 <supercynic> RayNbow: still prefixes
04:43:28 <mniip> it's 2017 and Applicative is a superclass of Monad
04:44:11 <supercynic> 'length' is defined in terms of Foldable
04:44:16 <mniip> iphone 10 came out too
04:44:33 <supercynic> we even got almost-agda-style typed holes
04:44:39 <mniip> almost
04:44:55 <EvanR> its 2021 and we have dependent types
04:45:10 <supercynic> we have TypeInType, so only one more layer to go before dependent types
04:45:15 <supercynic> and records still suck
04:45:17 <RayNbow> supercynic: ah, thanks :)
04:45:43 <mniip> supercynic, I see more than 1 layer though
04:45:49 <EvanR> to anybody in 2021 reading these logs, jealous
04:46:29 <mniip> EvanR, yeah but
04:46:32 <hpc> in a shocking twist, EvanR is going to be the one reading these logs
04:46:35 <Saizan> orion: re his "6.", I would run again but with the compositions left-associated instead of right-associated, i'd expect it to show a slow-down
04:46:37 <mniip> what's the type of \f g x -> f (g x)
04:46:47 <Saizan> orion: run the benchmark
04:46:57 <EvanR> they sent me back in time to complete the time loop
04:47:28 <EvanR> :t \f g x -> f (g x)
04:47:29 <lambdabot> (t1 -> t2) -> (t3 -> t1) -> t3 -> t2
04:47:49 <supercynic> the way it looks we're gonna have dependent types and deep learning error messages before we get nice records
04:48:10 <supercynic> in fact i think it's physically impossible to get nice records before GHC finally collapses into a black hole
04:49:17 <EvanR> on the bright side dependent types will let you make yet another extensible record library
04:49:36 <supercynic> mniip: hmm?  TypeInType collapsed all the type levels into a single level…  now we only need to merge the type language with the value language, no?
04:49:40 <mniip> EvanR, correction
04:49:42 <mniip> forall (a :: *) (b :: a -> *) (c :: forall (x :: a) -> b x -> *). pi (f :: forall (x :: a). pi (y :: b x) -> c x y) (g :: pi (x :: a) -> b x) (x :: a) -> c x (g x)
04:50:26 <supercynic> well, "only"…  but it is a single layer
04:50:27 <EvanR> ill just rewrite that in a form i can read
04:51:22 <EvanR> i forgot the diff between forall and pi
04:51:50 <saurabhnanda> does anyone know how to run the benchmarks in the aeson repo?
04:52:30 <lyxia> saurabhnanda: stack exec aeson-benchmark-$THING
04:52:40 <saurabhnanda> $THING ?
04:52:50 <saurabhnanda> lyxia: does it have TH vs Generics benchmarks, if you know?
04:52:56 <lyxia> it does
04:53:14 <saurabhnanda> `stack exec`?
04:53:29 <saurabhnanda> aeson-benchmark-$THING are binaries?
04:53:33 <lyxia> saurabhnanda: BTW I'm working on publishing some benchmarks as you suggested some time ago
04:53:54 <saurabhnanda> I'm preparing some slides for a talk. Do you know what's the latest on TH vs Generics?
04:54:02 <lyxia> saurabhnanda: in the benchmarks/ folder there is a cabal package where the benchmarks are executables
04:54:05 <saurabhnanda> which is faster during compile time? which is faster during runtime?
04:54:18 <mniip> supercynic, I see a lot of intermediate changes
04:54:26 <lyxia> Ah, I don't have comparisons at compile time.
04:54:39 <mniip> matchable/unmatchable arrow distinction,
04:54:45 <lyxia> saurabhnanda: TH is faster at run time
04:54:46 <mniip> explicit pi-quantification in type families and the like
04:55:02 <lyxia> saurabhnanda: the names of the executables are all of the form aeson-benchmark-$THING
04:55:22 <mniip> probably apartness guards too, for compat between type families and instances
04:55:33 <mniip> fundep functions too
04:55:53 <mniip> and then you could start thinking about unifying the syntax of the two levels
04:55:58 <supercynic> mniip: yes, of course…  it's not a small change, but it does finish what TypeInType began
04:56:02 <lyxia> saurabhnanda: so it should be possible to just go in benchmarks/ and build it as usual with cabal or stack
04:56:25 <mniip> yeah and of course,
04:56:28 <saurabhnanda> lyxia: why can't I find `aeson-benchmark-*` in my PATH? I just did the following in the project directory -- stack build --stack-yaml=stack-lts9.yaml
04:56:29 <mniip> typechecking goes down the drain
04:58:33 <saurabhnanda> lyxia: benchmarks is a separate package? I did a `stack init && stack install` there -- should work?
04:58:37 <lyxia> saurabhnanda: Ah, you should use stack-bench.yaml
04:58:50 <lyxia> yes it should
05:02:47 <saurabhnanda> trying this now -- "stack install --stack-yaml=stack-bench.yaml --resolver=lts-9.12"
05:15:53 <saurabhnanda> lyxia: thanks. Got all the aeson-benchmark-$THING
05:16:06 <saurabhnanda> lyxia: which one has the generic vs th benchmarks?
05:17:05 <saurabhnanda> lyxia: aeson-benchmark-aeson-encode: Unexpected empty list -- what am I supposed to pass to these benchmark programs?
05:22:13 <lyxia> saurabhnanda: a number (of iterations) followed by a list of filenames
05:22:31 <saurabhnanda> what files am I supposed to pass?
05:22:51 <saurabhnanda> stuff in benchmarks/json-data ?
05:23:14 <lyxia> yeah, any JSON file I suppose
05:23:35 <lyxia> These should probably be updated to work with criterion
05:24:26 <lyxia> saurabhnanda, phadej: how does this look https://lysxia.github.io/aeson-benchmarks/
05:25:32 <lyxia> It's missing the non-criterion benchmarks
05:25:36 <saurabhnanda> lyxia: sadly, I have never been able to figure out how to use this UI. This the same thing on ghc-perf, right?
05:26:10 <lyxia> yeah
05:26:44 <lyxia> saurabhnanda: what would you like to see, I'm actively working on the UI
05:27:42 <lyxia> saurabhnanda: for now, if you want to see all benchmarks, click on the "=" button on the top right
05:27:51 <saurabhnanda> th vs generics performance, for starters
05:28:07 <saurabhnanda> clicked `=` -- it does nothing.
05:28:21 <lyxia> saurabhnanda: then click on a commit
05:28:59 <lyxia> saurabhnanda: oh yeah it doesn't do comparisons between different benchmarks, only the same benchmarks between versions.
05:29:51 <saurabhnanda> lyxia: via the aeson-benchmark-* tools, how do I do a TH vs Generics comparison?
05:30:53 <lyxia> saurabhnanda: it's built in a few of the benchmarks. You just run them and they bench TH, Generics, and sometimes a manually written one.
05:31:49 <rwarfield> Hey guys... I'm trying to implement something like a Pandas/R dataframe in Haskell and was hoping I could get some advice. After a lot of Googling it appears term of art for what I want is a heterogenous list or extensible record whose values are vectors of various types. 
05:32:46 <lyxia> saurabhnanda: hmmm it looks like only aeson-benchmark-typed does it
05:33:30 <lyxia> saurabhnanda: in the repo there's also benchmarks/AesonCompareAutoInstances.hs but it's not anywhere in the .cabal file
05:33:57 <saurabhnanda> lyxia: finally got something to work
05:34:11 <lyxia> so "a few of them" is two, less than I thought.
05:34:31 <rwarfield> I need to be able to get the typed vectors out... so it seems an existentially quantified type won't work.  There are libraries like HList that use tricks with the type system but that one looks ancient... is there any "nice" way to achieve this
05:35:48 <EvanR> heterolists are an exercise in asking what you really want to do 
05:36:25 <EvanR> just having one is not enouggh
05:37:04 <quchen> A wild [Dynamic] appears
05:37:33 <EvanR> barf
05:38:07 <quchen> Not barfer than heterogeneous lists
05:39:55 <rwarfield> Well... Ideally I'd like to be able to keep type safety without a ton of boilerplate.  To write types like dataframe :: DataFrame [Vector Int, Vector Text, Vector Double] while retaining the ability to pick out the individual vectors without a huge amount of boilerplate/pain
05:41:01 <EvanR> all that looks like is a regular record type
05:41:08 <rwarfield> I could just use Dynamic but that then lose most of the benefits of the haskell type system
05:41:12 <EvanR> but haskell doesnt have record types
05:42:33 <EvanR> another answer is use (Vector Int, Vector Text, Vector Double) and were back to my question
05:42:54 <rwarfield> But I want to also be able to have dataframe :: DataFrame [Vector Scientific, Vector Integer, ....] without having to define every posisble combination... 
05:43:23 <EvanR> whats the difference between DataFrame [x,y,z] and (x,y,z)
05:45:12 <rwarfield> Well not much... but how would I write a function to (e.g.) pick out the 3rd element of a tuple if I don't know the length and don't know the types? 
05:45:30 <rwarfield> Is that a stupid question?
05:45:52 <EvanR> well that partially answers the question
05:46:26 <EvanR> so you want an operation like third :: DataFrame xs -> (xs !! 2)
05:47:16 <rwarfield> Right, I think that would get me most of the way there
05:47:27 <rwarfield> is lens the way to go?
05:47:39 <EvanR> if this is appealing, now answer what happens if xs has less than 3 elements
05:48:25 <rwarfield> Then the code shouldn't compile
05:48:38 <EvanR> not enough info in the type there to know
05:48:58 <EvanR> if you have a way to fix it, you might be looking for the world of dependent types
05:49:02 <EvanR> which haskell doesnt have
05:49:15 <EvanR> and the similar solutions it has are boilerplatey
05:50:01 <EvanR> but i am kind of questioning the utility of the whole situation
05:50:07 <rwarfield> Hmm... so... I need to quite haskell? :-)
05:50:10 <rwarfield> *quit
05:50:31 <EvanR> is a dataframe a transpose of something like [(a,b,c)]
05:52:41 <rwarfield> A dataframe is basically a tuple of vectors (columns) of different types, like you pointed out.  I want to write a library.  The users of the library will know at compile time the number and types of the columns. But I do not know as the library author.
05:53:13 <EvanR> the only operation is projecting to get the fields?
05:54:18 <rwarfield> Well given that operation and the ability to construct new dataframes, I think I could figure out how to implement the rest of the functionality.
05:54:40 <EvanR> construct them how
05:54:57 <phadej> something like https://hackage.haskell.org/package/Frames ?
05:55:48 <phadej> there was a talk about data science in haskell at haskellX 2017
05:55:52 <EvanR> yeah so this one works by prepending rows
05:55:57 <rwarfield> I've looked at the frames library ... it's a bit different from Pandas/R dataframes work.  For one thing it's row oriented not column oriented
05:55:57 <phadej> it mentions various libraries
05:56:18 <EvanR> it implements row types
05:56:26 <phadej> rwarfield: well that's SoA/AoS
05:56:32 <rwarfield> Also... this is partly a learning exercise
05:56:43 <rwarfield> Hmm... maybe I need to take another look
05:57:59 <rwarfield> Ah yes... I remember. Frames uses template haskell.  which would definitely be one way I could do this
05:58:09 <EvanR> so Frames uses vinyl
05:58:34 <EvanR> an extensible records lib
05:58:48 <drdo> Anyone using haskell-mode with ghc 8.2.1?
06:01:02 <rwarfield> Vinyl looks interesting
06:04:41 <supercynic> rwarfield: is there anything wrong with just using product types?
06:05:21 <EvanR> the goal is to make a library which lets the client index into an unknown product type
06:05:40 <EvanR> which seems artificial and very difficult to make logical
06:06:06 <EvanR> you need to specify the numeric conditions in the type of the operations
06:06:12 <ggVGc> what's the better way of writing this? https://gist.github.com/004f41e47a988907512d317405068039
06:06:53 <ggVGc> maybToList(sig) <> assumSignals?
06:07:18 <EvanR> then the client needs to provide proof at the use site, or have support for proof search which will only work on concrete types known at compile time, which haskell doesnt do
06:07:21 <supercynic> :t \xs -> maybe xs (: xs)
06:07:23 <lambdabot> [a] -> Maybe a -> [a]
06:07:38 <adrien91> Hi guys, does anyone got a suggestion how I can implement an infinite matrix data structure? 
06:07:57 <EvanR> (Integer,Integer) -> a
06:08:22 <supercynic> or [[a]]
06:08:32 <EvanR> or total map
06:08:45 <supercynic> or [Vector [Vector a]]
06:09:00 <supercynic> (i wish we had lazy vectors)
06:09:02 <tdammers> adrien91: depends on what you want to do with it
06:10:05 <tdammers> Map (Integer, Integer) a -- if you need an infinitely large space with a finite number of spots occupied
06:10:07 <EvanR> infinite Vector ?
06:10:14 <EvanR> would be cool
06:10:15 <adrien91> so I got a uni assignment to implement a tile based game, where the field is a matrix and should be infinite => a player should be able to walk every till infinity (except neg values)
06:11:10 <tdammers> then it depends what kind of data you need to store in the matrix, and how literal the "infinite" requirement is
06:11:23 <adrien91> I need to store tuples in it
06:11:45 <adrien91> every coordinate has a (Int, Int, Int)
06:11:52 <byorgey> adrien91: in that case I like EvanR's idea best: an "infinite" field is just a function which can tell you the tile at any given (x,y) coordinate
06:11:55 <tdammers> uhm, that's not actually infinite
06:12:09 <tdammers> Int is bounded, so that gives you very much a finite space
06:12:20 <EvanR> 3 Int is the payload
06:12:29 <byorgey> tdammers: I think adrien91 is saying that every coordinate *contains* an (Int, Int, Int) ?
06:12:36 <tdammers> byorgey: oh, ok then
06:12:48 <adrien91> yes that is correct byorgey
06:13:02 <tdammers> problem, if you need to reference the coordinates at any point, you need "infinite" types for the coordinates
06:13:14 <byorgey> tdammers: spoiler alert, Integer isn't actually infinite either
06:13:19 <tdammers> byorgey: exactly
06:13:34 <EvanR> what is this, finitism
06:13:51 <tdammers> EvanR: ℕ is infinite, but Haskell's Integer is not
06:14:02 <EvanR> haskell has several Integer implementations
06:14:13 <byorgey> no, my point is that Int is actually quite infinite enough already.  quibbling over whether things are "actually" infinite isn't really helpful for adrien91 I think
06:14:18 <EvanR> is an infinite list also not nec infinite
06:14:39 <adrien91> is "total map" a package I have to download (never used packages before) 
06:14:49 <tdammers> EvanR: an infinite list is infinite in the sense that you can traverse it until the death of the universe without running out of memory
06:14:59 <adrien91> because I'm not sure if im allowed for the assignment
06:15:02 <EvanR> total map is like Map (Integer,Integer) a but with a default value for the missing locations
06:15:51 <byorgey> if a player can take one million steps every second it will take them 300 thousand years to reach the edge of the world if you represent coordinates with Int on a 64-bit architecture
06:15:52 <EvanR> i love abstractions that depend on physics
06:15:54 <adrien91> so that the best way of implementing the grid EvanR?
06:16:10 <adrien91> that's*
06:16:21 <byorgey> adrien91: is there are regular rule that determines the contents of each location?
06:16:22 <EvanR> adrien91: it depends on what you want to *do* with the data
06:16:36 <byorgey> or are you going to design a map with specific things at specific locations?
06:16:50 <tdammers> EvanR: what if the player grows exponentially such that the number of steps they can take per day doubles every day?
06:17:20 <byorgey> tdammers: that sounds like the start of an interesting game teaching about the scale of the universe.
06:17:35 <adrien91> byorgey: it's a desert game and every tile has a chance of being either a pool of lava, pool of water or just a desert tile (these types are stored in the tuple of each tile)
06:18:38 <byorgey> adrien91: ok.  And can you randomly generate the whole world before the player starts, or do you have to randomly generate each tile as they come to it?
06:19:04 <adrien91> byorgey: I need to give a seed for random generation before game starts
06:19:40 <EvanR> heh, if you use the right algorithm you can restore any section from the generator without storing it
06:22:27 <supercynic> tdammers: how is Integer not infinite?
06:22:41 <EvanR> gmp limits
06:22:55 <supercynic> i would count that as an implementation detail
06:23:08 <EvanR> yeah whats important is the abstraction
06:24:01 <EvanR> you can choose to not care about that implementation detail, and also not care about how slow the program is going to get when they start an exponential journey
06:24:52 <EvanR> if you do care its the wrong abstraction
06:25:14 <tdammers> supercynic: Integer is stored internally as an arbitrarily long array of finite integers
06:25:36 <supercynic> tdammers: "arbitrarily long"
06:25:42 <tdammers> supercynic: but the "arbitrarily long" is limited by how large an array your computer can hold / address
06:25:54 <EvanR> its limited more than that
06:26:15 <supercynic> tdammers: so [()] is finite, too?
06:26:26 <EvanR> > length [()]
06:26:28 <tdammers> EvanR: yes, it is, but this part is a fundamental limitation that transcends implementation details
06:26:28 <lambdabot>  1
06:26:36 <tdammers> supercynic: [()] is trivially finite
06:26:42 <supercynic> tdammers: the type
06:26:45 <supercynic> not the value
06:26:47 <EvanR> your computers addresses modes are very implementation details
06:26:52 <EvanR> addressing
06:26:59 <tdammers> the type can hold infinite lists
06:27:20 <tdammers> and those are actually infinite, in the sense that traversing them never finishes
06:27:30 <supercynic> that's irrelevant
06:27:35 <supercynic> data Nat = Z | S !Nat
06:27:40 <supercynic> is this an infinite type?
06:27:44 <EvanR> when your computer runs out of space it prints "please transfer to bigger computer to continue"
06:27:52 <EvanR> to the printer
06:27:56 <byorgey> adrien91: right, make sense.  In that case I would represent the world with a function   Seed -> Integer -> Integer -> (Int, Int, Int)
06:28:11 <byorgey> adrien91: i.e. given a seed value and the coordinates of a location, it tells you what is at that location
06:28:19 <supercynic> tdammers: ^
06:28:27 <byorgey> adrien91: but it depends on the seed somehow, so every seed will give a different "random" world
06:28:49 <adrien91> byorgey: thats exacly what I need
06:28:55 <tdammers> supercynic: it's recursive, but because it's strict, you cannot use it to represent infinity in practice
06:29:19 <tdammers> that is, packing an infinitely recursive series of applications of S into it will run out of memory
06:29:28 <EvanR> "infinite in the sense...." is an implementation detail
06:29:33 <EvanR> heat death of the universe is an implementation detail
06:29:59 <supercynic> tdammers: you're not answering the question…  is Nat an infinite type in that there is no enumeration type that is isomorphic to it?
06:30:04 <EvanR> i cant think of a number larger than x is an implementation detail
06:31:29 <tdammers> well, meh, integer overflows are an implementation detail. rounding errors are an implementation detail
06:31:40 <adrien91> byorgey: thanks alot
06:31:43 <EvanR> the defined constant which stands as the "fin" of the supposedly infinite Integer is just as arbitary as the computers memory model
06:31:52 <supercynic> Double is a finite type (despite having "infinity" as a value)
06:32:04 <supercynic> the problem here is that you're talking about different notions of infinity
06:32:25 <supercynic> i would define any type that is isomorphic to Nat as countably infinite
06:32:38 <EvanR> rounding errors might be actually wrong, if you dont have a theory for the convergence or stability of your code
06:32:38 <tdammers> except that Nat is a lie
06:32:56 <tdammers> a leaky abstraction
06:33:16 <supercynic> so turing machines are a lie, too?  because we don't have infinite tapes?
06:33:29 <tdammers> yes, pretty much
06:33:30 <hexagoxel> "Bool is infinite, only most implementations stop at 1"
06:33:35 <byorgey> adrien91: sure.  if you google for "procedural generation" you might get some ideas on how to write that function.  It's not obvious how to do it, because if you just pick simple rules like "if the seed + x + y is divisible by 3 then it is desert" then the world will look too regular/patterned
06:33:47 <supercynic> ok, then i'm no longer interested in this discussion =)
06:33:56 <EvanR> abstractions dont actually exist? 
06:34:00 <EvanR> news?
06:34:13 <hexagoxel> (i don't really understand the details of what you discuss..)
06:34:58 <supercynic> hexagoxel: "Nat is not really infinite, because computers can't hold all of its values"
06:35:34 <hexagoxel> comes down to whether it is supposed to have an upper bound, doesn't it?
06:35:46 <supercynic> hexagoxel: data Nat = Z | S !Nat
06:35:47 <hexagoxel> and for Int, one may very well disagree for the same question.
06:36:15 <EvanR> abstractions are true if you cannot or choose not to observe the deviation
06:36:16 <byorgey> adrien91: e.g. you might also want to google "Perlin noise".  https://gamedev.stackexchange.com/questions/18840/how-do-games-like-minecraft-generate-entire-worlds-from-a-seed-number has some good links.
06:37:59 <EvanR> an infinite number of things dont exist in real life? do "numbers of things" even exist in real life anyway?
06:38:54 <EvanR> if real life cant follow rules, then let me live in the abstract instead
06:39:34 <TCZ> what
06:39:35 <TCZ> xd
06:39:57 <EvanR> welcome to applied philosophy i mean haskell
06:40:10 <adrien91> byorgey: thanks
06:42:30 <supercynic> again: start by defining infinity
06:42:57 <supercynic> i define an infinite type to be one that has an injection from Nat
06:43:24 <EvanR> a simpler one would be... no final element
06:43:36 <supercynic> "final"?
06:43:43 <EvanR> yeah
06:43:56 <supercynic> what does that mean?
06:43:58 <EvanR> if you tried to list them
06:44:15 <EvanR> last everything = bottom
06:44:24 <supercynic> and listing means something other than assigning a natural number to each element? =)
06:44:52 <EvanR> in this case listing is just an intuitive thing, but let me get the constructive version of listing
06:45:27 <tdammers> equivalently, you could also say that for every value, a "larger" value exists
06:45:49 <tdammers> showing this for Nat (at least the lazy version) is trivial
06:45:53 <tdammers> just apply S
06:46:24 <tdammers> the problem with strict Nat is that, depending on your interpretation of bottom, S is partial
06:46:26 <supercynic> "larger"?
06:46:44 <EvanR> hmm andrejbauer calls a listing a surjection from {1..n} to S
06:46:50 <tdammers> "larger" as in "further down according to some traversal"
06:46:56 <supercynic> "traversal"?
06:47:01 <EvanR> so... built-in finiteness
06:47:08 <EvanR> (of a certain kind)
06:47:20 <supercynic> see?  just use injections (or surjections)…  your seemingly "simpler" definitions are really much more complicated
06:47:33 <EvanR> no
06:48:07 <supercynic> also it nicely generalises to categories
06:48:18 <EvanR> injection and surjection will pull in all kinds of complex mathematical topics
06:48:22 <supercynic> where you replace injections by monomorphisms
06:48:33 <EvanR> any attempt to list all the elements will not have an end
06:48:39 <supercynic> huh?  i can define injection in a one-line self-contained law
06:48:52 <mnoonan> there is nothing complex about injections or surjections. it just involves saying exactly what you mean.
06:49:10 <hexagoxel> what does the `Nat` type have to do with computers?
06:49:38 <EvanR> i am saying what i mean
06:49:39 <tdammers> hexagoxel: the ! in the definition suggests that we are talking Haskell code, not a theoretical Math thing
06:49:40 <supercynic> a type X is infinite, if there exists (f :: Nat -> X) such that for all x and y, f(x) = f(y) → x = y
06:49:42 <supercynic> done
06:49:52 <hexagoxel> haskell code is a theoretical math thing.
06:49:56 <hexagoxel> what else
06:50:14 <supercynic> completely self-contained, no vague/ambiguous terms like "larger" or "final"
06:50:28 <tdammers> haskell is a practical general-purpose programming language. it can be compiled into machine code for actual physical finite machines
06:50:29 <EvanR> there are a lot of ways to do it
06:50:39 <EvanR> none of them are teh one true way
06:50:44 <hexagoxel> next you say "haskell is not pure" because there are no "computers" that would not make an error while computing (1+1) with some rather low probability.
06:50:47 <mnoonan> and no implicit quantification over the set of all ways of trying to list your type's inhabitants :)
06:51:15 <hexagoxel> > 1+1 -- maybe i get lucky and hit that low probability
06:51:17 <lambdabot>  2
06:51:20 <hexagoxel> dang
06:51:32 <tdammers> hexagoxel: it's worse; much of the theory behind Haskell's "soundness" blatantly ignores bottoms, by practical necessity
06:51:44 <EvanR> mnoonan: game theory!
06:52:06 <tdammers> then again, nontermination is a form of bottom, so in that sense at least we can get "infinite" things
06:52:29 <EvanR> non termination isnt real
06:52:46 <supercynic> of course (4 + 4 = 8) is also false in ZF, because the sheet of paper you wrote it on might get torn, turning the 8 into a 3 =)
06:52:58 <tdammers> EvanR: prove it! >:)
06:53:41 <EvanR> (a rather long) proof: leave the program running
06:54:03 <EvanR> eventually they defund your electricity because of how ridiculous this argument is, computer turns off
06:54:13 <EvanR> try it
06:54:21 <Psybur> Is physics turing complete? :D
06:54:30 <supercynic> Psybur: yeah
06:54:36 <ggVGc> Psybur: no, can you write a physics engine in physics?
06:54:40 <supercynic> Psybur: the proof of that is right in front of you =)
06:55:00 <Psybur> Is existence some kind of program? :o
06:55:03 <EvanR> physics is the most accurate and efficient physics engine
06:55:15 <ggVGc> EvanR: it's pretty limited though
06:55:23 <ggVGc> I think we need an expansion
06:55:29 <hexagoxel> "i run an _actual_ turing machine in my basement, you see. i tape new paper to the band whenever it becomes necessary"
06:55:36 <EvanR> to metaphysics
06:57:00 <ggVGc> I have actual alan turing in my basement
06:57:04 <ggVGc> and he does calculcations for me
06:57:26 <tdammers> EvanR: but that just shows that this one attempt at infinity didn't work - it doesn't prove that nontermination isn't possible
06:57:44 <ggVGc> mnoonan: to be fair, it's quite hard to say exactly what you mean, a lot of the time
06:57:52 <ggVGc> humans have been struggling with this since forever
06:57:54 <EvanR> the proof works with any computer and any program
06:57:58 <ggVGc> not sure we've gotten much better
06:58:02 <EvanR> proof, try it
06:58:35 <mnoonan> ggVGc: agreed, so.. reuse existing solutions, including terminology :)
06:58:41 <EvanR> (maybe proofs that require spending large sums of money should be considered invalid)
07:01:01 <sphinxo> best way to test a  postgres-simple application?
07:01:14 <supercynic> sphinxo: yes
07:03:17 <sphinxo> supercynic: yes?
07:04:12 <supercynic> sphinxo: don't mind me, i just ran out of fields =)
07:04:19 * ertes-w powers down
07:04:50 <Psybur> sphinxo, I think he's saying there is both no "best" way and that every way to test is the best way? D;
07:06:57 <sphinxo> ahh ok, well what are some good ways then, eg any helpful packages 
07:07:27 <sphinxo> eg for setup/teardown for tests
07:11:38 <ertes-w> sphinxo: any test framework should be good enough…  you can use quickcheck for randomised tests (it supports IO tests)
07:11:51 <sphinxo> ok cool
07:13:28 <ertes-w> sphinxo: it can be helpful to abstract over the storage layer by writing a type class with the application-specific business logic:  class AppData h where addUser :: h -> User -> IO UserId; getUser :: …
07:13:44 <ertes-w> sphinxo: because then you can write two backends:  a postgres backend for production and an STM backend for testing
07:13:58 <ertes-w> (of course you still need to test the backends themselves, but at least you get some separation)
07:14:07 <sphinxo> yeah that's what I planning on doing for different db backends
07:43:25 <ij> Hello, I've a parsing problem. I have a parser “ar” that parses arithmetical expressions. I want to be able to parse “ar” expressions from inside the parentheses in "#()". The “ar” expressions may themselves use parentheses, but I'd like 'em to be escaped, if inside "#()". Can I write a parser that'd parse "#(ar_expression)" without changing “ar” with *megaparsec*?
07:44:27 <ij> so "garbage text #(1 * \(3 + 4\)) + 5" should parse the expression "1 * (3 + 4)".
07:47:45 <ij> If I do “(string "#(" *> ar) <* string ")”, then ar will "take" the unescaped parentheses.
07:48:38 <ij> Is the only solution that doesn't change “ar” parsing again? Is "subparsing"(?) a good tactic?
07:53:48 <ij> Do parsers have some magic rules that show you cannot do it or something?
07:53:50 <ij> :D
08:01:34 <shapr> ij: do you have a parser that works with "1 * (3 + 4)" ?
08:01:53 <ij> Yes.
08:02:18 <shapr> doesn't megparsec have between or something?
08:02:35 <shapr> what do you mean by subparsing?
08:06:11 <shapr> ij: I've composed parsers a bunch, but never had one where the inside and the outside both wanted to eat parens
08:07:46 <ij> 1. it does, 2. calling “parse” again, 3. I could extend the problem to just *a* parser, not this specific one
08:08:35 <shapr> is the ar parser something you can modify?
08:08:46 <shapr> for example, could it look for #( and )# ?
08:11:03 <aplainzetakind> hdevtools is not supposed to spawn new instances all the time right?
08:14:03 <aplainzetakind> man hdevtools
08:14:12 <aplainzetakind> Oops.
08:15:13 <MarcelineVQ> might be your editor doing that, try to find the options being used if you can.
08:16:18 <shapr> anyone compared stack and mafia for ease of installation/getting started?
08:16:47 <aplainzetakind> It's vim with syntastic.
08:19:03 <shapr> I've been teaching Haskell to my coworkers once a week at lunchtimes, but getting stack installed on mac and linux is much frustration, is there something easier?
08:19:33 <ij> I think it should be pretty easy with nix.
08:19:58 <shapr> ij: I've heard that, but nix is another step to add
08:20:06 <ij> None of the operating system's exeutables/libraries are being used after installing nix itself.
08:20:41 <shapr> ij: that's a good suggestion, I've not tried that
08:21:00 <MarcelineVQ> shapr: I only used mafia one time but it was entirely painless, for the little that's worth hehe. I've no idea if it's appropriate to manage a project with though, or if it's more for deployment
08:22:18 <MarcelineVQ> shapr: that being said what is the reason they need stack shapr? to wrangle ghc versions?
08:22:28 <ij> shapr, Hm, I think if the language being parsed has balanced parentheses, you wouldn't even have to escape it, it should just work. What if the embedded parser's the )* language?
08:22:31 <Eduard_Munteanu> shapr, there's an official Haskell docker thing which includes stack, but I haven't tried it
08:22:57 <Eduard_Munteanu> https://hub.docker.com/_/haskell/
08:23:02 <ij> Yeah, docker sounds fine.
08:23:49 <MarcelineVQ> shapr: asking because  cabal new-build  should cover most things a beginner needs for project-making
08:24:57 <MarcelineVQ> heck cabal sandboxes still work fine, new-build has the nice new package caching features though
08:35:33 <centril> Hmm... after doing `stack install Agda` on Windows, and using agda-mode on Atom I managed to get "Unable to locate Agda on Windows systems" on loading a file does anyone have any idea why?
08:35:40 <centril> google fails me completely
08:37:04 <ertes-w> shapr: cabal-install
08:37:20 <MarcelineVQ> centril: dunno specifically but make sure agda is on your path, possibly restart so atom is using the same path you see, check the plugin settings and tell it where to find agda specifically
08:37:41 <centril> MarcelineVQ: agda is on the path, restarted atom =)
08:38:25 <centril> perhaps Atom expects it to be somewhere else :/
08:38:29 <ertes-w> shapr: while i'm a fan of nix, i think you shouldn't use it for education
08:38:30 <MarcelineVQ> when it comes to windows restarting the whole system is a good first step to problem solving hehe
08:38:56 <ertes-w> shapr: it has a learning curve of its own, and if you keep it opaque, it will only make everything look like a black box
08:39:18 <MarcelineVQ> but if atom can't find it, try to tell it where to find it in the plugin settings
08:39:26 <ertes-w> shapr: just use plain old cabal-install, and everything will be fine
08:40:18 <centril> MarcelineVQ: looked for such settings but they don't seem to exist :/
08:40:27 <centril> meh... this worked a year ago
08:40:30 <MarcelineVQ> hmm lemme install atom and see
08:43:25 <centril> MarcelineVQ: cheers
08:45:05 <MarcelineVQ> just so we're using the same things do you have language-agda as well?
08:45:23 <centril> MarcelineVQ: yep
08:46:00 <centril> Agda version 2.5.2
08:46:02 <ggVGc> man, writing some haskell again for the first time in over 1.5y
08:46:04 <ggVGc> feels nice
08:46:09 <ggVGc> but also, I'm fairly rusty
08:46:22 <ggVGc> wasn't even any good when I last stopped
08:46:59 <ggVGc> really think 'type' was a fairly bad choice of keyword
08:48:03 <ertes-w> all the type definition keywords are a bad choice =)
08:49:29 <bigos> https://github.com/bigos/haskell-installation/blob/master/haskellInstall.org  my record of struggling with Haskell compilation of a program that uses Gtk
08:49:39 <bigos> Why it is so hard?
08:51:40 <MarcelineVQ> centril: installing Agda atm to test some things.  when you load a file, and use the plugin option  Agda Mode -> Load  what's the full error it spits out at the bottom?
08:51:49 <erisco> because 1) that is as good as it gets in this universe, or 2) someone has yet to find the optimum
08:52:46 <centril> MarcelineVQ: "Unable to locate Agda on Windows systems"
08:53:11 <MarcelineVQ> that's the whole thing? gosh, it's not trying to help you is it :(
08:53:47 <ggVGc> wait, Agda was invented at Chalmers? I live literally 500m from Chalmers
08:53:51 <MarcelineVQ> allthough, the wording might be an evil hint, it says systems. it maye be spekaing generally, as in "I can't find Agda on windows at all."
08:53:57 <ggVGc> and I'm a student there, although not attending very much
08:54:18 <acowley> bigos: Perhaps starting with stack rather than HP would simplify a bit. But I'll admit that building a GTk application on Windows with Haskell is not something I'd expect to go perfectly smoothly.
08:54:33 <acowley> bigos: Too few people doing it
08:55:24 <centril> MarcelineVQ: maybe Atom has some fuller output somewhere?
08:55:37 <dminuoso> ertes-w: Sorry had to do some work stuff. I was going for replaceWith :: (Traversable t, Eq a) => a -> t a -> t a -> t a
08:55:42 <centril> MarcelineVQ: tho, the plugin is supposed to work on Windows
08:55:45 <MarcelineVQ> centril: That doesn't mean can't use though, just doesn't know how to find things, so we'll see what options there are when Agda finishes building
08:55:49 <centril> ggVGc: I'm a Chalmers student myself =)
08:55:59 <centril> MarcelineVQ: ;)
08:56:20 <dminuoso> ertes-w: (And then ruthlessly use the Traversable instance I have just defined on Expr)
08:56:25 <MarcelineVQ> centril: did you try rebooting the pc yet just in case that'll path refresh things for atom?
08:57:19 <centril> MarcelineVQ: haha, the lab deadline is in 6 hours :P
08:57:24 <centril> every minute counts ;)
08:57:33 <centril> MarcelineVQ: I'll try it, brb
08:58:45 <ertes-w> dminuoso: no, that won't work
08:59:23 <dminuoso> ertes-w: Perhaps. Ill try it anyway and maybe it will become obvious. :)
08:59:38 <ertes-w> dminuoso: yeah, try it
08:59:50 <ertes-w> dminuoso: but the type is almost correct =)
09:00:07 <ertes-w> dminuoso: right shape, wrong constraint
09:01:32 <bigos> acowley:I would try a simpler option if I knew it. I am a Haskell noob
09:01:51 <centril> MarcelineVQ: no diff :/
09:01:54 <ertes-w> dminuoso: BTW, there are DeriveFunctor, DeriveFoldable and DeriveTraversable
09:02:36 <dminuoso> ertes-w: I remembered, for now the decision was to be explicit to burn the relationship between those instances into myhead.
09:02:47 <dminuoso> Rather than relying on Haskell to "to the right thing somehow"
09:02:54 <bigos> acowley: I am very uncomfortable with the way HP is done and documented at the moment. The destination folder for install contains spaces
09:03:33 <DrMentats> hey, quick question (hopefully) about gi-gtk: documentation is scarce and now that widgetOverrideBackgroundColor is deprecated I'm completely lost... apparently you use CSS to change the colors of things now, but when I try `ctx <- Gtk.getStyleContext button` Haskell complains that "required ancestor 'Gtk.Style' not found for type 'Gtk.Button'". any ideas?
09:12:15 <namosca> hi all
09:12:16 <namosca> I installed haskell stack and emacs haskell-mode, but i cannot open the interperter in emacs because it doesnt find the ghci... in which file can I instruct emacs to run stack ghci ? I looked to my emacs.d file and this doesnt seem to be the place for it
09:12:56 <cocreature> namosca: do you have a stack.yaml? it should launch stack ghci automatically in that case
09:13:39 <cocreature> namosca: if you want to set it manually take a look at haskell-process-type
09:15:05 <centril> c
09:15:50 <namosca> cocreature: in my ~/.stack I see a config.yaml file, but no stack.yaml
09:16:57 <cocreature> the autodetection only works when you’re inside a stack project that has a stack.yaml. if you want to always stack ghci just set haskell-process-type
09:18:06 <ggVGc> how can I do this better? "maybeToList(sig) <> accumSignals"
09:18:14 <ggVGc> I feel like I should be able to use Applicative or something?
09:18:30 <ggVGc> it's been to long since I was haskelling
09:18:39 <cocreature> ggVGc: seems pretty reasonable tbh
09:19:06 <ggVGc> hm
09:19:21 <ggVGc> I feel there's something I'm missing
09:20:01 <cocreature> I feel like you’re trying to codegolf something that’s not worth codegolfing :)
09:20:16 <ggVGc> I just want to brush up my knowledge
09:20:48 <infinisil> Um, is there no `head :: [a] -> Maybe a`?
09:21:15 <ggVGc> infinisil: there are alternative Prelude implementations that are pure
09:21:20 <liste> :t listToMaybe -- infinisil 
09:21:22 <lambdabot> [a] -> Maybe a
09:21:25 <ggVGc> well, or that
09:21:39 <infinisil> Oh nice
09:21:55 <cocreature> ggVGc: Applicative doesn’t really work here. if you use the Applicative instance of Maybe you’ll get out a Maybe which is not what you want. the Applicative instance of [] doesn’t tell you what should happen with Maybe
09:22:13 <cocreature> you could use toList from Foldable instead of maybeToList but that’s about it
09:22:28 <ggVGc> hm, alright, thanks
09:22:57 <namosca> cocreature: It worked with emacs and stack ghci now, thanks
09:23:54 <AWizzArd> Oho, that looks promising: https://github.com/ucsd-progsys/liquidhaskell/commit/f4b3f716dc30a61b09793d66295c8811c5d1108a
09:24:16 <namosca> I installed a game in stack using stack install frag... how am I supposed to run it now?
09:24:39 <aplainze1akind> Is hdevtools supposed to launch a new instance when ran in a new directory?
09:25:08 <cocreature> namosca: on linux it should copy it to ~/.local/bin so just add that directory to your PATH and you can simply run "frag"
09:26:39 <namosca> cocreature: weird... i dont have it inside my ~/.local/bin... I installed it by tying stack install frag... maybe I did something wrong?
09:27:32 <cocreature> namosca: can you show us the full output of running that command?
09:28:23 <namosca> yes
09:30:36 <namosca> cocreature: here is the link http://lpaste.net/360090
09:31:55 <infinisil> Oh and i just realized, I could've just searched hoogle for "[a] -> Maybe a" to find listToMaybe
09:33:03 <shapr> I do love hoogle
09:34:05 <sternmull> the process package uses a maperrno() function inside its C-stuff. Does anyone know where that comes from? Is this a haskell FFI utility function?
09:34:25 <cocreature> namosca: well it’s failing with a compile error so the executable is simply not produced :)
09:35:23 <namosca> cocreature: oh.. thats so annoying.. i dont have a clue about how to fix it :)
09:36:02 <namosca> cocreature: If it doesnt even compile, it shouldnt be inside stack... i thought all packages there were tested to be woring
09:36:04 <namosca> working
09:36:54 <MarcelineVQ> centril: the only solution I can come up with is to edit   .atom/packages/agda-mode/lib/connector.js   line 173 or so  function autoSearch  but none of my edits are doing anything :( atom must used a cached/compiled version of packages, I'm not sure
09:37:12 <cocreature> namosca: "stack install X" will search for X on hackage if it’s not in stackage, the tested package set
09:38:33 <MarcelineVQ> centril: the edit being to change to something like resolve(parser_1.parseFilepath("/path/to/agdafolder/agdaexecutable"));  in the win32 section
09:38:54 <MarcelineVQ> can't bne sure though, can't get atom to use my changes :<
09:39:36 <namosca> cocreature: ah, nice... so you think that this failed attempt of install let some "dirty leftovers" on my system that requires some manual cleaning, or I can let it go?
09:44:05 <centril> MarcelineVQ: maybe if I use agda-mode from git?
09:47:57 <mud> namosca: Only in ~/.stack/ hidden away somewhere, and I don't think it's much except for stuff it compiled as dependencies.
09:49:17 <MarcelineVQ> centril: worth a try, currently the package is hardwired to give up on windows if   .atom/packages/agda-mode/lib/connector.js  is any indication
09:50:00 <MarcelineVQ> which is confusing as heck, because there's clearly people using it on windows based on the git issue page
09:50:47 <namosca> mud: So it sounds as if its no harm if I dont touch it
09:52:43 <mud> Naw, no harm
09:53:30 <mud> By the way, if you actually want to get that thing working, you could try doing 'stack unpack frag' and going in and messing with stuff. Though I have no idea what's wrong with it, it might just have too loose bounds on dependencies and it's actually supposed to be with a really old resolver (in stack terms)
09:53:57 <mud> Or it could have never worked in the first place, hard to say.
10:01:04 <mgibson> ?
10:01:16 <mgibson> oops
10:14:01 <athan_> How does GHC detect that an MVar or STM reference isn't used, and that blocking on it will be perpetuated indefinitely? Could there be a way to fool this detection system?
10:20:30 <c_wraith> athan_, it's conservative. it checks for any reference in a thread that isn't blocked on the current operation blocking it.
10:21:02 <c_wraith> if every thread with a reference is blocked attempting to read, you know it's deadlocked.
10:21:30 <c_wraith> it doesn't catch every case, but every case it catches is valid.
10:33:36 <athan_> Thanks c_wraith, so there's no real way to "pretend" to put data in, without blocking the thread? I'm just wondering if it takes into consideration transitive blocks, where one thread may eventually be unblocked, which can actually put data - it's just the unblocking of the putter isn't deterministic or something
10:35:31 <c_wraith> all it cares about is reachability from an unblocked thread.
10:52:21 <c_wraith> .. more precisely, not blocked on the same operation on the same reference
10:53:39 <eacameron> So I have a function that takes an `m` in negative position (I think that's what it's called) and it has constraints on `m` for various reasons. It needs those constraints on `m`, but there is no reason that the `m` in negative position has to be *limited* to those constraints. Yet, because it's in negative position, Haskell can only prove that the provided `m` has the constraints I explicitly give it. Is there a
10:53:39 <eacameron> way to do this?
10:54:29 <eacameron> I.e. a way to free up the `m` in negative position to have *at least* these constraints, but not limited to?
10:55:38 <c_wraith> is there some sort of higher-rank quantification going on?
10:56:08 <eacameron> c_wraith: No explicit foralls.
10:56:43 <eacameron> Actually...I think I basically need `Forall` from constraints
10:57:00 <eacameron> Maybe not.
10:57:50 <athan_> c_wraith: would it be sane to catch the `blocked indefinitely` exception, and just retry?
10:59:31 <c_wraith> athan_, no. that would just cause the exception to be thrown again on the next garbage collection
10:59:49 <c_wraith> athan_, the point of that exception is that your logic is broken.
11:00:09 <raynold> ahh it's a wonderful day
11:00:55 <davean> athan_: That exception means it can never become unblocked.
11:01:10 <davean> That exception is the only way anything can ever happen again for it
11:01:27 <carbolymer> how can I debug SIGSEGV in my application? strace does not say much: https://pastebin.com/raw/AU3XKqKA
11:02:09 <c_wraith> carbolymer, try running from gdb
11:02:10 <davean> strace doesn't debug SIGSEGVs
11:02:16 <davean> You'd want gdb, a debugger
11:02:21 <davean> all strace does is show system calls
11:02:34 <carbolymer> oh, good point
11:02:39 <carbolymer> I'll try, thanks
11:03:00 <carbolymer> I was hoping to find anythin in strace results, because I have segfaults only inside docker container
11:03:06 <beaky> hello. is there something like SLIME for haskell. like ghci on steroids on emacs
11:03:17 <davean> carbolymer: Oh ... haha, enjoy that
11:04:00 <davean> Still, start with gdb
11:04:10 <carbolymer> davean, is there something I should know? :D
11:04:15 <carbolymer> sure, sure
11:04:23 <davean> carbolymer: just that docker is kinda jurry rigged and has all sorts of weird shit happen?
11:04:51 <davean> hell, I've seen docker sometimes say a file didn't exist under high IO loads
11:05:13 <beaky> yay just found out about interactive-haskell-mode on emacs
11:05:17 <davean> Great fun when your running 90% odds that an open call will fail or not, and you start just repeating your open callss
11:05:18 <dsal> I've got a program that's doing socket stuff.  How do I timeout my reads so that I can fail if I haven't received something in a while?
11:05:44 <dsal> My main loop is     forever (hGetLine a >>= entry)
11:06:07 <dsal> I'd like to wrap that one with a connect and close, with a timeout on the read.
11:06:12 <athan_> c_wraith, davean: Ah that makes a lot of sense, thank you!
11:06:37 <davean> athan_: often it means that whatever it is blocked on, it holds the only reference to
11:06:43 <davean> which basicly means everyone else has forgotten about it
11:06:54 <dsal> Oh, I just found Network.Socket.Options
11:07:15 <davean> dsal: you can also just wrap it with timeout
11:07:17 <carbolymer> davean, I agree, I like playing with docker, but sometimes it is a huge PITA, like: https://github.com/docker/compose/issues/5179
11:07:34 <davean> dsal: exceptions will interupt the read
11:07:42 <davean> dsal: of course you might want to tickle the timer
11:07:43 <dsal> davean: You mean hGetLine itself?  I guess that could work.
11:08:13 <dsal> I'm reading line-oriented data over the network and should get a line every few seconds.  I just switched networks and it's hanging.  It should probably fail a few kinds of ways here.
11:08:16 <davean> carbolymer: Its funny, I ran a beta release of BSD Jails back in the mid 2000s, you know what? Never had an issue :-p
11:08:31 <davean> Its something about docker
11:08:36 <carbolymer> yep
11:08:37 <davean> Hell, lxc doesn't have these issues
11:09:02 <davean> So the tech docker is built on is fine
11:09:07 <davean> Its something about *docker*
11:09:10 <davean> and they STILL haven't fixed it
11:09:14 <davean> but they're sure adding features!
11:09:45 <carbolymer> that's worrying
11:10:02 * carbolymer should go with VMs instead, probably
11:10:04 <davean> carbolymer: this is why I said "have fun"
11:29:31 <mpickering> How do I reinitialise ~/.cabal/store
11:29:35 <mpickering> and what is it for?
12:00:16 <orion> I want to create an API which abstracts over various cloud providers' APIs. I want each cloud provider to be their own separate library/stack project.
12:00:51 <orion> Would a good design be to have the generic API define a bunch of type families that the specific drivers instantiate?
12:01:44 <orion> Or are other forms of modularity recommended for this purpose?
12:01:51 <lyxia> backpack
12:02:10 <orion> !!! I've never used backpack before. Is this a perfect use case?
12:02:22 <lyxia> it is
12:07:49 <orion> I'll look in to that, thanks.
12:10:49 <agander> Does anyone use stack with --file-watch-poll and --exec with [args] parameters?
12:11:16 <orion> I do.
12:13:33 <agander> For me it doesnt recognize the args. I get: "Error parsing targets: Directory not found: --version" when I send this: "stack build  --file-watch --exec setup_m4_version -- --version"
12:24:19 <sillygauss> i feel like maybe there are enough algebraists here to answer this question :):
12:24:21 <sillygauss> is the following true: if T is some subring of endomorphisms of some abelian group A, the commutant (or centralizer) of T is isomorphic to the endomorphisms of A as a left T-module?
12:35:55 <mnoonan> sillygauss: I'm rusty, but I don't think so. What about A = R^2, T = matrices of the form [[1,t],[0,1]]
12:38:34 <mnoonan> or I guess actually T = [[a,b],[0,a]]
12:38:34 <sillygauss> thanks! let me check... btw, this "fact" comes from here (1st paragraph): https://qchu.wordpress.com/2012/11/11/the-double-commutant-theorem/
12:39:03 <mnoonan> qiaochu is far smarter than I am, so take that into account :)
12:40:10 <sillygauss> do you understand what he actually means? i'm confused in general since the commutant of T is a ring, so i am not sure how think of it as a left-T module of end(A) to begin with (do i then just take the same ring operation as before from End(A)? that must be wrong)
12:55:34 <mnoonan> sillygauss: yeah, I'm not following the "In that case.." sentence either.
12:57:37 <sillygauss> i think it would certainly be very cool if something like that were true. i'm trying to understand what he was actually trying to say.
12:57:44 <sillygauss> your example is good since the commutant in your case is just T itself
12:58:44 <sillygauss> mnoonan: maybe there is some equivalence class on a in End(A) that are related to each other by multiplication by T, and somehow this is the ring that gives the commutant?
12:58:51 <sillygauss> still trying to make it work in your case
13:02:43 <mnoonan> sillygauss: it doesn't really make sense in terms of the other parts of the blog post, either. e.g. if T' is End(A), why note in "Basic properties.." that "T' is a subring of End(A)", "S \subseteq T" implies "T' \subseteq S'", etc
13:04:06 <sillygauss> mnoonan: i don't think he's saying T' = End(A), or are you using that as an example?
13:05:20 <mnoonan> that's how I was reading "T' is just the ring of endomorphisms of A as a left T-module". oh! but he probably means "T' is just the ring of endomorphisms of (A as a left T-module)", I guess?
13:06:39 <sillygauss> ahhh. let me check if that works :)
13:06:52 <mnoonan> yeah, that's gotta be it.
13:08:11 <sillygauss> certainly it contains T' ):
13:08:15 <sillygauss> :)*
13:09:30 <orion> agander: I think you need to separate the build and exec steps.
13:09:34 <orion> They are separate commands.
13:10:07 <sillygauss> mnoonan: ah, the definition of module homomorphism forces to preserve the module structure in the naive way (by commuting past the ring elements)
13:10:09 <orion> I do see the "--exec" flag though.
13:10:26 <sillygauss> mnoonan: all is good, thanks a lot! that has been bugging me for a while
13:10:49 <aoeu256> Is there a haskell IDE or haskell REPL that can "fill in" code for you where you put a x based on types & assertions?  Like if you write assert 5 `x` 8 == 13, it will look for all 200 functions that take two Ints return an an Int and give you (+).  If you write x mylist, it will give you all functions that take a list in 1st argument (similar to the . in OOP IDEs).  Another is if you assert ordered [1, 2, 3] == True && ordered [4, 1, 9] == False, and 
13:10:50 <aoeu256> ordered = x it will see that it takes List of Ints and gives out a boolean. It will try in parallel to find functions from Int[List] to Boolean, Int to Boolean, and List to Boolean.  For all int to boolean functions it will then use map, fold, unfold, etc... to turn it into a list.  For the List to boolean funcs it will ask you if the int type is important or something.
13:11:17 <mnoonan> sillygauss: and to make it channel-relevant again, it was just the difference between "(avoid success) at all costs" and "avoid (success at all costs)" :)
13:11:30 <orion> agander: I think vim+ghc-mod may do what you want.
13:11:37 <orion> To a limited degree.
13:16:13 <anabra> Greeting!
13:16:44 <athan_> Salutations space invader!
13:17:14 <anabra> Quick question: Now with the introduction of -XDerivingStrategies a resolution algorithm was given.
13:17:43 <anabra> My question is, is it only "enabled" when -XDerivingStrategies is enabled, or is it always used?
13:19:21 <anabra> Obviously I meant tha case when the user doesn't explicitly give the strategy.
13:21:00 <agander> orion: Thanks
13:22:27 <athan_> anabra: I'm not sure, but I think type roles might have something to play there
13:23:45 <anabra> athan_: Where could I get a precise answer?
13:27:03 <athan_> anabra: You've got me :\ I'd ask #ghc or hit up the mailing list; you probably know more than me. Have you read the Trac article on it?
13:27:24 <geekosaur> there was an email discussion that spawned the deriving strategies extension, I think on one of the ghc lists
13:28:05 <hariel> from a programmers perspective, is there anything to be gained from learning category theory?
13:28:07 <anabra> athan_: Yes I did, but it isn't clear enough on this subject.
13:30:38 <c_wraith> hariel, depends. it seems to have a lot of stuff in it that can be mined for insight into how to design abstractions that feel natural.
13:31:31 <c_wraith> hariel, but if you just want to *use* abstractions, rather than examine things from other domains to see how they work in programming... eh, not so useful.
13:32:09 <geekosaur> anabra, I think a large part of the problem behind DerivingStrategies is that there *is* no strategy/algorithm by default.
13:33:07 <geekosaur> there's a table in https://ghc.haskell.org/trac/ghc/ticket/10598 showing how different ghc versions handle a conflict situation
13:34:00 <geekosaur> btw https://ghc.haskell.org/trac/ghc/ticket/14357
13:34:07 <dsal> This program I wrote reads a stream of data via TCP, interprets it, and spits out stuff to stdout.  I'm working on reimplementing a thing I wrote in go a while back that does this, but also allows users to connect via TCP and receive their own (filtered) stream.  What's a good approach to having the thing receiving the data broadcast it to whatever transient listeners may be available?
13:34:16 <geekosaur> HEAD already has better docs, https://ghc.haskell.org/trac/ghc/changeset/317aa966b3d89e45227a5870feba339e34d77a18/ghc
13:36:51 <hariel> i see, thank you c_wraith
13:42:53 <anabra> geekosaur, I'm aware these facts, but my my problem is that it's nowhere stated that this algorithm is not only used when DerivingStrategies is enabled.
13:43:15 <geekosaur> so I saw (I'm in #ghc also)
13:43:27 <geekosaur> missed that you'd moved the discussion there though
13:55:37 <fkczkyqub> I'm looking at https://hackage.haskell.org/package/lens-4.15.4/docs/Control-Lens-Wrapped.html but I'm having trouble figuring it out. Could somebody help me with a simple example? I have a function `f :: Int -> Int` and a `newtype New = New Int`. I would like to map `f` over `New` so that I have a `New -> New`. How do I do this?
13:56:36 <fkczkyqub> `Int` and `New` are isomorphic so clearly I can travel from the source `New` up into `Int`, travel along `f` and wrap it in `New` again. But I can't figure out how to make lens do it for me.
13:57:08 <fkczkyqub> I know how to use `ala` to fold monoid types like `Sum` but this is beyond me.
13:58:22 <fkczkyqub> So for example, I would like to apply `liftedDouble` to `New 5` to get `New 10`.
13:58:35 <fkczkyqub> Just applying the function inside the newtype wrapper.
13:58:46 <fkczkyqub> I can't implement Functor because it is the wrong kind.
13:59:43 <fkczkyqub> Manually specified this would be `manually f (New val) = New (f val)`.
14:00:05 <fkczkyqub> It seems like the simplest thing in the world but it doesn't seem to be possible with lens.
14:00:54 <fkczkyqub> But every newtype is just a trivial product type with a well-defined isomorphism.
14:05:03 <geekosaur> lens can't automagically do it if the type isn;t exposed (which would let you make a Functor instance)
14:05:58 <geekosaur> you can define your own Unwrapped and Rewrapped instances for your newtype, or derive Generic and I think then it uses _GWrapped'
14:05:59 <fkczkyqub> I thought that it was the lack of polymorphism that made it impossible to derive Functor.
14:06:16 <geekosaur> that's pretty much the same thing said differently
14:06:24 <fkczkyqub> Is it? Oh, okay.
14:06:46 <geekosaur> you don't expose the inner type beause youd on;t want it to be changeable, but it needs a Functor instance to be able to figure this out by itself
14:06:47 <fkczkyqub> I guess I can do `over (iso unNew New) f`.
14:07:16 <fkczkyqub> I'm okay with it not being a Functor, that seems pretty natural.
14:07:34 <fkczkyqub> But I should be able to apply endomorphisms to the inner type.
14:07:47 <athan_> Is there any kind of asymmetric channels out in the wild? I'm not sure how Go does it, but probably something along its lines
14:08:05 <fkczkyqub> But having to manually specify `iso unNew New` is weird given that it'll be the same for EVERY newtype.
14:08:47 <geekosaur> basically lens manipulates laws to do what it does automatically. but your type doesn;t expose anything with usable laws. you can still do it with manual Unwrapped and Rewrapped instances, which give it 'laws' to work with (and then I think you need to use alaf, so it uses your instances instead of trying to go through Functor)
14:09:48 <geekosaur> hypothetically it might be able to derive this stuff automatically for newtypes using Coercible
14:09:55 <fkczkyqub> Ah, okay.
14:10:59 <fkczkyqub> My thinking was that any newtype provides functions `a -> n` and `n -> a` so given a `a -> a` one should, by function composition, be able to provide a `n -> n` by going `a -> n . a -> a . n -> a`.
14:11:07 <fkczkyqub> And those are laws enough.
14:11:44 <geekosaur> "should". but that is only automateable if the inner type is exposed
14:11:51 <fkczkyqub> Exposed?
14:12:02 <geekosaur> lens can get there now with the Generic instance which lets it forcibly extract the inner type
14:12:18 <fkczkyqub> Can you define "exposed" for me? I only know what it means in the import/export sense.
14:12:41 <geekosaur> again, it's about this being newtype Foo = Foo Int --- the Int cannot be seen
14:12:58 <fkczkyqub> Can you define "cannot be seen" for me please?
14:13:01 <fkczkyqub> I don't know what you mean.
14:13:03 <geekosaur> if you write generically, you cannot typecheck the instances you want to happen automatically
14:13:23 <centril> So... I have:  data Nat = Z | S Nat; data Int = Neg Nat | Pos Nat; and: natrec :: c -> (Nat -> c -> c) -> Nat -> c   ...      and so I'm trying to define primitive recursion on Int, but I'm getting nowhere :/
14:13:41 <centril> cc MarcelineVQ ^
14:14:12 <centril> any hints?
14:14:24 <geekosaur> fkczkyqub, in the general case, the only way to recover Int from Foo is pattern matching. (newtype does not *have* to use record syntax, and there is no way for the lens code to check whether you did or not)
14:14:38 <fkczkyqub> Wait, is pattern matching somehow special?
14:15:19 <geekosaur> that is, there is not guaranteed to be a *function* from Foo to Int, only pattern matching. and the only way to construct one is via Generics
14:15:25 <fkczkyqub> I thought it was essentially identical to `New = New { unNew :: Int }`.
14:15:36 <fkczkyqub> Ohhhh, I didn't realized that was the sticking point.
14:15:47 <geekosaur> *you* can use then the same way. automatically generated code can not
14:15:55 <geekosaur> *use them
14:15:56 <fkczkyqub> Interesting, I had no idea.
14:16:06 <geekosaur> unless you go through Generics, as I described
14:16:09 <fkczkyqub> So if I define it with record syntax, does it become possible?
14:16:57 <geekosaur> I think then you can use https://hackage.haskell.org/package/lens-4.15.4/docs/Control-Lens-Wrapped.html#v:alaf
14:17:18 <geekosaur> a weirdness here si it doesn;t need to actually use the function, it only needs it as proof that it is possible to unwrap
14:17:31 <geekosaur> which is the part it can;t get any other way
14:18:27 <geekosaur> this stuff is tricky, you probably want to go look at the original Epigram work
14:18:47 <geekosaur> not sure if it's actually linked fromthe haddock instead of just being mentioned in the docs for ala and alaf
14:19:01 <fkczkyqub> Oh Conor McBride is excellent. 
14:19:10 <fkczkyqub> So maybe that's the best way to look at it.
14:19:11 <geekosaur> (at least, I don;t see it, might be linked elsewhere in the lens haddocks though)
14:20:10 <fkczkyqub> Okay. I'm going to assume it's impossible then. If it needs the proof, then I might as well implement the iso myself as above.
14:20:28 <fkczkyqub> It's just very ODD that the proof is needed for newtypes, since it's true for ALL newtypes.
14:20:32 <geekosaur> again, I think Coercible might enable it. would have to ask ekmett though
14:21:13 <geekosaur> it's true but it's not automateable in the case of a pattern match, as I understand it. (but with Coercible it is, because the compiler is secretly building the reverse function needed)
14:21:21 <fkczkyqub> Ahhh, okay.
14:21:28 <fkczkyqub> yuck
14:22:01 <geekosaur> well, not even building, it's just taking advantage of the fact that the newtype is the same as the underlying representation. Coercible is a typechecker hack.
14:22:20 <geekosaur> another complication here is type roles
14:22:25 <fkczkyqub> Yeah, that's why it feels weird.
14:22:50 <fkczkyqub> I don't really care about the underlying representation. I just care about the logical isomorphism evident from the structure of every newtype.
14:23:21 <fkczkyqub> This would be a good one for Control.Lens.Tutorial or the Lens FAQ. It's the most trivial map.
14:23:27 <geekosaur> just because the representation is the same doesn't mean it should be exposeable to things like this; sometimes youa re deliberately hiding the type information (consider how Map hides its internals so it can maintain the invariant of the map being sorted by its keys)
14:23:49 <fkczkyqub> Yeah, that makes sense to me, but you're applying a function, aren't you?
14:24:03 <fkczkyqub> And that function is extremely constrained in what it can do.
14:24:16 <fkczkyqub> I suppose it could be used for evil...
14:24:28 <geekosaur> the point is, in this case (type role nominal instead of representational) you do not get such a function
14:24:29 <fkczkyqub> Let's say you have many String-wrapping newtypes.
14:24:40 <fkczkyqub> Programmers could map over them without thinking.
14:25:25 <fkczkyqub> Fine. Manual isomorphisms it is.
14:25:41 <fkczkyqub> I'll give them separate names like `isoNew` so that they can't be confused.
14:26:08 <fkczkyqub> I still think that this explanation should be either in Control.Lens.Tutorial or Lens FAQ, even in the negative.
14:26:13 <fkczkyqub> Maybe I'll make a pull request.
14:36:32 <crucify_me> hi anyone show me precisely how to put a trace on this extended euclid algorithm ? I've been studying a longhand example and hope to see it work in haskell . thanks      https://gist.github.com/trevordixon/6895802
14:37:37 <[exa]> by 'trace' you mean the bezout's coefficients?
14:38:22 <crucify_me> [exa]: hmm ..
14:38:34 <erisco> :t trace
14:38:35 <lambdabot> error: Variable not in scope: trace
14:38:49 <erisco> @hoogle trace
14:38:50 <lambdabot> Debug.Trace trace :: String -> a -> a
14:38:50 <lambdabot> Linear.Matrix trace :: (Trace m, Num a) => m (m a) -> a
14:38:50 <lambdabot> Linear.Matrix trace :: (Trace m, Foldable m, Num a) => m (m a) -> a
14:39:14 <erisco> so for example,  trace "computing 5 + 5" (5 + 5)
14:39:27 <[exa]> oh, for debugging
14:39:32 <[exa]> trace has so many meanings
14:39:52 <erisco> which is something like  trace str x = unsafePerformIO (putStrLn str) `seq` x
14:40:20 <crucify_me> sorry, well I'm not too sure how the extended algorithm works, or why it is used instead of the standard euc. algorithm for LCD
14:41:02 <crucify_me> pardon GCD
14:41:17 <[exa]> crucify_me: that thing you have there is standard euclid algorithm, with hand-defined modulo division
14:42:01 <crucify_me> https://ibb.co/bEACOR  <<      I can see whats going here, but I have questions if you have time.
14:43:02 <[exa]> "extended" is the one that also computes bezout's coefficients for the result (e.g. tells you u,b so that gcd(a,b)=a*s+b*u
14:43:59 <crucify_me> those row calculations on the left, such as row2 - 3 row3 -> 8      .   [exa] 
14:44:11 <crucify_me> how are they determined?
14:44:22 <[exa]> the best example around is this one: https://en.wikipedia.org/wiki/Extended_Euclidean_algorithm#Example
14:44:33 <TCZ> 738e12bc-ac03-4f7c-b25c-e672fb25333d
14:45:07 * geekosaur hears a key rattle
14:45:40 * EvanR presses the key to see what car it goes to
14:45:47 <erisco> what Steam game does that get me?
14:45:48 <[exa]> future is here, instead of sending full messages we now only send GUIDs of them
14:45:51 <crucify_me> [exa] cool thanks. you see ^ where they start at row1 - row2   ? that I understand since they start off with the first division. what about the second one [exa]  ?
14:46:11 <EvanR> [exa]: everything is so unoriginal, everybody has cached rainbow tables of conversations
14:46:19 <[exa]> crucify_me: talking about wikipedia or that your example?
14:46:44 <crucify_me> my example since I've been staring for a time bound to give results
14:46:59 <erisco> GUID poetry rhymes with collisions
14:48:10 <[exa]> crucify_me: oh so. So you have row1 and row2 with first numbers 80 and 62; you can subtract 62 from 80 once for the result to stay positive, so you do it once
14:48:34 <[exa]> and all other columns get treated the same way
14:48:53 <crucify_me> ok thanks [exa] . then how do we know that 8 = -3(80) = 4(62)   ?
14:49:06 <[exa]> result is a new row (row3), you then discard row1 and continue as before
14:49:50 <[exa]> crucify_me: like, the proof that it works?
14:50:05 <crucify_me> one sec please
14:51:54 * [exa] goes afk
14:53:07 <crucify_me> sorry for typo. so how do we know to use -3 for the factor for (80) and + 4 for the factor for (62) [exa]  ?
15:21:32 <EvanR> am i missing a routine for IntMap which is like
15:21:56 <EvanR> (a -> b -> c) -> IntMap a -> IntMap b -> IntMap c
15:23:27 <lyxia> https://hackage.haskell.org/package/containers-0.5.10.2/docs/Data-IntMap-Lazy.html#v:intersectionWith
15:23:34 <EvanR> oh intersection
15:24:46 <c_wraith> I mean, it has to be an intersection with that type.
15:24:53 <EvanR> yeah
15:25:15 <EvanR> since i expect all keys to match up on both sides, i wasnt seeing a diff between union and intersection
15:27:13 <mud> It seems like there should be one with Maybe a -> Maybe b -> Maybe c  ... or ... These a b -> c  ? something like that
15:29:13 <c_wraith> there is https://hackage.haskell.org/package/containers-0.5.10.2/docs/Data-IntMap-Strict.html#v:mergeWithKey
15:29:25 <c_wraith> but.. you have to be careful with it.
15:29:55 <c_wraith> I see that interface was been replaced with something safer in Data.Map
15:48:44 <EvanR> how do you equip things with new unique IDs at runtime in FRP
15:48:55 <EvanR> all at the same time
15:49:43 <EvanR> this is blowing my mind
15:49:46 <monochrom> Do you have access to a clock or a monotonic increasing counter?
15:49:48 <athan> wat EvanR
15:50:02 <EvanR> sure, but at any given time that is only 1 number
15:50:05 <athan> bitemyapp was working on an interesting monotone uuid generator
15:51:11 <athan> EvanR: maybe scrunch it down into a sequential fold somehow?
15:51:24 <athan> idk if your frp environment is multithreaded
15:51:28 <athan> er... concurrent
15:56:07 <EvanR> heres one... with problems ... if there are exactly N things that may be created at any given time, then always have a supply of N IDs sitting there ready to be sampled. if they are ever sampled, at time t+ they will be replaced as a side effect
15:56:21 <EvanR> ready for next time
15:56:39 <EvanR> but what if the number of things is dynamic
15:57:53 <EvanR> this seems like a super sequential corner to be painted into
16:00:52 <EvanR> the "fresh" thing from algorithm M, what a cheat!
16:03:55 <EvanR> step1 understand the problem...
16:30:11 <watsirc> Hey guys, I'm trying to convert a value of type [[Maybe a]] -> Maybe [[a]]. I seem to be struggling to wrap my brain around how to do it with sequence. Any tips?
16:31:00 <koala_man> how do you want that conversion to work?
16:31:56 <Tuplanolla> :t sequenceA . fmap sequenceA
16:31:57 <lambdabot> (Traversable t2, Traversable t1, Applicative f) => t1 (t2 (f a)) -> f (t1 (t2 a))
16:31:59 <watsirc> For clarity, I should say I meant I want a value of [[Maybe a]] to be transformed into a Maybe [[a]]. Basically, Just go through every value in the matrix, if any are Nothing, then the whole thing is nothing, otherwise it is Just the matrix
16:32:22 <Tuplanolla> Try that one, watsirc.
16:32:34 <erisco> :t traverse . traverse
16:32:35 <lambdabot> (Traversable t2, Traversable t1, Applicative f) => (a -> f b) -> t1 (t2 a) -> f (t1 (t2 b))
16:32:47 <watsirc> Ahhh that makes sense, thanks
16:33:43 <erisco> I imagine lens has a nice way to express that
16:34:18 <MarcelineVQ> it's already pretty nice :>    traverse sequence
16:34:52 <watsirc> Ah damn that's even better, sweet
16:35:39 <watsirc> I fully admit I don't quite have a solid understanding of traversables yet
16:36:02 <erisco> well, the typing is simple
16:36:05 <erisco> :t traverse
16:36:06 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
16:36:36 <erisco> the principle operation is sequence, where traverse is like an fmap rolled in
16:36:39 <erisco> :t sequence
16:36:41 <lambdabot> (Monad m, Traversable t) => t (m a) -> m (t a)
16:37:13 <erisco> or sequenceA
16:37:34 <erisco> so, simply, it swaps  g (f a)  for  f (g a)
16:38:32 <erisco> [[Maybe a]]  to  Maybe [[a]]  is clearly pulling Maybe out two levels
16:38:52 <erisco> like  fmap . fmap  the standard pattern for this is  traverse . traverse
16:39:31 <Zemyla> I wish there were a type derived from Traversable where Applicative was replaced by Functor, which could express all tuple-like values.
16:39:39 <erisco> sequenceA  is just  runIdentity . traverse Identity
16:40:21 <Zemyla> I thought sequenceA was traverse id.
16:40:22 <erisco> I may have messed that up
16:40:37 <erisco> yes that is right Zemyla :)
16:40:41 <Zemyla> erisco: You've got it confused with fmapDefault.
16:40:51 <Zemyla> :t \f -> runIdentity . traverse (Identity . f)
16:40:52 <lambdabot> Traversable t => (a -> b) -> t a -> t b
16:40:59 <erisco> mhm
16:41:36 <nshepper1> :t _1 -- Zemyla
16:41:37 <lambdabot> (Functor f, Field1 s t a b) => (a -> f b) -> s -> f t
16:41:56 <monochrom> > traverse id [Just 1, Just 2, Just 3]
16:41:59 <lambdabot>  Just [1,2,3]
16:42:12 <Zemyla> nshepper1: Yes, but I want the signature to be more like (Functor f, ??? t) => (a -> f b) -> t a -> f (t b).
16:42:27 <Zemyla> That way, it can be a subclass of Traversable.
16:43:07 <erisco> so let  s be t a  and  t be t b
16:43:24 <nshepper1> That would mean that the container only has one a
16:43:48 <Zemyla> erisco: Field1 really isn't a good model here.
16:44:11 <Zemyla> nshepper1: Yep. It's the dual of a distributive functor, and there's an adjunction between the two.
16:44:12 <erisco> reason?
16:44:59 <nshepper1> Ie. It's basically the "isomorphic to Identity" type class
16:45:57 <Zemyla> nshepper1: No, it's the "isomorphic to (,) e for some e" type class.
16:46:21 <Zemyla> Like how if f is Distributive, it's isomorphic to (->) e for some e.
16:48:08 <Zemyla> It also represents functorial strength.
17:02:00 <watsirc> Thanks all who helped me out
17:06:54 <zachk> is there a better tutorial or explanation of cloud haskell then hackage and the github site for it?
17:12:07 <lyxia> zachk: have you looked at the resources on the haskell wiki
17:13:12 <lyxia> Otherwise, try asking on their IRC channel or mailing list
17:13:14 <Welkin> zachk: learn erlang
17:13:19 <Welkin> it is erlang as a library
17:13:54 <Welkin> there are two good books on erlang: Learn You Some Erlang (in the style of LYAH), and "Programming in Erlang" by Joe Armstrong
17:18:03 <alive876_> newb quesion, i'm trying happystack web framework. As a first try, wanted to change the port, but  compiler not happy http://lpaste.net/8276275728828334080
17:18:10 <zachk> I played with elixir before, but I kind of like using monadic parsing libraries to parse input text 
17:21:05 <Welkin> zachk: elixir is not erlang. elixir sucks
17:21:55 <lyxia> alive876_: can you paste the error message with it
17:22:04 <Welkin> zachk: cloud haskell is literally erlang as a library, which is why I mentioned learning erlang to learn cloud haskell
17:22:33 <lyxia> alive876_: Is it that Conf is not in scope
17:22:51 <alive876_> yes, 
17:23:33 <lyxia> alive876_: import Happstack.Server (..., Conf(..))
17:23:50 <alive876_> ok thanks
17:30:18 <alive876_> <lyxia> i changed the code, errors listed : http://lpaste.net/3083810574639824896
17:32:44 <dmwit> happystack is now my headcanon
17:35:40 <zachk> I mostly need to figure out how to do node discovery in cloud haskell
17:36:39 <bigos> I had success compiling a Haskell example program that uses Gtk, I am beginning to understand how it works, but I still wonder if it was worth my while.
17:38:14 <ggVGc> I want to keep some decimal numbers in fixed point, but I am fairly confused at what to pick
17:38:25 <ggVGc> Rational? Data.Fixed? Data.FixPoint?
17:38:28 <ggVGc> something else?
17:38:37 <ggVGc> I am keeping account balances
17:38:40 <dmwit> Data.Fixed
17:39:43 <dmwit> Never heard of Data.FixPoint. Where do you see it?
17:40:21 <ggVGc> https://hackage.haskell.org/package/FixedPoint-simple-0.6.1/docs/Data-FixedPoint.html
17:40:29 <ggVGc> sorry, FixedPoint
17:40:31 <ggVGc> not FixPoint
17:41:47 <dmwit> I think I would use that only if I actually wanted the utility functions it offers for pi, sqrt, erf, and friends.
17:41:53 <dmwit> It looks too complicated otherwise.
17:42:06 <dsal> A FixPoint is the opposite of a BreakPoint
17:42:53 <geekosaur> 'fixpoint' makes me think 'fix'
17:43:08 <geekosaur> :t fix
17:43:09 <lambdabot> (a -> a) -> a
17:43:14 <dmwit> Also it violates my soft rule: nothing named "simple", "automatic", "friendly", "smart", etc.
17:44:27 <Zemyla> ggVGc: Data.Fixed is broken. It always rounds down in its internal calculations.
17:44:42 <ggVGc> ^ see that's the kind of info I was looking for
17:44:45 <ggVGc> and what I was suspecting
17:44:50 <ggVGc> Zemyla: what do you recommend?
17:44:53 <ggVGc> Rational?
17:45:43 <dmwit> Rationals tend to grow large if you do a lot of calculations.
17:45:55 <Zemyla> Hmm.
17:45:57 <dmwit> Like, not large in absolute value. But the numerators and denominators tend to grow large.
17:47:02 <dmwit> The speed difference between Rational and Fixed is also quite noticeable (Fixed is much faster).
17:47:08 <nshepperd> just use Integer
17:47:23 <dmwit> Fixed *is* just Integer, basically.
17:48:40 <nshepperd> and if you need to divide anything, use quotRem and know where you're going to put the remainder
17:49:42 <dmwit> Zemyla: Seems easy to fix it to round, just change `div (a*b) (resolution fa)` to `div (a*b + div (resolution fa) 2) (resolution fa)` or something. I wonder what the library@ folks would think of this change.
17:50:28 <dmwit> or use shiftR instead of div _ 2 or something
17:50:43 * geekosaur wonders how much it'd complicate things to make that part of the HasResolution typeclass
17:50:53 <nshepperd> or divMod i guess. I won't tell you what to do with your negative money amounts
17:50:57 <dmwit> geekosaur: Oh, sure
17:51:28 <dmwit> Probably very cheap to add a method with a default implementation.
17:55:58 <dmwit> :t (>>= toList)
17:56:00 <lambdabot> error:
17:56:00 <lambdabot>     Ambiguous occurrence ‘toList’
17:56:00 <lambdabot>     It could refer to either ‘F.toList’,
17:56:08 <dmwit> :t (>>= F.toList)
17:56:09 <lambdabot> Foldable t => [t b] -> [b]
17:56:47 <dmwit> :t catMaybes
17:56:48 <lambdabot> [Maybe a] -> [a]
17:58:50 <Web98473> What is the difference, if any, between "f :: a -> a -> b" and "f :: a -> (a -> b)"?
17:59:29 <dsal> Web98473: The latter is a function that returns a function.
17:59:29 <Welkin> nothing
17:59:35 <Welkin> they are the same
17:59:53 <Welkin> all functions in haskell are curried
17:59:59 <dsal> I guess all functions that take two arguments return functions.
18:00:20 <dsal> Yeah, if you  :t them when partially applied, you'd get the same answer.
18:00:52 <dsal> :t (+1)
18:00:53 <lambdabot> Num a => a -> a
18:01:05 <Web98473> Is there a reason for the notation difference? Can it be enforced that you want a function a -> b as the return type as opposed to just b?
18:01:18 <Welkin> there is no notation difference
18:01:25 <Welkin>  the parentheses in the second one are redundant
18:01:27 <Web98473> There is a notation difference.
18:01:37 <Welkin> no one ever writes it like that
18:01:42 <nshepperd> the difference is the same as the difference between "1 + 2 * 3" and "1 + (2 * 3)"
18:01:45 <Welkin> the compiler will always simplify it
18:02:01 <nshepperd> which is to say, there is none
18:02:30 <Web98473> That you can use parenthesis means there is a notation difference. How that is interpreted/parsed is another matter.
18:02:32 <geekosaur> Web98473, 'enforce that there is a difference'... ther isn't one
18:02:52 <geekosaur> any function that takes more than one parameter *is* a function of one parameter that produces a function which takes the next parameter, etc
18:03:01 <Web98473> In a language that curries, yes.
18:03:01 <geekosaur> this is how partial application works in Haskell
18:03:15 <Welkin> now, if you asked about `(a -> a) -> b` vs `a -> (a -> b)`, then there is a difference
18:03:32 <Web98473> Welkin: explain?
18:04:19 <Welkin> `a -> b -> c -> d -> e` is the same as `(a -> (b -> (c -> (d -> e))))`
18:04:27 <Web98473> Right.
18:05:29 <Welkin> `(a -> a) -> b` could be written as `c -> b` where c :: a -> a
18:05:43 <Welkin> it only takes one parameter before it is fully applied
18:06:39 <Web98473> So this "redundant" notation becomes extremely meaningful when used in that context.
18:06:52 <Web98473> Which is why I was pushing back on that bit.
18:06:59 <Welkin> this is not the same
18:07:02 <Welkin> there is no redundancy here
18:07:04 <Web98473> But the notation is.
18:07:13 <Welkin> parentheses are used in many different contexts
18:07:14 <Web98473> And I'm really glad you brought up that example.
18:07:18 <Welkin> there is nothing special about parentheses
18:07:20 <ivans> (2+3)*5  vs.  2+(3*5_
18:07:22 <Welkin> they are not a notation
18:07:38 <Welkin> they are used here to group types together
18:07:51 <Welkin> in other places they group values together (at the value level)
18:08:10 <Web98473> That grouping is a notation. That you can shift these "redundant" parenthesis around and suddenly change the meaning of something means they are very important.
18:08:27 <Web98473> Like the case you brought up.
18:08:29 <ivans> they are not redundant in (a -> b) -> c
18:08:40 <ivans> because in that case they do change the meaning
18:08:45 <ivans> they are redundant in a -> (b -> c)
18:08:53 <ivans> because -> is already right-associative
18:09:22 <ivans> you can't infer from that that parentheses are always redundant
18:09:26 <Web98473> Now consider a functional language using similar signatures for functions that does not curry.
18:10:02 <Web98473> In such a hypothetical context, would "a -> (b -> c)" still be redundant?
18:10:03 <nshepperd> is this question still relevant to haskell
18:10:13 <ivans> depends on the language
18:10:17 <Web98473> It is relevant in the same way that "(a -> a) -> b" is relevant.
18:10:50 <ivans> (a, b) -> c is used in some languages, but this is #haskell
18:11:00 <Web98473> Would it be correct to say that "f :: (a -> a) -> b" is a function taking a function and returning some type, b?
18:11:24 <ivans> yeah
18:11:31 <ivans> more or less
18:11:31 <Welkin> it doesn't produce a type
18:11:42 <Web98473> A term of type 'b'.
18:11:45 <ivans> a value
18:11:58 <Web98473> Yes that was the meaning intended.
18:12:19 <Welkin> yes
18:12:25 <Welkin> but `b` could be anything
18:12:32 <Welkin> `b` could be `c -> d`
18:12:45 <nshepperd> it would be very silly for a non-currying language to use the 'a -> b -> c' syntax
18:12:49 <Welkin> `a` could be `(e -> f) -> k`
18:12:51 <nshepperd> but why should we answer your questions about hypothetical languages? this is a haskell chat room
18:12:51 <Web98473> But, what I am asking, is if you recognize the distinction between a function returning a function and a function returning a 'value' (that is not a function)?
18:13:17 <nshepperd> Web98473: functions are values
18:13:34 <Welkin> Web98473: a function can be applied to values, but you cannot apply a value to a value
18:13:38 <Web98473> nshepperd: yes, I know, that is why my question was qualified.
18:14:11 <ivans> is there a greater point behind these questions
18:14:22 <Web98473> That's a very strange thing to ask.
18:14:34 <Welkin> Web98473: the easiest way to think about it is making the types work out
18:14:50 <Welkin> you need to unify the types to produce your new type signature
18:14:51 <ivans> it seems like you might be trying to understand a distinction between Haskell and some other language
18:15:40 <Web98473> ivans: I study and work in a very large number of programming languages, but I like working in Haskell for certain tasks/tinkering. It can be very educating to compare to known systems.
18:15:57 <nshepperd> Web98473: the type of 'id' is a -> a. That a can be anything, including a function type
18:16:09 <nshepperd> :t id :: (b -> b) -> (b -> b)
18:16:10 <lambdabot> (b -> b) -> b -> b
18:16:21 <Welkin> it is easier to start with concrete types
18:16:28 <Welkin> let's use Int and Bool
18:16:35 <Welkin> Int -> Int -> Int
18:16:35 <Web98473> I'm aware of the polymorphism implied by the notation.
18:17:05 <Welkin> you can apply the above function to exactly two values of type Int
18:17:06 <Web98473> What I am really asking isn't relevant to Haskell, as you've said, because its curried.
18:17:09 <nshepperd> it doesn't make sense to ask whether id returns a function, or a non-function 'value'
18:17:17 <Welkin> then you have a value of type Int, which cannot be applied to anything
18:17:28 <nshepperd> it can be either, depending at what type it is used
18:18:19 <Web98473> At any rate, the -> notation, with parenthesis, is used in a very wide variety of typing situations. It's not nonsensical for it to exist in a formal language that does not implicitly curry.
18:18:37 <Welkin> -> is an infix type constructor
18:18:51 <Web98473> In such a situation, I was wondering if it would be a convenient notation for a higher-order function.
18:18:53 <Welkin> `(->) a b` is `a -> b`
18:18:56 <ivans> before starting with concrete types... maybe start with a concrete language in mind
18:19:25 <Welkin> `(->) ((->) a a) b` is `(a -> a) -> b`
18:19:33 <Web98473> Yes, I'm aware of that rofl.
18:19:50 <nshepperd> a language can use whatever syntax it likes
18:20:08 <Welkin> Web98473: that is exactly what it is used for, higher-order functions
18:20:11 <Web98473> Welkin: The biggest thing was when you provided the counter-case to my question. Which actually answered it on a deep level by making me think about how that works internally.
18:20:41 <Web98473> Welkin: You pretty much hit the nail on the head with the 'f :: (a -> a) -> b' example.
18:23:46 <Web98473> Welkin: Thank you. Heading out o/
18:47:03 <kerrhau> what fp lang should I learn first?
18:47:31 <monochrom> Haskell.
18:48:20 <Welkin> there is only one
18:48:42 <Axman6> Yes, Lambda Calculus
18:48:56 <monochrom> No, there are also Agda and Idris.
18:49:25 <Welkin> there is only one practical purely functional language
18:49:29 <Welkin> and that is haskell
19:05:35 <orion> Is the Writer Monad considered harmful?
19:07:46 <heath> elm is a decent first fp language
19:08:10 <monochrom> No. It just probably isn't too useful, and when it's useful you probably need to choose your monoid carefully.
19:09:39 <heath> if you're starting out, it's fine
19:10:07 <monochrom> Writer Monad considered use with thoughtful consideration not you use it just because you saw other people use it.
19:10:27 <monochrom> Then again, all of Haskell too.
19:11:03 <heath> also, https://code.world/ is a nice effort to teach fp
19:11:22 <monochrom> Unlike wearing jeans, where you wear jeans just because you saw other people wearing jeans. (I don't.)
19:11:34 <rotaerk> lol
19:11:53 <orion> In my case, I'd like to append elements to a list using do-notation.
19:12:33 <orion> I specifically want do-notation for aesthetic purposes. There is no mathematical reason for it.
19:12:57 <heath> https://www.reddit.com/r/haskell/comments/79i7h9/why_is_elm_more_popular_than_purescript/dp433ls/
19:13:33 <heath> all of the comments are worth reading: https://www.reddit.com/r/haskell/comments/79i7h9/why_is_elm_more_popular_than_purescript/
21:02:02 <slack1256> the X11 library should be learn by they C api and then translate that knowledge for the haskell side right?
21:04:16 <LiaoTao> slack1256: That seems reasonable
21:04:24 <LiaoTao> For many libraries that Haskell wraps
21:04:39 <LiaoTao> Unless it's high-level bindings, in which case you should refer to their own documentation
21:04:45 <geekosaur> although you might do better to start from xhb, since X11 package is Xlib
21:05:48 <slack1256> but there seems to be more documentation for Xlib event though xcb is newer
21:06:28 <slack1256> although the stuff is weird. XQueryTree seems to return windows twice and on the haskell side, you have to allocate those structures, funny.
21:06:54 <rwarfield> Hey haskellers. I'm tying to write a heterogenous list type together with a function to extract the nth element (as a learning exercise in part). Was hoping someone could have a look at https://pastebin.com/kLvTb9KW and tell me what I'm doing wrong..
21:07:10 <rwarfield> (sorry for the weird highlighting on pastebin)
21:07:30 <slack1256> rwarfield: semi related, you can use also lpaste
21:07:40 <slack1256> @where lpaste
21:07:40 <lambdabot> http://lpaste.net/
21:09:00 <rwarfield> Thanks.... didn't know about lpaste. This looks nicer: http://lpaste.net/389669596648439808
21:09:06 <saurabhn_> `top` is reporting ~1 TERABYTE usage of my Haskell process in production. What could be going wrong? https://www.dropbox.com/s/piivhynf7unsm29/Screenshot%202017-11-17%2010.38.20.png?dl=0 (the server most definitely doesn't have that kind of RAM)
21:09:23 <mniip> saurabhn_, that is correct
21:09:25 <MarcelineVQ> saurabhn_: nothing, it's just reserved that space, it's not using it
21:09:33 <mniip> ghc rts is using 1TB of virtual memory
21:09:33 <geekosaur> saurabhn_, that's the new memory allocator. thre pages are reserved but unpopulated
21:09:34 <saurabhn_> what?!
21:09:40 <saurabhn_> 1 TB of space pulled out from where?
21:09:42 <mniip> MarcelineVQ, it's not recerved either
21:09:47 <mniip> saurabhn_, it's virtual!
21:10:00 <slack1256> virtual memory on linux isn't allocated until commited. So you are free to declare you will need much
21:10:04 <MarcelineVQ> mniip: doh
21:10:05 <geekosaur> saurabhn_, it means you have page tables alloated, not memory. top is not smart enough to understand the difference
21:10:12 <saurabhn_> but why? there is no way that the process can get that kind of memory even if it is required (eg. due to a load-spike)
21:10:23 <slack1256> performance
21:10:23 <saurabhn_> which tool can I use to check actual memory usage, in that case?
21:10:44 <MarcelineVQ> saurabhn_: top has a stat called RES
21:11:43 <saurabhn_> which is 76mb right now
21:11:45 <slack1256> saurabhn_: ps -o rss <pid-of-program>
21:11:55 <slack1256> rss Resident Set Size
21:12:18 <mniip> by default linux will reserve the pages in swapspace
21:12:31 <mniip> mmap's flag MMAP_NORESERVE disables this behavior
21:12:52 <saurabhn_> slack1256: is that reporting in bytes or kb?
21:12:53 <mniip> with the catch that if the system is out of RAM *and* swap you can get a SIGSEGV
21:13:01 <saurabhn_> I'm getting: RSS=269476
21:13:13 <slack1256> saurabhn_: I think kilobytes. Check the man page
21:13:20 <mniip> could be 4k pages
21:13:33 <slack1256> I think ps does that conversion already
21:13:33 <saurabhn_> slack1256: in kb
21:13:56 <saurabhn_> so that's about 270 MB of actual memory being used with a out-of-whack option of using up to 1TB (?!?!)
21:14:11 <saurabhn_> sorry that was for the rails process
21:14:13 <saurabhn_> let's check for haskell
21:15:19 <saurabhn_> 78MB for Hakell
21:15:59 <saurabhn_> and what would the activity monitor on Mac OSX be showing -- https://www.dropbox.com/s/onfrk6omhylexjd/Screenshot%202017-11-16%2016.23.15.png?dl=0 ?
21:16:11 <geekosaur> https://ghc.haskell.org/trac/ghc/ticket/9706
21:17:12 <geekosaur> https://downloads.haskell.org/~ghc/master/users-guide/8.0.1-notes.html#runtime-system
21:17:17 <geekosaur> that's the one I was looking for
21:19:54 <crobbins> for type class instances that depend on existing instances, do they need to be re-instantiated on demand, or is there some sort of optimization? for context, take a look at Scala which _does_ re-instantiate on demand: https://gist.github.com/carymrobbins/4bb71a4540291857646a06febf1bdde1
21:20:09 <geekosaur> (always fun to watch someone discover what virtual memory actually means. people just don't seem to get the idea at all. including the authors of utilities like top)
21:21:40 <geekosaur> ...ghc isn't commonly used enough for such authors to care. back in the 90s, xfree86 (not yet xorg) changed the way it mapped the video card into memory and top similarly misreported it; iirc they fixed it with a hack instead of doing ot right, which would have made top ready for this kind of memory allocation strategy as well
21:24:45 <fkl> Is there a substitute/equivalent in the singletons library for the KnownNats typeclass in typelists-witnesses?
21:26:33 <LiaoTao> geekosaur: Care to elaborate?
21:26:38 <LiaoTao> Sounds interesting
21:26:45 <slack1256> when I was learning haskell I thought "well this is hard but after I will write programs easily", then I learned that libraries are hard to get to know 
21:26:46 <lyxia> crobbins: both are equivalent in Haskell
21:27:29 <crobbins> lyxia: hmm so you'd end up instantiating two instances of the same Show instance?
21:27:41 <crobbins> i would have hoped that haskell optimized that away somehow
21:29:07 <lyxia> It depends, but I'm not sure what GHC does exactly.
21:29:22 <lyxia> No sharing means easier inlining.
21:30:41 <lyxia> SPECIALIZE can also help, I don't remember how it works though.
21:31:08 <fkl> slack1256  can sympathize, how far along are you?
21:31:39 <jle`> fkl: hi typelits-witnesses is my library and it's kinda deprecated
21:31:46 <jle`> but i just haven't officially doe so :)
21:32:00 <jle`> i have been meaning to write up how to do all of it in singletons instead
21:32:04 <jle`> fkl: but it's basically SingI
21:32:16 <jle`> (the equivalent of KnownNats in singletons is SingI)
21:33:37 <slack1256> I would say I am an expert haskeller
21:33:50 <slack1256> for the stuff is in base or platform
21:33:56 <lyxia> crobbins: for the most part, inlining makes a lot of these dictionaries disappear at compile time so it doesn't seem that much of a problem to me. The compiler also does common subexpression elimination, maybe that helps?
21:34:31 <slack1256> is the stuff that is outside that (as the X11, sometimes lens) that really make me scratch me head sometimes
21:34:36 <lyxia> crobbins: If you have an example where it's behaving badly, I'm sure GHC developers would be interested.
21:38:09 <dsal> I'm pretty good at Num
21:46:09 <fkl> jle` the equivalent of KnownNats in singletons is SingI ? that doesn't make sense..
21:48:12 <jle`> fkl: yes an NatList is Sing
21:51:15 <fkl> hmm, but Sing / SingI aren't specific to Nats
21:51:21 <fkl> what do you mean by that?
21:52:09 <jle`> fkl: yeah, Sing and SingI are polymorphic
21:52:11 <jle`> they are poly-kinded
21:52:27 <jle`> they work for several different kinds, not just Nats :)
21:52:29 <jle`> *Nat
21:52:39 <jle`> which is why it's a superior alternative
21:53:11 <fkl> how then would I express a constraint that is specific to [Nats]
21:53:12 <jle`> it generalizes KnownNat and KnownNats interface to several different kinds and unites them under the same interface
21:53:17 <dmwit> crobbins: I think the answer here is complicated enough that you should read the Core to know the answer for any given program.
21:53:23 <jle`> fkl: you don't have to, cause we have kind inference
21:53:40 <jle`> kind inference should let haskell know the kind of a type variable
21:53:51 <fkl> but what if i want to constrain the intent?
21:53:53 <jle`> if you use a kind variable in a situation that expects [Nat], then it'll be inferred as having kind [Nat]
21:54:11 <fkl> or is it considered back practice to specialize?
21:54:21 <fkl> *bad practice
21:54:25 <jle`> i mean you can if you want, but usually there's no point?
21:54:26 <dmwit> crobbins: But basically I would expect dictionaries to be constructed only in very rare circumstances, or when the user is doing advanced typehackery.
21:54:37 <jle`> fkl: you can also just manually do SingI (ns :: [Nat])
21:54:46 <dmwit> (The alternative to "dictionaries being constructed" being "a static dictionary being used".)
21:55:13 <fkl> readability maybe? also, "I have no idea what this code means in other scenarios?"
21:56:14 <jle`> it's sort of something similar to using 'return' or 'pure' in different contexts, or different integer literals
21:56:30 <jle`> you don't necessarily always do `return True :: Maybe Bool`
21:56:37 <jle`> but...you could
21:56:41 <crobbins> dmwit: yeah tried to read the core, not my forte just yet ;)
21:56:52 <dmwit> definitely takes some practice
21:57:21 <dmwit> But I believe in you. =)
21:57:32 <fkl> oh that's cool so I can do stuff like
21:57:46 <fkl> SingI (blah:: [[Nat]]) => 
21:58:00 <crobbins> wow
21:58:04 <crobbins> you're great dmwit 
21:58:09 <fkl> in my signatures without defining a typeclass, neat!
21:58:23 <jle`> yeah, or even SingI (blah :: [[[Nat]]]) =>, or SingI (blah :: Bool), SingI (blah :: [Maybe Nat]), etc.
21:58:26 <crobbins> specifically i've generated this
21:58:27 <crobbins> https://gist.github.com/carymrobbins/33a86c2a9349cab2153f00e26786b52d
21:58:30 <jle`> fkl: well, SingI is actually a typeclass
21:58:38 <jle`> that has to be individually defined for every kind
21:59:21 <jle`> in some sense you can think of it as a way to unite KnownNat and KnownNats and KnownSym and KnownSyms etc. 
21:59:36 <jle`> but someone had to define every instance of SingI, just like defining KnownNat/KnownSym/ec.
21:59:42 <fkl> jle` is there a way to define an alias 
21:59:49 <jle`> er sorry, i mean, every *kind* instance
21:59:52 <dmwit> crobbins: `\ (@ a_a43u) ($dShow_a43v :: Show a_a43u)` <- this is a function which takes as arguments a type and a Show dictionary for that type.
21:59:55 <jle`> yeah you can just make a type synonym
22:00:06 <fkl> like KnownNats = SingI (blah :: [Nats])
22:00:33 <dmwit> crobbins: Then, later, `show @ a_a43u $dShow_a43v x_a43m` is passing along that dictionary to `show` (along with the value to show, `x_a43m`).
22:00:38 <jle`> fkl: yeah, the singletons library does this with every kind instance actually
22:00:50 <fkl> what's the syntax? i have a hard time keeping all the different type definition methods straight
22:01:09 <jle`> oh sorry, the library does this for Sing's, not SingI's
22:01:16 <dmwit> crobbins: You can see a similar pattern in the other `Show`-polymorphic functions in that dump.
22:01:26 <jle`> but it'd be type KnownNats (ns :: [Nat]s) = SingI ns
22:01:26 <watsirc> Hey guys, would anyone mind explaining to me why (/5) $ (length . filter (> 0) $ [-5..10] is not a valid expression? GHC complains about the lack of a fractional instance for Int, which it seems like it ought to be
22:01:36 <jle`> er, without that stray 's'
22:01:48 <jle`> watsirc: there is no Fractional instance for Int
22:01:54 <fkl> i'm still in the stage of getting kind definitions confused
22:01:59 <dmwit> crobbins: In short, no dictionaries are being constructed in that dump that I can see, only passed along faithfully unchanged.
22:02:07 <fkl> sometimes it's class, type, or data w/ datakinds, ...
22:02:31 <jle`> yeah, it's admittedly a bit lot to take in
22:02:38 <nshepperd> oh, the haddock for the Sing instances is confused
22:02:40 <watsirc> jle: Right I figured as much, I just mean that the expression seems like it ought to be valid. Shouldn't I be able to divide an integer by another integer?
22:02:51 <dmwit> > 6 `div` 3
22:02:53 <lambdabot>  2
22:03:02 <jle`> watsirc: integer division is different than the division implied by (/)
22:03:16 <jle`> watsirc: what would the result of your division be?
22:03:17 <dmwit> :t (/)
22:03:18 <dmwit> :t div
22:03:18 <lambdabot> Fractional a => a -> a -> a
22:03:18 <jle`> *what type
22:03:19 <lambdabot> Integral a => a -> a -> a
22:03:20 <fkl> Illegal constraint synonym of kind: ‘Constraint’
22:03:21 <nshepperd> was wondering why it was saying silly things like 'STrue :: SingBool z'
22:03:30 <fkl> I guess this is what ConstraintKinds is for...
22:03:55 <fkl> another day  another extension I didn't know about
22:03:56 <jle`> fkl: mhm
22:04:11 <jle`> one of those extensions that probably should be a normal part of the language anyway
22:05:17 <watsirc> Sorry, I don't mean integer division. I suppose though that the real issue is that length returns an Int instead of a Num, but I don't exactly know how it could return a Num so yeah
22:05:19 <jle`> fkl: but really seeing a SingI ns => constraint should really be like seeing a `Sing ns ->` 
22:05:28 <jle`> watsirc: 'Num' is not a type
22:05:34 <dmwit> :t genericLength
22:05:35 <lambdabot> Num i => [a] -> i
22:05:45 <jle`> fkl: and seeing a 'Sing ns ->'  should really be like seeing 'ns ->'
22:06:21 <watsirc> jle`: I know, I mistyped. All I mean to say is that length is not sufficiently generic, though it looks like the function linked by dmwit does the trick. Thanks
22:06:25 <jle`> watsirc: you can use fromIntegral to turn an Int into, say, a Double
22:06:36 <jle`> i wouldn't use genericLength in practice, but
22:06:42 <crobbins> dmwit: comparing against a simple instance which _doesn't_ depend on another...
22:06:44 <dmwit> > (%5) . length . filter (>0) $ [-5 .. 10]
22:06:47 <lambdabot>  2 % 1
22:06:53 <dmwit> watsirc: ^^
22:07:15 <jle`> :t fromInteger
22:07:16 <lambdabot> Num a => Integer -> a
22:07:27 <fkl> fkl` how are they equivalent? you mean if haskell were dependently typed?
22:07:32 <fkl> is that how it looks in idris?
22:07:36 <dmwit> Actually, I guess that one is a bit dangerous, since it leaves you with a `Ratio Int`, which is... yeah, easy to overflow.
22:07:58 <dmwit> > (%5) . genericLength . filter (>0) $ [-5..10]
22:08:01 <lambdabot>  2 % 1
22:08:04 <dmwit> much better =)
22:08:08 <fkl> unrelated - are GADT and TypeInType not compatable?
22:08:14 <jle`> fkl: `SingI ns =>` is the same as `Sing ns ->`, because a SingI constraint only just gives you the ability to conjure a 'Sing ns'
22:08:28 <jle`> fkl: and 'Sing ns' is basically nothing more than a runtime witness for the type 'ns'
22:09:17 <jle`> so `SingI ns => ...`, or `Sing ns -> ...`, basically just tells you that you can 'match' on ns at runtime
22:09:19 <fkl> jle` but it would still be a different function right? in one case the information is type level and in the other case the information is term level
22:09:24 <fkl> if i'm understanding you correctly
22:09:34 <dmwit> fkl: As far as I know, all extensions are compatible with all others.
22:09:49 <jle`> fkl: no, the two are the same
22:09:55 <jle`> and you can convert between the two
22:11:08 <fkl> dmwit turning on typeInType causes GADT signatures to choke on [*]
22:11:10 <fkl> Not in scope: type constructor or class ‘*’
22:11:13 <jle`> functions of type `SingI ns => Blah` and functions of type `Sing ns -> Blah` are isomorphic, the constraint is basically just an a way to implicitly pass a Sing ns
22:11:33 <jle`> fkl: TypeInType hides * behind an import
22:11:35 <jle`> Data.Kind
22:11:50 <fkl> i think we're saying the same thing ...
22:11:52 <jle`> although i think it might even disable it and require you to use 'type Type = *' instead
22:12:19 <jle`> so you'd use [Type], not [*]
22:12:25 <fkl> isomorphic in their meaning, but the functions would be used differently as that information is passed as a type or term
22:12:50 <jle`> ah yeah, you would use the functions differently
22:13:13 <jle`> i'm just trying to convey a statement about how you should be interpreting what a SingI ns =>, or a Sing ns -> "maens"
22:13:36 <jle`> s/statement/sentiment
22:14:01 <jle`> s/should/could
22:14:23 <hariel> does anyone have an estimation of how big the latest lts release is?
22:15:06 <fkl> I think I understand. I was only thinking of SingI for cases where I would need to pull out the term value
22:15:07 <hariel> i might have to go without internetz for some time and am thinking of dling the whole thing
22:15:23 <fkl> hadn't thought to use it to define class constraints
22:19:25 <dmwit> hariel: It's been a while, but at some point I think I did download the latest version of every package on Hackage. It wasn't that bad -- a gig or two, I think? My memory is pretty hazy.
22:20:02 <crobbins> ok so if i do this: print (Some (1::Int))
22:20:04 <crobbins> i see: (Ghci4.$fShowOption @ GHC.Types.Int GHC.Show.$fShowInt)
22:20:17 <crobbins> so wouldn't that construct a new dict?
22:20:57 <dmwit> yep
22:21:01 <crobbins> so we'd end up with N dicts for fShowOption, where N is the number of distinct `a` types, so long as ghc inlines it all
22:21:16 <dmwit> Oh, well, yes. You can't avoid that.
22:21:30 <hariel> not bad, im thinking of grabbing latest lts and nightly before i go
22:21:48 <jle`> hariel: let me know if you figure out a nice way to do it :)
22:21:54 <crobbins> but what you _can_ avoid is constructing duplicate `Show (Option a)` for the same `a`
22:22:01 <crobbins> because i assume the compiler will inline it
22:22:06 <hariel> hehe will do
22:22:23 <dmwit> Right to the former. Inlining is the opposite of what you want to avoid constructing duplicates, though.
22:25:56 <crobbins> oh i guess i mean _caching_
22:26:10 <crobbins> and substitution
22:37:29 <nshepperd> aha! I figured out how to compile both with and without profiling to make -fplugin work with -prof
22:39:51 <nshepperd> some black magic going on the compiler there o_o
22:51:55 <dminuoso> How can I simplify something like `liftM3 f (g a) (g b) (g c)`. I want to get rid of this repeated mentioning of `g`
22:55:53 <ertes> dminuoso: i wouldn't call it a simplification, but…
22:56:11 <ertes> liftA3 (liftM3 f) ($ a) ($ b) ($ c)
22:56:24 <dminuoso> ertes: Oh hey. I realized this was simpler by the way :)
22:56:25 <dminuoso> replace n w = (>>= \x -> if x == n then w else return x)
22:56:28 <ertes> err
22:56:30 <dminuoso> replace :: (Eq a, Monad m) => a -> m a -> m a -> m a
22:56:31 <ertes> liftA3 (liftM3 f) ($ a) ($ b) ($ c) g
22:57:00 <glguy> ertes: That makes a similar assumption that ?pl would that g had the same type in each occurrence
22:57:02 <ertes> dminuoso: yeah =)
22:57:15 <ertes> glguy: indeed
22:57:51 <dminuoso> ertes: And in fact the point-free notation helped me make it so obvious how monadic bind replaces expressions. :)
22:58:05 <glguy> but that's implicit in the question, so I'm going to go back to not saying anything...
22:58:13 <ertes> dminuoso: note how you can use 'replace' to replace any list element by a sublist, and you can use the same function to substitute variables
23:03:12 <mniip> :t ((=<<) .) . (. (==)) . liftA3 bool return . const
23:03:13 <lambdabot> (Eq a, Monad m) => m a -> a -> m a -> m a
23:03:32 <dminuoso> mniip: I see what you did there. Full point-free :o
23:03:50 <dminuoso> That dot dot dot is a bit crazy though.
23:04:31 <mniip> @unpl (f .) . (. g)
23:04:31 <lambdabot> (\ x x0 -> f (x (g x0)))
23:04:44 <ertes> except it's not the same function =)
23:05:14 <mniip> flip
23:05:32 <mniip> ok lemme try again
23:07:30 <mniip> :t (. liftA3 bool return . const) . ((=<<) .) . flip id . (==)
23:07:31 <lambdabot> (Eq a, Monad m) => a -> m a -> m a -> m a
23:07:39 <mniip> better?
23:11:33 <osa1> in lens is there anything like `each` but for indexed types like conteiners' Data.Map.Map?
23:19:10 <Axman6> ix and at
23:19:13 <Axman6> :T ix
23:19:16 <Axman6> :t ix
23:19:17 <lambdabot> (Applicative f, Ixed m1) => Index m2 -> (IxValue m1 -> f (IxValue m1)) -> m1 -> f m1
23:19:19 <Axman6> :t at
23:19:21 <lambdabot> (Functor f, At m1) => Index m2 -> (Maybe (IxValue m1) -> f (Maybe (IxValue m1))) -> m1 -> f m1
23:19:46 <Axman6> which are from... Control.Lens.At I think?
23:19:53 <Axman6> @hoogle at
23:19:53 <lambdabot> Control.Lens.At at :: At m => Index m -> Lens' m (Maybe (IxValue m))
23:19:53 <lambdabot> Safe at :: Partial => [a] -> Int -> a
23:19:53 <lambdabot> Lens.Micro at :: At m => Index m -> Lens' m (Maybe (IxValue m))
23:19:59 <nshepperd> osa1: you can just use traverse if you want to touch all values
23:20:02 <Axman6> yep, they're both in there
23:20:07 <nshepperd> :t traverse :: Traversal (M.Map k a) (M.Map k b) a b
23:20:08 <lambdabot> Applicative f => (a -> f b) -> M.Map k a -> f (M.Map k b)
23:33:57 <osa1> I actually want to map elements and get a list of results, something like `map f (Map.elems m)`. of course the code is not that simple, it's a lens expression that at some point gets this map
23:34:33 <osa1> I'm currently binding result of this lens to a variable, then do this `map f (Map.elems m)` stuff. if possible I'd like to eliminate this single-use variable
23:38:56 <nshepperd> well, you can use traverse exactly as you would use each in a lens expression
23:39:04 <nshepperd> > (M.fromList [("foo", -11), ("bar", 3)], Nothing) ^.. (_1 . traverse . to abs)
23:39:06 <lambdabot>  [3,11]
23:39:56 <osa1> ah.. for some reason I thought traverse would return a new map with values applied to the function
23:40:01 <dminuoso> ertes: Getting quite excited when I'm advanced enough to start with parsers in Haskell, it seems like dealing with ASTs could be fun.
23:40:10 <osa1> thanks
23:41:26 <nshepperd> > each (\x -> Identity (x + 100)) (5, -9, 4, 4)
23:41:28 <lambdabot>  Identity (105,91,104,104)
23:41:41 <nshepperd> > traverse (\x -> Identity (x + 100)) [5, -9, 4, 4]
23:41:43 <lambdabot>  Identity [105,91,104,104]
23:42:04 <cocreature> osa1: (^..) always converts to a list
23:44:42 <nshepperd> 'return a new map with values applied to the function' as an intuition for what traversals and lenses do sort of breaks down when you start thinking of functors like Const, which is what ^.. secretly uses under the hood
23:45:32 <nshepperd> > traverse (\x -> Const [x + 100]) (M.fromList [("foo", -11), ("bar", 3)])
23:45:34 <lambdabot>  Const [103,89]
23:46:11 <osa1> interesting. I should properly study lens sometime.
23:49:47 <jcarpenter2> lens seems goop
23:49:50 <nshepperd> lenses are super cool
23:50:07 <jcarpenter2> pretty goop
23:50:23 <nshepperd> i was just using aeson-lens library the other day
23:51:10 <nshepperd> so much nicer and boilerplate free to just lens into a Text to pull out some value from the middle of a pile of json
23:51:14 <dminuoso> Does parametricity guarantee a natural transformation between any two functors exists?
23:51:22 <nshepperd> much better than writing To/FromJson instances
23:51:31 <dminuoso> Im trying really hard to something sensible for Maybe -> Const, but I just dont see how this could owrk.
23:52:05 <dminuoso> Other than producing Const () 
23:52:47 <nshepperd> i think it guarantees that if you can write one, it's actually a natural transformation
23:53:06 <dminuoso> Ahh.
23:53:44 <dminuoso> Oh and Const () would be wrong, but `Const undefined`. Not sure whether using bottom as an escape hatch would be legit.
23:54:21 <nshepperd> yeah i don't think it counts if you use undefined
23:54:50 <cocreature> if you count undefined then you can implement arbitrary type signatures so discussions what’s implementable becomes kind of meaningless
23:55:30 <dminuoso> I suppose then I have my answer. A natural transformation from Maybe to Const cannot exist.
23:57:26 <dminuoso> cocreature: How can you reason about the type system with bottom existing in the first place?
23:57:42 <dminuoso> Are there proofs to show that one can ignore bottom?
23:58:15 <geekosaur> @google fast and loose reasoning is morally correct
23:58:16 <lambdabot> https://pdfs.semanticscholar.org/a316/3d9097a87a713f0dd3f154f139e19dcb2a82.pdf
23:58:17 <nshepperd> but I suppose parametricity means that const Nothing is a natural transformation from anything to Maybe
23:58:24 <jcarpenter2> dminuoso: i agree :P
23:58:33 <jle`> dminuoso: be aware that Const is not a Functor
23:58:53 <jle`> so like you might be looking for the answers to the wrong question
23:59:45 <jle`> Const actually provides a *family* of functors
23:59:50 <jle`> many different ones
