00:00:19 <romanix> ghc starts to swap when compiling my app, not itself :)
00:01:32 <romanix> i dread the prospect of ripping out my dependencies to track which library(ies) are causing this so was hoping there was an easier way :)
00:16:11 <ertes-w> hell
00:21:41 <romanix> ertes-w, are you referring to my profiling situation? ;)
00:21:58 <ertes-w> huh?  no, why?
00:23:14 <ertes-w> i just joined
00:23:22 <romanix> ah. ok. sorry
00:23:45 <romanix> i'll reiterate (sorry for spamming)
00:23:52 <cocreature> romanix: I don’t think there is really anything you can do to reduce memory usage of GHC
00:24:00 <romanix> <romanix> do you guys know how to reduce ghc's memory requirements when compiling with profiling enabled? i'm unable to compile my app with profiling due to ghc starting to swap during compilation
00:24:00 <romanix> <romanix> ghc starts to swap when compiling my app, not itself :)
00:24:00 <romanix> <romanix> i dread the prospect of ripping out my dependencies to track which library(ies) are causing this so was hoping there was an easier way :)
00:24:14 <cocreature> well at least nothing without rewriting your code
00:24:41 <romanix> cocreature, I tried various flags to turn off automatic cost centre generation but to no avail
00:25:16 <tdammers> actually, there are some edge cases in GHC that cause it to allocate unreasonable amounts of memory sometimes
00:25:59 <romanix> I've read somewhere that GHC can go crazy with libraries that use a lot of inlining
00:26:20 <tdammers> it's more subtle than that, and we don't even know exactly why it happens
00:26:48 <tdammers> for example, the test suite for the vector package consumes way more memory than it should
00:32:18 <ertes-w> romanix: honestly i would just throw more RAM at it
00:32:37 <geekosaur> not always possible
00:33:12 <romanix> ertes-w, well, I can't put more than 8gb in my laptop
00:33:49 <romanix> and to be honest my app is quite simple at this point
00:34:34 <romanix> so the fact that 8gb is not enough to compile it now is somewhat troubling
00:36:43 <cocreature> more than 8gb sounds like a bug tbh
00:42:15 <romanix> exactly. here are my build-depends: http://lpaste.net/360162. do you guys see any obvious suspects?
00:42:36 <LiaoTao> +1 for the extreme memory requirements
00:42:43 <LiaoTao> Stack and store cripple my laptop
00:45:06 <saurabhnanda> geekosaur: that conditional with cabal seems to have worked. Thanks.
00:46:37 <ertes-w> romanix: yeah, that's quite a lot, but it's not unheard of either; GHC is a memory hog…  however, if the example is really that small, perhaps it could serve as a nice reproducible test case in a bug report
00:47:11 <tdammers> ertes-w: problem is probably not the code itself, but one of the dependencies
00:47:41 <tdammers> that said, a small example *without* any dependencies that reproduces the problem would be very welcome
00:47:58 <marvin2> does it matter how the example is when it has 46 dependencies? but still surprising that 8GB isn't enough to compile it
00:48:06 <marvin2> how small*
00:48:45 <ertes-w> tdammers: i don't know how profiling is implemented, but can an already compiled dependency really have such an impact?
00:49:33 <tdammers> ertes-w: if you enable profiling, you will typically recompile dependencies as well
00:50:30 <romanix> I don't know if it matters but ghc departs when compiling my app (last step). it compiles libraries just fine
00:51:42 <romanix> at least that is what stack reports
00:54:15 <romanix> but I guess assembling the final binary is when all the inlining happens etc
00:55:06 <tdammers> linking?
01:00:02 <tdammers> https://ghc.haskell.org/trac/ghc/ticket/13535 <- btw, this is one of the issues we currently have wrt excessive memory usage in GHC
01:04:20 <romanix> thanks, will have a look. vector is one of my transitive deps but i'm guessing its tests are not normally compiled?
01:06:59 <tdammers> no, normally they shouldn't
01:22:22 <simon> hi. trying to compile xmonad with stack and I get these errors that say "recompile with -fPIC". I forgot what the solution was; should I use stack from git instead of from ubuntu/debian's repo?
01:22:56 <simon> (I realize this isn't #xmonad, but this problem relates to the network/memory/clock packages, I think.
01:41:48 <man2323> hi
01:42:08 <liste> hi man2323 
01:43:26 <man2323> do you know a free server where i can use my own proxy server? i just want to bypass some filters of my isp
01:51:23 <quchen> This isn’t the right channel for that.
03:31:58 <d-fish> cryptonite-0.24 wont install with stack. I added it to my extra-deps, lts-9.14
03:32:22 <liste> d-fish: how does it fail?
03:32:35 <d-fish> running stack ghci shows: 
03:32:37 <d-fish> cryptonite-0.24: configure
03:32:39 <d-fish> cryptonite-0.24: build
03:32:40 <d-fish> Progress: 0/11
03:32:59 <d-fish> Nothing happens until ^C
03:33:39 <d-fish> Nevermind, it just took a suuuuuuuper long time for x509 to build
03:33:53 <mniip> ugh
03:33:59 <mniip> how is |- typeset again
03:36:04 <quchen> mniip: Teach a man how to fish… http://detexify.kirelabs.org/
03:36:04 <quchen> :-)
03:36:23 <quchen> Bonus, the backend is written in Haskell
03:38:59 <mniip> hmm, is it okay to typeset entailment with \frac
03:44:04 <quchen> What do you mean?
03:44:19 <quchen> \frac{}{}\!\!\!\emdash?
03:44:23 <quchen> That’s blasphemy.
03:44:38 <quchen> It’s okay to typeset entailment with \vdash.
03:45:42 <mniip> why the emdash
03:46:00 <quchen> Oh. Because I thought »fractions, yes that’s the vertical bar« in my head.
03:46:16 <quchen> Correct up to isomorphism ;-)
04:01:44 <lamba_> hi! has anyone here dealt with the ad library?
04:02:11 <lamba_> ad and linear actually
04:03:37 <lamba_> because I want to do something like grad (\[V2 z w,V2 x y] -> x*z*y*w) [(V2 0 0),(V2 1 1)] so I am asking if I have to convert the V2s into lists concatenate them and then chunk the list again to get the grads
04:03:44 <lamba_> or can i do something better?
04:24:47 <luiduihui> https://leetcode.com/problems/add-two-numbers/description/  can some one solve me this in haskell and post the code
04:31:30 <WinterFox[m]> Is every function with `do` impure and every function without it pure?
04:31:35 <mniip> no
04:31:37 <hpc> > do ()
04:31:39 <lambdabot>  ()
04:31:47 <hpc> > do False
04:31:48 <hpc> ;)
04:31:49 <lambdabot>  False
04:31:58 <mniip> > do x <- []; return ()
04:31:59 <WinterFox[m]> Is there any way to work out which functions are pure?
04:32:00 <lambdabot>  []
04:32:05 <mniip> WinterFox[m], all of them
04:32:12 <hpc> WinterFox[m]: if you've ever used list comprehensions, those translate to do-notation as well
04:32:19 <hpc> and yeah, they're all pure
04:32:22 <mniip> it's just that some of the things you might think of as functions aren't really
04:32:23 <hpc> even the IO stuff
04:32:28 <WinterFox[m]> How?
04:32:31 <hpc> in fact, that's the whole idea behind the IO type
04:32:47 <demiurge> WinterFox[m]: functions that "perform IO" really just return a value that contains instructions about the IO to perform
04:32:55 <mniip> WinterFox[m], putStrLn is a pure function
04:33:02 <liste> WinterFox[m]: more interesting would be ask if a function type is of form "Monad m => m a" or "a"
04:33:14 <mniip> putStrLn "foo"  always *returns* the same value - an IO action that ouputs 'foo'
04:33:41 <liste> IO a values are values like any other
04:33:50 <liste> :t [putStrLn "foo", putStrLn "bar"]
04:33:52 <lambdabot> [IO ()]
04:34:21 <WinterFox[m]> What about a function that returns a random number?
04:34:29 <liste> WinterFox[m]: there is no such function
04:34:34 <mniip> no such function
04:34:38 <hpc> :t randomIO
04:34:39 <lambdabot> Random a => IO a
04:34:45 <WinterFox[m]> Is there another name for it?
04:34:53 <hpc> that uses a globally mutable rng seed
04:34:54 <liste> that's an action, when executed, returns a random number
04:35:01 <liste> but it's not a function at all
04:35:28 <tdammers> WinterFox[m]: the name for such a thing would be "IO action" or just "IO value"
04:35:36 <WinterFox[m]> Ah
04:35:46 <hpc> although usually you will use mkStdGen or similar to seed an RNG
04:38:08 <d-fish> luiduihui: Here's one solution: https://pastebin.com/RtGNA82W
04:43:00 <lamba_> lamba
04:43:13 <lamba_> woops by mistake
05:12:13 <quchen> WinterFox[m]: You can view »IO a« as a recipe or subroutine that computes an »a«, and may perform side effects (read from stdin, write to network).
05:12:25 <quchen> WinterFox[m]: Anything without IO in its type cannot do any of these.
05:12:48 <quchen> A computation built from things of IO types should not be seen as a program, but more of a program description.
05:13:12 <quchen> Haskell programs are, at the top level, IO actions. Running a Haskell program means evaluating the »main« value, which runs the recipe.
05:13:22 <hpc> *executing
05:13:46 <quchen> From within the code, IO actions are not special at all – that’s why some say »IO is pure«. From a running-the-program perspective, IO is the thing that allows impure things to happen.
05:14:10 <quchen> hpc: it’s eval/apply, not execute/apply ;-P
05:14:47 <hpc> evaluating an IO action doesn't perform the action though, all it does is... evaluate it
05:14:56 <hpc> execution is what makes it do things
05:15:11 <hpc> evaluation is the thing lambdabot is doing
05:15:36 <hpc> (this distinction is a necessary consequence of IO being pure)
05:16:20 <hpc> it's something that will come up later for WinterFox[m] so might as well make the distinction up front
05:17:15 <quchen> Alright alright. But then I would have had to explain what the difference beween performing an IO action and evaluation an IO value was.
06:28:21 <supercynic> > putStrLn "bello!" `seq` ()
06:28:23 <lambdabot>  ()
06:30:14 <supercynic> would be pretty bad if evaluation and execution were the same thing =)
06:30:27 <supercynic> that's why all mainstream languages other than haskell are bad =)
06:58:58 <clinton> @djinn (a -> b -> t -> t) -> a -> b -> f t -> f t
06:58:58 <lambdabot> f _ _ _ a = a
07:00:01 <clinton> @djinn Functor f => (a -> b -> t -> t) -> a -> b -> f t -> f t
07:00:01 <lambdabot> Error: Class not found: Functor
07:00:12 <clinton> @djinn Prelude.Functor f => (a -> b -> t -> t) -> a -> b -> f t -> f t
07:00:12 <lambdabot> Error: Class not found: Prelude.Functor
07:00:17 <pierrot> Good morning. Why does `2 , 2' fail if (,) has type `(,) :: a -> b -> (a, b)'? (The parentheses around `,' doesn't mean that it can be used in prefix form?)
07:01:55 <supercynic> pierrot: (,) is a singularity
07:01:59 <cocreature> pierrot: tuples are builtin syntax so they don’t work like user-defined operators
07:02:01 <supercynic> you need the parentheses
07:03:20 <quchen> Let’s not insult every other language out there because of the way they model I/O, shall we
07:03:58 <quchen> …or I put on my Idris hat and say bad things about Haskell’s I/O ;-)
07:04:49 <hexagoxel> :exf "Functor f => (a -> b -> t -> t) -> a -> b -> f t -> f t"
07:04:49 <exferenceBot> \ f1 b -> fmap . f1 b
07:04:54 <pierrot> supercynic and cocreature : thanks. although I must admit expressions like `2 , 2' look ugly, they're consistent with user-defined operators
07:04:55 <hexagoxel> clinton: ^
07:06:34 <quchen> pierrot: Well, you can define your own tuple-building operator if you really want. Sometimes that makes for nice syntax, for example »(~>) = (,)« allows things like »M.fromList [1 ~> "hello", 2 ~> "world"]
07:06:35 <quchen> «
07:07:36 <supercynic> pierrot: yes, i find it unfortunate that (,) is special
07:07:49 <supercynic> pierrot: you also need an extension to get tuple sections:  TupleSections
07:08:05 <supercynic> > map (, 5) [1,2,3]  -- like this
07:08:07 <lambdabot>  [(1,5),(2,5),(3,5)]
07:08:16 <quchen> If comma was an operator, parsing things like [1,2,3,4] would be impossible, so it’s the price we have to pay
07:08:31 <supercynic> i think the mistake is that [] uses commas in the first place
07:08:49 <supercynic> [1;2;3]  -- semicolons are already special…  might as well use them here
07:10:15 <pierrot> supercynic: Thanks. I've never used tuple sections..
07:10:22 <supercynic> if (,) were a regular infixr operator, we could also use nested tuples instead of those ad-hoc tuple types
07:11:33 <supercynic> @let (,,) = (,); infixr ,, 5
07:11:33 <lambdabot>  Parse failed: Parse error: ,
07:12:05 <supercynic> @let (.:) = (,); infixr .: 5
07:12:05 <lambdabot>  Parse failed: Parse error: 5
07:12:11 <supercynic> @let (,,) = (,); infixr 5 ,,
07:12:12 <lambdabot>  Parse failed: Parse error: ,
07:12:13 <quchen> That reminds me of the best comment I’ve heard all year, at ZuriHac. »Other languages have problems like everything is nullable and the type system is crap, and in Haskell we have problems like ›but we NEED inductive tuples‹.«
07:12:17 <supercynic> oh, come on
07:12:22 <supercynic> @let (.:) = (,); infixr 5 .:
07:12:24 <lambdabot>  Defined.
07:12:29 <supercynic> > 1 .: 2 .: 3
07:12:31 <lambdabot>  (1,(2,3))
07:12:38 <pierrot> quchen: looool
07:13:15 <supercynic> yeah, we're complaining on a very high level =)
07:13:55 <quchen> To be fair, Haskell also has silly problems.
07:14:30 <tdammers> unary minus
07:14:42 <quchen> Yeah, that’s totally ruining everything, for example nothing at all.
07:14:52 <tdammers> record fields not automatically being lenses
07:15:03 <tdammers> instance Num Double
07:15:09 <supercynic> that would be quite nice
07:15:09 <tdammers> class Num, in general
07:15:12 <quchen> I like Edwin’s view on lenses: make records not suck, in a way that lenses become unnecessary.
07:15:28 <supercynic> just make field accessors lenses
07:15:46 <quchen> String = [Char]
07:16:08 <tdammers> "records that don't suck" would beat lenses fair and square
07:16:31 <quchen> I’ve heard great things about Purescript’s open records, but I’ve never used them. Justin Woo is a good salesperson.
07:16:45 <quchen> Plus he’s on every Haskell conference so it’s hard to miss the preaching :-D
07:16:53 <tdammers> I've used purescript's records in practice, and they turn out to be worse than Haskell records
07:17:01 <quchen> Eww!
07:17:24 <tdammers> can't even tell exactly where the disappointment stems from, but somehow, they got me in stupid situations a lot more often than Haskell does
07:17:47 <quchen> In Haskell I rarely have problems with records, because they’re so limiting I almost never use them. :-C
07:18:25 <tdammers> Haskell's record problems are actually pretty superficial, little more than a syntactic nuisance
07:18:39 <quchen> I should learn more about row types, because at the moment they sound too good to be true, which usually nothing is.
07:18:49 <tdammers> worst case you $(makeLenses) and carry on about your day
07:19:07 <madjestic> hey guys.  Does anybody have experience with haskell-eigen?  The Readme sais that "It supports various matrix decompositions and geometry features" (such as space transformations, afaiu), but I don't understand how to access something like AngleAxis(angle,axis); in haskell.
07:19:14 <quchen> tdammers: Haskell the language is fine. But the infamous IDE situation, ugh
07:19:20 <pierrot> quchen: Was that quote exactly as you wrote it here or you adapted it to this particular conversation in which we were talking about making (,) a regular infixr operator opens doors to inductive tuples?
07:19:52 <tdammers> quchen: in all fairness, purescript's IDE situation is just as ghastly AFAIK
07:20:07 <quchen> pierrot: It wasn’t a literal quote (taken out of a conversation during having pizza), but the Haskell problem in it was specifically »oh noes we don’t have inductive tuples«.
07:20:48 <pierrot> heh
07:20:50 <quchen> tdammers: I mean I can edit atrocities like PHP well using an IDE!
07:21:18 <tdammers> I can edit Haskell well without an IDE
07:21:31 <tdammers> but, yes, PHP sadly enough has better IDE support than Haskell
07:21:53 <tdammers> then again, the average PHP codebase also needs it a lot more direly
07:21:55 <quchen> I have a great setup put together over a long period of time, and an unconfigured IntelliJ wipes the floor with it any day
07:30:58 <supercynic> tdammers: i disagree about records that don't suck beating lenses…  i'd rather say these issues are orthogonal
07:31:22 <supercynic> for example a killer combination would be row types + lenses
07:32:17 <supercynic> + useful disambiguation
07:32:43 <tdammers> record update syntax annoys me more than not having row types
07:34:10 <supercynic> quchen: row types are basically what vinyl does
07:34:28 <joelburget> Does anybody here know Djinn well? I'm running into some issues described here: https://gist.github.com/joelburget/d28279799c856c577dfa7d3ed2010db3
07:35:02 <joelburget> Basically I want to implement some functions but without pattern-matching on constructors
07:35:29 <joelburget> I tried using "uninterpreted" types to do that but they don't seem to be the right tool
07:38:12 <orion> Anyone familiar with Backpack: Why does line 15 of this cabal file cause the build to fail?: https://gist.github.com/centromere/c26373133bba2b03e80863503f60d353
07:45:27 <dminuoso> I keep people using ~> in types in some places. What does this mean?
07:45:32 <dminuoso> *I keep seeing
07:46:41 <bts-> dminuoso: it depends on which libraries people are using, but ~> commonly means natural transformation
07:48:02 <bts-> dminuoso: i.e.: type f ~> g = forall x. f x -> g x
07:48:42 <quchen> ~> also looks deceptively like -> in many fonts, so we like to abuse it to »redefine« the function arrow.
07:50:15 <infandum> I have a list of intervals [5-100,260-320, ...] and another list of intervals. What's the fastest way of finding the intersecting intervals?
07:50:42 <hexagoxel> joelburget: djinn does not handle polymorphic functions. It reads your environment as if there are no implicit foralls in the signatures, pretty much.
07:50:45 <infandum> I was thinking either making a giant vector of zeros and ones and checking each interval to see if they have a one.
07:50:47 <dminuoso> bts-: Mmm. I see.
07:51:03 <infandum> Another way would be a set of numbers to see if they intersect.
07:51:16 <quchen> infandum: For each interval, subtract all the other intervals, then filter for non-empty ones.
07:51:20 <infandum> Unfortunately both ways involve expanding the sparse format into a dense format
07:51:34 <quchen> Quadratic, but fast as long as you don’t run the code (or your lists are small).
07:51:43 <infandum> Lists are HUGE
07:51:53 <quchen> Nevermind then :-þ
07:51:58 <joelburget> @hexagoxel: so there's no way to add the quantifiers I need?
07:51:58 <lambdabot> Unknown command, try @list
07:52:04 <infandum> The other option is to use a pre-existing program that can do it, like bedtools
07:52:07 <infandum> intersect
07:52:45 <dminuoso> bts-: So this is just mathism happening? Everybody having their own brilliant form of notation?
07:53:22 <hexagoxel> joelburget: no. but `exference` supports this.
07:53:57 <hexagoxel> unfortunately i never taught exferenceBot to accept changes to the environment, so you'd have to test it locally..
07:54:05 <joelburget> I'll try exference
07:54:08 <joelburget> thank you
07:54:17 <hexagoxel> joelburget: you have any more interesting queries?
07:54:48 <joelburget> No -- I didn't get to more interesting stuff yet, since I couldn't get basics to work
07:55:07 <hexagoxel> joelburget: also, one of your bindings is named `case` which will be a syntax error.
07:56:29 <hexagoxel> joelburget: feel free to ping me if you have problems using the custom environment with exference.
07:57:04 <joelburget> hexagoxel: thank you -- I will
07:59:35 <infandum> quchen: What are the chances! https://hackage.haskell.org/package/IntervalMap-0.5.3.1/docs/Data-IntervalMap-Strict.html
07:59:39 <infandum> I'll check it out
08:03:04 <bts-> dminuoso: it's pretty standard notation, and comes in handy when you're working with a lot of mappings between functors. the concision aids in focusing on functors rather than types
08:05:17 <dminuoso> bts-: So just like -> is an instance of Arrow in Hask, ~> would be an instance of Arrow in Functor?
08:40:27 <orion> Anyone know the answer to this?: https://www.reddit.com/r/haskell/comments/7ea0qg/backpack_why_does_this_cabal_file_fail_to_build/
08:41:21 <supercynic> dminuoso: Category, not Arrow
08:42:58 <cocreature> naming a typeclass Arrow when the rest of the language borrows quite a bit from category where “arrow” already has a meaning was quite silly
08:43:12 <cocreature> I guess maybe the CT influence wasn’t that strong at the time
08:43:42 <dminuoso> Okay let me wrap my head around this, no hints. :P
08:47:36 <ertes-w> we have quite a few stupid names in base
08:47:54 <ertes-w> for example Functor should really be called EndofunctorOnHaskButBewareThatHaskIsKindOfALie
08:48:11 <quicksilver> well Arrow is named after the arrow concept in category theory
08:48:30 <ertes-w> that would also make it more appealing to programmers used to the windows API
08:48:36 <ertes-w> MsgWaitForMultipleObjectsEx
08:48:38 <quicksilver> so it's not like it's a coincidence
08:48:47 <cocreature> quicksilver: really? that’s a pretty weird definition of category theory arrows
08:49:02 <dminuoso> Wow I cant even. What is this Arrow?
08:51:34 <quicksilver> cocreature: have you seen the paper?
08:52:07 <cocreature> quicksilver: I know there exists a paper but I’ve never bothered to read it :/
08:53:00 <quicksilver> ok
08:53:11 <quicksilver> well if you do, it will outline the connection to category theory ;)
08:53:16 <cocreature> heh fair enough :)
08:53:21 <quicksilver> I don't find Arrow a terribly useful class in practice
08:53:34 <quicksilver> I would rather have things which are less than functions not things that are more than functions
08:53:36 <cocreature> yeah me neither, that’s why I’ve never bothered reading the paper :)
08:53:43 <quicksilver> but there is a categorical connection and hence the name.
08:54:15 <quicksilver> and by "I would rather" what I actually mean is "n my experience, I have come across more examples where it would be useful"
08:56:45 <dminuoso> ertes-w: Okay the instance of Category for (->) makes sense. id and composition just implies that I can compose functions.
08:57:44 <dminuoso> In fact the class Arrow requires the same constraint. Shouldn't Functor strictly speaking an instance for both Arrow and Category?
08:58:23 <dminuoso> I mean (endo)functors are arrows between categories. And due to natural transformations, you can make a category out of them.
08:58:25 <eacameron> Is there a lens that acts like `fromMaybe`?
08:58:43 <eacameron> like `^? _Left . defaultTo ""` ?
08:59:11 <dminuoso> I mean, in the category of categories, arrows are (well they can be if the category wants them to be) functors
09:00:07 <eschnett> the regular haskell Functor is an endofunctor, i.e. it maps back into the same category (Hask). that makes is less generic than it should be to be an instance of Category.
09:01:06 <dminuoso> eschnett: You can constrain that category of categories to not have arrows between different objects. The remaining arrows are endofunctors and identity functors.
09:01:19 <dminuoso> It's just a different category, but one all-the-same
09:03:53 <alsoStevenXL> .usd
09:05:05 <eschnett> let’s say you have two categories, Hask and Hask’. Functor then acts within Hask, or within Hask’. Functor is then an arrow in a category where Hask and Hask’ are object — let’s call it MetaHask. you need to define MetaHask to make Functor an instance of it.
09:05:53 <eschnett> i don’t think that the current Category can capture MetaHask. (but maybe i’m wrong about this.)
09:10:43 <benzrf> :k Category
09:10:44 <lambdabot> (k -> k -> *) -> Constraint
09:12:21 <benzrf> @let class (Category j, Category k) => Functor' j k where fmap' :: j a b -> k a b
09:12:23 <lambdabot>  Defined.
09:12:44 <benzrf> hmm
09:13:09 <benzrf> @unlet
09:13:09 <lambdabot>  Define what?
09:13:16 <benzrf> @undef Functor'
09:13:16 <lambdabot> There's currently no way to undefine just one thing.  Say @undefine (with no extra words) to undefine everything.
09:13:19 <benzrf> @undefine
09:13:19 <lambdabot> Undefined.
09:14:38 <benzrf> @let data Functor' j k where Functor' :: (Category j, Category k) => (forall a b. j a b -> k a b) -> Functor' j k
09:14:39 <lambdabot>  Defined.
09:15:43 <benzrf> @let idFunctor :: Category k => Functor' k k; idFunctor = Functor' id
09:15:44 <lambdabot>  Defined.
09:16:41 <benzrf> @let functorCompose :: (Category j, Category k, Category l) => Functor' k l -> Functor' j k -> Functor' j l; functorCompose (Functor' f) (Functor' g) = Functor' (f . g)
09:16:42 <lambdabot>  Defined.
09:17:02 <benzrf> @let instance Category Functor' where id = idFunctor; (.) = functorCompose
09:17:03 <lambdabot>  .L.hs:172:14: error:
09:17:03 <lambdabot>      • No instance for (Category a) arising from a use of ‘idFunctor’
09:17:03 <lambdabot>        Possible fix:
09:17:07 <benzrf> o.O
09:17:11 <benzrf> oh fuck
09:17:24 <benzrf> well hold on i didnt even need category instances what was i thinking
09:20:28 <benzrf> @letlpaste 360166
09:20:29 <lambdabot>  Defined.
09:21:12 <benzrf> theres your Cat
09:21:27 <benzrf> :k Functor'
09:21:28 <lambdabot> (k1 -> k2 -> *) -> (k1 -> k2 -> *) -> *
09:21:42 <benzrf> oh, wait... shit, that doesnt quite work does it
09:21:50 <benzrf> because they have to have the same object kinds
09:21:52 <benzrf> welp fuck
09:21:58 <benzrf> bbl
09:33:08 <ralu> :k Applicative
09:33:09 <lambdabot> (* -> *) -> Constraint
09:40:33 <dminuoso> What exactly does (k1 -> k2 -> *) denote? What's with that asterisk?
09:40:50 <dminuoso> I mean Ive seen this in kinds.
09:49:23 <opqdonut> dminuoso: * is the kind of "normal" types
09:50:02 <opqdonut> :k Int
09:50:04 <lambdabot> *
09:50:08 <opqdonut> :k [Maybe Bool]
09:50:10 <lambdabot> *
09:51:10 <dminuoso> opqdonut: Is * equivalent to forall a. in this context?
09:51:16 <opqdonut> yeah
09:51:21 <opqdonut> or well, kinda
09:52:00 <opqdonut> the original definition was `data Functor' j k where Functor' :: (Category j, Category k) => (forall a b. j a b -> k a b) -> Functor' j k`
09:52:19 <opqdonut> the kind is Functor' :: (k1 -> k2 -> *) -> (k1 -> k2 -> *) -> *
09:52:51 <opqdonut> j :: k1 -> k2 -> * because it is applied to two (type) arguments (whose kinds we don't know, thus the k1 and k2 variables)
09:53:05 <opqdonut> k is applied to the same arguments, so it must have the same kind
09:53:29 <opqdonut> the return kind of j and k must be * because (->) can only be applied to kind *
09:56:28 <mniip> shouldn't it be (k -> k -> *)
09:56:41 <mniip> the kind of Category constraint would require that I would think
09:57:08 <opqdonut> hmm
09:57:11 <mniip> as you would want to have some sort of 'id : c a a' method in the 'Category c' class
09:58:08 <mniip> !
09:58:11 <opqdonut> ah, the definition was amended to drop the Category constraint
09:58:30 <mniip> I now know a proper name for this type of definition of Category
09:58:46 <mniip> a category defined by hom-sets, or hom-types in this case
10:09:57 <dminuoso> opqdonut: Not fitting into my head. Think Ill just ignore this, and write it off as "looks complicated, it'll probably make sense if I learn more haskell"
10:10:13 <dminuoso> Thank you for trying to explain though.
10:36:22 <the_2nd> I want to use a simply config file. Should I use .yaml or what do you guys suggest?
10:36:40 <the_2nd> I basically just need key - value pairs
10:38:34 <sternmull> i would pick something INI-like. Yaml is complex (not only for the developer but also for the user) and if there is no reason for that complexity then don't do it.
10:42:39 <humanoyd> the_2nd: https://hackage.haskell.org/package/configurator
10:44:08 <orion> http://hackage.haskell.org/package/dhall
10:48:22 <Fuuzetsu> I'd recommend against configurator if you have users. It's a Haskell-only thing with fairly limited structure. JSON or YAML are probably better. I can't comment much about dhall but AFAIU my coworkers try to like it but fail every time for various reasons. Configurator _does_ do a few nice things though so if you need those, it might be worth a shot.
11:11:55 <mniip> hmm
11:12:12 <mniip> do subcategories of monomorhpisms and epimorphisms have specific names and/or uses
11:12:51 <mniip> that is, for any category C another category where objects are exactly the objects of C, and morphisms are all monomorphisms of C
11:22:26 <the_2nd> In which module is "<<" defined?
11:23:04 <cocreature> the_2nd: http://hoogle.haskell.org/?hoogle=(%3C%3C)
11:27:06 <mniip> % :info (<<)
11:27:07 <yahb> mniip: ; <interactive>:1:1: error: Not in scope: `<<'
11:27:13 <mniip> oh er
11:32:25 <the_2nd> :D
11:33:26 <the_2nd> >> it is
11:42:08 <dmwit> I know what type I want (<<) to have. But what behavior do I want it to have?
11:42:51 <dmwit> a << b = b >> a, or a << b = do { x <- a; b; return x }?
11:43:33 <ongy> wouldn't the type mandate that?
11:43:38 <cocreature> given that >> has the same behavior as *>, I would expect << to have the same behavior as <*
11:43:54 <opqdonut> ongy: dmwit
11:44:01 <opqdonut> 's two solutions have the same type
11:44:04 <opqdonut> but different sequencing
11:44:14 <ongy> oh right
11:44:19 <opqdonut> I think << is meant to be flip (>>)
11:44:29 <ongy> I read that wrong
11:44:38 <Tuplanolla> That sounds like a terrible idea, opqdonut.
11:44:39 <cocreature> opqdonut: so different than <*? that seems really confusing
11:44:59 <opqdonut> @src (=<<)
11:44:59 <lambdabot> f =<< x = x >>= f
11:45:18 <dmwit> I think both implementations are defensible, really.
11:45:40 <dmwit> And perhaps this is an argument for not having (<<). =)
11:45:44 <cocreature> if (<*) didn’t exist in base, I’d agree with that
11:46:03 <dmwit> cocreature: Since (<*) already does one of them, it's more useful for (<<) to do the other. ;-)
11:46:45 <dmwit> (And more uniform with `(=<<)`, as opqdonut pointed out!)
11:46:58 <ggVGc> made a crypto trader in haskell this weekend! earnt 3 euro so far!
11:47:04 <dmwit> ggVGc: grats!
11:47:06 <ggVGc> more than I ever earnt from haskell in the past
11:47:08 <HaskellLord69> nice mang
11:47:12 <ggVGc> I consider it a success
11:47:37 <dmwit> Honestly I'm more impressed by the bravery it took to connnect it to actual funds than I am by the programming achievement, haha
11:48:15 <HaskellLord69> im sure he had tests right?????
11:49:43 <ongy> who needs tests when you have types
11:49:55 <shapr> I need tests!
11:49:59 <mud> dmwit: Bravery is one name for it :)
11:50:07 <HaskellLord69> I do need WAY less tests with haskells type system
11:50:16 <HaskellLord69> and I do really appreciate that
11:50:25 <shapr> HaskellLord69: have you tried QuickCheck?
11:50:42 <shapr> My favorite flavor of tests is property based tests.
11:50:48 <HaskellLord69> yes, and It made them my favorite kind of test
11:51:38 <shapr> I keep meaning to dig into hedgehog, I've heard it's the next cool thing after QuickCheck
11:53:19 <HaskellLord69> I use the .net equiv of quickcheck and its pretty nice, although quite a bit more verbose.
11:59:32 <shapr> HaskellLord69: are you writing F#?
11:59:58 <HaskellLord69> I probably could if I knew it better, but no I use c# at work.
12:00:02 <HaskellLord69> the library is fscheck though
12:00:39 <shapr> we're writing some C# here, I've been meaning to find a QC equivalent, thanks!
12:00:49 <HaskellLord69> np
12:02:04 * dmwit . o O ( a << b = a >> b >> b >> a {- dancing queen -} )
12:03:14 <benzrf> pff
12:10:44 <HaskellLord69> originally I wanted to learn f# but then I was worried I would use OO as a crutch and wanted to learn "real FP" so I tried haskell, but then I fell in love with it and kind of left f# alone for a long time
12:10:56 <HaskellLord69> unlikely that I will get to use haskell at work, so f# is probably the next best thing
12:13:32 <Rembane> HaskellLord69: Doesn't sound too terrible.
12:14:43 <cement> I can confirm the existance of at least two companies that are nearly haskell exclusive
12:14:55 <HaskellLord69> awesome
12:15:09 <Rembane> HaskellLord69: Have you checked out F* btw? https://www.fstar-lang.org/
12:16:32 <Athas> HaskellLord69: F# is a pretty good language.  You could do much, much worse.
12:16:53 <cement> both the companies I have in mind also heavily use nix too, so that's something to probably look into
12:19:47 <cement> is there a commonly accepted way to do ByteString.isSubstring?
12:21:31 <rightfold> cement: isInfixOf
12:22:14 <cocreature> or https://hackage.haskell.org/package/bytestring-0.10.8.2/docs/Data-ByteString.html#v:breakSubstring if you need more information
12:22:24 <cement> of course I missed isInfixOf
12:22:49 <cement> I was checking the size of the second element of breakSubString
12:25:12 <dminuoso> Can someone give me a hint to understand how this type signature comes to be? 
12:25:19 <dminuoso> :t (zipWith . zipWith)
12:25:20 <lambdabot> (a -> b -> c) -> [[a]] -> [[b]] -> [[c]]
12:26:56 <M-Illandan> dminuoso: well, you want to be able to perform zip operations successively
12:26:58 <cocreature> :t (.)
12:26:59 <lambdabot> (b -> c) -> (a -> b) -> a -> c
12:27:00 <cocreature> :t zipWith
12:27:01 <lambdabot> (a -> b -> c) -> [a] -> [b] -> [c]
12:27:07 <M-Illandan> What do you think would best support it?
12:27:19 <cocreature> now try and unify the type variables
12:28:23 <cocreature> e.g. the first argument to (.) is zipWith so "(b -> c)" and "(a -> b -> c) -> [a] -> [b] -> [c]" have to be unified (don’t be confused those are different bs and cs)
12:29:08 <cocreature> so b has to unify with (a -> b -> c) and c has to unify with "[a] -> [b] -> [c]"
12:29:26 <cocreature> dminuoso: now do the same for the second argument and combine the information that you gain by doing so
12:32:56 <dminuoso> cocreature: What does unification mean in this context? monomorphisizing say (b -> c) into some t?
12:35:08 <cocreature> dminuoso: I guess if you want to be colloquial you could call it “making two types the same”. so you know (x -> y) and (a -> b -> c) -> [a] -> [b] -> [c] (I’ve renamed the variables to make things less confusing) need to be “equal”. by trying to make them equal you can derive constraints on those type variables
12:35:32 <cocreature> for this example you get "x = (a -> b -> c) and y = [a] -> [b] -> [c]"
12:37:07 <dminuoso> cocreature: Ah, so it's basically just "substitution" in some particular sense, which is fine since (a -> b -> c) itself is a proper type
12:39:02 <waut3r> holy cow this is a populated channel
12:39:43 <HaskellLord69> we love haskell
12:39:52 <dminuoso> cocreature: I guess my real question is, how is the functor suddenly composed? Because this is not obvious from staring at (.)
12:40:02 <waut3r> i've been reading through http://learnyouahaskell.com/chapters and haskell looks super super awesome
12:40:11 <dminuoso> i.e. why do I end up with [[a]] -> [[b]] -> [[c]]
12:40:12 <cocreature> dminuoso: which functor?
12:40:15 <waut3r> just for fun, i've barely touched any code for it yet outside of implementing a couple of examples
12:40:45 <cocreature> dminuoso: try working through the unification for the second argument, you’ll see why it needs to be this way :)
12:42:51 <cocreature> and make sure to rename things, e.g. use "(y -> z) -> (x -> y) -> x -> z" for the type of (.) and "(a1 -> b1 -> c1) -> [a1] -> [b1] -> [c1]" for the first zipWith and "(a2 -> b2 -> c2) -> [a2] -> [b2] -> [c2]" for the second zipWith
12:45:00 <dminuoso> cocreature: Ohhh. It's so crystal clear. This is amazing.
12:45:18 <cocreature> dminuoso: if you’re more interested in how it works rather than how you get that type, try just unfolding the definition of (.) and apply it to some arguments: (zipWith . zipWith) f xs ys = (\x -> zipWith (zipWith x)) f xs ys = zipWith (zipWith f) xs ys"
12:45:41 <orion> Let's say I have a set of Backpack-enabled haskell packages which provide a unified interface for strings (String, Text, ByteString, etc). Is it possible to choose a particular implementation at runtime in the Backpack paradigm?
12:45:57 <orion> Or must the decision (of which implementation to use) be made at compile time?
12:49:19 <dminuoso> cocreature: https://gist.github.com/dminuoso/7c9ddeb839308234025c84e42af31a18
12:49:28 <dminuoso> This should be correct, right?
12:50:18 <dminuoso> (Writing the list type as `[] a` made this eaiser to see)
12:50:34 <cocreature> dminuoso: looks correct!
13:00:29 <mniip> '[] [] a' is ill-kinded
13:01:22 <dminuoso> mniip: Mmm. Should have been [] ([] a) rather?
13:01:29 <wz1000> when would you use class C a where f :: t; default f :: (Generic a) => t vs  f :: Generic a => t
13:01:37 <dminuoso> mniip: Or what am I missing?
13:03:47 <mniip> dminuoso, yes
13:04:29 <mniip> wz1000, when you want to be able to define C in terms of non-default type
13:05:34 <dminuoso> cocreature: This is pretty cool. https://gist.github.com/dminuoso/7c9ddeb839308234025c84e42af31a18
13:05:45 <dminuoso> cocreature: (I burrowed the beta reduction syntax from lambda calculus)
13:06:25 <dminuoso> Why is this so strangely satisfying.
13:06:42 <cocreature> I’m glad you’re having fun :)
13:07:08 <dminuoso> Im glad this channel is such an incredibly helpful place.
13:09:08 <mniip> sounds like you could be able to implement HM(X) in code
13:10:21 <mniip> or, well, HM(\varnothing) I guess
13:10:33 <mniip> is that what haskell98 is?
13:10:55 <monochrom> What is \varnothing?
13:11:10 <mniip> empty set
13:11:30 <mniip> as in our constrain system has no additional constraints besides those introduced by HM
13:11:34 <monochrom> You could say ∅ directly, you know...
13:12:00 <mniip> well sorry mr apl keyboard
13:13:41 <monochrom> No, it's just the collective economic argument of "one person, the writer, takes a bit more effort so that many people, the readers, have it easy".
13:14:03 <danielsmw> if you're in emacs/erc, you can also just set-input-method to TeX: ⟨∑ⱼ x² - 3⟩
13:14:16 <danielsmw> no apl keyboard needed :p
13:14:38 <monochrom> http://www.vex.net/~trebla/symbols/refute-anti-unicode.html
13:14:56 <mniip> No instance of Emacs
13:15:14 <mniip> arising from the use of 'no apl keyboard needed'
13:15:38 <mniip> on <interactive>:1511212433
13:15:44 <danielsmw> lol
13:16:28 <mniip> Suggested fix: add constraint to the type of the binding
13:18:12 <mniip> monochrom, "It does not scale to longer formulas"
13:18:19 <mniip> your proposed solution doesn't
13:36:46 <dmwit> monochrom: You need some javascript to keep those "X years ago" claims up to date without further effort on your part.
13:38:07 <monochrom> heh
13:38:18 <John882> hello guys 
13:38:34 <modusponens> hey John882
13:38:50 <John882> How can i change the type of a string to the desired type?
13:38:53 <John882> actually
13:39:06 <shapr> I don't understand the question?
13:39:07 <John882> https://dpaste.de/b1KH
13:39:22 <John882> prettyPrinter (Prog prog) = putStr (nLine ++ printProg prog)
13:39:40 <John882> basically I have this function in the PrettyPrinter file
13:40:03 <John882> instead of running the program I've posted and copy pasting the output
13:40:33 <John882> then Running the PrettyPrinter program I've wanted to pass the output to the prettyPrinter function
13:40:38 <John882> Is there a way?
13:42:16 <monochrom> Where may I read the PrettyPrinter file?
13:42:47 <dmwit> John882: What is the type of `prettyPrinter`? What is the type of `tree` on line 43?
13:43:04 <dmwit> Perhaps you can just add the line `prettyPrinter tree` there.
13:43:09 <John882> https://dpaste.de/JmNc
13:43:10 <John882> here
13:45:38 <monochrom> I stil think I don't understand the question. In "instead of doing X, I want to do Y", what is Y?
13:46:09 <monochrom> because I think I'm just seeing "instead of doing X".
13:46:30 <monochrom> And I am not even sure I'm reading X correctly.
13:46:36 <dmwit> Actually, a better design would probably to make `run :: ... -> IO Program` or whatever and use `return tree` instead of `exitSuccess`. Then you can do whatever you want with the program after `run` is finished, including calling the pretty printer.
13:46:59 <dmwit> But also this question is very imprecise and has many important details left out, as monochrom says.
13:47:55 <John882> basically I have a bunch of files generated from a bnfc converter 
13:48:07 <John882> and wated to change my prettyprinter with the one generated
13:57:54 <fishythefish> :861
13:57:57 <fishythefish> whoops
14:12:32 <cement> I just threatened my coworker with continuous beatings until they removed accursedUnutterablePerformIO from their code
14:12:54 <cement> and then threatened them with more until they could either remove or justify unsafePerformIO
14:17:38 <johnw_> what about unsafeDupablePerformIO? :)
14:18:18 <johnw_> or runRW#
14:18:22 <dminuoso> filter (\x -> any ($x) [(==2), odd]) [1,2,3,4,5] -- is there a way to do this point-free style?
14:18:41 <dminuoso> Or let me rephrase. What is the way to do this point-free style? :-P
14:18:58 <barrucadu> @pl \x -> any ($x) [(==2), odd]
14:18:58 <lambdabot> flip any [(2 ==), odd] . flip id
14:19:12 <dminuoso> What magic is this.
14:24:14 <dminuoso> barrucadu: How can I learn more about lambdabot?
14:25:23 <barrucadu> @help
14:25:24 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
14:25:45 <barrucadu> You can also play around with the pl stuff yourself
14:25:48 <barrucadu> @hackage pointfree
14:25:48 <lambdabot> http://hackage.haskell.org/package/pointfree
14:26:53 <mniip> dminuoso, you mean flip id?
14:26:56 <mniip> pretty useful combinator
14:27:31 <mniip> if you mean in general,
14:27:44 <mniip> there's a theorem that any lambda can be rewritten in point-free form
14:28:07 <mniip> in fact there is a very explicit construction of any lambda using the S and K combinators
14:28:57 <mniip> pl does that with some simplifications
14:29:09 <mniip> things like S(SK)K = .
14:29:48 <mniip> I messed that up
14:30:11 <erisco> also check out CCCs which is another combinator vocabulary you can translate lambdas to
14:30:11 <mniip> S(KS)K
14:30:36 <erisco> (closed Cartesian categories)
14:30:41 <MarcelineVQ> closed cartesian category?
14:30:45 <MarcelineVQ> woo :>
14:30:52 <mniip> you mean &&& and ***?
14:31:06 <erisco> I've been reading that a lot lately and so spat out the abbreviation without thinking :P
14:31:31 <mniip> probably also needs the diagonal function
14:31:34 <erisco> those are two pieces
14:31:54 <mniip> what's an exhaustive set of pieces?
14:32:21 <erisco> conal has published a paper recently that, in my opinion, revolutionises what you can do with functional programs and there is even a Haskell lib you can grab
14:32:25 <dminuoso> mniip: Okay, that's really interesting. `flip id`
14:32:31 <mniip> diagonal, ***, eval?
14:32:38 <dminuoso> mniip: Immediately recognized flip id as similar to ($)
14:32:47 <dminuoso> In a non-obvious way,.
14:32:52 <mniip> dminuoso, well uh
14:32:58 <mniip> :t [id, ($)]
14:32:59 <lambdabot> [(a -> b) -> a -> b]
14:33:09 <erisco> and Haskell Curry was fascinated with combinators, so there has to be something to it ;)
14:33:13 <mniip> one is a subtype of another
14:33:39 <dminuoso> mniip: yeah it seems like ($) is just a special case for when a is a -> b
14:33:54 <mniip> that's a misleading thing to say
14:41:24 <dminuoso> mniip: Let me rephrase. So the way this seems to work out for `flip id` is that a -> a is assumed as (a -> b) -> a -> b. How does it derive that this has to be the type?
14:42:10 <erisco> :t flip
14:42:11 <lambdabot> (a -> b -> c) -> b -> a -> c
14:42:15 <erisco> :t id
14:42:16 <lambdabot> a -> a
14:42:25 <erisco> match  a -> b -> c  with  d -> d
14:45:14 <dminuoso> erisco: Oh. so it deduces that d = a, and d = (b -> c), and then it deduces that a = (b -> c), and thus arrives at (b -> c) -> (b -> c) ?
14:45:22 <erisco> yes
14:45:22 <adelbertc> is there anything like an MVar but guaranteed to be non-empty? i can wrap it myself and provide "safe" operations only but wondering if anything like that exists already
14:50:30 <barrucadu> adelbertc: IORef?  TVar?
14:51:03 <barrucadu> TVar is nice because STM transactions compose without losing atomicity.
14:53:22 <adelbertc> is IORef threadsafe?
14:54:15 <barrucadu> Depends on what you mean by that.  Updating an IORef is atomic, but two threads trying to update it concurrently is racey.
14:54:48 <adelbertc> yeah i dont want the race
14:55:08 <barrucadu> What is the behaviour you want?
14:55:54 <adelbertc> pretty much just MVar + newMVar, putMVar, readMVar
14:56:01 <adelbertc> i can limit myself to just those methods
14:56:28 <adelbertc> j/w if theres something that exists that is MVar, but if only those 3 methods were exposed (e.g. no creation of empty MVar, and no takeMVar which leaves it empty)
14:56:42 <adelbertc> put differently, to create you must provide a value, and you can overwrite, but not remove
14:57:02 <barrucadu> Ok, so what if two thread concurrently putMVar?  Wouldn't that be racey?
14:57:30 <johnw> barrucadu: one will succeed, the other will block until the next take
14:57:33 <adelbertc> i was under the impression putMVar will only allow one
14:57:39 <adelbertc> yeah
14:58:05 <adelbertc> oh hm johnw has made me realize i dont *quite* want putMVar then since it would never be empty
14:58:13 <barrucadu> That's what I was getting at
14:58:26 <barrucadu> If you only have full MVars, putMVar is a bit pointless
14:58:36 <adelbertc> right. so i want serialized put's then
14:58:37 <adelbertc> is that TVar
14:59:05 <barrucadu> Serialised puts?
14:59:15 <adelbertc> one after another
14:59:20 <barrucadu> Ok
14:59:20 <adelbertc> no races
15:00:16 <barrucadu> I think we misunderstood each other when I said that writing to an IORef is racey.  You'll not be able to observe a "half updated" state.  What I meant was simply that one thread overwrite the value that the other stored, and which thread that is is nondeterministic.
15:01:07 <barrucadu> Which I think is the behaviour you want: a shared mutable variable which is not empty, which can be read and written.
15:01:18 <barrucadu> But in general I'd use TVar over IORef because STM is quite nice
15:01:24 <koz_> Suppose I have a computation of the type 'a -> Maybe a'. I wanna execute this computation n times; if any of them return a Just, return that, otherwise, return Nothing. How would I write this?
15:01:59 <johnw> barrucadu: same for me
15:02:46 <adelbertc> barrucadu: johnw - so TVar ftw?
15:02:50 <barrucadu> (and IORef has weird semantics if you just use readIORef and writeIORef, because of relaxed memory)
15:02:53 <barrucadu> Yes
15:02:59 <johnw> use, TVar is what I always start with
15:03:08 <adelbertc> cool beans
15:03:13 <adelbertc> thanks guys!
15:03:14 <johnw> s/use/yes
15:03:47 <johnw> in fact, I've almost never needed MVars anymore; TVar, TMVar, TQueue or TBQueue nearly always fit the bill
15:04:27 <adelbertc> cool
15:04:33 <adelbertc> i really need to get around to reading Simon's book
15:04:38 <johnw> yes!
15:04:42 <johnw> a great read
15:04:54 <barrucadu> Even if you just skim through it, it's helpful
15:05:07 <adelbertc> johnw: you going to be at the Nix meetup in a couple weeks?
15:05:40 <johnw> adelbertc: what day?
15:05:56 <adelbertc> Dec 7 i think?
15:06:19 <dminuoso> Here's a question that immediately made me wonder about HM. x:σ ∈ Γ -> Γ ⊢ x: σ. Whats the point of this?
15:06:25 <dminuoso> Is seems a bit redundant.
15:07:15 <dminuoso> Or is that just to say "if the type system determines that x has some type σ, then any x must have that type σ" ?
15:07:29 <fishythefish> it's essentially a variable declaration
15:07:33 <erisco> it says if x has type σ in context then the term x has the type σ
15:07:44 <barrucadu> It looks like it lets you "pull things out" of the context Γ
15:07:58 <fishythefish> if x is declared to have type T in the context, then from then on, the context lets you assume x has type T
15:08:00 <MarcelineVQ> koz_: with the same input to the computation each time?
15:08:10 <dminuoso> fishythefish: Ahh.
15:08:36 <koz_> MarcelineVQ: No, different ones. They're all as, but they're different as.
15:08:59 <MarcelineVQ> so are they in a list or something then?
15:09:04 <koz_> MarcelineVQ: Yep.
15:09:27 <koz_> I know I can fmap to [Maybe a], but what I need to get out of that is a Maybe a (given the constraints above).
15:09:31 <johnw> adelbertc: sure, I'll plan to be there
15:09:34 <MarcelineVQ> asum and msum are function to look at then
15:09:42 <koz_> MarcelineVQ: Ah, thank you!
15:10:32 <koz_> MarcelineVQ: I think in my case asum is OK? The computations aren't sequentially-dependent.
15:12:01 <koz_> MarcelineVQ: Also, is asum lazy? Like, I'm guessing if I feed it a list of 1000 Maybe as, if the first one Justs, it won't even bother evaluating the remaining 999?
15:12:17 <koz_> (sorry, 1000 as, not 1000 Maybe as)
15:12:27 <MarcelineVQ> seems to be
15:12:32 <MarcelineVQ> > asum [Nothing, Just 3, Nothing, Just 8, Nothing, undefined]
15:12:32 <dmwit> :t \f xs -> asum (map f xs)
15:12:34 <lambdabot> Alternative f => (a1 -> f a2) -> [a1] -> f a2
15:12:34 <lambdabot>  Just 3
15:12:49 * dmwit high fives MarcelineVQ 
15:12:59 <koz_> Whoo, Haskell wins again!
15:13:47 <dmwit> koz_: Yes, asum is lazy.
15:13:56 <dmwit> > asum (Just 3:undefined)
15:13:58 <lambdabot>  Just 3
15:14:05 <koz_> dmwit: Excellent news.
15:14:20 <dmwit> :t Alt
15:14:21 <lambdabot> forall k (f :: k -> *) (a :: k). f a -> Alt f a
15:14:29 <koz_> What's Alt?
15:14:30 <dmwit> :t \f -> traverse (Alt . f)
15:14:31 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> Alt f (t b)
15:14:41 <dmwit> oops, no
15:15:12 <dmwit> :t \f -> foldMap (Alt . f)
15:15:13 <lambdabot> forall k (t :: * -> *) (f :: k -> *) (a1 :: k) a2. (Monoid (Alt f a1), Foldable t) => (a2 -> f a1) -> t a2 -> Alt f a1
15:15:57 <dmwit> :t \f -> foldMap (First . f)
15:15:58 <lambdabot> Foldable t => (a1 -> Maybe a2) -> t a1 -> First a2
15:16:01 <dmwit> yay
15:16:09 <koz_> First is what?
15:16:31 <dmwit> First converts Maybe's Alternative instance into a Monoid instance.
15:17:16 <koz_> Ah, I see. I'm guessing Maybe's Alternative instance is 'bail once you hit Nothing', while the Monoid one is 'only bail when it's all Nothing'?
15:17:30 <dmwit> instance Monoid (First a) where mempty = First Nothing; mappend (First (Just x)) _ = First (Just x); mappend Nothing x = x
15:17:45 <dmwit> Maybe's Alternative instance is "bail once you hit Just".
15:18:12 <dmwit> First's Monoid instance is also "bail once you hit Just". Maybe's Monoid instance is "mappend the values contained in Justs and throw away Nothings".
15:18:23 <koz_> Ah, OK, that makes sense.
15:20:04 <dmwit> For posterity: that should be `mappend (First Nothing) x = x`, of course.
15:20:44 <dmwit> And the spelling that matches my English description is `instance Monoid (First a) where mempty = First empty; mappend (First a) (First b) = First (a <|> b)`
15:23:12 <dmwit> Alt does that more generally for any Alternative instance. \bot just had trouble with my Alt proposal above because it has kind polymorphism turned on.
15:52:55 <orion> Under what conditions does it make sense to use type classes over Backpack?
16:03:29 <robertkennedy> > let elem' _ [] = False; elem' x (y:ys) = x == y | (x < y && elem' x ys) in fix $ \ls -> [(x,y) | x <- [1..6], y <- [1..6], not $ (y,x) `elem'` ls]
16:03:31 <lambdabot>  <hint>:1:49: error: parse error on input ‘|’
16:04:04 <robertkennedy> > let elem' _ [] = False; elem' x (y:ys) = x == y || (x < y && elem' x ys) in fix $ \ls -> [(x,y) | x <- [1..6], y <- [1..6], not $ (y,x) `elem'` ls]
16:04:06 <lambdabot>  *Exception: <<loop>>
16:04:14 <Donovan> morning people, does anyone here know much about dynamic casting with GADTs? I'm trying the example here, which compiles fine, but gives me strange results when i try a few examples: https://gist.github.com/sacundim/5386823
16:05:15 <Donovan> running `fromDynamic $ toDynamic (1::Integer)` works fine, and gives `Just 1`, but `fromDynamic $ toDnyamic ('a'::Char)` gives `Nothing`
16:06:09 <glguy> Donovan: Add a type signature to the second one
16:06:33 <seafood> Anyone here got much experience with using the “+RTS -xc” option?
16:07:18 <Axman6> heh, yeah defaulting strikes again?
16:07:33 <glguy> fromDynamic (toDynamic 'a') :: Maybe Char
16:08:21 <Donovan> thanks glguy, that works. Why do I need to do it for Char though, when Integer works just fine?
16:08:29 <seafood> I was using the +RTS -xc option and instead of _one_ stack trace, for my program I got a bunch.
16:08:48 <Axman6> that's good value!
16:10:17 <seafood> Axman6: Heh. I guess. I was expecting just one though.
16:10:38 <seafood> I think it may be because much of the code was wrapped in exception catching code.
16:11:16 <glguy> Donovan: It worked as an accident of the ExtendedDefaultRules GHCi uses by default
16:11:39 <Donovan> hmm ok
16:11:59 <Donovan> cheers though glguy, i'd been stuck on that for a while!
16:15:40 <jcarpenter2> i'm tempted to use a reader monad
16:34:15 <Fabio_> anyone here?
16:34:44 <Fabio_> hello?
16:34:58 * ddellacosta waves at Fabio_
16:35:16 <Fabio_> hi :)
16:36:03 <Fabio_> i found out about this page on a website called learnyouahaskell
16:36:14 <mmaruseacph2> welcome
16:36:14 <monochrom> seafood: Recently I found that you don't have to turn on +RTS -xc. You will still get a trace for uncaught exceptions. Just need to enable profiling during build. Best to use the -fprof-auto-calls way. See also the GHC users guide, section "Compiler options for profiling" for other choices.
16:36:22 <Fabio_> it said i can come here if i needed help on haskell
16:36:33 <Fabio_> thank you mmaru
16:36:36 <mmaruseacph2> it's a good place to ask questions, Fabio_ 
16:37:17 <Fabio_> i think i should explain who i am before asking questions if that's ok
16:39:11 <Fabio_> im a first year undergraduate student in computer science
16:39:18 <ski> Fabio_ : asking a question to start with would also be ok, but fine
16:39:37 <Fabio_> and we were basically given labs based on haskell without prior experience in programming 
16:40:38 <ski> (also, this isn't a page, this is a channel on an IRC network. you may be connected to it via a web client, but several of us aren't, as we're using stand-alone IRC clients, not a web browser, to connect to the IRC network)
16:40:55 <ski> (bur do continue with what you were saying)
16:41:03 <Fabio_> well i'm new to programming, no experience, and i need to learn haskell 
16:41:19 <ski> you might consider getting a book, then
16:41:27 <Fabio_> any recommendations?
16:41:30 <ski> especially if you're new to programming
16:41:50 <ski> you could try
16:41:51 <ski> @where HPFFP
16:41:51 <lambdabot> "Haskell Programming: from first principles - Pure functional programming without fear or frustration" by Chistopher Allen (bitemyapp),Julie Moronuki at <http://haskellbook.com/>,#haskell-beginners
16:42:14 <ski> i learned from "Haskell: The Craft of Functional Programming", by Simon Thompson
16:42:36 <Fabio_> thank you
16:42:57 <ski> there's also others, like one called "The Haskell School of Expression", by Paul Hudak, iirc
16:43:13 <ski> and some i'm forgetting at the moment
16:44:16 <Fabio_> well i'm just looking for one that treats its reader like a beginner
16:45:58 <ski> oh, i think i was thinking of "Programming in Haskell" by Graham Hutton and "Introduction to Functional Programming using Haskell" by Richard Bird
16:46:05 <ski> some more info can be found at
16:46:08 <ski> @wiki Books
16:46:08 <lambdabot> https://wiki.haskell.org/Books
16:47:09 <ski> (and "The Haskell Road to Logic, Math and Programming" by Kees Doets,Jan van Eijck is also a beginner book, i think)
16:48:05 <ski> (<http://homepages.cwi.nl/~jve/HR/> is the page for that one. for some reason that's not listed at the Books wiki page above)
16:48:46 <Fabio_> ok i'll look through the list and see if they're any recommended for beginners 
16:48:48 <Fabio_> thank you
16:49:58 <ski> Fabio_ : HPFFP is explicitly intended to be suitable for someone with no experience with programming. i don't recall to what extent the others i mentioned also succeed in doing that, but i think they at least intend to
16:50:26 <ski> HPFFP also has an IRC channel, with one of the authors of that book in the channel (they're also in this channel)
16:50:37 <Fabio_> oh ok, i've actually just downloaded it, thanks
16:52:10 <ski> which book is best for you will depend on which style of learning you prefer, and perhaps a *little* bit on your previous background knowledge in *simple* math (like solving simple equations)
16:53:57 <Fabio_> im willing to adjust once the book treats me like an absolute beginner
16:55:52 <Fabio_> well thank you so much for your help
16:55:58 <Fabio_> time to start reading 
16:56:01 <Fabio_> bye
17:35:00 <Guest50436> Hi!
17:35:09 <Guest50436> Can anyone help me with getting Atom set up with Haskell?
17:35:20 <Guest50436> I'm having some trouble :(
17:37:37 <infinisil> lol, just wanted to tell him to just ask
19:16:02 <pierrot> Hi
19:16:19 <pierrot> Can someone explain me the line `return $ maybe (error "undefined variable") id (M.lookup x env)' here: https://donsbot.wordpress.com/2006/12/11/quick-interpreters-with-the-reader-monad/ ?
19:16:42 <Welkin> :t return
19:16:43 <lambdabot> Monad m => a -> m a
19:16:46 <Welkin> :t maybe
19:16:47 <lambdabot> b -> (a -> b) -> Maybe a -> b
19:16:50 <Welkin> :t id
19:16:51 <lambdabot> a -> a
19:16:53 <Welkin> :t error
19:16:54 <lambdabot> [Char] -> a
19:16:55 <Welkin> there you go
19:19:47 <Welkin> you can write it with a case expression instead ofu sing `maybe` which is easier to read and understand, but more verbose
19:20:12 <Welkin> I prefer using case expressions except for very simple situations
19:20:26 <Welkin> :t fromMaybe
19:20:28 <lambdabot> a -> Maybe a -> a
19:20:46 <Welkin> that is better than using `maybe something id`
19:22:32 <pierrot> Welkin: Thanks
20:01:46 <waut3r> I want to create a YAML configuration file for my application - if I run stack exec <projectname>, what will be the working directory of my application?
20:03:00 <waut3r> that is, if I do stack exec <projectname> and try to run BS.readFile "config.yml", where does it expect config.yml to be?
20:10:18 <raynold> ahh it's a wonderful day
20:11:24 <Welkin> raynold: why is that?
20:20:17 <infinisil> waut3r: https://hackage.haskell.org/package/directory-1.2.6.3/docs/System-Directory.html#v:getCurrentDirectory
20:47:43 <gourav> Hello
20:47:55 <gourav> Anyone?
20:48:13 <lambdabot> Hi.
20:48:20 <infinisil> gourav: Hi.
20:48:22 <Welkin> is there anybody in there?
20:48:26 <infinisil> Welkin: Hi.
20:48:28 <gourav> Where r u from
20:48:36 <Welkin> just nod if you can hear me
20:48:43 <gourav> Yeah
20:48:45 <infinisil> I'm from port 5000 of my server
20:50:01 <gourav> Want some
20:50:06 <gourav> Advice
20:50:26 <glguy> gourav: This isn't a general chat channel; it's for discussing the Haskell programming language
20:50:54 <gourav> Wait
20:51:15 <Welkin> you can only communicate using pink floyd lyrics!
20:51:27 <gourav> I haven't heard about that
20:51:30 <infinisil> gourav: if you want advice then just ask a question, no need to be chatty chatty about it
20:52:00 <gourav> Hold on
21:14:01 <fabien_> hi , is it possible to not return anything in a function that normally return a string ?
21:14:10 <fabien_> i can return "" but i dont want it at all
21:14:37 <mud> fabien_: Not really, no. You can use 'error' or 'undefined', but that's likely not what you want to do very often.
21:14:58 <fabien_> if i use a maybe ? but i need to check the return after right ?
21:15:17 <fabien_> if i return Nothing its not going to work if i ++ Nothing with something else
21:15:31 <mud> You can change the return type to be Maybe String, sure.
21:15:37 <fabien_> but
21:15:40 <mud> And yes, that won't work, but you can work around it easily.
21:15:56 <fabien_> so i change it to a maybe string and i check if its a nothing then ?
21:16:01 <fabien_> its the best way to do ?
21:16:07 <ski> you'll have to say what to do instead, of you get a `Nothing'
21:16:21 <mud> You can check if it's Nothing, sure. Or you can use something like fromMaybe or etc., depending on what you want to happen.
21:16:25 <fabien_> i concat if /= Nothing
21:16:34 <ski> depending on what you want to happen then, there may be shortcuts defined for it
21:16:37 <fabien_> :t fromMaybe
21:16:39 <lambdabot> a -> Maybe a -> a
21:16:48 <fabien_> if its a Nothing what happen
21:16:57 <fabien_> > fromMaybe Nothing
21:16:59 <lambdabot>  error:
21:16:59 <lambdabot>      • No instance for (Typeable a0)
21:16:59 <lambdabot>          arising from a use of ‘show_M202612582559007702527201’
21:17:01 <ski> point is, you have to specify, somehow, what to do when you get a `Nothing'
21:17:11 <ski> > fromMaybe 42 (Just 3)
21:17:13 <lambdabot>  3
21:17:14 <ski> > fromMaybe 42 Nothing
21:17:16 <lambdabot>  42
21:17:29 <mud> > "wheeeee" ++ fromMaybe "" Nothing
21:17:32 <lambdabot>  "wheeeee"
21:17:32 <ski> `fromMaybe' uses the default value provided, if it gets a `Nothing'
21:17:39 <mud> > "wheeeee" ++ fromMaybe "" " omg more stuff"
21:17:42 <lambdabot>  error:
21:17:42 <lambdabot>      • Couldn't match expected type ‘Maybe [Char]’
21:17:42 <lambdabot>                    with actual type ‘[Char]’
21:17:46 <fabien_> = )
21:17:51 <mud> > "wheeeee" ++ fromMaybe "" (Just " omg more stuff")
21:17:53 <lambdabot>  "wheeeee omg more stuff"
21:17:57 <fabien_> oh
21:18:06 <fabien_> > "wheeeee" ++ fromMaybe "" (Nothing)
21:18:08 <lambdabot>  "wheeeee"
21:18:09 <ski> > fmap ("wheeeee" ++) (Just "!")
21:18:10 <fabien_> oh
21:18:11 <lambdabot>  Just "wheeeee!"
21:18:13 <ski> > fmap ("wheeeee" ++) Nothing
21:18:13 <fabien_> so its what i want
21:18:15 <lambdabot>  Nothing
21:18:20 <fabien_> its what i wanted perfect
21:18:22 <fabien_> = )
21:18:22 <fabien_> thanks
21:18:36 <ski> `fmap' will keep the `Maybe', leaving you with the decision of how to handle `Nothing' until later
21:18:36 <Axman6> with stack, does anyone know if it's possible to use ghc 8.2 with an lts which uses 8.0? (eg, lts-9.x)
21:18:53 <fabien_> ok thank you ski
21:19:11 <mud> Axman6: There's a nightly with 8.2 isn't there?
21:19:12 <ski> in some cases, `(>>=)' will be a nicer way to proceed
21:19:40 <ski> but all these are just nicely packaged ways to handle the two cases in some particular fashion
21:20:43 <Axman6> there is, but I was hoping to use the same snapshot we're currently using to avoid too much pain in making fixes for new packages
21:20:45 <fabien_> is it monad ?
21:20:54 <ski> `(>>=)' is a monad operation, yes
21:21:03 <fabien_> i dont know monad for the moment
21:21:09 <fabien_> i prefer to not use it for the moment
21:21:10 <fabien_> aha
21:21:11 <ski> @src Maybe (>>=)
21:21:11 <lambdabot> (Just x) >>= k = k x
21:21:11 <lambdabot> Nothing  >>= _ = Nothing
21:21:24 <jle`> fabien_: you don't need to worry about monads ....
21:21:25 <mud> Axman6: Probably going to be more pain trying to fix stuff in lts that doesn't work with ghc 8.2. It is possible though to force the compiler version, I forget the syntax though.
21:21:47 <jle`> fabien_: you can just think of (>>=) as a useful utility function (like fromMaybe, maybe, fmap, etc.) for your Maybe data type
21:21:48 <ski> it's just a, sometimes, handy way to handle `Maybe's
21:22:23 <fabien_> > "wheeeee" >>++ fromMaybe "" (Nothing)
21:22:25 <lambdabot>  error:
21:22:25 <lambdabot>      Variable not in scope: (>>++) :: [Char] -> [Char] -> t
21:22:35 <fabien_> > "wheeeee" >>= fromMaybe "" (Nothing)
21:22:37 <lambdabot>  error:
21:22:37 <lambdabot>      • Couldn't match expected type ‘Char -> [b]’
21:22:37 <lambdabot>                    with actual type ‘[Char]’
21:22:46 <fabien_> > "wheeeee" >>= "" (Nothing)
21:22:48 <lambdabot>  error:
21:22:48 <lambdabot>      • Couldn't match expected type ‘Maybe a0 -> Char -> [b]’
21:22:48 <lambdabot>                    with actual type ‘[Char]’
21:22:51 <fabien_> i dont knoww
21:23:12 <ski> `(>>=)' for `Maybe' tends to be useful when you have a sequence of operations of `Maybe' things. in each step you might get a `Nothing', and then you stop. otherwise, you continue to the next step. so a sequence of possibly failing steps. that's what `(>>=)' for `Maybe' gives you
21:24:10 <fabien_> its exactly what im searching y
21:25:22 <ski> > Nothing >>= \x -> (if even x then Just (x `div` 2) else Nothing ) >>= \y -> if odd y then Just (3*y + 1) else Nothing
21:25:28 <lambdabot>  mueval-core: Time limit exceeded
21:25:33 <fabien_> = )
21:25:46 <ski> hm, lambdabot was a bit sluggish
21:25:47 <ski> > Nothing >>= \x -> (if even x then Just (x `div` 2) else Nothing ) >>= \y -> if odd y then Just (3*y + 1) else Nothing
21:25:49 <lambdabot>  Nothing
21:25:51 <ski> > Just 12 >>= \x -> (if even x then Just (x `div` 2) else Nothing ) >>= \y -> if odd y then Just (3*y + 1) else Nothing
21:25:53 <lambdabot>  Nothing
21:25:57 <ski> > Just 14 >>= \x -> (if even x then Just (x `div` 2) else Nothing ) >>= \y -> if odd y then Just (3*y + 1) else Nothing
21:25:58 <lambdabot>  Just 22
21:26:17 <ski> in the first case, we start with `Nothing', so we end up with `Nothing'
21:26:38 <fabien_> i dont want to stop when there is a nothing
21:26:41 <fabien_> i just want to ignore it
21:27:02 <Welkin> :t catMaybes
21:27:03 <lambdabot> [Maybe a] -> [a]
21:27:07 <Welkin> use that
21:27:13 <ski> in the next case, we start with `Just' a `12'. so we continue with `x' as `12', which is even. so we continue with `Just' a `6'. so `y' is now `6', which is not odd, so we get `Nothing' here
21:27:17 <Welkin> you can filter out all of the Nothing's
21:27:47 <ski> while with the last one, `x' is `14', `y' is `7', which is odd, so we get `Just' of `7*3 + 1' in the end
21:27:50 <fabien_> i can y
21:27:58 <fabien_> but i was searching for a better way
21:28:06 <fabien_> ok
21:28:08 <fabien_> so its ok 
21:28:20 <ski> fabien_ : "ignore it" is ambiguous. it might mean different things
21:28:37 <fabien_> i just want to go through it 
21:28:38 <fabien_> continue
21:28:46 <Welkin> fabien_: you can
21:28:48 <ski> depending on the situation, it could mean just omit `Nothing's in a list, like `catMaybes'
21:28:50 <Welkin> fabien_: write more than
21:28:53 <fabien_> just 'a' ++ Nothing ++ just 'b' = just "ab"
21:28:53 <Welkin> fabien_: a few words
21:28:56 <Welkin> fabien_: per line
21:29:01 <ski> if you don't have a value, then you can't continue as if you had a value
21:29:17 <ski> if you have a default value, you could continue with that instead (so `fromMaybe')
21:29:47 <ski> if you want to defer the choice of how to handle failure, you can just leave the `Nothing' (and `Just', if you get that instead) in place, using `fmap'
21:30:01 <ski> it all depends on how you want to handle failures
21:30:57 <ski> in any case, just saying "i dont want to stop when there is a nothing","i just want to ignore it" isn't good enough
21:31:11 <ski> you have to say *how* to continue, since you can't continue "as usual"
21:31:49 <ski> if you want your program to blow up if you get a `Nothing', then that's fine. use `fromMaybe' with an error as the default value
21:31:54 <Welkin> > (+1) Control.Category(..) [1,2,3]
21:31:56 <lambdabot>  <hint>:1:23: error: parse error on input ‘..’
21:31:59 <Welkin> lol
21:32:05 <ski> @type (Control.Category..)
21:32:06 <lambdabot> forall k (cat :: k -> k -> *) (b :: k) (c :: k) (a :: k). Category cat => cat b c -> cat a b -> cat a c
21:32:16 <Welkin> > (+1) (Control.Category..) [1,2,3]
21:32:18 <lambdabot>  error:
21:32:18 <lambdabot>      • Couldn't match type ‘[]’ with ‘cat b’
21:32:18 <lambdabot>        Expected type: cat b c
21:32:22 <Welkin> aw
21:32:47 <Welkin> I was wondering if I could use Category's (.) as fmap
21:33:55 <ski> > (+1) Control.Category.. [1,2,3]  -- i suppose you meant, this, but it doesn't work, since the type of `[1,2,3]' doesn't match `cat a b'
21:33:57 <Welkin> I suppose because List is not an instance of Category
21:33:58 <lambdabot>  error:
21:33:58 <lambdabot>      • Couldn't match type ‘[]’ with ‘(->) a’
21:33:58 <lambdabot>        Expected type: a -> b
21:34:44 <ski> (well, `cat' in this case becomes `(->)', because of the left operand of `Control.Category..')
21:35:31 <ski> > Just "a" <> Nothing <> Just "b"  -- fabien_ ?
21:35:33 <lambdabot>  Just "ab"
21:35:43 <fabien_> its ok actually
21:35:45 <fabien_> catmaybes
21:35:48 <fabien_> did the job
21:36:00 <Welkin> fabien_: please use more words per line
21:36:09 <fabien_> oh yea sorry sorry
21:37:23 <ski> > mconcat [Just "a",Nothing,Just "b"]
21:37:25 <lambdabot>  Just "ab"
21:50:08 <johnson> does anyone here know liquid haskell? I'm having an issue where an inner function liquid definition is conflicting with the outer function's liquid type
21:51:05 <lyxia> johnson: the authors are pretty responsive on their slack channel
21:51:46 <lyxia> during the day on East US that is...
21:58:14 <johnson> :(
22:07:26 <Welkin> johnson: you must be aware that your name is used to refer to male genitalia
22:08:25 <erisco> I think Slack sends new clients a backlog, though I could be misremembering
22:08:47 <Welkin> anyone who joins a slack channels sees all of the history
22:09:05 <erisco> yeah so they'll see your questions tomorrow when they wake up
22:09:36 <Welkin> they'll see your future questions that you have not asked yet as well
22:09:47 <erisco> worst case you'll have to make a Haskell program to send off a message at the correct time
22:09:49 <Welkin> they'll see those in the past
22:09:58 <erisco> but without liquid Haskell to verify it, you won't know if it works… hmm
22:11:42 <lyxia> you have the tie the knot in time
22:12:36 <erisco> I think a time machine paradox could resolve this
22:32:44 <EvanR> can anyone explain what sing means here
22:32:46 <EvanR> rget :: sing r -> Rec f rs -> f r
22:37:19 <geekosaur> a placeholder type. stuff that uses Proxy does that a lot too (citing 'proxy' instead of 'Proxy' so you can use *any* type constructor that carries a type, not just Proxy --- or in this case not just Sing
22:39:45 <EvanR> Proxy and Sing are the same thing?
22:39:59 <EvanR> i get proxy but not sing
22:42:49 <geekosaur> not the same thing, no, unless you count that in some sense Sing is at kind level what Proxy is at type level. but with TypeInType that distinction fades a bit...
22:43:27 <geekosaur> (at least as I understand it --- but my understanding when it comes to type level is a bit weak still)
22:44:29 <geekosaur> point being that sing instead of Sing lets you use other kind-indexers, just as proxy instead of Proxy lets you use other type-indexers
22:45:22 <EvanR> so i am supposed to use Sing under normal circumstances
22:45:31 <geekosaur> yes, if it's convenient
22:45:31 <EvanR> now i need to figure out what Sing is
22:46:11 <geekosaur> like using proxy instead of Proxy lets you, if you have a Maybe, use it directly instead of performing extra histrionics to get a Proxy form it when at the typechecker level there often isn't really a visible difference
22:46:25 <geekosaur> Sing is a kind-indexed singletons type family
22:47:20 <geekosaur> if you have some other kind-carrying thing and there's no *specific* need for Sing beyond it carrying a kind, using a tyvar instead of explicit Sing makes the programmer's job easier
22:48:03 <geekosaur> but f you don't have such a thing, you can just use Sing
22:48:27 <EvanR> the first argument is establishing uh... what kind 
22:48:42 <geekosaur> I don't know what Rec is offhand
22:48:47 <EvanR> vinyl
22:49:29 <EvanR> thats from Data.Vinyl.Lens
22:49:55 <geekosaur> but I'd suspect kind-indexed records... vinyl, yeh, that becomes likely then
22:50:30 <geekosaur> in this case kinds define the "fields" (as the inhabitants of the kind)
22:50:53 <geekosaur> if you have a field and nothing else you can use Sing; if you have a record with such a field, you can use the record
22:50:55 <lyxia> Not sure why they call it sing, it's the same as proxy here.
22:51:00 <lyxia> https://hackage.haskell.org/package/vinyl-0.6.0/docs/Data-Vinyl-Lens.html#v:rget
22:53:26 <EvanR> oh
22:53:51 <purpleunicorn> Does anyone know how to use limechat because I’m confused 
22:54:49 <EvanR> the first argument is really the field, but since fields are types, not values, you need a stand-in
22:55:53 <EvanR> such as a Proxy
22:57:42 <EvanR> dont know why i thought there were 3 arguments
22:58:29 <purpleunicorn> Lol
22:58:49 <rightfold> purpleunicorn: you type a message and hit return
22:59:02 <rightfold> Kind of like GHCi
22:59:16 <purpleunicorn> Lol I did 
22:59:35 <purpleunicorn> I can see users on the right side bar but no one types anything on the chat 
23:06:27 <cocreature> purpleunicorn: that’s because nobody is typing anything atm :)
23:06:46 <DigitalKiwi> I was typing a really long message
23:08:16 <rightfold> Maybe everybody is on your ignore list
23:08:23 <rightfold> Classic mistake
23:09:09 <purpleunicorn> Lol
23:09:16 <purpleunicorn> Why I’m not annoying anyone
23:16:52 <ij> How do I test fixity of operations in ghci?
23:17:22 <ij> :info
23:20:18 <ij> Function's functor is composition? Amazing.
23:22:16 <rightfold> In many cases, fmap applies a function to the values whose types are in positive position. For functions, these are the return values. Applying a function to the return value of another function results in function composition.
23:24:01 <quchen> ij: What’s a »Map a b«? Well, it allows you to look up a »b« given an »a«.
23:24:15 <quchen> ij: What’s a »a -> b«? Well, it allows you to look up a »b« given an »a«.
23:24:45 <quchen> The main difference is that functions in Haskell are usually total (there is a »b« for every »a«), while maps are not.
23:25:25 <quchen> Regardless, what fmap does for Map is pretty clear, so it’s no surprise it does the same thing for ->. And that just so turns out to be equivalent to function composition.
23:28:33 <liste> quchen: so Map a b ~ a -> Maybe b ?
23:29:05 <quchen> liste: Yup, pretty much. (Denotationally. Operationally, they may have vastly different efficiency.)
23:30:20 <quchen> :t flip M.lookup
23:30:22 <lambdabot> Ord k => M.Map k a -> k -> Maybe a
23:30:51 <quchen> :t \f -> M.fromList [ (x, f x) <- [minBound ..] ]
23:30:52 <lambdabot> error:
23:30:52 <lambdabot>     parse error on input ‘<-’
23:30:52 <lambdabot>     Perhaps this statement should be within a 'do' block?
23:30:58 <quchen> :t \f -> M.fromList [ (x, f x) | x <- [minBound ..] ]
23:30:59 <lambdabot> (Enum t, Bounded t, Ord t) => (t -> a) -> M.Map t a
23:31:21 <quchen> liste: those are the two functions converting between the two
23:31:36 <quchen> The latter requires Enum/Bounded to enumerate all the values, but that’s just a technical detail
23:33:05 <ij> "~" for isomorphic?
23:33:59 <rightfold> Well it also depends on the Ord instance used
23:35:10 <rightfold> If you have an Ord instance for which all even integers compare equal, they won’t be isomorphic
23:36:23 <quchen> ij for kind-of-isomorphic.
23:36:52 <quchen> Not literally isomorphic, but as in »conceptually they solve the same problem«, namely associating a key with a value.
23:37:33 <quchen> rightfold: Well if you put nonsense in, you’ll get nonsense out.
23:42:09 <rightfold> It can be a valid total order 🤷🏼‍♀️
23:42:35 <rightfold> Orders where unidentical values compare equal are quite common
23:44:59 <rightfold> WTB quotient types 🤓 (a / (==) -> Maybe b ~ Map a b
23:45:22 <rightfold> )
23:45:48 <ij> "WTB"?
23:46:25 <ij> Also, what characters are those blocks supposed to be?
23:48:32 <jw358> "want to buy" - an mmo meme
23:48:37 <mbrock> it's kind of weird that `HashMap.keys` can return different orders for the same value on different computers
23:48:39 <jw358> the blocks are emoji
23:49:06 <ski> > maxBound :: Int
23:49:09 <lambdabot>  9223372036854775807
23:50:05 <ski> it probably makes mobile code harder to achieve
23:52:16 <quchen> rightfold: Sure, and main=main is a valid and sound Haskell program, but that doesn’t make it useful
23:52:30 <mbrock> yeah, a user opened an issue that my test suite failed because everything was the other way around on their computer
23:53:15 <rightfold> quchen: Ord instances with this property are often useful
23:53:24 <ski> endianess ?
23:54:15 <rightfold> memcpy is not a good way to decode and encode integers :')
23:54:39 <rightfold> Probably the hash function used for hash maps is different for different sizes of Int/Word
23:55:32 <geekosaur> mbrock, depending on the order of a HashMap is a bad idea anyway. if you want ordered keys, that's what Map is for
23:56:03 <geekosaur> I mean,. even the package name tells you that: _unordered_-containers
23:56:15 <mbrock> geekosaur: yeah, I hadn't given much thought to it, because I'm just a mere Aeson user
23:56:46 <geekosaur> yeh, you;re not supposed to depend on key order in JSON either, it's usually represented as an unordered dictionary type
23:57:35 <tdammers> in fact, HashMap returning a consistent ordering for independently created HashMaps on the same computer is a bit of a problem, really
23:57:41 <mbrock> I was mostly surprised because I tend to expect Haskell code to be "deterministic"
23:58:58 <tdammers> I'd assume that the Hashable instances for some primitive types depend more or less directly on the actual in-memory representations, which can differ between machines
23:59:50 <tdammers> a hashdos-proof implementation would have to change the hashing function for each hashmap, or at least cycle hash salts regularly, but this is kind of tricky in a pure language
23:59:54 <tdammers> even if you cheat
