01:09:47 <tom-lambda> For the type signature of >>= :: m a ->  ( a -> m a ) -> m a
01:10:02 <tom-lambda> How is type a obtained from an m a?
01:10:48 <cocreature> tom-lambda: 1. that’s not the type signature of (>>=), the correct type signature is (>>=) :: m a -> (a -> m b) -> m b
01:10:59 <cocreature> tom-lambda: 2. that’s up to the Monad instance of m to define
01:12:01 <tom-lambda> Ah ok. So That second argument (a -> mb) is defined in the bind method of a given monad instance?
01:12:13 <dminuoso> tom-lambda: no.
01:12:17 <cocreature> no, (>>=) is defined
01:12:22 <tom-lambda> (>>=) :: m a -> (a -> m b) -> m b Is the generalised form of bind right?
01:12:25 <dminuoso> tom-lambda: that is whats commonly called "the monadic action"
01:12:36 <dminuoso> tom-lambda: Not the generalized form. That *is* bind.
01:12:38 <cocreature> which gets two arguments of type "m a" and "a -> m b" and needs to produce and "m b"
01:13:19 <liste> :t (>>=) -- doesn't it have the Monad constraint too ?
01:13:20 <lambdabot> Monad m => m a -> (a -> m b) -> m b
01:13:45 * dminuoso figured that `m` being used implied that constraint
01:13:46 <tom-lambda> So when we define bind
01:13:53 <tom-lambda> are we just defining the bind operator?
01:14:01 <dminuoso> Yes.
01:14:13 <tom-lambda> I am getting confused as I thought bind was just a function implemented only on monad instances
01:14:17 <liste> "bind" is just a human-pronounceable name for >>=
01:14:52 <tom-lambda> Ok so (>>=) :: m a -> (a -> m b) -> m b is just the type signature of bind
01:15:07 <tom-lambda> but the actual implementation of bind is defined according to the Monad instance
01:15:10 <dminuoso> tom-lambda: You missed the constraint that liste mentioned, but yes.
01:16:32 <liste> to implement Monad, you need to implement >>= and return (there's also join, but let's not get into that)
01:16:38 <tom-lambda> Thanks so much that was a great explanation
01:16:59 <cocreature> and return is optional in 8.2 :)
01:17:12 <dminuoso> cocreature: Oh really? What does it default to?
01:17:22 <tom-lambda> So return just takes the type a and wraps it in a monad?
01:17:22 <cocreature> pure
01:17:29 <cocreature> https://hackage.haskell.org/package/base-4.10.0.0/docs/src/GHC.Base.html#Monad
01:17:40 <dminuoso> tom-lambda: In some law-preserving way.
01:18:59 <tom-lambda> So the purpose of monads is to allow the application of pure functions to impure values and allow sequencing?
01:19:20 <dminuoso> tom-lambda: monads dont exactly have a purpose. they are just a pattern
01:20:01 <dminuoso> tom-lambda: Afaik you could have side-effects before monads too, but its just more elegant with monads.
01:20:02 <cocreature> “pure” and “impure” is a confusing term to use in this context, there is nothing impure about a "Maybe Int"
01:20:28 <dminuoso> tom-lambda: but at the end that "pattern" bit is more important to understand. List for example has a monad instance, but it does not model side effects
01:21:21 <tom-lambda> So could we replace the pure/impure terms in my previous statement with computational context?
01:22:11 <cocreature> tom-lambda: you’re first going to have to define what exactly “computational context” means
01:22:18 <liste> I'd just use terms "values of type a" and "values of type m a"
01:22:23 <cocreature> liste++
01:23:07 <liste> Monad just defines some operations on a type, that fulfill certain laws
01:24:16 <tom-lambda> Thanks!
01:24:46 <dminuoso> tom-lambda: They are just a highly generalized pattern with no specific meaning.
01:24:57 <dminuoso> A programming pattern that is.
01:26:56 <tom-lambda> I think part of my misunderstanding was thinking that the >>= operator was the same thing for all monads instead of realising that all this operator does is apply the bind method of that particular monad instance
01:27:41 <tom-lambda> Im not used to thinking of the same operator being defined across multiple types
01:28:04 <tom-lambda> fyi I have never even used a statically typed language before
01:28:16 <dminuoso> tom-lambda: It's called ad-hoc polymorphism.
01:28:26 <liste> tom-lambda: the same applies for numbers too
01:28:29 <liste> > 1 / 3
01:28:31 <lambdabot>  0.3333333333333333
01:28:41 <dminuoso> tom-lambda: The speciality of Monad however is that its lawful - and it receives syntax sugar.
01:28:46 <liste> oh wait, that's not a good example
01:28:58 <tom-lambda> haskell is gradually blowing my mind
01:28:59 <liste> > (2 + 3, 2.0 + 3.0)
01:29:01 <lambdabot>  (5,5.0)
01:29:21 <liste> both use the + operator, but it's defined differently for integers and floating-point numbers
01:29:56 <liste> other languages have special cases of + for different numbers, but in Haskell it's just a regular function
01:29:59 <liste> :t (+)
01:30:00 <lambdabot> Num a => a -> a -> a
01:30:53 <tom-lambda> :D
01:31:19 <tom-lambda> So in haskell the type signature forms the generalised pattern for the operator
01:31:21 <dminuoso> tom-lambda: Im wondering whether you are rushing a bit too fast into Haskell.
01:31:37 <dminuoso> If you have not heard about ad-hoc polymorphism before, and look at Monads, it implies that you have not looked at Functors yet.
01:31:52 <dminuoso> Because this concept should have been familiar when you used fmap the first time.
01:31:53 <tom-lambda> Not really looked at functors :p
01:31:59 <tom-lambda> Read about them briefly
01:32:31 <tom-lambda> Not sure how fmap works
01:32:43 <dminuoso> tom-lambda: Turns out the signature is subtly different.
01:32:50 <dminuoso> :t (=<<)
01:32:52 <lambdabot> Monad m => (a -> m b) -> m a -> m b
01:32:53 <dminuoso> :t fmap
01:32:54 <lambdabot> Functor f => (a -> b) -> f a -> f b
01:36:45 <tom-lambda> So the only difference is that the first argument is a function that returns a different type as output than is input?
01:37:25 <dminuoso> tom-lambda: And the type constraint (though as it happens many functors are also monads, and every monad definitely is a functor)
01:37:48 <portnov> hi all
01:38:26 <dminuoso> tom-lambda: Strictly speaking no however. At any rate, you should probably get a decent learning resource.
01:38:47 <tom-lambda> Thanks so much guys really appreciate the help. Should I just work through learn you a haskell sequentially?
01:39:10 <ndcroos> Hi
01:41:13 <dminuoso> Im not equipped to give advice on learning material. 
01:48:07 <jim_> greetings. i've been going through the data61 course, and have a small question: namely, when defining the monad instance for the reader, the bind operator, (=<<) :: (a -> ((->) t b) -> ((->) t a) -> ((->) t b)
01:48:28 <jim_> f =<< g = f . g   is not a correct solution?
01:48:54 <jim_> and yet, f =<< g = \t f (g t) t , is 
01:53:28 <liste> jim_: that applies "t" twice
01:53:35 <liste> with (.), "t" is applied only once
01:55:06 <liste> (f . g) x is f (g x), not f (g x) x
01:56:30 <jim_> i noticed that, but shouldn't it be applied only once?
01:56:51 <jim_> i mean, i'll walk through it again, thanks.
01:57:55 <jim_> yeah, sorry, it's clear now
02:04:21 <jchia_> Question about ghc's '-j' option: Is the documentation (https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/using.html?highlight=#ghc-flag--j) accurate? I did an experiment and it seems that if not specified, '-j' defaults to 1, not the number of processors as described in the documentation. I tested on Arch Linux with 8.2.1.20171108, i.e. 8.2.2 RC3.
02:04:58 <liste> jchia_: how did you test it?
02:05:07 <jchia_> If ghc is detecting the wrong number of processors, that's another problem, but how can I tell how many it detected?
02:05:35 <jchia_> liste: I made a stack project with two modules each sleeping for 10 seconds in a lifted TH with unsafePerformIO. I can share the project if you want.
02:06:14 <jchia_> If I do a simple build, it takes 20+seconds. If I explicitly give '-j2', it takes 10+ seconds.
02:07:13 <jchia_> liste:
02:07:13 <jchia_> forceCompilationDelay :: String
02:07:13 <jchia_> forceCompilationDelay = $(lift $ unsafePerformIO $ threadDelay 10000000 >> pure "")
02:08:50 <liste> jchia_: I see
02:08:58 <liste> looks like a sensible test
02:11:36 <Maxdamantus> jchia_: are you at least specifying "-j" in the other case?
02:12:08 <Maxdamantus> jchia_: the documentation says the "-j" flag enables parallel compilation. If you omit the flag completely it simply won't be parallel.
02:12:32 <Maxdamantus> jchia_: and if you want it to detect the number of parallel tasks to do, you pass "-j" alone instead of "-j2"
02:13:16 <jchia_> Maxdamantus: Good point, let me try that. I thought if not specified, there would still be a '-j' value. I did a test explicitly giving '-j' and it took 10+s, so I think you're right.
02:15:15 <liste> usually defaults are conservative as to not break stuff
02:56:54 <Xion__> I have a problem regarding runtime polymorphism (I think). Basically, I have a (Servant) app configured by data Env = Dev | Test | Prod. Depending on Env, I want to connect to different DB backends (Sqlite for Test, psql for Prod, etc.), but I have problem writing the makePool function: makePool :: IsSqlBackend b => Environment -> Pool b (from resource-pool package)
02:58:01 <Xion__> The problem is that I actually want to return any IsSqlBackend b => Pool b from there, not just one particular Pool b (because it depends on the value of Env).
02:58:22 <Xion__> It does sound a bit like dependent types but I'm confused since this kind of thing is very possible in languages less powerful than Haskell.
02:59:28 <Xion__> I tried making it: makePool :: Environment -> forall b. IsSqlBackend b => Pool b -- but that quickly went into some GHC complaints about lack of support for "impredicative typing" when I had to wrap it in IO.
03:09:33 <cocreature> Xion__: basically the problem is that "Environment -> Pool b" says that the caller can choose what b is but what you want to say is that the caller can’t make any assumptions about "b" apart from the fact that it’s an instance of IsSqlBackend
03:10:20 <cocreature> Xion__: you can either make an existential data type and return that or you can use a "withPool :: Environment -> (forall b. IsSqlBackend b => Pool b -> c) -> c" function
03:21:03 <Xion__> Basically a newtype wrapper, right
03:24:00 <cocreature> Xion__: no, existentials need to use "data" not "newtype"
03:24:11 <cocreature> the instance needs to be stored somewhere so they can’t have the same runtime representation
03:26:00 <Xion__> Mhm.
03:26:30 <Xion__> Fortunately I discovered that Persistent exposes a Pool SqlBackend type which I can simply return instead ;)
03:26:42 <Xion__> (and it works with both DB backends)
03:48:34 <MathUser157> Is first-order logic both complete and consistent?
03:49:32 <Lowl3v3l> MathUser157: do you talk about gödels theorem?
03:49:42 <MathUser157> Yeah
03:50:39 <MathUser157> Wikipedia states that FOL is a formal system, but Godel's incompleteness theorem holds for all formal systems as far as I understand, so that's why I am confused 
03:51:43 <Lowl3v3l> MathUser157: http://www.cs.cornell.edu/courses/cs2800/2017sp/lectures/lec41-godel.html
03:53:29 <lambdamu_> MathUser157: Can you express arithmetic in a pure first-order theory? That is a requirement to for godels theorems to apply
03:53:32 <fakenullie> System built on first order logic is either incomplete or inconsistent
03:54:17 <MathUser157> lambdamu_ is A and B not arithmetic?
03:54:45 <lambdamu_> MathUser157: What is A and B here?
03:55:22 <liste> MathUser157: Gödel's theorem is about the arithmetic of natural numbers
03:56:03 <MathUser157> liste, does it hold for ZFC then?
03:56:20 <fakenullie> It does
03:56:33 <lambdamu_> MathUser157: First order logic is complete and sound (or rather there are deductive systems for FOL that have those properties), consistency is a property of a FOL theory
03:57:31 <fakenullie> Afaik there are theorems unprovable in zfc
03:57:38 <liste> MathUser157: it holds for ZFC
03:57:58 <MathUser157> liste, so it's not about natural numbers only?
03:58:09 <liste> MathUser157: you can express statements about natural numbers in ZFC
03:58:21 <lambdamu_> fakenullie: Only assuming ZFC is consistent :D
03:58:44 <fakenullie> Well, that means it's either incomplete or inconsistent
03:58:44 <MathUser157> ahh, so it's about any formal system that allows expressing arithmetic of Nats?
03:58:49 <liste> MathUser157: yes
03:59:06 <MathUser157> How about second-order logic?
04:01:27 <Lowl3v3l> MathUser157: are you sure you shouldn't just read a good book on formal logic?
04:02:27 <MathUser157> I think I should :) could you recommend a good one?
04:03:02 <Lowl3v3l> MathUser157: i like Barwise and Etchemendy, though its not only about logic
04:03:06 <lambdamu_> MathUser157: Logic is subtle is is import to distinguish between languages (e.g. first order logic, second order logic), deductive systems (inference rules), models and theories (sets of sentences) and which properties applies to what
04:07:35 <lambdamu_> ZFC for example is IMHO not a useful first order theory, since it requires infinite axioms (an axiom schema), that means for example that you can't use a tableaux calculus and feed it with zfc sentences and be sure it terminates if the sentence is true
04:08:18 <lambdamu_> provability being semidecidable in FOL you could expect that from a first order theory
04:08:50 <lambdamu_> true arithmetic and and set theory are inherently second order concepts
04:09:51 <lambdamu_> but there are fragments of e.g. arithmetic like presburger arithemetic that are truly first order
04:15:44 <MathUser157> lambdamu_ can you recommend a book about everything you just described? I understand logic, and can do proofs. I also know some abstract algebra, but I'd like to dive more into formal systems
04:17:23 <lambdamu_> MathUser157: I can't personally recommend a book, but a friend of mine liked this: https://www.amazon.com/Introduction-Logic-Methodology-Deductive-Mathematics/
04:20:43 <lambdamu_> Regarding the axiom schemata I mentioned earlier, you can have inifinite axioms in a FOL theory and even have the theory be decidable, presburger arithmetic for example, so I'm not sure my criticism of the infinite axioms of zfc goes to the point of what is wrong with zfc
04:23:06 <toppler> It's difficult to feed infinite axioms to an off-the-shelf resolution prover.
04:23:59 <lambdamu_> toppler: Yeah it would have to accept some kind of second order axiom or call back into some kind of oracle
04:24:47 <lambdamu_> I'm not sure actually what is the state of the art method to solve presburger sentences, but I believe some SMT solvers have that feature
04:25:58 <lambdamu_> Although the general case is computationally intractable, but someone told me the intractable sentences are rather pathological
04:28:57 <toppler> Yeah, couldn't say. I mostly did my arithmetic stuff in HOL Light, which I think had the Presburger decision procedure, and performance wasn't great. But it was all interactive, so you don't need to rely on the general case.
04:35:51 <rwarfiel1> Could someone tell me what I'm doing wrong ... I'm trying to convert a list of Scientific to a Vinyl/Frames type record. 
04:36:04 <rwarfiel1> l2r :: Sing rs -> [Scientific] -> Record rs
04:36:04 <rwarfiel1> l2r SNil [] = RNil
04:36:04 <rwarfiel1> l2r (SCons _ _) (e1:es) = (Identity e1) :& l2r ss es
04:37:00 <rwarfiel1> ghc gives a fairly cryptic error indicating it can't deduce n0 ~ Scientific on the third line
04:38:18 <rwarfiel1> I'm thinking maybe I need to match the first argument of SCons to some singleton to tie the type down as scientific? But how?
04:40:23 <rwarfiel1> I've been tearing my hair out all day
04:40:35 <maerwald> you've got any hair left?
04:40:48 <rwarfiel1> it grows fast
04:40:54 <maerwald> :D
04:49:42 <lambdamu_> rwarfiel1: I'm guessing here, but what is the purpose of the first argument? Couldn't you just give a type to rs and leave it of?
04:53:44 <rwarfiel1> It's entirely possible I don't need it.  It's a singleton
04:55:02 <rwarfiel1> The thing is I can't give rs a concrete type ... rs is a type level list that depends on the length of the [Scientific] list
04:55:16 <rwarfiel1> so I started with this
04:55:22 <rwarfiel1> l2r_ :: [Scientific] -> Record rs
04:55:22 <rwarfiel1> l2r_ [] = RNil
04:55:22 <rwarfiel1> l2r_ (e1:es) = (Identity e1) :& l2r_ es
04:55:49 <rwarfiel1> and get a complaint about rs not matching Scientific : rs0
04:56:36 <lambdamu_> rwarfiel1: Hm yeah I see the problem
05:01:10 <lambdamu_> rwarfiel1: The function is more general then Scientific something like this would work to? l2r :: Sing (a ': rs) -> [a] -> Record (a ': rs), but in the type level nil case you don't have an a
05:01:27 <lambdamu_> rwarfiel1: I guess you need a type class
05:04:00 <rwarfiel1> Hmm.. let me try the type class
05:11:56 <euniarte> Hi, I am trying to run hprotoc in a Setup.hs hook, so I chose the preBuildHook which returns a HookedBuildInfo . When I am trying to import Distribution.Types.HookedBuildInfo, the build fails with "Failed to load interface for ‘Distribution.Types.HookedBuildInfo’", although Distribution.Simple which is also contained in the Cabal package gets imported fine. How is this possible?
05:11:56 <euniarte> Maybe Distribution.Types.HookedBuildInfo is not being exported by Cabal? There are Haddocks though :/ .
05:14:05 <rwarfiel1> :t Sing
05:14:07 <lambdabot> error: Data constructor not in scope: Sing
05:19:51 <lyxia> euniarte: Are you perhaps using an older version of cabal than 2.0?
05:21:01 <euniarte> lyxia: I'm using Cabal 1.24.2.0 (forgot to mention that) on nixos
05:22:00 <euniarte> (and through stack)
05:24:00 <euniarte> cabal build does yield the same error (so this rules out stack)
05:24:27 <rwarfiel1> Well this is weird.  This gives me class L2R sing rs where
05:24:27 <rwarfiel1>     l2r :: Sing rs -> [Scientific] -> Record rs
05:24:28 <rwarfiel1> instance L2R (Sing '[]) (Record '[]) where
05:24:28 <rwarfiel1>     l2r SNil [] = RNil
05:25:31 <rwarfiel1> sorry about the paste... I'm getting "Expected kind ‘[*]’but ‘Record '[]’ has kind ‘ghc-prim-0.5.0.0:GHC.Types.*’" in the instance line
05:26:32 <rwarfiel1> Why is it expecting kind [*]?  
05:27:01 <cocreature> euniarte: lyxia is probably right: that package only works with Cabal >= 2.0
05:27:19 <Gurkenglas> Why is there no (b -> (a, b)) -> b -> [a] between iterate and unfoldr?
05:27:52 <euniarte> cocreature: Facepalm, I somehow though 1.24 > 2.0 ...
05:34:33 <hexagoxel> Gurkenglas: that's a mapAccum. mapAccumL is sufficiently lazy to work on (repeat ()).
05:35:31 <lambdamu_> rwarfiel1: I don't feel like type level programming today, so this POC is the best I can do: http://lpaste.net/360143
05:37:42 <rwarfiel1> Thank you! This looks very helpful
05:38:04 <Gurkenglas> hexagoxel, ooh well spotted, though \f x -> snd $ mapAccumL (\b _ -> swap $ f b) x (repeat ()) doesn't really give more peace of mind than \f -> unfoldr (Just . f)
05:38:04 <euniarte> lyxia, cocreature: It works now :) (what a stupid mistake...)
05:39:29 <lyxia> rwarfiel1: the general type of l2r is   l2r :: L2R sing rs => ... -> Record rs    now your instance picks   rs ~ Record '[]   so   l2r :: ... -> Record (Record '[])   and this nested "Record" application is causing the kind error..
05:40:24 <hexagoxel> Gurkenglas: right
05:40:46 <rwarfiel1> Thanks lyxia... I've confused my type level lists and records
06:51:11 <ahri> i have a function `e5e s n = s ++ show n
06:51:31 <ahri> and i want to reimplement it in a point-free style
06:52:32 <lyxia> Are Haskell programs getting slower? http://lpaste.net/360144
06:52:48 <ahri> but i can't work it out because of the order of params not matching. i keep wanting to store the values somewhere to use in a different order but i'd really like to be able to juggle this stuff in a pf style
06:53:05 <liste> ahri: you may need to use flip
06:53:07 <liste> :t flip
06:53:08 <lambdabot> (a -> b -> c) -> b -> a -> c
06:53:09 <lyxia> @pl e5e s n = s ++ show n
06:53:09 <lambdabot> e5e = (. show) . (++)
06:53:19 <ski> ahri : start by rewriting it as `e5e s n = (++) s (show n)'
06:53:29 <ski> then use
06:53:33 <ski> @src (.)
06:53:34 <lambdabot> (f . g) x = f (g x)
06:54:07 <hpc> lyxia: i wonder if the slowdown scales with a larger dataset
06:54:22 <ski> to rewrite it further, so that you can apply function extensionality (sometimes called eta- reduction/contraction, which isn't quite the same thing, but is related)
06:56:45 <ski> (eta expansion is going from a (function-valued) expression `...' to an expression `\x -> (...) x', where the variable name `x' is chosen tot conflict with any free variable of the expression `...'. eta contraction/reduction is going in the opposite direction, where one must ensure that `x' (or whatever the variable is called) is not mentioned (freely) in the expression `...')
06:58:10 <lyxia> ski: list length x10 -> run time x10
06:58:24 <ski> (otoh, function extensionality claims that, for any (function) expressions `f' and `g', if `f x = g x' holds for every `x', then in fact `f = g'. one can think of this as "cancelling the `x'". here again, `x' may not be (freely) mentioned in the expressions `f' and `g')
06:58:34 <ski> lyxia : sorry ?
06:58:58 <ahri> ski: i'm reading over what you said about extensibility, it's not something i'm familiar with :)
06:59:52 <ahri> lyxia: the result that lambdabot came up with is pretty, i hadn't thought of using `.' like that
06:59:53 <ski> the idea there is that if `f' and `g' "behaves the same", in that they give the same answer (`f x = g x'), for every possible input `x', then the functions `f' and `g' must in fact be equal
07:00:32 <le_jonge> hi there. i have a problem which i hope to be able to solve with ExistentialQuantification/GADTs, but i failed trying this myself. i put together a comprehensive example with a lot of comments here: https://gist.github.com/tfc/c4fad02c692ec01bda0233520170a519 would anybody mind having a look at it and helping me?
07:00:58 <ahri> ski: ah yes, that does make me think of eta reduction
07:00:59 <ski> the idea being that the only thing you can do with a function, to extract information out of it, is to apply it to an input. so if two functions give the same result for every possible input, these two functions must be the same. that's what function extensionality means
07:01:06 <ski> ahri : does that make sense to you ?
07:02:51 <ahri> yes! thank you :) i'm struggling to see how i go from `e5epf1 s n = (++) s (show n)' to `e5epfN = (. show) . (++)', though
07:04:45 <ski> here's how to show that function extensionality holds, under the assumption that eta expansion&contraction works : we assume that `f x = g x', for every `x'. we want to reach the goal that `f = g'. since `f x = g x', for every `x', we deduce that abstracting both sides over `x', gives us that the resulting two functions (lambda expressions) are equal : `(\x -> f x) = (\x -> g x)'
07:05:34 <ski> now, since we assumed eta, we know that `f = (\x -> f x)' and `(\x -> g x) = g'. combining those steps with the former equality (using transitivity of equality), we arrive at the goal `f = g'
07:07:28 <lyxia> ski: sorry that was addressed to hpc.
07:09:16 <hpc> lyxia: ah, so the slowdown is consistent
07:09:27 <hpc> you might be onto something
07:09:41 <ski> here's how to show that eta holds, assuming that function extensionality holds : we want to prove `f = (\x -> f x)'. well, "pick" (or "consider", if you prefer) an arbitrary input `y'. now, according to beta reduction/expansion, we have `f y = (\x -> f x) y' (just substitute the actual parameter `y' for the formal parameter `x' in the body `f x', and you get `f y')
07:11:02 <ski> but we have that `f y = (\x -> f x) y' holds for every input `y', since `y' was "arbitrarily chosen", with no restriction on what `y' can be (except that it must be of the argument type of `f'). so, by extensionality, we have `f = (\x -> f x)', as was the goal
07:11:54 <ski> ahri : now that's a little theory, which may or may not help you understand better what the eta rule and the function extensionality rule are, and how they relate
07:12:27 <ski> the main point here is that they are equivalent (though we needed to use the beta rule for one direction of the equivalence)
07:14:26 <ski> the beta rule is what you use to state e.g. the equality (or computation step, if you prefer)`(\x -> x * x) (2 + 3) = (2 + 3) * (2 + 3)' -- it amounts to replacing the formal parameter (the "input variable", or pattern in more complicated cases) with the actual parameter (the argument expression), in the body of the lambda expression
07:14:45 <ski> ahri : do you see how to continue with making the defining equation for `e5e', that i stated, more "pointless" (or point-free, if you prefer that term :) ?
07:14:52 <lyxia> hpc: ah it looks like that wasn't valid, the differences go away if I let f get specialized, e.g., by inlining or a type signature... I'll have to investigate more
07:17:15 <ski> ahri : the goal here is that, from `e5e s n = s ++ show n', which i rewrote as `e5e s n = (++) s (show n)', we want to "isolate" `n' at the end of the defining equation, so that it looks like `e5e s n = (...) n', where the expression `...' doesn't mention `n'. if we reach this point, for some (as of yet unknown) expression `...', then we can apply function extensionality to "cancel the `n's"
07:17:56 <ski> ahri : if you're not sure how to proceed from here, i can show how it can be done. should i ?
07:18:03 * ski looks at ahri
07:47:22 <laserpants> "[{\"config\":{\"Image\":4}},{\"config\":{\"Image\":5}}]" ^._Array ^? traverse . key "config"
07:47:30 <laserpants> How can I make this behave like a map operation?
08:00:56 <kuribas> What's a good abstraction for tabular data?  (like financial accounts)  Maybe frp, where changing one row will automatically update others?
08:02:03 <dminuoso> kuribas: frp is the way to do it
08:02:37 <kuribas> Is there frp for python?
08:04:27 <hpc> if there's reactive programming, i doubt it will be functional
08:05:47 <dminuoso> Heh.
08:09:13 <codeshot> is there a monoid instance that fulfills the "optional" nature of Maybe but for which (Got a) <> (Got b) = Got (a <> b) ?
08:10:13 <codeshot> Obviously there is and I just have to type it in, but is there one I can have with a mere import ?
08:10:48 <kuribas> What was first, reactive programming or functional reactive programming?
08:11:16 <dminuoso> functional programming.
08:11:26 <kuribas> > Just (Sum 1) <> Just (Sum 2)
08:11:29 <lambdabot>  Just (Sum {getSum = 3})
08:11:45 <kuribas> codeshot: ^^
08:12:13 <kuribas> dminuoso: so reactive programming was based on frp?
08:12:51 <codeshot> weird, so Maybe is it
08:12:56 <codeshot> but my code didn't do that
08:12:58 <codeshot> how odd
08:13:03 <codeshot> wonder what I did wrong
08:13:24 <dminuoso> codeshot: your `a` in your Maybe a has to be an instance of Monoid.
08:13:50 <codeshot> ah, my question is dumb
08:14:19 <kuribas> > Just 1 <> Nothing
08:14:21 <lambdabot>  error:
08:14:22 <lambdabot>      • Ambiguous type variable ‘a0’ arising from a use of ‘show_M473421440918...
08:14:22 <lambdabot>        prevents the constraint ‘(Show a0)’ from being solved.
08:14:29 <kuribas> > Just (Sum 1) <> Nothing
08:14:31 <lambdabot>  Just (Sum {getSum = 1})
08:15:14 <codeshot> I used liftA2 of (<>) to apply to Maybes in a List which is dumb
08:15:15 <dminuoso> codeshot: Remember that Integer or Int do not have Monoid instances, because the operation would be ambiguous (should it be (*) or (+) ? )
08:15:21 <dminuoso> Oh
08:15:27 <codeshot> it was totally unrelated dumbness
08:15:32 <codeshot> thanks anyway
08:33:47 <codeshot> Is there a variant of take for Foldable?
08:33:57 <ertes> kuribas: FRP is not a good abstraction for tabular data itself…  it's a framework for encoding the *state* and changes of the data
08:33:59 <codeshot> I can't see one but it would seem to make utmost sense
08:34:06 <merijn> codeshot: "take n . F.toList"?
08:34:09 <royal_screwup21> so I was leanring about the Maybe datatype and I was wondering if it's possible to have a function where the Maybe is on the input side as well? Like so: Maybe Bool → Maybe Bool?
08:34:26 <codeshot> merijn, that changes the type from (f a) to [a]
08:34:42 <lyxia> :t (id :: Maybe Bool -> Maybe Bool) (Just False) -- royal_screwup21 
08:34:44 <lambdabot> Maybe Bool
08:34:53 <codeshot> royal_screwup21, yup you can do that
08:34:57 <merijn> codeshot: oh, you want the same 'f', no, that's definitely not possible
08:35:18 <merijn> codeshot: Because Foldable thus not require that you can sensibly create a modified version of the original structure
08:35:24 <merijn> s/thus/does
08:35:38 <codeshot> what about Traversable or MonadPlus?
08:35:50 <merijn> codeshot: Also not, maybe you want https://hackage.haskell.org/package/witherable
08:36:16 <merijn> not sure if that allows "take", though
08:36:18 <ertes> kuribas: in other words: before you bring FRP into the game you still need to think about how you're going to represent any individual snapshot of the data, and once you have that you can use FRP to connect the data to time and the real world
08:36:22 <kuribas> :t (fmap :: a -> b -> (Maybe a -> Maybe b)) -- royal_screwup21 
08:36:24 <lambdabot> error:
08:36:24 <lambdabot>     • Couldn't match type ‘b1’ with ‘Maybe a1 -> a0’
08:36:24 <lambdabot>       ‘b1’ is a rigid type variable bound by
08:36:34 <kuribas> :t (fmap :: (a -> b) -> (Maybe a -> Maybe b)) -- royal_screwup21 
08:36:36 <lambdabot> (a -> b) -> Maybe a -> Maybe b
08:36:42 <codeshot> merijn, lol, yeah
08:36:44 <codeshot> probably that
08:36:50 <kuribas> ertes: right
08:36:51 <codeshot> ZipList is a pain in the arse without this
08:36:57 <merijn> codeshot: Why?
08:37:21 <codeshot> I have many lists which form a lattice
08:37:22 <kuribas> > fmap not (Just False) -- royal_screwup21 
08:37:25 <lambdabot>  Just True
08:37:43 <merijn> codeshot: and...?
08:37:47 <codeshot> and to use applicative with them to zip instead of making elements of a new lattice is nice
08:38:07 <kuribas> > fmap not Nothing -- royal_screwup21 
08:38:08 <codeshot> but then I have to return to list to cut bits of it out
08:38:08 <lambdabot>  Nothing
08:38:22 <merijn> I'm not sure what the need for "take" is?
08:38:52 <codeshot> To do things in the domain of users requirements instead of maths
08:39:02 <codeshot> we start in maths then we map to users
08:39:18 <codeshot> also to examine values without evaluating an infinite value
08:39:20 <merijn> codeshot: Anyway, with ZipList specifically you can just do "ZipList . take n . getZipList"
08:39:52 <ahri> ski: sorry, I had to rush out, though I've been considering the use of (.) in a section to make my brain read it correctly in the meantime. While I understand how to isolate `n' at the end of the expression, I find the jump to swapping around the params via a sectioned composition quite unreadable right now
08:40:06 <codeshot> merijn, yeah, but that's not the right way to solve such problems because then the technique to examine list-like structures is different depending on which list-like structure
08:41:05 <merijn> codeshot: take can't really be sensibly generalised for non-lists (and maybe sequences), though
08:41:19 <codeshot> I wonder if $> with a short list of unit is the right abstraction
08:45:25 <codeshot> almost, but ZipList isn't a Monoid :/
08:45:52 <codeshot> Was hoping it would have the same instances as [] but with applicative being a bit different
08:46:02 <quatomene> if I have a data Person = P Name Age Gender deriving Show, is there an easy way to access the value of Name / Age / Gender specifically?
08:46:17 <lyxia> quatomene: no
08:46:28 <EvanR> seems like you want a record
08:46:49 <quatomene> alright then I'll just write pattern match functions
08:47:17 <EvanR> projections for each field are what records give you automagically
08:47:25 <EvanR> or you can write them yourself
08:48:15 <dminuoso> Let's say I have some deeper nested list and want to component-wise add things, such as: zipWith (zipWith (zipWith (zipWith (<>))) a b, is there some pattern with functional composition to let me express this more appropriately?
08:49:32 <ertes> an existential without a constraint is operationally free, right?
08:49:44 <lyxia> ertes: yes
08:49:48 <ertes> thanks
08:50:04 <EvanR> operationally free ?
08:50:22 <dminuoso> Ohh wait, Im stupid. Nevermind my question.
08:53:17 <lyxia> EvanR: It costs nothing at run time
08:53:33 <EvanR> ah
08:53:36 <EvanR> free as in beer
08:55:00 <ertes> ok, i just got rid of the existential
08:56:02 <ertes> before:  data M a b = forall s. M ((a -> b) -> s -> s) (TVar s) (TVar Bool)
08:56:15 <ertes> after:  newtype M a b = M ((a -> b) -> STM ())
08:58:36 <ertes> i wonder if there is a type class for this kind of thing:  class C p where applyModifier :: ((a -> b) -> s -> t) -> p s t -> p a b
08:59:03 <ertes> or equivalently:  class C p where applyModifier :: ASetter s t a b -> p s t -> p a b
09:01:00 <sgraf812> Hey, anyone knows how to tell cabal to hide the transitive dependencies of the `ghc` package while building a project? `--ghc-options="-hide-package=containers"` doesn't work
09:04:09 <codeshot> what's the lambdabot command to find better ways to write an expression?
09:04:15 <codeshot> I recall seeing someone use that
09:04:30 <hpc> @pl \x y z -> x z x (y z x)
09:04:30 <lambdabot> ap ((.) . ap . join flip) (flip flip)
09:04:35 <hpc> fsvo better ;)
09:05:10 <codeshot> oh, I've already got pointfree
09:05:17 <codeshot> maybe I want djinn
09:05:29 <codeshot> :t maybe
09:05:30 <lambdabot> b -> (a -> b) -> Maybe a -> b
09:05:45 <EvanR> djinn produces implementations from type signatures
09:05:55 <hpc> @djinn b -> (a -> b) -> Maybe a -> b
09:05:55 <lambdabot> f a b c =
09:05:55 <lambdabot>     case c of
09:05:55 <lambdabot>     Nothing -> a
09:05:55 <lambdabot>     Just d -> b d
09:06:06 <codeshot> @djinn a -> Maybe a -> a
09:06:07 <lambdabot> f a b =
09:06:07 <lambdabot>     case b of
09:06:07 <lambdabot>     Nothing -> a
09:06:07 <lambdabot>     Just c -> c
09:06:12 <hpc> i don't know of any command that given an expression, will actually make it better for you
09:06:19 <ertes> codeshot: i don't think lambdabot has that…  hlint does, but keep in mind that it's highly opinionated by default
09:06:30 <codeshot> erg not sure what's best, that or (flip maybe id)
09:06:57 <codeshot> @pl (@djinn a -> Maybe a -> a)
09:06:57 <lambdabot> (line 1, column 3):
09:06:57 <lambdabot> unexpected '@'
09:06:57 <lambdabot> expecting expression
09:07:00 <codeshot> lol
09:07:06 <codeshot> too much to hope for
09:07:20 <hpc> @@ @pl @djinn a -> Maybe a -> a
09:07:20 <lambdabot>  (line 1, column 37):
09:07:20 <lambdabot> unexpected '>'
09:07:20 <lambdabot> expecting operator
09:07:29 <hpc> @@ pl djinn a -> Maybe a -> a
09:07:29 <lambdabot>  pl djinn a -> Maybe a -> a
09:07:31 <hpc> hmm
09:07:36 <hpc> i forget how to compose commands
09:07:53 <MarcelineVQ> :t fromMaybe
09:07:55 <lambdabot> a -> Maybe a -> a
09:08:14 <ertes> @. pl djinn a -> Maybe a -> a
09:08:14 <lambdabot> (line 3, column 15):
09:08:14 <lambdabot> unexpected '>'
09:08:14 <lambdabot> expecting operator
09:08:23 <codeshot> fromMaybe!
09:08:56 <ertes> but @. composes (String -> String) functions, so its utility is fairly limited
09:09:13 <ertes> @. djinn type fromMaybe
09:09:14 <lambdabot> f a b =
09:09:15 <lambdabot>     case b of
09:09:15 <lambdabot>     Nothing -> a
09:09:15 <lambdabot>     Just c -> c
09:10:18 <hpc> ertes: ah
09:11:17 <ertes> and djinn is more an exercise in automatic theorem proving than writing good code =)
09:11:25 <ertes> @djinn a -> b
09:11:25 <lambdabot> -- f cannot be realized.
09:12:49 <EvanR> true
09:27:59 <royal_screwup21> I'm trying to write a function takes in a list of Maybes, and output Nothing if there's a Nothing in the list, otherwise the list itself. https://thepasteb.in/p/mwh1lkwKNo5T5 the compiler throws this error: https://thepasteb.in/p/76hENn5xBM9UV what am I doing wrong?
09:29:08 <EvanR> the list itself without the Justs ?
09:29:25 <royal_screwup21> EvanR: with the Just
09:30:21 <exio4> royal_screwup21: you don't want to compare with ==
09:30:46 <EvanR> :t elem Nothing
09:30:48 <lambdabot> (Eq a, Foldable t) => t (Maybe a) -> Bool
09:30:55 <EvanR> should be useful
09:30:59 <exio4> royal_screwup21: use pattern matching 
09:31:54 <exio4> EvanR: if this is looking about a ready-to-use solution, `sequence` would be it :)
09:32:36 <ahihi> :t any (== Nothing)
09:32:38 <lambdabot> (Eq a, Foldable t) => t (Maybe a) -> Bool
09:32:39 <ahihi> :t any isNothing
09:32:41 <lambdabot> Foldable t => t (Maybe a) -> Bool
09:33:07 <EvanR> step 1, clone the thunk, step 2, search for Nothing. if found, return Just other thunk, otherwise return Nothing
09:33:37 <exio4> royal_screwup21: oh, btw, if you can use sequence, sequence is the function you're looking for
09:33:43 <exio4> > sequence [Just 3, Just 4]
09:33:46 <lambdabot>  Just [3,4]
09:33:48 <exio4> > sequence [Just 3, Nothing]
09:33:50 <lambdabot>  Nothing
09:33:54 <EvanR> yeah but
09:34:01 <royal_screwup21> oh
09:34:02 <EvanR> they want literally original list
09:34:10 <quatemene> say i have a list of (a, b,c ) - how can i sort by a, if that is equal sort by b and if that is equal sort by c?
09:34:11 <EvanR> for some reason
09:34:12 <exio4> royal_screwup21: if this is homework, I think you should avoid it 
09:34:18 <exio4> EvanR: what? 
09:34:23 <royal_screwup21> exio4 avoid using sequence?
09:34:38 <EvanR> exio4: "without the justs?" "with the justs"
09:34:47 <exio4> royal_screwup21: this is likely an exercise from some book/tutorial/etc, right? 
09:34:54 <royal_screwup21> yeah its from a book
09:35:11 <exio4> royal_screwup21: have you been taught about sequence and the likes already?
09:35:29 <royal_screwup21> nope I just looked it up
09:35:41 <exio4> royal_screwup21: ah, alright, which book/which chapters, etc?
09:36:11 <monochrom> quatemene: vanilla "sort" already does that.
09:36:18 <exio4> royal_screwup21: sequence is a library which is already doing what you want, so if you haven't been taught it, it's likely looking for you to implement it on your own
09:36:25 <royal_screwup21> alrighty
09:36:36 <EvanR> it doesnt do exactly what you said
09:36:47 <EvanR> but exactly what you said isnt well typed
09:36:47 <exio4> royal_screwup21: the problem of your code (ignoring the sequence), is that your type signature says mjusts should work for *any* [Maybe a]
09:37:16 <exio4> royal_screwup21: (== Nothing) adds an equality contraint, because (==) might also check the values inside the Just case
09:37:20 <exio4> > Just 3 == Just 4
09:37:22 <lambdabot>  False
09:37:23 <EvanR> sequence doesnt do exactly what you said
09:37:24 <monochrom> > sort [(1, 100, 200), (2, 10, 15), (2, 12, 5), (2, 12, 1)]
09:37:26 <lambdabot>  [(1,100,200),(2,10,15),(2,12,1),(2,12,5)]
09:37:43 <quatemene> i have [(a,b,c)], a is a string, b is a string and c is a number, sort works for that monochrom ?
09:38:28 <ahihi> quatemene: try it :)
09:38:31 <exio4> (sequence isn't a library, it is a function from a typeclass, I just re-read what I just wrote)
09:40:15 <monochrom> Yes too.
09:42:23 <EvanR> quatemene: bonus points for understanding why it works
09:44:57 <jim_> hello, again. so another question from the data61 course: http://lpaste.net/360148. I implemented the function (my solution), and then checked their solution (bottom in the aforementioned lpaste). I don't understand how their solution works at all. 
09:45:45 <jim_> could someone be kind enough to walk through it for a sec? namely, they're lifting fmap to be applied to (,) and readFile
09:46:32 <jim_> but (,) and readFile are functions are they functor instances (in the reader sense)? and how does that even work?
09:48:27 <ahihi> jim_: what is lift2? liftA2 with a different name?
09:49:38 <jim_> exactly
09:50:17 <ahihi> jim_: then it is using the Applicative instance for functions
09:51:56 <jim_> ahihi: do you mean this instance: http://lpaste.net/360149 ?
09:52:04 <ahihi> jim_: yep
09:52:50 <jim_> thanks, i still have to wrap my head around it somehow, although I understand most/all concepts involved.
09:54:05 <Milan[m]> huhu (just wanna remind my matrix server that it has some work to do on this room)
09:54:26 <ahihi> jim_: i would start by looking at the types for liftA2, (<$>) and (,), and seeing how they unify in `liftA2 (<$>) (,)`
09:55:00 <ahihi> jim_: but honestly i think this is highly unreadable code, even if i know how it works :P
09:55:33 <Milan[m]> cu :3
09:57:10 <dsal> jim_: I've had code evolve that way a few times.  It makes sense.
09:57:41 <ahihi> personally i would prefer something like: getFile path = (path,) <$> readFile path
09:58:06 <ahihi> no need to involve Applicative at all
09:58:43 <dsal> -XTupleSections
10:00:03 <ahihi> `(,) path` if you don't want the extension :P
10:03:35 <codeshot> remarkably, I can't find a standardised (a -> Bool) -> a -> Maybe a
10:04:46 <hpc> :t \p a -> guard (p a) *> pure a
10:04:47 <lambdabot> Alternative f => (b -> Bool) -> b -> f b
10:05:06 <hpc> :t ($>)
10:05:07 <lambdabot> error:
10:05:07 <lambdabot>     • Variable not in scope: $>
10:05:07 <lambdabot>     • Perhaps you meant one of these:
10:05:10 <hpc> hmm
10:05:13 <codeshot> ah, because I had Maybe in there hoogle doesn't help
10:05:24 <codeshot> I should have known that one
10:05:36 <codeshot> I still can't reliably draw these parallels
10:05:41 <hpc> you might be able to do better than that, but i don't know how off the top of my head
10:06:19 <hpc> although if you really just need it for Maybe, might as well write it out
10:07:10 <dsal> I don't like if in haskell for some reason.  It always feels awkward.
10:07:14 <royal_screwup21> exio4: just found out that when I remove the definition, the function works, like so: https://thepasteb.in/p/nZhlDr04x0VFY previously I had the definition :: [Maybe a] -> Maybe [a] and I got this error: https://thepasteb.in/p/76hENn5xBM9UV Not quite able to understand why the function when I don't pre-define it
10:07:40 <exio4> royal_screwup21: yes, it's about a constraint
10:07:40 <codeshot> hpc, if I write it out it provides too steep a learning curve for the beginning reader
10:07:47 <EvanR> if then else is like the only thing we have to attract people from other languages
10:07:54 <codeshot> guard is good - strange it's in Control.Monad and not Control.Applicative
10:08:01 <codeshot> and not prelude
10:08:17 <exio4> royal_screwup21: your definition is :: [Maybe a] -> Maybe [a] -- this implies it will work for *ANY* a
10:08:29 <EvanR> codeshot: a two case function definition seems more approachable
10:08:33 <hpc> Monad predates Applicative
10:09:03 <hpc> sorting out the historical warts from that is in progress
10:09:26 <exio4> royal_screwup21: when you use (== Nothing) you are saying it will require an *additional* contraint on a
10:09:34 <hpc> though the big one of having "class Applicative f => Monad f where ..." is done
10:10:05 <royal_screwup21> exio4: oh okay
10:10:37 <royal_screwup21> exio4: the additional constraint being that a has to be of datatype Maybe?
10:10:53 <exio4> royal_screwup21: nop, that you must support equality on a 
10:11:03 <exio4> > id == (+1) 
10:11:06 <lambdabot>  error:
10:11:08 <lambdabot>      • No instance for (Eq (Integer -> Integer))
10:11:12 <lambdabot>          arising from a use of ‘==’
10:11:55 <royal_screwup21> -> Just 5 == Nothing
10:12:02 <royal_screwup21> > Just 5 == Nothing
10:12:05 <lambdabot>  False
10:12:09 <exio4> > Just id == Nothing
10:12:11 <lambdabot>  error:
10:12:11 <lambdabot>      • No instance for (Eq (a0 -> a0)) arising from a use of ‘==’
10:12:11 <lambdabot>          (maybe you haven't applied a function to enough arguments?)
10:12:17 <lavalike> :t (. return) . find
10:12:19 <lambdabot> (a -> Bool) -> a -> Maybe a
10:13:33 <exio4> royal_screwup21: you are supposed to use pattern matching
10:15:21 <codeshot> EvanR, no, because then the source file isn't neatly tabular
10:15:51 <codeshot> That's a big obstacle because visual comparison of elements doesn't immediately reveal their relative roles
10:16:05 <Forgetaboutit> hey guys, I have a problem installing PostgreSQL.Simple via Stack.  It's failing in the linking phase with an error: http://lpaste.net/360150
10:16:12 <Forgetaboutit> What am I supposed to do with this?
10:16:17 <codeshot> so ore must be learned before the reader can intuitively reason about the program
10:17:31 <MarcelineVQ> Forgetaboutit: archlinux?
10:18:03 <Forgetaboutit> MarcelineVQ: yes
10:18:21 <MarcelineVQ> add   ghc-build: nopie  to ~/.stack/config.yaml   and if that's not enough, install   ncurses5-compat-libs  from the AUR
10:19:01 <EvanR> codeshot: what i was talking about probably means learning very little above base
10:19:14 <Forgetaboutit> MarcelineVQ: Will do, thank you!
10:19:50 <EvanR> if you cant write a basic function definition by cases, rather than pointfree tricks with funny classes, ...
10:20:20 <codeshot> yeah, but that means clarity of intention is learned after control flow
10:20:23 <MarcelineVQ> hpc, lavalike:  ​somehting about   liftA2 (bool empty) pure  is kind of pleasing
10:20:34 <codeshot> so the user's get stuck thinking it's all about the small scale
10:20:35 <Forgetaboutit> MarcelineVQ: Any pointers on what that does?  I'm not getting it from the Stack wiki page
10:20:35 <EvanR> control flow O_o
10:20:57 <lavalike> (:
10:21:01 <codeshot> I'll define this for them and explain it by examples instead of logic: let points = (guard .)
10:21:15 <Welkin> has anyone created an html book using hakyll?
10:21:17 <EvanR> :(
10:21:20 <codeshot> EvanR, yeah
10:21:36 <Forgetaboutit> MarcelineVQ: Nvm, I found it =)
10:21:36 <EvanR> if this is an advanced haskell course, makes sense
10:21:40 <EvanR> "stupid haskell tricks"
10:21:51 <codeshot> no, people just mostly learn the wrong stuff first.
10:22:02 <MarcelineVQ> Forgetaboutit: Oh good, I wasn't sure what to say because it involves things distros are doing now with gcc settings mostly. where did you find it?
10:22:28 <codeshot> case analysis is subordinate to stating the problem well and the general form of the solution
10:22:30 <EvanR> (guard .) . foo, cant be right the thing first
10:22:38 <codeshot> I won't teach that
10:22:42 <Forgetaboutit> MarcelineVQ: https://stackoverflow.com/questions/2463150/fpie-position-independent-executable-option-gcc-ld
10:22:58 <codeshot> I'll give it a neat name and treat it like part of the standard library
10:23:01 <Welkin> better teach the blackbird then
10:23:05 <EvanR> i can imagine frustrated people years later being like
10:23:05 <Forgetaboutit> MarcelineVQ: It's probably for security reasons because it relates to ASLR somehow
10:23:12 <EvanR> why did codeshot not just explain this
10:23:17 <codeshot> if people looked at the definition of everything in the Prelude you'd have to say that the whole Prelude wasn't for newbies
10:23:18 <EvanR> foo p x | p x       = Just x
10:23:22 <EvanR>         | otherwise = Nothing
10:23:42 <codeshot> so that logic is easily demonstrated to be totally false
10:23:46 <Welkin> codeshot: are you writing a guide or course on something in particular?
10:24:10 <codeshot> succinct examples where code describes it's intention before its mechanism
10:24:12 <EvanR> ghc implementation probably isnt good for learning haskell 
10:24:38 <codeshot> yet, we can learn with the functions predefined in the prelude
10:24:43 <codeshot> it's just that one is missing
10:24:52 <codeshot> what's the problem with defining it?
10:25:23 <codeshot> let points = (guard .)
10:25:43 <EvanR> points?
10:25:50 <Welkin> a point guard
10:25:54 <Welkin> basketball
10:27:03 <codeshot> let points = (guard .) -- don't worry about this, just know that points (== 4) <$> ziplistofjusts selects the points that we care about
10:27:13 <codeshot> this maps from matlab concepts very directly
10:27:27 <Forgetaboutit> MarcelineVQ: Okay, `nopie` by itself didn't help.  Trying to get `libtinfo` somehow
10:27:40 <Welkin> no one uses matlab expect first-year engineering students and phd students
10:27:41 <Welkin> o.o
10:27:44 <Welkin> except*
10:27:57 <MarcelineVQ> Forgetaboutit: if nopie isn't enough you want  ncurses5-compat-libs  specifically, from the AURE
10:27:58 <MarcelineVQ> *AUR
10:27:59 <EvanR> if anything is signalling intent, the name you gave (guard .) is not doing it
10:28:14 <codeshot> that's because everyone is being taught to do loops
10:28:17 <Welkin> what is wrong with `|` ?
10:28:22 <codeshot> instead of first stating which loop they'd like
10:28:34 <EvanR> who is taught to do loops?
10:28:41 <codeshot> oh nevermind
10:28:43 <Welkin> fruity loops?
10:29:33 <codeshot> I'd write another tutorial on case analysis but there's already a lot and they don't really help, why would the same approach help if I wrote it?
10:29:37 <Welkin> has anyone used hakyll to generate a book?
10:29:45 <monochrom> Time loops like an arrow. Fruit loops like a banana.
10:30:07 <cocreature> Welkin: a web version of a book?
10:30:15 <Welkin> I'm curious if there is already some code I can steal, but I know I can write it myself
10:30:18 <Welkin> yes
10:30:32 <MarcelineVQ> Forgetaboutit: don't forget to run  stack setup  after doing these things, in case it needs to update its ghc settings
10:30:33 <Welkin> with a proper table of contents and everything
10:30:35 <cocreature> no idea, sry
10:34:28 <Forgetaboutit> MarcelineVQ: Gotcha, installing ncurses5-compat-libs right now.  Pacman blew up when detecting an untrusted key but I'm good now
10:38:10 <bartholin> Hello, is this the place to complain about packages failing to install?
10:38:31 <MarcelineVQ> sometimes, but it's better for asking how to install them without failure
10:38:45 <bartholin> Ok.
10:38:58 <bartholin> I cannot install the math-functions package. http://lpaste.net/360152
10:40:08 <bartholin> I have ghc 8.0.2 and cabal-install 1.24.0.2
10:40:22 <bartholin> on fedora
10:40:56 <Forgetaboutit> MarcelineVQ: Got it to build!  Your help is much appreciated.
10:41:44 <MarcelineVQ> Forgetaboutit: np, arch has been a real trial lately so I'm glad to be able to make it easier for people
10:42:07 <bartholin> but somehow I have the exact same versions on ArchLinux (my other computer), and it installs without any problem.
10:42:31 <bartholin> But I can't find the problem on my Fedora.
10:47:14 <MarcelineVQ> bartholin: strange issue, just built it here and it went fine, which isn't helpful information I know. what version of vector-th-unbox do you have?
10:48:44 <EvanR> what is this notation... '(s,t)
10:48:55 <EvanR> DataKinds? 
10:48:56 <MarcelineVQ> bartholin: oop nvm I see it there in the log
10:49:03 <MarcelineVQ> EvanR: most likely
10:49:11 <EvanR> but... "type level tuple" ?
10:49:23 <maerwald> is there a definite example of a problem with tabs in haskell, such as that stuff suddenly doesn't compile elsewhere?
10:50:04 <bartholin> bartavelle: vector-th-unbox version 0.2.1.6
10:51:37 <bartholin> oop I meant to ping MarcelineVQ 
10:56:48 <bartholin> If I want to reinitialize everything cabal related, do I just have to erase the .cabal folder?
10:56:54 <qqwy> Hello everyone!
10:57:09 <qqwy> A while back someone linked me to an amazing resource on learning more about advanced Haskell techniques.
10:57:27 <qqwy> Unfortunately I do not remember what it was called, and I have been unable to find it again thus far
10:57:51 <qqwy> IIRC it was named something akin 'the guide I wished I had when I started out'
10:58:23 <qqwy> and it was one very long page containing tons of information about all the different Monad implementations that Haskell's included packages have,
10:58:24 <bartholin> http://dev.stephendiehl.com/hask/ qqwy?
10:58:37 <qqwy> as well as a treatise on how to speed up code by using the appropriate text library
10:58:52 <qqwy> Yes!
10:58:54 <qqwy> Exactly that one :D
10:59:45 <qqwy> Thank you very much! <3
11:04:06 <hexagoxel> maerwald: i am pretty certain the compiler always interprets tabs the same way. the problem is more how the semantics can change (or break) when replacing each tab with n spaces.
11:05:50 <limitbreak> Hi all! I'm trying to run lambdabot offline but I always get "mueval: ExitFailure 1" for everything I try to evaluate
11:31:32 <amx> is there a working solution to have cabal watch a source dir and recompile/run on every change?
11:32:14 <fakenullie> what's the point of recompiling on every change?
11:32:27 <fakenullie> oh, run
11:32:43 <ebw_> Hi there, all of a sudden I get errors when using stack build: /usr/bin/ar: /usr/lib/libLLVM-5.0.so: undefined symbol: _ZN4llvm15ExecutionEngine16getConstantValueE ... . I can't find this on google or SO, could someone please explain to me, what's wrong with my install?
11:33:17 <Tuplanolla> Does `ghcid` suit your needs, amx?
11:35:18 <amx> Tuplanolla: I'll take a look, thanks!
11:41:22 <pierrot> Hi. I'm asked the following: Let's `M' be a monad, `A' some type and `g1', `g2', `g3' of type `M A`. Then, I have the following definitions for `h1', `h2' and `h3' : https://glot.io/snippets/evnb2ibs0i
11:41:40 <pierrot> Which ones are equivalent?
11:41:58 <g2> :)
11:42:01 <pierrot> For those that aren't equivalent, I need to find a counterexample
11:43:18 <pierrot> My impression is that all of them are equivalent...
11:44:05 <liste> pierrot: they're not
11:44:56 <liste> pierrot: counterexample: g2 is None
11:45:01 <liste> Nothing*
11:45:44 <Welkin> the clown i back
11:45:46 <Welkin> is
11:46:22 <Welkin> pierrot: is this some kind of homework question?
11:47:44 <pierrot> Welkin: Yes, it's for an exercise. liste: thanks, I see it
11:47:53 <Welkin> an exercise from what?
11:48:05 <pierrot> for school
11:48:14 <Welkin> I see
11:48:34 <Welkin> that must be why it looks so terrible
11:49:06 <EvanR> its a beautiful day today
11:49:28 <pierrot> theoretical exercises always look terrible
11:55:18 <pierrot> Is h1 equivalent to h2? They're not equivalent to h3 because of liste's counterexample...
11:56:59 <dminuoso> pierrot: look at the return, you tell me.
11:57:29 <dminuoso> pierrot: Or better yet, just write some specific code lets say using the list monad. Should become obvious.
12:04:31 <laserpants> Why is the type of `deleteBy` in Data.List (a -> a -> Bool) -> a -> [a] -> [a], as opposed to (b -> a -> Bool) -> b -> [a] -> [a]?
12:04:48 <monochrom> h1 and h2 are equivalent. Use some monad laws to prove.
12:04:53 <bartholin> Is there a way to evaluate a .hs file step by step through emacs?
12:05:10 <dminuoso> :t deleteBy
12:05:11 <lambdabot> (a -> a -> Bool) -> a -> [a] -> [a]
12:05:17 <monochrom> h3 can be equivalent or not, depending on actual M.
12:05:53 <Welkin> I have never seen or used `deleteBy`
12:05:58 <Welkin> how is it different than `filter`?
12:06:10 <EvanR> @src deleteBy
12:06:10 <lambdabot> deleteBy eq x []     = []
12:06:10 <lambdabot> deleteBy eq x (y:ys) = if x `eq` y then ys else y : deleteBy eq x ys
12:06:30 <Welkin> okay
12:06:36 <Welkin> it removes only the first occurrence
12:06:40 <dminuoso> monochrom: Oh wow. I cant read code :(
12:07:09 <laserpants> I am thinking maybe it is to make it consistent with the rest of the API.
12:07:22 <Welkin> laserpants: it has that type because lists are homogeneous
12:07:34 <pierrot> monochrom: "equivalent" in this context means "equivalent for all monad `M'" so if the equality doesn't hold for a specific monad, the the response is negative.
12:08:33 <Welkin> the predicate must compare two value of the same type, thereforce, they must both be `a`
12:08:43 <Welkin> therefore*
12:08:48 <MarcelineVQ> he's asking why the predicate must compare two values of the same type.
12:08:52 <laserpants> Welkin: I don't get it. The compiler-derived type is (t -> a -> Bool) -> t -> [a] -> [a]
12:09:06 <monochrom> https://wiki.haskell.org/Monad_laws is your friend. There is a version that uses do-notation.
12:09:16 <Welkin> because you are comparing two values from the list, and all values in the list must have the same type
12:09:43 <MarcelineVQ> no you're comparing the values of a list with a seperate value
12:09:46 <Welkin> sorry
12:09:58 <Welkin> that is what I meant
12:10:09 * EvanR attempts "there is no good reason"
12:10:45 <Welkin> okay
12:10:45 <MarcelineVQ> There is no good reason is a reasonable explanation
12:10:46 <pierrot> monochrom and liste : thanks 🙂
12:10:47 <Welkin> now I see what you mean
12:11:00 <Welkin> it could make sense to have an `a` and a `b`
12:11:22 <Welkin> like I said, I have never seen or used that function before
12:11:33 <laserpants> deleteFirstsBy is defined in terms of deleteBy, and in that case it makes a lot of sense
12:11:35 <Welkin> I stick with the basics and if I need to do something more complex, I write my own function
12:12:06 <laserpants> but yeah, I can easily define my own version, of course.
12:12:15 <Welkin> also
12:12:19 <Welkin> I hardly ever use lists
12:12:36 <Welkin> when you write real programs you will almost never use lists as data structures
12:12:58 <Welkin> but instead as control structures where you process each element of the list in order
12:13:06 <EvanR> that function doesn't necessarily use list as a data structure
12:13:36 <EvanR> its like a limited filter
12:46:57 <EvanR> there is one function field in this huge record... throw me a bone here and derive Show anyway
12:48:45 <Welkin> define Show for that one function
12:49:01 <EvanR> i was about to define Show for all functions
12:49:05 <Welkin> that too
12:49:23 <Welkin> Show is really only useful for debugging anyway
12:49:58 <EvanR> well, i will probably need to do pretty printing for debugging 
12:50:05 <EvanR> at some point
12:50:09 <Welkin> too much work
12:50:19 <Welkin> unless there is a typeclass for that
12:50:25 <EvanR> unreadable Shown records are unreadable
12:51:06 <EvanR> i am all about records right now
12:51:41 <Welkin> I just finished writing the first draft of lesson 1 of my tutorial, which covers data types and record syntax
12:52:25 <EvanR> can i have a tutorial for a language whose records suck less
12:52:46 <Rembane> EvanR: Purescript?
12:52:51 <EvanR> maybe
12:53:14 <Welkin> but then you will have a Show problem far worse than in haskell
12:53:15 <Rembane> I'm becoming more and more friend with the Haskell records. But I need all language extensions to make the records good.
12:53:22 <Rembane> Indeed.
12:53:33 <Welkin> haskell records are okay
12:53:37 <Welkin> people complain about them a lot
12:53:37 <EvanR> :(
12:53:39 <Welkin> but they work
12:53:46 <Welkin> if you need more power, use lens
12:54:09 <EvanR> i dont need more power, i need less carpal tunnel syndrome or metaprogramming
12:54:09 <Rembane> DuplicateRecordFields is the language extension that made records good for me.
12:54:12 <Tuplanolla> This `Show` problem of programming languages reminds me of the equality problem of foundational mathematics.
12:54:31 <Rembane> What is the Show problem btw?
12:54:42 <EvanR> i dont see a show problem with advanced records
12:55:05 <Tuplanolla> Whether we should be able to print things that were once expressed as text, Rembane.
12:55:24 <Tuplanolla> When, more precisely.
12:55:25 <Welkin> you need to define a generic instance before you can define a show instance, and then all of your constructors have the module name prefixed to them
12:55:46 <Welkin> Main.A, Main.B
12:56:21 <EvanR> the problem i was just having has nothing to do with fundamental conceptual problems, but the practical fact of the matter that despite functions in haskell having literally no good way to "show", i still want to be able to debug a record containing one
12:56:32 <Rembane> Tuplanolla: Print as in give a human readable representation or as in read show = id?
12:56:44 <Welkin> the easiest solution seems to be defining Show for functions
12:56:54 <Rembane> +1
12:57:00 <Tuplanolla> Being able to produce representations in the first place, Rembane.
12:57:05 <EvanR> idris went another direction and said, of course there is a way to show functions... but its not readable
12:57:05 <monochrom> Show is just for the show. <duck>
12:57:18 <Rembane> Tuplanolla: Oh. Any representation at all?
12:57:26 <Welkin> just make all functions `show` as "Function"
12:57:41 <Tuplanolla> Hopefully something useful, Rembane.
12:57:46 <EvanR> heh
12:57:48 <Rembane> Tuplanolla: Cool.
12:57:56 <EvanR> > ord
12:57:56 <Tuplanolla> Not just `show _ = "Thing"`.
12:57:58 <lambdabot>  <Char -> Int>
12:58:04 <EvanR> \o/
12:58:14 <Rembane> :D
12:58:22 <Rembane> > over
12:58:24 <lambdabot>  error:
12:58:24 <lambdabot>      • No instance for (Typeable a0)
12:58:24 <lambdabot>          arising from a use of ‘show_M495247005508369809331457’
12:58:29 <Rembane> :D
12:58:31 <hydraz> of course
12:58:34 <Welkin> what does lambdabot use for that?
13:02:00 <Gurkenglas> Well, the obvious compiler-side way to give functions Show would be to carry the source code string around at runtime. It would break read.show=show.read=id if implemented faithfully, break our extensional equality, and change on each new version of anything.
13:03:04 <EvanR> thats not obvious to me
13:03:24 <EvanR> and neither is idris dumping its core type theory of the functions compiled representation
13:03:45 <hydraz> isn't that just in the REPL?
13:03:51 <Tuplanolla> I think definitions as black boxes is an excessively strong abstraction, but I don't know how exactly.
13:04:11 <EvanR> thats what were talking about
13:04:30 <hydraz> then I think it's perfectly reasonable
13:04:45 <EvanR> its not help as a generic debugging feature
13:04:47 <EvanR> helpful
13:04:57 <EvanR> if that function were in a huge record, you couldnt read anything
13:05:27 <hydraz> well, let's just disagree on that. I think that prettily showing the expression, and indeed, how application specialises things, is pretty useful
13:05:47 <EvanR> i dont think we are talking about the same thing
13:05:48 <Welkin> you can just ask for the type in ghci
13:06:03 <Welkin> it doesn't need to be part of the shown string
13:06:09 <Gurkenglas> Are you glad it isn't obvious to you? What is the "that" you say we are talking about?
13:06:16 <EvanR> autoformatted lambda calculus with fully expanded qualified namespacing
13:06:22 <Welkin> everything else is a value in the string
13:06:40 <hydraz> EvanR: yes, we are
13:06:57 <EvanR> with no clear relationship to the original expression that produced the function
13:07:21 <EvanR> its cool and all but not solving my issue
13:07:39 <Tuplanolla> What would it entail to have a language where comparison of definitions is decidable regardless of domain size?
13:08:06 <EvanR> how would that help
13:10:28 <Gurkenglas> You want show show = "show", show ((\x y -> x + y)) = "((\x y -> x + y))", etc., right?
13:10:40 <EvanR> if you consider functions codata, then that might make you feel better about no being able to "see it" ... all
13:10:48 <Tuplanolla> I feel like that would allow finding some sort of canonical form to show, EvanR.
13:11:09 <Welkin> lol, codata
13:11:23 <EvanR> no, i dont want to see the function, just everything else in the huge record. so ill do Welkin's trick
13:11:34 <Welkin> everyt itme someone talks about co-anything I imagine a backwards mirror-world
13:11:43 <Welkin> where we have CoMaybe and CoInt and CoBool
13:12:12 <[exa]> Welkin: in that world we are the co-wierdos
13:12:48 <thething_911> hello everyone :)
13:13:06 <Gurkenglas> I never know which arrows to turn around to construct the dual of something. Would you do CoMaybe = CoEither () = ((),) or some other level at which to resolve the Co?
13:16:04 <Gurkenglas> Sounds like there being no Show instance for functions isn't the problem, but (a, b) needing a show instance for both sides.
13:16:41 <Gurkenglas> Shouldn't Data automatically give us a Show instance?
13:16:44 <thething_911> if anyone would be willing to help? I'm really new with Haskell. I've been trucking pretty well, but, I've hit an error that I'd really like to solve, but I'm really not sure why, much appreciated if you could help me see where I'm falling flat, thanks  :)  http://lpaste.net/360154
13:17:13 <EvanR> (3, *nothing to see here*)
13:17:32 <EvanR> (3, *you aren't ready for this show instance*)
13:17:47 <EvanR> this space intentionally left blank
13:18:00 <EvanR> unicode square symbol
13:18:20 <Gurkenglas> thething_911, it expected to see a "then" before that "else"
13:18:37 <Welkin> as long as you add -XRankNTypes, `instance forall a b. Show ((->) a b) where show _ = "Function"`
13:19:32 <thething_911> omfg, thank you so very much xD, I have an example literally before my eyes, and I just couldn't see the obvious, thank you very much :)
13:19:32 <EvanR> didnt need it
13:19:38 <Gurkenglas> Would that only allow you to show functions (forall a b. a -> b), aka (\_ -> undefined)?
13:20:00 <Welkin> Gurkenglas: no
13:20:10 <EvanR> instance Show (a -> b) where show _ = "(λ)"
13:20:22 <Welkin> okay, I guess you don't need the RankNTypes
13:20:34 <Gurkenglas> thething_911, next time I recommend you make the code simpler until the program goes away, then go backwards until it comes back, and repeat until you see the exact change that is responsible
13:20:34 <Welkin> as long as you remove the forall
13:20:43 <Welkin> but it still works the same way regardless
13:20:50 <Tuplanolla> We have `Text.Show.Functions` in `base` by the way.
13:21:35 <EvanR> nifty
13:21:57 <thething_911> Gurkenglas: it was only that I really liked the solution xD, I will remember that, just really sensed it was something simple slipping my seeing it
13:29:25 <thething_911> Gurkenglas: I went ahead and unwound it in to two arrays of bools then a comparison, followed by a sum, much nicer now, thanks :), take care
13:45:40 <ddellacosta> so I'm as a relative newbie to parsing I'm trying to learn how to use megaparsec by building a simple CSV parser. As part of that I figured I'd also try using Data.Text vs. relying on String everywhere. However, it seems like it's impossible to actually avoid intermediate representations in my parsers with [Char]/String. As a result I have Data.Text.pack sprinkled throughout, and this strikes me as rather def
13:45:40 <ddellacosta> eating the point of using Data.Text in the first place. Am I doing something wrong, or am I overthinking this?
13:45:58 <ddellacosta> * so as a
13:46:26 <koz_> While we're on the subject, what's the difference between parsec, attoparsec and megaparsec?
13:47:17 <ddellacosta> koz_ my hot take is: attoparsec is better for dealing with binary data, parsec is the original but currently less maintained, megaparsec is a fork of parsec that has moved past it
13:47:21 <merijn> koz_: parsec = original, old, only bare minimum maintenance, used for parsing "human input" (think source files for programming languages) and give helpful parse errors, at the cost of being slower/taking more memory
13:47:57 <EvanR> ddellacosta: one thing that can help is stuff like "abcd" can stand for Text if you enable OverloadedStrings
13:48:02 <ddellacosta> the megaparsec README has a pretty good set of comparisons actually: https://github.com/mrkkrp/megaparsec#comparison-with-other-solutions
13:48:16 <merijn> koz_: attoparsec = newer, speed at all cost, lousy error reporting, sane support for working with binary data, designed for parsing "machine only" input where you just want success/fail reporting and speed
13:48:22 <ddellacosta> EvanR: yeah I have OverloadedStrings in there already, I should have mentioned
13:48:39 <ddellacosta> so at least I don't suffer from string literals and whatnot being String/[Char]
13:48:40 <EvanR> what kind of things are requiring String 
13:48:43 <merijn> koz_: Megaparsec = fork of parsec, updated to be compatible with modern Haskell (parsec predates Applicative!) and actively maintained
13:49:08 <merijn> koz_: And like parsec aimed at parsing "human readable" source
13:49:21 <ddellacosta> EvanR: well, for example I've run into exactly this same problem, handily I can point to this stackoverflow link: https://stackoverflow.com/questions/44681410/megaparsec-how-to-declare-the-type-of-eol-to-parse-text-and-not-char
13:49:50 <ddellacosta> that's just one place, another example is: T.pack <$> many (notChar ',')
13:49:58 <ddellacosta> (T is Data.Text if that wasn't obvious)
13:50:00 <merijn> koz_: i.e. if your problem is "I have 10 million records in a huge custom binary file" -> probably use attoparsec. "I have a several thousand line max human written source file" -> probably megaparsec
13:50:11 <geekosaur> ddellacosta, there's a bit of a conflict if you don't work in terms of higher level things as much as possible: if you, for example, collect characters with a Text string type, you still get a list of characters. or something like anyOf, which uses a list as a set so it's going to be [Char] regardless (and the real fix for that is it should use Set Char)
13:50:13 <koz_> merijn: OK, thank you, that's very helpful.
13:50:24 <merijn> ddellacosta: New megaparsec version should have "blitting" operators like attoparsec for that
13:51:10 <geekosaur> ...although if you then turn on OverloadedLists then you're back to [Char] again and with a potential type conflict on top >.>
13:51:13 <merijn> ddellacosta: See takeWhileP
13:51:17 <geekosaur> reality insists on being messy and complex
13:51:38 <EvanR> ddellacosta: its ok to use [Char] in some cases, if you can hide it in lower level functions, and you are using it lazily
13:51:39 <ddellacosta> geekosaur: yeah that's what I was looking for--I was wondering for example if I needed to use Text.Megaparsec.Byte(.Lexer) or something at one point, but that seemed of
13:51:45 <koz_> geekosaur: We should stuff reality into a monad.
13:51:46 <ddellacosta> merijn: thanks for those suggestions, very helpful
13:51:53 <EvanR> as part of a larger plan to use Text as the currency of strings
13:51:56 <ddellacosta> seemed off*
13:52:09 <geekosaur> koz, 'reality binds you'
13:52:17 <koz_> geekosaur: Only in Soviet Russia.
13:52:21 <EvanR> building a piece of text char-by-char is inherently a [Char] and pack situation, too
13:52:28 <merijn> ddellacosta: There was a blogpost on this, lemme try and find it
13:52:39 <ddellacosta> EvanR: yeah, I guess I was also curious about that too--I just wasn't sure if it was expected that you'd do some coercing here and there, or if there were other options (like the Set Char thing geekosaur mentioned above)
13:52:40 <merijn> ddellacosta: I think is the one: https://markkarpov.com/post/megaparsec-more-speed-more-power.html
13:52:51 <ddellacosta> merijn: great, thanks
13:53:06 <EvanR> if theres a very large number of chars to check against... yeah Set would be good
13:53:28 <merijn> ddellacosta: The idea is "instead of building a Text from individual chars, just find how many chars match and copy them into a new Text in one go", so should be way more efficient too
13:53:29 <ddellacosta> right, so makes sense, it's about considering how much you end up coercing I suppose and what the performance/space costs are
13:53:31 <EvanR> or a bloom filter?
13:53:37 <ddellacosta> merijn: gotcha
13:54:02 <EvanR> when you dont care about performance (and sometimes when you do) you can often get away with doing all the conversions in your low level combinators
13:54:12 <merijn> ddellacosta: So in that sense "T.pack <$> parser" is a code smell anyway. Although likely unnoticable for, say, human inputs (i.e. a few kb at most)
13:54:15 <ddellacosta> yeah, makes sense upon consideration
13:54:38 <EvanR> not sure why `eol' doesnt have a text version already though
13:54:46 <ddellacosta> merijn: right
13:54:53 <merijn> koz_: Basically, I would say megaparsec completely obsoletes parsec, except for backwards compatibility/portability considerations, whereas attoparsec tries to do something completely different
13:55:07 <ddellacosta> EvanR: I know I was wondering that too, I'm sure there's a lot of stuff like that in there still though
13:55:23 <EvanR> if it did, it would look like T.pack <$> eol
13:55:44 <EvanR> but out of sight
13:55:57 <ddellacosta> ha, so, "don't look behind the curtain?" :-D
13:56:14 <EvanR> because it will be so uninteresting? :)
13:56:27 <merijn> EvanR: That's when I do "import Foo hiding (eol); import qualified Foo; "eol = T.pack <$> Foo.eol" and be done with it :)
13:56:35 <EvanR> yes
13:56:50 <ddellacosta> ha
13:57:08 <EvanR> perform the manual completion of the lib
13:57:12 <ddellacosta> well thanks all, this was super helpful. Much appreciated
14:00:10 <merijn> ddellacosta: Well, it was be helpful or work on my own disaster C++ code, so... :p
14:00:24 <ddellacosta> merijn: haha, I feel your pain...
14:02:37 <merijn> Only got myself to blame. 4 years ago I was too worried about GC pauses messing up my benchmarks to use Haskell, now I gotta live with the consequences >.
14:07:51 <Welkin> o.o
14:08:01 <Welkin> merijn: should have talked to Cale about that
14:08:05 <EvanR> write the actual program in haskell, write the benchmarks in C++
14:08:11 <Welkin> he used a method to smooth over large GC pauses
14:08:23 <merijn> EvanR: The benchmark IS the program
14:08:27 <EvanR> haha
14:08:30 <Welkin> also, who cares about benchmarks
14:08:31 <Welkin> lol
14:08:31 <merijn> EvanR: There is nothing else
14:08:44 <merijn> Welkin: People who get paid to do research about making shit faster? :)
14:09:08 <EvanR> the key to quick GC is to not use memory!
14:09:19 <Welkin> the key is to write everything in binary!
14:09:34 <EvanR> or rot13
14:10:17 <Welkin> https://ro-che.info/ccc/25
14:11:32 <EvanR> the comic is literally right
14:11:44 <Welkin> the comics are always right
14:14:45 <Welkin> there hasn't been a new comic since july 2015
14:14:49 <Welkin> what happened?
14:18:19 <merijn> Welkin: Work, probably?
14:18:32 <merijn> Welkin: Or deciding there were more fun activities to do in your free time
14:32:28 <merijn> Actually, maybe you don't even have to modify the code, just the vector type and how you allocate it :)
14:34:04 <merijn> mmm, maybe not
14:34:12 <geekosaur> there's also deciding that you don;t have enough good material. you don;t necessarily want to run it into the ground
14:34:25 <geekosaur> cf. Dilbert or UF
14:36:30 <Cale> Welkin: Well, it wasn't me who did that work specifically. Stephen Blackheath I think was responsible for that code. Basically all it was though was a very small C++ program that would follow the graphics instructions from the Haskell code, and forward user input along.
14:37:30 <merijn> Cale: That wouldn't work for me anyway, since the goal would be too have Haskell wrap C++ calls so they were less painful
14:38:24 <Cale> Right, in our case, most of the code was written in Haskell
14:38:34 <EvanR> having trouble understanding in what circumstances that will help gc latency
14:38:53 <merijn> EvanR: It means the C++ code can run the graphics loop without being blocked during GC
14:39:04 <Cale> EvanR: The idea is that the C++ code could continue playing through animations and such while the Haskell code GCed.
14:39:11 <EvanR> but during gc you still dont get the graphics instructions
14:39:15 <merijn> EvanR: It might be running with a slightly out-of-date state (due to haskell updates not having been done)
14:39:26 <merijn> EvanR: Rendering old graphics is better than no graphics
14:39:39 <EvanR> if the picture freezes... isnt that the same
14:40:01 <Cale> So on a 2009-era iPhone, you have a 300ms input delay every 5 minutes... not ideal, but tolerable.
14:40:04 <merijn> EvanR: The picture won't freeze long enough
14:40:19 <merijn> EvanR: You notice visual stutter way sooner than you notice input latency
14:40:27 <merijn> EvanR: And the GC pause most likely won't be that long
14:40:34 <EvanR> how will input respond during gc ?
14:40:47 <EvanR> or am i not understanding the full responsibilities of this C++ wrapper
14:41:02 <Cale> The picture won't freeze, since all the animations keep playing (and actually, the polynomials describing the motions of objects will continue to be evaluated)
14:41:08 <EvanR> it has some enginey aspect to it that allows it to continue without communication with haskell?
14:41:22 <EvanR> ok
14:41:38 <geekosaur> separate process, sounds like
14:41:52 <EvanR> separate process, and an independent animation engine
14:42:07 <EvanR> and event handler?
14:42:16 <Cale> It was the same process, but that doesn't really matter.
14:42:25 <EvanR> so like, your mouse will still control the camera during gc
14:42:26 <Cale> Separate thread, I suppose.
14:42:33 <merijn> Cale: C++ thread is not affected by Haskell threads being blocked
14:42:36 <merijn> eh
14:42:42 <merijn> s/Cale/EvanR
14:43:12 <EvanR> so this trick would have worked without C++ if we could have two GC worlds
14:43:16 <Cale> EvanR: But yeah, it's basically a tiny C++ program which would handle the very top level I/O
14:43:46 <merijn> EvanR: Yes
14:43:50 <Cale> EvanR: Well, maybe? The thing is, the C++ code never has to stop to GC.
14:44:16 <EvanR> you could arrange for one of the worlds to use very little gc-intensive memory
14:44:28 <Cale> Yeah, that's possible
14:44:38 <EvanR> but as it is, everything is in the same world
14:44:50 <EvanR> so youre stuck reducing memory usage of everything ever
14:44:53 <Cale> Also, to be clear, this solution really only turned out to be necessary for 2009-era iPhones
14:45:13 <Cale> On desktop, GC wasn't such a big deal.
14:45:18 <EvanR> yes that sounds ancient, but i have no grasp of how things have progressed since then
14:45:44 <EvanR> im about to wrestle with this issue on a 2017-era raspberry pi
14:45:51 <Unode> hi all, is GHC memory allocation tiered?
14:46:07 <Cale> Unode: Tiered in what sense?
14:46:14 <Cale> It's multi-generational
14:46:57 <Unode> I'm running some haskell app through a queueing system (SGE) and depending on how much memory I request from the system the app adjusts its "VIRT" memory accordingly. But not quite.
14:47:47 <Unode> If I request 18GB RAM, I see ~16GB VIRT, if I request 28GB I see ~16G VIRT, 32 -> 16 ; 34 -> 32
14:48:11 <Unode> and I'm running into "out of memory" errors which come from the app, not from the queue system.
14:48:34 <Unode> Cale: any clue?
14:49:33 <merijn> Unode: GHC 8?
14:49:38 <Unode> yes
14:49:44 <merijn> Unode: So SGE is limiting the virtual memory available?
14:50:07 <merijn> Unode: Yeah, you might have hit a bit of an edge case there
14:50:17 <Unode> merijn: well I guess that's how it works. In the past I remember seeing the same app displaying "1TB VIRT" which was scary but everything seemed to work normally.
14:50:48 <Unode> now, it seems like it's hitting "out of memory" long before the requested limit is reached.
14:51:06 <merijn> Unode: Yes, because GHC8 changed the GC implementation into a single huge heap, which makes GC faster/easier to implement, but to do so it reserves 1 TB of virtual address space
14:51:09 <Unode> which made me wonder if allocation is happening in chunks, multiples of what has been alocated before
14:51:20 <merijn> Which is fine, because it's just a reservation, not actually allocated
14:51:27 <Unode> merijn: yes, thing is I don't see that 1TB footprint anymore
14:52:04 <merijn> Unode: Except SGE is configuring your OS/node to not allow that much virtual address space, probably erroring out the reservation and causing the runtime to exit
14:52:12 <Unode> I'm still trying to get a more reproducible test-case since I don't know which variable the queue system sets that limits the process.
14:52:42 <merijn> Unode: The way allocation works it reserves 1 TB and then incrementally converts that reservation into actually allocated memory as necessary. Except it's failing at the first step
14:53:04 <merijn> Unode: You might wanna log a feature request on the GHC trac to override the initial alloc with a different size.
14:53:11 <Unode> hum... I can ask our sysadmin, but I'd be surprised if this was something that changed
14:53:25 <Unode> also, is there any way to have something more informative than "out of memory" ?
14:53:25 <merijn> Unode: In the mean time, if switching to 7.10 is feasible that'd be a workaround
14:53:50 <Unode> I'd love to know how much memory was actually in-use and how much was going to be allocated 
14:53:53 <merijn> Unode: Eh, if someone adds a more informative error...maybe? I dunno how helpful the OS error is
14:54:03 <Unode> merijn: that's not the OS :)
14:54:18 <merijn> Unode: Eh, yes it is?
14:54:28 <Unode> I mean, the error is coming from the app, not the system.
14:54:37 <merijn> Unode: I mean, a system call is erroring out and causing the runtime to exit
14:54:55 <merijn> Unode: Yeah, I just mean if the syscall just returns ENOMEM, there's not much the app can do with that
14:55:18 <Unode> unless it tracks it's memory footprint... I guess
14:55:40 <merijn> Unode: Do you happen to know C?
14:55:47 <Unode> barely
14:56:22 <Unode> I know enough to understand with some effort but can't do much of it myself.
14:56:42 <merijn> Unode: Ah, too bad. The RTS is probably one of the pieces with the fewest people working on it, so if you had a bit of time to investigate that'd probably be incredibly helpful. But probably not worth learning C for ;)
14:57:32 <Unode> I'm not even that much into haskell yet, just been slowly poking this software we have here.
15:04:44 <Gurkenglas> "break _ xs@[] = (xs, xs)" <- why not ([], [])?
15:04:56 <merijn> Gurkenglas: Less allocation
15:05:13 <merijn> Gurkenglas: Just reuse the list that already exists instead of allocating 2 new ones
15:05:19 <merijn> Probably not very significant, but still
15:05:29 <EvanR> erm theres only ever one [] right
15:05:39 <Gurkenglas> Sounds like there ought to be a single [] somewhere in memory that everyone shares
15:05:53 <EvanR> one [] to rule them all
15:06:08 <merijn> Gurkenglas: Maybe, I dunno
15:06:16 <merijn> Gurkenglas: Ask the author of the function whether they profiled?
15:06:36 <EvanR> looks like better safe than sorry
15:06:47 <Gurkenglas> Truify unsafePtrEquality [] []!
15:07:17 <EvanR> ghc-vis confirms all [] are the same object
15:08:15 <merijn> EvanR: Yeah, I think that's true
15:09:55 <Unode> merijn: so this allocation system, are there any options that can be passed to GHC to produce different behaviors at runtime?
15:10:21 <merijn> Unode: Not currently, afaik. But I think that'd be a decent feature request
15:11:03 <Unode> I just did some tests and at higher memory requests there can be up to 50% of memory unused/not allocated. E.g requesting 512GB gives me 256GB VIRT, requesting 514GB gives me 512GB.
15:11:11 <Unode> that doesn't look like a sane behavior.
15:11:43 <merijn> Unode: Looks like sloppy mixing of SI prefixes :)
15:11:58 <Unode> merijn: hehe that's not the point :P
15:12:25 <merijn> Unode: No, I mean I think that it's parsing as SI values, but reporting non SI values (i.e. GiB, rather than GB)
15:12:47 <Unode> the point is, any request between 257 and 512 GB makes no difference.
15:13:02 <merijn> mmm, that's weird
15:13:19 <Unode> that's what I'm inquiring about
15:17:25 <Unode> So what SGE seems to be limiting is "-v: address space (kbytes)" (from ulimit).
15:19:59 <dtrix> Hi. I have a custom List data which can either be Nil or Cons a (List a). I'm having trouble defining a concat function for it
15:20:13 <dtrix> concat :: List (List a) -> List a
15:20:23 <Cale> looks good so far ;)
15:20:31 <merijn> dtrix: What have you got and what gets you stuck?
15:20:53 <dtrix> If i'm using concat with case of matching statement, here's 1 case: Cons _ (Cons x xs) -> x ++ (concat xs)
15:20:58 <dtrix> this is where I'm stuck
15:21:15 <dtrix> Couldn't match expected type ‘[a0]’ with actual type ‘List a’     • In the second argument of ‘(++)’, namely ‘(concat xs)’
15:21:24 <Cale> That looks incorrect, why would you ignore the first element of the list?
15:21:25 <merijn> dtrix: (++) only works on []
15:21:33 <merijn> dtrix: Not on your own List type
15:21:35 <dtrix> yea thats my issue
15:21:37 <merijn> dtrix: And what Cale said
15:21:46 <dtrix> do i have to redefine combine? 
15:21:53 <Tuplanolla> My guess would be that the runtime system tries to double the virtual memory capacity until your demand is met or the request is denied, Unode.
15:21:54 <Cale> dtrix: Perhaps you should write the equivalent of (++) for your list type first
15:22:03 <merijn> dtrix: You have to define your own ++ first, yes
15:22:08 <dtrix> Oh ok, gotcha. Thanks!
15:22:43 <merijn> Tuplanolla: The runtime doesn't do doubling. As I said, it reserves all (virtual) address space and then just incrementally allocates it
15:23:04 <merijn> Tuplanolla: But that requires your reservation to actually work. And the OS is not allowing it to
15:23:23 <Tuplanolla> Yes, but how does it find what "all" means, merijn?
15:23:38 <merijn> Tuplanolla: It reserves a terabyte
15:24:18 <merijn> So it's sorta assuming people won't use more than that. (I think it falls back on the old heap linking if that runs out)
15:26:06 <Unode> merijn: yeah, I can't explain what I'm seeing here then. If I run with 18G I get 16G and my job that takes ~14G runs fine. If I run with 16G I get 8G and "out of memory".
15:26:26 <Unode> I understand the allocation issue, but not the why it behaves like that.
15:26:40 <merijn> Unode: Ah, in that case maybe GHC is already doing the right thing
15:26:58 <merijn> Unode: Maybe it's just the SGE setup that's broken?
15:28:50 <Unode> I don't see how. As I said, SGE sets ulimit -v to the requested memory. It's the "double" behavior that causes the issue.
15:29:18 <merijn> Unode: What does ulimit report for those different values?
15:30:48 <Unode> 512G -> 536870912 ; 400G -> 419430400 ; 256G -> 268435456 ; 
15:31:07 <Unode> seems to be working fine
15:31:26 <merijn> That's not the right value voor 400GiB
15:31:41 <merijn> Not for 512GiB either
15:31:43 <Unode> :/ you are missing the point
15:33:37 <Unode> even if they are off by one byte, it shouldn't trigger a failure. In this machine, I can't run any haskell app that takes more than 256G, even if the machine has 512GB of RAM.
15:34:46 <merijn> I wonder if the RTS reservation ends up halving until it succeeds
15:35:04 <merijn> I don't actually have a GHC source to investigate, though
15:35:32 <Tuplanolla> Now you're suggesting what I just did, but in reverse.
15:36:29 <merijn> Tuplanolla: hmm, maybe, someone would have to dig into the RTS
16:10:04 <crucify_me> hi the [_] syntax is wrong on line 3. why can't I use that wildcard inside the list? http://lpaste.net/360160
16:10:41 <crucify_me> is it not general enought?
16:10:48 <Tuplanolla> @let counterexample 0 [_]  = []
16:10:50 <lambdabot>  Defined.
16:11:08 <EvanR> > (\[_] -> 'b') ['a']
16:11:10 <lambdabot>  'b'
16:11:15 <Tuplanolla> > counterexample 0 "x"
16:11:17 <lambdabot>  []
16:11:18 <merijn> crucify_me: What makes you say you can't use it?
16:11:23 <Axman6> crucify_me: [_] says match a list with exactly one element, which you ignore
16:11:27 <merijn> It's almost certainly not correct
16:11:28 <geekosaur> [x] for any 'x' including '_' means a list with exactly one item
16:11:31 <merijn> But you can use it :)
16:11:44 <geekosaur> if you want to match any list there, let the type determine that it is list and use _ by itself
16:11:49 <geekosaur> that is, _ not [_]
16:11:51 <crucify_me> hold on thanks
16:12:19 <Axman6> have a think about what [_,_] would match, and you'll see why it's wrong
16:17:56 <geekosaur> if you're thinking of this in terms of shell globbing, _ is always ? never *
16:18:15 <geekosaur> but the thing it matches may be a directory/container
16:18:37 <geekosaur> (uh, except that last switches gears, derp)
16:19:11 <geekosaur> anyway it matches one thing. but that one thing may be a collection (e.g. an entore list). used inside of a list, it matches one list item (which may itself be a list if the original is a list of lists)
16:20:41 <crucify_me> geekosaur, thanks I'm going to try a list of lists
16:23:58 <crucify_me> so, it does work on any sort of list, including a list of lists. but its not equivalent?
16:25:14 <geekosaur> [_] is a one-item list containing some other list, as opposed to being any list
16:25:25 <geekosaur> _, in a context that wants a list, matches any single list
16:25:33 <geekosaur> regardless of its content
16:26:03 <EvanR> the pattern syntax is supposed to mirror what that matched expression looks like
16:26:06 <EvanR> to make it easier
16:26:28 <EvanR> [_] matches ['x'], [[_]] matches [['x']]
16:28:03 <crucify_me> but why would take' 0 return an empty list, if the arg is [1,2,3] ? sorry ..
16:28:19 <crucify_me> why would we want that?
16:28:35 <EvanR> what else would it return
16:28:49 <monochrom> Because the user said 0?
16:29:06 <Axman6> "take no elements from the front of this list"
16:30:08 <crucify_me> ok the initial list remains the same, the returned list is new/ separate and is empty.
16:30:33 <EvanR> you were thinking of drop?
16:30:34 <crucify_me> sorry makes sense, I was thinking of one list that is unaltered
16:30:42 <EvanR> > drop 0 [1,2,3]
16:30:44 <lambdabot>  [1,2,3]
16:31:43 <crucify_me> right, its just a new list with no elements, so the initial list is unaltered but we don't see it
16:32:20 <crucify_me> correct essentially ^ ?
16:32:53 <EvanR> altered as in mutated ?
16:33:10 <EvanR> you can't mutate values in haskell
16:33:48 <crucify_me> I have the wrong impression the initial list is hanging out somewhere, but its not.
16:34:05 <EvanR> even if it is, you cant modify it
16:35:06 <EvanR> you're supposed to feel like that would be as absurd as modifying the value of 3
16:35:30 <crucify_me> ok, thanks, right, it cannot change, there's nothing that would modify it in this program.
16:36:02 <EvanR> 3 and [1,2,3] are immutable
16:36:31 <crucify_me> the returned list is separate, its just a copy of whatever take' n is
16:37:09 <EvanR> that is still not sounding right, its not necessarily a copy, in some operational sense that does not matter
16:37:41 <EvanR> like, sin(pi) is zero, but zero is not a copy of anything in particular
16:38:49 <crucify_me> excellent comparison thanks
18:15:54 <Axman6> @hoogle (Foldable f, Alternative b) => (a -> b) -> f a -> b
18:15:54 <lambdabot> Control.Concurrent.Speculation.Foldable asum :: (Foldable t, Alternative f, Eq (f a)) => (Int -> f a) -> t (f a) -> f a
18:15:54 <lambdabot> Control.Concurrent.Speculation.Foldable asumBy :: (Foldable t, Alternative f) => (f a -> f a -> Bool) -> (Int -> f a) -> t (f a) -> f a
18:15:54 <lambdabot> Control.Applicative.Trans.Free runAlt :: (Alternative g, Foldable t) => (forall x . f x -> g x) -> ApT f t a -> g a
18:20:24 <MarcelineVQ> Axman6: foldMap for Alternative?
18:25:25 <Axman6> yeah basically
18:25:33 <Axman6> which can be done with the Alt monoid
18:25:38 <Axman6> :t Alt
18:25:39 <lambdabot> forall k (f :: k -> *) (a :: k). f a -> Alt f a
18:25:59 <Axman6> Alt a <> Alt b = Alt (a<>b)
18:26:04 <Axman6> uh, <|>
18:44:47 <dtrix> hi
18:45:13 <dtrix> i'm still having trouble with a concat function: http://lpaste.net/5758106557455794176
18:46:26 <dtrix> I'm getting a compile error on line 12
18:46:38 <dtrix> Couldn't match type ‘a1’ with ‘List a0’       ‘a1’ is a rigid type variable bound by         the type signature for:           combine :: forall a1. List a1 -> List a1 -> List a1
18:46:53 <dtrix>   at HW4.lhs:131:23-59       Expected type: List (List a0)         Actual type: List a1     • In the second argument of ‘C’, namely ‘y’       In the expression: C Nil y       In a case alternative: (y, Nil) -> C Nil y
18:48:33 <Cheaterman> Ohai buddiez I hope y'all doing goodie ^__^
18:48:41 <Cheaterman> « concat $ List.intersperse "\n" $ filter (/= "") $ map description mylist » can this be made shorter or more legible?
18:48:51 <Cheaterman> Thanks in advance for your ideas ^__^
18:52:15 <MarcelineVQ> dtrix:  C Nil y  would have the type   List (List a)
18:52:28 <FedoraTipper5000> heyo
18:52:28 <dtrix> That's what I don't understand
18:52:33 <FedoraTipper5000> what up folks
18:52:35 <dtrix> oh
18:52:53 <FedoraTipper5000> dude stop
18:53:22 <dtrix> MarcelineVQ but then how would I define a single list using the C notation
18:53:30 <FedoraTipper5000> Omg ur such a nerd
18:53:33 <FedoraTipper5000> just shut it ok
18:53:36 <FedoraTipper5000> gosh dang
18:53:40 <dtrix> I thought (C Nil Nil) would be a single list
18:54:09 <FedoraTipper5000> i saID SHUT UP LIKE 10 TIMES OK
18:54:17 --- mode: ChanServ set +o geekosaur
18:54:18 <FedoraTipper5000> STFU DTRIX FOOL
18:54:23 <FedoraTipper5000> REEEEEEEEEEEEEEEEEEEEEEE
18:54:26 --- kick: FedoraTipper5000 was kicked by geekosaur (FedoraTipper5000)
18:54:26 <MarcelineVQ> C Nil Nil is a single list, that contains an empty list
18:54:32 <FedoraTipper5000> 1 MAR WORD N ILL IGNORE U OK
18:54:38 --- mode: geekosaur set +b *!*Adnok@2602:306:8b2b:5eb0:9db3:e30a:8016:115a
18:55:00 --- mode: geekosaur set +b *!*Adnok@*2602:306:8b2b:5eb0:9db3:e30a:8016:115a
18:55:01 --- kick: FedoraTipper5000 was kicked by geekosaur (FedoraTipper5000)
18:55:01 <Welkin> must be a BASIC programmer
18:55:20 --- mode: geekosaur set -b *!*Adnok@2602:306:8b2b:5eb0:9db3:e30a:8016:115a
18:56:48 <dtrix> MarcelineVQ: Then how is C Nil y a double list? I'm overlooking something
18:57:47 <MarcelineVQ> in data List a = Nil | C a (List a)     C a (List a)   takes an element and a list and produces a list, if that element is a list we have a list of lists.
18:57:57 --- mode: ChanServ set +o glguy
18:57:58 --- mode: glguy set +b-bo *!*@2602:306:8b2b:5eb0:* *!*Adnok@*2602:306:8b2b:5eb0:9db3:e30a:8016:115a glguy
18:58:00 --- mode: geekosaur set -o geekosaur
18:58:33 <dtrix> Oh ... since Nil isn't a single element. Thanks!!
19:00:11 <MarcelineVQ> it is but it's a list, which means 'a' is a list, so your list of List a becomes List (List a)   I really wish I could be explaining this clearer though :X
19:00:58 <MarcelineVQ> @let data List a = Nil | C a (List a) deriving Show
19:01:00 <lambdabot>  Defined.
19:01:03 <MarcelineVQ> :t Nil
19:01:05 <lambdabot> List a
19:01:28 <MarcelineVQ> @let ys = List 3 Nil
19:01:29 <lambdabot>  .L.hs:173:1: error:
19:01:29 <lambdabot>      • Could not deduce (Num [Item (List a0 -> t)])
19:01:29 <lambdabot>        from the context: (Num [Item (List a -> t)], IsList (List a -> t))
19:01:43 <MarcelineVQ> oopshehe
19:01:47 <MarcelineVQ> @let ys = C 3 Nil
19:01:48 <lambdabot>  Defined.
19:02:07 <MarcelineVQ> :t ys
19:02:08 <lambdabot> Num a => List a
19:02:21 <MarcelineVQ> :t C Nil ys
19:02:22 <lambdabot> Num (List a) => List (List a)
19:02:58 <MarcelineVQ> erhm, that's not a coherent example actually, I shoulda done this in ghci  :(
19:03:05 <dtrix> oh so a normal list like [4, 3, 2, 1] would be C 4 (C 3 (C 2 (C 1 Nil)))
19:03:19 <MarcelineVQ> dtrix: that's exactly right
19:03:58 <dtrix> MarcelineVQ: Thanks!  
19:33:46 <HorribleProgram> fuck u stupid cunts
19:34:10 <HorribleProgram> hello?
19:34:15 <HorribleProgram> fuck all of u
19:37:19 --- mode: ChanServ set +o glguy
19:37:19 --- mode: glguy set +b *!*@unaffiliated/horribleprogram
19:39:40 --- mode: glguy set +b-b $a:HorribleProgram *!*@unaffiliated/horribleprogram
21:01:40 <Marisa_> Hi, had anyone read https://www.cs.bham.ac.uk/~mhe/papers/selection-escardo-oliva.pdf?
21:01:47 <Marisa_> I am stuck on p 16...
21:03:02 <Marisa_> what is it even trying to say... got very confused
21:03:52 <Marisa_> can anyone give an example that a function is simultaneously a fix point operator, a selection function, and a quantifier at the same time?
21:03:59 <Marisa_> That sound so strange to me..
21:04:03 <Welkin> looks like your typical academix paper written in academese
21:04:35 <Marisa_> I mean, I can do a few cat theory, so I survive for 15 page > <
21:13:42 <int-index> the code in http://lpaste.net/360161 compiles on GHC 8.2.1 but not on GHC 8.0.2 - can someone help me find the relevant Trac ticket?
21:35:48 <MarcelineVQ> int-index: I'm unable to find anything that matches close-enough to that issue, please make a ticket about it and if people know about the issue they'll be able to link relevant tickets to it
21:42:56 <int-index> MarcelineVQ, alright, I created https://ghc.haskell.org/trac/ghc/ticket/14488
21:44:20 <MarcelineVQ> be sure to peruse the 8.2 release notes in case there's something obvious there, but I didn't see anything
22:00:19 <saurabhnanda> is there quick way to check which libraries are in base in each compiler version? I want to specifically check when List.NonEmpty became a base library
22:02:00 <jcarpenter2> saurabhnanda: what about hackage
22:02:06 <jcarpenter2> https://hackage.haskell.org/package/base-4.10.0.0
22:02:29 <saurabhnanda> jcarpenter2: where is the compiler version written on that page?
22:02:34 <saurabhnanda> did I hit a blind spot?
22:02:53 <saurabhnanda> assumption - base version and compiler versions are in lock-step
22:02:54 <jcarpenter2> the base version is written on that page
22:03:17 <saurabhnanda> in that case, can I have a CPP flag in cabal based on base version instead of compiler version?
22:04:42 <geekosaur> #if MIN_VERSION_base(4,10,0,0)
22:04:46 <geekosaur> something like that
22:05:07 <saurabhnanda> geekosaur: doing this for the first time. is #if different from if ?
22:05:12 <geekosaur> but not in the cabal file. you can do something with flags though, thinking backwards
22:05:24 <saurabhnanda> I need to include `semigroups` conditionally based on base version?
22:05:26 <geekosaur> flag foo
22:05:36 <geekosaur> if foo
22:06:19 <geekosaur> er, soorry
22:06:21 <geekosaur> if flag(base)
22:06:40 <geekosaur>   build-depends: base >= 4.10
22:06:44 <geekosaur> else
22:06:55 <geekosaur>   build-depends: base < 4.10
22:07:08 <geekosaur> (amnnd whatever else you need in those)
22:07:18 <geekosaur> the #if one is for CPP extension in Haskell source files
22:07:23 <saurabhnanda> does the entire `build-depends` section need to be duplicated?
22:07:36 <geekosaur> so youcan also test it inside your source, if you need to e.g. use a different module name for an external import, or something
22:07:41 <geekosaur> no, it's additive
22:07:43 <saurabhnanda> can't I have a single build-depends section and have a few packages conditional?
22:08:11 <geekosaur> build-depends: foo, bar\nif flag(foo)\n  build-depends: base >= 4.10\nelse\n  ...
22:08:42 <saurabhnanda> ah okay
22:08:44 <saurabhnanda> let me rye
22:08:46 <geekosaur> so you put the common ones outside the conditional and your appends inside
22:09:31 <jle`> int-index: is DatatypeConstraints still supported?
22:10:07 <int-index> jle`, it's not DatatypeConstraints
22:10:36 <int-index> (and you probably meant DatatypeContexts)
22:10:53 <jle`> oh i see
22:11:00 <jle`> i don't even konw how to interpret that data type then :o
22:11:30 <saurabhnanda> geekosaur: okay -- seems to be working at cabal level. Now, need to use CPP in the hs source file as well, right?
22:12:08 <geekosaur> dpeends. if you include the semigroup library in the older base branch. I think it has the same module name and API so yuou could avoid the CPP foo
22:12:23 <geekosaur> some other deps might not be so polite about upgrades
22:12:36 <geekosaur> er, semigroup package
22:12:47 <geekosaur> only in the base < 4.10 branch
22:13:52 <saurabhnanda> hmm okay... let's push and see if CI complains.
22:35:23 <xacktm> Hi, can someone see what's wrong with my types?  I'm trying to integrate https://artyom.me/aeson#parsing-without-creating-extra-types but my naive implementation is .. naive http://lpaste.net/3164299163709997056
22:40:16 <liste> xacktm: I don't think =<< is appropriate here
22:40:28 <liste> xacktm: I think just . is enough
22:41:05 <geekosaur> it's seeing (parseMaybe unwrapQuery =<< decode . BL.fromStrict . encodeUtf8) someTextValue
22:41:36 <geekosaur> you want it to see something like: parseMaybe unwrapQuery =<< (decode . BL.fromStrict . encodeUtf8) someTextValue
22:47:09 <xacktm> hmm let me see
22:53:22 <xacktm> thanks, it works!  I made it pointful since my point-free-fu is not that good, but I can move on now :)
23:11:32 <rightfold> Will evaluating par x y finish as soon as evaluating y finishes, or will it also wait for the evaluation of x to finish?
23:12:12 <rightfold> I’d like to carry on while x is still evaluating in the background.
23:13:34 <rightfold> Because I won’t be using x until much later.
23:59:33 <romanix> do you guys know how to reduce ghc's memory requirements when compiling with profiling enabled? i'm unable to compile my app with profiling due to ghc starting to swap during compilation
