00:00:15 <nshepperd> :t const (Const ()) :: Maybe a -> Const () a
00:00:17 <lambdabot> Maybe a -> Const () a
00:00:44 <dminuoso> Oh... Ohh...
00:00:53 <jle`> ^ `Const ()` is indeed a Functor, and is isomorphic to the popular functor Proxy
00:01:55 <jle`> for any inhabited type X, Const X is a Functor, and there are potentially many different natural transformations Maybe ~> Const X
00:01:58 <cocreature> dminuoso: basically you just pretend bottom doesn’t exist and hope or the best :) the paper geekosaur linked to formally proves that reasoning under that assumption leads to valid theorems for the total fragment of Haskell iirc so ignoring bottom is actually “reasonable” in some sense
00:03:01 <jle`> to clarify what i mean before, for any type X at all, `Const X` is a Functor
00:03:03 <geekosaur> the paper also delineates when that reasoning is valid
00:03:09 <dminuoso> jle`: I see, this actually resolves the "bizarre type signature thought" I had for a while.
00:03:15 <jle`> and if X is inhabited, you do have a natural transformation Maybe ~> Const X
00:03:23 <jle`> and, potentially many
00:03:25 <dminuoso> geekosaur: Ive started reading it, it's pretty thick for my background. :)
00:03:43 <jle`> for example, there are an infinite amount of distinct natural transformations Maybe ~> Const Int
00:04:23 <dminuoso> jle`: I can see where this is going. I think I need to make a diagram to wrap my head around how Const Int is a functor.
00:05:25 <nshepperd> my approach to it is basically: as long as my code evaluates to bottom only if some input is bottom ('introduces no new bottoms'), then any theorem violations due to bottoms are someone else's fault ;)
00:06:09 <dminuoso> nshepperd: iow as long as your program terminates and does not error, bottom might as well not exist?
00:06:57 <nshepperd> something like that
00:07:17 <nshepperd> after all, that's the only way to observe a bottom
00:07:45 <nshepperd> (unless you go around using IO to catch pure exceptions)
00:07:55 <nshepperd> (like some kind of monster)
00:10:54 <jle`> dminuoso: try making your own ConstInt and verifying the laws :)
00:11:11 <jle`> data ConstInt a = ConstInt { getConstInt :: Int }
00:11:18 <jle`> instance Functor ConstInt where
00:11:20 <jle`> etc.
00:22:33 <artagnon> Hi, are exceptions only supposed to work in IO? How do you make them work in a MonadIO like the distributed Haskell Process, or an RWST IO?
00:23:43 <cocreature> artagnon: liftIO . throwIO?
00:24:26 <tdammers> cocreature: that covers throwing, but not catching
00:24:30 <ertes-w> ello
00:25:05 <artagnon> Do you have to catch them explicitly? I thought the program would just abort with some location information.
00:25:14 <ertes-w> artagnon: the 'exceptions' package has exception effect classes
00:25:17 <cocreature> if you just want to abort throwIO is all you need
00:25:30 <cocreature> if you want to catch take a look at MonadCatch
00:25:32 <ertes-w> artagnon: but MonadIO is sufficient for throwing
00:25:37 <artagnon> Also, what is `error`?
00:25:50 <ertes-w> artagnon: error x = undefined
00:26:23 <geekosaur> error throws an async exception from pure code, with a programmer specified message
00:26:26 <artagnon> ertes-w, cocreature: Thanks, will try in the morning.
00:27:28 <geekosaur> but you should consider whether you should be using it; functions that use error for 'impossible' cases are annoying at best
00:27:31 <cocreature> if we’re already acknowledging the existence of exceptions error and undefined are not the same thing
00:27:32 <geekosaur> > head []
00:27:34 <lambdabot>  *Exception: Prelude.head: empty list
00:27:39 <artagnon> Okay, I read about this, but what is an async exception?
00:28:22 <artagnon> geekosaur: That doesn’t work in an RWST context, for instance.
00:28:38 <geekosaur> define 'work'
00:28:38 <artagnon> Head just silently fails, and I have no idea what went wrong where.
00:29:12 <geekosaur> uh, that sounds like something else is wrong, likely something is catching all exceptions and not rethrowing or etc.
00:29:33 <jml> geekosaur: what do you suggest for 'impossible' cases, if not `error`?
00:30:35 <geekosaur> jml, ideally you deal with them before they become impossible. if you can't (things like that 'head' example I showed) a pattern match is usually preferable to a partial function because you get better messaging
00:30:54 <artagnon> I think Maybe or Either should be used in pure code.
00:31:08 * jml nods
00:31:12 <geekosaur> because (a) better location information (b) since pattern matching is strict, you are more likely to get the error where it actually happened and not when it gets forced at some future point
00:31:55 <geekosaur> (laziness complicates debugging such things)
00:32:12 <jml> right. but a thing I do when I'm not clever enough to eliminate the possibility is, `UnreachablePattern {} -> error "This cannot happen because $plausible_reason"`
00:32:27 <artagnon> So under no circumstance should an `error` or `assert` seem to do “nothing”?
00:32:36 <ertes-w> it's usually better to convince GHC that the case can't happen
00:32:49 <ertes-w> but it's not always possible/practical to do that
00:34:26 <geekosaur> artagnon, it can happen if something is catching all exceptions and ignoring them instead of rethrowing the ones it doesn't want to deal with.
00:34:50 <geekosaur> some poorly written threaded programs can 'lose' exceptions thrown in a thread that way, for example
00:34:57 <artagnon> On an unrelated note, can anything be done about this? https://gist.github.com/artagnon/6fd289ae7d1704413a8b62a7d52ce001
00:35:51 <artagnon> geekosaur: I couldn’t find anything on the internet about Distributed Haskell having this deficiency, and I don’t know how to even catch exceptions myself.
00:36:51 <geekosaur> I think we'd have to see actual code that reproduces the problem to have any idea of what's going on
00:37:14 <artagnon> Right, I’ll try to cook up some reduced cases in the morning.
00:39:07 <artagnon> I think Foundation has a magic NonEmpty type to deal with `head`.
00:41:11 <artagnon> Oh, another question in the queue: is there a way to represent non-negative integers? Some GHC extension that does some subset of dependent typing?
00:46:31 <LiaoTao> artagnon: https://prime.haskell.org/ticket/79
00:50:00 <artagnon> LiaoTao: I was hoping for something in GHC that would let me define it, not a built in.
01:18:06 <ertes-w> artagnon: it's not really magic
01:20:29 <ertes-w> artagnon: you can define it yourself like this:  data NonEmpty a = a :| [a]; infixr 5 :|
01:20:44 <ertes-w> then a non-empty list looks like this:  x1 :| x2 : x3 : x4 : …
01:21:21 <agerick>  
02:10:56 <ertes-w> i wish i could write instance-global helper definitions in an instance
02:14:13 <ertes-w> instance (Reifies x B) => C (A x) where { let x = reflect (Proxy @ x); … }  -- like this
02:17:51 <ertes-w> alternatively it would be nice to have parameterised (sub-) modules
03:03:41 <Maticz> Hey guys, yesterday I asked for a solution on how I could implement infinite matrix, it doesn't work for what I want to do. I need to make a grid where some tiles in the grind depend on values from tiles around it. Does anyone have any suggestions how I could implement such an infinite matrix where the elements can be accessed in O(1)
03:05:40 <[exa]> Maticz: what if a tile depends on a neighboring tile that depends on a neighboring tile that ...
03:06:05 <Lowl3v3l> Maticz: random access in O(1) is impossible with interdependant fields.
03:07:36 <Maticz> [exa]: that was exacly the problem I was facing, ghci stalls
03:08:21 <Maticz> Lowl3v3l: Ok I was afraid for that, what would be the best approach to implement such a matrix that is infinite but isn't in O(1)
03:09:20 <Lowl3v3l> Maticz: depends on how big you want your matrix to be, how fast you need it and what algorithms should run on it.
03:10:04 <Lowl3v3l> Maticz: and it soudns like a bad datastructure since it seems to be mutable, unperformant and with possible endless-recursion-traps in there
03:10:30 <Lowl3v3l> Maticz: so whatever provlem you try solving, i'd advise to solve it differently^^
03:11:12 <Maticz> Lowl3v3l: its a grid that is generated by a seed value, every tile in the grid has a chance of becoming a lava tile but also every tile as another chance to be a lava tile if one of the neighbouring tiles is a lava tile
03:11:30 <Maticz> Lowl3v3l: its a desert exploring tile game
03:12:07 <Maticz> but the desert must be infinite for every coordinate (x, y) where x and y are natural numbers
03:12:37 <Maticz> so the player must be able to walk to (inf, inf)
03:12:44 <Lowl3v3l> Maticz: how about a graph? resolving recursion issues would be isomorphic to finding cyclical subgraphs anyway
03:13:33 <Maticz> Lowl3v3l: a graph with the keys as coordinates, I was thinking about that too, but I wanted to make sure to make the right choice
03:13:35 <Lowl3v3l> Maticz: you could even weight the graph in order to give some tiles a different chance of becoming lava^
03:14:25 <Lowl3v3l> Maticz: though i'd really try to remove the dependencies between tiles. just mutate the graph round based or sth
03:14:37 <Maticz> Lowl3v3l: otoh, there is a classmate of me that is implementing a static matrix that is expanding every time by doubling its size when the player wants to walk outside of the bounds of the previous matrix
03:15:23 <Lowl3v3l> Maticz: sadly, this doesn't solve all the problems i named. e.g. avoiding recursive behavior^^
03:15:24 <Maticz> Lowl3v3l: I cant remove the dependencies, its a requirement for the project
03:16:11 <Lowl3v3l> Maticz: is this game round based? i assume there's some kind of trigger that transforms tiles to lava after a fixed time or a fixed number of steps the player does?
03:16:26 <Maticz> Lowl3v3l: no its not
03:17:00 <Maticz> Lowl3v3l: there are some portal tiles in the grid too, which are end points of the game
03:17:11 <Maticz> Lowl3v3l: but these portal do not depend on other tiles
03:19:01 <Lowl3v3l> Maticz: i assume there's a known subset of nodes that are lava at the beginning, yes?
03:19:47 <Maticz> Lowl3v3l: no
03:20:21 <Maticz> Lowl3v3l: maybe I could send you the text from the assignment so you get idea?
03:20:27 <Lowl3v3l> Maticz: so, at which events do tiles transform?
03:21:19 <Maticz> Lowl3v3l: by a line of sight of the player
03:22:37 <Lowl3v3l> so there IS an event when the tiles transform. i'd just mutate the graph at each step the player does . 
03:24:13 <Maticz> Lowl3v3l: So when the player "discovers" a tile, it is generated 
03:25:23 <ertes-w> Maticz: if the player traverses to (50000000,50000000), do you actually need to remember what is at (0,0)?
03:25:37 <Maticz> ertes-w: yes
03:26:04 <Maticz> "However, once a tile has been revealed by the line of sight of the explorer, it should remain so." - from assignment
03:26:28 <Lowl3v3l> yeah. essentially, i'd treat the game as  round based. a round is one step the player takes, aka a monadic function that takes keyboard input, fires a lot of triggers, changes the map accordingly, and calls itself recursively with then new map and the new player position
03:26:47 <Lowl3v3l> and of course hope you got enough ram xD
03:27:31 <Maticz> Lowl3v3l: well its purely hypothetical that a player should step to (big int, big int)
03:27:42 <Maticz> Lowl3v3l: but it should be possible
03:30:11 <Maticz> Lowl3v3l: I just recently started learning about monads this week, what do you mean by "a monadic function that takes keyboard input, fires a lot of triggers"
03:31:23 <Lowl3v3l> Maticz: well you have a monad with two arguments : a graph with the field and a player position. then the function takes a keyboard input that determines the next step. It transforms the graph accordingly and then calls itself with the new graph and the new player position.
03:32:15 <Maticz> Lowl3v3l: thanks alot for your help :)
03:50:49 <Virgo_> So the trick behind Room temperature superconductivity 
03:51:23 <Virgo_> has to do with the cross connections between resistivity and conductance
03:52:00 <Lowl3v3l> Virgo_: are you a physicist? just so i can decide wether to discuss this seriously^^
03:52:27 <Virgo_> I am a molecular biologists with interest in material science 
03:52:40 <Virgo_> err ist*
03:53:24 <Virgo_> like tin and Dy
03:53:59 <Lowl3v3l> Virgo_: so how come you think you found how to get room temp superconductors?^^ I mean, i studied physics, but not condensed matter physics, and i can tell its a fucking hard problem^^
03:54:39 <Virgo_> it is
03:58:10 <Lowl3v3l> Virgo_: so entertain me, what IS the trick? i want to be the first one to see a new physicist nobel laureate :D
03:59:22 <Virgo_> it is difficult to formulate the two into an alloy
04:00:11 <Virgo_> in one hand you have alloic layering... in another you have atomic arrangement 
04:01:15 <Virgo_> the common goal around this is to use an insulator to get around the crystal structure disarray... 
04:01:27 <Virgo_> in which we have only a few options 
04:02:01 <Lowl3v3l> Virgo_: what makes you think this allow would be super conductive at norm conditions?^^
04:02:12 <Lowl3v3l> Virgo_: do you have at least any math to back this up?
04:02:27 <Virgo_> arrangements of Carbon, Silicon, P, Boron and a non isul like germanium which is diamagnetic 
04:02:41 <Virgo_> well yes
04:02:58 <Lowl3v3l> did you publish it? in which magazine?
04:03:35 <Virgo_> the difficulty of the math is perplexed due to diamagnetic to paramagnetic exchanges and crystal structures during physical states
04:03:47 <Virgo_> no the research is private
04:04:01 <Lowl3v3l> okay, so no reason to take you serious then. 
04:04:58 <Virgo_> nope
04:05:15 <Lowl3v3l> thats like the girlfriend i had when i was 13 yo. "oh no you cant meet her, she goes to a different school".
04:05:16 <Virgo_> I have no credentials to back it up
04:05:27 <Virgo_> moving on then
04:06:39 <johnnymacs> Is haskell suitable for reversible computing?
04:07:08 <Lowl3v3l> johnnymacs: what do you mean by reversible computing? haskell is a general purpose language
04:08:04 <Virgo_> without the knowledge to back up an arguement to discredit. The counter misinformation would make both our discussions a waste of time. 
04:09:32 <johnnymacs> In a purely reversible computer no energy is consumed by the cpu.
04:09:49 <Virgo_> Besides the Earth is projected to run out of Dy by 2025. And we wouldn't want that. 
04:09:50 <johnnymacs> But it has to be purely reversible from the hardware all the way up through the software
04:16:12 <Lowl3v3l> johnnymacs: i do not really understand what you mean by reversible.
04:23:31 <absurd[m]> What can be the best language to write bots to collect information from sites?
04:25:43 <Lowl3v3l> absurd[m]: the language nearly doesn't matter for such trivial efforts. Malbolge or Brainfuck would be bad choices and assembly might take to long, but otherwise... the main problem when programming is, in all cases, finding a good algorithm, modelling etc, at that point writing a program is comparatively easy. Sure, i DO consider haskell a pretty good language, but this doesn't mean i consider all other languages bad.
04:29:06 <absurd[m]> Hmm, so Haskell can make it without some complications?
04:30:30 <Lowl3v3l> absurd[m]: what do you mean by "complications"? unknown languages are hard
04:31:48 <absurd[m]> hehe, for examle would it be easier with Python?
04:32:57 <Lowl3v3l> absurd[m]: i dont know what your background is, wether you know haskell or pythong et cetera. i find languages like python really hard compared with haskell or lisp, but that may be just me being special.
04:34:23 <quchen> Both Haskell and Python are not unsuitable for the task. Which one to choose brings us back to the old »which language should I learn« problem. In #haskell, the answer to this is usually »learn Haskell«.
04:36:57 <quchen> You don’t learn Haskell (or Python) in order to write a specific program though; they’re general purpose languages with pros and cons. It’s not like you end learning something after you’ve written your program, much like you can use your hammer despite having finished that cupboard.
04:37:31 <ezyang> I had a funny experience today where I attempted to compute factorial in the Python repl, failed on my first try, and then did it in GHCi, succeeded on first try 
04:37:38 <ezyang> (mind you, I am currently writing Python at my day job) 
04:38:47 <Lowl3v3l> ezyang: i feel you. i have to write java and i miss quickcheck or pure functions ( or at least proper TCO) every single day :/
04:38:53 <le_jonge> ezyang: lol i am using a lot of haskell and python currently, too. and meanwhile i find it easier to "proof of concept" ideas in haskell than in python.
04:43:44 <hpc> i have been using puppet at work, and it's pretty alright
04:44:06 <hpc> it's an extremely domain-specific language, but at least it has purity
04:45:57 <agander> orion: it does work - the 'stack build --file-watch-poll  --exec prog arg1 arg2'. You just need to enclose the 'prog arg1 arg2' in quotes like this: stack build --file-watch-poll  --exec "prog arg1 arg2"
04:48:36 <infinisil> First haskell project I'm writing..
04:48:41 <infinisil> Everything is IO () :/
04:49:21 <cocreature> infinisil: Haskell is a great language for IO-heavy stuff :)
04:49:37 <dminuoso> infinisil: It's being honest about what your program "does" (i.e. what it returns)
04:49:56 <infinisil> True
04:50:10 <infinisil> But eventually I'd like to try out an effect system
04:50:12 <Maticz> Is there anyone with experience in the fgl graph library? I'm wondering if I could use tuples as nodes instead of just Int's
04:50:31 <infinisil> and sprinkle some monads around
04:51:25 <cocreature> Maticz: afaik your nodes always have to be Ints but you can change the type of the data that is associated with each node (the node labels)
04:52:37 <quchen> Lowl3v3l: GHC doesn’t do TCO, so it has nothing over Java in that respect.
04:52:40 <dminuoso> infinisil: I found incredible comfort in being able to look at a function and gain intuition about what the function does from its type.
04:53:00 <ezyang> ...yes it does? 
04:53:17 <quchen> It does? I would argue the STG makes TCO unnecessary.
04:53:23 <dminuoso> infinisil: And that includes knowing whether a function has side effects or not. :)
04:53:46 <infinisil> dminuoso: You're using an effect system? Or are you just talking about function signatures in general?
04:54:03 <infinisil> s/function signatures/types
04:54:29 <dminuoso> infinisil: function signatures in general.
04:54:42 <infinisil> Can agree with that
04:54:50 <infinisil> I'm explicitly passing around state
04:55:23 <quchen> Lowl3v3l: And there is a Quickcheck implementation for Java, you should try it out!
04:55:50 <Lowl3v3l> quchen: unfortunately i am not free to choose my testing framework myself.
04:55:51 <quchen> (Assuming changing the tests to Quickcheck is easier than changing the codebase to Haskell) ;-)
04:56:14 <Lowl3v3l> and changing the codebase to something less insane is out of the question too i suppose :D
04:56:53 <Lowl3v3l> quchen: and yeah, ghc doesn't have tco, but i'd consider stg to be superior. thats why i said "at least"^^
04:58:39 <ezyang> quchen: I don't see what laziness has to do with this. I can CPS my code to fix an evaluation order and I'm still not going to run out of stack 
04:59:20 <quchen> ezyang: Yes, but then you’re changing the code. I know TCO as the compiler automatically recognizing tail calls and generating special code to make that case more memory-efficient.
04:59:24 <infinisil> Probably simple question for a lot of people here, how can i refactor this? https://git.io/vFSJW It should be possible with >>= but I'm not sure how
05:00:10 <infinisil> oh and I could do return $ fromMaybe ... directly
05:00:51 <lyxia> infinisil: is that... a gist containing a link to another gist?
05:01:13 <infinisil> Lol
05:01:46 <lyxia> infinisil: return $ maybe defaultPort read $ listToMaybe args
05:02:24 <ezyang> but this is exactly what we do. For example, see Section 2 "Compiling join points efficiently" 
05:02:29 <quchen> infinisil: http://lpaste.net/360097
05:02:55 <quchen> infinisil: You should use readMaybe (and handle the parse error) though, read throws an exception if the input is malformed
05:03:02 <quchen> > read "hello" :: Int
05:03:03 <lambdabot>  *Exception: Prelude.read: no parse
05:03:08 <ezyang> (in https://www.microsoft.com/en-us/research/wp-content/uploads/2016/11/join-points-pldi17.pdf) 
05:03:23 <infinisil> Ohh thanks a lot
05:03:48 <quchen> ezyang: Ah, join points! (What about before we had those?)
05:03:49 <infinisil> quchen: really useful gist!
05:04:14 <cocreature> quchen: join points are just a generalization of what GHC has been trying to do before afaik
05:04:20 <quchen> infinisil: I think you should write that sort of code for clarit, not brevity, though.
05:04:37 <quchen> infinisil: There is no tax for taking 5 lines for what could have been crammed into one
05:05:10 <quchen> Apart from the >>= to fmap conversion, all of this is what GHC would pretty much have done on its own as well
05:05:14 <infinisil> True, I mainly do this to understand this stuff better though
05:05:50 <quchen> infinisil: Then this might help, https://github.com/quchen/articles/blob/master/functions_comprehensible.md#desugaring-do-notation
05:05:55 <ezyang> Whenever you have 'case f 2 of ...' you're going to have to codegen the call to f differently than if you just had 'f 2' 
05:05:55 <infinisil> Btw it's maybeRead, not readMaybe
05:06:12 <quchen> :t readMaybe
05:06:14 <lambdabot> error: Variable not in scope: readMaybe
05:06:28 <quchen> Nope, it’s readMaybe. https://hackage.haskell.org/package/base-4.10.0.0/docs/Text-Read.html#v:readMaybe
05:06:33 <infinisil> Huh, maybeRead is in Network.CGI.Protocol :/
05:06:39 <quchen> :-þ
05:06:43 <infinisil> I can't find readMaybe in hoogle
05:06:50 <quchen> Try Hayoo!
05:06:52 <cocreature> http://hoogle.haskell.org/?hoogle=readMaybe
05:06:56 <quchen> http://hayoo.fh-wedel.de/?query=readMaybe
05:07:10 <quchen> Hayoo is slower, but I much prefer its search results
05:07:21 <quchen> Haven’t used Hoogle in some time, maybe it’s improved though
05:07:27 <cocreature> quchen: even compared to hoogle 5?
05:07:34 <ezyang> and so, yes, when you translate to STG this gets turned into 'let x = f 2 in case x of ...' and now it's all laziness and "everything is a tail call", but at the end of the day you're still skinning the cat 
05:07:41 <infinisil> Oh nice
05:09:22 <quchen> ezyang: Alright, you convinced me. Thanks :-)
05:10:00 <ezyang> apparently, I should write a StackOverflow answer, because "Haskell TCO" turns up a very strange answer 
05:14:03 <lyxia> ezyang: or a blogpost!
05:14:20 <cocreature> I’d definitely welcome that!
05:23:50 <infinisil> Alright I got this now, needed a bit more (now returning PortID instead of PortNumber): https://git.io/vFSkL
05:23:56 <infinisil> and using readMaybe now
05:24:24 <infinisil> (N is qualified import of Network btw)
05:25:49 <infinisil> When do the people here prefer to use a qualified import vs importing specific stuff vs importing all of the module?
05:29:10 <ezyang> obvious cases are libraries which tell you the preferred import style in haddocks 
05:30:49 <infinisil> I should just google this question tbh, it's probably been answered loads of times already
05:30:52 <cocreature> I generally go for explicit imports when I need a relatively small number of imports (< 5 or something like that) and the module is not in "base", import everything for modules in base and qualified modules for a lot of other stuff
05:31:08 <cocreature> often I also import types unqualified and then import the functions qualified
05:31:35 <cocreature> which is why I’m really sad that anthony cowley’s proposal for an import syntax that allows for this didn’t get through :(
05:31:51 <cocreature> e.g. "import Data.Text (Text); import qualified Data.Text as Text"
05:32:34 <infinisil> Wait what does this do?
05:32:57 <cocreature> you can use Text as a type without the module name but for everything else you need the module name
05:33:12 <infinisil> import the Text type from Data.Text but also a qualified import for Text.<stuff> so you can use Text for multiple thnigs?
05:33:16 <cocreature> Text.Text just looks really ugly and doesn’t add very much
05:33:22 <cocreature> yep
05:33:25 <infinisil> hmm
05:34:00 <cocreature> e.g. imagine you are using ByteString and Text in the same module, qualifying the functions that actually operate on those is necessary
05:34:19 <infinisil> Ohh I see now
05:34:19 <cocreature> but qualifying the types isn’t since the type names don’t collide
05:34:44 <infinisil> So if you need ByteStrings <foo> you can just use ByteString.<foo>
05:34:51 <cocreature> exactly
05:34:57 <infinisil> That would be nice indeed
05:35:13 <cocreature> you can do it now, you just need two separate import statements
05:35:22 <cocreature> anthony proposed a syntax that allows you to combine these two into one
05:35:31 <infinisil> Oh I see, cool
05:35:49 <ertes-w> you can also use some functions from more generic interfaces to avoid having to use qualified names
05:36:00 <ertes-w> for example (Monoid ByteString) and (Monoid Text)
05:36:50 <ertes-w> (xs <> ys) looks nicer than (xs `T.append` ys)
05:37:07 <infinisil> Oh nice
05:37:47 <infinisil> Why isn't this done for everything though? Shouldn't it be possible to refactor everything that uses the same method names under some typeclass?
05:37:59 <infinisil> Oh, because code from different people and stuff
05:38:25 <infinisil> and it probably wouldn't work all the time, because nobody dictates what function names should really do
06:16:08 <ertes-w> infinisil: Text and ByteString are similar enough that a common interface could work…  there have been attempts to do that (e.g. mono-traversable)
06:16:08 <orion> I'm using Cabal 2.0.0.2, and I'm getting an error "cabal: No targets given and there is no package in the current directory.". I am attempting to build the following set of packages: https://github.com/ezyang/backpack-regex-example/tree/multiple-packages
06:16:14 <orion> Does anyone know what could be going wrong?
06:17:04 <ertes-w> infinisil: but then mono-traversable tries to be far more generic, so it has become this complicated, unintuitive mess of arbitrary type classes
06:19:30 <cocreature> orion: try "cabal new-build all"
06:19:57 <orion> cocreature: Bah! Thank you.
06:22:48 <cocreature> orion: does the error message not tell you about this? I thought it mentioned this command
06:27:21 <orion> cocreature: It does tell me this. :( I haven't had coffee yet this morning.
06:29:47 <cocreature> orion: no worries, I was just checking if I should be worried because I’m making up error messages that don’t actually exist :)
06:49:14 <infinisil> ertes-w: Nice to know
06:50:25 <infinisil> Is the reason that a lot of packages have a <Lib>.Types module so that there aren't any import cycles? Because I just got and I feel like that would prevent it
06:50:43 <infinisil> s/just got/just got one/
06:52:57 <quchen> infinisil: Yes, import cycles are one reason to do this sort of thing. But on the other hand, having the types in a different module than the API can make it muhc harder to write typeclass instances.
06:53:14 <ertes-w> infinisil: well, it's true that import cycles force you to use a certain module structure, but i wouldn't say it's only because of that
06:53:16 <quchen> I think types should go into the same module as their API, unless there is a good reason not to do that.
06:53:55 <ertes-w> infinisil: having all the types and classes in one module is quite helpful
06:54:03 <ertes-w> .Types and .Class
06:55:04 <ertes-w> infinisil: .Core is also common – includes types and primitive operations
06:56:56 <infinisil> Alright thanks, will have to think about how I want to structure it eventually, currently everything's all over the place
07:52:08 <orion> Is there any official documentation regarding "mixins" in cabal?
07:53:28 <cocreature> orion: you mean backpack mixins?
07:54:21 <orion> Yes.
07:54:52 <orion> I assume mixins are a cabal-level feature, not a GHC level feature.
07:55:08 <cocreature> orion: afaik the “official” docs are https://ghc.haskell.org/trac/ghc/wiki/Backpack and the linked blogposts
07:56:24 <prohobo> is there some kind of example app i can write in haskell to get a hang of the language?
07:56:26 <prohobo> i dont get it
07:56:32 <prohobo> i can't think of a god damn thing
07:57:01 <prohobo> hmm maybe project euler problems
07:59:31 <shapr> I wish I could easily call Haskell code from Python and Go, I might be able to get Haskell into production at my job.
07:59:34 <Lowl3v3l> prohobo: do you have some CS background? being able to reason about stuff usually helps with haskell
07:59:43 <Lowl3v3l> shapr: ffi?
08:00:05 <lavalike> shapr: you could call it... over TCP (:
08:00:06 <prohobo> Lowl3v3l: im a fake web dev
08:00:20 <prohobo> vape naysh
08:00:30 <shapr> yeah, but I want something like Rust's explicit support for being called from Python
08:00:47 <Lowl3v3l> prohobo: so get some CS background, thats always a good idea
08:01:12 <shapr> prohobo: I started building things in Haskell without ever taking math or CS college classes, you can do it!
08:01:19 <prohobo> ah thats nice
08:01:29 <shapr> but I do agree that it makes reasoning about the code easier
08:01:42 <Lowl3v3l> shapr: i still believe CS is the one thing that most programmers lack xD
08:02:11 <shapr> yeah, but I've seen coders with a MS in CS still unaware of useful things that Haskell teaches
08:02:39 <prohobo> i passed CS okay
08:03:20 <shapr> prohobo: build something that scratches an itch you have?
08:03:34 <Lowl3v3l> shapr: i don't speak about haskell here ( i dont know that many good haskell programmers) but about coding in general^^ its absolutely shocking how many  lack even most basic knowledge of algorithms or data structures or the ability to spot NP hard problems
08:03:38 <shapr> todo list, mp3 tag editor, something like that?
08:05:04 <Lowl3v3l> shapr: if i had a dollar for every newbie trying to solve undecidable problems that i've seen this year... xD
08:05:34 <shapr> The pursuit of undecidable problems is certainly informative.
08:06:40 <shapr> prohobo: when I'm teaching Haskell, I start with "download a book from gutenberg.org, cut it into words, display the top ten most frequent words"
08:07:01 <shapr> prohobo: then I teach "build a markov chain from the book, and use that to generate random text that sounds like the original book"
08:07:01 <Lowl3v3l> shapr: thats actually a good one , gotta keep it in mind^^
08:07:53 <shapr> after that, we do stylometry: "find a way to compare markov chains so we can see if a new document closely matches a previously seen document"
08:08:21 <shapr> The implementations of those ideas are surprisingly simple
08:09:48 <Lowl3v3l> shapr: okay i go a more mathematical route when teaching, tends to be a clearer problem domain, e.g. i like doing image generation a la mc escher. Or fractals
08:11:07 <lavalike> shapr: are your course materials online?
08:11:08 <shapr> Sometimes those lessons turn into "here's how we grab emails from imap/pop so we can try to identify authors"
08:11:17 <shapr> lavalike: nah, I just make this stuff up as I go
08:11:33 <shapr> though now I have the urge to make some kind of curriculum
08:12:59 <shapr> lavalike: I teach the same lessons in Python and Haskell
08:13:10 <shapr> what we tackle next really depends on who's in the classes
08:13:32 <shapr> BUT, it turns out installing Haskell is a HUGE pain!
08:13:42 <lavalike> womp womp!
08:13:50 <gehmehgeh> Installing Haskell is the easy part
08:14:07 <shapr> stack is okay, but I'd like something that doesn't require piping a shell script to bash
08:14:38 <shapr> I've helped ... probably fifteen people install Haskell in the past two weeks, and it was rarely easy.
08:14:50 <Lowl3v3l> shapr: though parts of the stack are a pain as well. e.g. try installing leksah via stack.
08:15:03 <shapr> At this point I'd like to see if it's easier to install nix and then use nix to install Haskell
08:15:10 <lavalike> shapr: the other day I discovered this https://code.world/haskell#PNR9yg-2S7JlSMyp3xRYFMA
08:15:27 <shapr> that's chris smith's project, yeah?
08:15:47 <MarcelineVQ> shapr: stack is just a single executable, you can download a bin if you prefer to avoid the skechyness of wget sh
08:16:02 <shapr> lavalike: for the Python lessons, I started using Jupyter because it was difficult to get everyone on the same Python version, and able to install libraries
08:16:11 <shapr> MarcelineVQ: tell me more?
08:16:12 <lavalike> indeed it is
08:16:17 <sm> shapr: that's interesting
08:16:30 <shapr> I installed ihaskell on my laptop this past week, but I've not had time to try it yet.
08:16:38 <sm> pasting that one stack install command line was a problem ?
08:16:40 <lavalike> shapr: that's interesting, as I understand it there is a haskell background daemon for jupyter notebooks
08:16:42 <shapr> I can hope it's as easy to use as Jupyter
08:16:47 <shapr> lavalike: right! ihaskell!
08:16:59 <lavalike> have you tried it out in that setting?
08:17:08 <shapr> sm: more that I'm teaching coworkers, and they don't trust piping a shell script to sudo bash
08:17:22 <MarcelineVQ> shapr: manual download links here https://docs.haskellstack.org/en/stable/install_and_upgrade/#installupgrade
08:17:29 <shapr> sm: so most people tried brew install haskell-stack, or apt-get install haskell-stack
08:17:37 <sm> ah, fair enough
08:17:42 <shapr> at one point someone ended up with haskell-stack 0.1.something
08:17:54 <sm> would they go for curl FILE; less FILE; ./FILE ?
08:17:59 <shapr> and then stack upgrade failed, and frustration continued
08:18:03 <shapr> sm: sometimes
08:18:36 <MarcelineVQ> shapr: if you can get stack by other means then one can simply   stack upgrade   and use the new executable it puts in ~/.local/bin  and uninstal the old one entirely
08:18:52 <Henson> hi folks.  When interfacing Haskell with C, is there any way to make Haskell aware of memory allocated within C?  I'm trying to load images inside of the C block.  I can't pass in a haskell-pre-allocated area of memory because I don't know how big the image will be a-priori, so C passes out a Ptr which gets turned into a ForeignPtr.  But Haskell doesn't know how big the data within that....
08:19:04 <MarcelineVQ> "<shapr> and then stack upgrade failed, and frustration continued" aww :X
08:19:06 <Henson> ForeignPtr is, and I don't think is giving it high enough garbage collection priority.
08:19:11 <sm> or, what about: install system stack package; stack upgrade
08:19:18 <shapr> MarcelineVQ: Yeah, that's the easiest approach I've found, but users with antiquated versions of Ubuntu/Debian get an antique version of stack, unsurprisingly.
08:19:23 <sm> oh, what MarcelineVQ said
08:20:00 <shapr> Several people in my class just fired up a recent Ubuntu VM and installed and used stack/ghc there.
08:20:25 <shapr> But I wish to encourage real world and everyday use of Haskell
08:20:32 <shapr> so that's why I discourage VMs and all that
08:20:39 <sm> quite right
08:21:03 <lavalike> Henson: I wonder if the solution is implementing a data type and its Storable instance, then do the marshaling of that instead of just a raw pointer
08:21:10 <sm> but I wonder how this will be solved
08:21:45 <shapr> sm: ihaskell and nix are my next two ideas for simplifying the install
08:21:49 <shapr> sm: got any other ideas?
08:21:49 <MarcelineVQ> shapr: so like, I think we got disconnected before because I don't recall the response, but why are cabal sandboxes or   cabal new-build   insufficient for teaching?
08:22:16 <lavalike> Henson: maybe I'm wrong and that's not the right primitive
08:22:40 <shapr> MarcelineVQ: they might be, I need to try that too. The advantage of stack is that it will get the correct version of GHC if it doesn't already have it.
08:23:25 <shapr> At one point "brew install" would download GHC and then build it, and that would take hours.
08:23:56 <shapr> MarcelineVQ: if you have any other ideas, I'd like to try them :-)
08:23:58 <lavalike> I usually install the haskell platform on OS X to use Haskell
08:25:21 <sm> shapr: I suppose, make haskell valuable enough in the real world  that it becomes a priority for packagers and funders
08:25:50 <shapr> yeah, that's one reason I wish Haskell had an explicit "call Haskell from Python / Go" like Rust's libs
08:26:16 <shapr> but I'm working on this from both the education and value ends, hopefully it makes some impact at my company
08:27:06 * sm seems to remember a blog post about calling haskell from something.. C ?
08:28:42 * sm finds http://www.vex.net/~trebla/haskell/so.xhtml and https://stackoverflow.com/questions/5015447/calling-haskell-functions-from-python
08:28:48 <Henson> lavalike: hmm, I'll take a look in that direction.  Essentially there needs to be some way of feeding back the allocated size from C to the Haskell layer, or knowing in advance how much memory Haskell should allocate.  One simple way would just be to get the image from C along with its size and then allocate memory in Haskell and copy the data, but unnecessary copying would be desirable.
08:31:02 <lavalike> Henson: yeah I agree, if you can get the size from the C side you should be good to go: I also *think* it should be possible to package those up in an Haskell data type equipped with a Storable instance
08:31:24 <Henson> lavalike: ok, I'll look into a Storable instance, then.
08:32:05 <shapr> sm: yeah, there's also https://github.com/nh2/call-haskell-from-anything and others
08:32:31 <shapr> that github repo uses MessagePack, and maybe that's a good approach to simpler FFI
08:33:31 <sm> that looks pretty good
08:35:05 <mnoonan> Henson: I've wanted this too, and I don't think there is a good solution to making the Haskell runtime feel the pressure from the C allocations. Let me know if you find something interesting.
08:35:24 <shapr> sm: We're using protobuf3 to communicate among our several implementation languages, I need to learn that, and try it from proto-lens.
08:36:40 <nh2[m]> sm: if you have a problem with it, ping me
08:37:25 <sm> thanks!
08:37:44 <sm> shapr: if it gives you trouble, ping me and I'll ping nh2[m]
08:37:50 <shapr> ha, thanks!
08:38:39 * sm starts thinking about reasons to call haskell code from php
08:38:53 <shapr> sm: Do you write PHP at work?
08:38:58 <sm> yup
08:40:30 * sm thinks: reimplement some of the model layer in haskell, using persistent to access the same db tables, call from php when new models can do something easier than the old ones
08:58:52 <Guest58922> @pl setKernelInputData context' kernel' argNum' data' dataSize' = ((newArray (data')) >>= (\xs -> (createConstBuffer context' dataSize' (castPtr xs)) >>= (\mem_xs -> clSetKernelArgSto kernel' argNum' mem_xs)))
08:58:52 <lambdabot> setKernelInputData = ((flip ((.) . (>>=) . newArray) .) .) . (. clSetKernelArgSto) . (.) . flip . ((flip . ((>>=) .)) .) . flip flip castPtr . ((.) .) . createConstBuffer
08:59:52 <Guest58922> @pl createConstBuffer context' size' ptr' = clCreateBuffer context' [CL_MEM_READ_ONLY, CL_MEM_COPY_HOST_PTR] (size', ptr')
08:59:52 <lambdabot> createConstBuffer = (. (,)) . (.) . flip clCreateBuffer [CL_MEM_READ_ONLY, CL_MEM_COPY_HOST_PTR]
09:01:05 <Guest58922> @unpl createConstBuffer = (. (,)) . (.) . flip clCreateBuffer [CL_MEM_READ_ONLY, CL_MEM_COPY_HOST_PTR]
09:01:05 <lambdabot> createConstBuffer x x0 x2 = clCreateBuffer x [CL_MEM_READ_ONLY, CL_MEM_COPY_HOST_PTR] (((,)) x0 x2);
09:02:05 <Guest58922> @unpl setKernelInputData = ((flip ((.) . (>>=) . newArray) .) .) . (. clSetKernelArgSto) . (.) . flip . ((flip . ((>>=) .)) .) . flip flip castPtr . ((.) .) . createConstBuffer
09:02:05 <lambdabot> setKernelInputData x x0 x1 y x4 = newArray y >>= \ y1 -> createConstBuffer x x4 (castPtr y1) >>= clSetKernelArgSto x0 x1;
09:03:43 <Guest58922> @pl setKernelInputData x x0 x1 y x4 = newArray y >>= \ y1 -> createConstBuffer x x4 (castPtr y1) >>= clSetKernelArgSto x0 x1
09:03:43 <lambdabot> setKernelInputData = ((flip ((.) . (>>=) . newArray) .) .) . (. clSetKernelArgSto) . (.) . flip . ((flip . ((>>=) .)) .) . flip flip castPtr . ((.) .) . createConstBuffer
09:04:15 <infinisil> What the fell is that monstrosity
09:04:19 <infinisil> hell
09:05:00 <Taneb> infinisil: welcome to pointless style
09:05:02 <Guest58922> Some haskell code in my project. I hoped pl could simplify it
09:05:50 <erisco> I will not stand by while pointfree style is besmirched
09:06:39 <c_wraith> Guest58922, the only thing that might make the original easier to read is do notation.
09:07:12 <erisco> you often have to begin in a principled way to have good pointfree code
09:07:34 <exio4> and more often than not, full point-free code is a mess :)
09:07:42 <Guest58922> I want to try one more
09:07:49 <erisco> pointed code is more suitable as duct tape
09:08:16 <mnoonan> map (not . standby erisco) . takeWhile (besmirching PointFreeStyle) ?
09:08:28 <Guest58922> @pl   foldr1 (>>) [setKernelInputData context kernel (fromIntegral i) (xsData!!i) vecSize | i <- [0..nD-1]]
09:08:29 <lambdabot> foldr1 (>>) [setKernelInputData context kernel (fromIntegral i) (xsData !! i) vecSize | i <- [0..nD - 1]]
09:09:42 <erisco> mnoonan, I don't know if we can be friends anymore
09:13:18 <barrucadu> besmirch :: Style -> Maybe Defender
09:14:43 <infinisil> Um what the hell, why do i not get any output when I run my haskell program via systemd :////
09:15:09 <barrucadu> Run it via systemd?
09:15:14 <infinisil> with a systemd unit
09:15:15 <ystael> barrucadu: I feel like that should be :: (HasStyleDefenders m) => Style -> m (Maybe Defender)
09:15:46 <ystael> cause, you know, `besmirch` is sort of stateful
09:16:36 <barrucadu> infinisil: I'm no systemd expert, but what's your unit file look like?  I have a couple of Haskell servers started by systemd
09:18:02 <infinisil> barrucadu: It's literally just a [Unit] Description ... [Service] ExecStart=/path/to/binary arguments
09:18:48 <infinisil> I triple checked that it's actually running even
09:20:50 <infinisil> Okay I got a clue, it has nothing to do with systemd, but with my program
09:22:33 <infinisil> Apparently this line is the problem: https://gist.github.com/Infinisil/a96d904420ee8c0dc332427702d2ad21#file-main-hs-L75
09:23:21 <infinisil> replacing it with `return ()` prints the "Listening on port ..." message /above/, leaving it in makes it print nothing at all
09:24:12 <infinisil> I am using the blocking readChan from Control.Concurrent in my main thread, could that be the problem?
09:25:31 <alsoStevenXL> Hi everyone. I am getting my feet wet on Haskell web development (I'm using Spock). I have the following module (http://lpaste.net/360102), and I want to change Line 44 / 45 from what they currently are to get people People.getPeople
09:25:52 <alsoStevenXL> When I try to do that, the type inference no longer works. But I don't know what type to use to help the compiler.
09:26:08 <comerijn> infinisil: Is your output rather short?
09:26:20 <cocreature> alsoStevenXL: please show us the full error and the exact code you use to produce that error
09:26:25 <barrucadu> infinisil: I guess it's a buffering issue
09:26:40 <alsoStevenXL> cocreature: Sure. Will do. Let me get that set up for you.
09:27:21 <comerijn> infinisil: I'm almost certain it's buffering issues
09:27:25 <barrucadu> infinisil: Try setting the buffering mode of stdout to LineBuffering: https://hackage.haskell.org/package/base-4.10.0.0/docs/System-IO.html#g:12
09:27:41 <barrucadu> When run by systemd it may well default to block buffering
09:27:47 <comerijn> infinisil: I don't know systemd, but I suspect it talks to your process via pipes, which would cause your IO to be block buffered, rather than line buffered
09:28:01 <infinisil> comerijn: Just a line, but running it from a terminal works no problem
09:28:01 <infinisil> Do I need to manually flush or something?
09:28:15 <comerijn> infinisil: Yes, because terminals default to line-buffered :)
09:28:24 <comerijn> infinisil: (Since they're for interaction with people)
09:28:45 <comerijn> infinisil: files/pipes are for interaction with programs, so default to blockbuffering (i.e. only flush every N kb)
09:28:59 <comerijn> So yes, either manually flush or change the buffering mode
09:29:14 <infinisil> Hmm alright thanks I'll try setting it to line buffered manually
09:30:25 <infinisil> I'm pretty sure it worked with a previous version of the program though, not sure why
09:31:44 <infinisil> Yeah that worked
09:32:28 <barrucadu> The reason the message for printed when you changed the line to `return ()` is because all buffers are flushed as the program terminates
09:32:36 <barrucadu> *the message was printed
09:32:40 <alsoStevenXL> cocreature: here is the entire code base, (https://github.com/stevenxl/spock-todo), and this is the erro taht I am seeing (http://lpaste.net/1574474576228777984)
09:32:48 <alsoStevenXL> Sorry for the links, didn't want to spam the channel.
09:33:18 <infinisil> barrucadu: Ah right
09:38:00 <cocreature> alsoStevenXL: I’ll take a look in a few minutes
09:38:29 <alsoStevenXL> cocreature: no worries; thank you for any help.
09:43:28 <alsoStevenXL> Hi everyone. On a somewhat related question, how do you figure out what module to import a function from as teh client of a library? For example, the Spock library defines a function json, and if I do :i json in ghci, I get this (Defined in ‘Spock-core-0.12.0.0:Web.Spock.Internal.CoreAction’). But I don't think that the library author wants me to import the function from that module.
09:44:29 <namosca> Hi everone... I have a simple question. Is there a way of making this function look more elegant??
09:44:29 <namosca> runLengthEncoding s= zip (map length (group s)) (map head (group s))
09:44:53 <alsoStevenXL> Is there a better solution than going through the code and seeing which is the "least namespaced" module that exports the json function?
09:45:16 <comerijn> namosca: eh, "map (\l -> (length l, head l)) (group s)"?
09:45:23 <erisco> namosca, yes I have a function just for this called "gang"
09:45:38 <erisco> which I am trying to get submitted to some library but... no one returns my calls
09:45:55 <erisco> namosca, here you are http://lpaste.net/359821
09:45:58 <comerijn> Alternatively:
09:46:03 <mud> namosca: Haha, you can do stupid Arrow tricks.  runLengthEncoding = map (length &&& head) . group
09:46:07 <comerijn> :t map (length &&& head) . group
09:46:08 <lambdabot> Eq a => [a] -> [(Int, a)]
09:46:35 <namosca> I am on the codewars website and I did this code... but somehow it loooks terrible hehe
09:47:01 <infinisil> :t fmap (length &&& head) . group
09:47:02 <lambdabot> Eq a => [a] -> [(Int, a)]
09:47:46 <documentnode> >5
09:49:24 <namosca> comerijn, mud: Nice the trick with arrow... today I was wondering what the hell is arrows.. now its nice that I saw your answer
09:50:53 <mud> There's actually quite a bit to Arrow and friends. But nobody really uses them anymore, so they're essentially just weird tuple tricks now.
09:51:59 <namosca> mud: ahh okl....
09:52:19 <namosca> One day I read somebody saying that arrow and lenses are the future, so thats why I wanted to learn it
09:53:55 <comerijn> lens, maybe
09:54:00 <comerijn> arrow almost certainly not :)
09:54:46 <namosca> in which module is this &&& symbol? My prelude complains about it
09:55:07 <infinisil> Control.Arrow
09:55:17 <infinisil> Source: http://hayoo.fh-wedel.de/?query=%26%26%26
10:02:22 <alsoStevenXL> Might be getting closer, this is the new error: Couldn't match type ‘persistent-2.7.0:Database.Persist.Class.PersistEntity.PersistEntityBackend
10:02:25 <alsoStevenXL>                              record0’
10:02:27 <alsoStevenXL>                      with ‘SqlBackend’
10:02:30 <alsoStevenXL>         arising from a use of ‘selectList’
10:02:32 <alsoStevenXL>       The type variable ‘record0’ is ambiguous
10:04:09 <cocreature> alsoStevenXL: http://lpaste.net/360105 typechecks but I don’t use spock so I’m not sure if it also makes sense :)
10:05:07 <alsoStevenXL> cocreature: thank you i'll take a look
10:05:11 <alsoStevenXL> appreciate your time
10:05:36 <alsoStevenXL> What did you do to figure that out by the way? 
10:06:35 <artagnon> Hi, I'm having some trouble with JSON-encoding my cryptonite data structure: https://gist.github.com/artagnon/c8898893764ff8b8704c3a2ddd995ff7
10:07:02 <artagnon> The encoding seems to work, but the decoding seems to be broken.
10:07:30 <orion> artagnon: Does the code compile?
10:07:51 <cocreature> alsoStevenXL: I took a look at the type of json to see that the return type of getPeople must be "ActionCtxT ctx m b" for some choice of ctx m and b. then I looked at the type of runSQL and added the constraints that it needs
10:08:04 <artagnon> orion: It's a snippet, should I prepare something that compiles?
10:08:32 <alsoStevenXL> cocreature: Thanks. I'll have to take some time to dissect that, but I think concpetually I get it. 
10:08:35 <alsoStevenXL> ;0
10:08:35 <alsoStevenXL> ;)
10:09:21 <orion> artagnon: Can you paste an example of the precise input to b64decode?
10:09:37 <artagnon> orion: Sure, just a sec.
10:10:02 <madsj> exit
10:10:53 <artagnon> orion: I've pasted the json as a comment: https://gist.github.com/artagnon/c8898893764ff8b8704c3a2ddd995ff7
10:11:47 <artagnon> That is ClientConfig with three fields: public_key, private_key, profile_name.
10:12:24 <orion> artagnon: So, if you decode a ClientConfig, you're going to eventually rely on the FromJSON instance for PublicKey.
10:12:36 <artagnon> Yes.
10:12:42 <orion> public_key is a string.
10:12:46 <artagnon> Yes.
10:13:06 <artagnon> The deserializer expects a Text signature.
10:13:19 <artagnon> Which is why there's a T.unpack.
10:13:29 <orion> You base64 decode it, *then* you decode it again using aeson's decode.
10:13:49 <orion> On line 26.
10:14:49 <artagnon> Oh.
10:14:53 * artagnon scratches his head
10:15:25 <artagnon> How does Aeson's decode know that it's a base64 encoded ByteString
10:15:27 <orion> The base64 decoded value contained in "public_key" would itself have to be valid JSON.
10:15:41 <orion> It doesn't.
10:16:08 <artagnon> I see.
10:16:12 <orion> When you write T.unpack, you're forcing aeson to assume that the type of "public_key" is a string.
10:16:15 <orion> JSON string.
10:16:26 <artagnon> Yes, isn't it?
10:16:30 <orion> Correct.
10:16:50 <artagnon> Oh, then I don't need the B64.decode?
10:17:20 <orion> After aeson hands you a string, "AQEBAAAAAAAAACAv/P/...", you call B64.decode, which is correct.
10:17:47 <orion> But it looks to me that you made a mistake in calling `decode` on *that*.
10:18:11 <artagnon> So how do I make it into an Object?
10:18:27 <orion> What is the type of B64.decode?
10:18:44 <artagnon> ByteString -> ByteString.
10:19:05 <orion> What library?
10:20:09 <artagnon> orion: https://hackage.haskell.org/package/base64-bytestring-1.0.0.1/docs/Data-ByteString-Base64.html (base64-bytestring)
10:20:31 <orion> decode :: ByteString -> Either String ByteString
10:20:41 <artagnon> Sorry, I recalled from memory.
10:21:52 <orion> The ByteString you get back from `decode` should be properly converted to a PublicKey.
10:22:15 <orion> (decode . fromStrict) is not correct here.
10:22:48 <artagnon> Okay, what else gives `ByteString -> Maybe a`
10:23:15 <orion> Why are you searching for that?
10:23:20 <monochrom> CSV parsing. :)
10:23:32 <artagnon> Haha.
10:24:00 <orion> Your intention is to extract the JSON string value from "public_key", base64 decode it, and return a PublicKey, right?
10:24:07 <artagnon> Yes.
10:24:49 <orion> So what you want is a function (or combination of functions) which gives you Either String ByteString -> Either String PublicKey
10:25:43 <michalrus> Hey, can I do `unsafeIOToSTM . randomIO` or… is it a (very) bad idea?
10:25:56 <artagnon> Okay,  let me look in cryptonite then.
10:26:03 <monochrom> Does unsafeIOToSTM exist?
10:26:12 <michalrus> Yes, in GHC.Conc.Sync
10:26:21 <bitemyapp> athan: snowflake/flake id
10:26:23 <michalrus> https://hackage.haskell.org/package/base-4.10.0.0/docs/GHC-Conc-Sync.html#v:unsafeIOToSTM
10:26:29 <bitemyapp> https://github.com/bitemyapp/blacktip
10:26:34 <monochrom> It seems a bad idea.
10:26:35 <bitemyapp> it's a mimic of flake which is a mimic of snowflake.
10:27:53 <artagnon> orion: cryptonite doesn't seem to have anything the converts from ByteString.
10:28:11 <artagnon> Should I use ByteString's decode?
10:28:16 <artagnon> Er, Binary's decode.
10:28:35 <Xandaros> How did you use non-hackage packages (on the local filesystem) with stack again?
10:29:27 <michalrus> monochrom: okay. =( =)
10:29:29 <michalrus> Thanks!
10:29:50 <lyxia> Xandaros: add their path in the packages: section
10:30:32 <Xandaros> Yeah, I remember needing some other option, though, to declare it as dependency rather than something project-internal
10:32:28 <lyxia> Xandaros: https://docs.haskellstack.org/en/stable/yaml_configuration/#local-dependency-packages-extra-dep
10:37:31 <artagnon> orion: Thanks, I made some progress with the right `decode` :)
10:41:46 <Xandaros> lyxia: thank you very much!
10:44:14 <orion> artagnon: Cool.
10:49:06 <lavalike> what is the state of the art to make cross-platform uis in haskell nowadays?
10:50:28 <orion> HTML
10:59:06 <artagnon> Where is my `error`? https://gist.github.com/artagnon/5208a3a6988b35caabb78631aabd5943
10:59:23 <artagnon> I'm having this issue with distributed-process swallowing up exceptions (?)
11:02:26 <artagnon> geekosaur: Here's the promised example (^)
11:12:20 <Neos1998> some_file.wav
11:12:45 <Neos1998> No leepyleepy!
11:13:27 <infinisil> wat
11:14:37 --- mode: ChanServ set +o shapr
11:14:44 <shapr> Neos1998: are you here to learn Haskell?
11:15:12 <Neos1998> Just passing through....is it hard?
11:15:19 <shapr> nah, it's really fun
11:15:32 <Neos1998> what is haskell??
11:15:38 <shapr> It's a programming language!
11:15:46 <Lowl3v3l> Neos1998: everything worth knowing is hard to learn
11:16:06 <erisco> it is also a given name
11:16:09 <danielsmw> even the knowledge that everything worth knowing is hard to learn, perhaps
11:16:36 <Lowl3v3l> danielsmw: well i for one had to learn this the hard way :P
11:16:36 <shapr> Neos1998: there's a neat tour on haskell.org
11:16:39 <Neos1998> ....Does torifier run well with mIRC ?
11:16:50 <shapr> Neos1998: that's not Haskell related!
11:16:56 <Neos1998> Thank you saw the webpage...
11:17:00 <monochrom> I don't think Neos1998 cares.
11:17:05 <shapr> Neos1998: This channel is for Haskell related discussion.
11:17:16 <shapr> If you want to talk about Haskell, this is a good place for that!
11:17:25 <Neos1998> Okay I can be directed to such answers?.......
11:17:28 <shapr> If not, we politely ask that you move your conversation elsewhere
11:17:38 <Neos1998> Thanks...........................
11:17:41 <monochrom> No, this is not a directory service either.
11:18:26 <infinisil> Haha
11:47:24 <orion> ezyang: Hi. Are you around?
11:56:14 <crucify_me> hi I'm trying to learn how this extended euclidean algorithm works in haskell. I can do the reverse substitutions on paper. but first, do I need the semicolon in the where clause? https://ptpb.pw/2bWv 
11:56:40 <danielsmw> no, you definitely don't want that semicolon
11:57:12 <danielsmw> you may want to consider aligning the (q,r) with the (s,t) vertically, as well
11:57:35 <crucify_me> danielsmw, weird, it works with the semicolon. it won't compile without it, do I have another error where it strangely works ? danielsmw 
11:57:42 <danielsmw> what's the error?
11:57:52 <crucify_me> sorry one sec
11:59:36 <crucify_me> parse error on input '=' (line 9 which is last line)
12:00:03 <danielsmw> yeah, so like I said, try aligning the (s with the (q vertically
12:00:06 <crucify_me> perhaps you need a 'let' in a 'do' block
12:00:09 <crucify_me> ok
12:00:25 <danielsmw> it may be that the semicolon lets you do weird stuff like that, but typically semicolons aren't the style people use
12:00:46 <danielsmw> i'm honestly not sure. but without semicolons, haskell does depend on alignment of certain code blocks
12:00:50 <crucify_me> I tried that first instinctively when I cut and paste the code from github
12:00:55 <crucify_me> one sec
12:01:39 <crucify_me> weird danielsmw that worked thanks. one moment if you have time....
12:02:08 <danielsmw> crucify_me: glad it worked
12:02:20 <danielsmw> crucify_me: i'll be around for a bit
12:02:37 <crucify_me> yes, really don't like seeing the semicolon. I'm a beginner but that looks horrible :)
12:03:18 <danielsmw> crucify_me: i honestly didn't even know semicolons could be used in where blocks! i've only seen them in do { expr1; expr2; } blocks before.
12:03:31 --- mode: shapr set -o shapr
12:05:01 <geekosaur> they can be used anywhere that layout is active, including where blocks
12:05:45 <danielsmw> TIL. does the layout parser just kind of reset after the semicolon?
12:06:41 <crucify_me> so the trace is showing the meat and bones of the euclid algorithm. which variables there are for the x,y variables in, say, gcd (a,b) = ax + by, which are the x,y variables there? I don't really understand the code yet. mathematically, I can do the substitutions, said earlier
12:06:44 <crucify_me> danielsmw, 
12:07:27 <crucify_me> but need to see what haskell is doing
12:09:36 <danielsmw> crucify_me: if you want to see very clearly what haskell is doing, you might want to just start doing IO. like putStrLn'ing out the state of the variables at each step
12:10:20 <danielsmw> do you know how to do basic I/O?
12:10:33 <crucify_me> er..
12:10:48 <fizbin> danielsmw: I really think for a beginner that trace is actually more useful output
12:11:03 <crucify_me> I mean I've used printLn et al
12:11:21 <danielsmw> fizbin: possibly, but i worry that relying on it in a simple example where it works might lead to confusion later when it fires at all the wrong times
12:11:22 <fizbin> Specifically, getting this pure calculation threaded through IO seems like more than is needed.
12:11:24 <danielsmw> but that's fair
12:11:29 <crucify_me> just in examples. IO is actually confusing to me, like main = $  that sort of thing
12:11:40 <danielsmw> crucify_me: exactly what extra info are you trying to "see" in the calculation, anyway?
12:12:48 <danielsmw> fizbin: you're definitely right, though. i should have thought through what that would involve before suggesting it.
12:13:11 <crucify_me> danielsmw, fizbin  thanks for considering the difference. one sec please
12:13:52 <fizbin> crucify_me: I have an idea. Just a moment.
12:15:24 <crucify_me> excellent
12:16:04 <fizbin> crucify_me: How about this? http://lpaste.net/360107
12:16:16 <fizbin> I have tweaked your code just a tiny bit.
12:16:24 <crucify_me> see, I just got a handle on what the math is doing. I don't really know why the extended version is used, though I heard its crucial to basic number theory. I'm self-teaching numTheory without a CLUE
12:16:35 <crucify_me> one moment pls
12:18:41 <crucify_me> sorry I can't follow that. I don't really see how the initial (my) version works. sorry
12:19:07 <crucify_me> but let me run it
12:20:41 <fizbin> So, all I'm doing in my version is I'm saying "when you make the recursive call, instead of calling the real extendEu function, call this extendEu' function that wraps your extendEu function by printing out the arguments and (importantly) the answer that the function comes up with"
12:21:36 <crucify_me> ok in 'seq' trace (argument) is just for the output, right?
12:22:28 <fizbin> Yeah, I was afraid that might be a bit obscure. The `seq` makes sure that the value of "y" is fully worked out before it tries to construct and print the trace message.
12:23:40 <crucify_me> sorry fizbin I'm in over my head. I need to focus on how the initial program works, given that it is written well in haskell.
12:23:53 <fizbin> Otherwise, in recursive function like this, you might get Haskell printing out the first bit of the trace message, then stopping to work out the value of y, then continuing. But "stopping to work out y" would print out another trace message (go recursion) so you'd end up with an unreadable mess.
12:24:34 <carbolymer> I am adding -g -rtsopts to the ghc-options inside .cabal file, but when I am running my application through gdb I am getting this message: (no debugging symbols found) - what am I doing wrong? I'd like to add debug symbols to the statically linked binary
12:26:22 <anks> hey, what is the most efficient way to convert Vector Word8 -> ByteString you know?
12:26:28 <crucify_me> ok, thanks. well consider gcd (421,111)  fizbin. the gcd is actually one so these are relatively prime. you start with the last non-zero remainder, and work backwards (reverse substitution). this is how it is taught anyway. I wonder if we could illustrate that process...
12:26:34 <crucify_me> fizbin, ^
12:26:35 <danielsmw> crucify_me: when you say that you want to figure out "how the initial program works", do you mean you want to understand the steps that haskell programattically carries out in the evaluation of your code, or are you just asking how this algorithm works abstractly?
12:27:26 <crucify_me> I think at first, maybe the abstract solution being traced somehow would be helpful danielsmw 
12:28:13 <crucify_me> I naively thought I could see the whole shebang
12:29:02 <fizbin> anks: Is there some reason B.pack . V.toList is not efficient enough?
12:29:30 <fizbin> crucify_me: Hrm. Let me see if I can write a version of your initial code with lots of tracing.
12:29:43 <zachk> there are some haskell step evaluators somewhere online
12:29:45 <anks> i'll go with this one as its super simple, and if thats not enough ive found something with unsafe pointers
12:29:49 <anks> thanks fizbin 
12:30:15 <fizbin> crucify_me: Because I think part of the issue with seeing it with your original code is that you don't trace the return result of the function.
12:33:48 <crucify_me> fizbin the return result?
12:34:30 <crucify_me> with (a,b) it only gives what a standard euclid algorithm would return
12:34:37 <crucify_me> with that trace
12:36:23 <infinisil> :pl f g a h b = g a >>= h b
12:36:30 <crucify_me> by the way this is a sample I'm following the uses Bezouts formula http://lpaste.net/360110
12:36:36 <crucify_me> that*
12:36:47 <fizbin> crucify_me: Check out http://lpaste.net/360107 again (updated it)
12:36:54 <crucify_me> thanks!
12:37:25 <infinisil> @pl f g a h b = g a >>= h b
12:37:25 <lambdabot> f = (((.) . (>>=)) .)
12:37:35 <infinisil> Sweet
12:37:36 <crucify_me> holy smokes
12:38:02 <c_wraith> please don't use that in real code. :P
12:38:04 * infinisil is totally gonna use that
12:38:33 <infinisil> @pl f a b = g a >>= h b
12:38:33 <lambdabot> f = (. h) . (>>=) . g
12:38:42 <crucify_me> fizbin danielsmw thanks SO much. upexpected afk. pax
12:40:26 <infinisil> Is there something like a monadic foldl?
12:40:33 <johnw> foldM
12:40:43 <infinisil> Oh lol
12:42:46 <danielsmw> does anyone know how to get either LaTeX or unicode into the labels, legends, etc using Chart?
12:44:57 <danielsmw> or alternatively, does anyone know how to produce a diagram (via Chart-diagrams) in a way that the text objects are diagrams-like? it seems that Chart is doing its own preprocessing of text before is produces a diagram.
12:48:39 <sternmull> i would like to play with qtah-qt5. This package is only on hackage and not on stackage. So far i only used stack to build my projects. How do i use qtah as dependency in my stack project?
12:49:20 <danielsmw> sternmull: in your stack.yaml file, you should be able to include it under extra-deps.
12:49:38 <danielsmw> sternmull: in fact, if its in your .cabal file and you run stack solver, it'll probably tell you exactly what to put in
12:51:59 <infinisil> Hmm, I'm doing `foldM_ nextState initialState (repeat constant)` with `nextState :: s -> c -> IO s` and `constant :: c`. I'm content with this, but I feel like it could be done nicer
12:52:45 <sternmull> my first attempt was to just add it to build-depends. If i now run "stack solver" it fails with "The following lines from cabal-install output could not be parsed:" and some more lines.
12:52:49 <codeshot> Possibly StateT?
12:53:10 <infinisil> I haven't looked at StateT really
12:53:33 <codeshot> There's State, which allows you to update a state value
12:53:49 <codeshot> and StateT is a more generic form, which allows you to put IO actions in at the same time
12:54:22 <artagnon> Is there a thorough documentation of exceptions and how they (are supposed to) work in MonadIO? Is an `error` supposed to print a message?
12:54:31 <codeshot> I don't really know what you're doing so maybe it's not appropriate
12:55:04 <codeshot> artagnon only if you don't catch it
12:55:42 <geekosaur> oh dear. distributed haskell uses exceptions for IPC.
12:55:48 <danielsmw> sternmull: hmm... what lines can't be parsed? 
12:56:09 <geekosaur> I don;t think you will be able to rely on error
12:56:15 <artagnon> codeshot: The code in question is: https://gist.github.com/artagnon/5208a3a6988b35caabb78631aabd5943
12:56:21 <geekosaur> unless they were *very* careful with their message processing
12:56:22 <infinisil> codeshot: I'll just use what I have for now, will look at StateT and stuff later, thanks though!
12:56:34 <artagnon> geekosaur: It's "poorly written" then?
12:56:41 <sternmull> danielsmw: "haskell-src-1.0.2.0 (via: qtah-generator-0.3.0 hoppy-std-0.3.0" and a few more (don't want to spam them here)
12:57:03 <geekosaur> possibly. I wasn't expecting anyone to try to use exceptions as inter-task communication; that's rather hard to get right
12:57:28 <MarcelineVQ> sternmull: he's asking to see the cabal file that is giving you the error
12:57:36 <artagnon> So if `error` can't work, what will?
12:57:57 <danielsmw> sternmull: yeah, seeing the cabal file would be most helpful
12:58:00 <geekosaur> and, uh, I see in the docs: "Error handling is explicit: every function declares as part of its type which errors it can return (no exceptions are thrown)"
12:58:08 <geekosaur> which suggests to me they know about this and consider it a feature
12:58:33 <geekosaur> you're not *supposed* to use exceptions, including 'error'
12:58:53 <artagnon> Ah, I see. Then what am I supposed to do?
12:59:59 <sternmull> danielsmw: http://lpaste.net/2147533134613184512 i just did "stack new qt-test", added  ", qtah-qt5" and ran "stack solver"
13:00:01 <geekosaur> if it was not clear, I am just reading through their docs, I do not know Distributed Haskell
13:00:45 <artagnon> Yes, I understand. I was reading the Hackage doc, but reading that GH page now myself.
13:00:51 <geekosaur> but the line I quoted earlier suggests you are not supposed to do things that way. "Error handling is explicit: every function declares as part of its type which errors it can return (no exceptions are thrown)"
13:02:01 <artagnon> Yes, but as a general Haskell question: how do you report any failures without exceptions?
13:02:22 <dsal> Doing it *with* exceptions is so much harder.
13:02:24 <danielsmw> sternmull: ah, okay
13:02:27 <dsal> Either or Maybe are way better.
13:03:05 <danielsmw> sternmull: so i followed your steps. stack new qt-test, then i added qtah-qt5 to my build depends. then stack build said I should add it to my stack.yaml. is that where you are?
13:03:17 <artagnon> So, do I `liftIO . putStrLn`?
13:03:42 <artagnon> dsal: Either or Maybe is fine, but I want something printed on the screen.
13:04:34 <danielsmw> sternmull: or at least, does that summarize the steps youve taken so far?
13:04:55 <dsal> Printed to what screen?  When?
13:05:11 <sternmull> danielsmw: Yes. I think i just failed to read the full error message. It tells to include the version number for the yaml, i get a step further if i do that.
13:05:48 <artagnon> For instance, I have a deserialization as a set of functions where each function does some Either or Maybe -- now, I want to know which function failed.
13:05:52 <danielsmw> yeah. just keep copy/pasting that stuff in to your stack.yaml, replacing hyphens with commas. i'm getting a successful compilation after 2-3 rounds of that.
13:05:56 <danielsmw> ^ sternmull
13:06:09 <dsal> Either can tell you what failed.
13:06:14 <artagnon> Currently, I do `maybe (error "This failed")` or `either (error . show)`
13:06:43 <artagnon> Replace `error` with `liftIO . putStrLn`?
13:07:12 <artagnon> How do I distinguish between message I'm printing to the screen for informational purposes and errors then?
13:07:23 <sternmull> danielsmw: Thanks. Should have tried harder. Now it started to build.
13:07:39 <artagnon> How do I get file-line information in that `putStrLn`?
13:07:54 <danielsmw> sternmull: cool. hope the build actually finishes, I didn't wait to see if mine did :)
13:08:02 <dsal> I'm not quite understanding the fundamental approach you're taking.  Very little of my code prints anything at all.
13:08:15 <dsal> Of the stuff I've been doing lately, almost none of it has anything related to IO.
13:08:56 <dsal> It's a bunch of gross complex parsing of data generated by people who can't read specs.  When something doesn't parse the way I expect, I add a unit test for it and try to figure out what they meant.
13:09:29 <artagnon> I'm having a problem with unit testing too ... everything is nested inside a big monad stack.
13:10:11 <dsal> There's a commandline tool I wrote on top of that library that connects to a socket and reads packets off of it, parses them, and dumps them (color coded) to the screen.  If something can't be parsed at all, it shows up in red as a thing I need to think about.
13:10:46 <artagnon> dsal: Is it open source?
13:11:00 <dsal> Yeah.  It's not super useful yet.  Just junk I'm writing that's interesting to me.
13:11:04 <artagnon> (Maybe I can derive some inspiration from it)
13:11:07 <dsal> https://github.com/dustin/haprs
13:12:52 <dsal> attoparsec, in particular, can give pretty useful error messages when you need them, but I only do that when I'm confused.  (e.g., it'll tell me it couldn't find a digit or something, and I'll add some attributions around that to drill down).   It's not that useful for the high level parser, because the error message would be something like, "I tried a lot of things and nothing worked."
13:15:52 <dsal> exceptions are "convenient" in that error will satisfy any type and give you a convenient means of creating a partial function, but using partial functions is not that fun.
13:18:12 <sternmull> danielsmw: Ha. Got the notpad example running :)
13:28:59 <artagnon> dsal: I agree, but sometimes the type signatures constrain you -- how do you not `fromMaybe` in this case? https://gist.github.com/artagnon/c8898893764ff8b8704c3a2ddd995ff7
13:29:42 <dsal> I'd probably use fail there.
13:29:44 <dsal> :t fail
13:29:46 <lambdabot> Monad m => String -> m a
13:30:26 <dsal> It's a parser, so it's already got a failure path.  You're just jumping around it with an exception.
13:32:19 <Wizek> Is it possible somehow to have a polymorphic `Dynamic` value? e.g. `toDyn id`?
13:33:14 <Wizek> I could do the conversion with unsafeCoerce readily to an opaque value, but how could I persist a polymorphic TypeRep?
13:33:15 <artagnon> dsal: What does `fail` do exactly? What will happen when I call my new `fail` function?
13:36:47 <dsal> I guess lambdabot doesn't expose attoparsec or whatever.
13:36:57 <dsal> λ> A.parseOnly (fail "didn't work") "some string"
13:36:57 <dsal> Left "Failed reading: didn't work"
13:37:37 <dsal> It's like any other parser failure.  You're looking for specific stuff.  If you don't find the stuff you're looking for, you fail it.
13:37:57 <rotaerk> Hmm, realized I'm not sure on the correct usage of the term "abstract"
13:39:07 <rotaerk> Is it correct to say that parameters abstract values from a function, or that the function itself is abstracted
13:39:32 <Tuplanolla> What use is saying either, rotaerk?
13:40:59 <dminuoso> rotaerk: all parameters are, is elements from a functions domain.
13:41:04 <artagnon> dsal: Learning little by little ... is this a poor signature? What is `fail` in the context of IO? In the case of `Parser` it's probably a parser error. https://gist.github.com/artagnon/b6a32596d283f000c5162d2fbbff0656
13:41:42 <Wizek> it seems someone make this work for rank1: https://hackage.haskell.org/package/rank1dynamic-0.4.0/docs/Data-Rank1Dynamic.html
13:42:06 <artagnon> I can't imagine what `IO PublicKey` I get back from this function on failure.
13:42:16 <dsal> Well, that returns IO PublicKey -- why not    IO (Either String PublicKey)  ?
13:42:34 <dsal> Yes, because the parser always returns   Either String a
13:42:35 <rotaerk> dminuoso, that's one perspective of what a parameter is.  It's true but it doesn't mean there aren't other ways of characterizing then
13:43:07 <artagnon> Yeah, that's a good idea, but I want to know what `IO PublicKey` I can possibly get back for this type-consistent function.
13:44:06 <rotaerk> The concern I have is, an abstraction generally involves capturing some core concept and ignoring details that change from case to case
13:44:43 <rotaerk> But are the details abstracted, or is the core concept abstracted
13:44:54 <dsal> artagnon: That's up to the monad.  IO will throw an asynchronous exception.  This is where confusion beigns.
13:45:02 <dsal> If you do the easy thing, it's a lot easier to not be confused.
13:45:18 <artagnon> Got it, thanks for the explanations!
13:46:04 <artagnon> Better? https://gist.github.com/artagnon/b6a32596d283f000c5162d2fbbff0656
13:46:06 <Tuplanolla> Abstraction is the process of forgetting details, rotaerk. Whatever you end up with is more abstract than whatever you started with.
13:46:26 <artagnon> I'm a little surprised that fail auto-Lefts.
13:47:20 <dsal> I'm not even sure what you mean.
13:48:06 <rotaerk> Right, going from IO and Maybe to Monad is abstraction, because you capture the core concept of the Monad operators and the laws, and forget the details of their implementation
13:48:08 <Tuplanolla> If you try to abstract foundational concepts like functions or truth itself, you will either end up doing philosophy or nothing useful at all.
13:49:17 <artagnon> Never mind, I think I understand how to do this now. Thanks again!
13:49:33 <rotaerk> But in such an event, is the concept of Monad abstracted from IO and Maybe, or are the implementations abstracted from them to leave behind Monad
13:50:46 <dsal> artagnon: Keep in mind, you won't see an exception from that extractPublicKey call until you try to use the return value of it.  This is why things get very confusing.
13:51:12 <artagnon> Yeah, the pervasive laziness.
13:51:15 <dsal> So don't use fail there, use Left.
13:52:01 <rotaerk> Tuplanolla, I was only using functions as an example
13:52:11 <Tuplanolla> If you forget everything, you end up with the most abstract possible concept. It has nothing in common with anything else and is unique up to isomorphism.
13:52:48 <ivans> "either philosophy or nothing useful at all"
13:52:52 <ivans> TIL there's a difference :p
13:53:03 <Tuplanolla> It's not an exclusive or, ivans.
13:53:26 <ivans> touche
13:58:25 <rotaerk> Functions are abstractions of expressions, where details are sub-expressions replaced by parameters 
13:58:51 <rotaerk> The forgotten details *
13:59:52 <Tuplanolla> Does that imply that `id` generalizes everything?
14:02:03 <rotaerk> Pretty much, it's the most trivial of such abstractions
14:03:33 <_sideeffect> what is the difference between dynamic and static binding, and are they even closely related to lazy evaluation?
14:05:33 <rotaerk> I'm just trying to figure out the direct object of the verb "abstract", which literally means to extract it remove.  Are the details removed from the concrete cases to produce the abstraction, or is the abstraction extracted from the concrete cases leaving behind the details.  It just matters for how I form my sentences...
14:06:52 <lambdamu_> _sideeffect: I'm not sure what exactly dynamic and static binding refers to, but if you mean something akin to dynamic and static dispatch known from OOP languages, then I would say that hasn't anything to do with lazy evaluation
14:07:35 * geekosaur wonders as to the context
14:07:43 <rotaerk> To extract or remove*
14:07:50 <artagnon> dsal: Doesn't seem to help; my program just hangs when I do this: https://gist.github.com/artagnon/cb3417e43a2c616e0cb920949309902b
14:08:02 <geekosaur> because all I can think of is dynamic vs. static linking, and that has nothing whatsoever to do with evaluation; it's part of compilation
14:08:30 <artagnon> Where is the (async or not) exception being thrown?
14:09:00 <geekosaur> there's also runtime symbol binding which also has little to do with evaluation, although lazy binding may occur as a side effect --- but that's unrelated to the language, ti's related to the underlying system runtime;'s handling of references into shared object
14:09:02 <geekosaur> s
14:22:02 <dsal> artagnon: Hard to say, but I wouldn't put the whole program under a match from a case.   I don't have enough about your other bits to know what's going on here...   What is spawnLocal?  What does it do when with the return value from the Left case?
14:23:17 <artagnon> dsal: I don't want to put the whole program under a case-match either, this was just a quick demo.
14:23:19 <artagnon> :t spawnLocal
14:23:21 <lambdabot> error: Variable not in scope: spawnLocal
14:23:40 <dsal> @hoogle spawnLocal
14:23:40 <lambdabot> No results found
14:24:16 <artagnon> ```spawnLocal :: Process () -> Process ProcessId Source
14:24:16 <artagnon> Spawn a process on the local node```
14:24:58 <artagnon> I wonder why distributed haskell isn't so popular ... especially with the amount of ds we need to do today.
14:25:29 <dsal> Heh.  You're also wondering why it's mysteriously hanging.  :)
14:26:54 <artagnon> so the "Process" is "printing a string to stdout", I'm guessing.
14:27:02 <orion> Is it possible to use a mixin/instantiate a signature with an executable?
14:27:24 <artagnon> It wasn't able to return a ProcessID because the process immediately "exited"?
14:27:47 <bsima> :t (-&-)
14:27:48 <lambdabot> error: Variable not in scope: -&-
14:28:03 <dsal> You can't just like, not return a value from a functio.
14:28:21 * artagnon laughs
14:28:34 <artagnon> I thought *this* is what types were designed to protect against!
14:29:16 <dsal> Sure, but then people add exceptions and confuse everything.  If it compiles, you're at least declaring what type you intend to return, but if an exception is being thrown in here somewhere, then who knows.
14:30:08 <artagnon> Where is the exception here?
14:30:27 <artagnon> I'm not doing any `throwIO` or even `error`.
14:31:14 <dsal> I don't even know that there *is* an exception.  Can you simplify the function some?
14:31:34 <artagnon> Sure, just a sec.
14:33:33 <pavonia> What was that data type called where you have Either a b + (a,b)
14:33:53 <artagnon> What the heck is going on? https://gist.github.com/artagnon/cb3417e43a2c616e0cb920949309902b
14:34:06 <lambdamu_> pavonia: These
14:34:14 <artagnon> `liftIO` is a lie.
14:34:35 <pavonia> lambdamu_: Ah, thanks
14:37:01 <dsal> What did that do?
14:37:10 <artagnon> Hang mysteriously :)
14:37:19 <artagnon> Without printing anything.
14:37:44 <dsal> Maybe it hasn't spawned locally yet.
14:38:00 <artagnon> Why not?
14:38:16 <artagnon> What's preventing it from spawning a thread doing a print?
14:38:37 <dsal> I didn't write that framework, and don't have any familiarity with it.
14:38:56 <artagnon> I know, we're all guessing.
14:41:41 <geekosaur> I do wonder if you'd be better served with something like async inshead of DH
14:41:44 <geekosaur> *instead
14:41:53 <geekosaur> @where parallel
14:41:53 <lambdabot> http://www.haskell.org/haskellwiki/Parallel
14:41:57 <geekosaur> sigh
14:42:48 <geekosaur> @where parconc
14:42:49 <lambdabot> http://chimera.labs.oreilly.com/books/1230000000929
14:43:09 <geekosaur> "Parallel and Concurrent Programming in Haskell" (free access)
14:43:40 <dsal> Yeah, I stuck a    `using` parList rdeepseq    at the end of a function call once and it magically got faster.
14:43:49 <boj> artagnon: if i recall it's because of laziness. nothing is demanding the output, so the prints are queued until you exit (at which point they print?)
14:44:09 <artagnon> boj: No, they don't print on exit either.
14:45:21 <boj> slide Debug.Trace.traceIO calls in there instead to prove they get called period?
14:45:29 <ggVGc> man
14:45:38 <ggVGc> haskell code that throws exceptions really bother me
14:46:22 <johnw> it would be worse if it just hoarded them for itself
14:47:01 <ggVGc> my main issue is that it doesn't show in the types
14:47:06 <ggVGc> so you can't know
14:47:07 <ggVGc> other than IO
14:47:21 <johnw> think of Haskell as being composed of two domains
14:47:29 <johnw> the domains of types, which relate to evaluation
14:47:37 <johnw> and the domain of IO, which relates to execution of the runtime
14:47:44 <johnw> exceptions are failures in the latter domain
14:48:00 <johnw> failures in the former domain must be represented as a possibility in the type
14:48:19 <ggVGc> sure, but I's still like to be able to know what throws exceptions, and maybe even have checked exceptions
14:48:27 <johnw> another way to put it is: we don't have a specified semantics for the runtime
14:48:27 <artagnon> boj: One sec, will try.
14:48:42 <johnw> ggVGc: there is a library that attempts to provide checked exceptions
14:48:54 <artagnon> geekosaur: I went for DH because I thought it'd make my life simpler :(
14:50:00 <ggVGc> I think the main problem with exceptions in all contexts is that people throw exceptions for non-exceptional situations
14:50:24 <ggVGc> right now I'm using a library which in turn uses a REST client library, and the latter throws exceptions when a request fails
14:50:29 <geekosaur> (there's a 'have at thee artagnon' sour joke hiding in here somewhere)
14:50:30 <ggVGc> I don't think that's exceptional at all
14:51:09 <dsal> I was using a (the?) regex library and found that it threw exceptions on bad source data.
14:51:17 <dsal> Not only could it fail a match, but it could also throw an async exception.
14:51:32 <lambdamu_> ggVGc: I agree, I find it annoying that I can't easily figure out what can be thrown by which function, but I only care because people use exceptions for things that aren't exceptional, as you say
14:52:10 <dsal> On the plus side, I rewrote all the code in attoparsec and it's hugely faster and actually solves the problem much better.
14:52:12 <lambdamu_> Exceptions by themselves aren't a problem, all code can fail
14:52:25 <artagnon> boj: Still silent: https://gist.github.com/artagnon/cb3417e43a2c616e0cb920949309902b
14:53:17 <lambdamu_> I like exceptions much more the way panic is used in Rust
14:53:19 <boj> artagnon: i suspect you have a different problem then :)
14:53:32 <artagnon> Not an exception problem?
14:53:46 <artagnon> Just hanging mysteriously?
14:53:57 <boj> "mysteriously" indeed
14:54:04 <Tuplanolla> I think this problem stems from our lack of a panic mechanism.
14:54:29 <Tuplanolla> There should be some sort of a difference between recoverable and unrecoverable exceptions.
14:54:56 <MarcelineVQ> oh that's easy, the recoverable ones use throwIO
14:55:27 <boj> artagnon: is it possible your extractPublicKey is silently failing somehow?
14:56:27 <lambdamu_> Tuplanolla: My current opinion is that exceptions shouldn't be used in recovery at all
14:56:31 <artagnon> boj: You can look at it if you like; I removed all exceptions from it: https://gist.github.com/artagnon/b6a32596d283f000c5162d2fbbff0656
14:58:05 <lambdamu_> Tuplanolla: Damage control maybe, but using a library in way that can trigger an exception would be always a bug to me, then I would either change the library or my code
15:02:57 <boj> artagnon: DH really is a weird beast. i'd start liberally sprinking traceIO around until i saw what i forgot to do, or what silently failed
15:03:23 <artagnon> boj: Thanks for the tip.
15:03:33 <artagnon> I have to reverse-engineer this thing.
15:03:43 <boj> nothing is immediately obvious, that is the best i've got :(
15:05:16 <artagnon> I literally wrote the whole program without testing anything and trusting the types ... now, running it is a nightmare.
15:05:42 <ij> Are there any regex replace functions in some stackage package?
15:05:56 <artagnon> Silent failure + laziness is the worst combination.
15:06:29 <dsal> @hoogle regex
15:06:30 <lambdabot> Web.Scotty regex :: String -> RoutePattern
15:06:30 <lambdabot> Web.Scotty.Trans regex :: String -> RoutePattern
15:06:30 <lambdabot> Data.Text.ICU regex :: [MatchOption] -> Text -> Regex
15:06:38 <dsal> Well that's useless
15:07:11 <ij> I'll guess I'll just add text-regex-replace to extra deps
15:12:02 <dsal> Last time I used regex I had an issue with it and someone recommended just using *parsec.  That was a tremendous improvement.
15:12:25 <ij> Ain't gonna use parsec just to remove some newlines.
15:12:36 <dsal> I wouldn't use a regex for that.
15:12:47 <dsal> filter (/= '\n')
15:13:14 <ij> How would you make occurences of " (\r\n)+ " into " // "?
15:13:15 <geekosaur> "some" newlines
15:13:46 <geekosaur> but I suspect simple Haskell pattern matching would work better than trying to get fancy with regex or parser combinators
15:13:58 <ij> I used this with text-regex-replace: replaceAll (regex [Multiline] " *(\r\n)+ *") (rtext " // ")
15:14:32 <zachk>  > unwords . lines $ "hello\nworld"
15:14:42 <zachk> > unwords . lines $ "hello\nworld"
15:14:44 <lambdabot>  "hello world"
15:14:59 <dsal> > Data.Text.replace "\r\n" "//"  "This\r\n?"
15:15:01 <lambdabot>  error:
15:15:02 <lambdabot>      Not in scope: ‘Data.Text.replace’
15:15:02 <lambdabot>      No module named ‘Data.Text’ is imported.
15:15:06 <dsal> damn.
15:15:16 <ij> dsal, You could try that in /query or ghci first, you know.
15:15:32 <dsal> Sure... but why wouldn't that work?  :)
15:15:53 <ij> There are whole new packages needed just to do a regex replace.
15:15:55 <dsal> It works fine in ghci.  I'm just surprised lambdabot doesn't have Data.Text
15:15:59 <zachk> you could use a map if its character to character
15:16:22 <lavalike> or sed
15:16:24 <dsal> Regex would be slower and less reliable, but it wouldn't be easier.
15:16:33 <ij> lavalike, That's ridiculous.
15:16:37 <lavalike> haha
15:17:28 <ij> Regex, in this case, is very much reliable, what are you takling about? " *(\r\n)+ *" → " // " is very straight-forward and easy
15:17:43 <dsal> How much have you used regex in haskell?
15:17:52 <ij> Quite a bit.
15:18:05 <ij> geekosaur, :) Grammar's simple this time.
15:18:13 <zachk> I recollect segfaulting one time using regex's in haskell
15:18:29 <dsal> I didn't have it segfault, just throw exceptions and complicate my call points.
15:18:43 <bsima> anyone know what (-&-) is?
15:18:51 <dsal> Had to use evaluate and a bunch of other stuff.
15:19:22 <begriffs> I'm thinking about how to manage GHC and package versions on my system. Back in the old days I used to have a big place where all packages co-existed, and there were some cabal problems. Then I switched to cabal sandboxes and it involved lots of recompiling. Then I used stack and it works fine. However, I'm wondering if there's a simpler way nowadays?
15:19:28 <begriffs> Is there a more "unix" way to do things, like managing GHC versions with GNU Stow? And yes there is nix, but I'm looking for a more familiar way to do things with normal unix utilities.
15:20:06 <lavalike> bsima: is it perchance http://hayoo.fh-wedel.de/?query=%28-%26-%29
15:20:51 <boj> begriffs: i think you've described all we have at this point
15:21:57 <dsal> bsima: hoogle hasn't heard of it.  Was it created in your project?
15:22:13 <bsima> no i'm reading this API docs http://hackage.haskell.org/package/stripe-core-2.2.3/docs/Web-Stripe-Charge.html
15:24:18 <dsal> bsima: http://hackage.haskell.org/package/stripe-core-2.2.3/docs/Web-Stripe-StripeRequest.html
15:24:39 <Wizek> Why does --profile (with stack) require many (all?) dependent packages to be rebuilt? And could I just not profile the functions in my own package, treating everything below as black boxes?
15:24:40 <lambdamu_> begriffs: Have you tried cabal new-build? I use and it works great
15:24:59 <Wizek> -not
15:25:58 <lambdamu_> begriffs: Not sure what constiutes simple for you, though, and I don't know GNU Stow
15:26:15 <geekosaur> Wizek, because laziness means profiled stuff can happen in the non-profiuled library, and because apparently profiling libs are not ABI compatible with non-profiled
15:27:01 <Wizek> geekosaur: that's a shame
15:28:20 <Wizek> geekosaur: would you then happen to know if stack is intelligent enough nowadays to at least only do this recompilation once per package and keep those around? It used to just delete all of them and recompile everything when I switched from --profile and back
15:28:36 <geekosaur> that I do not
15:28:44 <begriffs> lambdamu_: I haven't tried it yet. It basically allows us to store all packages together in one place again?
15:28:52 <bsima> dsal: thanks, I couldn't find it b/c of implicit imports i guess
15:29:00 <Wizek> geekosaur: off I go duplicating my work folder then to find out, I guess
15:29:07 <dsal> bsima: I just downloaded the source and grepped.  heh
15:29:08 <Wizek> geekosaur: thanks for the info
15:30:09 <bsima> ah! good thinking.
15:31:50 <lambdamu_> begriffs: It works similar to stack and nix, you don't have a manually managed global db, but it caches packages keyed by configuration in some global place
15:32:06 <Wizek> geekosaur: (or anyone else) btw, maybe you know if there are any plans, or at least a trac ticket/GHC proposal to make them have the same ABI?
15:32:45 <geekosaur> I don't know of one, and ghc is finicky enough that I wouldn't want to assert whether it's even possible
15:33:18 <begriffs> lambdamu_: oh by the way I just discovered that search engines are my friend. :) https://byorgey.wordpress.com/2012/11/01/using-multiple-versions-of-ghc-in-parallel-with-gnu-stow/
15:33:31 <artagnon> This is a lost cause; I think I'm going to write unit tests for now. HSpec?
15:34:21 <begriffs> So I might be able to stow different ghc versions, and use cabal new-build to manage the packages. Worth a try.
15:34:27 <average> hi
15:34:37 <lambdamu_> begriffs: Well there you go, cabal new-build doesn't sandbox GHC afaict, if that is what you want
15:34:51 <dsal> artagnon: I'm not a fan of spec for tests at all.  I like either quickcheck or hunit.
15:34:52 <average> just so you know, every time I'm here, I am here to assess the practical aspects of Haskell, its eco-system, monetization, and generally down-to-earth real-life topics
15:34:54 <average> I have good news
15:34:58 <lambdamu_> begriffs: stack did that if I remeber correctly
15:35:10 <dsal> artagnon: There's good info here:  http://dev.stephendiehl.com/hask/#testing
15:35:22 <average> Haskell's eco-system has been able to produce a real gem. It's obviously a diamond covered by a thick layer of dust, practically unknown
15:35:23 <artagnon> dsal: Thanks, reading.
15:35:35 <average> I want to promote this piece of software because there's too much crap Haskell codebases out there
15:35:41 <average> of no real value or utility
15:35:45 <average> so here's what I like
15:35:46 <average> https://github.com/BurntSushi/erd
15:36:00 <average> erd, an amazingly promising and to-the-point entity-relationship diagram generator
15:36:02 <average> I love it
15:36:23 <average> nobody knows about it i"m sure, they're too busy with catamorphisms and functors
15:37:02 <lambdamu_> average: So do you have some links to crap haskell codebases, too?
15:37:03 <average> my list of Haskell products of real practical value is really small.. but every 6 months, I find another piece of Haskell that attracts my attention in a positive way
15:37:10 <average> so I thought I'd drop by and share it with you :)
15:37:26 <average> lambdamu_: basically most of them. Pick a random one, high probability it will be crap
15:37:52 <dsal> http://github.com/dustin/haprs
15:37:57 <dsal> I just wanted to list my library below average
15:38:01 <average> I think it's my duty as a programmer that's been around, after all I'm 31 now..
15:38:11 <average> it's my duty to educate people on what's useful and what's not
15:38:21 <average> so.. I'm here from time to time to drop some knowledge on you guys
15:38:27 <average> that's it for tonight
15:38:30 <dsal> Thanks for the warning.
15:38:33 <average> </transmission>
15:38:34 <boj> still young and arrogant then. you have a ways to go grasshopper
15:38:44 <dsal> Eh, that's why we have /ignore
15:38:54 <boj> indeed
15:39:13 <dsal> The older I get, the more I realize the less I know.
15:39:43 <average> The older I get, more stuff seems useless, and I get a very good sense of what is useful and what's not
15:40:01 <average> I'm a practician
15:40:09 <average> just so you people know a bit about me
15:40:19 <boj> and humble no doubt
15:40:34 <begriffs> average: yeah erd is cool, I've used it for making illustrations in database docs. Pandoc is cool, and shellcheck comes in handy as well.
15:40:35 <ivans> so 31 is old and experienced nowadays :D
15:40:44 <average> yes I fully agree begriffs 
15:40:46 <average> that's kindof my list too
15:40:47 <ivans> now that makes me feel old
15:41:01 <systemfault> I must be a grandfather at 35.
15:41:12 <average> there's very little beyond that list begriffs , that's how I feel
15:41:18 <dsal> 35?  When I was your age, I was at least 38.
15:41:45 * geekosaur *eyeroll*
15:41:47 <average> I'm here to educate you, regardless of your age
15:41:54 <average> you should consider yourself lucky to have me here
15:42:07 <average> so.. enjoy me while you have me here as your guest
15:42:18 <Wizek> ij In case your regex question is still relevant: have you heard of/tried http://regex.uk/ ?
15:44:20 <average> I want to see Haskell drop the smart alec mentality, and enter an industrial mindset. I hope in the future there will still be room for the funky stuff, but I want to see that part shrink. I want to see things around robustness and utility be emphasized more.
15:44:42 <average> those are my wishes for 2018
15:44:51 <ij> Wizek, hmmmm, why didn't I find it somewhere
15:45:23 <codeshot> Psybur, I figured out why every fib was memoized by ghc (including intermediates)
15:45:27 <average> and frankly, in the long run, I never want to see "written in Haskell" in the headline of a serious github project
15:45:41 <Wizek> artagnon: There is no shame in unit testing. I myself use hspec extensively and quite like it. It also integrates well with quickcheck when I want reach for that on occasion.
15:45:47 <average> you never see anyone writing a useful Bash script brag about "omg, I wrote this in Bash"
15:46:26 <codeshot> average, the funky stuff is important
15:46:29 <codeshot> we already have erlang
15:46:30 <average> there's zero difference in my mind as to what it's written in. I just want it to do what it says it does, and be useful.
15:46:32 <codeshot> just use that
15:46:36 <codeshot> job done
15:46:55 <artagnon> Wizek: Thanks for that perspective. It integrates well with QuickCheck apparently.
15:47:13 <average> codeshot: ok.. then I want a clear distinction between the useful part and the funky stuff
15:47:16 <dsal> artagnon: Things got a lot easier for me when I started running everything through tasty.  Just a mix of hunit and qc properties.
15:47:28 <codeshot> there isn't a distinction, you need a new universe
15:47:29 <Psybur> codeshot, what do you mean? It will memoize without anything special? I did not encounter that in my trials
15:47:34 <codeshot> or more vision
15:47:39 <codeshot> yes
15:48:06 <codeshot> Psybur, from my posted version where I adjusted the list to [500, 300000, 400000, 400001, 299999]
15:48:13 <lambdamu_> average: I agree that language isn't important, but you should drop that smug act, makes you appear mentally ill
15:48:16 <codeshot> 400001 was instant as was 299999
15:48:20 <Wizek> ij: it's relatively quite new and not yet well known. IIRC there were only just a few posts on reddit/r/haskell about it. But I tried it a few times and its API I fould quite high quality
15:48:34 <ij> Wizek, Cool, man. :)
15:48:40 <ij> Thanks for the heads up.
15:48:50 <average> lambdamu_: if you use strong language like that, then I didn't make mysefl understood at all
15:48:53 <codeshot> that's because fibs was shared across all loops, so ghc kept every element of that list in memory
15:48:55 <Wizek> ij: sure thing :) 
15:48:59 <average> which is ok, there were some deep ideas in what I said
15:49:03 <codeshot> were you using ghc or another compiler?
15:49:06 <average> maybe re-reading what I wrote will help
15:49:29 <lambdamu_> average: I didn't use strong language and what you wrote isn't wrong but not very deep sorry
15:49:32 <dsal> average: Perhaps you're not very good at communicating and/or what you have to say isn't important or interesting.
15:49:39 <codeshot> but then exit from the program was very slow because of ineffective heap cleanup that resulted
15:49:59 <Psybur> codeshot, im using ghc
15:50:14 <average> dsal: the people complaining are usually not my target audience. like I said, I'm a practician
15:50:59 <Psybur> my version doesnt speed up overlapping numbers. your scan version does?
15:50:59 <hexagoxel> average: so what useful product would you like developed in haskell, and how much are you willing to pay for it? i assume you wish to help this community grow, right?
15:51:01 <codeshot> average, there were no deep ideas, the practical stuff you've been talking about has engineering solutions. Functors and the maths are required to do the next step
15:51:12 <average> but do note that there's one person in this channel who perfectly understood me
15:51:16 <average> it's begriffs
15:51:26 <average> and I barely know them, maybe saw them once before..
15:51:30 <average> on irc
15:51:37 <dsal> average: You're just some random guy who thinks entirely too much of himself showing up in a language-specific channel talking about how you want to change how people use the language because it's not important.
15:52:03 <boj> we used to call that trolling. not sure what the term is these days
15:52:08 <codeshot> average, did begriffs agree with you?
15:52:12 <average> yes he did
15:52:21 <codeshot> don't mistake agreement for understanding
15:52:21 <average> and his list overlaps quite a lot with mine
15:52:25 <codeshot> or the converse
15:53:00 <wolfcub> is there any expectation that template haskell or something like it will be incorporated into the next standard?
15:53:50 <average> 01:50 ( codeshot) [..] Functors and the maths are required to do the next step
15:54:08 <average> to be honest.. I am following some math-related codebases, for example sympy
15:54:17 <geekosaur> the standard still wants to be lieve that there can be multiple implementations of Haskell. TH is tightly tied to GHC's internals
15:54:30 <average> that is borderline useful and funky
15:54:39 <average> but Haskell does not have anything like that
15:55:09 <dsal> Perhaps you should write the useful thing you think should exist instead of complaining?
15:55:11 <average> and "next step" sounds very vague
15:55:21 <average> dsal: not complaining at all
15:55:52 <dsal> "I want to see Haskell drop the smart alec mentality, and enter an industrial mindset"
15:56:02 <average> yeah, that's just a personal wish
15:56:05 <average> or hope
15:56:33 <ggVGc> bet average is high
15:57:03 <dsal> Yeah, that makes more sense.  Trolls used to at least have some kind of plausibility.
15:57:21 <geekosaur> yeh, I was thinking same
15:57:38 <ggVGc> I have a confession
15:57:50 <Adluc> Hello, is it possible to have deriving (Show, Eq) after every data declaration implicitly?
15:57:53 <ggVGc> the more I use haskell, the more I want to just keep it ultra simple and stay away from the advanced parts of the type system
15:57:54 <wolfcub> geekosaur are you aware if theres any proposal of th alternatives?
15:58:31 <lambdamu_> Adluc: I don't think so
15:58:35 <Adluc> :(
15:58:46 <codeshot> average, I mean to get the things you asked about, use erlang
15:58:48 <Adluc> lambdamu_: okay, thanks anyway
15:58:52 <lambdamu_> Adluc: To much boilerplate?
15:58:56 <Wizek> Adluc: perhaps TH or custom preprocessors could help uou
15:58:58 <Adluc> yea, for parser
15:58:58 <codeshot> if the functors and stuff isn't important then that's enough
15:59:05 <Adluc> I'll have a look
15:59:30 <Adluc> Anyway, have to show off a bit, working on gerber parser https://www.pastiebin.com/5a0f619f4787f
15:59:39 <dsal> It's a bit weird to think of erlang as a "practical" haskell.
16:00:32 <Wizek> Adluc: to be a bit more specific, I'm quite sure you could reduce such boilerplate, perhaps even quite simply with something similar to `{-# OPTIONS_GHC -F -pgmF hspec-discover #-}`
16:01:11 <ggVGc> yeah I don't see much overlap of haskell and erlang
16:01:32 <Adluc> Wizek: lol, it looks like it works!! :D
16:01:49 <ggVGc> erlang's only real main focus is runtime fault tolerance and concurrency
16:01:49 <Adluc> srk: ^
16:01:59 <codeshot> Psybur, I'm sending you a tarball containing terminal sessions that can be played with replayscript: http://www.noiseaddicts.com/samples_1w72b820/4638.mp3
16:02:00 <ggVGc> both of which are not really main concerns of haskell at all
16:02:06 <Wizek> Adluc: *That* quickly?!
16:02:28 <Adluc> yea :D
16:02:37 <Wizek> Adluc: what did you do?
16:02:42 <ggVGc> in a way I'd actually argue that haskell is the opposite of erlang, in mindset
16:02:45 <dsal> In particular, erlang's types are *super* simple -- in a way that's really nice for how you use them, at least.
16:03:04 <ggVGc> haskell wants to prevent errors by not compiling incorrect programs. Erlang wants to run anything, and do the best it can when it fails
16:03:04 <Adluc> just added {-# OPTIONS_GHC -F -pgmF hspec-discover #-} on top of the file, and added hspec to cabal depends
16:03:11 <Adluc> Wizek: ^
16:03:26 <Adluc> oh wait no
16:03:48 <ggVGc> man I hate my code
16:03:55 <ggVGc> and I don't want to write it anymore
16:04:03 <ggVGc> but I'd like to have the result
16:04:08 <dsal> I've been sitting in R all day.
16:05:30 <Wizek> I'd be surprised hspec-discover itself would give you such automatic deriving. I was mentioning that you may be able to whip together a similar such preprocessor quickly.
16:05:50 <Wizek> relatively
16:05:56 <Wizek> not in seconds though :D
16:05:59 <Wizek> likely
16:06:10 <Wizek> Adluc: ^
16:06:50 <Adluc> :D well, yea, though you gave me the magic one-liner that worked at first
16:06:54 <Adluc> *thought
16:07:03 <Adluc> I will have a look at some preprocessing
16:07:16 <Wizek> ggVGc: What do you hate about your code?
16:09:22 <lambdamu_> Adluc: You could use TemplateHaskell and StandaloneDeriving but you would still have to list all your data types as in genInstances [''TypeA, ''TypeB, ..]
16:09:47 <Wizek> lambdamu_: Actually, not even necessarily!
16:10:14 <Wizek> Couldn't you get (reify?) all local definitions with TH?
16:10:14 <lambdamu_> Wizek: No, you can't enumerate the scope afaik
16:10:45 <ggVGc> Wizek: just bored of writing code
16:11:04 <Wizek> lambdamu_: even if not explicitly, you could still read the current whole file that is being compiled
16:11:17 <Wizek> lambdamu_: from that it would be possible to yank ouy all data definitions
16:11:34 <lambdamu_> Wizek: Well yes you can do arbitrary IO and reparse the hs file :D
16:11:46 <Wizek> lambdamu_: exactly
16:12:14 <lambdamu_> You can also write a code generator, I wouldn't consider that a solution as much as a fireable offense, though
16:12:17 <Wizek> that way all one would need to invoke on top level is `$(derilveAll)`
16:12:57 <Wizek> lambdamu_: what kind of code generator do you mean?
16:13:43 <lambdamu_> Wizek: whichever kind you like, a thought of a preprocessor
16:14:10 <lambdamu_> Well I guess you could use CPP macros anyway
16:15:06 <Wizek> lambdamu_: well, wouldn't you be surprised to learn that the exact thing I suggested above was a custom preprocessor :D
16:16:09 <Wizek> and as things stand, that would likely be easier to pull off, especially for someone relatively new to haskell than using TH for this.
16:16:10 <lambdamu_> Wizek: Well I guess that is the standard escalation path, can haskell do that? can _ghc_ do that? can TH do that? can CPP do that? ... code generator
16:17:04 <lambdamu_> I think the solution is just to write Eq and Show behind the data types and call it a day :D
16:17:25 <Wizek> lambdamu_: But muh boilerplate!
16:18:03 <Wizek> here, I left off some quotes: "\"\""
16:18:49 <Adluc> :D
16:52:37 <boj> so, anyone eligible to work in the US want to move to Alaska to do haskell dev? i'm still looking for another software engineer :p
16:53:32 <ezyang> orion: Hi what's up 
16:53:55 <dsal> boj: Sounds pretty rad, but I've got too many houses down here.  :(
16:55:06 <EvanR> boj: oh... interesting
16:55:44 <EvanR> i might
16:56:21 <boj> EvanR: if you genuinely are http://alasconnect.com/jobs.html
16:57:23 <EvanR> you work there?
16:57:32 <boj> yeah
17:09:25 <Guest30> h>1
17:10:15 * jle` . o ( h <= 1 )
17:36:09 <koz_> I'm trying to (using monad transformers) write the type of a computation that uses a PRNG (by way of RandT transformer) while making an STVector storing Word8s. My current attempt of this type is '(RandomGen g) => RandT g (STVector s Word8) ()', but this isn't acceptable, as the kind of STVector s Word8 is * not * -> * as required. What am I missing?
17:37:33 <c_wraith> koz_, you want (ST s) in there. it's the monad type.
17:38:05 <koz_> c_wraith: So would that be (RandomGen g) => RandT g (ST s) () ? But what happens to the vector type?
17:38:35 <c_wraith> koz_, if you want to return it, it would replace the ()
17:39:12 <koz_> c_wraith: So (RandomGen g) => RandT g (ST s) (STVector s Word8) ?
17:39:41 <c_wraith> yeah, that looks reasonable
17:40:10 <jle`> evalRandT :: RandT g (ST s) (STVector s Word8) -> g -> ST s (STVector s Word8)
17:40:22 <jle`> which is something you can getn runST
17:40:37 <jle`> s/getn/then
17:41:10 <koz_> jle`: OK, thanks, let me try write something sensible.
17:42:16 <jle`> but if you're in ST then you might as well use something like mwc-random which might fit more naturally
17:43:21 <koz_> jle`: I'm trying to (once and for all) understand how to stack RandT with ST. It's been bugging me for ages, and I hate the fact I don't understand.
17:46:07 <jle`> if you google this you might run into the SO questions of me on my first ever haskell project :)
17:46:32 <koz_> jle`: Lol.
17:48:29 <zachk> ok using simplelocalnet backend for distributed process (ie. cloud haskell) findpeers is returning peers on my local machine when I run multiple programs, but they don't seem to receive nsendRemote messages to registered processes at all, any help:?
17:52:32 <johnw> does anyone know of a way to weight a list of integers, that is high for ordered lists (ascending), and low for reversed (descending) or random lists?
17:53:28 <zachk> mostly ascending or totally ascending?
17:53:37 <johnw> I'd like mostly ascending
17:53:45 <johnw> so, a value 0.0 to 1.0, that gives me an idea of its "ascendingness"
17:55:52 <Aelara> johnw: You could just try using the propertion of elements L n in list L such that L n > L (n - 1) where n > 0. I've never heard of this being used, though
17:56:46 <johnw> proportion of elements?
17:57:29 <Aelara> (and L n mean's the nth element of L, of course)
17:57:30 <nshepper1> Count the number of adjacent elements (x, y) where x < y
17:57:40 <johnw> ah
17:58:00 <nshepper1> And divide that by the total number of elements - 1
17:58:34 <Aelara> nshepper1: That would work too
17:58:40 <nshepper1> You could also look at all pairs of elements rather than just adjacent pairs
18:01:16 <johnw> for a bonus, express it as an SMT constraint on a vector of integer variables, such that the solver will prefer ascending-ish models :)
18:02:59 <johnw> this is for a scheduler, btw, where ascending offers more compacted loops (but there are lots of other constraints too, so I can't just strictly order things)
18:46:01 <koz_> I'm having enormous trouble writing this using RandT and STVector: https://en.wikipedia.org/wiki/Fisher-Yates_Shuffle#The_.22inside-out.22_algorithm . I get about this far before getting stumped: http://lpaste.net/360112 Could someone please help me?
18:50:34 <artagnon> I'm probably messing up the syntax here, but why doesn't `deriving instance Generic (Digest SHA3_256)` work with Standalone deriving?
18:50:50 <artagnon> It says that I haven't got the constructors for Digest, but I've already imported everything.
18:53:10 <geekosaur> show code?
18:53:12 <geekosaur> @paste
18:53:12 <lambdabot> Haskell pastebin: http://lpaste.net/
18:53:49 <geekosaur> (a common failure is expecting that importing a type also imports its data constructors automatically, but it's also possible the module doesn't export data constructors)
18:55:58 <artagnon> geekosaur: It does export Digest(..) -- http://hackage.haskell.org/package/cryptonite-0.24/docs/src/Crypto-Hash-Types.html#Digest
18:56:48 <artagnon> geekosaur: https://gist.github.com/artagnon/5db4744077db5d9be83b95729726c5c2
18:56:56 <geekosaur> yes, I used hayoo to verify that once I was reasonably certain you meant the cryptonite package
18:57:18 <geekosaur> (another reason to show code, you seem to be assuming any given type exists in only one possible package. good luck with that, then...)
18:58:02 <artagnon> Right, I was asking it as a more generic question -- "when would StandaloneDeriving fail?"
18:58:25 <geekosaur> also when something internal isn't exported
18:58:34 <artagnon> In the paste, I deleted several other instances of Generic, Ord, Binary for types from the cryptonite library.
18:58:46 <artagnon> (They all work fine)
18:59:24 <artagnon> Something inside Digest is not exported? Possible. In any case, why doesn't my own instance (commented out) work?
19:00:02 <artagnon> They made (Digest a) an instance of ByteArrayAccess, not Binary. I found that pretty annoying.
19:00:02 <geekosaur> and chasing through types, quite possibly Foundation.Array.UArray
19:00:13 * artagnon nods
19:00:30 <artagnon> I need my own Binary to work then.
19:00:56 <geekosaur> and I would not know why your own instance doesn't work; full error messages are also a good idea
19:02:22 <artagnon> There, it's a comment on top, but I didn't find it particularly helpful: https://gist.github.com/artagnon/5db4744077db5d9be83b95729726c5c2
19:04:28 <geekosaur> oh, right. binary is using its tagged representation, not raw
19:04:45 <geekosaur> you will want to study the lower level binary primitives
19:05:10 <artagnon> Which package?
19:05:37 <geekosaur> same package. Data.Binary.Builder module
19:06:02 <geekosaur> oh wait, this doc is putters only :(
19:06:49 <geekosaur> ok, in Data.Binary.Get. don;t just use "get", use the specific ones
19:07:22 <geekosaur> "get" by itself will use binary's own tagged format, which wants extra type tags in the data
19:09:18 <WinterFox[m]> If I have something like `"foo" :: Text` is this just letting the compiler know which datatype it is?
19:11:04 <artagnon> WinterFox[m]: Yes.
19:11:16 <artagnon> geekosaur: getLazyByteStringNul doesn't seem to work.
19:11:22 <artagnon> ... and I have no idea what the size is.
19:13:37 <artagnon> Wait a minute ... since I'm using `put`, shouldn't I get a tagged representation?
19:15:28 <geekosaur> oh, you're not reading something generated outside of haskell?
19:15:46 <artagnon> No!
19:16:16 <artagnon> Just trying to round-trip this Digest thing.
19:18:07 <geekosaur> mm, actually, what's convert? don't see it in cryptonite
19:18:47 <artagnon> It's in Data.ByteArray.
19:18:54 <artagnon> Converts from ByteArrayAccess -> ByteArray
19:19:28 <artagnon> (both are interfaces, and there'a an instance of ByteArray for Binary)
19:22:21 <geekosaur> oh. you don't want decode there
19:23:00 <geekosaur> I'm not sure what exactly you want there but it likely involves http://hackage.haskell.org/package/cryptonite-0.24/docs/Crypto-Hash.html#v:digestFromByteString
19:23:50 <geekosaur> decode is trying to read the 'put' value as another 'binary' encoded blob, instead of as the result of converting the Digest to a ByteString
19:24:44 <geekosaur> in effect, you only 'binary'-encoded once, but you're trying to 'binary'-decode twice
20:41:54 <koz_> Is there an easy way to do Vector (a, a) -> Vector a such that the result is twice the length of the input, and has each pair's elements side-by-side in it?
20:42:27 <koz_> For example, if used on fromList [(1, 2), (3, 4)], the result would be fromList [1, 2, 3, 4]
20:45:41 <MarcelineVQ> something that isn't   concatMap (\(x,y) -> fromList [x,y])   ?   though I'm not sure how magical Vector's fusion abilities are
21:05:48 <centril> MarcelineVQ: doesn't REPA use Vector internally? I found its map fusion abilities quite nice
21:08:21 <MarcelineVQ> Dunno about that, one would want to be sure the above is fusing though if it can
21:09:02 <MarcelineVQ> :t Data.Vector.concatMap (\(x,y) -> Data.Vector.fromList [x,y]) -- koz_ : was serious though, Vector has concatMap
21:09:04 <lambdabot> Data.Vector.Vector (b, b) -> Data.Vector.Vector b
21:09:31 <koz_> MarcelineVQ: thanks!
21:27:13 <jcarpenter2> Question about MonadPlus / Happstack.  I'm looking for a cookie that may or may not be there.  Happstack's "lookCookie" method returns a "ServerPart Cookie", but returns the mzero value when the cookie is not present.  How do I catch this mzero, thus returning a "ServerPart (Maybe Cookie)"?
21:28:12 <jcarpenter2> I tried this, but it doesn't compile because there's no instance for Eq http://lpaste.net/360119
21:31:48 <lyxia> optional (lookCookieValue sessionCookieName)
21:32:11 <jcarpenter2> oh yeah, mplus does the trick
21:45:03 <tabemann> I should turn off logging for this IRC channel in my IRC client, because all it is doing is recording oh so many joins, parts, and quits
21:50:44 <geekosaur> might be able to turn off logging only those
21:51:26 <tabemann> testing
22:12:53 <EvanR> @djinn Functor f => f a -> (a -> Bool) -> b -> b -> f b
22:12:53 <lambdabot> Error: Class not found: Functor
22:17:37 <geekosaur> :exf "Functor f => f a -> (a -> Bool) -> b -> b -> f b"
22:17:57 <MarcelineVQ> exf don't like that one    \fa p a b -> bool a b . p <$> fa
22:18:01 <exferenceBot> could not find expression
22:48:25 <koz_> If I have a [State s a], how can I turn it into State s [a] by just doing all the state changes one after another and collecting all the results?
22:48:30 <koz_> Would traverse be suitable here?
22:49:22 <geekosaur> isn't that just sequence?
22:49:28 <koz_> :t sequence
22:49:29 <lambdabot> (Monad m, Traversable t) => t (m a) -> m (t a)
22:49:42 <koz_> Huh, so it is. Thank you geekosaur.
23:25:10 <centril> what would you name a  class ??? f g where ??? :: f (g a) -> g (f a)   ?
23:26:22 <opqdonut> Commute
23:26:44 <dminuoso> opqdonut: Im not sure how that would follow.
23:26:52 <dminuoso> :t sequenceA
23:26:53 <lambdabot> (Applicative f, Traversable t) => t (f a) -> f (t a)
23:26:55 <dminuoso> Is there an inverse of this?
23:27:34 <centril> opqdonut: are you thinking of Compose  as a monoid and then we have a commutative monoid?
23:27:37 <mniip> centril, Distributive
23:28:02 <mniip> :t distribute
23:28:03 <lambdabot> error:
23:28:03 <lambdabot>     • Variable not in scope: distribute
23:28:03 <lambdabot>     • Perhaps you meant ‘distrib’ (imported from Control.Lens)
23:28:16 <mniip> :t Data.Distributive.distribute
23:28:17 <lambdabot> (Functor f, Data.Distributive.Distributive g) => f (g a) -> g (f a)
23:31:17 <centril> mniip: that should work for   Maybe (Either e a) -> Either e (Maybe a) , right?
23:31:40 <opqdonut> dminuoso: centril: you're commuting the type constructors f and g
23:32:34 <mniip> centril, no, that's what traverse is for
23:32:48 <dminuoso> opqdonut: Its only commutative if f (g a) == g (f a) holds
23:32:49 <mniip> Either is not distributive, but Maybe is traversable
23:32:59 <centril> mniip: oh right
23:33:06 <opqdonut> or in other words, Compose f g -> Compose g f
23:33:08 <mniip> dminuoso, that is correct but to commute doesn't necessarily mean to be commutative
23:33:13 <opqdonut> yes
23:33:15 <dminuoso> Ohh.
23:33:31 <dminuoso> Details of the English math language I see.
23:36:49 <centril> cheers =)
