00:01:40 <Cale> mniip: First of all,  n = m * div n m + mod n m, and quot/rem satisfy an analogous identity. Secondly, the sign of mod n m matches the sign of m, while the sign of rem n m matches the sign of n.
00:03:21 <mniip> yeah but
00:03:27 <mniip> what's the uh
00:03:41 <mniip> is there a branch-free solution
00:03:52 <mniip> or at least solution where you don't have to branch into all 4 cases
00:04:04 <Cale> Well, you might be able to write something using signum
00:04:13 <Cale> and abs
00:04:19 <mniip> right
00:04:52 <Cale> Actually, I bet this is in the Report
00:05:12 <Cale>     divMod n d       =  if signum r == - signum d then (q-1, r+d) else qr
00:05:12 <Cale>                         where qr@(q,r) = quotRem n d
00:05:14 <Cale> yep
00:06:20 <mniip> well
00:06:22 <[exa]> is there a real usage for divMod defined like this?
00:06:30 <mniip> that establishes divMod in terms of quotRem
00:06:34 <Cale> divMod is usually the function you want
00:06:40 <mniip> but I have quotRem defined only on one quarter of the space
00:06:42 <Cale> quotRem is usually what CPUs implement
00:06:53 <mniip> namely the part that coincides in the two
00:07:09 <[exa]> I haven't met a problem where divMod be the "right thing"
00:07:11 <Cale> mniip: Ah, that uses quotRem on 1/2 of the space
00:07:21 <[exa]> so just kindof curious :]
00:07:38 <Cale> [exa]: well, usually you'd want the remainder to be positive when the modulus is positive
00:07:54 <Cale> > [mod n 5 | n <- [-10..10]]
00:07:57 <lambdabot>  [0,1,2,3,4,0,1,2,3,4,0,1,2,3,4,0,1,2,3,4,0]
00:08:01 <mniip> Cale, pretty sure that uses it everywhere
00:08:16 <Cale> It gives you the nice wrapping behaviour when you're using this as an index, for instance
00:08:24 <Cale> > [rem n 5 | n <- [-10..10]]
00:08:27 <lambdabot>  [0,-4,-3,-2,-1,0,-4,-3,-2,-1,0,1,2,3,4,0,1,2,3,4,0]
00:08:29 <Cale> ^^ this just sucks
00:08:41 <[exa]> Cale: oh, problem solved :D i've confused both of them
00:08:45 <Cale> (but it's marginally cheaper to implement with transistors)
00:08:59 <[exa]> thanks :D
00:10:44 <Cale> mniip: Oh, I guess it does.
00:13:55 <mniip> this isn't really a haskell question per se, but I wanted to write elegant code so turned to #haskell
00:14:08 <[exa]> :]
00:18:15 * hackage multirec 0.7.8 - Generic programming for families of recursive datatypes  https://hackage.haskell.org/package/multirec-0.7.8 (AndresLoeh)
00:43:17 <adenGFX> what does `\w -> concat (map (replicate n) w)` do? 
00:44:00 <erisco> try it on some examples
00:45:49 <mniip> it concats the result of mapping replicate n over w
00:46:04 <adenGFX> w a string and n a int?
00:46:18 <mniip> in general w :: [a], n :: Int
00:46:21 <erisco> ask ghci for the types
00:46:24 <mniip> with the whole thing :: [a]
00:46:26 <erisco> or do it here with :t
00:46:38 <mniip> :t \w -> concat (map (replicate ?n) w)
00:46:40 <lambdabot> (?n::Int) => [a] -> [a]
00:46:54 <erisco> lambdabot has implicit parameters? lol
00:48:06 <adenGFX> ah, I think I've got it, thanks 
00:49:45 * hackage weigh 0.0.7 - Measure allocations of a Haskell functions/values  https://hackage.haskell.org/package/weigh-0.0.7 (ChrisDone)
01:00:00 <ertes-w> hello
01:00:10 <lostman> i just tried updating to ghc-8.2.2 with latest nightly resolver and it blew up on my rhel6 travis ci with "Supported versions for OS key 'linux64-gmp4': ...". how to get a list of all supported variants? is linux64-gmp4 going to be supported with stack later?
01:36:26 * hackage optparse-simple 0.1.0 - Simple interface to optparse-applicative  https://hackage.haskell.org/package/optparse-simple-0.1.0 (MichaelSnoyman)
02:07:41 * hackage bgmax 0.2.0.2 - Parse BgMax-files  https://hackage.haskell.org/package/bgmax-0.2.0.2 (petterb)
03:11:40 * hackage time-locale-vietnamese 1.0.0.0 - Vietnamese locale for date and time format  https://hackage.haskell.org/package/time-locale-vietnamese-1.0.0.0 (tungd)
03:12:48 <royal_screwup21> I'm trying to map over a tree with characters and convert said characters to their ascii values. here's what I tried https://thepasteb.in/p/lOhOE9By79DfB this didn't throw an error when compiling, but when I tried "maptree tree1", I did get an error: https://thepasteb.in/p/pghQoljjvvpuR What am I doing wrong?
03:17:01 <Boomerang> royal_screwup21: Take a look at the mapTree Empty case, should you return a char there?
03:17:27 <royal_screwup21> Boomerang: oops, should be an Int
03:18:24 <Boomerang> Actually royal_screwup21 I think your mapTree should return a Tree :) It looks like you might have to update the Branch case too
03:19:04 <Boomerang> The point for mapTree for your use case is to go from a Tree Char to a Tree Int, correct?
03:19:32 <royal_screwup21> yup
03:20:43 <Boomerang> You are pretty close, you just need to make sure that you are in fact returning a Tree on the right hand side of the equal sign for all the cases of mapTree. I am sure can figure out how! :)
03:21:44 <Boomerang> But if you have more questions, feel free to ask!
03:24:47 <royal_screwup21> Boomerang: I think I figured out the base case. maptree f Empty = Empty?
03:25:05 <royal_screwup21> that returns a Tree
03:25:50 <Boomerang> That looks good to me!
03:27:26 <royal_screwup21> Boomerang: done! I had to include a Branch in the branch case
03:27:50 <Boomerang> royal_screwup21: Great :D
03:58:38 <ertes-w> royal_screwup21: now that you know how to do it by hand you can just derive a Functor instance using the DeriveFunctor extension
03:59:02 <ertes-w> royal_screwup21: then 'fmap' is your 'maptree'
03:59:14 <royal_screwup21> alrighty, I'll look into it, thanks!
04:05:45 <phaazon> plop
04:05:53 <phaazon> I read that bracket re-throws any exception
04:06:05 <phaazon> is there a way to have such a function that doesn’t re-throws?
04:06:08 <phaazon> -s
04:06:48 <merijn> phaazon: eh, what would you expect it to return?
04:07:14 <phaazon> merijn: an Either or something, a bit like try
04:07:15 <merijn> phaazon: You'd have to wrap your bracket in a catch
04:07:31 <merijn> phaazon: So wrap your bracket in a try or catch?
04:07:43 <phaazon> ok, I thought there was a function to do that :)
04:07:43 <phaazon> thanks
04:10:49 <merijn> phaazon: Well, defining one should be pretty trivial
04:11:49 <merijn> I suspect it doesn't exist because it's below the Fairbairn threshold
04:43:49 <Psybur> When do I know to make my own Functors/Applicatives/Monads? Is there a checklist? Wondering how I know when to not just use a list/map/set etc
04:45:50 <merijn> Psybur: Why would you think about functors/applicatives/monads when you don't even have a datatype yet?
04:46:40 <hpc> Psybur: do you know how to write instances of any other type classes?
04:47:01 <Psybur> So FAM comes after youve determined data structure?
04:47:37 <Psybur> hpc, yes I know about writing instances
04:47:46 <merijn> Psybur: Whether something is a functor, applicative, monad, etc. is a property of the datatype. You can't just arbitrarily decide to "make a functor", because that wouldn't make sense if you don't even know what it'd look like
04:48:09 <Psybur> Im not trying to arbitrarily make these, Im just wondering what are the signs that you should be using them?
04:48:20 <hpc> it's exactly the same thing for Functor/Applicative/Monad
04:48:46 <hpc> if you have a type that has sensible operations that fit the types of the stuff inside the type class
04:48:57 <hpc> and you can show that those definitions obey the additional laws of the type class
04:49:02 <hpc> then you can write the instance
04:49:07 <ventonegro> Psybur: When you want to use the Functor/Applicative/Monad methods
04:50:13 <Psybur> What if Im doing something one way and it turns out I could be doing it a better way using FAM? Are there any signs?
04:51:02 <ventonegro> Psybur: After you learn about FAM, you you think to yourself "Ah, this type is a Functor"
04:51:23 <Psybur> Heh I suppose
04:53:27 <Cale> Psybur: Yeah, you just use those things when you notice that the type you're defining has a viable instance of them. You might have defined their methods less polymorphically anyhow, the type classes just makes code look uniform.
04:53:31 <Cale> make*
04:53:51 <Cale> and of course, it lets you use stuff which is abstracted over an arbitrary Monad or whatever
04:54:51 <saurabhnanda> If I'm looking at https://www.stackage.org/haddock/lts-9.0/base-4.9.1.0/Control-Applicative.html#t:Alternative and want to know what exactly the Applicative instance of Maybe does, is this documented anywhere?
04:55:19 <ventonegro> Psybur: It's a deep rabbit hole though, eventually you'll be reading "Categories for Programmers" :)
04:56:01 <Cale> saurabhnanda: http://hackage.haskell.org/package/base-4.9.1.0/docs/Control-Applicative.html#g:2
04:56:13 <Cale> ^^ that version has source links
04:57:10 <Psybur> ventonegro, I already am I think
04:57:33 <Psybur> ventonegro, https://bartoszmilewski.com/2014/10/28/category-theory-for-programmers-the-preface/?
04:57:51 <ventonegro> Psybur: yep
04:58:22 <saurabhnanda> Cale: so read the source. The actual behaviour of instances in not haddocked anywhere?
04:58:50 <Cale> Yeah. Well, for the most part, it's unique anyway
04:58:58 <merijn> It probably should be, but I don't think that's currently the case
04:59:20 <merijn> Cale: Yeah, but probably specific instance should have a short description, tbh
04:59:38 <Cale> I suppose that would be nice
05:01:03 <Cale> If you consider for example, the type of (<*>) for Maybe, there's not a whole lot of choice involved:  Maybe (a -> b) -> Maybe a -> Maybe b
05:01:17 <Cale> Basically, there's a bunch of degenerate functions and one that's actually any good :)
05:01:18 <merijn> Cale: He was asking about Alternative, though
05:01:43 <Cale> For Alternative, yeah, there are two that are reasonable
05:02:33 <merijn> OTOH, there's only two lawful implementation of <|> for Maybe, only one of which is sensible for programmers
05:03:08 <Cale> Well, both of the ones I'm thinking of would be sensible for programmers
05:03:19 <Cale> (the left-biased one and the right-biased one)
05:03:44 <merijn> Cale: I'd expect every programmer to expect left-biased
05:03:56 <merijn> Since almost everything we're used to has left-biased short-circuiting
05:04:51 <erisco> no one expects the right bias!
05:05:55 <Cale> I suppose it's a natural extension of using lists and having foldr be more natural than foldl
05:06:51 * hackage relational-query 0.11.0.0 - Typeful, Modular, Relational, algebraic query engine  https://hackage.haskell.org/package/relational-query-0.11.0.0 (KeiHibino)
05:07:56 <EvanR> i skipped to the end of cat theory for programmers
05:08:01 <EvanR> now thats it exists
05:08:39 <EvanR> "a category is just a monad in the bicategory of spans, whats the problem"
05:09:08 * EvanR takes that away
05:12:17 <EvanR> so a category is a kind of monad, a monad is a kind of monoid, and a monoid is a kind of category
05:12:33 <EvanR> brain explode
05:13:25 <hpc> ppsh, all of those things are just endofunctors :P
05:13:47 <ventonegro> I'm still confused by the monoid-as-a-category-with-a-single-object thing
05:14:52 <merijn> ventonegro: How so?
05:16:03 <ertes-w> ventonegro: for a single object A you have a set of morphisms Hom(A, A) and a composition function (∘) : Hom(A, A) → Hom(A, A) → Hom(A, A)
05:16:20 <ertes-w> ventonegro: and an identity morphism (id : Hom(A, A))
05:16:23 <ventonegro> merijn: As I recall from my sparse knowledge, monoids need both an associative operation and elements to apply the operation to
05:16:55 <ertes-w> ventonegro: now just give Hom(A, A) a name:  C = Hom(A,A)
05:17:07 <ertes-w> then you have a set C of things ("morphisms") that you can compose with (∘)
05:17:23 <ventonegro> ertes-w: Ah ha, so the morphisms themselves are the elements
05:17:27 <ertes-w> yes
05:17:42 <ertes-w> the object itself is uninteresting, only the fact that there is exactly one matters
05:18:15 <ventonegro> That's why I like IRC
05:18:20 <ventonegro> ertes-w: Thanks! :)
05:18:29 <ertes-w> (a purist category-theoriest would say that words like "one" should be avoided)
05:18:34 <ertes-w> -e
05:19:54 <ertes-w> ventonegro: you can go one step further:  for any category C, for any object (A : Ob(C)), the set of all endomorphisms of A together with C's composition forms a monoid
05:20:44 <merijn> ventonegro: Also (this took me ages to figure out, because none of the damn texts mention it), morphisms have an "identity", that is, you can have multiple morphisms "A -> A" which are not the same
05:20:47 <ventonegro> ertes-w: Indeed, since there is always an identity
05:21:09 <ertes-w> ventonegro: and since composition of endomorphisms is closed
05:22:18 <ertes-w> ventonegro: replace "endomorphisms" by "automorphisms" and you have groups =)
05:22:25 <ventonegro> merijn: Yeah, I guess that's a given for the people writing the texts, which shows that teaching is hard :)
05:22:42 <ertes-w> in categorical terms a group is a monoid, where all endomorphisms are automorphisms
05:22:45 <merijn> ventonegro: Which is why I need a "CT for PLT people" book :p
05:23:07 <erisco> there is a name for categories where Hom(A,B) has at most one element
05:23:08 <merijn> Even Pierce's "CT for computer scientists" isn't working for me :p
05:23:35 <ertes-w> erisco: "graph"? =)
05:23:35 <EvanR> thin category?
05:23:40 <erisco> yeah that's right
05:23:45 <ventonegro> ertes-w: You lost me at automorphims :)
05:23:57 <ertes-w> ventonegro: auto = endo + iso
05:24:02 <erisco> or a posetal category
05:24:10 <ventonegro> ertes-w: Ah ha
05:24:37 <EvanR> yet again we established CT as just a pile of definitions
05:24:49 <liyang> nonsense!
05:24:52 <merijn> EvanR: All of math is just a pile of definitions
05:25:00 <liyang> (abstract, of course.)
05:25:00 <ertes-w> ventonegro: Iso f = ∃ g, f ∘ g = id and g ∘ f = id
05:25:02 <EvanR> sometimes you have actual theorems with proofs
05:25:06 <erisco> after definitions you want theorems
05:25:22 <erisco> CT has more definitions than you can shake a stick at
05:25:44 <ertes-w> ventonegro: or in metaphors: f is an isomorphism, if it has an "inverse"
05:25:55 <ventonegro> It's fascinating how something as simple as a category leads one to things like limits, colimits, adjunctions etc.
05:26:23 <ventonegro> The cone thing is fun :)
05:26:24 <erisco> it is like that because it is so little… then complexity is bolted on
05:26:47 <erisco> it is like, if you study term rewriting, you can do any maths as term rewriting
05:27:06 <erisco> but you've got to bolt it all onto the framework
05:27:20 <ventonegro> ertes-w: I know about endo and isomorphims, but I didn't now they had a baby
05:27:21 <ertes-w> to me "cat theory" is the theory of everything for compositional design =)
05:27:30 <ventonegro> know*
05:28:48 <ertes-w> ventonegro: prediction: you will start reading the HoTT book in 2017
05:29:01 <EvanR> its cool how the information however complex disappears when you do composition, at position B in (A -> B) o (B -> C) = A -> C
05:29:07 <erisco> not much time left… better get started
05:29:10 <merijn> ertes-w: Ain't nobody got time for that :p
05:29:34 <erisco> EvanR, same with function application
05:29:43 <EvanR> function application ? :(
05:29:48 <erisco> yes
05:29:52 <EvanR> gross
05:30:03 <erisco> well whatever
05:30:49 <erisco> add const to your category and compose, w/e
05:30:58 <ertes-w> EvanR just prefers to call it eval
05:31:02 <ertes-w> it's the same thing =P
05:31:23 <EvanR> function application in haskell ruins all the fun
05:31:26 <EvanR> syntactically
05:32:03 <ertes-w> how funky would haskell without funktion application
05:32:39 <erisco> it is a significant feature for abstraction… ironically by removing abstractions
05:32:55 <ertes-w> let's also build Applicative into the language and remove lambdas
05:33:37 <ggVGc> I don't see why we even have a type language and a runtime language
05:33:42 <EvanR> composition is nicer in the sense of having less details
05:33:43 <ggVGc> why not just evaluate the programs in the type system
05:33:53 <EvanR> less assumptions about whats going on
05:33:57 <merijn> ggVGc: #idris is that way *point*
05:34:04 <ggVGc> :((
05:34:09 * ggVGc stays in the stoneage
05:35:08 <erisco> but you can also shoot yourself in the foot
05:35:22 <erisco> APIs are a struggle between too much information and too little
05:35:54 <EvanR> you want as little as possible and no littler !
05:36:56 <erisco> or perhaps as much as possible so at worst you need some more definitions for convenience
05:42:37 <erisco> a benefit to as much as possible is it is the most resilient to changing requirements
05:43:23 <erisco> how many times have you realised you needed a particular piece of information in a spot but to get it you have to begin a refactor much further upstream
05:44:13 <erisco> because, as always, it wasn't thought that information was needed and so it was discarded… by projection or by substitution
05:44:15 * hackage relational-schemas 0.1.6.1 - RDBMSs' schema templates for relational-query  https://hackage.haskell.org/package/relational-schemas-0.1.6.1 (KeiHibino)
05:44:55 <ertes-w> merijn: you haven't read the HoTT book?
05:45:17 <erisco> yet if you keep everything you can't reduce anything ever, and that's a problem
05:45:32 <erisco> you'd end up with the top level of your program being an interpreter
05:51:10 <Athas> 'make binary-dist' for GHC is heating my CPU to 96 degrees.  Better be worth it!
05:51:19 <Athas> Killing a lot of polar bears for a compiler.
05:53:15 <ddd> hey I have a question, if I use a "where" clause in my function, when is it evaluated?
05:53:48 <lyxia> bindings are evaluated when needed
05:54:55 <lyxia> If we write nonsense under "where" and never use it, it never gets evaluated
05:55:41 <ddd> that is very helpful detail, thanks alot
05:57:36 <ventonegro> ertes-w: I downloaded the book already :D
05:57:48 <ventonegro> But I think I lack some of the prerequisites...
05:59:25 <merijn> ertes-w: Naah, I don't have the time for that sorta time commitment atm
06:00:02 <merijn> Athas: Why are you building a binary-dist yourself?
06:00:27 <Athas> merijn: there does not seem to be one for Fedora in Stack.
06:01:05 <merijn> Athas: Ah, I just grab ghc bindists, no stack
06:01:46 <Athas> They don't work either.
06:01:52 <Athas> They are linked to the wrong libraries for Fedora.
06:01:57 <merijn> Really? How old is your fedora?
06:02:03 <Athas> Very new.  27.
06:02:22 <Athas> From what I can determine, Fedora fiddles with some thing related to ncurses.  It needs special 'tinfo' builds.
06:02:29 <Athas> I guess it's similar to the old GMP issues.
06:02:38 <saurabhnanda> has anyone used hlint for arrow/proc related code? does it work to suggest replacements for proc() related stuff?
06:02:52 * hackage relational-query-HDBC 0.6.6.1 - HDBC instance of relational-query and typed query interface for HDBC  https://hackage.haskell.org/package/relational-query-HDBC-0.6.6.1 (KeiHibino)
06:06:32 <ertes-w> merijn: same here…  i started reading it, because i kinda hoped for more immediate benefits
06:06:57 <ertes-w> i'm back to "classical type theory" for now
06:07:26 <merijn> saurabhnanda: Most likely not, since arrow notation is rather rare now
06:13:02 <saurabhnanda> merijn: hmmm, still trying... is it possible to write hlint rules for multi-line expressions?
06:13:14 <merijn> no clue
06:21:17 * hackage relational-record 0.2.0.1 - Meta package of Relational Record  https://hackage.haskell.org/package/relational-record-0.2.0.1 (KeiHibino)
06:36:11 * hackage spake2 0.4.0 - Implementation of the SPAKE2 Password-Authenticated Key Exchange algorithm  https://hackage.haskell.org/package/spake2-0.4.0 (jml)
06:36:21 * jml waves
06:37:02 <saurabhnanda> anyone written multi-line hlint rules?
06:46:46 <Kristjan> My name is Kristjan Robam.  Bank account nr: EE671010010225901016 (SEB Estonia). People, please donate me with 200$ donates. I am very ill and need to collect money.
06:48:48 <saurabhnanda> Kristjan: do you know category theory?
06:49:16 <Kristjan> no
06:49:25 <Kristjan> but I think it's simple
06:49:50 <ertes-w> Kristjan: please use a funding platform for that
06:50:10 * hackage relational-record 0.2.1.1 - Meta package of Relational Record  https://hackage.haskell.org/package/relational-record-0.2.1.1 (KeiHibino)
06:50:11 <lyxia> You need a funding platform for category theory?
06:50:19 <merijn> ertes-w: Since he's spamming that in multiple channels it's just a spammer
06:50:54 <ertes-w> merijn: probably, but on the small chance that it's legit i don't want to be too rude =)
06:55:16 * hackage relational-record-examples 0.4.1.0 - Examples of Haskell Relationa Record  https://hackage.haskell.org/package/relational-record-examples-0.4.1.0 (KeiHibino)
07:05:12 <ddd> If I use the call "listToMaybe x" on some recursive function x, will Haskell grab an element as soon as it exists in this list?
07:06:01 <saurabhnanda> what's the recommended custom prelude for a largish projetc with newbies?
07:06:31 <merijn> saurabhnanda: I don't think you'll find any consensus
07:06:51 <guest_____> I have a question about usage of FFI. Lets say I have a .h file which has a function something like "void myFunc(double *a, int b, int c)". I want to call that function from my haskell code
07:08:43 <guest_____> "foreign import ccall "a.h myFunc"   myHaskellFunc :: Ptr (Double) -> Int -> Int -> IO ()" - this is what I tried to use, but it fails at link time
07:09:09 <merijn> guest_____: Are you passing the object file to GHC?
07:10:09 <guest_____> no, I do not have an object file. The function has its definition in the header
07:10:15 <merijn> guest_____: That won't work
07:10:53 <merijn> guest_____: You the CApiFFI can deal with that, I'm not sure. But for the ccall you need to pass GHC an object file, since it can't magically compile C for you
07:11:34 <EvanR> doesnt the build system magically ask gcc to compile stuff?
07:11:48 <merijn> EvanR: You can ask cabal to call gcc, yes
07:12:04 <merijn> EvanR: But that wasn't part of the question
07:12:24 <EvanR> also i heard header files get compiled in C++
07:12:35 <merijn> hah
07:12:36 <merijn> I wish
07:12:42 <merijn> That would make my life so much better...
07:12:57 <EvanR> uh
07:13:06 <ertes-w> ddd: x is not a function
07:13:37 <ertes-w> ddd: listToMaybe will construct a Maybe that is strict only in the outermost ("first") constructor of the list
07:13:39 <guest_____> ok, so how do I make cabal to compile the c stuff?
07:13:53 <merijn> EvanR: I think gcc has some notion of "compiled header files", but that's an implementation detail of gcc and not portable
07:14:00 <ertes-w> ddd: i.e. pattern-matching on the Maybe will evaluate the list up to knowing whether it's a (:) or a []
07:14:07 <merijn> guest_____: Cabal can only deal with really simple C compilation of .c files
07:14:18 <EvanR> merijn: so does the ms c++ compiler
07:14:38 <merijn> EvanR: All of that isn't portable between compilers, though
07:14:46 <ertes-w> > listToMaybe undefined `seq` ()
07:14:47 <merijn> EvanR: And GHC certainly can't handle it
07:14:48 <lambdabot>  *Exception: Prelude.undefined
07:14:49 <EvanR> so it exists but isnt standardized
07:14:55 <ertes-w> > listToMaybe [undefined] `seq` ()
07:14:58 <lambdabot>  ()
07:15:11 <ertes-w> ddd: listToMaybe will not even look at the tail
07:15:19 <ertes-w> > listToMaybe (() : undefined) `seq` ()
07:15:22 <lambdabot>  ()
07:15:37 <EvanR> > listToMaybe (undefined : undefined) `seq` ()
07:15:40 <lambdabot>  ()
07:15:47 <saurabhnanda> am I reading this correctly? Does Protolude only export a handful of functions? https://hackage.haskell.org/package/protolude-0.2/docs/Protolude.html
07:15:48 <guest_____> I have a Linux system, it has all kinds of tools available, I do not really care about portability. Can I specify something in .cabal file so it would call g++ to compile C things for me?
07:22:17 <saurabhnanda> is this recommended to specify my own implicit prelude? https://ghc.haskell.org/trac/ghc/ticket/9499#comment:9
07:23:02 <merijn> I don't even think there's consensus whether writing your own Prelude is recommended
07:23:33 <EvanR> you can specify a different implicit prelude?
07:24:36 <quchen> Maybe write your own prelude for big (> 10k sloc), but definitely don’t publish it.
07:24:40 <quchen> +projects
07:24:46 <hexagoxel> saurabhnanda: the haddock generation is broken for import..as X + export module X. look at the source for the Protolude module instead.
07:25:08 <EvanR> interesting suggestion
07:26:10 <EvanR> i would like to try a sane prelude one day
07:27:50 <mnoonan> protolude and classy-prelude are both pretty nice (though kind of diametrically opposed)
07:28:48 <ertes-w> i think it's fine to use an alternate prelude for *programs*
07:28:54 <ertes-w> not so much for libraries
07:31:05 <ertes-w> it's probably even fine for libraries in most cases, until you start using the alternate type classes
07:31:05 <cocreature> depends on the kind of alternate prelude, the “avoid import bloat by reexporting a bunch of stuff from base” are fine even for libraries
07:31:49 <ertes-w> yeah, that's fine…  it really comes down to whether you expose an interface that ends up depending on the alternate prelude
07:31:55 <cocreature> right
07:32:06 <ertes-w> "sorry, you can't use Num from base…  you have to use Num from this alternate prelude"
07:32:06 <tdammers> classy-prelude is not very nice for a public api
07:34:57 <ertes-w> BTW, are there any alternate preludes that solve some of the more basic problems (like using Text instead of String for most things), but don't completely reinvent everything?
07:35:10 <cocreature> ertes-w: protolude
07:36:08 <ertes-w> protolude looks rather minimal
07:36:24 <cocreature> that’s what I like about it :)
07:36:46 <ertes-w> i'd like a prelude that makes my import lists shorter, not longer =)
07:36:57 <cocreature> protolude reexports way more than base
07:37:19 <cocreature> eh Prelude
07:37:54 <humanoyd> Will `cabal new-build` eventually make Stack obsolete?
07:37:56 <ertes-w> how is it supposed to be used?  the haddock suggests that there is barely two browser pages of reexports and a bunch of utility definitions
07:38:04 <ertes-w> https://hackage.haskell.org/package/protolude-0.2/docs/Protolude.html
07:38:15 <ezyang> humanoyd: In practice I don't think this will happen 
07:38:15 <cocreature> ertes-w: there’s a haddock bug that affects protolude
07:38:23 <ertes-w> ah, i see
07:38:25 <merijn> ertes-w: As was pointed out earlier, haddock doesn't generate docs when importing part of a module and then reexporting
07:39:03 <cocreature> ertes-w: there is a list in the github repo but I’m not sure how useful and/or up2date it is https://github.com/sdiehl/protolude/blob/master/Symbols.md
07:39:03 <ertes-w> in my own projects it at least shows the reexport, but doesn't show details
07:39:14 <ertes-w> cocreature: i'll just read the source code
07:39:15 <humanoyd> ezyang: Oh, the man himself! :) Why don't you think so?
07:39:39 <saurabhnanda> btw, any thoughts on https://ghc.haskell.org/trac/ghc/ticket/9499#comment:9 ?
07:40:15 <guest_____> Is there a way to produce correct C function call from .o file. I want to verity I am using correct types with "foreign import ccall"
07:41:04 <ezyang> First off, I think the Stackage model is useful and not going away, as long as people are willing to put in the legwork to make it work (which they are) 
07:41:48 <Eduard_Munteanu> I have personally resorted to CPP on a few occasions to get a prelude and qualified imports everywhere in a project.
07:42:46 <ezyang> Second, assuming that (1) is the case, I think in practice, you'll get a better experience using a tool that is specifically designed for this model, which stack is 
07:46:09 <cocreature> ertes-w: tbh since it’s just reexports you can just start using it and be happy to not have to import a bunch of crap. I think the only “major” thing it adds is https://github.com/sdiehl/protolude/blob/master/src/Protolude/Conv.hs
07:46:34 <ranberry> Speaking of the Stack model, can anyone explain to me the separation of roles between the <project>.cabal file and stack.yaml files? I initialized my project using Stack, but I've still been specifying most of my dependencies in my <project>.cabal file. Am I going about this the wrong way?
07:47:44 <cocreature> ranberry: you can think of the stack.yaml file as declaring where packages come from (e.g. a stackage snapshot, from git repos, …) while the .cabal file declares which packages your project needs
07:49:12 <ranberry> That explanation makes sense to me. Thanks!
07:49:17 <humanoyd> ezyang: Thanks!
07:51:48 <ertes-w> cocreature: yeah, probably…  i'm not really in desparate need of a custom prelude though…  i tend to use project preludes
07:52:26 <ertes-w> mostly because i have rather unusual common imports
07:53:28 <cocreature> ertes-w: yeah I use project preludes as well, I just base them on protolude rather than the standard Prelude :)
07:56:58 <ertes-w> cocreature: do you use NoImplicitPrelude, or do you import Prelude ()?
07:57:28 <cocreature> NoImplicitPrelude
08:10:58 <guest_____> who to I convert from CDouble to Double?
08:11:08 <cocreature> guest_____: realToFrac
08:12:23 <guest_____> thanks
08:12:23 <cocreature> guest_____: there are two main numeric conversion functions that you need to remember in Haskell: "fromIntegral" for converting from integers to everything else and "realToFrac" for converting between non-integers
08:12:45 <guest_____> good to know
08:13:39 <mud> And then sometimes round/ceiling/floor for non-integer to integer. But that doesn't seem to come up as much.
08:14:09 <quchen> cocreature: And unsafeCoerce to convert between a and b, for example [a] and Bool!
08:14:18 <mud> :(
08:14:37 <quchen> let null :: [a] -> Bool; null = unsafeCoerce
08:14:38 <quchen> ;-)
08:14:54 <cocreature> quchen: you’re evil
08:14:56 <mud> Much better. Does that actually work? *checks*
08:15:21 <quchen> instance Functor Proxy where fmap _ = unsafeCoerce
08:15:44 <mud> Hah
08:15:45 <quchen> instance Functor (Either e) where fmap _ l@(Left _) = unsafeCoerce l
08:16:01 <quchen> Sorry, I’m preparing a talk on quirky Haskell, I couldn’t help myself ;-)
08:16:15 <mud> Those are pleasantly quirky.
08:16:25 <mud> (unpleasantly? whatever)
08:16:54 <Taneb> quchen: unsafeCoerce can be used as a lens! But I don't recommend it
08:17:01 <quchen> Oh good lord
08:17:57 <Taneb> (I don't recommend it because you can do unsafe things with it, which I accept is a pretty stupid reason in the circumstances0
08:18:12 * hackage relational-record 0.2.1.2 - Meta package of Relational Record  https://hackage.haskell.org/package/relational-record-0.2.1.2 (KeiHibino)
08:19:31 <guest_____> is there a way to produce proper foreign function calls for haskell using C sources? Looks like c2hs is meant to do that, but I don't understand how to use it - it require some .chs file...
08:23:37 <Taneb> Prelude Control.Lens Unsafe.Coerce> let unsafe :: Lens' Char Int; unsafe = unsafeCoerce in ("QUCHEN", 1) & _1.mapped.unsafe +~ 32
08:23:40 <Taneb> ("quchen",1)
08:24:21 <Taneb> (bonus points: you can use it as any kind of optic)
08:46:29 <ij> How does "man" find the manual in ~/.nix-profile/share/man/…?
08:47:10 <dmwit> MANPATH
08:47:32 <ij> I've no MANPATH `env`.
08:48:23 <monochrom> Perhaps if you're going through nix shell, it adds MANPATH behind your back.
08:48:24 <dmwit> Try `man manpath` for further details, then.
08:48:58 <ij> Hm, this isn't #nixos. :D
08:49:12 <ij> Didn't notice that, sorry.
08:49:28 <dmwit> From a quick look through that document, there's probably something special in /etc/man_db.conf.
08:52:41 <cocreature> I wouldn’t be surprised if nix patches man to change the default either
08:52:53 <ij> It's man from archlinux.
08:55:32 <dmwit> Maybe. Or maybe it's a man from your nix profile.
08:55:55 <ij> No, it definitely is, "which -a" assures me.
08:57:13 * hackage postgres-embedded 0.1.8 - Library for easily running embedded PostgreSQL server for tests.  https://hackage.haskell.org/package/postgres-embedded-0.1.8 (ilya_murzinov)
08:57:19 <dmwit> Ugh, that reminds me of a terrible problem I debugged a few weeks ago. By default, Fedora creates an alias for `which` that uses an *executable* named `which` and overrides the shell builtin. Why they did this I have no idea. The alias works okay on bash, but gets defined for zsh, too, where it doesn't work correctly... and so `which` was lying to me...
08:57:24 <ertes-w> ij: if you want man-pages from nix as well as from your system, you have to set MANPATH explicitly and include ~/.nix-profile/share/man
08:57:39 <dmwit> It took a while to notice because `which which` was also lying to me...
08:57:59 <ij> dmwit, sounds horrible
08:58:25 <ij> ertes-w, I'm merely curious how it finds the those manuals.
09:03:26 <cocreature> jle`: thanks for your great post on your hamilton lib! I’ve been wondering, do you have an actual usecase for it or is this just a really awesome toy project? :)
09:05:13 * hackage hocker 1.0.0 - Interact with the docker registry and generate nix build instructions  https://hackage.haskell.org/package/hocker-1.0.0 (ParnellSpringmeyer)
09:14:49 <mjhoy> ij: oddly, man finds my nix manuals on osx without setting MANPATH.
09:19:08 <quelqun_dautre> hi
09:20:34 <kuribas> What's the least painful language that you can also find a job in (without relocating)?
09:20:37 <kuribas> scale?  c# ?
09:21:17 <kuribas> scala
09:21:48 <quelqun_dautre> kuribas: what does it have to do with #haskell ?
09:22:03 <kuribas> quelqun_dautre: I mean for someone who like haskell of course
09:22:07 <kuribas> likes
09:22:20 <kuribas> or is proficient in it
09:22:40 <fakenullie> there's nothing like haskell except purescript
09:22:59 <EvanR> haskell
09:23:03 <kuribas> fakenullie: purescript jobs are practically non existant
09:23:05 <EvanR> get that job
09:24:42 <quelqun_dautre> purescript ?
09:24:46 <kuribas> EvanR: 0 jobs in Belgium
09:24:52 <EvanR> remote then
09:25:08 <fakenullie> all of europe is open to you
09:28:24 <rightfold> I had a PureScript job and it was great
09:29:16 <rightfold> It was also pretty easy to get at, just had to shitpost a lot about it on Twitter and someone contacted me with an offer
09:30:48 <Jikstra[m]> rightfold: you complained on twitter about no one offering a purescript job? :D
09:32:05 <rightfold> It was also remote, no relocation necessary. I also got other remote job offers from at least two companies.
09:32:40 <rightfold> I don’t know how remoting with Haskell is though, my current Haskell job is on site
09:35:09 <cement> I have an onsite haskell job, but they let me work remote if I need to, and whiteboarding is pretty helpful
09:35:41 <cement> it's not that it's hard to work remote, but it's very nice to pick my coworkers' brains
09:37:05 <rightfold> I much prefer remote. It enforces that all communication be written, which is objectively better for archiving reasons.
09:39:22 <cement> the only qualitative advantage is that it's easier to get a brain dump from someone and also ask questions about the specific pieces that need emphasis
09:39:45 <cement> archival is problematic, though
09:40:10 * hackage partial 1.0.0.0 - A nullary type class for partial functions  https://hackage.haskell.org/package/partial-1.0.0.0 (PhilFreeman)
09:40:19 <rightfold> Thanks paf31
09:40:52 <paf31> rightfold: yw, thanks for the PR :)
09:41:06 <paf31> I was thinking of adding a version with an "excuse" string in the dictionary
09:41:16 <rightfold> We will gladly use it
09:41:26 <rightfold> There was this other idea
09:41:32 <paf31> So when you call head on an empty list, you could get something like "assertion failed: <your excuse here>"
09:41:43 <rightfold> You can remove all overhead by aliasing the empty constraint in release mode :)
09:42:05 <paf31> :) yeah, true
09:43:11 <rightfold> And another useful utility is partialIO :: NFData a => (Partial => r) -> IO r
09:43:47 <paf31> I should also add Data.Maybe.Partial for things like fromMaybe
09:43:50 <paf31> fromJust, sorry
09:45:24 <adenGFX> can anyone point me in a direction of how I could achieve this ? http://lpaste.net/360342
09:46:29 <cement> you can look at the 'words' function perhaps
09:48:28 <adenGFX> cement: so turn the string to a list of strings, then remove the word ?
09:48:47 <mud> You could also do it with dropWhile, but try 'words' first, it might do close enough to what you need.
09:49:21 <humanoyd> rightfold: paf31 Wait, are you porting packages FROM purescript TO haskell? :>
09:51:44 <paf31> Occasionally, yes
09:52:08 <paf31> This one was from when the feature first got added to PS though
09:52:09 <exio4> rightfold: remote can rely on programmed online calls/meetings
09:53:05 <cement> >(unwords . drop 1 . words) "cat and dog"
09:53:31 <robertkennedy> Is there an equivalent of Python's eval in Haskell?
09:53:31 <cement> I really need to sit and mess with lambdabot on my own
09:55:10 <cocreature> @let dropFirstWord = dropWhile (not . isSpace) . dropWhile isSpace
09:55:11 <lambdabot>  Defined.
09:55:16 <cocreature> dropFirstWord "dog and cat"
09:57:00 <erisco> > dropFirstWord "supercalifragilisticexpialidocious"
09:57:03 <lambdabot>  ""
09:57:03 <cement> robertkennedy: I'm fairly certain there isn't, barring something in the "unsafe" series of functions
09:57:21 <erisco> Marry Poppins approved
09:57:40 <adenGFX> erisco: so what it is doing, is replacing the first word with a space?
09:59:04 <erisco> where do you see a space?
09:59:09 <paf31> rightfold: class Partial where excuse :: String seems to work nicely too :)
10:00:17 <paf31> rightfold: Might make sense to publish a Prelude with all of the partial versions annotated
10:00:45 <humanoyd> paf31: oops, didn't occur to me that the Haskell version could be older...just saw `nullary type class` and thought "Hey, I've seen this before..."
10:01:10 <mnoonan> robertkennedy: there is "hint", at least: http://conscientiousprogrammer.com/blog/2015/12/13/24-days-of-hackage-2015-day-13-hint-runtime-eval-for-haskell/
10:01:15 <rightfold> paf31: yeah nice
10:01:41 <fishythefish> adenGFX: I'd look at dropWhile/takeWhile or span/break in Data.List
10:03:52 <tabaqui> does anybody know how to specify ghc version with stach>
10:03:54 <tabaqui> ?
10:03:59 <tabaqui> like tinfo, ncurses or clean
10:06:19 <tabaqui> *stack, ofc
10:08:01 <fishythefish> tabaqui: do you already have the desired ghc version installed?
10:08:13 <tabaqui> fishythefish: system or stack?
10:08:33 <tabaqui> neither one, anyway
10:08:54 <fishythefish> if it's installed, you can run e.g. `stack ghc --resolver ghc-7.8`
10:09:06 <fishythefish> if not, you'll need to install it, run `stack setup --resolver ghc-7.8`
10:09:46 <tabaqui> and then I'll get clean ghc-8.0.2, while I want ghc-tinfo-8.0.2, f.e
10:10:08 <fishythefish> ah, okay, now I parse your question :P
10:12:16 <tabaqui> what I really want is to install i386 ghc on x86_64 debian
10:13:12 <tabaqui> but it fails with checksum error
10:13:18 <tabaqui> so I'm trying other versions
10:26:09 <f-a> hello, in a datatype declaration I have
10:26:11 <f-a> _menu       :: MenuState,
10:26:19 <f-a> error:     Not in scope: type constructor or class ‘MenuState’
10:26:25 <f-a> but MenuState is there in the same file
10:26:35 <f-a> I suspect it is a TH problem, but how to solve it?
10:26:36 <rightfold> Move the definition of MenuState to above the makeLenses call
10:26:54 <f-a> rightfold: the makeLenses are at the bottom of the file
10:26:57 <f-a> using microlens
10:27:14 <rightfold> Bizarre! Then I’m not sure.
10:27:23 <f-a> let me remove dist-newstyle
10:27:29 <f-a> maybe triggering recompilation will do
10:28:15 * hackage gnss-converters 0.3.23 - GNSS Converters.  https://hackage.haskell.org/package/gnss-converters-0.3.23 (markfine)
10:28:44 <tabaqui> ahh, ghc-7.6.3
10:28:52 <tabaqui> why debian is so slow...
10:30:14 <Clint> tabaqui: are you using an obsolete version of debian?
10:31:37 <tabaqui> jessy
10:31:51 <Athas> GHC 8.2 seems much slower at building Happy-generated parsers than 8.0.
10:31:53 <tabaqui> well, I found my old records and solve the problem
10:31:53 <Athas> That is unfortunate.
10:32:10 <Athas> Sometimes I get the impression that I'm the only one who didn't switch to parser combinators!
10:32:22 <tabaqui> you need to install binutils:i386, cpp:i386 and gcc:i386
10:32:31 <tabaqui> then install ghc with stack
10:33:49 <f-a> k
10:34:22 <f-a> rightfold: apparently leaving random words inside the .hs (i.e. a comment without {- -- confuses template haskell
10:34:25 <f-a> weird
10:36:43 <rightfold> top kek
10:36:49 <f-a> indeed
10:42:21 <ranberry> Anyone mind pointing me in the right direction to figuring this functional dependency issue I'm having? I have a function that I'm using from the linklater library named say with type:
10:42:26 <ranberry> say
10:42:28 <ranberry>   :: (Control.Monad.IO.Class.MonadIO m,
10:42:31 <ranberry>       mtl-2.2.1:Control.Monad.Error.Class.MonadError
10:42:33 <ranberry>         Network.Linklater.Types.RequestError m) =>
10:42:36 <ranberry>      Message -> Config -> m ()
10:42:48 <glguy> ranberry: No, don't paste into chat, use a pastebin
10:43:05 <ranberry> Whoops, better idea
10:43:09 <ranberry> sorry about that
10:43:38 <slackman> can I use Data.HashMap.Lazy with heterogeneous value types?
10:43:50 <slackman> like HM.fromList [("bar",2),("foo","bar")]
10:43:59 <glguy> slackman: What type would that have?
10:44:11 <slackman> I'm not sure
10:44:15 <glguy> Then no
10:44:55 <sbrg> slackman: you can do something like: data ManyThings = IntThing Int | StringThing String | AnotherThing .. 
10:45:08 <sbrg> and then Map String ManyThings
10:45:38 <Aleksejs> Hi, how do I read a file via Bytestring.Lazy.readFile and then write to the same file via B.L.writeFile? It shows resource locked and I think it's because of laziness
10:46:39 <glguy> Aleksejs: Open it using strict bytestrings instead of lazy ones to do it all at once
10:48:27 <Aleksejs> well, I guess I can't use strict because it's a JSON file and I use aeson
10:48:46 <glguy> No, you can, you'll just need to convert the result to a lazy bytestring
10:53:20 <Aleksejs> how do I convert from strict to lazy? Should I unpack and then pack back?
10:53:32 <Angelica> Please help! Send at least a dollar!Help the child!!!
10:54:10 <Aleksejs> ah, there is fromStrict function
10:59:38 <robertkennedy> Mnoonan: thanks
11:01:55 <slackman> sbrg: I tried that but I'm not sure how to interpret this error <http://lpaste.net/360346>
11:02:36 <slackman> I used aeson to decode json and it has no problems returning a hashmap like HM.HashMap String Value
11:02:40 <Angelica>  Please help! Send at least a dollar!Help the child!!!
11:02:46 <quakobert> someone know how I can determine if a number has a zero or one in binary at position ?
11:02:48 <slackman> where Value is same as your ManyThings
11:03:18 <quakobert> at a certain position ? *
11:03:23 <dminuoso> Does someone have the name of the presentation of dependent types in Haskell with regular expression at hand? Or a link?
11:03:25 <Aleksejs> fromStrict solved a problem, thanks!
11:03:27 <dminuoso> I remember it was some female PhD.
11:03:52 <slackman> quakobert you mean like .&amp;. ?
11:04:07 <sternmull> is there standard a way to express "inner exception" in Haskell? What i mean is a way that a function can catch an exception, wrap it with some context and then throwing the wrapper.
11:04:43 <quakobert> slackman: what does that do? i want to check if for 11001 the most right number is one or zero, what does .&amp;. do ?
11:05:10 <dminuoso> Ah I found it, nevermind.
11:08:59 <slackman> quakobert: if you can express your number as an integer, you can do for example 25 .&amp;. 1 to check if the least significant bit is set 25 .&amp;. 2 for the next one and so on
11:10:17 <Tuplanolla> > testBit 0b11001 0
11:10:19 <lambdabot>  error:
11:10:20 <lambdabot>      • Couldn't match expected type ‘Integer -> t’
11:10:20 <lambdabot>                    with actual type ‘Bool’
11:11:31 <slackman> &gt; testBit 25 0
11:11:47 <Tuplanolla> That should work with `BinaryLiterals`.
11:12:49 <slackman> what's with all the extensions
11:20:39 <raynold> Ahh it's a wonderful day
11:36:45 <ranberry> Anyone mind pointing me in the right direction for troubleshooting this error? http://lpaste.net/360345 I included my usage, the type/implementation from the lib, and the error. Sorry if I missed any other basic stuff!
11:48:52 <aberrant> hi all
11:49:09 <aberrant> really basic question: how do I write this correctly? myKth :: (Any a, Num k) => [a] -> k -> a
11:49:18 <aberrant> obviously, "Any a" isn't correct
11:49:38 <glguy> myKth :: [a] -> Int -> a
11:49:46 <rightfold> Remove the Any constraint
11:49:47 <aberrant> oooooh.
11:49:53 <rightfold> You don’t need it
11:50:02 <rightfold> A constraint only adds restrictions
11:50:04 <aberrant> rightfold: I tried that but it still errored.
11:50:08 <rightfold> You want no restrictions
11:50:13 <aberrant> I think glguy might have it.
11:51:16 <[exa]> what does 'Any' do?
11:51:34 <rightfold> type Any a = ()
11:53:36 <aberrant> that worked. Thank you, glguy and rightfold.
11:53:52 <aberrant> I need error handling, but it works :)
12:08:19 * hackage type-of-html 1.2.0.0 - High performance type driven html generation.  https://hackage.haskell.org/package/type-of-html-1.2.0.0 (knupfer)
12:09:09 <knupfer> And a new release is there, backwards compatibility with ghc 8
12:09:11 <knupfer> :)
12:19:37 <aplainzetakind> I was writing some functions around a c binding library I wanted to use. I realized that calling functions that return foreign pointers, then discarding those pointers (like doing f x >> pure ()) caused segaults. Making those pointer-returning functions strict seems to have solved this, but I don't really understand why. How can I acquire understanding on that matter?
12:23:45 * hackage hs-functors 0.1.1.0 - Functors from products of Haskell and its dual to Haskell  https://hackage.haskell.org/package/hs-functors-0.1.1.0 (MatthewFarkasDyck)
12:25:03 <aberrant> I don't understand this sentence in LYAH: "Note: Not only can we call functions as infix with backticks, we can also define them using backticks. Sometimes it's easier to read that way."
12:25:33 <aberrant> why would you want to define functions using backticks? How would this be easier to read?
12:25:47 <pikajude> because they're used with backticks off
12:25:49 <pikajude> often*
12:25:53 <pikajude> like elem for example
12:26:38 <aberrant> if you define `elem` and elem', they'd be called with the same infix syntax, right? a `elem` b and a `elem'` b ?
12:26:54 <pikajude> sure
12:26:57 <aberrant> ok
12:27:11 <aberrant> still not sure what advantage there is in defining functions with backticks.
12:27:19 <aberrant> need more practice.
12:27:25 <mnoonan> (x:_) `startsWith` y = x == y, [] `startsWith` _ = False
12:27:33 <mnoonan> as opposed to
12:27:46 <mnoonan> startsWith (x:_) y = x == y   -- etc
12:28:02 <aberrant> OH.
12:28:23 <aberrant> *lightbulb goes on*
12:28:41 <aberrant> thanks. That's what I was missing. I was thinking `startsWith` (x:_) y was still how you defined it.
12:29:21 <mnoonan> ah, yeah, that would be not so useful. a nice thing is you can backtick a function or not, so you can use it as infix or prefix as you see fit in each situation
12:30:12 <mnoonan> but usually if it reads nicely when used with backticks, it'll probably read nicely when defined with backticks too
12:30:21 <[exa]> there should be a book called 'the infinite sweetness of syntactic sugar'
12:31:05 <mnoonan> [exa]: seriously. for me, "where" bindings are practically a killer app for Haskell :)
12:31:31 <aberrant> this is really cool. Thanks for tolerating beginner questions.
12:33:53 <[exa]> mnoonan: we have a tiny language here where 'where' is kindof inline using « and »; so you can put «a=b+c» anywhere (and it looks especially nice in the place that is usually designated for comments)
12:34:22 <mnoonan> oh, interesting!
12:34:28 <mnoonan> where is "here"?
12:34:47 <[exa]> here at the experimental unfinished language farm :D
12:36:48 <[exa]> the nice thing is that it allows you to visibly define a thing at first usage, not before/after
12:40:13 * hackage product 0.1.0.0 - Product category  https://hackage.haskell.org/package/product-0.1.0.0 (MatthewFarkasDyck)
12:46:42 * hackage accelerate-utility 1.0 - Utility functions for the Accelerate framework  https://hackage.haskell.org/package/accelerate-utility-1.0 (HenningThielemann)
12:49:51 <sternmull> is there a stack template to start a fresh library including tests?
12:51:46 <asoltysik> haskeleton i think
12:52:20 <zachk> is there a way to get websockets working with the scotty http library?
12:52:50 <asoltysik> Hi, I am looking for a package that implements the 128bit version MurmurHash3. So far I've found two packages with 32 bit murmur3 and some murmur2 package. Is there maybe some package for hashing that gathers many algorithims and that's why I can't find it?
12:54:43 * hackage accelerate-arithmetic 1.0 - Linear algebra and interpolation using the Accelerate framework  https://hackage.haskell.org/package/accelerate-arithmetic-1.0 (HenningThielemann)
12:56:34 <fishythefish> asoltysik: based on a quick search, would this work? http://hackage.haskell.org/package/Dish
12:57:05 <sternmull> asoltysik: Thanks. hpack is completely new to me.
12:58:03 <asoltysik> fishythefish: thanks! I have no idea how I could miss that
13:00:23 * hackage accelerate-fftw 1.0 - Accelerate frontend to the FFTW library (Fourier transform)  https://hackage.haskell.org/package/accelerate-fftw-1.0 (HenningThielemann)
13:04:01 <mnoonan> sternmull: the 'hspec' template gives you a library + executable + test suite using hspec-discover, too
13:04:28 <asoltysik> fishythefish: Dish requires: base (>=4.6.0 && <4.7)"
13:04:40 <asoltysik> I have 4.9.1, what can I do about it?
13:05:04 <asoltysik> except for downgrading the base
13:05:08 <fishythefish> that's unfortunate
13:05:45 <fishythefish> you could try fetching the source and see what it takes to build against latest base
13:08:03 <asoltysik> and if I make it work against latest base, can I include is as a local dependency or something like that? Note that I am writing a package for hackage
13:09:57 <asoltysik> Hmm I guess I will just make a FFI for C implementation of this algorithm
13:10:06 <fishythefish> I'm not too knowledgeable about hackage
13:10:34 <fishythefish> if the package maintainer is active, you could submit a pull request for dish
13:11:02 <fishythefish> if you're up to it, you could also author your own package for it
13:15:49 * hackage accelerate-fourier 1.0 - Fast Fourier transform and convolution using the Accelerate framework  https://hackage.haskell.org/package/accelerate-fourier-1.0 (HenningThielemann)
13:15:55 <sshack> I have a stack question. I'm developing a yesod app on MacOS and all is going fine. However, when I use stack image container to build a docker container the built yesod app in the container is build for MacOS. How can I correct this so yesod builds for linux on the docker image target?
13:19:40 * hackage hscolour 1.24.3 - Colourise Haskell code.  https://hackage.haskell.org/package/hscolour-1.24.3 (MalcolmWallace)
13:26:47 <Person> >>> youtube.com/watch?v=X8qL6cAI0zQ
13:27:54 <Person> >>> youtube.com/watch?v=X8qL6cAI0zQ
13:28:02 <EvanR> stahp
13:32:38 --- mode: ChanServ set +o glguy
13:32:38 --- mode: glguy set +q *!*@185.143.40.132
13:33:56 <ericshortcut> Hi, I'm looking for information about Yesod's connection Pool. Does anyone use it here?
13:34:24 <ericshortcut> I'm trying to make a mult-tenancy system.
13:52:08 <dsfox> Suppose you want a pretty printer that almost always works - is there a way to write a function that calls pPrint on values that have Pretty instances and (text . show) on values that only have Show instances?
13:53:40 * hackage hoogle 5.0.14 - Haskell API Search  https://hackage.haskell.org/package/hoogle-5.0.14 (NeilMitchell)
13:56:51 <[exa]> dsfox: well, you will hit overlapping instances if you just derive the general fallback Show a => PPrint a
13:57:13 <fishythefish> dsfox: you could use https://github.com/mikeizbicki/ifcxt, but it's debatable whether this is good practice
13:57:46 <[exa]> dsfox: there's also this wiki entry: https://wiki.haskell.org/GHC/AdvancedOverlap
14:00:44 <[exa]> fishythefish: wow ifCxt is cool
14:00:57 <[exa]> isn't there the prolog's cut in the typeclasses somewhere?
14:01:08 <dsfox> exa, fishythefish: thanks.  ifcxt looks pretty interesting.  My actual application is to distinguish whether or not a value is an instance of Ixed (from the lens package).  I had a feeling there were quetions about good practice, but I haven't found an alternative.
14:01:34 <fishythefish> I mean, ultimately they all boil down to overlapping instances somewhere
14:01:37 <fishythefish> it's just a choice of approach
14:02:13 <qmm> one would think that you could match on this: data Foo = Bar Baz Quz
14:02:18 <[exa]> dsfox: generally, anything that looks like adhoc overloading will be problematic :]
14:02:23 <dsfox> I don't fully understand the point about overlapping instances
14:02:52 <dsfox> Maybe I'll soon know more than I care to!
14:03:25 <[exa]> dsfox: a simpler example would be defining e.g. instance Show a -> Show [a] together with instance Show [Int]
14:04:04 <dsfox> the fallback Show a => PPrint a does seem dangerous - that's why I'm trying to avoid it
14:04:09 <fishythefish> qmm: are you unable to pattern match on that?
14:04:16 <[exa]> dsfox: compiler doesn't know which one to choose because both are applicable for showing [Int] (and so this is overlapping)
14:04:28 <qmm> fishythefish: weirdly not.
14:04:37 <qmm> match f | f == Bar _ _ = print "yes" causes this message to appear, "Found hole: _
14:04:38 <fishythefish> qmm: can you provide a minimal paste?
14:04:54 <qmm> it suggests that the relevant binding is f
14:05:02 <[exa]> dsfox: Show a => PPrint a will cause you trouble whenever you already have a Show for something, but want to assign it a different output for pPrint
14:05:26 <fishythefish> qmm: that's not a pattern match, you're testing equality
14:05:28 <fishythefish> so that's a typed hole
14:05:55 <fishythefish> a pattern match would be `match (Bar _ _) = print "yes"`
14:06:11 <[exa]> qmm: you want to use 'case' keyword which allows pattern matching like this
14:06:39 <qmm> if i make it into a case statement, everything compiles 
14:07:15 <[exa]> qmm: the thing you're using are guards, which is in fact a case internally, see https://wiki.haskell.org/Case#Guards
14:07:55 <qmm> [exa]: it could be nice to use guards 
14:08:20 <fishythefish> guards are unnecessary in your example
14:08:21 <lyxia> match f | Bar _ _ <- f = print "yes"
14:08:41 <[exa]> qmm: oh sorry it's not 'case' internally, I got confused
14:09:08 <qmm> [exa]: i thought guards compiled to case expressions as well
14:09:38 <[exa]> at least the link was wrong :]
14:09:49 <fishythefish> [exa]: link wasn't wrong, but i think you're misreading it
14:09:54 <[exa]> yep :]
14:10:28 <qmm> lyxia: that works. backwards arrow is new to me
14:10:46 <fishythefish> qmm: keywords are "pattern guard"
14:11:54 <qmm> fishythefish: thanks
14:16:37 <orion> Is it possible to pass chunks of strict ByteStrings to aeson?
14:17:18 <orion> I ask becuase http-client gives me a BodyReader, and my only options for retrieving the body are brRead, brReadSome, and brConsume.
14:18:21 <int-e> orion: there's fromChunks in Data.ByteString.Lazy, does that help?
14:26:31 <dsal> "cabal install pointfree" is failing for me.  Can't seem to compile.  Did someone break something?
14:27:03 <lyxia> dsal: what's the error
14:27:50 <dsal> This is the compiler output: https://www.irccloud.com/pastebin/2tYnEFve/pointfree.log
14:30:55 <Mins> Hello, I want to make a something, which is like a sieve. Example: sieve [(<3), (>7)] [1,5,9] ~> [[1], [9] [5]] 
14:30:56 <Mins> http://lpaste.net/5875329301728985088
14:32:47 <fishythefish> Mins: do you understand the error?
14:33:16 <Mins> Yes. But I can't just make the "b" to "a".
14:33:22 <smckay> sieve :: [(a -> Bool)] -> [a] -> [[a]] ?
14:33:27 <Mins> Yes
14:33:41 <glguy> dsal: You're trying to build a very old version of the package
14:33:53 <dsal> Huh.  Why would I try that?
14:34:00 <glguy> dsal: The author didn't bother putting version constraints on this version of the package and it doesn't build with the current versions of its dependencies
14:34:06 <glguy> dsal: You'd have to ask dsal
14:34:15 <dsal> I'll pm
14:34:31 <dsal> I'm just typing 'cabal install pointfree' -- is there a way to get that to work more magically?
14:34:45 <glguy> Not on a package like this where the version constraints are wrong
14:34:52 <fishythefish> Mins: once you've fixed the type error (as smckay suggested), we can address logic issues
14:35:19 <glguy> You can look on hackage for the current version. cabal-install probably didn't pick the current version because its version constraints are incompatible with something about your current environment: http://hackage.haskell.org/package/pointfree-1.1.1.3
14:36:23 <fishythefish> Mins: two places to start are that fs is never used and that `f x` will produce a Bool, which doesn't seem to be what you want
14:36:35 <dsal> Hmm...  I removed all of ~/.cabal and ~/.ghc and it still tries 1.0.3 by default.
14:36:54 <glguy> dsal: then your GHC is probably too new. You should not have deleted those directories
14:36:58 <orion> int-e: That was helpful, thanks.
14:37:09 <Mins> I've "fixed" it, but now he the inferred type is everywhere bool.
14:37:32 <fishythefish> Mins: you're going to continue to get inferred type errors because your implementation doesn't do what you want
14:37:43 <int-e> > foldr (\f sv -> (\(ys,zs) -> ys : sv zs) . partition f) (:[]) [(<3), (>7)] [1,5,9]
14:37:45 <lambdabot>  [[1],[9],[5]]
14:37:47 <Mins> Yes, I see it. Wait.
14:37:50 <dsal> Yeah, looks like I've got ghc 8.2.1
14:37:55 <glguy> dsal: ``cabal install --dry pointfree-1.1.1.3`` will show you why the latest version isn't possible
14:38:10 <int-e> @pl  (\f sv -> (\(ys,zs) -> ys : sv zs) . partition f)
14:38:10 <lambdabot> flip ((.) . (`ap` snd) . (. fst) . flip ((.) . (:))) . partition
14:38:15 <glguy> rejecting: base-4.10.0.0/installed-4.1... (conflict: pointfree => base>=4.5 && <4.10)
14:39:08 <int-e> (well, that was pointless)
14:39:20 <fishythefish> (boo, get off the stage)
14:39:28 <Mins> Yey, now it works for the first f.
14:39:49 <smckay> i see people using lambdabot for that and the result is usually totally unreadable to me. is that normal?
14:39:58 <glguy> smckay: Yes
14:40:00 <fishythefish> yup
14:40:01 <Mins> sieve [(<3),(>5)] [1,2,3,5,6] ~> [1,2]
14:40:17 <mud> smckay: Most of them are bad ideas. Occasionally you find a decent one though.
14:40:17 <glguy> smckay: The output of ?pl isn't generally suitable for using in real code; it's a curiosity
14:41:53 <Mins> fishythefish: Now I need to concat the lists, so I get a list of lists
14:42:51 <hexagoxel> is pattern-matching in let/where always lazy?
14:43:46 <infinisil> Is it totally okay to have a variable of type `TVar (TQueue Foo)` or is nesting STM like this something bad?
14:43:48 <_d0t> stupid question. Are import list and hiding list mutually exclusive?
14:44:01 <zwarag> Assuming I have a binary tree representing a sorted integer array. How can I "collapse" the tree into a sorted list using only : instead of building a list with ++ like here: https://pastebin.com/U71AxPrB
14:45:35 <infinisil> zwarag: Why would you want that?
14:45:55 <hexagoxel> _d0t: you want to both black- and white-list?
14:46:47 <infinisil> zwarag: And ++ is defined in terms of : anyways
14:47:41 <_d0t> hexagoxel: no, i'm actually rewriting some code for hint and wanna know if this is supported
14:47:54 <hexagoxel> pretty sure it is not.
14:48:00 <_d0t> ok, thx
14:48:27 <Mins> It works now, but I need to delete the "sieved" elements. I don't know how. http://lpaste.net/5875329301728985088
14:49:10 <Mins> sieve [(<3),(>5)] [1,2,3,5,6] ~> [1,2,6,1,2,3,5,6] (but I need [[1,2], [6], [3,5]]
14:49:21 <Gurkenglas> :t partition -- Mins
14:49:23 <lambdabot> (a -> Bool) -> [a] -> ([a], [a])
14:49:54 <smckay> concat is probably not what you want
14:50:19 <Mins> I'm not sure, how I can delete it without an infinite loop. 
14:50:19 <smckay> why not : ?
14:50:55 <fishythefish> hexagoxel: yeah, pretty sure they're both lazy (irrefutable)
14:53:39 <Mins> Gurkenglas: :i partition ~> Unknown reference `partition'
14:55:12 <jle`> cocreature: well i actually wrote it because i wanted to ask a physics question i believe
14:55:15 <Gurkenglas> Mins, you'll need to import Data.List
14:55:38 <Mins> I think we shouldn't do it.
14:55:40 <jle`> cocreature: i wanted to find out an answer to an actual physics problem i was mulling around, so the library was helpful for that :)
14:55:52 <Mins> Is it possible with "filter"?
14:55:59 <Gurkenglas> Mins, yes
14:56:32 <Gurkenglas> You'll apply each f to each a twice that way tho
14:57:59 <Gurkenglas> (Note that you're already doing a filter with the ", f x]" part
14:58:02 <Gurkenglas> *)
14:58:07 <hexagoxel> fishythefish: thanks. i just found that 2010 report indeed says so for at least `let`.
14:58:40 <fishythefish> hexagoxel: I know it specifies that for let, and I'm pretty sure where behaves the same way
14:58:56 <fishythefish> they both work lazily in current ghci
14:59:40 <Mins> Can I use something to invert "f" and use it like "[x | x<-xs, (not f) x]"? 
15:00:04 <Mins> Gurkenglas: flip inverts the function?
15:00:14 <glguy> [x | x <- xs, not (f x) ]
15:00:20 <Mins> Okay, thank you!
15:01:06 <jle`> Mins: flip f x y = f y z
15:01:11 <jle`> it doens't quite invert the function
15:01:15 <Mins> Yep, I've tried :i flip
15:01:17 <jle`> it just flips the order of the arugments
15:01:31 <fishythefish> hexagoxel: looks like section 4.4.3.2 covers simple pattern bindings lazily. I think this encompasses both cases
15:01:35 <jle`> inverting a function in general is impossible! :o
15:01:59 <Mins> Okay :D Now my function is doing what I want... but now I need to get a list of lists: http://lpaste.net/5875329301728985088
15:02:33 <Mins> sieve [(<3),(>5)] [1,2,3,5,6] ~> [1,2,6,3,5] (but need to give me: [[1,2],[6],[3,5]]
15:03:04 <Mins> I think first I need to modify: sieve :: [(a->Bool)] -> [a] -> [[a]] (so it gives me a list of lists)
15:03:18 <fishythefish> Mins: you don't want to append lists with (++); you want to make a new list out of all the lists
15:03:28 <fishythefish> and your intuition about the type is correct :)
15:03:42 <Mins> (++) was just for testing.
15:04:13 <Mins> Should I use "<-"?
15:04:20 <Mins> To generate a list out of the lists
15:09:44 <Mins> unification would give infinite type http://lpaste.net/5875329301728985088
15:11:47 <glguy> Mins: What are you using to generate that message?
15:11:59 <Mins> I try to compile it.
15:12:04 <Gurkenglas> Mins, that means that [a -> Bool] -> [a] -> [a] = [a -> Bool] -> [a] -> [[a]] would mean that a would have to be the type of lists of a, [[[[[...]]]]]
15:12:16 <glguy> Mins: Yeah, but which what program. Just curious what version of what you're using
15:12:25 <glguy> The current GHC error for that code points directly at the problem
15:12:25 <Mins> We need to use hugs96.
15:12:46 <glguy> You can use GHC for the nicer error messages and then load working code in hugs
15:12:59 <Mins> Ah. Okay... Eh... I don't know how I should fix that >.<
15:13:22 <glguy> Mins: the error is on line 2
15:13:43 <Mins> The first line is line 0 or line 1?
15:13:45 <glguy> of your paste, the body of that function clause is wrong
15:14:00 <glguy> it's the one with the number 2 next to it
15:14:12 <Mins> Ah, got it
15:14:13 <Mins> [xs]
15:14:31 <Mins> It works <3
15:14:32 <Gurkenglas> Do all editors for all languages start with line number 1?
15:15:01 <Mins> I was confused, because I didn't saw the error in line 2... I thought it was in line 3
15:15:11 <Mins> But it works, thank you all!
15:15:21 * hackage time-exts 3.0.4 - Yet another time library  https://hackage.haskell.org/package/time-exts-3.0.4 (EnzoHaussecker)
15:15:50 <Mins> sieve [(<3),(>7),odd] [1,2,3,4,5,6,7,8,9,10] [[1,2],[8,9,10],[3,5,7],[4,6]]
15:15:59 <smckay> hmm should sieve [] [] = [] or [[]]?
15:16:06 <Mins> Best IRC ever.
15:16:14 <Mins> Eh, I think [[]]. 
15:17:07 <Mins> But... it's not appointed by my teacher. So I'll use [[]]
15:19:18 <smckay> yeah after thinking about it [[]] seems more appropriate. then (length $ sieve fs xs) == (length fs + 1)
15:20:47 <Mins> Yep. Why is there a "$" in front of sieve?
15:21:29 <glguy> (f $ g x) is a complicated way to write f (g x)
15:21:52 <mnoonan_> it saves -1 characters!
15:22:43 <Mins> Okay, thanks :D
15:24:48 <hexagoxel> it is a "complicated" way to write (f (g x)). that version at least works independent of context.
15:25:46 <lyxia> f (g x) also works
15:26:00 <hexagoxel> print (f $ g x) === print f (g x)   ?
15:29:56 <duncan^> wow, hugs is still going
15:30:19 <fishythefish> f $ g x == f (g x). (f $ g x) == (f (g x))
15:30:56 <aplainzetakind> Is there a "monadic generalization" (not a well defined meaning at all) of <*> in the applicative instance of functions? I mean something that is :: (a -> b -> m c) -> (a -> m b) -> (a -> m c) rather than (<*>) :: (a -> b -> c) -> (a -> b) -> (a -> c) ?
15:33:17 <mud> :t (<*>)
15:33:18 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
15:33:40 <jle`> :t \f g x -> f x =<< g x
15:33:42 <lambdabot> Monad m => (t -> a -> m b) -> (t -> m a) -> t -> m b
15:34:00 <Gurkenglas> :t liftA2 (=<<) :: Monad m => (a -> b -> m c) -> (a -> m b) -> (a -> m c)
15:34:01 <lambdabot> Monad m => (a -> b -> m c) -> (a -> m b) -> a -> m c
15:34:36 <jle`> this makes sense, becuase
15:34:40 <jle`> <*> = liftA2 ($)
15:34:40 <aplainzetakind> Gurkenglas: Yes, that seems the most natural.
15:34:42 <Mins> duncan^: My teacher want to use Hugs, because it's the basic of a functional programming language. The newer interpreter have new functions or something... 
15:34:51 <jle`> so this is liftA2 (=<<)
15:34:59 <jle`> since (=<<) is just a "monadic" version of ($)
15:35:08 <Gurkenglas> jle`, I assumed he who specialized to the ((->) a) functor would accept its use
15:35:21 <aplainzetakind> Cool, thanks.
15:35:38 <raynold> Ahh it's a wonderful day
15:35:40 <jle`> Gurkenglas: yeah, just pointing out an interesting  liftA2 ($) => liftA2 (=<<) parallel
15:35:50 <jle`> aplainzetakind: i probably wouldn't use liftA2 (=<<) in real code though 
15:35:54 <jle`> it's not terribly readable
15:37:36 <jle`> :t liftA2 ($)
15:37:38 <lambdabot> Applicative f => f (a -> c) -> f a -> f c
15:37:40 <jle`> :t liftA2 (<$>)
15:37:42 <lambdabot> (Functor f2, Applicative f1) => f1 (a -> b) -> f1 (f2 a) -> f1 (f2 b)
15:37:48 <aplainzetakind> jle`: Of course, I was just curious.
15:37:50 <jle`> :t liftA2 (=<<)
15:37:52 <lambdabot> (Applicative f, Monad m) => f (a -> m b) -> f (m a) -> f (m b)
15:38:12 <jle`> :t liftA2 (<*>)
15:38:13 <lambdabot> (Applicative f2, Applicative f1) => f1 (f2 (a -> b)) -> f1 (f2 a) -> f1 (f2 b)
15:38:16 <jle`> lifting function application is fun ~
15:39:07 <aplainzetakind> Actually if there were a single infix operator that was standard...
15:39:38 <jle`> i don't think it comes up often enough to warrant its own operators
15:40:00 <jle`> adding an operator is a huge cost to justify
15:40:48 <aplainzetakind> It came up quite naturally to me but I'm pretty sure that's because I'm using >>= in an inappropriate way.
15:41:12 <jle`> i mean, a lot of things come up naturally, but that doesn't mean they warrant an operator :)
15:42:07 <aplainzetakind> Sure, I wasn't seriously suggesting there be one.
15:42:55 <aplainzetakind> But I try to avoid do notation generally, possibly because of my noob enthusiasm for less-imperative-looking code.
15:44:06 <aplainzetakind> And trying not to use do notation seems likely to give rise to situations where this would be handy.
15:44:34 <nshepperd> :t liftA2 liftA2 liftA2 liftA2
15:44:35 <lambdabot> Applicative f => (f c -> b -> c) -> (f (f c) -> f b -> b) -> f (f c) -> f b -> c
15:45:18 <woodson> hi does anyone know why aeson-0.7.0.6 is hasking for a lower version of bytestring?
15:45:30 <jle`> lower than what
15:45:44 <_d0t> aplainzetakind: the fun starts when you begin using do-notation for other than io-based monads
15:45:53 <woodson> In the dependencies for aeson-0.7.0.6: bytestring-0.10.8.1 must match >=0.10 && <0.10.4.0 latest applicable is 0.10.2.0   time-1.6.0.1 must match <1.5 
15:46:00 <woodson> im getting this error
15:46:11 <glguy> woodson: That's an old version of aeson, it depends on old versions of things
15:46:22 <jle`> woodson: that's probably because that's the version of bytestring that was around when aeson-0.7.0.6 was being written
15:46:23 <zachk> maye I hask a question about the hask category j/k
15:47:36 <jle`> woodson: but, yes, "lower than what"?
15:47:43 <jle`> lower than the one you have?
15:47:58 <woodson> yes
15:48:04 <woodson> bytestring-0.10.8.1
15:48:24 <jle`> aeson 0.7.0.6 was written about four years ago
15:48:40 <woodson> i just noticed that 
15:48:43 <jle`> they didn't try to imagine how bytestring-0.10.8 would look like or try to anticipate any changes
15:48:50 <woodson> 1.2.3
15:48:53 <woodson> is the latest
15:48:58 <jle`> so they probably restricted it to <0.10.4 to anticipate breaking changes
15:49:04 <woodson> sorry i think im goo for a break
15:49:07 <jle`> it's common practice to put upper bounds on deps :)
15:49:08 <woodson> good**
15:49:15 <jle`> oh no need to be sorry
15:49:24 <jle`> i thought you were asking why old versions of libraries put upper bounds
15:49:30 <jle`> knowing that it was old
15:49:34 <jle`> it's actually a controversial topic
15:49:56 <woodson> no, i think i know what happened...
15:50:04 <woodson> i believe that i was following an old tutorial
15:50:17 <woodson> and thats how i got it in here
15:50:30 <jle`> a lot of people are philosophically against upper bounds, so asking why an old version of a library has an upper bound on deps is a legitimate question
15:50:51 <jle`> woodson: what tool are you using to install aeson, bytestring, etc.?
15:50:59 <woodson> stack
15:51:03 <woodson> jle: stack
15:52:42 <jle`> ah.  yeah stack doesn't go that far back, but in many cases stack is useful for recreating the environment of ancient blog posts
15:52:49 <cement> Maybe I'm just inexperienced or naive, but I sometimes wanna make changes that would absolutely break backwards compatibility, and removing upper bounds would require that to never happen, or so it seems to me...
15:53:42 <woodson> jle: what is mostly used stack or ngix?
15:53:44 <jle`> the argument against them is that usually in that case your build would break anyway
15:53:46 <glguy> cement: it just becomes some else's problem
15:53:55 <glguy> it doesn't mean you never break backwards compat
15:53:56 <jle`> s/your/their
15:54:31 <jle`> woodson: stack is more common than ngix i think,
15:54:48 <mud> xD
15:55:06 <cement> ngix =?= nix
15:56:50 <fishythefish> and here I am thinking "ngix =?= nginx"
15:58:48 <nshepperd> i think i come out in favour on the basis that it's easier to get a version mismatch error, download the offending package then bump its version bounds locally, than it is to find the correct package+version that you need to downgrade when build breaks
16:02:05 <jle`> i do agree
16:03:54 <woodson> yes nix
16:06:18 <cement> I think most people do use stack, but I do know of at least 2 companies that use nix to support their haskell development
16:07:47 * infinisil is a nix person too
16:07:59 * infinisil uses stack on nix even
16:08:09 <cement> wait what
16:08:21 <cement> I thought stack2nix was still borked
16:08:28 <infinisil> not using stack2nix
16:08:37 <infinisil> i mean stack on nixos
16:08:46 <cement> I think clever would have some strong words for you
16:09:15 <infinisil> it works fine, stack has even builtin support for nix
16:09:49 <infinisil> well it works once you know the quirks, I wish to use just nix for it in the future
16:10:18 <cement> hmmm... sounds tempting, because it is a hellova pain when you've gotta jailbreak like 20 packages to get the "proper" versions
16:11:14 <infinisil> i can help you get around the quirks
16:11:29 <infinisil> (with stack on nixos that is)
16:12:01 <cement> well, currently my purely nix setup is actually working, so long as I don't add any more dependencies that were written in-house
16:14:04 <infinisil> i actually haven't added any self-made dependencies, so i'm not sure if that part's quirkless
16:15:23 <cement> well, what I mean is that sometimes I've got dependencies that are on hackage, but need dontcheck and were put up like a day ago
16:17:13 <infinisil> that are on hackage but not stackage?
16:18:35 <__monty__> I came across "You can't implement Functor (a,b)." And I didn't really see the problem, you could seemingly write something that satisfies the functor laws. Actually trying to write it the closest I got is bimap though (a -> b) -> (c -> d) -> f a c -> f b d. Is there a way to reduce that to a single function argument? Currently thinking typeclass constraint.
16:20:16 <glguy> __monty__: Functor (a,b) doesn't even kind-check
16:21:17 <__monty__> glguy: I know, but that seems more a practical limitation than a theoretical limitation to me. I'm talking about functor the idea not Functor the typeclass anymore.
16:21:48 <fishythefish> __monty__: it's an important distinction
16:22:16 <fishythefish> it's not hard to make it functorial in either component (or both), but it affects your semantics and what it takes to implement it in haskell
16:22:34 <sm> Clint: what's a good way to find out if http://hackage.haskell.org/package/extra is packaged in debian ?
16:23:58 <dminuoso> Is there a way to allow for `λx → 2 * x` be accepted by GHC?
16:24:28 <__monty__> dminuoso: You mean unicode notation?
16:24:36 <dminuoso> __monty__: Yes, particularly the lambda.
16:24:44 <jle`> with UnicodeSyntax you can come close, but the problem is that the lambda is a valid variable name in haskell
16:24:45 <fishythefish> dminuoso: add the UnicodeSyntax language extension
16:24:59 <jle`> as in, people use greek letters in their variable names
16:25:02 <fishythefish> but both not and lambda are problems
16:25:02 <jle`> especially like, greek people
16:25:12 <dminuoso> jle`: Oh.. hah. I didn't actually consider that. 
16:25:32 <jle`> i believe the arrow is valid under UnicodeSyntax
16:25:46 <jle`> but lambda being a valid variable name causes some issues with lambdas for lambda notation
16:26:10 <__monty__> Greek characters should just be banned. Greek question mark has been a tool of pranksters for far too long : )
16:26:28 <dminuoso> jle`: The argument with greek folks seems a bit moot, since this could just be an extension
16:26:47 <dminuoso> But Im guessing that fact would make the parser a bit a funky
16:27:55 <__monty__> I wonder how Agda handles the lambda, never thought of using it as a variable name.
16:28:04 <jle`> well one would like UnicodeExtension to work for eveyone
16:28:10 <jle`> maybe LambdaLambda would be a separate extension
16:28:50 <thoughtpolice> -XGREEK_SMALL_LETTER_LAMBDA
16:28:51 <dminuoso> Cant we just name it λλ 
16:29:40 <jle`> extensions ahve to be uppercase
16:29:42 <jle`> so it's ΛΛ
16:30:12 <lyxia> So, M.
16:30:22 <lyxia> ghc -XM
16:30:31 <dminuoso> jle`: Mmm. https://gist.github.com/anonymous/0b3bcd162907a52984dfd8ccc0070efe :(
16:30:34 <Axman6> -DLAMBDA=λ ... LAMBDA x -> x+x
16:31:07 <jle`> dminuoso: ?
16:31:59 <Axman6> {-# LANGUAGE Pretentious #-}
16:32:03 <dminuoso> It seems like despite enabling UnicodeSyntax, GHCi gives me ASCII-style notations.
16:32:27 <thoughtpolice> pretty-printing doesn't respect -XUnicodeSyntax, no. I think it's always been that way.
16:32:35 <Axman6> the extension only allows you to use it to write code, not to print it
16:33:50 <geekosaur> yeh, the ppr stuff neither knows nor cares about UnicodeSyntax
16:34:47 <geekosaur> nor does it ever refer to your original source except in terms of SrcSpans (locations in the source file); the code it shows is reconstructed from the AST
16:34:48 * Axman6 nor should it
16:35:43 <__monty__> Axman6: Why the unicode aversion?
16:36:04 <__monty__> I think it's reasonable to expect the behavior when enabling the extension.
16:39:03 <Axman6> butauce it adds small mental barriers when trying to read other people's code. there's nothing more frustrating than coming across a package which used alpha and beta everywhere that convention would have used a and b, for no benefit. humans are very good at pattern recognition, and using unicode syntax breaks the patterns. I use the FiraCode font so that I can have nice ligatures in my code, but wouldn't want to inflict them on others
16:39:40 <Axman6> because*
16:40:08 <Axman6> if you want things to look pretty in your terminal too, use fuch a font there too
16:40:20 <Axman6> such* man, what's going on with my typing today
16:40:31 <__monty__> Axman6: The pretty printing behavior has zero impact on you though. It's the actual code written using the extension that you'd take issue with.
16:40:32 <thoughtpolice> Well, I think the point was more "if you fed GHC some code with unicodesyntax, and it spits it back out, it seems reasonable to give back the syntax you wrote". That's a very reasonable suggestion, for example, if you leveraged GHC to format code automatically. It'd be bad to disregard what the user typed and throw it away.
16:41:10 <__monty__> Exactly what I think.
16:41:13 <thoughtpolice> But it's a bit confusing here because when you ask for ":t", GHCi isn't telling you "the type it read in the source code, the one you typed." It's telling you "the type the type checker inferred", and that's a bit different. It may just so happen you wrote down that type too, but GHC is telling you the inferred one. It "forgets" everything else, including whether or not the original thing was using unicode syntax, or not.
16:41:19 <smckay> Axman6: I sympathize with that as an argument against UnicodeSyntax existing at all
16:41:23 <thoughtpolice> After all, you could have written no type at all and GHC would have still inferred it.
16:42:32 <nshepperd_> I sometimes use alpha and beta as type variables because a and b are already taken :|
16:43:10 <__monty__> I disagree with most of the flak unicodesyntax gets, the arrow is not that different, the double colon is not that different, even lambda is not that different if you squint.
16:43:12 <thoughtpolice> So it's one of those fiddly UX things, though I sort of just said it was "the pretty printer", it's a bit more than that. I would expect GHC's SrcSpans to accurately reflect the fact a UnicodeSyntax keyword was used -- and I'm (100%) certain it does. It's just not displaying what you wrote, despite what it looks like.
16:43:16 <nshepperd_> Which is probably even worse tbh
16:43:30 <smckay> it sounds like the AST is annotated to the extent it needed to be, to recover source locations for example. UnicodeSyntax breaks the assumption that -> has exactly one tokenization so the level of annotation is now insufficient
16:47:45 <__monty__> Since the extension changes the parser anyway it should be able to properly annotate the AST, no?
16:49:56 <geekosaur> it could even be argued that UnicodeSyntax being means it should just go ahead and generate the Unicode version instead
16:50:17 <geekosaur> I mean, it already does things like collapsing layout into braces and semicolons
16:50:26 <geekosaur> it's not reproducing the original source anyway
16:56:19 * hackage classyplate 0.3.0.1 - Fuseable type-class based generics  https://hackage.haskell.org/package/classyplate-0.3.0.1 (lazac)
16:57:20 <Axman6> id ∷ a -> a; id x = x; myId = id; :t myId = ?
16:57:46 <Axman6> __monty__: it probably changes the lexer actually
16:59:47 <__monty__> Imo :t myId should print the unicode version.
17:03:12 <__monty__> You're probably right about it only changing the lexer though. But that doesn't mean it shouldn't affect the AST generated.
17:36:46 * hackage columbia 0.2 - Enhanced serialization using seeking.  https://hackage.haskell.org/package/columbia-0.2 (JamesCandy)
17:38:33 <_test123> latest upload of hscolour is busted: http://hackage.haskell.org/package/hscolour-1.24.3/reports/1
17:38:45 <_test123> this is breaking a lot of things, anyone know how to contact Malcolm Wallace?
17:38:49 <_test123> No contact info on the hackage page
17:43:32 <fishythefish> _test123: maybe tweet at him?
17:52:11 <netsu[m]> Hello, everybody
17:52:37 <netsu[m]> Is there any haskell library available for matrix.org protocol?
17:52:50 <sm> netsu[m]: have a search on hackage
17:53:30 <netsu[m]> I mean, for server side. Cant't find nothing relevant on hackage
17:57:14 * sm neither
18:12:06 <_test123> fishythefish: I'm not a twitter user; would you be kind enough to do so?
18:12:18 <fishythefish> _test123: i'm not either ._.
18:13:09 <_test123> fishythefish: surely there must be a way to contact, google isn't helping alas
18:14:34 <fishythefish> _test123: found malcolm.wallace@me.com
18:17:00 <orion> What is an obvious and clear cut example of when not to use a type class instead of a record of functions if your goal is to make a unified interface to some data?
18:18:38 <_test123> fishythefish: Thanks! Sent an email and it didn't bounce back. Hopefully he'll see it soon.
18:24:03 <Cale> orion: When there would naturally be many implementations for a single type, or when defining the way that the operations should act requires doing IO setup.
18:35:28 <bigos> is this the right place to ask stack questions?
18:37:32 <MarcelineVQ> it's one of a couple but it's a goo place to try first
18:38:05 <bigos> one moment
18:41:25 <bigos> https://github.com/commercialhaskell/stack/pull/3325 what is your opinion about possibility of fixing this windows bug?
18:42:14 <orion> Cale: What about the reverse? What is a clear cut example of when to use a type class in this case?
18:44:41 <MarcelineVQ> bigos: oh ehe, that's not the usual kind of question, most people are mystified about how to use stack rather than how to fix it. I'm not sure, but if you've any ideas I'm sure it would help people for you to give it a try: gtk and windows are common subjects that come up so someone would benefit from a fix.
18:45:05 <MarcelineVQ> bigos: just as a quick pre-check though did you check out https://github.com/commercialhaskell/stack/issues/3154 ?
18:45:39 <bigos> yes i have seen it
18:45:58 <bigos> it helped me to move forward and settle on the stack bug
18:50:14 <bigos> another thing, how long does it take to compile Haskell from source on a typical high end laptop?
18:52:53 <MarcelineVQ> good question, I've not compiled in awhile, expecting something like 25 mins with good metal
18:53:40 <Axman6> "Haskell" == "GHC"?
18:53:46 <MarcelineVQ> number seems to vary a lot on who you ask
18:53:54 <MarcelineVQ> Axman6: good point ehe
18:54:20 <EvanR> only 25 minutes?
18:55:32 <MarcelineVQ> EvanR: not been your experience? maybe I get nicer numbers than other people somehow <_<
18:58:07 <MarcelineVQ> ah possibly I had been doing unoptomized builds
18:59:34 <EvanR> maybe moores law made my understanding of GHCs build time obsolete
19:00:13 <Cale> orion: The main thing that type classes do relative to records is that they establish a convention for which operations are the ones to use for any given type
19:00:57 <Cale> orion: Consider something like Num. It would be rather inconvenient to always be passing records of addition/multiplication/fromInteger etc. around explicitly.
19:01:34 <bigos> last time i tried it took me many hours, i wonder why
19:05:20 <Guest9494> Hey all. Would anyone be able to help me with a question about the scientific library?
19:06:19 <Guest9494> The scientific package uses "round half to even" behind the scenes: https://github.com/basvandijk/scientific/blob/e709988f5b0986c9dc2fbab6726e5d38b70ac74e/src/Utils.hs
19:06:41 <Guest9494> But the roundTo function doesn't have any comments. Does anyone know how to modify that to do "round half up" instead of even?
19:10:26 <Axman6> by default, IIRC IEEE-754 also does round to even
19:11:31 <Guest9494> Axman6 yes, I'm aware of that. But I need match the behaviour of another program (written in another language) that does round half up
19:12:40 <Axman6> can you implement your own function which does the rounding you want and use that?
19:14:27 <Guest9494> Yeah I think so. But since I'm aiming to use the scientific library, I was aiming to keep my function as close as possible to scientific's roundTo, and only slightly modify it so that it does round half up instead of even
19:24:28 --- mode: glguy set +q-q *!*@gateway/web/irccloud.com/x-pkveljrkgmzholvz *!*@185.143.40.132
19:33:01 <joe9> I am trying to figure out how I can match a particular exception, but, cannot get it to work. http://bpaste.net/show/78199831384a is my relevant code , error http://bpaste.net/show/7bda9c14abea . This is happening in the line "Left (SomeException EndOfDayException)".
19:33:08 <joe9> any suggestions, please?
19:33:44 <EvanR> thats not right because SomeException is abstract
19:33:52 <EvanR> you cant decompose it
19:34:04 <EvanR> but you can convert it to your desired exception type using toException
19:34:04 <Axman6> you should read the docs for the Exception class
19:34:10 <Axman6> https://hackage.haskell.org/package/base-4.10.0.0/docs/Control-Exception.html
19:34:29 <joe9> EvanR: Axman6, Thanks.
19:43:17 <elvishjerricco> Is stack’s build plan 100% deterministic in the presence of new Hackage revisions?
20:24:10 <mud> elvishjerricco: AFAIK, yes.
20:25:56 <jle`> elvishjerricco: what new hackage revisions?
20:26:45 <elvishjerricco> jle`: Just revisions on Hackage that weren't there when the snapshot was made
20:27:08 <elvishjerricco> jle`: Hackage trustees have the ability to mutate the cabal files of packages without changing their versions.
20:27:16 <elvishjerricco> and maintainers, not just trustees
20:27:29 <jle`> elvishjerricco: oh you mean new revisions to the package that have been uploaded to hackage
20:28:07 <elvishjerricco> jle`: Well, not new _version_, just new revisions, e.g. these: https://hackage.haskell.org/package/vector-0.11.0.0/revisions/
20:28:25 <jle`> ah i see
20:28:35 <jle`> i thought you had meant revisions to the actual website/hackage server
20:29:21 <mud> Oh those. I ... have no idea.
20:29:32 <jle`> hm that's an interesting question
20:30:48 <elvishjerricco> I know there have been some arguments on github over them wrt stackage, but I don't know what actually came of them.
20:32:40 <jle`> hm
20:32:51 <jle`> well, the actual downloaded tarbals are not affected
20:33:11 <jle`> and the actual versions themselves are pinned down once and forever on stackage
20:34:05 <jle`> so i suppose if you use a stackage snapshot, the hackage metadatas aren't even consulted
20:35:01 <jle`> since resolving the dependencies happen only once
21:50:31 <Donovan> does anyone here have experience with writing dependantly typed functions in Haskell? I'm trying to write a foldr for heterogeneous lists
21:50:51 <Donovan> so far I have the definition of Foldr at a type level, but i'm struggling to get the compiler to accept the actual function
21:50:55 <Donovan> seen here: https://gist.github.com/donovancrichton/efb06223ec6a2b136afcf79da194f460
21:51:42 <Axman6> what sort of function do you want to fold over the list?
21:51:53 <Donovan> just composition/application
21:57:02 <jle`> Donovan: (c :: (a -> b -> b)) doesn't make any sense
21:57:08 <jle`> as an argument
21:57:25 <jle`> since all types of values have kind *
21:58:05 <jle`> Donovan: the typical analogous concept of a "fold" for something like a heterogeneous list is an eliminator
21:58:22 <jle`> (if you're looking for a keyword to google)
21:59:01 <Donovan> alright, i'll take a look jle`, did you mean the argument doesnt make sense in the Foldr family, or the foldrH function?
21:59:09 <jle`> the foldrH function
21:59:59 <jle`> what do you really want foldrH to do?
22:00:56 <Donovan> go through my heterogeneous list and recursively apply, something like `foldr (.) id list`
22:01:06 <Donovan> or just do the usual things that a foldr can
22:01:29 <Donovan> like `foldr (flip :) [] list`
22:02:21 <jle`> can you give a concrete example of what lists you might be wanting to use?
22:03:07 <Donovan> there's one at the bottom of the gist
22:03:30 <Donovan> i want to fold my lists of expressions
22:05:01 <Donovan> so turn `HList Expr '[Integer -> Char -> Integer, Integer, Char]` to `Expr Integer`
22:05:15 <jle`> yes this isn't really anything you would call a fold
22:05:22 <jle`> [f,x,y] => f x y?
22:05:36 <jle`> what happens if there is a fourth item in the list?
22:05:57 <Donovan> not sure yet, i figured i'd get the basic working first
22:06:14 <jle`> yeah, it's not really something that makes sense to call a fold
22:06:19 <jle`> you aren't doing anything repeatedly for every item in a list
22:06:34 <jle`> you could just directly pattern match and apply the first item to the second two items
22:07:17 <jle`> it's not really any...systematic thing
22:07:19 <Donovan> alright, well what about turning `HList Expr '[Integer -> Char -> Integer, Integer, Char] to HList Expr '[Char, Integer, Integer -> Char -> Integer]`?
22:07:25 <Donovan> that's a fold right?
22:07:26 <jle`> it's just an arbitrary function on lists
22:08:03 <jle`> Donovan: you mean like reverse for HList ?
22:08:06 <Donovan> yeah
22:08:34 <jle`> yeah, you could write it as HList f '[a,b,c] -> HList f '[c,b,a]
22:08:48 <Donovan> but as a more general case?
22:09:28 <Donovan> i still think i should be able to get out a fold for heterogeneous lists
22:09:45 <Donovan> especially for things like reverse, or function application
22:10:02 <jle`> that is a better candidate for a fold, but the original thing you gave doesn't really make sense for systematic reduction
22:10:12 <Donovan> alright, i'll pay that :) 
22:13:03 <Donovan> back to my foldrH, what would i replace the c :: a -> b -> b with? just c? The compiler then complains it wants a higher kind
22:13:04 <jle`> but hm, it's not something you'd write an eliminator for
22:13:19 <jle`> Donovan: well you have a kind mismatch here
22:13:37 <Donovan> im not sure i understand
22:13:42 <jle`> your Foldr type family expects something of kind (k -> j -> j)
22:13:55 <jle`> so if you use 'Foldr c acc as'
22:14:07 <jle`> then c has kind k -> j -> j
22:14:19 <jle`> but there is no value with that kind
22:14:50 <jle`> er sorry, no values of types of that kind
22:15:11 <jle`> so if foldrH :: c -> ..., c has to have kind *
22:15:28 <jle`> so it's not something you can give to Foldr type family
22:15:59 <Donovan> hmm
22:16:05 <Donovan> this is hard
22:16:17 <jle`> but you can have some sort of representation of that function at the value level
22:16:28 <jle`> a FunWrapper :: (k -> j -> j) -> *
22:16:50 <jle`> and so something like foldrH :: FunWrapper c -> .... would be well-kinded
22:16:56 <jle`> this is what the singletons library does
22:17:24 <Donovan> ahh ok
22:17:37 <jle`> but really you're sort of mixing ideas on a bunch of different levels here
22:18:26 <jle`> in any case, if 'c' is a type-level function, it doesn't make sense to require a c-value
22:18:44 <Donovan> where do you learn this stuff?
22:18:58 <Donovan> the stuff i've looked at for dependent types in Haskell online doesnt go into much detail
22:19:03 <Donovan> and shows me the same examples over and over
22:20:04 <jle`> the idris book helps :) and digging into the singletons library helps too to see how to link those concepts back into haskell.  but you should probably first clarify your thoughts in actual dependently typed functions before thinking about how to translate that into haskell
22:21:04 <Donovan> alright, i guess i'll go read that then, cheers :)
22:21:09 <jle`> that's the thing with learning dependently typed programming in haskell -- kind of like learning haskell concepts in other language.  it's hard enough learning these concepts, but learning to butcher it into haskell at the same time adds another layer of difficulty in learning :)
22:21:34 <jcarpenter2> totally
22:21:35 <jle`> but actually a fold over an HList like you are thinking is of questionable value
22:21:53 <jcarpenter2> dependent types are like the join of this forest of GHC features
22:21:54 <jle`> it might be a sort of XY problem kinda thing
22:21:58 <jcarpenter2> (or meet if you prefer)
22:22:14 <Donovan> is it the book by Edwin Brady?
22:22:23 <jle`> mhm
22:22:35 <Donovan> ok cool
22:48:51 * hackage substring-parser 0.3.0.0 - Match / replace substrings with a parser combinators.  https://hackage.haskell.org/package/substring-parser-0.3.0.0 (igrep)
22:58:06 <balor> My understanding is that Type families and functional dependencies are functional and relational (respectively) mechanisms for encoding similar constraints.  Is there a source that demonstrates how to rewrite type family constraints as fun deps (where possible) and vice-versa?
22:59:48 <opqdonut> type family Foo x y; type instance Foo Int Char = Bool; <==> class Foo x y z | x y -> z; instance Foo Int Char Bool;
23:04:33 <phadej> is it possible to issue a warning (`fail` would error) in template haskell?
23:16:19 <balor> opqdonut, Oh, thanks.  Didn't realise it was that straightforward
23:17:51 <cocreature> phadej: my google foo brought up https://hackage.haskell.org/package/template-haskell-2.12.0.0/docs/Language-Haskell-TH-Syntax.html#v:qReport but I haven’t tried it :)
23:36:23 <phadej> cocreature: thanks!
23:40:24 <quchen> Is there a clearer way to write this?
23:40:25 <quchen> altMax _ x        Nothing  = x
23:40:26 <quchen> altMax _ Nothing  y        = y
23:40:26 <quchen> altMax f (Just x) (Just y) = Just (f x y)
23:40:56 <quchen> Eh, ignore the »max«, I meant to use this with f=max.
23:41:23 <cocreature> I think "liftA2 f x y <|> x <|> y" is equivalent but whether that’s clearer is debatable :)
23:41:31 <jle`> (Max <$> x) <> (Max <$> y)  ?
23:42:15 <jle`> > Just (Max 3) <> Just (Max 5)
23:42:17 <lambdabot>  error:
23:42:17 <lambdabot>      • Data constructor not in scope: Max :: Integer -> a
23:42:17 <lambdabot>      • Perhaps you meant variable ‘max’ (imported from Data.Ord)error:
23:42:27 <jle`> @let import Data.Semigroup
23:42:29 <lambdabot>  Defined.
23:42:31 <jle`> > Just (Max 3) <> Just (Max 5)
23:42:34 <lambdabot>  error:
23:42:34 <lambdabot>      Ambiguous occurrence ‘<>’
23:42:34 <lambdabot>      It could refer to either ‘Data.Monoid.<>’,
23:42:40 <jle`> this is me being sad
23:42:43 <jcarpenter2> pwned
23:42:56 <jle`> @let import Data.Semigroup as SM
23:42:58 <lambdabot>  Defined.
23:43:01 <jle`> > Just (Max 3) SM.<> Just (Max 5)
23:43:04 <lambdabot>  Just (Max {getMax = 5})
23:43:09 <jle`> > Just (Max 3) SM.<> Nothing
23:43:12 <lambdabot>  Just (Max {getMax = 3})
23:43:19 <jle`> > Nothing SM.<> Just (Max 5)
23:43:22 <lambdabot>  Just (Max {getMax = 5})
23:43:31 <cocreature> or just "max" and no newtype
23:43:38 <cocreature> if "max" is really all you care about
23:43:54 <jle`> oh yeah, Maybe has an ord instance
23:44:07 <tdammers> that's SMP for you. Been biting me quite a bit lately.
23:44:18 <tdammers> even though it is morally the right thing
