00:00:00 <qqkami> in fact its not digits that im interested but ive sorted something depending on what another function outputs when using them as inputs and now i have to sort the ones that are "equal when used as inputs" in another way - if there is another way could you hint me to that please
00:10:23 <qqkami> nevermind i just changed my "quicksort" to check for the second "sorting paramter" too - it calls the other function a lot now but it shoudlnt really matter
00:13:55 * Lokathor writes the first mildly complex function and is already considering lenses
00:14:00 <Lokathor> rip
00:14:36 <[exa]> dark side is the easy path
00:15:01 <Lokathor> http://lpaste.net/359734 poor records
00:15:07 <Lokathor> just not quite easy to work with
00:21:18 <[exa]> room exits aren't functions?
00:37:42 <jgt> are Haskell people awake at this hour?
00:40:02 <nicknight> jgt:  what happend to this hour?
00:42:49 <nicknight> oh may be midnight to some countries
00:43:45 <Sornaensis> haskell people are always awake
00:44:46 <nicknight> 22*7 :)
00:45:19 <nicknight> 2 hours to read logs :P
00:54:17 <jle`> it's midnightnish in alaska?
00:54:33 <opqdonut> I just got to work
00:54:45 <opqdonut> in alaskaish latitudes
01:12:11 <boj> it is indeed midnight in alaska
01:12:51 <boj> i am headed there tomorrow even
01:13:54 * boj leaves Friday evening and arrives.. Friday evening
01:18:22 <capisce> "People who refuse to self-promote [...] can end up feeling like losers in a game they never agreed to play."
01:19:22 <capisce> wrong window
01:19:23 <foojs> have you guys met ferge?
01:19:37 <foojs> https://en.wikipedia.org/wiki/Frege_(programming_language)
01:20:06 <boj> it tends to come up
01:23:06 <ertes-w> helo
02:17:33 <merijn> hmmm
02:18:01 <merijn> So, github somehow believes I have 0 issues assigned to me, while yesterday it was like 20+...anyone else have the same happen?
02:18:04 <mbrock> Lokathor: that could be a demonstration of why I like relational data external to the data records as in `Set (Room, Door, Room)` ;) (don't wanna pester you about this, I just find it an interesting tradeoff)
02:18:46 <mbrock> merijn: it's the great issue jubilee. you are now free to pursue your own leisurely interests instead of fixing other people's problems. woo hoo!
02:19:30 <merijn> mbrock: They weren't other people's problems. They were my todo list for my own problems >.>
02:19:45 <merijn> mbrock: Since, 90% of them were from the issues on my dotfile repository >.>
02:20:21 <mbrock> that was the annoying past you who outsourced all his problems to present you! >_<
02:23:37 <merijn> There appears to be no one way to get them listed again...that's annoying as fuck
02:38:46 <helpneeded> hi there, I need help with a function, how can I split a list into two lists based on a certain condition?
02:39:56 <ventonegro> @hoogle [a] -> ([a], [a])
02:39:56 <lambdabot> Data.List.HT removeEach :: [a] -> [(a, [a])]
02:39:56 <lambdabot> Agda.Utils.List holes :: [a] -> [(a, [a])]
02:39:56 <lambdabot> DSP.Basic uninterleave :: [a] -> ([a], [a])
02:40:02 <phaazon> hey
02:40:02 <Athas> helpneeded: partition.
02:40:11 <phaazon> what is the flags key in stack.yaml for?
02:40:11 <Athas> Or span.
02:40:16 <Athas> It depends on how you want to split them.
02:40:26 <ventonegro> @hoogle (a -> Bool) -> [a] -> ([a], [a])
02:40:27 <lambdabot> Prelude span :: (a -> Bool) -> [a] -> ([a], [a])
02:40:27 <lambdabot> Prelude break :: (a -> Bool) -> [a] -> ([a], [a])
02:40:27 <lambdabot> Data.List span :: (a -> Bool) -> [a] -> ([a], [a])
02:40:30 <phaazon> I need to declare a flag for all local packages defined in the stack.yaml
02:40:33 <phaazon> is it the right way to go?
02:40:35 <Athas> > partition (\x -> x `mod` 2 == 0) [0..10]
02:40:38 <lambdabot>  ([0,2,4,6,8,10],[1,3,5,7,9])
02:40:40 <Athas> > span (\x -> x `mod` 2 == 0) [0..10]
02:40:43 <lambdabot>  ([0],[1,2,3,4,5,6,7,8,9,10])
02:42:15 <helpneeded> Athas it's basically split the list into two sublists; if it is divisible by 2 put it in the "left", if not into the "right" sublist
02:42:39 <helpneeded> Athas: i think partition will work
02:43:42 <Athas> helpneeded: yes, partition is exactly what you need.
02:48:52 <helpneeded> Athas: alright I think I'm not supposed to import the base package so I'll have to solve it otherwise wow
02:50:23 <Athas> helpneeded: base is implicitly availabled.  Just do 'import Data.List'.
02:50:49 <merijn> helpneeded: base is a part of GHC
02:51:36 <helpneeded> we're supposed to use hugs, is there a way to import that in hugs, because it's giving me errors
02:52:01 <merijn> Rats...I got myself in a situation where I need to write a complex function and can't write out the type due to GADT shenanigans >.>
02:52:52 <Athas> The wonders of advanced languages.
02:52:59 <Athas> helpneeded: Hugs?  Uh.  Try 'import List'.
02:53:14 <Athas> But Hugs is old and dead and starting to smell really funny.  Why are you using that?
02:53:38 <Athas> It used to have a better interactive experience than GHC, but that hasn't been the case for ten years or so.
02:53:50 <helpneeded> the exercise is valuated with hugs
02:54:17 <Athas> Well, I seem to recall that Hugs is from before the Haskell module namespace became hierarchical, so the module is 'List' instead of 'Data.List'.
02:54:36 <merijn> Athas: Some lecturers apparently still insist on Hugs...
02:54:38 <helpneeded> and somehow import List wont work aswell, "ERROR - Syntax error in expression (unexpected keyword "import")"
02:55:03 <helpneeded> I think it's a good way to stop someone from using those predefined functions
02:56:54 <Athas> merijn: sounds like an elegant way to ensure your students will never be able to find information on their own.
02:57:00 <ertes-w> what's the currently recommended regex package in terms of performance?
02:57:09 <merijn> ertes-w: attoparsec? >.>
02:57:12 * merijn ducks
02:57:28 <MarcelineVQ> Athas: supposedly it's because, certain people think, typeclasses are too confusing to introduce right away
02:57:39 <ertes-w> merijn: i'm not gonna embed a haskell interpreter =)
02:58:09 <merijn> Rats...why I gotta make my own life difficult >.>
02:58:23 <ertes-w> regex-tdfa sounds reasonable…  is it a good choice?
02:58:54 <merijn> "I'll just implement a generic library to solve this probably once and for all" -> "Oh, that would be a neat addition to add" -> *confusing mess of GADTs and recursion* "...whoops"
02:59:23 <merijn> ertes-w: Just write an attoparsec parser that parsec a regex into an attoparsec parser? :p
02:59:28 <int-e> dmwit: oh wow lambdabot actually did die there (usually it's a connection problem but this seems to have been a VM reboot. interesting...)
03:00:30 <Athas> MarcelineVQ: I certainly think Haskell is a dubious choice for many teaching purposes, but it seems like a poor solution to then select another language also called "Haskell", but which is not compatible with the "Haskell" you can find information about online.
03:00:33 <ertes-w> merijn: great idea…  and if you become my first sponsor, i'll make it open source =P
03:01:21 <MarcelineVQ> Athas: it's pretty silly
03:11:45 <ongy> can I nest ReaderTs?
03:11:53 <Athas> Yes.
03:12:12 <Athas> But you'll have to manually use 'lift' to pick the one you want to get an environment from.
03:12:23 <ongy> in a convinient way? GeneralizedNewtypeDeriving in a single stack doesn't like me :(
03:12:26 <merijn> You can, but you probably shouldn't :p
03:12:42 <merijn> ongy: Are you deriving MonadReader?
03:12:43 <Athas> No, you can't define several MonadReader instances for the same stack.
03:12:47 <ongy> ah, that's annoying. So I'll probably rather put a record of interesting types in instead of nesting the ReaderTs
03:12:51 <ongy> yes
03:12:54 <Athas> You get to manually say 'lift ask', 'lift (lift ask)', etc.
03:13:00 <merijn> ongy: Yes, you should use the record approach
03:13:04 <ongy> yea, then record works better
03:24:00 <helpneeded> Athas you previously used this: partition (\x -> x `mod` 2 == 0) [0..10], how can i do this when I  have doSomething [Int] -> ([Int],[Int]) , but instead of the [0..1] i use the input for that method?
03:24:22 <helpneeded> [0..10]  is what i wanted to say
03:44:25 <ongy> argh, that fundep for MonadREader is annoying. so I can't even make my own instances that get the right element from the Record :(
03:44:47 <merijn> ongy: Maybe you wanna look at the lens stuff for reader?
03:45:06 <merijn> ongy: You can just pass a lens for your record and it will grab the right element from the record in the reader
03:45:38 <dminuoso> heath: just btw
03:45:39 <dminuoso> :t even
03:45:42 <lambdabot> Integral a => a -> Bool
03:45:44 <dminuoso> Oh, they left.
03:57:56 <phaazon> is there a way to declare ghc-opts in a stack.yaml?
03:58:05 <phaazon> so that it overrides the .cabal / package.yaml?
03:58:07 <phaazon> it’d be great.
03:58:54 <phaazon> oh yes it’s possible
03:59:01 <phaazon> https://github.com/commercialhaskell/stack/blob/master/doc/yaml_configuration.md#ghc-options
04:02:13 <phaazon> arf, it doesn’t parse
04:04:21 <ongy> merijn: not sure yet if I want to depend on lens. Maybe I should...
04:04:46 <phaazon> wtf
04:05:18 <phaazon> that ghc-options doesn’t work.
04:06:13 <MarcelineVQ> are you looking for asistance phaazon? the coin for that is what you've tried and the error it gave you
04:06:52 <phaazon> MarcelineVQ: yeah I just want to build the local packages declared in my stack.yaml with a specific -DFLAG
04:07:52 <phaazon> MarcelineVQ: https://gist.github.com/phaazon/9e913bb5faf2b3e8616cf563e9689869
04:08:11 <phaazon> stack --version
04:08:12 <phaazon> Version 1.5.1, Git revision 600c1f01435a10d127938709556c1682ecfd694e (4861 commits) x86_64 hpack-0.17.1
04:10:53 <MarcelineVQ> what's your whole stack.yaml?
04:10:57 <jchia_> Is there a not-too-complicated way to modify a json file (insert new keys or delete existing keys) without changing the original order of keys? In Python, this can be done using OrderedDict (https://stackoverflow.com/questions/6921699/can-i-get-json-to-load-into-an-ordereddict-in-python), but with aeson, there's no such thing.
04:10:59 <phaazon> it’s heavy, MarcelineVQ 
04:11:00 <phaazon> why?
04:11:14 <phaazon> well, “heavy”
04:11:30 <MarcelineVQ> because parse errors aren't exact so what you think is the problem isn't neccesarily the problem
04:11:59 <phaazon> it’s on the same line as I declare ghc-options:
04:13:42 <phaazon> goddammit.
04:13:45 <phaazon> I should read more.
04:13:48 <phaazon> Non-project config options may go in the global config (/etc/stack/config.yaml) or the user config (~/.stack/config.yaml).
04:13:56 <phaazon> it doesn’t go in the stack.yaml
04:13:58 <phaazon> :–––––––––’)
04:14:18 <phaazon> it’s not gonna be simple then
04:14:24 <phaazon> since the configuration is linked to a given stack.yaml
04:14:28 <phaazon> jesus I hate stack
04:14:36 <phaazon> it’s not production ready
04:15:04 <MarcelineVQ> those options can go in stack.yaml just fine
04:16:07 <MarcelineVQ> I'd reccomend against setting things like that in global configs as much as possible.
04:20:39 <MarcelineVQ> I'd like to see the whole stack.yaml if you're still having issues. also is this actually a -Dflag you need, or is it a cabal flag?
04:21:01 <MarcelineVQ> *-Dsymbol
04:27:23 <tabaqui> how can I substitute table name with mysql-simple?
04:27:38 <tabaqui> when I query "select foo from (?)" (Only "table_name")
04:27:51 <tabaqui> it translates to "select foo from 'table_name'"
04:28:07 <tabaqui> with redundant single-quotes
04:38:34 <tabaqui> well, you just need to newtyped your table_name
04:38:41 <tabaqui> and redefine Param instance for it
04:39:01 <tabaqui> instead of Escape'd render you have to use Plain
05:05:37 <ertes-w> jchia_: JSON hashes are unordered…  if any application relies on the order, it needs to be fixed
05:05:51 <ertes-w> jchia_: in other words: just use aeson
05:06:06 <jchia_> ertes-w: It's not for the machines, it's for the human being's ease of reading.
05:07:49 <ertes-w> jchia_: humans can filter the JSON through 'jq -S .'
05:08:03 <ertes-w> jchia_: that also formats it nicely
05:08:40 <ertes-w> (aeson outputs minified JSON)
05:09:45 <jchia_> ertes-w: I didn't know about jq. I'm going to check it out.
05:18:41 <someexercise> can i do like in java a+b > 9 ? 1: 0
05:19:24 <opqdonut> someexercise: "if a+b>9 then 1 else 0"
05:19:49 <someexercise> thank opqdonut 
06:06:27 <WinterFox[m]> Would anyone be able to help me work out what this type error is? https://bpaste.net/show/d424389121b5
06:06:33 <lavalike> does anyone know if this pattern is already embodied by some function somewhere
06:06:38 <lavalike> :t \x y -> listToMaybe x >> return y
06:06:39 <lambdabot> [a] -> b -> Maybe b
06:07:18 <lavalike> WinterFox[m]: looks like a Text is expected where a String is being used
06:07:55 <WinterFox[m]> Text is not the same thing as String?
06:07:57 <lavalike> nope
06:08:17 <lavalike> Text is an implementation of unicode text, String is an actual list of Char values
06:09:15 <WinterFox[m]> Oh
06:09:44 <WinterFox[m]> Maybe the guide I used is out of date
06:10:37 <WinterFox[m]> How do I use text? Can't seem to find much about it.
06:10:38 <lavalike> I think you might just be missing that thing that lets ghc interpret string literals as Text
06:11:07 <lavalike> {-# LANGUAGE OverloadedStrings #-} I believe it is
06:12:02 <lavalike> yeah https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#overloaded-string-literals
06:12:10 <WinterFox[m]> I'll have to look in to that
06:12:26 <WinterFox[m]> Does LANGUAGE work in ghci?
06:12:46 <lavalike> there's something in ghci for it to not have to restart it, let's see in the help
06:13:07 <lavalike> :showi language -- shows you the current modifiers
06:13:48 <lavalike> :seti -XOverloadedStrings -- there it is
06:14:39 <WinterFox[m]> That seems to work :D
06:14:43 <lavalike> ^_^
06:15:15 <lavalike> at the very top of that page you see the explanation of how language options can be set, there's 2 ways
06:37:20 <foojin> How do I install a patched version of a certain package globally (in ~/.stack/snapshots/...) using Stack? I'd like to make some improvements but the stuff I need is in internal modules or not exported.
06:40:42 <hvr> foojin: does this need to be done via Stack?
06:40:49 <MarcelineVQ> foojin: that's not what stack is about but you may be able to make your own resolver that includes such packages, not sure https://docs.haskellstack.org/en/stable/custom_snapshot/  possibly.
06:41:16 <hvr> foojin: cause what you want sounds like a good use-case for http://cabal.readthedocs.io/en/latest/nix-local-build-overview.html
06:48:00 <foojin> hvr: Stack is the first tool that I've actually used a little bit over the past week or so, but it's by no means my preference. If I understand correctly, Stack uses cabal under the hood, so learning cabal might give me more insight into the whole process, but I'm unsure if I should mix both.
06:50:32 <hvr> foojin: it's a bit of a complicated matter; Stack uses *parts* of cabal under the hood, while trying hard to facade away certain behaviour its developers consider flawed in cabal as it doesn't fit into their design/ux philosophy. so you have to differentiate between the different kind of "cabal" people refer to if they say "cabal"
06:51:56 <hvr> foojin: to make it short, stack basically is forced to use the least amount of "cabal" needed in order to be able interpret .cabal files; but they don't really make use of the UI of "cabal" which has a lot of additional machinery not accessible to Stack
06:52:15 <hvr> foojin: and the nix-style local builds thing is actually a cabal-specific feature Stack cannot use
06:55:22 <hvr> foojin: if you're interested to learn more about cabal nix-style local builds, feel free to join #hackage and I'll try to help you through it
06:56:52 <foojin> hvr: I didn't know that there's a separate channel for that.
06:57:28 <hvr> foojin: it's just the channel where most cabal devs hang out; 
06:59:47 <foojin> hvr: Anyways I don't really see myself having the kind of problems that Stack is said to help solve, namely installing so many packages that their transitive dependencies end up being incompatible.
07:01:34 <hvr> foojin: to be fair, if cabal doesn't have access to a valid solution, neither has Stack
07:01:35 <MarcelineVQ> that's not quite what stack's meant to solve, but is is a nice side effect of the problem stack is mean to solve. either way if you don't have those issues now you'll have them later so you'll want to learn about stack or cabal new-build (what hvr is talking about), or cabal sandboxes sometime soon
07:02:01 <merijn> hvr: If we add a network-uri dependency to multi-ghc-travis, I think I can actually make tests using external (i.e., not in the current repo) dependencies that are not on Hackage work
07:02:17 <foojin> hvr: So I'll check out cabal if the same setup I'm trying to recreate (some global packages to import them in one-file script-like programs and to use them in ghci) is possible with it.
07:02:45 <hvr> merijn: I think I already told you, that since we cabalized the script, the original limitation to ghc boot libs is kinda moot :)
07:03:02 <merijn> hvr: Yeah, just checking :)
07:03:06 <hvr> merijn: i.e. feel free to add deps within reason
07:03:39 <hvr> foojin: if you hit a wall, please lemme know
07:03:54 <merijn> hvr: Basically, adding globs to optional-packages and then having the yaml script fetch them from the install step should let them be picked up
07:05:10 <merijn> Anyway, that's for later, I have complicated GADT abuse to implement and package :p
07:05:36 <MarcelineVQ> merijn: is it a, tasty, gadt?
07:05:54 <foojin> MarcelineVQ: So if I understand correctly, there's nothing stack can do that cabal cannot? Even those nice conflict-preventing snapshots must contain enough for cabal to make sense of it.
07:06:07 <merijn> MarcelineVQ: No, although I am using it to simplify generating tasty test trees :p
07:08:48 <MarcelineVQ> stack can install the ghc version needed for a project which afaik cabal can't do currently, but that's simply a requirement of stack's actual job, which is to manage projects that need to be built reproducably. as in if it builds today it should build a year from now, you may not have the same ghc verson a year from now so stack has to be able to fill such gaps
07:09:21 <merijn> MarcelineVQ: I just keep multiple ghcs around and point cabal at the right one, tbh
07:09:48 <ventonegro> merijn: If only something could automate that...
07:09:54 <MarcelineVQ> that's an option too, I don't have an endorsement in a particular direction
07:10:11 <foojin> hvr: Sure, I'll see how it goes when (if ?) I manage to reinstall all the needed libs with cabal.
07:10:16 <merijn> ventonegro: I don't change GHC often enough to care and stack wants me to do things completely different from how I want to do them
07:11:20 <merijn> I get annoyed by people who love stack somehow thinking they have to go on and "fix" me to also use it. I'm not hassling stack users for their choice in tooling...
07:11:37 <MarcelineVQ> that's 'cause people keep using stack for non-stacky things, doh ho ho
07:11:59 <ventonegro> merijn: Those people are the worst, tbh
07:16:00 <Rembane> merijn: They have seen the light! 
07:16:27 <MarcelineVQ> bow down before the platinum idol
07:17:44 <Rembane> Soon some dude will walk down from a mountain bearing stone plates covered in the rules for simply typed lambda calculus.
07:18:08 <MarcelineVQ> he'll be SKIng down
07:18:42 <ertes-w> "i bring you the 15 commandments of chur…" *crash*…  "10 commandments of church…"
07:19:10 <MarcelineVQ> for posterity the 11th was, "don't sweat the small stuff"
07:26:26 <Lokathor> mbrock, with the data links external to the room, every time the exits of the room must be displayed (which is relatively often) you need to walk the entire set
07:26:33 <Lokathor> that seems no good
07:29:16 <mbrock> unless relatively often means a thousand times per second, my instinct is that it doesn't matter... so I'm also provoking you to free yourself of premature ideas of performance :)
07:29:39 <Lokathor> hmm
07:30:12 <Lokathor> but your system can't also ensure that, for example, the north exit of a room exists exactly once
07:31:23 <mbrock> yeah, that's a good point... so `Map (Room, Door) Room` is another option
07:32:19 <mbrock> feel free to ignore these suggestions, I just remember starting to appreciate these kinds of representations a while ago
07:32:51 <Lokathor> i was suddenly woken up and told to work 4 hours earlier than expected
07:33:00 <Lokathor> i may be a tad grump
07:33:01 <MarcelineVQ> finally tagless nethack
07:34:21 <Lokathor> mbrock, such a map isn't bad, but it does mean you need to store two blobs to keep track of the whole world
07:35:37 <ertes-w> data RoomF x = Room { roomData :: RoomData, roomDoors :: Map DoorName x }
07:35:41 <mbrock> yeah, the world could be e.g. `{ rooms :: Map (Id Room) Room, doors :: Map (Room, Door) Room }` 
07:35:43 <ertes-w> type Room = Fix RoomF
07:36:16 <ertes-w> or rather:  type World = Fix RoomF
07:36:30 <ertes-w> type WorldMap = IntMap (RoomF Int)
07:36:44 <Lokathor> ertes-w, i don't know what that Fix type is doing but i am suspicious
07:37:09 <ertes-w> Lokathor: data ListF a x = Nil | Cons a x
07:37:13 <ertes-w> type List = Fix ListF
07:37:34 <ertes-w> World represents a world from a certain room's perspective…  it's an intrinsic encoding
07:37:45 <mbrock> ertes-w: that's pretty neat, like a way to get both an infinite recursive world and an int pointer world, without duplicating the types...
07:37:56 <Lokathor> how would you build such a thing one room at a time, and how would you serialize it to disk
07:38:34 <ertes-w> Lokathor: say you need IO to build a world one room at a time
07:38:41 <ertes-w> Lokathor: FreeT RoomF IO
07:39:03 <Lokathor> wait so now there's Free in it?
07:39:29 <Lokathor> this feels like the classic Haskell problem: "this is so fancy, but how would I ever use it?"
07:39:40 <Psybur> Lokathor, watch out next he's going to stick your world in a foldr
07:39:47 <Lokathor> ah!
07:39:54 <Psybur> A stateful foldr!
07:40:20 <ggVGc> isn't every fold stateful?
07:40:41 <Lokathor> if you can't serialize it to disk, and you can't build up a world either from disk or one room at a time from a blank world, it's probably not a helpful design for my case
07:40:51 <tabaqui> ergh
07:41:01 <tabaqui> mysql and mysql have the same module names
07:41:10 <ertes-w> Lokathor: what?  (Fix RoomF) is easily serialisable
07:41:10 <Lokathor> ggVGc, folds are usually not considered while they're running, usually before or after
07:41:12 <tabaqui> with same function names
07:41:13 <ggVGc> Lokathor: you'll use everything when you're working on your thesis for improvement of the Haskell type system!
07:41:17 <tabaqui> and different signatures
07:41:18 <tabaqui> bleh
07:41:27 <ggVGc> ah, yeah, fair
07:41:39 <mbrock> my preference comes from e.g. decisions like "should an item point to which room it is in, or should a room contain a list of the items it contains, or both?" to which I answer "just store a separate `Map (Id Item) (Id Room)` for this containment relation"
07:42:09 <mbrock> anyway, I'm vaguely interested in game world representations in Haskell and in general, but I haven't done much of it
07:42:18 <mbrock> would be curious to see some literature about related things
07:42:44 <mbrock> also generally representing "data bases" in Haskell is strangely underdiscussed
07:42:46 <Lokathor> mbrock, i was gonna store items in whatever container they're in, which is the floor of a room, or a continer in a room, or an inventory, or a container in an inventory
07:43:09 <ertes-w> mbrock: my proposal is inspired from the idea that you can represent recursive types as fixed points of functors
07:43:32 <Lokathor> ertes-w, i'm afraid you're gonna have to write basically all of it for me if you want me to use some sort of Fix thing
07:43:41 <Lokathor> i don't know how you'd write any operations at all :S
07:43:55 <ertes-w> mbrock: that gives you the aforementioned advantage that you only need a single "template" type both for a full world representation and an indexed world map
07:44:38 <ertes-w> Lokathor: imagine you would have written Room with direct recursion…  the only difference is that you need Fix wrapping/unwrapping
07:44:58 <Lokathor> but i wouldn't have written Room with direct recursion :P
07:45:08 <Lokathor> never in my life would i imagine writing it that way
07:45:14 <ertes-w> back to the List example, a value of a recursively written List type would look like this:  Cons x1 (Cons x2 (Cons x3 Nil)
07:45:55 <ertes-w> the equialent value of a fixed-point list type looks like this:  Fix (Cons x1 (Fix (Cons x2 (Fix (Cons x3 (Fix Nil))))))
07:46:16 <ertes-w> it looks more messy, but usually you only see one level of that mess
07:46:40 <Lokathor> okay but I just want some data blobs per room, right now mainly Name and Description, and then it seems that other properties can be external
07:46:57 <ertes-w> Lokathor: how do you represent the world?
07:47:09 <ertes-w> a map from indices to rooms?
07:47:30 <Lokathor> http://lpaste.net/359741 is the current code
07:48:31 <Lokathor> so, yes, "a map from indices to rooms" is exactly it
07:48:45 <ertes-w> Lokathor: now you have Ints throughout your world types in order to refer to other rooms, e.g. for exits
07:49:06 <Lokathor> that can be newtyped as necessary
07:49:50 <ertes-w> Lokathor: now all you do is change 'Int' to 'x' and take 'x' as a type argument…  then you take (World Int), (Room Int) and (Exits Int) instead of World, Room and Exit resp.
07:50:12 <ertes-w> Lokathor: this alone has one advantage: parametricity: you gain type safety without needing newtype wrappers
07:50:23 <Lokathor> what's the Int param?
07:50:49 <ertes-w> it's meaningless at this point…  you just take the Int as a type parameter, nothing else
07:51:20 <Lokathor> this sounds slower than the IntMap and also it sounds harder to work with
07:51:39 <ertes-w> no, you still use IntMap…  apart from the types it's literally the same code
07:52:37 <Lokathor> if you want to write an example of that and PM it to me I can have a look when i get done with work
07:52:41 <Lokathor> but i gotta go to work
07:52:50 <ertes-w> but now you can be more flexible in your operations…  now that Room takes a type argument, it's Foldable, Functor and Traversable
07:53:07 <ertes-w> adjacent :: World Int -> Room x -> Room (Room x)
07:53:32 <ertes-w> a value of type Room (Room x) is a room with all adjacent rooms
07:53:35 <Lokathor> that entire signature looks bonkers
07:53:45 <ertes-w> err, it's wrong
07:53:50 <ertes-w> adjacent :: World Int -> Room Int -> Room (Room Int)
07:53:52 <ertes-w> like that
07:53:52 <MarcelineVQ> ertes-w: oh that's quite interesting
07:54:09 <Lokathor> so you're saying that a room isn't a room at all
07:54:14 <Lokathor> it's just some arbitrary container
07:54:21 <ertes-w> it's just an arbitrary container anyway
07:54:22 <Lokathor> like it has no fields
07:54:29 <ertes-w> you just hardcoded the Int
07:55:00 <ertes-w> it does have fields…  you still have the room name and description in there
07:55:20 <Lokathor> then what's the int paramater
07:55:52 <ertes-w> read this chat again when you're not hurrying to get to work =)
07:55:57 <ertes-w> i've explained all of that
07:56:02 <MarcelineVQ> An excuse to upgrade your kind options
07:56:41 <Lokathor> ertes-w, i have sat and stared at every word you've written this entire time, but few of them make sense
07:57:33 <ertes-w> Lokathor: do you see how your current version of Room is *in principle* recursive, but you're using a kind of "controller" to tie the knot?
07:57:46 <ertes-w> (a separate piece of code that does IntMap lookups/inserts)
07:57:51 <Lokathor> i absoltely do not see that
07:58:22 <Lokathor> i'm not trying to be difficult, it doesn't look recursive to me in any way
07:58:36 <ertes-w> the spots where you write an Int are the "recursion" spots…  the Int really represents another Room, but it does so by pointing into an IntMap
07:59:14 <Lokathor> yes, you point back into the map, okay
07:59:15 <auto_complete_> :d
07:59:41 <ertes-w> Lokathor: now in principle the IntMap together with any Room represents the whole world
08:00:22 <ertes-w> Lokathor: and that world *could* be encoded by just making Room recursive…  the Int pointers would disappear, and Room would take their place…  makes sense so far?
08:00:52 <ertes-w> keep in mind: i'm not saying you should do that…  just that it *could* be done, and it would represent the same thing, just encoded differently
08:01:47 <Lokathor> ertes-w, the intmap alone is the whole world
08:02:22 <ertes-w> Lokathor: yes, and if you pick any aribtrary room you have an "entry point" into that world…  much like the head of a list is the entry point into a list
08:02:30 <ertes-w> or the root of a tree is the entry point into a tree
08:02:45 <Lokathor> this is very strange to me, but i might ask about this again
08:03:26 <ertes-w> consider this:  the type [a] could be represented by (Int, IntMap (a, Maybe Int))
08:03:45 <ertes-w> you have a "head pointer" and a map from indices to individual elements and their "remainder"
08:03:46 <Lokathor> i gotta go, but that's witchcraft
08:04:06 <ertes-w> have fun =)
08:18:25 <merijn> Is there a hacky "make stuff printable without a show constraint" solution?
08:18:49 <merijn> I need to do some debug printing and propagating show constraints is really impossible...
08:21:52 <c_wraith> find whatever package it is that lets you introspect STG structures in memory.  That's as much as you can do without knowing the type in order to select a show instance
08:22:32 <merijn> c_wraith: I know the types, I just can't effectively propagate the Show constraint
08:23:10 <c_wraith> if you know the type, you can do something dumb like using reflection to set the Show instance?
08:23:52 <merijn> c_wraith: The problem is that I have a bunch of complicated GADT/Type Family machinery and adding Show constraints throughout is an utterly insane task
08:24:07 <c_wraith> Or even simpler, you could just use unsafeCoerce to their actual type
08:24:18 <merijn> No
08:27:33 <c_wraith> This... isn't making much sense.  If you know the actual types, use unsafeCoerce so the compiler puts in the right Show instances.  If you don't, you can't do much more than introspecting the STG
08:28:12 <merijn> c_wraith: I have a set of types, I know they're all printable, but at the place in the code where I want to print them I don't have access to that
08:28:34 <c_wraith> So you don't know the types
08:28:41 <merijn> For all I care it just dumps a "<value of type X>" when show gets called as long as I can visualise it
08:29:44 <ertes-w> merijn: what about temporarily using StandaloneDeriving for the types you need to print?
08:30:06 <merijn> ertes-w: I'm not sure how that's supposed to help?
08:31:35 <ertes-w> merijn: a TH helper could "standalone-derive Show instances as much as necessary to print this value here"
08:43:43 <merijn> I forgot, where is NonEmpty from?
08:44:24 <cocreature> merijn: Data.List.NonEmpty
09:17:13 <bivoje> Hi. What is the best way to implement large array that only small linear segments are used in haskell?
09:17:32 <merijn> bivoje: IntMap would be the simple first attempt for me
09:17:45 <bivoje> I'm planning to write something like memory simulator.
09:17:58 <bivoje> Oh.. I'll check that
09:18:30 <merijn> That doesn't really help with the linear aspect, I suppose, though
09:19:02 <bivoje> Yeah.. It seems so..
09:20:13 <bivoje> I thought haskell's laziness could somehow give solution
09:20:26 <bivoje> but I couldn't find a way..
09:21:28 <nshepperd_> merijn: either add show constraints throughout or add typeable constraints throughout :(
09:22:50 <ertes-w> bivoje: if you want to get fancy you can use a finger tree of vectors…  that way only the parts that are actually used have an in-memory representation
09:23:29 <nshepperd_> Maybe ghc should have a profiling mode that adds show/typeable vtable to every boxed object just so that you can print debug things
09:23:30 <ertes-w> bivoje: laziness doesn't help you directly here, unless you represent the memory as some kind of infinite tree…  but good luck predicting the performance of that
09:28:56 <ertes-w> bivoje: the finger-tree approach basically works like a chunked array with run-length encoding, and you have some flexibility to do domain-specific optimisation…  for example you could defragment the chunks regularly at quieter times
09:37:08 <bivoje> ertes-w: hmm.. that sounds nice. I might be doing in your way.
09:38:08 <ertes-w> bivoje: finger-trees are kinda hard to implement by yourself, so just use the 'fingertree' library
09:38:59 <bivoje> ertes-w: you mean Data.FingerTree?
09:39:27 <bivoje> ertes-w: I'll look into it
09:41:01 <bivoje> by the way.. it's not taking advantage of functionality or laziness of haskell language, am I right?
09:42:05 <ertes-w> bivoje: it does take advantage of sharing, much like most functional ("persistent") data structures
09:43:19 <ertes-w> it's in the same rank as things like Map, Seq and Set
09:43:43 <nshepperd> IntMap of Vector
09:44:38 <nshepperd> map from the first address of linear segment to the vector for that segment
09:45:43 <ertes-w> that works, too, as long as you don't intend to split or concatenate
09:46:53 <Psybur> Is there any way to get a line number in stack traces generated by +RTS -cx ?
09:47:35 <nshepperd> you can split and concatenate adjacent vectors just by looking them up
09:49:15 <nshepperd> use lookupLE to find a vector by contained address
09:49:38 <nshepperd> uh, these are probably mutable vectors
09:50:15 <nshepperd> if you want it to be a 'pure' memory simulator, I would be surprised if plain ol IntMap is not best
09:51:15 <nshepperd> regardless of the 'small linear segment' part
09:54:16 <bivoje> ertes-w: what do you mean by "persistent"?
09:54:59 <bivoje> nshepperd: wow lookupLE would be really helpful when implementing memory
09:55:03 <ertes-w> bivoje: data structures with sharing, basically…  "functional"
09:57:35 <bivoje> ertes-w: 
09:59:08 <bivoje> ertes-w: oh. I got it.
09:59:33 <bivoje> thank you for your answers guys.
10:01:10 <simendsjo> I needed a function for work today doing [a] -> [[a]] converting [1, 1, 2, 1, 1, 1] into [[1, 1], [2], [1, 1, 1]], that is loop until the value differst, then returning the elements, repeat until done. It seems like this is a common algorithm that probably already has a name, but I'm unable to find it. Hoogling for [a] -> [[a]] doesn't show me anything which seems to work. Does anybody know what name this goes by?
10:03:01 <nshepperd> > group [1, 1, 2, 1, 1, 1]
10:03:02 <lambdabot>  [[1,1],[2],[1,1,1]]
10:03:22 <simendsjo> Ahm.. I thought that would sort it first :/
10:05:37 <mnoonan> :t group
10:05:38 <lambdabot> Eq a => [a] -> [[a]]
10:05:45 <mnoonan> ^ no Ord constraint :)
10:06:40 <simendsjo> I actually needed a kind of groupBy as I need to check only part of the data for equality, but return the entire element
10:08:00 <nshepperd> :t groupBy
10:08:01 <lambdabot> (a -> a -> Bool) -> [a] -> [[a]]
10:08:55 <simendsjo> Looks like groupBy is already defined in Data.List. I should note that I needed to implement it in C# though :) I'll examine the grouping functions a bit more in case I can get the same semantics as Haskell.
10:28:36 * nh2[m] sent a long message: nh2[m]_2017-11-02_17:28:13.txt <https://matrix.org/_matrix/media/v1/download/matrix.org/uHzJySlhBaVIUDgODEhEzWRV>
10:28:43 <nh2[m]> wrong channel.
10:48:29 <dsal> What's the easiest way to see major changes across GHC versions?
10:49:21 <shapr> dsal: https://ghc.haskell.org/trac/ghc/blog/ghc-8.2.11-released ?
10:50:34 <dsal> That's the release notes for that version.  Is there a higher level thing?  e.g., from 8.0  -> 8.1 -> 8.2 kind of thing?
10:50:47 <dsal> I'm using 8.0.2.   What wonders await me in the future?
10:51:34 <geekosaur> probabaly not (but note that 8.1 is not a released version. the odd numbered ones are dev versions)
10:51:40 <shapr> dsal: https://downloads.haskell.org/~ghc/master/users-guide/8.2.1-notes.html ?
10:52:14 <dsal> ooh. Thanks.
10:52:23 <dsal> geekosaur: Makes sense.  I hadn't seen anything about 8.1
10:56:25 <dsal> Weird.  'stack test' on my mac is .11s vs. ~1.5s on my presumably more powerful Linux machine.
11:13:46 <sm> interesting
11:14:50 <raynold> ahh it's a wonderful day
11:16:17 <sm> good day raynold! 
11:21:01 * EvanR agrees
12:03:08 <michalrus> Hmmm, when I’m trying to `cancel` an `Async` that I started in a `finalize`, it doesn’t work (blocks).
12:03:35 <michalrus> As if the `ThreadKilled` async exception couldn’t get to that Async. Hmmm.
12:04:41 <michalrus> `cancel`s docs say: “For example, it could block if: It's executing some cleanup handler after having received the exception, and the handler is blocking.”
12:04:45 <michalrus> Is this the situation?
12:05:34 <michalrus> That Async is just `threadDelay`ing right now, nothing fancy.
12:09:26 <michalrus> And this `finalize` is from safe-exceptions (ClassyPrelude, really).
12:09:45 <michalrus> s/finalize/finally ^.^’
12:13:59 <michalrus> Using `asyncWithUnmask` and unmasking the `threadDelay` solves this.
12:14:01 <michalrus> Hmmmm.
12:14:07 <michalrus> I kind-of get it.
12:14:25 <michalrus> =)
12:31:53 <Skyb0rg> I'm having difficulty with the Aeson parsing library
12:33:09 <geekosaur> I think you're going to have to ask a concrete question, including example code and if relevant full error message(s)
12:33:49 <Skyb0rg> I have a JSON value which has object styled like this:
12:34:20 <Skyb0rg> {"Mo"{"start":1,"end":3},"Tu"{"start":1,"end":3}}
12:35:01 <Skyb0rg> Can i parse this into a datatype with day, start, and end values
12:35:03 <geekosaur> that looks erroneous
12:35:50 <geekosaur> {"Mo":{"start":1,"end":3},"Tu":{"start":1,"end":3}} would be valid JSON
12:36:08 <Skyb0rg> thats what i meant
12:36:16 <Skyb0rg> mb
12:36:39 <Skyb0rg> I don't know how to capture the names of the object's values
12:37:52 <Excel> Hey guys I know this isa  haskell caht
12:37:58 <Excel> but can I ask a C program related question?
12:38:01 <geekosaur> that should be parseable info a Map WDay TRange where data WDay = Mo | Tu | We | Th | Fr | Sa | Su and data TRange = TRange { start :: Int; end :: Int }
12:38:08 <t7> Excel, why not ask in ##c
12:38:15 <geekosaur> Excel, you'd probably get better answers in ##c
12:38:20 <Excel> I've been trying :/ no answers
12:39:06 <Taneb> Excel, then you've probably got a not very good question
12:39:19 <t7> or possibly too good
12:39:23 <asthasr> Hey guys. Do any of you remember that time that SPJ posted an admonition on one of the Haskell mailing lists for everyone to be friendlier? If so, does anyone have a link to it?
12:39:28 <[exa]> Excel: do try, please. :D
12:39:36 <geekosaur> Skyb0rg, note that you'd need to derive FromJSON for those types
12:39:42 <[exa]> Excel: (to ask here)
12:39:44 <asthasr> I remember it, but can't find it for the life of me, and want to offer it as an example of effective, civil communication :)
12:39:49 <Excel> im new to programming m question might be bad :p
12:40:08 <Skyb0rg> I did find an answer online for a Map-based answer
12:40:13 <geekosaur> (along with the usual ones e.g. Read, Show, probably Eq and Ord)
12:40:19 <sm> damn it asthasr, can't you search.. oh wait. Sorry :)
12:40:21 <Skyb0rg> but it didnt work ill post what I did
12:40:28 <[exa]> Excel: don't ask to ask just ask
12:40:34 <asthasr> sm: Sorry! I have tried.
12:40:50 <Excel> so basically I'm creating a function that reads an array of 20 ints max (which the user will input) and the function will read all the numbers and print the # of prime ints in the array
12:40:56 <Excel> lemme upload my code
12:41:17 <Skyb0rg> parseJSON v = ( Days . map  (\(nameOfDay, INTDAY st ed) -> Day nameOfDay st ed) . M.toList) <$> parseJSON v
12:41:39 <Skyb0rg> data Days = Days [Day]
12:41:49 <[exa]> Excel: ok that belongs in ##c but we'll try
12:41:53 <Excel> So the problem is that my counter only increases if the function reads prime numbers and not non primes  https://pastebin.com/g53h606p
12:42:15 <Excel> thanks guys
12:42:22 <asthasr> Hah! Actually, I just found it. Of course, if you go and ask about it you subsequently find it
12:42:38 <geekosaur> Skyb0rg, please use a paste site
12:42:40 <geekosaur> @paste
12:42:40 <lambdabot> Haskell pastebin: http://lpaste.net/
12:42:42 <asthasr> Link, if anyone else cares: https://mail.haskell.org/pipermail/haskell/2016-September/024995.html
12:43:09 <sm> asthasr: hm, thanks. I was having trouble finding it too
12:44:14 <Skyb0rg> http://lpaste.net/359746
12:45:35 <[exa]> Excel: what's wrong with it?
12:45:47 <asthasr> sm: no worries!
12:45:48 <Excel> the counter only increments when the array sees a prime
12:45:58 <Excel> but I want it to increment when it sees any integer
12:46:01 <[exa]> Excel: use two counters?
12:46:53 <sm> asthasr: I think if we are serious about upholding that, we'll need do more active and organised community management/education
12:47:04 <Excel> one counter for the primes and one for the total inputs?
12:47:16 <[exa]> Excel: one in 'for' cycle, second for counting the results. And give me a minute to code it in haskell :D
12:47:16 <sm> otherwise it's a losing battle
12:47:38 <asthasr> sm: True. Although I believe the Haskell community does a lot better than most other technical communities.
12:47:51 <sm> I think that has changed over time
12:48:10 <sm> and is partly a function of where it is on its growth curve
12:52:00 <geekosaur> Skyb0rg, that doesn't parse the same thing
12:58:16 <camm_> Hey guys. I've been trying to install process-1.4.3.0 with stack (stack install process-1.4.3.0) and I get the following error message: 
12:58:17 <camm_>     Linking /tmp/stack855/process-1.4.3.0/.stack-work/dist/x86_64-linux-tinfo6-nopie/Cabal-1.24.2.0/setup/setup ...
12:58:18 <camm_>     Configuring process-1.4.3.0...
12:58:18 <camm_>     configure: WARNING: unrecognized options: --with-compiler
12:58:18 <camm_>     checking for gcc... /usr/bin/gcc
12:58:18 <camm_>     checking whether the C compiler works... yes
12:58:20 <camm_>     checking for C compiler default output file name... a.out
12:58:22 <camm_>     checking for suffix of executables...
13:02:09 <[exa]> @pl filter id
13:02:09 <lambdabot> filter id
13:02:18 <[exa]> :(
13:02:46 --- mode: ChanServ set +o geekosaur
13:03:09 --- mode: geekosaur set -o geekosaur
13:03:47 <[exa]> Excel: just for comparison, in haskell it would be something like: length.filter not <$> replicateM 20 ((\x -> any ((0==).(mod x)) [2..x-1]) <$> readLn)
13:04:07 <johnw> f <$> g <$> x == f . g <$> x
13:04:36 <[exa]> I expected you.
13:04:47 <johnw> then I'm not the spanish inquisition?
13:05:42 <[exa]> is there any chance to squash the (\x->...), possibly without parens? (except for >>= \x -> return...)
13:06:44 <Tuplanolla> Translate the list to `enumFromTo` and apply `<*>` for functions, [exa].
13:07:29 <[exa]> ...how easy it is to forget about ->
13:09:45 <geekosaur> guess they're not coming back
13:14:29 <cmotoche> Hello. I'm getting the following error while I run `stack install process-1.4.3.0`: http://lpaste.net/359751 I'm not sure what could happen. I'm using stack 1.5.1 and lts-9.0.
13:14:49 <cmotoche> May you know what can I do to fix that problem?
13:17:36 <[exa]> :t (-1)
13:17:37 <lambdabot> Num a => a
13:17:39 <[exa]> :t (- 1)
13:17:40 <lambdabot> Num a => a
13:17:49 <[exa]> :t (+ -1)
13:17:50 <lambdabot> error:
13:17:50 <lambdabot>     The operator ‘+’ [infixl 6] of a section
13:17:50 <lambdabot>         must have lower precedence than that of the operand,
13:17:57 <[exa]> :t (-1+)
13:17:58 <lambdabot> Num a => a -> a
13:18:05 <[exa]> oh unary operators
13:18:16 <geekosaur> cmotoche, you're on Arch, right?
13:18:31 <cmotoche> geekosaur: Yeah
13:18:40 <geekosaur> yeh, this is an Arch specific issue
13:19:01 <fakenullie> (-x) is a syntactic sugar because it's normally infix
13:19:02 <geekosaur> you can try removing libtinfo6 (and installing the tinfo5 compat lib in its place if necessary)
13:19:43 <fakenullie> :i -
13:19:51 <fakenullie> :t (-)
13:19:52 <lambdabot> Num a => a -> a -> a
13:19:53 <cmotoche> geekosaur: I'll try that.
13:20:27 <geekosaur> the main problem here is the ghc binary distributions are built on debian and none of them quite matches how arch does things
13:20:48 <geekosaur> but arch has messed up its haskell ecosystem so badly that any more your best bet is run something else in a VM
13:20:52 <geekosaur> :(
13:21:45 <fakenullie> will it work with nix on arch?
13:22:47 <geekosaur> probably? they sdon;t have the shared library hosage and should have ghc binary packages specific to arch instead of trying to bodge ones from debian in
13:24:25 * sm wonders don't the arch haskell packagers use this stuff ? shouldn't they be providing all this support ?
13:25:26 <geekosaur> they provide what works for arch pkgbuilds
13:25:32 <geekosaur> they don't care about anything else
13:30:04 <royal_screwup21> how useful would you say haskell is in learning recursion, and just that?
13:30:04 <sm> I don't know what a pkgbuild is, but seems like the dogfood principle is missing
13:30:37 <sm> royal_screwup21: it's great. You can learn recursion in ghci in about a minute.
13:33:17 <Zemyla> I think I've figured out a way to have Array i be Traversable without an Ix constraint on i.
13:39:50 <monochrom> No, you can mess up your mind by recursion examples in ghci in about a minute. :)
13:42:16 <tdammers> in order to learn recursion using haskell, you first need to learn haskell, which involves learning recursion
13:42:33 <monochrom> haha
13:45:32 <jcarpenter2> in order to learn recursion, you must first learn recursion
13:46:45 <eschnett> i want to write something like “newtype V a = V ((if Unbox a then Unboxed.Vector else Boxed.Vector) a)”
13:46:49 <monochrom> Go to Google and search for recursion. :)
13:47:14 <eschnett> that is, i want to check (at compile time) whether the element type satisfies “Unbox a”, and depending on this, choose what vector implementation to use
13:47:44 <eschnett> do you have any pointers? would Typeable help? is there documentation for Typeable that’s more detailed than Hackage?
13:48:17 <cocreature> eschnett: you can’t really do that without gross hacks
13:48:27 <cocreature> see https://github.com/mikeizbicki/ifcxt for the hack :)
13:48:54 <eschnett> i don’t mind hacks. thanks, will have a look.
13:49:01 <jcarpenter2> in order to learn structural recursion, you must first learn recursion
13:50:00 <eschnett> ooh, OVERLAPPABLE and OVERLAPS
14:15:49 <dumptruckman> How can I export constructors of a algebraic type in a module?
14:16:01 <dumptruckman> like data (Stack a) = NilStack | Top a (Stack a)
14:16:08 <dumptruckman> how do i export NilStack
14:16:14 <dmwit> module Foo where (Stack(NilStack, Top)) where
14:16:18 <dumptruckman> ah
14:16:19 <dumptruckman> thanks
14:16:21 <dmwit> Uh. Delete that first where.
14:16:22 <monochrom> module M(Stack(..))  or  dmwit's.
14:16:29 <dmwit> There's also Stack(..) if you want all the constructors.
14:17:03 <dumptruckman> oh cool
14:18:44 <orzo> Does anybody know something like asTypeOf :: a -> a -> a but using a type (proxy a) as reference instead?
14:19:55 <geekosaur> not already provided. shouldn't be hard to write yourself
14:20:23 <monochrom> There is asProxyTypeOf in Data.Proxy
14:20:31 <geekosaur> oh, huh
14:20:50 <monochrom> It pays to have read docs from cover to cover. :)
14:21:20 <dmwit> "Does this function which is certainly possible to write exist" is a dangerous question to answer. You can be sure of a "yes", but "no" is very hard to know.
14:21:57 <monochrom> That is also true. I just happened to know a "yes" answer and its witness.
14:22:06 <monochrom> But in general: Don't answer to answer, just don't answer.
14:22:14 <dmwit> hahaha
14:22:57 <dmwit> I have often replied along the lines of "I don't know of one". If you think the person who says that knows a big chunk of the library, that can be useful evidence about how much time you should spend looking before you just sit and write it yourself.
14:23:19 <mtjmullen> Have any of the libraries that use Text/ByteString started to use Backpack?  Or at least made motions towards it?
14:24:49 <c_wraith> Text and Bytestring really aren't interchangeable. only one is correct for any given use.
14:25:42 <monochrom> Text/String is more like it. But no, no one has really acted.
14:26:07 <orzo> actually, monochrom's solution doesn't work because my proxy is not Proxy, it's some other thingy i had convenient already
14:26:13 <monochrom> OTOH for regex libraries and parser libraries Text/ByteString/[a]/Sequence a/... makes sense.
14:26:52 <monochrom> Have you actually read the doc or the type?
14:26:57 <monochrom> @type asProxyTypeOf
14:26:59 <lambdabot> error: Variable not in scope: asProxyTypeOf
14:27:05 <monochrom> @type Data.Proxy.asProxyTypeOf
14:27:07 <lambdabot> a -> proxy a -> a
14:27:20 <orzo> not in the version of Data.Proxy I'm linking with
14:27:20 <monochrom> So even a -> Maybe a -> a works.
14:27:27 <monochrom> Oh too bad.
14:27:29 <orzo> Data.Proxy asProxyTypeOf :: a -> Proxy a -> a 
14:28:09 <dmwit> Yeah, a few capital-P Proxy's have snuck through early designs of a couple of these libraries.
14:28:18 <orzo> but if it's going to be compatible in the future, then i might as well name my function the same
14:28:24 <dmwit> I've been bitten by that, too.
14:31:25 <mtjmullen> monochrom: Things like parsers that only care about it being a 'monomorphic list' don't particularly care, that's what I had in mind
14:44:19 <llinguini> So I have a question about lambda calculus, and the mathematical function composition 
14:44:44 <johnw> what do people use in Haskell for generally dealing with XxY matrices?  just vectors of vectors?
14:44:58 <llinguini> I read somewhere about this https://en.wikipedia.org/wiki/Church%E2%80%93Rosser_theorem
14:45:34 <llinguini> And they were saying, that the order in which you apply functions doesn't matter, but you get the same result out at the end
14:45:51 <llinguini> Which is what makes haskell good at parallel/concurrent programming 
14:46:06 <llinguini> But, if you have a simple function such as f x = x + 1
14:46:14 <llinguini> and g x = x * 2 
14:46:43 <llinguini> The order you apply f and g does matter. This is making me a little confused about how that works 
14:47:54 <monochrom> You have conflated "order of evaluation" with "what does the expression look like".
14:48:40 <mtjmullen> johnw: just 2d matrices? Try http://hackage.haskell.org/package/hmatrix
14:48:50 <buttbutter> 1. I'm kind of a Haskell noob. 2. I'm trying to write a C lexer in Haskell, using Text.Megaparsec as a parser. C allows line continuations on any line, i.e. if a line ends with "\" right before a newline character, it simply deletes the "\" along with the newline character. The C spec literally says to pre-process by deleting all occurences of the aforementioned "\\n". So these "\\n"'s are giving us 
14:48:51 <johnw> actually, it looks like just 'matrix' is enough
14:48:56 <buttbutter> trouble, since we can't just outright delete them as that messes up our position in the source file. We could ammend each of our parsers to explicitly deal with the "\\n"'s, but it seems ugly/messy and seems like there'd be a better way.
14:49:00 <buttbutter> Suggestions? :) 
14:49:02 <johnw> i mainly just want a matrix of opaque data I can reference by (x, y) coords
14:49:26 <monochrom> hmatrix uses a 1D vector for its matrix and does its own row-column-to-index calculation.
14:49:40 <monochrom> But I use hmatrix. You will not be alone. :)
14:50:00 <johnw> except I don't need to do *any* actual calculations
14:50:03 <johnw> it's just storage
14:50:10 <llinguini> monochrom: Can you explain that a little more? I was thinking that order of evaluation makes a big difference in concurrent settings 
14:50:40 <johnw> hmm.. it looks like hmatrix's Matrix type is general, so I could use that too
14:50:44 <monochrom> And the exact wording on wikipedia is "ordering in which the reductions are chosen" which I have no idea how one could read that as "f . g vs g . f".
14:51:58 <llinguini> Sorry if I'm being stupid, but isn't applying reductions the same as applying functions?
14:52:07 <monochrom> No.
14:53:56 <llinguini> then what is it?
14:54:25 <monochrom> What do you already know?
14:55:59 <llinguini> I haven't formally learnt this stuff. I know a little big about how to apply alpha and beta reductions, but I don't know why we apply them. I also don't know what the purpose of the lambda calculus abstraction is. 
14:56:13 <llinguini> Or rather, I don't understand how the abstraction relates to practice
14:58:52 <monochrom> I have never thought of lambda calculus as an abstraction. Perhaps that's where you started wrong in the first place.
14:59:40 <buttbutter> On a tangential note, monochrom, do you have a recommendation for learning about the lambda calculus/semantics? We started lambda calculus today in one of my courses and I really need a second, lucid reference :) 
15:01:19 <monochrom> If I have defined "f x = [x, x, x]" then I can deduce f 'a' = ['a', 'a', 'a']. That is beta reduction. If you ask "but where is it ever used?" then you're also asking "where do we ever plug parameters into functions?"
15:03:57 <monochrom> Yeah, how did I learn lambda calculus in the first place?
15:04:15 <monochrom> I didn't learn it from a course either.
15:05:32 <buttbutter> I wish I had the privlege of knowing lambda calculus without knowing where I know it from. :) 
15:05:41 <buttbutter> privilege*
15:06:24 <monochrom> I think I picked up bits by bits from papers that mentioned lambda calculus for whatever purposes and after the 5th time I got it.
15:07:08 <monochrom> (Because they don't just mention. If they have to bring it up, they tend to also have to give a one-subsection crash course.)
15:07:16 <johnw> heh, that's so true
15:11:35 <monochrom> Oh OK I think I learned it from my thesis supervisor's course in which he defined logic and expressions and programs from the ground up, and his expression language contained lambda terms (and also all the common math expressions).
15:12:08 <monochrom> So he was like "a function expression goes like lambda v. body"
15:12:40 <monochrom> And you can rename local vars: lambda v. v+x = lambda x. x+x
15:12:58 <monochrom> And you can plug in: (lambda v. v+v) 5 = 5+5
15:13:31 <monochrom> 3 years later I picked up from other sources that those are alpha and beta.
15:13:55 <monochrom> 3 more years later I found out there is also an eta rule (\v. f v) = f.
15:14:31 <buttbutter> Aha, so, slowly  but surely :D
15:15:21 <monochrom> And 2 more years later I found out that these 3 rules were meant to be single-directional, you're not supposed to use = and go back, but my thesis supervisor is interested in doing algebra rather than studying rewrite systems, so he made them =
15:47:13 <Profpatsch> wyager here?
15:47:46 <Profpatsch> If you see him, tell him that: “You, sir, are just a piece of shit”
15:47:52 <Profpatsch> Context: https://lobste.rs/s/f5vsl9/first_annual_haskell_users_survey#c_faec5j
15:57:19 <hololeap> Profpatsch: don't you think that's a little harsh?
15:57:59 <mniip> unconstructive
16:00:15 <codeshot> Hello, is there a nice facility for failing monads with arbitrary error types? I'm looking for something where I say "do {a <- ok $ fn; b <- ok $ fn' b; c <- bad $ fn'' b; d <- ok $ fn''' c}"
16:01:11 <codeshot> And the result is a value where I can see that the final result is out of spec and via the "bad" function my instances could log at what point in a process things started to go wrong
16:01:40 <codeshot> (eg, threshold not met, system state deviates, etc - all while continuing towards a best-effort result
16:03:03 <codeshot> I don't want to re-invent the wheel but MonadZero, `fail` and EitherT don't cut it
16:03:51 <hololeap> codeshot: maybe not the best answer, but that sounds like it would be in the general ballpark of the continuation monad
16:04:17 <hololeap> (which i honestly have a hard time wrapping my head around)
16:04:20 <exio4> codeshot: ExceptT? 
16:04:29 <codeshot> exio4, thanks
16:04:37 * codeshot goes a-googling
16:05:16 <hololeap> EitherT == ExceptT, right?
16:06:03 <exio4> hololeap: EitherT is deprecated, haven't really checked it
16:06:27 <hololeap> exio4: cuz codeshot said EitherT won't cut it
16:07:54 <codeshot> Unless you think I'm wrong about that
16:08:14 <codeshot> ExceptT isn't it because the monad stops at the first error
16:08:36 <codeshot> I'm kind of thinking about "QualityT" or "DeviationT"
16:09:30 <tinco> anyone find this wording confusing as well? "No instance for (V.Unbox [Char]) arising from a use of ‘V.toList’"
16:09:44 <codeshot> although, I think it has to combine two Monads rather than be a MonadTrans
16:10:25 <codeshot> because a regular monad has to be hoisted into being a transformer
16:10:31 <tinco> where does it inspect the instance for V.Unbox [Char] to arise?
16:11:17 <hololeap> codeshot: if all you're looking for is logging, then you could just use the Writer monad
16:11:34 <tinco> oh wait I think I get it, there's a difference in return types..
16:11:43 <hololeap> codeshot: because if it just continues on in spite of the error, what's the point of doing anything other than logging?
16:11:50 <mud> tinco: I would assume your toList implies that an unboxed Vector exists with elements of type [Char]
16:12:01 <codeshot> not just logging, I wanted the user of the monad to inject the policy of what to do with errors
16:12:27 <codeshot> I'm betting this doesn't quite exist but I'll think for a while about existing transformers to see if one actually solves this
16:12:33 <hololeap> codeshot: what about State then?
16:14:00 <hololeap> codeshot: if you haven't looked into it before, look at the Cont (continuation) monad. it may be (a piece of) what you're looking for
16:14:30 <codeshot> hololeap, probably could be used as a basis for implementation, although I don't think it's implementation's right because the outer monad gets to decide all the flow
16:14:56 <Axman6> :t traverse
16:14:57 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
16:15:16 <codeshot> thanks for the suggestions folks
16:15:33 <codeshot> It sounds like what I want has never been packaged up so that's good to know
16:15:45 <Axman6> :t traverse `asAppliedTo` (undefined :: a -> IO b)
16:15:47 <lambdabot> Traversable t => (a -> IO b) -> t a -> IO (t b)
16:18:41 <codeshot> perhaps MonadError does what I want
16:19:13 <codeshot> What's the name of this haskell language feature "class B a b | b -> a where" <~~~ the "| b -> a" bit
16:19:27 <Axman6> functional dependencies
16:22:08 <Axman6> does fmap join have another name?
16:22:24 <mud> :t fmap join
16:22:25 <lambdabot> (Functor f, Monad m) => f (m (m a)) -> f (m a)
16:22:56 <mud> I don't think so. Might be missing something though.
16:23:09 <Axman6> trying to simplify fmap join $ traverse f x
16:23:09 <codeshot> Axman6, thanks
16:23:31 <mud> :t \f -> fmap join . traverse f
16:23:33 <lambdabot> (Applicative f, Traversable m, Monad m) => (a1 -> f (m a2)) -> m a1 -> f (m a2)
16:24:00 <mud> :t traverse
16:24:01 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
16:24:09 <codeshot> :t join <$> traverse f x
16:24:10 <lambdabot> error:
16:24:10 <lambdabot>     • Couldn't match expected type ‘m ()’ with actual type ‘Expr’
16:24:10 <lambdabot>     • In the second argument of ‘traverse’, namely ‘x’
16:24:12 <codeshot> nope
16:26:14 <codeshot> :t traverse f >=> join
16:26:15 <lambdabot> (FromExpr (m (m c)), Show a, Traversable m, Monad m) => m a -> m c
16:26:38 <codeshot> uh, I still get confused about this stuff
16:27:46 <Axman6> :t \f -> traverse f >=> join
16:27:48 <lambdabot> (Traversable m, Monad m) => (a -> m (m c)) -> m a -> m c
16:28:00 <Axman6> f /= m in this example
16:28:49 <codeshot> but maybe you can avoid m (m a) in the first place by using >=> - works in some places
16:32:36 <tinco> can anyone explain to me how I could get a record to implement Unbox? I'm looking at this: https://hackage.haskell.org/package/vector-th-unbox-0.2.1.6/docs/Data-Vector-Unboxed-Deriving.html#v:derivingUnbox
16:32:41 <tinco> but I don't know template haskell
16:33:00 <tinco> and it assumes I'm deriving a container not a concrete type
16:35:03 <tinco> so the first argument is a typequotation
16:35:39 <tinco> my typename is IntervalItem, so should the line just be: A a. IntervalItem -> (Bool, a)
16:36:48 <tinco> that page is the most ridiculous documentation ever
16:38:44 <tinco> no that bool is only for deriving maybe..
16:43:42 <Axman6> tinco: do you have a sum type?
16:43:44 <folder> Hi, I was looking at the implementation of foldrM and saw that it uses foldl, not foldl'
16:43:46 <folder> http://hackage.haskell.org/package/base-4.10.0.0/docs/src/Data.Foldable.html#foldrM
16:43:51 <folder> Is that fine?
16:44:40 <dmwit> tinco: No, presumably the line should be `[t| IntervalItem -> (Some, Concrete, Field, Values) |]`.
16:44:40 <folder> I have relatively particular perf requirements, and I'm not sure if it is "supposed" to use the lazy foldl for some reason.
16:45:12 <dmwit> tinco: What is `IntervalItem`?
16:45:27 <codeshot> Axman6, is the Traversable constraint actually required - or is it just there because your type has suitable behaviour in its traversable type - but could it also have suitable behaviour from another type class or function?
16:46:44 <dmwit> tinco: And of course, you don't *have* to use TH. You can write the instance yourself.
16:46:54 <Axman6> not required, but the original task was basically traverse
16:48:52 <cement> am I sane in thinking that the Simon Marlowe book "Parallelism and Concurrency in Haskell" doesn't really explain the difference between a TVar and a TMVar, nor does it really show the differing use cases?
16:49:30 <Axman6> the difference is a TMvar can be empty
16:49:55 <codeshot> if your traversable is *actually* just a monad then does this solve the problem (x >>= f) ?
16:50:06 <Axman6> I would guess that it assumes you understand the difference between an IORef and an MVar
16:50:20 <codeshot> Maybe I confused myself though because it would seem too simple so I probably screwed up and didn't notice the difference
16:50:26 <folder> Does anyone know why the http://hackage.haskell.org/package/base-4.10.0.0/docs/src/Data.Foldable.html#foldrM implementation uses the lazy foldl rather than the strict foldl' ?
16:51:03 <folder> I am going to do some IO actions with it that definitely always happens, and I'm unclear on how the lazy foldl interacts with that.
16:51:23 <Axman6> folder: when the value being produced is some arbitrary monad, having strict evaluation might not be a good thing (or do anything useful)
16:51:24 <folder> Particularly about whether it'll get optimized well
16:51:32 <codeshot> oh f /= m
16:51:34 <codeshot> forgot
16:51:59 <folder> Axman6, it is definitely IO in my case. What would the benefit of laziness be in that context?
16:52:52 <folder> Also, do you know examples of times where it would be desirable? Nondeterminism?
16:53:03 <dmwit> But this is not about the monad at all. The laziness is about a value of type `b -> m b`. Strictness probably won't do very much there.
16:53:20 <Axman6> well, there's no real benefit to it being strict if it's IO, as that doesn't force anything useful
16:53:47 <Cale> Yeah, you're not expected to gain much by forcing the evaluation of not-yet-applied functions
16:54:06 <dmwit> I suspect foldl vs foldl' will make only a negligible difference here, no matter what monad is involved.
16:55:12 <folder> Cool, that makes sense now. Thank you!
16:57:25 <tinco> Axman6: I'm trying to do it without TH now, my type is a record of a bunch of floats and an int
17:00:34 <Axman6> if you have n fields, then you just need a) the type from YourType -> (Float,...,Int), b) a frunction from your type to a tuple, and c) a function from the tuple to your type
17:00:55 <hololeap> folder: if you are doing something that is prone to failure, like a network call, and you need the whole thing to get transmitted in its entirety before continuing on, that's a good time to use strict evaluation (e.g. deepseq)
17:01:13 <hololeap> but maybe not so much for a fold
17:02:33 <tinco> Axman6: ah now I'm doing it manually I think I get what derivingUnbox is supposed to do
17:03:38 <tinco> it would be nice if they could've just written that in the documentation
17:13:01 <tinco> I've never compiled TH before, should I do something to the stack build command? I get this: "parse error on input ‘]’"
17:14:29 <rotaerk> tinco, did you specify the TH extension?
17:14:34 <rotaerk> in your source file
17:18:37 <codeshot> Axman6, I got something with a similarly structured type but the applicative becomes traversable and the monad becomes just monad
17:18:45 <codeshot> I haven't checked if it's functionally the same
17:18:50 <codeshot> :t x >>= sequence . f
17:18:52 <lambdabot> error:
17:18:52 <lambdabot>     • Couldn't match expected type ‘m ()’ with actual type ‘Expr’
17:18:52 <lambdabot>     • In the first argument of ‘(>>=)’, namely ‘x’
17:19:06 <codeshot> :t x >>= (sequence . f)
17:19:08 <lambdabot> error:
17:19:08 <lambdabot>     • Couldn't match expected type ‘m ()’ with actual type ‘Expr’
17:19:08 <lambdabot>     • In the first argument of ‘(>>=)’, namely ‘x’
17:19:13 <codeshot> hm, works in 8.0.2
17:19:32 <monochrom> Are you sure it's the same x?
17:19:42 <codeshot> :t \f x -> x >>= sequence . f
17:19:43 <lambdabot> (Traversable t, Monad m) => (a1 -> t (m a2)) -> m a1 -> m (t a2)
17:19:45 <codeshot> lol
17:19:47 <monochrom> Better.
17:20:26 <codeshot> vs original
17:20:40 <codeshot> :t \f x -> fmap join $ traverse f x
17:20:41 <lambdabot> (Applicative f, Traversable m, Monad m) => (a1 -> f (m a2)) -> m a1 -> f (m a2)
17:20:51 <codeshot> cock1
17:20:54 <codeshot> cock!
17:21:51 <codeshot> I can't think of anything more succinct than the original
17:22:07 <codeshot> this was wrong
17:29:43 <tinco> thanks rotaerk that was it
18:16:23 <sssilver> has anyone here read "Real World Haskell"? Is it decent?
18:17:23 <jle`> it is one of the more respected/established haskell learning resources in the community
18:17:46 <jle`> however, there are parts of it which refer to outdated library API's
18:17:48 <mud> sssilver: It's pretty good, but it's a bit outdated and I never really considered it a great only-resource for learning haskell.
18:18:06 <jle`> that is, the libraries that it uses have updated their API's since it was published
18:18:13 <sssilver> I've already read Learn You A Haskell For Great Good
18:18:23 <cement> ah, the spoilery movie trailer
18:18:36 <sssilver> I don't think libraries really matter too much to me... I'm just trying to grasp the language and the paradigm really
18:18:39 <jle`> sssilver: this SO post details all of the 'outdated' parts https://stackoverflow.com/questions/23727768/which-parts-of-real-world-haskell-are-now-obsolete-or-considered-bad-practice
18:18:48 <jle`> sssilver: it's just that the code doesn't compile
18:18:53 <jle`> so you can't do any of the exercises
18:19:02 <mud> sssilver: RWH and LYAH were like the old, really bad formula to learn haskell. That's what I tried first and failed miserably to actually be able to write haskell.
18:19:18 <sssilver> ouch mud
18:19:38 <sssilver> where do I start then? (provided math bores me)
18:19:41 <jle`> yes they really aren't a great way to 'learn haskell'
18:19:50 <jle`> but RWH is a good standalone book if you already know haskell
18:20:07 <jle`> and LYAH is a good book if you don't want to learn anything
18:20:10 <mud> Especially LYAH I find just terrible as something to learn haskell from. http://haskellbook.com/ is how I wish I could have learned (it didn't exist when I learned)
18:22:09 <sssilver> http://haskelbook.com I like the website, I hope it's available on iBooks
18:22:23 <sssilver> I quite enjoyed LYAH, and bought quite a few copies for various friends
18:22:33 <jle`> yes it's definitely a fun read
18:23:00 <jle`> the reputation now is that it's a lot of fun with little substance in terms of learning how to actually read or write haskell
18:23:29 <jle`> there's also
18:23:32 <jle`> @where learnhaskell
18:23:32 <lambdabot> https://github.com/bitemyapp/learnhaskell
18:23:50 <cement> that one is by the same person as haskellbook.com
18:24:03 <mud> If LYAH had exercises I'd give it less grief. But without exercises, it's like it's not even trying hard enough to give it much benefit of the doubt.
18:24:54 <cement> I sometimes refer to it to refresh my list comprehensions and record syntax
18:25:22 <sssilver> I've read LYAH more in prose mode than in technical reference mode really :)
18:25:34 <sssilver> and I though it was tremendously enjoyable in that way
18:25:43 <sssilver> it was a similar experience to reading Code by Charles Petzold
18:26:13 <sssilver> it was excellent in affecting the way I think about programming in general, but yes I didn't feel like I got any closer to being a practical Haskell programmer
18:26:59 <sssilver> This http://haskelbook.com/ thing isn't available on iBooks :(( I guess they just wanna keep that 30% to themselves.... but that's becoming a convenience problem for everyone else
18:27:10 <sssilver> I wish they offered it on iBooks for 30% more expensive at least
18:27:19 <cement> yeah, unfortunately, practical haskell is very much wrapped up in libraries (in my experience as an applications writer), so libraries are very very important
18:27:37 <htse> can I type declare a function definition? like say type myFunc = (String -> Int) ?
18:27:54 <htse> I obviously tried that and it errored :P
18:28:14 <cement> that looks like a type annotation
18:28:14 <jle`> htse: 'type declare'?
18:28:22 <htse> I was just wondering if a callback function could be declared nicer that way
18:28:26 <jle`> myFunc :: String -> Int, you mean
18:28:28 <jle`> ?
18:28:56 <htse> well I have a function that has a callback function say myFunc :: (String -> Int) String
18:29:17 <cement> what's a callback function?
18:29:19 <htse> I wonder wether that (String->Int) can be changed to stay stringCallback
18:29:31 <jle`> myFunc :: (String -> Int) String
18:29:34 <jle`> doesn't quite make sense?
18:29:44 <jle`> that's a 'kind error'
18:29:45 <htse> like in map
18:29:57 <htse> where you do map <callback function> list
18:30:01 <jle`> `(String -> Int) String` isn't a meaningful type signature
18:30:21 <jle`> do you mean (String -> Int) -> String ....?
18:30:48 <htse> yes
18:31:06 <jle`> you can declare a type synonym
18:31:18 <jle`> type Foo = Int, for example, is a type synonym 'Foo' that means 'Int'
18:31:21 <jle`> type String = [Char]
18:31:24 <jle`> etc.
18:31:31 <jle`> 'String' is a type synonym for [Char]
18:31:41 <htse> I know, how do I do that for a function declaration?
18:31:47 <jle`> a function declaration?
18:31:50 <htse> is that possible?
18:31:50 <jle`> you can only do it for types
18:31:58 <jle`> type IntFunc = Int -> Int      ... ?
18:32:02 <htse> ah ok, thx
18:32:03 <jle`> (Int -> Int) isn't a function declaration
18:32:08 <jle`> it's a type
18:32:09 <jle`> (a function type)
18:32:20 <jle`> also type synonyms have to begin in uppercase letters
18:33:03 <jle`> `type StringToInt = String -> Int` should be fine if that's what you want
18:33:34 <htse> so that's my error, the uppercase
18:33:38 <jle`> alternatively, if you just want a throwaway name, you can do something silly like
18:33:51 <htse> oh it doesn't need the ( ) that's interesting
18:33:54 <jle`> myFunc :: (stringCallback ~ String -> Int) => stringCallback -> String
18:34:09 <jle`> (don't do that)
18:34:13 <jle`> (but well, i do that sometimes, heh)
18:34:17 <htse> that does make stuff a lot more readable in the end
18:34:19 <jle`> (if it gets really complicated)
18:35:21 <cement> maybe I just find currying to be really natural, because I don't see a real reason to do that... unless it's a stupidly complicated type
18:41:11 <htse> oh nice I can return function types that way as well :)
18:50:27 <htse> what is the purpose of function composition? why not just add the appropriate ( )  ?
18:51:01 <htse> is it so the argument isn't buried somewhere in the middle of a )))))) field?
18:51:06 <iqubic> Because that's not what function composition does.
18:51:41 <htse> it chains calls doesn't it? (f . g) argument equals f (g argument) ?
18:51:55 <iqubic> Function composition calls the functions in sequence. It takes the output of function a, and feeds it into function b as the input.
18:52:00 <geekosaur> the point is we don't usually include the argument
18:52:04 <geekosaur> foo = f . g
18:52:23 <geekosaur> so you compose a larger function out of smaller components
18:52:29 <htse> oh so you use it in combination with that eta reduction
18:52:29 <iqubic> Or you could write: foo x = f (g x)
18:52:39 <iqubic> YEs, that's right.
18:53:04 <iqubic> It's a point free coding style.
18:53:22 <geekosaur> the point being we are operating on the *functions*, not the arguments
18:53:34 <cement> about half of my code looks like "foo = f . g . h . j . k . l . m"
18:54:11 <cement> (the other half is figuring out how to refactor Monads into Applicative or Functor)
18:58:01 <crucify_me> hi the wildcard on line 4, why is the x in the list x:xs replaced by the wildcard sometimes? Is that if there is just one element in the list?   http://lpaste.net/359759  
18:59:17 <mud> crucify_me: _ works like any other binding, except it doesn't bind a name.  So that has the exact same meaning as  (x:xs) assuming you never use the name x.
18:59:30 <mud> It's purely for documentation in that sense, it shows that you don't plan to use that value.
18:59:53 <raynold> ahh it's a wonderful day
18:59:53 <crucify_me> you don't plan to use it?
19:00:52 <cement> in the case of drop, you never actually use the first element of the list
19:01:03 <mud> crucify_me: Note that you can rewrite line 4 as  drop n (x:xs) = drop (n-1) xs -- and then note that the value 'x' isn't actually used anywhere on the right-hand-side. So why are we giving it a name? instead we should use _, as they've done.
19:01:43 <mud> _ does the same thing as x, it just doesn't give you a name that you can use.
19:02:00 <crucify_me> mud, cement thanks pondering that
19:04:11 <crucify_me> cement when you say you neever actually use the first element, what you mean is that barring the case of drop 0 which is covered in the first base case, the first element of any list is dropped and not seen in the recursive part of the function?
19:06:25 <dumptruckman> I have a algebraic type of math expression tokens
19:06:37 <dumptruckman> is it possible to make some of those tokens "extend" something
19:06:39 <crucify_me> mud is the above post I made correct?
19:06:41 <dumptruckman> like, the operator tokens
19:06:50 <dumptruckman> I'm asking for the purpose of pattern matching
19:08:00 <mud> crucify_me: It's vague. Making it specific would make it look a lot like the code of the function you pasted.
19:08:55 <crucify_me> mud very sorry I missed you point just now
19:09:43 <mud> Yes, it's correct.
19:10:38 <dumptruckman> https://ghostbin.com/paste/p9ofp
19:10:51 <crucify_me> put another way, you would never see x:xs on the rhs being recursed on, like say drop (n - 1) (x:xs)
19:10:55 <crucify_me> mud ^
19:11:16 <mud> I don't understand the question/comment
19:12:35 <geekosaur> you can't extend an existing type on the fly, no
19:14:29 <iqubic> Not even with reflection/generics/typeable?
19:19:57 <noob_haskeller> Hi guys. I'm trying to write a program in Haskell to print all sublists of a  list of numbers where each sublist has odd number of elements. Here's the code
19:20:01 <noob_haskeller> sublists [] = [[]] sublists (x:xs) = filter (odd . length) [x:sublist | sublist <- sublists xs] ++ sublists xs
19:20:25 <noob_haskeller> eg: sublists [1,2,3,4,5,6]  OUTPUT - [[1,3,5],[2,3,4],[2,3,5],[1],[2,3,6],[3],[5],[2],[4],[6],[1,2,3],[1,2,4],[1,2,5],[1,2,6],[1,3,4],[1,3,6],[1,4,5],[1,4,6],[1,5,6],[2,4,5],[2,4,6],[2,5,6],[3,4,5],[3,4,6],[3,5,6],[4,5,6],[]]
19:20:31 <noob_haskeller> Can someone point out my mistake?
19:21:25 <Welkin> > tails [1..6]
19:21:27 <lambdabot>  [[1,2,3,4,5,6],[2,3,4,5,6],[3,4,5,6],[4,5,6],[5,6],[6],[]]
19:21:57 <crucify_me> mud so the head of (x:xs) is dropped first without a recursion, then the first element of the tail is dropped based on the count (n - 1). so the recursion begins on the first element of the tail.
19:22:18 <crucify_me> its not dropped per se
19:22:45 <crucify_me> its just that on the rhs its not there, only the tail is being recursed on.
19:23:12 <noob_haskeller> Okay. Can you please modify my code. I'm new to functional programming the trying to understand. 
19:26:04 <hololeap> noob_haskeller: i just connected, can you post your code again?
19:26:46 <crucify_me> ie the first element (the head) is not dropped as per the recursive function drop on the rhs, it just goes away, is that correct?   drop n (_:xs) = drop (n - 1) xs    
19:27:33 <crucify_me> and the first recursion, drop (n - 1), operates on the first element of the tail
19:37:06 <dumptruckman> this algorithm is not correct is it? https://i.imgur.com/3xIQur4.png
19:43:20 <sssilver> soooo really I only have one problem with Haskell
19:43:24 <sssilver> it's amazing and perfect in every other way
19:43:38 <sssilver> but the goddamn trailing comma issue is driving me NUTS
19:44:37 <sssilver> this is a nightmare for anyone who cares even a little bit about legibility, typesetting, and typography in general
19:44:48 <sssilver> "this"
19:44:51 <MarcelineVQ> what is the issue and the nightmare?
19:44:51 <sssilver> , "isn't cool"
19:44:56 <dsal> Everyone solves the problem by putting commas in the beginning.
19:45:03 <MarcelineVQ> so put it after "this"
19:45:07 <MarcelineVQ> you have control
19:45:09 <sssilver> holy crap dsal that's exactly what's driving me bonkers
19:45:18 <dsal> I got over it pretty quickly.
19:45:43 <sssilver> MarcelineVQ yes but then I feel marginalized
19:45:50 <sssilver> almost feel like I'm no longer writing "idiomatic Haskell"
19:45:53 <MarcelineVQ> code doesn't care how you feel
19:46:14 <MarcelineVQ> But if you care then pick the feeling you like more :>
19:46:40 <sssilver> perhaps if it was any other character, it wouldn't feel as... wrong
20:08:51 <dumptruckman> How can I ensure a derives show here:  data (Stack a) = NilStack | Top a (Stack a)  
20:10:24 <Fekinox> as in, ensuring that the type variable a has a show instance?
20:10:29 <dumptruckman> yeah
20:10:37 <dumptruckman> (i think)
20:10:50 <Fekinox> I don't think you do that in the datatype declaration, but rather in the instance declaration
20:11:12 <Fekinox> so it looks like `instance (Show s) => Stack s where`
20:11:45 <dumptruckman> like this? https://ghostbin.com/paste/jcutm
20:11:45 <Fekinox> `instance (Show s) => Show (Stack s) where`, rather
20:11:51 <dumptruckman> oh
20:12:18 <dumptruckman> nice, that did it
20:12:58 <MarcelineVQ> data (Stack a) = NilStack | Top a (Stack a)  deriving Show  is enough as long as when you try to show a   Stack a  value the   a   has a Show instance.
20:13:08 <MarcelineVQ> @let data (Stack a) = NilStack | Top a (Stack a)  deriving Show
20:13:10 <lambdabot>  Defined.
20:13:25 <MarcelineVQ> > show (Top 12 NilStack)
20:13:27 <lambdabot>  "Top 12 NilStack"
20:13:30 <dumptruckman> https://ghostbin.com/paste/9qbwo
20:13:33 <dumptruckman> doing it like that
20:13:41 <dumptruckman> i wanna show it like a cons list
20:14:16 <MarcelineVQ> ah if you want a cusotm Show then Fekinox is putting you on the right track
20:14:54 <dumptruckman> How do I get rid of the quotes? "(":"[]"
20:16:07 <dumptruckman> (that was what it printed out)
20:16:09 <MarcelineVQ> :t show
20:16:10 <lambdabot> Show a => a -> String
20:16:47 <MarcelineVQ> show results in a String, and "[]" is already a String so show "[]" is probably redundant
20:16:53 <dumptruckman> hmm
20:16:57 <dumptruckman> ohh
20:34:34 <hololeap> sssi1ver[m]: on that topic, i thought this was interesting: https://stackoverflow.com/questions/10483635/why-do-lots-of-programmers-move-commas-to-the-next-line
20:38:25 <Newbie_> Hey guys. I'm trying to learn me a haskell. Any advice to get the most out of the book?
20:40:08 <hololeap> Newbie_: don't give up
20:41:43 <dsal> Newbie_: Which book?
20:42:21 <geekosaur> if you mean LYAHFGG, find some exercises somewhee
20:42:30 <iqubic> dsal: I think he means "learn you a haskell for a great good"
20:42:42 <dsal> Ah.  That makes sense.
20:42:47 <Newbie_> Yep
20:43:02 <dsal> For exercises, I liked exercism.  For book, I really like haskelbook.com (so far, though I've been coding more than reading lately)
20:55:04 <Fare> what is the name of the combinator that composes in opposite order from (.) ?
20:55:04 <Fare> i.e. foo f g = g . f
20:55:16 <Zermizeee> How can I test if my website is vulnerable to this? https://blog.ircmaxell.com/2017/10/disclosure-wordpress-wpdb-sql-injection-technical.html
20:55:23 <Zermizeee> I just want to know if anyone has a script to check if its vulnerable or not
20:55:28 <Zermizeee> My sysadmin wont update without proof that it is vulnerable
20:57:38 <geekosaur> this doesn't seem like the right channel for that question
20:59:15 * geekosaur sees a #wordpress
21:00:00 * pacak sees a sysadmin that needs to be fired
21:00:29 <geekosaur> that too
21:00:39 <Zermizeee> Our company sucks
21:01:16 * piyush-kurur sees a statement that is often uttered by employes
21:01:26 * pacak likes his company
21:02:04 * geekosaur likewise
21:07:51 <dumptruckman> can I make some of these tokens be specific constructors from the data type? evaluate :: Token -> Token -> Token -> Token
21:09:20 <geekosaur> no, unless you switch to using lifted types
21:09:52 <balor> I have a type `data Foo m  = Foo Int m Int`. A functor for Foo should `fmap f (Foo i m j) = Foo i m (f j)`.  Is there a name for a structure preserving function (morphism?) that would be implemented as `fmap f (Foo i m j) = Foo i (f m) j`?
21:12:47 <MarcelineVQ> why should a functor for foo be `fmap f (Foo i m j) = Foo i m (f j)`
21:13:28 <MarcelineVQ> `fmap f (Foo i m j) = Foo i (f m) j` looks like a Functor for Foo to me
21:16:49 <slack1256> How do I quote a " inside of a "haskell string" ?
21:16:56 <balor> MarcelineVQ, I have always assumed the `derive functor` would simply apply `f` to the rightmost.
21:16:59 <slack1256> if I put a backslash is printed as is
21:17:17 <geekosaur> you are using show (or print, or ghci's implict show) to display it
21:17:23 <geekosaur> > text "foo\"bar"
21:17:25 <lambdabot>  foo"bar
21:17:39 <geekosaur> > "foo\"bar" -- what Show produces
21:17:41 <lambdabot>  "foo\"bar"
21:18:08 <geekosaur> (note that "text" is a lambdabot hack
21:19:09 <slack1256> Mmmm there is an extra show somewhere
21:19:10 <slack1256> got it
21:19:22 <balor> MarcelineVQ, Thanks! https://ghc.haskell.org/trac/ghc/wiki/Commentary/Compiler/DeriveFunctor tells me I'm totally wrong
21:19:23 <iqubic> Is deriving only allowed for typeclasses defined in Prelude? Can I have "Class foo where..." and Data bar x = mkBar x deriving (foo)"?
21:19:32 <balor> MarcelineVQ, And life makes more sense now
21:19:41 <geekosaur> not with the lowercase class name, certainly
21:20:00 <iqubic> if I had an uppercase class name, would that work?
21:20:08 <geekosaur> there is DeriveAnyClass extension but it produces an empty instance (you'd need default methods)
21:20:29 <geekosaur> otherwise, I think 8.2 has deriving strategies but don't know how you'd use them offhand
21:20:43 <iqubic> I see. What makes Eq, Ord, Show, Read, and Functor different?
21:20:46 <geekosaur> (and it will be a few minutes before my browser is back online)
21:21:14 <geekosaur> Fucntor requires an extension. The others are specified in the Language Report. Deriving rules for all of them are built into ghc
21:22:02 <iqubic> What extension does functor require? And will it always Do The Right Thing™?
21:22:49 <geekosaur> DeriveFunctor extension
21:22:49 <balor> iqubic, I think you're asking the question I just asked (https://ghc.haskell.org/trac/ghc/wiki/Commentary/Compiler/DeriveFunctor). Deriving functor will mostly do the right thing
21:23:29 <iqubic> That makes a certain amount of sense I suppose.
21:31:05 <dsal> Is there a good magic to go from  two Maybe Doubles to a Maybe constructor that wants a (Double, Double)  ?
21:31:46 <Adeon> do you mean Maybe Double -> Maybe Double -> Maybe (Double, Double)?
21:31:58 <dsal> That'd be a good start.
21:33:13 <Adeon> so that would give you `Just (a, b)` only if both arguments are Just
21:33:13 <dsal> sequence doesn't do what I'd expect.
21:33:15 <Adeon> maybe something like
21:33:24 <Adeon> let f d1 d2 = (,) <$> d1 <*> d2
21:34:08 <dsal> > let f d1 d2 = (,) <$> d1 <*> d2  in    f (Just 1.0) (Just 2.0)
21:34:10 <lambdabot>  Just (1.0,2.0)
21:34:17 <dsal> > let f d1 d2 = (,) <$> d1 <*> d2  in    f (Just 1.0) Nothing
21:34:18 <geekosaur> aka liftA2 (,)
21:34:19 <lambdabot>  Nothing
21:34:19 <MarcelineVQ> note that the above function already has a name  liftA2  I'm pretty curious about what you mean by a Maybe constructor that wants a (Double,Double)
21:34:36 <dsal> Velocity :: (Double, Double) -> Velocity
21:34:46 <dsal> That's what I'm trying to make.  Well, a Maybe of that.
21:35:34 <jchia> Question about parsing packages: I notice that the packages parsec & attoparsec have combinator functions like choice and count, but the package megaparsec doesn't. Furthermore, the package parser-combinators has combinator functions with the same name (slightly different type signature). Is megaparsec meant to be used together with parser-combinators? How come megaparsec is different from the other libraries by not including these functions? Conversely, why do
21:36:19 <dsal> Thanks, liftA2 looks like the magic I wanted.
21:36:21 <geekosaur> you chopped at 'Conversely, why do'
21:36:34 <jchia> "... Conversely, why don't all these parsing packages all exclude the combinator functions and let another package like parser-combinators provide them?"
21:38:08 <MarcelineVQ> jchia, megaparsec re-exports  https://hackage.haskell.org/package/parser-combinators-0.2.0/docs/Control-Applicative-Combinators.html
21:38:24 <dsal> I don't quite understand the "lift" terminology.  I've not got that far into the book yet. :)  I'm still at the "I know this exists, but don't know what it's called" phase.
21:38:35 <geekosaur> parsec is old. I know megaparsec dumped anything already provided by Control.Applicative, but that doesn't include choice
21:38:42 <geekosaur> ok, then
21:39:29 <geekosaur> and attoparsec isn;t as old as parsec but copied parsec fairly closely, so like parsec it continues to provide its own versions of things that have more standard implementations now
21:39:33 <MarcelineVQ> e.g. https://hackage.haskell.org/package/megaparsec-6.2.0/docs/Text-Megaparsec.html#g:1
21:39:53 <jchia> MarcelineVQ: I didn't notice that. I was just looking at the megaparsec documentation and noticed the absence of count & choice whereas the attoparsec documentation has them.
21:40:10 <geekosaur> Applicative wasn't as much of a thing back then (in fact I don't think it was around when parsec was first released)
21:40:44 <jchia> MarcelineVQ: OK, I missed the part about 're-exports' in the haddock.
21:40:54 <MarcelineVQ> jchia: it's easy to miss
21:41:16 <MarcelineVQ> but a good thing to be in the habbit of looking for when you wonder why a library is missing some core feature
21:55:39 <jchia> geekosaur, MarcelineVQ: Thanks
21:59:34 <geekosaur> hm. as yet deriving strategies is just the simple implementation that lets you pcik between newtype and derive-any-class (and built-in). think its supposed to be extended, maybe via plugins
22:02:08 <zigzrx> huh... this channel still exists
22:13:27 <olligobber> how can you be so sure, zigzrx
22:44:41 <coffeemug> :t 
22:44:42 <lambdabot> <no location info>: error: not an expression: ‘’
22:44:44 <coffeemug> :t 1
22:44:46 <lambdabot> Num p => p
22:45:28 <coffeemug> > take 5 [1..]
22:45:31 <lambdabot>  [1,2,3,4,5]
22:45:47 <coffeemug> (Sorry for spamming, I'll stop now; just remembering the lambdabot goodness)
22:45:59 <geekosaur> there is always /msg / /query
23:25:07 <truffle> is there a way to join a list of strings using intersperse?
23:26:16 <w-spc-gir> What do you mean by join?
23:26:34 <Axman6> :t intersperse
23:26:36 <lambdabot> a -> [a] -> [a]
23:26:44 <Axman6> :t intercalate
23:26:46 <lambdabot> [a] -> [[a]] -> [a]
23:28:30 <truffle> I mean concatenate a list of strings e.g. ["a","b"] to "a,b"
23:31:13 <liste> truffle: why use intersperse for that?
23:31:24 <liste> (or intercalate)
23:31:32 <liste> oh, the comma
23:31:40 <liste> > intercalate "," ["a", "b"]
23:31:42 <lambdabot>  "a,b"
23:32:18 <liste> > concat (intercalate "," ["a", "b"])
23:32:21 <lambdabot>  error:
23:32:21 <lambdabot>      • Couldn't match type ‘Char’ with ‘[a]’
23:32:21 <lambdabot>        Expected type: [[a]]
23:32:46 <liste> > concat (intersperse "," ["a", "b"])
23:32:49 <lambdabot>  "a,b"
23:32:57 <liste> brainfart :|
23:33:05 <truffle> intercalate "," ["foo", "bar", "baz"]
23:33:16 <liste> truffle: add > in the front
23:33:36 <truffle> > intercalate "," ["foo", "bar", "baz"]
23:33:38 <lambdabot>  "foo,bar,baz"
23:33:58 <truffle> neat. thanks liste
23:34:01 <liste> np
23:34:10 <Lokathor> ertes, unfortunately for us both, try as I might all day, I couldn't think of an engaging way to actually do the game i want as a text adventure
23:35:17 <truffle> so does intercalate call concat ( intersperse ) internally?
23:35:47 <Lokathor> truffle, let's find out: https://hackage.haskell.org/package/base-4.10.0.0/docs/src/Data.OldList.html#intercalate
23:35:56 <Lokathor> looks like yes
23:36:41 <truffle> cool cool
23:37:07 <truffle> but why is it Data.OldList as opposed to Data.List
23:37:46 <Lokathor> that is a good question. Data.List probably re-exports stuff that's technically defined in OldList
23:38:42 <truffle> any technical reasons for the separation?
23:38:54 <Lokathor> unlikely
23:39:08 <Lokathor> "Haskell is 20 years old" explains a lot of weird things like that
23:39:23 <liste> https://hackage.haskell.org/package/base-4.10.0.0/docs/GHC-OldList.html this has some rationale
23:39:33 <liste> "This legacy module provides access to the list-specialised operations of Data.List. This module may go away again in future GHC versions and is provided as transitional tool to access some of the list-specialised operations that had to be generalised due to the implementation of the Foldable/Traversable-in-Prelude Proposal (FTP)."
23:39:44 <liste> :t intercalate
23:39:46 <lambdabot> [a] -> [[a]] -> [a]
23:39:52 <liste> that seems list-specialized though
23:40:20 <truffle> then using Data.OldList instead of Data.List in a module will also work ?
23:40:25 <jchia> Question about naming: I have a lens for accessing a 'Widget' in something. If I call the lens 'widget' it will be shadow with any other variable that I also call 'widget'. (I may have a variable representing some widget, not the lens.) To avoid shadowing, is it OK to give my lenses names that start with an underscore? E.g. _widget? Control.Lens already has _1, _2, etc, and lens-aeson has prisms like _Object and _Array.
23:41:19 <jchia> Will there be bad interactions with Typed Holes?
23:42:01 <Lokathor> jchia, the usual convention is that the fields themselves are named with an underscore, and then the lens is that field name with the underscore taken off, but you could buck convention if you need to
23:42:15 <Lokathor> or, name local vars widget_ or widget' or something
23:42:29 <Lokathor> or don't even care if the local var use doesn't also need the lens at the same time
23:42:42 <jchia> Lokathor: I may do "let widget = x ^. _widget; ..." How do people avoid shadowing problems in such cases?
23:43:02 <jchia> Lokathor: I see, you name the variable widget'
23:43:08 <Lokathor> let widget', let theWidget, let widget_, let myWidget
23:43:22 <jchia> OK
23:43:56 <Lokathor> let laWidget, if you're feeling a little extra european
23:44:03 <truffle> also what exactly is meant by list-specialized? googling isn't being much help
23:44:31 <Lokathor> truffle, it means that the same sorts of functions could work with other types, but they are the versions for only lists. compare `map` and `fmap`
23:50:54 <truffle> so the functions in Data.List aren't list-specialized? why would that be ?
23:51:30 <Lokathor> they are list specialized
23:51:32 <Lokathor> :t map
23:51:33 <lambdabot> (a -> b) -> [a] -> [b]
23:51:34 <Lokathor> :t fmap
23:51:35 <lambdabot> Functor f => (a -> b) -> f a -> f b
23:51:49 <Lokathor> map is the list-specialized version of fmap
23:52:17 <jchia> truffle: Some functions in Data.List are not list-specialized. E.g. concat
23:52:19 <jchia> :t concat
23:52:21 <lambdabot> Foldable t => t [a] -> [a]
23:53:13 <liste> :t intercalate' a b = concat (intersperse a b)
23:53:15 <lambdabot> error:
23:53:15 <lambdabot>     parse error on input ‘=’
23:53:15 <lambdabot>     Perhaps you need a 'let' in a 'do' block?
23:53:19 <truffle> why is there a foldable in Data.List ?
23:53:43 <jchia> truffle: If I have to guess, it's because of historical reasons. Maybe once upon a time there were all list-specialized.
23:54:00 <liste> not very long ago in fact
23:55:34 <liste> GHC 7.10 introduced Foldable-Traversable proposal in March 2015
23:56:08 <liste> (well it wasn't a proposal at that point anymore)
23:56:11 <Lokathor> that's like 21 versions in rust time!
23:57:41 <geekosaur> the Foldable stuff is reexported by Data.List basically fgor backward compatibility
23:57:56 <geekosaur> and the original Data.List is available as GHC.OldList when needed
23:58:32 <geekosaur> FTP was informally called the Bridge Burning Proposal for a reason... there was basically no way to do it "right"
