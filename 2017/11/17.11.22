00:29:16 <xacktm> How can one tell what format UTCTime expects wrt aeson?  I'm trying to parse a format like `2017-11-19T17:43:04.464999` into UTCTime but aeson is giving me ': could not parse date: not enough input'
00:31:07 <liste> xacktm: I think UTCtime expects a time zone
00:31:22 <liste> xacktm: if you want a timezoneless time use LocalTime
00:31:45 <xacktm> ah hmm
00:33:24 <xacktm> yes! thanks :)
00:33:47 <xacktm> although ideally I need to modify the backend to return a timezone, but for testing LocalTime is good enough
00:38:37 <liste> not sure if you need a full time zone or if an offset is enough
00:39:18 <liste> I think for having a UTCTime an offset is enough, but for displaying the local time properly you need a full timezone
00:40:38 <Xandaros> /join ##crypto
00:40:41 <Xandaros> wat
00:40:56 <Xandaros> That's a first
00:40:59 <liste> no ##crypto for you
00:41:34 <Xandaros> Well, it worked the second time
00:51:31 <geekosaur> you doubled the / probably
00:51:47 <liste> /does it really work like that?
00:51:52 <liste> apparently it does :)
00:51:54 <geekosaur> in some clients, yes
00:51:55 <liste> TIL
00:54:02 <Xandaros> Yeah, that is what I did
00:54:22 <Xandaros> Must have gotton confused because of the ##. Still, that rather surprised me
00:56:06 <ertes-w> helo
00:57:17 <JuanDaugherty> Xandaros, which client is this?
00:59:43 <Xandaros> weechat
01:01:09 <JuanDaugherty> ah
01:03:14 <jcarpenter2> sometimes
01:03:20 <jcarpenter2> i wonder
01:03:24 <jcarpenter2> why the moon is green
01:03:24 <jcarpenter2> no wait
01:03:31 <jcarpenter2> sorry wrong channel
01:03:53 <MarcelineVQ> is there a slam poetry channel?
01:11:08 <ertes-w> why the moon is green‚Ä¶  because there are languages like clean and provers like lean, yet people use PHP and JS, what does that mean?  it means that pink cows and a big-headed queen can be seen, and the moon can be green!
01:18:10 * hackage wai-extra 3.0.20.2 - Provides some basic WAI handlers and middleware.  https://hackage.haskell.org/package/wai-extra-3.0.20.2 (MichaelSnoyman)
01:22:23 <mniip> Why get concerned with color attribution? It's nothing more than a wavelength distribution. The colors you see are but three convolutions. You can't perceive spectra in high resolution
01:34:34 <mniip> ertes-w, To this type of questions one answer is principal: The argument's called the Anthropic Principle
01:35:10 <ij> telegram-api on hackage requires servant <0.11, but nixpkgs 17.03 have the servant-0.11. Can I solve this somehow? 
01:38:07 <JuanDaugherty> don't use nix
01:38:39 <ij> thoughtful
01:39:05 * JuanDaugherty used it in '10-13 timeframe, nixos that is
01:42:13 <cocreature> ij: use cabal2nix to generate a nix file for some servant version < 0.11 and override the one in nixpkgs by that
01:42:19 <alp> ij, you can override the version of servant you use
01:43:47 <alp> haskellPackages.override { overrides = self: super: { servant = self.callPackage /path/to/your/servant.nix {}; ... }; };
01:44:03 <alp> this overrides the servant that lives in the haskellPackages package set
01:45:17 <ij> Okay, I'll try that. So I could copy the servant entry from the hackage-packages.nix from some while ago?
01:45:45 <alp> ij, the simplest would probably be to do what cocreature said
01:46:15 <alp> cabal2nix cabal://servant-0.10
01:46:24 <alp> and so on, with the other servant packages that you need
01:46:31 <ij> Oh, I didn't know you could cabal://‚Ä¶ :)
01:46:50 <alp> saving the result in some nix files, that you then instantiate in the "overrides" bit
01:47:31 <alp> this could probably be achieved with overlays too, but I'm not yet knowledgeable enough about them
01:47:50 <ij> Suppose it had a tonne of deps. Would I have to save nix files for each of them too?
01:47:50 <alp> and yes, cabal2nix supports various "sources", see its helptext :)
01:48:08 <alp> ooooh actually no sorry
01:48:11 <alp> there's a much better way
01:48:15 <alp> you can use callHackage
01:49:03 <alp> ij, see https://github.com/snowleopard/hadrian/blob/master/shell.nix#L30 for an example
01:49:31 <alp> shake and HUnit are obtained from hackage, some particular versions.
01:49:53 <ij> that's just‚Ä¶ super-easy!
01:49:56 <ij> :D
01:50:44 <alp> quite handy yes
01:51:12 <alp> ij, note that it's however up to you to make sure that the resulting package set is suitable for building your project
01:51:21 <ij> Of course.
01:57:25 <ij> How is caching decided in callHackage case? Will network be always necessary?
01:59:48 <phaazon> 06:12 < pierrot> I'm finally done with this exercise... here's my code: https://glot.io/snippets/evpy6r5kwe. It consists of a implementing an interpreter for this language: https://imgur.com/pHZOCk6
01:59:56 <phaazon> that keeps highlighting me
02:00:07 <phaazon> because of the ‚ÄúpHZ‚Äù in the address :D
02:08:09 <rwarfield> Is there an easy way in GHCI to check if two types are equal?
02:13:16 <alp> ij, well, once you have it in your store, it'll be reused
02:13:30 <alp> but if it's not there, you do need to fetch the package
03:25:21 <sphinxo> cleanest way to optionally update a record eg:
03:26:15 <sphinxo> default = Rec { a = 1, b = "c" }
03:26:53 <sphinxo> and then I have a Maybe Int and Maybe String
03:31:05 <ertes-w> rwarfield: what do you mean, "check"?
03:31:33 <ertes-w> rwarfield: generally you just *require* types to be equal simply by using the same type variable
03:31:37 <ertes-w> :t (+)
03:31:38 <lambdabot> Num a => a -> a -> a
03:31:52 <ertes-w> (3 :: Int) + (3 :: Integer)  -- type error
03:32:52 * hackage gssapi 0.2.0.1 - libgssapi and libkrb5 bindings for haskell  https://hackage.haskell.org/package/gssapi-0.2.0.1 (ondrap)
03:35:43 * hackage gssapi-wai 0.1.2.2 - WAI Middleware for SPNEGO authentiaction  https://hackage.haskell.org/package/gssapi-wai-0.1.2.2 (ondrap)
03:36:07 <mniip> ugh
03:36:15 <mniip> these universal arrows just won't stick...
03:50:54 * hackage cabal-debian 4.36.1 - Create a Debianization for a Cabal package  https://hackage.haskell.org/package/cabal-debian-4.36.1 (DavidFox)
03:58:48 <ertes-w> maybe you should put more tension on the bow
04:01:58 <Yotam_> How can I convert my function `f:: v Double -> Double` to be used in https://hackage.haskell.org/package/ad-4.3.4/docs/Numeric-AD-Mode-Reverse.html#v:grad?
04:04:03 <lyxia> Yotam_: make it f :: Num a => v a -> a
04:08:54 <sjivcdj> (fmap . fmap) sum Just
04:08:58 <sjivcdj> :t (fmap . fmap) sum Just
04:09:00 <lambdabot> (Num b, Foldable t) => t b -> Maybe b
04:09:22 <sjivcdj> :t (fmap . fmap) sum
04:09:24 <lambdabot> (Num b, Foldable t, Functor f2, Functor f1) => f1 (f2 (t b)) -> f1 (f2 b)
04:10:13 <sjivcdj> (fmap . fmap) sum Just [1,2,3]
04:13:07 <Yotam_> lyxia: Unfurtunatly a is bounded to Double by another function call
04:14:55 <lyxia> Yotam_: I'm not sure how that is an obstacle
04:15:13 <romanix> i'm checking my application for spaceleaks. i'm using ekg and also looking at actual residency in top
04:16:06 <romanix> on consecutive runs with the same input my app shows constant max residency on ekg, which suggests no leaks
04:16:26 <romanix> but in top, the memory usage increases with each run
04:16:33 <romanix> which is strange
04:16:53 <mniip> (f, m) :: exists y. (D X (F y), forall z. D X (F z) -> C y z) such that forall h, h = fmap (m h) . f
04:17:01 <romanix> by run, I mean feeding the app with data. it is a server so there are no restarts between runs
04:17:06 <mniip> ertes-w, make any sense to you?
04:17:12 <romanix> any ideas?
04:17:58 <lyxia> Yotam_: do you mean that f is used elsewhere at type Double?
04:19:37 <Yotam_> lyxia: https://github.com/yohad/Reactive-Apple/blob/master/src/Apple.hs this is what I'm trying to do
04:20:23 <mniip> Yotam_, I think you're using that package incorrectly
04:20:44 <Yotam_> mniip: How's that?
04:20:49 <mniip> this does automatic differentiation not numeric differentiation
04:21:13 <mniip> "f :: v Double -> Double" is too generic
04:21:18 <mniip> to differentiate
04:21:55 <Yotam_> Do you know another way to get the grad?
04:22:10 <Yotam_> Because I can't find a library for this
04:22:31 <mniip> grad of what exactly
04:23:03 <Yotam_> of f, for `optimize`
04:24:11 <mniip> sounds like you might need to compute the gradient numerically
04:25:40 <mniip> Yotam_, what's b1 and b2 anyway
04:26:02 <Yotam_> they are of type Image s i
04:29:00 <mniip> what's the total type of 'collision'
04:29:44 <Yotam_> Image s i -> Image s i -> Bool
04:30:01 <Yotam_> It needs to tell me if there is an overlapping to the projections
04:30:26 <mniip> but then 'project b1' :: s -> i
04:30:39 <mniip> and you apply (^) to that
04:31:27 <Yotam_> For some reason that typed checked and I didn't looked at it
04:31:59 <mniip> it probably assumed Num (s -> i) and didn't report the missing instance because there were more severe errors
04:33:05 <tabaqui> how you measure cpu load with haskell?
04:33:51 <tabaqui> and memory, though I've done it already with /proc/meminfo
04:34:04 <hpc> read /proc/loadavg, or do whatever top does
04:34:46 <tabaqui> oh, didn't know about this file, always thought that top calculate clock ticks
04:35:19 <tabaqui> hmm, but /proc/loadvg doesn't correlate with htop
04:36:25 <hpc> load average is a measure of the number of processes queued for cpu time, interpolated with some exponential thing like how capacitors work
04:36:53 <hpc> the three numbers are with different decay levels, one measures roughly the past minute, then 5 minutes, then 15 minutes
04:37:06 <mniip> "like how capacitors work"
04:37:11 <mniip> did you mean exponential decay
04:37:20 <hpc> yeah
04:37:48 * hpc is still waking up :P
04:38:51 <hpc> actual cpu time probably comes from files deeper down in /proc
04:39:47 <tabaqui> I've started 'while True: pass' 5 minutes ago
04:39:55 <tabaqui> and first number in loadavg is 1.55
04:40:06 <tabaqui> (I have 4 cores and one of them is fully loaded)
04:41:38 <tabaqui> well, I get it
04:42:23 <tabaqui> hmm, still not enough precise
04:42:57 <tabaqui> 1 minute interval is too wide
04:51:14 * hackage yesod-csp 0.2.2.0 - Add CSP headers to Yesod apps  https://hackage.haskell.org/package/yesod-csp-0.2.2.0 (boblong)
05:22:04 <ertes-w> mniip: symbolically yes, and shape-wise it reminds me of epimorphisms‚Ä¶  
05:22:13 <ertes-w> not sure what to do with it, though
05:24:05 <sternmull> is there a recommended way to pick the first element of a list that satisfied a predicate? Something like [a] -> (a -> Bool) -> ([a], Maybe a)
05:25:01 <merijn> sternmull: "listToMaybe . filter p"?
05:25:54 <merijn> That returns "Maybe a" instead of ([a], Maybe a), but it's ambiguous what you want with that return type anyway?
05:26:25 <sternmull> merijn: I want the first element that satisfied the predicate and a list without that element.
05:26:50 <merijn> I don't think there's an easy function for that, no
05:26:56 <merijn> Maybe some lens voodoo will do it
05:27:31 <sternmull> ok, then i write my own utility function for that
05:27:57 <Ke> what is the rest of the [a] there
05:29:16 <sternmull> what i actually want is some kind of priority queue that supports popping the highest priority-element that satisfies a predicate.
05:33:49 <felixsch_> what is the correct way: I have a stack project with a cabal file only containing one executable. Now I want to add unit tests but the unit tests can not find the source the executable.
05:34:54 <felixsch_> Add the src of the executable to hs-source-dirs results in lot of warnings about redundant imports
05:35:15 <felixsch_> of the unit test executable
05:36:37 <merijn> felixsch_: The correct way: Move all the source used by both into a library and make the tests and executable both depend on that
05:37:04 <merijn> felixsch_: You can have executables in a cabal file depend on a library in that same file
05:37:20 <felixsch_> ok tought so already.. out of lazyness I tought with luck there might be another way :)
05:37:24 <merijn> felixsch_: That's better design anyway, since it makes it easier for other people to reuse/extend your executable to
05:37:38 <felixsch_> thats true! thanks for the advice :)
05:37:42 <merijn> felixsch_: Shouldn't really cost much effort to do that, though?
05:38:30 <felixsch_> mhm I will see. It's a webapp so the most stuff will end up in the library anyway
05:38:39 <fabien__> hi how can i go from 1000 :: Int to [1,0,0,0] ?
05:39:58 <opqdonut> > map digitToInt $ show 1000
05:40:00 <lambdabot>  [1,0,0,0]
05:40:08 <opqdonut> fabien__: ^ that's the easiest option, but show is kinda slow
05:40:31 <fabien__> ok
05:40:34 <fabien__> thk
05:40:53 <opqdonut> a divMod loop is the proper answer
05:43:27 <opqdonut> something like:
05:43:29 <opqdonut> > unfoldr (\n -> case n of 0 -> Nothing; n' -> let (d,m) = divMod n 10 in Just (m,d)) 1234
05:43:31 <lambdabot>  [4,3,2,1]
05:43:58 <fabien__> ouch
05:48:11 * hackage dynamodb-simple 0.5.0.0 - Typesafe library for working with DynamoDB database  https://hackage.haskell.org/package/dynamodb-simple-0.5.0.0 (ondrap)
05:54:44 <sternmull> what is wrong with my guard syntax inside where? http://lpaste.net/360193
05:55:15 <merijn> sternmull: no parens around your list
05:55:40 <merijn> i.e. "x:xs" instead of "(x:xs)"
05:55:57 <sternmull> oh, thanks!
06:04:04 <sternmull> i like to shadow variables a lot. For example "f x = case x of {Maybe x -> foo x}". Is this considered bad practice?
06:04:14 <merijn> It Depends (TM)
06:04:29 <sternmull> (of course it shoud be "Just x -> foo x" ...)
06:04:34 <merijn> I tend to avoid it, since it ensures you don't accidentally use the "wrong" variable
06:05:08 <merijn> But sometimes it's really inconvenient not to shadow some name (I often find myself wanting to use 'id' as variable name)
06:05:55 <sternmull> in this example i find it very useful because i don't want to access the Maybe anymore when i already got its inner value that i actually want to use.
06:06:58 <merijn> sternmull: What do you return for Nothing?
06:07:13 <merijn> sternmull: Because there's a bunch of better alternatives for that anyway
06:07:14 * hackage text-builder 0.5.1 - An efficient strict text builder  https://hackage.haskell.org/package/text-builder-0.5.1 (NikitaVolkov)
06:07:34 <sternmull> merijn: In real code i do handle all cases. This was just to show how i often shadow variables.
06:07:52 <merijn> sternmull: I'd avoid the shadowing here by using, e.g. fromMaybe
06:08:45 <merijn> Because then you can just do "f x = maybe default foo x" (no shadowing) and simplify further to "f = maybe default foo" <- don't even have to come up with name 'x' :)
06:08:51 <sternmull> merijn: Right. I should keep that in mind.
06:10:40 <sternmull> But i also had a few other cases where i match a constructor that is really just a wrapper for something i want to use. For example a message with some text, so i do "case msg of; Msg msg -> print msg" or somthing similar.
06:12:23 <pierrot> I'm trying to turn this: https://github.com/pierrot14/interp into a cabal package. I'd like to expose the "Parser" module as a library and "interp" as an executable. `cabal init` created a default 'interp.cabal' file that I adapted to include both (a library and a executable). This is the file I'm editing right now: https://glot.io/snippets/evqd1n7tdn
06:12:53 <merijn> pierrot: That paste site...does not look usable without cookies
06:13:00 <merijn> pierrot: Maybe repaste on lpaste.net?
06:13:11 <pierrot> merijn: Ok
06:14:46 <pierrot> merijn: http://lpaste.net/3918373113103908864
06:15:06 <pierrot> I'm not sure about the dependencies
06:15:27 <pierrot> default ones for executable `interp' were "base >=4.9 && <4.10, mtl >=2.2 && <2.3"
06:15:46 <merijn> pierrot: Looks reasonable
06:16:14 <merijn> pierrot: At the very least you're going to need "base" for the library
06:16:48 <pierrot> merijn: so do I copy that line for the library too?
06:17:20 <merijn> pierrot: You can skipe the mtl part for the library, since that isn't using mtl right now
06:17:45 <pierrot> what's mtl?
06:17:54 <pierrot> can I remove it from the executable too?
06:17:57 <merijn> @hackage mtl
06:17:57 <lambdabot> http://hackage.haskell.org/package/mtl
06:18:20 <merijn> pierrot: It's the mtl library, and no, you can't remove it, since you import Control.Monad.Reader (which is part of the mtl package)
06:20:47 <pierrot> merijn: thanks
06:23:16 <pierrot> I see that Control.Monad is part of base too, so it seems that "base >=4.9 && <4.10" is the only dependency I need to fil for the library
06:23:32 <pierrot> fill *
06:35:21 <pierrot> merijn: for the executable, do I need to add `other-modules: Parser, interpreter' ?
06:35:33 <merijn> pierrot: No
06:37:13 <pierrot> is that for external modules?
06:56:02 <Forlorn> How would on conduct proof in Haskell in contrast to testing?
06:56:09 <Forlorn> s/on/one
06:57:14 <merijn> Forlorn: You mean as in "prove your program correct"?
06:57:47 <Forlorn> merijn, yes, or that a property holds for a function.
06:58:10 <merijn> Forlorn: There is an excellent (free!) book on the topic of proving properties of functions
06:58:13 <merijn> @where sf
06:58:13 <lambdabot> "Software Foundations" by Pierce,Casinghino,Greenberg,Sj√∂berg,Yorgey in 2011-06 at <http://www.cis.upenn.edu/~bcpierce/sf/> about "the mathematical theory of programming and programming languages",
06:58:13 <lambdabot> "It develops basic concepts of functional programming, logic, operational semantics, lambda-calculus, and static type systems, using the Coq proof assistant."
06:58:25 <merijn> Forlorn: That one
06:58:43 <merijn> Forlorn: It comes with lots of exercises and examples too
06:59:03 <Forlorn> merijn, is that similar to proving that a program is correct?
07:00:14 <merijn> Forlorn: It starts out with proving individual (pure) functions and keeps building on top of that to how to do proofs on entire imperative programs
07:00:16 <Forlorn> merijn, oh, it uses Coq, that's awesome, I am very eager to learn about Proof theory, Type theory, and Category theory.
07:00:40 <merijn> Forlorn: Things like "prove reversing a list twice produces the same list"
07:00:44 <Forlorn> I have been looking at Agda a little bit too
07:01:25 <merijn> Forlorn: The entire book is literate Coq, so if you download it you can actually interactively step throught the proofs using ProofGeneral (emacs) or Coquille (vim)
07:01:35 <Forlorn> merijn, thanks, I will probably purchase that book right away :)
07:02:10 <merijn> Forlorn: Well, you can download it for free to see if you like it first :)
07:05:07 <mantasg> Hi guys, I have a Lens question
07:05:21 <mantasg> I have a maybe hashmap and I want to query it
07:05:31 <mantasg> e.g: 
07:05:32 <mantasg> foo :: Maybe (HM.HashMap Int Int)
07:05:36 <mantasg> foo = Just $ (HM.fromList [(1,2)])
07:05:50 <mantasg> if I query it using lenses: foo ^? _Just . at 2 
07:06:06 <mantasg> I get (Just (Just 1))
07:06:27 <mantasg> Is there some lensy wai to jon Maybes
07:06:32 <mantasg> *way
07:06:34 <merijn> :t join -- ? :p
07:06:35 <lambdabot> Monad m => m (m a) -> m a
07:06:52 <mantasg> yeah that's what I thought myself 
07:07:03 <mantasg> I can do "^. to join"
07:10:27 <mniip> question
07:11:03 <mniip> Mac Lane mentions that in the yoneda the functor needs to come from a locally small category, why is that
07:14:15 <mniip> in this proof, where do I use the local smallness? http://mathb.in/20481
07:14:54 <ystael> mniip: where you say that Hom_C(X, .) is a functor from C to Set
07:15:03 <mniip> ah yes
07:15:09 <mniip> Set is just the small sets
07:15:11 <mniip> innit
07:22:45 * hackage speculate 0.3.1 - discovery of properties about Haskell functions  https://hackage.haskell.org/package/speculate-0.3.1 (rudymatela)
07:38:55 <ticao[m]> hey
08:31:20 <Mins> Hello, why is "foldr (\_ acc -> acc + 1) 0 [1]" = 1 and "foldl (\_ acc -> acc + 1) 0 [1]" = 2? o.o
08:33:04 <lyxia> Mins: the arguments are actually flipped between the functions passed to foldr and foldl
08:33:16 * hackage repline 0.1.7.0 - Haskeline wrapper for GHCi-like REPL interfaces.  https://hackage.haskell.org/package/repline-0.1.7.0 (sdiehl)
08:33:20 <Mins> Yeah, got that. Thanks! "foldl (\a b -> a + b) 0 x" is now working
08:34:02 <lyxia> > (foldl (+) x [a,b,c], foldr (+) x [a,b,c])
08:34:04 <lambdabot>  (x + a + b + c,a + (b + (c + x)))
08:35:34 <Mins> > foldl (\a b -> a + b) 0 x
08:35:37 <lambdabot>  error:
08:35:37 <lambdabot>      ‚Ä¢ Couldn't match expected type ‚Äò[a]‚Äô with actual type ‚ÄòExpr‚Äô
08:35:37 <lambdabot>      ‚Ä¢ In the third argument of ‚Äòfoldl‚Äô, namely ‚Äòx‚Äô
08:35:44 <Mins> :D
08:35:54 <Mins> foldl (\a b -> a + b) 0 [1,2,3]
08:36:06 <Mins> > foldl (\a b -> a + b) 0 [1,2,3]
08:36:08 <lambdabot>  6
08:36:23 <Mins> Wrong function. Oops.
08:36:28 <Mins> But thanks, I'll work it out.
08:53:55 <muesli4> lyxia: oh wow, lambdabot is cool
09:08:49 <yhhko> i'd like to generate types based on some text in a file. i could just generate code directly, or I could use TH. I could use dependent types. is there another option?
09:22:12 <glguy> Dependent types aren't relevant. Generating a file manually or with template haskell are your two choices
09:22:39 <yhhko> dependent types are relevant. i translate the characters from the file to different types.
09:22:47 <yhhko> but i agree they are undesirable
09:23:08 <glguy> yhhko: No, that's not what dependent types means
09:23:53 <spietz> dependent types are types that depend on values
09:24:05 <yhhko> yes, and the type that i output depends on the value in the text file
09:24:09 <spietz> the characters in a file are values
09:24:35 <spietz> in what what would dependent types not be relevant?
09:24:45 <spietz> glguy
09:24:49 <yhhko> anyway, i'm not really interested in the semantics of the word "dependent type". are there any other options than code generation or template haskell?
09:25:15 <mniip> yhhko, an untyped mess
09:25:21 <mniip> Dynamic/Typeable
09:25:48 <spietz> I don't think the confusion is about semantics
09:26:30 <yhhko> i'm also not interested in the semantics of the word "semantics". or of "confusion", for that matter
09:26:56 <glguy> Ok, good luck
09:27:02 <yhhko> thanks :)
09:27:15 <spietz> ok, I'm not really interested in what you are and arent interested in
09:27:23 <EvanR> it depends on what "means" means
09:27:29 <spietz> I was talking to the other person
09:27:32 <purpleunicorn> Hi
09:27:54 <yhhko> spietz: okay, sorry for that then
09:28:16 <purpleunicorn> I think i was hacked.....
09:28:30 <mniip> Fascinating. What does this have to do with Haskell?
09:28:40 <glguy> purpleunicorn: This channel is for discussion of the Haskell programming language; it's not a general chat channel.
09:29:17 <purpleunicorn> It doesn‚Äôt but I can‚Äôt find any other channel with others in it
09:29:26 <EvanR> /topic haskell or gtfo
09:29:42 <purpleunicorn> Ok
09:29:52 <MarcelineVQ> You guys are full of beans today
09:30:08 <Clint> o_O
09:32:57 <sm> O_o
09:34:02 <ertes-w> err‚Ä¶  i don't know if context is needed, but this most recent backlog almost gives me 50 fields
10:10:51 <jeddak> q
10:10:53 <jeddak> :q
10:10:58 <jeddak> quit
10:11:01 <jeddak> \q
10:11:43 <kaychaks> while trying to install `Dhall` in a sandbox am getting cabal error installing `zlib-0.6.1.2` stating `- cabal: Missing dependency on a foreign library:
10:11:43 <kaychaks> * Missing (or bad) header file: zlib.h`. I did install the package zlib using cabal install and then also added separately using `nix`
10:12:13 <kaychaks> while trying to install `Dhall` in a sandbox am getting cabal error installing `zlib-0.6.1.2` stating `- cabal: Missing dependency on a foreign library: * Missing (or bad) header file: zlib.h`. I did install the package zlib using cabal install and then also added separately using `nix`
10:13:51 <jeddak> 
10:19:54 <geekosaur> kaychaks, I'm looking, someone else ran into it and it's some kind of nix weirdness
10:24:53 <geekosaur> blah. found the past discussion, thought there was a coda on it but there isn't. so I have no idea what the fix is. I only know that it's something that nix is doing that makes the zlib header files not quite work right under nix (and you need them to use zlib, as a lot of the functionality is hidden in macros to deal with versioning etc.)
10:25:24 <barrucadu> Are you building with stack or cabal?
10:25:54 <barrucadu> Stack has nix integration which works pretty well.  I think for cabal running the build inside a nix-shell will do, but I'm not sure.
10:26:51 <barrucadu> Oh, sandbox.  Cabal then.
10:39:03 <spietz> keychaks: if you're using nix what's the benefit of using a cabal sandbox?
10:39:21 <spietz> kaychaks
10:39:22 <spietz> *
10:51:34 <lambdamu_> kaychaks: Hey the way I deal with the zlib dependency for the zlib haskell package is to use this paste with nix-shell and then execute the cabal commands inside the shell: http://lpaste.net/360199
10:52:09 <lambdamu_> nix-shell -p zlib doesn't work unfortunately
10:52:58 <lambdamu_> Although when you build a haskell package that way no gc root for the nix store is added, so it can happen that with gc the zlib store path is removed
10:53:43 <lambdamu_> I think there are options with nix-shell to have a root added, but generally I don't bother so I can't tell you more
11:09:41 <codeshot_> I went to solve Kevlin Henney's FizzBuzz program for Haskell giving the neatest code I could. In order to do that I ended up re-inventing Data.Functor.Compose but with a different Applicative instance
11:10:12 <codeshot_> Sorry, a different Alternative instance
11:11:02 <codeshot_> How come Compose has the Alternative instance that it does instead of following the pattern of the Applicative instance, that <|> be implementent with (<|>) <$> a <*> b
11:11:50 <codeshot_> This is an amazing instance and there were only 3 reasonable choices so I'm curious why we have the one we do
11:15:44 <Cale_> Hello from a coffee shop in Toronto :)
11:16:03 <Cale_> Anyone here coming to the FunctionalTO meetup tonight?
11:16:05 <codeshot_> hello Cale_
11:16:17 <codeshot_> maybe another yeah
11:16:34 <codeshot_> Cale_, you're pretty expert, can you answer this quandry?
11:16:39 <codeshot_> I went to solve Kevlin Henney's FizzBuzz program for Haskell giving the neatest code I could. In order to do that I ended up re-inventing Data.Functor.Compose but with a different Applicative instance
11:16:45 <codeshot_> Sorry, a different Alternative instance
11:16:50 <codeshot_> How come Compose has the Alternative instance that it does instead of following the pattern of the Applicative instance, that <|> be implementent with (<|>) <$> a <*> b
11:16:55 <codeshot_> This is an amazing instance and there were only 3 reasonable choices so I'm curious why we have the one we do
11:17:15 <Cale_> I don't recall which Alternative instance it has
11:17:26 <codeshot_> Compose (a <|> b)
11:17:29 <Cale_> Does it rely on Alternative instances for the functors?
11:17:52 <codeshot_> (Alternative f, Applicative g)
11:18:28 <codeshot_> other options would have been (Applicative f, Alternative g) <~~ very cool, or (Alternative f, Alternative g) <~~ interesting but would be super ambiguous
11:18:44 <codeshot_> I propose that (Applicative f, Alternative g) is the correct choise
11:18:46 <codeshot_> choice
11:20:06 <Cale_> Ah, it's the cheapest instance, I guess.
11:20:27 <Cale_> Looks like they implemented (<|>) just by coercing away the newtype
11:21:01 <codeshot_> This is how cool my preferred option is: http://lpaste.net/360200
11:21:04 <Cale_> But yeah, it's hard to say what the "right" instance is, when there's more than one to choose from
11:22:15 <codeshot_> SubZero models reaching down underneath values to add new structure
11:22:26 <Cale_> You can also do a similar trick just with Monoid though.
11:22:43 <codeshot_> (lowering the zeropoint in a parallel to Physics)
11:23:03 <codeshot_> But Monoid doesn't have half the descriptive power and clarity of code
11:23:15 <Cale_> It's really similar...
11:25:07 <codeshot_> I started there and realised it wasn't right - it works for some append models but not general "we started with one end decision for each point of the functor's source and we work back to expand the decisions that could have been made to get there" which allows much more arbitrary stuff, including <|> that builds structure instead of just appending
11:25:40 <codeshot_> I think this would be an important foundation for compiler optimizers, for example
11:26:20 <Winwin> https://cryptosrevolution.wixsite.com/beta/
11:26:46 <Cale_> > let fizzbuzz n = fromMaybe (show n) $ ("fizz" <$ guard (n `mod` 3 == 0)) <> ("buzz" <$ guard (n `mod` 5 == 0)) in map fizzbuzz [1..30]
11:26:48 <lambdabot>  ["1","2","fizz","4","buzz","fizz","7","8","fizz","buzz","11","fizz","13","14...
11:27:06 <codeshot_> yeah that was my starting point, but the problems it solves are very limited
11:27:42 <codeshot_> you have to change your intuition about what lines to start writing quite radically even for similar problems
11:27:46 <Cale_> I suppose. Certainly Applicative functors are more interesting.
11:30:48 <codeshot_> How does one go about trying to do something about this?
11:31:34 <codeshot_> Soon I'll have some demonstration of this here: https://github.com/code5hot/subzero
11:32:30 <codeshot_> It's currently out of date code
11:37:46 <Cale_> codeshot_: You mean selecting a different instance? Usually just making a newtype wrapper is the thing
11:40:36 <codeshot_> well I can do that
11:40:54 <codeshot_> but I wonder if Compose should be adjusted or we should add Compose'
11:41:01 <codeshot_> developers need ready materials
11:41:14 <codeshot_> before they learn about implementing typeclasses, etc
11:43:07 <Welkin> codeshot_: what does Compose have to do with what you just said?
11:47:32 <codeshot_> well, it's functor composition which is what we want to do to write sophisticated programs, but it's applicative instance appears to be one that doesn't help with intuitive programs and few building blocks
11:48:00 <codeshot_> that is, it looks like haskells "Compose" data type is not the most natural functor composition
11:48:28 <Welkin> I have never even lloked at Compose except for an academic exercise that didn't actually need it
11:48:32 <Welkin> looked*
11:48:58 <mud> I used it in reflex a time or two and it actually helped. I forget the specifics though.
11:49:17 <codeshot_> I just created a type so I could write something in an intuitive way and which applies to very many problems, and then I realised it was probably functor and it was but for the Alternative instance
11:49:30 <codeshot_> whereupon I was like "I think that's not what they would really want"
11:50:35 <codeshot_> Here's the fizzbuzz game as a test case for my SubZero datatype: https://github.com/code5hot/subzero/blob/master/test/Spec.hs
11:51:48 <codeshot_> SubZero's applicative gives [[1],[2]] <|> [[3],[4]] == [[1,3],[1,4],[2,3],[2,4]] instead of just [[1],[2],[3],[4]] so it's much richer
11:52:48 <codeshot_> I'd like to get SubZero into base but with a name that reflects that it's an equal or maybe superior functor composition vs Compose
11:53:25 <codeshot_> especially so devs find it as an avenue from basic python system programming to compositional functional programming
11:54:00 <Welkin> what does python have to do with anything?
11:55:52 <codeshot_> Ah, it's a popular programming language
11:56:28 <codeshot_> and to be able to create great haskell programs it helps to have more mindshare
11:56:39 <mud> codeshot_: So it's just about the Alternative instance it looks like?
11:56:39 <codeshot_> you get more support and training
11:56:46 <codeshot_> so far
11:57:04 <mud> I didn't know Compose actually gave you an Alternative, definitely never used that myself.
11:57:05 <codeshot_> This suggests another prime type class derived from Alternative
11:57:12 <codeshot_> I have to sleep on it for now though
11:57:22 <codeshot_> mud, I don't think it's a good instance at all
11:57:42 <codeshot_> it doesn't deliver on the potention of functor composition
11:57:55 <codeshot_> *potential
11:59:13 * hackage traildb 0.1.3.0 - TrailDB bindings for Haskell  https://hackage.haskell.org/package/traildb-0.1.3.0 (Adeon)
12:18:40 * hackage traildb 0.1.4.0 - TrailDB bindings for Haskell  https://hackage.haskell.org/package/traildb-0.1.4.0 (Adeon)
12:22:20 <ioann> Hello, when I create a new variable, a lambda, containing some outside parameter, does it remember the value? For some reason this does not work (trying this: https://pastebin.com/hrn3QYxY). Can one accomplish this behaviour w/o using global variables?
12:22:59 <dsal> ioann: Your paste is expired, but it's not clear what you're asking for.
12:23:04 <dsal> What's a global variable?
12:23:29 <ioann> Well this is what I am trying to accomplish:
12:24:10 <epta> dsal: it isn't expired, ')' shouldn't be part of the link
12:24:12 <ioann> http://lpaste.net/2510978537125576704
12:24:23 <dsal> Ah, client issues.
12:25:33 <ioann> Basically what I expected this to do is to do recursive branching .. if key = x then <some scalar> else <call previous lambda which was used to create this one> key
12:26:20 <ioann> e.g. just a whole lot of if key == 1 then value else if key == 2 then value else ...
12:27:09 <lyxia> ioann: you are calling map_ recursively with key...
12:28:31 <dminuoso> ioann: I recommend you expand the expression `addKeyToMap b 3 4` by hand.
12:28:48 <dminuoso> To make it obvious why you are getting 0.
12:29:28 <ioann> Ah silly of me.
12:30:00 <leshow> I'm trying to write a parser for a css file to get all the "url(someurl)" and return a list of all the urls, I started off with this: http://lpaste.net/360204  but I think I'm doing something wrong
12:30:01 <ioann> Trivial error /x not key/, sorry to have bothered you with a triviality such as this. Anyway, thank you!
12:30:11 <dsal> The lpaste error about the lambda is helpful here.
12:31:15 <leshow> the parser gets to some point in the file (never makes it to "url(" and goes 'unexpected "p"' expecting "url("
12:31:29 <leshow> seems to make it to like the 10th column, oddly
12:31:54 <beemo> any way to handle insert errors in opaleye?
12:32:12 <leshow> Oh, I think it's hitting a 'u' and then failing because it doesnt get 'url', how do i fix that?
12:33:19 <lyxia> void $ try $ string "url("
12:34:27 <leshow> then it hits the eof without finding the ")". There are a bunch of "url()" in here so it should be able to find one
12:35:04 <lyxia> many1 anyChar will eat everything because anyChar never fails until the eof
12:35:10 <leshow> oh
12:38:37 <leshow> I'd like to accept pretty much anything up until the closing ")" though, since it'll be a url with possibly weird characters in it. Is there a way to do that?
12:40:00 <dsal> "url(" *> many1 (satisfy (/= ')') <* ")"
12:41:17 <dsal> Not sure what happens if there actually is a ) in your URL, though.  I've not looked at that spec.
12:44:03 <dsal> Oh, gross.  It might have quotes and it might have escape characters.
12:44:34 <mniip> eh that's like a couple extra lines of code
12:45:14 <dsal> I just don't like specs that have three ways to do one thing.
12:47:14 <leshow> I can't seem to get that working anyway, does that expression return a Parser String? I have control over the urls here so they won't contain anything wacky
12:48:29 <dsal> leshow: I'm using attoparsec -- that works pretty well as-is:
12:48:33 <dsal> Œª> A.parseOnly ("url(" *> A.many1 (A.satisfy (/= ')')) <* ")") "url(http://something/)"                   
12:48:34 <dsal> Right "http://something/"   
12:49:04 <leshow> oh, I see. I was using parsec
12:55:50 * hackage subzero 0.1.0.0 - Helps when going "seed values" -> alternatives and optional -> answers  https://hackage.haskell.org/package/subzero-0.1.0.0 (codeshot)
13:13:44 <mniip> I feel like I've been studying CT wrong all this time
13:14:28 <benzrf> that seems extremely likely
13:14:48 <benzrf> i mean, from the context of "is posting this in a haskell channel"
13:14:54 <mniip> I'm reading Mac Lane
13:15:25 <benzrf> you mean that's what was wrong all this time, or you mean mac lane has shown you the light?
13:15:38 <mniip> and in every exercise I end up tediously writing down all the functors and transformations with exhausting mental juggling of objects and arrows
13:15:56 <mniip> and in every proof Mac Lane is like, check out this diagram and this vague equation and huzzah
13:16:45 <mniip> and before I can digest said diagram and equation I need to write down all the omitted objects, arrows, an equations
13:16:56 <mniip> which suggests that I don't "understand" diagrams
13:17:27 <mniip> which appear to be the cornerstone of the whole CT thing
13:18:12 <mniip> I can't say "mac lane has shown me the light" but I definitely see a problem
13:19:51 <mniip> benzrf, I mean like this http://mathb.in/20466
13:21:41 <benzrf> qh
13:21:43 <benzrf> *ah
13:22:18 <benzrf> i think its probably because like - that tedious checking doesn't really need to be written down to be easily doable - so they only write down the part that involves any kind of insight
13:22:41 <mniip> but
13:22:44 <mniip> I can't verify it
13:22:52 <benzrf> hmm?
13:24:09 <mniip> I can't do the checking in my head
13:24:14 <taktoa> anyone know enough about propositional equality in haskell to answer the question in this gist? https://gist.github.com/taktoa/10e943caf5606f25486491bf0b6b2ba2
13:24:48 <mniip> taktoa, the answer is no
13:25:09 <mniip> taktoa, consider data Proxy a = Proxy
13:25:23 <mniip> just because it's represented with the same constructor doesn't mean Proxy a ~ Proxy b
13:25:43 <taktoa> mniip: is there some kind of type role shit I can do to at least get a Coercible instance or something?
13:26:19 <mniip> for the 'Foo m' part - probably yes
13:26:26 <benzrf> taktoa: yes this is what type roles are about
13:26:44 <benzrf> er wait
13:26:44 <mniip> (a -> m ()) probably not as they are actually different representations
13:26:48 <benzrf> sorry i think i mightve misread
13:27:13 <taktoa> oh yeah duh
13:27:30 <taktoa> like, that equality is just trivially false
13:29:24 <mniip> you can do this however
13:29:47 <mniip> newtype Bar m a = Bar (Foo m, ...)
13:30:08 <mniip> then Coercible will give you coerce :: Bar m a -> Bar n a, where Foo m ~ Foo n
13:31:28 <sternmull> I use lens and try to simplify a working "foo & bar . at k .~ Nothing" by using "sans". "bar" is a field of type Map in a Foo. Can "sans" even be combined with the "bar" lens?
13:31:31 <mniip> benzrf, anyway, I feel like a large part of CT is being able to comprehend these checks on large scale and be able to mentally verify them without writing everything down
13:31:57 <taktoa> it occurs to me that I might just have a more general architectural problem with the monad transformer I'm working on, so I guess I'll just say what I'm trying to do in general
13:32:06 <taktoa> this is the source code https://gist.github.com/taktoa/37c761355f0cbe6d575963e3feed8c5c
13:32:34 <taktoa> specifically, look at https://gist.github.com/taktoa/37c761355f0cbe6d575963e3feed8c5c#file-snapshot-hs-L306
13:33:07 <mniip> long paste is long
13:33:19 <taktoa> hence why I linked a specific line :)
13:33:35 <taktoa> essentially I want to change SActorT so that it is `VCActorT (SState u st) (SMessage u msg) (WS u) ret` instead of `VCActorT (SState u st) (SMessage u msg) u ret`
13:35:06 <taktoa> the problem is that when I do that, I end up needing to convert a `VCMailbox (WS u) a` to a `VCMailbox u a`
13:35:23 <taktoa> which led me to that question
13:36:48 <taktoa> I guess my point here is that somehow my monad transformer isn't compositional
13:37:03 <mniip> fascinating
13:38:01 <mniip> should have expected that when you made a GADT a monad
13:38:48 <dsal> Heh, is there a {-# LANGUAGE * #-} ?
13:38:58 <sbrg> IIRC i read something a good while ago that used stack to directly open the relevant documenation for a module or something. does anyone know if this is possible? 
13:39:26 <taktoa> mniip: I don't think I actually use any GADTs in that code, I'm just using GADT syntax for rank-n types
13:39:38 <taktoa> (and was too lazy to type GADTSyntax instead  of GADTs
13:39:40 <taktoa> )
13:40:41 <mniip> you use associated types
13:40:45 <mniip> that amounts to pretty much the same
13:40:54 <taktoa> ah
13:40:54 <mniip> well, maybe a bit less
13:41:13 <mniip> but basically that introduces nontrivial structural equality axioms
13:41:17 <taktoa> I was under the impression that associated types don't generate constraints, since stuck type families are a thing
13:41:36 <mniip> they're not constraints
13:42:03 <mniip> well, they kind of are
13:42:13 <taktoa> oh, also, ignore the stuff in Main lol, that was a previous draft
13:42:33 <taktoa> I deleted it from the gist
13:42:37 <mniip> they're constraints as per the typechecker terminology, but they aren't of Constraint kind, they are CoAxioms
13:43:23 <mniip> realize that any GADT could be rewritten with closed type families
13:44:40 <taktoa> mniip: is that because you could replace propositional equality with a type family into Constraint that is defined as the diagonal map?
13:44:58 <taktoa> e.g.: type instance Eq a a = ()
13:45:17 <taktoa> err, the closed type family version of that
13:46:13 <mniip> I was thinking more of the
13:47:43 <mniip> C :: a -> T (F a)
13:48:06 <mniip> type family IF a where IF (F a) = a
13:48:17 <mniip> C' :: IF b -> T b
13:48:39 <mniip> hence, data T a where C :: a -> T (F a)
13:48:49 <mniip> into: data T b = C' (IF b)
13:49:06 <taktoa> huh, neat
14:08:44 <Tritlo> Hey there! Is there any flag I can pass to GHC to show me desguared do notation? I'm messing around with ApplicativeDo, and I want to see the generated statement.
14:09:14 * hackage groups 0.4.1.0 - Haskell 98 groups  https://hackage.haskell.org/package/groups-0.4.1.0 (NathanVanDoorn)
14:11:35 <MarcelineVQ> yeah but it's not to pretty   -ddump-ds -dsuppress-all
14:11:40 * hackage atom-conduit 0.5.0.1 - Streaming parser/renderer for the Atom 1.0 standard (RFC 4287).  https://hackage.haskell.org/package/atom-conduit-0.5.0.1 (koral)
14:14:15 <MarcelineVQ> you might not need suppress-all when you're just dumping ds, not sure
14:29:30 <akegalj> I am trying to figure out how to test some quickcheck properties with repl. Is there `PropertyM m a -> IO a` ?
14:29:41 <Tritlo> Thanks!
14:34:31 <akegalj> not needed above - figured it out
14:37:22 <glguy> mniip: What does this look like using closed type families? data T a where C :: T Int under that transformation?
14:38:31 <mniip> good question
14:38:33 <mniip> how about
14:39:03 <mniip> type family Z a :: Constraint where Z Int = ()
14:39:08 <mniip> data T a = Z a => C
14:40:25 <glguy> Using that you wouldn't learn the type equality inside of a pattern match though
14:41:07 <mniip> true
14:54:44 <jle`> i would have preferred an alternative syntax for ApplicativeDo
14:54:51 <jle`> to know when things are really being fired
14:55:11 <mniip> your boss usually would let you know
14:55:54 <jle`> i only found out when my key card stopped working
14:56:15 <glguy> I looked into it more deeply and I found that apparently what happened is that he was laid off five years ago and no one ever told him about it; but through some kind of glitch in the payroll department, he still gets a paycheck. 
14:56:40 <MarcelineVQ> :>
14:57:02 <MarcelineVQ> -XApplicativeStapler
14:59:38 <mniip> glguy, the financial department is using dependent types,
14:59:44 <mniip> you can't stop paying the person without telling him
15:05:08 <EvanR> without telling him, but more to the issue, without telling anyone else
15:06:06 <Gurkenglas> What's the downsides of building all of a snapshot in the global project for scripts?
15:06:20 <EvanR> floating point payroll ftw
15:08:22 <erisco> oh, you're talking about office space
15:10:41 <sm> Gurkenglas: if you don't see any, maybe none!
15:11:15 <MarcelineVQ> Gurkenglas: I'm not sure I understand what you mean by building all of a snapshot. but in the global space dependencies will be built against the resolver specified by ~/.stack/global-project/stack.yaml  or ~/.stack/config.yaml  so there is a benefit that if any of your projects use that resolver version they can share these already built things
15:11:53 <Gurkenglas> What command builds a whole snapshot? How much space/time does this take?
15:12:36 <Forlorn> What is a good starting point for learning about untyped and typed lambda calculus, with systems like system F?
15:12:38 <sm> stack install pandoc. A few G an a half an hour
15:12:52 <sm> give or take
15:14:09 <EvanR> is floating point arithmetic deterministic... in the sense that if i map f over a list of floats, to get a list of floats, x = y in the first list implies f(x) = f(y) in the second list?
15:14:19 <erisco> moral if the story is to not give a damn, irrc XD
15:14:24 <EvanR> and that means i can sanely use group or groupBy
15:14:29 <lyxia> @where tapl Forlorn 
15:14:29 <lambdabot> "Types and Programming Languages" by Benjamin C. Pierce in 2002-02-01 at <https://www.cis.upenn.edu/~bcpierce/tapl/>
15:14:41 <lambdamu_> Forlorn: I've enjoyed this: http://www.paultaylor.eu/stable/Proofs+Types.html
15:15:33 <erisco> the mundane breeds indifference, and indifference breeds perspective, and perspective breeds confidence, and that gets you promoted!
15:16:13 <EvanR> i heard of some horror stories where answers come out differently if the compiler does some stuff in float registers vs memory
15:24:11 <exio4> EvanR: I would expect that to be true
15:33:53 <EvanR> exio4: what
15:34:14 <exio4> EvanR: given x = y, for any f, f x = f y 
15:34:42 <mniip> that property has a name
15:35:24 <EvanR> being a function
15:35:35 <exio4> mniip: leibniz equality?
15:35:38 <MarcelineVQ> congruence
15:36:09 <EvanR> the first 3rd of this blog post is making me think f maybe not have that property if you compile on another machine https://randomascii.wordpress.com/2013/07/16/floating-point-determinism/
15:36:28 <EvanR> but what about within the same runtime of a single machine
15:36:59 <mniip> sorry I was thinking about the converse: injectivity and generativity
15:37:22 <erisco> what is generativity?
15:38:37 <erisco> just don't rely on floats being too accurate and you'll be fine
15:39:13 <erisco> think of floats to do tasks like guess how many ping pong balls can fit in a bus
15:39:25 <mniip> erisco, f and g are generative if f a ~ g b implies f ~ g
15:39:40 <geekosaur> EvanR, I think the same code on the same machine with the same fp options should get the same answer. But all bets are off if code gen can differ (and here you can run into trouble in, say, Java depending on JIT behavior), or if something else can change the fp options and you don't religiously save and restore said options around your computations and any time you call into a library routine not under your control.
15:39:45 <EvanR> im less concerned right now about accuracy and more about self consistency
15:40:25 <EvanR> so it is that bad
15:40:27 <geekosaur> (also you are at the mercy of OS bugs, if e.g. context switches don't precisely restore fp options. I think Linux kernels even have had bugs relating to this.)
15:40:27 <exio4> EvanR: the "intermediate precision" issue doesn't seem to apply to Haskell
15:40:36 <EvanR> no?
15:41:59 <exio4> EvanR: types avoid it in Haskell ( (a :: Double) + (b :: Double) ) :: Double, I think (if I understand the problem correctly)
15:42:14 <erisco> mniip, I see
15:42:46 <EvanR> so ghc produces float code that is convervative
15:43:09 <EvanR> conservative, in the sense that it tries to get consistent results across builds
15:43:29 <EvanR> at the expense of performance
15:43:32 <erisco> is it IEEE compatible to have different results on the same machine? that doesn't make sense to me
15:43:46 <erisco> what doesn't make sense is that the results can vary by machine at all... though I did not read the standard
15:44:04 <EvanR> there is a lot thats undefined
15:44:08 <EvanR> according to that post
15:44:33 <erisco> lol
15:45:07 <EvanR> what features your CPU has and what particular algorithm you use for transcendental functions will affect the answer
15:45:18 <EvanR> *features of the CPU you use
15:48:36 <erisco> I actually remember on WP7, or at least the hardware I was running, had a bug in Math.sin (C#)
15:49:02 <erisco> it was only correct up to the first 27 bits of a 64 bit double
15:49:15 <erisco> guess how long it took me to figure that one out? -.-
15:50:39 <monochrom> 3.14159 months. :)
15:51:43 <EvanR> i saw a sentence refer to... the correctly rounded value as if you computed the answer with infinite precision, then rounded
15:51:52 <erisco> I should say what I was doing, iirc, was bit shifting a 1 left and casting to double
15:52:07 <EvanR> which, after reading brouwer ... i am like what
15:52:23 <erisco> and 1 << 28 and beyond gave nonsense answers
15:52:26 <barrucadu> I saw a paper somewhere recently about automatically proving the correctness of C math.h functions using a novel way to figure out how much error there was.  Maybe one day we'll all have correct floating point libraries!
15:53:00 <EvanR> the key being "all" having them
15:53:15 <EvanR> else what are we even doing?
15:54:15 <monochrom> Brouwer is irrelevant because since there are only finitely many possible floating-point values there are also only finitely many correct answers.
15:54:56 <EvanR> i was questioning "the" correct answer being defined as a rounding of an infinite precision real
15:55:09 <monochrom> The job of the FPU designer is to just think up a really good algorithm that avoids a humongous lookup table.
15:55:25 <EvanR> if all values of the sine function land on an irrational, i can see how that makes sense
15:56:20 <EvanR> all values at our chosen rational arguments
15:57:27 <EvanR> is rounding technically defined in terms of digits ?
15:58:19 <EvanR> blarg
15:58:23 <monochrom> I don't see what's the problem with rational answers.
15:59:02 <EvanR> not that they are rational, but the closer the "real" answer is to an exactly representable number, the more precision you need to round properly
15:59:21 <EvanR> until its exactly on, and you may need infinite precision
15:59:38 <monochrom> If you say "I want the negation of the rational input 1/2" you will get the same -0.5 whether you do it by Platonic math or by going through "do it as though you had infinite precision, so -0.50000000000000... and then round to 54-bit mantissa".
16:00:10 <EvanR> negation is one thing, i was talking about trascendental functions
16:01:15 <Gurkenglas> Why does Data.Array's freeze need to do a full copy?
16:01:19 <monochrom> Sure, so if you do arcsin(1) you will get 54 bits of pi/2.
16:01:21 <EvanR> if you see an answer like 0.499999999999999, which way do you round
16:01:51 <erisco> Gurkenglas, so you don't mutate it later, but there is an unsafeFreeze if you want that
16:02:06 <EvanR> it doesnt really matter, except for the goal of determinism
16:02:10 <monochrom> The default rounding mode is round-to-even. There are 3 others as choosable options.
16:02:22 <Gurkenglas> I suppose that's fine enough that I'm not too incentivized to look for a better solution.
16:03:02 <EvanR> monochrom: round to even speaks of the last digit, right. and the basic operations in ieee (not sine, etc) speak of infinite precision prior to rounding
16:03:21 <EvanR> so i dont know what to believe
16:03:46 <monochrom> I think you're just overthinking this.
16:04:44 <monochrom> arcsin(1) gives 54 bits of pi/2 and it can be mentally modelled by having pi/2 in binary in infinite precision and then rounding for 54 bits.
16:05:15 <monochrom> And no, we know how to do this rounding without knowing the last digit.
16:05:32 <monochrom> Err last bit. This is not BCD.
16:05:32 <EvanR> i am glad we dont need to know the last digit of pi
16:06:00 <EvanR> but besides that, the reason you dont need to is because the number is irrational
16:06:10 <EvanR> or, known to be
16:06:28 <EvanR> some numbers have an unknown status
16:06:37 <EvanR> what does it mean to round an arbitrary real number
16:10:44 <fatroom> hi all! can somebody give me a hint with the CS homework? I got a following data structures http://lpaste.net/4994729133373128704 and need to create some operations. But i don't know how to work with the Bank type declared here, neither able to find some examples on how to work with such custom types.
16:11:40 <Axman6> fatroom: are you doing self study or taking the course?
16:11:40 <fatroom> any idea on how to operate on such thing? or at least how that properly called?
16:12:11 <fatroom> Axman my wife doing the course and asked for help.
16:14:11 * EvanR reads about table maker's dilemma
16:14:16 <Axman6> ok. That limits how helpful we can be (ie, we won't give you answers, but will help you find them yourself)
16:14:46 <Axman6> fatroom: have you worked with lists before?
16:15:01 <Axman6> (I'm happy to use "you" as a proxy for your wife too :P)
16:15:02 <fatroom> thanks, that's why i didn't posted actual task that need to be done :)
16:15:03 <Welkin> but what about chairs?
16:15:31 <fatroom> yep know about lists
16:16:02 <Axman6> ok, well a Bank is just a data type which contains a list, and that list contains zero or more ID, Account pairs
16:16:09 <fatroom> i assume there can be somehow filter applied to this structure, but got type errors
16:16:35 <Axman6> getAccounts :: Bank -> [(ID,Account)]; getAccounts (Benk accts) = accts
16:16:39 <erisco> I'll give you answers, but I can't guarantee they'll be the answers to your questions
16:17:25 <erisco> breadsticks are not a vegetable
16:17:35 <fatroom> yay, so i can unwrap this structure to list and work with the list. 
16:18:02 <fatroom> thanks!
16:19:15 <Axman6> ok, question for you, how do you go from a [(ID,Account)] to a Bank?
16:21:25 <fatroom> seems like this: Bank (getAccounts b)
16:22:01 <Axman6> well, that lets you go from a Bank to a Bank. 
16:23:45 <Axman6> if you have x :: [(ID,Account)], how do you make a Bank?
16:25:33 <fatroom> i assume like this: http://lpaste.net/4470480872558034944
16:26:50 <Axman6> yep. so, if you know how to work with lists, and you can unwrap and rewrap a Bank, then you should be good to go!
16:28:36 <fatroom> yeah, thanks! that really helpful. I got experience in bunch of other languages, but got confused by haskell datatypes and didn't thought about unwrapping and rewrapping Bank. 
16:29:50 <EvanR> are sections like (1 +) related to sections in category theory
16:29:52 <fatroom> is there other ways of working with such data structures? 
16:30:03 <monochrom> No.
16:30:17 <monochrom> I mean no to sections in category theory.
16:30:50 <Axman6> fatroom: what sort of other ways?
16:31:16 <Axman6> remember we have no mutation in Haskell, so many of the things you might use in other languages to mutate objects don't make sense
16:32:28 <crucify_me> hi why is (x:xs) -- including the head -- not needed with a list comprehension when x is used on the rhs, ie   filter p xs = [x | x <- xs, p x ]
16:32:40 <fatroom> axman6 have no idea, but this approach arise question to me why not to use lisp-style language. So I suspect that it's not really natural way of doing things in haskell. 
16:33:05 <EvanR> which aspect of lisp are you talking about
16:33:13 <Axman6> well, what you're doing is pretty close to lisp style, with different syntax =)
16:33:19 <monochrom> "Lisp" stands for many unrelated things. What does "lisp style" mean?
16:33:38 <crucify_me> whereas in recursive functions if x is used on the rhs, we need say filter p (x:xs) = ..
16:33:46 <Axman6> crucify_me: x <- xs ways "for each x in xs"
16:34:08 <Axman6> but this syntax is just using recursive functions inderneath, specifically concatMap
16:34:12 <Axman6> underneath*
16:35:18 <crucify_me> so its implicit while using the x <- xs notation Axman6 ?
16:35:45 <Axman6> you should read up on the syntax sugar that list comprehensions use
16:35:59 <dminuoso> crucify_me: list comprehensions are syntactic sugar around a more complex pattern you will later learn about
16:36:07 <crucify_me> I did, I was reading it as "drawn from" Axman6
16:36:13 <Axman6> what you've written gets turned into: filter p xs = concatMap (\x -> if p x then [x] else []) xs
16:36:49 <crucify_me> dminuoso: thanks yeah I heard its really a monad
16:37:35 <crucify_me> but in any case the argument doesn't need to be (x:xs) which is odd to me
16:38:01 <dminuoso> crucify_me: in a particular way the "x" is actually an argument of a function.
16:38:09 <dminuoso> \x -> ...
16:38:23 <dminuoso> Its just that list comprehensions look the other way around.
16:38:46 <dminuoso> Or I should be more precise. its the parameter of a lambda expression.
16:38:51 <crucify_me> so <- just peels off an x
16:39:10 <dminuoso> crucify_me: it feeds it into a function that has a parameter named x.
16:39:27 <crucify_me> good call thanks
16:39:49 <Axman6> crucify_me: you don't need to pattern match on every single list you accept as an argument. you would have got used to it because you've been reimplementing the same functions that are provided by the prelude
16:40:31 <crucify_me> Axman6: sorry not really following that
16:40:55 <Axman6> you would have written a lot of functions that look like foo [] = ...; foo (x:xs) = ... right?
16:41:13 <crucify_me> yeah..
16:41:37 <Axman6> but now you're learning how to use other functions which use lists, so you don't always need to pattern match on them like that, you just pass them to other functions
16:41:53 <dabei> hi, noob question:  how do i set a nested field using aeson lens?  
16:42:01 <dabei> What I'm trying:   myJson & _Object . at "foo" . at "bar" .~ Just (Bool True)
16:42:25 <Axman6> ah, you probably need another _Object between the ats
16:42:36 <crucify_me> thanks yeah where I saw xs sometimes I would just write list which works fine
16:42:46 <Axman6> or, you should key "foo" . key "bar" .~
16:43:16 <dabei> add _Object doesn't work
16:43:18 <Axman6> crucify_me: well, they are just names. x:xs is convention
16:43:36 <Axman6> dabei: can you give an example of what the data looks like and what you're trying to achieve?
16:43:50 <Axman6> there's lot of possibilities for what you actually want
16:44:33 <dabei> just want to set a myJson.foo.bar to a value
16:44:47 <dabei> how would you do it?
16:45:13 <Axman6> key "foo" . key "bar .~ <value>
16:45:18 <Axman6> assuming that path exists
16:45:23 <Axman6> if not, then there's more work to do
16:45:52 <dabei> it doesn't always exist
16:48:32 <kaychaks> on my zlib question earlier (sorry I went to sleep so couldnot respond) - am just nix as package manager in Mac, its just being used in place of brew. So in spite of installing zlib using that, cabal is failing to find the header file (zlib.h). Is there some specific directory that I need to include --extra-include-dirs ?
16:50:12 <geekosaur> the thing is, that may not atually be the problem. the error does say "missing (or bad)"
16:50:27 <geekosaur> and the last time this came up, the person in question never got back to me on it,.
16:50:59 <crucify_me> Axman6: actually, the distinction is not super obvious, between the list comprehension using x as an argument fed into the function, and in the recursive function where x in a predicate like say ' filter p (x:xs) | p x = x : filter p xs '  
16:51:03 <geekosaur> I think if you run cabal sufficiently verbosely, it'll show what it's trying to do and exactly what error it got back (from the C compiler, trying to use the header). And the complexity here is that zlib.h #include-s zconf.h which lives in a different place
16:51:14 <geekosaur> and if that can;t be found, cabal will claim that zlib.h is the problem
16:51:36 <dabei> Axman6: figured out a workaround, i could just set the whole bar object
16:51:39 <crucify_me> or is it the same?
16:51:48 <dabei> Axman6: thanks for the help
16:52:39 <geekosaur> (because parsing the C compiler errors to figure out that it's actually zconf.h or some other header dependency is a bit of a fool's errand. especially with fancy compiler error messages intended for humans to read but really difficult for *programs* to extract information from)
16:56:48 <kaychaks> geekosaur: ok lemme try to increase the verbosity and see the actual reason
16:59:09 <crucify_me> > filter (/= ' ') "cat dog house"
16:59:11 <lambdabot>  "catdoghouse"
17:00:43 <crucify_me> how does that work? that seems like coercion of some kind.
17:00:53 <tabemann> type String = [Char]
17:01:26 <EvanR> String is literally list of Char, no coercion or conversion required
17:02:06 <Axman6> > ['a','b','c']
17:02:08 <lambdabot>  "abc"
17:02:12 <EvanR> but there is some syntax sugar involved e.g. "cat" = 'c':'a':'t':[]
17:02:44 <tabemann> @type "cat"
17:02:45 <lambdabot> [Char]
17:02:52 <geekosaur> kaychaks, ugh ... just remembered that the time I ran into something similar to this, cabal verbosity didn;t help.Cabal *librayr* verbosity would but setting the cabal *pprogram* verbosity doesn;t help with verbosity fo the cabal *library* as used by Setup,hs --- so getting those errors out took running the Setup.hs directly and futzing around
17:02:54 <crucify_me> so that says 'filter is its True that there are spaces there'
17:03:02 <crucify_me> if*
17:03:14 <EvanR> only keep things that are not space
17:03:19 <Axman6> I want to start a movement to change the name of filter to keep
17:03:23 <EvanR> ^
17:03:35 <Axman6> and discard for filter . not
17:03:54 <crucify_me> well yeah , I would have understood it right away
17:04:39 <Axman6> if we're going to have things like otherwise = True in the prelude, I can't see why we couldn't have keep = filter
17:06:03 * EvanR attaches to Axman6's proposal comparing, on, and groupBy (three different imports right now)
17:06:27 <Axman6> urgh, yeah
17:06:28 <kaychaks> geekosaur: with verbose=3 during cabal install I got this error 
17:06:28 <kaychaks> ```
17:06:28 <kaychaks> fatal error: 'zlib.h' file not found
17:06:28 <kaychaks> #include "zlib.h"
17:06:28 <kaychaks> ^~~~~~~~
17:06:28 <kaychaks> 1 error generated.
17:06:28 <kaychaks> ```
17:06:42 <crucify_me> wait a doggone minute
17:06:46 <geekosaur> hrm
17:07:45 <geekosaur> so it is tripoing on the lib itself. but it's doing so in Setup.hs which is what actually does those tests... now I have to wonder if you're right about extra-include-dirs
17:07:45 <kaychaks> lemme try to clean up some cabal installs (global, sandbox) and try again
17:08:22 <geekosaur> but I don't know off hand if you ned to specify the niz onne or the homebrew one (be warned that compilers etc. do not usually check /usr/local/include for headers or /usr/local/lib for libraries!)
17:08:23 <crucify_me> but doesn't (/= ' ') mean 'if there are no spaces , return True  ?
17:08:31 <crucify_me> its a predicate
17:08:46 <Axman6> it returns True if the value passed to it is not ' '
17:08:54 <Axman6> > (/= ' ') 'a'
17:08:55 <Axman6> > (/= ' ') ' '
17:08:56 <lambdabot>  True
17:08:57 <lambdabot>  False
17:09:03 <geekosaur> 'if the list element currently being tested is a space, return False; otherwise True'
17:09:19 <geekosaur> then it keeps only the list elements for which the predicate was True
17:09:21 <jle`> (/=) :: Char -> Char -> Char
17:09:27 <crucify_me> excellent thanks
17:09:40 <geekosaur> and since a String is just a list of Char, this filters out all the space characters
17:09:42 <crucify_me> its sort of tricky
17:09:50 <EvanR> jle`: o_O
17:09:51 <Axman6> :t filter
17:09:53 <lambdabot> (a -> Bool) -> [a] -> [a]
17:10:05 <jle`> sorry, Char -> Char -> Bool :)
17:10:08 <EvanR> filterOut = filter
17:10:11 <tabemann> lol
17:10:23 <EvanR> filterIn = keep
17:10:32 <Axman6> no...
17:10:34 <EvanR> lol
17:10:45 <crucify_me> understood yes a work in progress
17:11:06 <EvanR> filterOutOf = ?
17:11:29 <geekosaur> kaychaks, there's also a nastiness lurking for later: if you somehow manage to get nix's zlib.h but homebrew's libz.dylib, or vice versa, (or likewise for apple's version vs. either of those), you will get a successful link but a runtime abort
17:11:41 <crucify_me> loseThisElement
17:11:48 <kaychaks> ah ok
17:12:19 <geekosaur> because zlib specifically checks at runtime library initialization for the header matching the library, because much of the zlib functionality is macros and if those macros don;t exactly match the library code you;d get core dumps or corruption
17:12:32 <geekosaur> (this is done for speed)
17:13:08 <kaychaks> am sure this issue is not a general one but specific to my env. 
17:21:48 <Gurkenglas> How hard would it be to allow libraries to define instances for other libraries without depending on them?
17:22:33 <tabemann> that's almost certainly impossible, and even if it were it'd be a horrible idea
17:22:45 <tabemann> instances should always be either where the class is defined or the type is defined
17:25:07 <Gurkenglas> I mean that the library that defines the class or the type would provide the instance (without depending on the library providing the other)
17:25:16 <Gurkenglas> (It couldn't use that instance, of course.)
17:27:01 <monochrom> So basically you write "instance X Y" without even saying which package X came from, or Y came from.
17:27:19 <monochrom> But read about Backpack.
17:27:33 <Gurkenglas> One of the two would come from your current module, you would specify the other, but that wouldn't incur a dependency.
17:36:06 <tabemann> the thing as I see it is that you would have to make a whole way of referring to things without knowing anything about them at compile-time (because they might not be available)
17:47:19 * hackage extensible-effects 2.1.0.0 - An Alternative to Monad Transformers  https://hackage.haskell.org/package/extensible-effects-2.1.0.0 (shergill)
18:47:18 * hackage intrinsic-superclasses 0.1.0.0 - A quasiquoter implementation of the Intrinsic Superclasses Proposal  https://hackage.haskell.org/package/intrinsic-superclasses-0.1.0.0 (dailectic)
18:59:41 <EvanR> one of my records now has 26 fields
18:59:49 <EvanR> still good performance
19:07:29 <butterthebuddha> Hey people, so I've been reading LYAH as part of CIS 194 (Spring 2013), but I don't feel like I'm _really_ learning anything because it's a lot of reading and not enough doing. The CIS 194 homeworks are great, but is there another list of exercises that might help me feel confident with more foreign concepts like type classes, and monoids and the like
19:14:29 <Welkin> butterthebuddha: that's a common problem
19:14:42 <Welkin> I recommend starting a project
19:15:07 <Gurkenglas_> EvanR, doesn't it have to copy 25 pointers on each mutation?
19:15:26 <Welkin> it's the only way I ever got past that stage of feeling like I can read haskell and understand the basic concepts, but was still incapable of building anything non-trivial
19:15:52 <Welkin> butterthebuddha: also, the typeclassopedia is great https://wiki.haskell.org/Typeclassopedia
19:16:09 <Welkin> you only need to read functor, applicative, monad, and monoid (and perhaps foldable and traversable)
19:16:12 <EvanR> Gurkenglas_: yes
19:16:44 <EvanR> though for this record, its only ever constructing the whole thing from scratch anyway
19:17:02 <EvanR> though^2, many fields are the same as before
19:17:07 <Welkin> butterthebuddha: as soon as you start building a real project, you will use monads, monoids, functors, and foldable a ton
19:17:22 <EvanR> traversable?
19:17:25 <Welkin> using them is a lot more helpful than reading about them
20:51:59 <isSymbolicLinkHe> Out of curiosity, how does the process of moving packages from Hackage to Stackage work? Does someone just rewrite the libraries?
20:52:34 <isSymbolicLinkHe> Because I've noticed a version mismatch between System.Directory on Hackage and Stackage (1.3.1.5 vs 1.3.0.0) respectively
20:52:57 <isSymbolicLinkHe> which is a shame because I installed Haskell using Stack, and wanted a specific function from the newest version, but Stack is behind the curve here
20:54:23 <geekosaur> no rewriting. I'm not sure why you think anything "moves" or needs to be "rewritten" or whatever
20:54:41 <smckay> i was clicking around stackage and ended up at https://github.com/fpco/stackage/#add-your-package and that seems to explain it
20:54:47 <glguy> isSymbolicLinkHe: You don't have to use stackage when you use stack
20:54:48 <geekosaur> stackage is a collection of "resolvers", each of which is a ghc version and a set of libraries compatible with that ghc and with each other
20:54:53 <smckay> disclaimer I know nothing
20:55:21 <geekosaur> you can request addition of new pckages, and they will be tested and added if compatible and their dependencies are in stackage
20:55:28 <geekosaur> note however the ghc version.
20:55:53 <geekosaur> (a) if a package comes with ghc, stackage will *always* get it from ghc. (there are very good reasons for this)
20:56:16 <isSymbolicLinkHe> oh, okay! so I just read the blurb on the github repo smckay provided, ask for the latest version of System.Directory to be accepted, and that's it?
20:56:34 <geekosaur> (b) stackage LTS releases often do not use the very latest compiler, if not all the packages in the LTS resolver are compatible wiht the most recent ghc
20:56:46 <geekosaur> there is also a nightly resolver, which often does match the latest ghc
20:56:50 <glguy> isSymbolicLinkHe: You don't have to do anything; the directory package will be added to the next resolver when it's ready
20:57:04 <geekosaur> and iwll therefore have the version of directory that comes with that ghc
20:57:22 <smckay> sounds like the haskell analogue of a linux distro
20:57:27 <isSymbolicLinkHe> got it, but in the meantime, if I want something from the latest version of System.Directory, I will have to wait until that happens?
20:57:36 <geekosaur> smckay, that's kinda the idea, yes
20:57:44 <geekosaur> isSymbolicLinkHe, you can use overrides in stack.yaml
20:57:50 <glguy> No, you just add the versions you want to extra-deps in your stack.yaml
20:58:03 <geekosaur> (with care; overriding a library that comes with ghc can for example break Template Haskell)
20:58:25 <isSymbolicLinkHe> geekosaur: thanks for the explanation! I didn't really know how discrepancies with Hackage and Stackage were handled, hence the question
20:58:31 <geekosaur> (I think directory is safe in that regard though, especially for a minior version update)
20:58:32 <isSymbolicLinkHe> and oh, perfect! that's an easy fix
20:58:48 <isSymbolicLinkHe> thanks, geekosaur, glguy, and smckay!
21:00:25 <smckay> now I have a question! is conduit good? I want to do a thing to learn haskell involving DB and HTTP, and it fits a pipeline model pretty good
21:00:47 <smckay> but that means I would rather not use something that turns out to be tricky once you get to nontrivial stuff
21:02:00 <smckay> like will I need to learn about monad transformer field theories before I can get a URL from MySQL, fetch it, parse it, and put it back in the DB
21:02:36 <EvanR> you do not need all that to do that
21:03:49 <EvanR> e.g. there is mysql-simple to do the interaction with the db
21:04:19 <EvanR> wreq can do the request
21:04:29 <EvanR> and whatever parser libs you need can do the parsing
21:06:17 <smckay> sure that will bang a thing together but very quickly I will want to do different parsing, probably plug in other stages, etc. requirements change for hobby projects too and I don‚Äôt want to rewrite everything to change one thing
21:06:51 <EvanR> doing it with just IO is how you avoid having to rewrite it all :)
21:07:14 <EvanR> because you end up disagreeing or becoming frustrated with the monstrous framework you buried yourself with
21:08:45 <EvanR> a big transformer based system may make sense once you decide on a clearly defined interface, but if you think its all going to change use less global glue
21:13:14 <smckay> I can block out the dataflow well enough (this sort of thing is my day job more or less) so I can define stable inputs and outputs for each stage. it‚Äôs only that I‚Äôll want to swap out implementations
21:13:53 <EvanR> if you are operating on streams in weird ways, then pipes, conduit, maybe machines exists
21:14:46 <EvanR> but get one url from a db, do one request, parse the content in its entirety to get a thing to stuff back in a database (all at once), isnt really that
21:15:01 <EvanR> i know in java there are frameworks which want *that* to be all pipelined, but it makes no sense
21:15:42 <EvanR> that workflow makes way more sense as a monad with steps and error handlers
21:16:01 <EvanR> (which IO is)
21:16:22 <EvanR> haskell has a billion ways to swap out implementations, pipes is not the only way
21:18:04 <smckay> ok cool, I won‚Äôt try to use fancy libraries yet :) yes I‚Äôm a Java programmer, and the first step in starting a project is always ‚Äúfind the applicable libraries‚Äù
21:18:34 <smckay> oh and I do want things pipelined because buffering a 5GB response isn‚Äôt really practical
21:18:52 <EvanR> you might find that using the libraries i named, and combining them in IO, (and generally using proper FP principles) will get you something that makes way more sense than bare java
21:19:14 <smckay> maybe not in a ‚ÄúI need a library for this‚Äù way but streaming yeah
21:19:24 <EvanR> i see, then you might be right
21:20:54 <EvanR> there are pipe-ified and conduit-ified versions of many packages, adapters to use them with pipes and conduit respectively
21:21:33 <EvanR> what sort of data is the 5GB
21:21:45 <EvanR> is it ammenable to incremental processing
21:22:15 <smckay> yes or else I‚Äôd be screwed ;) xml, json, that sort of thing
21:22:22 <EvanR> json o_O
21:22:38 <EvanR> good luck
21:23:03 <boj> 5gb of json? o.O
21:23:09 <smckay> object-per-line, 5GB file
21:23:21 <boj> ah
21:23:31 <EvanR> lucky
21:23:47 <EvanR> you can use a line-ifier pipe
21:26:14 <smckay> if I wasn‚Äôt so lucky, are there any libraries that produce a stream of json tokens?
21:26:51 <boj> there's a nice pipes-aeson library
21:27:03 <boj> streaming + json parsing
21:27:32 <EvanR> hmm https://github.com/ondrap/json-stream
21:28:06 <boj> interesting
22:18:44 <xacktm> I set up a cabal sandbox in a different directory then moved it, and when I try to `cabal run` it's missing packages, but when I move it back it works.  Can I somehow reconfigure the cabal project so that it finds the sandbox packages in the new place?
22:19:15 <geekosaur> you have to edit the package.conf files to include the new paths, and then cabal sandbox hc-pkg recache
22:19:17 <Welkin> in your cabal sandbox config file you would need to change the directory it points to
22:19:23 <geekosaur> also that, yes
22:19:38 <xacktm> all right, thanks!
22:19:54 * geekosaur generally symlinks instead of moving, but arguably that is a different use case
22:20:41 <geekosaur> also there's some work going on which will hopefully allow for properly relocatable packages in the future. (requires changes to ghc since it uses those files directly itself)
22:49:06 <sebastian___> Is there any way, using ExistentialQuantification or GADTs or anything else of that ilk, to store in a list many pieces of data that contain a function (a -> b) and a source `a`, for all a, and be able to then apply the function to each source afterwards?
22:50:11 <Welkin> `forall a` on the datatype, or the function?
22:51:25 <sebastian___> That might sound like a riddle. This pseudo, non-working code might be clearer: http://lpaste.net/360216
22:52:38 <sebastian___> Welkin: does the paste help clarify?
22:53:40 <Welkin> have you tried something already?
22:53:55 <Welkin> generally you don't add restriction on the data declaration, but I belive you can
22:54:25 <Welkin> you would add the forall to the function only
22:55:05 <Welkin> (which is already there implicitly)
22:55:50 <cocreature> sebastian___: what are you actually trying to do? lazyness means that you can just store the "b" and it will only be evaluated if you actually use it
23:01:32 <cocreature> sebastian___: you can technically do this using existentials http://lpaste.net/360217 but unless you have a good reason for not doing so, just store a list of [result]
23:06:01 <jle`> sebastian___: it's possible but yes you should really consider why you want to do this
23:06:41 <jle`> @let data MkRes a = forall s. MkRes s (s -> a)
23:06:42 <lambdabot>  Defined.
23:06:53 <jle`> MkRes is essentially the same thing as Identity
23:07:09 <jle`> they are isomorphic for the most part
23:07:18 * Axman6 prefers using GADTs when writing types like that
23:07:36 <jle`> @let toMkRes :: Identity a -> MkRes a; toMkRes (Identity x) = MkRes x id
23:07:38 <lambdabot>  Defined.
23:07:55 <jle`> @let fromMkRes :: MkRes a -> Identity a; fromMkRes (MkRes x f) = Identity (f x)
23:07:57 <lambdabot>  Defined.
23:08:02 <jle`> ismorphic :)
23:08:11 <sebastian___> jle` cocreature Welkin: Sorry, I walked away for a moment there. What I'm making is an actor system, with actors and mailboxes. Actors need to read from and send to mailboxes, and potentially read from multiple heterogenously typed mailboxes with adaptor functions to bring them all into a single event type for the actor to consume
23:09:15 <sebastian___> Now, I want my spawnActor function to be able to take a list of SourceMailboxes actorInputMessageType, a product of the Mailbox (source) and an adapter function to bring that source to actorInputMessageType
23:09:35 <sebastian___> but I can't, since the adaptor functions don't all have the same type, even though they're all trying to get to the same result
23:11:07 <sebastian___> instead, so far, I'm making (Input1 s2 (s2 -> msg), Input2 (Mailbox s1) (s1 -> msg),... ) and so on, but that really kind of sucks
23:11:26 <cocreature> sebastian___: so why can‚Äôt you just store the result of applying the adapter function to the mailbox source?
23:11:30 <sebastian___> whoops, I got my numbers on s1 and s2 backwards there. Hopefully you see what I mean
23:12:00 <jle`> sebastian___: if you have something that works, can you show us some code
23:12:31 <sebastian___> cocreature: I can't partially apply, because these are abstracting Unagi.Chan broadcast Chans that have to be dupChan'd inside the actor spawn
23:12:43 <sebastian___> jle` sure, let me take a look and curate that mess for a moment
23:13:26 <jle`> sebastian___: i think cocreature doesn't mean partially apply, but rather *fully* apply
23:14:04 <cocreature> it sounds like you don‚Äôt want to store arbitrary source types but your source is always "Chan a" for an arbitrary a
23:14:18 <sebastian___> jle` dupChan-ing is a dangerous operation here, and I've thus-far kept it from being the responsibility of users of this nascent library
23:14:25 <sebastian___> I would like it keep it that way if possible
23:16:55 <sebastian___> jle`: & cocreature: I wasn't going to show anyone this library for a while, but here's the core copied out for you to see: http://lpaste.net/360218
23:17:43 <sebastian___> I'm trying out implementing the Elm architecture (sort of) as a server-side actor framework... it's very naive at the moment
23:18:27 <sebastian___> The Inflow and Outflow modules denote input and output wrappers for mailboxes with adapters
23:18:43 <sebastian___> Those are what I would like to put in a list and be able to do what I do in `two2One` with them
23:24:46 <sebastian___> let me know if you're feeling a little TL;DR, it's really only about a couple parts there
23:28:00 <jle`> what parts of the type do you want to "hide"?
23:29:32 <sebastian___> jle` I want to be able to have the signature of the second parameter of two2One generalize from (Intake i1 input, Intake i2 input) to [Intake input] or something like that
23:29:58 <sebastian___> I would then like to apply that to the Outflows as well, which are slightly different in their signature, but I would like them to be [Outflow output]
23:43:12 <cocreature> sebastian___: this is only a very rough sketch (don‚Äôt have time for more atm) but how about something like http://lpaste.net/360219
23:48:22 <zephyz_> Hi, Is there a way to combine two parsers with different stream types with Parsec?
23:49:23 <zephyz_> I have a parser that takes a stream of Token and parses a string, and I would like to combine it with a parse that takes a string as input and output an AST 
23:49:24 <rightfold> zephyz_: What does combine mean?
23:50:06 <zephyz_> rightfold using the parsed output of a parsed instead of using the rest of the stream
23:50:25 <zephyz_> output of a parser*
