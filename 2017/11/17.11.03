00:00:25 <truffle> is there a newsletter I can subscribe to when such changes happen?
00:01:02 <Lokathor> https://haskellweekly.news/ ?
00:01:30 <geekosaur> at one point there was a ghc weekly too
00:01:36 <yushyin> ghc changelog?
00:02:13 <truffle> where would the proposals for design changes in the language be posted ?
00:03:24 <yushyin> maybe haskell prime bug tracker?
00:06:09 <geekosaur> haskell prime is for the language standard. most changes in the language start out iin ghc-proposals
00:06:22 <geekosaur> since the standards body won't consider it without a working implementation
00:06:39 <truffle> would i be correct in assuming that design changes occur as a consequence of bugs ?
00:06:46 <geekosaur> https://github.com/ghc-proposals/ghc-proposals
00:07:24 <geekosaur> you would not; ghc is also a playground for type theory, and most design changes are in support of experiments with the type system
00:08:16 <geekosaur> although in the case of FTP, it is arguably a correction to an earlier change: Haskell 1.4 and earlier were more polymorphic than Haskell 98
00:08:48 <geekosaur> (although neither Foldable nor Traversable *as such* existed back then; the polymorphism was more limited.)
00:09:48 <geekosaur> AMP could be argued as a bug fix, except that Applicative didn't exist when Monad was codified
00:12:07 <truffle> ah lots of things I don't understand. just starting out . thanks for being patient 
00:15:24 <jcarpenter2> i see all these nice constructors for creating Html values with content in them: https://hackage.haskell.org/package/blaze-html-0.9.0.1/docs/Text-Blaze-Html5.html
00:15:37 <jcarpenter2> but does anybody know how to create an empty Html value using blaze?
00:17:24 <geekosaur> I see a Monoid instance when I dig down through the types, so presumably mempty would work
00:17:57 <jcarpenter2> neat, that works
00:37:50 <cocreature> any ideas for a nice generalization of http://lpaste.net/359762 ?
01:04:48 <pranz> cocreature: pairwise f xs ys = all (uncurry f) $ zip xs ys
01:05:45 <cocreature> pranz: that’s not the same. if the lists don’t have the same length your solution returns True while I want False
01:05:47 <MarcelineVQ> that doens't fit pattern 2 and 3, this function can only succeed on equal sized lists
01:05:54 <jcarpenter2> :t (,)
01:05:56 <lambdabot> a -> b -> (a, b)
01:06:00 <jcarpenter2> woooooot
01:06:03 <jcarpenter2> thanks, haskell
01:06:29 <pranz> ah yeah that's true
01:07:32 <jcarpenter2> haskell is replete with good stuff
01:08:23 <MarcelineVQ>  \p xs ys -> and (zipWith p xs ys) && length xs == length ys  is a bit silly though    what if you made  zipWithSame :: (a -> b -> c) -> [a] -> [b] -> Maybe c    a zipWith that returns Nothing on uneven lists
01:08:51 <MarcelineVQ> Though I bet there's a 'lens' for equal lists, there's every other kind
01:08:56 <cocreature> heh
01:09:05 <cocreature> yeah I guess the zipWithSame solution is fine
01:20:39 <ertes-w> helo
01:20:56 <MarcelineVQ> ertes-w: hello, <cocreature> any ideas for a nice generalization of http://lpaste.net/359762 ?
01:21:06 <ertes-w> Lokathor: so you want to make a real-time game instead?
01:21:25 <MarcelineVQ> Lokathor: interesting find today http://hexagoxel.de/postsforpublish/posts/2017-10-30-brick-plus-reflex.html
01:22:51 <ertes-w> cocreature: generalisation of which aspect?
01:23:05 <ertes-w> you could easily go from [] to Foldable
01:24:25 <cocreature> ertes-w: I was more thinking about generalizing the Bool but I’m not sure what abstraction fits here
01:25:48 <ertes-w> cocreature: one generalisation i can think of is:  (Monoid m) => (a -> b -> m) -> [a] -> [b] -> m
01:26:09 <cocreature> ertes-w: I don’t think that works. Monoid doesn’t give me both True and False
01:26:42 <ertes-w> @let pairwise f xs ys = fold (zipWith f xs ys)
01:26:44 <lambdabot>  Defined.
01:27:03 <ertes-w> > pairwise (\x y -> All (x == y)) [1,2,3] [1,2,3]
01:27:05 <lambdabot>  All {getAll = True}
01:27:11 <ertes-w> > pairwise (\x y -> All (x == y)) [1,2,3] [1,2,4]
01:27:13 <lambdabot>  All {getAll = False}
01:27:22 <ertes-w> > pairwise (\x y -> Any (x == y)) [1,2,3] [1,2,4]
01:27:24 <lambdabot>  Any {getAny = True}
01:27:29 <cocreature> pairwise (\x y -> All (x == y)) [1] []
01:27:29 <ertes-w> cocreature: ^ that's what i was thinking of
01:27:32 <cocreature> > pairwise (\x y -> All (x == y)) [1] []
01:27:34 <lambdabot>  All {getAll = True}
01:27:41 <cocreature> doesn’t fit
01:28:04 <ertes-w> true
01:28:22 <ertes-w> need an extra "different lengths" parameter
01:28:30 <ertes-w> or filler values
01:28:59 <cocreature> I guess "alignWith" is a generalization
01:29:18 <cocreature> :t alignWith
01:29:19 <lambdabot> error: Variable not in scope: alignWith
01:29:22 <cocreature> damn you lambdabot 
01:29:27 <ertes-w> @let import Data.Align
01:29:27 <lambdabot>  .L.hs:66:1: error:
01:29:27 <lambdabot>      Could not find module ‘Data.Align’
01:29:27 <lambdabot>      Perhaps you meant Data.Aeson (from aeson-1.2.1.0)
01:29:35 <cocreature> % import Data.Align
01:29:35 <yahb> cocreature: ; <no location info>: error:; Could not find module `Data.Align'; It is not a module in the current program, or in any known package.
01:29:39 <cocreature> :(
01:30:06 <ertes-w> well, alignWith is less a general tool than an "implement your semantics here"
01:30:24 <cocreature> yeah
01:30:43 <cocreature> *shrug* it’s not like I need a generalization, I was mostly just curious if I’m missing something obvious here
01:31:12 <ertes-w> whenever i think of generalising Bool i think of Monoid or Alternative
01:31:34 <ertes-w> or sometimes Plus from semigroupoids/Data.Functor.Plus
01:31:59 <nshepperd_> > over (zip_ . traverse) swap ("abc", "defgh")
01:32:01 <lambdabot>  ("def","abcgh")
01:32:26 <nshepperd_> :t zip_
01:32:28 <lambdabot> Functor f => ([(a1, a2)] -> f [(a1, a2)]) -> ([a1], [a2]) -> f ([a1], [a2])
01:32:49 * nshepperd_ had to go and write that lens
01:37:03 <nshepperd_> > over zip_ reverse ("abcd", [1..])
01:37:05 <lambdabot>  ("dcba",[4,3,2,1,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,2...
02:22:15 <cocreature> huh why is there no Unbox instance for Ratio
02:30:02 <ertes-w> cocreature: probably because nobody uses Ratio with anything but Integer =)
02:30:36 <cocreature> it still seems silly to provide an instance for Complex but none for Ratio
02:32:01 <ertes-w> i guess there is no technical reason
02:49:28 <jchia> I have a data type Foo which in practice has many constructors. The first constructor argument is always Int. I want a simple way to get it. Can I improve? Is it better to use Generics? http://lpaste.net/359765
02:50:51 <merijn> jchia: "many" to a degree where just writing them out once is impractical?
02:51:35 <jchia> merijn: In practice at least 10. Trying to avoid boilerplate. On a related not, I also need a way to set the Int, but it's not in the code.
02:51:44 <jchia> "related note"
02:51:50 <ski> jchia : factor it like `data Foo = MkFoo Int ABC; data ABC = A Char | B Double | C [Int]' ? (`Int * Char + Int * Double + Int * [Int] = Int * (Char + Int + [Int])' is the factoring)
02:52:24 <merijn> jchia: With 10ish I would probably either just suck it up and write it out or refactor ala ski's suggestion
02:56:25 <jchia> Using gmapQi is probably type-unsafe in that the presence of the first-argument Int is not guaranteed at compile-time, but I'm wondering if I can do better with Generics.
02:56:50 <jchia> (I could make a mistake in defining Foo and have a constructor where the first argument is not Int.)
02:57:15 <jchia> ski's way works, but introduces some syntactic noise
02:57:21 <merijn> jchia: honestly, I try and avoid writing Generic code by hand if possible, it's always rather painful
02:57:45 <merijn> jchia: Well, you could abuse pattern synonyms to hide the fact that you now have two constructors
02:57:55 <merijn> jchia: But then you end up having to write out all those cases again
03:20:58 <ertes-w> jchia: i'd go with ski's factored version
03:21:26 <ertes-w> as for setting the Int, that version makes it trivial
03:21:56 <cocreature> jchia: fwiw the generics-sop code for this is actually not so bad http://lpaste.net/359766
03:22:04 <ertes-w> in other cases it's useful to know that you can share field names between constructors, as long as the types are the same
03:22:58 <ertes-w> @let data Blah = BlahA { blahId :: Int, blahA :: Double } | BlahB { blahId :: Int, blahB :: String } | BlahC { blahId :: Int, blahC :: Rational }
03:23:01 <lambdabot>  Defined.
03:23:30 <ertes-w> @let deriving instance Show Blah
03:23:32 <lambdabot>  Defined.
03:23:35 <ertes-w> > (BlahB 5 "blah") { blahId = 7 }
03:23:37 <lambdabot>  BlahB {blahId = 7, blahB = "blah"}
03:25:51 <merijn> I don't suppose that GHC is smart enough to realise that if I have a GADT and one pattern with a specific return type and then a wildcard pattern that the wildcard can't match the other pattern?
03:50:46 <merijn> :(
03:51:07 <merijn> GHC y u so sucky at case analysis ?!?
03:51:37 <jchia_> cocreature, ertes-w: Thanks. Sharing field names looks like it'll solve the problem. I'm going to check out what generics-sop is about.
03:51:51 <merijn> I don't wanna write out the same code 5 times because you suck at determining things can'thappen :(
03:55:11 * merijn sigh
03:55:23 <merijn> I can't even extract the duplication into a separate function...
04:08:31 <dysfun> can i get haskell-mode to not error out on unimplemented functions but just check the type consistency for me without having to construct a typeclass?
04:22:25 <verlet64> Morning!
04:32:39 <cocreature> merijn: are you on a somewhat recent version of GHC? iirc it has gotten a lot better in 8.0 and there might be more improvements in 8.2
04:42:32 <the_2nd> Will the Haskellbook.com come out as print version? If so, when? Will the ebook purchase make the book cheaper?
04:44:12 <ventonegro> the_2nd: I saw a tweet once with a photo of a preprint, but it was never mentioned again
04:44:30 <ventonegro> And it was huge...
04:51:26 <merijn> cocreature: I'm using 8.0
04:51:43 <merijn> the_2nd: It won't be printed due to being too long
04:53:00 <ertes-w> dysfun: what do you mean by "unimplemented"?
04:53:29 <dysfun> ertes-w: i mean i would like to write a load of function type signatures and no implementations and have the consistency checked
04:54:10 <merijn> cocreature: Basically, I have a GADT where 1 constructor has type "None :: Foo '[]" and all the others have "Foo (h ': t)", but when I write a function "foo None = ...; foo p = {- code that requires "h ': t" here -}" then the it will complain about the fact that it doesn't typecheck for cases where the type is "Foo '[]", which obviously can't happen since those are caught by the first case
04:54:25 <merijn> cocreature: So I end up having to write out all the constructors by hand with an identical body :\
04:54:55 <ertes-w> dysfun: unfortunately GHC itself doesn't support that
04:55:06 <ertes-w> dysfun: my approach is to use holes
04:55:10 <ertes-w> f = _
04:55:27 <dysfun> that'll still result in haskell-mode complaining, won't it?
04:55:30 <merijn> dysfun: ^^ use holes like that
04:55:31 <ertes-w> dysfun: with -fdefer-typed-holes
04:55:35 <dysfun> aha
04:55:36 <merijn> dysfun: You can disable the warning
04:55:43 <dysfun> perfect, thanks
04:56:03 <ertes-w> dysfun: it's just a warning, so you can still load and run your code
04:56:10 <hpc> you'll need at least /some/ of an implementation ie to show the relation between f :: a and g :: b
04:56:16 <merijn> ertes-w: You can disable the warning too
04:56:21 <the_2nd> merijn, you know for sure there won't be a print? How so?
04:56:28 <merijn> ertes-w: -fno-warn-typed-holes
04:56:35 <dysfun> a little bit is fine, i just don't want to have to write all of it out
04:56:46 <dysfun> i'm trying to use haskell as a poor man's proof checker
04:56:50 <merijn> the_2nd: That's what bitemyapp said last I saw it talked about
04:56:58 <ertes-w> dysfun: why don't you use a real one?
04:57:17 <dysfun> ugh, sounds tedious to learn
04:57:32 <dysfun> i have done a little agda, but it goes beyond what i need
04:58:45 <ertes-w> dysfun: honestly i'd rather climb that learning curve than deal with haskell's lack of dependent types and logical consistency
04:59:03 <dysfun> hah
04:59:25 <hpc> idris maybe?
04:59:36 <dysfun> could work
04:59:45 <dysfun> easier to learn than coq, anyway
04:59:49 <hpc> although if all you're trying to do is get slightly better than what a typical haskell program gives you, i don't see anything wrong with staying in haskell
05:00:11 <hpc> once you need more than slightly, idris is probably the way to go, if you can deal with the relative lack of libraries
05:00:36 <dysfun> in this case, i can, since i want the proof more than the program
05:00:42 <ertes-w> sadly neither agda nor idris are really practical for proofs
05:01:10 <ertes-w> i bit the bullet and learned coq
05:01:26 <dysfun> hrm
05:01:34 <dysfun> i tried a little, but it made my brain hurt
05:02:30 <ertes-w> it's really just an awkward agda, but it does have tactics and generally a lot of inference stuff built in
05:02:32 <hpc> coq's tactics feel too far removed for me
05:03:02 <hpc> although i haven't gotten nearly as far with coq as i have with agda
05:03:17 <ertes-w> agda also has that horrible hooooorrible universe system where a functor takes six universe arguments
05:03:35 <dysfun> i think coq would certainly be quite enlightening if i took the time to learn it properly
05:03:52 <ertes-w> coq is awful…  i hate it…  but at least i can get my proofs done
05:04:44 <ertes-w> it's just super-handy to say "ring" and have coq fully infer the proof from the ring laws
05:26:07 <michalrus> Is this style OK? `(cancel `traverse_`) =<< readTVarIO pingTimeoutKiller`?
05:26:48 <phadej> why not: `traverse_ cancel =<< ...` ?
05:26:59 <michalrus> Oh. ♥
05:27:10 <michalrus> Wonderful, thanks!
05:28:21 <phadej> (FWIW, you'd probably want to read the contents into var, then cancel, and then use "what I have just canceled" to change tvar contents
05:29:43 <michalrus> Mhm! But what I have just cancelled is irrelevant, I think, as `pingTimeoutKiller :: TVar (Maybe (Async (IO ())))`.
05:30:04 <michalrus> I don’t like that really, but the WebSockets lib kind of enforces that, I think.
05:30:46 <michalrus> I mean, they want me to supply an onPong callback until there’s a Connection available. And they don’t supply current Connection to that handler. =(
05:31:34 <phadej> ah, it's in Maybe (and not e.g. []), when then it's indeed simpler.
05:31:39 <michalrus> Mhm. :)
05:31:41 <michalrus> Also, ping timeout kept under control (not left to kernel) seems like a usable thing to have in a websockets lib.
05:36:24 <merijn> Ah...the one true solution to GADT problems...throwing more GADTs at it
05:41:32 <ertes-w> michalrus: if you could just use withAsync that would be a lot better than maintaining asyncs in a TVar
05:43:20 <michalrus> Uh-huh. :( I don’t think that’s possible, unfortunately, if you look at the API here: https://hackage.haskell.org/package/websockets-0.12.2.0/docs/Network-WebSockets.html#t:ConnectionOptions
05:43:56 <michalrus> I need to supply `connectionOnPong :: !(IO ())` even before any connection is there.
05:49:03 <ertes-w> michalrus: you want to cancel a timeout thread on pong?
05:52:18 <michalrus> Yes. So first I `WebSockets.forkPingThread tmout`, then in `WebSockets.connectionOnPong`, I start an Async that will destroy the connection after (2*tmout), and `cancel` the previous Async.
05:52:36 <michalrus> This works, but feels hacky. But what else can I do with that WebSockets API?
06:19:57 <inkbottle> GHCI, let a = [1..10], then take 3 a, then :sprint a, yields a = _. Shouldn't that be a = 1:2:3:_?
06:20:45 <merijn> inkbottle: I have a suspicion
06:20:53 <MarcelineVQ> it would be with [1..10 :: Int] but typeclass polymorphic values are alittle mor ealoof
06:21:05 <merijn> inkbottle: Can you try: "let a :: [Int]; a = [1..10]" and then repeat the rest?
06:21:05 <MarcelineVQ> :t 1
06:21:07 <lambdabot> Num p => p
06:21:16 <inkbottle> OK, I do that
06:21:47 <merijn> inkbottle: Basically, unlike regular code ghci has the MonoMorphismRestriction disabled and you're seeing exactly why the MMR exists :)
06:24:04 <inkbottle> merijn: MarcelineVQ: Thanks, this version works
06:27:34 <cocreature> mmr is one of those things where I’m not sure if enabling or disabling it confuses people more
06:28:41 <merijn> cocreature: Enabling is guaranteed to give compile time errors in "error" conditions, whereas disabling will silently do the "wrong thing"
06:31:14 <cocreature> good point
06:31:34 <merijn> Which is I always advocate against disabling it
06:31:51 <merijn> (on the ghci prompt disabling is ok, but for source shouldn't be done, imho)
06:40:13 <cmotoche> Hello. Is it possible to build a library with an external compiled dependency? For instance, I have: ".stack/programs/x86_64-linux/ghc-tinfo6-nopie-8.0.2/lib/ghc-8.0.2/process-1.4.3.0/" compiled, but I'm getting an error while I try to build that dependency from my local project. So I'd like to use that compiled library in my project so stack don't try to compile it again and fail.
06:42:05 <cocreature> if stack doesn’t reuse a dependency it has already built there is generally a reason for why it doesn’t do so
06:42:21 <cocreature> so even if you could trick it into using it, it probably won’t work
06:42:31 <cocreature> cmotoche: what’s the error you’re seeing when building that dependency?
06:44:59 <cmotoche> cocreature, This is the error I get: http://lpaste.net/359767
06:54:33 <cmotoche> cocreature, I could solve the issue following this github issue thread: https://github.com/commercialhaskell/stack/issues/2712
06:54:45 <cmotoche> cocreature, Thanks anyway.
06:55:52 <cocreature> cmotoche: glad you were able to figure it out!
07:01:59 <mickdekkers> Hello! I'm working on designing and implementing a DSL and I'm wondering if anyone knows any resources I could check out to learn more about this and language design in general. I'm not actually using Haskell for this yet, but I've heard it's frequently used to implement DSLs so I thought I'd try asking here.
07:02:36 <cocreature> does aeson still have no way to decode from Text? I thought they added that when they added encoding to Text but I can’t find it
07:04:48 <merijn> mickdekkers: Depends, what kinda things do you have in mind? Will it be a typed language? How complex? Are you in a hurry or is this a long term project?
07:05:14 <merijn> mickdekkers: Also, do you know any Haskell-like language? (F#, OCaml, SML, Swift, etc.)
07:05:18 <MarcelineVQ> cocreature: FromJSON has Text, idk how far that gets a person
07:05:56 <mickdekkers> merijn: I've actually mostly completed the initial implementation of my DSL in JavaScript using Nearley.js https://nearley.js.org/ and I've mostly just got some questions about terminology so I can refactor more intelligently. I intend to port it to Haskell as well once I work the kinks out in my initial JS implementation.
07:05:56 <cocreature> MarcelineVQ: I’m looking for "decodeText :: FromJSON a => Text -> a"
07:06:29 <mickdekkers> It's a fairly simple language similar to DOT/Graphviz. It's a side project of mine so there's no hurry :)
07:07:38 <merijn> mickdekkers: The only resource I know about language design might be a bit overkill for that. In general implementing parsers/ASTs in Haskell is rather simple, so in that sense it's good for experimenting with those kinds of things
07:08:48 <mickdekkers> I've been learning Haskell through the Learn You a Haskell book and I'm at a point I understand most of the syntax. I'm not very familiar with the libraries/packages on offer yet though.
07:10:24 <merijn> mickdekkers: If you're interested in languages/language design I always recommend "Types and Programming Languages" by Pierce which is all you ever wanted to know (and more) about writing type systems for you language (including examples, etc.)
07:11:37 <merijn> mickdekkers: I don't really know of much for simple languages, though
07:11:44 <mickdekkers> merijn: so far I've created a parser that takes the raw text as input and produces an AST. I've also got a separate piece of code that reads that AST and produces a series of instructions to perform. Then I have a piece of code that actually executes these instructions.
07:12:04 <mickdekkers> I'm not really sure what the proper terminology for the latter two would be though 
07:12:20 <mickdekkers> Where does the parser end and the interpeter begin? :p
07:12:27 <merijn> mickdekkers: Eh, "compiler" and "interpreter"? :p
07:12:34 <cocreature> the parser ends with the AST
07:12:56 <merijn> "code that takes an AST and produces a series of instructions" <- that's pretty much the definition of a compiler :p
07:13:09 <mickdekkers> merijn: Oh, I suppose that makes sense haha. I hadn't really stopped to think whether my language is compiled
07:13:36 <mickdekkers> cocreature, thanks, that makes sense!
07:13:53 <cocreature> mickdekkers: just make sure you don’t end up calling it a transpiler or merijn will hunt you down
07:14:04 <merijn> ^^ that
07:14:06 <mickdekkers> also, is an AST a form of "intermediate representation"?
07:14:14 <merijn> mickdekkers: Yes
07:14:14 <mickdekkers> transpiler is source to source, right?
07:14:23 <merijn> mickdekkers: All compilers are source to source >.<
07:14:42 <merijn> Just sometimes that target source happens to be assembly
07:14:53 <mickdekkers> huh, that makes sense I suppose
07:18:27 <mickdekkers> Thanks for clarifying these things, I appreciate it :)
07:20:25 <greymalkin> merijn: Where does binary (not assembly) fit into the philosophy?
07:21:56 <mnoonan> can I interest you in my compiler-to-haskell-gloriously 'chg'? it takes machine code as input and compiles it to Haskell2010.
07:24:45 <merijn> greymalkin: That's produced by assemblers
07:25:04 <merijn> mnoonan: That'd be cool, tbh
07:25:38 <mnoonan> merijn: agreed :)
07:33:15 <mickdekkers> merijn: so just to clarify: even if a language is compiled instead of "interpreted", the thing that actually executes the instructions is still called an "interpreter", right?
07:34:27 <merijn> mickdekkers: It depends on your point of view. Generally we call languages "interpreted" when they are interpreted in software, rather than hardware. Since realistically, CPU are just hardware interpreter for machine code.
07:36:23 <merijn> Anyone know which GHC version added Coercible?
07:41:10 <ertes-w> merijn: GHC 7.8, base 4.7
07:42:01 <merijn> Drat
07:45:43 <kuribas> So what exactly can clojure solve that static types cannot?  I've been following the discussion on reddit but none of the points make sense to me.
07:46:03 <kuribas> (perhaps because I never used jason in haskell).
07:46:04 <merijn> kuribas: Nothing
07:46:17 <mickdekkers> Alright. In my case, executing instructions consists of starting an executable with specific command line arguments
07:46:30 <merijn> kuribas: I mean, you could just as easily turn all your types into Dynamic/Typeable and pretend you're doing dynamic programming in Haskell
07:47:10 <mnoonan> kuribas: I've found it really confusing, too. that said, I've never used clojure (but I have used other lisps and schemes quite a bit)
07:48:14 <kuribas> One of the examples was row types, for example personal data, and then data than may vary.  Which I believe can be easily done with (data Person a = ...), where a is extra data.
07:48:56 <kuribas> mnoonan: right, I've used scheme, and there's nothing that I cannot do in haskell, except perhaps macros.
07:49:46 <mnoonan> I feel like I get 90% of the benefit of macros just from lazy evaluation anyway
07:49:55 <ertes-w> kuribas: what a dynamically typed programmer means by "row types" is HashMap Text Dynamic
07:50:14 <ertes-w> haskell has that, as i just demonstrated
07:50:17 <kuribas> ertes-w: lol
07:52:40 <kuribas> or a datatype where all fields could be missing, which can be done easily by setting every field to Maybe.
07:52:48 <ertes-w> all arguments against static types in favour of non-static types are ultimately bullshit…  proof: static typing is a superset of non-static typing in terms of features…  "dynamic typing" is a degenerate special case of static typing, where you only use a single type, in haskell's case Dynamic
07:53:07 <merijn> ertes-w++
07:55:41 <ertes-w> "dynamic typing" is not a feature, but quite the opposite: it's a *lack* of a feature…  it's not something a sane person would ask for
07:56:15 <ertes-w> use a statically typed language and use dynamic typing when you need it within that language
08:13:32 <nshepperd_> Arguments against static types are mostly arguments against impoverished type systems like C's. And it's true, if i had to program in c all day i would think dynamic typing was great too
08:16:17 <greymalkin> Trying to use cryptonite -- but I'm missing something because I cannot find any functions for reading key formats (esp those beginning with -----BEGIN...
08:19:12 <kuribas> nshepperd_: after programming in python for two months, I am not sure it is better than a weak type system like javas.
08:19:58 <merijn> kuribas: Java is already better than C
08:20:03 <merijn> kuribas: Java has generics
08:20:11 <kuribas> C++ has templates :)
08:20:16 <merijn> C++ is not C
08:20:35 <merijn> And I'm not sure templates are a good thing, especially for people who do Haskell
08:20:56 <[exa]> why not?
08:21:23 <mnoonan> https://github.com/matt-noonan/haskell-as-templates    <-- yeah, what's not to like?  :)
08:21:30 <merijn> [exa]: You end up writing atrocities like: https://github.com/merijn/GPU-benchmarks/blob/master/TemplateConfig.hpp#L205-L224
08:21:51 <merijn> mnoonan: pfft, get on my level :p
08:22:35 * ventonegro gets reminded of edwardk presentation at ZuriHac
08:22:38 <sanett> templates are like the best thing about C++ though
08:22:39 <[exa]> even haskell sometimes has to succumb to policy classes, the example you posted is exactly the same problem as bloated type signatures
08:23:12 <[exa]> the only main difference though is C++ forces full monomorphization
08:23:21 <mnoonan> [exa]: very true.. at work, we have some massive templates that used to have a pile of parameters..
08:23:47 <mnoonan> we had to switch to policy parameters when the size of various individual symbols started exceeding 40kB
08:23:48 <ventonegro> https://www.youtube.com/watch?v=KzqNQMpRbac
08:23:56 <[exa]> lol
08:24:14 <[exa]> mnoonan: ok well that's a bit too much :]
08:37:29 <anelson> hi all, how do I connect to GHCJSi in my browser? I've heard this is possible, but I don't know how it works. Is it listening on some local port, because `lsof` doesn't show anything while I'm running ghcjsi. Googling around, I can't for the life of me seem to find docs on it.
08:38:46 <cocreature> anelson: localhost:6400 but it should tell you that if you start it
08:38:58 <cocreature> or it should complain about socket.io not being available
08:39:29 <anelson> I don't see anything about socket.io, one way or another
08:39:42 <anelson> I'm running it thru cabal repl btw
08:39:51 <ertes-w> wait, what?  connecting to GHCJSi from the browser?
08:40:27 <cocreature> ertes-w: yeah you can type code in the repl and it evaluates it in the browser window, it’s quite cool!
08:40:50 <anelson> OK, 6400 works, I was looking for ghc in lsof but it's node :P
08:40:52 <ertes-w> nice!
08:41:05 <anelson> but, there's just a white page so it doesn't seem to be loading my code
08:41:10 <anelson> how do I do that?
08:41:20 <cocreature> just run "main" in your repl or whatever you want to run
08:41:27 <cocreature> it loads your code but loading does not mean executing
08:41:35 <cocreature> just like ghci doesn’t execute "main" if you start it
08:41:43 <dsal> Can anyone help me understand what I'm doing wrong here? https://www.irccloud.com/pastebin/XZ0vB6FI/fail.hs
08:41:49 <anelson> interesting, OK, thanks!
08:41:55 <anelson> Hopefully I can get something going
08:42:22 <dsal> The commented out definition of testNoDupMapping works, but I'd expect this one to work as well (though I don't think it needs Eq b)
08:43:16 <dmwit> dsal: You have the literal type `PacketType` in your type ascription for `Right Set.empty`.
08:43:27 <dsal> oh.  ha
08:43:29 <dsal> thanks
08:44:21 <dmwit> dsal: ...the error also says this. "Couldn't match type `b' with `PacketType'... in the second argument of `foldr', namely `(Right Set.empty :: Either PacketType (Set.SetPacketType))'"
08:44:39 <dsal> Yeah, it's super obvious now.  I was like, "Why can't I use PacketType here?"
08:45:13 <dsal> The only problem with this function is I do have two inputs that produce the same output.  *sigh*
08:46:27 <dmwit> dsal: Also, you don't want `(Bounded a, Enum a)`, you want `Finite a`. ;-)
08:46:44 <dsal> I didn't know Finite was a thing.
08:46:59 <dsal> @src Finite
08:46:59 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
08:47:00 <dmwit> ahhh, I'm just doing some shameless advertising for a stupid package of mine
08:47:05 <dmwit> ?hackage universe
08:47:05 <lambdabot> http://hackage.haskell.org/package/universe
08:47:07 <dsal> ah.  I see.
08:47:57 <dmwit> But in particular it gives you a Traversable and Foldable instance for functions over Finite domain.
08:48:08 <dmwit> This function would be a snap to implement with those.
08:53:36 <dsal> Neat, I'll take a look.
08:53:44 <dsal> universe sounds like a big package.
09:01:00 <dsal> dmwit: What does this look like with universe?
09:01:14 <dsal> Too many trees here.
09:11:54 <dmwit> dsal: Mostly you replace `[minBound..]` with `f` and you can skip the `let p = f x in ...` bit of `findDup`.
09:12:11 <dmwit> You could get fancier, I think, but that way seems fine.
09:12:43 <michalrus> Hey, silly question: if `newtype` is completely gone in runtime, how do `newtype` exceptions work? https://hackage.haskell.org/package/base-4.10.0.0/docs/Control-Exception.html#t:NoMethodError
09:12:49 <michalrus> Or is it not gone?
09:13:53 <dmwit> michalrus: You've misunderstood what "completely gone" means.
09:14:07 <michalrus> (:
09:14:24 <dmwit> michalrus: In `newtype NoMethodError = NoMethodError String`, "completely gone" means that at runtime values of type `NoMethodError` and values of type `String` have the same representation.
09:15:11 <dmwit> Compare `data NoMethodError = NoMethodError String`, where the representation differs; in particular there is an additional value, `NoMethodError undefined`, which does not correspond to any value of type `String`.
09:15:41 <dmwit> i.e. `undefined` and `NoMethodError undefined` are distinguishable if `NoMethodError` is a `data` type, but not if it is a `newtype` type.
09:16:12 <dmwit> Or, to say yet another way: it is the `NoMethodError` constructor which is completely gone, not the value as a whole.
09:17:02 <michalrus> Mhmmm, I t-think I get it. So how does `E.catch` in runtime know that it’s an `NoMethodError` and not just a `String`?
09:17:14 <michalrus> s/an/a
09:17:58 <dmwit> `catch` is passed an `Exception` dictionary. The `Exception` dictionary for `NoMethodError` differs from the `Exception` dictionary for `String`.
09:19:05 <dmwit> Most of the time, it is statically known whether a particular call to `catch` should be getting a `NoMethodError` dictionary or a `String` dictionary, in which case that's inlined. But that's an implementation detail.
09:19:33 <michalrus> Okay! Thank you very much. :)
09:19:38 <dmwit> (Actually this dictionary stuff is an implementation detail, too. But it's a super-useful intuition anyway.)
09:19:59 <inkbottle> @pl \x -> if x == 3 then (-x) else (x)
09:19:59 <lambdabot> join (liftM2 if' (3 ==) negate)
09:20:09 <inkbottle> what is if'?
09:20:27 <dmwit> if' p t f = if p then t else f
09:20:54 <inkbottle> OK
09:21:05 <dmwit> You can get a similar function from the base library in `Data.Bool` (named `bool`).
09:22:50 <inkbottle> dmwit: But where is if' defined? (if' not in scope)
09:23:08 <dmwit> Yes, it doesn't exist.
09:23:17 <dmwit> Hence my comment about `Data.Bool`...
09:23:30 <inkbottle> dmwit: OK, doesn't exist
09:24:17 <dmwit> :t liftA3 bool negate id (3==)
09:24:19 <lambdabot> (Eq d, Num d) => d -> d
09:25:05 <dmwit> Also, if you write `liftA3 bool negate id (3==)`, I will come to your house and it won't be for a party.
09:27:55 <inkbottle> dmwit: not for a party then, too bad
09:29:15 <anelson> cocreature: is it possible to change the port to something other than 6400?
09:29:33 <cocreature> anelson: no idea, sry
09:31:29 <ski> @where+ if' if' p t f = if p then t else f
09:31:30 <lambdabot> It is forever etched in my memory.
09:31:35 <dmwit> You have contention for port 6400?
09:32:03 <dmwit> Oh, maybe you want to run more than one.
09:34:00 <dmwit> Looks like there is a #ghcjs, might be worth asking in there.
09:34:12 <dmwit> (Your question will probably be scrolled off the screen in here by the time somebody with expertise is around.)
09:34:52 <cocreature> anelson: grepping through the source suggests you can change it via the GHCJSI_PORT environment variable
09:37:17 <inkbottle> :t let if' p t f = if p then t else f in liftM2 if' -- how come (== 3) is accepted as a (m Bool)?
09:37:19 <lambdabot> Monad m => m Bool -> m p -> m (p -> p)
09:39:40 <dsal> My mac:  frame round trips:                 OK (0.10s)       Travis:  frame round trips:                 OK (22.38s)
09:40:05 <monochrom> Heh 22 seconds
09:40:57 <dsal> I think Linux may just be slower.  That's .74 on my desktop Linux machine, which is at least a higher clock speed than my macbook's i5
09:41:17 <dsal> the new test I added takes 3.57s on my desktop box, and 1.33s on my mac.
09:41:44 <dsal> And then Travis...  no dup packet types:               OK (150.75s)
09:42:28 <mnoonan> dsal: ssd vs spinning rust?
09:42:41 <dsal> Yeah, but this should be all CPU.
09:42:56 <dsal> and maybe memory, which the desktop has a lot more of.
09:45:17 <dsal> The test is this function with a   Char -> a https://www.irccloud.com/pastebin/FQWJ5wAS/testNoDupMapping.hs
09:46:35 <dsal> Anything special about characters that might slow down?  I noticed another test that is related to character handling that's slower on linux.  Both LANG=en_US.UTF-8
09:46:46 <TweyII> inkbottle: (r ->) is a Monad
09:47:00 <TweyII> inkbottle: We traditionally call it Reader
09:47:09 <dsal> address validation   mac v. linux is   (0.13s)  vs. (1.53s)   for 1000 quickcheck tests.
09:48:54 <gerunds> hey
09:50:02 <inkbottle> TweyII: OK, thanks
10:41:46 <ckemper> So I've been diving deeper with functional programming lately, especially at work. And though can't use Haskell for company-political reasons, I have been using a C# functional library called Language-Ext. I've been thinking a lot about the monads Maybe and Either (Option and Try in Language-Ext), and I can't seem to come up with a good rule for when to use one over the other. Either can often be consumed with the same simplicity tha
10:41:54 <ckemper> ...and often I find myself chaining Maybe-returning functions (via Bind) with Either-returning functions by converting the Maybe to an Either with the additional information. In my case, it is a C# exception object with a simple message. So my question is, to all of you seasons functional programmers, how do you decide? My gut is telling me to always use Either and simply throw away the extra information when I don't need it, but tha
10:41:59 <ckemper> ...exactly feel quite right either (haha puns!).
10:45:18 <quicksilver> be willign to convert between them and make sure it feels easy to do so
10:45:42 <quicksilver> for a "large" system (like a typical enterprise system) Either seems a more plausible default thought because there is almost always an error message/object
10:46:45 <TweyII> And note that Either () a is equivalent to Maybe a, so maybe (ha) you can just use that if you have a long chain and conversions are awkward
10:47:37 <ckemper> Right that is exactly what I was feeling (every operation can potentially fail at any layer, and there are maaaaany layers). While monads help me catch things at compile time, they also help me build the error messages I'll be dealing with when customers call in with issues and give me a log file/screenshot of the message.
10:48:49 <ckemper> Thanks for the tips guys! I think I will default to Either for everything and convert to Maybe when I need to Bind across Maybe values, makes sense!
10:48:53 <dsal> @hoogle Either a b -> Just b
10:48:53 <lambdabot> Data.Type.Option Just_ :: f a -> Option f (Just a)
10:48:53 <lambdabot> Data.Type.Index.Trans IxJust :: i a b -> IxJust i (Just a) b
10:48:53 <lambdabot> Data.Either.Combinators swapEither :: Either e a -> Either a e
10:49:19 <dsal> @hoogle Either a b -> Maybe b
10:49:19 <lambdabot> Data.Either.Combinators leftToMaybe :: Either a b -> Maybe a
10:49:19 <lambdabot> Agda.Utils.Either maybeLeft :: Either a b -> Maybe a
10:49:19 <lambdabot> Data.Either.Combinators rightToMaybe :: Either a b -> Maybe b
10:49:44 <dsal> Ah, there it is.
10:50:33 <ckemper> Yep Haskell is filled with those conversion goodies, the C# library I'm using not-so-much, but I am writing some extension functions that make things pretty clean.
10:57:44 <inkbottle> :t flip.bool
10:57:46 <lambdabot> c -> Bool -> c -> c
10:57:48 <inkbottle> :t flip.bool 3
10:57:50 <lambdabot> Num (b -> c) => (b -> c) -> b -> Bool -> c
10:58:46 <inkbottle> Why not :: Bool -> Int -> Int?
10:59:21 <lambda443> is haskell a huge language? :)
11:00:05 <cocreature> lambda443: huge in terms of language features?
11:00:08 <quicksilver> you wanted (flip.bool) 3
11:00:15 <quicksilver> :t (flip.bool) 3
11:00:16 <lambdabot> Num c => Bool -> c -> c
11:00:22 <quicksilver> :t (flip.bool) (3::Int)
11:00:24 <lambdabot> Bool -> Int -> Int
11:00:38 <inkbottle> quicksilver: OK...
11:00:59 <lambda443> in terms of amount of things one needs to know before he could make something as basic as a function that returns the max of two integers of a list :D
11:01:18 <cocreature> > maximum [1,2]
11:01:20 <lambdabot>  2
11:01:23 <lambda443> lol
11:01:33 <cocreature> so that’s relatively easy :)
11:01:38 <inkbottle> quicksilver: "." has lower priority than "application"
11:01:47 <lambda443> it's very concise i know, but :|
11:02:03 <inkbottle> quicksilver: thanks
11:02:04 <cement> the definition of maximum is also pretty concise, afaik
11:02:08 <lambda443> i'm reading real world haskell reached pg 19, and there are 712 densely packed pages :D
11:02:15 <quicksilver> inkbottle: application has highest priority, yes
11:03:01 <cement> it requires a very different kind of thinking compared to most other languages, so guiding people toward changing how they think requires a lot of pages
11:03:02 <cocreature> real world haskell teaches you how to write code that’s significantly more complex, e.g., iirc one of the examples is implementing a json parser
11:04:10 <cement> was ByteString or Text around for RWH?
11:05:05 <inkbottle> quicksilver: got it: if' == (flip.(flip (flip.bool)))
11:05:08 <cement> also a lot of haskellers are wordy folk
11:06:10 <lambda443> the languages seems to be very different from what i'm used to, i know c,c++, a little bit of java but the closest thing i found to it is python
11:07:31 <cement> :t (flip . (flip (flip . bool)))
11:07:33 <lambdabot> Bool -> c -> c -> c
11:07:40 <cement> :t flip $ flip . bool
11:07:42 <lambdabot> Bool -> c -> c -> c
11:08:12 <inkbottle> (flip . (flip (flip . bool))) True 3 4
11:08:48 <cement> I see
11:09:04 <inkbottle> bot refused to answer
11:09:20 <z0ttel> you forgot the :t?
11:09:29 <inkbottle> I wanted evaluation
11:09:35 <inkbottle> 3
11:09:47 <cement> you need '>' at the start
11:09:52 <inkbottle> ok
11:10:03 <inkbottle> > (flip . (flip (flip . bool))) True 3 4
11:10:05 <lambdabot>  3
11:11:11 <cement> > (flip (flip . bool)) True 3 4
11:11:13 <lambdabot>  4
11:11:34 <cement> which is probably not what you're after
11:11:59 <inkbottle> it needed a lot of flip
11:25:36 <lambda443> i heard that haskell can be fast when compiled (much faster than interpreted languages), do you have to sacrifice elegance for your code to be performant? i mean what's usually the difference between fast and slow code in haskell?
11:25:51 <jle`> it depends on the situation
11:26:42 <jle`> libraries can be designed in a way that the most "elegant" usage is the most performant, because of restructuring you can do because code is guaranteed to be pure
11:26:53 <jle`> so many libraries are written to take advantage of purity
11:27:21 <jle`> for example, the 'base' library's implementation of list functions takes advantage of purity to compile code using lists to be extremely performant
11:27:21 <exio4> lambda443: it might go from "do nothing, it's already much faster", or "rewrite it using a different library"
11:27:52 <michi7x7> lambda443: maximum = foldl1 max -- that's a possible implementation for maximum on lists
11:28:07 <TweyII> @src maximum
11:28:07 <lambdabot> maximum [] = undefined
11:28:07 <lambdabot> maximum xs = foldl1 max xs
11:28:23 <exio4> there are certain libs like conduit, attoparsec, aeson which are quite fast if used properly 
11:28:51 <michi7x7> @src maximum :: Vector Int -> Int
11:28:51 <lambdabot> Source not found. stty: unknown mode: doofus
11:29:07 <lambda443> i still don't know how to write a function, so i haven't reached the point where i could understand how these things work :D
11:29:43 <mniip> you've probably inadvertedly written many functions
11:29:45 <lambda443> purity is about how deterministic a function is given a certain input? so it doesn't use any external state
11:29:47 <jle`> lambdabot: however, the downside is that sometimes if you use a library in a way that it wasn't designed to be used (which might be narrow, in some libraries), it can't refactor things or compile things efficiently and then you get non-performan code
11:30:32 <jle`> in that case you might have to dig down and write 'ugly' code sometimes
11:30:59 <jle`> but the ideal is that writing elegant code allows for libraries to take advantage of purity and ref transp and compile things really efficiently
11:31:22 <lambda443> hmm, from how concise the language seems to be at first glance i assume libraries are more readable once you're intermediate'ish level? :O
11:31:28 <jle`> lambda443: yeah, it always gives the same input, and doesn't have any side-effects
11:31:41 <jle`> (to answer your question about purity)
11:32:03 <jle`> *gives the same output if given the same input
11:32:27 <jle`> lambda443: yes most of the standard libraries are pretty readable/usable at the later beginner stages
11:32:43 <jle`> many haskell lessons/tutorials actually include tours of the typically used libraries
11:33:41 <lambda443> jle`: that's great, with languages like c and c++ it's impossible to read those, it seems nobody bothers to read them unless something is broken and the guy debugging them only needs to read the relevant sections :P
11:34:36 <jle`> of course once you venture into the less-often-used libraries, ymmv depending on the priorities of the author
11:38:03 <Psybur> Anybody here use hakyll? Is it worth giving up github pages integration?
11:38:39 <lambda443> are lists considered a type in the same way an Integer or Double is? looking at the output of :type [] outputs [a] which i assume something like a template that is replaced by the type we later use it with once filled?
11:39:34 <jle`> lambda443: yeah, [a] is a polymorphic type
11:39:41 <jle`> meaning that [] can be used as an [Int], a [Double], etc.
11:39:44 <lambda443> and then :type [12,42] outputs [12,42] :: Num a => [a]
11:39:44 <lambda443> . is this notation indicating the replacement of [a] by Num?
11:39:54 <jle`> it's still a polymorphic type
11:40:03 <jle`> but it can be instantiated as any type that is an instance of the Num typeclass
11:40:12 <jle`> Num is a typeclass here, so Num a => ... is a constraint
11:40:18 <jle`> this is because python's numeric literals are polymorphic
11:40:40 <jle`> `12` can be interpreted as any type that implements the Num typeclass
11:40:52 <jle`> for a more 'concrete' example, try something like :type [True, False]
11:40:52 <EvanR> s/python/haskell/ ?
11:41:04 <jle`> sorry, yes, haskell :) just came back from teaching a python lecture, heh
11:41:15 <EvanR> i thought you were serious for a second :)
11:41:16 <lambda443> hahaha, i got confused
11:41:44 <jle`> in my python class i always also say "in haskell...", as well
11:41:47 <jle`> heh
11:41:55 <EvanR> well, thats ok
11:53:31 <lambda443> lol i've written a function just by guessing the syntax, let fx a = head a * 2; fx [2,3]; outputs 4 :D
11:54:50 <Psybur> > fx = (*2) . head; fx [2,3]
11:54:52 <lambdabot>  <hint>:1:4: error:
11:54:53 <lambdabot>      parse error on input ‘=’
11:54:53 <lambdabot>      Perhaps you need a 'let' in a 'do' block?
11:55:12 <Psybur> > ((*2) . head) [2,3]
11:55:14 <lambdabot>  4
11:55:47 <Psybur> lambda443, point free :D?
11:56:04 <lambda443> Psybur: what do you mean?
11:57:03 <Psybur> You can rewrite the function `fx a = 2 * (head a)` to be just `fx = (*2) . head
11:57:29 <lambda443> oh, what the hell
11:57:34 <Psybur> https://wiki.haskell.org/Pointfree
11:59:06 <lambda443> is xs kind of a place holder for any type?
11:59:25 <Psybur> In that example Im pretty sure xs is the parameter for a list
11:59:48 <Psybur> :t foldr
11:59:50 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
12:00:02 <Psybur> Never mind, xs is a Foldable
12:01:15 <cement> I still don't quite "get" catamorphisms
12:01:32 * lambda443 needs a description that explains description of foldr
12:01:53 <cement> Foldable t ~ [t]
12:01:59 <cement> sorry
12:02:11 <cement> Foldable t => t a ~ [a]
12:02:13 <cement> that one
12:03:36 <lambda443> oh, foldr recursively adds the list to the parameter
12:03:54 <lambda443> oh wait, it takes other "operators"
12:04:13 <ongy> is there a good way to extend zippers to have multiple (tagged) foci? The Zipper [a] a [a] as xmonad uses it is sadly limited to a single focused element, which I want to avoid it
12:04:30 <Psybur> @src foldr
12:04:31 <lambdabot> foldr f z []     = z
12:04:31 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
12:04:52 <cement> @src sum
12:04:53 <lambdabot> sum = foldl (+) 0
12:05:11 <Psybur> > foldr f z [a,b,c]
12:05:13 <lambdabot>  f a (f b (f c z))
12:05:52 <geekosaur> ongy, look up the derivation of a zipper? iirc every derivative of a type adds a new focus
12:05:53 <Psybur> > foldr (:) [] "abc"
12:05:55 <lambdabot>  "abc"
12:06:46 <lambda443> hmm, it still looks like magic to me
12:09:49 <cement> I see it as replacing ':' in a list with the given operator (intuitively)
12:09:55 <monochrom> "f a (f b (f c z))" might not be the best presentation. If you think of f as an infix binary operator, it's: a `f` (b `f` (c `f` z))
12:10:19 <monochrom> And now draw a parallel with the input list: a : (b : (c : []))
12:10:36 <monochrom> So now it's what cement just said, replacing : by f, [] by z.
12:11:29 <monochrom> That is the ground level of understanding. To be a user and know what you expect when you use it.
12:12:01 <monochrom> The next level of understanding is to recognize that the source code shown by @src foldr does the job.
12:12:46 <cement> my understanding breaks down whenever I try to generalize out to a Tree or some of the other things that are Foldable, but that's a whole 'nother animal
12:13:34 <monochrom> That's just because Foldable and catamorphism represent two incompatible directions of generalization.
12:14:57 <cement> I love how delightfully unhelpful wikipedia is for things like this
12:15:04 <monochrom> Foldable is about "let's just pretend your tree is a list by in-order traversing your tree extracting the content and losing the tree shape"
12:15:18 <monochrom> Catamorphism actually respects your tree shape.
12:15:32 <cement> I see
12:15:51 <monochrom> They are nemeses of each other.
12:16:01 <cement> I'd suppose so
12:16:16 <ongy> geekosaur: ah, I may have worded that badly. I want a dynamic amount of foci. Which I think wouldn't be possible that way
12:16:39 <geekosaur> mm, I think zippers are going the wrong direction then
12:17:30 <mbeidler> Has there  ever been talk of a separate typeclass for mempty?
12:17:33 <ongy> I was thinking [(Maybe a, b)], but I'm not quite sure that's a nice way to go about it
12:18:09 <mbeidler> For types that have "unit" but no associative binary operation.
12:18:13 <monochrom> No, but there is a separate typeclass for semigroup which is just the associative mappend operation
12:19:05 <monochrom> So here is a cunning plan. Request for a language extension that lets you subtract two typeclasses. Then you'll get the mempty typeclass. And other useful typeclasses.
12:19:18 <mbeidler> monochrom: Yeah, I was hoping there might be something for the opposite situation.
12:19:19 <monochrom> Many chicken wings in one stone!
12:20:24 <cement> seems to me that mempty doesn't really mean much outside of monoid...
12:20:41 <Tuplanolla> There's `Default`.
12:20:44 <mbeidler> Well, in the sense of something like default.
12:21:09 <geekosaur> well. having an identity can be useful... but identity is only meaningful in the presence of an operator
12:21:28 <monochrom> We have a class Pointed for the "pure" method alone. And it is non-standard. And it took years to appear. I think a class for mempty alone is going to take another decade, and even then not in base.
12:23:15 <monochrom> Yeah if you don't mind Default you can find it on hackage.
12:23:40 <mbeidler> I'm thinking `Nothing` for Maybe, `[]` for list, essentially what is `mempty` or `mzero` currently. In those cases the meaning is independent of an operator. The  identity in the sense of mempty is tied to it's monoid.
12:23:47 <monochrom> But you may or may not like their choice of default::Int
12:23:49 <mbeidler> its*
12:24:17 <mnoonan> I think the class should be "class Proof t where qed :: t", with the law that qed is not bottom.
12:24:40 <geekosaur> mbeidler, so you want the identity to be defined only for free types?
12:25:12 <monochrom> Ah but programmers love defaults and hate proofs!
12:25:18 <mnoonan> :(
12:25:34 <geekosaur> sorry, not free types
12:25:42 <monochrom> In the same way some people love gelato but hate ice cream!
12:25:43 <geekosaur> the free <x> for a type
12:25:58 <geekosaur> which then leaves you with a parameter again: which <x>?
12:26:39 <geekosaur> (in particular, I suspect you're reaching for the free monoid's mempty)
12:26:59 <mbeidler> geekosaur: The use case is that I have a HOF that serializes to any type with `FromJSON`. I then run a user-supplied (a -> b) on the result.
12:27:46 <mbeidler> However, if I get empty result back, I would like the b in that function to be the mempty.
12:28:25 <mbeidler> So something that is expecting only a single result back will supply `Just`
12:30:05 <mbeidler> Or to constrain in some way that only those with such a concept can be applied.
12:31:10 <lopytro> hello everyone
13:09:21 <Psybur> Lets see if I have the terminology straight yet. `do` chains monadic computations to produce monadic values?
13:11:04 <fakenullie> syntax sugar for >>= and >>
13:11:34 <fakenullie> or not >>, I need to refresh my knowledge
13:12:30 <monochrom> I don't understand why there is a "monadic computation" and then there is a "monadic value". Same thing?
13:13:29 <fakenullie> I guess monadic values is a value of Monad type and computation is operation on such values
13:14:55 <monochrom> But you need to know that since "do { xxx; do { y1; y2; y2 }; zzz }" is possible, therefore whenever you say "do chains MMM" the whole do-block is therefore also an MMM because it can become an ingredient of yet another do-block.
13:15:32 <monochrom> In other words if you say that xxx is an MMM then do{y1;y2;y2} is also an MMM.
13:16:45 <monochrom> Not to mention recursive scenerios such as "r = do { putChar 'x'; r }"
13:17:56 <monochrom> If putChar'x' is an MMM then r is also an MMM of the same social status but then r is do{putChar'x'; r} so this do-block is also an MMM of the same social status.
13:18:34 <fakenullie> I don't understand what you're trying to say, sorry
13:19:06 <fakenullie> maybe we'll wait for someone more competent
13:19:07 <monochrom> I am calling bluff on having two separate things, "monadic computation" and "monadic value".
13:19:48 <monochrom> There is none.
13:21:46 <monochrom> Or rather, more specifically, I'm calling bluff on, in do {xxx; yyy; zzz}, saying "xxx is a monadic computation, the whole do-block is a monadic value", and considering them different.
13:21:48 <fakenullie> putChar 'x' is a value
13:22:08 <fakenullie> putChar 'x' >> putChar 'y' is a computation, no?
13:22:25 <fakenullie> well, result of putChar 'x' is a value
13:22:32 <fakenullie> :t putChar 'x'
13:22:33 <monochrom> putChar 'x' is also a computation. putChar 'x' >> putChar 'y' is also a value.
13:22:34 <lambdabot> IO ()
13:23:14 <fakenullie> ok
13:24:18 <Tuplanolla> Assuming `Monad m`, name these things: `a`, `m a`, `a -> b`, `a -> m b`, `m a -> m b`, `m (a -> b)`, `a -> b -> c`, `a -> m b -> m c`, `a -> m (b -> c)`, `m a -> m b -> m c`, `m a -> m (b -> c)`, `m (a -> b -> c)`.
13:26:25 <sgronblo> What is the best way to get some sort of Haskell IDE going nowadays? No Emacs please.
13:27:14 <johnw> sgronblo: maybe Manuel's learning IDE on the Mac App Store?  what are you criteria for 'best'?
13:27:54 <sgronblo> Isn't that more for doing some sort of interactive coding?
13:28:16 <johnw> well, I don't know what you intend to do with Haskell
13:28:26 <johnw> the I in IDE does stand for interactive
13:28:34 <johnw> or, integrated, depending on whom you ask
13:28:53 <fakenullie> it's for integrated
13:28:58 <sgronblo> I want something with great auto completion, go to definitions, and error checking
13:29:23 <sgronblo> at the very least
13:29:55 <sgronblo> And ideally not something that requires a lot of manual scripting and installing a whole bunch of different tools and configuring them
13:30:54 <fakenullie> microsoft visual haskell
13:30:57 <fakenullie> I'm sorry
13:33:17 <monochrom> There is Haskell for Mac.
13:33:48 <fakenullie> sgronblo: does "no emacs" also rules out vim?
13:34:17 <sgronblo> fakenullie: of course not
13:34:25 <sgronblo> emacs is not vim
13:35:07 <monochrom> Microsoft Visual Studio Code is also an option. "Microsoft Visual Haskell" is not entirely fictional.
13:35:32 <fakenullie> I consider that just Atom in disguise
13:36:07 <monochrom> But anyway if you're on Mac you may like to consider http://haskellformac.com/
13:36:28 <monochrom> Oh yeah Atom is also pretty popular.
13:36:49 <Sose> vscode is more than just atom in disguise :p
13:37:08 <sgronblo> https://github.com/haskell/haskell-ide-engine I wonder what the state of this is nowadays
13:37:12 <monochrom> I am old school I am wedding (welding?) myself to my emacs.
13:37:31 <sgronblo> I couldnt find a good haskell plugin for VSCode
13:37:34 <monochrom> Then again there was a time emacs was the new-fangled thing.
13:37:44 <fakenullie> is leksah dead
13:38:03 <monochrom> I grew up on Turbo Pascal and vi.
13:38:07 <hamishmack> fakenullie: What makes you say that?
13:39:36 <johnw> monochrom: I grew up on Turbo Pascal and Turbo Pascal's own editor
13:40:03 <Sose> https://github.com/haskelly-dev/Haskelly I guess this is decent for vscode
13:40:13 <Sose> but I don't know what sort of magic emacs modes have
13:40:22 <hamishmack> fakenullie: Have you tried it lately? Was there a bug or something? https://github.com/leksah/leksah#getting-leksah
13:40:37 <johnw> so much magic
13:40:40 <dsal> https://www.irccloud.com/pastebin/jxzbJc9m/Is%20there%20a%20way%20to%20combine%20these%20implementations%20and%20parameterize%20on%20just%20the%20parameter%20to%20choose%20there%3F
13:40:52 <dsal> Ugh, wrong field.  Is there a way to combine these implementations and parameterize on just the parameter to choose there?
13:42:49 <sgronblo> Sose: I feel like I tried that one, but it wasn't working the way I expected
13:43:54 <sgronblo> Gonna give the haskell-ide-engine a try again
13:46:57 <freeman42x> any ideas which strip program this is talking about? <<Warning: Unable to strip executable or library 'libHShie-build-plugin-0.1.0.0-LukZWjNs9qzBcmvDX3Zs7D-ghc8.0.2' (missing the
13:46:58 <freeman42x> 'strip' program)>>
13:47:50 <cement> if we're 100% honest, emacs is probably your best bet for anything resembling an integrated environment. vim with ghc-mod works, but only some of the time, and even then I've needed nix to make that happen
13:48:27 <geekosaur> freeman42x, it usually comes with binutils
13:48:53 <geekosaur> on s x it should be part of the command line tools
13:49:00 <geekosaur> *on os x
13:50:38 <sgronblo> cement: i hope that is not true
13:51:53 <freeman42x>  > freeman42x, it usually comes with binutils
13:51:54 <freeman42x> NixOS here, there was a binutils package and it contained it. Thank you very much!
13:54:02 <EvanR> i believe an induction principle for the recursive data type Nat can somehow prove the well ordering principle for Nat
13:54:12 <cement> @sgronblo http://www.stephendiehl.com/posts/vim_2016.html
13:54:13 <lambdabot> Unknown command, try @list
13:54:17 <cement> whoops
13:54:28 <cement> that's a habit to break
13:54:42 <EvanR> and now i want to know how to justify the induction principle, it seems like it ought to be possible
13:55:10 <EvanR> it seems ovious somehow that recursion into lesser Nats has to stop
13:59:47 <codeshot> Am I right in understanding that an instance 'Functor f' maps morphisims of Hask from Hask to 
14:00:19 <codeshot> Am I right in understanding that an instance 'Functor f' maps morphisims of Hask from Hask to an embeddind of Hask within itself ?
14:00:28 <codeshot> urgh, keyboard fail tonight!
14:00:43 <codeshot> But that it doesn't map objects of Hask and as such isn't a functor?
14:01:05 <EvanR> f maps objects
14:01:14 <EvanR> fmap maps functions
14:01:44 <codeshot> Can you give an example of mapping an object, generalised to all instances of Functor?
14:02:01 <EvanR> well, the type of fmap does that
14:02:06 <ski> `Maybe' maps `Int' to `Maybe Int'
14:02:36 <codeshot> Oh I see
14:02:51 <EvanR> how tautological :)
14:03:02 <jcarpenter2> quite
14:03:08 <codeshot> Does every functor in haskell have an inverse?
14:03:13 <ski> `fmap' maps any function of type `A -> B' to a function of type `Maybe A -> Maybe B'
14:03:46 <codeshot> that's still an object isn't it?
14:04:02 <codeshot> without <*> how can it be a mapping of morphisms ?
14:04:05 <ski> codeshot : pre-inverse or post-inverse, or both ?
14:04:17 <EvanR> fmap is mapping the function itself, not types
14:04:17 <codeshot> ski, I'm too junior to know
14:04:28 <EvanR> fmap works on values not types, f works on types
14:04:28 <monochrom> EvanR: Some of us take the well-ordering principle for granted (as an axiom or family of axioms); the others of us take induction for granted (again as an axiom or family of axioms). The philosophical ground is, of course, just what you said: It is one of those few obvious things that can't be broken down further.
14:04:31 <codeshot> EvanR, got it
14:05:21 <EvanR> but "its obvious" is unsatisfying
14:06:26 <monochrom> But it isn't a very bad kind of take-for-granted. Induction is also a way to say "I am referring to the smallest set that has 0 and successors".
14:07:12 <monochrom> At which point it's a definition rather than an axiom. (And then of course you worry about whether this definition may or may not lead to contradictions but that's another episode.)
14:07:29 <EvanR> thats one direction, but the (logically equivalent??) direction which says, if i take any number and work "backwards", i will arrive at zero
14:07:32 <ski> EvanR : perhaps see "Two conceptions of natural number" by Alexander George,Daniel J. Velleman in 1998 at <https://www.amherst.edu/media/view/18770/original/Two_Conceptions_of_Natural_Number.pdf>
14:07:34 <EvanR> seems more concrete
14:07:56 <codeshot> So "Maybe" is a functor from the category of Hask-Maybes to Hask?
14:08:07 <EvanR> ski: thanks
14:08:11 <ski> no, it's a functor from `Hask' to `Hask'
14:08:35 <codeshot> ok
14:15:15 * monochrom Imagines "A Dialogue of Two Systems of The Natural Numbers between Peano and Simplicio" :)
14:16:41 <monochrom> It consists of two chapters.
14:16:46 <monochrom> First chapter: "Day 1"
14:17:00 <monochrom> Second chapter: "Day n+1, building upon Day n"
14:20:03 <EvanR> the very context of this question... haskell.. in all its glory  betrays the obviousness of terminating recursion... fix S
14:20:30 <EvanR> which this paper points out is the silly part of the construction
14:21:05 <monochrom> Wait, successor is silly?
14:21:17 <monochrom> (Sorry, the paper was too long, didn't read.)
14:22:43 <EvanR> fix S
14:22:53 <EvanR> is sssssssssss... illy
14:43:01 <monochrom> Oh, I see.
14:43:04 <c4pt> https://iota.org/
14:53:46 <EvanR> to define well founded recursion, you must somehow exclude regular recursion
14:55:08 <EvanR> if you exclude it it must already exist, platonism!
14:55:19 <EvanR> QE
14:55:21 <EvanR> D
14:59:21 <ski> ("if you say there is no king of france, do you in some sense still presuppose a king of france which has the property of non-existence ?")
15:05:51 <mbrock> sphalerite: just remembered a way I sometimes explore data structures: dump to JSON, load in a HTML document, and then use `console.log(x)` in Chromium's console...
15:06:27 <mbrock> it's kind of heavyweight, but also kinda neat, and you can run some quick JavaScript queries if you want...
15:06:42 <mbrock> the autocompletion in the console is decent too
15:07:22 <mbrock> p.s. someone should take a few hours to make a JSON explorer with Aeson and Brick, I suppose!
15:08:08 <mbrock> ski: wow, that's a surprisingly pithy and interesting ontological question
15:08:26 <codeshot> Is there a fairly standard operator for a -> (a -> b) -> b ? ie `(flip ($))`
15:08:32 <codeshot> in operator form?
15:08:35 <Tuplanolla> :t (&)
15:08:37 <lambdabot> a -> (a -> b) -> b
15:08:46 <codeshot> hoogle hid that from me
15:08:49 <codeshot> naughty hoogle
15:08:58 <codeshot> :info (&)
15:09:09 <Tuplanolla> In `Data.Function`.
15:09:14 <codeshot> :D
15:14:12 <ski> mbrock : perhaps see "second-order property" at <https://plato.stanford.edu/entries/existence/>
15:14:20 <ski> (also <https://philosophy.stackexchange.com/questions/23712/quines-to-be-is-to-be-the-value-of-a-bound-variable> may be interesting)
15:14:45 <ski> @type runCont . return
15:14:46 <lambdabot> a -> (a -> r) -> r
15:15:19 <mbrock> presupposing a king of France with the property of not being the king of France is a very reactionary ideology, I believe it's a part of Jacobitism :P
15:15:23 <iqubic> :t runCont
15:15:24 <mbrock> thanks for links!
15:15:24 <lambdabot> Cont r a -> (a -> r) -> r
15:15:42 <sphalerite> mbrock: nice channel switch :p but yes that's also an option I suppose
15:17:15 <mbrock> it's also like "king of France" type checks if you don't have the right dependent typings... but it's an uninhabited type
15:18:46 <mbrock> (except maybe Franz, the duke of Bavaria, but only in an obscure fork)
15:34:51 <monochrom> Haha mbrock about reactionary Jacobitism
15:36:23 <monochrom> Although why would the supporters of the Stuart Scottish dynasty dabble in the French throne?
15:37:14 <monochrom> Apart from procrastination
15:38:07 <geekosaur> why do I feel like this is going to end with Civilization implemented in the type system?
15:38:13 <Welkin> not contracrastination?
15:38:16 <monochrom> \∩/
15:38:46 <jcarpenter2> such emoji
18:05:24 <dumptruckman> How to I properly close the handle here? https://imgur.com/a/6MUWK
18:05:43 <dumptruckman> quit isn't implemented to do anything atm
18:06:35 <olligobber> dumptruckman, ghci isn't good at closing handles, but if you compile and run from terminal, ctrl+d will probably work
18:06:42 <dumptruckman> ah
18:07:19 <Welkin> dumptruckman: https://hackage.haskell.org/package/base-4.10.0.0/docs/GHC-IO-Handle.html#v:hGetContents
18:07:31 <Welkin> the docs have some good comments about it too
19:34:08 <iqubic> How are my favorite Haskellers?
19:34:28 <Clint> i'm fine
19:35:58 <Welkin> says the Compure library Int
19:36:03 <Welkin> Compute*
19:36:37 * Clint twitches and reboots.
19:38:32 <ghostyy> hi, what is the easiest way to use haskell to display a bitmap (whose contents i can access and modify, and redraw as necessary) in an xorg window using haskell?
19:39:23 <ghostyy> also i would like some way to know when the window is clicked on, and what coordinates (relative to the window) the cursor was on when it clicked
19:39:31 <ghostyy> and get keyboard input
19:41:22 <Welkin> ghostyy: use sdl2
19:41:29 <Welkin> for input capture
19:41:37 <Welkin> use juicypixels for bitmap loading/parsing
19:41:56 <ghostyy> well, ill be drawing the bitmap myself
19:41:58 <Welkin> sdl2 can also render your bitmaps
19:42:15 <ghostyy> so i dont need to parse or load one
19:51:40 <dsal> My coverage report suggests I'm not exercising my derived Eq.  It seems accurate otherwise.  Any idea why this would happen?
19:51:41 <buttbutter> noob question: want to test out my parser in ghci, have a test file foo.test. Is there an easy way to apss foo.test as a String to my function runParser :: String -> [Cmd]? 
19:52:19 <Welkin> runParser "foo.test"
19:52:20 <Welkin> o.o
19:52:22 <dsal> runParser "foo.test"
19:52:25 <Welkin> lol
19:52:27 <buttbutter> sheeet
19:52:31 <buttbutter> wait what
19:52:41 <buttbutter> Won't that just past the string "foo.test"?
19:52:44 <Welkin> yes
19:52:46 <buttbutter> no!
19:52:49 <dsal> That's what you specified.
19:52:55 <buttbutter> foo.test is *test file*
19:53:00 <ghostyy> dsal, that is not what he specified
19:53:01 <buttbutter> It has the input in the file!
19:53:02 <Welkin> you can load the files as a string using something like hGetContents
19:53:14 <Welkin> :t hGetContents
19:53:15 <lambdabot> error:
19:53:15 <lambdabot>     • Variable not in scope: hGetContents
19:53:15 <lambdabot>     • Perhaps you meant one of these:
19:53:15 <dsal> You want the contents of foo.test as a string?
19:53:21 <buttbutter> Yessir.
19:53:21 <Welkin> @type hGetContents
19:53:24 <lambdabot> error:
19:53:24 <lambdabot>     • Variable not in scope: hGetContents
19:53:24 <lambdabot>     • Perhaps you meant one of these:
19:53:31 <buttbutter> Just for ghci testing
19:53:36 <buttbutter> pls no IO monads ;_; 
19:53:39 <ghostyy> http://hackage.haskell.org/package/base-4.10.0.0/docs/System-IO.html#v:hGetContents
19:53:49 <dsal> You want to do IO without an IO monad?
19:53:50 <Welkin> http://hackage.haskell.org/package/base-4.10.0.0/docs/System-IO.html#v:hGetContents
19:53:54 <ghostyy> ghci is already in the io monad
19:53:58 <ghostyy> so its okay to use io in it
19:54:09 <Welkin> io is a moon
19:54:29 <ghostyy> thats why you can use functions like print in it, and it wont give you a type error
19:56:22 <buttbutter> ghostyy: I know :) 
19:56:34 <buttbutter> I just meant like...I want to do it in GHCI and not have to edit my source :) 
19:57:18 <Welkin> runParser =<< hGetContents "foo.test"
19:57:55 <Welkin> return . runParser =<< hGetContents "foo.test"
19:59:09 <olligobber> "no IO monads" and "load the files" are kinda incompatible in pure functional programming
19:59:39 <buttbutter> Welkin: That doesn't work for me. Gotta get a Handle first from opening the file, right?
20:01:38 <ghostyy> you dont strictly need a monad to do "purely functional" programming, the thing that prevents you from stripping from IO type from the return value of an IO function by pattern matching on its constructor is that it doesnt export its constructor
20:02:19 <buttbutter> Well I just got the handle with openFile and then used hGetContents and that worked fine.
20:02:22 <buttbutter> Thanks for the help :) 
20:02:36 <buttbutter> I just figured there might be some ez sugar to open files in ghci but I guess not :C
20:05:13 <monochrom> I don't know how ez you need.
20:05:44 <dsal> BL.readFile "foo.test"   -- but that's not a String.  You'd have to unpack it.
20:05:49 <monochrom> "x <- openFile "xxx.txt" ReadMode" works in ghci.
20:06:18 <monochrom> "y <- readFile "xxx.txt"" does the combination of openFile and hGetContents
20:06:20 <ghostyy> dsal, you have to compose them but the oeprator that does that doesnt need to be a monad
20:06:47 <monochrom> If those two don't count as ez I don't know what does.
20:07:28 <monochrom> I mean apart from directly connecting your brain to the computer by USB 3.0
20:09:16 <Welkin> yeah, readFile
20:09:25 <Welkin> I haven't dealt with file reading in a while
20:09:57 <monochrom> It's OK. Eventually you'll find that readFile has its problems and you don't actually use it often in production.
20:10:06 <monochrom> In production you go pipes or conduits etc.
20:10:23 <monochrom> Actually and : etc :: or : ???
20:27:29 <Axman6> also etc?
20:28:24 <Axman6> "and so on" for for adjunction and disjunction no?
20:28:27 <Axman6> works for*
20:28:43 <MarcelineVQ> et cet-er-a, et cet-er-a, et cet-er-a
20:29:49 <ghostyy> you guys care way too much about semantics =_= (the word kind, not the fun formal kind)
20:30:13 <geekosaur> the 'et' has a different sense there, fine to use it with 'or'
20:30:49 <geekosaur> kinda funny how Latin gets used as English's metalanguage though
20:30:56 <Welkin> or we could just stop using latin
20:31:10 <Welkin> instead of etc., you can use "and so on"
20:31:41 <ghostyy> but those things mean the same thing, so whats the point of changing
20:32:22 <Welkin> why not just go back to using latin?
20:32:36 <MarcelineVQ> it sounds silly out loud
20:32:45 <ghostyy> it would be very difficult to switch
20:32:51 <Welkin> people overuse latin
20:32:53 <ghostyy> but aside from that i have no problem with it
20:32:56 <Welkin> "mea culpa" too
20:33:21 <Welkin> "caveat emptor"
20:33:45 <Welkin> even "i.e." and "e.g."
20:34:06 <Welkin> I am guilty of using "e.g." though
20:34:24 <MarcelineVQ> kinda funny how abbreviation gets used as English's metalanguage though
20:34:24 <Welkin> at least I don't use Q.E.D.
20:47:17 <dsal> Welkin: If we replace etc… with "and so on" then how will people misspell it?
20:47:33 <geekosaur> they will
20:47:43 <dsal> dumb finds a way
20:53:34 <kadoban> Welkin: If you remove all of the borrow word/phrases from English, you have little left. Why is latin in particular a problem?
20:54:20 <Clint> Welkin: i use f.ex. instead of e.g.
20:54:48 <kadoban> Clint: Basically guaranteeing nobody will know what it means?
20:55:49 <Clint> kadoban: most people don't seem to know the difference between e.g. and i.e. so that doesn't seem like much of a loss
20:56:22 <kadoban> I see them used correctly way more than incorrectly I think.
21:16:08 <gmax> does anyone know any reactive libraries that are easy for a beginner to use? I tried installing reflex, but after starting the shell it completely froze my computer and i had to restart it
21:17:05 <gmax> for a class project im thinking of using something reactive to make a game, or making a library that has to do with reactive programming. Would the latter be doable for a beginner?
21:17:36 <Welkin> I don't think frp is for beginners
21:17:45 <Welkin> you really need to know haskell pretty well before you can use it
21:18:14 <gmax> ok, yea does seem kinda hard
21:18:40 <Welkin> it's also not the most intuitive concept
21:19:18 <Welkin> is this a haskell class?
21:19:36 <gmax> yea
21:20:04 <ghostyy> you have to finish reading tapl and also attapl before you are allowed to try frp,  there is a short examination on the download site
21:20:05 <Welkin> if you want to use reflex, go ahead. Join #reflex-frp for help
21:20:13 <Welkin> otherwise there is also reactive-banana
21:20:46 <Welkin> frp is not required to write a game though
21:20:56 <Welkin> it's easier to write a game without using it
21:21:17 <gmax> i thought it would be easier since I wanted to do something with a gui instead of terminal ui
21:21:36 <gmax> are there any gui libraries ud recommend?
21:21:49 <ghostyy> haskell has bindings to sdl2
21:21:57 <Welkin> sdl2 is great
21:22:02 <ghostyy> and also to gtk
21:22:05 <Welkin> but also has a learning curve
21:22:08 <Welkin> very low level
21:22:11 <ghostyy> the latter of which i have used and is okay
21:22:12 <Welkin> I would not recommend gtk
21:22:30 <gmax> thanks, guess ill check out sdl2
21:22:41 <Welkin> sdl2 or glfw-b with gloss is probably your best bet
21:22:54 <Welkin> it's hard to recommend anything beginner friendly
21:22:58 <Welkin> because none of these really are
21:23:07 <Welkin> the most beginner friendly would be html canvas
21:23:54 <ghostyy> cairo has drawing primitives basically the same as html canvas
21:24:00 <ghostyy> which you can use from gtk programs
21:49:40 <sm> gmax: there's also FunGEn
21:50:10 <gmax> sm: thanks. I just came across gloss and it seems nice
21:52:13 <sm> it is nice, but does it have... cool game characters! http://fungen.joyful.com
21:55:35 <sm> and example games
22:08:15 <gmax> sm: thanks! I'll check out fungen
