00:36:53 <ertes-w> dminuoso: your traverseX is correct…  however, you doing a lot more there than necessary…  do you really need to use (<*>) multiple times?
00:37:14 <ertes-w> *you're
00:39:31 <M4GNV5work> hey, i have a small question: I have several types defined using data which all implement a specific class, now i want to create a function which takes an array of strings and returns one of the types (so i can parse a configuration file). But it gives me an error because the multiple return types.
00:39:37 <M4GNV5work> here is my code: https://pastebin.com/h0MLN2PW
00:39:55 <M4GNV5work> are there some language extensions i can enable to allow this? or am i doing something wrong?
00:40:41 <ertes-w> M4GNV5work: type classes ≠ OOP…  your function promises to work for *any* type 'a' that the user of the function picks, as long as there is a Collider instance
00:41:36 <ertes-w> M4GNV5work: so if i use your function instantiated with (a = Rectangle), it should give me a Rectangle
00:43:40 <ertes-w> M4GNV5work: what you can do is return a collision function
00:43:42 <M4GNV5work> hmm so the only solution is to put Circle, Rectangle, ... into a single data type?
00:43:50 <M4GNV5work> hmm
00:44:11 <ertes-w> M4GNV5work: parseCollider :: [String] -> Line -> [Point]
00:44:20 <ertes-w> or rather:
00:44:27 <ertes-w> parseCollider :: [String] -> Maybe (Line -> [Point])
00:45:18 <ertes-w> M4GNV5work: if you want to actually tell the different objects apart and access their individual fields, then yes, you need a sum type
00:46:11 <M4GNV5work> cool ty, i'll stick with the returned partially applied collision function for now
00:46:19 <ertes-w> if you're just parsing for the sake of collision detection, then you might as well just return the collision function
00:46:37 <M4GNV5work> but yeah if i want to plot it later i probably have to access the fields and do it the other way
00:47:09 <ertes-w> M4GNV5work: or you return more information…  turning Collider into a regular data type might be helpful
00:48:03 <ertes-w> class ParseObject a where parseObject :: [String] -> Maybe a
00:48:24 <ertes-w> instance ParseObject Collider where …
00:48:28 <ertes-w> instance ParseObject Plotter where …
00:48:55 <ertes-w> or dispense with the class and just return everything:  parseObject :: [String] -> Maybe (Collider, Plotter)
00:50:24 <ertes-w> M4GNV5work: the underlying notion is that an object can be defined by its behaviour instead of its data/state
00:56:39 <kaychaks> does `intero` support adding missing imports ?
01:07:35 <ventonegro> @hoogle m a -> m [a]
01:07:35 <lambdabot> Data.List subsequences :: [a] -> [[a]]
01:07:35 <lambdabot> Data.List permutations :: [a] -> [[a]]
01:07:35 <lambdabot> Data.List inits :: [a] -> [[a]]
01:07:56 <ventonegro> @hoogle m a -> (a -> Bool) -> m [a]
01:07:56 <lambdabot> Data.List nubBy :: (a -> a -> Bool) -> [a] -> [a]
01:07:56 <lambdabot> GHC.OldList nubBy :: (a -> a -> Bool) -> [a] -> [a]
01:07:56 <lambdabot> Distribution.Compat.Prelude.Internal nubBy :: () => (a -> a -> Bool) -> [a] -> [a]
01:08:16 <ventonegro> @hoogle (a -> Bool) -> m a -> m [a]
01:08:16 <lambdabot> Data.List nubBy :: (a -> a -> Bool) -> [a] -> [a]
01:08:16 <lambdabot> GHC.OldList nubBy :: (a -> a -> Bool) -> [a] -> [a]
01:08:17 <lambdabot> Distribution.Compat.Prelude.Internal nubBy :: () => (a -> a -> Bool) -> [a] -> [a]
01:20:44 <muzzle> the type signature f :: a -> b -> c is equal to (forall a b c . a -> b -> c), right?
01:21:24 <muzzle> I'm asking because I don't understand why the forall is needed to bring the type variables into scope when using ScopedTypeVariables...
01:26:45 <ertes-w> muzzle: yes, but that's not the reason you need forall
01:27:10 <ertes-w> muzzle: the problem is that haskell quantifies implicitly, so you usually don't need the forall, but that makes scoping ambiguous
01:27:42 <ertes-w> when you use the type variable 'a' in a local definition, are you referring to the 'a' from the top-level, or are you quantifying over it?
01:27:48 <phadej> f :: a -> a -> a; f = ... where g :: a -> a; g = ...
01:28:07 <phadej> are `a` in f's and g's  signatures the same?
01:28:13 <ertes-w> ScopedTypeVariables follows a more or less natural rule: if you want to quantify, you have to do it explicitly, otherwise you're referring to a variable from an outer scope
01:28:50 <ertes-w> only when the variable doesn't exist in an outer scope it will be implicitly quantified (that's the sad part about the rule)
01:29:15 <Wizek> geekosaur: Do you remember this exchange we had about a month ago? http://ircbrowse.net/browse/haskell?id=25177755&timestamp=1507840899#t1507840899 I might have found just now what I was looking for then: https://www.reddit.com/r/haskell/comments/7bdyib/debugdo_does_this_already_exist_andor_should_this/dphkzlz/?context=10000
01:30:34 <muzzle> ertes-w: Thanks for clearing this up, but this seems like a weird design choice to me. Was the intention to not accidentally break code by enabling scoped type-variables?
01:30:45 <merijn> muzzle: Yes
01:31:04 <merijn> muzzle: Enabling SCTV in an existing file might break things for no reason if it is not opt-in
01:31:24 <merijn> muzzle: By making it explicit opt-in you can safely enable it in existing files without worrying about breaking code
01:32:14 <muzzle> Couldn't it possibly break code that was written using RankNTypes ?
01:32:39 <merijn> muzzle: No, because RankNTypes foralls are scoped to a part of the top level signature
01:33:18 <merijn> muzzle: RankN example: "(forall a . a -> a) -> b" 
01:33:34 <merijn> muzzle: The forall's scope is limited to the parenthesis, so doesn't logically extend to the where block anyway
01:35:32 <merijn> muzzle: Note that the entire forall thing isn't an ad hoc syntax hack, but actually a fundamental part of the underlying language used in GHC (Roughly based on System F_ω ), which has all these foralls in it explicitly.
01:36:52 <merijn> muzzle: "standard" Haskell2010 doesn't have them and they're added implicitly when the compiler converts from Haskell to it's IR language (Core, in the case of GHC), which does have them. The RankN extension just allows more of the underlying theory to bleed through into the Haskell sytnax
01:38:48 <muzzle> ertes-w, merijn: thanks, this has been really helpful!
01:40:32 <merijn> muzzle: And while I'm rambling: One of the reasons (perhaps the main one?) that RankN wasn't part of standard Haskell is because it is impossible to infer RankN types (Rank2 is theoretically possible, which is why there are separate Rank2 and RankN extensions), but practically speaking the Rank2 inference is so incredibly tricky and cumbersome, I don't think any language implements it or ever will, beyond 
01:40:34 <ertes-w> muzzle: ScTV could break RankNTypes code, because it allows you to use explicit 'forall' *without* making the scope available to local definitions
01:40:38 <merijn> the formal proof that it is possible
01:42:16 <muzzle> I think having ScTV enabled by default using the implicit forall would be clearer (at least it's what I would have expected default behaviour to be)
01:42:23 <merijn> ertes-w: But not in the sense that adding "ScTV" to a file that already has existing RankN would cause it to stop compiling, afaik?
01:43:06 <merijn> muzzle: Maybe, but GHC tries to (mostly) adhere to the 2010 report when extensions aren't enabled, and that behaviour would deviate from the report
01:43:06 <ertes-w> len :: forall a. [a] -> Int; len = myId . length where myId :: a -> a; myId x = x
01:43:27 <ertes-w> works with RankNTypes, ScTV breaks it
01:43:37 <ertes-w> because with ScTV the inner 'a' refers to the outer 'a'
01:43:53 <ertes-w> so 'len' can't instantiate it at Int
01:45:24 <ertes-w> ScTV makes myId monomorphic
01:52:27 <ij> I updated my arch, now I cannot build anything. The linker, ld, complains about something I don't quite understand. http://sprunge.us/KNVS (relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC).
01:53:20 <merijn> ij: Arch's Haskell setup is fucked
01:54:03 <merijn> ij: Step 1) annoy the Arch maintainer to not gratuitously break shit, Step 2) google around for "haskell arch" or something along those lines to find out how people managed to unbreak it
01:54:29 <cocreature> merijn: actually this is a different error and not the arch maintainers fault
01:55:08 <merijn> cocreature: Can I still blame them regardless? :)
01:55:26 <cocreature> merijn: sure they give us enough reasons to blame them :)
01:55:47 <cocreature> ij: do you have libtinfo installed?
01:56:07 <ij> Nope.
01:56:50 <ij> Hm, I have the file, I cannot find the package that owns it.
01:56:59 <cocreature> pacman -Qo filename
01:57:33 <ij> I do and ncurses owns it.
01:57:38 <frobnicator> ij: can you provide linker flags to the compiler
01:57:41 <frobnicator> if so add -no-pie
01:57:58 <cocreature> try installing ncurses5-compat-libs and run "stack setup --reinstall"
01:58:00 <frobnicator> it's a known problem, gcc >6 produces pie code and haskell can't handle it
02:12:45 <ij> tried that, still the same thing
02:12:47 <ij> cocreature, 
02:25:56 <humanoyd> why isn't there a `replicateA` function in Control.Applicative?
02:27:09 <merijn> humanoyd: Probably no one thought it important enough. You can trivially implement it as "sequenceA . replicate n" though
02:28:51 <verlet64> Yeah I cannot do Arch Linux
02:29:02 <verlet64> Set it up and honestly, it just got annoying after a while
02:37:31 <humanoyd> merijn: yeah, I'm just trying to get into the habit of using the least constrained functions (liftM -> fmap, mapM -> traverse, (>>) -> (*>) etc.) and found it odd that replicateM doesn't have a counterpart
02:51:09 <ij> frobnicator, cocreature, "ghc-build: nopie" helped
02:56:11 <ventonegro> @hoogle a -> m [a] -> m [a]
02:56:11 <lambdabot> Data.List intercalate :: [a] -> [[a]] -> [a]
02:56:12 <lambdabot> GHC.OldList intercalate :: [a] -> [[a]] -> [a]
02:56:12 <lambdabot> Distribution.Compat.Prelude.Internal intercalate :: () => [a] -> [[a]] -> [a]
03:00:16 <Maxdamantus> :t liftM . (:)
03:00:18 <lambdabot> Monad m => a -> m [a] -> m [a]
03:01:46 <ventonegro> Maxdamantus: Ah ha, I used fmap with a (:) section. Thanks :)
03:15:01 <Once_a_looser_al> what are tuples? what does it mean there is no singleton tuple
03:15:27 <liste> Once_a_looser_al: tuples are values of type (a,b), (a,b,c), (a,b,c,d) etc
03:15:31 <liste> there's no type (a,)
03:15:54 <liste> all tuples have 2 or more elements
03:16:03 <liste> so there's no singleton (1-element) tuples
03:16:10 <Once_a_looser_al> liste:  [(a,b),(a,b,c),(a,b,c,d)] throw an error
03:16:20 <liste> Once_a_looser_al: yes, because they're different types
03:16:21 <tdammers> arguably, scalars are singleton tuples
03:16:34 <Once_a_looser_al> I get no error when i write (3)
03:16:43 <Once_a_looser_al> (3) isn;t a singleton ?
03:16:46 <liste> Once_a_looser_al: yes, because that's just the value 3 in parenthesis
03:16:53 <liste> it's like writing (1+2)
03:17:06 <lavalike> :t (,)
03:17:07 <lambdabot> a -> b -> (a, b)
03:17:22 <lavalike> :t (,,)
03:17:24 <lambdabot> a -> b -> c -> (a, b, c)
03:17:30 <lavalike> =)
03:17:50 <tdammers> :t (1)
03:17:52 <lambdabot> Num p => p
03:17:58 <tdammers> :t 1
03:17:59 <lambdabot> Num p => p
03:18:10 <tdammers> > (1) == 1
03:18:11 <liste> Once_a_looser_al: (3) generally isn't thought of as a singleton *tuple* - but like tdammers said, you *could* consider it one
03:18:13 <lambdabot>  True
03:18:40 <tdammers> it depends what your concept of "tuple" is supposed to be
03:18:52 <lavalike> https://www.stackage.org/haddock/lts-9.12/ghc-prim-0.5.0.0/GHC-Tuple.html
03:19:00 <Once_a_looser_al> so tuple always should have (,) 
03:19:00 <mekeor> you could consider () as a zero-size tuple
03:19:08 <tdammers> one value is just one value; two values is a pair; three values is a triple (3-tuple); four values is a 4-tuple; etc
03:19:08 <Once_a_looser_al> , in between as I understand
03:19:11 <liste> Once_a_looser_al: yes, one or more commas
03:19:14 <lavalike> looks like GHC.Tuple does define the unary tuple, called Unit !
03:19:48 <Once_a_looser_al> Okay cool playing with haskell and it is not so hard as I thought/imagined
03:19:53 <liste> lavalike: which is very confusing, because () is the unit type
03:20:00 <tdammers> but in practice, it is more useful to consider only tuples of size 2 and up
03:20:21 <lavalike> Once_a_looser_al: it's pretty nice, the compiler errors really help
03:23:56 <saurabhn_> quick qn -- how can I generate haddock for a package that I'm editing locally?
03:24:12 <lavalike> it should be as simple as running haddock
03:25:51 <lavalike> haddock -o docs -h Foo.hs or thereabouts
03:26:05 <lavalike> open docs/index.html
03:29:04 <cocreature> "cabal haddock" or "stack haddock" if you’re working on a package instead of a single file
03:30:15 <royal_screwup21> what's the difference between https://thepasteb.in/p/y8h6oyz5GgQHO vs https://thepasteb.in/p/1jhnGEDNQ1PsB?
03:30:38 <texstex> hallo
03:30:41 <texstex> list
03:30:41 <saurabhn_> cocreature: let's try 'stack haddock'
03:30:55 <texstex> !list
03:34:24 <lavalike> royal_screwup21: the first one doesn't do what you think it does, I believe
03:34:28 <mekeor> royal_screwup21: in the first code, (Tree a) is neither in Eq typeclass nor in Ord typeclass.
03:34:42 <dminuoso> nshepperd: Oh turns out I found my mistake.
03:34:45 <Axman6> Do people really still do !list? I haven't seen that for many years
03:35:01 <mlehmk> I'd say the second one doesn't do what you want
03:35:02 <mekeor> Axman6: i don't even know what that means
03:35:22 <dminuoso> nshepperd: I rewrote my traverse to look like this: https://gist.github.com/dminuoso/077611857c42c71b28728702ea2bab03
03:35:24 <mauke> Axman6: italians ...
03:35:30 <liste> @list -- does it mean this ?
03:35:30 <lambdabot> No module "-- does it mean this ?" loaded
03:35:37 <mlehmk> "(Ord a, Eq a) => " qualifies what a needs to implement
03:35:46 <mekeor> i'd say none of those sources do what royal_screwup21 wants
03:35:46 <dminuoso> Though can you golf my traverse implementation any further?
03:35:48 <mlehmk> what is probably what you want
03:35:59 <Axman6> royal_screwup21: you really don't want the first one, you will have to put those constraints of _all_ functions which accept Tree s, even if they don't use Ord or Eq in their implementation
03:36:46 <Axman6> Tree a*
03:37:38 <Axman6> you end up with functions like size :: (Ord a, Eq a) => Tree a -> Int, which clearly doesn't need to know anything about the a's at all
03:37:39 <mlehmk> well if a of the Tree a needs to be sortable, what other ways to ensure it implements Ord and Eq?
03:38:09 <Axman6> by putting the constraint on the functions which need the constraint
03:38:10 <mlehmk> like without Ord, how to implement a sorted binary tree then?
03:38:14 <royal_screwup21> so I was looking to create a balanced search tree and I came across the first one on here https://gist.github.com/Kedrigern/1239141/5ee8f5f45facdf4f48785fc92a78ad4104f16537
03:38:29 <Axman6> insert :: Ord a => Tree a -> a -> Tree a
03:38:47 <Axman6> yeah don't do that
03:39:04 <dminuoso> Is there an equivalent for $ that has `infixl 0 what_goes_here?`
03:39:26 <mlehmk> Axman6, okay, what's the alternative?
03:39:55 <Axman6> to what?
03:40:04 <mlehmk> (Ord a) => Tree a
03:41:12 <Axman6> don't place any constraints on Tree at all. you can control what the user is allowed to do by what is exporte - if you want to ensure they cannot create an invalid tree, then you don't export the constructors of your Tree type, and export functions which maintain your invariants
03:43:18 <Axman6> module Foo.Tree (Tree, insert, lookup, delete, fromList, size) where data Tree a = ...; insert :: Ord a => Tree a -> a -> Tree a; insert = ...; lookup :: Ord a => Tree a -> a -> Bool; delete :: Ord a => Tree a -> a -> Tree a; fromList :: Ord a => [a] -> Tree a; size :: Tree a -> Int
03:43:51 <Axman6> by not exporting the contructors of Tree, the user must use the interface you have defined
03:44:26 <barrucadu> (also, even with an Ord constraint on the data type, people can create an invalid tree if you export the constructors)
03:44:53 <Axman6> (The other alternative it to use GADTs but I have a feeling that's not the best topic for the current audience)
03:46:07 <Axman6> barrucadu: indeed - having the constraint that the a's must be orderable does not guarantee that they will be ordered: you can happily write myTree = Node (Node Nil 100 Nil) 1 (Node Nil 20 Nil)
03:47:25 <Axman6> so what you _really_ want is a way to sat in the type system that the values on the left are all strictly less than, and the values on the right are strictly greater than, the value contained at a node, but we don't have a dependently typed type system so can't make types depend on values
03:51:50 <saurabhn_> oh shit, I'm in a non-stack project... what to do?
03:52:25 <osa1> stack init
03:52:30 <Axman6> heh
03:52:34 <Axman6> or, cabal configure
03:52:44 <Axman6> (maybe, if you're lucky, that might work)
03:52:49 <merijn> Or just "cabal new-build"
03:53:01 <Axman6> that too (muchmmore likely to work)
03:53:27 <cocreature> to this day I still have no idea when exactly one is supposed to call "cabal configure"
03:53:44 <saurabhn_> stack build, it just worked (tm)
03:54:03 <cocreature> "stack build" definitely doesn’t work in a non-stack project
03:54:39 <merijn> cocreature: You configure before building
03:55:16 <saurabhn_> sorry... that was "stack init && stack build" :)
03:55:35 <Axman6> and after changing dependencies
03:55:38 <cocreature> merijn: right but sometimes "build" seems to work without configuring. but you need to have dependencies installed before configuring so somehow configuring does not involve dependency resolution …
03:55:53 <merijn> cocreature: It does
03:56:01 <cocreature> anyway, I’m glad new-build gets rid of it
03:56:09 <Axman6> yeah that's the point of configure
03:56:11 <merijn> cocreature: If "build" just works you probably configured in the past and forgot
03:56:39 <cocreature> maybe, luckily it’s been a while since I’ve had to deal with it :)
03:57:10 <merijn> cocreature: I have to deal with it to get ghc-mod to work with my new-build projects >.>
03:57:27 <merijn> cocreature: I still haven't found a plugin setup that works with vim and new-build
03:58:46 <merijn> I don't even need all that much fancy, just error highlighting and the ability to query the type of an expression, but everyone who's bothering to implement those things isn't doing so on vim >.>
04:03:53 <royal_screwup21> so I want to check if an element exists in an unsorted tree. Here's what I tried: https://thepasteb.in/p/LghN9YRVPrWIZ Am I on the right track? It seems to work okay if I set my tree to be `tree1`
04:05:19 <cocreature> royal_screwup21: looks pretty reasonable
04:05:51 <cocreature> although personally I would just cheat and derive Foldable to get `toList` for free and then use the existing `elem` function on lists :)
04:06:56 <pranz> ^ what he said
04:07:35 <pranz> implementing Foldable, and/or traversable means you don't have to explicitly recurse the tree for future functions, which means simpler code and easier to understand
04:07:41 <pranz> you can just use the Foldable/Traversable functions
04:08:15 <Tehnix> I can't remember who was asking about doing stuff depending on which instances a value had, but I just discovered `ifCtx` from <https://github.com/mikeizbicki/ifcxt>
04:10:41 <lyxia> Tehnix: lots of people look for that functionality at some point
04:12:41 <EvanR> thats crazy and awesome
04:14:24 <ij> Does ghcjs use ghc?
04:14:44 <Axman6> yes
04:14:56 <Axman6> well, it's basically a backend for ghc
04:16:19 <Axman6> royal_screwup21: the code golfer in me wants to make it shorter: a == x || check x t1 || check x t2
04:20:17 <Axman6> Tehnix: that's really cool, and super useful
04:24:13 <Axman6> hmm, it's a shame it needs the template haskell stuff though
04:25:03 <Axman6> It'd be cool it you could write instance {-# OVERLAPS #-} ctx => IfCxt ctx where ifCxt _ t f = t
04:37:11 <dminuoso> ertes-w: Ohh heh. https://gist.github.com/dminuoso/077611857c42c71b28728702ea2bab03
04:37:14 <dminuoso> There we go, that looks cleaner.
04:37:48 <royal_screwup21> I want to write a function to create a BST so that I don't have to manually type out "node", "leaf" and deal with parens. I came across this: https://thepasteb.in/p/k5hYBqORJ0wHE The author of this function said that *isn't* a valid way to create a BST though. I'm curious why that's the case.
04:37:53 <dminuoso> So this is starting to become interesting
04:38:05 <ertes-w> dminuoso: go back to (<*>), then see if you can use the applicative laws to make this more concise
04:38:33 <ertes-w> dminuoso: with the specific goal of getting rid of (<*>) (and not just hiding it under liftA3)
04:40:45 <lyxia> royal_screwup21: "BST" means the nodes are sorted so that the left subtree has only nodes smaller than the root, and the right subtree has only nodes greater than the root
04:41:03 <royal_screwup21> oh yeah
04:41:59 <royal_screwup21> well so this isn't a BST at all, since the left and right nodes will always eb smaller than the root
04:42:39 <cocreature> sounds like a heap
04:43:06 <royal_screwup21> is there neat way to generate a random BST?
04:45:49 <lyxia> you can just keep track of the bounds in which the nodes must be and update it for recursive calls
04:48:46 <royal_screwup21> I see all these BST functions -  like "insert", "delete" and so on - but how does the author verify that it actually works on a given BST? Like this has got all everything related to BST https://gist.github.com/Kedrigern/1239141/5ee8f5f45facdf4f48785fc92a78ad4104f16537 but I can't find a single testing example
04:52:19 <saurabhn_> is there a quick way to generate a random WAI request for the purpose of testing?
04:52:25 <saurabhn_> automated testing, i.e.
05:01:33 <lyxia> royal_screwup21: It's a 100 line gist with a header that says "no guarantees"
05:02:25 <lyxia> It's unverified code.
05:02:47 <EvanR> who needs tests when you could include a proof
05:03:09 <royal_screwup21> welp
05:03:26 <EvanR> i am fascinated with the idea of proving code correct
05:09:12 <ventonegro> EvanR: Have you seen Idris?
05:09:19 <EvanR> yeah
05:10:10 <ventonegro> EvanR: edwinb's book is a very nice read :)
05:10:49 <EvanR> we went through that one for our reading group
05:11:40 <EvanR> now that its clear what it means to have a formal proof within a theory of dependent types, it would be nice to be able to actually do it
05:12:08 <EvanR> within the formal system or not. so far it seems very tedious and difficult 
05:12:16 <saurabhn_> stack haddock seems to work. Can it rebuild docs each time I save, and reload the browser? /cc cocreature
05:17:22 <lyxia> saurabhn_: each time you save what
05:17:33 <saurabhn_> the source file
05:17:35 <saurabhn_> I found it
05:17:38 <saurabhn_> stack haddock --file-watch
05:19:22 <saurabhn_> does anyone know why this is not showing up as common documentation on top of the three newtypes in the generated haddock? https://gist.github.com/saurabhnanda/8492ca2f013c227857385b7eac703781
05:27:14 <merijn> saurabhn_: Because that's just a comment and not haddock documentation?
05:28:33 <saurabhn_> merijn: I need to put a pipe - | - to make it haddock? if I do that, the comment gets added to the first type in the list. Not to that section.
05:29:18 <merijn> Sections should either be in the export list, or explicitly linked from the export list
05:29:22 <saurabhn_> I'm geting this https://www.dropbox.com/s/mopnpsyxukuw8qi/Screenshot%202017-11-08%2018.59.22.png?dl=0 -- but I want my docs to be immediately below the heading.
05:32:14 <hexagoxel> saurabhn_: http://haskell-haddock.readthedocs.io/en/latest/markup.html#controlling-the-documentation-structure
05:33:26 <nateb> I've hit a snag writing a Traversable instance.  A field in one constructor is a list, and some uses set this to an infinite list (which is consumed by `take n` elsewhere).  This is obviously impossible to sequence for most monads, and so traverse doesn't terminate.  Is there an effective workaround for this issue?
05:35:56 <saurabhn_> hexagoxel: thanks. got it to work.
05:36:28 <hexagoxel> saurabhn_: minor difference in what syntax you used, i suppose?
05:36:56 <saurabhn_> had to put a `$namedChunkOfDocumentation`
05:37:59 <hexagoxel> ah, i see.
05:49:27 <fendor> hey guys, is there a function of roughly the signature `Int -> [a] -> [[a]]` that works approximately like `foo 3 [1,2,3,4,5] == [[1,2,3], [2,3,4], [3,4,5]]`?
05:51:22 <mauke> :t chunksOf
05:51:24 <lambdabot> Int -> [e] -> [[e]]
05:51:32 <mauke> hmm, no
05:51:52 <phadej> > (\n -> map (take n) . tails ) 3 [1,2,3,4,5]
05:51:54 <phadej> is almost
05:51:54 <lambdabot>  [[1,2,3],[2,3,4],[3,4,5],[4,5],[5],[]]
05:52:26 <phadej> > (\n -> mapMaybe (Just . take n) . tails ) 3 [1,2,3,4,5]
05:52:29 <lambdabot>  [[1,2,3],[2,3,4],[3,4,5],[4,5],[5],[]]
05:52:49 <phadej> I'm sure there is something ready somewhere, but I don't remember :(
05:53:57 <fendor> yeah, think the same, something like groupof or something like that
05:54:02 <fendor> cant remember either
06:02:07 <caryoscelus> > (\n -> takeWhile ((== n) . length) . map (take n) . tails) 3 [1,2,3,4,5]
06:02:09 <lambdabot>  [[1,2,3],[2,3,4],[3,4,5]]
06:02:28 <caryoscelus> though i guess there's an easier way to do this
06:03:00 <fendor> hopefully :D 
06:03:07 <Tomsky> Hi all, I have a question about QuickCheck / SmallCheck.
06:03:17 <hexagoxel> yeah, via zip(with). also better asymptotic performance. this has n * length l.
06:03:45 <[exa]> :t zip3
06:03:46 <lambdabot> [a] -> [b] -> [c] -> [(a, b, c)]
06:04:01 <[exa]> oh you want lists of lists
06:04:04 <michalrus> data DiscreteChoice side =
06:04:07 <michalrus> Oops, sorry.
06:04:13 <Tomsky> QuickCheck tests a property against a set of randomly generated inputs. SmallCheck checks against inputs up to a certain size. I want to provide the full list of inputs to test the property against (there aren't that many). Does anyone know if that's possible?
06:05:50 <michalrus> Hey! If I have `data T ab = MkT { xy :: ?₁, zt :: ?₂ }`, can I somehow make `?₁` be `X` and `?₂` be `Z` when the user supplies `ab = A`; and `?₁` be `Y` and `?₂` be `T` when the user supplies `ab = B`? I suppose it’s impossible directly, but maybe there’s a way to emulate this?
06:06:43 <phadej> Tomsky: smallcheck with size big enough_
06:07:05 <eschnett> Tomsky: see https://stackoverflow.com/questions/16555291/how-to-use-smallcheck-in-haskell ?
06:08:26 <hexagoxel> > (\l -> let tl = tails l in zipWith (\x _ -> take 3 x) tl (drop 3 tl)) [1..10]
06:08:28 <lambdabot>  [[1,2,3],[2,3,4],[3,4,5],[4,5,6],[5,6,7],[6,7,8],[7,8,9],[8,9,10]]
06:08:30 <ertes-w> michalrus: your question has a kind error
06:08:45 <ertes-w> T :: * -> *
06:08:48 <[exa]> michalrus: either multiparameter type classes or type families. You basically want a type-level function
06:08:56 <ertes-w> ?₂ :: *
06:08:56 <lambdabot> Unknown command, try @list
06:09:04 <ertes-w> michalrus: ^
06:09:04 <michalrus> Yes. :c
06:09:08 <michalrus> Hmm.
06:09:14 <hexagoxel> but that's not asymptotically better. not sure if possible.
06:09:20 <[exa]> (if I parsed the question correctly)
06:09:36 <ertes-w> michalrus: once you fix that kind error, a GADT could probably do it
06:10:35 <ertes-w> michalrus: data T :: * -> * where MkTA :: X -> Z -> T A; MkTB :: Y -> _ -> T B
06:10:35 <Tomsky> eschnett: so I could easily write an instance that returns the list of values I want no matter what "depth" is asked for ... but isn't smallcheck then going to waste time testing the same thing over and over at different imaginary depths?
06:11:24 <michalrus> Nice! I’ll read about that finally, then. Okay, thank you, both! (ﾉ^_^)ﾉ
06:11:59 <eschnett> Tomsky: to my knowledge it will do what you need
06:12:05 <lavalike> with a data family you'd be able to have just one constructor MkT :: a -> b -> F a b right?
06:13:37 <Psybur> > L.transpose $ take 4 $ iterate tail [1,2,3,4,5,6]
06:13:40 <lambdabot>  error:
06:13:40 <lambdabot>      Not in scope: ‘L.transpose’
06:13:40 <lambdabot>      Perhaps you meant one of these:
06:13:45 <Psybur> > transpose $ take 4 $ iterate tail [1,2,3,4,5,6]
06:13:47 <lambdabot>  [[1,2,3,4],[2,3,4,5],[3,4,5,6],[4,5,6],[5,6],[6]]
06:15:17 <Psybur> > transpose $ take 4 $ iterate tail [1..]
06:15:19 <lambdabot>  [[1,2,3,4],[2,3,4,5],[3,4,5,6],[4,5,6,7],[5,6,7,8],[6,7,8,9],[7,8,9,10],[8,9...
06:15:43 <Psybur> u mirin? ;p
06:16:14 <fendor> that looks so complicated for such a simple function :D 
06:17:05 <ertes-w> > map (\x -> [x..x+3]) [1..]
06:17:07 <lambdabot>  [[1,2,3,4],[2,3,4,5],[3,4,5,6],[4,5,6,7],[5,6,7,8],[6,7,8,9],[7,8,9,10],[8,9...
06:17:19 <fendor> who, that looks nice
06:17:23 <fendor> *wooh
06:17:31 <lavalike> > unfoldr (Just . (take 4 &&& tail)) [1..]
06:17:33 <lambdabot>  [[1,2,3,4],[2,3,4,5],[3,4,5,6],[4,5,6,7],[5,6,7,8],[6,7,8,9],[7,8,9,10],[8,9...
06:17:55 <fendor> but not possible since it needs to work for arbitrary lists
06:18:00 <Psybur> > map (\x -> [x..x+3]) [1,7,9,66,99]
06:18:02 <lambdabot>  [[1,2,3,4],[7,8,9,10],[9,10,11,12],[66,67,68,69],[99,100,101,102]]
06:18:03 <ertes-w> it's better than any tail/take-based solution, because there is unnecessary sharing with that one
06:18:04 <Psybur> :P
06:18:43 <lavalike> mine only works on infinite lists :P
06:19:00 <fendor> lavalike, that would actually fit the use case :D 
06:19:05 <lavalike> yay!!
06:19:14 <ertes-w> if it has to work for arbitrary lists, then you're out of luck…  you're gonna use tail/take =)
06:19:16 <Psybur> > transpose $ take 4 $ iterate tail [-44,66,111,0,3]
06:19:18 <lambdabot>  [[-44,66,111,0],[66,111,0,3],[111,0,3],[0,3],[3]]
06:19:31 <ertes-w> > map (take 4) . tails $ [1..]
06:19:33 <lambdabot>  [[1,2,3,4],[2,3,4,5],[3,4,5,6],[4,5,6,7],[5,6,7,8],[6,7,8,9],[7,8,9,10],[8,9...
06:19:41 <lavalike> tails, good thinking
06:20:00 <Psybur> You win this time ertes-w !
06:20:14 * Psybur fist shake
06:20:30 <fendor> yeah, that seems to be the simplest solution...
06:20:33 <lavalike> I still like unfoldr every time I produce lists =)
06:20:41 <fendor> hehe
06:22:12 <ertes-w> =)
06:26:30 <lavalike> > unfoldr (liftM2 (>>) (listToMaybe . drop 3) (return . (take 4 &&& tail))) [1..6]
06:26:32 <lambdabot>  [[1,2,3,4],[2,3,4,5],[3,4,5,6]]
06:27:00 <Tomsky> eschnett: Ah okay yes it works because SmallCheck doesn't descend into lower depths unless you ask it to, it seems.
06:28:41 <Psybur> > unfoldr (liftM2 (>>) (listToMaybe . drop 3) (return . (take 4 &&& tail))) [1..21]
06:28:43 <lambdabot>  [[1,2,3,4],[2,3,4,5],[3,4,5,6],[4,5,6,7],[5,6,7,8],[6,7,8,9],[7,8,9,10],[8,9...
06:28:59 <Psybur> > unfoldr (liftM2 (>>) (listToMaybe . drop 3) (return . (take 4 &&& tail))) [1..9]
06:29:02 <lambdabot>  [[1,2,3,4],[2,3,4,5],[3,4,5,6],[4,5,6,7],[5,6,7,8],[6,7,8,9]]
06:29:04 <lavalike> :D
06:29:09 <Psybur> Whats the mysterious drop 3 about heh
06:29:20 <Boomerang> > fix ((:) [1..4] . map (fmap succ))
06:29:22 <lambdabot>  [[1,2,3,4],[2,3,4,5],[3,4,5,6],[4,5,6,7],[5,6,7,8],[6,7,8,9],[7,8,9,10],[8,9...
06:29:39 <ertes-w> > foldr (\x -> over (taking 4 traverse) (x:) . ([] :)) [] [1..]
06:29:41 <lambdabot>  [[1],[1,2],[1,2,3],[1,2,3,4],[2,3,4,5],[3,4,5,6],[4,5,6,7],[5,6,7,8],[6,7,8,...
06:30:03 <lavalike> > listToMaybe (drop 3) [7,8,9]
06:30:05 <lambdabot>  error:
06:30:05 <lambdabot>      • Couldn't match expected type ‘[Integer] -> t’
06:30:05 <lambdabot>                    with actual type ‘Maybe a1’
06:30:14 <lavalike> ooopsie-daisy
06:30:33 <lavalike> > listToMaybe (drop 3 [7,8,9])
06:30:35 <lambdabot>  Nothing
06:30:39 <Psybur> I see
06:31:24 <lavalike> ertes-w: over and taking are from Lens?
06:36:56 <martino> Hi!
06:37:35 <martino> I have an issue using repa-friday package
06:38:12 <martino> I'm currently using the  base package (v 4.9.1.0) 
06:38:30 <martino> repa-devil (sorry not repa-friday)
06:39:16 <martino> however repa-devil depends on transformers <0.5 that depends in base <4.9 
06:39:34 <martino> how I can solve this problem? Can I downgrade my base in the cabal configuration?
06:40:49 <martino> (here my cabal file http://lpaste.net/359886)
06:40:53 <edofic> @martino I think you need to use an older GHC to downgrade base
06:40:53 <lambdabot> Unknown command, try @list
06:41:31 <martino> ok so or I use a older ghc or I can not use the repa-devil package
06:42:53 <martino> what image loading libraries exists that could work on the last ghc
06:42:55 <martino> ?
06:43:24 <ventonegro> martino: JuicyPixels
06:43:45 <martino> ok I will try this one! Thank you!
06:46:42 <ertes-w> lavalike: yeah
06:47:56 <ertes-w> lavalike: i just had to write a foldr-based solution, because you know…  foldr is legion
06:48:35 <lavalike> (:
06:49:06 <lavalike> martino: the repa-devil package on hackage explicitly says "deprecated in favor of friday"
06:51:00 <martino> well also friday-devil has the same problem
06:51:13 <martino> (I actually first try with friday and friday-devil)
06:56:34 <lavalike> strange, https://hackage.haskell.org/package/friday depends on transformers <0.6 (not <0.5 like repa-devil or friday-devil) which in turn depends on base <6 (not <4.9 like those older transformers)
06:58:29 <martino> yes but I did not found the load function in friday but only in friday-devil
06:58:39 <martino> https://hackage.haskell.org/package/friday-devil-0.1.1.1/docs/Vision-Image-Storage-DevIL.html#v:load
06:59:48 <lavalike> I think you just provide your own pointer, let's see
07:02:37 <lavalike> oh wow https://github.com/RaphaelJ/friday/blob/master/README.md#load-and-save-images-from-and-to-files
07:03:09 <lavalike> so you're bound to use one or the other of those choices, and one is broken
07:03:38 <martino> I didn't saw the juicypixels  version
07:03:56 <lavalike> I think that one might work, it's got this constraint: base (>=4.6 && <4.10)
07:04:14 <martino> perfect :)
07:04:16 <lavalike> \o/
07:05:18 <lavalike> that does make sense, you could use the storable instance with a vector directly, but you also have to decode the image to a bunch of pixels first if it's in a non-bitmap format
07:08:22 <Psybur> How would I call generic vector maxIndex on a MVector (PrimState m) a ?
07:23:32 <ertes-w> > foldrM(\x->zipWith((.(x:)).(++))<$>inits<*>tails)[] "abc"
07:23:35 <lambdabot>  ["abc","bac","bca","acb","cab","cba"]
07:24:43 <ertes-w> foldrM saved a few extra characters =)
07:27:12 <Boomerang> > permutations "abc"
07:27:14 <lambdabot>  ["abc","bac","cba","bca","cab","acb"]
07:29:27 <ertes-w> Boomerang: not the same function =P
07:29:44 <Boomerang> Yeah not quite, I thought it would be at first glance :)
07:30:54 <ertes-w> ('permutations' is actually a much better function anyway, but it's not a good golfing function)
07:32:05 <ertes-w> > map (take 5) (permutations [0..])
07:32:07 <lambdabot>  [[0,1,2,3,4],[1,0,2,3,4],[2,1,0,3,4],[1,2,0,3,4],[2,0,1,3,4],[0,2,1,3,4],[3,...
07:32:21 <ertes-w> > map (take 5) (foldrM(\x->zipWith((.(x:)).(++))<$>inits<*>tails)[] [0..])
07:32:27 <lambdabot>  mueval-core: Time limit exceeded
07:32:47 <cocreature> how do I unset "-ddump-splices" in ghci?
07:32:54 <cocreature> (I tried :unset)
07:35:05 <michowski> Hey guys! I could not really find a definite answer to it. Is there any possibility, when compiling using Stack&GHC for Mac OS, to target Linux?
07:35:17 <glguy> no
07:35:26 <cocreature> maybe stack’s docker support works for this?
07:35:32 <michowski> Thanks!
07:38:45 <michowski> Do you know any efficient and "practical" way to cross compile your app for multiple platforms, like MacOS, Windows and Linux? The only thing I am aware of is VM and manual compilation for every single platform I want to support.
07:39:32 <michowski> The app itself is a very simple CLI and I assume there shouldn't be too many problems to run it everywhere.
08:28:03 <sm> michowski: you could use CI services
08:33:00 <dminuoso> ertes-w: So I've been staring at this for a real long while, and Ive been quite stuck on traverseX' f (V3 a b c) = pure V3 <*> f a <*> pure b <*> pure c
08:33:32 <dminuoso> Alongside I also obtained the simple equivalent traverseX''   f (V3 a b c) = (fmap V3 $ f a) <*> pure b <*> pure c 
08:33:51 <dminuoso> But I've been staring at those Applicative laws for so long, I really don't see how I can do anything further.
08:34:57 <dminuoso> Can you give me some form of hint without spoiling the task?
08:35:25 <ertes-w> dminuoso: you'll need two Applicative laws and one Functor law:
08:35:27 <dminuoso> The only law that is able to remove <*> is homomorphism, but because <*> is not associative I don't see how I can apply it
08:35:44 <ertes-w> 1. cf <*> pure x = ($ x) <$> cf
08:35:54 <ertes-w> 2. pure f <*> cx = f <$> cx
08:35:59 <dminuoso> ertes-w: Alright.
08:36:17 <ertes-w> 3. fmap f (fmap g cx) = fmap (f . g) cx
08:36:29 <ertes-w> also you'll need to use the fact that (<*>) is left-associative
08:36:56 <ertes-w> pure V3 <*> f a <*> pure b <*> pure c = ((pure V3 <*> f a) <*> pure b) <*> pure c
08:37:15 <dminuoso> Yeah, that "fact" has been weird. Also you missed a pure on the first law, didnt you?
08:37:25 <dminuoso> Thought it should be cf <*> pure x = pure ($ x) <$> cf
08:37:40 <ertes-w> nope…  have a closer look
08:38:09 <ertes-w> 1a. cf <$> pure x = ($ x) <$> cf
08:38:20 <ertes-w> 1b. cf <$> pure x = pure ($ x) <*> cf
08:38:24 <dminuoso> Oh!
08:38:26 <ertes-w> these are the same law
08:39:00 <ertes-w> the reason 1a and 1b are the same is because of law 2 =)
08:39:19 <dminuoso> Ahh yeah.
08:44:39 <iridium_> hi all
08:44:55 <iridium_> I am trying to use stack to install something it does not finish well
08:45:29 <iridium_> this stack install chatter
08:46:39 <barrucadu> Can you be more specific than "it does not finish well"?
08:47:14 <dsal> Anyone here know quickcheck shrinking well?  I'm trying to do something I'd expect to be simple, but failing.  I have an arbitrary instance which generates a hostname.  I want to be able to shrink the hostname when a test fails, but I can't figure out how quickcheck helps here.  I have  "www.haskell.org" -> ["www", "haskell", "org"] but I can't figure out what magic sensibly shrinks the components.
08:48:33 <iridium_> In the dependencies for chatter-0.9.1.0:     cereal-0.5.4.0 must match >=0.4.0.1 && <0.5.4.0 (latest applicable is 0.5.3.0) needed for unknown reason - stack invariant violated.
08:49:04 <Cale> dsal: I can't recall exactly, but I think the default shrink for lists either deletes an element at random, or shrinks an element at random
08:49:08 <sm> iridium_: check the issue tracker
08:49:18 <Cale> (picking from all those possibilities)
08:49:32 <iridium_> what does the message mean?
08:49:39 <sm> and bug the maintainer
08:49:58 <dsal> Oh.  I was trying genericShrink, I think, and it seemed to do something like that.
08:50:04 <Cale> > shrink [1,2,3]
08:50:07 <lambdabot>  [[],[2,3],[1,3],[1,2],[0,2,3],[1,0,3],[1,1,3],[1,2,0],[1,2,2]]
08:50:22 <dsal> Huh.  Maybe that is what I wanted.  It just didn't look right.
08:50:23 <Cale> > shrink ["www", "haskell", "org"]
08:50:26 <lambdabot>  [[],["haskell","org"],["www","org"],["www","haskell"],["","haskell","org"],[...
08:50:41 <Cale> > shrink ["a", "bc", "d"]
08:50:43 <lambdabot>  [[],["bc","d"],["a","d"],["a","bc"],["","bc","d"],["a","","d"],["a","c","d"]...
08:50:45 <ventonegro> ertes-w: What's the goal? No tie-fighters?
08:51:06 <Cale> > shrink "c"
08:51:08 <lambdabot>  ["","a","b"]
08:51:11 <dsal> Cale: Ah, it starts putting other random letters in there.
08:51:15 <Cale> yep
08:51:17 <dsal> That doesn't help me.
08:51:20 <Cale> because strings are lists
08:51:25 <dsal> Explains my confusion, though. heh
08:51:27 <ertes-w> ventonegro: of what?
08:51:32 <Cale> > shrink 'c'
08:51:34 <lambdabot>  "ab"
08:51:43 <ventonegro> ertes-w: The traverse puzzle
08:51:47 <dsal> I introduced an invalid letter into my generator and it told me my thing failed on a different invalid letter.
08:51:57 <sm> iridium_: it means that the dependency bounds specified by the cabal file and possibly stack.yaml file, and what's available in the stack resolver you're installing from, conflict. 
08:52:01 <ertes-w> ventonegro: learning lenses
08:52:04 <dsal> That behavior makes a lot of sense, except I need it not to take invalid letters.
08:52:11 <ertes-w> ventonegro: and also some general haskell training
08:52:29 <Cale> dsal: I wonder what the shrink for Text does
08:52:39 <Cale> dsal: If all else fails, you could make a newtype
08:52:51 <Cale> and just write shrink yourself :)
08:52:54 <ventonegro> ertes-w: I see
08:52:59 <iridium_> ok
08:53:44 <dsal> Yeah, I've already got a new type.  Writing the shrink myself.  :)  I just assumed the built-in stuff what do what I want.
08:54:10 <dsal> This is what I ended up with:
08:54:11 <dsal>   shrink (ArbitraryHostname h)
08:54:11 <dsal>     | h == "" = []
08:54:11 <dsal>     | '.' `elem` h = map ArbitraryHostname (split h)
08:54:11 <dsal>     | otherwise = map ArbitraryHostname $ (map (\h' -> take (length h - 1) h')) (tails h)
08:54:11 <dsal>     where split h = foldr (\x (w:ws) -> if x == '.' then [] : w : ws else (x:w):ws) [[]] h
08:54:58 <dsal> This is mostly just "see if I can do it" at this point, since the only thing that fails is my arbitrary generator.
09:01:47 <saurabhnanda> if one wants to build a benchmark suite, what's the recommended method? add a "test-suite benchmark" section to cabal?
09:03:51 <dsal> saurabhnanda: Yes, https://github.com/dustin/powerlab/blob/haskell/Powerlab.cabal#L53-L61
09:04:42 <saurabhnanda> dsal: thanks
09:05:37 <shafox> I am not able to typecheck this piece of code: https://gist.github.com/shadow-fox/488110759695dbf82b1ffee685857b82 
09:05:42 <dsal> OK, I think I've successfully built a shrinker that maintains structure, but shrinks.  It doesn't maintain constraints (I've not yet defined) yet, though.
09:13:00 <forker> spacemacs users: is there a way to show signatures for multiple terms at the same time? (I use C-x C-i to view type of a term on the cursor position)
09:16:51 <haskellnoob> why removeNonUppercase :: [Char] -> [Char]    this doesn't work in ghci
09:17:17 <haskellnoob> I have latest 8.2 version
09:18:08 <lyxia> haskellnoob: what do you expect that to do
09:32:13 <haskellnoob> lyxia:  declaring that function type
09:32:28 <haskellnoob> it works from editor after loading
09:32:32 <haskellnoob> but not in ghci
09:38:15 <saurabhnanda> i need to share some code between my test-suite and benchmark-suite (separate sections in cabal). How to do it? Unable to add 'exposed-modules' to test-suite section.
09:42:50 <lyxia> saurabhnanda: exposed-modules is only a library thing
09:43:07 <saurabhnanda> can I have multiple libraries in the same cabal file?
09:43:14 <lyxia> unfortunately not
09:43:22 <saurabhnanda> can't two executable/tests share some small amount of code?
09:43:25 <saurabhnanda> restrictive.
09:43:59 <lyxia> only through the library
09:50:17 <RGamma> Why is Tree a = a | Forest a and not directly defined as Tree a = a | [Tree a]? Wouldn't that be simpler?
09:50:54 <phadej> those are exactly the same, as it's type Forest a = [Tree a]
09:50:57 <phadej> and not newtype
09:51:08 <phadej> it just gives you a new word to use
09:51:51 <RGamma> So it's more for convenience?
09:51:55 <RGamma> Thank you
09:52:02 <phadej> yes
09:54:00 <cocreature> saurabhnanda: you can just put add reference the same source file for both
09:54:49 <portnov> hi all
09:55:28 <Mins> Hey, I need help. Here's the code with all explanation: http://lpaste.net/4799021282014265344
09:55:49 <Mins> I get a error with "file:.\Aufgabe_2.hs:16 - Improperly terminated character constant Hugs>"
09:57:25 <portnov> heh
09:57:44 <portnov> Mins: you added something in the beginning, so we have to guess where line 16 is :)
09:57:57 <cocreature> Mins: you want `quot` not 'quot'
09:58:02 <portnov> most probably it is complaining to 'quot', yes
09:58:12 <Mins> edited!
09:58:17 <portnov> any "persistent" specialists here?
09:58:31 <clever> Mins: i believe ' is only for single characters, not strings
09:58:31 <cocreature> portnov: you’re going to get better answers if you ask your actual question
09:58:46 <Mins> Okay, you're right
09:58:52 <portnov> is there a standard way to do "select .. where ... like ..."?
09:59:09 <portnov> I see "like" operator in esqueleto, but not in persistent itself
09:59:24 <mlehmk> Mins ` not '
09:59:29 <Mins> Yes
09:59:36 <Mins> Now I got "ERROR file:.\Aufgabe_2.hs:23 - Syntax error in declaration (unexpected `;', possibly due to bad layout)"
10:00:34 <cocreature> the last line of all of your guard statements is incorrect, you need "| otherwise = …"
10:00:57 <cocreature> also this is a lot simpler if you use pattern matching instead of guards
10:01:32 <Mins> How would it look like with pattern?
10:03:27 <portnov> well, and there is no selectFirst in esqueleto :/
10:04:20 <cocreature> Mins: something like this http://lpaste.net/359890
10:04:49 <mlehmk> the fst and snd are examples of pattern matching
10:05:34 <mlehmk> I wonder if using pattern matching like that fails the task
10:06:35 <mlehmk> I see that pattern with some teachers, when they give a task and it is solved efficiently deviating from their solution it is considered wrong, even if it produces the same result
10:09:30 <Mins> Thanks, they just look at the results of the programm
10:09:37 <Mins> Edited. "ERROR file:.\Aufgabe_2.hs:16 - Ambiguous variable occurrence "snd" *** Could refer to: RatOps.snd Hugs.Prelude.snd "
10:10:30 <Mins> Is my "Rat != (a, b)"? 
10:14:10 <mlehmk> no, snd is already in Prelude
10:14:40 <Mins> Ahh, ups
10:14:44 <mlehmk> Prelude is that part of haskell libraries that are already loaded into default namespace
10:15:40 <Psybur> Does haskell have an Interlude and Postlude? :D
10:19:11 <EvanR> https://hackage.haskell.org/package/interlude
10:19:40 <EvanR> http://haskellsmall.com/compositions/1987/fugue-and-postlude
10:19:47 <Psybur> Five years old and no maintainer :D
10:19:55 <Mins> It's working, thank you!
10:21:47 <Mins> It's reducing my rational number now... but "mulR (2,4) (-1,-2)" should have the result "(1,4)", but it's "(-1,-4)"
10:22:51 <EvanR> if you have a divMod somewhere maybe try quotRem
10:23:06 <Mins> I just used quot
10:23:35 <EvanR> who let negatives into number theory
10:23:44 <saurabhnanda> when using criterion, should I be using ng or whnf to ensure that laziness doesn't screw the results?
10:23:47 <Mins> Why is the gcd of -3 and -4 just 1?
10:24:05 <mlehmk> I think a gcd is always a natural number
10:24:06 <EvanR> there are different versions of gcd for negative
10:24:19 <dmj`> saurabhnanda: nf will fully evaluate the result
10:24:31 <saurabhnanda> dmj`: thanks
10:24:50 <dmj`> saurabhnanda: np
10:24:56 <byorgey> Mins: when you normalize (p,q) you probably also want to check whether q is negative, and if so just negate both p and q
10:25:02 <dmj`> whnf only evaluates to the outermost constructor
10:25:56 <EvanR> make denom always positive
10:27:41 <cocreature> do we have a "zipN :: Monoid a => [[a]] -> [a]" somewhere?
10:28:14 <EvanR> map mconcat ?
10:28:46 <cocreature> ah (map mconcat . transpose) works I guess
10:28:57 <cocreature> although I don’t want it to cut off it some lists are empty
10:29:07 <cocreature> > transpose [[1,2,3],[1,2]]
10:29:09 <lambdabot>  [[1,1],[2,2],[3]]
10:29:18 <cocreature> ah that looks right
10:29:21 <cocreature> thanks EvanR!
10:29:59 <EvanR> crazy jagged matrices
10:37:21 <_sras_> Using servant, how can I make an endpoint trigger a file download. I have managed to add the content disposition header. But not sure how to actually send the raw data.
10:38:09 <cocreature> _sras_: what kind of files are you sending?
10:38:42 <_sras_> cocreature: It is dynamically generated content of CSV format
10:39:01 <cocreature> sounds like you can use "Text" as the content type
10:39:06 <mivael> hello all
10:39:13 <mivael> I need an advise regarding how bad :-) this text parser design is: http://codepad.org/sK5TCOaX
10:39:13 <cocreature> eh PlainText
10:39:20 <mivael> I'm trying to design a simple text parser from scratch.  The goal is to have simple, Parsec/Attoparasec/Megaparsec independent, scalable code to use as a template for ad hoc text parsing when solving competitive programming problems.  (A side goal is to better understand (eventually) why Parsec/Attoparsec designs are as they are.)
10:39:32 <mivael> The most interesting is to have your opinions on casesFromLines and parseCases type signatures.  Is there something prematurely bad about such approach?  Specifically, I treat the parsing task as a function which transforms between parsing states, where parsing state in an envelop over a pair of values: (valueResultingFromPreviousParsingSteps, unparsedInput_aka_theRestOfUnparsedString).
10:41:59 <_sras_> cocreature: Is there anyway to send the raw bytestring?
10:42:31 <cocreature> _sras_: OctetStream should be the right thing in that case
10:43:23 <_sras_> cocreature: Compiles! Thanks
10:44:48 <saurabhnanda> how does one define an NfData instance for a function?
10:44:54 <_sras_> cocreature: Where is this stuff, for ex OctetStream documented?
10:45:57 <cocreature> saurabhnanda: 1. you don’t because it already exists 2. if you need that, you might want to double check that this is actually what you want
10:46:13 <cocreature> _sras_: https://hackage.haskell.org/package/servant-0.12/docs/Servant-API-ContentTypes.html
10:47:41 <raynold> Ahh it's a wonderful day
10:47:47 <saurabhnanda> cocreature: it's a type synonym of a function, actually
10:47:57 <saurabhnanda> for PGS.RowParser
10:47:59 <cocreature> saurabhnanda: instances don’t care about type synonyms
10:48:30 <cocreature> raynold: you seem to have a really nice life judging by how many wonderful days you have :)
10:48:39 <saurabhnanda> sorry, not a type synonm. It's a data type.
10:48:52 <cocreature> so it’s not a function?
10:49:15 <cocreature> either way in that case you can use the existing instances for function to define the one for the type you care about
10:49:53 <saurabhnanda> no, not a function
10:50:04 <saurabhnanda> not sure if I need a NfData instance for this - https://www.stackage.org/haddock/lts-9.12/postgresql-simple-0.5.3.0/Database-PostgreSQL-Simple-FromRow.html#t:RowParser
10:50:15 <saurabhnanda> https://www.stackage.org/haddock/lts-9.12/postgresql-simple-0.5.3.0/Database-PostgreSQL-Simple-FromRow.html#t:RowParser
10:50:37 <cocreature> whether you need the instance depends on what you are trying to do and you haven’t told us what that is :)
10:55:51 <saurabhnanda> will point you to the PR in a bit.
10:56:08 <saurabhnanda> does this make sense -- insatnce 
10:56:10 <Mins> How can I write another module which is using my first module?
10:56:15 <saurabhnanda> does this make sense -  rnf q = rnf $ show q
10:56:23 <erisco> Mins, import
10:56:24 <Mins> Should I write it in the same file or can I use another?
10:56:25 <saurabhnanda> for q, which is an instance of IString
10:56:32 <erisco> Mins, one module per file only
10:56:46 <saurabhnanda> does this make sense -  rnf q = rnf $ show q - for q, which is an instance of IString -- will it fully evaluate q?
10:57:12 <cocreature> depends on the Show instance
10:57:36 <erisco> what is rnf? looks like it evals to bottom
10:58:29 <fakenullie> @let rnf q = rnf $ show q
10:58:31 <lambdabot>  Defined.
10:58:36 <fakenullie> > rnf "hello"
10:58:43 <lambdabot>  mueval-core: Time limit exceeded
10:59:13 <Mins> How would a import for "addR" and "subR" look like?
10:59:15 <erisco> if the question is if whether q is evaluated in the recursive evaluation of rnf, then the answer is no, it is not
10:59:18 <Mins> For this:
10:59:19 <Mins> http://lpaste.net/4799021282014265344
10:59:51 <erisco> import RatOps
11:00:27 <erisco> import RatOps (addR, subR)
11:00:35 <erisco> import qualified RatOps as RO
11:01:17 <Mins> Thanks
11:01:30 <nshepper1> Defining rnf in terms of show doesn't sound efficient
11:01:36 <nshepper1> Even if it would work
11:02:28 <cocreature> nshepper1: heh, I was wondering that as well but I was too lazy to stare at core and see if GHC is able to make something efficient out of it at least in some cases
11:02:39 <erisco> Mins, to cross your i's and dot your t's, you should have an explicit export list for RatOps and explicit or qualified imports
11:03:24 <saurabhnanda> cocreature: https://github.com/tomjaguarpaw/haskell-opaleye/pull/347/files#diff-3a34ca03768d1566e4827c2be674da8eR60
11:03:45 <erisco> this is so that builds are less likely to break after definitions are added
11:04:18 <erisco> also, it is nice to see where definitions have been imported from
11:05:54 <cocreature> saurabhnanda: why are you benchmarking the creation of the query and the rowparser? it seems like what you want to benchmark is actually executing the query (including the time it takes to generate it)
11:06:24 <saurabhnanda> cocreature: that's next. tom has a hunch that even query generation is slow.
11:06:32 <cocreature> also if you use a trivial NFData instance for RowParser you can just as well use "fst" to throw it away
11:06:41 <saurabhnanda> cocreature: need to isolate the slowness to finely-grained steps.
11:06:49 <cocreature> and if you’re benchmarking listen to nshepper1 and don’t use show to implement NFData
11:07:43 <saurabhnanda> nshepper1: cocreature: how can I implement NFData for PGS.RunQuery (opaque wrapper on top of sttring-y data type)?
11:08:49 <cocreature> it’s not opaque, the constructor is exposed in Database.PostgreSQL.Simple.Types
11:09:12 <Mins> erisco: I don't how to just import the two.
11:09:35 <saurabhnanda> cocreature: ah thanks
11:11:15 <erisco> Mins, see my second import example
11:11:49 <Mins> Ah, got it
11:11:53 <Mins>  import RatOps (addR, subR) works...
11:12:49 <saurabhnanda> cocreature: nshepper1 -- this better? https://github.com/tomjaguarpaw/haskell-opaleye/pull/347/files#diff-3a34ca03768d1566e4827c2be674da8eR58
11:13:34 <saurabhnanda> does criterion run a few "warmup" rounds before recording final numbers?
11:13:40 <saurabhnanda> how many iterations does it run?
11:23:58 <Mins> What does it mean to import "qualified"? 
11:24:51 <Mins> Does it mean, if there's a function with the same name, it will not be imported?
11:25:51 <electrocat> Mins: if you do `import qualified Data.List`, you have to write `Data.List.sort` to use it's functions
11:25:55 <electrocat> and types
11:26:01 <Mins> Ah, thanks!
11:26:45 <electrocat> or you can do `import qualified Data.List as L` and then you can do `L.sort`
11:30:15 <erisco> import Data.Map (Map); import qualified Data.Map.Strict as Map
11:30:26 <erisco> that is a common pattern for several modules that you should know
11:30:33 <Mins> Okay, thank you!
11:31:15 <erisco> this imports the type  Map  and imports all definitions from Data.Map.Strict under the namespace also called  Map
11:32:25 <codeshot> does lambdabot have super hoogle powers?
11:33:43 <erisco> define "super"
11:34:02 <codeshot> I can't
11:34:07 <mud> It has @hoogle, but it's more just basic hoogle powers.
11:34:08 <codeshot> It's just a feeling
11:34:30 <codeshot> @hoogle (Monad m) => m a -> t m a
11:34:31 <lambdabot> Control.Monad join :: (Monad m) => m (m a) -> m a
11:34:31 <lambdabot> Streaming join :: Monad m => m (m a) -> m a
11:34:31 <lambdabot> Haxl.Prelude join :: Monad m => m (m a) -> m a
11:34:40 <codeshot> indeed
11:34:51 <codeshot> @hoogle (Monad m, MonadTrans t) => m a -> t m a
11:34:51 <lambdabot> Control.Monad.Trans.Class lift :: (MonadTrans t, Monad m) => m a -> t m a
11:34:51 <lambdabot> Yesod.Core lift :: (MonadTrans t, Monad m) => m a -> t m a
11:34:52 <lambdabot> Control.Monad.Morph lift :: (MonadTrans t, Monad m) => m a -> t m a
11:34:55 <codeshot> better
11:35:13 * codeshot opens IM with lambdabot
11:37:24 <dminuoso> ertes-w: Okay, after just deriving those slightly different laws from what Im used to, (the left associativity was obvious before you even mentioned it by the way), it turned out to be rather simple
11:37:27 <dminuoso> traverseX f (V3 a b c) = (($ b) . ($ c) . V3) <$> (f a)
11:37:35 <dminuoso> For some reason Im getting a redundant pattern match warning however
11:37:41 <dminuoso> It type checks and works.
11:38:11 <dminuoso> It's utterly amazing how all the applicative has disappeared.
11:40:37 <dminuoso> erisco: Turns out the main thing I just didn't see, was `fmap f (fmap g cx) = fmap (f . g) cx` because I was used to seeing this as `(fmap f) . (fmap g) = fmap (g . f)`, and it was not visually obvious to be useful.
11:40:44 <dminuoso> Ops, wrong recipient sorry.
11:41:01 <treebgx> When I attempt to run "stack build --coverage" I get the message "No tix files found in /home/name/codelocation/.stack-work/install/x86_64-linux-nopie/lts-8.21/8.0.2/hpc/, so not generating a unified coverage report."
11:41:10 <treebgx> Any thoughts on what's going wrong?  Google didn't turn up anything
11:42:13 <haskellnoob> removeNonUppercase :: [Char] -> [Char]   removeNonUppercase st = [ c | c <- st, c `elem` ['A'..'Z']]  
11:42:21 <haskellnoob> this is not working in tghci 
11:42:29 <haskellnoob> but working from editor why ?
11:43:27 <geekosaur> because the editor changes it to what ghci wants to see, which is all of it on one line with semicolons between
11:43:30 <haskellnoob> removeNonUppercase :: [Char] -> [Char]   I am also not understanding why declaring like this is a good style?
11:43:40 <lavalike> haskellnoob: you only need to input the definition in ghci, not the type
11:43:41 <geekosaur> and pssibly 'let' in front if your ghci is old enough
11:43:56 <betawaffle> is there a GHC extension that lets me put a type constraint that follows my type alias around?
11:44:03 <haskellnoob> let also not working
11:44:17 <lavalike> haskellnoob: if you input just the second line it will work
11:44:34 <geekosaur> and it's good style because the combination of laziness and polymorphism means you often get type errors where the typechecker sees the conflict instead of where you actually made a mistake
11:44:38 <haskellnoob> as soosn as I enter first line it throw error
11:44:43 <haskellnoob> so should I add ;
11:44:48 <lavalike> haskellnoob: the first line you can't type into ghci
11:44:49 <haskellnoob> after first line
11:44:50 <geekosaur> but if you state your types up front then it's more likely to spot it at the right time
11:45:21 <haskellnoob> and that first line making me scary
11:45:28 <lavalike> haskellnoob: you're asking it to evaluate the expression "removeNonUppercase :: [Char] -> [Char]" which is not going to work, because that identifier is not defined
11:45:33 <haskellnoob> should I declare like that  it will be very hard isn't it
11:45:49 <geekosaur>     let removeNonUppercase :: [Char] -> [Char]; removeNonUppercase st = [ c | c <- st, c `elem` ['A'..'Z']] 
11:45:52 <geekosaur> ...what?
11:46:02 <lavalike> haskellnoob: on the other hand, if you type just "removeNonUppercase st = [ ... ]" then it will add that binding and you can use it at the prompt thereafter
11:46:04 <erisco> why can I not find Natural
11:46:28 <erisco> GHC.Natural? oO
11:46:36 <haskellnoob> lavalike:  geekosaur  that first line os good style learnyouhaskell book says
11:46:50 <haskellnoob> but I am scared why should I declare everytime
11:46:54 <lavalike> haskellnoob: there is a difference between what you can type in an haskell source and what you can type in the interpreter
11:47:04 <geekosaur> I answered that
11:47:12 <haskellnoob> geekosaur:  where ?
11:47:20 <geekosaur> [08 19:44:12] <geekosaur> and it's good style because the combination of laziness and polymorphism means you often get type errors where the typechecker sees the conflict instead of where you actually made a mistake
11:47:30 <geekosaur> [08 19:44:28] <geekosaur> but if you state your types up front then it's more likely to spot it at the right time
11:47:49 <Mins> I need to work with "real numbers" in haskell. Do they mean "double" or are there real "real numbers" in haskell? 
11:48:00 <geekosaur> and I do not see what's so "scary" about it
11:48:36 <lavalike> Mins: usually Double does the trick (:
11:48:49 <Mins> Thanks! 
11:49:02 <haskellnoob> geekosaur:  how I will know which is what type in large programs
11:49:10 <geekosaur> Mins, there are no true "real numbers" inany language, only approximations of one kind or another. Double is *probably* what you want, but others are available in packages
11:49:55 <Mins> My task is to search for a maximal real number in a list. Idk, what they mean.
11:50:13 <geekosaur> haskellnoob, you build your large programs from smaller components which you can easily figure the type of, and then knowing the types of the components you can determine the types of the larger pieces you build out of those components
11:50:26 <betawaffle> Mins: where does a task like that come from?
11:50:31 <Mins> My teacher
11:50:34 <betawaffle> ahh
11:50:36 <Mins> -> Homework
11:50:43 <lavalike> that's a good source of tasks
11:50:53 <mauke> is the text of the assignment online?
11:51:00 <haskellnoob> now I understand why haskell is hard
11:51:07 <betawaffle> that sounds pretty trivial
11:52:15 <MagneticDuck> haskellnoob: Because it's typed?
11:53:00 <haskellnoob> MagneticDuck:  I need to declare type of function which I havn't seen in language like python or similar
11:53:09 <mauke> knowing the types is the easy part :-)
11:53:28 <mauke> in python you still need to understand what a function does, how many arguments it takes, what is what, etc
11:53:33 <haskellnoob> mauke:  what else is tough part then ?
11:53:35 <mauke> but the compiler can't help you with types
11:53:38 <mud> haskellnoob: Python things still have to have types in a sense, it just does less to help you figure out when you do it incorrectly (until it crashes while it's running)
11:54:12 <MagneticDuck> mauke: Wrong! You just declare a function, forget its preconditions, and ship buggy code.
11:54:12 <mauke> bonus (orthogonal) problem: in python, "unbound variable" is a runtime error
11:54:32 <mauke> i.e. python can't even detect typos in variable names
11:58:55 <geekosaur> haskellnoob, you can work out the types up front with tools to help you do it (like ghci), or you can wait until you get a runtime type error and then try to diagnose it without any help. I don't see how the first is harder than the second.
11:59:33 <geekosaur> or is this one of those cases of "never time to do it right, always time to do it over"?
11:59:45 <haskellnoob> geekosaur: I dont know may be I just started thats why I feel hard
11:59:53 <haskellnoob> I will try more and see
12:00:03 <mauke> the other thing is, adding type declarations to a large code base that doesn't have them is not a thing I've ever needed to do
12:00:16 <mauke> it's simply not a thing that happens in practice
12:00:42 <mauke> (also, you can do it piece by piece and the compiler will tell you if you get it wrong)
12:00:56 <[exa]> haskellnoob: there's this thing called a type hole, you can use it to see what type is expected where and what type is assigned to what
12:01:31 <[exa]> haskellnoob: just put _ instead of whatever you don't know and the compiler/interpreter will tell you what it would expect
12:01:38 <haskellnoob> [exa]:  is it a library ? I will use it later once I finish learnyouhaskell book
12:02:13 <[exa]> no, iirc it's built to ghc/ghci
12:02:20 <[exa]> > 1 + _
12:02:22 <lambdabot>  error:
12:02:22 <lambdabot>      • Found hole: _ :: a
12:02:22 <lambdabot>        Where: ‘a’ is a rigid type variable bound by
12:02:49 <mud> It doesn't do amazingly well in lambdabot, because the messages are fairly long.
12:02:53 <[exa]> oh seems I've triggered defaulting
12:03:03 <mud> But it's pretty cool in practice.
12:03:07 <[exa]> yep
12:03:40 <[exa]> haskellnoob: run ghci and put stuff with _'s into it, like `map _ [1,2,3]` or `_ 3 4 5` etc
12:04:48 <haskellnoob> ok [exa]  
12:06:00 <erisco> has anyone seen an implementation of quotient types like this? http://lpaste.net/359897
12:06:24 <erisco> I thought there was something on Hackage like this but now I don't see it
12:06:42 <lorproas> In GHCi, I'm setting -fbreak-on-exception and trying to Ctrl+C out of an infinite loop, and GHCi hangs.
12:06:43 <dminuoso> Is there some way of golfing `($ b) . ($ c) . f` into something even more concise?
12:06:50 <lorproas> It doesn't hang if -fbreak-on-exception isn't set.
12:06:53 <lorproas> Any thoughts?
12:07:01 <erisco> :t \b c f -> ($ b) . ($ c) . f
12:07:02 <lambdabot> a1 -> a2 -> (a3 -> a2 -> a1 -> c) -> a3 -> c
12:07:20 <erisco> is that the right argument order, dminuoso?
12:07:52 <dminuoso> Ohhhh. Its not in fact :o
12:08:29 <Guest94699> hi, Can somebody explain to me what type of functions is this: "(->) t a". What I understand is it's a function that has the first argument "t a", but what about it's result ?
12:08:32 <dminuoso> erisco: How did you spot that?
12:08:52 <erisco> probably by accident, since I don't know what it is that I spotted
12:09:07 <dminuoso> `(($ c) . ($ b) . V3)` is proper now
12:09:11 <erisco> Guest94699, that is equivalence to  t -> a
12:09:36 <dminuoso> :t \b c f -> ($ c) . ($ b) . f
12:09:38 <lambdabot> a1 -> a2 -> (a3 -> a1 -> a2 -> c) -> a3 -> c
12:09:42 <Guest94699> erisco: t and a are basic types ? 
12:09:47 <dminuoso> This looks right now.
12:09:56 <erisco> Guest94699, what is a "basic type"?
12:10:00 <geekosaur> they;re unknown types, with only that information
12:10:05 <Guest94699> erisco, like Int, Char 
12:10:15 <erisco> Guest94699, they could be
12:10:41 <Guest94699> not like Maybe a, or Either a b 
12:10:47 <erisco> could be those, too
12:11:28 <Guest94699> erisco, thanks
12:12:05 <erisco> dminuoso, \a -> V3 a b c
12:14:50 <dminuoso> erisco: Huh?
12:14:56 <erisco> the only other thing that comes to mind is ~> and an operator I came up with ~>$
12:15:13 <dminuoso> erisco: Let me show you the context
12:15:33 <dminuoso> erisco: https://gist.github.com/dminuoso/16dbce74596339108b3d3f73f5c713a5
12:17:00 <erisco> \x -> V3 x b c  then, though I'm not so opposed to shadowing
12:17:56 <dminuoso> erisco: What Im curious is how you arrived at that? This looks suscipiciously correct.
12:18:17 <erisco> put into English what  ($ b) . ($ c) . f  is about
12:18:48 <erisco> or swap b and c I guess
12:20:14 <erisco> if the term isn't clear, though it can be, then just look at the type
12:20:22 <dminuoso> create a function, that applies f to its argument, and then apply it to b, and then apply it to c
12:20:37 <dminuoso> Okay, Ill look at the type again :)
12:21:05 <erisco> yeah, exactly, and  \x -> V3 x b c  has the same description
12:21:27 <Mins> How can I make a list, which get a number (3) and make a list with [3, 6, 9, 12, ...]?
12:21:47 <erisco> Mins, what do you mean by "get a number"?
12:21:55 <Mins> Get a result
12:22:11 <erisco> by "get" do you mean read from stdin? do you mean it is an argument?
12:22:12 <Psybur> > [3..6]
12:22:15 <lambdabot>  [3,4,5,6]
12:22:16 <Psybur> ops
12:22:18 <mud> You want to have a function that will give you the multiples of a given number or something?
12:22:21 <Psybur> > [3,6..]
12:22:24 <lambdabot>  [3,6,9,12,15,18,21,24,27,30,33,36,39,42,45,48,51,54,57,60,63,66,69,72,75,78,...
12:22:35 <Mins> I calculate it
12:22:42 <Psybur> Mins is that what you mean?
12:22:53 <erisco> okay, and how did you determine the interval from 3 to 6?
12:23:00 <Mins> Yes, but idk what the number is.
12:23:07 <Mins> Wait... I'll try to explain it...
12:23:10 <Psybur> > (\x -> [x,2*x,..]) 3
12:23:13 <lambdabot>  <hint>:1:15: error: parse error on input ‘..’
12:23:18 <Psybur> > (\x -> [x,2*x..]) 3
12:23:21 <lambdabot>  [3,6,9,12,15,18,21,24,27,30,33,36,39,42,45,48,51,54,57,60,63,66,69,72,75,78,...
12:23:32 <Psybur> > (\x -> [x,2*x..]) 4
12:23:34 <lambdabot>  [4,8,12,16,20,24,28,32,36,40,44,48,52,56,60,64,68,72,76,80,84,88,92,96,100,1...
12:23:44 <Psybur> Like that?
12:24:15 <betawaffle> is there a more concise way to write this? https://gist.github.com/betawaffle/34c5c1af11e7f63620596ae99cf14146
12:24:21 <betawaffle> (the quad function)
12:24:24 <Mins> I got two lists with [x, 2*x, 3*x, 4*x, ...] and [y, 2*y, 3*y, 4*y, ...] and need to find the "Set" of these two
12:24:37 <Mins> Eh, not Set
12:24:50 <Psybur> step?
12:24:50 <Mins> Intersection!
12:25:26 <eikke> ocharles: could I bother you with a question about prometheus-effect?
12:25:27 <erisco> I think you can solve this better with a bit of maths
12:25:32 <Mins> So basically it's the least common multiple of the list. And the multiples of it.
12:26:13 <Psybur> > intersect [1,2,3] [4,3,2]
12:26:16 <lambdabot>  [2,3]
12:26:28 <MP2E> quad s p o c = Quad <$> intern s <*> intern p <*> intern o <*> intern c               perhaps?
12:26:40 <Mins> I need to write my own function for this. @Psybur
12:27:18 <Psybur> Mins, define own then? Prelude only?
12:27:38 <Mins> http://lpaste.net/5777162365275471872
12:27:38 <mlehmk> there should be a lazy intersect for sorted lists, too
12:27:44 <Psybur> Copy the source from Data.List :D?
12:28:13 <erisco> betawaffle, I have a feeling uniplate (http://hackage.haskell.org/package/uniplate) can help, but I am not familiar enough with the lib to tell you more
12:28:20 <Mins> intersect [1.0, 2.0, 3.0] [1.5, 3.0]
12:28:38 <Mins> > intersect [1.0, 2.0, 3.0] [1.5, 3.0]
12:28:38 <Psybur> Mins, you forgot to start with "> "
12:28:40 <lambdabot>  [3.0]
12:29:02 <Mins> Hm. Idk, if I "can" use the intersect function.
12:29:19 <Mins> I needed to write a "maximum" function for lists. I could also use "maximum"
12:29:25 <Mins> Or "max"
12:29:30 <Psybur> Homework? :D
12:29:33 <Mins> Yep.
12:29:45 <Psybur> Im telling your professor! :D
12:29:58 <Mins> Go and tell him!
12:29:58 <erisco> since you know x and y, why not just generate the list after determining the lcm?
12:30:27 <Mins> I'm asking how to generate the list after getting the lcm 
12:31:01 <erisco> fmap (lcm *) [1..]
12:31:17 <Mins> THANKS!
12:31:21 <erisco> though repeated addition might be smarter
12:31:26 <dminuoso> erisco: But this is interesting. I like the fact that my version is point-free. :)
12:31:41 <dminuoso> Although \x -> V3 x b c  is just far more expressive.
12:31:57 <Psybur> > fmap (4 *) [1..]
12:31:59 <lambdabot>  [4,8,12,16,20,24,28,32,36,40,44,48,52,56,60,64,68,72,76,80,84,88,92,96,100,1...
12:32:13 <Psybur> > map (4 *) [1..]
12:32:15 <lambdabot>  [4,8,12,16,20,24,28,32,36,40,44,48,52,56,60,64,68,72,76,80,84,88,92,96,100,1...
12:32:20 <Psybur> Why the f? xD
12:32:38 <erisco> > let lcm = 3 in iterate (+ lcm) 0
12:32:40 <lambdabot>  [0,3,6,9,12,15,18,21,24,27,30,33,36,39,42,45,48,51,54,57,60,63,66,69,72,75,7...
12:32:57 <mlehmk> fmap is the generic mapping function on functors?
12:33:05 <Mins> ERROR file:.\Aufgabe_5.hs:24 - Type error in guarded expression *** Term           : fmap (x *) (enumFrom 1) *** Type           : [Double] *** Does not match : Double
12:33:06 <erisco> or  lcm +  I dunno
12:33:08 <mlehmk> while map is for []
12:33:15 <Psybur> Yes, but why use it here? Its one more character :D
12:33:29 <mauke> Mins: is that a hugs error?
12:33:35 <Mins> Yes, wait
12:33:44 <mlehmk> because map shouldn't exist and fmap should be just called map
12:33:55 <Mins> http://lpaste.net/5777162365275471872
12:34:01 <betawaffle> erisco: i figured it out, i wanted: return Quad `ap` intern s `ap` intern p `ap` intern o `ap` intern c
12:34:06 <Mins> With the error
12:34:32 <Mins> A element of a List is a List..?
12:34:33 <Psybur> mlehmk, that may be the case but no need to waste characters for us folks at the base of your ivory tower :D?
12:34:40 <erisco> betawaffle, well that is just what MP2E suggested to you
12:35:07 <betawaffle> erisco: didn't see it :(
12:35:10 <mauke> Mins: beware, hugs hasn't seen a new release in 11 years. it's basically dead
12:35:17 <mauke> no one uses it anymore
12:35:22 <mlehmk> also, comparing floats is kind of flaky
12:35:35 <Psybur> mmmm zombie hugs
12:35:57 <mlehmk> two floats that should be the same can still differ due to rounding errors
12:36:04 <Mins> I need to use Hugs 98. So 19 years.
12:36:25 <erisco> you mean that two floats you wish were the same are not the same ;)
12:37:08 <mauke> Mins: :-(
12:37:10 <mlehmk> erisco, not wish, but actually should be the same, like (1.0/5.0 + 1.0/5.0 + 1.0/5.0 + 1.0/5.0 + 1.0/5.0) compared to 1.0
12:37:17 <mauke> Mins: please tell your teacher that ghci exists
12:37:33 <zoug_> anyone here ever use WebDriver?
12:37:57 <erisco> I am nitpicking the idea of "should", because the fact they are not equal does not disagree with the IEEE standard
12:38:23 <mlehmk> erisco, indeed
12:38:27 <zoug_> I need to know if there is control over tabs offered, because all I see is window manipulation, which doesn't seem to have the desired effect on tabs
12:38:50 <sternmull> i want to write/read some haskell values to/from a handle (a TCP stream). For writing i think it is clear: I can use cereal to build a ByteString from the value and write that (maybe with a length prefix). For reading i am not sure if there is an utility-function to read individual values or if i "manually" have to read a length, then the actual ByteString of the next value and then deserialize this. What do you think?
12:38:58 <mlehmk> thus Eq on floats does not really do what you want
12:39:06 <verement> > (1.0/5.0 + 1.0/5.0 + 1.0/5.0 + 1.0/5.0 + 1.0/5.0) == 1.0
12:39:08 <lambdabot>  True
12:39:33 <geekosaur> Mins, dunno what that was supposed to be doing, but the error is 'correct'; you are mapping an operation over a list of Double, which produces a list of Double, but your type signature says Double not [Double] 
12:39:56 <Mins> How can I get my Double out of the List? :D
12:40:10 <mlehmk> const []
12:40:24 <geekosaur> which Double?
12:40:40 <geekosaur> I still don't know what that is supposed to be doing, so I can't answer that
12:40:42 <Mins>  The x
12:41:00 <geekosaur> ...?
12:41:13 <erisco> > 1.0/49.0*49.0 == 1.0
12:41:14 <geekosaur> you are mapping (+ x) over an infinite list. how was that supposed to give you x?
12:41:15 <lambdabot>  False
12:41:45 <geekosaur> oh, I see there is more scrollback about this
12:41:53 <Mins> I have two sets. I intersect them, so I got the lcm of them.
12:42:14 <Mins> Instead of intersect the whole list, I want to multiply x 
12:42:35 <Mins> Idk how "Vielfachmengen" is translated properly. 
12:42:54 <Mins> Basically you got [x, 2*x, 3*x, 4*x, 5*x]. And I got two lists like that.
12:43:43 <mlehmk> should be: schnitt :: [Double] -> [Double] -> [Double]
12:43:51 <[exa]> Mins: vielfachmengen is multichannel mixing?
12:43:53 <betawaffle> uhg, haskell is so nice: https://gist.github.com/betawaffle/34c5c1af11e7f63620596ae99cf14146
12:43:56 <mlehmk> cause the intersection of two [] is also a []
12:45:02 <Mins> exa: Eh... no? It's a set of number, which is multiplied with [1..]
12:45:19 <[exa]> Oh deutsch. :]
12:45:24 <mlehmk> though, the fmap doesn't make sense in otherwise =
12:45:58 <Mins> mlehmk: I thought I got the element of the List. Because of "(x:xs)" I take the element of the list. 
12:46:08 <mlehmk> it should instead prepend either x or y in front of schnitt xs ys
12:46:12 <erisco> do you know an lcm algorithm?
12:46:21 <mlehmk> like (x:schnitt xs ys)
12:46:42 <erisco> if you take just the heads of each list, compute the lcm of the heads, and now generate the list of multiples of the lcm
12:46:44 <mlehmk> maybe even without ()
12:47:01 <mlehmk> once you manage to wrap your mind around that way to see it
12:47:28 <Mins> Ah, got it!
12:47:40 <mlehmk> first you want to just eat whatever is in only one or the other list, then you want to emit what is true and append the recursion
12:48:28 <Mins> No, I don't got it
12:48:29 <Mins> :D
12:48:37 <mlehmk> btw, the empty lists are not errors, you could just return empty lists if either is empty
12:49:31 <Mins> My teacher wants the errors.
12:50:16 <[exa]> throw them at him.
12:51:02 <mlehmk> it look like we're better at teaching you haskell than your teacher
12:51:17 <erisco> > 1/6.0 + 1/6.0 + 1/6.0 + 1/6.0 + 1/6.0 + 1/6.0 == 1.0
12:51:18 <lambdabot>  False
12:51:40 <mauke> > 1/6.0 + 1/6.0 + 1/6.0 + 1/6.0 + 1/6.0 + 1/6.0 == (1.0 :: Rational)
12:51:42 <lambdabot>  True
12:51:52 <Mins> He's not teaching us. He learns us how functional programming is and we need to learn haskell once a week.
12:51:53 <erisco> don't be so rational
12:52:19 <mlehmk> "get real" - "be rational"
12:52:36 <tdammers> "it's complex"
12:53:11 <mlehmk> that doesn't make sense in english
12:53:22 <[exa]> let me scare you using a common scheme
12:53:25 <[exa]> (inexact->exact 0.1)
12:53:31 <[exa]> => 3602879701896397/36028797018963968
12:54:01 <MP2E> D:
12:54:11 <erisco> > toRational 0.1 -- aka
12:54:12 <mlehmk> ohh
12:54:13 <lambdabot>  3602879701896397 % 36028797018963968
12:54:27 <mauke> > toRational (1/0)
12:54:29 <lambdabot>  1797693134862315907729305190789024733617976978942306572734300811577326758055...
12:54:34 <[exa]> cool!
12:54:40 <mlehmk> ohh, error
12:54:41 <Mins> [A..]
12:54:44 <mlehmk> infinity is not a number
12:54:44 <Mins> >[A..]
12:54:52 <erisco> I always knew infinity began with 179769…
12:55:02 <mauke> > toRational (0/0)
12:55:04 <lambdabot>  (-26965397022934738615939577861835371004269654684134598591014512173659901370...
12:55:20 <fakenullie> 1/0 is not infinity
12:55:35 <mauke> > 1/0
12:55:35 <erisco> I always knew NaN began with -26965…
12:55:37 <lambdabot>  Infinity
12:55:40 <[exa]> it's a projective infinity
12:55:43 <mauke> fakenullie: you were saying?
12:55:45 <mlehmk> I know that the result of the product of all factorials n! from n in [0..] ends in an infinite amount of 0
12:55:48 <fakenullie> Heh
12:56:17 <mlehmk> actually
12:56:20 <fakenullie> That's wrong
12:56:35 <mlehmk> scrap that, simplify with, product of all natural numbers ends in an infinite amount of 0
12:56:41 <Mins> I still don't know how I could do that http://lpaste.net/edit/5777162365275471872
12:56:42 <Mins> :D
12:56:56 <fakenullie> > (1/0)-(1/0)
12:56:58 <lambdabot>  NaN
12:57:06 <ertes> i always knew that graham's number is infinite
12:57:23 <mlehmk> Mins, you are still trying to return a single double, where schnitt is a [Double]
12:57:25 <codeshot> > toRational $ sum $ [1..]
12:57:32 <lambdabot>  mueval-core: Time limit exceeded
12:57:32 <codeshot> Hoping to get 1/12
12:57:36 <codeshot> -1/12
12:57:39 <mlehmk> Mins, also gave you the solution for the otherwise part earlier
12:57:53 <erisco> you just have to run it longer
12:58:00 <fakenullie> You need to use specific summation method to get that
12:58:00 <[exa]> Mins: [1..] is returning integers, (x*) expects Double. (note there aren't automatic conversions in haskell)
12:58:06 <Mins> like (x:schnitt xs ys)
12:58:08 <mlehmk> no, you have to put it into a solver to get -1/12
12:58:10 <Mins> that?
12:58:33 <ertes> i bet you need the axiom of choice to get -1/12
12:58:36 <mlehmk> Mins, and fixing the type description
12:58:49 <[exa]> ertes: you need to discard that and several other axioms in fact :D
12:59:09 <ertes> really?  you can get -1/12 constructively?
12:59:11 <MarcelineVQ> keep in mind that computer functions are mostly for computable things
12:59:31 <[exa]> the meme method isn't constructive?
12:59:38 <erisco> I thought you just had to add some hairbrained ideas about infinite sums
12:59:44 <mlehmk> ertes, yes, you need to explain, how to map an infinite set onto the set of all natural numbers and how you can take or add to the beginning of that infinite set
12:59:59 <mlehmk> which explains what a countable infinity is then
13:00:25 <ertes> anyway, it's non-sense
13:00:55 <mlehmk> then how comes that infinities like sum [1..] == -1/12 even have an application in physics?
13:00:55 <[exa]> erisco: yeah, you need to discard anything that would lead to infinite measures that would tell you that zipping infinity with infinity/2 is unfair
13:02:12 <mlehmk> besides, oddly the sum of all 2^n with n in [0..] results into -1
13:02:18 <hodapp> errr, it doesn't actually *equal* -1/12 (or anything), it is its analytic continuation that equals -1/12
13:02:27 <mlehmk> that's like intrinsic two-complement
13:02:43 <[exa]> I was afraid of this moment. :]
13:02:59 <ertes> mlehmk: i would buy that, but we're no longer talking about standard integers with standard arithmetic
13:03:10 * ystael deletes the number -1/12 from Q so no one can ever say this again
13:03:36 <mlehmk> -1/12 doesn't exist in Q^+ anyway
13:05:23 <erisco> you need to make counter YouTube videos
13:05:44 <mlehmk> and given the result of (+) of two elements of the set N is also member of the set N, you cannot get a member of the set Q-
13:05:49 <mlehmk> that just doesn't make sense
13:05:52 <Mins> Funny. When I try to use it like a List, I get a error with "it's a Double".
13:05:55 <erisco> remember when reply videos showed up under the original?
13:06:14 <mnoonan_> mlehmk: that reasoning only works for finitely many terms being added
13:06:28 <mlehmk> yet, the way the set of sum [1..] is modified is very convincing
13:06:46 <mlehmk> mnoonan_: that reasoning is inductive
13:07:01 <mlehmk> though feel free to point to the error in that induction
13:07:05 <mnoonan_> mlehmk: yes, so you have inductively proven it for any *finite* number
13:07:34 <erisco> now use coinduction
13:07:39 <mlehmk> then when turns finit to infinite? Is this the moving arrow paradoxon of infinities?
13:09:22 <mlehmk> this trail of thought turns out to be interesting
13:09:36 <mnoonan_> no, the point is that your argument is fine for finite sums but says nothing about infinite sums. and there are many interesting ways to extend to the infinite case.
13:09:39 <erisco> if induction is a staircase, then it lets you point at any stair and say how you climb to there, but it doesn't have anything to say about climbing forever
13:10:12 <benzrf> ^
13:10:22 <MarcelineVQ> erisco: though of the stairs go down you may eventually reach a bottom so with that assumption a lot of things are possible
13:11:32 <erisco> proof by infinite descent
13:12:09 <mlehmk> you need to have a bottom for induction, or it wouldn't work
13:12:28 <mlehmk> countable infinities have a bottom
13:12:57 <RedMachine> co-induction
13:13:23 <dsal> I'm have a strangely specific bug and I'm not sure whom to blame.  I have a docker image that builds a bare bones dev env for ARM.  If I try to run stack as a command directly upon startup, I get a sig4 (illegal instruction) from qemu.  If I run it any other way, it's fine.  e.g.   'stack test' fails, but '/usr/bin/env stack test' is fine.
13:13:42 <RedMachine> Is your PATH correct?
13:14:23 <geekosaur> env uses $PATH too
13:14:24 <dsal> I can give it the exact path to stack and it gives me an illegal instruction.  If I run it via /usr/bin/env, it's fine.
13:14:37 <mlehmk> although, I see it, the reverse of x + y, of x,y in N result N is not required. Two numbers from Q can result into an element that is in N
13:14:55 <codeshot> numberphile has a lot to answer for
13:14:56 <MagneticDuck> mlehmk: ... and uncountable infinities don't "have a bottom"? 
13:15:14 <mlehmk> MagneticDuck, I haven't witnessed an uncountable infinity with a bottom yet
13:15:33 <RedMachine> What's the full error other than just "sig4"?
13:15:36 <MagneticDuck> What's a "bottom" of an infinity?
13:15:50 <erisco> codeshot, that is what I was referring to… though I heard it before then
13:16:03 <mlehmk> MagneticDuck, a countable inifite set can map onto the set of natural numbers, before 1 would be the bottom
13:16:25 <MagneticDuck> Any infinite set can map onto N. O_o
13:16:35 <dsal> RedMachine qemu: uncaught target signal 4 (Illegal instruction) - core dumped
13:16:38 <mlehmk> No, an uncountable infinity cannot map onto N
13:17:17 <dsal> Something between docker, qemu, and stack fails if I run stack first, but is fine if I run stack from something else.
13:17:39 <mlehmk> even if you think you mapped all elements of an uncountable infinity onto N, you can still find an element in the uncountable infinity that didn't map onto N
13:17:48 <geekosaur> Cantor diagonalization
13:18:09 <mlehmk> for example
13:18:14 <MagneticDuck> *Any infinite set can map onto N.* That is one possible definition of an infinite set.
13:18:24 <MagneticDuck> Do you know what surjectivity is?
13:18:34 <mlehmk> I guess you forgot "countable" in that definition
13:19:03 <mnoonan_> wait, watch this: f :: R -> N, f x = 0 :)
13:19:13 <MagneticDuck> Please look this up online before you embarass yourself further.
13:19:21 <mlehmk> Like how would the set of all positive real numbers map onto N?
13:19:25 <[exa]> dsal: illegal instruction? what's your software's build flags?
13:19:42 <MagneticDuck> s/embarass/embarrass
13:19:44 <geekosaur> MagneticDuck, I might recommend the same to you
13:19:53 <geekosaur> specifically the phrase I mentioned
13:19:58 <mlehmk> And I don't even need to look it up
13:20:01 <hodapp> MagneticDuck: it's not necessary to be that condescending.
13:20:18 <erisco> I think MagneticDuck has been clear on their particularity to surjectivity, not bijectivity
13:20:29 <dsal> [exa]: it fails immediately.  No build files necessary.
13:20:32 <mlehmk> I wouldn't even know how to pick the start in the set of positive real numbers
13:20:57 <erisco> an ad-hoc rescue? disguised pedantry? who knows!
13:20:58 <mlehmk> and even if I would pick 1 for example, how to pick a next number from that? The set of positive real numbers is dense
13:20:59 <[exa]> dsal: can you find the command line of qemu?
13:21:13 <dsal> Probably.  It just hangs.
13:21:20 <mlehmk> between any two distinct real numbers in another real number
13:21:25 <[exa]> mlehmk: I'd pick 0.0000000000000....000000000001, that will have the best response here
13:21:57 <dsal> It looks like it's just   /usr/bin/qemu-arm-static /usr/local/bin/stack
13:22:52 <mlehmk> btw, Q maps onto N, R is too large
13:22:55 <nshepper1> I don't like the term "onto" as used for surjectivity
13:22:58 <RedMachine> dsal: are you running this as root? If this is an RPi (most forums deal with it on the Pi)
13:23:01 <MagneticDuck> mlehmk: Even ignoring our quibble on onto versus one-to-one functions, it's notable that there are uncountable well-ordered sets. It's certainly not obvious, but it's quite true.
13:23:10 <[exa]> dsal: and if you run it by hand then it works?
13:23:20 <nshepper1> If i put my book onto the table, that doesn't mean it covers the whole table
13:23:38 <mlehmk> an uncountable well-ordered set I can think of at first is the set of all real numbers
13:23:39 <dsal> RedMachine: I'm doing fancy uid mapping on Linux.  On OS X it's... whatever that does.  They both think they're root.
13:23:57 <mlehmk> real numbers cannot be mapped onto N, yet it is well ordered
13:24:06 <dsal> [exa]: If I just stick /usr/bin/env at the beginning of the command, it works fine.  I don't have the stack stuff outside of the container.
13:24:18 <mnoonan_> mlehmk: what about abs(floor(x))? do you agree that maps R onto N?
13:24:40 <mlehmk> mnoonan_, ohh, there's the error. What I mean is maps both ways
13:24:49 <mnoonan_> ding :)
13:25:05 <mlehmk> so for any \y -> f x, there's also a \x -> g y
13:25:10 <hodapp> it is a 1:1 mapping you refer to, right?
13:25:22 <[exa]> dsal: maybe look at export
13:25:23 <mlehmk> err
13:25:30 <mlehmk> you know what I mean, even if I broke haskell syntax
13:26:18 <mlehmk> I mean, f x = y, there's also a g y = x
13:26:33 <erisco> easily described as 1) surjective/onto and 2) injective/one-to-one
13:26:43 <mlehmk> okay
13:26:59 <mlehmk> that betters my knowledge of terminology
13:27:08 <nshepper1> Say "bijection", "injection" and "surjection" and it'll stop being so confusing
13:27:50 <johnw> or say iso, mono and epi, and we can be more confusing :)
13:27:53 <mlehmk> what's bijection?
13:27:58 <benzrf> inj + surj
13:28:08 <benzrf> i.e. inverse relation is also a function
13:28:09 <mlehmk> how does + work in that case?
13:28:16 <benzrf> conjunction
13:28:19 <hodapp> just means both injective and surjective
13:28:33 <benzrf> ur right i shouldve said inj * surj
13:28:34 <benzrf> :(
13:28:35 <mlehmk> okay, do you have an example of injective that is not surjective?
13:28:36 <erisco> it works like  pop + fries = lunch
13:28:53 <hodapp> erisco: that is not a proper lunch :(
13:28:54 <benzrf> sums are disjunction, products are conjunction... i fucked up
13:29:08 <dsal> I'm seeing if #docker knows what's up with this.  I've got my repro here:  https://gist.github.com/dustin/ea787ad087ca31817fd592e001dbd5b2
13:29:16 <erisco> hodapp, what if the fries are a poutine?
13:29:16 <benzrf> mlehmk: (*2) on the integers
13:29:19 <mlehmk> ohh wait, inj * surj makes sense again
13:29:27 <mlehmk> inj + surj does not to me
13:29:34 <hodapp> o_O I don't see why * or + would matter there
13:29:48 <geekosaur> heh
13:29:48 <benzrf> i was being a little bit facetious, i didnt think the distinction would make sense to someone who doesnt even know what inj and surj mean >w>
13:30:05 <mlehmk> because any descripton of inj is also surj, but you can create a bij from inj * surj
13:30:12 <benzrf> what
13:30:24 <erisco> en anglais, we pronounce "+" as "plus", so an abbreviation is to write "+" instead of "plus"
13:30:26 <benzrf> mlehmk: (*2) on the integers is injective and not surjective
13:30:30 <hodapp> injective doesn't imply surjective
13:30:43 <erisco> and a meaning of "plus" is "and"
13:30:54 <mlehmk> and bijective is (1/) on rationals?
13:30:55 <benzrf> erisco: heresy!
13:31:16 <erisco> I didn't write the rules, I am just reporting on them
13:31:17 <benzrf> mlehmk: (1/) is not defined on rationals, but if you restrict to rationals without 0, then yes
13:31:19 <hodapp> mlehmk: or just pick something simple like (+1) on integers
13:31:21 <mlehmk> or (0-) on integers
13:31:47 <mlehmk> isn't (+1) injective?
13:31:47 <erisco> I guess Copernicus didn't win with that argument either
13:31:51 <MagneticDuck> mlehmk: Since we're in #haskell, you're expected to know what a map is injective exactly when it verifies the left-cancellative law, i.e. f g = f h implies g = h for all pairs g, h. :)
13:31:57 <benzrf> mlehmk: yes, bijective means both injective and surjective
13:32:06 <hodapp> mlehmk: (+1) is injective, yes. It's just also surjective, and this bijective.
13:32:10 <benzrf> MagneticDuck: what an internal characterization
13:32:32 <benzrf> MagneticDuck: if you were a true math nerd you'd characterize it in terms of having a left inverse, smdh
13:33:09 <MagneticDuck> No, left inverses are first semester stuff. Now I'm a category theory nerd -- injections are monomorphisms on the category of sets.
13:33:15 <benzrf> wait.
13:33:50 <benzrf> oops, my bad - i assumed the space there was application, not composition
13:34:03 <benzrf> monic and split monic are different anyway in general though
13:34:13 <mlehmk> okay, https://en.wikipedia.org/wiki/Bijection,_injection_and_surjection makes sense now
13:34:13 <benzrf> and split monic certainly implies monic
13:34:16 <benzrf> mlehmk: :)
13:34:35 <mlehmk> so (+1) on natural numbers is injective but not surjective
13:34:46 <mlehmk> and (+1) on integers is bijective
13:34:52 <benzrf> yes
13:35:11 <erisco> you can check your Haskell proficiencies here: https://www.cs.utexas.edu/~cannata/cs345/Class%20Notes/10%20Haskell%20Programmer%20Evolution.html
13:35:15 <mlehmk> injective, doesn't map onto the same, surjective, maps onto completely
13:35:33 <mlehmk> bijective is the exact 1:1
13:35:46 <benzrf> injective means fibers have at most one element, surjective means fibers have at least one element, bijective means fibers have exactly one element
13:36:04 <mlehmk> same thing different words
13:36:09 <benzrf> indeed
13:36:23 <MagneticDuck> There are so many ways to take this. Injective means the map can be codomain-restricted into a bijection, surjection means the map can be domain-restricted into a bijection.
13:36:33 <hodapp> sorry, could you just explain this in terms of a burrito?
13:36:50 <mlehmk> Ahh... I finally get it
13:37:07 <mlehmk> why there is no thing like "flamewar" in haskell compared to different topics
13:37:55 <mlehmk> haskell is things as they are, other topics are things as you intepret them
13:38:27 <mlehmk> like cannot disagree on facts, but sure can fight over which opinion is right
13:38:56 <hodapp> pffffffffft
13:39:20 <MagneticDuck> mlehmk: Maybe you're thining about the hard science / soft science dichotomy.
13:39:35 <erisco> why debate facts when you can attack the words used to describe them? what does "fact" mean anyways?
13:39:57 <dminuoso> :t getConst $ traverse Const [1]
13:39:58 <lambdabot> (Num a, Monoid a) => a
13:40:02 <dminuoso> What is this? :o
13:40:14 <mlehmk> we need alternative facts, also known as fiction
13:40:29 <benzrf> dminuoso: unclear what youre asking
13:40:57 <hodapp> look, all I'm saying is, we don't actually know who is paying erisco to say things like this
13:41:13 <mlehmk> facts are descriptions of truths, I guess
13:41:28 <hodapp> and for some reason, we never hear the mainstream media asking questions about this
13:41:39 * hodapp looks suspiciously at erisco
13:41:42 <dminuoso> benzrf: for some reason I expected to get [1] back
13:41:48 <benzrf> dminuoso: don't you?
13:41:50 <benzrf> oh wait no
13:42:06 <benzrf> remember, traverse is fmap followed by sequenceA
13:42:15 <benzrf> so first we go from [1] to [Const 1]
13:42:19 <benzrf> then we sequence this
13:42:29 <benzrf> do you have a clear picture of sequencing for the const functor?
13:42:39 <benzrf> *applicative
13:43:38 <mlehmk> const x, eats argument and gives x, while id just passes argument...
13:43:44 <benzrf> mlehmk: different const
13:43:56 <mlehmk> I haven't understood the Const x thing yet
13:44:16 <dminuoso> benzrf: Hope its fine if I think on this before I answer. ;-)
13:44:20 <erisco> it is degenerate
13:44:22 <benzrf> yup!
13:45:03 <mlehmk> is it what ever I fmap over a Const 1, I get a 1?
13:45:15 <benzrf> dminuoso: just rememebr that the only instance for Const involved in sequencing is Const's applicative instance
13:45:34 <benzrf> the Traversable instance is list-specific, it does the same thing for every applicative - so it only matters what the applicative is like
13:46:06 <erisco> Const is different than const, and yet is similar
13:46:14 <mlehmk> wait
13:46:22 <dminuoso> erisco: It feels like a `const` of endofunctors.
13:46:36 <benzrf> you really dont need the word "endofunctor" there
13:46:40 <mlehmk> I always thought a Const 1 would be similar to a Just 1... but a it's actually a Const a b, not just Const a
13:46:55 <mlehmk> so a Const 1 and Just are the similar classes
13:47:06 <erisco> const constructions constant functions
13:47:23 <erisco> const constructs constant functions … try to get my suffixes correct
13:48:31 <dminuoso> If its also a constant endofunctor, does that mean it would transform all objects into one object. And morphisms into id?
13:48:44 <benzrf> yes, that's correct
13:49:15 <benzrf> however, "Const A" is probably not actually a constant endofunctor
13:49:40 <benzrf> actually, wait - my bad.
13:49:51 <benzrf> it's constant up to isomorphism, which is the correct non-evil concept :)
13:50:10 <dminuoso> benzrf: as it is always in category theory it seems. :-)
13:50:29 <benzrf> dminuoso: do you know what Const's Applicative instance looks like?
13:51:57 <erisco> ignoring the Monoid bit, Const is like Proxy
13:52:04 <benzrf> the monoid bit is the important part here, though
13:52:10 <dminuoso> benzrf: No, but I think I need to figure this out on my own.
13:52:14 <benzrf> alright!
13:52:14 <mlehmk> how to destruct a functor again? Like how to get from Just 1 to 1 and from Const 1 a to 1?
13:52:29 <benzrf> dminuoso: that's the key part, though.
13:52:34 <dminuoso> mlehmk: You cant generally "destruct" a functor without losing information.
13:52:37 <dmwit> mlehmk: Depends on the functor. For `Maybe` there is `maybe`.
13:52:58 <mlehmk> So I really have to use getConst on a Const?
13:53:05 <dmwit> mlehmk: For `Const` there is `getConst`.
13:53:15 <erisco> there is also coerce
13:53:19 <mlehmk> mmm...
13:53:35 <dmwit> mlehmk: Why is using getConst seem like a bad thing to you?
13:53:43 <dmwit> s/is/does/
13:53:51 <benzrf> btw, id just like to take the moment to remind everyone that whenever you talk about haskell types being endofunctors, you are not actually saying anything that we can make mathematically rigorous and still be talking about haskell http://math.andrej.com/2016/08/06/hask-is-not-a-category/
13:54:22 <mlehmk> dmwit, not a bad thing, I was just thinking if there was a general way
13:54:22 <johnw> benzrf: we use it in a fast-and-loose-yet-mostly-moral sense
13:55:08 <dmwit> mlehmk: No, there is no way which is general across all `Functor`s, because a `Functor` instance `f` need not have the property that there is exactly one `a` in an `f a`.
13:55:21 <mlehmk> could I use Const a b in a monadic way? Like would operations on that Const a b be on b, but if I getConst on it, it'd give me a?
13:55:22 <dminuoso> mlehmk: To see why, look at a counter example:
13:55:42 <dmwit> mlehmk: (Indeed, even `getConst :: Const a b -> a` does not get a `b` out of a `Const a b`!)
13:55:46 <dminuoso> mlehmk: How do you "deconstruct" [1,2,3,5] to get a single value back? You cant without folding.
13:55:53 <benzrf> johnw: one sec, let me find a token for my bingo board
13:56:25 <mlehmk> if I fmap (Const x) onto it?
13:56:25 <johnw> benzrf: :)
13:56:41 <mlehmk> uhm >.<
13:56:59 <erisco> johnw, benzrf I assume everyone has read this article, but reminding that the author acknowledges the usefulness of the moral use
13:57:03 <mlehmk> I just get it
13:57:11 <dmwit> mlehmk: Yes, there is a `Monad` instance for `Const`. Yes, the operations would "use" values of the second type argument to `Const`. Yes, `getConst` would return a value of the first type argument to `Const`.
13:57:17 <mlehmk> there is no deconstructing []
13:57:18 <erisco> not sure when it became "moral" rather than "fast and loose"
13:57:30 <erisco> kind of an oxymoronic change if you ask me
13:57:33 <johnw> well, I said mostly moral
13:57:35 <benzrf> erisco: i know, but i think its important to keep in mind that ultimately youre not really doing math
13:57:37 <dmwit> mlehmk: I put "use" in quotes because there is never an actual value of the second type argument floating around to use. =P
13:57:42 <mlehmk> there are so many different ways to get a single value from a []
13:57:49 <MagneticDuck> mlehmk: In a sense, the signature of fmap says that you can "touch" the "contents" of the functor, but the result that you "pull back" is "wrapped" in the functor.
13:57:52 <mlehmk> two examples might be sum and length
13:57:58 <benzrf> thats why i didnt say "...remind everyone that you're being useless" :)
13:58:16 <benzrf> anyway bbl
13:58:16 <mlehmk> that's why there is no generic deconstructor for funtors
13:58:34 <mlehmk> Then a Maybe can be Nothing, there is no value to get from it
13:58:56 <mlehmk> but a Maybe could be passed through a function or maybe not
13:59:06 <erisco> not all Functors have constructors, so there's another problem with that plan
13:59:59 <mlehmk> if Maybe is Just a value, the value can be passed through the function and wrapped into a Maybe constructed with Just, or the maybe is Nothing so nothing happens
14:00:12 <dmwit> ?src fmap Maybe
14:00:12 <lambdabot> Source not found. Just try something else.
14:00:15 <dmwit> ?src Maybe fmap
14:00:15 <lambdabot> fmap _ Nothing  = Nothing
14:00:15 <lambdabot> fmap f (Just a) = Just (f a)
14:00:27 <dmwit> mlehmk: The machine-readable version of what you just said. =P
14:00:40 <mlehmk> hah, that's what I like with functional programming, you learn it by "reinventing" functional programming, cause it is such a low level
14:01:22 <mlehmk> cannot learn Monads, you have to invent them, given by clues from sources
14:01:59 <mlehmk> oh wait, that's on a fringe
14:02:10 <mlehmk> it's awesome
14:02:42 <MagneticDuck> mlehmk: More generally this is a thing about math -- to learn it, you have to figure it out for yourself. Haskell is just a special case :)
14:02:50 <mlehmk> reminds me of twilight zone, outer limits or x-files, haha
14:03:06 <mlehmk> Fringe
14:03:22 <erisco> if you want to get a value out, use extract, which depends on being a Cofunctor
14:03:35 <geekosaur> ?
14:03:41 <geekosaur> Comonad?
14:04:15 <erisco> yeah, which depends on being a Cofunctor
14:04:27 <mlehmk> fmap kinda extracts it, but with Const a b it'd extract the b
14:04:38 <erisco> I was expecting a laugh or a groan… oh well
14:05:13 <infinisil> Is there a parser combinator library for the command line?
14:05:16 <mlehmk> fmap seems to be the generic "destructor" I was looking for
14:05:17 <hexagoxel> is there some (directed)graph-construction MonadFix (Arrow?) where the interface enforces that i specify the incoming edges for each node present in the graph?
14:05:23 <nopnut> hey guys, im new to haskell
14:05:29 <nopnut> i need to run 2 functions inside of main
14:05:33 <nopnut> how can i do this?
14:05:50 <erisco> nopnut, no idea, need more information, but maybe  main = x >> y
14:06:05 <hexagoxel> main = do { print (f x); print (g y) }
14:06:43 <nopnut> erisco: my current main looks like main :: IO (); main = runlights test_data
14:06:44 <mlehmk> What kinds of bugged me is, I could somehow implement parts of lenses by just signatures without actually understanding what I did
14:06:57 <mlehmk> which also included using Const
14:07:15 <mlehmk> Like I don't know what I did, but it works
14:07:17 <nopnut> but id like to do something like main = runlights runcar test_data test_data_1
14:07:52 <erisco> explain in English, because I don't know what that means
14:09:15 <erisco> also have you started on one of the Haskell beginner resources? though admittedly they probably do not get to clarifying main for a while
14:10:42 <michalrus> Hm, if I have `type family TF a b where ; TF Int Int = String ; TF String String = Int ; data D a b = D (TF a b)`, how can I autoderive `Eq` for `D`? It works for a `TF` with just one parameter.
14:10:58 <mlehmk> main is on the IO monad, so going into haskell by this programming style doesn't learn you anything
14:11:24 <mlehmk> I'd start haskell beginning with what's pure and extend from there
14:11:51 <mlehmk> simple functions, pattern matching, lists, ...
14:11:57 <gmalecha> does anyone know if there is a way to prevent GHC from eta-expanding type applications
14:12:22 <gmalecha> i have a variable of type `:: forall l. C l => f l -> a`
14:12:26 <mlehmk> going from lists to functors, applicative, monad
14:12:54 <mlehmk> once you had the monad, you can implement main
14:13:04 <gmalecha> and i have a newtype, `newtype Post a = Post (forall l. C l => f l -> a)`
14:13:10 <gmalecha> but i can't write `Post var`
14:13:24 <gmalecha> GHC complains that the l's don't match
14:13:39 <hexagoxel> nopnut: we don't know what those functions/values do nor what their types are. Its like asking "given f,g,a,b i'd like to obtain a natural number".
14:14:12 <hexagoxel> (in a mathy context instead of haskell)
14:14:20 <mlehmk> actually main :: IO ()
14:14:39 <mlehmk> thus, given f,g,a,b I'd like to obtain IO ()
14:15:23 <hexagoxel> .. no, i wanted to give a non-haskell equivalent.
14:15:41 <mlehmk> if runlights :: a -> IO ()
14:16:05 <mlehmk> and test_data :: a
14:16:08 <MarcelineVQ> gmalecha: where does f come from in the newtype
14:16:12 <hexagoxel> (wasn't it allowed to have main :: IO a?)
14:16:31 <erisco> michalrus, I don't know… but is it that big a deal?
14:16:41 <mlehmk> hexagoxel, it is explicitly declared to be main :: IO () earlier
14:17:01 <gmalecha> MarcelineVQ: just suppose it is a parameter
14:17:09 <mlehmk> well, then I still don't know what runcar is
14:17:25 <MarcelineVQ> but I can't test examples that don't run :X
14:17:46 <gmalecha> the real type is `newtype Post (ρ :: Row *) (ω :: *) = Post (forall l. KnownSymbol l => (ρ :! l) -> ω)`
14:17:49 <erisco> gmalecha, lpaste your code. I think maybe you've misunderstood a quantifier
14:17:51 <MarcelineVQ> why does this made up thing not work is a different question than why does my actual think not work you see
14:18:11 <mlehmk> I'd understand if it was like: main = runlights $ runcar test_data test_data_1
14:18:20 <mlehmk> then runcar :: a -> a -> a
14:18:47 <nopnut> erisco: main = a >> b worked
14:18:49 <nopnut> thank you
14:19:10 <erisco> nopnut, no problem, have fun
14:19:37 <michalrus> erisco: I don’t know yet, standalone deriving doesn’t won’t either. I can just write all of them by hand, but… I dunno.
14:19:39 <mlehmk> ohh, I think I got another thing about haskell here
14:19:52 <mlehmk> this explains why some things didn't work out when I began haskell
14:20:04 <erisco> michalrus, what do you mean by "all of them"? don't you just need one instance?
14:21:38 <michalrus> I meant writing standalone deriving for all cases, like: `deriving instance Show (D Int Int) ; deriving instance Show (D String String)`. Then everything works, but this feels silly. :p
14:22:01 <mlehmk> ohh
14:22:10 <michalrus> With one type parameter for TF, I can just write `deriving instance Show (D a)` and it’s OK.
14:22:34 <michalrus> While `deriving instance Show (D a b)` won’t compile.
14:22:42 <erisco> why not write an instance yourself?
14:23:18 <nopnut> erisco: btw, the tutorials im reading show to print strings you must do main = putStrLn
14:23:29 <nopnut> how can i print a string if my main is something else already?
14:23:39 * michalrus scratching head
14:23:45 <mlehmk> nopnut, IO ()
14:24:07 <mlehmk> you gotta wrap into IO with return
14:24:31 <erisco> nopnut, putStrLn is a function which takes a String and returns an IO action (to print the String to stdout). You can use multiple putStrLn's, and sequence them with other IO actions, using >> for example
14:27:47 <michalrus> I don’t know how to write an instance myself, hmm. ANything I try won’t compile. `instance Show (D a b) where show = _`. Hmmm. `const "D"` works, obviously, but I’d like it to do what Show Int and Show String do. :P
14:28:07 <betawaffle> is there a generalization of (:) for any monoid?
14:28:42 <erisco> betawaffle, : is not relevant to the list Monoid
14:29:07 <betawaffle> yeah... which is sort of the problem
14:29:34 <betawaffle> i've got a thing that's building a lazy list right now, but i was wondering if i could generalize it
14:29:58 <erisco> you may be seeking Alternative
14:30:07 <erisco> > pure 1 <|> [2,3]
14:30:09 <lambdabot>  [1,2,3]
14:30:14 <betawaffle> ok, cool
14:30:39 <erisco> x : xs == pure x <|> xs   particularly
14:31:00 <erisco> why am I using == again… whatever
14:31:01 <nopnut> erisco: so i have main :: IO () and main = runlights data
14:31:26 <nopnut> how can i then do putStrLn "hello" at the end of the runlights function
14:31:46 <nopnut> as it warns me about naked expressions at top level
14:31:51 <nopnut> if i do putStrLn
14:32:03 <gmalecha> http://lpaste.net/359900
14:32:50 <erisco> michalrus, maybe you would rather have a GADT. you have to explain the bigger problem to me
14:33:25 <michalrus> I don’t know yet, I’m looking at that, too.
14:33:26 <michalrus> OK:
14:34:42 <erisco> or maybe you'd rather an open type family, or a data family, or something, I am not sure
14:35:14 <erisco> nopnut,  main = runlights data >> putStrLn "hello"
14:35:38 <erisco> nopnut, you possibly have incorrect indentation
14:36:04 <gmalecha> MarcelineVQ , erisco : http://lpaste.net/359900 (in case you missed it)
14:36:22 <erisco> I am looking
14:36:33 <nopnut> erisco: is there a way to call putStrLn at a specific point in my code?
14:36:41 <erisco> post the error message too
14:36:43 <nopnut> erisco: actually...
14:37:12 <erisco> in that example, it specifically happens after  runlights data  :)
14:37:26 <ocharles> eikke: did you have a question about prom-effect?
14:37:30 <nopnut> erisco: i fixed it :)
14:37:32 <nopnut> thanks
14:37:41 <gmalecha> updated, erisco
14:39:08 <michalrus> erisco: I want to have some structure, say `data Decision = Decision { fieldA :: Map AId AName, fieldB :: Map BId BName }`. Now, two parties exchange that message. When the server sends it, fields contain possibilities. When clients sends it back, fields contain choices made out of these possibilities. For possibilities encoded in a `Map SomeId SomeName`, I’d like the choice to be just `Set SomeId`. But I
14:39:08 <michalrus> might want an Int-range possibility encoded as `(Int, Int)`. Then the choice made would be just an `Int`. And `Decision` is more complicated, but the structure for clients and servers is more/less “the same”.
14:39:14 <michalrus> Oops, wall of text. Sorry.
14:39:15 <dminuoso> ertes-w: Oh and when you read this, I uncrazied it to traverseX f (V3 a b c) = (\x -> V3 x b c) <$> (f a)
14:39:19 <nshepper1> nopnut: you may find https://www.vex.net/~trebla/haskell/IO.xhtml enlightening
14:39:27 <dminuoso> ertes-w: And Im certain that this was the end goal. ;-)
14:40:00 <nopnut> s
14:40:12 <nopnut> nshepper1: thank you
14:41:35 <michalrus> erisco: so I have this encoded as a type family per each pair Map—Set, (Int,Int)—Int etc. And Decision’s fields have types being these type families. And this is OK. But I have to write a lot of standalone derivings. :P
14:41:36 <erisco> gmalecha, can you add a functional dependency to :! so it is injective?
14:42:39 <gmalecha> erisco: it is a type-family, Rec is essentially extensible records from https://hackage.haskell.org/package/CTRex
14:42:56 <michalrus> erisco: actually 6 per `Decision`-like message: (Show, Eq, Generic)×(ClientSide, ServerSide).
14:43:07 <erisco> I know it is a TF
14:43:53 <erisco> the answer is probably "no", and I am not completely sure what the situation is… was just interested to see what GHC would say then
14:44:18 <gmalecha> i can give it a try
14:45:32 <jcarpenter2> okay, i'm going in
14:46:17 <erisco> gmalecha, I have a feeling TFs do not play with quantification like this in the way intended here
14:47:36 <erisco> if :! was a type constructor then it should be just fine
14:47:45 <mlehmk> is "pure (.) <*> u <*> v <*> w = u <*> (v <*> w)" kinda analogous to "\x -> (f . g) x = f (g x)" somehow? I'd like to understand composition of Applicative functors
14:47:59 <erisco> but I bet it is trying to reduce the TF immediately, you can't quantify over it like that
14:48:27 <gmalecha> erisco: I see, maybe i can abstract `:!` as well then
14:49:47 <eikke> ocharles: Yeah, filed an issue to ask in-between :)
14:49:58 <ocharles> Oh, perfect! Let me take a look
14:50:31 <eikke> ty
14:50:39 <erisco> and I am suspecting you needed AllowAmbiguousTypes for  Post (forall l. KnownSymbol l => (ρ :! l) -> ω)  to compile
14:50:59 <johnw> gmalecha: hello!
14:51:14 <erisco> this is because it wants to reduce  p :! l  to remove :!
14:51:36 <erisco> if  :!  requires anything about p or l to be known then it cannot do this
14:51:43 <johnw> mlehmk: it's basically composition of functions f (a -> b) and f (b -> c), which is then provided some f a
14:52:05 <mlehmk> mmm...
14:52:32 <johnw> mlehmk: it shows that the Applicative "preserve the meaning of composition"
14:52:53 <erisco> well, in this case  l  specifically, since p is a parameter
14:53:05 <ocharles> eikke: hmm, yes, it does seem like that should be allowable behaviour
14:53:45 <erisco> gmalecha, I am too tired to wrap my head around what you're intending to do with this… though I vaguely get the idea
14:53:51 <eikke> glad to head ocharles 
14:54:27 <mlehmk> I see something with trying "pure (.) <*> pure (1+) <*> pure (2*) <*> [1,2,3,4,5]"
14:54:35 <gmalecha> erisco: yeh, given that the type annotations match up perfectly, i was kind of hoping there was some way to tell GHC not to introduce a fresh name
14:54:49 <mlehmk> it's like "fmap ((1+) . (2*)) [1,2,3,4,5]"
14:55:07 <betawaffle> erisco: this is what i wanted: x <:> xs = (<|>) <$> fmap pure x <*> xs
14:55:09 <gmalecha> clearly there is a well-typedness proof, GHC just can't find it
14:55:12 <ocharles> eikke: it shouldn't be a huge amount of work to add that in, I might be able to find some time this week
14:56:08 <eikke> ocharles: cool thx. have a bit too much going on right now to hack on it myself, sorry
14:56:09 <mlehmk> I wonder, is the pure x = [x] in that above case?
14:56:31 <ocharles> eikke: no probs. I should write some tests for this library too, so I'll probably try and test-drive this feature and force myself to actually have a test framework around it
14:56:37 <ocharles> so, two birds one stone
14:56:46 <johnw> mlehmk: yes
14:56:48 <mlehmk> seems it is not
14:56:51 <erisco> gmalecha, I realise the signatures match, but I don't think TFs work in the way you're thinking here
14:56:55 <johnw> oh?
14:57:06 <eikke> ocharles: sounds good, thx. 'night now!
14:57:12 <mlehmk> > pure (.) <*> pure (1+) <*> pure (2*) <*> [1..5]
14:57:13 <lambdabot>  [3,5,7,9,11]
14:57:16 <erisco> gmalecha, but the details I am not entirely sure of… I can just say that based on my vague understanding, it does not seem right
14:57:22 <mlehmk> > [(.)] <*> [(1+)] <*> [(2+)] <*> [1..5]
14:57:24 <lambdabot>  [4,5,6,7,8]
14:58:19 <gmalecha> erisco: is there an explanation for how type families work? My understanding of them is they are hacky functions
14:58:32 <pierrot> Hello. How can I tell readFile that the file is encoded as ISO-8859-1? My locale is UTF-8 so I get the following error "hGetContents: invalid argument (invalid byte sequence)".
14:58:33 <mlehmk> something did not compute right and it isn't even a type error
14:58:36 <erisco> sure you can read the GHC manual on them
14:58:48 <dminuoso> benzrf: I cant make sense of this Applicative instance of Const.
14:59:00 <dminuoso> benzrf: I mean I understand *what* it is. Just not why in the slightest.
14:59:36 <erisco> gmalecha, as far as I can tell,  Post (forall l. KnownSymbol l => (ρ :! l) -> ω)  is just nonsense
14:59:58 <erisco> gmalecha, it would make sense if  :!  did not pattern match on  l
15:00:13 <mlehmk> johnw, the odd thing is, if I use pure, no matter if the first, second or third, I get the expected result, but if all is [] I get the unexpected one
15:00:42 <erisco> but, since it does,  p :! l  is not a type because it does not know  l
15:00:43 <geekosaur> pierrot, you need to separate the openFile and hGetContents, and use hSetEncoding in between https://downloads.haskell.org/~ghc/latest/docs/html/libraries/base-4.10.0.0/System-IO.html#v:hSetEncoding
15:00:51 <mlehmk> somehow [a] <*> [b] is different from pure a <*> [b]
15:01:08 <erisco> AllowAmbiguousTypes is only deferring this error
15:01:42 <erisco> as soon as you try and use Post, it is going to try and figure out  p :! l  again, but it still doesn't know  l  and so is hopeless
15:01:42 <gmalecha> erisco: if rho is a rho type, this is the type of the constructor labeled l if the variant type is omega
15:02:19 <dmwit> mlehmk: What evidence makes you conclude that `[a] <*> [b]` is different from `pure a <*> [b]`?
15:02:19 <gmalecha> p :! l ~ Void if l is not in p and some arbitrary type otherwise
15:02:29 <mlehmk> dmwit, look above
15:02:41 <mlehmk> what I fed to lambdabot, I don't get it
15:02:53 <erisco> yeah, well, it has to know  l  in order for  p :! l  to be a type
15:03:03 <erisco> but you've guaranteed that  l  is unknowable
15:03:07 <dmwit> mlehmk: In one you typed `pure (2*)`, and in the other `[(2+)]`.
15:03:22 <mlehmk> dmwit, that's it, thanks, haha
15:04:13 <codeshot> Is there a function, let's call it "delve", that transforms a -> b to a -> m b with m being a monad L where strictness/lazyness can be controlled programatically: (runL . fn1 . fn2) $ delve (+) 1 2? Or better ... $ delve (1 + 2) ?
15:04:16 <gmalecha> i have KnownSymbol, so it is knowable
15:04:52 <erisco> no, that does not help with types at all
15:05:16 <pierrot> geekosaur: Thanks. I'll look at the documentation of hSetEncoding
15:05:53 <erisco> that may let you have some interesting terms, but it isn't helping GHC figure out  p :! l  in any way
15:06:11 <erisco> instance resolution happens later
15:07:00 <gmalecha> i agree with that statement, i thought you were saying that my type doesn't make sense
15:07:16 <erisco> it may compile with AllowAmbiguousTypes but it is unusable
15:07:50 <erisco> let me type a simpler example for you
15:08:00 <gmalecha> hmmm....i'll have to think about it, the rest of my code makes it seem usable
15:10:27 <gmalecha> johnw: hi. we need to hack sometime
15:14:17 <erisco> gmalecha, http://lpaste.net/359902
15:14:35 <htse> guys stupid question: an Int has multiple typeclasses in Haskell I assume but when I define a typeclass in a function call then haskell only sees that typeclass and doesn't infer others? I've been testing with 'Eq' and just normal Int and als 'Num' and == complains about not having Eq passed when using Num
15:15:07 <erisco> gmalecha, is that explanation sufficient to see what X is unusable?
15:15:19 <htse> so Haskell doesn't say Oh you passed an Int, which is part of Num in that function, that is fine, oh it uses == which needs Eq but Int has that so all is well! ?
15:15:34 <johnw> gmalecha: indeed
15:16:10 <erisco> htse, Int has an instance for many type classes
15:17:02 <htse> but when specifying a typeclass it gets passed as explicitly that one? It can't derive "oh you're an Int so you're also part of Eq"?
15:17:03 <erisco> htse, if you give a type signature then Haskell checks that this signature is valid as-is. It will not amend your type signature to fix your mistakes.
15:17:25 <erisco> htse, if you do not list certain constraints in the signature, but they are required, then this is an error
15:17:52 <erisco> htse, I don't know exactly what you mean by your words. Can you post some code?
15:18:26 <codeshot> if you give the type signature for a function then haskell doesn't look at the point where you use the function, it decides at the point where you define it
15:18:31 <htse> hmm interesting that being comparable is viewed as a constraint never looked at it that way
15:19:11 <codeshot> If you don't give the type signature it's even worse
15:19:19 <htse> basically I have myEquals :: Eq a => a -> a -> Bool that = myEquals m n = m==n
15:19:34 <htse> and I figured if I pass Int that'd be fine and it was
15:19:55 <htse> but I I use a Num typeclass instead of Eq it complains about ==
15:20:02 <codeshot> think of it this way, to be comparable, there must be a method of comparing. So it has to be defined and if it's not defined then it can't be done.
15:20:04 <htse> which does make sense in a rigid sense
15:20:34 <htse> but I thought it would derive that what was being passed as an Int, which itself would then have an Eq instance
15:20:45 <htse> but it seems I'm wrong there
15:21:06 <mauke> it's not the call that fails to typecheck, it's the function definition itself
15:21:24 <codeshot> there is a non-rigid alternative. You can use haskell to run random bytes as machine code via the foreign function interface :P
15:21:36 <mauke> your signature promises that whatever type 'a' the caller passes in, the function will return a Bool (as long as there is a 'Num a' instance)
15:21:43 <gmalecha> erisco: your logic is sound, but i'm not sure it quite applies here. i have a function from r :! l, not to r :! l
15:21:53 <gmalecha> so i just need to say that r :! l is usable
15:22:04 <mauke> but this doesn't allow use of == in general
15:22:13 <mauke> the caller might be using numbers that can't be compared
15:22:17 <dmwit> htse: If you told the compiler that `myEquals` would be dealing with `Int` only, by giving the type signature `myEquals :: Int -> Int -> Bool`, it would indeed infer that `Int` is in the `Eq` typeclass and everything is fine.
15:22:23 <erisco> gmalecha, maybe I am unclear when I say "unusable"
15:22:27 <gmalecha> i have a function that tells me that i can go from Rec r -> r :! l
15:22:32 <geekosaur> htse, I think the rel issue here is that the stanbdard says Num implies Eq, but that is no longer true in ghc?
15:22:36 <erisco> and also there is more nuance to the injective situation, which I'll try and clarify later
15:22:39 <htse> dmwit that' what I did and it did work and do that
15:22:46 <geekosaur> *real issue
15:22:50 <erisco> but when I say "unusable", I mean there is nothing we can apply X to that works
15:22:51 <htse> hence my surprise that Num a => didn't work :)
15:22:55 <dmwit> htse: But that's not what you told the compiler. What you told the compiler was that `myEquals` should work no matter *which* instance of `Num` somebody decided to use. That's not okay, because not all `Num` instances support equality tests.
15:22:56 <geekosaur> ghc ditched the Eq and Show instances
15:23:00 <htse> I do get why but it's surprising :)
15:23:27 <gmalecha> i concur with your logic
15:23:31 <htse> there are numbers you can't compare? :/
15:23:32 <erisco> under the AllowAmbiguousTypes situation, there is nothing we can apply X to
15:23:39 <dmwit> htse: Yup!
15:23:56 <erisco> if X is injective, then there are things we can apply it to
15:24:01 <htse> even the double and floats will have an identical approximation, won't they?
15:24:02 <codeshot> I could have sworn that it used to be that all Num a was also Eq a
15:24:02 <erisco> sorry, if F is injective
15:24:21 <codeshot> is my memory bad or did that change ?
15:24:38 <dmwit> htse: Int, Integer, Double, Float, Ratio a, and Complex a come with GHC. But there are many other more exotic instances of Num that don't come with the compiler, and it's possible to write some which don't support equality.
15:24:40 <mauke> htse: double and float have exact comparisons; that's not the problem
15:25:07 <geekosaur> htse, consider natural numbers represented as functions
15:25:13 <erisco> but even then, I don't know of interesting examples
15:25:17 <geekosaur> they're perfectly good Nums but you can't (=) functions
15:25:18 <codeshot> double and float don't have exact comparisons in most machines, they're not even pure
15:25:20 <geekosaur> (==)
15:25:24 <erisco> type family F a = r | r -> a where F a = Maybe a
15:25:25 <dmwit> htse: For example, one could (and the "numbers" package has) cook up a type that represented the computable reals. There is no correct, decidable equality on this type.
15:25:39 <erisco> this is just using the injectivity of type constructors … F is as good as Maybe
15:25:40 <mauke> codeshot: double and float have exact comparisons on all machines
15:25:53 <dmwit> (The "numbers" package does define an Eq instance, but it is a lie: there are inequal computable reals which that package announces are equal.)
15:26:03 <erisco> so you might have  f :: forall a. F a; f = Nothing  but this is just as good as  f :: Maybe a; f = Nothing
15:26:19 <codeshot> rly? but they have different results depending on whether they've been written to memory or stayed in registers
15:26:20 <erisco> and  newtype X = X (forall a. F a)  is as good as   newtype X = X (Maybe a)
15:26:25 <mlehmk> "id" to "const" is like "(:[]) head" to "Const getConst"?
15:26:27 <cschneid_> What's the state of haskell web frameworks, haven't looked in a few years and have a small project to tackle. The kind of thing I'd normally grab rails for (html/js served, and backed by an sql db). -- Should I just use yesod for a working full-stack solution? Or is there another project I should look into?
15:26:33 <codeshot> without a monad!
15:26:42 <mauke> codeshot: ah, intel stuff
15:26:47 <mauke> ok, you're right about that
15:26:52 <codeshot> not just intel I understand
15:27:05 <codeshot> DSPs and all sorts
15:27:05 <htse> ok thx, confusing but I guess it'll become clear over time
15:27:27 <erisco> maybe something like  type family F a = r | r -> a where F (Either a a) = Maybe a   could be interesting but   f :: forall a. F a  doesn't make sense now
15:27:45 <erisco> and it doesn't make sense because F is not defined on all a's
15:27:55 <codeshot> In 21 century IEEE seems to have taken haskell's Eq type class and defined it as an approximate equality class in order to give floats some rigour
15:28:20 <erisco> even though  newtype X = X (forall a. F a)  will now compile, I don't see what we can actually apply X to
15:28:39 <codeshot> and impure equality
15:29:13 <gmalecha> erisco: If you write `newtype X = X (forall a. Default (F a) => F a)` that seems perfectly fine, right?
15:29:16 <codeshot> which is unfortunate and warrants obsolesence of Eq, IMHO
15:29:49 <htse> cschneid_ I'm planning to do something with hapstack and clckwrk, not sure if they're good since I'm a haskell noob
15:30:26 <gmalecha> and if you write `newtype X = X (forall a. a -> Int)` that is also fine
15:30:33 <codeshot> which would be good because we could have something better in terms of unification which would support logging the progeny of values
15:30:35 <erisco> gmalecha, a context changes absolutely nothing
15:30:47 <codeshot> so not unfortunate when I think about it :)
15:30:52 <erisco> maybe there is a context that would allow you to recover enough information to do something useful, but I don't think it is that one
15:30:56 <cschneid_> htse - clckwrks is last updated github repo of a year ago :-/ May work, but isn't actively developed
15:31:02 <gmalecha> def :: Default a => a
15:31:22 <gmalecha> so `X def` should be well-typed
15:31:29 <erisco> you have to recover enough information about the existential for F to reduce
15:31:44 <gmalecha> why?
15:32:28 <gmalecha> there are other places in my code where i write `r :! l` with completly polymorphic `r` and `l` without any problem
15:32:29 <erisco> I don't know what you are suggesting right now because you've said multiple things
15:33:13 <gmalecha> we may just be talking about different things at this point
15:33:25 <gmalecha> thanks for taking a look at the example
15:33:55 <erisco> newtype X = X (forall a. a -> Int)  looks like something else, I don't get how it relates
15:34:28 <gmalecha> in my type, the `r :! l` is in the domain of a function, not the codomain
15:34:37 <erisco> so?
15:35:02 <erisco> what did I say that you thought was particular to domains and codomains?
15:35:32 <jcarpenter2> Anybody know how to get stack traces or at least line numbers for execptions that are thrown such as `fromJust Nothing'?
15:35:39 <jcarpenter2> http://lpaste.net/359904
15:36:13 <jcarpenter2> ^ compiling with -prof -fprof-auto gave SOME additional information, but what I wanted to see was `test.hs:7'
15:36:22 <johnw> run with +RTS -xc
15:36:44 <jcarpenter2> ah very good
15:36:57 <gmalecha> erisco: sorry, my understanding of you saying that X in your example is unusable had something to do with there is no way to construct a value of type X
15:37:13 <erisco> gmalecha, yeah, that's right
15:37:50 <gmalecha> if you change the argument to `forall a. F a -> Int` then it is usuable in that case
15:38:00 <erisco> but I don't see why it matters whether we're talking about domains or codomains in where you use the TF
15:38:04 <gmalecha> you can construct a value of type X (that is not undefined)
15:39:02 <erisco> such as what?
15:39:12 <gmalecha> X (\ _ -> 0)
15:40:35 <gmalecha> thankfully though, the inhabitedness of uninhabitedness of a type does not impact type checking, so this portion of the conversation isn't particularly relevant to the question at hand
15:41:08 <gmalecha> thanks for your help :-)
15:42:00 <jcarpenter2> does that RTS output just go to stderr?
15:42:12 <jcarpenter2> surely it does
15:42:38 <geekosaur> yes
15:43:38 <erisco> gmalecha, what is the type of (\_ -> 0) in that example?
15:44:15 <erisco> if there is nothing interesting inhabiting the type then your design is goofed, is what I am saying
15:45:16 <gmalecha> in the example that i wrote above, `\ _ -> 0` :: `forall a. F a -> Int`
15:45:37 <pierrot> if I want to use hGetContents but for ByteString, how can I specify the encoding?
15:46:07 <erisco> gmalecha, I would type in  X (undefined :: forall a. F a -> Int)  and see what happens
15:46:10 <geekosaur> ByteString doesn't have an encoding, it's just [Word8]
15:48:13 <erisco> what the type is actually supposed to be I don't know
15:48:15 <pierrot> geekosaur: oh, I see. so the readFile function exported by Data.ByteString should be sufficient, right?
15:48:29 <erisco> I'd be interested to hear from anyone who can figure that out
15:48:56 <pierrot> there's no need to use openFile and hGetContents and all those lower-level functions...
15:49:18 <geekosaur> yes, it just gives you bytes. if you need a string with an encoding, you use one of the functions that converts to Text with an encoding
15:50:35 <pierrot> Nice. Thanks
15:51:14 <gmalecha> thanks erisco, that's a simple example that demonstrates the issue
15:56:32 <erisco> what is going on with this type error http://lpaste.net/359905
15:57:42 <erisco> my wild guess is that without the annotation GHC is happy to infer the correct type it knows internally, but with the annotation it is now trying to unify through F
15:58:34 <lyxia> yeah something like that.
15:59:39 <erisco> that's some goofy stuff right there … highlights a strange nature of TFs
16:00:42 <lyxia> it's surprising that there's no AllowAmbiguousTypes at the top here.
16:01:15 <geekosaur> I feel like this got explained within the past month or so on one of the mailing lists
16:01:21 <erisco> had it enabled on ghci
16:01:26 <geekosaur> (I think -cafe)
16:02:43 <erisco> my intuition of TFs is to not consider them first class … maybe that isn't the word or a good description
16:03:15 <erisco> but a saturated TF isn't a thing, it isn't a type (or whatever kind inhabitant) yet
16:05:07 <erisco> I kind of wanted to say it is more like a macro
16:05:16 <erisco> but I don't know how well that applies
16:08:30 <erisco> it is such a poor understanding =\ if you can dig up the explanation sometime geekosaur I'd appreciate it
16:08:56 <erisco> it is janky if there is no correct name for the type of  undefined  in that example
16:09:17 <erisco> and I am not sure what sensible type that is anyways
16:12:38 <erisco> we can nuke all cases in F, so it is undefined everywhere, and yet  X undefined :: X
16:13:16 <erisco> provably no choice for 'a' such that 'F a' is defined, yet somehow we have an  undefined :: forall a. F a
16:13:30 <erisco> I don't see how it makes sense for undefined to inhabit not-a-type
16:14:47 <erisco> unless… I dunno… not-a-type (NaT) inhabits all kinds? :P
16:16:30 <alhariel> hey guys anyone here using the intero-neovim plugin?
16:18:57 <jcarpenter2> whew, got one
16:26:10 <jle`> alhariel: if you have a question, best to just ask it :)
16:33:49 <alhariel> so im trying to get the intero-neovim plugin to work, but if i try to run InteroGoToDef it says 'Intero is still starting up', but if i do InteroOpen it opens a new window with a functional ghci with the modules loaded
16:33:58 <alhariel> so dunno whats going on here
16:35:18 <fragamus> Hey what should I use for arbitrary precision floating point
16:36:06 <hpc> https://hackage.haskell.org/package/numbers-3000.2.0.1/docs/Data-Number-CReal.html -- this probably
16:36:15 <erisco> fragamus, try Rational
16:36:39 <erisco> otherwise, it is a fairly nonsense concept… good luck with termination
16:36:42 <hpc> Rational is good too if you know you only need rational numbers
16:37:02 <fragamus> Rational not good for my purpose
16:37:25 <hpc> > sqrt 2 :: CReal
16:37:27 <lambdabot>  1.4142135623730950488016887242096980785697
16:37:36 <hpc> > showCReal 200 (sqrt 2)
16:37:38 <lambdabot>  "1.4142135623730950488016887242096980785696718753769480731766797379907324784...
16:38:05 <erisco> > (sqrt 2 :: CReal) == sqrt 2
16:38:07 <lambdabot>  True
16:38:15 <erisco> amazing
16:38:17 <hpc> whoa
16:38:25 <hpc> > log 0 :: CReal
16:38:31 <lambdabot>  mueval-core: Time limit exceeded
16:38:35 <hpc> yeah that's more like it
16:39:33 <hpc> but if you want to know exactly what pi ** phi is, that's your library
16:41:25 <erisco> and is there a symbolic math library? probably
16:41:55 <erisco> where  pi ** phi  is exactly  pi ** phi  :P
16:42:36 <erisco> or maybe uses some Taylor series something something
16:45:46 <erisco> maybe you just need algebraic numbers
16:49:48 <Tops2> Is the function (combinator?) (\f  a -> f a a) predefined somewhere? Preferably in base?
16:49:51 <Danyta> hola!
16:49:55 <erisco> Tops2, join
16:50:22 <Danyta> ola
16:50:34 <erisco> aloe, ha!
16:50:41 <Danyta> tops2,join
16:51:40 <Tops2> thanks, let me try it out :)
16:52:52 <Danyta> how are you
16:54:05 <erisco> later skater
16:56:45 <Danyta> oh
16:57:14 <centril> Has named instances ever been considered for Haskell as a way to solve "The Monoid Problem" ?
16:58:30 <centril> i.e: instance Sum for Monoid Float where ..   instance Product for Monoid Float where ..
16:59:10 <Danyta> centril, hola!!
16:59:18 <centril> Danyta: hello
17:00:49 <monochrom> Is Danyta a bot?
17:01:49 <Danyta> no
17:01:56 <Clint> that's just what a bot would say
17:02:03 <centril> Clint: haha
17:02:20 <Tops2> now I look for another combinator: Like on from Data.Function, but it should take two unary function of the same type instead of one.
17:02:38 <EvanR> centril: check out "typeclasses vs the world" video
17:02:48 <centril> EvanR: cheers
17:03:25 <centril> EvanR: I'm considering a named-impls RFC for Rust =)
17:03:38 <EvanR> idris lets you do it
17:03:51 <centril> EvanR: oh? neat! any link?
17:04:02 <EvanR> but when you get into it, its pretty clunky in practice
17:04:03 <fragamus> So CReal has how much precision?
17:04:15 <EvanR> fragamus: INFINITY!!!
17:04:25 <centril> EvanR: more or less than a newtype?
17:04:32 <Danyta> soy de argentina
17:04:36 <fragamus> That's not good for irrationals
17:04:37 <monochrom> CReal doesn't limit precision. But its (==) just checks 40 digits or something.
17:04:49 <Danyta> mee gusta donde vivo
17:04:52 <fragamus> Don't cry for me Argentina
17:04:53 <EvanR> centril: http://docs.idris-lang.org/en/latest/tutorial/interfaces.html#named-implementations
17:04:56 <monochrom> Also CReal doesn't store its digits. It re-computes.
17:05:12 <Danyta> mi ciudad es rosario
17:05:22 <EvanR> digits are a lie
17:05:31 <Danyta> hola a todos
17:05:32 <EvanR> -- brouwer
17:05:50 <EvanR> oh crap, youre right -- turing
17:06:27 <Danyta> esto salae para todo el mundo?????
17:07:04 <fragamus> Is CReal useful
17:07:06 <centril> EvanR: cheers
17:07:35 <EvanR> you could use CReal to check the accuracy of other number implementations
17:07:57 <Danyta> viejo evans, donde estas??
17:09:04 <centril> EvanR: edwardk is always nice to listen to =)
17:09:38 <EvanR> its nice that he talks like you know everything already, except i dont :)
17:11:28 <Danyta> eres tú cs?
17:11:37 <Danyta> disculpame!
17:11:47 <monochrom> Are you done?
17:13:10 <Danyta> yes?
17:13:37 <Danyta> Are you done??
17:13:47 --- mode: ChanServ set +o monochrom
17:13:57 --- mode: monochrom set +q *!*@181.111.15.112
17:14:01 --- mode: monochrom set -o monochrom
17:14:27 <centril> monochrom: long time no see btw
17:14:28 <centril> =)
17:16:49 <Fekinox> i've discovered that stacking fmaps gets... weird
17:16:54 <Fekinox> @type fmap fmap (fmap fmap) fmap
17:16:55 <lambdabot> (Functor f3, Functor f2, Functor f1) => f1 (a -> b) -> f1 (f2 (f3 a) -> f2 (f3 b))
17:17:17 <monochrom> Yes, it's a good but advanced exercise in type inference.
17:17:21 <exio4> @type [fmap fmap fmap, fmap . fmap] 
17:17:22 <lambdabot> (Functor f2, Functor f1) => [(a -> b) -> f1 (f2 a) -> f1 (f2 b)]
17:17:30 <geekosaur> roughly half of them are ((->) e) which is a bit of a mind bender until you get used to it
17:17:36 <Fekinox> @type (fmap fmap) fmap
17:17:37 <lambdabot> (Functor f2, Functor f1) => (a -> b) -> f1 (f2 a) -> f1 (f2 b)
17:18:35 <Fekinox> it feels like something that shouldn't work at all, yet it kind of does
17:19:46 <benzrf> i fucking love Traversable
17:19:54 <benzrf> it's an absolutely great abstraction
17:21:04 <qqkami> hello! for an assignment i have to create a newtype and implement the Num functions - however i am having some issue while implementing fromInteger (no approach) - this is what i tried so far https://pastebin.com/3P3iMRJp
17:23:03 <geekosaur> x's type is Integer, why would you expect it to match Float? (also "foo" is not a valid name for that)
17:23:55 <qqkami> it's not called foo but the assignment is in german so i just wrote foo instead 
17:24:27 <exio4> Fekinox: there's a fmap instance for ((->) e) 
17:24:28 <qqkami> i thought this it should take an Integer and output foo value
17:24:32 <exio4> @type fmap
17:24:34 <lambdabot> Functor f => (a -> b) -> f a -> f b
17:24:46 <geekosaur> but foo wants a Float, not an Integer
17:25:16 <exio4> Fekinox: if you replace f with ((->) e) you get fmap :: (a -> b) -> ((->) e) a -> ((->) e) b 
17:25:30 <exio4> Fekinox: which is the same as (a -> b) -> (e -> a) -> (e -> b) 
17:25:39 <exio4> Fekinox: which is.. function composition
17:25:51 <exio4> @type (.) :: (a -> b) -> (e -> a) -> (e -> b)
17:25:52 <lambdabot> (a -> b) -> (e -> a) -> e -> b
17:25:59 <exio4> @type (.)
17:26:01 <lambdabot> (b -> c) -> (a -> b) -> a -> c
17:26:13 <Fekinox> exio4: aha, that explains it
17:26:20 <Fekinox> it was just kinda jarring when I found out on my own
17:26:24 <qqkami> geekosaur: that is indeed true.. but i still don't what i need to do in that case - also it's quite weird isn't it? its called fromInteger but i'm supposed to pass it a float?
17:26:43 <exio4> Fekinox: try to infer which type has each fmap in `fmap fmap fmap` 
17:26:55 <monochrom> No, you are supposed to convert Integer to Float.
17:27:00 <geekosaur> qqkami, you were *given* an Integer
17:27:18 <geekosaur> fromInteger = 'here is an Integer, turn it into a foo'
17:27:33 <geekosaur> but foo wants a Float
17:28:06 <monochrom> I am also baffled by the fear of revealing the actual German-inspired type name.
17:28:13 <monochrom> and constructor name.
17:28:33 <geekosaur> possibly just the fear of typing e.g. ü
17:29:00 <monochrom> I am OK with mock code that simplifies. But at least give legal mock code.
17:29:43 <qqkami> oh so it was what i thought it was but the issue was on the other side - that does make sense - but how do i convert x to a float without using Float
17:30:09 <monochrom> I don't understand why the "without using Float" part.
17:30:14 <qqkami> it doesn't even contain ue etc (no german keyboard layout anyways) just figured some people might be put off by it
17:30:32 <qqkami> oh i tried: fromInteger x = K (Float (x))
17:30:49 <monochrom> That is just conflating types with constructors.
17:30:53 <geekosaur> there is no 'casting' in Haskell
17:31:07 <monochrom> Or worse, types with terms.
17:31:36 <qqkami> geekosaur: then i don't quite get how i can implement this
17:31:52 <geekosaur> @hoogle Integer -> Float
17:31:53 <lambdabot> Graphics.Gloss.Geometry.Angle degToRad :: Float -> Float
17:31:53 <lambdabot> Graphics.Gloss.Geometry.Angle radToDeg :: Float -> Float
17:31:53 <lambdabot> Graphics.Gloss.Geometry.Angle normalizeAngle :: Float -> Float
17:31:55 <qqkami> i guess i could check if x is a float and only return K x then?
17:31:56 <geekosaur> er
17:31:59 <monochrom> Look for a standard way to convert Integer to Float.
17:32:06 <geekosaur> sigh, when did hoogle become useless
17:32:28 <monochrom> Ironically, the question already contains the answer.
17:32:43 <monochrom> Is Float an instance of Num? If yes, what methods does it enjoy?
17:33:22 <qqkami> yes, so it does have an implementation of fromInteger too
17:34:21 <monochrom> In OOP parlance this is the "delegation" or "forwarder" design pattern.
17:36:08 <qqkami> so what i decided to do was:
17:36:15 <qqkami> fromInteger x = K (fromInteger x)
17:36:27 <monochrom> Yes.
17:36:56 <qqkami> could have thought of that sooner.. but thanks for your help geekosaur monochrom 
17:47:46 <fryguybob_> fryguybob?
17:49:20 <fryguybob_> give me A?
18:07:33 <olligobber> > round $ 1/0
18:07:35 <lambdabot>  1797693134862315907729305190789024733617976978942306572734300811577326758055...
18:07:40 <olligobber> ...
18:08:52 <lyxia> > round $ 1/0 :: Int
18:08:54 <lambdabot>  0
18:09:17 <lyxia> "obviously"
18:11:04 <monochrom> Those are long-standing bugs that no one wants to fix, that's all.
18:11:23 --- mode: ChanServ set +o monochrom
18:11:43 <EvanR> i am reading about gustafson posits
18:11:50 <EvanR> or trying to
18:11:53 --- mode: monochrom set -qo *!*@181.111.15.112 monochrom
18:30:39 <olligobber> > fromInteger (round $ (1/0 :: Float) :: Integer) :: Double
18:30:41 <lambdabot>  3.402823669209385e38
18:51:29 <EvanR> https://i.imgur.com/9A0rTQ7.png
19:18:10 <mniip> is it a know thing that sometimes ghc RTS libraries will remain resident after you dlclose the library that "loaded" them?
19:26:07 <Hijiri> I didn't know about it at least
19:31:47 <analogic> hey there
19:33:03 <dmj`> analogic: hey
19:35:47 <pacak> o/
19:39:18 <geekosaur> mniip, I think that may be deliberate? it stays loaded and initialized because reinitializing the RTS doesn't work (https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/bugs.html#infelicities-ffi) so multiply loading Haskell plugins wouldn't work properly?
19:40:32 <mniip> geekosaur, no it's not!
19:40:57 <mniip> I mean er
19:41:22 <mniip> prevending dlclose so that you absolutely can't reinitialize the RTS makes no sense
19:41:42 <mniip> also I think I found the source of my problem
19:42:38 <jcarpenter2> okay, i'm going in deep
19:42:52 <mniip> GHCi.ObjLink decided to loadDLL some files and not free them
19:43:43 <mniip> oh wow that's interesting
19:45:11 <mniip> https://github.com/ghc/ghc/blob/cdaf5f2027ea9678e9f92e9140c79da2daa78360/includes/rts/Linker.h#L80
19:45:43 <mniip> there's not even a removeDLL
19:47:07 <mniip> the rts...
19:47:13 <mniip> doesn't know
19:47:15 <mniip> about dlclose
19:47:48 <mniip> it's literally not mentioned anywhere
19:48:24 <nshepperd> sc0pew0ve
19:48:34 <nshepperd> ah fuck
19:48:42 <mniip> change your password
19:48:50 <nshepperd> yeeep
19:48:56 * MarcelineVQ steals nshepperd's credit card
19:49:02 <benzrf> ...whoops
19:49:17 <centril> EvanR: So; I checked edwardk's talk on type classes - it was nice and informative, but really didn't cover what I was talking about
19:49:19 <MarcelineVQ> that's not an especially secure one anyway
19:49:38 <MarcelineVQ> not that irc is life or death :X
19:49:49 <centril> EvanR: named instances would be instances that must be explicitly imported thereby preserving coherence
19:51:12 <nshepperd> MarcelineVQ: yeah i originally wanted a secure passwrod, but then password requirements happened
19:51:19 <nshepperd> and i was like fuck it
19:51:34 <nshepperd> anyhow, better change that
20:15:39 <kook77> hello
20:17:34 <kook77> is this place for programming help, sorry long time havent been on irc.
20:18:13 <centril> kook77: yes, for Haskell programming specifically
20:18:50 <kook77> Cause I had a question about directfb, was wondering if someone could direct me. And thanks for reply.
20:35:52 <blink3> oiuoi
20:38:50 <blink3> lkjlkj
20:50:18 <anhr> hello
21:10:18 <fredfoobar> yay - join/quit flooding
21:52:28 <tempeh> :q
22:16:30 <mniip> charming
22:16:46 <mniip> GHCi.Linker doesn't export PersistentLinkerState
22:32:34 <cocreature> hphuoc25: you should be able to do something like "withTaskGroup 50 $ \g -> mapConcurrently g …" and remove all semaphores and manual calls to async
22:45:05 <hphuoc25> cocreature: I got error 'thread blocked indefinitely in an STM transaction' http://lpaste.net/359910
22:46:30 <jcarpenter2> I'm having trouble catching exceptions that are thrown inside data members of a larger data type: http://lpaste.net/359911
22:46:40 <jcarpenter2> main does 2 things: create and output a String, then create and output a StringWrapper
22:47:46 <jcarpenter2> Both are strictly evaluated in order to catch exceptions, but it doesn't work for StringWrapper because strictly evaluating it does not mean strictly evaluating its data members
22:48:08 <jcarpenter2> Is there a way to cause a data type to be recursively strictly evaluated?
22:48:16 <mniip> jcarpenter2, evaluate evaluates to whnf
22:48:39 <mniip> use a strict constructor or Control.DeepSeq
22:48:59 <jcarpenter2> okay
22:49:50 <jcarpenter2> are strict fields in a data constructor evaluated to whnf?
22:50:02 <jcarpenter2> or to...  deep normal form?
22:50:08 <Cale> whnf
22:50:21 <jcarpenter2> okay
22:50:34 <Cale> basically, whenever you have a strict field, it causes occurrences of the data constructor in terms to be replaced with a lambda that seq's the particular fields
22:53:46 <cocreature> hphuoc25: looks like `mapConcurrently` might be broken, take a look at https://github.com/jwiegley/async-pool/issues/7#issue-115383850 for a workaround
23:02:12 <hphuoc25> cocreature: just tried that http://lpaste.net/359844#a359913, still 1gb+ memory and slow insert
23:04:42 <dminuoso> I need some guidance. Can someone explain to me this behavior? https://gist.github.com/dminuoso/cfcd3e8d44d6d5be13d6c6ae2d37a9ce
23:05:17 <cocreature> hphuoc25: use mapTasks_
23:06:21 <dminuoso> How is traverseX' f v = (test f v) <$> (test' f v) different from traverseX ?
23:07:26 <dminuoso> The only difference is the applicative constraint, but I do not understand how this changes the behavior of the Functor instance of Const.
23:08:20 <Cale> dminuoso: It's the Monoid constraint
23:08:27 <hphuoc25> cocreature: mapTasks_ works but it's not inserting into db 
23:08:32 <Cale> That's not a Prelude class, so defaulting doesn't happen
23:09:01 <Cale> dminuoso: If you :t your working line, you'll note that it only has Num constraints in its type
23:09:09 <Cale> so those can be defaulted to Integer, making things work
23:09:40 <Cale> For the other one, ghci would have to come up with something which is an instance of Num and Monoid
23:09:49 <Cale> (and Integer isn't it)
23:10:39 <cocreature> hphuoc25: but it does insert with mapTasks? that seems … weird
23:11:41 <Cale> *Main Data.Monoid> traverseX Const v :: Const (Sum Integer) (V3 (Sum Integer))
23:11:41 <Cale> Const (Sum {getSum = 1})
23:11:45 <Cale> ^^ dminuoso 
23:12:07 <Cale> That code works, it's just that the compiler isn't clever enough to guess what instance of Monoid you want to use.
23:12:39 <dminuoso> Cale: Okay, I got that. But what I do not understand, how it could type check if Integer was not an instance of Num and Mnoid
23:12:53 <Cale> Now, as it happens, you don't actually use the full Applicative structure, which makes use of the monoid operations (since you only use fmap), but the types that you've given things don't make that apparent, so 
23:13:15 <Cale> so it doesn't know that it won't actually need to make use of the Monoid instance
23:13:24 <Cale> (because you never actually used <*>)
23:13:42 <dminuoso> Oh so this is lazyness biting me back?
23:13:49 <Cale> Nothing to do with laziness
23:13:58 <Cale> This is a compile time thing, not a run time thing
23:14:07 <Cale> (it's typechecking)
23:14:35 <Cale> So, you gave traverseX a type which was less general than you could have
23:14:45 <Cale> You said it needed Applicative f
23:15:01 <Cale> So you need to pick a functor which is an instance of Applicative if you want to use it.
23:15:18 <Cale> Const a is an instance of Applicative, but only when a is an instance of Monoid
23:15:46 <Cale> i.e. instance Monoid m => Applicative (Const m)
23:16:13 <Cale> and so in order to be able to use traverseX with f = Const m
23:16:20 <Cale> you'd better have an instance of Monoid m
23:16:48 <Cale> If you'd said  traverseX :: Functor f => (a -> f a) -> V3 a -> f (V3 a)
23:17:03 <dminuoso> Cale: Ohh wait a moment.. I think it might be GHCi that's giving me this massive headache.
23:17:17 <Cale> not just ghci
23:17:43 <Cale> But certainly if in your real program, there's more type information, it might all work out just fine
23:17:58 <dminuoso> Cale: The thing is, *Main> a = traverseX' Const v works
23:17:59 <Cale> We have  instance Functor (Const m)  -- unconditionally
23:18:08 <dminuoso> Which seemed to imply it would typecheck
23:18:27 <Cale> sure, you can always make definitions and it will defer the decision about what types you want things at
23:18:35 <Cale> :t a
23:18:36 <lambdabot> Expr
23:18:43 <Cale> (well, do that in ghci there)
23:18:56 <Cale> and it'll tell you that the a you defined has a polymorphic type
23:19:03 <dminuoso> a :: (Monoid a, Num a) => Const a (V3 a)
23:19:08 <Cale> yep
23:19:28 <dminuoso> Ohhh, it hasnt decided on Integer yet..
23:19:38 <Cale> And it couldn't decide on Integer
23:19:44 <Cale> because there's no instance of Monoid for Integer
23:20:06 <Cale> (there are instances for Sum Integer and Product Integer though)
23:20:33 <Cale> The type signature you gave for traverseX isn't the most general one which you could have given
23:20:55 <Cale> If you generalise it to Functor f rather than Applicative f, things will work out better
23:20:59 <dminuoso> Yeah, that much I have already gathered. Until a while ago I used the applicative interface of f, but I didn't realize that I dont actually need an applicative.
23:21:19 <dminuoso> Through applying applicative laws I managed to reduce it just to Functor, but left the constraint in.
23:21:27 <Cale> Yeah, you only really need the Applicative structure if you're traversing more than one part of the structure
23:21:38 <Cale> You have a lens there, so you only need Functor
23:22:36 <dminuoso> Cale: So lenses fundamentally only operate on a single bit of some structure?
23:22:43 <Cale> yed
23:22:47 <Cale> yes
23:27:34 <dminuoso> Cale: Alright, thank you very much for your time. Appreciated as always. Should you ever be around northern Germany, let me buy you a drink. :)
23:30:01 <Cale> Yeah, no problem :)
23:33:03 <hphuoc25> cocreature: you can try running that program :)
23:37:43 <dminuoso> Cale: Oh my. I just dabbled a bit, and very quickly came up with over/view. https://gist.github.com/dminuoso/a98c15bd6fd2a759fadfe56404853292
23:37:48 <dminuoso> This is all the magic to lenses?
23:38:41 <Cale> yep
23:39:48 <Cale> Well, there's a bunch of additional abstraction and magic in Ed's lens library, but it's a reasonable place to stop :)
23:40:16 <dminuoso> Well, I need one more bit, which started the whole thing: The reason for seemingly backwards composition. :)
23:40:25 <dminuoso> But lets see how much I can figure out on my own
23:40:42 <jcarpenter2> whew, got one
23:42:23 <Cale> dminuoso: It's only backwards if you're thinking about the lenses in a particular way, which doesn't correspond to how they're actually represented as functions.
23:46:41 <osa1> anyone know a shorter (maybe without >>=) version of this lens expression: `m ^. at key1 >>= view (foo . at key2)` ?
23:47:58 <Cale> The >>= has nothing to do with the lens structure there, so I wouldn't expect to do any better
23:48:58 <Cale> I'd probably use view in both places though
23:49:08 <Cale> and use =<<
23:49:58 <osa1> can I not use _Just somewhere to avoid >>= ? I can use it for setting values in nested maps but I couldn't figure how to use it here
23:50:37 <Cale> oh, right
23:50:54 <Cale> hmm
23:51:40 <cocreature> hphuoc25: meh async-pool doesn’t seem to be as useful as I was hoping for. you are probably going to have to write your bounded map concurrently yourself after all
23:53:06 <osa1> so it works for set but not for view.. weird
23:58:41 <jcarpenter2> boom https://github.com/Happstack/happstack-server/pull/36
23:59:07 <jcarpenter2> comments would be great
