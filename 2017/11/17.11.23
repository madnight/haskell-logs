00:05:59 <sebastian___> cocreature: Thank you, that's a very interesting approach. I attempted a Functor implementation but at the Mailbox level, which had the unfortunate problem of being more of a Profunctor
00:07:45 * hackage monad-var 0.1.1.0 - Generic operations over variables  https://hackage.haskell.org/package/monad-var-0.1.1.0 (effectfully)
00:08:06 <sebastian___> I'll have to play more with it to see how I feel, but it might just work.
00:08:38 <cocreature> sebastian___: Mailbox is not even a Profunctor, it needs to be both covariant for reading from the mailbox and contravariant for sending to the mailbox
00:08:47 <cocreature> but in the same type argument
00:10:00 <sebastian___> Yeah, I was actually pointed to a typeclass called Invariant with those characteristics exactly
00:11:40 <sebastian___> but it's useless to define both directions for any given actor unless they commuicate bidirectionally, so it wasn't what I wanted anyway
00:12:23 <sebastian___> For any given actor->actor commuication, that is
00:12:39 <sebastian___> Communication*
00:14:34 <nshepperd> if you desperately need profunctoriality you could coyoneda it up. data Mailbox a b = forall m. Mailbox (a -> m) (Chan m) (m -> b)
00:15:49 <nshepperd> (and then apply those functions whenever pushing to or reading from the chan)
00:19:18 <sebastian___> thanks everyone for the help, will work on it and share my progress my progress on Friday or Saturday
00:20:32 <nshepperd> (...'proyoneda'?)
00:21:40 <nshepperd> i guess cocreature's suggestion makes more sense, normally one does separate the 'read end' and 'write end' anyway
00:21:53 <nshepperd> so the read end is covariant and the write end is contravariant
00:56:11 * hackage xeno 0.3.2 - A fast event-based XML parser in pure Haskell  https://hackage.haskell.org/package/xeno-0.3.2 (ocramz)
01:13:10 * hackage BNFC-meta 0.5 - Deriving Parsers and Quasi-Quoters from BNF Grammars  https://hackage.haskell.org/package/BNFC-meta-0.5 (JonasDuregard)
01:19:19 * hackage util 0.1.0.0 - Utilities  https://hackage.haskell.org/package/util-0.1.0.0 (MatthewFarkasDyck)
01:28:40 <ertes-w> ello
01:29:08 <Unhammer> util? :-S
01:29:53 <Unhammer> though I highly approve of the function names https://hackage.haskell.org/package/util-0.1.0.0/docs/Util.html#v:-254-rd3 
01:30:17 <merijn> It's a bit rude to claim a name that generic for such a niche thing, though
01:30:27 <Unhammer> yeah
01:30:55 <Unhammer> (that's what I meant by ":-S" but words sometimes fail me)
01:32:31 <nshepperd_> "þrd3" hah
01:37:22 <Unhammer> @let ( ¯＼＿﴾ツ﴿＿／¯ ) = const
01:37:22 <lambdabot>  Parse failed: Illegal character ''\12484''
01:37:31 <Unhammer> bah
01:38:39 <merijn> > generalCategory 'ツ'
01:38:41 <lambdabot>  OtherLetter
01:38:49 <merijn> Yeah, that's not allowed in an operator
01:39:15 <ertes-w> > map (\c -> (c, generalCategory c)) "¯＼＿﴾ツ﴿＿／¯"
01:39:17 <lambdabot>  [('\175',ModifierSymbol),('\65340',OtherPunctuation),('\65343',ConnectorPunc...
01:39:43 <merijn> ertes-w: Use text to make lambdabot output sane unicode
01:39:55 <ertes-w> i think, you're trying to define a function called "¯＼＿" with an operator argument named ﴾ツ﴿ and another argument named ＿／¯
01:39:56 <merijn> > text "ツ"
01:39:58 <lambdabot>  ツ
01:40:03 <ertes-w> ah
01:40:03 <merijn> > "ツ"
01:40:05 <lambdabot>  "\12484"
01:40:18 <ertes-w> in any case you can't use parentheses in the name =)
01:40:26 <ertes-w> even if you don't mix letters and symbols
01:40:34 <merijn> good point
01:40:46 <ertes-w> @let (¯＼＿＿／¯) = (.)
01:40:48 <lambdabot>  Defined.
01:41:01 <Unhammer> they weren't regular parens … =P
01:41:08 <ertes-w> ah, indeed
01:41:23 <ertes-w> @let (¯＼＿﴾﴿＿／¯) = (.)
01:41:23 <lambdabot>  .L.hs:178:5: error: lexical error at character '\64831'
01:41:24 <lambdabot>      |
01:41:24 <lambdabot>  178 | (¯＼＿﴾﴿＿／¯) = (.)
01:41:37 <ertes-w> GHC seems to disagree though =)
01:42:03 <merijn> > generalCategory '﴾'
01:42:05 <lambdabot>  ClosePunctuation
01:42:11 <Unhammer> an ornate right parenthesis is still a parenthesis, ok
01:42:13 <ertes-w> i'm pretty sure lambdabot has that Unicode* extension enabled, so GHC will recognise more than just ASCII parens as parens
01:42:16 <merijn> I don't think that's valid
01:42:41 <ertes-w> @let (∘) :: (b → c) → (a → b) → (a → c); (∘) = (.)
01:42:42 <lambdabot>  Defined.
01:42:45 <ertes-w> yep
01:43:31 <ertes-w> @let ﴾∘∘﴿ :: ﴾b → c﴿ → ﴾a → b﴿ → ﴾a → c﴿; ﴾∘∘﴿ = ﴾.﴿
01:43:31 <lambdabot> Plugin `eval' failed with: Enum.toEnum{Word8}: tag (64830) is outside of bounds (0,255)
01:43:44 <ertes-w> no, it doesn't seem to recognise those as parens
01:44:10 <ertes-w> i wonder…
01:44:16 * hackage dual 0.1.0.0 - Dual category  https://hackage.haskell.org/package/dual-0.1.0.0 (MatthewFarkasDyck)
01:44:18 <Unhammer> @let ( ¯＼＿∘∘＿／¯ ) = const -- crabshrug
01:44:20 <lambdabot>  Defined.
01:44:49 <ertes-w> @let (∘∘) :: ∀ a b c. (b → c) → (a → b) → (a → c); (∘∘) = (.)
01:44:50 <lambdabot>  Defined.
01:44:52 <ertes-w> nice
01:45:15 <ertes-w> i'm almost inclined to use that in real code =)
01:45:16 <int-e> Huh, where does the idea that reallyUnsafePtrEquality# can give false positives come from?
01:45:18 <Unhammer> alright, now there's something we can put into all the production systems
01:45:31 <merijn> int-e: Because GC can move object and just change their pointer
01:45:51 <merijn> int-e: So if the original pointer is before a GC and the second after, they may differ despite being the same object
01:46:01 <ertes-w> i don't agree with overuse of unicode, but i wouldn't mind using GHC-supported special symbols too much
01:46:09 <ertes-w> mostly because it makes type signatures shorter and easier to read
01:46:14 <int-e> (It's a crazy operation. It's possible to observe two objects to be equal and later to be different. But if it returns true then these two objects were the same at the point; there simply is no intervening GC possible. If it were, none of ghc's code would work.)
01:46:51 <Unhammer> (I just use a little emacs prettification; wouldn't want to force other people to enter funny chars)
01:47:03 <merijn> int-e: unsafePtrEquality# returning true doesn't guarantee equality either
01:47:04 <tdammers> ertes-w: I'm currently evaluating the use of non-ascii characters in identifiers on a side project, see whether it makes things better or not
01:47:12 <quicksilver> int-e: but if one of the arguments is still an unforced closure surely than can cause a GC intervening?
01:47:14 <int-e> merijn: yes it does.
01:47:16 <merijn> int-e: Theoretically it can give both false positives and false negatives
01:47:23 <merijn> int-e: No it doesn't, I asked ezyang
01:47:24 <tdammers> ertes-w: particularly, greek letters
01:47:31 <int-e> merijn: if it's a thunk it can get duplicated later on.
01:47:35 <merijn> int-e: Same scenario with GC
01:47:43 <int-e> merijn: and if the value isn't pure you may get different values
01:47:51 <tdammers> 2 * π * r -- and all that
01:47:58 <ertes-w> tdammers: not so sure about identifiers…  the rationale behind using things like "∀" and "→" is that they are GHC-special, so everybody can know which symbols to map to the keyboard
01:47:59 <merijn> int-e: I compute a pointer, GC moves things, new thing appears in the location of the old pointer. Those two now compare equal
01:48:18 <int-e> merijn: there is no computation of a pointer
01:48:22 <tdammers> ertes-w: well, this is a personal project, and I have a pretty slick .Xcompose in place
01:48:53 <ertes-w> tdammers: also when used in type signatures, another author doesn't even have to agree about the names…  you can use "∀" and greek letters for type variables, while another author can just use latin letters and it will be compatible
01:49:31 <ertes-w> i don't want to go full agda on haskell code =)
01:49:32 <tdammers> ertes-w: ∀ is supposed to mean forall though, how would that make sense as a type var?
01:49:48 <int-e> merijn: you have haskell values, represented by pointers to the heap. Instead of working with the values by dereferencing the pointers, they are compared. The crucial point here is that dereferencing them would be a valid operation at that point in the code. So if that could mix up heap objects, heap objected would be mixed up all over the place. Which doesn't happen...
01:49:52 <ertes-w> tdammers: no, i mean "∀" as "forall"
01:49:55 <ertes-w> see above
01:50:06 <ertes-w> my definition of (∘∘)
01:50:17 <Unhammer> though if https://web.archive.org/web/20150317141448/http://www.xefer.com/2008/03/interrocolon ever gets into unicode, I will use it everywhere
01:50:21 <tdammers> ertes-w: there's this habit in parts of the PureScript community of using ∀ over forall, particularly because PureScript doesn't have implicit forall, so you end up writing it a lot
01:50:39 <merijn> int-e: The mailing list just today described it CAN give false positives
01:51:00 <ertes-w> tdammers: and i'm a heavy user of RankNTypes, which is why i'm inclined to use "∀" as well
01:51:22 <tdammers> ertes-w: RankNTypes are nice, and yes, you write a lot of forall'd vars with those
01:51:56 <merijn> By biggest gripe with RankN is that forall syntax is separated by a single .
01:52:09 <merijn> This means it's not possible to nicely line up while linewrapping!
01:52:19 <merijn> ::, =>, and -> are all two characters
01:52:26 <tdammers> if that's the biggest issue with it, then I say calloo! callay!
01:52:28 <merijn> Clearly the biggest design flaw in GHC >.<
01:52:46 <tdammers> but yes, that icks me too
01:52:57 <int-e> merijn: it claimed that without proof
01:53:05 <tdammers> I tend to consider " ." a token, not "."
01:53:15 <tdammers> so the . right-aligns with => and ->
01:53:18 <tdammers> and ::
01:53:28 <merijn> tdammers: That's what I do now
01:53:43 <tdammers> another thing I think makes rather a lot of sense is writing chains of => instead of parens
01:53:54 <merijn> int-e: I had a discussion with ezyang at some point and he told me it could produce both false positives and negatives, at least in theory
01:53:58 <tdammers> Num a => Ord a => [a] -> [a]
01:54:15 <merijn> int-e: I don't remember the details of why, though
01:54:23 <int-e> merijn: note, I can construct code where two values first compare equal as pointers and later produce different values, but it would rely on impure functions; the point being that thunks can be evaluated several times.
01:54:33 <tdammers> newer purescript releases make this mandatory :O
01:56:05 <ertes-w> merijn: that's how i write it: https://github.com/esoeylemez/rapid/blob/master/Rapid.hs#L144-L148
01:56:18 <ertes-w> the gap is kinda awkward, but it's good enough
01:56:25 <ertes-w> (before Word32)
01:56:38 <merijn> ertes-w: I don't like the gap
01:57:26 <int-e> merijn: and I know that sharing can get lost, for the same reason. but this idea of confusing heap objects is a scenario that cannot be allowed to happen because it would break all generated code.
01:57:32 <ertes-w> how would you prefer to write it?  the "::" on the same line as "rapid", and then "∀  k r." on the next line?
01:57:48 <ertes-w> (with two spaces after "∀")
01:58:06 <ertes-w> err, not quite
01:58:16 <ertes-w> "∀  k r", then ".  Word32"
01:58:22 <merijn> ertes-w: Like tdammers I currently use " ." as token
01:58:42 <ertes-w> ah, yeah, almost the same
01:58:50 <merijn> ertes-w: so http://lpaste.net/360221
01:59:22 <ertes-w> but that's quite nice…  what don't you like about it?
01:59:37 <merijn> ertes-w: That . should be a 2 symbol token like the others!
02:00:06 <ertes-w> if you use unicode, then it is =)
02:00:21 <ertes-w> … like the others that is
02:05:05 <tdammers> ∀ a . Num a ⇒ a → a
02:06:01 <tdammers> ∀ α . ℕ α ⇒ α → α
02:06:10 <tdammers> only 1 ascii token left
02:06:33 <tdammers> although using ℕ for Num is probably very confusing
02:06:43 <merijn> I'm having nightmare flashbacks to my Agda introduction
02:07:27 <tdammers> I also have a compose sequence configured for 💩
02:07:40 <tdammers> haven't used it in Haskell code yet though
02:07:48 <merijn> Which included (when asked why the code snippet on the slide didn't work) the quote "Oh...yeah, those are unicode pipes, not ASCII..."
02:08:51 <tdammers> ouch
02:09:12 <tdammers> ceci n'est pas une pipe
02:18:20 <marvin2> is it possible to change the format that ghci uses when printing (show-ing) doubles?
02:18:51 <marvin2> I know it uses Show instance by default, but perhaps this is tweakable
02:19:16 <merijn> marvin2: Not by default, no
02:19:49 <marvin2> can I redefine Show instance?
02:20:23 <ertes-w> marvin2: the standard approach is to define a newtype wrapper
02:20:27 <merijn> Only by newtyping and defining a show for the newtype
02:21:42 <haba> Good morning (for whatever TZ you are in)
02:23:50 <haba> Linux question: I would be very happy if any of the 1700+ folks in this chat room knew of a way to do a generic install to somewhere else than /usr/local/haskell. For example an USB stick.
02:24:50 <merijn> haba: Grab the GHC bindist, run "./configure --prefix=$MYPATH && make install" <- done
02:25:09 <Unhammer> merijn,  https://github.com/camsaul/emacs-unicode-troll-stopper
02:25:11 <Ferdirand> some distros might mount usb keys with noexec though
02:25:16 <merijn> haba: Then you still need a copy of cabal, which by default expects to be in ~, I suppose
02:25:21 <Unhammer> for your unicode pipes =P
02:25:29 <haba> merijn: Thanks, I think that helps me.
02:25:37 <Ferdirand> and what filesystem will you put on your usb stick anyway ?
02:26:01 <merijn> haba: Whether it will be useful from USB I dunno, but that's what I use for user local GHC installs everywhere
02:26:31 <haba> Ferdirand: I can format my stick to ext4 whatever if necessary
02:29:08 <haba> merijn: Ok, an alternative to USB would be to prepare to copy to $HOME/something/
02:30:19 <haba> merijn: If that's what you mean by "user local GHC"
02:35:25 <merijn> haba: In that case you might as well just put the GHC bindist + cabal on your USB :)
02:35:45 <merijn> haba: And yes, by user local I mean installed in the homedir (since I can't touch anything else on university machines :p)
02:36:24 <merijn> Although, if the means you plan to use it on have internet access anyway, maybe just download the bindist directly on them and skip the USB stick ;)
02:36:33 <merijn> s/means/machines
02:36:38 <merijn> Jesus typing is hard today
02:39:22 <haba> merijn: Yes, there are such days. Thanks for the pointers. I will test a bit what works best in this case. Now in my TZ there will be lunch (AFK)
03:13:29 <int-e> merijn: So I've done some digging into ghc's RTS and garbage collections never run concurrently with Haskell evaluation after all. There's a design for that, even a paper ("Multicore Garbage Collection with Local Heaps") but the code never made it into ghc's HEAD (or releases). Even with that design, since objects that might be seen by other cores would be on a "sticky" heap (essentially pinned),...
03:13:35 <int-e> ...or on the global heap, and what I said about pointer comparisons would still be true.
03:22:13 <rightfold> Say you have a language with record field access, and you have written a type checker that checks record access always occurs with fields that actually exist. Now if you want to interpret this language in Haskell, you still have to handle the case where the field doesn’t exists. Is there a way around this without exceptions?
03:23:12 <rightfold> Somehow track the welltypedness of the expression in Haskell statically
03:25:47 <rightfold> Perhaps with rank-N types a la ST
03:29:13 * hackage monad-var 0.1.1.1 - Generic operations over variables  https://hackage.haskell.org/package/monad-var-0.1.1.1 (effectfully)
03:31:49 <mniip> rightfold, it's possible
03:31:54 <mniip> but needs more detail
04:15:31 <joebetz> can aeson parse json without field names?
04:15:35 <joebetz> e.g., ["sword",["sword art online","sword","swordfish"]]
04:19:12 <mniip> what would be an elegant combinator for
04:19:14 <merijn> joebetz: Then it's not json anymore?
04:19:20 <mniip> MonadPlus m => m (Maybe a) -> m a
04:20:11 <merijn> :t maybe mzero return
04:20:13 <lambdabot> MonadPlus m => Maybe a -> m a
04:20:25 <merijn> :t (>>=maybe mzero return)
04:20:28 <lambdabot> MonadPlus m => m (Maybe b) -> m b
04:20:32 <tdammers> merijn: sure is
04:20:52 <tdammers> joebetz: yes, it can, but not the way you want it to, most likely
04:21:04 <tdammers> joebetz: you can of course write your own JSON instances that understand data structures like these
04:21:17 <mniip> merijn, I feel like there's a combinator for that already
04:21:19 <tdammers> joebetz: or you can deserialize to Value, and operate on that
04:22:40 * hackage weigh 0.0.6 - Measure allocations of a Haskell functions/values  https://hackage.haskell.org/package/weigh-0.0.6 (ChrisDone)
04:23:01 <joebetz> merijn: I ran it through a generic json parser and it was considered valid json, so...
04:23:06 <joebetz> but yeah, I wondered the same thing
04:23:13 <tdammers> it is valid JSON
04:23:33 <tdammers> and aeson can parse it
04:23:43 <joebetz> okay
04:23:56 <tdammers> it's just that none of the automatically derived FromJSON instances out there will accept such a format
04:24:07 <ij> I'm struggling to write mapActionMaybe. Can anyone help? mapActionMaybe :: Applicative f => (a -> m (Maybe c)) -> [b a] -> m [b c]
04:24:09 <tdammers> except nested tuples, but then the number of elements must match exactly
04:24:23 <tdammers> or actually, (String, [String]) would work
04:24:49 <joebetz> even if the whole thing is wrapped in an array?
04:25:17 <tdammers> (String, [String])'s JSON instance parses the entire array
04:25:50 <marvin2> ij you did not use 'f' constraint
04:26:06 <ij> that should be an m
04:27:47 <joebetz> tdammers: okay sweet, I'll try that out
04:28:41 <kuribas> If I have a function f () = big_value, will big_value be evaluated everytime I call f?
04:28:48 <kuribas> Even with optimizations on?
04:30:14 <kuribas> For example, if big_value is the complete evaluation tree of chess, No leaves would be garbage collected if I had f = big_value
04:31:24 <tdammers> joebetz: http://lpaste.net/360222
04:32:30 <ij> Okay, I wrote it! fmap (catMaybes . fmap (traverse id)) . mapM (traverse a) The type's a bit differently constrained, though.
04:37:51 * hackage universum 0.8.0 - Custom prelude used in Serokell  https://hackage.haskell.org/package/universum-0.8.0 (shersh)
04:38:39 <kuribas> traverse id == sequence
04:39:07 <joebetz> tdammers: works :)
04:39:11 <kuribas> :t sequence
04:39:13 <lambdabot> (Monad m, Traversable t) => t (m a) -> m (t a)
04:39:15 <kuribas> :t traverse id
04:39:17 <lambdabot> (Applicative f, Traversable t) => t (f b) -> f (t b)
04:39:22 <kuribas> almost
04:39:37 <ij> kuribas, I wrote it in only an hour or more!
04:39:43 <ij> Sequence works in this case, yes.
04:41:02 <kuribas> ij: you can often write code by a series of transformations.
04:41:40 <phadej> :t sequenceA
04:41:41 <lambdabot> (Applicative f, Traversable t) => t (f a) -> f (t a)
04:42:50 <ij> Hm. That function works when given [(1,3)] and some action, but not on [(1,2,3)]. :(
04:43:29 <ij> kuribas, I did a lot of trial and error in ghci, so I didn't think of it and then sit down and write it.
04:43:50 <phadej> ij: nobody bothered to write Applicative instance for 3-tuple?
04:45:01 <ij> Nor a functor...
04:45:43 <kuribas> lens to the rescue
04:47:38 <phadej> ij: fwiw, I have no idea what you are trying to do, and what you have. Posting to the lpaste (or some other pastebin) would help a lot to help you
04:49:59 <infinisil> but not pastebin itself :P
04:53:50 <mniip> fascinating
04:54:08 <mniip> it's 2017 and still no way to pattern match on 0/1+n on the type level
04:55:18 <infinisil> mniip: You mean because it's 1+n and not S n? (I don't know about Nats in Haskell, but I'd imagine pattern matching on S n be possible)
04:55:35 <mniip> GHC.TypeLits
04:58:06 <ij> > let mapActionMaybe a = fmap (catMaybes . fmap (traverse id)) . mapM (traverse a) in mapActionMaybe (\a -> Identity (Just $ a + 1)) [(0,0)]
04:58:09 <lambdabot>  Identity [(0,1)]
04:58:32 <ij> Here's what I'm trying to do, phadej. It just won't work because there's no Traversable(not Applicative) for (,,).
04:58:45 <phadej> I'm quite sure there is
04:59:07 <phadej> > traverse print ((), (),  True)
04:59:09 <lambdabot>  error:
04:59:09 <lambdabot>      • No instance for (Traversable ((,,) () ()))
04:59:09 <lambdabot>          arising from a use of ‘traverse’
04:59:12 <ij> :D
04:59:34 <ij> I mean, I'm looking at the hackage docs of Data.Traversable for the latest base.
04:59:41 <ij> It ain't there.
04:59:50 <mniip> ij, compose (,) (,)
05:00:05 <merijn> ij: Yes, because people were bitching about adding those being even more confusing than (,), etc.
05:00:15 <mniip> or even better
05:00:19 <mniip> just use ((x, y),)
05:00:29 <infinisil> Oh my god, the implementation of tuples is really ugly in Haskell
05:00:31 <ij> ugh
05:00:53 <ij> Meh.
05:01:23 <phadej> hmm, I  was quite sure there were instances for >=3-tuples, IMHO sad there isn't
05:02:04 <infinisil> Can templatehaskell do it?
05:02:20 <phadej> > bitraverse id print ((), (), True)
05:02:22 <lambdabot>  error:
05:02:22 <lambdabot>      • Variable not in scope:
05:02:22 <lambdabot>          bitraverse :: (a0 -> a0) -> (() -> IO ()) -> ((), (), Bool) -> t
05:02:23 <ij> Well writing that function ls
05:02:31 <phadej> > Data.Bitraverse.bitraverse id print ((), (), True)
05:02:31 <ij> Well writing that function was rather pointless then.
05:02:32 <lambdabot>  error:
05:02:33 <lambdabot>      Not in scope: ‘Data.Bitraverse.bitraverse’
05:02:33 <lambdabot>      No module named ‘Data.Bitraverse’ is imported.
05:02:40 <phadej> > Data.Bitraversable.bitraverse id print ((), (), True)
05:02:43 <lambdabot>  error:
05:02:43 <lambdabot>      Not in scope: ‘Data.Bitraversable.bitraverse’
05:02:43 <lambdabot>      Perhaps you meant ‘Data.Traversable.traverse’ (imported from Data.Traver...
05:02:48 <phadej> :/
05:02:56 <phadej> > _3 print ((), (), True)
05:02:59 <lambdabot>  <IO ((),(),())>
05:03:12 <phadej> lens to the rescue, indeed.
05:03:34 <ij> I don't know how to put it in my function, though.
05:03:39 <ij> yet
05:03:46 <phadej> lens is a rabbit hole :)
05:04:29 <ij> I've some familiarity.
05:04:30 <kuribas> lens is like those houses in games which are much smaller on the outside as on the inside.
05:05:15 <ij> Can I (,,,) <-> ((,,),) with it? :D
05:05:30 * ij moves to another building
05:08:30 <kuribas> If I define chess_tree = ... as the complete evaluation of the chess move tree, then when exploring the tree, none of the leaves will be garbage collected, right?
05:08:45 <kuribas> Will it help defining it as a function? chess_tree () = ...
05:10:26 <Gurkenglas_> :t (mapMaybe $ _3 %%~ \x -> Just (x+1)) :: [(a, b, Int)] -> [(a, b, Int)] -- ij
05:10:29 <lambdabot> [(a, b, Int)] -> [(a, b, Int)]
05:11:26 <Gurkenglas_> (note (%%~) = traverseOf = id)
05:11:45 <marvin2> infinisil what is ugly about it?
05:12:14 <infinisil> marvin2: http://hackage.haskell.org/package/ghc-prim-0.5.1.0/docs/src/GHC.Tuple.html#Unit
05:12:34 <Gurkenglas_> kuribas, they will be garbage collected once you have no more way to refer to them, because you dropped all references to nodes above a leaf
05:14:43 <kuribas> Gurkenglas_: except they are refered to in the root.
05:14:47 <marvin2> infinisil hmm, is that even legal haskell? seems more like conceptual "lets pretend this is how it is implemented" thing, like lambdabot's src for list
05:15:03 <Gurkenglas_> kuribas, then stop refering to the root
05:16:10 <dminuoso> infinisil: The one thing that I find disconcerning is: {- Manuel says: Including one more declaration gives a segmentation fault.
05:17:08 <infinisil> marvin2: This is the actual tuple implementation
05:17:33 <infinisil> dminuoso: Agreed
05:18:34 <kuribas> Gurkenglas_: so my question is, if I make it a function, does it keep a reference to the root?
05:18:46 <kuribas> Gurkenglas_: like chess_tree () = ...
05:18:54 <kuribas> Gurkenglas_: after optimization
05:19:36 <kuribas> Gurkenglas_: I mean, without optimizations obviously not
05:19:58 <Gurkenglas_> Willing to bet 10:1 it doesn't (except that people will only agree if they have insider information :P)
05:25:54 <cocreature> kuribas: full lazyness will float things out of lambdas so making it a function doesn’t help
05:26:16 <cocreature> kuribas: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/using-optimisation.html?highlight=full%20laziness#ghc-flag--ffull-laziness
05:26:58 <cocreature> there are relatively long discussions about whether that’s a good idea or not since it basically means that you have no way to prevent GHC from sharing things
05:28:50 <kuribas> isntt there a pragma to disable sharing?
05:29:54 <kuribas> Like a weak ref?
05:32:32 <merijn> Doesn't sound like you want a weak ref here
05:33:40 <kuribas> merijn: yes, tree = ...  would garbage collect what it refers to if it's the only one that refers to it.
05:33:52 <kuribas> That's a weak ref right?
05:34:51 <merijn> kuribas: Weak references are a way to have a reference that does not prevent getting GCed
05:35:13 <merijn> kuribas: eh, a weak reference is a reference to something that "may or may not" exist
05:35:23 <merijn> They rely on other references to keep the value alive
05:35:58 <kuribas> merijn: what I mean is the value is not boxed
05:35:59 <merijn> kuribas: So if your tree is a weak reference, nothing stops GHC from immediately getting rid of the entire thing
05:36:41 <kuribas> merijn: that's what I want.  When I pass it through a function, it gets reevaluated.
05:37:02 <merijn> kuribas: No, then the weak reference just returns Nothing after that
05:37:16 <merijn> I doubt it's what you want, tbh
05:37:31 <kuribas> merijn: not exactly a weak ref then
05:43:52 <cocreature> kuribas: https://ghc.haskell.org/trac/ghc/ticket/12620 is the relevant ticket about providing a way to prevent sharing
05:47:46 <saurabhnanda> I seem to have tied myself into a type knot. Can anyone help me solve this type error: https://gist.github.com/saurabhnanda/66f2b1d2db293708678eb8917a7d1366 -- how do I tell the compiler that the `auth` in `Env auth` and `AppM auth` is the same?
05:50:54 <merijn> saurabhnanda: "(Env auth ~ AppM auth)"?
05:51:05 <int-e> saurabhnanda: can you make 'auth' a parameter of HasEnv?
05:51:37 <saurabhnanda> merijn: doesn't that mean that `Env auth` and `AppM auth` are the same type?
05:52:05 <merijn> saurabhnanda: Wait, are you importing the right "ask"?
05:52:25 <saurabhnanda> merijn: isn't there just one 'ask'?
05:52:47 <int-e> saurabhnanda: as is, getEnv :: m (Env auth)  means the function has to work for all possible types for auth. (oh instead of the parameter you may also consider an associated type family that maps m to the corresponding auth type)
05:52:50 <merijn> saurabhnanda: You have the one from Control.Monad.Reader which requires MonadReader and the one from Control.Monad.Trans.Reader which is a function on ReaderT
05:53:18 <saurabhnanda> what?! there are two 'ask'
05:53:48 <merijn> saurabhnanda: Control.Monad.Reader is the mtl lifted version of the one from transformers
05:54:42 <saurabhnanda> merijn: this brings me to the question -- what's the diff between mtl & transformers?
05:55:01 <merijn> saurabhnanda: mtl is a bunch of typeclass junk to "auto" lift things in transformers
05:55:34 <merijn> saurabhnanda: Also "(Monad m, MonadIO m)" on line 14 is redundant, since MonadIO has Monad as superclass
05:55:47 <saurabhnanda> merijn: so switched Reader to Trans.Reader and the error message changed. But the underlying problem is still the same.
05:55:59 <saurabhnanda> Couldn't match type ‘auth’ with ‘auth1’
05:56:48 * hackage html-tokenizer 0.5 - An "attoparsec"-based HTML tokenizer  https://hackage.haskell.org/package/html-tokenizer-0.5 (NikitaVolkov)
05:56:59 <saurabhnanda> int-e: is type family or fun-deps the only way around this?
05:57:02 <merijn> saurabhnanda: That's what int-e pointed out, your HasEnv claims to work for all auth's. Whereas "ask" only typechecks for one specific one
05:57:20 <int-e> saurabhnanda: as far as I know, yes
05:58:13 <saurabhnanda> okay
05:58:15 <saurabhnanda> so this worked
05:58:27 <saurabhnanda> instance HasEnv (AppM auth) where //   type MonadAuth (AppM auth) = auth //   getEnv = ask
05:58:46 <saurabhnanda> god save the next person who has to understand this code
06:08:31 <saurabhnanda> merijn: int-e thanks
06:42:15 * hackage propellor 5.1.0 - property-based host configuration management in haskell  https://hackage.haskell.org/package/propellor-5.1.0 (JoeyHess)
07:23:08 <ij> How do I make a lens that works on each list item? So that (thatlens . _1) .~ 2) $ [(1,1)] = [(2,1)].
07:24:43 <lyxia> thatlens = traverse
07:26:18 <mniip> that's not a lens
07:27:41 <ij> Isn't it lens-like?
07:27:51 <cocreature> it’s a Traversal
07:28:09 <cocreature> a Lens always targets a single element
07:28:38 <ij> So it isn't?
07:30:09 <cocreature> it isn’t what?
07:30:20 <ij> lens-like
07:31:45 <cocreature> if you have an Applicative constraint on "f" you can use it as a "LensLike f s t a b" for some choice of s,t,a,b
07:32:16 <cocreature> but I would say LensLike is more of an implementation detail than something that you should use to categorize things
07:40:28 <ij> For an "a :: a -> IO (Maybe b)", how could I make a [a] -> IO [a], where the Nothings are ommited?
07:40:45 <ij> IO [b] as the result, sorr
07:41:03 <merijn> catMaybes <$> mapM a myList
07:41:13 <merijn> :t mapM
07:41:15 <lambdabot> (Monad m, Traversable t) => (a -> m b) -> t a -> m (t b)
07:41:17 <merijn> :t catMaybes
07:41:18 <lambdabot> [Maybe a] -> [a]
07:41:27 <ij> oops, a bit more difficult
07:41:39 <merijn> :t mapM (undefined :: a -> IO (Maybe b))
07:41:41 <lambdabot> Traversable t => t a -> IO (t (Maybe b))
07:41:44 <ij> ah, crap, I'll have to make a pastie to explain it right
07:41:47 <merijn> :t mapM (undefined :: a -> IO (Maybe b)) []
07:41:48 <lambdabot> IO [Maybe b]
07:42:14 <ij> I'll be back with a pastie in an hour
07:43:27 <ertes-w> let's contribute to getting rid of the legacy
07:43:36 <ertes-w> ij: use 'traverse' instead of 'mapM'
07:43:46 <ertes-w> it's the same function
07:44:53 <Cale> I don't like seeing traverse as much if the generality isn't required in context though
07:45:18 <merijn> same
07:46:15 <cocreature> I wish we had a mapA or something like that
08:03:42 <infinisil> Is there a function for something like (Traversable t, Monad m) => (a -> m ()) -> t a -> m ()
08:04:08 <infinisil> Or (Int -> IO ()) -> [Int] -> IO () in my case
08:04:26 <int-e> :t mapM_
08:04:28 <lambdabot> (Monad m, Foldable t) => (a -> m b) -> t a -> m ()
08:04:32 <merijn> :t traverse_
08:04:34 <lambdabot> (Applicative f, Foldable t) => (a -> f b) -> t a -> f ()
08:07:46 <infinisil> int-e: merijn: Thanks! I'm gonna use mapM_ as I already have Control.Monad in my imports :)
08:08:19 * hackage yesod-csp 0.2.3.0 - Add CSP headers to Yesod apps  https://hackage.haskell.org/package/yesod-csp-0.2.3.0 (boblong)
08:17:23 <infinisil> @pl f a b = mapM_ (g a b) [0..]
08:17:23 <lambdabot> f = flip flip [0..] . (mapM_ .) . g
08:17:45 <infinisil> less beautiful than I hoped
08:31:47 <cuichen> wow!so many people here
08:32:50 <geekosaur> infinisil, (forM_ [0..] .) . g
08:32:59 <geekosaur> @pl is not all-knowing
08:32:59 <lambdabot> is not all - knowing
08:33:01 <geekosaur> heh
08:42:21 <infinisil> geekosaur: That looks a bit better thanks :P
08:56:20 <python476> hello
08:56:26 <python476> anybody familiar with winhugs ?
08:57:03 <python476> was wondering if it was possible to define function at the toplevel/repl
08:57:17 <python476> without resorting to file edition (which I do right now)
09:02:48 * hackage cndict 0.9.0 - Chinese/Mandarin <-> English dictionary, Chinese lexer.  https://hackage.haskell.org/package/cndict-0.9.0 (DavidHimmelstrup)
09:06:13 <Cale> python476: Nope, but also, hugs is very old and unsupported. You should probably look into getting ghc / ghci installed.
09:10:43 <python476> Cale: right, but, and sorry in advance, GHCI is huge, it triggers all my frugal warning senses
09:11:12 <python476> but IIRC even in GHCI definining function is a bit of a drag, does it still require a pair of :{ ?
09:13:10 <Saizan> python476: if you need multiple lines, yes
09:15:13 <python476> Saizan: aight
09:15:17 <Taneb> python476: one alternative to that is if you write "set +m" you get multiline input by default
09:15:27 <Taneb> *":set +m"
09:15:28 <python476> I suppose no haskellers needs interactive definitions
09:15:40 <python476> Taneb: ah well, I forgot that bit
09:15:43 <Saizan> reloading is pretty fast
09:16:01 <python476> Im spoiled by lisps 
09:16:26 <geekosaur> given there's no way to save such to a file, and Haskell kinda really wants to be compiled instead of interpreted, they're less useful anyway
09:16:31 <Saizan> have some consolation ($)s
09:16:36 <geekosaur> like C REPLs are not common becaause C prefers to be compiled
09:17:01 <glguy> I use GHCi as my C repl
09:17:11 <EvanR> however the activity of defining things one after the other is pretty cool... except in real life real people mess up the definitions and need to go back
09:17:14 <Taneb> glguy: that feels showing off
09:17:27 <EvanR> so like, writing down the theory in pen
09:17:34 <EvanR> the text editor is pencil
09:17:40 * hackage midimory 0.0.0.3 - A Memory-like (Concentration, Pairs, ...) game for tones  https://hackage.haskell.org/package/midimory-0.0.0.3 (HenningThielemann)
09:17:49 <python476> winhugs might be unsupported but fact 10000 still takes less than a sec on my 2009 laptop; gotta say, I'm smiling
09:17:58 <glguy> Taneb: I don't understand your message, but GHCi's quite nice for it
09:18:17 <glguy> I can load object files and foreign import stuff from the repl to experiment with it
09:18:20 <python476> geekosaur: I think someone made a c++ repl not long ago
09:18:24 <python476> it's a matter of perspective
09:18:32 <Taneb> glguy: ah, it was meant in jest and kind of sounded better in my head I'm afraid
09:18:33 <Cale> python476: Usually I like to put my definitions in files regardless, because it's a little too easy to want to keep them later.
09:18:44 <python476> Cale: I understand
09:18:46 <EvanR> evaluating C expressions to see wtf they do would be cool
09:19:02 <geekosaur> oh, they do exist, but ... "not long ago"? anfd C++ is how old? kinda tells you the demand right there
09:19:04 <python476> EvanR: I think that was the purpose, it was half live debug half coding
09:19:16 <python476> as I said, I'm spoiled by common lisp, also ipython
09:19:46 <python476> geekosaur: I disagree, it's just that repls got in favor again, in the 90s almost nobody cared
09:19:53 <python476> look how java is having a repl now too
09:19:58 <EvanR> i did that a lot in ruby, but i have no clue how i survived not being able to save what i did to a file
09:20:12 <EvanR> i eventually changed to doing everything in a ruby file, and loading it in the repl
09:20:40 <python476> smalltalkers would laugh at us poor coders
09:20:42 <geekosaur> aka in the 90s people didn't try to turn every language into js
09:21:29 <EvanR> did smalltalkers implement everything on a command line with a line editor 
09:21:38 <EvanR> because that part sounds terrible
09:21:53 <python476> they do everything in their class browser
09:22:11 <EvanR> is that like a full featured text editor
09:22:11 <python476> with versioning now (a problem in the past)
09:22:18 <python476> it's better than eclipse
09:22:29 <python476> (which doesn't give a lot but still)
09:23:05 <python476> I followed a pharo (ST fork) mooc last year, I can't hide that it was a pretty delightful experience
09:23:29 <EvanR> what is a pharo (ST fork) mooc
09:23:43 <python476> a MOOC, an online course
09:24:14 <python476> Pharo is SmallTalk implementation (with a few differences I believe)
09:25:10 <EvanR> something about dynamic everything really seems broken to me, now a days at least
09:26:09 <EvanR> i am too steeped in haskell and post haskell ritual
09:27:09 <EvanR> when you write out a theory, its meaningless until complete in a sense.
09:27:52 <EvanR> the land between transitions between two complete programs is frightening
09:27:58 <python476> EvanR: Im not surprised by your pov
09:28:11 <python476> i have no conclusion about the topic
09:28:53 <EvanR> imagine the "lisp expression" ((+ x y) 
09:29:00 <EvanR> the horror right
09:29:02 <python476> but to be fair, ST object model is infinitely more sensible than more dynamic languages, it has a theory feels to it, you know in advance the semantics (unless you fubar the logic by monkeypatching)
09:29:24 <python476> we just need prolog based parsers ;)
09:29:41 <python476> s/more/most
09:57:30 <rightfold> > print (undefined `par` ())
09:57:33 <lambdabot>  error:
09:57:33 <lambdabot>      • Variable not in scope: par :: t0 -> () -> ()
09:57:33 <lambdabot>      • Perhaps you meant one of these:
09:58:35 <rightfold> If you throw from a spark, will Control.Exception.evaluate catch it?
10:08:40 <rightfold> I’ll create a GH issue since this isn’t documented :3
10:18:11 * hackage ViennaRNA-bindings 0.233.2.0 - ViennaRNA v2 bindings  https://hackage.haskell.org/package/ViennaRNA-bindings-0.233.2.0 (ChristianHoener)
10:48:41 * hackage fluid-idl 0.0.5 - Fluid | The Programmatic IDL  https://hackage.haskell.org/package/fluid-idl-0.0.5 (jxv)
10:50:23 <MarcelineVQ> but what is an IDL
10:50:56 <geekosaur> interface definition language
10:51:59 <MarcelineVQ> thank you
10:52:01 <geekosaur> basoically describes remote procedure calls
10:52:10 <geekosaur> and remote object activations
11:04:57 <rightfold> Haskell without equations 😛
11:07:58 <humanoyd> rightfold: #purescript is just not the same without you :/
11:10:35 <rightfold> If it moves away from Slack I’d be glad to come back ;P
11:16:11 <barrucadu> I appear to have just received a bunch of messages from ghc-devs from January of 2014.  Is this happening to anyone else?  Looks like there might be a fault on haskell.org, as there's a mailman header: "X-Mailman-Approved-At: Thu, 23 Nov 2017 18:36:34 +0000"
11:17:28 <barrucadu> The thread is "A modest proposal (re the Platform)", with the first message sent by Mark Lentczner on 2014-01-19
11:18:19 <geekosaur> yes, looks like someone is unsticking a bunch of stuck mail queues for haskell-related mailing lists
11:18:48 <geekosaur> I'm getting messages dated 2014 from libraries@
11:18:51 <johnw> geekosaur: that was me
11:19:09 <johnw> I found several stuck messages that looked legit, so I unstuck them for posterity's sake
11:19:23 <johnw> I suppose I should mention this to the list
11:21:04 <johnw> ok, sent a notice
12:22:37 <ocramz> hullo!
12:23:18 <ocramz> I'm looking for a safe wrapper around `zlib`, does one exist?
12:23:38 <ocramz> e.g. the `decompress` function is `ByteString -> ByteString`, which is clearly a lie
12:24:16 <hpc> what's a lie about it?
12:24:22 <hpc> oh, errors
12:24:31 <ocramz> for example
12:28:09 <python476> so I'm reading LYAH, I've seen some critics about it, do you think I should avoid it ? or is it a matter of personal taste ?
12:28:36 <ocramz> python476, if you're a beginner then it's a good resource to build some intuition on the language
12:29:11 <ocramz> refer also to the WikiBook: https://en.wikibooks.org/wiki/Haskell
12:29:12 <python476> ok
12:29:57 <python476> so I guess the issue is for experienced haskellers that have different opinions on some topics 
12:30:16 <jle`> python476: i don't think you should avoid it, per se, but if you read it you should definitely supplement it
12:30:24 <jle`> @where learnhaskell
12:30:24 <lambdabot> https://github.com/bitemyapp/learnhaskell
12:31:19 <python476> good, this book was my planned follow up
12:31:37 <python476> so many people seems to think it's the best book to learn haskell so far
12:31:45 <algun|home> Why differentiate between morphisms and functions in our domain?
12:32:04 <jle`> python476: note that the link i posted wasn't a book, it was a list of resources
12:32:06 <ocramz> python476 if you are serious about learning the language then http://haskellbook.com/ receives very good reviews
12:32:15 * hackage conduit-parse 0.1.2.2 - Parsing framework based on conduit.  https://hackage.haskell.org/package/conduit-parse-0.1.2.2 (koral)
12:32:43 <ocramz> but if you want to stick to free resources, the learnhaskell page takes you a long way
12:32:43 <jle`> algun|home: it depends on the context of course, but 'functions' is usually reserved for morphisms of specific types of categories
12:33:42 <algun|home> jle`: that's the corollary: Why differentiate between categories and sets in our domain?
12:34:15 * hackage silvi 0.0.3 - A generator for different kinds of logs.  https://hackage.haskell.org/package/silvi-0.0.3 (chessai)
12:34:29 <python476> jle`: I misread github as twitter (I follow bitemyapp there) hence the confusion
12:35:04 <jle`> algun|home: catgories and sets are...different things
12:35:28 <jle`> they are different mathematical concepts
12:36:42 <jle`> so it doesn't make sense to *not* differentiate them
12:36:57 <jle`> that's like asking why we differentiate between integers and calculus
12:37:18 <jle`> (er, the pun was not intended)
12:37:39 <python476> jle you use CT often ? is it useful in avegare applications too or only so for mathematical problems ?
12:37:57 <jle`> do you mean in programming?
12:38:06 <jle`> it's not something we usually directly use in application programming
12:38:06 <python476> yes
12:38:26 <jle`> it sometimes gives us nice ways to guide writing our libraries/interfaces
12:38:42 <jle`> but also recognizing that some of our common patterns follow CT principles is useful
12:38:59 <jle`> so we can make refactorings that are justified by the mathematics of the abstraction
12:39:15 <jle`> like being able to refactor:
12:39:23 <python476> slightly related (even if only so slightly) I remember ml guys using ml functors to model network layers so they could have generic transport layers in FP. Im always looking for similar blend of abstraction and "trivialities" if I may say so
12:39:27 <jle`> > (map (*2) . map (+4)) [1,2,3]
12:39:29 <jle`> into
12:39:29 <lambdabot>  [10,12,14]
12:39:34 <jle`> > map ((*2) . (+4)) [1,2,3]
12:39:36 <lambdabot>  [10,12,14]
12:40:08 <jle`> i wouldn't call it a direct usage of CT any more than someone rewriting "3 * 7" to be "7 * 3" to be an application of abelian group theory
12:40:08 <python476> your io got into the order :p
12:40:19 <python476> heh
12:40:53 <jle`> but being 'aware' of certain things does help with refactoring sometimes
12:41:10 <python476> but it would be nice to have some abstract modeling of network stacks (fuzzy on purpose here) or even network topologies and be able to reason at that level
12:41:27 <python476> networking being just an example
12:41:40 * hackage dublincore-xml-conduit 0.1.0.2 - XML streaming parser/renderer for the Dublin Core standard elements.  https://hackage.haskell.org/package/dublincore-xml-conduit-0.1.0.2 (koral)
12:41:41 <jle`> yeah, and if your stacks can match some  known mathematical model, you can leverage all of the conclusions and theorems from that model
12:41:53 <python476> right
12:42:14 <python476> avoid bugs, incoherent states, leap into optimizations so and so forth
12:42:32 <jle`> mhm
12:43:07 <python476> anyway back to lyah, thanks 
12:43:12 <algun|home> jle`: Disagree. Set (theory) is to function as category (theory) is to morphismm
12:43:37 <jle`> even if that was true, that doesn't mean that sets and categories are the same concept
12:43:55 <jle`> red is to apple as yellow is to banana => "why distinguish between red and yellow?"
12:44:30 <jle`> but in any case, sets and categories are definitely distinct concepts
12:44:45 <jle`> what is your definition of a category?
12:45:03 <algun|home> jle`: I didn't say they were the same concepts, just like I didn't say all morphisms were functions
12:45:23 <jle`> you asked why they should be distinguished from each other?
12:46:08 <algun|home> My question is why talk about the abstraction in our domain? There don't seem to be morphisms here that aren't functions in programming languages.
12:47:28 <algun|home> *here=in programming languages
12:47:50 <algun|home> The lack of a quick response to this makes me think I am right.
12:48:36 <lines> the above (haskellbook.com) - is it a good source of exercises?
12:49:06 <lines> I and a workmate are doing a bit of haskell learning right now, but we're finding ourselves slightly short of /useful/ exercises
12:50:15 * algun|home grins sarcastically
12:51:03 <ij> algun|home, Lack of a quick response doesn't necessarily mean anything.
12:51:21 <algun|home> ij: i grant it's not conclusive
12:53:12 <algun|home> ij: but the fact that you addressed the logic rather than the substance further ups the probability ;)
12:54:10 <ij> You did it first, I addressed it and now you're doing it yourself again.
12:54:23 <erisco> stop hitting yourself
12:54:32 <lines> algun|home: so I appreciate I'm coming at this half-cocked, but I can imagine why you'd want to seperate the two
12:54:54 <algun|home> i should tone my glee lest i be accused of living under a bridge
12:55:25 <lines> the sort of easy example of something which is a category but can't easily be regarded as an underlying set would be, IDK, a directed graph (or more properly a directed graph generates such a category)
12:56:13 <algun|home> lines: what is a set of vertices?
12:56:57 <algun|home> lines: i think you're chasing after some morphism of morphisms. I have a faint memory of there being such an example somewhere
12:57:15 <lines> ha :P
12:57:48 <erisco> a morphism of morphisms? like a functor?
12:58:40 <algun|home> erisco: indeed i think it was even more involved
12:58:53 <erisco> well, choose the simpler one :)
12:58:53 <algun|home> and i'm not sure it was applicable to computer science
12:59:09 <lines> do you mean natural transformations?
13:00:40 * hackage haskell-lsp 0.2.0.0 - Haskell library for the Microsoft Language Server Protocol  https://hackage.haskell.org/package/haskell-lsp-0.2.0.0 (AlanZimmerman)
13:01:16 <algun|home> lines: erisco: my memory is as good or worse than yours
13:02:00 <lines> I'm just not quite sure what your question is :P
13:03:32 <algun|home> lines: i'd like an example of a category that is not a set, or a morphism that is not a function, but which have something to do with programming languages (or if not i'd settle for any domain, provided i can understand the example)
13:04:00 <lines> algun|home: I gave you one!
13:04:17 <lines> wait, do you want the /underlying collection of objects/ to not be a set?
13:04:51 <glguy> algun|home: You can look at the instances of the Category class in base to see some non-function morphisms http://hackage.haskell.org/package/base-4.10.0.0/docs/Control-Category.html
13:05:05 <erisco> uh, well, types as objects are a good example :P
13:05:07 <dminuoso> algun|home: Functors? Monads? Natural Transformations?
13:05:25 <dminuoso> algun|home: Monoids?
13:05:58 <algun|home> erisco: see i don't know. It fits the definition of a function. You operate on sets of types.
13:06:10 <dminuoso> algun|home: Categories don't "exist". It just turns out that a lot of things form categories.
13:06:13 * hackage subzero 0.1.0.1 - Helps when going "seed values" -> alternatives and optional -> answers  https://hackage.haskell.org/package/subzero-0.1.0.1 (codeshot)
13:06:17 <erisco> algun|home, you can also read conal's Compiling to Categories paper which lists several useful categories computationally
13:06:18 <algun|home> it = type constructor
13:06:25 <lines> dminuoso: I mean it depends how Platonic you want to get :P
13:06:34 <erisco> algun|home, there are no sets involved
13:07:17 <lines> algun|home: consider the category with two objects, A and B, an arrow from A to B. A, B aren't sets. They're just things.
13:07:39 <algun|home> erisco: maybe there's just a one (though I can arbitrarily differentiate between say basic types and collection types), but i don't see how it's anything but a set of those things
13:07:40 <lines> that is definitely a category but its arrow isn't a function and its objects aren't elements
13:07:48 <dminuoso> algun|home: One great example is preorders or partial orders.
13:07:53 <erisco> algun|home, possibly you're confusing the ability to encode an object as a set with the actuality of that object being a set
13:07:56 <dminuoso> algun|home: those naturally form categories.
13:07:59 <algun|home> lines: that's circular logic!
13:08:05 <lines> algun|home: no it's not?
13:08:22 <dminuoso> algun|home: (there morphisms represent relationships, and objects represent elements from the set you are looking at)
13:08:23 <algun|home> yes, i asked for a counter example and you said imagine a example that is counter
13:08:30 <lines> algun|home: yes well this is maths :P
13:08:40 <algun|home> circular maths :P
13:08:43 <algun|home> sec, catching up with others
13:09:25 <jle`> algun|home: are you familiar with the concept of monoids?
13:09:39 <lines> algun|home: what do you understand a category to be?
13:10:18 <algun|home> erisco: but numbers aren't sets themselves. Yet functions that operate on them (are just functions and so) work with sets (of numbers). Maybe I'm confused, but I don't see how.
13:10:49 <dminuoso> algun|home: Not that its particularly useful, but you can just form a singleton set with any element.
13:10:50 <erisco> algun|home, well your second statement, if you think that is a necessity for functions, is just wrong
13:11:18 <jle`> algun|home: if you want an example of a category that is not a set... your example is *every* category
13:11:20 <dminuoso> algun|home: Do you know what a category actually is? What defines a category?
13:11:23 <jle`> no category is a set
13:11:32 <jle`> no set is a category
13:11:35 <algun|home> lines: pretty much a set of similar things. That's why I ask, I'm not a mathematician, I don't venture far from applied maths (CS).
13:11:46 <lines> algun|home: that's not what a category is.
13:12:03 <lines> It has a formal definition. It's not just "some stuff which is similar".
13:12:07 <jle`> algun|home: oh, are you talking about "categories" like the english word category?
13:12:11 <algun|home> i'm sure it does
13:12:14 <algun|home> jle`: no
13:12:16 <jle`> and not category as in category theory/mathematical category?
13:12:21 <jle`> oh
13:12:32 <dminuoso> algun|home: If you dont even understand the formal definition, why do you feel competent enough to argue what is or is not a category?
13:12:35 <jle`> well then yeah, 'a set of similar things' is definitely completely unrelated to the mathematical idea of a category
13:12:51 <jle`> someone just happened to pick the same word for both things, so it's a bit unfortunate
13:13:06 <jle`> mathematical categories are completely unrelated to the english word 'category'
13:13:35 <algun|home> dminuoso: i'm not arguing for something not being a category. I'm arguing for things being functions or sets. That much I can handle.
13:14:17 <erisco> there are many theories to describe things. set theory is one theory (well actually there are many set theories).
13:14:30 <jle`> "category theory" is not the theory of categorizing things, heh, so it's a but unfortunately named
13:14:31 <lines> jle`: I mean you can see why it's a useful term
13:14:36 <lines> but like
13:14:42 <erisco> I don't know how to convince you that everything isn't just a set other than telling you that. It just isn't!
13:15:04 <erisco> but you can describe many things using sets… that is what theories are for
13:15:16 <algun|home> erisco: well you can provide me with a category that does not satisfy the definition of a set.
13:15:21 <algun|home> or can you? ;)
13:15:24 <dminuoso> algun|home: ANY.
13:15:25 <lines> algun|home: yes
13:15:29 <erisco> algun|home, I already gave you a paper to read
13:15:30 <algun|home> dminuoso: what?
13:15:33 <lines> algun|home: what's the definition of a set?
13:15:42 <lines> can you give an example of a category?
13:15:47 <erisco> and as everyone is saying, categories are not sets, that is just nonsense
13:16:02 <jle`> algun|home: no category is a set, there is not a single category that is a set
13:16:12 <algun|home> lines: what i said above for category
13:16:27 <algun|home> jle`: oh?
13:16:34 <jle`> yes, there are 0 categories that are sets
13:16:59 <jle`> just like how there are no integers that are cats
13:17:13 <jle`> (to be clear, i mean the animal)
13:17:24 <jle`> there isn't a single example of a mathemtical category that *is* a set
13:17:38 <jle`> so if you want an example of a category that isn't a set... try all of them :)
13:17:54 <algun|home> you all agree with what jle` is saying?
13:18:41 <erisco> I do
13:18:45 <dminuoso> algun|home: A fair share of people here is well versed in mathematics.
13:18:58 <jle`> you don't have to be well-versed in mathematics to know the definition of a mathematical category
13:19:06 <jle`> and to know that that definition.... cannot apply to any sets
13:19:26 <erisco> if you read any introductory text on sets, and then any introductory text on categories, I think you'll see quite readily how they are defined differently
13:19:30 <jle`> it's just illogical :o
13:19:31 <erisco> they are not the same theory
13:19:49 <erisco> that isn't to say you cannot have sets of categories or categories of sets… of course you can, but they are not themselves the same
13:20:12 <dminuoso> And frequently categories are formed around sets, but they can also be classes. And the set notion is not really important often.
13:20:14 <lambdamu> Yes they are different by definition, that being said though, for example every set is isomorphic to a category with no isomorphism other than the ids
13:20:16 <lines> and indeed you can have categories whose objects and arrows are sets
13:20:31 <dminuoso> lambdamu: Categories without morphisms are kind of boring to talk about.
13:20:39 <dminuoso> It's like the cake without the cake.
13:20:43 <lines> algun|home: more or less, yes
13:20:48 <lambdamu> dminuoso: I agree, but this whole discussion is somewhat pointless
13:21:53 <erisco> I don't know in what sense you would think they are the same… are both just bags of objects to you?
13:21:57 <lines> algun|home: essentially imagine you were like "look I've had a think and I reckon there's just no difference between mice and bears. Mice, bears - they both had the same definition, which is 'warm things'"
13:22:19 <ivans> warm and fuzzy
13:22:22 <jle`> i think it's more like "mice, bears, they both have the same definition: large mammals that eat people"
13:22:38 <ivans> mice, large
13:22:39 <jle`> at which point everyone stops to think "...what do they think a mouse is?"
13:22:46 <lines> jle`: I'm not even convinced they have their definition of sets right so...
13:23:24 <lambdamu> on the other hand what does it mean for two things to be the same? There are people that insist that everything that is sufficiently isomorphic is the _same_
13:23:35 <lambdamu> but even by that definition categories and sets are not the same
13:23:37 <erisco> damn topologists
13:23:39 <dminuoso> lambdamu: You are right up to isomorphism.
13:23:51 <dminuoso> >:)
13:24:02 * hexagoxel notes that one can get from "category theory" to "set" in the first sentences in wikipedia articles in very few steps.
13:24:11 <hexagoxel> "a labeled directed graph called a category"
13:24:19 <hexagoxel> directed graph -> graph
13:24:37 <hexagoxel> "a graph is a structure amounting to a set of objects"
13:24:46 <dminuoso> Not necessarily a set. It can also be a class.
13:24:49 <erisco> lambdamu, what it means to be the same is something which needs to be stated on a case by case basis… good reasons for different equalities
13:24:49 <lines> hexagoxel: yes, but that's just not the - yes
13:24:54 <dminuoso> And the set notion is really uninteresting.
13:24:55 <hexagoxel> then edit wikipedia pls :D
13:25:05 <dminuoso> hexagoxel: Its a pointless excercise.
13:25:24 <lines> dminuoso: although I will admit that I've never quite got a handle on what a class is other than mumble mumble let's not worry
13:25:39 <lines> but I've never really done much proper set theory
13:25:42 <erisco> the equality I am using here is based on the idea that theories are generative
13:25:44 <hexagoxel> fine. but still this might explain how the notion that category=set comes to be.
13:25:59 <dminuoso> lines: Well in naive set theory you could construct a set of all sets that dont contain themselves right?
13:26:03 <erisco> so, no two theories are the same, but you can find mappings between them, and possibly isomorphisms, sure
13:26:08 <dminuoso> lines: So the idea that anything definable is a set is not healthy.
13:26:41 <lines> dminuoso: right, indeed
13:26:56 <lambdamu> erisco: I agree, but you can get philosophical about it, personally I don't feel there is much to be gained by that either
13:26:57 <lines> I'm basically happy with the idea that classes are *waves hands* definable things
13:29:23 <erisco> well, univalence is a profound concept, and I look forward to learning what is different in that context
13:29:59 <dminuoso> lines: A class is basically a set but you're not allowed to call it set. That way you can suddenly get out of this bad situation and create a "class of sets with some arbitrary property"
13:30:15 <algun|home> Set (theory) is to function as category 
13:30:15 <algun|home>                     (theory) is to morphismm
13:30:19 <algun|home> algun|home> jle`: Disagree. Set (theory) is to function as category 
13:30:19 <algun|home>                     (theory) is to morphismm
13:30:30 <algun|home> darnit
13:30:33 <algun|home> my bad
13:30:51 <lambdamu> set theory : function / category theory : functor
13:31:17 <erisco> if you're convinced at all about the ties between CS and reality, then different equalities should have some profound meaning to you
13:31:44 <dminuoso> algun|home: Bartosz Milewski has recorded a series of lectures introducing category theory to programmers. It was quite adequate (he even has a book with the same content to follow) when I watched it.
13:31:58 <dminuoso> algun|home: I suggest you do some studying to learn about those concepts. And please dont use wikipedia for math,.
13:32:14 <algun|home> dminuoso: i come to you with these questions having read the first few pages of his series
13:32:40 <dminuoso> Guess its not as good as I remembered it.
13:32:50 <algun|home> i guess he dodges non-function morphisms quite skilfully
13:32:52 <jle`> algun|home: so do you see how no category is a set?
13:33:04 <dminuoso> algun|home: No, he quite explicitly talks about morphisms not being functions.
13:33:11 <erisco> algun|home, read "Category Theory For Computing Science" by Michael Barr & Charles Wells
13:33:24 <algun|home> dminuoso: he mentions that. but then refuses to explain this
13:33:31 <erisco> algun|home, there are example galore
13:33:31 <dminuoso> algun|home: No he does not. He talked about preorders.
13:33:34 <dminuoso> algun|home: he talks about functors.
13:33:40 <dminuoso> algun|home: he talks about natural transformations.
13:33:44 <dminuoso> algun|home: He talks about hom functors.
13:33:53 <dminuoso> He talks about so many category things that dont involve functions as morphisms.
13:34:09 <nshepperd> is there a "type hiercharchy" kind of clear definition of classes, collections and so forth?
13:34:40 <algun|home> nshepperd: i guess we need a word to encompass all those terms: kind, class, collection ... ;)
13:34:51 <erisco> nshepperd, provide more context
13:34:56 <dminuoso> algun|home: I believe the reason he talks so much about the category Hask, is because it's a bit easier for intuition purposes.
13:35:09 <nshepperd> like, construct the 'classes' based on the class of all sets, then you've got classes^2 which contains the class^2 of all classes and so forth
13:35:36 <erisco> ah… not sure, but some type theories have an infinite tower of universes sort of in the way you describe
13:35:43 <algun|home> dminuoso: can you link me to where the difference is evident? Here's the index: https://bartoszmilewski.com/2014/10/28/category-theory-for-programmers-the-preface/
13:36:28 <dminuoso> algun|home: Have you watched his lectures?
13:36:42 <nshepperd> I think i'm talking about intuitionistic type theory
13:36:44 <algun|home> erisco: everhigher kinds of turtles
13:36:52 <jle`> algun|home: it looks like https://bartoszmilewski.com/2014/12/05/categories-great-and-small/ (the third post) he lists a bunch of categories whose morphisms are not functions
13:36:56 <nshepperd> collections all the way up
13:37:04 <erisco> algun|home, are you actually arguing for your position?
13:37:10 <lambdamu> I think classes are just logician speak for what is second step in stratified universe of types / sets
13:37:11 <lines> at some point one has to feel like you're taking the piss
13:37:12 <python476> anybody familiar with adjoint functors ?
13:37:22 <algun|home> dminuoso: i watched a vid or two actually now that you ask and i look at his face
13:37:32 <python476> I remember talks by .. was it gershom bazerman ?
13:37:33 <dminuoso> algun|home: In the lectures he talks about categories that dont involve functions as morphisms for at least 2 entire hours.
13:37:44 <python476> the idea seemed amazing, I like the round trip idea
13:37:53 <dminuoso> 22:32           erisco | algun|home, read "Category Theory For Computing Science" by Michael Barr & Charles Wells
13:37:55 <dminuoso> This is an amazing read.
13:37:57 <lambdamu> It is a technical device to avoid self referencing pardoxes when quantifyting
13:38:47 <infinisil> Is there something like `collect :: IO a -> [a]` that repeats the action until it fails?
13:38:55 <erisco> algun|home, you have everyone in channel disagreeing with you and offering you resources to figure out where you went wrong
13:38:59 <algun|home> dminuoso: everyone's got their favorite. maybe because what works for some don't work for others?
13:39:11 <lyxia> infinisil: many
13:39:20 <nshepperd> algun|home: if you draw an actual category on paper, with actual dots and arrows, that's a category that doesn't have functions
13:39:22 <erisco> algun|home, now it is your job to go and study those resources, or revisit them if you have already seen them
13:39:46 <dminuoso> ski: By the way, are you around?
13:39:46 <lines> nshepperd: we-ll only if you have all the middle arrows, technicall.
13:39:50 <algun|home> erisco: is it?
13:39:55 <algun|home> nshepperd: umm
13:40:12 <erisco> algun|home, yes. And I recommend letting go of the quest to figure out what a category isn't and instead pay attention to what a category is
13:40:17 <infinisil> lyxia: Such as?
13:40:23 <algun|home> let me see jle`'s
13:40:29 <lyxia> :t many
13:40:31 <lambdabot> Alternative f => f a -> f [a]
13:40:34 <infinisil> ohh lol
13:40:42 <infinisil> thanks
13:41:04 <infinisil> I understood you saying there were many such functions
13:41:08 <nshepperd> lines: yeah well you've gotta draw it right!
13:41:09 <lyxia> haha
13:41:21 <algun|home> erisco: that was never my quest although this has already been imputed unto me (was it by you?)
13:41:30 <lines> https://www.amazon.co.uk/Conceptual-Mathematics-First-Introduction-Categories/dp/052171916X
13:41:57 <lines> this is a decent-enough book for someone who isn't interested in learning category theory but is interested in learning about categories, if you see what I mean
13:42:08 <erisco> algun|home, that is exactly what you're doing by asking "is a category not a set"?
13:42:39 <nshepperd> but in this case the morphisms obviously can't be functions
13:42:45 <nshepperd> because functions are abstract
13:42:53 <nshepperd> whereas these morphisms are made of ink
13:43:42 <nshepperd> you can even eat them
13:43:45 <ivans> as a casual haskeller, are there any recommended books on category theory that would make it possible to understand discussions like this?
13:44:06 <dminuoso> ivans: erisco | algun|home, read "Category Theory For Computing Science" by Michael Barr & Charles Wells
13:44:13 <erisco> algun|home, it is probably not anything that of what you are thinking right now, so I recommend instead to study the introductory materials to CT more, learn what a category is, and don't be too hasty to equivocate it with other things
13:44:53 <dminuoso> ivans: Also I personally enjoyed the video lectures from Bastosz Milewski much.
13:44:58 <lines> ivans: depends on your maths background
13:45:11 <lambdamu> a category is obviously just an object in a 2-category
13:45:14 <lines> the book I linked is reasonably good :)
13:45:29 <dminuoso> lines: How deep is it?
13:45:44 <dminuoso> lines: Is it enough to crack Yoneda by the end?
13:45:55 <algun|home> erisco: darnit man
13:46:29 <lines> dminuoso: no
13:46:35 <ivans> dminuoso: thanks, I'll check that out!
13:46:57 <lines> dminuoso: it's "accessible" - as I say, it's a book about categories not a book of category theory
13:47:05 <ivans> lines: I studied mathematics a couple of decades ago, but I'm out of touch with recent developments
13:47:17 <lambdamu> Personally I think Awodey's book on category theory is a nice introduction
13:47:41 <lines> ivans: give that book a look
13:48:25 <erisco> algun|home, it is tough stuff. It is normal to have to read it over and over again, then walk away for a while, then start again
13:48:34 <lambdamu> Also not to slow, if you wait to long to get to convincing applications categories become tedious
13:49:09 <jle`> infinisil: what do you mean by 'fails'?
13:49:10 * hackage cron 0.6.1 - Cron datatypes and Attoparsec parser  https://hackage.haskell.org/package/cron-0.6.1 (MichaelXavier)
13:49:17 <lines> ivans: also, you might like Algebra 0 (https://www.amazon.co.uk/Algebra-Chapter-Graduate-Studies-Mathematics/dp/0821847813) - I like it because I like algebra
13:49:19 <erisco> algun|home, sophisticated theories such as this have been developed for a long time. There is a trove of knowledge to absorb and you can't expect it to be quick or easy
13:49:40 <infinisil> jle`: Oh, actually I'm thinking of `fail` of MonadFail
13:49:48 <lines> but it's quite nice for givig you examples of categories in terms of things you've probably met before. I enjoy it.
13:50:12 <erisco> and you can't expect it to always fit within frameworks familiar to you
13:50:22 <jle`> infinisil: oh er, are you aware that nobody uses that for IO?
13:50:34 <jle`> unless you have some pattern match failure in a do block binding maybe
13:50:49 <infinisil> jle`: I am calling fail myself :) Or should i use something else?
13:51:32 <jle`> what are you calling 'fail' for? :o
13:51:42 <algun|home> erisco: "apples and oranges" is just not a satisfying answer to "what's the difference between sets and categories". There's a very real relationship, it just might be hard to explain: "Category theory[1] formalizes mathematical structure and its concepts in terms of a labeled directed graph", and "a structure on a set is an additional mathematical object that, in some manner, attaches (or relates) to 
13:51:48 <algun|home> that set to endow it with some additional meaning or significance."
13:52:09 <infinisil> jle`: A handle that gets closed, synchronously reading it
13:52:14 <lines> algun|home: they aren't unrelated
13:52:19 <lines> but neither are they the same thing
13:52:52 <lines> algun|home: are you familiar with a mathematical group?
13:53:01 <algun|home> lines: i admit i was very confused, thinking a set was an instance of category. But I reiterate that I didn't try to equate them.
13:53:13 <jle`> maybe a better example would be 'apples and democracy'
13:53:14 * hackage xml-conduit-parse 0.3.1.2 - Streaming XML parser based on conduits.  https://hackage.haskell.org/package/xml-conduit-parse-0.3.1.2 (koral)
13:53:26 <jle`> since it's clear that they aren't enve the same "type" of thing you can compare
13:53:28 <lines> algun|home: sure - you did say that they were both "a collection of similar things"
13:53:31 <erisco> jle`, want to start a political podcast with me?
13:54:12 <jle`> infinisil: would it make sense for it to be an IO (Maybe a) ?
13:54:21 <lambdamu> lines: That doesn't imply that they are the same though
13:54:30 <infinisil> jle`: Yes that would make sense, but it seems more tedious to deal with IO and Maybe at the same time
13:54:36 <lines> lambdamu: true
13:54:43 <jle`> infinisil: why tedious?
13:54:54 <lines> I'm not really invested in who exactly said what when and what they meant and the price of fish in Borogravia.
13:54:58 <erisco> algun|home, the answer that will be satisfying to you, I predict, is one which will come from a deeper understanding of categories, which will require you to study them more
13:55:13 <infinisil> jle`: How would I create an `f :: IO (Maybe a) -> [a]` ?
13:55:27 <jle`> IO (Maybe a) -> IO [a], you mean?
13:55:42 <infinisil> Ohh right
13:56:25 <algun|home> erisco: the prob is i don't know what benefit there would be other than avoiding blunder in #haskell
13:56:49 <jle`> i can't guaruntee that there will be any benefits, but you could look at it as a "for fun" thing
13:56:50 <lambdamu> algun|home: What could be more important?
13:56:55 <erisco> … you can't be going on this much without actually caring about categories. What is the point?
13:57:34 <erisco> if you don't care about categories then just suffice with "people say categories and sets are not really the same thing. I don't know why, but that is the way it is, and I'm moving on"
13:57:38 <nshepperd> oh well, categories are like sets in that they contain a bunch of objects
13:57:49 <jle`> >____>
13:57:59 <nshepperd> in the same way groups are like sets in that they contain stuff
13:58:47 <jle`> infinisil: you can use 'many' with the MaybeT newtype wrapper
13:58:50 <nshepperd> but the exciting part of a group is the binary operation, not the objects
13:58:53 <erisco> it is also okay to say "I don't know" or "I don't understand" and then move on… not everything can be known in a lifetime
13:58:54 <jle`> which gives the 'alternative' instance that you want
13:59:15 <jle`> s/'alternative'/Alternative
13:59:19 <nshepperd> and the exciting part of category is the morphisms
13:59:21 <erisco> but if it is nagging you then bite the bullet and study it
13:59:54 <infinisil> jle`: Oh that looks nice
14:00:14 <dminuoso> nshepperd: Well the objects are still interesting. Think about natural transformations :P
14:02:05 <infinisil> jle`: Oh and then I can use `many`?
14:02:09 <erisco> algun|home, the Barr & Wells paper I am actually reading right now. CT has been nagging *me* and so I am studying it, and I have been bamboozled several times by it
14:03:10 <algun|home> that's not the paper, that's the 500+ pg book
14:03:22 <algun|home> the other thing you mentioned (compiling to...) is a paper
14:03:28 <erisco> well, I have a PDF of it… brain says paper :P
14:03:41 * hackage BiobaseTypes 0.1.3.0 - Collection of types for bioinformatics  https://hackage.haskell.org/package/BiobaseTypes-0.1.3.0 (ChristianHoener)
14:03:48 <erisco> a dissertation can be a couple hundred pages… a novella or a paper? I dunno
14:03:50 <Gurkenglas_> infinisil, note that this will be strict, waiting until a Nothing is returned before giving back the whole list at once
14:04:14 <infinisil> Ohh.. well I need it lazy though
14:04:14 <algun|home> i think i'll give a Milewski a read-over before I try to lift (pun) anything heavy
14:04:28 <erisco> algun|home, you can PM me and we can read the book together if you want
14:05:06 <Gurkenglas_> :t Control.Monad.Loops.unfoldM -- infinisil (not sure whether this is lazy)
14:05:08 <lambdabot> Monad m => m (Maybe a) -> m [a]
14:05:15 <infinisil> Gurkenglas_: jle`: I could just use a recursive function though
14:05:30 <algun|home> erisco: reminds me when you try running with someone and one of you has already been running and the other one can't keep up
14:06:08 <erisco> algun|home, that's why I am wearing my backpack… so you can hop in when you get tired… ;)
14:07:07 <dminuoso> algun|home: Dont use the book.
14:07:22 <dminuoso> algun|home: If you want his works, use his lectures. They are decent.
14:07:34 <algun|home> erisco: questions would flow in one direction
14:07:52 <erisco> why is that? I don't know everything
14:07:57 <algun|home> dminuoso: what Milewski? I meant the blog series
14:08:15 <dminuoso> algun|home: He has recorded a series of actual lectures on youtube.
14:09:50 <algun|home> i know, and as much as I used to like MOOCs, I used to do them when the time time ratio is smaller in vid
14:10:10 * hackage BiobaseXNA 0.10.0.0 - Efficient RNA/DNA/Protein Primary/Secondary Structure  https://hackage.haskell.org/package/BiobaseXNA-0.10.0.0 (ChristianHoener)
14:10:12 <algun|home> *when the time/info ratio being high didn't bother me
14:10:37 <dminuoso> algun|home: If you dont spend the time to carefully study this, it's a rather pointless excercise.
14:11:20 <algun|home> dminuoso: what is usually the point though? XD
14:11:44 <dminuoso> Accumulating knowledge is its own purpose for me.
14:12:21 <erisco> CT has inspired several interesting Haskell libraries
14:12:40 <erisco> it has demonstrated itself as a useful base of knowledge from which to write better programs
14:14:09 <algun|home> erisco: i lack motivation so better not. i appreciate the offer however
14:14:18 <algun|home> thanks for the chat. til next time
14:14:28 <erisco> see ya
14:16:45 * hackage ADPfusionForest 0.0.0.1 - Dynamic programming on tree and forest structures  https://hackage.haskell.org/package/ADPfusionForest-0.0.0.1 (ChristianHoener)
14:25:04 <Maticz> Hey guys, I want to make a function that finds a path inside a maze from point a to point be. I want this function to return false if it can't find a path or a list of coordinates if it found a path. What kind of type should I use or implement to be either a bool or a list of coordinates?
14:25:46 <erisco> Maticz, Maybe [Point]
14:26:01 <mniip> it's not "either a bool or a list of coordinates"
14:26:10 <mniip> there's no "true"
14:26:13 <erisco> Maticz, Nothing if no path is found, otherwise Just the list of coordinates
14:26:14 * hackage finite-typelits 0.1.3.0 - A type inhabited by finitely many values, indexed by type-level naturals.  https://hackage.haskell.org/package/finite-typelits-0.1.3.0 (mniip)
14:26:42 <Maticz> erisco: I tried that but my recursion relies on bools
14:26:51 <mniip> how so
14:27:00 <mniip> (you can always convert a Maybe into a Bool later)
14:27:11 <Maticz> Il'l make a link to a snippet, sec
14:27:13 <erisco> well now you're adding more detail to the question. State a complete question and we can help
14:28:27 <mniip> hmm
14:28:43 <Maticz> https://pastebin.com/yjZ58Uta
14:28:44 <mniip> has anyone yet made a TypeLits elimination schemes package
14:29:19 <illiquid_> i love haskell this way http://bit.ly/2zhARal
14:29:37 <Maticz> So the problem is that this function can find a path, but now I want it to return a path if it found one
14:29:40 * hackage ViennaRNA-extras 0.0.0.1 - ViennaRNA v2 extensions  https://hackage.haskell.org/package/ViennaRNA-extras-0.0.0.1 (ChristianHoener)
14:29:47 <erisco> Maticz, that function determines if a path exists
14:30:30 <Maticz> erisco: Yes, now I want it to return the "p" parameter when it found the path
14:30:36 <erisco> you're going to want more sophistication than this, because it is going to produce infinite paths
14:30:44 <erisco> for example, up down up down up down up down…
14:30:58 <mniip> erisco, elem s p
14:31:08 <Maticz> erisco: oh but it checks previous visited paths
14:31:27 <erisco> good
14:31:28 <Maticz> previous visited coordinates sorry
14:32:12 <erisco> replace True with  Just p  and False with  Nothing
14:32:21 <erisco> replace the type Bool with  Maybe [Coordinate]
14:32:37 <erisco> then I'll let you figure out what to do with ||
14:33:12 <infinisil> Oh god, IO everywhere in my program
14:33:25 <mniip> I think not knowing what to do with || was the cornerstone of their question
14:34:25 <erisco> I'll wait for a more specific question to be asked on that then
14:34:32 <Maticz> erisco: I already did that but the thing is that I don't know what to do with ||
14:34:43 <erisco> mind reader mniip
14:35:12 <Maticz> haha
14:36:26 <erisco> Maticz, what are your possible results from  path f (s:p) (up s) d  ?
14:37:34 <Maticz> erisco: False or [Coordinate] I guess
14:37:55 <erisco> with the changes I suggested, using Maybe [Coordinate] now
14:38:49 <Maticz> erisco: compiler is yelling at me about ||
14:39:07 <erisco> yes of course because  Maybe [Coordinate]  is not  Bool
14:40:11 <Maticz> erisco: yes I'm looking for the correct operation to replace it with (||)
14:40:20 <erisco> have you used Maybe or other sum types before?
14:41:10 <Maticz> erisco: I've used Maybe a few weeks ago when we saw it in a lecture, I'm not sure what you mean by sum types, Ill look it up quickly
14:41:18 <erisco> there is such an operator but do you want to learn why?
14:41:35 <Maticz> erisco: ofcourse
14:42:52 <erisco> sum types have multiple constructors
14:43:53 <erisco> do you remember the two constructors for Maybe?
14:43:56 <Maticz> erisco: You mean like: dataShape = Circle Int Int | Rect Int Int
14:44:05 <erisco> yes, like that
14:45:06 <Maticz> erisco: Maybe a = Just a | Nothing?
14:45:17 <erisco> yes
14:46:19 <erisco> so in the otherwise case, you recurse on path four times. What possible results can you get from that?
14:47:08 <Maticz> Just Path or Nothing?
14:47:34 <erisco> for each one, yes, and so in total it can be any combination of that
14:47:41 <Maticz> yes
14:48:01 <erisco> so now you have to ask yourself what you want to do for each of those combinations
14:48:09 <erisco> if they are all Nothing, presumably you want to return Nothing
14:48:16 * hackage Forestry 0.0.0.1 - Comparison of trees and forests.  https://hackage.haskell.org/package/Forestry-0.0.0.1 (ChristianHoener)
14:48:19 <Maticz> yes
14:48:27 <erisco> if exactly one is  Just p  then you want to return  Just p
14:48:37 <erisco> what about if more than one is Just?
14:49:04 <Maticz> I'm not sure, but I guess I cons them?
14:49:58 <erisco> well, ask yourself what this function should do. There may be zero or more (non-self-intersecting) paths between two points.
14:50:59 <erisco> right now it determines whether at least one path exists. Do you want a function to return any one path, if it exists? Return all of them? Return the shortest?
14:51:11 <erisco> maybe the longest? the one with the most right-hand turns?
14:51:13 <Maticz> the shortest
14:52:08 <erisco> ah ha
14:52:27 <erisco> lets visit the other options quickly so you can see those
14:52:54 <erisco> if you want to return any path, then <|> is your operator. why?
14:53:05 <erisco> > Nothing <|> x
14:53:07 <lambdabot>  error:
14:53:07 <lambdabot>      • Couldn't match expected type ‘Maybe a’ with actual type ‘Expr’
14:53:07 <lambdabot>      • In the second argument of ‘(<|>)’, namely ‘x’
14:53:21 <erisco> hm, not sure how powerful Expr is… try again here
14:53:37 <erisco> Nothing <|> x = x  and  x <|> Nothing = x
14:53:43 <erisco> Just a <|> Just b = Just a
14:54:08 <erisco> do those three equations make sense to you? do you see why if we replace || with <|> that it would return exactly one path, if it exists?
14:55:31 <Maticz> Yea I understand
14:56:22 <erisco> now what if we want to return all paths? then <> is your operator, provided another change
14:56:36 <erisco> if we return multiple paths then we need to return a type of  Maybe [Path]
14:57:01 <erisco> so the  s == d  case becomes  Just [p]  instead and so on
14:57:13 <erisco> why?  Nothing <> x = x  and  x <> Nothing = x
14:57:18 <erisco> should look familiar to <|>
14:57:25 <erisco> Just a <> Just b = Just (a <> b)
14:57:40 <Maticz> I can't seem to find the <> operator for Maybe types
14:57:41 <erisco> note that <> is another name for mappend. Have you heard of that before?
14:57:54 <erisco> import Data.Monoid ((<>))
14:58:28 <Maticz> wow ok thats cool]
14:58:51 <erisco> Monoid is a pervasive type class, definitely worth knowing, and it is simple too
14:59:05 <Maticz> yea we saw it in lecture yesterday
14:59:07 <erisco> Monoid consists of mempty and mappend, and there are two laws
14:59:19 <erisco> okay great. Then you know what mappend is for lists?
14:59:20 <Maticz> but I didn't know anything of these yet
14:59:44 <Maticz> No we are not at that point yet
14:59:48 <Maticz> gonna check to be certain
14:59:57 <erisco> have to let the dog out brb
15:01:58 <Maticz> Oh ok sorry we saw "Monads" yesterday, was confused there for a second. We also did see Monoids a few weeks ago but very brief
15:02:41 <mniip> monads are really just monoids
15:02:50 <Maticz> A monoid is something that can be folded togehter
15:03:23 <erisco> ah ha, well we can talk about Monads here for this problem too
15:03:30 <mniip> I'm sorry that's not a definition
15:03:51 <erisco> that is something you can do with Monoids as evidenced by fold
15:03:53 <erisco> :t fold
15:03:54 <lambdabot> (Monoid m, Foldable t) => t m -> m
15:04:03 <erisco> but it isn't exactly what a Monoid is
15:04:54 <erisco> a Monoid is mempty and mappend, where  mempty `mappend` x = x  and  x `mappend` mempty = x  and  a `mappend` (b `mappend` c) = (a `mappend` b) `mappend` c
15:05:25 <erisco> or, in English, a Monoid is an associative binary operator which has a zero
15:05:43 <Maticz> ok
15:05:55 <erisco> also called an identity
15:06:20 <erisco> [] and ++ form a Monoid. Tell me why.
15:08:10 <Maticz> [] ++ [x] = [x], [x] ++ [] = [x]
15:08:35 <erisco> [] ++ x = x  and  x ++ [] = x
15:08:41 <erisco> remember that  [x]  is a list of one element
15:08:54 <Maticz> oh ok
15:08:59 <erisco> [] ++ xs = xs  and  xs ++ [] = xs   if that helps
15:09:07 <mniip> erisco, in fairness, that's not a proof :p
15:09:12 <erisco> what about associativity?
15:09:25 <erisco> no, we have to dig into the definition of ++, but I'll take "by intuition" for this ;)
15:10:05 <Maticz> x ++ (y ++ z) = (x ++ y) ++ z ?
15:10:18 <erisco> right, and does that make sense for lists? is that true?
15:10:22 <wzy8L-B2[m]> Also (xs ++ ys) ++ zs == xs ++ (ys ++ zs)
15:10:36 <Maticz> yea 
15:10:47 <Maticz> brb bio
15:11:17 <erisco> good, and we can prove all these if you want to but I want to wrap up your function without getting too distracted
15:12:14 <erisco> so now that we have an idea of the list Monoid, what about the Maybe Monoid. This is where Haskell gets fun
15:12:50 <erisco> so,  Maybe a  is a Monoid if  a  is a Monoid
15:13:08 <mniip> Semigroup
15:14:05 <erisco> did they weaken the constraint?
15:14:51 <erisco> doesn't look it http://hackage.haskell.org/package/base-4.10.0.0/docs/Prelude.html#t:Maybe but yes, Semigroup would suffice
15:15:34 <erisco> that is probably because it would break everything… Monoid doesn't extend Semigroup
15:16:42 <erisco> anyways, see if you can figure out the definitions of mempty and mappend for  Maybe a  given  a  is a Monoid
15:16:53 <Maticz> back
15:17:09 <erisco> that'll tell you how it manages to collect all the paths
15:17:49 <Maticz> ok
15:18:05 <erisco> then we'll tighten up the type, but this is a good excuse to visit the Maybe Monoid
15:21:00 <erisco> and I wonder if mniip can rewrite this using Comonads later :P
15:21:31 <Maticz> Ok cool found info on it in my book on Haskell
15:21:33 <mniip> rewrite what
15:21:51 <erisco> the path search. not entirely sure if it is applicable… was asking you
15:24:50 <aplainze2akind> Is there a library to play midi using soundfonts in real time?
15:24:57 <Maticz> erisco thanks alot for your help, you cleared out alot for me :)
15:25:18 <erisco> no problem
15:25:38 <erisco> once you have a list of all paths, you can then find the shortest of those paths as a separate problem
15:26:24 <Maticz> yea I'm doing that now 
15:26:25 <erisco> there is lots of nuance to path searching though, i.e. different algorithms and heuristics which can provide better or worse performance
15:26:33 <mniip> erisco, I could rewrite it in free monad transformers
15:26:54 <erisco> but it doesn't hurt to begin with the most obvious solution… correct before fast
15:27:54 <erisco> you also possibly have mazes in which there is exactly one path between any two points
15:28:22 <erisco> anyways, for  Maybe [Path]  there is some tightening up we can do
15:28:33 <erisco> Nothing stands for no path, but what does Just [] stand for then?
15:28:50 * hackage opml-conduit 0.6.0.4 - Streaming parser/renderer for the OPML 2.0 format.  https://hackage.haskell.org/package/opml-conduit-0.6.0.4 (koral)
15:28:57 <erisco> it seems there is an extra value in our type that we don't need, so we can subtract one value
15:29:18 <erisco> Maybe adds one value to a type, so we can just take Maybe away to subtract one
15:29:27 <erisco> therefore use [Path] where [] stands for no paths
15:30:17 <mniip> erisco, hmm I think I see where you're going
15:30:25 <mniip> were you thinking of using the Store comonad?
15:30:45 <glguy> Wouldn't [] be the Path for when you started where you wanted to end?
15:30:52 <erisco> I am not sure, it just seemed vaguely similar to examples I have seen particularly with spreadsheets
15:31:03 <glguy> Oh, I see, it's a list of paths
15:31:05 <glguy> nevermind :)
15:34:13 <Brocoli> Hello!
15:34:40 <erisco> or maybe use the perverse  Maybe (NonEmpty a)
15:35:36 <erisco> that is an example where Semigroup vs Monoid is going to matter
15:36:55 <erisco> Brocoli, good evening Lt Barclay
15:37:11 <Brocoli> I'm trying to reimplement the list drop function for a new type I just implied, but it's a bit difficult,
15:37:30 <Brocoli> data Nat = Zero | Succ Nat
15:37:44 <Brocoli> natDrop :: Nat -> [a] -> [a]
15:37:55 <Brocoli> natDrop n@(Succ x) l@(v:xs) = case (n, l) of (Zero, _) -> xs
15:38:03 <Brocoli> (_, _) -> natDrop x xs
15:38:26 <erisco> hm, that seems painfully redundant
15:38:30 <glguy> Brocoli: n@(Succ x) will only mach when n is Succ x
15:38:40 <glguy> Brocoli: so no sense in matching it again against Zero
15:38:52 <erisco> natDrop (Succ n) (x:xs)  already pattern matches to give you  n, x, and xs
15:39:04 <Brocoli> https://pastebin.com/TdkzkHG7
15:39:34 <erisco> so there are a few different opportunities to do pattern matching
15:39:54 <erisco> nonexhaustively, one is with function clauses, and another is with case/of
15:40:08 <erisco> most commonly you will use function clauses
15:40:18 <Brocoli> erisco: glguy please can you help me to fix this? Thanks!
15:40:30 <erisco> for example, here are two clauses to calculate the length of a list:   length [] = 0; length (_:xs) = 1 + length xs
15:40:44 <mniip> Brocoli, not if you don't put any effort into listening what they're saying
15:40:49 <erisco> the clauses are  length [] = …  and  length (_:xs) = …
15:41:07 <erisco> we could rewrite this to use case/of instead
15:41:21 <erisco> length xxs = case xxs of [] -> 0; (_:xs) -> length xs
15:41:40 <erisco> but there is no need to do the pattern matching with both clauses *and* case/of
15:42:20 <erisco> Haskell is a syntactically rich language which gives you different ways to write functionally the same thing
15:42:47 <erisco> those two length examples are exactly the same thing, one is just written with a different notation
15:44:50 <erisco> there are also pattern guards, lambda case, and pattern matching with bindings, and I might have missed some
15:45:27 <erisco> list comprehensions also, I think, though I don't use those at all, so don't trust my memory
15:45:55 <erisco> > [x | Just x <- [Nothing, Just 99]]
15:45:57 <lambdabot>  [99]
15:46:02 <erisco> sure thing
15:46:23 <lines> gods what does the @ do
15:46:30 <lines> can't recall
15:46:37 <glguy> It's an "as pattern"
15:46:38 <erisco> once you pattern match, like  (x:xs)  what if you want to refer to the whole?
15:46:45 <glguy> some_name @ some_pattern
15:46:55 <erisco> xxs@(x:xs)  says xxs refers to the whole of  x:xs
15:46:58 <Brocoli> erisco: you are right but i don't see the connection with my current problem
15:47:02 <fr33domlover> l@(x:xs)
15:47:28 <erisco> Brocoli, you are using both clauses and case/of. Pick one.
15:47:33 <lines> erisco: ah good
15:47:41 <Brocoli> erisco: how?
15:48:01 <erisco> either do pattern matching to the left of = only, or only do pattern matching to the right of = with case/of
15:49:25 <lines> hmm, I think I've solved that problem. I'm relatively new to the language - I'd be interested in feedback myself on how to make what I've written more idiomatic
15:49:43 <lines> but I don't want to take the learning experience from Brocoli so I'll keep sctum for now
15:49:46 <erisco> there are situations where you would use both, but not for the same patterns
15:50:34 <erisco> scutum?
15:50:55 <erisco> skookum?
15:51:23 <lines> schtum
15:51:30 <lines> quiet :P
15:52:03 <Brocoli> erisco: i did not understand anything, i'm a also new to the language
15:52:07 <erisco> lines, #haskell-beginners is a second channel you can ask questions on
15:52:54 <nshepperd_> Brocoli: you can have multiple function clauses. "natDrop (Succ n) (x:xs) = ..." is one
15:53:13 <erisco> Brocoli, how did you come around to defining Peano naturals?
15:53:41 <nshepperd_> Then on the next line you can put "natDrop Zero xs = ..." and that's another
15:54:09 <nshepperd_> (you need to fill in each ... with an answer)
15:54:46 <Brocoli> erisco: I do not know, I read wikipedia and I defined it
15:55:50 <erisco> Brocoli, that is an interesting vector into Haskell. I recommend reading this chapter http://learnyouahaskell.com/syntax-in-functions#pattern-matching
15:56:41 <Brocoli> nshepperd_: are you meant to use Lamdacase?
15:57:42 <nshepperd_> Brocoli: no need. The (Succ n) stuff has already pattern matched everything you need out of the input
15:58:15 <nshepperd_> I recommend reading the site erisco linked
15:58:45 <nshepperd_> That chapter in particular, but also the whole site in general. It's a fun tutorial
16:05:10 <erisco> I don't know… I'd prefer a less infantilising presentation… for those of us who want to think of ourselves as hardcore
16:06:25 <erisco> welcome to Haskell… here's the BNF grammar, here's the typing rules, here's the reductions, have fun
16:07:08 <nshepperd>  heh
16:07:36 <nshepperd> typing rules and reductions never would have made sense to me before i learned haskell
16:07:54 <geekosaur> here's a typechecker implemented in prolog, here's a general charaterization of the syntax as meta-bnf, derive the language from thee
16:07:56 <geekosaur> ]*these
16:08:15 <Brocoli> erisco: nshepperd I am so grateful, I forgot the applicative function definition in haskell
16:08:36 <erisco> Applicative is a type class, not a function
16:09:25 <nshepperd> it's also an adjective
16:09:46 <erisco> oh… coincidence?
16:10:14 <Brocoli> nshepperd: erisco https://pastebin.com/gF8q0JuD
16:10:30 <Brocoli> what do you think?
16:11:18 <erisco> the if/then/else and length predicate is unnecessary
16:12:49 <Brocoli> erisco: I need it otherwise, I have an error, when I ask to remove from the list more element than there is
16:12:56 <nshepperd> Brocoli: better!
16:13:02 <erisco> you should read through an introductory text so you can learn the basics of the language
16:13:05 <Brocoli> nshepperd: but?
16:13:10 <nshepperd> but you can remove the if/then/else if you add a third case
16:13:24 <nshepperd> what should the function do if the number is (Succ n) but the list is []?
16:13:35 <erisco> it is difficult to have a discussion otherwise
16:13:46 <Brocoli> nshepperd: return []
16:15:36 <Brocoli> erisco: i have, i have learned the basics but i forget quickly
16:15:57 <erisco> well, they weren't written with fading ink ;)
16:17:30 <nshepperd> Brocoli: so update your function with that case 'natdrop (Succ n) [] = []' and you should see that you no longer get an error when you ask to remove more elements than there is
16:18:10 <Brocoli> nshepperd: ah sure
16:19:01 <lines> how does this look: https://pastebin.com/p7rzhfYn
16:19:21 <lines> I'm vaguely interested in if there's a better way to do the negative in the last one - I guess this is where one might use Maybe?
16:19:27 <erisco> drop (S n) (_:xs) = drop n xs; drop _ xxs = xxs
16:22:09 <erisco> how did you end up with the same code as Brocoli, lines?
16:22:41 <Brocoli> lines: https://pastebin.com/7sEtKCaL
16:22:48 <Axman6> because someone's been cheating
16:22:58 <lines> erisco: well, I saw what Brocoli was trying to do and then did it
16:23:27 <erisco> uh huh… well I absolve myself from any collusion :P
16:23:48 <lines> ?
16:23:56 <questo> given I have something like this b1 :: Occupancy; b1 (X 1) = True; b1(X 2) = False; how can I write a func changeOne :: Occupancy -> Xtype -> Occupancy to only negate the b1 (Xtype here)? currently I can only do it for all of them
16:24:13 <Brocoli> Axman6: What do you talking about? ;)
16:24:17 <lines> I just looked at what Brocoli had put in channel.
16:24:22 <erisco> lines, what do you picture as the map from Int to Nat? it seems you are saying that 0 and less maps to Z?
16:25:02 <lines> erisco: yeah, I didn't much like that
16:25:17 <nshepperd> lines: yeah. Integer -> Maybe Nat would be the normal way to do that. because -1 isn't a natural number
16:25:30 <Axman6> it's pretty common to catch students cheating in this channel, so it's not an unreasonable conclusion ;) I've caught them from the course I used to tutor before, and many people know the lecturers of the various Haskell courses around the wrold, so it's a pretty dumb idea but happens nonetheless
16:25:32 <erisco> lines, maybe instead you'd like to write a bijection between Integer and Nat
16:25:51 <lines> Axman6: I'm 25 and not a student :P
16:26:31 <nshepperd> of course negative numbers -> 0 is also a valid mapping
16:26:39 <nshepperd> this is math! you can do whatever you want
16:26:56 <lines> indeed, I'm just not sure what the best property would be
16:27:13 <lines> as I say, I wrote a Integer -> Maybe Nat version first of all.
16:27:40 <erisco> if we take a sort of 2's complement approach then negative Ints would map to large numbers in Nat
16:27:53 <lines> eurgh
16:27:54 <Axman6> just make odd Nats negative
16:28:02 <nshepperd> lol
16:28:05 <lines> double eurgh
16:28:28 <erisco> well that is the practical way to write a bijection between Integer and Nat, lines, what Axman6 suggested
16:28:36 <lines> sure
16:28:36 <nshepperd> or you could... throw an exception
16:28:40 <Axman6> it's a perfectly cromulant mapping nbetween the Naturals and the Integers
16:28:40 * nshepperd hides
16:28:41 <lines> I do know that.
16:30:00 <lines> I have a relatively strong pure maths background.
16:31:11 <nshepperd> > drop (-1) [1, 2, 3]
16:31:14 <lambdabot>  [1,2,3]
16:31:22 <nshepperd> fair enough
16:31:42 <lines> right, you see, it's not an entirely silly choice :P
16:31:51 <mniip> lines, strong but is it costrong?
16:32:03 <lines> mniip: only if I reverse the arrows
16:32:09 <erisco> anyways, no, you cannot pattern match on  1 + n  in Haskell, unfortunately, so  n - 1  is reasonable
16:33:02 <mniip> uhh
16:33:16 <erisco> what? is there an extension for that?
16:33:29 <lines> didn't you used to be able to?
16:33:47 <nshepperd> there is an extension for that
16:34:06 <erisco> there's an extension for that like there's an app for that
16:34:13 <mniip> hmm I was pretty sure tensorial costrength was a thing
16:34:49 <nshepperd> or there was?
16:35:05 <nshepperd> but it's deprecated now and was never really a good idea iirc
16:35:12 <lines> hmm - could you define the Integers by (Nat,Nat), with (==) defined so that (a,b)==(c,d) means a + d == b + c?
16:36:05 <lines> (So that (Zero, Succ Zero) == (Succ Zero, Succ(Succ Zero)) = True, etc.)
16:36:06 <mniip> ah right
16:36:12 <mniip> there was Cotensorial strength
16:36:25 <nshepperd> yeah, in fact that's the exact construction of the integers that I was taught in our real analysis course
16:36:34 <nshepperd> set theory construction
16:36:42 <mniip> t (a ~> b) -> a ~> t b
16:36:42 <lines> nshepperd: indeed, but I was wondering if Haskell would play nice if I attempted to do it
16:36:57 <lines> (and then the rationals in the analogous way)
16:37:11 <mniip> lines, kinda
16:37:49 <mniip> there's a problem with nontrivial identifications
16:37:49 <dmwit> lines: Yes, you can do it cleanly in Haskell.
16:38:08 <lines> dmwit: hee, pleasing
16:38:38 <lines> anyway, bedtime. Thanks.
16:38:40 <nshepperd> oh, probably. quotient types aren't really a "thing" but as long as you can define all the operations like (==) and >= and so on in the right way you're good
16:38:45 <mniip> yeah
16:39:48 <nshepperd> though the meaning of (fix Succ, fix Succ) in that construction might be a bit mysterious
16:39:54 <erisco> ski can tell you have that, lines
16:39:56 <mniip> there's no way to prove that a certain function respects the divisor relation
16:40:15 <erisco> meh, this is Haskell, we don't prove anything
16:40:34 <mniip> so you can't really prove that a certain function (Nat, Nat) -> X, is really a function from Integer
16:41:53 <dmwit> mniip: You can make your type abstract and only export observations that respect the relation.
16:41:58 <mniip> righ
16:42:11 <dmwit> (aside: "divisor relation"?)
16:42:31 <mniip> I just needed to name the relation :S
16:42:43 <mniip> the relation we divided Nat * Nat by to get our quotient Integer type
17:15:03 <fragamus> howdy and happy TG
17:15:36 <koz_> fragamus: TG?
17:16:03 <fragamus> It means Thanksgiving
17:16:14 <koz_> fragamus: Ah, OK.
17:16:49 <fragamus> Does anyone know of a primer on Language.Haskell.Exts.Syntax
17:47:14 * hackage Cabal 2.0.1.0 - A framework for packaging Haskell software  https://hackage.haskell.org/package/Cabal-2.0.1.0 (MikhailGlushenkov)
18:09:39 <koz_> Does anyone have the problem that hdevtools hangs and does nothing when executed with Stack?
18:11:53 <vaibhavsagar> koz_: I find that I have to do `stack exec --no-ghc-package-path -- hdevtools` for it to be initialised correctly
18:12:17 <vaibhavsagar> otherwise I have to do the `killall hdevtools; rm .hdevtools.sock` dance and try again
18:12:50 <vaibhavsagar> has anyone seen this issue before? https://github.com/gibiansky/IHaskell/issues/787
18:13:04 <koz_> vaibhavsagar: I get no .hdevtools.sock upon execution of any hdevtools command via Stack.
18:13:15 <koz_> (including the one you just gave me)
18:13:29 <vaibhavsagar> can you `killall hdevtools` and try again?
18:13:49 <koz_> There's no process by that name, and I tried that too - same result.
18:14:09 <vaibhavsagar> it sounds like your hdevtools installation is borked
18:14:21 <vaibhavsagar> reinstall and try again?
18:14:21 <koz_> vaibhavsagar: How do I fix it then? I installed it with 'stack install'.
18:14:32 <koz_> Do I just delete the hdevtools binary stack made and then rebuild?
18:14:46 <vaibhavsagar> no, that shouldn't be necessart
18:14:53 <koz_> What should I do then?
18:15:15 <vaibhavsagar> what happens if you run `hdevtools check <project>/app/Main.hs`?
18:15:23 <koz_> Without stack exec?
18:15:37 <koz_> Hang.
18:15:56 <koz_> (and no .hdevtools.sock)
18:16:09 <vaibhavsagar> that is unusual
18:16:26 <koz_> vaibhavsagar: You reckon it's worth trying to remove the binary then reinstalling?
18:16:32 <vaibhavsagar> yes, try deleting and rebuilding
18:16:34 <koz_> (I don't know what else to try)
18:16:36 <koz_> OK.
18:16:41 <koz_> As an aside: does Stack do parallel builds?
18:16:59 <vaibhavsagar> it can, if you configure it appropriately
18:17:18 <koz_> At build time, or is it a flag I have to give it?
18:17:53 <vaibhavsagar> try `stack --ghc-options=-j`
18:18:10 <koz_> OK, will do next time I wanna build something big.
18:18:25 <vaibhavsagar> source: https://tech-blog.capital-match.com/posts/3-anatomy-of-haskell-web-app.html#physical-organization
18:18:29 <koz_> Also, does hdevtools not build under Stack nightlies?
18:18:37 <vaibhavsagar> hmm, it might not
18:18:49 <vaibhavsagar> is that what you are trying with?
18:18:54 <koz_> It seems like it doesn't, or at least not under the nightly I'm trying to use.
18:18:57 <koz_> Yeah.
18:19:10 <koz_> So basically, I have to use LTS if I want hdevtools?
18:19:12 <vaibhavsagar> ah, that is relevant to the problem you are experiencing, I wish you had mentioned it
18:19:22 <koz_> Sorry - I'm still getting used to Stack.
18:19:26 <koz_> But yeah, I'm using a nightly.
18:19:35 <vaibhavsagar> no worries, I understand
18:19:59 <vaibhavsagar> so hdevtools needs to match the version of GHC you are using
18:20:36 <inkbottle> [noob]: Minimal stack project with a "build-depends in your .cabal file" error, http://paste.debian.net/997319/ (only 12 lines of code)
18:20:37 <vaibhavsagar> by which I mean it needs to be compiled against the same version of GHC that you expect to use
18:21:28 <vaibhavsagar> so if you `stack install hdevtools` without specifying a nightly resolver, it will probably break when you try to use it with a project with a nightly resolver
18:21:39 <koz_> Ah, OK.
18:21:53 <vaibhavsagar> the solution is to use (I think) `stack install --resolver nightly hdevtools`
18:21:59 <vaibhavsagar> and then try
18:22:02 <koz_> vaibhavsagar: OK, will try that.
18:22:19 <vaibhavsagar> but the downside here is that you cannot use that hdevtools with any non-nightly projects
18:22:29 <koz_> I figured as much.
18:22:41 <koz_> Still breaks, exact same build error.
18:22:48 <koz_> I can copy-paste it if that'd help diagnosis.
18:23:08 <vaibhavsagar> yes, put it in a paste please
18:23:25 <vaibhavsagar> I think we like http://lpaste.net/ here
18:23:30 <MarcelineVQ> the solution is to  stack install hdevtools  in the project you'll be using it with
18:23:40 <MarcelineVQ> well, that's a solution, dunno about 'the' :X
18:23:54 <vaibhavsagar> that sounds right to me
18:23:56 <MarcelineVQ> But that will build it in the same context as you're using it
18:23:59 <koz_> MarcelineVQ: That doesn't help the 'will not build' problem.
18:24:04 <koz_> vaibhavsagar: http://lpaste.net/360230
18:24:29 <vaibhavsagar> aha, this looks like a change in the GHC API
18:24:40 <vaibhavsagar> which is preventing hdevtools from building
18:25:09 <koz_> vaibhavsagar: So does that mean I'm SOL on this one?
18:25:23 <vaibhavsagar> yes, I don't think you can use hdevtools right now
18:25:33 <vaibhavsagar> can I suggest ghcid?
18:25:33 <koz_> vaibhavsagar: Nor ghc-mod, for very similar reasons.
18:25:49 <koz_> I haven't heard of it, and Neomake doesn't integrate with it I don't think.
18:26:12 <koz_> (I use Neomake for syntax checking on Neovim)
18:26:20 <vaibhavsagar> ghcid has a neovim plugin
18:26:29 <koz_> Oh, really? OK, that's cool then.
18:26:37 <MarcelineVQ> You can try to install a specific hdevtoosl from hackage if the one you're trying isn't working. What's the ghc-mod issue?
18:26:53 <vaibhavsagar> koz_: https://github.com/ndmitchell/ghcid/tree/master/plugins/nvim
18:27:46 <koz_> MarcelineVQ: http://lpaste.net/360231
18:28:25 <vaibhavsagar> it doesn't look like ghc-mod has been updated with GHC 8.2 support yet: https://github.com/DanielG/ghc-mod/blob/master/ChangeLog
18:29:31 <koz_> vaibhavsagar: I'll try ghcid.
18:29:39 <koz_> Thank you for the suggestion!
18:30:00 <vaibhavsagar> My pleasure :)
18:31:06 <inkbottle> So, I've got this cabal dependencies problem: http://lpaste.net/360232
18:31:57 <lyxia> inkbottle: what's the error message?
18:31:59 <MarcelineVQ> what is the error it fails with, that's the most important bit hehe, and what does your cabal file look like
18:32:21 <inkbottle> lyxia: http://paste.debian.net/997319/
18:32:52 <inkbottle> lyxia: I put the output
18:33:10 <inkbottle> and the cabal file
18:33:35 <inkbottle> it's not haskell code so I put it on debian.paste
18:34:45 <inkbottle> MarcelineVQ: the three files and the outputs http://paste.debian.net/997319/
18:35:13 <lyxia> inkbottle: put your executable in a separate directory
18:35:15 <vaibhavsagar> inkbottle: add containers to your executable build-depends
18:35:24 <koz_> vaibhavsagar: In case you know - what do I need to do to make Neomake run :Ghcid on each save?
18:35:39 <koz_> (I think there's a line I have to add to my config, but I'm unsure what)
18:35:43 <vaibhavsagar> I think you only need to run it once?
18:35:56 <vaibhavsagar> and then Ghcid will continue running
18:35:56 <koz_> vaibhavsagar: Oh, so it's ongoing?
18:35:57 <inkbottle> lyxia: vaibhavsagar: ok, I try that
18:36:03 <koz_> Let me try that real quick.
18:36:20 <lyxia> inkbottle: When they are in the same directory, ghc recompiles TestContainers as an extra module part of the executable rather than reusing the TestContainers from the library it already compiled.
18:36:24 <koz_> Ah, very nice! Thanks!
18:36:39 <koz_> So in that case, how do I tell it to auto-run it every time I open a Haskell sauce file?
18:37:57 <vaibhavsagar> koz_: this probably involves an autocmd
18:38:18 <koz_> vaibhavsagar: OK, I'll investigate. But thank you so much for all your help!
18:38:44 <vaibhavsagar> anytime
18:40:42 <vaibhavsagar> koz_: something like 'autocmd FileType haskell :Ghcid'? http://learnvimscriptthehardway.stevelosh.com/chapters/12.html#filetype-events
18:41:22 <vaibhavsagar> you'll want to set up an augroup so that your autocmds don't run multiple times
18:43:16 <vaibhavsagar> question: what is the best practice WRT .cabal files and `source-repository head`? I'm looking at this issue and I don't understand what I need to change https://github.com/gibiansky/IHaskell/issues/787
18:45:34 <MarcelineVQ> is source-repository used for anything other than documentation?
18:45:41 <inkbottle> lyxia: still digging; how do I specify that "any" version is suitable for dependencies in cabal file?
18:45:47 <inkbottle> TestContainers must match -any, but the stack configuration has no specified version
18:45:48 <inkbottle> needed since testContainers-0.1.0.0 is a build target
18:46:19 <MarcelineVQ> your executable needs to depend on your library
18:46:57 <MarcelineVQ> so it would look like   build-depends:       base >= 4.7 && < 5, testContainers
18:47:58 <inkbottle> MarcelineVQ: yes, I've added TestContainers in the executable dependencies, but it complains about the version number of that TestContainers library
18:48:17 <inkbottle> MarcelineVQ: capitalization,
18:48:20 <inkbottle> I try that
18:48:20 <MarcelineVQ> case sensitive   testContainers  is the name of your library
18:50:33 <koz_> Whoo, found an issue with the Neovim plugin...
18:50:44 <koz_> It's just the usual for me - everything I try breaks somehow when doing something basic.
18:51:41 <MarcelineVQ> koz_: you're the PJ of haskell utility programs
18:51:59 <koz_> MarcelineVQ: Not just Haskell utility programs. I literally find bugs by just existing.
18:52:19 <MarcelineVQ> is vim your preferred editor?
18:52:32 <koz_> MarcelineVQ: Neovim, but yes.
18:52:42 <inkbottle> lyxia: vaibhavsagar: MarcelineVQ: TX, fixed: I added testContainers in the executable dependencies + moved src/Main.hs to exe/Main.hs; with relevant modification to the cabal file
18:52:44 <koz_> If you're going to suggest I switch to Emacs with evil-mode, the answer is 'no'.
18:53:04 <MarcelineVQ> ghci has adequate editor hooks, and has had them long enough that I'm not sure why ghc-mod hdevtools still exist, so I wonder if there's a vim plugin for just asking ghci what it thinks
18:53:18 <MarcelineVQ> I wasn't going to suggest you switch your editor no
18:53:30 <vaibhavsagar> MarcelineVQ: ghcid is very close to this
18:53:38 <koz_> MarcelineVQ: I dunno. I use Neomake for syntax checking, and it supports hlint, ghc-mod and hdevtools.
18:53:43 <vaibhavsagar> it's a thin wrapper around ghci
18:53:45 <koz_> So that's basically what I use(d).
18:53:47 <MarcelineVQ> vaibhavsagar: that is true, though it's still a step away
18:54:12 <koz_> Unfortunately, I quickly discovered that both hdevtools and ghc-mod are broken on Stack nightlies, and have been for a while.
18:54:20 <MarcelineVQ> the advantage to a plugin that just asks ghc is that if your ghc works your ghci works your question works
18:54:23 <koz_> (well, at least the last few nightlies I've tried using)
18:54:42 <vaibhavsagar> MarcelineVQ: does this exist for emacs?
18:54:49 <MarcelineVQ> yes, it's called dante iirc
18:54:51 <koz_> vaibhavsagar: Emacs uses Flycheck.
18:55:05 <koz_> (or rather, most Emacs users use Flycheck)
18:55:17 <MarcelineVQ> https://github.com/jyp/dante
18:55:23 <vaibhavsagar> isn't dante also a haskell project that implements its own thing?
18:55:29 <vaibhavsagar> I have heard of dante/intero
18:55:35 <MarcelineVQ> no, it's a script that asks ghci what it thinks
18:55:40 <koz_> I've also heard of intero.
18:55:48 <koz_> Maybe I can try that next and find more broken things? :P
18:56:03 <MarcelineVQ> at least, that's what it was last I checked, feel free to have a look I think it's just one file
18:56:09 <vaibhavsagar> ahh, fascinating, I didn't realise it was pure elisp
18:57:42 <MarcelineVQ> vaibhavsagar: there's also https://github.com/ambiata/mafia-mode as support if stack gets in your way
18:59:39 <vaibhavsagar> I unfortunately use Vim, so I'll stick with ghcid in a separate terminal window for now
19:00:30 <vaibhavsagar> fortunately (or unfortunately) I'm not writing much haskell these days so it's not a huge loss
19:00:33 <MarcelineVQ> I've no idea how to search for a vim counterpart to dante, implementing it should be pretty straightforward I would think, if you have a vim that can talk to oingoing processes especially which I understand it couldn't for a long time. dunnooo
19:00:50 <vaibhavsagar> it can now, but vimscript is a gigantic pain in the butt
19:01:35 <vaibhavsagar> it would only be possible with a lot of sweat and tears
19:02:03 <MarcelineVQ> I dunno if that's neccesary, everything else does it this way when possible, ongoin process, so I expect ghci's 'ide mode' to be similar
19:02:50 <koz_> Yep, found breakage with intero-neovim too.
19:02:54 <koz_> I'm on a roll today!
19:02:56 <vaibhavsagar> hahaha
19:03:25 <MarcelineVQ> is this with nightly still?
19:04:33 <vaibhavsagar> koz_: it looks like hdevtools master has GHC 8.2 support: https://github.com/hdevtools/hdevtools
19:04:56 <koz_> vaibhavsagar: So I need to clone that and stack install it?
19:05:03 <vaibhavsagar> yes, try that
19:05:12 <koz_> MarcelineVQ: That's not a Haskell issue, it's a Neovim issue.
19:05:23 <koz_> More specifically, intero-neovim clashes badly with vim-localvimrc.
19:05:29 <koz_> Which is... probably not what you want.
19:06:45 <vaibhavsagar> koz_: if you `stack install` from your clone of hdevtools, make sure to update the resolver to a recent nightly first
19:07:06 <koz_> vaibhavsagar: OK.
19:08:43 <inkbottle> lyxia: Even though it was obviously required, I can't find the information about that library and executable must be in different directories anywhere on the internet
19:08:54 <koz_> vaibhavsagar: Zomg it worked! Thank you!
19:09:10 <koz_> (I've now sent away two bugreports to other projects, so yay I guess?)
19:09:10 <vaibhavsagar> \o/
19:09:51 <koz_> Haskell community is best community.
19:11:36 <koz_> (if someone has a picture of SPJ in a field a la http://i0.kym-cdn.com/photos/images/original/000/065/469/north-korea-is-best-korea.jpg, that'd be really awesome)
19:13:44 * hackage html-tokenizer 0.5.1 - An "attoparsec"-based HTML tokenizer  https://hackage.haskell.org/package/html-tokenizer-0.5.1 (NikitaVolkov)
19:15:44 <lyxia> inkbottle: yes it is fairly non-obvious I also struggle to find a good resource
19:16:16 <inkbottle> lyxia: do you remember of any?
19:18:12 <inkbottle> lyxia: it must be a case of what is called internal dependencies in a cabal file, but I have read nothing about that directories have to be different
19:19:17 <inkbottle> And I'm sure I read tutos where lib and exec where in the same directory
19:20:01 <lyxia> inkbottle: https://stackoverflow.com/questions/6711151/how-to-avoid-recompiling-in-this-cabal-file/6711739
19:20:19 <lyxia> inkbottle: a lot of people are not aware of that unfortunately
19:20:33 <inkbottle> lyxia: tx
19:55:07 <lyxia> inkbottle: I opened an issue to ask about it https://github.com/haskell/cabal/issues/4906
20:08:40 * hackage html-tokenizer 0.5.2 - An "attoparsec"-based HTML tokenizer  https://hackage.haskell.org/package/html-tokenizer-0.5.2 (NikitaVolkov)
20:11:57 <inkbottle> lyxia: That's definitely great
20:12:44 <inkbottle> lyxia: plus the previous post was about 'not having to recompile everything everytime' (or so I understood)
20:14:17 <inkbottle> lyxia: in the present case, if I move exe/Main.hs to src/Main.hs, where the TestContainers.hs file already is: then it doesn't compile at all
20:15:24 <Axman6> @hoogle (v -> k) -> v -> Map k v -> Map k v
20:15:25 <lambdabot> Data.Map foldWithKey :: (k -> a -> b -> b) -> b -> Map k a -> b
20:15:25 <lambdabot> Data.Map.Internal foldrWithKey :: (k -> a -> b -> b) -> b -> Map k a -> b
20:15:25 <lambdabot> Data.Map.Internal foldrWithKey' :: (k -> a -> b -> b) -> b -> Map k a -> b
20:15:55 <inkbottle> lyxia: and actually, I haven't found any solution to compile with files in the same directory, that with a single compilation, or many
20:16:04 <dmwit> Axman6: What do you want that function to do?
20:17:07 <dmwit> I mean, I have a guess: re-key all the elements. But the extra `v` argument keeps throwing me off, and it seems like you'd want some control over which `v` "won", so to speak, when there's a clash.
20:17:34 <Axman6> I want insertOn
20:18:02 <dmwit> like...
20:18:15 <dmwit> :t \f v -> M.insert (f v) v
20:18:17 <lambdabot> Ord k => (a -> k) -> a -> M.Map k a -> M.Map k a
20:18:18 <Axman6> or insertBy perhaps is a better name. insertBy ident v  = insert (indent v) v
20:18:20 <dmwit> ?
20:18:23 <Axman6> yes
20:18:38 <dmwit> Huh. Don't know of any shorter way than that.
20:19:00 <Axman6> the number of times where I've wanted to make a map of values by a given key they contain has made me want this function a lot
20:19:11 <dmwit> :t (M.insert <*>)
20:19:12 <lambdabot> Ord k => (k -> a) -> k -> M.Map k a -> M.Map k a
20:19:16 <Axman6> fromListBy as well
20:19:32 <Axman6> that seems backwards
20:19:35 <dmwit> it does
20:19:40 <dmwit> I'm not very good at mental ?pl
20:19:43 <Axman6> need to extract the key from the value
20:19:46 <Axman6> heh, me either
20:20:00 <dmwit> ?pl foo v = M.insert (f v) v
20:20:00 <lambdabot> foo = M.insert =<< f
20:20:37 <dmwit> Axman6: I have used a `fromListWith` pattern that sounds like what you're describing quite a lot, too.
20:23:21 <Axman6> I can's count how many times I've written something like M.fromList . map (f *** id) 
20:23:25 <Axman6> :t (***)
20:23:26 <lambdabot> Arrow a => a b c -> a b' c' -> a (b, b') (c, c')
20:23:37 <Axman6> uh, (&&&) then
20:24:43 <dmwit> What, not fromListWith (++) . map (f &&& return)? =)
20:25:31 <Axman6> generally the key is a unique id
20:25:32 <dmwit> e.g. `f = sort` to clump together anagrams
20:26:24 <dmwit> Here's me proposing code like that for some other problem five years ago: https://stackoverflow.com/a/12398993/791604
20:26:38 <dmwit> And I'm pretty sure I had worked that trick out quite some time before that, too.
20:26:50 <dmwit> It's a really nice one, and I agree it seems to come up surprisingly often.
20:27:29 <dmwit> Sometimes you want a different monoid than []/(++), of course. ;-)
20:27:37 <Axman6> yeah
20:27:44 <dmwit> well
20:27:47 <dmwit> different semigroup
20:27:53 <Axman6> I'm reading http://www.timphilipwilliams.com/posts/2017-04-12-nested-datacubes.html which has reminded me of this problem
20:35:56 <lyxia> inkbottle: With your original setup you could just add containers to the executable's build-depends
20:36:40 * hackage html-tokenizer 0.6 - An "attoparsec"-based HTML tokenizer  https://hackage.haskell.org/package/html-tokenizer-0.6 (NikitaVolkov)
20:37:10 <wagle> is https://github.com/haskell/haskell-mode the emacs mode I'm looking for?
20:37:11 <lyxia> inkbottle: the executable wouldn't see the library, so all the information in the library section needs to be copied over
20:46:21 <koz_> How would I go about building myself a lambdabot using Stack?
20:51:13 <Axman6> stack unpack lambdabot; cd lambdabot*; stack init; <fix dependencies>; stack build
20:51:32 <koz_> Axman6: I didn't know about stack unpack. I guess it's like a clone?
20:52:04 <Axman6> it just unzips the tarball from hackage
20:52:11 <koz_> Oh, neat. Thanks!
20:52:24 <Axman6> you could find its repo and clone it too
21:19:44 * hackage apecs 0.2.4.6 - A fast ECS for game engine programming  https://hackage.haskell.org/package/apecs-0.2.4.6 (jonascarpay)
21:22:34 <MarcelineVQ> koz_: you'll need  stack init --solver  for thing you unpack, lamdabot's dep search crashes my stack though so gl :X
21:41:07 <inkbottle> lyxia: I can't say I understand every bit of it, but the modification you suggested did work, putting back the executable in src/, but adding containers to the dependencies of the executable
21:41:40 <inkbottle> it emitted weird messages but it did compile
21:42:46 <inkbottle> the container in the dependency line, is only a indirect dependency; but ok
21:44:57 <inkbottle> lyxia: maybe I'll understand better when I'll be able to look at the compile command "emitted" buy stack build.
22:23:42 <vektorweg1> whats the advised solution for cases, where i would need two ReaderT, like dragging more than one value along? tupling them up works, but this seems rather tedious. 
22:24:51 <jle`> vektorweg1: you can tuple and use zoomers
22:24:52 <geekosaur> use a record and asks
22:25:36 <jle`> zooming is the design pattern of using natural transformations like `Reader r1 a -> Reader (r1, r2) a`
22:26:33 <jle`> so if you ever need to only use r1, you can use a Reader r1 a.  and then you can use that inside a Reader (r1, r2) a by zooming it
22:27:09 <jle`> sorry not zoom, "magnify"
22:27:15 <jle`> zoom is slightly different
22:27:30 <jle`> also i'm probably the only person to call it a design pattern
22:27:41 <jle`> but it's going to happen
22:28:20 <vektorweg1> jle`: hm. i still haven`t dealt with lenses. 
22:28:27 <jle`> i didn't say anything about lenses
22:28:38 <jle`> i'm talking about manually writing a Reader r1 a -> Reader (r1, r2) a
22:28:40 <vektorweg1> isnt magnify/zoom something that comes with lens?
22:28:42 <jle`> a 'magnifier'
22:29:07 <jle`> vektorweg1: yes lens has some tools that makes it easy to write
22:29:21 <jle`> but that's like saying, "doesn't lens have functions that work with integers?"
22:29:29 <jle`> and then saying that "using integers?  i haven't dealt with lenses yet"
22:29:49 <jle`> lens is just a library but the pattern of using integers/magnifiers/zoomers is universal
22:30:11 <jle`> just because you use lists, for instance (something that the lens library uses) doesn't mean that you need to learn lenses to use lists, heh
22:30:57 <jle`> you can write a `Reader r1 m a -> ReaderT (r1, r2) m a` without even knowing about lenses or the lens library...I never mentioned it >___>
22:31:25 <vektorweg1> but helpful zoom/magnify functions don't seem to come with the standard libs. 
22:31:47 <jle`> yes i'm saying you can write them yourselves
22:32:00 <jle`> zoomFirst :: ReaderT r1 m a -> ReaderT (r1, r2) m a
22:32:05 <jle`> it's a useful function to have
22:32:21 <jle`> and a useful design pattern to use when having a bunch of things in your environment that you can use independently
22:32:44 <vektorweg1> there should be a package for it, if its so useful. i dont like the idea of copying code. ;)
22:33:11 <jle`> lens lets you make them easily
22:33:20 <jle`> but...common combinators like this are basically the unix philosophy
22:33:26 <jle`> it's very haskelly to write combinators yourself
22:33:30 <jle`> it's like a one-liner
22:33:42 <jle`> it's a haskell principle that like, if a combinator is simple, a library shouldn't have to export it
22:34:00 <jle`> that's why there is no "sumSquared" function
22:34:04 <jle`> in any popular library
22:34:15 <vektorweg1> product, lol
22:34:15 <jle`> you could just do `sum . map (**2)`
22:34:28 <jle`> so why bother with defining a new function just to sum squared items?
22:35:00 <jle`> if you named every useful combinator there'd be too many names to keep track of -- if they're super simple, the user should probably just write it themselves
22:35:17 <jle`> and being able to write composable utility functions is one of the advantages of Haskell, as well
22:35:29 <jle`> in other languages, writing utility functions is dangerous because you don't know how they all interact with each other
22:35:45 <jle`> especially with IO, side effects, exceptions, dynamic types, etc.
22:36:06 <jle`> it's pretty common in Haskell to just write one-off utility functions if you use them in a module or two :)
22:36:18 <jle`> since they're safe and abstractions are powerful in Haskell
22:36:29 <vektorweg1> but it seems more like a function to be used a lot. 
22:36:52 <koz_> Is there a way to write [(x, y) | x <- [0 .. (V.length v - 1)], y <- [0 .. (V.length v - 1)]] in a less verbose way?
22:36:55 <jle`> i'm not quite sure what you mean
22:37:01 <jle`> or what you're trying to say?
22:37:13 <jle`> because it's a function you are using a lot, you'd rather not define it as a utility function at all?
22:37:24 <jle`> isn't a function that you use a lot a function that is *more useful* to have as a utility function?
22:38:08 <jle`> koz_: liftA2 (,) or (,) <$> ??? <*> ??? maybe?
22:38:18 <koz_> jle`: Yeah, that'd do it.
22:38:20 <vektorweg1> no, if its used a lot, some package should have it, so that there is one reliable version and not a hundred hidden in personal prelude files. 
22:38:46 <erisco> koz_, let l = V.length v in liftA2 (,) [0..l] [0..l]
22:39:08 <jle`> vektorweg1: have you heard of the whole 'left-pad' debacle that happened about a year and a half ago? :)
22:39:18 <vektorweg1> no
22:39:44 <vektorweg1> yes, but i didnt know the name
22:39:45 <erisco> hrm I think the let/in is longer than duping
22:39:48 <jle`> ah, it was something that brought almost the entire node ecosystem down
22:40:04 <erisco> in which case join is going to be good…
22:40:28 <erisco> join (liftA2 (,)) [0..V.length v - 1]
22:40:30 <jle`> it's because there was a simple function that everyone really could have written on their own, but instead there was a library whose entire job was to just export left-pad
22:41:04 <jle`> it's just a silly example of over-reliance on silly libraries
22:41:11 <koz_> erisco: Thanks, that's actually exactly what I was after for.
22:41:15 <koz_> s/after for/after/
22:41:27 <koz_> OK, my grammar is failing and I keep mis-typing 'adjacent' in my code.
22:41:42 <jle`> vektorweg1: but in any case if it really bothers you to write a utility function, you can use lens to automatically write your magnifiers
22:41:43 <vektorweg1> that is of course yet another extreme case. a useful function should find its place in related packages. like mtl or some extension version of mtl.
22:41:59 <jle`> vektorweg1: yes, but there's a line somewhere to draw
22:42:24 <jle`> and to many, a Reader r1 a -> Reader (r1, r2) a falls in the camp of "useful to everyone" yet "too much to include in mtl"
22:42:41 <jle`> just like a `((a,b),c) -> a` function
22:42:47 <jle`> of course, 'fst . fst' is useful to everyone
22:42:50 <jle`> and everyone has probably used it before
22:42:59 <jle`> but a library that just offers 'fst . fst' ?
22:43:08 <erisco> I would argue it is a poor addition because it is particular to (,)
22:43:30 <erisco> if that goes in, then you can argue (,,) and every other product type
22:43:37 <koz_> jle`: New project: fst-fst on Hackage. :P
22:43:44 <jle`> erisco: yeah, that's my point too
22:43:52 <vektorweg1> that is absolutely not comparable ... 
22:43:54 <jle`> if you include the useful fst.fst, you'd have to include the other many combinations of tuples and everything
22:44:03 <koz_> (maybe it should be 'acme-fst-fst'?)
22:44:33 <jle`> a 'Reader r1 a -> Reader (r1, r2) a' is useful to many people, but if you have a library for *just* that, why stop at 2-tuples? combinations of everything?
22:44:49 <jle`> it's just easier for someone who needs it to just write it as a one-liner and use it in their code
22:45:17 <jle`> otherwise we'd be arguing for Data.Tuple in base to have 'fstfst = fst.fst'
22:45:35 <vektorweg1> everyone can guess when to use fst.fst . but i haven't thought about something like zoom because i never seen it. if it would have been in mtl, i never had needed to ask here about a solution. it would have been obvious.
22:45:55 <jle`> vektorweg1: in any case if you are really morally against writing utility functions for yourself, lens can create them for you
22:46:04 <jle`> magnify _1 :: Reader r1 a -> Reader (r1, r2) a
22:46:18 <koz_> Does lambdabot have a do-notation desugarer?
22:46:31 <koz_> (dieter?)
22:46:34 <liste> @undo do { a <- x; b <- y; return x }
22:46:34 <lambdabot> x >>= \ a -> y >>= \ b -> return x
22:46:34 <jle`> writing `magnify _1` by hand is probably a haskell one-liner that's useful to write from scratch, but the lens library has nice combinators for automatically generating magnifiers
22:46:34 <vektorweg1> lens is dependency hell ...
22:46:55 <jle`> magnify _2 :: ReaderT r2 m a -> ReaderT (r1, r2) m a
22:47:07 <jle`> vektorweg1: sure, but you don't need to include lens just to have magnifiers
22:47:11 <jle`> you ... can just write them by hand ...
22:47:38 <jle`> it's a useful pattern that you can just write by hand as a utility function
22:47:51 <erisco> you might find a function like  (t -> s) -> Reader s a -> Reader t a  in the library though
22:48:07 <erisco> actually maybe Reader is Profunctor
22:48:32 <jle`> it can't be
22:48:37 <vektorweg1> erisco: one could certainly use reader as state ;)
22:48:38 <jle`> but yeah, it's actually 'withReaderT'
22:49:03 <jle`> withReaderT :: (r1 -> r2) -> ReaderT r2 m a -> ReaderT r1 m a
22:49:14 <koz_> Does anyone else ever get into the situation where they write stuff in the State monad, and then realize fold would have worked just fine?
22:49:17 <jle`> withReaderT fst :: ReaderT r1 m a -> ReaderT (r1, r2) m a
22:49:20 <koz_> s/fold/foldr/
22:49:26 <jle`> withReaderT snd :: ReaderT r2 m a -> ReaderT (r1, r2) m a
22:49:31 <jle`> there are your magnifiers :)
22:49:55 <jle`> koz_: yes, the clue is that you end up with a result of type ()
22:50:12 <jle`> if you end up with StateT s (), then...that's a red flag that you might not have needed State
22:50:19 <erisco> jle`, why can't it be?
22:50:30 <jle`> erisco: hm?
22:50:52 <jle`> it's also similar for Writer w () -- if you have a Writer w (), it's a sign to check to make sure you really needed Writer at all
22:50:55 <vektorweg1> yes okay, i'll write it in my utils package. :|
22:50:57 <jle`> or just wanted monoid operations like mconcat
22:51:09 <jle`> vektorweg1: it's not worth having a package for :o
22:51:16 <jle`> it's `withReaderT fst` and `withReaderT snd`
22:51:18 <koz_> jle`: I'll remember that for the future.
22:51:26 <jle`> withReaderT already come with transformers/mtl
22:51:53 <jle`> kind of silly to have a package just magnifyFirst = withReaderT fst, magnifySecond = writhReaderT snd, etc. :)
22:51:55 <erisco> jle`, it doesn't work due to parameter order of ReaderT, but an independently defined Reader is Profunctor, or I am crazy
22:52:02 <jle`> erisco: oh you mean that
22:52:09 <jle`> yeah i mean as it is currently implemented
22:52:16 <jle`> because it's a type synonym
22:52:23 <vektorweg1> jle`: i will likely need it more often, so i got a personal package for that to temporarily offload it.
22:52:31 <jle`> but yeah Reader is a lower-case profunctor
22:52:51 <erisco> if only it was  ReaderT m s a  heh
22:52:52 <jle`> vektorweg1: honestly because it's so short, i might just use `withReaderT f` in-line whenever it comes up
22:52:59 <jle`> erisco: but then it can't be MonadTrans
22:53:18 <erisco> feels bad man
22:53:33 <jle`> but there is a OtherReaderT m s a
22:53:41 <jle`> * OtherReaderT m r a
22:53:46 <jle`> that is in a common library
22:53:55 <jle`> that you probably use all the time
22:53:59 <jle`> can you guess what it is? :)
22:54:24 <jle`> FlippedReaderT m r a
22:54:34 <jle`> it goes by another name
22:54:48 <erisco> I don't use many three parameter newtypes
22:55:06 <jle`> (and it also has a Profunctor instance)
22:55:13 <jle`> erisco: here's a hint -- the library is 'base'
22:55:29 <erisco> uh huh… probably the biggest library on Hackage
22:55:41 <jle`> (the profunctors library also offers an identical type)
22:55:59 <erisco> going to wager I have never heard of it
22:56:11 <jle`> but to be fair the one in base isn't used very often outside of teaching
22:56:30 <jle`> :t Kleisli
22:56:32 <lambdabot> (a -> m b) -> Kleisli m a b
22:56:49 <erisco> okay, heard of it, have never used it
22:57:24 <erisco> have any fun code that uses the Kleisli category?
22:57:33 <koz_> On second thought, I didn't even need foldr - sum would have done.
22:57:36 <jle`> well a lot of code uses the kleisli category
22:57:47 <erisco> none that I have written or seen
22:57:48 <koz_> (well, technically, 'map sum . traverse doMagicalThing')
22:57:48 <jle`> but the Kleisli newtype wrapper isn't too useful
22:58:06 <jle`> it's only useful when you have to work with Category-polymorphic or Arrow-polymorphic code
22:58:10 <erisco> well if it doesn't use the Kleisli type then it isn't what I am talking about
22:58:13 <jle`> which is literally never
22:58:48 <erisco> well no, that is not true
22:59:00 <erisco> I am very interested in category polymorphic code lately
22:59:32 <jle`> i guess i'm exaggerating, i have written some category polymorphic code in the past
22:59:49 <jle`> actually i built an ANN library around it i think maybe
23:00:16 <jle`> but any category polymorphic code is probably esoteric, to put generously
23:01:01 <jle`> but actually there is a good deal of useful Profunctor-polymorphic code out there
23:01:12 <jle`> and so in that sense Kleisli is very useful
23:01:13 <erisco> I am going to sound like a broken record, because I have cited this paper probably a dozen times now
23:01:22 <jle`> so maybe i am wrong
23:01:23 <erisco> but check out conal's Compiling to Categories paper
23:01:38 <jle`> yes actually i'm pretty wrong, Kleisli is useful when you have profunctor-polymorphic code, and there's a whole bunch of those
23:01:56 <jle`> especially all around profunctor optics
23:02:13 <jle`> erisco: oh i'll probably check that out, that sounds interesting :)
23:02:31 <erisco> in my opinion it is transformative to functional programming
23:03:07 <jle`> yeah i guess a lot of profunctor optics uses Kleisli, except they call it 'Star'
23:03:19 <jle`> poor Mr. Kleisli
23:03:26 <jle`> never gets any of the recognition he deserves
23:03:47 <jle`> good ol' Heinrich
23:03:48 <koz_> Who was he anyway?
23:04:05 <jle`> sorry I should say Dr. Kleisli
23:04:29 <jle`> hm, i guess, for the profunctor optics usage, they don't use Kleisli as a Category, so I guess it doesn't make sense to even call it Kleisli
23:04:38 <jle`> it just so happens that 'Star' is isomorphic to 'Kleisli'
23:04:45 <jle`> the newtype wrappers
23:04:54 <jle`> so i retract my sentiment
23:04:57 <koz_> Quite probably Professor Kleisli.
23:05:13 <koz_> jle`: So does that mean sentiments can be lifted? :P
23:05:20 <jle`> :P
23:06:58 <koz_> Sentiment transformers gogo.
23:11:06 <osa1> hmm I wish persistent-* packages had different git repos. it's hard to track changes this way.
23:11:42 <osa1> just switched from lts-7.14 to lts-9.14 and somehow database layer is not working. changelog doesn't show anything relevant so I have to look at commits.
23:14:39 <fragamus> hey I am importing an ADT and it derives show but I need it to also derive read.  I am thinking I have to make a typeclass which is a subclass of the ADT and then add my deriving read there. Is that the way to go or what?
23:15:46 <Cale> fragamus: That doesn't make sense -- type classes can only be subclasses of other type classes
23:15:48 <Cale> not data types
23:16:30 <cocreature> osa1: you can just look at the git log for a specific directory, no?
23:16:34 <Cale> fragamus: More likely solution, if the data constructors are in scope, is to add {-# LANGUAGE StandaloneDeriving #-}  and then write   deriving instance Read SomeType
23:16:48 <Cale> (it'll only work if you could have written the instance by hand)
23:17:01 <fragamus> ok I think thats the answer
23:17:03 <geekosaur> fragamus, I'd add the deriving read on the ADT def. if not and if you're not writing a library, you can use standalone deriving extension
23:17:24 <fragamus> thanks thanks I can try that
23:17:32 <geekosaur> if you are writing a library that uses that, well, instances are global and you can cause spooky action at a distance by creating orphan instances with standalone deriving
23:18:07 <osa1> cocreature: yep, just did that. wasn't aware that github UI has that feature
23:25:33 <Athas> How come is there is no Stackage LTS snapshot with GHC 8.2 yet?
23:25:41 <Athas> There are plenty of nightly snapshots.
23:29:29 <rightfold> Compatibility
23:29:47 <geekosaur> largely because of nasty bugs in 8.2.1, and 8.2.2 was only just released and stackage still needs to be tested against it
23:30:00 <koz_> I'm trying to write a shuffle for mutable arrays. My signature so far is: shuffle :: (MV.Unbox a, MonadRandom m, PrimMonad m) => MV.STVector s a -> m (). Am I on the right track?
23:30:12 <koz_> (well, unboxed mutable arrays, but details)
23:30:21 <geekosaur> there's at least two major memory corruption issues in 8.2.1 that prevent various stackage packages from working reliably
23:30:53 <koz_> Sorry, that should have been: shuffle :: (MV.Unbox a, MonadRandom m, PrimMonad m) => MV.STVector m a -> m ()
23:31:20 <cocreature> koz_: looks reasonable
23:31:53 <koz_> Stacking RandT and ST has generally given me conniptions in the past.
23:32:04 <koz_> I think I can do it right this time.
23:32:43 <cocreature> it looks like RandT has a PrimMonad instance so it should work
23:33:12 <koz_> cocreature: It was thanks to me complaining that it even got that instance in the first place. :P
23:33:23 <cocreature> heh
23:33:48 <koz_> I think I even sent the PR that made it happen, although Brent had to edit it a bit before merging.
23:34:10 <koz_> (which shows how far you can go by mechanically following type signatures and existing examples in Haskell)
23:34:18 <koz_> Haskell: making thinking optional since 1987.
23:36:36 <ij> I can't generalize this function from _3 to all lens-likes. http://sprunge.us/RIcB Roughly speaking, the function must convert [f a] to [f b], given a "a -> IO (Maybe b)", but I haven't added the catMaybes in just yet.
23:36:56 <ij> correction: [f a] to IO [f b]
23:38:54 <cocreature> that’s not what your first function does. it produces an "IO [Maybe (Int,Int,Int)]" from an "[(Int,Int,Int)]"
23:39:01 <koz_> I can't understand why I'm getting this error message: http://lpaste.net/360233
23:39:56 <cocreature> koz_: it’s not just a different line number, it references different code
23:40:05 <cocreature> please show us the code that’s actually producing the error
23:40:12 <koz_> cocreature: Sorry, my bad!
23:40:50 <koz_> cocreature: Should be correct now: http://lpaste.net/360233
23:41:02 <koz_> (I must be tired if I'm making c/p errors like this)
23:41:43 <cocreature> koz_: so 1. the second argument to STVector should not be "m" it should be "s" so you corrected it the wrong way around :)
23:41:55 <cocreature> 2. if you have an STVector you are not going to be able to work in an arbitrary PrimMonad
23:42:12 <koz_> cocreature: Ah, it forces it into ST?
23:42:21 <geekosaur> that would be what an STVector is about, yes
23:42:26 <cocreature> try "MVector (PrimState m) a"
23:42:43 <koz_> OK, thank you.
23:43:10 <cocreature> koz_: take a look at the type signatures in https://hackage.haskell.org/package/vector-0.12.0.1/docs/Data-Vector-Mutable.html to get an idea for how they should look like
23:43:28 <nshepperd> ij: the first function uses _3 at two different types, which would be why it doesn't when you replace it with l
23:43:35 <koz_> Could someone explain the whole PrimState thing? I keep seeing it, but I have no idea what it means exactly.
23:44:04 <koz_> I get PrimMonad, sorta - it's like a transformer for anything that can sit at the 'bottom' of a stack, like Identity, ST and IO.
23:47:00 <nshepperd> PrimMonad is basically the typeclass for ST
23:47:22 <nshepperd> basically, generalised version of MonadIO
23:47:43 <koz_> So what is PrimState then?
23:47:51 <koz_> Is it 'anything that can serve as an ST state token'?
23:47:57 <nshepperd> PrimState gives you the s in ST s
23:48:05 <nshepperd> PrimState (ST s) = s
23:48:11 <nshepperd> PrimState IO = RealWorld
23:50:30 <nshepperd> using PrimMonad/PrimState you can write functions that work in both ST and IO (and in any monads built on those)
23:51:39 <nshepperd> generalised newSTRef: PrimMonad m => a -> m (STRef (PrimState m) a)
23:52:09 <nshepperd> if you use that in ST, you get a -> ST s (STRef s a)
23:52:38 <nshepperd> in IO, you get a -> IO (STRef RealWorld a)
23:52:47 <koz_> Which is basically a -> IORef a?
23:53:02 <nshepperd> yeah, STRef RealWorld ~ IORef pretty much
23:53:14 * hackage yesod-csp 0.2.4.0 - Add CSP headers to Yesod apps  https://hackage.haskell.org/package/yesod-csp-0.2.4.0 (boblong)
23:55:35 <ij> nshepperd, So can the general function be written at all?
