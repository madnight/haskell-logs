00:50:53 <phadej> funny, I have the very same question as quchen
00:51:05 <phadej> (with min though :P)
00:52:37 <MarcelineVQ> what was the question anyway?
00:55:10 <phadej> is there prettier way to write fmap getMax $ fmap Max a <> fmap Max b :: Ord a => Maybe a -> Maybe a -> Maybe a
00:56:52 <MarcelineVQ> ah. min is more interseting too, because you have to ask if min is Nothing or the smallest number if there are both
01:01:37 <ertes-w> helo
01:02:31 <AWizzArd> Hi ertes-w.
01:04:27 <phadej> MarcelineVQ: well, if you want Nothing to min element, it's easy
01:04:33 <phadej> > liftA2 min Nothing (Just 'a)
01:04:35 <lambdabot>  error:
01:04:35 <lambdabot>      • Syntax error on 'a
01:04:35 <lambdabot>        Perhaps you intended to use TemplateHaskell or TemplateHaskellQuotes
01:04:36 <phadej> > liftA2 min Nothing (Just 'a')
01:04:39 <lambdabot>  Nothing
01:04:43 <phadej> > liftA2 min (Just 'b') (Just 'a')
01:04:46 <lambdabot>  Just 'a'
01:05:26 <phadej> vs.
01:05:46 <phadej> > fmap getMin $ fmap Min Nothing SM.<> fmap Min (Just 'a')
01:05:48 <lambdabot>  Just 'a'
01:06:49 <jle`> phadej: you can max the Down
01:06:51 <ertes-w> :t (\x y -> getMax (Max x <> Max y)) :: (Ord a) => Maybe a -> Maybe a -> Maybe a
01:06:52 <lambdabot> error:
01:06:52 <lambdabot>     Ambiguous occurrence ‘<>’
01:06:52 <lambdabot>     It could refer to either ‘Data.Monoid.<>’,
01:06:58 <ertes-w> @undef
01:06:58 <lambdabot> Undefined.
01:06:59 <ertes-w> :t (\x y -> getMax (Max x <> Max y)) :: (Ord a) => Maybe a -> Maybe a -> Maybe a
01:07:01 <lambdabot> error:
01:07:01 <lambdabot>     Variable not in scope: getMax :: t0 -> Maybe a1
01:07:01 <lambdabot> error:
01:07:06 <jle`> > max (Just (Down 'a')) Nothing
01:07:08 <lambdabot>  Just (Down 'a')
01:07:18 <ertes-w> :t (<>)
01:07:20 <lambdabot> Monoid m => m -> m -> m
01:07:25 <ertes-w> @let import Data.Monoid
01:07:25 <jle`> > max (Just (Down 'b')) (Just (Down 'c'))
01:07:26 <lambdabot>  Defined.
01:07:27 <lambdabot>  Just (Down 'b')
01:07:29 <ertes-w> :t (\x y -> getMax (Max x <> Max y)) :: (Ord a) => Maybe a -> Maybe a -> Maybe a
01:07:30 <lambdabot> error:
01:07:30 <lambdabot>     Variable not in scope: getMax :: t0 -> Maybe a1
01:07:30 <lambdabot> error:
01:07:34 <ertes-w> huh?
01:07:37 <ertes-w> :i Max
01:07:43 <ertes-w> @src Max
01:07:43 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
01:07:43 <phadej> fwiw, please try those in query with lambdabot
01:07:44 <jle`> Max is from Semigroup
01:07:49 <phadej> and then paste here the working one ;)
01:07:54 <ertes-w> d'oh, of course
01:08:06 <ertes-w> phadej: i didn't expect that not to work
01:08:25 <jle`> i wonder why there's no record accessor for Down
01:08:26 <ertes-w> in any case Nothing is smaller than Just anyway
01:08:32 <ertes-w> so you can use 'max' directly
01:08:47 <jle`> i suppose someone really objected to a function called getDown in base
01:08:54 <ertes-w> > max (Just 3) (Just 5)
01:08:55 <lambdabot>  Just 5
01:09:01 <phadej> :i Down
01:09:06 <phadej> :(
01:09:13 <jle`> Down flips the Ord instance
01:09:22 <jle`> so max of down is min
01:09:39 <jle`> but if you just the down then nothing is min still
01:09:54 <jle`> so just is max
01:10:06 <jle`> and who's on first
01:10:22 <phadej> jle`: I know, but then you might end up needing to compare on Down (Maybe (Down a)) ;)
01:10:41 <jle`> just max (Just (Down 'a')) Nothing should give you the behavior you want
01:12:10 <phadej> i.e. I don't really see those pretty, in both you need to wrap (and unwrap?) newtypes, either Max or Down
01:12:51 <ertes-w> i'm kinda surprised that there are no Min and Max for Monoid
01:13:27 <jle`> but there is no Monoid instance :o
01:13:27 <phadej> Min and Max are Monoids, but they aren't in Data.Monoid
01:13:55 <jle`> Max can't be made a Monoid in a nice way
01:14:13 <jle`> not with the standard typeclasses at least
01:14:16 <ertes-w> jle`: instance (Bounded a, Ord a) => Monoid (Max a)
01:14:17 <phadej> hmm. no true. they aren't monoids
01:14:38 <jle`> ertes-w: there are no laws relating minBound and compare/</>
01:15:09 <ertes-w> jle`: i'd consider that a bug in the base class laws
01:15:17 <ertes-w> Bounded is meaningless without Ord
01:15:43 <phadej> ertes-w: well, it makes sense for [minBound .. maxBound]
01:15:44 <dminuoso> Do you folks generally specify type annotations when they are not needed?
01:15:58 <phadej> but you'd expect x < succ x
01:15:59 <quchen> dminuoso: At the top level: yes.
01:15:59 <ertes-w> phadej: sure, but then Enum is a similarly meaningless class =)
01:16:04 <ertes-w> useful, but meaningless
01:16:05 <quchen> dminuoso: In let/where: sometimes.
01:16:19 <dminuoso> quchen: by "top level" do you mean at the module level?
01:16:23 <quchen> dminuoso: Yes
01:16:42 <phadej> same as quchen
01:16:51 <ertes-w> ditto
01:17:18 <dminuoso> What are your reasons for doing so? Couldn't the argument be made that a sufficiently advanced editor can give you those types anyway?
01:17:30 <MarcelineVQ> for the reader, if no other reason
01:17:38 <ertes-w> dminuoso: i don't want to hover over a definition to see the type
01:17:43 <jle`> it's easier for humans to read
01:17:47 <jle`> but also it helps you write code as well
01:17:53 <ertes-w> dminuoso: also for the most part i write the type signature *first*
01:17:56 <piyush-kurur> dminuoso: mainly because it is the first step before writing the code
01:18:04 <quchen> dminuoso: A sufficiently advanced editor could do many things, but we still edit code in multiple files instead of having the editor just display one file in a convenient way.
01:18:13 <jle`> yes this is like asking if there's a good reason to have train tracks
01:18:18 <ertes-w> dminuoso: because then i can use typed holes more effectively, and in general GHC does a better job guiding me to the solution
01:18:21 <jle`> shouldn't a sufficiently advanced train not need trained tracks
01:18:32 <jle`> s/trained/train
01:18:41 <quchen> jle`: Friction says »yes it does even for sufficiently advanced trains«.
01:18:59 <jle`> obviously it is then by definition not sufficiently advanced :)
01:19:00 <ertes-w> dminuoso: not writing type signatures for me would mean *deleting* type signatures that i had already written =)
01:19:00 <MarcelineVQ> what kind of advanced train has to deal with friction? we've got magnets now
01:19:01 <quchen> Unless you redefine »train«.
01:19:23 <jle`> ||set of sufficiently advanced trains|| = 0
01:20:06 <phadej> I write types out for compiler to verify them
01:20:37 <phadej> in Haskell98 you don't need to write a single one type-annotation, but that would be quite hard to get right...
01:20:50 <phadej> (type-annotations localise errors)
01:21:18 <dminuoso> jle`: Sorry if this seemed silly to you. Lack of expertise makes my rationale less likely to be correct. But it seemed that the unanimous opinion voiced in this channel fits the perspective Ive already had.
01:21:32 <jle`> definitely not a silly question :)
01:22:03 <cocreature> phadej: that’s not really true even for Haskell98, is it? "show . read" is Haskell98 and requires an annotation
01:22:54 <phadej> cocreature: ah, true.
01:22:56 <Deaddy> often you also get an idea what a thing does if all you have are types and the name of the thing
01:23:13 <dminuoso> Deaddy: That's kind of what made me think throughout the night.
01:23:59 <ertes-w> in other static languages i might be more tempted not to write the type signatures, because most other type systems are really degenerate anyway
01:24:09 <ertes-w> most languages reduce types to a safety feature, and do a poor job at that
01:24:10 <dminuoso> Was watching a talk from cppcon 2016 about types yesterday, where the speaker taught parametricity to C++ folks and some type theory basics. Nothing new to me, but he made an interesting point that types *can* replace documentations.
01:24:50 <ertes-w> const (x :: a) (_ :: b) :: a = x
01:25:15 <cocreature> const x y = error "lol parametricity"
01:25:16 <ertes-w> if i had to write *this*, i wouldn't bother
01:25:57 <quchen> ertes-w: Surely you meant public function const (x :: a) (_ :: b) :: a = x
01:26:01 <ertes-w> type syntax is important, way more important than one might think
01:26:38 <ertes-w> quchen: yeah, i forgot
01:27:00 <cocreature> public static final function const (x :: a) (_ :: b) :: a = x
01:27:15 <ertes-w> public function const<a,b> (x :: a) (_ :: b) = return x
01:27:15 <quchen> ertes-w: Actually it’s worse, you have to quantify the a and b as well
01:27:23 <ertes-w> quchen: ^
01:27:28 <quchen> :-)
01:29:20 <Deaddy> dminuoso: Well, replacing documentation. I think it is a necessary part of documentation and in some cases it is all you need, i.e. if you do not care about the details
01:31:13 <ertes-w> please define the function const quantifying over a, b to return r of type a with arguments x of type a and a nameless argument of type b where r is x
01:31:30 <Deaddy> dminuoso: think of a sort function, if it is just sort : List -> List, you know what it does, whereas just some sort(list) method in another language you don't know whether it returns a sorted list or if it sorts the list in place or whatever (once in a file I shoot myself in the foot in python)
01:31:40 * hackage boolean-normal-forms 0.0.1 - Boolean normal form: NNF, DNF & CNF  https://hackage.haskell.org/package/boolean-normal-forms-0.0.1 (phadej)
01:33:02 <dminuoso> Deaddy: Well [a] -> [a] can do all sorts of funky things even in Haskell. tail, slice, reverse, shuffle, id
01:33:10 <dminuoso> But the one thing it can not do is sort because there's no Ord constraint
01:34:59 <ertes-w> there is more than just the type…  there is also convention
01:35:06 <Deaddy> ok well bad example, but if you see two functions with this type and a name like tail or reverse, you do not need to look at the probably more complicated code or a line of documentation that says what it does
01:35:17 <ertes-w> nub :: (Ord a) => [a] -> [a]  -- i'd trust this function to be efficient
01:35:21 <ertes-w> reading just its type
01:35:36 <ertes-w> nub :: (Eq a) => [a] -> [a]  -- and i know this one isn't
01:36:04 <dminuoso> What do you mean by "efficient" ?
01:36:24 <ertes-w> dminuoso: nub deletes all but the first occurrence of an item
01:36:30 <ertes-w> > nub "hello world"
01:36:32 <lambdabot>  "helo wrd"
01:36:52 <ertes-w> dminuoso: for that it needs a running set of elements it has already encountered
01:37:03 <dminuoso> Ahh
01:37:25 <ertes-w> if all you have is Eq, then it's O(n²)
01:37:27 <dminuoso> So I guess (Eq a) => [a] -> [a] has to run in O(n^2)
01:37:28 <dminuoso> Heh.
01:38:01 <dminuoso> With Ord it should be what, O(nlog n)?
01:38:07 <marvin2> is there nub with Ord constraint in prelude?
01:38:07 <ertes-w> yeah, but if it's the O(n²) algorithm you wouldn't just require Ord anyway
01:39:07 <ertes-w> therefore if there is an Ord constraint and comes from a more or less experienced haskell programmer, i'd be fairly confident that it's the efficient version
01:39:28 <ertes-w> marvin2: efficient 'nub' requires data structures that aren't in base
01:39:53 <marvin2> ertes-w Map would do
01:40:02 <ertes-w> marvin2: Map isn't in base
01:40:11 <marvin2> oh?
01:40:19 <cocreature> it’s in "containers"
01:40:26 <ertes-w> marvin2: and you would use Set in this case
01:41:14 <marvin2> so is there a more efficient nub in any module that ships with ghc?
01:41:36 <ertes-w> that would be base =)
01:42:03 <cocreature> GHC ships with "containers"
01:42:11 <marvin2> ertes-w so is there efficient nub in base? suspense is killing me
01:42:19 <cocreature> marvin2: no there isn’t :)
01:44:21 <marvin2> considering that barebones Set can be implemented in less than 10 lines I'm not sure that "required data structures aren't in prelude" is a good enough reason to have O(n2) nub
01:46:46 <ertes-w> marvin2: Set in 10 lines?  with O(log n) operations?  i'd like to see that =)
01:47:51 <ertes-w> it's fairly easy to write in terms of foldr and Set, if you need it…  but when do you?  i can't think of any non-contrived use cases for 'nub'
01:48:33 <marvin2> ertes-w really? you can't see real-world uses for nub?
01:49:32 <ertes-w> marvin2: when do you need a unique sequence where you care about the order, but wouldn't want to use an ordered set data structure?
01:49:56 <ertes-w> most of the time you don't care about order and just use Set to begin with
01:50:04 <ertes-w> (or IntSet or HashSet or …)
01:50:51 <marvin2> ertes-w that assumes you have the benefit of choosing your own data structure.
01:51:05 <ertes-w> marvin2: when don't i have that benefit?
01:51:24 <marvin2> ertes-w every single time you call a function or action someone else wrote
01:51:41 <ij> Can you get automatic lenses for data Foo = Bar String | Baz String? Can you get automatic lenses for records without prefixing them with the underscore, if you also want to use the data types for decoding with aeson?
01:51:57 <ertes-w> ij: those aren't lenses, but prisms:  makePrisms
01:52:13 <cocreature> ertes-w: the implementation in extra is not that much longer than 10 lines https://hackage.haskell.org/package/extra-1.6/docs/src/Data-List-Extra.html#nubOrd :)
01:52:23 <cocreature> (the set is implemented at the bottom)
01:53:14 <ertes-w> cocreature: true
01:53:30 <ertes-w> marvin2: i don't understand that
01:54:01 <ertes-w> you mean when a third party API wants a list instead of a set, and that list needs to be unique?
01:54:25 <ertes-w> if yes, i'd still use a set
01:54:44 <marvin2> ertes-w no, I mean when a third party app supplies a list
01:54:45 <rightfold> I wonder if you can generate SPECIALIZE pragmas using CPP
01:54:52 <marvin2> API*
01:54:59 <ertes-w> marvin2: then i would turn it into a set
01:56:01 <marvin2> ertes-w, and then back to list, if needed? as opposed to using nub?
01:56:06 <merijn> rightfold: Yes, that'd work fine
01:56:11 <ertes-w> marvin2: yes
01:56:21 <merijn> rightfold: CPP is a textual preprocessing step that runs before GHC looks at the source
01:56:28 <marvin2> ertes-w would you do the same if nub was implemented efficiently?
01:56:43 <ertes-w> marvin2: nub constructs an internal set anyway
01:56:54 <ertes-w> might as well construct that set
01:57:23 <marvin2> what?
01:58:16 <merijn> marvin2: Why would you NOT construct the set?
01:58:30 <rightfold> merijn: ganz toll
01:58:34 <ertes-w> marvin2: the only rationale i can think of for 'nub' is that it's actually lazier than (S.toList . S.fromList)
01:58:45 <ij> Can I get a traversal for data A = A' String | A'' String?
01:59:28 <ertes-w> marvin2: if i don't need that laziness i would go for Set…  'nub' needs a working set internally anyway, so you're going to construct it one way or the other…  might as well use the set directly
01:59:34 <marvin2> merijn how can nub construct a Set (if that is what you meant by set) with Eq constraint?
01:59:49 <ertes-w> marvin2: s/nub/efficientNub/
01:59:58 <merijn> marvin2: No, I'm not saying nub constructs a set. I'm asking "why do you wanna avoid constructing one?"
02:00:15 <merijn> marvin2: Because the discussion appears to be, you not wanting to use a set?
02:00:28 <ertes-w> (the inefficient nub also constructs a working set)
02:00:40 <ertes-w> (it just uses a very poor data structure for it)
02:01:16 <merijn> marvin2: nub just fakes building a set by comparing each element against each other, which is why it has such terrible complexity
02:01:23 <ertes-w> merijn: the discussion is: "when would you actually use an efficient 'nub' over just using a Set?"
02:01:24 <merijn> (nub is O(n^2)
02:01:37 <marvin2> merijn that is not the discussion, at least not from my end. my whole point was that nub should use Set, either Data.Set or its own internal set
02:01:54 <marvin2> and have Ord instead of Eq constraint
02:02:19 <merijn> marvin2: I think there's already plans to add an efficient nub being discussed on libraries@, like, 2 weeks ago
02:02:48 <ertes-w> merijn: so base is going to depend on containers?  or will it use a mini-implementation of Set?
02:03:28 <merijn> ertes-w: I don't know where it's gonna be put
02:03:38 <cocreature> looks like they’re going to put it in "containers" https://mail.haskell.org/pipermail/libraries/2017-November/028307.html
02:03:49 <merijn> It was one of dfeuer's efficiency binges, iirc
02:04:06 <merijn> Since he's maintaining containers that doesn't surprise me, no
02:07:15 <jle`> (S.toList . S.fromList) is the nub i'd use, but, it does destroy ordering
02:07:43 <jle`> where normal-nub doesn't
02:07:59 <jle`> > nub "hello world"
02:08:01 <lambdabot>  "helo wrd"
02:08:06 <marvin2> so it will be called nubEfficient, and nub remain as it is? I think it would be more sensible to name it nub, and rename current nub to nubInefficient, on the rare ocassion when you need nub and can't satisfy Ord constraint
02:08:09 <jle`> > (S.toList . S.fromList) "hello world"
02:08:11 <lambdabot>  " dehlorw"
02:08:35 <jle`> marvin2: whoa there, you're basically talking about breaking changes to ghc which would probably break a lot of existing code
02:09:17 <TMA> it has been said, that Ord is required even today
02:09:32 <tdammers> :t nub
02:09:33 <jle`> changing the type of 'nub' breaks a lot of existing code, and for something that isn't *huge*, that's probably a non-starter
02:09:33 <lambdabot> Eq a => [a] -> [a]
02:10:02 <jle`> we needed a 3-GHC-versions cycle to just make Applicative a superclass of Monad
02:10:27 <marvin2> jle` good point, a sensible efficient nub, that keeps the ordering can't just do toList . fromList. it has to build a list while checking for duplicates in a set
02:10:30 <jle`> and that's something that actually made a big positive impact
02:10:47 <marvin2> jle`, maybe some of that code should be broken.. i imagine a lot of people use nub withotu realizing how terribly inefficient it is
02:11:00 <tdammers> indirectly too... the relatively painless transition paved the way for other similar transitions like SMP
02:11:16 <jle`> marvin2: yes there was a bug in cabal a few years back from this
02:11:18 <TMA> I gather that is it not possible to have different implementation based on the constraint (with the same name)
02:11:30 <jle`> but "maybe some of that code should be broken" is not a good philosophy for a stable project
02:11:57 <jle`> or at least a project that needs to be stable to be useful
02:12:54 <jle`> we'd like people to be able to build old things without having to be completely up to date and dig into multiple complicated migration guides
02:13:33 <jle`> and also we're trying to get people to take haskell seriously for industry >_>
02:14:19 <ertes-w> jle`: (S.toList . S.fromList) is not nub
02:14:23 <marvin2> jle` if I used nub without realizing it is giving me O(n2) I'd like compiler to warn me about it and throw an error at me. if it was efficient (there was Ord constraint) it would just continue to work
02:14:54 <dminuoso> jle`: is my assumption about O(nlog n) correct for Ord?
02:15:02 <merijn> marvin2: To be fair, the docs pretty explicitly state it's O(n^2), it's the first thing listed
02:15:21 <merijn> dminuoso: If you don't preserve ordering then getting all uniques is n log n, yes
02:15:51 <ertes-w> @let nub' xs = foldr (\x go ss -> if S.member x ss then go ss else x : go (S.insert x ss)) (const []) xs mempty
02:15:53 <lambdabot>  Defined.
02:16:04 <ertes-w> > nub' [0..]
02:16:06 <lambdabot>  [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
02:16:11 <ertes-w> jle`: ^
02:16:47 <jle`> indeed, i jumped the gun there :)
02:17:46 <ertes-w> also changing the type of 'nub' breaks existing code?  really?
02:18:01 <ertes-w> seriously that code probably needs to be broken anyway
02:18:06 <marvin2> yup
02:18:13 <merijn> ertes-w: I disagree
02:18:31 <merijn> ertes-w: I've used nub in a bunch of places where there was no way to implement Ord
02:18:44 <ertes-w> merijn: and no way to implement Hashable?
02:19:15 <merijn> ertes-w: Not without adding a bunch of orphans, etc.
02:19:25 <merijn> ertes-w: If N is small, who gives a shit about n^2?
02:20:28 <ertes-w> depends…  do you need that small-n-nub in an inner loop?  then it can make the difference between 10 secs and 10 minutes =)
02:22:31 <merijn> ertes-w: Sure. But saying "people's shit should be broken because I don't like nub being n^2 and those people should've written that code" is a bit more drastic than "people shouldn't use n^2 in an inner loop"
02:22:46 <merijn> s/should've/shouldn't've/
02:23:07 <merijn> The nix people are in Utrecht?
02:23:37 <merijn> hmmm, I've heard people complain about Nix needing a type-system...sounds like carreer opportunity :p
02:24:28 <merijn> And that's the wrong channel >.>
02:25:03 <ventonegro> #nix-jobs?
02:25:23 <merijn> Naah, -offtopic discussion
02:27:11 <marvin2> merijn changing "nub" to "inefficientNub" is a very easy fix, compiler even helps you with that. on the other hand tracking down that nub is the bottle neck is a lot harder, especially when you don't realize that the default (and as of now, only) nub implementation is O(n^2). I imagine that most people aren't reading help file for every trivial function they use
02:28:21 <ertes-w> merijn: i think it's not that drastic, if all you really need to do is an s/nub/squareNub/
02:28:39 <ertes-w> merijn: it's not like you need to rewrite your algorithm
02:29:14 <ertes-w> if we can get AMP and FTP through, we can probably get this one through as well =)
02:30:31 <tdammers> marvin2: the problem is that this would break a lot of mature libraries out there, things that basically just work right now, and don't need any maintenance except maybe for the occasional dependency version bump
02:31:05 <tdammers> personally, I'd prefer keeping nub as-is, and providing a better implementation under a different name
02:31:23 <jle`> we could probably phase it in over a 3-ghc-version cycle, but it's a lot of effort for something with probably much smaller ROI than AMP/FTP
02:32:05 <tdammers> a low-hanging first step would be to just provide a better nub in a separate module, outside of Prelude
02:32:47 <tdammers> similar to how there are lots of functions of which there are specific list versions and more general traversable or foldable ones
02:32:56 <jle`> we could also give efficient nub a different name, like 'uniq'
02:32:59 <jle`> and then re-brand nub
02:33:07 <tdammers> indeed
02:33:17 <jle`> "nub?  it's called that because only nubs use it"
02:33:29 <ertes-w> heh
02:33:31 <jle`> retcon it
02:33:36 <drdo> It's kinda obvious from the type that nub cannot do the efficient Ord thing
02:33:38 <ertes-w> i agree about the low ROI though
02:33:41 <drdo> There's no Ord constraint
02:34:22 <tdammers> or, introduce a new one called uniq, provide an unpleasant alias for nub, and then deprecate the old nub
02:34:34 <drdo> tdammers: nub is not in the Prelude anyway
02:34:38 <ertes-w> let's focus on stuff that matters: can we please rename 'return' to 'stopUsingReturnAlready'?
02:34:59 <tdammers> drdo: oh, right, heh
02:35:41 <drdo> In fact, I think the Prelude should be greatly expanded
02:35:44 <ertes-w> or more seriously now that Semigroup finally made it into base, i'd like to see the SMP happen
02:35:58 <drdo> Having a full page of trivial imports is no fun
02:36:19 <ertes-w> drdo: remember: anything you put in Prelude is going to have a snail-like update cycle
02:36:39 <drdo> ertes-w: Then remove everything from the Prelude!
02:36:59 <drdo> This halfway thing is no fun
02:38:22 <drdo> Also, when are we getting a → (a → b) → b and >>> with a good symbol in the Prelude?
02:38:39 <merijn> drdo: The first is already in base
02:38:47 <merijn> drdo: Doubt it will ever get in Prelude, though
02:38:52 <drdo> merijn: Where is it?
02:39:04 <merijn> :t (Data.Function.&)
02:39:05 <lambdabot> a -> (a -> b) -> b
02:39:12 <drdo> Didn't know it was there!
02:39:32 <drdo> Yet another line to add to the trivial imports list!
02:40:14 <drdo> I really don't get this thing of including seemingly arbitrary parts of modules in the Prelude
02:41:00 <drdo> Another more serious in my opinion issue if we want haskell to be mainstream is the Text/String/ByteString situation
02:41:31 <drdo> Doesn't stop anyone from doing things, but it's a pain in the ass
02:41:34 <merijn> drdo: The Prelude was specified by the Report years ago. The issue with adding new stuff is that (since Prelude is implicitly imported everywhere) you might break code by introducing name clashing
02:42:20 <merijn> drdo: So any addition to Prelude has to be sufficiently amazing/required to warrant the potential breakage
02:42:54 <merijn> drdo: ezyang's work on backpack might make dealing with Text/String/ByteString drastically easier in the future
02:44:31 <ertes-w> drdo: the Text/String/ByteString situation is on purpose…  it's a conspiracy by SPJ that was planned for years to deal with the worst case scenario of haskell actually becoming successful
02:45:55 <ertes-w> it's not gonna stop haskell from increasing in popularity though; it'll just slow it down…  too bad haskell is a good language
02:46:23 <drdo> Another area I think needs a good library is resource management with concurrency
02:46:33 <merijn> drdo: How so?
02:46:39 <drdo> Not really sure how to do it, but I know that working with it as is is a major pain
02:46:41 <ertes-w> drdo: threads not good enough?
02:46:41 <merijn> That part I find rather easy?
02:46:55 <merijn> drdo: What kinda resources do you need managed?
02:47:14 <drdo> merijn: Tell me how to couple threads and objects and transfer resource "ownership" around easily
02:47:40 <ertes-w> drdo: when/why would you change resource ownership in the first place?
02:48:49 <ertes-w> i mean it's easy enough to do: you can put the resource in an MVar…  but that sounds like the kind of software design that you would want to avoid
02:48:51 <drdo> ertes-w: Imagine the simple situation of a server loop where you want to make the handling thread responsible for the connection socket
02:48:58 <makalu> I can use a cabal sandbox to run a script using "runhaskell -package-db=.cabal-sandbox/x86_64-linux-ghc-8.0.2-packages.conf.d/ script.hs". Is there a way to do this in a GHC-version-agnostic manner? Can cabal list the package-db location with some command?
02:49:21 <ertes-w> drdo: you hand over ownership as part of thread creation
02:49:32 <drdo> ertes-w: Yes, but doing that is not easy
02:50:02 <drdo> Requires tricky code and perhaps even exposing the issue (restore)  in the interface
02:50:03 <ertes-w> drdo: huh?  do (h, _, _) <- accept sock; forkIO (c h `finally` hClose h)
02:50:21 <ertes-w> i'd put a 'mask' around that, but that's it
02:50:25 <drdo> ertes-w: What if there's an exception in between accepting and fork?
02:50:36 <ertes-w> drdo: that's why i'd put a 'mask' around that
02:50:36 <merijn> drdo: That's why you do it in mask
02:50:49 <drdo> But then you have to restore the mask in the thread
02:50:58 <ertes-w> nope
02:51:02 <ertes-w> and even if, it's easy
02:51:02 <merijn> drdo: There's a builtin fork for that
02:51:16 <merijn> drdo: forkIOUnmasked
02:51:28 <ertes-w> mask $ \unmask -> do (h, _, _) <- unmask (accept sock); forkIOUnmasked (c h `finally` hClose h)
02:51:31 <merijn> drdo: that explicitly unmasks the IO in the child
02:51:33 <ertes-w> or even:
02:51:42 <merijn> Just use mask_ for that
02:51:48 <drdo> merijn: But do you want to do that?
02:51:59 <ertes-w> merijn: you can unmask the 'accept'
02:52:06 <ertes-w> i'd go with 'mask'
02:52:21 <merijn> mask_ $ do (h, _, _) <- accept sock; forkIOUnmasked (c h `finally` hClose h)"
02:52:29 <merijn> ertes-w: accept unmasks when it blocks anyway
02:52:47 <drdo> But do we really want to unconditionally unmask that thread?
02:52:53 <merijn> All blocking operations unmask (unless you use uninterruptibleMask
02:52:58 <merijn> drdo: Why wouldn't you?
02:53:00 <ertes-w> drdo: unmasks aren't unconditional
02:53:04 <drdo> What if whoever is using the code wants that masked for some reason?
02:53:19 <ertes-w> drdo: regular unmasks give fairly lightweight guarantees, and those are good enough here
02:53:25 <merijn> drdo: Doesn't make sense, the thread can't get exceptions unless you're storing the ThreadId
02:53:39 <merijn> drdo: Also, if the IO action in the thread uses mask it'll be masked again
02:53:58 <ertes-w> drdo: also this issue can't really be simplified much further…  it's not resource management that's difficult, it's async exceptions
02:54:53 <drdo> What about having a bunch of threads associated with some object, that should live and die together? How would you guys do this?
02:55:16 <ertes-w> drdo: 'async' covers that pattern nicely with withAsync
02:55:17 <merijn> drdo: What kind of object are we talking about, 'cause 90% of things are just covered by GC
02:55:48 <ertes-w> drdo: once the outermost withAsync returns, all subthreads will have been killed
02:55:52 <drdo> merijn: Imagine for example some "smart" socket
02:59:26 <ertes-w> drdo: i'd use withAsyncWithUnmask + Codensity in that scenario
02:59:29 <ertes-w> … probably
02:59:41 <drdo> I'm sure all these things have solutions
03:00:07 <drdo> The issue seems to be that it's not easy at all to do and requires very careful thinking
03:00:10 <merijn> drdo: The solution is: Build a nice wrapper library for the primitive tools we have and use that.
03:00:39 <merijn> drdo: Which is what a lot of people are doing for lots of problems in Haskell, but that takes time and people
03:00:44 <ertes-w> drdo: it does require careful thinking, but that is the difficult part…  the doing is honestly easy enough
03:01:01 <drdo> ertes-w: The thing is that I only wanna do the careful thinking once and abstract that :P
03:01:06 <merijn> It's easy to point out things "that could be better", but if it isn't yet, that's because no one is getting paid to do that shit
03:01:12 <drdo> But I'm not really sure how to
03:01:21 <merijn> drdo: So, what's stopping you from writing the wrapper library you want/need?
03:01:33 <merijn> That's how we got async :p
03:01:46 <drdo> merijn: I'm not quite sure what is needed and how to implement this in a non-intrusive way
03:02:28 <drdo> I could just wrap everything in a monad that tracks this, like some ResourceT on steroids
03:02:41 <drdo> But that violates the non-intrusive part
03:04:24 <drdo> It's also entirely likely that I have blown-up the issues in my head into big monsters that won't be a serious problem in practice :P
03:05:08 <drdo> But ideally I'd want automagic resource handling without having to worry about carefully bracketing and masking stuff
03:30:48 * hackage accelerate-fourier 1.0.0.2 - Fast Fourier transform and convolution using the Accelerate framework  https://hackage.haskell.org/package/accelerate-fourier-1.0.0.2 (HenningThielemann)
03:38:45 <ertes-w> drdo: honestly i think pretty much anything you want is already covered by async
03:39:16 <ertes-w> drdo: and about masking/bracketing: you will have to worry about that anyway
03:39:31 <ertes-w> no matter how high-level your abstractions get, unless you abstract the very idea of threads away
03:39:45 <drdo> ertes-w: Why would that be the case?
03:39:54 <ertes-w> drdo: because async exceptions
03:40:39 <drdo> ertes-w: Well, the whole point of the abstraction would be not having to worry about that
03:40:56 <ertes-w> drdo: but why?
03:41:12 <drdo> What do you mean why?
03:45:38 <ertes-w> drdo: i've come to consider that a feature of haskell
03:45:58 <ertes-w> especially since i tried to do concurrency in python a few months back
03:47:24 <ertes-w> drdo: much like laziness this is just another feature you just get used to, and eventually you start to value it
03:47:40 <drdo> ertes-w: It is a feature of haskell, but the point of the abstraction would be not having to worry about it when handling resources
03:48:20 <drdo> I wanna write "x <- newX" and just write nice sequential code, not bracket/bracketOnError and mask all over the place just to allocate resources
03:48:20 <ertes-w> drdo: just use common bracketing patterns…  if you need to communicate a non-GC resource across threads, use masking
03:48:35 <drdo> ertes-w: Yes, that's what the abstraction would do!
03:48:49 <ertes-w> drdo: you can use the "x <- newX" pattern using Codensity
03:48:51 <drdo> I'd like to not have to write that tedious error-prone code all the time
03:49:46 <ertes-w> (\m fp -> Codensity (withFile m fp)) :: IOMode -> FilePath -> Codensity IO Handle
03:50:34 <ertes-w> (\open close -> Codensity (bracket open close)) :: IO a -> (a -> IO b) -> Codensity IO a
03:51:02 <ertes-w> Codensity @ Control.Monad.Codensity @ kan-extensions
03:52:31 <ertes-w> @let import Control.Monad.Codensity
03:52:33 <lambdabot>  Defined.
03:52:37 <ertes-w> oh, cool
03:52:49 <ertes-w> @let cbracket open close = Codensity (bracket open close)
03:52:50 <lambdabot>  Defined.
03:52:53 <ertes-w> :t cbracket
03:52:54 <lambdabot> IO a -> (a -> IO b) -> Codensity IO a
03:52:56 <ertes-w> drdo: ^
03:53:13 <ertes-w> do x <- cbracket o1 c1; y <- cbracket o2 c2; …
03:53:56 <drdo> I'll look into it when I can!
03:55:28 <ertes-w> this is especially nice when the number of resources you need to acquire is dynamic
03:55:42 <ertes-w> xs <- replicateM 100 (cbracket _ _)
03:56:18 <ertes-w> handles <- traverse (cWithFile ReadMode) filePaths
04:02:02 <quchen> ertes-w: The managed package is a nice version of that pattern
04:03:25 <ertes-w> quchen: i prefer Codensity
04:04:20 <ertes-w> i see no point in using a restricted version of Codensity, and there are cases where i use it with other monads from IO like STM
04:09:49 <guillaum3> I wonder what is the best way to pass a compile time string to a module. Using CPP?
04:10:31 <orion> TH?
04:11:29 <guillaum3> orion: in my context TH is disabled (reflex application on android).
04:17:50 <quchen> CPP should work.
04:32:46 <guillaum3> quchen: thank you.
04:37:08 <orion> guillaum3: Is it open source?
04:37:18 <ksj> does the GHC scheduler preempt an lwt if it does a blocking action like using Network.HTTP.Client to make a request? 
04:37:32 <ksj> *lwt scheduler
04:38:03 <ksj> or do you have to tell it yourself, that it's doing a blocking action?
04:39:09 <drdo> ksj: You can block as much as you like
04:40:16 <drdo> Well, I guess the answer is that yes, GHC does the right thing and you don't need to say anything about blocking actions
04:40:34 <ksj> alright, thanks a lot
04:40:47 <drdo> Although that might not be true if foreign code blocks
04:40:59 <drdo> But for haskell code that's fine
04:41:25 <cocreature> use the threaded runtime and you’ll generally be fine
04:41:41 <ksj> very nice
04:41:41 <merijn> ksj: GHC has pseudo-preemption
04:42:04 <ksj> yeah it's a pool of lwts on top of OS threads
04:42:06 <merijn> ksj: Basically, whenever memory is allocated threads check to see if they should yield to another thread
04:42:08 <guillaum3> orion: my android app, yes...
04:42:22 <merijn> ksj: And blocking IO operations are explicitly yielding
04:43:10 <royal_screwup21> I have tree data structure like so: data Tree a = Empty | Branch a (Tree a) (Tree a)  I'm trying to write a fold to find the number of elements in a given tree. I'd love a pointer or two in the right direction
04:43:49 <drdo> royal_screwup21: How many elements does (Branch x l r) have?
04:44:01 <royal_screwup21> 1, just a
04:44:10 <drdo> royal_screwup21: Really? That whole tree has just one element?
04:44:21 <royal_screwup21> oops
04:44:49 <royal_screwup21> 1 + num of elements in left tree + num of elements in right tree
04:44:53 <sbrg> there you go
04:44:54 <drdo> right
04:44:56 <sbrg> that's your fold function
04:44:57 <drdo> Then that's what you write!
04:45:32 <merijn> drdo: Foreign calls (by default) run in a different thread, leaving Haskell unblocked
04:45:33 <orion> guillaum3: Could you send me a link? I'm interested in writing a reflex application and am seeking examples.
04:46:15 <drdo> merijn: A single thread for all foreign calls?
04:46:22 <WinterFox[m]> How would I get `find_level` to keep running `stack_volume` incrementing `current_level` until `stack_volume` >= `looking_for`? https://bpaste.net/show/f73b13358ba5
04:46:30 <merijn> drdo: I think it uses a pool of several threads for foreign calls
04:46:40 <merijn> drdo: This also happens in the in "unthreaded" runtime
04:46:45 <drdo> Interesting
04:47:12 <drdo> I thought it just used whatever osThread the current thread is running on
04:47:24 <sbrg> WinterFox[m]: until?
04:47:24 <merijn> drdo: No, only for unsafe foreign calls
04:47:26 <sbrg> @hoogle until
04:47:26 <lambdabot> Prelude until :: (a -> Bool) -> (a -> a) -> a -> a
04:47:26 <lambdabot> Control.Monad.HT until :: (Monad m) => (a -> Bool) -> m a -> m a
04:47:26 <lambdabot> CorePrelude until :: (a -> Bool) -> (a -> a) -> a -> a
04:47:37 <opqdonut> WinterFox[m]: for example, "find_level looking_for current_level | stack_volume current_level >= looking_for = current level | otherwise = find_level looking_for (current_level+1)
04:47:40 <merijn> drdo: Which is why unsafe foreign calls can block GC and are, thus, unsafe
04:47:58 <WinterFox[m]> sbrg: Essentially I want to work out what input to stack_volume gives the output looking_for
04:48:13 <drdo> merijn: I wonder what happens if you do a bunch of blocking foreign calls and exhaust the pool
04:48:26 <merijn> drdo: No clue, you'd have to investigate the RTS
04:48:47 <WinterFox[m]> Or if none do
04:49:02 <opqdonut> WinterFox[m]: you can also do something like "head $ dropWhile (\l -> stack_volume l < looking_for) [1..]"
04:49:03 <merijn> drdo: Which, honestly is not a bad idea anyway, since more people with some RTS experience would be good ;)
04:49:21 <sbrg> WinterFox[m]: FWIW, I think you can write a closed-form function that calculates stack_volume
04:49:37 <sbrg> but opqdonut has a nice solution for you
04:49:49 <royal_screwup21> so I'm supposed to "fold up" this  tree: data Tree a = Empty | Branch a (Tree a) (Tree a). This is from an exercise book and I'm curious what they mean by "fold up". If I understand correctly, when you fold something, the fold returns a value. Not sure how to it applies to this question
04:50:31 <opqdonut> WinterFox[m]: however both of these solutions I have you are O(n^2) since you're computing "stack_volume n" again and again. a better solution would compute stack_volume incrementally
04:50:39 <drdo> royal_screwup21: Study what fold is for something simpler first perhaps, like a list
04:51:17 <cocreature> royal_screwup21: basically, write something of type "(a -> b -> a) -> a -> Tree b -> a" which “folds” all elements in the tree
04:51:28 <opqdonut> WinterFox[m]: so something like: "find_level looking_for current_volume n | current_volume > looking_for = n | otherwise = find_level looking_for (current_volume + n^3) (n+1)"
04:51:44 <sbrg> royal_screwup21: One thing you could try, as a way to gain some intuition, is to simply add `deriving (Foldable)` to your datatype, and then folding the tree with a few different functions to see what happens. then you can write the fold yourself
04:52:38 <WinterFox[m]> opqdonut: Ah I think I understand that
05:11:15 <royal_screwup21> what does "tree@" mean in this context https://stackoverflow.com/questions/9627713/haskell-creating-a-binary-search-tree-from-a-list ?
05:11:56 <ksj> royal_screwup21: https://wiki.haskell.org/Keywords#.40
05:12:14 <ksj> wait it didn't link to @
05:12:17 <alp> 'tree' there is an alias for 'MakeNode left value right'
05:13:05 <alp> that's useful when you want to use one or more fields from the constructor, but also want to be able to use the entire value without having to put all the fields back together yourself to create a new value with the very same fields
05:13:33 <royal_screwup21> gotcha
05:16:42 * hackage Dish 0.0.0.6 - Hash modules (currently Murmur3)  https://hackage.haskell.org/package/Dish-0.0.0.6 (zcourts)
05:27:37 <mpickering> Does anyone know of a plugin which curries core definitions? 
05:29:13 <royal_screwup21> how did the OP https://stackoverflow.com/questions/9627713/haskell-creating-a-binary-search-tree-from-a-list get the outputs for his function? I included a deriving(Show) at the end of the data structure and ran add "John"  on ghci but I got an error: https://thepasteb.in/p/lOhOEgoNzpzfB
05:29:51 <royal_screwup21> oh nvm
05:37:43 <saurabhn_> is anyone here using the danger-hlint plugin? (to get linter warnings as comments on PRs)?
05:38:14 <royal_screwup21> I'm trying to write a simple unbalanced binary tree like so: https://thepasteb.in/p/NxhV3vNLED9CN this compiles on ghci, but I want to test it out. What's the easiest way to do that?
05:40:24 <sbrg> royal_screwup21: define a constant called "empty" to be the empty tree. then you can add a list of items using for example foldl' and `add` with `empty` as your seed
05:40:38 <sbrg> or well, you can just use `Empty` for `empty`
05:48:16 <royal_screwup21> sbrg: I think I get what you're saying, but can give you me a minimal example? I'm not quite able to translate it to code
06:08:29 <jchia_> Question about megaparsec : I'm writing a parser that's meant to work on both Text and ByteString, so using megaparsec, I'll use Text.Megaparsec.Byte.decimal and Text.Megaparsec.Char.decimal for parsing into an integer. Those are two different functions. I'll be using such functions in exactly the same way for ByteString and Text.
06:08:32 <jchia_> The question is: How do I write code for both ByteString & Text without repeating myself?
06:10:59 <mud> So if you're doing the same parser for both, I assume the Byte one is just when it's ASCII? Why not just decode it into Text first?
06:12:57 <merijn> jchia_: A parser that works on both ByteString and Text doesn't make any sense, tbh
06:13:13 <merijn> jchia_: The former parses binary data, the latter unicode input.
06:17:42 <kahlil29> I have a list of values that I want to encode into the form { "values" : [myListOfValues] }    ... best way to do it? 
06:22:01 <quchen> kahlil29: Is that JSON?
06:22:06 <quchen> If yes: use Aeson
06:22:42 <kahlil29> was trying to 
06:28:53 <jchia_> merijn: It makes sense, not in general, but in some cases. Example: parse into [Int], separated by comma (',' or "fromIntegral . ord $ ',').
06:29:34 <merijn> jchia_: How exactly do you plan to parse a number of comma from a ByteString?
06:29:35 <jchia_> There are things that ByteString & Text in common. I can just stay within ASCII and not refer to non-ASCII values.
06:29:50 <jchia_> merijn: ASCII
06:30:02 <merijn> jchia_: Then just decodeUtf8 and use Text?
06:30:19 <jchia_> merijn: Also, actually not number of commas, but split with comma and then parse the parts into decimal integers
06:31:25 <jchia_> merijn: For simplicity of implementation, I could always decode convert the ASCII ByteString into Text and then parse the text, but that's unnecessary work at run-time.
06:33:11 <jchia_> mud: Yes, I could do that, but it's unnecessary work at run-time.
06:33:14 <__monty__> Is there a reason to prefer Data.Array over Data.Vector in a very simple use case? Create a 'list' once and index it randomly a bunch of times.
06:33:33 <merijn> __monty__: Not really
06:34:51 <merijn> Oh, well, I suppose vector might have some fusion optimisation stuff
06:43:28 <__monty__> I don't really grok fusion yet but I guess it won't pose a problem.
06:44:13 <jchia_> Can pattern matching be done on Text like on String or Seq a?
06:45:13 <Rembane> jchia_: Nope. But you can use pattern guards instead.
06:45:17 <Rembane> jchia_: https://wiki.haskell.org/Pattern_guard
06:52:48 <jchia_> Rembane: Good idea
06:54:23 <quchen> I have foo = f foo. How do I conclude that foo = fix f in a systematic way without using »obvious«?
06:55:10 <quchen> I guess it’s easiest to do it in reverse, foo = fix f = f (fix f) = f foo
06:55:25 <Rembane> jchia_: No worries. :)
06:55:43 <quchen> But doing it in reverse isn’t possible that way since that would involve using foo = fix f :-{
06:55:58 <quchen> Doing it in reverse-reverse, I mean ;-)
07:00:45 <hexagoxel> foo = fix f <--> foo = let x = f x in x <--> foo = let x = f foo in x <--> foo = f foo
07:02:32 <quchen> Why does the second <---> hold?
07:02:52 <quchen> Looks like it assumes x = foo.
07:05:13 <hexagoxel> but it says "foo = x  (where x = ..)" on the left side..
07:05:42 <hexagoxel> but you are right, this may still be seen as non-obvious.
07:09:11 <hexagoxel> might have to unsugar the "let" to make it more rigorous.
07:13:45 <Clint> sm: it's right there on the hackage page
07:15:03 <Clint> (though admittedly that's not always accurate)
07:38:23 <royal_screwup21> I'm trying to create a binary tree out of a list like so: https://thepasteb.in/p/Elh1xR1z1RZUm this throws an error: https://thepasteb.in/p/X6hBKpBgWqXc3 what am I doing wrong?
07:40:52 <mnoonan> royal_screwup21, it looks like your adds use val in different places (second parameter in defs, first parameter is uses)
07:40:59 <byorgey> royal_screwup21: you have the order of arguments to add backwards in the recursive calls
07:41:46 <byorgey> royal_screwup21: incidentally, it's probably a good idea to give add a type signature.  If you did, you would get a much better error message.
07:42:13 <byorgey> because it would be able to pinpoint where the code deviates from your intention, rather than just telling you that it can't figure out a valid type for add
07:46:30 <royal_screwup21> hmm as for the type signature, I want to take in a tree and an int, then return a tree
07:46:51 <royal_screwup21> so something like Tree -> Int -> Tree
07:47:12 <royal_screwup21> except that gives me another error: https://thepasteb.in/p/Z4hPgOPZR17CG
07:48:26 <royal_screwup21> ah nvm
07:48:37 <c_wraith> You need an argument to Tree.  Probably Tree Int, or something. :)
07:48:50 <royal_screwup21> yup just realized :)
07:52:52 <ptek> is someone familiar with the tasty internals around?
07:53:48 <ptek> we would like to write a `beforeEach :: IO a -> TestTree -> TestTree` function that would traverse the TestTree and run the IO action before each of the single tests
07:54:34 <ptek> but the TestTree constructors are somewhat obscure to traverse. At least I don't see how it can be done
07:55:26 <mantovani> how do I genererate haskell code from WSDL or use a WSDL using Haskell ?
07:56:36 <dminuoso> This sounds terrible. :(
07:56:44 <Lokathor> iterate uses an (a -> a) for each next value, is there a list building function that uses an a -> (a,a) for each next value?
07:57:29 <mud> Lokathor: Sounds a tad like unfoldr? What's the meaning of each though?
07:58:28 <Lokathor> for use with split, each side is a generator, but once you use split on a generator you should take the two outputs and one goes back into that slot and one goes into the next slot
07:58:44 <Lokathor> a PRNG that is
07:59:48 <ertes-w> Lokathor: yes, that's unfoldr
07:59:53 <mud> Yeah that soundns like unfoldr, but not using the Maybe part. So you have a useless Just, but otherwise it should work.
08:00:00 <Lokathor> neato
08:00:00 <c_wraith> Without the Maybe layer
08:00:03 <Lokathor> i'll look into that
08:00:24 <ertes-w> > unfoldr (Just . randomR (0, 9 :: Int)) (mkStdGen 0)
08:00:27 <lambdabot>  [3,3,3,8,0,7,1,1,1,6,3,0,2,0,4,5,0,1,5,2,2,6,0,5,6,9,0,9,1,0,7,2,3,4,0,0,0,8...
08:00:27 <mud> I wonder if there's an unfoldr without the Maybe. Hm, in NonEmpty maybe?
08:00:32 <ertes-w> Lokathor: ^
08:00:52 <c_wraith> mud: nah, without the Maybe it'd be for infinite streams.  So, check libraries that specialize in streams.
08:01:02 <mud> Ah yeah, NonEmpty wouldn't make any sense
08:01:03 <ertes-w> you could just use 'iterate' and then fmap away the snd part
08:01:52 <ertes-w> unfoldr is better though
08:02:24 <Lokathor> ertes-w, no you can't do that, because multi-stream generators will (probably) return generators that are each in their own stream
08:02:48 <Lokathor> so you'd mess that part up i suspect, if you tried to just use normal iterate
08:03:32 <ertes-w> Lokathor: i don't understand…  what's a generator?
08:04:40 <Lokathor> a random number genertor. it has a state which changes from use to use, but some generator methods also have a "stream" which you can select and that shuffles the number order, but the stream doesn't change from use to use
08:05:05 <Lokathor> sadly, i must go to work now
08:05:49 <ertes-w> Lokathor: still not quite sure about the stream part, but in any case if your generation pattern is complicated, you can use lazy State
08:07:05 <ertes-w> > evalState (let go = do x <- state (randomR (0, 9)); b <- state random; ((x, b :: Bool) :) <$> go in go) (mkStdGen 1)
08:07:07 <lambdabot>  [(5,False),(5,True),(8,True),(4,True),(0,False),(1,True),(4,True),(6,True),(...
08:08:51 <ertes-w> > execWriter . flip evalStateT (mkStdGen 1) . forever $ do x <- state (randomR (0, 9)); b <- state random; tell [(x, b :: Bool)]
08:08:53 <lambdabot>  [(5,False),(5,True),(8,True),(4,True),(0,False),(1,True),(4,True),(6,True),(...
08:09:11 <ertes-w> one of the few legitimate use cases of Writer =)
08:11:12 <ptek> ocharles: maybe you could help with tasty?
08:34:08 <muzzle> are there any good resources on when I can expect my haskell program to actually allocate something? for example something like forM [1..1000] (...) doesn't seem to allocate memory, but how can I tell better before profiling?
08:35:51 <c_wraith> muzzle: are you looking at allocation or residency?
08:36:12 <slack1256> I would argue that because deforestation and heavy inlining, only profiling & reading core will tell you the real story
08:36:25 <muzzle> c_wraith: what's the difference precisely?
08:37:06 <c_wraith> muzzle: residency is how much memory is currently in use.  allocation is how much memory has been marked in use (but potentially freed later)
08:37:12 <muzzle> slack1256: But that doesn't really help me when programming. I would really like to be able to tell how my code will perform a bit better.
08:37:24 <c_wraith> muzzle: basically, residency accounts for GC, allocation doesn't
08:38:29 <muzzle> c_wraith: so a .prof resource tells me about allocation in the "alloc" column, right?
08:38:46 <c_wraith> muzzle: yes.  it should also have some "max resident" numbers.
08:39:05 <c_wraith> muzzle: and if you get a .hp file, it graphs resident use
08:39:16 <slack1256> muzzle: this is only a partial answer. If you know that the generated data structure is composed with a "good consumer" then it will potentially be deforested or allocated element by element and not at once
08:39:39 <muzzle> c_wraith: I basically just want to be able to tell if my code calls malloc/calloc or not
08:39:46 <muzzle> from just reading it 
08:39:48 <slack1256> which is suprisingly common
08:39:56 <c_wraith> muzzle: unless you're using the FFI, you never will call those. :P
08:40:09 <muzzle> c_wraith: I know :P
08:40:11 <c_wraith> muzzle: ghc has a custom allocator designed for its usage patterns.
08:40:17 <muzzle> c_wraith: but the internal haskell equivalent
08:40:51 <c_wraith> First approximation - any time a thunk is created or a constructor is passed an argument, that allocates.
08:41:09 <muzzle> because in a case like "forM [1..n] f" I don't have to actually allocate cons cells, right?
08:41:25 <c_wraith> But there are lots of optimizations that reduce the amount of allocation
08:42:13 <ptek> ok, we seem to have found an example of something similar in tasty-expected-failure http://hackage.haskell.org/package/tasty-expected-failure-0.11.0.4/docs/src/Test-Tasty-ExpectedFailure.html#wrapTest
08:42:21 <c_wraith> muzzle: well, forM will always allocate cons cells.  forM_ might not
08:43:07 <c_wraith> muzzle: that is, there is no optimization that removes the (:) constructors resulting from forM
08:43:58 <c_wraith> muzzle: but it's quite possible that forM might act as a good consumer and elide allocation of cons cells passed into it from a good producer.
08:44:26 <muzzle> c_wraith: right I meant forM_, sorry
08:45:11 <muzzle> c_wraith: but if a cons cell is allocated or not (in the case of forM_) depends on the consumer? and on the monad I use I guess?
08:45:29 <muzzle> c_wraith: so for example when using ST it probably allocates nothing?
08:45:55 <c_wraith> muzzle: Well, you need to distinguish between allocation done by forM_ and allocation done by the list argument to forM_
08:46:09 <ertes-w> muzzle: if you want more certainty in avoiding allocations, one option is to switch to a church list encoding explicitly…  that's what list fusion does behind the scenes
08:46:46 <ertes-w> muzzle: type List a = forall r. (a -> r -> r) -> r -> r
08:46:47 <muzzle> c_wraith: I'm working with Array indices in the ST-monad to get maximal performance out of a dynamic programming problem
08:47:00 <muzzle> to provide some more context
08:47:33 <ertes-w> muzzle: if you then inline your list functions, they should always compile to a tight loop
08:47:39 <c_wraith> it turns out forM_ is implemented with foldr, so it's automatically a good consumer. 
08:48:56 <c_wraith> So forM_ [1..n] won't allocate the (:) constructors for the list.
08:49:32 <muzzle> What exactly makes a consumer "good"? That it is written in a way that allows rewrite rules to fire?
08:49:40 <ertes-w> muzzle: that it's written in terms of foldr
08:50:04 <c_wraith> which is half of allowing the rewrite rules to fire, yes.
08:50:15 <c_wraith> The other half is that the producer must be written in terms of build
08:50:26 <c_wraith> ...  At least at some point in the rewrite phase.
08:53:21 <muzzle> c_wraith, ertes-w: thanks
09:18:48 <AndreasPK___> Is there a function Monad m => (a -> m a) -> m (a -> a)
09:20:10 <cocreature> AndreasPK___: that doesn’t make sense. take m=[], now the left could be "\x -> replicate x 0 :: Int -> [Int]", what should the right side be?
09:20:18 <cocreature> you need to decide the length of the list without knowing the argument
09:21:16 <glguy> or consider (\x -> print x >> return x) :: Show a => a -> IO a
09:21:47 <AndreasPK___> So my mind wasn't just unable to come up with something. Thanks :)
09:21:48 <glguy> What behavior would you expect this operation to have on this argument?
09:22:59 <rightfold> const (pure id)
09:23:22 <cocreature> id <$ print 42
09:28:31 <AndreasPK___> glguy: My issue was that I had code turning (a -> a) into (a -> m a) without using the monad (in the specific case). So part of my head kept thinking i could turn it into m (a-> a) afterwards but yeah makes no sense.
09:29:27 <rightfold> You can if it’s a comonad
09:30:37 <rightfold> But that’s rare
09:32:25 <aberrant> morning all
09:32:44 <aberrant> a silly question: do I want haskell-stack, haskell-platform, or just ghc (from homebrew; I'm on a mac)?
09:33:19 <glguy> Haskell Platform minimal installer comes with all the things you'll need.
09:33:35 <aberrant> so brew install haskell-platform
09:33:57 <aberrant> er, it's a cask. whatever.
09:34:17 <aberrant> "We no longer package haskell-platform. Consider installing ghc and cabal-install instead"
09:34:20 <aberrant> interesting.
09:35:57 <mnoonan> not a silly question, it is annoyingly non-obvious what the best option is.
09:36:46 <mnoonan> fwiw, I use stack on OS X and it works quite well. it'll download and properly sandbox versions of cabal, ghc, libraries, etc.
09:36:53 <aberrant> ok, very cool
09:37:07 <aberrant> thank you, mnoonan, and thanks for that observation that it's a bit confusing for beginners.
09:37:12 <glguy> The nice thing about the platform is you get a standalone GHC, stack, and a cabal-install
09:37:20 <glguy> even if you're using stack you need cabal-install for the solver functionality
09:37:38 <aberrant> I just ordered hardcopy LYAH.
09:38:09 <aberrant> anyone have a recommendation for vscode plugins?
09:38:38 <aberrant> heard good things about haskelly
09:52:51 <mud> aberrant: Apologies in advance for LYAH. But haskell is fun.
10:09:54 <shapr> cement: YOW!
10:10:08 <cement> ohai
10:22:09 <bitemyapp> glguy: Stack bundled with Platform was broken for quite some time and they dragged their feet on fixing it. There's no benefit to using Platform if you're intending to use Stack.
10:22:26 <glguy> I listed two benefits, actually
10:23:38 <bitemyapp> You don't need the solver that often, and even if you do, you don't need Platform to use it. It just works with any regular Stack install.
10:23:57 <glguy> So the current version of Haskell Platform ships with a broken stack?
10:24:41 <aberrant> @mud: I read the first bits online, and I liked the way it presented the language.
10:24:41 <lambdabot> Unknown command, try @list
10:25:06 <aberrant> er. oops. used to slack.
10:25:42 <aberrant> I'm trying to get away from scala a bit, since I hate the JVM.
10:25:52 <aberrant> but FP is really cool to me.
10:26:16 <rightfold> lambdabot uses precisely those two punctuation characters often used for human conversation, @ and >
10:26:49 <rightfold> If you like FP you’ll like Haskell since Haskell is very well suited for FP :3
10:27:21 * rightfold the amount of like may decline after exposition to dependent types
10:31:40 <ralu> what is to use if one needs to work with (a,Bool) or Either a a
10:32:21 <rightfold> ralu: what do you mean?
10:32:29 <rightfold> You can use pattern matching.
10:32:41 <mud> ralu: Are you asking which one to use?
10:33:15 <ralu> I am asking for someones else libraary that implemnts funcions working with this
10:34:12 <rightfold> @type (Left, Right, either)
10:34:13 <lambdabot> (a1 -> Either a1 b1, b2 -> Either a2 b2, (a3 -> c) -> (b3 -> c) -> Either a3 b3 -> c)
10:34:28 <mud> What kind of functions? I mean Either a a is an instance of a bunch of typeclasses, (Bool, a) is as well, so there's quite a few libraries there. Also some Arrow stuff for either, depending on how deep you want to go.
10:35:22 <rightfold> (Bool, a) has Functor and Traversable, which may be very useful
10:43:41 --- mode: glguy set -q *!*@gateway/web/irccloud.com/x-pkveljrkgmzholvz
10:44:02 --- mode: glguy set -q *!*@187-78-89-187.user.veloxzone.com.br
10:46:11 --- mode: glguy set -bbb *!*@vps-0105.uppersafe.net *!*@2601:181:8301:16fd:* $a:HorribleProgram
10:46:34 --- mode: glguy set -b *!*@2602:306:8b2b:5eb0:*
11:05:40 <sshack> So when I build a docker image with 'stack image container' I'm getting MacOS binaries inside my docker container. Is there a straightforward way to build the (required) linux binaries for a docker image on macos?
11:10:19 <shapr> sshack: ooh, interesting question
11:10:24 <shapr> if you find the answer, I'd like to know that.
11:12:11 <sshack> Yeah, I will pass it on.
11:12:29 <sshack> afaik it's the only thing stopping me from deploying right now.
11:14:25 <cocreature> sshack: enable stack’s docker support for building the binary
11:15:03 <sshack> I believe I already have it enabled.
11:15:05 <cocreature> stack has two orthogonal kinds of docker suppor: 1. build everything inside a docker image and 2. package the built binaries in a docker container
11:15:28 <sshack> Oh. I may be mistaken then. Is there a clear reference for this?
11:15:28 <cocreature> using 2. without 1. only works if your host OS is identical to the one running in the container
11:15:59 <cocreature> https://docs.haskellstack.org/en/stable/docker_integration/ should be the docs for 1.
11:16:41 <sm> Clint: doh! you're so right. Thanks
11:18:15 <Clint> sm: but there are other ways; https://tracker.debian.org/pkg/haskell-extra etc.
11:19:00 <sshack> Okay, sounds like I need to build inside docker.
11:19:48 <cocreature> right but you don’t have to manually mess around with docker for that, stack will just transparently call build your project using docker
11:29:18 <sm> thanks
11:29:39 <sm> (I tried searching packages.debian.org and repology)
11:30:42 <sm> oh tracker.debian.org is great. I can type a package name substring and see candidates
11:35:05 <sshack> cocreature Just need to figure out what to add to my stack.yml to get that to happen.
11:35:45 <cocreature> sshack: "docker: enable: true" should be sufficient or at least stack should complain at that point if something else is missing :)
11:45:15 * hackage influxdb 1.2.2.1 - Haskell client library for InfluxDB  https://hackage.haskell.org/package/influxdb-1.2.2.1 (MitsutoshiAoe)
11:49:51 <sshack> cocreature I have to reboot for a little snitch update, but I will try that the instant I get back.
11:50:17 * hackage sbp 2.3.2 - SwiftNav's SBP Library  https://hackage.haskell.org/package/sbp-2.3.2 (markfine)
11:56:15 * hackage http-types 0.11 - Generic HTTP types for Haskell (for both client and server code).  https://hackage.haskell.org/package/http-types-0.11 (AristidBreitkreuz)
12:10:03 <dminuoso> Is there a reason :: was chosen to denote "has type" ?
12:10:21 <dminuoso> The math papers and books Ive started reading all use : rather
12:10:57 <dminuoso> Is this possibly related to the fact that : is used as cons?
12:18:12 <Tuplanolla> The committee used to resolve conflicts by always accepting the first proposal, dminuoso.
12:18:55 <Tuplanolla> Although I do like the false etymology that Haskell was Lisp first and ML second.
12:19:42 <Tuplanolla> Someone just happened to suggest `::` first.
12:20:20 <mnoonan> dminuoso: Haskell inherited that wart from Miranda.
12:20:52 * hackage pidfile 0.1.0.2 - Run an IO action protected by a pidfile  https://hackage.haskell.org/package/pidfile-0.1.0.2 (petterb)
12:21:10 <sshack> cocreature Yup. You were right. Adding docker: enable: True gets me a new and exciting error message "Error: No such object: fpco/stack-build:lts-9.8"
12:21:30 <sshack> I've pulled the latest fpco/stackb-build docker image but no joy.
12:26:54 <cocreature> sshack: run "stack docker pull"
12:27:40 <sshack> Oww. This might work.
12:28:41 <cocreature> docker pull fpco/stack-build:lts-9.8 should work too
12:28:49 <cocreature> you don’t need the latest image, you need the one with the lts-9.8 tag
12:29:03 <lyxia> What is this type called:  data Thing f a where Thing :: f a -> (a -> b) -> f b
12:29:18 <lyxia> uh, f a -> (a -> b) -> Thing f b
12:29:28 <Tuplanolla> Looks like `Coyoneda` to me, lyxia.
12:30:20 <lyxia> Coyoneda looks flipped. (a -> b) -> f b -> Coyoneda f a
12:30:36 <Tuplanolla> The other `Coyoneda`.
12:30:44 <lyxia> Okay so there's another one.
12:31:04 <Tuplanolla> There's one for covariant and one for contravariant functors.
12:33:37 <shelljump> what is the most well-developed library for profunctor lenses?
12:33:46 <MarcelineVQ> Coco Yoneda, talented 70's star
12:34:36 <shelljump> I want to learn how to use lens. I have the category theory background but not much programming background.
12:34:59 <lyxia> Tuplanolla: Thanks!
12:36:10 <shelljump> the profunctor version looks a lot more comprehensible than Data.Lens
12:37:19 <lyxia> shelljump: purescript has a nice one. In Haskell there's the quite old mezzolens.
12:38:25 <shelljump> How big of a leap is it to go from haskell to purescript?
12:38:59 <shelljump> seems questionable to try to learn a new language and one of the most complex abstractions simultaneously
12:39:52 <shelljump> thanks for the info though :)
12:40:17 <lyxia> I think it's pretty small, especially if your motivation so far is to investigate lenses in particular.
12:45:43 <shelljump> ok thats good to hear, I'll check it out
12:45:51 <shelljump> thanks again
12:55:46 <Athas> Will Semigroup really become a superclass of Monoid in 8.4?
12:55:55 <Clint> i hope so
12:56:34 <sshack> cocreature Worked. I have an application that runs under docker. Thanks!
12:56:50 <Athas> So... if I want to write code that works in both 8.4 and 8.2, I will have to add a dependency on semigroups so I can define a Semigroup instance for the older compilers, too?
12:57:18 <Athas> Semigroup has a fairly large dependency footprint considering how simple it is.
12:57:28 <Athas> Oh, they can be disabled with flags.
12:58:45 <Athas> This will not be fun to deal with.
12:59:50 <MarcelineVQ> what footprint dear? it's in base, as anything that's a required superclass would be
13:00:10 <Athas> Oh, was the semigroups package already merged into base?
13:00:28 <Athas> Oh yes.
13:00:49 <Athas> I guess since GHC 8.0?  I suppose I can discard compatibility with the older releases.
13:00:54 <MarcelineVQ> idk about that wording specifically, but base has semigroups
13:04:43 <f-a> I need to convert a String to a valid haskell contructor (e.g. "foo" "Foo"). I suppose there are a bazillion functions doing it. Where to find them? In TH?
13:06:14 <mnoonan> f-a: you mean you need to convert it to a constructor, or to a string that has the right syntax to be a constructor?
13:07:20 <f-a> mnoonan: in the end, latter. I would like to write a datatype to a file
13:09:05 <mnoonan> https://hackage.haskell.org/package/names-th-0.2.0.3/docs/Language-Haskell-TH-Name-CamelCase.html (but it doesn't look particularly clever about unexpected characters)
13:09:16 <mnoonan> ..and you're sure you don't want to use Binary / Serializable?
13:10:15 <f-a> mnoonan: I don't know. This has to be put in another .hs to be read by ghc. is binary/serializable the way to go?
13:10:57 <infinisil> @pl a == b = (f a) == (f b)
13:10:57 <lambdabot> (line 1, column 9):
13:10:57 <lambdabot> unexpected " "
13:10:57 <lambdabot> expecting operator
13:11:07 <infinisil> @pl (==) a b = (f a) == (f b)
13:11:07 <lambdabot> (line 1, column 11):
13:11:07 <lambdabot> unexpected " "
13:11:07 <lambdabot> expecting operator
13:11:18 <infinisil> huh
13:11:43 <Tuplanolla> @pl \ a b -> f a == f b
13:11:43 <lambdabot> (. f) . (==) . f
13:12:00 <infinisil> ah, would've been my next attempt
13:12:12 <mnoonan> oh.. no, probably not. maybe you can use Typeable, though? I don't know this corner of the universe very well.
13:12:14 <mnoonan> http://chrisdone.com/posts/data-typeable
13:12:25 <mnoonan> ^ f-a
13:12:33 <Tuplanolla> There's a better way, infinisil.
13:12:54 <infinisil> :t liftA2 (==)
13:12:55 <lambdabot> (Eq a, Applicative f) => f a -> f a -> f Bool
13:13:26 <Tuplanolla> It's `on (==) f`.
13:13:36 <hexagoxel> :t \f -> (==) `on` f
13:13:37 <lambdabot> Eq a1 => (a2 -> a1) -> a2 -> a2 -> Bool
13:13:41 <infinisil> Oh sweet
13:13:57 <infinisil> thanks!
13:14:29 <f-a> thanks mnoonan , I'll read tht now
13:14:33 <woodson> Hi anyone have an example that shows how to deploy a haskell app to heroku?
13:14:57 <infinisil> Not sure if i like `(==) = on (==) f` more than `a == b = f a == f b` though
13:15:03 <woodson> I tried deploying my servant server using this https://github.com/mfine/heroku-buildpack-stack but im having problems
13:15:09 <infinisil> the former looks horrible
13:16:35 <EvanR> haskell mind blowing lesson: use variables to make things clearer
13:17:32 <infinisil> Whoaa
13:18:16 <infinisil> I'm gonna run @pl over my whole program before making it open source
13:18:33 <EvanR> sometimes you can even repeat yourself to make it clearer
13:19:00 <mnoonan> EvanR: ..but then you'll have to deal with one of the hardest problem in software engineering!
13:19:37 <EvanR> what, naming variables?
13:19:47 <mnoonan> exactly
13:19:48 <EvanR> not really right... see f a and b above
13:20:45 --- mode: glguy set -o glguy
13:22:42 * hackage crdt 4.0 - Conflict-free replicated data types  https://hackage.haskell.org/package/crdt-4.0 (cblp)
13:41:13 <lala_> > foldr (\x y -> x + 2*y) 0 [1,1,0,1] :: Expr
13:41:15 <lambdabot>  1 + 2 * (1 + 2 * (0 + 2 * (1 + 2 * 0)))
13:41:55 <lala_> > foldr (\x y -> x + 2*y) 0 :: Expr
13:41:57 <lambdabot>  error:
13:41:57 <lambdabot>      • Couldn't match expected type ‘Expr’
13:41:57 <lambdabot>                    with actual type ‘[Integer] -> Integer’
13:42:39 <lala_> > foldr (\x y -> x + y*2) 0 [1,1,0,1] :: Expr
13:42:41 <lambdabot>  1 + (1 + (0 + (1 + 0 * 2) * 2) * 2) * 2
13:43:30 <lala_> > foldr (\x y -> x + 2*y) 0 [1,1,0,1] :: Expr
13:43:32 <lambdabot>  1 + 2 * (1 + 2 * (0 + 2 * (1 + 2 * 0)))
13:47:53 <slack1256> What newtypes are interesting for their relation to Foldable and Traversable? Const, Alt, what else?
13:48:19 <slack1256> (I've always found programming by the correct newtype instance obscure, I never know the semantics of the instance by heart)
13:52:57 <phadej> the "basic" functors are all interesteting, Const as you mentioned, but also Compose and Identity
13:53:07 <phadej> List aka []
13:54:31 <rightfold> Product and Coproduct
14:00:16 * hackage ptr 0.16.2 - Abstractions for operations on pointers  https://hackage.haskell.org/package/ptr-0.16.2 (NikitaVolkov)
14:00:35 <lala_> can someone help me in lambdabot? i installed it in my computer. when i command lambdabot  i get command prompt with lambdabot> but how can i do what i do here, that it will show me what the function will do. like when i do this: foldr (\x y -> x + 2*y) 0 [1,1,0,1] :: Expr
14:01:35 <lala_> when id wriet this in there: foldr (\x y -> x + 2*y) 0 [1,1,0,1] :: Expr, i get this: Sorry, look up one word at a time please.
14:01:58 <lala_> id wriet = i write
14:07:55 <lyxia> lala_: what does lambdabot say when you try
14:08:24 <lyxia> lala_: you might need to install simple-reflect and set it up with lambdabot
14:10:29 <lala_> lyxia when i try what? :)
14:12:21 <lala_> lyxia i `stack install simple-reflect`. it took a second and i got back to shell. how i am i config ot to work with lambdabot?
14:12:52 <lala_> lyxia how to config it to work with lambdabot?
14:12:56 <lyxia> (Actually I read too fast, nevermind)
14:13:08 <lyxia> I have no idea, I never tried installing lambdabot.
14:13:17 <lala_> ah OK thanks :)
14:13:26 <lyxia> But the error you get suggests the prompt is doing something else
14:13:32 <lyxia> than evaluating haskell
14:19:05 <orion> I have a data type "Scopes" whose values represent the various OAuth permissions supported by Google's API. Each API call is associated with one or more minimum scopes. OAuth access tokens are associated with one or more scopes.
14:19:49 <orion> I would like to store in memory a data structure relating the set of scopes for an access token with the actual access token value.
14:19:54 <aberrant> not that this is useful, but I'm surprised read "5" :: String doesn't work.
14:20:10 <geekosaur> a String in Read-able format is quoted
14:20:27 <orion> I am thinking of using "Map (Set Scope) AccessToken" for this.
14:20:33 <orion> Is there a more efficient way of going about this?
14:20:36 <geekosaur> > read "\"5\"" :: String
14:20:38 <lambdabot>  "5"
14:20:50 <aberrant> oooh.
14:21:10 <aberrant> thanks.
14:23:23 <infinisil> Oh my god, I rewrote this server in haskell like 4 times now, and I think I finally got a solution that works nicely
14:23:32 <slack1256> I don't understand the many/some methods of Alternative outside parser combinators
14:23:49 <slack1256> what should `many [5]` do?
14:29:08 <beemo[m]> slack1256: me neither
14:29:18 <geekosaur> slack1256, a common complaint about many and some is that they don't make much sense at all outsie of parser combinators
14:33:37 <beemo[m]> I remember using it with megaparsec (i think that re-exports them)
14:34:12 <beemo[m]> >:t many
14:35:46 <beemo[m]> > many (Just 5)
14:35:49 <lambdabot>  *Exception: <<loop>>
14:36:05 <zachk> can I do pattern matching inside a lambda (\x -> etc.) ?
14:36:21 <sbrg> yep
14:36:29 <beemo[m]> Yes (/(Just x) -> x)
14:36:30 <sbrg> > (Just x -> x) (Just 4)
14:36:32 <lambdabot>  error:
14:36:32 <lambdabot>      Pattern syntax in expression context: Just x -> x
14:36:36 <sbrg> oops <.<
14:36:43 <sbrg> > (\(Just x) -> x) (Just 4)
14:36:46 <lambdabot>  4
14:37:55 <zachk> with multiple patterns even
14:38:15 <zachk> > (\(Just x) -> x) Nothing
14:38:18 <lambdabot>  *Exception: <interactive>:3:2-15: Non-exhaustive patterns in lambda
14:38:24 <sbrg> zachk: you can do case
14:38:28 <beemo[m]> Haha
14:38:37 <zachk> the lambdaCase extension? 
14:38:54 <sbrg> > (\x -> case x of (Just v) -> v; _ -> 3;) (Just 4)
14:38:56 <lambdabot>  4
14:39:05 <sbrg> not sure how lambdacase works with multiple cases
14:39:07 <sbrg> but possibly, yes
14:39:45 <beemo[m]> > maybe id 4 (Just 1)
14:39:48 <lambdabot>  error:
14:39:48 <lambdabot>      • Could not deduce (Num a0)
14:39:48 <lambdabot>        from the context: (Num (a -> a1 -> a1), Num a)
14:40:03 <beemo[m]> Is maybe better in that case, if i typed it right
14:40:54 <beemo[m]> > maybe 4 id (Just 5)
14:40:56 <lambdabot>  5
14:41:02 <sbrg> :t fromMaybe -- beemo[m] 
14:41:03 <lambdabot> a -> Maybe a -> a
14:41:14 <sbrg> instead of `maybe _ id`
14:41:45 <beemo[m]> That looks better thanks
14:41:59 <zachk> can I use a bound variable inside of a pattern match?
14:42:53 <sbrg> as in: let a = 1 in (\a -> 1) .. ? 
14:43:06 <sbrg> so `a` in the lambda is equivalent to `1`? 
14:43:12 <sbrg> if so, nope, unfortunately
14:43:16 <zachk> yea was thinking more about matching over "relations" sort of ala prolog 
14:43:17 <zachk> :(
14:43:41 <sbrg> You can kindof do it with viewpatterns
14:44:05 <sbrg> > let is4 n = n == 4 in (\(is4 -> True) "yes") 4
14:44:08 <lambdabot>  <hint>:1:44: error: parse error on input ‘)’
14:44:16 <sbrg> > let is4 n = n == 4 in (\(is4 -> True) "yes") -> 4
14:44:19 <aberrant> "All tuples are also part of Bounded if the components are also in it." <- this seems very powerful.
14:44:19 <lambdabot>  <hint>:1:44: error: parse error on input ‘)’
14:44:19 <sbrg> jesus.
14:44:48 <beemo[m]> If a == 1 then ... Would work but might not be what you're looking for
14:45:05 <MarcelineVQ> > maxBound :: (Int, Word) -- hmm
14:45:08 <lambdabot>  (9223372036854775807,18446744073709551615)
14:45:52 <beemo[m]> Is a tulple instance of bounded
14:46:15 <sbrg> > let eq a b = a == b; n = 4 in (\(eq n -> True) "yes") 4
14:46:17 <lambdabot>  <hint>:1:53: error: parse error on input ‘)’
14:46:30 <sbrg> i give up
14:46:35 <sbrg> anyway, take a look at viewpatterns
14:47:26 <zachk> thank you
14:50:42 <hpc> > let f (null -> True) = "test" in f []
14:50:44 <lambdabot>  "test"
14:50:49 <hpc> > let f (null -> True) = "test" in f "test"
14:50:51 <lambdabot>  "*Exception: <interactive>:3:5-29: Non-exhaustive patterns in function f
14:51:04 <hpc> odd
14:52:32 <hpc> oh
14:52:50 <hpc> > let is4 n = n == 4 in (\(is4 -> True) -> "yes") 4
14:52:53 <lambdabot>  "yes"
14:53:39 <zachk> hpc: is that a view pattern?
14:53:45 <hpc> yeah
14:54:20 <hpc> in a pattern of the form (view -> pattern), it applies the view function to the parameter in that position, then pattern matches on the result
14:54:45 <Wizek> Is it possible to have a State monad without a return value? `newtype State s = State (s -> s)` Or do the monad laws prevent such?
14:55:02 <hpc> Wizek: the kind of State prevents it
14:55:05 <hpc> :k State
14:55:06 <lambdabot> * -> * -> *
14:55:11 <hpc> State has to take two type parameters
14:55:42 <hpc> (to become a type that you can make values of, anyway)
14:56:16 <Wizek> hpc: As defined in, say the `mtl` package yes, but I am thinking if we would define our own State datatype
14:56:26 <Wizek> hpc: like so: `newtype State s = State (s -> s)`
14:56:28 <hpc> ah
14:56:45 <hpc> you can define that type, sure
14:56:45 <exio4> making it a monad sounds hard
14:56:53 <hpc> not sure if you can write a Monad instance for it
14:56:57 <exio4> I am thinking of newtype State s a = State (s -> s) 
14:57:01 <hpc> and it definitely doesn't express stateful computation
14:57:16 <Wizek> hpc: doesn't it?
14:57:37 <exio4> Wizek: it represents an Endo (in Data.Monoid)
14:59:13 <Wizek> exio4: That's fair. But would it perhaps be fair to say that with such a definition some stateful computations could be expressed, but not others?
14:59:27 <Wizek> exio4: likely linear ones without loops and branches, I guess
15:00:05 <Guest72929>  youtube.com/watch?v=u6-zpIm9uno
15:00:10 <hpc> it would be a stretch to say that type helps you with it, i think
15:00:20 <aberrant> (x:xs) confuses the heck out of me
15:00:24 <hpc> technically you can
15:00:25 <aberrant> as a pattern
15:00:31 <aberrant> I always type [x:xs]
15:00:49 --- mode: ChanServ set +o glguy
15:00:49 --- mode: ChanServ set +o glguy
15:00:50 --- mode: glguy set +q *!*@185.143.40.133
15:01:16 <Wizek> exio4: Also, then, would it be fair to rephrase my question as: Is it possible to have a Monad instance for Endo?
15:01:37 <zachk> this seems to work fine let y = 0 in filterJust (\x -> case x of (Location x z) | z == y -> Just x ; _ -> Nothing) world
15:02:07 <hpc> aberrant: you probably need to just drill the type of (:) into your brain and write list-processing functions until it becomes normal-looking
15:02:32 <aberrant> hpc: yeah, more practice is definitely warranted.
15:02:54 <hpc> i never acquired that habit, but i have seen a lot of people come through here who have
15:03:27 --- mode: glguy set -q+b *!*@185.143.40.133 *!*@185.143.40.133
15:03:28 <aberrant> well, in other languages, [x:y] means something specific, PLUS you're dealing with a list, so brackets seem appropriate.
15:03:30 <hpc> so i couldn't help on whatever bit of brain stuff creates that idea
15:03:34 <aberrant> () is for tuples
15:03:46 <hpc> ah, maybe
15:03:56 <hpc> i always saw it as () for grouping, (,) for tuples
15:04:02 <hpc> (:) for lists
15:04:02 <geekosaur> () is only for tuples with ,
15:04:10 <aberrant> either brackets or no parens, but () seems strange.
15:04:14 <geekosaur> () with : is just parenthesization
15:04:21 <geekosaur> i.e. precedence
15:04:23 <hpc> and if you need to use [x, y, z] in a pattern, you're doing it wrong
15:04:25 <aberrant> why are parentheses needed?
15:04:44 <hpc> for parsing
15:04:44 <exio4> Wizek: Endo has a in both a negative and a positive position, so it cannot even have a functor instance :) 
15:04:57 <geekosaur> because patterns parse the same way expressions do
15:04:58 <hpc> the pattern match needs to be one "expression" so to speak
15:05:10 <geekosaur> foo x:y means (foo x):y
15:05:12 <aberrant> hpc: well, yes, but what is the specific ambiguity that it's fixing?
15:05:15 <aberrant> OH.
15:05:20 <aberrant> that's it.
15:05:38 <hpc> > Just Just 5
15:05:39 <aberrant> thank you. That will help me fix this bad habit
15:05:41 <lambdabot>  error:
15:05:41 <lambdabot>      • Couldn't match expected type ‘Integer -> t’
15:05:41 <lambdabot>                    with actual type ‘Maybe (a0 -> Maybe a0)’
15:05:43 <hpc> > Just (Just 5)
15:05:45 <lambdabot>  Just (Just 5)
15:05:47 <Wizek> exio4: interesting. I guess I'm finally starting to have some bits of intuition for this, as that starts to sound like it makes sense :D
15:06:08 <aberrant> I haven't gotten to Just yet. :)
15:06:45 <hpc> you'll enjoy it if you've ever seen something return an unexpected null
15:07:02 <aberrant> havent had to deal with nulls in a long time.
15:07:08 <bonsairoot> hello. I'm new and trying to set up my dev environment. I need hlint but the installation fails on one of its dependencies: https://pastebin.com/dtmAMMCS GHC version: 7.10.3 
15:08:39 <koz_> Maybe is an amazing idea.
15:09:58 <hpc> koz_: it's nice that it's the simplest example of something you can't do with just struct and enum too, which is sort of funny
15:10:14 <EvanR> Maybe is ok, but NOT maybe is an even better idea
15:10:25 <EvanR> i.e. value has to be there
15:10:33 <zachk> > (,) <$> Just "hello" <*> Just "World"
15:10:36 <lambdabot>  Just ("hello","World")
15:10:54 <zachk> > (,) <$> Nothing <*> Just "World"
15:10:57 <lambdabot>  Nothing
15:11:30 <koz_> hpc: Yeah, it's a very simple illustration of the coolness of algebraic data types, too.
15:11:51 <koz_> (I also find it a good demo of the intuition behind Functor, Applicative and Monad)
15:13:10 <EvanR> next challenge, how do you explain the utility to someone familiar with lisp
15:13:26 <koz_> EvanR: You don't?
15:13:37 <EvanR> challenge declined?
15:13:48 <koz_> EvanR: Challenge not deemed relevant to my current interests. :P
15:14:01 <sbrg> those guys love their nil punning
15:14:12 <koz_> sbrg: Common Lispers yes. Schemers disagree.
15:14:30 <aplainzetakind> I'd welcome some library advice. I'm working on an ear training program which will quiz the user to identify programmatically generated musical entities. I've got fluidsynth working, which has noteOn and noteOff functions to trigger and stop instrument samples. However, I feel dealing with note durations with stuff like threadDelay inbetween noteOn and noteOff is pretty lame. Would FRP libraries 
15:14:36 <aplainzetakind> like reactive banana let me fire up noteOn together with a noteOff in a prescribed future time? (I'll probably use some sort of FRP to deal with getting answers in specific time windows anyway). As is probably obvious, I'm not familiar with FRP yet, I'll start looking into it.
15:17:01 <bigos> How do I modify cabal so it uses different folders than standard?
15:18:24 <bonsairoot> I don't get the error on cabal install... I unpacked the package and checked the file and it has Data.Char isUpper imported
15:19:11 <geekosaur> bonsairoot, that looks like a fairly old, non-updated library
15:19:35 <glguy> bonsairoot: Data.Char isn't the same as Char
15:19:40 <geekosaur> unless it is importing Data.Char 'qualified as Char', it's using flat Haskell98 namespace instead of the Haskell2010 hierarchical namespace
15:20:53 <glguy> hscolour-1.24.3 was released yesterday and doesn't appear to build on any versions of GHC
15:21:09 <bonsairoot> @geekosaur I just saw bug reports https://hackage.haskell.org/package/hscolour-1.24.3/reports/1
15:21:09 <lambdabot> Unknown command, try @list
15:21:29 <glguy> Give 1.24.2 a shot
15:21:30 <bonsairoot> glguy, yea I just saw 3 reports with the same error
15:22:36 <geekosaur> ugh, hscolour? would have expected that to be up to date unless you are using an ancient version somehow
15:23:06 <bonsairoot> glguy, geekosaur ok works with 1.24.2 manual install Thanks
15:23:18 <geekosaur> ok, this is weird. that should have started failing, uh, somethig like 6 years ago
15:23:25 <geekosaur> unless someone thinkoed
15:23:39 <geekosaur> 1.24.2 works, yeh, just checked on hackage. think so meone had a braino
15:23:43 <bonsairoot> geekosaur, it's just the newest from 28th november that fails I think
15:24:03 <geekosaur> --constraint 'hscolour == 1.24/2
15:24:04 <geekosaur> er
15:24:09 <geekosaur> --constraint 'hscolour == 1.24.2'
15:24:33 <bonsairoot> yea I installed 24.2 first then hlint and it works
15:24:57 <geekosaur> riufght, that's the cabal (and stack I think) option to force it without manual install
15:26:05 <bonsairoot> ok good to know
15:28:43 <Maticz> Hey guys I'm wondering what the best way is to get command line arguments as a list of Int's instead of Strings
15:29:04 <EvanR> best way?
15:29:32 <exio4> Maticz: what do you want to do if one isn't a string?
15:30:40 <Maticz> EvanR, yes the fastest/concise way without much code or list transforming
15:30:49 <EvanR> > map read ["1", "2", "3"]
15:30:51 <lambdabot>  [*Exception: Prelude.read: no parse
15:30:55 <EvanR> > map read ["1", "2", "3"] :: [Int]
15:30:58 <lambdabot>  [1,2,3]
15:31:06 <exio4> Maticz: I can think of (map read <$> getArgs) ((catMaybes . map readMaybe) <$> getArgs) and ((sequence . map readMaybe) <$> getArgs)
15:31:18 <hexagoxel> aplainzetakind: reactive-banana is a bit short on some utility functions like the one you probably could use there ("delay event").
15:31:41 <exio4> depending on what you want, 1st one crashes and gives you an [Int] directly, the second returns an [Int], ignoring invalid values
15:32:03 <exio4> and the third one gives you a Maybe [Int] - either all were integers, or some read failed
15:32:18 <Maticz> the this is that I want them the arguments to bind as such: (s:m:g:t:w:p:l:ll) <- getArgs, but I want these bindings to be of tipe Int
15:32:27 <hexagoxel> aplainzetakind: you probably need to describe the desired behaviour in more detail if you want more specific FRP design advice.
15:33:04 <EvanR> (s:m:g:t:w:p:l:ll) <- fmap read getArgs
15:33:06 <exio4> Maticz: [(s:m:g:t:w:p:l:ll) <- map read <$> getArgs -- is the simplest I can think of, if you don't mind your program crashing (which it will do if you don't send enough params)
15:33:12 <exio4> EvanR: that won't work :)
15:33:20 <exio4> @type getArgs
15:33:21 <lambdabot> error: Variable not in scope: getArgs
15:33:29 <EvanR> (s:m:g:t:w:p:l:ll:[]) <- fmap read getArgs
15:33:29 <exio4> getArgs :: IO [String] 
15:33:52 <exio4> @type read 
15:33:53 <lambdabot> Read a => String -> a
15:33:56 <exio4> takes a String, not a [String]
15:34:00 <exio4> needs another map 
15:34:08 <EvanR> (s:m:g:t:w:p:l:ll:[]) <- fmap (map read) getArgs
15:34:16 <exio4> that works :D 
15:34:31 <EvanR> [s,m,g,t,w,p,l,ll] <- fmap (map read) getArgs
15:34:34 <exio4> if you are doing (a:b:c:d:[]) I would use [a,b,c,d] though
15:34:45 <EvanR> and if anything goes wrong, all bets are off
15:34:52 <Maticz> thats alot that did it :D
15:34:57 <Maticz> thanks
15:35:22 <exio4> EvanR: you are already assuming the number of parameters in that code, so it's fine I guess to crash if another invariant which is barely tougher also fails :p 
15:35:23 <EvanR> fast and loose is morally correct
15:36:03 <EvanR> this is haskell, screw soundness we just want to get work done
15:36:31 <EvanR> lessons you thought haskell might never teach anybody!
15:39:39 <aplainzetakind> hexagoxel: The desired behaviour is the following. In the most basic form the program will generate a sequence of notes, play them (each having separate noteOn and noteOff events), then wait for a prescribed period for the user to click on multiple choices, then display the correct answer.
15:40:26 <aplainzetakind> The playing of the notes will depend on a tempo parameter for duration.
15:40:33 <aplainzetakind> But that's irrelevant.
15:41:53 <aplainzetakind> Basically, when I call noteOn on a note, I want the noteOff in a prescribed future time bundled with it in a clean way.
15:42:19 <toblorone> dumb question: whats the haskell equivalent of this using something from Foldable? https://pastebin.com/b5xeKsDZ 
15:44:02 <aplainzetakind> toblorone: [(n,n-1) | n <- [0..9]]
15:44:59 <toblorone> not using list comprrehension : )
15:45:45 <toblorone> oh duh
15:45:47 <toblorone> nvm
15:45:49 <toblorone> fmap
15:46:38 <aplainzetakind> foldr (\n l -> (n,n-1):l) [] [0..9]
15:47:22 <exio4> let xs = [0..9] in zip xs (map (substract 1) xs)
15:48:56 <geekosaur> (\x -> zip (tail x) x) [0..10]
15:48:59 <geekosaur> er
15:49:02 <geekosaur> > (\x -> zip (tail x) x) [0..10]
15:49:04 <lambdabot>  [(1,0),(2,1),(3,2),(4,3),(5,4),(6,5),(7,6),(8,7),(9,8),(10,9)]
15:49:52 <geekosaur> (haskell smartass version...)
15:50:32 <hololeap> does anyone have experience with the fgl package? i'm trying to make a very basic graph with a loop and test it, but hasLoop always returns False
15:50:34 <hololeap> http://lpaste.net/8826714953617506304
15:53:26 <hexagoxel> aplainzetakind: you probably end up using threadDelay either way. the ugly approach is reactimating on a "note" event by forking a thread that does on, delay, off. alternatively, you could have a global tick/timer (like usual for midi) and have some Map/Queue from global tick to (midi) events to fire.
15:55:28 <hexagoxel> the latter approach gives more control regarding ordering/relative positioning of on/off events, and is conceptually simpler.
15:57:11 <jle`> :t zip`ap`tail
15:57:12 <lambdabot> [a] -> [(a, a)]
15:57:23 <geekosaur> it gets worse
15:58:20 <geekosaur> > (zip =<< tail) [0..10]
15:58:22 <lambdabot>  [(1,0),(2,1),(3,2),(4,3),(5,4),(6,5),(7,6),(8,7),(9,8),(10,9)]
16:00:03 <aplainzetakind> hexagoxel: OK, I'm quite inexperienced, so any sources/examples to study on the usual midi way of having a global timer would be very helpful.
16:03:29 <hexagoxel> aplainzetakind: have you ever looked at the "event list" representation of midi? it is the midi format itself, really - of course most editors don't show this raw data by default.
16:03:36 <Axman6> hololeap: if ivanm were around, he's be the right person to ask, but doesn't look like he is
16:04:13 <hololeap> Axman6, i see what it is... hasLoop only detects edges of the type (A,A), not larger cycles in the graph
16:04:30 <Axman6> makes sense :)
16:04:38 <Axman6> I guess loops differ from cycles
16:05:50 <hexagoxel> aplainzetakind: i'll take this to pm if you don't mind..
16:07:14 <aplainzetakind> hexagoxel: sure
16:11:00 <paws_> hi. Can anyone recommend an smtp library with TLS support, to use smtp.gmail.com for example?
16:11:16 <pikajude> now i've forgotten, what do I do about this GHC error? https://gist.github.com/pikajude/31357facf57914502df64ce8f1d343cb
16:11:21 <pikajude> I have to add something to a cabal file I think
16:14:35 <crucify_me> hi this generalized notation is from a book. how to write it better so I can sort of the foldables once and for all?
16:14:37 <crucify_me> http://lpaste.net/360362
16:14:48 <crucify_me> *out
16:15:49 <crucify_me> they are hard to read, esp. vis a vis the lambda expressions.
16:15:53 <MarcelineVQ> @src foldr
16:15:53 <lambdabot> foldr f z []     = z
16:15:53 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
16:15:55 <MarcelineVQ> @src foldl
16:15:55 <lambdabot> foldl f z []     = z
16:15:55 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
16:16:28 <MarcelineVQ> that's about as succinct as it gets in terms of how to write it, as it's the definition
16:17:30 <pikajude> all the google results for this error are regarding GHC 7.7
16:17:33 <pikajude> or earlier ???
16:17:54 <crucify_me> thanks, yeah MarcelineVQ I'm a bit confused about '\_ n '    vs.   ' \n _ '
16:17:56 <MarcelineVQ> not sure why a book would want to show it to you in an obscure way with that #
16:18:20 <MarcelineVQ> the answer to that is the types
16:18:21 * hackage preamble 0.0.54 - Yet another prelude.  https://hackage.haskell.org/package/preamble-0.0.54 (markfine)
16:18:23 <glguy> pikajude: Is it more complicated than just needing to put the module in one of exposed-modules or other-modules?
16:18:51 * geekosaur was thinking the .dyn_o was relevant?
16:18:58 <MarcelineVQ> crucify_me: ask ghci the type of foldr and foldl then tell me what is different about them
16:19:00 <pikajude> glguy: since it's an executable, not a library, maybe?
16:19:06 <pikajude> i've only seen this with libraries before
16:19:14 <crucify_me> ok
16:20:08 <geekosaur> crucify_me, I think at some point you are going to have to learn how to read that. the world isn't going to rewrite all its lambdas
16:21:39 <zachk> is there a simpler way to descriptionsLocated in this code http://lpaste.net/360364 ?
16:24:44 <glguy> :t mapMaybe
16:24:45 <lambdabot> (a -> Maybe b) -> [a] -> [b]
16:25:36 <glguy> zachk: A list comprehension might look nicer: [ a | Location a b <- world, b == location ]
16:26:12 <MarcelineVQ> crucify_me: do you know how to ask ghci the type of something?
16:29:57 <crucify_me> MarcelineVQ: sorry I was detained. yes sure :t 
16:30:37 <paws_> oh, found an example https://github.com/dpwright/HaskellNet-SSL/blob/master/examples/gmail.hs
16:31:11 <crucify_me> MarcelineVQ: I'm still unsure about how to get the full definition of say foldl from hackage et al
16:31:37 <crucify_me> geekosaur:  thanks I can sort of read the foldr . the two side by side are a bit confusing
16:31:38 <shapr> @src foldl
16:31:38 <lambdabot> foldl f z []     = z
16:31:38 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
16:31:42 <MarcelineVQ> that's not relevant to the task here
16:31:45 <shapr> crucify_me: install your own lambdabot
16:32:08 <crucify_me> you can do that?
16:32:10 <crucify_me> shapr
16:35:03 <crucify_me> should I use cabal for that or can I use stack ?
16:36:03 <zachk> thanks glguy
16:36:36 <tabemann> @src foldl'
16:36:36 <lambdabot> foldl' f a []     = a
16:36:36 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
16:37:02 <jxv> :t fmap fmap fmap fmap fmap fmap fmap fmap
16:37:04 <lambdabot> (Functor f3, Functor f2, Functor f1) => (a -> b) -> f1 (f2 (f3 a)) -> f1 (f2 (f3 b))
16:37:36 <jxv> some days I feel like that ^
16:40:55 <crucify_me> shapr hey is that also known as GOA  ?
16:41:51 <jxv> crucify_me you can pm lambdabot directly
16:42:35 <crucify_me> \lambdabot GOA
16:42:40 <crucify_me> sorry
16:42:57 <rotaerk> do you know how to PM in IRC? :P
16:43:26 <crucify_me> yeah I said sorry
16:48:18 * hackage preamble 0.0.55 - Yet another prelude.  https://hackage.haskell.org/package/preamble-0.0.55 (markfine)
16:50:18 <orion> I want to compute the intersection of all the Sets within "Set (Set a)". I initially wanted to use Set.foldl' for this purpose, but I don't know what the starting value/identity element should be. I suppose I could make it the union of all the Sets, but is there a better way?
16:50:46 <hpc> does it have foldl1'?
16:51:15 <hpc> (it would error on an empty set, otherwise the first element is picked from one in the set)
16:52:13 <orion> no. :(
16:54:22 * hackage cborg 0.2.0.0 - Concise Binary Object Representation  https://hackage.haskell.org/package/cborg-0.2.0.0 (BenGamari)
16:54:30 <rotaerk> orion, think of this:  what's the intersection of all sets in an empty set
16:55:19 * hackage serialise 0.2.0.0, cbor-tool 0.2.0.0, cborg-json 0.2.0.0 (BenGamari): https://qbin.io/oqhfaqlr
16:56:21 * hackage binary-serialise-cbor 0.2.0.0 - Yet Another Binary Serialisation Library (compatibility shim)  https://hackage.haskell.org/package/binary-serialise-cbor-0.2.0.0 (BenGamari)
16:56:58 <orion> rotaerk: Set.empty
16:57:48 <rotaerk> that's inconsistent
16:58:49 <jle`> orion: you want the identity of intersection
16:59:03 <rotaerk> if x is an element of the intersection, that's equivalent to saying that x is an element of every set being intersected
16:59:06 <jle`> the set where z `intersection` x = x
16:59:18 <orion> jle`: Yes.
16:59:20 <jle`> the empty set is definitely not that set
16:59:26 <orion> Right.
16:59:30 <jle`> since empty `intersection` x = empty
16:59:37 <orion> Yup, I see.
16:59:38 <rotaerk> and if you intersect no sets, then it's true that x is an element of all sets being intersected, for all x
16:59:53 <rotaerk> so the identity is the set of ... everything
17:01:21 <orion> The ##math people told me, "the universe".
17:02:08 <orion> That's why I said I was thinking that I might need to first compute the union of all the sets within the set and use that as my starting value.
17:02:17 <orion> But I wasn't sure if there was a better way.
17:03:12 <rotaerk> orion, I'd suggest requiring a non-empty set-of-sets as input, get the first (arbitrary) element from it and use that as the seed for the fold, and what you pass into the fold is the set of *remaining* sets
17:04:18 <rotaerk> that or accept a possibly-empty set, and return Maybe (Set a), where Nothing is the result when the input set is empty
17:05:17 <rotaerk> but I'd prefer the former, since you shouldn't have to handle the Nothing case when it's entirely determinable based on what you're passing into it
17:05:37 <rotaerk> https://hackage.haskell.org/package/non-empty-0.3/docs/Data-NonEmpty-Set.html#t:T
17:05:41 <rotaerk> looks like this is a thing ...
17:07:00 <rotaerk> also since you're doing a *set* of sets, wouldn't that be (potentially-expensively) checking for uniqueness?
17:07:11 <rotaerk> a list of sets might be better
17:07:18 <rotaerk> NonEmpty list, even
17:08:03 <orion> Good point.
17:09:14 <crucify_me> any way to install lambdabot with stack?  
17:10:31 <mud> Well, you can try 'stack install lambdabot'. Last I heard, lambdabot was pretty tricky to acutally get going though, so I don't know if it'll work.
17:10:50 <mud> Why do you actually need it? Most of what it can do, ghci can do at least as well, and the rest you can just /msg lambdabot
17:11:03 <rotaerk> was wondering the same thing
17:11:09 <geekosaur> was recommended earlier
17:11:39 <crucify_me> yeah but I don't how to use irc very well
17:12:01 <crucify_me> I can't keep track of all this shit
17:28:43 * hackage preamble 0.0.56 - Yet another prelude.  https://hackage.haskell.org/package/preamble-0.0.56 (markfine)
17:31:43 * hackage miso 0.10.0.0 - A tasty Haskell front-end framework  https://hackage.haskell.org/package/miso-0.10.0.0 (DavidJohnson)
17:39:56 * hackage mattermost-api 40400.0.0 - Client API for Mattermost chat system  https://hackage.haskell.org/package/mattermost-api-40400.0.0 (gdritter)
17:41:28 * hackage mattermost-api-qc 40400.0.0 - QuickCheck instances for the Mattermost client API library  https://hackage.haskell.org/package/mattermost-api-qc-40400.0.0 (gdritter)
17:42:08 <alhariel> yeah ive tried installing lambdabot with stack too, no success
17:42:40 * hackage matterhorn 40400.0.0 - Terminal client for the Mattermost chat system  https://hackage.haskell.org/package/matterhorn-40400.0.0 (gdritter)
18:39:54 * hackage search-algorithms 0.3.0 - Common graph search algorithms  https://hackage.haskell.org/package/search-algorithms-0.3.0 (devonhollowood)
18:49:09 <GoGetter> I'm making a game in haskell and I'm having trouble finding a good gui for it
18:49:38 <GoGetter> I tried using reflex but it didn't install, neither did reactive banana. I switched to threepenny gui, but I'm having trouble with the documentation
18:49:43 <amosbird> hello, how can I fix this    cabal: cannot configure cabal-install-2.0.0.0. It requires base >=4.5 && <5  ?
18:50:29 <mud> amosbird: Sounds like you're using the wrong version of GHC
18:50:49 <amosbird> ok, i'm stuck in centos 6. is there a way to fix this?
18:50:55 <mud> GoGetter: For reflex you should use the reflex-platform stuff from their docs, it works well.
18:51:16 <mud> amosbird: Install GHC yourself? Or stack can do it if you want to go that way (for its own use mostly)
18:51:41 <amosbird> i just want this to work though :)   cabal install ShellCheck
18:52:12 <GoGetter> has anyone tried using another language for GUI glued to haskell?
18:52:27 <GoGetter> I was thinking of using elm but I'm not sure how I would approach it with haskell for the logic of the game
18:52:56 <mud> amosbird: Well, if it's just an executable, it's pretty painless to use stack then. 'stack install --install-ghc ShellCheck' should just work most likely. But it'll require installing stack, so up to you if that's easier than installing GHC yourself and whatever else.
18:54:23 <amosbird> thanks
18:54:48 <amosbird> what are the flagship projects in haskell?
18:55:24 <lyxia> pandoc?
18:58:22 <amosbird> ok, it seems most of the successful haskell projects are parsers 
19:03:45 <Hijiri> does GHC count
19:03:47 <Hijiri> as a flagship haskell project
19:05:50 <GoGetter> elm has a lot of haskell
19:11:58 <vaibhavsagar> GoGetter: https://hackage.haskell.org/package/threepenny-gui
19:13:41 <GoGetter> vaibhavsagar: Thanks, that's what I've been trying to use. I'm having trouble mapping my internal data structures to the gui, and the documentation is a bit difficult for me since I'm new to the language. I need to draw rectangle tiles on a game board, but that itself is taking me a while to figure out 
19:55:06 <duncan^> Ac/bu29
19:56:51 <pikajude> the correct answer to my question was "add TemplateHaskell to other-extensions"
21:40:41 * hackage rtcm 0.2.11 - RTCM Library.  https://hackage.haskell.org/package/rtcm-0.2.11 (markfine)
21:52:43 <Guest20253> @help
21:52:43 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
21:53:36 <jle`> amosbird: parsers is indeed one of the 'killer apps' of haskell
21:53:40 <jle`> and compilers
21:53:47 <jle`> it's just so natural to write
21:54:08 <jle`> a parser is often one of the beginner exercises when learning the language
21:54:19 <jle`> and compilers/interpreters next
21:54:42 <Welkin> jle`: for more realistic applications that you will be writing all the time, web apps
21:55:18 <Welkin> haskell is king for web servers
21:55:32 <Welkin> and even for client-side apps more recently using ghcjs (and getting better)
22:07:27 <saurabhn_> what's the gold standard for consistently formatting Haskell code?
22:08:40 <Lokathor> 4 spaces
22:10:07 <saurabhn_> I meant tool, like gofmt or something
22:10:18 <jle`> there's no canonical tool like in go
22:10:23 <jle`> there are a couple of useful ones
22:10:35 <jle`> but haskell formatting doesn't have a ting that everyone follows
22:10:43 <Lokathor> go and rust made a tool early in their life. Haskell has lived too long
22:10:58 <saurabhn_> jle`: want to standardize it for our code-base to avoid any bike-shedding.
22:11:56 <Lokathor> saurabhn_, has it come up as a problem? I've seen a lot of Haskell pastes in this channel from various skill levels and the style is similar enough that i almost never care
22:13:44 <saurabhn_> Lokathor: yup... I'm spending unnecessary time in code-reviews telling newbies to fix indentation, or variable naming
22:14:06 <saurabhn_> some stuff has been handled by hlint, but it doesn't handle stylistic issues
22:14:12 <Lokathor> wild
22:14:32 <Lokathor> I guess you'll have to go classic style: write out some guidelines on how things should be formatted
22:15:03 <cocreature> ime hindent is the best we have but it’s also not nearly good enough to enforce its usage
22:20:45 <rightfold> Such tools are an offense to my ability to judge readability
22:22:40 * hackage gnss-converters 0.3.24 - GNSS Converters.  https://hackage.haskell.org/package/gnss-converters-0.3.24 (markfine)
22:22:43 <saurabhn_> cocreature: why would you say it's not mature enough to enforce?
22:23:19 <cocreature> because the output often looks quite ugly
22:23:41 <cocreature> and it also throws away comments in some case although that seems to have gotten better
22:23:48 <saurabhn_> cocreature: no way to configure it according to individual tastes?
22:23:52 <cocreature> no
22:24:13 <saurabhn_> hfmt seems like a unified wrapper over three tools -- hlint, stylish-haskell, and hindent
22:25:51 <saurabhn_> and the underlying 3 tools seem to have **some** configurability
22:26:04 <jle`> if bikeshedding at a company is the main thing then i wouldn't look for a universally accepted haskell thing, just one that works decently for your own project
22:26:10 <saurabhn_> but they seem to be limited. eg: https://github.com/jaspervdj/stylish-haskell#features
22:26:38 <saurabhn_> jle`: that was the idea. Take a standard tool and customise it to what works for us. Just did that for hlint and seeing acceptable results.
22:31:20 <andrei> Is it possible to write something like? (Monad m, Traversable f) => (m a -> m b) -> m (f a) -> m (f b)
22:34:46 <opqdonut> :t \op m -> m >>= traverse (op . return)
22:34:47 <lambdabot> (Monad m2, Monad m1, Traversable t) => (m2 a -> m1 b) -> m1 (t a) -> m1 (t b)
22:34:53 <opqdonut> andrei: see above
22:35:37 <opqdonut> you're not getting any more power with that type than with just using traverse
22:36:56 <andrei> opqdonut: Thanks! I should have seen that
22:37:53 <opqdonut> @pl \op m -> m >>= traverse (op . return)
22:37:53 <lambdabot> (=<<) . traverse . (. return)
23:06:21 <saurabhn_> does anyone know the core differences between HTF & tasty? From their Hackage intros, both of them seem to be solving the same problem. 
23:12:15 * hackage bytestring-handle 0.1.0.6 - ByteString-backed Handles  https://hackage.haskell.org/package/bytestring-handle-0.1.0.6 (GaneshSittampalam)
23:13:13 <osa1> oh wow yet another testing framework. testing-framework, hspec, tasty, now HTF
23:15:04 <osa1> s/testing-framework/test-framework
23:18:36 <rightfold> YATF
23:20:28 <saurabhn_> i thought test-framework and HTF were the same project!
23:23:43 <dminuoso> Im trying to figure out this (.) . (.) combinator, but Im stuck understanding why Im getting two different error messages for what seems to be the exact same code: https://gist.github.com/dminuoso/cf7d8f5a3c7ba57d33fe4c71309a6a49
23:24:28 <olligobber> Options: Learn how to install and use a haskell package, or use System.Process readProcess "nc"
23:28:16 <jle`> dminuoso: those aren't the same code...
23:28:33 <jle`> dminuoso: you're saying that `1 + 3` is the same as 1 (+) 3
23:28:43 <jle`> do you see the difference?
23:28:56 <jle`> between f `g` h and f g h ?
23:29:01 <dminuoso> jle`: Ahh! Yes.
23:29:08 <jle`> "f `g` h" is sugar for g f h
23:29:18 <jle`> f g h is...definitely different
23:30:26 <dminuoso> jle`: Yeah. Somehow I just thought that (.) . (.) would give somehow work infix for some inexplicable reason. Thanks for untwisting my head.
23:30:37 <jle`> no problem :)
