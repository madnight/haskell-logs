00:02:01 <mbrock> if I could `import Aeson with Map = Data.Map.Map` I would ;)
00:02:30 * ski . o O ( functors )
00:04:49 <geekosaur> backpack, maybe
00:05:06 <geekosaur> although I would wonder what code in aeson might depend on HashMap being unordered...
00:05:08 <tdammers> HashMap is morally correct though
00:05:30 <geekosaur> ^
00:05:33 <tdammers> geekosaur: you can't depend on HashMap being unordered, because it's not *properly* unordered (i.e., no salting)
00:05:42 <geekosaur> yeh
00:06:03 <tdammers> HashMap is unordered in the same sense that uninitialized chunks of RAM are "random"
00:06:44 <tdammers> there's a good argument to be made against HashMap, but it's not that it's not ordered; it is that it is not unordered enough
00:08:31 * ski makes an implementation of `HashMap' that changes representation of values, at run-time
00:09:13 <rightfold> tdammers: Would work if you could only fold with a commutative monoid. Or if you had a quotient type that prohibited the user from observing the different order. Haskell doesn’t have these, but they would make this work with purity.
00:09:20 * mbrock imagines `keys :: HashMap k v -> IO [k]`
00:09:31 <nshepperd> HashMap.fromList xs = unsafePerformIO { do salt <- randomIO; ... }
00:09:49 <rightfold> keys :: HashMap k v -> HashSet k 😛
00:10:19 <mbrock> yeah that makes more sense ;)
00:10:33 <rightfold> nshepperd: Go actually does this. Iterating a hash table uses a pseudorandom order each time, to prevent the subtle bug where a consistent order is assumed.
00:10:57 <tdammers> newMap :: IO HashMap; insert :: k -> v -> HashMap -> IO (); ...
00:12:34 <mniip> insert :: k -> v -> HashMap s k v -> State# s -> (# State# s, HashMap s k v #)
00:13:37 <tdammers> the problem isn't even so much the ordering; it's being able to provoke hash collisions
00:14:32 <tdammers> I don't care about observed ordering, really - the moral contract is "I will throw your ordering away, do not rely on any particular order, if you do it's your own stupid fault", and trying to capture the absence of a reproducible ordering in the type system seems like proving a negative to me
00:14:42 <tdammers> but I do care about hashdos
00:14:57 <ij> What's the "a" in (\a -> a)? A parameter, not a variable?
00:15:14 <tdammers> especially with JSON, because just parsing user-supplied JSON data should not be subject to DoS attacks
00:15:20 <geekosaur> haskell doesn't treally have variables
00:15:29 <ij> I know, but what's the name for "a" then.
00:15:31 <tdammers> ij: type variable
00:15:32 <geekosaur> it's a lambda binding, but if you must, you can think of it as a parameter
00:15:35 <tdammers> oh wait
00:15:43 <tdammers> missed the \
00:16:00 <tdammers> geekosaur: how does Haskell not have variables?
00:16:20 <tdammers> geekosaur: Haskell doesn't have *mutable* variables, but we sure have variables?
00:16:24 <geekosaur> well, not in the usual programming sense. you can argue it in the math sense
00:16:36 <pacak> % :t newIORef
00:16:37 <yahb> pacak: newIORef :: a -> IO (IORef a)
00:16:42 <geekosaur> but for the programming sense I prefer 'bindings' because it generally catches the R/O-ness
00:17:09 <tdammers> the usual programming sense is ill-defined
00:17:13 <ij> Can I bind both an Either itself and both of its cases in a single go? (\data@(Either a b) -> …)?
00:17:21 <ij> I didn't manage to, just want to check that it's not possible.
00:18:22 <cocreature> ij: how is that supposed to work? if you use "(\(Either a b) -> a + b) (Left 1)", what should be the result of this?
00:18:35 <tdammers> pacak: those are mutable references, but as far as the language is concerned, those are orthogonal to variables
00:18:38 <ij> Right, sorry. That's not right.
00:19:19 <geekosaur> ij,you never have both of its variables, you can't bind what isn't there
00:19:28 <geekosaur> er. both of its cases
00:19:29 <geekosaur> derp
00:19:34 <ij> Yes, yes. I agree, I derped.
00:19:41 <geekosaur> no, I meant my derp there :p
00:19:52 <tdammers> pacak: newIORef "Hello" >>= readIORef >>= putStrLn -- look Ma, no variables
00:20:35 <tdammers> ij, geekosaur: also, Either is a type constructor, not a term constructor, so you can't pattern-match on it; you can only pattern match on Left and Right
00:20:44 <geekosaur> yes
00:20:49 <ski> (Haskell has variables as much as math has variables)
00:20:50 <tdammers>  \something@(Left x) -> ... -- works just fine
00:21:13 <geekosaur> that would have been the next step if the first hadn't made the point
00:21:20 <tdammers> ski: I prefer the interpretation where Haskell has variables just like everything else, the scope in which they can vary is just a bit different than in an imperative language
00:22:39 <ski> variables in math can vary, in the sense that their value needn't be determined. in `(x+y)^2 = x^2 + 2*x*y + y^2' or `x^2 - x - 1 = 0', the value of `x' isn't determined
00:22:50 <tdammers> Hofstadter has a nice chapter on variables in GEB, something about levels of variability... the one where they are watching a series of increasingly hypothetical soccer games, each introducing deeper levels of "what-if"
00:22:53 * nshepperd . o O (HashMap.foldMapWithKeys :: CommutativeMonoid m => (k -> v -> m) -> HashMap k v -> m)
00:23:00 <ski> (also, i'm not sure what "proving a negative" means)
00:23:01 <tdammers> "constants are variables too"
00:23:39 <tdammers> "proving a negative" means that you demand proof of the absence of something (see Russell's Teapot)
00:24:40 <ski> (a binding associates a variable/name, with an entity (like a value, a type, a pattern alias))
00:25:45 <nshepperd> the difference between 'negatives' and 'positives' seems rather imaginary to me
00:25:53 <tdammers> nshepperd: it is a bit arbitrary, yes
00:26:00 <LiaoTao> ij: (\x -> case x of ...) can do pattern matching
00:26:00 <nshepperd> like trying to group all co-things together
00:26:03 <LiaoTao> Not sure if that's what you want
00:26:32 <tdammers> it holds up somewhat for relatively concrete things though, hence the teapot
00:26:56 * ski proves the absense of a rational number expression of the square root of two
00:28:37 <tdammers> once you abstract a little, it boils down to how proving a positive ("there is an x such that...") and disproving a negative ("there is no x such that...") are duals of one another, both require exactly one example (or counterexample); whereas disproving the positive or proving the negative requires showing that (counter)examples cannot possibly exist
00:29:55 <tdammers> to prove that the square root of two is not a rational number, you have to generalize the concept of a rational number, and then show how p/q = sqrt(2) cannot possibly hold for any p and q
00:30:29 <tdammers> whereas in order to prove that sqrt(4) is rational, all you need to do is provide one example, e.g. p = 2, q = 1
00:32:17 <ski> well, proving the positive "every perfect number is even" requires not just one example
00:32:25 <nshepperd> a lot of 'absence proofs' in cs are of the form 'here is an example of a -> Void, therefore a is uninhabited'
00:32:50 <tdammers> yeah, that's how "positive" is ill-defined
00:32:50 <ski> yea, that's the intuitionistic definition of negation
00:33:07 <tdammers> ∀ vs. ∃
00:33:24 <ski> there ought to be a logical hierarchy of statements in e.g. physics
00:35:08 <geekosaur> glwt
00:35:25 <ski> "The Arithmetic Hierarchy Meets the Real World" <https://xorshammer.com/2016/05/14/the-arithmetic-hierarchy-meets-the-real-world/>
00:50:08 <srandon111> hello all, i would like to learn a new language, and was thinking about haskell, since it is purely functional, and i would like to learn this new style... what is the best point to start ? 
00:50:27 <srandon111> also can you suggest me some good books about haskell ? 
00:50:31 <srandon111> from novice to advanced ?
00:50:57 <opqdonut> "learn you a haskell for great good" is somewhat popular
00:51:06 <opqdonut> a bit quirky, and it doesn't have exercises
00:51:16 <opqdonut>  http://learnyouahaskell.com/
00:51:25 <opqdonut> available for free online, or you can buy a book
00:51:46 <opqdonut> for slightly more advanced topics, there is real world haskell, but it's slightly outdated
00:51:56 <opqdonut> http://book.realworldhaskell.org/
00:52:09 <opqdonut> there's probably a list of good resources somewhere too
00:52:29 <opqdonut> https://www.haskell.org/documentation
00:53:08 <srandon111> opqdonut: also, what are real world applications of haskell ? 
00:53:08 <quchen> LYAH was a great appetizer for me.
00:53:26 <quchen> ?quote circuit.design
00:53:26 <lambdabot> Jafet says: Haskell is an abstract research language used only in academia, education, banking, stock trading, circuit design, embedded systems, cryptography, operating systems research, bioinformatic
00:53:26 <lambdabot> s, phone apps, and web services.
00:53:27 <srandon111> i mean in which context it is applied ? 
00:53:34 <ggVGc> why would I use haskell when javascript can do the same things?
00:53:46 <ggVGc> isn't it all the same code in the end!
00:54:06 <ski> @where CIS194
00:54:06 <lambdabot> http://www.seas.upenn.edu/~cis194/spring13/
00:54:06 <ski> srandon111 : that ^ has exercises
00:54:09 <srandon111> quchen: in circuit design ??? how ? 
00:54:19 <ertes-w> hell
00:54:19 <quchen> srandon111: Ollie Charles works on that, for example
00:54:36 <quchen> srandon111: He can tell you more about that I’m sure
00:54:39 <quchen> ocharles: ping
00:54:48 <opqdonut> facebook uses haskell for e.g. spam filtering and internal tooling
00:55:09 <merijn> quchen: Haskell and circuit design and you don't mention Clash? :p
00:55:10 <quchen> Barclay’s is rewriting its risk engine in Haskell (ndmitchell)
00:55:35 <ski> srandon111 : another recent book that some people seem to like is
00:55:38 <ski> @where HPFFP
00:55:38 <lambdabot> "Haskell Programming: from first principles - Pure functional programming without fear or frustration" by Chistopher Allen (bitemyapp),Julie Moronuki at <http://haskellbook.com/>,#haskell-beginners
00:55:46 * ski hasn't tried it
00:55:47 <quchen> merijn: Right, and then there’s Clash. But I don’t know anyone using it, other than Christiaan. Who has a company based on Clash, so I guess there are others using it ;-)
00:56:23 <srandon111> also are there many modules for haskell ? 
00:56:30 <srandon111> where can i search for modules ? 
00:56:38 <ski> @hackage
00:56:38 <lambdabot> http://hackage.haskell.org
00:56:41 <srandon111> e.g., machine learning/ data analysis and those things 
00:56:42 <merijn> ski: So far it seems decent. I don't entirely agree with the order in which some things are covered and I think the build up works best for existing programmers
00:57:14 <merijn> quchen: Clash is Jan Kuper's project. Christiaan is (was by now?) his PhD student, they started a company doing consulting together, yeah
00:57:29 <merijn> quchen: Pretty sure other people in their group are using it too
00:57:43 <cocreature> quchen: afaik myrtle is using clash as well
00:58:08 <quchen> I’m sure it’s being used! I just don’t know by whom :-)
00:58:13 <merijn> I should ask them next Dutch FP day, I expect them to be there :)
00:58:25 <quchen> Heisenbug also used Clash for some time at Alcatel I believe
00:59:26 <merijn> Incidentally, anyone close to the Netherlands that isn't going yet should register for that as this iteration of Dutch FP day will apparently be free :p
01:04:14 <quchen> What’s Dutch FP?
01:04:43 <merijn> quchen: The annual Dutch functional programming day? :p Think of it as a tiny and informal mini conference
01:05:11 <merijn> quchen: Bunch of people from universities, industry, etc. get together, give some talks and have dinner
01:05:39 <merijn> Talks very from state-of-the-art research to "here's this cool thing I did using functional programming"
01:06:07 <quchen> Got a link to it for me?
01:06:21 <merijn> quchen: http://wiki.clean.cs.ru.nl/NL-FP_dag_2018
01:08:05 <quchen> FP »Dag«? How English is it going to be there?
01:08:24 <quchen> Well, given that the Dutch are very proficient English speakers I guess it’s no problem
01:08:45 <merijn> quchen: Past iterations talks have (almost?) all been in English.
01:44:45 <mohsen_> Hi there
01:45:12 <mohsen_> what's wrong with this syntax: f (a,b) = (a*a, b*b) ?
01:45:38 <mohsen_> I'm getting "parse error on ="
01:45:50 <Unhammer> in ghci?
01:46:14 <mohsen_> yes
01:46:25 <ventonegro> :let (Num a, Num b) => f (a,b) = (a*a, b*b)
01:46:27 <Unhammer> how about
01:46:29 <Unhammer> let f (a,b) = (a*a, b*b)
01:46:39 <mohsen_> Ah
01:46:43 <ij> Is there an Either a a -> a?
01:46:44 <mohsen_> I forgot let 
01:46:49 <sbrg> if you have a relatively new ghc, then `f (a, b) = (a * a, b * b)` works in ghci
01:47:34 <Unhammer> mm, 8.0.2 allows that at least
01:47:35 <cocreature> ij: bimap id id
01:47:44 <mohsen_> putting let before it worked, I guess the version is old
01:47:58 <Unhammer> 7.10.3 does not
01:48:04 <Unhammer> well, not that old
01:48:07 <cocreature> ij: eh no, "either id id"
01:48:32 <Unhammer> mohsen_,  ghci is kind of like a big do-block
01:48:37 <mohsen_> Unhammer: I'm running centos 7 and installed ghc from official repos 
01:48:52 <Unhammer> oh, then I guess it is old :)
01:49:10 <mohsen_> yeah
01:56:48 <mniip> how would I denote the precomposition natural transformation,
01:57:14 <ertes-w> mohsen_: you should update your GHC
01:57:50 <merijn> mohsen_: Installing a GHC bindist of a newer GHC is probably the simplest solution
01:58:09 <merijn> mohsen_: (That's how I install GHC on the stupid old Centos on our cluster)
01:58:21 <ertes-w> mohsen_: if the syntax you used isn't accepted, your version of GHC is on the brink of antiquity
01:58:21 <mniip> that is, Hom_C(-, X) is a functor so if I have a morphism f in C, then "Hom_C(-, X)f" is a function that precomposes with f
01:58:34 <sbrg> just install stack and use that to upgrade ghc
01:58:48 <mniip> how do I typeset this "Hom_C(-, X)f"? Hom_C(f, X) doesn't feel right
01:59:10 <Lauda> Is this a help channel? I'm a bit stuck with something
01:59:22 <sbrg> sure
01:59:55 <ertes-w> Lauda: a haskell help channel…  if your question is haskell-related, feel free to ask =)
02:00:25 <Lauda> It is! Sec.
02:07:10 <Mitten394> Hi. 
02:14:11 <tung> hey there!
02:20:36 <Matias34> Hi. Can someone help me?
02:22:00 <sbrg> Matias34: best way to get help is to just ask your question :)
02:22:21 <Matias34> Can I use pastebin?
02:22:35 <M2tias> Matias34: of course
02:22:55 <Matias34> https://pastebin.com/raw/j94kzhga
02:23:30 <oherrala> Matias34: you are missing "deriving" in data Person
02:23:31 <Matias34> Any suggestions how to approach this?
02:23:55 <Matias34> oops, yes
02:30:31 <gregoire[m]> Matias34: I would define custom Ord instances for Person and Writing
02:34:33 <Matias34> Like this gregoire[m] https://pastebin.com/raw/0n7kULNA ?
02:37:11 <Matias34> Sorry, sex and age reversed I mean.
02:43:34 <gregoire[m]> Matias34: I don't think it works
02:43:56 <Matias34> I did it wrong? :/
02:46:21 <gregoire[m]> ok, break down your exercice in small parts that you can manage
02:48:45 <Matias34> but I am not sure how to proceed here. You said Ord would help?
02:49:02 <ski> `Name',`Age',`Stree',`Number' are not defined ?
02:49:13 <gregoire[m]> sure if you need to sort
02:49:37 <Matias34> yes ski, forgot to paste. String, Integer, String, Integer
02:50:15 <ski> do you mean for two `Person's to be compared, by first comparing their `Name' components. if they're the same, also compare the `Age' components, and if those're the same, also compare the `Sex' components ?
02:50:32 <Matias34> If the register has two people named Ski
02:51:14 <Matias34> ascending (so low is always first), if both ski have the same age, then compare sex. If that matches too, then order is not relevant.
02:52:07 <ski> so you want to compare `Name', `Age',`Sex' components, in that order, stopping as soon as two corresponding components are different ?
02:52:18 <Matias34> Yes
02:52:35 <ski> ok. that's known as "lexicographic" ordering
02:52:55 <Matias34> Oh
02:53:30 <ski> that's the ordering that you get for free, if you add `deriving Ord' on the `data Person' data type declaration (since you had the fields `Name',`Age',`Sex', in that order)
02:54:08 <ski> if you want to, though (perhaps for exercise ?), you could explicitly make such an `Ord Person' instance, anyway
02:54:14 <ski> do you want to ?
02:54:46 <Matias34> Yes, it would be nice to practice custom Ord functions
02:56:08 <ski> (it's known as "lexicographic" ordering, since it's basically the same idea used when comparing e.g. words in a dictionary (or names in a telephone directory). first you compare the corresponding first letters in the two words. then if they're the same, the next two letters, and so on)
02:57:01 <ski> well, the problem with your attempt at an `Ord' instance is that you have written `Name',`Age',`Sex' as patterns in the definition of `compare'
02:57:23 <ski> but `Name',`Age',`Sex' doesn't live at the value level. they are types
02:58:12 <ski> you should write patterns corresponding to values of type `Person', in those two argument positions of `compare', since `compare' (for the `Ord Person' instance) takes two arguments of type `Person'
02:59:02 <Matias34> You mean, e.g. compare String String?
02:59:18 <ski> oh .. i should add that if you derive the `Ord' instance for `Person', then it will also consider the `Homes' and the `Show' fields, in case all the previous three fields are equal
02:59:34 <ski> (hm, actually, possibly instead of `Show' there, you meant to say `deriving Show' ?)
02:59:42 <ski> speaking of
02:59:44 <ski>   data Person = P Name Age Sex Homes Show
02:59:44 <Matias34> Yes! sorry typo
02:59:48 <ski> ok, so you meant
02:59:50 <ski>   data Person = P Name Age Sex Homes
02:59:51 <Matias34> Someone mentioned at the beggining
02:59:57 <ski>                 deriving Show
03:00:07 <ski> ok, sorry i missed that
03:00:41 <ski> anyway, a `data' type declaration gives a "template" for values of the newly defined type (here `Person')
03:00:55 <Matias34> so for gender, I'd have to write compare for all those combinations?
03:01:27 <ski> the "template" `P Name Age Sex Homes' here means that a sample value of type `Person' can look like `P n a s h', assuming `n' is of type `Name', `a' of type `Age', `S' of type `Sex', and `h' of type `Homes'
03:01:49 <ski> of course, any appropriate value can be used in place of the variable names `n',`a',`s',`h' i used here
03:02:22 <ski> Matias34 : well .. either that, or you add `Ord' to the `deriving' clause on `Sex'
03:03:02 <Matias34> https://pastebin.com/raw/nLeEAjAX does this look better?
03:03:08 <ski> (which will in that case assert that `M < W', and that `W < X'. ordering the data constructors `M',`W',`X' in the order you wrote them)
03:03:27 <ski> sorry, no
03:03:36 <Matias34> :<
03:03:48 <ski> wait a bit until i've explained a bit more what you should do
03:03:55 <Matias34> Okay sure, thanks
03:04:15 <ski> anyway, again you should not write types like `String' or `Int', in a position where a pattern is expected
03:05:38 <ski> types are expected after `::'; after `type' and `data'; after the `=' after `type'; after each data constructor (separated by `|'s) after the `=' after `data'; after the class name after `instance'
03:05:51 <ski> and probably some other places i'm forgetting
03:06:48 <ski> but when you're defining a constant, or a function (like `residents' or `compare'), you normally don't write types into that defining equation (using `=')
03:06:54 <ski> anyway
03:07:13 <ski> as i said, a typical `Person' value looks like `P n a s h'
03:08:16 <Matias34> Yes
03:08:50 <ski> in the case of `compare', both arguments are `Person's
03:09:06 <Matias34> compare n1 n2?
03:09:44 <ski> and you want `compare' to work for all two possible `Person's, so you don't want to restrict it by unnecessarily imposing any conditions on what the `n',`a',`s',`h' components of each of the two `Person's could be
03:09:58 <ski> so, if you had started with
03:10:04 <ski>   compare p0 p1 = ..p0..p1..
03:10:34 <ski> (where `p0' and `p1' are your two `Person' arguments, and where `..p0..p1..' means some, as yet unwritten, expression that may use `p0' and `p1')
03:11:05 <ski> then, according to this understanding that a `Person' can look like `P n a s h' .. and in fact, that's the *only* way a `Person' can look like
03:11:30 <ski> we can now refine this definition attempt of `compare' into
03:11:49 <ski>   compare (P n0 a0 s0 h0) (P n1 a1 s1 h1) = ...
03:12:10 <ski> so `n0' is the name of the first `Person', and `n1' is the name of the second `Person'
03:12:17 <ski> and likewise for the other components
03:12:40 <ski> Matias34 : makes any sense ?
03:13:16 <ski> (of course, you could rename the variables `n0',&c. to anything you like. i was just attempting to name them in some systematic, though brief, way)
03:13:54 <ski> now, what's left is to actually write the code in the "hole" `...', that corresponds to lexicographic ordering of these components
03:13:56 <Matias34> Yes! That makes a lot of sense. I just need to figure out how the syntax would look like after that first = to compare each component individually (right?)
03:14:29 <ski> now, you *could* e.g. go on and replace `s0' and `s1' by all possible patterns for the type `Sex'
03:14:32 <ski> iow, you'd have
03:14:42 <ski>   compare (P n0 a0 M h0) (P n1 a1 M h1) = ...
03:14:45 <ski>   compare (P n0 a0 M h0) (P n1 a1 W h1) = ...
03:14:47 <ski>   compare (P n0 a0 M h0) (P n1 a1 X h1) = ...
03:14:51 <ski>   compare (P n0 a0 W h0) (P n1 a1 M h1) = ...
03:14:54 <ski>   compare (P n0 a0 W h0) (P n1 a1 W h1) = ...
03:14:57 <ski>   compare (P n0 a0 W h0) (P n1 a1 X h1) = ...
03:15:02 <ski>   compare (P n0 a0 X h0) (P n1 a1 M h1) = ...
03:15:05 <ski>   and so on ..
03:15:12 <ski> however, this is a bit tedious
03:16:00 <ski> and, if you make (or derive) an `Ord' instance for `Sex', you don't need to do it in this way : you could just use `compare' (or `<',`<=',`>',`>=') on `Sex', to compare the components `s0' and `s1'
03:17:30 <ski> (in the case of `n0',`n1', those two are `String's, and there's (conceptually speaking) an infinite number of (finite) strings, so you can't enumerate all possible strings. and you don't need to, you can just use the `Ord' operations for `String's, which are already pre-defined for you)
03:19:03 <ski> (similarly, for `a0',`a1', which are `Integer's. `h0' and `h1' are lists of `Writing's. you haven't said whether you want to also consider these in the ordering, in case all the previous components should turn out to be equal. and if they do, how do you want to compare these lists ? using lexicographic ordering on lists ?
03:19:08 <ski> )
03:19:28 <ski> Matias34 : so, i'd suggest you try to go on from
03:19:34 <ski>   compare (P n0 a0 s0 h0) (P n1 a1 s1 h1) = ...
03:20:00 <ski> and focus on writing some sensible comparision code in `...', rather than attempting to refine the patterns on the left of `=' any further
03:20:25 <ski> ok ?
03:21:08 <Matias34> Yes that makes sense. No I don't want to consider h0 and h1. I have written down all the combinations now, let's see how to go from after "="
03:21:54 <ski> ok (if you had derived `Ord', then that instance *would* have considered the `Homes' components, in case all previous components were equal)
03:22:23 <Matias34> = n0 == n1 && a0 == a2 (I assume this is wrong)?
03:22:28 <ski> now, you know what type of value `compose' is supposed to return back, when given these two `Person's ?
03:23:23 <ski> (iow, what is the return type of `compare' ?)
03:24:03 <Matias34> EQ?
03:24:14 <ski> well, that's not a type
03:24:31 <ski> `EQ' is a sample value of the type that i was asking for
03:25:09 <Matias34> Bool? 
03:25:37 <liste> is EQ of type Bool?
03:26:01 <Matias34> I am confused :x
03:26:30 <ski> in the interactor, you can ask for the type of an expression, using the command `:type' (can be abbreviated as `:t')
03:26:47 <ski> so, you could try `:type EQ', to ask the interactor for the type of `EQ'
03:27:06 <Matias34> Ordering?
03:27:12 <ski> yes, that's it
03:27:18 <ski> @src Ordering
03:27:19 <lambdabot> data Ordering = LT | EQ | GT
03:27:42 <ski> `Ordering' is a data type used to represent the result of a comparision between two values
03:28:07 <Matias34> I see, but in the first case, how do I know which values it is comparing? It's comparing everything?
03:28:45 <ski> `compare x y' will give `LT', in case `x' is Less Than `y' (so `x < y' is `True' then). it will give `EQ', in case `x' is EQual to `y' (so `x == y' is `True' then). and it will give `GT', in case `x' is Greater Than `y' (so `x > y' is `True' then)
03:29:24 <Matias34> Yes, that I understand. However, it surely isn't just appending = EQ at the first line, is it?
03:29:33 <ski> so, you need to write code, in place of `...' above, which will return one of the three values `LT',`EQ',`GT', depending on how the two given `Person's compare, according to the ordering you have in mind
03:29:41 <ski> well
03:29:46 <ski>   compare (P n0 a0 s0 h0) (P n1 a1 s1 h1) = EQ
03:30:03 <ski> would claim that any two `Person's are to be considered EQual. which surely isn't what you want
03:30:40 <ski> you want to start by comparing the `Name' components, right ? and then depending on the result of that comparision, perhaps continue with comparing more components ?
03:31:56 <ski> do you know how `case' expressions work ?
03:32:16 <gregoire[m]> he even needs to compare on `Homes` first
03:32:33 <Matias34> I have used that once or twice I think
03:32:37 <ski> gregoire[m] : they said they didn't want to consider the `Homes' components
03:33:22 <ski> you can do it without a `case' here. but then you need to use pattern-matching in some other way. e.g. defining a helper function in a `where' clause, that does pattern-matching
03:33:29 <ski> it's up to you
03:33:48 <gregoire[m]> how do they find people living at the same adress?
03:34:41 <Matias34> The resulting sort of residents  does not consider homes, but he is right. It first checks which ones live at address and then sort the list
03:34:56 <Matias34> of those that do*
03:35:17 <ski> i.e. you could define a function, `checkNameComparision', which you call as `checkNameComparision (compare n0 n1)', and then in the definition of `checkNameComparision', you can handle the three different cases of being passed a `LT', an `EQ', and a `GT'
03:35:49 <ski> Matias34 : does that make any sense ?
03:36:30 <Matias34> Yes it does, but the syntax tends to be problematic 
03:37:09 <ski> can you paste an attempt to do this (or using `case', or another approach, if you prefer) ?
03:39:25 <Matias34> Let me try 
03:42:41 <Matias34> https://pastebin.com/BE9AyMsS
03:42:44 <Matias34> Does this make any sense?
03:43:40 <ski> almost
03:43:52 <Matias34> At least I am getting somewhere :x
03:43:53 <ski> your last `if' lacks a corresponding `else'
03:44:07 <ski> (every `if' must have both a `then' and an `else', in Haskell)
03:44:52 <ski> here, it would be less clunky to use a `case' on `compare n0 n1', rather than repeatedly calling it, and comparing with `LT' and so on
03:45:02 <Matias34> How
03:45:07 <ski> so, you could do something like
03:45:16 <ski>   compare (P n0 a0 s0 h0) (P n1 a1 s1 h1) = case compare n0 n1 of
03:45:24 <ski>     LT -> ...
03:45:28 <ski>     EQ -> ...
03:45:32 <ski>     GT -> ...
03:45:54 <ski> (i used "hanging" branches here, to avoid too much right-drift of the code)
03:46:04 <ski> one could also lay it out as
03:46:08 <ski>   compare (P n0 a0 s0 h0) (P n1 a1 s1 h1) = 
03:46:12 <ski>     case compare n0 n1 of
03:46:17 <ski>       LT -> ...
03:46:20 <ski>       EQ -> ...
03:46:23 <ski>       GT -> ...
03:46:50 <ski> (also, one doesn't have to list the branches in the `LT',`EQ',`GT' order. if you prefer, you could have the `EQ' case first, as in your code using `if')
03:47:23 <ski> if you instead would be using a helper function, `checkNameComparision', then it'd look like
03:47:33 <ski>   compare (P n0 a0 s0 h0) (P n1 a1 s1 h1) = checkNameComparision (compare n0 n1)
03:47:36 <ski>     where
03:47:41 <ski>     checkNameComparision LT = ...
03:47:44 <ski>     checkNameComparision EQ = ...
03:47:47 <ski>     checkNameComparision GT = ...
03:48:02 <ski> (and again the ordering of the defining equations of `checkNameComparision' doesn't matter here)
03:48:17 <ski> Matias34 : does this make sense ?
03:49:02 <ski> (perhaps it would be nicer here to abbreviate `checkNameComparision' to just `checkName', to make it a bit less wordy/long ..)
03:50:48 <Matias34> Yes.. checkName :: Ordering -> Ordering?
03:50:55 <ski> yes
03:51:29 <ski> `checkName' is given the result of comparing the `Name' components, and should then, if required, continue by comparing remaining components, before deciding which `Ordering' value to return
03:51:57 <ski> (and if you want to, you could add that type signature for `checkName', inside that `where' clause)
03:52:33 <ski> `checkName' here can be viewed as "giving a name" to the corresponding "nameless" `case' above
03:52:52 <Matias34> Hold up a bit, I can't process so much wisdom hehe
03:53:06 <ski> it's a matter of circumstance, and taste, which of these two approaches are to be preferred
03:53:14 <Matias34> can I use the same checkName for checking age and sex or not?
03:53:29 <Matias34> or just define a similar checkAge
03:53:33 <ski> no, you'd probably also define a `checkAge' and a `checkSex'
03:53:36 <ski> yes
03:53:52 <ski> and then these would call each other, in the appropriate way ..
03:53:53 <Matias34> sex is probably specific because of M W X, right?
03:54:11 <ski> .. corresponding to the `case' above having other `case's nested inside it
03:54:32 <ski> hm, not sure what you mean
03:54:46 <Matias34> :(
03:54:49 <ski> you may be able to avoid a `checkSex', though
03:54:59 <Matias34> how
03:55:30 <ski> (since that's the last check, which has the final say in the comparision. if it says `LT', then the final answer is `LT'. if it says `EQ', then the final answer is `EQ', &c.)
03:55:42 <Matias34> that's the second check
03:55:49 <Matias34> see residents
03:55:56 <Matias34> check name -> check sex -> check age
03:55:57 <ski> .. but i think you should at the moment concentrate on how to define `checkName'
03:56:26 <Matias34> let me guess, it isn't as simple as writing compare n0 n1 == EQ = EQ and two more lines?
03:56:33 <ski> oh ?
03:56:46 <ski> well
03:56:51 <ski> <ski> do you mean for two `Person's to be compared, by first comparing their `Name' components. if they're the same, also compare the `Age' components, and if those're the same, also compare the `Sex' components ?
03:56:55 <ski> <Matias34> If the register has two people named Ski
03:56:59 <ski> <Matias34> ascending (so low is always first), if both ski have the same age, then compare sex. If that matches too, then order is not relevant.
03:57:03 <ski> <ski> so you want to compare `Name', `Age',`Sex' components, in that order, stopping as soon as two corresponding components are different ?
03:57:04 <Matias34> Oh wait a sceond 
03:57:06 <ski> <Matias34> Yes
03:57:24 <ski> said that `Age' should be considered before `Sex'
03:57:31 <ski> but perhaps you misspoke before ?
03:57:32 <Matias34> Sorry, Name, Sex then Age
03:57:38 <ski> ok, good
03:57:59 <ski> so, can you see how to complete
03:58:04 <ski>   checkName EQ = ...
03:58:08 <ski>   checkName LT = ...
03:58:11 <ski>   checkName GT = ...
03:58:20 <Matias34> https://pastebin.com/raw/auDqXUiM
03:58:25 <Matias34> does this make sense?
03:58:26 <ski> (or in whatever order you prefer for the defining equations)
03:58:27 <ski> ?
03:58:46 <ski> sorry, it doesn't
03:58:56 <Matias34> This language is so confusing :s
03:59:39 <ski> `checkName' doesn't get passed `n0' and `n1' (two `Name's), rather it gets passed the result of calling `compare n0 n1' (which gives an `Ordering', as your type signature for `checkName' says that the argument should be typed)
03:59:46 <ski> <ski>   compare (P n0 a0 s0 h0) (P n1 a1 s1 h1) = checkNameComparision (compare n0 n1)
04:00:03 <Matias34> but what am I going to do with an Ordering?
04:00:03 <ski> we call `checkName' with `compare n0 n1' as argument
04:00:15 <pierrot> Good morning. I'm reading a source file that has `import GHC.Base hiding ((<|>))' in its preambule. Isn't Package GHC.Base the same as Prelude?
04:00:27 <ski> you decide whether to continue with further comparision, and how
04:00:47 <Matias34> I meant with the function checkName 
04:00:53 <ski> if you get `LT' as comparision result, then that means that `n0 < n1' is `True'. do you need to compare any further, then ?
04:00:58 <Matias34> what to do in it, nothing?
04:01:02 <ski> Matias34 : yes, that's what i'm talking about
04:01:46 <Matias34> I get this part:
04:01:58 <Matias34> where 	checkName LT = LT (ignore syntax in IRC)
04:02:07 <ski> `checkName' gets a *single* argument, not two. and that argument will already be a value of type `Ordering', an ordering result (of comparing `n0' and `n1')
04:02:08 <Matias34> But what to do with "checkName :: Ordering -> Ordering"
04:02:24 <ski> do nothing. it's correct
04:02:33 <ski> include it in your code, if you want to
04:02:47 <Matias34> okay so first is just = LT
04:02:50 <Matias34> second is checkName EQ = checkSex (compare s0 s1)
04:02:52 <Matias34> right?
04:03:10 <ski> yes, that sounds like it can work
04:03:15 <ski> and third ?
04:03:25 <Matias34> GT
04:03:48 <Matias34> but obviously another where after that EQ line to handle checkSex
04:03:50 <Matias34> correct?
04:03:57 <ski> perhaps you could add this code to the paste, so we can see how it looks, spelled out, in one place
04:04:13 <ski> (so far, that is)
04:04:46 <ski> Matias34 : yes and no. yes, you *can* add `checkSex' inside a `where' attached to the `checkName EQ = ...' defining equation, if you want to
04:05:18 <ski> but you don't *need* to. just could just define `checkSex' "beside" `checkName' (by which i mean, above or below it, indented to the same level as `checkName')
04:05:26 <Matias34> Adding a binding to checkName is okay to just write n = n?
04:06:28 <ski> (but `checkName' *needs* to be defined in a `where' inside `compare' here, since it uses the variables `s0' and `s1', coming from the patterns of the `compare' defining equation, despite `s0' and `s1' not being passed explicitly to `checkName')
04:07:15 <Matias34> https://pastebin.com/raw/FYqCrZju
04:07:23 <Matias34> Looking better or worse?
04:07:48 <ski> (and similarly, `checkSex' will also probably need to "pick out of the air" such variables bound by `compare'. so it needs to be inside the `where' attached to the `compare' defining equation. but it doesn't need to be inside a `where' attached to `checkName EQ = ...', since it doesn't need to use locally bound variables of that equation (there are none))
04:08:34 <ski> that code is ok, except for the end of the paste
04:08:52 <Matias34> What's wrong with it?
04:09:10 <ski> the type signatures for `checkName',`checkSex',`checkAge' should be declared alongside the definitions of those function (indented inside the `where's), not at the end
04:09:48 <Matias34> Uhm?
04:09:56 <ski> (in fact, those signatures and defining equations that you have at the end define *different* functions, that happen to be named the same. but they are useless here, so you can scrap those)
04:10:04 <ski> i mean like :
04:10:11 <ski>   compare (P n0 a0 s0 h0) (P n1 a1 s1 h1) = checkName (compare n0 n1)
04:10:13 <ski>     where
04:10:19 <ski>     checkName :: Ordering -> Ordering
04:10:25 <ski>     checkName LT = LT
04:10:26 <ski>     ...
04:10:30 <Matias34> ooh
04:10:36 <Matias34> didn't know we could do that
04:10:51 <ski> but, you don't *have* to add type signatures for these local functions. it's up to you
04:11:27 <Matias34> Done. So our Ord should work now? Thanks for this lovely help
04:11:27 <ski> *usually*, people put type signatures on "top-level" definitions, but usually not on local ones, such as these. however, in some cases, it can help making the code more readable
04:11:53 <ski> btw, in fact you could even add
04:12:00 <ski>   compare :: Person -> Person -> Ordering
04:12:56 <ski> above the defining equation for `compare', inside the `instance' declaration .. at least if you enable the (benign) language extension `InstanceSigs'
04:13:15 <ski> (by adding `{-# LANGUAGE InstanceSigs #-}' as the first line of your source file)
04:13:35 <Matias34> Maybe keep it as is? Don't want to confuse myself hehe. But that's interesting
04:13:46 <ski> sure, if you prefer
04:14:23 <Matias34> So for residents, how would I filter that list of people to only leave those living at address?
04:14:30 <ski> also, as i said, you don't *need* to nest `checkSex' inside (the `where' attaching to) `checkName', nor `checkAge' inside `checkSex'
04:14:34 <Matias34> I should filter first and then order
04:15:06 <ski> you could just define those inside the "main" `where' (attaching to `compare'), directly under `checkName', indented to the same level
04:15:38 <ski> also, note that `checkAge x', for any comparision result `x', gives back just `x'
04:15:49 <Matias34> Um?
04:16:03 <ski> the only possible comparision values are `LT',`EQ',`GT'
04:16:13 <Matias34> I thought we were done with that function?
04:16:15 <ski> in each of these three cases, `checkAge' returns the same value back
04:16:39 <ski> therefore, `checkAge (compare a0 a1)' is equal to just `compare a0 a1', skipping `checkAge' altogether
04:16:51 <ski> this is a simplification you *could* make to your code
04:16:56 <ski> you don't have to
04:17:12 <Matias34> I think it's easier to undernstand what it really does for newbies like me
04:17:13 <Matias34> like this
04:17:18 * ski nods
04:17:28 <Matias34> The compacter haskell code is, the worse it is for me lol
04:17:40 <ski> if you want to, you could also consider how the corresponding `case' code would look like
04:17:48 <ski> (might be good practice in how to use `case')
04:17:57 <Matias34> Once I solve it, that's definitely a good idea to play with
04:18:58 <ski> i will also mention that it is possible to make the definition of `compare' here considerably shorter (and clearer, once you get the idea), by using the "monoid combination" operator `<>', on comparision values, which have type `Ordering'
04:19:32 <ski> (the code can be read out load as "first compare according to name, then according to sex, then according to age")
04:19:42 <ski> but perhaps another time :)
04:20:05 <Matias34> I'll write that down for later hehe
04:20:24 <ski> <Matias34> So for residents, how would I filter that list of people to only leave those living at address?
04:20:27 <ski> <Matias34> I should filter first and then order
04:20:35 <ski> well, do you know list comprehensions ?
04:21:02 <ski> you could also do it with (structural) recursion on lists, or using library functions like `map' and `filter'
04:21:04 <Matias34> I've done list filtering a bit, and working with head and stuff. However, accessing the first element of Person and checking that.. no idea
04:21:18 <Matias34> filter, that I would like
04:21:43 <ski> the input is of type `Register', which is the same type as `[Person]'. so the input is a list of `Person's
04:21:51 <ski> @type map
04:21:52 <lambdabot> (a -> b) -> [a] -> [b]
04:21:54 <ski> @type filter
04:21:55 <lambdabot> (a -> Bool) -> [a] -> [a]
04:22:04 <ski> are the types of those two functions
04:22:20 <ski> > map (2 *) [0,1,2,3,4]
04:22:22 <lambdabot>  [0,2,4,6,8]
04:22:36 <ski> > filter odd [0,1,2,3,4,5]
04:22:38 <lambdabot>  [1,3,5]
04:22:47 <ski> shows how they can be used
04:23:04 <Matias34> Yes, but problem for me I guess is getting and checking only the address of that person from the list (for all persons)
04:23:26 <Matias34> I take it I could write a straight out filter that does this for all the Persons, correct?
04:23:28 <ski> `map' takes a function that will be called on every element of the input list, to compute the corresponding elements of the output list. here that function was the doubling function `(2 *)' (the "two times" function)
04:24:02 <Matias34> So I need a combination of map and filter?
04:24:15 <ski> `filter' takes a function that returns a boolean result (sometimes such a function is called a predicate). it calls that predicate on all elements of the list, and keeps the elements for which the predicate "succeeds" (iow returns `True')
04:24:36 <ski> > [2 * n | n <- [0,1,2,3,4]]
04:24:38 <lambdabot>  [0,2,4,6,8]
04:24:49 <ski> > [n | n <- [0,1,2,3,4,5],odd n]
04:24:51 <lambdabot>  [1,3,5]
04:25:05 <ski> are ways to achieve the same things, using list comprehensions instead
04:25:36 <ski> `[2 * n | n <- [0,1,2,3,4]]' is "the list of all `2 * n', for every possible way to draw an element `n' from the list `[0,1,2,3,4]'"
04:26:11 <ski> `[n | n <- [0,1,2,3,4,5],odd n]' is "the list of all `n', for every possible way to draw an element `n' from the list `[0,1,2,3,4,5]', with the extra condition that `odd n' is `True'"
04:26:32 <ski> you can also combine these two steps
04:26:43 <ski> > [2 * n | n <- [0,1,2,3,4,5],odd n]
04:26:45 <lambdabot>  [2,6,10]
04:26:48 <Matias34> Uh
04:27:03 <ski> (getting the odd numbers in the list, doubled)
04:27:16 <ski> > map (2 *) (filter odd [0,1,2,3,4,5])
04:27:18 <lambdabot>  [2,6,10]
04:27:27 <ski> achieves the same thing, using `map' and `filter'
04:28:45 <ski> the list comprehension syntax above is meant to resemble "set builder" (aka ZF/set comprehension) notation, in math (set theory), if you know anything about that. otherwise, don't worry. list comprehensions aren't *that* hard to grasp
04:29:17 <ski> Matias34 : in your case, you'd be handling a list of `Person's, rather than a list of numbers, as in my examples above
04:29:31 <ski> the same ideas could apply, though
04:30:03 <ski> so .. you could start like
04:30:21 <ski>   residents reg addr = ..reg..addr..
04:30:39 <ski> and try to use list comprehensions, or `map' and `filter', in the body here (i.e. to the right of the `=')
04:30:50 <ski> or, you could use list recursion
04:31:11 <ski> Matias34 : are you familiar with using recursion to define a function that consumes one (or more) list(s) ?
04:31:21 <Matias34> I don't think so
04:31:36 <Matias34> yes I thought of the first case, but hitting it correctly as per syntax will take a bit
04:31:39 <Matias34> let me try some
04:32:17 <ski> (e.g. a function that computes the sum of all numbers in a list. or the mean. or a function that checks whether the elements in a list are in ascending order, &c.)
04:32:33 <Matias34> that I can do
04:32:36 <Matias34> I think :D
04:33:46 <ski> (or a function that squares every number in a list (using recursion, not `map' or list comprehension). or a function that takes two lists of the same length, and multiplies corresponding elements, adding all those products (this is "dot/scalar product" of vectors))
04:34:31 <Matias34> The complicated part here is that
04:34:36 <ski> if you're not satisfied that you can do these things, then you probably, at some point, want to look closer on list recursions
04:34:38 <Matias34> Each Person has a list of Homes (which have addresses)
04:34:46 * ski nods
04:34:58 <Matias34> so I can't just do like a == addr obviously
04:35:16 <Matias34> maybe write another function that 
04:35:20 <Matias34> check this?
04:35:23 <ski> there is a standard function, `elem', which checks whether a value is an element of a given list
04:35:30 <ski> perhaps you could use that
04:36:08 <ski> (or, if you prefer, you could define it for yourself, though it's then easiest if you rename it to something else, like `member' or `myElem')
04:36:18 <Matias34> a `elem` addr wouldn't work either I believe
04:36:25 <ski> > elem 3 [0,1,2,3,4]
04:36:27 <lambdabot>  True
04:36:29 <ski> > elem 5 [0,1,2,3,4]
04:36:31 <lambdabot>  False
04:36:54 <ij> How do I make "(a, b) -> m (a, c)" from "b -> m c"?
04:37:23 <ij> Is there some lens magic I could use?
04:37:30 <ski> hm .. well, if you could convert your list of `Writing's into a list of `Address'es, then you could possibly use `elem' on that list
04:37:41 <hpc> :t \f a -> fmap ((,) a) . f
04:37:43 <lambdabot> Functor f => (a1 -> f b) -> a2 -> a1 -> f (a2, b)
04:38:06 <hpc> :t \f -> fmap ((,) x) . f
04:38:07 <lambdabot> Functor f => (a -> f b) -> a -> f (Expr, b)
04:38:13 <Matias34> Yes ski, that's one way of tackling it. However, that would mean taking a list of writings and filtering out the other types
04:38:16 <hpc> ij: like that?
04:38:24 <Matias34> Which isn't also part of what I know, unfortunately.
04:38:31 <hpc> sometimes you don't need lens ;)
04:38:43 <ski> @type runKleisli . second . Kleisli
04:38:44 <lambdabot> Monad m => (b -> m c) -> (d, b) -> m (d, c)
04:39:22 * ij looks up kleisli
04:39:38 <ski> well, here it requires `Monad', though only `Functor' is really needed
04:40:21 <ski> Matias34 : well .. you could use a list comprehension to do that
04:40:24 <ski> (or `map')
04:40:44 <int-e> :t uncurry ((sequence .) . (,))
04:40:45 <lambdabot> Monad m => (a1, m a2) -> m (a1, a2)
04:40:49 <ski> Matias34 : but then you'd have to familiarize yourself a little bit more with those, i suspect
04:40:59 <Matias34> What would be the easiest way of doing this then?
04:41:31 <ski> you could probably decompose the problem into subproblems, corresponding partly to defining some helper functions
04:41:34 <ski> (like before)
04:41:48 <ski> you'd need some way of traversing the lists
04:42:02 <Matias34> Yes, but I just told you what my problem is
04:42:37 <ski> either list recursion (the basic way). or stuff like `map' and `filter' (which are defined using recursion). or using list comprehension
04:42:41 <Matias34> I wouldn't know how to work on a list that has [(a,b,c), (d,e,g)] and e.g. always compare the first element
04:42:51 <ski> so .. you'd need to learn more about at least one of these topics, i think
04:43:24 <Matias34> I know how to transverse a normal list [a,b,c,d]
04:43:36 <ski> using recursion ?
04:43:42 <int-e> :t mapM :: Monad m => (a -> m b) -> (c, a) -> m (c, b)
04:43:44 <lambdabot> Monad m => (a -> m b) -> (c, a) -> m (c, b)
04:43:46 <Matias34> x:xs? Yes
04:43:53 <ski> ok, good
04:44:02 <ski> then it's just a matter of some extra pattern-matching
04:44:22 <ski> instead of `x', you'll write a pattern, like `P n a s h', as before
04:44:40 <int-e> (now why didn't I see that 5 minutes ago)
04:44:58 <ski> int-e : nice
04:45:27 <Matias34> Uhm let's see
04:46:12 <ski> in this case, you'll probably want to look closer into the `h' part (of type `Homes', so that it is a list of `Writing's)
04:46:41 <ski> you could probably make a helper function, that you pass `h' to, that considers a single `Homes' (coming from a `Person')
04:47:42 <ski> so, possibly, both this helper function, and `residents', would be recursive, traversing lists
04:48:00 <Matias34> What would the return value be? Hm
04:48:25 <ski> not quite sure. depends on what exactly you want `residents' to do
04:48:36 <Matias34> We already defined that
04:48:49 <ski> (i haven't heard a clear statement of what it should do)
04:49:18 <Matias34> Returns an ordered list of the people living at the address in the form [(Name, Sex, Age)]  (sorted the way that we already implemented)
04:49:49 <ski> the people such that the given address is an element of their `Homes' list ?
04:50:28 <Matias34> So the input is a list of people and an address. However, each person has Homes which is a list of [Writing] which has the address in it.
04:50:39 <ski> can the argument of type `Register' be assumed to already be ordered ?
04:50:56 <Matias34> No
04:51:11 <ski> ok. then you must explicitly make sure that you give back a sorted list
04:51:22 <Matias34> That's why we implemented the Ord, is it not?
04:51:46 <ski> (either by making sure it keeps being ordered, as you build it; or by sorting it as a final step)
04:51:56 <ski> could be
04:52:04 <Matias34> I think sorting at the end is the easiest for me
04:52:09 * ski doesn't know why Matias34 wanted to make an instance of `Ord'
04:52:21 <Matias34> Someone suggested it as a way of solving this..
04:52:26 <ski> ok
04:52:33 <Matias34> In this chat I mean
04:52:52 <ski> if you want to sort (only) at the end, then that should not be done "inside" the recursion
04:53:09 <ski> (since then you'll probably do the sorting at each recursive step, which is wasteful)
04:53:34 <ski> so, you should make a separate function that will do the actual recursive list traversal
04:54:12 <Matias34> traversal of the Homes list of each person? 
04:54:30 <ski> well, that may require yet a helper function
04:54:43 <ski> defining helper functions is pretty common in Haskell. it's no big deal
04:54:59 <ski> often, the most trouble with them is inventing some sensible name for them
04:55:02 <Matias34> Okay I am a bit confused. Which traversal do I attempt to do first?
04:55:27 <ski> you have an overall traversal of the `Register' list
04:55:45 <ski> and, for each `Person' in that list, you have a subordinate traversal of the `Homes' list inside of that
04:56:03 <ski> whether you want to write the code for the former, or the latter, first, is up to you
04:56:32 <ski> it might be easier to start with the former, if you don't already have an idea of how the latter should work
04:56:46 <Matias34> residents ((P n a s h):reg) addr
04:56:49 <Matias34> like this?
04:57:03 <ski> yes, although the inner pair of brackets there are redundant, you can write just
04:57:11 <ski>   residents (P n a s h:reg) addr = ...
04:57:20 <ski> also, don't forget the base case of the recursion
04:57:39 <Matias34> Empty list?
04:57:45 <ski> probably, yes
04:58:11 <ski> that's the default choice of base case, for list recursion. it's often, but not quite always, an appropriate choice
04:59:25 <ski> (but if it's possible to make the base case, in a reasonable way, then one probably should do that. often that can help making the recursive code (or code calling it), simpler than it would otherwise be. defining "trivial"/"empty" cases like that can be quite helpful)
05:00:02 <Matias34> So, for every element in the list of people.. check something
05:00:04 <Matias34> right?
05:00:04 <ski> (if it's possible to make the base case the empty case, i mean)
05:00:11 <ski> yea
05:00:20 <ski> either you want to keep a person, or skip them
05:00:40 <Matias34> for example
05:00:53 <ski> if keeping, you only want to keep the `Name', `Age', and `Sex', not the `Homes' list
05:00:57 <ski> is that right ?
05:01:04 <Matias34> uhm I don't think I'll get this syntax correct
05:01:05 <Matias34> Yes
05:01:46 <ski> here could be an appropriate place to use "guards" syntax (like you attempted to use at <https://pastebin.com/raw/auDqXUiM>)
05:02:05 <Matias34> that's already gone haha
05:02:12 <ski> (one could also use `if'-`then'-`else', or even `case')
05:02:14 <ski> ok
05:02:18 <ski> well, something like
05:02:25 <ski>   residents (P n a s h:reg) addr
05:02:35 <ski>     | ...       = ...
05:02:40 <ski>     | otherwise = ...
05:02:41 <Matias34> I am doing that
05:02:46 <Matias34>  | length reg >= 0 = checkAddr(w addr) but what here...
05:02:51 <Matias34> syntax problems always
05:03:06 <Matias34> >0 *
05:03:13 <ski> then `length' of a list is always non-negative, so `length reg >= 0' is always `True'
05:03:16 <ski> ok
05:03:39 <cheater> is there a place i can paste haskell code and have it compile and run?
05:03:59 <Matias34> I mean, how do I write after that checkAddr to call the function again
05:04:04 <ski> instead of first computing the whole `length' of a list (by traversing to the end of it), it would be nicer to use the `null' predicate on lists, which checks whether a list is empty. you can combine it with `not'
05:04:13 <cheater> or maybe even just give it the url of a git repo or a gist
05:04:18 <ski> that way, you don't have to traverse the whole list
05:04:35 <TMA> returning to the <> monoid note from a while ago: would it be: instance Monoid Ordering where { mempty = EQ ; (<>) EQ x = x ; (<>) x _ = x } ?
05:04:39 <ski> (which is wasteful, here, since you only want to know whether it is empty or not)
05:05:22 <ski> cheater : i think there was some place, but i don't recall where :/
05:05:26 <Matias34>  | not (`null` reg) = checkAddr(w addr)
05:05:37 <cheater> ski: ok..
05:05:38 <ski> TMA : yep
05:05:58 <ski> (i'd define `<>' using infix notation, though)
05:06:12 <ski> Matias34 : skip the backticks ?
05:06:52 * ski is pretty sure the address to such a paste site is in lambdabot somewhere, though ..
05:07:20 <Matias34> skipped
05:07:27 <ski> what is `w' ?
05:07:42 <Matias34> homes
05:07:50 <ski> not `h' ?
05:08:15 <Matias34> Changed it, might be confusing since writing is with w
05:08:17 <Matias34> not it is h
05:08:26 <ski> do you want to pass two arguments to `checkAddr' ?
05:08:26 <Matias34> now*
05:08:49 <Matias34> Well I guess I check whether the list of homes has the address that we have in residents?
05:09:27 <ski> sounds like a plan
05:09:42 <Matias34> but my question now is
05:09:49 <Matias34> how do I call residents after that call again
05:09:52 <Matias34> with the remaining list
05:10:26 <ski> well, if you write `... : ...' after the `='
05:10:38 <ski> then you could recursively call `residents' in one of those "holes"
05:11:20 <ski> the first `...' in `... : ...' should be replaced by code computing the element to keep. the second should be replaced by code computing the remainder of the list to compute
05:11:36 <ski> ok ?
05:12:09 <Matias34> Um yes
05:12:16 <Matias34> the first should probably have something like if True
05:12:20 <Matias34> then keep that
05:12:31 <Matias34> otherwise just call the residents with remainder of list
05:12:32 <Matias34> Right?
05:12:39 <ski> (this might be simpler to grasp, if you had defined a function to square every number in a list, and a function to compute all the divisors of a given (positive) integers)
05:12:57 <ski> (or some other exercises that give similar exercise)
05:13:14 <ski> Matias34 : sounds like it could work
05:13:55 <Matias34> e.g. now I have no idea syntax wise hehe
05:14:05 <Matias34> big (if else):other part
05:14:11 <Matias34> nah that won't work I think
05:14:30 * ski nods
05:14:43 <Matias34> if checkAddr something
05:14:47 <Matias34> then something
05:14:48 <ski> you need to check the condition, before you decide whether to use `:' or not
05:14:48 <Matias34> else something?
05:14:55 <ski> that could work
05:15:03 <ski> (also, guards could work, as i already said)
05:15:10 <TMA> and then the rest would be: instance Ord Person where { compare (P n0 a0 s0 h0) (P n1 a1 s1 h1) = (compare n0 n1) <> (compare s0 s1) } ?
05:15:33 <ski> TMA : close, but not quite. age should also be considered
05:15:52 <TMA> ah, the age
05:16:12 <TMA> instance Ord Person where { compare (P n0 a0 s0 h0) (P n1 a1 s1 h1) = (compare n0 n1) <> (compare s0 s1) <> (compare a0 a1) } 
05:16:16 <ski> TMA : you got it ! :)
05:16:26 <ski> (though there are some redundant pairs of brackets there)
05:16:47 <TMA> yay \o/ even with an infix operator :)
05:16:49 <ski> TMA : using accessors, and `comparing', it could be written even more succinct :)
05:18:00 <ski> (yea, you could write `compare' infix as well, if you like)
05:18:10 <TMA> ski: I have last seen Haskell in 2000, my knowledge is very dusty and I am not yet up to speed
05:19:00 <ski> if you want to, i could point you to a reddit comment that explains it
05:19:15 <ski> @type comparing
05:19:16 <lambdabot> Ord a => (b -> a) -> b -> b -> Ordering
05:19:24 <ski> @src comparing
05:19:24 <lambdabot> comparing p x y = compare (p x) (p y)
05:19:33 <ski> @type \p -> compare `on` p
05:19:35 <lambdabot> Ord a1 => (a2 -> a1) -> a2 -> a2 -> Ordering
05:20:57 <Matias34> then P n a g h:residents(reg)
05:21:05 <Matias34> Doesn't this lose our initial addr or not?
05:21:35 <ski> well, the recursive call to `residents' would also require two arguments
05:21:46 <Matias34> okay so (reg addr)
05:21:55 <ski> can you be more explicit ?
05:22:09 <Matias34> What do you mean?
05:22:15 <Matias34> P n a g h:residents(reg addr)
05:22:22 <ski> that's what i mean, yes
05:22:37 <ski> i was suspecting you'd try to write the code like that
05:22:41 <ski> it's not correct
05:22:42 <Matias34> haha
05:22:49 <Matias34> What's wrong with it?
05:23:09 <ski> `residents(reg addr)' means : call the *function* `reg' on the argument `addr', and call the function `residents' on the result of the previous call
05:23:15 <ski> but `reg' is not a function !
05:23:22 <ski> you want `residents reg addr'
05:23:44 <ski> brackets are not used for function calls, in Haskell. they are used for grouping
05:23:47 <ski> (and for tuples)
05:24:07 <ski> the brackets in
05:24:10 <ski>   residents (P n a s h:reg) addr
05:24:14 <Matias34> Okay, thanks! Now i need to write checkAddr similarily
05:24:20 <Matias34> it goes through list of writings and compares
05:24:22 <ski> aren't written there because arguments needs to be wrapped
05:24:28 <Matias34> if = True, break and return true
05:24:31 <ski> they're written there, because if you wrote
05:24:36 <ski>   residents P n a s h:reg addr
05:24:45 <ski> then Haskell would interpret this as if you had written
05:24:51 <ski>   (residents P n a s h):(reg addr)
05:24:55 <ski> which isn't what you want
05:25:32 <ski> function application (the invisible "space" or juxtaposition between a function, and its arguments) binds tighter than infix operators (like `:' here)
05:25:40 <ski> that's why you need brackets in this case
05:30:07 <Matias34> I have a problem
05:31:43 <Matias34> then P n a s h:residents reg addr, does not match [(Name,Sex,Age)]. I think I wrote checkAddr correctly
05:33:56 <gregoire[m]> personToTuple (P n a s h) = (n, s, a)
05:34:21 <ski> well, you say `P n a s h', to the left of `:' (where the element of the output list goes)
05:34:30 <lyxia> cheater: https://www.tryhaskell.org
05:34:33 <ski> `P n a s h' does not have type `(Name,Sex,Age)'
05:35:04 <ski> you could use that `personToTuple', but you could just as well write the triple directly
05:35:29 <Matias34> Oh yes, you're right
05:35:35 <Matias34> now I need a function to sort this and it should be done
05:35:37 <Matias34> right?
05:36:26 <ski> i dunno. i haven't seen `checkAddr'
05:36:39 <Matias34> want me to share?
05:36:46 <ski> (btw, perhaps you could invent a more sensible name for that function, that is more descriptive)
05:37:03 <ski> if you want me to
05:39:56 <Matias34> https://pastebin.com/raw/wxzVCJna
05:40:05 <Matias34> The spacing is a bit off, but it should work
05:40:20 <pierrot> I need to build a parser for this simple EBNF specification : https://i.imgur.com/pHZOCk6.png (I need to implement it using a given `Parser' module)
05:40:40 <pierrot> This is what I've done: https://glot.io/snippets/evp8f06cyw
05:41:11 <ski> Matias34 : do you need a `null' check, here ?
05:41:20 <pierrot> (in the "main.hs" tab is my code and in the "dio.hs" is the `Parser' module I'm supposed to use)
05:42:39 <lyxia> pierrot: what's the problem
05:42:40 <pierrot> I need to construct a `parser :: Parser Expr` where Expr is the algebraic datatype defined in "main.hs"
05:43:18 <pierrot> lyxia: well, I've written parsers for `digit', `nat', `lower' and `varname'
05:43:25 <pierrot> but I'm not sure about `expr'
05:43:34 <cheater> lyxia: thanks
05:43:57 <lyxia> pierrot: line 41 is not aligned BTW
05:44:40 <lyxia> pierrot: Try (<|>)
05:44:40 <ski> @type digitToInt
05:44:41 <lambdabot> Char -> Int
05:45:35 <lyxia> pierrot: it usually represents "|" from grammars
05:45:40 <ski> the commands for a `do' doesn't need to be aligned with the `do' (though they need to be alignes with each other)
05:46:11 <ski> `maybe (...) id' is simpler written as `fromMaybe (...)'
05:46:18 <Matias34> ski don't I?
05:46:40 <ski> @type lookup  -- is a standard function
05:46:41 <Matias34> or you want me to reverse this
05:46:41 <lambdabot> Eq a => a -> [(a, b)] -> Maybe b
05:47:01 <ski> Matias34 : you already have a base case. do you need a second one ?
05:47:11 <pierrot> lyxia: yes, you're write
05:47:15 <pierrot> right*
05:47:16 <Matias34> I have no idea what you're asking of me
05:47:21 <pierrot> lapus lol
05:47:33 * ski looks at pierrot
05:48:17 <ski> you might want to use  foldl'  rather than  foldl
05:48:20 <pierrot> Hi ski o/
05:48:34 <ski> lo pierrot
05:49:20 <pierrot> lyxia: do I need a parser for spaces, right?
05:49:33 <Matias34> :<
05:50:03 <ski> Matias34 : `checkAddr [] addr = False' says what to do when you get an empty list of `Writing's
05:50:26 <pierrot> lyxia: what's wrong with line 41 ?
05:51:40 <ski> Matias34 : regarding the `checkaddr (A ad s n:rest) addr' part, the attached `| not (null rest) = ...' guard handles the case when then list passed to `checkAddrs' has at least two elements. and the `| otherwise = ...' guard handles the case when that list has exactly one element
05:52:03 <Matias34> so I don't need that null check?
05:52:19 <ski> Matias34 : so, you have one (base) case for zero elements, one (recursive) case for more than one element (iow at least two elements), and one (base) case for one element (and no more)
05:52:51 <ski> i'm suggesting that you may be able to simplify this code, by only having two cases
05:53:03 <Matias34> I thought I was running in circles
05:53:10 <Matias34> One second I think I am right, then next that I am wrong.. heh
05:53:20 <ski> the pattern-match on `[]' will check when you have reached the end of the list
05:53:32 <ski> do you need to be able to stop (base case), sooner than that ?
05:54:48 <Matias34> No. Ok simplified it
05:55:30 <lyxia> pierrot: if I click "run" I get a parse error.
05:56:13 <Matias34> Now I need to figure out how to sort this list
05:56:21 <pierrot> lyxia: oh. I loaded it in ghci and it doesn't complain, but I'll fix that indentation issue anyway
05:56:29 <terrorjack> Hi, is there an example of ghc frontend plugin that works with ghc head?
05:56:39 <ski> you could write your own list sorting function ..
05:56:50 <ski> .. or you could use the standard `sort' (or `sortBy') function
05:57:05 <ski> writing your own might be fun
05:57:15 <lyxia> pierrot: a parser for spaces would be useful indeed
05:57:25 <Matias34> is that even possible? to use 'sort' based on the 3 cases that we've described earlier
05:57:36 <Matias34> name then sex then age
05:59:24 <ski> well, if you sort a list of type `[(Name,Sex,Age)]', then it will use the built-in (lexicographic) ordering on triples, iow first compare the first component (the `Name'), then the second (`Sex'), and finally the third (`Age')
05:59:27 <ski> is that what you want ?
05:59:48 <ski> otherwise, you could use `sortBy', passing an explicit comparision function, that compares in the way you prefer
05:59:54 <ski> @type sort
05:59:55 <lambdabot> Ord a => [a] -> [a]
05:59:55 <ski> @type sortBy
05:59:56 <lambdabot> (a -> a -> Ordering) -> [a] -> [a]
06:00:02 <Matias34> Yes that is what I want
06:00:12 <ski> (`sortBy' takes a function of the same type as `compare')
06:00:49 <Matias34> but where do I place sort here? I can't just encapsulate the recursive call, can I
06:00:55 <ski> > sortBy (comparing length) (words "The quick fox jumps over the lazy dog")
06:00:57 <lambdabot>  ["The","fox","the","dog","over","lazy","quick","jumps"]
06:01:01 <ski> > sortBy (comparing length <> compare) (words "The quick fox jumps over the lazy dog")
06:01:03 <lambdabot>  ["The","dog","fox","the","lazy","over","jumps","quick"]
06:02:06 <ski> <ski> if you want to sort (only) at the end, then that should not be done "inside" the recursion
06:02:11 <ski> <ski> (since then you'll probably do the sorting at each recursive step, which is wasteful)
06:02:17 <ski> <ski> so, you should make a separate function that will do the actual recursive list traversal
06:02:37 <Matias34> :<
06:03:18 <Matias34> residents list addr = sort(help list addr)?
06:03:30 <ski> sounds like it would work
06:03:39 <ski> where `help' is your previous `residents', renamed
06:03:53 <ski> (including renaming the recursive call, of course)
06:04:45 <ski> (`help' could perhaps be called something like `filterResidents', instead. also, if you define it inside a `where' here, you don't need to pass `addr' as argument to it)
06:06:13 <pierrot> ski: I hadn't realized some of your messages were directed to me (like the one about `lookup' and `fromMaybe'). sorry, since you were helping Matias34, I almost ignored your messages
06:06:48 <ski> no worry
06:06:59 <Matias34> Undefined variable "sort"
06:07:00 <Matias34> what
06:07:06 <ski> @index sort
06:07:06 <lambdabot> GHC.OldList, Data.List, Data.ByteString, Data.ByteString.Char8, Data.Sequence
06:07:14 <ski>   import Data.List (sort)
06:07:32 <Matias34> or write my own sort?
06:07:41 <ski> or that, yes
06:07:52 <Matias34> would you recommend the latter?
06:08:23 <ski> if you have time, and haven't done it before, it could be fun
06:08:33 <ski> there are several different algorithms you could try
06:08:41 <ski> the simplest may be insertion-sort
06:08:51 <ski> (selection-sort is also relatively simple)
06:09:07 <Matias34> alright, I'll be back in a hour or so and pick that up
06:09:17 <ski> bubble sort is simple, but not that efficient
06:09:35 <ski> then merge sort and quick sort (though for a real quick sort, one needs mutable structures)
06:09:41 <Matias34> How long would something like this take for someone as experienced as you? i.e. the whole task from the beginning? 
06:10:05 <ski> hm, dunno. maybe half an hour ?
06:10:11 <ski> not quite sure
06:10:22 <ski> could be less, could perhaps be more
06:10:28 * ski hasn't read the specification
06:10:52 <Matias34> ooh, RIP me then :x
06:11:20 <ski> with more experience, it becomes easier
06:11:22 <ski> one step at a time
06:11:48 <ski> Matias34 : anyway .. i think i need to leave now. good luck and have fun !
06:12:03 <Matias34> Same, thanks and bye
06:12:10 <ski> you're welcome
06:15:13 <nosteam> hello
06:24:26 <jchia_> I'm trying to get Generic instance for 'label := value' (labels package from http://hackage.haskell.org/package/labels-0.3.3/docs/Labels-Internal.html). When I try to derive using 'deriving' GHC complains "Constructor ‘:=’ has constraints in its type" suggesting standalone deriving. With standalone deriving, it complains ":= must be a vanilla data constructor". Any tips on how to proceed?
06:32:26 <rwarfiel1> Could someone explain how to use a function like withKnownSymbol from the Singletons library?  It's declared 
06:32:29 <rwarfiel1> withKnownSymbol :: Sing n -> (KnownSymbol n => r) -> r
06:33:12 <rwarfiel1> I have a singleton and want to call symbolVal to get a string. How do I even use the n given it doesn't appear anywhere else in the definition?
06:42:53 <rwarfiel1> ok never mind... i was overcomplicating things. I can just use the fromSing function directly on the singleton
06:46:57 <ertes-w> rwarfiel1: the KnownSymbol context that you gain by using withKnownSymbol allows you to use functions in GHC.TypeLits
06:48:32 <lyxia> jchia_: you can't derive Generic for a GADT
06:51:00 <jchia_> lyxia: How can I tell that the "label := value" is a GADT? I don't see 'where'. What's the next best thing I can do to get Generic?
06:53:55 <jchia_> lyxia: OK, I see that when I turn off the GADTs extension, compilation fails. I'm going to try to understand the error message. Still, any idea how best to proceed?
07:01:20 <infandum`> I have a streaming traversable (Records from cassava). Does parListChunk retain streaming properties if I use "parListChunk n . toList $ trav"?
07:01:40 <infandum`> I would *assume* it does, because it should be a lazy list...
07:06:59 <pierrot> lyxia: I've written `parser' but it doesn't work properly :/ https://glot.io/snippets/evp8f06cyw
07:11:43 <pierrot> hmm it doesn't work so badly though
07:20:42 <orion> Is the Foundation package production-worthy?
08:14:21 <lyxia> jchia_: you can see it's a GADT because there is a constraint in the constructor. 
08:14:53 <lyxia> jchia_: Generics for GADTs is an open problem.
08:15:39 <dumptruckman> Anyone got any advice here? http://regexr.com/3h806 I want it to match everything except the opening a and img tags
08:16:15 <tdammers> my advice would be "don't use regexes on HTML"
08:16:58 <tdammers> use a proper HTML parser instead, and do your filtering on the DOM tree
08:18:14 <lyxia> In this case you might have KnownSymbol s => Generic (s := a) by hand but it really sounds like a bad idea... you might as well write simple functions between a and (s := a)
08:18:15 <jchia_> lyxia: I don't understand the technical syntax of Generic, but it seems like in this case, I only have to care about the 'value' and ignore the 'label' when making the Rep value. Can I define 'from' and 'to' in terms of the Generic instance of the 'value' type, i.e. ignoring the 'label'?
08:18:52 <jchia_> lyxia: The background problem is that I want to used the named tuples from the labels package and still use things like aeson & cassava without boilerplate.
08:19:04 <sternmull> is there any chance to debug unhandled exceptions in non-main-threads? If i set -fbreak-on-error and call a function that throws then ghci stops and i can debug it. When i run the same function with forkIO then i can't.
08:19:08 <lyxia> just don't use generics if it can't be derived.
08:19:27 <jchia_> lyxia: I think that means not using labels since there's no Generic instance.
08:20:19 <jchia_> Is there a way to somewhat solve the records problem and still be able to have Generic?
08:21:20 <lyxia> ah, in the context of records you can consider them as products
08:22:11 <jchia_> lyxia: That's the direction I was explaining about how to define the 'from' and 'to' but the syntax is quite hairy for me.
08:22:19 <lyxia> does labels not offer aeson instances already?
08:22:48 <jchia_> I'm not referring to aeson in particular. I'm referring to things that make use of Generic.
08:24:48 <jchia_> e.g. Binary.
08:26:11 <jchia_> In many cases, using named tuples like labels instead of regular tuples, giving up Generic, is quite a heavy penalty to development effort.
08:27:10 <jchia_> lyxia: I'm not stuck to labels, though. I just don't know which other similar package allows Generic.
08:35:39 <lyxia> jchia_: well labels uses tuples, which have the problem that there are no Generic instances beyond size 7
08:36:13 <jchia_> lyxia: Good for lots of cases, still.
08:36:26 <lyxia> although I don't think the fact that := has no generic instance is a problem otherwise
08:36:29 <jchia_> OTOH, I wonder why they stop at 7.
08:38:02 <lyxia> deriving Generic is slow
08:38:37 <lyxia> though I don't know how true that is nowadays
08:44:02 <lyxia> Generic is not really the right way of looking at := . It's really meant to be a kind of newtype.
08:51:06 <lyxia> I'd recommend vinyl or bookkeeper, and open an issue for Generic instances.
11:18:18 <shapr> SURE IS QUIET TODAY
11:18:30 * Clint yawns.
11:22:25 <mniip> so if we use CCC constructions in the Cat category, we can effortlessly construct functors and prove functoriality
11:22:33 <mniip> what about natural transformations
11:28:46 <kw> @pl (\f l -> sequence (fmap f l))
11:28:46 <lambdabot> (sequence .) . fmap
11:31:10 <mniip> kw: fmap (fmap sequence) fmap
11:31:48 <mniip> kw, oh wait
11:31:51 <mniip> I believe that's called
11:31:53 <mniip> :t traverse
11:31:54 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
11:35:41 <EvanR> so with a record, you could define some fields in terms of other fields of the same record
11:36:14 <EvanR> let r = Foo { a = f r, b = g r, c = 9 } in r
11:36:18 <mniip> did you mean: function
11:36:26 <mniip> ah that
11:36:52 <EvanR> but, does this work with something like vinyl records
11:38:10 <mniip> hmm
11:38:16 <mniip> are comma categories expressible in Hask
11:38:21 <kw> :t mapM
11:38:23 <lambdabot> (Monad m, Traversable t) => (a -> m b) -> t a -> m (t b)
11:38:29 <EvanR> > let r = [1, r !! 3, 3, 4] in r
11:38:31 <lambdabot>  [1,4,3,4]
11:38:35 <mniip> kw, same thing but weaker constraint
11:38:50 <mniip> EvanR, one more step and you're inventing loeb
11:39:25 <EvanR> why does that seem to prefigure my brain exploding
11:39:59 <mniip> ohhhhh
11:40:07 <mniip> where's quchen
11:40:31 <mniip> moeb :: Cont (c -> a) (Cont b a)
11:41:17 <mniip> I expect you'd even be able to implement it with callCC
11:43:34 <EvanR> well that seems to indicate its possible in vinyl
11:43:56 <EvanR> since vinyl records are just lists with a ton of type level stuff around them
11:45:09 <EvanR> (i wish we could make them be like regular records at runtime though)
11:45:19 <lyxia> sure, as long as your records have lazy fields
11:45:29 <EvanR> oh
11:45:53 <EvanR> here i am with bangs everywhere
11:46:01 <EvanR> that will never work
11:48:23 <EvanR> > let !r = [1, r !! 3, 3, 4] in r
11:48:25 <lambdabot>  [1,4,3,4]
11:48:36 <EvanR> > let !r = [r !! 1, 2, 3, 4] in r
11:48:39 <lambdabot>  [2,2,3,4]
11:48:45 <EvanR> im doing it wrong
11:50:10 <EvanR> do we have extensible records that are "backed by" vectors instead of lists
11:50:44 <shapr> does -fvia-C still work?
11:51:30 <geekosaur> shapr, no
11:51:52 <shapr> ah, too bad.. I just got access to Intel's commercial compilers
11:52:00 <shapr> was wondering if it'd make any difference
12:00:21 <lyxia> EvanR: superrecord uses a SmallArray, probably the fastest to read; CTRex uses a Map; data-diverse uses a Seq.
12:02:22 <EvanR> oh
12:02:59 <lyxia> I never remember the differences between the interfaces though.
12:03:06 <cocreature> if profiling shows that a lot of memory usage is caused by ByteString (i.e., -hy points to ARR_WORDS), how can I narrow down which ByteStrings are causing this?
12:03:16 <cocreature> retainer profiling is not particularly helpful
12:06:41 <EvanR> in smallarray what is the class name Elt supposed to mean
12:07:08 <shapr> element?
12:07:13 <geekosaur> I'd think
12:07:27 <mniip> Elite
12:08:47 <EvanR> ah
12:09:18 <EvanR> i see a pointer is not Elt
12:11:19 <EvanR> so no lazy elements, at least not directly
12:14:30 <EvanR> but Char is Elt, so we have yet another string type! 
12:14:56 <EvanR> i welcome Array Char overlords
12:18:05 <EvanR> actually superrecord seems to use something in GHC called SmallArray
12:18:14 <EvanR> instead of this package called smallarray
12:19:21 <EvanR> SmallArray# does allow pointers
12:21:46 <hariel> how do i build lambdabot with stack
12:26:28 <jared-w> Hmm, seems I missed syd. I replied to his email finally, so that's good :)  I feel bad about forgetting it existed, though...
12:26:33 <Guest14482> Pattern matching is something inherently dynamic; but does GHC knows to skip directly to to right body if all the arguments are known?
12:27:32 <Tuplanolla> Is this a join point question or are you just confused with terminology, Guest14482?
12:28:07 <jared-w> Pattern matching is compiled down to case expressions, which are essentially evaluated into something like switch statements or jump tables, whatever floats your boat when thinking about imperative machines. Does that help any?
12:29:55 <Jello_Raptor_Roa> So I've got a structure I'm working on that (ideally invisibly) decomposes "Fix v" into a map of "Map UID (v UID)", Is there some way to provide an interface where the user can give me an "Fold' (v (Fix v) (v (Fix v))''' and I can use it to traverse the map from one UID to some set of others?
12:30:20 <Jello_Raptor_Roa> this would let me keep my interface as clean as I can 
12:32:16 <Pamelloes> I want to lazily read a file into a bytestring. In C, the documentation for the needed syscalls to do this provide extensive documentation on how things can go wrong and how you can attempt to deal with that. However, the ByteString documentation has no mention of any errors that could occur or how to handle them. Is there another place I can look to for this documentation?
12:50:17 <haskellnoob> Spent more than 100hours and explored some haskell...I really dont want to become pro in haskell as there are no jobs, which language should I jump next 
12:50:52 <ggVGc> that's a weird question
12:51:38 <haskellnoob> why?
12:52:04 <erisco> if you define "professional of x" as "is paid to do x" then your statement is weird
12:52:43 <haskellnoob> I dont get you 
12:52:53 <haskellnoob> I dont do any profession right now
12:53:24 <ystael> No jobs like the full time Haskell back end developer positions on my team, that I would love to be able to fill? Those no jobs?
12:54:02 <erisco> then there is the fallacy that there are no Haskell jobs
12:54:07 <dminuoso> There are no Haskell jobs? So all those Haskell professionals must be working for free.
12:54:12 <dminuoso> I pity you folks.
12:54:38 <erisco> finally there is the fallacy that learning Haskell would only have merit if it appears on a job requirement list
12:55:15 <dminuoso> erisco: My last job offer went along the lines of "Must be competent in C and preferrably Erlang, but any functional language experience is sufficient"
12:55:19 <EvanR> i feel like there are less C jobs than haskell jobs
12:55:24 <haskellnoob> I am not saying I wont use haskell...I may use it forever I am asking another alternate language
12:55:43 <EvanR> the cobol job market though
12:55:48 <erisco> try Erlang or Clojure or Scala
12:55:50 <haskellnoob> I dont see a single haskell job trust me
12:56:12 <dminuoso> haskellnoob: There's a difference between "not seeing one", "not being able to find one", "none existing", or "not being offered one"
12:56:17 <danielsmw> why would people trust you when they just claimed to have hard evidence to the contrary?
12:56:23 <erisco> there are no Haskell jobs in my area either, but if you're willing to move (possibly to another country) then you can find work
12:58:34 <EvanR> my file compiled yay
12:58:39 <EvanR> that means its perfect
12:59:07 <erisco> did you use Coq?
12:59:20 <EvanR> no
12:59:22 <haskellnoob> dminuoso:  I will spend next 2 months to write mid level programs in haskell will you provide any interview or show any job ? I see alllocal job portals and searched with haskell and I see 0 matches
12:59:45 <dminuoso> haskellnoob: Are you hiring me to find me a job? 
12:59:48 <dminuoso> *Find you
12:59:51 <jared-w> EvanR: Then it's not perfect ;)
12:59:58 <haskellnoob> dminuoso:  yup :P
12:59:58 <EvanR> blast
13:00:13 <dminuoso> haskellnoob: I have no interest in becoming a head hunter.
13:00:29 <erisco> I have probably seen the most job ads for Scala, out of passably FPLs
13:00:36 <jared-w> haskellnoob: There's a few jobs here and there advertised on r/haskell, there's also a few websites out there dedicated to posting FP jobs only
13:01:02 <EvanR> i have been the most job ads for javascript
13:01:18 <erisco> AWS and JavaScript are pretty big
13:01:21 <EvanR> with undisclosed real languages behind it which you also need ot know
13:01:35 <EvanR> ruby, java, csharp etc
13:01:50 <haskellnoob> getting any job is easy but getting some good job is very very hard
13:02:02 <EvanR> even harder for noobs
13:02:07 <haskellnoob> I dnt want to work on some idiotic languages like JS
13:02:17 <haskellnoob> EvanR:  yeah
13:02:25 <sd4a6sa4> I just joined a few secs ago. About which countrys are you talking about? :) 
13:02:45 <Pamelloes> No country has been named yet :P
13:03:27 <EvanR> you might have to move to america
13:03:37 <dminuoso> haskellnoob: You can do amazing functional programming in JS.
13:03:46 <dminuoso> Its not clean and as much fun as Haskell, but its perfectly viable.
13:04:10 <erisco> FP is possible in many, or lets say most, popular languages, but that doesn't mean much
13:04:24 <erisco> because you have to agree with every library and coworker
13:04:52 <EvanR> programming is a human endeavor
13:05:28 <jared-w> erisco: ahh, looks like someone's worked on a real job before :p
13:05:28 <EvanR> mathematical truths can only get you so far
13:05:51 * jared-w uses PHP and JS at his job. No, you can't use whatever library you want. No, you can't write it however the hell you want to.
13:05:56 <haskellnoob> i worked for a fucking team who doesnt need me now
13:06:03 <johnw> EvanR: guess that depends on the axioms? ;)
13:06:36 <jared-w> johnw: Gonna add the "mathematical truths can get you anywhere" axiom to ZFC?
13:06:39 <erisco> jared-w, yeah and I am looking to put myself back in the ring again
13:06:47 <jared-w> What would you call that? ZFC+idealism? :p
13:06:47 <EvanR> to get farther, add more axioms? :)
13:07:04 <jared-w> erisco: nice, nice, any market in particular that you're looking at?
13:07:48 <erisco> job market?
13:07:54 <haskellnoob> So, I am checking erland scala and clojure for now and try them thnk you ll
13:07:57 <haskellnoob> all*
13:08:19 <jared-w> np
13:13:26 <pierrot> I've written a small frotend for the toy interpreter of my exercise: https://glot.io/snippets/evpkw82yjc
13:13:50 <pierrot> the `opts' list has type [Flag]
13:14:47 <pierrot> but it can be [ Verbose, Interp "program" ] or [ Interp "program", Verbose ]
13:15:02 <pierrot> depending on how the user called my program
13:15:30 <EvanR> cool
13:16:23 * deepredsky
13:19:00 <pierrot> if I'd use a `case opts of` expression, I needed to consider 3 cases ( [ Interp name ], [ Verbose, Interp name ] or [ Interp name, Verbose ] ) but the latest two are esentially the same
13:19:23 <Arney> yo
13:19:32 <pierrot> How could avoid that repetition?
13:19:49 <jared-w> pierrot: any reason to not sort [Flag] into a cannonical form of some sort and then prune the duplicates?
13:19:59 <erisco> pierrot, why not [Verbose] ?
13:20:38 <erisco> I am not sure if case analysis like this is what you'd want, rather than instead testing if a particular option is set (exists in the list)
13:20:54 <erisco> so,  Verbose `elemOf` opts  instead, for example
13:20:58 <pierrot> erisco: yeah, also [ Verbose ]. I didn't consider it because it must return an error in that case
13:21:01 <pierrot> but it must be considered
13:21:18 <EvanR> pierrot: i have seen a pattern, people make a record of the possible configurations, not a list of flags. you can run through the options and produce the record. then look at the record to see how to behave
13:21:33 <EvanR> {verbose=True, interp="program"}
13:21:45 <pierrot> EvanR: hmmm that's a nice idea
13:21:50 <erisco> the record gives a canonical order, is a way of viewing that
13:21:55 <geekosaur> or use a Set instead of a list
13:21:57 <EvanR> its not really in any order
13:22:10 <EvanR> i guess it is, but thats not the point
13:22:18 <erisco> I am comparing to a sorted list
13:22:28 <EvanR> the configuration is really a record, ordered or not
13:22:32 <jared-w> geekosaur: sets are so nice, I forget they exist sometimes, but really, so nice.
13:22:59 <erisco> there are other differences, like exactly one instance of the option exists, whereas in the list any number may
13:23:25 <geekosaur> maybe we need a bag type >.>
13:23:39 <EvanR> verbose verbose verbose
13:23:49 <jared-w> geekosaur: is the bag essentially an unordered list?
13:23:52 <geekosaur> (although you can emulate it with Map key Int)
13:24:01 <EvanR> anyway
13:24:01 <erisco> you might use Data.Set with a sort of funky Ord instance
13:24:12 <geekosaur> no, sets that can have multiple copies of things
13:24:29 <geekosaur> well, I suppose you can think fo that as unordered list
13:24:30 <EvanR> these are all implementation ideas for something no one agrees on the abstract interface to
13:24:32 <erisco> why multiple copies? I guess I don't understand the nature of these flags
13:24:48 <geekosaur> think commands that let you -v -v -v to get 3 levels of verbose
13:24:59 <EvanR> {verbosityLevel=3}
13:25:00 <jared-w> or, to be more precise, a list that cannot be ordered :p
13:25:08 <geekosaur> (ssh being an example)
13:25:22 <jared-w> -v -v -v seems like a really dumb idea tbh
13:25:29 <EvanR> -vvv is way better
13:25:30 <erisco> really? lol… I don't know CLIs that well
13:25:44 <geekosaur> well, they're the same with getopt
13:25:44 <EvanR> ive seen -vvvv before
13:25:49 <jared-w> erisco: every cli app has its own way of doing things
13:26:11 <ystael> as long as -vvvvvv reverses gravity
13:26:24 <EvanR> ^
13:26:35 <jared-w> I've seen -v for version, -V for version, --v for version, --version, --Version, -v for verbose, -v[1..5], -v -v -v only, -v -v -v but allows -vvv, and so on
13:27:54 <erisco> ystael, I think I know that reference oO
13:27:57 <EvanR> alright
13:28:44 <EvanR> container question, what container do you use for data that is inserted with an interval as the key, but looked up at a point
13:28:50 <EvanR> BSP ?
13:29:14 <jared-w> interval as the key, but looked up at a point?
13:29:16 <erisco> why doesn't an interval tree work?
13:29:29 <EvanR> because i dont know what an interval tree is
13:29:31 <erisco> a point can be converted to an interval
13:29:35 <erisco> the interval that contains exactly that point
13:30:08 <erisco> oh, sorry, here: http://hackage.haskell.org/package/IntervalMap
13:30:29 <erisco> http://hackage.haskell.org/package/data-interval
13:30:53 <erisco> first has more DLs and looked alright when I used it
13:31:45 <EvanR> IntervalMap looks right
13:32:14 <mniip> ooo
13:32:21 <mniip> my package being discussed on the ML
13:32:29 <erisco> yes sir
13:32:31 <EvanR> though, im wonder how to keep all the intervals from overlapping
13:32:40 <mniip> interval tree you mean like a segment tree?
13:33:03 <erisco> it is okay if they overlap
13:33:03 <mniip> I guess not
13:33:23 <mniip> erisco, I feel so accomlished
13:33:35 <jared-w> mniip: which package? :)
13:33:37 <erisco> people are using your software, congrats!
13:33:40 <mniip> finite-typelits
13:33:52 <jared-w> oooh nice, I saw that
13:34:02 <EvanR> actually i dont see a way to insert a whole interval of data
13:34:04 <mniip> which reminds me, I ought to fix a few instances
13:34:35 <erisco> I am too busy making ACME packages to be noticed :P
13:34:42 <mniip> I have an acme package
13:34:47 <mniip> @hackage acme-iot
13:34:47 <lambdabot> http://hackage.haskell.org/package/acme-iot
13:34:51 <EvanR> oh k is a type implementing Interval
13:34:59 <jared-w> ಠ_ಠ
13:35:22 <jared-w> "the resulting computations are lazy in the sense of being lazy IO"  ಠ_ಠ ಠ_ಠ
13:36:17 <jared-w> nice package though :p
13:36:26 <mniip> oh but wait
13:36:36 <mniip> @hackage acme-undo
13:36:36 <lambdabot> http://hackage.haskell.org/package/acme-undo
13:36:46 <jared-w> not found
13:36:46 <mniip> ah
13:36:49 <mniip> @hackage acme-timemachine
13:36:49 <lambdabot> http://hackage.haskell.org/package/acme-timemachine
13:36:58 <mniip> forgot the name
13:37:39 <jared-w> lol that's hilarious
13:38:03 <erisco> I appreciate that it reads like a dry, unexcited academic paper
13:38:23 <Tuplanolla> This package doesn't look like a joke to me.
13:38:39 <geekosaur> acme-dont?
13:38:41 <Tuplanolla> I guess my standard for good ideas is skewed.
13:38:54 <mniip> Tuplanolla, it is very much a joke
13:39:39 <erisco> if it really did work, you could at least write a program to make unlimited money through gambling
13:40:01 <EvanR> i often think about "what if" when playing video poker
13:40:14 <EvanR> if i went back in time and played the same hand, would i get the same cards or what
13:40:30 <EvanR> if not, i somehow would feel better
13:40:35 <erisco> well, good question, but it doesn't matter for profitability
13:40:35 <EvanR> i mean, if so
13:40:48 <EvanR> if you had a time machine, it would matter
13:40:51 <erisco> you merely rewind until you win
13:40:53 <mniip> Tuplanolla, there's no real reason to hide a State monad under the hood like that, especially if the resulting type isn't even a monad
13:41:01 <EvanR> if you always get the same cards, time travel wont help
13:41:18 <erisco> sure it will because if we're talking poker specifically then you can fold :)
13:41:30 <mniip> but can you sacn
13:41:32 <mniip> but can you scan
13:41:41 <EvanR> i wish i could fold in video poker
13:42:28 <glguy> You can, you just walk away
13:42:37 <mniip> Tuplanolla, acme-iot even more so
13:42:42 <mniip> the name itself is also a pun
13:42:51 <mniip> you would think it's related to the Internet Of Things
13:42:56 <mniip> but it's much worse
13:44:10 <geekosaur> io transformer?
13:44:16 <geekosaur> (without looking)
13:44:18 <mniip> yes
13:44:41 <jared-w> "Give any monad the full power of IO!"
13:46:00 <jared-w> @hackage acme-php
13:46:00 <lambdabot> http://hackage.haskell.org/package/acme-php
13:46:43 <EvanR> the monad power hierarchy
13:47:13 <EvanR> Identity, Reader, State, ST, IO, Undoable
13:48:15 <jared-w> Where does the Tardis monad go? It travels time, but doesn't break the laws of reality... Hmm....
13:48:37 <EvanR> between State and ST ?
13:49:05 <EvanR> somewhere around Cont ?
13:49:38 <mniip> hmm
13:49:52 <mniip> I should patch Undoable to support ST
13:49:57 <erisco> if you can figure out what the screwdriver and doctor functions will do, mniip has volunteered to write it
13:50:01 <mniip> adn IOT too
13:50:31 <jared-w> The doctor function patches your code in a way that type-checks; no guarantees if it actually fixes things.
13:50:41 <jared-w> screwdriver = unutterableAccursedPerformIO :p
13:50:52 <mniip> I think you mean
13:50:54 <mniip> unsafeCoerce
13:50:58 <EvanR> accursedUnutterablePerformance
13:51:17 <mniip> or, no,
13:51:25 <mniip> :t unsafeCoerce . unsafePerformIO
13:51:26 <lambdabot> error:
13:51:26 <lambdabot>     Variable not in scope: unsafeCoerce :: b0 -> c
13:51:26 <lambdabot> error:
13:51:30 <mniip> % :t unsafeCoerce . unsafePerformIO
13:51:30 <yahb> mniip: unsafeCoerce . unsafePerformIO :: IO a -> c
13:51:51 <jared-w> % :t unsafeCoerce . accursedUnutterablePerformIO
13:51:52 <yahb> jared-w: ; <interactive>:1:16: error: Variable not in scope: accursedUnutterablePerformIO :: a -> a0
13:52:21 <mniip> % unsafeCoerce . unsafePerformIO $ 5
13:52:22 <yahb> mniip: ; <interactive>:6:34: error:; * No instance for (Num (IO a0)) arising from the literal `5'; * In the second argument of `($)', namely `5'; In the expression: unsafeCoerce . unsafePerformIO $ 5; In an equation for `it': it = unsafeCoerce . unsafePerformIO $ 5
13:52:30 <mniip> aw
13:52:40 <mniip> that doesn't fix *all* the type errors
13:52:46 <EvanR> ways haskell can be worse than C
13:53:01 <mniip> hmmmm
13:53:02 <jared-w> EvanR: But look at all the semicolons you can avoid writing!
13:53:07 <jared-w> https://github.com/haskell/bytestring/blob/2530b1c28f15d0f320a84701bf507d5650de6098/Data/ByteString/Internal.hs#L624-L634
13:53:09 <mniip> % unsafeCoerce (unsafeCoerce . unsafePerformIO) $ 5
13:53:10 <yahb> mniip: <interactive>: internal error: stg_ap_v_ret; (GHC version 8.3.20170519 for x86_64_unknown_linux); Please report this as a GHC bug: http://www.haskell.org/ghc/reportabug; [Aborted]
13:53:54 <jared-w> % :t unsafeCoerce
13:54:00 <yahb> jared-w: [Timed out]
13:54:02 <EvanR> yahbs computer will now blue screen
13:54:03 <jared-w> lol
13:55:05 <mniip> the ghci boot time goes towards the timeout :(
13:55:20 <mniip> % :t unsafeCoerce
13:55:20 <yahb> mniip: unsafeCoerce :: a -> b
13:56:01 <jared-w> hmm... 
13:56:36 <jared-w> Could you cast it to like dynamic or something?
13:57:33 <mniip> what?
13:57:40 <EvanR> just stop
13:58:16 <Pamelloes> Is there a way to make -interactive-print process output from compile errors and type checks instead of just valid expressions?
14:05:05 <jared-w> mniip: I was thinking of something like https://hackage.haskell.org/package/base-4.10.0.0/docs/Data-Dynamic.html but I butchered my question a bit :p
14:06:11 <EvanR> you know what would be interesting
14:06:22 <jared-w> what?
14:06:51 <EvanR> a data type like A -> B, but secretly, evaluations at particular A are logged through spooky action at a distance, checkable in IO
14:07:34 <jared-w> Is that not essentially what Debug.Trace allows?
14:07:37 <mniip> ezpz
14:07:44 <EvanR> debug.trace just prints stuff out
14:07:47 <EvanR> as a side effect
14:08:24 <jared-w> Shouldn't be too hard to write a version of it that logs instead. If you want to get super fancy you could even throw a logging monad transformer in there and get customizable unsafe logging :p
14:08:28 <EvanR> by logged i mean theres a mutable bag of A you have access to somewhere
14:08:57 <jared-w> ahh okay, that wasn't what I was thinking of when you said logging
14:09:32 <mniip> trace :: (a -> b) -> IO (IORef [(a, b)], a -> b); trace f = do i <- newIORef []; return (i, \x -> unsafePerformIO $ let y = f x in modifyIORef ((x, y):) >> return y)
14:10:06 <Tuplanolla> Could you use an `MVar` instead?
14:10:49 <jared-w> Can't you basically always use an MVar instead of an IORef and vice versa?
14:11:01 <mniip> no
14:11:09 <mniip> MVar is a semaphore among other things
14:11:20 <jared-w> oh, right, that's what I was thinking about
14:11:34 <mniip> a one-element queue really
14:11:45 * jared-w read too many articles at the same time when using a semaphore in his program and lumped everything together mentally
14:12:10 <johnw> quemavars!
14:12:27 <mniip> qemu wars?
14:12:35 <johnw> queue semaphore variables
14:12:52 <mniip> simultaneously Hoare and Dijkstra?
14:12:57 <johnw> yeah
14:12:59 <geekosaur> Pamelloes, no
14:13:31 <mniip> johnw, add a mutex for good measure
14:13:46 <johnw> quemetexars!
14:13:47 <geekosaur> all it does is replace the default ghci behavior of invoking 'print' on a result with a user specified function
14:16:09 <mniip> johnw, Hijkre or Doastra?
14:16:39 <jared-w> mniip: he said yeah :p
14:17:48 <mniip> > intercalate "no" $ map return "yeah"
14:17:50 <lambdabot>  "ynoenoanoh"
14:18:40 <Pamelloes> geekosaur: damn :/
14:19:02 <Pamelloes> Back to messing around with pipes I guess
14:19:51 <johnw> pipes are fun though
14:20:18 <Pamelloes> Yeah.....
14:20:45 <geekosaur> might poke at how -fexternal-interpreter works
14:23:57 <Pamelloes> Ooh, that's cool. I think a bit overkill for my usage, but definitely good to know about.
14:25:05 <quaete> how can i iterate over a list of lists ? e.g. [[Int]]
14:25:25 <hpc> by iteratively iterating ;)
14:25:38 <hpc> > map (map (+5)) [[1,2],[3,4]]
14:25:40 <lambdabot>  [[6,7],[8,9]]
14:26:48 <quaete> hpc: and how would i use that in a method ? (x:xs) only gives me the 1st lists if I'm not mistaken, maybe (x:xs:xss)?
14:30:42 <erisco> quaestor, what is a method?
14:30:48 <mniip> quaete, what are you trying to do on larger scale
14:31:05 <jle`> (x:xs):xss would match on a non-empty list of lists, whose first item is a non-empty list
14:31:15 <quaete> a function i guess erisco, func :: [[Int]] -> True
14:31:32 <erisco> is True a type?
14:31:38 <quaete> sorry
14:31:43 <quaete> I ment Bool obviously
14:32:09 <erisco> are you asking how you would pattern match the first element of the first list?
14:32:56 <quaete> erisco: if I have [Int], I can do (x:xs), while x is the first element and xs is the rest. how can I achieve that behaviour when i have [[Int]] ?
14:33:20 <erisco> it is the same thing, and x will be the first list
14:33:32 <quaete> yeah
14:33:42 <quaete> I guess I can use head x then?
14:33:56 <erisco> read jle`
14:35:43 <mniip> is it possible to {-# DEPRECATED #-} an instance
14:35:51 <mniip> or, to make things worse, a derived instance
14:36:09 <erisco> lol
14:36:36 <quaete> I want to check if on a [[Int]] a number appears twice in each respective list mniip 
14:37:07 <johnw> nshepperd: found a way to semi-sort a list, encodable for SMT
14:37:07 <quaete> mniip: I could split the functions up into two parts but I think there is a better way
14:37:12 <erisco> give an example for True and another for False
14:37:35 <quaete> [[1,2,1][3,2,1]] is False
14:37:47 <quaete> [[1,2,3],[3,2,1]] is True
14:37:51 <quaete> missed a , there
14:37:57 <mniip> quaete, you could use 'any'
14:38:33 <mniip> check xss = not $ any containsDuplicates xss
14:38:37 <mniip> where 'containsDuplicates' checks a single list only
14:38:42 <erisco> so, is it False if any sublist contains exactly two of any number?
14:39:16 <quaete> erisco: any sublist contains more than one count of the number, if that is understandable
14:39:47 <mniip> :t not . any ((/=) <*> nub)
14:39:48 <quaete> mniip: like I said I think there could be an easier way than splitting up the function
14:39:48 <lambdabot> (Eq a, Foldable t) => t [a] -> Bool
14:40:06 <mniip> quaete, depends on how you want to write it
14:40:07 <erisco> first write the function which determines if all elements of a list are unique
14:40:28 <erisco> then, you can apply this function to every list in a list of lists, giving you a list of Bool
14:40:55 <mniip> TIMTOWTDI
14:40:58 <quaete> alright I didn't want to do it that way erisco but I guess I'll just stick to it
14:41:03 <erisco> this list can then be folded with || or && depending on what you're looking for
14:41:23 <erisco> which is aliased as "any" or "all"
14:41:47 <erisco> :t (any, or, and, all)
14:41:48 <lambdabot> (Foldable t4, Foldable t3, Foldable t2, Foldable t1) => ((a1 -> Bool) -> t1 a1 -> Bool, t2 Bool -> Bool, t3 Bool -> Bool, (a2 -> Bool) -> t4 a2 -> Bool)
14:41:48 <mniip> quaete, ok, if you want to do it explicitly,
14:41:57 <mniip> you can pattern match on a list of lists like this
14:42:01 <mniip> ((x:xs):xss)
14:42:16 <mniip> x is the head of the head, xs is the tail of the head, and xss is the tail
14:42:42 <mniip> but even if pattern matching, I still would rather deal with the outer list separately
14:43:13 <mniip> otherwise you have to perform awkward recursion like f ((x:xs):xss) -> f (xs:xss)
14:43:25 <erisco> it is clearly orthogonal, i.e. what you do with the list of lists versus the list of numbers
14:44:16 <mniip> erisco, almost as if there was some way to work on the elements of lists ignoring the fact that they're wrapped in a list
14:44:47 <erisco> one can dream
14:49:00 <mniip> so!
14:49:08 <mniip> can comma categories be represented in the Hask framework
14:49:36 <mniip> I don't feel like they can as that basically involves using another category's morphisms as objects,
14:49:51 <mniip> and in Hask objects live on the type level and morphisms on value level
14:50:11 <mniip> but then
14:50:16 <mniip> functor categories are a thing
14:50:28 <mniip> 2->C is essentially an arrow category
14:51:21 <mniip> NT 2 C is representable in Hask but then it's awkward to "instantiate"
14:54:22 <mniip> we could borrow objects of NT 2 C,
14:55:52 <siwica> How can I configure Stack to always use the latest Version of GHC?
14:56:32 <glguy> siwica: probably not
14:57:17 <siwica> Or at least the latest "safe" version
15:29:50 <cscalfani> If Profunctor is a Bifunctor that contravariant in the first parameter and covariant in the second, what's type of Functor is covariant in the first and contravariant in the second?
15:32:32 <Tuplanolla> It's just `Profunctor` with the parameters flipped, cscalfani.
15:32:54 <Tuplanolla> There's nothing interesting in it.
15:33:45 <cscalfani> Thanks Tuplanolla. That's what I thought but it seemed too simple to be true :-)
15:35:13 <MarcelineVQ> though I do think  https://hackage.haskell.org/package/invariant-0.4.3/docs/Data-Functor-Invariant.html  is neat
15:46:11 * hackage lenz 0.2.2.0 - Van Laarhoven lenses  https://hackage.haskell.org/package/lenz-0.2.2.0 (MatthewFarkasDyck)
15:51:45 * hackage lenz 0.2.2.1 - Van Laarhoven lenses  https://hackage.haskell.org/package/lenz-0.2.2.1 (MatthewFarkasDyck)
15:53:10 <barrucadu> Yet another lens library?
16:02:25 <lyxia> with unicode
16:02:38 <erisco> y'all
16:09:22 <pierrot> How would you construct a record from a [Flag] of command line arguments?
16:12:07 <pierrot> I've done it in an ugly way that doesn't scalate
16:16:44 <ezyang> @tell orion Many, many cases. It makes more sense to ask under what situations you should use Backpck 
16:16:44 <lambdabot> Consider it noted.
16:17:05 <barrucadu> pierrot: If your record is a monoid, you could do something like `foldl' (\record flag -> record <> flagToRecord flag) mempty flags`
16:17:34 <barrucadu> Has the property that later flags can override earlier ones, which is fairly common behaviour
16:19:57 <pierrot> and the monoid neutral `mempty` would be the default settings ?
16:21:18 <ggVGc> wow, I just switched to using haskell-ide-engine, with vim-lsp as the frontend
16:21:24 <ggVGc> it's pretty great
16:21:28 <ggVGc> compared to anything else I tried
16:21:35 <barrucadu> pierrot: Yeah
16:21:37 <Pamelloes> Is there a function Monoid a => Maybe a -> a which maps nothing to mempty?
16:21:39 <ggVGc> I was using intero for the past weeks, and it was pretty slow
16:21:49 <barrucadu> @type fromMaybe mempty
16:21:50 <lambdabot> Monoid a => Maybe a -> a
16:21:50 <ggVGc> haskell-ide-engine is top notch so far
16:21:55 <jd823592> Hi, how would one install ghc-8.2.1 on nixos?
16:22:11 <infinisil> ggVGc: have you compared it to ghc-mod? I'm using that right now and it's pretty great
16:22:45 <ggVGc> infinisil: I used ghc-mod for a long time in the past, but I got sick of the fragility of it
16:22:55 <ggVGc> are you successfully using it with stack projects?
16:23:04 <infinisil> that's what i actually have problems with too..
16:23:12 <infinisil> it randomly decides to not work
16:23:54 <ggVGc> it's not random
16:24:03 <ggVGc> it relies on your system ghc matching your project ghc
16:24:08 <ggVGc> which kind of doesnit work well with stack
16:24:20 <ggVGc> infinisil: intero works well with stack, but is neovim only
16:24:23 <infinisil> no then it's something different
16:24:33 <ggVGc> and personally I don't want to switch to neovim
16:24:35 <MarcelineVQ> it works fine. you run stack build ghc in your project and bam you have a ghc-mod of the right version in your project path
16:24:42 <MarcelineVQ> *stack build ghc-mod
16:24:54 <MarcelineVQ> it's lame needing to do this though
16:25:30 <pierrot> barrucadu: Thanks. 
16:25:52 <infinisil> I have some instability with ghc-mod where it shows up a syntax error of a previous version of the file, like I type "let .." and it shows that "l" is not a valid identifier
16:26:03 <infinisil> Using emacs frontend
16:26:08 <pierrot> There's something that is not considered by System.Console.GetOpt and is that some options can be mandatory
16:26:16 <infinisil> I need to ghc-kill-process and reload to make it work again
16:26:41 <infinisil> cc ggVGc 
16:27:06 <infinisil> not using stack anyways
16:28:17 <pierrot> barrucadu: what's the `<>' operator in `record <> flagToRecord flag' ?
16:28:42 <barrucadu> pierrot: mappend
16:31:06 <pierrot> oh, I didn't know that. Thanks
16:33:55 <ggVGc> infinisil: well, so far vim-lsp with haskell-ide-engine is causing no problems. And I can go into any file in any stack project and goto-definition instantly works. And the LspHover command instantly gives me the type of something, and tells me where it's defined (if not local)
16:34:03 <ggVGc> I haven't had remotely near this experience with any other tool
16:35:34 <infinisil> ggVGc: All of that instantly sounds really nice, i'm not sure how i can have 2 haskell projects open in emacs for now
16:36:20 <ggVGc> only thing I miss from ghcmod and intero atm is "Insert type of expression"
16:36:26 <ggVGc> but I can fairly easily script that I think
16:40:13 <athan_> How does a difference list compare to a vector? Are vectors low level bindings, while dlists are actually implemented structurally in haskell or something?
16:44:53 <johnw> athan_: a dlist is a function that, gives a list, returns a list; this turns appending into composition, which is really, really fast
16:45:02 <johnw> there is no connection to vectors
16:45:12 <johnw> there is no "implemented structurally"
16:45:47 <EvanR> setting up compositions yet to be evaluated, yeah, sounds fast :)
16:45:50 <johnw> i guess you should construct that to "a function that, giving a list, appends it to the list it would have returned if you'd passed nil"
16:45:55 <johnw> s/construct/revise
16:46:28 <EvanR> at one point "different list" was a thing that was supposed to compare to vectors
16:46:43 <johnw> (\xs -> "Hello " ++ xs) . (xs -> "World" ++ xs) $ []
16:46:51 <johnw> EvanR: ah
16:46:52 <EvanR> thats what i remember. now it refers to the "endo builder trick"
16:47:37 <johnw> or "cayley representation of a monoid" :)
16:48:20 <Pamelloes> If I have a ByteString which contains an ASCII encoded number, what would be the best way to parse it?
16:48:46 <Axman6> I think attoparsec has parsers for that already
16:49:00 <johnw> one way: read . unpack . decodeUtf8
16:49:19 <lyxia> Pamelloes: https://hackage.haskell.org/package/bytestring-0.10.8.2/docs/Data-ByteString-Char8.html#v:readInt
16:49:41 <Axman6> if not, PArsers might give you the interface to attoparsec which does
16:49:50 <Axman6> Parsers*
16:50:04 <Pamelloes> lyxia: That's close, but the numbers are going to be floating point
16:50:48 <Pamelloes> johnw: Does the read implementation for, say, Double account for localisation issues?
16:51:02 <EvanR> i demand a full list of known requirements :)
16:51:14 <johnw> Pamelloes: i have no idea
16:51:26 <Axman6> I doubt it
16:51:29 <johnw> once floating point gets involved, I doubt everything
16:51:35 <Pamelloes> :/
16:51:50 <Axman6> what localisation issues would there be?
16:51:59 <EvanR> you can write your own parser as a series of -> Maybe X functions
16:52:03 <EvanR> and monad them together
16:52:24 <erisco> just monad that
16:52:24 <EvanR> -> Maybe (X, ByteString)
16:52:40 <johnw> "monad them together", I love it
16:52:40 <Axman6> https://hackage.haskell.org/package/attoparsec-0.13.2.0/docs/Data-Attoparsec-ByteString-Char8.html#g:14
16:52:50 <Pamelloes> Axman6: Some countries use "," and some use "." to separate the integer and fractional components of a decimal number
16:53:27 <EvanR> i question the wisdom of the source of this data
16:53:36 <Axman6> Pamelloes: I don't know of any aprser library which supports anything but using . for the decimal point, because basically all programming languages use that format
16:54:16 <Pamelloes> whelp
16:54:19 <Axman6> but, you could write your own parser quite easily which supports the formats you want
16:54:32 <johnw> The commodities library will read either format, and tell you if the amount was encoded as european or not
16:54:34 <EvanR> :t encodeFloat
16:54:35 <lambdabot> RealFloat a => Integer -> Int -> a
16:54:51 <EvanR> all you need is to get the mantissa and the exponent somehow, then encodeFloat
16:55:08 <johnw> oh, never mind, I never actually wrote that parser
16:55:58 <EvanR> > encodeFloat 128 3
16:56:00 <lambdabot>  1024.0
16:56:06 <EvanR> > encodeFloat 64 4
16:56:07 <lambdabot>  1024.0
16:56:34 <EvanR> (i guess getting mantissa from a base 10 piece of text is non trivial. in which case maybe you really want Scientific)
16:57:01 <Pamelloes> eek
16:57:43 <EvanR> theres a fundamental schism between floats and the way we think of scientific notation numbers
16:57:57 <EvanR> base 2 vs base 10
16:59:32 <infinisil> people should just adapt hexadecimal goddamnit
16:59:41 <dmwit> :t fold -- Pamelloes, your question from 40 minutes ago
16:59:42 <lambdabot> (Monoid m, Foldable t) => t m -> m
17:00:05 <dmwit> (N.B. `Foldable Maybe`)
17:00:41 <Pamelloes> dmwit: Ooh that's cool
17:01:24 <EvanR> printf and scanf do let you use hex in C...
17:01:33 <EvanR> makes me feel better about transferring floats over text
17:01:49 <EvanR> but i just tried to write decodeFloat in C and failed... hmmm
17:03:00 <ggVGc> hah..
17:04:08 <ggVGc> I'm about to write some currency handling functions of something along the lines of CurrencyAction -> Maybe Currency, for my little trading bot, because I've already had some rounding issues..
17:05:17 <EvanR> > 1 / 3 :: Pico
17:05:19 <lambdabot>  0.333333333333
17:05:26 <EvanR> perfect
17:05:56 <ggVGc> :(((
17:07:40 <EvanR> i recommend you write the trading engine using floats, but arrange for any rounding errors to be sent me to my account
17:07:51 <EvanR> s/me//
17:08:44 <Pamelloes> If EvanR's account doesn't seem to work, I can supply mine as well :)
17:09:03 * ggVGc supplies some negative deposits to both accounts
17:09:25 <Pamelloes> Joke's on you, you can't steal money from my account if there's no money in it to begi with.
17:09:27 <EvanR> type error, money is never negative
17:09:28 <Pamelloes> *begin
17:09:46 <EvanR> you have to put parentheses around it
17:10:13 <Pamelloes> So money is a dependant type, huh
17:10:29 <EvanR> o_O
17:10:41 <Welkin> you can buy a money tree
17:22:28 * hackage hosc 0.16 - Haskell Open Sound Control  https://hackage.haskell.org/package/hosc-0.16 (RohanDrape)
17:24:53 <Pamelloes> Is there a clean way of writing this: (l V.! (V.length l `div` 2) + l V.! ((V.length l `div` 2) - 1)) / 2
17:25:08 <Pamelloes> (calculating the median for an even size list)
17:25:43 <EvanR> you can factor out length l `div` 2 using a let
17:25:54 <EvanR> you can use ! instead of V.!
17:26:15 <athan_> Pamelloes: chop it in half, reverse the first, then pluck the two heads?
17:26:15 * hackage hsc3 0.16 - Haskell SuperCollider  https://hackage.haskell.org/package/hsc3-0.16 (RohanDrape)
17:26:28 <EvanR> you can save the two arguments to the final avergae to variables using lets
17:27:02 <EvanR> unfortunately reversing a vector wont be cheap
17:27:40 <EvanR> fortunately last is cheap
17:27:49 <Pamelloes> Factoring out the length / 2 in a let definitely makes it a lot cleaner
17:29:05 <Welkin> make it dirtier
17:29:08 <Welkin> what's wrong with dirt?
17:29:20 <Welkin> dirt brings life
17:31:32 <Lauda> https://pastebin.com/raw/mhtXnLhm Anyone have a idea how to use this?
17:32:58 <slack1256> checkSomething syntax = Data.List.all (== 9) $ syntax 8
17:33:08 <Welkin> o.o
17:33:37 <Lauda> Now if I only understood that heh
17:33:42 <slack1256> at least there is a function with that signature
17:34:59 <Welkin> a function :: Num a => a -> Bool
17:35:00 <Welkin> sure
17:35:07 <Welkin> er
17:35:43 <Welkin> a function :: (Num a, Num b) => (a -> b) -> Bool
17:35:47 <Welkin> may even be more general than that
17:36:01 <Lauda> o_o
17:36:04 <Welkin> oh wait
17:36:18 <Welkin> (Num a, Num b) => (a -> [b]) -> Bool
17:36:30 <Welkin> may as well just ask lambdabot 
17:36:52 <Welkin> :t \syntax -> Data.List.all (== 9) $ syntax 8
17:36:54 <lambdabot> (Num t2, Num a, Eq a, Foldable t1) => (t2 -> t1 a) -> Bool
17:36:57 <Welkin> there we go
17:36:59 <Welkin> close enough
17:38:58 <Pamelloes> Hmmm.... Not sure if this is any cleaner: (\x y -> (x + y)/2) . (last *** head) . V.splitAt (V.length l `div` 2) $ l
17:39:07 <Welkin> oh god no
17:39:12 <Welkin> don't reach for Control.Arrow
17:39:16 <Welkin> that's when you know you have gone too far
17:39:23 <Lauda> lol
17:39:28 <Pamelloes> heheh
17:39:37 <Welkin> stop trying to write a point-free one-liner
17:39:45 <Welkin> make it legible, easy to understand
17:40:14 <Welkin> you can use `let ... in ...` to help
17:40:28 <Pamelloes> Believe it or not, that was my goal---I was annoyed with how illegible my original statement was
17:41:03 <Lauda> I am rather confused.
17:41:33 <Welkin> Lauda: of course
17:41:48 <Welkin> :t fmap . fmap . fmap
17:41:50 <lambdabot> (Functor f3, Functor f2, Functor f1) => (a -> b) -> f1 (f2 (f3 a)) -> f1 (f2 (f3 b))
17:41:51 <Welkin> there you go
17:42:04 <Lauda> ?
17:43:02 <APic> Uh oh.
17:43:08 <Welkin> Ljust a bit of fun
17:43:12 <Welkin> Lauda: just a bit of fun
17:43:19 <Gurkenglas> Pamelloes, (`div` 2) . sum . (let m = div (V.length l) 2 in V.slice m (m+1)) $ l
17:44:40 <Welkin> a pickle jar is talking to a citrus fruit
17:44:50 <Gurkenglas> not that there's any difference between lambdas and let
17:45:06 <Welkin> cucumber jar*
17:45:18 <Welkin> unless you are pickled, Gurkenglas 
17:45:51 <Gurkenglas> lemme check - looks like.
17:46:09 <APic> Nom nom nom.
17:46:52 * hackage hosc-json 0.16 - Haskell Open Sound Control JSON Serialisation  https://hackage.haskell.org/package/hosc-json-0.16 (RohanDrape)
17:47:15 <Pamelloes> Gurkenglas: I literally just came up with that exact same solution and was all excited to share it.
17:47:18 <Pamelloes> Whelp
17:48:50 <Pamelloes> Great minds think alike, though :)
17:49:01 <Gurkenglas> Pamelloes, (`div` 2) . sum . V.take 2 . V.drop (div (V.length l) 2 - 1) $ l needs less naming
17:49:30 <ggVGc> Gurkenglas: well, there's a difference in indentation :)
17:49:52 * hackage hmt 0.16 - Haskell Music Theory  https://hackage.haskell.org/package/hmt-0.16 (RohanDrape)
17:53:26 <Pamelloes> The second parameter of splice is length not index, actually, so the first solution is still viable
18:09:48 * hackage hly 0.16 - Haskell LilyPond  https://hackage.haskell.org/package/hly-0.16 (RohanDrape)
18:15:41 * hackage hps 0.16 - Haskell Postscript  https://hackage.haskell.org/package/hps-0.16 (RohanDrape)
18:17:26 * hackage hcg-minus 0.16 - haskell cg (minus)  https://hackage.haskell.org/package/hcg-minus-0.16 (RohanDrape)
18:20:44 <questro> lets say I have a function createnew :: Int -> TypeX - how can I create a new "object" of TypeX with the paramter being the Int ?
18:21:18 <jle`> questro: it depends on what API TypeX offers
18:21:46 * hackage hcg-minus-cairo 0.16 - haskell cg (minus) (cairo rendering)  https://hackage.haskell.org/package/hcg-minus-cairo-0.16 (RohanDrape)
18:21:52 <jle`> questro: check out the documentation for the library that offers it
18:21:59 <jle`> without knowing this, we can't answer any further
18:22:12 <questro> jle`: wait let me be try to word it a bit better
18:22:21 <jle`> usually if a library offers a type, it gives you ways to create values of that type
18:22:35 <jle`> if you have a specific type in mind, we can handle that specific case :)
18:22:47 <jle`> for example, createnew :: Int -> Bool, you'd use one of the Bool constructors, True or False
18:23:07 <questro> I have a type X, type X is usually declared like this: abc::X abc pos1 = 1, abc pos2 = 3
18:23:07 <lyxia> I though questro was asking about how to apply createNew
18:23:23 <questro> now i know what pos1 and pos2 is supposed to be
18:23:42 <questro> but I have to write a function which declares a new object of X with the values for pos1 and pos2
18:23:47 <lyxia> createNew pos1, createNew pos2
18:24:00 <jle`> oh i see, you weren'ta sking about how to write creatnew, you were asking about how to *use* it
18:24:02 <jle`> my bad
18:24:29 <jle`> questro: also i'm not sure how what you wrote can be considered a type declaration
18:24:41 <jle`> the syntax seems a bit foreign or unusual to me
18:24:45 <jle`> is it haskell?
18:24:49 <questro> yes 
18:24:58 <questro> I'm trying to simplify my problem jle` 
18:25:15 <jle`> i don't think there is any way to interpret that as haskell code, heh, so i'm not sure what you're doing exactly
18:25:36 <questro> I can write the whole explanation if you want me to jle` 
18:25:38 <jle`> but you can use 'createnew' by just giving it an Int, like 'createnew 4', or 'createnew 10'
18:25:51 <jle`> questro: you can give a simplified problem that is valid haskell maybe? :)
18:26:20 <questro> alright lets try that
18:26:41 <jle`> but yeah, if you have 'createnew', you can create new TypeX's by applying createnew to Int's, like `createNew 4 :: TypeX`
18:27:58 <questro> I have data Nodes = N1 | N2 | N3, and type Graph = Nodes -> [Nodes]; usually I would declare the variable like this: a::Graph, a N1 =[N2,N3], a N2 = [N3], a N3 = [N1]
18:28:43 <questro> now I have an adjacency list looking like [[N2,N3],[N3],[N1]]
18:29:11 <questro> and I want a function a :: [[Nodes]] -> Graph
18:29:38 <questro> which takes the adjacency list and executes them like a::Graph, a N1 =[N2,N3], a N2 = [N3], a N3 = [N1]
18:29:58 <questro> that's basically what I had in mind
18:30:39 <jle`> so it's a little confusing here because you're naming two different things 'a'
18:30:43 <jle`> but from what i think you're trying to say
18:30:52 <questro> yeah I realised that as soon as i pushed enter
18:31:04 <jle`> you're trying to make some fromAdjList :: [[Nodes]] -> Graph
18:31:12 <questro> yes
18:31:23 <jle`> so that fromAdjList [[N2, N3], [N3], [N1]] == your original 'a'
18:31:34 <questro> exactly
18:32:01 <jle`> a simple way to do this would be to just index into the adjacency list
18:32:12 <jle`> fromAdjList l N1 = l !! 0
18:32:14 <jle`> etc.
18:32:44 <questro> idk how long the adjList is sadly jle` 
18:32:58 <jle`> but N1 will always refer to the first item, right?
18:33:04 <questro> yes jle` 
18:33:12 <jle`> and N2 will always refer to the second
18:33:12 <questro> the first node 
18:33:15 <questro> yes
18:33:29 <jle`> what should happen when the user gives a list that is too short?
18:33:42 <questro> well it can be just two nodes
18:33:47 <questro> [[N2],[N1]]
18:33:51 <questro> is valid
18:34:53 <jle`> but what happens when the user calls fromAdjList [[N2],[N1]] N3 ?
18:34:58 <questro> what I have trouble with is how I create a object of type Graph inside my function to return that jle` 
18:35:09 <jle`> well Grahp is just a type synonym
18:35:19 <jle`> so fromAdjList :: [[Nodes]] -> Graph
18:35:32 <questro> fromAdjList [[N2],[N1]] N3 wont work since those are two inputs 
18:35:32 <jle`> is really just fromAdjList :: [[Nodes]] -> Nodes -> [Nodes]
18:35:58 <jle`> so you're really just writing a [[Nodes]] -> Nodes -> [Nodes]
18:36:20 <jle`> "how to create a value of type Graph" is "how to create a value of type Nodes -> [Nodes]"
18:36:27 <jle`> and you'd make one just like you'd make any other function in Haskell :)
18:36:35 <jle`> using lambdas, or function declaration syntax, etc.
18:36:55 <jle`> if you want to be more explicit, you could do something like:
18:37:04 <jle`> fromAdjList l = newGraph
18:37:06 <jle`>   where
18:37:12 <jle`>     newGraph N1 = l !! 0
18:37:25 <jle`> newGraph there is a Nodes -> [Nodes] function, like you want
18:37:59 <typedrat> I have an accelerate question
18:38:05 <jle`> newGraph :: Graph there (which is the same as newGraph :: Nodes -> [Nodes])
18:38:37 <lyxia> typedrat: does it have an easy answer
18:40:01 <typedrat> I don't know. :P What's the best way to fill a certain chunk of an array with random numbers? Is it best to just construct it in Haskell and then `use` it?
18:40:17 * hackage hsc3-dot 0.16 - haskell supercollider graph drawing  https://hackage.haskell.org/package/hsc3-dot-0.16 (RohanDrape)
18:42:10 <jle`> just allocate an array and don't clear it hehe
18:43:10 <typedrat> I'm using it for LA stuff with accelerate-blas, and I have an array of matrices (really, `Array DIM3`) that is representing a bunch of matrices that have either random numbers or zero as the elements
18:43:39 <typedrat> In different shapes each time
18:50:56 <questro> alright jle` I don't know how to do what you told me, if I write makeGraph :: [[Nodes]] -> Graph, makeGraph (n:ns) = "what goes in here ?" it's obvious I have to call g N1 = x, but where do I get that g (being a Graph) from ?
18:51:21 <questro> It's not like I'm not trying
18:51:33 <questro> it's just hard for me to understand on how to return something from inside the function
18:51:41 <questro> like you would do in java
18:52:12 <APic> Java is more imperative and less functional than Haskell, which is the other Way round.
18:54:38 <siwica> Haskell apparently "desugars" quite a few constructs under the hood. Is there a possibility for ghc to only output that desugared version of the code and to not actually compile it?
18:59:10 <lambdamu_> siwica: ghc has a bunch of -ddump-... flags that can output various intermediate represenations, e.g. template-haskell splices, core, stg, cmm
18:59:37 <lambdamu_> siwica: If you do not want to compile anything you could try -fno-code
19:00:15 <lambdamu_> siwica: Althought I'm not sure how well -fno-code works, but the -ddump flags are much used
19:01:14 <siwica> Ah, thanks! I will try this out right away
19:01:30 <siwica> Is there a good article on the different intermediate representations?
19:02:07 <lambdamu_> siwica: http://www.aosabook.org/en/ghc.html is a good start
19:03:10 * hackage moesocks 1.0.0.43 - A functional firewall killer  https://hackage.haskell.org/package/moesocks-1.0.0.43 (JinjingWang)
19:03:18 <lambdamu_> siwica: For details I consult the GHC wiki usually, or read the source code notes which are rather expansive
19:03:36 <siwica> Perfect, thank you!
19:10:56 <questro> jle`:  thanks for the help, I solved it now
19:11:38 <siwica> lambdamu_: Hm, seems -ddump-<pass> doesn't work together with -fno-code
19:12:25 <siwica> I have yet to find a way to only print the intermediate version to stdout and to ommit the generation of any files
19:13:31 <lambdamu_> siwica: Hm yes that might be, those flags are a bit conflicting instructions, no-code basically means just type check my code, afaik so anything beyond cpp and template-haskell execution won't be necessary
19:14:23 <lambdamu_> siwica: GHC won't say ah normally I wouldn't do anything now, but since core was requested I will at least generate that
19:15:06 <lambdamu_> siwica: -ddump-<pass> are debug options without real effect
19:16:42 <siwica> ok, I see! Well, I can just wrap the whole thing in a script to clean up afterwards. But it would be cool if ghc could do this by itself
19:16:52 <siwica> Maybe I'll ask on the mailing list
19:17:27 <lyxia> siwica: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/flags.html#keeping-intermediate-files ?
19:18:21 <lyxia> or set all output directories to a temporary folder
19:18:27 <lambdamu_> siwica: Depending on how you invoke ghc you can always redirect to /dev/null
19:19:40 <siwica> ok! There is -no-keep-hi-files -no-keep-o-files
19:19:48 <lambdamu_> siwica: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/flags.html#which-phases-to-run https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/flags.html#redirecting-output
19:20:33 <monochrom> Oh w00t GHC 8.2.2
19:20:46 <siwica> Thanks! A combination of all this should do it
19:21:20 * hackage sort-by-pinyin 2017.10.18 - Sort Simplified Chinese by PinYin  https://hackage.haskell.org/package/sort-by-pinyin-2017.10.18 (JinjingWang)
19:23:10 * hackage qr-imager 1.0.1.3 - Library to generate QR codes from bytestrings and objects  https://hackage.haskell.org/package/qr-imager-1.0.1.3 (vmchale)
19:44:02 <rwarfield> Is this an accurate statement (in the context of type level programming? "A function's type signature and body must always collectively provide the compiler enough information to determine the return type of the function for any valid parameterization of the inputs, without requiring any information about the inputs other than their types."
19:46:41 <Pamelloes> Given x :: Double, GHc correctly determines (\a -> a - x) has type Double -> Double, but for some reason it does not make the same inference when I just write (- x). WHat's going on?
19:47:33 <Pamelloes> Oh crap, it thinks I'm saying (-1) * x, doesn't it....
19:47:42 <lambdamu_> Pamelloes: yup
19:49:27 <monochrom> @type let {x :: Double; x = 5} in (- x)
19:49:28 <lambdabot> Double
19:49:35 <monochrom> worksforme
20:16:10 <Pamelloes> I have a list of functions [a -> a]. Is there a quick way to sequentially compose them? e.g. turn [(+ 10), (+ 5), (* 2)] into (+ 10) . (+ 5) . (* 2).
20:16:38 <Pamelloes> My naive attempt was to use mconcat, but that didn't work.
20:17:17 <athan> foldr . id xs ?
20:17:27 <athan> wait
20:17:38 <athan> @type foldr (.) id
20:17:39 <lambdabot> Foldable t => t (b -> b) -> b -> b
20:17:45 <pierrot> how can I `putStrLn' a string iff some condition `cond' holds? `main = do { if cond then putStrLn message else putStr "" }` would work but it's ugly
20:17:48 <ggVGc> name one reason foldl exists
20:18:09 <ggVGc> why isnit foldl just strict, and foldl' not existing
20:18:16 <athan> @src product
20:18:16 <lambdabot> product = foldl (*) 1
20:18:20 <athan> >:D
20:18:28 <tabemann> don't use product
20:18:32 <ggVGc> ^
20:18:39 <tabemann> @src sum
20:18:39 <lambdabot> sum = foldl (+) 0
20:18:44 <tabemann> same thing there
20:18:47 <ggVGc> I mean, foldl is really crap
20:18:51 <athan> ...for internal artwork? :D
20:19:24 <jle`> pierrot: mconcat is close and might have worked if the default Monoid instance for functions was (.)
20:19:27 <jle`> * Pamelloes 
20:19:28 <athan> quick maths
20:19:41 <jle`> Pamelloes: but you can achieve this with a newtype wrapper as well :)
20:20:08 <jle`> > appEndo (mconcat [Endo (+ 10), Endo (+ 5), Endo (* 2)]) 5
20:20:10 <lambdabot>  25
20:20:59 <jle`> mconcat [Endo (+ 10), Endo (+ 5), Endo (* 2)] = Endo ((+ 10) . (+ 5) . (* 2))
20:21:03 <ggVGc> so, why is sum implemented with foldl and not foldr?
20:21:16 <jle`> sum should be implemented with foldl'
20:21:27 <ggVGc> agree
20:21:44 <ggVGc> but wouldn't a lazy sum be useful?
20:21:51 <ggVGc> a lazy foldr sum
20:22:27 <Pamelloes> Then wouldn't a lazy product be equally useful?
20:22:38 <ggVGc> sure
20:22:45 <Welkin> no
20:22:46 <ggVGc> but a lazy stack-exploding one isn't
20:22:53 <jle`> it would be useful in certain situations for some types probably
20:22:57 <jle`> as a foldr
20:22:59 <Welkin> (+) is strict in both parameters
20:23:01 <Welkin> so is (*)
20:23:03 <Welkin> for good reason
20:23:08 <Pamelloes> jle`: What's the default monoid implementation of functions?
20:23:21 <jle`> but for the 'vast majority' of Num instances, sum/product would probably make more sense strictly
20:23:25 <ggVGc> so why is sum and product implemented with foldl
20:23:33 <ggVGc> actually, again, is there a single legitimate use of foldl
20:23:33 <jle`> Pamelloes: it gives a new function that mconcats the results of both
20:23:37 <Welkin> ggVGc: should be foldl'
20:23:37 <ggVGc> I'm really wondering
20:23:49 <jle`> > (reverse <> take 3) "hello"   -- Pamelloes 
20:23:51 <lambdabot>  "ollehhel"
20:24:21 <Pamelloes> Interesting.
20:24:21 <jle`> (f <> g) x = f x <> g x
20:24:25 <Welkin> is that swedish?
20:24:38 <ggVGc> could be
20:24:46 <jle`> it's especially useful for merging comparison functions
20:24:54 <Pamelloes> Ooooh
20:24:59 <jle`> that's the usual example people give
20:25:13 <Pamelloes> I was just trying to figure out a reason why that implementation is useful. That makes a lot of sense.
20:25:41 <Welkin> you got functions in my functions
20:25:58 <Welkin> you know you're using haskell when your types have types
20:32:51 <typedrat> In `accelerate`, is there a way to map an `f :: Array DIM2 e -> Array DIM2 e` over a dimension of `Array DIM3 e`? I've got a bunch of matrices, and I'm trying to apply the same operation to all of those matrices in parallel
20:32:51 <butterthebuddha> The lectures for CIS 194 don't seem to always cover enough material for the homeworks
20:33:10 <butterthebuddha> Is there a better resource for learning Haskell?
20:33:28 <Welkin> butterthebuddha: there is no single resource that covers everything you need at the moment
20:33:42 <Welkin> there are several books and blog posts that you can read though
20:34:07 <Welkin> CIS194 leans ehavily on books like Learn You A Haskell
20:34:10 <Welkin> heavily*
20:34:10 <Pamelloes> Huh, read and print are locale sensitive. That's super cool :)
20:34:14 <Welkin> and it links to many blog posts
20:35:55 <Axman6> Pamelloes: are you sure about that? they would have to run in IO (and print is just putStrLn . show)
20:36:11 <Axman6> > read "23,456e6" :: Double
20:36:13 <lambdabot>  *Exception: Prelude.read: no parse
20:36:50 <Axman6> > read "23,456" :: Integer
20:36:52 <lambdabot>  *Exception: Prelude.read: no parse
20:37:19 <pierrot> any suggestion for my question?
20:37:32 <inkbottle> In https://github.com/serras/emacs-haskell-tutorial/blob/master/tutorial.md, there are references to (expand-file-name "~/.cabal/bin"); but I use "stack", and therefore I do not have a ~/.cabal directory
20:37:42 <inkbottle> what wold be suitable instead?
20:37:49 <Welkin> butterthebuddha: I am working on a tutorial series for learning haskell by writing a video game and would love feedback on it. I haven't posted any of the lessons yet, but they'll be online soon. I assume zero knowledge of haskell or game programing at the beginning. Let me know if you are interested so I can send you a link when it's online later this week.
20:37:50 <Axman6> pierrot: when cond $ putStrLn "foo"
20:37:57 <Axman6> from Control.Monad
20:38:22 <Axman6> inkbottle: probably ~/.local/bin
20:38:34 <inkbottle> Axman6: OK, thanks
20:39:13 <Welkin> pierrot: what was your question?
20:39:35 <pierrot> Axman6: thanks, I dind't know about the existence of such function
20:39:50 <butterthebuddha> Welkin: sure!
20:39:50 <pierrot> Welkin: how can I `putStrLn' a string iff some condition `cond' holds? `main = do { if cond then putStrLn message else putStr "" }` would work but it's ugly
20:40:14 <Welkin> oh yeah, `when` and `unless` are useful
20:40:17 <mud> inkbottle: I think there are other guides with good support for stack, might want to go with one of those. I've heard a lot about intero, I think it handles quite a bit of editor nonsense. (I don't use it personally)
20:40:25 <jle`> pierrot: there is a "no-op" IO action, as well
20:40:43 <jle`> pierrot: it looks like you're trying to use `putStr ""` as a no-op
20:40:51 <jle`> but usually we use 'return ()'
20:40:54 <pierrot> jedws: indeed
20:40:56 <jle`> or 'return x', for a no-op that returns 'x'
20:41:04 <pierrot> ups, jle` *
20:41:12 <inkbottle> mud: OK, thanks, I'll look into it
20:41:32 <jle`> pierrot: this is pattern is kinda common so there's 'when'
20:41:36 <jle`> when True x = x
20:41:39 <jle`> when False _ = return ()
20:41:40 <pierrot> jle`: thanks for clarifying
20:41:53 <Axman6> @hoogle unless
20:41:53 <lambdabot> Control.Monad unless :: (Applicative f) => Bool -> f () -> f ()
20:41:53 <lambdabot> Distribution.Compat.Prelude.Internal unless :: Applicative f => Bool -> f () -> f ()
20:41:53 <lambdabot> Shelly unless :: Applicative f => Bool -> f () -> f ()
20:41:58 <Welkin> jle`: that reminds me of when I was doing some FRP with redux in javascript, and the way it was set up required me to produce some redux action, so I created a NOOP
20:42:04 <butterthebuddha> I'm super confused by exercise 6 of Hw 5: https://www.seas.upenn.edu/~cis194/spring13/hw/05-type-classes.pdf
20:42:30 <Pamelloes> Axman6: You're right. It looks like my program failed silently rather than parsing properly.
20:42:37 <inkbottle> mud: https://commercialhaskell.github.io/intero/; looks interesting
20:43:04 <hodapp> intero is nice; I've used it (albeit a year or two ago)
20:43:36 <mud> inkbottle: Ya, a lot of people seem to like it. I use vim so I never looked all that close.
20:45:11 <inkbottle> hodapp: why did you stopped using it? did you switched to sth else?
20:45:28 <hodapp> wasn't using Haskell as much
20:45:39 <inkbottle> OK
20:45:40 <Welkin> butterthebuddha: I remember doing exercise 5 instead when I did that lesson :P
20:45:56 <Welkin> butterthebuddha: but it wants you to create a typeclass and use a Map to store your variables
20:46:12 * hackage skylighting 0.4.4 - syntax highlighting library  https://hackage.haskell.org/package/skylighting-0.4.4 (JohnMacFarlane)
20:46:28 <butterthebuddha> So I'm stuck with implementing this - "instance HasVars (M.Map String Integer -> Maybe Integer)"
20:53:39 <jle`> butterthebuddha: what methods does HasVars have?
20:54:24 <butterthebuddha> A single method: "var :: String -> a"
20:56:48 <Welkin> I agree it is confusing
20:57:02 <Welkin> it is not explained where this Map of variables comes from until the final page
20:57:08 <Welkin> and it is just some random function they come up with
21:09:19 * hackage haskell-tools-ast 1.0.0.0 - Haskell AST for efficient tooling  https://hackage.haskell.org/package/haskell-tools-ast-1.0.0.0 (lazac)
21:10:01 <aconz2> random thought today: could we do away with function names if we new-typed the heck out of function types instead?
21:10:44 <Welkin> what do you mean?
21:10:57 <jle`> aconz2: that's kind of like what we do with typeclasses
21:11:28 <Welkin> you could use lambdas for everything I suppose
21:12:57 <pierrot> I'm finally done with this exercise... here's my code: https://glot.io/snippets/evpy6r5kwe. It consists of a implementing an interpreter for this language: https://imgur.com/pHZOCk6
21:13:04 * hackage haskell-tools-backend-ghc 1.0.0.0, haskell-tools-daemon 1.0.0.0, haskell-tools-cli 1.0.0.0, haskell-tools-builtin-refactorings 1.0.0.0 (lazac): https://qbin.io/xa2bv3b
21:13:50 <aconz2> instead of using a name like add or subtract to differentiate between *which* function of int -> int -> int you mean, you would newtype addition = int -> int -> int and then when calling it would be like... (thinking)
21:14:04 <pierrot> I've tested it and it works. Any suggestions regarding to improve my code is welcome
21:14:47 * hackage haskell-tools-rewrite 1.0.0.0, haskell-tools-refactor 1.0.0.0, haskell-tools-prettyprint 1.0.0.0, haskell-tools-experimental-refactorings 1.0.0.0, haskell-tools-debug 1.0.0.0, haskell-tools-demo 1.0.0.0 (lazac): https://qbin.io/e1cdah8w
21:15:14 <Welkin> pierrot: it would be easier if you posted it on lpaste.net or github
21:15:21 <Welkin> easier to read and annotate or leave comments
21:16:02 <Welkin> that glot.io site is forcing me to view the code through a tiny viewport and has screen tearing when I scroll for some reason
21:16:38 <pierrot> Welkin: yeah, you're right.
21:16:41 <pierrot> I'll do it
21:23:46 <aconz2> jle`: it would be a bit more like generative (I think thats the right word here) functors in ML where instead of doing the newtype on the element to select a different typeclass instance, you refer directly to the specific instance; and since each functor is a distinct type, you could refer to it by type and not by name
21:24:59 <aconz2> I've just been thinking a lot about how types and names interact, why we use one vs the other, and how we could better standardize (or elimnate!) naming things
21:25:24 <Welkin> you still need to name things
21:25:30 <Welkin> there is no way around it
21:25:35 <Welkin> unless everything is a lambda
21:27:11 <aconz2> right but shifting the focus of names to types I think could give a better shared understanding. ie. this is exactly what I mean when I say <insert ambiguous name here>
21:27:55 <Welkin> that would be more confusing, because then you have tons of things with the same name but all have different types
21:28:03 <Welkin> it just makes it worse
21:28:09 <pierrot> Welkin: https://github.com/pierrot14/interp
21:29:56 <pierrot> github legibility is certainly nicer
21:29:58 <Welkin> pierrot: instead of opening a file, reading the contents, then closing the file, you can use `readFile`
21:30:10 <Welkin> also, there is no reason to keep the file handle open once you have read the contents
21:30:23 <aconz2> we already have tons of things with the same name and no real way to communicate to others *and* the computer which thing we're actually referring to. so in that case like you're saying, they have different types, so we refer to them by type b/c that is unambiguous
21:30:54 <Welkin> aconz2: but code is written mostly for human consumption
21:31:08 <Welkin> if it was written mostly for computers, it would all look like machine code/assembly
21:33:56 <aconz2> right but humans are still bad at communicating their concept of what X means to them. I want the computer to help referee those discrepencies 
21:34:11 <Pamelloes> Are there any pure sorting algorithms for Vector, or do I have to convert to list?
21:34:23 <pierrot> Welkin: yes, I'll change it
21:35:24 <Axman6> Pamelloes: see the vector-algorithms package
21:36:30 <Welkin> Pamelloes: You can use a mutable vector and sort in ST or IO
21:36:42 <Welkin> but that also means thawing/freezing
21:36:48 <Welkin> so there is additional overhead anyway
21:37:22 <Welkin> converting to a list seems kind of dumb
21:37:40 <Pamelloes> Is thawing and freezing a lot of overhead?
21:38:07 <Welkin> I think it copies the vector once
21:38:16 <Welkin> for each operation
21:38:18 <Axman6> thawing involves copying all the data, freezing doesn't if you're using runArray (I think that's what it's called)
21:38:30 <Pamelloes> Ooh, O(n)
21:38:47 <Axman6> but all sorting is going to be at least that expensive
21:38:56 <Welkin> you would need to benchmark to see how much overhead it is compared to converting a vector to a list and sorting, then converting back
21:39:17 <Pamelloes> Yeah... performance isn't that important. Probably easier just to use thaw
21:39:31 <Pamelloes> Well, not easier but I'll learn more since I've never worked with ST before
21:39:41 <Welkin> I love lists for sorting
21:41:47 <Pamelloes> Is list sorting efficient?
21:42:56 <Welkin> it depends on the algorithm
21:43:00 <Welkin> lists are pefect for merge sort
21:43:08 <Axman6> sort of. it's lazy mergesort, so it's automatically optimal if you only need the first n element of the list. the vector algorithms are likely to be significantly faster in many cases though, if you need all elements sorted
21:43:10 <Welkin> perfect*
21:43:21 <Axman6> Radix sort is O(n) for example
21:43:41 <Pamelloes> I'm just trying to find the median of a list
21:43:45 <mud> Mergesort isn't exactly known as the sorting algorithm you really want to choose though, for decent reason.
21:44:06 <Welkin> mergesort is always a safe algorithm and it is stable
21:44:09 <mud> Median selection is actually asymptotically easier than sorting. Not that it usually matters.
21:44:29 <Welkin> it may not be the absolute fastest, but it always works as intended and never degrades into terrible performance
21:45:23 <Axman6> > take 10 $ sort [10000000,9999999..0]
21:45:29 <lambdabot>  mueval-core: Time limit exceeded
21:45:36 <Axman6> > take 10 $ sort [1000000,999999..0]
21:45:38 <lambdabot>  [0,1,2,3,4,5,6,7,8,9]
21:46:00 <mud> Welkin: Which kind of only matters when you're implementing it yourself though.
21:51:17 <Welkin> pierrot: looking briefly at the rest of your program it looks fine. There are some stylistic choices I would have made differently, but with haskell there are many ways to write the same function
21:52:40 <Welkin> pierrot: https://github.com/pierrot14/interp/blob/master/Interpreter.hs#L42 Here I would replace foldl with foldl', unless you really want a lazy left fold
21:53:23 <Axman6> (you don't)
21:57:36 <pierrot> Welkin: foldl' isn't re-exported by Prelude, right?
21:58:29 <Welkin> pierrot: not sure, but you can grab it from Data.Foldable
21:58:52 <pierrot> Ok
21:58:56 <Welkin> learning to not rely on the prelude is a good idea
21:59:11 <Welkin> for the most basic types and functions, it's fine
22:01:06 <rightfold> It’s also a minefield. You have to be careful.
22:04:52 <pierrot> Welkin: I changed `interp.hs' to use `readFile' as you suggested: https://github.com/pierrot14/interp/blob/master/Interpreter.hs
22:05:34 <pierrot> hmm that wasn't the source file, but this one: https://github.com/pierrot14/interp/blob/master/interp.hs
22:07:37 <pierrot> the function I like less is `compilerOpts'
22:08:05 <pierrot> it looks like poorly written..
22:11:31 <Welkin> you'll develop your own style as you read and write a lot more programs
22:11:47 <Welkin> I have my preferred way of writing things
22:12:35 <Welkin> it looks like you have some strange indentation though
22:12:54 <Welkin> are you using a haskell mode in your editor?
22:13:12 <pierrot> no, I'm using a naked vim
22:13:25 <Welkin> are you married to vim?
22:13:39 <pierrot> no, not necessarily
22:13:56 <Welkin> if not, I recommend using emacs with haskell-mode. If you need vim bindings, you can use evil-mode (oe spacemaces, which has everything set up like that by default)
22:14:12 <Welkin> the code formatting is very good
22:15:45 <pierrot> I've never used emacs. I'm a bit afraid of its (almost infinite) list of keybindings, but I'll give it a try :)
22:18:42 <rightfold> It’s not any more difficult to learn than Vim
22:19:02 <Welkin> you can use any keybindings you want
22:19:13 <Welkin> I use the default emacs ones, but many people use vim bindings as well
22:21:21 <pierrot> this exercises still continues lol. Now I'll have to add division to the language and consider failure during evaluation with monad transfer
22:22:00 <Welkin> integer division?
22:22:19 <pierrot> Yes
22:26:57 <Axman6> bloody hell, has anyone actually successfully used fast-logger? the API is awful
22:28:45 <Welkin> lol
22:28:59 <Welkin> I only remember using monad logger
22:29:18 <boj> Axman6: i use ocharles' logging-effect
22:29:24 <osa1> I use it with monad-logger
22:30:00 <Welkin> it looks like monad logger uses fast logger
22:30:06 <Welkin> just use that
22:32:51 <Axman6> I just understand how the interface can be so bad
22:33:12 <Welkin> maybe it was never meant to be used directly
23:05:07 <Axman6> That'd be fine if other tools didn't expect to take things like LoggerSets as arguments
23:06:18 <dysfigured> Axman6: rewrite it to not be so awful?
23:07:52 <Axman6> I"m considering it
23:11:32 <Xandaros> I'm currently trying to figure out why my program is using over 100% CPU when it is mostly idle. I compiled it for profiles and ran it with +RTS -p. Now I have a 23.5k line .prof file - any tips for interpreting it?
23:13:29 <cocreature> Xandaros: https://github.com/fpco/ghc-prof-flamegraph
23:13:53 <Xandaros> :)
23:14:00 <Xandaros> I'll try it - looks good :D
23:20:40 <zephyz_> Hi, I have a question abous Parsec, I would like to parse a single token into multiple AST nodes but I can't find anything on the net
23:22:00 <Xandaros> cocreature: http://tcpst.net/i6uk :(
23:22:32 <zephyz_> I have something like [PrefixOperator ">-+", Identifier "int"] and I would like to parse it as a tree like so: GreaterThan (Minus (Plus (IdentifierExpr "Int")))
23:22:47 <cocreature> Xandaros: how did you install ghc-prof-flamegraph?
23:22:53 <liste> zephyz_: you can use the Functor instance of Parser for that
23:23:06 <liste> zephyz_: or actually Monad instance
23:23:06 <Xandaros> just stack install ghc-prof-flamegraph
23:23:25 <cocreature> Xandaros: iirc there are some fixes in the repo that haven’t made it into a release
23:23:41 <cocreature> in particular, I vaguely recall having fixed this error for 8.0.2
23:23:58 <Xandaros> ...
23:24:00 <angerman> cocreature: got a second?
23:24:18 <Xandaros> I seem to be dealing with a lot of software unwanting to release new versions lately
23:24:30 <cocreature> angerman: sure
23:24:43 <angerman> cocreature: could you give me a short review on https://medium.com/@zw3rk/building-ghc-the-stages-2c6cf6fc4b29?
23:24:43 <cocreature> Xandaros: heh looks like there is even an issue for it https://github.com/fpco/ghc-prof-flamegraph/issues/9
23:24:57 <zephyz_> liste I don't see how, if I fmap my parse of prefix token I cant nest them correctly 
23:25:41 <zephyz_> liste well actually I don't even know how to get started with parsing the prefix token
23:27:01 <angerman> Xandaros, cocreature I like profview
23:27:36 <angerman> Xandaros, cocreature: sorry viewprof: https://hackage.haskell.org/package/viewprof
23:28:18 <Xandaros> RIght. While stack is installing ghc-8.0.1 to build the flamegraph thing, I'll try that :D
23:32:12 <cocreature> angerman: nice post! stage 0 is a bit unclear to me, you say that it is built with the bootstrap compiler but it is unclear what is actually being built here since the bootstrap compiler is still used to build stage 1.
23:32:32 <Xandaros> Neither of which actually build...
23:33:13 <cocreature> angerman: and I found two typos: “the next step, running ./configure.” should be merged with the next sentence and “To do this, we compiler” should be “s/compiler/compile” and should be merged with the next sentence
23:33:42 <angerman> Xandaros: what? viewprof doesn't build anymore? 
23:33:45 <Xandaros> viewprof doesn't build: http://tcpst.net/89uw got flamegraph to compile
23:34:58 <angerman> cocreature: yea, the stage stuff is a bit annoying. bceause drawing clear distinctions is hard. So you have the bootstrap compiler (ghc0, package-db0), and they form your stage 0, but you also add a few more extra packages into your stage 0, the so called boot packages.
23:35:57 <angerman> Xandaros: ahh, never tried to install it with Stackage. but haven't built viewprof in a while, been using the binary all the time, which I built a few month back.
23:36:08 <angerman> cocreature: thanks. Let me fix those up :D
23:36:28 <Xandaros> Well, no matter. I found the problem now :D
23:36:54 <Xandaros> ...I think. We'll see
23:37:16 <angerman> cocreature: man, editing is hard, your reviews are a god send every time! ;-)
23:38:51 <Xandaros> I was so sure it was just busy waiting somewhere. Apparently my cipher functions are incredibly inefficient, instead. Ah well
