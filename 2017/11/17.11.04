01:13:03 <paolino> is it me or "import Data.Monoid ((<>))" is kind of frequent
01:15:58 <paolino> maybe I should import from Semigroup and make it more verbose 
01:16:49 <paolino> how do you usually concat Text ?
01:20:18 <pacak> T.concat
01:24:37 <paolino> pacak, I meant mappend , (<>)
01:57:47 <Drinfeld> using Sublime Text 3 + SublimeHaskell, I am getting the error "Build FAILED Collected output: .\Haskell.cabal: getModificationTime:getFileTimes:getFileStatus: does not exist (No such file or directory)" when compiling. What am I doing wrong? When building my file using ghc, I am getting the error    Parse error: naked expression at top level Perhaps you intended to use TemplateHaskell (but...
01:57:48 <Drinfeld> ...there is a main :: IO ())
02:01:02 <Drinfeld> I fixed the ghc error, but the error in Sublime Text 3 remains.
02:01:52 <geekosaur> are you using a cabal file? it seems to be looking for one
02:02:44 <Drinfeld> yes, there is a Haskell.cabal file in the directory.
02:04:26 <geekosaur> wonder if it's looking in the wrong directory for some reason then
02:06:01 <Drinfeld> It worked before upgrading from Kubuntu 17.04 to 17.10
02:06:27 <geekosaur> o.O
02:06:42 <geekosaur> unless you typoed that error message, it seems to think it's on Windows
02:06:55 <geekosaur> .\Haskell.cabal
02:08:38 <Drinfeld> because of the \ instead of a /?
02:11:21 <geekosaur> yes. if it actually tried to open that file, it would file; \ is an acceptable filename character (although you usually have to escape it in most languages, editors will often be fine with it)
02:11:26 <geekosaur> er, it would fail
02:12:17 <Drinfeld> how can I fix this?
02:12:58 <geekosaur> makes me wonder if you got a buggy sublime text, or (if you installed it separately) you need to upgrade it
02:19:03 <Drinfeld> it is the most recent version: 3.0 Build 3143
02:21:40 <significance> Hey all! noob question: `cabal update` seems to be hanging on a curl call to hackage, and when I try to manually download the file in a web browser, it fails (01-index.tar.gz) -- any idea what might be going on?
02:22:42 <merijn> significance: Seems to work fine here?
02:23:11 <significance> merijn: must be my network, I'm at a university so I might be behind a proxy :P
02:23:14 <significance> thanks!
02:23:38 <merijn> significance: There's some cabal options for dealing with proxies, but I don't remember what
02:23:51 <merijn> significance: But googling haskell + cabal + proxy probably turns something up
02:23:59 <significance> merijn: think I might have found something online via google, I'll give it a shot
02:28:38 <significance> merijn: huh, I can't seem to detect any proxy, but when I download it in a web browser, the download halts just before completed. Any idea why that might happen?
02:31:09 <zennist> just searched for Turtle on hoogle and it doesn't show up - is this normal?
02:32:15 <zennist> okay figured out; there are two hoogle sites; hoogle.haskell.org is better than the haskell.org/hoogle one
02:32:34 <zennist> I think this should be documented somewhere.. already tripped up in it for a few times
02:32:36 <geekosaur> hoogle4 won't show it, hoogle5 should
02:32:46 <geekosaur> which is basically the division you just noted
02:32:55 <geekosaur> but ghoogle4 has working type search
02:33:03 <geekosaur> hoogle4
03:05:29 <hrk> Could someone please explain to me what does '*' mean in these Product instances? https://www.stackage.org/haddock/lts-9.11/base-4.9.1.0/Data-Functor-Product.html#t:Product
03:06:08 <hrk> Why is there not just "(Functor f, Functor g) => Functor (Product f g)" without star?
03:10:49 <geekosaur> hrk, haddock does a poor job currently of showing kinds
03:11:16 <hrk> geekosaur: oh, so it's some kind of Haddock bug?
03:11:20 <geekosaur> since PolyKinds is enabled, it's trying to say those instances expect kind *
03:12:26 <cocreature> I wouldn’t call it a bug, it makes sense to display kind arguments. they are just displayed in a very confusing way
03:12:33 <geekosaur> ^
03:13:14 <cocreature> hrk: are you familiar with kinds?
03:13:56 <hrk> cocreature: Yes. So that Start is kind of "Product f g" ?
03:14:06 <cocreature> :k Product
03:14:08 <lambdabot> * -> *
03:14:18 <cocreature> :k Data.Functor.Product.Product
03:14:19 <lambdabot> (k -> *) -> (k -> *) -> k -> *
03:14:28 <cocreature> the * is the value for k
03:15:45 <hrk> cocreature: ah, got it. Thanks
03:15:53 <geekosaur> if you look down toward the bottom of the list of instances, there are two (last and third from last) which show k instead of *
03:16:09 <geekosaur> meaning they will accept any kind, not just *
03:16:46 <geekosaur> this matters only if you are using lifted types to create your own kinds
03:27:13 <jle`> well, in general, non-* kinds can come from many normal haskell types, not just lifted types
03:56:05 <c_wraith> ack.  can we call those "promoted" instead of lifted?  GHC means something else when it calls a type "lifted"
04:02:47 <jle`> good point!
04:31:54 <jhoxray> hi all - a question on ghc compiler plugins
04:32:32 <jhoxray> it's all pretty self explanatory from the docs here - https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/extending_ghc.html#core-plugins-in-more-detail - and ghc apis
04:32:48 <jhoxray> however, what I couldn't find, is what is the order of execution of passes?
04:33:06 <jhoxray> E.g., I want to install my plugin to do passess *after* all ghc core optimizations are finished - 
04:33:11 <jhoxray> is there any way to do it?
04:33:19 <jhoxray> appreciate any pointers!
04:36:01 <zennist> started using Turtle again today and found there is this new 'Line' type replacing 'Text' in the past; so in place where I could do 'pure (mytext :: Text)' to get Shell Text; now I need 'select . textToLines $ mytext'
04:36:05 <zennist> is there a simpler way?
04:37:35 <cocreature> zennist: there is unsafeTextToLine if you know that there are no newlines in your string
05:03:47 <Ero> hi all
05:06:07 <Ero> in geometric math, what is the definition for a 'graph of vectors' (a structure which represents a vector and a set of vectors which exist at that vectors point?)
05:06:30 <Ero> 'originate' at that vectors point, i should say
05:07:50 <Ero> by definition, i mean name actually
05:08:11 <Ero> also is there a haskell library which represents these and their operations?
05:23:07 <Hafydd> Ero: that sounds like a vector space where the zero vector is the origin point.
05:23:18 <Hafydd> Ero: I don't see how it's a "graph".
05:24:02 <Hafydd> I believe there are implementations of a VectorSpace type class.
05:26:16 <Ero> Hafydd i used graph for lack of a better visual term
05:26:41 <Ero> vectorspace. Thank you
05:34:09 <Hafydd> It's hard to be sure what you mean by "vector" if you didn't know what a vector space is.
05:48:35 <merijn> So...question, suppose my tests need to check the stdout/stderr of my code, what's the easiest way to specify them in cabal?
05:48:47 <ph88> hey guys, how can i write this (imperative) loop in haskell? i have here a loop which some conditions in it, no matter in which order i place the conditions the elements are being appended to the array https://3v4l.org/7d5JV and https://3v4l.org/TmtkU
05:49:04 <merijn> If I simply write two exitcode test suites one which runs the other then it breaks because cabal will run one which isn't supposed to be run?
05:49:38 <merijn> ph88: what does "$arr[] = 4;" even mean?
05:49:47 <mniip> ph88, a naive translation would be:
05:51:08 <mniip> fun = go 0 where go n xs | n >= length xs = xs; go n xs = go (n + 1) (xs ++ (if xs !! n == 2 then [4] else []) ++ (if xs !! n == 4 then [5] else []))
05:51:53 <mniip> @let fun' = go 0 where go n xs | n >= length xs = xs; go n xs = go (n + 1) (xs ++ (if xs !! n == 2 then [4] else []) ++ (if xs !! n == 4 then [5] else []))> fun' [1,2,3]
05:51:54 <lambdabot>  .L.hs:161:13: error:
05:51:54 <lambdabot>      • Couldn't match expected type ‘[a]’ with actual type ‘Bool’
05:51:54 <lambdabot>      • In the expression:
05:51:59 <mniip> dammit copy
05:52:04 <mniip> @let fun' = go 0 where go n xs | n >= length xs = xs; go n xs = go (n + 1) (xs ++ (if xs !! n == 2 then [4] else []) ++ (if xs !! n == 4 then [5] else []))
05:52:05 <lambdabot>  Defined.
05:52:08 <mniip> > fun' [1,2,3]
05:52:10 <lambdabot>  [1,2,3,4,5]
05:52:23 <mniip> but this is naive and stupid and inefficient
05:53:50 <ph88> merijn, it means at 4 to $arr .. it's like arr.append(4) in some other languages
05:54:10 <ph88> thx mniip 
05:54:41 <ph88> mniip, what if i want only to apply some conditions depending on which conditions have been applied in PREVIOUS iterations of the loop ?
05:54:57 <mniip> then you pass them on
05:55:29 <mniip> you could use a state monad in theory
05:55:29 <ph88> you pass the value and the conditions together ?
05:55:35 <mniip> yes
05:55:59 <merijn> Is there a portable to redirect stdout in my program?
05:57:09 <ph88> mniip, how do i describe which conditions depend on which other ones though ?
05:57:42 <mniip> ph88, what exactly are you trying to do
05:58:00 <ph88> mniip, it's like a mini rule engine
05:58:06 <ph88> business rules
05:58:25 <mniip> and what does mutating a list have to do with that
05:58:49 <ph88> eh the list is the input and the output after all the rules have been applied
06:02:50 <merijn> \o/
06:03:18 <merijn> I've been looking for dupTo all this time, but turns out GHC already has a portable version of that, it's just named "hDuplicate"
06:08:48 <geekosaur> um.
06:08:58 <geekosaur> not identical to dupTo
06:09:29 <geekosaur> it gives you a new Handle value using the same fd as the old, not a Handle with a new, OS-duplicated fd
06:11:16 <geekosaur> oh, hm, maybe it is
06:11:21 * geekosaur is digging
06:11:47 <merijn> geekosaur: There's also hDuplicateTo
06:12:03 <merijn> hDuplicate = dup, hDuplicateTo = dupTo
06:15:10 <merijn> Now I just need a portable pipe
06:15:21 <mniip> files
06:16:08 <merijn> I now I can use files, but I'd much rather have a pipe as it's more robust for my usecase
06:16:31 <merijn> I'm pretty sure windows has pipes
06:16:49 <geekosaur> it does
06:28:06 <merijn> aww...unix-compat has a version of namedpipes, but not anonymous pipes :\
07:10:37 <merijn> hmm
07:13:03 <paws_> hello... anyone could help me with a (newbie) question about Stack's Docker integration? https://stackoverflow.com/questions/47111517/run-stack-docker-container
07:16:46 <paws_> Here the post in case anyone doesn't like stackoverflow https://www.irccloud.com/pastebin/Yw9GZvPo/
07:17:51 <merijn> Any clues why the hell http://lpaste.net/359784 wouldn't work? After restoring duplicating the handle I'm not getting any output on stderr or stdout?
07:20:01 <paws_> just asked also in #haskell-stack, didn't know this channel exists
07:26:20 <merijn> ugh...turns out tasty is sneakily throwing exceptions behind my back...
07:26:40 * merijn increases the "number of times I've wished Haskell had checked exceptions"-counter by 1
07:32:10 <Welkin> what are checked exceptions?
07:34:04 <merijn> Welkin: Exceptions that are visible in the type, ala java's "throws X" in type signatures
07:35:05 <Welkin> in IO, anything can happen
07:35:28 <merijn> Yes, that's a bug in the language design
07:36:25 <Welkin> is there any language that does it better?
07:41:10 <totom> Is there a channel for general programming talks?
07:43:00 <merijn> Welkin: No, but that's no excuse :)
07:43:06 <merijn> totom: ##programming?
07:44:45 <merijn> hmmm, at which point do you go from copying one/a handful of function into different projects to "fuck it, I'll just package it as a library"?
07:48:38 <Sornaensis> merijn: 2 uses
07:53:00 <merijn> Any nominations for what name I should use to refer to the combination of stderr+stdout+stdin?
07:53:22 <osfameron> the first time that you *change* the function in one place and realise that you actually do have to change it in all the other places too
07:54:09 <Welkin> merijn: shadenfreude
07:54:13 <merijn> osfameron: That's why I don't like copying it...I hate the idea of forgetting to fix a bug I've already fixed before :)
07:54:20 <seestevecode> Hi. Just starting with Haskell and FP. Working through CIS194 (Spring13). Is there somewhere I can go to get my code reviewed? It's working, but I'd like some feedback on how good it is.
07:54:31 <Welkin> copy-pasting code is great for prototyping
07:54:44 <merijn> seestevecode: Here (if someone is bored enough) or in the r/haskell reddit
07:54:47 <Welkin> but if you are bulding someting that will be released or used in production, you'll need to fix it before deploy
07:55:16 <osfameron> merijn: sure.  but you're just as likely to change it because of a functional requirement in one or other codebase
07:55:41 <osfameron> extracting to a library too early may box in both codebases, before you really understand what you're doing with it
07:56:02 <Welkin> seestevecode: it's also a good idea to read *a lot* of other people's code
07:56:16 <merijn> osfameron: Well, in the specific case, I have several test-suites where I need to run some code that writes to stdin/stdout/stderr and inspect that output. This is the 3rd time i need it, so I'm wondering whether I should just extract it
07:56:22 <Welkin> the base libraries in ghc are a good place to start. they are well-written with plenty of comments
07:57:31 <Welkin> seestevecode: understanding how all of the common functions you use are implemented is helpful (and fun)
07:58:56 <seestevecode> Is the best way to get it reviewed to post to GitHub and provide a link?
07:59:20 <Welkin> yes, or paste on lpaste.net
07:59:33 <Welkin> but that is usually for getting help on a bug/error
08:00:09 <merijn> I suppose stdio could work, but is not really accurate
08:00:10 <Welkin> for a full code review I recommend using github or another online repo
08:00:19 <seestevecode> Thank you Welkin and merijn (sorry - don't even know how to tag you - been a while since I've used IRC).
08:04:52 <geekosaur> mentioning is enough
08:11:09 <merijn> at this rate I'm going to publish like 8 libraries on Hackage just because I decided to add tests to 1 library and keep getting annoyed with repeatedly solving issues in the process >.>
08:26:53 <sm> merijn: maintenance costs ahead...
08:27:37 <sm> I guess quite some people compromise and publish one library with all their stuff
08:27:51 <sm> s/quite//
08:29:31 <merijn> sm: Having to maintain the same code across multiple packages is even worse
08:33:22 <sm> could you use shelltestrunner by the way, or is this more custom ?
08:34:02 <merijn> sm: The problem is that I don't have any executable
08:34:21 <sm> I see
08:34:31 <merijn> sm: Basically, I wrote some stuff for tasty which I want to test, which means I need to somehow inspect tasty's output
08:35:02 <merijn> sm: I can make 2 different test-suites, one with the test test-suite, and one that runs that, but that doesn't work out all that conveniently
08:35:17 <merijn> sm: For one, if my test testsuite has failures cabal will report it as failing
08:35:55 <merijn> sm: So what I ended up doing is running tasty's defaultMain with stdout redirect to a tempfile, then check that tempfile's output
08:36:11 <merijn> sm: Then I don't have to mess around with multiple executables
08:37:01 <merijn> sm: And then proceeded to realise that this code would drastically simplify a bunch of other test-suites I have too :p
08:37:48 <sm> it sounds like shelltestrunner includes some similar code. It could expose that as a library for testing non-executables. Or it could depend on your new libs..
08:38:05 <sm> just thinking aloud
08:39:04 <merijn> sm: I use tasty-golden for verifying the output
08:39:12 <sm> aha
08:39:49 <merijn> sm: So the only code I have to it basically something along the lines of "IO () -> IO ByteString" which redirects stdout, run the IO action, reads in all the output, then switches stdout back
08:49:12 <ertes> merijn: "stdio"
08:50:41 <merijn> ertes: Yeah, I considered something like "redirect-stdio" or something
08:50:54 <merijn> But I'll put the off until later, wrapping this up first.
08:51:21 <ertes> merijn: why do you need tasty's output anyway?  (i only skimmed through the backlog)
08:51:48 <merijn> ertes: Because I wrote some stuff to help me generate/prettify tasty tests
08:52:07 <merijn> ertes: So, to test whether those work I need to look at the output of tasty :p
08:52:20 <ertes> ah =)
08:53:06 <ertes> i need to redirect stdio when i use rapid-term for development, but my approach in that case is to just abstract over the I/O handles
08:53:29 <merijn> ertes: Yeah, unfortunately tasty doesn't have that (yet)
08:53:33 <ertes> (rapid-term is an extension of rapid that opens a persistent terminal for development of interactive stuff)
08:54:00 <merijn> Incidentally, anyone willing to go over these docs and comment on whether the naming is ok, docs are decent and everything's clear? https://hackage.haskell.org/package/paramtree-0.1.0/candidate
08:55:13 <ertes> "Example usecases include criterion benchmark trees of tasty test trees."
08:55:14 <ertes> "of"?
08:55:23 <merijn> ertes: Should be or :p
08:55:33 <ertes> ok, that makes more sense =)
08:59:22 <ertes> merijn: to me as an experienced haskeller it's more or less clear from the docs of the 'growTree' function, but i suspect that less experienced haskellers might have trouble understanding it
09:00:59 <merijn> ertes: I find it hard to describe tbh, so I was just hoping the example would be enough :) Besides, I'll settle for "experienced haskeller" for now :p
09:02:31 <ertes> i think it's fine, and to really explain it you need to write something in a more tutorial-like format
09:03:26 <anelson-> Hi all, is it expected that `cabal build` will run from scratch each time when TemplateHaskell is used? I recently added `makeLenses` calls to some of my modules and now when I build with cabal it always builds every module. Using ghcjs, not sure if that matters
09:07:39 <ertes> anelson-: i wouldn't be surprised, because TH code doesn't have to be deterministic, but there is probably a GHC option to disable it…  my question would rather be: do you have to have compilation in your development cycle?  GHC comes with an interpreter
09:08:20 <anelson-> ertes: due to the fact that I'm using ghcjs and need to continuously build a JS binary to be delivered to the browser, the repl is mostly only useful for type checking :(
09:09:23 <ertes> just yesterday i learned that you can connect to GHCJSi from the browser =)
09:09:33 <ertes> i haven't tried it myself though
09:09:43 <geekosaur> I don't know of a way to suppress TH recompilation. and ghc can't know ahead of time that you don't have a splice or quasiquoter that reads some random file somewhere
09:10:03 <anelson-> ertes: yeah but that has downsides
09:10:36 <anelson-> geekosaur: maybe ghc can't know it, but I can know it... seems like it could provide that as an option anyway
09:10:54 <ertes> anelson-: reflex-dom follows the approach to just work with both GHC and GHCJS…  if you compile/interpret with GHC, a webkitgtk window pops up and uses the native API of ghcjs-dom
09:11:27 <ertes> anelson-: perhaps you could replicate that…  or just use reflex-dom yourself =)
09:12:04 <anelson-> switching frameworks isn't really something I'm considering at this point :)
09:12:20 <merijn> ghc shouldn't recompile TH all the time
09:12:24 <merijn> might be a bug in ghcjs?
09:12:56 <anelson-> I've used the REPL-to-browser thing but it's almost as slow as compiling, has some weird bugs, and requires some extra effort to get to communicate with the backend
09:13:26 <anelson-> merijn: do you happen to know if there's a way I can have cabal build report why it's rebuilding what it says to rebuild
09:13:55 <merijn> anelson-: Pretty sure cabal just defers to GHC for that
09:14:38 <anelson-> merijn: yeah I'm only really familiar with the cabal workflow; do you know the equivalent command to invoke ghc(js) directly?
09:14:48 <ertes> anelson-: then my approach would be to make it work natively…  you just need to abstract the initialisation part, such that it fires up a webkitgtk window when compiled with GHC…  read the reflex-dom source code to figure out how it does it
09:15:11 <ertes> ghcjs-dom works natively out of the box
09:15:54 <anelson-> That's definitely interesting, but it frankly sounds like way more work than I'm wanting to put in for this
09:16:06 <anelson-> I've already spent an ungodly amount of time yak shaving on this project lol
09:16:11 <merijn> anelson-: I haven't used ghcjs before, so no
09:16:46 <anelson-> ertes: out of curiosity though does that work with the FFI?
09:17:32 <ertes> anelson-: i assume that you will have to write two versions of each FFI call…  in particular you probably can't use any external JS libraries in native mode
09:17:59 <anelson-> so it's not running javascript then? It's running machine code?
09:18:07 <ertes> yes
09:18:09 <anelson-> I don't know how that could work with JS stuff
09:18:19 <anelson-> Like, my app uses WebSockets and EventSource etc
09:18:39 <ertes> although webkitgtk probably has a way to load external JS explicitly
09:19:06 <dmj`> ghcjs uses node to compile template haskell, and has been known to be slow
09:19:18 <dmj`> unsure about full recompilation
09:19:19 <ertes> i don't know how exactly it works, but it probably uses the JS *engine* without using JS *code*
09:19:46 <anelson-> yeah I don't mind it as much being slow if it properly cached things
09:19:49 <dmj`> anelson-: you can replace calls to makeLenses with manual construction using lens
09:19:56 <anelson-> a full rebuild of the app takes almost 4 minutes at this point
09:20:00 <dmj`> :t lens
09:20:02 <lambdabot> Functor f => (s1 -> a1) -> (s1 -> b1 -> t1) -> (a2 -> f b2) -> s2 -> f t2
09:20:06 <anelson-> dmj`: yeah I know
09:20:13 <merijn> oh...rats
09:20:20 <anelson-> Just a pain :P but I might do just that
09:20:37 <cocreature> anelson-: ime it doesn’t rebuild a module containing makeLenses if nothing else in that module has changed
09:20:58 <cocreature> anelson-: so what I do is try to move the calls to makeLenses to modules that I change very rarely
09:21:01 <anelson-> cocreature: I can call `cabal build` twice and it will build from scratch each time, with no code changes
09:21:03 <cocreature> so most of the time they are cached
09:21:21 <cocreature> huh, I use new-build and that definitely doesn’t rebuild from scratch
09:21:27 <anelson-> what's new-build
09:21:39 <cocreature> https://cabal.readthedocs.io/en/latest/nix-local-build-overview.html
09:22:05 <cocreature> basically cabal that doesn’t suck until you hit the features that are still missing :)
09:22:16 <anelson-> does that work with nix?
09:22:21 <anelson-> it says it's "nix-style"
09:22:34 <cocreature> it works just as well with nix as regular "cabal build" does
09:22:45 <cocreature> just run it in a nix-shell
09:22:47 <anelson-> ok I'm gonna give it a shot
09:23:14 <anelson-> could not resolve dependencies :(
09:23:19 <ertes> if you use nix-shell is there even a reason to use new-build?
09:23:28 <ertes> i just use Setup.hs directly in that case
09:23:45 <anelson-> ertes: if it can fix this problem, that's the reason
09:23:47 <merijn> ertes: I think new-build has some stuff to integrate with nix better?
09:23:52 <cocreature> ertes: yes, multi-package projects, new-configure and a bunch of other stuff
09:23:55 <cocreature> merijn: nah
09:24:04 <cocreature> it doesn’t integrate with nix at all
09:24:11 <merijn> cocreature: You forgot "get travis testing script for free" :p
09:24:18 <ertes> i have never used new-build
09:24:21 <anelson-> cocreature: do you use cabal new-build in a nix shell? I'm getting errors about resolving dependencies
09:24:27 <ertes> but it seems like you would just do those things with nix itself
09:24:28 <cocreature> anelson-: yes I do
09:24:34 <cocreature> anelson-: what’s the error?
09:24:36 <anelson-> do you have to do anything special?
09:24:40 <ertes> at least i do
09:24:48 <merijn> cocreature: I fixed it to generate tests for multi-package things too, as soon as phadej merges my last fixes :p
09:25:01 <merijn> ertes: That'd require installing learning, etc. nix
09:25:04 <anelson-> cocreature: cabal: Could not resolve dependencies:
09:25:08 <cocreature> ertes: incremental rebuilds for multi-package projects is not really something that nix helps you with
09:25:16 <cocreature> anelson-: I’m more interested in the part that comes below that message :)
09:25:19 <ertes> merijn: the premise of my question is that you're already using nix-shell
09:25:26 <anelson-> trying: coolserver-frontend-0.0.1 (user goal)
09:25:26 <anelson-> next goal: vector (dependency of coolserver-frontend-0.0.1)
09:25:26 <anelson-> Dependency tree exhaustively searched.
09:25:28 <merijn> cocreature: There's literally a "nix integration" chapter in the docs
09:25:44 <ertes> cocreature: ah, i see
09:25:44 <cocreature> merijn: yes but that’s for old build
09:25:53 <merijn> ah
09:26:02 <ertes> cocreature: so new-build rebuilds in other projects as well?
09:26:13 <ertes> s/projects/packages/
09:26:31 <cocreature> ertes: you can make a cabal.project file and declare the local packages and if any of them changes it rebuilds
09:26:45 <ertes> that's interesting indeed…  i haven't figured out how to solve this nicely with nix yet
09:27:04 <ertes> i have a solution, but it's rather clumsy and requires me to update git commit hashes
09:27:22 <cocreature> anelson-: huh that’s weird. which version of cabal are you using?
09:27:36 <cocreature> new-build with cabal < 2.0 is basically unusable
09:27:37 <anelson-> 1.24.0.2
09:27:41 <anelson-> oh ok
09:27:49 <anelson-> what version should I try
09:28:00 <cocreature> I use 2.0 for the most part and HEAD occasonially
09:28:14 <merijn> ertes: I'm using that to have Travis test multiple unreleased packages in the same repo
09:29:03 <ertes> i guess i should just figure out how to use nix together with new-build and finally ditch my "all i need is Setup.hs" notion =)
09:29:28 <cocreature> ertes: there is really not much too it, just launch a nix-shell and run "cabal new-build" inside of it
09:30:17 <merijn> Aside from the missing bits new-build is how I always wanted things to work :p
09:30:22 <ertes> cocreature: yes, but cabal2nix doesn't support cabal.project files as far as i know…  i would need to generate/maintain the nix expression
09:31:00 <ertes> although i could probably just use cabal2nix on the individual packages and then write a project expression using ghcWithPackages
09:31:18 <merijn> ertes: You could stick with new-build for dev versions and use regular cabal + cabal2nix for releasing things?
09:31:40 <cocreature> ertes: usually I have one main package with a bunch of deps and then I just run "cabal2nix" on the main package which pulls in all the deps for the other packages as well
09:31:49 <merijn> ertes: cabal.project is really only relevant when you wanna use local/unreleased versions
09:32:01 <ertes> cocreature: makes sense, yeah
09:32:35 <ertes> yeah, i'll have to play around with it a bit
09:32:54 <anelson-> also does anyone know why my modules sometimes compile twice, once as (.js_dyn_o) and once as (.js_o)?
09:33:23 <monochrom> Sometimes, but not always?
09:33:32 <anelson-> yeah this doesn't seem to happen every time
09:33:58 <anelson-> and there isn't an explanation in the logs, it just says compiling
09:34:45 <monochrom> If this is GHCJS, I don't actually know. I only know native GHC.
09:35:20 <monochrom> But maybe the native GHC story helps too.
09:35:42 <anelson-> yeah...?
09:36:31 <Welkin> anelson-: direct ghcjs questions to #ghcjs
09:37:01 <monochrom> For libraries, cabal will tell GHC "--dynamic-too" so GHC will produce both *.o (intended for static linking) and *.dyn_o (has -fPIC, intended for dynamic linking) because the next thing cabal does is to build both a static library (*.a from the *.o's) and a dynamic library (*.so from the *.dyn_o's)
09:37:17 <monochrom> For executables though, cabal default is to stay purely static.
09:38:31 <anelson-> so normally you wouldn't expect to see dynamic files when the project is only an executable?
09:38:59 <monochrom> For ghcjs I don't know why it would need the dynamic version, apart from "we didn't bother to get rid of this part in the GHC source code"
09:39:05 <monochrom> Right.
09:39:08 <anelson-> lol
09:39:08 <anelson-> ok
09:39:19 <anelson-> well, life is difficult sometimes...
09:53:46 <Xion_> How do you typically fmaping through double-nested functors? Like IO (Maybe a).
09:53:51 <Xion_> typically write*
09:54:17 <anelson-> you can nest fmap, or use <$>
09:54:59 <Xion_> fmap foo <$> x -- is probably the cleanest
09:55:04 <anelson-> I often use a combination of fmap and <$>, I feel it reads better
09:55:08 <anelson-> yeah, agreed
09:55:10 <tdammers> :t <$$>
09:55:11 <lambdabot> error: parse error on input ‘<$$>’
09:55:11 <Xion_> (foo <$>) <$> x looks weird :)
09:55:14 <Welkin> define an fmap2 = fmap . fmap
09:55:17 <tdammers> :t (<$$>)
09:55:19 <lambdabot> error:
09:55:19 <lambdabot>     • Variable not in scope: <$$>
09:55:19 <lambdabot>     • Perhaps you meant one of these:
09:55:34 <Welkin> <$$> is infix fmap2
09:56:06 <tdammers> yes, but unfortunately there's no standard implementation
09:56:13 <Xion_> Oh yeah, https://www.stackage.org/haddock/lts-9.11/composition-extra-2.0.0/Data-Functor-Syntax.html#v:-60--36--36--62-
09:56:24 <Welkin> you can write your own Util.hs and include fmap2 = fmap . fmap
09:56:30 <tdammers> http://hackage.haskell.org/package/functor-infix-0.0.5/docs/Data-Functor-Infix.html
09:56:39 <tdammers> ^ closest I could find
09:56:44 <Welkin> importing an entire library for one function is ridiculous
09:56:57 <tdammers> *cough*left-pad*cough*
09:57:14 <Welkin> tdammers: we all know that the js community has no idea what they are doing anyway
09:57:29 <tdammers> true
09:57:50 <tdammers> last time I wanted to do ajax in JS, the first npm result for 'ajax' was a library that used eval() to parse JSON... go figure
09:57:58 <Welkin> they don't even realize that their favorite library (React) is written in ocaml
09:58:05 <tdammers> but hey, functor-infix also defines a lot of other useful functions
09:58:17 <tdammers> <&> is kind of nice IMO
10:01:17 <dmj`> :t fmap `fmap` fmap
10:01:19 <lambdabot> (Functor f2, Functor f1) => (a -> b) -> f1 (f2 a) -> f1 (f2 b)
10:02:14 <Xion_> dmj`: lol
10:03:28 <Welkin> same as fmap . fmap
10:03:37 * Xion_ ended up defining (<$$>) = fmap . fmap
10:15:14 <EvanR> fmaps all the way down
10:21:06 <iqubic> > 0.1 + 0.2 == 0.3
10:21:07 <lambdabot>  False
10:21:43 <iqubic> Why is floating point so weird.
10:21:52 <monochrom> Why not.
10:22:12 <anelson-> well equality on reals is undecidable anyway...
10:23:15 <mud> iqubic: Because it's a mix of like 5 different competing things you want to optimize or properties you want to have, and they all make sense if you look at each one. But combining them is ... weird.
10:25:48 <ertes> iqubic: compute 2/7 + 3/7 in decimal notation limited to 3 decimal places and see if you get 5/7
10:26:56 <ertes> 2/7 ≈ 0.286; 3/7 ≈ 0.429; 5/7 ≈ 0.714
10:27:19 <ertes> but 0.286 + 0.429 = 0.715
10:28:06 <EvanR> which isnt the real problem
10:28:31 <EvanR> write 2/7 in binary notation limited to 52 bits precision
10:28:49 <ertes> iqubic: the problem is that decimal is a base-10 digital representation, which means that you can't represent all rational numbers precisely…  only those that have only 2 and 5 in their denominator
10:28:55 <mud> It's an analogy. A pretty good one.
10:29:08 <ertes> iqubic: the same thing happens with 0.1 and 0.2 in Float/Double
10:29:17 <EvanR> sevenths is to base 10 as base 10 is to base 2 .... uh 
10:29:23 <ertes> iqubic: it's a base-2 representation, so you can represent even fewer rationals exactly
10:29:25 <EvanR> "not the same"
10:29:35 <monochrom> It is stronger than an analogy. It is the same phenomenon with different parameters.
10:29:47 <ertes> iqubic: only those that have only 2 in their denominator, however 0.1 = 1/10
10:29:49 <ertes> 10 = 2*5
10:29:53 <iqubic> > 0.25 + 0.75 == 1
10:29:55 <lambdabot>  True
10:29:58 <EvanR> cancel out the base 10 and get... sevenths is to base 2!
10:30:16 <mud> EvanR: It's the same in all the senses that are important. (the prime factors of the base vs. the prime factors in the denominators)
10:30:19 <monochrom> But there is a Knuth paper showing why base 2 is the least lossy, if you have decided to go floating point.
10:32:11 <EvanR> at least its easy to demonstrate to someone that "arithmetic on the computer is wrong" but then 
10:32:21 <EvanR> theres a mountain of explanations
10:32:43 <EvanR> and its worse if they dont know whats right (forgot school math)
10:33:14 <ertes> well, "wrong"…  it's imprecise
10:33:41 <EvanR> inaccurate?
10:33:49 <ertes> as you increase the number of bits, it converges to the correct result
10:33:54 <EvanR> its wrong within certain standards of precision
10:33:58 <EvanR> er its right
10:34:20 <EvanR> ertes: youd think!
10:34:24 <ertes> something like the FDIV bug in older intel processors would be "wrong"
10:34:34 <EvanR> simple addition converges yes
10:35:27 <EvanR> the unum slides have some formulas designed to stress test number systems, where floating point screws up royally
10:36:03 <ertes> you need to understand how FP can go wrong, if you use it (and care about precision)
10:36:12 <ertes> for example 'sum' is a bad idea, if you care about it
10:36:16 <EvanR> i thought i did until i saw those slides
10:36:50 <ertes> FP has some numeric stability issues…  it's not unusable, but you need to be aware of that, if you do anything complicated numerically
10:37:21 <EvanR> like compute a formula consisting of "elementary" operations
10:37:39 <EvanR> + * exp sqrt and recip
10:38:10 <ertes> 'exp' isn't really elementary
10:38:47 <EvanR> you take that back
10:39:07 <ertes> if you think it is, try to write an algorithm that computes it
10:39:33 <EvanR> theres no finite one
10:39:41 <ertes> remember that the type is Double -> Double, not Integer -> Double
10:39:42 <EvanR> in terms of + and *
10:39:51 <EvanR> yes thats what im talking about
10:40:31 <mbrock> the basic answer to "why is floating point weird" is just the pigeon hole principle, right? you have 2^64 numbers and you expect to fit all rational numbers in there, good luck
10:40:49 <EvanR> or all reals really
10:40:51 <ertes> mbrock: no, it's more than that…  see my arithmetic example from above
10:40:53 <EvanR> sin, exp, etc operations
10:40:59 <EvanR> sqrt
10:40:59 <mud> Not even just the rationals, yeah a lot of the time you really expect them to work like reals.
10:41:29 <ertes> consider this:  Ratio Int8 can represent numbers that Double can't
10:41:30 <EvanR> maybe not all reals
10:41:47 <ertes> and it can do exact computations with them
10:41:50 <EvanR> a set containing rationals and closed under the elementary ops
10:41:59 <ertes> > 1/3 + 2/3 == (3/3 :: Ratio Int8)
10:42:01 <lambdabot>  True
10:42:08 <ertes> > 1/3 + 2/3 == (3/3 :: Double)
10:42:10 <lambdabot>  True
10:42:21 <ertes> > 1/3 + 2/3 == (3/3 :: Float)
10:42:24 <lambdabot>  True
10:42:28 <ertes> well, of course it would
10:42:35 <ertes> > 1/7 + 2/7 == (3/7 :: Ratio Int8)
10:42:38 <lambdabot>  True
10:42:41 <ertes> > 1/7 + 2/7 == (3/7 :: Double)
10:42:43 <EvanR> and maybe closed under special extra functions you dream up
10:42:43 <lambdabot>  True
10:42:47 <ertes> come on…
10:42:50 <ertes> > 1/7 + 2/7 == (3/7 :: Float)
10:42:52 <lambdabot>  False
10:42:56 <ertes> finally =)
10:43:06 <mud> Lol. Damn things never fail like you want them to.
10:43:22 <mud> (they fail in entirely new and fun ways instead)
10:43:33 <ertes> Ratio Int8: 16 bits of precision
10:43:39 <ongy> > (0.1 :: Float)
10:43:42 <lambdabot>  0.1
10:44:06 <ertes> > map ($ (undefined :: Float)) [floatDigits, floatRange]
10:44:09 <lambdabot>  error:
10:44:09 <lambdabot>      • Couldn't match type ‘(Int, Int)’ with ‘Int’
10:44:09 <lambdabot>        Expected type: Float -> Int
10:44:19 <EvanR> i wish there was a different notation
10:44:26 <EvanR> like, 0.1 is a lie
10:44:29 <ertes> > (floatDigits (0 :: Float), floatRange (0 :: Float))
10:44:32 <lambdabot>  (24,(-125,128))
10:44:48 <EvanR> a different notation that was more informative but still readable
10:44:54 <EvanR> ~0.1 ? :)
10:44:56 <iqubic> > sqrt 2
10:44:57 <lambdabot>  1.4142135623730951
10:45:07 <ertes> hmm…  floatRange is misleading i think
10:45:10 <iqubic> > sqrt 4
10:45:11 <iqubic>  
10:45:13 <lambdabot>  2.0
10:45:46 <ertes> > toInteger (encodeFloat 2 128 :: Float) == 2^129
10:45:48 <lambdabot>  error:
10:45:48 <lambdabot>      • No instance for (Integral Float)
10:45:48 <lambdabot>          arising from a use of ‘toInteger’
10:45:54 <mbrock> https://pbs.twimg.com/media/DJtPjWkWsAI0AFb.jpg
10:45:56 <ertes> > floor (encodeFloat 2 128 :: Float) == 2^129
10:45:59 <EvanR> sketchup displays measurements like 4" means 4 inches, ~4" means you tried some geometry that didn't round trip
10:45:59 <lambdabot>  False
10:46:03 <ertes> indeed
10:46:09 <ertes> > floor (encodeFloat 1 128 :: Float) == 2^128
10:46:12 <lambdabot>  True
10:46:24 <ertes> it's more like 30 bits of precision
10:46:55 <iqubic> I like the term mantissa a lot.
10:47:29 <ertes> > encodeFloat 2 128 :: Float
10:47:32 <lambdabot>  Infinity
10:47:42 <ertes> > floor (encodeFloat 2 128 :: Float)
10:47:44 <lambdabot>  340282366920938463463374607431768211456
10:47:50 <ertes> gotta love arbitrary numbers =)
10:47:53 <EvanR> the floor of infinity
10:48:10 <ertes> > floatRange (0 :: Double)
10:48:12 <lambdabot>  (-1021,1024)
10:48:19 <EvanR> > floor (1/0)
10:48:21 <lambdabot>  1797693134862315907729305190789024733617976978942306572734300811577326758055...
10:48:27 <ertes> > floor (encodeFloat 2 1024 :: Double)
10:48:29 <lambdabot>  1797693134862315907729305190789024733617976978942306572734300811577326758055...
10:48:52 <ertes> i suppose it's just any Integer that is larger than the largest Double
10:49:10 <ertes> > 2^1024
10:49:12 <lambdabot>  1797693134862315907729305190789024733617976978942306572734300811577326758055...
10:49:28 <ertes> > floor(1/0 :: Double) - 2^1024
10:49:29 <mud> Ya, I have a feeling that a few of those are a lot less interesting in binary.
10:49:30 <lambdabot>  0
10:49:40 <ertes> hmm…  no, it's actually the largest Double
10:50:19 <ertes> > 2^1025 == (2^1024 :: Double)
10:50:21 <lambdabot>  True
10:50:27 <ertes> huh?!
10:50:33 <EvanR> all doubles after a certain point are integers? what point? i guess i need to read that text book
10:50:35 <ertes> > 2^1025 :: Double
10:50:38 <lambdabot>  Infinity
10:50:44 <ertes> > 2^1024 :: Double
10:50:47 <lambdabot>  Infinity
10:50:50 <ertes> hah!
10:51:17 <ertes> > encodeFloat 1 1024 == (encodeFloat 1 1025 :: Double)
10:51:19 <lambdabot>  True
10:51:26 <ertes> true anyway?
10:51:30 <EvanR> inf = inf
10:51:35 <ertes> > encodeFloat 1 1024 :: Double
10:51:37 <lambdabot>  Infinity
10:51:42 <ertes> why is that infinity?
10:51:55 <ertes> > encodeFloat 1 1023 :: Double
10:51:57 <lambdabot>  8.98846567431158e307
10:52:17 <ertes> i thought Double can handle 1024
10:52:29 <EvanR> 1023 is max exponent
10:52:39 <ertes> then floatRange is lying
10:52:44 <ertes> > floatRange (0 :: Double)
10:52:47 <lambdabot>  (-1021,1024)
10:53:03 <ertes> > encodeFloat 1 (-1021) :: Double
10:53:04 <EvanR> that looks really weird, why is it off balance
10:53:05 <lambdabot>  4.450147717014403e-308
10:53:53 <ertes> FP has this weird representation thing, where it wants the mantissa to be as large as possible
10:54:01 <ertes> maybe that's what's going on?
10:54:08 <EvanR> i welcome the new unum (posit?) overlords
10:54:15 <ertes> > decodeFloat (1/2 :: Double)
10:54:17 <lambdabot>  (4503599627370496,-53)
10:54:38 <ertes> it represents 1 * 2^(-1) as 4503599627370496 * 2^(-53)
10:55:19 <ertes> i don't really understand why it doesn't normalise to the *smallest* possible mantissa
10:55:24 <EvanR> erm...
10:56:01 <EvanR> so the bits would start at a random location depending on the mantissa's number of trailing zeros?
10:56:21 <ertes> > decodeFloat (1 :: Double)
10:56:24 <lambdabot>  (4503599627370496,-52)
10:57:01 <EvanR> 1 all the way to the right, 10 left one else we confuse it with 1. 11 left one. 
10:57:19 <EvanR> nevermind thats the normal way
10:58:24 <ertes> i guess one advantage is that it can just shift, until the highest bit becomes 1 instead of searching for the position of the highest bit
10:59:18 <ertes> or second highest bit, i guess
11:00:42 <EvanR> i compiled some data the other day using Data.Fixed Centi
11:00:46 <EvanR> it was so easy
11:01:05 <EvanR> luckily i didnt need sin, exp, sqrt
11:01:15 <EvanR> because they arent implemented
11:02:53 <trikl[m]> I'm trying to build Agda 2.5.3 with Stack on NixOS. I get an encoding error from `happy`: `happy: src/full/Agda/Syntax/Parser/Parser.y: hGetContents: invalid argument (invalid byte sequence)`
11:03:25 <trikl[m]> Still, when I install Agda through nix, it works perfectly fine
11:04:19 <trikl[m]> Can I tell Stack to use the package installed on the system?
11:05:16 <cocreature> trikl[m]: are you using stack’s nix integration?
11:05:37 <trikl[m]> cocreature: yes
11:05:54 <trikl[m]> I suspect it's an issue with `LC_ALL` not being correctly set?
11:06:05 <cocreature> or LANG or something like that
11:06:08 <cocreature> try setting pure: false
11:06:44 <trikl[m]> So far that didn't crash…
11:07:27 <cocreature> I hate that the default is to infer encoding from environment variables
11:07:36 <cocreature> so far that has only caused problems for me 
11:08:19 <humanoyd> Is there a difference between `sequence` and `sequenceA` (for well-behaved Applicative/Monad instances)?
11:08:28 <monochrom> No.
11:08:47 <humanoyd> monochrom: thanks
11:12:05 <Tuplanolla> I've taken to writing languages without tco but with goto by using said goto for pretend-recursion. Is this bad?
11:12:57 <EvanR> o_O
11:12:58 <boogalooga> http://lpaste.net/359788
11:13:03 <boogalooga> Need help understanding this
11:13:17 <boogalooga> Don't understand the stuff after instance and before where
11:13:20 <boogalooga> ?
11:13:24 <osfameron> Tuplanolla: that's more or less the best approach
11:13:26 <ertes> Tuplanolla: the usual approach is to use what is called a "trampoline"
11:13:54 <osfameron> ok, the 2nd best approach ;-)
11:14:04 <cocreature> boogalooga: it says that there is an instance for (a,b) if there is an instance for a and an instance for b
11:14:09 <monochrom> Trampolining usually uses a while-loop rather than raw goto.
11:14:15 <ertes> Tuplanolla: there is a controller loop, and your tail calls are encoded as returns of "future calls"
11:14:49 <ertes> if you return saying "return this value", the loop just ends, but if you return a "future call", the loop repeats with that call
11:15:02 <boogalooga> I still don't understand
11:15:03 <monochrom> Very old GHC used to do this too.
11:15:03 <boogalooga> so
11:15:17 <ertes> Tuplanolla: goto is much faster than this though
11:15:21 <Tuplanolla> I've seen those before, but they're always more elaborate, ertes.
11:15:30 <monochrom> (See the STG paper, the section that describes what they did in GHC.)
11:15:36 <boogalooga> mainly this part (Listable a, Listable b) => Listable (a,b)
11:15:50 <cocreature> that’s what I’ve just been trying to explain :)
11:16:23 <boogalooga> okay but I don't understand what's going with all the definitions
11:16:23 <cocreature> evidently I’ve failed at that but you’ll need to be more precise about what’s confusing you since I don’t know what it is
11:16:31 <boogalooga> not sure how to read it
11:16:33 <ertes> Tuplanolla: it comes down to whether you *use* or *compile* those languages…  trampolining is a reasonable workaround when using them
11:16:34 <boogalooga> So
11:16:38 <boogalooga> usually, 
11:16:38 <Tuplanolla> Some library I used once mentioned using a trampoline to "segfault gracefully" and I spent hours pondering what that even means.
11:16:58 <boogalooga> We'll have something like instance Listable <some type> where
11:17:05 <cocreature> read it like “there is an instance of Listable for (a,b) if there is a Listable instance for a and a Listable instance for b"
11:17:08 <boogalooga> I don't understand what the => means in this case
11:17:20 <monochrom> (However, it's old. Even by the time I started using GHC, they already switched to "first generate C code that uses C function calls, then intercept the resulting asm code, then use a Perl script to convert calls to gotos", which was also briefly mentioned in the STG paper as an alternative.)
11:18:00 <cocreature> boogalooga: on the right of => is the thing you’re actually declaring the instance for, on the left are constraints that you can use in the definition of this instance
11:18:23 <Welkin> is Int32 still a proper 32-but signed integer, unlike Int?
11:18:27 <Welkin> 32-bit*
11:18:27 <cocreature> so say you have "instance Eq a => Eq [a] where …". then you can use the Eq instance of a to define equality on lists of as
11:18:48 <Welkin> why is Int only 30 bits?
11:18:56 <ertes> Welkin: it's *at least* 30 bits
11:19:03 <ertes> > maxBound :: Int
11:19:04 <cocreature> Welkin: it’s probably 64bits on your system
11:19:05 <lambdabot>  9223372036854775807
11:19:09 <geekosaur> WQelkin, standard says at least 29 bits. ghc uses fiull width'
11:19:17 <geekosaur> gah
11:19:25 <cocreature> > finiteBitSize (0 :: Int)
11:19:27 <lambdabot>  64
11:19:28 <Welkin> okay
11:19:35 <Welkin> but if I need to gaurantee exactly 32 bits
11:19:36 <boogalooga> I see
11:19:42 <Welkin> then I can't use it
11:19:43 <monochrom> GHC Int is 32 or 64 based on whether you installed 32-bit GHC or 64-bit GHC>
11:19:45 <Welkin> must use Int32
11:19:50 <cocreature> yep
11:19:51 <geekosaur> yes, and?
11:19:52 <monochrom> Int32 is 32
11:19:53 <boogalooga> I think I get it thanks
11:20:00 <geekosaur> that is what Int32 is for
11:20:09 <Welkin> I was reading about conversion between CInt and Int in the Foreign module
11:20:18 <boogalooga> I just got confused between this use of => and its use in function types
11:20:18 <geekosaur> same as ANSI C havinbg int16_t, int32_t, etc.
11:20:24 <Welkin> and it stated that converting from CInt to Int can lose precision
11:20:34 <monochrom> If you're doing FFI, Int32 is C's int32_t
11:20:38 <geekosaur> because the standard says it can but it won;t in ghc
11:20:50 <cocreature> boogalooga: it’s not so different. if you have a => in a function type you are also allowed to use the constraints on the left of the =>
11:20:51 <geekosaur> ghc doesn't take advantage of the standard allowing it to steal bits
11:20:57 <Welkin> okay
11:20:58 <ertes> Welkin: in theory…  if you want to be portable, you can't assume Int to be at least as large as CInt
11:20:59 <monochrom> Actually not "is", rather the FFI mechanism will do the lossless conversion.
11:21:05 <boogalooga> True
11:21:14 <boogalooga> but the stuff on the right is not really the same right
11:21:15 <boogalooga> ?
11:21:22 <cocreature> right
11:21:26 <boogalooga> For a function it is its inputs and outputs
11:21:27 <Welkin> well, since this is for a game, I think I'll stick with Int32, especially because I want them to be exactly 32 bits
11:21:31 <monochrom> CInt is going to be int.
11:21:37 <boogalooga> and for an instance declaration it's the type
11:21:47 <boogalooga> which is being declared as the instance
11:21:49 <ertes> Welkin: interestingly CInt is probably smaller than Int in practice
11:22:08 <ertes> Welkin: because most C compilers use 32-bits int
11:22:24 <monochrom> It can be very simple if you don't make it complicated. Iff your C code says "int", use CInt. Iff your C code says "int32_t", use Int32.
11:22:26 <ertes> even for 64 bit targets
11:22:32 <cocreature> > finiteBitSize (0 :: CInt)
11:22:34 <lambdabot>  error:
11:22:34 <lambdabot>      Not in scope: type constructor or class ‘CInt’
11:22:34 <lambdabot>      Perhaps you meant one of these:
11:22:43 <cocreature> @let import Foreign.C.Types
11:22:44 <lambdabot>  Defined.
11:22:45 <cocreature> > finiteBitSize (0 :: CInt)
11:22:47 <lambdabot>  32
11:22:49 <monochrom> And I simply recommend not using Int when FFI is involved.
11:23:09 <Welkin> 32 bits values are preferred over 64 by the cpu I thought
11:23:12 <glguy> The time to use Int when FFI is involved is when the function you're calling uses HsInt
11:23:13 <Welkin> especially for floating point values
11:23:19 <geekosaur> huh?
11:23:28 <Welkin> for SIMD operations
11:23:38 <geekosaur> C on 64 bit archs sticking with 32 is purely a backward compatibility thing
11:23:48 <geekosaur> for int
11:24:07 <ertes> you can always use int32_t for better SIMD utilisation
11:24:19 <ertes> there is no technical reason why they would stick with 32-bit int
11:25:07 <monochrom> I have trouble understanding backward compatibility as a non-technical reason...
11:25:53 <ertes> being in the haskell community for such a long time i understand backward-compatibility as a social/economical thing
11:26:08 <monochrom> Oh, that.
11:26:38 <monochrom> Actually I guess I don't classify refinedly and precisely.
11:27:27 <monochrom> Turbo C int was 16 bits.
11:27:40 <geekosaur> enough people remember how much iot sucked when 32 bits became common that they didn't want to repeat it
11:28:35 <monochrom> I think Microsoft C int too, back in the Turbo C days.
11:29:00 <ertes> i think most of the real-mode DOS compilers used 16 bit int
11:29:33 <geekosaur> ^
11:29:35 <monochrom> The first time GCC came to x86 PCs was after 386 so they started with 32-bit int.
11:30:05 <ertes> it was with stuff like DJGPP for DOS that i first made contact with 32-bit int
11:30:11 <monochrom> Yeah, DJGPP.
11:30:48 <monochrom> It had to run a "DOS extender" which means running 32-bit programs (32-bit int and pointer) in an otherwise 16-bit DOS.
11:32:32 <monochrom> I actually appreciated the 16-to-32 increase without changing my source code. Because my deeply recursive algorithms finally worked. :)
11:32:55 <geekosaur> qemm!
11:33:03 <ertes> hehe
11:33:15 <ertes> i knew nothing of functional programming back then
11:33:27 <ertes> in fact i think i hadn't even seen or even thought of recursion
11:33:45 <monochrom> Oh me neither, I just used non-tail recursion in Pascal and C for even linked list algorithms.
11:34:11 <monochrom> I did have a university education back then.
11:34:31 <monochrom> But unlike other students, I loved and embraced recursion on first sight.
11:35:10 <monochrom> Actually I already thought of recursion when doing BASIC before university. I just didn't actually do anything abou the thought.
11:35:18 <ertes> i didn't, because i was thinking of stack usage…  i was one of those C programmers =)
11:35:36 <forelle> morning
11:35:38 <monochrom> Mainly because without parameter passing or local var, recursion in BASIC is basically useless. (Pun!)
11:35:55 <forelle> I'm making a naive backtracking sudoku solver in haskell and I have an interesting issue
11:36:08 <monochrom> Oh I was aware that GOSUB used a stack, too.
11:36:09 <forelle> it solves correctly, but only on almost full grids
11:36:19 <forelle> http://github.com/Lerrpy/sudocurry
11:36:23 <monochrom> But couldn't put my own parameter or data on stack. Meh.
11:36:53 <monochrom> Then in university I saw Pascal and my dream came true. Finally meaningful recursion.
11:37:08 <forelle> correctly return Just (solved grid) on almost full grids, but returns Nothing when the input has more than just a few blank spaces
11:37:13 <monochrom> (Of course, didn't know the word "recursion" until university.)
11:37:37 <forelle> if anybody can help I'd be a happy man
11:38:07 * geekosaur remembers using fixed variables for that. and then writing a program to preprocess almost-BASIC source into actual BASIC, with labels instead of line numbers and actual subs with parameters
11:40:59 <monochrom> Right, for non-recursive GOSUBs you can reserve a few global variables for parameter passing and return value.
11:42:09 <geekosaur> and for recursive ones back them with arrays :)
11:42:11 <monochrom> Fun fact: When Peter Naur announced that his Algol compiler accepted recursion, people didn't believe him because people's compiler was written exactly that way, for each procedure set aside fixed static space for params.
11:42:39 <geekosaur> even more fun, the same was done for the return address usually
11:42:47 <monochrom> Yeah.
11:43:27 <cocreature> I’m never sure if I should be happy or sad that I’m too young to have had to deal with this kind of stuff
11:43:34 <geekosaur> s/360 didn't even have a stack register, and none of its indexed addressing modes were quite right to emulate it
11:43:38 <monochrom> Actually Peter Naur also admitted that it took him a while to think up using a stack. One of those things obvious in hindsight, meh.
11:45:07 <monochrom> But what's wrong with some of the audience was that even after Peter Naur announced it, and even demoed it I think? the response was "but it's impossible!" rather than a more neutral, curious "how did you get it to work?"
11:46:26 <monochrom> cocreature: You will have the privilege to tell your kids and grandkids: "Back in my days, Windows updates usually required rebooting." :)
11:47:11 <cocreature> monochrom: that sounds less fun :)
11:47:40 <monochrom> But I do have the privilege to tell you: Back in my days, installing any device driver or even user-space software on Windows also required rebooting.
11:47:54 <int-e> monochrom: well the demo is unconvincing, everybody can compile enough copies of the function to cover the required recursion depth ;-)
11:48:13 <Welkin> windows shouldn't exist that much longer
11:48:17 <monochrom> Actually back in my days there was no line between user space and rootuser space and kernel space, I guess.
11:48:24 <Welkin> it'll be nice to hear kids say "wtf is windows?"
11:48:54 <Welkin> just like I heard some kids on halloween say "what's a pikachu?"
11:48:57 <Welkin> that was just sad though
11:49:10 <Tuplanolla> "Remember when operators were divided into programmers and users?"
11:49:28 <int-e> . o O ( what is a pikachu? all I've seen are pictures )
11:49:40 <Welkin> remember when computers were black women?
11:50:23 <monochrom> Anyway, "lambda the ultimate goto" is a fun paper to read.
11:53:44 <monochrom> Fun fact: FFI converts for you Haskell Bool to C int the expected way: True is 1 or non-zero, False is 0.
12:03:13 <Tuplanolla> I thought that was the job of `tagToEnum#`.
12:04:56 <monochrom> Oh the auto-generated code probably uses tagToEnum#
12:05:29 <monochrom> The point is you don't have to care, you just write high-level code and everything just works.
12:06:07 <Tuplanolla> How does `bool` from C99 map to this since it's not necessarily the same size as `int`?
12:06:57 <monochrom> Probably doesn't map at all.
12:23:23 <grex> how do u import outside hackage dependencies to a project?
12:26:06 <grex> I'm trying to use three-penny gui, so first i did cabal install threepenny-gui, and then edited the .cabal file of my project by adding threepenny-gui to build-depends. But when I call cabal build, it has the error: unknown package: threepenny-gui (dependency of pman-0.1.0.0) fail (backjumping, conflict set: pman, threepenny-gui) After searching the rest of the dependency tree exhaustively, these were the goals I've had most trouble f
12:26:27 <grex> (the name of my project is pman)
12:26:33 <Welkin> did you use stack?
12:26:56 <grex> nope i just called cabal
12:27:12 <Welkin> try building with stack
12:27:14 <fr33domlover> grex, it's probably best to use stack
12:27:34 <monochrom> threepenny-gui is inside hackage, not outside hackage.
12:27:56 <monochrom> But you need cabal install --dependencies-only
12:28:02 <trikl[m]> I can't get to install Agda 2.5.2 with Stack    (neither lts 9.4 or 9.6)
12:28:15 <iqubic> What is the best Haskell Gui Framework?
12:28:25 <trikl[m]> It doesn't seem to play nicely with happy
12:28:38 <grex> im trying to use three-penny. Before i tried reflex but it froze my laptop for over 20 mins when trying to run the shell
12:28:41 <monochrom> But if you mean you already did that, then I don't know.
12:29:01 <grex> thanks I'll try stack
12:29:13 <merijn> monochrom: Or use new-build if he has cabal 2.x
12:29:26 <merijn> grex: Do you have cabal-install 2.x?
12:29:38 <grex> i have the latest cabal, is that what u mean?
12:29:41 <merijn> (cabal -V)
12:29:49 <grex> yup
12:30:08 <merijn> grex: What happens if you run "cabal new-build" in the directory with the .cabal file?
12:32:34 <MarcelineVQ> the 'use stack' knee-jerk reaction just makes people then have to ask what a resolver is, how do I use hacakge packages with stack, why do I still get a exhaustive dependency search error :X
12:32:56 <monochrom> I agree, I have that suspicion too.
12:33:01 <merijn> MarcelineVQ: honestly "try new-build" is probabl a decent first try for people not using stack
12:33:34 <merijn> Apart from the things that aren't actually implemented yet, the whole user experience for new-build is pretty much what I always wanted from cabal-install
12:33:49 <monochrom> I didn't voice it because I had faith that the two people who said "use stack" up there actually knew what was going on in the question rather than just being knee-jerk preachers.
12:35:25 <monochrom> But sometimes such programmers are even worse than knee-jerk preachers.
12:36:02 <sm> iqubic: what are your criteria ?
12:36:14 <monochrom> If you are unhappy, or if you're worried about social problems, a typical Christian pastor would give you the blanket response "come to church", yes, much like the use-stack sayers.
12:36:23 <Welkin> lol what
12:36:39 <Welkin> typically, dependecy issues can be solved by just using stack
12:36:44 <trikl[m]> As per https://paste.debian.net/994179/ that should install Agda 2.5.2 against happy 1.9.5, right?
12:36:46 <monochrom> But unlike the use-stack sayers, the pastor would also take some time to actually ask you and listen to your specific concern.
12:37:03 <trikl[m]> Which is, from what I've read, a combination that should work — but it doesn't
12:37:09 <merijn> Welkin: Except you have to redo your entire workflow to work with stack
12:37:27 <Welkin> you do?
12:37:38 <Welkin> just add a stack.yml and run stack build
12:37:38 <merijn> Welkin: Well, maybe YOU don't
12:37:41 <monochrom> Whereas programmers just want to be spin doctors without any investigation or diagnosis. "Just install xxx." "Just put yyy into your file."
12:37:50 <merijn> Welkin: Most people who use cabal instead of stack don't like stack's workflow
12:38:11 <merijn> Welkin: Stack is a case of "if it matches your workflow, it's fine. If it doesn't, go F yourself"
12:38:12 <Welkin> I think most people who are *new* who use it just don't know stack exists
12:38:19 <Welkin> and they are using outdated tutorials that use cabal-install
12:38:36 <merijn> Welkin: Given that the most popular book atm recommends stack I'm not so sure
12:38:37 <geekosaur> here we go again. monochrom is right
12:38:41 <sm> these are just tools people
12:38:42 <hpc> monochrom: i think that's just the default position of most people in general
12:38:45 <hpc> understanding is hard :P
12:39:05 <Welkin> the most popular book is LYAH
12:39:34 <merijn> Welkin: CIS194 and HaskellBook have eclipsed LYAH by a lot, if these channels are any indication
12:39:46 <merijn> Anyway, this is not a particularly interesting discussion
12:39:50 <grex> didnt work :( , guess ill try stack
12:39:52 <Welkin> not from outside the community
12:39:52 <MarcelineVQ> trikl[m]: hmm I don't think so, happy is a building tool, but not a dependecy exactly. Agda doesn't depend on happy in it's cabal file, so listing it in extra-deps won't affect Agda in the way you need
12:40:02 <Welkin> anyone outside only knows about LYAH
12:40:20 <merijn> Fun times...I get to debug my golden test being wrong on only a single platform...
12:40:28 <trikl[m]> MarcelineVQ: Oh right, that explains it, thanks so much
12:40:41 <merijn> grex: What was the error for new-build? And can you lpaste your cabal file?
12:41:01 <grex> new-build worked
12:41:26 <grex> but when i do cabal run it has the same missing dependencies error. 
12:41:38 <merijn> grex: Try if "new-run" works
12:41:58 <monochrom> "cabal run" is not designed for new-build.
12:42:10 <merijn> grex: new-X are the future replacements of X, but not everything is done yet, but the old commands certainly don't work with new-build
12:42:15 <grex> http://lpaste.net/2191580803077505024
12:42:37 <merijn> grex: Does "cabal new-run pman" work?
12:43:06 <grex> merijn: THANKS!
12:43:08 <grex> yea
12:43:15 <monochrom> OK good to hear.
12:43:37 <merijn> grex: Good :) You may want to have a look at https://cabal.readthedocs.io/en/latest/nix-local-build-overview.html in the near future for more info on new-build
12:44:00 <grex> thanks, ill definitely check that out, and will learn stack later too
12:46:34 <MarcelineVQ> trikl[m]: what are you trying to do by the way, get any new Agda or specifically 2.5.2?
12:47:19 <trikl[m]> MarcelineVQ: specifically 2.5.2, because agda-snippets depends on it
12:47:40 <trikl[m]> (I've tried to update it to support 2.5.3 but it was not trivial)
12:48:14 <trikl[m]> My quest for specifying a concrete happy version to be used by stack is unsuccessful so far
12:48:32 <royal_screwup21> I'm trying to understand how to define Eq without deriving it automatically. I came across this https://thepasteb.in/p/wjh0xv0DZ4Ecv but I don't understand the first two lines beginning from instance. Where did c and d come from? And what's Const doing?
12:48:54 <MarcelineVQ> Alrighty, resolver lts-9.3 has Agda-2.5.2 are you able to use that resolver?
12:49:50 <paolino> royal_screwup21, Const is a typo
12:50:03 <trikl[m]> Does 9.4 not have it too? Because I remember 9.3 having happy 1.9.6 which doesn't work with Agda 2.5.2
12:50:31 <paolino> royal_screwup21, should be Cons
12:51:40 <royal_screwup21> paolino: ah okay. Can you walk me through the first two lines? I know the syntax for instance but I can't quite figure out what's happening in those 2 lines
12:51:53 <MarcelineVQ> 9.3 has 1.19.6, regardless it's stack's job to sort out build-tool details out for packages it supports, Agda-2.5.2 being in lts-9.3 means it can be built using that resolver, if not then it's a bug/error
12:52:08 <merijn> royal_screwup21: THose two lines are defining an implementation for (==)
12:52:16 <paolino> royal_screwup21, the (=) make the definition of (==)
12:52:33 <monochrom> royal_screwup21: Do you already know pattern-matching? Meaning, if I wrote this function "f (Cons a b) (Cons c d) = blah blah" would you understand?
12:53:19 <trikl[m]> MarcelineVQ: on lts-9.3 Agda 2.5.2 breaks
12:53:38 <trikl[m]> (I'm trying again just to make sure, but I did try that before)
12:53:38 <MarcelineVQ> breaks isn't a very informative error :>
12:53:52 <merijn> hmmm
12:54:03 <merijn> The links to the ghc-7.8 bindist on OSX are dead?
12:54:08 <trikl[m]> Sorry, I will paste the traceback once I get it — it takes my potato a while to compile these things
12:54:48 <MarcelineVQ> Mine too, actually I can't even use stack at the moment due to OS issues or I'd be trying solutions for you
12:55:08 <trikl[m]> But yeah, it's something to do with happy
12:55:26 <merijn> Just to be sure, can someone check what happens if they click the apple-darwin links here? https://downloads.haskell.org/~ghc/7.8.2/
12:55:38 <glguy> merijn: the 7.8.4 one just worked for me
12:55:52 <merijn> glguy: ah, maybe it's just shitty Haskell SEO getting to me
12:55:55 <MarcelineVQ> merijn: 404
12:56:03 <glguy> merijn: but yes, the 7.8.2 didn't work for me
12:56:34 <merijn> glguy: I don't care about 7.8.2 specifically, that's just what I found when googling for the 7.8 download :p
12:56:47 <merijn> So it's an issue, just not mine :p
12:57:09 <monochrom> Well, the apple-ios ones are also 404's, for that matter. Maybe something to do with iPhone X release? <duck>
12:58:11 <monochrom> Hmm what are those numbers in the rightmost column?
12:58:20 <merijn> MarcelineVQ: I think sizes?
12:58:43 <paolino> royal_screwup21, on the left of (=) you see it matches (takes apart) values of "List a" and on the right it defines how to compute the equality in terms of what has been matched
12:59:23 <geekosaur> the Const looks like a typo
12:59:31 <monochrom> Would you have problem believing that README.ios.html is 10 times bigger than ghc-7.8.2-arm-apple-ios.tar.bz2? :)
12:59:44 <geekosaur> should have been Cons
12:59:50 <royal_screwup21> paolino: hmm, okay...but how is it recursing forwards?
12:59:55 <MarcelineVQ> monochrom, merijn: byte count
13:00:02 <paolino> royal_screwup21, it cleverly reuses (==) from some other instance or same instance
13:00:19 <merijn> monochrom: Yeah, that seems wrong
13:00:30 <merijn> monochrom: These look better: https://downloads.haskell.org/~ghc/7.8-latest/
13:00:32 <monochrom> royal_screwup21: "b == d" is the recursive call.
13:00:34 <paolino> royal_screwup21, (a == c) is equality for type 'a'
13:00:47 <royal_screwup21> ah I see it now
13:01:10 <monochrom> a==c is also why you need the "Eq a" assumption.
13:04:00 <royal_screwup21> paolino: how do I test this out? It compiles alright but I want to see if this definition works. I tried [1,2,3]==[1,2,3] on ghci (after loading and compiling the file) and it returns True, but how do I know that it used the definition in the file, as opposed to the inbuilt Eq for lists?
13:04:33 <paolino> that is not using it
13:04:58 <paolino> royal_screwup21, [] is another constructor 
13:05:29 <royal_screwup21> oh right
13:05:30 <geekosaur> you were using the standard list type there. you have to build a List according to the constructors defined in the paste
13:05:41 <paolino> Cons 1 (Cons 2 (Cons 3 Nil)) = ..
13:06:41 <merijn> Right...time for whiskey if I'm gonna debug this nonsense...
13:07:02 <paolino> royal_screwup21, if you use :t on [1,2,3] you will see the type
13:07:10 <paolino> which is not List a
13:07:24 <royal_screwup21> yup just realized :)
13:10:03 <merijn> well...shit
13:10:28 <MarcelineVQ> shucks!
13:10:29 <merijn> I just realised I'm having a nice race condition in my test, probably
13:15:24 <merijn> Am I an evil person if I avoid a race by simply inserting a sleep? >.>
13:17:08 <forelle> can a function return a list of maybes?
13:17:15 <merijn> forelle: Sure?
13:17:52 <forelle> for some reason I have a function with signature [[Int]] -> [Maybe [[Int]]] that sometimes just returns "Nothing"
13:18:19 <geekosaur> that sounds wrong
13:18:27 <forelle> sure diddly does don't it
13:18:48 <MarcelineVQ> so what's the code
13:19:04 <codeshot> merijn, depends on the nature of the system and the contested resource's place in the system
13:19:04 <forelle> http://github.com/lerrpy/sudocurry
13:19:11 <forelle> naive backtracking sudoku solver 
13:19:37 <forelle> The greater issue is that it solves correctly, but only when just a few squares are empty
13:19:48 <codeshot> All races are avoided with a sleep somewhere in the pipeline (even if it's somewhere deep in the CPU, a transistor switches slowly so the resource has time to be released
13:19:59 <forelle> when the input isn't almost solved it returns "Nothing" 
13:20:10 <forelle> when really it should find a solution to any solvable grid
13:20:14 <codeshot> but sleeps prevent good testing and don't always solve the problem
13:20:18 <royal_screwup21> paolino: I'm not sure I understand why it's instance Eq a => Eq (List a) where, as opposed to instance  Eq (List a)  ==> Eq (List a)
13:20:39 <codeshot> so if you do it without proper analysis we say you have deceived your customer like a cowboy roofer
13:20:43 <paolino> royal_screwup21, the second one you have it for free
13:20:55 <geekosaur> royal_screwup21, 'if you have an Eq instance for a, you can make an Eq instance for List a, as follows:
13:20:56 <geekosaur> '
13:21:16 <MarcelineVQ> oh, so the issue isn't that solList :: [[Int]] -> [Maybe [[Int]]] is something Nothing, it's that backtrack :: [[Int]] -> Maybe [[Int]] is sometimes Nothing
13:21:30 <forelle> no but that's normal
13:21:54 <geekosaur> is it me or is the otherwise case just doing catMaybes the hard way?
13:21:54 <forelle> if you look at the fail case, it's Nothing when the current first empty cell has no legal moves
13:22:19 <geekosaur> oh, hm, no
13:22:24 <paolino> royal_screwup21, the Eq a is necessary to test equality on elements of the list
13:22:28 <forelle> geekosaur: teach me! I started this project to learn haskell
13:23:04 <forelle> MarcelineVQ: I tested just solList on a completely empty grid and it gave me "Nothing"
13:23:06 <forelle> instead of a list
13:23:19 <royal_screwup21> paolino: ah I get it now, thanks!
13:23:28 <paolino> royal_screwup21, like monochrom said (a == c) needs it
13:23:31 <merijn> argh
13:23:47 <geekosaur> sorry, not quite the same thing
13:23:51 <geekosaur> I was misreading
13:24:03 <merijn> My brilliant way to workaround tasty's inability to redirect output turns out in hindsight wasn't quite so brilliant >.>
13:25:05 <forelle> this is really quite frustrating, I can't find the issue at all
13:25:56 <MarcelineVQ> forelle: erm, that's not something that can happen though, solList on an empty grid is an index exception
13:26:08 <MarcelineVQ> is https://raw.githubusercontent.com/Lerrpy/sudocurry/master/solve.hs the most recent version?
13:26:24 <forelle> yes
13:26:31 <forelle> I meant empty grid as in empty sudoku puzzle
13:26:42 <forelle> which is list of 9 lists of 9 zeros
13:27:44 <forelle> what it should do is try putting all the possible legal moves in the first empty (zero) square
13:27:46 <forelle> and solving those
13:27:47 <trikl[m]> MarcelineVQ: http://lpaste.net/359791 This is with lts-9.3
13:27:58 <forelle> that's how the backtrack makes a move
13:28:18 <forelle> it tries all the possible moves in a square and takes the first one that ends up down the line on a success case
13:28:57 <royal_screwup21> paolino: what does "instance Eq a => Eq (List a)"  mean in words? Specifically the "=>" part of it? If it's implies, than what exactly is being implied?
13:29:12 <MarcelineVQ> what are you actually trying forelle? so that I'm trying the same thing   "solList (replicate 9 (replicate 9 0))  [*** Exception: Maybe.fromJust: Nothing"
13:29:29 <geekosaur> royal_screwup21, I told you that earlier. rephrasing ti in terms of 'implies' should be simple
13:29:56 <geekosaur> [04 20:20:32] <geekosaur> royal_screwup21, 'if you have an Eq instance for a, you can make an Eq instance for List a, as follows:'
13:29:58 <forelle> is that not just Nothing? is it a list of Nothings?
13:30:08 <paolino> given you have an Eq instance for 'a', that's the instance of Eq (List a)
13:30:09 <MarcelineVQ> no it's an exception, a program failure
13:30:14 <forelle> oh damn
13:30:20 <MarcelineVQ> no result in other words
13:30:53 <forelle> I don't get why
13:30:56 <royal_screwup21> ah okay, thanks folks!
13:31:10 <forelle> I'm fromJust a nothing somewhere
13:31:16 <forelle> gotta fix that eh
13:31:17 <MarcelineVQ> correct
13:31:27 <forelle> is there a traceback
13:31:48 <forelle> oh my god I'm such a dummy
13:31:55 <forelle> it's find
13:32:04 <MarcelineVQ> yes but I've not really used it so I can't advise
13:32:43 <forelle> find sometimes returns Maybe 
13:32:54 <forelle> when it doesn't find an item in the list that matches the predicate
13:33:02 <forelle> and this is actually part of my logic
13:33:08 <forelle> I just can't just fromJust on it obviously
13:33:56 <MarcelineVQ> find always returns Maybe a, sometimes that value is  Just a  and sometimes it's  Nothing
13:34:08 <forelle> yeah
13:34:09 <MarcelineVQ> @src Maybe
13:34:09 <lambdabot> data Maybe a = Nothing | Just a
13:34:35 <forelle> and find giving Nothing is good, it's a fail case 
13:34:39 <forelle> when it happens i need to backtrack
13:34:42 <paolino> forelle you could 'join' the two Maybe layers there
13:34:49 <forelle> what do you mean
13:35:13 <paolino> :t join :: Maybe (Maybe a) -> Maybe a
13:35:14 <lambdabot> Maybe (Maybe a) -> Maybe a
13:35:38 <MarcelineVQ> trikl[m]: What command did you type for that attempt?
13:36:19 <paolino> :t join . find isJust
13:36:20 <lambdabot> Foldable t => t (Maybe a) -> Maybe a
13:37:03 <forelle> omg yes this is what I'm looking fod
13:37:06 <forelle> for
13:37:11 <forelle> brb
13:39:20 <paolino> forelle which should be msum
13:39:33 <forelle> so like join (find (\g -> isJust g) (solList grid))
13:39:35 <forelle> ?
13:39:48 <paolino> :t msum :: [Maybe a] -> Maybe a
13:39:50 <lambdabot> [Maybe a] -> Maybe a
13:39:56 <trikl[m]> MarcelineVQ: `stack install --no-nix-pure`
13:40:30 <paolino> > msum [Nothing, Nothing, Just 1]
13:40:33 <lambdabot>  Just 1
13:40:34 <trikl[m]> I'm going to try to update agda-snippets to support Agda 2.5.3 instead, but it doesn't seem easy
13:40:47 <forelle> what if there are more than two justs though
13:40:58 <forelle> I kind of want to get only the first one
13:41:04 <paolino> > msum [Nothing, Nothing, Just 1, Just 2]
13:41:06 <lambdabot>  Just 1
13:41:11 <forelle> oh wow.
13:41:19 <forelle> and i need to import.... control.monad?
13:41:40 <paolino> I guess
13:43:28 <forelle> oh my god
13:43:32 <forelle> thank you so much
13:43:34 <forelle> it works hahahah
13:43:42 <Myrl-saki> Is the ESP(x86) being used as a GPR in GHC?
13:43:57 <forelle> this project started out over a year ago and I abandoned it due to lack of time and I was out of ideas
13:44:42 <forelle> yesterday I was thinking about it and it kept me awake and I got an idea for the first time in months and I got up, scratched it down and put it in first thing this morning
13:44:49 <MarcelineVQ> trikl[m]: my first try would be something like  stack unpack agda-snippets && cd agda-snippets-2.5.2  <edit agda-snippets.cabal to say Agda-2.5.3 in the lib section>  stack init --solver && stack build
13:44:52 <forelle> and it was the right idea I just had one dumb mistake
13:45:03 <forelle> @ paolino MarcelineVQ thanks a lot!
13:45:07 <geekosaur> Myrl-saki, it's still needed for some things
13:45:20 <trikl[m]> MarcelineVQ: I did that, but there are some changes in Agda's API
13:45:30 <trikl[m]> I was getting two errors, I solved one of them so far :)
13:45:37 <geekosaur> FFI calls, possibly calling out to GC during allocations (and possibly the allocations themselves), ...
13:45:40 <Myrl-saki> geekosaur: Such as? We were talking about languages that don't use ESP in ##programming
13:45:51 <Myrl-saki> geekosaur: Ah.
13:45:58 <MarcelineVQ> trikl[m]: I see, what a pain, not sure why you can't use 2.5.2 but I can't really test things on my end atm
13:46:24 <paolino> forelle, you could try to switch to arrays ans see if it's faster
13:46:32 <forelle> I mean
13:46:46 <forelle> it solved an empty grid instantly
13:47:05 <MarcelineVQ> I'd be inclined to try going  stack --resolver=lts-9.3 install Agda  outside of any project just to see if it can build without the project complicating things
13:47:14 <forelle> as sudoku solvers go, it'll only be slow on grids specifically designed against backtracking solvers
13:47:23 <trikl[m]> MarcelineVQ: the pain might result in something useful I do for once :')
13:47:45 <trikl[m]> The project itself isn't that complicated, the only other dependency is hakyll
13:49:26 <adrien91> Hi guys, I'm kind of confused how the zip implementation with foldr works. Can someone explain this to me? Link: https://pastebin.com/r7y37Na0
13:52:11 <monochrom> adrien91: I don't understand it either. But I know how I can understand it. I turn foldr back into handwritten recursion.
13:53:24 <monochrom> "blah = foldr f e" means the same as the handwritten recursion "blah [] = e; blah (x:xs) = f x (blah xs)"
13:53:38 <monochrom> So you do that to myzip and see what happens.
13:54:49 <adrien91> @monochrom : thanks ill do that
13:54:49 <lambdabot> Unknown command, try @list
13:55:02 <monochrom> The converse is also true. If someone gives me recursive code and ask "is it a foldr?" I begin by trying to fit the recursive code into that template.
13:55:03 <Cale> > foldr (\x xs -> \case [] -> []; (y:ys) -> (x,y) : xs ys) (\ys -> []) [1,2,3,4,5] [6,7,8,9,10]
13:55:05 <lambdabot>  [(1,6),(2,7),(3,8),(4,9),(5,10)]
13:55:18 <forelle> dang lambdabot is a neat dude 
13:56:12 <trikl[m]> MarcelineVQ: Got it working!
13:56:59 <benzrf> question:
13:57:00 <paolino> Cale, xs is a misleading name 
13:57:06 <benzrf> if i use a record type, i can do this:
13:57:12 <Cale> It's the result of folding the remainder of the list
13:57:33 <byorgey> that's why it's misleading =)
13:57:40 <benzrf> @let data TwoLists a = TwoLists {list1 :: [a], list2 :: [a]} deriving Show
13:57:41 <lambdabot>  Defined.
13:58:16 <benzrf> > fix (\tl -> tl {list1 = 1:list2 tl, list2 = 2:list1 tl} )
13:58:20 <lambdabot>  *Exception: <<loop>>
13:58:23 <benzrf> wait wuh
13:58:32 <monochrom> paolino: I use (\x r -> ...). I also write the type like "(a -> r -> r) -> r -> [a] -> r"
13:58:42 <Cale> I kind of like it for some reason. I think of foldr f z as replacing the (:)'s throughout the list with f and the [] (if any) with z
13:59:03 <benzrf> oh hold on
13:59:06 <monochrom> This is because I conflate foldr with CPS. In CPS they like to say "r".
13:59:06 <Cale> and so it's natural to think of the parameters to the replacement for (:) as being x and xs, even if xs has a different type now :)
13:59:31 <benzrf> ah, is record update too strict for this?
13:59:43 <monochrom> Oh record update is pretty strict, yeah.
14:00:10 <benzrf> @let twoLists = TwoLists {list1 = 1:list2 twoLists, list2 = [1, 2, 3]}
14:00:12 <lambdabot>  Defined.
14:00:14 <benzrf> > twoLists
14:00:16 <lambdabot>  TwoLists {list1 = [1,1,2,3], list2 = [1,2,3]}
14:00:19 <benzrf> there we go i guess
14:00:28 <monochrom> Record update demands the data constructor at the very least.
14:00:30 <byorgey> benzrf: but since you're updating both fields, you don't need to do a record update at all
14:00:33 <byorgey> right
14:00:35 <benzrf> yeah :)
14:00:45 <benzrf> anyway - is there something comparable i can use if i want a map with arbitrary string keys?
14:00:53 <dsal> Control.Concurrent.Async isn't quite behaving as I'd expect.  I'm doing a waitAny on a couple of Asyncs.  As soon as one completes, my function returns.  I may be misunderstanding something.
14:01:01 <nshepperd> uguu, -fplugin is still broken with profiling
14:01:06 <dsal> This is my waitN function.  It does what I expect when none complete. https://www.irccloud.com/pastebin/isT9l4wz/waitn.hs
14:01:18 <dsal> oh.  duh
14:01:21 <dsal> Thanks everyone.
14:01:31 <nshepperd> looks like i need to learn ghc to help fix it
14:01:44 <byorgey> > let twoLists = TwoLists {list1 = 1 : list2 twoLists, list2 = 2 : list1 twoLists} in twoLists
14:01:46 <lambdabot>  TwoLists {list1 = [1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1...
14:01:53 <benzrf> actally hold on
14:01:59 <byorgey> benzrf: comparable to what exactly?
14:03:00 <benzrf> nvm lmao this worked https://i.imgur.com/1OwAxvM.png
14:03:16 <benzrf> i tried something a bit less sensible a minute ago and concluded that Data.Map wouldnt work
14:04:02 <forelle> oh also
14:04:09 <forelle> did yall like the stupid name i gave my solver
14:04:50 <byorgey> benzrf: ah, yeah, that definitely works.  In fact it's a really nice way to express dynamic programming (with a lazy array defined in terms of itself)
14:04:55 <benzrf> :)
14:05:28 <monochrom> benzrf: IIUC this requires Data.Map.Lazy
14:05:37 <benzrf> yeah it doe
14:05:39 <benzrf> s
14:05:41 <forelle> IIUC?
14:05:52 <forelle> understand. got it. never heard that one
14:07:17 <paolino> and also to express finite state automata
14:10:40 <monochrom> IIUC = if I understand correctly
14:11:38 <monochrom> Data.Map.Lazy is a great way to store an environment (of an evaluator/interpreter of lambda calculus, say)
14:15:16 <monochrom> I killed the conversation.
14:16:14 <BartAdv> hey, I'm using intero with intero-devel-reload workflow, and I've noticed it doesn't redirect stderr to the *messages* buffer. And as it turns out, Debug.Trace.trace prints to stderr...
14:25:40 <merijn> What's the PVP policy on adding a field to a record? Bump A.B?
14:27:40 <monochrom> Hmm that's a tough one.
14:28:57 <monochrom> pvp.haskell.org's wording is "the definitions of datatypes or classes were changed" which reads like yes it's an A.B
14:29:58 <monochrom> But that may be too paranoid
14:30:04 <Eduard_Munteanu> You won't be able to make values from scratch without knowledge of the field, so it should be a breaking change.
14:31:03 <merijn> I feel like I should've not exported the constructor, just the fields and the default value...
14:31:06 <merijn> oh well
14:31:53 <monochrom> OK but these days some authors export a "default value for you to start from, and then you just override the fields you need overriding" to mitigate this, so now it is not so breaking.
14:32:19 <merijn> That's what I did, except I ended up accidentally exporting the constructor due to not paying attention >.>
14:38:34 <Eduard_Munteanu> Hmm... if we had a smart editor and a smarter way to represent source code, perhaps we could encode granular dependencies on specific declarations and do away with versioning (at least for that purpose).
14:40:06 <monochrom> That's what Backpack did. :)
14:40:40 <Eduard_Munteanu> What's Backpack? That alone isn't very googleable.
14:40:51 <merijn> Eduard_Munteanu: ezyang's thesis work
14:41:03 <Eduard_Munteanu> Ah, thanks, *looks*
14:41:06 <merijn> Eduard_Munteanu: http://blog.ezyang.com/category/haskell/backpack/
14:41:36 <monochrom> "haskell backpack" works fairly OK
14:41:56 <monochrom> BTW compare "michael jackson" with "michael jackson software"
14:42:28 <monochrom> Haha Fossil Haskell Weekender Bag?!
14:43:12 <Eduard_Munteanu> I wasn't sure this was about Haskell at all. :)
14:43:28 <monochrom> Then again maybe that's specific to Canadian users because it's from a Canadian department store.
14:44:11 <Eduard_Munteanu> Yeah, I don't get that among the first results.
14:45:10 <merijn> monochrom: Well, looks like I'm saved by "the change I wanted to make doesn't work anyway" so I don't have to modify my record :p
14:45:53 <nshepperd> welp, anyone have any ideas how I can somehow profile my application without using -prof (which is incompatible with ghc plugins)?
14:46:02 <monochrom> Haha merijn
14:46:36 <merijn> monochrom: Well, I can't make it work, just not the "nice" way I was envisioning, so I need to add a new name, but that's only an A.B.C bump
15:41:24 <black0range> Does anyone here have some experience with ghcjs and reflex-dom? 
15:42:27 <black0range> The latest version on hackage is pretty out of date and the version on github doesn't compile
15:42:57 <verlet64> Hello
15:45:07 <ahstro> verlet64: Hello
15:45:17 <black0range> verlet64: Hej
15:45:32 <verlet64> How are you all?
15:46:07 <ahstro> Tearing my hair out at trying to build a package with Nixpkgs, but otherwise fine. You? :)
15:46:44 <verlet64> I was tearing my hair out trying to work out how to refactor my application to use mtl
15:46:56 <verlet64> Got kind of late though so I thought time to leave it
15:47:52 <ahstro> Rough.. Late coding always feels like a good idea until the morning after, when you realize your mistakes
15:48:46 <verlet64> Yeah that's about the size of it, hah
15:49:14 <verlet64> Nix seems pretty cool
15:50:15 <ahstro> Yeah, I've only played with it for about a week, but I'm liking it so far.
15:50:36 <merijn> ahstro: If you're not too invested in Nix, you might wanna have a look at new-build?
15:50:48 <ahstro> Kind of a hard time finding out how things work though. Not the best website in the world
15:50:56 <mbwgh> Does anybody have any experience with the `concurrency` and `dejafu` packages and the refactorings necessary for code that is a little more involved (than say, just using plain TVars)?
15:51:00 <ahstro> merijn: What's that?
15:51:04 <merijn> ahstro: It's the suite of future replacements for cabal-install's commands, which is Nix inspired
15:51:16 <merijn> ahstro: https://cabal.readthedocs.io/en/latest/nix-local-build-overview.html
15:52:03 <merijn> ahstro: It's basically like all your cabal stuff is automagically running inside a sandbox that can share previously build dependencies amongst each other ;)
15:52:31 <ahstro> merijn: Ooh, interesting! I'm running NixOS though, so I need to figure that stuff out
15:52:48 <merijn> ahstro: Right, if you're already tied to Nix then you're probably better off learning that :)
15:54:23 <barrucadu> mbwgh: I wrote them, so I do
15:57:34 <merijn> ugh...
15:57:54 <merijn> Apparently exporting fields without constructor makes haddock act up...
16:01:14 <mbwgh> barrucadu: That's great! I thought I was able to squeeze my question in here, but ugh... If you have a few minutes spare, I'll try to whip up an lpaste.
16:03:42 <barrucadu> Sure
16:05:19 <dsal> Hmm...  async cancellation is a bit hard to reason about.  If I'm calling Network.connectTo from a thread that's killed, how do I avoid leaking?
16:05:52 <merijn> dsal: Call connectTo in bracket from Control.Exception
16:06:06 <merijn> And yes, async exceptions are incredibly hard to reason about
16:06:34 <dsal> Can you halfway clean up a connectTo?  i.e., if it's not connected, do I still close it?
16:07:23 <dsal> Oh, it self-brackets.
16:07:37 <dsal> OK.  This makes sense.
16:07:50 <dsal> Guess that's what those source links are for.  :)
16:23:57 <monochrom> self-bracket --- the next best thing if you can't self-destruct :)
16:24:12 <monochrom> "This note will self-bracket in 30 seconds"
16:25:19 <merijn> Any clue how long it takes until a newly uploaded package shows up locally when I run "cabal update"?
16:25:43 <hpc> it's not instant?
16:25:59 <merijn> hpc: Well, I just uploaded and I'm not getting anything, so...no?
16:26:03 <monochrom> As soon as Hackage posts it, I would think?
16:26:25 <monochrom> Speaking of which, I need to run cabal update too.
16:26:36 <merijn> monochrom: The new version is visible on the website
16:27:06 <merijn> ah, there we go, it seems
16:27:25 <monochrom> I have actually not tested this, so I might have been speaking out of thin air.
16:27:39 <merijn> Seems to work now :)
16:28:57 <geekosaur> it's using cloudflare so it can take a little time for stuff to propagate
16:29:07 <geekosaur> not too long but not instantaneous
16:29:19 <monochrom> To be sure the 00index.tar file and the web interface are two data paths and there is no reason they have to finish at precisely the same time.
16:29:58 <jared-w> 00index.tar? What a name
16:30:25 <monochrom> Let me look again for the precise name. But it isn't far from that.
16:30:34 <hpc> deleteme.tar
16:30:44 <MarcelineVQ> 00-index.tar
16:31:00 <merijn> Anyway, since hackagebot is down, let me pimp my own stuff...
16:31:33 <merijn> For anyone who's using Travis for testing, have a look at https://hackage.haskell.org/package/tasty-travis and tell me anything that's missing/broken/unclear
16:31:37 <monochrom> 00-index.tar for cabal < 2, 01-index.tar for cabal >= 2
16:31:45 <mbwgh> barrucadu: Ok, I tried to extract the code in question here: http://lpaste.net/359793 . I've written a small application that I use interactively and kill quite often. I needed some ad-hoc logging solution and for pedagogical purposes I wrote my own. On the other hand, I needed to be able to log messages in an stm block, without messages being lost if I kill the process. Since there were a lot of articles 
16:31:51 <mbwgh> out there recently that dealt with testing of code written against mtl-style effect classes, I wrote classes like MonadLogger and MonadHttp etc. The logging in IO and STM worked with what I came up with, and I was able to write everything against some abstract 't' over IO, which encapsulates the scary effectful parts. However, I was not really able to substitute IO with MonadConc. While I can refactor the 
16:31:57 <mbwgh> application code, at the point where I have to choose some concrete transformer stack, things get weird quickly, regardless of whether I substitute TQueue a with a conservative TQueue (STM IO) a, or the more general TQueue stm a. So given the code in the hpaste, and especially `someFun`, what should the concrete refactored types (the TQueue and the transformer encapsulating the effect) look like?
16:32:01 <merijn> I'm almost 80% sure the README example actually compiles :p
16:32:35 <MarcelineVQ> nice thats 14% better odds than most randomly chosen packages
16:32:45 <monochrom> You can look under your own $HOME/.cabal/packages/hackage.haskell.org for great good.
16:33:33 <merijn> MarcelineVQ: Well, the plan was to link to one of my other packages as example, but that one isn't ready yet so I had to strip out the relevant bit :p
16:33:49 <iqubic> What even is MTL?
16:34:14 <merijn> iqubic: The library?
16:34:24 <merijn> iqubic: Monad Transformer Library
16:35:00 <iqubic> I mean I don't even understand why you need monad transformers in the first place.
16:35:31 <monochrom> Right, I usually don't need monad transformers.
16:35:36 <merijn> iqubic: You don't "need" them, they're just convenient sometimes
16:36:05 <iqubic> Why are they convenient?
16:36:36 <merijn> And to continue pimping my own stuff. If you thought "Boy...I'd love to try that tasty-travis package, but I can't be arsed to write out the test trees for tasty (or benchmark trees for criterion)...": https://hackage.haskell.org/package/paramtree
16:37:12 <jared-w> iqubic: because monad transformers let you write effects that are polymorphic in the monad
16:37:47 <monochrom> Now you're doomed to spend all night explaining what you mean by that. :)
16:38:00 <verlet64> ahstro: couldn't help myself..grabbed the laptop and am diving back in
16:38:12 <monochrom> err, doomed to spending! Damn English.
16:38:15 <merijn> And if your excuse is "I don't know how to configure Travis CI...", you can try my (not yet merged upstream) version of multi-ghc-travis, now with proper cabal.project support and supports multiple local packages in the same repo: https://github.com/merijn/multi-ghc-travis
16:38:30 <jared-w> Monads do not compose in general, so you can't just smash two monads together and get a useful result in the end. But, suppose you figure out a way to glue those monads together... You could call it "transforming" one monad into another
16:38:55 <ahstro> verlet64: Haha, that's the spirit! I'm in a similar boat; think I finally figured out how to build the package!
16:39:06 <jared-w> Do that often enough and you find some common patterns happening, you abstract them a bit, and make a typeclass that helps automate that glue code from one type of monad to another
16:39:09 <iqubic> jared-w: Can I have an example?
16:39:31 <jared-w> a "maybe" type represents the idea "I either have a type, or I don't have anything"
16:39:44 <merijn> I think that's all my yaks released into the wild, for now...
16:39:56 <jared-w> and a reader monad says "I have some environment variables from configuration that I want my code to be able to access"
16:40:06 <jared-w> But... what if that environment variable could either be there or not be there?
16:40:14 <iqubic> I know I tried writing the MaybeT Functor Applicative and Monad at one point.
16:40:18 <ahstro> verlet64: Strike that.. Did not work. Everything is hell
16:40:29 <jared-w> I'd /really/ like to be able to glue together a "maybe reader" somehow
16:40:37 <iqubic> I think I still have that code lying around.
16:41:10 <jared-w> and a monad transformer basically lets you glue one monad into another. The mtl is essentially several pre-defined and organized typeclasses for several common  patterns people have found useful
16:41:13 <verlet64> ahstro: is there any devil more cunning than the misleading successful build 
16:41:24 <verlet64> no is the answer
16:41:45 <iqubic> No, actually I lost that code.
16:41:53 <ahstro> it is, indeed
16:42:02 <verlet64> No but seriously ops style stuff is terrible for this
16:42:10 <iqubic> I don't have my implementation of MaybeT laying around anymore.
16:42:12 <monochrom> mbwgh: I'm afraid LoggerT STM will only "log" the final successful transaction and completely forgets all the unsuccessful rollbacked ones.
16:42:18 <ahstro> verlet64: ops style stuff?
16:42:20 <jared-w> So you can say "I have a monad and I want to be able to use it any time I would be able to use a reader monad" and you can say "I have a monad and I want to use it anytime I could use a maybe monad" and you can then use the mtl and glue those together to get "I have my two monads blended together so they act like a reader monad that may or may not actually have a value"
16:42:37 <verlet64> Building packages, applications, deploying stuff
16:42:48 <jared-w> That is essentially the intuition behind monad transformers in general. Mtl is only just one way to do that sort of thing
16:42:53 <ahstro> verlet64: Ah, yeah
16:42:59 <monochrom> Although, maybe that's just what you want. Then godspeed.
16:43:14 <verlet64> ahstro: full of "no errors but nothing works" moments
16:43:18 <iqubic> jared-w: What does that type look like?
16:43:33 <iqubic> ReaderT Maybe foo?
16:43:50 <merijn> verlet64: That's why you don't trust it until the tests pass ;)
16:43:53 <iqubic> Where you might read Foo, or you might not have any foo to read.
16:44:08 <mbwgh> monochrom: But isn't this the behaviour you would want? Since I use this LoggerT for "logging" results as well, it would be weird (and for my purposes wrong) if they were logged more than once.
16:44:30 <monochrom> Ah OK, then we're in good agreement.
16:44:36 <merijn> mbwgh: Well, if you wanna log STM to debug your STM transactions then you'd want something different :)
16:44:36 <jared-w> Depends on the monad transformer library used, how you're transforming things, etc. But that is essentially it (that might not be the exact type, I can't think of the right one off hand with 100% surity, but it's the right idea)
16:44:40 <mbwgh> monochrom: I know that my "logging solution" sucks, btw. But it has worked for me so far.
16:45:09 <verlet64> merijn: heh, I mean more dev ops style jobs rather than code - not my normal role, but sometimes you gotta wear the hat
16:46:10 <monochrom> Sometimes, when it's cold and windy, I have to wear the hood, too, like today.
16:46:27 <mbwgh> merijn: It's not about debugging STM code, it's about being able to log messages inside an atomically block. It may be that "logging" is the wrong word here. I basically just have a TQueue that contains errors, txt messages and results, and these are written to different files from another thread.
16:46:47 <merijn> mbwgh: Sure, monochrom was just pointing out the limitations of the approach
16:47:44 <merijn> Right...bed time
16:48:10 <ahstro> merijn: Night
16:48:38 <barrucadu> mbwgh: This is tricky.  The obvious thing to do is to parameterise the LogConfig with the monad type, but that then messes up the MonadTrans instance for LoggerT, hmm
16:50:11 <fragamus> hmm is anyone using haskell-mpfr? I'm having problems installing in stack
16:51:19 <mbwgh> barrucadu: You can still write it by hand, it's just LoggerT . lift. But then the weirdness just continues
16:52:34 <johnw_> mbwgh: when logging in STM, the repeated logs actually give you insight as to when retries are happening (and where)
16:54:59 <crucify_me> hi does the stack begin with even, and get passed back and forth between the 2 functions? I always think the expansion and reduction occurs in a place.
16:55:04 <crucify_me> https://ptpb.pw/2XsG
16:55:09 <mbwgh> johnw_: How would that work? If I'm inside an atomically block, I would have to break referential transparancy for that to happen, for instance via unsafePerformIO (or may via unsafeSTMToIO or whatever it's called). Is this what you had in mind?
16:57:17 <lyxia> crucify_me: yes
16:57:53 <lyxia> crucify_me: actually you can use either function depending on whether you want to get the even elements or the odd ones
16:58:35 <verlet64> Half feel like I'm speed running Mario 64
16:58:42 <verlet64> "this is the run"
16:59:02 <hpc> and then it gets through your .Internal module
16:59:05 <johnw_> mbwgh: yes, exactly
16:59:05 <hpc> "the run is blessed"
16:59:22 <monochrom> I look forward to Mario 128.
16:59:22 <johnw_> mbwgh: executing IO in STM is fine, as long as you realize it may run any number of times
16:59:57 <verlet64> monochrom: They're skipping straight to 256 for backwards compat reasons
17:00:08 <monochrom> Ah that's even better.
17:02:07 <crucify_me> lyxia, thanks one moment
17:02:39 <mbwgh> johnw_: Might be useful for debugging purposes, yes.
17:03:48 <EvanR> to one-up firefox version numbers ms will be switching to increasing powers of 2 each week
17:04:16 <hpc> chrome is switching to up-arrow notation
17:04:20 <hpc> each release adds an arrow
17:04:22 <johnw_> mbwgh: I used it to do exactly that kind of logging before, and it worked out
17:04:51 <EvanR> another iteration of ackerman
17:04:56 <crucify_me> lyxia I see that they are passed, but the cons is written in the even function, so it essentially stays there as its passed?
17:06:11 <iqubic> hpc: How would that work?
17:06:22 <verlet64> Opera, meanwhile, have decided to change to exactly the same system as Chrome
17:07:13 <monochrom> No one likes Roman version numbers, eh? You just add an "I" for each next version.
17:07:29 <mbwgh> johnw_: I need to log atomically only because I update some statistics inside of it, and it would be an error if I decremented some number of results and the corresponding value was not commited as well. Especially since I recover from restart
17:07:35 <iqubic> monochrom: Except when you don't. 
17:07:41 <monochrom> And for some reason that sounds isomorphic to adding an arrow for each next version... :)
17:08:31 <mbwgh> They should add my add-ons not being broken by the next version.
17:08:39 <ertes> i wonder when our browsers will run out of natural numbers
17:08:39 <verlet64> Firefox?
17:08:49 <EvanR> the core data of the version number is ultimately a number that increments, and they are try to outcompete on the choice of view
17:09:02 <EvanR> monotonic view
17:09:03 <monochrom> Haha run out of natural numbers. That's very hard to do!
17:09:17 <verlet64> With that attitude it is
17:09:21 <verlet64> New style semver
17:09:24 <geekosaur> run out of memory for them. you always wondered why it was so big?
17:09:25 <EvanR> ertes: floor (1/0) right? javascript
17:09:25 <verlet64> Everything is major
17:09:44 <mbwgh> oh god, here it comes. firefox-S(S(S(S(S(S(S(...
17:09:48 <verlet64> Because we make a big impact with every deploy
17:10:11 <ertes> i don't know…  i can totally see issue number \omega_{15} asking whether inaccessible cardinals are consistent enough to use as version numbers
17:10:25 * geekosaur might be a bit grumpy after having his browser suddenly freeze his system while eating half his swap space yesterday...
17:10:31 <monochrom> Oh yeah no wonder they sell PCs with 12GB RAM when I only find use for just 6GB or less.
17:10:48 <iqubic> mbwgh: Are you claiming we should use peano numbers to label versions?
17:10:57 <EvanR> curiously Math.floor(1/0) is not 179769313486231590772930519078902473361797697894230657273430081157732675805500963132708477322407536021120113879871393357658789768814416622492847430639474124377767893424865485276302219601246094119453082952085005768838150682342462881473913110540827237163350510684586298239947245938479716304835356329624224137216 
17:11:06 <lyxia> crucify_me: I'm not sure what you mean. The list of elements with even indices of a list (x : xs) starts with x (of index 0), and continues with the list of odd-indexed elements of xs (taking the tail shifts the indices by 1). That's exactly what that code says.
17:11:11 <hpc> monochrom: the funny thing is some browsers will preemptively load stuff to fill available ram
17:11:29 <mbwgh> iqubic: Yeah, the 'Z' was implied.
17:11:33 <ertes> my firefox uses more RAM than my first hard disk
17:11:47 <ertes> 812 MB
17:12:00 <EvanR> i think i had 10 MB
17:12:09 <monochrom> And Firefox already uses less memory than Chrome.
17:12:22 <mbwgh> By the way, is it true that GHCJS needs at least 8GB? I wanted to try out reflex, but decided against it because I'm a poor plebeian with only 4GB.
17:12:33 <monochrom> I go with Chrome because it's more concurrent than Firefox. But it also eats more memory.
17:13:05 <ertes> mbwgh: GHC already uses a lot of RAM, and GHCJS takes it to a whole new level…  i wouldn't be surprised, if you need at least 8 GiB for larger code bases
17:13:22 <hpc> monochrom: i find that in practice, noscript is better than any sort of optimizations the browser could perform
17:13:24 <monochrom> "whole new level" :S
17:13:27 <iqubic> Ram == Swap, right?
17:13:35 <mbwgh> ertes: I actually read that it needs 16, and 8 was the recommended minimum D:
17:13:59 <hpc> because it's not an optimization problem on something that doesn't change over time, developers consume the resources available
17:14:17 <monochrom> Oh so that's why PCs are sold with 16GB RAM so you can run GHCJS.
17:14:34 <monochrom> Totally not because of Windows, eh? :)
17:14:37 <mbwgh> I guess GHC = GHCJS + NoScript
17:14:53 <monochrom> haha very logical conclusion :)
17:15:03 <ertes> mbwgh: well, what you can do is to use native GHC during development – that's kinda the standard mode of development with reflex-dom – then compile on your server
17:15:06 <johnw_> mbwgh: you could log your data with a generated id, and then log a "commit" message at the end of the trans with that id.  Later, when you process the log, only count the entries that have commits.
17:15:29 <monochrom> @rememeber mbwgh I guess GHC = GHCJS + NoScript
17:15:29 <lambdabot> Good to know.
17:15:59 <iqubic> Windows eats a ton of ram, right?
17:16:16 <ertes> iqubic: swap is disk space as an extension of RAM
17:17:05 <monochrom> www.ramtrucks.com
17:17:07 <iqubic> Is swap good to have?
17:18:17 <monochrom> Yes, it's why 5 years ago they added swap to base.
17:18:21 <ertes> iqubic: usually yes…  modern kernels use it both to get unused memory out of RAM to make more space for caching, and when you run out of RAM
17:18:37 <monochrom> Except it took another year after to settle on whether they wanted it strict or non-strict.
17:18:53 <iqubic> swap (a, b) = (b, a)???
17:18:53 <ertes> what did they settle on?
17:19:02 <mbwgh> ertes: I don't have a server though (well I do have access to some HPC clusters...). I feel there is some optimization potential here though
17:19:08 <monochrom> I forgot, but you could find it in base source code :)
17:19:30 <monochrom> My bet is "why not offer both versions?"
17:19:31 <mbwgh> barrucadu: Still there?
17:19:37 <monochrom> @quote monochrom pointless.debate
17:19:38 <lambdabot> monochrom says: All pointless debates can be settled by going polymorphic.
17:19:40 <ertes> > case swap undefined of (_, _) -> ()
17:19:42 <lambdabot>  *Exception: Prelude.undefined
17:20:18 <barrucadu> mbwgh: Yeah, still working on it
17:20:26 <ertes> @let daTrueSwap ~(x, y) = (y, x)
17:20:28 <lambdabot>  Defined.
17:20:33 <ertes> > case daTrueSwap undefined of (_, _) -> ()
17:20:36 <lambdabot>  ()
17:20:47 <ertes> that's how it's done!
17:20:58 <iqubic> What does "~" do?
17:21:03 <mbwgh> barrucadu: Oh boy. I thought this was just me being stupid :)
17:21:14 <monochrom> No, that's the wrong question.
17:21:22 <hpc> iqubic: irrefutable match
17:21:27 <monochrom> The right question is What doesn't "~" do?
17:21:50 <iqubic> monochrom: Can you answer that question then?
17:22:03 <ertes> > let f (_, _) = (); g ~(_, _) = () in f undefined
17:22:05 <lambdabot>  *Exception: Prelude.undefined
17:22:06 <ertes> > let f (_, _) = (); g ~(_, _) = () in g undefined
17:22:09 <lambdabot>  ()
17:22:09 <monochrom> It doesn't cause evaluation.
17:22:12 <ertes> iqubic: ^
17:22:27 <hpc> it also doesn't really do any matching either
17:22:45 <monochrom> Right.
17:22:55 <hpc> > let f ~(Just x) = x in f Nothing
17:22:57 <lambdabot>  *Exception: <interactive>:3:5-19: Irrefutable pattern failed for pattern Just x
17:23:16 <iqubic> Huh, WTF is that?
17:23:40 <ertes> iqubic: if you use an irrefutable match (g ~(x, y) = _), it's like you write (g xy = …), and then whenever you refer to 'x' or 'y' the compiler rewrites it to (fst xy) and (snd xy)
17:24:15 <iqubic> so what happened in the Maybe case?
17:24:20 <ertes> now that you're no longer actually *matching* anything, function application doesn't actually look at the value, and only when you refer to components of it is the actual match done
17:24:41 <iqubic> So it introduces laziness?
17:24:53 <ertes> it rather does *not* introduce eagerness
17:25:02 <hpc> iqubic: it's not actually doing a case-of kind of thing, it just goes "pretend this pattern match is bringing these things into scope"
17:25:16 <monochrom> Oh isn't this fun, this looks like a conservation law of bottoms.
17:25:18 <barrucadu> mbwgh: I was so close, then realised I was wrong :(
17:25:19 <hpc> > let f mx = fromJust mx in f Nothing -- this is basically what it is
17:25:21 <lambdabot>  *Exception: Maybe.fromJust: Nothing
17:25:38 <ertes> (the Maybe example is actually a bad example, because the function is strict anyway)
17:25:38 <monochrom> Irrefutable patterns removes one source of bottom and adds a new one.
17:25:49 <hpc> this is the same thing let-in does, btw
17:25:57 <hpc> > let f mx = let Just x = mx in x
17:25:58 <mbwgh> barrucadu: Haha, I had the same situation. Only after refactoring my whole application and trying to implement the top transformer stack :/
17:25:59 <lambdabot>  <no location info>: error:
17:25:59 <lambdabot>      not an expression: ‘let f mx = let Just x = mx in x’
17:26:02 <hpc> > let f mx = let Just x = mx in x in f Nothing
17:26:04 <lambdabot>  *Exception: <interactive>:3:16-26: Irrefutable pattern failed for pattern Ju...
17:26:14 <ertes> > let f (Just x) = [x] in f Nothing
17:26:17 <lambdabot>  *Exception: <interactive>:3:5-20: Non-exhaustive patterns in function f
17:26:18 <ertes> > let f ~(Just x) = [x] in f Nothing
17:26:20 <lambdabot>  [*Exception: <interactive>:3:5-21: Irrefutable pattern failed for pattern Ju...
17:26:27 <ertes> see the difference?  it's subtle =)
17:27:14 <mbwgh> You need this kind of stuff with MonadFix. Other than that, I haven't found any real use for it. (Or MonadFix, for that matter...)
17:27:32 <monochrom> Heh
17:27:34 <mbwgh> But one of those days, I'll relabel a tree for sure
17:29:12 <ertes> > Control.Monad.State.Strict.evalState (fix $ \again -> do x <- get; put (x + 1); fmap (x :) go) 0
17:29:15 <lambdabot>  error:
17:29:15 <lambdabot>      Not in scope: ‘Control.Monad.State.Strict.evalState’
17:29:15 <lambdabot>      Perhaps you meant one of these:
17:29:26 <ertes> > Control.Monad.Trans.State.Strict.evalState (fix $ \again -> do x <- get; put (x + 1); fmap (x :) go) 0
17:29:29 <lambdabot>  error:
17:29:29 <lambdabot>      Not in scope: ‘Control.Monad.Trans.State.Strict.evalState’
17:29:29 <lambdabot>      No module named ‘Control.Monad.Trans.State.Strict’ is imported.
17:29:43 <wilx> Hi.
17:29:47 <ertes> @import qualified Control.Monad.State.Strict as Strict
17:29:47 <lambdabot> Unknown command, try @list
17:29:51 <ertes> @let import qualified Control.Monad.State.Strict as Strict
17:29:53 <lambdabot>  Defined.
17:29:57 <ertes> @let import qualified Control.Monad.State.Lazy as Lazy
17:29:58 <lambdabot>  Defined.
17:30:00 <wilx> Let's say there are a lot of same string literals in a long Haskell source file.
17:30:08 <ertes> > Strict.evalState (fix $ \again -> do x <- get; put (x + 1); fmap (x :) go) 0
17:30:10 <lambdabot>  error:
17:30:10 <lambdabot>      • Variable not in scope: go :: Strict.StateT a Identity [a]
17:30:10 <lambdabot>      • Perhaps you meant one of these:
17:30:11 <monochrom> You mean my http://lpaste.net/41790/ :)
17:30:18 <ertes> oh, come on
17:30:20 <wilx> Would it make sense to replace "abcd" with abcd = "abcd" and use abcd everywhere instead?
17:30:21 <ertes> sorry
17:30:25 <ertes> > Strict.evalState (fix $ \again -> do x <- get; put (x + 1); fmap (x :) again) 0
17:30:31 <lambdabot>  mueval-core: Time limit exceeded
17:30:33 <ertes> > Lazy.evalState (fix $ \again -> do x <- get; put (x + 1); fmap (x :) again) 0
17:30:33 <wilx> Is this anyhow more efficient? Either for compilation or for run time?
17:30:35 <lambdabot>  [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
17:30:44 <ertes> mbwgh: ^
17:31:00 <mbwgh> So you finally fixed it :)
17:31:11 <ertes> the difference between lazy State and strict State is not on whether it forces the state itself, but whether it uses strict pattern-matching on the tuple
17:32:13 <mud> Oh is that the difference. I don't think I was ever clear on that.
17:32:23 <ertes> wilx: you should benchmark, but even if GHC actually duplicates the strings, it shouldn't make too much of a difference, except that you get worse cache behaviour
17:33:05 <crucify_me> lyxia thanks sorry disconnect here. what I was asking is if, since the cons is featured in the even function, if it stays there, or, as the stack expands, does it get passed to odds, so to speak, or does it "stay in place"
17:33:56 <mbwgh> wilx: Besides that, programmer performance should increase would you happen to change abcd to "abcde".
17:34:14 <crucify_me> since the cons is lazy and the new list is built later.
17:35:47 <mbwgh> ertes: Still, do you use fix/mfix on a regular basis? While I learned a lot when reading up on it (Especially the similarity between Fix and Free), I actually found it easier to make wrong code typecheck if you factor out recursion, especially with `recursion-schemes`.
17:36:20 <codeshot> mbwgh, how did you get that to happen?
17:37:14 <codeshot> foo = fix foo_step where foo_step recurse = ... seems so similar to me
17:38:41 <ertes> mbwgh: yes, i use both fairly regularly, although the former i mostly use to embed anonymous recursion into monadic actions
17:39:00 <ertes> main = …; fix $ \again -> … again …; …
17:39:13 <iqubic> :t fix
17:39:14 <lambdabot> (a -> a) -> a
17:39:15 <ertes> mbwgh: the latter comes up a lot in FRP, so i'm also a regular user of mfix
17:39:19 <iqubic> :t Free 
17:39:20 <lambdabot> error: Data constructor not in scope: Free
17:39:29 <iqubic> :k free 
17:39:30 <lambdabot> error:
17:39:30 <lambdabot>     Not in scope: type variable ‘free’
17:39:30 <lambdabot>     Perhaps you meant type constructor or class ‘Tree’ (imported from Data.Tree)
17:39:41 <iqubic> :k Free 
17:39:42 <lambdabot> error:
17:39:42 <lambdabot>     Not in scope: type constructor or class ‘Free’
17:39:42 <lambdabot>     Perhaps you meant ‘Tree’ (imported from Data.Tree)
17:40:03 <ertes> mbwgh: although i use it via RecursiveDo, because using mfix (or loop from Control.Arrow) directly is a pain =)
17:41:03 <iqubic> mbwgh: The kind of Free is (* -> *) -> *
17:43:03 <ertes> the kind of Free is (* -> *) -> * -> *
17:43:27 <mbwgh> codeshot: I can't really come up with a prototypical example, and it was probably just me not being used to it.
17:44:47 <ertes> mbwgh: are you comfortable with foldr and unfoldr?
17:46:09 <mbwgh> ertes: I know they're not the same, but it's Fix + pure basically. And while it might be nice to get started with frp, the ghcjs thing kind of was a show stopper for me, and I couldn't figure out an easy entry point of making gtk work with reactive-banana without having to rely on some unmaintained packages exposing weird combinators...
17:46:43 <ertes> mbwgh: i use FRP mainly on bare metal
17:46:46 <mbwgh> ertes: foldr for sure, but I haven't really found any need for unfoldr.
17:47:17 <ertes> mbwgh: do you see how foldr is the combinator for list catamorphisms?
17:47:45 <mbwgh> Yeah, it's basically the church encoding, right?
17:48:13 <ertes> even though it is, that's not the reason foldr is list catamorphisms
17:48:27 <ertes> mbwgh: do you know how [] is encoded in terms of Fix?
17:49:10 <mbwgh> ertes: You mean the Nil case for some ListF ?
17:49:29 <mbwgh> Otherwise no, sorry.
17:49:42 <ertes> yes, that
17:50:26 <ertes> [a] ≃ Fix (ListF a)
17:50:39 <ertes> where:  data ListF a x = Nil | Cons a x
17:50:50 <ertes> the catamorphism constructor for that looks like this:
17:51:05 <ertes> cata :: (ListF a x -> x) -> Fix (ListF a) -> x
17:51:14 <ertes> clear so far?
17:51:30 <mbwgh> ok
17:52:04 <ertes> now cata is actually just foldr
17:52:22 <ertes> its type is isomorphic to foldr's type…  do you see how?
17:54:44 <mbwgh> ertes: Well you have to pattern match on ListF, effectively giving you (a -> b -> b) and b.
17:54:59 <mbwgh> Well not giving you, you have to implement the cases.
17:55:23 <mbwgh> So the F-Algebra is the first two arguments to foldr, the way I see it
17:56:07 <mbwgh> (Does that make sense)?
17:56:21 <ertes> exactly (to your first response)
17:56:36 <ertes> yes
17:56:47 <ertes> in cata the F-algebra is the first argument
17:57:16 <ertes> you pick both an object 'x' and a function (F x -> x)
17:57:28 <ertes> that's an F-algebra
17:57:34 <ertes> in this case a (ListF a)-algebra
17:58:01 <ertes> unfoldr is the same with s/cata/ana/
17:58:34 <ertes> unfoldr :: (x -> Maybe (a, x)) -> x -> [a]
17:58:50 <ertes> listAna :: (x -> ListF a x) -> x -> Fix (ListF a)
17:59:04 <ertes> here the F-coalgebra encoding is even more visible
18:01:00 <ertes> recursion-schemes even gives you three data structure encodings to choose from
18:01:38 <ertes> Fix is the usual algebraic encoding
18:02:06 <ertes> Mu is the initial encoding:  Mu (ListF a) ≃ forall x. (ListF a x -> x) -> x
18:02:25 <ertes> Nu is the final encoding:  Nu (ListF a) ≃ exists x. (x -> ListF a x, x)
18:02:53 <ertes> so Mu encodes as a fold, Nu encodes as an unfold
18:03:27 <mbwgh> Yeah, initial and final encodings was really the point where I had to bail out when I looked into it, especially since if you google it, you quickly run into scary Oleg.
18:04:24 <ertes> Nu is easy to understand, if you think of it operationally…  you have an initial state of some unknown type 'x', and you have a function that, given an x, gives you either a Cons with a new x, or a Nil
18:11:14 <mbwgh> Ok, and Mu is just the fold itself? And why are they called initial and final encoding? When would I choose which?
18:12:20 <mbwgh> I think the terms initial and final are more general and I have heard of them in the context networking as well.
18:12:29 <mbwgh> +of
18:13:48 <ertes> mbwgh: not sure about the names, but i assume it's related to initial algebras and final coalgebras
18:14:31 <ertes> mbwgh: the reason you would use Mu is the same reason you would use (forall x. (a -> x -> x) -> x -> x) or the church-encoded version F/FT of Free/FreeT
18:15:12 <ertes> mbwgh: not really sure when you would use Nu…  i don't see any use cases
18:15:34 <mbwgh> Ok I didn't expect that :)
18:15:46 <ertes> i can see use cases of a variant of Nu, where there is a constraint on the state
18:16:27 <ertes> data SerialisableNu f = forall x. (Binary x) => SerialisableNu (x -> f x) x
18:16:59 <ertes> now you can save "the rest of the list" in terms of the current state
18:17:08 <ertes> or send it over the network
18:17:30 <ertes> something you can't do with Fix, because the state is implicit
18:19:52 <barrucadu> mbwgh: So I have a pretty nasty and poor solution which I recommend you don't actually adopt: https://misc.barrucadu.co.uk/LPaste.hs
18:24:26 <dsal> Anyone know how to test optparse applicative option parsers?  They want a ReadM -- I don't know how to make one of those.
18:29:15 <mbwgh> barrucadu: I feel there should be an easier solution, possibly by replacing MonadLogger with some data or type family. The non-total pattern matches are indeed undesirable. Do you think this would've been easier if someFun was of type `(MonadThis m, MonadThat m) => m ()` instead of `t m ()`? The former would've been my intention anyway. Also, if I happened to get a sensible transformer working, would I 
18:29:20 <mbwgh> really have to implement MonadConc? This is more boilerplate than all other mtl instances combined. Would it be possible to define the class itself with some default signature? For practical purposes, my own transformers would redelegate to the underlying monad anyway.
18:31:47 <mbwgh> barrucadu: If we take for granted that my LoggerT transformer just plain sucks, would you happen to have an example of how `concurrency` was intended to be used in a real application? All I could find was examples involving plain variables, and I couldn't find the code mentioned in the papers either.
18:31:58 <ertes> mbwgh: what problem are you trying to solve?
18:32:38 <ertes> dsal: https://hackage.haskell.org/package/optparse-applicative-0.14.0.0/docs/Options-Applicative-Builder.html#g:3
18:32:44 <olligobber> muhaha, I'm working on a project that involves interfacing with a python program, and the python users were passing it floats while everyone had to restrict themselves to passing ints, but then I wrote a testcase where python code would pass fractions, and they all failed!
18:33:09 <olligobber> that probably belonged in the off-topic channel...
18:33:33 <dsal> ertes: oh hey, thanks.
18:33:43 <barrucadu> mbwgh: So here's one of the schedulers from the Par monad using Control.Concurrent.Classy, which involves monad transformers and state, and is more of a real-world example: https://gist.github.com/barrucadu/740bd39a10aa28db7251d984cf4e0516
18:35:56 <dsal> ertes: Actually, this is what I've got.  I may be a bit confused, but I have a    :: ReadM T   function and want to make a ReadM from a string so I can try to parse it.
18:36:19 <dsal> maybe that's maybeReader
18:37:42 <ertes> dsal: ReadM is really just a failure monad with an implicit string to parse…  it's not even a proper parser monad
18:37:45 <mbwgh> ertes: I've written a small application for downloading pictures interactively, that makes use of STM. Since I kill it frequently and resume with the previous state after restart, I needed to be able to "log" errors and results inside atomically blocks, since the messages emitted needed to be consistent with shared state. I tried to refactor my code to mtl-style effect classes, and now functions look like 
18:37:51 <mbwgh> `(MonadLogger (t IO) <-- logging outside of atomically block, MonadLogger (t STM) <-- logging inside of it, MonadHttp t) => t IO ()`. I made a class MonadLogger m where ... with a corresponding LoggerT = LoggerT (ReaderT LogEnv m a), and while with some hoisting this worked (for example, see http://lpaste.net/359793), I couldn't get it to work with barrucadu's `concurrency` package.
18:38:10 <barrucadu> mbwgh: The difficulty in your case comes from wanting to be able to mix LoggerT STM and LoggerT IO in the same expression, which is difficult when STM and IO are now type variables
18:38:21 <ertes> mbwgh: you want to log even if the transaction fails?
18:38:36 <ertes> mbwgh: i.e. in the middle of transactions?
18:39:37 <dsal> ertes: It's just not clear to me how to shove the string into it and then execute within that environment.
18:40:29 <ertes> dsal: i don't see a way to do it…  for some reason the optparse-applicative authors felt that ReadM is an exceedingly super-dangerous monad that can destroy the universe when used wrong
18:40:44 <dsal> Oh good.  I feel slightly less dumb now.  :)
18:40:46 <ertes> dsal: the way to test your parsers is to write them separately without using ReadM
18:40:51 <dsal> I'll just refactor my thing... yeah
18:41:08 <dsal> All it does is pull the string out and <|> it.
18:41:10 <ertes> dsal: just use Alternative or MonadFail
18:41:39 <ertes> then it will be compatible with maybeReader/eitherReader
18:41:50 <jagajaga_> @pl a = \f -> fold . mconcat . map f
18:41:50 <lambdabot> a = ((fold . mconcat) .) . map
18:43:20 <mbwgh> ertes: No, only if it succeeds. So, say I compute a result or encounter an error. Inside an atomically block I modify some counter, and want to log the error or result, i.e. add them to some TQueue. So in the end, what I see inside my results.txt for instance, has to be consistent with the current application state, at least after a restart.
18:43:58 <ertes> mbwgh: you could just pass a (String -> STM ()) around in your application
18:43:59 <mbwgh> barrucadu: I don't need them to mix in the same expression I think. I'm not sure.
18:44:04 <ertes> mbwgh: that would be my approach
18:44:46 <Axman6> 8:t  \f -> fold . mconcat . map f
18:44:50 <Axman6> :t  \f -> fold . mconcat . map f
18:44:52 <lambdabot> (Monoid (t c), Monoid c, Foldable t) => (a -> t c) -> [a] -> c
18:45:05 <Axman6> :t  \f -> fold . mconcat . fmap f
18:45:05 <ertes> mbwgh: IMO "logger monads" are an anti-pattern
18:45:06 <lambdabot> (Monoid (t c), Monoid c, Foldable t) => (a -> t c) -> [a] -> c
18:45:19 <Axman6> :t foldMap
18:45:20 <lambdabot> (Monoid m, Foldable t) => (a -> m) -> t a -> m
18:45:48 <mbwgh> ertes: Yeah I head some ReaderT with all the nasty functions inside in the beginning. I wanted to try out where refactoring to mtl-style signatures would take me, but this quickly becomes overly complicated and maybe shows that typeclasses are not first-class, or mtl-style effects are over-rated.
18:47:33 <mbwgh> That, and concrete transformers are much nicer to work with. I have to say I don't really buy the arguments about compositionality or explicit lifts.
18:47:55 <mbwgh> That is, for application code at least.
18:48:31 <ertes> mbwgh: what it shows is that the ReaderT pattern is less useful than most people seem to think…  but that's an opinion not many people seem to share
18:48:43 <mbwgh> barrucadu: Speaking of opinions, how would you have gone about this?
18:48:58 <ertes> mbwgh: and LoggerT is really just ReaderT in disguise
18:49:52 <barrucadu> mbwgh: Something like `MonadConc m => (String -> STM m ()) -> ... -> m ...`, rather than a transformer.  I have to agree that I've never found a logger monad class particularly helpful.
18:50:30 <codeshot> Is there a standard function for switching between transformed monads?
18:50:50 <ertes> codeshot: "switching"?  'lift'?
18:50:57 <codeshot> ie (m a -> n a) -> mT m a -> mT n a
18:51:05 <ertes> ah, 'hoist'
18:51:11 <codeshot> ooh, thanks
18:51:18 <ertes> codeshot: check out the mmorph package
18:51:22 <codeshot> will do
18:51:55 <codeshot> This is the kind of scale of composition for which dependently typed languages were designed isn't it?
18:52:18 <mbwgh> codeshot: Though Tekmo claims that hoist is equivalent, it isn't as powerful as the specific map* functions that come with the concrete transformers.
18:53:19 <guest5081> huh, the applicative laws actually look quite nice in terms of liftA2
18:53:33 <lyxia> codeshot: I don't see how dependent types help here.
18:55:11 <mbwgh> ertes, barrucadu: So if I understand you correctly, you don't write against mtl-style classes, and you don't use a ReaderT AppEnv and `asks` or `view` what you need? And what about functions that launch the missiles? Does everything having type IO or MonadIO etc. not lead to problems in larger applications?
18:55:26 <codeshot> well, aren't I just running what otherwise are fairly typical functions but on both values and their types ?
18:55:53 <lyxia> codeshot: you aren't
18:55:55 <codeshot> oh
18:56:23 <ertes> mbwgh: no, effect classes are fine…  it's specifically ReaderT that usually just creates engineering problems you wouldn't have had you just used functions
18:57:02 <codeshot> hm, it feels like all the same stuff I do on values but with new names for doing it on types
18:57:32 <codeshot> perhaps that's just my inexperience
18:57:34 <ertes> mbwgh: also i've rarely found the notion of an "application monad" useful
18:57:42 <barrucadu> mbwgh: I find I usually just work against a concrete monad transformer stack when writing an application.  Sometimes different parts of the program will have different stacks (eg, a DatabaseM and a WebM), and then I'll have functions to convert between them.
18:57:59 <EvilMachine> Hi. Compiling Leksah eats over 3.1GB of RAM! But I have (and can afford) only 4GB! Using +RTS +M1G -RTS only makes GHC stop because it runs out of heap. How can I make it not use such a crazy amount of RAM?
18:59:31 <ertes> EvilMachine: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/sooner.html
19:00:32 <ertes> EvilMachine: although i don't really see anything that would help in your case
19:00:48 <codeshot> hoist is nice
19:00:57 <ertes> EvilMachine: one option is to let someone else build it, i.e. use a binary package
19:01:07 <mbwgh> Ok, so which effect classes do *not* boil down to some ReaderT, if by effect classes we are talking about some specific subset of IO. The classic examples are something like MonadLogger, MonadHttp, MonadDB, and they all need some kind of run-time configuration or a default one, in which case you can just make IO an instance. Is the problem the concrete transformer itself?
19:02:02 <EvilMachine> ertes: The thing is: Before GHC 8, I never got such high memory usages. To me it looks like a memory leak. Something is not GC’d.
19:02:45 <ertes> EvilMachine: in that case you may want to report it and use 7.10 to build leksah (or use a binary package)
19:02:53 * EvilMachine wishes he could afford a new computer. :/
19:03:30 <ertes> EvilMachine: anything wrong with using a binary package?
19:03:35 <EvilMachine> ertes: Yes, I could give it a try.
19:03:42 <EvilMachine> ertes: This is Gentoo. :)
19:04:09 <ertes> EvilMachine: NixOS is gentoo done right =)
19:04:11 <EvilMachine> ertes: But yeah, I use binary packages for large things like Libreoffice. So for Leksah it would make sense.
19:04:39 <ertes> i.e. build only if it actually gives you a different result from something already built somewhere else (in this case the build farm)
19:04:57 <EvilMachine> ertes: Let me look that up. (But I’d say an OS would have to be made of Haskell, to qualify for being evaluated for the label “done right” :D)
19:05:11 <Welkin> nix is written in c++
19:06:36 <mbwgh> barrucadu: What would such a transformer stack look like, if you pass things like logging functions explicitly?
19:07:05 <mbwgh> ertes: Did you see my question? (Just making sure, sorry if I'm impatient)
19:07:33 <ertes> mbwgh: oh, sorry…  you should highlight me =)
19:07:51 <EvilMachine> ertes: Regarding NixOS: Oh no… not yet another Linux distribution, revolving entirely around having a different package manager! ^^ … Some day, I’m gonna code my own user space! With Haskell and Vulcan and <50MB total size, period! ^^
19:08:06 <ertes> mbwgh: i do use Alternative, MonadIO, MonadState, etc.
19:08:42 <ertes> EvilMachine: before that, check it out anyway…  it's not just a new package manager, i promise
19:09:10 <someuniquenickna> Hello everyone. I'm trying to use GADTs in an event-based integer editor. Basically what i want is data EditorState (...), data State (e::EditorState) = State (SEditorState e) Int, interpret :: Char -> EditorState -> EditorState, processKeyboard :: pi (c :: Char) -> State e -> State (interpret c e), and (\c -> modifyIORef stateRef (processKeyboard c)) as an event handler. But this is impossible because IORefs are monomorph
19:09:12 <someuniquenickna>  Can i get something similar in existing haskell? Also this is a prototype for gtk application so event handler can't have funny type. Current prototype under 100 loc is here http://lpaste.net/359794
19:09:56 <mbwgh> ertes: Ah, so the point is that you don't use MonadMissile etc.
19:11:01 <ertes> mbwgh: only if it has "interesting" effects…  application effects are usually just IO or state effects…  they are not "interesting" in the same sense as StateT or ContT
19:11:19 <mbwgh> ertes: What about (MonadReader s m, HasLaunchKeys s) => ... ?
19:11:37 <ertes> mbwgh: (HasLaunchKeys s) => s -> …
19:11:51 <EvilMachine> ertes: Building myself makes sense for me, since I’m that guy that *wishes* he would, even just once, fit the damn mainstream. ^^ … I laugh at people trying to be sooo non-mainstream. If they actually were, they’d wish they weren’t. :P
19:12:27 <guest5081> the applicative laws in terms of liftA2 (a.k.a. fmap2) are just this: fmap2 f (pure x) = fmap (f x)  , fmap2 f . fmap g = fmap2 (f . g) and flip (fmap2 f) = fmap2 (flip f)
19:12:27 <ertes> EvilMachine: do you use haskell only because it's non-mainstream, or because it actually improves on it?
19:12:35 <EvilMachine> ertes: I’ll give NixOS it a try. Right after finishing my current 2-year project and the even bigger one after that, that I’m already too late on. :)
19:13:00 <ertes> "it" being mainstream languages
19:13:24 <guest5081> that feels a lot more intuitive than the laws for <*>
19:13:36 <guest5081> which can be implemented as fmap2 ($)
19:13:37 <mbwgh> ertes: So for example: doesHtmlAndLogging :: (Msg -> STM ()) -> (Request -> IO Response) -> IO () ?
19:13:57 <Redrield> Trying to get into Haskell, and I found https://github.com/parsonsmatt/intero-neovim for integrating Haskell & neovim, which is my editor of choice
19:14:19 <ertes> mbwgh: if there is a reason to abstract over (Request -> IO Response) as opposed to just using a library function, sure
19:15:00 <Redrield> When I open a .hs file, it pops up a window saying it's compiling, and I get this output https://hasteb.in/itixecumuw.vhdl
19:15:12 <EvilMachine> ertes: No, I never use anything *because* it’s non-mainstream. I just end up there against my will. :)
19:15:23 <Redrield> Not sure why this is happening. The only related article I could find on serverfault said to remount /tmp, which I did. Didn't seem to help the matter
19:15:40 <lyxia> someuniquenickna: does your curent prototype not work?
19:15:50 <EvilMachine> ertes: I walk my way… And everybody else is going the other way. And I’m like… Hey! I thought we were the mainstream. Where’re you going?! :((
19:16:03 <lyxia> someuniquenickna: I was about to suggest using an existential type but you already did that, so what's wrong?
19:16:59 <EvilMachine> ertes: I like Haskell, because I started to design my own language back in 2007, and noticed, that Haskell did exactly what I had thought up, but sooo much better. It was like a declaration of love. :)
19:17:33 <ertes> EvilMachine: then chances are you will have the same experience with nix vs. your own package manager =)
19:17:49 <ertes> EvilMachine: since it's off topic here i don't want to brag too much, but here is a summary: https://nixos.org/nixos/about.html
19:18:36 <mbwgh> ertes: And you don't "purify" your code with free monads? I think it's kind of a problem that all the blog posts out there seem to favor the more complicated approaches. It's hard to develop "style". Most advice seems to relate to library code, where it might make sense to make things more abstract.
19:18:43 <Welkin> or it will be completely broken 70% of the time
19:19:02 <Welkin> mbwgh: lol free monads
19:19:06 <Welkin> those are the current fad
19:19:12 <ertes> mbwgh: no, i use free monads
19:19:18 <Welkin> "cofree comonads"
19:19:29 <ertes> mbwgh: they are useful in coroutine scenarios
19:19:37 <EvilMachine> ertes: Might be… :)
19:19:41 <ertes> where i have a controller ("interpreter") and one or more free-monadic actions
19:20:30 <ertes> mbwgh: and yes, i do use MonadFree as well, because i switch back and forth between FreeT and FT =)
19:21:28 <EvilMachine> ertes: Can I ask you something regarding NixOS? (not on #haskell, due to being off-topic)
19:21:29 <mbwgh> Ok, but not as an alternative to the mtl-style effect approach. So no LoggerF etc.
19:22:04 <ertes> EvilMachine: ask in #nixos; if i can answer it, i will, but there are smarter people than me there, too =)
19:22:27 <EvilMachine> ertes: Ok. Thanks. :)
19:23:03 <ertes> mbwgh: no, FreeT is my coroutine monad whenever i need more than just stream processing
19:23:41 <mbwgh> ertes: Might this be related to you doing frp a lot?
19:24:22 <someuniquenickna> @lyxia current implementation doesn't ensure additional type-safety compared to non-gadt solution. I basically use (exists (e::EditorState). SEditorState e) instead of EditorState and they are isomorphic
19:24:23 <lambdabot> Unknown command, try @list
19:25:21 <someuniquenickna> lyxia: sorry, i'm new to irc. I answered you in last message
19:25:54 <ertes> mbwgh: no
19:28:53 <mbwgh> ertes: Then what are those typical coroutine scenarious?
19:29:42 <lyxia> someuniquenickna: I don't understand what kind of safety you are going for here.
19:30:44 <ertes> mbwgh: imagine you have a language for user "sessions", where you can send something to the user and wait for a reply, then send some more stuff, etc.
19:31:03 <ertes> mbwgh: but the underlying protocol does not support sessions…  imagine you execute that protocol over e-mail
19:31:57 <ertes> mbwgh: using Free/FreeT you would write the session as if it were interactive…  much like you would write an stdio application with putStrLn and getLine
19:33:02 <ertes> mbwgh: and then you have an interpreter that, whenever the session wants to wait for user input, waits for an e-mail
19:33:12 <ertes> mbwgh: and imagine you have many such sessions "running" concurrently
19:33:35 <someuniquenickna> lyxia: the function processKeyboard can discard EditorState returned by interpret function and put any other EditorState in stateRef. I want the type of processKeyboard to gaurantee that EditorState it puts in stateRef is the EditorState returned by interpret. 
19:34:01 <Redrield> Anyone know why that would be happening
19:34:03 <Redrield> ?
19:34:55 <geekosaur> stack is picking the wrong package to use on arch
19:35:05 <lyxia> someuniquenickna: oh, that makes sense.
19:35:08 <EvilMachine> ertes: LOL. NixOS uses systemd. Case closed. ^^
19:37:00 <ertes> i kinda expected that =)
19:37:14 <Redrield> geekosaur: How could i fix that? I need terminfo present to run intero-neovi
19:37:16 <Redrield> m
19:37:31 * geekosaur is trying to dig that out again
19:37:56 <mbwgh> ertes: Sounds interesting, I'll have to look into it (since I don't know what Free buys you that you can't do manually using async etc.)
19:37:58 <geekosaur> ok, looks like you uninstall libtinfo6 and install ncurses5-compat-libs
19:38:35 <ertes> mbwgh: do you think that stream processing frameworks are useful?
19:38:38 <lyxia> someuniquenickna: that doesn't look like something you can do in Haskell.
19:38:41 <geekosaur> the problem is the ghc binary distributions were built on debian and none of them quite matches arch, but using the older terminfo lib will let stack pick one that is more likely to work
19:38:44 <ertes> mbwgh: specifically the coroutine aspect
19:40:00 <Redrield> I've not got libtinfo6, doesn't look like
19:40:02 <mbwgh> ertes: They probably are, and I said I'll look into it merely because I haven't used coroutines at all as of yet, and I can't exactly ask you to explain everything to me, starting from Adam and Eve :)
19:40:03 <Redrield> And I have the compat libs
19:40:19 <Redrield> https://hasteb.in/qabesuxige.pl
19:40:23 <geekosaur> if uyou must have tinfo6 installed then there's a stack tweak
19:40:38 <geekosaur> hm. it may be part of ncurses, I'm not clear on that
19:41:03 <someuniquenickna> lyxia: ok, thanks for answeing
19:42:26 <geekosaur> https://docs.haskellstack.org/en/stable/yaml_configuration/#ghc-build 
19:42:38 <geekosaur> oh, urgh, right, this may be the opposite issue
19:43:01 <ertes> mbwgh: start with stream processing…  i'm personally a fan of the 'machines' library, but 'pipes' is much easier to learn
19:43:19 <ertes> mbwgh: once you're comfortable with stream processing free monads are merely a generalisation of that
19:43:20 <geekosaur> I think you get to test whether setting ghc-build as specified at the link I just pasted, to tinfo6 or nopie (but not both since that's the config that is failing for you_
19:44:27 <geekosaur> stack has an open bug to provide a more compatible bindist... someday
19:45:40 <MarcelineVQ> geekosaur: I had to add    ghc-build: nopie    to ~/.stack/config.yaml while having AUR package  ncurses5-compat-libs  installed to get around the arch linker issues this time around.
19:45:44 <JuanDaugherty> someday its pr will come
19:46:11 <geekosaur> Redrield, ^ what MarcelineVQ just said
19:46:16 <MarcelineVQ> These two specific things were both required this time around :(
19:46:47 <geekosaur> yeh, that makes sense. just not the tinfo6 one because debian and arch disagree on how it works and the bindists were built on debian
19:46:52 <mbwgh> ertes: Pipes was the next thing of my todo-list. Probably my current application could have written more cleanly using it, but every time I try to introduce a new concept, there is a 50/50 chance complexity will explode, like with the mtl-style effects thing.
19:47:26 <geekosaur> otoh uuisng that ghc-build setting should allow tinfo6 to remain installed for the stuff that needs it, I think, because the ghc bindist should use ncurses 5 and not try to use the ncurses 6 that confuses it
19:47:39 <MarcelineVQ> yes I don't have specific tinfo package, aside from what ncurses-compat is providing
19:47:55 * geekosaur shakes fist at Arch --- this crap has been going on since June. How much longer?!
19:47:58 <ertes> mbwgh: i think that won't happen with pipes, because its purpose is very specific
19:48:51 <Redrield> Alright, I found something that works and put it in the config and everything seems to be progressing fine
19:49:20 <Redrield> Yep, that worked
19:49:22 <Redrield> Thanks!
19:49:43 <mbwgh> ertes: And I think I will go back to just passing parameters. Yes, and the pipes documentation is really great as well. I like that Tekmo doesn't go with the "just stare at the types" style there.
19:50:34 <Welkin> his name is not Tekmo
19:50:35 <Welkin> o.o
19:50:38 <Welkin> it is Gabriel
19:51:02 <Welkin> no idea why he uses that name on reddit, but uses his real name here
19:51:13 <MarcelineVQ> except when he uses tekmo here
19:51:30 <Welkin> never seen it
19:51:31 <mbwgh> I thought he was known by that name, yes
19:52:17 <boogalooga> Wondering how this function works
19:52:19 <boogalooga> http://lpaste.net/359798
19:52:26 <boogalooga> I'm not sure where the "id" comes from
19:52:31 <Welkin> :t id
19:52:32 <boogalooga> is that some built in construct?
19:52:33 <lambdabot> a -> a
19:52:36 <Welkin> from prelude
19:52:50 <Welkin> it comes from the prelude library, which is imported by default
19:53:07 <boogalooga> oh
19:53:08 <codeshot> This always confuses me, and this time more than ever:
19:53:09 <codeshot>       ‘a’ is a rigid type variable bound by exceptToIO :: forall a. Except String a -> IO a
19:53:09 <codeshot>       Expected type: Except String a -> IO a, Actual type: Except String (IO ()) -> IO (IO ())
19:53:09 <boogalooga> I see now
19:53:17 <codeshot> What causes this?
19:53:27 <boogalooga> You can't assume a type for a
19:53:31 <boogalooga> as far as i've learnt
19:54:30 <geekosaur> more precisely, if you are writing a function, its type signature is a contract to all callers. if it says a, it means the *caller* can specify any type a it wants
19:54:35 <geekosaur> and you will accept it and work with it
19:54:45 <geekosaur> you cannot specify your own a; the type belongs to the caller
19:55:50 <codeshot> oh, yeah, I knew that but I needed someone to say it again to make me think
19:56:14 <mbwgh> ertes: I have one more question though. If you don't abstract over the boring IO-based "effects", how do you reason about code by looking at it's signature? Sure, you can write non-sensical class instances, and they don't come with laws. And surely you can still mock these functions. But how should I go about having a bad feeling if I've written fun :: IO () ?
19:56:16 <codeshot> As I was typing "but I'm not specifying my own ..." I realised I am in a function I go on to call
19:56:17 <codeshot> :D
19:56:18 <codeshot> thanks
19:57:31 <ertes> mbwgh: what's the difference between abstracting over functions and abstracting over instances?
19:57:57 <mbwgh> ertes: I guess what I'm asking is, if I introduce these classes, I can readily come up with a few reasons. But if I don't, right now what I have is "it becomes too complicated".
19:58:25 <mbwgh> ertes: Well, if I pass in the functions, the return type is still just IO a.
19:58:55 <geekosaur> and yes, this is backwards from OO type systems where you are free to specify any subclass. FP polymorphism usually works in terms of providing functions that are as general as they can be given what they are supposed to do.
19:58:56 <geekosaur> \:t map
19:58:57 <ertes> mbwgh: because it's an IO action
19:58:58 <geekosaur> er
19:59:01 <geekosaur> :t map
19:59:02 <lambdabot> (a -> b) -> [a] -> [b]
19:59:14 <geekosaur> so map promises to handle any a and b a caller chooses.
19:59:21 <ertes> mbwgh: what else would the return type be?
19:59:23 <codeshot> hm, hoist perhaps isn't what I want. Is there a function (forall a. m (n a) -> n a) -> t m (n b) -> t n b ?
19:59:56 <masaeedu[m]> although it gets more general
19:59:57 <masaeedu[m]> :t fmap
19:59:58 <lambdabot> Functor f => (a -> b) -> f a -> f b
20:00:17 <ertes> mbwgh: i mean if you abstract over MonadLogger, then you basically abstract over an IO (or in your case STM) action
20:00:18 <mbwgh> ertes: That may be, but if I have some class Moand m => MonadFoo m where ..., then I know that an m () action can only call one of the class methods.
20:00:52 <masaeedu[m]> is there something where the concrete -> in functors gets subsituted with arbitrary Arrows
20:00:52 <ertes> mbwgh: myAction :: (Monad m) => (X -> m Y) -> m Z
20:01:02 <ertes> mbwgh: now you know that myAction can only ever use the provided effect
20:01:13 <mbwgh> haaaaa
20:01:19 <mbwgh> ok that makes sense
20:02:21 <ertes> mbwgh: that's how you know that 'forever' won't launch the missiles, unless the argument action does
20:03:10 <mbwgh> ertes: So, I could write doesHttpAndLogging :: (Monad http, Monad stm) => (X -> http Y) -> (Z -> stm ()) -> ?? oh wait...
20:04:12 <ertes> mbwgh: it's the same as with type classes…  you have to choose whether you want to abstract over effects or use library actions directly
20:04:32 <mbwgh> ertes: But what about multiple effects?
20:05:24 <ertes> mbwgh: if all else fails you can combine multiple effects in a *type* rather than a class…  that's the same kind of documentation
20:05:59 <ertes> mbwgh: i have two criteria for when a class makes sense: 1. there are at least two instances, 2. you abstract over it
20:06:12 <ertes> if both are true, by all means use a class
20:07:12 <ertes> but even then sometimes a type is more useful, because you can modify the value while passing it around
20:07:15 <mbwgh> ertes: Ok but if you assume an actual and a mocking implementation, already those criteria are satisfied. What would such a type you mentioned look like?
20:07:56 <ertes> for example imagine you want to pass around an effect that creates a stream of some sort
20:08:11 <ertes> class MonadSomeStream m where next :: m X
20:08:46 <ertes> problem is: if the stream is stateful, now you need to write an actual SomeStreamT…  you can't just make IO an instance of this class
20:08:55 <ertes> you need a StateT component
20:09:12 <geekosaur> masaeedu[m], maybe http://hackage.haskell.org/package/profunctors-5.2.1/docs/Data-Profunctor-Monad.html#t:ProfunctorFunctor ?
20:09:43 <ertes> on the other hand:  newtype SomeStream = SomeStream (IO (a, SomeStream))
20:10:06 <ertes> this one you can use directly with IO…  not sure if it's a good/instructive example, but it should explain the problem
20:10:09 <geekosaur> Arrows kinda decomposed into three more general concepts: Category, Profunctor, Applicative
20:10:34 <ertes> mbwgh: mocking implementations are no problem with a type…  in fact they're easier
20:10:51 <ertes> mbwgh: because you can construct them on the fly, while with classes you always need to write an instance under the open world model
20:11:35 <ertes> mbwgh: the type version of Monoid is:  data Monoid a = Monoid { mappend :: a -> a -> a, mempty :: a }
20:11:36 <masaeedu[m]> :t promap
20:11:37 <masaeedu[m]> hmm
20:11:38 <lambdabot> error:
20:11:38 <lambdabot>     • Variable not in scope: promap
20:11:38 <lambdabot>     • Perhaps you meant ‘rmap’ (imported from Control.Lens)
20:11:46 <masaeedu[m]> promap :: Profunctor p => (p :-> q) -> t p :-> t q
20:12:03 <ertes> mbwgh: mconcat :: (Foldable f) => Monoid a -> f a -> a
20:12:27 <ertes> mbwgh: now you can pass (Monoid (+) 0) and (Monoid (*) 1) around directly without Sum and Product newtypes
20:12:51 <ertes> mbwgh: and even modify monoids on the fly:  product :: Monoid a -> Monoid b -> Monoid (a, b)
20:13:15 <ertes> potentially using local information
20:14:28 <suzu> does using a free monad have an effect on compile-times?
20:14:53 <suzu> i think it has an effect on cata performance because of the fmap (>>=), but how about compiles?
20:15:14 <mbwgh> mbwgh: But people actually write code like that? I can see that we might be able to implement mempty for matrices in this case, which is nice, but explicit dictionary passing could become unwieldy. Also with your previous example, we were back at IO, which you claimed could be avoided by something like m :: (A -> m B) -> m C.
20:15:57 <mbwgh> argh
20:16:08 <mbwgh> ertes: Was addressed to you.
20:24:40 <mbwgh> ertes: Anyway, I think I'm heading to bed now. Thanks for all your advice, I really appreciate it.
20:32:38 <ertes> @tell mbwgh you can abstract with types exactly like you abstract with classes:  newtype SomeStream m = SomeStream { next :: m (X, SomeStream m) }
20:32:38 <lambdabot> Consider it noted.
20:48:23 <JuanDaugherty> http://hackage.haskell.org/packages/#cat:TODO is "TODO" an acronym there or what?
20:50:55 <geekosaur> that is likely someone who forgot to finish filling out their cabal file
20:51:09 <geekosaur> we had a rash of those, mm, maybe 8 months ago?
20:51:35 <geekosaur> including like 6 packages in a row with description: Stack initial project template
20:51:40 <JuanDaugherty> that was one guess, automated category processing from the occurence in a descriptor string
20:51:55 <JuanDaugherty> shocking lack of quality control if so
20:52:31 <JuanDaugherty> attention to detail or whatever you want to call it
20:56:23 <JuanDaugherty> looks like hackage2 was a dud
21:03:48 <Welkin> what is hackage2?
21:05:14 <JuanDaugherty> http://industry.haskell.org/status 
21:08:13 <nisstyre> there should be an updated version of LYAH that covers lenses
21:08:31 <nisstyre> I was just looking at the table of contents, thinking of recommending it to someone
21:08:48 <Welkin> LYAH wil never be updated
21:08:52 * JuanDaugherty seems to recall it (hackage2) was subsumed/truncated 
21:08:54 <nisstyre> oh well
21:08:56 <Welkin> it is also a poor resource for learning haskell
21:09:03 <nisstyre> yeah
21:09:04 <Welkin> it is great for marketing
21:09:08 <Welkin> everyone knows about LYAH
21:09:17 <Welkin> but anyone who tries to learn from it will be disappointed
21:09:17 <nisstyre> I didn't use it to learn
21:09:22 <nisstyre> so I was curious if it's good or not
21:09:26 <nisstyre> and it does look kinda crappy
21:09:31 <Welkin> I started with it
21:09:38 <nisstyre> I started with RWH
21:09:40 <Welkin> I wouldn't recommend it as the first introduction
21:09:47 <nisstyre> which I also would not recommend lol
21:09:48 <Welkin> RWH is bad too
21:09:52 <Welkin> but in a different way
21:09:54 <Welkin> it is BORING
21:09:58 <nisstyre> yeah it really is
21:10:00 <Welkin> and outdated
21:10:03 <nisstyre> it took a lot of mental effort for me
21:10:11 <nisstyre> this was like 5 years ago
21:10:22 <nisstyre> which is amazing now that I think about it
21:10:55 <nisstyre> so what do I recommend then?
21:11:03 <nisstyre> there's that textbook
21:11:15 <nisstyre> the Simon Thompson one
21:11:25 * JuanDaugherty has it
21:11:36 <nisstyre> I have it because I TA'd for a class that used it, but I never read it
21:11:41 <nisstyre> except maybe the first chapter
21:11:57 <Welkin> I am not sure what is best
21:12:09 <Welkin> I like the new Hutton book, but have only skimmed it so far
21:12:13 <nisstyre> there's the Richard Bird one
21:12:16 <nisstyre> is that ok for beginners?
21:12:17 * JuanDaugherty doesn't regret it's price. It's certainly superior the other two mentioned.
21:12:25 <JuanDaugherty> *its
21:12:37 <nisstyre> Thinking Functionally with Haskell
21:13:05 <Welkin> many people like "Haskell from first principles", but it has obvious issues, mostly that it is 1300 pages long...
21:13:17 <Welkin> and it doesn't even talk about monads until something like page 900
21:13:24 <nisstyre> yeah I hate long books
21:13:27 <JuanDaugherty> but i don't share the expressed negative opinion on RWH and LYAH in as much as they are free  
21:14:02 <nisstyre> someone should write a book in the style of The Little Schemer but for Haskell
21:15:06 <Welkin> yes, LYAH had the huge advantage of being free when I first started learning haskell years ago as a poor college student
21:15:14 <Welkin> even $40 for a book was a fortune at the time
21:15:17 <nisstyre> same
21:19:27 <buttbutter> Is there a variant of the words functions where I can specify the string to join the words with?
21:19:45 <buttbutter> or, I guess, more clearly, specify the separator.
21:19:50 <monochrom> intercalate in Data.List
21:20:11 <buttbutter> Oh, thanks. :) 
21:20:44 <nisstyre> > intercalate "," ["a", "b", "c"]
21:20:47 <lambdabot>  "a,b,c"
21:22:14 <Welkin> @type intersperse
21:22:15 <lambdabot> a -> [a] -> [a]
21:22:21 <Welkin> @type intercalate
21:22:22 <lambdabot> [a] -> [[a]] -> [a]
21:23:59 <nisstyre> > intercalate [0] $ map return [1,2,3]
21:24:02 <lambdabot>  [1,0,2,0,3]
21:25:47 <Welkin> > intersperse 0 [1,2,3]
21:25:50 <lambdabot>  [1,0,2,0,3]
21:26:09 <Welkin> I find intersperse more useful generally
21:26:21 <Welkin> intercalate works fine on strings though
21:26:23 <nisstyre> yeah...outside of strings intercalate doesn't seem that useful
21:26:42 <nisstyre> I hardly even use String in real code now
22:14:40 <ertes> how do i prevent let floating without outright disabling it?
22:18:43 <MarcelineVQ> ertes: would inline or oneShot help? https://hackage.haskell.org/package/base-4.10.0.0/docs/GHC-Exts.html#v:inline
22:19:29 <MarcelineVQ> or is oneShot what you mean by disabling it?
22:19:33 <Welkin> what is "let floating"?
22:19:34 <ertes> MarcelineVQ: no, this is about an unsafely created IORef
22:19:43 <ertes> so i must not inline
22:21:24 <ertes> Welkin: let floating is an optimisation that moves a local definition to the top level
22:21:44 <ertes> and it can break unsafely created IORefs
22:21:47 <Welkin> top level in a do-block?
22:23:04 <Welkin> if it turns let bindings into top-level bindings, that sounds like a bug
22:23:19 <Welkin> unexpected behavior, not an optimization
22:23:35 <ertes> Welkin: f :: Integer -> Integer; f x = x + y where y = someExpensiveValue
22:23:45 <ertes> Welkin: let floating will (most likely) turn 'y' into a CAF
22:23:56 <ertes> so that it is not recomputed every time you use 'f'
22:24:28 <ertes> it can do that, because 'y' doesn't refer to anything in f's local scope
22:25:40 <ertes> it makes definitions bubble up scopes as far as possible (not necessarily to the top level)
22:37:09 <MarcelineVQ> ertes: lots of interesting info in here including some stuff about oneShot and using lambda's as barriers, https://ghc.haskell.org/trac/ghc/ticket/12620
22:37:21 <MarcelineVQ> also this but I've not read https://arxiv.org/pdf/1207.2017v1.pdf
22:38:07 <Welkin> could you avoid using the IORef?
22:39:32 <ertes> MarcelineVQ: thanks for your effort…  i'm not going to read it, because it will just make me sad right now =)
22:39:37 <ertes> Welkin: not really
22:40:00 <MarcelineVQ> then at least read the lower bit in case you can use oneShot and NOINLINE and/or lambda to do what you're after
22:40:16 <ertes> oh, indeed
22:40:18 <MarcelineVQ> a safe looking unsafe IORef, Unique ident counter?
22:43:16 <ertes> i believe floating shouldn't happen anyway, because the type of the IORef actually depends on the instantiation of the function
22:43:35 <ertes> but while it does that it doesn't really depend on anything on the value level
22:44:10 <ertes> unsafeMkEvent c = Event { _evRef = ref, _evUpdate = c ref } where ref = unsafePerformIO (newIORef Unknown); {-# NOINLINE ref #-}
22:44:11 <ertes>  
22:44:35 <Welkin> using accursedUnutterableIO?
22:44:53 <Welkin> why would you need to use that?
22:45:01 <Welkin> I haven't found a use for it (yet)
22:45:18 <ertes> Welkin: use what?
22:45:28 <Welkin> ertes: unsafePerformIO
22:45:48 <ertes> Welkin: FRP implementations tend to need it for efficiency
22:46:08 <ertes> the ref acts as a cache
22:46:31 <Welkin> doesn't that break referential transparency?
22:46:37 <Welkin> so then your whole library is a lie?
22:46:41 <ertes> nope
22:47:00 <ertes> it's only observable as a speed improvement
22:47:08 <ertes> it doesn't change the meaning of the program
22:48:06 <dsal> How do I indicate I want all the rest of the things in attoparsec?
22:48:25 <pacak> :t takeBytestring
22:48:27 <lambdabot> error: Variable not in scope: takeBytestring
22:48:48 <dsal> oh, there it is.
22:48:53 <dsal> Thanks.  I kept searching for stuff.
22:49:00 <pacak> :t takeByteString
22:49:01 <lambdabot> error: Variable not in scope: takeByteString
22:49:27 <pacak> lambdabot:  (ಠ_ಠ)
22:49:53 <MarcelineVQ> :t BS.takeBytestring
22:49:54 <lambdabot> error:
22:49:54 <lambdabot>     Not in scope: ‘BS.takeBytestring’
22:49:54 <lambdabot>     No module named ‘BS’ is imported.
22:50:15 <MarcelineVQ> odd, I just imported it, oh well.
22:50:21 <dsal> hmm...  can I take until a character or EOF?  Sorry, going through the things.
22:51:08 <MarcelineVQ> oh attoparsec counts as an unsafe import for lambdabot
22:51:12 <pacak> dsal: satisfy
22:51:47 <ertes> dsal: takeWhile
22:52:03 <ertes> dsal: it stops at EOF
22:52:08 <dsal> I'm using takeTill, but getting partial.  Maybe that's my problem.
22:52:10 <pacak> Yea, takeWhile is probably better
22:52:53 <pacak> partial? Feed an empty string into it to tell that there's no more results
22:53:19 <ertes> dsal: attoparsec is an incremental parser…  you need to inform it that there is no more input
22:53:21 <dsal> How do I feed it an empty string?
22:53:27 <pacak> yes
22:53:52 <ertes> dsal: Partial comes with a continuation function
22:54:54 <dsal> p :: A.Result Hostname
22:55:09 <pacak> When I use it as incremental parser I usually do something like feed (feed (parse p prev) next) B.empty
22:55:31 <ertes> note that there is also parseOnly
22:55:55 <pacak> p is usually "many stuff" - as a result it'll give you a list of stuff it managed to parse and leftovers
22:56:44 <dsal> Ah, parseOnly is exactly what I want.
22:56:48 <dsal> I'm parsing small strings.
23:53:39 <fragamus> can somebody tell me how to install haskell-mpfr on stack? It's complaining... integer-gmp-1.0.0.1 must match >=0.2 && <0.6 (latest applicable is 0.5.1.0)
23:58:50 <cocreature> fragamus: try adding integer-gmp-0.5.1.0 to the extra-deps section in your stack.yaml
23:59:21 <fragamus> thanks - never did mess with that yet
