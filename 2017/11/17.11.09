00:01:42 <Cale> jcarpenter2: What happens if the response is extremely large?
00:02:25 <jcarpenter2> then the whole thing has to be loaded into memory before it can be sent to the client
00:07:11 --- topic: 'https://www.haskell.org | https://wiki.haskell.org/IRC_channel | Paste code/errors: http://lpaste.net/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D | https://www.reddit.com/r/haskell | Admin: #haskell-ops | Offtopic: #haskell-offtopic | https://downloads.haskell.org | https://summer.haskell.org Summer of Haskell 2017'
00:07:11 --- topic: set by mauke!5lzdiZJQGk@p3m/member/mauke on [Mon Jul 31 05:45:11 2017]
00:07:11 --- names: list (clog jzeus hphuoc25 Itkovian albertid nickolay seveg wroathe gawen danvet slomo_ codesoup pellenation osa1 ali_bush jcarpenter2 Li[m] acidjnk takuan juhp cyphase vlatkoB Unhammer bazukas alex`` jtfell LiaoTao carbolymer simka graphtheory polman dec0n__ Yuras Oipo coot___________ kefin trosa Axman6 pfurla YongJoon schoppenhauer amadhavan1 beerdrop sphalerite peddie[m] aer[m] intheclouddan[m] dtcristo bananagram closures999[m] jmnoz sgal[m] lysgaard[m] schum[m])
00:07:11 --- names: list (ttk2[m] jerin[m] howdoi himmAllRight[m] riaqn M-Illandan mtncoder[m] WilliamHamilton rakete puminya[m] dkellner[m] nshepperd hugogomes[m] M-whoops tuxitagnu[m] ElyKar[m] bustillo[m] ego KeyJoo rossberg remy Squarism darjeeling_ laz naudiz nahra` meandi_2 brixen bartavelle davl pdxleif Foritus niHiggim_ besenwesen le_jonge scav_ ryan_vw Natch magog[m] apigeon[m] toa[m] dbramucci[m] liyang elpfen[m] kilian[m]1 frunobulax[m] Bimmie[m] mk[m] Monad[m] subz[m])
00:07:11 --- names: list (prot[m] JohnnyReb[m] asthma[m] shsnthstnhs[m] burgundy[m] Scapin[m] Heino[m] bramvdbogaerde[m M-ms islamicwarez[m] Guest291964[m] Rubas[m] eyenx sssi1ver[m] Mistv[m] rimon[m] Guest312594[m] rprospero[m] Vipernet1220[m] hesiodos[m] seto[m] scrypso[m] packetbiompm[m] caimbeul[m] Verandetten[m] jnonpony[m] fxk[m] h_ndrik[m] Guest1573[m] Litom[m] yaspoon[m] ptek[m] thebeast[m] ma-ku[m] zmre[m] KENNYNR1[m] joakimf95[m] maverickwoo[m] akshay7777[m] kwaku[m])
00:07:11 --- names: list (M0xfiras[m] Andry976[m] PatrickM[m] Jasonjunsu[m] KevinMGranger grahf[m] ElliotKiyomizu[m lixiang4u[m] SijmenSchoon[m] mark_c M-HirmeS shekel[m] M\u202e[m] am2on Elorm[m] Guest340521[m] fgaz[m] mrhunky[m] etXzat[m] kebertx[m] guest121[m] porcow[m] BartGroeneveld[m grdryn psan[m] c0ff33[m] asm[m]1 Zarthalan[m] stellis[m] M-herah guest236[m] kkr[m] km42[m] ArrayWindrunner[ nine-h[m] Reyu[m] teuffy[m] sgoody[m] boash[m] djquant[m] caro401 mrdaak[m] stevendai[m])
00:07:11 --- names: list (j0ni[m] dirb howsiwei[m] a89lk[m] gutigen[m] DavesTestingAcco razvanc-r[m] sudom0nk[m] pacmansyu[m] mrgraffe[m] Niboor[m] icen[m] superpat[m] Mougan[m] polux[m] testingriotnmatr nimbus[m] ramirezD[m] goolord[m] Shaunthesheep[m] felipeac[m] adziahel[m] oozz[m] Nerka[m] softashell vrnithinkumar[m] Luguber[m] Soft saci[m] jvalleroy[m] ajtowns[m] pedroteo[m] meinashi[m] thekyriarchy__ tobim[m] avatias0[m] WinterFox[m] TimWolla[m] MarkusK[m] octalsrc[m] cuddly[m])
00:07:11 --- names: list (antiless[m] Courage[m] Cadey[m] crapman[m] ya-alex[m] fonadius[m] magnap devpav[m] Sasasw Overload[m] Ed2bno1[m] unclechu ub[m] rizo[m] adampaigge[m] charlag[m] jsonhigh[m] WolfLightning[m] M-kitsune chominist[m] chaseroycroft[m] apardo[m] superobserver[m] pyrtheibarit[m] JHBrannam[m] rcat[m] XertroV[m] peel[m] moka[m] narispo[m] TristanBKildaire Fulgjon[m] Ubiquitous[m] ByteEater[m] okkk joncfoo[m] emme[m] Michi[m] mlainz[m] Naughtmare[m] tommy0010[m])
00:07:11 --- names: list (Frytka[m] lucnx[m] gylpm[m] Akito[m] xffox[m] Squidnyan[m] ThousandLions[m] mrhania[m] wisn[m] FederalRick[m] bbslclubbin[m] abbiya beemo[m] psYchotic[m] rydia5[m] phittacus PifyZ[m] hdurer[m] SansFr[m] Flecheck[m] laaksoan[m] CryptoCalsius[m] roninkaizen[m] hiq[m] Deleh[m] fbreitwieser[m] ycy[m] M-rgh Barnabas[m] dpacbach[m] tibike_m[m] jacobleach[m] scanleft[m] ltq520[m] Makinit[m] ninegua[m] AX3L[m] lonokhov[m] jhb2345 guest69[m] pingfreud[m])
00:07:11 --- names: list (talesmantovani[m lkh[m] chuzz[m] zhangjiji[m] Maikel_Experius[ synopz[m] thisLight[m] LucasFrancesco[m cow_2001[h] el_tejon[m] testtt55[m] ngross[m] dlandau[m] wubbalubbadubdu4 daoo[m] Dako300[m] georg3[m] huda[m] innaytool[m] riotartist[m] levzhazeschi[m] spotter[m] NickSeagull[m] noxeternae[m] Adau[m] kimchi[m] yashi[m] mad[m]1 fib11235[m] mj_k_ toumi124[m] nh2[m] romanzolotarev[m jomari[m] mith[m] zukonake[m] seizo[m] M16_29[m] naviknair7[m] xeel[m])
00:07:11 --- names: list (Novitsh[m] sebisebi[m] JackM[m] ItevNabdifNi[m] ketanhwr masaeedu[m] ddbbuu[m] bgrayburn[m] phil_frontal[m] futpib[m] M-schmittlauch plll[m] nullset[m] asenski[m] khac[m] zalipuha[m] hotsocks[m] stites[m] puffnfresh moonrunes[m] Masaomi[m] m3tti[m] Rifa[m] etcinit[m] thekyriarchy Obscurity[m] Matthew[m] strixy[m] wizzup[m] riadvargas[m] TFX[m] LangeOortjes[m] trikl[m] Mcpurplemuffin[m zineje[m] geetam sudoreboot[m] rcg[m] bitemyapp slartibartfast[m)
00:07:11 --- names: list (trevorriles[m] mossid[m]1 Alexander_Hansen schplaf[m] aniketd[m] redviking[m] thejonny[m] chaetopterus[m] SuperW[m] s0ra[m] sypwex[m] Mike[m] arslanatajanov[m newman[m] idnar[m] tangled_z[m] MikasiCoyote[m] piluex[m] pacak SenasOzys revprez_1st Netwolf_ brynedwards xpoqp richi235 Tuplanolla ManiacTwister hallomann srhb geppettodivacin bbee brent80_plow ehubinette greeny cheshircat mak` TyOverby__ dpn` meck twopoint718_ buhman cdornan_ lukexi adamCS ljhms hpc_)
00:07:11 --- names: list (joachifm_ valdyn bjobjo_ numberte1 jrslepak_ aweinsto1k Clint_ dilinger_ mxf_ ninegrid flori_ opqdonut kshannon_ SpaceKni1ht revprez posco bno2 capisce_ WzC infinity0 fabien DragonEyes1 saurabhnanda shangxiao justanotheruser ninedotnine o0o[m] rellen hakan[m] Nuva[m] goodboy[m] undu[m] MohdSKhoeini[m] hpd_m drasich[m] M-kevinliao M-krsiehl Aidan[m] JanPath[m] TylerCecil[m] angelbeats[m] srenatus davidar sn[m] scde tester668[m] kritzcreek cutie m4sk1n)
00:07:11 --- names: list (albertsg[m] aspiwack[m] davidar_ unknownln sirius[m] MawKKe[m] hendrik[m] bb010g berton spacekitteh[m] unlmtd turt2live pellegrino trevortknguyen[m freeman42x M-BostonEnginerd equalunique[m] tfc[m] ollieh M-berdario jyp[m] reactormonk[m] herzmeister[m] bennofs[m] zaphar_ps[m] anelson jhrcek yrid sanett revprez_stg rexor[m] gfixler dt343gs[m] revprez_1nz rainbyte[m] Swizec_ cdg dfeuer Scip Khisanth BartAdv otto_s_ a3Dman Raptor8m3 xxpor monochrom felixsch__)
00:07:11 --- names: list (m0rphism durandal1 markus1189 jared-w Twey japesinator_ ekr akermu LeaChim majoh_ robin__ baweaver M4GNV5 navilan jkup_ drk_lrd_777_ eddsteel newsham kaffepanna olligobber codeshot der_landgraf teej ortmage johnw kloeri __name__ unga pikajude mstruebing averell sanitypassing flebron ianconnolly hiratara stoopkid nkpart ocharles ixian tazjin banc deadlysin x1n4u crosleyt APic aplund quaestor theDon forker MitchW Jonno_FTW linduxed serendependy cross jchia)
00:07:11 --- names: list (sdrodge fakenullie przembot codebje nwf mountaingoat yaiyan bollu Benzi-Junior magnuson ircbrowse vaibhavsagar lispy plathrop glguy nekomune nathyong tomus destiny_ dunj3 Gothmog_ fredsir ycheng petercommand Rembane bsima joeyh agrif nakal niklasb tsahyt yarou aatxe govg nerteren Archrover noctux oherrala Cthalupa zenspider prophile Maxdamantus MitchellSalad kav ahf_ Guest27020 rntz amerlyq magicman malthe wladz matthavener jlouis TallerGhostWalt waylon531)
00:07:11 --- names: list (Reisen implementation iross threeve dan_f MrBusiness3 mniip andyhuzhill lambda-11235 kuttifunk Strix jb55 lambdamu ggVGc OhBeOne Youmu maddybutt Guest47159 MP2E alveric2 nighty- plutoniix buttbutt1r Coldblackice llinguini cpup StriderZ DTZUZO acro M2tias hrnz m4lvin mda1 raatiniemi ps-auxw Guest28908 ketralnis zero_byte nopnut Philonous xkapastel dcoutts cheater AndreasK twandy zargoertzel sw1nn pgib zoug_ valentinbuza tpreston whoisxy mrd cyborg-one bgamari)
00:07:11 --- names: list (raynold troydm Swizec rdococ shiyas kuko anishathalye Velpoman StoneToad abhiagarwal_ gehmehgeh SAL9000 shymega juri_ carlomagno jle` papanik remix2000 CurryWurst xinming ertes-w erikd przemkovv ctag OnkelTem wonko7 jfredett cgfbee Sigyn MindlessDrone ssn__ sun777 lukky513 amiri wizonesolutions codedmart OliPicard amatecha danieli theorbtwo seccus trig-ger angerman spicydonuts zpconn__________ lumimies mkurkov_ lexi-lambda twold monad_cat kyagrd andrew_n_)
00:07:11 --- names: list (dgonyeo solidsnack andreypopp sclv hansihe nek0 rgrinberg Ober eacameron dstockwell nelll dgpratt dumptruckman myme asjo kensan schaeferpp TimWolla huonw solatis cschneid acfoltzer bbaren ectos koz_ akemot bogdanteleaga RevJohnnyHealey heath vikraman wadadli Meanirelli jdt malt3 mud runeks oldsnakey ReinH mikedlr Scorchin carter runawayfive nbouscal ebutleriv kipd cansis capicue niveus Tritlo gridaphobe akl avdi iphy prizim HallaSurvivor ephemera_ Novitsh)
00:07:11 --- names: list (Xorlev zmanian _6a68 SegFaultAX Majiir emerson Lord_of_Life dminuoso Amadiro Meow-J zymurgy nopf noam_ aijony Warrigal tabaqui1 zyla mivael hjdskes alexbiehl freusque Emantor _kit_ padre_angolano rootnode takitus leothrix slackman1 alexelcu remexre electrostat lagothrix Ranhir ft eL_Bart0 urdh ironChicken ChongLi Guest32325 cjwelborn Guest83867 swhalen zenzike MagneticDuck okuu hc jrabe mkoenig kg Destol Dykam Vorpal qzo tsaka__ inkbottle ghostyy mtjmullen)
00:07:11 --- names: list (thallada Xion_ refold gienah_ amx andyo tromp Axton zaquest kapu xpinguin dkremer_ cchalmers tabaqui infinisil tv GreySunshine zeroed dibblego fxrs RayNbow`TU tmciver cic Fekinox pflanze phryk Bane^ __main__ maerwald texasmynsted _ashbreeze_ sqrt2 shikhin Tesseraction_m albel727 _flow_ cocreature hegge_ Randy ClaudiusMaximus machinedgod niklasl athan geekosaur Cale mathu thunderrd descender chriswk araujo kody^ JoelMcCracken salva Guest8932 langkid1 CARAM___)
00:07:11 --- names: list (johtso paf31 ericbmerritt_ bbielsa Bengi jml stig stasku mbrock baamonde pchiusano Tallenz JSharp lopex lynn prefork gornikm AlainODea AWizzArd logcat hanna kipras`away Laney feepo Draggor Jinxit heinrich5991 nille {AS} twomix stephe SolitaryCypher bind Limeth_ scinawa canta antismap joeytwiddle DustyDingo platz jdnavarro junktion bluepixel shutdown_-h_now dersquisher pranz ericsagnes nurupo prg318 stux|RC pita papapishu julmac xplat vfs_ mattp__ dysfigured)
00:07:11 --- names: list (Durbley raek dmiles dolio {emptyset} atk bydo Bigcheese tharper_ rizary jw358 sbrg SlashLife ralu relrod angular_mike zgrepc si14 banjiewen milessabin Cir0X paws_ spinda edwtjo chindy Immune altooid perrier-jouet dxtr prooftechnique cetchmoh reu_ fergusnoble keb catern sleepynate benzrf pmade mk_modrzew nshepperd2 gabiruh_ nyuszika7h dysfun nano- orion_ nshepper1 admwrd_ spoonm fingerzam SCHAPiE cpape R0b0t1_ swalladge Sose catsup mou Redrield nullifidian)
00:07:11 --- names: list (wilx verlet64 tomaw phadej jchia_ wunki joehillen pikolinosimo jimmyrcom leah2 atomi iliastsi GypsyScotty Geekingfrog jluttine zebrah tumdedum drewbert michaelw ptek dogui zerokarmaleft datajerk chrissl DoubleJ chronull RGamma ethercrow meinside heurist dxld pdgwien karshan milli hvr hiredman madknight wrengr_away MarcelineVQ felixsch_ mceier Profpatsch Klumben grayhatter ftop Lokathor kriztw fearless_man lambdabot ziman apeyroux kini Xe Purlox mitch_ Athas)
00:07:11 --- names: list (Ewout esph tomku vin-ivar Lierdakil paraseba ab9rf otulp verement worch tdammers ahihi centril earldouglas ph88_ wagle martingale dedgrant dpower Igloo Nik05 _janne swflint jophish diskie fryguybob lavalike cyberlard gnusosa Neo__ arkeet ids1024 nikivi dmwit Fubar^ kloplop321 fluxit dan64- mauke kwantam yeeve jbalint d6e jrm andjjj23 mmaruseacph2 marens peterhil` wayne riatre byte512 marcel beccamorgan fall_ mjo Deadhand htse timothyh CuriousErnestBro jtcs)
00:07:11 --- names: list (Paks danielglh felixonmars abbe Drezil rembo10 mimi_vx mnoonan hydraz dqd aminb hiptobecubic jeddak alexknvl lionaneesh johs lukeshu tsani mikeplus64 \u jol slester cjay- ssedov vqrs rann nisstyre jgornick dtulig Forkk mdarse NocnaShada sns chu rotaerk max-m cow-orker LnL _cyril_ miklcct Hijiri cpallares jokester Flonk Tharbakim noexcept mikosty tripty sdhand Boreeas kuchi thoros treehaqr bencryption no-n seliopou WhereIsMySpoon jix tolt_ dh lokydor)
00:07:11 --- names: list (acowley_away Wamanuz2 coeus Moyst niko gargawel stux|RC-only g2 jstolarek cods yushyin tzaeru Jaxan Voldenet Zoddo duncan^ Ninja3047 S007 dandan86 robogoat armlesshobo clever zxcv1729 zipper PotatoGim Firedancer bsrm caasih Frans-Willem zebr rotty sveit dpanth3r SexHendrix int-e freeside coup_de_shitlord Liskni_si jorj nesqi foolswood Raynes Pilfers lassulus froztbyte monty ezyang cfoch-al1 raibutera killtheliterate brisbin lachenmayer alanz marble_visions)
00:07:11 --- names: list (deba5e12 kiboneu kosmikus anoe saftsuse andrewmc1eigh mendez_ bcoppens minad srk Adluc hive-mind int0x27h thebnq ski uwap obiwahn Chobbes buoto1 zekt ncl28 c-rog arw pierrot Ulrar thoradam TabAtkins cbaines andromeda-galaxy mlen ggherdov gleber_ Guest63586 thomashoneyman cgag thi_ JoJoen jonrh jorendorff ijp alp suppi adelbertc yminsky simony wavewave reem incomprehensibly cdal sa1 tortal Ornedan dpepsilon kaol comboy Quintasan x-n2o jaargon eikke echoreply)
00:07:11 --- names: list (mitchty amuck chirpsalot TommyC rjungemann sm sjl__ crlane marienz supki ambrosia nitrix gareth__ tobiasBora billstclair dustinm nemesit|znc isaac__ spion edwardk houli erg inr micro Saizan z0ttel xa0 bod_ wto avn Unode Ke tg poga saurik peschkaj sigmundv_ osfameron ahf pfoetchen coup pelegreno_ pharaun tarcwynne__ Tspoon_ Deaddy ephemeron jzl Frankablu terrorjack caw__ heyj sbauman rodarmor libbyk vimto Willis etiago megaTherion vikram__________ davean)
00:07:11 --- names: list (solarus h30 thoughtpolice zph bigs bitonic edofic tjpeden xplat|work peteretep wyvern xnyhps jmct S11001001 mbeidler joel135 yaknyasn redcedar KaneTW mantovani Hafydd kmicu jounaz^__ qmm pandem harmaahylje m1dnight_ chrzyki GGMethos epta bjs Guest82765 earthy Ferdirand tessier bshelden dancek michalrus mutsig kaychaks Vq quicksilver Morgawr wamaral aidecoe klugez beaky bxc Blkt peddie raid SuperTux88 Intensity PyroLagus a_t runde hodapp vili Cathy anderson)
00:07:11 --- names: list (anhduy Sornaensis c_wraith henrytill ramatevish benonsoftware hongminh1e frontendloader [exa] eagleflo Guest18532 I8IsBetterThanN8 jamiis_ Burnout641_ mulk jdevlieghere butterthebuddha electrocat Adeon dmj` dashed defanor mt sdx23 bs pikhq rjeli Akii cynick Ankhers barrucadu tokik bwe paroxp dsm__ Niamkik NemesisD valkyr2e soncodi sujeet BytesAndCoffee changyj jameseb Taneb drdo Zemyla statusbot lyxia gilbertw1 wting fiddlerwoaroof Kneiva gspia grandy____)
00:07:11 --- names: list (brolin_empey niluje ryanbooker Kamuela strmpnk jzelinskie etrepum micmus liste happy0 ongy ventonegro procgen pyrtsa michi7x7 rofer ccase Arguggi MalfaitRobin greymalkin pasukon cesardv luigy gareth_ jlewis asm89 danzimm rootmos hsiktas tolt twk- StianL xacktm markhuge guios Gabemo kubrat statusfailed ByronJohnson TakumoKatekari edran gesindel oberste1n exferenceBot intelux_ idupree2 mpickering bgyss feltnerm noobst mystfox aib integral vodkaInferno nonzen)
00:07:11 --- names: list (fairfieldt HalfEatenPie syamaoka dschoepe fnurglewitz Zowlyfon Chousuke Fylwind bytesighs customminer metalrain darthThorik joedevivo shans_ sdemos kgadek frew noxd gsingh93 cstrahan mindtree mbrcknl_ gothos Argorok iravid elvishjerricco dsal @ChanServ SolarAquarion so PHO reptar_ exio4 bvad croben wz1000 mgaare nilOps Tristan-Speccy kfish shapr nikolah d3lxa betawaffle suzu Ring0` blackdog dyreshark Jello_Raptor zachary12 qz MasseR DDR Biohazard Guest60956)
00:07:11 --- names: list (absence hjklhjklhjkl Desoxy cjh` skeuchel alek Nikotiini EvanR zomg ec2-user_ bengt_ oleks abra0 geal brennie reinh1 RazorX fuziontech e phaazon Eliel lpsmith tctara hexagoxel da-x koala_man Solarion ynyounuo Logio bus000 tippenein Xandaros madsj dredozubov Fuuzetsu jackhill pleiosaur)
00:09:03 <Cale> jcarpenter2: It does look like they are using lazy bytestrings to that end, which comes along with a bunch of unfortunate consequences, one of which is the difficulty of correctly handling exceptions like this.
00:09:33 <Cale> (though even if it were easier, it can be hard to decide what's right to do in cases of that sort)
00:10:23 <Cale> jcarpenter2: If you were just going to deepseq everything anyway, it would be better just to use strict ByteString in the first place
00:10:53 <jcarpenter2> i see
00:17:53 <jcarpenter2> yeah, this is a difficult problem
00:18:07 <jcarpenter2> suppose there's a long video that's being streamed, and there's a bottom value halfway through it
00:18:59 <Cale> Or more realistically, the connection to the database backend goes down
00:20:01 <Cale> I suppose just truncating the output might be detectable as a failure by the client if the header included the size
00:20:04 <jcarpenter2> well, if you're using a well-typed database connection you'll be able to handle that in application code
00:21:02 <Cale> Well, the point of streaming would be not to have the entire video in memory on the backend server.
00:21:15 <jcarpenter2> right
00:21:34 <ertes-w> dminuoso: indeed, that's exactly the solution i hoped you would come up with, so good job =)
00:22:00 <ertes-w> dminuoso: now look at your function and look at its type…  do you think you can improve the type signature?
00:22:14 <dminuoso> ertes-w: You mean switching the Applicative to Functor constraint?
00:23:00 <jcarpenter2> but the Happstack server would never have to see an error thrown if the database connection fails
00:23:20 <ertes-w> dminuoso: yeah
00:24:14 <dminuoso> ertes-w: Oh yeah had some real headaches today because of that. After that I rapidly derived over/set/view without cheating as well. It's quite obvious now.
00:24:48 <dminuoso> Just working on why they compose they way they do now.
00:24:50 <ertes-w> dminuoso: great…  so now You Understand The Basics Of Lenses =)
00:25:02 <ertes-w> dminuoso: ask yourself what exactly you're composing
00:25:18 <jcarpenter2> rather, an ErrorT is set and handled in your code, and you send Happstack a perfectly good command to close the connection
00:25:19 <ventonegro> dminuoso: Will you write your insights in a nice blog post? :)
00:26:15 <jcarpenter2> the problem would be if the database connection failed and you had been using a "fromJust" like a noob
00:28:48 <ertes-w> dminuoso: or rather ask yourself how you would normally write a two-layer traversal…  for example to access the x coordinate of each vector in a list, you would do this:  traverse (traverseX f)
00:29:03 <ertes-w> dminuoso: in other words, you would do this:  (traverse . traverseX) f
00:29:35 <ertes-w> outer traversal on the left, inner traversal on the right
00:30:01 <jcarpenter2> good night all :)
00:30:09 <jcarpenter2> thank you for your comments, Cale
00:30:46 <hphuoc25> cocreature: thanks I will look into it
00:49:25 <_sras_> Using Servant how can I access data, ie key/value pairs submitted via a form post?
01:00:54 <cocreature> _sras_: https://hackage.haskell.org/package/servant-0.11/docs/Servant-API-QueryParam.html
01:01:35 <alp> _sras_, cocreature: I think you probably want to use the FormUrlEncoded content type
01:01:42 <_sras_> cocreature: Isn't that just for GET?  
01:01:53 <_sras_> cocreature: Yes. I am looking at https://github.com/haskell-servant/servant/issues/236
01:02:16 <alp> so e.g: ReqBody '[FormUrlEncoded] MyFormInput
01:02:18 <_sras_> alp: Yes
01:02:34 <alp> for this to work, you need to define instance FromFormUrlEncoded MyFormInput where ...
01:02:47 <alp> oops
01:02:52 <alp> it's actually FromForm/ToForm
01:03:00 <alp> see https://hackage.haskell.org/package/http-api-data-0.3.7.1/docs/Web-Internal-FormUrlEncoded.html#t:FromForm
01:03:30 <alp> so in the example there, you'd be able to use Person as a ReqBody with content type FormUrlEncoded.
01:04:34 <_sras_> alp: Yes. I didn't get your comment about FromForm/ToForm.
01:06:35 <alp> _sras_, ok, sorry if that was not clear. If you want to be able to use ReqBody '[FormUrlEncoded] SomeType in a server
01:06:47 <alp> you need to make sure that SomeType implements the FromForm class
01:07:22 <alp> if you want to have a client that can send a SomeType request body, you need to write a ToForm instance for SomeType
01:07:35 <alp> it's just like JSON request bodies with FromJSON/ToJSON, same idea, different format.
01:07:37 <_sras_> alp: But the error I am gettiing about missing FromFormUrlEncoded instance.
01:07:58 <alp> oh hmm, maybe you're using a slightly older version of servant.
01:08:15 <_sras_> alp: Ah. Yes
01:08:16 <Mimmo> !list
01:09:12 <alp> _sras_, looks like the last time we had "FromFormUrlEncoded" (provided by servant) instead of using FromForm, from http-api-data, was in servant 0.8.x
01:09:16 <alp> while we released 0.12 yesterday
01:09:40 <alp> and starting with servant 0.9 we started relying on FromForm/ToForm instead of the custom classes with longer names.
01:15:11 <alp> _sras_, is everything clearer now?
01:15:42 <alp> note that there's a dedicated #servant channel, where you usually are more likely to get answer on servant stuffs.
01:19:30 <_sras_> alp: Yes . It is clear. But do you think the documentation can be made better to make some of these frequently used stuff easily accessable. I think instead of documentation for specific modules, it might be helpful  to include a top level documentaiton that covers the frequently used stuff. Like start with a very basic GET endpoint, and show how to change it to a post. how to add headers etc
01:20:26 <dysfun> perhaps point to the stack template for a servant app, if it's up to date?
01:22:07 <alp> _sras_, have you checked out the tutorial? sounds like this is pretty much what you're looking for: https://haskell-servant.readthedocs.io/en/stable/tutorial/
01:26:00 <alp> _sras_, if you do see a way to improve the tutorial, please let us know :) (issue tracker, IRC channel, mailing list)
01:27:16 <_sras_> alp:  Yes. But, just curious. Why isn't this on hackage page?
01:28:24 <_sras_> alp: I mean, something like this https://hackage.haskell.org/package/postgresql-simple-0.5.3.0/docs/Database-PostgreSQL-Simple.html
01:30:11 <merijn> _sras_: I missed the specific library being discussed, but usually the answer is: "because documentation/tutorial writing is hard work, many people don't like doing it, and for even more people it's not part of what they're paid to do"
01:31:47 <alp> _sras_, it is way too large to fit in haddocks IMO. haddocks do show small examples here and there, but the landing page of servant on hackage links to the tutorial, that's really the main way to learn the library
01:32:44 <alp> _sras_, maybe the haddocks could do with small examples showcasing each content type etc, I think we do have this for the combinators but maybe not the content types
01:36:15 <_sras_> alp: Do you have the repo for the readthedocs documentation. Can I send a PR?
01:38:15 <alp> _sras_, yes, absolutely, that'd be very appreciated. documentation issues/PRs are always welcome. the tutorial is in fact in the servant repo itself, and the tutorial's code is compiled in CI. https://github.com/haskell-servant/servant/tree/master/doc/tutorial the tutorial is made of all the .lhs files you can see there (literate Haskell allows you to interleave text and code as you can see in those modules))
01:39:06 <haskellnoob> I am playing with haskell around 3 days, Can I know what are the uses of haskell ? Can I use haskell for competitive programming like topcoder ?
01:39:09 <_sras_> alp: Yes. Thankyou. 
01:40:36 <merijn> haskellnoob: Asking "what are the uses of Haskell" is like asking "what are the uses of Java?", it's a general purpose language, there's no specific uses
01:42:28 <ertes-w> haskellnoob: as a beginner you probably can…  the more you learn, the more frustrating competetive programming gets, because sites usually impose really stupid restrictions on you, which hurts haskell programming more than most other languages
01:42:50 <ertes-w> like being restricted to an old GHC or the set of libraries you can use
01:42:56 <haskellnoob> http://lpaste.net/6505963915350900736
01:43:44 <phaazon> is there a package out there for persistent that correctly handles transactional and iterative migrations?
01:44:07 <merijn> phaazon: I doubt it
01:44:12 <phaazon> :(
01:44:17 <phaazon> it might be doable
01:44:20 <phaazon> with printMigration
01:44:24 <phaazon> and a lot of trickery
01:45:18 <ertes-w> haskellnoob: writing type signatures for top-level definitions is useful as documentation, because unlike most other languages the type is not immediately obvious by just looking at the first line of the definition
01:45:30 <merijn> phaazon: Honestly, I'm not all that impressed with persistent anyway. Next time I'll probably look into Selda (I can't be arsed to replace all the persistent code I have atm)
01:45:44 <phaazon> merijn: I use selda already
01:45:48 <phaazon> and I love it
01:45:52 <phaazon> I use it in a project or two at work
01:46:02 <phaazon> but my colleagues don’t like all the :*: stuff :(
01:46:25 <merijn> phaazon: I was thinking about making opaleye work with SQLite again, but since Selda seems very similar I can save myself a lot of time :p
01:46:30 <haskellnoob> ertes-w:  ok so that line 1 is not mandatory I thought it was mandatory
01:46:44 <ertes-w> haskellnoob: no, types are inferred
01:46:44 <phaazon> yes you can
01:46:49 <phaazon> it’s awesome
01:47:01 <phaazon> though, I think some work must be done on it to leverage the difficulty to maintain code
01:47:08 <phaazon> like, compilation errors are pretty terrible haha
01:47:17 <phaazon> and it’s very easy to write messy code
01:47:22 <phaazon> with a :*: b :*: c …
01:47:30 <haskellnoob> infered meaning?
01:47:47 <haskellnoob> ertes-w: ^
01:48:07 <merijn> phaazon: I doubt they'd be that terrible compared to my current issues :p
01:48:13 <ertes-w> haskellnoob: GHC figures out the type from context
01:48:23 <merijn> phaazon: 1 mistyped character -> fifteen gazillion pages of C++ template errors :p
01:48:35 <phaazon> :D
01:48:38 <phaazon> yeah
01:48:38 <ertes-w> haskellnoob: it rarely needs your help, so for the most part type signatures are documentation
01:48:42 <phaazon> using boost? :D
01:48:48 <phaazon> I remember bad times with Spirit.Qi haha
01:50:46 <merijn> phaazon: Naah, not even using boost >.>
01:50:52 <haskellnoob> kind of confusion still but I want to move forward, but why you say its frustrating for haskell expert in competitive programs so expert haskellers dont participate in competitions etc ?
01:52:15 <ertes-w> haskellnoob: haskell and GHC evolve rather rapidly, and at the same time the base library is rather barebones…  it's not batteries-included like in some of the more mainstream languages
01:52:38 <ertes-w> haskellnoob: in other words you really want the latest GHC, and you want free choice over libraries
01:53:34 <ertes-w> haskellnoob: as a language haskell is a rather simple core language on which you build abstractions and control structures…  compare it to python for example, which has generators/coroutines built into the language…  in haskell you would have those as *libraries*
01:54:22 <haskellnoob> ok as I understand I have to build my own libraries right
01:54:43 <ertes-w> that makes haskell more powerful, *if* you're not forced to reinvent everything for every task
01:54:59 <ertes-w> i've seen people reinvent parser combinators, because they were not allowed to use parsec, for example
01:55:49 <haskellnoob> Ok apart from competitive programming in my company I think I can use it freely
01:56:33 <haskellnoob> May be haskell also need to include those libraries to its core std libraries? Like python did to requests
01:58:17 <ertes-w> some of them yeah, maybe…  some of the libraries are more or less community standard like 'text'
01:58:35 <ertes-w> not sure if they should be included…  it's easy enough to list them as dependencies in your cabal file
01:59:11 <ertes-w> the base library is tightly coupled with GHC, so bringing those libraries into base would make the update cycle much longer
01:59:47 <haskellnoob> Ok Thank you
02:00:08 <ertes-w> this has already happened in the past…  some libraries that don't really have to change that often like 'semigroups' have made it into base
02:00:25 <ertes-w> or some modules from 'transformers' like (finally!) Control.Monad.IO.Class
02:01:24 <ertes-w> but it's unlikely that a JSON library like aeson makes it into base, because that would be counterproductive
02:01:38 <haskellnoob> Ok 
02:02:47 <ertes-w> it's also not really necessary…  we have a strong community standard for where to publish and how to depend on libraries: cabal
02:03:27 <ertes-w> cabal pretty much takes care of everything for you…  you just say, "i need aeson", and it will be available
02:05:56 <haskellnoob> I still have no idea of cabal I need to learn more I guess
02:06:02 <haskellnoob> is it like pip ?
02:06:57 <ertes-w> it has the same purpose
02:11:07 <haskellnoob> ok May be I will explore it soon. Thanks again 
02:48:13 <haskellnoob> [16:16] <haskellnoob> :t "hey" [16:16] <lambdabot> [Char]   there is no string in haskell like c ?
02:50:43 <ertes-w> haskellnoob: we have three main string types in haskell: ByteString, String, Text
02:51:13 <haskellnoob> Can you please show example ? with :t
02:51:27 <merijn> ertes-w: Now I'm going to have to burn you as a heretic for implying ByteString is a string type
02:52:13 <ertes-w> haskellnoob: ByteString is basically an immutable variant of C's (char *)
02:52:28 <ertes-w> so a type for raw byte arrays
02:52:41 <ertes-w> merijn: "string" doesn't really imply "text"
02:54:00 <Maxdamantus> Pretty much any practical "string" type anyone can come up with probably isn't much better at being a type for "text" than ByteString anyway.
02:55:52 <ertes-w> Maxdamantus: why?
02:55:54 <Maxdamantus> cf. Data.Text, which still doesn't even represent things in terms of unicode code points (not that that's generally useful anyway).
02:58:00 <Maxdamantus> ertes-w: because the meaning of "random access text" is arbitrary .. any useful operation on text involves either walking through the text, or just concatenating bits of text together.
02:59:12 <Maxdamantus> which is perfectly sensible to do using something like ByteStrings .. when you want to finally render the text, or do some sort of Unicode-based comparison or normalisation or something on it, just interpret the sequence of bytes as UTF-8.
02:59:30 <Maxdamantus> Data.Text already does all of this, except it uses UTF-16 instead of UTF-8, probably for historical reasons.
03:00:27 <ertes-w> Maxdamantus: that's true, which is why i'd propose UTF-8 for Text, and whenever you need "random access" use Vector Char instead
03:00:33 <fakenullie> i think many useful operations will also need to convert from utf-8 sequence to unicode codepoint to operate
03:00:34 <Maxdamantus> Though in Data.Text the fact that it uses UTF-16 is at least an implementation detail, since it prevents you from coming up with values that are not well-formed Unicode strings.
03:01:11 <Maxdamantus> fakenullie: well, you shouldn't exactly need to "convert" .. when you want Unicode code points, you can walk through the UTF-8 string.
03:01:28 <fakenullie> and convert on the fly
03:01:53 <Maxdamantus> Sure, the actual string representation is not something involving Unicode code points though.
03:04:22 <mpickering> Is there a simple library or interface which allows me to generate a dot graph from a list of edges? 
03:04:28 <mpickering> Is Graphviz the way to go?
03:04:42 <ertes-w> the point of my proposal is: go with the encoding that potentially uses the least amount of memory
03:04:54 <ertes-w> since the operations are O(n) anyway
03:04:57 <fakenullie> gzip?
03:18:21 <ertes-w> kinda weird to depend on zlib for basic string operations =)
03:18:33 <ertes-w> on the other hand we depend on GMP for basic integer opreations, so who cares
03:19:42 <ertes-w> err, no, that would be a bad idea…  sharing, i.e. O(1) slicing, would no longer work
03:24:23 <fakenullie> you can share part of compressed stream
03:25:10 <Maxdamantus> It's probably often not going to save space.
03:25:11 <fakenullie> nevermind, that won't work
03:25:47 <Maxdamantus> It would usually only save space in cases where the programmer designed the storage in a special way, which you can already do.
03:25:48 <fakenullie> compressions saves a lot for text data
03:26:23 <Maxdamantus> Yeah, so it should generally be compressed when stored on persistable media or sent over a network.
03:27:07 <Maxdamantus> but if you've got a million 20-byte strings hanging around in memory, you're probably not going to save anything by compressing each of those 20-byte strings (individually)
03:27:12 <saurabhnanda> criterion is constantly telling me that my benchmark numbers are severely inflated. Across multiple runs the numbers aren't (relatively) consistent. How do I fix this?
03:27:37 <Maxdamantus> You might be able to do something clever by considering all of those million 20-byte strings at the same time.
03:31:00 <Maxdamantus> $ ls -lh .git/objects/"$(echo "some 20-byte string" | git hash-object -w -t blob --stdin | sed 's/^../&\//')"
03:31:03 <Maxdamantus> -r--r--r-- 1 max max 34 Nov 10 00:30 .git/objects/54/8b928d44847c88371cc9479dde0c5fad1af394
03:31:30 <Maxdamantus> To be fair, the actual content that is compressed there is "blob 20\0some 20-byte string"
03:32:02 <Maxdamantus> still loses 3 bytes.
03:32:55 <Maxdamantus> er, forgot about the "\n", so loses 2 bytes.
03:35:42 <EvanR> we dont need to depend on GMP for basic integer operations
03:37:12 <EvanR> https://github.com/erikd/haskell-big-integer-experiment
03:58:18 <grandeverde> ciao
03:58:20 <grandeverde> !list
04:13:24 <onceanoob> in 2018 if haskell is my first language should I go for rust or c or c++ for my second language adventure
04:13:37 <merijn> onceanoob: Rust, probably
04:13:51 <merijn> Unless you have a specific reason to use C++
04:14:10 <onceanoob> merijn:  why Rust ?
04:14:27 <merijn> onceanoob: Most "haskelly" of those 3
04:14:55 <merijn> C is an ugly language that's just painful to use for most issues, the only upside is "manual memory management", but Rust does that better
04:15:02 <merijn> C++ is an overcomplicated mess
04:15:59 <onceanoob> merijn:  what are haskell like languages?
04:16:20 <merijn> onceanoob: Focus on safety
04:16:57 <onceanoob> merijn:  I asking like haskell/rust what other languageds are there
04:17:56 <merijn> onceanoob: Not a lot :p
04:36:31 <ertes-w> after haskell you should probably learn javascript or python, so you know why the way haskell sucks is complaining on a very high level
04:37:02 * Clint_ squints.
04:37:30 <ertes-w> or even PHP
04:37:48 <ertes-w> haskell complaint: "why the hell can't i partially apply a type synonym?"
04:38:19 <ertes-w> PHP complaint: "why the hell did this function kill my database?  it doesn't even access anything DB-related!"
04:46:48 <sun777> As a used to be PHP dev i can confirm
04:47:10 <sun777> at least the php part, i mean. 
04:55:35 <tdammers> my PHP experience is more like, OK, so I know the right approach to this problem... but, oh wait, that won't work in PHP because {arbitrary restriction}. Never mind, I know a way around that. Oh, no, can't do that because {other arbitrary restriction}. Well then, I'll take a different approach. Hmm, no, that doesn't work either, because {arbitrary restriction}. Etc. etc. ad absurdum
04:56:04 <felixsch_> When I have a record: User { _email :: String } where I use autogeneration of lenses for this type. When I now use Aesons ToJSON feature. Will it generate "_email" or "email"?
04:56:11 <tdammers> and then in the end you settle for something half-assed that falls apart if you cough in its general direction, but it's the best you can do and everyone thinks you're a hero
04:57:09 <lyxia> felixsch_: I think it's "_email", but you an customize it.
05:19:25 <lerneaen_hydra> Hi everyone, total haskell newbie here. (If there's somewhere else I should be wrt. asking questions, just let me know and I'll move along). With that said, assume I create some type 'data Foo = Empty | Bar Int Foo'. Now, assume 'let b = Bar 1 (Bar 2 Empty)' . Is there any convenient way so that, given 'b', I can access the entry 'Bar 2 Empty'? Many thanks!
05:19:52 <merijn> lerneaen_hydra: Pattern matching
05:20:17 <merijn> lerneaen_hydra: "case b of (Bar _ x) -> doStuffWith x; Empty -> reportError"
05:21:08 <lerneaen_hydra> merijn: I'll take a look at pattern matching in more detail, many thanks!
05:41:01 <haskellnoob> May be I am wasting a lot of time on this but I wanted to understannd perfectly...what is the difference between addThree :: Num a => a -> a -> a -> a  addThree :: Int -> Int -> Int -> Int
05:41:27 <mauke> the first one can be used with any numeric type
05:41:38 <ventonegro> The first one accepts any type that implements Num
05:42:47 <Jacoby6000> does (,) implement Num? such that (Num a, Num b) => Num (a, b) ?
05:43:09 <haskellnoob> and what is the difference between Int and Integer?
05:43:14 <liste> Jacoby6000: so all operations would be pairwise?
05:43:17 <ventonegro> :info Num
05:43:25 <liste> Jacoby6000: I think you could implement that instance
05:43:26 <ventonegro> Does not work :)
05:43:35 <ventonegro> Try it at the REPL
05:43:42 <Jacoby6000> haskellnoob: one is fixed precision, and one is arbitrary IIRC
05:43:55 <Jacoby6000> s/precision/width/
05:44:13 <mauke> > maxBound :: Int
05:44:15 <lambdabot>  9223372036854775807
05:44:21 <ventonegro> Jacoby6000: not really
05:44:30 <mauke> > 9223372036854775807 + 1 :: Int
05:44:32 <lambdabot>  -9223372036854775808
05:44:33 <mauke> > 9223372036854775807 + 1 :: Integer
05:44:35 <lambdabot>  9223372036854775808
05:44:46 <liste> :t addThree
05:44:47 <lambdabot> Num a => a -> a -> a -> a
05:44:51 <liste> > addThree 1 2 3
05:44:53 <lambdabot>  6
05:44:57 <haskellnoob> ok is it overflow when we use int
05:44:57 <liste> > addThree 1.0 2.0 3.0
05:44:59 <lambdabot>  6.0
05:45:02 <ventonegro> Jacoby6000: Sorry, wrong message
05:45:02 <haskellnoob> and integer no bound
05:45:03 <liste> haskellnoob: ↑
05:45:18 <liste> haskellnoob: addThree with Num a works with all kinds of Nums
05:45:22 <liste> haskellnoob: not just Ints
05:45:39 <mauke> > addThree 0.5 0.5 0.5
05:45:41 <lambdabot>  1.5
05:45:44 <mauke> > addThree 0.5 0.5 0.5 :: Rational
05:45:46 <lambdabot>  3 % 2
05:49:19 <haskellnoob> Ok Thanks mates
06:28:42 <saurabhnanda> does anyone know the limits that TravisCI puts on open source projects?
06:32:29 <quchen> It builds GHC, so that’s reassuring
06:32:45 <quchen> I remember having some issues when putting Hadrian on Travis though, but that was 1.5 years ago :-/
06:33:06 <quchen> Maybe as Andrei Mokhov, I’m sure he has more experience with this
06:33:23 <quchen> »Andrey«, woops.
06:33:48 <quchen> saurabhnanda: ^
06:34:15 <saurabhnanda> quchen: I meant in terms of resources? memory? cpu? concurrent builds?
06:34:41 <quchen> Uh, no idea
06:45:48 <haskellnoob> why does it throw a error ?/ circumference :: Int -> Float circumference r = 2 * pi * r   
06:45:58 <haskellnoob> why can't I mention Int ?
06:46:32 <cocreature> haskellnoob: because * requires that both arguments have the same type but r has type Int while pi has type Float (actually pi’s type is slightly more general but that doesn’t matter here)
06:46:50 <cocreature> haskellnoob: you can use "fromIntegral r" to convert r to a Float
06:46:50 <fakenullie> :t pi
06:46:51 <lambdabot> Floating a => a
06:48:02 <fakenullie> > pi :: Rational
06:48:04 <lambdabot>  error:
06:48:04 <lambdabot>      • No instance for (Floating (Ratio Integer))
06:48:04 <lambdabot>          arising from a use of ‘pi’
06:48:29 <haskellnoob> in that case why this is not working 
06:48:31 <haskellnoob> circumference :: Int -> Float circumference r = 2 * 4 * r
06:48:51 <fakenullie> haskellnoob: because you need to convert from int to float still
06:50:37 <cocreature> haskellnoob: note that Haskell has no implicit conversions
06:50:41 <fakenullie> > toRational p\\ :: Rational
06:50:43 <lambdabot>  <hint>:1:16: error: parse error on input ‘::’
06:50:51 <cocreature> if you want to convert from one type to another you’ll need to do so explicitely
06:51:32 <haskellnoob> Okay fakenullie  cocreature 
06:51:56 <hexagoxel> saurabhnanda: 500MB resident, beyond that trashing starts. 50min per task limit, 4 concurrent (or less than 4 if no idle workers)
06:59:21 <Guest1000000> hello
06:59:46 <Guest1000000> What is the main characteristics of Haskell?
07:00:00 <Psybur> Pure, lazy and functional?
07:00:10 <erisco> statically typed, purely functional, type inference, concurrent, lazy, packages
07:00:15 <erisco> https://www.haskell.org/
07:00:21 <mauke> it's a programming language
07:00:47 <saurabhnanda> hexagoxel: wow -- does lens use Traveis?
07:01:00 <hexagoxel> dunno
07:01:37 <cocreature> hexagoxel: are you sure about the 500mb limit? I’m pretty sure I have projects that should use significantly more and I haven’t experienced any problems
07:01:53 <Guest1000000> Thanks. What kind of programs is Haskell mainly used for?
07:02:37 <lyxia> Haskell compilers
07:03:02 <erisco> Guest1000000, read https://wiki.haskell.org/Introduction
07:04:08 <erisco> Guest1000000, also https://github.com/Gabriel439/post-rfc/blob/master/sotu.md
07:04:47 <hexagoxel> i had travis get stuck (20min+) on compiling a single module, and fixed it by using +RTS -M500M. i think it still uses more than 500, because ghc uses like 600 still. but somewhere around that it got problematic.
07:05:07 <hexagoxel> and no, i don't have more than this observation as backup :p
07:06:08 <Guest1000000> Thanks. Bye.
07:07:47 <cocreature> hexagoxel: I have a project that compiles LLVM as a dependency on travis and at least on my locale machine that’s somewhere in the GB range and it’s reasonably fast on travis
07:09:07 <hexagoxel> wait, resident memory or disk usage?
07:09:15 <cocreature> resident memory
07:09:18 <hexagoxel> oO
07:11:06 <cocreature> https://docs.travis-ci.com/user/reference/overview/ claims that you have 4gb in container based builds although it is unclear how much of that is shared with others
07:12:19 <hexagoxel> i find that rather hard to believe. they can't be running that beefy virtual machines.. perhaps llvm is just much more cache-friendly?
07:12:48 <cocreature> if they’re machines were not beefy, I wouldn’t be able to compile LLVM in 50minutes :)
07:12:52 <cocreature> *their
07:12:57 <hexagoxel> but then, i would not put too much trust in my one data point either :)
07:28:12 * toby1851 is having fun with asum and IO
07:28:40 <toby1851> although, i'm a bit boggled that IO's monad zero is an exception
07:29:27 <Cale> toby1851: What else would it be?
07:29:38 <Cale> (perhaps nothing at all)
07:30:14 <Cale> (i.e. we might just opt not to have an instance for IO)
07:30:55 <Cale> However, it is kind of a nice way of chaining handlers sometimes, when you're being a bit lax regarding exactly which exceptions are being caught.
07:33:47 <toby1851> i'm finding it a bit weird that <|> and asum turn out to be exception handlers
07:34:24 <shterrett> I'm writing the types for a parser, and I want to know if there's a way to use a data declaration inside another data declaration. For instance: `data Id = Id String; data Expression = Id | Other`. I'd like the `Id` data I defined earlier to essentially be inlined in the new definition. I know this isn't standard, but in the large Expression sum type, there are multiple constructors that can take only a subset of the variants in Express
07:34:24 <shterrett> ion, and I'd like to make that explicit.
07:37:17 <Cale> shterrett: You're not allowed to have the same data constructor belong to more than one type (at least, within a given module's scope)
07:38:13 <chindy> When opening a haskell file in emacs i get stuck at initializing..., some bug report says this has been fixed with ghc-mod 5.4 but I have 5.7
07:39:35 <Cale> So if you defined Id as a data constructor of type String -> Id, then you're not allowed to also have it be a value of type Expression (there are three separate things you named Id there, you're allowed to have a type and a data constructor with the same name, because they live in separate namespaces, but that's it)
07:40:00 <shterrett> Cale: I understand that. I'm wondering if there's a way to make a single, large sum type where some of the constructors within that sum type recursively have only a portion of the large type as an argument. 
07:40:18 <Cale> Well, you can make a sum of smaller sum types
07:40:56 <shterrett> With an extra level of TypeConstructor Nesting. Ok - I'll give that a shot
07:41:04 <SexHendrix> chindy: are you running any other plugins with haskell files
07:41:08 <Cale> You can also make a GADT where the way in which the parameter to the type gets specialised tells you something about which subset of the constructors the term was built with
07:41:11 <SexHendrix> i've had similar issues in the past
07:41:16 <Cale> (though that's fancy)
07:41:59 <chindy> SexHendrix: yes. Should I just try to disable everything?
07:42:03 <Cale> (and works best if the subsets are disjoint)
07:42:45 <SexHendrix> chindy: are you interfacing it with the global haskell install or with stack
07:43:08 <shterrett> Cale: Thanks. I'll start with the simpler one, but keep the GADT in mind. The subsets aren't disjoint; they're overlapping and in layers. 
07:43:25 <Cale> are they nested?
07:44:24 <ertes-w> chindy: with emacs you usually don't need ghc-mod…  just use haskell-interactive-mode
07:44:27 <shterrett> Cale: Yes. Let me throw up a gist of the (not compiling) types I translated out of the specificiation
07:44:37 <ertes-w> chindy: from haskell-mode
07:46:03 <shterrett> Cale: https://gist.github.com/shterrett/ea9a69de4c36fa01a652e61b6b3f7a01
07:46:18 <shterrett> Id, TypeId, and LValue are the problems
07:46:42 <Cale> oh, well, this is close
07:46:58 <Cale> You just need to rename that data constructor and you probably want to give it an argument
07:47:06 <Cale> The Id you're writing there doesn't refer to the type
07:47:17 <Cale> It's syntactically in the position where the name of a data constructor goes
07:47:38 <shterrett> Right - I figured that out. So I just add a new data constructor for each of those variants in Expression, and go from there
07:49:05 <Cale> So like, where you currently have LValue in Expression, you want something like LValueExpr LValue
07:49:39 <shterrett> Yep - got it. Thanks!
07:49:46 <Cale> data Type = TyVar TypeId | ...
07:49:48 <Cale> etc.
07:55:17 <aje> hello, I'm trying to make a game in which players make a move one by one. It's a game of dominoes, I've made a function which allows player 1 to place all their dominos first then player 2 to play all their dominoes. But i'm unsure on how to allow player 1 to make a play then player 2 one after the other, does anyone have any ideas, thank you
08:01:06 <sm> that's a good question
08:01:52 <sm> aje: one easy way is to have a function that calls itself again to repeat, unless game is over (recursion)
08:06:48 <aje> will i need 2 separate functions? like player 1 move and player 2 move. When player 1 move makes a move it calls player 2 move and so on and so forth?
08:07:26 <ventonegro> aje: Write a function `nextPlayer :: Player -> Player`
08:08:01 <ventonegro> aje: And then call it `play (nextPlayer p) ...`
08:10:29 <whoisxy> on https://downloads.haskell.org/~ghc/7.0.3/docs/html/users_guide/lang-parallel.html in the example given in 7.18.4. it states that the evaluation of n2 is required before n1. Why is this so they don't affect each other. perhaps some optimization could be performed by reusing previous results however I'm not aware that haskell implies such optimizations.
08:10:59 <whoisxy> s/implies/employs/
08:15:19 <lynn> aje: is this at all enlightening? http://lpaste.net/359920
08:16:08 <lynn> ...heck, I overwrote this with its output >_>
08:17:19 <cocreature> whoisxy: without the pseq, the compiler could try to evaluate "n1 + n2 + 1" by first evaluating "n1" but you are already evaluating this in the other thread so now you have two threads computing the same thing (or one blocking until the other has finished). thereby you don’t gain any performance from parallelism
08:17:35 <lynn> ok, now it has both--whoops, they're gone
08:20:42 <whoisxy> cocreature: but what point if it's sequenced. in this case that sounds like they can't run in parallel. also if they do make use of the results from previous calls spawwning a thread seem pointless for what would only be a simple addition operation as
08:21:02 <whoisxy> s/as/
08:21:31 <cocreature> the addition itself is cheap but calculating the values that are being added can be expensive
08:21:50 <cocreature> whoisxy: what is being sequenced is the operation of thread 2, thread 1 will still compute n1 in parallel
08:21:51 <whoisxy> cocreature: it feels like im missing what your saying
08:22:43 <cocreature> "par a b" will evaluate a and b in parallel and then return b
08:23:19 <cocreature> "pseq a b" will evaluate a before b and then return b
08:23:48 <cocreature> "par n1 (pseq n2 (n1 + n2))" will evaluate "n1" and "pseq n2 (n1 + n2)" in parallel
08:24:00 <cocreature> so in particular n1 and n2 will be evaluated in parallel
08:27:34 <whoisxy> I'm still not understanding so far I have `n1` and `pseq n2 (n1 +n2)` be evaluated in parallel and `n2` will be evaluated before `n1 + n2`
08:29:07 <ertes-w> the most common mistake when designing a turn-based game in haskell is that people try to model *state* and *state transitions*
08:29:51 <cocreature> ertes-w: what’s wrong with modelling a game as a state transition system?
08:30:25 <ertes-w> cocreature: nothing, but the types and API should be modelled as automata, not as transition functions
08:31:24 <cocreature> I still don’t understand your point: automata have transition functions
08:31:32 <whoisxy> cocreature: Okay so I think thats a bit clearer after revising, it will attempt to find the value of n2 before it tries the addition of n1 + n2, otherise it might wait on n1 from the first thread before evaluating n2 
08:31:39 <ertes-w> data Dominos = Red Presentation (Move -> Dominos) | Blue Presentation (Move -> Dominos) | GameOver Finale
08:31:43 <cocreature> whoisxy: exactly
08:32:03 <ertes-w> as opposed to:  data GameState = …; redMove :: GameState -> GameState; blueMove :: GameState -> GameState
08:34:03 <hexagoxel> ertes-w: that smells just like Functor vs Monad.
08:34:34 <toby1851> further discoveries.... IO has only been an instance of Alternative since 2015! and the implementation (mplusIO) does involve exception handling
08:34:43 <whoisxy> cocreature: I assume the recursive element to this function does cause the issue of spawning many threads but keeps it at 2?
08:34:55 <whoisxy> *doesn't 
08:34:59 <cocreature> I’ll go for "data GameState = …; move :: Action -> GameState -> GameState"
08:35:04 <totom> Is there any prerequisites to the book "Haskell road to math and logic"
08:35:10 <betawaffle> is it possible to define an instance for (a -> Bool) where the a isn't there?
08:36:07 <ertes-w> betawaffle: you mean an instance for (-> Bool)?
08:36:22 <betawaffle> if that's a section, yes
08:36:40 <ertes-w> betawaffle: not directly…  you would have to define a wrapper type:  newtype Flip f a b = Flip { fromFlip :: f b a }
08:36:57 <ertes-w> then you can define an instance for (Flip (->) Bool)
08:36:59 <Jacoby6000> cocreature: That looks a lot like State.
08:37:08 <betawaffle> ertes-w: ok, thanks
08:37:12 <Jacoby6000> (the datastructure)
08:37:13 <cocreature> Jacoby6000: sure
08:37:37 <Jacoby6000> Why not encode your game action/state using the State monad?
08:38:21 <cocreature> because ime State doesn’t really help simplify things
08:38:28 <ertes-w> cocreature: there are strong advantages to going with an intrinsic state encoding, but after having explained my hangman encoding for like a billion times here i feel i should just refer you to the #haskell logs =)
08:38:30 <betawaffle> ertes-w: so like this? newtype Filter a = Filter { runFilter :: a -> Bool }
08:38:52 <ertes-w> betawaffle: yeah
08:39:50 <cocreature> ertes-w: oh sure there are advantages to your approach but separating your state from your transitions also has advantages
08:40:39 <hexagoxel> Jacoby6000: because input events happen over time, and state monad doesn't work too well for that.
08:41:17 <ertes-w> cocreature: if you construct it carefully enough you can maintain an isomorphism to its equivalent final encoding and get the best of both =)
08:41:21 <Jacoby6000> hexagoxel: how are functions better for that?
08:41:36 * hexagoxel searches for hangman in my weeks-long-history and finds.. one instance, from 2 min ago
08:42:05 <erisco> http://community.haskell.org/~ertes/hangman/
08:42:31 <ertes-w> woah, where did you dig that one out?
08:42:45 <ertes-w> anyway, it's not a good article…  too much prose, too few exercises
08:42:46 <Jacoby6000> thanks!
08:42:52 <Jacoby6000> oh
08:43:03 <erisco> I didn't. You did!
08:43:33 <ertes-w> well, it's not that bad actually =)
08:43:46 <ertes-w> i've done far worse in the past
08:44:06 <erisco> it is fine
08:55:05 <hexagoxel> ertes-w: does this approach not collapse entirely once you want to save/load game states?
08:56:22 <hexagoxel> and doesn't FRP give you the same kind of compositionality without sacrificing serialization?
08:58:23 <ertes-w> hexagoxel: no, but i'll elaborate tomorrow (short version: you need an isomorphism, and FRP is orthogonal)…  i'm off for now
08:58:47 <hexagoxel> feel free to point me to some logs, too..
09:05:10 <AWizzArd> I didn’t attend the Lambda World conference a few weeks ago but I heard Snoyman was suggesting to use a ReaderT over a TVar instead of StateT. Is this something that was already debated in some forum? Can anyone link to a nice blog post explaining this?
09:06:23 <mxf_> AWizzArd, https://www.fpcomplete.com/blog/2017/06/readert-design-pattern
09:06:36 <mxf> just had the tab open ;)
09:07:09 <mxf> AWizzArd, and https://www.fpcomplete.com/blog/2017/07/the-rio-monad
09:07:30 <AWizzArd> mxf: okay cool, thank you
09:10:31 <cocreature> I vaguely recall seeing a convenience wrapper for "[minBound..maxBound]" in base, am I missremembering?
09:10:48 <Clint> something in universe?
09:11:29 <cocreature> Clint: ah good point, maybe I had seen it there
09:13:45 <simendsjo> I'm pretty stuck on some basics here. I'm trying to read from stdin where the input follows this pattern: https://gist.github.com/simendsjo/34774d6c22229714beb077f6967a66ea. First a number stating the number of following lines that is a part of the input, and so on, until a sentinel value -1 telling there is no more input. For each group of lines, I wish to run some calculation. Trying to solve this is tricky for me, and I can't seem to
09:13:45 <simendsjo> find a reasonable way to do this. What are some elegant, hopefully effecient, way to read and group this input?
09:16:50 <erisco> simendsjo, what have you done so far?
09:18:29 <simendsjo> I've tried various ways of having loops in IO detecting the sentinel value to break, aggregating the input as I go. I can probably get it working, but it just seems so little elegant. Now I'm trying to read the entire input at once, shaving off as I go until I meet the sentinel value...
09:18:56 <erisco> have you tried readLn?
09:21:54 <nohTo> simendsjo: If every line in a block needs the same treatment (t :: IO b), then sequence (replicate n t) is your friend
09:22:11 <simendsjo> Yes, I'm reading the input, I just don't know how to structure it. I would like to read the input as [[n1line1, n1line2], [n2line1, n2line2]]
09:22:31 <simendsjo> Yes, the same calculation applies for all. I'll look into it.
09:23:27 <erisco> :t lines <$> getContents -- maybe start here
09:23:28 <lambdabot> IO [String]
09:24:34 <simendsjo> erisco: Yeah, I've gotten that far. The problem is chunking the file by the number n in the input, and then stopping when I reach the sentinel value. Maybe the simplest thing would be to read the sentinel value as a regular line, and then dropping it...?
09:25:19 <erisco> try init
09:29:23 <EvanR> simendsjo: a cool exercise is to define a type like data IOStream e a = Item a (IOStream a) | Error e | Done, then create one in IO which uses unsafeInterleaveIO to represent the reading as a pure value 
09:30:12 <EvanR> er forgot an e in there
09:31:00 <EvanR> then you can transform the raw stream in whatever way with regular FP techniques
09:32:00 <EvanR> its a way to stuff the crunchy IO crap behind a curtain or under a rug and expose a nicer interface
09:32:52 <nohTo> simensjo: After reading and applying lines you have a [String] and want to turn it into a [[String]]. You can do this recursively, by inspecting the number at the top, then splitting the list into first n lines and rest, then call yourself recursively on that rest
09:35:36 <simendsjo> Thanks. The IOStream thing is way above my level :) Just reading the last sentinel value as a regular line and using `init` helped though. I was able to solve it using this although it's probably a longshot from idiomatic Haskell :/ https://gist.github.com/simendsjo/47e2aab3160dd572d19a618014228937
09:36:18 <erisco> the first try is rarely good
09:36:50 <erisco> c :: String <- getContents   now there is some funny syntax
09:38:02 <erisco> times :: [(Int, Int)] = getTimes <$> lines
09:38:07 <erisco> I didn't know that was valid syntax
09:38:57 <nohTo> erisco: Oh my god you can write that?
09:39:08 <erisco> ask simendsjo
09:39:26 <erisco> I thought I was reading F# or something for a second
09:39:29 <nohTo> Ah, it's the language extension
09:39:55 <simendsjo> As I said; probably not very idiomatic :)
09:42:10 <erisco> > let f (x:xs) = let (a, b) = splitAt (read x) xs in a : f b; f [] = [] in f ["1","hello","2","hey","ya","-1"]
09:42:12 <lambdabot>  [["hello"],["hey","ya"],[]]
09:43:33 <erisco> > let f (x:xs) = uncurry (:) (fmap f (splitAt (read x) xs)); f [] = [] in f ["1","hello","2","hey","ya","-1"]
09:43:35 <lambdabot>  [["hello"],["hey","ya"],[]]
09:48:02 <erisco> you wrote the same thing, so I'd grade that part an A ;)
09:49:24 <erisco> calc is probably fine too, though I don't know what it does
09:53:54 <simendsjo> It's just a algorithmproblem on open.kattis.com, so it's not meant to do anything useful :)
09:54:18 <erisco> reeks of a C problem,t oo
09:56:11 <simendsjo> Seems like pretty much every problem there is structured to allow a fast answer in C
09:57:18 <erisco> read the whole file and *then* process?!
09:57:23 * erisco clutches his programming pearls
10:03:53 <mud> simendsjo: The input parts are usually easy enough to do in haskell, this one sounds like one of the more annoying input formats. But yes, Cish languages are assumed for some of the data structures once in a while, but there's almost always an alternative. Or you can just use ST or IO mutable arrays.
10:06:46 <RedMachine> Why are so many people on Haskell?
10:06:51 <simendsjo> The input is pretty simple in most cases, but where there are several testcases within a file *and* using sentinel values, it becomes annoying with my very limited Haskell experience. The problemtext and input specifies things that make it suitable to use static arrays. Like "the input will never be more than 120 characters long" etc. I'm just using String for everything. /me runs and hides
10:07:55 <erisco> RedMachine, idling here passively increases your IQ, true fact
10:08:28 <RedMachine> erisco, I had no idea. I've just been watching Rick and Morty to up my IQ.
10:16:32 <EvanR> erisco: read the whole file and the process, is a C problem?
10:17:15 <EvanR> 120 characters or bytes
10:17:24 <EvanR> or (yet another possibility) char :)
10:17:45 <erisco> EvanR, reading and processing files incrementally is at the heart of Programming Pearls and was especially relevant in the era of C
10:18:00 <erisco> what with tape drives and limited memories and so forth
10:18:13 <EvanR> its still relevant
10:19:08 <EvanR> "in the era of limited memory" :)
10:19:20 <EvanR> so primitive
10:19:31 <erisco> an eon ago
10:19:56 <tabaqui> is "evaluate pureFunction" interruptible?
10:19:56 <RedMachine> What do you guys use Haskell for?
10:20:15 <tabaqui> I do not see this in https://hackage.haskell.org/package/base-4.10.0.0/docs/Control-Exception.html#interruptible
10:20:20 <EvanR> i just did my taxes with it
10:20:26 <tabaqui> but test shows that it is trully
10:21:05 <tabaqui> ah, "everything from Control.Exception except for throwTo", ok
10:21:42 <RedMachine> That's pretty cool. I am considering learning it.
10:21:47 <erisco> I use Haskell to compute stuff
10:22:25 <EvanR> i have some videos of haskell doing stuff
10:22:26 <RedMachine> I'd never consider COMPUTING stuff with a computer. 
10:22:43 <EvanR> like 3D life, playing music
10:22:52 <erisco> well I recommend it… it is rather thrilling to run a program
10:23:21 <erisco> the CPU warms up and the fans rev up, and your electrical bill goes up :)
10:25:39 <tabaqui> why Ctrl-C interrupts masked actions?
10:26:39 <tabaqui> like "mask $ evaluate $ factorial 100000"
10:26:58 <tabaqui> *mask (\_ -> evaluate $ factorial 100000)
10:27:17 <jle`> is there a Maybe in python
10:27:29 <jle`> i don't need the monad instance
10:27:34 <jle`> just the Foldable one
10:28:03 <tabaqui> python has OOP, so you can write it by yourself
10:28:30 <EvanR> good question what control C is doing in ghci
10:28:30 <jle`> indeed
10:28:34 <jle`> but i'm writing a one-off script
10:28:46 <jle`> meh i'm just going to use a list and only ever use the first item
10:28:49 <jle`> quotient types ftw
10:28:56 <tabaqui> EvanR: I've asked this before and someone asked that it sends Exception to the main thread
10:28:59 <EvanR> agreed
10:29:02 <Jacoby6000> quotient types?
10:29:03 <tabaqui> *answered
10:29:13 <EvanR> [] and [x]
10:29:20 <erisco> two lists are equal if their head is equal, or they are both empty, I presume
10:29:46 <EvanR> its a subset type
10:30:32 <jle`> not quite subset, but squashing all [x,...] etc's and treating them identically as just [x]
10:31:16 <jle`> er, not actually squashing, but making them all effectively identical
10:31:43 <jle`> using them in a careful way...such that it's just as if they were [x] ...
10:31:53 <jle`> i kind of stumbled all over that explanation
10:32:45 <EvanR> why would you even have lists of length > 1
10:33:01 <EvanR> if you are dealing with maybe-like stuff
10:33:02 <tabaqui> oh, damn
10:33:14 <tabaqui> sec, I'll post it
10:33:15 <EvanR> tabaqui: masking stuff can be interrupted
10:33:23 <EvanR> theres uninterruptibleMask
10:33:33 <tabaqui> there is some weird stuff with exceptions and masks
10:33:37 <EvanR> (certain things can be interrupted from inside a mask)
10:33:45 <jle`> EvanR: i'm basically doing something like Writer (First a)
10:34:09 <jle`> multiple Just's might be told, but only the first one is relevant
10:34:28 <jle`> and if any Just was told at all at the end of the program, do something with its contents
10:34:40 <EvanR> so the combiner for that would be, x <> y = if x is empty then y else x
10:34:58 <EvanR> youll only ever have [] or [x]
10:35:28 <EvanR> poor mans First
10:37:02 <jle`> yes but i'm too lazy to define a new function
10:37:05 <jle`> so i'm using append
10:37:07 <jle`> hehe
10:39:08 <tabaqui> https://pastebin.com/rgR24Zpy
10:39:22 <tabaqui> if you try to interrupt it with ctrl-c
10:39:34 <tabaqui> then masked version will be terminated after second try
10:39:53 <tabaqui> while not masked will caught it and report
10:41:47 <tabaqui> *uninterruptibleMask can will be terminated too
10:42:17 <haskellnoob> my learning is so slow :(
10:44:28 <EvanR> then uninterruptibleMask is false advertising on the tin
10:46:37 <jle`> haskellnoob: compared to what? :O
10:47:10 <haskellnoob> jle`:  how many days it took you to learn haskell I am already spent 4 days and still stuck with type declarations
10:47:35 <jle`> it took me a few months
10:47:40 <jle`> to get through the basics
10:47:50 <jle`> a year or so to be comfortable at an intermediate level
10:47:55 <Psybur> haskellnoob, it can take years to really master a language heh dont give up after 4 days. Ive been going at it for a few months and I barely have the basics down heh
10:47:56 <jle`> four years later, i've never looked back :)
10:48:07 <jle`> haskellnoob: do you know any other programming languages besides haskell?
10:48:48 <jle`> (also, you do realize that schools dedicate an entire semester to learning just haskell sometimes, right?  can you imagine learning a semester's worth of material in 4 days?)
10:49:20 <haskellnoob> and yoiu think I am young?
10:49:23 <jle`> if you do know any other languages, try to remember how long it took you to learn that language and to be comfortable with it
10:49:34 <haskellnoob> Nope
10:49:34 <jle`> i don't make any assumption about your age :)
10:49:39 <haskellnoob> haskell only language
10:49:50 <jle`> ah, okay.  then this is normal for all languages, all programming
10:50:01 <haskellnoob> because you say about school and I studied school long back say 20 years back
10:50:02 <jle`> many schools ease students into programming over the course of a year or two
10:50:19 <tabaqui> EvanR: I want to open real discussion somewhere, but not sure is it a bug or a feature
10:50:22 <Psybur> haskellnoob, what got you into programming? And what led you to haskell?
10:50:22 <jle`> yeah, i'm just bringing up school to give you a sense of a reasonable timetable/time scale for learning a language
10:50:27 <tabaqui> when can I open a topic?
10:50:28 <haskellnoob> and never studied programming in school
10:50:43 <haskellnoob> Okayy
10:50:49 <jle`> if your goal is to learn a programming language in a week or a month, you're setting yourself up for disappointment
10:51:05 <haskellnoob> jle`:  no not really a week or month
10:51:08 <jle`> but if you adjust your expectations, you'll have a lot of fun :)
10:51:36 <haskellnoob> may be by end of my life I should master any programming language
10:51:50 <Psybur> master it to do what, though?
10:52:02 <haskellnoob> but I see so many kids/ytounsters on internet twitter doing a great things
10:52:10 <haskellnoob> so I am afrauid am I too slow
10:52:26 <liste> haskellnoob: http://www.norvig.com/21-days.html
10:53:03 <liste> "fast" often means "superficial understanding"
10:54:33 <EvanR> tabaqui: maybe ask in #ghc
10:55:06 <haskellnoob> liste:  true but that author dont know this modern age ...where people are competiting with robots and artificial intelligence and when 40 years old farmer wants to learn programming how can he not want to race seeing the world around
10:55:33 <lyxia> tabaqui: that may be a feature of your shell
10:56:03 <lyxia> or maybe the runtime is doing something funny
10:56:06 <lyxia> https://stackoverflow.com/questions/2349233/catching-control-c-exception-in-ghc-haskell/7941166#7941166
10:57:31 <liste> haskellnoob: human learning hasn't changed in the last decades
10:57:54 <liste> haskellnoob: if you want to actually understand something, you need to learn. and that takes time
10:58:23 <haskellnoob> may be true and agreed
10:58:26 <tabaqui> lyxia: I noticed second Ctrl-C thing before
10:58:42 <tabaqui> I think that here is another case
10:58:55 <Psybur> haskellnoob, what great things do you see people doing on twitter that you want to do?
10:59:31 <haskellnoob> Psybur:  They post many things and github repos etc which I never have
11:00:09 <Psybur> haskellnoob, but why do their github repos impress you? You can make a repo filled with a repeated character.
11:00:41 <Psybur> Fill it with garbage. And there you have a repo ;p
11:01:05 <haskellnoob> Psybur:  not like that 
11:01:18 <haskellnoob> Something which is new and innovative
11:02:09 <MarcelineVQ> if that's your goal then you should come up with the new and innovative idea first and then find the language that it makes sense to make it in
11:02:28 <haskellnoob> When I search with haskell on github this is firsst https://github.com/tensorflow/haskell
11:02:37 <Psybur> haskellnoob, the point Im trying to make is maybe you shouldn't be focusing on studying programming language as an end to being like those people you admire. You arent admiring their coding abilities, youre admiring their creativity. They are using programming as a means to and end.
11:02:40 <haskellnoob> MarcelineVQ:  so I find haskell
11:03:34 <haskellnoob> https://github.com/exercism/haskell second
11:03:41 <haskellnoob> both I didnt understand what are they
11:04:29 <Psybur> haskellnoob, I dont think the person who invented tensorflow started out trying to invent tensorflow. They were probably trying to solve general machine learning problem and ended up making a framework to help solve their initial problem.
11:04:47 <Psybur> Id wager thats the way it is for most things out there
11:05:30 <haskellnoob> Psybur:  what you are saying I am not understyanding , I should not focus on building git projects?
11:06:02 <Psybur> haskellnoob, no. You should focus on solving problems. If keeping track of source code in a git repo helps you do that, then thats great
11:06:50 <haskellnoob> Psybur:  to be honest I dont have any problems 
11:06:59 <Psybur> haskellnoob, do you use any software you think could be better?
11:07:00 <haskellnoob> I am just interested on new technologies
11:07:15 <Psybur> Try making a better version of some software you use. Like your IRC client
11:08:01 <Psybur> Or make an algorithmic trader and get rich off the stock market :P
11:08:31 <Psybur> I made an algotrader and backtesting framework in haskell. Its not doing so well but I learned a lot :D
11:08:37 <haskellnoob> I dont know algorithms, I heard some algorithm book by kuhn it is very huge after haskell I will read it
11:09:01 <haskellnoob> what is that ?
11:09:05 <haskellnoob> Can you show me?
11:09:21 <Psybur> Algorithmic trader. Analyzes price action, decides to buy or sell
11:09:38 <Psybur> haskellnoob, https://github.com/jrciii/money-machine
11:09:58 <tabaqui> lyxia: yeah, it is a second Ctrl-C feature, indeed
11:10:15 <lyxia> tabaqui: As suggested by the SO answer, the GHC runtime has this handler which behaves differently on the second Ctl-C https://github.com/ghc/ghc/blob/master/rts/posix/Signals.c#L521
11:10:52 <Psybur> It uses a generic Strategy record to plug into the backtest or the practice framework
11:11:12 <Psybur> I have a ClusterStrategy I have been working on (that hasnt been doing too well heh) in there
11:11:18 <haskellnoob> ok
11:11:36 <haskellnoob> i am not understanding that git anyway, I will check it out after some days
11:12:09 <Psybur> But if you arent familiar with this domain of trading it probably wont help you :D
11:12:21 <ph88_> how can i model a register map in haskell ?
11:12:54 <lyxia> ph88_: What's that
11:13:22 <ph88_> https://en.wikipedia.org/wiki/Memory_map
11:13:58 <mnoonan> ph88_: data Regs = Regs { rax :: Word32, rbx :: Word32, ... }?
11:14:05 <mnoonan> *64, but w/e
11:14:33 <ph88_> i have registers of arbitrary size, not just 32 bits
11:14:36 <ph88_> often just 1 bit
11:14:48 <Tuplanolla> The answer is always lenses, ph88_.
11:15:14 <ph88_> and i also have register overlapping and interleaving and aliasing
11:15:30 <mnoonan> ah, in that case.. ++Tuplanolla
11:15:34 <Tuplanolla> You can have a bunch of `Word64` and view the bits as you wish.
11:16:04 <Tuplanolla> The kind of bunch depends on your access patterns.
11:16:08 <ph88_> but the memory map has a lot of dead space
11:16:22 <Tuplanolla> Then it's a sparse bunch.
11:16:28 <ph88_> a what ?
11:16:44 <Tuplanolla> Like a sparse matrix, but without the matrix bit.
11:17:05 <ph88_> don't know what that is a sparse matrix ^^
11:18:42 <ph88_> hhmmm seems to be a matrix with a lot of zeros
11:18:52 <ph88_> but do those 0s occupy memory on my computer ?
11:21:18 <ph88_> worse case would be that i have a register of 1 bit that i need to store in a byte on my PC. And then i have 32 of those per address. So 8 bits * 32. And then i have a 32 bits address space. So 2^32 * 8 * 32 = 1 TB of RAM memory needed
11:22:09 <ph88_> ^_____^
11:22:52 <lyxia> If you use a dumb representation like that, yes you will eat all your memory.
11:23:04 <ph88_> ye i need something smarter :P
11:23:17 <ph88_> i mean what if 2 registers point to the same memory location ?
11:23:23 <lyxia> Well you can use a Map Address Byte
11:23:35 <lyxia> and if an address is not in the Map that means it's 0
11:24:04 <Zemyla> You know, I really like the idea of changing the signature of sortBy from (a -> a -> Ordering) -> [a] -> [a] to Traversable t => (a -> a -> Ordering) -> t a -> t a.
11:24:24 <ph88_> Zemyla, take a look at foundation ^____^
11:24:42 <Zemyla> Because not only is it more general, but it also proves that the sorted list will have the same number of elements as the original.
11:24:56 <ph88_> lyxia, you mean a haskell Map ?
11:25:01 <lyxia> yes
11:25:26 <ph88_> why a Map and not a Set ?
11:25:54 <Zemyla> ph88_: foundation?
11:26:55 <ph88_> Zemyla, https://github.com/haskell-foundation/foundation
11:27:41 <lyxia> ph88_: How would that work
11:28:07 <ph88_> sortBy :: (Element c -> Element c -> Ordering) -> c -> c
11:28:49 <lyxia> ph88_: Memory is naturally a map/function from addresses to bytes, that's why I use Map.
11:29:24 <ph88_> lyxia, i read in learn you a haskell  The Data.Set module offers us, well, sets. Like sets from mathematics. Sets are kind of like a cross between lists and maps. All the elements in a set are unique.  
11:29:33 <ph88_> so because i have unique addresses i though maybe use a Set ?
11:30:30 <orion> Has anyone used TypeApplications enough to have an opinion on how useful they are?
11:30:49 <ph88_> but i'm not sure if i let each address hold it's registers (because of bitmask there can be multiple) or that i let each register hold it's addresses (because of big registers can span multiple addresses)
11:31:04 <ph88_> orion, no, but sounds interesting :P
11:31:43 <Tuplanolla> I used them a bit and found them extremely annoying to work with, orion.
11:38:27 <johnw> orion: I use them often, and they are very useful
11:45:22 <cengchuhan> [x | x <- [1..20], even x]
11:45:39 <cengchuhan> where is lambda bot?
11:46:08 <lyxia> > [x | x <- [1..20], even x]
11:46:10 <lambdabot>  [2,4,6,8,10,12,14,16,18,20]
11:46:52 <cengchuhan> > [x | x <- [1..20], even x]
11:46:54 <lambdabot>  [2,4,6,8,10,12,14,16,18,20]
11:47:02 <cengchuhan> thanks!
11:51:51 <dgonyeo> I think arch may have broken my haskell install? When I try to "cabal install xmonad" I get "Could not find module 'Prelude'"
11:51:56 <dgonyeo> anyone know how to fix this?
11:52:19 <dgonyeo> 'stack install xmonad' also breaks on the linker with a recommendation to recompile with -fPIC
11:54:15 <MarcelineVQ> if you just want xmonad, arch has an xmonad community package you can install, if you'd like to fix your ghc gimme a sec and I'll let you know the steps that worked for me
11:54:24 <MarcelineVQ> *your stack installed ghc
11:55:18 <dgonyeo> I'd like to know how to fix it
11:55:24 <dgonyeo> although my xmonad comes in via pacman
11:55:33 <dgonyeo> xmonad --recompile says it can't find the XMonad package
11:55:40 <dgonyeo> so I'm assuming it's the same problem
11:56:33 <MarcelineVQ> idk about that specifically, I've never used xmonad. to get around my stack ghc problem I had to install from the AUR  ncurses5-compat-libs  and also add   ghc-build: nopie    to my .stack/config.yaml
11:57:26 <MarcelineVQ> then you'd want to run  stack setup --reinstall  just to make sure things are fresh
12:00:07 <dgonyeo> cool, I'll give that a shot, thanks
12:02:55 <tdammers> I usually install xmonad with cabal
12:03:08 <tdammers> even though I use stack for most other stuff
12:18:04 <nicknight> Hi porting scikit to haskell is a Huge project ?/
12:20:25 <Psybur> nicknight, Id imagine so
12:21:12 <nicknight> Psybur: for a expert programmer will it take years?
12:21:49 <Psybur> Depends on how much time that expert programmer has to spend on it :P
12:22:01 <nicknight> If Someone make a library similar to scikit learn can he earn anything?
12:22:11 <nicknight> earn for living
12:22:38 <Psybur> Do you mean earn something off of the library? Or general earning potential?
12:22:57 <nicknight> library should be opensource but for his living
12:23:39 <nicknight> if he spend full time on it , how he will be able to make earning?
12:23:46 <Spike_> Hey guys... Could anyone possibly assist me with a basic recursive function call issue?
12:23:47 <tdammers> there are a few viable profit models for open source work, but for most people, some sort of employment is a better bet
12:23:58 <tdammers> Spike_: don't ask to ask, just ask
12:24:06 <Psybur> nicknight, so you mean working on scikit outside of work hours?
12:24:53 <nicknight> Psybur:  No say I will work on it full time 16/18 hours a day 
12:24:58 <Spike_> I'm having a go at Conway's Game of Life and almost done, although when i call the function recursively and try take a few elements from the result it just jams up
12:25:03 <int-index> How would I implement pointer comparison of two boxed values? I don't want StablePtr because it pins memory.
12:25:14 <tdammers> @where lpaste
12:25:14 <lambdabot> http://lpaste.net/
12:25:17 <tdammers> ^ Spike
12:25:26 <tdammers> paste your code and I'll take a look
12:26:07 <int-index> Basically, the idea is that I have an expensive (==) and as an optimization I'd like to first check whether it's the same object
12:26:22 <dgonyeo> using the xmonad compiled with stack I'm still getting "Could not find module ‘Prelude’" when I run xmonad --recompile :/
12:26:25 <Tuplanolla> How about you hash it instead, int-index?
12:26:31 <codedmart> dmj`: I just want to be sure I am not  missing anything. Is your stripe package missing bank account?
12:26:36 <Psybur> nicknight how many lines of code is in scikitlearn main source?
12:26:46 <int-index> Tuplanolla, to incur the cost of hashing as well? Pointer comparison is really quick
12:26:56 <Spike_> ^ tdammers http://lpaste.net/476823197572923392
12:27:20 <nicknight> Psybur:  why should I care ?
12:27:37 <nicknight> it doesnt relate to what I am asking
12:27:39 <nicknight> ok leave
12:27:41 <nicknight> this
12:28:14 <Psybur> Actually whats the character count? You could figure out the average characters a minute for a programmer. And then youd see how long it would take to write the code verbatim. Then say you would do it some factor slower due to learning process :D?
12:28:16 <nicknight> it got 961 contributors
12:29:26 <nicknight> ok I dont know why all haskell programmers just say haskell is great and you will get respect and never contribute to such projects 
12:29:27 <tdammers> Spike_: and which function is it that's giving you trouble?
12:30:01 <Tuplanolla> You hash once and that covers almost all your future comparison costs, int-index.
12:30:35 <Tuplanolla> If you somehow ended up in a situation where comparisons matter, this is the natural follow-up.
12:30:37 <erisco> johnw, why no release of z3cat to Hackage?
12:30:56 <Psybur> nicknight, interesting. Have any sources for that observation?
12:31:28 <ph88_> when i have a many-to-many relationship like in SQL, 1 customers can have many products and 1 products can be bought by many customers. What's a good datatype if i want to do the same in haskell (without SQL) and be able to lookup products per customer and customers per product ?
12:31:40 <EvanR> an indexed set
12:31:43 <johnw> erisco: in deference to a more general solution that is now part of 'concat' itself
12:32:07 <erisco> johnw, and what is concat? I am still exploring the work
12:32:12 <ph88_> EvanR, IxSet ?
12:32:20 <johnw> a library that z3cat depends on
12:32:25 <int-index> Tuplanolla, I appreciate the alternative solution you suggest, but pointer comparison sounds like something that I'd get for free from the fact that the values are boxed, rather than calculating a hash and storing it together with each object
12:32:26 <EvanR> the set is the (productId, customerId) pairs, and the two indexes are productId -> [customerId] and customerId -> [productId]
12:32:45 <EvanR> IxSet does implement this sort of thing, or you could do it with two Data.Maps
12:33:14 <ph88_> super cool !
12:33:31 <EvanR> or IntMaps if IDs are Ints
12:34:19 <tdammers> Spike_: I see
12:34:20 <ph88_> EvanR, what if i have a circular relation between 2 things? so now i have Customer (C) and Product (P)  C <-> P     but what if i add a 3rd   C <-> M <-> P <-> C  (start and ends back at C) ... M is just a random letter i put there
12:34:29 <EvanR> for the specific case of set of (a,b), you could call the structure a relation
12:34:33 <tdammers> Spike_: x = evaluate x doesn't do what you think it does
12:34:54 <EvanR> you have 3 relations?
12:34:55 <erisco> johnw, guess I was confused, because I found SMT.hs in the examples directory… I don't know how stack projects are organised, though
12:35:06 <EvanR> you can compose relations, that is just the inner join
12:35:50 <dmj`> codedmart: probably not
12:37:04 <EvanR> :t concatMap f . concatMap g . h
12:37:05 <lambdabot> error:
12:37:06 <lambdabot>     • Could not deduce (FromExpr [()]) arising from a use of ‘h’
12:37:06 <lambdabot>       from the context: (FromExpr [b], Show a)
12:37:14 <int-index> Tuplanolla, now that I think of it, hashes and pointers are different optimizations. A hash would make comparing different objects quicker (because their hash is different), but in case of the same hash I'd have to do the regular comparison (to handle hash collisions). OTOH pointers make comparing an object to itself quick, but in case of different pointers the regular comparison must be performed. Pointers + hashes sounds like a 
12:37:14 <int-index> killer combo, because then the actual comparison would be just for objects which have the same hash but different memory addresses (what are the chances?)
12:37:39 <Spike_> tdammers_ shouldn't x get set to the new evaluated value after it's been called?
12:38:17 <ph88_> EvanR, ah i can compose relations .. that's good !
12:38:23 <tdammers> Spike_: no. Variables don't work that way in Haskell. Once defined, a variable can never be set to a new value
12:38:38 <Tuplanolla> Experience also suggests that you hardly ever have to compare two identities of the same object, int-index.
12:38:47 <tdammers> Spike_: x = evaluate x defines x in term of itself - it's a recursive definition, and evaluating it never terminates and never produces anything
12:38:49 <erisco> conal, is ConCat published to Hackage, and I am just not seeing it, or at this time do I have to do a checkout from github?
12:39:30 <codedmart> dmj`: OK fair enough, just wanted to be sure I wasn't missing anything before I look into possibly adding it.
12:39:37 <codedmart> Thanks!
12:39:43 <tdammers> Spike_: what you want is a function that recursively composes some sort of IO action that produces visible output
12:39:43 <ph88_> EvanR, what about Bimap is that another good option to consider ?
12:40:01 <EvanR> bimap will only allow 1 to 1
12:40:10 <EvanR> unique indexes both ways
12:40:14 <Spike_> tdammer: yes i thought it would result in an infinite loop.. but also thought if I "head" for example on x because its lazy will only recurse once
12:40:21 <dmj`> codedmart: it might be able to be specified as an optional parameter. Check the typeclass instances for HasParam
12:40:37 <tdammers> Spike_: it never returns at all, so you can't take the head of it
12:40:39 <dmj`> For the respective endpoint
12:40:43 <Spike_> tdammer: that was my next step, but then where would i store it if the variable is forever immutable
12:41:00 <tdammers> Spike_: you want something like this: run grid = printGrid >> run (evaluate grid)
12:41:09 <ph88_> EvanR, i think i will give it a try with this package https://hackage.haskell.org/package/ixset-typed
12:41:21 <ph88_> thx for the information
12:41:32 <EvanR> i havent tried that one, but yeah ixset itself is based on typeable and is kind of weird for it
12:41:35 <tdammers> Spike_: it helps to evaluate things with pen and paper
12:41:43 <Spike_> tdammer: my implementation is problably the worst implementation ever, ive abstracting every section and building up from there..... im going to attempt that now
12:42:06 <sternmull> could someone explain why i need the type signature at the line with TODO? http://lpaste.net/359926
12:42:30 <tdammers> Spike_: nah, that's fine, you can't expect to write perfect idiomatic Haskell from day 1
12:42:43 <jle`> i just nerdsniped myself into trying to write insert for church encoded bst's
12:43:13 <tdammers> Spike_: there's a valuable lesson in here, about how evaluation works in Haskell. I suggest you wreck your brain a little bit more to understand this better
12:43:32 <int-index> Tuplanolla, hm, but hashing rules out types with custom Eq instances (where two different objects are considered the same, for instance 1 = 0.(9) but might have a different representation), whereas pointer comparison sounds like a 100% benign optimization (because (==) is reflexive)
12:43:44 <mnoonan> int-index: pointer comparison is kind of dodgy, because GC can move things around
12:43:49 <tdammers> > let infiniteOnes = 1 : infiniteOnes in take 5 infiniteOnes
12:43:51 <lambdabot>  [1,1,1,1,1]
12:43:56 <geekosaur> sternmull, the a defined there is dfferent from the one in the outer signature
12:43:57 <tdammers> ^ Spike_ look at this
12:44:02 <tdammers> Spike_: why does this work?
12:44:20 <int-index> mnoonan, yep, I thought about this. If it was a primitve operation then it'd be possible to ensure that everything is done in a single GC cycle
12:44:21 <tdammers> > let infiniteOnes = infiniteOnes ++ [1] in take 5 infiniteOnes
12:44:24 <lambdabot>  *Exception: <<loop>>
12:44:34 <mnoonan> int-index: I had a failing unit test that was trying to ensure two values were literally the same in memory, and it is a bit terrifying (and not super reliable)
12:44:36 <tdammers> Spike_: and why does this ^ not work?
12:45:16 <Tuplanolla> Consider `A` for which there is `instance Eq A where _ == _ = False`, int-index.
12:45:24 <tdammers> Spike_: grab some paper and a pen, and evaluate infiniteOnes in both examples, and you might gain some insights
12:45:27 <geekosaur> sternmull, https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#lexically-scoped-type-variables
12:45:30 <Tuplanolla> Your optimization is suddenly not benign anymore.
12:45:38 <EvanR> infiniteOnes = infiniteOnes ++ [1] ++ infiniteOnes
12:45:40 <codedmart> dmj`: Ah I see what you mean. BankAccount is in Types. I will work from there. Thanks again!
12:45:42 <int-index> Tuplanolla, I wouldn't consider this Eq instance lawful
12:45:44 <mnoonan> int-index: and hard to track down why the test started failing. it turned out to be due to GHC getting more clever with optimizations.
12:46:05 <int-index> Tuplanolla, fmap (f.g) = fmap f . fmap g isn't benign either for unlawful Functors
12:46:10 <sternmull> geekosaur: I thought the a from my function type signature would be identical to the return type and therefore would define the type that gets decoded.
12:46:18 <Spike_> tdammer: Aweomse, im going to do that now will give my understading of it
12:47:11 <mnoonan> int-index: anyway, can't you just add a lazy hash field and call it a day?
12:47:27 <geekosaur> sternmull, when you specify a type ascription like that, you are being explicit about the type. absent PartialTypeSignatures (which would still require a `_ =>`) you need to specify the full type
12:48:00 <int-index> mnoonan, well, I said above that hashing and pointer comparison cover different optimization routes. And pointer comparison is an atomic operation, so we wouldn't need to worry about GC moving stuff around if it was a GHC primitive.
12:48:03 <mnoonan> this also has the advantage of being stable from run to run.. i've had annoying bugs related to pointer-based comparisons and hashes in C++ before.
12:48:30 <tdammers> Spike_: oh, and if you want to ping me, write my full nick (tdammers, not tdammer), otherwise my IRC client won't highlight
12:48:45 <orion> How many years away is HAskell from having dependent types?
12:48:50 <EvanR> td<tab>
12:49:06 <jle`> orion: um, i think the current roadmap is ~2 ghc versions away
12:49:10 <jle`> so maybe 2 or so years?
12:49:12 <sternmull> geekosaur: I am not sure i understand that. Do you mean that my function signature only specifies a set of possible types?
12:49:13 <int-index> the idea is to do something like `a == b = ptrCmp a b || realCmp a b`, I don't think it would be unstable or that GHC would break it with optimizations
12:49:18 <geekosaur> I'd probably turn on ScopedTypeVariables, forall the outer a, and then it can be used in the inner type ascription without specifying the full constraint
12:49:35 <Jacoby6000> How can you introduce dependent typing in to a language that does not have dependent typing?  Doesn't it break backwards compat?
12:49:46 <int-index> Jacoby6000, behind a language extension
12:49:50 <jle`> Jacoby6000: language extensions :)
12:49:55 <Jacoby6000> well right
12:49:58 <geekosaur> sternmull, you defined a completely new 'a'. the one in the outer signature is not in scope there
12:50:01 <mnoonan> int-index: if you really want it, https://github.com/matt-noonan/justified-containers/blob/master/test/Data/Map/JustifiedSpec.hs#L149
12:50:04 <maerwald> Jacoby6000: you don't, you create a new language
12:50:04 <Jacoby6000> but code with dependent types couldn't safely use code without.
12:50:15 <jle`> not necessarily?
12:50:16 <tdammers> Jacoby6000: depends on the language, but either through a language extension, or by using previously unusued syntax
12:50:20 <mnoonan> int-index: (but I take no responsibility :)
12:50:22 <geekosaur> sternmull, read what I linked earlier https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#lexically-scoped-type-variables
12:50:38 <jle`> Jacoby6000: that's like saying code with {-# LANGUAGE ScopedTypeVariables #-} can't import code that doesn't use it
12:50:40 <EvanR> dependent haskell throws some assumptions about dependent types out the window
12:50:43 <mnoonan> int-index: I'm not quite clear on why I had to force the values first, but it turned out to be important.
12:50:53 <geekosaur> it is a common misconception that type variables scope inside definitions
12:50:58 <jle`> "how can you introduced scoped type variables into a language that does not have scoped type variables"
12:51:21 <jle`> ScopedTypeVariables breaks backwards compat
12:51:33 <int-index> mnoonan, ah, so I was looking for reallyUnsafePtrEquality#, thanks!
12:51:35 <jle`> but it only applies to source files that use the extension of course
12:51:52 <mnoonan> int-index: no problem, good luck :)
12:51:53 <sternmull> geekosaur: Yes, that is clear. And it is useful. But why do i need ScopedTypeVariables or the explicit inner signature at all? Isn't the decoded type identical to the returned type which is said to be Serialize in the function signature?
12:52:11 <tdammers> jle`: it *could* have been done differently, by introducing new syntax for scoped type variables that would be a syntax error in plain Haskell but introduce a type scope in Haskell-with-STV
12:52:12 <Jacoby6000> jle`: of course you _can_ use not-dependently-typed-things with dependently typed things.  I just meant, you don't get proofs with the not dependently typed stuff, which seems like a big problem.
12:52:20 <Spike_> tdammers: Mmm, im going to research the implementation of ":" now because i would have assumed it did the same as a concatination but just from the front of the list....
12:52:29 <jle`> tdammers: fair
12:52:30 <geekosaur> sternmull, my guess is decode has a constraint rather than an explicit Either
12:52:36 <tdammers> Spike_: it works with (++) too, if you prefer:
12:52:39 <geekosaur> Monad m => m a
12:52:42 <EvanR> Jacoby6000: the idea is you dont need to use DT for literally the whole system
12:52:48 <tdammers> > let infiniteOnes = [1] ++ infiniteOnes in take 5 infiniteOnes
12:52:50 <lambdabot>  [1,1,1,1,1]
12:52:58 <EvanR> the more you want to prove, the more work it takes
12:53:14 <Jacoby6000> EvanR: I've only ever thought of it in a way where you have to prove everything. So that just seems weird to me.
12:53:20 <geekosaur> so you are specifying to use Either, but you have to specify the whole type (or use TypeApplications and something like `decode @Either buf`)
12:53:27 <Psybur> > let infiniteOnes = 1 : infiniteOnes in take 5 infiniteOnes
12:53:29 <geekosaur> er, no, it'd have to be @(Either String)
12:53:29 <lambdabot>  [1,1,1,1,1]
12:53:33 <EvanR> Jacoby6000: not only that, there will not be any termination checking
12:53:48 <EvanR> so this will be more an experiment in using DT for programming and not for mathematics
12:53:51 <sternmull> geekosaur: It is "decode :: Serialize a => B.ByteString -> Either String a".
12:54:08 <geekosaur> then no signature should be needed
12:54:12 <EvanR> if you read the paper on dependent haskell it will give a bunch of justifications for this
12:54:31 <dmj`> codedmart: cheers
12:54:38 <Spike_> tdammers: I think i know why! :P when im appending from the front it creates the new list from [1] but when i try add it from the back its take the original list and is infinite? am i on  the right track?
12:54:38 <geekosaur> but if you specify one, it has to match
12:55:00 <tdammers> Spike_: not quite. It always creates a new list, but that's an implementation detail.
12:55:19 <mnoonan> int-index: there is also the change that you are comparing X and Y, which are not the same, and the pointer comparison spans a GC, during which Y is placed where X used to be. I *think* this is possible, so you can get both false positives and false negatives from `isLiterally`
12:55:22 <mnoonan> *chance
12:55:43 <tdammers> Spike_: you can often evaluate Haskell expressions by simply replacing things with their definition
12:55:44 <ElCuy> Hey everyone, has anyone completed cis194 from UPenn? Specifically I'm in need of clues for solving homework 2 / question 6, which is optional. Anyone has any clue?
12:55:54 <tdammers> infiniteOnes = 1 : infiniteOnes
12:55:57 <EvanR> Spike_: in the not-working case, there is no list
12:56:04 <Spike_> tdammers: doing it on paper right now step by step
12:56:11 <int-index> How do I get false positives? Assuming reallyUnsafePtrEquality# is atomic, it happens either before GC moves stuff around or after
12:56:16 <EvanR> no original list
12:56:17 <tdammers> so we can plug the definition of infiniteOnes into the RHS:
12:56:26 <tdammers> infiniteOnes = 1 : (1 : infiniteOnes)
12:56:33 <tdammers> and then we keep doing that
12:56:41 <tdammers> infiniteOnes = 1 : (1 : (1 : infiniteOnes))
12:56:46 <tdammers> infiniteOnes = 1 : (1 : (1 : (1 : infiniteOnes)))
12:56:51 <sternmull> is there some nice summary of type signatures and constraints and all that stuff? I frequently hit their limits without seeing them.
12:56:51 <tdammers> etc. etc. ad infinitum
12:56:57 <Spike_> tdammers: yes similar to what im trying to do now with the eval function?
12:57:10 <tdammers> yes, kind of
12:57:21 <tdammers> but, here's the thing
12:57:55 <tdammers> Haskell is a non-strict language, which means that things only get evaluated far enough to get what the caller needs
12:58:39 <tdammers> so if you want Haskell to take the first 5 elements of infiniteOnes, it is enough to evaluate up to 1 : (1 : (1 : (1 : (1 : infiniteOnes))))
12:58:48 <tdammers> because from there, we can already extract 5 elements
12:59:09 <tdammers> but now consider the other implementation of infiniteOnes: infiniteOnes = infiniteOnes ++ [1]
12:59:32 <tdammers> in order to take the first 5 elements of that, we have to keep evaluating until we get something for which the first 5 elements are known
12:59:43 <tdammers> infiniteOnes = infiniteOnes ++ [1]
12:59:50 <tdammers> infiniteOnes = (infiniteOnes ++ [1]) ++ [1]
13:00:00 <tdammers> infiniteOnes = ((infiniteOnes ++ [1]) ++ [1]) ++ [1]
13:00:06 <tdammers> oh dear, we're not making progress
13:00:24 <EvanR> you cant ever get the first thing much less 5
13:00:25 <tdammers> we always have that unevaluated bit at the beginning of our list
13:00:44 <tdammers> no matter how deeply we evaluate, this fact never changed
13:01:06 <tdammers> even if we keep evaluating this until the end of days, we still don't know the first element
13:01:13 <EvanR> (looks like a perfectly working list of 1s backwards :)
13:01:43 <tdammers> EvanR: yes, except it's worse, because we can't even append anything, because we don't know where the end of the list we want to append to is
13:02:04 <tdammers> so all those ++ [1] get stashed away until we can apply them, which is never
13:02:06 <Spike_> tdammers: i think im getting you... give me 2 minutes to digest
13:02:36 <EvanR> the [1,1,1] notation makes me feel like there is a symmetry
13:02:45 <EvanR> which there unfortunately isnt
13:02:51 <tdammers> Spike_: sure, let it sink in... 2 minutes would be super quick actually
13:03:08 <EvanR> 1:1:1:[] = 1:(1:(1:[]))
13:03:14 <EvanR> lop sided
13:03:50 <tdammers> list syntax is a remnant of the dark ages :)
13:04:11 <Spike_> :tdammers: well since ++ concats to the end of the list, we need to iterate through each elements from the head of the list, but in the first implementation we never have to iterate through the list at all
13:05:17 <EvanR> you never *have* to iterate through a list for its own sake, and thinking of ++ as doing anything at all in isolation can be misleading
13:05:58 <tdammers> indeed... try to stop thinking in terms of "what happens", and think in terms of "what do I have, what do I want, and how can I figure out the thing I want from the things I have"
13:06:03 <Spike_> EvanR: but in the second implentation where we lst ++ [1] is has to right?
13:06:17 <EvanR> not unless you try to look at the first element
13:06:46 <EvanR> if you do, then some (but not nec all) of ++ must "happen"
13:07:12 <tdammers> Spike_: iteration only "happens" when the values being iterated over are demanded
13:07:23 <tdammers> Spike_: that is why we can take the first element of an infinite list
13:07:35 <tdammers> > head [1..]
13:07:36 <lambdabot>  1
13:07:46 <Spike_> tdammers: That's the one thing i've still been trying to get my head around in functional, the not "how" but "what" concept! it's hard to wrap my head around, imperative thinking has broken me
13:07:47 <tdammers> and likewise:
13:07:58 <EvanR> its like quantum physics, when the real world observer probes the result, part of the system takes a stand and irreversible stuff happens
13:07:59 <tdammers> > head ([1..] ++ [5])
13:08:01 <lambdabot>  1
13:08:12 <Spike_> But then howcome this doesn't work: let infiniteOnes = infiniteOnes ++ [1] in take 5 infiniteOnes
13:08:32 <geekosaur> because the first thing it does is expand infiniteOnes, which requires it to expand infiniteOnes, which ...
13:08:42 <geekosaur> it never reaches a constructor/"value"
13:08:45 <tdammers> Spike_: OK, so given just the definition of infiniteOnes, what steps can you perform to figure out the first element of infiniteOnes?
13:08:47 <Spike_> because then in theory shouldn't it concat the list and then provide us the 5 results
13:08:58 <monochrom> Whose theory?
13:09:09 <EvanR> concat what list...
13:09:14 <tdammers> Spike_: look at the [1..] ++ [5] example I just gave you
13:09:29 <EvanR> the meaning of infiniteOnes up there is not an actual list
13:09:29 <tdammers> Spike_: that one works - why? Because it doesn't actually "perform" the concatenation
13:10:03 <monochrom> We have lazy evaluation but lazy evaluation does not mean "anything goes".
13:10:03 <tdammers> Spike_: and likewise in infiniteOnes ++ [1], the (++) part is actually a red herring, because the concatenation there can never possibly happen at all
13:10:12 <tdammers> so let's go back
13:10:20 <tdammers> head ([1..] ++ [5])
13:10:44 <tdammers> in order to evaluate that, you have to figure out what the first element of [1..] ++ [5] is
13:10:52 <dsal> > head ([1..] ++ ["five"])
13:10:54 <lambdabot>  error:
13:10:54 <lambdabot>      • No instance for (Enum [Char])
13:10:54 <lambdabot>          arising from the arithmetic sequence ‘1 .. ’
13:11:16 <dsal> Heh, that kind of hurts my head.
13:11:22 <dsal> This can't happen, but if it could, it'd be wrong.
13:11:27 <Spike_> Well i understand the [1..] ++ [5] never ever needs perform the whole operation on the infinite list because we just requesting the head.
13:11:43 <tdammers> (++) can be thought of as "give me elements from the LHS list, until you reach the end of that list, then give me elements from the RHS list, until you reach the end of that
13:11:55 <tdammers> but we only ask for one element, and the LHS list can give us that one element
13:12:00 <EvanR> expand the ++ expression once
13:12:06 <EvanR> @src (++)
13:12:06 <lambdabot> []     ++ ys = ys
13:12:06 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
13:12:06 <lambdabot> -- OR
13:12:06 <lambdabot> xs ++ ys = foldr (:) ys xs
13:12:11 <monochrom> Yeah I don't think (non-bottom infinite list)++[5] illustrates the point.
13:12:38 <tdammers> ^ source code for (++) is actually helpful
13:12:38 <monochrom> With "x = x ++ [5]" what we have is bottom++[5] so it's another story.
13:12:52 <Spike_> yes i think im understanding, so when the i try add to the end of the list it needs to know the LHS
13:13:01 <EvanR> [1..] ++ [5] = 1 : ([2..] ++ [5])
13:13:08 <EvanR> now head will work
13:13:13 <monochrom> (++) absolutely wants to evaluate its left operand. "x = x++[5]" is an infinite loop.
13:13:13 <tdammers> no, the concatenation isn't the problem
13:13:28 <tdammers> infiniteList = infiniteList -- this fails just as badly
13:13:56 <tdammers> infiniteList = reverse infiniteList -- this too
13:14:23 <EvanR> :t fix reverse
13:14:24 <lambdabot> [a]
13:14:36 <monochrom> For that matter "y = y && False" is an infinite loop too because (&&) wants to evaluate its left operand. Compare with "z = False && z".
13:14:53 <EvanR> > let z = False && z in z
13:14:55 <lambdabot>  False
13:15:02 <EvanR> cool
13:15:10 <Spike_> So just to confirm I think im undestanding it like monochrom? is that correct
13:15:21 <monochrom> (&&) and (++) are assymetic in their strictness.
13:15:39 <dsal> > length . take 5 $ [undefined | x <- [1..]]
13:15:39 <EvanR> heh, z=False solves the equation
13:15:40 <lambdabot>  5
13:16:02 <EvanR> @src (&&)
13:16:02 <lambdabot> True  && x = x
13:16:02 <lambdabot> False && _ = False
13:16:16 <Psybur> > head `seq` ([1..] ++ [5])
13:16:18 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
13:16:29 <EvanR> well, system of equations
13:16:36 <tdammers> the (&&) example gets crystal clear once you look at the definition
13:16:43 <tdammers> @src (&&)
13:16:44 <lambdabot> True  && x = x
13:16:44 <lambdabot> False && _ = False
13:17:11 <EvanR> > let z = True && z in z
13:17:13 <lambdabot>  *Exception: <<loop>>
13:17:43 <tdammers> in order to pattern match on the first pattern, you have to evaluate the LHS; if it matches, then you can just return the RHS without further evaluation
13:18:16 <tdammers> in order to pattern match on the second pattern, you also have to evaluate the LHS; and if it matches, then you can just throw away the RHS because you're not using it at all
13:18:57 <mnoonan> ugh, trying to refactor this c++ template library is really driving home how bad duck typing is, independent from dynamic typing.
13:19:35 <EvanR> duck typing is coincidentally (?) close to duck taping
13:19:44 <monochrom> duct taping?
13:19:59 <dsal> > print =<< race (pure$length [1..]) (pure$length [1..9])
13:19:59 <geekosaur> 'duck tape' is a brand of duct tape hereabouts >.>
13:20:01 <lambdabot>  error:
13:20:01 <lambdabot>      Variable not in scope: race :: f0 Int -> f1 Int -> IO ()
13:20:04 <Spike_> :tdammers so its all got to do with the left associative evaluation
13:20:04 <dsal> boo
13:20:17 <monochrom> Oh the irony.
13:20:21 <monochrom> Or the pun, maybe.
13:20:22 <EvanR> https://target.scene7.com/is/image/Target/13799840?wid=1560&hei=1560&fmt=pjpeg
13:20:26 <tdammers> Spike_: yes and no. Actually closer to no than yes
13:20:30 <amateur_hour> I'm a little confused on how to do something in a brainf interpreter I'm writing to learn haskell
13:21:02 <tdammers> Spike_: as I said, the (++) is a red herring; what matters is that in order to get the first element from a ++ b, you have to evaluate a enough to tell what its first element is, or that it is empty
13:21:04 <EvanR> Spike_: associativity is about parsing not evaluation
13:21:08 <monochrom> Absolute no. "Left association" is from "infixl".
13:21:09 <tdammers> let's just try, shall we
13:21:18 <tdammers> we have infiniteOnes = infiniteOnes ++ [1]
13:21:22 <monochrom> In fact I think (&&) and (++) are infixr.
13:21:32 <tdammers> we want to get the first element, so we'll apply (++)
13:21:36 <tdammers> @src (++)
13:21:36 <lambdabot> []     ++ ys = ys
13:21:36 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
13:21:36 <lambdabot> -- OR
13:21:36 <lambdabot> xs ++ ys = foldr (:) ys xs
13:21:59 <EvanR> && ++ and : are right assoc
13:22:03 <tdammers> hmm, looks like we need to evaluate the LHS to tell if it matches [] or (x:xs)
13:22:28 <tdammers> OK, let's do that. infiniteOnes ++ [1], the LHS is infiniteOnes. Hey, we have the definition of that handy, let's plug it in:
13:22:28 <monochrom> But infixl and infixr are irrelevant until you write like "a && b && c".
13:22:52 <implementation_> > fix reverse :: String
13:22:54 <lambdabot>  "*Exception: <<loop>>
13:22:56 <tdammers> (infiniteOnes ++ [1]) ++ [1]
13:23:17 <tdammers> oh dear, looks like we have to start evaluating (++) again to figure this out
13:23:51 <tdammers> but we've been here before, haven't we
13:23:58 <Spike_> !! i think i get it.. we keep having to evaluate it ! 
13:24:06 <EvanR> implementation_: thats hilarious... magic information coming out of a bottom
13:24:06 <tdammers> YES
13:24:16 <tdammers> we keep evaluating it before ever reaching the first element
13:24:28 <Spike_> like we have to! theres no choice
13:24:29 <too_stupid_for_h> Hi everyone! I have a (maybe) quick question. I have a state monad which looks something like this: newtype Magic a = Magic {runMagic :: state -> Either (Maybe ErrMsg) a}. I was trying to run one monad depending on the result on the other monad.  My approach looked something like this: run m1 m2 = m1 >>= (\x-> case x of Right c -> return x; Left (Just a) -> m2 ) However it does not work :( Anyone sees my mistake? :)
13:24:47 <tdammers> Spike_: correct. It's the only thing we can do to figure out the first element.
13:24:55 <monochrom> too_stupid_for_h: Why is "state" in lower case? Is this even legal code?
13:25:02 <tdammers> Spike_: well, that, or realize that we're in an infinite loop, and complain about it
13:25:12 <Spike_> but we''ll never figure it out because we continouslty have to evaluate the original function
13:25:19 <tdammers> Spike_: which is what we see lambdabot do here: "Exception: <<loop>>"
13:25:22 <Spike_> well the new one i mean
13:25:26 <tdammers> yes
13:25:28 <EvanR> not only will you never figure it out, the answer doesn't exist
13:25:39 <too_stupid_for_h> Sorry, that was just a typo, in the actual code its upper cased
13:25:50 <tdammers> indeed, the answer is that there is no first element
13:26:05 <monochrom> This doesn't look like a state monad.
13:26:10 <tdammers> just like the other infiniteOnes implementation doesn't have a last element
13:26:25 <tdammers> > let infiniteOnes = 1 : infiniteOnes in last infiniteOnes
13:26:28 <implementation_> EvanR: there are pink fluffy unicorns on this planet, so let me believe in information coming out of bottom ;)
13:26:32 <lambdabot>  mueval: ExitFailure 1
13:26:36 <Spike_> Yes because we're still trying to evaluate the first element, and then we try again and again, but its infinite.. its like a valueless infinite loop
13:26:57 <too_stupid_for_h> Its a special Monad... I cant do anything about it. is similar to a state monad though
13:27:03 <tdammers> exactly. we keep digging deeper and deeper, but we're never getting anywhere
13:27:15 <tdammers> now let's do the same for infiniteOnes = 1 : infiniteOnes
13:27:17 <EvanR> to understand that one, its helpful to look at the code for last
13:27:24 <amateur_hour> suppose I have data ZipperList a = ZL [a] a [a], mainly being used with ZipperList Int, and I have a long serious of functions I wish to apply to transform this, some of which involve IO, what is the best way to handle this?
13:27:38 <tdammers> what's the first element of this infiniteOnes?
13:27:49 <amateur_hour> I'm very confused by the IO monad, and state monads in particular, so any pointers about where to start reading would be appreciated
13:27:51 <tdammers> @src
13:27:51 <lambdabot> src <id>. Display the implementation of a standard function
13:27:54 <Spike_> 1, it'll always be one
13:27:57 <tdammers> @src head
13:27:57 <lambdabot> head (x:_) = x
13:27:57 <lambdabot> head []    = error "Prelude.head: empty list"
13:28:06 <tdammers> so can we pattern match infiniteOnes on either of these?
13:28:12 <tdammers> not yet
13:28:25 <tdammers> but we can perform one evaluation step, namely plug in the definition of infiniteOnes
13:28:30 <tdammers> which is 1 : infiniteOnes
13:28:36 <tdammers> can we pattern match head on that?
13:28:45 <tdammers> YES! Yes we can! It matches (x:_)
13:28:52 <Spike_> yes :)
13:29:06 <Spike_> makes sense!!
13:29:19 <implementation_> > fix time_paradox
13:29:21 <lambdabot>  "DOCTOR!"
13:29:37 <EvanR> :t fix
13:29:38 <lambdabot> (a -> a) -> a
13:29:59 <implementation_> see, fix can really fix things
13:30:01 <EvanR> :t time_paradox
13:30:02 <lambdabot> p -> [Char]
13:30:07 <EvanR> lol
13:30:42 <Spike_> Thank you all and especially tdammers, i do feel like i understand it a little better... let me see if i can re-work my original problme keeping this in mind
13:32:08 <tdammers> Spike_: well, have fun! I'm about to go afk, but I'm sure you'll still get quality help here ;)
13:32:49 <EvanR> laziness reigns
13:33:33 <Spike_> tdammers: thank you very much! You're a legened for assisting, have an awesome evening
13:34:57 <amateur_hour> any advice for my problem? Applying a series of functions to initial data, some of which require IO.
13:35:24 <amateur_hour> it seems to me like a fold (>>=) would alleviate some of the problems, but some functions are pure and some IO
13:35:55 <liste> amateur_hour: fmap the pure functions
13:36:22 <amateur_hour> that would reduce the list of functions to just the impure IO functions right?
13:36:49 <amateur_hour> just a list of impure functions*
13:37:17 <amateur_hour> which then a fold of (>>=) would turn into a single function applied to an IO Type
13:37:19 <liste> :t fmap (+5) :: IO Int -> IO Int
13:37:20 <lambdabot> IO Int -> IO Int
13:37:34 <liste> though I guess you want Int -> IO Int?
13:37:44 <liste> > return . (+5)
13:37:46 <lambdabot>  error:
13:37:46 <lambdabot>      • No instance for (Typeable m0)
13:37:46 <lambdabot>          arising from a use of ‘show_M662188577208867179223963’
13:37:48 <liste> :t return . (+5)
13:37:49 <lambdabot> (Num a, Monad m) => a -> m a
13:38:04 <liste> :t (pure . (+5)) :: Int -> IO Int
13:38:05 <lambdabot> Int -> IO Int
13:38:59 <amateur_hour> okay, so starting with the list of functions, first simplify by fmapping pure functions over the nearest IO one
13:39:12 <amateur_hour> then fold over the impure ones with bind
13:39:27 <amateur_hour> does that sound like a reasonable strategy?
13:39:38 <monochrom> too_stupid_for_h: What does "doesn't work" mean?
13:39:43 <mnoonan> well wait, first of all you aren't going to have a list with both pure and impure functions in it, because they have different types
13:39:56 <amateur_hour> I was going to abstract that with a data type
13:40:02 <amateur_hour> maybe incorrectly...
13:40:06 <amateur_hour> (I'm a beginner)
13:40:19 <EvanR> all functions are pure. the important distinction is whether its an IO a, X -> IO a, or not
13:40:20 <mnoonan> data Fun a = Pure (a -> a) | Impure (a -> IO a)
13:40:30 <mnoonan> something like that?
13:40:33 <amateur_hour> yeah something like that
13:41:00 <mnoonan> ok, then you can do "runFun :: Fun a -> IO a" by runFun (Pure f) = return . f and runFun (Impure f) = f
13:41:02 <too_stupid_for_h> The pattern does not match. I get the error:    • Couldn't match expected type ‘a’  with actual type ‘Either (Maybe t0) t1’
13:41:05 <EvanR> you can probably skip that step and upgrade everything to the same type
13:41:12 <liste> :t (pure .) -- amateur_hour you may need to use this instead of fmap
13:41:13 <lambdabot> Applicative f => (a1 -> a2) -> a1 -> f a2
13:41:39 <amateur_hour> EvanR: do you mean to take my functions a -> a and slap a return at the end to change to a -> IO a for all?
13:41:44 <EvanR> yes
13:41:47 <mnoonan> oops, runFun :: Fun a -> (a -> IO a)
13:41:48 <liste> amateur_hour: but otherwise sounds sensible
13:42:14 <liste> note that pure and return are the same thing
13:42:21 <liste> if you didn't know it already
13:42:37 <amateur_hour> ahh, I'd heard they were from compiler warnings about the typeclass hierarchies 
13:42:41 <monochrom> too_stupid_for_h: I think it should be obvious to you that when you write "m1 >>= \x -> ..." x has type "a" and not your Either or Maybe.
13:44:28 <monochrom> The Either and Maybe are already processed in >>=.
13:44:58 <amateur_hour> perhaps this is something that could be abstracted with a monad anyway, transforming the initial data seems suspiciously like state
13:45:05 <monochrom> It won't let the downstream "\x -> ..." see it.
13:45:08 <amateur_hour> another monad I mean
13:48:21 <monochrom> runFun can be eliminated by unifying everything on your list to a -> IO a
13:48:40 <monochrom> And so even Fun can be eliminated.
13:49:18 <monochrom> Unless you say "once in a while I have to count how many were pure functions originally"
13:49:57 <implementation_> @let repfix f x = let fx = f x in if x == fx then x else repfix f fx  -- is there a function like this somewhere in the standard libraries? i'm using this so often
13:49:58 <lambdabot>  Defined.
13:50:18 <implementation_> @repfix (*2) 1 :: Double -- usage example
13:50:19 <lambdabot> Unknown command, try @list
13:50:23 <implementation_> > repfix (*2) 1 :: Double -- usage example
13:50:25 <lambdabot>  Infinity
13:52:05 <monochrom> I think I can articulate how I think differently from other programmers.
13:53:00 <monochrom> Other programmers are thrilled with rules of thumb like "use state", "no don't use state", "use a list", "no don't use a list".
13:53:30 <monochrom> I don't care. I am thrilled with eliminating bureacracy in your code (or rather, my code).
13:54:08 <monochrom> And sometimes using state causes more bureacracy, sometimes less, it depends on the rest of the code and what the code's purpose is.
13:55:01 <monochrom> And also this is fairly correlated but not equivalent to code length.
13:55:21 <EvanR> bureaucracy-free oriented programming
13:55:40 <Tuplanolla> Skip the middle man and eliminate programmers directly, monochrom.
13:56:11 <monochrom> I don't think programmers are middle men. I do think managers are.
13:56:32 <too_stupid_for_h> Oh... You are right... makes sense. I cant think of a solution....
13:58:09 <monochrom> If run wants to know whether m1 gives you Left or Right, Just or Nothing, then perhaps run can't use >>=
14:07:39 <Zemyla> Ugh, why is it saying "Use FlexibleContexts to permit this" when I already have FlexibleContexts on?
14:08:30 <Zemyla> Oh, I misspelled "LANGUAGE" as "LANGAGUE".
14:08:37 <monochrom> haha
14:10:36 <conal> erisco: concat is just on github for now.
14:11:12 <erisco> conal, okay, thanks
14:11:41 <pierrot> when I do "import Data.Word8" ghci tells me "Could not find module ‘Data.Word8’". do I have to install it?
14:12:02 <monochrom> There is none. It's Data.Word
14:12:29 <geekosaur> data Word8 = GHC.Word.W8# GHC.Prim.Word# 	-- Defined in ‘GHC.Word’
14:12:51 <geekosaur> oh, that was less than helpful since it shows the original :(
14:12:54 <geekosaur> Data.Word, yes
14:14:13 <pierrot> I'm referring to this one: https://hackage.haskell.org/package/word8-0.1.3/docs/Data-Word8.html
14:14:44 <jcarpenter2> is there a way, using Stack, to enable profiling for a specific package?
14:14:50 <EvanR> Word8 is implemented with a full word, C programmers every cringing
14:15:08 <monochrom> Do you see the heading "Re-exporting"?
14:15:11 <jcarpenter2> i'm using library-profiling: false and executable-profiling: true but it still seems to be profiling packages other than the main one
14:15:54 <monochrom> It is just re-exporting Data.Word's Word8. So unless you also want the other functions there like isControl, you don't need word8.
14:16:06 <jcarpenter2> what i'd LIKE to do is inside "ghc-options" put "<my-package>: -prof -fprof-auto" but then I get this issue https://github.com/commercialhaskell/stack/issues/1015
14:16:10 <Tuplanolla> Speaking of constrained categories, my doctoral studies will involve something similar, but applied to physics instead of hardware design. Do you know if anyone else has worked on anything similar, conal?
14:16:25 <pierrot> I'd like isDigit and those ones
14:16:29 <jcarpenter2> (which is why i'm trying to use executable-profiling and library-profiling, which I don't really understand)
14:16:43 <conal> Tuplanolla: applied to physics how?
14:17:08 <sm> jcarpenter2: it'll need to build all deps with profiling
14:17:08 <conal> Tuplanolla: concat started out being for hardware but grew quite a bit
14:17:15 <Tuplanolla> Synthesizing and solving second-order boundary value problems, conal.
14:17:19 <pierrot> I could re-implement it but it wouldn't make sense since those functions are already written
14:17:23 <jcarpenter2> sm: but i want it to build all deps without profiling
14:17:37 <monochrom> I'm wondering why Data.Char's isDigit doesn't serve you. But OK if you want word8 you will have to install it yourself.
14:17:52 <sm> you can't profile your code without also building deps for profiling
14:18:07 <jcarpenter2> the problem is i'm running it with "+RTS -xc 2> error" to put errors into an "error" file, but i'm getting garbage errors from dependencies
14:18:19 <jcarpenter2> i want only errors from my application, is there a way to do that?
14:18:50 <sm> runtime errors ? why are your deps doing that ?
14:18:57 <conal> Tuplanolla: nifty. perhaps concat would suit your purpose. it now has several non-standard interpretations of haskell, including a variant of automatic differentiation.
14:19:03 <geekosaur> what do you mean 'garbage errors'
14:19:07 <jcarpenter2> because they've got a retry policy
14:19:11 <jcarpenter2> let me paste an example
14:19:29 <conal> Tuplanolla: and if it's unsuitable, it'd be interesting to know how.
14:20:00 <Tuplanolla> I'll keep you updated, conal. The project starts next year.
14:20:28 <pierrot> thanks, monochrom 
14:20:30 <conal> Tuplanolla: good luck!
14:22:01 <jcarpenter2> http://lpaste.net/359927
14:22:25 <Tuplanolla> The rough idea is that, given the axioms or categorical structure of a field theory, one could produce efficient numerical code to solve problems from that theory, conal.
14:22:52 <jcarpenter2> the first error is the one that points me to the problem, but the rest appear to be due to Happstack retrying my handler
14:22:58 <conal> Tuplanolla: lovely!
14:23:02 <monochrom> This doesn't look like garbage. This looks like exactly what -xc wished for. So now you have to say that -xc is garbage.
14:23:12 <jcarpenter2> no
14:23:16 <jcarpenter2> listen
14:23:36 <Tuplanolla> One can hope!
14:23:43 <amateur_hour> Tuplanolla: it seems easier to just set up a nearest neighbour monte carlo lattice to be fair
14:24:20 <monochrom> OK yeah well if you want some exceptions to not show up in -xc's output, you've got to catch them.
14:24:34 <Tuplanolla> What is this nonsense, amateur_hour?
14:25:45 <amateur_hour> which part are you referring to as nonsense?
14:26:14 <jcarpenter2> monochrom: i'm pretty sure they show up whether you catch them or not
14:26:32 <Tuplanolla> The whole thing, amateur_hour.
14:27:08 <amateur_hour> if you have a set of fields, say SU(2) x U(1), you represent them somehow and transform them, usually
14:27:13 <jcarpenter2> http://lpaste.net/359928 for example
14:27:53 <jcarpenter2> when i run that with +RTS -xc i still get a "*** Exception" in my error log
14:28:11 <amateur_hour> the most straightforward way is to represent them with a, usually (hyper)cubic lattice, and generate an update mechanism of some form
14:28:40 <amateur_hour> say for example the kennedy-pendleton algorithm for thermal lattices in the early universe (for SU(2))
14:29:28 <jcarpenter2> but you know, they are actually all caught like that
14:29:57 <jcarpenter2> let me back up through this XY jungle a little bit
14:30:10 <amateur_hour> did you mean something completely different Tuplanolla ?
14:30:14 <amateur_hour> if so, sorry
14:30:32 <Tuplanolla> Yes, I'm afraid we talked past each other there, amateur_hour.
14:30:55 <jcarpenter2> All exceptions are caught, and I also get all that output with +RTS -xc but the only reason I'm using +RTS -xc is because I couldn't get a stack trace or a line number when I printed the exception using "show"
14:31:29 <sm> jcarpenter2: there's a showWithStackTrace or something ?
14:32:41 <jcarpenter2> sm: where's that?  i can't find it on hoogle
14:32:50 <MarcelineVQ> jcarpenter2: is it your expecation that caught exceptions shouldn't show up in -xc?
14:33:07 <jcarpenter2> MarcelineVQ: no, it's not
14:33:14 <MarcelineVQ> alrighty
14:33:20 <monochrom> It is my expectation.
14:34:28 <MarcelineVQ> monochrom: it is? hmm, the docs only mention that there's a report for every raised exception, not whether catching matters
14:34:47 <jcarpenter2> yeah, it's every exception, caught or not
14:34:58 <geekosaur> jcarpenter2 is talking about calling show on an exception, presumably that means it was caught
14:35:05 <sm> euh
14:36:47 <sm> jcarpenter2: don't have enough bandwidth to search for it, sorry
14:36:55 <jcarpenter2> oh okay
14:36:58 <sm> haddocks won't load
14:37:33 <jcarpenter2> yeh, all exceptions here are caught (the server stays up :) ) but I want to display a stack trace for the ones I catch in my application and not for the ones Happstack catches
14:38:41 <sm> process the text to filterout just yours ?
14:38:53 <geekosaur> they're coming from the runtime
14:38:54 <jcarpenter2> yeah, that's what i was just thinking
14:39:24 <sm> if you load that into and org-mode buffer I think you can folde them
14:39:42 <jcarpenter2> i could potentially come up with some bash gibberish to filter out exceptions that aren't mine, but i'd need to update it as I add new modules to my application
14:40:01 <sm> then C-c / /
14:40:30 <jcarpenter2> what's C-c / /?
14:41:02 <sm> org-sparse-tree
14:42:40 <jcarpenter2> btw, oh so this is why i don't write apps in haskell, i knew there was a reason :V
14:42:58 <sm> jcarpenter2: what's the actual problem again ?
14:43:37 <jcarpenter2> log stack traces for exceptions
14:44:30 <EvanR> so you enabled such things in the profiler, which outputs to stderr when the app crashes due to a bug, so log that?
14:44:36 <EvanR> with a redirect
14:44:39 <EvanR> then fix the bug ?
14:44:40 <geekosaur> yes, jcarpenter2 you can do so much better in a C or C++ signal handler. you know, where the only exceptions are signals (or, worse, setcontext)
14:45:08 <jcarpenter2> that's true - segfault isn't very helpful
14:45:27 <lyxia> jcarpenter2: instead of +RTS -xc how about catching your own exceptions and logging them explicitly in the program
14:45:48 <jcarpenter2> lyxia: when i do that, i can't get a stack trace pointing to the line that introduced the bottom value
14:45:51 <lyxia> jcarpenter2: you can use GHC.Stack to attach the stack traces
14:45:59 <jcarpenter2> yeah, but they don't go all the way down
14:46:01 <jcarpenter2> i've tried
14:46:31 <EvanR> poor code that was not proven to be non-bottom :(
14:46:32 <jcarpenter2> the stack trace ends up being to the exception handler
14:46:55 <jcarpenter2> EvanR: i would, but this is a web server that has to stay up no matter what goes down
14:47:44 <EvanR> you can split up your components into async threads each of which gets either proven to be non bottom in isolation, or crashes and is logged / restarted by its parent
14:48:03 <EvanR> then at least you know which component is messing up
14:48:27 * sm remembers a recent reddit thread explaining how to actually get good stack raaces that was mind-bending
14:48:53 <EvanR> then it wont go down
14:49:04 <EvanR> but to fix bugs, you still need to restart the program at some poit
14:49:39 <sm> https://www.reddit.com/r/haskell/comments/5s5khf/how_to_get_a_proper_stack_trace/ perhaps
14:50:47 <jcarpenter2> basically i would like to log stack traces for some exceptions but not others, and +RTS -xc is too coarse as it logs stack traces for ALL exceptions
14:51:01 <jcarpenter2> i'll probably have to go with some bash gibberish
14:51:15 <monochrom> Is it mind-bending because people tell you to use stack? :)
14:51:36 <sm> nope, just bloody confusing
14:51:44 <sm> still 
14:52:37 <sm> jcarpenter2: try org-mode, it'll just work
14:52:46 <sm> unless you are emacs-averse
14:52:48 <jcarpenter2> that may be true
14:52:50 <jcarpenter2> <3 emacs
14:53:09 <monochrom> My impression of the whole thread is a million explanations of how to add -prof -auto and +RTS -xc
14:53:13 <sm> <3 plain text
14:53:16 <jcarpenter2> i was just worried about disk space or something
14:53:31 <sm> oh well.. depends how big...
14:53:31 <jcarpenter2> because there are a loooooot of stack traces from happstack code
14:53:40 <monochrom> And that no one knows that with cabal it's --enable-library-profiling
14:53:46 <sm> um.. could you run this code from not-happstack ?
14:53:54 <sm> ie a custom script
14:54:03 <jcarpenter2> what do you mean?
14:54:33 <sm> does happstack have to be involved ? if you remove it, -Xc will be more useful
14:55:10 <sm> until you find the problem
14:55:20 <jcarpenter2> happstack doesn't have to be involved, i could use a different web server
14:55:45 <monochrom> whereas https://simonmar.github.io/posts/2016-02-12-Stack-traces-in-GHCi.html is actually transparent.
14:55:56 <sm> but really, maybe org-mode is overkill for a huge log, just use less and search for your code
14:56:25 <jcarpenter2> but there's nothing wrong with happstack (except this https://github.com/Happstack/happstack-server/pull/36 )
14:57:17 <sm> good post monochrom 
14:58:22 <monochrom> A lot of Haskell Q&A is degenerating into Windows end-users Q&A.
14:58:31 <jcarpenter2> that page mentions assert, error, and some methods for outputting a call stack, none of which do the trick
14:59:20 <monochrom> That is, in the answers there are a lot of cargo-culting and spin-doctor try-this-secret-herb-ing.
14:59:29 <jcarpenter2> for assert and error, you need to put them into your code at the point where you want the stack trace, which won't help for unexpected bottom values, and if you print a call stack inside an exception handler it points to the handler, not to where the exception was raised
15:00:52 <jcarpenter2> what's needed is to save the stack trace as part of the Exception object, so that it's included when you run (show (e::SomeException))
15:01:15 <sm> monochrom: I think that's a sign that we are lacking good-enough primary docs (or people are not finding them, which is another way of saying the same thing)
15:03:25 <lyxia> jcarpenter2: http://lpaste.net/359930 The locations I'm getting are not the handlers'.
15:03:39 <monochrom> I think differently. The amount of spin-doctoring is a ratio of: the complexity of the system being used, to the intellectual capacity of the diagnosers.
15:04:53 <sm> sounds like what I said :)
15:06:11 <sm> as in, insufficient docs, so the effective complexity is too high
15:06:14 <monochrom> So take for example the human body and medicine. Even today, among the scientific doctors there is still a bit of spin-doctoring (and they admit it, and our civilization still can't do better yet) because the human body is just so damn complex and even the best researchers are feeling helpless.
15:06:45 <maerwald> wat?
15:06:56 <monochrom> Whereas in the case of Haskell, the system is simpler compared to the human body, and its complexity hasn't changed, but the average programmer intellectual capacity has decreased.
15:07:38 <sm> (afk bbl)
15:07:46 <jcarpenter2> lyxia: right, but you are deliberately throwing an exception and including the call stack when you do
15:08:12 <monochrom> So for example 10 years ago if you had a dependency problem I would ask for your output of "cabal install -v3" and I would read it. Today people will just say "Have you tried stack?"
15:08:15 <maerwald> that sounds like a random guess
15:08:19 <lyxia> jcarpenter2: I am.
15:08:20 <orion> monochrom: How does diminished intellectual capacity manifest itself?
15:08:46 <jcarpenter2> that doesn't work if the exception is due to a "fromJust Nothing" or an out-of-range index into a list
15:09:14 <jcarpenter2> or any other way to create a bottom value that later gets pattern-matched
15:09:18 <monochrom> orion: By seeing an increase in spin-doctor answers?
15:09:53 <orion> Is it possible that the *capacity* hasn't decreased, but tooling has made it easier to be lazy?
15:10:21 <jcarpenter2> which admittedly you're not likely to do, but at the same time you might do sometimes, and Haskell doesn't have a totality checker
15:10:24 <lyxia> jcarpenter2: can't you replace partial functions with ones that throw such exceptions?
15:10:28 <geekosaur> capacity decreases when it's not used though
15:10:49 <monochrom> No, the average decreases because there are more people.
15:10:58 <orion> geekosaur: You're right, but is it true that the capacity is not being used?
15:11:05 <orion> Maybe it's being used to solve different problems.
15:11:06 <maerwald> that's nonsense
15:11:34 <monochrom> HIgher popularity causes lower average. I still haven't seen a counterexample.
15:12:11 <orion> Maybe stack allows me to use my limited intellectual capacity in the pursuit of solving high level architectual problems rather than dependency issues.
15:12:36 <orion> I am now free to concentrate on the problems that make me enjoy programming, as opposed to the problems that make me hate it.
15:12:50 <monochrom> That still doesn't mean you give spin-doctor answers in #haskell or reddit.
15:13:07 <jcarpenter2> lyxia: you can, but what if you make a mistake
15:13:11 <orion> monochrom: That's a separate issue.
15:13:28 <orion> It's an issue to be sure... but it's separate.
15:13:40 <monochrom> But I am talking about the amount of spin-doctor answers.
15:13:53 <orion> What are some other examples of spin-doctor answers, besides stack?
15:14:45 <lyxia> jcarpenter2: what kind of mistake
15:14:45 <monochrom> I'm too lazy to pull up one from the logs of this channel, but there were some. Alternatively, wait a week.
15:14:56 <jcarpenter2> lyxia: using a partial function
15:15:28 <monochrom> And I disagree with "besides stack" too.
15:15:35 <jcarpenter2> ghc can warn you if you've got incomplete patterns, but i don't think it warns you if you use a library function that does
15:16:01 <lyxia> are there that many?
15:16:11 <jcarpenter2> idk
15:16:31 <jcarpenter2> about a dozen
15:16:38 * geekosaur still thinks we need alternative modules/Prelude with callstacks enabled (error -> errorWithStackTrace)
15:16:47 <monochrom> I don't summarily classify all "try stack" answers as spin-doctor answers. Sometimes the answerer actually reads the question and knows for sure suggesting stack is specifically right. Other times people just knee-jerk it.
15:17:08 <Tuplanolla> You should activate monologuechrom more often. It's great.
15:17:32 <lyxia> jcarpenter2: https://hackage.haskell.org/package/located-base you could import this and then resolve all the ambiguity errors.
15:17:49 <hpc_> sometimes stack does fit the answerer's mental model better
15:18:16 <hpc_> if i was comfortable enough with packaging to chime in when someone has an issue, the way i would answer would probably be in the context of stack
15:18:29 <hpc_> (as distinct from "you should use stack" though, i would just frame my advice with it)
15:18:40 <jcarpenter2> that's pretty neat
15:18:47 <jcarpenter2> i'm still writing a bash script
15:19:07 <lyxia> Okay :(
15:19:31 <jcarpenter2> State machine is initialized when "*** Exception" is seen, "called from Main.main" ends it; if in between "called from X" is seen where X is a module from my application, then output to the error file, else do not output anything
15:19:34 <jcarpenter2> should work
15:24:49 <mniip> wow that's a backwards way to solve a problem
15:25:09 <mniip> jcarpenter2, have you considered that there might be a race condition that might cause the error message to be output inbetween other output?
15:26:06 <jcarpenter2> mniip: that's possible, but i'm pretty sure GHC synchronizes them
15:26:26 <Tuplanolla> Dubious, jcarpenter2.
15:26:28 <mniip> if your program outpus an unterminated line to stderr
15:26:34 <monochrom> I don't think I'm seeing nested error messages in this case.
15:26:34 <mniip> can't synchronize that
15:26:46 <mniip> also entirely possible if using lazy IO
15:27:56 <monochrom> The mass of "minus1retry" seems to instead reflect that a syscall is placed and it gets an EINTR and so some driver code re-issues the syscall and this happens several times and it's harmless but -xc sees them.
15:28:03 <Tuplanolla> Your system may guarantee that buffered smaller-than-one-page writes are atomic amongst each other, but it's a nice surprise when you break that guarantee by accident.
15:29:43 <jcarpenter2> well, if +RTS -xc can be directed to a special file handle that would be great
15:33:32 <monochrom> A clean solution uses GHC.Stack (maybe indirectly, e.g., located-base) so you code up how to log the error messages. But it's also a lot of work and overhauling your code.
15:34:39 <monochrom> +RTS -xc is becoming a blunt instrument. I mean sure there was a time it was the only choice so "blunt compared to what?" back then.
15:35:15 <johnw> I used -xc today to track down a bug
15:35:21 <johnw> it's useful when it's useful
15:35:24 <jcarpenter2> located-base only applies to those Prelude functions
15:35:34 <jcarpenter2> and, what if you forget to use it
15:36:16 <monochrom> Yeah GHC.Stack requires a fair dose of consciousness.
15:37:02 <monochrom> What you said about what an Exception object should store is right but GHC wasn't coded up for it back then so today it would require an overhaul.
15:37:21 <monochrom> GHC.Stack already represents a small dose of overhaul.
15:37:33 <monochrom> It didn't even exist two years ago.
15:37:49 <jcarpenter2> i do appreciate all the hard work that's gone into making Haskell what it is today
15:38:02 <jcarpenter2> it's truly a joy to program in
15:38:30 <monochrom> And two more years before that you could find Simon Marlow saying "today I finally figured out stack traces" and you should feel how much this was an uphill battle even for him.
15:38:39 <jcarpenter2> just a little lacking in the exception handling department, quite ironically
15:40:01 <jcarpenter2> if there's ever a bottom value in my code, i want to display an error page to the user and log the stack trace so i can fix the error - easy in C#, terribly complicated in haskell
15:40:13 <monochrom> Any kind of debugging information is at odds with code optimization, generally.
15:40:30 <jcarpenter2> bottom value in happstack's code, well that's upstream :P
15:40:42 <jcarpenter2> got to stay on the latest happstack :P
15:41:58 <geekosaur> stack traces are actually harder to do in a graph reduction language, specifically because there isn't one and you have to carry around a lot of extra information if you want to simulate it
15:42:06 <geekosaur> which makes everything slower
15:45:58 <monochrom> Oh actually I guess GHC.Stack doesn't count as overhaul (even if small) because the HasCallStack constraint means we're just re-using the existing class-and-instance mechanism.
15:46:40 <monochrom> Or more candidly s/re-using/hijacking/
15:47:05 <monochrom> But new code has to be added for the line numbers but that's it.
15:47:41 <monochrom> And it does carry a performance penalty because an extra dictionary is being passed.
15:48:27 <geekosaur> plus the stack data structure itself
15:48:40 <geekosaur> (which is an implicit parameter in the dictionary)
15:48:40 <monochrom> But it was also a realistic project. The size of GHC dev is much smaller than say Windows kernel or MSVC.
15:50:26 <mizunno>  HexChat: 2.10.2 ** OS: Linux 4.10.0-38-generic x86_64 ** Distro: Ubuntu "xenial" 16.04 ** CPU: 4 x Intel(R) Core(TM) i7-3520M CPU @ 2.90GHz (GenuineIntel) @ 2,42GHz ** RAM: Physical: 7,7GiB, 75,7% free ** Disk: Total: 117,1GiB, 42,2% free ** VGA: Intel Corporation 3rd Gen Core processor Graphics Controller ** Sound: HDA-Intel - HDA Intel PCH ** Ethernet: Qualcomm Atheros AR8162 Fast Ethernet ** Uptime: 
15:50:26 <mizunno> 1h 0m 8s **
15:50:27 <monochrom> I need to learn how to use this stuff.
15:51:22 <monochrom> We also need to scarmonger against these people who spontaneously spew their computer specs out of the blue.
15:51:38 <mizunno> Sorry, I'm newbie
15:51:39 <geekosaur> that I'm pretty sure was a typo
15:52:23 <monochrom> We need to scare them with "do you know that this information helps black hats to break into your computer more easily than the rest of us". That will teach them.
15:52:52 <monochrom> Like if I know that you're specifically using Ubuntu 16.04, that saves me time.
15:53:13 <mizunno> Yes, I know, but... So embarrassing
15:54:06 <monochrom> OK no worries, I'm joking, I'm pretty sure real black hats are laughing at my theory.
15:55:48 <mizunno> OK. It's the first time I use IRC
15:56:42 <sm> welcome mizunno ! don't worry, old timers do it too
15:56:43 <geekosaur> argubaly sysinfo shouldn't be so easy to trigger inappropriately, (plus the manual implies it's displayed locally not sent to IRC)
15:56:50 <sm> at least you didn't paste your password.
15:57:13 <geekosaur> but making it harder would probably annoy the folks over in #hexchat who want that information when someone asks for help
15:58:47 <EvanR> i wonder how many users nickserv pw is hunter2
15:59:11 <MarcelineVQ> probably about as many's are *********
15:59:13 <mizunno> I didn't think it was going to be sent directly
16:00:08 <monochrom> Oh that gives me an idea. We need a similar hexchat script to spew GHC version, cabal version, stack version, and go ahead to post the output of "ghc-pkg list" and "ghc -v" to lpaste... :)
16:00:36 <geekosaur> then you have to get more people to use hexchat instead of freenode webchatr
16:00:37 <mizunno> It hasn't been a good way to introduce myself, or yes ;)
16:00:41 <geekosaur> which isn't very scriptable :p
16:24:37 <monochrom> Actually just a "this user is using archlinux" already clarifies 90% of the questions. :D
16:28:40 <mniip> !
16:28:51 <mniip> would you like to hear
16:29:00 <mniip> about my haskell scripting plugin for hexchat
16:34:54 <mniip> no one? :(
16:40:06 <Rembane> mniip: Yes we would! :D
16:41:38 <mniip> I haven't gotten the entire API in order yet,
16:41:51 <mniip> but the basic functions are working already: script loading/unloading, command hooking,
16:42:04 <mniip> and I'm yet to come up with a high-level API
16:43:08 <monochrom> mniip: My https://github.com/treblacy/xchat-plugin-haskell-toy may be of interest, but clearly I did less.
16:44:53 <mniip> right
16:45:15 <mniip> I'll put it on github once I have at least all FFI imported functions bound to stubs
16:47:40 <monochrom> You will also like to know http://www.vex.net/~trebla/haskell/so.xhtml#cabal i.e. cabal now has direct make-*.so support.
16:48:03 <monochrom> Oh more funnily I should say make-me-a-*.so
16:48:57 <mniip> right but
16:49:14 <mniip> https://github.com/haskell/cabal/issues/4878
16:52:49 <mniip> 7 more functions to go
16:55:00 <mniip> monochrom, yeah my code is at least a superset of yours
16:55:31 <monochrom> Yeah just in case I pulled a trick that you haven't thought of.
16:57:50 <mniip> you underestimate my power
16:58:00 * monochrom trembles
16:58:59 <mniip> no you're supposed to say "don't try it"
16:59:30 <monochrom> Heh
16:59:59 <monochrom> Was it Obi Wan who said "don't try it"?
17:00:42 * Rembane hands out light sabres
17:01:58 <Tuplanolla> Subset, you say? Consider the fact that every package contains a subset of `lens`.
17:02:20 <mniip> but I said a much stronger statement
17:02:55 <monochrom> I have a better idea. Every package contains a subset of the empty package.
17:03:24 <Tuplanolla> It's the best kind of true.
17:03:41 <monochrom> Nobody is perfect and I'm nobody. \∩/
17:22:19 <ymte_> Client: HexChat 2.12.4 • OS: Debian 9.2 • CPU: AMD A10-5700 APU with Radeon(tm) HD Graphics (2,30GHz) • Memory: Physical: 3,7 GiB Total (1,5 GiB Free) Swap: 3,9 GiB Total (3,9 GiB Free) • Storage: 605,1 GB / 1,1 TB (488,8 GB Free) • VGA: Advanced Micro Devices, Inc. [AMD/ATI] Cape Verde XT [Radeon HD 7770/8760 / R7 250X] @ Advanced Micro Devices, Inc. [AMD] Family 15h • Uptime: 1h 49m 56s
17:29:12 <mniip> 3 to go
17:31:33 <mniip> hi dax
17:32:09 <dax> hihi
17:56:12 <EvanR> in numeric code, if youre unsure of the possibility of division by zero, you can 1. prove somehow that division by zero does not happen 2. do an explicit check for zero before any division (and then i dont know what) 3. define a division that returns a nonsense number or NaN in case of division by zero and continue on. are there any other strategies?
17:59:58 <mniip> monochrom, do you happen to know if I can tell cabal where to install the .so?
18:02:21 <mniip> EvanR, document undefined behavior and scare the library user out of ever even attempting to do it
18:02:38 <EvanR> out of attempting to use the library?
18:03:43 <mniip> to divide by zero
18:10:41 <monochrom> mniip: --prefix=/xxx/yyy helps
18:10:54 <mniip> well something that goes into the .cabal file
18:11:08 <mniip> specific to a stanza
18:11:16 <monochrom> Oh *.cabal doesn't support that.
18:13:46 <mniip> aw
18:22:10 <Enigmagic> EvanR: it's pretty common to add a small value, like 1e-12, to the denominator
18:22:21 <Enigmagic> whether or not that's appropriate for your app...
18:23:01 <EvanR> if youre supposed to only be dealing with positive divisors i guess that can "fix" it
18:23:23 <EvanR> did not know about that one
18:24:20 <mniip> oh yes
18:24:22 <mniip> I did that
18:24:40 <mniip> sometimes you would even unconditionally add 1e-12 even if the number is possibly negative
18:24:55 <EvanR> now that just seems silly
18:25:19 <Enigmagic> and very common :-)
18:25:21 <EvanR> add 1e-12 if positive, subtract 1e-12 if negative? :)
18:25:38 <mniip> add 0 if 0 xD
18:25:50 <EvanR> oh
18:26:15 <EvanR> oh what i am partially missing jokes
18:30:12 <mniip> monochrom, Rembane https://github.com/mniip/hexchat-haskell
19:17:21 <boogalooga> quick question
19:17:27 <boogalooga> I have a data type
19:17:34 <boogalooga> which is a instance of some type class
19:17:56 <boogalooga> now I want to create another data type which is exactly the same as my first data type
19:18:05 <boogalooga> but it is also an instance of another type class
19:18:09 <boogalooga> how do I do that?
19:18:55 <lyxia> newtype and GeneralizedNewtypeDeriving?
19:19:32 <boogalooga> don't follow
19:20:15 <boogalooga> oh wait
19:20:45 <lyxia> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#generalised-derived-instances-for-newtypes
19:21:58 <boogalooga> wait
19:22:12 <boogalooga> can two different data types have data constructors with the same names
19:22:13 <boogalooga> ?
19:22:18 <geekosaur> no
19:22:26 <boogalooga> I see okay
19:22:28 <boogalooga> thanks
19:28:55 <bob_the_brain> hello all, i'm doing some type-level programming and am having trouble proving that `'[] ~ as ++ bs` implies `'[] ~ as`. here is a minimal example (http://lpaste.net/359932) and error message (http://lpaste.net/359933). does anyone have advice on directions towards a solution?
19:29:34 <EvanR> that doesnt seem try
19:29:39 <EvanR> that doesnt seem true
19:30:08 <EvanR> oh yes it does
19:30:36 <bob_the_brain> i guess it depends on the definition of ++ but in this case i believe it is true :)
19:42:40 <bob_the_brain> i have an ugly solution that works in my specific case but would love to know where to find examples of how proofs of this sort are passed around in type-level code
19:43:03 <bob_the_brain> i know it can be done elegantly
19:44:44 <boogalooga> instance HasVars (M.Map String Integer -> Maybe Integer)
19:44:49 <boogalooga> Does this mean that
19:45:09 <boogalooga> a function with that signature will be an instance of my custom type HasVars?
19:46:02 <monochrom> No. You're conflating types with values.
19:46:12 <monochrom> A function with whatever signature is a value.
19:46:18 <monochrom> The signature is a type.
19:46:36 <monochrom> And you're conflating types with classes.
19:46:51 <monochrom> HasVars is your custom class, not your custom type.
19:47:41 <monochrom> If you have "x :: Int" you don't say that x is an instance of Num. Int is an instance of Num.
19:48:26 <monochrom> And there is no relation between x and Num.
19:49:04 <boogalooga> I see
19:49:19 <boogalooga> I think I wrote type because it was being called a type class
19:49:21 <boogalooga> in my notes
19:49:23 <boogalooga> oops
19:49:43 <monochrom> Yes, this is why I no longer say "typeclass" or "type class".
19:50:02 <boogalooga> okay
19:50:03 <boogalooga> but
19:50:10 <monochrom> The code reads "class HasVars xxx where" so let's KISS and just say "class" too.
19:50:15 <boogalooga> I still don't understand the instance declaration
19:50:34 <monochrom> Do you understand other instance declarations?
19:50:44 <boogalooga> If it's something like instance HasVars Integer where
19:50:47 <boogalooga> then yes I do
19:50:51 <boogalooga> but the arrow is confusing me
19:51:20 <boogalooga> it looks like a function input and return type
19:51:49 <boogalooga> so any function with that type signature is an instance of HasVars?
19:52:05 <monochrom> No, you have been brainwashed by other languages to think that function types are fundamentally different from other data types.
19:52:29 <monochrom> In Haskell, they are all types, we don't draw a line.
19:52:54 <boogalooga> okay if the thing with the arrow is a data type
19:52:58 <boogalooga> what does it represent?
19:53:03 <Cale> boogalooga: It means *that function type* is an instance of HasVars
19:53:14 <Cale> (not that functions of that type are)
19:53:26 <boogalooga> so any function with that type?
19:53:38 <monochrom> I don't know what "represent" means. What does "Maybe Int" "represent"?
19:53:40 <Cale> This is a terminology nitpick, but I do agree with monochrom that it's a bit important to get right :)
19:53:44 <geekosaur> the distinction being drawn here is *values* are not members of typeclasses
19:53:47 <geekosaur> *types* aree
19:54:02 <geekosaur> a function is a value
19:54:03 <monochrom> No I clearly think that behind the wrong terminology is completely flawed model.
19:54:38 <Cale> Maybe to make things more concrete, what's the actual definition of the HasVars class? We can look at what are the rest of the implications of that instance
19:54:39 <monochrom> No I don't just think. I have hard evidence. "So a function of that sig is an instance?".  Clearly wrong.  Not just wrong wording.
19:54:40 <geekosaur> (+1) is a perfectly good value, one you might pass to e.g. map. likewise, map itself is a perfectly good value
19:55:14 <geekosaur> neither one is an instance of a typeclass, although their types may be
19:55:23 <boogalooga> for some reason
19:55:25 <boogalooga> I thought
19:55:35 <boogalooga> functions were expressions which evaluated to values
19:55:39 <monochrom> "Int" is a type. "Maybe Int" is a type. "Maybe Int -> Bool" is a type. They are all examples of types.
19:56:05 <monochrom> No. That's a great misunderstanding from some applied math classes.
19:56:19 <monochrom> Or at least our functions aren't their functions.
19:56:51 <boogalooga> you can see the declaration of HasVars here
19:56:52 <boogalooga> http://www.cis.upenn.edu/~cis194/spring13/hw/05-type-classes.pdf
19:58:05 <Cale> ah, okay, so this means that for this instance, we'll have  var :: String -> (M.Map String Integer -> Maybe Integer)
19:58:59 <boogalooga> Right
19:59:00 <Cale> (whose obvious implementation will look up the given String in the given Map)
19:59:05 <boogalooga> so I return a function correct?
19:59:21 <Cale> Or you define var as a function of two arguments, which is the same thing
19:59:34 <Cale> A -> (B -> C) is the same thing as A -> B -> C
19:59:37 <monochrom> Yes. If "I" really means "var".
19:59:46 <boogalooga> yes I understand
20:00:01 <boogalooga> one of the lectures mentioned that every function is curried
20:00:26 <Axman6> All functions only take one argument, there are no exceptions
20:00:35 <boogalooga> By I, I meant me. Haha
20:00:39 <boogalooga> ahuh
20:00:45 <monochrom> I wouldn't say that. "Int -> Bool" isn't curried. Unless in the degenerate sense.
20:01:20 <monochrom> Also there is 76% chance you misunderstood the lecture.
20:01:31 <boogalooga> why?
20:01:32 <monochrom> (Oh I made up that number.)
20:01:55 <monochrom> Statistics? Every student has a non-zero chance of misunderstanding lectures?
20:02:14 <monochrom> We know this from marking assignments and exams?
20:07:17 <monochrom> Haskell's X->Y->Z is almost inexpressible in C.
20:09:16 <monochrom> Almost. If you don't mind going through a function pointer, it's "Z (*(X))(Y)".
20:09:38 <iqubic> That's weird.
20:09:43 <monochrom> Or more clearly, if you have "f :: X->Y->Z" in Haskell, it's "Z (*f(X))(Y)" in C.
20:10:02 <iqubic> I wonder what purescript does to get around this?
20:10:20 <monochrom> And that's only the beginning of the trouble. You're written the prototype. Great. Now how to write the code inside?
20:10:50 <monochrom> I don't think you can in C. But you can FFI to Haskell and do http://lpaste.net/358634
20:11:10 <iqubic> Why are we talking about C in the first place?
20:12:02 <iqubic> δξκσαλδξσκαλδξκσλαφξλακσφξκσαλ
20:12:14 <monochrom> Because C is one of the father languages that rip us of our ability to understand function types?
20:13:10 <iqubic> Yeah. Java is even worse. No way to express f :: x -> y -> z at all.
20:13:54 <iqubic> How do you even do that in java? Answer you don't.
20:16:26 <monochrom> So basically from a C background or equivalent, you can understand that "int, bool, double" are types but functions don't have types because you can't write it. You make do with an inferior model "a function has two types, the param type and the return type".
20:18:15 <monochrom> So when in Haskell you see "instance C (X -> Y)" you can't even believe that X->Y is a thing so you start making alternatve theories like "OK so it's such a function, not such a function type, that is an instance, since there is no such thing as function type"
20:21:48 <edwardk> monochrom: closure conversion is such an alien concept
20:24:53 <dibblego> Yes you can. It was first written in Java in 2004.
20:32:25 <Axman6> Ask him how he knows
20:33:24 <|{ame> hello,is there a more compact way to write (\a b -> f(g(a),g(b)) ?
20:33:36 <Axman6> @pl (\a b -> f(g(a),g(b))
20:33:37 <lambdabot> (line 1, column 22):
20:33:37 <lambdabot> unexpected end of input
20:33:37 <lambdabot> expecting variable, "(", operator or ")"
20:33:44 <Axman6> @pl (\a b -> f(g(a),g(b)))
20:33:44 <lambdabot> (f .) . (. g) . (,) . g
20:33:51 <Axman6> hmm
20:34:00 <|{ame> sorry
20:34:17 <Axman6> :t (\a b -> f(g(a),g(b)))
20:34:18 <|{ame> (\a b -> f g(a) g(b) )
20:34:19 <lambdabot> error:
20:34:19 <lambdabot>     • Could not deduce (Show a0) arising from a use of ‘f’
20:34:19 <lambdabot>       from the context: (FromExpr t2, Show t1, Show t)
20:34:25 <monochrom> Maybe &&& helps.
20:34:25 <Axman6> :t (\f g a b -> f(g(a),g(b)))
20:34:26 <lambdabot> ((b, b) -> t1) -> (t2 -> b) -> t2 -> t2 -> t1
20:35:11 <|{ame> essintially, I want to do function composition (.) extended to each argument
20:35:21 <geekosaur> :t on
20:35:22 <lambdabot> (b -> b -> c) -> (a -> b) -> a -> a -> c
20:35:28 <Axman6> :t \f g -> f . g &&& g
20:35:30 <lambdabot> (c' -> c) -> (b -> c') -> b -> (c, c')
20:36:21 <Axman6> |{ame: I assume you mean  (\a b -> f (g a) (g b) )?
20:36:27 <monochrom> No, I've decided that (&&&) doesn't help.
20:36:43 <Axman6> yeah it doesn't
20:36:49 <|{ame> yes, and by the definition, on is what I needed, thank you!
20:37:01 <Axman6> oh yes, of course
20:37:06 <Axman6> thought it was familliar
20:37:29 <Axman6> (==) `on` snd and similar things are quite common
20:42:47 <boogalooga> any way to void
20:42:49 <boogalooga> avoid
20:42:58 <boogalooga> the use of nested case here
20:42:59 <boogalooga> http://lpaste.net/359934
20:43:26 <lyxia> (liftA2 . liftA2) (+) a b m
20:43:40 <glguy> boogalooga: It's OK if you wait to send your message once you've written the whole thing. Your lines can be longer than a few characters.
20:44:18 <boogalooga> alright
20:45:48 <monochrom> I recommend sticking to nesting cases for now. There is a way but it's a few lessons later in CIS193 (3? 4?)
20:46:02 <boogalooga> 194
20:46:58 <boogalooga> okay
20:47:21 <boogalooga> sounds good
20:47:22 <boogalooga> thanks
20:47:41 <Cale> Just as a preview, using the Monad instance for Maybe, you could write
20:47:46 <Cale> add a b m = do
20:47:50 <Cale>   k <- a m
20:47:53 <Cale>   l <- b m
20:47:57 <Cale>   return (k+l)
20:48:06 <boogalooga> I think Monads are the last lecture, haha
20:49:12 <mniip> 1510286968 [07:09:28] <monochrom> Or more clearly, if you have "f :: X->Y->Z" in Haskell, it's "Z (*f(X))(Y)" in C.
20:49:49 <Cale> I love how you have to read C types in a spiral
20:50:00 <mniip> I think you mean Z (*)(Y) (*)(X)
20:51:51 <saurabhn_> using `stack ghci` how do I load my test-suite?
20:53:12 <mniip> monochrom, actually C++ isn't half bad in that regard
20:53:27 <mniip> std::function<std::function<Z(Y)>(X)>
20:57:01 <glguy> int(*f(int y))(int) { return y ? inc : dec; }
20:57:48 <monochrom> But can you do (\x y -> x + y)?
20:58:01 <systemfault> Even C isn't that bad if you do it properly (with typedefs)
20:58:20 <mniip> monochrom, probably yes
20:58:38 <monochrom> Yeah right, typedef Z (*ftype(X))(Y)
20:58:43 <geekosaur> if you let me extend C a bit, yes (but please, not Apple's blocks, they seem like a clumsy way to do it, even C++'s [](...) is better)
20:58:43 <mniip> [](auto x, auto y) { return x + y; } among other things
20:58:57 <mniip> or
20:59:02 <glguy> monochrom: can I use a global variable? :)
20:59:11 <mniip> [](auto x) { return [x](auto y) { return x + y; }; }
20:59:26 <mniip> but there's probably an stl or boost function for that
20:59:27 <monochrom> Yeah I could only think of going through a global variable. But re-entrancy...
21:00:03 <mniip> std::plus
21:01:02 <glguy> monochrom: If we limit ourselves to uint8_t add(uint8_t, uint8_t) we merely need 256 predefined functions
21:01:40 <glguy> err the curried version, that is
21:02:51 <monochrom> Ah ultrafinitism.
21:03:05 <mniip> well
21:03:10 <mniip> just implement std::function in C
21:04:25 <mniip> #define FUNCTION(A, B) struct { B (*call)(void *, A); void *nonce; }
21:05:02 <monochrom> The problem is that this can't use function application syntax.
21:05:09 <glguy> Hey, bring those goalposts back
21:05:09 <mniip> sure
21:05:11 <codeshot> Why is pure a method of Applicative instead of Functor? Are there functors where it's undesirable to define arbitrary construction?
21:05:44 <mniip> codeshot, anything that is Functor but not Applicative
21:05:54 <monochrom> No, but rather functor has always been about fmap and nothing more.
21:06:07 <mniip> codeshot, Const for example
21:06:54 <EvanR> arent there things that could have a pure but not <*>
21:06:57 <mniip> or
21:07:03 <mniip> Free f
21:07:09 <codeshot> Why would you want to avoid pure = Const?
21:07:15 <geekosaur> there are functors where it's not possible
21:07:17 <geekosaur> One example of aFunctorwhich is notPointedis((,) e)
21:07:21 <mniip> codeshot, please implement pure :: a -> Const r a
21:07:24 <geekosaur> urk. damn pdfs
21:07:24 <ongy> Data.Map as well
21:07:25 <glguy> codeshot: Because we want it to typecheck
21:08:24 <mniip> ongy, tbf I could imagine Monoid m => Applicative (Map m)
21:08:26 <codeshot> mniip, oh I see
21:08:32 <mniip> much like the [] Applicative
21:08:46 <codeshot> thanks for the knowledge
21:08:47 <ongy> mniip: the pure instance will be good fun
21:08:59 <mniip> oh right
21:09:05 <mniip> needs some constraints
21:09:13 <mniip> Monoid m, Ord m
21:09:26 <codeshot> are all Applicative methods definable for all Functors where pure is definable?
21:10:11 <mniip> pure x = fromList $ pure x
21:10:31 <mniip> f <*> k = fromList  $liftA2 (<*>) (toList f) (toList k)
21:10:34 <edwardk> mniip: does that work?
21:10:34 <ongy> https://hackage.haskell.org/package/base-4.10.0.0/docs/Control-Applicative.html docs contain how and why
21:10:38 <ongy> ^ codeshot
21:11:25 <edwardk> [(m,a)] looks like WriterT m [] a i guess
21:11:29 <mniip> yes
21:11:47 <mniip> @let instance (Monoid m, Ord m) => Applicative (Map m) where pure = M.fromList $ pure x; f <*> k = M.fromList $ liftA2 (<*>) (M.toList f) (M.toList k)
21:11:48 <lambdabot>  .L.hs:171:44: error:
21:11:48 <lambdabot>      Not in scope: type constructor or class ‘Map’
21:11:48 <lambdabot>      Perhaps you meant ‘M.Map’ (imported from Data.Map)
21:11:52 <mniip> @let instance (Monoid m, Ord m) => Applicative (M.Map m) where pure = M.fromList $ pure x; f <*> k = M.fromList $ liftA2 (<*>) (M.toList f) (M.toList k)
21:11:54 <lambdabot>  .L.hs:172:34: error:
21:11:54 <lambdabot>      Ambiguous occurrence ‘x’
21:11:54 <lambdabot>      It could refer to either ‘Debug.SimpleReflect.x’,
21:11:58 <mniip> @let instance (Monoid m, Ord m) => Applicative (M.Map m) where pure x = M.fromList $ pure x; f <*> k = M.fromList $ liftA2 (<*>) (M.toList f) (M.toList k)
21:11:59 <lambdabot>  .L.hs:172:31: error:
21:12:00 <lambdabot>      • Couldn't match type ‘a’ with ‘(m, a)’
21:12:00 <lambdabot>        ‘a’ is a rigid type variable bound by
21:12:08 <mniip> one sec I'll iron it out
21:12:09 <glguy> I'd worry that this instance for map might not satisfy the associativity of <*>
21:12:16 <glguy> because some keys could overlap differently
21:12:37 <mniip> @let instance (Monoid m, Ord m) => Applicative (M.Map m) where pure x = M.fromList $ pure $ pure x; f <*> k = M.fromList $ liftA2 (<*>) (M.toList f) (M.toList k)
21:12:38 <glguy> where that isn't such a problem for [(m,a)] because keys aren't merged
21:12:38 <lambdabot>  Defined.
21:12:47 <edwardk> yeah, the merge i think screws you
21:12:50 <mniip> glguy, always pick the firsts?
21:13:11 <mniip> hmm
21:13:12 <edwardk> that's what the fromList will do
21:13:33 <mniip> toList . fromList is a sort of sorts
21:13:39 <mniip> which might be a problem
21:14:05 <codeshot> ongy, I just looked through that page again. I can't see an explanation
21:14:27 <codeshot> Do I have to do maths to calculate the answers to those questions?
21:14:29 <mniip> ok so the problem here is the correspondence of Ord and Monoid
21:14:36 <mniip> at least for some cases it's got to be right
21:15:49 <ongy> codeshot: yea, the explanation is only really the laws that have to be statisfied. You could write it out how it works, yes
21:18:08 <mniip> yay
21:18:09 <mniip> @check \f g x -> ((.) <$> f <*> g <*> x) == ((f :: M.Map [Bool] (Bool -> Bool)) <*> ((g :: M.Map [Bool] (Bool -> Bool)) <*> (x :: M.Map [Bool] Bool)))
21:18:11 <lambdabot>  *** Failed! Falsifiable (after 20 tests and 17 shrinks):
21:18:11 <lambdabot>  fromList [([],<Bool -> Bool>),([False],<Bool -> Bool>),([False,False,False,T...
21:19:15 <ongy> is @check just quickcheck?
21:21:32 <jle`> yes
21:21:51 <codeshot> I find it weird that these things are so secret
21:28:00 <mniip> codeshot, secret?
21:28:25 <codeshot> yeah, it's really hard to get straightforward statements of how it is
21:28:46 <codeshot> everythings all "I know light is a corpuscle because I can polish glass"
21:29:01 <codeshot> (Isaac Newton)
21:29:31 <mniip> idk I can look at the definitions of functor and applicative and find some examples of one that is not another
21:29:51 <mniip> you learn to see these kinds of things
21:32:12 <codeshot> but this is an example of search, and that suffers the halting problem. To excel as a group, in engineering, we must record a map of searches that have been done for newcomers to follow the map, reach the unexplored parts of the search, and avoid cycles
21:33:18 <codeshot> We can only use iterative deepening to the depth of a single human career which is quite limited
21:35:56 <mniip> codeshot, this isn't a deep search
21:36:05 <mniip> and shallow searches like this have educational purpose
21:36:31 <mniip> you can't "learn" by reading lectures
21:36:35 <mniip> you have to solve tasks too
21:36:47 <codeshot> I'm trying to learn some different vectors at the moment, in addition to a career
21:37:17 <codeshot> Is there a standard syllabus I can check to ensure I'm on the right course?
21:37:20 <monochrom> You're missing out on the economic angle. Especially since you mentioned engineering.
21:41:50 <monochrom> The engineering apprenticeship consists for a few years of getting an engineering degree and a few more years of work experience before they let you into their engineering society.
21:42:46 <monochrom> And there was once I wondered why the "experience" part can't be just articulated and told and read and listened to in textbooks and lectures.
21:42:46 <codeshot> mniip, I'm solving tasks, but I have to stop to solve one that's stopping me from learning the things I need to learn right now (my task is to learn the economic effects of choosing mathematical languages by exploring what's possible before learning the techniques used in mathematical languages)
21:43:52 <monochrom> Half of it is as mniip says, some of those things are better off you go through it in person than just being told. They can be told but telling and listening isn't effective for them.
21:44:00 <codeshot> otherwise the joke about sharing a cola. But my half is at the bottom so I had to drink my buddy's half first to get to it
21:44:33 <monochrom> But there is also the other half where they just watch you making a mistake, and not warn you, and afterwards just be smug and say "see this is the value of experience".
21:44:36 <codeshot> monochrom, yeah, but at 39 I'm able to identify and learn in that style after I've worked out if I should
21:44:55 <codeshot> monochrom, yeah I know that one from lots of people
21:45:03 <monochrom> So I wondered why is that.
21:45:13 <monochrom> And later I understood the economic perspective.
21:45:48 <codeshot> monochrom, me too, but as above: I have a time budget and I need to know key facts about the explored space to decide whether to budget time to learning these skills
21:45:53 <monochrom> A senior engineer's time is better spent on earning money (or earning money for the company) then documenting all these things for the young ones.
21:46:09 <codeshot> which I will learn in the manner you guys suggest once I know that's what I want to dedicate my time to
21:46:44 <codeshot> monochrom, ah, well, that's line managements decision. Documentation is not just for young ones, it's also for ramping up resources
21:47:03 <monochrom> And I am already speaking as someone who volunteered to write for example http://www.vex.net/~trebla/haskell/lazy.xhtml and http://www.vex.net/~trebla/haskell/so.xhtml
21:47:29 <codeshot> I'm ramping up, but only once I've worked out if I can deliver with my resource
21:48:01 <monochrom> But at some point I have to make money too. I can't spend my whole life finishing my todo list of writing a tutorial on type inference, a tutorial on denotational semantics, a tutorial on Backpack...
21:48:24 <monochrom> Now think of those engineers who actually aim at making more money than I do.
21:48:37 <codeshot> Any idea why there are so many tutorials and things that don't explain things?
21:48:42 <monochrom> Like they care how you learn.
21:49:06 <codeshot> ah, but I won't until I know the scope of the state of the art
21:49:16 <codeshot> the unsolved problems,
21:49:58 <codeshot> the ratio of key knowledge to unsolved problems that are involved in prerequisites to solving an engineering problem, etc
21:50:11 * pacak makes money writing haskell and reading cryptic tutorials
21:50:55 * codeshot wants to make significant positive impact on the world, can't do it at this pace
21:51:17 * codeshot will be dead before he understands the maths of Monads
21:51:36 <pacak> Monads are simple.
21:51:45 <codeshot> everything complex is simple
21:51:48 <codeshot> always is
21:52:25 <pacak> Even if you look at them as monoids in a category of applicative endofunctors...
21:52:31 <codeshot> The schroedinger equation is simple, but just go look at the world that necessarily follows
21:53:19 <Hafydd> You need some initial conditions for that, too.
21:53:47 <Hafydd> Hopefully those are simple, too.
21:53:53 <codeshot> yet we tell our kids "Don't run into the road without looking first", not "you should think about the pauli exclusion principle" leaving them to deduce the consequences for the forces on their brain tissue
21:54:13 <pacak> and initial conditions for those initial conditions...
21:54:42 <monochrom> I thought the Pauli exclusion principle just warned "don't run into your twin brother".
21:55:15 <geekosaur> only if you're a fermion
21:59:19 <nshepperd> sometimes you think you understand something, but you actually don't
21:59:39 * nshepperd wonders if people often think they don't understand monads, but actually they do
21:59:53 <geekosaur> monads certainly get overthought a lot
22:01:04 <codeshot> I'm starting to understand them I think
22:02:50 <codeshot> they lift a value into a concept of a value using a tree for constructing the concept via relationships (like geogebra does for constructing a geometry)
22:03:36 <ezyang> I heard someone say Backpack :O 
22:04:16 <monochrom> Yeah I'm estimating that two years later I will actually come around to write a tutorial.
22:04:50 <codeshot> monochrom, we already have lots of tutorials on monads
22:05:01 <monochrom> I mean Backpack tutorial.
22:05:08 <codeshot> we did when I visited Haskell on the side at uni in 2001
22:05:10 <codeshot> oh
22:05:15 <nshepperd> i just think of a monad as something that you can use >>= and return on
22:05:23 <nshepperd> dunno what a geogebra is
22:05:44 <monochrom> I'm open to commissions for writing it earlier but that's still next September because I'm already booked from now to then.
22:05:55 <codeshot> geogebra, it is to geometry what compilation is to the lambda calculus
22:06:21 <codeshot> well, almost - but they don't have any reordering
22:06:36 <monochrom> Yes you should commission me to write tutorials you want, like how they commissioned Mozart and Dvorak etc.
22:07:20 <codeshot> heh, you should convince me you could and then I seriously might
22:07:37 <codeshot> unfortunately I don't yet know how to describe the tutorial I want
22:07:41 <monochrom> Oh just look at http://www.vex.net/~trebla/haskell/
22:07:45 <codeshot> or if it's possible
22:08:02 <nshepperd> oh, it's a constructive geometry application, like c.a.r
22:08:58 <codeshot> I'm not sure that it's a good idea to search by personality rather than topic, filtered by intended audience and their goals, ordered by a quality rating
22:09:41 <codeshot> monochrom, oh is that your stuff?
22:09:44 <codeshot> I'll have a look
22:09:46 <monochrom> Yes.
22:11:07 <codeshot> Which of those are the ones you think are most likely to make me want to pay you to do more on specific things?
22:13:05 <monochrom> "Introduction to Cont", "Exception Tutorial", "Lazy Evaluation", "Storage and identification of Cabalized packages"
22:14:10 * codeshot starts reading
22:19:10 <mniip> hey monochrom have you seen my take on the hexchat plugin
22:19:23 <monochrom> yes
22:21:16 <koz_> monochrom: That's a neat resource - thank you!
22:21:45 <koz_> Also, could someone please tell me what the difference between Accelerate and Repa is? They seem to do very similar things.
22:25:41 <geekosaur> Accelerate uses external libraries; repa is intended to be pure Haskell. Accelerate also supports using CUDA to do computations on GPUs
22:27:04 <koz_> geekosaur: Which is easier to use?
22:27:49 <geekosaur> that I couldn't tell you; I know the above because of helping others sort out Accelerate backend library issues in the past, not because I use it
22:28:27 <geekosaur> but I'd guess repa would be somewhat easier just because it doesn't involve writing code that might have to be offloaded to a GPU or another CPU via LLVM
22:31:23 <koz_> geekosaur: Thanks - that actually helps.
22:53:52 <Athas> koz_: I find them equally easy to use.
22:53:56 <Athas> The type systems are very similar.
22:54:39 <Athas> Accelerate may be a smidge simpler.
23:01:10 <Athas> Also, Accelerate is still receiving lots of tender love and care, while Repa is a little more passively maintained.
