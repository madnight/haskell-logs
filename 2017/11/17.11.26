00:27:48 * hackage shelly 1.6.8.7 - shell-like (systems) programming in Haskell  https://hackage.haskell.org/package/shelly-1.6.8.7 (psibi)
00:29:40 * hackage shakespeare 2.0.14.1 - A toolkit for making compile-time interpolated templates  https://hackage.haskell.org/package/shakespeare-2.0.14.1 (psibi)
00:36:12 * hackage egison 3.7.5 - Programming language with non-linear pattern-matching against non-free data  https://hackage.haskell.org/package/egison-3.7.5 (SatoshiEgi)
00:37:40 * hackage gio 0.13.4.0 - Binding to GIO  https://hackage.haskell.org/package/gio-0.13.4.0 (HamishMackenzie)
00:52:10 * hackage hasql 1.1.1 - An efficient PostgreSQL driver and a flexible mapping API  https://hackage.haskell.org/package/hasql-1.1.1 (NikitaVolkov)
00:59:10 * hackage rebase 1.2 - A more progressive alternative to the "base" package  https://hackage.haskell.org/package/rebase-1.2 (NikitaVolkov)
01:05:16 * hackage rerebase 1.2 - Reexports from "base" with a bunch of other standard libraries  https://hackage.haskell.org/package/rerebase-1.2 (NikitaVolkov)
01:08:26 <abbe> Hi, is there a known folding function, where one can just exit in the middle of the folding loop, something like e.g. fold fn acc [] = acc; fold fn acc (x:xs) = let (nextiter, acc2) = fn acc in if nextiter then fold fn acc2 xs else acc2
01:09:47 <erisco> abbe, what is the larger problem? I am not sure how to translate your question
01:11:08 <abbe> i want to basically fold a list only until certain point, a point which i don't know in advance, e.g. list of first n natural numbers whose sum is less than 1000
01:11:55 <erisco> well you can just accumulate a tuple like you've already shown
01:12:16 <abbe> right, but I want to know, if there is such a folding function present somewhere, or I have to write above function
01:12:26 <erisco> no, just use foldr
01:12:45 <erisco> or maybe foldl'
01:13:15 <abbe> hmm, reading on them. thanks for the pointers
01:16:23 <Tuplanolla> Zippers and continuations provide other means to suspend computations, abbe.
01:19:15 * hackage rob 0.0.2 - Simple projects generator  https://hackage.haskell.org/package/rob-0.0.2 (gianlucaguarini)
01:21:17 * hackage gtk3 0.14.8 - Binding to the Gtk+ 3 graphical user interface library  https://hackage.haskell.org/package/gtk3-0.14.8 (HamishMackenzie)
01:47:10 * hackage cairo 0.13.4.2 - Binding to the Cairo library.  https://hackage.haskell.org/package/cairo-0.13.4.2 (HamishMackenzie)
01:52:27 <abbe> don't see how fold{r,l'} can terminate early
01:55:39 <vaibhavsagar> koz_: have you seen https://github.com/owickstrom/neovim-ghci?
01:57:36 <cocreature> abbe: foldr can terminate early if you don’t force the evaluation of the accumulator
01:57:45 <cocreature> > foldr (\x acc -> 0) 0 [1..]
01:57:47 <lambdabot>  0
01:57:49 <abbe> hmm
01:59:06 <[exa]> Hm guys, what's the nicest way to write application GUIs
01:59:28 <abbe> cocreature: yes, makes sense, but unfortunately doesn't quite do what I would like. I guess I will just write that custom folding function, using zipper or continuation seems like overkill
01:59:31 <[exa]> not that I'd be a fan of GUIs but I need something for visualising stuff
01:59:35 <ph88> [exa], in my opinion electron even though i haven't tried it .. but you can use purescript
02:00:35 <[exa]> ph88: not necessarily for web, I thought about something more like Qt or gtk or so
02:01:34 <cocreature> abbe: you can also use scanl' and the afterwards filter to the part that you care about
02:01:44 <rightfold> [exa]: I have had a positive experience with the GTK library bindings
02:01:53 <cocreature> > take (<=30) (scanl' (+) 0 [1..])
02:01:55 <lambdabot>  error:
02:01:55 <lambdabot>      • Couldn't match expected type ‘Int’
02:01:55 <lambdabot>                    with actual type ‘Integer -> Bool’
02:02:05 <cocreature> > takeWhile (<=30) (scanl' (+) 0 [1..])
02:02:08 <lambdabot>  [0,1,3,6,10,15,21,28]
02:02:08 <[exa]> rightfold: good to hear that, thanks
02:02:25 <[exa]> rightfold: any idea if it's portable to windows/mac?
02:02:32 <rightfold> [exa]: GTK or Qt or Cocoa is generally easier than Electron because you don’t have to write all of the controls ourself
02:02:32 <abbe> oh, okay
02:02:44 <xormor> can someone teach me how to do complex number calculations with Haskell? I mean "complex numbers", aka "imaginary numbers", like i=sqrt(-1); i²=-1
02:02:57 <ruzi> any body have some Haskell code for evaluating Riemann Zeta function in critical strip?
02:02:58 <rightfold> [exa]: Likely, since Inkscape also uses it, but I only use GNU/Linux
02:03:05 * Virgo pokes abbe
02:03:36 <abbe> hi!
02:03:41 <[exa]> rightfold: ok thanks!
02:03:54 <Virgo> sup man
02:04:07 <cocreature> ruzi: maybe something in https://hackage.haskell.org/package/arithmoi-0.6.0.0/docs/Math-NumberTheory-Zeta.html ?
02:04:25 <[exa]> rightfold: yeah especially about the controls. It's an app for biologists, look at some data, rotate them around, see if it looks right, click click save
02:04:28 <abbe> Sunday fun work, and you ?
02:05:02 <Virgo> Sunday funday... just seeing what kinda trouble I can cause. Same old same old. 
02:05:51 <Virgo> work that sucks
02:06:17 <abbe> :)
02:06:32 <Virgo> I am really just having my annual final exams melt down 
02:06:51 <rightfold> [exa]: sounds fun
02:07:33 <abbe> i also have an exam due, but not studying
02:07:34 <ruzi> cocreature, looks like it only does calculations on real number line
02:07:40 <Virgo> cursing the reason I am stuck on Earth... the ussual 
02:08:06 <Virgo> Yea... studying is over rated
02:08:20 <[exa]> rightfold: type 2 fun, yes.
02:08:21 <rightfold> I still have a GTK project that I have to work on
02:10:46 <Virgo> hey abbe did we ever finish much on the greenbank project?
02:11:30 * abbe is not who you think they are.
02:11:42 <Virgo> oh shit my bad
02:12:07 <abbe> np, if i'd more i would play along :)
02:12:12 <Virgo> good thing I left out the part about the aliens in my back yard then 
02:12:16 <koz_> vaibhavsagar: Yeah, I have. I might try using it.
02:12:18 * Virgo chuckles
02:12:19 <abbe> s/(more)/\1 time/
02:13:01 <Virgo> eep
02:13:07 <Virgo> yea time to go then
02:36:20 <ruzi> any haskell code for computing Riemann Zeta on critical strip?
02:51:55 <vitamin-q> Hi, I'm currently trying to do the first part of this tutorial: https://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours/Parsing but when I compile my code I get this error:
02:52:49 <vitamin-q> Error is here: https://pastebin.com/raw/bbiFRDLq
02:53:13 <vitamin-q> I've installed parsec and I've even tried building in a cabal sandbox but I get the same error
02:53:33 <vitamin-q> I running Arch Linux
02:57:43 <cocreature> vitamin-q: https://wiki.archlinux.org/index.php/haskell#Building_statically_linked_packages_with_Cabal_.28without_using_shared_libraries.29
03:46:47 * hackage real-day-end 0.0.1 - Tiny library to calculate date considering when your day realy ends  https://hackage.haskell.org/package/real-day-end-0.0.1 (AlekseyUymanov)
04:09:14 * hackage haskell-updater 1.3 - Rebuild Haskell dependencies in Gentoo  https://hackage.haskell.org/package/haskell-updater-1.3 (SergeiTrofimovich)
04:14:20 * hackage haskell-updater 1.2.11 - Rebuild Haskell dependencies in Gentoo  https://hackage.haskell.org/package/haskell-updater-1.2.11 (SergeiTrofimovich)
04:26:21 <rightfold> Is there some library that provides a type for mapping keys to values, where keys expire after a certain period, unless periodically kept alive?
04:34:14 * hackage websockets-snap 0.10.2.4 - Snap integration for the websockets library  https://hackage.haskell.org/package/websockets-snap-0.10.2.4 (JasperVanDerJeugt)
04:35:22 <shapr> GOOD MORNING!
04:37:23 <cocreature> hey shapr :)
04:43:10 <shapr> cocreature: writing any cool code?
04:44:12 <hadecolliday> So what is this language used for
04:44:38 <shapr> hadecolliday: same as other programming languages, just about everything!
04:45:08 <hadecolliday> you have any sample programs that are open source that i can look at?
04:45:15 <shapr> sure, piles of stuff
04:45:42 <shapr> hadecolliday: anything in particular?
04:45:58 <shapr> hadecolliday: here's a window manager: https://github.com/xmonad/xmonad
04:46:14 <shapr> hadecolliday: here's a shell script linter: https://github.com/koalaman/shellcheck
04:46:17 <albertus1> I am using a REST interface to arbitrary PostgreSQL databases in production, it's called "PostgREST" and completely written in Haskell - https://github.com/begriffs/postgrest
04:47:24 <shapr> hadecolliday: what have you implemented in other languages?
04:47:49 <cocreature> shapr: hacking on my recipe management web app that I keep rewriting from scratch every few months to try out some new technology instead of getting into a state where it can actually be used :)
04:48:26 <hadecolliday> well im not very deep in any language but i used python with django to make a website
04:48:43 <shapr> hadecolliday: oh, have you used flask?
04:49:28 <hadecolliday> nah, i heard that django was more clean so i used it cause it was for some team i was on and the code needed to be clean for when i left and somebody else had to take my spot
04:52:01 <shapr> hadecolliday: I wrote a simple comparison with Python flask ( https://github.com/shapr/pyrkle ) and Haskell spock: ( https://github.com/shapr/sporkle )
04:52:06 <bigos> how do I create a cabal file or to compile example using reactive-banana with wx widgets
04:52:52 <bigos> also is there any tutorial that explains how to do it in general that erxplains it in simple language for dummies like me?
04:53:01 <shapr> though I need to clean up the sporkle repo, I forgot I left in some dead code
04:53:13 <hadecolliday> Also how maintained is this language is it being updated and maintained or is it dead
04:53:45 <hadecolliday> Also what is Spock
04:54:54 <albertus1> hadecolliday: the most popular Haskell compiler is under active development, I'd say. this page lists the recent releases: https://www.haskell.org/ghc/
04:57:28 <shapr> hadecolliday: Spock is a Haskell webapp library that works much like the Flask webapp library in Python. The idea is that you hook into a combination of HTTP event and URL to run code.
04:59:42 <shapr> Yeah, Haskell compiler development is very active 
05:02:53 <albertus1> the language "definition" itself was last majorly updated in 2010, I think. if those updates are what you want to occur frequently, then, well. Haskell is a rather "mature" language (it's been around for decades), so it doesn't actually need frequent enhancements like "newer" languages do, I would argue
05:05:44 <hadecolliday> Wait so how old is Haskell?
05:06:29 <albertus1> I think it roots back to the 1980s
05:06:32 <hadecolliday> And if its been around for decades like albertus1 says why have I never heard of it?
05:07:59 <hadecolliday> is there a guide to this IRC thing im not used to this i feel like ive got a hang of it but i feel like im missing a few things
05:12:00 <shapr> hadecolliday: Haskell hasn't been really popular until the past ten years or so, maybe that's why you haven't heard of it before?
05:12:35 <albertus1> hm, what do you mean by "guide"? it seems you're using it successfully already. for understanding the inner workings or concepts, maybe a skim over the wikipedia article is helpful: https://en.wikipedia.org/wiki/Internet_Relay_Chat
05:12:39 <hadecolliday> I just read that and thats because of you right kinda
05:13:21 <shapr> hadecolliday: huh?
05:14:13 <hadecolliday> Wait, no you just got this IRC channel going ... "The #haskell channel appeared in the late 90s, and really got going in early 2001, with the help of Shae Erisson (aka shapr)."
05:14:35 <shapr> hadecolliday: that's true, I got this channel started
05:14:39 <hadecolliday> also why is your name red?
05:14:49 <hadecolliday> is it cause you are like moderator
05:14:57 <shapr> hadecolliday: don't know why my name is red, sorry
05:15:01 <albertus1> hadecolliday: am i red now, too?
05:15:07 <hadecolliday> yes
05:15:13 --- mode: ChanServ set +o shapr
05:15:18 <shapr> is my name red now? :-D
05:15:23 <hadecolliday> no
05:15:25 --- mode: shapr set -o shapr
05:15:26 <shapr> aw, ok
05:15:27 <albertus1> this may be a feature of many IRC client softwares, called "highlight", which occurs on definable words in the text, especially your own name
05:15:44 <shapr> oh, it's when we use your irc nick name to address you directly
05:15:49 <shapr> that's when our name turns red
05:15:56 <DigitalKiwi> shapr is purple 
05:15:58 <shapr> ok, time for coffee and Haskell code!
05:16:01 <hadecolliday> ah!
05:16:05 <shapr> howdy DigitalKiwi ! How's code treating you?
05:16:09 <albertus1> shapr is light blue over here :-)
05:16:26 <shapr> I gotta clean up sporkle today so I can easily compare flask and spock for new people who drop into the channel
05:16:36 <shapr> then I want to dig into some code Ed wrote yesterday
05:16:45 <shapr> I'll be back online later!
05:17:01 <DigitalKiwi> I haven't written any code to speak of in ages...so shrug
05:17:33 <hadecolliday> Go Shapr!
05:38:26 <Jikstra[m]> anyone using haskell-ide-engine? My stack install fails... `/usr/bin/ld: .stack-work/dist/x86_64-linux-tinfo6-nopie/Cabal-1.24.2.0/build/Foundation/System/Bindings/Posix_hsc_make.o: relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC`
05:42:47 * hackage relational-query 0.10.1.1 - Typeful, Modular, Relational, algebraic query engine  https://hackage.haskell.org/package/relational-query-0.10.1.1 (KeiHibino)
06:00:31 <f-a> hello. I have made a small library, compiled with dist-newstyle, everything is perfect
06:00:43 <f-a> this is local, not uploaded to hackage
06:01:21 <f-a> now I am making a small project depending on this library, but putting $LIBNAME in `build-depends` does not work
06:01:44 <f-a> unknown package: some-lib (dependency of something-0.1.0.0)
06:01:52 <f-a> what's the way to approach this?
06:02:36 <f-a> uploading to hackage would to, but it irks me as the library is waaay rough
06:33:26 <erisco> f-a, install it
06:35:44 <f-a> erisco: that sounds reasonable, as the library depends on few things
06:37:10 <cocreature> f-a: does the other person use new-build or stack?
06:38:05 <cocreature> oh you are making the other project yourself
06:38:10 <f-a> cocreature: all by myself
06:38:40 <cocreature> f-a: if you’re using new-build you can just add the path to the package to the "packages" section in your cabal.project
06:39:23 <f-a> cocreature: the ~/.cabal/something path? or the cabal to the project directory?
06:39:45 <cocreature> the path to the project directory containing the .cabal file
06:39:49 <f-a> very good
06:39:50 <f-a> thanks cocreature 
06:47:11 <f-a> cocreature: installing it globally doesn't seem to work with new-build. is that expected?
06:48:02 <cocreature> f-a: depends on what you mean by globally, just installing via "cabal install" isn’t going to work
06:50:15 <cocreature> installing in the global package db in /usr/whatever works afaik but I wouldn’t do that as then there is no way to not have this package in your package db
06:50:32 <f-a> cocreature: cabal install, yeah. but it was erisco that sugg- oh ok, thanks
07:27:33 <ezyang> nshepperd_: Backpack doesn't really solve the orphan instance problem 
07:39:47 * hackage yesod-core 1.4.37.1 - Creation of type-safe, RESTful web applications.  https://hackage.haskell.org/package/yesod-core-1.4.37.1 (MaxGabriel)
07:43:11 * hackage yesod-core 1.4.37.2 - Creation of type-safe, RESTful web applications.  https://hackage.haskell.org/package/yesod-core-1.4.37.2 (MaxGabriel)
07:45:14 * hackage yesod-auth 1.4.20 - Authentication for Yesod.  https://hackage.haskell.org/package/yesod-auth-1.4.20 (MaxGabriel)
07:56:50 * hackage persistent-sqlite 2.6.3.2 - Backend for the persistent library using sqlite3.  https://hackage.haskell.org/package/persistent-sqlite-2.6.3.2 (MaxGabriel)
08:38:04 <ikopico> Hey all, I'm learning Haskell now and am following some books, I'm not new to FP and the theories behind are clear. Can anyone please recommend me of a tutorial for writing applications, using stack? I also would like to understand how the PATH environment can be taken advantage of for writing CLI tools (maybe without adding to PATH but a standard way of installing those to say, /usr/local/bin)
08:48:10 <amf> ikopico: try `stack new --help`, that will use a template to generate example files so you can get started
08:48:31 <amf> ikopico: i also highly recommend using hpack to generate a cabal file from a yaml definition
08:49:18 <ikopico> amf thanks a lot. will try hpack. Is there a community standard of installing packages in a machine without ghc installed?
08:50:07 <ezyang> if you download a working stack binary that will get you bootstrapped 
08:51:33 <ikopico> Sure, I mean, distribute only the compiled package
08:52:25 <amf> ikopico: stack can use either its pre-packaged ghc or the system one.. its best to not use the system one
08:56:29 <rightfold> Why is Stackage Haddock so slow?
08:56:38 <rightfold> What does it need to do more than serving static files?
09:05:38 <lseactuary> can someone help me define types and constrained objects for a scenario. i had an attempt but now confused what to do. 
09:05:45 <lseactuary> Length == N (N is a natural number) Used ::= yes | no ts : seq (Identifier x Length x Used) cumulative_total E seq (Identifier x Length x Used) -> Length   ts: seq(Identifer x Length x Used) ---------------------------------- (constraints below)
09:05:52 <lseactuary> woops
09:05:53 <lseactuary> i mean : https://pastebin.com/6nEwt10P
09:43:52 <lseactuary> anyone here who can help me out please?
09:44:13 <f-a> lseactuary: say the question and wait a bit
09:44:20 <lseactuary> oki
09:44:24 <f-a> not everyone is looking at the screen every time :)
09:44:31 <lseactuary> oki :)
09:47:14 <f-a> lseactuary: maybe if you rewrite it in haskell you might get more answers?
09:47:20 <lseactuary> i put the question and my attempt here: https://pastebin.com/XppBNZAg
09:47:38 <lseactuary> i need to write it in math logic. i asked in math they sent me here. 
09:47:44 <lseactuary> its more the logic. then i can write it up.
09:48:09 <f-a> I suppose Used ::= yes | no means dat- well this is #haskell, a chan for the programming language
09:48:33 <lseactuary> dat- ?
09:48:49 <f-a> data Used = Yes | No
09:49:11 <lseactuary> ah
10:00:53 <kuribas> does flycheck haskell not work with ghc-8.2.2?
10:01:29 <Fooz> Hi!
10:01:33 <Fooz> I'm stuck working with JSON
10:01:45 <Fooz> I ran Attoparsec after reading a file
10:02:00 <Fooz> The result is something like: Done "" (Object (fromList [])
10:02:10 <Fooz> How do I turn this into something I can work with in Haskell?
10:03:23 <Fooz> How do I pattern match against it?
10:05:33 <rightfold> You can use parseOnly instead of parse
10:05:37 <rightfold> This will return Either
10:05:51 <rightfold> Or use decode' from Aeson instead of going through attoparsec
10:10:48 <Fooz> rightfold: I'm having some trouble with Aeson as the JSON I'm decoding has duplicate field names, i.e. the same name for a field at various levels of nesting
10:11:02 <monochrom> The pattern "Done s o" matches your "Done "" (Object (fromList []))" with s = "" and o = Object (fromList [])
10:11:13 <Fooz> rightfold: parseOnly works; now I have an object I can match against
10:11:43 <Fooz> But what is an "Object", how do I turn this into a simple Data.Map?
10:11:57 <Fooz> This sounds so basic, but I'm getting stumped looking for examples..
10:12:00 <monochrom> The "fromList []" there is your Data.Map
10:12:10 <Fooz> monochrom: yes, I figures that out
10:12:13 <Fooz> but what is "Object"
10:12:14 <Fooz> ?
10:12:32 <Fooz> Is there a way to turn the entire nested Object into a nested Data.Map?
10:13:04 <monochrom> The examples don't anticipate you to do things this way in the first place. You're supposed to write a FromJSON instance which doesn't work at this low level.
10:13:28 <Fooz> I feel stupid
10:13:34 <Fooz> I could just match against Object
10:14:07 <monochrom> But Value is a pretty transparent ADT, yeah.
10:15:26 <cocreature> note that "Object" has two different meanings in the context of "aeson", it’s a constructor of the "Value" type and it is a type synonym for "HashMap Text Value"
10:16:29 <monochrom> Oh, right, I misremembered, it's a HashMap not a Map.
10:16:45 <monochrom> I hate type synonyms.
10:21:33 <rightfold> 👍🏼
10:31:17 <Fooz> Is there a canonical way for turning a Vector into a list?
10:31:32 <Fooz> i.e. iterate through all elements, pull them out one by one and store them in a list
10:32:40 <slack1256> what is the simpler option to use regex in haskell?
10:32:43 <slack1256> regex-posix?
10:32:52 <amf> Fooz: Vector.toList :)
10:33:02 <Fooz> amf: thanks!
10:33:16 <amf> slack1256: have you looked at parser combinators?
10:35:13 <cocreature> slack1256: regex-applicative is by far the most pleasant option I’ve used. if you’re looking for a more “traditional” regex library, https://github.com/iconnect/regex seemed pretty good when I last looked at it
10:36:40 * hackage base-noprelude 4.10.1.0 - "base" package sans "Prelude" module  https://hackage.haskell.org/package/base-noprelude-4.10.1.0 (HerbertValerioRiedel)
10:37:19 <slack1256> amf: I know ho to use parsec & attoparsec. But my users don't, they expect to put regexes somewhere
10:37:35 <infinisil> regexes suck
10:40:32 <dmwit> Open challenge: find something that doesn't suck.
10:40:51 <Welkin> parser combinators
10:41:02 <slack1256> they suck less
10:41:19 <cocreature> they suck at different things :)
10:41:19 <dmwit> Parser combinators suck: they have terrible and often undocumented backtracking behavior and surprising asymptotic behavior compared to parser generators.
10:41:37 <dmwit> (And where there is documentation on the backtracking, it is often wrong.)
10:41:40 <cocreature> dmwit: also manually left-factoring grammars is really boring
10:42:25 <amf> dmwit: is there a good library where i can learn more about parser generators?
10:42:36 <dmwit> Parsec is the standard starter pack.
10:42:46 <dmwit> Oh, parser generators. Sorry, I can't read.
10:42:50 <slack1256> also without the help of pipes-parse or the like, tokenizing before parsec if really curbersome
10:42:56 <dmwit> Alex and Happy are the standard pair in Haskell-land.
10:43:14 <Welkin> sucking is a *Feature* for vacuum cleaners!
10:43:16 <dmwit> Outside of Haskell, look at Flex and Yacc or Bison (can't remember which of those two is the more modern one).
10:43:25 <slack1256> they are the yacc & bison from haskell
10:43:31 <amf> ahhhh ok didnt realize alex and happy were called that
10:44:30 <infinisil> We first need to define what "to suck" means before using it
10:44:53 <dmwit> "To suck" is the trivial property which applies to all objects.
10:45:27 <infinisil> sucks = const True
10:45:34 <dmwit> (This makes the challenge problem very difficult.)
10:45:40 <infinisil> :let sucks = const True
10:45:49 <Welkin> use @let
10:45:56 <infinisil> @let sucks = const True
10:45:57 <lambdabot>  Defined.
10:46:08 <infinisil> @ sucks "Haskell"
10:46:19 <infinisil> > sucks "Haskell"
10:46:21 <lambdabot>  True
10:46:25 <infinisil> Oh boy
10:46:50 <Fooz> I have a question regarding Aeson: what is the workaround if the input file has clashing field names, e.g. there is a field "id" in the parent but also the children
10:46:54 <Welkin> > 0 `sucks`
10:46:56 <lambdabot>  <hint>:1:10: error:
10:46:56 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
10:47:00 <Welkin> > 0 `sucks` 1
10:47:02 <lambdabot>  error:
10:47:02 <lambdabot>      • Couldn't match expected type ‘Integer -> t’
10:47:02 <lambdabot>                    with actual type ‘Bool’
10:47:17 <Fooz> Consequently, I can't define records, for instance like this:
10:47:21 <Welkin> I wonder how infix notation works for 3 parameters
10:47:24 <Fooz> https://stackoverflow.com/questions/17844223/json-parsing-in-haskell
10:47:30 <Fooz> ...because GHC rejects the code
10:48:15 <dmwit> Fooz: I don't understand why this needs a workaround. There is no "clash" between parent and children.
10:48:24 <Welkin> it kind of works
10:49:10 <dmwit> Fooz: Ah, you are asking about clashes on the Haskell side? There are two approaches: use modules as namespaces, or use aeson's support for custom prefixes.
10:49:18 <Fooz> dmwit: yes, exactly~
10:49:35 <Fooz> No, let me paste a simple example on lpaste
10:50:31 <dmwit> http://hackage.haskell.org/package/aeson-1.2.3.0/docs/Data-Aeson-Types.html#v:fieldLabelModifier
10:50:34 <dmwit> for the latter
10:50:44 <Fooz> dmwit: here's an example: http://lpaste.net/8229374402488172544
10:51:11 <dmwit> Fooz: After reviewing your paste, my answer stands.
10:51:57 <dmwit> However, I am bad at explaining things, so if my answer is not understandable, you should ask questions to help me explain the parts I didn't explain well.
10:53:27 <Fooz> dmwit: could you possibly look at my lpaste and show me how I could fix the code?
10:53:50 <Fooz> there are only a few examples for fieldLabelModifier online...
10:54:39 <dmwit> No, I am too lazy. Instead, I will help you understand how to fix it yourself. This requires more effort from you and less from me. But that is as it should be: your success is not a blocker for any of my success.
10:55:39 * hackage yesod-auth-bcryptdb 0.1.0.0 - Authentication plugin for Yesod.  https://hackage.haskell.org/package/yesod-auth-bcryptdb-0.1.0.0 (yusent)
10:55:52 <Fooz> dmwit: this fix does not work: "instance ToJSON Person where   toJSON = genericToJSON defaultOptions {              fieldLabelModifier = drop 1 }"
10:56:17 <dmwit> Neat! What goes wrong?
10:56:25 <Fooz> dmwit: GHC throws the same error
10:56:51 <dmwit> Yes, you need to choose different names for the fields of the records in your two types.
10:57:03 <Fooz> dmwit: but then you can't parse it
10:57:33 <dmwit> Then you can fix up the name used by the ToJSON and FromJSON instances to be the "same" for the two types: `fieldLabelModifier` will be given the name of the Haskell record field, and should output the name of the JSON field to use for that.
10:58:50 <romanix> can anyone recommend some useful rts flags for detailed memory profiling? i'm trying to figure out why ekg attached to my app reports 1gb residency and top shows 3.5gb residency
10:59:42 <romanix> i'm guessing it's due to the use FFI is some libraries I depend on but is there a way to show this?
11:01:43 <Fooz> dmwit: how is this supposed to work?
11:02:24 <dmwit> Can you make your question a bit more concrete? (What is "this"?)
11:03:07 <EbleMonado> https://www.youtube.com/watch?v=t1e8gqXLbsU
11:03:30 <EbleMonado> "What is a Monad? - Computerphile"
11:03:34 <EbleMonado> :D
11:05:47 <Fooz> dmwit: I'm using "overloaded string", so the name of the record field is the same as the variable, i.e. the variable 'name' gets turned into the string "name"
11:06:14 <Fooz> So, with 'fieldLabelModifier' I can made some changes to that, when reading
11:06:26 <Fooz> ...from Json
11:06:37 <Fooz> But it is not clear how those two parts of the code even interact
11:06:47 <dmwit> I don't think OverloadedStrings is relevant here.
11:07:14 <Fooz> I think it is, because the record field names have to match the field names of the Json file
11:07:35 <dmwit> No, they don't. fieldLabelModifier gives the connection between record field names and json field names.
11:07:42 <dmwit> By default it is `id`, but you can change it.
11:08:09 <Fooz> OK
11:09:40 <Fooz> dmwit: to clarify, fieldLabelmodifier takes the field name from JSON and tries to match it with a field name in Haskell (in FromJson)?
11:09:59 <dmwit> No, the other way: it takes a Haskell field name and should return the appropriate JSON field name.
11:11:26 <Fooz> dmwit: then I'm stumped; here's what is supposed to happen:
11:11:40 <Fooz> The haskell field name is "_name", and I 'drop 1' to match it with name
11:11:43 <Fooz> Yet, the parse fails
11:11:49 <Fooz> Let me update the lpaste
11:12:03 <dmwit> Yeah, good idea. That is indeed a fun failure mode!
11:12:33 <Fooz> updated: http://lpaste.net/8229374402488172544
11:12:49 <dmwit> fieldLabelModifier gets applied to *all* the field names.
11:13:00 <dmwit> So it's looking for JSON fields "ge" and "ddress".
11:14:38 <Fooz> Perfect; it works!
11:14:41 <Fooz> Thank you!
11:17:57 <dmwit> \o/
11:33:40 * hackage versions 3.3.1 - Types and parsers for software version numbers.  https://hackage.haskell.org/package/versions-3.3.1 (fosskers)
11:46:48 * hackage yesod-auth-bcryptdb 0.1.0.1 - Authentication plugin for Yesod.  https://hackage.haskell.org/package/yesod-auth-bcryptdb-0.1.0.1 (yusent)
11:51:45 * hackage haskell-updater 1.2.12 - Rebuild Haskell dependencies in Gentoo  https://hackage.haskell.org/package/haskell-updater-1.2.12 (SergeiTrofimovich)
12:19:30 <totigno> ciao
12:19:36 <totigno> !list
12:26:13 * hackage github-backup 1.20171126 - backs up everything github knows about a repository, to the repository  https://hackage.haskell.org/package/github-backup-1.20171126 (JoeyHess)
12:32:22 <totigno82> ciao
12:32:59 <totigno82> !list
12:40:39 <leooo>  what does a smirk with prolonged eye contact mean when it comes to flirting?
12:40:53 <monochrom> Off topic.
12:41:50 <qmm> (qux . baz . bar . foo) <- for this, if baz "fails to process", is there a way to return the data as processed by bar?
12:42:11 <monochrom> Unfortunately no.
12:42:26 <[exa]> qmm: how do you recognize that it failed?
12:43:18 * hackage celtchar 0.1.2.0 - A tool to build a novel  https://hackage.haskell.org/package/celtchar-0.1.2.0 (lethom)
12:44:01 <qmm> [exa]: open ended question. i don't have a specific example. 
12:44:58 <Rembane> qmm: You can wrap it all in Either.
12:45:06 <Rembane> qmm: Where all is each funcitonl.
12:45:25 <qmm> is there a way to manipulate a string with a set of changes, and either returning the string as last edited or rejecting the computation entirely 
12:45:43 <qmm> Either could work,is there another way of doing this?
12:47:40 <Eduard_Munteanu> qmm, use a State and look up the last state on failure?
12:48:13 <Eduard_Munteanu> Assuming the last computation only writes the state if it suceeded.
13:15:07 <kw> Is it possible to create an container instance along the lines of `instance (Functor m) => Functor (F (m a)) where ...`, where mapping over `F` automatically maps over `m`?
13:15:47 <cocreature> kw: how is F defined?
13:19:17 <kw> Let's say F is a newtype of Maybe. So I want to be able to say the the composition of Maybe and a functor is also a functor.
13:21:24 <kw> But I don't want to enumerate and make newtypes for all the possible compositions. I just want to say that fmap f (F Nothing) = F Nothing, and fmap f (F (Just something)) = F $ Just $ fmap f something.
13:22:44 * hackage html-tokenizer 0.6.3 - An "attoparsec"-based HTML tokenizer  https://hackage.haskell.org/package/html-tokenizer-0.6.3 (NikitaVolkov)
13:26:16 * hackage postmark-streams 0.1.0.1 - Send email via Postmark using io-streams.  https://hackage.haskell.org/package/postmark-streams-0.1.0.1 (petterb)
13:29:29 <cocreature> kw: you can make a single newtype for the composition of two arbitrary functors and luckily someone has already done that for you https://hackage.haskell.org/package/base-4.10.0.0/docs/Data-Functor-Compose.html#t:Compose
13:34:33 <kw> Thanks, cocreature! That's awesome!
13:37:15 * hackage timezone-olson-th 0.1.0.4 - Load TimeZoneSeries from an Olson file at compile time.  https://hackage.haskell.org/package/timezone-olson-th-0.1.0.4 (petterb)
13:51:18 * hackage yesod-auth-bcryptdb 0.2.0.0 - Authentication plugin for Yesod.  https://hackage.haskell.org/package/yesod-auth-bcryptdb-0.2.0.0 (yusent)
14:00:54 <simplegauss> hi. i am recently back to programming haskell and see a bit of uncharacteristic chaos in the tooling; specifically, i have been trying out ghc 8.2.2 and neither intero nor haskell-mode's built-in repl work with this version. is there a more stable/reliable workflow for emacs, or is the more standard way to develop to just run ghci in a separate window?
14:01:36 <amf> simplegauss: those havent caught up to 8.2.x yet, so sticking with 8.0.x is your only current option
14:05:17 <simplegauss> but i assume people continue to develop software using the new versions of the compilers, i was hoping to hear about those workflows
14:07:26 <Cale> simplegauss: I use ghcid
14:07:35 <Cale> (and ghci in a separate window)
14:08:55 <Cale> (also, I'm still on 8.0.2 for the most part, because ghcjs is)
14:10:26 <Cale> simplegauss: I've never really understood why someone would want ghci to be running inside emacs -- back when I used emacs, I always just ran it in a separate terminal window anyway.
14:11:15 <Cale> (particularly, I found emacs to deal with large output from ghci rather poorly, making the experience worse than if ghci was just running from a separate terminal)
14:11:39 <Cale> But that was a long time ago
14:12:37 <simplegauss> Cale: it's convenient to share keybindings, clipboard, and to have emacs manage the ghci process/arguments.
14:13:39 <simplegauss> Cale: but mostly if i could have function types, completion, and jump to error without running in emacs that would alleviate most of the need to run ghci in emacs
14:13:47 <simplegauss> also slime spoils people :)
14:15:17 <Cale> I dunno. I use hasktags to generate a tags file so that I can jump to definitions (and complete things), and don't tend to care about jump to error, since it's quick enough for me to get to wherever the errors are anyway.
14:15:28 <Cale> Types are obviously available through :t in ghci
14:16:05 <Cale> (or by jumping to definition and then back)
14:17:30 <Cale> Maybe a little more support would be nice sometimes, but I have a hard time caring enough to do anything about it.
14:19:16 <Cale> (If I was going to spend money paying for people to work on tooling, essentially 100% of it right now would be aimed at reducing compile times.)
14:19:43 <simplegauss> Cale: i guess now you use vim? like i mentioned, i think slime spoiled me too much and i'm too used to programming interactively, anything else feels a bit primitive, so i really want to run ghci/get types/everything in-editor. especially for the style of work i do (lots of exploration/trying out small ideas)
14:20:11 <Cale> I used vim for many years, but recently I switched to SublimeText, just to be annoyed at different aspects of the text editing experience
14:23:15 <Cale> The differences between available text editors for the most part aren't really in the range of stuff that changes my life. Multiple cursors in Sublime is surprisingly nice. Most of its other features are annoying, and the syntax highlighting is often incorrect.
14:23:42 <Cale> But for the most part, if it'll convert tabs to spaces automatically, I don't really care.
14:24:16 <Cale> I could be happy enough (i.e. equally annoyed) using gedit or whatever.
14:28:15 * hackage transformers-either 0.0.1 - An Either monad transformer  https://hackage.haskell.org/package/transformers-either-0.0.1 (lambda_foo)
14:39:43 <crucify_me> so I guess foldr and foldl are not rocket science. If I just study scanr and scanl with various functions, the behavior is fairly straightforward.
14:41:01 <crucify_me> if anyone could suggest simple lambda functions to use, aside from (\_ n -> n + 1) , that are interesting and instructive, I'd really appreciate it.
14:41:29 <crucify_me> that would make sense with , say, foldl
14:41:35 <slack1256> church encondings!
14:42:23 <crucify_me> please elaborate friend!
14:42:58 <slack1256> oh with a foldl/foldr. There are more straighforwards uses for those lambdas
14:43:15 <slack1256> One is replicate the behaviour of other functions of list with a correct lambda
14:43:31 <Tuplanolla> > foldr (\ x f -> shows x . f) id [1 .. 4] "" -- Here's a good one, crucify_me.
14:43:34 <lambdabot>  "1234"
14:43:48 <crucify_me> cool !
14:44:16 <slack1256> > foldr (\a acc -> if (a <= 3) then a : acc else acc) [] [1..10]
14:44:18 <lambdabot>  [1,2,3]
14:44:30 <Cale> > foldr (\x xs s -> s : xs (x + s)) (\s -> [s]) [1,2,3,4,5] 0
14:44:33 <lambdabot>  [0,1,3,6,10,15]
14:45:02 <crucify_me> id Tuplanolla ? man I still don't really get id. I learned a bunch of stuff with flip id, const id, but its still a mystery.
14:45:20 <jle`> id is p simple, id x = x
14:45:28 <Cale> There's really not much to get about id
14:45:31 <slack1256> Cale: I have always found confusing those foldr with 3 parameters (and the trick to write foldl from foldr). But this helps!
14:46:06 <crucify_me> but in category theory its crucial with that little jughandle that turns the function 'round
14:46:18 <Cale> huh?
14:46:34 <jle`> > foldr (.) id [(+3), (*8), (^2)] 4
14:46:36 <lambdabot>  131
14:46:42 <monochrom> You don't need category theory for this.
14:46:53 <Cale> Well, the identity arrows are an important part of the definition of a category, sure.
14:47:14 <crucify_me> written on a blackboard, id is like a jughandle (east coast word for freeway turnoff)
14:47:40 <jle`> foldr (+) 0 [1,2,3] is 1+2+3+0, so foldr (.) id [(+3), (*8), (^2)] is ((+3) . (*8) . (^2) . id)
14:47:55 <jle`> here id is just used as like a function that you can compose that doesn't make a difference
14:48:00 <monochrom> id doesn't turn around anything either.
14:48:09 <crucify_me> excellent thanks so much for these examples 
14:48:19 <jle`> yes id does the opposite of turning something around
14:48:21 <jle`> it literally does nothing
14:48:27 <jle`> in composition
14:48:32 <slack1256> monochrom: he is refering to the usual way id is written in diagrams, as an arrow to goes to itself
14:48:47 <crucify_me> yup^
14:49:10 <monochrom> OK, but category theory is completely unenlightening for this.
14:50:04 <monochrom> I have a feeling that I'm watching a 3rd-rate sci-fi movie in which they make up jargons like "quantum SSL Internex tunnel"
14:50:08 <jle`> yes, it's kind of like telling a 1st grader that they need to learn group theory to understand 3 + 0
14:50:12 <crucify_me> so if you tack on id to this ((+3) . (*8) . (^2) . id)  ...
14:50:18 <crucify_me> what does that do?
14:50:30 <jle`> it's the same as (+3) . (*8) . (^2)
14:50:46 <jle`> but if you don't believe me, just try it out :)  or manually expand out the function composition
14:51:12 <jle`> foldr needs a "base case" to fill in for [], so 'id' is the one that doesn't change anything
14:51:26 <slack1256> Has anyone written a helm source for autocompletion of module names?
14:51:30 <crucify_me> thanks! got my day's work cut out :)
14:51:58 <jle`> crucify_me: see if you can prove that (f . id) = f
14:52:06 <jle`> and (id . f) = f
14:52:29 <Zemyla> So showListWith isn't a good consumer, and I thought of a way to fix that.
14:52:32 <crucify_me> but seriously, I have all these notes about foldl. I just want to chuck them. scanl is what explains it, its like a trace
14:52:43 <jle`> all you need to do is expand out the definition of (.), (f . g) = \x -> f (g x)
14:52:53 <jle`> so (f . id) = \x -> f (id x)
14:53:02 <jle`> which is \x -> f x, which is just f
14:53:21 <mniip> you need eta-contraction too
14:53:29 <mniip> (that last fact that you used)
14:53:38 <Zemyla> :t \sh ls s -> (:) '[' $ either id id $ foldr (\x r -> Right $ sh x $ either id ((:) ',') r) (Left $ ']':s) ls
14:53:40 <lambdabot> Foldable t1 => (t2 -> [Char] -> [Char]) -> t1 t2 -> [Char] -> [Char]
14:53:43 <mniip> which uh, extensional equality I guess
14:53:45 <crucify_me> eta reduction, yes very cool
14:54:04 <jle`> try out (id . f) = f, it's even more fun!
14:54:09 <Zemyla> That's the definition I want showListWith (well, showList__ in GHC.Show) to use, because it uses foldr.
14:54:25 <crucify_me> Zemyla, haven't looked at either yet :(
14:54:57 <Zemyla> But yeah, that's a good use for foldr. Try tracing you way through that.
14:55:07 <crucify_me> thanks
14:56:10 * hackage dejafu 0.9.1.0 - Systematic testing for Haskell concurrency.  https://hackage.haskell.org/package/dejafu-0.9.1.0 (barrucadu)
14:56:34 <crucify_me> I mean if you take the simplest case, id of (*) is 1. so with functions, what is the point of using id , whereas in math, the id of (*) has an obvious role
14:57:43 <mniip> sequenceA = traverse id
14:57:45 <int-e> :t foldr id
14:57:46 <lambdabot> Foldable t => b -> t (b -> b) -> b
14:57:53 <Zemyla> crucify_me: It has use in the definition of foldl.
14:57:54 <mniip> or that
14:57:57 <Zemyla> Well, foldl from foldr.
14:58:19 <crucify_me> hmm ok
14:58:19 <Zemyla> :t \f z l -> foldr (\a r x -> r $ f x a) id l z
14:58:21 <lambdabot> Foldable t1 => (t2 -> t3 -> t2) -> t2 -> t1 t3 -> t2
14:58:27 <int-e> @src $
14:58:27 <lambdabot> f $ x = f x
14:58:58 <Zemyla> Where does lambdabot get @src information from?
14:59:09 <mniip> a hand typed file I think
14:59:11 <int-e> it has a text file with definitions, basically
14:59:31 <int-e> so it's often inaccurate and very much incomplete
14:59:55 <mniip> % :info $
14:59:56 <yahb> mniip: ($) :: forall (r :: GHC.Types.RuntimeRep) a (b :: TYPE r). (a -> b) -> a -> b -- Defined in `GHC.Base'; infixr 0 $
15:06:19 <crucify_me> so you can use id as the seed/accum value such as in ? :   foldr (\ x f -> shows x . f) id [1 .. 4] ""
15:07:31 <crucify_me> > foldr (\ x f -> shows x . f) id [1 .. 4] ""
15:07:34 <lambdabot>  "1234"
15:07:47 <crucify_me> how does id work there?
15:07:55 <mniip> here in
15:07:58 <mniip> :t foldr
15:08:00 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
15:08:01 <mniip> b is a function
15:08:27 <mniip> the answer desired for the empty list is a ShowS that does nothing
15:08:31 <mniip> i.e \x -> x
15:09:42 <crucify_me> ok, yeah it just calls for a function there so you use id. no numeric value works
15:12:00 <crucify_me> so mniip where there would normally be an accum value, you put id since it is an immutable value ?
15:12:27 <mniip> what
15:12:28 <crucify_me> nothing is being replaced by a new value
15:12:48 <crucify_me> in say, foldr (+) 0 [2,3,4]
15:12:57 <mniip> that's because there the b is Int
15:13:32 <crucify_me> ok I get it. It's just printing out so we use id
15:13:52 <mniip> look at the type of foldr again
15:13:55 <mniip> (a -> b -> b) -> b -> [a] -> b
15:14:16 <mniip> a is the type of the elements
15:14:22 <mniip> b is anything you choose
15:16:24 <crucify_me> ok thanks mniip .. getting there
15:17:49 <infinisil> e really convenient
15:18:15 <infinisil> why is my message cut off weechat -.-
15:18:43 <infinisil> Damnit, why can't Haskell have named parameters like Idris, they're really convenient
15:20:08 <infinisil> okay they are named i guess, but the convention seems to be to use single letters for types, which makes it really hard to understand
15:21:49 <monochrom> That's a superficial understanding.
15:22:31 <monochrom> There is no point replacing the highly general "a -> a" by any more "meaningful" or longer names.
15:23:08 <infinisil> monochrom: I guess i parameters of types, e.g. this: http://hackage.haskell.org/package/pipes-4.3.7/docs/Pipes-Core.html#t:Proxy
15:23:31 <monochrom> But if you look at Parsec or Megaparsec, you willl see "Parser open -> Parser close -> Parser a -> Parser a" which is just right.
15:23:56 <monochrom> I don't understand "I guess i parameters of types"
15:23:56 <infinisil> monochrom: open, close are type parameters?
15:24:45 <infinisil> i mean parameters of types
15:25:04 <infinisil> actually I'm not sure what I'm even saying
15:26:36 <monochrom> You can talk the the authors of pipes about this, you know, if you see it from pipes.
15:26:53 <monochrom> s/talk the the/talk to the/
15:27:54 <slack1256> what about pipes
15:29:15 <infinisil> Haha, forget what I said, i never said anything
15:29:46 <monochrom> HTM = Human Transactional Memory.
15:30:26 <slack1256> (making the human input 'y' to confirm which transsaction succeds?)
15:32:06 <infinisil> Actually I do have a question regarding pipes
15:32:46 <slack1256> yay
15:33:52 <infinisil> So I'm pretty new to Haskell, and I read the pipes introduction, and it seems like that's what I really need for my project, but I'm not quiet sure
15:34:23 <Clint> what have you got to lose except your time and energy
15:35:00 <infinisil> The program is supposed to be a server, and connecting 2 client together for a game
15:35:08 <slack1256> if you need (effectful) streaming behaviour, pipes / conduit are your friend
15:35:24 <slack1256> conduit argueably has better documentation and is simple overall
15:36:03 <slack1256> pipes is confusing because it has too much type parameters (that don't do much unless you get bidirectional)
15:36:16 <infinisil> All of this is done through a TCP connection, so what I did was to spawn a thread for every client that may update a global shared state of the server (using STM)
15:36:41 <infinisil> and have it do transitions like this.
15:37:12 <infinisil> It's a mess I tell ya
15:37:20 <infinisil> and I'm not even done yet
15:37:38 <infinisil> Can pipes handle such a situation? Is it well suited for this task?
15:38:15 <infinisil> I guess the answer is yes, given I know what I'm doing
15:39:10 <slack1256> I am in favor on minimal working code and only abstract when you need
15:39:25 <slack1256> if using stm and listening manually works for you at the moment I would go for that
15:39:33 <slack1256> (we only have so many hours a day)
15:39:38 <infinisil> Hmm true..
15:40:09 <slack1256> but if you end up needing streaming guarrantee as early termination, safe exception handling or co-routine behaviour well you know you could modify your code to use pipes or conduit
15:40:14 <infinisil> I guess I should first do some stuff with monad transformers, as I only read a tutorial about them, haven't used them
15:40:57 <slack1256> (argueably *the greatest* strenght of haskell is refactoring on a broader sense, so don't worry too much getting the code right the first time)
15:41:32 <infinisil> slack1256: While reading the pipes tutorial made a lot of sense, looking into pipes-networkig, pipes-concurrent was really confusing, as it's not just a simple Producer/Pipe, but rather some abstraction on top of it
15:42:15 <slack1256> yeah, libraries ecosystem are like that. I am not gonna lie, it is hard stuff to get into
15:42:26 <slack1256> so do it only when you *know* you will get the bang for buck
15:42:46 <infinisil> Alright, thanks!
15:43:14 <slack1256> (for example pipes-safe uses a monad transformer for the early termination. That requires knowledge of how transformers work9
15:43:29 <crucify_me> > foldr (.) id [(+3) , (*8) , (^2)] 4
15:43:31 <lambdabot>  131
15:43:52 <crucify_me> so, I'm tripping: isn't there one too many arguments here? ^
15:44:02 <slack1256> @type foldr
15:44:04 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
15:44:13 <alhariel> foldr returns a function in that case
15:44:22 <slack1256> @type foldr (.)
15:44:24 <lambdabot> Foldable t => (a -> b) -> t (b -> b) -> a -> b
15:44:24 <alhariel> the 4 is the argument to that function
15:44:33 <infinisil> sneaky
15:44:35 <slack1256> @type foldr (.) id
15:44:36 <lambdabot> Foldable t => t (b -> b) -> b -> b
15:44:44 <slack1256> @type foldr (.) id [(+3)]
15:44:46 <lambdabot> Num b => b -> b
15:44:48 <slack1256> @type foldr (.) id [(+3)] 4
15:44:49 <lambdabot> Num b => b
15:45:07 <slack1256> you can see it even clearly expanding manually the foldr definition
15:45:23 <crucify_me> one moment
15:45:31 <infinisil> Is there some step-by-step evaluation thing for haskell?
15:45:34 <slack1256> foldr (.) id [(+3)] == (+3) . id
15:45:56 <slack1256> well yeah, just replace the definition various times until you get a value
15:46:07 <slack1256> foldr for list is
15:46:10 <slack1256> @src foldr
15:46:10 <lambdabot> foldr f z []     = z
15:46:10 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
15:46:25 <alhariel> handy
15:46:35 <Tuplanolla> infinisil: http://chrisuehlinger.com/LambdaBubblePop/
15:46:40 <alp> infinisil, it's not for haskell per se, but close enough: https://github.com/well-typed/visualize-cbn
15:46:42 <slack1256> so here your "f = (.)" your "z = id" and the list is clear
15:46:43 <alhariel> does anyone know how to install lambdabot with stack btw
15:46:50 <alhariel> build*
15:47:17 <crucify_me> slack1256, sorry I didn't get all that
15:47:35 <slack1256> which part you didn't get?
15:47:42 <slack1256> the how to expand part?
15:48:20 <crucify_me> "the 4 is the argument to that function ^ "
15:48:27 <crucify_me> member comment
15:48:58 <infinisil> Tuplanolla: Neat!
15:49:08 <crucify_me> frankly I haven't been able to read the signature quite yet
15:49:25 <slack1256> this should be parsed as this (  foldr (.) id [(+3) , (*8) , (^2)]  ) $ 4
15:49:37 <slack1256> ( foldr (.) id [(+3) , (*8) , (^2)] ) $ 4
15:49:40 <infinisil> alp: Also neat!
15:49:52 <slack1256> so the foldr is returning a function
15:53:44 <infinisil> I also looked into pipes-aeson, which has this crazy type: https://hackage.haskell.org/package/pipes-aeson-0.4.1.8/docs/Pipes-Aeson.html#v:decoded (the decoded function)
15:54:26 <slack1256> yeah, that library is the intersection of 2 ecosystems: pipes & lens
15:54:50 <slack1256> I would use just aeson
15:56:54 <slack1256> https://stites.io/posts/2016-04-12-Data-Text.html 
15:57:12 <infinisil> using aeson currently
15:57:13 <slack1256> is this true? UTF16 is faster to encode/decode that UTF8?
15:57:34 <Clint> why wouldn't it be?
15:57:39 <Welkin> who is sam stites?
15:59:04 <slack1256> seems to be /a guy/
16:00:02 <crucify_me> slack1256, thing is, how is 4 a function there? : $ 4  
16:00:55 <Welkin> crucify_me: that is applying a function to 4
16:01:00 <slack1256> ^ that
16:01:05 <Welkin> $ is an infix function (that just does function application)
16:01:12 <Welkin> :t ($)
16:01:14 <lambdabot> (a -> b) -> a -> b
16:01:19 <slack1256> @src ($)
16:01:20 <lambdabot> f $ x = f x
16:01:29 <slack1256> (it is put to avoid parentesis)
16:02:01 <infinisil> Welkin: "sam stites" has a levenshtein distance of 3 to "sams tits"
16:04:20 <crucify_me> so without answering with lambdabot, could I ask, are id and the list [(+3), (*8), (^2)] read as a single argument ? 
16:04:32 * slack1256 someday will use a mixin for text types and everything will be alright on the world
16:04:53 <slack1256> @type foldr (.) id ([+3])
16:04:54 <lambdabot> error:
16:04:54 <lambdabot>     A section must be enclosed in parentheses thus: (+ 3)
16:04:59 <Welkin> function application happens left to right
16:04:59 <slack1256> @type foldr (.) id [+3]
16:05:00 <lambdabot> error:
16:05:00 <lambdabot>     A section must be enclosed in parentheses thus: (+ 3)
16:05:18 <slack1256> @type foldr (.) id [(+3)]
16:05:19 <lambdabot> Num b => b -> b
16:05:27 <slack1256> that's a function
16:06:33 <Welkin> > foldr (.) id [(+ 3)] $ 2
16:06:35 <lambdabot>  5
16:06:38 <Welkin> lol
16:06:45 <Welkin> it's hard to see what that actually does
16:06:49 <Welkin> until you read the type
16:06:51 <Welkin> I couldn't tell
16:07:05 <Welkin> it is really stupid
16:07:18 <Welkin> it is equivalent to (+ 3)
16:07:30 <muyfine> Does anyone have examples of a Free Monad that one of its 
16:07:38 <muyfine> operations consumes the Free Monad?
16:07:45 <muyfine> I have http://lpaste.net/360269
16:07:58 <muyfine> and trying to figure out how to define Group
16:09:32 <muyfine> I thought `Group String (Proto next)` would work, but makeFree gives me hell for trying that
16:09:58 <muyfine> been searching around for examples but haven't been able to find any
16:10:37 <Zemyla> Oh, when will Rep and Rep1 in Generic become injective?
16:10:42 <crucify_me> right, so that entire part, (.) id [(+3), (*8), (^2)] is read as the function ? sorry not clear
16:11:22 <Welkin> crucify_me: no, foldr is used to construct a function that performs all of those operations on a value
16:12:09 <Welkin> it would create a function (+ 3) . (* 8) . (^ 2)
16:12:34 <Welkin> > foldr (.) id [f, g, h] :: Expr
16:12:37 <lambdabot>  error:
16:12:37 <lambdabot>      • Couldn't match expected type ‘Expr’ with actual type ‘b0 -> b0’
16:12:37 <lambdabot>      • Probable cause: ‘foldr’ is applied to too few arguments
16:12:52 <Welkin> > foldr (.) id [f, g, h] x :: Expr
16:12:55 <lambdabot>  f (g (h x))
16:13:54 <crucify_me> Welkin, 'performs all of those operations on a value, so 4 is the value (from far above example?)
16:14:05 <Welkin> `f (g (h x))` is the same as `(f . g . h) x` which is the same as `f . g . h $ x`
16:14:23 <Welkin> crucify_me: yes
16:15:24 <Welkin> the result from foldr is a function
16:15:28 <Welkin> in this case
16:15:46 <Welkin> you can also think of it like this `(foldr (.) id [f, g, h]) x`
16:16:25 <Welkin> the parentheses are not necessary because of the precedence of functon application, but you can add them anyway
16:16:54 <Welkin> and it is left associative, so functions are applied from left to right
16:17:14 <crucify_me> thanks, so by using (.), the argument which would be a simple operator, like (+) , is more complex because (.) is combining ?
16:17:27 <Welkin> `((((foldr (.)) id) [f, g, h])) x` is the same as well
16:18:32 <Welkin> it is because the values you are folding are functions (all of one parameter) and your initial accumulator value is `id`, the identity function
16:19:14 <Welkin> composition `(.)` is being used here to accumulate the list of functions into a single function
16:20:05 <crucify_me> ok so the composition is (.) and the list, which requires just one parameter
16:20:25 <crucify_me> *all of which requires one parameter
16:20:33 <Welkin> I don't understand what you mean
16:20:49 <Welkin> I think it may be a simple misunderstanding of foldr
16:20:53 <Welkin> have you implemented your own foldr?
16:21:00 <crucify_me> (.) doesn't stand alone as an argument
16:21:04 <Welkin> it does
16:21:11 <crucify_me> geez
16:21:12 <Welkin> it takes up one "slot"
16:21:19 <Welkin> :t foldr
16:21:20 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
16:21:25 <Welkin> :t foldr (.)
16:21:26 <lambdabot> Foldable t => (a -> b) -> t (b -> b) -> a -> b
16:21:29 <Welkin> it is the accumulating function
16:21:34 <Welkin> justl ike any other accumulating function
16:22:11 <Welkin> well, those types don't help
16:22:18 <Welkin> because you would have to unify them by hand o.o
16:22:23 <Welkin> but anyway
16:22:35 <Welkin> it is easier to work this out on paper, by hand
16:22:45 <Welkin> to truly understand what is going on
16:22:54 <Welkin> rather than trying to figure it out by running the code
16:23:25 <Welkin> function application has the highest precendence of any operator
16:23:28 <Welkin> it always comes first
16:23:31 <Welkin> and it goes left to right
16:24:10 <aplainze2akind> In the context of a fold, wouldn't it follow the folding order anyway? Is precedence relevant?
16:24:53 <Welkin> so, unless you have some explicit parentheses to tell the compiler otherwise, `foldr g acc xs` is going to be resolved as `((foldr g) acc) xs` no matter what `g`g may be
16:25:06 <Welkin> as long as `g` matches the type that foldr expects
16:25:44 <Welkin> every time you supply a parameter to a function, you can cross it off form the type
16:25:51 <Welkin> :t foldr
16:25:53 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
16:25:56 <aplainze2akind> I mean foldr (.) id [f, g, h] $ x would give (f . g . h . id) x which is (f (g (h x)))
16:27:00 <Welkin> so in this case, once we suppluy it with `g`, we can cross off the first parameter in the type which is `(a -> a -> b)`, so the type now becomes `b -> t a -> b` for some *new* `a` and `b`
16:27:25 <crucify_me> Welkin I get it now. really appreciate it. the accum value represents a combined function of (+3)(*8)(^2) that is applied to 4
16:28:04 <Welkin> crucify_me: yes, the final accumulator value, the end result
16:28:05 <crucify_me> foldr combines the simple math operators to be applied to the last parameter, in this case 4
16:28:42 <crucify_me> by using (.)
16:28:58 <Welkin> yes
16:29:05 <crucify_me> Welkin excellent thanks!
16:29:18 <Welkin> just like you can combine numbers using (+), you can combine functions using (.)
16:29:31 <Welkin> the result of the first is also a number
16:29:37 <crucify_me> I knew that, I was thinking of the accum wrongly
16:29:38 <Welkin> the result of the second is also a function
16:30:47 <Welkin> so in the case of using (.) for your accumlator function, the end result `b` is actually some function `c -> d`
16:31:53 <crucify_me> so id is squeezed in there, but that is still necessary ?
16:32:07 <Welkin> every time you supply a function with a new parameter, you have to cross out that parameter from the type, unify the type the function expects for that parameter with the actual type you have supplied, then update the other variables in the rest of the type to reflect the change
16:32:40 <Welkin> this is easier to show than tell
16:32:47 <Welkin> much easier on paper of course
16:33:12 <crucify_me> ok I get that part, thanks so much, if I could just get the use of id straight...
16:33:28 <Welkin> `id` is used here as a filler value
16:33:34 <Welkin> foldr expects a starting value
16:33:51 <Welkin> `id` works fine because it doesn't do anything
16:34:02 <Welkin> the types work out
16:34:03 <aplainzetakind> It's like 0 for (+)
16:34:33 <Welkin> this way, it is the most generalized that it can be
16:34:38 <crucify_me> exactly. but (.) is in the accum place
16:34:42 <Welkin> so it can work on any list of functions of one parameter
16:34:49 <crucify_me> so id is not in the accum place
16:35:09 <Welkin> (.) is your accumulator function, while `id` is your initial accumulator value
16:35:35 <crucify_me> got it.
16:35:36 <Welkin> sorry, I failed to include `id` in my earlier explanation
16:35:40 <aplainzetakind> Think of foldr as replacing (:) operators with the fuction you give it. So when you fold [f,g,h] = f : g: h : [] with (.), you will have f . g . h . (something to put in place of [])
16:36:34 <Welkin> I really recommend working out the types on paper
16:36:36 <aplainzetakind> Than something is usually chosen to be a "neutral" value for the function you're folding with. Since composing with id is basically not changing anything, that's a sensible start.
16:36:41 <Welkin> I don't think I would have ever understand it had I not done that
16:36:58 <aplainzetakind> s/Than/That/
16:37:04 <Welkin> it really is just basic algebra
16:38:00 <crucify_me> foldr (+) 0 [2,3,4]   is not a good parallel since it appears that the (.) example has an additional parameter
16:38:17 <Welkin> they are equivalent
16:38:19 <aplainzetakind> No. It is an exact analogue.
16:38:29 <Welkin> except that the (.) example will produce a function
16:38:40 <Welkin> the (+) example will produce a number value
16:38:45 <aplainzetakind> Think of functions as objects themselves, on the same level of numbers.
16:39:13 <Welkin> functions are first class, so they can be treated as values
16:39:16 <aplainzetakind> (.) takes two such objects and produces another, just like (+) and numbers.
16:39:34 <crucify_me> its trippy but I see how it works now. 
16:40:25 <crucify_me> its a good thing I made such short work of it. :)
16:40:35 <crucify_me> THANKS
16:40:38 <Welkin> it's time to check up on my farm in stardew valley. I haven't been there in over a year!
16:40:42 <Welkin> I bet my chicken is sad
16:43:06 <crucify_me> you mean we've been at it for a year?
16:43:28 <crucify_me> I thought it was like 8 months
16:46:40 * hackage egison 3.7.6 - Programming language with non-linear pattern-matching against non-free data  https://hackage.haskell.org/package/egison-3.7.6 (SatoshiEgi)
17:03:40 * hackage egison 3.7.7 - Programming language with non-linear pattern-matching against non-free data  https://hackage.haskell.org/package/egison-3.7.7 (SatoshiEgi)
17:20:17 <hariel> crucify_me if both parameters to the folding function are of the same type you could  also use foldr1, which does away with the 'initial value' parameter to foldr
17:27:38 <fragamus> i have a list of values and I want them to be arguments to a function.  
17:27:55 <fragamus> is there a way
17:28:25 <benzrf> the simple answer is that if you want to do that you're probably doing something wrong
17:28:28 <benzrf> what are you doing?
17:29:09 <fragamus> im writing a parser to reassemble a serialized GADT
17:29:26 <benzrf> what are the types of the stuff involved
17:29:54 <fragamus> string integer etc
17:30:21 <benzrf> no i mean the type of the function
17:30:58 <fragamus> its just a constructor for the GADT
17:33:22 <amf> if you have a sum type (e.g. data A = A A1 | B B1, is there a way to have a common function (via records or whatever) access the type inside the constructor?
17:33:48 <infinisil> amf: what type should the function have?
17:34:34 <amf> i want to avoid pattern matching every constructor and just have a getStuff function i can use on the type
17:35:28 <aplainzetakind> amf: I suppose A1 and B1 have the same type?
17:36:03 <amf> no, thats why i chose A1 and B1
17:36:28 <aplainzetakind> Then I don't think it's possible.
17:36:38 <aplainzetakind> What type would getStuff have?
17:36:52 <aplainzetakind> You can't have a well-typed function.
17:37:37 <amf> i believe i want `f :: A -> *`
17:38:05 <amf> (but im pretty sure thats not possible)
17:39:05 <aplainzetakind> I mean, you can have a typeclass method that's polymorphic like that, like read.
17:39:43 <amf> its annoying having to type `x (A a1) = someTypeClasFunc a1; x (B b1) = someTypeClassFunc b1` for >= 10 constructors
17:40:10 <aplainzetakind> Yes' it would be longer than pattern matching.
17:40:14 <infinisil> amf: Well, you need to specify what happens with all cases
17:40:22 <infinisil> that's the entire point of sum types
17:40:48 <amf> i was hoping there was a cleverer / easier way, maybe there isnt
17:41:25 <infinisil> amf: Oh, a1 and b1 share a typeclass?
17:41:49 <amf> in this case yes
17:46:53 <mniip> well, here goes
17:47:45 * hackage hexchat 0.0.1.0 - Haskell scripting interface for HexChat  https://hackage.haskell.org/package/hexchat-0.0.1.0 (mniip)
17:50:42 <mniip> oh shi
17:51:31 * mniip edits the .cabal real quick
17:52:49 * hackage egison 3.7.8 - Programming language with non-linear pattern-matching against non-free data  https://hackage.haskell.org/package/egison-3.7.8 (SatoshiEgi)
17:57:21 <emmanuel_erc> Hello there everyone!
18:03:10 * hackage egison 3.7.9 - Programming language with non-linear pattern-matching against non-free data  https://hackage.haskell.org/package/egison-3.7.9 (SatoshiEgi)
18:27:51 <dmwit> amf: You can write `foo :: (forall a. C a => a -> b) -> A -> b` once and for all.
18:28:12 <dmwit> ?let data Foo = W8 Word8 | W16 Word16
18:28:13 <lambdabot>  Defined.
18:28:47 <dmwit> ?let foo :: (forall a. Num a => a -> b) -> Foo -> b; foo f (W8 w8) = f w8; foo f (W16 w16) = f w16
18:28:49 <lambdabot>  Defined.
18:29:24 <dmwit> :t foo fromIntegral :: Foo -> Integer
18:29:26 <lambdabot> error:
18:29:26 <lambdabot>     • Could not deduce (Integral a)
18:29:26 <lambdabot>         arising from a use of ‘fromIntegral’
18:29:35 <dmwit> Yeah, that's the problem. =P
18:29:43 <Axman6> :t foo (+1)
18:29:44 <lambdabot> error:
18:29:45 <lambdabot>     • Couldn't match type ‘b’ with ‘a’
18:29:45 <lambdabot>         because type variable ‘a’ would escape its scope
18:30:02 <dmwit> Can't do it with Num in a sensible way. There's no way to "leave" a Num instance.
18:30:06 <dmwit> ?undefine
18:30:06 <lambdabot> Undefined.
18:30:41 * hackage egison-tutorial 3.7.9 - A tutorial program for the Egison programming language  https://hackage.haskell.org/package/egison-tutorial-3.7.9 (SatoshiEgi)
18:30:52 <dmwit> ?let data Foo = W8 Word8 | W16 Word16
18:30:54 <lambdabot>  Defined.
18:31:17 <dmwit> ?let foo :: (forall a. (Bounded a, Enum a, Eq a, Integral a, Num a, Ord a, Read a, Real a, Show a) => a -> b) -> Foo -> b; foo f (W8 w8) = f w8; foo f (W16 w16) = f w16
18:31:18 <lambdabot>  Defined.
18:31:35 <dmwit> :t foo toInteger
18:31:37 <lambdabot> Foo -> Integer
18:31:45 <hydraz> ... nice
18:31:51 <Axman6> that'll do it!
18:32:15 <dmwit> :t foo (0==)
18:32:16 <lambdabot> Foo -> Bool
18:32:49 <Axman6> can you do something like... (c Word8, c Word16) => (forall a. c a => a -> b) -> ...
18:32:59 <mniip> hardly
18:33:05 <Axman6> (no, but I'm not even surew what the syntax would look like)
18:33:13 <mniip> you can,
18:33:17 <mniip> but context inference is almost nonexistent
18:33:28 <mniip> you have to be very explicit about what that c is at every use site
18:33:46 <Axman6> yeah
18:34:02 <Axman6> foo @Show ... >_>
18:34:50 <jle`> you can do some cata like thing
18:34:59 <dmwit> And if you need `c x ~ (Show x, Eq x)`...?
18:35:09 <jle`> f :: (A1 -> r) -> (B1 -> r) -> A -> r
18:35:20 <jle`> and so f someFunc someFunc
18:35:23 <Axman6> I wonder if Ed's constraints stuff would make this no insane
18:35:30 <mniip> no
18:35:33 <mniip> well
18:35:35 <Axman6> not*
18:35:37 <jle`> it's probably the most sensible way to do things if you don't have too many constructors
18:35:38 <dmwit> jle`: The original complaint was that this is too repetitive because the plan is to supply the same literal function (but at different types) for the `A1 -> r`, `B1 -> r` values.
18:35:48 <mniip> slightly less insane:
18:35:51 <jle`> yes it is still repetitive, but less so
18:35:54 <dmwit> ...and that there are more than two constructors.
18:36:10 <jle`> it's still repetitive but much less verbose than the original situation
18:36:16 <dmwit> Anyway. I think the right answer is "you're doing something wrong".
18:36:25 <mniip> Dict (c Word8) -> Dict (c Word16) -> (forall a. Dict (c a) -> r) -> Foo -> r
18:36:26 <dmwit> But it's fun to noodle with insufficient data anyway.
18:36:41 <dmwit> jle`: right
18:36:47 <dmwit> agreed
18:36:55 <mniip> dmwit, can't you use let-generalization
18:37:05 <mniip> let g = ... in f g g
18:37:19 <dmwit> cute =)
18:37:21 <mniip> wait I forget, was it let or where that doesn't generalize
18:37:33 <jle`> and it sort of emphasizes the 'higher order functions are often the way to go' thing that you pick up when learning haskell as a beginner
18:37:43 <mniip> yeah no
18:37:48 <dmwit> > let g = (+) in (g 3 3, g 3 3) :: (Int, Double)
18:37:50 <lambdabot>  (6,6.0)
18:37:54 <mniip> higher order functions, dependent typing,
18:37:58 <mniip> looks nice doesn't work
18:38:14 <jle`> i'm talking about my f :: (A1 -> r) -> (B1 -> r) -> A -> r thing
18:38:20 <mniip> type inference goes out of the window
18:38:23 <jle`> doing the constraints magic is definitely....not beginner territory
18:38:32 <dmwit> > let f = (g 3 3, g 3 3) where g = (+) in f :: (Int, Double)
18:38:33 <mniip> oh er, I misread and miswrote higher order as higher rank
18:38:34 <lambdabot>  (6,6.0)
18:38:45 <dmwit> mniip: Seems like both `let` and `where` generalize.
18:38:52 <jle`> it's case that doesn't generalize
18:39:06 <jle`> > case (+) of g -> (g 3 3, g 3 3) :: (Int, Double)
18:39:08 <lambdabot>  error:
18:39:09 <lambdabot>      • Couldn't match expected type ‘Double’ with actual type ‘Int’
18:39:09 <lambdabot>      • In the expression: g 3 3
18:39:13 <dmwit> lambda, too
18:39:30 <mniip> lambda is expected
18:39:50 <mniip> :t (\x -> case x of x -> x)
18:39:52 <lambdabot> p -> p
18:40:03 <Gurkenglas> Could we have "uninlining pragmas" which derive hlint rules?
18:40:07 <jle`> superspecialization
18:40:43 <mniip> I guess what you can say is,
18:40:55 <jle`> :t (\x -> let z = y where y = x in case z of q -> q)
18:40:57 <lambdabot> p -> p
18:40:58 <mniip> you can't pattern match on qualified identifiers
18:41:26 <mniip> the context is floated around the case
18:41:58 <mniip> :t case fmap id of _ -> ()
18:42:00 <lambdabot> error:
18:42:00 <lambdabot>     • Ambiguous type variable ‘f0’ arising from a use of ‘fmap’
18:42:00 <lambdabot>       prevents the constraint ‘(Functor f0)’ from being solved.
18:42:06 <mniip> yeah
18:42:28 <dmwit> Did you really mean "qualified identifiers"?
18:42:38 <dmwit> :t case True of Prelude.True -> "ya"
18:42:40 <lambdabot> [Char]
18:43:33 <mazeto> :)
18:43:44 <Axman6> heh
18:43:57 <geekosaur> or equivalently "how exactly did you mean 'qualified' there?"
18:43:59 <Axman6> I don't know why I found thatso funny, but that was a great response
18:45:03 <mniip> uhh
18:45:08 <mniip> I might have forgotten a word
18:45:44 * hackage elocrypt 2.0.0 - Generate easy-to-remember, hard-to-guess passwords  https://hackage.haskell.org/package/elocrypt-2.0.0 (sgillespie)
18:45:44 <mniip> basically a type with no contexts
18:50:48 <hariel> the haskell report is such a sweet read compared to the c++ standard
18:53:46 <mniip> haskell has parametric rules
18:53:50 <mniip> C++ has ad-hoc rules
19:07:12 <emmanuel_erc> I want to ask a question about an implementation of cartesian and treaps I just wrote. (Here is the gist: https://gist.github.com/emmanueldenloye/d25ebf556f3db4fb72b40bb157aab7db/revisions). I want to ask, if it is possible to not allow/require a particular class function to be in effect for a particular instance of that class?
19:07:57 <emmanuel_erc> In particular, looking at my example, is it possible to have "priority" function for CTree not defined (without a cheap undefined)?
19:08:09 <emmanuel_erc> Sorry, let me put the actual link
19:08:25 <emmanuel_erc> here is the link: https://gist.github.com/emmanueldenloye/d25ebf556f3db4fb72b40bb157aab7db
19:11:07 <Axman6> you could make a new class which requires CartesianTree which only has priority in it
19:11:36 <Axman6> class CartesianTree c k v p => CartesianTreePriority c k v p where priority ...
19:11:44 <emmanuel_erc> Axman6: that is a good suggestion
19:12:35 <emmanuel_erc> Axman6: I'm a little frustrated that that did not occur to me.
19:14:22 <emmanuel_erc> Axman6: Thanks!
19:14:24 <Axman6> classes should generally be as small as they can be (though there are often good reasons to put functions which can be derived by other functions in the class to allow for optimisations, such as Monoid and Foldable IIRC)
19:14:51 <emmanuel_erc> Is my class too big?
19:15:28 <Axman6> I don';t understand it well enough ti know =)
19:15:52 <joshuahorwitz> Evening all
19:16:19 <emmanuel_erc> Axman6: Well, in any case, thanks again!
19:42:10 * hackage glambda 1.0.2 - A simply typed lambda calculus interpreter, written with GADTs  https://hackage.haskell.org/package/glambda-1.0.2 (RichardEisenberg)
19:50:09 <shapr> is that like glamping?
19:56:25 <Gurkenglas> What was the name of that evaluation model that reduces 2D diagrams to simpler diagrams by applying local rules?
19:59:36 <mmaruseacph2> graph rewriting?
20:13:11 <butterthebuddha> https://gist.githubusercontent.com/anrdh/cd2e62375304e1acd9d659c0da853ef3/raw/1254339ea201e244ed45285b5d51a9947c34e0fc/indexJ.hs
20:13:12 <butterthebuddha> Why can't I eta-reduce the function "toInt"?
20:13:39 <erisco> butterthebuddha, why do you think you cant?
20:13:48 <butterthebuddha> erisco: I'm getting a type error when I do
20:13:57 <erisco> well then you didn't eta-reduce it
20:14:20 <butterthebuddha> erisco: eta-reduction here would just be getting rid of the "a" in the declaration right?
20:14:29 <erisco> eta reduction is  λx.fx → f
20:14:52 <erisco> first put your expression in the form on the LHS
20:14:57 <erisco> then you can apply the reduction
20:17:27 <mniip> eta reduction is (\x -> f x) into f
20:17:38 <mniip> but that's an AST transformation not string substitution
20:17:47 <mniip> if f = y + z
20:17:56 <mniip> then f x != y + z x
20:18:12 <mniip> because operators bind more tightly than juxtaposition
20:19:49 * hackage postgres-websockets 0.4.2.0 - PostgREST extension to map LISTEN/NOTIFY messages to Websockets  https://hackage.haskell.org/package/postgres-websockets-0.4.2.0 (diogob)
20:31:46 <Axman6> f x = ((+) y z) x
20:44:10 * hackage rebase 1.2.1 - A more progressive alternative to the "base" package  https://hackage.haskell.org/package/rebase-1.2.1 (NikitaVolkov)
20:54:30 <mniip> lol
20:54:38 <mniip> I just realized how consistent my code is...
20:54:40 <mniip> 		liftIO $ traverse deinitScript =<< readIORef scripts
20:54:41 <mniip> 		liftIO $ readIORef borrowedStrings >>= mapM free
20:55:05 <mniip> on adjacent lines, too
20:56:24 <Axman6> could also be one do block, liftIO $ do
20:56:54 <mniip> yeah there's a bit of a problem with this do block
20:57:26 <mniip> https://github.com/mniip/hexchat-haskell/blob/master/plugin/HexChat/Linker.hs#L167-L173
20:57:43 <mniip> in theory I could need the GhcMonad for something in that block but in practice I do not
20:57:55 <mniip> but it's there because in theory I might
21:22:22 <walwa> Hi, pure maths student here. I know a little bit about category theory and type theory, and briefly about logic. For the purposes of mathematical growth, would learning haskell benefit me? There are some people in my classes who think that haskell is cool, and I want to know what the hype is about
21:22:43 <erisco> if you want to program stuff, go for it
21:22:44 <walwa> For reference, I already know Java and C from earlier, so programming itself is not new to me
21:23:07 <mniip> walwa, yes
21:23:22 <Cale> walwa: Given your mathematics background, you might find programming with Haskell more satisfying -- at least I did.
21:23:39 <walwa> I don't want to create stuff for the purpose of creating it. Though I suspect that learning haskell would help me become better at math in some way?
21:23:48 <Cale> A big reason is that you can (and generally will) think equationally about what Haskell programs mean.
21:24:39 <mniip> haskell helped me get a lot better at math - but at the time I was still at school
21:24:52 <Cale> walwa: I don't know if it'll do that, but it helps make programming feel more like the same stuff as mathematics.
21:25:20 <mniip> !
21:25:24 <erisco> if you want to apply type theory in a more mathematical setting then try a proof assistant
21:25:27 <mniip> exactly but reverse
21:25:39 <mniip> mathematics started feeling a lot like programming after I learned haskell
21:25:39 <walwa> Cale: programming/making stuff doesn't really attract me at the moment because I have no idea of anything to program, nor do I feel the drive to create something
21:26:20 <erisco> Haskell is a language suited to make programs that execute and do IO stuff
21:26:36 <mniip> haskell is a language where you don't know to create anything
21:26:43 <Cale> haha
21:26:47 <mniip> I often just make something in ghci on a whim
21:27:21 <mniip> one of its greatest alleged weaknesses is also the strong point!
21:28:27 <Cale> walwa: But if you're really interested in studying type theories further, or want to get into homotopy type theory, well, Haskell might be a reasonable stepping stone, but you might be better served learning Coq or Agda.
21:29:14 <Cale> However, I would strongly recommend developing some programming skill on the side if you're doing a degree in pure mathematics.
21:29:58 <Cale> (My degree is in pure mathematics, but I work as a software developer, writing web and mobile applications in Haskell using functional reactive programming.)
21:29:59 <erisco> Haskell not being total is not so great logically… some practical benefits for programming though
21:30:08 <walwa> Cale: I already have knowledge of Java and C
21:30:18 <walwa> But maybe you mean that you recommend me to have more experience
21:30:40 <Cale> Well, okay :)
21:31:10 <mniip> "have knowledge of"
21:31:23 <Cale> Haskell helps you to see the connection between what you're doing when you write programs to satisfy types, and what you're doing when you write proofs to satisfy theorems.
21:31:48 <Cale> So, at least for me, it was pretty helpful in becoming a much better programmer than I was.
21:31:55 <mniip> ^ pretty much any statically typed functional language
21:31:59 <mniip> and it has a name
21:32:05 <walwa> mniip: Have done a lot of project euler problems in them, and done some game development in C a long time ago
21:32:06 <erisco> don't say it
21:34:05 <Cale> The Curry-Howard correspondence works more strongly in total dependent languages like Coq and Agda -- when regarded as a logical theory, Haskell is inconsistent because it admits general recursion.
21:34:29 <mniip> loose reasoning is morally correct
21:34:31 <Cale> But it *can* be regarded as something like a logical theory regardless.
21:34:46 <mniip> https://pdfs.semanticscholar.org/a316/3d9097a87a713f0dd3f154f139e19dcb2a82.pdf
21:35:18 <erisco> morality is subjective
21:37:46 <Cale> Well, really the thing which saves the language isn't that the inconsistency can be ignored, but rather that it has an interesting semantics. When you begin to care *which* proofs of any proposition exist because they have meaning beyond verifying something, that is, rather than *whether* there is a proof, inconsistency might be okay.
21:38:33 <erisco> Inconsistent isn't a problem so long as it is.
21:39:39 <Cale> The linked paper is about translating equational proofs from a total language such that they express something about a non-total one -- so you get some of that too.
22:23:29 <moet> is there a convenience function similar to Data.Text.split but for which the following is true? (Data.Text.concat . Data.Text.split fn == id)
22:23:41 <moet> for some predicate `fn`
22:24:18 <moet> i wrote one using Data.Text.break and Data.Text.uncons, but it's clunky
22:26:09 <moet> another way to word the question: Is there a function like Data.Text.split which doesn't consume the delimiters?
22:35:40 * hackage orgstat 0.1.3 - Statistics visualizer for org-mode  https://hackage.haskell.org/package/orgstat-0.1.3 (volhovm)
23:33:42 <infinisil> I have a feeling that STM shouldn't be used with StateT and such
23:36:37 <infinisil> Wait no, this should be entirely possible
23:37:45 * hackage nix-diff 1.0.0 - Explain why two Nix derivations differ  https://hackage.haskell.org/package/nix-diff-1.0.0 (GabrielGonzalez)
23:46:47 <nshepperd_> StateT over STM eh
23:52:27 <infinisil> nshepperd_: I'm just wondering why TVar's aren't MonadState's
23:52:27 <rightfold> Why not?
23:53:23 <rightfold> StateT is a wrapper for functions of the form s -> m (a, s). If you need to work with functions of that form a lot, StateT is a good solution.
23:56:54 <tdammers> particularly, StateT can trivially backtrack
23:58:11 <infinisil> Hmm, what's the first s and the second one in s -> m (a, s) ?
23:58:43 <tdammers> that's the "state"
23:58:47 <tdammers> the thing you're dragging along
23:58:58 <tdammers> the first one it the state going in, the second one is the modified state going out
