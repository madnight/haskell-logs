00:00:40 <nshepperd> ij: Certainly. I would suspect that you can rewrite your function to only use l once
00:01:02 <nshepperd> the use of 'traverseOf _3' twice looks suspiciously redundant
00:02:56 <nshepperd> if not, you can use ATraversal/cloneTraversal or ReifiedTraversal/runTraversal to make the function accept a full traversal while still being rank-1
00:04:17 <nshepperd> > (\tr -> ([1, 2, 3] ^.. tr, (tr ~+ 1) [1, 2, 3])) traverse
00:04:19 <lambdabot>  error:
00:04:19 <lambdabot>      • Variable not in scope:
00:04:19 <lambdabot>          (~+) :: Getting (Endo [a]) [a] a -> Integer -> [Integer] -> b
00:04:45 <ij> What would I need to learn in order to be able to write one myself?
00:07:32 <nshepperd> > (\tr -> ([1, 2, 3] ^.. tr, [1, 2, 3::Int] ^? tr)) traverse -- fails because tr is used at two different types
00:07:34 <lambdabot>  error:
00:07:35 <lambdabot>      • Couldn't match type ‘Endo [Int]’ with ‘First Int’
00:07:35 <lambdabot>        Expected type: Getting (First Int) [Int] Int
00:07:58 <nshepperd> > (\tr -> ([1, 2, 3] ^.. cloneTraversal tr, [1, 2, 3::Int] ^? cloneTraversal tr)) traverse -- works because tr is used at one type
00:08:01 <lambdabot>  ([1,2,3],Just 1)
00:08:08 <nshepperd> :t cloneTraversal
00:08:10 <lambdabot> Applicative f => ATraversal s1 t1 a1 b1 -> (a2 -> f b2) -> s2 -> f t2
00:09:02 <osa1> hmm nice microlens lenses can be used with lens
00:09:36 <nshepperd> ij: https://stackoverflow.com/questions/23424203/using-a-lens-twice
00:10:52 <nshepperd> I'm not sure how to explain what ATraversal does lol
00:11:11 <cocreature> tbh I’d jjust use a RankNType
00:11:55 <phadej> with ATraversal inference would work beteer
00:12:17 <phadej> but otherwise it's mostly a choice of taste indeed
00:13:08 <phadej> (the inference is one reason why
00:13:10 <phadej> :t view
00:13:12 <lambdabot> MonadReader s m => Getting a s a -> m a
00:13:25 <phadej> takes `Getting a s a` and not `Getter s a`)
00:14:27 <cocreature> fair point, a RankNType just seems a lot clearer to me than ATraversal
00:19:08 <nshepperd> it's easier to understand how ReifiedTraversal works since it literally just packages up the forall f. 'newtype ReifiedTraversal s t a b = Traversal { runTraversal :: forall f. Applicative f => (a -> f b) -> s -> f t }'
00:19:35 <nshepperd> but then putting on the newtype wrapper is an annoyance that makes you wish you'd just used a RankNType :)
00:20:45 <phadej> hmm. I had to add newtype around rank-n-types to remove completely unnecessary use of ImpredicativeTypes
00:21:14 <phadej> (otoh, it's kind of cool that warp uses impredicative types ;))
00:22:11 <cocreature> oh it does? wasn’t aware of that
00:23:31 <phadej> cocreature: for this one: http://hackage.haskell.org/package/warp-3.2.13/docs/Network-Wai-Handler-Warp.html#v:setFork
00:23:36 <nshepperd> madness
00:24:26 <cocreature> and it has managed to not break with newer ghc releases? impressive :)
00:24:33 <phadej> http://hackage.haskell.org/package/warp-3.2.13/docs/src/Network-Wai-Handler-Warp-Settings.html
00:25:27 <phadej> I was kind of surprised (I reaped parts of warp to make own (non-http)-server)
00:27:05 <phadej> but it's a real challenge for type-checker when you have a lens to a field of such type ;)
00:27:35 <phadej> So to stay sane, I wrapped it in newtype - because I don't think I need to use non-default that often
00:30:19 <nshepperd_> Isn't impredicative when you instantiate a type variable with something containing a forall?
00:33:46 <nshepperd_> A couple of people said in here that that is completely broken in ghc right now
00:34:17 <nshepperd_> But i guess i don't know what "completely" or "broken" means there
00:48:02 <fragamus> Cale: that deriving instance thing is really great.  Thank you
00:51:25 <isaac__> What would it take (or is it even theoretically possible) to be able to write an "n-functor" class?
00:51:43 <isaac__> Such that `Functor ~ NFunctor 1` and `Bifunctor ~ NFunctor 2`, and so on
00:52:22 <isaac__> I'm moderately sure you can't do this in Haskell, having hacked around for the past couple of hours
01:00:14 <muzzle> am I missing something or is it really annoying to work with 2 or three-dimensional vectors?
01:00:26 <muzzle> specifically mutable vectors in the ST monad
01:00:46 <muzzle> The array library has a much nicer interface IMO
01:00:51 <muzzle> but no 'slice' operation
01:00:59 <muzzle> which is really useful
01:01:10 <muzzle> is there a common workaround for this?
01:01:23 <Ferdirand> by 2 or 3-dimensional vector, you mean matrices and "rank 3 tensors" or something ?
01:01:39 <muzzle> Ferdirand: matrices mostly
01:01:54 <muzzle> I'm currently working on some dynamic programming problems for which I use matrices
01:03:14 <Ferdirand> isn't there an operation that applies a contravariant map on the index, or something ?
01:04:41 <Ferdirand> mapIndices
01:04:45 <Ferdirand> not a true slice, but
01:05:02 <muzzle> ixmap?
01:05:42 <muzzle> Ferdiran isn't that only used to map over array indices?
01:06:04 <muzzle> but I can't "get rid of" indices i want to exclude
01:21:01 <wzy8L-B2[m]> As far as I know you're not supposed to use mutable arrays for dynamic programming in hashell, that's probably why it doesn't work very well
01:21:54 <wzy8L-B2[m]> muzzle:
01:23:03 <muzzle> it works really well actually
01:23:09 <muzzle> it's just annoying to write
01:25:12 <muzzle> wzy8L-B2[m]: are there other well-performing alternatives to arrays?
01:28:22 <wzy8L-B2[m]> muzzle: I must admit that I'm no expert on this but have you read the wiki pages on dynamic programming and memorization?
01:30:11 <cocreature> using arrays is completely fine
01:30:26 <cocreature> but sadly it can be quite annoying to work with multi-dimensional vectors
01:33:27 <edwardk> isaac__: you could do it with the sort of generalized Functor/Category stuff i like to use. e.g. https://gist.github.com/ekmett/b26363fc0f38777a637d 
01:34:11 <muzzle> As far as I can tell nothing is actually faster than to use unboxed Double arrays/vectors
01:34:14 <edwardk> require that an NFunctor matches that you have at least N-1 levels of "Nat" in the Cod
01:34:58 <edwardk> easier using a proper inductive data type than the built-in Nat
01:46:45 <isaac__> Wow this is some serious stuff
02:01:42 <isaac__> What's the best thing(s) to read so that this is all "intuitive" to me? Category theory stuff I guess?
02:02:26 <merijn> isaac__: What specifically?
02:02:34 <merijn> isaac__: (I missed the discussion before)
02:03:58 <isaac__> merijn: Context: I asked if one could write some "NFunctor" class, from which Functor and Bifunctor could be derived
02:04:06 <isaac__> Ed replied with this file https://gist.github.com/ekmett/b26363fc0f38777a637d
02:04:29 <merijn> isaac__: Hah...that might be the one case where reading up on CT might actually be relevant...
02:04:45 <merijn> And I was almost done typing up my anti "should I learn CT?" rant :p
02:04:50 <isaac__> Said that you might be able to use that technique
02:04:59 <isaac__> Hahaha
02:05:50 <isaac__> There is a talk about this file https://www.youtube.com/watch?v=ZL9ehIJhk98
02:05:55 <merijn> isaac__: Also, for these obscure things, don't underestimate the power of reading the GHC manual section on extensions and lots of fiddling/playing around to see if you can make it work
02:06:05 <merijn> isaac__: It's a good way to learn
02:06:31 <merijn> I don't see an obvious to make an NFunctor class, but you might be able to manage with -XKitchenSink and some hasochism
02:06:51 <isaac__> This is my attempt https://gist.github.com/LightAndLight/1c662f5951c23555208163dec519ce22
02:07:10 <isaac__> Everything up to the class definition type checks
02:20:14 <merijn> isaac__: I don't see any obvious problem, but I'm a bit to busy to dive into the details of that, sorry
02:21:21 <isaac__> merijn: Oh yeah, don't think about it too hard. It's something to do with the `nmap`'s type being the result of a type family
02:21:28 <merijn> isaac__: I have some similar abuse that might give some inspiration, but I think you've already got most of those ideas covered
02:21:53 <merijn> https://gist.github.com/merijn/6130082 https://gist.github.com/merijn/39dc86e345e87276c523 https://gist.github.com/merijn/dc00bc7cebd6df012c5e https://gist.github.com/merijn/6a0126db702b3d109e508f442581eec9
02:28:21 <Xandaros> Are there any resources on interfacing with foreign (C) libraries specifically written for the project? i.e. I don't want to just create bindings to a pre-existing C library but rather write parts of my application in C and bundle that code with it (ideally in the static executable - not sure how feasible that is)
02:30:38 <merijn> Xandaros: Why would there be any difference between those two? :)
02:31:34 <Xandaros> One assumes existance of the library in the environment, one needs stuff to be deployed, too. (I suppose this is kind of similar to C++ bindings, since those need a C wrapper, actually)
02:31:40 <merijn> Xandaros: libraries and object files are all the same from the linker's perspective and the FFI really deals with linking stuff. So if you just wanna link some C objects into your executable there's no difficulty there
02:32:32 <merijn> Xandaros: Cabal needs a library specification and maybe pkgconfig info for the library, but from a "what does my haskell code look like?" perspective there isn't really much difference
02:32:55 <merijn> Xandaros: Anyway, step 1 should be "read chapter 8 (the FFI chapter) of the haskell report"
02:33:02 <Xandaros> Yeah, it's more about the entire process. Will do that :D
02:33:20 <merijn> Xandaros: Assuming you know C and linking that should teach you 90% of what you need to know
02:33:22 <Xandaros> (I'm also using stack. Don't know how much that complicates matters)
02:33:41 <merijn> Xandaros: I have no clue how stack works, so can't help you there :p
02:34:25 <merijn> Xandaros: And I have a super small (1 haskell file, 2 C files) library that does exactly what you said, ship with some simple C code to be called from Haskell: https://github.com/merijn/posix-pty
02:35:18 <Xandaros> Ah, thank you! That is very handy
02:41:40 <Dnsk_> Karolina Petrželková [11:24 AM]  Hi guys,  I would like to invite you to meetup called LambdUp. The meetup will be held on December 6, 2017 in Prague. The program of meetup will be about functional programming where you can meet names like Eric Normand, Claudio Ortolina, Andrea Leopardi and more great speakers. Let’s join us and get to know more about Elixir, Clojure, F# and Elm. More info: https://www.lambdup.io
03:30:11 <Brocoli> Hello Guys! 
03:30:19 <Brocoli> data Bank = Bank [(ID,Account)] deriving Show
03:30:37 <Brocoli> how do i declare an object of the type bank? should I declare it with the [] or just like a tuple
03:31:51 <Hafydd> Brocoli: "bank :: Bank" to declare its type, and "bank = Bank [(id1, acc1), (id2, acc2), ...]" to declare its value.
03:32:20 <Hafydd> Brocoli: but it's not clear what you mean by "with the [] or just like a tuple".
03:32:40 <Xandaros> "Bank []" is a perfectly valid value of type Bank
03:32:56 <Xandaros> (If that's what you're asking...)
03:33:04 <Brocoli> i mean somthing like this Bank (x1, (Account x2 y)) or like this Bank [(x1, (Account x2 y))]?
03:33:23 <boj> the latter
03:33:26 <Brocoli> i have tried with []
03:33:29 <Hafydd> Brocoli: do you understand that as defined above, a Bank can contain multiple accounts?
03:33:29 <Xandaros> The latter, it's still a list
03:33:41 <Arguggi> I can't build basement-0.0.4 with cabal (both in a sandbox and with new-build), build errors: http://lpaste.net/360235 , something about hsc2hs missing a template, any ideas?
03:34:08 <Brocoli> Hafydd: Ya i know
03:34:30 <Hafydd> Brocoli: so it wouldn't make any sense to declare a Bank with a tuple argument. The argument has to be a list.
03:34:40 <Brocoli> Hafydd: but i have tried with []and a error is occured
03:35:17 <Xandaros> merijn: What happens if you pass something like a CString to a C function that modifies this CString? (Well, char*). Does it make a copy beforehand or will all hell break loose?
03:35:28 <Hafydd> Brocoli: the square brackets are likely not at fault. What is the error, and what is the code?
03:35:54 <Brocoli> Hafydd: please wait a few minute
03:36:05 <merijn> Xandaros: CString is a "Ptr CChar", so you can't observe changes without IO anyway
03:36:26 <merijn> Xandaros: You can only observe data behind a Ptr via peek/poke which are in IO
03:36:33 <Xandaros> Hmm, that's fair
03:36:44 <merijn> Xandaros: But yes, if the C function modifies the memory that will be visible from Haskell
03:37:57 <Xandaros> Ah. I was going to convert a ByteString to a CString and indeed, the docs do say it makes a copy :D
03:46:07 <Brocoli> Hafydd: I slightly simplify the trick
03:46:22 <Brocoli> Hafydd: i have map (+3) [(1,2), (2,3)]
03:47:23 <Brocoli> Hafydd: i want to apply map(+3) only of the second member of the tuple
03:47:23 <Hafydd> Brocoli: map (+3) [(1,2), (2,3)] means [(1,2)+3, (2,3)+3]. Do you see how that is erroneous?
03:47:34 <Hafydd> Brocoli: in that case, you should use map (map (+3)).
03:47:42 <Hafydd> Brocoli: er, I mean: map (fmap (+3)).
03:48:23 <Hafydd> That is [fmap (+3) (1,2), fmap (+3) (2,3)] = [(1,2+3), (2,3+3)].
03:49:03 <Brocoli> Hafydd: oh so thanks :)
03:51:27 <Hafydd> If you wanted to do it to the first element, or to a tuple of size 3 or greater, it would a bit more verbose using just Prelude functions.
03:51:52 <Hafydd> But it happens that there is a Functor instance for (,) that affects the second element.
03:52:48 <Hafydd> > map (swap . fmap (+3) . swap) [(1,2), (2,3)]
03:52:51 <lambdabot>  [(4,2),(5,3)]
03:53:10 <Hafydd> > map (\(x,y) -> (x+3,y)) [(1,2), (2,3)]
03:53:13 <lambdabot>  [(4,2),(5,3)]
03:56:59 <osa1> can I tell just by looking at `+RTS --help` output whether an executable has threaded runtime?
03:59:38 <merijn> osa1: As a user or within the code?
03:59:53 <merijn> osa1: As a user you'd just use ldd/otool -L/whatever windows has
04:01:15 * hackage boolean-normal-forms 0.0.0.2 - Boolean normal form: NNF, DNF & CNF  https://hackage.haskell.org/package/boolean-normal-forms-0.0.0.2 (phadej)
04:01:50 <osa1> ldd makes sense
04:01:53 <osa1> yeah I just have the binary
04:02:39 <osa1> any symbols to look for? the binary may be statically linked
04:02:53 <merijn> No idea, tbh
04:03:20 <osa1> does +RTS -N work with non-threaded runtime?
04:06:49 <carbolymer> osa1, maybe readelf yourbinary | grep thread ?
04:15:20 <Brocoli> bac = Bank [(1, acc), (2, acc), (3, acc)]
04:15:31 <Brocoli> ro = filter(\(x, y) -> x >= 1 && x <= 2) bac
04:15:46 <Brocoli> Error:  Couldn't match expected type ‘[(a, b)]’ with actual type ‘Bank’
04:15:55 <Brocoli> how can i fix this?
04:19:11 <Brocoli> Hafydd: do you have any idea about that? 
04:19:53 <lyxia> Brocoli: filter takes a list, bac is a Bank.
04:21:51 <Brocoli> lyxia: how can i write it differently?
04:23:12 <Xandaros> If you know about functors, make it one. If not, extract the list from the Bank first (e.g. by pattern-matching), then apply filter on the list. You can put the filtered list into a Bank again afterwards, if you like
04:25:21 <Xandaros> Eh, disregard the functor part. This may be too concrete to become one
04:30:48 <numee> Is it possible in Haskell (with GHC extensions) to achieve this dependently-typed program?
04:30:49 <numee> data Color = R | G | B; data A = X (c :: Int) (ColorToType c)
04:30:49 <numee> ColorToType R = Int; ColorToType G = Int -> Int; ColorToType B = Int -> Int -> Int
04:31:50 <numee> oops, c is of type Color in definition of A
04:33:00 <isaac__> numee: Yes, using `singletons` and closed type families
04:33:42 <isaac__> https://hackage.haskell.org/package/singletons-2.3.1/docs/Data-Singletons.html
04:34:32 <numee> isaac__: Thank you! I'll take a look at it
04:35:04 <cocreature> numee: here’s your specific example http://lpaste.net/360237
04:35:50 <cocreature> the singletons library can be a bit daunting at first. I’d recommend to first get familiar with writing this kind of code “by hand” and then look into how you can use the singletons library to simplify parts of it
04:38:54 <numee> cocreature: Thank you! Without the code it would have taken a huge amount of time to decipher the documentation
04:49:48 <Brocoli> please help me, i don't know, what i have to do
04:50:05 <cocreature> I don’t know what you have to do either
04:50:59 <Brocoli> cocreature:  ro = filter(\(Bank [(x, (Account y z))]) -> x >= 1 && x <= 2) bac
04:51:16 <Brocoli> Error • Couldn't match expected type ‘[Bank]’ with actual type ‘Bank’
04:52:30 <cocreature> Brocoli: I’m not sure what you are trying to do
04:53:12 <cocreature> ideally, provide a minimal self-contained example that shows how your types are defined and what you are trying to do
04:53:47 <Brocoli> cocreature: i want to filter the id that is between 1 and 2 inclusive, and return all the accounts
04:54:18 <Brocoli> cocreature: data Bank = Bank [(ID,Account)] deriving Show
04:54:47 <Brocoli> type ID = Int
04:55:11 <cocreature> Brocoli: as lyxia already mentioned, you need to pass a list to "filter" not a "Bank". you can pattern match on bac to get a list, apply filter to it and then rewrap it in Bank
04:58:18 <Brocoli> cocreature: but how?
04:59:33 <cocreature> Brocoli: I’d recommend to pick up some introductory Haskell resources to learn about pattern matching
05:01:20 <cocreature> if you have a specific question, you are ofc more than welcome to ask here but learning the basic language features is easier by taking a look at some book or another resource
05:04:15 <kakashiAL> I have a stupid question
05:04:17 <kakashiAL> Procedural Programming means "do this, then do that"
05:04:19 <kakashiAL> Object Oriented Programming is all about encapsulation and inheritence, so you model your problems in objects that contains data and behavior (methods)
05:04:21 <kakashiAL> But whats about functional programming? I know it has keys like pure functions and not mutating data, but is that all?
05:04:23 <kakashiAL> I mean in that case I could do the same with OOP
05:04:44 <tdammers> OOP and FP are orthogonal
05:05:23 <tdammers> OOP is programming with objects, where an object is an entity that bundles state and behavior into one unit, and exposes a public interface that (ideally, but not always) hides the object's internals
05:05:34 <tdammers> FP means programming with functions, and there are two interpretations
05:06:07 <tdammers> the "weak FP" interpretation, where "function" is used in the informal programming sense of "something that you can call, and that might return a value of sorts"
05:06:34 <tdammers> and the "strong FP" intepretation, where "function" is used in a sense closer to the mathematical definition, as an entity that relates inputs to outputs
05:07:57 <tdammers> languages like Lisp, JavaScript, etc., use the "weak FP" interpretation, and there, "functional" just means that you use "functions" (or, as I prefer to call them, "procedures") as your primary building blocks
05:08:39 <tdammers> and there is a notion of preferring immutable data structures over mutable state there, but other than that, many, if not most, procedures have some side effects
05:09:22 <tdammers> the main thing that distinguishes the "weak FP" style from imperative is preferring immutable over mutable, and using map / reduce / filter instead of destructively updated loop variables
05:10:14 <kakashiAL> tdammers: thanks, I see. You can simply say "solving problem with (mathematical) functions"
05:10:38 <tdammers> the disambiguation is important though, because in practice, the two styles have very little in common
05:11:48 <tdammers> I happen to be writing a little blog series about OOP in Haskell - it's not something you would use a lot, but it's good to know that in the rare cases where it *is* a good approach, you can do it
05:12:09 <tdammers> https://programming.tobiasdammers.nl/blog/2017-10-17-object-oriented-haskell
05:12:12 <kakashiAL> tdammers: but are not all paradigms in a sense also procedural?
05:12:14 <drdo> tdammers: Which part of OOP is it about?
05:12:26 <tdammers> drdo: read the introduction ;)
05:12:35 <drdo> Are we talking about message passing or the whole inheritance business?
05:12:42 <tdammers> drdo: in short: 1) bundling behavior and state, 2) interfaces, 3) open recursion
05:12:47 <kakashiAL> tdammers: I see totaly no use in OOP, give me every class I can easily write a functional solution
05:13:05 <tdammers> kakashiAL: the use case is when you want runtime polymorphism with open recursion
05:13:40 <tdammers> kakashiAL: there are very few legit use cases for this, but they do exist, I have encountered maybe two or three of them in my 25-year programming career
05:13:44 <kakashiAL> polymoprhism....do more than one thing, I try to avoid that
05:13:48 <drdo> tdammers: Looks like both!
05:14:00 <tdammers> drdo: yes, kind of
05:14:05 <kahlil29> I have a Maybe Int that I am writing to the DB but it gives me a type error saying that it can't match Int with Integer .... Couldn't match type ‘Integer’ with ‘Int’. Any ideas on what to do? 
05:14:19 <tdammers> drdo: although my approach is closer to the "call a method" paradigm than smalltalk's "send a message"
05:14:24 <kahlil29> if I try to type cast it, it still does not work
05:14:26 <kakashiAL> tdammers: could you explain a simple case where OOP is needed and could you say tht OOP and FP are also procedural languages?
05:14:47 <kakashiAL> procedural paradigms 
05:14:49 <drdo> tdammers: I'm not really sure the two are different
05:15:07 <tdammers> drdo: technically they're the same, they're just two different ways of looking at the same thing
05:15:49 <drdo> I have no problem with OOP, it makes sense in some contexts
05:15:51 <tdammers> kakashiAL: no, I don't think you can say that. OOP is a structural paradigm, it tells you how to structure your code; FP and procedural are about what your primary building blocks at the lowest level are
05:15:58 <drdo> My problem is when people try to make *everything* fit into that mold
05:16:40 <tdammers> kakashiAL: you can build objects on top of functions, or on top of procedures, both are perfectly valid, it's just that the vast majority of OOP languages out there is also deeply committed to imperative / procedural programming
05:16:45 <tdammers> drdo: indeed
05:16:59 <tdammers> kakashiAL: as far as use cases go, the blog talks about those a bit
05:19:13 <tdammers> drdo: I'm currently writing part 4 of that series, which shows how some of the popular OOP Design Patterns can be implemented in this style, and I also explain why most of them are overkill in Haskell, because simpler, more elegant solutions exist that accomplish the same
05:20:37 <cocreature> tdammers: oh nice, didn’t know this was a series. I’ve only read part 1 so far :)
05:37:13 <Brocoli> please
05:37:38 <Brocoli> toList :: Bank -> [(ID, Account)]
05:37:44 <Brocoli> toList (Bank []) = [()]
05:37:51 <Brocoli> toList (Bank (a:xs)) = (toList (Bank xs)) ++ [a]
05:38:54 <Brocoli> this is the second line that I have problem
05:39:06 <cocreature> Brocoli: it’s way easier: toList (Bank xs) = xs
06:23:17 <mbrock> it's so strange that the regex libraries work on `Seq Char` but not `Text`
06:24:36 <mbrock> ok I can sort of see that it makes sense from some internal implementation detail perspective
06:36:13 <tdammers> cocreature: it wasn't, originally, but I thought I might as well run with it
06:43:03 <Wizek> mbrock: take a look at https://regex.uk, IIRC it supports Text 
06:44:34 <Wizek> whoops, ssl doesn't seem to be fully supported on that site: http://regex.uk/
06:47:30 <sflux> Hello everyone
06:49:09 <Harzilein> hi
06:49:16 * hackage timemap 0.0.5 - A mutable hashmap, implicitly indexed by UTCTime.  https://hackage.haskell.org/package/timemap-0.0.5 (athanclark)
06:52:14 * hackage git-annex 6.20171124 - manage files with git, without checking their contents into git  https://hackage.haskell.org/package/git-annex-6.20171124 (JoeyHess)
06:57:43 * hackage derive-topdown 0.0.1.0 - Help Haskellers derive class instances for composited data types.  https://hackage.haskell.org/package/derive-topdown-0.0.1.0 (songzh)
07:02:36 <hoanglong> test
07:17:34 <Gurkenglas_> If a class and a type are defined in different libraries, how hard would it be to allow one of the two libraries to export an instance without incurring a build dependency?
07:19:36 <merijn> Gurkenglas_: Very, that's why no one does it
07:20:01 <Gurkenglas_> What makes it difficult?
07:20:38 <merijn> Gurkenglas_: How do you expect the compiler to know the definition of the class/type without depending on the library that has it?
07:20:40 <mniip> instance depends both on the dictionary strucure layout and the datum impleentation
07:24:30 <Gurkenglas_> merijn, wouldn't type inference work on the unknown identifiers? Shoot, got to go. I'll try to continue the discussion. mniip, I know some of those words
07:25:13 <Gurkenglas_> (I'd imagine it would work similarly to implicit parameters)
07:32:41 <Gurkenglas_> Nevermind, I'm available. So one library would say that whenever a class named bar that would accept these definitions comes into scope, here's an instance.
07:33:58 <mniip> so if the instances don't match
07:34:18 <mniip> ok no
07:34:26 <mniip> if the data libary is installed before the class library
07:38:12 * hackage attoparsec-base64 0.0.0 - Fetch only base64 characters, erroring in the attoparsec monad on failure  https://hackage.haskell.org/package/attoparsec-base64-0.0.0 (athanclark)
07:38:27 <Gurkenglas_> Perhaps it should even give a warning when a class named bar that doesn't accept these definitions comes into scope, not sure.
07:41:48 <Gurkenglas_> The "implicit parameter" containing the class would have kind * -> Constraint, and other kinds should be equally possible (such as, of course, the library defining the class saying that if a type named Bar comes into scope along with a function runBar :: Bar -> [(Int, Bar)], here's an instance. Here, the implicit parameter would have kind *.)
08:00:30 <atractiva-y-cabr> hi
08:19:10 <Gurkenglas_> Did mniip run off in the middle of his refutation to implement a language extension?
08:29:20 <ggVGc> the more haskell I write, the more I embrace putting extra brackets around stuff...
08:29:26 <ggVGc> one day my haskell will be lisp
09:41:58 <Gurkenglas_> merijn, so if the class definer wants to define an instance for a type without having it in scope, it'd look like a TemplateHaskell function that can specialize to ((?Bar :: *, ?Bar :: [(Int, Bar)] -> Bar, ?runBar :: Bar -> [(Int, Bar)]) -> Dict) -> DecsQ
09:42:13 <Gurkenglas_> " -> Dict (MyClass Bar)", that is
09:44:22 <Gurkenglas_> (the class definer wouldn't implement any templatehaskell code, of course)
10:06:15 * hackage persistent-sqlite 2.6.3.1 - Backend for the persistent library using sqlite3.  https://hackage.haskell.org/package/persistent-sqlite-2.6.3.1 (paulrouse)
10:10:17 * hackage nsis 0.3.2 - DSL for producing Windows Installer using NSIS.  https://hackage.haskell.org/package/nsis-0.3.2 (NeilMitchell)
10:15:33 <saurabhnanda> am I missing something obvious? is there a String version of Data.Text.Split ?
10:15:42 <saurabhnanda> Data.Text.split
10:16:09 <Welkin> Data.List.Split
10:16:30 <Welkin> type String = [Char]
10:17:13 <phadej> saurabhnanda: see `split` package
10:17:48 <saurabhnanda> Welkin: https://www.stackage.org/haddock/lts-9.0/base-4.9.1.0/Data-List.html
10:17:58 <saurabhnanda> couldn't find split there...
10:18:04 <Welkin> it is not in base
10:18:10 <Welkin> it is in a different package called split
10:18:22 <Welkin> the easiest way to find these things is to search hayoo for the module name
10:18:34 <Welkin> http://hayoo.fh-wedel.de/?query=Data.List.Split
10:18:55 <saurabhnanda> ah okay
10:20:14 <saurabhnanda> thanks, pretty useful. Should probably be merged with Data.List in base itself.
10:20:38 <saurabhnanda> and any idea how to use https://www.stackage.org/haddock/lts-9.0/bytestring-0.10.8.1/Data-ByteString.html#v:split
10:20:58 <saurabhnanda> it's not accepting single-quoted chars as given in the docs.
10:21:41 <crucify_me> https://ptpb.pw/9lx9   hi how does the lambda expression work here, with (\_ n -> n + 1) I understand the second part (increment). thanks
10:22:04 <cocreature> a Char doesn’t make sense. bytestring is a sequence of bytes, you can’t split that on unicode characters
10:22:26 <saurabhnanda> cocreature: but the example of that function seems to be doing exactly that.
10:22:36 <cocreature> if you want ascii encoding you can use (fromIntegral . ord) to go from Char to Word8
10:22:37 <saurabhnanda> `split 'a'  "aXaXaXa"`
10:22:41 <cocreature> saurabhnanda: right the docs are broken
10:22:52 <saurabhnanda> what?!
10:23:07 <saurabhnanda> ignore the surprise.
10:23:16 <saurabhnanda> so, is GHC accepting doc PRs via github?
10:23:37 <cocreature> you need a PR for bytestring not for GHC
10:23:45 <saurabhnanda> s/GHC/base/
10:23:54 <Welkin> ghc repo is here https://ghc.haskell.org/trac/ghc
10:23:58 <saurabhnanda> oh this is not even base
10:23:58 <saurabhnanda> it's a separate package
10:25:06 * hackage animate-example 0.0.0, animate 0.2.0 (jxv): https://qbin.io/y5zvqhj
10:26:29 <crucify_me> ^ hoping for help with that part of lambda ' \_ n -> ' above
10:26:48 <crucify_me> the wildcard always throws me off
10:27:30 <crucify_me> what would that represent in a definition of length ?
10:28:08 <crucify_me> https://ptpb.pw/9lx9  << re: this
10:28:09 <Welkin> that is const
10:28:12 <Welkin> :t const
10:28:13 <lambdabot> a -> b -> a
10:28:17 <Welkin> well, almost
10:28:36 <Welkin> :t (+1) . const
10:28:38 <lambdabot> Num (b -> a) => a -> b -> a
10:29:00 <Welkin> :t (+1) (.).(.) const
10:29:02 <lambdabot> Num ((b1 -> b2 -> a1) -> (a2 -> b1) -> a2 -> b2 -> a1) => (b1 -> a1) -> (a2 -> b1) -> a2 -> b2 -> a1
10:29:04 <Welkin> lol
10:29:16 <crucify_me> Welkin, er, is that for my benefit?
10:29:26 <Welkin> just playing around
10:29:40 <Welkin> I don't quite understand your question
10:29:50 <Welkin> the lambda you wrote should be self-explanatory
10:30:01 <crucify_me> its a textbook
10:30:31 <Welkin> > (+1) . const $ 9 2
10:30:33 <lambdabot>  error:
10:30:34 <lambdabot>      • Could not deduce (Num t0)
10:30:34 <lambdabot>        from the context: (Num (t -> a), Num (b -> a), Num t)
10:30:51 <Welkin> > (+1) $ const $ 9 2
10:30:53 <lambdabot>  error:
10:30:53 <lambdabot>      • Could not deduce (Num t0)
10:30:53 <lambdabot>        from the context: (Num (t -> a), Num (b -> a), Num t)
10:31:05 <crucify_me> I'm not following with const example
10:31:07 <Welkin> > ((+1) . const) 9 2
10:31:09 <lambdabot>  error:
10:31:09 <lambdabot>      • Could not deduce (Num b0)
10:31:09 <lambdabot>        from the context: (Num (b -> a), Num b, Num a)
10:31:12 <Welkin> o.o
10:31:34 <Welkin> I just meant that it throws away the first parameter
10:31:46 <Welkin> \_ n -> n + 1
10:33:27 <crucify_me> could you explain how the wildcard is used there, and the first n in that lambda Welkin 
10:33:37 <Pacra> thats wild
10:34:22 * hackage hslua-module-text 0.1.2.1 - Lua module for text  https://hackage.haskell.org/package/hslua-module-text-0.1.2.1 (tarleb)
10:34:35 <Welkin> because all functions are curried, `\a b -> ...` is actually `\a -> \b -> ...`
10:35:18 <crucify_me> ok thanks so n there is the list itself ?
10:35:31 <Welkin> the `_` is a variable you can bind to like any other, but is used to represent a "don't care" when you don't want to use that parameter in your equation
10:35:47 * hackage pipes-safe 2.2.6 - Safety for the pipes ecosystem  https://hackage.haskell.org/package/pipes-safe-2.2.6 (GabrielGonzalez)
10:36:04 <crucify_me> ok got that..
10:36:13 <Welkin> no, the n is obivously not a list because you are applying (+1) to it
10:36:16 <Welkin> you can't do that to a list
10:36:23 <Welkin> it must be some kind of Num, probably an Int
10:36:27 <crucify_me> n is a seed value ?
10:36:54 <Welkin> okay, I see
10:36:59 <crucify_me> or , careful to say, an accumulator?
10:37:01 <Welkin> I should have looked at your paste earlier
10:37:07 <Welkin> it is used as the accumulator function for foldr
10:37:09 <Welkin> :t foldr
10:37:10 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
10:38:09 <Welkin> foldr takes an accumulator function where the first parameter is an element from your Foldable structure (like a List), and the second parameter is your accumulator value
10:38:15 <Welkin> here, the accumulator is set to 0
10:38:22 <Welkin> @src foldr
10:38:22 <lambdabot> foldr f z []     = z
10:38:22 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
10:38:51 <crucify_me> excellent thanks. In the lambda it didn't look like an accumulator to me. (some people here prefer seed value)
10:39:38 <Welkin> well, the value you provide to it on the first application is a seed value, but the value that gets passed around on each iteration is an accumulation of all of the operations (an accumulator)
10:39:42 <crucify_me> so what are you calling the first parameter ? the \_
10:39:43 <crucify_me> ?
10:40:03 <Welkin> that is the element from the list
10:40:18 <Welkin> foldr iterates over a foldable structure one element at a time
10:40:36 <crucify_me> ok so that is like a staging area
10:40:37 <EvanR> those variable names are good for seeing the structure at a glance but not for understanding the intended use
10:41:01 <EvanR> in that @src listing
10:41:08 <ggVGc> what is this variable naming you talk of
10:41:26 <EvanR> z and x
10:41:30 <ggVGc> in haskell you donit need variable names
10:41:46 <ggVGc> point free all the things
10:42:28 <EvanR> foldr kind of cant be defined in terms of simpler point free parts, its the core interpreter of the list data structure
10:42:41 <EvanR> im not sure how to make that precise
10:43:08 <crucify_me> I understand the point free element, the \_ is as Welkin said the first element of the list that is being folded over. EvanR would love elaboration on it thanks
10:43:23 <Welkin> that is not point-free
10:43:28 <EvanR> i just showed up, what is \_
10:43:31 <Welkin> the point-free discussion has nothing to do with our discussion
10:43:37 <crucify_me> https://ptpb.pw/9lx9
10:43:40 <Welkin> you can safely ignore that crucify_me 
10:43:49 <crucify_me> ok ! thanks
10:44:07 <EvanR> the first argument (_) is the element from the list
10:44:15 <Welkin> crucify_me: try to implement foldr and foldl yourself
10:44:16 <EvanR> the visitee
10:44:17 <Welkin> it helps a lot
10:44:29 <Welkin> implement them as recursive functions
10:44:44 <Welkin> you can even fix them to work just on lists
10:44:51 <Welkin> so you don't have to deal with Foldable
10:45:43 <crucify_me> the text has been walking through it. It was using a lambda as the arg that had me confused . 
10:46:23 <crucify_me> the fact its just the first, second element, etc being counted helped .
10:47:00 <Welkin> crucify_me: https://imgur.com/a/CbkR5
10:47:13 <Welkin> I think Cale made that (not sure where I grabbed it from)
10:47:21 <Welkin> but it is a very helpful diagram to understand folds
10:47:47 <crucify_me> the hardest thing is looking at \_ as a single element , not a 'working' function . thanks Welkin  cool 
10:47:51 <Welkin> just look at the left portion on foldr and foldl
10:48:40 <crucify_me> I went through folds and it is a bit tough. thanks I 'll take a look
10:50:11 <Welkin> right anf left folds can take some time to build intuition for
10:50:24 <Welkin> foldr is easier
10:51:07 <crucify_me> trippy I need to look at those trees on a desktop. thanks kindly Welkin working on it this week.
10:52:07 <Welkin> try working them out on paper
10:52:20 <Welkin> start with a small list of maybe 5 elements
10:52:32 <Welkin> and work out each step of the calculation until you get your final result
10:52:44 <Welkin> each "iteration"
10:53:47 <EvanR> you have to know that e1 + e2 cant be lazily evaluated (for Int or Integer or Double...)
10:54:14 <EvanR> tricky part of evaluating that by hand
10:56:26 <crucify_me> EvanR, Welkin ok thanks, that would be called linear recursion, not tail right/
10:56:28 <crucify_me> ?
10:56:56 <EvanR> foldr isnt tail recursive, i dont know what linear recursion is
10:57:10 <crucify_me> it lines up in a stack, so to speak
10:57:23 <EvanR> interesting
10:57:39 <EvanR> that implementation detail doesnt apply to haskell really
10:58:03 <crucify_me> hmm, it is foggy remembrances of scheme
10:58:34 <EvanR> haskell is lazy so a call stack doesnt really make sense, all calls are effectively tail calls
10:58:54 <EvanR> but not necessarily tail recursive (tail position, and recursive)
10:59:35 <crucify_me> hmm, I was using the SICP book, it makes the distinction in scheme
11:00:04 <EvanR> schema does eager evaluation, theres a totally different implementation for that
11:02:41 <crucify_me> here is random sentence : When we make a normal recursive call, we have to push the return address onto the call stack then jump to the called function. This means that we need a call stack whose size is linear 
11:03:14 <EvanR> that doesnt apply to haskell
11:03:39 <crucify_me> ok thanks, EvanR I was disconnected briefly
11:06:02 <crucify_me> so anything like this 1 : (2 : (3 : []))  I was looking at as linear recursion , wrongly I guess EvanR 
11:06:17 * hackage subzero 0.1.0.2 - Helps when going "seed values" -> alternatives and optional -> answers  https://hackage.haskell.org/package/subzero-0.1.0.2 (codeshot)
11:06:19 <EvanR> that doesnt look like recursion
11:06:49 <amf> with `stack haddock` im getting a failure, but no information to know what exactly failed.. are there any flags i can pass to stack or haddock to increase verbosity? (stack --verbose haddock doesnt help)
11:08:10 <EvanR> crucify_me: if you use foldr, depending on how you use it, it may or may not use a bunch of extra space
11:08:30 <EvanR> but SICP wont help you understand that
11:12:33 <crucify_me> EvanR, interesting. SICP introduced me to big O notation and worked out tail vs linear timestamps, etc. thanks can't wait to understand what you mean
11:12:49 <crucify_me> if you call them timestamps I forget
11:13:20 <EvanR> tail vs linear timestamps?
11:13:48 <crucify_me> well big O notation for each
11:19:13 * hackage xmlhtml 0.2.5.2 - XML parser and renderer with HTML 5 quirks mode  https://hackage.haskell.org/package/xmlhtml-0.2.5.2 (DougBeardsley)
11:31:44 <Gurkenglas_> How hard would it be to allow libraries to use something like implicit parameters to write an instance template that turns into an instance when the missing classes/types come into scope?
11:32:57 <Gurkenglas_> (Of course one of the classes/types must still be defined in the current module)
11:36:40 <Gurkenglas_> Ooh, there's a concern that factors relatively neatly out of this: How possible would it be to have ?asd nameclash with asd, so the ? would be closer to a defer-type-errors operator
11:42:22 <CodeWeaver> Okay, I've got another thunk/laziness related question...  I was pondering the splitAt function and its various cousins for lists.  As a technical exercise, I wanted to see if I could implement a version that didn't chew up memory holding on to the second half as long as the first half was consumed.
11:42:58 <CodeWeaver> I started with the version in base, explicitly typed to ints so I didn't have any polymorphism issues like last time.
11:43:28 <CodeWeaver> I was amused to discover that the one in base doesn't seem to have this problems under -O1, but does under -O0.  Then I got curious as to what optimizations caused that.
11:44:44 <CodeWeaver> code here:  https://pastebin.com/bm4wZ0qU
11:45:38 <CodeWeaver> I've been unable to figure out how standard splitAt avoids holding on to the whole list until the first sublist is completely used up, and the second part gets consumed.
11:46:01 <CodeWeaver> Well, it doesn't, actually, without -O0, but I can't figure out what subset of the -O1 optimizations _allow_ it to avoid that fate.
11:46:14 <CodeWeaver> Errr, I mean it doesn't using -O0
11:46:33 <cocreature> CodeWeaver: how are you measuring that it’s holding the list in memory?
11:47:20 <CodeWeaver> cocreature:  That's a fair question.  Two ways.  Rudimentary:  Watching the memory growth go out of control at a system level.  The difference between -O1 and -O0 is immediate and obvious.
11:47:52 <CodeWeaver> cocreatre:  Also, I looked at the core to see if I could spot ways in which, maybe, lists were being brought out to... what is it called? CAF level?
11:48:31 <CodeWeaver> I haven't run any of GHC's memory analysis and graphing tools just yet, but the effect seemed really obvious, and the program's designed to BE really obvious.
11:48:52 <CodeWeaver> And also in fairness I can't read Core very well yet.
11:52:53 <JuanDaugherty> does, "core" here mean physical memory content?
11:53:07 <cocreature> JuanDaugherty: core is GHC’s intermediate language
11:53:12 <JuanDaugherty> ah
11:53:12 * hackage heist 1.0.1.1 - An Haskell template system supporting both HTML5 and XML.  https://hackage.haskell.org/package/heist-1.0.1.1 (DougBeardsley)
11:53:13 <cocreature> or rather one of the intermediate languages
11:53:15 <CodeWeaver> No, I mean.. GHC's ... STG language?
11:53:24 <cocreature> STG is one level below core :)
11:53:28 <CodeWeaver> Ah.
11:53:32 <CodeWeaver> My mistake. Still.
11:53:39 <crucify_me> length' = foldr ( \_ n -> n + 1 ) 0     wondering EvanR Welkin if you have time: how does haskell know that n is the accumulator function, and how is it set to initial value 0 ?    or any member help please?
11:53:42 <sternmull> I am in need for asynchronous threads that work on their own state and communicate with each other, pretty much like Erlang processes. Modeling this on top of Async's turned out to get pretty messy. Is there a good package for such things?
11:53:45 <CodeWeaver> The dump_simpl stuff .
11:53:58 <CodeWeaver> That's what I meant. APologizes for bad use of the terms.
11:54:21 <CodeWeaver> At best I've discovered three optimizations in -O1 any one of which that, if i turn off, cause the bad behaviour to appear,  But turning them on in -O0 doesn't  cause the bad behaviour to disappear, and its not clear what transforms are making it better or how I'd do it 'by hand' at the Haskell level if I needed to.
11:54:53 <cocreature> it looks like with -O0, GHC floats out the call to splitAt
11:55:23 <cocreature> I actually find the -O0 behavior to be more surprising than the -O1 behavior :)
11:55:33 <CodeWeaver> Hey, no argument from me.
11:55:43 <cocreature> you are not holding any explicit reference to [0..n-1]
11:55:55 <CodeWeaver> True.
11:55:57 <cocreature> so there is nothing that causes GHC to keep it around
11:56:52 <CodeWeaver> Well, I would have thought in stockSplitAt, which is from base, would hold on to the second half even if you processed a very large first half.  Like, the way I read that code, the behaviour SHOULD be to use up memory.
11:57:11 <CodeWeaver> Its not clear to me how the optimizations are avoiding it.
11:57:23 <CodeWeaver> But I could be reading the code wrong.
11:57:26 * cocreature stares at the code again
11:57:44 <CodeWeaver> And then, I'm not sure what optimizations are doing it, much less how.
11:58:26 <CodeWeaver> Also not quite sure why it would change anything to have the internal splitAt' in that function floated out in -O0 would change that behaviour.
12:00:13 <CodeWeaver> Also apparently can't grammar before coffee.
12:03:17 <cocreature> so with -O1 it pattern matches on the result of splitAt', that gives it a tuple. note that none of the elements is forced at this point so the large list has not been evaluated yet. it then starts going through a loop on the first element of that tuple to find the last element. this will evaluate the large list but nothing is retaining references to those elements so they can be immediately garbage collected
12:03:34 <CodeWeaver> GImme a moment to read that.
12:03:46 * hackage Villefort 0.1.2.5 - Villefort is a task manager and time tracker written in haskell.  https://hackage.haskell.org/package/Villefort-0.1.2.5 (ChrisReuter)
12:04:23 <CodeWeaver> Well, okay, but the second half of the list is already.... held on to by the caller by way of a thunk that, when evaluated, would itself have to walk down the list, no?
12:04:58 <CodeWeaver> Isn't the need to eventually process that second part of that initial tuple the thing that should hold on to the whole list?
12:05:46 <CodeWeaver> I mean that's to me why it _has_ bad behaviour when run with -O0
12:06:30 <cocreature> the reason why this is not the case (as far as I understand it, I might be completely wrong here) is that you are not calculating the first and the second part of the tuple independently
12:06:55 <cocreature> if you just had splitAt xs = (take n xs, drop n xs) then yeah you would retain a reference to xs
12:07:00 <crucify_me> https://ptpb.pw/qP6P  these are some notes on foldr. I see how \_ in ' length' = (\_ n -> n + 1) 0 ' works as the 'x' in (x:xs). but how does foldr know that n is the accumulator ?  
12:07:40 <crucify_me> sorry mis posted ... 
12:07:59 <CodeWeaver> Yeah, but in pattern matching to split open the tuple to get the first part, what _is_ retained in order to get the second part?  As far as I know it's not going to re-evaluate the function calls to splitAt'
12:08:01 <crucify_me> length' = foldr (\_ n -> n + 1 ) 0
12:09:14 * CodeWeaver scratches head
12:09:16 <cocreature> the longer I’m staring at this the more I’m confusing myself :)
12:09:26 <CodeWeaver> I'm glad I"m not the only one. :D
12:09:34 <cocreature> heh :)
12:09:35 <CodeWeaver> Such a simple bit of code.... but it vexes me.
12:10:10 <sphinxo> naming convention for libraries that provide c bindings?
12:11:37 <sphinxo> libname-haskell ?
12:11:40 <cocreature> so let me try to rephrase and you tell me if I’m making sense: the reason why the list is not being retained is that evaluating the first element which forces the evaluation of the call to splitAt' also partially evaluates the second element. in particular it evaluates it sufficently far to see that it doesn’t need to keep elements around
12:12:15 <CodeWeaver> If that's the case, why does itnot do that in -O0?  If it's one of the optimizations, which one?
12:12:15 <hololeap> crucify_me: i'm not exactly sure what you mean. it knows what n is because that is how the function is coded. this is reflected in the type signature for foldr
12:13:17 <cocreature> sphinxo: libname-hs seems to be reasonably popular
12:13:29 <sphinxo> cocreature: thanks!
12:13:45 * hackage criterion 1.2.4.0 - Robust, reliable performance measurement and analysis  https://hackage.haskell.org/package/criterion-1.2.4.0 (ryanglscott)
12:14:07 <cocreature> sphinxo: but maybe I’m just trying to get you to use my naming convention so that I don’t have to feel bad for being really uncreative when it comes to package names :)
12:14:12 <CodeWeaver> Looking at splitAt' in the third clause, where the bulk of the work is done... as you pull more and more elements lazily off of the first list, I agree that the same function that you need to get the first sublist fully evaluated walks down the entire function call chain....
12:14:42 <sphinxo> cocreature: I'm all about uncreative and consistent
12:16:11 <CodeWeaver> I'd have to draw out how the thunks are set up that would allow it to happen.
12:16:27 <crucify_me> hololeap, thanks a lot. so in foldr the accumulator argument is expected. I need to figure out where it is in foldr 's definition. 
12:16:30 <CodeWeaver> But then I'm still left with... what is it in the optimizations that allows it to behave as you might say 'correctly'?
12:16:40 <CodeWeaver> And why does it misbehave with -O0?
12:17:03 <CodeWeaver> If you're right, why would it ever hold on to memory?
12:18:34 <CodeWeaver> The more I think bout it the more you make sense, but I'm still left with that mystery.
12:18:47 <cocreature> yeah I’m confused about that myself
12:19:00 <cocreature> *makes up excuse about being too tired*
12:19:37 <CodeWeaver> You've been more than a good sport about it, so my thanks for your efforts. :)
12:20:04 <CodeWeaver> There's a thunk visualizer for ghc somewhere I recall....
12:20:20 <EvanR> ghc-vis
12:20:48 <CodeWeaver> This will help me at least verify the thunking we think is happening
12:21:42 <hololeap> crucify_me: foldr has a different implementation for each Foldable instance, such as []
12:22:29 <sphinxo> Conventions for namespacing of c bindings? 
12:22:30 <CodeWeaver> Power dwindling.  Back shortly.
12:25:31 <hololeap> crucify_me: the implementation for [] is here: http://hackage.haskell.org/package/base-4.10.0.0/docs/src/GHC.Base.html#foldr
12:26:13 <crucify_me> thanks kindly hololeap . so what about this definition, is the v there what is used as the accumulator ? http://lpaste.net/360242
12:26:46 <crucify_me> ie does n satisfy the v arg ?
12:26:53 <hololeap> crucify_me: that's correct
12:27:00 <crucify_me> excellent thanks
12:28:00 <EvanR> for some reason the infix code there makes me realize... the f passed to foldr gets the first element of the list and the result of folding the rest of the list as the two arguments
12:28:08 <hololeap> crucify_me: the reason why is because you are calling f with two arguments: x (of type 'a') and either v for the empty list case or (foldr f v xs) for the non-empty case (both of which are of type 'b')
12:28:37 <hololeap> crucify_me: does that make sense?
12:28:57 <crucify_me> hololeap, I'm working on that and EvanR 's comment 
12:31:25 <hololeap> crucify_me: even if you didn't explicitly put in the type signature, the compiler could infer that `f' is a function with two arguments. when you pass in the lambda, you are telling it what the function `f' should be
12:32:06 <crucify_me> hololeap, very helpful thanks
12:32:46 <hololeap> crucify_me: np :)
12:33:21 <EvanR> hmm breakpoint :: a -> a
12:33:25 <EvanR> breakpoint r = r
12:34:40 <MarcelineVQ> EvanR: when you see something in a module called GHC that is just id but has a different name, it's typically a signal to the compiler to put something not-haskell there to do magical things
12:36:35 <EvanR> ah
12:36:47 <EvanR> i would love to make new magic things like that
12:38:08 <crucify_me> hololeap, yeah its no cake walk  :)
12:42:34 <CodeWeaver> I hear that whole electricity thing helps make haskell go to.
12:42:38 <CodeWeaver> too.
12:42:46 <crucify_me> hololeap, thing is , there's still something odd / confusing about it :   
12:43:28 <CodeWeaver> Installing graph-vis. Shoulda done this yesterday. ;)
12:43:34 <EvanR> foldr :: (a -> b -> b) -> b -> [a] -> Electricity -> b
12:44:00 <CodeWeaver> errrr ghc-vis
12:44:27 <CodeWeaver> bwahahahahaha 
12:44:32 * CodeWeaver coughs and chokes.
12:44:38 <CodeWeaver> Dammit, EvanR, I was enjoying that coffee :D
12:45:02 <EvanR> hmm, now i want coffee
12:45:18 <crucify_me> no scratch that: the accumulator is exactly where it should be: in the v place. the arguments seems out of order at first hololeap 
12:45:25 <CodeWeaver> I'm still getting the grounds out of my USB port from the last time I tried to upload a cup so you're on your own.
12:45:35 <crucify_me> seemed*
12:45:56 <hololeap> crucify_me: do you understand currying? that might be part of the reason why you're confused. that and higher-order functions are a bit hard to get used to
12:46:06 <EvanR> i am not sure why foldr and foldl have the arguments going in opposite order
12:46:22 <peter81> why does product[1..n] :: Int yield 0 for all n>=66?
12:46:42 <crucify_me> EvanR, haven't looked at foldl in a while, really?
12:46:44 <EvanR> because overflow?
12:46:54 <platz> is there a way do deal with `~` in filesystem paths?  http://lpaste.net/2936398247545012224
12:46:58 <crucify_me> one moment hololeap 
12:46:59 <CodeWeaver> 66 factorial is pretty bloody big.
12:47:03 <EvanR> foldr :: Foldable t => (a -> b -> b) -> b -> t a -> b
12:47:04 <peter81> EvanR: it overflows before 66 too
12:47:09 <EvanR> foldl :: Foldable t => (b -> a -> b) -> b -> t a -> b
12:47:14 <geekosaur> because every even number adds a factor 2 and eventually you not only overflow but you've done so by shifting 0s onto the right, leaving you with only the 0 bits fitting
12:47:36 <peter81> geekosaur: ah that explains it, thanks
12:47:38 <hololeap> EvanR: i think it's just because it's more intuitive that way. (a -> b -> b) is nomming a's on the left and (b -> a -> b) is nomming a's on the right
12:47:44 * hackage BNFC-meta 0.6 - Deriving Parsers and Quasi-Quoters from BNF Grammars  https://hackage.haskell.org/package/BNFC-meta-0.6 (JonasDuregard)
12:48:09 <EvanR> hololeap: i guess i have more intuition to hammer into my brain
12:48:09 <CodeWeaver> Is that a formal term?  nomming? If not it should be. ;)
12:48:42 <nshepperd_> Standard nommenclature
12:48:55 * CodeWeaver coughs and hacks again. ;)
12:49:08 <crucify_me> hololeap, yes \_ is just an x value from (x:xs), but written '\_' I always think it is more complex
12:49:27 <EvanR> ok, if you imagine foldl "happening" starting on the right and going left, you have an a on the right, and the rest of the fold on the left
12:49:52 <hololeap> EvanR: that
12:50:05 <hololeap> EvanR: *that's the way i've always imagined it
12:50:54 <EvanR> i can never tell if these pictures actually make sense, or its a trick caused by left-to-right writing
12:51:19 <crucify_me> I heard not to think in terms of l -> r or r -> l. just that the cons is replaced by the function ie (+), and the empty list is replaced by 0 
12:51:22 <hololeap> crucify_me: you could also write it (\x n -> n + 1). the underscore just emphasizes that the value is thrown away
12:51:43 <crucify_me> helpful thanks
12:51:59 <EvanR> '\_' isnt a unit of syntax that makes sense
12:52:33 <EvanR> _ makes sense, \_ x -> x makes sense
12:53:00 <crucify_me> example in hutton book to write length. you saw it right? sorry yeah its \_ n in this case
12:53:03 <crucify_me> EvanR, 
12:53:15 <byorgey> crucify_me: when you replace cons with a function and empty list by a value, that is specifically foldr.
12:53:25 <byorgey> you can't think of foldl that way.
12:53:35 <crucify_me> byorgey, thanks, yeah this is for foldr
12:54:01 <crucify_me> right value is correct, 0 is specific
12:54:41 <sternmull> EvanR: about the argument order i think this comes from the final node when you draw them as tree, see https://en.wikibooks.org/wiki/Haskell/Lists_III#foldr
12:55:11 <EvanR> left and right are cultural, up and down are ambiguous, diagonal is both. the only fair way is to have the notation start near you and progress directly away in 3D
12:55:47 <EvanR> for lists
12:55:48 <crucify_me> I wipe with my left hand
12:56:04 <EvanR> TMI
12:56:07 <hololeap> programming meets general relativity
12:56:19 <crucify_me> sorry ! :)
12:56:31 <CodeWeaver> The faster your haskell program goes, the more compressed your output is?
12:56:56 <crucify_me> couldn't resist, its a holiday day
12:57:03 <crucify_me> here*
12:58:15 <EvanR> [1,2,3,2,1] notation makes lists look symmetric when they arent
13:00:10 <hololeap> the most general way to think of it is foldr starts with the last value in the recursive data structure (the empty list [])
13:01:02 <hololeap> so it has to unfold the whole thing and start evaluating backwards once it reaches the end
13:01:31 <Welkin> although foldr builds up the expression as it goes
13:03:06 <hololeap> Welkin: i thought it built up a chain of thunks?
13:03:15 <byorgey> hololeap: but that doesn't explain why foldr can sometimes return a finite result when called on an infinite list.
13:03:25 <hololeap> maybe i'm confused
13:03:31 <byorgey> > foldr (||) False (False : False : False : True : repeat False)
13:03:33 <lambdabot>  True
13:04:12 <byorgey> hololeap: what you said is true IF the combining function is strict in its right-hand argument.
13:04:33 <sternmull> look my link above, for my taste this is a good explanation. Take that from a guy that needed some time to get a feeling for foldl and foldr :)
13:04:53 <phaazon>     Preprocessing library for basement-0.0.4..
13:04:53 <phaazon>     /usr/bin/ld.gold: error: .stack-work/dist/x86_64-linux-tinfo6-nopie/Cabal-2.0.0.2/build/Basement/Terminal/Size_hsc_make.o: requires dynamic R_X86_64_32 reloc which may overflow at runtime; recompile with -fPIC
13:04:55 <EvanR> hololeap: what you said sounds like foldl
13:04:57 <phaazon>     /usr/bin/ld.gold: error: .stack-work/dist/x86_64-linux-tinfo6-nopie/Cabal-2.0.0.2/build/Basement/Terminal/Size_hsc_utils.o: requires dynamic R_X86_64_PC32 reloc against 'vprintf' which may overflow at runtime; recompile with -fPIC
13:05:01 <phaazon>     collect2: error: ld returned 1 exit status
13:05:02 <phaazon> I wanted to paste the gist of that
13:05:04 <phaazon> oops sorry
13:05:09 <phaazon> anyway, anyone what’s going on? :(
13:05:25 <phaazon> +know
13:05:31 <phaazon> (jesus wtf is wrong with me tonight :D)
13:06:35 <MarcelineVQ> phaazon: arch?
13:06:42 <phaazon> MarcelineVQ: yep
13:06:51 <MarcelineVQ> what's wrong is you need to add ghc-build: nopie in your  ~/.stack/config.yaml  and install ncurses5-compat-libs from the AUR
13:07:08 <phaazon> MarcelineVQ: what the… ?!
13:10:05 <hololeap> i see, so i was right, but the unfolding process can short-circuit if the function (f :: a -> b -> b) doesn't evaluate b for some a (due to laziness). however, if that isn't the case, it will keep unfolding until it reaches []
13:11:28 <hololeap> `True || (foldr f v xs)` never evaluates the second part and it just returns True
13:13:03 <EvanR> hololeap: well it may be the case that all the second arguments will be needed to get the full answer
13:13:15 <EvanR> but you dont necessarily have to view the full answer on the consuming end
13:13:46 <EvanR> in which case its lucky that the foldr algorithm doesnt require traversing the whole list regardless
13:14:13 <phaazon> MarcelineVQ: is there a blog post or anything stating why this is needed?
13:14:16 <phaazon> that seems insane
13:14:27 <EvanR> unlike foldl. to get anything back from foldl, the list spine must be traversed to the end (if it exists)
13:14:28 <sternmull> phaazon: Create a ~/.stack/config.yaml with "ghc-build: nopie" in it and install ncurses5-compat-libs from AUR. This at least worked for me. And of course... it sucks. See https://bbs.archlinux.org/viewtopic.php?id=230091
13:16:23 <MarcelineVQ> phaazon: Probably not, there's a stack github issue or two that allude to the underlying cause but I don't reacall that the deal was. possibly something to do with not having a specific enough ghc package available on stack's end to combat the weird way arch is doing things these days
13:16:37 <EvanR> > foldl (\z _ -> z) 6 [1,2,3]
13:16:39 <lambdabot>  6
13:16:44 <EvanR> > foldl (\z _ -> z) 6 [1..]
13:16:50 <lambdabot>  mueval-core: Time limit exceeded
13:16:56 <hololeap> i see... because foldr calls `'f' first, but foldl calls `foldl' first... for foldl there's no chance to short-circuit 
13:17:17 <phaazon> MarcelineVQ: what do you mean weird ways?
13:17:18 <EvanR> foldl can short circuit, but only after it unwinds the whole list
13:17:27 <hololeap> makes sense
13:17:39 <EvanR> so its not a great shortcircuit
13:18:03 <EvanR> > foldl (\z _ -> z) 6 [undefined, undefined, undefined]
13:18:03 <cloudhead> hey, can someone tell me what I need to do to improve on this: http://lpaste.net/360243? Wondering if I'm missing some instances perhaps..
13:18:05 <lambdabot>  6
13:18:30 <EvanR> > foldl (\z _ -> z) 6 (repeat undefined)
13:18:36 <lambdabot>  mueval-core: Time limit exceeded
13:18:44 <CodeWeaver> Interesting point.  YOu'd want to foldl' (strict version) on, say, a folded list using (+), but you'd want foldr for (|||) because of the short circuiting.  Neat.
13:19:05 <phaazon> MarcelineVQ: I’m very curious about what you mean, because I like arch very well
13:20:48 <EvanR> i was about to say that foldl' acts more like foldr
13:20:52 <MarcelineVQ> well in the case of having to add nopie there's clearly some issue regarding how stack or ghc or arch's gcc are dealing with linking flags.  generally though by weird way, and I'm not sure if this is relevant to stack, I mean arch's making all their haskell package's dynamic so if you want to install pandoc or something similar you have to install 104 packages along with it
13:21:03 <nshepperd> arch ghc maintainer got it into his head to make haskell libraries dynamic by default
13:21:08 <EvanR> so i checked the source... and its implemented with foldr :)
13:21:38 <crucify_me> glad you're still on it. the fold stuff is tricky
13:21:39 <MarcelineVQ> I avoid that issue by not installing anything haskell related with pacman, but I shouldn't have to avoid pacman, arch _is_ pacman
13:21:40 <nshepperd> and I guess doesn't use haskell because there were a few rounds of total breakage :(
13:22:01 <hololeap> > foldl' (\z _ -> z) 6 (repeat undefined)
13:22:08 <lambdabot>  mueval-core: Time limit exceeded
13:22:31 <phaazon> MarcelineVQ: yeah, I have pandoc installed
13:22:35 <geekosaur> that and they manually force -dynamic for stuff in arch but then remove all the statioc libs from the arech packages, so if you try to use ghc yourself lots of things fail
13:22:42 <geekosaur> unless you know to force dynamic etc.
13:22:49 <hexagoxel> nopie is completely unrelated to dynamic linking issues though, is it not?
13:23:11 <geekosaur> not completely unrelated, since PIE is basically 'an executable is a shared library'
13:23:15 <hololeap> > foldl' (||) False ( False : False : False : True : repeat False )
13:23:21 <geekosaur> but it's a different issue, and it's not really arch's fault
13:23:22 <lambdabot>  mueval: ExitFailure 1
13:23:23 <phaazon> hexagoxel: no position independent
13:23:26 <phaazon> so… it kinda of is
13:23:33 <EvanR> > foldr (\z !unused -> z) 6 (repeat undefined)
13:23:39 <lambdabot>  mueval-core: Time limit exceeded
13:23:49 <MarcelineVQ> luckily a lot of bins are available on AUR so you can avoid the nonsense that way, but this is quite a hassle for people unfamiliar with it
13:23:51 <geekosaur> the problem there is 'nopie' is conflated with some other things ecuse ghc binary distributions are built on debian, so nopie goes along with some other debianisms
13:23:58 <geekosaur> but arch isn;t debian and they made different decisions
13:24:04 <EvanR> > foldr (\z unused -> z) 6 (repeat undefined)
13:24:06 <lambdabot>  *Exception: Prelude.undefined
13:24:14 <geekosaur> so you end up hosed on arch even if you aren't using arch packages
13:24:15 <EvanR> heh
13:24:20 <ertes> hololeap: challenge: implement foldl' (yes, the strict version) in terms of foldr
13:24:45 <CodeWeaver> Even doing the non-strict version is an exercise in mental warping.
13:24:46 <geekosaur> and the only real fix is to get a ghc binary distribution that was built on arch and therefore fits with how arch is organized/what decisions they made
13:25:10 <EvanR> next challenge, implement foldr in terms of foldl :)
13:25:10 <hololeap> ertes: i was already looking at the source for foldl' ;)
13:25:21 <geekosaur> but there's some hackarounds that mostly work... for now. but if either debian ior arch makes different decisions in the future, it might well break
13:25:59 <ertes> hololeap: does it spoil the challenge?
13:26:07 <hololeap> maybe a little.
13:26:11 <geekosaur> (which is why the nopie stuff ends up weirdly "linked to" libtinfo6)
13:26:11 <ertes> i haven't looked at the base source code
13:27:02 <ertes> i'd implement it in terms of foldr anyway to enable fusion
13:27:22 <hololeap> it is implemented in terms of foldr in base
13:27:43 <ertes> makes sense
13:28:19 <hololeap> phaazon: i don't know if it is relevant to your issue, but i was getting "unrecognized command line option '-nopie'" on gentoo after upgrading from gcc-5.* to gcc-6.* and i had to rebuild ghc
13:28:54 <phaazon> hololeap: I’ll try to get the latest one… but I’m trying the fix with ncurses things
13:28:58 <phaazon> that sounds insane
13:29:18 <hololeap> what does?
13:33:07 <cloudhead> phaazon: easiest way to get stuff working on arch imo is to get ghc-static 
13:33:19 <phaazon> what is that?
13:33:19 <cloudhead> and install the rest with stack or cabal
13:33:26 <cloudhead> it's just a statically linked version of ghc
13:34:06 <geekosaur> actyually it's just the static versions of the packages/libraries that ship with ghc, sin ce the arch ghc package only installs the shared/dynamic versions
13:34:45 <cloudhead> right ^
13:34:47 <geekosaur> but you still have a problem because if you have any other haskell packages installed from arch, they too only coem with dynamic lib s --- and there are not corresponding packages to get the statoic libs
13:35:25 <cloudhead> yeah you uninstall everything except ghc-static
13:35:27 <geekosaur> so if you're working with arch's ghc, the only sane way to do things is install ONLY ghc, ghc-static, and one or both of stack or cabal --- and use those to install EVERYTHING else
13:35:49 <cloudhead> yeah, that's what I did
13:36:15 <cloudhead> trying to use stack to install ghc was a mess
13:36:18 * hackage timemap 0.0.6 - A mutable hashmap, implicitly indexed by UTCTime.  https://hackage.haskell.org/package/timemap-0.0.6 (athanclark)
13:36:20 <geekosaur> (and since stack has a lot of deps, you have a bit of a conflict there --- lucking someone put a static build of stack in AUR, so you probably want that instead of the main repo's stack package)
13:36:28 <geekosaur> *luckily
13:36:30 <frank1> When is an expression well-formed and well-typed?
13:37:34 <hexagoxel> but if you don't use system ghc, stack should not be at all affected by pacman packages, provided ncurses-compat stuff (?)
13:37:41 <MarcelineVQ> geekosaur: if a person wanted to avoid AUR then once stack installed you can do a  stack upgrade  and use the new bin in ~/.local/bin  and uninstall stack
13:38:46 <hexagoxel> and if you install and use ghc bindists, pacman packages should not matter either.
13:39:03 <geekosaur> hexagoxel, you need to deal with the ncurses compat stuff because the terminfo stuff isn;t just versioning, it's debian deciding to take advantage of the binary compatobility break in ncurses 6 to change how they configure ncurses/terminfo.
13:39:23 <hololeap> haskell on arch might have some pitfalls, but it is nothing compared to the pain of trying to install anything haskell and gui-related on windows
13:39:51 <geekosaur> so if you have stack install a ghc, you have to force a specific combionation of options to get a working binary ghc, and install the compat terminfo stuff to match it. but then you should be fine with nothing else from arch
13:39:55 <hexagoxel> geekosaur: but you still need that workaround even for the "sane" approach you described, right?
13:40:00 <geekosaur> (it's a custom binarty distribution for arch)
13:40:14 <geekosaur> no, because you;re using arch';s ghc
13:40:26 <geekosaur> the ncurses-compat stuff is only iuf you have stack install a ghc for you
13:40:35 <geekosaur> because it will install one built for debian, not for arch
13:41:35 <geekosaur> and you need ncurses-compat to paper over the differences between how arch and debian configured their ncurses/terminfo packages
13:43:14 <the_2nd> warning, archlinuxler here. stack build seems to fail in zlib after update
13:43:28 <hexagoxel> i see. still don't complete get how ghc-static is less of a hack than ncurses-compat.
13:43:39 <sternmull> as i wrote earlier i have just ~/.stack/config.yaml with "ghc-build: nopie" in it and installed ncurses5-compat-libs from AUR and live without problems... using stack for everything, so stack is the only thing coming from pacman when i build my haskell stuff.
13:44:44 <geekosaur> right, you can do that ... sometimes. if you have certain arch packages installed, they'll install the arch terminfo6 library and stack will suddenly start guessing wring about which binary ghc to install
13:44:48 <the_2nd> https://pastebin.com/raw/P6W8PbAa
13:46:17 <geekosaur> oh, I guess the nopie thing si the change you need to avoid that,. thoughtyou needed another flag as well to avoid it trying to use tinfo6 (which then causes it to do other things that work on debian but not arch)
13:46:37 <the_2nd> I have ghc 8.2.1 in userspace and 8.0.2 within stack
13:46:55 <geekosaur> the_2nd, funny, we're just discussing that
13:47:08 <geekosaur> [24 21:43:17] <sternmull> as i wrote earlier i have just ~/.stack/config.yaml with "ghc-build: nopie" in it and installed ncurses5-compat-libs from AUR and live without problems... using stack for everything, so stack is the only thing coming from pacman when i build my haskell stuff.
13:47:56 <the_2nd> geekosaur, stack is the current version for me
13:48:09 <the_2nd> just updated an hour ago
13:48:10 <geekosaur> I said nothing about stack version
13:48:25 <geekosaur> you have to change the stack *config*
13:48:30 <geekosaur> that ghc-build entry
13:49:01 <hexagoxel> geekosaur: how would i install terminfo6? i have ncurses 6 installed, and stack works fine.
13:49:06 <geekosaur> because stack is trying to guess what ghc to install, but its guesses assume debian because the only ghc binary builds are from debian
13:49:28 <geekosaur> hexagoxel, you don't. if you force the nopie ghc then you get oine that uses terminfo 5, so you need the compat libs
13:49:58 <geekosaur> because debian switched to pie and upgraded to ncurses/terminfo 6 at the same time, and all the ghc bindists were built on debian
13:50:34 <geekosaur> so stack sees terminfo6 installed and picks the bindist that uses terminfo 6 ... but you also get PIE because it's for debian
13:50:49 <geekosaur> so you have to force nopie but that then requires terminfo 5
13:51:28 <geekosaur> (at that point you can have terminfo 6 installed, but ghc won't use it)
13:51:29 <the_2nd> geekosaur, it only contains comments and {} on the last line
13:51:41 <geekosaur> yes
13:51:41 <the_2nd> do I have to put the settings within the brackets?
13:51:52 <sternmull> i hope this gets sorted out soon. It feels bad to have a toolchain that is hold together with duct tape.
13:51:55 <the_2nd> don't usually see brackets in yaml?
13:51:55 <geekosaur> you put it on a line of its own, not indented
13:54:07 <the_2nd> geekosaur, seems like the {} marks an empty file
13:54:13 <the_2nd> had to remove it to get it to work
13:55:26 <hexagoxel> geekosaur: you mistake my intend. i want to test how brittle my setup is. so, how would i install terminfo6?
13:55:47 <geekosaur> it's part of the ncurses package. it's probably already installed since readline needs it
13:56:03 <geekosaur> that it's already installed is precisely why stack picks the wrong ghc initially
13:56:37 <geekosaur> because it grabs the build from the debian with ncurses 6, but that also gets the PIE build which does things non-PIE linkers don't understand... leading to the errors the_2nd pasted
13:57:17 <geekosaur> (so you set ghc-build: nopie to force the one with a compatible linker, and then you need ncurses 5 compat libs installed)
13:57:36 <hexagoxel> right. i still believe that both approaches are equally (in)sane. but good to know how exactly stuff might break in the next couple releases :)
13:58:55 <geekosaur> the only insane part is stack wanting to install binary ghc distributions and not having a collection of them by Linux distribution
13:59:23 <geekosaur> each distro makes its own decisions, and doing things like blindly assuming debian builds are 100% compatoble with everything else is what causes problems
13:59:24 <hexagoxel> well, and arch ghc defaulting to dynamic.
13:59:41 <hexagoxel> dynamic only.
14:00:04 <cloudhead> If my base monad is STM, what is the equivalent of liftIO?
14:00:10 <geekosaur> arch could have fixed that one too,. there's a knob in the ghc build that lets them set the default behavior to dynamic. (it's deprecated but ti's there. this might cause it to become undeprecated...)
14:00:21 <geekosaur> if they had set that, nost people wouldn;t see a problem
14:00:56 <geekosaur> (at least i they stick to the ghc from arch. the stack issues would still be there)
14:01:47 <yushyin> geekosaur: do you know the name of this flag by any chance?
14:01:49 <Welkin> hasn't arch been a disaster for haskell for months now?
14:02:02 <Clint> seems that way
14:03:11 <geekosaur> yushyin, not off the top of my head, I'm checking the ghc trac
14:05:23 <geekosaur> grrr. wonder if they fully deprecated it. not seeing it in build.mk or the wiki
14:06:47 <geekosaur> yep, looks like it was removed because it didn't actualy work https://ghc.haskell.org/trac/ghc/wiki/DynamicByDefault
14:06:52 <geekosaur> sigh
14:07:23 <yushyin> nice ...
14:07:53 <ertes> Welkin: a friend of mine is using arch, and he could only compile a tool i wrote for his project by using an overlay
14:08:22 <ertes> the official 'ghc' and 'cabal-install' packages didn't work
14:08:35 <the_2nd> geekosaur, the ncurses package is untrusted?
14:08:45 <the_2nd> Can't seem to be able to build ghc otherwise
14:09:28 <ertes> i was almost going to make him install nix, but luckily the overlay worked
14:09:42 <geekosaur> I'm ... not sure what you are referring to. 'untrusted' in the context of ghc normally means that you can;t load it with Safe Haskell enabled... but ghc source itself doesn't use Safe Haskell
14:10:01 <geekosaur> (except in the implemntation of Safe Haskell mode but that shouldn't touch ncurses)
14:10:31 <the_2nd> geekosaur, someone above wrote he installed ncurses5-compat-libs from the AUR
14:10:46 <the_2nd> but I get a Unsupported package : Potentially dangerous   there
14:11:17 <geekosaur> right. that's Arch being pedantic about only stuff from the main repo being trusted *by Arch*; installing third party stuff is always a potential risk
14:11:20 <MarcelineVQ> that's the nature of the AUR, it's packages maintained by users so there's no official support
14:11:35 <MarcelineVQ> whatever official support means for arch hehe :>
14:12:33 <geekosaur> in this case, it's not much of a risk; and if you;re paranoid, you can always grab the PKGBUILD from the AUR and look it over yourself
14:13:26 <geekosaur> but pacman doesn't know the risk profile of particular packages, only that anything not from the main Arch repo is not *completely known* to work with the main Arch repo
14:14:50 <the_2nd> aw can't install due to conflicts with libncurses.sp.5 in /usr/lib
14:15:05 <geekosaur> that sounds like something else installed a compat lib already
14:15:14 <geekosaur> but that would mean you don;t need the AUR one
14:15:31 <geekosaur> (hm, or not; depends on whether libtinfo.so.5 is also there)
14:16:01 <geekosaur> ...if it's notm you could just symlink it to libncurses.so.5
14:18:50 <the_2nd> ln -s /usr/lib/libncurses.so.5 /usr/lib/;ibtinfo.so.5
14:18:51 <the_2nd> ?
14:20:03 <EvanR> i was totally wrong foldl' doesnt act like foldr at all
14:23:03 <geekosaur> roughly yes
14:23:22 <geekosaur> I'd actually make it relative instead of absolute, but that confuses a lot of people, so.
14:23:49 <geekosaur> and you;d only notice the difference if you're on a system with a LOT of disk I/O (the full-path one will be slightly slower)
14:26:55 <the_2nd>  #haskell ftw. Got it to work
14:27:18 <the_2nd> Would be impossible and require lots of broken screens otherwise ;)
14:27:25 <the_2nd> thanks everyone and goodbye
15:00:21 <jason11> is it possible to define a total function of type (a->a)->a?
15:01:51 <erisco> @djinn (a -> a) -> a
15:01:51 <lambdabot> -- f cannot be realized.
15:02:34 <jason11> erisco: thanks :)
15:03:03 <jason11> @djinn a->a->a
15:03:03 <lambdabot> f _ a = a
15:12:24 <nshepperd> jason11: that's the type of fix
15:12:32 <nshepperd> which i guess would not count as total
15:13:20 <nshepperd> even though it is meaningful on the whole input domain
15:16:25 <EvanR> the existence of fix allows general recursion 
15:16:29 <EvanR> so no
15:27:07 <sphinxo> corrosponding haskell type for uint8_t*  ?
15:27:15 <ertes> sphinxo: Word8
15:27:20 <ertes> from Data.Word
15:27:26 <sphinxo> (Ptr Word*) ?
15:27:32 <ertes> oh, yeah
15:27:44 <ertes> Ptr Word8
15:27:58 <sphinxo> ok thanks
15:28:09 <ertes> sphinxo: what's the use case?
15:28:34 <sphinxo> ffi
15:28:51 <sphinxo> >     Module ‘Foreign.C.Types’ does not export ‘CBool’
15:28:53 <lambdabot>  <hint>:1:8: error: lexical error at character 'F'
15:29:02 <Welkin> sphinxo: lol, I read that as ffs
15:29:02 <sphinxo> https://hackage.haskell.org/package/base-4.10.0.0/docs/Foreign-C-Types.html#t:CBool ?
15:29:31 <geekosaur> which ghc version are you using?
15:30:29 <geekosaur> CBool is actually a bit of a complicated situation and how the FFI handles it has had to change in light of e.g. hoe C++ handles bools vs. how C99 handles them vs. how pre-C99 handles them
15:30:36 <geekosaur> *how C++
15:30:51 <sphinxo> oh wait, I was using a nightly then switch back to lts
15:31:29 <sphinxo> Since: 4.10.0.0 ( this is probably the clue )
15:33:46 <geekosaur> yep
15:34:21 <geekosaur> basically "CBool" didn't exist before, it was CInt because that's what older C did. but with C99 there is a need for an actual CBool that matches C99 semantics
15:34:32 <Tuplanolla> Oh, finally.
15:34:50 <geekosaur> but C99 has been rather slow to actually get into use, so it's only recently that that became an actual problem for Haskell FFI
15:37:08 <geekosaur> (be warned it may change in future versions though; there are known issues because what C++ expects for a boolean *differs* from C99 semantics, and this makes things kinda difficult for FFI to C that wraps C++)
15:38:58 <sphinxo> why are my cpp-options in my cabal file being passed into ghci? https://pastebin.com/raw/PhzLKcdb
15:39:17 <Welkin> what many (experienced) c and c++ programmer do is to define their own type for bool as an alias for int32 (or unit32)
15:39:30 <Welkin> uint32*
15:39:37 <Welkin> I make that typo all the time :P
15:39:43 <geekosaur> sphinxo, you have a typo and it will bite you in other ways later
15:39:53 <geekosaur> there must be *no* space between -I and the directory
15:40:27 <sphinxo> ahh 
15:40:30 <geekosaur> and as to why it is passed, not sure but possibly because it's needed if it has to dynamically load C
15:41:09 <geekosaur> (foreign import "ccall" requires dynamically geenrated stub C code, which will be affected by CPP options)
15:41:20 <sphinxo> ahh ok
15:41:38 <sphinxo> after removing the -std... I get https://pastebin.com/raw/K5KhNgGb
15:41:50 <sphinxo> not sure if it's an improvement
15:42:41 <geekosaur> you need the -std for that probably ("cxxabi"). nbut to get it through ghc you need to put it inside another option. hold on...
15:43:17 <geekosaur> -optc-stdc++11
15:43:21 <geekosaur> er
15:43:28 <geekosaur> -optc-std=c++11
15:43:37 <geekosaur> (with no space after -optc)]
15:44:09 <sphinxo> where does that belong? cpp-options?
15:44:13 <geekosaur> yes
15:44:32 <geekosaur> and I'm not sure that will fix it, but the "cxxabi" in the missing symbol suggests this is the issue
15:44:57 <geekosaur> since one of the things that -std option does is change which C++ runtime to use, and thereby which symbols it exports
15:45:58 <geekosaur> (as for why ghc would care... possibly because of libffi to handle the fine details of C<->Haskell interop)
15:46:24 <geekosaur> but libffi is also C++ and several other languages, so accesses their runtimes as well
15:46:53 <sphinxo_> the functions in my header file are wrapped in extern "C" { .. }
15:47:22 <sphinxo_> ( not sure if that's helpful/useful info)
15:47:25 <geekosaur> yes. but they call C++ code, so the symbols needed for that C++ code still need to be around
15:47:29 <sphinxo_> ahh 
15:48:16 <geekosaur> and more to the point, the symbols for all the support routines C++ code calls "behind the scenes" to do the actual work of e.g. gluing C++ objects together
15:49:28 <infinisil> This most recent video by Computerphile might just have convinced a couple thousand people to never use Haskell: https://youtu.be/t1e8gqXLbsU
15:49:48 <monochrom> Oh heh.
15:49:59 <infinisil> Yet another Monad tutorial, and a bad one at that
15:51:31 <infinisil> The comment section is hilarious
15:56:54 <mniip> seriously
15:57:15 <mniip> monoid in the category of endofunctors, with compositional addition
16:01:00 <zachk> is 300-400 lines of haskell code for a simplish chat server alot, or about spot on?
16:01:15 <mniip> simplish?
16:01:32 <zachk> chat to everyone, private messaging, and a who is logged in command
16:01:38 <mniip> depends on how abstract you are
16:02:05 <zachk> I use cloud haskell, so almost everything is an actor/process
16:02:08 <infinisil> seems about the right size
16:02:20 <mniip> could probably do it in 50 if you're clever with your types
16:02:39 <zachk> really?
16:03:04 <zachk> most of the types are :: stuff...-> more stuff -> Process () 
16:03:04 <mniip> if you use ParsecT over IO, or even plain Binary to read/write the messages
16:04:12 <mniip> and then handle all the messages sequentially in one function
16:04:21 <mniip> which instead of using IORefs could use StateT
16:05:04 <mniip> oh oh oh
16:05:07 <mniip> pipes!
16:05:20 <mniip> just write the server as a pipe combinator
16:07:32 <mniip> you could get really clever about it if you wanted to
16:07:47 <mniip> but of course, flexibility goes out the window
16:08:02 <EvanR> unless you use flexible pipes
16:08:13 <EvanR> hoses
16:08:20 <hpc> crazy straws
16:08:33 <mniip> I think you mean horses
16:08:49 * Clint whinnies
16:09:01 <mniip> which of course you mean ponies
16:20:27 <ertes> zachk: my first question would be how people would access that server
16:20:42 <ertes> web?  telnet?  a custom client?
16:21:42 <Welkin> telegraph wire
16:25:56 <illiquid> 371558678681014  04/20  5222 SUSAN P SELLA  13233 ALHAMBRA LAKE CIR  DELRAY BEACH  FL  334463734  UNITED STATES
16:25:57 <illiquid> 371558678681014  04/20  5222 SUSAN P SELLA  13233 ALHAMBRA LAKE CIR  DELRAY BEACH  FL  334463734  UNITED STATES
16:25:57 <illiquid> REMEMBER illiquid IS MY NAME, BITCHEZ! I OWN YOUR FREENODE ASSES!
16:26:14 <Welkin> what
16:26:42 * EvanR forgets their name immediately
16:27:29 <illiquid> 371558678681014  04/20  5222 SUSAN P SELLA  13233 ALHAMBRA LAKE CIR  DELRAY BEACH  FL  334463734  UNITED STATES
16:27:50 <MarcelineVQ> I feel more owned than usual.
16:28:01 <koz_> MarcelineVQ: So you feel pwnd? :P
16:28:42 <mniip> oh no not the freenode donkeys
16:30:37 <zachk> ertes: for now telnet handling doesnt work correctly, so raw mode from putty works fine
16:30:54 <zachk> netcat worked fine as well
16:31:17 <geekosaur> that's ... some persistent stupid
16:32:25 <EvanR> their coming in from all over the planet
16:32:35 <illiquid> 4564727009677400  07/20  689 sun yun  12/14 Meadow Cres  Meadowbank  state  2114  AUSTRALIA approved
16:32:36 <illiquid> 4564727009677400  07/20  689 sun yun  12/14 Meadow Cres  Meadowbank  state  2114  AUSTRALIA approved
16:32:36 <illiquid> REMEMBER ILLIQUID IS MY NAME, BITCHEZ! I OWN YOUR FREENODE ASSES!
16:32:43 --- mode: ChanServ set +o geekosaur
16:32:56 <boj> botnet i imagine
16:33:10 --- mode: geekosaur set +q illiquid!*@*
16:33:22 <EvanR> a simple nickban haha
16:33:29 * boj thanks geekosaur
16:33:37 <geekosaur> until they give up. basing the whole thing oin their nick was kinda stupid
16:33:50 --- mode: geekosaur set -o geekosaur
16:35:36 <geekosaur> so of course they evaded that too...
16:35:40 <geekosaur> oy
16:35:56 --- mode: ChanServ set +o geekosaur
16:36:12 <geekosaur> hah, now they're choking themself.
16:36:16 <geekosaur> "derp"
16:37:59 --- mode: geekosaur set -q illiquid!*@*
16:40:46 --- mode: geekosaur set -o geekosaur
16:46:34 <ertes> zachk: 300 lines sounds reasonable…  you could probably do with even less, depending on the libraries and level of abstraction you use
17:00:17 <GuessWhaccount> hey, ya ppl!
17:00:52 <SomeThing> hi
17:00:58 <koz_> Sup?
17:01:14 <GuessWhaccount> sup!
17:01:23 <GuessWhaccount> hi, SomeThing!
17:01:31 <SomeThing> what
17:01:42 <GuessWhaccount> i've just said hi
17:02:07 <SomeThing> waste of time
17:02:32 <GuessWhaccount> not for me. I have fun everywhere!
17:03:46 <GuessWhaccount> what time is it?
17:16:05 <mniip> % Data.Time.Clock.getCurrentTime
17:16:05 <yahb> mniip: 2017-11-25 01:15:43.090454189 UTC
17:16:38 <infinisil> > getCurrentTime
17:16:40 <lambdabot>  error: Variable not in scope: getCurrentTime
17:16:49 <infinisil> > Data.Time.Clock.getCurrentTime
17:16:52 <lambdabot>  error:
17:16:52 <lambdabot>      Not in scope: ‘Data.Time.Clock.getCurrentTime’
17:16:52 <lambdabot>      No module named ‘Data.Time.Clock’ is imported.
17:16:55 <EvanR> lambdabot doesnt run IO
17:17:00 <infinisil> man
17:17:07 <EvanR> > getChar
17:17:09 <jle`> lambdabot just evaluates expressions
17:17:09 <lambdabot>  <IO Char>
17:17:40 <EvanR> however if it loaded acme-now it could get the current time with pure code
17:18:13 <mniip> is acme-now the package that just gets its build date from the paths file
17:18:16 <infinisil> > let f x = f (f x) in f 1
17:18:17 <EvanR> since its always right now... its just a value
17:18:22 <lambdabot>  mueval-core: Time limit exceeded
17:18:28 <hpc> when will now be then?
17:18:41 <EvanR> now
17:18:44 <mniip> hpc, it won't be now then
17:18:52 <EvanR> or that
17:18:58 <EvanR> now /= then
17:19:14 <hpc> https://www.youtube.com/watch?v=nRGCZh5A8T4
17:19:22 <mniip> if it was now, then then it was now
17:19:37 <infinisil> hpc: "This video is not available"
17:19:49 <mniip> likewise
17:20:51 <mniip> infinisil, yahb is the slightly crazier distant relative of lambdabot
17:21:32 <infinisil> mniip: How robust? Can I try to bring it down?
17:22:35 <mniip> you can try
17:22:48 <mniip> but beware of the quirks
17:22:57 <koz_> Why write 'cata f = c where c = f . fmap c . project' instead of 'cata f = f . fmap (cata f) . project'?
17:23:36 <hpc> koz_: tying the knot maybe?
17:23:57 <koz_> hpc: I don't understnad hwat you mean.
17:24:37 <hpc> tying the knot is basically where you write an infinite data structure so it's actually looped instead of generating the same stuff over and over again
17:24:48 <hpc> so like, if you were to do let ones = 1 : ones
17:24:58 <hpc> there's only ever one cons cell, with a tail that points back to itself
17:25:01 <mniip> tying the knot yes
17:25:07 <mniip> that's exactly the reason
17:25:18 <mniip> GHC doesn't do CSE very often
17:25:23 <koz_> CSE?
17:25:26 <hpc> if you do (map id ones), it unties the knot and you have gajillions of cons cells again
17:25:30 <hpc> common subexpression elimination
17:25:58 <hpc> a good way to watch this happen is with Debug.Trace
17:26:19 <hpc> tying the knot is also an important part of memoization libraries
17:26:33 <koz_> Is there any kind of reading I can do about this to help me understand when (and when not) to do this?
17:26:55 <hpc> there's a haskell wiki page, but i read it yeeeeeaaars ago and it wasn't very good then
17:27:11 <hpc> you can sort of get part of the story from reading about how memoization works
17:27:21 <hpc> most of the rest is your standard time-space tradeoff stuff
17:27:22 <mniip> well
17:27:31 <hpc> unless someone else knows a better resource?
17:27:42 <mniip> are you familiar with how a functional language fits on the hardware
17:27:52 <mniip> if you figure that out it might become apparent
17:27:54 <koz_> mniip: Not really, no.
17:28:13 <koz_> Is there some reading for that?
17:28:36 <mniip> well see if you can come up with a sensible system that can interpret lambda calculus in a von-neumann environment
17:28:44 <mniip> (say, compile lambda calculus to C)
17:28:59 <koz_> I'd rather read about it if possible.
17:29:03 <koz_> I learn better that way.
17:29:10 <mniip> if you're out of ideas read about graph reduction machines
17:29:12 <mniip> in partigular,
17:29:17 <mniip> "Spineless Tagless G-machine"
17:29:29 <koz_> Paper, I assume?
17:30:12 <mniip> paper is "Implementing lazy functional programming languages on stock hardware" but yes
17:30:57 <koz_> Lol, figured SPJ would be the author...
17:31:49 <mniip> I did come up with something fairly similar on my own
17:32:13 <mniip> it's not rocket surgery,
17:32:19 <mniip> but really the cornerstone of the paper is the efficiency
17:37:45 <infinisil> As expected, yahb runs in a sandbox :P, but I got this:
17:37:47 <infinisil> % System.Process.readProcess "../bin/uname" ["-a"] ""
17:37:48 <yahb> infinisil: "Linux mniip.com 4.9.0-0.bpo.3-amd64 #1 SMP Debian 4.9.25-1~bpo8+1 (2017-05-19) x86_64 GNU/Linux\n"
17:38:42 <infinisil> % readFile "lol"
17:38:42 <yahb> infinisil: "Message from infinisil: Hi!"
17:39:36 <mniip> there's %! if you want to play
17:39:47 <mniip> with a debian almquist shell
17:40:42 <infinisil> No idea what that is
17:40:43 * hackage tweet-hs 1.0.1.33 - Command-line tool for twitter  https://hackage.haskell.org/package/tweet-hs-1.0.1.33 (vmchale)
17:44:49 <mniip> debian's bash
17:45:57 <ertes> % pure True :: IO Bool
17:45:58 <yahb> ertes: True
17:46:03 <ertes> hmm?
17:46:39 <ertes> % System.Directory.listDirectory "/"
17:46:40 <yahb> ertes: *** Exception: /: getDirectoryContents:openDirStream: does not exist (No such file or directory)
17:48:09 <mniip> :D
17:48:13 <ertes> % liftA2 (,) System.Info.os System.Info.arch
17:48:14 <yahb> ertes: [('l','x'),('l','8'),('l','6'),('l','_'),('l','6'),('l','4'),('i','x'),('i','8'),('i','6'),('i','_'),('i','6'),('i','4'),('n','x'),('n','8'),('n','6'),('n','_'),('n','6'),('n','4'),('u','x'),('u','8'),('u','6'),('u','_'),('u','6'),('u','4'),('x','x'),('x','8'),('x','6'),('x','_'),('x','6'),('x','4')]
17:48:24 <ertes> oh, those are pure strings
17:48:30 <ertes> % (System.Info.os, System.Info.arch)
17:48:31 <yahb> ertes: ("linux","x86_64")
17:48:36 <mniip> hahhaha
17:48:54 <mniip> did you just take a cartesian product of two strings
17:48:59 <ertes> yeah =)
17:49:23 <ertes> % System.Directory.getCurrentDirectory
17:49:25 <yahb> ertes: "/var/lib/xsbot/sandbox/root/data"
17:49:54 <EvanR> there was a conal blog post calling out those pure strings
17:50:21 <EvanR> the meaning of a program that uses them depends on where it is running
17:51:28 <ertes> well, there are quite a few things in base you could call out regarding that
17:51:32 <infinisil> Apparently this machine only has 54MB of memory
17:51:43 <ertes> the meaning of a program that uses Int could change depending on where it's run
17:51:57 <ertes> you could distinguish architecture through Int overflows
17:52:01 <jle`> @let import System.Info
17:52:02 <lambdabot>  Defined.
17:52:05 <jle`> > (os, arch)
17:52:08 <lambdabot>  ("linux","x86_64")
17:52:19 <EvanR> http://conal.net/blog/posts/notions-of-purity-in-haskell
17:52:26 <infinisil> % appendFile "big" $ take 1000000 ['\0','\0'..]
17:52:27 <jle`> et tu lambdabot
17:52:27 <yahb> infinisil: *** Exception: big: hClose: resource exhausted (No space left on device)
17:52:43 <ertes> what i care about is that those strings don't change for the duration of 'main' execution
17:53:07 <ertes> % writeFile "let-me-guess.txt" "permission denied"
17:53:07 <yahb> ertes: *** Exception: let-me-guess.txt: hClose: resource exhausted (No space left on device)
17:53:12 <ertes> or that
17:53:29 <EvanR> ertes: i think the question to answer is... why are these OS strings not simply an IO query like getChar
17:53:33 <EvanR> or getArgs
17:53:41 <jle`> i mean within a program, they obey ref transp
17:53:47 <jle`> and they behave like pure values
17:53:56 <infinisil> % removeFile "big"
17:53:57 <EvanR> and what is their value?
17:53:57 <yahb> infinisil: 
17:53:59 <mniip> %! df -h
17:53:59 <yahb> mniip: Filesystem Size Used Avail Use% Mounted on; /dev/loop1 58M 1.6M 54M 3% /var/lib/xsbot/sandbox/root/data
17:54:49 <infinisil> % writeFile "let-me-guess-again.txt" "aww yeah"
17:54:49 <yahb> infinisil: 
17:54:59 <infinisil> % readFile "let-me-guess-again.txt"
17:54:59 <yahb> infinisil: "aww yeah"
17:55:25 <ertes> EvanR: the only way i see them changing is if you live-migrate the program to a different OS
17:55:52 <EvanR> and isnt the unchangingness of the OS string a function of our inability to switch OS at runtime
17:56:06 <ertes> it is
17:56:21 <EvanR> point is.. an IO query doesnt seem unwarranted
17:56:23 <mniip> suppose arch becomes an IO String
17:56:33 <mniip> mechanisms to switch arch at runtime won't magically collapse into existence
17:56:44 <ertes> but if we could, then relying on 'os' would be the wrong approach anyway
17:56:45 <EvanR> getArgs should be a pure value?
17:56:55 <EvanR> the systems total memory?
17:56:55 <ertes> live-changing the OS is an event, and you should treat it as such
17:57:06 <mniip> EvanR, each of those can change at runtime
17:57:09 <mniip> reasonably too
17:57:09 <EvanR> the systems memory in-use-at-the-time-of-program-start?
17:57:17 <EvanR> the programs start time in UTC?
17:57:19 <ertes> EvanR: there is RAM hot-plugging
17:57:37 <EvanR> anything you can get from the file system or the internet at startup should be available as a pure value?
17:57:38 <ertes> the program's start time could indeed be a pure value
17:57:51 <infinisil> IPFS should be a pure value!
17:57:54 <EvanR> it seems to be adding more stuff to the implicit boot up sequence we already dont see
17:58:13 <ertes> the question is whether you want the RTS to retrieve those values at startup
17:58:27 <ertes> if you do, by all means, make them pure values
17:58:29 <EvanR> i think the semantics of haskell dont really have a loophole for this as is, you need new semantics for "IO prior to startup"
17:58:42 <EvanR> (with no way to control it really)
17:58:47 <infinisil> Wait no, a hash on IPFS can either exist or not exist, which depends on IO, so IPFS can't be pure
17:59:16 <jle`> EvanR: System.Info.os etc. are generated at compile-time i believe
17:59:27 <EvanR> like, the meaning of a haskell value of type A -> B may not be anything in particular in isolation, thanks to this
17:59:34 <EvanR> its not a particular function
17:59:40 <jle`> it's basically the same issue as Template Haskell
17:59:41 <infinisil> jle`: sooo, crosscompiling breaks it?
17:59:41 <EvanR> its a IO (A -> B)
17:59:46 <EvanR> which has no semantics
17:59:48 <ertes> EvanR: again: you can use pure Int to distinguish architecture, so if you want to take your argument to its conclusion, you have to make the size of Int fixed as well
18:00:02 <jle`> infinisil: it should, yes, unless you take this into account
18:00:05 <EvanR> the behavior of Int is another gripe, and not related to this
18:00:28 <EvanR> you would fix Int by deciding what it means, or replacing it with Integer
18:00:34 <ertes> @let is64Bit = (2^32 :: Word) == 0
18:00:36 <lambdabot>  Defined.
18:00:37 <jle`> but yeah, for distributed programming, System.Info.os should make no sense
18:00:41 <ertes> err
18:00:42 <ertes> @undef
18:00:42 <lambdabot> Undefined.
18:00:46 <EvanR> you cant really decide what System.os means
18:00:46 <ertes> @let is64Bit = (2^32 :: Word) /= 0
18:00:48 <lambdabot>  Defined.
18:00:52 <ertes> > is64Bit
18:00:54 <lambdabot>  True
18:01:04 <jle`> the way i say it it's the same as using TH to splice in configuration files
18:01:13 <jle`> it's embedded directly into the binary
18:01:22 <EvanR> it is, but you control what TH you use and decide to forget all semantics
18:01:31 <EvanR> conals gripe was os was in a base library
18:02:02 <ertes> EvanR: what's the gripe with Int?
18:02:08 <EvanR> same thing youre saying
18:02:16 <ertes> i don't consider that a gripe
18:02:43 <infinisil> Does ghci not have a :printdef like command?
18:02:59 <EvanR> the question is always, what does this program mean
18:03:11 <ertes> if 2^32 = 0, then it remains that way throughout the execution of the program, so i can share and refactor…  that's what i care about
18:03:41 <EvanR> if you wanted to be explicit about what a haskell program means, without knowing what kind of computer it runs out, well you cant
18:03:50 <EvanR> unfortunately
18:04:20 <infinisil> All we need is a model of a turing machine
18:04:56 <ertes> why would i care about that?  this seems like a minor issue to me
18:05:20 <EvanR> you dont have to care about semantics
18:05:29 <EvanR> we got to this point without them, somehow
18:05:34 <ertes> that's not what i mean
18:05:45 <EvanR> i am always wondering what Int is going to do
18:06:01 <ertes> why would i care that Int is the same type everywhere?  it doesn't affect my ability to use equational reasoning
18:06:04 <EvanR> i pretend it is either 32 or 64 bits wide, and do two reasonings and stop
18:06:14 <EvanR> but that is technically wrong
18:07:08 <Welkin> but you need to care about symantec
18:14:12 <EvanR> "Thus the value of the expression “2^32 == (0 ::Int)” may be either False or True, depending on the dynamic conditions under which it is evaluated." :(
18:16:10 <EvanR> so the meaning of that expression isnt a math truth value, its perhaps Architecture -> Bool
18:20:10 <ertes> how would you solve it?
18:20:48 <ertes> withMachineInt :: (forall int. (Num int, Integral int, …) => Proxy int -> IO r) -> IO r
18:24:49 <khl> what's the easiest way to expose a pure C++ to be callable from Haskell as FFI
18:24:57 <khl> ?
18:25:00 <khl> No classes or anything, just a function.
18:25:30 <ertes> khl: if you are in control, extern "C"
18:27:09 <khl> ertes so make extern C declarations ina header file
18:27:16 <khl> and they will be visible to haskell as C functions?
18:27:38 <EvanR> nothing speaks C++ ABI except C++ compilers
18:27:55 <infinisil> EvanR: How so?
18:28:12 <EvanR> extern C is the way anything besides C++ is able to use C++ code
18:28:23 <EvanR> the only real way
18:31:58 <eacameron> Is there a strict addition function somewhere?
18:32:39 <wagle> I saw a "trick" years ago where you cou;d get ghc to emit either the "answer", or else a string (?) oof the program to compute that answer..  is this a thing?  what's it called?
18:33:13 <ertes> khl: of course you need to compile those functions using those header files as well
18:33:42 <ertes> eacameron: (+) is strict on most types
18:33:52 <ertes> > undefined + 0 :: Integer
18:33:54 <lambdabot>  *Exception: Prelude.undefined
18:33:55 <ertes> > undefined + 0 :: Double
18:33:57 <lambdabot>  *Exception: Prelude.undefined
18:34:18 <eacameron> ertes: That doesn't prove much because it's being forced by the print
18:34:34 <ertes> eacameron: that's not what strict means
18:34:53 <ertes> eacameron: a function f is strict, if (f ⊥ = ⊥)
18:34:53 <EvanR> > seq (undefined + 0) 'a'
18:34:56 <lambdabot>  *Exception: Prelude.undefined
18:36:25 <ertes> eacameron: this smells like an XY question…  what's the actual problem?
18:36:43 <Welkin> what is an XY question?
18:37:01 <EvanR> do we have lazy Nats loaded somewhere
18:37:07 <eacameron> asking about a solution instead of a problem
18:37:15 <wagle> google has the answer to xy
18:37:38 <eacameron> ertes: So what would I call it then, if not strict? I don't want thunk buildup
18:38:04 <eacameron> All the classic examples of space leak use repeated applications of +
18:38:13 <ertes> eacameron: thunk buildup is not an issue with (+), but with how it's used
18:38:26 <ertes> foldr (+) 0  -- thunk buildup
18:38:32 <ertes> foldl' (+) 0  -- no thunk buildup
18:38:50 <EvanR> yeah the fact that + *is* strict is why the folds dont work well
18:38:57 <ertes> if (+) were non-strict, the foldl' version might build up thunks
18:39:02 <ertes> *might*
18:39:06 <EvanR> if you had lazy addition, foldr would work :)
18:39:29 <ertes> and with a non-strict (+), foldr might turn out to work better
18:39:36 <ertes> it's all a question of how you use them
18:40:08 <ertes> for example (foldr (+) 0) would be totally reasonable *and preferred* over the foldl' version for an inductively defined Nat type
18:40:13 <eacameron> I clearly still have to learn more about how this works. But for the time being, this is no XY question. I literally have a fold and a I want to use +. :P
18:40:22 <EvanR> use foldl'
18:40:34 <eacameron> I'm using Reflex foldDyn
18:40:37 <EvanR> assuming you want to add up things in a list
18:40:41 <EvanR> ah
18:40:48 <EvanR> the real question
18:40:49 <eacameron> So I don't know how that behaves.
18:40:51 <ertes> eacameron: be sure to actually consume the value
18:41:07 <ertes> i.e. sample the underlying behaviour
18:41:28 <ertes> Behaviour is non-strict in the current value
18:41:37 <ertes> *Behavior
18:42:23 <eacameron> So I need to actually force it. I think I will be. It's a counter but I'll be using `even` on it, which should case analyze
18:42:43 <ertes> eacameron: even if you only need the value every 1000 frames, you should still sample it in every frame, otherwise you will be building up thunks for 1000 frames before collapsing them into a final value
18:43:10 <eacameron> ertes: I will be, but let's say I wasn't. How would I prevent thunks?
18:43:44 <eacameron> `0 +! 0 = 0; x +! y = x + y` ? :P
18:44:25 <eacameron> or `case x + y of 0 -> 0; z -> z`
18:44:49 <EvanR> there isnt an eager accumulator ?
18:44:53 <EvanR> in reflex
18:45:09 <EvanR> like there is a strict MVar
18:45:51 <EvanR> eacameron: seq is the magic trick to cause evaluation
18:46:18 <EvanR> > let x = undefined in fst (1, x)
18:46:20 <lambdabot>  1
18:46:21 <eacameron> I'm scared of seq because I still don't have a good sense of when it *actually* helps.
18:46:26 <EvanR> > let x = undefined in x `seq` fst (1, x)
18:46:28 <lambdabot>  *Exception: Prelude.undefined
18:46:42 <ertes> eacameron: sample and force…  that's how you prevent thunks
18:47:18 <eacameron> Is it possible to write my + in such a way that at least the each iteration of the fold collapses the last?
18:47:19 <EvanR> eacameron: outside the context of reflex... im just saying you would use seq instead of that artificial case, just because thats what its for
18:47:24 <CodeWeaver> If you know one expression is being evaluated, you can use that fact to force another expression to evaluate as a sort of invisible side effect using seq.
18:47:31 <EvanR> bang patterns do the same thing
18:47:38 <ertes> eacameron: !x <- sample (current dyn)
18:47:44 <eacameron> EvanR: I see. Thanks.
18:48:25 <EvanR> with sums you want to evaluate the intermediate states of the accumulator somehow, else you get a waste of memory
18:48:38 <eacameron> EvanR: Right that's all I care about really.
18:48:39 <EvanR> thats one case when it helps
18:49:04 <EvanR> different libs have different utilities for causing the eager evaluation
18:49:05 <eacameron> I don't want to risk the caller not forcing every frame
18:50:03 <EvanR> is it really a per frame thing?
18:50:26 <EvanR> i would figure its a per + thing
18:52:23 <eacameron> I mean that ertes solution scares me because now I've got to worry that the caller is demanding this value frequently.
18:52:35 <eacameron> I can't promise that. But there's never a reason to remember all past +s
18:53:01 <EvanR> yes, if this were a record that kept being updated per loop, a strict field would fix it
18:53:15 <EvanR> if it were an mvar with the sum in it, a strict mvar would fix it
18:53:25 <EvanR> seems like there would be a reflex equivalent
18:53:40 * wagle ponders the question "is there a pattern to what you will always compute vs sometimes?"  dunno if that helps
18:53:54 <wagle> is always, do strict
18:54:00 <wagle> if always, do strict
18:54:17 * wagle does not necessarily know what he's talking about
18:54:30 <eacameron> It's just `a`, in my case (Int, b); I could do (,) $! a $! b?
18:55:20 <EvanR> that would be a strict pair
18:55:28 <EvanR> or would be simplified by
18:55:44 <eacameron> Right, but I'd rather not change the type just for this.
18:55:46 <EvanR> but you can always "manually" evaluate the inputs to the constructor instead
18:55:54 <EvanR> using seq or bang patterns or $!
18:56:25 <EvanR> let !x = foo in !y = bar in (x,y)
18:56:38 <CodeWeaver> Alright, I asked this this morning, but there's other people in here now, so, can't hurt to ask a refined version of it...
18:56:44 <ertes> eacameron: this is something you need to be aware of in haskell in general
18:57:14 <eacameron> ertes: You're right. I do need to understand this better in general.
18:57:32 <eacameron> EvanR: Is that different from (,) $! x $! y?
18:57:49 <CodeWeaver> Given this version of splitAt, which is a type specific version of the one in base... why does -O0 cause it to build up memory usage, but -O1 does not?  What specific optimizations are making the function safe to evaluate in this way, where the first sublist is consumed before the second one is examined?
18:57:52 <CodeWeaver> https://pastebin.com/ysSdgfwZ
18:57:54 <ertes> eacameron: the price of laziness is that you need to be careful about the data interactions in your code
18:57:56 <EvanR> no but i think itll be nicer in your real code, since x and y are coming from somewhere
18:58:02 <EvanR> put a bang on that variable binding
18:58:19 <eacameron> EvanR: Oh! Quite right...
18:58:39 <CodeWeaver> We seem to be in lazy-analysis mode, so I figured it couldn't hurt to re-ask. ;)
18:58:47 <ertes> eacameron: but there is one simple rule of thumb that should get you far enough:  only IO can force, nothing else
18:59:02 <eacameron> ertes: Interesting!
18:59:09 <EvanR> hrm ... huh
18:59:22 <eacameron> In that case .... `unsafePerformIO . evaluate` :P
18:59:27 <EvanR> yeah
18:59:33 <EvanR> there are several things that cause evaluation
18:59:38 <mniip> CodeWeaver, probably strictness analysis
18:59:39 <ertes> all forcing in pure code is transitive…  it all originates in IO
19:00:03 <EvanR> when you are on ghci, that is not what it feels like
19:00:25 <CodeWeaver> mniip:  Is there an optimization I can turn on, after saying -O0, to show this to be true?
19:01:07 <EvanR> primitive arithmetic, case analysis, and evaluate :: a -> IO a, and outputting data can cause evaluation
19:01:18 <EvanR> and seq
19:01:30 <eacameron> I think the point is that only IO actually *starts* the domino effect.
19:01:44 <ertes> exactly
19:01:47 <EvanR> sure... nothing happens at all without IO
19:01:48 <eacameron> seq and case analysis lay out the dominos
19:02:35 <eacameron> But I suppose that's helpful to think of it more like a tree (domino design) of chain reactions.
19:02:44 <EvanR> but the concept of i have an expression, evaluate to WHNF, makes total sense in isolation
19:02:50 <ertes> eacameron: another important question you should keep in mind for strictness reasoning is: "what happens, if i pattern-match on this?"
19:03:41 <eacameron> ertes: What in particular do you have in mind? I realize that pattern matching will need to demand the input enough to case it.
19:04:58 <ertes> eacameron: pattern-matching is where you care about strictness…  for example 'print' is really (putStrLn . show), and putStrLn looks at the string character by character…  if the string is a typical product of 'Show', then it will be lazily generated from the original value
19:05:31 <ertes> > take 4 (show (12 : undefined))
19:05:35 <lambdabot>  "[12*Exception: Prelude.undefined
19:05:42 <ertes> > take 3 (show (12 : undefined))
19:05:44 <lambdabot>  "[12"
19:06:10 <eacameron> Heh that's actually pretty freaking awesome.
19:06:12 <EvanR> foldDyn really doesnt evaluate the result of applying that function?
19:06:30 <eacameron> EvanR: Maybe I should just look. I don't know. 
19:06:33 <EvanR> (immediately)
19:06:34 <mniip> CodeWeaver, this best I can give you is https://downloads.haskell.org/~ghc/7.8.1-rc1/docs/html/users_guide/options-optimise.html
19:07:03 <ertes> EvanR: Behavior isn't strict in the current value
19:07:16 <EvanR> what does Behavior have to do with it
19:07:23 <EvanR> foldDyn :: (Reflex t, MonadHold t m, MonadFix m) => (a -> b -> b) -> b -> Event t a -> m (Dynamic t b)
19:07:28 <CodeWeaver> mniip: Thanks.  I've been over that trying to either add optimizations to -O0, or remove them from -O1, and I came up with a set of three in trying to cause -O1 to misbehave, but those alone added to -O0 don't improve matters.  It's odd to me.
19:07:49 <eacameron> EvanR: Dynamic is just Behavior and Event
19:07:53 <ertes> EvanR: semantically (Dynamic t a ≃ (Event t a, Behavior t a))
19:08:14 <EvanR> use Behavior' ?
19:08:18 <EvanR> heh
19:08:21 <eacameron> Lol
19:09:38 <EvanR> whether Behavior is strict, isnt this a question about foldDyn
19:11:05 <EvanR> it seems to depend on the monad
19:11:09 <eacameron> EvanR: Yeah but foldDyn builds a Bahavior somewhere in there...I think that's the point. My guess is that foldDyn is very lazy
19:11:13 <ertes> i suppose foldDyn could do a strict scan, but it doesn't
19:11:33 <ertes> if anything, there should be foldDyn'
19:11:39 <EvanR> it builds a behavior using sample and hold in the monad m
19:11:56 <ertes> but i would be kinda cautious around such a function and sample anyway
19:12:08 <eacameron> Reflex makes gratuitous use of MonadFix, and thus tends to be pretty lazy.
19:12:23 <EvanR> ertes: if you sample once per frame, to force a sum, that might not be frequent enough to stop thunks accumulating
19:12:39 <ertes> eacameron: SpiderHost is really just IO
19:12:50 <ertes> it's pretty much just reusing IO's MonadFix
19:12:51 <EvanR> if theres 1000 increments per frame
19:13:05 <ertes> EvanR: yes, it is
19:13:05 <eacameron> Heh I didn't know IO had a MonadFix instance...
19:13:25 <ertes> EvanR: reflex can only update behaviours in trigger frames
19:13:25 <EvanR> 1000 (+1)'s piled up is just gross
19:14:12 <ertes> EvanR: make sure that your scans are strict, then sampling in every frame will be enough
19:14:21 <EvanR> scans?
19:14:29 <ertes> foldDyn
19:14:48 <ertes> it's basically scanl over time =)
19:14:54 <EvanR> do you mean make the (a -> b -> b) strict?
19:15:13 <ertes> depends
19:15:26 <EvanR> im not sure what you mean by make the scan strict
19:15:56 <ertes> well, if you do this:  !x <- sample (current dyn)
19:16:18 <ertes> then you'll want the (a -> b -> b) to be strict enough for that to actually compute the value
19:17:05 <CodeWeaver> ..and now I'm knee deep in GHC strictness analysis documentation ;)
19:17:29 <EvanR> how will the thing your are sampling now be a big pile of iterated a -> b -> b 's
19:17:33 <EvanR> not*
19:17:54 <ertes> because you're sampling in every frame
19:18:04 <EvanR> frame = trigger frame?
19:18:19 <ertes> yes…  reflex' notion of frame is triggering events
19:18:32 <ertes> and it's the only time where reflex will update behaviours
19:19:35 <EvanR> so long story short, if you have a counter and not doing anything with it yet, you will need an artificial sampler somewhere that is always poking it to keep memory from leaking
19:19:40 <ertes> so if you sample all relevant behaviours after each fireEventsAndRead and friends, then you will not pile up thunks
19:19:49 <ertes> yes
19:19:51 <EvanR> or even if you dont intend to use it very often
19:20:01 <EvanR> you need an artificial poker doohickey
19:20:27 <ertes> however, if you don't use it anywhere, chances are it will just be garbage-collected =)
19:21:03 <EvanR> really... if its in scope in one of your recurring do blocks...
19:21:22 <EvanR> guess i dont know what "use" means
19:21:44 <ertes> unless GHC detects that you're pointlessly passing it around, yes, you have to sample it
19:22:01 <EvanR> wacky
19:22:42 <ertes> it's the same way with a pipes Producer that you keep poking, but never actually use the value it gives you
19:23:06 <EvanR> is that a thing you have to do... 
19:23:38 <ertes> or simpler: it's the same way with a lazy list that you traverse, but ignore the values of
19:24:07 <ertes> last (iterate succ 0)  -- this will actually blow up
19:24:24 <EvanR> huh
19:24:30 <ertes> (if you want to try it, use '+RTS -M16m' or something)
19:24:44 <EvanR> that doesnt use constant space?
19:25:11 <EvanR> seems horribly wrong
19:25:30 <ertes> it's totally reasonable…  GHC doesn't know that the list is infinite
19:25:41 <ertes> 'last' is strict in the last value
19:25:54 <wagle> the GC cant keep up?
19:25:55 <ertes> so it will keep building and building
19:25:57 <ertes> nope
19:26:02 <ertes> the GC doesn't even kick in
19:26:09 <EvanR> that makes no sense
19:26:10 <ertes> it does GC the list, but not the value
19:26:23 <ertes> it's not the list that blows up, it's the sum
19:26:29 <wagle> ah
19:26:30 <EvanR> well that makes sense
19:26:34 <mniip> 1511580223 [06:23:43] <ertes> last (iterate succ 0)  -- this will actually blow up
19:26:38 <EvanR> it collects the list and the old value
19:26:39 <mniip> how many laayers of irony are you on
19:26:43 <wagle> ah
19:27:01 <ertes> mniip: sorry, i didn't get that =)
19:27:07 <mniip> :(
19:27:15 <MarcelineVQ> mniip: like, maybe 5 or 6 right now. my dudfe
19:27:18 <EvanR> last (iterate succ 0) :: Int
19:27:31 <EvanR> shouldnt use infinite memory, imo
19:27:40 <wagle> briefly thought of casting as Int, but my brain didnt see that going anywhere interesting..  but
19:27:44 <mniip> MarcelineVQ, dfufdfe
19:27:48 <ertes> @let iterate' f = go where go !x = x : go (f x)
19:27:50 <lambdabot>  Defined.
19:28:00 <ertes> last (iterate' succ 0)  -- this will run in constant space
19:28:00 <MarcelineVQ> mniip: dfudfefe
19:28:14 <mniip> what no that's the wrong meme
19:28:17 <ertes> reason is that it makes pattern-matching on the (:) strict in the current value
19:28:53 <ertes> whenever 'last' pattern-matches on (:), it will force the running sum as a side effect
19:28:56 <EvanR> now i am not sure anymore what we are exhibiting
19:29:14 <ertes> and that makes it constant
19:29:28 <EvanR> oh were talking about forcing a pile of (+1)s
19:29:44 <CodeWeaver> Blargh, silly disconnecting client.
19:29:50 <ertes> (well, logarithmic really, because 'succ' on the default Integer still keeps growing)
19:29:52 <mniip> EvanR, memes
19:29:53 <MnemoniX> hey all
19:30:02 <MnemoniX> happy holidays
19:30:45 <ertes> mniip: i know it's awkward, but would you mind explaining the joke?
19:30:56 <ertes> hi MnemoniX
19:31:02 <MnemoniX> Can i deploy my HaBot here for beta testing
19:31:10 <mniip> ertes, google "layers of irony"
19:31:25 <ertes> MnemoniX: just create a temporary channel
19:31:31 <EvanR> layers of irony comic meme, no idea where it came from
19:31:34 <mniip> and "hfeflflfo" (the first video result)
19:31:35 <GuessWhaccount> habot?
19:31:39 <GuessWhaccount> what does it do?
19:31:49 <MnemoniX> I idea is for every 1 to try ole Hal out
19:32:00 <MnemoniX> Hes preety col
19:32:08 <MnemoniX> been on him for a year now
19:32:10 <GuessWhaccount> can i order a pizza through habot?
19:32:23 <MnemoniX> free here Yes
19:32:32 <MnemoniX> from my house
19:32:45 <GuessWhaccount> xD
19:32:47 <mniip> in what way is habot related to the topic of this channel
19:32:47 <MnemoniX> Hals pretty cool
19:33:21 <MnemoniX> I picked this channel because of the reviews about how nice this channel is
19:33:31 <ertes> hah, i see
19:33:47 <GuessWhaccount> How nice this channel is¡?
19:33:56 <mniip> it's only nice to people who participate in the on-topic conversations
19:34:06 <MnemoniX> ah
19:34:07 <GuessWhaccount> ic}
19:34:37 <mniip> I host a couple of bots in this channel but again they're on-topic
19:34:45 <ertes> now MnemoniX's question sounds kinda ironic…
19:35:10 <ertes> or am i just being overcynical again?
19:35:23 <ertes> or should i say…
19:35:30 <ertes> do i have 50 fields?  i do have 50 fields!
19:35:35 * supercynic powers up
19:35:37 <MarcelineVQ> ertes: I warned you about stairs bro
19:35:40 <supercynic> … SUPER-CYNICAL!
19:35:53 <mniip> 50 fields huh
19:35:54 <MnemoniX> IIP: i have know idea what the topic is,,lol. Hal covers about 20k Topics and growing at a geometric rate
19:36:25 <mniip> you could have looked up
19:36:42 <supercynic> yes, you need 50 fields to become super
19:36:45 <mniip> in the 6 minutes that you've been here and had been repeatedly being pointed to the topic
19:36:50 <EvanR> you could only get here by typing in the name of the channel
19:36:59 <EvanR> which also answers the question
19:37:00 <mniip> if only there was some command to see what the topic of the channel is
19:37:05 <mniip> hmm
19:37:08 <MnemoniX> Oh i forgot to say: Hal is a Loebner prize winning Learning Engine
19:37:13 <mniip> I'd name it /topic
19:37:41 <supercynic> MarcelineVQ: you never warned me about stairs
19:38:13 <geekosaur> um, people? careful. I've run across at least o ne client where typing "/top[ic" doesn't show the current topic, it tries to clear the current topic
19:38:28 <geekosaur> (which I rthink will fail here for non-ops, but it still won;t show anyone using those clients wtf is going on)
19:38:29 <mniip> this channel is +t
19:38:38 <MnemoniX> well: im off then to try and find a Home for Hal to Hang out and party with the people
19:38:49 <MarcelineVQ> supercynic: i told you dog
19:38:54 <mniip> MnemoniX, right sorry this isn't really that type of channel
19:39:02 <supercynic> MarcelineVQ: you're confusing me with erisco
19:39:27 <EvanR> we are trying to chat about Haskell the programming language here
19:39:39 <MnemoniX> Can any 1 recommend a channel that wont start flaming
19:39:52 <MnemoniX> Ahhh
19:39:59 <mniip> 1511580979 [06:36:19] <supercynic> yes, you need 50 fields to become super
19:40:01 <mniip> SuperDynFlags
19:40:13 <EvanR> what is 50 fields
19:40:29 <mniip> I don't know. I keep imagining a record with 50 fields
19:40:39 <EvanR> i am getting there
19:40:43 <EvanR> so far, 26
19:40:49 <supercynic> nah…  a field is a ring, where the multiplication monoid is a group
19:41:13 <erisco> just remember he is the cynic, I am the outlaw
19:41:32 <mniip> um
19:41:39 <mniip> I have an infinite collection of fields sweetie
19:42:21 <supercynic> you also need to be a cynic
19:42:34 <mniip> cyanic?
19:42:34 <captainahab> Is it possible to parse "(a(ras)   (ars)" as "a(ras) ars" as in parse the contents of each parenthesed expression ignoring orginal expression
19:42:41 <wagle> vast tracts of land?
19:42:51 <captainahab> Using Parsec?
19:43:01 <CodeWeaver> Hm, turning off strictness analysis after -O1 in fact does not expose the bad behaviour.  Curiouser and curiouser.
19:43:41 <erisco> captainahab, can you be more precise? how did you determine the correct output there?
19:44:26 <captainahab> identify each expression contained by parentheses and then return them
19:44:32 <supercynic> mniip: if you don't get the joke, you probably grew up with nintendo =)
19:44:47 <erisco> captainahab, how did you determine the expressions contained by parentheses?
19:44:52 <supercynic> (or i superobscured it)
19:44:56 <MarcelineVQ> supercynic: is it a jaguar joke?
19:44:58 <mniip> oh there's a meme I'm missing
19:45:16 <mniip> supercynic, I grew up in the x86 era
19:45:24 <mniip> it was too late
19:45:43 <captainahab> I guess you start with an open parenthese and you count the number of open parenthese and closed parentheses until you get back to that top level. 
19:46:11 <erisco> captainahab, what I do not understand is why three parentheses are missing from the output. How do you explain that?
19:46:27 <mniip> captainahab, I'm not sure I understand the algorithm
19:47:08 <supercynic> mniip: nah, 16-bit consoles were still around when i got my first x86
19:47:29 <supercynic> MarcelineVQ: nope
19:48:25 <elomatreb> Hi - How much is it frowned upon to ask a trivial homework question? I'm asked to implement a function, and I'm not quite understanding what they want for me. Normally I would go ask the instructor, but they canceled their visiting hours right before we have to turn it in
19:48:52 <erisco> elomatreb, ask the question and include the work you have done thus far
19:49:24 <supercynic> they were already on their way out, but not before making little ertes addicted to 16-bit platforming to funktional music =)
19:49:26 <mniip> captainahab, care to demonstrate your algorithm on this infinite class of cases
19:49:27 <mniip> > fix $ ([]:) . (>>= (<$> "()") . flip (:))
19:49:30 <lambdabot>  ["","(",")","((",")(","()","))","(((",")((","()(","))(","(()",")()","())",")...
19:50:06 <mniip> elomatreb, we're not going to do your homework for you but we will explain everything necessary
19:50:08 <captainahab> Oh I forgot to put them back in. My first attempt at the algorithm matched against the parentheses. So it would remove them http://lpaste.net/360245.
19:50:22 <elomatreb> Thank you, I will post in a second
19:50:32 <captainahab> But it didn't work because anyChar would match against the closing ')'
19:50:59 <mniip> supercynic, I've (almost) never had a console
19:51:36 <erisco> I don't know, I am going to guess parsec wants you to use a negated character class
19:51:41 <erisco> like  c /= ')'
19:52:12 <elomatreb> https://gist.github.com/elomatreb/e94b73325a5824ff05be75408e6e6e0d -- I included some comments detailing my confusion about the task
19:53:00 <erisco> elomatreb, walk me through how you arrived at your type for foldTree
19:54:14 <mniip> preliminary: what's  yourFoldTree id 0 (Node (Leaf 1) (Leaf 2))
19:54:51 <elomatreb> .. I think you just made me realize. My function argument would have to have two arguments, one for the current value and one for the accumulator, right?
19:55:13 <erisco> did your instructor teach you about folds?
19:55:38 <erisco> if so, what examples were you shown?
19:56:33 <mniip> there's no "accumulator argument" per se
19:56:46 <mniip> it's just that foldr for lists looks like that
19:56:59 <mniip> because a for-loop with accumulator is just so much similar to folding a list
19:57:00 <supercynic> elomatreb: in general folds aren't about accumulation, but about recursive transformation
19:57:10 <elomatreb> I'm noticing I have some misunderstandings looking at the reference material, I'll go through it again, maybe it clears that up. Sorry for asking without checking first
19:57:25 <erisco> no problem, let us know what you find
19:58:23 <mniip> supercynic, I thought it's more of an induction/elimination thing
19:59:22 <supercynic> it is
19:59:36 <mniip> not a transformation per se
19:59:40 <mniip> just a dismantling
19:59:55 <erisco> it is a remantling
20:00:04 <mniip> dismantling, case analysis, destruction, construction of a function taking strucutre as argument
20:00:18 <supercynic> or…  in general…  a transformation
20:00:42 <mniip> in my mind a transformation is, first of all, an endomorphism
20:01:22 <mniip> and a transformation in general is both an elimination and a construction
20:01:28 <erisco> maybe it is a metamorphosis then ;)
20:01:30 <supercynic> "transformation" is overloaded enough that i think of it as "function"
20:01:41 <mniip> metaterminology
20:02:01 <mniip> we've come full circle
20:02:09 <supercynic> elimination + construction + endo rather reminds me of hylomorphisms
20:03:22 <mniip> I imagine metamorphism instead
20:07:47 <mniip> hmm what does a good anamorphism look like in haskell
20:08:19 <erisco> I have never used one even one time
20:08:27 <erisco> am I missing out?
20:08:45 <MarcelineVQ> you've never used unfoldr?
20:08:55 <mniip> (forall r. b -> r -> (a -> b -> r) -> r) -> b -> [a]
20:08:56 <erisco> nope
20:09:05 <MarcelineVQ> but it's so fun :O
20:09:09 <EvanR> ah the smell of haskell in the morning... totally refactored this thing and it still runs and behaves exactly as before haha
20:09:12 <EvanR> first time
20:09:23 <erisco> that is what it wants you to think
20:09:33 <mniip> EvanR, I've mastered the skill of pointfreeing by hand, I usually get it right first time
20:09:36 <erisco> but actually, there was a subtle partiality introduced that you won't find out until three months from now
20:09:41 <supercynic> mniip: unfoldr?
20:09:49 <mniip> supercynic, that doesn't scale
20:09:57 <supercynic> ah, you mean in general
20:09:58 <EvanR> there is tons of partiality 
20:10:23 <EvanR> a detailed argument for why none of it triggers kablooey is pending
20:10:45 <supercynic> mniip: ana :: (a -> F a) -> a -> Fix F  -- better?
20:10:52 <erisco> Z3 is still crunching the proof
20:10:53 <mniip> ehh
20:11:04 <EvanR> unfoldr is kind of crappy
20:11:07 <mniip> that requires a derecursed F functor
20:11:12 <mniip> what's the proper name
20:11:21 <supercynic> "base functor"?
20:11:48 <supercynic> untangled functor?
20:12:39 <mniip> hmm it's not a unique constructor, per a given inductive datum
20:12:58 <supercynic> actually, this is generic:  ana :: (Functor f) => (a -> f a) -> a -> Fix f
20:13:34 <supercynic> it should be the most generic Hask anamorphism combinator
20:14:09 <mniip> right
20:14:12 <mniip> but that doesn't
20:14:17 <mniip> ugh
20:15:10 <mniip> the "universal catamorphism schema" doesn't involve any products or coproducts - just the exponentials
20:15:58 <mniip> hmm
20:16:05 <mniip> are coexponentials a thing
20:17:22 <mniip> in a category with finite coproducts, coeval :: A -> (A <- B) + B
20:18:17 <mniip> that would be the dual statement innit
20:19:09 <mniip> ok, more formally
20:20:22 <mniip> C is coexponential A<-B iff exists coeval :: A -> C + B, and for any other C', exists unique m :: C -> C', s.t coeval factors through coeval'
20:20:57 <supercynic> are you trying to generalise anamorphisms?  because i'm not sure how expoentials are even relevant
20:21:11 <mniip> 1511583286 [07:14:46] <mniip> the "universal catamorphism schema" doesn't involve any products or coproducts - just the exponentials
20:21:39 <supercynic> is the "universal catamorphism schema" something other than just catamorphisms?
20:22:01 <mniip> I mean the foldr style catamorphisms
20:22:02 <mniip> not cata
20:24:51 <python476> gotta admit, when reaching http://learnyouahaskell.com/functors-applicative-functors-and-monoids
20:24:59 <python476> your brain start to feel nice tickles
20:25:15 <supercynic> mniip: let ([a] ≃ Fix (ListF a)), then listCata :: (ListF a r -> r) -> [a] -> r  -- the only exponentials i see are rather trivial and only superficially relevant to how listCata works
20:25:19 <python476> revives my combinator fetish also
20:26:22 * hackage aivika-experiment 5.3 - Simulation experiments for the Aivika library  https://hackage.haskell.org/package/aivika-experiment-5.3 (DavidSorokin)
20:26:31 <Welkin> python476: was it the pirate referencese?
20:27:10 <mniip> supercynic, what part of "not cata" did you not understand
20:27:40 * hackage aivika-experiment-chart 5.3 - Simulation experiments with charting for the Aivika library  https://hackage.haskell.org/package/aivika-experiment-chart-5.3 (DavidSorokin)
20:28:14 <supercynic> mniip: are "foldr style catamorphisms" something other than catamorphisms constructed by foldr/listCata?
20:28:32 <mniip> :t foldr
20:28:33 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
20:29:24 <supercynic> mniip: or maybe i should just ask what your issue with unfoldr is
20:29:43 <mniip> if you have
20:30:12 <mniip> data R = C1 D11 D12 ... R | C2 D21 .. R | ... 
20:30:22 <mniip> then you make up a catamorphism:
20:30:44 <mniip> (D11 -> D12 -> ... b -> b) -> (D21 -> ... b -> b) -> R -> b
20:30:56 <mniip> using no products or coproducts
20:31:19 <python476> Welkin: no just the tiny amount of typesystem over good old functions to generate combination without names
20:31:32 <mniip> unfoldr uses an auxiliary functor
20:31:48 <mniip> which cannot be expanded without introducing more auxiliary products and coproducts
20:32:28 <hlp> question for stack users out there, does extra-lib-dirs work for you?
20:32:38 <python476> thinking that last week I thought I'd look for a python or a Java job.. and now I'm considering learning DT ..
20:32:46 <python476> damn you haskell
20:32:50 <hlp> DT?
20:33:00 <mniip> dependent typing?
20:33:01 <hlp> on OSX, stack can't seem to find dylib files within extra-lib-dirs
20:33:29 <hlp> unless I also export DYLD_LIBRARY_PATH
20:33:38 <supercynic> mniip: so you're thinking that situation could be fixed by a notion of "coexponentials"?
20:33:51 <mniip> nah I'm just thinking out loud
20:33:54 <hlp> python476 - not sure if my previous message went through, but haskellbook.com is much better than LYAH
20:34:26 <python476> hip: you're totally right
20:34:28 <supercynic> mniip: but your issue (if it can be called that) is the Maybe and the (,), if i understand you correctly
20:34:35 <mniip> yes
20:34:36 <python476> your last message didn't go throuhg :)
20:34:58 <supercynic> mniip: well, at least for [] i see no way to change that
20:35:03 <mniip> you really represented ListF with Maybe + (,)
20:35:31 <hlp> python476 well then, i highly recommend it. LYAH is a bit gimmicky, a lot of learners are initially impressed but then get stuck when they try to work on a real project
20:35:32 <python476> i've read dozens of similar opinions, and have delayed reading LYAH, especially since haskellbook is out but for a reason last night I started reading LYAH and couldnt stop
20:36:21 <hlp> the problem is you see a lot of material but don't really learn how to use it. 
20:36:26 <python476> hlp: lyah gave me just enough typing to make me feel I'm actually programming in haskell (rather than toying with some online ghci repl)
20:36:36 <python476> hlp: I can see that
20:36:42 <python476> I'll follow with HB
20:36:53 <hlp> well as long as you don't stop there, yeah HB is great
20:37:01 <python476> or maybe I'll take a tiny holiday trip in minikanren land
20:37:06 <hlp> as an in-between, maybe check out http://www.happylearnhaskelltutorial.com/contents.html which seems like a better LYAH
20:37:17 <python476> hah; never saw this one
20:38:00 <hlp> it doesn't come up as high on google searches, i haven't gone through all of it, but it looks more promising than LYAH
20:38:12 <supercynic> mniip: well, one way would be to destructure the state type…  if you know how it's composed, you could at least get rid of the sum
20:38:23 <python476> well thanks
20:38:39 <hlp> have fun, are you coming recently from python?
20:38:42 <python476> any particular article or paper regarding haskell you enjoyed more than the rest ?
20:38:53 <supercynic> unfoldr :: (1 + a*s)^s -> s -> [a]
20:38:57 <supercynic> now if s = 2…
20:39:03 <mniip> hmm
20:39:09 <hlp> python476 how long have you been learning? i wouldn't read papers if you're just starting quite yet
20:39:25 <python476> hlp: god I should change my nick, it's a webchat coincidence (I had to register to talk to some python chan and now I use it all the time)
20:39:40 <mniip> we could take (forall r. b -> r -> (a -> b -> r) -> r) -> b -> [a]
20:39:45 <mniip> and lower its rank with r~[a]
20:39:50 <supercynic> unfoldr :: 1 + 4*a + a² -> 2 -> [a]
20:39:53 <python476> I've been dabbling in FP for years and took moocs about sml and also the haskell one by Meijer (2/3 finished though)
20:40:30 <supercynic> mniip: yeah, that might work, too
20:40:37 <mniip> (b -> [a] -> (a -> b -> [a]) -> [a]) -> b -> [a]
20:40:40 <supercynic> mniip: but then you could just as well represent lists using an initial encoding
20:41:42 <supercynic> newtype List a = List { foldList :: forall r. (a -> r -> r) -> r -> r }
20:42:08 <mniip> :t fix (\u f x -> f x [] (\e x -> e : u f x))
20:42:09 <lambdabot> (t -> [a1] -> (a2 -> t -> [a2]) -> [a2]) -> t -> [a2]
20:43:02 <hlp> python476 i see. i've also dabbled for a while, finally tackling some real projects after much dabbling.
20:43:10 <python476> cool
20:43:16 <hlp> rather, _a_ real project.
20:43:21 <mniip> > fix (\u f x -> f x [] (\e x -> e : u f x)) (\n z c -> c n (n + 1)) 0
20:43:23 <lambdabot>  [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
20:43:26 <python476> each one has his own twistey little path
20:43:41 <hlp> which is unfortunate really, haskell neads a much better onboarding story
20:43:46 <python476> hlp: personal side project or job related ?
20:44:07 <python476> hlp: honestly I dont think its gonna get better until a decade or two
20:44:16 <hlp> personal project, but could be used productively
20:44:16 <python476> it's too ahead conceptually
20:44:40 <python476> think how the world regarded lambdas/closures in the 70s
20:44:42 <hlp> two decades and i'll be approaching retirement, or at least wasting away in middle management.
20:44:57 <python476> nowadays everybody use and enjoy them, but even 10 years ago it was dark voodoo
20:44:59 <mniip> supercynic, ok so
20:45:16 <hlp> it doesn't have to be though, I think a lot of the impediments are self inflicted handicaps by the community and culture.
20:45:26 <python476> mostly 
20:45:31 <mniip> ((D11 -> D12 -> .. -> b -> R) -> (D21 -> .. -> b -> R) -> .. -> b -> b) -> b -> R
20:45:46 <mniip> now
20:45:47 <python476> starts with sequential register machines as first and main interaction with computer
20:45:49 <hlp> look at eta for example, a little work into a nice website and they had literally thousands of people signing up in days.
20:45:56 <mniip> can you incorporate polymorphic recursion into this
20:46:20 <python476> oh I forgot eta
20:46:29 <python476> haskell's clojure in a way
20:46:48 <EvanR> hlp: culture as in... avoid "success at any cost" ? :)
20:46:54 <hlp> i don't use it, but it's a good lesson that the haskell community hasn't learned yet
20:47:20 <EvanR> (fancy looking website + web framework + hotheaded celeb spokesperson)
20:47:27 <python476> EvanR: maybe strong but I'd be avoiding "success" too
20:47:29 <hlp> EvanR no not that, as in, adoption/user hostile
20:47:39 <EvanR> really?
20:47:41 <python476> mainstream spoils everything -- me
20:48:04 <EvanR> ime the adopting/new users are hostile
20:48:05 <supercynic> mniip: i haven't completely thought this through, but i think you're reinventing initial encodings
20:48:06 <hlp> i get eta is a bit controversial, but there are lessons 
20:48:22 <hlp> to be learned from the onboarding experience they provided
20:48:24 <mniip> @let data F f a = P a | F (F f (f a))
20:48:25 <lambdabot>  Defined.
20:48:31 <python476> EvanR: nobody is, it's just culture shock
20:48:57 <EvanR> years ago it was like... anybody who was learning haskell was only there because they actually wanted to
20:49:04 <python476> just like trying to put mechanics and abstract algebrist at the same table
20:49:06 <EvanR> i am not sure you need to "onboard" other people
20:49:08 <supercynic> mniip: with my initially encoded list type above:  List :: (forall r. (a -> r -> r) -> r -> r) -> List a
20:49:16 <hlp> EvanR my point exactly
20:49:16 <supercynic> mniip: List is an unfold combinator for List
20:49:18 <mniip> yeah I know that
20:49:25 <mniip> but
20:49:27 <mniip> higher rank
20:49:48 <supercynic> mniip: i can't think of a way to get rid of that without turning it into an existential
20:50:05 <EvanR> any sort of evangelical program to convert others seems doomed to failure to me, and i am not sure why youd want to
20:50:23 <EvanR> i would be afraid of the backlash
20:50:28 <hlp> there's a difference between evangelical and welcoming.
20:50:31 <hlp> but maybe ask "why not?" i personally think the world would be better if more people were using it for regular business work.
20:50:46 <hlp> but i get it, your sentiment is pretty much the norm
20:50:53 <hlp> which was my original point.
20:50:54 <EvanR> or maybe there will be more resistance to breaking changes?
20:51:06 <python476> hlp: i tend to side against these
20:51:15 <python476> let motivated people overcome "hurdles"
20:51:18 <EvanR> personally, if people were ok with haskell at work i think it would work fine
20:51:26 <hlp> that's fine most people in the Haskell community do
20:51:26 <EvanR> now that stack exists to keep versions straight
20:51:47 <hlp> which is why though, I say Haskell adoption doesn't have to be decades away, but we make it so.
20:51:56 <supercynic> we already have an acme-php package…  i'd rather not see a serious php package for haskell =)
20:52:01 <mniip> @let cataF :: (forall a. a -> h a) -> (forall b. h (f b) -> h b) -> F f a -> h a; cataF z c (P x) = z x; cataF z c (F x) = c (cataF z c x)
20:52:03 <lambdabot>  Defined.
20:52:08 <EvanR> serious-php package
20:52:21 <EvanR> laravel-compat
20:52:46 <python476> let's program all in hs https://github.com/rahulmutt/codec-jvm/blob/master/example/Main.hs
20:53:16 <EvanR> hey i screwed around with java-bridge for a second
20:53:17 <EvanR> it worked
20:54:45 <supercynic> you know what happens to successful languages…  just imagine there were a company developing a commercial build tool to compete with cabal-install that does things completely differently and fragments the community, and…
20:55:20 <python476> you dont even need a company for that
20:55:32 <EvanR> anyone know why i cant use a type family of kind K -> * in a position of kind (K -> *) (it says one more argument required), but if i wrap a newtype around the family... to get a newtype of kind K -> *, the newtype will work?
20:56:05 <EvanR> seems inconsistent
20:56:10 <hlp> you know it's possible that maybe with smart people a language wouldn't have to screw things up just because people used it.
20:56:17 <EvanR> and the error message unhelpful
20:56:23 <supercynic> python476: that was an in joke
20:56:55 <EvanR> oh yeah, supercynic is referring to slack
20:56:55 <supercynic> EvanR: type families are essentially type synonyms, so the same restrictions apply
20:57:01 <python476> I need way too much sleep to click at these  Iguess
20:57:14 <EvanR> supercynic: the type family name itself is a synonym?
20:57:20 <EvanR> oh right
20:57:21 <EvanR> ok
20:57:33 <EvanR> s/slack/stack/
20:57:37 <supercynic> EvanR: basically…  for example you can't define instances on partially applied type synonyms either
20:57:55 <hlp> there are things worse than fragmentation..
20:57:55 <EvanR> yet a newtype does work
20:58:14 <supercynic> EvanR: if you could, you would have type-level general recursion
20:58:26 <EvanR> sounds fun!
20:58:47 <EvanR> game of life in the type checker
20:58:50 <supercynic> err
20:58:59 <supercynic> s/synonyms/families/
20:59:35 <supercynic> @let type family F a where F a = F a
20:59:39 <lambdabot>  .L.hs:171:1: error:
20:59:41 <lambdabot>      Multiple declarations of ‘F’
20:59:43 <lambdabot>      Declared at: .L.hs:160:1
20:59:48 <supercynic> huh?
21:00:01 <EvanR> :k F
21:00:05 <lambdabot> (* -> *) -> * -> *
21:00:06 <supercynic> @let type family F a where F a = a
21:00:11 <lambdabot>  .L.hs:171:1: error:
21:00:15 <lambdabot>      Multiple declarations of ‘F’
21:00:17 <lambdabot>      Declared at: .L.hs:160:1
21:00:21 <EvanR> F exists
21:00:23 <supercynic> oh, d'oh
21:00:35 <supercynic> @let type family Blah a where Blah a = Blah a
21:00:37 <lambdabot>  Defined.
21:00:40 <supercynic> huh?!
21:00:44 <EvanR> rofl
21:00:59 <EvanR> :k Blah Char
21:01:01 <lambdabot> k
21:01:01 <supercynic> > undefined :: Blah ()
21:01:03 <lambdabot>  error:
21:01:03 <lambdabot>      • Reduction stack overflow; size = 201
21:01:03 <lambdabot>        When simplifying the following type: Blah ()
21:01:21 <EvanR> i guess we have type level general recursion after all
21:01:28 <supercynic> @let type family Blubb a; type instance Blubb a = Blubb a
21:01:29 <lambdabot>  Defined.
21:01:40 <supercynic> @let type Foo a = Foo a
21:01:41 <lambdabot>  .L.hs:179:1: error:
21:01:41 <lambdabot>      Cycle in type synonym declarations:
21:01:41 <lambdabot>        .L.hs:179:1-18: type Foo a = Foo a
21:01:55 <supercynic> is that a bug?
21:01:59 <EvanR> or a feature
21:02:06 <supercynic> neither would surprise me
21:02:27 <EvanR> maybe undecidable instances or some such is enabled
21:02:33 <supercynic> yeah, probably
21:02:45 <supercynic> it's an undecidable type *instance* after all
21:05:36 * supercynic ertes
21:05:40 <supercynic> err
21:05:47 * ertes powers down
21:06:50 <mniip> ertes, I did it I think
21:06:56 <mniip> :t cataF
21:06:58 <lambdabot> (forall a1. a1 -> h a1) -> (forall b. h (f b) -> h b) -> F f a -> h a
21:07:00 <mniip> :t anaF
21:07:02 <lambdabot> (forall b. (b -> F f b) -> (h (f b) -> F f b) -> h b -> F f b) -> h a -> F f a
21:07:10 <mniip> > anaF (\p f (n, x) -> if n > 5 then p x else f (n + 1, Just x)) (0, 'x')
21:07:13 <lambdabot>  F (F (F (F (F (F (P Just (Just (Just (Just (Just (Just 'x')))))))))))
21:07:42 <mniip> (writing out the show instance was quite fascinating)
21:14:23 <EvanR> singletons is so wacky...
21:15:37 <EvanR> you got your values promoted to types... and your gadt wrapper for values whose type is that value... or type... or datakind or something
21:15:53 <EvanR> so the value represents the promoted types... which are values anyway
21:16:12 <mniip> it's obvious
21:16:15 <EvanR> lol
21:16:42 <lyxia> a poor man's dependent types
21:17:00 <cameltoeFV129> alright, what the fuck
21:17:39 <cameltoeFV129> not here for the language. hate haskell in fact. but that's just me. but i need to discuss something with everyone here
21:17:53 <cameltoeFV129> FUCKING AJIT PAI
21:17:58 <cameltoeFV129> AAAAAA
21:18:19 <mniip> uh sorry but that's nothing to do with haskell
21:18:50 <cameltoeFV129> alright, but when he fucking ends the internet with his pajeet skills, how are you people going to congregate ehre again
21:18:52 <cameltoeFV129> here*
21:19:10 --- mode: ChanServ set +o geekosaur
21:19:18 <mniip> not everyone here is from the US
21:19:20 <mniip> ;)
21:19:23 --- mode: geekosaur set +b *!*18f6b375@gateway/web/freenode/ip.24.246.179.117
21:19:23 --- kick: cameltoeFV129 was kicked by geekosaur (cameltoeFV129)
21:19:46 <EvanR> comments closed
21:20:39 <mniip> back to singletons
21:21:29 <EvanR> so if i want to use (r ->) as a * -> *
21:21:56 <EvanR> ok this is not a synonym so it should be allowed
21:22:08 <mniip> spelled as ((->) r) sure
21:22:12 <EvanR> oh
21:22:18 --- mode: geekosaur set -o geekosaur
21:23:17 <EvanR> and a synonym that is fully applied that expandsd to that... should be allowed
21:23:23 <EvanR> to make it more readable
21:24:24 <mniip> yes
21:38:46 <elomatreb> erisco, mniip: Thank you for your help earlier, I did manage to figure it out
21:47:11 <mniip> ooh
21:47:14 <mniip> “every fully faithful and essentially surjective functor is an equivalence of categories” is equivalent to the axiom of choice.
21:48:41 <monochrom> Oh, that reminds me of https://en.wikipedia.org/wiki/Schr%C3%B6der%E2%80%93Bernstein_theorem
21:50:36 <mniip> monochrom, if 5*A ~ 5*B, then is A ~ B?
21:55:18 <EvanR> 5*A = A + A + A + A + A ? :)
21:56:08 <mniip> can you prove that?
21:56:17 <mniip> without aoc and lem
21:56:27 <mniip> well, I suppose you can
21:56:33 <mniip> for a finite 5
21:56:51 <mniip> ok, suppose you've proven that,
21:56:52 <EvanR> for very large values of 5
21:56:57 <mniip> what next?
21:57:15 <EvanR> i dont even know what * ~ and + are right now
21:57:32 <EvanR> type product, sum, equality?
22:01:05 <mniip> cartesian product of sets, existence of bijection, disjoint union
22:04:51 <EvanR> oh
22:06:13 <mniip> EvanR, I've seen a fully constructive proof of 3*A ~ 3*B => A ~ B, and it wasn't nice
22:06:53 <EvanR> i am not sure what principles you can even get started with, constructively, with sets
22:07:02 <EvanR> without knowledge of A or B
22:07:19 <mniip> ZFC
22:08:41 <EvanR> that doesnt compute
22:09:32 <Lowl3v3l> EvanR: Zermelo Fraenkel-axioms with the axiom of choice
22:10:31 <mniip> err
22:10:33 <EvanR> haha
22:10:38 <mniip> sorry I typed the C by reflex
22:10:41 <mniip> ZF of course
22:11:02 <EvanR> still how does that give you any ability to generate any function out of A or B
22:11:21 <EvanR> some function
22:12:17 <EvanR> ah well you start with 2.. because of the ~
23:18:01 <mpiechotka> Hi. I have problem using ConstraintKinds - compiler chokes on type family Invariant v v' :: Constraint claiming that "Not in scope: type constructor or class ‘Constraint’". It's probably some silly mistake but I cannot find it (GHC 8.0.2).
23:19:39 <mniip> % :info Constraint
23:19:39 <yahb> mniip: ; <interactive>:1:1: error: Not in scope: `Constraint'
23:19:54 <mniip> Data.Kind or something
23:20:03 <mniip> hmm
23:20:09 <mpiechotka> mniip: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#the-constraint-kind
23:20:50 <mniip> % :info Data.Kind.Constraint
23:20:51 <yahb> mniip: data Constraint -- Defined in `GHC.Types'
23:20:57 <mpiechotka> Oh sorry
23:21:08 <mniip> still have to import it
23:21:31 <mpiechotka> I think this is a tidbit which should be mentioned in documentation ;)
23:22:05 <mniip> I guess it's expected you'll figure it out on your own
23:22:41 <mniip> oh er
23:22:45 <mniip> "Anything whose form is not yet known, but the user has declared to have kind Constraint (for which they need to import it from GHC.Exts)"
23:34:52 <mpiechotka> My bad
23:56:50 <ViNnI> Всем привет
23:57:00 <ViNnI> мирк жив
23:58:25 <xormor> ViNnI, "privjet"?
23:58:39 <xormor> ViNnI, "Bsem"?
23:58:54 <xormor> ViNnI, "mirk gib"?
23:59:33 <mniip> ViNnI, жив. Что-нибудь имеющее отношение к Хаскелю интересует?
