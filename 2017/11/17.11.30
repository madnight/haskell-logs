00:13:37 <osa1> ugh years of Haskell and "can't match X with Y" type errors are still not helpful for me because it's not clear which one is expected and which one is found.
00:17:56 <dminuoso> Speaking of diagnostics, what exactly is a rigid type variable?
00:18:02 <rightfold> There is no such thing as expected
00:18:19 <dminuoso> https://gist.github.com/dminuoso/5acc0fd83d6ba3469f67a732412210a0 we can use this as a basis for discussion
00:19:21 <dminuoso> Does rigid imply that I provided a type annotation (making it rigid) ?
00:19:40 <rightfold> dminuoso: also known as a Skolem, it’s a type variable inside the definition of a polymorphic binding
00:20:11 <rightfold> Since the choice of the actual type is up to the *caller*, the caller must treat it as completely opaque, hence “rigid”
00:20:23 <rightfold> Second caller should be callee
00:21:29 <rightfold> So, in your example, you’re trying to return a String, but the caller may decide it wants an Int
00:22:05 <dminuoso> rightfold: In my case there's no caller/callee though
00:22:16 <rightfold> How can test know?
00:22:26 <dminuoso> Huh?
00:22:40 <rightfold> How can your function “test” know that there won’t be any callers?
00:23:02 <rightfold> It can’t, so it has to be prepared to be called with any possible type for “a”
00:23:16 <rightfold> Which may be any type with a Show instance, such as Int
00:23:37 <rightfold> What would you want to happen if the next GHCi command were “test + 1”?
00:23:53 <dminuoso> rightfold: It expect an error that test was not in scope.
00:24:12 <rightfold> Assuming your definition of test did type check
00:24:45 <dminuoso> Is this discussion sound? I mean if we assume the type system to be nonsensical then ex falso quodlibet
00:24:49 <rightfold> Whatever
00:31:28 <dminuoso> rightfold: No seriously, how can I answer your question?
00:31:56 <dminuoso> (Im not saying that your question is wrong, I just can't follow this thought process)
00:34:53 <dminuoso> Either `test` has a polymorphic type s, or a monotype [Char]. If we presume the definition of test to type check, one of these has to be false.
00:35:07 <dminuoso> *One of these has to be false.
00:38:52 * hackage ghc-typelits-presburger 0.1.1.1 - Presburger Arithmetic Solver for GHC Type-level natural numbers.  https://hackage.haskell.org/package/ghc-typelits-presburger-0.1.1.1 (HiromiIshii)
00:40:46 * hackage type-natural 0.7.1.4 - Type-level natural and proofs of their properties.  https://hackage.haskell.org/package/type-natural-0.7.1.4 (HiromiIshii)
01:01:31 <milesrout> the zippers library by edwardk thoroughly confuses me
01:01:57 <milesrout> it seems to be built upon the notion that you are basically encoding where you are in your data structure in the types?
01:02:00 <merijn> milesrout: Most libraries by edwardk thoroughly confuse me :p
01:02:22 <merijn> milesrout: Yes, that's what zippers are
01:03:16 <milesrout> but then, what if you want to: do { goals %= upward } or however you spell it in lens
01:03:28 <milesrout> you have a zipper into a tree, in your state, and you want to move around in it
01:03:32 <milesrout> or am I doing it completely wrong
01:04:28 <merijn> milesrout: I don't really understand what the question is?
01:04:50 <milesrout> fair enough sorry, I have explained poorly. let me try again
01:05:33 <milesrout> I have a data structure that contains a tree amongst other things. I am interpreting some commands in the RWS monad with this data structure as my State
01:06:00 <milesrout> I want to maintain a 'focus' in this data structure, of where I am in this tree
01:06:14 <milesrout> I assumed that zippers were a reasonable way of doing this, but I might be wrong
01:06:47 <merijn> milesrout: It depends why you're trying to "focus" the tree?
01:07:16 <milesrout> certain commands operate on the 'current node'
01:07:50 <milesrout> they might modify the current node, create a new subnode to that node, then move the 'current node' pointer to the new child
01:09:16 <milesrout> I know I could just have a treeIndex :: [Int] in my state, but then every operation on the current node would need to traverse the tree and it can get quite large.
01:11:22 <merijn> ok, that makes sense, although I'm not seeing where the problem is?
01:12:13 <milesrout> well the type of a zipper focused on the root note is different to the type of a zipper focused on another node, for example
01:12:28 <milesrout> at least I think it is
01:12:42 <milesrout> if I use https://hackage.haskell.org/package/zippers
01:13:26 <merijn> ah, so the type of the zipper changes
01:13:43 <milesrout> I think so yeah
01:14:04 <sbrg> milesrout: FWIW, writing a zipper for this from scratch is pretty simple, and also a good exercise. maybe it's preferable to trying to use a complicated library?
01:14:09 <merijn> Yeah, that probably doesn't play nice with State
01:14:19 <merijn> sbrg++
01:14:51 <milesrout> sbrg: good point.
01:14:55 <milesrout> I might give that a go.
01:15:23 <sbrg> https://wiki.haskell.org/Zipper is a decent article on it
01:16:00 <sbrg> and for the record, zippers sound like exactly what you need. 
01:16:47 <milesrout> cheers
01:16:52 <milesrout> I'll have a look at that
01:16:59 <milesrout> might have a go first though
01:21:12 <ertes-w> milesrout: so you never actually go "up" toward the root node?
01:21:36 <ertes-w> err
01:21:37 <ertes-w> helo
01:26:24 <milesrout> ertes-w: what do you mean?
01:26:35 <milesrout> ertes-w: I might do, there are potentially commands that could do so
01:27:52 <ertes-w> ok
01:28:05 <milesrout> it's a tree of goals to be proved. for context.
01:28:56 <ertes-w> milesrout: oh?  you're writing a proof assistant?
01:29:07 <milesrout> yep
01:29:23 <ertes-w> milesrout: for which foundation?  HOL?
01:30:36 <milesrout> intuitionistic first order logic, approximately.
01:31:00 <milesrout> at least, for now.
01:31:06 <milesrout> it's purely for fun
01:31:10 <milesrout> at least, for now. :)
01:31:54 <ertes-w> nice =)
01:32:35 <ertes-w> i'm still hopeful that proof assistants don't have to suck
01:33:56 <milesrout> ha :)
01:40:00 <hololeap> :t op
01:40:00 <lambdabot> Wrapped s => (Unwrapped s -> s) -> s -> Unwrapped s
01:49:58 <mniip> hmm
01:51:03 <mniip> is the cofree comonad construction the left adjoint of the forgetful comonad->functor functor?
01:51:29 <mniip> or is its duality to free monad of a different kind?
01:53:16 <olligobber> well, calling bash nc won't work, I need the IP address of the sender....
01:58:37 <dminuoso> So here's a question. If I dont flush, stdout can get sequenced after stdin?
02:02:31 <dminuoso> Or I guess what my actual question is..
02:02:37 <dminuoso> Why do I see stdin?
02:02:58 <merijn> dminuoso: What do you mean "see stdin"?
02:03:14 <dminuoso> I mean what mechanism is causing the echoing of stdin for some `getLine`. Is that my terminal?
02:03:26 <dminuoso> Is it the shell? It it haskell?
02:03:32 <merijn> dminuoso: That's your terminal
02:03:54 <merijn> dminuoso: If you wanna know the details, I'd recommend grabbing a copy of "Advanced Programming in the Unix Environment" which a lot more people should read
02:05:13 <dminuoso> merijn: Looks like a good read, will check with the book store when I get back home.
02:05:45 <dminuoso> merijn: Im guessing that stdin echo mechanism does not feed back into stdout?
02:06:00 <dminuoso> Based on my observation it would seem so (since pressing enter does definitely not flush)
02:06:17 <merijn> dminuoso: This all has to do with the active terminal discipline
02:06:26 <infinisil> Is there a better way to write this? case maybeIO of   Nothing -> return ()   Just io -> io
02:06:31 <merijn> raw, cooked, or that weird 3rd one I remember
02:06:46 <dminuoso> Guessing that would be covered in the book?
02:06:59 <merijn> infinisil: "fromMaybe (return ())"?
02:07:22 <mniip> merijn, raw and cooked would actually be a set of options no?
02:07:28 <paolinoGlA> hi, how can I test the output (stdout)  of an IO action ?
02:07:48 <mniip>        cooked same  as  brkint ignpar istrip icrnl ixon opost isig icanon
02:07:50 <merijn> dminuoso: Yeah. Basically, you terminal can do preprocessing before feeding input to your application (allowing for line-editing) and only send full lines
02:07:51 <mniip>        -cooked              same as raw
02:07:53 <infinisil> merijn: Oh nice, thanks
02:08:09 <merijn> paolinoGlA: I have an incredibly hacky solution for that
02:08:13 <merijn> paolinoGlA: Lemme find the code
02:08:29 <mniip>       raw    same as -ignbrk -brkint -ignpar -parmrk -inpck -istrip -inlcr -igncr -icrnl -ixon -ixoff -icanon -opost -isig -iuclc -ixany -imaxbel -xcase min 1 time 0
02:08:36 <dminuoso> merijn: Right. And in that mode the "echo'd" characters, including the newline, seem to be magically displayed without stdout.
02:08:50 <paolinoGlA> merijn: for some reason HUnit seems not tested
02:09:10 <dminuoso> Ill pick up the book then, thank you for the suggestion.
02:09:13 <mniip> dminuoso, that behavior happens in the kernel at the pseudoterminal driver
02:09:26 <paolinoGlA> I went straight to copy paste from there 
02:09:31 <mniip> dminuoso, not at your program, which, by the way, only has references to the slave file descriptors of the pty
02:11:24 <merijn> paolinoGlA: https://github.com/merijn/paramtree/blob/master/tests/Test.hs
02:11:54 <merijn> paolinoGlA: See withCapturedIO there
02:12:05 <dminuoso> mniip: By "your program" do you mean my terminal emulator?
02:12:07 <merijn> I've been thinking whether I should wrap that up as a separate library on hackage
02:12:21 <mniip> dminuoso, no I meant your program where you reference stdin/out
02:12:24 <paolinoGlA> yep, please do that :-) Thanks
02:12:27 <mniip> those are just file descriptors
02:12:49 <mniip> they are probably bound to the pty slave file descriptors
02:13:34 <paolinoGlA> merijn ++
02:13:36 <mniip> your terminal emulator is the one who holds the master file descriptor
02:13:56 <merijn> paolinoGlA: Just seems like it'd be such a small thing to create a library for
02:14:27 <mniip> however all your terminal emulator does is display read characters on screen and write typed characters and sometimes react to ANSI escape codes
02:14:43 <mniip> the echoing/ctrlc/linebuffering happens inbetween
02:14:43 <paolinoGlA> merijn  half a day of hacking saved to anyone needing it
02:14:45 <mniip> in the kernel
02:15:02 <merijn> paolinoGlA: True, no time to wrap that up any time soon, though
02:16:32 <paolinoGlA> merijn: would you add a license header ? I will report it
02:17:54 <merijn> paolinoGlA: That entire package is BSD3 licensed, so that includes the test code
02:18:01 <paolinoGlA> ok
02:18:41 <cr1t1cal> is there a haskell binding for wayland?
02:21:56 <merijn> cr1t1cal: Maybe? You'd have to scan/search the hackage index
02:23:05 <alp> cr1t1cal, in general I just google (or another search engine) "hackage <thing I'm looking for>", works well. with wayland that points me to https://hackage.haskell.org/package/hayland
02:23:45 <merijn> alp: Probably more effective to just go to the package index: https://hackage.haskell.org/packages/
02:24:24 <cr1t1cal> the only one that I find is deprecated
02:25:10 <merijn> cr1t1cal: In that case you might have to write your own
02:28:16 <olligobber> hmm, can anyone reccommend a simple way of doing networking/sockets, maybe with a tutorial?
02:29:25 <cr1t1cal> merijn: lol so much work
02:29:48 <merijn> olligobber: I don't think there's really a high level library beyond "network" for networking
02:30:14 <merijn> olligobber: And network is a very direct wrapper around the socket API of C (and most other languages)
02:30:21 <olligobber> there's Network.Socket 
02:30:47 <merijn> olligobber: Yes, that's the one I mean
02:31:07 <olligobber> hmm, I haven't used any packages other than those that came pre-installed before, I'll ahve to look into how that works too
02:31:19 <merijn> olligobber: Depends on if you're using cabal or stack
02:31:30 <olligobber> I've used neither!
02:31:37 <merijn> olligobber: How'd you install GHC?
02:31:39 <olligobber> I saw something saying I could use apt-get
02:31:49 <merijn> That's...generally a terrible idea
02:32:03 <olligobber> oh, I have cabal installed
02:32:09 <merijn> Most linux package managers have a tendency to fuck up and break the haskell package infrastructure
02:32:20 <milesrout> use gentoo
02:32:38 <milesrout> (in all seriousness, I think you're meant to use stack)
02:32:50 <olligobber> I don't have stack installed, I do have cabal...
02:32:54 <merijn> olligobber: If you install the platform you should already have network installed, else you just do "cabal install network"
02:33:07 <olligobber> import network doesn't do anything
02:33:46 <merijn> You'd have to use "import Network.Socket" after installing the network package
02:34:03 <olligobber> so I should have it? weird that I don't
02:34:17 <merijn> olligobber: Whether you should have it depends on how you installed GHC
02:35:05 <olligobber> I might have selected a 'minimal' option somewhere
02:35:13 <olligobber> rather than getting a bigger SSD
02:35:37 <merijn> That's not really an answer to how you installed GHC, though...
02:35:44 <olligobber> cabal? apt-get?
02:37:08 <olligobber> I probably did "sudo apt-get install haskell-platform"
02:37:33 <merijn> haskell-platform should come with network already installed
02:43:57 <ertes-w> the Semigroup/Monoid situation has always been ugly, but this is the first time it actually prevents me from solving something nicely
02:44:33 <ertes-w> instance (Monoid a) => Monoid (Maybe a)  -- this
02:44:38 <ertes-w> instance (Semigroup a) => Monoid (Maybe a)  -- should be this
02:46:45 <hexagoxel> ertes-w: you'll have to look for .. different `Option`s :D
02:47:29 <tdammers> the SMP transition is definitely not elegant
02:48:13 <ertes-w> heh
02:54:55 <infinisil> Have been using Haskell for a few weeks now and I'm liking it more and more
02:55:40 <liste> infinisil: nice!
02:55:46 <infinisil> Really neat just now was how when I added a constructor to a datatype, the compiler complained on all the places i needed to change anything
02:56:13 <infinisil> and as soon as the compiler was happy, the program ran correctly :)
02:56:19 <merijn> infinisil: Refactoring in Haskell is so nice :)
02:57:05 <dminuoso> merijn: Since you seem to have a tendency to make good recommendations wrt books, any good resource to dive into Haskell to build "real programs" ?
02:57:29 <cocreature> dminuoso: don’t read a book, write programs :)
02:57:37 <infinisil> ^^^^^
02:57:39 <dminuoso> cocreature: So just trial and error?
02:57:48 <cocreature> books are useful for getting over the initial hurdle
02:58:01 <cocreature> but you can get stuck reading and reading without ever writing programs
02:58:10 <infinisil> I have rewritten my first haskell project like 4 times by now, I've learned a lot
02:58:13 <cocreature> so once you’ve picked up the basics, I’d recommend to just build something
02:58:37 <muzzle> cocreature, diminuoso: plus I find that a lot of concepts only become clear after you have developed a solid intuition, which you can only really do by applying them
03:00:42 <infinisil> I actually should probably read a book, I feel like my haskell is kinda non-idiomatic
03:01:51 <infinisil> Question: I have a Client datatype, and a ClientT typeclass, instance ClientT Client
03:02:32 <infinisil> But now I've got `f :: ClientT c => ...` all over the place, is this usual?
03:02:48 <ertes-w> -1/0 is guaranteed to be negative infinity, right?
03:02:59 <atodorov> hi folks, one of my CI slaves fails to build hscolour-1.24.3 (dependency of hlint), log here http://lpaste.net/360371. This is on Fedora 26 while the same is working on Ubuntu. Does anyone have idea what's wrong ?
03:03:06 <ertes-w> by IEEE-something
03:03:17 <infinisil> I guess I could put all the methods for ClassT into the typeclass itself, hmm
03:04:42 <hexagoxel> atodorov: have you seen https://matrix.hackage.haskell.org/package/hscolour ?
03:04:53 <hexagoxel> i think the 24.3 release is just borked.
03:04:59 <ertes-w> infinisil: what's the point of the ClientT class?
03:05:09 <hexagoxel> are you sure you use that version on ubuntu?
03:05:34 <infinisil> ertes-w: To make it possible to have different kinds of clients, e.g. a TCP one, or one for testing
03:06:18 <ertes-w> infinisil: then yes, it's usual
03:06:36 <ertes-w> infinisil: and no, you shouldn't move everything into the class
03:07:36 <infinisil> ertes-w: Oh, because these funs should be the same for all clients, but if i move it into the class, it could be overwritten
03:07:55 <infinisil> I think
03:09:20 <atodorov> hexagoxel: thanks for the tip. On another system where I was able to build hlint successfully cabal says: Default available version: 1.24.3 Installed versions: 1.24.1 so I guess on the failing system I don't have older versions available and cabal is trying to build the latest hscolour which fails
03:21:57 <aplainzetakind> What are the justificiations to newtype over type except overriding type class instances?
03:22:24 <liste> aplainzetakind: you can't mix types by accident if you use newtype
03:22:31 <sbrg> ^
03:23:05 <Taneb> It prevents things like adding two IDs together
03:23:26 <aplainzetakind> Alright.
03:23:57 <sbrg> There is no reason not to use it heavily since you can use GNTD to basically get everything you need for free
03:24:58 <sbrg> and then even add "specialized behavior" by writing custom instances for certain typeclasses. Like, say, a case insensitive string. just write an Eq instance that does case insensitive comparisons
03:25:41 <liste> and you even get to use string literals with OverloadedStrings!
03:26:52 <sbrg> yeah!
03:27:03 <sbrg> it's great
03:27:23 <paolinoGlA> Anyone nows how to strip ansi-escape-sequences from a String ?
03:28:24 <quchen> paolinoGlA: Don’t they all have the format \ESCxxxx;?
03:28:35 <quchen> Pardon, \ESC...m
03:29:28 <paolinoGlA> quchen not sure how they are encoded
03:29:57 <mniip> quchen, no
03:30:00 <sbrg> yep, pretty sure they look something like that, and then \]m or something to close? 
03:30:04 <mniip> \ESC[2A
03:30:14 <quchen> mniip: Eeeek, right, only the color ones end in m
03:30:18 <mniip> there's a wide variety
03:30:38 <quchen> »The ESC [ is followed by any number (including none) of "parameter bytes" in the range 0x30–0x3F (ASCII 0–9:;<=>?), then by any number of "intermediate bytes" in the range 0x20–0x2F (ASCII space and !"#$%&'()*+,-./), then finally by a single "final byte" in the range 0x40–0x7E (ASCII @A–Z[\]^_`a–z{|}~).«
03:30:51 <quchen> https://en.wikipedia.org/wiki/ANSI_escape_code#CSI_sequences
03:30:57 <mniip> I was thinking,
03:31:01 <mniip> of a library
03:31:19 <mniip> which could be called cocurses
03:31:44 <mniip> it would do the inverse of what curses does: read ansi speak and render the text onto a character matrix
03:32:32 <lavalike> I know "man fopen | col -b" does it, maybe you could look up what col does :D
03:32:54 <mniip> nope it doesn't
03:33:12 <mniip> lavalike, try man fopen | cat
03:33:24 <mniip> it's man that is acting here
03:33:33 <sbrg> it's just man that knows it's sending output somewhere else and doesn't include color etc
03:33:34 <lavalike> dang! it's figuring out the capabilities
03:33:36 <sbrg> yeah
03:33:38 <olligobber> so to deal with network stuff I'm using ByteStrings, and in code examples they call functions that take ByteStrings with normal looking strings like "This", why won't this work in my code?
03:33:44 <lavalike> I have been lied to
03:33:51 <sbrg> olligobber: OverloadedStrings
03:34:15 <sbrg> {-# LANGUAGE OverloadedStrings #-} at the top of your code
03:34:50 <liste> not sure if using the IsString instance of ByteString is a good idea
03:34:58 <lavalike> ah okay but it does *do* something, man fopen >foo vs man fopen | col -b >bar
03:37:17 <olligobber> sbrg, is there a similar thing for char / Word8 ?
03:37:40 <olligobber> liste, I'm using Data.ByteString?
03:38:21 <olligobber> oh, there are two people in here with string issues at the same time, nice
03:42:02 <cocreature> olligobber: note that this only works if your string literals are ASCII, otherwise the characters will be silently truncated
03:42:37 <olligobber> I thought so
03:49:18 <dminuoso> Mmm, why is ShowS not a typeclass?
03:49:28 <olligobber> thanks everyone <3
03:49:30 <mniip> why would it be
03:49:39 <mniip> % :info ShowS
03:49:45 <mniip> oh oops
03:51:10 <mniip> % :info ShowS
03:51:10 <yahb> mniip: type ShowS = String -> String -- Defined in `GHC.Show'
03:53:42 <liste> olligobber: yes, I was worried about what cocreature pointed out, using string literals with ByteString is dangerous
03:53:56 <olligobber> I'll be careful
03:55:00 <dminuoso> mniip: Well I was thinking that implementing Show for a recursive structure using ++ would be inefficient giving me O(n^2) complexity.
03:55:46 <Younder> performance = C like operations = monads = dangerous = C ;)
03:56:09 <Younder> let me guess no, no and no
03:58:02 * hackage LParse 0.2.2.2 - A continuation-based parser library  https://hackage.haskell.org/package/LParse-0.2.2.2 (Sacchan)
04:01:43 <aplainzetakind> x :: IO a; fs :: [(a -> IO a)].  Is there a shorthand for foldl (>>=) x fs?
04:03:39 <causamortis> Hi lads, does any of you know of an IRC channel in which to discuss software architecture on a more abstract level?
04:03:57 <causamortis> Something like software engineering on stackexchange but .. on IRC I guess ^^
04:09:32 <paolinoGlA> Seems like I can use regex to strip the ansi-escape-sequences. Any library from hackage which support deletion of matches ?
04:23:59 <Philonous> Is there a canonical way for naming lenses accessing fields of a record? I.e. I have an existing record named getTmpDir, is there a standard way of naming the lens for it?
04:24:08 <Philonous> record field*
04:25:38 <hpc> i think you would name the field something like _tmpDir and then the lens would be named tmpDir
04:25:58 <hpc> but i am hardly qualified to say how to write lens code ;)
04:26:41 <Philonous> OK, that's what I have seen in other projects, but I'm working on an established package, so I can't really change the record fields
04:27:10 <hpc> dunno then
04:27:23 <lyxia> some append "L" or "Lens" at the end
04:28:25 <mniip> dminuoso, that's what ShowS is for
04:28:42 <Philonous> Oh, that's what I've been doing. So I guess I'll just stick to that. Thanks!
04:28:44 <dminuoso> mniip: But doesn't ShowS just use my `show` implementation?
04:29:03 <dminuoso> Or does this mean its my job to not use [Char] with ++ there?
04:29:22 <dminuoso> s/ShowS/shows/
04:29:44 <ertes-w> infinisil: sometimes it's a good idea to have redundant class members, because individual instances can provide more efficient implementations…  for example technically (<*) in Applicative is redundant
04:30:31 <infinisil> R0b0t1`: I see
04:30:39 <ertes-w> infinisil: but for the most part a class should contain only primitives, and classes should be "reasonable" in quite a literal sense: 1. there is a reason the class exists, 2. it can be used for reasoning
04:30:51 <mniip> dminuoso, "use"?
04:31:07 <mniip> % :info Show
04:31:07 <yahb> mniip: class Show a where; showsPrec :: Int -> a -> ShowS; show :: a -> String; showList :: [a] -> ShowS; {-# MINIMAL showsPrec | show #-}; -- Defined in `GHC.Show'; instance Show Data.ByteString.ByteString -- Defined in `Data.ByteString.Internal'; instance Show Data.ByteString.Lazy.ByteString -- Defined in `Data.ByteString.Lazy.Internal'; instance Show a => Show (Data.Sequence.ViewR a) -- Defined in 
04:31:16 <mniip> see where it says MINIMAL showsPrec | show
04:31:25 <mniip> it means it suffices to implement one of these
04:31:27 <ertes-w> infinisil: a good reason for a class to exist is: there are at least two instances, and there is at least one value that abstracts over the class
04:31:31 <mniip> for the typeclass to be complete
04:31:43 <dminuoso> mniip: Ohhh! That's interesting. So if I implement it in terms of showsPrec, I can gain the lazyness I want?
04:32:31 <mniip> it's not laziness
04:32:32 <infinisil> ertes-w: Makes sense, will keep that in mind, thx!
04:32:36 <dminuoso> https://gist.github.com/dminuoso/271c0f587fea4ea6ec7c833177d5e358 this is what I had originally
04:32:45 <mniip> it doesn't become any more strict or non-strict
04:33:00 <ertes-w> infinisil: for example for Monoid there are two instances:  instance Monoid [a]; instance (Num a) => Monoid (Sum a)
04:33:08 <dminuoso> Ah, my bad. Using function composition rather than string concatentation I mean.
04:33:32 <ertes-w> infinisil: and there is at least one function that abstracts over Monoid:  fold :: (Foldable f, Monoid a) => f a -> a
04:34:46 <mniip> dminuoso, well it goes like this:
04:35:05 <infinisil> Oh and I just noticed this when doing :i Monoid, does {-# MINIMAL mempty, mappend #-} probably means that mempty and mappend is required to be implemented
04:35:13 <infinisil> s/does//
04:35:24 <infinisil> but mconcat isn't
04:35:29 <ertes-w> infinisil: yes
04:37:03 <ertes-w> infinisil: we tend to think of MINIMAL as a stronger concept in haskell:  the other members *follow from* those primitives
04:37:26 <ertes-w> you can implement your own mconcat, but it should not have different semantics from the default one
04:38:25 <mniip> dminuoso, showsPrec d (Add a b) = showParen (d >= 7) $ showsPrec 6 a . showString " + " . showsPrec 7 b
04:38:55 <mniip> where 6 is the fixity of +
04:39:13 <mniip> but then again recall that Show is supposed to look like haskell code and not just pretty-print
04:39:28 <mniip> s/fixity/precedence/
04:56:10 <quchen> Yes. https://github.com/quchen/articles/blob/master/fbut.md#show-is-not-for-prettyprinting
05:00:06 <Unhammer> quchen,  +1 – it really annoys me when I can't paste the output of show back into ghci for debugging …
05:06:22 <WinterFox[m]> How would I get the sum of the array [Just 1, Just 2]?
05:07:26 <liste> > sum (catMaybes [Just 1, Just 2])
05:07:29 <lambdabot>  3
05:09:34 <Logio> quchen: How bad a sin would you consider it to print a nicer, but valid constructor syntax in Show?
05:12:53 <Logio> I've done that for a library of mine, and I wondered a bit whether there would be some robust way to do it
05:25:58 <ertes-w> Unhammer: i think the point is that Show is not for pretty-printing, not that you can actually use its output as haskell code
05:26:20 <ertes-w> > S.fromList [1,2,3]
05:26:23 <lambdabot>  fromList [1,2,3]
05:26:27 <ertes-w> > fromList [1,2,3]
05:26:29 <lambdabot>  error:
05:26:29 <lambdabot>      • Ambiguous type variable ‘a0’ arising from a use of ‘show_M146405625457...
05:26:29 <lambdabot>        prevents the constraint ‘(Show a0)’ from being solved.
05:27:57 <Unhammer> ertes-w,  but it's *so useful* for pasting back into ghci (when it's actually implemented as something `read`-able), and not very useful for anything else 
05:28:28 <Unhammer> I typically see Set.fromList when I Debug.traceShow, not S
05:29:14 <ertes-w> honestly i don't think Show is really anything, so the arguments people love to have about how "Show is only for debugging!!!111" are kinda pointless
05:29:38 <Unhammer> (granted, that means I have to s,Set,S since I imported it as S, but that's much better than having "fromGregorian 1800 1 1" turn into "1800-01-01")
05:30:24 <Unhammer> I guess if you don't use it, it's pointless :) but for me it has been really useful
05:30:57 <ertes-w> i find it useful that the Show instance of UTCTime is *not* haskell code ;)
05:36:59 <hexagoxel> #
05:48:16 <phadej> well, it could be something partial
06:19:10 <jchia_> Can I get some help understanding a type error? http://lpaste.net/360374
06:20:04 <jchia_> makeVector is fine but makeVector' is rejected. I don't understand why the compiler is OK with makeVector but not makeVector' when I'm just adding composition with sequence.
06:21:59 <merijn> jchia_: oh, just for kicks, can you replace the . after sequence with $ ?
06:22:01 <lyxia> jchia_: create :: (forall s. ST s (...)) -> (...)     (.) :: (b -> c) -> (a -> b) -> (a -> c)    to compose them (... . create), you must unify a with (forall s. ST s (...))
06:23:22 <lyxia> A type system that can do this is "impredicative", and Haskell doesn't do that yet.
06:23:25 <jchia_> What's a clean way to help the compiler figure out the types?
06:23:42 <merijn> jchia_: Did you try using $ instead of . as I suggested?
06:23:51 <byorgey> jchia_: what merijn said.  There are special typechecking rules built in for ($) to handle exactly this situation.
06:24:17 <jchia_> *sigh*, mixed up $ with .
06:24:28 <merijn> lyxia: Haskell does do impredicative, for some definition of impredicative. The problem is that no one really knows what impredicative types *should* do
06:25:00 <jchia_> well, not mixed up, just prefering . over $ as a habit but it doesn't work in this case
06:25:01 <merijn> jchia_: I was too lazy to check if it was the actual issue, but $ has specific hacks for ST that . does not. So usually errors when using . with ST can be solved with $ :)
06:25:02 <Cale> It's not that you mixed them up, it's that $ is treated magically by the typechecker in a silly way.
06:25:02 <byorgey> jchia_: I'm not sure what you mean.  In theory $ and . should have the same result here.  It's just that you've run into a strange corner of the type system.
06:25:29 <byorgey> jchia_: this is the *only* case where preferring . over $ is the wrong choice =)
06:25:35 <Cale> I actually wish that special case didn't exist, it's weird.
06:25:49 <jchia_> i was banging my head for like an hour
06:25:55 <lyxia> Just use parentheses
06:26:13 <merijn> lyxia: ugh :p
06:26:47 <jchia_> merijn: $ works like a charm
06:26:56 <jchia_> I now don't even need the type annotation for sequence
06:28:01 <jchia_> Is there a simple way to detect cases like this and apply this hack?
06:28:14 <merijn> jchia_: This is the only case
06:28:46 <jchia_> merijn: I mean in future with some other code, how can I recognize that I need to use $ instead of .?
06:28:58 <merijn> jchia_: When the error involves ST
06:29:11 <jchia_> OK
06:29:32 <jchia_> merijn, byorgey, lyxia: Thanks
06:30:55 <Kristjan> Minu nimi on Kristjan Robam. Pangakonto nr: EE671010010225901016 (SEB Eesti). Inimesed, palun annetage mulle raha, eelistatult 50 eurot korraga. Vajan hädasti raha.
06:33:55 <Cale> jchia: Actually, I wouldn't even rely on $ working there -- the only reason it works is because GHC does some fairly mysterious stuff with ($) specifically. If you have to apply a function whose type is higher rank, probably best just to apply it with ordinary whitespace function application.
06:37:09 <Cale> jchia: The reason it doesn't work is due to the type of create :: (forall s. ST s (MVector s a)) -> Vector a -- in order to unify the type of this function with the type of (.) or ($), it has to instantiate a type variable to the polymorphic type (forall s. ST s (MVector s a))
06:38:20 <Cale> and GHC doesn't normally attempt this
06:45:03 <byorgey> ...was that a random plea for donations in Estonian??
06:45:16 <byorgey> people on the internet are strange
06:45:26 <merijn> byorgey: Same person was spamming in English for healthcare donations earlier this week
06:45:40 <merijn> So just regular old scamming
07:00:09 <infandum> Does cassava work on utf-8 CSV files?
07:00:20 <infandum> It takes in bytestrings, not utf-8...
07:00:38 <cocreature> ascii commas have the same encoding as utf-8 commas
07:00:58 <infandum> What if it's spaces and stuff like that?
07:01:29 <infandum> I have working code on csvs. I was presented with a utf-8 file, then it doesn't work.
07:01:59 <cocreature> cassava doesn’t care about that, the FromField instances might care but at least for Text they assume utf8 anyway
07:02:14 <infandum> Hmm, ok.
07:03:31 <cocreature> how are you checking whether it works with utf-8?
07:06:43 <st0ut> hi hi
07:19:41 <athan> With -XLinearTypes, could you prove that `(a -> b) o- (a -> b) == (a -> b)`?
07:20:08 <athan> or, really - `Monad m => (a -> m b) o- (a -> m b)`
07:20:30 <tsaka__> is anyone familiar with both "The HoTT Book" by Univalent Foundations and the homotopy type theory book by Bartoz Milewski and can comment on the difference in quality and difficulty between them?
07:20:44 <athan> == (a -> m b) (sorry, I'm really off the ball)
07:23:50 <[exa]> tsaka__: for some reason I thought they are the same, can you point me to the second book?
07:24:14 <[exa]> tsaka__: anyway the hott book is a good read, though it gets a bit boring/technical in the middle
07:24:36 <tsaka__> [exa]: http://www.lulu.com/shop/bartosz-milewski/category-theory-for-programmers/paperback/product-23352094.html
07:24:56 <cocreature> tsaka__: that’s not a hott book?
07:24:59 <Taneb> tsaka__: Category Theory for Programmers isn't about HoTT at all
07:25:34 <tsaka__> oh, i wouldn't know, haven't read either!
07:25:54 <[exa]> tsaka__: if you want to dodge categories, certainly read the hott book :]
07:26:17 <tsaka__> they're complementary then? cat theory is a subset of hott?
07:31:07 <steve-chavez> Hi, I've found a snippet that uses `deriving Data`  and I get a ` Not in scope: type constructor or class ‘Data’` error, what import should I use to clear that error?
07:31:50 <Taneb> steve-chavez: Data.Data
07:31:58 <Taneb> Or Data.Data (Data)
07:33:01 <steve-chavez> Taneb thanks a lot, google wasn't helping
07:33:27 <Taneb> :)
07:33:43 <[exa]> tsaka__: hott is more like a metatheory, you can define CT in that. So the book is about something completely different, related more to logic than to programming
07:34:29 <[exa]> (you can also define everything the other way around, as CT people would do)
07:34:32 <Cale> tsaka__: I'm only familiar with the HoTT Book. It's good.
07:34:52 <aberrant> morning all
07:35:41 <aberrant> I noticed that "where" statements are indent-sensitive. Is indentation a generally important feature of Haskell?
07:36:24 <lyxia> very much
07:36:35 <Cale> tsaka__: Probably the difficulty of it depends on your background a fair amount. If you know a bit about dependent type theory already, it'll probably be easier. If you know a bit about homotopy theory, that will also make it easier, but neither of these things is really a hard prerequisite.
07:36:53 <lyxia> aberrant: https://en.wikibooks.org/wiki/Haskell/Indentation
07:37:29 <lyxia> This makes it impossible to produce unreadable Haskell. [Citation needed]
07:37:33 <aberrant> lyxia: that's very helpful. Thanks.
07:37:59 <Taneb> lyxia: ha, you haven't seen some of my code
07:38:00 <aberrant> so it's not quite as demanding as, say, python, but still important.
07:38:26 <tsaka__> Cale: Okay, that's helpful. I don't have any formal background in type theory so I think I'll give the cat theory book a read first, maybe that's the simpler one
07:39:11 <Cale> tsaka__: Another good thing to check out is Software Foundations, which is an introduction to Coq.
07:39:47 <Cale> tsaka__: A few days of playing around with proofs in Coq or Agda is worth a lot.
07:39:53 <Taneb> Oooh, I didn't realise you could get a PDF of the HoTT book
07:40:16 <Cale> Taneb: also the source is on github
07:40:29 <Taneb> Now I don't have an excuse not to check it out :D
07:42:03 <Cale> (the entire book was produced collaboratively as a version controlled open source project :)
07:42:16 <tsaka__> didn't one of the founders of hott recently pass away
07:44:18 <Taneb> Cale: seeing the price I might actually buy a physical copy instead
07:46:51 <tsaka__> yeah the main bloke behind the hott book recently died; read the news thought i'd pick his book up. Is it helpful at all for Haskell programming?
07:47:24 <aberrant> are case expressions ever used, or is function pattern matching preferred?
07:47:47 <Taneb> aberrant: case expressions are used quite frequently
07:47:48 <quchen> tsaka__: The first chapter (of 3) is a nice intro to dependent types, it made me realize how very simple existential types were
07:47:59 <aberrant> Taneb: ok, so worth to learn.
07:48:13 <quchen> tsaka__: Understanding existentials by using Haskell is as simple as understanding lambdas using Java
07:48:14 <aberrant> I need to find some representative Haskell code.
07:48:35 <dminuoso> mniip: Wow wait a moment. In a bizarre way this reminds me of fold somehow ( https://wiki.haskell.org/wikiupload/3/3e/Right-fold-transformation.png ). Is this by any chance related to catamorphisms?
07:49:01 <quchen> Understanding existentials in a more suitable type system is almost trivial (see e.g. Idris, Agda, or reading about them in HoTT)
07:49:57 <mniip> dminuoso, well yes
07:50:25 <mniip> list fusion is a similar optimization that relies heavily on the fact that  build foldr = id
07:50:28 <quchen> aberrant: case is the primitive all pattern matches (and guards and what have you) desugar to, and it’s also used frequently
07:50:39 <mniip> where  build f = f (:) []
07:51:45 <quchen> aberrant: I often prefer case over multiple clauses, since the latter requires repeating the function’s name a lot.
07:51:52 <quchen> But it’s mostly a stylistic thing.
07:51:58 <mniip> foldr (:) = flip (++)
07:52:12 <mniip> dminuoso, this is more relying on the fact that
07:52:30 <mniip> x ++ (y ++ z) is more efficient than (x ++ y) ++ z
07:52:36 <mniip> fsvo efficient
07:53:27 <mniip> and this precatenation thing is just a really neat way to turn all kinds of trees into right-hanging ones
07:54:13 <mlehmk> what about (<|>)?
07:54:38 <mniip> the performance of (x ++) . (y ++) . (z ++) doesn't depend on the order of composition, only on the number of the composed functions
07:54:51 <mniip> mlehmk, what does <|> change
07:55:05 <mniip> it's still a concatenation function limited by the same limitations
07:55:13 <mniip> 1512057125 [18:52:05] <mniip> x ++ (y ++ z) is more efficient than (x ++ y) ++ z
07:55:17 <mniip> this isn't a problem with the ++ function
07:55:24 <mniip> this is a quirk of the evaluation strategt
07:56:02 <quchen> …which is a quirk of sinlgy linked lists
07:56:43 <dminuoso> mniip: Ah, I remember this from the Gentle Introduction. Well, showsPrec is so easy to use, it just looked weird and scary when I saw it on hackage
07:57:01 <mlehmk> so a new operator with infixr would do the fast thing?
07:57:09 <mniip> dminuoso, I'm not sure where I picked up showsPrec but likely from examining -ddump-deriv
07:57:13 <mniip> mlehmk, no
07:57:26 <mniip> ++ should be infixr too
07:57:30 <mniip> % :info ++
07:57:31 <yahb> mniip: (++) :: [a] -> [a] -> [a] -- Defined in `GHC.Base'; infixr 5 ++
07:57:48 <mniip> infixr only changes what 'x ++ y ++ z' means
07:59:00 <mniip> it doesn't change the fact that, say,
07:59:24 <mniip> foldl (++) []
07:59:34 <mniip> constructs a left-hanging tree
07:59:51 <mniip> hmm
08:00:08 <mniip> yeah that
08:01:31 <dminuoso> mniip: When I said that it reminded me of a fold, it was just that "show" and "shows" somehow seemed to do something very similar to folds
08:02:16 <dminuoso> With my recursive data structure I mean.
08:02:16 <mniip> not sure in what way
08:02:20 <mniip> ah
08:02:23 <mniip> I see
08:02:29 <mniip> they are catamorphisms of some sort
08:02:42 <mniip> I thought you meant the show->shows transformation reminded you of folds
08:02:58 <dminuoso> Ah that explains the confusion, my apologies for not being clear.
08:34:18 <rgc> hi!I need help with this: data Robot a = Electron a | Magnet a deriving (Show), i.e the pure part of the Applicative instance 
08:35:51 <mlehmk> pure is a lift operation, isn't it?
08:36:17 <rgc> mlehmk: I think so :)
08:36:32 <geekosaur> in a sense --- but "lift" is a trifle overloaded. it's a different kind of lift from, say, the monad transformer one.
08:36:44 <geekosaur> also see e.g. hoist
08:37:08 <mlehmk> well, you need to somehow a -> Robot a with your pure
08:37:16 <mlehmk> and that a is the function
08:37:41 <rgc> :mlehmk how? 
08:38:11 <mlehmk> I don't see how, like pure id, is it Electron id or Magnet id?
08:38:37 <rgc> mlehmk: that's the prblem, I think
08:39:12 <mnoonan> rgc: do you have fmap and (<*>) defined already?
08:39:19 <dminuoso> So if a type variable is rigid, that means it's "set in stone" and cannot be unified/changed/switched from that context?
08:39:27 <rgc> monochrom: yes
08:40:15 <lyxia> dminuoso: sounds about right
08:40:33 <mnoonan> (assuming that was to me).. you can't say what pure is in isolation, it has to satisfy laws that tie it to <$> and <*>
08:41:38 <rgc> mnoonan: so, I can't define it?
08:41:39 <mnoonan> but if you start with one of the laws, (maybe "fmap f x = pure f <*> x") and the definitions of fmap and <*>, you can probably work back to a definition of pure
08:42:04 <mnoonan> rgc: *I* can't define it, because you haven't told me what fmap and <*> are for Robot :)
08:43:17 <mlehmk> rgc, it might be fine to add the applicative, so it is neither Electron id nor Magnet id but a third
08:43:33 <mlehmk> to the datatype
08:44:25 <rgc> instance Functor Robot where ↥f (Electron a ) = Electron ( f a)  ↥f (Magnet a) = Magnet (f a)
08:46:04 <mlehmk> rgc, could you elaborate at how Robot should behave under the Applicative?
08:47:02 <rgc> mlehmk: Yes, it as to respect the Applicative law  pure id <*> Magnet 2 => Magnet 2
08:47:25 <rgc> *has*
08:47:26 <mlehmk> rgc, how did you define <*> then?
08:47:31 <mnoonan> but you still haven't defined <*> for Robot, and it isn't really clear what you want it to do
08:47:44 <mnoonan> e.g. what is Electron id <*> Magnet 2 supposed to be?
08:47:46 <rgc> mnoonan: a moment :9
08:47:49 <mnoonan> :)
08:48:26 <rgc> instance Applicative Robot where (Electron f) ⊛ (Electron a) = Electron (f a)(Magnet f) ⊛ (Magnet a) = Magnet (f a) 
08:50:01 <rgc> (Electron f) ⊛ (Magnet a)= Electron (f a)
08:50:04 <mlehmk> could pure a = Electron a then?
08:50:16 <rgc> mlehmk: yes but
08:50:40 <rgc> pure id <*> Magnet 2 => Electron 2
08:50:44 <rgc> not correct
08:50:50 <mlehmk> a bummer
08:50:57 <rgc> I think so
08:51:20 <mlehmk> is there any X f, where X f <*> A a => A a
08:51:37 <mnoonan> is the Electron f <*> Magnet x case Electron (f x) or Magnet (f x)?
08:51:49 <mnoonan> er, sorry, Magnet f <*> Electron x
08:52:33 <rgc> I miss it :)
08:52:38 <mlehmk> what would be with Magnet id <*> Magnet 2
08:53:56 <rgc> (Magnet f) <*> (Electron a) = Magnet (f a)
08:54:26 <mnoonan> so I think you're out of luck, no possible "pure"
08:54:57 <rgc> Magnet id <*> Magnet 2 => Magnet 2
08:55:16 <rgc> mnoonan: I think so....
08:55:34 <rgc> Just to be sure
08:55:43 <rgc> mnoonan: thank you, anyway
08:56:16 <mnoonan> you either have pure = Magnet or pure = Electron, but if pure = Magnet then "pure f <*> (Electron x) /= fmap f (Electron x)", and similar for pure = Electron
08:57:54 <rgc> mnoonan: in any case , I don't respect the Applicative law pure id <*> Magnet 2 ( because => Electron 2),or viceversa
08:58:06 <mnoonan> right
09:00:14 <mlehmk> rgc, could work if fmap id (Electron 2) => Magnet 2
09:00:45 <mnoonan> mlehmk: that breaks the law for functor
09:01:06 <mlehmk> ahh, so not only the law for applicative, but also the law for functor seems broken
09:02:02 <rgc> a total mess :)
09:02:06 <mlehmk> can't there be a third, where Third id <*> Magnet a => Magnet a and Third id <*> Electron a => Electron a?
09:02:38 <rgc> mmmhh...maybe that's a solution
09:03:50 <rgc> but fmap id (Electron 2) => Electron 2
09:04:02 <mlehmk> yes, so?
09:04:13 <rgc> functor law is safe
09:04:36 <mlehmk> safer if Third cannot be used as constructor for Robot
09:05:05 <mlehmk> so only pure is a constructor and it might even constrain to a specific kind, if that is even possible
09:05:44 <rgc> I think it's not possible, in this case
09:06:22 <mlehmk> well, you need a representation for a Robot id that holds true for fmap id a being identical to pure id <*> a
09:06:53 <rgc> yes
09:07:06 <mlehmk> for now I only see a third as a possibility if Magnet and Electron are supposed to flip
09:07:53 <rgc> I think it's time to enter Gravitational :)
09:08:03 <rgc> I try to elaborate on it
09:08:33 <rgc> thank you for the suggestion, mlehmk 
09:12:48 <mlehmk> you're welcome
09:13:05 <mlehmk> actually I also see gravitational as a side effect of electron and magnet
09:13:48 <mlehmk> somehow, probably cause energy concentrations curve spacetime in a way that might be the cause of gravitational effects...
09:14:23 <rgc> mlehmk: ;)
09:15:04 <mlehmk> just gravitational waves are strange then
09:25:15 <masaeedu[m]> Is it possible to get a free instance of `Functor` for things that are both `Foldable` and `Monoid`?
09:25:35 * masaeedu[m] sent a long message: masaeedu[m]_2017-11-30_17:25:12.txt <https://matrix.org/_matrix/media/v1/download/matrix.org/DnjPeJVBqcjddjAbVYkZDhxZ>
09:26:10 <masaeedu[m]> which I feel is close, but of course no cigar
09:27:38 <exio4> there's a kind mismatch there
09:29:17 <masaeedu[m]> I need a typeclass that represents the ability to unwrap and re-wrap elements, without going all the way to the strength of monad
09:30:15 <fishythefish> Monad doesn't represent that anyway
09:30:17 <geekosaur> we can do that, but in aa sense it's worse
09:30:26 <masaeedu[m]> exio4: Could you point out where specifically?
09:30:28 <geekosaur> it goes all the way to the strength of lens :p
09:30:48 <geekosaur> (Unwrapped and Rewrapped typeclasses and Iso)
09:31:29 * masaeedu[m] sent a long message: masaeedu[m]_2017-11-30_17:31:06.txt <https://matrix.org/_matrix/media/v1/download/matrix.org/gpShFrJtGDKDXESCmxcLwJXn>
09:31:32 <lyxia> Do you mean (Foldable f, forall a. Monoid (f a)) => Functor f
09:32:48 <lyxia> Here's an f that contradicts such a thing:  data F a where C :: F ()
09:32:52 <fishythefish> is defining your own `class C f where wrap :: a -> f a; unwrap :: f a -> a` unacceptable?
09:33:19 <lyxia> ah no it doesn't have a monoid...
09:33:35 <lyxia> I mean, F a isn't a monoid for all a... hmmm
09:33:51 <masaeedu[m]> Basically the loose idea here is
09:34:00 <rightfold> fishythefish: yes but also see the Newtype class
09:34:07 <masaeedu[m]> If you have a way to fold down a structure, and also a way to build up the same structure
09:34:13 <masaeedu[m]> then you should kind of have an fmap out of that
09:35:09 <masaeedu[m]> because you can more or less fmap by foldMapping over anamorphism composed with the transformation
09:35:11 <byorgey> masaeedu[m]: only if you can build up exactly the same structure you started with.  i.e. I can imagine that on a tree, folding it and building up again might result in a differen tree (e.g. a totally left- or right-nested one)
09:35:15 <masaeedu[m]> waves hands furiously
09:35:48 <masaeedu[m]> byorgey: Right, so how do I represent "being able to build up the same structure"?
09:35:50 <byorgey> masaeedu[m]: I think what you really want is 'Traversable'.  But every Traversable is already a Functor.
09:35:54 <nshepperd_> You can make fmappy kind of thing that throws away any extra structure with foldMap, pure and <|>
09:35:59 <lyxia> masaeedu[m]: after you apply f :: a -> b, you get a "b" but you're still missing a way to make "f b" before applying mappend
09:36:51 <nshepperd_> But if you have pure or <|> then you already have Functor
09:36:53 <masaeedu[m]> This is why I was thinking maybe I need something that allows "rewrapping"
09:37:03 <masaeedu[m]> like that stuff that abstracts over constructors
09:37:07 <masaeedu[m]> generic haskell?
09:37:09 <masaeedu[m]> or something
09:37:20 <masaeedu[m]> Yeah, I don't want to go past functor
09:37:25 <masaeedu[m]> because then it's all useless
09:37:45 <masaeedu[m]> I wanted to see what primitives that are orthogonal to Functor are sufficient to implement functor
09:38:10 <byorgey> I really don't think there are any.  Functor is pretty fundamental.
09:40:15 <masaeedu[m]> hmm
09:41:12 <masaeedu[m]> Like for lists, I could say you can `fmap` by tearing down the old list element by element, embedding each element into a new list after applying `f`
09:41:30 <atondwal[m]> Functor has one field and one axiom. Hard to get simpler than that
09:42:21 <masaeedu[m]> So if someone didn't give me `Functor` on list for whatever reason, the foldability of it and the ability to mappend on new elements are sufficient to make an fmap
09:42:46 <byorgey> masaeedu[m]: yes, but that *only* works for lists.  Because if you tear down a structure and then build it up one by one, all you can get at the end is a list.  Because that's the structure you get when you add elements one by one.
09:42:47 <nshepperd_> That's a special fact about lists, that they are nothing other than a list of elements and hence foldMap preserves information
09:43:14 <masaeedu[m]> byorgey: I can actually follow similar reasoning for some other kinds of functors
09:43:16 <masaeedu[m]> e.g. rose trees
09:43:53 <nshepperd_> data ListWithInt a = List Int [a]
09:43:54 <byorgey> masaeedu[m]: but not using Foldable.  Foldable *only* lets you observe the elements of a structure as an ordered list.
09:43:55 <masaeedu[m]> or `Map`s
09:44:05 <atondwal[m]> You can't actually write anamorphisms in general if you don't already have a functor instance
09:44:11 <byorgey> the entire Foldable interface can be implemented in terms of the 'toList' method
09:44:20 <nshepperd_> ^^ is a Functor, but you can't get fmap out of foldable no matter how hard you try
09:44:54 <masaeedu[m]> Ok, I see what you're saying now
09:45:00 <masaeedu[m]> durr
09:45:18 <masaeedu[m]> what specifically is it about lists
09:45:28 <masaeedu[m]> E.g. if I had no list concrete type
09:45:57 <masaeedu[m]> what combination of abstract typeclasses makes a thing amenable to this reconstruction
09:46:14 <byorgey> now, if Foldable represented "real" folds (i.e. catamorphisms) then you could implement Functor in terms of that.
09:46:47 <nshepperd_> Well, if you're using foldMap, pure and <|>, you're just secretly using the list constructors
09:47:04 <byorgey> masaeedu[m]: Functor =)
09:47:05 <atondwal[m]> Buuuut the type signature for cata requires that you already be a functor
09:47:08 <nshepperd_> And reimplementing fmap the normal way
09:47:16 <masaeedu[m]> lol
09:47:49 <byorgey> atondwal[m]: not quite, it requires that the one-level "pattern functor" is a functor.  That's different than saying that the generated fixpoint is a functor.
09:47:58 <nshepperd_> But just pretending that you don't know you're using a list
09:48:01 <byorgey> you can usefully implement fmap in terms of cata.
09:48:03 <masaeedu[m]> byorgey: Well no, I mean what property in combination with `foldMap` *gives* you functoriality on the list
09:48:23 <masaeedu[m]> nshepperd_: Can something like `pure` be pushed upwards past `Functor`?
09:48:23 <byorgey> masaeedu[m]: for lists specifically?
09:48:48 <masaeedu[m]> byorgey: What I'm trying to ask I guess is, how similar does a type need to be to lists
09:48:49 <nshepperd_> masaeedu[m]: huh? What is upwards?
09:49:00 <byorgey> masaeedu[m]: isomorphic.
09:49:02 <masaeedu[m]> to also be able to get `fmap` from foldability
09:49:24 <masaeedu[m]> Upwards as in not dependent on `Functor`. Right now `pure` is in applicative functors, which are functors
09:49:38 <byorgey> since Foldable turns everything into a list, the only thing you can correctly reconstruct is a list.
09:50:00 <masaeedu[m]> :t cata
09:50:01 <lambdabot> Functor f => (f a -> a) -> Mu f -> a
09:50:21 <masaeedu[m]> :t Mu
09:50:22 <lambdabot> error:
09:50:22 <lambdabot>     • Data constructor not in scope: Mu
09:50:22 <lambdabot>     • Perhaps you meant one of these:
09:50:26 <masaeedu[m]> :i Mu
09:51:47 <masaeedu[m]> Weird, can't find `cata` on Hoogle
09:53:12 <byorgey> well, it's not in a standard package
09:53:13 <rightfold> Hoogle doesn’t search through all packages
09:53:27 <cocreature> http://hoogle.haskell.org/?hoogle=cata
09:55:15 <masaeedu[m]> Oh man, this is one of those Ed Kmett things isn't it
10:00:04 <masaeedu[m]> Is there a non-type family way of expressing what a catamorphism is?
10:01:30 <dsal> http-conduit seems a good deal slower than other things.
10:02:42 <mnoonan> masaeedu[m]: you need a relationship between two types, the fixpoint and the underlying functor. so either you need a type family to convert one to the other (like Base from recursion-schemes), or you need to explicitly define one from the other (like data Fix f = Fix (f (Fix f)))
10:03:02 <EvanR> see also the way they did it here https://en.wikipedia.org/wiki/Catamorphism
10:03:22 <EvanR> cata :: Functor f => Algebra f a -> (Fix f -> a)
10:03:41 <atondwal[m]> byorgey: I was thinking that one implies the other, but I guess that's equivalent to being able to usefully implement fmap on terms of cata
10:06:04 <EvanR> or the linked page https://www.schoolofhaskell.com/user/edwardk/recursion-schemes/catamorphisms 
10:06:10 <EvanR> maybe you didnt mean type family
10:07:04 * hackage rate-limit 1.2.0 - A basic library for rate-limiting IO actions.  https://hackage.haskell.org/package/rate-limit-1.2.0 (AdamWick)
10:10:38 <aberrant> I am beating my head against the wall with this syntax. Can someone set me straight?  https://pastebin.com/JncyHvSQ
10:11:46 <EvanR> remove the last paren
10:11:48 <mnoonan> aberrant, surely it should be "filter p", given the name of the function?
10:12:12 <aberrant> er, wait, wrong version. Try this: https://pastebin.com/JCW0Eq3K
10:12:14 <aberrant> yeah
10:12:30 <aberrant> I clicked "undo" fewer times than I should've
10:12:34 <EvanR> you cant put where within an expression like that
10:13:00 <EvanR> where is attached to an equation or a case alternative
10:13:02 <aberrant> EvanR: the where goes with the filter, right?
10:13:02 <Cale> 'where' is part of the syntax of declarations
10:13:06 <EvanR> no
10:13:12 <aberrant> oh.
10:13:24 <EvanR> move last paren to the end of the first line
10:13:39 <Cale> If you want an expression form, you can use   let <decls> in <expr>
10:13:39 <EvanR> then rewrite it all to use . instead of tons of parens ;)
10:13:55 <aberrant> I haven't gotten to "." in the book yet
10:14:05 <EvanR> function composition
10:14:13 <aberrant> in time :)
10:14:27 <erisco> the most important function you will ever use
10:14:32 <aberrant> so the "where" always goes at the end of the assignment?
10:14:56 <EvanR> s/assignment/definition
10:15:06 <aberrant> definition. Sorry
10:15:16 <EvanR> foo = bar where more equations
10:16:39 <aberrant> that works; thank you
10:17:05 <aberrant> and I learned there's a function called "odd" that replaces "where p x = x `mod` 2 /= 0"
10:17:20 <EvanR> odd 0
10:17:24 <EvanR> > odd 0
10:17:27 <lambdabot>  False
10:17:32 <EvanR> thumbsup
10:17:41 <aberrant> > even 0
10:17:43 <lambdabot>  True
10:17:51 <aberrant> > odd -1
10:17:54 <lambdabot>  error:
10:17:54 <lambdabot>      • No instance for (Num (Integer -> Bool))
10:17:54 <lambdabot>          arising from a use of ‘e_11’
10:18:02 <EvanR> > odd (-1)
10:18:04 <lambdabot>  True
10:18:06 <aberrant> ah.
10:18:15 <aberrant> the parens are messing me up
10:18:51 <EvanR> what you wrote was parsed as "odd - 1"
10:19:02 <EvanR> :(
10:19:05 <aberrant> hah.
10:19:13 <aberrant> so whitespace is important, except when it isn't. :)
10:19:28 <fakenullie> > odd(-1)
10:19:30 <EvanR> specifically the - character is all wrong in haskell
10:19:30 <lambdabot>  True
10:20:01 <EvanR> and (- 1) is parsed as (-1)
10:20:08 <EvanR> instead of a section subtracting 1
10:20:40 <fakenullie> can you still section it somehow?
10:20:45 <EvanR> no
10:20:57 <EvanR> you have to use (subtract 1)
10:21:39 <fakenullie> > subtract 1 10
10:21:42 <lambdabot>  9
10:22:19 <erisco> > (`subtract` 10) 1
10:22:21 <lambdabot>  9
10:22:34 <fakenullie> heh
10:23:16 <erisco> > let (—) = subtract in (— 10) 1
10:23:18 <lambdabot>  9
10:23:35 <EvanR> subtract x = negate . (x -)
10:24:00 <fakenullie> > let (—) = (-) in (— 10) 1
10:24:03 <lambdabot>  -9
10:24:09 <EvanR> lol
10:24:14 <EvanR> fixed
10:29:08 <aberrant> ok, now you're just confusing me
10:30:38 <slack1256> http://lpaste.net/360379 I got code like this, with an scoped monadic effect
10:31:02 <slack1256> sometimes I heard that if I am using lift then I am doing it wrong. Is there an alternative to this that doesn't use lift?
10:31:39 <lyxia> slack1256: you could export primitives as mtl-style type classes
10:32:13 <lyxia> so that lift remains only in these instances
10:33:15 <slack1256> !!! oh you mean write `cmd1,cmd2 :: (MonadState Int m) => m ()` for example?
10:33:17 <slack1256> that works
10:40:25 <fresheyeball> I'm trying to do some aggitation for this https://github.com/commercialhaskell/stack/issues/3617
10:40:34 <fresheyeball> who is with me!?
10:41:16 <slack1256> I don't believe in agitation, I believe in code. Write some 
10:42:01 <[exa]> fresheyeball: people from debian called this kind of ruling as do-oism
10:42:06 <[exa]> code it, it will be there
10:42:46 <[exa]> agitation is for politics :D
10:43:43 <Rembane> +1 for code it
10:44:04 <fresheyeball> [exa]: I may try to code and solve this myself. However I don't have an interest in developing that deep stack knowledge.
10:45:00 <fresheyeball> Rembane: [exa] I also believe in paying OS devs to do what they do best. If enough people want it, we could get it funded.
10:45:56 <Rembane> fresheyeball: I'm quite happy using stack.
10:46:09 <AndreasK> Doesn't stack have already stack init to turn cabal into stack projects? While not enough for many people I doubt many are motivated to do more if that works already
10:46:09 <fresheyeball> Rembane: that's great!
10:46:10 <cocreature> fresheyeball: are you proposing that stack uses dependency solving in those cases?
10:46:50 <fresheyeball> cocreature: no, I propose it not care about deps when exposing certain apis
10:47:03 <cocreature> fresheyeball: but all examples you mention actually rely on being able to build projects
10:47:06 <cocreature> so you need deps
10:47:07 <fresheyeball> or get deps from standard cabal sources
10:47:39 <fresheyeball> as in, the project is buildable with `cabal build`, so the deps are there already
10:47:45 <fresheyeball> I think it could just use them
10:47:52 <cocreature> sounds like you want dependency solving
10:48:09 <fresheyeball> cocreature: I might have misunderstood you
10:48:23 <cocreature> you need some way to figure out which dependencies to use
10:48:31 <fresheyeball> I thought you meant dependency solving as in contraint solving of dep versions
10:48:36 <cocreature> stack does that via stackage normally while cabal uses a solver to figure out the right version
10:48:41 <cocreature> that’s exactly what I mean
10:49:03 <fresheyeball> cocreature: then I don't think we need that
10:49:05 <cocreature> you are saying stack shouldn’t rely on stackage for tasks that require dependencies so it seems like you are proposing to do constraint solving to figure out the dependencies
10:49:06 <fresheyeball> but I could be wrong
10:49:39 <fresheyeball> I think if I provide a working dep set to stack, it should be able to use them, without Stackage
10:50:29 <glguy> Yeah, and the way you do that is by listing the versions in the extra-deps of your stack.yaml
10:51:06 <fresheyeball> glguy: that is the current way. But I have custom nix code providing them, that cannot be moved to a stack.yaml easily.
10:51:30 <fresheyeball> I am suggesting that stack could provide a subset of it's functionality to a non-stack use-case.
10:52:18 <cocreature> my point is that the functionality you want to have requires more information than you seem to be suggesting
10:53:02 <fresheyeball> cocreature: I don't think so. I've read the notes on the projects I mentioned, and most of them just need a stackwork folder. Not dependecy resolution.
10:53:46 <fresheyeball> IE they need stack's .hi files and structure, but nothing else. Cabal could add this functionality as well, but the tools expect stackwork
10:53:48 <cocreature> fresheyeball: I know that at least weeder, haskell-tools and intero need to be able to build your project which requires among other things knowing which dependencies to use
10:54:21 <fresheyeball> I mean I get why stack can't do this now. I am suggesting to could be able to.
10:54:30 <fresheyeball> *it could
10:54:52 * hackage memory 0.14.9 - memory and related abstraction stuff  https://hackage.haskell.org/package/memory-0.14.9 (VincentHanquez)
10:55:04 <cocreature> it seems like you are proposing that stack becomes an abstraction layer over various build tools
10:55:21 <fresheyeball> cocreature: IDE tools
10:55:25 <cocreature> I don’t see that happening any time soon and I’m also not sure it is a good idea
10:55:26 <fresheyeball> and it more or less is now!
10:55:58 <fresheyeball> It's popularity means that there is little pressure for the developers of these tools to support cabal projects.
10:56:22 <fresheyeball> So why not provide a way for stack to build projects without stackage.
10:56:41 <fresheyeball> Given that it offers more than resolution and stackage.
10:57:50 <mud> Stackage isn't a requirement in stack. There are resolvers that don't use stackage
10:58:43 <fresheyeball> mud: does my request already work, and I am just unaware of how to do it?
10:58:57 <mud> I'm not exactly sure what you're trying to do honestly
10:59:19 <fresheyeball> mud: use tools like weeder and intero with a cabal+nix project
10:59:52 <glguy> in the meantime you can drop intero for dante, which works with both stack and new-build and old-build
11:00:37 <mud> Ah, I don't know. I've never heard of weeder, and I've never used intero. I mean you can make a cabal project a stack project fairly easily. I don't know how nix works very well, I know stack has *some* support for it, but hell if I know if it'll do what you want.
11:00:49 <fresheyeball> glguy: I use dante now. But it sucks by comparison, and also doesn't have the features of these new tools.
11:00:54 <traitedd> Hello  if one spend 5 hours daily for 40days for haskell can he become haskell pro ?
11:01:21 <fresheyeball> traitedd: it took me longer than that. Could work for you.
11:01:34 <edwardk> Same here
11:01:45 <traitedd> fresheyeball:  why work for me ? longer like how much ?
11:01:58 <EvanR> 40 days 40 nights in the oasis of referential transparency
11:02:07 <fresheyeball> traitedd: I don't know how fast you learn. It took me 3 years with daily study.
11:02:28 <fresheyeball> Also, it was the best decision of my career.
11:02:33 <traitedd> 3 years ?
11:02:39 <traitedd> aree you serious ?
11:02:39 <EvanR> me too
11:02:50 <EvanR> and yeah it took years
11:03:13 <edwardk> It took me about six months to really feel comfortable with Haskell, and so felt like there was a rather severely diminish set of things I didn't know about Haskell about 2 years in
11:03:28 <edwardk> Er "and I"
11:03:50 <EvanR> it will go smoother i think if you have previous experience with functional programming, lisp or scheme
11:03:53 <traitedd> then I must postpone my haskell dream :(
11:04:35 <EvanR> dont try to do a crash course all at once
11:04:40 * slack1256 realize he thought like traitedd before, thinking that the goal was mastery
11:05:02 <traitedd> can I learn python in 40 days?
11:05:21 <slack1256> you should seek novelty. What catches you attention?
11:05:28 <Psybur> Ive been cracking at haskell since like september and I can navigate my way through a monad stack somewhat heh
11:05:44 <glguy> You can learn the basics of most programming languages in 40 days. You won't be a "pro" in any of them
11:05:47 <traitedd> I decided to choose either haskell or python for next 40 days
11:06:05 <EvanR> interleave python and haskell
11:06:51 <traitedd> EvanR: what 
11:06:58 <slack1256> ^ yes interleave
11:07:06 <traitedd> means
11:07:08 <fresheyeball> traitedd: Haskell plays nice with other languages
11:07:22 <fresheyeball> you can polygott yourself to more learning and experience
11:09:34 <traitedd> I see my life so blank
11:10:01 <traitedd> and feel so lost :(
11:10:07 <Psybur> traitedd, do you have any software you want to make?
11:10:33 <Psybur> I "learned" both python and haskell by creating algorithmic traders
11:11:13 <traitedd> not from books ?
11:12:37 <eacameron> Wow...trying to use regex in Haskell
11:12:39 <Psybur> Nope, tried to implement certain features, when I'd hit roadblocks Id search for the way to do it and then also read about best practices regarding what I just learned about
11:12:47 <traitedd> i have nothing in my mind ...I need a new job and I am to learn C or Python or Haskell in next 40-60 daysand attend job interviews
11:12:49 <eacameron> It's ... abysmal.
11:13:04 <Psybur> traitedd, if you need a new job learn java heh
11:13:11 <EvanR> or PHP
11:13:13 <Rembane> eacameron: Don't. Create a parser instead.
11:13:14 <cocreature> eacameron: take a look at regex-applicative
11:13:27 <fresheyeball> Ooo regex-applicative looks NICE!
11:13:28 <EvanR> jobs that hire you to write in those languages with no experience
11:13:43 <traitedd> Java very tough right ?
11:14:22 <Psybur> traitedd, its more verbose but I dont think its tough
11:14:34 <eacameron> traitedd: If you only have 60 days I'd recommend against trying to learn Haskell and find a Haskell job.
11:14:48 <eacameron> cocreature: It's slow
11:15:16 <Psybur> eacameron, you mean recommend against both parts of your and expression? Or he should find a haskell job first without learning the language? :D
11:15:20 <traitedd> java can be astered in 40-60 days? then wgat type of jobs I will get ?
11:15:20 <cocreature> eacameron: :( luckily I haven’t had to care about that so far
11:15:35 <eacameron> Psybur: 
11:15:43 <eacameron> Psyber: Just the combination of the two
11:15:58 <EvanR> your not mastering anything in 2 months
11:15:58 <cocreature> gabriel gonzalez gave a nice talk and fast and nice regex apis in Haskell at some point but afaik he never released a package out of that work
11:16:02 <eacameron> Haskell's great. Having a job is great. But trying to get a Haskell job after 60 days of haskell...yeah. not going to happen
11:16:14 <eacameron> cocreature: I was looking for that!
11:16:34 <aberrant> ok
11:16:37 <traitedd> EvanR:  need not master I should crack job interview
11:16:48 <traitedd> then slowly I will master
11:16:48 <Psybur> How do you know you're ready for a job writing haskell? I cant find any certifications like Java has
11:16:55 <traitedd> and I should be able to do my job
11:17:00 <aberrant> LYAH just used something they haven't yet introduced. What is !! ?
11:17:07 <cocreature> eacameron: maybe you need to be the one to turn it into a package ;)
11:17:17 <eacameron> cocreature: :/
11:17:20 <eacameron> That's funny.
11:17:21 <Psybur> > [1,2,3] !! 1
11:17:23 <lambdabot>  2
11:17:34 <aberrant> erm
11:17:44 <Psybur> aberrant, random list access
11:18:00 <aberrant> oh, a random selection?
11:18:16 <fresheyeball> traitedd: if you can write a Servant server. I would hire you. That's my personal min bound for Haskell skill.
11:18:16 <Psybur> Well, not random in the sense that you supply the index :D
11:18:20 <aberrant> oh, no. indexing.
11:18:22 <aberrant> got it.
11:18:23 * hackage hscolour 1.24.4 - Colourise Haskell code.  https://hackage.haskell.org/package/hscolour-1.24.4 (MalcolmWallace)
11:18:30 <aberrant> thank you.
11:19:23 <traitedd> fresheyeball:  why not you give me time and test ?
11:19:52 <Psybur> fresheyeball, so I could just copy the hello world example and you'd hire me? :D
11:21:36 <fresheyeball> traitedd: what do you mean by `test`. You can have all the time you like :P
11:22:03 <dmwit> is this test open-book
11:22:17 <traitedd> fresheyeball:  I will be back after 40-60 days finishing haskellbook and other resources will you provide me job after testing?
11:22:24 * hackage hsshellscript 3.4.2 - Haskell for Unix shell scripting tasks  https://hackage.haskell.org/package/hsshellscript-3.4.2 (VolkerWysk)
11:22:29 <traitedd> Right now I find no jobs in haskell
11:22:46 <fresheyeball> traitedd: hit me up once you finish the book
11:22:50 <traitedd> testing my skills*
11:22:51 <glguy> dmwit: sorry, you're not eligible to find a new job
11:23:01 <fresheyeball> let's talk and I would be happy to recommend you for an interview where I work
11:23:03 <Psybur> fresheyeball, this is the minimum for Haskell skill? https://github.com/haskell-servant/example-servant-minimal/blob/master/src/App.hs :D?
11:23:07 <dmwit> hehe, BUSTED
11:23:31 <dmwit> I can't get the job anyway, apparently. I've no idea how to Servant.
11:23:34 <fresheyeball> Psybur: lmfao
11:23:51 <mniip> fresheyeball, that seems oddly specific
11:23:59 <fresheyeball> dmwit: I am sure you can use Servant
11:24:14 <mniip> yeah I have never used servant either
11:24:24 <mniip> but I know a great deal of many other things
11:24:31 <aberrant> I'm looking at that code and realize I understand next to none of it.
11:24:32 <fresheyeball> mniip: I like it as a rule of thumb test, since using it forces you to touch many concepts
11:24:43 <fresheyeball> not saying it's the only test or anything
11:24:54 <dmwit> aberrant: I think this is exactly why my "open-book" question is relevant.
11:25:09 <fresheyeball> plenty of employable Haskellers who don't use Servant
11:25:12 <dmwit> If it's open book, it might be a reasonable test. Closed book it is testing for a very strange thing.
11:25:18 <aberrant> dmwit: I'm not looking for a new job though :)
11:25:23 <dmwit> me neither =)
11:25:50 <aberrant> but there is a project here that has some haskell and few people understand it, so I might be able to jump on in a few months.
11:26:01 <dmwit> I just thought it was funny that I have a job doing Haskell all day and still wouldn't pass fresheyeball's minimum requirements. =P
11:26:06 <mniip> huh
11:26:07 <aberrant> hah.
11:26:15 <mniip> I understood most of it but what's that Foo/+/X for
11:26:23 <aberrant> so there are non-academic uses for this language? :D
11:26:28 <dmwit> oh no
11:26:35 <dmwit> please =P
11:27:06 <mniip> aberrant, suppose that no, does that make you want to abandon the language?
11:27:20 <fresheyeball> dmwit: I think you misunderstood what I meant. I'm sure you would have no problem writing a Servant server. I don't look for being Servant skills, just the ability to use it as a rough measure.
11:27:22 <aberrant> not at all
11:27:26 <mniip> then why ask :p
11:27:30 <traitedd> from today I will spend 5 hours for haskell and 2 hours for python  and I will try for 40 days + 20 days some project. I will see why is it no possible to master
11:27:40 <aberrant> because it's going to determine whether I advocate for it here at work.
11:27:57 <mniip> I see
11:28:01 <Psybur> dmwit, what kind of projects are you working on at the moment?
11:28:42 <Psybur> traitedd, if you really keep up that schedule you will learn a lot, I'll tell you that. Good luck
11:28:51 <mizu_no_oto> dmwit: I assume the 'write a Servant server' is 'over a weekend, throw together a quick server using Servant'
11:29:09 <dmwit> Most recently, I've been hacking on some cryptographic program obfuscation stuff and helping design a tool for discovering anomalous (possibly malicious) behavior with machine learning.
11:29:17 <mniip> yeah I don't expect servant to be any harder than say flask given my haskell level
11:29:26 <mniip> and I've figured flask out in hours
11:29:29 <fresheyeball> dmwit: you are cool! 
11:29:32 <Psybur> Which machine learning libraries are you using?
11:29:33 <mizu_no_oto> So 'I don't know Servant' just means you need to read some documentation
11:29:49 <mniip> mizu_no_oto, yeah pretty much
11:29:51 <traitedd> Thanks Psybur  I will catch fresheyeball  after that time or I will ping on IRC 
11:29:52 <fresheyeball> mniip: mizu_no_oto exactly
11:29:53 <Psybur> And why was haskell chosen over say python with its dang ol scikit learn
11:30:13 <fresheyeball> traitedd: you can tweet at me, as I am not always on IRC
11:30:17 <fresheyeball> same handle
11:30:30 <mniip> fresheyeball, I do wonder what do you use haskell for
11:30:33 <traitedd> I dont have twitter 
11:30:43 <dmwit> Actually the ML stuff *is* mostly in Python.
11:30:47 <fresheyeball> traitedd: can't help you there haha
11:31:04 <traitedd> fresheyeball:  no prob  If God helps I will find you :)
11:31:04 <mizu_no_oto> dmwit: where are you working, these days?
11:31:10 <traitedd> or some one like you
11:31:12 <dmwit> I'm at Galois.
11:31:20 <fresheyeball> mniip: I do frontend with Reflex-dom and backend with Servant and Database.Beam
11:31:21 <fakenullie>  python is good for shuffling things, not implementing actual algorithms
11:31:25 <fresheyeball> I work at Takt
11:31:49 <Psybur> fresheyeball, what domain?
11:31:51 <traitedd> https://takt.com/   ?
11:31:56 <dmwit> And, well, as long as people are advertising, we're always looking for talented engineers too. =P
11:31:57 <mniip> oh
11:32:02 <fresheyeball> traitedd: yes
11:32:03 <mniip> hmm, doesn't sound like my cup of tea
11:32:09 <fresheyeball> Psybur: marketing and personalization
11:32:22 <traitedd> fresheyeball:  I am very good with maths and ML(only theory)
11:32:30 <traitedd> your company do AI stuff?
11:32:38 <fresheyeball> traitedd: yes, with TensorFlow
11:32:41 <Psybur> fresheyeball, do you work on the customer portal or in the data analysis/mining part
11:32:52 <Psybur> I assume theres some kind of mining/analytics going on
11:33:05 <traitedd> fresheyeball:  then how you are using haskell ? you mostly use python right?
11:33:08 <fresheyeball> Psybur: I personally work on the customer UI, as well as the rendering pipeline.
11:33:20 <fresheyeball> traitedd: We use TensorFlow in Haskell
11:33:38 <dmwit> fresheyeball: Are the bindings pretty complete?
11:33:50 <traitedd> fresheyeball:  Awesome 
11:33:55 <fresheyeball> dmwit: I don't work on that part, but my perception is they are good bindings.
11:34:03 <mniip> fresheyeball, I prefer less data-intensive and more architecturally-intriguing problems :p
11:34:11 <dmwit> I've been thinking about trying to use TF from Haskell for a hobby project, but I worry that I won't be able to match up the standard docs with the Haskell API very well.
11:34:31 <fresheyeball> dmwit: I can ask around if you like.
11:34:37 <dmwit> no biggy
11:34:50 <Psybur> You guys work remote?
11:35:00 <fresheyeball> Psybur: I am 100% remote
11:35:05 <Psybur> Das it mane
11:35:23 <mniip> ooh remote
11:35:29 <mniip> ignore anything I said
11:35:36 <fresheyeball> haha
11:35:37 <Psybur> xD
11:39:01 <humanoyd> dmwit: only out of curiosity, what would be the minimum requirements at Galois? Having written a language extension? Fluent with Coyoneda? :)
11:39:43 <dmwit> hehehe, we do have some pretty crazy smart folks =)
11:40:48 <dminuoso> fromInteger :: Num a => Integer -> a   how does this work exactly?
11:40:57 <dminuoso> How does one make a polymorphic type from a monotype?
11:40:57 <mniip> ooh coyoneda
11:41:11 <dmwit> dminuoso: Each instance of `Num` has to say how it works.
11:41:18 <mniip> do you mean the existentially packed "free" functor construction?
11:41:20 <mniip> or something else
11:41:45 <fishythefish> dminuoso: i.e. it's part of the minimal complete definition for a Num instance
11:41:46 <jle`> dminuoso: are you familiar with how typeclasses work
11:42:13 <jle`> when you write an instance of a typeclass for a type, you must provide definitions for those methods for your type
11:42:25 <mniip> oooh
11:42:26 <humanoyd> dmwit: alternatively, you could provide a link to the github repo of the least smart employee :>
11:42:30 <dmwit> dminuoso: Maybe a fun minimization of your question: How does `mempty :: Monoid a => a` work? How does one make a polymorphic value out of nothing?
11:42:33 <mniip> I should say I am pretty familiar with Coyoneda the type
11:42:42 <mniip> but I never considered it in terms of the yoneda lemma itself
11:42:47 <Psybur> humanoyd, ooh if you get it please share :D
11:43:31 <dmwit> humanoyd: github.com/dmwit
11:44:16 <mniip> damn
11:44:28 <balor> I've seen type constraints like this http://lpaste.net/360380 in a few libraries.  How do I write a function that takes a `V`?  I had thought `d :: V Int ~ Int -> String`  would take either `(1, 2)` or `(0,1,2)` and return `"V 2"`.
11:44:57 <mniip> forall b. (a -> b) -> f b
11:45:00 <mniip> is pretty much
11:45:06 <mniip> NT ((->) a) f
11:45:06 <Psybur> dmwit, thats a lot of forking
11:45:11 <mniip> which uh
11:45:19 <dmwit> Psybur: That's the github way. =/
11:45:43 <mniip> liftYoneda and runYoneda evidence a natural isomorphism between NT ((->) a) f and f a
11:45:50 <dminuoso> dmwit: Ah, my brain was disabled there. Somehow I did not realize it was part of Num. Maybe I should stop using :t to figure things out about things.
11:45:51 <mniip> fascinating
11:46:32 <jle`> balor: d :: (V a ~ Int) => a -> String
11:46:44 <balor> jle`, thanks
11:47:24 <mniip> now what exactly is the coyoneda lemma
11:47:28 <jle`> balor: but be aware that the only sensible implementations are constant strings
11:47:47 <jle`> d _ = "something"  etc. are the only implementations possible
11:47:52 <jle`> you can't use the input
11:48:02 <mniip> the definition of Coyoneda makes me think of dinatural transformations
11:48:09 <mniip> from (-> a) to f
11:48:10 <dmwit> You can if there's an appropriate typeclass lying around.
11:48:27 <dmwit> class Select a where select :: a -> V a -- or something
11:48:37 <balor> jle`, yes. That makes sense.  I'm just playing with simple examples right now.  I can probably ensure that X is an instance of `show` somewhere and use that.
11:49:35 <mniip> some sort of...
11:49:46 <mniip> hmm, is there a Profunctor in profunctors for it
11:53:46 <balor> I had to use `d :: (V a ~ b) => a -> String` rather than  `d :: (V a ~ Int) => a -> String` as "Expected kind ‘* -> *’, but ‘Int’ has kind ‘*’"
11:54:21 <jle`> balor: oh yeah i noticed that the kind signature you had for V was a bit weird
11:54:35 <jle`> it seems like you want V :: * -> *
11:54:46 <jle`> but the one you wrote was V a :: * -> *
11:54:53 <jle`> which makes V :: k -> * -> *
11:55:08 <mniip> Product (Clown Op) f
11:55:10 <mniip> there it is
11:55:19 <jle`> balor: and, through kind inference, V :: * -> * -> *
11:55:25 <mniip> end of that as a universal wedge
11:55:35 <jle`> balor: you should write type family V a :: *, perhaps
11:55:53 <balor> jle`, The example comes from https://github.com/diagrams/diagrams-core/blob/master/src/Diagrams/Core/V.hs
11:56:15 <mniip> dmwit, is that enough edwardklike gibberish to work at galois :D
11:58:35 <jle`> balor: ah okay.  then yea, V is supposed to take two arguments
11:58:43 <jle`> V a b ~ Int, maybe
11:59:10 <jle`> or `V a` is a Functor
11:59:19 <jle`> (or at least, a single-argument type constructor
11:59:47 <zwuggy> :t \f a -> f ($ a)
11:59:48 <lambdabot> (((a -> b) -> b) -> t) -> a -> t
12:00:19 <zwuggy> ^ so is that a valid proof of triple contradiction is single contradiction in intuitionistic logic?
12:00:38 <zwuggy> (substituting bottom for b and t)
12:00:53 <mniip> sounds legit
12:00:59 <fishythefish> lgtm
12:01:09 <balor> jle`, Right...I'll go and read. This discussion has been really helpful in clarifying my misunderstandings about TypeFamilies. Thanks.
12:01:09 <mniip> @djinn Not (Not (Not a)) -> Not a
12:01:09 <lambdabot> f a b = void (a (\ c -> c b))
12:01:18 <jle`> balor: no problem :)
12:02:59 <Average-user> Hi, sorry to interrupt, but have someone worked with a Haskell minikenren before? Or another Logic Haskell library?
12:08:01 <byorgey> jle`: yeah, it's more that V takes an argument and returns a Functor
12:08:09 <zwuggy> mniip: why do we need a void there?
12:08:18 <zwuggy> ... in what djinn siad
12:08:31 <mniip> I don't think you do
12:08:39 <mniip> but it's not incorrect
12:08:46 <zwuggy> yeah, mine is exactly that without the void
12:08:48 <mniip> void @Void = id
12:09:17 <mniip> in fact otherwise Void wouldn't be initial
12:09:39 <zwuggy> so it is kind of incorrect?
12:09:57 <mniip> no
12:10:17 <mniip> both of these are equally correct, and with closer consideration, equal
12:10:51 <zwuggy> what syntax is 'void @Void = id'?
12:11:17 <mniip> TypeApplication
12:11:18 <mniip> :t void
12:11:20 <lambdabot> Functor f => f a -> f ()
12:11:25 <mniip> hmm that's the wrong void
12:11:45 <mniip> :t absurd
12:11:47 <lambdabot> Void -> a
12:12:08 <mniip> ah duh lambdabot doesn't have TypeApplications
12:12:11 <mniip> % :t absurd @Void
12:12:11 <yahb> mniip: absurd @Void :: Void -> Void
12:12:59 <zwuggy> ah, now I get it, thanks!
12:13:06 <mniip> absurd is "the" unique morpshism from the initial object Void of the Hask category
12:13:17 <EvanR> Void -> Void makes sense
12:13:18 <mniip> id @Void is the identity morphism around Void
12:13:35 <mniip> together the two statements imply
12:13:40 <mniip> that absurd @Void = id @Void
12:14:17 <zwuggy> yep, makes sense.
12:14:38 <EvanR> but Void -> a has had some philosophical criticism
12:14:45 <zwuggy> what doesn't make sense is why djinn thought to include it, yet to me.
12:15:31 <zwuggy> EvanR: but then wouldn't you not have initial objects at all?
12:17:07 * hackage rhine 0.3.0.0 - Functional Reactive Programming with type-level clocks  https://hackage.haskell.org/package/rhine-0.3.0.0 (turion)
12:17:18 <EvanR> is Hask even a category, etc
12:17:28 <nshepperd_> Perhaps djinn just tacks on absurd to any function that results in Void as a shortcut
12:18:32 <nshepperd_> Regardless what you are trying to prove, if you obtain Void you can use absurd and say "done" without thinking any further
12:19:15 <EvanR> assuming principle of ex falso quodlibet
12:19:22 * hackage rhine-gloss 0.3.0.0 -   https://hackage.haskell.org/package/rhine-gloss-0.3.0.0 (turion)
12:20:25 <EvanR> which went through a long period of questioning before being enshrined in martin lof type theory
12:22:43 <dminuoso> So. I managed to panic GHC, but trac refuses to let me sign up and keeps me in an infinite captcha loop.
12:23:57 <edmn> Pardon me, I've been looking for help with setting up haskell build & editor tooling. In particular, getting ghc-mod with stack projects. Could I trouble someone for a bit of help?
12:27:44 <mniip> I woudln't expect djinn to specialcase Void
12:27:53 <mniip> given it doesn't use a naive algorithm
12:28:23 <mniip> there's a cubic time or something algorithm for type exference in HM
12:29:23 * hackage tagsoup 0.14.2 - Parsing and extracting information from (possibly malformed) HTML/XML documents  https://hackage.haskell.org/package/tagsoup-0.14.2 (NeilMitchell)
12:34:38 <sjsch> I'm following "Learn you a Haskell" and I've hit a gap in my knowledge
12:34:50 <sjsch> I've made a "YesNo a" typeclass
12:34:59 <sjsch> with one function yesno :: a -> Bool
12:35:10 <sjsch> and now I want to make an instance of YesNo for all Num
12:35:35 <sjsch> I can make "instance YesNo Int" and it works fine, but I want to make YesNo work for ALL types in the Num typeclass
12:37:11 <guillaum3> Do you know a readable way to flatten a structure such as `Map a (Map b (Set c))` to [(a, b, c)]. For now I have something such as `concatMap (\(a, bc) -> concatMap (\(b, cs) -> map (\c -> (a, b, c)) (Set.toList cs)) (Map.toList bc)) (Map.toList m)` (Or something similar).
12:37:34 <EvanR> instance Num a => YesNo a where
12:38:10 <EvanR> this will stop you from defining more than 1 totaly instance of YesNo
12:38:16 <EvanR> total
12:38:22 <sjsch> EvanR, I've got that, but I don't quite understand the error I'm getting
12:38:26 <sjsch> let me paste it real quick
12:38:35 <geekosaur> it's also likely incomplete since there's no isZero and ghc dropped Eq a => Num a
12:38:36 <EvanR> because any other instance will be overlapping
12:39:20 <sjsch> http://lpaste.net/360384
12:39:23 <dsal> You can add constraints to classes like that?
12:39:33 <geekosaur> class (Show a, Eq a) => Num a where...
12:39:39 <EvanR> sure
12:39:42 <geekosaur> which is the H2010 definition
12:40:19 <EvanR> you need to enable FlexibleInstances, like it says
12:40:24 <geekosaur> hm, actually I can derive a likely suitable isZero from Num, come to think of it. modulo possible weird behavior for nonstandard Num instances
12:40:36 <sjsch> Thanks guys, it works now
12:40:57 <sjsch> I had to do Num a as well
12:41:07 <sjsch> and enable UndecidableInstances and FlexibleInstances
12:41:08 <EvanR> do Num a ?
12:41:16 <sjsch> sorry, I meant Eq a
12:41:31 <geekosaur> (using negate and abs. Complex would be slightly odd but should still behave intuitively. I can imagine other "weird" Num instances that might not, rules or no)
12:41:42 <EvanR> since you defined it as yesno 0 = ...
12:41:48 <EvanR> you implicitly required Eq
12:42:02 <EvanR> but really, this instance is going to be wacky
12:42:17 <EvanR> because it overlaps any other instance of YesNo
12:42:21 <sjsch> I would think that, too, but if I delete the Eq a it says Could not deduce (Eq a) arising from the literal ‘0’
12:42:35 <geekosaur> that's what EvanR meant
12:42:36 <EvanR> that is what i said, you have to have Eq
12:42:40 <geekosaur> (and what I meant earlier)
12:42:46 <sjsch> ah, sorry.  still new to haskell's type madness
12:42:56 <geekosaur> you can't infer that instance, it has to be explicit
12:43:12 <sjsch> thanks for the help!
12:43:17 <dsal> geekosaur: How does isZero work?
12:43:18 <geekosaur> which is what the error tells you
12:43:28 <dsal> I ran into a similar problem a bit back.
12:43:59 <dminuoso> Is there a way to set the global resolver to a nightly?
12:44:02 <geekosaur> dsal, actually I thought about it and decided that while I can remove explicit zero I still need Eq, so it doesn't help
12:44:32 <dsal> Oh, right.  I couldn't do anything useful without Eq.
12:44:35 <geekosaur> and explicit zero is actually a non-problem since literals get wrapped anyway
12:46:37 <AndiK> dminuoso: For stack? There should be a global project in your stack folder
12:50:31 <dminuoso> AndiK: Ah thank you for the pointer, works great. :)
12:52:00 <mniip> type madness
12:52:04 <mniip> did you mean type heaven
12:52:18 <EvanR> type limbo
12:55:34 <geekosaur> the type fog of youth :p
12:58:46 --- topic: 'https://www.haskell.org | https://wiki.haskell.org/IRC_channel | Paste code/errors: http://lpaste.net/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D | https://www.reddit.com/r/haskell | Admin: #haskell-ops | Offtopic: #haskell-offtopic | https://downloads.haskell.org | https://summer.haskell.org Summer of Haskell 2017'
12:58:46 --- topic: set by mauke!5lzdiZJQGk@p3m/member/mauke on [Mon Jul 31 05:45:11 2017]
12:58:46 --- names: list (clog animated ericshortcut whaletechno pitb0ss fishythefish Jackoe serendependy Xal ski hc chaosmasttter sjsch toby__ maomao knupfer HMPerson1_ ma27 sfcg sepp2k MP2E ziocroc2 AndiK raingloom mjhoy juhp kafle thblt sleffy ninedotnine xcmw jmelesky mlehmk cschneid_ lambda-11235 tomphp zwuggy Average-user path[l] zmt00 jgt codyw graphtheory alexteves zachk qmm tac-tics albertus1 pera pfurla nudgeman AndreasK coot___________ valentinbuza romanix cross toblorone)
12:58:46 --- names: list (kuribas sakalli humanoyd raynold conal atomi ranberry juiko Guest78 kakashiAL db8093246 replay mcoffin GamboPango slack1256 ystael tsaka__ teddy_error t7 goodboy NotASpy1 Xion__ erisco xkapastel Dr8128 Swizec neoncontrails davr0s danthemyth xttraces mda1 theelous3 rickygee zaquest desperek SaleemPheku jfredett jeltsch rm8 Jesin SpinTensor spietz1 Jacoby6000 drewr urodna biglama SuprDewd TipsyMe afarmer raichoo nuncanada rgc yago woodson _ashbreeze_)
12:58:46 --- names: list ({emptyset} doodleha_ dbmikus quobo nurupo hexfive Pacra kculpis aberrant Sampuka aarvar xinming inhortte mud sdothum sternmull jxv minn hucksy nighty- Ulrar dddddd emilypi mizu_no_oto crobbins duncan^ gawen yellowj barcabuona pavonia jackhill pplorins Lokathor_ connrs nahra Mistv[m] Rubas[m] Guest291964[m] eyenx rprospero[m] Vipernet1220[m] Guest312594[m] caimbeul[m] frunobulax[m] Bimmie[m] rimon[m] sssi1ver[m] scrypso[m] voidanon[m] hesiodos[m] jnonpony[m])
12:58:46 --- names: list (Guest1573[m] seto[m] packetbiompm[m] yaspoon[m] ticao[m] Monad[m] Verandetten[m] ptek[m] Litom[m] thebeast[m] zmre[m] lixiang4u[m] KevinMGranger bustillo[m] mrhania[m] mark_c akshay7777[m] M-HirmeS maverickwoo[m] mk[m] Elorm[m] kwaku[m] KENNYNR1[m] littlejay[m] sh4pe[m] am2on reconmaster[m] porcow[m] durandal1 joakimf95[m] fxk[m] fgaz[m] PatrickM[m] magog[m] etXzat[m] grahf[m] stellis[m] himmAllRight[m] prot[m] Andry976[m] BartGroeneveld[m mapleleaf[m])
12:58:46 --- names: list (M0xfiras[m] ElliotKiyomizu[m c0ff33[m] matheusrv[m] M-herah Jasonjunsu[m] SijmenSchoon[m] kkr[m] km42[m] JohnnyReb[m] shekel[m] asthma[m] nine-h[m] Guest340521[m] caro401 stevendai[m] guest236[m] mrgraffe[m] psan[m] djquant[m] mrdaak[m] guest121[m] toa[m] dirb guest69[m] razvanc-r[m] testtt0x11[m] Zarthalan[m] ArrayWindrunner[ sudom0nk[m] kebertx[m] j0ni[m] pacmansyu[m] DavesTestingAcco a89lk[m] mith[m] ayylmaoo[m] usedname[m] Mougan[m] boash[m])
12:58:46 --- names: list (shsnthstnhs[m] sphalerite teuffy[m] Reyu[m] dbramucci[m] srenatus Shaunthesheep[m] sgoody[m] superpat[m] polux[m] magnap Scapin[m] gutigen[m] Deleh[m] howsiwei[m] riaqn burgundy[m] marmite[m] wizzup[m] Niboor[m] SansFr[m] felipeac[m] ajtowns[m] nimbus[m] minhnhdo[m] jvalleroy[m] M-x-matrix[m] softashell rcat[m] oozz[m] tobim[m] rainbyte[m] Luguber[m] testingriotnmatr kosmikus[m] ramirezD[m] goolord[m] thekyriarchy__ cuddly[m] aminos[m] ub[m] Makinit[m])
12:58:46 --- names: list (Nerka[m] vrnithinkumar[m] avatias0[m] siddhanathan[m] octalsrc[m] chocowheel[m] grdryn meinashi[m] Overload[m] TuXic[m] Ed2bno1[m] Cadey[m] antiless[m] Sasasw just_test1ng[m] ya-alex[m] LangeOortjes[m] MarkusK[m] unclechu crapman[m] pedroteo[m] adampaigge[m] M-kitsune Courage[m] devpav[m] hugogomes[m] WolfLightning[m] jsonhigh[m] h_ndrik[m] Adau[m] chominist[m] rizo[m] fonadius[m] peel[m] TimWolla[m] schum[m] moka[m] superobserver[m] sitischu[m] apardo[m])
12:58:46 --- names: list (Heino[m] narispo[m] Naughtmare[m] emme[m] levzhazeschi[m] dtpop[m] Frytka[m] adziahel[m] ttk2[m] lucnx[m] chaseroycroft[m] Michi[m] JHBrannam[m] gylpm[m] joncfoo[m] netsu[m] Akito[m] mlainz[m] Squidnyan[m] wisn[m] pyrtheibarit[m] Ubiquitous[m] intheclouddan[m] bramvdbogaerde[m XertroV[m] ThousandLions[m] FederalRick[m] abel-abel[m] okkk hdurer[m] d-0504[m] beemo[m] mtncoder[m] M-rgh bbslclubbin[m] laaksoan[m] Barnabas[m] hiq[m] peddie[m] ycy[m])
12:58:46 --- names: list (trevorriles[m] jacobleach[m] ltq520[m] ByteEater[m] elpfen[m] roninkaizen[m] ninegua[m] dkellner[m] xffox[m] AX3L[m] jhb2345 rydia5[m] PifyZ[m] fbreitwieser[m] MufeedAli[m] psYchotic[m] dpacbach[m] absurd[m] chuzz[m] saci[m] puminya[m] synopz[m] talesmantovani[m CryptoCalsius[m] Flecheck[m] zhangjiji[m] M-ms lkh[m] Maikel_Experius[ pingfreud[m] LucasFrancesco[m daoo[m] lonokhov[m] el_tejon[m] rakete redviking[m] cwgoes[m]1 georg3[m] ngross[m] noxeternae[m])
12:58:46 --- names: list (gregoire[m] ljagged[m] yassineoualmakra Dako300[m] thisLight[m] mrhunky[m] towaii[m] ma-ku[m] fib11235[m] huda[m] testtt55[m] asm[m]1 chaetopterus[m] NickSeagull[m] innaytool[m] naviknair7[m] riotartist[m] closures999[m] toumi124[m] xeel[m] M16_29[m] romanzolotarev[m seizo[m] nh2[m] NickHu1 spotter[m] M-whoops kimchi[m] kilian[m]1 vitamin-q jomari[m] Novitsh[m] yashi[m] charlag[m] phil_frontal[m] phittacus bgrayburn[m] ketanhwr zukonake[m] mad[m]1)
12:58:46 --- names: list (sebisebi[m] plll[m] masaeedu[m] nullset[m] tibike_m[m] scanleft[m] ddbbuu[m] islamicwarez[m] khac[m] futpib[m] JackM[m] wubbalubbadubdu4 ItevNabdifNi[m] subz[m] apigeon[m] asenski[m] zalipuha[m] stites[m] hotsocks[m] idnar[m] moonrunes[m] puffnfresh aaronc[m] foreseaz[m] m3tti[m] Matthew[m] M-Illandan Rifa[m] strixy[m] etcinit[m] Masaomi[m] Obscurity[m] riadvargas[m] thekyriarchy Mcpurplemuffin[m dtcristo trikl[m] TFX[m] zineje[m] Li[m] ElyKar[m] geetam)
12:58:46 --- names: list (schplaf[m] mossid[m]1 sudoreboot[m] rcg[m] slartibartfast[m wzy8L-B2[m] icen[m] aniketd[m] Alexander_Hansen s0ra[m] SuperW[m] thejonny[m] johnwhitlow[m] Jikstra[m] sypwex[m] newman[m] Mike[m]1 tangled_z[m] arslanatajanov[m piluex[m] MikasiCoyote[m] codesoup WinterFox[m] Lowl3v3l silver alex`` Twey dustinm JCGrant[m] Nuva[m] dphabian[m] hakan[m] undu[m] goodboy[m] TylerCecil[m] hpd_m drasich[m] JanPath[m] Aidan[m] M-kevinliao M-krsiehl zaphar_ps[m])
12:58:46 --- names: list (angelbeats[m] rellen M-BostonEnginerd o0o[m] jerin[m] sn[m] sgal[m] scde davidar WilliamHamilton tester668[m] kritzcreek m4sk1n cutie sirius[m] bennofs[m] albertsg[m] wizek[m] davidar_ turt2live MawKKe[m] unlmtd spacekitteh[m] aer[m] aspiwack[m] jmnoz MohdSKhoeini[m] ollieh hendrik[m]1 pellegrino berton freeman42x tfc[m] lysgaard[m] equalunique[m] javjarfer[m] herzmeister[m] M-berdario trevortknguyen[m reactormonk[m] jyp[m] dt343gs[m] unknownln rexor[m])
12:58:46 --- names: list (Snircle bb010g caasih Cerise steshaw yahb leat a3Dman paraseba Arcaelyx Lord_of_Life uptime beccamorgan hololeap_ simukis awayney spoonm dmiles henriksod tripty swalladge moei banc ironChicken kolko dmj` shutdown_-h_now salva mathu hegge_ anishathalye wladz rntz jared-w opqdonut carbolymer lpsmith gsingh93 majoh_ \u ChongLi Fylwind dpn` lukexi shans_ joedevivo bytesighs bradparker nkpart artagnon customminer strmpnk vikraman quaestor pmade zariuq Chousuke_)
12:58:46 --- names: list (baetheus NinjaTrappeur dxld CurryWurst lieven Limeth_ vvz tv kini thomaav yaiyan descender fearless_man acidjnk mikosty wunki noxd niklasb_ hackage Tehnix hurtsi brisbin_ pacak tek0_ CindyLinz bartavelle ess_sing x1n4u Bane^ khisanth_ Bashmetim Gabemo tg joehillen amerlyq rembo10 Oipo srhb _flow_ absence mjo carc Majiir Amadiro hsyl20 mou liyang_ jkup otto_s_ cheshircat_ cynick_ eL_Bart0- thunderrd WarzoneCommand padre_angolano rcat thc202 Voldenet lkolstad)
12:58:46 --- names: list (bengt_ lavalike milesrout Guest68998 marr perrier-1 Wuzzy marvin2 polman takuan theDon crosleyt danvet infinity0 poga jzeus isenmann ck_y felixsch__ bbielsa Squarism nakal vaibhavsagar lagothri1 lambdamu byte512 amosbird markus1189 brynedwards Nd-69-M DTZUZO Jinxit kuttifunk rossberg heurist cheater bydo carlomagno drewbarbs leothrix acarrico verement anshumanf alveric3 staffehn wedify meck Tesseraction_i taktoa maerwald armyriad mzf hiratara alhariel)
12:58:46 --- names: list (mandiblegrip rootnode dedgrant sagax mkoenig LiaoTao codeshot d6e takitus gehmehgeh erikd nshepperd srainey calloc TimWolla max-m pikajude Adeon rblaze mniip gienah ph88^ toure avocado danieli Guest1878 tromp StoneToad Noldorin alx741 valkyr2e canta cods ArneB piyush-k` hanDerPeder ertes guillaum3 Geekingfrog hamishmack karshan spion revprez toppler cgfbee RGamma unyu jchia theorbtwo MarcelineVQ meinside boj nonzen Fairy hydraz treehaqr revprez_atlanta)
12:58:46 --- names: list (mendez tusj JuanDaugherty renzhi srdqty jrabe Sgeo jcarpenter2 coeus kefin DDR sbjorn juri_ Philonous jdnavarro dsfox hrnz Happyfeeet DTZUZU S007 wonko7 obiwahn quelqun_dautre tctara Velpoman ianp happy0 slackman phadej earthy remy earldouglas ertes-w Lauda Benzi-Junior madknight castlelore wedens alexbiehl reallycooldude philosaur govg stefan-__ uwap henrytill nshepperd1 armlesshobo xa0 remexre procgen blackdog brixen dolio bitemyapp idupree cetchmoh Mikan)
12:58:46 --- names: list (isaac__ byorgey hanna barrucadu tomku ensyde mrenaud`` urdh soncodi infinisil greeny Blkt Natch Axman6 greymalkin mak` Younder quicksilver jrslepak aweinstock beerdrop emmanuel_erc m0rphism bgamari dcoutts mbrcknl_ darthThorik fuziontech iravid gleber_ mindtree cgag Bigcheese jamiecook_ petermw bonz060 ycheng fakenullie Adluc teej cdornan_ Meow-J bgyss cstrahan lopex simony sa1 feltnerm sdemos rann machbio mpickering yrid adelbertc wavewave yaknyasn)
12:58:46 --- names: list (TyOverby__ iphy tabaqui foolswood fxrs_ aijony niHiggim__ tomaw jzl Jello_Raptor dibblego johnw cyphase nerteren orion sethetter Cale tjbp usrthree mikedlr atk fall_ statusbot flori k jokester SCHAPiE marens Robin_Jadoul Alchemical sqrt2 ikopico michalisko shikhin Someguy123 Zowlyfon Akii dredozubov markhuge pasukon bus000_ Logio ninegrid Maxdamantus psychicist__ AntiSpamMeta cpup etiago sw1nn catsup raatiniemi jounaz^__ Foritus kensan asjo ryan_vw avn aminb)
12:58:46 --- names: list (alexelcu Randy matthavener Hafydd revprez_yk cjwelborn giraffe dqd nimbleark DoubleJ felixonmars vivek troydm nilOps higherorder ksj otulp xnyhps remix2000 Immune ynezz RayNbow`TU ericsagnes lispy bollu mivael_ pita sigmundv_ valdyn richi235 besenwesen kuchi Tintle Boreeas Ranhir srk emerson ego amf Sigyn eagleflo kuno Harzilein anhduy hpc rzhanka m4lvin sdrodge Jon Zialus Wizek dandan86 kshannon athan phryk g2` ssedov lines jakutis buoto revprez_stg)
12:58:46 --- names: list (revprez_anz fryguybob electrostat runawayfive miklcct @glguy timothyh monochrom R0b0t1` magicman reu Pilfers heinrich5991 nullifidian fugyk mceier hvr ralu JoelMcCracken Ewout karls Unhammer PsyDebug rotaerk andyo Igloo m1dnight_ ggVGc geppettodivacin xaimus Meanirelli robogoat Flonk schaeferpp buhman Enigmagic baweaver xaviergmail Eagle_Erwin milli dysfigured amx inr thallada _cyril_ Frankablu cesardv OnkelTem oherrala `0660 a_t_ aib raid Taneb DigitalKiwi)
12:58:46 --- names: list (mountaingoat odamn martingale ekr wagle peterhil gnusosa M4GNV5 noam__ Ankhers luigy ccase tokik tippenein niklasl hiptobecubic qzo nshepperd_ Guest98560 betawaffle fnurglewitz zeroed kav marienz simon TMA rightfold tnks chirpsalot Chobbes jgornick Cheaterman LnL mattp_ ctag sdhand ft Neo Arguggi jrm benana koz_ vimto Vorpal raindev jchia_ oh_lawd MindlessDrone sujeet joncfoo cpape dschoepe angular_mike liste dogui bsima erg newsham rwarfield albel727)
12:58:46 --- names: list (oberstein mstruebing jtcs alsoStevenXL centril jdevlieghere chrissl slester runde polux36 anoe NocnaShada Sose tsani brent80_plow bs syamaoka geal reinh1 RazorX HalfEatenPie fairfieldt edran tolt Kneiva lyxia drdo NemesisD pikhq mulk Burnout641_ jamiis_ [exa] ramatevish c_wraith aidecoe Vq Tspoon_ amuck mitchty jaargon Ornedan clever jstolarek jix thoros Hijiri jol andjjj23 diskie dysfun benzrf sleepynate catern fergusnoble prooftechnique przemkovv noctux)
12:58:46 --- names: list (joeyh fredsir Gothmog_ dunj3 ircbrowse magnuson przembot MitchW mk-fg mnoonan gabiruh wilx __main__ Tuplanolla ManiacTwister a3f ncl28_ [df]_ butterthebuddha Dykam swhalen statusfailed dmwit arw liff hive-mind emmflo kwantam pdxleif dilinger codebje orzo acro DustyDingo xtore Xnuk seliopou coup dminuoso kaffepan1a iross_ threeve_ ghostyyy dsal trosa pyrtsa n3parikh Raptor8m3 drcode gspia cpallares prg318 amiri ggherdov johs jonrh thi_ SolarAquarion)
12:58:46 --- names: list (Tristan-Speccy elvishjerricco Cthalupa twopoint718 iliastsi ljhms ynyounuo dtulig mikeplus64 gothos jameseb andromeda-galaxy Ferdirand koala_man Drezil_ sjl_ harmaahy1je hsiktas metalrain_ Argorok vodkaInf1rno deba5e12 Athas Xion_ solarus phaazon noplamodo tinco Paks capisce ClaudiusMaximus tolt_ CuriousErnestBro Intensity bendricklamar oleks nek0 lassulus Takumo marble_visions Lierdakil jle` ahihi hiredman wtw mearnsh trcm Strix echoreply divVerent scopedtv)
12:58:46 --- names: list (kgadek chrzyki Reisen burp jinblack bbaren fluxit iw00t Wamanuz2 datajerk APic rbocquet rom1504 Deewiant TallerGhostWalt ernst grumble garphy hodapp ij bananagram naudiz le_jonge scav xpoqp adamCS joachifm_ bjobjo numberten Clint mxf SpaceKni1ht posco bno2 anelson xxpor japesinator_ akermu LeaChim navilan eddsteel kloeri __name__ sanitypassing flebron ianconnolly ocharles ixian tazjin Jonno_FTW linduxed nwf nekomune nathyong tomus destiny_ petercommand)
12:58:46 --- names: list (Rembane agrif tsahyt yarou aatxe ahf_ fgaz malthe jlouis implementation_ M2tias mrd SAL9000 lukky513 wizonesolutions codedmart OliPicard amatecha seccus trig-ger angerman spicydonuts zpconn__________ lumimies mkurkov_ lexi-lambda twold monad_cat kyagrd andrew_n_ dgonyeo solidsnack andreypopp sclv hansihe rgrinberg Ober eacameron dstockwell nelll dgpratt dumptruckman huonw solatis cschneid acfoltzer akemot bogdanteleaga RevJohnnyHealey heath jdt malt3 runeks)
12:58:46 --- names: list (oldsnakey ReinH Scorchin carter nbouscal ebutleriv kipd cansis capicue niveus Tritlo gridaphobe avdi prizim ephemera_ Xorlev zmanian _6a68 SegFaultAX zymurgy nopf Warrigal tabaqui1 zenzike MagneticDuck kapu cchalmers texasmynsted cocreature geekosaur chriswk langkid1 CARAM___ johtso paf31 ericbmerritt_ Bengi jml stig stasku mbrock baamonde pchiusano Tallenz JSharp lynn prefork gornikm AlainODea AWizzArd logcat kipras feepo nille {AS} twomix stephe)
12:58:46 --- names: list (SolitaryCypher bind scinawa antismap joeytwiddle @ChanServ so PHO reptar_ exio4 croben wz1000 mgaare kfish shapr d3lxa suzu Ring0` zachary12 MasseR Biohazard Guest60956 hjklhjklhjkl Desoxy cjh` skeuchel alek Nikotiini EvanR zomg ec2-user_ abra0 brennie demiurge Eliel hexagoxel da-x Xandaros madsj Fuuzetsu pleiosaur integral mystfox noobst intelux_ exferenceBot gesindel ByronJohnson kubrat guios xacktm StianL twk- danzimm asm89 jlewis gareth_ rofer michi7x7)
12:58:46 --- names: list (ventonegro ongy micmus etrepum jzelinskie Kamuela ryanbooker niluje grandy____ fiddlerwoaroof wting gilbertw1 Zemyla changyj BytesAndCoffee Niamkik dsm__ paroxp bwe rjeli sdx23 mt defanor dashed Guest18532 frontendloader hongminhee benonsoftware Sornaensis anderson Cathy PyroLagus SuperTux88 peddie bxc beaky klugez wamaral Morgawr kaychaks mutsig michalrus bshelden tessier Guest82765 bjs epta GGMethos pandem mantovani KaneTW redcedar joel135 mbeidler)
12:58:46 --- names: list (S11001001 jmct wyvern peteretep xplat|work tjpeden edofic bitonic bigs zph thoughtpolice davean vikram__________ megaTherion Willis libbyk rodarmor sbauman heyj caw__ terrorjack ephemeron Deaddy tarcwynne__ pharaun pelegreno_ pfoetchen ahf osfameron peschkaj saurik Ke Unode wto bod_ z0ttel Saizan micro houli edwardk nemesit|znc billstclair gareth__ ambrosia supki crlane sm rjungemann TommyC eikke x-n2o Quintasan comboy kaol dpepsilon tortal cdal)
12:58:46 --- names: list (incomprehensibly reem suppi alp ijp jorendorff JoJoen thomashoneyman Guest63586 mlen TabAtkins thoradam pierrot c-rog zekt thebnq int0x27h minad bcoppens andrewmc1eigh saftsuse kosmikus kiboneu alanz lachenmayer killtheliterate raibutera cfoch-al1 ezyang monty froztbyte nesqi jorj Liskni_si freeside int-e NextHendrix dpanth3r sveit rotty zebr Frans-Willem bsrm Firedancer PotatoGim zipper Ninja3047 Zoddo Jaxan tzaeru yushyin stux|RC-only gargawel Moyst)
12:58:46 --- names: list (acowley lokydor dh WhereIsMySpoon no-n bencryption noexcept Tharbakim cow-orker sns mdarse Forkk nisstyre vqrs cjay- lukeshu alexknvl mimi_vx abbe danielglh Deadhand marcel riatre wayne mmaruseacph2 jbalint dan64- Fubar^ nikivi ids1024 arkeet cyberlard jophish swflint _janne Nik05 tdammers worch ab9rf vin-ivar esph mitch_ Purlox Xe lambdabot ftop grayhatter Klumben Profpatsch felixsch_ wrengr pdgwien ethercrow zerokarmaleft ptek michaelw tumdedum zebrah)
12:58:46 --- names: list (leah2 pikolinosimo verlet64 fingerzam admwrd nyuszika7h mk_modrzew dxtr chindy edwtjo spinda paws_ Cir0X milessabin banjiewen si14 zgrepc relrod SlashLife sbrg jw358 rizary tharper_ raek vfs xplat julmac stux|RC pranz dersquisher bluepixel junktion platz)
12:58:57 <pitb0ss> I feel like I'm probably doing something wrong
12:58:58 <hexagoxel> guillaum3: foldMapWithKey, probably? (also list comprehension makes your version more readable.)
12:59:35 <mniip> pitb0ss, I don't think that exists
12:59:56 <pitb0ss> Hm, ok
12:59:58 <pitb0ss> Thanks
13:10:53 * hackage hlint 2.0.11 - Source code suggestions  https://hackage.haskell.org/package/hlint-2.0.11 (NeilMitchell)
13:13:44 <lionrouge> hi :)
13:13:44 <exio4> masaeedu[m]: I don't mean in your code but in what you can do, a Monoid cannot be known to work on ∀a. f a for some f 
13:13:57 <lionrouge> what editors/IDE do you use to write Haskell programs ?
13:14:33 <EvanR> vim
13:14:46 <glguy> MacVim
13:15:23 <exio4> lionrouge: kate
13:15:27 <osfameron> vim
13:15:42 <exio4> lionrouge: any text editor with syntax highlighting will do it :)
13:15:55 <lionrouge> i see
13:16:00 <osfameron> (I expect more haskell devs use emacs, but as you can see, vim is so efficient that us vim users reply more quickly ;-)
13:16:08 <lionrouge> maybe some of you use plugins for Sublime/Atom/VSCode
13:16:08 <[Leary]> You can use anything, of course. I use vim too though. It's good for your life, if not your little finger.
13:17:04 <mniip> I could never get into a stable workflow of using a language specific plugin with vim
13:17:12 <mniip> so I just use plain vim
13:17:14 <cocreature> lionrouge: if you use a reasonably popular editor, changes are there is already Haskell integration for it so I would just stick to what you’re using now
13:17:39 <lionrouge> ok, thanks
13:17:56 <Average-user> I use Atom, but only for highlighting, the rest is in hands of the command line and GHC(i)
13:19:22 <exio4> osfameron: I have used Atom in the past - but just with syntax highlighting, I also use other text editors sometimes, but Kate's tabs and multiple files are good enough more often than not (for me anyway :)
13:30:00 <Sh4rPEYE> Hey. I have a (hopefully) simple question: How does one properly add packages from stack- and hack- age to IHaskell? They do have a guide(-ishish) on their GitHub, but I'm afraid I'm too slow to be able to understand that quick writing.
13:30:30 * hackage extra 1.6.1 - Extra functions I use.  https://hackage.haskell.org/package/extra-1.6.1 (NeilMitchell)
13:30:47 <Sh4rPEYE> The GitHub in question (how to add packages on the bottom): https://github.com/gibiansky/IHaskell
13:31:50 <Sh4rPEYE> To be exact, I'd liek to use trifecta from stackage and counter from hackage
13:32:56 <davean> Sh4rPEYE: what is the motivation to pull trifecta from stackage?
13:34:27 <Sh4rPEYE> Well, I thought that's the default way. Kind of: I use Stack, therefore I use stackage. tbh I'm not even sure what's the difference between stackage and hackage except that for one I use stack and for the other I use cabal
13:35:01 <davean> For both you use cabal?
13:35:08 <davean> In one case you just do it through stack
13:35:10 <geekosaur> stackage gets you a base set fo packages with fixed dependency relationships (the resolver)
13:35:25 <geekosaur> cabal is more amorphous about deps
13:35:38 <geekosaur> / hackage
13:36:00 <glguy> stack uses hackage, too. stackage has to do with the resolver: part of stack
13:36:43 <Sh4rPEYE> Ok, got it. I don't really need to care about some dependency relationships (I'm using only these two packages plus MonadRandom)
13:36:53 * hackage concurrency 1.2.3.0 - Typeclasses, functions, and data types for concurrency and STM.  https://hackage.haskell.org/package/concurrency-1.2.3.0 (barrucadu)
13:37:00 <Sh4rPEYE> Does that mean I should pull everything from hackage?
13:37:25 <mniip> huh how long do hackage docs take to build nowadays
13:38:02 <davean> mniip: is there a problem with some?
13:38:05 <Sh4rPEYE> And if so, how do I add the hackage packages to IHaskell? Should I cabal-install them beforehand, or just add them to .cabal and let stack do the work?
13:38:18 <Maticz> Hey guys, I'm wondering why foldr is the default choice over foldl as explained here: https://wiki.haskell.org/Foldr_Foldl_Foldl%27   --- I'm still a bit confused why this is? I know you can choose foldl' for the deep strictification, but why exacly will foldr still be the default choice when foldl variants are tail-recursive?
13:38:19 <mniip> or is it just that my package is too strick about the 'base' version
13:38:28 <mniip> strict
13:39:07 <mniip> Maticz, foldr is better when your folding function produces a result that can be partially evaluated
13:39:45 <Maticz> mniip, could you explain what "partially evaluated" is in this case?
13:39:45 <mniip> @let foo = foldr (:) [] $ "hello" ++ fix id
13:39:47 <lambdabot>  Defined.
13:39:50 <mniip> > take 3 foo
13:39:53 <lambdabot>  "hel"
13:39:59 <mniip> you would never achieve this with a left fold
13:40:23 <davean> mniip: can you link me to the package that didn't build for you?
13:40:33 <mniip> davean, http://hackage.haskell.org/package/hexchat
13:40:38 <mniip> davean, do notice how it said no reports
13:40:57 <fishythefish> Maticz: the importance of tail-recursion depends on the overall evaluation strategy
13:41:16 <fishythefish> since we evaluate lazily, tail-recursion is less useful in haskell than in many other languages
13:42:14 <fishythefish> we *want* data to be produced outside the recursive call, since that's data we can work with immediately
13:42:38 <Maticz> fishythefish, that makes sense indeed
13:44:03 <fishythefish> infinite data tends to illustrate this well, but foldr is often a good choice for finite data as well
13:44:45 <fishythefish> other considerations include the associativity/commutativity of your combining function as well as its strictness requirements
13:45:42 <mniip> oh yeah
13:45:47 <mniip> (++) is better foldred
13:45:51 <mniip> than foldled
13:47:00 <Maticz> thanks for the info guys
13:47:59 <fishythefish> comparing foldr (:) [] == id to foldl (flip (:)) [] == reverse is enough to convince me which one is the right one, personally :)
13:48:35 <mniip> davean, are you one of the people who can actually take a look into it
13:49:08 <davean> mniip: Yes, I run/ran the hackage builder
13:49:26 <davean> though right now I can't log in to rackspace and I lack the ip of the builder saved on this system ...
13:49:41 <davean> so its looking like more work then I can fit into my current schedule ATM
13:50:12 <mniip> I see
13:50:16 <mniip> it can wait
13:50:58 <davean> other people with access can be pinged in #haskell-infrastructure 
13:51:13 <davean> I don't know that there isn't just a queue ATM or I'd make it a higher priority
13:51:34 <davean> Hum, thats old enough there is an issue
13:51:43 <davean> We probably forgot to update the GHC available
13:57:39 * hackage tasty-dejafu 0.7.1.0 - Deja Fu support for the Tasty test framework.  https://hackage.haskell.org/package/tasty-dejafu-0.7.1.0 (barrucadu)
13:58:24 * hackage hunit-dejafu 0.7.1.0 - Deja Fu support for the HUnit test framework.  https://hackage.haskell.org/package/hunit-dejafu-0.7.1.0 (barrucadu)
13:58:57 <lionrouge> hi again
13:59:05 <lionrouge> i can't install ghc-mod under Windows 10 with cabal
13:59:12 <lionrouge> here is the output: https://dpaste.de/4jGa
13:59:22 <lionrouge> how can i fix it?
14:00:37 <lionrouge> can non-ASCII letters in cabal config path strings be the issue?
14:00:47 <glguy> lionrouge: You'll have to install an older version of GHC
14:00:58 <glguy> rejecting: base-4.10.0.0/installed-4.1... (conflict: ghc-mod => base<4.10 && >=4.6.0.1)
14:01:21 <lionrouge> can i downgrade somehow or i need to download it manually?
14:01:46 <glguy> Whatever you did to install GHC, you'll need to do that again for the 8.0.2 version
14:02:21 <lionrouge> i see. thanks
14:04:39 <lionrouge> is release 8.2.1 significantly better than 8.0.2 ?
14:06:00 <mud> A pretty decent amount, but it doesn't matter much usually.
14:06:22 <lionrouge> ok
14:08:33 <lionrouge> i'm new to the language. Heard about it a lot and recently (after watching some Bartosz Milewski videos) made up my mind to try it. Could you recommend some books/online resources apart from the official site?
14:10:17 <mud> http://haskellbook.com/ is the book I wish I could have used to learn haskell. And I find the 'stack' tool very useful: https://github.com/commercialhaskell/stack (for example it can manage GHC for you, so your previous question wouldn't really have come up)
14:10:27 <[exa]> lionrouge: there's "learn yourself a haskell" thing
14:11:07 <mud> https://docs.haskellstack.org/en/stable/README/ is probably a better link for stack actually, my bad.
14:11:15 <[exa]> ( lionrouge: http://learnyouahaskell.com/ )
14:11:25 <lionrouge> [exa], thanks, i saw this book on the shelves
14:12:02 <[Leary]> Learn you a Haskell is entertaining, but it's not worth very much without exercises.
14:12:05 <mud> I really wouldn't recommend LYAH personally. It's fun enough to read, but I've yet to meet anyone who came out of it able to write haskell. There's no exercises.
14:12:07 <[exa]> lionrouge: it's a quick read though, not much examples yeah
14:13:23 * [exa] thinks about hacking together something like 'exercise yourself a haskell for great profit'
14:14:51 <[Leary]> I don't know if it's still a prescribed route, but I just finished CIS194. Seemed pretty good to me.
14:14:53 <Rembane> [exa]: Do it! :D
14:16:54 <beemo[m]> Mud: its the only book i used, and now haskell is my go to language
14:17:39 <exio4> mud: it's a good introduction if you have written in a FP language before
14:18:20 <exio4> mud: I am not saying I could write perfect Haskell after checking it - but it helped me map what I knew about SML to Haskell :)
14:18:41 <benzrf> still, the majority of people asking "how do i learn haskell" do not know sml
14:18:44 <benzrf> so as a default suggestion...
14:18:47 <lionrouge> i like to write in functional style in Python and i played with Clojure before
14:20:03 <lionrouge> what do you think about this? Looks like it has examples in Haskell: https://bartoszmilewski.com/2014/10/28/category-theory-for-programmers-the-preface/
14:20:09 <benzrf> ack!!!
14:20:15 <benzrf> don't try to learn category theory, jeez!
14:20:19 <benzrf> if you wanna learn haskell just learn haskell
14:20:32 <benzrf> also, python cannot write code in a functional style
14:20:40 <benzrf> at least, not in any sense very close to what real haskell looks like
14:20:50 <[exa]> Rembane: What if I start a repo on github and ask everyone to add their favorite exercise, then categorize the exercises so that it roughly corresponds to LYAH, add funny badly drawn pictures and publish the result?
14:20:51 <mud> beemo[m]: Interesting. That's one at least then.
14:21:04 <[exa]> mud: #metoo
14:21:19 <Rembane> [exa]: That sounds like a really fun plan. Do it! :D
14:21:43 <zachk> is there any reason or advantage to use STM if I am only going to have one TVar?
14:21:54 <[exa]> Rembane: Hmm ok.
14:22:12 <mniip> [exa], ooh
14:22:13 <mniip> I would
14:22:40 <Rembane> zachk: Use an IORef until it bites you. :)
14:22:53 <mniip> lionrouge, don't learn CT because haskell borrows some concepts from it
14:23:04 <[exa]> OK let me think a bit about layout
14:23:06 <mniip> learn CT because it's freakin awesome
14:23:10 <Rembane> +1
14:23:19 * benzrf rubs temples
14:23:28 <benzrf> in my "humble" opinion
14:23:33 <mniip> and if you decide to do that don't stop at "programming" tutorials
14:23:47 <mniip> not that these are bad
14:23:54 <benzrf> learning ct before learning about, at the very least, two different types of mathematical structures (e.g. lattices, groups, topological spaces)
14:24:01 <mniip> yes
14:24:02 <mniip> good point
14:24:09 <benzrf> is like trying to learn about haskell monads before learning about any other part of haskell
14:24:13 <benzrf> when your background is in python
14:24:33 <benzrf> and trying to learn ct, without that math background, from looking at haskell
14:24:41 <benzrf> is like trying to learn about haskell monads by looking at python translations
14:25:28 <mniip> in early days my understanding of CT was fueled by linear algebra and basic set theory alone
14:25:31 <mniip> and, well, Hask
14:25:45 <benzrf> Hask is not a category!!!
14:25:55 <benzrf> >:O
14:26:03 <Rembane> benzrf: What?! What happen?!
14:26:14 <EvanR> haha
14:26:16 <benzrf> in order for the statement "Hask is a category" to be coherent
14:26:20 <benzrf> there has to be a thing called "Hask"
14:26:27 <benzrf> there is no thing called "Hask"
14:26:50 <EvanR> "objects are haskell types (?) and haskell functions (?)"
14:26:51 <mniip> no
14:26:56 <mniip> I mean
14:26:57 <mniip> Vect
14:26:59 <mniip> Toph
14:27:07 <hololeap_> it's pretty much just Set with a bottom in every set
14:27:11 <benzrf> no it isn't
14:27:14 <EvanR> what...
14:27:18 <mniip> none of these are called exactly as their objects
14:27:21 <mniip> but rather contractions
14:27:28 <benzrf> http://math.andrej.com/2016/08/06/hask-is-not-a-category/
14:27:33 * hackage hunit-dejafu 0.7.1.1 - Deja Fu support for the HUnit test framework.  https://hackage.haskell.org/package/hunit-dejafu-0.7.1.1 (barrucadu)
14:27:39 <mniip> oh you mean Hask is not a CCC
14:27:41 <EvanR> proof by andrej bauer
14:27:47 <benzrf> no, i mean it is not a category
14:27:54 * hackage tasty-dejafu 0.7.1.1 - Deja Fu support for the Tasty test framework.  https://hackage.haskell.org/package/tasty-dejafu-0.7.1.1 (barrucadu)
14:28:04 <mniip> hmmm
14:28:10 <mniip> okay
14:28:29 <hololeap_> you can model anything in Set in Hask... afaik
14:28:37 <benzrf> if you start reading that post, i recommend finishing it before saying anything more about this
14:28:40 <mniip> if we consider the category of total Hask
14:28:50 <mniip> and view it through the lens of fast and loose reasoning
14:28:50 <EvanR> by trying to say hask is set with bottoms, you run into the first set of problems
14:28:53 <mniip> which is morally correct
14:28:53 <EvanR> breaking the laws
14:28:58 * benzrf rubs temples
14:29:21 <zachk> rembane, it's going to be multithread/multiple cloud haskell processses, so I think it could bite me in the ass very quickly
14:29:27 <monochrom> Are your temples touch pads? :)
14:29:37 <benzrf> yea
14:29:48 <EvanR> hololeap_: a model of set theory in haskell, i would like to see that
14:30:01 <benzrf> mniip: like i said, finish reading the post >:( https://i.imgur.com/xOJBMUq.png
14:30:24 <Rembane> zachk: Sounds fun. Go for STM.
14:30:34 <EvanR> i flame posted that andrej post in here once, nobdoy was amused
14:30:41 <benzrf> ~_^
14:31:19 <hololeap_> benzrf, i highly recommend bartosz milewski's youtube/blog on cat theory for programmers
14:31:41 <benzrf> i am terrified of looking that up
14:31:54 <hololeap_> whatever, your loss
14:32:05 <mniip> in *my* "humble" opinion
14:32:15 <benzrf> wait, do you mean that you think it's good and proves me wrong, or that i would benefit from watching it?
14:33:33 <mniip> personally for me the whole "CT for programmers" has been limiting my exposure to real CT too much. Reading an actual CT textbook made me realize how deep the rabbit hole *actually* goes and opened a whole new world before me
14:33:34 <monochrom> 10 to 1 it's tangential preaching
14:33:43 <nshepperd_> Couldn't you fix "undefined . id /= undefined" by defining . to be strict instead of lazy
14:33:51 <benzrf> nshepperd_: then that's not haskell
14:33:53 <benzrf> kind of the point
14:34:16 <benzrf> oh, well, wait i see what you mean
14:34:16 <mniip> nshepperd_, strict in what
14:34:18 <nshepperd_> Sure it is
14:34:22 <benzrf> give me a moment to consider that
14:34:29 <mniip> nshepperd_, I'd like to see your definition
14:34:41 <exio4> mniip: what CT books have you checked?
14:34:55 <mniip> exio4, I'm reading Mac Lane atm
14:35:18 <nshepperd_> mniip: f . g = f `seq` g `seq` (f Prelude.. g)
14:35:20 <benzrf> but yes, broadly speaking "category theory for programmers" is basically "monads for python users"
14:35:24 <exio4> ah, I started it but it was quite out of reach when I checked it
14:36:04 <fishythefish> mud: a little late, but I think LYAH was the only book I read when I was learning Haskell as a beginner. (All the book-reading since then has mostly been for evaluation rather than learning.)
14:36:06 <mniip> exio4, I can safely say I understand at least a third of the tasks/examples
14:36:10 <mniip> and that's enough to click for me
14:36:48 <hololeap_> mniip, for me, i need the bridge from what i am comfortable with (programming) into the scary world of math
14:36:52 <EvanR> i dont really understand how second paragraph of section 1 here makes Hask into a categry https://wiki.haskell.org/Hask
14:36:53 <mniip> and it even made me research tangential topics better
14:37:08 <fishythefish> that said, the book did very little for me other than spur me on to find better resources
14:37:14 <mud> fishythefish: I guess I'll have to word that differently next time. I still don't think it's a good idea though, would you really recommend that route? (just out of curiosity)
14:37:19 <EvanR> last paragraph of section 1
14:37:23 <fishythefish> mud: I would not
14:37:26 <mud> Ah
14:37:26 <EvanR> only paragraph?
14:37:38 <mniip> one exercise in Mac Lane asked what is the center of the Grp category, had to reach out to my group theorist friend
14:37:42 <fishythefish> I only recommend it when someone needs something bright and colorful to reassure them
14:37:50 <mud> Nice
14:37:52 <benzrf> hololeap_: if the world of math is scary for you, category theory is probably not useful to you
14:37:57 <mniip> now I know that all subgroups of free groups are free
14:38:11 <benzrf> welllllllllllllll.............. there are quibbles one could make with that statement
14:38:22 <benzrf> but i will at least claim that it's at *least* a half truth
14:38:23 <hololeap_> benzrf, i'm not particularly interested in your opinion of what is or isn't useful to me
14:38:48 <mniip> wow that turned personal real quick
14:38:51 <benzrf> :x
14:38:52 <fishythefish> "if the world of math is scary for you, category theory is probably also scary for you"
14:40:06 <TMA> category theory is scary even if I am rather fond of other parts of mathematics
14:40:42 <fishythefish> i have to temper my desire to learn all of CT with my knowledge that i can only understand so much of it at present
14:41:10 <fishythefish> nearly 4 years of grad level math, then 2 weeks into a course on homological algebra taught me i knew nothing about topology T_T
14:41:17 <benzrf> haha
14:42:01 <hololeap_> what i meant to say was simply that it is taking me time to adjust to the reading of symbols in the way that a lot of "high-level" math presents them
14:42:18 <hololeap_> it's hard to dive into a textbook, though i have tried
14:42:28 <fishythefish> hololeap_: this is something that only gets better with more exposure to math. ncatlab is particularly intimidating
14:42:45 <mniip> fishythefish, yeah topology amazes me by how little I actually know after learning so much
14:43:02 <fishythefish> CT is also easier to understand when you have lots of examples of categories you're already familiar with, and -- surprise -- this comes from exposure to a variety of math
14:43:06 <hololeap_> algebra: chatper 0 was recommended to me, and i got only throught the first chapter. but maybe i'll take another stab at it
14:43:14 <fishythefish> mniip: one day i will go back and learn what sheaves do
14:43:26 <mud> fishythefish: Yeah, personally I don't think I know enough other math deeply enough for CT to be interesting to me.
14:43:29 <mniip> sheaves are just a short word for something innit
14:43:33 <benzrf> all i mean is - learning category theory without knowing a bunch of other math - is kind of like learning to use git when you only ever write single-file 100-line programs
14:43:54 <hexagoxel> can i prevent cabal from linking in parallel without also forcing -j1 on the rest of the (new-)build ?
14:43:54 <fishythefish> mniip: "X is just a short word for something innit" is gonna be my standard approach to math vocab from now on
14:44:00 <hololeap_> i never said i wasn't trying to learn other branches of math too
14:44:07 <mniip> no like
14:44:09 <mniip> one sec
14:44:28 <mniip> oh right
14:44:31 <mniip> I was thinking presheaves
14:46:05 <hexagoxel> (currently, when my library changes, all tests in the test-suite are rebuild, in most cases doing only a re-link immediately. and each needs more than 1GB of ram. in parallel, this results in quite the burst of memory usage.)
14:46:08 <benzrf> hololeap_: well, i just mean that *until* other stuff is less scary, you probably won't get all that much out of ct
14:46:11 <fishythefish> like, i get that a presheaf is a functor respecting inclusion of open sets and a sheaf is a presheaf that gives you locality and gluing, but i've never really grokked them enough past that point to continue CT with them
14:46:14 <mniip> contravariant functor from the poset category of open sets
14:46:36 <hololeap_> i really meant "scary" in a sort of tongue-in-cheek kind of way
14:46:42 <benzrf> well...
14:46:45 <benzrf> alright :P
14:46:58 <benzrf> mniip: well, more generally 'presheaf' is a term for just a contravariant functor to the category of sets (or even more generally, something else fillign in for the category of sets)
14:47:34 <benzrf> one of the key points of presheaves is that they can be interpreted as sort of a "virtual object" in the domain category
14:48:20 <benzrf> if i have a presheaf F on a category C, i can imagine that i have a "virtual object" O in C determined by F, where
14:48:51 <fishythefish> hololeap_: IMO, it's possible to get some value (or at least something ranging from interest to understanding) out of CT as "just" a Haskeller
14:48:52 <nshepperd_> An alternative to making . strict is to realise that without seq the only way to observe a function being bottom is to apply it to something, and therefore to define a subset of haskell where a) seq is removed and b) any function value that is bottom is magically replaced with const undefined. Then we have undefined 
14:49:13 <nshepperd_>  undefined . id = undefined, again
14:49:13 <benzrf> for any object X of C, Hom(X, O) is given by F(X), and for f : A -> X, F(f) is composition of f
14:49:14 <fishythefish> you can learn about the "projections" of CT concepts onto Haskell and read about how they're useful or can speed up your code
14:49:26 <fishythefish> they probably won't be any more illuminating than that
14:49:28 <nshepperd_> But strict . seems simpler
14:49:57 <fishythefish> to appreciate the full generality, you need to be aware of other categories, particularly ones where these "projections" are different
14:50:08 <benzrf> if this "virtual object" actually exists in a certain sense, the presheaf is "representable"
14:50:22 <fishythefish> and to appreciate those categories, it's important to know about the broad range of structures the concept of a category unifies
14:51:03 <benzrf> viewing a category from the outside, the morphisms and objects have no "internal structure", so the only things we can think about are how the morphisms compose and which morphisms go from one object to another - it doesnt matter what the morphisms "are"
14:51:11 <mniip> right
14:51:32 <mniip> I have a general understanding of that and it feels like a point that is often not stressed enough
14:51:34 <nshepperd_> (in other words, remove seq and identify undefined :: a -> b with const undefined :: a -> b)
14:51:58 <benzrf> if i have an object O, i can get a presheaf F given by that object which really does send F(X) := Hom(X, O) and F(f) = (f .)
14:52:17 <benzrf> and the key thing to realize is that
14:52:31 <benzrf> given the point i just made about the unimportance of what morphisms really are -
14:52:32 <hololeap_> i've gained a lot of intuition for haskell from learning about nat-trans and monads in CT. the yoneda lemma helped me understand the Cont monad. i'm still trying to wrap my head around comonads and cofree comonads
14:52:41 <benzrf> *all of the structure of O is given by this presheaf F*
14:52:59 <benzrf> _even_ if we ignore the fact that the elements of the sets "really are" morphisms
14:52:59 <fishythefish> benzrf: whoa, I really appreciate this "virtual object" explanation
14:53:02 <benzrf> :)
14:53:21 <benzrf> so a representable presheaf is, to be specific, one which is naturally isomorphic to a presheaf induced in the above manner
14:53:34 <fishythefish> this is one of those things that i've only seen manipulated formally, but i've never had intuition as to *why* presheaves should be so fundamental
14:54:54 <benzrf> the above way of getting presheaves from objects is the "yoneda embedding"
14:54:59 <fishythefish> mniip: btw, how did you prove Nielsen-Schreier? I remember having to prove it algebraically in my group theory courses, but the only proof I really remember/enjoy is using fundamental groups of covering spaces
14:55:10 <mniip> I er didn't prove it
14:55:18 <mniip> merely used it in the proof
14:55:36 <mniip> I'm not that great at group theory
14:55:47 <benzrf> the yoneda lemma essentially states that thinking about the presheaf category as a kind of "completed" version of C works pretty well
14:56:14 <mniip> my group theorist friend claims that the course I've had at my uni "isn't even just the basics"
14:56:16 <fishythefish> heh, "now I know that all subgroups of free groups are free" <-- i'm used to s/know/have proved that/
14:56:31 <fishythefish> mniip: don't worry, that continues at all levels in my experience
14:56:34 <mniip> fishythefish, yeah I too like proving thingd before knowing
14:56:47 <benzrf> part of the statement of the yoneda lemma is that the yoneda embedding is full and faithful - i.e., the full subcategory of representable presheaves is equivalent to C
14:56:47 <mniip> but this is way over my head I think
14:56:58 <benzrf> so working with representable presheaves is exactly the same as working with C itself!
14:57:18 <mniip> benzrf, I'll need to reread that tomorrow...
14:57:31 <benzrf> this is the formal statement of the idea that the presheaf for an object really does capture everything you want to know about it
14:57:34 <benzrf> hehe ok :)
14:57:34 <fishythefish> mniip: nah, if you don't mind reading a couple chapters on algebraic topology, it's not bad at all
14:57:39 <fishythefish> the subject itself is pretty cool
14:57:50 <mniip> algebraic topology? yes
14:58:05 <mniip> like I said it amazes me
14:58:15 <fishythefish> benzrf: "working with C itself" <-- I did a double take
14:58:25 <benzrf> oh?
14:58:29 <mniip> hahaha
14:58:32 <benzrf> oh
14:58:34 <benzrf> lmao
14:58:34 <mniip> I'm going to quote that out of context
15:01:34 <benzrf> oh, and re: wikipedia claiming that the yoneda lemma is "a vast generalisation of Cayley's theorem from group theory"
15:01:39 <benzrf> roughly speaking:
15:01:54 <benzrf> all you want to know about an element of a group is the permutation it induces on the rest of the group
15:02:07 <glguy> There's a whole IRC channel for category theory, too
15:02:23 <benzrf> then, in particular, you can embed any group as a subgroup of the group of permutations on itself
15:02:30 <benzrf> glguy: er right let me just finish this thought sorry
15:02:41 <[exa]> mniip, Rembane: so if you have exercises please push them all here https://github.com/exaexa/EYAH
15:02:55 <Rembane> [exa]: Sweet! Thank you!
15:02:58 <benzrf> by analogy: all you want to know about an object of a category is what the morphisms involving it are and how they compose with other morphisms
15:03:09 <[exa]> I'll add some auto-formatting to make a github page or a tex book tomorrow
15:03:18 <mniip> ooooh
15:03:20 <benzrf> then, in particular, you can embed any category as a subcategory of the category of "that sort of data" on that category
15:03:22 <mniip> that explains it perfectly
15:03:25 <benzrf> i.e., the presheaf category
15:03:29 <benzrf> alright done with the CT in #haskell
15:03:53 <benzrf> bbl
15:05:35 <[exa]> Rembane, mniip: also feel free to add other directories than lyah (not quite sure what to do with directories yet, will see.)
15:07:05 <Rembane> [exa]: Roger that.
15:10:43 <abhiroop> Are there any papers on the internal implementation of the parallel library by Simon Marlow
16:18:20 <lmapper> hi, I'm wondering if there's an easier way to work with certain data values without having to pack and unpack... stripped down example here
16:18:24 <lmapper> http://lpaste.net/360387
16:18:47 <lmapper> in the "eval" function, I'm unpacking EString and EInt
16:19:22 <lmapper> but I was hoping to be able to work with the underlying String and Int values more smoothly
16:20:27 <lmapper> I tried deriving Functor and Foldable, but still coming to grips with how to use them
16:21:05 <lyxia> EValue a   <- a does not appear in any constructor, so it's useless.
16:21:27 <lyxia> I mean, phantom types in general have uses, but not here.
16:21:51 <lmapper> Yeah, I added that when I was experimenting with deriving Functor
16:22:01 <lyxia> eval (eInts -> Just ev)   is the same as   eval (EInt ev)
16:22:32 <erisco> who needs terms anyways
16:22:46 <lyxia> oh wait no
16:22:54 <lmapper> nah, it's a list
16:23:14 <lyxia> I see, I misread "eInt" instead of "eInts"
16:23:42 <lmapper> I'm most interested in knowing how to simplify these parts: return $ EInt . sum $ eInt <$> ev
16:24:19 <zachk> lmapper, what will eval do if you have EInt and Estring's mixed in the input type [Evalue] ?
16:25:25 <lmapper> throwError ( I have another setup with ExceptT in another file catching the errors, this is just a stripped down example)
16:26:16 <lmapper> I know it's not the best way, but I struggled with another issue and ended up settling with this kind of setup
16:26:30 <lyxia> lmapper: instead of doing one check and one map, you could just do a single mapFilter
16:28:03 <lmapper> lyxia, are you referring to something in the "eval" function?
16:28:03 <zachk> lmapper do you even need EInt's and EStrings being together in the same datatype if you only want lists that are exclusively made of all of one or the other?
16:29:46 <lyxia> lmapper: yes, in each of the first two clauses of eval you are doing one filter (eInts, eStrings) and one map ((<$>))
16:30:10 <cetchmoh> what is the most elegant way to find out what is imported from an unqualified import statement?
16:30:14 <lmapper> zachk, I think so, this is just a simplified example, EValue has several other constructors in the real project. And, there will also be several variations of the "eval" function, where the lists are heterogeneous
16:30:24 <cetchmoh> besides looking up the api-docs
16:31:48 <lyxia> lmapper: http://lpaste.net/360388
16:32:07 <lmapper> is there a way to hide the wrapping and unwrapping behind some kind of "machinery"?
16:33:03 <Axman6> as with many problems, the answer may be lens
16:33:32 <lyxia> lmapper: you could have eInts and eStrings do the unwrapping since by the time you get a Just you know they're all the same type
16:33:37 <lmapper> Axman6, I have not gone down that rabbit hole yet
16:35:04 <lmapper> in this example, it's homogenous, but in other "eval" functions there will be a mix. I just happened to use view patterns here to check
16:35:29 <Rembane> \o/ GADTs \o/
16:36:18 <lmapper> Rembane, I have experiemented, but not very comfortable with GADTs yet
16:36:43 <Axman6> yeah GADTs solve a lot of problems here
16:37:17 <lmapper> I have thought of restructuring to use Int, String, etc, and create a typeclass "Evaluable"
16:37:24 <lyxia> lmapper: you could still have functions that handle each clause while doing all the unwrapping.
16:37:25 <Rembane> lmapper: IMO, they are really nicely implemented in Haskell, so they give a lot and aren't too terrible to work with.
16:37:34 <lmapper> but couldn't really get it to work
16:38:56 <lmapper> I can give GADTs another try then
16:38:59 <lyxia> lmapper: why not push sum and mconcat into eInts and eStrings
16:39:12 <Welkin> wtf are eInt and eString?
16:39:19 <Welkin> a new internet buzzword?
16:39:35 <lmapper> Welkin, just something I quickly wrote to pull the value out
16:39:49 <lmapper> a terrible partial function
16:40:54 <lmapper> lyxia, sum and mconcat are just examples, I'm not really going to be only summing and mconcat in the real project
16:41:37 <lmapper> my big question was regarding the wrapping and unwrapping with eInt and EInt
16:42:21 <lmapper> I was hoping there was a way to structure where I wouldn't need to wrap and unwrap while working with this kind of data structure
16:43:18 <lyxia> lmapper: yes but my point is that you could both check and unwrap and everything all at once instead of separating eInts on one side and (sum $ eInt <$> ev) on the other.
16:44:21 <lyxia> eInt and eString wouldn't be needed, because eInts and eStrings already work by pattern matching.
16:52:45 <lmapper> lyxia: thanks, I tried another test example and found pattern matching while unwrapping makes it more sensible
16:53:53 <lmapper> how might I use the "Foldable" instance that's automatically derived?
16:54:26 <Welkin> foldMap
17:20:50 <lmapper> :q
17:50:07 * hackage config-parser 1.0.0.0 - Parse config files using parsec and generate parse errorson unhandled keys  https://hackage.haskell.org/package/config-parser-1.0.0.0 (BenHamlin)
17:55:23 <dmwit> mniip: loved it
17:55:41 <dmwit> mniip: I will happily recommend you if you decide to apply to Galois. =)
17:56:28 <slack1256> I wonder if a tool that given a function signature the depends on many type classes, gives you possible instantiation for the types of that function
17:56:38 <slack1256> or does hoogle, ghc-mod already do that?
17:57:11 <dmwit> :i ClassName will tell you about in-scope instances
17:57:48 <dmwit> I don't know of a tool that finds the intersection of this information, though.
17:58:29 <dmwit> Like, I don't know of a tool that can take `(Num a, Monoid a)` and spit back `Sum` and `Product`.
17:58:34 <slack1256> yep, but usually I got code line (MonadCatch t, Run t ~ Maybe (), MFunctor t) and have to check too many docs to find a candidate
18:13:49 --- topic: 'https://www.haskell.org | https://wiki.haskell.org/IRC_channel | Paste code/errors: http://lpaste.net/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D | https://www.reddit.com/r/haskell | Admin: #haskell-ops | Offtopic: #haskell-offtopic | https://downloads.haskell.org | https://summer.haskell.org Summer of Haskell 2017'
18:13:49 --- topic: set by mauke!5lzdiZJQGk@p3m/member/mauke on [Mon Jul 31 05:45:11 2017]
18:13:49 --- names: list (clog_ WzC levex amer oisdk nenadovic djapo eSVG kuttifunk xcmw nomicflux acidjnk pfurla gtomas nighty- Stanley00 Neomex HMPerson1__ duncan^ woodson slack1256 suls MoarSpaceFi `Guest00000 sword865 uuplusu olligobber floryst mnoonan_ justanotheruser sz0 Jesin fr33domlover mdtusz pera leshow Guest78 jxv mson gawen Pacra L1nk andyhuzhill neoncontrails ChaiTRex Welkin cromachina soniku jcarpenter2 rootnode dan_f ammazza Gurkenglas SummerNinja harfangk YongJoon)
18:13:49 --- names: list (kakashiAL lionelhutz sshack Swizec spietz1 conal machinedgod plutoniix boj durandal1 stevenxl ninedotnine falafel UserOO7 maerwald tsaka_ jkup silver_ hphuoc25 kroogs2 zv nak Wizek_ hiratara darjeeling_ codyw _ashbreeze_ arthurwong codesoup llinguini vegetablien hariel aplainzetakind Maticz yahb crobbins infinisil mniip grumble maomao zero_byte mstruebing [Leary] clog whaletechno pitb0ss Xal ski hc toby__ MP2E AndiK raingloom juhp sleffy jmelesky cschneid_)
18:13:49 --- names: list (zwuggy path[l] zmt00 qmm tac-tics nudgeman AndreasK coot___________ valentinbuza cross raynold atomi replay teddy_error erisco xkapastel xttraces mda1 zaquest SaleemPheku jfredett jeltsch SuprDewd TipsyMe yago {emptyset} quobo nurupo hexfive kculpis aberrant aarvar xinming sdothum minn hucksy Ulrar dddddd barcabuona pavonia jackhill Lokathor_ connrs nahra Mistv[m] Rubas[m] Guest291964[m] eyenx rprospero[m] Vipernet1220[m] Guest312594[m] caimbeul[m])
18:13:49 --- names: list (frunobulax[m] Bimmie[m] rimon[m] sssi1ver[m] scrypso[m] voidanon[m] hesiodos[m] jnonpony[m] Guest1573[m] seto[m] packetbiompm[m] yaspoon[m] ticao[m] Monad[m] Verandetten[m] ptek[m] Litom[m] thebeast[m] zmre[m] lixiang4u[m] KevinMGranger bustillo[m] mrhania[m] mark_c akshay7777[m] M-HirmeS maverickwoo[m] mk[m] Elorm[m] kwaku[m] KENNYNR1[m] littlejay[m] sh4pe[m] am2on reconmaster[m] porcow[m] joakimf95[m] fxk[m] fgaz[m] PatrickM[m] magog[m] etXzat[m] grahf[m])
18:13:49 --- names: list (stellis[m] himmAllRight[m] prot[m] Andry976[m] BartGroeneveld[m mapleleaf[m] M0xfiras[m] ElliotKiyomizu[m c0ff33[m] matheusrv[m] M-herah Jasonjunsu[m] SijmenSchoon[m] kkr[m] km42[m] JohnnyReb[m] shekel[m] asthma[m] nine-h[m] Guest340521[m] caro401 stevendai[m] guest236[m] mrgraffe[m] psan[m] djquant[m] mrdaak[m] guest121[m] toa[m] dirb guest69[m] razvanc-r[m] testtt0x11[m] Zarthalan[m] ArrayWindrunner[ sudom0nk[m] kebertx[m] j0ni[m] pacmansyu[m])
18:13:49 --- names: list (DavesTestingAcco a89lk[m] mith[m] ayylmaoo[m] usedname[m] Mougan[m] boash[m] shsnthstnhs[m] sphalerite teuffy[m] Reyu[m] dbramucci[m] srenatus Shaunthesheep[m] sgoody[m] superpat[m] polux[m] magnap Scapin[m] gutigen[m] Deleh[m] howsiwei[m] riaqn burgundy[m] marmite[m] wizzup[m] Niboor[m] SansFr[m] felipeac[m] ajtowns[m] nimbus[m] minhnhdo[m] jvalleroy[m] M-x-matrix[m] softashell rcat[m] oozz[m] tobim[m] rainbyte[m] Luguber[m] testingriotnmatr kosmikus[m])
18:13:49 --- names: list (ramirezD[m] goolord[m] thekyriarchy__ cuddly[m] aminos[m] ub[m] Makinit[m] Nerka[m] vrnithinkumar[m] avatias0[m] siddhanathan[m] octalsrc[m] chocowheel[m] grdryn meinashi[m] Overload[m] TuXic[m] Ed2bno1[m] Cadey[m] antiless[m] Sasasw just_test1ng[m] ya-alex[m] LangeOortjes[m] MarkusK[m] unclechu crapman[m] pedroteo[m] adampaigge[m] M-kitsune Courage[m] devpav[m] hugogomes[m] WolfLightning[m] jsonhigh[m] h_ndrik[m] Adau[m] chominist[m] rizo[m] fonadius[m])
18:13:49 --- names: list (peel[m] TimWolla[m] schum[m] moka[m] superobserver[m] sitischu[m] apardo[m] Heino[m] narispo[m] Naughtmare[m] emme[m] levzhazeschi[m] dtpop[m] Frytka[m] adziahel[m] ttk2[m] lucnx[m] chaseroycroft[m] Michi[m] JHBrannam[m] gylpm[m] joncfoo[m] netsu[m] Akito[m] mlainz[m] Squidnyan[m] wisn[m] pyrtheibarit[m] Ubiquitous[m] intheclouddan[m] bramvdbogaerde[m XertroV[m] ThousandLions[m] FederalRick[m] abel-abel[m] okkk hdurer[m] d-0504[m] beemo[m] mtncoder[m] M-rgh)
18:13:49 --- names: list (bbslclubbin[m] laaksoan[m] Barnabas[m] hiq[m] peddie[m] ycy[m] trevorriles[m] jacobleach[m] ltq520[m] ByteEater[m] elpfen[m] roninkaizen[m] ninegua[m] dkellner[m] xffox[m] AX3L[m] jhb2345 rydia5[m] PifyZ[m] fbreitwieser[m] MufeedAli[m] psYchotic[m] dpacbach[m] absurd[m] chuzz[m] saci[m] puminya[m] synopz[m] talesmantovani[m CryptoCalsius[m] Flecheck[m] zhangjiji[m] M-ms lkh[m] Maikel_Experius[ pingfreud[m] LucasFrancesco[m daoo[m] lonokhov[m] el_tejon[m])
18:13:49 --- names: list (rakete redviking[m] cwgoes[m]1 georg3[m] ngross[m] noxeternae[m] gregoire[m] ljagged[m] yassineoualmakra Dako300[m] thisLight[m] mrhunky[m] towaii[m] ma-ku[m] fib11235[m] huda[m] testtt55[m] asm[m]1 chaetopterus[m] NickSeagull[m] innaytool[m] naviknair7[m] riotartist[m] closures999[m] toumi124[m] xeel[m] M16_29[m] romanzolotarev[m seizo[m] nh2[m] NickHu1 spotter[m] M-whoops kimchi[m] kilian[m]1 vitamin-q jomari[m] Novitsh[m] yashi[m] charlag[m])
18:13:49 --- names: list (phil_frontal[m] phittacus bgrayburn[m] ketanhwr zukonake[m] mad[m]1 sebisebi[m] plll[m] masaeedu[m] nullset[m] tibike_m[m] scanleft[m] ddbbuu[m] islamicwarez[m] khac[m] futpib[m] JackM[m] wubbalubbadubdu4 ItevNabdifNi[m] subz[m] apigeon[m] asenski[m] zalipuha[m] stites[m] hotsocks[m] idnar[m] moonrunes[m] puffnfresh aaronc[m] foreseaz[m] m3tti[m] Matthew[m] M-Illandan Rifa[m] strixy[m] etcinit[m] Masaomi[m] Obscurity[m] riadvargas[m] thekyriarchy)
18:13:49 --- names: list (Mcpurplemuffin[m dtcristo trikl[m] TFX[m] zineje[m] Li[m] ElyKar[m] geetam schplaf[m] mossid[m]1 sudoreboot[m] rcg[m] slartibartfast[m wzy8L-B2[m] icen[m] aniketd[m] Alexander_Hansen s0ra[m] SuperW[m] thejonny[m] johnwhitlow[m] Jikstra[m] sypwex[m] newman[m] Mike[m]1 tangled_z[m] arslanatajanov[m piluex[m] MikasiCoyote[m] WinterFox[m] Twey dustinm JCGrant[m] Nuva[m] dphabian[m] hakan[m] undu[m] goodboy[m] TylerCecil[m] hpd_m drasich[m] JanPath[m] Aidan[m])
18:13:49 --- names: list (M-kevinliao M-krsiehl zaphar_ps[m] angelbeats[m] rellen M-BostonEnginerd o0o[m] jerin[m] sn[m] sgal[m] scde davidar WilliamHamilton tester668[m] kritzcreek m4sk1n cutie sirius[m] bennofs[m] albertsg[m] wizek[m] davidar_ turt2live MawKKe[m] unlmtd spacekitteh[m] aer[m] aspiwack[m] jmnoz MohdSKhoeini[m] ollieh hendrik[m]1 pellegrino berton freeman42x tfc[m] lysgaard[m] equalunique[m] javjarfer[m] herzmeister[m] M-berdario trevortknguyen[m reactormonk[m])
18:13:49 --- names: list (jyp[m] dt343gs[m] unknownln rexor[m] Snircle bb010g caasih Cerise steshaw a3Dman paraseba Arcaelyx Lord_of_Life uptime beccamorgan awayney spoonm dmiles henriksod tripty swalladge moei banc ironChicken kolko dmj` shutdown_-h_now salva mathu hegge_ anishathalye wladz rntz jared-w opqdonut carbolymer lpsmith gsingh93 majoh_ \u ChongLi Fylwind dpn` lukexi shans_ joedevivo bytesighs bradparker nkpart artagnon customminer strmpnk vikraman quaestor pmade zariuq)
18:13:49 --- names: list (Chousuke_ baetheus NinjaTrappeur dxld CurryWurst lieven Limeth_ vvz tv kini thomaav yaiyan descender fearless_man mikosty wunki noxd niklasb_ hackage Tehnix hurtsi brisbin_ pacak tek0_ CindyLinz bartavelle ess_sing x1n4u Bane^ khisanth_ Bashmetim Gabemo tg joehillen amerlyq rembo10 Oipo srhb _flow_ absence mjo carc Majiir Amadiro hsyl20 mou liyang_ otto_s_ cheshircat_ cynick_ eL_Bart0- thunderrd WarzoneCommand padre_angolano rcat Voldenet lkolstad bengt_)
18:13:49 --- names: list (lavalike milesrout Guest68998 perrier-1 polman theDon crosleyt infinity0 poga jzeus isenmann ck_y felixsch__ bbielsa Squarism nakal vaibhavsagar lagothri1 lambdamu byte512 amosbird brynedwards Nd-69-M DTZUZO Jinxit rossberg heurist cheater bydo drewbarbs leothrix acarrico verement anshumanf alveric3 staffehn wedify meck Tesseraction_i taktoa armyriad mzf mandiblegrip dedgrant sagax mkoenig LiaoTao codeshot d6e takitus gehmehgeh nshepperd srainey calloc)
18:13:49 --- names: list (TimWolla max-m pikajude Adeon rblaze ph88^ toure avocado Guest1878 tromp StoneToad Noldorin alx741 valkyr2e canta cods ArneB piyush-k` hanDerPeder ertes guillaum3 Geekingfrog hamishmack karshan spion revprez toppler cgfbee RGamma unyu jchia theorbtwo meinside nonzen Fairy hydraz treehaqr revprez_atlanta mendez tusj renzhi srdqty jrabe Sgeo coeus kefin DDR sbjorn juri_ Philonous jdnavarro dsfox hrnz Happyfeeet DTZUZU S007 obiwahn quelqun_dautre tctara)
18:13:49 --- names: list (Velpoman ianp happy0 slackman phadej earthy remy earldouglas ertes-w Lauda Benzi-Junior madknight castlelore wedens alexbiehl reallycooldude philosaur stefan-__ uwap henrytill nshepperd1 armlesshobo xa0 remexre procgen blackdog brixen dolio bitemyapp idupree cetchmoh Mikan isaac__ byorgey hanna barrucadu tomku ensyde mrenaud`` urdh soncodi greeny Blkt Natch Axman6 greymalkin mak` Younder quicksilver jrslepak aweinstock beerdrop emmanuel_erc m0rphism bgamari)
18:13:50 --- names: list (dcoutts mbrcknl_ darthThorik fuziontech iravid gleber_ mindtree cgag Bigcheese jamiecook_ petermw bonz060 ycheng fakenullie Adluc teej cdornan_ Meow-J bgyss cstrahan lopex simony sa1 feltnerm sdemos rann machbio mpickering yrid adelbertc wavewave yaknyasn TyOverby__ iphy tabaqui foolswood fxrs_ aijony niHiggim__ tomaw jzl Jello_Raptor dibblego johnw cyphase nerteren orion sethetter Cale tjbp usrthree mikedlr atk fall_ statusbot flori k jokester SCHAPiE)
18:13:50 --- names: list (marens Robin_Jadoul Alchemical sqrt2 ikopico michalisko shikhin Someguy123 Zowlyfon Akii dredozubov markhuge pasukon bus000_ Logio ninegrid Maxdamantus psychicist__ AntiSpamMeta cpup etiago sw1nn catsup raatiniemi jounaz^__ Foritus kensan asjo ryan_vw avn aminb alexelcu Randy matthavener Hafydd revprez_yk cjwelborn giraffe dqd nimbleark DoubleJ felixonmars vivek troydm nilOps higherorder ksj otulp xnyhps remix2000 Immune ynezz RayNbow`TU ericsagnes lispy)
18:13:50 --- names: list (bollu mivael_ pita sigmundv_ valdyn richi235 besenwesen kuchi Tintle Boreeas Ranhir srk emerson ego Sigyn eagleflo kuno Harzilein anhduy hpc rzhanka m4lvin sdrodge Jon Zialus Wizek dandan86 kshannon athan phryk g2` ssedov lines jakutis buoto revprez_stg revprez_anz electrostat runawayfive miklcct @glguy timothyh monochrom R0b0t1` magicman reu Pilfers heinrich5991 nullifidian fugyk mceier hvr ralu JoelMcCracken Ewout karls Unhammer PsyDebug rotaerk andyo)
18:13:50 --- names: list (Igloo m1dnight_ ggVGc geppettodivacin xaimus Meanirelli robogoat Flonk schaeferpp buhman Enigmagic baweaver Eagle_Erwin milli dysfigured amx inr thallada _cyril_ Frankablu cesardv OnkelTem oherrala `0660 a_t_ aib raid Taneb DigitalKiwi mountaingoat odamn martingale ekr wagle peterhil gnusosa M4GNV5 noam__ Ankhers luigy ccase tokik tippenein niklasl hiptobecubic qzo nshepperd_ Guest98560 betawaffle fnurglewitz zeroed kav marienz simon TMA rightfold tnks)
18:13:50 --- names: list (chirpsalot Chobbes jgornick Cheaterman LnL mattp_ ctag sdhand ft Neo Arguggi jrm benana koz_ vimto Vorpal raindev jchia_ oh_lawd MindlessDrone sujeet joncfoo cpape dschoepe angular_mike liste dogui bsima erg newsham rwarfield albel727 oberstein jtcs alsoStevenXL centril jdevlieghere chrissl slester runde polux36 anoe NocnaShada Sose tsani brent80_plow bs syamaoka geal reinh1 RazorX HalfEatenPie fairfieldt edran tolt Kneiva lyxia drdo NemesisD pikhq mulk)
18:13:50 --- names: list (Burnout641_ jamiis_ [exa] ramatevish c_wraith aidecoe Vq Tspoon_ amuck mitchty jaargon Ornedan clever jstolarek jix thoros Hijiri jol andjjj23 diskie dysfun benzrf sleepynate catern fergusnoble prooftechnique przemkovv noctux joeyh fredsir Gothmog_ dunj3 ircbrowse magnuson przembot MitchW mk-fg mnoonan gabiruh wilx __main__ Tuplanolla ManiacTwister a3f ncl28_ [df]_ butterthebuddha Dykam swhalen statusfailed dmwit arw liff hive-mind emmflo kwantam pdxleif)
18:13:50 --- names: list (dilinger codebje orzo acro DustyDingo xtore Xnuk seliopou coup dminuoso kaffepan1a iross_ threeve_ ghostyyy dsal trosa pyrtsa n3parikh Raptor8m3 drcode gspia cpallares prg318 amiri ggherdov johs jonrh thi_ SolarAquarion Tristan-Speccy elvishjerricco Cthalupa twopoint718 iliastsi ljhms ynyounuo dtulig mikeplus64 gothos jameseb andromeda-galaxy Ferdirand koala_man Drezil_ harmaahy1je sjl_ hsiktas metalrain_ Argorok vodkaInf1rno deba5e12 Athas Xion_ solarus)
18:13:50 --- names: list (phaazon noplamodo tinco Paks capisce ClaudiusMaximus tolt_ CuriousErnestBro Intensity bendricklamar oleks nek0 lassulus Takumo marble_visions Lierdakil jle` ahihi hiredman wtw mearnsh trcm Strix echoreply divVerent scopedtv kgadek chrzyki Reisen burp jinblack bbaren fluxit iw00t Wamanuz2 datajerk APic rbocquet rom1504 Deewiant TallerGhostWalt ernst garphy`aw hodapp ij bananagram naudiz le_jonge scav xpoqp adamCS joachifm_ bjobjo numberten Clint mxf)
18:13:50 --- names: list (SpaceKni1ht posco bno2 anelson xxpor japesinator_ akermu LeaChim navilan eddsteel kloeri __name__ sanitypassing flebron ianconnolly ocharles ixian tazjin Jonno_FTW linduxed nwf nekomune nathyong tomus destiny_ petercommand Rembane agrif tsahyt yarou aatxe ahf_ fgaz malthe jlouis implementation_ M2tias mrd SAL9000 lukky513 wizonesolutions codedmart OliPicard amatecha seccus trig-ger angerman spicydonuts zpconn__________ lumimies mkurkov_ lexi-lambda twold)
18:13:50 --- names: list (monad_cat kyagrd andrew_n_ dgonyeo solidsnack andreypopp sclv hansihe rgrinberg Ober eacameron dstockwell nelll dgpratt dumptruckman huonw solatis cschneid acfoltzer akemot bogdanteleaga RevJohnnyHealey heath jdt malt3 runeks oldsnakey ReinH Scorchin carter nbouscal ebutleriv kipd cansis capicue niveus Tritlo gridaphobe avdi prizim ephemera_ Xorlev zmanian _6a68 SegFaultAX zymurgy nopf Warrigal tabaqui1 zenzike MagneticDuck kapu cchalmers texasmynsted)
18:13:50 --- names: list (cocreature geekosaur chriswk langkid1 CARAM___ johtso paf31 ericbmerritt_ Bengi jml stig stasku mbrock baamonde pchiusano Tallenz JSharp lynn prefork gornikm AlainODea AWizzArd logcat kipras feepo nille {AS} twomix stephe SolitaryCypher bind scinawa antismap joeytwiddle platz junktion bluepixel dersquisher pranz stux|RC julmac xplat vfs raek tharper_ rizary jw358 sbrg SlashLife relrod zgrepc si14 banjiewen milessabin Cir0X paws_ spinda edwtjo chindy dxtr)
18:13:50 --- names: list (mk_modrzew nyuszika7h admwrd fingerzam verlet64 pikolinosimo leah2 zebrah tumdedum michaelw ptek zerokarmaleft ethercrow pdgwien wrengr_away felixsch_ Profpatsch Klumben grayhatter ftop lambdabot Xe Purlox mitch_ esph vin-ivar ab9rf worch tdammers Nik05 _janne swflint jophish cyberlard arkeet ids1024 nikivi Fubar^ dan64- jbalint mmaruseacph2 wayne riatre marcel Deadhand danielglh abbe mimi_vx alexknvl lukeshu cjay- vqrs nisstyre Forkk mdarse sns cow-orker)
18:13:50 --- names: list (Tharbakim noexcept bencryption no-n WhereIsMySpoon dh lokydor acowley Moyst gargawel stux|RC-only yushyin tzaeru Jaxan Zoddo Ninja3047 zipper PotatoGim Firedancer bsrm Frans-Willem zebr rotty sveit dpanth3r NextHendrix int-e freeside Liskni_si jorj nesqi froztbyte monty ezyang cfoch-al1 raibutera killtheliterate lachenmayer alanz kiboneu kosmikus saftsuse andrewmc1eigh bcoppens minad int0x27h thebnq zekt c-rog pierrot thoradam TabAtkins mlen Guest63586)
18:13:50 --- names: list (thomashoneyman JoJoen jorendorff ijp alp suppi reem incomprehensibly cdal tortal dpepsilon kaol comboy Quintasan x-n2o eikke TommyC rjungemann sm crlane supki ambrosia gareth__ billstclair nemesit|znc edwardk houli micro Saizan z0ttel bod_ wto Unode Ke saurik peschkaj osfameron ahf pfoetchen pelegreno_ pharaun tarcwynne__ Deaddy ephemeron terrorjack caw__ heyj sbauman rodarmor libbyk Willis megaTherion vikram__________ davean thoughtpolice zph bigs bitonic)
18:13:50 --- names: list (edofic tjpeden xplat|work peteretep wyvern jmct S11001001 mbeidler joel135 redcedar KaneTW mantovani pandem GGMethos epta bjs Guest82765 tessier bshelden michalrus mutsig kaychaks Morgawr wamaral klugez beaky bxc peddie SuperTux88 PyroLagus Cathy anderson Sornaensis benonsoftware hongminhee frontendloader Guest18532 dashed defanor mt sdx23 rjeli bwe paroxp dsm__ Niamkik BytesAndCoffee changyj Zemyla gilbertw1 wting fiddlerwoaroof grandy____ niluje)
18:13:50 --- names: list (ryanbooker Kamuela jzelinskie etrepum micmus ongy ventonegro michi7x7 rofer gareth_ jlewis asm89 danzimm twk- StianL xacktm guios kubrat ByronJohnson gesindel exferenceBot intelux_ noobst mystfox integral pleiosaur Fuuzetsu madsj Xandaros da-x hexagoxel Eliel @ChanServ so PHO reptar_ exio4 croben wz1000 mgaare kfish shapr d3lxa suzu Ring0` zachary12 MasseR Biohazard Guest60956 hjklhjklhjkl Desoxy cjh` skeuchel alek Nikotiini EvanR zomg ec2-user_ abra0)
18:13:50 --- names: list (brennie demiurge)
18:28:10 <jchia> debugging question: There are functions in the file containing main. Is there a straightforward way to call them from ghci so that I can test they return value?
18:29:33 <jchia> Found the answer. When I start ghci, it asks me which executable I want to load. If I load the one that I want to debug, I can use its functions.
18:40:58 <slack1256> jchia: also, you can declare you code as a library and only use a stub executable that calls the realmain defined on the library
18:41:11 <slack1256> taht way, you can load as a module the library with the functions
18:43:14 <jchia> OK
18:49:07 <jchia> mutable vector question: In a function, I have an algorithm in ST that makes an MVector of Text a certain size. If any element is not initialized from running the algorithm, the function returns Nothing. Otherwise it returns the resulting (non-mutable) Vector.
18:49:19 <jchia> Right now, I'm making an Vector (Maybe Text) first and then applying sequence on it. Can I do better by working directly on Vector Text (drop the Maybe), using replicate instead of new and catching the exception about "unininitialized element"? If so, how should I catch?
18:49:44 <jchia> f:: SomeType -> Maybe (Vector Text)
18:50:23 <woodson> Hi everyone, what library is mostly used for implementing jwt?
18:50:24 <jchia> Also, what's the difference between new and unsafeNew in Data.Vector.Mutable? What's unsafe about the unsafeNew?
18:50:53 <boj> woodson: jose seems to be maintained quite a bit
18:51:32 <Axman6> "The memory is not initialized."
18:51:58 <woodson> boj: This one https://github.com/tekul/jose-jw
18:52:02 <jchia> Axman6: What exactly does that mean? If I write to an element, does that make the memory initialized?
18:52:06 <boj> @hackage jose
18:52:06 <lambdabot> http://hackage.haskell.org/package/jose
18:52:14 <woodson> boj: The reason im asking is because i remember seeing it also in another package
18:52:18 <Axman6> yes
18:52:41 <slack1256> I would say the unsafe par is about avoiding a copy
18:53:04 <Axman6> jchia: what "initialised" means depends on the definition of basicInitialise from the MVector class
18:53:22 <jchia> Axman6: But I find that I can still get an "uninitialised element" Exception when I use new instead of unsafeNew.
18:53:43 <jchia> So, I still don't know what the observable difference is.
18:53:52 <Axman6> see my comment above
18:53:57 <boj> woodson: i admittedly don't know much else, was researching the same topic myself this week
18:53:57 <Axman6> it will depend on what type a is
18:57:19 <woodson> boj: thanks, since im using servant i have been looking at this https://github.com/haskell-servant/servant-auth but it says build unknown
18:58:13 <jchia> Axman6: OK
19:12:08 <waterdrop> Hi, I'm a newbie that's learning Haskell. In the type sig for a function, what does it mean when there are two type variables next to each other? For example, all has the type Foldable t => (a -> Bool) -> t a -> Bool
19:12:12 <waterdrop> What does the "t a" mean?
19:12:34 <Axman6> t might be [] or Maybe or Either String
19:13:01 <Axman6> it's a any type t which has kind * -> *, i.e., it needs to be given another type before it becomes a type
19:13:14 <Axman6> Maybe isn't a type, Maybe Int is
19:13:43 <Axman6> the constraint Foldable t says that t must ba e an instance of Foldable
19:14:38 <waterdrop> Axman6: I see. So t is a higher kinded type that has to have an instance of Foldable? And so basically that "t a" says, this argument must be a value that you got by applying a data constructor for a higher kinded type that has an instance of foldable to a value of type a?
19:14:49 <woodson> waterdrop: look at this List Int 
19:15:08 <woodson> this turns to t a where t is type List and a kind Int
19:15:47 <waterdrop> woodson: Yeah I think I see
19:16:07 <woodson> waterdrop: https://en.wikibooks.org/wiki/Haskell/Kinds
19:16:21 <waterdrop> So for the "t a" argument I need to provide a value that was constructed by applying a data constructor for a higher kinded type t that has an instance of foldable to a value of type a
19:16:42 <woodson> they usually explain type and kind later on in haskell books but i think that it should be introduced first
19:17:06 <waterdrop> woodson: they did explain type and kind, I guess I was just confused for this specific example
19:17:07 <woodson> it really helps understand the rest of other abstraction later on
19:17:16 <waterdrop> is what I said above correct though?
19:17:40 <woodson> waterdrop: yes
19:17:48 <woodson> what you said above is correct
19:17:53 <waterdrop> woodson: cool, thanks :)
19:18:41 <waterdrop> woodson: How much of the theory do I need to understand before I should start learning by programming in Haskell?
19:19:07 <dmwit> waterdrop: You have the idea right, but a slight terminology bug.
19:19:12 <dmwit> `t` need not be higher kinded.
19:19:21 <waterdrop> With other languages I'd just start programming earlier as a way to learn the language, but Haskell seems to have a lot more abstraction and different concepts that I need to understand
19:19:27 <dmwit> In fact `t` must have kind * -> *, which is not a higher kind.
19:19:50 <waterdrop> dmwit: I think the book I'm reading describes kind * -> * as a higher kind, because it needs to be applied to a type before it can be a concrete type itself
19:20:19 <waterdrop> I'm probably misremembering though
19:20:20 <dmwit> Okay. I think normally "higher kind" means a kind with an arrow to the left of an arrow.
19:20:26 <dmwit> e.g. `(* -> *) -> *` or similar
19:20:53 <dmwit> N.B. `* -> * -> *` does not have an arrow to the left of an arrow because it is `* -> (* -> *)`
19:21:35 <waterdrop> I see
19:22:03 <woodson> waterdrop: honeslty im still in my learning phase as well. I have been playing with haskell for almost 6 months now. If I had not given myself a project to work on I would have probably stopped, but now I just love it.
19:22:09 <dmwit> Also, on the "when should I stop doing theory and start programming": I think you can start programming straight away if you want.
19:22:35 <woodson> waterdrop: Finding tutorial will be harder than other popular languages though
19:22:40 <slack1256> there is royal path to haskell
19:22:46 <slack1256> *is no
19:22:51 <dmwit> For me, I read the Gentle Intro, then started programming, and I think that worked out pretty well. The Gentle Intro is dense but short.
19:22:53 <waterdrop> dmwit: I see
19:23:09 <waterdrop> great thanks
19:23:13 <dmwit> Anyway given the grasp of types and kinds you have demonstrated so far I'd say theory is not such a weak point that it should stop you from being productive.
19:23:23 <waterdrop> Okay
19:23:52 <waterdrop> I'm only halfway through my book…I still see chapters on monoids, semigroups, functors, applicatives, monads, ..etc
19:24:11 <waterdrop> I have some experience with abstract algebra which will hopefully help
19:24:38 <waterdrop> haskell is definitely the most interesting language I've seen :)
19:24:51 <dmwit> Okay. Serious programs will probably need to do a little bit of IO, and most explanations of IO go by way of monads.
19:25:08 <dmwit> But for beginning programs, you can get very far with a pretty basic understanding and `interact`.
19:25:22 <waterdrop> cool, thanks
19:41:04 <hxegon> Going through programming in haskell 2nd edition and one of the examples is giving me a non-exhaustive pattern message.
19:41:12 <hxegon> let rmdups [] = []
19:41:33 <hxegon> let rmdups (x:xs) = x : filter (/= x) (rmdups xs)
19:44:23 <dmwit> Put them both in one let block.
19:44:32 <dmwit> As it is, your second `let` is shadowing the first.
19:44:39 <dmwit> let rmdups [] = []
19:44:44 <dmwit>     rmdups (x:xs) = ...
19:45:12 <dmwit> If you are doing this in ghci, you will need to either :set +m to get automatic multiline mode or use :{ and :} to manually trigger multiline mode.
19:46:36 <hxegon> dmwit: ahh, thanks. still trying to wrap my mind around ghci vs ghc
19:52:53 * hackage airship 0.9.1 - A Webmachine-inspired HTTP library  https://hackage.haskell.org/package/airship-0.9.1 (lambda_foo)
20:04:55 * hackage mvc 1.1.6 - Model-view-controller  https://hackage.haskell.org/package/mvc-1.1.6 (GabrielGonzalez)
20:12:27 <dmwit> hxegon: Think of ghci as a giant IO do block.
20:13:20 <jchia> Question about guards. How exactly they work or desugar has always been hazy to me. I only know how to use them to express the RHS of a function definition. How can I use them in other contexts? http://lpaste.net/360390
20:14:36 <glguy> jchia: You can use them as part of a pattern in a function definition clause or as part of a pattern in a case expression alternative
20:15:10 <jchia> glguy: Is there a simple reason why it's so restrictive?
20:15:31 <jchia> Why can't I use it wherever an expression is expected?
20:15:49 <glguy> There's an extension called "MultiWayIf" for that
20:16:21 <jchia> glguy: OK, but multiwayif can't do pattern matching like pattern guards, right?
20:17:21 <glguy> What happened when you tried?
20:27:12 <jchia> glguy: Actually, I just found out that the compiler accepted it with slightly different indentation requirements. I wasn't expecting it to compile because I've never seen MultiWayIf explained in a way that involves pattern matching.
20:28:47 <jchia> glguy: So, I suppose the morale of the story is to read the ghc manual?
20:29:03 <glguy> That kind of seems like cheating
20:29:16 <jchia> cheating?
20:36:53 <Average-user> Can someone make this shorter https://pastebin.com/V3ce9DE3?
20:37:45 <Axman6> @pl s xs = nub xs == xs
20:37:45 <lambdabot> s = (==) =<< nub
20:37:58 <Axman6> @pl m x f = zipWith f [0..] x
20:37:58 <lambdabot> m = flip (flip zipWith [0..])
20:38:30 <Axman6> if you care about performance at all, nub is a bad idea
20:39:03 <Average-user> the last one makes it larger
20:39:36 <Average-user> m x f = zipWith f [0..] x and thats what I already have.
20:41:27 <Axman6> ...
21:09:55 <XorSwap> @hoogle a -> [a] -> Int
21:09:55 <lambdabot> Prelude (!!) :: [a] -> Int -> a
21:09:55 <lambdabot> Data.List (!!) :: [a] -> Int -> a
21:09:55 <lambdabot> GHC.OldList (!!) :: [a] -> Int -> a
21:10:44 <glguy> Doing adventofcode.com this year? Join the #haskell leaderboard: http://adventofcode.com/2017/leaderboard/private 43100-84040706
21:13:19 <jle`> woo hoo :D
21:13:48 --- topic: set to 'https://www.haskell.org | https://wiki.haskell.org/IRC_channel | Paste code/errors: http://lpaste.net/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D | https://www.reddit.com/r/haskell | Admin: #haskell-ops | Offtopic: #haskell-offtopic | https://downloads.haskell.org | https://summer.haskell.org Summer of Haskell 2017 | AoC leaderboard 43100-84040706' by ChanServ
21:14:33 <geekosaur> I would have thought SoH could go away by now
21:14:51 <geekosaur> unless it's turning into Winter of Haskell shortly >.>
21:14:58 --- topic: set to 'https://www.haskell.org | https://wiki.haskell.org/IRC_channel | Paste code/errors: http://lpaste.net/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D | https://www.reddit.com/r/haskell | Admin: #haskell-ops | Offtopic: #haskell-offtopic | https://downloads.haskell.org | AoC leaderboard 43100-84040706' by ChanServ
21:16:17 <mandiblegrip> It's just become Summer in my neck of the woods
21:17:17 <geekosaur> antipodal SoH >.>
21:20:06 <mud> glguy: Did day 1. I'll see if I keep up with it, heh.
21:31:27 <Average-user> I joined  the private leaderboard, but probably I will not be able to participate tomorrow
21:32:44 <mud> You only get any points in a day if you're in the first 100 to solve?
21:32:51 <Average-user> no
21:33:09 <mud> http://adventofcode.com/2017/leaderboard not sure how to read this then
21:33:17 <Average-user> you are right my bad
21:33:33 <Average-user> but i think that it works separately with the privates leaderboards
21:33:43 <mud> That's a fairly awful scoring system.
21:35:18 <Average-user> It's made like that to make everyone fight for those 100 places
21:36:13 <mud> You pretty much have to solve right at midnight then for it to mean anything though, which seems lame.
21:36:48 <Average-user> Axman6: I don't care about performance, it was just to make the shortest code possible
21:37:39 <mud> I guess I can aim for score on the private leaderboard, heh.
21:37:42 <Average-user> In my country starts at 2:00 am
21:38:01 <Average-user> I'm currently fourth
21:38:05 <mud> Starts at 9pm in my TZ I think. Which is ... not horrible, but I'm often busy at that time.
21:38:36 <Average-user> well, 2:00 am it is pretty bad
21:39:17 <Average-user> now I'm at 2:37 and I have to wake up at 6:30
21:39:26 <Average-user> so I better go to sleep
21:39:28 <Average-user> bye
21:56:57 <jle`> i wonder if there's a nice way to bisect a list in haskell with only one traversal
22:04:00 <XorSwap> @hoogle -> RandomGen
22:04:01 <lambdabot> Unknown flag: ->
22:04:08 <XorSwap> @hoogle a -> RandomGen
22:04:08 <lambdabot> Prelude id :: a -> a
22:04:08 <lambdabot> Data.Function id :: a -> a
22:04:08 <lambdabot> GHC.Exts breakpoint :: a -> a
22:04:12 <XorSwap> @hoogle RandomGen
22:04:13 <lambdabot> System.Random class RandomGen g
22:04:13 <lambdabot> FRP.Yampa class RandomGen g
22:04:13 <lambdabot> FRP.Yampa.Random class RandomGen g
22:04:25 <XorSwap> @hoogle RandomGen g
22:04:25 <lambdabot> System.Random class RandomGen g
22:04:25 <lambdabot> FRP.Yampa class RandomGen g
22:04:25 <lambdabot> FRP.Yampa.Random class RandomGen g
22:04:40 <boj> XorSwap: please do that in a query with lambdabot 
22:04:47 <XorSwap> oh sorry
22:08:33 <nshepperd> jle`: splitAt (genericLength xs `div` 2 :: Peano) xs?
22:10:01 <nshepperd> not sure how productive is `div` on lazy nats. but you could special case it
22:27:53 * hackage algebraic-prelude 0.1.1.0 - Algebraically structured Prelude  https://hackage.haskell.org/package/algebraic-prelude-0.1.1.0 (HiromiIshii)
23:24:05 <kahlil29> https://hackage.haskell.org/package/wreq-0.5.1.0/docs/Network-Wreq-Types.html#t:Putable  Putable has instances of "Value" and "Payload" but these instance declarations are only visible when checking the info of Putable in the REPL. Can't find anywhere in docs or even the source files. Any idea why? 
23:25:01 <mniip> dmwit, yeah see unfortunately I'm only limited to remote jobs at the moment
23:28:06 <cocreature> kahlil29: https://github.com/bos/wreq/blob/1b64b0e505427b7ec235a9034bf3b05791c7ad0c/Network/Wreq/Types.hs#L99
23:31:36 <kahlil29> cocreature: yes so the instances are there in the source. But why are they not showing up in the docs? 
23:32:06 <geekosaur> this smells like the haddock instance bug
23:32:38 <geekosaur> if you look in the haddock for Prelude from different versions of base, you'll find different random instances missing
23:33:10 <mniip> I think it's simple
23:33:11 <geekosaur> nobody has figured out the bug yet :(
23:34:07 <mniip> whenever it generates doscs for a package it only generates docs using this package and the small set of platform packages
23:34:43 <geekosaur> but the instances are right there and the types are in the same package. and base instances should always be available
23:35:58 <mniip> oh duh
23:36:01 <mniip> it's at the bottom
23:36:04 <mniip> orphan instances
23:36:30 <mniip> not sure why it's considered orphan though
23:36:52 <atondwal[m]> hey does anyone here know how to sequence parsers?
23:37:11 <atondwal[m]> given a Parser Text Text and a Parser Text a
23:37:12 <jxv> mniip, neither Puttable or Value is defined in that module
23:37:21 <mniip> but Putable is
23:37:36 <mniip> oh well, reexported only
23:37:51 <atondwal[m]> is there something that'll do that for me, or do I have to write the packing/error handling myself?
23:38:01 <jxv> atondwal[m] what type signature do you expect?
23:38:46 <mniip> atondwal[m], sounds like a job for >> or >>= or <*> but depends on the exact parser you're using
23:39:11 <mniip> unless you mean vertical composition?
23:39:15 <geekosaur> hm actually that sounds like a bit overenthusiastic orphaning, since it should be by package
23:39:33 <mniip> geekosaur, no I think that matches with ghc's understanding
23:39:37 <mniip> as ghc compiles by module
23:40:15 <atondwal[m]> jxv: Parser Text a
23:40:31 <atondwal[m]> It's not bind, because bind takes a function
23:40:44 <atondwal[m]> Yeah, vertical composition
23:40:45 <jxv> Parser Text Text -> Parser Text a?
23:41:11 <cocreature> atondwal[m]: where is the parser type coming from?
23:41:14 <vaibhavsagar> glguy: are you putting your solutions for AoC up this year like you did last year? I learned a lot from reading them and they were super helpful when I got stuck!
23:41:42 <atondwal[m]> Parser Text Text -> Parser Text a -> Parser Text a
23:42:38 <atondwal[m]> cocreature:  Text.Parse. I think it's attoparsec?
23:44:16 <cocreature> atondwal[m]: no attoparsec is Data.Attoparsec.*
23:44:21 <atondwal[m]> so I have a parser that parses text into text (why? don't ask me) and I want to compose that with a parser that actually parses that text
23:44:32 <cocreature> it looks like Text.Parse is polyparse which I haven’t even heard of until now
23:44:54 <atondwal[m]> cocreature: ignore that, for some reason I imported both
23:45:12 <cocreature> atondwal[m]: so it’s attoparsec after all? :)
23:45:14 <atondwal[m]> I have import Data.Attoparsec.Internal.Types (Parser)
23:45:29 <atondwal[m]> (but I also have import Text.Parses as P, which threw me off)
23:45:29 <atondwal[m]> yeah
23:47:14 <cocreature> I don’t think attoparsec has anything built in for that
23:47:54 <atondwal[m]> grr I guess what I'd like is an instance declaration of `Parser Text a` as an `Arrow Text a`
23:48:08 <atondwal[m]> I don't know if I can even do violence to the type system like that
23:48:54 <atondwal[m]> okay then, time to refactor
23:49:47 <cocreature> it’s not particularly hard to implement this yourself
23:52:58 <mniip> huh
23:53:12 <mniip> github did ask me to re-allow AoC
23:53:21 <mniip> yet I'm still on the haskell leaderboard
23:54:03 <Lokathor> I hope that everyone is pumped up about the Advent of Code this year
23:54:37 * mniip considers the misinterpretation opportunities of mentioning "AoC" in a highly mathematical channel
23:54:38 <Lokathor> I did it in rust and had 10x the difficulty that the Haskell version had
23:55:11 <atondwal[m]> cocreature: yeah, but I'm taking it as a sign that it's just something that I shouldn't do
23:56:23 * geekosaur has already at least once dropped "if you hear mention of AoC, run away from the mathematical religious argument" into a discussion :p
23:57:40 <atondwal[m]> oh man Bob Harper has the most interesting argument for AoC at OPLSS this summer
23:58:15 <atondwal[m]> *against AoC
23:59:23 <atondwal[m]> I don't remember it exactly, but he posited the existence of a choice function as a certain morphism that has to exist in a category, and argued that while Set has it, there are a lot of useful categories that don't have it (like Grp). It's in the videoes
23:59:50 <atondwal[m]> wow that is not how one pluralizes videos. I swear English is my native tongue
