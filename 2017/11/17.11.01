00:09:05 <jchia> Are there some general guidelines on how to organize a project into its respective modules? How bad are circular dependencies between modules?
00:10:07 <jchia> I know some people advocating making a 'Types' module, but I don't really understand why it's needed or the benefits. In other languages like C++, there's no such practice.
00:10:57 <mud> jchia: Circular dependencies are at least very annoying. Definitely to be avoided.
00:11:23 <mud> 1/2 of the reason to do Types modules is to avoid circular dependencies in my experience, heh.
00:12:42 <jchia> mud: So, if there are modules A.B.C1 and A.B.C2, someone would typically break circular dependencies by defining A.B.Types and putting C1's and C2's custom types in there?
00:13:17 <mud> Unless my experience is uncommon, yeah, that mostly takes care of it.
00:13:33 <mud> There are other times circular dependencies come up, but that's most of mine.
00:13:56 <jchia> mud: What annoying things happen in relation to circular dependencies in Haskell?
00:14:09 <jcarpenter2> ok, i'm using haskell
00:14:39 <mud> jchia: You have to do some weird thing I always forget with .hsboot files or something in GHC.
00:15:01 <jcarpenter2> hopefully i don't get into cabal conflict hell
00:15:16 <jcarpenter2> (i'm using a sandbox but still)
00:15:26 <jchia> mud: OK, weird project/tool setups. Thanks.
00:16:32 <mud> Sure
00:18:29 <jle`> jcarpenter2: congrats :D
00:18:37 <jchia> jcarpenter2: Have you just started using Haskell?
00:18:40 <jle`> cabal hell isn't really a thing people talk about anymore these days
00:18:48 <jcarpenter2> not quite just
00:18:51 <jle`> now that we have stackage snapshots
00:18:56 <jle`> and better cabal
00:18:59 <jcarpenter2> i messed around with it about 2 years ago
00:19:13 <jle`> nowadays we think of it as a 'back in the day things were so rough' kinda thing
00:19:21 <jcarpenter2> yeah, i was hoping maybe things improved since then, i used to always get these annoying conflicts
00:19:40 <jle`> welcome to the future :D
00:19:48 <jcarpenter2> thank you!
00:19:52 <jcarpenter2> it's good to be here
00:20:03 <jchia> jcarpenter2: I haven't had to deal with cabal hell. Like jle` said, there's stackage. I just use stack and there's no cabal hell. Stack has other problems, too, but it's not too much of a bother for me.
00:20:17 <jcarpenter2> what is stackage?
00:20:25 <jle`> stackage is a curated set of compatible packages
00:20:35 <jle`> compatible package snapshots
00:20:49 <jcarpenter2> ah cool
00:21:05 <jcarpenter2> all mutually compatible?  sounds like a long shot
00:21:07 <jle`> and stack is a tool that lets your project be dependent on specific snapshots
00:21:19 <jle`> yea that's what we all said when the project was announced
00:21:32 <jle`> but look who's laughing now
00:21:34 <jcarpenter2> is stack used instead of cabal, or do you configure cabal to use it?
00:21:46 <jle`> stack and cabal are two different tools
00:22:21 <jle`> they're two different toolkits, for the most part
00:22:33 <jchia> jcarpenter2: When you use stack, you don't have to think about using the cabal command, but you still need to deal with .cabal project files.
00:23:16 <jcarpenter2> installing it now
01:02:42 <vrederv> Are data types to values what classes are to objects?
01:04:43 <Hafydd> What are "objects"?
01:08:34 <jchia> Hafydd: I think he means objects in an OOP language.
01:08:39 <ventonegro> Instances of classes, I guess
01:08:59 <Hafydd> If you mean classes and objects from classical OOP, and not type classes from Haskell, then the analogy is only very loose, and limited to the general type/value relationship. Data types can't inherit from each other, and values don't have subtype polymorphism.
01:15:42 <vrederv> Why can record syntax definitions begin on a newline but record syntax initializations not? http://lpaste.net/359712
01:18:11 <remix2000> What exactly is the difference between liftA, liftM, fmap in context of applicating function to list, like `map (*2) [1..10]`?
01:18:20 * remix2000 is confused…
01:18:59 <dminuoso> remix2000: liftM is just a confusion for historical reasons I believe.
01:18:59 <liste> remix2000: they do the same thing, they're just parts of different type classes
01:19:29 <dminuoso> remix2000: Same applies to liftA. This has to do with the fact that back then, it was not a requirement for an Applicative to also be a Functor, and for Monads to also be Functor and Applicatives.
01:19:34 <dminuoso> Just use fmap.
01:19:44 <liste> yeah, forget liftA and liftM
01:19:49 <liste> these days they're useless
01:20:39 <jchia> liftA2, liftA3 are still handy, though
01:21:31 <dminuoso> remix2000: also keep in mind that `fmap` is not for "applying functions to things", but rather "transforming functions"
01:22:00 <jchia> vrederv: What error message do you get? What if you indent more?
01:22:07 <dminuoso> remix2000: While it's frequently used like you just said, it's cleaner to see currying: double' = fmap (*2); double' [1..10]
01:22:18 <dminuoso> This captures the essence of fmap better
01:22:33 <vrederv> test.hs:10:9: error: parse error on input ‘{’
01:22:49 <jchia> does indenting more help?
01:23:33 <{AS}> What could be a potential way to track why ByteStrings are not properly released
01:24:00 <Hafydd> vrederv: because the opening brace of your record constructor is on the same indentation level as the "foo" in "let foo", it's interpreted as a new item in the list of definitions in the "let" clause. See <https://www.haskell.org/onlinereport/haskell2010/haskellch2.html#x7-210002.7> for the rules of this.
01:24:08 <vrederv> jchia, yes
01:24:09 <Hafydd> vrederv: this "works": http://lpaste.net/359712
01:25:19 <Hafydd> Reading the Haskell 2010 language report should be an entry requirement for asking questions about Haskell.
01:25:21 <vrederv> you just sent the same url
01:25:52 <Hafydd> vrederv: I edited it.
01:26:18 <remix2000> dminuoso: so it transforms function like `1 f` to `n f` in fmap f [1..n] mapping values to new array, am I right?
01:26:20 <vrederv> oh
01:26:31 <Hafydd> I thought it would add a new entry underneath, but apparently not.
01:27:05 <dminuoso> :t fmap
01:27:07 <lambdabot> Functor f => (a -> b) -> f a -> f b
01:27:09 <fakenullie> Fmap is transforming functors
01:27:12 <dminuoso> remix2000: ^- this is the cleanest way to just see what it does.
01:27:25 <dminuoso> remix2000: fmap is just transforms a function a -> b into f a -> f b
01:27:44 <dminuoso> remix2000: in your case f is []
01:31:49 <remix2000> dminuoso: and in this case `f a` means functor of type a?
01:32:45 <dminuoso> remix2000: no. it just happens that most functors are polymorphic types.
01:33:12 <vrederv> Hafydd, thanks
01:33:19 <dminuoso> :k Functor
01:33:21 <lambdabot> (* -> *) -> Constraint
01:34:57 <dminuoso> remix2000: think along the way of []. [Int] is just syntactic sugar for `[] Int`
01:35:16 <dminuoso> whereas [] is an instance of Functor (the `f` you just saw)
01:36:04 <dminuoso> so for example fmap might transform: (Int -> Int) into ([] Int -> [] Int)
01:39:23 <remix2000> Nothing >>= (\ x -> if (x == 0) then fail "zero" else Just (x + 1) )
01:39:38 <remix2000> sorry, not intended to pase
01:39:44 <remix2000> *paste
01:41:08 <dminuoso> remix2000: except fmap can do this for any Functor f and types a, b, such that: (a -> b) -> (f a -> f b)
01:42:08 <osa1> uh why there isn't a waitAll in async
01:42:18 <osa1> I don't remember how many times I rolled my own version
01:43:09 <remix2000> So it can be written for ([] Int -> [] Int) -> (Functor Int -> Functor Int)?
01:43:33 <remix2000> sorry, I mean Functor [] Int
01:46:33 <dminuoso> remix2000: It doesn't matter what a is. `[] Int` itself is a proper (mono)type
01:46:52 <ventonegro> {AS}: Did you already try this? https://downloads.haskell.org/~ghc/8.2.1/docs/html/users_guide/profiling.html#profiling-memory-usage
01:47:26 <dminuoso> remix2000: so sure, you could have some ([] Int -> [] Int) -> (Maybe ([] Int) -> Maybe ([] Int)). Or any other Functor you can think of.
01:47:28 <{AS}> ventonegro: thanks for the suggestion, I believe the profile showed that the reason was ByteStrings
01:47:39 <{AS}> when the old developers did the profiling
01:47:40 <{AS}> I can try to redo it though
01:47:53 <dminuoso> remix2000: Or perhaps more to the point: ([] Int -> [] Bool) -> (Maybe ([] Int) -> Maybe ([] Bool))
01:48:09 <dminuoso> remix2000: So the most generic way of expressing this is:
01:48:11 <dminuoso> :t fmap
01:48:12 <lambdabot> Functor f => (a -> b) -> f a -> f b
01:48:16 <ventonegro> {AS}: Ok, but didn't it show where they were leaking from?
01:48:50 <remix2000> dminuoso: So f is any type deriving functor, like []? And functor alone doesn't mean anything special?
01:49:30 <{AS}> ventonegro: Hmm, does it show a trace where the leak is from?
01:49:32 <merijn> remix2000: Well, functor literally means "fmap works on this" :)
01:49:35 <dminuoso> remix2000: Well, Functor tells you that this parameteric type follows some special laws.
01:49:45 <{AS}> like the particular function
01:49:51 <ventonegro> {AS}: Yes, with `-hc`
01:50:10 <remix2000> Now it's clear, thank you :)
01:50:14 <merijn> remix2000: Although a "proper" functor should obey the functor law(s), which is "fmap id x == x"
01:50:32 <{AS}> ventonegro: thanks I will try to take a look when I get the time :)!
01:50:37 <dminuoso>  and (fmap f) . (fmap g) = fmap (g . f)
01:50:44 <dminuoso> (for covariant functors)
01:50:46 <merijn> dminuoso: That one is redundant in Haskell
01:51:01 <ventonegro> {AS}: Sure
01:51:10 <merijn> dminuoso: fmap composition is a free theorem that follows from "fmap id = id"
01:51:29 <dminuoso> merijn: Interesting, how?
01:51:37 <merijn> I like my theorems and laws like I like my coffee. Free!
01:52:02 <merijn> dminuoso: It follows from parametricity (which is not a given in CT in general, but is in Haskell)
01:52:24 <merijn> dminuoso: I don't have a rigorous proof, but I can sketch out the reasoning.
01:52:36 <merijn> :t fmap
01:52:38 <lambdabot> Functor f => (a -> b) -> f a -> f b
01:52:58 <merijn> dminuoso: Parametricity tells us that *every* 'a' must be used in fmap (else it wouldn't typecheck as 'f b')
01:53:12 <merijn> dminuoso: And "fmap id = id" is enough to guarantee no structural changes can occur
01:54:11 <c_wraith> when combined with parametricity, anyway.
01:54:11 <merijn> dminuoso: So if we already have proof of "no structural changes" and proof of "every element must be used" (from parametricity), then it automatically follows that multiple fmaps in a row must match a single fmap of composed functions
01:54:20 <merijn> c_wraith: Yes, I mentioned that above
01:54:51 <c_wraith> you mentioned it, but not that it was a requirement for the next part.
01:56:08 <merijn> Sad times...need to wait another day for upstream...
01:56:20 <c_wraith> anyway, I've written non-parametric definitions of Functor to demonstrate how that fails. (and why Functor is defined the way it is) 
01:56:43 <merijn> Maybe I should try something different and spent my waiting time documenting stuff :p
01:57:40 <dminuoso> merijn: Okay I've read this twice, I think I need to work out a proof. Will do this later, got what you wrote safely in my logs. Thans.
01:58:10 <dminuoso> merijn: To me the idea of (fmap f) . (fmap g) = fmap (g . f) is what helped me gain a finer understanding of what functors are about (whether it follows from `fmap id = id` or not)
01:59:17 <dminuoso> merijn: There seems to be a thorough article on this subject https://bartoszmilewski.com/2014/09/22/parametricity-money-for-nothing-and-theorems-for-free/
01:59:32 <dminuoso> Not sure whether Bartosz Milewski's articles are considered worthwhile in here.
02:00:05 <merijn> dminuoso: I recall Wadler's "Theorems for Free!" paper being pretty readable too
02:00:05 <ventonegro> WAT
02:00:44 <merijn> dminuoso: https://pdfs.semanticscholar.org/1887/6ec7dd36d455392c04668c4058175e82f6a9.pdf
02:01:21 <dminuoso> merijn: Hah. That article was the name giver and is even referenced by Bartosz.
02:01:31 <merijn> dminuoso: Free theorems and parametricity are excellent topics to read up on anyway.
02:01:57 <dminuoso> I'll see whether I have acquired enough understanding to get through that paper, it looks intriguing.
02:02:01 <merijn> dminuoso: It's basically about formalising the intuition that, e.g. "a -> a" has only one (well, two in Haskell) implementation
02:02:24 <dminuoso> merijn: By two, do you mean to imply _
02:02:28 <dminuoso> _|_ ?
02:02:31 <merijn> dminuoso: Correct
02:02:45 <merijn> dminuoso: But we have another paper formalising why it's ok to pretend it has only one ;)
02:03:30 <merijn> aka "Fast and Loose Reasoning is Morally Correct!"
02:04:52 <merijn> dminuoso: Which boils down to "if we prove something about a total language (i.e. one without bottom), the proof is automatically correct for non-total languages IFF we assume non-bottom inputs"
02:05:31 <merijn> And proofs for a subset of our inputs are more useful than no proofs at all
02:09:07 <int-e> . o O ( unless the subset is empty )
03:47:05 <statusfailed> does anyone have an example of using recursion-schemes to do substitution in a lambda calculus AST? I cant figure out how to account for abstraction shadowing var names
04:16:30 <jollygood2> hi
04:16:59 <jollygood2> I get the impression that typeclasses are not very loved by some in the haskell community, often seeing suggestions that code that uses if antipattern, and that it should be using data instead. would you extend the same thing to Monad, Functor, or Num? should those be data as well? if not why not?
04:17:13 <jollygood2> that uses it is antipattern*
04:18:19 <ahihi> i think it's mostly typeclasses without laws that are disliked
04:20:27 <liste> also existial typeclasses are frowned upon https://lukepalmer.wordpress.com/2010/01/24/haskell-antipattern-existential-typeclass/
04:20:33 <liste> but not typeclasses in general
04:28:39 <M4GNV5> hey, i have a long list [IO a] how would evaluate all entries but not more than n at the same time? Can i use the parallelizing operators and a special Strategy for that? I'm new to parallelizing stuff in hs
04:31:17 <M4GNV5> the problem is that each operation in the list opens a file and i quickly run into the file descriptor limit when using sequence, even when using evaluate after readFile to read the full string
04:31:32 <Rembane> M4GNV5: What kind of parallellism do you want?
04:31:58 <Rembane> M4GNV5: Do you have any preferences for parallellism libraries and so on?
04:32:33 <M4GNV5> hmm, for starters i just want it not to crash :D
04:33:42 <cocreature> M4GNV5: what kind of operations are you performing? the parallel strategies are for parallelizing pure computations. if you want to parallelize things like network requests, "async" is a better choice
04:34:45 <liste> @hackage async
04:34:45 <lambdabot> http://hackage.haskell.org/package/async
04:47:44 <M4GNV5> cocreature, just a readFile and then using the resulting string on a pure function
04:48:28 <M4GNV5> this is the whole code: https://pastebin.com/raw/f8ZGz2u8
04:49:06 <M4GNV5> the problem is, i assume, in the last two functions
04:49:15 <cocreature> split it up in two parts: first read the file and then parallelize the computation on the things you’ve read
04:50:09 <M4GNV5> but every computation has its own file
04:50:21 <M4GNV5> i have 11818 files in total
04:51:37 <cocreature> alright, then try mapConcurrently https://hackage.haskell.org/package/async-2.1.1.1/docs/Control-Concurrent-Async.html#v:mapConcurrently
04:52:22 <cocreature> to limit the number of concurrent operations you can either just wrap each action in a semaphore (https://hackage.haskell.org/package/base-4.10.0.0/docs/Control-Concurrent-QSem.html) or you can use the async-pool package (https://hackage.haskell.org/package/async-pool)
04:54:24 <cocreature> M4GNV5: also your call to "evaluate" probably doesn’t do what you want. it will only evaluate the string to whnf not fully evaluate it. you can either use the deepseq package to force full evaluation or just use readFile from System.IO.Strict
04:55:15 <cocreature> and you might also want to force evaluation of the result of applying handleMatch
04:56:49 <M4GNV5> whnf?
04:57:04 <cocreature> weak head normal form
04:57:15 <cocreature> https://wiki.haskell.org/Weak_head_normal_form
04:57:16 <M4GNV5> I can't find System.IO.Struct, is it a package?
04:57:32 <cocreature> http://hoogle.haskell.org/?hoogle=System.IO.Strict%20is%3Amodule
04:59:21 <M4GNV5> hmm "stackage", so how do import that?
04:59:57 <cocreature> take a closer look at the link :) it tells you that it’s in a package called "strict"
05:03:18 <M4GNV5> hmm now it ate *just* 11GB ram, but it didn't crash ^^
05:03:24 <M4GNV5> thanks cocreature!
05:23:21 <stevenxl> Hi folks. If I have the following type alias "type TodoAPI   = "api" :> "todos" :> Get '[JSON] [Todo]", and I want to protect that with the BasicAuth combinator, does it matter where I put the BasicAuth combinator?
05:23:40 <stevenxl> whoops - wrong channel
05:35:16 <ongy> is there a tool I can fire on a file to automagically remove unused imports? 
05:36:46 <merijn> ongy: I have them highlighted via ghc's -Wall and then remove them manually?
05:37:32 <ongy> I wanted to avoid the last step here :) I got quite a few
05:42:37 <lyxia> hlint perhaps
05:49:15 <ahuidk> I'm not sure why my function complains of type error and doesn't return ["aa_K", "bb_L", "cc_K"]
05:49:19 <ahuidk> foldr (\x y -> if fromJust (elemIndex x lst) then x ++ "_K":y else x ++ "_L":y) [] ["aa", "bb", "cc"]
05:49:59 <merijn> :t elemIndex
05:50:01 <lambdabot> Eq a => a -> [a] -> Maybe Int
05:50:07 <merijn> ahuidk: Int is not a Bool
05:50:32 <ahuidk> oops
05:51:15 <ahuidk> oh, I forgot to put "even"
05:51:28 <ahuidk> foldr (\x y -> if even (fromJust (elemIndex x lst)) then x ++ "_K":y else x ++ "_L":y) [] ["aa", "bb", "cc"]
05:51:39 <ahuidk> still complains about type error
05:54:21 <mnoonan_> ahuidk: (:) binds more tightly than (++)
05:55:23 <ahuidk> yep, but it gives me a type error instead of ["aa_K", "bb_L", "cc_K"]
05:55:45 <ahuidk> I've no clue how to solve this.
05:55:59 <mnoonan_> yes, because (:) binds more tightly :)  that is, you wrote x ++ (“_K” : y), when I think you meant (x ++ “_K”) : y
05:56:55 <mnoonan_> in your case of x ++ (“_K”: y) you are trying to append a x :: [Char] to a (“_K” : _) :: [[Char]]
05:57:50 <ahuidk> Thank you so much
05:57:54 <mnoonan_> np
06:06:47 <Psybur> Do you guys think it would be a good exercise to refactor my backtesting framework to use the Free monad / DSL pattern?
06:07:51 <Psybur> Maybe not, its kind of a straightforward process, guess making a DSL wouldnt make sense
06:15:21 <Psybur> @src (>=>)
06:15:21 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
06:19:42 <WinterFox[m]> In this line `allUsers :: [Entity User] <- runDB $ selectList [] []` is the data from the right of <- being cast to the type Entity User?
06:21:34 <merijn> WinterFox[m]: Haskell doesn't have casts
06:21:55 <merijn> WinterFox[m]: That's just a type annotation
06:22:32 <WinterFox[m]> merijn: Is it just checking the data it gets back is of that type?
06:24:14 <merijn> WinterFox[m]: It's telling the compiler it has that type
06:24:21 <merijn> WinterFox[m]: Since selectList is polymorphic
06:32:33 <sick_with_fever> Hi how close is C language to Haskell ?
06:32:50 <merijn> sick_with_fever: As far as possible while staying in this universe
06:32:53 <AndreasK> |<----------------->| this far
06:32:59 <AndreasK> *not to scale
06:33:33 <sick_with_fever> merijn:  AndreasK  What do you mean ? I am saying c is similar language to haskell or not 
06:34:49 <AndreasK> Without defining how you measure close it's not a useful question to ask. But they are pretty different
06:36:33 <sick_with_fever> AndreasK:  Haskell can be your primary language and C secondary or viceversa is posible  ?  Nor mally we keep primary and secondary languages which are similar
06:36:36 <sick_with_fever> isnt it ?
06:37:20 <AndreasK> I think the languages one uses is primarily determined by use cases not how similar they are.
06:37:40 <AndreasK> GHC is implemented in Haskell + C so I don't see why one couldn't focus on both
06:39:26 <sick_with_fever> AndreasK:  what are your primary and secondary languages?  Other can you also tell if you like 
06:40:45 <AndreasK> atm I deal most with Haskell and C followed by Java. Why do you ask
06:41:31 <sick_with_fever> AndreasK:  I want to know what experts/haskellers use
06:42:58 <[exa]> sick_with_fever: choice of programming language is something you _want_ to transcend
06:44:31 <sick_with_fever_> Disconnected
06:58:00 <sick_with_fever_> hi haskell have no access to gpu?
07:00:07 <M2tias> sick_with_fever_: there are packages like these http://hackage.haskell.org/package/cuda
07:01:07 <mud> sick_with_fever_: Also things like https://github.com/AccelerateHS/accelerate/
07:01:55 <sick_with_fever_> M2tias: mud  but I heard haskell 20 ttimes slow when doing things realted to compliectaed mathematics models
07:03:42 <mud> The benchmarks I've seen put haskell around 2-5x slower than C for most things. And haskell has a C FFI for when you really need that speed at all costs (and there are costs).
07:04:20 <merijn> mud: Also really depends on whose writing the C and whose writing the Haskell :p
07:04:59 <mud> Yes, but it's pretty hard to judge speed in this way already. Adding more factors is going to make it even more of a mess, heh.
07:05:03 <M2tias> yeah, you might write fast Haskell code but then you are probably so far from reality that your C program is 20x slower
07:05:12 <sick_with_fever_> merijn:  what do you mean by your statement ? how does who writes matter ?
07:05:26 <Athas> Haskell is fastest for problems that are intrinsically fairly slow (IO heavy), because then the overhead of Haskell is less dominant.
07:05:33 <Athas> C is faster for computational problems.
07:05:50 <mud> I write haskell for competitive programming. I've had maybe *one* problem that was hard because I couldn't fit it under the time limit using haskell.
07:05:54 <merijn> Hell, even C can be 10 times slower than C :)
07:06:12 <mud> 20x would be ... unlikely.
07:06:15 <merijn> At some point you start having to know CPU and OS internals to squeeze out true speed
07:07:02 <Athas> Sure, but you can get quite far just from programming in something that encourages simple cache-friendly data structures and non-boxed values.
07:07:21 <Athas> It doesn't take a genius to make a modern computer run fast.  They _are_ bloody fast.
07:08:54 <tdammers> they are bloody fast, but that mostly buys you linear improvements
07:09:16 <tdammers> so if you write code that has accidental nonlinearities, then a faster computer won't help much
07:09:57 <sick_with_fever_> Which ever langugae channel I go they compare its speed to c, and all languages or somehow related to C, I think every one must learn C
07:11:00 <sm> never underestimate the power of software developers to bring a supercomputer to its knees :)
07:11:19 <mud> sick_with_fever_: It's the cannonical fast-if-you-spend-forever-writing-but-awful language.
07:11:44 <guiniol> hello everyone! I'm not a haskell dev, but I use hledger, which is in haskell. Today, I tried installing an addon using stack but it didn't work. I'm on archlinux, which apparently does things weirdly regarding haskell. However, I resolved my issue (with the help of sm in #hledger) by following the advice in https://github.com/commercialhaskell/stack/issues/2712 . This is a pretty old issue and it looks
07:11:46 <guiniol> fixed. Is the error I am encoutering expected since I use archlinux ?  BTW, here is the log with the error: https://ptpb.pw/qB7Z
07:11:51 <Psybur> > foldMap Last [1,2,3]
07:11:53 <lambdabot>  error:
07:11:53 <lambdabot>      • No instance for (Num (Maybe ())) arising from a use of ‘e_1123’
07:11:53 <lambdabot>      • In the expression: e_1123
07:13:44 <sick_with_fever_> To get some energy I am talking here smething....My head is breaking :( I think better if I throw my laptop. Software developers spend 40% of money to hospitals/medicine
07:13:51 <Athas> sick_with_fever_: it's called C because people think that's the fastest a language can go.
07:14:13 <ski> > foldMap (Last . Just) [1,2,3]
07:14:15 <lambdabot>  Last {getLast = Just 3}
07:14:28 <mud> It's called C because it came after B, though that is a cuter reason.
07:14:59 <sick_with_fever_> mud:  that fisrt ken thompson developed B then dennis developed c I know 
07:15:27 * ski . o O ( BCPL )
07:15:33 <byorgey> mud: re: Haskell for competitive programming, what do you do for problems with large amounts of I/O?
07:16:03 <merijn> ski: iirc there was also a B language
07:16:32 <byorgey> I have also been using Haskell for competitive programming but that's one thing I am not sure how to handle.  Though it is probably obvious to someone who has to write performant Haskell code for a living.
07:16:55 <sm> guiniol's failing "stack install old-time" on arch linux is using lts-9, which is ghc 8.0.2; and a very recent stack (10/22). Shouldn't this already have the "sed -i 's/-fno-PIE/-no-pie/g' ..." fix mentioned in https://github.com/commercialhaskell/stack/issues/2712 ?
07:17:28 <mud> byorgey: I used to use Text, which worked fine, but I switched to the horrible ByteString.Char8 because it's always ASCII anyway. I use their version of uhm   interact :: ByteString -> ByteString   and just words and lines and etc. My haskell template is kind of a horror to behold, but for me it works.
07:17:39 <merijn> byorgey: Depends, can you use libraries?
07:18:19 <byorgey> mud: ah, makes sense
07:18:35 <byorgey> merijn: anything in haskell-platform basically
07:18:54 <merijn> byorgey: I'd usually use pipes/conduit for large amounts of IO, but no clue if those are in platform
07:20:19 <mud> I don't think they're typically available on the usual sites, but like hackerrank.com has pipes (but not conduit it seems)
07:21:06 <byorgey> merijn: no, I don't think so
07:21:55 <ertes> that's why i don't really like using haskell for competetive programming or really most kinds of contests, because the result is ultimately meaningless
07:21:59 <merijn> Unrelated question
07:21:59 <merijn> Can I define an infix/operator type family? If so, what's the syntax?
07:21:59 <merijn> My own attempts haven't worked
07:22:14 <ertes> in haskell, much more so than in most other languages, it's important to be able to use libraries and the latest GHC
07:22:48 <ertes> @let type family x :++ y
07:22:50 <lambdabot>  Defined.
07:22:52 <ertes> merijn: ^
07:22:59 <byorgey> merijn: yes
07:23:05 <mud> It's all meaningless, but the journey is fun :)
07:23:05 <merijn> I though : was no longer required for type operators?
07:23:06 <byorgey> merijn: enable TypeOperators
07:23:15 <merijn> byorgey: I already have -XKitchenSink :)
07:23:34 <byorgey> fair enough =)
07:23:50 <ertes> mud: i find it rather frustrating
07:24:14 <byorgey> ertes: that's not the same as meaningless =)
07:24:36 <ertes> byorgey: it's not, but it's usually meaningless, too
07:25:01 <mud> ertes: I used to too. Once you get into it, it has its charm though.
07:25:26 <byorgey> I have duly noted the fact that ertes finds no meaning in using Haskell for competitive programming.  I don't see any point in arguing about it though.
07:26:01 <ertes> the only kind of competition i like is the code length competition, because for that in most cases you'd rather not use libraries anyway =)
07:26:19 <ertes> be it haskell or other languages
07:33:30 <tabaqui> hey
07:33:48 <tabaqui> about exceptions (again)
07:34:00 <tabaqui> if I forked a bunch of threads
07:34:06 <tabaqui> and send sigterm
07:34:26 <tabaqui> who will receive it as SignalInterrupt Exception?
07:34:45 <Athas> The main thread.
07:34:47 <ertes> tabaqui: exception handlers run in their own thread
07:34:50 <merijn> *bzzt*
07:34:55 <Athas> What, really?  wtf
07:34:55 <ertes> err
07:34:59 <merijn> By default sig TERM doesn't have a handler
07:35:01 <ertes> tabaqui: i mean signal handlers
07:35:08 <merijn> So nothing will run
07:35:11 <tabaqui> ertes: handlers - yes, but if sigterm has default handler
07:35:17 <tabaqui> then it will be raised as exception
07:35:33 <merijn> tabaqui: if sigterm has a default handler your process will immediately die
07:35:40 <tabaqui> nope!
07:35:45 <tabaqui> it is not sigkill
07:36:09 <merijn> tabaqui: The default handler for sigterm still kills the process
07:36:09 <ertes> tabaqui: if anything, the main thread, but you should verify that yourself
07:36:21 <tabaqui> https://hackage.haskell.org/package/base-4.10.0.0/docs/Control-Exception-Base.html#t:AsyncException
07:36:27 <merijn> tabaqui: So you need to install a custom handler for SIGTERM to do anything else
07:36:27 <tabaqui> UserInterrupt, actually
07:36:31 <ertes> tabaqui: main = threadDelay 10000000 `catch` \(SomeException ex) -> print ex
07:36:40 <ertes> tabaqui: and don't confuse SIGINT with SIGTERM
07:36:49 <tabaqui> oh, right
07:36:50 <ertes> i believe the default SIGTERM just kills the application
07:36:56 <tabaqui> sigint is handled as exception
07:37:04 <tabaqui> well
07:37:14 <merijn> SIGINT has a special handler installed by the runtime, yes
07:37:15 <ertes> (and yes, it's stupid)
07:37:28 <tabaqui> merijn: and it will be handled in main thread only?
07:37:40 <ertes> tabaqui: yes
07:38:02 <ertes> it would be rather pointless to send it to any other or even multiple threads
07:38:10 <merijn> tabaqui: 
07:38:23 <Athas> Unix signals are the worst thing.
07:38:27 <tabaqui> ah, thanks to the infinite sky, I can send async exception in child threads!
07:38:30 <merijn> I wouldn't even know where the RTS system is specified
07:39:28 <tabaqui> ertes, merijn, thanks too :)
07:46:10 <tabaqui> and another thing
07:47:01 <tabaqui> if thread exited for any reason, and no one keeps the pointer to its child thread
07:47:10 <tabaqui> what will happen with the child?
07:49:27 <tabaqui> doc says: "This means the thread itself can't be garbage collected until you drop the ThreadId. This misfeature will hopefully be corrected at a later date."
07:49:43 <tabaqui> but when I "void $ forkIO doSomething"
07:49:57 <tabaqui> this child isn't collected
07:50:18 <tabaqui> (base-4.10.0.0)
07:52:57 <merijn> tabaqui: What makes you say it isn't collected?
07:53:40 <tabaqui> I've deployed such code on a server
07:53:48 <tabaqui> it works for a few months
07:54:13 <merijn> I don't suppose there's a version of 'group' that groups all values, not just adjacent ones?
07:54:47 <lavalike> :t group . sort
07:54:48 <lambdabot> Ord a => [a] -> [[a]]
07:54:58 <merijn> lavalike: That adds an Ord constraint though
07:55:04 <lavalike> that it does
07:55:06 <merijn> I'd rather just have Eq
07:59:19 <mud> I guess you could do it if you don't care if it's Ω(n^2) ?
07:59:22 <ski> @src groupBy
07:59:22 <lambdabot> groupBy _  []     = []
07:59:22 <lambdabot> groupBy eq (x:xs) = (x:ys) : groupBy eq zs
07:59:22 <lambdabot>     where (ys, zs) = span (eq x) xs
07:59:36 <ski> @let groupSortBy _ [] = []; groupSortBy (==) (x:xs) = (x:ys) : groupSortBy (==) zs where (ys,zs) = partition (x ==) xs
07:59:38 <lambdabot>  Defined.
07:59:42 <ski> > groupSortBy ((==) `on` snd) [(1,0),(2,1),(3,0),(4,2),(5,0),(6,1),(7,0),(8,3)]
07:59:45 <lambdabot>  [[(1,0),(3,0),(5,0),(7,0)],[(2,1),(6,1)],[(4,2)],[(8,3)]]
07:59:47 <ski> @type groupSortBy
07:59:50 <lambdabot> (a -> a -> Bool) -> [a] -> [[a]]
08:00:14 <ski> @type \(==) -> groupBy (==) . sortBy (==)
08:00:15 <merijn> mud: Should only be small numbers of values, so n^2 will probably be fine
08:00:16 <lambdabot> error:
08:00:17 <lambdabot>     • Couldn't match type ‘Bool’ with ‘Ordering’
08:00:17 <lambdabot>       Expected type: a -> a -> Ordering
08:01:09 <ski> @type \compare -> groupBy (((EQ ==) .) . compare) . sortBy compare
08:01:12 <lambdabot> (a -> a -> Ordering) -> [a] -> [[a]]
08:12:53 <kuko1> groupSort exists already in Data.List.Extra
08:13:12 <kuko1> also, HashMap.fromListWith ...
08:13:20 <byorgey> merijn: how about https://hackage.haskell.org/package/discrimination-0.3/docs/Data-Discrimination-Grouping.html#v:group ?
08:14:05 <merijn> byorgey: meh...I kinda dislike adding dependencies with huge footprints to otherwise minimalist packages :\
08:14:10 <byorgey> If you really want to insist on Eq and only Eq though, the above suggestions re: n^2 algorithms are your best bet
08:14:14 <byorgey> fair enough.
08:14:31 <merijn> byorgey: As in, the code right now literally only depends on base :)
08:14:34 <byorgey> I didn't know what your use case is.
08:14:54 <mud> I tend to just throw in deps like mad xD
08:15:13 <Sornaensis> dependencies were made to be pulled in
08:15:13 <merijn> mud: Sure, if I need a lot of stuff and I already have them, I don't care
08:15:36 <merijn> mud: But if I have stuff that is 1) really minimal and 2) I would like others to use, I tend to be more conservative
08:15:52 <merijn> Smaller footprint == more acceptable to others and less chance of transitive breakage
08:16:14 <mud> Yeah, true. I mostly just do executables, not a lot of libraries. I think it matters more for libs. And I depend heavily on stack to make my executables easy to build.
08:36:28 <mpodien> i need a datastructure to store scale (?) information in. more precisely for every value bigger than X and smaller than Y I want to return A. What data structure would you use?
08:37:49 <mud> mpodien: Any more precise you can be? Not really clear what it should do otherwise.
08:51:12 <royal_screwup21> this line gives me a "parse error (incorrect indentation or mismatched brackets)": n`mod`(length (acc)+1). acc is a list. What am I doing wrong here?
08:51:32 <royal_screwup21> sorry, the line is: n`mod`(length (acc)+1)==0=[]
08:51:35 <rudyrudyrudy> quick question: If I have a infinite list of characters, how can I take as many characters as I want until I see a certain amount of one character?
08:52:21 <merijn> rudyrudyrudy: take?
08:52:21 <rudyrudyrudy> I have this: takeWords n char = takeWhile (\x -> length $ filter (== char) x <= x)
08:52:31 <rudyrudyrudy> I think it's something to do with takeWhile right?
08:52:38 <merijn> > take 10 [1..]
08:52:41 <lambdabot>  [1,2,3,4,5,6,7,8,9,10]
08:52:46 <merijn> ah, wait
08:52:53 <merijn> I see what you mean
08:52:56 <rudyrudyrudy> > takeWhile (\x -> x > 10) [1 .. 20]
08:52:58 <rudyrudyrudy> ok
08:52:58 <lambdabot>  []
08:53:05 <rudyrudyrudy> yeah, I don't get that
08:53:22 <merijn> You can't do that with takeWhile
08:53:28 <rudyrudyrudy> > takeWhile (\x -> x < 10) [1 .. 20]
08:53:29 <merijn> You'd have to write something using fold
08:53:29 <carbolymer> guys, do you have maybe any dockerfile with stack & ghc 8.2.1 which can be used to build static binaries? I've been trying to find one / create one using alpine or debian without success for two days :|
08:53:31 <lambdabot>  [1,2,3,4,5,6,7,8,9]
08:53:47 <rudyrudyrudy> really?
08:53:51 <merijn> carbolymer: Static Haskell libraries or static everything
08:54:00 <mpodien> use another parameter to store state (characters and character count)?
08:54:04 <merijn> rudyrudyrudy: takeWhile can't inspect how much it's taken so far
08:54:14 <rudyrudyrudy> I have an infinitely growing list of characters and I want to get X amt of words from it, but I dont know the word sizes, all I know is that the words are seperated by spaces.
08:54:30 <carbolymer> merijn, I want to compile my project and distribute as single statically bound binary
08:54:30 <rudyrudyrudy> well, if the list continually grows like "x" to "x x" to "x x x"
08:54:44 <rudyrudyrudy> cant I just do (\x -> (spaces x) < z) ?
08:55:02 <rudyrudyrudy> and it'll take everything underneath that condition?
08:55:05 <mud> rudyrudyrudy: unwords . take n . words    maybe?
08:55:11 <merijn> carbolymer: That's the default behaviour for Haskell. The only things linked dynamically are C libraries. You can make those static too, but I don't know exactly how
08:55:13 <rudyrudyrudy> ...
08:55:18 <rudyrudyrudy> i completely forgot about that..
08:55:19 <mud> royal_screwup21: Probably need context
08:55:25 <rudyrudyrudy> I dont know however, since its an infinite list
08:55:33 <rudyrudyrudy> hmm
08:55:37 <rudyrudyrudy> let me try that actually, thank you
08:55:37 <mud> It will change the answer if you have multiple spaces in a row though.
08:55:44 <rudyrudyrudy> it wont
08:55:48 <merijn> rudyrudyrudy: You're just trying to take the first N words?
08:55:51 <rudyrudyrudy> er, the markov generator only has one space
08:55:55 <rudyrudyrudy> yeah, of an infinite list
08:56:10 <merijn> rudyrudyrudy: Oh, that's much easier. mud's suggestion should work
08:56:16 <mud> words should work on an infinite list. I think it'll do like, progressive output.
08:56:26 <rudyrudyrudy> ah right because its like map
08:56:31 <rudyrudyrudy> tysm
08:56:45 <carbolymer> merijn, ok, but I am unable to install ghc 8.2.1 via stack because of cryptic error messages
08:56:55 <carbolymer> merijn, like: set_curterm: symbol not found
08:57:03 <merijn> rudyrudyrudy, mud: By default everything is lazy, so unless your function specifically needs the entire list (like length) everything works on infinite lists
08:57:11 <merijn> carbolymer: I don't use stack, so can't help you there
08:57:30 <mud> Wellll, it's certainly possible to accidentally make things more strict than they should be. But yeah, pretty much.
08:57:48 <merijn> mud: You can, but it's not the default
08:58:27 <rudyrudyrudy> Ok yeah, that kinda words like my old solution
08:58:43 <rudyrudyrudy> but if I have something or a string that has 5 spaces when I requeset 4, using that method I get an empty list and not what shouldve been evaluated
08:58:50 <rudyrudyrudy> I think im misunderstanding how takeWhile works
08:59:13 <merijn> rudyrudyrudy: takeWhile just stops after the first element that returns false
08:59:20 <merijn> rudyrudyrudy: It only looks at a single element at a time
08:59:28 <rudyrudyrudy> yes, but why does it return nothing?
08:59:45 <rudyrudyrudy> actually what might be my issue is that when im traversing a string, it
08:59:56 <rudyrudyrudy> ok yeah its not your solution, its just my input to takewhile
09:02:03 <rudyrudyrudy> if I have a list that adds a char with each new element, how do I construct a list like: [x], [x ++ x1], [x ++ x2 ++ x2]?
09:11:14 <mud> rudyrudyrudy: I'm not really sure what the result is supposed to be :-/
09:11:28 <mud> Something like 'tails' does?
09:11:36 <mud> Or inits maybe?
09:14:58 <yuh> anyone here?
09:15:03 <dmwit> no
09:15:24 <yuh> im new to this whole irc shit what exactly is this channel
09:15:50 <tdammers> yuh: type /about, that should tell you what this channel is about
09:15:54 <dmwit> This channel is for discussion of the Haskell programming language.
09:16:05 <glguy> tdammers: in which client?
09:16:15 <tdammers> glguy: shouldn't matter, should it?
09:16:18 <dmwit> You can learn more about Haskell, a lazy, strongly-typed language with type inference, at haskell.org.
09:16:26 <dmwit> tdammers: definitely matters
09:16:26 <glguy> tdammers: It'll certainly matter
09:16:35 <tdammers> oh right, ugh
09:16:38 <tdammers> :x
09:16:40 <dmwit> Basically everything you do that starts with / is client-specific.
09:16:58 <dmwit> I think /topic is the more standard name for that command.
09:17:14 <tdammers> so it is... ignore everything I say today
09:17:15 <dmwit> And of course there's nothing stopping a client from using a different prefix than /. =P
09:17:32 <yuh> so then this is a programming language?
09:18:14 <mud> yuh: Yep
09:18:53 <mbrock> offtopic question: where should I look for prior work on verifying logical claims against symbolic execution traces?
09:18:58 <yuh> then what function does the channel serve?
09:20:11 <dmwit> People chat about what they're hacking on, ask for advice, and chat about cool developments in the community.
09:20:19 <merijn> Speaking of which
09:20:32 <merijn> What was the cabal command to build+upload haddocks for a package?
09:20:53 <raynold> ahh it's a wonderful day
09:20:56 <glguy> merijn: See the bottom of http://hackage.haskell.org/upload
09:21:08 <yuh> what channel should i use for just random shit and discussion?
09:21:15 <yuh> idk the names of them
09:21:24 <glguy> Sorry yuh, this isn't a directory service
09:22:10 <yuh> could you at least point me in the right direction>
09:22:21 <yuh> ?*
09:22:21 <lambdabot> Maybe you meant: v @ ? .
09:22:42 <mud> yuh: #freenode might not be the worst place. Most clients have some kind of directory feature, list of channels, something.
09:23:33 <ski> yuh, mayhaps ##defocus ? (i have not been there)
09:30:22 <tabaqui> xmao
09:30:49 <tabaqui> two "Haskell devs" offer consultations for $100 per month
09:31:04 <tabaqui> and they are russians, I'm sorry for them
09:31:23 <tabaqui> what the heck? you can just come here and ask for help freely
09:32:01 <mud> There are limits of free help
09:32:11 <tabaqui> 1711 users right now
09:32:22 <mud> People only help until you get to the hard parts, then you're on your own. And you're limited by how bored people are.
09:32:58 <tabaqui> I do not think, that these guys can help you with hard parts neither
09:33:35 <merijn> Paying gets you help with boring parts too
09:33:37 <tabaqui> and of course they will not write code for you
09:35:31 <mrkgnao> tabaqui: I doubt it. I've written ~200 line gists for people who asked (nicely).
09:35:45 <tabaqui> mrkgnao: in one piece?
09:35:55 <mrkgnao> yes
09:36:03 <tabaqui> dude...
09:36:32 <mrkgnao> if I'm fooling around on teh interwebs, might as well play with Servant while I'm at it
09:36:37 <tabaqui> do you understand ContT monad well? :)
09:37:07 <ertes> does anyone know why IORef is non-strict in the underlying MutVar#?
09:37:14 <mrkgnao> I used to, but I've had few reasons to use it since.
09:37:17 <ertes> it seems like a pointless indirection to me
09:37:52 <tabaqui> mrkgnao: just kidding, I'll write my monad by itself :)
09:38:09 <tabaqui> *myself
09:38:09 <mrkgnao> sure. 
09:39:53 <ertes> :t withFile
09:39:55 <lambdabot> error:
09:39:55 <lambdabot>     • Variable not in scope: withFile
09:39:55 <lambdabot>     • Perhaps you meant one of these:
09:40:00 <ertes> :t System.IO.withFile
09:40:01 <lambdabot> FilePath -> GHC.IO.IOMode.IOMode -> (GHC.IO.Handle.Types.Handle -> IO r) -> IO r
09:40:03 <ertes> :t ContT
09:40:05 <lambdabot> forall k a (m :: k -> *) (r :: k). ((a -> m r) -> m r) -> ContT r m a
09:40:13 <ertes> mrkgnao: ^ have fun =)
09:40:36 <glguy> ertes: Why do you think it is non-strict in the MutVar#?
09:41:11 <ertes> glguy: because the source code says so: data STRef s a = STRef (MutVar# s a)
09:41:21 <ertes> (IORef is a wrapper around STRef)
09:41:31 <glguy> That's what the source says, yes, but that's not non-strict in the mutvar
09:41:31 <glguy> MutVar# :: * -> * -> TYPE 'UnliftedRep
09:41:52 <ertes> oh, i see
09:42:49 <glguy> There is some work to avoid the indirection, however, and allow mutable fields directly in data types
09:42:51 <dsal> I'm trying to convert some code from using String to Text -- is there a way to be a bit more flexible in the input?
09:43:19 <dsal> I figured IsString would be useful, but that seems only useful for OverloadedStrings
09:43:31 <glguy> ertes: https://github.com/yav/ghc/tree/wip/mutable-fields
09:43:38 <ertes> glguy: yeah, i'm aware that there is work in that direction, but nothing usable yet…  the only practical thing i have found that goes into that direction is the unboxed-ref package
09:43:42 <glguy> and there's a related discussion ticket on the topic
09:43:53 <ertes> glguy: thanks for the pointer
09:44:18 <glguy> The other bit of work in that direction I know of was https://github.com/ekmett/structs
09:45:18 <Tomsky> Hi, how does one format a number (with decimal places and appropriate thousand separators) in a locale correct way in Haskell?
09:45:53 <ertes> glguy: i think i'll just wait for mutable fields for now
09:46:06 <ertes> and use IORef in the meantime
09:46:50 <ertes> it's not overly important right now, but it should give a considerable speed boost once they arrive
09:47:45 <EvanR> Tomsky: how do you do that in other languages?
09:48:48 <Tomsky> EvanR: for example in Java, https://docs.oracle.com/javase/7/docs/api/java/text/NumberFormat.html
09:49:22 <Tomsky> Or in C# https://msdn.microsoft.com/en-us/library/system.string.format(v=vs.110).aspx
09:49:38 <EvanR> what about C
09:50:20 <dmwit> Tomsky: Looks like there are bindings to lconv here: https://hackage.haskell.org/package/bindings-common-1.3.4/docs/Bindings-C-Locale.html
09:51:01 <dmwit> Well, bindings to retrieve the lconv, anyway. You'll probably have to consume the lconv to do the formatting yourself.
09:51:40 <EvanR> strfmon ?
09:51:53 <Tomsky> Yeah sure you can get it by wrapping an OS level C library, I was wondering if there was any native support for locales in Haskell.
09:53:11 <dmwit> You can get it that way. And you should. And what's more, you should wrap it up in a way that others can use it and then put it on Hackage. =)
09:53:31 <Tomsky> Hehe, I'm amazed no-one has done it already :-)
09:54:19 <EvanR> haskell programmers mainly consume numbers unformatted haha
09:54:30 <EvanR> and are bad at GUIs
09:55:37 <tdammers> everyone is bad at GUIs, the difference is that other language cultures are more willing to compromise
09:56:10 <Tomsky> Hehe, it's not even for a GUI .. it's just correctly formatting a number :-)
09:56:22 <Tomsky> Anyway, thanks for your help guys :-)
09:56:28 <merijn> UIs require a lot of work
10:06:31 <tdammers> yes, and a lot of that work is terribly boring
10:06:52 <tdammers> and none of the approaches towards making it less boring are very good
10:07:04 <tdammers> some are better than others, but they all have terrible terrible corners somewhere
10:17:04 <black0range> Hello, are there some known nice ways to solve the max-flow problem using a "pure" style? (And still keep a reasonable performance)
10:22:21 <bigos> I have 64 bit windows. How do I make sure haskell uses 64 bit libraries instead of giving me an error about 32 bit libraries missing
10:27:34 <Cale> black0range: There's some discussion of it in here http://macau.uni-kiel.de/servlets/MCRFileNodeServlet/dissertation_derivate_00006562/dissDanilenko.pdf
10:29:24 <Cale> black0range: But I think it just amounts to more or less the same thing as a traditional algorithm
10:29:41 <Cale> (but using immutable finite maps of some sort)
10:30:55 <black0range> Interesting, i'll read through it. Thanks! :)
10:30:57 <Cale> (only perhaps explained better)
10:31:32 <geekosaur> bigos, make sure you have a 64 bit ghc. if it's looking for 32 bit libs then it is a 32 bit build, because you can't mix 32 and 64 bit libs on windows
10:37:38 <schell> is there an “easy” way to figure out what all the minimum bounds of your cabal project’s deps can be?
10:38:31 <Cale> Not really, it's a tricky problem
10:40:32 <schell> Cale: yeah, so far my solution has been to let emacs auto-complete put in whatever the dep version is in my current stackage resolver, then relax that if someone has a problem
10:44:29 <bigos> geekosaur, is it possible to find it on the command line? how do I know which version I am running?
10:45:49 <geekosaur> ghc --info, look for "Target platform" or "Target arch"
10:46:13 <geekosaur> and it should say x86_64, not just x86
10:47:18 <zwarag> Noob here, I'm trying to make two INT lists the same length but fail due to some type error: lpaste.net/359726a 
10:48:10 <bigos> geekosaur, arrrrrgh! target_os OSMinGW32, target arch ArchX86_64
10:48:25 <geekosaur> that sounds like it should not be complaining about 32 bit libs then
10:48:34 <bigos> at what pointshould I curl in the corner an weep?
10:48:35 <geekosaur> possibly a problem with your mingw install
10:49:18 <glguy> zwarag: There's no error message in that paste
10:49:27 <bigos> thanks, that helped me to move one step forward
10:49:46 <bigos> I will check my mingw install
10:50:27 <Cale> zwarag: You need to give the function a *pair* of lists rather than two separate arguments, since that's what type you gave it.
10:50:39 <bigos> but 64 libraries work fine with Lisp, is it possible to specify 64 bit in cabal?
10:51:19 <geekosaur> the other possibility is you somehow installed something that is 32 bit only and it is trying to find more 32 bit libs for compatibility, but I don't think it would be a haskell lib doing that but some native/FFI lib
10:51:21 <Cale> zwarag: Also might be worth noting that this algorithm you've written is O(n^2)
10:51:43 <geekosaur> or, possibly you somehow installed a 32 bit cabal
10:51:47 <Cale> zwarag: since it recomputes the lengths of the lists over and over
10:52:59 <geekosaur> uh, also note I am not an expert on windows, but nobody else seems to be answering and I have some (not a lot) experience
10:54:49 <zwarag> Cale: Thank you very much for the time. Appreciate it.
10:55:14 <bigos> i will go back to Linux then :-)
11:25:34 <Fuuzetsu> @pl f x y = pure (x, y, x + y)
11:25:34 <lambdabot> f = (pure .) . liftM2 ap (,,) (+)
11:26:23 <Fuuzetsu> @pl f x y = return (x, y, x + y)
11:26:23 <lambdabot> f = (return .) . liftM2 ap (,,) (+)
11:32:03 <t7> interesting haskell vs clojure thread starting on hackernews
11:42:02 <monochrom> Oh w00t 8.2.2 RC2
11:42:59 <monochrom> haha "ghc-pkg now works even in environments with misconfigured NFS mounts"
11:43:50 <geekosaur> that was actually bothering a fair number of folks
11:44:06 <monochrom> That's a bit sad.
11:45:04 <monochrom> But one day, we're going to be able to boast "GHC now works even for source files from misconfigured Notepad"
11:45:57 <geekosaur> I'm also not entirely sure that's an accurate description of the real problem, but I haven't seen the latest on the ticket
11:46:36 <monochrom> And the cabal team will also say "cabal now can download stuff even through misconfigured proxy and broken wifi"
11:47:33 <geekosaur> neh. nfs has its own fun issues
11:48:33 <c_wraith> monochrom, you mean like... "ghc now figures out what your mixed tabs and spaces were supposed to mean"?
11:48:47 <monochrom> That's too easy.
11:48:50 <geekosaur> (and nfs being stateless means it actually recovers from a number of problems... but misconfiguring it can make it think it hasn't recovered)
11:49:14 <monochrom> I have in mind some files being in UTF-16, and some being in UTF-32.
11:49:33 <dogui> is there a hacky way to print something of any type? without a show instance I mean
11:49:50 <dogui> like %A in F#
11:50:37 <c_wraith> dogui, how hacky? there are things that introspect the stg memory layout
11:51:15 <c_wraith> and that's really all you can do with data of an unknown type.
11:51:24 <dogui> c_wraith: that might work, how does one do that? :)
11:52:14 <c_wraith> I don't ever remember the package names. it's not something you want to do yourself.
11:52:23 <dogui> right
11:52:43 <dogui> this is just for debugging, so I won't throw in another problem over me just yet :)
11:52:47 <dogui> c_wraith: thanks a lot!
11:59:36 <toto008> May I please ask a general learning guidance question here.
12:00:17 <toto008> May I please ask a general learning guidance question here.
12:00:58 <johnw> of course you may
12:01:03 <johnw> in fact, you needn't even ask before asking
12:04:02 <toto008> johnw: I am new in development field and for my first Job interview I am given an assignment which I have to do in a week. For that I need to learn two new languages and one framework. I want to ask is that a good approach to learn?
12:04:45 <Athas> Under stress, with a hard deadline, and fueled by external motivation?
12:04:46 <Athas> No.
12:04:59 <johnw> toto008: I'm happy to answer in private message, but this is a bit too general to be discussed here
12:05:07 <johnw> we generally take Haskell questions
12:05:49 <toto008> johnw: How can i pm you?
12:10:14 <nicknight> toto008:  if you are rich/have money take time to learn...if poor andcant survive without job learn basic syntax/concepts ans use your creativity to impresess interviewer and one week you can spend 40hous learning
12:11:12 <nicknight> even 60 hrs* based on your concentration and patience
12:12:59 <greymalkin> If I have -fwarn-unused-top-binds turned on, is there a way to selectively annotate a function to be ignored by that?
12:13:18 <greymalkin> er... -Wunused-top-binds
12:31:01 <crucify_me> hi is there a way to not use these six special chars and put the 2nd argument of mod at 52 ? http://lpaste.net/359727  thanks
12:33:35 <n_blownapart> sorry disconnected :  reposting :    hi is there a way to not use these six special chars and put the 2nd argument of mod at 52 ? http://lpaste.net/359727  
12:34:40 <johnw> greymalkin: I've wanted annotation-based warning suppression for some time
12:35:07 <johnw> sadly, I don't think it's supported yet: https://stackoverflow.com/questions/41768887/how-can-i-disable-haskell-warning-in-small-block
12:43:30 <geekosaur> c `elem` "[\\]^_`"
12:44:27 <greymalkin> johnw: Yeah, I've been scouring the pragmas; the only useful function-level annotation I've found is the INLINE and NOINLINE.
12:45:50 <geekosaur> and to be honest you probably don't want isLower or isUpper there either, because you're obviously one of those who thinks characters outside 1960s-vintage US-ASCII aren't characters
12:47:04 <geekosaur> > isUpper 'ẞ'
12:47:07 <lambdabot>  True
12:47:55 <geekosaur> well, maybe not so obviously, but any time I see something like that I have to suspect it
12:47:59 <Psybur> > isUpper '🤔'
12:48:01 <lambdabot>  <hint>:1:10: error:
12:48:01 <lambdabot>      lexical error in string/character literal at character '\129300'
12:48:10 <geekosaur> mostly because too many programmers are still guilty of it
12:51:33 <tom_> What does the | operator do in haskell?
12:51:42 <mniip> it's not an operator
12:51:47 <mniip> as a token it does many things though
12:52:20 <mniip> guards, list comprehensions, variants of datatypes, docstrings in comments
12:52:22 <tom_> I am trying to understand this code [x*2 | x <- [1..10]]  
12:52:31 <merijn> tom_: That's a lit comprehension
12:52:33 <mniip> yeah that's a part of list comprehension syntax
12:52:44 <tom_> so its like to or operator?
12:52:46 <mniip> it always goes like [expr | binds or guards]
12:52:48 <tom_> the*
12:52:55 <merijn> tom_: Do you know python?
12:53:03 <tom_> a bit
12:53:10 <tom_> why?
12:53:16 <mniip> tom_, it's not an operator it's a piece of syntax
12:53:23 <mniip> like comma, semicolon, etc
12:53:28 <tom_> oh ok
12:53:48 <merijn> tom_: [x*2 | x <- [1..10]] syntax is basically "[x*2 for x in [1,2,3,4,5,6,7,8,9,10]]" in python
12:54:49 <tom_> so the arrow operator is equal to in in python and the | syntax just separates it?
12:55:02 <mniip> again it's not an operator
12:55:13 <merijn> tom_: Those aren't operators, though, just syntax
12:55:14 <tom_> oh yeah
12:55:31 <tom_> used to c sry ^^
12:55:50 <mniip> you wouldn't call ; an operator in C
12:55:55 <bigos> I have not given up on making Haskell on Windows work. This is description of my way of installing Haskell
12:55:58 <tom_> so what dose [x|2] mean?
12:56:01 <mniip> nor uhhhh
12:56:01 <bigos> https://gist.github.com/bigos/487ded42108253b560e591f57e34f425
12:56:03 <mniip> {
12:56:09 <mniip> tom_, that's a type error
12:56:22 <bigos> and relevant ghc info shows something like
12:56:35 <merijn> bigos: Have you tried installing via stack?
12:56:38 <bigos>  ,("Build platform","x86_64-unknown-mingw32")
12:56:42 <tom_> oh sorry i am not quiet getting when you would need to use [|]
12:56:48 <tom_> |*
12:56:52 <bigos> merijn, yes
12:57:02 <merijn> bigos: Didn't work?
12:57:03 <mniip> tom_, all list comprehensions are of the form [expr | binds or guards]
12:57:12 <tom_> what is a bind or guard?
12:57:16 <mniip> for example:
12:57:27 <mniip> > [ x + y | x <- [1..10], y <- [1..10], x * y == 4]
12:57:29 <lambdabot>  [5,4,5]
12:58:05 <mniip> this iterates over all x in [1..10] and all y in [1..10], and selects those pairs for which x * y == 4, and returns x+y for them
12:58:09 <geekosaur> [ expr | binds_or_guards ] where binds_or_guards is 1 or more of ``` pat <- expr ``` or ``` boolean_guard_expr ``` separated by commas
12:58:32 <mniip> tom_, in this case "x <- [1..10]" is a bind and "x * y == 4" is a guard
12:58:51 <bigos> merijn, i still get the error aaDLL libcairo-2.dll (Win32 error 127)
12:58:53 <mniip> a bind always goes like "pattern <- expr"
12:58:53 <geekosaur> | does not act as an operator, the entire construct is specific syntax. which is to say you can't pop that out in the middle of another list
12:59:01 <tom_> so i guard is like an if statement?
12:59:06 <mniip> kind-of
12:59:45 <tom_> and the bind is just setting the variables x and y equal to somthing
12:59:55 <tom_> and then it adds them together?
13:00:02 <tom_> and returns
13:00:19 <mniip> kind-of
13:01:06 <mniip> tom_, are you good with math?
13:01:13 <tom_> kind of
13:01:18 <tom_> try me
13:01:45 <mniip> tom_, do you know about first-order logic?
13:01:51 <tom_> no
13:01:53 <mniip> free and bound variables in expressions?
13:01:56 <mniip> aw, shame
13:02:43 <tom_> i think i get the idea though so thanks
13:04:10 <mniip> the notion of binding is closer to 'bound variables' in that, than to actually setting variables in a programming language
13:05:09 <mniip> in haskell variables are like in math: they "vary over a range of values". They don't exactly get set to different values like in C
13:06:27 <merijn> What's the escape character for backspace? (like \n is for newline)
13:06:40 <tom_> so this [ x + y | x <- [1..10], y <- [1..10], x * y == 4] can be translated as
13:06:45 <tom_> ...
13:07:38 <Forlorn_> Hi, I created a new stack project, added ncurses and did the stack solver, I can build just fine now, but when I try to run `stack ghci` I get error
13:07:41 <Forlorn_> http://sprunge.us/MVDC
13:08:08 <tom_> [return x + y, x = [somthing between 1 and 10], y = somthing between 1 and ten, make sure whatever x and y end up being equa to give the product of 4]
13:08:21 <tom_> equal*
13:09:50 <MarcelineVQ> Forlorn_: stack only deals with haskell related things, and error like that sugests sounds like you don't have ncurses (the c library) installed at the OS level or have the wrong version from what's expected
13:11:00 <geekosaur> you may not get to force narrow library there, because my guess is that libpanel.so is a linker script pointing to -lpanelw
13:11:27 <geekosaur> this will be your OS/distro and stack can't do anything about it, ghc can't do anything about it
13:13:08 <geekosaur> (that is, libpanel.so will be a text file containing the string "INPUT(-lpanelw)")
13:19:39 <MarcelineVQ> assuming you're on arch, aur has  ncurses5-compat-libs  which may be something to look into, not sure. it may not be effective for the reason geekosaur is pointing out.  if you just want to play on the console and aren't dead set on ncurses there's other options like brick or vty
13:22:22 <merijn> MarcelineVQ: vty and brick still depend on ncurses, though
13:22:36 <merijn> MarcelineVQ: They use it for the terminfo API
13:26:58 <simendsjo> I've worked through HPFFP two times, but I would like to understand more of the underpinnings. Trying to look at the Lens library blows my mind, but I would really like to understand what is going on. Pro, Co, Bi, Endo, Iso, etc etc. What are some good starting places to continue reading about these things? Bartosz Milewksis category theory blog? Some books? It's difficult to know where to start.
13:27:23 <MarcelineVQ> merijn: huh really?
13:28:28 <merijn> MarcelineVQ: hmm, maybe not anymore
13:28:48 <merijn> simendsjo: Honestly, there's not really clear path to that
13:29:16 <merijn> simendsjo: It's a bit of algebra, bit of category theory, bit of reading blogs, etc.
13:29:41 <merijn> simendsjo: Also, lens is pretty damn confusing to look at, so don't be too worried about that
13:30:13 <MarcelineVQ> lens does have pretty good documentation itself I'm told
13:31:06 <simendsjo> A bit discouraging :( I see that Lens might not be the best starting point. I guess everything by Kmett will be way too hard. But I believe that understanding the theory behind it would be beneficial -- I would never have come up with a similar design myself, which I find intriguing.
13:31:46 <merijn> simendsjo: Honestly, I learned most of the stuff I know by idling here for a year or so and struggling through blogposts
13:31:57 <MarcelineVQ> you could ask edwardk about it when he's around as well, he's really quite approachable and explains things gently
13:32:03 <merijn> And asking lots of things here
13:32:06 <edwardk> ?
13:32:11 <MarcelineVQ> he'
13:32:21 <merijn> edwardk: That you're a mean curmudgeon ;)
13:32:28 <edwardk> oh, yeah, i am
13:33:07 <MarcelineVQ> d like to know where to learn about the ideas underpinning the lens lib, broad topic as it is :> he being simendsjo
13:33:12 <merijn> simendsjo: Just as you figure out the stuff he's written, he goes off making up more new stuff, hopeless struggle :p
13:33:16 <edwardk> simendsjo: the key thing to know about lens is that the types aren't really designed first and foremost for approachability, but rather so that the bits and pieces all work when put together in unexpected situations.
13:33:52 <edwardk> normally i advocate everybody to read the types and understand the classes and laws, involved. with lens i usually advocate the opposite approach. learn how a few of the combinators work in practice
13:34:15 <edwardk> then as you get some intuition for that it'll help guide your understanding about the classes and the types that are involved in making that experience smooth
13:34:48 <Forlorn_> MarcelineVQ, how do I find out about the "expected version"?
13:34:50 <edwardk> but unlike most haskell code you really don't want to try to reason about it in a void from first principles, not unless you have some serious chops working with the classes underneath
13:35:12 <edwardk> the basic lens/traversal construction that spj goes through in his talk are pretty approachable
13:35:22 <edwardk> but after that it dives deep down the rabbit hole
13:36:14 <edwardk> and its mostly because what happened with the simple designs for lens libraries i tried to use before this (data-lens, etc) is that you'd write a bunch of code using the simple types they offered, but then you'd need a second target or a type would change just a little bit and you had to rip out and replace all the code you'd written with pretty lenses with the boring direct code anyways
13:36:42 <edwardk> so the lens library was designed to avoid running into that situation. you should always have _some_ "lensy" way forward, to avoid having to throw out all your code
13:36:56 <edwardk> but this means that a ton of info leaks into the types
13:37:11 <edwardk> this can make the error messages pretty awful
13:37:12 <MarcelineVQ> Forlorn_: I really don't know :( first thing to look into is why you don't have libpanel.so if indeed you don't have libpanel.so
13:37:24 <monochrom> Oh so this is why you called it Control.Lens instead of Data.Lens? Because there was a superceded data-lens?
13:37:38 <edwardk> monochrom: yeah =)
13:37:49 <monochrom> Because I've always found Control.Lens and Data.Machine swapped.
13:38:03 <MarcelineVQ> Forlorn_: or rather why you don't have panelw, because you do have libpanel.so, it just points to panelw
13:38:18 <simendsjo> Thanks. I guess just using it a lot would give some intuition on how everything fits together. But how did you guys learn about theory? Wikipedia isn't exactly very approacable, and just fumbling blindly understanding bits and pieces over a long time seems quite inefficient. I'm not in a position to introduce it at work, so it will just be a learning process for some time.
13:38:22 <edwardk> meh control is data, data is control =P
13:38:26 <merijn> We should just get rid of Control/Data prefixes :)
13:38:27 <monochrom> It's like "Love Is Hate. Lens Is Control and Machine Is Data".
13:39:05 <merijn> simendsjo: Edward has a good talk on youtube on lens
13:39:08 <merijn> @where lens
13:39:08 <lambdabot> #haskell-lens | http://lens.github.io/ | https://github.com/ekmett/lens | http://www.youtube.com/watch?v=cefnmjtAolY&hd=1
13:39:13 <dibblego> simendsjo: this is an excellent tutorial/article imo https://github.com/ekmett/lens/wiki/Derivation
13:39:14 <merijn> I think that's the one
13:39:27 <simendsjo> The way Lens is able to be used across so many different structures and how nicely they compose almost looks like a killer feature -- much like I think Type Providers is a killer feature of F#.
13:39:57 <edwardk> simendsjo: the theory started out by understanding the naive getter/setter pair notion, then there was a curious little post by twan van laarhoven back in the day that showed you could use forall f. Functor f => (a -> f a) -> s -> f s    as a way to encode a lens from s to a.
13:40:06 <simendsjo> Thanks. I've seen the video, which really helped. The article looks useful too.
13:40:36 <edwardk> and at some point roconnor ripped the type signature off and realized that you could change types, and realized traverse looked very similar
13:41:24 <edwardk> but this was after a bunch of false starts where everybody and their brother said, well, you have a getter :: s -> a   and a setter :: s -> a -> s so maybe there should be some kind of monadic version with side-effects?
13:41:33 <edwardk> s -> m a,  s -> a -> m s
13:41:42 <edwardk> but nobody could ever give me laws for them
13:41:55 <edwardk> so the first avenue folks tried to use to generalize lenses was a rather complete dead-end
13:42:38 <edwardk> then the second avenue was realizing that s -> a,    and s -> a -> s    share a common s prefix. this leads to the s -> (a, a -> s)      or s -> Store a s      store comonad coalgebra encoding we tried for data-lens
13:43:28 <edwardk> but it turns out that the s ->  common prefix was sort of an accident (for a deep fundamental reason)  and given that local optimum you could never find prisms and the like
13:44:20 <edwardk> figuring out prisms and isos and how to encode those and indexed traversals and the like was a big cooperative effort over on the #haskell-lens channel
13:47:40 <simendsjo> Good to hear that you guys don't just get epiphanies all the time and only do the correct thing from the start :) I'll continue taking my baby-steps in the dark with lenses and all the other foreign abstractions.
13:47:56 <merijn> simendsjo: I get epiphanies all the time
13:48:16 <merijn> simendsjo: You know, after I spend 2 weeks fulltime trying all the million ways it DOESN'T work
13:50:29 <simendsjo> Hehe. It's just difficult to get time for deepdives into Haskell when I'm not using it at work.
13:51:01 <merijn> Solution, just start secretly using it at work ;)
13:51:43 <Psybur> merijn, do you mean secretly using it FOR work, or merely just AT work :D?
13:52:10 <merijn> Psybur: Why not both? :p
13:52:14 <Psybur> <:D
13:53:03 <Tuplanolla> People will catch on to you once they realize everything you write anymore is an edsl.
13:53:09 <simendsjo> If I was working in-house, I might have considered using it for small ad-hoc tools and projects, but as an external consultant I feel I can't :) And I'm having a hard time getting my coworkers to look at F# even though we have some F# codebases too :/
13:55:16 <Tuplanolla> It doesn't even have to be Haskell.
13:58:51 <Psybur> Tuplanolla, do you use free monad + interpreter for everything? :D
13:59:23 <edwardk> simendsjo: i spent the last week or so working out that every idea i just had about fiddling with SKI combinators was buried in an old paper from 84 that I didn't know about.
13:59:34 <Tuplanolla> Not really, Psybur. I can show you what I mean soon.
13:59:52 <edwardk> simendsjo: a huge amount of my time is spent reinventing or learning things that other folks have done
13:59:54 <Psybur> Tuplanolla, Im leaving now but dont forget! ;p
14:00:33 <simendsjo> edwardk: I don't doubt it. I've come to the conclusion that I've never had an original idea, never will have, and all work I've ever done and ever will do would be done a lot better by someone else :)
14:01:10 <geekosaur> flip side is presentation counts for a lot, as does collation
14:01:13 <Sornaensis> whoa a wild edwardk appears
14:01:50 <bitemyapp> Sornaensis: you just have to say one of the magic words, it's like summoning Beetlejuice
14:02:49 <edwardk> i try to rotate the magic words otherwise i spend way too much of my day granting wishes
14:03:29 <merijn> bitemyapp: I thought it was just a matter of pinging his name all day :p
14:05:45 <edwardk> I turn off the keywords entirely occasionally otherwise folks get the idea that all they have to do is chant "Iä! Iä! Comonad fhtagn!"
14:12:45 <qqkami> https://pastebin.com/Q8ujk6ah
14:13:35 <qqkami> oh nvm i have to call abs on one number i think - sorry
14:13:42 <monochrom> You should use div instead. / is for fractions.
14:14:04 <bigos> probably my previous Gtk install problems were caused by 2 different msus2 installs one came with haskell platform and the other was installed separately
14:14:17 <edwardk> qqkami: also the needless tupling is weird
14:14:30 <geekosaur> also that's (gcd a b)
14:14:39 <monochrom> @type lcm
14:14:41 <lambdabot> Integral a => a -> a -> a
14:14:43 <edwardk> lcd a b = abs (a*b) / gcd a b -- would be more idiomatic
14:14:47 <edwardk> er lcm
14:14:54 <geekosaur> unless you defined your own
14:15:09 <edwardk> and yeah div
14:15:28 <bitemyapp> edwardk: well I wasn't going to say what the keywords were
14:16:13 <edwardk> @pl \a b -> abs (a*b) `div` gcd a b
14:16:13 <lambdabot> ap (ap . ((div . abs) .) . (*)) gcd
14:16:35 <edwardk> you know you've been spending too long compiling to combinators lately when that reads intuitively
14:22:43 <qqkami> thanks i figured out how to fix it but i still dont get why i had the following issue with my previous version in the pastebi
14:22:45 <wz1000> S = ap , no?
14:22:52 <wz1000> for (->)
14:23:08 <qqkami> it said something along hte lines of (Integer,Integer) -> (Integer,Integer) i line 6 which is my lcd thing
14:23:13 <geekosaur> :t (/)
14:23:14 <lambdabot> Fractional a => a -> a -> a
14:23:24 <geekosaur> ^ Integer does not have a Fracitonal instance
14:23:32 <geekosaur> :t div
14:23:33 <lambdabot> Integral a => a -> a -> a
14:24:33 <qqkami> sadly i didnt screenshot it or something :/ 
14:24:48 <wz1000> why does unsafeCoerce () :: ByteString in ghci result in a segfault, but unsafeCoerce (unsafeCoerce () :: ByteString) :: () work fine?
14:25:18 <qqkami> i don't ge the -> (Integer,Integer) part when no function produced an Integer,Integer tupel output
14:25:33 <geekosaur> wz1000, because the latter isn't trying to inspect the intermediate
14:26:46 <geekosaur> the intermediate ByteString is invalid and will dump core if you try to do anything with its value, but immediately unsafeCoerce-ing back to () is ok
14:27:46 <wz1000> is there any way to inspect the raw memory contents of a value?
14:28:00 <Tuplanolla> Can you really `unsafeCoerce` to a value that might contain pointers without having to worry about the garbage collector inspecting it, geekosaur?
14:28:05 <merijn> wz1000: Yes, no, maybe
14:28:12 <wz1000> I suppose you would atleast NFData
14:28:17 <merijn> wz1000: It depends on exactly what you want and how good you are at voodoo
14:28:18 <geekosaur> unsafeCoerce is all in the typechecker
14:28:19 <wz1000> *need
14:28:55 <geekosaur> it does nothing with the value, it just changes what the typechecker thinks its type is
14:29:10 <geekosaur> and it shouldn;'t involve any code at all at runtime
14:29:19 <Tuplanolla> Okay, good.
14:33:50 <qqkami> i guess this is a good place to ask a question regarding my haskell class ive been wondering about
14:34:16 <qqkami> we use hugs which is not developed anymore (and our lecturer knows that) - any idea why that choice could have been made?
14:34:38 <glguy> What'd the lecturer say?
14:34:45 <mud> Historical reasons probably, like it's what they've been using for a while I'd assume.
14:35:33 <qqkami> glguy: havent had the chance to talk to them yet
14:36:04 <qqkami> but imo a university shouldn't keep something just because of historical reasons mud
14:36:11 <glguy> Maybe just shoot one of them an email
14:36:12 <qqkami> shouldnt they strive to use newer technology available 
14:36:47 <qqkami> glguy: guess ill have to do that - was wondering if any of you had an idea (perhaps some big restructuring to move from hugs or something)
14:37:03 <sm> hugs was considered to be more beginner friendly
14:37:22 <Hafydd> My university also used hugs, and I wasn't able to find out why. It might have something do with the fact that GHC is several GB in size, though.
14:37:23 <sm> less time wasted on package snafus, eg
14:37:24 <glguy> There isn't a good reason to use Hugs in general anymore, but maybe these lecturers have some reason specific to the course
14:37:24 <mauke> yeah, 12 years ago
14:37:49 <mauke> the usual reason is that hugs is what those lecturers learned on
14:38:01 <mauke> they don't follow haskell in general and aren't aware of ghci
14:38:20 <geekosaur> there's also the argument that some of ghc's type errors are less than helpful these days, pointing you to extensions when you had a typo/thinko
14:38:39 <merijn> Aha! Look at this gorgeous coloured + folded output: https://travis-ci.org/#L675
14:38:47 <geekosaur> like if you confuse type and data constructors like learners do
14:39:04 <merijn> geekosaur: Pretty sure GHC errors are more helpful nowadays and even more so in 8.2
14:39:16 <Tuplanolla> I just turn on `DataKinds` to make up for my poor typing skills.
14:39:33 <Hafydd> merijn: I don't think that URL links to what you intended.
14:40:01 <mud> qqkami: Everything happens for historical reasons.
14:40:14 <merijn> Hafydd: hmm, that's dumb UI design on their part
14:40:18 <qqkami> just to make sure: to get the lcm of two primes i just multiply them by each other right? makes sense in my head and it would als fit the criteria that each number can be written as a prime factorisation 
14:40:22 <qqkami> mud i guess so
14:40:37 <glguy> qqkami: In most cases
14:40:42 <merijn> Retry: https://travis-ci.org/merijn/tasty-travis/builds/295965219#L675
14:40:58 <qqkami> glguy: in most cases only, why is that?
14:41:27 <qqkami> guess this is more math related than haskell related so sorry if this isn't the right place
14:41:33 <mud> qqkami: Two non-equal primes I assume?
14:41:47 <qqkami> mud: oh, yes non equal primes 
14:42:00 <mud> Then I'd think yes. At least I don't see anything wrong with that logic.
14:42:21 <mud> It's like ....  a * b / gcd(a,b)   or something, right? So ya
14:42:36 <qqkami> yes abs(a * b) / gcd(a,b)
14:42:51 <qqkami> perhaps glguy was saying almost in case of equal primes
14:43:26 <qqkami> thanks!
14:45:34 <mud> qqkami: Anyway, I'd think almost anything you learn will be easy to transfer over to using GHC. The most that's changed is ... I mean a lot more extensions, but some of the basic functions got generalized a bit, like Foldable, and uhm, I guess Applicative/Monad became more related.
14:46:05 <geekosaur> Num changes are also likely to cause issues
14:46:24 <geekosaur> specifically you need Show and/or Eq explicitly in more places
14:46:41 <mud> Oh, right.
14:47:18 <qqkami> mud: alright - shouldn't bee too much of an issue then
14:47:33 <qqkami> geekosaur: we havent touched on what Eq is yet, but Show is so i can return a String right?
14:47:50 <merijn> qqkami: Yeah
14:47:54 <geekosaur> it provides a String representation for a value, yes
14:48:06 <mud> The biggest practical thing would be learning how to set up an environment (install GHC, etc.), but they probably wouldn't go through that much anyway. At least none of my classes did.
14:48:40 <geekosaur> Num used to require that those instances exist, but in modern ghc it doesn't any more so you may find code that doesn't typecheck with just a Num instance in the context but also needs Show and/or Eq instances
14:48:43 <qqkami> mud: i use linux so i just install it from the repositories anyways - but yeah they didnt tell us how to set up hugs either
14:48:55 <merijn> mud: tbh, installing GHC and cabal isn't that hard. I would actually say I wish more languages were as convenient as GHC Haskell
14:49:36 <qqkami> geekosaur: okay, seems like that would be something thats easy to pickup afterwards though
14:49:37 <mud> qqkami: I'd actually recommend against that for practical work. What's in the package managers for any linux I know is ... not great. I'd just use stack, or cabal-install and install GHC manually
14:49:42 <geekosaur> these kind of changes might actually be why courses stick with hugs, specifically that it is *not* changing like this all the time
14:49:46 <mud> But for playing around it might be fine.
14:50:03 <mud> merijn: It's not really too bad, no.
14:50:06 <geekosaur> Gram Hutton was iirc not very pleased when AMP and FTP landed in the middle of his working on the 2nd edition of his book
14:50:09 <geekosaur> *Graham
14:50:27 <merijn> mud: With new-buid it's even easier
14:50:28 <mud> Haha, I bet.
14:50:38 <qqkami> mud: so basically the ghc can be compiled with different "flags" or something and the default ones in package managers arent that great?
14:50:45 <mud> merijn: Oh? Does it help install GHC or something now?
14:51:12 <merijn> mud: Doesn't help installing GHC, but you no longer have to fiddle with sandboxes
14:51:21 <mud> qqkami: Mostly they're just out of date, and the haskell library packages in the package managers make everything a mess. You really want to use sandboxes, in either stack (implied and automatic) or cabal-install (use the new-build stuff)
14:51:35 <mud> merijn: Ah, ya that's a good thing.
14:52:10 <merijn> mud: It's absolutely trivial to make packages use local versions of dependencies and you end up building a lot less (since it reuses stuff when possible)
14:52:55 <bitemyapp> merijn: Stack also does this, but in the process, also handles installing a version of GHC that's compatible with your packages.
14:52:57 <mud> Well, with stack it's at least unhelpful. AFAIK it just ignores all of that now, your system GHC and system packages and etc.
14:53:21 <qqkami> mud: i use a running release system so i'd hope mine isn't out of date - but if i do end up using haskell after the course (and i might since it seems neat) ill look into that - tahnks
14:53:33 <bitemyapp> mud: Stack used to use system GHC when one existed but it caused problems for people who had a version of GHC incompatible with their packages and didn't know it.
14:53:45 <bitemyapp> now you have to explicitly set your config to permit system GHC use.
14:53:48 <bitemyapp> but the option still remains.
14:54:15 <mud> bitemyapp: Right, it is an option but ... I'm glad it's not the default anymore. It seemed to cause more problems than it was worth.
14:54:31 <merijn> bitemyapp: Stack really, really, really doesn't work for me, though
14:54:48 <qqkami> digits = [0,1,2,3,4,5,6,7,8,9] :: Int
14:54:56 <mud> merijn: As in it crashes, or you just don't like how it wants you to do things?
14:55:01 <mauke> qqkami: a list is not an Int
14:55:02 <merijn> mud: The latter
14:55:04 <qqkami> thats a given line of code in my homework but im getting an error
14:55:16 <merijn> mud: Stack wants me to do things completely different from how *I* want to do things
14:56:12 <mud> Yeah, fair enough. I find cabal-install much more of a real option now that new-build and such exists, but I still like stack better. It works how I want to really.
14:56:45 <qqkami> oh mauke they updated it i didn't see :: [Int] works now 
15:04:24 <fresheyeball> how can I get failover type behavior with Either?
15:04:31 <fresheyeball> is there a <|> that works with Either?
15:04:35 <fresheyeball> I expect
15:04:45 <fresheyeball> Right 1 <|> x = Right 1
15:04:53 <fresheyeball> Left 1 <|> x = x
15:05:17 <fresheyeball> is there such a thing?
15:10:19 <iqubic> Arrows are hard to grok for me.
15:10:49 <iqubic> Anyone have a good tutorial for them?
15:11:24 <merijn> iqubic: Honestly, arrows have mostly fallen out of favour
15:12:00 <iqubic> What do people use instead?
15:12:02 <merijn> iqubic: Turns out the typeclass isn't quite as useful as was hoped and several other more useful classes have stolen it's usecases (Category, Profunctor and Bifunctor, to be exact)
15:12:16 <iqubic> Ah, I see.
15:12:42 <iqubic> Are Kleisli arrows still used?
15:13:11 <merijn> Considering that's just a fancy name for "a -> m b", I'm sure they are :p
15:13:48 <dmwit> `Kleisli` the type is occasionally useful. Its `Arrow` instance is less often useful.
15:14:00 <iqubic> Isn't that like what >>= does?
15:14:04 <geekosaur> Arrowized FRP is still a thing
15:14:08 <iqubic> :t (>>=)
15:14:09 <lambdabot> Monad m => m a -> (a -> m b) -> m b
15:14:12 <dmwit> I still use some of the `Arrow` functions on occasion, but rarely on an `Arrow` other than `(->)`.
15:14:49 <dmwit> What is the "that" in "Isn't that like what >>= does?"?
15:15:08 <iqubic> dmwit: (a -> m b)
15:15:13 <merijn> iqubic: Naah, more like
15:15:15 <merijn> :t (>=>)
15:15:17 <lambdabot> Monad m => (a -> m b) -> (b -> m c) -> a -> m c
15:15:18 <dmwit> No, `a -> m b` is not like what >>= does.
15:15:29 <iqubic> What is kleisli used for if not an arrow?
15:15:33 <dmwit> `a -> m b` is a type. "what >>= does" is not a type.
15:15:49 <iqubic> I know.
15:16:54 <geekosaur> merijn just showed you. (>=>) is the Kleisli arrow version of (.). but if all you are doing is Kleisli arrows, might as well stick to Monad; the generalization of function arrows to include Kleisli arrows turns out to not be very useful
15:17:45 <iqubic> What do people use kleisli for nowadays?
15:18:37 <dmwit> Here's an example use: https://stackoverflow.com/a/40983855/791604
15:43:22 <jmcarthur> It looks like Any is no longer in GHC.Prim as of GHC 8.2. Where did that go?
15:43:41 <jmcarthur> Of course I found it as soon as I asked
15:43:47 <jmcarthur> (GHC.Types)
15:44:00 <jmcarthur> Apparently it's a type family now
15:44:20 <jle`> iqubic: usually it's for utilizing polymorphic combinators, same as Sum/Product/Endo/All/Any/First/Last etc.
15:45:05 <iqubic> How does that work?
15:50:27 <spion> are monoid morphisms functors?
15:51:22 <jle`> iqubic: if you want to use useful functions like foldMap over your data
15:51:31 <jle`> and you want to fold by summing numbers
15:51:43 <jle`> you can use the Sum newtype wrapper to get the Monoid instance you'd like
15:51:52 <edwardk> wz1000: yep
15:52:04 <jle`> > foldMap (\x -> (Sum (length x), x)) ["hello","world","how","are","you"]
15:52:06 <lambdabot>  (Sum {getSum = 19},"helloworldhowareyou")
15:52:41 <jle`> also, the generic Writer monad instance lets you accumulate any type, using its Monoid instance
15:52:58 <jle`> so if you want your 'writer log' to be a running sum, you can tell (Sum x)
15:53:18 <edwardk> wz1000: if you read the old turner article on how to compile down to combinators you realize that @pl is just an implementation of his technique directly on haskell terms. ap and const are enough to do everything argument-plumbing-wise that you need, using (.) and flip are optimizations that turner adds
15:53:32 <jle`> Sum is a newtype wrapper over a numeric type that gives it a Monoid instance that adds things together with (+)
15:53:48 <edwardk> S = ap, K = const, I = id, B = (.), C = flip, Y = fix
15:53:51 <jle`> using Sum allows you to re-use the great Writer type in the containers library to do useful things
15:54:37 <merijn> jle`: I think you mean transformers :p
15:57:12 <jle`> thanks, i do mean that :)
15:59:31 <Welkin> no, gundams!
16:13:38 <edwardk> Welkin: i welcome the new Control.Monad.Gundam namespace.
16:13:54 <edwardk> Control.Monad.Gobot didn't get any traction
16:56:23 <dmwit> spion: Yes.
16:56:41 <dmwit> spion: A monoid is a one-object category (with mempty the identity arrow and mappend the composition).
16:57:01 <dmwit> spion: If you now write down the functor laws for a functor from one such category to another, you see they are exactly the laws for monoid morphisms.
16:57:44 <dmwit> Specifically: F(id) = id says f(mempty) = mempty, and F(g . h) = F(g) . F(h) says f(x <> y) = f(x) <> f(y).
17:00:46 <dmwit> Oh. I guess I said what the object, identity, and composition were but forgot to say what the arrows were. Maybe you could guess from the other bits, but the arrows in that category are the elements of the monoid.
17:01:42 <qqkami> hello, when given a list of inputs how do i return the input that will produce the lowest result when used with a specific function?
17:02:09 <qqkami> usually id just have a variable and find the minimum in a loop with different programming languages
17:02:15 <dmwit> There is `minimumBy`. Unfortunately there is no `argmin`, but you can build it out of `minimumBy` yourself.
17:02:45 <dmwit> :t minimumBy
17:02:47 <lambdabot> Foldable t => (a -> a -> Ordering) -> t a -> a
17:02:54 <dmwit> Oh, perhaps that *is* argmin.
17:03:10 <dmwit> :t let argmin f = minimumBy (comparing . f)
17:03:19 <dmwit> :t let argmin f = minimumBy (comparing . f) in argmin
17:03:26 <dmwit> uh oh
17:03:27 <dmwit> ?botsnack
17:04:26 <qqkami> whats the general consensus on hoogle? because i just looked up minimumBy therenad it seems like it'd return the original value that produces the minimum result
17:04:33 <qqkami> so i guess thatsthe argmin you speak of?
17:04:39 <dmwit> qqkami: Okay, I checked in ghci. It should be `minimumBy . comparing`, not what I typed above. =P
17:05:32 <dmwit> The general consensus on Hoogle is that it's damn useful. I don't understand the rest of that question.
17:06:12 <qqkami> okay - i wasnt sure if it was a good site thats up to date etc since i just found it right now when googling 
17:06:18 <qqkami> well anyways thanks for your help!
17:08:31 <dmwit> int-e: lambdabot died! =(
17:14:11 <mniip> hmm
17:14:26 <dmwit> ?botsnack
17:14:31 <lambdabot> :)
17:14:52 <mniip> is there a name for the category that's like a cardinal category but has a distinct morphism for any pair of objects as well
17:15:59 <mniip> so like for 2 there's morphisms 0->1 and 1->2 but also 0->2 that is not equal to 1->2 . 0->1
17:23:12 <dmwit> So an arrow from a to b is a strictly monotonically increasing sequence starting at a and ending at b?
17:23:39 <dmwit> Seems like a plausible category. Don't know of a name for it, though.
17:30:33 <mniip> yeah
17:31:49 <mniip> well, not so much interested in naming but rather the counting of morphisms between specific objects in a category that is product of a number of such sequence categories
17:32:07 <mniip> oh no
17:32:16 <dmwit> Oh, that should be easy.
17:32:22 <mniip> that would be not the number I'm looking for because in a product category all squares commute
17:32:43 <dmwit> uh
17:32:51 <dmwit> I don't think that's right...
17:33:15 <mniip> well not "all" squares
17:33:39 <mniip> (f *** id) . (id *** g) == (id *** g) . (f *** id)
17:33:48 <dmwit> yes
17:35:11 <dmwit> I'm not sure why that's a problem. Perhaps you should give a bit of context.
17:35:45 <mniip> just looking for the path count in a digraph that is a product of such simplical digraphs
17:39:22 <mniip> dmwit, context is project euler problem 606
17:41:14 <dmwit> Okay. That's kinda different from what I understood of your explanation. =P
17:42:57 <dmwit> I think I see what you were going for. You could take each prime and give it the category you asked about with objects from 0 to the exponent on that prime in the factorization.
17:43:28 <dmwit> Then a gozinta chain for p^e is exactly an arrow in that category. But the product category isn't the right construction for p^e*q^e'.
17:44:24 <dmwit> A gozinta chain is instead a sequence of tuples, where in each step of the sequence, all tuple elements don't decrease and at least one increases.
17:44:29 <freeman42x> run into some issue with hidden module loading (probably): https://stackoverflow.com/q/47065821/750216
17:47:26 <dmwit> I don't think that is because it is hidden.
17:48:03 <geekosaur> Paths_hoogle is a generated module and will be under dist somewhere
17:48:06 <dmwit> Paths_* is a bit special: it's generated by cabal. Dunno how stack handles that. You may need to build the whole thing once for it to get generated? I am not a stack expert.
17:50:25 <htse> if I want to / an Int I need to use fromIntegral to vast it to an acceptable type right?
17:50:31 <dmwit> :t div
17:50:33 <lambdabot> Integral a => a -> a -> a
17:51:04 <dmwit> But yes, if you want non-integer division, you can use fromIntegral.
17:51:38 <htse> div doesn't work, I want a fractional/float result
17:52:17 <geekosaur> then yes, fromIntegral
17:52:56 <htse> but I get "Could not deduce (Fractional t0) arising from a use of ‘/" as an error when doing (fromIntegral p)/100
17:53:07 <htse> where p is an Int
17:53:28 <geekosaur> you need to show actual code
17:53:34 <htse> well it's a type that is defined as an Int but I assume that's the same thing for the compiler?
17:53:46 <geekosaur> and probably full error message, if you are using this in a contxt where defaulting won't work
17:54:03 <geekosaur> no, it's not the Int that you fromIntegral-d that is te problem
17:54:10 <geekosaur> it doesn;t know what type to give the *result*
17:54:25 <geekosaur> worst case you may have to put an :: Double annotation somewhere
17:55:11 <geekosaur> this generally happens when you;re using it in a context that blocks defaulting (e.g. through a Foldable instance --- but note that FOldable will work in ghci, just not in compiled code unless you use -XExtendedDefaultRules)
17:57:16 <htse> here is my code and error https://n.wzm.me/?30013d55cadbd1e2#dQ4AT1Xt/QOIXmme4gnDnUauiDvt4N4tvCywZx+KW5k=
17:58:11 <htse> I found an older haskell book called the craft of functional programming in the library and am following that
17:58:35 <dmwit> As geekosaur said: use `(fromIntegral p/100 :: Double)`.
17:59:35 <geekosaur> ah, Text.Printf, that'd stop it defaulting too
17:59:39 <dmwit> ...but I would probably use `%d.%d` as the format instead, with `divMod p 100` supplying the two values.
17:59:40 <geekosaur> too many typeclass tricks going on
17:59:57 <htse> casting it to Double works
18:00:19 <htse> but why? isn't the result of `/` a Float?
18:00:27 <dmwit> `Float` would be fine, too.
18:00:36 <htse> yes but why? :/
18:00:55 <dmwit> Because `fromIntegral` and `/` are both polymorphic over a typeclass that includes both `Float` and `Double`.
18:01:03 <htse> I don't get why the compiler complains and I have to specify the type it knows already
18:01:07 <dmwit> (...also `100` is polymorphic enough to support that class. =P)
18:01:15 <dmwit> It doesn't know. There are many choices.
18:01:25 <htse> I see
18:01:34 <dmwit> `Float`, `Double`, `Rational` are all possible choices, and the user could add more later themselves.
18:01:49 <htse> yes, that makes sense, thanks
18:01:52 <geekosaur> also COmplex Double and a few other things that come with standard Haskell
18:02:34 <dmwit> Of course, of those, probably only `Float` and `Double` qualify as `PrintfArg`s out of the box. But hey.
18:02:38 <htse> I couldn't deduce that for the life of me from those errors :/
18:02:45 <dmwit> > printf "%g" (3 :: Rational) :: String
18:02:47 <lambdabot>  error:
18:02:47 <lambdabot>      • No instance for (PrintfArg (Ratio Integer))
18:02:47 <lambdabot>          arising from a use of ‘printf’
18:02:55 <dmwit> too bad =)
18:03:44 <geekosaur> if this came from a book, Im tryi8ng to figure out how it worked. the Printf machinery has changed a bit over the years but the typeclass itself shouldn;t have changed in ways that would disallow defaulting (that is, even the original one wouldn't have allowed defaulting to work)
18:03:46 <dmwit> htse: Well, if you look about halfway through each error, it does say, "The type variable is ambiguous; these potential instances exist:" and lists a few.
18:04:34 <htse> oh yes!
18:04:55 <htse> I always look at like the first 3-5 lines to see location and what it complains about :s
18:04:58 <geekosaur> but it can't deduce at compile time based on the format so it starts listing out all the possible PrintfType instances
18:05:06 <htse> thanks for pointing that out
18:05:12 <geekosaur> the second error is actually more useful there
18:06:03 <alhariel> could somebody recommend me a nice haskell refresher
18:06:10 <htse> it's quite verbose to have on my laptop here, not that big of a screen and using i3 so large texts like that in my console can be a bit of a pain :)
18:06:16 <dmwit> alhariel: The Gentle Intro
18:06:19 <geekosaur> suddenly I want to find a ghc 6.6 binary and see if it actually compiled there...
18:06:20 <dmwit> ?where gentle
18:06:20 <lambdabot> http://www.haskell.org/tutorial/
18:06:35 <alhariel> dont feel like going thru beginner material all over again lel
18:06:51 <alhariel> ty
18:07:09 <dmwit> alhariel: That's a good refresher for the language. I don't know of a great refresher for the library ecosystem.
18:07:47 <dmwit> You might browse https://hackage.haskell.org/packages/top, which is a list of Hackage packages sorted by downloads.
18:07:47 <alhariel> eh its alright i didnt know much of the library
18:08:13 <alhariel> nice, thank you
18:08:20 <dmwit> There are definitely tutorials out there for most of the packages in the top screenful.
18:14:00 <alhariel> is fgl the preferred lib for graphs? its pretty far down in that list
18:24:41 <vaibhavsagar> alhariel, what do you want to do with graphs?
18:28:32 <alhariel> nothing in particular yet, just using it as a container i guess
18:30:17 <monochrom> What are above fgl in that list?
18:34:37 <htse> because I wanted to make things clean and had to use temp variables I put a where clause in a where clause, is that frowned upon?
18:35:00 <htse> it works but I wonder if it's maybe something I rather should not do
18:35:06 <monochrom> No, not by me anyway.
18:35:42 <Welkin> I have seen people write entire programs inside of where clauses
18:35:54 <Welkin> I think that is ridiculous
18:36:10 <Welkin> at a certain point, it should be top-level
18:36:52 <mniip> Welkin, I've written triangular where-code before
18:37:01 <mniip> one sec, lemme count the number of layers...
18:37:40 <mniip> 7 layers of where
18:38:18 <monochrom> Meta consideration: If you poll other people's opinion, you'll suffer the bias of strong conviction.
18:39:35 <Welkin> mniip: do you use 180 character columns, too?
18:40:25 <mniip> I impose no specific limits
18:41:11 <mniip> my screen fits 294 cols but I'm willing to go beyond that
21:13:15 <qqkami> hello, i have a function with the signature [Int] -> ([Int],[Int]) how can i test it in hugs (or ghc) by calling it
21:13:32 <qqkami> i get a type error in application (a,b,c...) does not match [Int] error
21:14:11 <dsal> qqkami: What did you try?
21:14:27 <jcarpenter2> what chu talkin' bout willis
21:14:28 <qqkami> functionname (0,1,2,3)
21:14:37 <dsal> qqkami: (0,1,2,3) isn't a list of ints.
21:14:42 <jcarpenter2> that is not a list, it is a 4-tuple
21:14:43 <dsal> Try [0, 1, 2, 3]
21:14:43 <qqkami> im stupid
21:14:46 <qqkami> yes
21:14:47 <qqkami> thanks
21:14:58 <qqkami> its late.. 
21:31:39 <dsal> I've got a do block that I *think* is a Maybe monad that has a guard.  It's failing with   Exception: user error (mzero)
21:31:56 <dsal> Am I doing something really stupid?  I'm not even sure how to confirm the type here. : /
21:32:54 <dsal> My higher level goal is to have a conditional block of stuff within another do block.  It works other than the guard.
21:33:03 <qqkami> is there a nicer way to write something like this? perhaps without guards or something since it seems quite unsightly https://pastebin.com/DwwcWr3v
21:34:34 <dsal> What is ternaryCountOnesModThree ?
21:35:16 <qqkami> its just a function that counts how many 1's are in the ternary representation of a number
21:35:29 <qqkami> and the function isnt called function i just changed it since its a german word 
21:36:03 <qqkami> its supposed to split the numbers in a list into two lists, the first being a list where the number of ones is divisable by 3 and the second one where its not
21:36:08 <geekosaur> dsal, that sounds like a MonadPlus instance with an mzero that calls (error "mzero")
21:36:09 <qqkami> it works this way.. but its kinda ugly
21:36:26 <geekosaur> which wouldn't be Maybe; its mzero is Nothing
21:36:49 <dsal> geekosaur: Hmm...  I'm not sure how to do this right.  It works other than the guard.  :(
21:36:59 <geekosaur> :t guard
21:37:00 <lambdabot> Alternative f => Bool -> f ()
21:38:19 <geekosaur> dsal, guard is probably not the way to do that. but you should show actual code; it's kinda hard to guess
21:39:46 <dsal> geekosaur: The code's not super tidy. https://www.irccloud.com/pastebin/I5WUE791/code.hs
21:40:31 <dsal> Working with a bunch of data.  Sometimes I can parse numbers.  When I can, I want to test that they're right.  When I can't, I want to just skip that bit.
21:47:00 <geekosaur> pn <- if (fromMaybe 0 . latitude) res <= 0 then return Nothing else do
21:47:02 <geekosaur> I think
21:47:18 <geekosaur> I jhave no idea what MonadPlus instance you're getting
21:47:54 <dsal> Me too. :(  That runs anyway.  Probably a good start.
21:48:50 <dsal> qqkami: I'd probably express that function as   (Int -> Bool) -> [Int] -> ([Int], [Int])     Then you could return ([n | <- ns, f n], [n | <- ns, (not.f) n])
21:54:13 <Axman6> that's called partition btw
21:54:16 <Axman6> :t partition
21:54:17 <lambdabot> (a -> Bool) -> [a] -> ([a], [a])
22:00:07 <geekosaur> and there's a one-pass implementation (also those list comps both have the same error)
22:03:07 <dsal> Exception: user error (Text.Regex.Posix.String died: (ReturnCode 17,"illegal byte sequence"))
22:03:07 <dsal> Bah
22:03:38 <geekosaur> sadly, most POSIX regex ompls don't handle unicode / utf8
22:04:08 <dsal> Nothing would be nice, since that's what it returns when it doesn't match.
22:04:17 <geekosaur> usually you end up using Text.Regex.TDFA
22:05:13 <Axman6> @src partition
22:05:13 <lambdabot> partition p xs = foldr (select p) ([],[]) xs
22:05:13 <lambdabot>     where select p x ~(ts,fs) | p x       = (x:ts,fs)
22:05:13 <lambdabot>                               | otherwise = (ts, x:fs)
22:06:11 <dsal> I'm not enjoying exceptions much in haskell. 
22:08:32 <dsal> Is there an easy way to eat that exception here:     matchText r t = matchRegex r (unpack t)
22:09:00 <Axman6> luckuly they're quire rarely used. I try to avoid libraries which use them excepti in exceptional circumstances (and even then there should be a good reason for it)
22:18:00 <nshepperd> ReturnCode 17? is that wrapping a C library or something
22:21:47 <nshepperd> you can often write a parser (with one of the *parsecs) instead of using regexes
22:22:12 <nshepperd> I did that last time i felt the urge to write a regex
22:23:14 <Axman6> yeah, regex--
22:23:16 <nshepperd> ended up writing a 'findAll :: Parsec s u a -> Parsec s u [a]' function to emulate the usual regex feature of finding all matches, lol
22:23:44 <dsal> Yeah, I probably could.  I'm porting some code and have a regex for some kind of complicated stuff.
22:25:42 <Axman6> that's always a bad usecase for regexes
22:25:52 <dsal> haha
22:25:59 <dsal> I've been a long regex hater.
22:26:24 <Axman6> imo, the only acceptable use of regexes is if you need user input for a pattern to match, such as in a text editor. they shouldn't be used directly in code
22:27:44 <dsal> Well, I'd like to be able to commit here, but my regex is failing my test instead of returning Nothing.
22:33:59 <dsal> OK, is there some kind of magic I can use here?  All the Control.Exception stuff I see looks like it's in IO.
22:46:24 <Axman6> right, because exceptions are asynchronous side effects
22:48:36 <dsal> Yeah, I'm trying to wrap it in the one place in this test that's actually using that, but it's still coming through.
22:51:52 <dsal>                                     pos <- catch (return $ position b) (\e -> do
22:51:52 <dsal>                                                                            let _ = (e :: SomeException)
22:51:52 <dsal>                                                                            return Nothing)
22:51:57 <dsal> Shouldn't that do it?
22:55:12 <Axman6> no, because the value of b needs to be evaluated inside the catch. look at the function evaluate
22:55:23 <Axman6> exceptions are hard, avoid them at all costs
22:55:49 <dsal> oooh
22:55:53 <dsal> changing return to evaluate does it
22:55:59 <dsal> Yeah, I just figured that out. :)
22:59:11 <jcarpenter2> yeah, haskell has better stuff than exceptions
22:59:19 <jcarpenter2> Either Exception, for instance
22:59:32 <zRecursive> What's that better stuff ?
23:00:04 <dsal> This code should be functional, but it's throwing an async exception due to bad data *and* it's a Maybe type.
23:00:20 <dsal> How you gonna have a partial Maybe function?
23:03:46 <jcarpenter2> zRecursive: Maybe, Either
23:04:18 <jcarpenter2> tracking errors via the type system instead of not knowing whether your IO will blow up
23:04:53 <jcarpenter2> btw Text.Blaze.Html5 is great, i'm gonna write my html in haskell from now on
23:05:49 <dsal> Yeah, playing with this stuff today, both Monad and Applicative Maybe started to make a ton of sense.
23:07:14 <dsal> Hmm...  coveralls doesn't agree with my local coverage run.  That's unfortunate.  I wonder who's right.
23:31:44 <dsal> Looks like coveralls shows any line that wasn't fully evaluated.
23:31:57 <dsal> I increased my effective coverage by validating the error messages I was getting from bad data.
23:42:13 <dsal> the coveralls variant also shows that I didn't specifically invoke the field accessors, whereas the regular coverage tool doesn't do that.  But at least it shows me all of my otherwises were always true.
23:59:03 <qqkami> hello once again ^^ given a list of.. let's say digits [0,0,1,2,3,4] (they are sorted) is there any way to split them into seperate lists as follows [0,0] [1] etc.. just by numbers basically?
