00:00:18 <geekosaur> (well, now I know what "Haskell" is in Russian...)
00:00:22 <ViNnI> это кто хаскель
00:00:43 <ViNnI> я с 2010 в мирке небыл вообще
00:00:44 <mniip> geekosaur, beware that was the dative case
00:00:51 <geekosaur> figured
00:01:16 <geekosaur> (well, figured it wasn;t necessarily nominative. I can transliterate Cyrillic but know very little of the language)
00:01:52 <mniip> ViNnI, Хаскелл - функциональный язык программирования. Этот канал посвящен ему
00:04:09 <fragamus> http://lpaste.net/360246
00:06:54 <mniip> fragamus, it's a record type
00:07:12 <mniip> possible that record types' dervied Show/Read instances expect the full record sytnax
00:07:26 <mniip> possibly even in correct order
00:08:02 <xormor> https://en.wikipedia.org/wiki/Dative_case
00:08:04 <fragamus> well both read and show are derived
00:08:20 <fragamus> I would think they would be consistent 
00:08:46 <mniip> fragamus, have you used the show instance
00:08:51 <fragamus> yes
00:08:53 <xormor> my mother tongue (native language) is Finnish and we use the dative case... "annoin kirjaN LauriLLE". "I gave a book to Lauri".
00:09:22 <xormor> ViNnI, osaatko sie huastaa yhtää karjalaa?
00:09:44 <xormor> I tried speaking East-Finnish Karelian to him.
00:09:50 <mniip> I don't think they speak finnish
00:10:11 <geekosaur> mniip, fragamus: re record types, yes, Haskell standard requires that something declared in record syntax will derive Show and Read in record syntax and with fields in declared order
00:10:40 <koz_> mniip: You're a Russian speaker?
00:10:47 <ViNnI> xormor russia
00:10:57 <xormor> ViNnI, ok
00:10:58 <mniip> koz_, yes
00:11:01 <ViNnI> moscow
00:11:08 <koz_> Learn something new every day, I guess.
00:11:11 * koz_ is too.
00:11:20 <fragamus> geekosaur: what can i do, I am using derived show and read for this record tyoe
00:11:40 <kuribas> "Monads are containers:" https://functional.works-hub.com/blog/Understanding-the-Math-behind-FP-The-Monads
00:11:46 <kuribas> No they are not...
00:11:59 <mniip> kuribas, depends on what you mean by container
00:12:12 <koz_> It's a possible analogy for some monads.
00:12:13 <mniip> I'm perfectly fine with calling Reader or Proxy a container
00:12:21 <kuribas> mniip: I suppose they refer to the type variable, but a type variable isn't a container
00:12:22 <geekosaur> fragamus, you have to replicate the correct record format in declared field order, or you have to write your own Read instance that will accept the non-record form
00:12:34 <geekosaur> deriving will not create the latter
00:12:49 <fragamus> gah
00:12:51 <koz_> Also, what stops ZipList from being a monad?
00:12:57 <geekosaur> (hypothetically there might be a way to do that in the future, but probably as a compiler plugin, which I'm not sure you would consider an improvement :)
00:13:00 <kuribas> mniip: how is reader a container?
00:13:13 <kuribas> mniip: it's a function...
00:13:19 <kuribas> mniip: it doesn't contain anything
00:13:34 <fragamus> i don't control the input to read so I guess i have to write that read function and several dozen other ones
00:13:34 <mniip> you give it environments
00:13:39 <mniip> it gives you the contained results
00:14:23 <fragamus> maybe i only need to write the record ones
00:14:37 <mniip> koz_, you don't live in russia do you
00:14:38 <kuribas> it's confusing
00:14:50 <koz_> mniip: Nope.
00:14:51 <kuribas> and doesn't really say anything about a Monad?
00:15:16 <kuribas> Because a Functor is a container, a Monoid is a container, an Applicative is a container.
00:15:43 <mniip> functor is a container, applicative has finite products, and monad is flattenable
00:15:45 <geekosaur> fragamus, there's also parsing the strings yourself using something ReadS-based, or even preprocessing them (I suspect a little sed/awk could fix them up into record style)
00:16:07 <geekosaur> because they're not fancy recursive values
00:16:31 <fragamus> geekosaur: yeah 
00:16:36 <geekosaur> edge cases with Haskell string parsing might make it a little interesting, but at least you probably don't need to deal with e.g. string gaps :)
00:16:58 <kuribas> mniip: if you refer to the argument that is passed to the reader monad as a container, that isn't a monad.
00:17:22 <mniip> pretty sure Reader e is a monad
00:18:27 <kuribas> mniip: I mean, e in Reader e isn't (necessarily) a monad.
00:18:54 <mniip> sure
00:19:02 <mniip> I never said anything like that
00:19:17 <mniip> e is of the wrong kind of be a monad anyway
00:19:55 <kuribas> (r -> e) is a reader monad, but how can it contain anything?
00:20:10 * hackage language-c 0.7.1 - Analysis and generation of C code  https://hackage.haskell.org/package/language-c-0.7.1 (BenediktHuber)
00:20:32 <mniip> it contains an e for every r
00:20:38 <fragamus> geekosaur: https://stackoverflow.com/questions/28813161/haskell-record-syntax-and-read-from-file-string-to-record-syntax-exception#28813380
00:21:42 <mniip> kuribas, though I agree the article is fairly stupid
00:21:49 <geekosaur> kuribas, I think you're seeing the mathematical notion of function as a set
00:22:21 <mniip> I especially take offense with this image https://functionalworks-backend--prod.s3.amazonaws.com/logos/981fd9ea58709ae90f1ff8dcc7ba5ef4
00:22:25 <geekosaur> fragamus, isn't that what I said?
00:22:42 <fragamus> geekosaur: yes indeed
00:22:47 <kuribas> if a function is a container, and a value is one too (trivially one that contains itself), then everything is simply a container.
00:22:57 <kuribas> And a Monad is one too trivially.
00:23:02 <fragamus> geekosaur: and thank you for saying it
00:23:16 <geekosaur> it's been observed before that you can twist the notion of container to fit, but some of the twisted forms are pretty strange looking
00:23:31 <mniip> kuribas, what no
00:23:35 <mniip> it needs to be rebindable
00:23:38 <mniip> aka abstract
00:23:41 <mniip> aka of kind *->*
00:25:24 <kuribas> So you can say any type variable is a container.
00:25:30 <kuribas> At the type level.
00:25:36 <mniip> what
00:25:43 <fragamus> geekosaur: Altering the input is not an option, I shall have to write a Read instance
00:26:05 <mniip> I'm not sure if you're not understanding what I'm trying to say or are intentionally trying to twist my words
00:26:27 <kuribas> mniip: I don't get it
00:28:28 <holler> hello
00:28:34 <holler> trying to learn haskell following http://learnyouahaskell.com/starting-out
00:28:49 <holler> I created `hello.hs` with content `doubleMe x = x + x`
00:29:05 <holler> then from same dir I run `ghci` and type `:1 hello`
00:29:30 <holler> Prelude> :1 hello
00:29:30 <holler> unknown command ':1'
00:29:32 <geekosaur> um. it's ":l"
00:29:37 <holler> omg
00:29:39 <geekosaur> lowercase "l" as in "load"
00:29:39 <holler> LOL
00:29:46 <holler> hahaha wow
00:29:48 <holler> thanks
00:29:57 <Cale> holler: Also, you can give the filename on the commandline, like ghci hello.hs
00:29:58 <holler> ok if you look at that webpage
00:30:04 <holler> the font he's using looks like a "1"
00:30:07 <Cale> ah, haha
00:30:17 <holler> ^^ thanks Cale
00:30:22 <geekosaur> yeh. I'm not fond of either the book or the website, tbh
00:30:31 <mniip> http://tcpst.net/fc_v.png
00:30:40 <mniip> looks distinct enough to me
00:30:42 <holler> yep that worked thanks :D
00:30:44 <nshepperd> for want of a serif, computing failed as a profession
00:31:10 <nshepperd> kuribas: I don't think it's normal for a thing to contain itself
00:31:21 <holler> https://i.imgur.com/4jXJwGs.jpg
00:31:28 <holler> looks like a 1 to me
00:31:53 <mniip> there's a 1 just below that
00:31:56 <mniip> with a slated roof
00:32:15 <mniip> but, the fact that our pictures look different...
00:32:20 <holler> lol
00:32:34 <rightfold> Uninstall this awful font
00:32:43 <holler> wait geekosaur you don't like the `learnyouahaskell` book?
00:33:02 <mniip> he's only setting font-family: "Consolas", monospace
00:33:11 <geekosaur> it's the textbook equivalent of a 2-hour movie trailer
00:33:13 <mniip> which - I don't have mscorefonts so it's just my systemwide monospace font
00:33:30 <geekosaur> great iverview, kinda lousy for actually learning how to write Haskell
00:33:34 <geekosaur> *overview
00:33:38 <boj> holler: it's not a great "build up and learn" resource, more like a "show things off, but that's it book
00:34:20 <kuribas> mniip: even if you can fit some container analogy in a function, it's still confusing for beginners.
00:34:20 <rightfold> I have a custom stylesheet with pre, code, textarea { font-family: 'Fixedsys Excelsior 3.01' !important; font-size: 16px; }
00:34:29 <geekosaur> finding a source of exercises can help. (but only if they;re good exercises. Project Euler, for example, is not great for learning, because it's trying to teach you mathematical reasoning, not Haskell.)
00:34:30 <mniip> I guess
00:34:40 <mniip> if you define "container" precisely as a monad
00:34:45 <mniip> then it all makes sense
00:35:02 <nicknight> holler:  they are just distracting you, you finish that book
00:35:18 <Cale> kuribas: One way to think about functions is as giant arrays, indexed by the domain :)
00:35:23 <holler> lol
00:35:28 <holler> sounds good
00:35:34 <rightfold> StateT Int (Either String) is my favorite container
00:35:39 <holler> I write a lot of javascript 
00:35:41 <boj> holler: definitely finish it. was how i got into haskell :p
00:35:42 <holler> have written lots of python
00:35:43 <kuribas> Cale: I suppose a function is like a infinite Map.
00:35:44 <holler> have a startup
00:35:47 <Cale> yeah
00:35:55 <mniip> rightfold, I prefer ParsecT ContT
00:35:56 <rightfold> kuribas: a function may be finite
00:36:10 <holler> my friend/business partner said haskell would be amazing for some things
00:36:26 <rightfold> For example, Bool -> Word8 = 65536
00:36:29 <nicknight> holler:  what startup?
00:36:34 <mniip> holler, you'll uhh need a few years before you can write decent haskell
00:36:57 <boj> holler: definitely need a long R&D timeline if you have no other experts around
00:37:05 <holler> we havent launched yet
00:37:19 <holler> yeah tbh i just want to get my feet wet
00:37:27 <holler> start learning something new
00:37:38 <Cale> It took me about 2 months before I felt like I could use Haskell for real work, and about a year to be comfortable. I was doing a mathematics degree at the time though, so it's not like I was putting all my effort into it.
00:38:00 <kuribas> holler: if you think like becomming instantly rich, then probably not.
00:38:08 <Cale> (also, that was back in 2001-2002, so there were a lot fewer resources available)
00:38:23 <mniip> well alright, I could probably solve any task after less than a year
00:38:29 <mniip> but it wouldn't be an elegant solution
00:38:32 <holler> kuribas?
00:38:48 <mniip> it's been what, 5 years now and I still am amazed by lots of things
00:38:49 <Cale> mniip: Of course, there's always more to learn about how to do things well.
00:39:36 <kuribas> holler: haskell is great, and it allows you to write robust programs with short development time, but it takes time to really grasp the concepts.
00:40:48 <rightfold> Stuff didn’t really click for me until I saw the ring hierarchy in PureScript and learned about abstract algebra. It was then that I realized how all these seemingly obscure interfaces should be reasoned about.
00:40:55 <boj> holler: start now, learn to forget everything you think you know about programming, and in a years time you'll be well on your way to pro :)
00:41:32 <Cale> rightfold: Yeah, there's something very natural about the way we use type classes, if you're coming from a background in mathematics.
00:41:46 <mniip> NATURAL
00:42:15 <nshepperd> if becoming instantly rich was as easy as learning haskell
00:42:25 <nicknight> Cale:  I am just curious what job are you doing if you are from mathematical background
00:42:31 <mniip> sorry I got excited about the functor categories
00:42:49 <holler> haha ok great kuribas & boj // thanks
00:43:00 <rightfold> nshepperd: what if it is, but you just have never discovered it? 🤑
00:43:09 <holler> btw in haskell is 2 or 4 spaces standard for indent
00:43:09 <holler> ?
00:43:15 <nshepperd> actually I don't know what would follow from that but i'm sure it would be something fabulous
00:43:18 <rightfold> holler: no
00:43:19 <Cale> nicknight: I've been working for Obsidian Systems, we build web and mobile applications almost entirely in Haskell, using the functional reactive programming system Reflex, and the Reflex-DOM library built on that.
00:43:35 <kuribas> holler: I don't think there's a standard.
00:43:39 <boj> holler: not really a rule
00:43:53 <rightfold> There’s no formatting guidelines, other than “don’t use tabs because they break everything”
00:43:56 <dibblego> Cale: we should talk more about that
00:44:00 <holler> is there anything like pep8 in python?
00:44:04 <rightfold> No
00:44:12 <nshepperd> I just use whatever syntax emacs tells me to
00:44:15 <Cale> dibblego: About Reflex?
00:44:15 <holler> lol
00:44:22 <rightfold> People format Haskell in lots of different ways
00:44:32 <dibblego> Cale: Yes. We published a series of blog posts recently. http://qfpl.io/
00:44:40 <rightfold> Even where commas are placed in list literals cannot be agreed upon
00:44:47 <boj> holler: maybe google for "haskell style guide" and see what other people/companies do, but there's no hard fast rules
00:44:51 * mniip is a tabs rights activist
00:45:03 <Cale> Oh, yeah, Dave Laing's stuff, right?
00:45:03 <nshepperd> I guess it's two spaces in a lot of places
00:45:08 <rightfold> The Go solution is “make a tool”. The Haskell solution is “don’t talk about it”.
00:45:09 <mniip> indent with spaces, align never
00:45:14 <dibblego> Cale: Yes, he is on my team.
00:45:24 <mniip> indent with tabs*, align never
00:46:08 <Cale> dibblego: cool, thanks for all the effort on that! I've been continually frustrated that we never seem to have enough time/energy to put into documenting everything in all the ways that it ought to be.
00:46:12 <rightfold> Indent with spaces, align with tabs
00:46:45 <kuribas> Did anyone succesfully create a haskell startup?
00:46:48 <Cale> dibblego: This stuff is all pretty nice to use once you understand what's going on, but it's been way too hard to get into. So it's really nice to see people writing helpful articles.
00:46:57 * nshepperd looks. yeah, I seem to have been using 2 spaces for most 'blocks'
00:47:05 <dibblego> Cale: yeah, I need to get into it myself.
00:47:19 <Taneb> kuribas, I work for a startup using Haskell as its primary working language
00:47:33 <rightfold> kuribas: I know a startup that went Haskell, but not straight from he start
00:47:43 <kuribas> rightfold: what did they use first?
00:47:56 <Taneb> rightfold, yeah, that's similar for where I work
00:48:01 <rightfold> Python, still do for a large part, but all infrastructure is in Haskell
00:48:27 <rightfold> Also some Scala which will be deleted ASAP
00:48:34 <Cale> Indent/align with spaces, pretend tabs don't exist.
00:48:35 <dibblego> I have fixed startups using haskell since 2005
00:48:45 <boj> i've swapped a small telecom over to haskell (they were meandering in a directionless C# land)
00:49:59 <kuribas> how do you get the team to change?
00:50:22 <boj> persistence, patience, and the willing to listen and teach
00:50:24 <dibblego> you teach them the tools to determine why their software isn't working, and what the improvements are
00:50:29 <rightfold> https://tech.channable.com/posts/2017-02-24-how-we-secretly-introduced-haskell-and-got-away-with-it.html
00:50:50 <dibblego> if you repeat this enough, even the government gives you money and says, "do it more!"
00:51:16 <rightfold> They just sneaked it in, and then demonstrated how well it works 🤡
00:51:44 <dibblego> I am not a fan of the "sneak it in" approach. Rather, celebrate loudly your intentions, and upon resistance, simply sit and wait, looking at your watch.
00:52:23 <dibblego> I once sat at a company for 6 months, doing nothing, until they admitted that ruby on rails will never work. When asked, "what are you doing?", simply reply, "more than you"
00:52:46 <dibblego> after 6 months, an admission was made, we wrote it in haskell in about 6 weeks, it worked, that was 2011, and it is still working
00:52:49 <boj> i got hired on to run the development department during a time of massive flux, so i guess i had a lot of luck/good timing on my side
00:54:05 <boj> having a team willing to dive in helped a lot too
00:54:43 <mniip> heh
00:54:56 <mniip> I often wonder what are my future job opportunities with haskell...
00:54:58 <rightfold> Now whenever we need to pick a language for a new infrastructure project, the answer is typically Haskell, “because all our Haskell projects have been a great success!”
00:55:04 <mniip> (am an undergrad rn)
00:56:04 <Taneb> mniip, well, if you're able to relocate to Cambridge, England, I can recommend somewhere :)
00:56:08 <rightfold> Speaking of which, I need a new Haskell project for my spare time
00:56:09 <Cale> dibblego: hahahaha
00:56:45 <kuribas> dibblego: so you were already writing haskell at your company?
00:57:10 <mniip> Taneb, yeah thing is I'm not very relocative until I'm done with at least this degree
00:57:24 <Taneb> mniip, that's understandable
00:57:44 <Taneb> There definitely are Haskell jobs out there
00:58:11 <kuribas> Taneb: it seems they are clustered around some places, like London and Berlin.
00:58:21 <boj> i'm still hiring. no one wants to move to Alaska :p
00:58:24 <mniip> also britain isn't part of the EU anymore which is extra hassle
00:58:39 <boj> (and i can't convince old school CEOs to do remote)
00:58:51 <Taneb> We've still got like a year in
00:59:10 <koz_> boj: How long've you been searching?
00:59:38 <kuribas> boj: isn't it cold?
00:59:41 <boj> koz_: about 3-4 months for general developers period, let alone any haskell skills
00:59:49 <koz_> Wow, OK.
00:59:51 <boj> hard to find good people in AK
00:59:52 <koz_> I wish you the best of luck.
00:59:59 * koz_ isn't looking.
00:59:59 <boj> appreciated
01:00:12 <mniip> hey alaska is basically russia right?
01:00:20 <boj> indeed
01:00:21 <koz_> mniip: LOL.
01:01:06 * boj ironically lives in Japan while he straightens visas for family out
01:01:26 <koz_> How do you ironically live somewhere?
01:01:40 <boj> the irony is that the CEO won't do remote (for other people)
01:02:11 <koz_> Ah, OK.
01:03:02 <mniip> koz_, doesn't need to be a somewhere :p
01:03:26 <koz_> mniip: Ironic living as such I get. It's called 'being a hipster'.
01:03:29 <kuribas> boj: where in alaska?
01:04:13 <boj> kuribas: Anchorage. head office is actually Fairbanks, and parent company Palmer
01:05:28 <koz_> Whenever I see Anchorage mentioned, I always think it's something from a Lovecraft novel.
01:05:37 <koz_> Ever seen any Deep Ones as part of your work commute, boj?
01:07:02 <boj> if i did i must have blanked it out :p
01:07:22 <koz_> boj: That's why you need Haskell devs; it makes the non-Euclidean geometries manageable.
01:07:30 <koz_> Something about the CosmicHorror monad.
01:07:40 <boj> haha
01:15:41 * hackage mustache 2.3.0 - A mustache template parser library.  https://hackage.haskell.org/package/mustache-2.3.0 (justus)
01:21:58 <rightfold> Can you use {-# UNPACK #-} for vector elements?
01:22:51 <rightfold> E.g. unboxed vector with maybes
01:23:02 <koz_> rightfold: I think that's done with Data.Vector.Unboxed.
01:23:07 <koz_> Which means writing an Unbox instance.
01:23:48 <koz_> I don't believe there's an instance of the form Unbox a => Unbox (Maybe a), although I can't imagine it'd be hard to write.
01:23:51 <rightfold> But Unbox has no methods :(
01:25:38 <koz_> rightfold: I don't recall exactly how one defined Unbox instances, but I know it can be done.
01:25:51 <koz_> (I investigated this a while ago for very similar reasons to what you're trying to do)
01:25:59 <koz_> (but I forgot)
01:26:03 <koz_> (because I ended up not needing it)
01:29:51 <koz_> rightfold: You can also use the thing suggested at the top of Data.Vector.Unboxed's docs.
01:30:18 <koz_> (i.e. write an instance for Vector (Maybe a) as a newtype instance for Vector (Bool, a))
01:30:48 <nshepperd_> Unboxed vector is a data family
01:31:40 <nshepperd_> You add an instance for it, then write the Vector / MVector instances and that's it iirc
01:32:36 <nshepperd_> Ideally reusing other unboxed vector instances to do so yeah
01:43:55 <koz_> nshepperd_: But there has to be some way the 'base' instances are defined, right?
01:44:05 <koz_> Like, how does Int get its Unboxed instance, for example?
01:44:43 * hackage crdt 3.0 - Conflict-free replicated data types  https://hackage.haskell.org/package/crdt-3.0 (cblp)
01:47:48 <rightfold> koz_: oh cool
01:48:09 <geekosaur> http://hackage.haskell.org/package/vector-0.12.0.1/docs/src/Data.Vector.Unboxed.Base.html#line-209
01:48:24 <geekosaur> which actually appears to be off a few lines...
01:48:36 <koz_> geekosaur: The idea is clear from the context though.
01:48:39 <koz_> Thanks!
01:51:01 <koz_> Is it a good idea/even possible to have an instance of the form Unbox a => Unbox (Vector a)?
01:53:14 <geekosaur> doesn't look like it.
01:53:44 <geekosaur> Unbox is a trick to let it turn vector-of-nonprimitive into nonprimitive-of-primitive-vectors. which requires the nonprimitive to be fixed size/shape
01:53:50 <geekosaur> Vector has fixed shape but not size
01:55:49 <koz_> geekosaur: Ah, I see.
01:56:30 <geekosaur> (actually I should say unboxed instead of primitive throughout that...)
02:00:06 <ggVGc> how are you supposed to pronounce haskell?
02:00:21 <ggVGc> does this guy say it right? https://youtu.be/t1e8gqXLbsU?t=36
02:00:24 <ggVGc> I don't say it like that
02:01:18 <koz_> Neither do I - for me, the second syllable sounds like the orange soda loving character.
02:01:26 <koz_> (and with that, I have thoroughly dated myself)
02:02:22 <koz_> (well, sorry, it doesn't sound like that - the vowel's a schwa for me)
02:05:10 <koz_> ggVGc: Since Haskell is named after the logician, I assume his name is the canonical pronunciation, which is here: https://en.wikipedia.org/wiki/Haskell_Curry
02:05:20 <geekosaur> gleh. refusing to load for me (because local network sucks)
02:05:49 <koz_> ˈhæskəl
02:06:23 <geekosaur> (have some IPA with your IPA?)
02:06:30 <koz_> geekosaur: I'm not a hipster.
02:06:36 <koz_> Nor am I Xzibit.
02:06:44 <koz_> (Xzibit as a hipster)
02:06:48 <koz_> (enjoy the nightmare fuel)
02:07:05 <geekosaur> "I get stranger things than that with my breakfast cereal"
02:07:33 <koz_> geekosaur: Where do you live, Miskatonic University?
02:08:24 <geekosaur> In my head, which is, uh. Different.
02:08:48 <koz_> geekosaur: Maybe you could make some use of the CosmicHorror monad.
02:14:10 * hackage subzero 0.1.0.3 - Helps when going "seed values" -> alternatives and optional -> answers  https://hackage.haskell.org/package/subzero-0.1.0.3 (codeshot)
02:27:41 <fragamus> deriving instance Read SrcSpanInfo    does not parse the input emitted by the corresponding show, even though it is in record format
02:29:48 <fragamus> is there any generic parser around for record format stuff
02:42:10 * hackage errors-ext 0.2 - Bracket-like functions for ExceptT over IO monad.  https://hackage.haskell.org/package/errors-ext-0.2 (warlock)
03:31:50 <fabien__> there is a way to simply add a Int to a Float ?
03:32:06 <fabien__> add a b :: Int -> Float -> Float ???
03:32:22 <cocreature> fabien__: add a b = fromIntegral a + b
03:35:21 <rightfold> The GHC documentation on GADT record syntax is wrong.
03:36:18 <rightfold> Oh, Google just links to a very old version. In the latest version it is correct.
03:47:53 <qqwy1> Hey everyon!
03:47:56 <qqwy1> everyone*
03:47:58 * hackage validity 0.4.0.1, genvalidity 0.4.0.1 (Norfair): https://qbin.io/zm6wekmm8
03:48:03 <qqwy> How are you all? :-)
03:48:35 <qqwy> I am wondering if it is possible to create a Data.Ratio using a Data.Complex numerator and denominator.
03:49:05 <qqwy> Doing just 'import Data.Complex', 'import Data.Ratio'
03:49:18 <qqwy> and then writing things like '(1 :+ 2) % (3 :+ 4)' in GHCI
03:49:23 <qqwy> will result in the following error:
03:49:49 <qqwy> https://gist.github.com/anonymous/7aae81decbf87b6f1f3dd9ee2b5ca62f
03:51:32 <cocreature> qqwy: no, it’s not possible, (%) requires an Integral constraint and there is no Integral constraint for "Complex a"
03:52:34 <qqwy> Aww, that's too bad
03:53:03 <qqwy> All right, that means I'll need to build my own datatype to represent linear fractional transformations
03:53:25 <fabien__> oh i can do that cocreature
03:53:27 <fabien__> ok
03:54:26 <fabien__> its not working for dive
03:54:28 <fabien__> its not working for div
03:54:59 <cocreature> fabien__: "div" is integer division, if you want to divide floats use /
03:58:00 <ph88> hey guys, is there a function that runs a function on a list and returns the first Just value ?   like the "any" function but then with Just instead of Bool
03:59:23 <cocreature> :t \f -> asum . map f -- ph88 
03:59:25 <lambdabot> Alternative f => (a1 -> f a2) -> [a1] -> f a2
04:02:32 <qqwy> My mind is blown
04:02:40 <qqwy> @cocreature what is the best way to learn all those wonderful functions
04:02:40 <lambdabot> Unknown command, try @list
04:03:54 <qqwy> So in this case, `asum` uses the 'Alternative' instance of Maybe, meaning that they are combined using <|> which for maybe means that the first 'Just' is used?
04:03:56 <ph88> thx cocreature 
04:04:39 <cocreature> qqwy: exactly
04:04:49 <cocreature> qqwy: lurking around in this channel is one way to learn about these functions :)
04:05:03 <qqwy> And `empty` (which returns Nothing for Maybe a ) is used if the list is empty... Awesome!
04:05:10 <ph88> how is it that the sum of a Maybe is the Just ?
04:05:13 <qqwy> ^^ All right, I will be here more often then I guess :-)
04:05:15 <ph88> asum: The sum of a collection of actions, generalizing concat.
04:05:30 <cocreature> ph88: it’s the sum with regards to <|>
04:05:31 <qqwy> @ph88 It is the 'sum' according to the rules specified in 'Alternative'.
04:05:31 <lambdabot> Unknown command, try @list
04:06:01 <qqwy> Sorry lambdabot, I'll stop using '@'s ^^'
04:06:05 <cocreature> I don’t think “sum” is a particularly helpful term to use here but apparently someone thought it was a good name :)
04:06:21 <ph88> how can i be sure that the alternative stops at the first occurrence of Just ? .. i mean is this behavior described somewhere ? 
04:06:53 <cocreature> doesn’t look like it. The instance doesn’t have a comment :(
04:06:58 <qqwy> Well, it is the more general name for this kind of combining operation. But it is only intuitive to high-schooled mathematicians
04:07:05 <cocreature> which is sadly true for a lot of instances
04:08:49 <qqwy> You can look here http://hackage.haskell.org/package/base-4.10.0.0/docs/src/GHC.Base.html#%3C%7C%3E  for 'instance Alternative Maybe'
04:08:54 <qqwy> and there you see what is going on
04:09:20 <qqwy> but indeed, the documentation of much of Haskell's stuff out there could be improved
04:09:28 <fabien> thank you , its working im stupid i didnt know for `div`
04:12:10 * hackage persistent 2.7.2 - Type-safe, multi-backend data serialization.  https://hackage.haskell.org/package/persistent-2.7.2 (paulrouse)
04:39:13 * hackage distributed-process-async 0.2.4.1 - Cloud Haskell Async API  https://hackage.haskell.org/package/distributed-process-async-0.2.4.1 (AlexanderVershilov)
04:56:43 <ph88> how can i split a string into chunks where [a-zA-Z] is one group, whitespace is another group and the rest (like comma) is in the last group ?
04:57:07 <qqwy> ph88: Can you give us an example of exactly what input you get and what output you expect?
04:57:15 <qqwy> How should the chunks look?
04:57:39 <qqwy> (The answer to your question is 'yes'. But there are multiple ways to do this)
04:59:44 <ph88> "hello, world" -> ["hello", ",", " ", "world"]
05:00:33 <Axman6> > groupBy generalCategory "hello, world"
05:00:36 <lambdabot>  error:
05:00:36 <lambdabot>      • Couldn't match type ‘GeneralCategory’ with ‘Char -> Bool’
05:00:36 <lambdabot>        Expected type: Char -> Char -> Bool
05:00:43 <ph88> "foo,.bar; qux  ,boo" -> ["foo", ",.", "bar", ";", " ", "qux", "  ", ",", "boo"]
05:00:54 <Axman6> > groupBy ((==) `on` generalCategory) "hello, world"
05:00:56 <lambdabot>  ["hello",","," ","world"]
05:01:01 <ph88> crazy xD
05:01:04 <ph88> thx Axman6 
05:01:08 <qqwy> <3 Amazing!
05:01:13 <Axman6> > groupBy ((==) `on` generalCategory) "foo,.bar; qux  ,boo"
05:01:15 <lambdabot>  ["foo",",.","bar",";"," ","qux","  ",",","boo"]
05:01:23 <qqwy> I was about to write about needing Parsec for this xD
05:01:34 <ph88> is there any way i can get the type of group without inspecting the characters again ?
05:01:44 <Axman6> you should find out what generalCategory does though ;)
05:01:49 <qqwy> :t generalCategory
05:01:51 <lambdabot> Char -> GeneralCategory
05:02:15 <Axman6> > map (generalCategory . head &&& id) $ groupBy ((==) `on` generalCategory) "foo,.bar; qux  ,boo"
05:02:18 <lambdabot>  [(LowercaseLetter,"foo"),(OtherPunctuation,",."),(LowercaseLetter,"bar"),(Ot...
05:02:22 <qqwy> ph88: You only need to look at the first char of each of your tokens again for that :p
05:02:22 <ph88> LOL
05:02:28 <qqwy> Exactly what Axman6 is now doing
05:02:45 <ph88> never seen &&& before
05:03:06 <Axman6> note that lower case letters are a different category from uppercase
05:03:14 <qqwy> :t (&&&)
05:03:16 <lambdabot> Arrow a => a b c -> a b c' -> a b (c, c')
05:03:34 <ph88> that's a bit too crazy for me now, i will try to rewrite it without &&&
05:03:39 <qqwy> You can read 'Arrow' as 'things that work like Functions' (like functions themselves)
05:04:13 <qqwy> So you could then read this type signature as ( b -> c) -> (b -> c') -> (b -> (c, c'))
05:04:14 <Axman6> it's just f &&& g = \x -> (f x, g x)
05:04:32 <qqwy> So given a function from b to c and a function from b to c', return a pair of the two answers.
05:04:41 <qqwy> return a function that returns the pair of the answers*
05:05:16 <ph88> ok i put it in my comments
05:05:31 <ph88> i think i will be using &&& more often, but not just yet ^^
05:05:49 <Axman6> it's one of the few thing I like from Arrow
05:06:01 <Rembane> Arrow has really useful operators. 
05:06:07 <Axman6> there's also (***) which aplies two functions to the elements of a tuple
05:06:17 <Axman6> :t (***)
05:06:18 <lambdabot> Arrow a => a b c -> a b' c' -> a (b, b') (c, c')
05:06:30 <owickstrom> ANN: I just published an Asciinema demo of how you can use neovim-ghci for a fast-feedback interactive Haskell workflow: https://asciinema.org/a/q9I5eNblDLCoOiQlZjm1ce0ba?size=20&speed=3&theme=tango
05:06:35 <Axman6> :t (***) @(->)
05:06:37 <lambdabot> error: parse error on input ‘->’
05:06:38 <ph88> :t on
05:06:40 <lambdabot> (b -> b -> c) -> (a -> b) -> a -> a -> c
05:06:54 <ph88> from which package is that ?
05:07:20 <cocreature> base
05:07:21 <Axman6> owickstrom: IRC isn't a great place to announce things, it's too ephemeral. reddit would be better
05:07:24 <cocreature> it’s in Data.Function
05:08:20 <Rembane> owickstrom: Nice! 
05:09:08 <owickstrom> Axman6: yeah, I can post the link there as well, probably better :)
05:09:22 <owickstrom> Rembane: thx!
05:10:09 <Axman6> looks handy though
05:12:03 <owickstrom> Yeah, it has saved me a bunch of times, when my setups using ghc-mod or Emacs haskell-mode broke down in various ways.
05:38:45 <ph88> > groupBy ((==) `on` generalCategory) "Hello, world"
05:38:47 <lambdabot>  ["H","ello",","," ","world"]
05:38:58 <ph88> Axman6, this is going wrong, i need "Hello" to be one group :(
05:39:30 <Axman6> "00:02         Axman6: note that lower case letters are a different category from uppercase " ;)
05:39:54 <ph88> :(
05:40:08 <rightfold> Is anyone using WAI with Cont?
05:40:13 <Axman6> I did give you several warnings...
05:40:20 <cocreature> ph88: one solution would be to replace generalCategory by "\x -> if isAlpha then 0 else if isSpace then 1 else 3"
05:40:24 <geekosaur> ph88, I don;t think you will find anything predefined
05:40:34 <ph88> alright
05:40:37 <ph88> i'll whip something up
05:40:42 <Axman6> time to do some programming!
05:40:58 <Hafydd> > groupBy ((==) `on` generalCategory . toLower) "Hello, world"
05:41:00 <lambdabot>  ["Hello",","," ","world"]
05:41:39 <geekosaur> but what cocreature said. or more generally data CCat = Letter | Space | Other; ccat c | isAlpha c = Letter | isSpace c = Space | otherwise = Other
05:42:28 <geekosaur> the other problem might be that it doesn't sort first so you get "hello,world" -> ["hello",",","world"] instead of one group of letters and another of nonletters
05:42:37 <geekosaur> which it looked ot me like you wanted in your original query
05:43:01 <geekosaur> (you could always sortOn ccat...)
05:44:06 <geekosaur> oh, note that isAlpha and such there don't do Unicode
05:44:11 <geekosaur> iirc
05:44:21 <geekosaur> (but there are I think variants in icu packages that do?)
05:44:36 <cocreature> “Selects alphabetic Unicode characters” sounds like it does do unicode
05:57:39 <Axman6> > filter isAlpha [minBound..]
05:57:41 <lambdabot>  "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\170\181\186\192\193\19...
05:58:05 <Axman6> > text . drop 52 $  filter isAlpha [minBound..]
05:58:07 <lambdabot>  ªµºÀÁÂÃÄÅÆÇÈÉÊËÌÍÎÏÐÑÒÓÔÕÖØÙÚÛÜÝÞßàáâãäåæçèéêëìíîïðñòóôõöøùúûüýþÿĀāĂăĄąĆćĈĉĊ...
05:58:16 <Boreeas> hi
05:58:27 <Axman6> Hello!
05:58:27 <Boreeas> that line pinged me
05:58:29 <Boreeas> wtf
05:58:40 <Axman6> o.O
05:59:27 <Boreeas> oh i see. because i'm mu on other servers, and I told my client to alert me on µ...
05:59:29 <Boreeas> carry on :P
06:03:49 <rightfold> I too get to enjoy such pings. :P
06:07:00 <int-e> let's discuss some least fixed points
06:12:29 <benzrf> > text "\r\n"
06:12:50 <benzrf> > text "\r\nPRIVMSG benzrf sup"
06:12:53 <lambdabot>  PRIVMSG benzrf sup
06:12:56 <benzrf> aww
06:12:58 <benzrf> :)
06:17:07 <deepfire> is it possible to generate lenses for associated data family instances?
06:27:10 * hackage serokell-util 0.5.3 - General-purpose functions by Serokell  https://hackage.haskell.org/package/serokell-util-0.5.3 (shersh)
06:27:43 <Gurkenglas_> How hard would it be to allow instances that use out-of-scope identifiers/classes/types, which only apply once those are in scope?
06:32:05 * deepfire finds a negative answer to his question: https://github.com/ekmett/lens/issues/283#issuecomment-20598614
06:32:55 <mniip> %% filter isAlpha [minBound..]
06:33:02 <yahb> mniip: http://qp.mniip.com/y/2
06:33:26 <mniip> %% putStr $ filter isAlpha [minBound..]
06:33:30 <yahb> mniip: http://qp.mniip.com/y/3
06:34:34 <geekosaur> Gurkenglas_, the problem is class instances are records constructed at compile time. you can't control scoping of parts of what amounts to a global  constant
06:35:05 <mniip> Gurkenglas_, in large, a class is like a data definition, and an instance is like a constructor use
06:35:30 <Gurkenglas_> geekosaur, how do implicit parameters work then?
06:35:40 <mniip> they're literally parameters
06:36:07 <mniip> they're compiled to functions
06:36:28 <geekosaur> and that 'global' nature (because of the open world assumption) means the constant must be in scope everywhere and the data type can't be checked for completeness (consider that Map has instances that are usable even though its constructors are only in scope internally)
06:36:54 <Gurkenglas_> What happens, then, if we compile such instances to functions?
06:37:13 <mniip> functions of what
06:37:26 <Gurkenglas_> of the missing classes/types/identifiers
06:37:32 <mniip> ok, here's roughly how instances work:
06:37:33 <geekosaur> what does that even mean
06:37:37 <geekosaur> theyre compile time not run time
06:38:06 <geekosaur> also, even if you can find some way over being confused about compile vs. run time, how does a potential 90x slowdown in pathological cases sound?
06:38:21 <python476> ho lyah ends up abruptly on the zipper chapter, funny
06:38:32 <python476> time to unfold the next tutorial
06:39:04 <ertes> python476: how about starting your first project?
06:39:05 <mniip> data EqDict a = EqDict { (==) :: a -> a -> Bool; (/=) :: a -> a -> Bool }
06:39:10 <geekosaur> (and still significant slowdowns even if you don;'t hit the worst cases. ghc goes toa lot of effort to optimize away class dictionaries, but making them functions even only in some cases (and not sure how *that* would work) would impair that with rather severe performance costs
06:39:18 <python476> ertes: that could work except I have no idea so far :)
06:39:28 <mniip> eqBool :: EqDict Bool; eqBool = EqDict { (==) = ..., (/=) = ...}
06:39:34 <Gurkenglas_> geekosaur, 90x slowdown because you can't inline until you know whether the instance exists?
06:39:43 <mniip> Gurkenglas_, the above is pretty much how classes
06:39:47 <mniip> to the point of unsafecoercing
06:39:49 <python476> my haskell reading is almost more about abstraction inspiration and curiosity; and a bit of functional foo
06:39:56 <ertes> python476: if you can't think of something useful, just replicate a small (!) command line tool
06:40:13 <geekosaur> Gurkenglas_, yes, inlining is one of severla things that goes away. multiply indirect lookups is another
06:40:18 <ertes> python476: perhaps start with something very small like 'cat'
06:40:34 <ertes> python476: or, if you want, i can give you an exercise
06:41:02 <python476> ertes: I'm eyeing hard on write scheme in 48h
06:41:10 <python476> but maybe a smaller cli util could be nice
06:41:37 <ertes> python476: it certainly pays off to do that, but unfortunately scheme-in-48 doesn't really teach you some of the essential things
06:41:46 <ertes> python476: like dealing with I/O and user interaction
06:42:42 <ertes> python476: interestingly you will find it much easier to write scheme-in-48 in haskell than to write something like 'grep'
06:46:32 <geekosaur> Gurkenglas_, the only way that what you want makes any sense is if you build the class/instance definition via TH. but even then there's a sting in the tail because TH can cheat and access things that aren't in scope for normal code.
06:47:11 <geekosaur> meaning that there's a good chance the cases you're trying to deal with will end up with instances (possibly inappropriately) anyway
06:50:50 <geekosaur> it might make sense in a language like Javascript where there isn't much of a meaningful difference between "compile time" and "run time". it doesn't make sense in Haskell, and equivalent functionalities wouldn't make sense in Java or C
06:51:24 <geekosaur> (well, in C you could probably do it with a lot of C preprocessor hackery, but that's going to be syntactically expensive both in the definition and probably in use sites)
06:52:03 <mniip> Gurkenglas_, check this out
06:52:07 <mniip> % :t given
06:52:08 <yahb> mniip: given :: DictRep c -> (c => a) -> a
06:52:12 <mniip> % given (EqDict (\f g -> f True || g True) undefined) (not == id)
06:52:13 <yahb> mniip: True
06:52:25 <python476> ertes: but I wanted to go back to lisps evaluation schemes so you know.. tempting
06:52:28 <mniip> % :t known
06:52:28 <yahb> mniip: known :: c => DictRep c
06:52:35 <python476> IO is fine but I'm more into semantics, graphs
06:53:00 <mniip> % cshow known ()
06:53:00 <yahb> mniip: "()"
06:53:25 <mniip> % :info ShowDict
06:53:25 <yahb> mniip: data instance DictRep (Show a) = ShowDict {...} -- Defined at <interactive>:13:34
06:54:03 <mniip> % :t cshow
06:54:03 <yahb> mniip: cshow :: DictRep (Show a) -> a -> String
06:54:36 <geekosaur> not sure any of that lets you conditionalize on whether the right things are in scope
06:55:01 <mniip> I'm just showing him how it works on the inside
06:55:38 <geekosaur> closest you get there is, I think, so-called "superclasses" (or what I consider/call prerequisites), and I don't think that works here except in the special case of derived instances where Haskell is defined to cheat
06:55:40 <mniip> http://lpaste.net/7821481693394501632
07:01:39 <heath> https://www.youtube.com/watch?v=KZIN9f9rI34
07:01:50 <heath> Monad Transformer State - Michael Snoyman
07:14:42 <vaibhavsagar> how would I model a hashmap with two types of keys pointing to a single value?
07:16:07 <vaibhavsagar> e.g. suppose I have a string and a int as two ways of uniquely identifying a value
07:16:54 <vaibhavsagar> but I want to query with one of them at a time, sometimes the int and other times the string
07:17:48 <geekosaur> intermediate map holding the actual value and keyed by a unique value (whose "next available" might be held in the same map with a distinct key, say using an IntMap with key 0 holding the next-available and the hashmaps going from their keys to that intermediate key)?
07:17:50 <vaibhavsagar> would this be a bimap + a map from one of the keys to the value?
07:19:38 <vaibhavsagar> in this case I might have enough information to construct the bimap
07:21:50 <Gurkenglas_> mniip, so eqBool would become something like (?Bool :: *) => EqDict ?Bool. geekosaur, aren't the additional lookups caused by the lack of inlining? geekosaur, could one build a TH library that does this and exposes a safe interface? 
07:21:56 <Unhammer> Is it possible, with e.g. GADTs, to have a type T such that [One "foo", Top (One ","), One "bar" `Both` One "fie"] is allowed, but (Top(One "foo") `Both` One"bar") is not? Ie. a Both can contain two One/Both's  but a Top always has to be at the "top"
07:22:09 <mniip> Gurkenglas_, wait you can have implicit type parametesrs?
07:22:30 <Unhammer> I thought maybe DataKinds and a typeclass might work, but then I guess "un-promotable type One"
07:22:50 <geekosaur> you very badly want todo something that doesn;t actually make a lot of sense. what problem are you actually trying to solve?
07:23:07 <mniip> Unhammer, yeah it's possible
07:23:11 <geekosaur> (Gurkenglas_)
07:24:34 <geekosaur> Gurkenglas_, yes as I said earlier it is lack of inlining. you can;t inline what you seem to be truying to do, although I can;t be certain because I;m not sure what you are tryuing to do is even sane
07:24:50 <geekosaur> it feels like you really think typeclasses/instances are something different from what they are
07:24:54 <Gurkenglas_> mniip, I don't know, I was guessing and it sounds like it makes sense to me. geekosaur, the actual problem is that lens has to depend on everything to come with batteries included
07:25:07 <geekosaur> and trying to twist them into being something else ends badly
07:25:17 <mniip> Gurkenglas_, I don't think you can do that
07:25:27 <mniip> I can't see how ever you could implement that
07:25:41 <mniip> Unhammer, Top (Top _) allowed?
07:26:21 <Unhammer> no
07:26:33 <mniip> ok so
07:26:50 <geekosaur> Gurkenglas_, open world assumption. you're trying to close the world, or at least put a door in the way. typeclasses don't and can't work that way
07:26:58 <at> Multi-parameter type classes are permitted, with flag -XMultiParamTypeClasses.
07:27:26 <mniip> data T (c :: Bool) where One :: String -> T True; Top :: T True -> T False; Both :: T a -> T a -> T False
07:27:53 <at> In function showHelp GHC sees no overlapping instances, and so uses the MyShow [a] instance without complaint. In the call to myshow in main, GHC resolves the MyShow [T] constraint using the overlapping instance declaration in module Main. As a result, the program prints
07:27:58 <geekosaur> the typesystem becomes unsound if typeclass instances aren't global and unconditional
07:29:07 <geekosaur> @paste
07:29:07 <lambdabot> Haskell pastebin: http://lpaste.net/
07:30:20 <Gurkenglas_> geekosaur, I asked whether the additional lookups are caused by the lack of inlining because of "<geekosaur> Gurkenglas_, yes, inlining is one of severla things that goes away. multiply indirect lookups is another". Why couldn't you inline? Anything that refers to the instances requires that the relevant identifiers are in scope. (I suppose one would have to restrict the instances to using that which one has to 
07:30:21 <Gurkenglas_> import to refer to the instance, or also only allow the use of code using the instances once those identifiers are in scope.)
07:31:08 <geekosaur> "Anything that refers to the instances" --- so Data.Map, which doesn;t expose its constructors, doesn;t ever have typeclass instances?
07:31:13 <geekosaur> that is not how typeclasses work
07:31:52 <Gurkenglas_> The user only has to provide the identifiers if Data.Map doesn't have them, obviously
07:32:43 <geekosaur> that ... doens;t even make sense to me. What identifiers?
07:32:56 <Gurkenglas_> The ones that the instance definition uses
07:33:48 <geekosaur> this still isn;t makeing any sesne
07:33:54 <geekosaur> probably because I know what typeclasses are
07:34:11 <mniip> again
07:34:13 <Unhammer> ooh; thanks mniip; will have to try when back on computer
07:34:26 <mniip> please realize that using a datatype involves more than invoking the constructors by their relocs
07:34:32 <mniip> it also involves destructuring it
07:34:39 <mniip> for which you need to know the layour
07:34:40 <mniip> layout
07:35:03 <mniip> same for classes which are basically just data
07:35:12 <mniip> albeit invisible and inlined for you
07:35:54 <Gurkenglas_> "again"? I don't think I've heard this before, what do you mean by "invoking constructors by their relocs" or "destructuring"?
07:36:45 <mniip> ok
07:36:50 <mniip> how does haskell code work?
07:37:57 <Gurkenglas_> You probably want some particular answer, but that question has too many answers
07:40:58 <mniip> you know haskell code gets compiled to machine code at module level right?
07:41:09 <mniip> with minimal information in .hi interface files
07:42:30 <Gurkenglas_> (You know, this isn't completely specific to typeclasses. Let's rephrase as "sections of code you're only allowed to use if some particular package is already built)
07:42:42 <mniip> it's specific to datatypes
07:42:55 <mniip> using a datatype you don't know
07:43:16 <geekosaur> Gurkenglas_, how does that work when building a library that will be linked into some program 6 months from now?
07:43:30 <geekosaur> how does the library know what will happen in 6 months?
07:44:44 <Gurkenglas_> geekosaur, the code you write only works if the assumptions you made hold true
07:45:02 <geekosaur> how does it _know_ that?
07:45:27 <Gurkenglas_> How does it know, in the future, whether the assumptions it made turned out correct?
07:45:46 <geekosaur> exactly
07:46:29 <Gurkenglas_> The assumption it made are that the code it has written would compile if the future library had already existed
07:48:10 <Gurkenglas_> Not sure how to process "<mniip> you know haskell code gets compiled to machine code at module level right?".
07:48:57 <geekosaur> sigh
07:49:14 <geekosaur> you are not understanding. you really don't know how compiled code works, do yyou?
07:49:37 <geekosaur> the only way what you are thinking of makes any sense is if the library is recompiled on the fly, custom for your executable
07:49:54 <geekosaur> there is no way to pass around these assumptions. there's no way to *describe* these assumptions
07:50:02 <mniip> yeah almost as if you thing haskell code in textual form gets preprocessed into one large chunk
07:50:21 <mniip> for every executable and library
07:50:53 <Gurkenglas_> The code it has written would compile if all the types of identifiers it preemptively used unify with the future true ones
07:51:07 <Unhammer> mniip,  I tried your solution, but [One "a", Top (One "b")] still gives "couldn't match T 'False with T 'True"
07:51:29 <Unhammer> where data T (c :: Bool) where One :: String -> T True; Top :: T True -> T False; Both :: T a -> T a -> T False
07:51:36 <geekosaur> Gurkenglas_, again, that can only be done if the library is *recompiled* when you use it in the future
07:53:03 <Gurkenglas_> Couldn't you say that the assumptious code is compiled as part of the future library?
07:54:03 <fragamus> geekosaur: I wrote that Read instance, and it worked great... now I am trying to derive one for a different class that is going to parse in record format... I tried a derived instance again and it did not parse even though the data is in record format...
07:54:41 <mniip> Gurkenglas_, where is it stored
07:55:15 <geekosaur> fragamus, as I mentioned at the time, the fields also have to be in correct order
07:55:18 <mniip> Unhammer, hmm
07:55:21 <mniip> One :: String -> T a
07:55:22 <geekosaur> as originally defined
07:55:48 <mniip> Both :: T a -> T b -> T False
07:55:52 <fragamus> oh riiiight...
07:56:36 <Gurkenglas_> mniip, I did not expect that question. Whereever it stores the already compiled code of the assuming library, I suppose?
07:56:41 <geekosaur> you may also have to wath out for other things, like the Read instance for lists which are fields will expect quoted strings for [Char] and canonical list format [a,b,c] for other types (that is, a:b:c:[] won't parse_
07:56:51 <mniip> Gurkenglas_, but you can't "compile" it
07:57:08 <mniip> you don't have the descriptions of the types you "work" with
07:57:17 <fragamus> geekosaur so I guess i am writing a generic parser for record format today... i think someone else must have had to write that before
07:57:17 <michalrus> Oh, how wonderful that Data.Coerce does not allow one to escape smart constructors. Thank you! ♥
07:57:28 <mniip> michalrus, that was kind of the idea
07:57:32 <michalrus> Mhm. ^.^
07:57:37 <Unhammer> mniip but I  want Both in the list too..
07:57:47 <geekosaur> derived Read and Show instances are quite dumb. if you need anythinbg fancier, you;re expected to write a parser, although you could write one using ReadS / ReadP if you don';t want to haul in a full parser library
07:58:06 <mniip> Unhammer, it should work
07:58:15 <Gurkenglas_> mniip, according to the idea in my second to last line, it would only compile the parts that it already has all the components for
07:58:18 <mniip> [One _, Both _ _] :: [T False]
07:58:27 <mniip> and the not compiled parts
07:58:30 <mniip> where do they go
07:58:40 <Gurkenglas_> Wherever the compiled parts go, I suppose.
07:58:47 <mniip> can't have that
07:58:53 <Unhammer> and Top
07:59:06 <Gurkenglas_> The compiled part is presumably in a file in some folder. Put another file into that folder.
07:59:11 <Unhammer> which is T True
07:59:45 <mniip> Unhammer, Top can fit in T False too
07:59:48 <rain1> hi
07:59:51 <mniip> it takes T True as argument
08:00:03 <rain1> could anyone help me with javascript? i want to know how await/async is related to monads
08:00:10 <fragamus> geekosaur: Read/Show was always so magical, and now I see the blood and sweat that makes the magic
08:00:46 <hpc> rain1: it's not very related at all
08:00:51 <mniip> rain1, that's a tough one
08:00:55 <Gurkenglas_> mniip, would it help if the code that needs additional dependencies is put into its own module?
08:00:59 <rain1> aw.. darn
08:01:29 <hpc> there's /types/ that it can be similar to if you squint a bunch, and some of those have Monad instances
08:01:37 <hpc> but nothing about it relates to Monad directly
08:01:54 <hpc> more on the level of System.out.println is related to monads because it does IO, that sort of thing
08:02:03 <mniip> Gurkenglas_, so really you propose to store textual modules to conditionally sneak into other packages at their time of compilation
08:02:05 <rain1> i get what you mean!
08:02:09 <rain1> thanks :)
08:02:45 <Gurkenglas_> That sure sounds like a way to implement what I originally wanted, which I supplied when you asked for one.
08:02:54 <hpc> rain1: check out https://hackage.haskell.org/package/async though
08:03:05 <mniip> rain1, "I want to know how the number 3 relates to rings"
08:05:44 <Gurkenglas_> Although if it is to be partitioned into modules, to help the lens situation modules would also have to be allowed to grant parental authority to a list of other modules, which could then provide instances that are not considered orphans.
08:05:55 <Gurkenglas_> Would that be possible?
08:08:19 <numee> Is it possible to make addOne in this code less redundant? http://lpaste.net/9052863389981736960
08:08:26 <numee> Specifically, I'd like GHC to figure out all possible parameters which would result in a specific type when applied to a type function
08:18:34 <Gurkenglas_> numee, using https://hackage.haskell.org/package/NumInstances-1.4/docs/Data-NumInstances-Tuple.html , maybe you can do "Num (ColorToTuple c) => SColor c -> ColorToTuple c -> (SColor c, ColorToTuple c)"
08:19:21 <nshepperd_> For Gurkenglas_ thing wouldn't you put the not fully compiled parts into the hi file
08:20:25 <geekosaur> .hi files are already one of the slowest parts of compilation
08:22:53 <nshepperd_> I could imagine a thing like "import optional <module> (identifiers)" where you would be required to specify the exact identifiers you expect to exist and their types etc
08:23:50 <nshepperd_> And then things that use those identifiers would be dumped into the .hi file and any users would be forced to inline them at the use site
08:24:08 <nshepperd_> Yeah, it wouldn't be great for performance
08:25:14 <mjhoy> are there any functors in the wild that don't obey the functor laws?
08:25:37 <mniip> that's very hard to come by
08:25:56 <mniip> the hughes list functor can be made disobey functor laws if you use its constructors directly
08:26:29 <mjhoy> hmm, thanks
08:27:16 <CuriousErnestBro> are monads like templates?
08:28:50 <mniip> no
08:31:00 <numee> Gurkenglas_: My problem is that GHC does not automatically infer a parameter type of a type function from a resulting type. I'm having difficulty to wrap my head around the way in which the library helps the situation
08:31:04 <hpc> CuriousErnestBro: have you learned Functor and Applicative?
08:31:28 <CuriousErnestBro> nope
08:31:40 <hpc> learn Functor first, then Applicative
08:31:49 <CuriousErnestBro> okay
08:32:04 <hpc> Monad is Applicative plus one more definition
08:32:42 <geekosaur> numee, what exactly do you think the type function is here
08:32:43 <int-e> . o O ( Nobody can tell you what a Monad is. In order to understand Monads, you have to discover them yourself. )
08:32:57 <nshepperd_> Or you could roll all this stuff into cabal. Just have a separate module that will only be compiled whenever whatever it depends on is installed
08:34:00 <numee> geekosaur: the type function is ColorToTuple in http://lpaste.net/9052863389981736960
08:34:14 <nshepperd_> Although then you get an annoying orphan instance warning
08:34:41 <nshepperd_> You'd need a bit of ghc extension to make that go away
08:34:43 <Gurkenglas> nshepperd_, could you let the parent specify a number of modules that are also allowed to make instance that aren't considered orphans?
08:34:54 <mniip> int-e, wise but honestly not that remote from truth
08:35:35 <fakenullie> Monads looks really easy as class with two operators
08:35:47 <Gurkenglas> Ah, you already thought it was possible if we're willing to go to that sort of effort.
08:36:14 <fakenullie> I don't know why every resource hides this
08:36:21 <nshepperd_> Well, you can specify in the main module that a certain instance will exist later
08:36:55 <nshepperd_> And then make it so that importing the main module imports the extra one, if it exists
08:37:12 <int-e> mniip: it's inspired by the title of http://blog.sigfpe.com/2006/08/you-could-have-invented-monads-and.html
08:37:53 <int-e> (which stands out from tutorials of that time by avoiding the burrito trap)
08:37:58 <nshepperd_> Importantly, importing the main module should bring the instance into scope unconditionally. Even if actually using it is a compile error. So that way instance coherence can't be broken
08:39:04 <nshepperd_> I thought backpack was supposed to solve this problem, but i don't know much about it
08:41:17 <nshepperd_> (Say not "monads are like X", but "X is an example of a monad")
08:41:55 <ggVGc> monads are just onads with an m
08:45:43 <ertes> python476: well, do what you enjoy doing…  just saying, you may want to learn writing *programs* at some point =)
08:45:48 <rightfold> monads are like applicatives
08:46:10 <ertes> python476: writing programs is a non-trivial skill in haskell
08:47:00 <Jikstra[m]> ertes: why?
08:47:25 <Jikstra[m]> depending on the problem and your skillset, it's quite trivial in haskell
08:47:43 <mniip> huh
08:48:18 <mniip> ertes, were you scolled up
08:48:28 * DigitalKiwi confused too
08:52:20 <geekosaur> or running bad/misconfigured client that mixes pm in with channel foo
08:53:10 * hackage stratosphere 0.13.0 - EDSL for AWS CloudFormation  https://hackage.haskell.org/package/stratosphere-0.13.0 (jdreaver)
08:57:10 <rightfold> skillsmatter
09:02:33 <Gurkenglas> nshepperd_, what if specifying the instance already needs you to refer to types or classes that aren't defined
09:02:37 <ertes> mniip: no, i just responded to a highlight =)
09:04:11 <ertes> Jikstra[m]: challenge: write a very small tool like wget…  it doesn't have to do anything fancy, but it should feature a good CLI, a progress bar (that doesn't stall, if the network is down) and supports concurrent downloads
09:04:35 <nshepperd_> Gurkenglas: you only actually need to specify the instance head
09:04:49 <nshepperd_> So i guess you can provide a fully qualified name there
09:04:49 <Gurkenglas> nshepperd_, that's what I meant
09:05:11 <Gurkenglas> Can you provide a fully qualified name without a dependency?
09:06:14 <nshepperd_> Why not. It's just a name
09:06:42 <hexagoxel> challenge: don't assume challenges proof anything.
09:06:44 <shapr> `/me hops quietly
09:06:47 <shapr> whoops
09:06:50 * shapr hops quietly
09:06:50 <shapr> ok, that's better
09:07:41 <shapr> Anyone in Boston want to get together to write Haskell in the next two weeks?
09:08:04 <nshepperd_> It just needs enough information for the compiler to be able to resolve the instance at any use site
09:21:10 <rudol> is there an equivalent in microlens for `Control.Lens.At`'s   `contains :: Index m -> Lens' m Bool` function?
09:22:12 <rudol> ... or an alternative?
09:22:33 <Welkin> what is microlens?
09:22:41 <Welkin> another lens derivative?
09:23:07 <rudol> yep - lightweight version of Lens
09:23:16 <Welkin> why are there so many of them?
09:23:41 <rudol> Lens is recommended for larger projects and has a lot of functionality and dependenies
09:24:02 <rudol> microlens is lightweight but still covers a lot of useful ground
09:24:04 <cocreature> lens alternatives are great, they result in me depending on 5 different implementations of lens transitively
09:24:17 <Welkin> I thought that was what lens-family was for
09:24:32 <rudol> I haven't lookes at that one yet
09:24:35 <Welkin> o.o
09:24:38 <Welkin> my god
09:24:41 <Welkin> they are multiplying
09:25:09 <ertes> hexagoxel: the point is that there are multiple non-trivial skills involved in writing such a seemingly simple program
09:25:59 <ertes> like understanding cabal and your tool-chain, a reasonable development cycle, library choices and also learning those libraries, concurrency, etc.
09:26:26 <nshepperd_> This is why we need the thing Gurkenglas was talking about, so that people will stop cloning lens :)
09:26:35 <Welkin> nshepperd_: what thing was that?
09:26:43 <Welkin> people keep cloning parsec too, though!!
09:27:03 <cocreature> well parsec development is effectively dead
09:27:10 <cocreature> so creating alternatives to that is actually reasonable
09:27:14 <rudol> edwardk has a nice little pong example demonstrating use of Lens and I wanted to see if microlens would be sufficiently featureful
09:27:16 <nshepperd_> Deferred compilation of typeclass instances
09:27:20 <cocreature> and quite a few of those also focus on different things
09:27:53 <ertes> rudol: i'd just go with lens
09:27:57 <cocreature> whereas the only thing differentiating microlens from lens is a limited featureset (afaik)
09:27:59 <nshepperd_> Welkin: we were discussing it this morning
09:28:01 <rudol> it seems microlens is missing `contains`, but maybe it has an alternative
09:28:28 <nshepperd_> This contains thing seems weird
09:28:57 <nshepperd_> What does contains .~ True do
09:29:22 <nshepperd_> Or is it actually a Getter. That would make more sense
09:29:36 <rudol> ertes, yes, I think I will level up to lens later, but I was trying to work with microlens first as there's a lot to read
09:29:58 <ertes> > (contains 'a' .~ True) (S.fromList "bc")
09:30:00 <lambdabot>  fromList "abc"
09:30:05 <ertes> nshepperd: ^
09:30:34 <ertes> rudol: microlens is really just lens with lots of features missing, but without being any simpler than lens
09:31:30 <rudol> ertes I am using microlens in a few places, and ideally would rather not change the `depends` and imports for now, if possible
09:31:46 <rudol> keyPressed key = p^.keys.contains (SpecialKey key)
09:31:52 <nshepperd_> Hm, that's niche. Is Index only for set types then?
09:32:18 <ertes> nshepperd_: pretty much
09:32:52 <rudol> can you think of a work around with some sort of traversal?
09:33:12 <ertes> rudol: you could just implement 'contains' for the type in question
09:33:36 <rudol> so make an instance of Contains?
09:34:14 <rudol> http://hackage.haskell.org/package/lens-4.15.4/docs/Control-Lens-At.html#v:contains
09:34:39 <ertes> rudol: if you don't want to depend on lens, you can just write your own setContains or intSetContains or …
09:36:06 <Welkin> but you NEED lens to do things like `player ^. name`1
09:36:42 <rudol> microlens has that already
09:36:56 <Welkin> rudol: it was a joke
09:37:12 <Welkin> you don't need any kind of lens library to do that
09:37:21 <ertes> @let intSetContains x f xs = (\b -> (if b then IM.insert else IM.delete) x xs) <$> f (IM.member x xs)
09:37:22 <nshepperd_> contains a = lens (Set.member a) (bool (Set.delete a) (Set.insert a))
09:37:23 <lambdabot>  .L.hs:195:39: error:
09:37:23 <lambdabot>      • Couldn't match type ‘IM.IntMap a’
09:37:23 <lambdabot>                       with ‘IM.IntMap (IM.IntMap a) -> IM.IntMap (IM.IntMap a)’
09:38:18 <rudol> right, so need to make an instance of Lens At.Contains - that might work, thanks!
09:38:48 <nshepperd_> Nobody mentioned writing an instance
09:38:54 <nshepperd_> Just write a function
09:39:05 <ertes> rudol: i don't understand why you keep coming back to Contains and instances
09:39:29 <ertes> also what the hell is wrong with my implementation?
09:41:04 <ertes> :t (IM.insert, IM.delete, IM.member)
09:41:05 <lambdabot> (IS.Key -> a1 -> IM.IntMap a1 -> IM.IntMap a1, IS.Key -> IM.IntMap a2 -> IM.IntMap a2, IS.Key -> IM.IntMap a3 -> Bool)
09:41:16 <ertes> d'oh
09:41:25 <ertes> @let intSetContains x f xs = (\b -> (if b then IS.insert else IS.delete) x xs) <$> f (IS.member x xs)
09:41:27 <lambdabot>  Defined.
09:42:00 <ertes> > (intSetContains 'x' .~ True) (IS.fromList "abc")
09:42:03 <lambdabot>  error:
09:42:03 <lambdabot>      • Couldn't match type ‘Char’ with ‘Int’
09:42:03 <lambdabot>        Expected type: IS.Key
09:42:20 <ertes> > (intSetContains 10 .~ True) (IS.fromList [1,2,3])
09:42:23 <lambdabot>  fromList [1,2,3,10]
09:45:57 <ertes> @let betterIntSetContains x f xs | IS.member x xs = (\b -> if b then xs else IS.delete x xs) <$> f True | otherwise = (\b -> if b then IS.insert x xs else xs) <$> f False
09:45:58 <lambdabot>  Defined.
09:51:48 <Gurkenglas> nshepperd_, there's much more inertia in ghc than in cabal, right? So of the language extension that allows specifying where an instance is defined, and the cabal patch that allows deferring compilation of modules, the former is less likely to get anywhere?
09:54:42 <rudol> nshepperd_- I couldn't get that to compile; somehow introducing `import Data.Bool (bool)` broke some other Set operations.
09:55:02 <rudol> ertes - betterIntSetContains works fine, thank you!
09:56:23 <rudol> the reason I was asking re the Contains typeclass is that I thought there may need to be an instance implemeted for whatever the type of the field is 
09:56:42 <Welkin> rudol: are you a red nosed reindeer?
09:57:12 <rudol> is that another joke?
09:57:28 <Welkin> rudol(f): yes
09:57:36 <rudol> nice one :)
09:59:30 * nshepperd was wraiting that from memory
09:59:50 <Welkin> wraithing?
10:00:17 <nshepperd> i'm a ghostwriter
10:01:49 <Unode> I have: func1 <$> listOfData; func2 <$> listOfData . How can I convert it such that (func1, func2) <$> listOfData  returns a tuple of the output of each function?
10:01:55 <nshepperd> /O
10:02:23 <nshepperd> anyway, it's actually contains a = lens (Set.member a) (flip $ bool (Set.delete a) (Set.insert a))
10:02:44 <nshepperd> i got the order of arguments of lens the wrong way around
10:04:51 <Unode> I know I could do: zip (func1 <$> listOfData) (func2 <$> listOfData) but I'm looking for something that can generalize to more than 2 functions and corresponding tuple, triple ...
10:05:54 <nshepperd> ((*2) &&& (*10)) <$> [1, 2, 3]
10:06:02 <nshepperd> > ((*2) &&& (*10)) <$> [1, 2, 3]
10:06:05 <lambdabot>  [(2,10),(4,20),(6,30)]
10:08:10 <ertes> Unode: map (\x -> (f x, g x)) xs
10:08:16 <ertes> or (&&&) if you like arrow combinators
10:08:34 <ertes> or (liftA2 (,) f g), if you prefer applicative style
10:09:05 <ertes> Unode: also (zip (func1 <$> listOfData) (func2 <$> listOfData)) is a really bad idea
10:09:25 <Unode> ertes: care to explain why?
10:09:30 <Unode> and thanks for all the feedback
10:10:04 <ertes> well, it might just work in this case, but you might also end up with sharing, which means that you will build listOfData in memory
10:10:43 <ertes> same reason why this is bad:  sum xs / fromIntegral (length xs)
10:10:44 <nshepperd> it's a moderately bad idea, since it traverses the list twice, and hence doesn't fuse
10:11:07 <ertes> except that this latter example will definitely suck, while yours might just be a little slower
10:11:46 <MarcelineVQ> nshepperd: doesn't or might not?
10:13:33 <nshepperd> doesn't. there might be a rewrite rule for zip but it only fuses one of the arguments
10:14:07 <cocreature> couldn’t you make a zip (map f xs) (map g xs) rewrite rule?
10:14:46 <nshepperd> you could, yeah
10:14:52 <nshepperd> I would be suprised if anyone has
10:17:19 <MarcelineVQ> 'There used to be a foldr2/right rule, allowing foldr2 to fuse with a build form on the right. However, this causes trouble if the right list ends in a bottom that is only avoided by the left list ending at that spot.' ah hmm
10:19:14 * hackage html-tokenizer 0.6.1 - An "attoparsec"-based HTML tokenizer  https://hackage.haskell.org/package/html-tokenizer-0.6.1 (NikitaVolkov)
10:19:31 <C_Everett_Koop> hi
10:20:13 <C_Everett_Koop> is there a good way to configure preparing of an environment for intero
10:20:14 <C_Everett_Koop> ?
10:20:16 <rudol> nshepperd - yep, I had flipped it too, works fine now, thanks.
10:20:35 <C_Everett_Koop> in particular, i need to setup some system variables like DYLD_LIBRARY_PATH
10:20:51 <C_Everett_Koop> for stack ghci to find shared libraries 
10:21:32 <nshepperd> Gurkenglas: I think we need both for the result to be nice
10:23:08 <nshepperd> Gurkenglas: you can patch cabal to defer compilation of a module, but without anything special in ghc it's no different than importing an orphan instance from some other package (ie. you have to explicitly import the deferred module to get the instance)
10:24:14 <nshepperd> Gurkenglas: which opens you to the usual problems of orphan instances
10:25:49 <nshepperd> but if you also patch ghc to let the main module 'reexport' the deferred instances in some sense, then it works very well
10:26:36 <MarcelineVQ> C_Everett_Koop: no idea really, but possibly https://docs.haskellstack.org/en/stable/yaml_configuration/#extra-include-dirsextra-lib-dirs in your stack.yaml for libraries specifically
10:28:05 <C_Everett_Koop> MarcelineVQ I think there may be some issues with OSX that render extra-lib-dirs non-functional, or at least it seems like it
10:28:24 <MarcelineVQ> dang, I wish I knew more about it
10:28:47 <Profpatsch> Hm, aeson gives me a ByteString.
10:29:06 <Profpatsch> Value uses Text as for the String constructor.
10:29:21 <Profpatsch> Why not give a Text?
10:29:29 <rightfold> Does Gurkenglas mean pickle jar?
10:29:30 <Gurkenglas> nshepperd, yes, I had in mind that both are necessary
10:29:38 <Profpatsch> And what’s the encoding of the ByteString?
10:29:56 <phadej> Profpatsch: efficiency, utf8 (json spec says that)
10:30:17 <cocreature> Profpatsch: there is a Data.Aeson.Text module which provides an encodeToLazyText https://hackage.haskell.org/package/aeson-1.2.3.0/docs/Data-Aeson-Text.html#v:encodeToLazyText
10:30:22 <MarcelineVQ> C_Everett_Koop: are you able to check if cli flags will work instead? like stack --extra-include-dirs DIR  --extra-lib-dirs DIR ghci
10:30:59 <C_Everett_Koop> MarcelineVQ trying it out
10:31:17 <Profpatsch> cocreature: Heh, I missed that.
10:31:19 <MarcelineVQ> C_Everett_Koop: also consider making a stack or intero github issue about it if you're out of options. the worst that can happen is someone tells you it's not an issue and closes it
10:31:19 <nshepperd> hm, maybe you could actually do this without patching cabal, only ghc
10:31:32 <cocreature> Profpatsch: it’s relatively new
10:31:43 <Profpatsch> cocreature: Do you think I can pass that over to the Browser’s JS runtime again?
10:31:54 <nshepperd> with the same kind of 'deferred reexport' of something in an entirely different package
10:32:01 <Profpatsch> (from GHCJS)
10:32:15 <cocreature> Profpatsch: not sure I understand the question? what do you mean by passing it to the JS runtime?
10:32:31 <nshepperd> then the error message when you try to use the instance would say "please install lens-foo-orphans"
10:32:49 <C_Everett_Koop> MarcelineVQ just to make sure i'm not confused, --extra-lib-dirs should be equivalent to adding the location to DYLD_LIBRARY_PATH right?
10:33:10 <Profpatsch> cocreature: I’m trying to make a library (dhall) accessible from JS.
10:33:37 <cocreature> Profpatsch: Text is not represented as a javascript string, the type for that is JSString
10:34:22 <Profpatsch> cocreature: Oh right, I need to go through that.
10:34:40 <Profpatsch> rn I’m just trying to pretty-print to the console.
10:34:54 <Profpatsch> is there a pretty-printer in aeson?
10:35:05 <cocreature> no but iirc there is an aeson-pretty package
10:35:16 <MarcelineVQ> C_Everett_Koop: I'm not quite sure
10:36:01 <MarcelineVQ> C_Everett_Koop: but it doesn't look like it, based on   stack --extra-lib-dirs DIRS exec env
10:36:04 <crucify_me> how does reverse actually switch the order of the elements beginning with [] , when its written recursively with concat like this? 
10:36:07 <crucify_me> https://ptpb.pw/rIyC
10:36:58 <crucify_me> that syntax confuses me
10:37:42 <crucify_me> yesterday I was told there is no linear recursion in haskell which requires a 'stack' that goes from right to left
10:38:12 <crucify_me> but even thinking of it that way...
10:40:32 <crucify_me> I don't see how it extracts out the [] to get this result :     (([] ++ [3]) ++ [2]) ++ [1]
10:40:49 * hackage servant-cassava 0.10 - Servant CSV content-type for cassava  https://hackage.haskell.org/package/servant-cassava-0.10 (phadej)
10:41:02 <crucify_me> from ' reverrse [1,2,3] '
10:41:15 <rightfold> I don't quite understand the signature of parseJSON. It returns a *parser*, but takes the input itself? Shouldn't the parser already take the input?
10:41:24 <rightfold> Does "parser" here actually mean Either?
10:42:32 <phadej> rightfold: parser there is such because we have Value -> Parser a, but also Object -> Parser a, and Text -> Parser a etc.
10:43:08 <rightfold> What does "Parser" concretely do?
10:43:55 <rightfold> Looking at the definition it seems to be a CPS-based error reporting monad
10:43:58 <phadej> rightfold: but yes, Parser in aeson is a cps-ised Result, which is kind-of Either
10:44:04 <rightfold> Thanks. :3
10:44:16 <phadej> (also there's attoparsec's Parser in the haddocks, btw)
10:44:35 <phadej> the ones which are in: http://hackage.haskell.org/package/aeson-1.2.3.0/docs/Data-Aeson-Parser.html
10:44:52 <phadej> and those are different :)
10:45:06 <masaeedu[m]> When people talk about monads being a "monoid in the category of endofunctors", it seems to me that this implies we are only talking about one functor at a time, e.g. say []
10:45:39 <masaeedu[m]> And that the morphisms in the monoidal category are natural transformations, which are functions `forall a. [a] -> [a]`
10:45:44 <rightfold> masaeedu[m]: the full phrase is "a monad in X is just a monoid in the category of endofunctors of X, with product × replaced by composition of endofunctors and unit set by the identity endofunctor."
10:46:07 * hackage genvalidity-hspec-aeson 0.1.0.1, genvalidity 0.4.0.2, validity-path 0.2.0.2, validity 0.4.0.2, genvalidity-path 0.2.0.2 (Norfair): https://qbin.io/rr8rya712
10:46:08 <nshepperd> perhaps the aeson 'Parser' type should really be called 'Parsed'
10:46:50 <MarcelineVQ> crucify_me: it's difficult to tell which part is confusing you from that description.  you understand that reverrse [1,2,3] is equivalent to (([] ++ [3]) ++ [2]) ++ [1]  but what part are you having trouble with specifically?
10:47:15 <masaeedu[m]> rightfold: Ok, that's useful. So the `X` in `of X` is just the category of types
10:47:20 <masaeedu[m]> we're talking about functors which take types to other types
10:47:30 <masaeedu[m]> like `[]` takes `String` to `[String]`
10:48:05 <masaeedu[m]> And which take corresponding functions on those types to lifted functions (via fmap)
10:48:21 <rightfold> So monoidal operation is A × A -> A
10:48:48 <masaeedu[m]> But if you have a category in which the objects are functors (of types to types), the morphisms in that category must be natural transformations
10:48:59 <masaeedu[m]> no?
10:49:02 <rightfold> Monad is join : A ∘ A ~> A (i.e. join :: A (A a) -> A a)
10:49:33 <masaeedu[m]> But this is what I don't understand
10:49:34 <rightfold> join is a natural transformation from A ∘ A to A
10:49:35 <masaeedu[m]> why are you allowed to change the `A a` into `a`
10:49:37 <masaeedu[m]> in the nested type
10:49:57 <rightfold> Note how any function "f : forall a. F a -> G a" is a natural transformation in Haskell
10:49:58 <masaeedu[m]> hmm
10:50:08 <masaeedu[m]> right
10:50:17 <masaeedu[m]> But both `F` and `G` must be the same thing
10:50:21 <masaeedu[m]> in a monoid
10:50:31 <masaeedu[m]> i.e. a category comprised of a single endofunctor objet
10:50:36 <rightfold> So with join, F is A ∘ A, and G is A
10:50:55 <masaeedu[m]> `[]` and `[[]]` are distinct functors, so in a monoidal category you can't have them both
10:51:00 <rightfold> And with monoid, mappend :: a × a -> a
10:51:05 <rightfold> Hence "× replaced by ∘"
10:51:07 <masaeedu[m]> But doesn't that make it a non-monoid?
10:51:51 <crucify_me> my trouble is that (++) would be identity R and L so how does that flip the order of elements ? https://ptpb.pw/rIyC
10:51:57 <masaeedu[m]> If your category consists of both the functors `A ∘ A` and `A`, that's two objects right there
10:52:33 <rightfold> The category X may have multiple endofunctors
10:52:55 <rightfold> For example, Hask has both `[]` and `[] ∘ []`.
10:52:58 <masaeedu[m]> The category `X` is { Types, functions on types }
10:53:12 <masaeedu[m]> X isn't the category of functors
10:53:19 <nshepperd> aren't the elements of this monoid {I, A, A∘A, A∘A∘A, ...}
10:53:26 <MarcelineVQ> crucify_me: it's only identity if the order is unchanged.
10:53:27 <masaeedu[m]> Then you talk about the category of endofunctors on X
10:53:33 <rightfold> `Functor []` is an endofunctor on Hask; the one that takes types to list types
10:53:34 <MarcelineVQ> > [1] ++ [2,3]
10:53:36 <lambdabot>  [1,2,3]
10:53:39 <MarcelineVQ> > [2,3] ++ [1]
10:53:41 <lambdabot>  [2,3,1]
10:53:48 <rightfold> `Functor ([] ∘ [])` is an endofunctor on Hask; the one that takes types to list of list types
10:53:49 <MarcelineVQ>  reverrse (x:xs) = reverrse xs ++ [x]   assigns the head of the list to x, and the tail to xs.  ++ is being used on the tail and then the head.
10:54:07 <C_Everett_Koop> MarcelineVQ command line extra-lib-dirs doesn't work either. only thing that works seems to be to set environment variables
10:54:09 <crucify_me> MarcelineVQ, oh yeah, one sec thank you
10:54:09 <masaeedu[m]> Yup, following you so far
10:54:21 <masaeedu[m]> That's two different endofunctors
10:54:24 <C_Everett_Koop> OTOH, seems to work as intended on my linux-based CI
10:54:31 <masaeedu[m]> in a monoidal category of endofunctors, there's only room for one
10:54:40 <Welkin> endoplasmic reticulums!
10:54:40 <rightfold> masaeedu[m]: yeah, I'm pretty sure that's what was meant here
10:54:48 <rightfold> the "of" should be "on"
10:55:57 <MarcelineVQ> C_Everett_Koop: if it works on linux for you and not mac it's a good idea to make a stack issue about it
10:56:01 <rightfold> [] : Hask -> Hask; [] ∘ [] : Hask -> Hask; pure : Id ~> []; join : [] ∘ [] -> []
10:56:12 <nshepperd> where is 'monoidal category' coming from
10:56:32 <masaeedu[m]> "A monoid in the category of endofunctors"
10:56:39 <masaeedu[m]> Think about all endofunctors that go `Hask -> Hask`
10:57:16 <masaeedu[m]> [], IO, etc. etc.
10:57:22 <crucify_me> MarcelineVQ, yes I need to do things by hand. I try to visualize a "mechanism" working in the recursion, and it causes me much anguish ! thank you
10:57:23 <rightfold> Two of those are [] and [] ∘ []
10:57:27 <Welkin> where did the names "monad" and "monoid" come from? Why weren't they called "nonads" or "gonoids"?
10:57:32 <masaeedu[m]> The category of all such endofunctors has the functors as objects, and natural transformations as morphisms
10:57:33 <nshepperd> right, isn't a 'monoid in a category' a different thing? or are they related somehow
10:57:37 <masaeedu[m]> rightfold: Yes
10:58:13 <masaeedu[m]> nshepperd: Poorly educated on this subject, if there's a meaningful difference I'm unaware of it
10:58:18 <masaeedu[m]> maybe that's what I'm getting wrong
10:58:36 <crucify_me> monad is from mathematics I read somewhere
10:58:42 <crucify_me> duh
10:58:44 <masaeedu[m]> I was assuming a "monoid in a category" is just a category formed out of a subset of a category's objects and morphisms
10:58:45 <Welkin> yes, I know they come from math
10:58:53 <Welkin> I am asking about the origin of the names in math
10:58:55 <rightfold> So the monoid has two operators
10:59:01 <crucify_me> meaning, duh that I stated the obvious
10:59:01 <masaeedu[m]> Specifically a unitary subset
10:59:33 <masaeedu[m]> rightfold: Right, it has two morphisms
10:59:38 <rightfold> mu : [] × [] -> [] and eta : Id -> []
10:59:46 <masaeedu[m]> That lead from and to itself the single object in the category
10:59:52 <crucify_me> Welkin, I didn't mean for that to come out as demeaning. it was self-deprecating.
10:59:58 <masaeedu[m]> Well that's the part I can't wrap my head around
11:00:05 <crucify_me> since I don't know squat
11:00:07 <rightfold> You can have multiple monoids
11:00:10 * hackage html-tokenizer 0.6.2 - An "attoparsec"-based HTML tokenizer  https://hackage.haskell.org/package/html-tokenizer-0.6.2 (NikitaVolkov)
11:00:14 <rightfold> One of those uses the object []
11:00:17 <masaeedu[m]> in e.g. the original hask category, a monoid doesn't work like that
11:00:26 <rightfold> Objects in this category are endofunctors such as []
11:00:29 <masaeedu[m]> You can't go from one type to another in the morphims
11:00:35 <rightfold> No, but this isn't Hask, but htis is the endofucntors on Hask
11:00:54 <masaeedu[m]> Right, so you have to go from the endofunctor to the same endofunctor
11:01:04 <masaeedu[m]> And the morphisms need to be natural transformations
11:01:09 <rightfold> No, you don't have to
11:01:18 <masaeedu[m]> Which basically ends up restricting you to `[a] -> [a]`
11:01:29 <rightfold> You define the monoid for some object
11:01:31 <crucify_me> the problem with programming is one cannot visualize a program operating as a mechanic visualizes how a car works. how to unlearn that habit?
11:01:32 <rightfold> We pick the object []
11:01:38 <rightfold> From this follows that eta : [] x [] -> []
11:01:41 <rightfold> s/eta/mu/
11:02:06 <rightfold> A monoid is tripled (object, mu : object x object -> object, eta : id -> object)
11:02:09 <masaeedu[m]> How can you have a morphism from `[] x []`, when it isn't an object in the category?
11:02:28 <Welkin> huh, it looks like "monad" comes from western philosophy and predates category theory by hundreds of years
11:02:29 <rightfold> It is an object in this category if you "replace x by o" :)
11:02:37 <masaeedu[m]> The only object in a monoid category is a single endofunctor
11:02:39 <Welkin> https://en.wikipedia.org/wiki/Monadology
11:02:52 <rightfold> Which was mentioned in the original message
11:03:10 <Welkin> or https://en.wikipedia.org/wiki/Monad_(philosophy) for a better explanation
11:03:19 <rightfold> So, after replacing x with o, we get eta : [] o [] -> [], which is clearly a morphism between Hask endofunctors
11:03:51 <Welkin> the monad goes back to ancient greece D:
11:03:59 <masaeedu[m]> Ok, just wanted to say I appreciate your patience here
11:04:32 <masaeedu[m]> A natural transformation is `forall a. F a -> G a`, for two functors `F` and `G`, correct?
11:04:42 <nshepperd> masaeedu[m]: i don't think we're talking about a monoid category
11:04:52 <rightfold> In Haskell, that's always a natural transformation, yes.
11:04:59 <masaeedu[m]> Ok, cool
11:05:03 <rightfold> In general, there are more restrictions, but due to parametricity this always goes in Haskell.
11:05:04 <masaeedu[m]> So now let's substitute the symbols
11:05:15 <masaeedu[m]> nshepperd: hmm, that would explain some things
11:05:26 <masaeedu[m]> but it causes other mental problems
11:05:31 <masaeedu[m]> So `F` and `G` are both `[]`
11:05:31 <rightfold> Oh, this category isn't a monoid, no.
11:05:37 <rightfold> It has multiple objects. Monoids don't.
11:05:43 <masaeedu[m]> Right, ok
11:06:02 <rightfold> Don't confuse "single-object categories ~ monoids" with monoidal categories. :)
11:06:03 <masaeedu[m]> So this is what I've been wrestling with the whole time
11:06:05 <masaeedu[m]> in that, like
11:06:34 <masaeedu[m]> If you have a monoidal category with objects as functors and morphisms as natural transformations
11:06:38 <rightfold> A single-object category is a category with one object, and all morphisms are endomorphisms on that object. It is a monoid where mempty = identity morphism, and mappend = morphism composition.
11:06:40 * hackage wai-middleware-rollbar 0.5.0 - Middleware that communicates to Rollbar.  https://hackage.haskell.org/package/wai-middleware-rollbar-0.5.0 (joneshf)
11:06:41 <nshepperd> or monoids in categories, which is a different thing entirely
11:06:50 <masaeedu[m]> you can't accommodate a `[[]] -> []` natural transformation
11:07:24 <rightfold> A monoidal category always has more than one object.
11:07:36 <rightfold> It always has at least two; X and X^2
11:07:51 <Unode> I'm going around all this and getting stuck, I have "getReference rn refs = find (liftM2 (||) ((== rn) . refName) ((== rn) . refAlias)) refs" however refAlias returns a Maybe T.Text. How can I rewrite this? It's not possible to have the second part return a Bool (or is it?).
11:07:57 <rightfold> Otherwise you couldn't define mu : X^2 -> X
11:07:59 <masaeedu[m]> oh
11:08:04 <masaeedu[m]> OH
11:08:06 <nshepperd> 'C is a monoidal category' means that in addition to having objects and morphism, you have a product on objects (C, C) -> C
11:08:12 <masaeedu[m]> so a monoidal category is more like
11:08:24 <masaeedu[m]> a different mapping to the set concept of monoids
11:08:32 <masaeedu[m]> where the elements of the set actually start corresponding to category objects
11:08:37 <nshepperd> and a unit object I : C
11:08:41 <masaeedu[m]> rather than just category morphisms
11:08:43 <rightfold> The set itself corresponds to an object
11:08:46 <nshepperd> such that the product obeys the monoid laws
11:09:22 <masaeedu[m]> nshepperd: Right
11:09:44 <masaeedu[m]> Ok, so then obviously in that thing up there you have an identity functor
11:09:45 <masaeedu[m]> sitting around as an actual object
11:10:09 <nshepperd> eg. the category of endofunctors on Hask is a monoidal category, where the product is functor composition
11:10:13 <masaeedu[m]> and you're free to have a natural transformation from it to your functor of interest for your monad
11:10:18 <masaeedu[m]> 's `return`
11:11:05 <nshepperd> (F × G) -> Compose F G
11:11:16 <masaeedu[m]> right
11:11:19 <masaeedu[m]> ok, this is much clearer
11:11:27 <masaeedu[m]> I was just laboring under the wrong mapping
11:11:32 <masaeedu[m]> Thanks very much
11:12:40 <masaeedu[m]> I was watching Bartosz's excellent video series, and he talks about one mapping, where a monoidal set corresponds to a single element category, and the id morphism is the unit element, morphism composition is the product, etc.
11:12:51 <masaeedu[m]> and then I tried to misapply it all here
11:13:42 <nshepperd> So I guess 'object E is a monoid in a category C' means that C is monoidal, and that there are morphisms 'E × E -> E' and 'I -> E' such that... how does one write the monoid laws in this situation?
11:13:58 <rightfold> My favorite newtype Endo c a = Endo (c a a); instance Category c => Monoid (Endo c a) where { mempty = Endo id; mappend (Endo a) (Endo b) = Endo (a . b) } :D
11:14:37 <rightfold> nshepperd: same as in algebra but with "up to isomorphism"
11:14:57 <masaeedu[m]> nshepperd: Well the right and left composition of the identity functor with your functor of interest will leave both the types and the functions between them alone
11:15:00 <masaeedu[m]> so that's two down
11:15:20 <nshepperd> I've only ever seen the laws in algebra writing in pointful form
11:15:46 <nshepperd> but I suppose you mean, write them in pointfree notation then interpret . as morphism composition
11:15:52 <rightfold> ... such that × is associative up to isomorphism and I is the left and right identity of × up to isomorphism.
11:16:40 <nshepperd> rightfold: those are the laws of a monoidal category
11:17:00 <nshepperd> no, i'm talking about the laws for the two natural transformations. you called them eta and mu
11:17:05 <rightfold> Oh.
11:17:19 <rightfold> Eh, × should be mu, and I should be eta
11:17:55 <nshepperd> I have a morphism called mu :: E × E -> E
11:18:01 <nshepperd> and one called eta :: I -> E
11:18:21 <rightfold> Yes, mu must be associative. So mu ([], ([], [])) = mu (([], []), [])
11:18:43 <nshepperd> E is an object
11:19:08 <nshepperd> (this is all happening in the monoidal category C, whose product is ×)
11:19:13 <masaeedu[m]> nshepperd: I guess it depends on what functor composition means
11:19:37 <rightfold> And mu (I, a) = mu (a, I) = a
11:19:47 <nshepperd> rightfold: no
11:19:56 <rightfold> :(
11:20:17 <nshepperd> I and E are abstract objects. you can't look inside them or talk about elements
11:20:41 <nshepperd> you're giving me the laws for a monoidal category again :p
11:20:42 <rightfold> Not doing that
11:22:08 <masaeedu[m]> But you can have a functor on this category itself
11:22:26 <masaeedu[m]> Specifically a functor that takes two elements and maps to some other thing in the same category
11:23:11 <masaeedu[m]> It's like a bifunctor on a category of endofunctors on Hask (for the original monad use case)
11:24:59 <masaeedu[m]> And the bifunctor needs to be defined so it carries the pair `I, O` or `O, I` to O (where `I` is the identity object in the category and `O` is any other object in the category)
11:27:00 <nshepperd> hm. mu . eta × id_E = snd
11:27:52 <nshepperd> and mu . (id_E × eta) = fst
11:28:43 <nshepperd> express something like the usual requirement that (x `mu` 1) = x and (1 `mu` x) = x
11:29:26 <crucify_me> Welkin, hi , you copy that? 
11:30:19 <Welkin> crucify_me: yes
11:31:03 <crucify_me> thanks
11:31:08 <nshepperd> assumes there are special morphisms fst : A × I -> A and snd : I × A -> A
11:33:18 <nshepperd> mu . (id_E × mu) = mu . (mu × id_E) . assoc
11:33:32 <nshepperd> for the associativity of mu
11:33:55 <ph88> if typeclass functions are not used will ghc optimize away everything related to that typeclass?
11:34:48 <masaeedu[m]> nshepperd: Not quite getting what id_E × mu means
11:35:03 <masaeedu[m]> isn't `id_E` an object, and `mu` a natural transformation?
11:36:38 <nshepperd> I'm trying to do this in a general monoidal category 
11:36:49 <masaeedu[m]> Right
11:36:50 <nshepperd> so id_E is a morphism (the identity on E) and mu is a morphism
11:37:01 <nshepperd> id_E : E -> E
11:37:06 <nshepperd> mu : E × E -> E
11:37:09 <qqwy> ph88: I believe it does
11:37:24 <rightfold> What does ghc-nopie mean?
11:37:37 <qqwy> ph88 it will also inline all functions of a typeclass if they are only used by one instance.
11:37:42 <qqwy> (i.e. skip the typeclass-checing)
11:37:42 <nshepperd> id_E × mu is supposed to be a morphism (E × (E × E)) -> E × E
11:37:44 <qqwy> checking*
11:37:48 <qqwy> instance-checking*
11:37:49 <qqwy> there we go :-)
11:38:01 <masaeedu[m]> But even in a general monoidal category, wouldn't identity still be an object?
11:38:04 <nshepperd> composing the morphisms "next to each other". like (***) in haskell
11:38:12 <masaeedu[m]> Unless we're now talking about monoidal categories as single object categories
11:38:20 <masaeedu[m]> With the operators as morphisms
11:38:51 <nshepperd> masaeedu[m]: I"m talking about the identity morphism
11:39:03 <nshepperd> you know, the identity of morphism composition
11:39:08 <nshepperd> there's one for every object
11:39:10 <masaeedu[m]> yeah
11:39:14 <masaeedu[m]> right
11:39:39 <nshepperd> no, i'm not talking about single object categories
11:40:19 <masaeedu[m]> Ok, so you're kind of abstracting over "for any object `E` in the category"
11:40:25 <masaeedu[m]> dadada
11:40:27 <dminuoso> Terminology question: `f a`, would you ever call "a" an argument? Or do you stricly say "f is applied to value `a` (just a value, not an argument) ?
11:40:46 <dminuoso> Having real problems with the word "argument" for reasons I cant quite articulate yet.
11:41:17 <nshepperd> for any object E, in the category, it forms a monoid if there are morphisms eta and mu such that blah blah blah
11:42:01 <koz_> dminuoso: Is 'f' a function or a higher-kinded type?
11:42:04 <MarcelineVQ> dminuoso: sure peole use argument or parameter to refer to a when it's convenient to
11:42:08 <ph88> good to know qqwy 
11:42:10 <masaeedu[m]> ok, cool
11:42:11 <dminuoso> koz_, a function
11:42:12 <masaeedu[m]> i'm beginning to understand
11:42:19 <masaeedu[m]> so eta doesn't necessarily have to be id
11:42:22 <ph88> does ghc do cross module optimizations ?
11:42:28 <dminuoso> koz_, but I'd be happy to explore this on higher kinded types as well.
11:42:43 <rightfold> f wouldn't necessarily be a higher-kinded type
11:42:48 <rightfold> it'd be a type constructor
11:42:55 <rightfold> you could pass it as an argument to some higher-kinded types
11:42:57 <nshepperd> right
11:43:10 <ph88> if i put some library in my cabal file does the entire library end up in the binary or just the bits i'm using ?
11:43:12 <koz_> The reason I ask is because I have no problem with referring to a 'type argument' in such a case.
11:43:12 <rightfold> for example: Cofree f
11:43:14 <dminuoso> The reason I have problems with the word "argument" is that it feels so imperative.
11:43:23 <rightfold> Why would it?
11:43:30 <koz_> dminuoso: Then use 'parameter'?
11:43:31 <rightfold> You have a function. You give it an argument. It returns a result.
11:43:38 <MarcelineVQ> because imperative programming is always causing arguments
11:43:38 <dminuoso> koz_, thats wrong in every way.
11:43:39 <nshepperd> morphisms eta : I -> E and mu : E × E -> E. where I is the identity of the category product
11:43:59 <masaeedu[m]> Ok, that's new to me. I guess you could check your formulation using the degenerate case
11:44:02 <dminuoso> koz_, parameter is what you call the variable the argument gets substituted for in the abstraction
11:44:16 <masaeedu[m]> where in a single element category your eta should become id
11:44:35 <koz_> dminuoso: Yeah, point taken.
11:44:57 <rightfold> It really doesn't matter.
11:45:01 <nshepperd> masaeedu[m]: I guess
11:45:13 <nshepperd>  a monoid in a single object category doesn't sound like much fun
11:45:52 <masaeedu[m]> I mean most of the monoids I'd seen up to now were just that
11:46:21 <nshepperd> well. a single object category *is* a monoid
11:46:32 <nshepperd> but it's a monoid in the category of sets
11:46:48 <nshepperd> which is very much not a single object category
11:47:10 * hackage c2hs 0.28.3 - C->Haskell FFI tool that gives some cross-language type safety  https://hackage.haskell.org/package/c2hs-0.28.3 (deech)
11:47:37 <masaeedu[m]> hmm
11:49:43 <masaeedu[m]> So sets are the monoidal category here?
11:49:52 <rightfold> Aw man, I so want GHC 8.2 so I can use deriving strategies everywhere.
11:49:58 <nshepperd> a single object category satisfies the 'normal' algebra definition of a monoid: a set of elements S (the morphisms) and a function (·) : S × S -> S that is associative and has in identity in S
11:50:11 <masaeedu[m]> that the single object category is a monoid on?
11:50:19 <nshepperd> masaeedu[m]: yeah
11:50:51 <nshepperd> see the key words in the algebra definition: a *set* S, and a *function* (·)
11:51:11 <nshepperd> sets and functions are the objects and morphisms of the category of sets, respectively
11:51:13 <masaeedu[m]> Right, so the hom set is the set
11:51:24 <masaeedu[m]> and composition is the function
11:51:36 <masaeedu[m]> and the id morphism is the unit element in the hom set
11:51:50 <nshepperd> yep
11:52:04 <masaeedu[m]> ok, cool
11:52:06 <masaeedu[m]> thanks
11:52:10 <masaeedu[m]> it's slippery, this stuff
11:55:31 <ertes> dminuoso: let me make you uncomfortable:  a function is an object that you can call, giving it an argument, and it returns a result
11:57:48 <Welkin> a function is a subroutine that you jump to in the execution of your code, and may or may not have parameters that you pushed onto your stack for it to use in calculating a result
11:57:49 <rightfold> A function is an object that has exactly one method.
11:58:16 <ertes> i think my description didn't actually break abstraction boundaries =)
11:58:21 <ertes> it's just uncomfortable wording
11:59:01 <masaeedu[m]> A function is a coroutine that will call you back after the first date
11:59:04 <rightfold> Welkin: Wait till you see the optimization called "registers" that have been all the rage since the eighties. I believe they're a sort of high-speed global mutable variables.
11:59:43 <Welkin> rightfold: registers are older than call stacks
11:59:45 <ertes> … and then ever again
11:59:48 <ertes> *never
12:00:06 <ertes> if you want your function to call you back, you have to keep calling it
12:00:13 <dminuoso> ertes, so an "argument" is just the role of an expression in beta reduction (if this makes any sense) ?
12:00:31 <ertes> dminuoso: i'm just joking
12:01:31 <ertes> a function is a value of type (a -> b) for some 'a' and 'b'
12:02:42 <ertes> but i don't really understand your issue with "argument"
12:05:11 <dminuoso> ertes, I think it's okay. May have found the clarity I was looking for in lambda calculus actually.
12:26:48 * hackage servant-ruby 0.4.0.0 - Generate a Ruby client from a Servant API with Net::HTTP.  https://hackage.haskell.org/package/servant-ruby-0.4.0.0 (joneshf)
12:54:12 <heath> http://mishadoff.com/blog/clojure-design-patterns/
13:06:17 <dogbitsman> :t (1+1)
13:06:19 <lambdabot> Num a => a
13:07:04 <dogbitsman> :t fmap fmap fmap
13:07:05 <lambdabot> (Functor f2, Functor f1) => (a -> b) -> f1 (f2 a) -> f1 (f2 b)
13:07:08 <crucify_me> foldr and foldl are convoluted. I guess they are used often ?
13:10:13 <johnw> crucify_me: convoluted?
13:10:23 <johnw> they are used extremely often
13:11:17 <johnw> they represent an induction principle for lists: a value for nil, and a function called for every cons, recursively, this might explain the types better
13:12:11 <crucify_me> johnw induction principle ?
13:12:32 <crucify_me> foldl is making my head spin. I understand foldr well enough
13:12:50 <johnw> foldr is more fundamental, in the sense that foldl can be implemented in terms of it
13:13:37 <crucify_me> johnw thanks one moment I'd like to pastebin something if you have time
13:13:40 * hackage concurrent-output 1.10.1 - Ungarble output from several threads or commands  https://hackage.haskell.org/package/concurrent-output-1.10.1 (JoeyHess)
13:13:45 <johnw> by "induction principle" I mean a recursion strategy in this case: a function whose job it is to produce a result by visiting all its members
13:13:50 <johnw> sure, paste away
13:20:09 <crucify_me> johnw this is psuedo code for foldr foldl, that shows their generalized behavior, from textbook: 
13:20:13 <crucify_me> https://ptpb.pw/Qok0
13:21:43 <crucify_me> can you read that ?  
13:22:13 <johnw> horrible notation taken out of context, but yes
13:22:23 <johnw> it shows how they differ in association
13:22:31 <johnw> i'd find a better explanation ;)
13:23:05 <crucify_me> well, its a (good) textbook, though I studied these in another book and had trouble then with it
13:23:21 <crucify_me> as well
13:23:40 <johnw> @src foldl
13:23:41 <lambdabot> foldl f z []     = z
13:23:41 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
13:23:44 <johnw> @src foldr
13:23:44 <lambdabot> foldr f z []     = z
13:23:44 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
13:23:56 <johnw> if you read carefully, you can see the identity between those, and your textbook
13:24:23 <johnw> the call to 'f' is being hidden in the # symbol
13:24:33 <johnw> and your textbook's 'f' is the name of the foldl or foldr
13:24:37 <crucify_me> thanks yeah I have the actual definitions. I'm confused by it all
13:25:18 <johnw> keep banging your head on it, the confusion should evaporate soon
13:25:23 <johnw> the clearest definition I know is this:
13:25:37 <rightfold> foldl is foreach with accumulator. foldr f z replaces (:) by f and [] by z.
13:25:54 <crucify_me> foldr maps the empty set to value, foldl maps the accumulator and the empty to value, right ?
13:26:04 <johnw> foldr f z replaces nil with z, and cons with a call to f
13:26:05 <crucify_me> empty *set
13:26:12 <crucify_me> sorry empty list
13:26:18 <johnw> so that [a, b, c] becomes f a (f b (f c z))
13:26:27 <johnw> thus, foldr (:) nil xs = xs
13:28:09 <crucify_me> ok thanks, foldl is the issue now.
13:29:59 <johnw> [a, b, c] becomes f (f (f z a) b) c
13:31:14 <johnw> note that in both cases, the 'a' value is "visited" first
13:34:38 <crucify_me> johnw working thanks
13:39:45 * hackage rob 0.0.1 - Simple projects generator  https://hackage.haskell.org/package/rob-0.0.1 (gianlucaguarini)
13:42:18 <crucify_me> also thanks rightfold 
13:55:09 <ph88> guys, i've read this SO answer https://stackoverflow.com/a/32476604/1833322 but still i'm like o_O that sequence gives a cartesian product of list of lists  .. can someone comment ?
13:57:17 <MarcelineVQ> what are you expecting to see vs what you are seeing?
14:00:15 <MarcelineVQ> Are you after an explanation of sequence on lists that's differenant the the one given there?
14:01:36 <ph88> it feels like sequence is like a double list comprehension or something
14:01:50 <ph88> i was trying to implement it as list comprehension before and i got stuck
14:03:23 <ph88> well maybe i can just remember that sequence just does that and not think about it too hard
14:03:39 <ph88> but then i don't really understand it's use (also in relation to other monads)
14:09:01 <ph88> by the way .. is there a function that picks the highest number from a list and puts it in Just or Nothing when the list is empty? I know it's trivial to write .. but maybe there is just a build in function for that
14:09:38 <MarcelineVQ> safeMaximum? probably not in base, not sure
14:15:08 <ekr> hello, i've been having a bit of trouble trying to understand a small piece of code (probably because it's well past midnight, but anyway): http://lpaste.net/360254 . Could anyone give me some hints? namely the "((<$>) f <$> a)" bit .
14:16:16 <hpc> first, replace (<$>) with fmap
14:16:29 <hpc> so that becomes (fmap f) <$> a
14:16:36 <hpc> or fmap (fmap f) a
14:16:38 <ekr> yes, that's clear, but is it using the applicative instance of functions?
14:16:54 <hpc> no
14:17:00 <erisco> a crazy person wrote that
14:17:03 <ekr> <$> is infixl 4, so i assume the (<$>) has the highest priority
14:17:14 <ekr> i mean function application is applied first
14:17:18 <hpc> it's using whatever the structure of a is
14:17:28 <hpc> so if a :: f (g something)
14:17:35 <hpc> the two fmaps are for Functor f, and Functor g
14:18:34 <james4> I can't seem to understand why this code won't compile: http://lpaste.net/360253.  Specifically, I don't understand why the compiler can't tell that mapping a function of type (Double -> Matrix Double) to a list of doubles ([Double]) will return a list of double matrices ([Matrix Double]).  What am I doing wrong here?
14:19:42 <erisco> well based on the error it does seem to understand that, but it is expecting [Double]
14:20:07 <erisco> which means the place you used it requires [Double]
14:20:55 <james4> Hmmmm
14:22:08 <erisco> sum $ zipWith (*) wts (map integrand xi)
14:22:20 <ph88> why does ghci have trouble infering the type here?  https://bpaste.net/show/bda31bdc0a69
14:22:21 <erisco> this looks to me like it produces a Double
14:22:43 <erisco> what else is a sum supposed to be here?
14:23:10 <james4> Yep.  I see the issue.
14:23:31 <MarcelineVQ> ph88: did you mean  sequence . map cardValues  ?
14:23:50 <ph88> no ?
14:23:53 <james4> Thanks, erisco.
14:23:57 <erisco> it didn't have trouble inferring the type… you have a constraint error
14:24:20 <erisco> james4, np
14:24:31 <ph88> MarcelineVQ, i mean the same thing as on line 1 ... but then not supplying the last argument onePlayer .. it should infer some kind of function signature
14:24:38 <MarcelineVQ> ph88: then you're missing an argument to make that type-correct, if you didn't mean . then $ doesn't do what you think it does
14:25:03 <erisco> hint: stop using $
14:25:13 <MarcelineVQ> it's inferring things just fine, it's just inferring the correct things :(
14:25:13 <ph88> well  :t sequence (map cardValues)  has the same problem
14:25:29 <erisco> :t sequence
14:25:31 <lambdabot> (Monad m, Traversable t) => t (m a) -> m (t a)
14:25:45 <james4> Agreed, erisco. 
14:25:46 <erisco> I am not sure what you are expecting here
14:25:57 <erisco> :t map
14:25:59 <lambdabot> (a -> b) -> [a] -> [b]
14:26:15 <erisco> so you have to be saying  [a] -> [b] ~ t (m a)
14:26:45 <ph88> hhmmzzz
14:26:51 <erisco> so  t = (->) [a]  m = []
14:27:31 <erisco> then by the constraint we have to find a Traversable for  (->) [a]
14:27:36 <erisco> where  a  happens to be Card2
14:30:38 <ph88> i fixed it now by doing  (\x -> sequence (map cardValues) x)
14:31:06 <ph88> how do i get a maximum of [Maybe Int] ? 
14:31:18 <ph88> [Maybe Int] -> Maybe Int
14:31:24 <erisco> that is equivalent to  sequence (map cardValues)
14:32:40 <erisco> what have you tried to find the maximum?
14:33:53 <ph88> https://bpaste.net/show/8de7c59eb48b
14:34:10 <ph88> i also thought this would be the same
14:34:15 <erisco> you have said two different things
14:34:26 <ph88> missing arguments filled up from the right
14:34:32 <Eduard_Munteanu> > maximum [Just 3, Nothing, Just 1]
14:34:34 <lambdabot>  Just 3
14:34:46 <ph88> oh maximum already does that o_O
14:34:47 <ph88> ok
14:35:13 <erisco> (\x -> sequence $ map cardValues x) = (\x -> sequence (map cardValues x)) = sequence . map cardValues
14:35:45 <Eduard_Munteanu> > minimum [Just 3, Nothing, Just 1]
14:35:48 <lambdabot>  Nothing
14:35:55 <Eduard_Munteanu> Beware ^
14:36:02 <MarcelineVQ> Eduard_Munteanu: omy
14:38:36 <Eduard_Munteanu> > maximum ([] :: [Maybe Int])  -- this is another caveat
14:38:38 <lambdabot>  *Exception: Prelude.maximum: empty list
14:38:46 <erisco> ph88, there is no such thing as "missing arguments filled up from the right"
14:39:14 <erisco> unless you use my stupendous Control.DotDotDot package. highly recommended for all acme-strength enterprise apps
14:39:59 <Eduard_Munteanu> erisco, heh, what package is that in?
14:40:08 <erisco> probably control-dotdotdot
14:41:40 <ph88> acme best company ever
14:45:26 <MarcelineVQ> :t fmap getMax . getConst . traverse (Const . Just . Max) -- ehehe
14:45:28 <lambdabot> (Bounded b, Ord b, Traversable t) => t b -> Maybe b
14:47:46 <erisco> > let f = fmap maximum . Data.List.NonEmpty.nonEmpty . catMaybes in (f [Just 3, Nothing, Just 1], f [Nothing], f [])
14:47:48 <lambdabot>  error:
14:47:48 <lambdabot>      Not in scope: ‘Data.List.NonEmpty.nonEmpty’
14:47:48 <lambdabot>      No module named ‘Data.List.NonEmpty’ is imported.
14:48:25 <erisco> @import qualified Data.List.NonEmpty as NonEmpty
14:48:25 <lambdabot> Unknown command, try @list
14:48:33 * erisco *shrugs*
14:49:06 <MarcelineVQ> tame the beast erisco
14:49:20 <MarcelineVQ> @let import qualified Data.List.NonEmpty as NonEmpty
14:49:21 <lambdabot>  Defined.
14:49:25 <erisco> weird syntax
14:49:28 <erisco> > let f = fmap maximum . Data.List.NonEmpty.nonEmpty . catMaybes in (f [Just 3, Nothing, Just 1], f [Nothing], f [])
14:49:30 <lambdabot>  error:
14:49:30 <lambdabot>      Not in scope: ‘Data.List.NonEmpty.nonEmpty’
14:49:30 <lambdabot>      No module named ‘Data.List.NonEmpty’ is imported.
14:49:34 <MarcelineVQ> muahah
14:49:41 <erisco> I… don't get it
14:49:49 <erisco> > let f = fmap maximum . NonEmpty.nonEmpty . catMaybes in (f [Just 3, Nothing, Just 1], f [Nothing], f [])
14:49:51 <lambdabot>  (Just 3,Nothing,Nothing)
14:50:14 <erisco> I thought it would still allow the fully qualified name but I guess not… never tried that before actually
14:51:32 <MarcelineVQ> :t Data.List.NonEmpty.nonEmpty
14:51:33 <lambdabot> [a] -> Maybe (NonEmpty.NonEmpty a)
14:52:00 <erisco> lambdabot can query types without being able to evaluate the term
14:54:36 <MarcelineVQ> but can it tell why kids love the taste of cinnamon toast crunch
14:57:05 <erisco> that was proven undecidable as a corollary to how many licks it takes to get to the centre of a tootsie pop
14:57:15 <MarcelineVQ> it's 3 though
14:57:22 <MarcelineVQ> This has been tested
14:57:34 <MarcelineVQ> There's studies
14:59:39 <erisco> I am skeptical about their methodology though. Too much beak.
15:05:29 <raynold> ahh it's a wonderful day
15:05:56 <erisco> zip a dee do da
15:09:10 * hackage fingertree 0.1.3.0 - Generic finger-tree structure, with example instances  https://hackage.haskell.org/package/fingertree-0.1.3.0 (RossPaterson)
15:15:17 <Gurkenglas> Could a deriving clause on a function definition f produce hlint hint rules of form "use f"?
15:16:51 <Gurkenglas> (To the point where one could slap deriving clauses on, say, most of Control.Monad.Loops)
15:18:37 <Gurkenglas> A sort of uninlining pragma x)
15:20:13 * hackage monad-journal 0.8.1 - Pure logger typeclass and monad transformer  https://hackage.haskell.org/package/monad-journal-0.8.1 (DimitriSabadie)
15:24:50 <Zemyla> If m is Distributive and Applicative, then for all ma :: m a, mb :: m b, f :: a -> b -> c, liftA2 f ma mb = liftA2 (flip f) mb ma, right?
15:25:25 <Wizek> Are there some among us who have had experience with AngularJS, or later Angular iterations?
15:25:35 <Gurkenglas> Zemyla, that's called commutative btw
15:25:40 <erisco> not familiar with distributive
15:27:25 <Gurkenglas> And yes, since Distributive implies isomorphism to ((->) x) for some x
15:27:56 <erisco> not true for just Applicative
15:28:47 <Zemyla> And then the Monad instance can be defined as m >>= f = distribute f <*> m.
15:29:09 <Gurkenglas> yep
15:31:14 <Gurkenglas> Zemyla, http://lpaste.net/312022691085287424
15:31:32 <Gurkenglas> I think ekmett said somewhere that you can't do it without the hack, lemme search
15:33:40 <Zemyla> Gurkenglas: You can do it without the hack if you have evidence that f has an Adjunction with another Functor g.
15:34:37 <Zemyla> liftA2 f x y = leftAdjunct (\k -> f (rightAdjunct fst k) (rightAdjunct snd k)) (x, y)
15:35:27 <Zemyla> where class (Functor f, Distributive u) => Adjunction f u where { leftAdjunct :: (f a -> b) -> a -> u b; rightAdjunct :: (a -> u b) -> f a -> b }
15:35:44 <Gurkenglas> Looks like this is the conversation I was thinking of http://irclogger.com/.haskell/2017-05-09#1494366224
15:36:47 <Gurkenglas> Wait, you can't? Um. Should we call him?
15:37:33 <Gurkenglas> (that last "you can't" referring to defining the monad instance using only Distributive)
15:38:40 * hackage firefly 0.1.0.1 - A simple HTTP server framework  https://hackage.haskell.org/package/firefly-0.1.0.1 (ChrisPenner)
15:40:06 <Zemyla> Well, no, you can't, and the current Adjunction library requires a Representable instance on top of the Distributive one (which makes defining liftA2 trivial), but if you had an Adjunction class that didn't require Representable, then you could prove that u is an Applicative.
15:40:54 <Zemyla> But then again, an Adjunction between f and u means that u is isomorphic to (->) (f ()).
15:41:08 <Gurkenglas> But we just did! The lpaste gives the Applicative instance, your oneliner gives the Monad instance.
15:45:48 <Zemyla> And like I said, there really needs to be a class Traversable f => Codistributive f where { cocollect :: Functor g => (a -> g b) -> f a -> g (f b); codistribute :: Functor g => f (g a) -> g (f a); codistribute = cocollect id }
15:46:14 <Zemyla> And it needs to be a prerequisite for Adjunction.
15:46:44 <Gurkenglas> Why aren't you panicking?
15:46:51 <Zemyla> Because you can define it if you already have the Adjunction as cocollect f = rightAdjunct $ collect unit . f
15:47:14 <Zemyla> Why would I be panicking? Did I miss something?
15:47:41 <Gurkenglas> http://lpaste.net/312022691085287424 gives Distributive -> Applicative, m >>= f = distribute f <*> m gives Monad, http://irclogger.com/.haskell/2017-05-09#1494366419 says that's impossible.
15:49:38 <MarcelineVQ> "<edwardk> it cant be for cultural reasons "
15:50:41 <Gurkenglas> above that: "how does one construct it from distribute" "you cant"
15:51:14 <Gurkenglas> I remember being linked a proof or something?
16:00:12 * hackage gtk2hs-buildtools 0.13.3.1 - Tools to build the Gtk2Hs suite of User Interface libraries.  https://hackage.haskell.org/package/gtk2hs-buildtools-0.13.3.1 (HamishMackenzie)
16:00:26 <Zemyla> Gurkenglas: I'm saying that there should be, for every Distributive functor u, a matching Codistributive functor f, and vice versa, even if you can't express that relationship in Haskell 98.
16:01:44 <joncfoo> anyone care to review some introductory blog posts about Spock?
16:02:57 <Zemyla> And given that, if you have both you can easily derive the Applicative instance for u, and where one exists the other must as well somewhere, Applicative should be a superclass of Distributive.
16:03:59 <Gurkenglas> and i just took something that i thought can't be expressed in haskell 98 and apparently went of and expressed it
16:04:06 <Gurkenglas> *off
16:07:39 <zachk> in GHC , if all the threads die or are killed that have an open socket/file descriptor, will the socket/file descriptor be closed?
16:07:56 <Zemyla> Gurkenglas: You expressed it, but you didn't prove it, because you used a non-total function.
16:12:57 <geekosaur> zachk, per note at end of https://downloads.haskell.org/~ghc/latest/docs/html/libraries/base-4.10.0.0/System-IO.html#t:Handle it will
16:13:11 <geekosaur> but there is no guarantee as to how quickly that will happen after it becomes unreferenced
16:20:40 * hackage vectortiles 1.2.0.6 - GIS Vector Tiles, as defined by Mapbox.  https://hackage.haskell.org/package/vectortiles-1.2.0.6 (fosskers)
16:21:38 <zachk> thank you geekosaur, seems to be taking awhile, guess I will need to close the socket
16:27:17 * hackage pipes-random 1.0.0.4 - Producers for handling randomness.  https://hackage.haskell.org/package/pipes-random-1.0.0.4 (fosskers)
16:35:47 * hackage kanji 3.0.2 - Perform 漢字検定 (Japan Kanji Aptitude Test) level analysis on Japanese Kanji.  https://hackage.haskell.org/package/kanji-3.0.2 (fosskers)
16:37:15 * infinisil checks out kanji
17:12:57 <infinisil> What prevents functions from being serialized?
17:13:21 <infinisil> I mean in theory it should be possible to use the source code for its serialization, right?
17:14:53 <Zemyla> infinisil: That's the point of Cloud Haskell.
17:18:35 <lyxia> infinisil: can you do it without breaking referential transparency
17:20:45 <infinisil> lyxia: Why would it break it?
17:21:38 <infinisil> Zemyla: Does cloud haskell give you some type that encodes a function which you can use? Or does it actually encode any haskell function?
17:22:03 <geekosaur> it actually serializes a token representing a funciton that has to already exist in both processes
17:23:02 <infinisil> oh i see, so not quiet function serialization
17:23:45 <Zemyla> geekosaur: Or also a piece of serializable data.
17:24:05 <geekosaur> the specific quiestion was about serializing functions, not data
17:24:53 <C_Everett_Koop> what's the current thinking around dealing with C++ exceptions?
17:25:40 <Zemyla> C_Everett_Koop: Write an extern "C" wrapper that catches them and turns them into error codes.
17:27:08 <C_Everett_Koop> Zemyla what if there are thousands of functions being wrapped? one for every function or is there a pattern to write
17:27:20 <C_Everett_Koop> a master function-caller/exception-catcher?
17:30:11 * hackage posix-paths 0.2.1.3 - POSIX filepath/directory functionality  https://hackage.haskell.org/package/posix-paths-0.2.1.3 (NiklasHambuechen)
17:32:02 <lyxia> infinisil: by serializing functions as their code, you can distinguish different implementations of what should be the same function in Haskell.
17:34:04 <infinisil> lyxia: I don't see the problem, you don't need to compare functions like this ever
17:35:20 <infinisil> lyxia: referential transparency means that "[an expression] can be replaced with its corresponding value without changing the program's behavior", which is still true with through source code serialized functions
17:40:07 <eacameron> Hey folks, can someone recommend a library/tool for doing run-of-the-mill image resizing/re-encoding for thumbnails etc? This kind of thing is extremely common in PHP but it seems Haskell doesn't have a clear story for this?
17:41:43 <amf> eacameron: http://hackage.haskell.org/package/JuicyPixels-extra ?
17:43:47 <lyxia> infinisil: If id = fmap id, referential transparency implies that serialize id = serialize (fmap id), but serialize id = "id", serialize (fmap id) = "fmap id", contradiction.
17:45:36 <eacameron> amf: I considered JuicyPixels, but it seems very limited and unlikely as efficient as something like ImageMagick
17:47:49 <infinisil> lyxia: How is id = fmap id?
17:48:37 <infinisil> lyxia: And you replaced serialize id = serialize (fmap id) which is clearly not true, with something that clearly isn't true either, so referential transparency holds
17:49:12 <lyxia> infinisil: It's one of the functor laws, it holds pretty often.
17:49:51 <lyxia> https://hackage.haskell.org/package/base-4.10.0.0/docs/Data-Functor.html#t:Functor
17:49:56 <infinisil> Ah okay
17:50:12 <infinisil> that is true, but my second message still applies
17:51:06 <hololeap> that's weird... haddock still requires ghc-8.0.*?
17:52:35 <lyxia> infinisil: I don't understand the second part of your message. id = fmap id, so you can replace one with the other.
17:53:08 <hololeap> i thought 8.2.1 was considered stable?
18:00:08 <infinisil> lyxia: Definiton of referential transparency: "[an expression] can be replaced with its corresponding value without changing the program's behavior". If you want to show me a counter example you need a function that evaluates to something different if you replace some expressions of it with the value
18:00:40 * hackage servant-ruby 0.5.0.0 - Generate a Ruby client from a Servant API with Net::HTTP.  https://hackage.haskell.org/package/servant-ruby-0.5.0.0 (joneshf)
18:01:40 <infinisil> Oh
18:02:02 <lyxia> id and fmap id are two expressions with the same value
18:02:28 <infinisil> Sorry!
18:03:42 <infinisil> hmm
18:04:24 <infinisil> lyxia: But, and a big butt at that: Nobody said you could Eq functions
18:05:01 <infinisil> so id == fmap id doesn't even typecheck
18:05:07 <lyxia> I didn't say there is an Eq instance
18:06:32 <infinisil> lyxia: But in your counterexample you're relying on one, so it doesn't work
18:06:34 <lyxia> "=" should be taken as semantic equivalence, which is mathematical equality for a conventional denotation of Haskell functions.
18:06:53 <infinisil> lyxia: We're talking about haskell expressions though, not mathematical equivalence
18:07:09 <lyxia> Haskell expressions have a mathematical meaning.
18:07:32 <infinisil> yeah, but referential transparency is defined in terms of haskell expressions
18:09:53 <exio4> for all x. if id x and fmap id x type check, they are equal
18:09:57 <lyxia> Wikipedia's definition of referential transparency is quite informal...
18:10:40 <infinisil> exio4: Is that an expression?
18:11:12 <lyxia> and formalizing it fully for a given language is kind of tedious.
18:11:34 <infinisil> lyxia: Now you might say now that `2 == (1 + 1)` is obviously true, but "2" == "1 + 1" obviously isn't, but then I'd say that we won't serialize functions as strings directly, but rather with data Serialization = Serialization String and won't make Eq Serialization
18:12:46 * hackage wai-middleware-rollbar 0.6.0 - Middleware that communicates to Rollbar.  https://hackage.haskell.org/package/wai-middleware-rollbar-0.6.0 (joneshf)
18:12:47 <infinisil> I am not convinced at all, I'm pretty sure referential transparency is still guaranteed
18:12:57 <exio4> infinisil: I don't follow the proble, id and fmap id are equivalent expressions, because in any situation where you could use one - you could use the other (given the types match)
18:14:54 <infinisil> exio4: but you can't compare them, you can only compare the results of them, so id == fmap id is essentially f == g, which makes no sense whatsoever to haskell
18:15:57 <lyxia> I did write "id = fmap id" rather than "id == fmap id" consciously.
18:16:57 <exio4> infinisil: it is a way to define equality. iff ∀x. f x = g x then f and g are equal 
18:19:48 <infinisil> exio4: What my theorem is: If we serialize functions with their source code, referential transparency is still guaranteed
18:20:25 <exio4> infinisil: where does it say that? 
18:20:33 <exio4> (I haven't been here the whole conversation)
18:21:44 <jle`> even if `id` and `fmap id` were serialized differently, though, we could consider the underlying serialization method as a quotient type
18:22:08 <jle`> so they might be serialized as different bytes, but the actual bytes must not be observable
18:22:24 <jle`> this is impossible though because you gain access to the bytes
18:23:01 <infinisil> exio4: I came up with the idea of serializing function with their source code, and lyxia thought that referential transparency wasn't going to be guaranteed anymore (i think it still is)
18:23:06 <lyxia> Yes, infinisil proposed the bytes to be abstract.
18:23:44 <lyxia> I guess that works.
18:23:56 <jle`> but that wouldn't be a very useful serialization ?
18:24:07 <jle`> if you write it to disk, you can directly observe it
18:24:37 <lyxia> Okay, let's say that works on some level.
18:25:22 <jle`> it'd only work if you can never directly observe the bytes, or write it to disk, i suppose
18:25:40 <infinisil> jle`: What's the problem with observing the bytes? I don't get that part
18:25:57 <exio4> infinisil: serialize f wouldn't be equal to serialize g, even though they should be equivalent
18:26:53 <jle`> so actually i think this might be subject to false negatives depending on what compiler optimizations fire
18:27:11 <edwardk> managed to figure out a way to use a trick from the 'ad' package to get a nice way to work with ROBDDs
18:27:31 <jle`> same
18:27:32 <exio4> jle`: serialize f being different to serialize f if some optimizations only trigger in one call?
18:28:04 <jle`> yeah or if the program is re-compiled
18:28:16 <jle`> or even serialize f == serialize g being different depending on compiler optimizations
18:28:19 <infinisil> jle`: optimizers shouldn't modify program behaviour
18:28:23 <jle`> s/different/nondeterministic
18:28:29 <jle`> infinisil: i know, and so there's the problem
18:28:45 <exio4> infinisil: how are you going to implement that kind of serialization? 
18:29:05 <exio4> infinisil: the original AST of the function before optimizations? 
18:29:05 <jle`> ghc optimizes functions in a way to that preserves ref transp, and respects purity, etc., and making sure everything is behaviorally the same
18:29:29 <infinisil> exio4: something like that yeah
18:29:33 <jle`> but if you throw in function serialization, then that disables a huge swath of compiler optimizations
18:30:10 <infinisil> it would be implemented somewhere in GHC
18:30:36 <jle`> still doesn't stop it from making invalidating a lot of compiler optimizations
18:31:03 <lyxia> Explain the difference between = and ==.
18:32:30 <jle`> GHC makes assumptions that allows it to know what it doesn't have to care about, and so it can do a lot of optimizations.  with function serialization in the picture, then many of those optimizations are no longer legal
18:32:33 <infinisil> jle`: The deserialize function would compile the serialization on the running system (GHC runtime dependency) and run it somehow
18:32:35 <lyxia> infinisil said "f = g  implies  serialize f = serialize g" doesn't contradict referential transparency because you can't compare functions with ==.
18:32:36 <jle`> and can change program behavior
18:33:02 <jle`> infinisil: yeah but we aren't even talking about deserialization at this point
18:33:25 <infinisil> jle`: But you can have 1 version of the function optimized, and 1 version for the serialization
18:33:33 <jle`> if the only way to work with a serialized function was to deserialize it first, then it's fine
18:33:36 <jle`> that's the quotienting i was talking about
18:33:52 <jle`> but the problem is when you have access to the actual bytes
18:34:15 <jle`> then comparing the bytes of function serializations would be non-deterministic
18:35:08 <infinisil> well you don't have access to bytes
18:35:44 <jle`> i was just answering your previous question :)
18:35:50 <EvanR> serialize :: A -> Cereal
18:35:51 <jle`> you asked what the problem is with observing the bytes directly
18:36:01 <jle`> if you can't observe the bytes directly, then yeah, there isn't any problem
18:36:14 <infinisil> The serialization would be an interface something like `serialize :: a -> Serialization; deserialize :: Serialization -> Maybe a`
18:36:15 <jle`> but it also makes it a really useless serialization process
18:36:22 <jle`> what are you going to do with the Serialization ?
18:36:25 <EvanR> i thought serialize implied -> [Word8]
18:36:33 <jle`> write it to disk?  send it over a network connection?
18:36:38 <infinisil> jle`: Yes
18:36:45 <jle`> if you write it to disk, then you have access to the bytes
18:36:46 <texasmynsted> so maybe not the ideal place to ask, but anybody know of a gitit example site?  iirc http://gitit.net was shut down because of spam.
18:36:58 <jle`> if you send it over a network connection, then you have access to the bytes
18:37:25 <infinisil> jle`: Why would you use those bytes though?
18:37:30 <jle`> but i suppose IO is already non-deterministic
18:37:46 <EvanR> i think we need to expand network and disk as things which are allowed to NOT give access to bytes, or make it convenient to tell you when you are breaking an abstraction
18:38:20 <EvanR> there are bytes in the runtime too but we dont want to believe it
18:38:35 <EvanR> the runtime is magic and the disk is a bunch of bytes. but whats the difference
18:39:08 <jle`> infinisil: you might not have a reason to use them, but it does mean that your program can branch on bool's that are non-deterministic, and so behave differently depending on optimizations
18:39:20 <jle`> this would fall under the unsafeX category of things
18:39:46 <EvanR> everything is unsafe until you put the proper interface on it
18:39:47 <infinisil> jle`: There are no optimizations from source -> AST
18:39:57 <infinisil> and that's all the serialization does
18:40:02 <infinisil> or even use the source directly
18:40:36 <texasmynsted> hm  I suppose this works -->  https://hub.docker.com/r/marcelhuberfoo/pandoc-gitit/
18:40:44 <jle`> what about haskell assumptions we use every day, like "you should be able to replace 'fmap id' with 'id' in your code, and it should not change any observable behavior"
18:41:19 <infinisil> jle`: all you can do with a serialization is deserialize it
18:41:40 <jle`> that sounds pretty useless, unless you can write it to disk or send it over a connection or something
18:41:56 <infinisil> Yes that's what I'd do
18:42:13 <jle`> so if you can write it to disk or send it over a connection, you can cause behavior change if you use fmap id vs. id
18:42:23 <EvanR> source code isnt a serialization
18:42:30 <infinisil> ohh
18:42:35 <EvanR> its already serial.. no ize
18:42:51 <infinisil> I see now
18:43:04 <infinisil> thanks for the explanation jle` even though it took me a while to get
18:43:09 <jle`> when (loadedbytes == serialize id) launchMissiles
18:43:26 <jle`> no problem, although i do agree with you that it'd be useful as an unsafe interface
18:43:52 <infinisil> What you're saying is that if all you have is serialize and deserialize without access to the bytes, you can't even write it to disk or send it over the network
18:43:54 <jle`> but in practice i've found that serializing arbitrary functions really does more harm than good
18:44:07 <EvanR> you know whats interesting, ghc compact regions can be serialized and reconstituted in another computer
18:44:34 <jle`> infinisil: yes, but you *can* tell the user that accessing the bytes directly on the disk or network is undefined/unsafe behavior
18:44:41 <infinisil> true dat
18:46:34 <infinisil> I mean, we already serialize functions everyday anyways
18:46:46 <infinisil> writing a Main.hs is a serialization
18:46:52 <EvanR> :|
18:47:02 <infinisil> :P
18:47:09 <EvanR> is this an exercise in logos, pathos, or ethos
18:47:26 <jle`> compiling is already a nondeterministic IO process though
18:47:30 <jle`> especially with template haskell
18:47:42 <jle`> compiling the same binary twice is like SourceCode -> IO ByteString
18:47:58 <infinisil> haskell is non-deterministic ? :(
18:48:02 <jle`> and compiling the same source code two times in a row already gives you different ByteString
18:48:05 <EvanR> yes it is
18:48:05 <jle`> GHC is non-deterministic
18:48:09 <EvanR> even without template haskell
18:48:14 <EvanR> unfortunately
18:48:24 <infinisil> where's the non-determinism coming from?
18:48:33 <EvanR> yesterdays discussion
18:48:36 <infinisil> optimizations using randomness?
18:48:38 <jle`> but anyway, having to work around serializing arbitrary functions has lead me to write cleaner code in a lot of situations
18:49:01 <jle`> and overall "better" programs.  even if that's just anecdotal experience
18:49:05 <EvanR> the value of System.Info.os, the behavior of Int....
18:49:40 <infinisil> Ohh, I think i saw the System.Info.os thing, it gets evaluated at compile-time
18:49:40 <jle`> the value of love
18:50:06 <infinisil> EvanR: behaviour of Int?
18:50:12 <EvanR> {-# LANGUAGE CPP #-}
18:50:13 <EvanR> os = HOST_OS
18:51:00 <EvanR> its "evaluated" at compile time of the base library
18:51:50 <EvanR> infinisil: whether mod 2^32 does anything to an Int
18:52:21 <EvanR> guess that calculation is wrong...
18:52:36 <EvanR> anyway
18:53:06 <infinisil> Hmm, I mean shouldn't that all be solved by specifying a target system/arch, essentially crosscompiling?
18:53:52 <infinisil> which means that the compiler is essentially :: Source -> Target -> Binary
18:54:00 <EvanR> its non deterministic in the sense that given some haskell program, there is a list of possible results longer than 1
18:55:03 <EvanR> not in the sense of random
19:00:24 <infinisil> EvanR: jle`: This paper mentions 8.0.2 being deterministic: https://conf.researchr.org/event/icfp-2016/hiw-2016-papers-ghc-determinism
19:00:44 <infinisil> s/paper/abstract
19:00:58 <EvanR> that doesnt seem to be contradicting the above facts
19:01:15 <EvanR> but it does use the same word for something else
19:01:58 <infinisil> Oh, it doesn't refer to produced binary determinism
19:03:07 <infinisil> but binary objects during the compiling process
19:06:03 <EvanR> a better narrative might be not which properties the language satisfies or not, but why do we care
19:06:59 <EvanR> sometimes non determinism is a feature not a bug
19:07:12 <infinisil> EvanR: how so?
19:09:53 <EvanR> the list monad is basically giving you non determinism
19:10:14 <EvanR> each computation can have less than one or more than one result
19:11:43 <infinisil> EvanR: That's just non-determinism modeled through something that's still deterministic though
19:11:54 <EvanR> a thread scheduler might be broken if it always chose the first thread that wanted to run
19:12:05 <infinisil> or randomness really
19:12:08 <EvanR> infinisil: again mixing up a few different senses of the word
19:12:56 <infinisil> okay yeah, non-determinism is sometimes desired (but that shouldn't need to be the case for a compiler)
19:13:29 <EvanR> a thread schedule might be broken if it chose randomly which thread to run :)
19:13:32 <EvanR> scheduler
19:13:49 <infinisil> amortized probably not though?
19:14:16 <infinisil> "your thread will run eventually, probably"
19:14:49 <EvanR> that guarantee is satisfied by running it once eventually and never again
19:15:44 <EvanR> actually choosing randomly from a bucket over and over gives you clumpy results
19:17:37 <infinisil> EvanR: Just found this :) https://en.wikipedia.org/wiki/Lottery_scheduling
19:18:05 <EvanR> whereas choosing like this page would give more even results https://en.wikipedia.org/wiki/Low-discrepancy_sequence
19:19:38 <infinisil> EvanR: I see, makes sense
19:23:11 <EvanR> if the amount of work done on each run is the same... round robin
19:27:45 <hololeap> :i Representable
19:29:27 <hololeap> Representable seems like a more abstract version of Enum
19:31:03 <hololeap> would it be ok to type unicode into this channel?
19:31:30 <hololeap> actually, it looks like my irc client doesn't dispaly it properly...
19:35:24 <infinisil> Oh god, what the hell is a profunctor
19:35:42 <infinisil> and I see Hask, which I have no idea about etiher
19:37:13 <EvanR> a profunctor is a combination of a functor and a contrafunctor
19:37:26 <erisco> infinisil, (->) is the prime example
19:37:45 <infinisil> cotrafunctor?
19:38:10 <EvanR> contravariant functor
19:38:17 <EvanR> :t contraMap
19:38:18 <lambdabot> error:
19:38:18 <lambdabot>     • Variable not in scope: contraMap
19:38:18 <lambdabot>     • Perhaps you meant ‘contramap’ (imported from Control.Lens)
19:38:22 <EvanR> :t contramap
19:38:23 <lambdabot> Contravariant f => (a -> b) -> f b -> f a
19:38:56 <infinisil> oh that's a weird type
19:39:21 <EvanR> the rabbithole keeps going
19:40:53 <infinisil> Wait, is this like a bijection?
19:41:22 <EvanR> no
19:42:45 <EvanR> :t rmap
19:42:46 <lambdabot> Profunctor p => (b -> c) -> p a b -> p a c
19:42:49 <EvanR> :t lmap
19:42:50 <lambdabot> Profunctor p => (a -> b) -> p b c -> p a c
19:43:09 <EvanR> rmap acts like fmap on the second type variable
19:43:18 <EvanR> lmap acts like contramap on the first variable
19:43:34 <EvanR> its bifunctor with a twist
19:44:13 <erisco> you won't believe how it ends!
19:44:49 <EvanR> :t bimap
19:44:50 <lambdabot> Bifunctor p => (a -> b) -> (c -> d) -> p a c -> p b d
19:45:02 <infinisil> what is this black magic
19:45:26 <EvanR> not magic
19:45:28 <infinisil> sooo, what can i /do/ with a profunctor? How can I use it?
19:45:38 <EvanR> lmap it, rmap it :)
19:48:04 <erisco> could also consider Arrow, here
19:48:56 <EvanR> Arrow, in retrospect, is like category + profunctor + cruft
19:51:55 <infinisil> While I really appreciate the expressiveness of monads, this stuff is a bit too far out of my reach for now
19:52:04 <infinisil> I fail to see how that's any useful
20:03:14 <EvanR> infinisil: well ... https://www.youtube.com/watch?v=JZPXzJ5tp9w
20:04:23 <EvanR> you may or may not be able to skip to the profunctor pqrt
20:04:24 <EvanR> part
20:06:05 <infinisil> EvanR: Thanks for the link, seems interesting in general
20:08:38 <EvanR> i take it back, watch the entire thing
20:08:53 <EvanR> because its informative and hilarious
20:10:55 * hackage yahoo-finance-api 0.2.0.3 - Read quotes from Yahoo Finance API.  https://hackage.haskell.org/package/yahoo-finance-api-0.2.0.3 (cdepillabout)
20:13:45 <CoderWannabe> hello everyone. I was hoping a haskell genius might tell me why I'm not understanding type signatures correctly.
20:13:50 <CoderWannabe> https://pastebin.com/ea5f9wpp
20:14:20 <CoderWannabe> only works when I qualify the type signature like so -     maybeRead ::  Read a :: String -> Maybe a
20:14:38 <CoderWannabe> sorry... maybeRead ::  Read a => String -> Maybe a
20:16:31 <EvanR> CoderWannabe: so you need to put Read a => on it
20:16:55 <EvanR> the error message does contain the reason, i believe
20:17:45 <geekosaur> CoderWannabe, in simple cases the compiler might be able to prove that a Read a constraint is always present. but if it's exported, it can't because it can;t know what future code will use it
20:18:44 <geekosaur> constraints like that at compile time therefore become "hidden" parameters at runtime, where the compiler passes a proof that whatever value it uses for a prssesses a Read instance. (an existence proof, in fact: it passes the specific "reads" function for the type)
20:19:01 <geekosaur> *possesses a
20:20:35 <geekosaur> ...I should say the generated code passes the proof, not the compiler itself
20:20:53 <CoderWannabe> Thanks EvanR and geekosaur. I appreciate the responses. Why I understand the basics of type signatures, I think the divide between what happens at compile time versus runtime has been a hangup for me. Any recommended readings that might help? thanks again. 
20:22:20 <EvanR> CoderWannabe: you used `reads', which requires Read support
20:23:04 <infinisil> EvanR: That was a great talk and talker
20:23:16 <EvanR> String -> Maybe a, by itself means, a function which takes a String and returns Maybe a for any a you want. which makes no sense after some thought believe me
20:24:18 <CoderWannabe> I see! I've been reading the documentation wrong in terms of how type constraints work... Thanks a ton! I know it was a small thing, but you guys just helped the lights click. Thanks again so much, lol.
20:24:18 <EvanR> unless you return Nothing 
20:25:31 <EvanR> infinisil: yeah that video is really well done
20:35:12 <infinisil> Man, I got so much stuff to discover in haskell
20:35:36 <infinisil> it's amazing what you can do with it
20:36:42 <slack1256> do you guys learn libraries pre-emptively or right at the moment of need?
20:37:25 * Clint squints.
20:40:07 <erisco> both
20:41:11 <andromed1-galaxy> I'm trying to build ghc 8.0.2 and the build fails immediately with an error in utils/ghc-cabal/Main.hs that 'componentsConfig' is not in scope.  Does anyone know what might cause this/how t fix it?  If it is relevant, the host ghc is 8.2.1
20:41:51 <andromed1-galaxy> (I am building 8.2.0 because I need to later apply some patches that are not easy to forward port)
20:45:03 <ntc2> Hi. I'm also failing to build 8.0.2 using 8.2.1, but my error is `ghc-cabal: Encountered missing dependencies: process >=1.1 && <1.5`.
20:45:54 <ntc2> My general question is: should I expect old versions of GHC to build? I reported a GHC bug and someone suggested I try to find the commit that introduced it using Git bisection, but so far I've only been able to build GHC HEAD.
20:46:27 <EvanR> old versions of ghc should definitely build with versions soon prior to that
20:46:46 <EvanR> i would be interested to see if the reverse is true
20:47:36 <ntc2> @EvenR: by "with versions soon prior to that" you mean I should try building 8.0.2 with something at least as old as 8.0.2?
20:47:36 <lambdabot> Unknown command, try @list
20:47:41 <ntc2> EvenR: by "with versions soon prior to that" you mean I should try building 8.0.2 with something at least as old as 8.0.2?
20:48:08 <geekosaur> ntc2, the build policy says you can build a gghc version with itself or the two immediately prior releases
20:48:18 <geekosaur> building with a later version is *not* guaranteed to work
20:48:43 <geekosaur> (because it may have been relying on a bug that was eventually fixed, for example)
20:49:00 <ntc2> geekosaur: ah! I had not come across this "build policy". Could you tell me where that is on the wiki? I'll link to it from the Newcomers page.
20:49:51 <geekosaur> to give a current example, 8.2.1 inclided a thing called deriving strategies, because in older versions if you had DeriveAnyClass and GeneralizedNewtypeDeriving both enabled, which one got used when both could apply was essentially random
20:51:14 <geekosaur> I don;t think ghc itself uses DeriveAnyClass, but if ti had then there'd be litt;le guarnatee aside from explicit tweaks as to whether/how its code would compile with different ghc releases
20:54:04 <geekosaur> ntc2, https://ghc.haskell.org/trac/ghc/wiki/Building/Preparation/Tools
20:54:54 <geekosaur> which is linked from the Building Guide, indirectly (via Setting up your system for building GHC)
20:56:03 <ntc2> geekosaur, thanks! I just tried rebuilding 8.0.2 using 8.0.1, but get the same error about `ghc-cabal: Encountered missing dependencies: process >=1.1 && <1.5`.
20:56:18 <andromed1-galaxy> I also tried buildin with 7.10.3, but got some similar errors in utils/ghc-cabal/Main.hs: PackageName, componentConfig, an AbiHash are all listed as being out of scope
20:57:30 <geekosaur> ntc2, that sounds like it's still using the wrong ghc, since packages are installed for particular ghc versions. or, there is something else wrong (process should be provided in tree, did you forget to "./boot"?)
20:57:43 <ntc2> And I meant to ask about this in #ghc, not #haskell :P I'll move the question there now.
20:58:02 <infinisil> Damn, pipes seem really nice
20:58:09 <infinisil> I could really use these for my project
20:58:17 <andromeda-galaxy> geekosaur: do you have any idea what is up with the ghc-cabal not in scope errors
20:58:40 <geekosaur> that sounds like incompatible cabal version trying to build the in-tree cabal
20:58:46 <ntc2> geekosaur, I did `make clean`, but did not rerun `./boot`. I'll try that too ...
20:58:50 <geekosaur> I think that's covered on the same page
20:59:08 <geekosaur> ntc2, if you changed the ghc in $PATH then you likely alkso need to rerun configure
21:00:32 <geekosaur> hm, no, it doesn;t mention cabal dep. but those symbols are from the Cabal lib and AbiHash requires a sufficiently recent Cabal lib (1.24 is new enough, dunno about earlier)
21:01:35 <geekosaur> ntc2, andromeda-galaxy, you might do better asking in #ghc if you still have problems, there's more people who know version specifics and such
21:02:10 <andromeda-galaxy> geekosaur: oops, will do, thanks! That might be the issue, it looks like I have cabal 1.22.
21:02:43 <andromeda-galaxy> I wasn't sure if #ghc was only for upstream ghc development discussions or not
21:03:02 <geekosaur> building ghc counts as that, in some sense
21:03:19 <geekosaur> and the build system has odd corners that people there are more likely to be able to answer in general
21:03:48 <geekosaur> and many of them don;t hang out in here because with 1700+ people it's often rather high traffic
21:04:39 <andromeda-galaxy> geekosaur: makes sense. thanks for the suggestions!
21:10:43 <Gurkenglas> Could we have "uninlining pragmas" which derive hlint rules?
21:13:16 <jle`> infinisil: this is pleasantly surprising news to me :)
21:13:52 <infinisil> jle`: that i could really use pipes?
21:15:01 <jle`> about the determinism of ghc
21:19:33 <infinisil> Ah :2
21:19:34 <infinisil> :)
21:21:16 <begriffs> So ghc provides that special Paths_<project_name> module with a "version" function to reflect on the current version of the project in cabal...is there a way to get access to the git SHA of the project too? I'd like to include the exact build SHA as version output. It would help me debug problems for people who are running a custom build of my software from master.
21:24:51 <geekosaur> Paths_* is actually a Cabal thing. and Cabal doesn't know about git.
21:26:14 <geekosaur> the usual trick is that Setup.hs retrieves the SHA (see: git describe) and generates a source file
21:30:39 <ntc2> begriffs, the `gitrev` package gives you access to Git revs in your program: https://hackage.haskell.org/package/gitrev.
21:31:04 <begriffs> ntc2: perfect! Thank you.
21:31:14 <geekosaur> (there's also trickier ways like having one of the source files use TH's runIO
22:00:50 * hackage relational-query 0.9.5.1 - Typeful, Modular, Relational, algebraic query engine  https://hackage.haskell.org/package/relational-query-0.9.5.1 (KeiHibino)
22:22:40 * hackage relational-schemas 0.1.4.2 - RDBMSs' schema templates for relational-query  https://hackage.haskell.org/package/relational-schemas-0.1.4.2 (KeiHibino)
22:34:42 <cocreature> geekosaur: it’s not very tricky if gitrev does all the work for you :)
22:41:16 <begriffs> Added gitrev and it worked just fine.
22:44:06 <koz_> Can I use Pandoc to convert an EPUB to PDF?
22:45:45 * hackage relational-query-HDBC 0.6.4.2 - HDBC instance of relational-query and typed query interface for HDBC  https://hackage.haskell.org/package/relational-query-HDBC-0.6.4.2 (KeiHibino)
22:48:55 <cocreature> koz_: should work afaik
22:49:04 <koz_> cocreature: I just realized I forgot some magic flags.
22:57:17 * hackage relational-query 0.10.1.0 - Typeful, Modular, Relational, algebraic query engine  https://hackage.haskell.org/package/relational-query-0.10.1.0 (KeiHibino)
23:30:49 * hackage relational-query-HDBC 0.6.6.0 - HDBC instance of relational-query and typed query interface for HDBC  https://hackage.haskell.org/package/relational-query-HDBC-0.6.6.0 (KeiHibino)
23:39:21 * hackage relational-record 0.2.1.0 - Meta package of Relational Record  https://hackage.haskell.org/package/relational-record-0.2.1.0 (KeiHibino)
23:43:10 * hackage time-machine 0.1.0 - A library to mock the current time.  https://hackage.haskell.org/package/time-machine-0.1.0 (y_taka_23)
23:46:16 * hackage relational-schemas 0.1.6.0 - RDBMSs' schema templates for relational-query  https://hackage.haskell.org/package/relational-schemas-0.1.6.0 (KeiHibino)
