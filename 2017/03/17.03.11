00:44:23 <Sh4rPEYE> Hi! I'm looking for a way to install and use IHaskell, because I love IPython. The problem is it depends on old version of packages... And I'm not really a hacker, so that was the final hurdle. Could somebody help me?
01:03:38 <pacak>  Sh4rPEYE: I think haskell works better if you use it as it supposed to be used. But if you have any specific errors - I can try to help
01:04:25 <jle`> pacak: what does that mean lol.  is ihaskell not a legitimate way of using haskell?
01:05:44 <geekosaur> I think you may want to try iHaskell from its git repo, the last release is a year old but git was last updated about a month ago
01:06:14 <pacak> jle`: I think tried using it a while ago. It's strange.
01:07:16 <jle`> i don't think you can say that it's not how haskell is meant to be used, though
01:09:24 <geekosaur> ghci isn't exactly how haskell was meant to be used either :p
01:17:33 <dmwit> Sh4rPEYE: I installed iHaskell recently from the git repo following the instructions in their README. It seemed to work well, though you will need an older GHC; GHC 8 is not supported at the moment.
01:18:06 <tsahyt> are there examples of types that are both monads and comonads?
01:18:27 <dmwit> Writer
01:20:54 <dmwit> Identity, I suppose
01:20:55 <tsahyt> I see
01:23:10 <dmwit> I bet you can make non-empty lists into a Monad. Perhaps they are a Comonad, too, in some way.
01:23:37 <edwardk> non-empty lists are a comonad, basically tails without [] in the result
01:23:40 <edwardk> with head as extract
01:24:00 <edwardk> aka Cofree Maybe
01:24:13 <dibblego> Tree
01:24:40 <tsahyt> edwardk: is there a particular reason why head is chosen as extract rather than say last?
01:25:10 <edwardk> tsahyt: see the streams package for the option to have both causal and anti-causal streams where it takes inits/last basically
01:25:18 <geekosaur> if it's nonempty then head is always defined. last may not be if it;'s an infinite list
01:25:28 <edwardk> but the short answer is performance, head is O(1), last is O(n)
01:25:38 <dmwit> last is fine for non-empty snoc lists ;-)
01:25:40 <edwardk> and also head (and tails) terminates for infinite streams
01:25:46 <tsahyt> well that makes sense of course
01:26:26 <edwardk> the streams package bundles nonempty snoc-lists for the causal last/init form and normal nonempty lists for anti-causal streams
01:28:05 <edwardk> if you have no final entry like data Stream a = a :- Stream a  -- then the monad is isomorphic to (Natural ->) -- its a zipping reader monad. and the comonad is basically Traced (Sum Natural)      which is also Natural -> .... but ensuring the monoid used to glue together functions is (+)
01:28:32 <dmwit> Oh yes, byorgey has a nice post on Reader comonads and their connection to monoids.
01:28:44 <dmwit> So that's another good example.
01:28:59 <edwardk> watch out the co-reader is really (,) e    so the terminology is a mess =
01:29:02 <edwardk> =P
01:29:13 <dmwit> Good thing I didn't say co-reader then!
01:29:38 <edwardk> hence why i picked arbitrary'ish names for the various comonad transformers in the comonad package
01:29:52 <edwardk> as CoFoo basically told you nothing
01:30:36 <edwardk> and showing that they are _actually_ dual turned out to be rather more difficult than expected, so i didn't believe it for a lon time =)
01:30:44 <edwardk> er long
02:11:26 <Sh4rPEYE> I have some connection issues, so I don't know if my last message got through: I'd like to learn Haskell on mac, preferably without a big IDE. I thought the notebooks might be the best way, but if I have to use old compiler with them... Not so clean and elegant anymore. What are the other options, and what are the best ones in your opinion?
02:12:47 <dmwit> I don't think that message got through before now.
02:13:07 <dmwit> Personally, vim+ghci has worked well for me.
02:13:39 <dmwit> Some folks like ghcid. There are also various integrations with vim and emacs, but I don't really use them much.
02:13:51 <infinity0> is there a way to specify your own wrap-operators like [] ?
02:14:13 <dmwit> Not really. There are quasiquoters, which would let you write `[myOp| ... |]`.
02:14:27 <dmwit> You define `myOp`.
02:14:53 <dmwit> But they are quite heavyweight compared to other operators in Haskell: you have to do your own parsing of `...`, for example.
02:15:16 <Sh4rPEYE> I'm not really profficient with vim/emacs. 
02:15:18 <infinity0> ah, ok
02:15:41 <dmwit> There is also a somewhat standard trick for multi-arity infix operators, in case you haven't seen it you might find it sufficient.
02:16:15 <dmwit> > let (-|) = (,); (x, y) |-> z = 100*x + 10*y + z in 3 -|4|-> 5
02:16:18 <lambdabot>  345
02:16:26 <Sh4rPEYE> I'll probably stick to VSCode + ghci. Thanks for help though :-)
02:17:17 <infinity0> dmwit: i see thanks, i'll have a play with it :)
02:19:24 <Sh4rPEYE> And somewhat off-topic question. I'll use the Haskell Proramming book + do some Rosalind excersizes. Is there some Haskell algorithms/cookbook you could recommend for a beginner?
02:19:59 <dmwit> Folks often recommend RWH, which I would classify very much as cookbook-style.
02:20:00 <dmwit> ?where RWH
02:20:01 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
02:20:31 <Sh4rPEYE> Somewhere I read is outdated... It's from 2008, isn't it
02:20:49 <Sh4rPEYE> If you say it'ß useable still, better for me :-D 
02:20:59 <sm> there's HTAC, https://leanpub.com/haskell-cookbook
02:21:06 <dmwit> There are a few chapters that obsoleted themselves by becoming Hackage packages.
02:22:02 <Sh4rPEYE> Ok, thanks
02:53:21 <jaseemabid> I've a monad transformer stack with State and Either; `type Result a = StateT Env (ExceptT String Identity) a`. I'm absolutely lost on how to run this transformer and extract the value a. Any pointers? I've been starting at incomprehensible mil errors since last ~4 hours. 
02:53:39 * jaseemabid needs help
02:54:52 <jaseemabid> I couldn't make any of the `runStateT` or `runExceptT` examples work so far. 
02:56:39 <mauke> :t runExceptT
02:56:41 <lambdabot> ExceptT e m a -> m (Either e a)
02:56:49 <mauke> :t runStateT
02:56:51 <lambdabot> StateT s m a -> s -> m (a, s)
02:57:39 <mauke> :t runIdentity (runExceptT (runStateT ?foo ?env))
02:57:41 <lambdabot> (?foo::StateT s (ExceptT e Identity) a, ?env::s) => Either e (a, s)
02:58:48 <jaseemabid> mauke, The types _sort of_ makes sense, but I've probably tried all combinations of it by now :/
02:59:39 <mauke> what do you mean, combinations
02:59:58 <mauke> what I typed there is how you do it
03:02:03 <chilversc> what exactly is the context in a tpye signature? this mentions it but does not explain it https://wiki.haskell.org/Type_signature
03:02:49 <mauke> basically a list of class constraints
03:03:07 <mauke> in the example Num a means that a has to be an instance of Num
03:03:24 <jaseemabid> Ah. So you runStateT and get rid of the state and get the except value. The  runExceptT and get the Either and then runIdentity to get the `a` 
03:03:34 <chilversc> so why isn't that just, [t] -> Num a; instead of Num a => [t] -> a?
03:04:02 <chilversc> or, [t] -> Num ?
03:04:11 <jaseemabid> mauke,  Something like `runIdentity $ runExceptT $ runStateT (progn undefined) undefined`  gives me `Either String (Scheme, Env)`; which is close enough to what i wanted 
03:04:21 <mauke> jaseemabid: no, you get Either String (a, Env)
03:04:45 <mauke> there isn't necessarily an 'a' in there
03:04:47 <qqwy> Good morning everyone!
03:05:03 <mauke> chilversc: because Num isn't a type
03:05:15 <jaseemabid> mauke, Yeah. The a is a fixed type Scheme for me here. 
03:05:38 <mauke> :t evalStateT
03:05:41 <lambdabot> Monad m => StateT s m a -> s -> m a
03:05:47 <mauke> ^ if you don't care about the final state
03:06:07 <mauke> but you still have to deal with the absence of Scheme because of ExcepT
03:06:18 <mauke> +t
03:06:20 <qqwy> I am looking for a function that does `Data.List.inits` and `Data.List.tails` at the same time (for clarity: [a] -> [([a],[a])])
03:06:33 <qqwy> That is, it returns all the different ways to split a list into two sublists
03:06:37 <ski> chilversc : `Num' is not a concrete type. it's a type predicate. `[t] -> Num a' and `[t] -> Num' are nonsense, doesn't kind check
03:06:38 <mauke> :t inits &&& tails
03:06:40 <lambdabot> [a] -> ([[a]], [[a]])
03:07:26 <qqwy> :t foo list = zip (heads list) (tails list)
03:07:28 <lambdabot> error:
03:07:29 <lambdabot>     parse error on input ‘=’
03:07:29 <lambdabot>     Perhaps you need a 'let' in a 'do' block?
03:07:37 <mauke> :t uncurry zip . inits &&& tails
03:07:40 <lambdabot> error:
03:07:40 <lambdabot>     • Couldn't match type ‘[[a1]]’ with ‘([a], [b])’
03:07:41 <lambdabot>       Expected type: [a1] -> ([a], [b])
03:07:45 <qqwy> :t let foo list = zip (heads list) (tails list)
03:07:48 <lambdabot> <no location info>: error:
03:07:48 <lambdabot>     not an expression: ‘let foo list = zip (heads list) (tails list)’
03:07:57 <mauke> :t uncurry zip . (inits &&& tails)
03:07:59 <lambdabot> [a] -> [([a], [a])]
03:08:20 <qqwy> Obviously I am looking for something that computes both of them at the same time, rather than iterating twice over the list.
03:08:22 <qqwy> ^^'
03:09:03 <qqwy> By the way, where is `&&&` defined? Applicative or something?
03:09:17 <mauke> @hoogle &&&
03:09:20 <lambdabot> Control.Arrow (&&&) :: Arrow a => a b c -> a b c' -> a b (c, c')
03:09:20 <lambdabot> Data.Constraint (&&&) :: (a :- b) -> (a :- c) -> a :- (b, c)
03:09:20 <lambdabot> Data.Tuple.Extra (&&&) :: (a -> b) -> (a -> c) -> a -> (b, c)
03:10:03 <jaseemabid> mauke, that seems to have worked. Thanks a lot :)
03:10:17 <chilversc> ah, so Num a =>; says that a will be some kind of number, with out restricting it to be an Int
03:10:47 * qqwy is astonished by @lambdabot's prowess
03:10:56 <qqwy> Thank you, mauke!
03:11:56 <ski> @type let split xs = ([],xs) : case xs of [] -> []; x:xs -> map (first (x:)) (split xs) in split
03:12:02 <lambdabot> [t] -> [([t], [t])]
03:12:15 <ski> @type let split [] = [([],[])]; split xs0@(x:xs) = ([],xs0) : map (first (x:)) (split xs) in split
03:12:18 <lambdabot> [t] -> [([t], [t])]
03:12:40 <ski> chilversc : yep
03:14:02 <mauke> :t (==)
03:14:04 <lambdabot> Eq a => a -> a -> Bool
03:14:53 <qqwy> :t first
03:14:55 <lambdabot> Arrow a => a b c -> a (b, d) (c, d)
03:15:53 <ski> instead of `first (x:)', i could have said `\(front,back) -> (x:front,back)'
03:16:08 <qqwy> Wow
03:16:20 <qqwy> Where can I read more about how to work with the Control.Arrow functions?
03:16:22 <ski> (or one could use a list comprehension)
03:16:22 <qqwy> they look so useful
03:16:29 <qqwy> although slightly obfuscating, possibly ^^'
03:16:51 <mauke> replace all 'Arrow a' by '->'
03:16:58 <mauke> that's the only thing I use them for anyway
03:17:00 <qqwy> Thank you very much, ski!
03:17:52 <qqwy> So Control.Arrow contains all kinds of magic functions to alter the way you can sequence functions together?
03:17:54 <ski> qqwy : lists can be used for "nondeterministic computation". `split' above is an example of that, computing all possible ways to cut a list in two pieces
03:18:05 <qqwy> mind = blown
03:18:32 <ski> `Control.Arrow' contain a few handy functions for writing pointless code
03:20:15 <ski> ("pointless", or "pointfree", as opposed to "pointful", because the "points", i.e. the input values on which the functions operate, aren't visible. the most basic such functions are `id', the identity function, and `(.)', function composition. there's also `const' and `flip' in the `Prelude')
03:20:38 <ski> @src (->) first
03:20:39 <lambdabot> first f = f *** id
03:20:48 <ski> @src (->) (***)
03:20:49 <lambdabot> (f *** g) ~(x,y) = (f x, g y)
03:21:05 <qqwy> @src ~
03:21:05 <lambdabot> Source not found. Just what do you think you're doing Dave?
03:21:17 <ski> that's lazy pattern-matching
03:21:29 <ski> it can sometimes make a difference
03:21:33 <qqwy> O_O Lazy... pattern matching? Wow
03:21:56 <ski> it delays the matching of the pattern it is applied to, until a variable bound by that pattern is demanded (forced)
03:22:14 <qqwy> Does it matter for efficiency, or is it mostly to have correct handling of _|_ ?
03:22:29 <ski> and then the pattern had better match, since otherwise you get a run-time failure (as opposed to trying the next alternative, which would happen if you didn't use `~')
03:22:47 <ski> sometimes it's the difference between terminating and nonterminating code
03:23:12 <ski> i'm not sure whether you count that among the former, the latter, or both :)
03:23:18 <qqwy> Ah, so it is like saying "trust me, it will match, but since you'll only need the result later, lets not expand it yet"
03:23:23 <ski> right
03:23:25 <qqwy> True, true :')
03:23:35 <ski> @src partition
03:23:35 <lambdabot> partition p xs = foldr (select p) ([],[]) xs
03:23:35 <lambdabot>     where select p x ~(ts,fs) | p x       = (x:ts,fs)
03:23:35 <lambdabot>                               | otherwise = (ts, x:fs)
03:23:54 <ski> > (take 4 *** take 4) (partition even [0 ..])
03:23:57 <lambdabot>  ([0,2,4,6],[1,3,5,7])
03:24:38 <ski> @let partition' p xs = foldr (select p) ([],[]) xs where select p x (ts,fs) | p x = (x:ts,fs) | otherwise (ts,x:fs)
03:24:38 <lambdabot>  Parse failed: Parse error: EOF
03:24:45 <ski> @let partition' p xs = foldr (select p) ([],[]) xs where select p x (ts,fs) | p x = (x:ts,fs) | otherwise = (ts,x:fs)
03:24:49 <lambdabot>  Defined.
03:24:50 <ski> > (take 4 *** take 4) (partition' even [0 ..])
03:24:54 <lambdabot>  (*Exception: stack overflow
03:25:07 <ski> this is an example where the lack of `~' causes nontermination
03:25:36 <ski> since without `~', it waits to produce an output element until it has traversed to the end -- which will never happen with an infinite list
03:26:24 <qqwy> Ah, because it tries to fill in the pattern match at that time
03:26:31 <qqwy> even though you might only use part of that match later on
03:26:40 <qqwy> Nice! Very important to know
03:26:44 <ski> the problem is that if we force the matching of the pattern `(ts,fs)' right now, that will force the recursive call in `foldr' right now, which runs down an infinite path in a tree, with no return
03:27:07 <ski> but with `~' on that pattern, it works out fine
03:28:20 <ski> (the `take 4 *** take 4' is just a quick way to cut off the ends of the two result lists, in order to see that you get results for both lists. otherwise it would never get to showing the second list, since the first (and second) are infinite)
03:29:30 <ski> qqwy : if you're doing tying-the-knot tricks, passing back an output of a call as an input to the same call, then often `~' can also be critical
03:30:09 <ski> (e.g. if you're using `fix' to produce a pair .. of two lists or whatever)
03:30:30 <qqwy> Awesome
03:30:59 <ski> > (take 4 *** take 4) (fix (\ ~(xs,ys) -> (0:ys,map (1+) xs)))
03:31:04 <lambdabot>  ([0,1,2,3],[1,2,3,4])
03:31:05 <ski> > (take 4 *** take 4) (fix (\(xs,ys) -> (0:ys,map (1+) xs)))
03:31:06 <qqwy> My 'tying the knot' has until now been only about building simple cyclic structures, as well as an on-line longest common subsequence algorithm
03:31:11 <lambdabot>  mueval-core: Time limit exceeded
03:31:34 <qqwy> marvellous stuff :D
03:32:39 <qqwy> Please enlighten me: How can you write `foo list = zip list (tail list)` using pointless style?
03:32:48 <AWizzArd> Is there a compiler switch that turns on warnings when I introduce a local var which shadows another one?
03:32:52 <ski> @pointless foo list = zip list (tail list)
03:32:52 <lambdabot> foo = ap zip tail
03:33:06 <ski> @quote zip`ap`tail
03:33:06 <lambdabot> quicksilver says: zip`ap`tail - the Aztec god of consecutive numbers
03:33:37 <qqwy> @type ap
03:33:39 <ski> that's using the `(a ->)' instance of `Monad'
03:33:40 <lambdabot> Monad m => m (a -> b) -> m a -> m b
03:34:05 <ski> replace `m' there with `(rho ->)', say, and you get `(rho -> a -> b) -> (rho -> a) -> (rho -> b)'
03:34:18 <ski> this is also known as the "S combinator" (see SKI combinators)
03:34:42 <qqwy> :D!!!
03:35:16 <ski> @type liftA2 zip id tail  -- one can also do this
03:35:18 <lambdabot> [a] -> [(a, a)]
03:35:24 <ski> (or with `liftM2' instead of `liftA2')
03:36:14 <qqwy> Actually we only need the applicative instance of (a -> ) here, right?
03:36:31 <ski> (`const' is the `K' combinator, and `id' the `I' combinator. `flip' is the `C' combinator, and `(.)' the `B' combinator)
03:36:39 <ski> yes
03:36:54 <ski> the applicative version of `ap' is `(<*>)'
03:37:09 <qqwy> Ah, of course
03:37:12 <ski> `ap' was invented before `Applicative'
03:37:15 <qqwy> I've seen that one before
03:38:19 <ski> AWizzArd : try `-fwarn-name-shadowing' ?
03:39:11 <ski> anyway, the `pointless' (`pl' for short) lambdabot command quite often produces unreadable incantations
03:39:47 <ski> usually i prefer deriving the incantation myself
03:41:10 <ski> @type join id
03:41:12 <lambdabot> error:
03:41:13 <lambdabot>     • Occurs check: cannot construct the infinite type: m ~ (->) (m a)
03:41:13 <lambdabot>       Expected type: m (m a)
03:41:56 <ski> oh, sorry, not `id'
03:42:16 <ski> @type \f x -> join f x  -- forcing it to set `m' to `(t ->)'
03:42:18 <lambdabot> (t -> t -> t1) -> t -> t1
03:42:54 <ski> in pointless incantations, this use of `join' is quite common
03:43:21 <qqwy> I love how these are called incantations :-)
03:43:30 <qqwy> @type join
03:43:32 <lambdabot> Monad m => m (m a) -> m a
03:43:38 <qqwy> Ah, yes, of course, that one
03:45:03 <ski> there's a fine line between a nice or cute pointless expression, and one which risks being incomprehensible or requiring too much thought to decipher
03:45:38 <ski> this line isn't in the same place for everybody, but it exists nonetheless. one shouldn't make code too pointless
03:46:11 <ski> some people may be comfortable reading `(foo .) . bar . (baz .)', say; while some won't
03:46:40 <qqwy> I wholeheartedly agree
03:47:08 <ski> a lot of the pointless expressions people show in here wouldn't be put in actual (non-throwaway) code
03:47:19 <ski> but it can serve as a kind of mental gymnastics
03:49:00 <ski> @where SEC
03:49:01 <lambdabot> http://conal.net/blog/posts/semantic-editor-combinators/
03:49:04 <ski> might also be relevant, here
04:00:05 <qqwy> @ps 
04:00:05 <qqwy>     currentProblemCost (lhs, rhs) = (fst (head lhs)) * fst (head rhs) * snd (last rhs)
04:00:06 <lambdabot> (line 1, column 1):
04:00:06 <lambdabot> unexpected end of input
04:00:06 <lambdabot> expecting white space, "()", natural, identifier, lambda abstraction or expression
04:00:20 <qqwy> @ps currentProblemCost (lhs, rhs) = (fst (head lhs)) * fst (head rhs) * snd (last rhs)
04:00:20 <lambdabot> currentProblemCost = uncurry ((`ap` (snd . last)) . ((*) .) . (. (fst . head)) . (*) . fst . head)
04:00:41 <qqwy> Indeed, that becomes unreadable very quickly
04:00:43 <qqwy> ^^"
04:07:38 <laserpants> I am looking at this wiki page: https://wiki.haskell.org/The_Fibonacci_sequence where it says "The fix used here has to be implemented through sharing, fix f = xs where xs = f xs, not code replication, fix f = f (fix f), to avoid quadratic behaviour."
04:08:20 <ph88> hi all
04:08:25 <ph88> can someone help me with lens ?
04:09:28 <ph88> i have this code http://lpaste.net/353242 and now instead of maximmum i like to search the structure with a predicate, and then change the value of the last value that matches the predicate and then get the same structure back with that one value changed
04:09:31 <laserpants> Why does the latter lead to quadratic behaviour?
04:09:46 <ski>   currentProblemCost = uncurry (*) . second (uncurry (*)) . ((fst . head) *** (fst . head) &&& (snd . last))  -- qqwy
04:12:09 <chilversc> bah, just spent 10 minutes trying to see why it wasn't working only to realise I had [x:xs] not (x:xs)
04:12:21 <cocreature> ph88: are you looking for "findOf"?
04:12:38 <cocreature> oh no nvm
04:13:14 <ph88> cocreature, not sure what functions to use and how .. i saw a few functions that possibly can be of help like lastOf and holesOf
04:13:46 <cocreature> ph88: the problem with lastOf is that it only allows you to get the value not modify it
04:14:06 <cocreature> ph88: "filtered" is close but it will modify all values that match the predicate not only the first one
04:14:45 <ph88> cocreature, yes i saw this too by the description of the functions .. but i don't know how to do it and which functions to use
04:15:29 <ski> laserpants : iiuc, with the "replication" version, you get repeatedly nested calls `scanl', deeper and deeper the longer you go. cf. left-associated `(++)'
04:16:30 <cocreature> > over (traverse . filtered even) (+1) [1,2,3,4]
04:16:37 <lambdabot>  [1,3,3,5]
04:16:47 <cocreature> ph88: so that’s how you modify all values matching a predicate
04:16:53 <cocreature> I’m not sure how to restrict it to the first one
04:17:02 <cocreature> (or the last one)
04:17:04 <laserpants> ski: i see ..  
04:17:57 <ski> with sharing, you only have one `scanl' call active at any time
04:19:00 <ph88> cocreature, ya me neither .. i've looked throught the functions and the only function i could find related to last value is lastOf, and as you say it's not the right function for me :(
04:20:24 <Cale> > over (singular (traverse . filtered even)) (+1) [1,2,3,4]
04:20:30 <lambdabot>  mueval-core: Time limit exceeded
04:20:34 <Cale> > over (singular (traverse . filtered even)) (+1) [1,2,3,4]
04:20:39 <lambdabot>  [1,3,3,4]
04:21:24 <ph88> Cale, that looks nice, but i would like to change the last value, not the first
04:24:44 <AWizzArd> Is there a way to allow multiple objects in case cases?
04:25:09 <cocreature> AWizzArd: you can match on a tuple of the values
04:25:12 <AWizzArd> case x of …    if x is 1 or 2 or 3, *then* I want to return x+10
04:25:29 <Cale> case x of _ | x `elem` [1,2,3] -> ...
04:26:07 <sternmull> or a let-binding that is used by all the cases
04:27:29 <ski> unfortunately no disjunctive patterns in Haskell
04:27:48 <cocreature> luckily osa1 is working on implementing them so we might get them in 8.4 :)
04:28:13 <AWizzArd> I also read about -XMultiWayIf
04:28:24 <osa1> cocreature: I'm working on that right now :)
04:28:36 <cocreature> osa1: thanks for doing that! I’m really looking forward to using it
04:29:59 <ski> osa1 : the binding set being the intersection of the ones of the child patterns, yes ?
04:30:10 <ski> or requiring them to have the same binding set ?
04:30:24 <osa1> ski: yes
04:30:27 <ski> which ? :)
04:30:29 <osa1> ski: including coercions and existentials
04:30:45 <osa1> all sub-patterns must bind same variables, coercions and existentials included
04:31:00 <ski> no local guards, i guess
04:31:42 <ski> i suppose there's no work on generalizing `@' to conjunctive patterns (e.g. useful with views) ?
04:31:50 <osa1> guards are same as before except there are two possible semantics depending on whether you want to try other alternatives or not in case of a guard match failure
04:32:12 <osa1> I'm not sure what does local guards mean though
04:32:35 <ski> well, i'd opt for trying the other alternative ..
04:33:22 <osa1> I'm currently implementing that version. extending the formal semantics for that is harder but in the implementation it's about the same in terms of implementation complexity
04:33:32 <ski> i mean like `(Left (x,y) when x >= 0) | (Right (_,y,_))', if `|' here is disjunctive pattern, and `when' is a local guard
04:33:49 <osa1> oh right. no that's not in the roadmap
04:34:00 <ski> `x' here is only available for use in the local guard
04:34:12 * ski nods
04:34:54 <osa1> conjunctive patterns would also be interesting. I'm guessing that you can only specify the shapes in those patterns, right? i.e. no bindings
04:35:46 <osa1> or you could do something like a non-linear pattern e.g. you can use same variable multiple times and those desugar to `(==)` guards
04:36:25 <ski> on this topic, one could also consider patterns `if <expr> then <pat> else <pat>' (and similarly with `case') and `let <expr> = <pat> in <pat>'. the `let' pattern here matching the value with the body pattern, binding variables which are used to evaluate the expression, which is matched with the other pattern
04:38:03 <ph88> be right back
04:38:43 <ski> osa1 : consider `(viewl -> x :> xs) @ (viewr -> ys :< y)'
04:39:51 <ski> er, flip `:>' and `:<'
04:41:02 <osa1> if I understand correctly that's like `| x :> xs <- viewl <fresh>, ys :< y <- viewr <fresh> -> ...` where <fresh> is the argument,  right?
04:41:27 <ski> (also slightly related is allowing `if',`case', and `let' (in SML, this is `local'-`in'-`end') as declarations)
04:41:40 <ski> osa1 : yes
04:42:06 <ski> using view patterns (or pattern synonyms) is the main use for conjuctive patterns, afaik
04:42:38 <osa1> interesting. you know any languages that support conjunctive patterns?
04:42:50 <ski> hm .. Mercury, i think
04:44:04 <ski> right, <https://www.mercurylang.org/information/doc-latest/mercury_ref/Unification-expressions.html>
04:44:37 <ski> this is in some sense "easier" in Mercury, since there's no syntactic distinction between patterns and expressions there
04:45:12 <ski> (otoh, there's a static analysis and checking mechanism of insts and modes (and determinisms) to make up for this)
04:47:12 <ski> i've wanted `let' for declarations many times in Haskell. `if'/`case' also some times
04:47:53 <ski> `if' and `let' as patterns is more a thought-experiment, to see how much of expression constructions one can sensibly bring over to patterns
04:48:40 <ski> .. i've also pondered allowing (certain stylized uses of) `case' for definiendums (left-hand-sides)
04:49:18 <ph88> ski, yesterday i read something fascinating
04:49:28 <ph88> that type system is related to logic programming
04:49:35 <ski> yes
04:49:41 <ph88> https://en.wikibooks.org/wiki/Haskell/The_Curry%E2%80%93Howard_isomorphism
04:49:52 <ph88> i already had a feeling about this
04:49:52 <ski> unification is a core part of logic programming
04:50:30 <ski> when reading type system inference rules, it helps to have some experience with logic programming. especially knowing about multiple modes of predicates
04:50:36 <cocreature> curry-howard is not really about logic programming, it’s about constructive logic
04:51:00 <ph88> i want to get into logic programming too
04:51:04 <ph88> it seems very useful
04:51:26 <ski> i'd suggest starting with Prolog, despite it being old and having many flaws
04:51:50 <ski> most of the learning material is in terms of Prolog, or a Prolog-derivative
04:51:51 <ph88> look at this https://www.youtube.com/watch?v=eQL48qYDwp4 ski
04:52:56 <ph88> ski, yeah i saw there are quite a few interesting language, some people like mercury or logtalk, but maybe just prolog is the best because of being the most well known
04:53:05 <ski> Mercury <https://www.mercurylang.org/> is a more modern logic programming language, also supporting functions, having a module system (!), static type checking, parametric polymorphism, algebraic data types, type classes, existentials, &c.
04:53:21 <ph88> ya i know
04:53:27 <cocreature> minikanren is also worth a look because of its simplicity
04:53:31 <ph88> seems attractive
04:53:51 <ph88> i actually found a implementation of minikanren in php :P
04:54:18 <ph88> watch that youtube though, it's very interesting
04:54:26 <ski> however, Mercury is also less flexible than Prolog. some things are harder or impossible to do in Mercury, that are easy or possible in Prolog
04:54:40 <dmiles> hrrm "Propositions are types" .. but are "Types actually Propositions"?
04:55:02 <ski> otoh, it's easier to get into trouble in Prolog, due to dynamic type checking, no static mode, determinism (especially this) checking
04:55:17 <ski> you might perhaps find "Re: Mercury in academic teaching?" by Richard A. O'Keefe in 2006-10-(09|10) at <http://www.mercurylang.org/list-archives/users/2006-October/004000.html>,<http://www.mercurylang.org/list-archives/users/2006-October/004011.html> interesting re which to start learning
04:55:37 * ski also finds those posts interesting from a more general standpoint
04:55:55 <ski> dmiles : in a generalized sense, they are :)
04:56:06 <ph88> ski, you wanna write a game bot with me with prolog ?
04:57:56 <ski> there's also the language Oz <http://mozart.github.io/>,<http://mozart.github.io/mozart-v1/doc-1.4.0/>, which is used in the book
04:57:59 <ski> @where CTM
04:57:59 <lambdabot> "Concepts, Techniques, and Models of Computer Programming", by Peter Van Roy,Seif Haridi, at <http://www.info.ucl.ac.be/~pvr/book.html>
04:58:56 <ski> which can be considered as a kind of update on SICP. it teaches different programming paradigm (of interest is e.g. "declarative concurrency", using dataflow variables for synchronization and communication between threads of execution)
04:59:26 <ski> Oz is at the core a logic programming language (without backtracking), onto which layers have been added to support more paradigms
04:59:35 <ph88> got d/c for a moment ^^
05:00:43 <dmiles> i wonder how OZ compares to Poplog
05:00:46 <ski> of interest here is also Constraint Programming. which is perhaps most easily handled in combination with Logic Programming : Constraint Logic Programming (CLP)
05:00:59 * ski should check out Poplog some time
05:01:06 <ph88> i think not too many things at once :P
05:01:33 <ph88> ski, have you tried clingo? i'm trying to find some opinions on it
05:03:26 <ski> dmiles : in a restricted sense, propositions can be seen as those types that have at most one proof (and where biimplication implies equality)
05:08:18 <dmiles> ski: hrm.
05:08:52 <dmiles> ph88: oh neat clingo website pointed out to me that ASP has a standardization effort
05:08:56 <ski> functional programming corresponds to proof reduction (simplification). logic programming corresponds to proof search
05:09:10 <ski> ph88 : haven't heard of clingo
05:09:44 * ski . o O ( <https://en.wikipedia.org/wiki/Answer_set_programming> )
05:09:57 <ph88> ski, https://potassco.org/
05:10:02 <dmiles> ASP is very easy to implment in prolog
05:10:25 <dmiles> so something i should study is extra things prolgo forgot
05:10:26 <ph88> then what does it offer on top of prolog ?
05:10:38 <ph88> it seems some people went out and invented some really cool new stuff
05:10:42 <ph88> but what is good about it ?
05:11:49 <ski> dmiles : .. when i say "at most one proof", i mean basically "at most one canonical / most reduced proof". there's an equational theory of proofs (being functional programming, more or less), that explains when two proofs are equivalent (equal)
05:12:01 <dmiles> ph88: well ASP simplies prolog qand in doing that i belive frees it up to add new features 
05:12:22 <dmiles> simplifies*
05:12:31 <Hafydd> ph88: ASP is more suitable for hard problems, requiring very large sets of possible solutions to be searched, than Prolog is.
05:13:35 <dmiles> ski: hrrm i see some benefit then i think
05:13:47 <ski> logic programming results from making the proof search more efficient and predictable, by introducing a focus, and by restricting the allowed classes of formulae to keep completeness in spite of the restriction on the search strategy
05:14:35 <dmiles> (i mean often the things i need to do in logic (though its more the logicains problem) is prove two instances are of the same type.. i suppose that would meant they had the same proofs
05:15:02 <dmiles> )
05:16:04 <dmiles> ski: was that last sentence about ASP or C-H ?
05:16:22 <ski> (re minikanren, also see the book "The Reasoned Schemer")
05:16:51 <Hafydd> ph88: http://www.cs.uni-potsdam.de/~torsten/Papers/asp4ki.pdf is a good introduction.
05:17:00 <dmiles> (ok yeah i interpreted your last statement about relatinal programing :P )
05:17:04 <ski> well. more related to C-H, i suppose. though i didn't read about it in connection to that
05:17:36 <ski> dmiles : some of the papers on lambdaProlog talks more about how to see logic programming as relating to proof search
05:18:58 <ph88> Hafydd, i already saw a pretty extensive introduction, but since i don't know prolog i don't know what are the differences between them
05:20:29 * ski . o O ( attribute grammars )
05:23:39 <dmiles> hrrm figure 21 of http://www.cs.uni-potsdam.de/~torsten/Papers/asp4ki.pdf  is awesome.. i didnt know ASP undertstand it needed to have multiple understands of negation
05:24:23 <dmiles> didnt know ASP undertstood we needed to have multiple understandings of strong negation
05:26:14 <dmiles> oh yeah cardinality contraints ASP is free to have (beyond prolog)
05:28:04 <dmiles> also lack of clause order prefernce in ASP is not avaiable in prolog (unless one really codes it)
05:28:44 <ph88> no idea what you're talking about :P
05:28:53 <kritzcreek_> How would I write a Recognizer with lexer-applicative that recognizes `<-` not followed by another symbol character and differentiates it from `<->`
05:28:56 <kritzcreek_> ?
05:29:25 <dmiles> Well what i am saying ph88, is ASP does offer some things that prolog by default makes hard to implment
05:29:36 <ph88> sounds good :P
05:30:47 <dmiles> but i been implementing those hard things :P.. so gawd.. i think i migh have ASP soon
05:32:00 <ph88> dmiles, please keep me posted about your experiences !
05:32:31 <ph88> i have to go, bye guys
05:33:53 <dmiles> oh very neat https://www.mat.unical.it/ricca/aspide/
05:34:01 <Hafydd> Knowing ASP but not Prolog is a pretty high level of programming hipster.
05:34:53 <dmiles> well from what i can tell ASP is slightly less crippling that Datalog might be 
05:35:03 <kgadek> FYI: https://www.reddit.com/r/rust/comments/5yo24a/meta_rust_jealousy/
05:35:04 <kgadek> > So I just met Simon Peyton Jones (creator of Haskell) and chatted with him for a bit. Asked him his thoughts on Rust and he said he thinks it seems exciting and he was jealous of the great community we have. Just thought I would let you guys know :)
05:35:06 <lambdabot>  <hint>:1:43: error: parse error on input ‘of’
05:35:22 <dmiles> (i am ony assuming though at this point)
05:36:41 <dmiles> Crippling = how hard it is to write applications
05:40:49 <dmiles> Less Crippling = if i had a prolog prgram if it is possible to port to ASP standard
05:56:53 <Hafydd> data Crippling =
05:58:21 <Hafydd> You can't port Prolog effects to ASP...
05:59:21 <dmiles> Like no assert/retract ?
05:59:45 <Hafydd> I mean things like I/O.
06:01:02 <dmiles> ah 
06:01:03 <Hafydd> But I'm sure there are other Prolog semantics that would not be trivial to port, like cutting.
06:01:19 <dmiles> is "Ordered Disjunction" a way to create clauses that stop (sort of like cut) ?
06:02:29 <dmiles> i was assuming it starts and running the disjuct list and on first success it cuts
06:03:10 <dmiles> i was assuming it starts out running over the disjuncts  and on first success, it stops (therefore like a cut)
06:03:23 <Hafydd> No, in principle it finds all solutions, although you might only look at the first one. In that way, I suppose ordered disjunctions might do something vaguely similar to cutting.
06:06:19 <dmiles> Can compund terms be put inside pred arguements?
06:06:27 <Athas> Urgh, for the first time, I've been bitten by the Foldable/Traversable integration with the Prelude.
06:07:49 <Hafydd> dmiles: yes. The ASP solver first expands all possible ground terms, possibly including nested terms, and instantiates each rule with each assignment of terms.
06:08:24 <Hafydd> (For this reason, the set of ground terms must be finite.)
06:09:14 <dmiles> are there anonmous unyfiers? like _ ?
06:09:48 <dmiles> are there anonymous unifiers like   loves(joe,_).
06:11:16 <dmiles> (i meant it as a dont care .. in one system that is truely "dont care" i might want to treat  Prop= loves(joe,_), knows(sue,Prop).
06:11:21 <dmiles> )
06:11:22 <Hafydd> dmiles: I don't know about newer versions of Clingo, but those weren't in the version I used; and if they are, they would be a syntactic sugar.
06:11:41 <Hafydd> dmiles: it would have to expand to something like: loves(joe, P) :- person(P).
06:11:59 <Hafydd> Or :- loves(joe, P), person(P).
06:12:05 <dmiles> (i might want to treat  Prop= loves(joe,_), knows(sue,Prop)...  as Ground!)
06:12:15 <dmiles> ok that is awesome
06:12:37 * ski . o O ( existential quantification )
06:12:54 <dmiles> ski thats secretly probly what i was hoping :P
06:13:20 <dmiles> Hafydd. right it would really only be things that met arg2 restriction of loves/2
06:14:24 <dmiles> the thing that makes prolog no fun is i have to make a skolem for existentials
06:15:08 <dmiles> (which why i added the truely "dont care" vars to SWI-Prolog's VM)
06:15:30 * ski isn't sure whether dmiles wanted `knows(sue,Prop)' to be treated as a clause/resource, or as a goal
06:15:37 <dmiles> (they do care .. becasue i put constraints onto the dont care)
06:16:21 <dmiles> (which is why they are existentiual and no longer universal in meaning)
06:16:52 <dmiles> 'knows(sue,Prop)' as a goal 
06:16:58 <Hafydd> Oh, they were in the version I used, actually, but I didn't use them much because they often make a program less efficient (i.e. with a large number of ground terms) when you don't constrain the variables.
06:17:09 <dmiles> loves(joe,_) as a resource?
06:17:42 <Hafydd> Er... a large number of ground rules, I mean.
06:18:16 <dmiles> Hafydd: hrrm .. sounds like they are just interating as naively as prolgo in that usecase
06:18:24 <dmiles> iterating*
06:18:52 <dmiles> (binding all 4 billion Persons to arg2)
06:19:14 <Hafydd> dmiles: I don't think any better way of doing it is known. For some problems, that's all we can do.
06:19:21 <Hafydd> dmiles: but Clingo does take some shortcuts.
06:20:42 <dmiles> shortcuts? (i know what you mean) but do tell
06:23:15 <ski> dmiles : i was thinking about `knows(sue,some [P] ( person(P),loves(joe,P) ))' .. but then when you mentioned skolems, i was wondering whether you were instead considering this as a clause/resource, rather than as a goal
06:23:43 <dmiles> ski: i sorta mixed and conflated the two topics
06:24:09 <ski> ok
06:24:14 <dmiles> the next question might have been knows(sue,some [P] ( person(P),loves(joe,P) )) 
06:24:23 <kuribas> is there a better way of sequence_ $ iterate n action?
06:24:41 <dmiles> actualy.. we an "Answer Set" might actualy decide we needed "some"
06:24:44 <kuribas> erm "sequence_ $ replicate n action?"
06:25:16 <ski> (where i was treating your `Prop= loves(joe,_)' as intending to express `Prop = some [P] ( person(P),loves(joe,P) )' (assuming that `P' in `loves(joe,P)' has `person(P)' as a presupposition))
06:25:32 <ski> @src replicateM_
06:25:32 <lambdabot> replicateM_ n x = sequence_ (replicate n x)
06:25:54 <kuribas> right
06:26:13 <kuribas> :t replicateM_
06:26:15 <lambdabot> Applicative m => Int -> m a -> m ()
06:26:30 <dmiles> ski: oh what i actualy was wondering about is   some [Prop] All [P]
06:26:31 <ski> (`Applicative' there used to be `Monad', hence the `M')
06:27:20 <dmiles> (Prop being a variable .. I was wondering is some Prop that matched loves(joe,_) existed
06:27:24 <ski> (i didn't really follow "which why i added ..")
06:27:34 <joneshf-laptop> I'm trying to use opaleye. I'd like to count the number of rows in a table based on an id, so I tried to write `foo :: QueryArr Id (Column PGInt8)`. I see `countRows`, but it only works with a `Query a`, not `QueryArr a b`. I next thought to make a function `foo' :: Id -> Query (Column PGInt8)`, but I don't understand how to use this in arrow syntax. It says `id not in scope`. Any thoughts?
06:28:55 <dmiles> and by loves(joe,_) .. i guess i meant "At least 1"
06:29:38 <Eduard_Munteanu> I wonder why people aren't running Hakyll or other static site generators at compile-time, a-la Yesod. Interpolating Haskell expressions is nice.
06:30:10 <ski> yes, aka `some'
06:32:18 * ski has no idea about `opaleye', but would possibly try looking for an operation corresponding to "GROUP BY" ?
06:32:20 <dmiles> so in the case of  a query to   knows(sue,( person(P),loves(joe,P))).   I wouldnt be suprised if P was a skolem like   some(P, knows(sue,( person(P),loves(joe,P))))
06:33:15 <dmiles> I mean the answer set that came back was:   P =  some(P, knows(sue,( person(P),loves(joe,P))));
06:33:34 <ski> (confusing two different `P' variables ?)
06:34:10 <dmiles> based on the query:   ?-  knows(sue,loves(joe,P)).    % added person/1 
06:35:21 <ski> dmiles : recall the "de re" vs. "de dicto" distinction. you can't move the existential past the modality like that without changing meaning
06:35:26 <dmiles> yeah.. i supposed the anwer might really be ...     P =  some(A, knows(sue,( person(A),loves(joe,A))))
06:35:32 <ski> (so they question then is which meaning did you intend)
06:35:33 <joneshf-laptop> ski, unfortunately `groupBy` also works only with `Query a`. All of these aggregations are defined to only work with `Query a` rather than `QueryArr a b`. Something about invalid sql possibly being generated.
06:36:06 <dmiles> query:  ?-  knows(sue,loves(joe,P)).    % returns    P =  some(A, knows(sue,( person(A),loves(joe,A))))
06:36:07 <ski> joneshf-laptop : then i'm sorry for not being able to give any more useful hunch ..
06:36:21 <joneshf-laptop> ski, no worries, I definitely appreciate it!
06:36:33 <dmiles> (if the systerm had proof at least)
06:37:11 * ski . o O ( <https://en.wikipedia.org/wiki/De_dicto_and_de_re> )
06:37:52 <dmiles> if example if joe had once killed the omly woman he ever loved the result would have come back as     P =  some(A, dead(A), merdered(joe,A), knows(sue,( person(A),loves(joe,A)))).
06:38:59 <dmiles> still anonymnous skolem because we dont actualyl know whom she was
06:39:19 <joneshf-laptop> I feel like my problem is more that I don't understand arrow syntax than anything else.
06:39:24 <Hafydd> dmiles: for example, during ground, rules with an contradiction on their right-hand side are omitted from the output, as in this program:
06:39:33 <Hafydd> p(a). q(X) :- p(X), not p(X).
06:39:41 <joneshf-laptop> Like, I don't know how to apply a value to a function in arrow syntax.
06:39:45 <Hafydd> The ground program for that is just: p(a).
06:39:55 <ski> dmiles : well, it doesn't express the "only" part
06:40:27 <elenh_> www.greekircnet.gr
06:41:24 <ski> dmiles : in the `some [A] ( ...,knows(sue,...) )' case, Sue has someone in particular in mind. in the `knows(sue,some [A] ( ...,...) )' case, Sue doesn't necessarily have someone in particular in mind
06:41:54 <max3> is there a way to get code formatted like the compiler sees it? with braces and ;
06:42:12 <ski> the former is "de re", the latter is "de dicto"
06:42:14 <Hafydd> Or: "p. :- p." is grounded to: "p. :-.".
06:42:46 <Hafydd> And a program containing ":-." has no solutions.
06:44:39 <dmiles> (oh, my assumption.. sorry to keep adding.. is Sue might have assumed he practiced on at least one person yet didnt know he killed her)
06:45:05 * ski isn't sure whether `-ddump-ds' will dump an AST, a parse tree, or concrete syntax
06:45:05 <dmiles> (oh, my assumption.. sorry to keep adding.. is Sue might have assumed he practiced on at least one person (becasue he was a good kisser) yet didnt know he killed her)
06:45:35 <Eduard_Munteanu> max3, try ghc -ddump-parsed
06:45:35 <dmiles> but yeah  knows(sue,some [A]).
06:45:55 <max3> Eduard_Munteanu, no way to do it for just one file?
06:46:00 <Hafydd> But that's not possible for programs like this: "a(x). p(X) :- a(X), not q(X). q(X) :- a(X), not p(X).". That grounds to the same program with X replaced by x everywhere, and its solutions are: "a(x) p(x)" and "a(x) q(x)".
06:46:14 <Eduard_Munteanu> max3, ghc -ddump-parsed foo.hs
06:46:29 <max3> Eduard_Munteanu, it won't try to compile?
06:46:35 <Eduard_Munteanu> It will.
06:46:53 <Eduard_Munteanu> But I think the dumping occurs early enough.
06:47:04 <dmiles> Hafydd: that is awesome ASP stays smart about the negations
06:48:04 <max3> -nope
06:48:09 <max3> Eduard_Munteanu, nope
06:49:14 <ski> (`-E' ?)
06:49:48 <Eduard_Munteanu> max3, try what ski said
06:50:37 <max3> nothing happened?
06:50:40 <ski> Hafydd : how is "solution" defined here ?
06:51:39 <Hafydd> ski: it means an answer set, which is a set of ground propositions consistent with all of the rules and maximal with respect to set inclusion.
06:51:59 <max3> Eduard_Munteanu, where does the dump go?
06:52:07 <max3> ah
06:52:25 <ski> joneshf-laptop : you need to distinguish between ordinarily bound variables, and arrow-bound ones. you can't use one of the latter freely in an application
06:52:29 <Eduard_Munteanu> max3, oh, try this... ghc -c -ddump-parsed module.hs
06:52:48 <Eduard_Munteanu> This works for me.
06:53:23 <ski> Hafydd : and some relevancy condition ?
06:53:24 <max3> it tries to comile
06:53:32 <max3> ah
06:53:34 <max3> okay
06:53:35 <max3> thanks
06:53:50 <Eduard_Munteanu> There should be parser output nevertheless.
06:54:04 <max3> yes
06:54:26 <dmiles> (also btw.. something about an "Answer Set" for each binding iterated out.. we have to assume even if the annonymous woman in my exanple.. this women if she wasnt annonymous (say a ground term) would have to have acted as if she was pysically asserted in the database)
06:54:33 <Hafydd> ski: oh, yes, well, it also has to occur as the ground left-hand side of some rule in the program.
06:54:42 * ski nods
06:55:32 <ski> and the argument terms presumably have to be relevant, drawn from some finite domain presumably, perhaps derived automatically from the program
06:55:54 <joneshf-laptop> ski, what do you mean by "distinguish"?
06:57:52 <dmiles> (so the the shizzy/cool thing i was after is if an anonmous woman could be qualifed as being a ground term .. for the grounded-only phase .. i know this would be an awefull lot to ask!)
06:57:53 <ski> joneshf-laptop : you can't have `proc x -> do y <- f -< x; z <- g y -< (); ...', e.g. -- `y' here is an "internal" variable, can't be used in the arrow expression `g y'
06:58:03 <Hafydd> ski: yes: during grounding, the possible values of the ground terms in the head (the LHS) of each rule is determined by the body.
06:58:28 <ski> mhm
06:58:32 <joneshf-laptop> ski, sure.
06:58:45 <Hafydd> And if that isn't possible, it's an error.
06:59:25 <Hafydd> ("p(X) :- not q(X)."
06:59:29 <joneshf-laptop> ski, that's almost exactly what I'm trying to do.
06:59:32 <Hafydd> is an erroneous program, for example.)
06:59:42 <ski> (well, skolems are in some sense ground .. but i'm not sure what you're thinking of would be a skolem)
07:00:12 <joneshf-laptop> ski, But clearly there's some disconnect. I'm just not sure how to do what I want.
07:00:18 <ski> joneshf-laptop : if there's an `ArrowApply' instance, then there's some alternative syntax (was it `-<<' ?) that can be used)
07:00:39 <ski> joneshf-laptop : perhaps it's an oversight in the coverage of the library
07:00:48 <dmiles> (the reason i call them skolems is in some prolog systems.. the way you make the woman a real entity is to put in a fake "sk1")
07:01:46 <ski> (existential quantifiction in goals, as well as universal quantification in clauses, create logic variables. otoh universal quantification in goals, as well as existential quantification in clauses, creates skolems)
07:02:01 <ski> (.. i'm not quite sure how modalities would interact with this, though)
07:03:32 <dmiles> so assert(some [W] (killed(joe,W),loved(joe,W)). ==> physically might put into the KB:   killed(joe,sk1). loved(joe,sk1). person(sk1). 
07:04:21 <ski> in linear logic, there's a difference between the clause (resource) `{some [X] p(X)}.' ({}/1 being the "of course" modality, related to "necessary", "knows", "believes", "henceforth", "always", &c.) and the clause (resource) `some [X] {p(X)}.'
07:04:43 <joneshf-laptop> ski, wow, that does work. Thanks! I'll see if it's law abiding before actually using it though.
07:05:36 <ski> er, sorry, that should be `all', not `some' (`X' being a logic variable here, not a skolem)
07:05:47 <ski> with the former `?- p(a),p(b).' succeeds. with the latter it doesn't. `?- p(a),p(a).' succeeds with either version, though
07:07:03 <ski> `all [X] {p(X)}.' acts like a partially instantiated clause, that is instantiated (grounded) by the first call. `{all [X] p(X)}.' otoh behaves in the traditional Prolog way, each new call producing a fresh logic variable `X'
07:07:26 * qqwy is back
07:07:30 <qqwy> Hey hey, everyoen
07:07:32 <qqwy> everyone*
07:07:40 <ski> ("of course" allows the program to use the resource as many times as it likes to)
07:07:47 * ski is forward
07:08:25 * qqwy winks cheerfully at ski, although he might see it as `skniw'
07:08:57 <dmiles> "all [X] {p(X)}"  vs  "some [X] {p(X)}"  ... funny i hadnt thought before that some was easier to interpret than all
07:09:00 <qqwy> I am working on implementing https://en.wikipedia.org/wiki/Matrix_chain_multiplication in Haskell.
07:09:12 <qqwy> There is nice pseudocode there, but it is written in a very imperative fashion
07:09:32 <dmiles> 'some' is less work to nterpret than 'all'
07:09:38 <ski> dmiles : i'm sorry, imagine i had written `some' in both these clauses
07:09:47 <ski> *sigh*
07:09:49 <qqwy> I wonder if there are ways to write this in Haskell that either uses tables as well, or uses a different kind of memoization.
07:09:50 <ski> `all'
07:10:26 <ski> dmiles : i agree with your assert/1 and skolem thing
07:10:26 <dmiles> ski: no worries i get things i type backwards more often than you
07:10:37 <qqwy> it might be possible to write something similar using STArrays or something, but those are very much black magic to me
07:11:18 <qqwy> About getting things backwards btw: Snoc lists are interesting creatures
07:11:23 <qqwy> :-)
07:12:35 <ski> "Algebra of Programming" by Richard Bird and Oege de Moor talks about them, iirc
07:13:36 <ski> also mentioning `associativeFoldMap :: (r -> r -> r) -> (a -> r) -> r -> [a] -> r' (where `[a]' is to be interpreted as any representation of a sequence)
07:13:48 <dmiles> so assert(all [P] some [S] (person(P) & soul(S) & hasA(P,S))   physically might put into the KB:   soul(sk2(P)):-person(P). hasA(P,sk2(P)).  
07:14:12 <ski> one might wonder why throw a `map' (the `a -> r' part) into it .. but it makes it easier to do equational reasoning and refactoring
07:14:14 <dmiles> oops  hasA(P,sk2(P)):- person(P).
07:14:23 <c_wraith> ski: how does that differ from foldMap?  Just that it takes the pair of monoidal operations instead of using a Monoid instance?
07:14:44 <ski> (note that `exists a. ([a],a -> r)' (coyoneda) is isomorphic to `[r]')
07:15:31 <ski> c_wraith : yes, possibly associating the sequence in some other way than the obvious
07:16:57 <ski> dmiles : `all [P] ( person(P) => some [S] ( soul(S),has_a(P,S) ) )' ?
07:17:32 <dmiles> yes
07:17:46 <dmiles> becomes:  soul(sk2(P)):-person(P).   hasA(P,sk2(P)):-person(P).    
07:17:55 <ski> i was just thinking that :)
07:18:07 <dmiles>  i often think omitting the Body "person(P)" makes for a faster engine.. 
07:18:25 <dmiles> since the term "sk2(_)."   would still mean:  soul(sk2(_)).  hasA(P,sk2(P)).
07:18:28 <ski> well, it can be considered a matter of type checking .. or partial deduction
07:19:22 * ski would like to see a logic programming system with presuppositions (built-in, preferably)
07:19:23 <dmiles> sk2(_)   <- type checking.. anyhting allowed in  arg1 of sk2.. must be a person
07:20:06 <dmiles> sk2(_) tersm need to fit only into places souls can be
07:20:48 <ski> qqwy : (top-down) dynamic programming can often be done in a nice way by defining an array (or other data structure) recursively
07:20:52 <dmiles> whats neat is that Hafydd says ASP  "expects" that these assumptions would need to be met
07:21:11 <ski> (note, not populating the array by a recursive loop. defining the array itself recursively)
07:21:33 <ski> and i'm talking about immutable arrays
07:21:56 <qqwy> sky: Could you show me an example?
07:22:08 <qqwy> Immutable arrays feel somewhat hard to manage
07:24:04 <ski> > let fibs6 = listArray (0,6) [case n of 0 -> 0; 1 -> 1; _ -> fibs6 ! (n-1) + fibs6 ! (n-2) | n <- range (0,6)] in fibs6
07:24:07 <lambdabot>  array (0,6) [(0,0),(1,1),(2,1),(3,2),(4,3),(5,5),(6,8)]
07:24:48 <ski> @let tabulate :: Ix i => (i,i) -> (i -> e) -> Array i e; tabulate ix f = listArray ix [f i | i <- range ix]
07:24:50 <lambdabot>  Defined.
07:25:14 <ski> > let fibs6 = tabulate (0,6) $ \n -> case n of 0 -> 0; 1 -> 1; _ -> fibs6 ! (n-1) + fibs6 ! (n-2) in fibs6
07:25:16 <lambdabot>  array (0,6) [(0,0),(1,1),(2,1),(3,2),(4,3),(5,5),(6,8)]
07:25:28 <jaseemab`> Heyo! I've been working on a lisp interpreter and just refactored the code to use a monad transformer to manage state and errors. The code looks a bit odd overall. Can someone please take a look at https://github.com/jaseemabid/lisper/blob/master/src/Lisper/Eval.hs and tell me if I'm doing anything fundamentally stupid? 
07:26:32 <ski> @let memoArr :: Ix i => (i,i) -> (i -> e) -> (i -> e); memoArr ix f = (tabulate ix f !)
07:26:35 <lambdabot>  Defined.
07:27:17 <ski> > let (memoArr (0,6) -> fib6) = \n -> case n of 0 -> 0; 1 -> 1; _ -> fib6 (n-1) + fib6 (n-2) in fib6 6
07:27:20 <lambdabot>  8
07:27:24 <jaseemabid`> Very flaky connection here. Just in case anyone wants to share feedback and I get dropped off the IRC, please drop an email at jaseemabid@gmail.com 
07:27:37 <qqwy> What is the final `in fibs6` part for here?
07:27:51 <ski> to evaluate the array
07:28:04 <ski> instead one could pick one or a few elements (e.g. the last one)
07:28:37 <qqwy> Ah, I see
07:28:53 <ski> @let memoArrFix :: Ix i => (i,i) -> ((i -> e) -> (i -> e)) -> (i -> e); memoArr ix ff = fix (memoArr ix . ff)
07:28:55 <lambdabot>  .L.hs:162:1: error:
07:28:55 <lambdabot>      The type signature for ‘memoArrFix’ lacks an accompanying binding
07:29:00 <ski> @let memoArrFix :: Ix i => (i,i) -> ((i -> e) -> (i -> e)) -> (i -> e); memoArrFix ix ff = fix (memoArr ix . ff)
07:29:02 <lambdabot>  Defined.
07:29:08 <jaseemabid`> mauke: /ping. The comments you said a while ago helped. Thanks. 
07:29:57 <ski> > (memoArrFix (0,6) `flip` 6) $ \fib6 n -> case n of 0 -> 0; 1 -> 1; _ -> fib6 (n-1) + fib6 (n-2)
07:30:02 <lambdabot>  8
07:30:46 <qqwy> If you just run this in ghci, it will get progressively slower for the higher numbers, so it seems that it does not memoize (What did I do wrong?)
07:31:07 <qqwy>  
07:31:07 <qqwy> let fibsn n = listArray (0,n) [case k of 0 -> 0; 1 -> 1; _ -> fibsn n ! (k-1) + fibsn n ! (k-2) | k <- range (0,n)]
07:31:19 <ski> qqwy : anyway, it works just as well with a two-dimensional array. it's *top-down* dynamic programming, meaning that there isn't an a priori selected scheduling of in which order to compute the elements. instead it's all demand driven, but results for the subproblems are cached in the array (or other data structure, perhaps an infinite list or something)
07:31:34 <qqwy> @let fibsn n = listArray (0,n) [case k of 0 -> 0; 1 -> 1; _ -> fibsn n !
07:31:34 <qqwy>        (k-1) + fibsn n ! (k-2) | k <- range (0,n)]
07:31:34 <lambdabot>  Parse failed: Parse error in expression: fibsn n !
07:31:45 <ski> qqwy : you need to say `let fibsn n = arr where arr = listArray ...'
07:31:55 <qqwy> @let fibsn n = listArray (0,n) [case k of 0 -> 0; 1 -> 1; _ -> fibsn n ! (k-1) + fibsn n ! (k-2) | k <- range (0,n)]
07:31:59 <lambdabot>  Defined.
07:31:59 <ski> otherwise the recursive calls to `fibsn' will recompute the array
07:32:09 <qqwy> Ah, I see
07:32:21 <ski> (you can use `fix' instead of `where' there, if you prefer)
07:32:46 <ski> the point of `tabulate',&c. above is to make the code look nicer, closer to the non-DP version
07:33:29 <ski> one weakness is that there's no premature GC of values computed in earlier stages, which aren't needed anymore
07:33:54 <ski> all the previous values are kept in this fibonacci example, not just the previous two
07:35:08 <qqwy> So in the case of e.g. Fibonacci, one would use a list instead because you only ever need to access (n-1) and (n02) to build the rest, so accessing the `100`-th element of that list will make sure there are only ever three made, before the oldest of these three is GC'd?
07:35:10 <ski> if you do approximate string search, then you get a two-dimensional array, each element being defined in terms of the three element, to the left, above, and to the left of above
07:35:48 <ski> so we get some kind of fringe moving from the top left corner to the bottom right, which contains the information that's actually needed to progress
07:36:03 <ski> but it's harder to describe this accurately
07:36:45 <qqwy> Yep
07:38:03 <ski> what you're talking about fibonacci i suppose is `fibs = 0 : 1 : zipWith (+) fibs (tail fibs)'
07:38:10 <qqwy> I wrote something that searches for the longest commong subsequence, but works on lists instead of arrays
07:38:12 <qqwy> https://gist.github.com/Qqwy/905736aba1dc0b2d324de69f545b42ea
07:38:14 <qqwy> Yes, indeed
07:41:11 <ski> qqwy : hm, i'd suggest not using `Show' like that ..
07:43:13 <qqwy> ski: It was meant to be a quick and dirty example to show my professor that building such an algorithm on-line was possible, because she wouldn't believe me
07:43:42 <ski> ok. as long as you're aware that `Show' isn't meant for that kind of thing
07:43:47 <ski> "on-line" in which sense ?
07:44:17 <qqwy> In that this algorithm allows you to find the longest common subsequence between two strings while gradually adding more characters to the ends of either string.
07:44:31 <qqwy> It will compute the LCS of the first part of the string before the rest is known
07:45:01 <qqwy> The only thing that 'changes' when you add another character, is that an extra row or column is added to this matrix, and finally the path back to the root might be different.
07:45:02 <ski> ah, so it's incremental
07:45:05 <qqwy> Yes
07:45:19 <qqwy> Is incremental the colloqial term for an algorithm like this?
07:45:46 <ski> probably both terms are in use
07:45:51 <qqwy> I find the term 'on-line' to be somewhat overloaded myself as well... :S
07:45:53 <qqwy> https://en.wikipedia.org/wiki/Online_algorithm
07:46:18 <ski> "incremental" is used to describe `map' e.g., as opposed to `reverse' which is "bulky"
07:46:47 <qqwy> Anyhow, to be sure: Is `Show' only meant to print representations that you can `Read' back in?
07:46:54 <ski> `reverse' produces no output until it has reached the end of the input. `map' produces outputs as soon as it is "passed" input elements
07:47:09 * qqwy nods
07:47:37 <ski> `Show' is foremost meant for debugging purposes. it's sometimes also used as a quick-and-dirty serialization format
07:48:26 <ski> i'd say that i expect `show' to give a string representation of an expression that (in an appropriate environment) evaluates to a value equal to the input value
07:48:51 <ski> and, if there's a `Read' instance, i expect `read (show x) == x = True', for finite `x'
07:49:17 <ski> this, unfortunately, doesn't always hold, even for the standard library
07:49:35 <ski> but it's the ideal i'd like us to strive towards
07:50:08 <ski> a `Show' instance doesn't have to show the internal representation, leaking detail about unexported constructors (abstract data types)
07:50:21 <qqwy> I see :-)
07:50:23 <ski> it could just as well generate an expression in terms of the exported abstract operations
07:50:42 <ski> > listArray (0,2) [True,False,False]
07:50:46 <lambdabot>  array (0,2) [(0,True),(1,False),(2,False)]
07:51:17 <ski> the other things that should be said here are : `Show' instances (and `Read' instances) are meant to work together
07:51:43 <ski> if i get an instance `Show Foo', i automatically get an instance `Show (Maybe Foo)' as well (and similarly for tuples, lists, &c.)
07:52:08 <ski> so if `Show Foo' is using some custom output format, not Haskell syntax, then `Show (Maybe Foo)' will be a strange mixture
07:52:29 <qqwy> If you want to build a humanly readable 'fancy' string output, is there a typeclass in the standard library for that?
07:52:39 <ski> this is the other reason why i'm urging people not to put custom formats in `Show'
07:52:57 <ski> afair, there isn't a standard one for that
07:53:23 <ski> i should also mention that if you're making a custom `Show' instance, you should in almost all cases define `showsPrec', not `shows' or `show'
07:53:51 <qqwy> ! This is the first time I hear about the function `showsPrec'
07:53:51 <ski> and you should use `showParen' (and `showString',`showChar',&c.) to define it
07:54:04 <ski> similarly for `Read' (`readsPrec',`readParen',`lex',&c.)
07:54:57 <ski> `showsPrec' is for communicating to `Show' the current precedence level of the surrounding context, in order to allow it to determine whether it needs to add some extra brackets wrapping or not
07:55:18 <ski>   show x = shows x ""
07:55:25 <ski>   shows = showsPrec 0
07:55:34 <ski> `shows' assumes we start at level `0'
07:55:38 <ski> let's take
07:55:41 <ski> @src Maybe
07:55:41 <lambdabot> data Maybe a = Nothing | Just a
07:55:47 <ski> the derived instance is
07:55:55 <ski>   instance Show a => Show (Maybe a)
07:55:57 <ski>     where
07:56:22 <ski>     showsPrec p  Nothing  = showString "Nothing"
07:56:47 <ski>     showsPrec p (Just a ) = showParen (p > 10)
07:57:03 <ski>                           $ showString "Just "
07:57:17 <ski>                           . showsPrec 11 a
07:57:36 <ski> in the `Nothing' case, we never need to wrap brackets, so no need for `showParen' there
07:58:26 <ski> `10' is the conceptual precedence level of application, which is thought of as an implicit operator inbetween `Just' and `a'. it determines the precedence level of *this* expression `Just a' to be `10'
07:58:39 <ski> is the surrounding level is greater, we add wrapping brackets
08:00:21 <ski> let's take an example with an actual operator
08:00:23 <qqwy> Ah!
08:00:25 <ski> @src Complex
08:00:25 <lambdabot> data (RealFloat a) => Complex a = !a :+ !a
08:00:35 <ski> here we have
08:00:38 <ski>   infix 6 :+
08:00:41 <ski> we get
08:00:57 <ski>   showsPrec p (x :+ y) = showParen (p > 6)
08:01:12 <ski>                        $ showsPrec 7 x
08:01:24 <ski>                        . showString " :+ "
08:01:29 <ski>                        . showsPrec 7 y
08:01:33 <ski> why `7' ?
08:01:49 <ski> well, `:+' is neither left-associative nor right-associative
08:02:10 <ski> so we need to increment the precedence level (`6') for both calls to `showsPrec'
08:02:27 <ski> if `:+' had been left-associative, then we wouldn't have incremented for `x'
08:02:41 <ski> if it had been right-associative, then we wouldn't have incremented for `y'
08:03:44 <ski> since applicative is left-associative, we increment for `a', but conceptually not for `Just'. however that doesn't require a call to `showsPrec', so we don't actually pass `10' on anyway there
08:04:10 <ski> qqwy : the story with `readsPrec' is similar
08:05:38 <ski> s/applicative/application/
08:06:22 <ski> qqwy : for `Read', `lex' is generally used to grab the next token, matching on it
08:06:32 <ski> qqwy : .. i hope what i said makes any sense
08:08:21 <qqwy> Yes, it does
08:08:34 <qqwy> :-)
08:08:53 <qqwy> Parsing is a subject that I know (too?) much about. ^^'
08:11:34 <qqwy> I asked Programmers.StackExchange about the difference between Parser Combinators and Parser Generators once.
08:11:54 <qqwy> And then, since the answers were very sparse and/or opinionated, I decided to do some research myself
08:11:59 <qqwy> And finally I answered my own question
08:12:35 <qqwy> In much detail.
08:12:35 <c_wraith> Isn't the biggest difference that parser combinators are hosted in the language but generators are external tools?
08:12:39 <qqwy> which was then promptly downvoted by someone `because the other answers are shorter' :'|
08:13:44 <qqwy> c_wraith: Sort of. Generators decouple the generation step from the compilation, which indeed means that the language of the generator could be a different one, but the reason they are used historically is because turning a top-down grammar into a bottom-up recursive Finite State Automaton is something you can not easily do manually
08:14:42 <qqwy> Back in the day it was believe that bottom-up parsing was better (faster, more memory efficient, less problems with non-terminating recursion) but nowadays we know that all of these issues can also be resolved in other ways, creating even stronger 'generalized' parsers that even allow to work on ambiguous input grammar.
08:15:28 <qqwy> If you try to optimize for developer efficieny, a parser combinator is definitely the way to go because maintaining a parser generator is a highly specialized field. But of course when 'using' either of these tools, this does not matter much.
08:16:17 <qqwy> Parser Combinators are more flexible in that you can use all the tools of the host language, as well as altering the grammar 'on the fly' (such as reading what tokens are known as 'verbs' from a database) which is impossible when you generate your parser from a grammar beforehand using a parser generator
08:16:23 <qqwy> Something like that
08:16:27 <qqwy> All right, I'll stop now ^^'
08:19:00 <qqwy> Hmm... Translating nested for-loops that alter a 2d-array into a functional program that works on immutable arrays is proving more difficult than I'd like.
08:19:15 <Eduard_Munteanu> Unfortunately it doesn't seem you can derive unparsers from parser combinators, like attribute grammars can.
08:19:52 <qqwy> `unparsers'?
08:20:07 <Eduard_Munteanu> qqwy, printers
08:20:09 <qqwy> (antiparsers? coparsers?)
08:20:15 <qqwy> :-)
08:20:55 <Eduard_Munteanu> And some things are easier done bottom-up.
08:20:55 <qqwy> Really? I'd think that this might be possible if you write your parser combinator properly
08:21:01 <qqwy> That is very true
08:21:01 <ski> qqwy : *nod*, applicative vs. monadic parsers
08:22:55 * ski . o O ( "Applicative vs Monadic build systems" by Neil D. Mitchell (ndm) in 2014-07-23 at <http://neilmitchell.blogspot.se/2014/07/applicative-vs-monadic-build-systems.html> )
08:23:17 * qqwy bookmarked!
09:02:06 <ertes> @let paraOver l = join . l . const
09:02:08 <lambdabot>  Defined.
09:02:25 <ertes> > paraOver _1 (liftA2 (+) (^. _1) (^. _2)) (3, 5)
09:02:29 <lambdabot>  (8,5)
09:04:07 <ertes> (Lens s t a b) instaniated at (f = (->) s) lets one access the original data, which i found useful
09:04:16 <ertes> at least in state monads
09:04:55 <ertes> @let (~+~) = liftA2 (+)
09:04:58 <lambdabot>  Defined.
09:05:09 <ertes> > paraOver _1 (fst ~+~ snd) (3, 5)
09:05:13 <lambdabot>  (8,5)
09:05:38 <ertes> does that exist in the lens library, and i'm just overlooking it?
09:08:40 <ertes> (the inspiration for the name "paraOver" came from paramorphisms)
09:09:06 <kuribas> is there a way to catch exceptions in pure code?
09:09:23 <ertes> kuribas: nope, unless they are explicit (e.g. Maybe)
09:09:50 <kuribas> ertes: neither nothing unsafe?
09:10:20 <ertes> kuribas: well, you could use unsafePerformIO, but you will get into semantics hell very quickly, if you do that
09:10:44 <kuribas> I am now keeping a log, and I would like to see the log when the algorithm hangs...
09:11:03 <ertes> kuribas: what about Debug.Trace?
09:11:28 <kuribas> ertes: I did that before, but I wasn't sure of the order...
09:12:01 <kuribas> but I could write out the log, and reset it every loop...
09:12:08 <kuribas> ok, I'll try this
09:12:35 <ertes> kuribas: if your log is sufficiently lazy, you can print it while the algorithm is running…  one of the rare use cases of (in fact lazy) Writer
09:13:00 <ertes> but if you're going to use a monad anyway, might as well use IO
09:13:12 <kuribas> it's part of my state, which is strict...
09:14:46 <ertes> kuribas: write your algorithm with effect classes and add MonadIO during debugging…  later you can just remove that constraint
09:15:05 <ertes> myAlg :: (MonadState S m, MonadIO m) => A -> B -> m C
09:15:06 <kuribas> right...
09:15:42 <kuribas> is using CPP for that good style?
09:15:46 <ertes> just using MonadState is as good as using a pure state monad, but lets you instantiate freely
09:16:34 <ertes> CPP might get ugly quickly…  however, one slightly overengineered solution would be to create MonadDebug with two instance monads:  Debug and NoDebug
09:16:45 <ertes> class MonadDebug m where debug :: String -> m ()
09:17:05 <ertes> instance (Monad m) => MonadDebug (NoDebugT m)
09:17:11 <ertes> instance (MonadIO m) => MonadDebug (DebugT m)
09:17:25 <kuribas> I hope my algorithm will get specialized to State...
09:17:39 <ertes> myAlg :: (MonadState S m, MonadDebug m) => …
09:18:28 <ertes> well, NoDebug is pretty much IdentityT, so the compiler's result will be a pure state monad
09:19:12 <ertes> StateT s (NoDebugT Identity) a ≃ State s a
09:20:10 <kuribas> ertes: I'd want ghc to optimize the class away though...
09:20:26 <ertes> kuribas: i'm pretty sure it will
09:20:58 <kuribas> right, I'll try this...
09:21:21 <ertes> most likely 'debug' of NoDebugT will be inlined (you can force it to be sure), along with (>>=), which should make both vanish
09:22:20 <ertes> kuribas: actually there is a simpler solution, and CPP might work for that:
09:22:47 <ertes> in the debugging case:  type MonadMyAlg m = (MonadState S m, MonadIO m)
09:22:56 <ertes> debug :: (MonadIO m) => String -> m ()
09:23:13 <ertes> in the non-debugging case:  type MonadMyAlg m = (MonadState S m)
09:23:19 <ertes> debug :: (Monad m) => String -> m ()
09:23:25 <ertes> without a class
09:23:54 <kuribas> ok...
09:36:11 <chilversc> can I make ghci print each item in a list on a separate line?
09:36:34 <c_wraith> sort of.
09:36:35 <Rembane> chilversc: mapM_ print xs
09:37:03 <chilversc> thanks
09:37:04 <c_wraith> that's not really making ghci do it - it's doing it yourself.  But it's short! :)
09:38:05 <Rembane> ghci helpeth those who helpeth themselves.
09:38:44 <chilversc> yeah at first I thought I'd use unlines map show, and gchi helpfully went "1\n2\n3"
09:40:05 <monochrom> putStrLn (unlines map show)
09:40:51 <Tuplanolla> That's two kinds of wrong.
09:42:50 <cocreature> chilversc: unlines is fine, just use putStrLn instead of print
09:43:15 <c_wraith> cocreature: not a lot of beginners realize that ghci uses print
09:43:35 <chilversc> I'm just playing around with exercises from real world haskell at the moment, havn't even got up to i/o yet
09:43:36 <cocreature> yeah I remember being confused about this as well
09:46:13 <tapirus> style question, suppose I have a function that always takes an (unwieldly) number of integers, say a,b,c,d,t,x,y
09:47:23 <tapirus> I could write the type signature as f :: Int -> Int -> Int -> Int -> Int -> Int -> Int -> Double, or I could write it as f :: [Int] -> Double and have f [a,b,c,d,t,x,y] = etc. on the next line
09:47:51 <tapirus> the latter is less unwieldy, but would it be considered stylistically to be a bad choice, because reading the type signature might lead someone to assume that it's a function that works on a variable length array?
09:47:59 <byorgey> tapirus: yes.
09:47:59 <c_wraith> tapirus: is there some relationship between the numbers?
09:48:34 <c_wraith> tapirus: because the best solution is to package the numbers into semantically-meaningful data types 
09:48:36 <byorgey> tapirus: why does the function take so many arguments?  You might consider creating some kind of record or other data structure to hold them all together.
09:49:02 <tapirus> well in this case, I'm computing a t_i which is a function of t_0 and a bunch of parameters (there's actually no x,y in my example, I just added them in to accentuate the point)
09:49:45 <tapirus> but basically the way to go would be to wrap the parameters in some datatype or type synonym?
09:49:52 <byorgey> right, so make a record type   data Parameters = Params { numWidgets :: Int, tolerance :: Int, x :: Int, y :: Int, ... }   and then pass one of those to your function.  Bonus, they now have names.
09:49:58 <tapirus> lovely
09:50:44 <byorgey> you could also perhaps define   defaultParams :: Parameters
09:51:10 <byorgey> and then you can call your function like   f (defaultParams { x = 6 })   to only override the x parameter with a non-default value
09:51:23 <byorgey> I don't know if this makes sense for your function in particular but it can sometimes be a nice approach.
09:53:59 <tapirus> cool :) yeah that makes sense
10:01:00 <ertes> tapirus: if the function is commutative or "linear" in a way, then just listing the arguments the way you did, and even a list, would be fine
10:01:55 <ertes> commutative: the position of each argument doesn't matter at all
10:02:18 <ertes> linear: only the relative positions of the arguments to each other matter, not the absolute position
10:03:53 <marekw2143> hello, why here: https://bitbucket.org/chessRepo/c7/src/87445b8c9b042ea2b816adc7052b869bc4593dd0/main.hs?at=master&fileviewer=file-view-default#main.hs-168 
10:03:59 <marekw2143> I just cannot put "let ... in"
10:04:06 <marekw2143> and have to be "if .. else" ? 
10:04:07 <ertes> tapirus: example: a bezier curve takes four points, and it would be fine to take all of those points as individual arguments (instead of a record type)
10:04:22 <marekw2143> from my knowledge, "let ... in" is an expression , just like "if ... else .. "is
10:04:54 <kuribas> @hoogle exit
10:04:57 <lambdabot> Graphics.UI.GLUT.Initialization exit :: MonadIO m => m ()
10:04:58 <lambdabot> Shelly exit :: Int -> Sh a
10:04:58 <lambdabot> Shelly.Lifted exit :: MonadSh m => Int -> m a
10:05:34 <barrucadu> marekw2143: I don't understand your question.
10:05:39 <lyxia> marekw2143: what exactly would you want to write here
10:06:26 <marekw2143> lyxia, : "let nextBoards = ; nextStates = .. in (if .. else )"
10:06:27 <tapirus> ertes: gotcha :)
10:06:52 <marekw2143> instead of "if .. else (let nextBoards = ; nextStates .. = in (if .. else ) "
10:07:06 <marekw2143> the outer most "if else" seems needed for program to compile 
10:07:30 <lyxia> marekw2143: it's not.
10:07:45 <ertes> marekw2143: you need to indent the 'in', because you're in a do-block
10:08:11 <ertes> marekw2143: but you can also just leave the 'in' out…  do-notation will desugar it appropriately
10:08:35 <ertes> (do let X; Y) = let X in (do Y)
10:09:48 <ertes> marekw2143: do-notation supports 'then' and 'else' unindented for 'if', but does not support unindented 'in' for 'let', because that would be ambiguous
10:10:45 <marekw2143> yyy, so I have to just indent "in" ? 
10:11:08 <ertes> marekw2143: it would probably be stylistically better to just leave it out entirely
10:11:13 <ertes> do let …; if … then … else
10:11:40 <tapirus> ertes: gotcha :)
10:11:43 <tapirus> whoops
10:12:46 <marekw2143> https://bitbucket.org/chessRepo/c7/src/bb78b67f99d08b5802049c564e33a487b767f501/main.hs?at=master&fileviewer=file-view-default#main.hs-171
10:12:56 <marekw2143> now I've removed unwanted "if else"
10:13:54 <ertes> marekw2143: remove line 168 and unindent lines 169-172 by 4 spaces
10:14:05 <marekw2143> it works here: https://bitbucket.org/chessRepo/c7/src/04a029be3c7eb21651d9d49956a0fc27f15c6d74/main.hs?at=master&fileviewer=file-view-default#main.hs-171
10:14:41 <ertes> marekw2143: now remove line 169 and unindent lines 169-172 by 8 spaces =)
10:14:48 <ertes> whoops
10:14:52 <ertes> marekw2143: now remove line 168 and unindent lines 169-172 by 8 spaces =)
10:15:59 <ertes> marekw2143: http://lpaste.net/353430
10:16:29 <marekw2143> ertes, thanks
10:16:39 <marekw2143> works now
10:16:52 <ertes> marekw2143: of course you might as well write:  return (if lastCheckingState state then nextStates else map addNextStates nextStates)
10:17:16 <marekw2143> yep
10:17:23 <monochrom> That may be too lazy.
10:17:39 <marekw2143> the whole "if else" is to add eventually some subtree
10:17:52 <ertes> it's a reader, so it shouldn't matter
10:18:16 <marekw2143> ertes, thanks for pointing out "reader"
10:18:26 <marekw2143> since I'm just wondering whether it's good place to use it there 
10:18:31 <ertes> marekw2143: it's not
10:18:42 <ertes> marekw2143: Reader is just (->)
10:18:57 <marekw2143> ?
10:19:27 <marekw2143> I mean reader monad , so that in 3 lines I'm asking for some "constant" data
10:19:27 <ertes> marekw2143: (Reader e a) is just (e -> a) in disguise
10:19:58 <marekw2143> yes
10:20:04 <ertes> marekw2143: i'd just use a function there
10:20:32 <marekw2143> ok. I've used reader at last from educational pov ;)
10:20:58 <marekw2143> but if reader is not usefull there (seems not usefull as I had to either fmpa functions like in brd <- board <$> ask
10:21:08 <marekw2143> or I've made whoMoves of type REader 
10:21:14 <marekw2143> so where is reader usefull? 
10:21:22 <ertes> marekw2143: here is a nice trick…  you probably know the instance:
10:21:27 <ertes> instance Monad (Reader e)
10:21:40 <ertes> you get exactly the same instance for (->):
10:21:44 <ertes> instance Monad ((->) e)
10:22:25 <ertes> if you change the type signature to (GameState -> [GameState]), it should still work
10:22:48 <ertes> but now 'ask' is just 'id'
10:23:01 <kuribas> ertes: thank, this works great!  I have SweepMonadM = State SweepState or in the debug version SweepMonadM = StateT SweepState IO.  Later I use unsafePerformIO on the state.
10:23:09 <ertes> ask :: Reader e e  -- for Reader
10:23:15 <ertes> ask :: (->) e e  -- for (->)
10:23:17 <monochrom> > (do { x <- cos; y <- sin; return (x :+ y) }) 0.1
10:23:20 <lambdabot>  0.9950041652780258 :+ 9.983341664682815e-2
10:24:48 <ertes> kuribas: yeah, unsafePerformIO has all the sweets
10:25:02 <ertes> it's luring you into semantics hell =)
10:25:08 <kuribas> ertes: and thanks to IO everything is in order...
10:25:08 <marekw2143> btw, (-> e) is just a "function monad" ? 
10:25:23 <kuribas> ertes: this is just for debugging ...
10:25:37 <ertes> marekw2143: if we refer to it as a monad, a common term is just "reader monad"
10:25:46 <monochrom> Debugging is semantics hell. Or semantic hell.
10:25:50 <monochrom> Also:
10:25:56 <monochrom> @quote monochrom debug
10:25:56 <lambdabot> monochrom says: it was fun debugging Debug :)
10:26:06 <ertes> hehe
10:26:26 <marekw2143> ertes, thanks
10:26:26 <ertes> marekw2143: if you want to be precise, just state the type itself
10:26:36 <ertes> "((->) e) monad" is fine
10:26:56 <marekw2143> ((->) e)    - there e is environment 
10:27:15 <ertes> ergument
10:27:39 <monochrom> To be fair, we don't say "the State Int monad" either. We just say "the State monad".
10:27:40 <marekw2143> ergument ? 
10:27:51 <ertes> marekw2143: kidding =)
10:28:04 <ertes> feel free to call it whatever you like…  i just say: "the argument type"
10:28:16 <marekw2143> oik :)
10:28:28 <marekw2143> I've just looked for definition of instance Monad ((-r) r)
10:28:47 <marekw2143> it seems at last similar to instance Reader e monad 
10:28:51 <ertes> marekw2143: it's the same as for Reader, except all the newtype wrapping and unwrapping is gone
10:28:57 <marekw2143> yep
10:29:03 <marekw2143> so where is REader usefull ? 
10:29:24 <monochrom> marekw2143: It seems the source code of GHC.Base has it.
10:29:36 <ertes> marekw2143: some people find ReaderT useful from time to time (FWIW i don't), but Reader is literally useless
10:31:11 <ertes> fun fact:  for ((->) e) both 'ask' and 'asks' are 'id' =)
10:31:31 <monochrom> Reader is useful for Googling and for word-centric people.
10:31:59 <monochrom> "Word-centric people" means they don't understand "1 + 2" but they understand "add one two".
10:32:16 <marekw2143> maybe in MonadTransformers its usefull ? 
10:32:33 <ertes> marekw2143: Reader e = ReaderT e Identity
10:32:47 <ertes> it's usually defined that way, too
10:33:03 <ertes> so it's more of a byproduct of ReaderT
10:33:09 <lyxia> it's only defined for consistency
10:33:45 <ertes> you get Reader, because it's a special case of ReaderT, and because it's conventional to have the Identity special case explicitly defined
10:33:57 <ertes> type State s = StateT s Identity
10:54:07 <qqwy> Hey guys
10:54:29 <qqwy> After a lot of fiddling, I was able to translate the imperative algorithm of calculating the optimal chaining in a matrix multiplication
10:54:40 <qqwy> but my resulting program still is very slow
10:54:46 <qqwy> I wonder how it could be made more efficient
10:54:49 <qqwy> https://gist.github.com/Qqwy/2ac3ef54c914d096803318e77fe637a1
10:54:53 <Rembane> qqwy: Have you profiled it?
10:55:12 <qqwy> This implements this pseudocode: https://en.wikipedia.org/wiki/Matrix_chain_multiplication
10:55:25 <qqwy> (And yes, the naming for the different subfunctions is still rather bad)
10:56:18 <qqwy> I have not yes profiled it manually. I will do so as well, but I was wondering if there are any naïve things I am doing here that might 'jump out' to you experts.
10:56:54 <Rembane> qqwy: Hard to say, things that seem slow when you look at them could be fast after run through GHC.
10:57:08 <Rembane> qqwy: And vice versa.
10:58:10 <qqwy> Very true
11:04:55 <qqwy> Holy hell... if I try to run my program on a large-ish input, it swiftly eats more than 2 GB RAM
11:04:58 <qqwy> O.O
11:07:26 <thoughtpolice> glguy: Have you ever thought about supporting comments in something like the language-lua parse tree? (I would have filed a GH issue but your fork does not have issue tracking enabled.) My motivation is I'd like to use it for a simple tool to parse comments and generate some docs.
11:07:48 <thoughtpolice> Maybe just hand-rolling something would be easier for this specific case, since I don't think I care about much more than that (for this, at least)
11:08:31 <Sornaensis> qqwy: define large-ish
11:08:46 <Sornaensis> are you doing string operations?
11:09:39 <glguy> thoughpolice: I'll have to fix the issue tracker. I haven't thought about it, but it might be worth exploring
11:09:56 <qqwy> large-ish means reading 400 input dimensions
11:10:13 <qqwy> i.e. calling computeMinimalMatrixChain with a list of 400 Ints
11:10:53 <Sornaensis> neat, how much memory would you expect that to use
11:11:22 <ertes> ok, paraOver seems redundant
11:11:58 <ertes> @let paraFst f xy' = (\x -> (x, snd xy')) <$> f xy'
11:12:01 <lambdabot>  Defined.
11:12:19 <ertes> > over paraFst (fst ~+~ snd) (3, 5)
11:12:22 <lambdabot>  (8,5)
11:12:55 <qqwy> The algorithm is supposed to run in O(n²) memory usage
11:13:46 <qqwy> so I'd expect +- 400*400 ints = 160000 ints
11:13:56 <thoughtpolice> glguy: OK, cool. Yes, I'm not exactly sure what it would look like in the parse tree, but fundamentally I "only" need to basically A) Find function defns in a module and B) look at the comment prior to that decl. I'm not sure if I'll have time to take a go at this soon but I can file an issue so nobody forgets.
11:14:05 <ertes> although one advantage of paraFst is that it doesn't require special para-lenses
11:14:08 <qqwy> which would be 10.2 megabytes
11:14:13 <ertes> s/paraFst/paraOver/
11:14:15 <thoughtpolice> glguy: (I might want the full parser in another tool, which is just a linter, and I don't care about comments for that. Only just for this thing)
11:14:26 <MarcelineVQ> ertes: how do you guys remember all these symbols and names :>
11:15:06 <ertes> MarcelineVQ: which ones tripped you up?  i think i used fairly standard terminology
11:15:57 <ertes> (~+~) i just defined as (liftA2 (+)) earlier =)
11:17:02 <ertes> i would have used (<+>), but that one is already wasted for ArrowPlus
11:17:26 <qqwy> Hmm
11:17:58 <qqwy> It seems that rewriting the list comprehension to `map` did the trick, and made the program use more than 50 times less memory, as well as resulting in a huge speed boost
11:17:59 <qqwy> o.o
11:18:26 <MarcelineVQ> ertes: Normal case of coming in late to a convo and trying to be funny, I'll scroll up and do some learning :>
11:18:39 <ertes> ah =)
11:19:05 <ertes> well, lens is…
11:19:07 <ertes> :t confusing
11:19:10 <lambdabot> Applicative f => LensLike (Data.Functor.Day.Curried.Curried (Data.Functor.Yoneda.Yoneda f) (Data.Functor.Yoneda.Yoneda f)) s t a b -> LensLike f s t a b
11:19:13 <barrucadu> qqwy: Probably when you used the explicit "map" some rewrite rules fired which you missed out on before, which allowed much better optimisation: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#rewrite-rules
11:19:42 <Sornaensis> are list comprehensions ever useful
11:20:11 <barrucadu> Sornaensis: I think they can be easier to read if you're doing a couple of maps and filters in one go
11:20:31 <cocreature> Sornaensis: depends on how you define “useful”. they don’t provide anything that you can’t write otherwise but the syntax can be more readable in some cases
11:20:37 <Sornaensis> easier than do notation?
11:20:48 <ertes> > [ x + y | x' <- [0..10], let x = x^2, guard (x /= x'), y <- [x..10] ]
11:20:52 <lambdabot>  error:
11:20:52 <lambdabot>      • Couldn't match expected type ‘Bool’ with actual type ‘f0 ()’
11:20:52 <lambdabot>      • In the expression: guard (x /= x')
11:20:54 <ertes> whoops
11:20:57 <ertes> > [ x + y | x' <- [0..10], let x = x^2, x /= x', y <- [x..10] ]
11:21:03 <lambdabot>  mueval-core: Time limit exceeded
11:21:13 <ertes> > [ x + y | x' <- [0..10], let x = x'^2, x /= x', y <- [x..10] ]
11:21:16 <lambdabot>  [8,9,10,11,12,13,14,18,19]
11:21:37 <ertes> Sornaensis: sometimes it's just more concise and saves you from having to import Control.Monad
11:22:21 <ertes> > do x' <- [0..10]; let { x = x'^2 }; guard (x /= x'); y <- [x..10]; pure (x + y)
11:22:25 <lambdabot>  [8,9,10,11,12,13,14,18,19]
11:22:43 <barrucadu> I find do-notation for lists more confusing, but that's because I never use it, so I always do a double-take when I see it.
11:23:22 <ertes> if 'guard' were in Prelude, i'd probably never use list comprehensions
11:24:25 <ertes> the set-notation style is a bit awkward, because you have to read the definition part in order and then jump to the result part…  with do-notation it's top-down all the way
11:43:28 <pavonia> When you have a lots of data types each with parsers and pretty-printers, is it more common to have three modules Types, Parsers and Printers; or to have a lot of small modules for each type with its corresponding printers and parsers in it?
11:43:51 <pavonia> Or perhaps something third
11:44:50 <hpc> i like writing one ADT per modul and naming it something like AbstractParserFactory ;)
11:45:07 <hpc> but usually the first one, if you have things that parsers and printers will both depend on
11:45:20 <hpc> because you need something that both of them can import without making a cyclic dependency
11:48:16 <pavonia> Is that AbstractParserFactory a thing in Haskell?
11:49:30 <geekosaur> not usually except as a joke
11:50:04 <tdammers> you could also say it's a thing, but nobody bothers naming it because it's trivial
12:00:52 <Tuplanolla> "What's this design pattern called?" "It's a function."
12:01:26 <geekosaur> .oO { bengloarafurd ford }
12:03:41 <Rotaerk> wat?
12:03:48 <mac10688> Anyone good with reactive-banana? I feel like it's an easy concept until I start reading the docs.
12:04:03 <hseg> Hi. I'm trying to create an infix constructor, and the report is a bit unclear on what characters are valid there. Am I parsing it correctly as being : followed by any Unicode symbol or punctuation except an enumerated list of symbols and an enumerated list of operators?
12:04:49 <qqwy> hseg: Anything that would make a valid infix operator in Haskell would also be a valid infix constructor, IIRC
12:04:58 <hpc> an infix constructor is something that follows the rules of any other infix operator, with a "capital symbol" at the front
12:05:09 <hpc> much like regular constructors are identifiers that are capitalized
12:05:16 <hpc> the only "capital symbol" is ':'
12:05:31 <qqwy> This list might help: http://stackoverflow.com/questions/10548170/what-characters-are-permitted-for-haskell-operators
12:08:14 <hseg> Thanks. I suppose letterlike codepoints are forbidden in symbols, then?
12:08:49 <qqwy> Yes, I believe so
12:09:49 <hseg> Too bad. I wanted to abuse syntax and write :+i√2 for the constructor of Q(i√2)
12:09:51 <ertes> mac10688: what's your question?
12:09:56 <hseg> Eh. Was a hack anyway
12:10:15 <MarcelineVQ> @let data Foo a b = a `Foo` b
12:10:18 <lambdabot>  Defined.
12:10:22 <monochrom> Well, the "2" will also get into the way.
12:10:23 <hseg> That works.
12:10:26 <hseg> Yup
12:10:29 <mac10688> ertes, I want to program the game of life but I'm trying to figure out how to do it with frp. Where each tick of the second will send an event
12:11:00 <mac10688> ertes, 1. how do I wire up a tick of a second to send an event 2. How do I wire up listeners to the event?
12:11:04 <hseg> However, MarcelineVQ's solution would work - define a conid infix
12:11:31 <ertes> mac10688: well, GoL is a rather boring use case for FRP, because it's essentially just an accumE
12:12:10 <ertes> mac10688: r-b is split into two interfaces:  an application interface and a framework interface
12:12:30 <ertes> mac10688: if you use r-b directly, you write both an application and the framework that binds the application to the real world
12:12:46 <ertes> the latter is the interface you find in Reactive.Banana.Frameworks
12:13:32 <ertes> mac10688: there are a number of ways to create a root event (one that isn't derived from other events/behaviours, but is actually a real-world thing)
12:13:48 <ertes> so much for that…
12:14:25 <mac10688> ertes, I'm sorry, my computer crashed after you said gol would be a boring example and to just use accume
12:14:41 <mac10688> I'm ok with a boring example though, I just want to use a small example to see how it works
12:15:00 <ertes> mac10688: r-b is split into two interfaces:  an application interface and a framework interface…  if you use r-b directly, you write both an application and the framework that binds the application to the real world…  the latter is the interface you find in Reactive.Banana.Frameworks
12:15:18 <ertes> mac10688: there are a number of ways to create a root event (one that isn't derived from other events/behaviours, but is actually a real-world thing)
12:15:57 <ertes> mac10688: the most common and generally recommended way for r-b is fromAddHandler, which also indicates that r-b is mostly meant to bind to callback-based UI libraries
12:16:04 <MarcelineVQ> hseg: note that the defintion notation doesn't have an impact in this case.   a `Foo` b   is just  Foo a b  in the same way as map f x is   f`map`x  You can define it as data Foo a b = Foo a b   and at the use site say   'c' `Foo` 3  if you like  or  Foo 'c' 3
12:16:45 <mac10688> yeah I've seen those fromAddHandler functions, but I have trouble wrapping my head around them
12:17:13 <ertes> mac10688: do you understand the AddHandler type?
12:17:46 <mac10688> not really. I see the register function, that takes a Handler type and gives back an IO (IO ())
12:18:51 <ertes> mac10688: let's say your application is basically just an infinite loop
12:19:01 <mac10688> ok
12:19:23 <ertes> but at each iteration an event occurs, like a "tick" event…  feel free to add a threadDelay to that loop to get some loose control over timing
12:19:44 <ertes> mac10688: i suggest that we move this into #haskell-game, otherwise we drown everything else =)
12:20:20 <hseg> MarcelineVQ: Sure. Although I note that the precedence is not what I expected, as e.g. 2*3 `Foo` 3+5 parses as (2*(3`Foo` 3))+5, not (2*3) `Foo` (3+5)
12:20:28 <mac10688> ok ertes 
12:20:45 <hseg> At least, GHC complains according to the former parse, and entering the latter parse explicitly causes it to shut up
12:21:50 <MarcelineVQ> hseg: it has function precedence, which iirc is  infixl 9 when infix,   you can define a precedence you prefer with a line like   infixr 3 `Foo`
12:22:20 <MarcelineVQ> e.g in ghci    data Foo a b = a `Foo` b; infixr 3 `Foo`
12:23:07 <hseg> MarcelineVQ: Sorry, missed everything since my comment about getting GHC to shut up.
12:23:23 <MarcelineVQ> hseg: it has function precedence, which iirc is  infixl 9 when infix,   you can define a precedence you prefer with a line like   infixr 3 `Foo`   e.g in ghci    data Foo a b = a `Foo` b; infixr 3 `Foo`
12:24:41 <MarcelineVQ> also I think I​ didn't see a line about ghc being noisy
12:24:47 <MarcelineVQ> oh there it is, I'm just blind
12:24:58 <hseg> Ah. Yeah looks like fixity 5 should do the trick.
12:25:57 <hseg> Although looking at the fixity table for the Prelude, it looks a bit odd that the fixities for operators in two different domains would be comparable.
12:27:08 <hseg> Wouldn't it make more sense to be able to define a fixity class (e.g. Arith, List, Ord, Bool), define the ordering between operators within a class, then define the ordering between classes?
12:27:29 <hseg> (I'm probably overengineering this, and should just get used to it)
12:27:41 <MarcelineVQ> I don't know much about that, in general ( ) are straightforward enough that sounds like a bit much though
12:28:24 <MarcelineVQ> If it bothers you it's worth exploring though, that's how we get new things :>
12:28:35 <hseg> :)
12:29:02 <hseg> Will put it on my weekend project list.
12:29:35 <hseg> Reason why this annoys me now - there is no way to make something bind more tightly than : but less than +.
12:30:23 <benzrf> time for rational fixity
12:30:24 <MarcelineVQ> Did you make a Num instance for lists?
12:30:25 <benzrf> :>
12:30:59 <hseg> So if I were to e.g. reimplement Complex, there is no way to write a + b :+ c + d : a :+ b : [] with parse ((a+b) :+ (c+d)) : (a :+ b) : []
12:31:41 <hseg> No, I didn't make a Num instance for lists, but I am potentially consing complex expressions onto them
12:31:51 <qqwy> Interesting. When replacing the boxed arrays with unboxed arrays, my program compiles without problem, but when run it returns `programname: <<loop>>`
12:32:30 <qqwy> So it seems that the array is made in order, and that this is stricter than my algorithm requires. But I am curious as to how/why it prints `<<loop>>`
12:32:34 <hseg> benzrf: That's a solution in a direction that's less flexible, and IMHO less Haskelly than what I suggested. Then again, I'm no authority.
12:32:53 <benzrf> i was being facetious :)
12:32:55 <MarcelineVQ> hmm, in the mean time maybe you can redefine the fixity for :+ for your module
12:33:09 <hseg> Yeah, I did. infix 3.
12:33:24 <hseg> For the moment, I don't have list code, so it's not biting me yet.
12:37:21 <michalrus> glguy: hey, just writing to thank you for that suggestion with `data T a b = MkT (a -> (b, T a b))`, I took this route for my “list of functions with state”. But I’ve also got a question… I remember you suggested `data T a b = MkT (a -> (b, a -> T a b))`—why the additional `a ->` if `T a b` already encodes a function from `a`? I implemented the first version and it seems to work well. :)
12:38:52 <cgag> trying to build ghc and running into make[1]: *** No rule to make target '/opt/ghc/8.0.2/libinclude/Rts.h', needed by 'compiler/stage1/build/ghci/keepCAFsForGHCi.o'.  Stop.
12:39:05 <cgag> from the ghc-8.0.2 source distribution
12:39:10 <cgag> anyone dealt with that?
12:41:00 <cgag> alternitavely, anyone have a workaround for this: "unable to decommit memory: Invalid argument"? I'm pretty sure it's from running a container with ghc built on a recent kernel, but running on 4.4.  Currently attempting to build ghc and everything myself but would be happy to not need to.
12:41:31 <geekosaur> shouldn't it be recovering from that and using a backup method?
12:41:52 <geekosaur> (I don't think you can currently force an x86-64 ghc to use the old allocator)
12:44:44 <ski> michalrus : synchronous stream processor is one name for that, btw
12:47:35 <geekosaur> cgag, if you don;t get an answer here, you can try in #ghc
12:47:47 <MarcelineVQ> cgag: what are your build steps after extracting from the source archive?
12:50:21 <cgag> MarcelineVQ: ./boot && ./configure && make
12:51:15 <michalrus> ski: thank you, I’ll Google™ that. (:
12:51:53 <ski> you could also compare with "transducer"
12:51:56 <MarcelineVQ> if you're using the source distro you shouldn't need to do ./boot  idk if that matters though
12:52:37 <cgag> yeah i wans't doing that initially but i thew it in after failing
12:52:51 <cgag> geekosaur: i'll drop this in #ghc, thanks
12:52:55 <MarcelineVQ> alrighty, I'd ask in #ghc then
12:53:03 <michalrus> Mhm. :)
12:53:18 <MarcelineVQ> be sure to mention your OS and arch
12:53:58 <MarcelineVQ> and where you're getting the source from, such as http://downloads.haskell.org/~ghc/8.0.2/ghc-8.0.2-src.tar.xz
12:55:24 <cgag> will do, thanks
13:23:10 <lpaste_> hseg pasted “Program loops. Why?” at http://lpaste.net/353434
13:23:23 <hseg> For some reason, this code snippet loops.
13:23:28 <qqwy> Ah!
13:23:36 <qqwy> Using STArrays is actually really easy :o
13:23:50 <qqwy>  
13:23:50 <qqwy> matrixChainOrder :: UArray Int Int -> Int -> UArray (Int, Int) Int
13:23:50 <qqwy> matrixChainOrder dims n = runST $ do
13:23:50 <qqwy>   memo <- newArray ((1,1),(n,n)) 0 :: ST s (STUArray s (Int, Int) Int)
13:23:53 <qqwy>   forM_ [1..n] $ \i -> do
13:23:56 <qqwy>     writeArray memo (i,i) 0
13:23:58 <qqwy>   forM_ [2..n] $ \l -> do
13:24:01 <qqwy>     forM_ [1..(n-l+1)] $ \i -> do
13:24:04 <qqwy>       let j = i + l - 1
13:24:12 <Tuplanolla> Nice.
13:24:12 <hseg> Don't see why - it should have a call pprint twice when on each element of x.
13:24:58 <hseg> *it should call pprint*
13:25:36 <Tuplanolla> Add parentheses to your `if`, hseg.
13:26:08 <hseg> Oh? How is it parsing it, then?
13:26:26 <Tuplanolla> I'm not sure if it works the way you intend, but it looks a bit suspicious.
13:26:37 <Tuplanolla> The `else` part spans to the end.
13:27:19 <hseg> Yes... Intention is to pprint the a part, then if b is nonzero pprint the b part.
13:27:52 <hsk3> What is blaze-react https://www.youtube.com/watch?v=4nTnC0t7pzY
13:27:53 <hsk3> and how does it compare to reflex? https://www.youtube.com/watch?v=92eXGvHFbzs
13:27:54 <hsk3> O notice both rely on GHCJS.
13:28:04 <hsk3> s/O/I
13:29:02 <Tuplanolla> I don't see the problem then. That would require more focus.
13:31:35 <hexagoxel> hseg: a*c-2*b*d `ISqrt2` b*d  ===  a*c-2*b*(d `ISqrt2` b)*d
13:32:29 <hexagoxel> nevermind, you have infix 3..
13:32:29 <hseg> Oh? Shouldn't my infix 3 `ISqrt2` declaration have fixed that?
13:32:39 <MarcelineVQ> ehehe
13:32:50 <MarcelineVQ> negate x = -1 * x
13:32:52 <hseg> I suspect it's the fromInteger implementation that's at fault.
13:33:12 <hseg> Well... *blushes*
13:33:29 <hexagoxel> hseg: just pepper trace statements everywhere, and see what gets spammed
13:34:15 <MarcelineVQ> my laugh is how my ide handle that line, not about the line itself
13:34:28 <hseg> Oh?
13:35:27 <MarcelineVQ> yeah it thinks you meant x as in x :: [QiSqrt2]   it's not somehting that actually seems to matter though, just an oddity with the ide since it compiles. Howver I noticed it sticks on the first negative number and negate uses * so I'd be looking at negate and *
13:36:20 <hseg> MarcelineVQ: You are correct, removing the -1 terms causes the program to stop looping.
13:36:30 <Tuplanolla> Is it that `-1 * x` turns into `negate (fromIntegral 1 * x)`?
13:38:07 <hseg> .... That's probably it. Replacing it by (fromInteger (-1)) * x works
13:38:33 <monochrom> Hmm that's strange.
13:38:57 <hseg> That's because I defined     fromInteger = (`ISqrt2` fromInteger 0) . fromInteger
13:39:21 <hseg> So there's only recursion into the Num Ratio instance.
13:39:30 <Tuplanolla> More reasons to use `NegativeLiterals`.
13:39:40 <hseg> NegativeLiterals?
13:42:04 <MarcelineVQ> hseg: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#negative-literals
13:42:50 <zenware> If I was going to give a lecture on some property or feature of Haskell, to a technical audience, what would this crowd recommend I get them excited about?
13:43:04 <hseg> Yup, NegativeLiterals + writing spaces before differences makes this work.
13:43:39 <hseg> NegativeLiterals seems useful, with small cost.
13:46:44 <monochrom> Interesting, -1*x is read as -(1*x) therefore negate(1*x)
13:47:11 <hseg> WTF? Moral of this story: Don't use negative literals?
13:48:03 <geekosaur> safest to parenthesize them always
13:48:03 <monochrom> I am still looking into the Haskell 2010 Report for why this happens :)
13:48:12 <int-e> you can write  fromInteger (-1) * x ...
13:48:38 <geekosaur> because unary - does not have its own precedence, it uses the precedence of infix (-)
13:48:39 <int-e> there are no negative literals in that grammar/tokenizer.
13:48:57 <geekosaur> so it's lower precedence than the (*)
13:49:25 <monochrom> Yeah, even (-1)*x becomes just negate(fromInteger 1)*x, all using your Num methods.
13:49:42 <int-e> I mean, even (-1)*x will be (negate (fromInteger 1)) * x, which is silly
13:50:00 <int-e> (hmm, that stereo effect)
13:50:03 <hseg> Which is why NegativeLiterals was recommended.
13:52:25 <hseg> ... And suddenly I realize I made a computational error and didn't need to be able to calculate over Q(sqrt(-2))
13:52:26 <monochrom> OK, two rules from the Haskell Report: "infixexp -> lexp qop infixexp | - infixexp | lexp", and "unary - will always refer to the negate function defined in the Prelude"
13:53:09 <int-e> okay, I checked that with NegativeLiterals you actually get  fromInteger (-1) * x from -1*x. sweet.
13:54:01 <int-e> but not from - 1 * x, so it's whitespace sensitive.
13:54:01 <monochrom> So unary - at the beginning is going to bind more loosely than infix operators. And then it's translated to a negate call.
13:54:22 <hseg> Yeah, makes much more sense. Of course, it simultaneously forbids x-1 (parses as x (-1))
13:54:31 <int-e> and in fact, - -1 * x becomes a valid expression
13:54:48 <ertes> you could just use 'negate'
13:54:54 <monochrom> Well yeah, even with NegativeLiterals, first you have to get past the tokenizer. Tokenizer is not going to declare "-        1" as "one token" at a whim.
13:54:57 <hseg> int-e: What do -1 * x and - -1 * x parse to?
13:55:39 <int-e> hseg: with NegativeLiterals they get desugared to fromInteger (-1) * x and negate (fromInteger (-1) * x), respectively.
13:56:16 <hseg> Oh. That's the parses I expected, but not what I interpreted your statements as saying.
13:56:38 <monochrom> Isn't it exciting to be a language lawyer? :)
13:58:36 <monochrom> Oh oops, the grammar rule does not dictate looser or tighter binding. The extra clause "Prefix negation has the same precedence as the infix operator - defined in the Prelude" does.
13:58:58 <hseg> monochrom: Alas, 'tis our curse as programmers. Our interlocutors don't handle ambiguity well.
13:59:36 <monochrom> We need a Supreme Court ruling!  <duck>
14:01:09 <nut> Im using emacs, how can i list the defitions(data and functions etc) in the current buffer ?
14:01:23 <nut> and then helm goto it
14:01:33 <romanandreg> So, I've been following tips from this blogpost to get fancier outputs from GHCi (http://teh.id.au/posts/2017/02/13/interactive-print/index.html), but I would like to know how to handle package dependencies required for this features without including them in my project's cabal file (using stack)
14:01:38 <romanandreg> any pointers?
14:03:35 <romanandreg> or, if having it in my project's cabal file, having a way to point them as development dependencies (leiningen style)
14:16:54 <romanandreg> ok, by doing `:set -package show-pretty` I was able to make it work on the repl without explicit dependency on the cabal project
14:17:50 <Tuplanolla> Does it persist over module reloads, romanandreg?
14:17:57 <romanandreg> let me check
14:18:29 <romanandreg> Tuplanolla: no it doesn't seem to –_–'
14:18:52 <Tuplanolla> I'll keep avoiding this problem then.
14:19:17 <romanandreg> I guess everytime I want pretty printing I will have to execute a command
14:19:20 <romanandreg> this seems
14:19:21 <romanandreg> annoying
14:23:21 <lyxia> stack ghci --ghci-options "-package show-pretty"
14:24:23 <lyxia> or use a .ghci file
14:47:02 <MarcelineVQ> "<lyxia> stack ghci --ghci-options "-package show-pretty"" shorthand:  stack ghci --package show-pretty
15:05:52 <Bocemb> Hi there! I've got a performance question. I define a standard list data type: (data List a = Nil | Cons a (List a) deriving Foldable) but it appears to be 8 times slower than built-in lists when doing something like length [1..1000000]. Are built-in lists treated specially? Is there a way to get closer to build-in lists using a custom list data type? Thanks!
15:07:19 <Bocemb> To be more specific, here is how I build the lists: build k = case k of { 0 -> Nil; k -> Cons k (m $ k - 1)} and the same code for build-in lists but using [] and (:) instead of Nil and Cons
15:07:25 <Eduard_Munteanu> Bocemb, there are rewrite rules for builtin lists which may reduce the overhead (sometimes there isn't even a list to begin with)
15:08:06 <geekosaur> Bocemb, there is a *lot* of rewriting done for the builtins. you can dig them out of the ghc source and reproduce them for your type, but that will be annoying and painful (as will examining the Core and trying to reinvent them)
15:08:25 <Bocemb> Eduard_Munteanu: I see, thank you
15:08:49 <Bocemb> geekosaur: Right, thank you too
15:08:57 <Bocemb> I was just unsure whether I'm doing something wrong
15:09:03 <Eduard_Munteanu> Also see... https://hackage.haskell.org/package/stream-fusion-0.1.2.5/docs/Data-List-Stream.html
15:09:17 <geekosaur> ghc attempts to fuse list operations into streams, and if it does so fully then the whole list can disappear as Eduard_Munteanu said
15:09:36 <geekosaur> just a generate ==> process ==> output stream pipeline
15:10:02 <Bocemb> I see. I was hoping some kind of fusion can also happen with simple data types like List
15:10:15 <Bocemb> (automatically with -O2)
15:10:30 <Eduard_Munteanu> It is kinda sad it doesn't work with generic traversals.
15:11:21 <geekosaur> there's a little of that, but mostly ghc depends on rewrite rules
15:11:31 <Eduard_Munteanu> It might make sense for List, Stream and perhaps some trees, not sure about others.
15:11:43 <geekosaur> ^
15:11:56 <geekosaur> there's only so much you can do without altering strictness etc.
15:12:38 <Bocemb> OK, thanks. I'll look into rewrite rules. My actual data type is quite similar to tree and I was wondering how come my implementation is so slow compared to lists :-) It's clear now
15:16:03 <Eduard_Munteanu> For stream processing, conduits may be of interest to you.
15:17:10 <Bocemb> Eduard_Munteanu: it's more of a container data structure, but in this particular benchmark I'm consuming it in a stream fashion
15:17:44 <Bocemb> (although, presumably all containers are supposed to be consumed by some folds)
15:21:21 <hexagoxel> does the import-Prelude-last trick to avoid warnings not work when it has "hiding.." stuff?
15:25:11 <tnks> when edwardk says "Yoneda f is in some sense smaller than Codensity f" what exactly is the best way to formalize "bigger"?
15:25:33 <tnks> I always I feel I'm inferring what's meant, and worry that I'm imprecise/incorrect.
15:27:26 <tnks> actually, I think it's just about a homomorphism, and not an isomorphism.
15:30:46 <johnw> tnks: I think it's like the fact that Free f a is bigger than f a, because there are values of Free f a you can distinguish between that are indistinguishable when reduced to their mutually equivalent f a
15:31:12 <johnw> so to prove what he said about Yoneda and Codensity, you'd just need to find two such Codensity constructions
15:31:47 <johnw> ah
15:32:17 <johnw> it's because Yoneda f a is isomorphic to f a, and hence bijective, while Codensity f a is larger than f a, and hence surjective
15:32:47 <tnks> johnw: okay, this is all jiving with what my intuition is.
15:55:27 <ski> `Yoneda f a' isn't iso to `f a', for any old `f'. only for functors `f'
15:55:40 <ski> (likewise with `Coyoneda f a' vs. `f a')
15:56:05 <ski> `Yoneda' can be thought of as some kind of interior, while `Coyoneda' would then be closure
15:57:29 <ski> (specifically, upper interior resp. upper closure)
15:58:09 <ski> we can go `Yoneda f >---> f', for any `f', and also `f >---> Coyoneda f', for any `f'
15:58:27 <ski> to go in the other directions, we need `f' to be a functor
15:58:54 <ski> i suspect this is more or less what edwardk meant by that "Yoneda f is in some sense smaller than Codensity f"
15:59:14 <ski> tnks,johnw ^
16:10:12 <tnks> ski: actually, I was just thinking about the Functor constraint.
16:10:28 <tnks> but the good part is that our vocabulary of what it means to be "bigger" is consistent.
16:19:25 <johnw> ski: I meant functor, but forgot to say it
16:20:18 <johnw> ski: to quote the Kmett reference in question: "Note, Yoneda f is in some sense smaller than Codensity f, as Codensity f a is somewhat 'bigger' than f a, despite providing an embedding, while Yoneda f a is isomorphic."
16:20:23 <johnw> from http://comonad.com/reader/2011/free-monads-for-less-2/
16:22:57 * ski realizes they're tired enough to read `Coyoneda' when `Codensity' was said
16:23:45 <johnw> I'm tired too
16:23:50 <johnw> and avoiding a paper I must be writing
17:46:17 <Myrl-saki> Building Cabal in a 512 MB droplet is like witnessing a crime scene.
17:46:37 <Myrl-saki>  Mem[||||||||||||||||||||||||||||||||||||||||436M/493M]
17:46:39 <Myrl-saki>  Swp[||||||||||||||||||||||||||||||         939M/1.50G]
17:52:20 <jvliwanag> when using  with a writer monad, which data structure is best to use for just storing a log of events? esp when most most of the writes are just single element entries. are lists good enough?
17:53:53 <lyxia> use state and put them in a list.
17:57:03 <jvliwanag> ah. is that better? use state and just cons to that list as needed instead of using the writer monad?
18:03:30 <johnw> jvliwanag: http://comments.gmane.org/gmane.comp.lang.haskell.libraries/18980
18:04:10 <ezyang> ahoy haskell, for a data type intended to represent indexes into arrays, do you like Index/Size/SizeT/Pos/Position/what? 
18:04:41 <johnw> yes
18:04:48 <Myrl-saki> ezyang: A typeclass.
18:04:52 <johnw> there's also Offset
18:05:12 <ezyang> I need to pick only one name :) 
18:05:59 <johnw> how would you say it in English?
18:06:11 <johnw> "As you see, we have this gigantic array, and at _____ 113, we find the value X."
18:06:20 <ezyang> index 
18:06:28 <ezyang> ...offset? 
18:06:30 <ezyang> haha 
18:06:32 <johnw> position!
18:06:33 <johnw> haha
18:06:35 <johnw> i don't know either
18:06:42 <johnw> ask someone who hasn't heard the question yet
18:07:11 <Myrl-saki> johnw: index.
18:07:34 <Myrl-saki> Offset is relative.
18:07:41 <Myrl-saki> While index is locally absolute.
18:07:43 <Myrl-saki> If that makes sense.
18:07:53 <ezyang> yes it's true 
18:10:09 <johnw> good point
18:10:15 <johnw> I'd say Index then
18:10:38 <barrucadu> When I have such a variable, I typically call it "idx". Index is a good name for the type.
18:12:53 <johnw> Inductive Context a := C : seq a -> a -> seq a -> Context a.
18:12:57 <johnw> wrong window
18:13:56 <Myrl-saki> [Ind]uctive Cont[ex]t
18:14:03 <Myrl-saki> Index is the best type name.
18:15:39 <johnw> haha
18:22:21 <wkoiking> I often write the code like: case a of pat1 -> Just b1; pat2 -> Just b2; _ -> Nothing
18:23:28 <wkoiking> or more generally: case a of pat1 -> return b1; pat2 -> return b2; _ -> fail
18:24:19 <wkoiking> isnt threre nicer way to write these expression?
18:24:35 <Myrl-saki> wkoiking: Depends?
18:25:27 <Myrl-saki> wkoiking: For one, case statements are already the nicer way.
18:26:24 <wkoiking> something like: caseM a of pat1 -> b1; pat2 -> b2
18:26:54 <wkoiking> return and fail case seems redundant
18:27:31 <Myrl-saki> wkoiking: Ah.
18:29:18 <Myrl-saki> wkoiking: I don't think there's a generaly way to do it.
18:29:34 <Myrl-saki> wkoiking: But in some cases, there's a specifc way to do it.
18:29:49 <Myrl-saki> wkoiking: Do you have an example where you used that pattern?
18:33:49 <geekosaur> doesn't case already throw when a pattern doesn't match? (granted this is different from fail, because it has to work in pure code)
18:35:01 <wkoiking> hmm, I use that pretty much every where when Im in monad..
18:35:22 <aarvar> wkoiking: prisms?
18:36:11 <Vibor> Hi
18:36:16 <Myrl-saki> geekosaur: The first code. `case a of pat1 -> Just b1; pat2 -> Just b2; _ -> Nothing`
18:37:07 <Myrl-saki> aarvar: I'm curious. How can prisms help?
18:37:10 <Vibor> Does not this line work?  > factorial (n+1) = (n+1) * factorial n
18:37:23 <geekosaur> not any more
18:37:32 <geekosaur> N+K patterns were in haskell98, removed in haskell2010
18:37:42 <geekosaur> but you can reactivate them with -XNPlusKPatterns
18:37:55 <geekosaur> (the reason they were removed is that they can lead to some ugly edge cases)
18:39:42 <geekosaur> http://stackoverflow.com/questions/3748592/what-are-nk-patterns-and-why-are-they-banned-from-haskell-2010 they can give you unexpectedly partial functions as shown here, although there are more subtle examples of it around
18:40:04 <tswett> Hey folks. What are my options for calling into Python from Haskell? Looks like this is the most popular Haskell library for doing it: https://github.com/jmillikin/haskell-cpython
18:41:14 <Vibor> geekosaur: Can I compile lhs file written in haskell 98 with ghc of version 8.0.1 , I found it's not just pattern, there are tons of errors while I'm trying to compile it
18:41:20 <tswett> Seems to be dormant since 2015, though.
18:41:32 <geekosaur> Vibor, you could run into a lot of problems, I'm afraid
18:42:35 <geekosaur> since haskell 98 there have been a number of changes, not just n+k pattern removal but Num changes (no more Show/Eq implicit), Monad change (must provide an Applicative instance), Foldable/Traversable (can introduce unexpected type confusion), ...
18:43:05 <Vibor> geekosaur: actually here is the source code, a module written for a book : http://www.cs.ou.edu/~hougen/classes/Spring-2011/cs2603/materials/Stdm.lhs
18:43:26 <Vibor> It's a math proof checker
18:43:26 <geekosaur> also haskell98 only specified flat modules but haskell2010 (and an addendum to 98) added hierarchical modules, and you can't use the old flat-namespace names any more
18:46:32 <tswett> geekosaur: Monad must provide an Applicative instance? Maybe I'm misunderstanding this page, because Monad doesn't seem to require Applicative there: https://www.haskell.org/onlinereport/haskell2010/haskellch9.html
18:46:49 <geekosaur> that's as of ghc 7.10 (AMP)
18:47:12 <the|auriscope> I'm currently reading something that says that foldr "forces the first bit of the spine." 
18:47:17 <the|auriscope> so this blows up:
18:47:17 <the|auriscope> foldr (\_ _ -> 1) 0 undefined
18:47:24 <geekosaur> the only major differences between h98 and h2010 were removal of n+k, hierarchical modules standard, and ffi no longer an addendum
18:47:30 <geekosaur> the other changes are ghc specific
18:47:56 <the|auriscope> but how would something other than the "first bit" of the spine be, uh, is bottom the word I'm looking for?
18:48:00 <geekosaur> Vibor, the big problem you are seeing is from the Foldable-Traversable thing I mentioned. "traverse" is now defined in the Prelude
18:48:06 <Myrl-saki> the|auriscope: ` "forces the first bit of the spine."` sounds like some complicated medical procedure.
18:48:11 <the|auriscope> ^
18:48:36 <the|auriscope> I don't want to be in the room when a doctor says he's about to "force the first bit of my spine"
18:48:44 <geekosaur> and the other is the old weird Prelude "catch" went away; you need to import the real one from Control.Exception
18:48:59 <geekosaur> so, 2 lines to add after the "> module StdM where":
18:49:21 <geekosaur> "> import Prelude hiding (traverse)"
18:49:38 <geekosaur> hm, wait, I bet you also hit the exception hierarchy changes too
18:49:58 <geekosaur> so just importing catch won't be enough (and tbh something like this should not use catch, generally...)
18:50:16 <geekosaur> ok
18:50:24 <geekosaur> "> import Control.Exception"
18:50:54 <geekosaur> and at the top of the file: "{-# LANGUAGE ScopedTypeVariables #-}"
18:51:01 <tswett> the|auriscope: are you saying you're expecting "foldr (\_ _ -> 1) 0 undefined" to do something else?
18:51:23 <aarvar> Myrl-saki: was thinking you could use them to construct a [a -> Maybe r]
18:51:27 <geekosaur> and then the uses of catch need to be changed from having "\_ ->" to "\(e :: SomeException) ->"
18:51:31 <tswett> Nb that I don't actually know what "spine" means here.
18:51:45 <aarvar> and actually you'd only need Folds, not Prisms
18:51:54 <geekosaur> Haskell moves kinda fast; if you can get it to build, you  might be better off using hugs like the text says
18:52:40 <the|auriscope> tswett: the literature that I'm reading uses "spine" to refer to (in the context of lists, but I assume it has a more general definition for Foldables) the series of conses that bind the list elements together.
18:53:04 <geekosaur> yes
18:53:23 <tswett> Well, I guess (3 : undefined) would have "something other than the first bit of the spine" as bottom, right?
18:53:30 <Vibor> geekosaur: thanks a lot for the great explainations and quick solutions :)
18:53:37 <tswett> The first bit of the spine is just a cons, but the *second* bit is bottom.
18:53:39 <geekosaur> so forcing the spine forces evaluation of the next (:) (and will crash if there isn't one, as with '1':'2':undefined)
18:53:51 <the|auriscope> so, for instance, this isn't bottom: foldr (\_ _ -> 1) 0 [undefined, undefined]
18:54:01 <the|auriscope> since the lambda doesn't force any of the list elements
18:54:12 <geekosaur> right, with [] format your spine is always well formed
18:54:30 <the|auriscope> oh, gotcha.
18:54:32 <geekosaur> but with explicit (:) you can build a list which terminates in undefined
18:54:57 <the|auriscope> tswett geekosaur: Thank you.
18:55:07 <tswett> Hey, does GHC represent String as something a little "smarter" than a linked list of 32-bit characters, at run time?
18:55:14 <geekosaur> nope
18:55:35 <the|auriscope> this was the punchline for me:  <geekosaur> right, with [] format your spine is always well formed
18:55:38 <geekosaur> although it tries very hard to fuse lists, including String-s, so some or all of them may not even be in the program
18:55:48 <tswett> *nod*
18:56:49 <tswett> So if I *do* keep a 1,000,000-character String around, that's going to be at least... oh... 8,000,000 bytes or so, on a 32-bit system?
18:57:13 <tswett> *shrug* I guess GHC can't implement every possible feature.
18:57:18 <pacak> tswett: Yes.
18:57:27 <geekosaur> if you keep the whole thing, yes
18:57:33 <pacak> Strings are not very efficient for big chunks of data.
18:57:46 <geekosaur> this is one reason we tend to recommend Text for larger strings
18:58:13 <pacak> But for very short ones it can be faster than text/bytestring.
18:58:17 <geekosaur> but also note that String cn do something (strict) Text can't: you may be holding the spine but the characters themselves get gc-d. or only holding part of the spine
18:58:59 <geekosaur> also Strings can fuse away, as I said; this is much harder for Text
18:59:05 <geekosaur> (although it does try)
18:59:11 <tswett> Aha.
18:59:11 <the|auriscope> can values in a list be forced without their corresponding spine part being forced?
18:59:27 <geekosaur> no becauseyou need to go through the spine to reach the value
18:59:35 <the|auriscope> yeah, that was my assumption
18:59:53 <the|auriscope> but was open to some sort of magic being possible
19:00:08 <geekosaur> well. normally. there are tricks where the value can actually be referenced from multiple places (see "tying the knot"; this is less than useful with, say, Char)
19:00:48 <tswett> Are Text and ByteString pretty analogous?
19:00:54 <geekosaur> this is *not* the common case and can be very hard to achieve by deliberate intent (but then it sometimes happens when you least expect/want it....)
19:01:12 <geekosaur> not really unless you're an American :p
19:01:44 <geekosaur> Text is Unicode text. ByteString is octets, which are enough to represent characters in US-ASCII or ISO 8859 but not full Unicode
19:03:43 <geekosaur> generally ByteString is used for network connections because network sockets transmit/receive octets. if some/all of those octets represent some kind of text, you will want to use the encode/decode functions in Data.Text to get Text values
19:04:04 <geekosaur> (and it's on you to know or determine *what kind* of text)
19:04:06 <tswett> Well, yeah... I meant are they equivalent *apart* from the fact that a Text is a string of Unicode scalar values whereas a ByteString is a string of bytes?
19:04:18 <geekosaur> I think there are implementation differences
19:04:28 <geekosaur> aside from Text being UTF16
19:05:20 <geekosaur> like, iirc text uses normal primitive arrays but ByteString is pinned?
19:05:48 <geekosaur> (which would mean gc can move a Text around but not a ByteString)
19:06:48 <tswett> *nod*
19:07:07 <tswett> Anyway, I'm gonna go buy a burrito. Be back soon.
19:07:20 <geekosaur> don't let it bind you:p
19:08:03 <wkoiking> geekosaur: could you elaborate on prism thing you have mentioned?  and how it helps?
19:08:19 <geekosaur> I didn't mention prisms
19:08:41 <geekosaur> [12 02:51:23] <aarvar> and actually you'd only need Folds, not Prisms
19:08:43 <geekosaur> that perhaps?
19:08:47 <geekosaur> sounds like lenses to me
19:09:17 <geekosaur> right, I see earlier refs from them as well
19:09:31 <Cale> wkoiking: What would the code you want to write look like?
19:10:06 <Cale> Perhaps write the code you'd like to be able to write and then see how close you can get to it by making definitions.
19:10:30 <aarvar> wkoiking: something like this maybe? http://lpaste.net/353440
19:10:44 <wkoiking> Sorry that was aarvar
19:14:18 <wkoiking> Oh, this looks cool. (though I do not understand fully yet)
19:14:55 <aarvar> the idea being to construct a list of functions, [a -> Maybe r]
19:19:21 <aarvar> wkoiking: updated the paste
19:20:04 <aarvar> it's not really much shorter than the case statement
19:20:15 <aarvar> *expression
19:23:34 <wkoiking> but that was almost what I was looking for... thanks
19:25:12 <ertes> jophish: is the vulkan library still maintained?
19:25:30 <wkoiking> I often use the msum to replace guard to omit default case and Im looking for similar in case of case expression
19:25:55 <ertes> jophish: i'm asking, because the last release is almost a year old, and vector-sized got updated in the meantime
19:50:05 --- mode: rajaniemi.freenode.net set +o ChanServ
19:50:15 <wkoiking> Now I understand the former at least :)
21:24:06 <ezyang> More naming advice please. "count" is currently overloading to mean "count characters" in ByteString and "count strings" in Text. What are good names to disambiguate these to? 
21:25:32 <ezyang> I guess for now I'll go with elemCount and substringCount 
21:35:06 <johnw> ezyang: that sounds good to me
22:04:36 <buttons840> is HXT the only option for xpath?
22:08:21 <buttons840> ah, looks like HXT and HaXml are both packages with XPath support, and they are independent of each other -- both look fairly complicated, but it's nice to know there's two independent options to choose from
22:11:10 <johnw> usually when someone looks at two libraries and says they both look complicated, we'll have someone in a few months say they found three libraries and they all look complicated :)
22:30:37 <ertes> instance (Show a, Show (v a)) => Show (Linear v a)
22:30:45 <ertes> this doesn't require FlexibleContexts?
22:30:58 <jle`> only if you pick a concrete type for v i think
22:31:21 <ertes> weird
22:31:27 <jle`> if all of your types are type variables then i think you don't need flexible contexts
22:31:51 <ertes> i could have sworn that GHC complained about a context like that in the past
22:31:54 <jle`> i mean, the constraints
22:33:20 <jle`> oh
22:33:24 <jle`> i think you're right
22:33:29 <jle`> it should require FlexibleContexts
22:34:06 <jle`> w/o flexible contexts, the constraints should only be allowed to be simple type variables like 'Show a', not 'Show (v a)'
22:34:31 <ertes> yeah…  but i'm still on 8.0.1, so perhaps it will be fixed after an upgrade
22:34:47 <jle`> maybe some extension is turning it on?
22:34:55 <ertes> i have none enabled
22:34:57 <jle`> try setting NoFlexibleContexts
22:35:02 <ertes> (yet)
22:35:22 <ertes> as expected it doesn't make a difference
22:35:52 <jle`> yeah, what you gave is actually the exact example that the GHC manual gives for situations that require FlexibleContexts
22:36:59 <ertes> BTW, i wish i could tell the deriver to ignore fields…  would save me a lot of boilerplate in this particular library
22:37:20 <ertes> *the Show deriver
22:37:41 <jle`> `class (Monad m, Monad (t m)) => Transform t m where`  is their example, lol
22:40:51 <athan> is there a... codo for comonads?..
22:41:06 <pikajude> no
22:41:11 <pikajude> but you can use RebindableSyntax
22:41:57 <athan> hm, thanks pikajude never used that extension before
22:43:46 <athan> is there a way to scope language extensions in a source file? Or turn them off at some line?
22:45:58 <jle`> codo is a thing, but it's not in ghc
22:46:41 <jle`> i think there might be a TH package
22:49:50 <athan> RebindableSyntax still looks really cool, thanks for the tip pikajude
22:50:02 <athan> eh yeah idk, I still don't understand comonads jle` :)
22:50:18 <pikajude> athan: you can do 🌈anything with it
22:50:57 <jle`> athan: regarding rebindable syntax, you can import prelude and use the normal (>>=) from Monad
22:51:12 <jle`> athan: and then in the situations where you want to use a special (>>=), you can introduce a shadowing binding
22:51:50 <jle`> foo = do ....;  where (>>=) = myBind; return = myReturn
22:53:29 <ertes> athan: i don't think using sugar will improve your understanding of comonads
22:58:27 <Zorkie> Hey there. I've installed Haskell to windows. After which I'm trying to install a software package that has a dependency on 'download'. Unfortunately, that package gives me a build error. 'unknon type name 'auth_t'
22:58:35 <Zorkie> Any clues?
22:59:08 <Zorkie> Als, an error 'unknown type __BEGIN_DECLS' was given
22:59:29 <Zorkie> This gives me the impression some core library is missing or not found
22:59:38 <athan> suppi: did you write that functorial blog post you showed me?
22:59:51 <athan> the `right` / `left` functions for zippers are partial :(
22:59:55 <Zorkie> I did add the additional paths to 'config', as the install guide told me.
23:00:14 <athan> still rediculously cool though
23:00:31 <suppi> athan: no, it's phils blog
23:01:21 <athan> oop right on
23:01:31 <nshepperd> what would a codo look like
23:02:40 <athan> ... ?:)
23:03:17 <athan> codo {g x; f -> x}
23:03:22 <athan> idk lol
23:03:40 <athan> don't {...}
23:03:50 <jle`> https://hackage.haskell.org/package/codo-notation
23:03:56 <athan> o_o
23:04:01 <nshepperd> codo { wx <- x; f wx } = extend f x?
23:04:03 <jle`> oh sorry should have linked to http://www.cl.cam.ac.uk/~dao29/drafts/codo-notation-orchard-ifl12.pdf
23:04:22 <athan> hm!
23:08:44 <ertes> codo and do are pretty much the same thing with a flipped arrow
23:09:44 <ertes> more importantly codo is rather confusing
23:10:01 <johnw> in the future, people will discover that "codo" meant "close the door"
23:10:42 <ertes> codo t <- s; v t
23:10:49 <Zorkie> Anybod got a clue as to why I'm getting build errors e.g. 'unknown type name auth_t' ?
23:11:02 <Zorkie> Running haskell on windows
23:11:11 <ertes> 't' has the same type as 's', and (v t) is supposed to be an unwrapped value
23:11:24 <ertes> it's confusing…  just use 'extend' and 'extract'
23:11:51 <athan> heh, thanks ertes 
23:12:45 <ertes> i guess comonads are also flipped in whether you want sugar or not =)
23:13:28 <ertes> @paste -- Zorkie 
23:13:29 <lambdabot> Haskell pastebin: http://lpaste.net/
23:18:16 <Zorkie> http://pastebin.com/TxW0vNJY
23:18:28 <Zorkie> thank you
23:19:26 <Zorkie> sorry for slow response, 4-month old demands my full attention :-P
23:22:10 <ertes> Zorkie: what are you trying to build?
23:22:22 <ertes> and how?
23:24:17 <ertes> ah, 'download'
23:24:28 <Zorkie> cabal install download  -v3 >log
23:25:09 <ertes> as far as i see parts of that library are written in non-portable C
23:25:18 <Zorkie> Actually i want to install 'implicit', but it fails on dependency 'download'
23:25:21 <ertes> or at least: not portable to windows
23:25:56 <Zorkie> hmm, that would explain it... but that would suck too ;-)
23:26:26 <ertes> yeah, it's including stuff like unistd.h unconditionally
23:26:54 <Zorkie> okay, well, thats a showstopper then :-)
23:27:04 <Zorkie> thanks for explaining,
23:27:09 <ertes> so unless you would enjoy some sunday pain with cygwin, you're pretty much out of luck =)
23:27:32 <ertes> alternatively port the library yourself
23:27:37 <Zorkie> hehe, nah... a vm with linux would be easier :-P
23:27:45 <ertes> yeah, definitely
23:28:08 <Zorkie> okay, I'll give that a spin. Thanks a lot guys!
23:28:24 <Zorkie> Have  a great sunday!
23:29:10 <ertes> Zorkie: you could try a different library
