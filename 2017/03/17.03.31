00:05:51 <fred-fri> https://www.hackerrank.com/challenges/diagonal-difference Wrote a quick and dirty Java solution https://pastebin.com/1EtaRW1D but struggling to solve it in Haskell. I'd be interested to see any solution anyone might come up with.
00:07:27 <jle`> fred-fri: are you asking for a direct translation of your java solution?
00:08:26 <jle`> > map (map read . unwords) . unlines $ "1 2 3\n4 5 6\n7 8 9" :: [[Int]]
00:08:28 <lambdabot>  error:
00:08:28 <lambdabot>      • Couldn't match type ‘Char’ with ‘[Char]’
00:08:28 <lambdabot>        Expected type: [String] -> [String]
00:08:40 <jle`> > map (map read . words) . lines $ "1 2 3\n4 5 6\n7 8 9" :: [[Int]]
00:08:43 <lambdabot>  [[1,2,3],[4,5,6],[7,8,9]]
00:09:26 <jle`> > zipWith drop [1..] . map (map read . words) . lines $ "1 2 3\n4 5 6\n7 8 9" :: [[Int]]
00:09:28 <lambdabot>  [[2,3],[6],[]]
00:09:33 <jle`> hm
00:09:38 <jle`> > zipWith drop [0..] . map (map read . words) . lines $ "1 2 3\n4 5 6\n7 8 9" :: [[Int]]
00:09:41 <lambdabot>  [[1,2,3],[5,6],[9]]
00:09:53 <jle`> oh, well
00:10:14 <jle`> > sum . zipWith (flip (!!)) [0..] . map (map read . words) . lines $ "1 2 3\n4 5 6\n7 8 9" :: [[Int]]
00:10:17 <lambdabot>  error:
00:10:17 <lambdabot>      • No instance for (Num [[Int]]) arising from a use of ‘sum’
00:10:17 <lambdabot>      • In the first argument of ‘(.)’, namely ‘sum’
00:10:27 <jle`> hopefully that's good enough of a hint to start from
00:41:09 <bollu> cocreature: ping
00:47:14 <significance> Hey all! Haskell noob here -- I wrote a really simple program as an exercise here (https://gist.github.com/useanalias/1780ea3f48f27250a27c7dbeefe6f7c1) and it runs fine for positive input, but for negative input, it complains of a "non type-variable argument in the constraint: Num (a -> a -> a)." What might be going on?
00:47:57 <quchen> significance: (-) is the "subtract" function,
00:48:05 <quchen> > (-) 10 1
00:48:07 <lambdabot>  9
00:48:10 <quchen> That’s the same as
00:48:12 <quchen> > 10 - 1
00:48:14 <lambdabot>  9
00:48:25 <quchen> Use »negate« to flip the sign,
00:48:27 <quchen> > negate 2
00:48:30 <lambdabot>  -2
00:48:33 <significance> Ohh, is (+) different?
00:48:40 <significance> > (+) 3 2
00:48:42 <lambdabot>  5
00:48:47 <quchen> (+) follows the same principle.
00:48:47 <jle`> it's the same, but it's probably how you are calling it
00:48:56 <jle`> significance: are you calling it 'stepReverseSign -1' ?
00:49:04 <quchen> You can use an infix function as prefix if you enclose it in parentheses.
00:49:05 <jle`> becuase haskell doesn't like that
00:49:11 <quchen> > (*) 3 4
00:49:13 <lambdabot>  12
00:49:18 <significance> jle`: I'm calling it with two arguments :)
00:49:20 <quchen> > (/) 10 2
00:49:23 <lambdabot>  5.0
00:49:25 <jle`> significance: can you post how you are calling it
00:49:40 <hvr> quchen: and now explain -XNegativeLiterals :-)
00:49:41 <significance> jle`: sure: stepReverseSign -3 1 from ghci
00:49:54 <jle`> significance: ah, yeah
00:49:59 <jle`> try stepReverseSign (-3) 1
00:50:04 <quchen> hvr: Not Haskell :-þ
00:50:06 <jle`> the problem is that haskell interprets - as an operator, there
00:50:16 <jle`> so it's parsed as stepReverseSign - 3 1
00:50:21 <significance> ohh, derp -- thank you!
00:50:22 <jle`> or stepReverseSign - (3 1)
00:50:37 <jle`> it's definitely unintuitive, and very different from most other programming languages, so you can't blame yourself
00:50:42 <hvr> quchen: ...not yet =)
00:51:06 <significance> thank you!
00:51:18 <jle`> no problem!
00:51:29 <quchen> hvr: »I should do something for Haskell’« is something that bugs me every day :-S
00:51:30 <jle`> the - token is kind of weird anyway in haskell
00:51:42 <quchen> … to varying avail
00:51:49 <hvr> quchen: yeah, I know... same here
00:52:33 <hvr> but there's unfortunately other parts of the ecosystems that have currently higher prio for me
00:55:53 <quchen> hvr: Dug up a mainframe again? ;-)
01:19:38 <cocreature> bollu: pong you need to go via the FFI, e.g., https://github.com/llvm-hs/llvm-hs/blob/llvm-4/llvm-hs/test/LLVM/Test/OrcJIT.hs#L82
01:21:02 <ahri> i have a function returning "Either Error [Event]" - in the Right case i want to go through each Event, passing it to a function that returns "Maybe Database" - this is for a unit test, and really i don't care about the intermediate results, only the final Database value. can i do this in a one-liner? it feels like i should be able to but the 2 monads involved confuse me a bit
01:22:04 <cocreature> ahri: so you have "Either Error [Event]" and "Event -> Maybe Database". what should the type of the result be?
01:22:12 <ventonegro> ahri: funcA >>= traverse funcB
01:22:40 <ahri> cocreature: the end result can be "Maybe Database"
01:23:13 <ahri> ventonegro: traverse? hm, i'll look that up!
01:24:04 <ventonegro> ahri: in this case the Traversable is the list [Event] and the Applicative is Maybe
01:24:17 <ventonegro> > :t traverse
01:24:19 <lambdabot>  <hint>:1:1: error: parse error on input ‘:’
01:25:21 <cocreature> ahri: so in the case of Left Error this should map to Nothing? and what happens if you get a database for multiple events?
01:25:36 <cocreature> ahri: and what happens if you get Nothing for some of the events and Just db for others?
01:26:42 <KorriX> Hello! Is there any easy way of writing catMaybes for list of tuples with Maybes as fst? ( [(Maybe a, b)] -> [(a,b)] )
01:27:29 <ahri> cocreature: if any of the events result in a Nothing, the end result would be a Nothing; i want to sequentially apply the events, one by one, to the Database, and give up if any of the events are invalid
01:27:30 <KorriX> Possibly as some kind of lens/arrow oneliner
01:29:33 <Aruro> KorriX: traversable would be nice to go from [Maybe a] to Maybe [a]
01:29:49 <Aruro> but your structure is more than that
01:30:14 <merijn> KorriX: What should happen if your Maybe is Nothing?
01:30:33 <Gurkenglas_> :t mapMaybe (_1 id) :: [(Maybe a, b)] -> [(a, b)] -- KorriX
01:30:35 <lambdabot> [(Maybe a, b)] -> [(a, b)]
01:30:54 <KorriX> merijn: Whole tuple should disappear from list
01:31:07 <Gurkenglas_> He did mention catMaybes
01:31:54 <KorriX> Gurkenglas: Thx, this is what I wanted
01:32:27 <Aruro> how do people work with arrow keys on terminal? does standard library offer any support of them?
01:34:15 <merijn> Aruro: You mean "how do I do interactive line editing on input?"
01:34:52 <Aruro> no, i mean how i detect that user pressed up or down key, i need to change some parameter based on that
01:35:40 <KorriX> Aruro: You should be able to just use getchar
01:35:46 <geekosaur> not for arrows
01:35:52 <geekosaur> at least not on linux/os x
01:35:57 <Aruro> its gets ugly on non letter symbols
01:35:58 <merijn> Aruro: That very much depends on what kinda program you're trying to write, depending on that there's 2 answers
01:36:04 <geekosaur> you'll want to use vty/brick or hscurses
01:36:34 <geekosaur> btu only configure the keyboard part (hscurses but stick to the terminfo part, or the low level terminfo bindings)
01:36:48 <merijn> Answer 1) buy a copy of Advanced Programming in the UNIX Environment and read up on the hell that is ttys, tty modes and lots of confusion about raw, cooked and half-cooked modes
01:36:54 <Gurkenglas> geekosaur, why not the ncurses package? It was updated more recently
01:37:08 <merijn> Answer 2) You're writing a terminal UI, use brick/vty-ui and forget all the other mess
01:37:32 <merijn> Gurkenglas: Because ncurses has a retarded API that drives you insane
01:37:39 <Aruro> i have vty and terminfo currently installed
01:37:50 <merijn> Which, incidentally probably also applies to hscurses, being an ncurses binding
01:38:09 <Gurkenglas> so's ncurses
01:38:11 <merijn> Aruro: What are you actually trying to implement?
01:38:33 <merijn> Gurkenglas: Right, but I already said ncurses was a Cthulhian nightmare :)
01:38:45 <Aruro> taking keystroke up and down from terminal and changing time interval of printing stuff on screen
01:38:53 <Aruro> simple
01:38:54 <ahri> ventonegro: hmm i'm doing "events >>= traverse (applyEvent db)" and getting "Couldn't match type ‘Maybe’ with ‘Either Error’" - which is sorta what i expected to be a problem with this. db :: Database, events :: Either Error [Event]
01:39:15 <Gurkenglas> Was just trying to make sure you didnt confuse ncurses the haskell package with the ncurses that binds to
01:39:19 <ahri> applyEvent :: Database -> Event -> Maybe Database
01:39:21 <merijn> Aruro: Yes, but what kinda program? Are you trying to write some terminal UI? If yes, use brick
01:39:39 <Aruro> yes, terminal, why not vty? i have no brick :(
01:39:56 <Gurkenglas> Why not just do getChar for w and s?
01:39:57 <merijn> Aruro: brick is a high level interface build on vty
01:40:07 <ventonegro> ahri: well, now you gave your function signature :)
01:40:14 <merijn> :t (>>=)
01:40:15 <lambdabot> Monad m => m a -> (a -> m b) -> m b
01:40:23 <merijn> ahri: Notice, same 'm' on both sides
01:40:35 <merijn> ahri: 'Either Error' is not 'Maybe', so you can't mix those
01:40:45 <ventonegro> ahri: my bad
01:41:04 <ahri> yeah, that's what i expected. i was wondering whether i need to transform the Either to a Maybe or something
01:41:19 <ahri> but i have no idea whether that's the correct approach
01:42:48 <ahri> this scenario of 2 different monads is not one i've had to deal with yet, but i've been looking forward to it :)
01:43:33 <merijn> ahri: converting the maybe to either is probably best
01:44:04 <merijn> "maybe (Left myError) Right . traverse (applyEvent db)" or something
01:49:15 <ahri> hm, i see, thanks :)
01:49:58 <ahri> on the subject of Brick - does it work well cross platform? and would it suit representing a realtime game on the console with it?
01:51:32 <merijn> ahri: As long as your definition of "cross platform" does not include Windows, I think it works well
01:52:06 <ahri> merijn: it kinda did, but i'm not all that bothered by windows i guess ;)
01:52:10 <merijn> ahri: I've actually decided it's probably easier to write a game using brick, dump it on a $5 VPS and tell windows users to use PuTTy to play it then figure out windows portability ;)
01:52:35 <geekosaur> windows console is weird for that stuff :/
01:53:02 <ahri> haha, it supposedly supports bash now, so perhaps in the future...
01:53:29 <Aruro> why supporting windows?
01:55:51 <Aruro> not supporting windows willbring more people to normal worlds, instead of half baked solutions which anycase dont work
01:56:08 <Aruro> nobody in production uses haskell on windows
01:56:24 <merijn> Aruro: uh...SPJ does all his GHC work on windows
01:56:36 <Aruro> wtf? really?
01:56:45 <merijn> Yes, always has
01:57:10 <jle`> also microsoft is one of the biggest sponsors of haskell development so there's that
01:57:17 <Aruro> wierd. what does he say? why he does it?
01:57:38 <jle`> s/sponsors/supporters
01:57:54 <jle`> but that was probably only because SPJ used to work there, admittedly
01:57:56 <Aruro> jle`: i thought haskell was academic
01:58:12 <jle`> Aruro: you thought wrong :)
01:58:43 <merijn> jle`: SPJ still works at MSR
01:58:49 <int-e> MSR is largely academic.
01:58:55 <merijn> s/largely//
01:59:06 <merijn> MSR is more academic than a significant percentage of universities
01:59:25 <Aruro> hence has nothing to do with windows
02:00:26 <merijn> Purely functional language implementors just like Windows :p
02:00:36 <merijn> The main platform of Clean is also Windows
02:00:45 <Aruro> merijn: does spj use emacs on windows? what does he code in?
02:01:34 <merijn> No idea, tbh
02:02:01 <tsahyt> SPJ also uses do notation with {} and ;s
02:02:13 <Aruro> mmm
02:02:18 <tsahyt> according to a comment edwardk made on reddit a few days ago iirc
02:02:33 <tsahyt> I find that a lot stranger than somebody using windows :P
02:02:44 <Aruro> they are together :D
02:02:52 <osa1> Aruro: he uses a shell connected to a linux server and runs emacs in it
02:03:58 <tsahyt> talking about windows, how's the haskell + gtk situation on windows? I think threadscope uses gtk, and I've never heard any complaints about it from windows users
02:09:06 <tsahyt> the reason why I'm asking is because FRP has made me start to like GUI programming.. which is the strangest thing really
02:13:14 <merijn> tsahyt: I think it's the same as most GUI frameworks and most OSes. Horrible initial pain to setup, but reasonable if you get it working?
02:13:19 <Aruro> what is the way to get asynchronous keystrokes? getChar solution demands full stop
02:13:50 <tsahyt> well that's good enough then
02:14:29 <merijn> tsahyt: Be warned, I haven't actually tried it, though ;)
02:15:12 <tsahyt> merijn: It's good enough to know that it could probably work in principle. as long as I have a choice I have no intentions of supporting windows to begin with.
02:15:24 <tsahyt> I have no machine to test windows builds on for example
02:15:41 <tsahyt> but it's reassuring to know that a sufficiently determined user could probably make it work
02:16:18 <Aruro> i was in mediamarkt yesterday, all pcs have windows by default, why people shoul support monopoly?
02:17:13 <Aruro> its like all cars have diesel 
02:17:16 <Aruro> engine
02:18:20 <tsahyt> the engine thing depends mostly on where you are in the world. I'll assume you're german because mediamarkt. the americans have barely any diesel engines in their cars
02:18:44 <merijn> This doesn't strike me as a particularly on-topic or interesting discussion, though?
02:18:50 <tsahyt> agreed
02:19:48 <Aruro> people often complain about poor support of something good on windows (haskell)
02:21:07 <Aruro> as an argument against it.
02:23:23 <Maxdaman1us> against Windows or against Haskell?
02:23:29 <Aruro> haskell
02:27:03 <Aruro> is forkIO the only way to get asynchronous getChar keystrokes?
02:31:17 <lapinot> me again, is there any (possibly hacky, involving Dynamic or the like) way to get some data out of a GADT that has "eaten" a type variable?
02:31:34 <merijn> Aruro: What does "asynchronous" mean here?
02:31:52 <tsahyt> lapinot: pattern matching on it with scoped type variables enabled
02:31:54 <merijn> lapinot: Can you explain what you mean by that?
02:31:54 <cocreature> lapinot: could you provide an example? I don’t understand that question
02:31:58 <tsahyt> unless I misunderstand
02:34:13 <lapinot> for example the oblivious type would be `data X = MaybeAConstraintHere a => Foo a -> X` and I would like an unwrap function that could get a value back (I know this sound silly, it is, so what could be workarounds?)
02:34:59 <lapinot> I read a bit of the text about "phantom types", that could be some way out, but I don't really see how
02:35:04 <merijn> lapinot: No, unless you modify X
02:35:10 <cocreature> if Foo is a GADT you might be able to recover some type info by pattern matching on it
02:35:26 <merijn> He can only uncover the Constraint on 'a'
02:35:30 <merijn> Not the type of 'a'
02:35:37 <merijn> Unless he adds a Typeable constraint
02:36:05 <merijn> lapinot: But the most common scenario for wanting this is falling into the trap of the existential anti-pattern
02:36:06 <cocreature> merijn: if Foo is a gadt you can totally get the type of "a" at least for some gadts
02:36:13 <merijn> @where existential-antipattern
02:36:13 <lambdabot> "Haskell Antipattern: Existential Typeclass" by Luke Palmer at <http://lukepalmer.wordpress.com/2010/01/24/haskell-antipattern-existential-typeclass/>
02:36:27 <merijn> cocreature: Not unless you add the type variable somewhere
02:37:14 <Phyx-> geekosaur: windows console is fine, GHC just doesn't use the API directly which results in weirdness
02:37:49 <lapinot> merijn: actually, i'm doing HOAS stuff so this seems like just a nice(tm) use case ;)
02:39:04 <cocreature> merijn: here’s what I’m referring to http://lpaste.net/
02:39:08 <cocreature> eh http://lpaste.net/354136
02:39:21 <Phyx-> in fact, you can replace "GHC doesn't use native Windows XXX which results in weirdness" with just about anything
02:39:22 <cocreature> if you have multiple branches you’ll at least get the type in each branch
02:39:59 <Phyx-> with the exception being memory management and linker, out of necessity
02:41:03 <merijn> cocreature: Right, but that only works since Foo can only ever be "Foo Int"
02:41:19 <merijn> cocreature: You couldn't, for example, stuff "Identity a" in there and achieve the same
02:41:32 <cocreature> merijn: yeah but if there are multiple possibilities you’ll at least get the type in each branch of your pattern match
02:42:28 <merijn> Is there a proper mathy/scientific way of saying "5 number summary"? Or is that the best I can do?
02:42:30 <tsahyt> wait, what? you can pattern match on the type directly?
02:42:55 <merijn> tsahyt: No
02:43:02 <merijn> tsahyt: I think you're misreading it :)
02:43:25 <tsahyt> so, case x of { Foo (x :: A) -> .., Foo (x :: B) -> .. } does not work then
02:43:28 <cocreature> no you can recover type info by pattern matching on values using GADTs
02:44:02 <merijn> tsahyt: Well you can't even create a Foo with a type different than Int
02:44:28 <tsahyt> Oh, no I didn't mean Foo from cocreature's paste
02:44:56 <tsahyt> just some existential wrapper
02:45:07 <merijn> You can't match on types in existential wrappers
02:45:25 <tsahyt> okay
02:45:27 <merijn> GHC doesn't store their type at runtime, so you can't recover them either
02:45:37 <tsahyt> yes, that's what I was thinking. I was worried there for a moment.
02:45:42 <lapinot> if you want to think with my code in sight: https://ptpb.pw/7uUy
02:48:54 <bollu> what's that paper where they describe writing datatypes out as equations?
02:49:03 <bollu> like, [a] becomes x = 1 + ax
02:49:16 <bollu> which gives you x = 1/(1 - a) = 1 + a + a^2 + … ?
02:49:27 <bollu> merijn: do you remember?
02:50:11 <merijn> That's algebraic datatypes, but I don't know any references
02:50:56 <bollu> merijn: ah, damn
02:51:09 <bollu> merijn: specifically, I was looking for like, how differentiation gives you zippers
02:51:25 <bollu> merijn: it was something like "hole context" or something?
02:52:02 <merijn> bollu: Yeah, it sounds vaguely familiar but I don't remember author/title
02:52:11 <tsahyt> bollu: ∂ for data: differentiating data structures
02:52:17 <tsahyt> maybe this is what you're looking for
02:52:17 <bollu> http://strictlypositive.org/diff.pdf found it!
02:52:43 <bollu> tsahyt: thanks :) That and: the derivative of a data type is its type in one hole context
02:53:22 <bollu> TIL it is conor Mc Bride who came up with this
02:54:18 <bollu> does he accept research students? ;)
02:54:34 <tsahyt> at least related work has been done earlier than that by philippe flajolet iirc
02:54:54 <tsahyt> I remember a paper from the 80s or so
02:55:06 <tsahyt> the first time I saw something similar was in a category theory textbook
02:55:12 <bollu> tsahyt: what? :O
02:55:23 <bollu> tsahyt: will you be here in an hour or so?
02:55:25 <tsahyt> no the differentiation
02:55:27 <tsahyt> not*
02:55:32 <bollu> tsahyt: oh
02:55:34 <tsahyt> but writing a type out like that
02:55:34 <bollu> tsahyt: then?
02:55:43 <bollu> tsahyt: I see. I would still like a reference, please
02:55:52 <bollu> tsahyt: a categorical interpretation would be super neat
02:55:55 <tsahyt> sure, let me see
02:56:26 <bollu> tsahyt: much appreciates
02:56:42 <bollu> tsahyt: my laptop may go to sleep, it would be nice if you could @tell me the reference :)
02:56:44 <bollu> appreciated*
02:56:49 <tsahyt> R.F.C. Walters, Categories for Computer Science. page 82. There he decomposes a tree like this
02:57:07 <tsahyt> okay, will do.
03:00:32 <tsahyt> I misremembered. It wasn't Flajolet, it was Joyal.
03:00:38 <tsahyt> @tell bollu http://www.sciencedirect.com/science/article/pii/0001870881900529
03:00:38 <lambdabot> Consider it noted.
03:00:51 <tsahyt> unfortunately in french, so I can't really read it
04:10:40 <eatman> Hey, tell me, what can be an applicative functor wothout being a monad?
04:10:55 <merijn> eatman: Const
04:11:05 <merijn> eatman: As in "data Const k a = Const k"
04:11:28 <merijn> eatman: In fact, trying to implement Functor, Applicative, and Monad for that is a good exercise :)
04:11:45 <merijn> eatman: hint: You might need a typeclass constraint to implement a lawful Applicative :)
04:11:57 <merijn> eatman: Also, ZipList is an Applicative, but not a Monad
04:12:03 <eatman> merijn: thanks.
04:12:32 <eatman> Did not know Const yet.
04:12:37 <merijn> eatman: ZipList being a newtype for list, since list has 2 possible lawful Applicatives, only one of which (the default) has a possible Monad
04:12:40 <eatman> And, ok for ZipList.
04:13:38 <eatman> :i Const
04:13:41 <merijn> > f <$> [a,b,c] <*> [x,y,z] :: [Expr] 
04:13:43 <lambdabot>  error:
04:13:43 <lambdabot>      Ambiguous occurrence ‘c’
04:13:43 <lambdabot>      It could refer to either ‘Debug.SimpleReflect.c’,
04:13:46 <merijn> hmmm
04:13:49 <merijn> @undefine
04:13:49 <lambdabot> Undefined.
04:13:51 <merijn> > f <$> [a,b,c] <*> [x,y,z] :: [Expr] 
04:13:53 <lambdabot>  [f a x,f a y,f a z,f b x,f b y,f b z,f c x,f c y,f c z]
04:14:29 <merijn> > getZipList (f <$> ZipList [a,b,c] <*> ZipList [x,y,z]) :: [Expr] 
04:14:31 <lambdabot>  [f a x,f b y,f c z]
04:16:04 <eatman> Ok ok...
04:16:12 <eatman> Never easy to understand...
04:16:59 <merijn> eatman: The normal applicative is cartesian product (all possible pairs), whereas ZipList is pairwise zip of the lists :)
04:18:31 <eatman> Yes, I know that for lists and zipLists, just no easy to get it for every possible data type.
04:18:53 <eatman> But I guess I'll get used to it.
04:19:07 <tsahyt> there are also some thing that could be monads but aren't because allowing bind would wreck performance
04:19:26 <merijn> tsahyt: Like?
04:19:39 <tsahyt> merijn: I remember some examples in FRP
04:19:47 <tsahyt> either behaviors or events, not sure
04:19:55 <merijn> tsahyt: Oh, time leaks, yes
04:20:13 <bollu> merijn: also backtracing parers?
04:20:21 <bollu> merijn: AFAIK arrows were invented for that purpose, right?
04:20:37 <bollu> tsahyt: thanks for the link. Though, I can't read french either
04:20:56 <merijn> bollu: Almost all monadic parsers allow backtracking
04:21:01 <bollu> merijn: no, I mean
04:21:05 <bollu> merijn: space leaks
04:21:18 <merijn> (mega/atto)parsec and trifecta have monad instances and do backtracking
04:23:01 <tsahyt> bollu: when I first read about it in the r.f.c. walters book I was quite amazed at how elegant a way of counting the possible trees it was. Basically a very nifty way to derive the catalan numbers. then I got to the joyal paper and the fun ended there due to the language barrier
04:23:39 <bollu> tsahyt: ah, I see
04:24:19 <bollu> merijn, tsahyt: is there a way to generalise this to n-hole conexts?
04:24:34 <bollu> would the double derivative work?
04:25:29 <tsahyt> you mean in order to derive zippers?
04:26:07 <bollu> tsahyt: yes, with "n" contexts though
04:26:10 <bollu> not just 1 context
04:26:35 <tsahyt> I don't know, this is all stuff that I've just filed away under "it exists" and didn't get to study properly yet.
04:26:45 <tsahyt> I just remembered where I had seen it
04:27:13 <bollu> I see
04:27:21 <bollu> well, thanks for the reference in any case
04:27:22 <bollu> :)
04:27:57 <tsahyt> you're welcome. for the purely combinatorial aspects, there's also a textbook. analytic combinatorics. I meant to do the coursera course of the same name last winter but somehow it never started
04:28:23 <tsahyt> it is (or was?) freely available on the internet
04:31:26 <tsahyt> bollu: purely by intuition I would say that you'd be looking at the analogue of partial derivatives ∂x∂yT. but I have no idea whether order matters here or not, etc.
04:31:47 <tsahyt> if those are really well behaved derivatives, it shouldn't.
04:32:30 <tsahyt> great, now I became interested in it again. too many things to learn, too little time
04:33:20 <bollu> tsahyt: I will probably blog about this if I find it useful for what I am trying to do :)
04:33:26 <bollu> tsahyt: so I could link you to that
04:33:40 <tsahyt> that'd be great, thank you!
04:33:45 <CtrC> so what are arrows good for?
04:34:06 <tsahyt> CtrC: they're just an alternative way of structuring computations
04:34:21 <CtrC> well, this alternative has tohave some benefits
04:34:30 <CtrC> otherwise it is equivalence
04:34:43 <tsahyt> they are equivalent to monads once you bring ArrowApply into it
04:34:53 <tsahyt> hence why every monad gives rise to an arrow
04:35:18 <tsahyt> but when you leave that out they are less powerful than monads
04:36:12 <tsahyt> which can be desireable sometimes. e.g. arrowized FRP came along partly because it allowed controlling the time leaks that can arise when handing out a monadic interface
04:36:57 <tsahyt> while I'm already dropping references today: Lindley, Wadler, and Yallop, “Idioms Are Oblivious, Arrows Are Meticulous, Monads Are Promiscuous.”
04:37:23 <CtrC> wiki book claims arrows are more general than monads
04:37:32 <systadmi1> ello
04:37:56 <merijn> CtrC: tbh, Arrows have mostly fallen out of favour
04:38:25 <tsahyt> CtrC: more general doesn't mean more powerful
04:38:35 <merijn> CtrC: It turns out that some other classes capture many of the desirable features of Arrows, leaving them rather unpopular as of late
04:38:50 <tsahyt> merijn: did Applicatives turn up after Arrows?
04:38:58 <merijn> CtrC: The relevant classes being Applicative, Category, and Profunctor
04:39:06 <tsahyt> oh right, Profunctor.
04:39:15 <tsahyt> I've always thought of these as arrows in disguise though
04:39:43 <merijn> tsahyt: Yes
04:39:53 <merijn> The Arrow paper appears to date to 2000
04:39:59 <merijn> Applicative was discovered in 2004
04:41:02 <tsahyt> so many abstractions. meanwhile I'm still amazed just by how many things are monoidal in nature
04:41:49 <CtrC> no so many abstractions, basically containers and functions
04:41:57 <CtrC> not*
04:42:12 <ertes> tsahyt: time leaks were not an API problem…  we now have monadic FRP without time leaks
04:42:22 <ertes> they were a problem with semantics
04:43:51 <merijn> I always find it funny how fundamental Applicative is (even when I just started with Haskell), despite being such a recent discovery
04:45:06 <bollu> tsahyt: if you differentiate this: data Rose a = Rose a [Rose a]. you wind up with Rose' a = [(Bool, Rose a)]
04:45:23 <bollu> I have no idea how to interpret this as a "one hole context" for a Rose tree
04:45:27 <bollu> any ideas? merijn as well
04:45:50 <tsahyt> ertes: I remember you talking about how >>= allows depending on all former values. I guess that's more of a space leak then though
04:45:52 <CtrC> bollu: how do u carry diffenetiation on data definitions?
04:46:01 <bollu> CtrC: there's a paper on it :D
04:46:14 <CtrC> it can not be differential, there is no limit
04:46:16 <bollu> CtrC: check these blog posts out: http://chris-taylor.github.io/blog/2013/02/10/the-algebra-of-algebraic-data-types/
04:46:23 <bollu> CtrC: yeah, it's a "formal" notion of differentitaion
04:46:29 <bollu> CtrC: it's not related to analysis
04:47:43 <ertes> tsahyt: that's only related to trying to implement automaton-based FRP using a monadic interface
04:48:02 <ertes> but there are other, usually graph-based, implementations that don't have that caveat
04:48:16 <ertes> e.g. reactive-banana and reflex
04:48:20 <bollu> hm, I think you can use the bool to tag if it is "above" or "below". I'm not sure
04:48:52 <tsahyt> ertes: you mentioned you were working on an automaton-based implementation that circumvented this problem somehow. how's it going?
04:48:59 <lyxia> bollu: it is related to analysis
04:49:08 <bollu> lyxia: how so?
04:49:16 <bollu> lyxia: there's no continuity or whatever
04:49:23 <ertes> tsahyt: i've been looking for years, and my conclusion is that it's likely impossible
04:49:29 <CtrC> bollu: that blog post talks about algebra of data types, no derivatives mentioned
04:50:04 <lyxia> A combinatorial species is associated with a formal series, and when the corresponding power series converge, operations on real/complex functions reflect operations on combinatorial species
04:50:10 <bollu> CtrC: go to the second and third blog posts
04:50:18 <bollu> lyxia: hm, really? that is quite neat
04:50:26 <bollu> lyxia: I did not know about that, thanks for the pointer
04:50:44 <tsahyt> ertes: that is disappointing.
04:50:46 <lyxia> and the presence of singularities in these functions tell you about the asymptotic growth of the series
04:51:11 <tsahyt> ertes: about the semantics giving rise to the problem, are you talking about conal's original FRP semantics?
04:51:34 <bollu> lyxia: interesting, it seems the "pointing" operation is similar
04:51:49 <CtrC> bollu: funny enough, i came across this talk on youtube today.
04:51:54 <merijn> ertes: The semantics are solved? Any references?
04:51:58 <bollu> CtrC: the same talk?
04:54:18 <CtrC> yes, algebra of datatypes
04:54:31 <CtrC> being insightful idea, seems there is no outcome of it?
04:55:07 <lyxia> Boltzmann generators are based on this.
05:01:16 <CtrC> based on algebra of types? in original article i can hardly find any mention of ADT
05:04:08 <CtrC> in article they talk about lablled structures from combinatorial theory, perhaps it has some connection to ADT
05:05:10 <lyxia> They talk about sum/product/fixpoint, which correspond to operations that generate standard ADTs.
05:05:36 <ertes> tsahyt: pretty much…  i don't think there are any time leaks left
05:05:52 <ertes> merijn: not to any papers, sorry, but the reflex semantics should not have any time leaks
05:06:24 <ertes> 'hold' is time-capped, so you can't refer to event occurrences from the past
05:06:50 <ertes> and there is no way to refer to specific points in time
05:11:04 <CtrC> anyone knows what happened to this blog : http://www.twanvl.nl/blog/ ?
05:11:14 <CtrC> internal server error on every post
05:13:36 <lyxia> I can see the posts fine.
05:14:07 <merijn> Same here
05:15:05 <CtrC> ty
05:17:13 <spatial> Want to know if case instead of if in http://lpaste.net/354138 changes the logic.
05:19:05 <spatial> How do they flow ?
05:21:18 <spatial> If x == -1.0 there are 4 conditions inside.
05:22:02 <vaibhavsagar> hey, can I add a haskell package to stack's global pkgdb?
05:22:45 <vaibhavsagar> I realise this isn't what stack is meant for but I have these ihaskell-display modules that I want to be accessible from IHaskell and I can't see a better way to do it
05:24:58 <Athas> Oh, Accelerate 1.0 is out.  Gotta try it.
05:28:53 <spatial> How would one code this lisp in haskell ? http://lpaste.net/354139
05:29:36 <stevenxl> Hi folks. I am trying to run the command cabal install snap on a VPS. Is that command supposed to take up all my memory?
05:31:14 <liste> stevenxl: how much memory is there?
05:31:59 <stevenxl> liste: only about 512mb
05:32:02 <stevenxl> It's a small VPS. 
05:34:28 <sm> "supposed to" is a bit strong, but yes that's normal
05:34:50 <stevenxl> Cool.
05:34:51 <stevenxl> Thanks
05:34:56 <stevenxl> I'll use a bigger VPS. :-)
05:35:15 <merijn> stevenxl: Alternatively, you could compile in a local VM and just copy the binary to the VPS
05:35:42 <sm> third option, fiddle with +RTS -M... flag
05:35:49 <merijn> stevenxl: GHC is...not known for being considerate about how much RAM it consumes during compilation :)
05:36:02 <merijn> So I would avoid running it on tiny VPS's
05:36:10 <sm> and install deps with several commands, not just one
05:37:25 <Athas> stevenxl: you can also turn off optimisations.
05:37:41 <Athas> I don't remember the cabal stanza, but I sometimes use 'stack --fast' to compile things on my small VPS.
05:37:48 <Athas> It will run slowly, of course.
05:38:07 <Gurkenglas> spatial, why are you porting that reinforcement learning thing from sutton's book to Haskell?
05:39:34 <spatial> Gurkenglas: I don't know lisp very well. Learning ML using haskell. Why ?
05:40:15 <spatial> Plan to use Haskell bindings with TensorFlow later.
05:42:04 <Gurkenglas> Because the Haskell code in the post (to other readers: http://codereview.stackexchange.com/questions/159329/recinforcement-learning-example-chap-1-from-suttons-book ) has poor quality and you said you dont want code quality advice and I'm trying to find a way to combat this madness
05:43:06 <Gurkenglas> If you said something like "the guys in the project I want to add this to know Haskell but not Lisp" I could have said that you want to improve the quality if they aren't to run screaming
05:43:23 <Gurkenglas> At or from you, I don't know :D
05:44:24 <spatial> Gurkenglas:Please:-) One follows one's path.Can't learn in a day.
05:44:45 <Gurkenglas> That's fine, I just want to be allowed to tell you how to improve the quality
05:45:24 <spatial> Please comment there. That is fine.
05:46:02 <spatial> RL itself is hard and I do it using haskell as a beginner.
05:46:14 <Gurkenglas> Start by removing the portions of code that aren't used, like fun, store, retrieve, getrow, getcolumn, boardsize, the gloss stuff
05:46:44 <nbro> what’s up dudes?! :D
05:47:17 <Gurkenglas> Next, replace the names like "magicsquare" and "magicnumber" by something that tells the reader what they do
05:51:51 <nbro> apparently Haskell was to be called curry, but there was a problem regarding the usage of that name because of copyright issues, if I’m not wrong, but absurdely now we also have a programming language called curry…
05:52:07 <nbro> whatever
05:52:45 <Cale> huh?
05:52:49 <nbro> times have changed
05:52:54 <Cale> I'm not sure about that story
05:53:12 <nbro> Cale: I read it somehwere
05:53:13 <c_wraith> I recall something like it from Being Lazy with Class
05:53:34 <Taneb> I think I read it in the History of Haskell paper?
05:53:36 <Cale> They went to Haskell Curry's widow to ask her if she'd be okay with them using the name Haskell.
05:54:07 <c_wraith> yeah, section 2.4 of Being Lazy With Class says they wanted to call it Curry
05:54:29 <merijn> Ironically, Haskell Curry never liked the name Haskell :)
05:54:43 <c_wraith> But apparently the reason they went with Haskell instead was...  fear of really bad puns about curry?
05:54:45 <c_wraith> That's odd
05:54:51 <merijn> At least, that's what his widow said according to Lennart :)
05:55:00 <c_wraith> http://haskell.cs.yale.edu/wp-content/uploads/2011/02/history.pdf
05:55:42 <mauke> they should've called it Schönfinkel
05:58:56 <bollu> Cale: do you know stuff about the derivative of type == one hole context stuff?
05:59:04 <bollu> too many "stuff"s in that sentence
05:59:12 <bollu> Cale: I was looking for reading references. 
05:59:26 <bollu> Cale: it looks like there is a connection with the thing you explained to me once: analytic combinatorics?
06:03:28 <bartavelle> Why doesn't this compile ? http://lpaste.net/354141
06:03:54 <bartavelle> error: • Couldn't match type ‘RegType a0’ with ‘RegType a’ Expected type: Register a -> Expr (RegType a) Actual type: Register a0 -> Expr (RegType a0)
06:05:35 <Cale> It wouldn't be clear which type 'a' was
06:06:05 <bartavelle> ah you mean when I use it with an abstract 'a'
06:06:13 <Cale> Even with a particular 'a'
06:06:31 <bartavelle> why wouldn't it be clear with a particular 'a'?
06:06:50 <Cale> Like, suppose Register X = Int, and RegType X = String
06:07:01 <bartavelle> AHH
06:07:02 <Cale> and suppose that Register Y = Int and RegType Y = Double
06:07:12 <bartavelle> yeah obviously :/
06:07:28 <bartavelle> looks like I just can't write that :(((
06:07:43 <Cale> You could have it take a Proxy a
06:07:55 <bartavelle> most regtypes for most a's will be Word32 or Word64
06:08:22 <bartavelle> ah yeah
06:09:34 <bartavelle> works, thanks, I didn't realize until now how why the term "injective" was used with type families
06:10:07 <Cale> Another way would be to have a data family which you'd make a new trivial constructor for with each instance
06:10:21 <Cale> (which would be like Proxy, but with nicer names maybe)
06:10:31 <bartavelle> proxy is ok to me
06:11:09 <Cale> like,  data family Architecture arch
06:11:31 <Cale> data instance Architecture X86 = AX86
06:12:09 <Cale> and then you'd be able to write something like  EReg :: Architecture a -> Register a -> Expr (RegType a)
06:12:14 <bartavelle> ahh
06:12:21 <bartavelle> yeah it is indeed nicer
06:12:37 <bartavelle> (except I'm not gunning for x86 yet :p )
06:12:59 <c_wraith> going straight to x64? :P
06:13:09 <bartavelle> I'll start with EBPF :)
06:14:58 <bartavelle> I'm not sure I'll be able to express all the instruction semantics with a GADT, that is just a PoC
06:24:01 <Alex____> Hello
06:27:50 <vaibhavsagar> hi there Alex____
06:32:35 <Alex____> I've this problem where I have created a directed acyclic graph (which can have different weights) but when I try to calculate the longest path it just doesn't work :|
06:33:08 <Alex____> So if anyone would be interested in taking a look I got some source code because I'm stuck
06:37:47 <qmm> geekosaur: thanks for responding. what is the search term needed to find all instances of functor in hackage with hayoo?
06:38:27 <sea_wulf> Alex____: I don't know how much help I will be, but I would love to take a look and see what can be done.
06:41:49 <okra_> I've been reading Oleg's FBackTrack monad (http://okmij.org/ftp/Haskell/FBackTrack.hs) and had a couple questions, if anyone's familiar with that
06:43:05 <okra_> firstly, I didn't understand what `Incomplete` was used for (why it couldn't just be a "normal" stream, `Stream a = Nil | Choice a (Stream a)'), so I annotated some stuff with `trace' (http://lpaste.net/354142) but it's not printing things in the way I originally expected
06:44:26 <Alex____> Okay sea_wulf, can I message you private somehow or...?
06:44:54 <c_wraith> okra_: that trace has to evaluate the entire stream...
06:45:06 <c_wraith> okra_: did you maybe just want to show the first constructor?
06:45:39 <Taneb> Alex____, most IRC clients have a "/msg [name] [private message]" command
06:46:16 <sea_wulf> Alex____: yea just do /msg nick message and host it on pastebin or something.
06:48:13 <dominik_> hi, I'm using the most recent haskell-mode from melpa in emacs
06:48:34 <dominik_> everything works quite well, except that hlint tells me that it cannot find certain modules
06:48:41 <okra_> c_wraith: yeah, I suppose I wanted to show the first n constructors
06:48:59 <dominik_> however, when I then compile the module using haskell-interactive-mode, ghc finds everything
06:49:04 <dominik_> so it seems to be an isolated problem with hlint
06:49:12 <dominik_> has anyone had a similar issue?
06:49:15 <Alex____> Hmm, it worked for one message ^^ Now it doesnt say anything
06:50:26 <c_wraith> okra_: then you're going to have to write a function to only look that far ahead and use it in the trace. :)
06:51:36 <c_wraith> okra_: I'd be somewhat worried about even that, though.  Looking n constructors ahead requires recursive evaluation, which will probably result in recursive tracing, and you're back to an infinite loop.
06:54:57 <orion> okra_ said: "Stream a = Nil | Choice a (Stream a)" -- How is this different from the [] data type?
07:00:12 <nh2> tomjaguarpawaway: I don't understand what the point of ProductProfunctor is. Reading the docs, it seems like it is simply a data type that is both Applicative and Profunctor. Then, why is there need for an extra class for it, why would using `(Applicative (p a), Profunctor p) => ... p ...` not be enough?
07:02:50 <kgadek> I'm tired but Applicative (p a) seems to be related to second param, while the docs of ProductProfunctor mention first param
07:03:08 <kgadek> but I may say rubbish right now, so be warned
07:04:24 <okra_> orion: i think it would be in the MonadPlus instance -- `Choice a r `mplus` r' = Choice a (r `mplus` r') `
07:05:58 <parsnip> is `:i Monoid` maybe the closest built-in local thing to lambdabot's `@instances Monoid` ? 
07:06:19 <parsnip> easy to install things like `hoogle` count :)
07:07:22 <lyxia> nh2: you will need "forall a. Applicative (p a)", which you currently can only write with a hack from the constraints package
07:12:06 <dawehner> Hi. I try to understand why on Monoids the type need to be more explicit than on Functors on Applicatives: https://gist.github.com/dawehner/0f482284225f4a65d53c8f4388fe8bfc
07:13:07 <Taneb> dawehner, short answer: a Monoid is a thing a type can be. A Functor is a thing a type constructor (a function from types to types) can be
07:13:19 <Taneb> List is a function from types to types, you need to give it a type to get a type
07:18:58 <ocharles> Any of the LambdaCube guys here?
07:22:18 <nh2> lyxia: thanks
07:25:12 <nbro> what’s the problem with this function: https://pastebin.com/utmPksnA?
07:25:55 <Cale> nbro: Well, it doesn't handle the case of an empty list
07:26:13 <Cale> nbro: and it's also really weird
07:26:31 <Cale> It gives an empty list in the case that the input list is length 1
07:26:36 <nbro> wait, I got it wrong, indeed, the second guard I wanted to check for the emptiness of the list not xs
07:26:49 <Cale> The pattern match (x:xs) implies that the list is nonempty
07:26:56 <nbro> in that case I may want to use s@(x:xs)
07:27:08 <Cale> That pattern still won't match an empty list
07:27:21 <Cale> You want to add another case above this one, like  takeInt a [] = ...
07:27:51 <nbro> why wouldn’t it match the empty list?
07:27:53 <Cale> If you made the pattern s@(x:xs), then null s would simply always be False
07:28:07 <Cale> Because (x:xs) is a list which starts with the element x, and whose tail is xs
07:28:21 <Cale> Such a list can't be empty, because it contains the element x
07:29:00 <Sornaensis> (:) is a list constructor
07:29:03 <Sornaensis> :t (:)
07:29:04 <lambdabot> a -> [a] -> [a]
07:29:15 <Sornaensis> works like any other constructor in a pattern match
07:29:17 <nbro> ok
07:29:23 <nbro> right
07:29:36 <CtrC> list continuator :) takes [a]
07:30:28 <Taneb> CtrC, I've never heard that term used like that before
07:30:48 <nbro> anyway, this gives me a parse error: https://pastebin.com/xCXS2Kct
07:31:01 <CtrC> function which takes [a] obviously does not make list :)
07:31:11 <nbro> Cale: i.e. if I simply handle the case you mentioned
07:31:24 <Taneb> CtrC, what about let x = 1:x in x?
07:31:30 <Taneb> x is an entirely new list there
07:31:40 <nbro> opps
07:31:49 <nbro> sorry
07:32:04 <nbro> switching between programming languages from day to day, this is the result
07:32:14 <Sornaensis> > let x = 1:x in x
07:32:16 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
07:32:18 <Cale> Yeah, the x:xs needs to be in parens there
07:32:23 <nbro> yeah
07:32:30 <nbro> ;)
07:32:32 <Sornaensis> > let x = 1:y; y = 0:x  in x
07:32:35 <lambdabot>  [1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0...
07:32:50 <Cale> > let evens = 0 : map (+1) odds; odds = map (+1) evens in evens
07:32:53 <lambdabot>  [0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52...
07:33:28 <Sornaensis> lol
07:33:36 <Cale> > let primes = 2 : filter isPrime [3,5..]; isPrime n = all (\p -> n `mod` p /= 0) (takeWhile (\p -> p*p <= n) primes) in primes
07:33:39 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
07:33:43 <CtrC> infinite lists are best friends to start talking about lists, sure :)
07:33:55 <CtrC> :t (:)
07:33:57 <lambdabot> a -> [a] -> [a]
07:35:32 <CtrC> :t Just
07:35:34 <lambdabot> a -> Maybe a
07:36:10 <CtrC> pretty clear who is constructor and who is not.
07:36:21 <WarmCookie> :t pure @Maybe
07:36:23 <lambdabot> error:
07:36:23 <lambdabot>     Pattern syntax in expression context: pure@Maybe
07:36:23 <lambdabot>     Did you mean to enable TypeApplications?
07:40:05 <CtrC> :t pure 5
07:40:07 <lambdabot> (Num a, Applicative f) => f a
07:43:15 <CtrC> :t pure
07:43:16 <lambdabot> Applicative f => a -> f a
07:43:28 <CtrC> this looks like list constructor.
07:43:45 <c_wraith> > pure 5 :: [Int]
07:43:47 <lambdabot>  [5]
07:44:06 <c_wraith> It creates singleton lists, sure.  But it does a lot more, too.
07:44:13 <Taneb> CtrC, yet that is implemented in terms of (:) and []
07:44:19 <WarmCookie> CtrC: It's a more general version, provided by Applicatives.
07:44:20 <Taneb> pure x = x : []
07:44:36 <CtrC> [] is list on its own :)
07:44:48 <dawehner> Taneb: interesting, I think I get it
07:45:11 <CtrC> :t [[]]
07:45:12 <lambdabot> [[t]]
07:47:05 <qmm> this seems like a hack: https://sidburn.github.io/blog/2016/03/24/higher-kinded-polymorphism
07:47:37 <qmm> wouldn't you want your language to just give you this functionality?
07:48:11 <Sornaensis> F# doesn't have polymorphic functions?
07:48:48 <c_wraith> F# doesn't have anything like type classes.
07:48:59 <Sornaensis> you can do that in Rust with traits
07:49:02 <c_wraith> It also doesn't have abstraction over higher-kinded types.
07:49:08 <Sornaensis> I wish they'd add higher kinded types to rust already
07:49:27 <qmm> i suppose you could start building your own library that has functors, applicatives, monoids, monads, comonads (um, are these called higher kinds?) and try pushing this library as best practice to other developers
07:50:29 <qmm> there's a great chance that you'll use a library that doesn't use your library though and then how do you extend their work support your style?...
07:50:37 <Sornaensis> for what language
07:51:09 <c_wraith> this F# article is weird.  It claims to talk about higher-kinded polymorphism, but all the examples are about type classes.
07:51:12 <qmm> any language like fsharp that doesn't have "abstraction over higher kinded types"
07:51:13 <Sornaensis> you need hkts to implement functors and monads in a statically typed language
07:51:29 <dolio> Yeah, I don't see any higher kind stuff there.
07:51:43 <qmm> c_wraith: i guess "abstraction over higher kinded types" is called higher kinded polymorphism
07:51:51 <Sornaensis> otherwise you end up with abstractions that don't actually work
07:52:40 <qmm> an example of higher kinded types are [a], correct?
07:52:44 <c_wraith> No
07:52:49 <Sornaensis> @kind []
07:52:49 <qmm> s/are/is
07:52:50 <lambdabot> * -> *
07:52:51 <c_wraith> [] is higher-kinded.  [a] is not
07:52:58 <Sornaensis> @kind [a]
07:53:00 <lambdabot> error: Not in scope: type variable ‘a’
07:53:03 <Sornaensis> @kind [Int]
07:53:05 <lambdabot> *
07:53:06 <balor> I often end up with `data Manufacturer  = HONDA | DUCATI`  and then `data Bike = Bike {manufacturer:: Manufacturer}` types in my applications.  How do I `toJson` Manufacturer to a value?  I've tried `toJSON HONDA = value "honda"` But I'm unconvinced this is the right approach.
07:53:28 <qmm> alright, [] / List is higher kinded 
07:53:34 <brynedwards> instance ToJSON?
07:53:56 <Sornaensis> higher kinded types are like type functions
07:54:02 <Sornaensis> @kind StateT
07:54:04 <lambdabot> * -> (* -> *) -> * -> *
07:54:08 <balor> brynedwards, Does it make sense to have Manufacturer as an instance of ToJSON that returns a value rather than an object?
07:54:17 <Sornaensis> they take other types to make 'concrete' types
07:54:58 <dolio> qmm: c_wraith's point is that the 'novel' thing in that article is constrainted polymorphism, not higher kinds.
07:54:59 <Sornaensis> you need this to properly implement functors, because functors represent function objects that wrap some contained type-- where the contained type may change with fmap
07:55:05 <dolio> All the variables are still kind * in the article.
07:55:29 <qmm> but then a functor is a single level of abstraction higher than []?
07:55:43 <Sornaensis> functor is a type class
07:55:58 <dolio> Just instead of 'forall a' they have 'forall a with (+) member'.
07:56:00 <brynedwards> balor: I would. You'd end up with something like '{ "bike": { "manufacturer": "honda": } }'
07:56:13 <Sornaensis> so yea, many types can implement it like you might implement an abstract class in OOP
07:56:24 <Cale> Sornaensis: function objects?
07:56:34 <Cale> what
07:56:42 <Sornaensis> eh yea in the mathematical sense
07:57:01 <c_wraith> qmm: [] is a concrete type.  Functor requires the ability to abstract over *any* type of kind * -> *
07:57:28 <brynedwards> balor: The beginning of the Aeson docs show to generate generic ToJSON instances, see https://hackage.haskell.org/package/aeson-1.1.0.0/docs/Data-Aeson.html
07:58:17 <Cale> In the mathematical sense, they consist of a function from objects (of a category) to objects (of another), as well as a corresponding function from arrows to arrows
07:58:19 <balor> brynedwards, thanks
07:58:58 <Cale> Of course, in the case of Haskell, both the categories are going to be the category whose objects are Haskell types, and whose arrows are functions
07:59:42 <Cale> The type-level function f is then the mapping on objects, sending Haskell types to Haskell types
07:59:57 <Cale> and then fmap :: (a -> b) -> (f a -> f b) is the mapping on arrows
08:00:06 <Sornaensis> ah
08:01:08 <WarmCookie> Cale: Is `arrow` just another term for `morphism` ?
08:01:49 <bollu> WarmCookie: I think Cale means "arrow" in the category-theoretic sense
08:01:53 <WarmCookie> Cale: Or do morphisms translate differently in Haskell?
08:01:54 <c_wraith> iirc, arrows are more generic
08:02:09 <c_wraith> and yes, Cale's description was category theory arrows.
08:02:33 <WarmCookie> I see. When I hear arrow I think (->) of Hask.
08:02:34 <dolio> They're just two different names for the same thing.
08:02:38 <Cale> Well, people use the word "morphism" as a synonym for the category theoretical notion of "arrow" too.
08:02:48 <Cale> yeah
08:03:04 <Sornaensis> when you say arrow you mean (->)
08:03:07 <Sornaensis> ?
08:03:33 <Cale> Well, in this context, I mean the more general thing -- arrows are part of the data you specify when you define a category.
08:03:39 <Sornaensis> ah
08:04:04 <Cale> In the case of Haskell, the arrows are (all) functions
08:04:14 <c_wraith> in the category of haskell types, arrows correspond to functions.
08:04:42 <Sornaensis> what is the Arrow typeclass based on
08:04:51 <c_wraith> That's something entirely different
08:04:58 <c_wraith> Hughes Arrows, I believe
08:05:00 <CtrC> talk about smart names.
08:05:16 <Cale> Yeah, sadly, the Arrow type class doesn't quite line up with pre-existing terminology
08:05:27 <bollu> Cale: doesn't "Machine" make more sense for it?
08:05:36 <bollu> Cale: at least, that is the interpretation that made most sense to me
08:05:51 <Cale> "Machine" could mean a whole lot of stuff
08:06:03 <erisco> like ramps and pulleys and stuff
08:06:08 <Sornaensis> make more sense for what
08:06:17 <Cale> When you're naming abstractions, lots of words could do just as well, you just need a consistent tag
08:06:32 <CtrC> erisco: all machines are the same. u justs did not notice.
08:06:35 <bollu> Cale: also, what was the book you had given me for combinatorics? It was like, studying combinatorics with algebra
08:07:02 <bollu> Cale: you told me of the reference when I asked about the "fractional cardinality" stuff
08:07:11 <bollu> Cale: defining the size based on the Aut of an object
08:07:18 <Cale> When F is a Hughes Arrow, the values of type F a b can be seen as arrows in a monoidal category between objects corresponding to a and b.
08:07:32 <Cale> and I believe that's the inspiration for it
08:08:32 <qmm> Cale: your explanation via category theory is much appreciated
08:08:41 <Cale> It's not *just* monoidal categories though, they're particular special sorts of monoidal categories, having the collection of Haskell types as their objects, and with some special relationship to the category of Haskell types and functions, and a bunch of other stuff.
08:09:40 <CtrC> reading cathegory theory stuff is like calculating WHNF in your brain
08:10:04 <erisco> that's what we do as programmers all the time oO
08:16:31 <markasoftware> is there any more haskelly way to do this?
08:16:33 <markasoftware> revOtherWords boop = unwords $ map (\(i, w) -> if mod i 2 == 1 then reverse w else w) $ zip [0..] $ words boop
08:16:35 <markasoftware> to reverse every other word from input
08:17:49 <cocreature> markasoftware: you could consider using zipWith instead of map & zip but it looks like a pretty reasonable solution
08:17:56 <c_wraith> markasoftware: using zipWith and cycle let you simplify a bit.
08:18:22 <markasoftware> oh cool, ill try it with zipwith
08:18:35 <c_wraith> zipWith (\c w -> if c then reverse w else w) (cycle [False, True]) ...
08:18:37 <erisco> > zipWith ($) (cycle [id, reverse]) . words $ "Greetings from the citizens of Earth!"
08:18:39 <lambdabot>  ["Greetings","morf","the","snezitic","of","!htraE"]
08:18:45 <c_wraith> oh, that's better.
08:18:50 <markasoftware> oh coocle, didn't know the cycle function
08:18:52 <c_wraith> if is kind of awful
08:19:00 <c_wraith> cycle over id and reverse is much better
08:19:36 <markasoftware> wow cycling over functions, i wouldn't have thought of that one
08:19:37 <cocreature> oh yeah cycle [id, reverse] is nice!
08:19:55 <ski> > (unwords . concat . map (\ws -> case ws of [w0,w1] -> [w0,reverse w1]; _ -> ws) . chunksOf 2 . words) "The quick brown fox jumps over the lazy dog"  -- markasoftware ?
08:19:57 <lambdabot>  "The kciuq brown xof jumps revo the yzal dog"
08:20:14 <bollu> hahaha, cycling over the functions is so cool
08:20:55 <ski> the `cycle' one is nice, yes
08:21:09 <c_wraith> though..
08:21:10 <nbro> is there a way to simplify this function: https://pastebin.com/NMppjbnY?
08:21:18 <c_wraith> Instead of zipWith ($), you could use zipWith id
08:21:27 <c_wraith> one character shorter and draws more double-takes!
08:21:36 * ski would use `($)' in this case
08:21:47 <cocreature> yeah I think ($) makes the intention clearer
08:23:41 <markasoftware> well thanks guys
08:24:17 <WarmCookie> nbro: I'd either remove the `length` guard or move it elsewhere so that it gets memoized.
08:24:44 <WarmCookie> Each recursive call to dropInt is going to do a complete traversal currently (quadratic).
08:24:56 <Fendor> nbro, the length guard is not neccessary at all imo
08:25:29 <erisco> is this intended as a reimplementation of drop?
08:26:47 <ski> > (onWords . perChunksOf 2) (\ws -> case ws of [w0,w1] -> [w0,reverse w1]; _ -> ws) "The quick brown fox jumps over the lazy dog"
08:26:49 <lambdabot>  "The kciuq brown xof jumps revo the yzal dog"
08:27:59 <Fendor> :t onWords
08:28:01 <lambdabot> ([String] -> [String]) -> String -> String
08:28:35 <nbro> erisco: yes, but for list of integers…
08:28:43 <Fendor> :t (onWords . perChunksOf 2)
08:28:45 <lambdabot> ([String] -> [String]) -> String -> String
08:29:02 <Fendor> sorry, will talk to lambdabot in private 
08:29:16 <erisco> nbro, sorry I don't understand what you mean. dropInt and drop have the same type
08:29:34 <nbro> yeah, it’s intended as a re-implementation of drop
08:29:49 <qmm> how can you use hayoo to query for all instances of the functor instance?
08:30:17 <erisco> well, you can look at the official implementation to compare
08:31:11 <nbro> erisco: the idea is that you could give me some feedback on your practices
08:31:28 <nbro> but what you’re suggesting is also a good thing
08:31:47 <ski> Fendor : `onWords f = unwords . f . words; perWord = onWords . map; onChunksOf n f = concat . f . chunksOf n; perChunksOf n = onChunksOf n . map'
08:32:32 <Fendor> ski, these are interesting functions
08:32:45 <Fendor> ski, i've never seen them before ^^
08:33:08 <ski> one can easily define `onLines f = unlines . f . lines; perLine = onLines . map', &c.
08:33:11 <ski> see
08:33:18 <ski> @where TV
08:33:18 <lambdabot> http://www.haskell.org/haskellwiki/TV
08:33:23 <ski> (the end)
08:33:28 <ski> also
08:33:30 <ski> @where SEC
08:33:31 <lambdabot> http://conal.net/blog/posts/semantic-editor-combinators/
08:35:51 <Fendor> ski, thanks for the links
08:39:14 <Fendor> small question, is there a language extension to access a field in the same way you can do it in elm?
08:39:31 <Fendor> for example
08:39:44 <Fendor> > data T = T {a :: Int, b :: Int}
08:39:46 <lambdabot>  <hint>:1:1: error: parse error on input ‘data’
08:40:06 <Fendor> dammit, can't use lambdabot properly...
08:40:52 <Fendor> @let data T = T {a :: Int, b :: Int}
08:40:53 <lambdabot>  .L.hs:170:1: error:
08:40:53 <lambdabot>      Multiple declarations of ‘T’
08:40:53 <lambdabot>      Declared at: .L.hs:168:1
08:41:02 <Fendor> @let data Example = E {a :: Int, b :: Int}
08:41:03 <lambdabot>  .L.hs:170:18: error:
08:41:03 <lambdabot>      Multiple declarations of ‘a’
08:41:03 <lambdabot>      Declared at: .L.hs:168:12
08:41:22 <Fendor> @let data Example = E {a' :: Int, b' :: Int}
08:41:24 <lambdabot>  Defined.
08:41:43 <Fendor> @let example' =  E {a' = 4, b = 5}
08:41:44 <lambdabot>  .L.hs:171:22: error:
08:41:44 <lambdabot>      Ambiguous occurrence ‘b’
08:41:44 <lambdabot>      It could refer to either ‘Debug.SimpleReflect.b’,
08:41:49 <Fendor> @let example' =  E {a' = 4, b' = 5}
08:41:50 <lambdabot>  Defined.
08:42:07 <Fendor> and now access b' like example'.b'
08:42:21 <ski> > b' example'
08:42:23 <lambdabot>  5
08:42:49 <Fendor> ski, yes, but is there a language extension that lets me use it the other way round?
08:43:31 <Fendor> i feel, that it is more readable than `b' example'`
08:43:34 <ski> > example' & b'
08:43:36 <lambdabot>  5
08:43:41 <Fendor> :t (&)
08:43:43 <lambdabot> a -> (a -> b) -> b
08:44:02 <Fendor> where is that operator defined?
08:44:04 * ski 'd prefer something like the SML syntax, where it'd be :  #b' example'
08:44:15 <ski> @index (&)
08:44:15 <lambdabot> Data.Function
08:44:23 <Fendor> thank you a lot 
08:44:59 * ski wouldn't use `&', personally
08:45:24 <Fendor> mhm, for most people, it would be unexpected, wouldn't it?
08:46:01 <ski> what would be unexpected ?
08:46:28 <Fendor> to use this operator, because most people probably dont use it
08:46:29 <Fendor> ?
08:46:55 <monochrom> So let's use it more so more people will use it.
08:47:09 <ski> i don't think that's a that important criterion when deciding whether to use it
08:47:42 <Fendor> ok, so why wouldnt you use it?
08:47:54 <glguy> Most of the time people won't need any operator at all to apply a function to its argument
08:48:07 <ski> what glguy said
08:48:55 <ski> however, i do think it's a design mistake in Haskell to use the same notation for the field as for the field accessor function
08:49:35 <erisco> lol, was wondering why my program was so awfully slow
08:49:51 <erisco> turns out I had a really slow debug line in it and just forgot
08:49:54 <Fendor> it's not like i need it, but if I have a nested datastructure, id need to destructe it to get a specific value. If i use it like accessor function, personally i feel like it is harder to read 
08:50:02 <ski> whether you write `#x point' or `point .x' is less important. but if `x' is a field of type `Int', then it's confusing that in `x point', `x' now suddenly has type `Point -> Int'
08:50:17 <markasoftware> when would one want to use FastCGI with yesod rather than Warp?
08:50:33 <ski> (especially as in `MkPoint {x = 42,...}', `x', and `42', has type `Int')
08:51:56 <erisco> I am just annoyed by the collision
08:52:06 <ski> Fendor : anyway, i also think that many people use `$' way too much ..
08:52:11 <Fendor> ski, yes, i think, thats exactly what my problem is 
08:52:32 <Fendor> ski, really? i thought it was good style to use as few parenthesis as possible
08:52:42 <glguy> Fendor: not particularly
08:52:45 <ski> there's nothing wrong with brackets
08:52:51 <erisco> I like using parentheses
08:53:04 <monochrom> I attribute it to programmers choosing to be programmers because they hate math.
08:53:10 <Fendor> yeah, sometimes me too, except for nested brackets
08:53:29 <ski> something it's nicer to write `(foo . bar x y . baz z) (...)', though. i wouldn't write `foo $ bar x y $ baz z $ ...'
08:53:30 <erisco> I actually changed to rarely using $
08:54:05 <erisco> I just use it, from what I can recall, unapplied or as  foo $ \x -> ...
08:54:15 <Fendor> well, yes, totally agree on that example, i never use more $'s than one 
08:54:18 <Fendor> in one expression
08:54:29 <erisco> because you can have something like  foo $ \x -> bar $ \y -> ...
08:54:40 <ski> basically, i mostly use `$' when it's followed by a lambda, or a keyword (`do',`let',`case',`if') .. imho, it would be nicer to change the parsing rules so that a `$' wouldn't be needed here. then most of my uses of `$' would be gone
08:54:56 <erisco> makes a particular formatting convenient
08:54:57 <MitchellSalad> I would write `(foo . bar x y . baz z) (...)` as `foo (bar x y (baz z ...))`
08:55:16 <ski> MitchellSalad : it depends, but yes, that can also be nice
08:55:34 <erisco> the former is SEC style
08:55:45 <MitchellSalad> if you can't eta reduce, the former is obfuscatory
08:56:05 <monochrom> In math, (x + y) * (sqrt z - t) is a perfectly readable expression. But no, programmers hate math and call it unreadable, they have to write multiply $ (add $ x $ y) $ (minus $ (sqrt $ z) $ t), and that's their idea of readable.
08:56:08 <ski> SEC is rather `(foo . bar x y . baz z) (...) (...)'
08:57:54 <robertkennedy> How can I program ghc/ghci to open a page in chrome?
08:58:03 <Fendor> ok, to sum up my initial question, there is no way to use an accessor function in the same way elm does and it would be recommended to use (&) as a replacement?
08:58:30 <glguy> It would be recommended to get used to using the field accessors in prefix position, otherwise you can use &
08:58:32 <Fendor> *it would not be 
08:58:35 <robertkennedy> Or the default browser
08:59:06 <Fendor> glguy, i was used to it, then i tried elm and now i'm thinking that it is easier to read ^^
08:59:53 <Fendor> robertkennedy, maybe this would work for you? https://hackage.haskell.org/package/open-browser
09:00:36 <robertkennedy> Ty I'll check it out
09:01:12 <Fendor> robertkennedy, it's only one function, i guess, it wont take you long to see if it works for you
09:10:13 <ertes> robertkennedy: you can invoke shell commands in GHCi via :!
09:27:52 <unclechu> hey guys, any ideas why i can't connect as client to DBus in Haskell on FreeBSD? here is minimal example that reproduces it https://pastebin.com/ejruLmKi
09:28:14 <unclechu> and here is error i get: `SocketError {socketErrorMessage = "Authentication failed", socketErrorFatal = True, socketErrorAddress = Just (Address "unix:guid=53252465d2726f11957f8b9d58de79ab,path=/tmp/dbus-jUIv1mTBAV")}`
09:29:11 <unclechu> also I start session dbus daemon in `~/.profile`: `DBUS_SESSION_BUS_ADDRESS=`dbus-daemon --fork --session --print-address``
09:31:07 <unclechu> i can call `dbus-send` well https://pastebin.com/Ey9d52NK
09:31:25 <erisco> how might I find the nth root of an integer
09:31:41 <unclechu> it happens only on FreeBSD
09:36:45 <ReinH> erisco: does \n -> (** (1/n)) suffice?
09:36:53 <erisco> :t (**)
09:36:54 <lambdabot> Floating a => a -> a -> a
09:36:56 <erisco> no
09:37:13 <ReinH> convert the integer to a Double?
09:37:18 <erisco> that overflows
09:37:44 <ReinH> To some other Floating member that doesn't overflow?
09:38:14 <erisco> well it might be in range, I'll have to check how large the exponent is allowed
09:39:06 <ReinH> anyway, the easiest way to find an nth root is to exponentiate by the reciprocal of n
09:39:20 <ReinH> ofc that won't find all roots
09:41:49 <erisco> yeah I think it'll keep enough precision
09:42:00 <erisco> thankfully I don't need a precise answer
09:42:51 <infandum> I think there's a bug in https://wiki.haskell.org/GHC/Memory_Footprint
09:43:08 <infandum> Should IntMap be (3N + 5(N-1) words) + N * sizeof(v) 
09:43:20 <infandum> Right now it's just (3N + 5(N-1) words) + sizeof(v) 
09:47:58 <eugenez> Hello friends! Let's say I have a = "10" and b = "1" how do I get ["11", "01"] ? I know list comprehension works, but seems a bit unwieldy
09:48:36 <eugenez> all combinations if what I'm looking for
09:48:52 <ski> > [[x,y] | x <- "10",y <- "1"]  -- ?
09:48:55 <lambdabot>  ["11","01"]
09:49:12 <ski> > sequence ["10","1"]
09:49:14 <lambdabot>  ["11","01"]
09:49:18 <erisco> beat me to it D:
09:49:30 <eugenez> Yeah, like I said, list comprehesion works, but what if I have unspecified number of inputs?
09:49:47 * ski waits
09:51:02 <eschnett> eugenez: what output do you expect if you have a=“12” and b=“3”?
09:51:28 <eugenez> ["13", "23"]
09:51:28 <ski> > ["13","23"]
09:51:31 <lambdabot>  ["13","23"]
09:52:27 <eugenez> Cartesian product I believe it is called?
09:53:19 <erisco> yes
09:54:04 * ski . o O ( `sequence :: Vec m (Vec n a) -> Vec (Vec m n) (Vec m a)' )
09:55:05 <erisco> huh?
09:57:28 <ski> (replace `Vec m n' by `Vec m (Fin n)', if you insist)
09:57:59 <erisco> :k Vec
09:58:01 <lambdabot> error:
09:58:02 <lambdabot>     Not in scope: type constructor or class ‘Vec’
09:58:02 <lambdabot>     Perhaps you meant ‘Rec’ (imported from Lambdabot.Plugin.Haskell.Eval.Trusted)
09:58:25 <ski>   Vec :: Nat -> * -> *
09:58:25 <erisco> hm, not in scope... but I don't see why it isn't Vec n (Vec m a)
09:58:59 <ski> how many elements would `sequence ["ab","cd","ef"]' have ?
09:59:32 <eugenez> Wow! Yep, looks like sequence is what I was looking for!!
09:59:53 <erisco> I am just following the types
10:00:10 <eugenez> Thank you very much!
10:00:26 <ski> eugenez : cheers :)
10:02:10 <ertes> ski: your thought bubble has a kind error =)
10:04:14 <ski> ertes : yes (more than one), it's supposed to give an idea :)
10:04:51 <erisco> Vec m (Vec n a) -> Vec (n ^ m) (Vec m a)  where n ^ 0 = 0
10:05:01 <ski> yes
10:05:39 <erisco> I don't understand  Vec m (Vec n a) -> Vec (Vec m n) (Vec m a)
10:05:49 <ertes> that doesn't sound right…  it doesn't even fit the type of 'sequence'
10:06:07 <ertes> > sequence ["ab", "cd", "ef"]  -- gives two lists of 3
10:06:09 <lambdabot>  ["ace","acf","ade","adf","bce","bcf","bde","bdf"]
10:06:12 <ertes> oh, no
10:06:20 <erisco> I know, I said that, but if we wanted to write the n-ary Cartesian product for Vec this is the type we're looking for
10:06:32 <ski> those elements are indexed by vectors of the shape `[i0,i1,i2]', where `i0',`i1',`i2' are elements of `Fin 2'
10:07:11 <ertes> yeah, 'sequence' doesn't work
10:07:30 <ertes> at least not the one from Traversable
10:07:36 <ski> the idea is to keep the behaviour of `sequence', not the type
10:08:17 <ski> (and i wasn't that clearly distinguishing between natural numbers and finite types)
10:08:41 <ertes> a size-indexed version of Traversable could do it, along with a kind-level equivalent of Num
10:09:11 <erisco> ski, how do I also think about the kind change to Vec you've made?
10:09:29 <ski> hm, which kind change ?
10:09:29 <erisco> and why a vector of Fin n at all?
10:09:41 <erisco> you wrote  Vec (Vec m n) (Vec m a)
10:09:56 <erisco> or maybe changed that to  Vec (Vec m (Fin n)) (Vec m a)
10:10:12 <ski> well, if `n' is a `Nat', then `Vec m n' is a kind-error, but `Fin :: Nat -> *', so `Vec m (Fin n)' isn't
10:10:31 <erisco> Vec m (Fin n)  is not a Nat
10:10:32 <ski> however, `Vec (Vec m (Fin n)) a' is still a kind error, so `Vec (n ^ m) a' is better still
10:11:05 <ski> (or we could just say `Vec :: * -> * -> *; Vec n a = n -> a')
10:12:50 <ski> the point was to ponder this way of typing a version of `sequence', and think about things it might remind one of
10:19:33 <erisco> what is the point of duplicate record fields if it won't disambiguate the fields for you, ugh
10:20:32 <erisco> it does not even disambiguate with field puns
10:25:48 <geekosaur> it's a first step
10:26:18 * geekosaur is just waiting for full OverloadedRecordFields
10:26:39 <cocreature> will OverloadedRecordFields make it into 8.2?
10:26:45 <cocreature> I’ve lost track of its status
10:27:56 <geekosaur> IIRC more of the stuff needed for it will, but the full ORF is not there yet
10:28:24 <geekosaur> oh, huh, updated status page says full ORF *is* making it
10:29:01 <geekosaur> wait, no, looking more closely, still not the full extension, just more of the changes needed for it
10:29:05 <geekosaur> ah well
10:29:16 <geekosaur> "soon"
10:33:50 <ertes> the year is 2025, GHC 12 was just released…  you can hear the cheers of haskell programmers around the globe and on the moon for the final arrival of dependent types, uniqueness types and automatic proof search…  suddenly a blue telephone booth appears out of nowhere and a strange guy comes out: "hey kid, is the record problem solved yet?"
10:34:20 <sm> lol
10:35:01 <sm> cue Dr. Who theme music
10:35:45 <ystael> if SPJ were actually the doctor, or vice versa, it would explain so much
10:36:21 <ertes> (to anyone who didn't get the reference: <https://ro-che.info/ccc/21>)
10:37:10 <geekosaur> for some people it may never be solved, if they don't like the ORF solution
10:37:33 <geekosaur> oh, it occurs to me that enough of ORF might be in place in 8.2 to remove the need for TH when making lenses for records
10:37:57 <geekosaur> if there's a switch to turn it on, at least, and not just the mechanism buried somewhere inside
10:38:22 <ertes> i wonder if it could be done today with generics and a rather ugly type class
10:41:17 <Cale> I don't really understand what the problem is that needs solving there.
10:42:12 <lyxia> http://lpaste.net/353157 <- lenses for records with Generics
10:42:24 <srhb> Cale: Sounds like Stockholm syndrome :-P
10:42:54 <srhb> _typenameMyField etc. is terribly ugly.
10:43:47 <Cale> I'll agree that the underscores are ugly
10:44:11 <dolio> It's also annoying that TH divides up your file into components that do not admit forward references.
10:44:14 <Cale> But that's more a design decision that was made by various TH things
10:44:16 <srhb> The type prefix is not ugly in itself, I think, but having to write it for each field *is*
10:44:38 <robertkennedy> Category Theory: what is the thing on top of an exponential? Ie when we say "(3^4)^5 = 3^(4*5)" (uncurrying) we usually use the product type, but is there a more precise object?
10:45:24 <Cale> srhb: Well, I do like being able to tell what type something is when the field extractor gets used.
10:46:08 <srhb> Cale: Right, that's the non-ugly part. The boilerplatey repetition in the type definition is my complaint. :)
10:47:28 <tobiasBora> Hello,
10:47:42 <srhb> tobiasBora: Hello.
10:47:54 <Cale> Okay, new extension modest proposal: using record syntax in your data declaration automatically prepends the type name to the field names in the usual way
10:47:55 <ski> robertkennedy : "exponent" ?
10:48:01 <tobiasBora> Just a question, my program stoped with an exception "Error_Packet "partial packet: expecting 2088 bytes, got: 1393"
10:48:36 <tobiasBora> But I put a catch on all "HttpExceptionRequest _ _" errors, so I think it's not an HttpExceptionRequest error... But then what is it???
10:48:53 * ski idly wonders how hard it would be to have light-weight records
10:49:17 <srhb> Cale: I would be quite happy with that. :-)
10:49:35 <tobiasBora> I tried to hoogle Error_Packet, but nothing is shown...
10:49:36 <dolio> robertkennedy: Are you asking if something other than Cartesian product could be there? I think "exponential" is specifically related to Cartesian product.
10:49:50 <Cale> Seems a whole lot simpler than all the craziness involved in reusing the same names
10:49:54 <ski> s/cartesian/categorical/
10:50:18 <srhb> tobiasBora: What library is this?
10:50:26 <ystael> Cale: did you just propose implementing C++
10:50:33 <dolio> But there are generalizations of that to arbitrary other monoidal tensor products and "internal homs".
10:50:38 <tobiasBora> srhb: It's conduit (http)
10:50:48 <tobiasBora> https://hackage.haskell.org/package/http-conduit-2.2.3.1/docs/Network-HTTP-Conduit.html
10:51:09 <Cale> ystael: Does C++ do anything like that?
10:51:10 <ertes> lyxia: yeah, as ugly as i expected =)
10:51:14 <rjg_> hi are there any good tools to go through haskell code step by step?
10:51:28 <dolio> ski: It's the Cartesian product; they're called Cartesian closed categories, not categorical closed categories. :)
10:52:04 <ystael> Cale: I was thinking of the "name mangling" used to issue distinct C-ABI-level function names to class methods by class and signature
10:52:34 <qmm> is there a common term for monoids, monads, comonads, functors, applicatives?
10:52:36 <ystael> it's been so long since I programmed C++ that maybe this isn't standard practice any more
10:52:45 <Cale> qmm: Type classes?
10:52:51 <qmm> besides type classes
10:53:05 <Cale> Those things don't have a lot in common.
10:53:09 <lyxia> rjg_: http://chrisuehlinger.com/LambdaBubblePop/ ?
10:53:57 <rjg_> thank you for the link lyxia
10:54:40 <srhb> tobiasBora: https://hackage.haskell.org/package/tls-1.3.10/docs/Network-TLS.html#v:Error_Packet
10:55:17 <tobiasBora> srhb: Great, thank you, how did you find it?
10:55:47 <geekosaur> qmm, for what it's worth I just typed "Functor" into it, the first few hits were definitions of the class and the rest were instances. "instance Functor" might work better but might also miss "deriving Functor". but that's a lousy query to tell noise from signal, since the signal is overwhelming :)
10:56:37 <sm> rjg: maybe the GHCI debugger ?
10:56:45 <srhb> tobiasBora: error_packet partial packet expecting. to Google. But my search bubble is highly Haskell attuned.
10:56:50 <qmm> geekosaur: perfect! thank you very much
10:57:08 <Cale> qmm: If you drop monoids from the list, then they're all special sorts of functors.
10:57:42 <Cale> qmm: If you drop comonads, functors and applicative functors, monoids and monads are both examples of monoid objects.
10:58:35 <qmm> geekosaur: there aren't as many results as i thought there would be
10:58:47 <isaac_> what is the difference between sum and coproduct?
10:59:00 <Cale> isaac_: They're synonymous.
10:59:04 <qmm> https://hayoo.fh-wedel.de/?query=deriving+Functor has a little over 20 results
10:59:08 <dolio> Cale: Comonads are monoid objects if you flip the category. :P
10:59:18 <Cale> That's fair enough :D
10:59:20 <qmm> Cale: thanks :)
10:59:39 <geekosaur> I didn't suggest "deriving FUnctor" as a query, I said that a search for "instance Functor" might miss the ones that derive it instead of writing a direct instanc
10:59:39 <Cale> and they're comonoid objects if you don't
10:59:46 <ertes> qmm: "algebraic structures"?
11:00:28 <geekosaur> because I don't know how hayoo indexes stuff. (although ideally it'd handle it properly since it's supposed to be trying to do a type search not a text search --- your query being a demonstration that it's not doing text search :)
11:00:42 <rjg_> sm: I tried to step through my main function with :step, but I can only see a ¨_result¨ variable, is this correct?
11:00:58 <qmm> geekosaur: i guess i do want "instance Functor"
11:01:07 <qmm> thanks again
11:01:10 <sm> rjg_: it's very tricky at first, best read the docs carefully
11:01:22 <qmm> ertes: i'm just confused i guess 
11:01:39 <qmm> :k []
11:01:40 <lambdabot> * -> *
11:01:45 <qmm> :k Functor
11:01:47 <lambdabot> (* -> *) -> Constraint
11:01:52 <qmm> :k Monoid
11:01:53 <lambdabot> * -> Constraint
11:02:02 <qmm> :k Monad
11:02:03 <lambdabot> (* -> *) -> Constraint
11:02:15 <ertes> qmm: you can talk to lambdabot in private
11:02:52 <ertes> and of course your local GHCi will tell you the same things (usually) =)
11:03:01 <qmm> it did! :)
11:03:33 <rjg_> sm: I am trying to find the source of a possible infinite loop, but the step does not give me enough information, is it possible to make smaller steps or make the output more verbose? 
11:03:42 <qmm> it seems like functor, monoid, and monad are a level higher than []
11:03:57 <qmm> the phrasing is probably incorrect
11:04:20 <geekosaur> [] is a type constructor, the others are constraints
11:04:23 <ertes> rjg_: GHCi does support breakpoints, but you need to at least have an idea where the infinite loop might be
11:04:26 <sm> rjg_: I often find print or trace statements (Debug.Trace) a quick way to locate those
11:04:37 <geekosaur> ([] Int) is the same as [Int]
11:04:55 <ertes> rjg_: and i agree with sm…  Debug.Trace is often much easier to use than GHCi's debugging features
11:05:38 <erisco> I usually debug by simplifying
11:05:54 <sm> that too
11:06:29 <erisco> can I break this into smaller steps that I can individually verify
11:06:36 <erisco> or can I approach this differently in a way that is less confusing
11:07:16 <sm> don't forget to explain the situation to the rubber duck
11:07:25 <ski> isaac_ : i think "sum" is usually used if you have a distributive law
11:07:37 <rjg_> thanks for the tips
11:08:14 <ski> dolio : never heard them called "Cartesian products" in the general case, before
11:08:16 <nmdanny> Does anybody here know about using HXT(xml library)? I'm having a weird result when transforming an Xml document
11:09:01 <ertes> the proper way to use hxt is to switch to xml-conduit or something else
11:09:15 <monochrom> haha
11:09:39 <nmdanny> I tried using xml-conduit but I didn't find a nice way to manipulate documents
11:10:02 <rjg_> how does the ¨trace¨ function work? It looks pure but how can it have side effects
11:10:13 <erisco> rjg_, it contains cheat codes
11:10:15 <sm> it's a secret
11:10:32 <nmdanny> anyway, when transforming XML via HXT, I get some weird xml tag added to the output
11:10:52 <ertes> nmdanny: "<?xml … ?>"?
11:10:57 <nmdanny> e.g when processing <Item></Item>, I get: </ transfer-MimeType="text/xml" transfer-Status="200" transfer-Message="OK" transfer-URI="file:///C..." source="....xml" transfer-Encoding="UTF-8"><Item></Item>
11:11:10 <ertes> ah
11:11:13 <rjg_> wow cool
11:11:17 <freeside> wow, your XML has eaten HTTP
11:11:25 <freeside> it has, like, XHTML envy
11:11:29 <nmdanny> wat
11:11:58 <nmdanny> I haven't enabled hxt-http or something similar.. and i'm dealing with a file on my own computer
11:13:07 <erisco> I don't know if outputs should be relevant to purity, but that's a rabbit hole
11:13:31 <erisco> if you discount those then you also solve the time and heat issue
11:13:35 <ertesx> nmdanny: i found this: https://hackage.haskell.org/package/xml-lens
11:13:39 <ertesx> list release is from 2015, but it probably still works
11:13:52 <ertesx> *last
11:14:38 <nmdanny> I was actually interested in using this but my lens skills aren't pretty good
11:15:06 <erisco> bbl
11:15:08 <nmdanny> and I already figured how to use arrows and such..
11:15:13 <ertesx> nmdanny: well, this might be a good opportunity to improve them
11:15:28 <ertesx> arrows are exactly the reason why i wouldn't use hxt
11:15:57 <nmdanny> why not?
11:16:08 <ertesx> hxt doesn't actually have any *proper* arrows…  it's just using arrows for the sake of using arrows
11:16:30 <Cale> Yeah, I never understood that decision
11:16:39 <nmdanny> what do you mean by 'proper', are they not law abiding or something as such?
11:16:41 <Cale> It actually had a monadic interface at one point
11:16:49 <ertes> nmdanny: all of them have a monadic variant
11:17:06 <ertes> in other words they are all kleisli arrows
11:17:13 <nmdanny> oh yes, because they all implement ArrowApply right?
11:17:21 <ertes> yes
11:17:59 <ertes> so all the arrow interface does is to bloat the types and make source code awkward to write
11:18:36 <Cale> They're "law abiding" insofar as Kleisli arrows of arbitrary monads are, but they won't satisfy the law that I think all good instances of Arrow really ought to satisfy
11:18:54 <Cale> which is (f *** g) >>> (h *** k) = (f >>> h) *** (g >>> k)
11:19:57 <Cale> Without that law, you can't easily draw diagrams explaining your arrow computations without explicitly drawing boxes around every combination, so that you can see whether things are vertically or horizontally composed first
11:20:08 <Cale> (which makes things super ugly)
11:20:40 <ertes> to be fair that's more a feature of the underlying monads…  they have global state
11:20:51 <Cale> Well, right
11:21:27 <Cale> It's kind of similar to electronic circuits which don't follow the usual circuit abstraction that components are independent of one another.
11:22:18 <Cale> Only... it's almost worse, because it's how you carve up the diagram vertically or horizontally which makes the difference
11:23:09 <nmdanny> well HXT aside, what other viable XML manipulation libraries are there in haskell? 
11:23:25 <nmdanny> xml-lens doesn't seem to very used
11:23:33 <Cale> It's kind of old, but I remember using hexpat-pickle and not hating it
11:23:42 <dolio> I don't think you need "global state" to have a problem.
11:23:48 <dolio> Unless it's defined very broadly.
11:23:55 <Cale> A newer one is xml-conduit
11:24:02 <dolio> Kleisli [] probably doesn't have that property, either.
11:24:08 <pikajude> hexpat-pickle is a lot more useful than xml-conduit is
11:24:11 <pikajude> in my personal opinion
11:24:24 <cocreature> I’ve only used xml-conduit but so far I’ve been quite happy with it
11:24:26 <Cale> Ah, see, I haven't actually tried to use xml-conduit
11:24:28 <nmdanny> I'm not interested in pickling/unpickling the data,
11:24:35 <nmdanny> I need to manipulate XML trees and such
11:24:38 <pikajude> I used xml-conduit for a side project for work for about 5 minutes
11:25:00 <pikajude> it wasn't suited for that specific project
11:25:07 <dolio> Kleisli m probably only has that property for commutative m.
11:25:08 <rjg_> is it possible to keep definitions each time a hs file is reloaded? 
11:25:40 <monochrom> Yes. Put them in that file.
11:25:41 <Cale> rjg_: Put them in the .hs file
11:26:08 <Cale> I actually almost wish that GHCi would go back to not accepting declarations
11:26:12 <monochrom> Or revise GHCi to do what you want. :)
11:26:21 <sm> what about ertes's http://hackage.haskell.org/package/rapid
11:26:49 <rjg_> but isn´t it bad practice to clutter your source code with mock data
11:26:50 <sm> because put it in the hs file isn't great when you're interactively exploring
11:26:54 <Cale> When I learned Haskell, GHCi was simple: you loaded a file containing declarations, and it took expressions only
11:27:06 <ertes> nmdanny: in a library like xml-lens, the age is probably not as important, as long as it still works
11:27:20 <Cale> If the expression was an IO action, it would execute it (only)
11:27:32 <monochrom> Yes, so put your mock data and an import line in a new file, and load this new file instead.
11:27:34 <Cale> If not, it would try to apply print to it for you and execute that.
11:27:37 <ertes> nmdanny: in any case i'd go for lenses/traversals there
11:28:04 <ertes> rjg_: yes, rapid allows you to keep data resident
11:28:21 <monochrom> Like, if I'm testing out my XXX.hs, I don't load XXX.hs. I write play.hs to say "import XXX; example1 = x y". I load play.hs.
11:28:23 <ertes> rjg_: https://hackage.haskell.org/package/rapid-0.1.3/docs/Rapid.html#g:3
11:28:57 <Cale> I don't even regard it as all that bad to put some mock data into your file if your program is only one module anyway.
11:29:38 <nmdanny> are there any examples or documentation of using xml-lens, for instance?
11:30:06 <sm> ertes: to persist something across reloads, you have to have previously set up a reference for it in the source, is that right ?
11:30:44 <nmdanny> I want to do something like: edit an XML in-place,  drill down to some node, map its children(e.g append some nodes)
11:32:58 <ertes> sm: yes, the tutorial explains the whole process
11:33:02 <rjg_> ertes: is it possible to integrate ¨rapid¨ with vim?
11:33:14 <sm> bah, GHCI should just automatically pickle your state
11:33:40 <ertes> rjg_: that's more a vim question than a rapid question…  rapid itself is simply a library you use from GHCi
11:34:02 <sm> even if just dumped pretty-print of bound values on exit, that'd be quite useful
11:34:10 <ertes> rjg_: i don't know the answer though…  it's certainly possible, but i'm not aware of anything ready-made
11:34:27 <ertes> rjg_: it does integrate well into emacs at least
11:34:31 <monochrom> "patches welcome"
11:34:51 <rjg_> ertes: oh ok thanks, I saw that it could be integrated into editors so I thought it was a plugin
11:35:35 <ertes> rjg_: i try not to write more elisp than necessary =)
11:35:46 <ertes> haskell-mode kindly already had the hooks needed =)
11:36:39 <monochrom> You wouldn't believe how 50% of the economy of GHC's development is the economy of how to get some academic papers published. (And therefore not how much you want an REPL feature.)
11:37:21 <monochrom> And the other 50% is Simon Marlow being exceptionally selfless. But I get to say the exception proves the rule.
11:37:29 <rjg_> ertes: is the rapid library a workaround for a missing feature of GHCi? It looks pretty complicated
11:38:23 <ertes> rjg_: i guess that's a question of philosophy…  in principle it could be a GHCi feature, i guess
11:38:50 <geekosaur> nevertheless people do submit ghci features, and there's even a package to help you develop them without having to hack ghc directly (ghci-ng)
11:39:34 <ertes> rjg_: if it had better support from GHC, it could at least be a lot safer
11:40:16 <ertes> right now it uses the foreign-store library, which is a *major* hack
11:53:47 <rjg_> is it possible to capture an intermediate value in between multiple composed functions? So a bit like @, without having to split up the chain with let..in or where
11:56:21 <rjg_> for example for debugging purposes
11:58:12 <Cale> > ap ((,) . reverse) (map toUpper) "hello"
11:58:14 <lambdabot>  ("olleh","HELLO")
11:58:17 <Cale> heh
11:58:25 <Cale> just define the intermediate value :P
11:59:43 <Cale> (that didn't work, because reverse was only applied to the first argument of course)
12:00:34 <Cale> @pl \x -> (f x, g (f x))
12:00:34 <lambdabot> liftM2 (,) f (g . f)
12:00:42 <Cale> well, sure
12:00:43 <Cale> heh
12:01:56 <Cale> Oh, I guess it could be:
12:02:08 <Cale> > ap (,) (map toUpper) . reverse $ "hello"
12:02:09 <lambdabot>  ("olleh","OLLEH")
12:02:12 <Cale> yeah!
12:03:12 <glguy> you can use trace or the GHCi debugger
12:03:20 <mnoonan> Something must be wrong with me to prefer `(id &&& map toUpper) . reverse` :)
12:04:05 <Cale> I don't really like any of them
12:04:08 <Cale> Use lambda
12:04:41 <dolio> Use a debugger.
12:05:46 <sm> rjg_: yes, especially if the value is showable, traceShowId is very useful
12:06:01 <ertes> rjg_: (\x -> traceShow x x)
12:06:10 <ertes> or (join traceShow), if you prefer
12:06:36 <ertes> ah, apparently it's predefined =)
12:06:58 <rjg_> thanks
12:07:20 <sophiag> i'm a bit confused about how to structure a data type constructor to store lambdas and wondering if someone could give me a hand. here's the relevant code: http://lpaste.net/354152
12:07:24 <sophiag> the problem is i need Eq as a constraint on the value returned by parseOp and learned it doesn't play nicely with existential quantification. i'm fine providing a type for the lambda since it would match that of the value returned by parseLiteral, which i can make Typeable, however i'm still confused about how to pass the lambdas i've put together to the constructor themselves. does that make sense?
12:07:39 <sm> http://hackage.haskell.org/package/hledger-lib-1.1/docs/src/Hledger-Utils-Debug.html#traceWith is also useful
12:08:09 <sm> ha, the code would have been shorter
12:09:53 <Cale> sophiag: I'm a little confused about what the input expression is there
12:10:20 <Cale> sophiag: Also, does an operation of this type really make much sense? Most expressions aren't going to be lambdas, are they?
12:10:39 <sophiag> it's for parsing a dsl
12:10:51 <sophiag> and just the parts of it that are definitely going to be lambdas
12:11:38 <sophiag> i was told i can create a constructor for functions by just using their type signatures (so a -> Bool in this case), but then i'm confused about how i pass both a _and_ the actual implementation
12:12:16 <Cale> You don't... but also that's probably not a good representation for a lambda that you're going to be interpreting.
12:12:43 <sophiag> i'm not sure what you mean. 
12:12:57 <sophiag> they'll all have that type signature and all be of one variable
12:13:13 <Cale> Well, a lambda consists of some variable which is being abstracted over, and then a body
12:14:20 <sophiag> i haven't yet gotten to parsing compound expressions, but otherwise i know all of _these_ lambdas will be of that form
12:14:36 <sophiag> in other words just one bound variable on the lhs of an infix expression
12:14:37 <Apocalisp> I've made a monad transformer FooT and a class (Monad m) => MonadFoo m. Now I want something like instance (MonadFoo m, MonadTrans t) => MonadFoo (t m). But I need to prove Monad (t m). How to resolve this?
12:15:15 <Cale> Apocalisp: You can't write an instance like that.
12:15:35 <Apocalisp> didn't think so but I can't articulate why
12:15:48 <Cale> Perhaps you meant:  instance (Monad m) => MonadFoo (FooT m) ?
12:16:21 <Cale> The reason why is that instances have to match on type constructors
12:17:01 <Cale> You're not allowed to write an instance which applies to just any type application whatsoever
12:18:07 <Apocalisp> ok, makes sense
12:18:15 <dolio> Well, GHC will let you if you turn on enough extensions. But you shouldn't do it.
12:18:23 <Apocalisp> :)
12:18:43 <Cale> Yeah, it'll overlap with almost anything
12:18:52 <Cale> and you'll have problems
12:19:32 <Cale> Apocalisp: an important thing to keep in mind is that when deciding which instance applies in any particular case, the resolver can't and won't consider the type class constraints on the instances
12:19:45 <Cale> Those only get checked once it finishes committing to a particular instance
12:20:21 <Cale> It only looks at the structure of the type, and matches it against the patterns in the instance heads.
12:21:14 <freeside> pedagogically, wouldn't it be better to first learn how to do monad transformers without involving typeclasses?
12:21:20 <Apocalisp> What about the case where Foo is just a monad (not a transformer), and I have class (Monad m) => MonadFoo m where liftFoo :: Foo a -> m a. Then I find myself writing instance MonadFoo m => MonadFoo (ReaderT m), etc.
12:21:59 <Cale> freeside: Well, you need to know enough about type classes to at least do the Monad and MonadTrans instancez
12:22:00 <Cale> s*
12:22:18 <Aruro> after ghc 8 doing monad became pain
12:22:26 <Aruro> u need to implement 4 extra classes
12:22:31 <Cale> Apocalisp: yes.
12:22:33 <Aruro> or hack like undefine
12:22:43 <Cale> Aruro: hm?
12:22:49 <ertes> Aruro: derive Functor, write Monad without 'return'
12:22:55 <Aruro> need applicative
12:23:09 <ertes> yes, define full Applicative, but for Monad you can leave out 'return'
12:23:25 <monochrom> Which 4 extra classes? I only know 2.
12:23:27 <Aruro> Functor + Applicative + Monad and if u Want then transformer
12:23:35 <Cale> I would just write the Monad instance, and then  instance Functor MyThing where fmap = liftM; instance Applicative MyThing where { pure = return; (<*>) = ap }
12:23:38 <ertes> in most cases it's good enough to just define 'pure' and (>>=) and then:  (<*>) = ap
12:23:39 <jle`> what undefine hack do you mean, heh
12:23:56 <Apocalisp> Cale: So I need MonadFoo (ReaderT r m), MonadFoo (StateT s m), MonadFoo (LoggingT m)... but they're all identical
12:24:05 <Cale> Apocalisp: yes.
12:24:10 <Apocalisp> I guess the solution is to make FooT
12:24:11 <Aruro> jle`: if u want to make use of old examples from haskell tutorials, u can hack with undefined
12:24:18 <dolio> If you weren't defining Functor and Applicative before, I would have recommended that no one use your code.
12:24:18 <jle`> what undefined hack do you mean?
12:24:30 <Aruro> dolio: seriously?
12:24:34 <dolio> Absolutely.
12:24:45 <Aruro> makers of haskell did not know about applicative, please dont use it
12:24:49 <Aruro> i mean haskell
12:25:06 <Cale> Aruro: Applicative has been around for quite a while though.
12:25:08 <Aruro> look at first report, with such high bars u have set :)
12:25:15 <Cale> and not supporting it at this point is annoying
12:25:28 <monochrom> First report? Haskell 0.4?
12:25:29 <ertes> Apocalisp: if you look at mtl, you will find that they do exactly the same thing
12:25:35 <Aruro> u have to first teach it right, and then Demand
12:25:35 <Cale> But even from the beginning, it was a mistake not to make Functor at least a superclass of Monad.
12:26:02 <ertes> Apocalisp: monad transformers with effect classes suffer from the expression problem there
12:26:02 <jle`> Aruro: what hack with undefined are you talking about?
12:26:07 <lyxia> Is there a GHC.Generics implementation of generic zippers?
12:26:07 <Cale> In mathematics, monads are functors equipped with extra information.
12:26:37 <Cale> So it doesn't entirely make sense why they weren't a subclass of Functor from day 1 -- just an oversight by the committee.
12:26:56 <dolio> People have had 10 years to start teaching it. Why are they so slow?
12:27:03 <jle`> the first versions of haskell didn't have monad, either, for what it's worth
12:27:07 <Cale> Applicative came along a good bit later, but it's basically proven itself useful enough.
12:27:12 <Aruro> i find it unjustified to talk about oversight After things happen
12:27:18 <Aruro> a bit strange
12:27:23 <Cale> Well, yeah, the first versions of Haskell didn't have constructor classes.
12:27:38 <Cale> You could only define type classes for types of kind *
12:27:40 <jle`> so talking about the first versions of haskell doesn't have too much weight
12:27:57 <jle`> Aruro: if you mean something like 'instance Functor m where fmap = undefined', you don't need undefined there
12:28:04 <jle`> Aruro: you can just write 'instance Functor m' to mean the same thing
12:28:25 <Cale> Aruro: if you're going to write fmap = undefined, why not just write fmap = liftM ?
12:28:32 <Cale> You'll get a reasonable instance.
12:28:41 <Cale> (assuming you wrote a reasonable Monad instance)
12:28:52 <monochrom> My high standard is if you write I/O code with [Response] -> [Request], I won't want to read your code, unless you pay me well.
12:28:57 <ertes> and again, most of the time you can just derive Functor
12:29:14 <monochrom> So now point me to Haskell 1.2 to chastise me or something.
12:29:34 <ertes> the advantages of the new class hierarchy far outweigh the requirement to write a bit more code, honestly
12:29:41 <Cale> We need an acme-response-request
12:29:54 <Cale> a backwards compatibility layer with early Haskell
12:30:04 <Aruro> it does outweight, but now to write monad u really need to understand all major classes
12:30:04 <monochrom> Yes! What should be in it? Maybe be just in time for tomorrow April 1st. :)
12:30:07 <ertes> also Functor and Applicative could easily be extended to use default signatures
12:30:10 <Aruro> since they are superclasses now
12:30:17 <jle`> Aruro: you don't need to
12:30:17 <ertes> instance Functor F; instance Applicative F; instance Monad F where …
12:30:27 <jle`> you can just write instance Functor Foo where fmap = liftM
12:30:39 <Aruro> if u want tranformer more instances may be needed
12:30:40 <jle`> and instance Applicative Foo where pure = return; (<*>) = ap
12:30:48 <Cale> Basically the Request and Response types from one of the early Reports, and a function ([Response] -> [Request]) -> IO ()
12:30:48 <jle`> you don't need to understand them
12:30:56 <jle`> you just need to barf out boilerplate, i suppose
12:31:01 <Aruro> :)
12:31:04 <hololeap> i'm trying to understand how (enumFromTo :: Enum a => a -> a -> [a]) is implemented without `a` also being a part of the Eq class
12:31:22 <jle`> hololeap: enumFromTo is a part of the Enum typeclass
12:31:30 <jle`> so each class gets to define its own implementation
12:31:37 <Cale> each instance
12:31:43 <jle`> yes, each instance :)
12:31:48 <rjg_> how can I get an object a from a list such that when you apply the function f to all elements on that list, f(a) has the biggest value 
12:31:54 <jle`> rjg_: maximumBy
12:32:03 <hololeap> but the "to" part is what confuses me. how does it know to stop at the second `a` without using a comparison
12:32:05 <jle`> > maximumBy (comparing negate) [1..10]
12:32:07 <lambdabot>  1
12:32:12 <jle`> hololeap: that's up to each individual instance to figure out
12:32:18 <Cale> > maximumBy (flip compare) [1..10]
12:32:20 <lambdabot>  1
12:32:36 <jle`> hololeap: so, the instance for Int would probably use (==)
12:32:46 <sophiag> Cale: what do you think about my lambda datat type situation? does it make more sense to have something like: "data LambdaT a f = (Eq a) => LambdaType (a -> Bool) f"
12:33:01 <Cale> sophiag: Can I see the rest of your definitions?
12:33:14 <Cale> sophiag: I'm not sure I fully understand what you're after :)
12:33:15 <jle`> > maximumBy (comparing length) ["hello","hi","what is up","how doing"]
12:33:17 <lambdabot>  "what is up"
12:33:37 <jle`> hololeap: if the individual instance you are writing has (==), then you can use it
12:33:45 <rjg_> thanks jle
12:33:52 <jle`> note that this doesn't do any caching
12:34:07 <Aruro> rjg_: (maximum . map myF ) list
12:34:10 <jle`> so if the mapping function is expensive you might want to memoize the results
12:34:33 <jle`> Aruro: that gives you the maximum f(a)
12:34:40 <jle`> Aruro: but rjg_ wanted the maximum 'a'
12:34:56 <Aruro> jle`: my appologies, did not think enough
12:35:03 <jle`> no need to aplogize to me :)
12:35:09 <Aruro> :)
12:35:17 <Cale> > snd . maximum . map (length &&& id) $ ["hello","hi","what is up","how doing"]
12:35:19 <lambdabot>  "what is up"
12:35:22 <sophiag> Cale: it's that paste from before
12:35:53 <hololeap> but the minimal definition for Enum is just `toEnum` and `fromEnum` so that tells me that enumFromTo is implemented generically. unfortunately, in the source code it is just defined as `[f .. t]`
12:36:51 <Cale> sophiag: I'm not sure I still have the link...
12:36:55 <sophiag> Cale: although i changed it to use a let statement, which seems to make more sense
12:37:04 <jle`> hololeap: the minimal definition uses [fromEnum f .. fromEnum t]
12:37:07 <sophiag> ok, lemme repaste with more :)
12:37:18 <jle`> hololeap: so it's using the Enum instance of Int
12:37:34 <hololeap> i see
12:37:39 <hololeap> that makes sense now
12:37:39 <jle`> > [fromEnum LT .. fromEnum GT]
12:37:42 <lambdabot>  [0,1,2]
12:37:49 <rjg_> jle`: what do you mean with that it doesn't do any caching? That it does not store the results?
12:38:00 <jle`> rjg_: yes, it recomputes the result of the function on every comparison
12:38:13 <jle`> on the "currently seen maximum"
12:38:21 <jle`> er, the current known maximum
12:38:44 <jle`> so if your maximum is the first item in the list, it recomputes the function on every subsequent comparison
12:39:16 <jle`> or well, it would do that even if it wasn't the first item
12:39:31 <jle`> i guess you can say that for a list of length n, the function is applied 2n times.
12:39:44 <jle`> Cale posted a version that caches the image of the function that only applies the function n times
12:40:10 <jle`> same asymptotics though, so it probably isn't a big deal in most programs
12:40:45 <rjg_> thanks, I guess for small cases the n times version is better
12:41:03 <jle`> for small cases the naive version probably isn't much slower
12:41:30 <jle`> if your program's runtime is dominated by this maximum-finding, then it would probably make a difference, though
12:43:55 <rjg_> hmm but what does &&& mean?
12:45:04 <nmdanny> is it possible to use letters inside custom operators? e.g define the following operator "=ci="
12:45:45 <jle`> rjg_: (f &&& g) = \x -> (f x, g x)
12:45:50 <jle`> nmdanny: it is not
12:46:28 <sophiag> Cale: here's the full code modified a bit trying another way to do it. i have an error from unwrapJust on line 37 i thought i was able to resolve yesterday, though :/
12:48:19 <jle`> rjg_: actually after trying it out in ghc it looks like the non-caching version is faster when the function is cheap, cause of the overhead from generating the tuple
12:48:29 <jle`> *ghci
12:48:41 <jle`> results might be different in compiled -O2 though.
12:49:01 <rjg_> ah
12:53:10 <sophiag> Cale: i updated it to not use existential quantifcation with the RhsT type: http://lpaste.net/354152
12:54:36 <sophiag> so really it seems my issue is just how it's reading the type signature from the lambda. in other words, the AST types of op and rhs don't actually matter. it needs to be something like: "(typeOf rhs) -> Bool"
12:57:23 <sophiag> i'm trying providing a type signature inside the function, but clearly not doing it right: "func :: typeOf rhs -> Bool"
12:57:34 <jle`> upset at myself that i wasn't able to think of a good haskell april fools in time this year
13:02:51 <Apocalisp> Given State (a,b) m, can I get MonadState a m and MonadState b m?
13:02:59 <dolio> jle`: You still have a few hours.
13:03:46 <Apocalisp> sorry, make that ...
13:04:01 <jle`> Apocalisp: yes
13:04:17 <napping> Apocalisp: no, there's a functional dependency saying m has to determine the state
13:04:28 <jle`> oh wait
13:04:32 <jle`> no, because it's not well-kinded
13:04:40 <Apocalisp> can I get MonadState a (State (a,b)) and MonadState b (State (a,b))?
13:04:45 <jle`> you use m as * first, but then you use it as * -> *
13:04:57 <dolio> Apocalisp: What happens if a = b?
13:05:07 <jle`> MonadState :: * -> (* -> *) -> Constraint, so the second argument has to be (* -> *)
13:05:37 <Apocalisp> yeah, sorry, poorly kinded question
13:05:40 <napping> Apocalisp: not that either, there's a functional dependency
13:05:48 <napping> unless you are not using mtl?
13:06:28 <WarmCookie> Can someone with a bit of knowledge of rust-lang brief me on what a typical Haskell user would complain about while working with that language?
13:06:39 <napping> even if there wasn't the overlap would be problematic
13:06:48 <jle`> i think i might have a seen a 'six months with rust' kind of post from the perspetive of a haskell user not to long ago
13:06:52 <napping> Maybe something like zoom from lens would help?
13:07:19 <jle`> yes, a big-picture idea of what you actually want would shed some insight and allow for more useful answers
13:07:20 <monochrom> jle`: Usually I think up or discover in #haskell a good idea on April 2nd.
13:07:21 <WarmCookie> I know that their support of higher-kinded polymorphism is near inexistant, but what problems does it creates pratically?
13:07:52 <jle`> i mean, without higher kinded polymorphism, there's no functor, applicative, traversable, monad ...
13:07:58 <jle`> no anything
13:08:51 <Apocalisp> dolio: That illustrates the problem nicely, thanks
13:08:59 <napping> Apocalisp: zoom _1 can have type State a x -> State (a,b) x
13:09:00 <WarmCookie> jle`: Don't they have some trait system for like, at least a `map` operation for container-like types and similar?
13:09:25 <Apocalisp> napping: Yeah awesome, I think I'll have use of the MonadState combinators from Lens
13:09:30 <napping> WarmCookie: I think it's mostly with iterators
13:09:47 <napping> A type changing map is kind of problematic if you worry about storage layout
13:10:32 <itachi> what does it mean when we say a function is pure?
13:11:07 <nut> itachi: It means it doesn't have side effect
13:11:24 <nut> itachi: side effects are things like IO 
13:11:29 <infandum> itachi: Double -> Double means Double -> Double, nothing else is returned or executed
13:11:50 <itachi> why is having side effects harmful?
13:12:04 <infandum> whereas in python, you could have a (+) function that is Double -> Double but also prints "howdy doody"
13:12:12 <infandum> or queries a web server
13:12:18 <dolio> Because having side effects means you have to worry about the exact order things happen a lot more.
13:12:34 <dolio> Which is mental overhead.
13:12:46 <napping> itachi: in particular, if f :: Double -> Double, then you should always have that some expression .... (f x) ... (f x) ... behaves exactly like let y = f x in .... y ... y ...
13:13:06 <nut> itachi: It's harming in the sense that you don't get the same result every time you run your code. It depends on the outside world
13:13:19 <itachi> makes sense
13:13:24 <jle`> it's much harder to understand and debug side-effecting code
13:13:27 <infandum> That got me thinking. 
13:13:28 <jle`> like, a bajillion times
13:13:30 <WarmCookie> nut: I think IO is supposed to model effects, not side effects.
13:13:42 <infandum> What happens if you use a library who uses unsafePerformIO?
13:13:45 <napping> lots more rearangements of code are correct when everything is pure
13:13:50 <itachi> model effects?
13:13:52 <WarmCookie> Side effects are undesirable; effects with IO are perfectly fine.
13:14:02 <jle`> IO *describes* effects
13:14:04 <infandum> Even if all of your code is pure, that wouldn't matter because it isn't really
13:14:12 <napping> infandum: It's either observably pure, or you write nasty letters to/about the author
13:14:12 <jle`> it doesn't do side-effects
13:14:24 <nut> by IO I don't mean the IO monad
13:14:49 <infandum> napping: Haha yeah I figure that'd be the only solution. I've seen plenty of libraries that look find but use unsafePerformIO because of...well I'm not sure
13:15:00 <infandum> look fine*
13:15:19 <infandum> lots of numerical ones and ones that use state from what I remember
13:16:01 <infandum> napping: By observably pure you mean in the code? Not empirically?
13:16:38 <jle`> infandum: if a library uses unsafePerformIO, it is expected that they preserve pure semantics
13:16:39 <Apocalisp> unsafePerformIO is sometimes necessary when calling out to C libraries
13:16:51 <dolio> WarmCookie: This isn't Rust, but if you look at Scala's collections, they too abstract 'mapping' through traits and subtyping. And when you use the abstraction, you tend to lose the information about what container type you're working with.
13:17:00 <jle`> it's all about providing a well-behaving abstract API
13:17:22 <jle`> unsafePerformIO must only be used in situations where the semantics of the resulting abstract API is pure
13:17:41 <dolio> It is not the abstraction I usually want. I want to map and get back the same container type. So in practice we end up converting back down by calling `toFoo` everywhere. And it gets noisy.
13:17:48 <itachi> what is the use of ">>" in monad?
13:18:02 <jle`> itachi: the behavior depends on the instance
13:18:06 <Apocalisp> unsafePerformIO should be renamed uncoolPerformIO for the new generation
13:18:11 <dolio> WarmCookie: The difference is, Scala could give the abstraction I want, but doesn't, whereas Rust can't.
13:18:14 <jle`> itachi: for IO, it sequences two IO actions 
13:18:22 <jle`> itachi: remember that a value of type 'IO a' describes a program
13:18:24 <Apocalisp> or unspeakableEldritchPerformIO
13:18:39 <jle`> itachi: so if x and y are bith IO a, then (x >> y) describes a program that has the effects of a, and then does the effects of b
13:18:47 <jle`> (x >> y :: IO a), as well
13:19:09 <jle`> but every intsance of Monad can define its own (>>) to behave in its own appropriate way, that might not have anything to do with IO's >> necessarily.
13:19:11 <itachi> hmm
13:19:40 <Apocalisp> a >> b = do { a; b }
13:19:41 <WarmCookie> > [0,0,0] >> [1,2,3]
13:19:42 <nut> itachi: putStrLn "hello" >> putStrLn "world", try it
13:19:44 <lambdabot>  [1,2,3,1,2,3,1,2,3]
13:20:14 <jle`> itachi: a value of type (IO a) is nothing more than a data type describing IO actions/effects, so (>>) is a neat combinator that lets you build complex IO actions from simpler 'primitive' ones
13:20:25 <jle`> itachi: kind of like (++) for lists, it lets you build complex lists from simpler lists
13:20:29 <jle`> > [1,2,3] ++ [4,5,6]
13:20:32 <lambdabot>  [1,2,3,4,5,6]
13:20:42 <itachi> k
13:20:44 <Aruro> :t (>>)
13:20:45 <lambdabot> Monad m => m a -> m b -> m b
13:20:59 <itachi> a>>b will first do "a" then "b"
13:21:09 <Aruro> and ignore a
13:21:31 <WarmCookie> (And join the effects of the the two m's into the final m)
13:21:49 <itachi> by ignore a you mean results of "b" wont depend on a
13:22:12 <Aruro> yes, but effects of m a will be performed
13:22:23 <jle`> yes, it'll sequence the effects, but drop the result of the left hand side
13:22:29 <jle`> fun stuff
13:22:35 <WarmCookie> f >> g = f >>= \_ -> g
13:23:02 <itachi> I did not get how "[0,0,0] >> [1,2,3]" returns "[1,2,3,1,2,3,1,2,3]"
13:23:21 <Aruro> itachi: because u did not look at list instance of monad
13:23:45 * itachi checks
13:23:46 <jle`> itachi: like i said earlier, every monad instance is free to define >> however it wants
13:23:52 <jle`> itachi: that's just how the list intsance defines it
13:23:54 <WarmCookie> itachi: Each `0` is replaced with [1,2,3], then all these [1,2,3] are concatenated is per the semantic of the list monad.
13:24:05 <jle`> for lists, xs >> ys = [ y | _ <- xs, y <- ys ]
13:24:12 <nut> itachi: that list example is confusing for beginners. the >> has different behavior for different monad. you have to check how >> is implemented for list
13:24:47 <itachi> I think i somewhat get it now
13:24:56 <jle`> yes, one of the common roadblocks people encounter when trying to 'learn monads' is to think that the different instances have that much in common in their implementations
13:25:18 <jle`> but the different monad instances are all really different types, so you can't really expect their monad instances to be related to eachother that muc
13:25:43 <itachi> k will keep that in mind
13:25:43 <jle`> > [ y | _ <- [0,0,0], y <- [1,2,3] ]
13:25:46 <lambdabot>  [1,2,3,1,2,3,1,2,3]
13:26:17 <jle`> (>>) is useful for lists because the left hand side can "kill" the right hand side
13:26:23 <jle`> > [ y | _ <- [], y <- [1,2,3] ]
13:26:25 <lambdabot>  []
13:26:29 <jle`> > [ y | _ <- [(),()], y <- [1,2,3] ]
13:26:31 <lambdabot>  [1,2,3,1,2,3]
13:26:38 <jle`> > [ y | _ <- [()], y <- [1,2,3] ]
13:26:40 <lambdabot>  [1,2,3]
13:26:40 <jle`> etc.
13:26:48 <jle`> (ignore the middle example with [(),()])
13:26:58 <itachi> yup get it now thanks
13:27:02 <itachi> :)
13:27:04 <jle`> the left hand side can choose to kill ys, or just returns it as-is
13:27:07 <WarmCookie> I like the middle example to show it can also duplicate the right hand side.
13:27:16 <WarmCookie> *replicate
13:28:04 <jle`> all of the monad methods are themselves useful functions for their respective instances
13:28:23 <jle`> if list didn't have a Monad instance, it would probably already define (>>=) and (>>) on its own with different names, just because they're useful
13:28:30 <jle`> (in fact, list actually does define its own (>>=) under a different name)
13:28:48 <jle`> (not because "oh, we should have monadic bind", but "oh, (>>=) is a useful combinator for lists")
13:28:54 <Aruro> :t (>>=)
13:28:56 <lambdabot> Monad m => m a -> (a -> m b) -> m b
13:29:22 <Aruro> [a]->(a->[a])->[a]
13:29:44 <dolio> I'm not sure how often (>>) for lists comes up.
13:30:07 <jle`> (>>) for list comes up more often than (>>=), i would think
13:30:18 <jle`> or just as often
13:30:20 <dolio> I don't think I agree with that.
13:30:32 <jle`> for doing prolog-style constraint satisfaction
13:30:42 <jle`> (>>) is used with guard
13:31:00 <itachi> you guys now any good resource for quetions on monads?
13:31:05 <jle`> yes, #haskell :)
13:31:15 <Aruro> itachi: one definition of monad is revolving around how to get m a out of m (m a) , in terms of lists how to get [a] out of [[a]]
13:31:26 <itachi> I am questions to solve
13:31:41 <jle`> dolio: when using list prolog-style, (>>) is essential
13:32:09 <dolio> Sure. That is already a niche use.
13:32:14 <Aruro> itachi: dont get stuck with monads, they are just functions.
13:32:22 <Aruro> nothing special.
13:32:42 <jle`> dolio: >>= is a niche use too, isn't it?
13:33:33 <dolio> No. Concat mapping is a frequent operation for building lists in general.
13:33:44 <itachi> Aruro: k
13:34:19 <jle`> ok you caught me in my bluff
13:38:20 <jle`> but, (>>) would probably still exist for lists even if there was no Monad instance for some reason.
13:38:33 <dolio> Yeah, you might occasionally want it.
13:40:05 <monochrom> itachi: A textbook is a good source of exercises.
13:40:43 <rjg_> how can i get a sublist a from a list b such that when you apply the function f to all elements of b, it has a maximum value only on the elements that are also in list a
13:40:57 <itachi> which textbook? I am currently using http://learnyouahaskell.com/chapters ?
13:41:05 <monochrom> Exercises take both talent and effort to make. I don't think any bloggers ever bothered.
13:41:06 <Apocalisp> more mtl questions. Given (r, m a) for some (MonadReader r m), can I run the reader not knowing where in my stack it appears?
13:41:28 <monochrom> That one is not quite a textbook.
13:42:08 <itachi> any suggestions on a good textbook?
13:42:22 <monochrom> There are Richard Bird's textbook, Graham Hutton's textbook, and Chris Allen's haskellbook.com
13:42:23 <dolio> Apocalisp: No. You could change what parameter is passed in with `local`, though.
13:43:01 <Aruro> itachi: i suggest no exercises, try to implement very small and personally useful programs, calculating personal day of life, small console utils and so on
13:43:02 <itachi> k thanks
13:43:27 <Aruro> itachi: one condition u have to use your programs, more often the better
13:43:47 <rjg_> so I would like to extend "maximumBy (comparing f) list" so that it can return more than one element in case multiple elements share the maximum value 
13:43:54 <jle`> does anyone know an interesting function :: [a] -> [a] -> [a] that *isn't* associative?
13:44:34 <itachi> Aruro: will do
13:44:36 <jle`> rjg_: maybe you could gather all of the values into a Map where the keys are the image of f, and the values are the values that gave that image
13:44:43 <jle`> and then take the value of the maximum key
13:45:02 <Aruro> itachi: first learn ghci well, commands like :i :t and others, and start playing with every function u can
13:45:05 <lieven> jle`: if it supports Eq, set difference
13:45:20 <jle`> i'm not sure if there's a bettre way, other than writing it using explicit recursion
13:45:22 <jle`> (which isn't that bad)
13:45:28 <monochrom> jle`: Perhaps an inverse of (++), attempting to strip a prefix.
13:45:43 <rjg_> thank you 
13:45:50 <nmdanny> is there a way of turning a Traversal' a b into Prism' a b, if I know that the traversal yields only one element?
13:45:51 <jle`> lieven, monochrom: ah, thanks
13:46:01 <monochrom> I guess it also needs Eq
13:46:31 <jle`> oh, yeah, one that doesn't require Eq owould be better for my purpose/demonstration
13:46:32 <tapirus> > :t (**)
13:46:34 <lambdabot>  <hint>:1:1: error: parse error on input ‘:’
13:46:46 <Aruro> :t (**)
13:46:48 <lambdabot> Floating a => a -> a -> a
13:46:54 <jle`> nmdanny: i don't think so
13:46:54 <tapirus> ugh, ignore me
13:46:56 <monochrom> We're basically banking on "the inverse operations such as subtraction and division are not going to be associative" :)
13:47:06 <robertkennedy> I'm surprised at the number of segfaults I've been getting. Do you guys know which libraries or practices tend to cause them? I'm eyeing wai as the culprit
13:47:08 <jle`> nmdanny: a prism also has the ability to construct the item
13:47:34 <merijn> robertkennedy: Anything using the FFI
13:47:41 <jle`> nmdanny: there's no way to construct a 'Maybe a' given only a Traversal' (Maybe a) a
13:47:50 <monochrom> Yikes, even const is associative, eh?
13:47:58 <jle`> yup it's the zero semigroup
13:48:02 <jle`> *left zero
13:48:17 <monochrom> Is (\x y -> x ++ y ++ x) good?
13:48:18 <jle`> well i can just use subtraction
13:48:26 <merijn> robertkennedy: Any experience debugging C? If it's indeed the FFI (or the runtime system) you might be able to get some useful info from core dumps
13:48:27 <jle`> treating the list as [()]
13:48:34 <robertkennedy> merijn: is that pretty much the only case? Do segfaults always blame "generated code"
13:48:49 <nmdanny> Is there something like the lens traversal that allows modifying the traversable?
13:49:21 <jle`> that is, treating [a] as Nat
13:49:32 <puregreen> nmdanny: lens traversals already allow modifying the traversable
13:49:43 <puregreen> > [1,2,3] & each %~ succ
13:49:44 <nmdanny> do they allow adding or removing elements from it?
13:49:45 <lambdabot>  [2,3,4]
13:49:48 <monochrom> I would hope that someone will find (\x y -> x ++ y ++ x) or (\x y -> y ++ x ++ y) somewhat useful because that's how "* * * Warning * * *" could be done.
13:49:50 <puregreen> no, they don't
13:49:55 <merijn> robertkennedy: Well, they're either compiler bugs, runtime bugs, or people writing bugs using FFI operations. The first is extremely unlikely, runtime (as in, inside the runtime system's C) are very unlikely, but not unheard off. People messing up FFI code? That's as common as people messing up C
13:50:32 <robertkennedy> I'll try dumping core, but the apps that these pop up in are our wrapping programs, which are pretty large
13:50:33 <nmdanny> well then is there a similar lens construct? I'm working with a tree-like structure (xml lens),
13:50:34 <merijn> robertkennedy: I mean, segfaulting is as easy as "peek nullPtr :: IO CInt" :)
13:50:50 <nmdanny> and I'd like to create a prism for an xml node matching a certain condition
13:50:50 <puregreen> nmdanny: the only generic thing I know that lets you remove elements from traversed structure is the Witherable class
13:50:55 <puregreen> no idea about XML, sorry
13:51:24 <puregreen> if you see a lens that views “Maybe a”, then you should be able to set Nothing to remove the value
13:51:25 <merijn> robertkennedy: So I suspect FFI in libraries, but if that doesn't appear to be the case, compile with "ghc -debug" which will use the runtime system with DWARF debugging symbols
13:51:32 <puregreen> but I don't know whether xml-lens has such lenses
13:52:14 <robertkennedy> Yeah I'll work toward that 
13:52:19 <robertkennedy> Ty
13:52:23 <nmdanny> well it doesn't have to be necessarily xml-lens, is there a similar abstraction for any tree structure?
13:53:07 <Aruro> nmdanny: have u looked at hxt?
13:53:23 <nmdanny> yes, it's what I began with at first
13:53:30 <nmdanny> and now i'm trying to move to lens
13:53:39 <puregreen> nmdanny: if xml-lens implements the At class for XML, then you can use `at` from lens to remove values
13:53:57 <merijn> nmdanny: what kinda xml are you dealing with?
13:54:12 <jle`> ah hm so it looks like subtration (treating [a] as Nat) is not associative
13:54:26 <nmdanny> i'm creating a utility that would modify an xml tree in place,
13:54:55 <nmdanny> it looks something like this: <ItemContainer><Item></Item><Item></Item><Item></Item></ItemContainer>
13:54:58 <jle`> @let subList [] _ = []; subList xs [] = xs; subList (x:xs) (y:ys) = subList xs ys
13:55:00 <lambdabot>  Defined.
13:55:01 <jle`> i wonder if this has a name
13:55:02 <merijn> nmdanny: no, I meant like: do you need schema support? are you just scraping messy xml? etc.
13:55:08 <jle`> > subList "abcdefg" [1,2,3]
13:55:10 <lambdabot>  "defg"
13:55:40 <itachi> why does "++ [1,2,3] [4,5,6]" trow an error but not "(++) [1,2,3] [4,5,6]"?
13:55:43 <nmdanny> the XML has a constant schema, but I don't want to create haskell datatypes for it
13:55:56 <jle`> itachi: they are different things, heh
13:56:01 <nmdanny> i'm basically interested in directly manipulating the xml tree
13:56:01 <jle`> ++ is not the same as (++)
13:56:11 <merijn> nmdanny: I've had some succes using xml-conduit for scraping
13:56:13 <nmdanny> that would mean, inserting, replacing and deleting nodes
13:56:17 <jle`> itachi: ++ is an infix operator, and (++) is a prefix function
13:56:35 <nmdanny> xml-lens is based on xml-conduit
13:56:56 <monochrom> [1,2,3] ++ [4,5,6] will not throw an error.
13:57:01 <jle`> although i can see why you might expect (blah) and blah to be the same
13:57:33 <jle`> btw, in haskell, you can convert any prefix non-operator function into infix, as well, using backticks
13:57:48 <jle`> > 3 `subtract` 10
13:57:50 <lambdabot>  7
13:57:54 <jle`> > 3 `elem [1..10]
13:57:56 <lambdabot>  <hint>:1:9: error: parse error on input ‘[’
13:57:57 <jle`> > 3 `elem` [1..10]
13:57:59 <lambdabot>  True
13:58:16 <jle`> so, you can use backticks to turn a non-operator prefix function into infix, and you can use parentheses to turn any operator infix function into prefix
13:58:17 <monochrom> Unfortunately 3 `(+)` 4 doesn't fly.
13:58:43 <itachi> k got it :)
13:58:44 <Aruro> itachi: try :i (++) in ghci
13:58:46 <jle`> (`(+)`) 3 4      would have been nice
13:59:06 <monochrom> lovely bear face or something
13:59:48 <itachi> "infixr 5 ++" decides the precedence in which it will be used right?
13:59:58 <monochrom> yes
14:01:06 <monochrom> ("(∨)")
14:02:08 <Aruro> itachi: btw :i ++ works as expected
14:02:12 <merijn> on the bright side, GHC ignores the report and allows ಠ_ಠ as identifier :)
14:02:33 <merijn> See: acme-lookofdisapproval
14:03:12 <merijn> A flaw in the report that Haskell Prime will hopefully fix ;)
14:03:44 <Aruro> so no good april first Haskell news?
14:04:01 <monochrom> How did the Haskell Report disallow it?
14:04:53 <merijn> monochrom: Well, you know the unicode bits of the report's syntax? That allow constructors to start with any uppercase letter?
14:05:09 <monochrom> Yes.
14:05:24 <merijn> monochrom: They explicitly specified non-constructor identifiers to start with lowercase letters, as opposed to "not uppercase"
14:05:36 <merijn> monochrom: Now, naively, you'd say those are the same thing. And you'd be wrong ;)
14:05:40 <monochrom> Oh, there is a middle.
14:06:10 <merijn> ಠ is a letter from the Kanada writing system, which doesn't have cases and is thus neither upper nor lowercase according to unicode :)
14:06:27 <merijn> And thus, technically, not a valid identifier
14:06:44 <monochrom> Yeah, that's too bad. False dichotomies die die die.
14:07:13 <monochrom> The other die die die false dichotomy is prime vs composite. Causes endless quarrels on 1.
14:07:39 <merijn> monochrom: Not if we fix the abomination and define 1 to be prime!
14:08:02 <monochrom> That would be royally inconvenient.
14:11:44 <Unicorn_Princess> I hope you'll like this: https://my.mixtape.moe/ygcxko.webm
14:13:46 <Aruro> monochrom: wiki tells prime has to be bigger than 1
14:15:04 <Aruro> its needed to exclude ambiguity in factorization
14:15:38 <rjg_> does the output of trace (and its derivates) go to stdout or stderr?
14:15:56 <jle`> i know a way to find out
14:17:00 <nmdanny> is it possible to do in-place manipulation of XML trees with xml-conduit?
14:17:07 <nmdanny> with their cursor interface^
14:17:09 <monochrom> You are like me. When someone here asks "why is f x y parsed as (f x) y?", I shallowly answer "because Haskell 2010 says so", evading the real question of why the Haskell designers designed it so.
14:17:49 <monochrom> It is very leisurely to just cite authority and never critically think about it.
14:18:52 <monochrom> And even unique factorization does not explain why don't we classify 1 as a composite.
14:22:59 <Aruro> i cited modern source, no dichotomy
14:23:11 <Aruro> prime Has to be bigger than 1, problem solved?
14:23:13 <dmj`> what was the max # of fields a haskell record can have?
14:23:50 <monochrom> I think it's up to individual compilers.
14:23:53 <merijn> dmj`: According to the spec? I don't think there's a limit. According to GHC? Several tens, because after that (well, even before that) compile time blows up
14:24:11 <monochrom> I think GHC's is around 64 +/- 1 or something.
14:24:30 <merijn> For tuples, yes. Not sure if that holds for ADTs, though?
14:24:37 <Unicorn_Princess> why would nb. of fields explode compile times? :S
14:24:43 <monochrom> Oh! Right, I don't know.
14:25:07 <merijn> Unicorn_Princess: I'm not ruling out some Shlemiel the Painter algorithm somewhere
14:25:10 <monochrom> Type inference time is exponential to program length.
14:25:40 <merijn> monochrom: Naah, it's because it blows up the memory GHC uses, resulting in lots of swapping
14:26:25 <merijn> monochrom: There's this pandoc dependency for bibtex stuff that has one or two ADTs with huge number of fields, and in 7.6/7.8 compiling that would balloon to comical (if you didn't care about actually finishing >.>) sizes
14:26:48 <monochrom> OK, I suppose it is just space in the case of long tuples or products.
14:27:37 <merijn> ugh...I hate it when I'm required to think to write my code >.<
14:29:52 <monochrom> You don't think to walk, only because you have walked so many thousands of hours.
14:30:14 <monochrom> So write more code. Keep writing until you don't need to think anymore.
14:30:30 <merijn> monochrom: That only works if you keep writing code at the same difficulty level :p
14:31:29 <monochrom> Yeah, well, First World problems.
14:42:43 <sophiag> what does SrcLoc mean in ASTs?
14:42:59 <merijn> sophiag: The location in the source where said part was defined? :)
14:43:35 <sophiag> ha
14:44:08 <sophiag> the context is in lambdas so i assume it uses the location sort of as a var to distinguish between them
14:44:31 <merijn> sophiag: No, I would expect it to be the source code line that defined the lambda
14:45:34 <sophiag> yeah. because it's "1-1" in ghci :)
14:50:47 <geekosaur> it's mostly there to show locations in error messages
14:51:13 <sophiag> i was curious because i'm trying to construct one and can't find it in the docs
14:51:49 <koala_man> zsh
14:51:52 <koala_man> derp
14:56:52 <dzdcnfzd> Does anyone have any idea why stack might be failing to install aeson-1.0.2.1? The message is Rule "FromJSONKeyCoerce: fmap id" may never fire           because ‘id’ might inline first         Probable fix: add an INLINE[n] or NOINLINE[n] pragma for ‘id’
14:59:08 <dzdcnfzd> And, just generally, I can't figure out how to trouble-shoot this sort of thing
15:13:17 <bennofs> dzdcnfzd: this sounds like it should be a warning, not an error to me?
15:16:15 <dzdcnfzd> bennofs: http://lpaste.net/354158
15:16:20 <dzdcnfzd> am I missing something
15:31:30 <geekosaur> uhhhhh
15:31:43 <geekosaur> ExitFailure (-11) has a rather high chance of being the compiler segfaulted
15:32:59 <dzdcnfzd> geekosaur: whoa
15:33:07 <dzdcnfzd> is there any fix for that?
15:34:01 <ggVGc> don't write software
15:34:02 <geekosaur> https://github.com/commercialhaskell/stack/issues/2575 looks related
15:34:06 <ggVGc> ^ fixes all bugs
15:34:43 <geekosaur> it suggests the real problem is out of swap and it showed up as a segfault probably because of the new memory allocator not handling that well?
15:34:56 <ggVGc> geekosaur: please explain to me if haskell is so good, and the compiler is written in haskell, then how can the compiler break?
15:35:03 <ggVGc> :(
15:35:40 <geekosaur> (more specifically, I'd guess someone did not consider that an allocation failure, the way they are doing it, probably *will* show up as a segfault)
15:36:59 <geekosaur> (there is no guarantee you get back success/failure from the madvise() call, actual page allocation may not happen until it's first written to and if it fails you take a segfault...)
15:38:08 <MarcelineVQ> dzdcnfzd: what version of stack do you have
15:38:57 <geekosaur> oh, and nobody would likely have caught that failure mode because often the OOM killer will trigger first, but if it doesn't then you get a segfault. wonder if that should be reported...
15:39:48 <geekosaur> hah, I didn't finish reading the bug, it's already reported. will comment
15:45:20 <sophiag> geekosaur: i'm still stuck on this data type for storing lambdas =(
15:45:34 * geekosaur updates ghc bug report
15:45:53 <geekosaur> not sure I can help, to be honest
15:45:59 <MarcelineVQ> but was it ghc that error 11'd or stack
15:46:31 <geekosaur> stack was running to report the ExitFailure
15:46:35 <geekosaur> so it would have been ghc
15:47:25 <sophiag> my issue is just with the types at this point :/
15:47:44 <MarcelineVQ> geekosaur: sounds reasonable
15:49:44 <geekosaur> sophiag, the problem is, it's not "just" the type; the way you were trying to do it, there's no way to assign a type to it without causing other problems.
15:50:04 <geekosaur> (Like, you can hide it in an existential, but then you can't do anything with it.)
15:50:12 <geekosaur> (including match it with other types)
15:50:35 <sophiag> actually if i *could* hide it in an existential i'd be fine. i can't because it needs an Eq constraint
15:50:39 <tobiasBora> srhb: Ok thank you!
16:26:36 <b_perez_> is there way to get polymorphic type info from reify in TH? For example, lets say I have some Exp with type Maybe String and I want to use reify to see if its a member of Maybe a
16:28:32 <b_perez_> In other words, I want to catch all expressions in some function declaration that are in some monad m using TH
16:29:37 <lyxia> You can just check the type constructor
16:32:34 <b_perez_> so just pattern match and make sure it starts with an IO constructor and add some extra stuff to make sure its not like IO String -> IO () or whatever?
16:33:52 <lyxia> If it "starts with" IO it can't be a function.
16:34:34 <lyxia> IO String -> IO ()  has (->) as the constructor at the root. IO String   has IO.
16:34:40 <b_perez_> right right
16:34:45 <b_perez_> thanks!
16:35:00 <lyxia> yw
17:00:01 <mjhoy> maybe a stupid question; why is Network.Wreq.get :: String -> IO (Response BSL.ByteString) and not something like String -> IO (Either HttpException (Response BSL.ByteString))
17:05:47 <tikhon> I'm curious about how people approach logging. Do you ever log things from pure functions?
17:07:13 <jle`> usually only for debugging purposes
17:07:53 <jle`> mjhoy: a lot of people prefer to use IO's exception system to handle IO exceptions
17:08:23 <jle`> as opposed to Either
17:08:41 <jle`> there are a lot of neat tools built into GHC to make it a smooth process
17:09:08 <mjhoy> jle`: hmm. is there an easy way to convert to using Either?
17:09:14 <jle`> yes
17:09:34 <jle`> using try
17:09:44 <jle`> try :: Exception e => IO a -> IO (Either e a)
17:09:57 <mjhoy> ah. thanks!
17:10:04 <jle`> so try (Network.Wreq.get "foo") :: IO (Either HttpException (Response BSL.ByteString))
17:10:44 <jle`> mjhoy: but, a lot of times you don't want the Either excplicitly, and just want to handle the exception right there
17:10:58 <jle`> for that you can use 'catch' or 'handle', or any of the other nice combinators in the Control.Exception module :)
17:12:00 <mjhoy> jle`: hmm. I'm requesting an xml document and then parsing it. I would have thought it'd just be easier to use Either for failure at any point
17:12:54 <jle`> using the exceptions system integrates with a lot of other parts of haskell IO nicely
17:13:06 <jle`> but you can always "convert to Either" using try if you actually wanted an Either
17:15:02 <mjhoy> thanks. i should probably try both to really understand it.
17:54:26 <Sornaensis> is there a way to pass C-- code to ghc
17:55:04 <c_wraith> Sornaensis: look for documentation on writing your own primops
17:55:17 <c_wraith> Sornaensis: it's a recent addition to GHC, but it exists
18:07:54 <Sornaensis> c_wraith: I looked around but what I am trying to do I guess is use ghc to compile c-- directly
18:08:24 <geekosaur> afaik the only way to *run* cmm is for it to be a primop
18:16:26 <Sornaensis> geekosaur: instead of haskell I want to pass in cmm
18:16:31 <Sornaensis> is this possible
18:16:43 <geekosaur> not so far as I know
18:18:29 <Cale> There was a C-- compiler which got split off from GHC's development a long time ago, but they've diverged.
18:21:22 <Sornaensis> Cale: is it still actively developed?
18:21:36 <lyxia> heheheh (return () :: MaybeT (... (MaybeT (MaybeT Identity))...) ()) has complexity O(2^(number of MaybeT))
18:21:56 <Sornaensis> x___X
18:23:20 <Cale> Sornaensis: I have no idea
18:23:28 <Cale> My guess would be no
18:48:26 <alx741> hello everyone, I runned into a problem: I need basically to do this "function n = g 3 (g 2 (g 1 n))" where 'g' is a function, but I need to do that for a list if 'Int' (so I'ts general and i don't have to hardcode those numbers there). Any help apreciated it
18:49:35 <alx741> I think it answer should be obvios, but at these point I just can't work it out
18:52:11 <dolio> This sounds like a homework question.
18:53:48 <Welkin> lol
18:54:01 <Welkin> alx741: that is just a right fold
18:54:17 <atec> Hey guys, I'm having some trouble using Slack's API with Network.HTTP.Conduit
18:54:23 <alx741> it's not, it's just I ended up in a sutiation in with that as a fold does not work
18:54:39 <atec> I was lead there because I need HTTPS
18:54:46 <alx741> Welkin: Yes, I know, I just notice i didn't expres the actual problem there
18:54:48 <atec> But it still says I'm not authed 
18:55:38 <atec> Does anyone know if there is anything I have to do to prepare the request? Or is simpleHttp on the URL enough?
18:58:00 <alx741> the problem is, that if I do "function p = foldr g p p", every aplication of 'g' needs to use the new changed p rather than the old one
18:58:47 <alx741> I'm having trouble even expressing the issue
18:58:54 <dolio> The 'changed' p is created by applying g.
18:59:11 <alx741> dolio: yes, exactly
18:59:13 <dolio> Although you wouldn't be using p twice.
19:00:39 <alx741> g applies some transformations on p, but these trasnformations needs to be available for the next round of transformations, but of course, the second 'p' there, stays always the same, so i have no clue how to proceed
19:00:51 <atec> Guis. Pls halp 
19:01:11 <Welkin> alx741: just write a recursive function them
19:01:12 <Welkin> then*
19:01:14 <Welkin> it's not hard
19:03:50 <alx741> Welkin: right, didn't try aproaching that way, thanks a lot!
19:05:11 <_sras_> Is there a Type class for Number like things, a money value, that can have operations + - / *, but not other methods in the Num instance?
19:06:09 <Welkin> just Num
19:06:14 <Welkin> you can write your own typeclass though
19:10:49 <tobiasBora> Hi
19:11:06 <tobiasBora> I don't understand something with the exceptions...
19:12:28 <tobiasBora> Hum...
19:13:00 <tobiasBora> Is the eroor " recv: resource vanished (Connection reset by peer)" a synchronous or asynchronous error?
19:13:34 <geekosaur> synchronous, you only find out the remote went away when you try to do something with the Handle
19:14:39 <tobiasBora> Because I'm using Control.Exception.Safe (note the Safe part) to catch all the errors that goes out of my downloading function:
19:15:33 <tobiasBora> tryAgain = (myfunction xxx) `catch` (\_ -> tryAgain)
19:15:51 <geekosaur> uh
19:16:42 <tobiasBora> And most of the errors are indeed catched, but after a few hours I got an error "recv: resource vanished (Connection reset by peer)" the killed all my threads (I'm using the async lib to deal with threads)
19:16:47 <geekosaur> that error is not recoverable...
19:16:55 <_sras_> Welkin: But It doesn't make sense to have a "fromInteger" for money..
19:17:36 <tobiasBora> geekosaur: Really? So it means that whatever I do, if I've a "recv: resource vanished" error, my client will die???
19:18:07 <geekosaur> it means retrying like you do won;t help
19:18:15 <geekosaur> the remote is not going to un-close its end of the connection
19:18:22 <geekosaur> (in fact it can't)
19:18:55 <geekosaur> you'll just get an endless stream of that exception over and over, and you may be discovering some place where exceptions 'leak'
19:19:19 <tobiasBora> I don't follow what you say...
19:19:42 <geekosaur> "Connection reset by peer"
19:19:42 <geekosaur> the other side of the network connection *is gone*
19:19:57 <tobiasBora> geekosaur: Yes, but if I recreate the connection?
19:20:01 <geekosaur> you can retry all you want, you'll just get that again and again and again
19:20:08 <geekosaur> then it's a new connection, not the one you are working with
19:20:12 <geekosaur> that connection is dead
19:20:14 <tobiasBora> yes sure
19:20:17 <tobiasBora> I don't mind
19:20:36 <tobiasBora> actually when I try again, I even change the proxy
19:20:56 <tobiasBora> so here "myfunction" contains everything
19:21:06 <geekosaur> I also wonder what happens if you do an exception handler inside an exception handler; that's a nice corner case if they end up nesting deeply
19:21:16 <tobiasBora> : the request creation, the sending, the receiving, the parsing...
19:22:31 <geekosaur> so I am looking at the safe-exceptions package, and while this is technically 'synchronous' it's handled as asynchronous
19:22:51 <geekosaur> because retrying is assumed not to work, because it thinks you will retry with the same connection
19:23:54 <geekosaur> also, arguably you are doing ti wrong; you should be using bracket around the network connection; that's the only way this exception can be handled even partially synchronously
19:24:06 <geekosaur> otherwise you can leak sockets
19:25:04 <geekosaur> hm, looking coser, I guiess it does handle as synchronous. but still, you want bracket or you can leak the socket
19:25:27 <geekosaur> because throwing the exception will bypass any code that cleans up after the socket. that's what bracket is for
19:25:32 <tobiasBora> What do you mean by leak the socket?
19:25:39 <tobiasBora> ok
19:26:17 <geekosaur> it never gets closed
19:26:25 <tobiasBora> But I don't understand how you use brackets to avoid this problem
19:26:45 <geekosaur> Control.Exception.Safe.bracket
19:26:55 <tobiasBora> And is it really important if the socket is not closed ?
19:27:02 <tobiasBora> oh bracket the function
19:27:06 <geekosaur> yes, because they consume OS file handles and you will run out
19:27:13 <tobiasBora> ok
19:27:56 <tobiasBora> But let's imagine I use bracket
19:28:13 <geekosaur> and it won't necessarily close stuff that went out of scope via an exception --- that's specifically why the dsafe-exceptions README talks about resource allocation, the normal allocation stuff doesn't behave nicely in the presence of exceptions
19:28:25 <geekosaur> it *will* eventually get cleaned up... but it may be a long time
19:30:56 <tobiasBora> but wait, I'm using "httpLbs requestWithProxy (manager sharedData)" to connect
19:30:59 <julianleviston> I’ve been trying to build a bunch of prisms around Haskell.Language.Exts… the Literal type presents no problem at all, but I’m having trouble with the Exp type, in particular multiparamater Sum elements such as InfixApp. How would one build a prism from that?
19:31:06 <tobiasBora> so I don't have any way to close it properly no?
19:31:36 <julianleviston> This is how I build prism for Char, for example: _Char = Lens.prism Char (\s -> case s of (Char i) -> Right i ; _ -> Left s)
19:31:52 <geekosaur> tobiasBora, then hope the library is doing it and rethrowing... but it'll likely be throwing a normal exception and it may be handled as async
19:32:50 <tobiasBora> geekosaur: So you mean that the "recv: resource vanished (Connection reset by peer)" error can be both sent async or sync?
19:33:02 <_sras_> How can I model Monetary values in Haskell so that I can do something like, mempty :: Money USD = 0 USD?
19:33:15 <geekosaur> which might also be a problem; safe-exceptions README warns against mixing it with regular exceptions, but most of the libraries you would use throw regular exceptions. I don't know if it handles those as anything other than async, since it wasn't thrown with its functions
19:33:32 <geekosaur> so it would have to assume async
19:35:41 <julianleviston> _sras_: Sorry I don’t quite understand your question. Could you rephrase a bit with some more info?
19:37:16 <Luna521> haskell is hard -_-！
19:37:21 <mounty> _sras_:  you mean you want to model monetary values using Monoid?
19:37:32 <mounty> Luna521:  maybe so but the rewards are great.
19:39:02 <Luna521> yes itis very great ，i like haskell
19:39:42 <tobiasBora> geekosaur: Haskells exceptions are way to complicated ^^ What do you call "regular exceptions"? Is it sync exceptions? If yes you mean that safe-exception "async" catch do not work nicely with the sync errors?
19:39:43 <julianleviston> mounty: I get the feeling s/he wants to be able to do mconcat (ie <>) on Money a where a is a currency
19:40:13 <_sras_> julianleviston: mounty I was trying to use something like "data Money = Money Scientific Currency" where Currency = USD | INR 
19:41:09 <julianleviston> _sras_: sure, can you give a simple expression that you would like to be able to evaluate using this, and your expected result?
19:41:12 <_sras_> julianleviston: mounty But now I find myself unable to do a fold to sum money values in an array
19:41:14 <geekosaur> reguklar exceptions = Control.Exception
19:42:15 <Squarism> theres no channel that lets multiple threads  write to it (wo duping it) ? 
19:42:25 <tobiasBora> geekosaur: Ah ok... But since it's the libraries that uses Control.Exception, I can't do anything for that right? So Control.Exception.Safe is useless for me?
19:42:52 <glguy> julianleviston: you can make a Prism' Exp (Field1,Field2)
19:43:06 <geekosaur> that is how I read the README, but you'd have to ask Snoyman or study the source to be certain :/
19:43:16 <julianleviston> _sras_: I wonder if mconcat (Money v1 c1) (Money v2 c2) = Money (convertMoney v1 c1 USD) (convertMoney v2 c2 USD) ?
19:43:41 * geekosaur basically thinks synchronous exceptions shouldn't be exceptions, notwithstanding the paean to exceptions earlier in here. we already have Either
19:43:51 <julianleviston> glguy: there are three fields in InfixApp … 
19:44:03 <glguy> julianleviston: ok?
19:44:05 <julianleviston> glguy: I’d like to be able to use over on it
19:44:19 <_sras_> julianleviston: I don't want conversions to happen, and only want to allow operations between values in same currency.
19:44:47 <julianleviston> _sras_: oh ok… that sounds like some kind of value based constraint?
19:45:01 <glguy> julianleviston: and no that's probably not going to work for mappend, it's important that mempty is an identity element for mappend
19:45:17 <julianleviston> glguy: it wouldn’t work at all
19:45:28 <tobiasBora> geekosaur: Ok. So now, if I don't use anymore the safe exception library, and if I do a big catch, such that "UserInterrupt" is not cached, shall it work?
19:45:29 <julianleviston> glguy: ^ the mappend thing
19:45:30 <geekosaur> but exception-lovers think hacks like safe-exceptions solve the problems, when you have to ask "so what really happens if some library throws a Control.Exception exception instead of a "safe" exception?:"
19:46:03 <_sras_> julianleviston: Yes. i guess..
19:46:33 <tobiasBora> geekosaur: Yeah, at the beginning I thought that safe-exception was only a small overhead on top of regular exception, not a complete rewritting
19:47:34 <geekosaur> I don't know if it is or not. from what I read, I would have to go study the source to see whether it's actually safe or does what it leads me to except right up until the big warning not to mix it with Control.Exception exceptions
19:47:44 <geekosaur> which, uh, pretty much everything uses :/
19:49:24 <tobiasBora> geekosaur: Yes, and actually I never throw exceptions by myself...
19:49:42 <tobiasBora> it's always the library
19:51:46 <tobiasBora> The nice thing is that Ctr-C is not catched by the new catch, but I have that the recv exception will be cached this time...
19:52:13 <tobiasBora> The problem is that it's very difficult to test, because it happened maybe once every 15h...
19:54:46 <tobiasBora> So I hope it will be enough, thank you geekosaur!
19:56:03 <julianleviston> glguy: what would a Prism’ Exp (Field1, Field2) do? I’m not sure I understand what Field-N are for, other than to help with tuples?
19:56:40 <glguy> julianleviston: gives you a place to put the fields of the constructor you're making the prism for
19:57:24 <julianleviston> glguy: not sure I follow, sorry… :( This is the constructor I’m trying to write a prism for: InfixApp :: Exp -> QOp -> Exp -> Exp
19:57:40 <julianleviston> glguy: I just want to focus on the first Exp
19:58:01 <julianleviston> glguy: it’s the haskell syntax representing an infix operator application
19:58:17 <glguy> a prism doesn't focus on a single field
19:58:55 <julianleviston> glguy: oh… what does it focus on?
19:59:00 <glguy> it focuses on all the fields
19:59:11 <julianleviston> ah… it focusses on a single item of a sum type
19:59:26 <julianleviston> So I want a lens. 
19:59:27 <julianleviston> duh :)
19:59:36 <julianleviston> you rock :) thanks :)
19:59:44 <julianleviston> a lens within a prism.
20:00:58 <julianleviston> glguy: ok, so I’d do a Prism to (Field1, Field2, Field3), and even make a type for it, and then I could make a lens for each field within that. Yay :)
20:01:09 <glguy> yeah
20:21:21 <julianleviston> glguy: can I tip you somehow?
20:22:12 <julianleviston> I now have data InfixAppExp = InfixAppExp (Exp, QOp, Exp) and _InfixAppExp :: Lens.Prism' Exp InfixAppExp which is great.
20:55:00 <julianleviston> glguy: well thanks, anyway.
21:44:15 <jle`> can i get ghc to infer what kind a given type variable is
21:46:20 <oelewapperke> jle`: you could be a bit more specific with this question. But yes.
21:47:47 <jle`> i have foo :: f a -> Bar a, for example, and i want to infer what the kind of 'f' is
21:47:59 <jle`> in this example i can do it in my head; if a :: k, then f :: k -> Type
21:48:15 <jle`> but can i ask ghc
21:48:24 <glguy> Yes, there's a flag
21:48:34 <jle`> er, i mean, if Bar :: K -> Type, then i can guess that a :: K, and f :: K -> Type
21:48:34 <glguy> -fprint-explicit-kinds
21:48:37 <jle`> hm thanks
21:48:43 <jle`> and then I :t it
21:48:45 <jle`> brilliant
21:49:05 <jle`> thanks :)
21:50:09 <jayshua> Is the only difference between type and newtype that type makes a non-type-system-enforced type and newtype makes a type-system-enforced... "new type"?
21:50:43 <jle`> type is just a lexical alias, more or less
21:50:54 <jle`> newtype makes an actual new type
21:50:59 <glguy> newtype introduces a new, distinct type. type merely creates an alias
21:51:05 <jle`> newtype is closer in nature to 'data' than type is
21:51:09 <zoran119> i built an executable using 'stack build', and am trying to run the executable from '.stack-work/install/x86_64-linux-ncurses6/lts-8.6/8.0.2/bin/' on another machine
21:51:39 <zoran119> i'm getting ' libgmp.so.10: cannot open shared object file: No such file or directory'
21:52:01 <zoran119> i'm thinking that just copying that executable from the .stack-work directory is a bad idea
21:52:45 <zoran119> can anyone confirm my suspicion? and help me get the executable in the correct way
21:53:49 <dolio> zoran119: The problem is most likely that GMP isn't installed on the new machine.
21:55:04 <dolio> Copying the exe could be dicey if you dynamically linked. GMP is one of the things that's always dynamically linked.
21:55:56 <dolio> Oh, alternately, it might be installed, but not the right version.
21:56:32 <zoran119> dolio, interesting
21:57:10 <zoran119> dolio, i was intending to build a http rest service using scotty, and then just copy this executable and run it in docker
21:57:15 <zoran119> dolio, sounds like a bad idea?
21:57:46 <dolio> Well, you can set most stuff to link statically (not sure what the default is with all tools these days).
21:57:59 <dolio> But GMP will never be linked statically, I think.
21:58:13 <dolio> It's not a Haskell library.
21:59:47 <zoran119> dolio, would you know what ubuntu package installs GMP?
21:59:48 <dolio> There's some way to not use GMP, but I'm not sure what happens then linking wise.
22:00:47 <dolio> No, but it'd probably either be 'gmp' or 'libgmp' or something along those lines.
22:08:50 <ludat> zoran119, https://www.fpcomplete.com/blog/2016/10/static-compilation-with-stack maybe this could help
22:48:30 <jle`> anyone know where the proof that the monad instance of list obeys the monad laws can be found online
