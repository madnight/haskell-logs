00:02:23 <grayhatter> https://gist.github.com/7dde0485f1e951feb1c1b8381d3ee03b
00:02:32 <grayhatter> any idea what I'm doing wrong?
00:03:57 <grayhatter> I have no idea why it's returning (String, String, (String, String, String))
00:04:32 <osa1> grayhatter: get rid of `return`
00:04:46 <grayhatter> I thought I tried that
00:05:23 <grayhatter> oh, I did, but now I'm getting a diffirent error, and I read the line numbers wrong -_- thanks osa1 
00:46:44 <quchen> Anyone else using Atom, and did the recent Linter upgrade break your Haskell support as well? Is there a quick fix until the downstream packages adapt?
01:40:25 <ysangkok> how is it possible that I get "Could not deduce (HasInfixDecls QName ds0) from the context ..." but ds0 does not appear in the context?
01:41:15 <ezyang> the goal doesn't necessarily come from context 
02:20:04 <shane> Can anyone suggest a good module for CSV parsing?
02:21:13 <merijn> I mostly hear cassava for CSV, but I've never used it
02:22:13 <shane> Thanks
02:22:54 <ysangkok> if the goal doesn't come from the context, how can I learn where the goal comes from? i presume that i could fix the error by manually requiring the ds0 to an instance of the type class, but if it doesn't appear in the context, where could it be?
02:24:19 <ysangkok> here is the error http://lpaste.net/353629
02:24:29 <ysangkok> and here is the code https://github.com/ysangkok/programatica/blob/master/src/programatica/tools/base/tstModules.hs#L92
02:33:36 <k0ral> Hello
02:34:24 <ysangkok> i wonder if there is a way to defer my error to runtime. changing the definition to say, "if it is an instance of this type class, do this, other wise runtime error"
02:35:39 <ezyang> -fdefer-type-errors? 
02:35:53 <k0ral> after reading https://elvishjerricco.github.io/2016/09/17/abstracting-async-concurrently.html , I'm eager to learn how to apply this trick in practice to add concurrency to my free-monad-based program; is there a code example somewhere ?
02:36:56 <k0ral> I've always wanted to use async but never could as this requires a `MonadBaseControl IO` instance and FreeT isn't
02:37:04 <ysangkok> ezyang: ooh thank you
02:45:08 <Xnuk> Is there a function like Control.Concurrent.Async.race but does not throw an exception when the second returns successful result?
02:46:18 <jle`> ysangkok: "if it is an instance of this type class then do this otherwise runtime error" isn't really possible in haskell
02:46:29 <comerijn> jle`: Actually it is
02:46:36 <jle`> :o
02:46:52 <quchen> Xnuk: You mean one that does not cancel the slower thread?
02:46:54 <comerijn> jle`: Observe this magnificent hack: https://github.com/mikeizbicki/ifcxt
02:47:27 <jle`> this is horrifying
02:47:49 <Xnuk> quchen: yes if the first fails
02:49:16 <Xnuk> If the fast one is successful, cancels the slower one
02:51:07 <merijn> Xnuk: Well, yes, that's kinda the point of 'race'
02:55:40 <Xnuk> but `race (threadDelay (1 * sec) >> fail "foo") (threadDelay (5 * sec) >> return True)` fails
02:56:01 <Xnuk> where sec = 1000000
02:58:31 <Xnuk> I want it returns `True` or `Right True` or `Just $ Right True` or something else contains True
03:02:01 <merijn> Wrap the individual actions in an exception handler before calling race?
03:04:43 <mauke> the most horrible part of ifcxt is that it's not called ifctx
03:04:54 <Xnuk> merijn: making both returns successful result?
03:05:27 <merijn> mauke: or ifctxt
03:27:16 <quchen> Xnuk: You could use »a <- async (...); b <- async (...); result <- join (race (wait a) (wait b))«, would that work?
03:27:28 <quchen> Or does wait cancel its async if it is canceled?
03:28:17 <merijn> quchen: I would assume so
03:30:20 <Xnuk> :t join
03:30:26 <lambdabot> Monad m => m (m a) -> m a
03:31:38 <Xnuk> fmap join $ race (wait a) (wait b) ?
03:41:04 <quchen> fmap join = join
03:41:22 <quchen> (One of the Monad laws)
03:45:33 <Xnuk> but `race` is `IO (Either a b)`
03:46:11 <Xnuk> > join $ Right (Just 4)
03:46:16 <lambdabot>  error:
03:46:16 <lambdabot>      • Couldn't match type ‘Maybe’ with ‘Either a1’
03:46:17 <lambdabot>        Expected type: Either a1 (Either a1 a)
03:59:12 <int-e> Xnuk: using Async primitives, something like http://lpaste.net/3720874479425945600 should work. (warning though, that code is completely untested, I didn't even try to load it)
04:10:45 <Xnuk> int-e: works well, thanks
04:25:10 <sanett> Hey folks I'm having a a really hard time understanding lambda calculus.
04:25:16 <Cale> Hello!
04:25:23 <Cale> Anything I can help with?
04:25:44 <sanett> I now have an expression λz.(n z)(m z) (λx.x), how do I deal with lambda x and lambda x in this expression?
04:25:57 <sanett> lambda z and lambda x*
04:26:19 <Cale> I don't think there's anything to reduce there
04:26:35 <Cale> Unless you intended to have more parens...
04:26:37 <sanett> oh so that's the end of it?
04:27:02 <Cale> If it was (\z. n z (m z)) (\x. x) then you'd have something to do.
04:27:55 <Cale> But generally by convention, lambdas scope as far to the right as possible
04:28:07 <sanett> oh perfect because now I don't know if there's a parenthesis around n and z
04:28:26 <Cale> ah, and the other common convention is that application associates to the left
04:28:36 <Cale> So, f x y z means ((f x) y) z
04:28:49 <Cale> and  n z (m z)  and  (n z) (m z)  means the same thing
04:28:56 <Cale> mean*
04:29:38 <sanett> so how are (\z. n z (m z)) (\x. x)  and λz.(n z)(m z) (λx.x) different?
04:31:03 <Cale> The latter means \z. (((n z) (m z)) (\x. x))
04:31:43 <sanett> ah right lambda goes as far right as possible
04:31:55 <sanett> no I actually meant  (\z. n z (m z)) (\x. x) 
04:33:21 <Cale> Well, those are identical now :)
04:33:33 <Cale> If I understand you
04:35:15 <Cale> (\z. n z (m z)) (\x. x) = n (\x. x) (m (\x . x))
04:35:37 <sanett> right... so I keep this thing (\x.x)
04:35:39 <Cale> and then you can't go any further without knowing n or m
04:35:46 <sanett> right...
04:36:02 <sanett> thanks a lot Cale
04:36:06 <Cale> No problem
05:01:45 <quchen> ezyang: Congratulations! :-)
05:01:54 <quchen> Just heard about your defense
05:11:13 <tabaqui1> I'm trying to make stack package
05:11:37 <tabaqui1> it contains library and executable module depended on it
05:11:44 <tabaqui1> in two separate folders
05:12:28 <tabaqui1> I've added my-lib in .cabal dependencies section
05:12:34 <tabaqui1> and stack build it first
05:13:05 <tabaqui1> and writes a message in .stack-work/log/my-lib.log
05:13:18 <tabaqui1> that package installed in .stack-work/install/...
05:13:36 <tabaqui1> but there is not library and I get compile error while building my-exec
05:13:56 <tabaqui1> what am I doing wrong?
05:14:17 <tabaqui1> library marked as extra-dep in stack.yaml
05:23:32 <maerwald> I forgot how the {..} feature was called, anyone?
05:23:43 <maerwald> and it's not a particularly good google search term
05:25:35 <liste> maerwald: RecordWildCards ?
05:25:40 <liste> maerwald: or NamedFieldPuns
05:25:54 <liste> maerwald: https://ocharles.org.uk/blog/posts/2014-12-04-record-wildcards.html
05:26:11 <Tuplanolla> How about `RecordPuns`?
05:26:19 <ocharles> it's RecordWildCards
05:27:56 <suppi> too wild for me
05:31:57 <tabaqui1> ah, yeah, I've forgot to add actual modules in exposed-modules
05:39:58 <shane> Are there any features in attoparsec that are not present in parsec?
05:41:25 <Clint> automatic backtracking?
05:41:52 <shane> I see...and does attoparsec still have a significant speed advantage?
06:01:31 <md208> hello. what is difference between 'stack' and 'haskell-stack' packages? Sorry if it's obvious, but i am 
06:01:44 <md208> kinda newbie
06:01:58 <md208> I am using Manjaro.
06:05:34 <coot> hello, anybody knows an example of a PureScript project running client side tests in karma?
06:06:38 <codedmart> My project is getting big enough that compilation times are getting noticable. Reading around I foung this as ghc-options `--ghc-options="-O0 -j +RTS -A128m -n2m -RTS"` to reduce compilation times. Are these safe options to use? What am I gaining or sacrificing by using them?
06:07:38 <merijn> codedmart: Looks like it disables optimisation, enables parallelism and increases GHCs memory so it's GCing less
06:08:09 <codedmart> merijn: When you word it like that it only the disable optimizations sounds negative.
06:08:20 <merijn> codedmart: Yeah
06:08:33 <merijn> codedmart: Personally I have a "development" set of flags and a "final compilation"
06:08:51 <merijn> Where I use the "dev" ones only for typechecking/errors/warnings while coding
06:09:04 <codedmart> So I could disable optimizations in development then not for production.
06:09:17 <merijn> In which case the secret "moar speed" setting would be "-O0 -fno-code"
06:09:27 <merijn> which skips optimisations/code generation and only type checks
06:10:00 <merijn> If you use, like, ghc-mod/hdevtools you can configure those to use those flags to be faster
06:10:22 <codedmart> Ah interesting. What do you use the final?
06:10:31 <codedmart> Does it vary
06:10:37 <codedmart> I need to learn the options better.
06:10:58 <codedmart> And do you just use those as cabal flags?
06:11:22 <merijn> codedmart: I use hdevtools, so I specify those options in hdevtools
06:11:48 <merijn> codedmart: The GHC manual is rather elaborate and explains most flags and somehow mostly escapes people's notice :p
06:12:00 <codedmart> :) reading is hard.
06:12:08 <codedmart> Thanks for your help.
06:43:14 <lpaste_> foobar pasted “first 4 digs of las” at http://lpaste.net/353633
06:43:32 <Anon1123097123> #hackthissite
06:43:39 <Anon1123097123> ./join hackthissite
06:48:15 <kshukla> http://lpaste.net/353633 : something funny is happening. `(las 5)` gives 312211 (as expected),`firstNDigs 4 (las 5)` gives 3122 (as expected), but if I change the definition of `las` to `firstNDigs 4 (nextLas (las (n-1)))` I get 3112 (wrong).
06:48:30 <kshukla> http://lpaste.net/353633 : something funny is happening. `(las 5)` gives 312211 (as expected),`firstNDigs 4 (las 5)` gives 3122 (as expected), but if I change the definition of `las` to `firstNDigs 4 (nextLas (las (n-1)))` I get 3112 (wrong).
06:51:04 <kshukla> Basically, firstNDigs and las work fine. But when I modify las to apply firstNDigs on its return value, I get wrong results.
07:04:23 <codedmart> @merijn Do you use stack?
07:04:24 <lambdabot> Unknown command, try @list
07:05:08 <merijn> codedmart: Nope
07:05:30 <codedmart> OK, having issues with hdevtools
07:06:02 <merijn> the one on hackage used to be a bit outdated, not working with recent GHC. Mine is installed from github, I think. Not sure if someone took the hackage project over
07:06:31 <merijn> oh, looks like wat updated in december, so I guess someone took over maintenance
07:10:37 <merijn> codedmart: One common issue I can imagine is that hdevtools uses ghc-the-library to do it's things, so if a stack project uses a different GHC than what hdevtools is built against it might fail
07:11:17 <codedmart> It has something to do with --package-db
07:26:06 <ertes> is there an effectful version of (%%=) in lens?
07:27:35 <ertes> i would use 'zoom', but the lenses in pipes-parse/pipes-bytestring are improper, so i'm a bit worried about repeating effects
07:31:44 <ertes> although it should actually be safe…  'zoom' only uses the lens once
07:31:49 <mutsig> what's the purpose of the "--| some comment" - comments in haskell source codes? In contrast to just "-- some comment" or "{- some comment -}"
07:32:03 <ertes> mutsig: it's haddock's comment syntax
07:32:13 <ertes> its purpose is automated generation of documentation
07:32:22 <ertes> mutsig: https://www.haskell.org/haddock/doc/html/index.html
07:32:42 <mutsig> oh, I see. Thanks ertes
07:33:50 <Tuplanolla> Without the space it's an operator, mutsig.
07:33:56 <Tuplanolla> > let x --| y = x * y + x / y in 42 --| 13
07:33:59 <lambdabot>  549.2307692307693
07:41:18 <orion> Are the objects within Hask Sets?
07:47:25 <eschnett> i believe the objects in Hask are types, which are isomorphic to sets (of the possible values of these types, including “undefined”)
07:51:29 <orion> And are morphisms functions?
07:51:33 <orion> Like, f :: Int -> Int
07:56:06 <NickHu> Yeah
07:56:11 <NickHu> Hask isn't quite what you think it is though
07:56:27 <NickHu> It's not exactly a category of Haskell types as objects and functions as morphisms
07:56:33 <NickHu> Because you have undefined
07:56:40 <NickHu> Which doesn't correspond to anything
07:58:58 <ski> NickHu : i don't follow ..
07:59:10 <mmachenry> NickHu, ski, By undefined we mean bottom, right?
07:59:15 <NickHu> Yeah
07:59:22 <NickHu> undefined :: a
07:59:48 <mmachenry> Yes, that undefined but also all other things that are in bottom that aren't undefined. 
08:00:07 <ski> it's more like the category of pointed sets, than the category of sets, if you account for partiality
08:00:50 <ski> (however, then there's partially defined values which aren't `_|_', but which aren't fully defined either .. so it's a bit more complex than the category of pointed sets)
08:02:39 <ski> in the category of pointed sets, an object is a pair of a set, and a value (a point) in it
08:02:40 <NickHu> mmachenry: That's true, yea
08:03:28 <ski> and a morphism from one such pair `<A,bot_A>' to another `<B,bot_B>' is a function from `A' to `B', that maps `bot_A' to `bot_B'
08:04:08 <NickHu> Ehh, you could do it that way, but all the literature I've ever seen about Hask is the way I described, and people just conveniently don't consider bottoms
08:04:58 <ski> we can think of this as a partial function from `A' to `B', where the values of `A' where the function isn't defined are all mapped to `bot_B' (denoting `undefined'), and where we require `bot_A' to also map there, to not get any more "wiggly room" in how we choose what a partial function does
08:05:47 <ski> in effect, you add a "bottom" element to every set, and by this procedure your partial functions now turn into total functions on these extended (pointed) sets
08:06:08 * ski isn't talking about `Hask' atm, fwiw
08:07:01 <Xnuk> > "🤔"
08:07:04 <lambdabot>  <hint>:1:2: error:
08:07:04 <lambdabot>      lexical error in string/character literal at character '\129300'
08:07:10 <Xnuk> 🤔
08:07:40 <NickHu> ski: I see
08:07:52 <Prutheus> jaspervdj: are you here?
08:07:53 <ski> if we want to be able to model partially undefined values, and non-strict functions, then look into "domain theory" (denotational semantics)
08:08:08 <NickHu> mm
08:08:12 <Prutheus> jaspervdj: I've send you a mail a week ago you havent answered yet
08:08:53 <ski> where there is stilla bottom element of every domain, but now there's also an ordering, e.g. `(_|_,2)' is less defined that `(3,2)'
08:09:44 <ski> and morphisms have to be "monotonic", preserve information. if it maps a partially defined value to some output. then it can't map a *more* defined value to an output having *less* information
08:10:20 <ski> can't retract information about the output that you've already computed, as more information about the input comes in
08:11:15 <ski> if a function maps `(_|_,2)' to `5', then it can't map `(3,2)' to `_|_'
08:12:15 <ski> there's also limits being brought into the sequence
08:13:28 <ski> if you have an increasing sequence `_|_',`2 : _|_',`2 : 3 : _|_',`2 : 3 : 5 : _|_',... (increasing in the definedness sense, not necessarily, in this case, in some natural ordering on the elements of the lists here)
08:14:10 <ski> and you will eventually compute a defined value for any element of the list
08:14:24 <ski> iow you have a computation that (ideally speaking) computes an infinite list
08:14:35 <NickHu> I see; that's pretty cool
08:14:49 <ski> then if you apply a function to it, iow you apply a function to all the above finite approximations of the finite list
08:15:22 <ski> then the sequence of values that you get from applying the function to each finite approximation .. this sequence will also converge
08:15:53 <ski> and you can do stuff along this lines to describe how recursion (e.g. `fix') works
08:16:29 <ski> (er, finite approximaitons of the infinite list)
08:18:36 <centril> I need to make  Maybe an instance of  MonadError () Maybe   ... will this cause an orphan instance given that neither data type and class is defined by me ?
08:22:13 <cocreature> centril: yep
08:22:26 <centril> cocreature: crap :(
08:22:48 <centril> i dont get why Maybe is not an instance of MonadError () Maybe  tho... it should be...
08:22:52 <cocreature> centril: if you don’t want the orphan instance, your only choice is a newtype
08:23:35 <centril> cocreature: Right - I'll go with  Either () a  instead then, since it is already MonadError () (Either ())
08:24:38 <cocreature> centril: if you are working on an executable or a non-public library, orphan instances are also not really a problem
08:25:12 <centril> cocreature: it is intended to be part of a public executable that has a public library forit
08:25:29 <centril> Either () a   is fine i guess
08:25:32 <centril> not that much diff
08:25:47 <cocreature> centril: if it’s part of the executable that’s still not a problem because you can’t depend on it. if it’s part of the public library then you should probably avoid it
08:25:59 <centril> cocreature: part of lib
08:26:20 <centril> cocreature: I guess I could nag the maintainers of mtl / transformers to fix this  ;)
08:28:37 <cocreature> yep :)
08:39:02 <nak> can someone explain this { :: } syntax here newtype EitherT e m a = EitherT { runEitherT :: m (Either e a) }
08:39:06 <nak> what should i be looking up for that ?
08:39:24 <mauke> records
08:39:26 <geekosaur> record syntax
08:39:45 <glguy> nak: Haskell Report section 3.15 : Datatypes with Field Labels
08:39:58 <nitrix> nak: <record constructor> { <field label> :: <type of field> }
08:40:09 <mauke> https://www.haskell.org/onlinereport/haskell2010/haskellch3.html#x8-490003.15
08:40:55 <nak> interesting......
08:41:01 <nak> it creates a new function for each record field ?
08:41:05 <nak> :t runEitherT
08:41:07 <lambdabot> error:
08:41:07 <lambdabot>     • Variable not in scope: runEitherT
08:41:07 <lambdabot>     • Perhaps you meant ‘runWriterT’ (imported from Control.Monad.Writer)
08:41:11 <nak> PHOOEY
08:41:18 <Sornaensis> :t runStateT
08:41:20 <lambdabot> StateT s m a -> s -> m (a, s)
08:41:21 <nak> i will guess tho:
08:41:30 <Sornaensis> @src runStateT
08:41:31 <lambdabot> Source not found. That's something I cannot allow to happen.
08:41:33 <nak> runEitherT :: Either e m a -> Either e a 
08:41:35 <nak> is that right ?
08:41:55 <glguy> nak: No, you dropped a 'T'
08:42:00 <glguy> and an 'm'
08:42:01 <nak> let's try again
08:42:27 <nak> runEitherT :: EitherT e m a -> m (Either e a)
08:42:38 <codedmart> I am struggling with lenses a bit. I want to use putObject from amazonka but use poaACL to modify the acl field? https://www.stackage.org/haddock/nightly-2017-03-03/amazonka-s3-1.4.5/Network-AWS-S3-PutObject.html#v:putObject
08:42:50 <codedmart> Not sure the proper syntax. Never used lenses before.
08:43:23 <nak> so intuitively, runEitherT just unwraps an EitherT and gives us the underlying monad ?
08:46:21 <mauke> codedmart: me neither, but 'set poACL x (putObject ...)' maybe?  /me closes eyes and prepares for type errors
08:46:29 <nak> so in order to wrap a monad in EitherT we must EitherT { runEitherT = mypatheticmonad }
08:46:50 <nak> ?
08:47:04 <glguy> nak: It's uncommon to use record syntax to construct an EitherT. You can just write: EitherT yourThing
08:47:14 <nitrix> nak: You have to wrap an `Either e a` in the monad you're transforming.
08:47:30 <mauke> that's not what a "monad" is, btw
08:47:46 <codedmart> mauke: Ah I had it backwards. I was trying `putObject .. <&> set poACL ..`
08:47:49 <codedmart> Thanks!
08:48:09 <mauke> isn't <&> the fmap one?
08:48:12 <nitrix> @unmtl EitherT String IO Int -- nah
08:48:12 <lambdabot> EitherT String IO Int
08:48:15 <nitrix> *nak
08:48:17 <mauke> :t (<&>)
08:48:19 <lambdabot> Functor f => f a -> (a -> b) -> f b
08:48:25 <mauke> :t (&)
08:48:27 <lambdabot> a -> (a -> b) -> b
08:48:38 <mauke> codedmart: looks like & would work
08:48:45 <nitrix> Why's lambdabot struggling here?
08:48:50 <nitrix> @unmtl EitherT String IO Int
08:48:51 <lambdabot> EitherT String IO Int
08:48:55 * nitrix scratches head
08:48:57 <nak> glguy: interesting. so if i don't specify the field names for record syntax, the field values will be assigned in order of their definition ?
08:48:58 <mauke> EitherT isn't mtl
08:49:01 <glguy> @unmtl ErrorT String IO Int
08:49:02 <lambdabot> IO (Either String Int)
08:49:25 <nak> glguy: eg data Foo = Foo { bar :: String } deriving (Show) -- Foo "hello" == Foo { bar = "hello" } 
08:50:08 <codedmart> mauke: Just `&` and not `<&>`? `&` doesn't seem to work, but I will play with it some more. Thanks!
08:50:12 <mauke> @let data SomeRecord = MkRecord { field_1 :: String, field_2 :: Int } deriving (Eq, Ord, Read, Show)
08:50:16 <lambdabot>  Defined.
08:50:22 <mauke> > MkRecord "hello" 42
08:50:26 <lambdabot>  MkRecord {field_1 = "hello", field_2 = 42}
08:50:34 <nak> FANCIFUL
08:50:56 <mauke> > MkRecord "hello" 42 == MkRecord { field_2 = 42, field_1 = "hello" }
08:50:59 <lambdabot>  True
08:51:21 <nak> mauke: a+ demonstration, thank you
08:53:19 <mauke> > ("x", "codedmart") & set _1 42
08:53:24 <lambdabot>  (42,"codedmart")
08:53:38 <Sornaensis> :t set
08:53:40 <lambdabot> ASetter s t a b -> b -> s -> t
08:53:41 <Sornaensis> lenses are magic
08:53:49 <Sornaensis> look at all that black magic, wtf
08:53:54 <mauke> lenses are s t a b b y
08:54:18 <mauke> set's type is easy, though
08:54:20 <Sornaensis> :t _1
08:54:23 <lambdabot> (Field1 s t a b, Functor f) => (a -> f b) -> s -> f t
08:54:24 <int-e> don't put lenses in your eyes... wait.
08:54:51 <mauke> set takes a field descriptor, a new (field) value, and a record
08:54:56 <codedmart> mauke: Thanks, I must have had a different syntax error. I appreciate it.
08:54:59 <mauke> and it returns a record the the field has that new value
08:55:25 <mauke> & is backwards $
09:02:10 * nak is not ready for lenses
09:03:06 <ocharles> I wish we had |> and <| instead of & and $ :(
09:03:14 <mutsig> Can lenses be used on newtypes? Not that I see a reason, just curious.
09:03:23 <ocharles> mutsig: they certainly can
09:03:32 <Cale> ocharles: I kinda just wish we didn't have &
09:03:39 <ocharles> And _Wrapped is a batteries-included lens (at least with the `lens` library)
09:03:55 <Tuplanolla> I sometimes wish we had no operators at all.
09:03:57 <ocharles> Cale: I've come to really like forward application for some things
09:04:33 <Cale> There are a few places where it's idiomatic already, but mostly it just bothers me when anyone uses it
09:05:19 <ocharles> I think we need both forward and backward, because I think things come out more readable if you're at least consistent in your order of composition
09:05:29 <ocharles> there's so much code that use >>= and ., information flows all over the place like that
09:10:33 <Cale> ocharles: I rarely actually use (>>=) directly.
09:10:47 <Cale> It's (=<<) or do-notation
09:12:48 <dolio> I feel like <&> is nicer in a lot more situations than &.
09:12:58 <dolio> But I think some people disagree with me.
09:17:29 <robkennedy> Does >=> offer performance improvements? Or will ghc just replace >>= with >=> when it can?
09:17:47 <Cale> No
09:18:12 <Cale> If anything, it potentially harms performance very slightly, but that won't usually happen because it should inline
09:18:55 <ocharles> Cale: good! I wish my colleagues were as good as you :p
09:19:24 <ocharles> I've finally stopped them importing Control.Arrow and using &&& everywhere though
09:19:33 <robkennedy> It seems like >=> would inline much easier than >>=. But I suppose that's been solved probably
09:20:26 <Cale> Just checking one of our projects... in the backend which is about 9100 lines of Haskell, there are 3 occurrences of >>= two of which are followed by a \case and the other of which, well, I don't hate it, but should probably be a do-block anyway
09:21:36 <ocharles> 203 occurrences here, in 31k lines of Haskell
09:21:40 <Cale> In the frontend, which is about 18000 lines of code, there's 12 occurrences, three of which are followed by \case, and the rest of which are all things I should probably stamp out
09:21:49 <ocharles> and wtf, since when did we have 31k lines
09:22:02 <Cale> (I'm using sloccount to count)
09:22:09 <ocharles> cloc here
09:23:24 <Cale> altmappend (cn ^? _ConversationId_Direct >>= SP.other i) (cn ^? _ConversationId_Sidebar . _1 >>= exclusiveOther i) -- whoever wrote this needs talking to
09:23:27 <Cale> :D
09:23:41 <ocharles> haha
09:23:45 <ocharles> let me see what gems I can dig up
09:24:13 <ocharles> join $ readMay . uncurry (<>) . (T.toUpper . T.take 1 &&& T.toLower . T.drop 1) . head <$> M.lookup k 
09:24:30 <ocharles> god damnit team.. stahp. wat r u doing.
09:25:04 <ocharles> This pattern shows up so often I can actually quickly understand this, but so many times I've had to manually inline the definitions of &&& and `.` just to see what the hell is going on
09:25:25 <Cale> The (.)'s don't bother me at all, and the (&&&) I'm okay with
09:25:37 * ocharles hisses
09:25:40 <Cale> It's the head that worries me
09:25:52 <ocharles> that too
09:26:08 <bennofs> ocharles: I'd have to look up the precendence of &&& vs (.)
09:26:14 <Cale> and the join isn't so wonderful there
09:26:25 <bennofs> that line is just too long
09:26:38 <bennofs> it would be fine if some of the subexpressions were given names I think
09:26:41 <ocharles> basically there's nothing ok with it
09:26:44 <ocharles> we're on the same page then ;)
09:27:01 <Cale> It's basically titlecasing something
09:27:01 <bennofs> o.o why does it use join
09:27:07 <bennofs> and not just =<<
09:27:09 <Cale> I don't know that the rest is about
09:27:11 <MarcelineVQ> also whether lookup or readMay fails isn't known ye?
09:27:32 <ocharles> bennofs: lookup can fail and readMay can fail
09:28:11 <Cale> toTitle :: Text -> Text   O(n) Convert a string to title case, using simple case conversion. Subject to fusion.
09:28:58 <Cale> Well, that'll do every word
09:29:01 <Cale> which you might not want
09:29:16 <bennofs> what, how does this code even compile. The <$> is using the (->) r instance, right?
09:29:52 <Cale> > uncurry (<>) . (T.toUpper . T.take 1 &&& T.toLower . T.drop 1) $ "hello"
09:29:54 <jaspervdj> Prutheus: Yeah sorry -- I'll check if I have time to go through it tomorrow.  Been busy with work and zurihac stuff.
09:30:03 <lambdabot>  mueval-core: Time limit exceeded
09:30:05 <Cale> ...
09:30:06 <Cale> > uncurry (<>) . (T.toUpper . T.take 1 &&& T.toLower . T.drop 1) $ "hello"
09:30:11 <lambdabot>  error:
09:30:11 <lambdabot>      Not in scope: ‘T.toUpper’
09:30:11 <lambdabot>      No module named ‘T’ is imported.error:
09:30:19 <Cale> ah, we don't have Data.Text
09:30:33 <bennofs> @let import qualified Data.Text as T
09:30:36 <lambdabot>  Defined.
09:30:42 <Cale> > uncurry (<>) . (T.toUpper . T.take 1 &&& T.toLower . T.drop 1) $ "hello"
09:30:45 <lambdabot>  error:
09:30:45 <lambdabot>      • Couldn't match type ‘T.Text’ with ‘[Char]’
09:30:45 <lambdabot>        Expected type: [Char] -> (T.Text, T.Text)
09:30:52 <Cale> > uncurry (<>) . (T.toUpper . T.take 1 &&& T.toLower . T.drop 1) . T.pack $ "hello"
09:30:55 <lambdabot>  "Hello"
09:31:01 <bennofs> yeah that makes sense so far
09:31:06 <bennofs> :t readMay
09:31:09 <lambdabot> error: Variable not in scope: readMay
09:31:15 <bennofs> @hoogle readMay
09:31:19 <Cale> oh jeez
09:31:22 <lambdabot> Safe readMay :: Read a => String -> Maybe a
09:31:22 <lambdabot> BasicPrelude readMay :: Read a => Text -> Maybe a
09:31:22 <lambdabot> ClassyPrelude readMay :: (Element c ~ Char, MonoFoldable c, Read a) => c -> Maybe a
09:31:30 <Cale> is this like, turning  true  into  True  and then reading it?
09:31:30 <ocharles> bennofs: there might have been something else important on the next line, I was just providing an example of the horrors deep in some of the legacy code
09:31:40 <ocharles> I wouldn't put it past it
09:31:42 <bennofs> Cale: looks like it
09:31:52 <ocharles> Let me go and actually open this file :p
09:31:54 <Cale> That's pretty questionable
09:32:03 <bennofs> ocharles: oh, yes. But one could have just written it with =<< instead of join $ f <$> bla
09:32:18 <ocharles> https://www.irccloud.com/pastebin/zbDmq7nr/
09:32:29 <Profpatsch> Cale: I very often user >>= \case
09:32:30 <Cale> Probably just needs some lambdas
09:32:31 <Profpatsch> I thank thaw
09:32:34 <ocharles> It's for query parsing in URLs, so yes, it looks like it does parse true to True and false to False
09:32:35 <Profpatsch> I love that idiom
09:32:49 <Cale> Yeah, >>= \case is one of the only places where I actually like >>=
09:33:08 <bennofs> Cale: what do you use instead of >>=? do notation or =<< ?
09:33:18 <Cale> bennofs: Yes
09:33:22 <ocharles> :)
09:33:38 <Cale> and the occasional <=<
09:33:44 <bennofs> ocharles: i would replace uncurry (<>) by foldOf both #lensforlife :D
09:34:12 <Cale> pls
09:34:21 <Cale> There's nothing worse than abuse of lens
09:34:34 <Tuplanolla> How about abuse of children?
09:34:36 <bennofs> is this an abuse ? foldOf both is pretty clear to me
09:35:01 <Cale> Tuplanolla: hmm, uniplate also can get pretty crazy
09:35:45 <Cale> http://hackage.haskell.org/package/uniplate-1.6.12/docs/Data-Generics-Uniplate.html#v:children
09:35:55 <Tuplanolla> Yes.
09:36:25 <ocharles> uniplate is already an abuse with it's horrific orphan instance modules
09:36:46 <bennofs> :t T.splitAt
09:36:49 <lambdabot> Int -> T.Text -> (T.Text, T.Text)
09:36:56 <bennofs> > T.splitAt 0 ""
09:37:00 <lambdabot>  error:
09:37:00 <lambdabot>      • Couldn't match expected type ‘T.Text’ with actual type ‘[Char]’
09:37:00 <lambdabot>      • In the second argument of ‘T.splitAt’, namely ‘""’
09:37:01 <bennofs> > T.splitAt 1 ""
09:37:04 <lambdabot>  error:
09:37:04 <lambdabot>      • Couldn't match expected type ‘T.Text’ with actual type ‘[Char]’
09:37:04 <lambdabot>      • In the second argument of ‘T.splitAt’, namely ‘""’
09:37:05 <bennofs> > T.splitAt 1 (T.pack "")
09:37:09 <lambdabot>  ("","")
09:37:52 <bennofs> :t foldOf both . over _1 T.toUpper . T.splitAt 1 
09:37:54 <lambdabot> T.Text -> T.Text
09:38:25 <ocharles> or just over _head T.toUpper
09:38:35 <bennofs> ocharles: does that work for Text?
09:38:45 <ocharles> if it doesn't it should
09:38:53 <bennofs> :t over _head
09:38:55 <lambdabot> Cons t t a a => (a -> a) -> t -> t
09:38:58 <ocharles> Cons Text Text Char Char
09:38:59 <ocharles> should work fine
09:39:05 <ocharles> (that instance exists)
09:39:20 <bennofs> ocharles: you'd need to use Data.Char.toUpper and not Text.toUpper then though
09:39:34 <ocharles> we have some stupid overloaded monofoldable toUpper thing in scope
09:46:49 <grayhatter> is there a list of infix operators?
09:47:11 <grayhatter> eg, where I referenec <$>, $, <>, <*>
09:49:06 <geekosaur> no, because it depends on what linraries you use
09:49:08 <MarcelineVQ> I used to use http://stackoverflow.com/questions/7746894/are-there-pronounceable-names-for-common-haskell-operators a lot, it's not exactly reference since it's just names though
09:49:08 <Gurkenglas> hayoo successfully searches for them
09:49:09 <geekosaur> *libraries
09:49:25 <Gurkenglas> http://hayoo.fh-wedel.de/?query=%3C%24%3E
09:49:31 <geekosaur> infix ops are not wired into the language like they are in java or c++
09:50:43 <merijn> geekosaur: Well, to be fair, he only asked about a lot common operators from base, and I assume someone made a reference for those somewhere
09:51:12 <geekosaur> probably, but even those change :)
09:51:15 <MarcelineVQ> also relevant, but just names, https://wiki.haskell.org/Pronunciation
09:51:48 <geekosaur> of those four, three are fairly recent
09:52:30 <merijn> geekosaur: Applicative is from like 2004, no? Not sure you can still call that recent
09:52:39 <merijn> geekosaur: That's 13 years ago >.>
09:53:00 <geekosaur> there's quite a few references out there that were never updated from haskell98 though
09:57:19 <tippenein> what is an IO (Either String a) -> IO a
09:57:55 <ocharles> I'm starting to think these days that I don't want named operators for infix operators, but what I actually want is a function that's a monoid homomorphism from the free monoid generated by the operand types to the result of the operator. Does mean that the operator and domain needs to be a monoid though
09:58:08 <nak> how is "newtype" different from "type" ?
09:58:13 <nak> or "data"
09:58:13 <grayhatter> ocharles> ....
09:58:15 <nak> ugh
09:58:15 <ocharles> but then you get sum :: [a] -> a, and :: [Bool] -> Bool, or :: [Bool] -> Bool, etc. It's kinda lispy
09:58:18 <grayhatter> I know some of these words
09:58:41 <mutsig> nak: newtype can be used to make class instances, which isn't true for types
09:59:15 <ocharles> grayhatter: Well, (+) :: Int -> Int -> Int. 0 + a = a, a + 0 = a, a + (b + c) = (a + b) + c. Hey look, that's everything we need to know that (Int, 0, +) is a monoid!  So I'd argue rather than having   "plus :: Int -> Int -> Int", I'd rather have  "plus :: [Int] -> Int"
09:59:26 <geekosaur> nak: "type" is exactly a type alias. "newtype" tells the typechecker to pretend that the type is distinct from what it "wraps", but doesn't literally wrap it.
09:59:35 <mutsig> As I see it, newtypes are a lightweight version of a "data"-type with only 1 constructor.
10:00:17 <geekosaur> so the main use for newtype is to allow different typeclass instances, althouygh it's sometimes just to keep you from combining two notional Int-s that should be kept distinct (think things like age and quantity) 
10:00:33 <hexagoxel> nak: https://github.com/quchen/articles/blob/master/fbut.md#data-newtype-type
10:00:54 <nak> mutsig geekosaur i guess i just keep reading... if anyone pretends learning haskell is easy tho, that's really unfair
10:01:03 <nak> hexagoxel: thank you
10:01:34 <geekosaur> I found getting used to laziness much harder than this... but I came in with a fair amount of experience already
10:01:46 <mutsig> nak: almost every part of haskell is simple but abstract, and simple and abstract things can be hard to learn.
10:02:19 <mutsig> i.e. simple /= easy
10:02:39 <robkennedy> Any XML package suggestions? I tried Xeno but it failed with no debugging 
10:03:18 <robkennedy> I'm just consuming XML 
10:03:38 <Cale> I was somewhat already prepared for laziness, as when I really got going learning Haskell (back around 2001 or so), I had just finished writing an IRC bot as what amounted to a really long bash pipeline.
10:03:54 <Cale> (with netcat at one end, and a fifo tying the knot)
10:05:36 <geekosaur> robkennedy, my only suggestion is that a lot of stuff uses HXT... don't go down that rabbit hole, there are better ways now
10:06:02 <cocreature> robkennedy: I like xml-conduit
10:06:04 <nak> Cale: is that referring to my comment ?
10:06:50 <robkennedy> Ty I had just started hxt
10:06:51 <Cale> nak: Moreso geekosaur's
10:07:07 <nak> Cale: ok that makes more sense
10:07:40 <geekosaur> re laziness, spreadsheets helped me more there, fwiw.
10:08:04 <geekosaur> because "laziness" is really demand driven evaluation, and spreadsheets do that by default
10:08:31 <ocharles> robkennedy: I've had luck with xml-conduit in the past
10:08:43 <Cale> Yeah, I'd used spreadsheets as well, but I'd never had a spreadsheet that was involved enough that I had to worry about what order it was being evaluated in.
10:09:40 <ocharles> Cale: do you still have the source to that bot?
10:10:07 <Cale> Probably not... I think it would have been on the hard drive that really died.
10:10:33 <Cale> I have a bunch of stuff that's on a hard drive I merely don't have in any machine, and which I should rescue though.
10:11:03 <ocharles> just thought it could be interesting to see that fairly atypical approach to writing a bot :)
10:12:27 <dminuoso> This may sound like a really silly question, but when you do fmap (+1) (Just 1)   -> does this imply that Just is a functor or how is it know how fmap is applied to Just?
10:12:36 <Cale> Maybe is a functor
10:12:44 <nak> is anyone interested in entertaining me with a discussion about EitherT (and perhaps monad transformers in general) ?
10:13:15 <Cale> dminuoso: As for how it selects the implementation of fmap based on the type, that's just what type classes do
10:13:26 <Cale> There's an instance:
10:13:30 <Cale> instance Functor Maybe where
10:13:35 <Cale>   fmap f Nothing = Nothing
10:13:43 <Cale>   fmap f (Just x) = Just (f x)
10:13:45 <dminuoso> and.. fmap func (Just val) = Just (func val)
10:13:46 <dminuoso> yeah
10:14:09 <erisco> once upon a time there was EitherT. EitherT had a hard time making friends with the other transformers because of his indecisiveness.
10:14:31 <nak> erisco: ^_^
10:16:56 <nak> if i have someMonad of someEither (m e), i am under the impression i can use EitherT M (where M is the type of m) to make it easier to work with the nested monads
10:17:13 <nak> my first question: is this understanding correct
10:17:19 <dolio> Cale: By the way, do you know if there's some `coend -| ??? -| end` characterization? The obvious thing to try doesn't really work, because dinatural transformations don't compose in general.
10:17:24 <erisco> :t EitherT
10:17:26 <lambdabot> error:
10:17:27 <lambdabot>     • Data constructor not in scope: EitherT
10:17:27 <lambdabot>     • Perhaps you meant variable ‘either’ (imported from Data.Either)
10:18:08 <dolio> And extranatural transformations don't even make sense to compose, really.
10:18:09 <erisco> EitherT :: m (Either a b) -> EitherT a m b
10:18:18 <ski> @kind ExceptT
10:18:20 <lambdabot> * -> (* -> *) -> * -> *
10:18:58 <erisco> so the understanding is, if you have a Monad full of Either, you can lift this to EitherT
10:19:19 <nak> erisco: ok so EitherT is a wrapper for our Monad containing our Either
10:19:22 <nak> yes ok cool
10:19:31 <ski> nak : if `M' has kind `* -> *', then it can't be the type of a value
10:19:40 <Cale> dolio: No idea.
10:21:16 <nak> erisco: so i have some function f that gives me an (m e) -- would the first step to working with that be (EitherT . f) in order to put (m e) into the EitherT wrapper ?
10:21:57 <erisco> what is e? it has to unify with m (Either a b)
10:22:11 <nak> e is a Left or Right
10:22:27 <nak> an "instance of Either" is the way my brain is thinking about it
10:22:33 <nak> but that's probably wrong
10:22:41 * ski isn't sure whether nak's `e' is a value or a type
10:22:48 <erisco> I don't understand because Left and Right are constructors, so m Left or m Right don't make any sense presuming m is a type var for a Monad
10:23:47 <nak> i mean like Foo (Left a) or Foo (Right b)
10:24:11 <erisco> okay, and so Foo is a constructor?
10:24:41 <nak> yea
10:24:46 <erisco> what is the type of Foo (Left a) given a :: t ?
10:25:09 <nak> uh...
10:25:25 <nak> FooType (Either e a) ??
10:26:09 <erisco> lets start with the type of Foo, what is that?
10:26:12 <mutsig> nak: How does your data-type declaration look like? "data FooType = Foo a" or "data FooType a = Foo a"
10:26:19 * ski would like to see a more concrete example nak would like help with
10:26:27 <erisco> I'd let you hand-wave but I think that is missing exactly what we want to talk about
10:26:29 <Cale> dolio: http://math.stackexchange.com/questions/709838/does-the-coend-have-a-right-adjoint
10:28:03 <nak> ok let's make FooType "Maybe" in this example - i'm just trying to talk about a monadic value of another monadic value
10:28:16 <nak> Just (Left a), Just (Right b)
10:28:25 <nak> so type of Maybe (Either e a), rigtht ?
10:28:34 <Cale> nak: Usually it's not worth focusing too hard on the fact that some type is a monad.
10:28:40 <erisco> if a :: e and b :: a, yes
10:28:42 <ski> assuming `a :: e' or `b :: a', yes
10:29:10 <nak> ah, Just (Left e), Just (Right a)
10:29:12 <nak> ok ^_^
10:29:27 <ski> then `e :: e' respectively `a :: a' :)
10:29:40 <Cale> I mean, there are cases where you will need to know that, and of course, if you want to write something that works with an arbitrary monad, that's all you get to assume, but usually there will be many other operations around
10:29:50 <ski> (value variables and type variables living in different name spaces)
10:30:12 <nak> yeah lots of overwhelming things !
10:30:13 <erisco> so now EitherT (Just (Left a)) :: EitherT e Maybe a
10:31:21 <nak> and EitherT (Just (Right a)) :: EitherT e Maybe a
10:31:24 <nak> yes ?
10:31:31 <erisco> if a :: a, yes
10:32:46 <nak> v_v
10:32:56 <nak> i guess i don't understand
10:33:46 <erisco> you said something correct but you don't understand? are we in the Chinese room? :P
10:34:08 <nak> well i was not certain with my guess !
10:34:40 <erisco> you just follow the types
10:34:49 <erisco> you know the type of EitherT and the type of Just (Left a)
10:35:06 <erisco> and you know the rule for the type of application
10:35:24 <erisco> i.e. f :: a -> b, x :: a ---> f x :: b
10:35:34 <ski> (unfortunately, imho, the data constructor is here called the same as the type constructor. which can muddle up things in your mind, if you're not clear on the distinction to begin with)
10:36:05 <nak> ski only partially clear on it
10:36:38 <erisco> ah, well if you are not clear on values versus types we need to start there
10:37:21 <erisco> EitherT (Just (Left a)) :: EitherT e Maybe a    what is the EitherT on the left versus the EitherT on the right?
10:37:50 <nak> EitherT on the left is a data constructor
10:38:06 <erisco> yes, and what is EitherT on the right?
10:38:45 <nak> EitherT is a type constructor on the right, binding m :: Maybe in EitherT e m a
10:38:58 * nak crosses fingers
10:39:03 * nak waits in anticipation
10:39:16 <erisco> yes, and so in general the names on the left of :: are in a different namespace than names on the right of ::
10:39:26 <erisco> and by "in general" I mean "always"
10:39:41 <nak> mm wakarimashita
10:39:47 <okeuday_bak> hackage.haskell.org user account creation requires manual approval, right?
10:39:49 <erisco> so seeing things of the same name on both sides never says they are the same thing, in fact they are always different
10:39:56 <halogenandtoast> nak: 本当に
10:40:04 <erisco> this is why in Haskell we're allowed to give data constructors the same name as type constructors
10:40:10 <erisco> whereas in other languages, such as Idris, we cannot
10:40:14 <nak> ok erisco so some data constructors and some type constructors can have the same name ?
10:40:30 <erisco> yes, because they are different name spaces
10:41:06 <erisco> the EitherT on the right of :: can never refer to the data constructor, because that is always on the left
10:41:09 <nak> halogenandtoast: my jp is like level zero... sumimasen　:(
10:41:11 <erisco> and vice versa
10:41:27 <nak> erisco: ok that's already a huge point of confusion cleared up
10:41:34 <nak> re: type/data constructors can have the same name
10:41:49 <nak> so: data Person = Person { name :: String }
10:42:03 <nak> gives us a Person TYPE and a Person DATA constructor
10:42:10 <nak> there is no type *constructor* here tho
10:42:13 <nak> just a type
10:42:33 <erisco> well I am not sure what the official definition of type constructor is, but sure
10:42:39 <nak> mm
10:42:43 <nak> ok 
10:42:49 <erisco> Nothing is a data constructor but takes no arguments
10:42:56 <erisco> so similarly, Person is a type constructor
10:43:07 <erisco> but maybe the official terminology does not have this similarity, I don't know
10:43:14 * nak nods
10:43:16 <erisco> it is a minor pedantic point
10:43:16 <Cale> You can tell something is a type or data constructor because it will start with an uppercase letter
10:43:38 <dolio> Except type aliases/families ruin that.
10:43:47 <Cale> ah, right
10:43:58 <Cale> That's actually really unfortunate
10:44:02 <dolio> Yeah.
10:44:05 <nak> rip
10:44:33 <nak> ok so we have some function f :: Maybe (Either e a)
10:44:40 <nak> erisco: and now we wanna do something cool with it
10:44:49 <nak> like i dunno, map over the inner either
10:44:53 <erisco> well that is not a function, but go on
10:45:01 <nak> ah sorry, 
10:45:08 <nak> let me get that straight
10:45:52 <nak> f :: Int -> Maybe (Either String Int)
10:46:41 <nak> possible values might look like Just (Left "no way") or Just (Right 5) or Nothing
10:46:48 <nak> do those fit ?
10:46:58 <erisco> no, because neither of those have a function type
10:47:09 <nak> i meant return values of the function
10:47:27 <Cale> sure
10:47:36 <erisco> still no, because those are Either (Either a b) (Either c d)
10:47:44 <Cale> er, what?
10:47:52 * erisco was hit on the head
10:48:01 <erisco> I kept reading "Just" as "Right" oO
10:48:38 * nak waits for the dust to settle
10:48:56 <erisco> yes it looks fine nak
10:49:00 <nak> mm ok
10:53:13 <nak> so if we want a monad that can behave both as Maybe and as Either, we might reach for EitherT to compose both behaviours in one
10:54:02 <ski> the monad would be `EitherT String Maybe' in this case
10:54:10 <nak> like data MaybeEither e a = EitherT e (Maybe a) 
10:54:18 <ski> (`Either' is not a monad, but `Either e', for any type `e', is)
10:54:33 <ski> you're missing a data constructor, but sure
10:54:35 <nak> ah ok that makes more sense
10:54:49 <nak> mmm ok let me try to fix 
10:55:10 <nak> data MaybeEither e a = MaybeEither EitherT e (Maybe a)
10:55:12 <ski> (or perhaps you wanted a type synonym instead ?)
10:55:30 <dminuoso> Cale: Well it's certainly interesting, something must be inherently different about this. But I guess I should stop thinking about Haskell in terms of other common object oriented languages.
10:55:34 <nak> (unsure, but basics are preferred at the moment. i'm such a scrub noob)
10:55:44 * ski is a fan of naming the data constructor by prefixing `Mk' to the type constructor, in case there's only a single one, and no better name suggests itself
10:56:43 <ski> `data' (and `newtype') defines a new type (the type constructor you invent, applies to any type parameters)
10:56:55 <davean> dminuoso: Almost everything is inherantly different, Haskell isn't an object oriented language, and there a few things people think have similarities but they're also different then any "objects" I've ever come across
10:57:01 <ski> `type' just gives a synonym name to an existing type
10:57:44 <nak> ok but the declaration i have above is OK, ski ?
10:57:57 <ski> it is
10:57:59 <davean> dminuoso: Almost nothing from OO languages really applies
10:58:06 <nak> (i'm ok with learning the nuances of data/type/newtype later)
10:58:18 <erisco> I don't like when I have to use a Mk* name... I am thinking of using Mc* instead because that is what I think of
10:58:31 * ski smiles
10:58:36 <ski> @src String
10:58:37 <lambdabot> type String = [Char]
10:58:48 <ski> @type words
10:58:50 <lambdabot> String -> [String]
10:58:54 <ski> means the same thing as
10:58:59 <ski>   [Char] -> [[Char]]
10:59:05 <erisco> and somehow find an excuse for McDouble :: Double
10:59:15 <nak> lol
10:59:16 <ski> `String' is just a shorthand (or what you want to call it) for `[Char]'
10:59:40 <dolio> If you want to follow Double's naming convention, you should postfix a # on the constructor name.
10:59:55 <dolio> Although I think it's D#, not Double#.
10:59:57 <ski> you gain no extra checking by using a type synonym
11:00:05 <Cale> dminuoso: If you're going to relate type classes to anything in Java, the closest thing would be interfaces.
11:00:30 <monochrom> Corollary: F# is a subset of Haskell. :)
11:00:31 <nak> ok so given my new MaybeEither type, can i work with my values (eg) Just (Right 5) more easily ?
11:00:53 <Cale> dminuoso: But there's an important difference: with type classes, the information about how the operations are implemented travels separately from the values, which allows things like this:
11:00:56 <Cale> :t read
11:00:59 <lambdabot> Read a => String -> a
11:01:16 <ski> nak : the opposite. you have to peel away the extra data constructor layer, to "get to" the actual information-bearing content
11:01:22 <Cale> Here, for any type a which is an instance of the type class Read, the function will take a String, and produce a result of type a
11:01:27 <monochrom> erisco: I like Mk, but I don't mind Mc.
11:01:48 <monochrom> newtype Cont r a = McCont{unCont :: (a -> r) -> r}
11:02:06 <ystael> Mc in the sense of "son of"? 
11:02:09 <monochrom> Also do you have a preference on what to rename unCont to?
11:02:26 <ski> nak : sorry, i just noticed the pair of brackets in your declaration should go
11:02:39 <Cale> (well, there are also lots of other differences, but that's a start :)
11:02:58 <Cale> dminuoso: Monad is hard to capture in settings without proper type classes because of the type of return:
11:03:00 <Cale> :t return
11:03:03 <lambdabot> Monad m => a -> m a
11:03:05 <erisco> I am alright with that one so I haven't made a joke for it ;)
11:03:12 <ski> nak : .. however, library operations that are polymorphic in a monad (like `mapM_', e.g.) will apply to this new monad `EitherT e Maybe' (or to `MaybeEither e m', if you make that an instance of `Monad' as well), in a *useful* way
11:03:14 <Cale> It's polymorphic again in the type of the result of the function.
11:04:08 * ski . o O ( `sunCont' )
11:05:24 <monochrom> ski, I have a personal preference I haven't said. I want the constructor and the selector to have the same prefix length. So, whereas I add two letters to the constructor, I also want to just add two letters to the selector.
11:07:34 <monochrom> erisco: Actually, what would you think of putting the Mk after? ContMk?
11:08:38 <erisco> I actually like that more
11:08:56 <monochrom> I just thought up another one. ContOf. How about that one?
11:09:08 <erisco> makes it easier to read an expression when the significant part is first
11:09:35 <erisco> that is better yet :)
11:09:51 <erisco> one I have been using is "Form"
11:10:38 <monochrom> I am now thinking of the pair ContOf and deCont. Because "ContOf (\k -> k 1)" is "I make a Cont out of the following...", and "deCont xxx" is "I strip away the Cont wrapper"
11:10:41 <erisco> because that is a common phrase: "forms a monoid"
11:11:44 <erisco> but you can also say "a monoid consisting of"
11:12:29 <monochrom> Now I'm splitting hair between "un" and "de"...
11:12:33 <erisco> "of" is shorter and makes for a good suffix, which is superior to a prefix imo because it is less significant
11:13:42 <erisco> though "of" could be argued for the type as well
11:13:45 <erisco> EitherOf Int String
11:13:47 <monochrom> Yeah, it is inspired by "newtype Double = D# ...", except the "#" suffix is better reserved for primitives. But the suffixing idea is good.
11:14:31 <erisco> ContOf Int String
11:15:32 <Tuplanolla> Would that prefix eventually lead to `deCreate` or `deStroy`?
11:16:47 <monochrom> Oh w00t! Rationalization of ContOf: In SML you write "datatype Shape = Square of Double | Rectangle of ..."
11:17:08 <dolio> deLaMancha
11:17:26 <scope> Hey guys, I have some code to paste and a noobie question
11:17:52 <geekosaur> @paste it and ask
11:17:53 <lambdabot> Haskell pastebin: http://lpaste.net/
11:17:57 <geekosaur> you don;t have to ask to ask here
11:17:58 <erisco> if you have a non-nullary type constructor then maybe consider the suffix "On"
11:17:59 <monochrom> I don't have a Stroy type or a Create type. I don't know what "stroy" is, and "create" is better a function name than a type name.
11:18:02 <scope> I'm trying to figure out how to do the closestPair function at the bottom, and having a really hard time working through the logic http://lpaste.net/493703887925018624
11:18:17 <scope> I'm extremely new to haskell and don't fully understand syntax
11:18:26 <erisco> when you are working in a dependent system I don't think it is necessarily a bad idea to easily distinguish type and data constructors with suffixes
11:18:32 <erisco> a Hungarian notation
11:19:26 <erisco> because you have things "on a domain"
11:19:30 <scope> I'm assuming I need to use the closerPair function.
11:19:45 <erisco> and you have elements "of a domain"
11:20:51 <erisco> so  newtype ContOn r a = ContOf { deCont :: (a -> r) -> r }
11:21:15 <scope> I was trying to do something along the lines of this but the syntax is all kinds of messed up (closerPair(p1,p2) p1 <- pairsFromPoints(points), p2 <- pairsFromPoints(points), p1 /= p2)
11:22:40 <erisco> it wouldn't have to be used everywhere, but just for the circumstances where you'd otherwise have the data and type constructors have the same name
11:23:11 <scope> So I have a function that gives me every possible pair of points, and I need to find the two points that are the closest together coordinate-wise
11:23:49 <monochrom> erisco: Yeah, good idea.
11:25:50 <erisco> scope, okay, I sort of see what your thinking is
11:26:22 <erisco> scope, you're trying to express "forall points p1, p2 in pairsFromPoints points where p1 ≠ p2, closerPair p1 p2"
11:26:35 <erisco> which doesn't really make much sense but is in the ballpark
11:26:59 <scope> right, so closerPair takes two pairs of points and finds which of those two pairs is the closer together
11:27:09 <erisco> it makes sense up to the proposition closerPair p1 p2
11:27:10 <scope> so I need to iterate through the list of all pairs and find the two closest
11:27:32 <erisco> okay, let me start with a simpler example
11:27:47 <erisco> say I have a list of numbers [5,2,7,3] and I want to find the smallest one, how can I do that?
11:27:55 <scope> minimum
11:28:06 <scope> I was trying to do something with minimumBy but I don't understand it
11:28:24 <erisco> okay, what did your attempt with minimumBy look like?
11:28:38 <scope> I'll paste it one sec
11:28:59 <scope> http://lpaste.net/4702265186482913280
11:29:04 <monochrom> minimumBy would make closerPair useless and make you write a comparator for Pairs instead.
11:29:27 <scope> sqDistance takes in two points
11:29:32 <monochrom> And the biggest pain is that the comparator pretty much duplicates closerPair's algorithm.
11:29:37 <scope> so that doesn't really work
11:30:08 <scope> gotcha, so I guess I just don't really know how to go about using closerPair
11:30:16 <monochrom> If you already have closerPair, you're better off using recursion for closestPair and using closerPair as a helper.
11:30:20 <erisco> well, I know there is another way to do this monochrom, I just don't know if busting out a fold is the right thing
11:30:44 <scope> I was debating using recursion, but like I said I'm a huge noob when it comes to Haskell
11:30:45 <monochrom> But we don't have to bust out fold. We can write our own recursion.
11:31:14 <erisco> well I am not going to compete for ways to solve the problem, I don't care :P
11:31:25 <erisco> what method fancies you scope?
11:31:38 <scope> I'm pretty sure I need to first create the list of all pairs, then use closerPair within closestPair
11:31:42 <scope> I think recursion would probably work
11:32:29 <erisco> okay cool, we'll do the recursive solution with closerPair and then if you're interested we can also do the minimumBy and fold solutions for comparison
11:32:32 <monochrom> You already have pairsFromPoints.
11:32:57 <scope> monochrom right, I just don't know how to use that within closestPair
11:33:12 <scope> but sure I just want to understand how to get this function to work
11:33:18 <erisco> what does your attempt at the recursive solution look like?
11:33:31 <scope> I honestly haven't tried yet, I've been fighting with other solutions
11:33:47 <monochrom> closestPair points onepair = let allpairs = pairsFromPoints in ...
11:33:56 <monochrom> err
11:34:02 <monochrom> closestPair points onepair = let allpairs = pairsFromPoints points in ...
11:34:18 <erisco> okay, so for recursion we want to write a definition for each case
11:34:20 <monochrom> err, wrong number of parameters
11:34:26 <monochrom> closestPair points = let allpairs = pairsFromPoints points in ...
11:35:00 <erisco> closestPair :: [Point a] -> Pair a  so we're taking a list of points
11:35:08 <erisco> are you going to do this monochrom? I'll step out
11:35:17 <monochrom> No, I have to go.
11:35:23 <scope> thanks anyways mono
11:35:26 <erisco> okay, and I have maybe 15 min
11:35:34 <scope> that's fine as lone as I can get a start
11:35:57 <erisco> so what are the cases of list?
11:36:05 <scope> so with mono's answer, what would come after the "in"? closestPair points = let allpairs = pairsFromPoints points in ...
11:36:34 <scope> what do you mean?
11:36:46 <erisco> okay, similar example, say I want to define length for lists
11:37:01 <erisco> then my cases are empty list, i.e. [], and cons, i.e. (x:xs)
11:37:11 <erisco> length [] = 0; length (x:xs) = 1 + length xs
11:37:20 <erisco> this is what a recursive definition looks like
11:37:42 <erisco> there is some base case and some recursive case (or many of each)
11:37:54 <erisco> what is the base case for closestPair?
11:38:17 <scope> I would guess null if there aren't any points in the list?
11:38:20 <erisco> or the "stopping case" or "stopping condition" or whatever you want to call it
11:38:30 <erisco> Haskell doesn't have null
11:38:32 <scope> when it reaches the end of the list rather
11:38:39 <erisco> but that is a good thought, what if the list is empty
11:38:51 <erisco> well if the list is empty we cannot return a Pair a, can we, because we have no pairs
11:38:59 <erisco> so there are two things we can do
11:39:10 <erisco> option 1 is to accept that closestPair is a partial function
11:39:29 <scope> I'm treating it as a partial function
11:39:30 <erisco> option 2 is to change the type, so perhaps closestPair :: [Point a] -> Maybe (Pair a)
11:39:38 <erisco> or closestPair :: NonEmpty (Point a) -> Pair a
11:39:50 <erisco> okay, so we're going to be partial
11:39:53 <ski> monochrom : *nod*
11:40:06 <erisco> then we will just ignore the case where the list is empty
11:40:10 <scope> right
11:40:32 <erisco> the effect of this is that evaluating on an empty list will give us bottom, which is the null of Haskell, if there was one
11:40:53 <erisco> we still need a base case though, so what is that
11:40:56 <dolio> It's not null, though.
11:41:17 <erisco> it is absolutely not and don't let me confuse you into thinking it is :P
11:41:30 <scope> I guess when it reaches the last pair returned by pairsFromPoints
11:41:35 <scope> not sure how to put that into the right words
11:41:44 <erisco> a list of one element, or a singleton list
11:41:55 <erisco> what is the pattern for that?
11:42:24 <scope> do you have my code open somewhere or should I paste again?
11:42:32 <erisco> I have it open
11:43:13 <scope> Man like I said I'm so new to this. I came from entirely OOP languages
11:43:20 <erisco> I'll make life a bit easier and change the type like this scope http://lpaste.net/353644
11:43:39 <scope> I can't change the types, have to deal with them as they are
11:43:41 <erisco> so we're operating on a list of pairs, not a list of points
11:43:59 <erisco> well okay, I made an edit
11:44:58 <erisco> if we define closestPair', then closestPair = closestPair' . pairsFromPoints
11:44:58 <scope> do you know what mono was going for with his partial solution? what he was doing interests me
11:45:15 <erisco> if he was thinking of recursion then I am doing the same thing
11:45:21 <scope> Ok
11:45:33 <monochrom> yeah
11:45:36 <erisco> he might have juggled things a bit differently but it will be the same concept
11:45:59 <erisco> the pattern for a list of one element is (x:[]) or [x]
11:46:09 <scope> right that much makes sense
11:46:17 <erisco> so  closestPair' [x] = ?  fill in the blank
11:47:11 <scope> x?
11:47:16 <erisco> looks good
11:47:36 <erisco> so we have, for example,  closestPair' [Pair (1,2) (3,4)] = Pair (1,2) (3,4)
11:47:50 <erisco> now we need the recursive case, any ideas what that should be?
11:48:17 <scope> not a clue, I've never been great with recursion and its a bit harder for me with haskell
11:48:34 <erisco> okay, so we're trying to span all lists
11:48:40 <erisco> except the empty one
11:48:45 <erisco> so we have covered a list of one element
11:48:59 <erisco> if we also cover a list with two or more elements, we'll have covered all non-empty lists
11:49:15 <erisco> the pattern for this is (p1:p2:ps)
11:49:30 <erisco> so we have  closestPair' (p1:p2:ps) = ?  what is the blank here?
11:50:26 <srhb> cd
11:50:29 <srhb> woops
11:50:39 * erisco prints the help text for cd
11:50:49 <scope> lol
11:50:59 <scope> erisco I'm not sure.
11:51:00 <srhb> erisco: That's not what no argument cd does!
11:51:10 <erisco> this is why I am not a sys admin
11:51:14 <srhb> :-)
11:51:26 <erisco> scope, okay, well we can start with  closerPair p1 p2, yes?
11:51:43 <scope> sure
11:51:58 <erisco> alright, so we find the closer of these two pairs and we still have the rest of the list left
11:52:09 <scope> right
11:52:17 <erisco> so our question now is: what is the closest pair out of closerPair p1 p2, and the rest of the list, right?
11:52:26 <scope> Yes.
11:52:36 <erisco> how can we solve that?
11:52:57 <scope> p1:p2:ps like what you were saying before?
11:53:05 <pkoshy> Why are there so many people in this channel?  In terms of users in language related channels, it is second only to python at the moment.  I didn't really expect that
11:53:20 <erisco> well  (p1:p2:ps) is a pattern
11:53:34 <erisco> if we write  p1:p2:ps on the right of the = then this just rebuilds the list we started with
11:53:50 <scope> so we just want ps then?
11:53:51 <pkoshy> Is haskell having some kind of renaissance or something?
11:53:51 <erisco> but we don't want that list, because we've just reduced it by finding the closer of p1 and p2
11:53:59 <erisco> well, what about closerPair p1 p2?
11:54:20 <erisco> if we just use ps then we're forgetting the closer of p1 and p2, and one of those may actually be the minimum
11:54:21 <Cale> pkoshy: #haskell has been one of the largest channels on freenode for several years now
11:54:56 <erisco> scope, let me spark your imagination a bit and suggest  closerPair p1 p2 : ps
11:55:11 <erisco> what can we do with this list?
11:55:14 <pkoshy> Cale: had no idea...I'm impressed I guess?  It has been of interest to me personally but is it used much in industry?
11:55:31 <erisco> note that that is  (closerPair p1 p2) : ps
11:55:54 <Cale> pkoshy: Well, we use it where I work, at least. :)
11:55:57 <erisco> if we make that list, we want to find the closest pair in that list, yes? do we have a function which can do that?
11:56:09 <scope> closerPair?
11:56:17 <pkoshy> Cale:  Interesting - thank you for the info
11:56:18 <Cale> pkoshy: It's used somewhat in industry -- could probably stand to be more popular.
11:56:33 <frontendloader> pkoshy: people like me are hoping to one day understand what a Monad is
11:56:46 <erisco> scope, I am thinking of a function f so we can write   f (closerPair p1 p2 : ps)
11:56:47 <pkoshy> heh
11:56:54 <frontendloader> beyond "simply a monoid in the category of endofunctors"
11:57:04 <geekosaur> pkoshy, for one example: there's a fair amount of direct and indirect interest from Javascript programmers, because Haskell's do notation turns out to be a good way to write callback-based programming without explicitly writing callbacks all over the place
11:57:05 <Cale> The company I'm working for, Obsidian Systems, makes web applications for various clients, and we use Haskell both for the frontend (compiled to Javascript using GHCJS) and for the backend (using Snap)
11:57:06 <erisco> scope, remember   closerPair p1 p2 : ps :: [Pair a]
11:57:30 <pkoshy> geekosaur: Interesting.  Good to know
11:57:43 <scope> I'm struggling so hard to follow, sorry erisco
11:57:59 <scope> I know this must be frustrating for you
11:57:59 <Cale> We also compile our frontends for iOS and Android using GHC's ARM support.
11:58:02 <geekosaur> so there are haskell to javascript compilers, and various Javascript derivatives that are inspired by Haskell
11:58:03 <erisco> yeah I am going a bit quick because my time is limited ^.^
11:58:05 <erisco> no it is not frustrating
11:58:20 <ggVGc> pkoshy: there is one notable use of haskell in "industry" and it's the entire anti-spam system of facebook. They rewrote it because of performance issues of the earlier one, and to be able to create a type safe DSL for non-programmers to use for making the spam rules
11:58:25 <ggVGc> and it's been a huge success for them
11:58:28 <erisco> let me describe what I want to do with this algorithm
11:58:38 <ggVGc> they also contributed some much needed improvements to GHC while doing it
11:58:40 <erisco> I have a list of points, say it is [p1,p2,p3,p4,...]
11:58:45 <Cale> (Rather nice that you can have one piece of code which gets compiled to Javascript and also to native code)
11:58:54 <ggVGc> because it turned out haskell was not completely ready for large scale use like that, until they fixed it
11:59:10 <ggVGc> pkoshy: https://www.youtube.com/watch?v=sl2zo7tzrO8
11:59:14 <ggVGc> that's a very good talk
11:59:19 <scope> erisco right
11:59:21 <erisco> what if I found the minimum of the first two elements? of p1 and p2, call it px
11:59:38 <pkoshy> All very interesting info - thanks everyone.  I honestly had no idea it was used
11:59:40 <erisco> well then I know that the minimum of the whole list must be found in [px,p3,p4,...]
11:59:48 <erisco> so by doing this I have just made the list smaller
12:00:03 <erisco> and I can keep doing this, by now finding the minimum of px and p3, call it py
12:00:09 <erisco> now I have [py,p4,...]
12:00:17 <erisco> and I can keep going until the list has only one element (our base case)
12:00:37 <scope> Right, see I understand that. Putting it into code is what is slowing me down
12:00:55 <erisco> so, because I have to go, what I would write is  closestPair' (p1:p2:ps) = closestPair' (closerPair p1 p2 : ps)
12:01:26 <scope> alright I'll give it a shot, thanks for your help!
12:01:33 <erisco> run through a few examples using equational reasoning and see what happens
12:01:57 <Cale> pkoshy: I can honestly say I'd never want to go back to building web applications any other way. Sharing data types and common logic between the frontend and backend, ensuring that for example, you never have issues with JSON encoding mismatches is so nice.
12:02:07 <erisco> good luck and talk to you later :) if you figure this out and want we can later go over the minimumBy and fold solutions
12:02:26 <pkoshy> Cale: I've heard good things about clojure/clojurescript that I think fits into that problem space
12:02:35 <pkoshy> Cale: Someone at my former company swears by it
12:03:17 <Cale> Nevermind the fact that we're using a really nice functional reactive programming system (reflex-dom) in our frontends which makes it really easy to do live-updating stuff everywhere, and generally makes GUI programming pretty fun.
12:04:05 <Cale> (I actually enjoy frontend work more than backend most of the time now! CSS is still annoying though.)
12:05:21 <dopey_> anyone know of a haskell http server that has an interface to the underlying socket during request handling?
12:05:28 <livingbeef> How do I run ghci in noninteractive mode?
12:06:53 <livingbeef> nevermind, it's not really a problem
12:06:56 <cocreature> livingbeef: just run ghc instead of ghci?
12:07:23 <cocreature> livingbeef: if you want something that interprets instead of compiling your code first and the running it use "runhaskell"
12:07:49 <Cale> dopey_: Well, what kind of interface do you need?
12:08:05 <Cale> I think most of them provide *some* kind of interface ;)
12:09:27 <livingbeef> cocreature: that doesn't work for naked espressions at top level. Bug I can live with promts, I guess.
12:09:46 <livingbeef> *but
12:10:29 <cocreature> livingbeef: iirc you can make ghci run a script and then exit
12:11:15 <cocreature> ghc -e ':script filename'
12:11:16 <dopey_> cale: pretty much I just want access to the socket (https://hackage.haskell.org/package/network-2.6.3.1/docs/Network-Socket.html) during request handling. I'm using Warp right now, and I *don't think* I have access to the socket from the "router"
12:11:27 <Cale> hmm
12:11:34 <Cale> Snap has a way
12:11:44 <Cale> Let me have a look
12:11:49 <dopey_> cheers. taking a look now too
12:12:33 <Cale> hmm, Warp has a way to specify which Socket it will use...
12:13:07 <livingbeef> cocreature: I guess runhaskell is the only option then, if I want to interpret text at hand. But I'll have to wrap it in main...
12:13:27 <cocreature> livingbeef: how does ghc -e not do what you want?
12:13:45 <cocreature> dopey_: you got me interested. what do you need this for?
12:14:05 <livingbeef> Then I'd have to create files and such, which is not ideal. But it's not a big deal.
12:14:23 <dopey_> cale: right, but I think that's just when you start the server, no? after that I assume it assigns a new socket to each request
12:14:26 <cocreature> livingbeef: no you don’t. I thought you had a file. you can just run something like 'ghc -e "1 + 1"'
12:14:29 <geekosaur> livingbeef, you want a programmatic interface to interpretation? Look at the hint package
12:14:57 <geekosaur> note however that this is a separate interpreter not connected to your program, that is, changes made there do not affect your running program
12:15:21 <dopey_> cocreature: id like to be able to use the socket to do another layer of verification as to the source process making the request. basically getting the user id of the originating process
12:15:55 <dopey_> cocreature: i know that the process is local (or should be)
12:16:49 <cocreature> dopey_: for security purposes?
12:17:03 <dopey_> cocreature: yep
12:18:45 <cocreature> dopey_: cool, thanks for the explanation :)
12:20:12 <dopey_> cocreature: np. i want to get it working first and then explore the security merits, e.g. whether it can be spoofed
12:23:18 <Jinxit> i seem to remember there being a good blog series on Free and how it can be used to make a DSL, does anyone happen to know which one i'm talking about?
13:01:48 <jle`> ezyang: congrats! :)
13:02:04 <jle`> 🎉
13:11:03 <ezyang> jle`: THanks :) 
13:12:07 <AWizzArd> I tried to write a Lens that would return me the nth element of a tree. The view works, and returns me the correct element. The over operation however does not return the whole tree, with that element changed. But instead it only returns me also the (now possibly changed) nth element.
13:12:23 <AWizzArd> Is there anything useful one can suggest me, without seeing the code?
13:14:49 <Cale> What is the type of the thing that you wrote?
13:15:10 <Cale> AWizzArd: ^^
13:15:49 <AWizzArd> Cale:    nthElement :: (Functor f) => Int -> (Program -> f Program) -> Program -> f Program
13:16:11 <Cale> ahh, harder to tell what's wrong because it's all Program
13:16:29 <AWizzArd> Yes, I guess there is not much anyone could tell me.
13:16:42 <AWizzArd> I was hoping that this is a kind of a „typical” mistake of Haskell/Lens beginners.
13:17:32 <Cale> I'm guessing that you just didn't make the function put everything back together correctly
13:17:49 <Cale> So, nthElement n f p
13:18:00 <AWizzArd> Cale: yes, it’s correct. I was just writing the non-lens version of it. And tried to lensify it.
13:18:02 <Cale> is supposed to take apart p somehow, finding the nth element
13:18:06 <Cale> (whatever that is)
13:18:13 <Cale> and then apply f to it
13:18:27 <Cale> and then put the rest of the structure back on surrounding that
13:18:43 <AWizzArd> I can easily write a function that traverses my tree/Program depth-first.
13:18:50 <Cale> Oh, also, if you can write the view and set
13:19:01 <Cale> there's a function you can use to make the lens
13:19:03 <Cale> :t lens
13:19:06 <lambdabot> Functor f => (s -> a) -> (s -> b -> t) -> (a -> f b) -> s -> f t
13:19:18 <AWizzArd> Didn’t use that. I tried it first the more complicated way, via Functor.
13:19:40 <Cale> Here's an example of a lens:
13:20:36 <Cale> > let scnd f (x,y) = (\y' -> (x,y')) <$> f y in over scnd (+1) (10,20)
13:20:39 <lambdabot>  (10,21)
13:21:28 <scope> Hey guys, I'm trying to create a list in an if then else by doing this http://lpaste.net/8165899308453855232
13:21:29 <Cale> So, the pattern to note is that the argument to <$> here is kind of like our original pair (x,y), only with a hole in it
13:21:32 <scope> what's wrong with my syntax?
13:21:48 <Cale> That is, the first argument is
13:22:03 <AWizzArd> Okay thanks, I will study this example.
13:22:05 <Cale> and the second argument to <$> is just the function applied to the thing which was in that hole
13:22:24 <mauke> scope: it looks like you're trying to use statements or something
13:22:40 <mauke> scope: haskell doesn't have those. the syntax is 'if <expr> then <expr> else <expr>'
13:22:42 <AWizzArd> Cale: and what is this „in”?
13:22:43 <Cale> scope: several things
13:23:14 <Cale> AWizzArd: let <declarations> in <expr>
13:23:16 <scope> welp
13:23:21 <mauke> AWizzArd: 'let <definitions> in <expr>' defines local variables for use in one expression
13:23:24 <AWizzArd> Aah, _this_ in. Okay.
13:23:29 <scope> ok thanks
13:23:53 <Cale> scope: Okay, so first of all, line up the 'then' and 'else' just to be safe
13:24:11 <Cale> secondly, perhaps you want a let
13:24:15 <scope> super new to Haskell so apologies for the terrible formatting/syntax
13:24:24 <scope> I tried to use a let but that told me it needed to be in a do block?
13:24:37 <Cale> but... I don't really understand what line 5 is supposed to be
13:24:40 <mauke> 'let' needs to be followed by 'in' normally
13:24:52 <Cale> > let x = 5 in x * x
13:24:54 <lambdabot>  25
13:24:55 <mauke> exceptions are 'do' blocks and list comprehensions
13:25:15 <Cale> scope: What is the context of this code?
13:25:22 <Cale> scope: Is this part of a function declaration?
13:26:00 <scope> one sec I'll paste the rest
13:26:04 <Cale> scope: Why define allDirections to be [] and then write allDirections ++ ..., rather than just writing [] ++ ...
13:26:23 <Cale> scope: and of course, appending an empty list isn't going to change much :)
13:26:44 <Cale> scope: In Haskell, if something is equal to something else, it means you can substitute one for the other, just like in algebra
13:27:09 <scope> lpaste is frozen for me, won't load
13:27:22 <Cale> seems to load for me
13:27:33 <Cale> lpaste.net, right?
13:27:42 <scope> here's the context http://lpaste.net/1955896736157270016
13:28:13 <mauke> what's allDirections?
13:28:26 <scope> the list of all of the results from lineSide
13:28:28 <scope> to be used later
13:28:36 <Cale> scope: Nope...
13:28:44 <Cale> scope: Well, you might want it to be
13:28:53 <Cale> scope: But in that case, you should define it to be such a list
13:29:14 <scope> it needs to be, as I need to check whether all of the results of lineSide are either <= 0 or >= 0
13:29:19 <Cale> okay
13:29:40 <mauke> it looks like you're trying to call a function on each element of a list
13:29:48 * mauke is now known as Clippy
13:29:48 <Cale> So, which parameters should we supply to lineSide?
13:30:00 <scope> a point from the points list, and edge
13:30:08 <scope> both coming from isHullEdge
13:30:08 <Cale> scope: for each of the points?
13:30:11 <scope> yes
13:30:21 <Cale> Perhaps we should use a list comprehension, just for fun. We could also use map
13:30:39 <scope> I barely have any grasp on haskell as I'm sure you can tell lol
13:30:40 <Cale> [lineSide edge point | point <- points]
13:30:50 <mauke> scope: do you know any other programming languages?
13:30:56 <mauke> (my guess: yes)
13:30:58 <scope> Yes, all OOP though
13:31:02 <mauke> which ones?
13:31:12 <scope> C, C++, Java, some Ruby
13:31:35 <Cale> scope: So this will be the list which you wanted. Now what do you want to do with that list?
13:31:53 <scope> check that all of the values are either <= 0 or >= 0
13:32:19 <Cale> ah, okay
13:32:25 <Cale> So, perhaps a let will be appropriate
13:32:43 <scope> so are you saying set allDirections to [lineSide edge point | point <- points]?
13:32:56 <Cale> let allDirections = [lineSide edge point | point <- points]
13:33:09 <scope> ok
13:33:10 <Cale>  in all (<= 0) allDirections || all (>= 0) allDirections
13:33:42 <scope> wow well that compiled
13:33:49 <scope> let me test to make sure it's working somewhat
13:35:00 <scope> wow, thank you very much Cale
13:35:05 <scope> passes my tests
13:35:09 <Cale> cool
13:35:16 <scope> I was making it much more complicated than I needed to
13:35:41 <Cale> You can also write
13:35:49 <Cale> allDirections = map (lineSide edge) points
13:35:58 <Cale> if you prefer
13:36:05 <scope> See that seems even easier, what exactly is happening there with the map?
13:36:17 <Cale> map :: (a -> b) -> [a] -> [b]
13:36:27 <Cale> is a function which, given a function, and a list of values to apply it to
13:36:36 <Cale> applies the function to all the values and gives a list of the results
13:36:46 <Cale> map f [] = []
13:36:52 <Cale> map f (x:xs) = f x : map f xs
13:37:14 <scope> syntax for haskell still looks very alien to me
13:37:19 <scope> need to do more reading on it
13:38:08 <Cale> So that breaks the problem of defining map down into two cases: every list is either the empty list []
13:38:31 <Cale> or it's a nonempty list with some first element (say x) and some tail (say xs)
13:38:42 <scope> so another quick question, in "let allDirections = [lineSide edge point | point <- points]" what would the english equivalent of the pipe operator be?
13:38:43 <Cale> which we can write (x : xs)
13:38:48 <Cale> "where"
13:38:55 <scope> that's what I assumed, ok
13:38:55 <Cale> Or "such that"
13:39:01 <mauke> are you familiar with math notation for sets?
13:39:05 <scope> somewhat
13:39:13 <Cale> and "<-" can be read as "is selected from"
13:39:27 <mauke>  { lineSide(edge, point) | point ∈ points }
13:39:36 <scope> ahhh ok, this IRC is helping me learn Haskell much easier than I would have otherwise
13:40:01 <Cale> > [(x,y) | x <- [1,2,3], y <- [4,5]]
13:40:04 <lambdabot>  [(1,4),(1,5),(2,4),(2,5),(3,4),(3,5)]
13:40:09 <Cale> > [(x,y) | x <- [1,2,3], y <- [4,5], even (x + y)]
13:40:12 <lambdabot>  [(1,5),(2,4),(3,5)]
13:40:13 <scope> You guys have been extremely helpful. But alright that makes sense Cale/mauke
13:40:32 <mauke> > [ show x ++ " is even" | x <- [1 .. 10], even x ]
13:40:36 <lambdabot>  ["2 is even","4 is even","6 is even","8 is even","10 is even"]
13:40:57 <Cale> > [(x,y,z) | x <- [1..20], y <- [x..20], z <- [y..20], x^2 + y^2 == z^2]
13:41:03 <lambdabot>  [(3,4,5),(5,12,13),(6,8,10),(8,15,17),(9,12,15),(12,16,20)]
13:41:05 <mauke> heh
13:41:20 <mauke> that might not be the most efficient way to brute force that
13:41:53 <Cale> Iterating over the choices of z is a bit foolish :)
13:42:43 <scope> hey if it works I'm happy
13:42:50 <scope> still learning
13:43:08 <Confusius> Quit
13:43:14 <scope> hahaha
13:43:16 <scope> tempting
13:43:17 <mauke> /quit
13:43:20 <scope> :q
13:43:30 <Cale> :wq
13:43:36 <mauke> :x > :wq
13:43:42 <Cale> scope: It's good to get to know how to manipulate lists early, because lists are effectively our loops.
13:44:13 <scope> Cale: yeah I'm starting to realize that. Haskell isn't like any language I've ever used before, really difficult to wrap my brain around and rewire it
13:44:19 <Cale> Just as a loop either might not occur (because its precondition isn't met), or consists of an iteration followed by another loop, a list is either empty, or consists of an element followed by another list.
13:44:35 <scope> that much I understand
13:45:00 <Tuplanolla> Trees are also everywhere.
13:45:14 <Cale> But the effect on the code is sort of like everything has been turned inside out
13:45:33 <scope> Cale: kind of like my brain trying to learn Haskell
13:45:44 <Cale> Instead of having the index set up on the outside, and having all this code inside of the loop body
13:46:15 <Cale> The list you're iterating over is sort of at the "innermost" position usually, and you're applying functions to that to transform it
13:46:32 <Cale> (which might or might not get you more lists)
13:47:46 <Cale> Which ultimately ends up being a bit more modular, because, well, you can cleanly separate a problem of generating things to be iterated over from the problem of processing them.
13:48:10 <Cale> (with some special thanks to lazy evaluation)
13:48:41 <scope> everything about this language is pushing my thought process to its limits, I think it's just because I'm not used to it yet.
13:48:47 <Cale> Yeah
13:49:06 <scope> Thanks for you help Cale.
13:49:10 <Cale> When I started learning Haskell back around 2001 or so, it took me a couple months to feel like I could do anything useful
13:49:25 <Cale> and about a year to be "comfortable" for some definition of that word
13:49:25 <scope> Well I've only been doing it for about two weeks ha
13:50:00 <graygray> Can someone explain why when year = "2007", if (cast year :: Maybe Int) /= Nothing returns false
13:50:11 <mauke> because "2007" is not an Int
13:50:13 <scope> It seems incredibly powerful/elegant for what it is though.
13:50:16 <mauke> it's a String
13:50:35 <monochrom> What is the type of "cast"? And what does the doc say?
13:50:40 <geekosaur> graygray, cast there is not a C cast
13:50:44 <cocreature> :t cast
13:50:46 <lambdabot> (Typeable b, Typeable a) => a -> Maybe b
13:50:49 <mauke> the other answer is: cast doesn't convert anything
13:50:54 <mauke> it's just a runtime type check, basically
13:51:02 <Cale> cast will only produce Just x in the case that the types a and b are the same
13:52:12 <allenj12> if you wanted to make a list in haskell without using ADT's such as (defn cons [h t] #(if % h t)) what would the type signature of that function be? since it is a recursive type?
13:52:19 <Cale> (The advantage it buys you is that sometimes you don't know that a and b are the same type even though they might be)
13:52:51 <graygray> so if i did cast read("2007"),1 would that return 2007?
13:52:53 <mauke> allenj12: uh, what?
13:53:17 <monochrom> Yes, but then you would also screw "cast".
13:53:22 <mauke> > cast read("2007"),1
13:53:26 <lambdabot>  <hint>:1:18: error: parse error on input ‘,’
13:53:48 <graygray> monochrom: how so?
13:53:52 <Cale> > cast (read "2007" :: Integer) :: Maybe Integer
13:53:56 <lambdabot>  Just 2007
13:54:04 <Cale> > cast (read "2007" :: Integer) :: Maybe String
13:54:06 <lambdabot>  Nothing
13:54:17 <Cale> > cast (read "2007" :: Int) :: Maybe Integer
13:54:20 <lambdabot>  Nothing
13:54:22 <monochrom> Because you already have the number. Why would you jump through more hoops to get it again?
13:54:26 <Cale> They have to match *exactly*
13:54:26 <allenj12> mauke: so if i wanted to make a list but only using functions, no ADT's. cons h t = \b -> if b the h else t . Where t would be another cons, what would the type signature for cons look like
13:54:53 <mauke> that's not a list
13:55:05 <Cale> allenj12: The branches of that if expression don't appear to have matching types
13:55:11 <mauke> :t let cons h t = \b -> if b then h else t in cons
13:55:12 <lambdabot> t -> t -> Bool -> t
13:55:24 <monochrom> "I am using my desktop to ssh to the same desktop to IRC"  You could, but why would you.
13:55:30 <Cale> If your intention is that this get used to build up lists, anyway
13:55:36 <mauke> you've defined a pair
13:55:38 <Cale> yeah
13:55:39 <graygray> monochrom: I was taking in an input and wanted to make sure it was maybe an Int so was using cast to see if I got anything returned
13:55:40 <mauke> .oO( homo-pair? )
13:55:47 <allenj12> Cale: https://aphyr.com/posts/340-acing-the-technical-interview
13:55:50 <Cale> a pair of values of the same type
13:55:55 <allenj12> i want to do that but in haskell
13:56:01 <monochrom> Have you answered my question about what cast's doc says?
13:56:14 <mauke> graygray: input is always a string
13:56:16 <centril> is there anything like  (\f ts -> join <$> traverse f ts)  in lens or anywhere else on hackage ?
13:56:19 <monochrom> Does the doc even say anything remotely close to your goal?
13:56:52 <centril> doesn't have to be join tho, other candidates: concat
13:56:55 <allenj12> Cale: my problem is the type signature is recursive so i have no idea how to even start writing the function
13:57:20 <Cale> allenj12: I guess if we defined a type which was inclusive enough to begin with such that it could contain both functions and whatever type of elements you want in your "lists", then you could do something similar
13:57:38 <Cale> allenj12: They're abusing the fact that whatever lisp that is is untyped though
13:57:58 <allenj12> Cale: i know, its also clojure. but it should be possible in haskell?
13:58:12 <Cale> Well, you can Church encode a list
13:58:15 <allenj12> Cale: this is purely for excersice, nothing practical
13:58:16 <graygray> mauke: yeah but when I read Input and store in an Int it causes runtime errors if Input doesn't cast so I was checking using cast before storing it
13:58:44 <Cale> > let myList = (\nil cons -> cons 1 (cons 2 (cons 3 nil))) in myList 0 (+)
13:58:49 <lambdabot>  6
13:58:58 <mauke> graygray: I don't know why you keep talking about casts. this has nothing to do with casting
13:59:08 <graygray> doesn't it?
13:59:24 <mauke> ... no?
13:59:31 <monochrom> For the 4th time, you should read the doc.
13:59:48 <graygray> I did read the doc
13:59:50 <monochrom> And then if it's still unclear to you, we can talk.
13:59:53 <mauke> it has to do with 'read' erroring out when given something it doesn't like
14:00:05 <mauke> wrapping cast around an error achieves nothing
14:00:06 <monochrom> OK, so what did it say and how did you deduce that it's relevant?
14:00:20 <Cale> Use readMay if you want to handle a parse failure
14:00:25 <Cale> (or reads)
14:00:28 <Cale> :t readMay
14:00:33 <lambdabot> error: Variable not in scope: readMay
14:00:35 <monochrom> it's readMaybe
14:00:40 <Cale> ah
14:00:41 <monochrom> in Text.Read
14:00:46 <Cale> :t readMaybe
14:00:49 <lambdabot> error: Variable not in scope: readMaybe
14:00:52 <monochrom> "readMay" is a pig latin thing.
14:00:58 <Cale> haha
14:01:04 <Cale> @let import Text.Read
14:01:09 <Cale> :t readMaybe
14:01:11 <lambdabot>  Defined.
14:01:21 <Cale> lambdabot running a little slow today
14:01:22 <lambdabot> error: Variable not in scope: readMaybe
14:01:24 <mauke> @hoogle readMay
14:01:43 <lambdabot> Plugin `hoogle' failed with: <<timeout>>
14:02:00 --- mode: ChanServ set +o mauke
14:02:00 --- mode: mauke set +b *!~GK_1wm_SU@*
14:02:03 <Cale> I think readMay is from Safe
14:02:05 <monochrom> OK, no answer. Point proved, problem solved.
14:02:43 <Cale> But yeah, readMaybe is in base, use that :)
14:03:00 <graygray> I was just trying out readMaybe
14:04:00 --- mode: mauke set -o mauke
14:04:01 <Cale> .oO(IPv6 is great for ban effectiveness...)
14:22:31 <AWizzArd> carlosdagos: are you here?
14:23:51 <ph88^> hi guys
14:24:18 <ph88^> ghc advice me to use Rank2Types, i never used it before, should i use it? I get the notice with this code https://bpaste.net/show/503bbab9fe6f
14:26:17 <glguy> ph88^: That's a trivial use of RankNTypes, doesn't hurt anything. If you want to avoid the extension change to: eotTerminal :: (Generic a, Applicative f) => eot -> LensLike' f eot a
14:33:26 <mmaruseacph2> can anyone help me understand why this behavior happens? http://lpaste.net/353653
14:36:40 <Cale> If you use thaw rather than unsafeThaw, you'll get the result you wany
14:36:42 <Cale> want*
14:37:20 <mmaruseacph2> yes, but I want the unsafe everywhere
14:38:54 <Cale> It's only safe to unsafeThaw a vector if you do not use the immutable one ever again after that point.
14:39:35 <mmaruseacph2> even if I freeze it after the modify?
14:39:44 <Cale> Right.
14:40:10 <mmaruseacph2> cool, thanks
14:40:12 <Cale> My guess is that it has to do with replicate
14:40:40 <scope> Hey so I have duplicate points coming out of this function, for instance the list it returns might have points ((1,4), (5,7)) and ((5,7), (1,4)). How can I prevent this?
14:40:45 <scope> http://lpaste.net/7363021821769154560
14:41:46 <mmaruseacph2> it is because of replicate, if I pass a V.fromList [VU.fromList [0, 0], VU.fromList [0, 0]] instead it works
14:42:09 <Cale> scope: (x:xs) <- tails points, y <- xs
14:42:23 <scope> ahh that makes sense
14:42:27 <scope> ty
14:46:17 <scope> Cale I tried your solution but I get **Exception: tail empty list while testing
14:46:43 <Cale> tails, not tail
14:47:14 <scope> changed to tails and get a shitload more errors
14:47:14 <Cale> > tails [1,2,3,4,5]
14:47:18 <lambdabot>  [[1,2,3,4,5],[2,3,4,5],[3,4,5],[4,5],[5],[]]
14:47:33 <scope> works without tails though
14:47:42 <Cale> > [(x,y) | (x:xs) <- tails [1,2,3,4,5], y <- xs]
14:47:46 <lambdabot>  [(1,2),(1,3),(1,4),(1,5),(2,3),(2,4),(2,5),(3,4),(3,5),(4,5)]
14:47:52 <scope> [(x,y) | x <- tails points, y <- points, isHullEdge points (x,y), x /= y]
14:48:03 <Cale> that's not what I wrote...
14:48:06 <glguy> scope: You still have to show actual code and errors
14:48:07 <scope> oh wow
14:48:10 <scope> I see what you're saying
14:48:13 <glguy> we can't guess what the typos are
14:48:24 <scope> glguy I literally just pasted the line
14:48:29 <scope> cale knows what's happening
14:50:04 <scope> I missed the (x:xs) Cale, works now, thanks
14:50:47 <Cale> Do you understand how it works?
14:50:55 <Cale> We're picking a nonempty tail of the list of points
14:51:20 <Cale> and then the first element of that tail is our first selected point
14:51:32 <Cale> and we pick the second point from the remainder of that tail
14:51:49 <Cale> so the second point is necessarily one that came later in the original list
14:56:26 <scope> Hey sorry Cale, yes I do understand how it works
15:00:50 <ph88^> glguy, yeah that worked really nice .. but now i get some errors that i'm not sure what to do about them. I think it's best to first fix the bottom one and then the ones higher up https://bpaste.net/show/0977056f3a1f
15:01:22 <laudiacay>  /b 2
15:01:38 <mauke> 2 /b or not 2 /b
15:02:40 <ph88^> glguy, from which timezone are you ?
15:02:43 <glguy> ph88^: It looks like you forgot the 'eot' typed parameter
15:02:56 <glguy> eotTerminal f (Left fields) = becomes eotTerminal _eot f (Left fields) =
15:03:20 <mauke> @time glguy
15:03:25 <ph88^> glguy, yeah i know that, but i'm not sure what i'm suppose to do with that _eot parameter
15:03:42 <glguy> mauke: I elected not to implement CTCP responses this time around
15:03:46 <mauke> heh
15:04:07 <glguy> I'm on PST/PDT -8/-7
15:04:49 <ph88^> oh nice afternoon
15:05:07 <ph88^> let me think about that eot for a bit
15:05:28 <erisco> scope, how's your breath?
15:05:48 <scope> I haven't quite gotten the one we were working on earlier to work right
15:05:57 <scope> I've made progress on other functions though with some help
15:06:21 <erisco> hm, well lets take a look
15:06:31 <scope> I do have a question for you though, how can I prevent duplicates in this list comprehension? [fst(x,y) | x <- points, y <- points, isHullEdge points (x,y)]
15:06:32 <erisco> I gave every line needed
15:07:18 <erisco> okay, well first fst (x, y) reduces to x, so may as well just write that
15:08:05 <erisco> now, do you mean prevent duplicates or just remove them afterwards?
15:08:26 <erisco> if you mean prevent then there is a problem, because you necessarily have a duplicate x for every y
15:08:37 <scope> problem is the context, I need to send a pair of points to isHullEdge
15:08:38 <erisco> if you just want to remove duplicates afterwards then use nub
15:08:42 <scope> here one sec
15:09:16 <scope> http://lpaste.net/1086680722216845312
15:09:46 <scope> edge is a pair of points
15:10:34 <scope> I might be able to skip using isHullEdge and just use convexHullEdges
15:10:43 <erisco> are we looking at line 11 then?
15:10:58 <scope> trying to fix line 16
15:11:04 <scope> line 11 works as intended
15:11:55 <erisco> interestingly the Graham Scan is the first thing I wrote in Haskell ^.^
15:12:17 <erisco> it was horrendous
15:12:22 <scope> tell me about it haha
15:12:36 <mauke> horrendomorphism
15:13:17 <erisco> okay, so we want all the points on the hull, got it
15:13:47 <erisco> and our test for knowing if a point is on the hull is if it forms a line segment (with any other point) that is on the hull
15:14:01 <scope> right
15:14:30 <erisco> okay, so, you have a function convexHullEdges which finds all the edges that form the hull
15:15:10 <erisco> all the points then can be found with these edges, yes? (the implication is backwards here, but I think it is still okay)
15:15:21 <scope> Yes, this is true.
15:15:43 <scope> But they're wrapped up in the form ((x,y), (x,y))
15:15:50 <erisco> okay, so if we take this list of edges and project out the two points that make them we'll end up with a list of list of points, yes?
15:16:02 <erisco> or a list of tuples of points, but lets say we make it a list of lists
15:16:08 <scope> Right, having trouble figuring out how to do this
15:16:15 <lambdabot> Local time for glguy is manual response?
15:16:21 <erisco> okay, what is the definition of Edge?
15:16:27 <scope> Two points
15:16:33 <scope> type Edge a = (Point a, Point a)
15:16:43 <erisco> okay, I meant exactly. So it is an alias
15:16:50 <scope> yes
15:16:54 <erisco> :t fst
15:16:56 <lambdabot> (a, b) -> a
15:16:57 <erisco> :t snd
15:16:59 <lambdabot> (a, b) -> b
15:17:06 <erisco> do you see now how we can get the points out?
15:17:10 <scope> I think I get what you're saying.
15:17:13 <scope> give me a minute to play around
15:18:47 <scope> something along the lines of this? I know this isn't quite correct [x | x <- fst(convexHullEdges(points))]
15:19:12 <erisco> not everything has to be a list comprehension, you know ;)
15:19:22 <erisco> [x | x <- xs] is just xs
15:19:52 <scope> what exactly do you mean?
15:20:19 <AWizzArd> When I get a Non-exhaustive pattern error message in ghci, is there then a way to see the actual arguments with which my FN was called?
15:20:22 <erisco> well you write everything as a list comprehension and that's okay but there are other options
15:20:38 <scope> how would you suggest doing it? I understand what you're saying but I can't picture the code
15:20:41 <erisco> it may help to think outside the box of list comprehensions
15:20:41 <bollu> :t map
15:20:47 <lambdabot> (a -> b) -> [a] -> [b]
15:20:56 <scope> are you saying like xs <- fst(convexHullEdges(points))?
15:21:18 <bollu> > map (+ 1) [1..10] == [x + 1 | x <- [1..10]]
15:21:28 <lambdabot>  mueval-core: Time limit exceeded
15:21:29 <erisco> okay, so, convexHullEdges points :: [Edge a]
15:21:36 <bollu> what?
15:21:40 <erisco> right?
15:21:44 <scope> right
15:22:04 <erisco> now, we want to take this list of edges and end up with a list of list of points
15:22:17 <erisco> i.e. we want to take the points out of each edge and make a list
15:22:36 <erisco> so, we can do that latter part with \(x, y) -> [x, y]
15:23:00 <scope> what does the \ do?
15:23:10 <erisco> okay lets not use that
15:23:28 <erisco> lets say  pointsOfEdge :: Edge a -> [Point a]; pointsOfEdge (x, y) = [x, y]
15:23:54 <scope> do we need to make the tuple into a list or can I just take the first element of the tuple?
15:24:01 <ph88^> glguy, what i don't get about this code https://bpaste.net/show/4ec41c1fcae7 before i had eot -> P.Doc (line 6) and 2 arguments where enough (line 23) .. and now i have also just 1 arrow (line 41) but i suddenly require 3 arguments (line 58) .. what's going on ?
15:24:11 <scope> Think I'm misunderstanding what we're trying to do here
15:24:30 <erisco> ah, heh, well I think you are using a clever insight about how the edges form the hull
15:24:46 <erisco> let me frame the algorithm then
15:25:06 <mauke> the \ thing is for functions. \ PARAMETERS -> BODY
15:25:15 <erisco> we get a list of points, call it ps, and from this we find the edges that form the convex call, call it es = convexHullEdges ps
15:25:30 <erisco> form the convex hull*
15:25:55 <erisco> now we want all the points on the convex hull and we have a list of the edges of the convex hull
15:26:00 <erisco> does it make sense up to here scope?
15:26:09 <scope> somewhat
15:26:25 <erisco> we should be 100% up to this point so what is unsure?
15:27:05 <scope> it's just how it's coded, I understand the logic
15:27:33 <erisco> well I am just describing the idea, not the code, at the moment, so are we good up to that point?
15:27:54 <scope> ah, yes. But we shouldn't need to call the list of points ps, as it's already defined as "points" correct?
15:28:23 <erisco> "we get a list of points, call it points, ..." that just didn't sound clear to me :P
15:28:37 <scope> it's a parameter for convexHullPoints haha, that just threw me off
15:28:44 <scope> continue on
15:29:13 <erisco> okay, so we know all the points on the hull can be found in the edges that form the hull
15:29:22 <lyxia> How can I know what options stack calls ghc with?
15:29:34 <scope> correct
15:29:43 <erisco> so our objective is to get all the points out of the edges, and we have our answer
15:29:51 <erisco> does that rough idea make sense?
15:29:57 <scope> absolutely
15:30:18 <erisco> okay, so the first thing I did was figure out how to get the points out of an edge
15:30:25 <MarcelineVQ> lyxia: it'll be in -v with a line like Run process:
15:30:26 <scope> I'm just trying to come up with the code for it, when you say it doesn't need to be a list comprehension that confuses me though, as that's how I've been doing most things
15:30:41 <erisco> now, I happen to know a little further ahead, so I know we'll want to put them in a list, I am just saving a bit of backtracking for us
15:30:47 <scope> so I can't just do [es <- convexHullEdges points] can I?
15:31:11 <erisco> it *can* be a list comprehension, I am just suggesting that you try other things
15:31:19 <scope> gotcha
15:31:19 <erisco> we'll use a list comprehension
15:31:37 <scope> I mean if you think it's better to do it another way I'll do my best to make sense of it
15:31:47 <scope> I'm just not used to what you're suggesting but I'm willing to learn
15:31:49 <erisco> well I don't want to confuse more than necessary
15:32:06 <erisco> it is just that list comprehensions are a combination of simpler pieces and it might help to know them individually
15:32:22 <scope> fair enough, keep going with your suggestion
15:32:25 <scope> I'll try to keep up
15:32:48 <erisco> okay, so I made a new function called pointsOfEdge which takes the points out of an edge and puts them in a list
15:32:54 <erisco> did that function make sense to you?
15:33:04 <scope> Yes
15:33:24 <erisco> we'll do this without a list comprehension first then and I'll show you how it connects to a list comprehension after
15:33:53 <erisco> now we have es :: [Edge a] and pointsOfEdge :: Edge a -> [Point a]  and we desire  ps' :: [Point a]
15:34:03 <erisco> ps' is our desired list of hull points
15:34:25 <scope> now what does the ' notation mean?
15:34:25 <erisco> bollu gave us the function to stick es and pointsOfEdge together in the way we want
15:34:34 <erisco> it is just another character
15:34:39 <scope> alright
15:34:58 <erisco> Haskell lets you use it for identifiers
15:35:03 <scope> gotcha
15:35:13 <erisco> so I am using it like you might mathematically for the "after"
15:35:18 <erisco> we start with ps and want to get to ps'
15:35:48 <erisco> :t map
15:35:51 <lambdabot> (a -> b) -> [a] -> [b]
15:36:22 <erisco> so lets look at this type carefully, as we should do first when trying to understand anything in Haskell
15:36:44 <erisco> map takes a function a -> b, and a list [a], and gives us back a list [b]
15:36:58 <erisco> can you intuit what map does?
15:37:04 <monochrom> Oh bollu is around! bollu: http://www.vex.net/~trebla/haskell/cont.xhtml
15:37:17 <scope> puts things into a list based on a function's result?
15:37:20 <scope> something like that?
15:37:30 <erisco> that's close to it
15:37:34 <AWizzArd> Is there a way, in ghci, to automatically place a break in the moment I get a Non-exhausting pattern error? So that I can see the args with which the function was called.
15:37:36 <erisco> the function takes a's, where does it get the a's from?
15:37:54 <bollu> monochrom: thanks!
15:38:01 <scope> not sure to be honest
15:38:24 <erisco> okay lets use concrete types
15:38:39 <erisco> map :: (Int -> Char) -> [Int] -> [Char]
15:38:46 <erisco> where does it take the Ints from?
15:39:01 <scope> is it a parameter for map?
15:39:22 <erisco> maybe my question is more obtuse than I realise
15:39:28 <erisco> > map f [a,b,c]
15:39:29 <scope> you mean the first Int right?
15:39:35 <lambdabot>  mueval-core: Time limit exceeded
15:39:42 <erisco> lambdabot get your shit together man
15:39:45 <scope> hahaha
15:39:53 <erisco> okay, well it should have told us this:
15:39:56 <erisco> [f a, f b, f c]
15:40:07 <scope> so map applies a function to a list
15:40:44 <scope> I think I see where you're going with this. Are you suggesting using map with pointsOfEdge to create the new list?
15:40:54 <erisco> yes, that is exactly it
15:40:55 <scope> so that the tuples are no longer tuples?
15:41:01 <erisco> mhm
15:41:07 <scope> Ok makes sense
15:41:19 <erisco> now like I said, I know a step ahead of this, so we'll get to why we don't want tuples in a minute
15:41:29 <bollu> anyone know what's up with lambdabot?
15:41:52 <erisco> map :: (a -> b) -> [a] -> [b]  and so what is the type of  map pointsOfEdge  ?
15:42:03 <scope> a list?
15:42:08 <erisco> tell me exactly
15:42:15 <scope> uhhhhh
15:42:36 <scope> a list of the points on the edge?
15:42:46 <erisco> map :: (a -> b) -> [a] -> [b]  and  pointsOfEdge :: Edge a -> [Point a]
15:42:55 <erisco> so what is  map pointsOfEdge :: ?
15:43:04 <bollu> erisco: may want to change "a" to "p" or something :)
15:43:13 <scope> the points that make up the convex hull? maybe I'm not following
15:43:17 <erisco> curse you hygiene!
15:43:24 <erisco> well I am looking for a type
15:43:32 <erisco> tell me a type, like Int, or Maybe String, or something like that
15:43:46 <kazagistar> Its slightly less confusing if you use different letters, yeah. Like (a -> b) -> [a] -> [b]  and  pointsOfEdge :: Edge e -> [Point p]
15:44:13 <erisco> well it cannot be e and p, but we can say  pointsOfEdge :: Edge c -> [Point c]  or something
15:44:18 <scope> I'm struggling here, doesn't help that chat keeps moving
15:44:23 <kazagistar> oh, right
15:44:32 <erisco> I don't think we're at the stage of being confused about the variable hygiene
15:44:35 <bollu> scope: OK. think of this as a game of "matching"
15:44:54 <erisco> lets start simpler, since we really need to develop a basic sense of types to program in Haskell
15:45:10 <scope> before that, what was the type you were looking for?
15:45:14 <scope> it may click when you say it
15:45:16 <erisco> I will tell you that (+1) :: Int -> Int, and I will tell you x :: Int
15:45:23 <erisco> what is the type of (+1) x then?
15:45:36 <lyxia> Tuplanolla: I don't see my options in -v, even though I can see them taking effect...
15:45:38 <scope> Int...?
15:45:48 <erisco> yes
15:46:00 <erisco> now I will tell you   f :: a -> b  and  x :: a, so what is the type of  f x ?
15:46:14 <scope> a
15:46:18 <erisco> try again
15:46:20 <Tuplanolla> What are we discussing, lyxia?
15:46:22 <bollu> scope: why a?
15:46:38 <scope> b rather
15:46:53 <erisco> does that make sense?
15:47:02 <scope> well f changes a to b, is that right?
15:47:14 <erisco> yes, f is a function from a to b
15:47:30 <bollu> scope: also remember, these are _types_
15:47:31 <erisco> so if we give it an a, then we will get a b
15:47:36 <scope> right
15:47:53 <erisco> okay, now say  f :: a -> b  and  x :: Int, what is the type of  f x ?
15:48:10 <scope> whatever b is
15:48:23 <lyxia> Tuplanolla: I want to know why stack is optimizing my builds, and more generally how it's calling ghc
15:48:42 <scope> wait
15:48:49 <Tuplanolla> Okay, lyxia. I don't use Stack though.
15:49:03 <erisco> scope, Int and "a" look different, are you sure that is okay?
15:49:28 <scope> is this a trick question? lol
15:49:52 <erisco> well I can't know everything you've already learned so I am not sure
15:50:06 <erisco> I presume you know "a" is a type variable, whereas "Int" is a type
15:50:12 <scope> well how can f x even work if f doesn't take an Int
15:50:49 <erisco> okay, good, this is really important to know
15:51:06 <scope> I legitimately thought that was a trick question lol
15:51:13 <erisco> types in Haskell can be polymorphic, meaning they may have variables in them
15:51:29 <erisco> f :: a -> b  is polymorphic. we can choose "a" or "b" to be any type
15:51:37 <erisco> "a" and "b" are type variables
15:51:57 <erisco> just like if I have an equation y = 3*x + 4 I can choose x to be any number
15:52:10 <erisco> in types we can choose variables to be any type
15:52:21 <MarcelineVQ> lyxia: Looks like I was wrong, I also don't see options in full debug output, or find them in build logs
15:52:26 <erisco> so, if f :: a -> b, it is also the case that f :: Int -> b
15:52:32 <erisco> because we can choose a = Int
15:52:38 <glguy> ph88^: You changed the type of eotTerminal from one that needed 1 parameter to one that needed 3
15:52:40 <scope> ah alright
15:52:46 <erisco> why do we choose a = Int? well because x :: Int and we need to match them up
15:53:10 <erisco> this process of instantiating variables to match types is called unification, and is something Haskell does for us
15:53:16 <maerwald> it's like duck typing, but during compile time! (lol)
15:53:26 <Lazersmoke> (and completely safe)
15:53:28 <erisco> but we need to know how it works so we can write type correct programs
15:53:29 <scope> I've noticed that you don't need to explicitly call something an int or whatever
15:53:48 <scope> meaning I could do name = 5 or name = "myname"
15:53:52 <Lazersmoke> the compiler is pretty good at inferring what the type *should* be from the context
15:53:52 <scope> so I understand that much
15:53:56 <hiWorld> haskell assigns typing at compile time, so it only appears to the user as if it's duck typed
15:54:05 <bollu> scope: so, f :: a -> b is "actually" f :: forall a, forall b, a -> b
15:54:14 <erisco> okay, so, armed with this knowledge, can you figure out the type of  map pointsOfEdge ?
15:54:21 <MarcelineVQ> lyxia: if Cabal optomizes by default though that's likely why stack would be, it seems to use Cabal on the configure step
15:54:26 <erisco> right
15:54:50 <erisco> it is, in words, "forall types a, forall types b, f has the type a -> b"
15:55:00 <Lazersmoke> worth noting that `forall a b. a -> b` is actually a nonsense type because it would have to be a function that works for every single possible type
15:55:10 <scope> :t map
15:55:13 <lambdabot> (a -> b) -> [a] -> [b]
15:55:40 <erisco> right, f is actually unsafeCoerce, which is bad, but we were just using it for an example
15:55:42 <scope> so the type would be a function?
15:55:43 <bollu> scope: I have a question for you. Consider g :: forall a. a -> a. Can you implement such a "g" for me?
15:56:03 <scope> specifically pointsOfEdge?
15:56:11 <erisco> yes
15:56:46 <lyxia> MarcelineVQ: Thanks, that seems to be it.
15:56:52 <scope> bollu I understand the logic but don't think I understand how the syntax would look
15:57:24 <bollu> scope: tell me the logic then :)
15:57:32 <bollu> can I not have cyclic data declarations?
15:57:57 <erisco> bollu, is that a separate question?
15:58:05 <bollu> erisco: yeah that's to the channel
15:58:15 <erisco> cyclic as in mutual?
15:58:18 <scope> so erisco, you're saying for convexHullPoints points = [map pointsOfEdge (convexHullEdges)] or something of the sort
15:58:26 <bollu> A is a sum type which uses X in one of the branches. X is a product type that always uses A
15:58:27 <scope> I know there's more to it
15:58:31 <bollu> so it's not wrong to create this
15:58:37 <bollu> to imagine such a type that is
15:58:42 <bollu> but the compiler doesn't let me do this
15:58:59 <erisco> bollu, maybe write out your attempt and I can get a better idea
15:59:37 <erisco> scope, not quite, no, so I just wanted you to figure out the type at this point
15:59:45 <erisco> to program in Haskell what you really want to do is follow the types
15:59:52 <erisco> they're like the walls, they tell you things
16:00:21 <erisco> you see you have type A and you want type B and that informs you of what needs to happen
16:00:30 <scope> right
16:00:39 <erisco> so if we know the type of map pointsOfEdge it is going to become clear as to how we finish the definition
16:00:43 <Lazersmoke> Sometimes you can figure out what something does from the types alone
16:00:51 <bollu> erisco: http://lpaste.net/7092124185572409344#line142. ExprNodeLet uses Binding. Binding uses Lambda. Lambda uses ExprNode
16:01:44 <erisco> and what is the compiler error?
16:01:45 <scope> well the type is pointsOfEdge, which returns a list
16:01:48 <glguy> bollu: The problem is that you used TH between the two
16:01:59 <erisco> pointsOfEdge is not a type
16:02:00 <glguy> bollu: specifically makePrisms, doing that segments your module
16:02:13 <bollu> glguy: what? :O 
16:02:22 <erisco> in Haskell there are types and there are values, and they never mix
16:02:25 <bollu> glguy: I have never heard of this, why does this happen?
16:02:32 <glguy> bollu: move all the data type declarations above your splicing in of the Prisms
16:02:33 <erisco> we write x :: t which means "the value x has the type t"
16:02:35 <bollu> OK
16:02:37 <scope> well wouldn't the type be the return type of pointsofedge?
16:02:41 <erisco> so values are always on the left and types always on the right of ::
16:02:42 <Lazersmoke> yeah that makes sense. TH probably stopped reading the file before it got to the definition of ExprNode
16:02:55 <erisco> pointsOfEdge is a function, so it is on the left of ::, it is a value
16:03:01 <erisco> tell me the type of pointsOfEdge
16:03:11 <scope> [Point a]
16:03:22 <erisco> nope, go back to when I defined pointsOfEdge
16:03:23 <glguy> bollu: It does that so that you can use things from TH as you define them to make new things, but the things you are using need to be finished being defined before you can use them , so it processes the module in chunks
16:03:47 <scope> it takes an edge and returns the points in that edge
16:04:15 <bollu> glguy: I see
16:04:17 <scope> pointsOfEdge :: Edge a -> [Point a]
16:04:20 <bollu> glguy: and why are the chunks not fused up?
16:04:23 <erisco> when I ask for a type I always mean something like String, or Int, or a formal thing like this
16:04:40 <glguy> bollu: so that you can use the thing syou just defined with TH below the TH
16:04:54 <erisco> okay, so tell me in words what pointsOfEdge :: Edge a -> [Point a] is. don't tell me what the function does, just tell me what that notation means
16:05:14 <erisco> and if you don't know that is okay, we'll go through it
16:05:34 <erisco> I'm not sure how much you know and don't know so I am taking some guesses when I direct these questions
16:05:36 <scope> pointsOfEdge changes an edge to a list of points, I don't know what you mean, is that not what the notation means?
16:05:56 <erisco> okay, that is part of it
16:06:10 <bollu> glguy: I'm still not sure as to why the chunks are not fused together once the spilicing has finished?
16:06:34 <erisco> you can word it differently, but it is something like this: "pointsOfEdge has the type function from Edge a to [Point a]"
16:06:43 <scope> right, I understand that
16:06:57 <glguy> bollu: It's discussed in the GHC user's guide. I'd start there. There's a chicken/egg problem if you want to be able to inspect parts of the module while you're defining the module
16:07:04 <erisco> so x :: t means "x has the type t", and a -> b means "function from a to b"
16:07:13 <scope> right
16:07:18 <Lazersmoke> GHC is frustratingly linear; you can't compile mutually recursive modules without {-# SOURCE #-} and hs-boot, and TH splices break things. I wish GHC treated every top-level definition as its own module and allowed mutual recursion
16:07:25 <Lazersmoke> that would make me cohappy
16:07:52 <erisco> okay, good, so when you say "the type is pointsOfEdge" do you see why that doesn't work?
16:08:07 <bollu> ah OK
16:08:11 <bollu> glguy: much appreciated
16:08:15 <bollu> glguy: what do I need to look for?
16:08:22 <scope> Okay so I get why pointsOfEdge won't give me what I need, it only takes a single edge rather than all of them
16:08:23 <glguy> Template Haskell
16:08:33 <scope> meaning I'll only get the points on a single edge
16:08:35 <erisco> no, it doesn't work because pointsOfEdge is not a type :P
16:08:50 <scope> but map takes a function???
16:08:53 <bollu> this is perhaps offtopic, but is there some sort of haskell meetup in zurich every week or some such?
16:08:56 <erisco> you cannot say "the type is x" when x isn't a type because that is a nonsense statement
16:09:11 <Lazersmoke> a "function" is different from a "function type"
16:09:15 <scope> ah but yes I understand that
16:09:19 <scope> pointsOfEdge is a function
16:09:23 <scope> I misunderstood you
16:09:43 <erisco> yes maybe we are being unclear when I say "function", as Lazersmoke points out
16:09:53 <Lazersmoke> yeah map takes a function, and the function you are giving it is pointsOfEdge
16:10:01 <scope> Lazersmoke exactly
16:10:03 <scope> I get that haha
16:10:29 <erisco> id x = x   this is a function definition, it defines the value called id
16:10:36 <erisco> so I will say "id is a function"
16:10:45 <erisco> id also has a type, this type is a -> a
16:11:14 <erisco> so I should have more clearly said "a -> a" is the type of functions from a to a
16:11:17 <Lazersmoke> :t id
16:11:20 <lambdabot> a -> a
16:11:25 <scope> so I can't send convexHullEdges(points) to pointsOfEdge because convexHullEdges returns a list, whereas pointOfEdge doesn't take a list
16:11:40 <Lazersmoke> exactly
16:11:43 <erisco> the key phrase being "type of functions", which -> constructs
16:12:19 <Lazersmoke> that's where map comes in. It takes a function and "upgrades" it to work on each element of a list individually
16:12:20 <Lazersmoke> :t map
16:12:22 <lambdabot> (a -> b) -> [a] -> [b]
16:12:24 <erisco> that's right, if the types don't match then it is a no-go
16:12:36 <erisco> but  map pointsOfEdge  will work, I just wanted you to figure out the type of this
16:12:46 <erisco> if you know what type it has it will help us finish the definition
16:12:50 <scope> this still doesn't quite work though convexHullPoints points = map pointsOfEdge (convexHullEdges(points))
16:12:59 <Lazersmoke> that type is the same as "(a -> b) -> ([a] -> [b])" btw
16:13:20 <erisco> right, well, humour me and find the type :P
16:13:25 <bollu> Lazersmoke: I think you should wait till you bring in currying and associativity of (->) and all that 
16:13:42 <Lazersmoke> yeah probably
16:13:57 <erisco> you can take some intuitive guesses at this point but it will be so much easier if you just learn how to understand the types
16:14:00 <scope> the type of that whole expression or something in particular?
16:14:22 <Lazersmoke> what is the type of convexHullEdges? "[Point a] -> [Edge a]"?
16:14:27 <erisco> then you don't just be taking stabs, you'll be making careful, well-timed attacks ;)
16:14:44 <erisco> Lazersmoke, http://lpaste.net/1086680722216845312
16:14:51 <Lazersmoke> ah ty
16:14:53 <scope> convexHullEdges is a function
16:14:59 <scope> lol
16:15:15 <scope> but it returns a list of points
16:15:17 <erisco> it is a function, yes, and that is the type (ignoring the context)
16:15:31 <scope> AH
16:15:32 <erisco> so here is the task
16:15:48 <erisco> map :: (a -> b) -> [a] -> [b]  and  pointsOfEdge :: Edge c -> [Point c]
16:16:03 <erisco> so you just need to find the a and b such that  a -> b  is the same as  Edge c -> [Point c]
16:16:20 <erisco> then you can find the type of  map pointsOfEdge
16:17:51 <scope> dammit
16:18:33 <scope> put this into english for me and I think I could understand map :: (a -> b) -> [a] -> [b]
16:18:58 <bollu> scope: what part are you finding trouble with? the entire type, or some part of it, or..?
16:19:21 <scope> I'm just struggling to take in so much information at once I think
16:19:22 <erisco> "map has the type of a function from a -> b to a function from [a] to [b]
16:19:23 <erisco> "
16:19:45 <erisco> if the two ->'s are confusing you we can discuss that
16:19:53 <scope> yeah just a bit
16:19:57 <erisco> actually I'll let bollu tell you because he knows
16:19:59 <Lazersmoke> you can put parentheses like this if it helps: "(a -> b) -> ([a] -> [b])"
16:20:23 <Tuplanolla> :t uncurry map -- Alternatively you can view it like this, scope.
16:20:26 <lambdabot> (a -> b, [a]) -> [b]
16:21:07 <Tuplanolla> :t uncurry id -- It is one kind of a generalization of this, scope.
16:21:09 <lambdabot> (b -> c, b) -> c
16:21:52 <bollu> scope: OK, let's talk about a -> b -> c v/s a -> (b -> c)
16:22:03 <bollu> scope: consider this
16:22:10 <bollu> :t (+) :: Int -> Int -> Int
16:22:13 <lambdabot> Int -> Int -> Int
16:22:29 <bollu> what does (+) do? it takes 2 integers and returns another one, corect?
16:22:30 <bollu> > 1 + 2
16:22:34 <lambdabot>  3
16:22:42 <bollu> now, that's _one_ way to look at it
16:22:46 <bollu> the other way is like this
16:23:06 <bollu> > ((+) 1) 3
16:23:08 <Raddamu> 6 + 4
16:23:14 <bollu> Raddamu: ?
16:23:15 <lambdabot>  mueval-core: Time limit exceeded
16:23:15 <lambdabot>  mueval: ExitFailure 1
16:23:29 <bollu> why is lambdabot failing :(
16:23:38 <geekosaur> because whatever it's hosted on is overloiaded
16:23:43 <erisco> I think a cicada is stuck in the CPU fan
16:23:49 <Lazersmoke> RIP lambdabot, you will live on forever in our hearts, if not in our IRC
16:23:52 <geekosaur> stick stuff in the cloud, occasionally end up with a cloudburst :p
16:24:08 <bollu> geekosaur: I had never realised how much I rely on lambdabot to explain things :P
16:24:13 <Tuplanolla> Clouds are subject to weather.
16:24:28 <scope> so erisco, map pointsOfEdge
16:24:35 <bollu> https://www.youtube.com/watch?v=AnxrJiS5uKU
16:25:11 <Lazersmoke> (map :: (a -> b) -> [a] -> [b]) (pointsOfEdge :: Edge a -> [Point a])
16:25:16 <bollu> scope: the other way of looking at (+) is as follows: (+) is a function that takes an integer, and returns another _function_ which takes an integer and returns a value
16:25:27 <scope> bollu I think you're confusing me more
16:25:27 <bollu> scope: in the sense, let f = (+) 1
16:25:32 <bollu> scope: OK
16:25:44 <scope> I'm literally just trying to figure out the type of map pointsOfEdge
16:25:52 <scope> which I think should be a list
16:26:11 <chaosmasttter> why do you think that?
16:26:13 <bollu> scope: answer this question first: how many parameters does map have?
16:26:22 <scope> one, a tuple
16:26:40 <erisco> <erisco> so you just need to find the a and b such that  a -> b  is the same as  Edge c -> [Point c]
16:26:49 <Lazersmoke> scope: You just need to match up "Edge a -> [Point a]" with the "a -> b" in map
16:26:52 <erisco> can you do that scope? I narrowed the problem for you
16:26:59 <bollu> :t map
16:27:02 <lambdabot> (a -> b) -> [a] -> [b]
16:27:20 * erisco is glad we still have map and not just fmap
16:27:23 <bollu> scope: why do you think map takes 1 parameter? (a tuple)
16:27:26 <bollu> erisco: lol
16:27:32 <bollu> > fmap @ []
16:27:32 <pawn> How does haskell do multiple statements in a function?
16:27:38 <lambdabot>  error:
16:27:38 <lambdabot>      Pattern syntax in expression context: fmap@[]
16:27:38 <lambdabot>      Did you mean to enable TypeApplications?
16:27:43 <pawn> Cause isn't there only one return and stuff?
16:27:49 <bollu> pawn: you don't? you literally have only expressions
16:27:51 <geekosaur> pawn, haskell doesn't do statements
16:28:02 <erisco> doesn't "do" statements, heh
16:28:04 <bollu> pawn: "return" is just a function
16:28:06 <geekosaur> do notation pretends to, but it's actually an expression
16:28:07 <bollu> :t return
16:28:09 <lambdabot> Monad m => a -> m a
16:28:26 <scope> I misunderstood your question, I meant pointsOfEdge takes one parameter being a tuple
16:28:35 <scope> map takes a function and a list correct?
16:28:40 <erisco> yes
16:28:41 <bollu> scope: yes
16:28:45 <geekosaur> pawn, and that is in a sense your answer: instead of statements, we use sequences of functions
16:28:52 <geekosaur> @undo do a; b; c
16:28:53 <lambdabot> a >> b >> c
16:29:08 <bollu> scope: now, in the call "map pointsOfEdge", how many parameters are we passing?
16:29:14 <pawn> So, how would you do the equivalent of this in javascript: (x) => { dosomething(x); return 23; }?
16:29:19 <Lazersmoke> scope: in order to figure out the type of "map pointsOfEdge", you need to figure out what a and b are in the type of map
16:29:30 <scope> just one, but I've tried map pointsOfEdge (convexHullEdges(points))
16:29:33 <bollu> pawn: it depends on what dosomething(x) does. 
16:29:35 <geekosaur> pawn, that depends on the type of doSomething
16:29:35 <scope> which should satisfy both requirements
16:29:35 <Lazersmoke> pawn: haskell functions are pure, they only return a value, and don't do side effects
16:29:41 <bollu> scope: step back for a second
16:29:59 <geekosaur> hm, why did I camelify that...
16:30:01 <bollu> scope: let's say I have a function that takes two parameters, but I give it only 1. is this legal haskell?
16:30:12 <scope> No, and I realize that
16:30:19 <erisco> pawn, you can get a quick answer but if you want to understand how Haskell approaches this differently then you'll need to learn Haskell
16:30:23 <scope> map pointsOfEdge isn't valid
16:30:24 <bollu> scope: it _is_ legal haskell :D
16:30:27 <scope> what
16:30:31 <scope> my life is a lie
16:30:32 <erisco> pawn, so the long answer is a few weeks or months of practice
16:30:35 <bollu> scope: yes :)
16:30:43 <pawn> Eeek
16:30:44 <bollu> scope: OK, so to understand this, I want to go back to (+)
16:30:52 <bollu> scope: we think (+) has two parameters correct?
16:30:59 <scope> I don't even know what that is
16:31:05 <scope> that's why I thought you were confusing me more
16:31:08 <bollu> scope: that's just the operator + for addition
16:31:12 <Lazersmoke> (+) is just +, like 1 + 2
16:31:15 <scope> oh
16:31:21 <geekosaur> it's the + operator, presented as a prefix function instead of an infix operator
16:31:26 <Lazersmoke> you put it in parentheses and you can call it like "(+) 1 2"
16:31:28 <scope> oh ok
16:31:32 <bollu> > (+) 1 2
16:31:36 <lambdabot>  3
16:31:36 <bollu> plz work lambdabot
16:31:38 <bollu> yes
16:31:39 <bollu> OK
16:31:39 <scope> lol
16:31:44 <carlosdagos> lol
16:31:53 <bollu> OK, so, now, we think of (+) as a function with two parameters?
16:31:53 <erisco> pawn, if "doSomething" is a side effect then there is IO and ST as common solutions, and so it might look like  \x -> doSomething x >> return 23
16:32:07 <scope> yes
16:32:23 <Lazersmoke> lambdabot, our lord and savior, has returned. all praise his holy presence
16:32:24 <erisco> pawn, but some of those side effects we just do differently, such as having state
16:32:39 <bollu> however, we can think of (+) as a function that takes _1_ parameter, and _returns a function_ which takes another parameter and then does the (+). Actions speak louder, let me demonstate
16:32:42 <erisco> pawn, we prefer a type called State which lets us save and retrieve a value
16:32:47 <erisco> pawn, and it would look similarly
16:32:48 <bollu> > let inc = (+) 1 in (inc 2, inc 3)
16:32:51 * ski . o O ( s/his/her/ )
16:32:51 <lambdabot>  (3,4)
16:33:08 <scope> ok I see what happened there
16:33:13 <scope> added one to 2 and one to 3
16:33:17 <erisco> pawn, another answer is that in Haskell we don't have a lot of functions that look like that
16:33:36 <Lazersmoke> pawn, how experienced are you with Haskell?
16:33:50 <bollu> right? so I can pass fewer parameters  than needed, and haskell will go "oh cool, now I know what the first k parameters are, give me the rest of them and I will evaluate them!"
16:33:56 <bollu> scope: do you follow this
16:34:06 <scope> yes
16:34:08 <Lazersmoke> scope: what is the type of inc, if the type of (+) is "Int -> Int -> Int"?
16:34:14 <bollu> scope: OK, so now
16:34:26 <bollu> scope: the type of (+) is actually
16:34:50 <bollu> (+) :: Int -> (Int -> Int) === take an integer, return a *function* that takes an integer and returns an integer
16:34:55 <bollu> scope: does this make sense?
16:35:12 <scope> yes
16:35:14 <bollu> scope: a -> (b -> c) == take a, return a function from b to c, remember?
16:35:16 <bollu> scope: OK
16:36:13 <bollu> scope: now, traditionally, we have (->) associate rightward. So, a -> b -> c -> d is *by convention* read as a -> (b -> (c -> d))
16:36:44 <bollu> scope: which means, a function that takes a and (returns a function that takes b and returns (a function that takes c and returns d)))
16:36:48 <bollu> scope: this makes sense too?
16:36:49 <scope> so, take a, return a function that returns a function from c to d
16:37:02 <scope> right
16:37:15 <bollu> so when I write a -> b -> c, I actually mean a -> (b -> c)
16:37:21 <scope> ok
16:37:22 <bollu> this is fundamentally different from (a -> b) -> c
16:37:22 <pawn> Lazersmoke: Not so experienced at all
16:37:42 <tenohk> hi all. I'm trying to create a main function such that > main = putStrLn $ printAndReturn "foo" < prints "foo" twice, but cannot wrap my head around how to implement such a printAndReturn function.
16:37:43 <bollu> a -> (b -> c) = take a , return function from b to c. (a -> b) -> c = take a function from a to b, return c
16:37:44 <pawn> I'm just wondering how haskell does do more than one thing in a function if it only does expressions?
16:37:47 <bollu> does that make sense too?
16:37:54 <scope> yes
16:37:58 <bollu> so now
16:37:59 <bollu> consider
16:38:04 <bollu> map :: (a -> b) -> [a] -> [b]
16:38:11 <bollu> (what was the other thing?)
16:38:19 <scope> pointsOfEdge :: Edge a -> [Point a]
16:38:21 <scope> ?
16:38:21 <ski> tenohk : can't be done like that. can be done if you change `$' to `=<<'
16:38:22 <erisco> pawn, the secret is in what "do a thing" means
16:38:24 <bollu> right, yeah
16:38:30 <bollu> so what will map pointsOfEdge be?
16:38:37 <tenohk> thanks @ski ill check that out
16:38:38 <bollu> "map pointsOfEdge" is legal haskell
16:38:40 <bollu> as we discovered
16:38:44 <erisco> pawn, x * 2 + 1  I do two things here in this expression, right? I multiply by 2 and add 1
16:38:46 <bollu> so now, I want you to tell me the tye
16:38:47 <halogenandtoast> :t (=<<)
16:38:47 <bollu> type*
16:38:49 <lambdabot> Monad m => (a -> m b) -> m a -> m b
16:38:54 <ski> tenohk : in this case, `(=<<) :: (a -> IO b) -> IO a -> IO b'
16:38:57 <bollu> pawn: It really depends on what you mean by "do things
16:38:58 <bollu> "
16:39:03 <pawn> I see
16:39:15 <tenohk> haha damn i feel so retarded. thanks
16:39:25 <Lazersmoke> pawn: "doing more than one thing" means doing one thing, and then doing another thing, correct?
16:39:26 <scope> a list of lists? tenohk I feel retarded too
16:39:31 <bollu> scope: don't guess
16:39:40 <bollu> scope: think of this as pattern matching in your head
16:39:40 <pawn> Lazersmoke: Yes
16:39:46 <bollu> map :: (a -> b) -> [a] -> [b]
16:39:48 <ski> tenohk : `putStrLn' takes a `String', so in `putStrLn $ printAndReturn "foo"', `printAndReturn "foo"' must compute to a simple `String'. it can't do any I/O
16:40:21 <bollu> map ::                (a         ->        b)      -> [a] -> [b]
16:40:21 <bollu> pointsOfEdge :: Edge c -> [Point c]
16:40:23 <Lazersmoke> pawn: so in Haskell, we have the function (>>) which takes two arguments: the first thing to do, and the second thing to do
16:40:25 <pawn> Lazersmoke: I'm trying to figure out how you go from the functionName { block } way of thinking where { block } can be { statement. statement. statement...} to the haskell way
16:40:31 <bollu> map pointsOfEdge :: ?
16:40:43 <scope> fuck
16:40:47 <bollu> scope: ?
16:40:48 <tenohk> thanks ski
16:40:52 <ski> tenohk : in `putStrLn =<< printAndReturn "foo"', however, `printAndReturn "foo"' will have type `IO String', which is very different. this is a "recipe" for doing some I/O and ending up with a `String' (possibly a different one each time you follow the recipe, each time you execute the action)
16:40:53 <scope> I don't know why I can't wrap my head around this
16:40:58 <bollu> scope: OK, step back
16:40:59 <halogenandtoast> scope: Just do variable substitution
16:41:04 <erisco> pawn, like I said, that is a question of learning Haskell
16:41:13 <bollu> scope: what is the type of (+)?
16:41:23 <Lazersmoke> pawn: and it smooshes them together into a new "thing to do" that does the first thing, then the second thing
16:41:38 <erisco> pawn, if I asked you "how do you solve a problem so it looks like  statement1; statement2; statement3; ..." you'd tell me to learn procedural programming
16:41:39 <Lazersmoke> pawn: there is special syntax that lets you write that in a pretty way
16:41:43 <scope> a function
16:41:55 <bollu> scope: yes, but what is the type?
16:42:03 <scope> Int
16:42:07 <bollu> scope: is it?
16:42:13 <bollu> scope: so (+) is a number?
16:42:15 <erisco> pawn, so similarly your question is big
16:42:15 <ski> tenohk : so then `putStrLn =<< printAndReturn "foo"' will "add" the action of printing out this computed `String', after the recipe of `printAndReturn "foo"' -- iow, extending the recipe into a larger recipe. and because we define `main' to be this recipe, when the Haskell program is run, it'll start following the recipe
16:42:16 <pawn> I understand that erisco, however, I'm interested in the FP way
16:42:19 <scope> no it isn't but
16:42:22 <Lazersmoke> pawn: most of your programming is not actually doing side effects, but computing a value of some kind
16:42:25 <halogenandtoast> scope: don't confuse "return type" with type
16:42:27 <bollu> scope: but?
16:42:35 <erisco> pawn, now you can look at simpler systems such as Lambda Calculus if you want a taste, but that alone is not practical programming so it may be difficult to connect
16:42:37 <scope> I don't understand what you mean, a function isn't a type
16:42:45 <bollu> scope: a function *has* a type
16:42:52 <bollu> scope: everything has a type :)
16:42:58 <bollu> scope: I am asking you what type + has
16:43:03 <erisco> so I'd direct you to introductory texts on Haskell
16:43:09 <scope> num?
16:43:14 <ski> tenohk : just *evaluating* the "recipe", the action, will not perform any I/O whatsoever. it will only determine *what* to (possibly) later do. actually doing it (*executing* it), only happens as a result of being made part of the `main' action
16:43:19 <ski> tenohk : does that make sense ?
16:43:20 <erisco> I heard people poo-pooing LYAH and RWH so I don't know what the new hotness is
16:43:24 <bollu> scope: what other languages do you know?
16:43:31 <orion> erisco: haskellbook.com
16:43:32 <scope> C, C++, Java and some Ruby
16:43:34 <erisco> either of those are probably still reasonable
16:43:40 <monochrom> I can see how "the type of this function" is an alien concept for, say, C programmers.
16:43:43 <erisco> okay, go to there and start reading! we're here for your questions
16:43:54 <halogenandtoast> scope: For a function a type is defined by what types it can take, and what type it returns
16:44:01 <bollu> scope: OK, so, if I wrote this: int add(int a, int b) { return a + b; } and I asked you "what is the type of add" what would your answer be?
16:44:11 <Lazersmoke> pawn: don't listen to the haters, LYAH is the best book ever written http://learnyouahaskell.com/chapters
16:44:16 <scope> int
16:44:21 <monochrom> :)
16:44:28 <bollu> scope: wait what?
16:44:32 <carlosdagos> Lazersmoke: *claps*
16:44:40 <scope> I fail at life
16:44:41 <tenohk> yes. I'm just starting get into the idea of monads, this helped a lot. it's part of a greater effort, I'll see if i can pull it off now
16:44:44 <halogenandtoast> bollu: in oops when we talk about type, it's the return type
16:44:59 <bollu> scope: have you used function pointers in C?
16:45:02 <halogenandtoast> that oops what auto correct for oop...
16:45:04 <scope> Yes
16:45:06 <bollu> scope: for callbacks and stuff?
16:45:10 <scope> not very good with them
16:45:14 <bollu> scope: OK, so what is the signature of the function pointer for add?
16:45:32 <bollu> scope: because that will be the type of the *function* called add (since in a function pointer, we hold the type of function itself)
16:45:34 <ski> @quote /bin/ls
16:45:35 <lambdabot> shachaf says: getLine :: IO String contains a String in the same way that /bin/ls contains a list of files
16:45:37 <ski> tenohk ^
16:45:48 <scope> I mean I've used them but don't fully understand
16:45:53 <bollu> scope: hm, OK
16:46:08 <halogenandtoast> int (*add)(int, int)
16:46:10 <bollu> scope: uh, how much of a math background do you have?
16:46:27 <scope> my brain is also mush at the moment and I'm half asleep, so I'm sure that's not helping
16:46:40 <tenohk> im trying to create a sort of Maybe type such that whenever a function returns a Nothing, some IO action is performed
16:46:42 <erisco> maybe sleep and a new day is the best way to continue
16:46:42 <scope> not much
16:46:46 <scope> I've taken calc
16:47:10 <scope> so you tell me, what is the type of add?
16:47:14 <ski> tenohk : sounds doable
16:47:25 <bollu> scope: add :: (int , int) -> int
16:47:26 <scope> maybe when you say it I'll immediately understand and feel like an idiot
16:47:38 <bollu> scope: takes two integers, returns an integer
16:47:47 <scope> see that's where I'm getting confused
16:47:55 <bollu> OK, tell me
16:47:57 <bollu> what is confusing
16:48:04 <scope> I've been thinking of types as int, double, char etc.
16:48:08 <bollu> scope: yes
16:48:11 <halogenandtoast> those are
16:48:18 <tenohk> im trying to create a sort of Maybe type such that whenever a function returns a Nothing, some IO action is performed
16:48:24 <tenohk> ups sorry 
16:48:28 <erisco> Haskell ups the game and gives us more complicated types
16:48:30 <scope> never thought too much of types of functions, I just know what they take in and return
16:48:31 <bollu> scope: in mathematics, do we not define the domain and codomain of a function?
16:48:45 <halogenandtoast> scope: That is what a function is though
16:48:53 <halogenandtoast> it takes something in, it's "domain"
16:49:01 <halogenandtoast> and returns something, it's "codomain"
16:49:21 <bollu> scope: have you seen the whole f: R -> R or g : C -> C in calculus
16:49:22 <bollu> ?
16:49:38 <scope> man I haven't thought about calc since high school
16:49:43 <Lazersmoke> scope: a function's type *is* what it takes and what it returns (with an arrow in between)
16:49:49 <ph88^> glguy, i mean in the new type i only see 1 arrow, so i don't understand why it needs 3 parameters
16:49:54 <scope> see that's where the confusion came from lazersmoke
16:49:58 <orion> In category theory, if I have two morphisms f and g from any object a --> Bool, f _ = True, g _ = False, are f and g endomorphic, monomorphic, both, or neither?
16:50:18 <scope> that's why every time I was asked "what's the type of this function?" I'm just like, "but it's a function..."
16:50:22 <scope> I never thought of it that way
16:50:28 <bollu> scope: I see
16:50:44 <halogenandtoast> scope: but we need a way to distinguish between what functions take in and return
16:50:53 <halogenandtoast> so we can pass the around
16:50:53 <erisco> I will show you the world... a whole new world!
16:50:57 <scope> I just think of that as parameters and return types lol
16:50:59 <inferno-cop> scope: Haskell is different from C/C++ in that functions are also objects. A function is just another kind of "thing", like double, char etc.
16:51:00 <bollu> orion: doesn't endo only make sense in a monoid?
16:51:16 <halogenandtoast> scope: You need to realize that if you want to turn functions into parameters themselves
16:51:21 <halogenandtoast> their type signature matter
16:51:24 <orion> bollu: No idea. I'm just getting in to category theory.
16:51:26 <halogenandtoast> so you encode the type signature in the type
16:51:44 <scope> so can we go back to the map pointsOfEdge and try to clear that up?
16:52:00 <chaosmasttter> orion: you probably mean epi not endo
16:52:03 <halogenandtoast> a function that is (String -> Int) can not be passed as a parameter to something that wants (Int -> String)
16:52:06 <ski> orion : endomorphic iff `a' is `Bool'. monomorphic iff `a' is a subsingleton
16:52:08 <Lazersmoke> and the idea that functions are just normal "things" is called "first class functions"
16:52:11 <erisco> well I am not sure you've graduated from bollu's school of function types yet
16:52:27 <scope> lol
16:52:33 <erisco> you need to find the a and b such that a -> b is the same as Edge c -> [Point c]
16:52:44 <Lazersmoke> scope: see how "a -> b" matches "(Edge a) -> ([Point a])"?
16:52:50 <bollu> ski: don't endomorphisms need to form a ring?
16:52:52 <scope> yes lazer
16:52:54 <Lazersmoke> like how they have the same "shape"
16:53:04 <Lazersmoke> so what does a and b match with then?
16:53:05 <scope> oh wait
16:53:08 <halogenandtoast> :t map
16:53:09 <ski> bollu : just a monoid
16:53:11 <lambdabot> (a -> b) -> [a] -> [b]
16:53:12 <scope> so the [] is what is throwing it off?
16:53:14 <halogenandtoast> now do replacement
16:53:15 <orion> bollu: What "things" can I apply the label "monoid" to?
16:53:16 <scope> around [point a]
16:53:34 <Lazersmoke> [Something] just means a List of Something
16:53:37 <bollu> orion: have a binary operator, call it (<>), which has an identity element
16:53:38 <erisco> throwing what off? stay on target scope
16:53:41 <inferno-cop> scope: Just as you can have a variable that contains a Double, you can have a variable that contains a (Double -> Int). It just so happens that an object of type (Double -> Int) is a function that you can call with a Double to get an Int
16:53:43 <scope> right, but b isn't [b]
16:53:46 <erisco> or you'll miss the port hole and Darth Vader will win
16:54:00 <ski> Lazersmoke : the type of lists with elements of type `Something'
16:54:09 <orion> bollu: How does the concept of an operator translate in to CT?
16:54:14 <erisco> okay, lets do this step by step even furthe
16:54:15 <erisco> r
16:54:23 <erisco> we can match the -> with the other ->, right?
16:54:23 <Lazersmoke> yeah my bad; what I said only applies to types, not values
16:54:27 <scope> yes
16:54:38 <erisco> so now we have to find the "a" that matches Edge c, what is that?
16:54:44 <orion> bollu: Does it only make sense to talk about "operators" in the categories of Set and Hask?
16:54:54 <scope> Edge? I literally don't understand
16:54:57 <ski> orion : depends on what you mean by "operators" ..
16:55:07 <erisco> okay, the types are   a -> b    and   Edge c -> [Point c]
16:55:16 <orion> ski: bollu used the word "binary operator".
16:55:20 <orion> words
16:55:21 <erisco> "a", "b", and "c" are all type variables, meaning we can substitute *any* type for them
16:55:34 <erisco> we need   a -> b   to look like   Edge c -> [Point c]
16:55:34 <scope> right, so why can't edge c just go where a is?
16:55:43 <halogenandtoast> scope it can
16:55:43 <erisco> yes, that is exactly it lol
16:55:47 <scope> what the fuck
16:55:48 <erisco> a = Edge c
16:55:54 <erisco> now, what is b?
16:55:55 <halogenandtoast> so now you have Edge c -> b
16:55:59 <scope> Point c
16:56:01 <Lazersmoke> :t map
16:56:02 <halogenandtoast> no
16:56:03 <lambdabot> (a -> b) -> [a] -> [b]
16:56:13 <erisco> Edge c -> Point c  doesn't look like   Edge c -> [Point c]
16:56:19 <halogenandtoast> b is not Point c
16:56:20 <scope> [point c]
16:56:20 <erisco> so try a different b
16:56:22 <Lazersmoke> b is "[Point c]", not "Point c"
16:56:25 <bollu> orion: endo-anything means that the domain and codomain are same
16:56:25 <halogenandtoast> yes [Point c]
16:56:31 <bollu> orion: so you can have endo-arrows
16:56:35 <erisco> okay! progress! :)
16:56:36 <bollu> Hom(X, X)
16:56:40 <scope> damn you guys are pickier than a compiler
16:56:42 <scope> hahaha
16:56:50 <bollu> scope: GHC is pickier than  us :)
16:56:51 <erisco> so, a = Edge c and b = [Point c], so what is the type of  map pointsOfEdge ?
16:56:51 <bollu> orion: you can have "endofunctors"
16:56:52 <ski> orion : if you have a category with categorical products, you can consider "multiple argument" morphisms, as morphisms whose domain object is a categorical product of a bunch of objects. like `(+) : Integer * Integer >---> Integer', e.g. .. or `between : Integer * Integer * Integer >---> Bool'
16:56:53 <scope> true that lol
16:57:03 <Welkin> pricklier
16:57:24 <Tuplanolla> Endorsement, bollu?
16:57:30 <bollu> Tuplanolla: :)
16:57:44 <Lazersmoke> scope: http://imgur.com/KZOJEaR
16:57:46 <scope> (Edge c -> [Point c] -> [Edge a] -> [[Point c]]
16:57:51 <halogenandtoast> yes!
16:57:56 <bollu> scope: Ithink you dropped a ")" somewhere
16:57:58 <allenj12> ok, so i looked up some church encoding to make a list. cons :: a -> b -> (Bool, (a, b))
16:57:58 <allenj12> cons h t = (False, (h, t))
16:57:58 <allenj12>  
16:58:00 <scope> happens
16:58:01 <bollu> halogenandtoast: not yet ;) almost there
16:58:07 <erisco> well you missed a paren
16:58:08 <bollu> scope: where should the ")" go?
16:58:08 <halogenandtoast> yeah I missed the dropped )
16:58:14 <Lazersmoke> that's exactly right, scope :D
16:58:15 <ski> orion : in some cases you want to consider another "product" than categorical product, though ..
16:58:21 <allenj12> but how does this type? b should b (bool -> (a,b) but (True,True) contradicts that
16:58:26 <Lazersmoke> well almost
16:58:34 <erisco> and that is not the type of  map pointsOfEdge, but that is on the way
16:58:40 <scope> (Edge c -> [Point c])
16:58:42 <bollu> ski: oh god, the tensoring and day convolution and all that craziness comes into picture now doesn't it? :D
16:58:44 <erisco> what you have is the type of map
16:58:55 <Welkin> lol day convolution
16:59:01 * ski smiles
16:59:07 <halogenandtoast> erisco: it was progress though
16:59:07 <scope> Edge a rather
16:59:09 <Welkin> that always reminds me of Chiat Day, the marketing company that makes the ads for apple
16:59:13 <erisco> so  map :: (Edge c -> [Point c]) -> [Edge a] -> [[Point c]]  and  pointsOfEdge :: Edge c -> [Point c]  and so what is  map pointsOfEdge?
16:59:17 <halogenandtoast> figuring out the next step is hard
16:59:18 <erisco> yes, we're going forward
16:59:19 <bollu> ski: I want to know where day convolution is actually used in math
16:59:28 <halogenandtoast> for some reason or another
16:59:35 <Lazersmoke> scope: map :: (Edge c -> [Point c]) -> [Edge a] -> [[Point c]]
16:59:44 <allenj12> i think i will make an lpaste so its clearer to read
17:00:16 <ski> allenj12 : .. i don't think that would be called a church encoding. and i think you need dependent types, to statically type that
17:00:38 <scope> see this is where you're losing me
17:00:45 <erisco> whoops I meant  map :: (Edge c -> [Point c]) -> [Edge c] -> [[Point c]]
17:00:57 <erisco> well this comes back to bollu's school of function types
17:00:58 <allenj12> ski: im mainly following https://en.wikipedia.org/wiki/Church_encoding and it does work currently
17:01:18 <erisco> we're applying map to the argument pointsOfEdge
17:01:46 <erisco> how many arguments does    map pointsOfEdge   take?
17:01:55 <erisco> that is either a confusing question or an enlightening one
17:01:56 <allenj12> ski: how would i make it church encoding?
17:02:01 <Lazersmoke> scope: what happens when you apply a function with the type "(Edge c -> [Point c]) -> [Edge a] -> [[Point c]]" to an argument with the type "Edge c -> [Point c]"?
17:02:27 <scope> type mismatch?
17:02:49 <scope> I mean one is [Point c] and one is [[Point c]]
17:02:58 <Lazersmoke> scope: what is the type of the first argument of a function with the type "(Edge c -> [Point c]) -> [Edge a] -> [[Point c]]"?
17:03:09 <erisco> okay give me the floor for a second
17:03:16 <scope> Edge
17:03:19 <Welkin> yes, senator
17:03:28 <erisco> lets say   f :: (Edge c -> [Point c]) -> X
17:03:29 * Welkin prepares to watch a filibuster
17:03:37 <erisco> what is the type of   f pointsOfEdge  ?
17:03:42 <halogenandtoast> Welkin: ha, well sometimes too many cooks leads to more confusion, so it was a fair request
17:04:04 <scope> (Edge c -> [Point c])
17:04:40 <ski> allenj12 : `nil = \n c -> n' and `cons h t = \n c -> c h (t n c)'
17:04:54 <erisco> f takes some value with type Edge c -> [Point c] and gives us a value with what type?
17:05:07 <scope> X
17:05:33 <erisco> okay, so  pointsOfEdge is a value with type Edge c -> [Point c], and I give this to f, so what is the type of the value I get?
17:05:50 <okeuday_bak> erisco: Prelude.floor
17:06:14 <scope> X according to your definition
17:06:27 <erisco> yes! and so what is the type of  f pointsOfEdge  ?
17:06:29 <dolio> Cale: Oh, thanks for the link.
17:06:43 <scope> X
17:06:48 <erisco> good
17:06:51 <dolio> I knew about the weighted (co)limit angle but couldn't figure out how to use that.
17:07:02 <erisco> you said it was  Edge c -> [Point c]  first. do you see why that is wrong now?
17:07:19 <scope> so map pointsOfEdge is [Edge a] -> [[Point c]]
17:07:29 * erisco weeps in joy
17:07:33 <scope> lmfao
17:07:45 <allenj12> ski: seems actually equvalest except you define nil instead of having True/False. is that right?
17:07:47 <scope> me too
17:07:52 <allenj12> equivalent*
17:07:54 <erisco> now, it is  [Edge c] -> [[Point c]]  but I think you just copied my earlier typo
17:08:27 <Jinxit> i keep running into circular dependencies between my modules :(
17:08:44 <erisco> okay, so,  map pointsOfEdge  is a function which takes a list of edges (some value of type [Edge c]) and returns a list of list of points (some value of type [[Point c]])
17:08:49 <Welkin> Jinxit: extract the common parts out into another module, then import that
17:08:55 <scope> right
17:09:02 <scope> but convexHullPoints just wants a list
17:09:04 <scope> not a list of lists
17:09:27 <erisco> good, you're right! that is why we want to know the types
17:09:30 <halogenandtoast> so you'd need something that has type [[a]] -> [a]
17:09:38 <Jinxit> it feels weird to have a module that's "this and this and that just because it's a cycle" when there would be no problem if they were all declared in the same file
17:09:40 <erisco> we can see those don't match and can now figure out how to get a list from a list of lists
17:09:55 <erisco> there is a function called "concat" which does precisely this
17:09:56 <erisco> :t concat
17:09:59 <lambdabot> Foldable t => t [a] -> [a]
17:10:03 <erisco> damn...
17:10:04 <halogenandtoast> lol
17:10:06 <scope> lol
17:10:07 <Welkin> Jinxit: it's common to have a `Common` module
17:10:11 <ski> allenj12 : i didn't exactly follow what you meant by `(True,True)'. i was assuming you had something like `nil = (True,())' or `nil = (True,(True,True))' in mind
17:10:12 <erisco> okay,  concat :: [[a]] -> [a]
17:10:32 <scope> ok, so concat(map pointsOfEdge (convexHullEdges(points)))
17:10:39 <erisco> bang on
17:11:01 <Welkin> bang on?
17:11:03 <erisco> now, conventionally we'd write this  concat (map pointsOfEdge (convexHullEdges points))
17:11:03 <Jinxit> and there's no ghc extension or anything to resolve this? (except hs-boot)
17:11:15 <scope> alright so that compiles but I still have double values
17:11:15 <halogenandtoast> Welkin: UK colloquialism probably
17:11:22 <ski> @src concatMap
17:11:23 <lambdabot> concatMap f = foldr ((++) . f) []
17:11:27 <Welkin> erisco is a canoodle though D:<
17:11:27 <erisco> well, we'd write it differently  using function composition, but if we used parens we'd write it like that
17:11:38 <ski> .. or just `concatMap f xs = concat (map f xs)'
17:11:54 <erisco> ski,  yes yes ski, I just like to start with concat and map and mention concatMap as a "by the way"
17:11:55 <allenj12> ski: anything with True in fst position on the tuple is actually considered Nil here, but that does kind lead to my original question. Also i realized something happened when i tried to paste the original question, im currently making an lpaste, one sec
17:12:03 <scope> so, you said nub removes duplicates?
17:12:05 <ski> erisco : of course :)
17:12:08 <halogenandtoast> I would have waited
17:12:20 <halogenandtoast> let the current situation settle in
17:12:30 <erisco> scope, yup, try it in ghci
17:12:49 <scope> so is it just nub(everything from above)
17:12:50 <scope> ?
17:12:55 <erisco> yes
17:13:12 <scope> holy shit
17:13:20 <erisco> you earlier also had another keen observation, another way to remove the duplicates
17:13:31 <Welkin> nub and nubBy
17:13:35 <scope> what was that? I don't remember
17:13:41 <erisco> and that observation was that the edges are chained, so the end of one edge is the beginning of another
17:13:50 <bollu> scope: be warned, nub is O(n^2)
17:13:52 <Welkin> there is also a version of nub that edwardk wrote (using radix trees?) that runs in linear time
17:14:16 <erisco> so instead of pointsOfEdge, which gives us both points, we can just use fst to take the first point
17:14:19 <lpaste_> allenj12 pasted “How does cons type check?” at http://lpaste.net/353658
17:14:28 <erisco> because the second point will be the first point of another edge anyways
17:14:34 <allenj12> ski: that should clear things up slighlty
17:14:36 <scope> jesus, well thank you guys for bearing with me
17:14:37 <Welkin> erisco: triangle fan :D
17:14:45 <scope> I know you guys must have been smacking your face on your desk
17:14:55 <erisco> that is a more efficient solution
17:15:16 <erisco> I only went away from that because it relies on a careful observation about how the list of edges are constructed
17:15:21 <halogenandtoast> scope: some people just want to teach others, if they do they're used to this and neither upset nor "smacking our faces on our desks"
17:15:22 <bollu> scope: teaching is fun
17:15:26 <bollu> ^
17:15:30 <Welkin> does anyone remember where that linear-time nub was (which library)?
17:15:32 <scope> ah gotcha, honestly I'm just glad this is working now
17:15:43 <scope> this program isn't working with huge lists so nub is fine
17:16:18 <scope> now, erisco, if you're up for it my closestPair function is still broken
17:16:24 <scope> the one we were talking about minimumBy with
17:16:31 <bollu> scope: closestPair does what?
17:16:35 <scope> one sec
17:16:38 <scope> I'll post the code
17:16:40 <erisco> we can also write this as a list comprehension if you want to see the similarity
17:17:06 <scope> http://lpaste.net/3953644544179830784
17:17:39 <scope> so there's the context. closestPair takes a set of points and finds the closest pair of points coordinate-wise
17:17:49 <erisco> ah that one again, okay
17:17:54 <scope> I wanted to use minimumBy, but I don't quite understand it
17:18:05 <halogenandtoast> :t minimumBy
17:18:06 <ski> allenj12 : each use of `cons' may have different actual types used in place of the type variables `a' and `b'
17:18:07 <lambdabot> Foldable t => (a -> a -> Ordering) -> t a -> a
17:18:13 <erisco> well minimumBy doesn't make use of closerPair which is why we didn't use it
17:18:20 <scope> ah ok
17:18:25 <halogenandtoast> so minimumBy :: (a -> a -> Ordering) -> [a] -> a
17:18:33 <erisco> we need something like it but not quite
17:18:33 <scope> well forget about minimumBy then
17:18:34 <allenj12> ski: is that possible since its recursive? should b be set all the way down?
17:18:43 <erisco> okay, well the other way was a fold, which does use closerPair
17:18:54 <scope> I'm all ears
17:18:56 <ski> allenj12 : "since its recursive" -- since what is recursive ?
17:19:03 <erisco> you may be surprised to know that the recursive function you wrote earlier is also just  foldr1 closerPair
17:19:03 <Welkin> found it http://hackage.haskell.org/package/discrimination-0.2.1/docs/Data-Discrimination.html#v:nub
17:19:06 <Welkin> :D
17:19:11 <erisco> try that one out
17:19:22 <scope> wait what???
17:19:32 <bollu> :t foldr1
17:19:35 <lambdabot> Foldable t => (a -> a -> a) -> t a -> a
17:19:40 <bollu> *sigh
17:19:48 <bollu> :t foldr1 :: (a -> a -> a) -> [a] -> a
17:19:50 <scope> lol
17:19:51 <lambdabot> (a -> a -> a) -> [a] -> a
17:20:04 <bollu> foldr1 (+) [1..10]
17:20:05 <Welkin> :t Data.List.foldr1
17:20:07 <lambdabot> Foldable t => (a -> a -> a) -> t a -> a
17:20:10 <Welkin> lol
17:20:13 <bollu> > :t Data.List.foldr1
17:20:16 <lambdabot>  <hint>:1:1: error: parse error on input ‘:’
17:20:20 <allenj12> ski: the type signature could you not unstack it so. a -> b (Bool, (a,(a -> b -> (Bool, (a...)))))
17:20:20 <scope> looool
17:20:24 <bollu> > foldr1 (+) [1..10]
17:20:33 <allenj12> would all the bs have to be the same in this case?
17:20:35 <bollu> scope: they're just general version of the idea
17:20:35 <lambdabot>  mueval: ExitFailure 1
17:20:39 <erisco> I can explain a fold to you really quickly, but there is much to be said about them
17:20:51 <erisco> and I'm only talking about list fold
17:20:59 <scope> if that's what you think is the simplest solution then sure
17:21:03 <erisco> > foldr f z [a,b,c]
17:21:05 <hexagoxel> :t GHC.OldList.foldr1
17:21:05 <ski> allenj12 : if you want to, you could say `bogusList = cons 2 (Maybe "not a list")', where `bogusList' gets type `(Bool,(Integer,Maybe String))'. here `a' becomes `Integer' and `b' becomes `Maybe String'
17:21:15 <lambdabot>  mueval-core: Time limit exceeded
17:21:16 <lambdabot>  mueval: ExitFailure 1
17:21:16 <lambdabot> (a -> a -> a) -> [a] -> a
17:21:26 <scope> jesus lambdabot
17:21:36 <erisco> it should have said:  f a (f b (f c z))
17:21:39 <bollu> int-e: ping
17:21:47 <ski> allenj12 : btw, looking at <https://aphyr.com/posts/340-acing-the-technical-interview>, i should say that that post is not doing what you sketched above
17:21:55 <Welkin> > foldl1 (+) [1..10000]
17:21:57 <Jinxit> Welkin: is a Common module really the most common (heh) solution? i lose any semblance of code structure and just get one big file
17:21:59 <lambdabot>  50005000
17:22:03 <Welkin> > foldl1 (+) [1..1000000]
17:22:06 <scope> so when you say "foldr1 closerPair" that can't be all that it takes?
17:22:08 <lambdabot>  *Exception: stack overflow
17:22:09 <Welkin> > foldl1' (+) [1..1000000]
17:22:12 <lambdabot>  500000500000
17:22:13 <Welkin> :D
17:22:15 <erisco> yes that is the whole thing scope
17:22:22 <scope> well that throws up errors
17:22:26 <allenj12> ski: i know but you cant really do what there doing in that post since its untyped, i have kinda been going on a different path since
17:22:26 <ski> allenj12 : "would all the bs have to be the same in this case?" -- the answer to the question you intended to ask is : no, they don't
17:22:39 <ski> allenj12 : however, `a -> b (Bool, (a,(a -> b -> (Bool, (a...)))))' doesn't make sense in this context
17:22:44 <erisco> scope, that is for closestPair' which we wrote earlier, not closestPair
17:23:05 <scope> ohhh, to be honest I didn't actually write the code for that, I was just trying to understand it
17:23:13 <Welkin> Jinxit: well, a Common module is used in Yesod to import other modules and re-export them
17:23:14 <erisco> scope, for closestPair we'd write  foldr1 closerPair . pairsFromPoints
17:23:34 <Welkin> Jinxit: Ideally you would structure your code in such a way that you don't have circular dependencies
17:23:38 <scope> foldr1 closerPair . pairsFromPoints(points) right erisco?
17:23:41 <Welkin> put functions that rely on each other together
17:23:42 <Jinxit> Welkin: that sounds fine to me, that's more for user convenience
17:23:43 <erisco> no
17:23:46 <Jinxit> well
17:23:49 <erisco> you omit the argument on the left of =
17:23:55 <Jinxit> it's types that rely on eachother
17:23:55 <erisco> or the parameter, rather
17:23:55 <ydl>  k
17:24:03 <Welkin> Jinxit: I see
17:24:08 <scope> erisco what do you mean?
17:24:15 <halogenandtoast> erisco: maybe that's a little complex
17:24:17 <allenj12> ski: interesting, i just thought the type of b was set from the first cons because in every instance of cons it has the type of the next 'b' defined to be the same as the original
17:24:19 <scope> ohhh nevermind I see
17:24:20 <erisco> so  closestPair = foldr1 closerPair . pairsFromPoints
17:24:20 <Welkin> there is also another common way to structure your code by putting all of your types in a Types.hs module
17:24:25 <scope> it automatically sends it?
17:24:27 <Welkin> I have used this before and it is helpful
17:24:30 <Jinxit> that's what i have
17:24:31 <ski> allenj12 : `(Bool,(a0,(Bool,(a1,..(Bool,(a_{n-1},(Bool,Bool)))..))))' would make more sense ..
17:24:39 <erisco> yes this involves some things we haven't talked about but that is how a Haskeller would actually write it
17:24:52 <erisco> since we're just on a hypothetical of "what if we used a fold"
17:24:53 <scope> still get errors that way as well
17:24:55 <ski> allenj12 : each use of `cons' gets its own "copy" of `b' (and `a')
17:25:02 <erisco> hm, pastebin it for me scope
17:25:07 <erisco> as well as the error
17:25:09 <Welkin> erisco: lpaste you mean!
17:25:12 <Jinxit> Welkin: but it turns out i need this one thing in that file to solve a circular dependency
17:25:13 <Welkin> @lpaste
17:25:13 <lambdabot> Haskell pastebin: http://lpaste.net/
17:25:18 <Jinxit> and boom, it drags in everything
17:25:21 <Jinxit> in a cascade
17:25:26 <erisco> yes of course, I am just devaluing the pastebin brand by using it as a verb
17:25:27 <scope> http://lpaste.net/8545957051761688576
17:25:28 <allenj12> ski:  ah, a little bit confusing but makes sense
17:25:31 <erisco> you should thank me
17:25:31 <Welkin> Jinxit: post an example
17:25:38 <Welkin> Jinxit: is it on github?
17:25:50 <allenj12> ski: your type signature does make more sense aswell :D i was getting confused haha
17:25:52 <Jinxit> Welkin: will be in a bit, just gotta fix some compiler errors
17:25:57 <ski> allenj12 : there's no problem with `cons 2 (cons False (cons "help !" (putStr "This is not an action")))'
17:26:14 <halogenandtoast> scope: you have to drop the argument on the left as well
17:26:31 <scope> oh see I can't remove that
17:26:40 <erisco> yes you can
17:26:41 <halogenandtoast> why?
17:26:51 <ski> allenj12 : still, if you want to be able to process the elements of such a "list", one after another, in some uniform fashion (what's known as a "loop"), then this is not a good representation of lists
17:26:51 <scope> not allowed to change the stubs
17:27:09 <Welkin> scope: what is this? a homework assignment?
17:27:17 <scope> something like that
17:27:18 <halogenandtoast> Welkin: wasn't that obvious?
17:27:19 <ski> allenj12 : better would be the `nil = \n c -> n' and `cons h t = \n c -> c h (t n c)' i mentioned
17:27:20 <Welkin> o.o
17:27:22 <erisco> okay, well, you are not submitting this anyways because you don't understand foldr1 and . and so on well enough
17:27:27 <erisco> you're submitting your recursive version
17:27:40 <erisco> I am just showing you how else it would be written if it was someone experienced
17:27:44 <erisco> gives you something to consider
17:27:49 <scope> right, I wanted to check it out
17:28:00 <Welkin> erisco: lol, did you show them the "evolution of a haskell programmer" page yet?
17:28:02 <halogenandtoast> scope: so drop the parameter on the left and try it out
17:28:12 <allenj12> ski: i see, say you wanted to make sure all 'a's are the same type? how would you enforce that since the type signature does not carry down
17:28:16 <Welkin> http://www.willamette.edu/~fruehr/haskell/evolution.html
17:28:17 <Welkin> :P
17:28:18 <erisco> the one that ends in  fac n = product [1..n]  Welkin?
17:28:19 <scope> well yeah that works
17:28:21 <scope> that's amazing
17:28:52 <erisco> so, my quick view of folds is  foldr f z [a,b,c]  is   f a (f b (f c z))
17:28:53 <bollu> Welkin: I can understand till "post doc" IIRC. I was quite proud when I grokked over half of it
17:29:06 <scope> erisco would you mind going over how to solve this recursively again?
17:29:10 <bollu> :t foldr
17:29:12 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
17:29:13 <erisco> you can extrapolate the pattern for any list. I will also tell you  foldr f z [] = z
17:29:19 <ski> allenj12 : you would enforce that by not using this list representation
17:29:27 <scope> this is the only other function that has been giving me trouble
17:29:49 <Welkin> scope: throw them a curve ball and use Data.Sequence.Seq instead of lists
17:29:53 <ski> allenj12 : this is exactly the kind of issue i was having in mind
17:29:53 <erisco> if you understand foldr then foldr1 is similar
17:30:10 <Jinxit> Welkin: http://lpaste.net/4504528366803615744
17:30:11 <erisco> scope, yes sure, we can do that
17:30:15 <scope> ty
17:30:29 <allenj12> ski: I havent tested your version yet, but im assuming your saying I have to use an ADT if i do want that
17:30:45 <ski> allenj12 : no, i'm not saying that
17:30:47 <scope> need to piss really quick though, tag me in your next message so I can find it easily
17:31:16 <allenj12> ski: gotcha, i need to play around with your version for a second. does your keep type?
17:31:19 <halogenandtoast> I'm out, time to get ready for the day, can't lie in bed and irc all day...
17:31:21 <Welkin> Jinxit: where is the circular dependency?
17:31:31 <erisco> scope, is there somewhere you want to start particularly? something confusing?
17:31:58 <ski> allenj12 : you need extensions to be able to state the type of my `cons', though
17:32:24 <Jinxit> Welkin: first off several of the types go in a circle, but i'm kindof ok with having them in a giant file (but it's not optimal), second is from line 200 onwards
17:33:02 <Jinxit> Welkin: when i moved in Trigger because it needed Game which needs Character which needs Trigger
17:33:08 <ski> allenj12 : `cons :: a -> (forall o. o -> (a -> o -> o) -> o) -> (forall o. o -> (a -> o -> o) -> o)', namely .. (you can avoid mentioning the latter `forall o.', but not the former one)
17:33:08 <allenj12> ski: λ> :t cons
17:33:08 <allenj12> cons
17:33:08 <allenj12>   :: t3
17:33:08 <allenj12>      -> (t2 -> (t3 -> t1 -> t) -> t1) -> t2 -> (t3 -> t1 -> t) -> t :D
17:33:16 <ski> wrong type
17:35:51 <Jinxit> Welkin: and on top of that the unsolved error because Types requires Database requires Game requires Types
17:36:00 <allenj12> ski: the types are confusing me a little bit, how would you get the head in your version?
17:36:21 <Welkin> Jinxit: why are all of these extra things in your Types modules?
17:36:34 <Welkin> did you pull them in to try to get rid of the errors?
17:36:38 <Jinxit> correct
17:36:47 <Jinxit> it was only types before
17:36:55 <Jinxit> so the name stuck
17:36:57 <scope> erisco sorry about that, roommate started a conversation with me
17:37:09 <Welkin> could you link me to a commit where it was the way it should normally be? I can build locally and see what I can do
17:37:10 <scope> I honestly just don't even know how to start
17:37:44 <erisco> have you written a recursive function before?
17:37:54 <scope> In other languages, and once in haskell
17:38:04 <erisco> okay, explain to me what a recursive function is
17:38:06 <scope> but it was with a parameter that could be incremented
17:38:10 <erisco> lets make sure we know the basics
17:38:16 <Jinxit> i don't have a commit for that stage, but the moved things (past line 200 in Types) are all annotated with where they came from
17:38:24 <Welkin> okay
17:39:07 <hsk3> multThree :: Int -> Int -> Int -> Int
17:39:07 <hsk3> multThree x y z = x * y * z
17:39:09 <hsk3> What happens when we compute multThree 1 2 3 ? Does a thunk of 1 and 2 and 3 first build up in memory and then the result is computed?
17:39:22 <Jinxit> i appreciate that you're taking a look btw :)
17:39:32 <scope> erisco ok
17:40:11 <jle`> hsk3: you can't really ask 'what happens when we compute multThree 1 2 3' in a vacuum
17:40:18 <jle`> hsk3: do you mean, what happens when we print the result of multThree 1 2 3 ?
17:40:21 <scope> erisco this was the function I solved recursively in Haskell http://lpaste.net/5997182596272881664
17:40:26 <scope> from a previous project
17:40:30 <hsk3> jle` yeah
17:40:55 <erisco> okay cool, and what makes it recursive? that is what I am asking
17:41:05 <scope> the fact that it calls itself
17:41:17 <hsk3> jle` i'm guessing the memory buildup because (multThree 1) returns a new func, etc.
17:41:17 <scope> and then increments the parameter each time
17:41:27 <erisco> well just your first description suffices
17:41:28 <ski> allenj12 : `maybeHead l = l Nothing (\x _ -> Just x)'
17:41:39 <jle`> hsk3: calls like that are usually optimized away by ghc
17:41:41 <erisco> a recursive definition is one which refers to itself
17:41:48 <erisco> so recursive functions are ones which refer to themselves
17:41:52 <scope> right
17:42:02 <scope> you're right the parameter incrementation doesn't matter
17:42:10 <ski> allenj12 : or `head l = l (error "empty list") (\x _ -> x)', if you want a partial one
17:42:15 <erisco> now, in practical application there is a usual way recursive functions look
17:42:24 <hsk3> jle` is it good practice to assume such optimizations?
17:42:47 <erisco> there are one or more base cases, or stopping conditions, and one or more recursive cases
17:43:01 <erisco> in nextPrime, what is the base case?
17:43:06 <jle`> usually no, but in this case, it's pretty straightforward i think
17:43:10 <scope> the else statement
17:43:28 <scope> whoops
17:43:37 <scope> nevermind, it's if the number is prime
17:43:47 <scope> so what comes after the then
17:43:55 <erisco> right, the terminology is a little ambiguous here, so I'd say it altogether
17:44:01 <jle`> hsk3: the partially applied functions won't be built up, but depending on the specific Num instance, (x * y) * z might build up and collapse thunks
17:44:13 <erisco> the base case is n + 1 when isPrime (n + 1)
17:44:17 <jle`> it might be optimized away for Ints though
17:44:21 <scope> right
17:44:44 <erisco> and the recursive case is  nextPrime (n + 1)  when not isPrime (n + 1)
17:45:08 <hsk3> jle` won't it be x*(y*z) ?
17:45:17 <erisco> most recursive functions are going to look just like this
17:45:24 <hsk3> 1*(2*(3))
17:45:33 <erisco> so when we go to write one we're asking what are the base cases and what are the recursive cases
17:45:42 <jle`>  :i (*)   => infixl 7 *
17:45:48 <scope> so the base case for closestPair would be if that pair is the closest, but I'm having trouble figuring out how you'd know without going through the entire list
17:46:29 <scope> as the pairs aren't in any order
17:46:30 <erisco> ah, well, I think you're halfway
17:46:38 <erisco> there is a list where the minimum is obvious
17:46:47 <erisco> which list is that?
17:46:58 <scope> closerPair
17:47:07 <erisco> closerPair is a function, not a list
17:47:09 <hsk3> jle` Okay. So without the optimization, multThree 1 would give (1 * y) * z. Applying that to 2 would give (1 * 2) * z. Applying that to 3 would give (1 * 2) * 3.
17:47:18 <erisco> I'm asking in what list can we trivially know the minimum element?
17:47:25 <scope> an ordered list
17:47:41 <erisco> that is a good answer, since it would always be the first (or last) element
17:47:51 <erisco> however, we do not have an ordered list, so think of something else
17:47:56 <jle`> hsk3: multThree 1 is semantically \y z -> (1*y)+z
17:47:59 <erisco> remember we're looking for base cases
17:48:09 <erisco> and common with base cases is they are trivial
17:48:11 <jle`> and (multThree 1) 2 is \z -> (1*2)*z
17:48:20 <erisco> so when we think "what is the base case" we are thinking "what is the trivial case"
17:48:30 <scope> when there is only one element in the list
17:48:34 <erisco> bingo
17:49:06 <erisco> so, closestPair' [x] = x, you remember that?
17:49:17 <scope> so, discard whichever pair isn't the closer from closerPair?
17:49:20 <scope> and yes
17:49:34 <erisco> well we don't need closerPair at all when there is just one element in the list
17:49:41 <scope> right, was thinking ahead
17:50:23 <scope> so, closestPair' isn't a separate function is it?
17:50:33 <erisco> yes
17:50:40 <erisco> oh, it is a separate function
17:51:01 <erisco> because I gave it type [Pair a] -> Pair a
17:51:16 <scope> ah ok
17:51:16 <scope> I see
17:51:22 <erisco> we're interested in recursing on the list of pairs, so that is what we need
17:51:31 <erisco> we can use this function to define closestPair
17:51:45 <erisco> closestPair just needs to use pairsFromPoints and pass that to closestPair'
17:52:15 <erisco> feel free to give it a better name
17:52:36 <scope> so like this
17:52:40 <erisco> and yes, after the base case we think about the recursive case
17:52:50 <scope> lpaste being slow
17:53:07 <erisco> we have covered a list of just one element, so to cover all (nonempty) lists we also need to cover lists of two or more elements
17:53:22 <scope> http://lpaste.net/5060198668485787648
17:53:35 <scope> so would I need an if then else under closestPair?
17:53:36 <allenj12> ski: im still playing with your version and trying to figure it out. but I think im slowly getting it, thanks
17:53:37 <erisco> when we have a list of two or more elements we can use closerPair to reduce one element from the list
17:54:07 <erisco> no, no if/then/else needed
17:54:12 <scope> hm
17:54:13 <scope> ok
17:54:22 <erisco> also you want  closestPair points = closestPair' (pairsFromPoints points)
17:54:53 <scope> ok
17:54:57 <erisco> function application associates to the left, so what you wrote is  (closestPair' pairsFromPoints) points
17:55:03 <scope> right, understood
17:55:27 <erisco> I think you're unlearning the call syntax from other languages
17:55:34 <scope> yeah it's killing me
17:55:35 <scope> lol
17:56:01 <erisco> the funny thing is you will see  f(x,y)  in Haskell and this sort of is what you'd expect
17:56:19 <scope> right lol that did throw me off for a bit
17:56:23 <bollu> > (+ 1) $ 2
17:56:24 <erisco> but the key is  (x, y) is a tuple and we're passing it to f
17:56:27 <lambdabot>  3
17:56:28 <scope> exactly
17:56:58 <erisco> so if you like, other languages are just the same, only they force you to use tuples ;)
17:57:26 <erisco> though you can curry in other languages
17:57:30 <scope> so now, why wouldn't I need the if then else to determine whether points is only one element?
17:57:43 <erisco> ah, well this is the power of pattern matching
17:57:51 <erisco> [x] is a pattern that only matches a list with one element
17:57:59 <erisco> (x:[]) is an equivalent pattern
17:58:40 <erisco> something else to learn... in other languages you branch on Bool
17:58:55 <erisco> in Haskell you branch on any sum type
17:59:01 <erisco> so Bool is a sum of True and False
17:59:07 <erisco> List is a sum of [] and :
17:59:28 <erisco> Haskell isn't the only language with this, that's a bit of hyperbole
18:00:15 <scope> so, how does closestPair determine whether to use closerPair? sorry if I'm not understanding
18:00:40 <erisco> we're going to add another case, the case  closestPair' (p1:p2:ps) = ?
18:00:48 <erisco> this is the case of "a list with two or more elements"
18:01:07 <scope> wait so closestPair' (pairsFromPoints points) is a case?
18:01:17 <erisco> no
18:01:47 <scope> so this is an entirely new function then
18:01:52 <erisco> no
18:02:07 <erisco> anyone know the official terminology? function segment? I forget
18:03:26 <scope> so this will go right under the pairsFromPoints points one, I moved the first case to a new line
18:03:30 <flobberlet> erisco: function clause?
18:03:33 <bollu> erisco: terminology for?
18:03:39 <erisco> right, a clause, thank-you
18:03:57 <erisco> so in Haskell we can define functions as multiple clauses
18:04:09 <erisco> you don't do this in other languages like C and Python and so forth
18:04:39 <erisco> so let me show you another popular example: http://lpaste.net/353659
18:05:04 <scope> ah
18:05:07 <erisco> flobberlet, does the clause refer just to the parameter patterns or to the whole thing?
18:05:34 <ski> erisco : i say "defining equation"
18:05:43 <scope> so just to be clear, this should be looking something like this? http://lpaste.net/109962978232631296
18:05:59 <Welkin> are you trying to emulate obama?
18:06:00 <erisco> ski, as in "e is the defining equation of the clause c"?
18:06:03 <Welkin> "Let me be clear"
18:06:13 <scope> no watch this drive
18:06:15 <scope> now*
18:06:17 <ski> erisco : the whole thing, not just the parameter patterns
18:06:49 <erisco> ski, so you'd say a function may be defined with many equations?
18:07:04 <ski> erisco :  closestPair' (p1:p2:ps) = ..p1..p2..ps..  is a definition equation, aka clause of a function definition
18:07:06 <erisco> I am sure there is something in the report but I can't find it atm
18:07:09 <ski> erisco : yes
18:07:23 <ski> s/definition equation/defining equation/
18:07:58 <erisco> scope, no we're quite far off here :P
18:08:05 <scope> hahaha I was trying
18:08:26 <erisco> scope, I added an annotation for you
18:08:58 <erisco> lines 6, 7, and 8 are all talking about the same function closestPair'
18:09:28 <Welkin> Jinxit: I don't see a Trigger.hs or a Character.hs
18:09:33 <erisco> line 6 declares the type, line 7 is a clause (or defining equation) and line 8 is a clause
18:10:03 <Jinxit> Welkin: oh right, deleted them when they turned out empty
18:10:06 <scope> are you about to paste something or are we talking about my last lpaste link?
18:10:08 <Jinxit> check the master branch
18:10:11 <Jinxit> still has them
18:10:33 <Jinxit> (to some extent, since they were also changed)
18:10:38 <erisco> so, when we give closestPair' a list with exactly one element it uses line 7, and with two or more elements line 8, and with no elements a secret line that crashes our program
18:10:52 <allenj12> ski: ok i actually cant figure out how to get the tail :(
18:11:21 <scope> erisco are you talking about a different paste than mine?
18:11:22 <erisco> scope, lpaste lets anyone annotate a paste, so I have added an annotation under your paste
18:11:26 <allenj12> guess im confused what n and c are really suppose to be conceptually
18:11:26 <scope> oh shit
18:11:34 <scope> I didn't realize
18:11:42 <erisco> surprise :)
18:12:02 <erisco> so take a look at that and go back over what I said about it
18:12:22 <scope> OK I see
18:12:37 <scope> like polymorphism in a sense I guess?
18:12:51 <erisco> mm no, not really related
18:12:55 <bollu> > let fibs = 1:2:zipWith (+) fibs (tail fibs) in take 10 fibs
18:12:58 <lambdabot>  [1,2,3,5,8,13,21,34,55,89]
18:13:02 <scope> maybe I'm thinking of a different term
18:13:14 <scope> I mean it chooses the correct function based on what it's passed
18:13:24 <erisco> so what might you do in another language?  if is_empty xs then ... else if has_two_elements xs then ... else ...
18:13:33 <scope> right
18:13:35 <bollu> scope: I expected you to be impressed at the fiboncci thing :(
18:13:43 <scope> wait what bollu?
18:13:49 <erisco> well, we don't have to do that in Haskell, and in fact it is a waste of effort
18:13:50 <scope> Oh
18:13:56 <scope> I thought you were talking to someone else
18:14:04 <erisco> in Haskell we can branch on more than just Bool
18:14:14 <erisco> so we don't have to come up with a Bool, i.e. we don't have to use if/then/else
18:14:18 <bollu> erisco: oh nvm I thought you were showing him cute uses of higher order funtions
18:14:22 <bollu> scope: let's do this later
18:14:51 <scope> ha as soon as I'm finished with this function I'm going to the store any buying alcohol and enjoying my Friday night as much as I can
18:14:54 <erisco> we can just branch directly on a list
18:15:13 <scope> gotcha erisco
18:15:57 <scope> so erisco, line 8 will call closerPair?
18:16:08 <erisco> yes, line 8 will need closerPair
18:17:21 <Welkin> Jinxit: I still can't seem to get any circular dependency errors, although it won't compile anyway because of other errors
18:17:21 <scope> now would it be passing (p1:p2:ps) or what? I'm a bit confused as to how it will go through the list of pairs
18:17:32 <Welkin> Jinxit: is there a way you could give me the exact code that is causing the problem?
18:17:41 <scope> tails ps maybe?
18:17:52 <erisco> yes, well, this takes some practice
18:18:06 <Jinxit> Welkin: gimme a mo
18:18:47 <erisco> what we want to do is do the smallest possible thing to make the problem smaller
18:18:58 <erisco> why? because if we know how to do that we can repeatedly apply the technique
18:19:04 <scope> right
18:19:05 <erisco> until the problem is so small it becomes trivial, i.e. our base case
18:19:08 <scope> recursion and all that
18:19:21 <erisco> so how do we make the problem smaller if our problem is on a list?
18:19:34 <erisco> well we have to make the list smaller
18:19:35 <scope> but if control passes to closerPair, how do we get back to closestPair etc.
18:20:03 <scope> nevermind dumb question, my guess is we'd use tails
18:20:07 <erisco> that isn't really the way you want to think about Haskell programs
18:20:16 <scope> yeah I realized after I said that
18:20:32 <erisco> we just write expressions and they evaluate
18:20:38 <erisco> control doesn't pass around
18:20:41 <scope> right
18:21:11 <erisco> if we talk specifically about *evaluation order* then we can identity when we're evaluating the closerPair part of the expression
18:21:21 <erisco> and when we finish doing so
18:21:34 <erisco> but we're not usually worried about it
18:21:54 <erisco> that comes up when your program mysteriously does nothing or takes up all your memory, or something
18:21:57 <Jinxit> Welkin: https://github.com/Jinxit/firestone/tree/temp
18:22:13 <Jinxit> might have some more compiler errors once that circular dependency goes away, not sure
18:22:25 <scope> ok, so closestPair' (p1:p2:ps) needs to call closerPair, but it also needs to call itself I'm guessing?
18:22:37 <Jinxit> but now it's Character -> Trigger -> Script -> Game -> Character
18:22:39 <erisco> yes, otherwise we haven't a recursive function, by definition
18:22:56 <erisco> so first just think, how do we make the list p1:p2:ps smaller?
18:23:08 <scope> tails ps
18:23:09 <erisco> to make it smaller we have to get rid of an element, so which one do we get rid of? how do we tell?
18:23:15 <scope> oh
18:23:21 <scope> true we can't just get rid of anything
18:23:33 <scope> well we'd have to compare p1 and p2
18:23:38 <erisco> right, if we throw out any ol' pair it could be the one we actually want to keep
18:23:41 <scope> and decide which one is the further distance, and drop it
18:23:48 <erisco> right, great!
18:24:56 <scope> so there must be a list function that deletes based on a requirement
18:25:02 <Jinxit> Welkin: hold on i'm dumb and forgot to commit
18:25:07 <erisco> yes, but no need here
18:25:23 <scope> hm
18:25:37 <Jinxit> Welkin: there we go
18:25:40 <erisco> so we're comparing p1 and p2 and we're going to end up with just one of them
18:25:48 <scope> right
18:26:05 <erisco> the name of this pair is  closerPair p1 p2
18:26:14 <halogenandtoast> If I have `newtype NhkDateGrouping = NhkDateGrouping (Map String [NhkArticle])` is there a way to make this pointfree: importDateGrouping (NhkDateGrouping m) = (importNhkArticles . concat . elems) m
18:26:15 <erisco> then there is the rest of the list, ps
18:26:34 <erisco> but we've already made the list smaller by removing one of p1 and p2, so we don't need to touch ps
18:27:08 <scope> right, but how do we drop the larger one?
18:27:20 <scope> from the list that is
18:27:26 <erisco> we're going to construct a new list that doesn't include it
18:27:40 <scope> ah, of only the smallest distance from each pair?
18:27:47 <geekosaur> halogenandtoast, no, but if you use record syntax in the newtype then you can
18:27:57 <erisco> we're going to construct a new list from ps and the smaller of p1 and p2
18:28:10 <halogenandtoast> geekosaur: right silly me
18:28:54 <allenj12> syntax for lamda function with no arguments?
18:29:25 <erisco> allenj12, but that defies what a lambda is
18:29:28 <geekosaur> allenj, there isn't one because it's a somewhat dubious concept. if you really need one, you generally pass unit
18:29:39 <geekosaur> but, what are you trying to do?
18:30:02 <scope> erisco alright, I'm still a bit lost on how the recursion is going to work for this though.
18:30:08 <allenj12> geekosaur: im trying to work out ski's example of a list, im trying to create a tail function but its really confusing me
18:30:11 <halogenandtoast> geekosaur: I absolutely love that I can just switch it to use record syntax and nothing breaks.
18:30:13 <erisco> that's like a cheeseburger with no cheese
18:30:27 <Jinxit> a burger, if you will
18:30:31 <geekosaur> well, I could see someone trying to be pointfree, but the lambda kinda kills that anyway
18:30:53 <allenj12> geekosaur: nil n c = n
18:30:53 <allenj12> cons h t = \n c -> c h (t n c)
18:30:53 <allenj12> maybeHead l = l Nothing (\x _ -> Just x)
18:31:06 <allenj12> and i want to write tail, but its becoming kinda hard
18:31:24 <erisco> scope, okay, shoot, what do you have right now?
18:31:43 <scope> pretty much just up to where that lpaste is
18:32:14 <erisco> okay, well we know up to  closestPair' (p1:p2:ps) = ... closerPair p1 p2 ...   at least, right?
18:32:22 <scope> yes
18:32:32 <scope> it's the recursion that's confusing me, and how the new list will be made
18:32:45 <erisco> now we want to build a new list with the smaller of p1 and p2 (i.e. closerPair p1 p2) and ps
18:32:51 <erisco> which is the same as a new list without the larger
18:32:54 <erisco> what is that?
18:33:30 <scope> whichever one closerPair returns + ps
18:33:43 <erisco> okay, two things
18:33:52 <erisco> the one closerPair return is exactly closerPair p1 p2
18:34:34 <erisco> we could give this a name, we could say  let p_smaller = closerPair p1 p2 in ...
18:34:45 <erisco> or we can just say  closerPair p1 p2
18:34:57 <erisco> in either case, "closerPair p1 p2" *is* the smaller of p1 and p2
18:35:17 <scope> right, now going about using let ... in ...
18:35:27 <scope> where does the recursion come in?
18:35:29 <erisco> well, don't, because I think this is important to realise
18:35:50 <erisco> say we have 1 + 1
18:35:58 <scope> alright, so (p1:p2:ps) = closerPair p1 p2 ...
18:35:58 <erisco> what is this?
18:36:11 <scope> that's a vague question
18:36:34 <erisco> I don't think it is
18:36:44 <erisco> there are a couple ways to answer it
18:36:53 <scope> the addition of two numbers
18:36:57 <erisco> that is one way
18:36:59 <scope> an expression
18:37:08 <erisco> the other is: 1 + 1 is 2!
18:37:19 <erisco> (that is exclamation, not factorial)
18:37:40 <erisco> so, one way to look at what something is is to consider the syntax
18:37:43 <scope> ha, right
18:37:43 <halogenandtoast> A human abstraction of physical state quantified into a made up system in order to pattern match and discuss quantities of objects
18:37:48 <erisco> 1 + 1 is the addition of two numbers
18:37:56 <erisco> that is a syntactical view of 1 + 1
18:37:59 <halogenandtoast> or a monoid
18:38:10 <erisco> another way to look at what something is is to consider the meaning, i.e. semantic
18:38:13 <erisco> 1 + 1 is 2
18:38:23 <erisco> 1 + 1 is 3 - 1
18:38:49 <erisco> well, that last one might set some alarm bells off for people here :P
18:38:56 <halogenandtoast> it did
18:38:58 <scope> 3 - (1)
18:38:59 <erisco> haha
18:39:01 <halogenandtoast> you mean equivalent to
18:39:01 <scope> lol
18:39:11 <erisco> in a practical sense, yes halogenandtoast
18:39:22 <erisco> but we could choose the meaning to be 3 - 1, it would just be a strange choice
18:39:30 <erisco> but I shouldn't confuse like that
18:39:43 <erisco> so let me rephrase it correctly
18:39:57 <erisco> we can say the meaning of 2 is 1 + 1
18:40:04 <erisco> i.e. the way we define what 2 is is that it is 1 + 1
18:40:25 <erisco> this is a one-way thing, we don't say the meaning of 1 + 1 is 2, if we're talking denotational semantics
18:40:40 <erisco> then we can say 2 and 3 - 1 have the same meaning
18:40:41 <scope> so, closestPair' (p1:p2:ps) = closestPair' closerPair p1 p2:ps
18:40:45 <erisco> because they both mean 1 + 1
18:40:59 <scope> is that at least in the ballpark?
18:41:01 <erisco> maybe this is a bit too nuanced for the moment
18:41:38 <scope> well, closestPair' (closerPair p1 p2):ps
18:41:41 <scope> or something like that
18:41:44 <erisco> in any case we can say  closerPair p1 p2  means the lesser of p1 and p2
18:41:53 <scope> yes I get that
18:42:02 <scope> I'm trying to figure out the recursion
18:42:03 <glguy> scope: You probably meant:   closestPair' (closerPair p1 p2 : ps)
18:42:04 <erisco> (or equivalent to, I don't want to split not-so-fine hairs with people)
18:42:10 <scope> yes that glguy
18:43:24 <scope> erisco is that on the right track though?
18:44:59 <erisco> x = y iff μ(x) = μ(y)
18:45:08 <erisco> halogenandtoast, does that satisfy? :P
18:46:06 <Christian> Hello, how are you? 
18:46:16 <erisco> scope, well that looks like the full solution to me
18:46:26 <scope> I can't get it to work lol
18:46:32 <erisco> scope, it is up to where we left off earlier
18:46:36 <erisco> alright, what is going wrong?
18:46:50 <scope> here I'll update the paste
18:47:08 <Christian> Does anyone know how to connect an Irc bot to a weather API? 
18:47:14 <scope> erisco updated
18:47:24 <scope> maybe you can spot something glaring
18:47:28 <glguy> Christian: Sorry, this channel is about the Haskell programming language
18:47:40 <Christian> Ohhhkay 
18:48:12 <erisco> well what is the error scope?
18:48:19 <scope> erisco: error "No instance for (real a) arising from a use of `closerPair`"
18:48:36 <erisco> right, so you need   closestPair' :: Real a => [Pair a] -> Pair a
18:48:49 <scope> telling me to add (Real a) to the context of the type signature for closestPair' :: [Pair a] -> Pair a
18:48:53 <scope> ah
18:48:54 <scope> ok
18:48:56 <erisco> sorry, I omitted the context originally because I thought it was just noisy at the time
18:49:17 <Christian> Ping
18:49:54 <scope> awesome! erisco you're a life saver
18:50:04 <scope> Cale too if he's still around
18:50:16 <erisco> Cale taught me Haskell too
18:50:24 <scope> ha, that's awesome
18:51:04 <erisco> and many others but he was a key contributor to when I was developing an Applicative parser
18:51:04 <scope> well I seem to be passing all of my tests, so I guess I'm out of here for the night. I'm sure I'll see you guys around
18:51:14 <erisco> night
18:51:14 <scope> thanks again erisco
18:51:19 <erisco> glad to help
18:52:30 <erisco> now I've fallen into the deep end and am writing Idris
18:53:11 <erisco> they should have signs that read "BEWARE" when you start learning Haskell
18:53:34 <monochrom> But I'm still writing Haskell.
18:53:44 <erisco> "BEWARE: path of no return"
18:53:46 <monochrom> and pretty sure I started earlier than you did.
18:54:01 <monochrom> So I conclude that it's a function of you, not a function of Haskell.
18:54:03 <geekosaur> "so it's Applicative?"
18:54:46 <erisco> monochrom, well some can control themselves and for others it is a gateway language :P
18:56:26 <erisco> if you go deeper into types it seems like that is how you'd progress, I don't see how you'd stay away from DT forever
18:57:20 <monochrom> No, I think instead #haskell is bad influence on a lot of people.
18:57:35 <glguy> Exposure to DT can help drive you back to not wanting them
18:58:02 <monochrom> I already saw Coq and formed my opinion before I came to #haskell. Probably why I was immune.
18:58:18 <erisco> okay, well I am still on my DT tour, so maybe I'll come around
18:58:32 <monochrom> But I understand that millions of people are vulnerable.
18:58:59 <monochrom> Well both outcomes are possible. Just look at Hongwei Xi.
18:59:02 <erisco> I initially wanted to see things done much differently, and I still do, but I am trying to fill in the blanks by learning
18:59:07 <monochrom> That is, the ATS guy.
18:59:30 <erisco> I think there is a significant traction problem right now
18:59:32 <dolio> ATS will definitely convince you that you don't want anything resembling dependent types.
18:59:51 <monochrom> So exposed to DT, and loving it so much, he made his own Frankenstein's monster.
18:59:53 <erisco> Idris is a step but it won't be the language to break DT in, I don't think, but a critical milestone nonetheless
19:00:37 <erisco> if you're a math head it is one thing... I am speaking from a programmer's perspective
19:00:50 <monochrom> Did you know: He started his career by working on Dependent ML?
19:00:52 <erisco> if you consider the friction with Haskell... well you guys know DT, you know the implications
19:01:25 <erisco> what does ATS stand for?
19:01:34 <monochrom> I forgot.
19:01:41 <dolio> Advanced Type System.
19:01:45 <monochrom> And I think the long name contains no information anyway.
19:01:54 <Welkin> Jinxit: I'm not familiar enough with Lens, but I got to a point where I am getting no more import errors (at least until this other errors is fixed)
19:02:02 <lpaste_> allenj12 pasted “tail of church list?” at http://lpaste.net/353663
19:02:06 <erisco> https://en.wikipedia.org/wiki/ATS_%28programming_language%29 ?
19:02:34 <Welkin> Jinxit: but I am getting this error http://lpaste.net/353664
19:02:35 <monochrom> I use an acronym iff the long name contains no more information than the few letters in the acronym.
19:02:56 <erisco> I will take a look. maybe it speaks more to my ideals
19:03:06 <erisco> but I am still working out why DT upsets me
19:03:10 <monochrom> For example you look at my recent http://www.vex.net/~trebla/haskell/cont.xhtml and it doesn't even say "CPS" once. Because "continuation-passing style" actually helps.
19:03:10 <Welkin> Jinxit: why were you importing Game into Script? I don't see anything obvious that would require that import
19:03:11 <erisco> have to understand it better to decide
19:03:20 <erisco> and in the process I fear growing too familiar with it to be discontent
19:03:26 <MarcelineVQ> erisco: think of the poor implementers, won't anyone think of the poor implementers?
19:03:31 <monochrom> Whereas why would I expand "PCMCIA"?
19:03:55 <erisco> the compiler (writer) works hard so I don't have to
19:04:02 <monochrom> Oh oops the sample code does say "one_cps" oh well.
19:04:15 <Jinxit> Welkin: that error is probably fixed with the ImpredicativeTypes extension, or some other extension from Types.hs
19:04:18 <Jinxit> Welkin: interpret
19:04:59 <glguy> No, the solution isn't to turn on ImpredicativeTypes for that case
19:05:01 <monochrom> But yeah, ATS the programming language.
19:05:03 <glguy> (which is broken)
19:05:25 <glguy> The issue is that MinionLens is a type synonym for a polymorphic type and thus can't be the argument to Scruot
19:05:27 <glguy> Script*
19:05:36 <erisco> monochrom, is there any concise reason why you like ATS?
19:05:47 <monochrom> No, I don't like ATS.
19:06:09 <Jinxit> ah, i see
19:06:10 <monochrom> I just kind of like Hongwei Xi because I met him and he was a nice guy.
19:06:23 <erisco> lol, well I guess I misunderstood :P
19:06:35 <monochrom> And then I went on to citing him as an example of joining the Dark Side.
19:06:40 <Figaro_> Hi, newbie to haskell here
19:06:46 <Figaro_> Can i make a question?
19:06:55 <ski> you just did
19:07:03 <glguy> Congratz!
19:07:11 <Figaro_> Well, two question hehe
19:07:14 <Jinxit> glguy: wait, i have "type MinionLens = Traversal' Game Minion", is that really polymorphic?
19:07:19 <glguy> Jinxit: yes
19:07:23 <erisco> a constructive proof that questions exist
19:07:37 <Guest69913> Hello everyone
19:07:46 <Figaro_> It's about folding
19:07:54 <monochrom> In fact I don't even like intuitionistic logics generally all that much.
19:07:58 <Figaro_> Can I break a foldr early?
19:08:09 <glguy> Jinxit: You can use a ReifiedTraversal wrapper
19:08:13 <ski> Figaro_ : eys
19:08:15 <ski> yes
19:08:21 <Figaro_> How so?
19:08:32 <erisco> monochrom, are you more on board with Eric, erm, I forget his last name, perspective? though I don't know how well that lends to a paradigm
19:08:35 <Figaro_> Like if I want to break when the accumulator reach some value
19:08:36 <Jinxit> glguy: what's the polymorphism here?
19:08:40 <ski> > foldr const undefined [0 ..]  -- breaking early
19:08:44 <lambdabot>  0
19:08:53 <monochrom> Erik Meijer? Eric Hehner?
19:08:58 <glguy> Jinxit: Keep unfolding type synonyms
19:09:01 <erisco> begins with an H, perhaps Hehner then
19:09:13 <erisco> we share a first name so I remember that much ;)
19:09:15 <monochrom> Yes. Clearly, he's my thesis supervisor.
19:09:29 <erisco> well you don't have to agree with his work :P
19:09:32 <monochrom> Do we need a paradigm?
19:09:37 <erisco> from an aesthetics standard
19:09:45 <Jinxit> ah i see it
19:09:51 <erisco> a way in which to program, yes
19:09:54 <ski> > foldr (\n foldr_ns acc -> if acc > 1000 then acc else foldr_ns (acc + 2 ^ n)) (\acc -> acc) [0 ..] 0  -- Figaro_
19:09:56 <erisco> that is kind of what we're talking about
19:09:57 <lambdabot>  1023
19:10:09 <monochrom> But I do. At least the aPToP book. On aesthetic reasons.
19:10:15 <Figaro_> whoa
19:10:16 <Jinxit> can a ReifiedTraversal be used as a Traversal?
19:10:23 <erisco> I knew that monochrom because you gave me his paper a while ago and I read part of it
19:10:27 <Jinxit> never quite understood reification
19:10:35 <monochrom> My disagreement with him is on some other topic not in his textbook.
19:10:51 <glguy> Jinxit: Not directly, but you can match on the constructor to get a Traversal again
19:11:35 <erisco> my short description of discontent is that DT is not presented in the right way, for me
19:11:57 <ski> Figaro_ : another approach would be to use an exception monad (`Either e' or `ExceptT e m'), to break out
19:11:59 <erisco> it is becoming more like practical programming, and that is good
19:12:03 <monochrom> I think Idris is a good take on DT.
19:12:13 <erisco> but when it starts with logic, well, that's great that you can correlate
19:12:18 <erisco> but it doesn't mean that is how I want to program
19:12:21 <Figaro_> A bit too hard for me
19:12:40 <Guest69913> wait, what's the magic behind this @ski?
19:12:52 <Figaro_> I'm trying to understand it
19:12:59 <ski> no magic
19:13:03 <monochrom> Coq is really not a programming language, whether by intent or by outcome.
19:14:02 <erisco> I should reread Eric Hehner's paper again because I'd probably understand much more of it now
19:14:03 <monochrom> A few very clever people like Xavier Leroy pulled it off (using Coq for programming), but that only proves subjective cleverness, not objective suitability.
19:14:18 <erisco> and the perspective he has I remember appreciating a lot
19:14:20 <monochrom> A few very clever people wrote proof generators in javascript too.
19:15:01 <erisco> I want to be minimally clever to write programs :P
19:16:08 <Jinxit> Welkin: gotta go to bed now, but either ping or PM me and i'll read it tomorrow :)
19:16:46 <ski> > case foldM (\acc n -> if acc > 1000 then throwError acc else return (acc + 2 ^ n)) 0 [0 ..] of Left acc -> "Aborted : " ++ show acc; Right acc -> "Finished : " ++ show acc
19:16:49 <lambdabot>  "Aborted : 1023"
19:16:50 <ski> > case foldM (\acc n -> if acc > 1000 then throwError acc else return (acc + 2 ^ n)) 0 [0 .. 8] of Left acc -> "Aborted : " ++ show acc; Right acc -> "Finished : " ++ show acc
19:16:54 <lambdabot>  "Finished : 511"
19:17:08 <monochrom> Oh, I know a simpler example for Figaro_
19:17:12 <ski> Figaro_ : `throwError' there is `Left', and `return' is `Right'
19:17:28 <Figaro_> The exception stuff is with monads?
19:17:33 <ski> @type foldM
19:17:34 <ski> yes
19:17:35 <Figaro_> I have not read about it yet
19:17:36 <lambdabot> (Foldable t, Monad m) => (b -> a -> m b) -> b -> t a -> m b
19:17:37 <Welkin> using guard?
19:17:43 <Figaro_> foldr (\n foldr_ns acc -> if acc > 1000 then acc else foldr_ns (acc + 2 ^ n)) (\acc -> acc) [0 ..] 0
19:17:53 <monochrom> foldr (\b r -> if b then True else r) False [False, True, False, False, False,...]
19:17:54 <Figaro_> What's the (\acc -> acc ) for
19:17:56 <Figaro_> ?
19:18:08 <Welkin> looks weir
19:18:10 <Welkin> looks weird
19:18:12 <Welkin> it's just `id`
19:18:32 <ski> `foldr' "replaces" the `(:)'s in the list skeleton by the first argument, and the `[]' at the end (if any) by the second argument
19:18:42 <ski> in this case, `[]' will be replaced by `\acc -> acc'
19:18:53 <ski> > foldr f z [a,b,c]
19:18:57 <lambdabot>  error:
19:18:57 <lambdabot>      Ambiguous occurrence ‘f’
19:18:57 <lambdabot>      It could refer to either ‘Debug.SimpleReflect.f’,
19:19:10 <Welkin> > foldr f z [a,b,c] :: Expr
19:19:14 <lambdabot>  error:
19:19:14 <lambdabot>      Ambiguous occurrence ‘f’
19:19:16 <lambdabot>      It could refer to either ‘Debug.SimpleReflect.f’,
19:19:18 <Welkin> lol
19:19:45 <ski> @undefine
19:19:46 <lambdabot> Undefined.
19:19:47 <ski> > foldr f z [a,b,c]
19:19:50 <lambdabot>  f a (f b (f c z))
19:19:57 <ski> (someone had defined `f' ..)
19:20:18 <ski> > foldr f z (a:b:c:[])
19:20:25 <lambdabot>  f a (f b (f c z))
19:20:39 <ski> > foldr (-) z (a:b:c:[])
19:20:42 <lambdabot>  a - (b - (c - z))
19:20:54 * ski hopes the idea of "replace" is clear now
19:21:16 <ski> Figaro_ : but monochrom's example is also good, and simpler
19:21:30 <Welkin> how is a function used as the accumulator value
19:21:32 <Welkin> ?
19:21:52 <ski> my example is "leaned so far right they came back as left"
19:23:23 <ski> if you want to ponder my example, then ask yourself : how many arguments does `foldr' take ?
19:24:39 <Welkin> only 3
19:24:54 <Figaro_> (i think) i get the examples
19:24:57 <Welkin> the accumulator functions, starting value, and a foldable datatype
19:25:09 <Welkin> but your accumulator function takes 3 parameters
19:25:23 <ski> look again at the `foldr' example. how many arguments ?
19:25:25 <Figaro_> but I think I made the wrong question
19:25:38 <Welkin> ski: yours somehow takes 4
19:25:42 <ski> yes
19:26:06 <ski> how is that possible ?
19:26:09 <Figaro_> What Welkin mentions is not clear
19:26:22 <Figaro_> about your example
19:26:23 <glguy> > id f x
19:26:26 <lambdabot>  error:
19:26:26 <lambdabot>      • Ambiguous type variable ‘a0’ arising from a use of ‘show_M409624688158...
19:26:26 <lambdabot>        prevents the constraint ‘(Show a0)’ from being solved.
19:26:43 <ski> the general type signature (only considering lists) of `foldr' is
19:26:51 <glguy> > id (f :: Expr -> Expr) (x :: Expr)
19:26:53 <lambdabot>  f x
19:26:54 <ski>   foldr :: (a -> o -> o) -> o -> [a] -> o
19:26:59 <glguy> How many arguments does "id" have there?
19:27:05 <ski> in my specific use, the type of `foldr' is
19:27:38 <ski>   foldr :: (Integer -> (Integer -> Integer) -> (Integer -> Integer)) -> (Integer -> Integer) -> [Integer] -> (Integer -> Integer)
19:27:44 <ski> or, skipping redundant brackets
19:27:46 <glguy> Welkin: ^
19:27:47 <ski>   foldr :: (Integer -> (Integer -> Integer) -> (Integer -> Integer)) -> (Integer -> Integer) -> [Integer] -> Integer -> Integer
19:27:55 <ski> do you see what has happened here ?
19:28:20 <ski> (actually even
19:28:26 <ski>    foldr :: (Integer -> (Integer -> Integer) -> Integer -> Integer) -> (Integer -> Integer) -> [Integer] -> Integer -> Integer
19:28:29 <ski> )
19:30:53 <Figaro_> Isn't your example returning a number? Does not  .... -> (Integer -> Integer) means that your result whould be a functin that takes an Integer and return and Integer?
19:31:07 <Welkin> Figaro_: all functions in haskell are curried
19:31:12 <Figaro_> Yes
19:31:16 <Welkin> so all functions only take one parameter
19:31:24 <Welkin> and produce another function
19:32:10 <Figaro_> I still don't get why ski gives 4 parameteres to foldr
19:32:27 <glguy> Figaro_: Do you understand how I gave 2 parameters to id?
19:32:34 <Welkin> glguy: `id` still only has one arugment, but `id f` gets reduced to `f`
19:32:45 <glguy> sure, same situation in foldr
19:33:10 <glguy> :t foldr
19:33:11 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
19:33:13 <Figaro_> glguy: nop
19:33:13 <glguy> :t id
19:33:15 <lambdabot> a -> a
19:33:27 <glguy> For id, we can pick the type 'a' to be 'this -> that'
19:33:34 <glguy> and we get: (this -> that) -> this -> that
19:33:40 <Figaro_> Yes
19:33:42 <Welkin> :t const id
19:33:44 <lambdabot> b -> a -> a
19:33:50 <Welkin> that is the closest example I know
19:33:53 <glguy> same deal for foldr, pick 'b' to be a function type
19:34:05 <Figaro_> Yes
19:34:08 <glguy> suddenly it looks like there are 4 "arguments"
19:34:11 <Welkin> it took a while for me to work out the type transformations on that one when I did it a while back
19:34:15 <Figaro_> Then this fold IS returning a function?
19:34:38 <glguy> yeah
19:35:04 <Figaro_> and applying it to 0 ?
19:35:11 <Welkin> is there a cleaner pattern to use for a fold that you can break from?
19:38:44 <Redrield> What would be the best editor to use for Haskell. I'm trying to use VSCode with the Haskelly extension, but it just isn't working out as smoothly as other languages have been when using VSCode
19:39:10 <Redrield> Should I be using a different extension (I really don't feel like having another text editor installed, so if that could be a last resort I would appreciate it)
19:39:17 <Welkin> emacs
19:39:39 <Welkin> it has the best haskell support
19:39:40 <Redrield> Emacs failed me, I'm almost certainly not going back
19:40:03 <jle`> i use vim for the most part
19:40:18 <jle`> but people like atom, sublime, etc. too
19:43:43 <ski> Figaro_ : yes
19:43:50 <ski> that `0' is the accumulator
19:45:58 <Guest69913> http://lpaste.net/353662 I have these datatypes. It works well when I'm using LogicGate or Proposition, but things get messy when I try to use "Boolean" alone. I'm having an infinite type error
19:46:07 <tswett_to_go> I just thought of a dumb joke.
19:46:26 <tswett_to_go> What language is this: update a set b = null where null = b
19:47:26 <tswett_to_go> There's no punchline. I just thought it was funny that you can make a thing which is both a valid SQL statement and a valid Haskell statement, and which uses both languages' "where" clauses.
19:47:30 <jle`> Guest69913: can you post the error?
19:47:56 <jle`> tswett_to_go: cute :)
19:49:27 <Guest69913> here you go http://lpaste.net/353666 jle`
19:50:20 <jle`> Guest69913: what line is the error on?
19:50:35 <Guest69913> the first one
19:50:59 <jle`> Guest69913: what type do you think 'f' has?
19:51:26 <jle`> ...what type do you want it to have?
19:51:29 <jle`> (what is f supposed to do?)
19:51:50 <jle`> if you answer these questions then you might see your problem
19:52:17 <Figaro_> ski : Another question from your example
19:52:30 <jle`> Guest69913: giving it a type signature will help you see what the problem is
19:52:44 <jle`> i don't know how to help you fix it because i'm not sure what 'f' is supposed to be doing
19:53:16 <jle`> but if you think about what f is doing, then you'll see why it doesn't make sense, the way you have written it
19:53:41 <jle`> you're applying 'f' to things of different types, and the types don't unify
19:53:59 <jle`> kind of like saying foo True = foo "hello"
19:54:10 <Guest69913> jle` it's supposed to walk though the tree and convert everything to haskell's I want the type to be like "Boolean Boolean Bool"
19:54:20 <jle`> foo is taking a Bool as an argument, but I later apply it to a String?
19:54:27 <jle`> Guest69913: Boolean Boolean Bool ?
19:54:29 <jle`> there's your problem
19:54:31 <jle`> that's not a function type
19:54:36 <jle`> so f isn't a function
19:54:39 <Guest69913> http://lpaste.net/353662
19:54:58 <jle`> Guest69913: if you want f :: Boolean Boolean Bool, then it isn't a function
19:55:03 <jle`> so there isn't any reason to pattern match on arguments
19:55:17 <Guest69913> oh no I want Boolean Boolean Bool -> Bool
19:55:20 <jle`> also, Boolean Boolean Bool isn't well-kinded
19:55:41 <jle`> Boolean's first argument is a (* -> *)
19:55:50 <jle`> but Boolean is (* -> *) -> (* -> *)
19:56:03 <jle`> so `Boolean Boolean Bool` doesn't make sense as a type
19:56:12 <jle`> are you familiar with kinds?
19:56:29 * ski waits for Figaro_ to formulate their question
19:56:34 <Guest69913> yes kind of, I get the error, but I don't know how to fix it
19:57:00 <jle`> maybe you want 'Boolean Identity Bool' ?
19:57:07 <jle`> from Data.Functor.Identity
19:57:16 <Guest69913> I want it to be still recursive
19:57:31 <glguy> Probably not the ideal, but we can do : newtype BooleanBoolean a = BB (Boolean BooleanBoolean a)
19:57:41 <jle`> ah, so you want Boolean (Boolean (Boolean (Boolean ...))) Bool, huh?
19:57:43 <Figaro_> Many questions actually, why the function you give to foldr has three paramters?
19:57:56 <Figaro_> What's the n parameter
19:58:06 <ski> the current element of the list
19:58:11 <Figaro_> ohhhh
19:58:13 <Guest69913> in a way yes
19:58:23 <jle`> you want each inner layer to be another Boolean
19:58:29 <Guest69913> ya
19:58:31 <jle`> boolean wrapping a boolean wrapping a boolean wrapping a boolean forever
19:58:33 <Figaro_> That what I wanted originally
19:58:53 <Figaro_> But again, isn't the function you give to foldr supposed to have two parameters?
19:58:56 <glguy> Guest69913: You could avoid the pain with: data Boolean = Value Bool | And Boolean Boolean
19:59:07 <jle`> haskell doesn't quite let you do that nakedly, you'll have to wrap it up like how glguy posted, or use a generic fixed-point combinator
19:59:47 <ski> Figaro_ : it's supposed to have type `a -> o -> o', for some types `a' and `o'. in my case `a' is `Integer' and `o' is `Integer -> Integer'
19:59:55 <jle`> there's a common one in the 'data-fix' library if you want to leverage it
20:00:05 <ski> Figaro_ : meaning that callback function has type `Integer -> (Integer -> Integer) -> Integer -> Integer'
20:00:29 <jle`> or yeah, you can write a data type implementing the infinte recursion, newtype BoolForever a = BF (Boolean BoolForever a)
20:00:46 <jle`> so a `Boolean BoolForever a` contains BoolForever's, which contain Boolean's
20:01:04 <jle`> then you can write f :: Boolean BoolForever Bool -> Bool
20:01:24 <jle`> f (And (BF x) (BF y)) = f x && f y
20:01:38 <jle`> this works because the type of x is :: Boolean BoolForever a
20:01:46 <jle`> er, the type of x is :: Boolean BoolForever Bool
20:01:55 <jle`> so now, every time you use 'f', you're applying it to a Boolean BoolFrever Bool
20:01:59 <jle`> so it's all well-typed :)
20:02:13 <Guest69913> that's awesome, I'll look into the fix-point and use the newtype if it fails, thanks a lot jle` and glguy! :)
20:06:24 <jle`> Guest66913: the data-fix package provides a parameterized version of BoolForever, and also some nice polymorphic combinators for recursion like what we quote here
20:07:09 <Figaro_> ski: your foldr takes its initial value as a function  then
20:07:23 <Figaro_> Sorry if I ask you many things
20:07:47 <ski> what do you mean by "initial value" ?
20:08:34 <Figaro_> > foldr (\acc x -> x + acc) 0 [1,2,3,4]
20:08:38 <lambdabot>  10
20:08:41 <Figaro_> has 0 as initial value
20:08:47 <glguy> Figaro_: foldr "starts" from the beginning of the list, like any other operation on lists
20:08:57 <glguy> at best the 0 is the "end" value
20:15:13 <tswett_to_go> Can templates in Template Haskell have "side effects"? In my case, I want to have a template that returns a type, but also generates a declaration.
20:15:29 <glguy> No
20:16:33 <tswett_to_go> Well... that's a straightforward answer. :)
20:16:36 <tswett_to_go> Thanks.
20:18:27 <Welkin> glguy: you forgot the full stop
20:20:01 <glguy> Thanks.
20:21:38 <tswett_to_go> I see that you can use Template Haskell to query whether or not Template Haskell is enabled.
20:21:58 <tswett_to_go> Sounds kind of... cartesian.
20:22:17 <lpaste_> codebje revised “tail of church list?”: “tail of church list?” at http://lpaste.net/353663
20:25:34 <tswett_to_go> Next question, then. I see that a TH QuasiQuoter can contain a "quoteDec" parser, which is expected to return a Dec.
20:25:45 <tswett_to_go> Does this mean it's not possible to have a QuasiQuoter which returns multiple declarations?
20:26:40 <glguy> No, it's type is : quoteDec :: String -> Q [Dec]
20:27:51 <tswett_to_go> Ah, nice.
20:29:33 <Maxdamantus> codebje: I'm not sure what you mean by "will immediately call tail"
20:29:52 <Maxdamantus> codebje: tail should work just the same way as head.
20:30:20 <Maxdamantus> maybeTail l = l Nothing (\_ x -> Just x)
21:03:49 <Starfflame> https://www.irccloud.com/pastebin/iGcgpNxK/
21:04:08 <Starfflame> https://www.irccloud.com/pastebin/gKIjaeEU/
21:04:14 <Starfflame> crap
21:04:36 <Starfflame> I can't format my text, but I'm confused how this is producing an error
21:05:04 <Starfflame> I don't have a Maybe input specified anywhere...?
21:05:29 <glguy> Starfflame: First issue is that you have the arguments to comp backward 
21:05:48 <Starfflame> they are?
21:06:27 <Starfflame> rip
21:09:27 <lpaste_> glguy pasted “for starfflame” at http://lpaste.net/6795469252544430080
21:09:51 <glguy> Starfflame: The other problem was that comp was using 'x' as though it had type 'Maybe a' instead of the actual 'a'
21:10:41 <Starfflame> I'm confused, why should that matter?
21:10:59 <Starfflame> doesn't comparing Just X and Just Y work equally well?
21:11:04 <glguy> You weren't doing that
21:11:17 <glguy> You were comparing  X and Nothing
21:11:25 <glguy> Not Just X and Nothing
21:11:43 <glguy> and then you were returning that same x as the first element of your 3-tuple
21:11:52 <glguy> where it needed to have a Maybe type, but didn't
21:12:37 <Starfflame> My list should compose all of Maybe types
21:12:50 <Starfflame> perhaps I should declare that in the type declaration, but
21:13:06 <glguy> Right, you declared that that was not necessarily the case
21:13:41 <Starfflame> so why does Haskell freak out when I use Just X?
21:13:56 <glguy> It tells you right in the message
21:14:31 <Starfflame> I see
21:14:55 <Starfflame> thanks man :D
21:18:25 <Starfflame> haskell's error messages are kinda cryptic
21:18:28 <Starfflame> at least to a noob
21:19:45 <glguy> If you have a question about one you can of course ask it
21:21:00 <Starfflame> usually I'm able to figure it out
21:21:09 <Starfflame> but the specific one I saw was just confusing xD
21:21:11 <Cale> Starfflame: One thing which helps a lot is if you add type signatures to things which don't have them -- generally the compiler will be able to improve the quality of the messages, since it has more information about what it is that you want.
21:22:25 <neezer> Hello! I'm new to Haskell and trying to understand the Turtle library (https://hackage.haskell.org/package/turtle-1.3.2/docs/Turtle-Prelude.html) for a script I'm working on... specifically how to filter the output of `lstree "/some/dir"` to only return files and not directories. Would appreciate any help/guidance!
21:24:14 <Cale> This library is... weird
21:25:20 <neezer> @Cale Any recommendations for an alternative? Really I just need a list of all files in a directory (recursive).
21:25:20 <lambdabot> Unknown command, try @list
21:25:33 <neezer> @list
21:25:34 <lambdabot> What module?  Try @listmodules for some ideas.
21:25:49 <neezer> @listmodules
21:25:50 <lambdabot> activity base bf check compose dice dict djinn dummy elite eval filter free fresh haddock help hoogle instances irc karma localtime metar more oeis offlineRC pl pointful poll pretty quote search
21:25:50 <lambdabot> slap source spell system tell ticker todo topic type undo unlambda unmtl version where
21:26:08 <glguy> The @ is for bot commands, not addressing other users.
21:26:36 <neezer> glguy Thanks, also new to IRC. Usually on Slack these days. :)
21:27:53 <dmwit> Might be nice to remove @ from \bot's vocabulary. It's becoming a much more common way to address people on other media, and I think we can expect continued confusion here from it.
21:28:09 <Cale> neezer: There's a package called directory-tree which is relatively straightforward. You should be able to use  readDirectoryWith return "/path/to/somewhere"
21:29:03 <neezer> Cale Thanks for the recommendation, I'll check it out.
21:31:41 <Cale> toList . dirTree <$> readDirectoryWith return "/path/to/somewhere"
21:31:55 <Cale> will turn it into a list of paths
21:32:06 <Cale> (since you'll get a tree to start with)
21:32:16 <Cale> toList is from Data.Foldable
21:33:59 <Cale> Prelude System.Directory.Tree Data.Foldable> length . toList . dirTree <$> readDirectoryWith return "/home/cale/Music"
21:33:59 <Cale> 16181
21:34:12 <neezer> Cale: Awesome, that's exactly what I needed. Thank you!
21:37:15 <Cale> neezer: That Turtle library is actually probably worth looking at more closely, given who its author is, however, it looks like a pretty fancy tool for the job.
21:37:25 <Starfflame> is there a built-in function that does concat splitOn?
21:37:57 <Cale> Starfflame: You just want to delete the separators?
21:38:09 <Starfflame> yeah
21:38:22 <neezer> Another question, unrelated to the first: I'm trying to use HLint and I have a data type that I want to not use camelCasing on, so I read about how to add an annotation pragma to the top of my file to disable that rule: I used `{-# ANN module "HLint: ignore Use camelCase" #-}` and that gets rid of the HLint error, but now my app won't compile with the error "File name does not match module name: Saw: ‘Main’ Expected: ‘Lib’".
21:38:30 <neezer> Docs here: http://community.haskell.org/~ndm/darcs/hlint/hlint.htm#customization
21:38:49 <Cale> Starfflame: perhaps replace?
21:38:58 <Cale> Starfflame: Is this a Text you're working with?
21:39:09 <Starfflame> Yeah, a string
21:40:40 <Eduard_Munteanu> neezer, the error seems totally unrelated to hlint
21:41:06 <Eduard_Munteanu> neezer, do you have a module declaration at the top of your file?
21:41:37 <neezer> Eduard_Munteanu: Yes, after the ANN pragma, which reads `module Lib (argConfig, defaultFromEnv) where`
21:41:54 <neezer> Eduard_Munteanu: Removing the ANN pragma allows my app to compile and run fine.
21:42:04 <glguy> Put the ANN under the module declaration
21:42:38 <neezer> glguy: After my imports too? Otherwise I get parsing errors.
21:44:14 <neezer> Hmm, now I'm getting "Ambiguous type variable ‘t0’ arising from an annotation prevents the constraint ‘(Data t0)’ from being solved."
21:44:27 <neezer> I can't help but wonder if my ANN pragma is malformed in some way.
21:45:11 <glguy> OverloadedStrings enabled?
21:45:53 <neezer> glguy: Yes.
21:46:06 <glguy> OK, then you'll need a type signature on the string literal in the annotation
21:47:00 <neezer> glguy: What would that look like?
21:47:00 * ski would prefer being able to say `@type',&c. in the future as well
21:48:39 <dmwit> ski: What makes you prefer @type to ?type?
21:48:50 <glguy> neezer: Try:  {-# ANN module ("stuff" :: String) #-} perhaps
21:49:34 <glguy> Annotations are more interesting than simply expecting strings, then can take arbitrary data types as annotations
21:49:47 <neezer> glguy: That seemed to work. Compiled without errors.
21:49:58 <ski> tradition
21:50:23 <neezer> glguy: Thanks for the help!
21:51:48 <dmwit> ski: yeah =)
21:52:16 <ski> (for me, `?' just feels wrong. i feel like i'd refrain from interacting with lambdabot via such commands, should the old way become unavailable)
