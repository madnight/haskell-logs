00:32:37 <SurveyBot> please fill out this survey
00:32:38 <SurveyBot> #haskell 
00:32:50 <SurveyBot> https://docs.google.com/forms/d/e/1FAIpQLSeTDkfDkBGHnoY_hfxwCZjJzxntfXZeY4SKqPHlIZT5bz2jQQ/viewform?usp=sf_link#responses
00:34:35 <CoconutCrab> f the sandbox didn't have so many holes in it Java applets were arguably better for webapps than the unholy mess we've cobbled together over the last ten years to replace them.
00:34:38 <CoconutCrab> sorry
00:34:40 <CoconutCrab> wrong tabs
00:51:42 <halogenandtoast> Anyone have a good suggestion for a weekend Haskell project?
00:54:14 <blueonyx> halogenandtoast: projecteuler.net
00:54:22 <ahri> i have a failing hspec test, and a vague understanding of setting breakpoints in ghci. i'd like to take these bits of knowledge and use them in unison. i loaded my src, then the test spec, set my breakpoints, and ran "main", but the unit test fails without hitting my breakpoint. any ideas?
00:54:40 <halogenandtoast> blueonyx: those are kind of boring, I was looking for something a bit more practical. For example: Write a Sokoban clone, etc.
00:54:41 <blueonyx> halogenandtoast: make compiling couchdb-conduit great again
00:54:53 <blueonyx> write a sokoban clone :>
00:54:58 <halogenandtoast> I did already
00:55:01 <halogenandtoast> 3 times
00:55:32 <blueonyx> i'm working on the ftdi lib to build a weatherstation showing temperatures/date/internet bandwidth usage 
00:55:56 <blueonyx> using an lcd graphics board and a ftdi usb chip 
00:56:22 <blueonyx> there are so many games one could try to implement or solve in haskell
00:56:43 <blueonyx> or write a bittorrent client
00:56:52 <blueonyx> or something to do with monero
00:57:09 <blueonyx> or some rl puzzle
00:57:18 <halogenandtoast> a bittorrent client could be an interesting project.
00:57:22 <halogenandtoast> I know very little about it.
00:57:29 <halogenandtoast> Thanks blueonyx 
00:59:40 <blueonyx> great way to get into bytestrings and networking or conduit or lenses as well 
01:00:37 <halogenandtoast> All things I want to get better at. And it will be a cool app if it works when I'm done.
01:00:45 <halogenandtoast> Can download some NASA images.
01:00:59 <blueonyx> hehe
01:16:27 <sjpet> Good morning. Anyone in here familiar with HSCurses?
01:35:32 <ahri> argh, after ":l src/MyModule.hs" then ":l test/Spec.hs" how can i set a breakpoint like ":break MyModule 310"? i get this error: module 'MyModule' is from another package; this command requires an interpreted module
01:35:46 <ahri> (in ghci)
01:37:01 <sjpet> ahri: does ":l src/MyModule.hs test/Spec.hs" work better?
01:40:22 <halogenandtoast> sjpet: I've used the haskell ncurses package...
01:40:23 <ahri> sjpet: it works! i had no idea i could specify multiple modules with :load ! thank you
01:40:35 <ania123> I do not understant, why interpreter is machine undependent? a program language code is transformed into machine language is not?
01:40:40 <halogenandtoast> But not specifically HSCurses methinks.
01:41:58 <halogenandtoast> ania123: The interperter doesn't directly transform a provided program into the machine language of the system.
01:42:11 <halogenandtoast> It only executes already compiled statements.
01:42:24 <geekosaur> ania123, the interpreter produces bytecode for s imple virtual machine (like the JVM or CLR only much simpler)
01:42:33 <halogenandtoast> geekosaur: sometimes
01:42:39 <geekosaur> most of that bytecode references compiled libraries
01:42:42 <halogenandtoast> geekosaur: sometimes it just directly executes the AST
01:43:04 <ania123> Haskell is interpreter or complier?
01:43:07 <geekosaur> both
01:43:09 <pacak> ania123: Can be both
01:43:12 <halogenandtoast> depends on how you run it
01:43:30 <halogenandtoast> Actually...
01:43:33 <halogenandtoast> Haskell is neither
01:43:41 <halogenandtoast> GHC is both an interpreter and compiler
01:43:43 <pacak> ghc is
01:44:02 <sjpet> halogenandtoast: I have an issue with the input queue I think. I am handling resizing by capturing sigwinch as in HSCurses.CursesHelper and it works mostly fine, except that if the first key pressed after window resize is a complex one, getch doesn't combine them. e.g. ArrowDown comes as \ESC [ B
01:44:04 <geekosaur> ghc has multiple backends, most of which compile in various ways (-fasm native backend, -fllvm produces LLVM IR and runs opt and llc on that) but also a bytecode backend used by ghci and to interpret Template Haskell splices
01:44:17 <osa1> mmm so I updated stack from 1.2 to 1.4 and my snapshots don't work anymore. I'm getting "symbol not found" errors during linking stage.
01:45:02 <ania123> assume haskell is only interpreter. AfterI install haskell on my pc, any program written in haskel is transformed in another form let assume to byte code. How ,y machine can udnerstand that byte code?
01:45:17 <geekosaur> hugs is purely an interpreter. jhc is a whole-program compiler/"transpiler" producing ANSI C. uhc is an alternative native-code compiler.
01:45:54 <ania123> byte code is Platform-independent?
01:45:57 <halogenandtoast> ania123: it can not
01:46:04 <geekosaur> (neither hugs nor jhc is under development any more. uhc still sees development but apparently it's mostly Utrecht CS students)
01:46:17 <sjpet> halogenandtoast: (there is also a non-critical issue that all ungetCh'd KeyResize come in at once along with whatever key is pressed after resize
01:46:39 <halogenandtoast> ania123: bytecode is interpreted usually by some VM packaged as an interpreter
01:46:40 <ania123> halogenandtoast: there should be smt which transforms byte codes into machine codes
01:46:41 <ania123> is not?
01:47:03 <halogenandtoast> ania123: When I write an interpreter that has a byte code step here is what happens
01:47:29 <halogenandtoast> lex, tokenize, generate ast, convert to bytecode, interpret bytecode or output bytecode to be interpreted later.
01:47:29 <ania123> byte code is uniform? 
01:47:30 <geekosaur> there is a bytecode interpreter to go with the bytecode compiler. it's not separate; "runghc" produces bytecode into memory and then runs the interpreter on it, "ghci" uses the bytecode compiler for expressions and then runs the interpreter on it.
01:47:40 <halogenandtoast> ania123: bytecode is implementation dependendent
01:47:52 <geekosaur> I',mm not sure the bytecode compile and interpret steps can even be separated in current ghc
01:47:54 <halogenandtoast> Meaning bytecode for the JVM (Java Virtual Machine) will only run on the JVM
01:48:22 <halogenandtoast> sjpet: I haven't messed with Sigwinch yet
01:48:32 <ania123> uh, not quite clear
01:48:33 <halogenandtoast> Do you have any example code I can try out?
01:48:34 <geekosaur> ghc's bytecode virtual machine is not a full or standalone implementation like JVM/CLR/beam
01:48:50 <ania123> JAVA-->byte code -->machine code
01:48:56 <halogenandtoast> ania123: no
01:49:02 <ania123> no?
01:49:05 <ania123> then how is?
01:49:06 <halogenandtoast> javac compiles your .java file to bytecode
01:49:10 <halogenandtoast> you run that bytecode with java
01:49:23 <geekosaur> javac produces byecode. you then run java or jre on that, which is the bytecode virtual machine
01:49:31 <halogenandtoast> If a system does not have the java runtime installed, then you will not be able to run it
01:49:38 <geekosaur> you can;t separate those steps with ghc
01:49:53 <ania123> aha
01:49:57 <geekosaur> similarly for erlang, you compile to beam bytecode and use beam to run that bytecode
01:50:06 <halogenandtoast> so as an example I could write a simple stack based language
01:50:15 <ania123> so, Java complier generates byte codes for java program?
01:50:22 <halogenandtoast> 1 means push 2 means pop 3 means add and 4 means print
01:50:30 <halogenandtoast> push takes an int
01:50:32 <geekosaur> (and you compile C# or F# or etc. to CLR bytecode which usually has an executable header, after the fashion of self-unzipping exe files on windows)
01:50:35 <halogenandtoast> so my "machine code" would be
01:50:40 <ania123> so, Java complier generates byte codes for java program?
01:50:47 <halogenandtoast> 15163422
01:50:53 <geekosaur> yes, that is what .class files contain
01:50:54 <halogenandtoast> whuch would print 11
01:50:57 <halogenandtoast> *which
01:51:11 <ania123> halogenandtoast: so, Java complier generates byte codes for java program?
01:51:15 <halogenandtoast> but I have to write an interpreter that can understand that
01:51:47 <geekosaur> there are disassemblers and such for those files that will show you the bytecode as individual "assembly language" instructions, and even assemblers to reconstitute the class file from that format
01:52:10 <halogenandtoast> ania123: from a perspective yes, java program is a bit ambiguous. In general we just refer to it as the JVM
01:52:18 <halogenandtoast> or Java Virtual Machine
01:52:25 <ania123> ok
01:52:28 <halogenandtoast> and the neat thing about the JVM is that other languages can target this
01:52:33 <halogenandtoast> they just generate the same bytecode
01:52:36 <halogenandtoast> for instance Clojure
01:52:45 <ania123> after byte code is generated JVM interpreter transform it to machine code is not?
01:53:10 <ania123> byte code --> machine code by JVM
01:53:10 <halogenandtoast> ania123: not exactly, the JVM itself is compiled for your machine
01:53:11 <geekosaur> (Android dev environments use that internally since they convert the JVM bytecode to Android bytecode for either the old Dalvik VM or the newer ART VM)
01:53:24 <halogenandtoast> so it has all these methods that are compiled already
01:53:33 <ania123> I am inetersted, what transforms byte code into machine code?
01:53:33 <halogenandtoast> when the runtime executes your program
01:53:40 <halogenandtoast> it calls these compiled methods
01:54:06 <ania123> Java program --> byte code by JVM
01:54:07 <halogenandtoast> it's not converted into machine code...
01:54:08 <ania123> this is clear
01:54:26 <ania123> now question, how machine code is udnerstand by my pc
01:54:43 <Hijiri> the machine code is in the JVM, it chooses which machine code to run based on the bytecode
01:54:52 <halogenandtoast> the JVM is compiled on your machine. It has a bunch of methods already compiled to machine code
01:54:54 <Hijiri> but it doesn't transform the bytecode to machine code in a way that is runnable on its own
01:55:02 <halogenandtoast> the bytecode is then read and just calls these methods
01:55:09 <halogenandtoast> the bytecode itself is never transformed
01:55:10 <Hijiri> except I think newer versions of the JVM do some JIT?
01:55:21 <geekosaur> yes
01:55:34 <halogenandtoast> Hijiri: shhh that just confuses things.
01:55:51 <halogenandtoast> Sometimes we lie in order to obtain enlightenment
01:56:45 <ania123> Hijiri: there can be infinite deferent machine codes, is not?
01:57:00 <Hijiri> ania123: I don't know what that means
01:57:15 <halogenandtoast> ania123: Do you know what machine code is?
01:57:37 <ania123> machine code is combination of 0 and 1
01:57:39 <ania123> no?
01:57:44 <halogenandtoast> that's binary
01:57:50 <geekosaur> ania123, a virtual machine of this type is software reading the bytecode and dispatching to different functions
01:57:58 <halogenandtoast> you need a larger definition to describe machine code.
01:58:12 <geekosaur> you may be thinking of a different kind of virtual machine, for which the example is LLVM bytecode
01:58:29 <geekosaur> (which is never run directly but converted to native code by llc or lld)
01:59:00 <ania123> machine code for me is some program which machine can read
01:59:02 <geekosaur> well, slight lie there, llc reads textual LLVM IR
01:59:17 <geekosaur> yes, why should that program not be a big loop that inteprets bytecode?
01:59:32 <ania123> complier transforms a guven program into machine code, that is clear
01:59:37 <geekosaur> sometimes
01:59:42 <halogenandtoast> ania123: machine is too generic.
01:59:56 <halogenandtoast> what part of your machine?
02:00:11 <halogenandtoast> What part of your machine interprets the machine code
02:00:29 <ania123> now, what is not clear for me is, what interpreter dies? why it is platform undependent
02:00:56 <halogenandtoast> ania123: write one and find out
02:01:11 <halogenandtoast> ania123: https://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours
02:01:40 <piyush-kurur> what is the status of backpack in GHC ? Is it implemented in 8.*
02:02:07 <geekosaur> piyush-kurur, coming in 8.2.1
02:02:30 <geekosaur> https://github.com/ezyang/thesis/releases
02:03:04 <piyush-kurur> geekosaur: thanks
02:03:37 <geekosaur> ania123, you can write a program that can read source code and evaluate it directly (many simple LISP and Scheme implementations)
02:04:03 <geekosaur> you can write a program that interprets an AST produced either by the same program or by something else
02:04:35 <geekosaur> you can write a program that reads and interprets bytecode in a big read/case loop
02:04:59 <geekosaur> all three of these can be portable because they read the same thing no matter what platform they are on
02:05:19 <ania123> geekosaur: compiler takes a humen readable code and transforms it to machine code
02:05:27 <halogenandtoast> ania123: sometimes
02:05:28 <geekosaur> you;ve said that multiple times
02:05:31 <ania123> I call machine code a code which can be read by machine
02:05:36 <geekosaur> you;ve been wrong the same number of times
02:05:50 <ania123> :)
02:06:06 <ania123> assume it does always like this
02:06:08 <halogenandtoast> ania123: machine code are CPU depdendent instructions which depend entirely on its architecture.
02:06:23 <geekosaur> or perhaps you need to go reeducate the folks who came up with java, erlang, python (can save and interpret bytecode), C#, F#, LLVM, ...
02:06:42 <ania123> ok
02:06:49 <ania123> it is mroe or less clear for me
02:06:59 <ania123> I fail to understand the deference 
02:07:11 <ania123> between compiler and interpreter
02:07:27 <halogenandtoast> A compiler changes your program from one form to another.
02:07:49 <ania123> yes,  I got it
02:07:51 <halogenandtoast> A interpreter take your program in a format usually written by a human and executes it.
02:07:55 <ania123> and it is clear for me
02:07:57 <geekosaur> ania123, these days the difference is small enough not to matter that much, to be honest. in 1970 it mattered
02:08:08 <halogenandtoast> compiler takes a file and produces a file
02:08:10 <ania123> what execution means?
02:08:12 <geekosaur> there are "hardware" implemntations of the JVM and BEAM, at least
02:08:16 <halogenandtoast> an interpreter takes a file and does what it says.
02:08:30 <ania123> aha
02:08:41 <bollu> geekosaur: any hardware implementations of STG?
02:08:57 <ania123> halogenandtoast: now my question is 
02:09:03 <ania123> how it does?
02:09:18 <ania123> I mean, when compler does smt it should be udnerstandable by machine
02:09:23 <halogenandtoast> example: a file program.code has "print 'hello'" a compiler takes program.code and output program.exe an interpreter take program.code and prints 'Hello' to the screen.
02:09:33 <ania123> so, transitively ot should be converted to machine code
02:09:34 <ania123> is not?
02:09:37 <geekosaur> but no hardware that understands .pyo or llvm bytecode or etc. (yet? although the point of LLVM was to generate native code on the fly from bytecode quickly, so you could send your compiled program to any machine in a heterogeneous cluster and have it run)
02:10:09 <geekosaur> ania123, what is so hard about the idea of a program that reads and does tings based on bytecode?
02:10:27 <ania123> interpreter take program.code and prints 'Hello' to the screen.
02:10:29 <geekosaur> there are programs that read your input and runs commands based on it (e.g. unix shells)
02:10:35 <halogenandtoast> geekosaur: it's easy to understand when you understand it, it's hard when you don't
02:10:38 <geekosaur> why can't they do the same with bytecode?
02:10:45 <ania123> to print Hello, it should be udnestand by machine in some form, is not?
02:11:01 <halogenandtoast> the interpreter, which has been compiled, has a method for printing text
02:11:13 <halogenandtoast> your bytecode or program when inspected, will call that method
02:11:29 <halogenandtoast> s/inspected/interpreted/
02:11:53 <halogenandtoast> the interpreter has been compiled to run specifically on your system
02:12:24 <ania123> i think , I see now
02:12:24 <halogenandtoast> As an example one clever way this has been done is to use a virtual machine
02:12:34 <halogenandtoast> which is basically a computer emulator
02:12:49 <halogenandtoast> so you basically write a system which acts like a computer
02:13:10 <halogenandtoast> so you can easily target it regardless of what platform it runs on.
02:13:37 <ania123> I see
02:13:44 <ania123> so
02:13:48 <halogenandtoast> In a way, bytecode can just be machine language for an emulated computer.
02:14:03 <halogenandtoast> and much like a CPU takes an instruction and does something with it
02:14:06 <halogenandtoast> so does the emulated computer
02:14:08 <geekosaur> bollu, I have a vague recollection of someone doing an FPGA implementation
02:14:52 <geekosaur> bollu, also see HaLVM
02:14:55 <ania123> halogenandtoast: when we write haskell program test.hs
02:15:00 <halogenandtoast> but instead of having hardware to perform the instruction, the emulated computer has precompiled instruction that target your current architecture.
02:15:06 <ania123> it is complaied to machine code?
02:15:18 <halogenandtoast> depends on what I do with it.
02:15:27 <halogenandtoast> if I use runhaskell it is not
02:15:38 <halogenandtoast> if I load it into ghci it is not
02:15:44 <ania123> if u use runhaskell what will happen
02:15:58 <ania123> or if u load it with ghci
02:16:20 <halogenandtoast> sorry I don't have time to answer as I have a Japanese lesson.
02:16:32 <ania123> ok. thank you!
02:17:01 <geekosaur> it generates and then runs bytecode
02:17:24 <geekosaur> let's try a simpler example since haskell compilers aren't very simple.
02:17:38 <geekosaur> I have a one-line program:     PRINT "Hello"
02:18:17 <geekosaur> my compiler reads this and writes out bytecode:   01 05 48 65 6c 6c 6f 00
02:18:27 <geekosaur> I now run the interpreter on this bytecode.
02:18:45 <geekosaur> It reads 01 and knows that it is supposed to print a string, which is the next thing in the bytecode.
02:18:56 <geekosaur> Next it reads 05 which is the length of the string to read back
02:19:16 <geekosaur> Next it reads 48 65 6c 6c 6f. Now it has the string, and it calls its internal print routine on that string.
02:19:25 <geekosaur> And finally it reads 00, which tells it to exit.
02:19:36 <geekosaur> That is how a bytecode interpreter works
02:20:11 <ania123> very clear explanation
02:20:18 <ania123> thank you
02:20:24 <ania123> the interpreter comes
02:20:27 <geekosaur> The interpreter must be compiled (to machine code or whatever) on any machine you want to use it on. The *bytecode* it understands is the sam everywhere
02:20:28 <ania123> with haskell system
02:20:29 <geekosaur> *same
02:20:30 <ania123> is not?
02:20:39 <geekosaur> ghci comes with ghc, yes
02:20:52 <geekosaur> (in fact "ghci" is just a wrapper that runs "ghc --interactive")
02:21:26 <ania123> then it is not fully machine independent
02:21:28 <ania123> because
02:21:40 <ania123> every haskell system should depend to machine
02:21:50 <ania123> the one whiche cen be installed on mac can nto be installed on PC
02:21:51 <ania123> no?
02:22:36 <geekosaur> the programs that come with ghc are all native machine code, yes.
02:23:50 <geekosaur> that does not mean they are incapable of interpreting
02:23:56 <geekosaur> you are confusing levels
02:24:05 <ania123> seems so :)
02:24:12 <geekosaur> you do not have to use a program that is itself interpreted, to interpret other code
02:24:23 <geekosaur> inf act you usually want the intepreter program to be native code
02:24:38 <geekosaur> but what it interprets does not have to be, and in fact usually is not, native code
02:24:59 <geekosaur> it can be typed commands, or it can be bytecode like I described earlier
02:25:20 <ania123> ok, thanks
02:28:17 <geekosaur> (there are interpreters that interpret native machine code though. valgrind is the best known one)
02:33:19 <ania123> geekosaur, in the case when a compiler compails a program directly to machine code. 
02:33:51 <ania123> what kind of code is generated ?
02:34:28 <geekosaur> that's actually soemwhat complex. most compilers go through various stages, only producing native code at the end
02:35:10 <geekosaur> with gcc you get gcc's internal representation (s-expressions, sort of), then that is converted to assembly language, then it runs "as" to produce machine code
02:35:54 <hsk3> Cale, hey
02:35:55 <geekosaur> with clang it produces LLVM IR, then runs llc to produce LLVM bytecode, then optionally runs lld to produce native machine code (this can be deferred to the end, either for cluster use or for LTO)
02:36:45 <geekosaur> ghc produces ghc core, then STG, then cmm, then either LLVM IR or native machine code or ghc's bytecode
02:37:45 <hsk3> I understand it's good practice, for if-then-else, to put then-else at a deeper column than if.
02:37:45 <hsk3> Is it similarly good practice, for let-in, to put in at a deeper column than let?
02:38:20 <geekosaur> (cmm is essentially a simplified dialect of C intended as a compiler intermediate language. STG is a representation of an evaluation graph; see Simon Peyton Jones' STG paper for details)
02:38:24 <geekosaur> hsk3, it is
02:39:35 <geekosaur> in particular, layout can become confused if you indent to the same level (the DoAndIfThenElse extension relaxes this specifically for if/then/else in "do", but that does not help if you use them in "let" or "case" or other layout-inducing elements)
02:40:21 <hsk3> geekosaur I understand that "let", "do", "of", and "where" are layout keywords. Is "in" also a layout keyword?
02:40:34 <geekosaur> no
02:41:28 <geekosaur> the bindings in let ... in induce layout, so you can bind more than one name either by using explicit braces and semicolons or by indentation. the "in" has following it a single expression, so it doesn't need layout.
02:42:26 <hsk3> so, dude change your nickname :S
02:42:38 <geekosaur> ?
02:42:56 <hsk3> "so" is highlighting in my irc client because of this dude with this nickname lol
02:43:06 <hsk3> no big deal
02:47:12 <hsk3> geekosaur, so is this https://paste.ee/p/Su7Lj better than this https://paste.ee/p/YE0LU ?
02:47:21 <zaquest> are IO ops on Handle thread safe with line/block buffering on?
02:47:36 <zaquest> in a sense that they won't split lines
02:48:41 <ahri> i'm considering the architecture of a game i'm writing, and i need a way to randomly generate stuff. however i also like the clean world of pure functions, especially for testing - i.e. it can't be random in tests otherwise i can't easily make assertions. i don't really know how i can achieve this. how are these problems solved in haskell?
02:49:10 <ahri> so far all of my code is completely devoid of any IO
02:49:17 <suppi> ahri: you make a random seed in IO
02:49:23 <hsk3> ahri pseudo-random
02:49:29 <geekosaur> zaquest, buffering is process level, because Handles are process level
02:49:37 <suppi> and pass it to the pure function to use and create the world
02:49:42 <geekosaur> so threads operating on the same Handle will interleave
02:50:21 <ahri> suppi: so my tests would use the same seed every time
02:50:32 <suppi> ahri yes
02:50:51 <geekosaur> hsk3, what you wrote will work either way. if you were to use that inside the bindings of another let, or in a do, the second one would throw an error
02:51:25 <hsk3> geekosaur okay, but even if both work here, the former is still better practice?
02:51:31 <geekosaur> because the "in" would be interpreted as separate from your "let" and processed as part of the outer layout
02:51:40 <geekosaur> it is because it works consistently
02:51:53 <geekosaur> the second one will fail under some circumstances, as I described
02:52:20 <suppi> you don't even need the seed to be random :) then you always get them same generated world
02:52:49 <geekosaur> basically it's easier to stick to something that always works instead of needing to adjust the indentation depending on where you're writing it
02:53:07 <ahri> suppi: the only random thing is whether a powerup is dropped. it would be nice if in the test i can make it clear that a powerup of type X _will_ drop, rather than experimenting and then seeding with 1234 because it happens to get the behaviour i want; do you think there's a simple way to achieve this?
02:53:08 <geekosaur> nobody likes needing to remember special cases
02:53:45 <suppi> ahri pass true or false?
02:54:04 <hsk3> geekosaur cool. yet one question: isn't it pity that I have to break my "tab" = 4 spaces convention? Suddenly, I'm using only 2 spaces here. I have to pick 1, 2, or 3.
02:54:04 <hsk3> Unless I do https://paste.ee/p/Ftx8K or https://paste.ee/p/3j3YP which both look bad.
02:54:43 <suppi> pick a number, if it's even pass true if not false, etc.
02:56:17 <geekosaur> hsk3, could just indent by 1 space there. (that's my usual convention for let/in, because the *end* of "let" and of "in" then line up)
02:57:56 <hsk3> geekosaur ok i'll do that. still pity. i was hoping to consistently stick to 4 spaces or zero spaces.
02:57:56 <hsk3> oh well
02:57:56 <ahri> suppi: hm, ok, i'll have a play with actually generating random numbers and bear this in mind. thanks!
02:58:00 <geekosaur> (equivalently, the bindings line up with the expression that uses them)
02:58:43 <geekosaur> I actually vary a bit from something that strict; not just this case, but also I tend to indent "where" 2 spaces so the bindings attached to it are indented 4 spaces
02:59:07 <geekosaur> foo\n  where\n    bar = ...
02:59:08 <suppi> ahri good luck :)
03:01:29 <hsk3> geekosaur looks good actually
03:01:38 <hsk3> Thank you
03:03:51 <halogenandtoast> back, did we solve the compiler/interpreter thing?
03:04:22 <halogenandtoast> geekosaur: I indent the same.
03:04:34 <halogenandtoast> I haven't found any specific guidelines for indentation though.
03:04:49 <halogenandtoast> Or even newlines. I know some people have two newlines between function definitions.
03:05:18 <zaquest> geekosaur, sorry i don't understand what does it mean that Handles are process level?
03:05:56 <geekosaur> zaquest, it mans they do not belong to threads, they belong to the entire process
03:06:59 <geekosaur> this is necessary because on all operating systems ghc runs on and compiles for, the underlying OS construct is process level not thread level
03:07:12 <geekosaur> you cannot give a thread its own standard input, for example
03:08:02 <geekosaur> (standard input being defined as OS file descriptor 0 on both POSIX and Windows)
03:15:09 <Maxdamantus> Well, you could get into a different situation in Linux if you pass the right integer to SYS_clone
03:16:25 <eugenez> Hello, friends! Let's say I want to programm function that returns 2*x+1. I don't want to make it func x = 2*x +1, want it to be fancy func = ... I tried multiple variants, but the only one that worked ended up being func = (+) 1 . (*) 2, whick is less than readable and is very far from original math function. Can I get something like func = 2*<*> + 1 working?
03:18:58 <halogenandtoast> eugenez: ... maybe f = (1 +) . (2 *)
03:19:24 <halogenandtoast> is a little easier to read
03:19:53 <halogenandtoast> and (1 +) is just succ
03:20:47 <eugenez> halogenandtoast: Thank you!
03:21:02 <halogenandtoast> np.
03:21:21 <geekosaur> Maxdamantus, yes, I was leaving clone out of it because I'd kinda prefer to forget LinuxThreads ever existed. As would almost everyone else that had to suffer through them. :)
03:24:31 <zaquest> geekosaur, ah, that, i see, thanks.
04:25:20 <christiandiloren> I'm getting this error and I am not quite sure what is wrong: Pattern syntax in expression context:
04:25:20 <christiandiloren>         m -> manUsername m == u && manPassword m == p
04:25:56 <christiandiloren> It seems to be saying that I have some pattern matching syntax in here but I don't see it.
04:26:02 <christiandiloren> Any ideas?
04:27:32 <zaquest> ok, sorry, but i have to ask again :) if i have several threads that do hPutStrLn on a handle will the lines from different threads split each other? is it the same for bytestring's IO operations? does the length of the strings matter? what about hPutStr with manual newlines at the end (it appears to me that putStrLn acquires handle's mvar at least twice from looking at code in base)? i really dont want that manual synchronization if i can avoid it :)
04:27:53 <brynedwards> The 'm -> ...' is syntax used for pattern matching after a case statement
04:28:11 <brynedwards> Did you mean to do a lambda? add a \ before the m so it's \m -> manUsername m ...
04:29:13 <christiandiloren> Oh, doh! You would think I would have seen that! Thanks brynedwards.
04:29:20 <brynedwards> =)
04:35:41 <zaquest> TMR issue 19 has an article about mighttpd that says it's safe and lines won't be split. my tests show that lines are not split but that might be just luck...
04:36:22 <pacak> zaquest: With hPutStrLn you'll get a mix of those.
04:36:22 <pacak> Mixed letters.
04:36:28 <pacak> You can make them in sync by putting your handle into MVar
04:36:45 <Athas> zaquest: it is probably just luck.  IIRC, Michael Snoyman wrote a blog post recently about this issue (and why it should be changed to be line-based atomicity).  I'll see if I can get it up.
04:36:46 <pacak> ByteString or Text will give better results
04:36:51 <kuribas> zaquest: https://www.reddit.com/r/haskell/comments/5db3lj/haskells_missing_concurrency_basics/
04:37:29 <Athas> Yes, that one.
04:38:06 <kuribas> The opinions seem to vary on that one.
04:39:00 <Athas> Right, I also disagree myself.
04:39:06 <Athas> Synchronisation ought to be explicit.
04:40:49 <geekosaur> zaquest, it locks the Handle only long enough to manipulate the buffer. the problem there is that putStr/hPutStr becomes a series of putChar/hPutChar each of which locks the Handle for one character
04:41:22 <Athas> es
04:41:40 <geekosaur> zaquest, the usual way to handle this is to have a dedicated thread to write output to a Handle, and feed it chunks of the appropriate size (here, presumably lines) over a Chan (or maybe a bounded Chan, which you can find on Hackage)
04:44:39 <zaquest> geekosaur, i thought so from looking at the code, but i since it showed no signs of breaking lines i thought i missed something. also i might be wrong, but it seems that bytestring's hPut* functions are implemented differently and should be thread safe for at least lines <1024, do you know anything about it?
04:44:59 <geekosaur> not offahnd, I was speaking of System.IO
04:45:22 <geekosaur> I still would not want to trust it, although you seem to really want to trust it
04:45:50 <Athas> zaquest: I am quite sure that is an implementation detail.
04:45:58 <geekosaur> either you want to trust it that badly and therefore should just trust it and find out yourself, or you require correctness more than you require trust and you implement it safely to begin with
04:49:11 <systadmin> helo
04:53:23 <zaquest> Ok, thank you guys. Seems like that post mentions all I wanted to know. It just the knowledge that there's already an MVar in there that doesn't provide any usable thread safety it bugs me :)
04:53:38 <systadmin> How does the derive function work?
04:55:01 <liste> systadmin: what derive function?
04:55:20 <systadmin> liste: `derive (Ord)` something like that
04:55:38 <liste> systadmin: oh, the deriving mechanism
04:55:43 <systadmin> yep
04:56:00 <liste> http://stackoverflow.com/q/3864647
04:56:13 <systadmin> thank
04:56:27 <liste> also 
04:56:29 <liste> https://www.haskell.org/onlinereport/derived.html#derived-appendix
04:58:00 <geekosaur> zaquest, it does provide thread safety, insofar as two threads cannot modify the buffer associated with the Handle at the same time (this is necessary or flushing the buffer could write garbage or even dump core). It has nothing to do with output synchronization, nor does it have anything to do with synchronization of independent write operations
04:59:08 <systadmin> my head is melting on comprehending how deriving works
04:59:15 <geekosaur> C does this also but is also more prone to treat a single write-string operation as a single buffer manipulation (provided there is room in the buffer); System.IO doesn't have that optimization
04:59:20 <geekosaur> (perhaps it should...)
04:59:34 <liste> systadmin: it's implemented by the compiler
04:59:59 <liste> systadmin: so basically if you do data Foo = .. deriving (Eq) the compiler generates an Eq instance
05:00:14 <geekosaur> systadmin, currently it's wired into the compiler. the Report typeclasses have formulaic deriving expansions that ghc mostly follows as specified.
05:00:38 <systadmin> But what if I'm deriving more than one typeclass?
05:00:44 <geekosaur> 8.2.1 will have at least part of deriving strategies, which are intended to enable user-defined derivings
05:00:52 <liste> systadmin: then the compiler generates an instance of each you derive
05:04:08 <zaquest> geekosaur, yes, i understand that it's for buffer access synchronization, however since you still get garbage-ish output unless you use more synchronization it doesn't seem useful. i don't know anything about dump core case though.
05:04:51 <geekosaur> then that's your problem :)
05:06:09 <geekosaur> the usual I/O buffer implementation has pointers into what may be either a fixed or ring buffer. while the buffer is being updated, one or more of the pointers may not be valid as seen by other threads
05:06:32 <geekosaur> so the MVar ensures that any other threads see a consistent buffer state
05:07:28 <geekosaur> that is *all* it does. I don't know offhand if this can actually cause a core dump in ghc, although various things I have traced through seem to think the consequences of not having that mutex are fairly severe
05:08:39 <geekosaur> in at least some glibc versions, the corresponding stdio+iostreams buffers *can* cause core dumps without a mutex protecting other threads from seeing an inconsistent buffer state
05:09:55 <zaquest> geekosaur, if i understand things correctly it is enough to know the start of the buffer and it's length to not violate memory access, and both are constant after the buffer's allocation. so the only reason for that lock that i can see is too make the garbage less trashy :)
05:13:23 <geekosaur> zaquest, you do not understand things correctly unless you go through GHC.Handle source and probably parts of the RTS. or every relevant comment therein was outright lying.
05:13:40 <geekosaur> " various things I have traced through seem to think the consequences of not having that mutex are fairly severe" does not mean "oh, it can interleave output"
05:14:16 <geekosaur> the implication is crashes or deadlocks
05:25:23 * geekosaur wonders if his connection has stabilized yet :/
05:33:36 <zaquest> geekosaur, well, yes, one always can introduce crashes and deadlocks. but is it in general true that no correct (meaning garbage output is correct :)) implementation is possible w/o that lock? or is it just how ghc's runtime is implemented? am i missing something again?
05:34:00 <geekosaur> sorry, I guess I have to go read the whole implementation then?
05:34:05 <geekosaur> so I can answer yoi?
05:34:32 <geekosaur> but it is clear that you really really badly want to believe that the only possible issue is your output is not interleaved and ghc has a mandate to insure this for you
05:34:56 <geekosaur> and that there is no possible reason that not-crashing-or-deadlocking is the reason it would use an MVar
05:35:48 <geekosaur> so I can only say: go ahead and do what you want, since you know that what you want it to do is the only behavior it can possibly have
05:38:07 <zaquest> no, sorry, i didnt mean that. i just wonder if you know of any theoretical limitation that would prevent an implementation w/o the lock. sorry for bothering you.
05:38:29 <geekosaur> well, as you have determined that the reason I gave cannot possibly exist...
05:38:39 <geekosaur> again: since you know better, please go ahead and do whatever
05:39:29 <geekosaur> I will try to forget the comments that say that it is for correctness of buffer management, or try to reinterpret those comments as you have informed me that they must mean something else.
05:40:17 <zaquest> my english isn't good but i don't think i said something similar...
05:40:59 <geekosaur> what you said is you believe the only possible reason for MVar locking is to ensure that sequencing by lines occuirs
05:41:06 <geekosaur> because that si what uyou want
05:41:42 <geekosaur> which also invalidates anyone that is working with, say, a binary packet protocol, but I guess they don't matter either?
05:42:17 <geekosaur> in any case you are telling me you are convinced that the locking must support your specific use case
05:42:25 <geekosaur> and no other makes any sense at all
05:53:36 <halogenandtoast> Does anyone know if intero mode (or haskell mode) has a way to unindent after I double return?
05:56:39 <zaquest> geekosaur, no. why? what makes you think so? i wouldn't ask advice if i thought i know better. and i don't mean lines only (it's just my current case, which i figured and thanked you all for help), i mean atomicity of writing functions in general (hPut* in case of haskell). and since the point when i figured my case i was just wondering if it's possible to do it w/o the lock in general case (not only in ghc, or even haskell, which i tried to indicate 
05:56:39 <zaquest> by repeatedly saying "in general")
05:57:24 <geekosaur> zaquest, every time I tried to explain what the locks you were doing, you either declared it not relevant or apparently "wrong" because only your desired behavior is correct
05:57:28 <geekosaur> I'm done. Do whatever.
05:57:58 <geekosaur> If it breaksd, since you know what it Should Do(tm), report a bug against base.
05:58:37 <geekosaur> Stop bugging me because you don't seem to think anything I say is relevant unless it agrees with what you want.
06:02:17 <Cale> Sorry, what was the issue here?
06:09:55 <halogenandtoast> Cale: probably easiest just to read the log and search for zaquest
06:10:12 <halogenandtoast> The initial question was "are IO ops on Handle thread safe with line/block buffering on?"
06:10:35 <Cale> ah, yes they are, though you might not like the result.
06:11:08 <halogenandtoast> the follow up was a bit more complex
06:11:10 <halogenandtoast> "ok, sorry, but i have to ask again :) if i have several threads that do hPutStrLn on a handle will the lines from different threads split each other? is it the same for bytestring's IO operations? does the length of the strings matter? what about hPutStr with manual newlines at the end (it appears to me that putStrLn acquires handle's mvar at least twice from looking at code in base)? i really 
06:11:17 <halogenandtoast> dont want that manual synchronization if i can avoid it :)"
06:11:18 <zaquest> Cale, mine? my original question was about thread safety of operations on Handle (in particular about when they break lines) and whether I need explicit synchronization, but this is long solved. After that I was just wondered if it's (theoretically) possible to implement non-crashing non-deadlocking write ops w/o the buffer lock.
06:11:18 <Cale> You shouldn't really write to the same Handle from different threads, because while nothing will actually go wrong, you'll just make yourself a mess of the output.
06:11:19 <halogenandtoast> not my question
06:12:32 <Cale> Well, unless you do extra synchronisation -- but the easiest thing to do is just to make a simple thread whose sole job is to write things to the Handle, and then have other threads send it chunks of data to write.
06:12:33 <halogenandtoast> zaquest: I don't know of any language that allows you to write to the same handle in such a way that output might not overlap without some locking mechanism
06:12:38 <halogenandtoast> or maybe mailboxes in Erlang...
06:12:55 <halogenandtoast> What Cale is describing sounds like mailboxes in erlang :p
06:13:00 <halogenandtoast> to me at least
06:14:36 <halogenandtoast> This seems very reminiscent of the dining philosophers.
06:14:54 <merijn> Although doing manual locking in Haskell for this would be pretty easy too
06:14:54 <halogenandtoast> nvm, don't know why I said that.
06:15:06 <merijn> But the single thread per handle is easiest
06:15:15 <Cale> Well, kinda. It's simpler than that. You just have a Chan for a single type of message -- perhaps Text or ByteString or whatever it is that you want to write
06:15:43 <merijn> Cale: But then you have no way to close said channel to indicate being done, unless you use TChan
06:16:17 <merijn> Although I actually have a working closable channel with some other nice properties, but I'm still working on benchmarking it, as criterion isn't particularly good at these kinda benchmarks
06:16:22 <Cale> There are some other options there if you need that.
06:16:23 <merijn> So I'd have to fix criterion first >.<
06:16:31 <merijn> Thirty yaks later...
06:16:33 <Cale> Yeah, there's a package with a bunch of different variations on channels
06:16:38 <Cale> including closeable ones
06:16:49 <merijn> Cale: Most of the ones I've found are not as good as they could be
06:17:10 <Cale> https://hackage.haskell.org/package/stm-chans
06:17:32 <robertkennedy> If lambdabot interpreted its own output, can you think of a command to get it to loop?
06:17:35 <merijn> The STM ones are ok, but often want non-STM channels :)
06:20:08 <halogenandtoast> > (putStr . ap (++) show) "> (putStr . ap (++) show) "
06:20:11 <zaquest> yes, thank you guys. i actually used all these approaches, including stm-chans before. it's just i read in TMR issue 19 that Handle's buffer is MVar protected and that they don't use explicit synchronization in mighttpd for logging. So I decided to ask how reliable this is. Turned out it's more an implementation detail of bytestring package than a guarantee. After that I just wondered about the destination of Handle's buffer MVar and whether it is 
06:20:11 <zaquest> absolutely necessary to have a non-crashing buffering in general case or it's just GHC's implementation that needs it.
06:20:12 <lambdabot>  <IO ()>
06:21:07 <zaquest> necessary to have it for *
06:22:01 <robertkennedy> > ap (++) show "> ap (++) show"
06:22:04 <lambdabot>  "> ap (++) show\"> ap (++) show\""
06:22:14 <robertkennedy> Nice 
06:25:40 <halogenandtoast> lamdbabot is just too smart
06:26:20 <merijn> halogenandtoast: Mostly lambdabot has been tried and tested by hundreds of people over years, trying to find ways to break it ;)
06:28:43 <halogenandtoast> > ap main getLine
06:28:45 <lambdabot>  error:
06:28:45 <lambdabot>      • Variable not in scope: main :: IO (String -> b)
06:28:45 <lambdabot>      • Perhaps you meant ‘min’ (imported from Data.Ord)
06:29:14 <halogenandtoast> I'm not very creative
06:29:27 <halogenandtoast> I am surprised that there is no main though
06:30:33 <liste> lambdabot can't do IO
06:31:03 <halogenandtoast> That definitely solves a lot of problems
06:31:29 <Cale> > getLine
06:31:32 <lambdabot>  <IO [Char]>
06:34:53 <ski> @help run
06:34:54 <lambdabot> run <expr>. You have Haskell, 3 seconds and no IO. Go nuts!
06:38:47 <Cale> > text$ap(++)show"> text$ap(++)show"
06:38:51 <lambdabot>  > text$ap(++)show"> text$ap(++)show"
06:38:58 <Cale> A little closer ;)
06:42:12 <halogenandtoast> text$ap(++)show "> text$ap(++)show "
06:42:29 <halogenandtoast> > text$ap(++)show "> text$ap(++)show "
06:42:33 <lambdabot>  > text$ap(++)show "> text$ap(++)show "
06:42:35 <halogenandtoast> I assume you'd want the spaces
06:43:13 <halogenandtoast> > text$ap(++)show "\b> text$ap(++)show "
06:43:16 <lambdabot>  > text$ap(++)show "\b> text$ap(++)show "
06:45:54 <ogrady> http://lpaste.net/353594 I feel like this should be a one-liner. But I can't seem to figure out the right way to bind the result of `somethingMonadic` while returning.
06:46:48 <halogenandtoast> maybe f (foo t) = somethingMonadic t >>= (MyMonad.return . Bar)
06:47:40 <lyxia> Why is it MyMonad.return rather than return
06:48:09 <lyxia> Do you also have MyMonad.fmap? fmap Bar (somethingMonadic t) ?
06:48:18 <halogenandtoast> yeah I agree it should just be return...
06:48:29 <ogrady> lyxia: it could just be return as well, I guess.
06:49:00 <halogenandtoast> so: f (Foo t) = somethingMonadic t >>= (return . Bar)
06:50:02 <ogrady> Ah, that workd, great. Thank you. :)
06:50:07 <halogenandtoast> No problem
06:50:24 <lyxia> m >>= return . f    should be equivalent to    fmap f m
06:50:49 <ogrady> I am fairly new to haskell and I was under the impression that qualifying functions is good style. Therefore the MyMonad.return. Is that not the case?
06:51:02 <halogenandtoast> so f (Foo t) = Bar <$> somethingMonadic t
06:51:22 <halogenandtoast> ogrady: I would not qualify in that case
06:51:56 <Rotaerk> even if you do qualify it, wouldn't the qualification be Control.Monad.return
06:52:16 <halogenandtoast> Rotaerk: not if he did import qualified Control.Monad as MyMonad
06:52:17 <c_wraith> ogrady: anyway, qualification doesn't work like that.  You qualify things with the module they are defined in, and return is defined as part of the Monad class, not your instance
06:52:37 <Rotaerk> oh, I figured MyMonad was a particular monad instance
06:53:09 <ogrady> Ah, I see. I was already confused how a "thing" I have specified instances of different monads for knows "whos" return to call.
06:53:45 <halogenandtoast> ogrady: welcome to type classes
06:53:47 <ogrady> Coming from OOP, in case it wasn't obvious. :)
06:54:08 <halogenandtoast> ogrady: Ah this is a good test, I'm writing a talk called Haskell for Rubyists
06:54:25 <halogenandtoast> and step 1) is to explain a little math rules and step 2) is to explain type classes
06:54:46 <halogenandtoast> then build up Functor, Applicative, and Monad
06:56:00 <halogenandtoast> So I guess the question is... do you understand type classes?
06:56:17 <ogrady> I guess not.
06:56:53 <halogenandtoast> So I guess an easy, yet great example is (==) since it's pretty easy to understand
06:57:07 <halogenandtoast> You could do 1 == 2 or "foo" == "bar" and it works
06:57:34 <halogenandtoast> but mathematically speaking, we can't have some function foo that takes inputs from different domains.
06:57:46 <halogenandtoast> so how does (==) even work?
06:58:33 <ogrady> (I'm still with you, in case you're waiting for a response :) )
06:58:38 <halogenandtoast> Well in the OOP world, we could maybe do something with interfaces
06:59:10 <halogenandtoast> But in the functional world we essentially create a type class which allows us to defined a sort of interface
06:59:14 <halogenandtoast> for example
06:59:19 <halogenandtoast> class Eq a where
06:59:23 <halogenandtoast>   (==) :: a -> a -> Bool
06:59:40 <eschnett> one could define
06:59:48 <halogenandtoast> So Eq is a type class that requires you to defined (==) for your instance of that type class
07:00:16 <halogenandtoast> to make an instance for YourClass
07:00:24 <clamchowder> can I ask an sml question here
07:00:29 <halogenandtoast> instance Eq YourClass where
07:00:48 <clamchowder> Standard ML
07:00:51 <halogenandtoast>   (YourClass anInt) == (YourClass anotherInt) = anInt == anotherInt
07:01:27 <halogenandtoast> so with that instance defined I can now use (==) with something of type YourClass
07:01:49 <halogenandtoast> If you do :i Eq in ghci you can see a bunch of things have an instance defined already
07:01:56 <ogrady> Yes, that needed some getting used to syntactically for me. In OOP you define the datatype with all its operations. In Haskell you seem to define collections of operations and then bind them to whatever data you have.
07:03:26 <halogenandtoast> ogrady: Sure it is a different syntax, but I think it makes sense over time.
07:03:39 <halogenandtoast> It makes it easy to make existing classes adhere to your type classes
07:03:39 <nitrix> I'd word it as you define data types and regroup types with similar capabilities under a common type class that provides you with an interface for performing the supported operations on such types.
07:03:59 <ogrady> It does now more or less. But for me, coming from OOP, that made a big difference.
07:04:22 <halogenandtoast> ogrady: so the point here is that Monad is "just" a type class
07:04:29 <nitrix> Without type classes, you'd be writing a different function for each type and lose ad-hoc polymorphism.
07:04:46 <halogenandtoast> and `return` is part of that interface
07:04:47 <nitrix> eqInt, eqBool, eqString ...
07:05:00 <halogenandtoast> so if you have something that is an instance of Monad, it will have defined its own return
07:05:06 <halogenandtoast> and the correct one will be used
07:05:41 <halogenandtoast> check out :i Monad in ghci for some useful insight
07:05:43 <centril> I thought transformM (Control.Lens.Plated) was not supposed to cross type boundaries, but it seems to do that... I thought you were supposed to use transformOn biplate  for that...
07:05:54 <centril> how do I get it to not cross type boundaries?
07:06:51 <halogenandtoast> ogrady: I'm a Ruby programmer mostly so I've been down this road as well.
07:07:01 <centril> an example tree: data E = V String | I Int | E :+: E | E :*: E | EB B ; data B = B E   (and derive .., Typeable, Data) + instance for Plated
07:07:49 <ogrady> halogenandtoast: I guess that makes somewhat sense. I was under the impression that I could define instances for my data for multiple monads, like IO, Control... then the return would be ambiguous.
07:07:52 <centril> tried with: (EB $ B $ V "x" :+: V "x") :*: I 3  and it crosses type boundaries
07:08:29 <halogenandtoast> ogrady: IO is not a type class so you cannot define an instance for it
07:08:37 <clamchowder> Is there an SML REPL that has autocompletion from input history?
07:08:57 <ogrady> halogenandtoast: I see that now :)
07:09:22 <centril> ogrady: haskell picks the (>>=) and return/pure implementation based on unifying the constraints you have put via the type signature of your function, or it picks the most general one it can find based on other functions used
07:09:32 <`Guest00000> can i have a type synonym for a variable? e.g. have "f :: Syn -> Syn" and in other place "type Syn = a". the point is controlling mono-/polymorphicity from a single line, the type synonym definition
07:10:00 <ogrady> So thanks again. Everytime I come here I learn a new bit. I'm always amazed at how helpful the haskell community is in contrast to other PL communities. :D
07:10:17 <centril> `Guest00000: type Syn = a  <-- free variable a, should be bound by Syn, so type Syn a = a
07:10:23 <halogenandtoast> ogrady: Yeah I like it here usually, and I've found myself disenchanted with outers as well.
07:10:45 <halogenandtoast> *other channels
07:10:47 <centril> `Guest00000: unless a is a specific a, in which case you can do that
07:11:11 <`Guest00000> centril: aha, thanks. so if i want to have it, i need to insert ugly points everywhere?
07:11:41 <centril> `Guest00000: is  a   in type Syn = a  a general type variable or a specific data type?
07:11:54 <`Guest00000> centril: variable
07:12:20 <`Guest00000> i want to e able to quickly change whether Syn is variable or a specific type
07:12:25 <`Guest00000> from one line
07:12:36 <`Guest00000> s/from/in
07:12:42 <centril> `Guest00000: no, unless you use existentials like  type Syn = forall a. <apply a to something>
07:13:00 <`Guest00000> thanks
07:13:15 <`Guest00000> hmmm
07:14:42 <ocharles> Does anyone know how to extend hvr's travis script to override a package from Git source?
07:14:49 <ocharles> I currently depend on something that hasn't been released
07:15:32 <centril> ocharles: you need to drop cabal and go over to stack
07:16:02 <centril> ocharles: this might interest you: https://github.com/DATX02-17-26/DATX02-17-26/blob/dev/.travis.yml
07:16:06 <ocharles> ok, are there any examples you know of that I can steal a travis.yml from?
07:16:07 <ocharles> thanks!
07:16:54 <ocharles> Now to finally use stack for the first time :}
07:16:56 <centril> it doesn't use the fancy multi resolver stuff for having both GHC 7.10.3 + 8.0.2 + HEAD, but you can combine it with the hvr stuff to get that i guss
07:17:30 <ocharles> I'm fine with just building on 8.0.2 for now
07:17:47 <centril> then my link should do =)
07:18:03 <ocharles> yep, it looks good :) just need to write a stack.yml
07:18:34 <centril> and please don't use our slack hash :P (i dont know if it would work if you did...)
07:18:48 <centril> there's a stack.yml in the same repo you can steal
07:21:05 <ocharles> haha, I saw that key. it was tempting
07:21:20 <ocharles> but only if you guys fix the build for me
07:30:55 <Reisen> best way to format an `x :: Text` of a number with commas? I.E, "-192312313.23" -> "-192,312,313.23"?
07:33:22 <merijn> hmmm, I can't seem to find any locale aware function for numbers
07:33:48 <Reisen> Yeah, it seems like a bit of a void from googling
07:33:56 <Reisen> Might be time to write a package
07:38:28 <halogenandtoast> Any easy way to look up where certain operators come from trying to find <> and hoogle only has bad answers
07:38:53 <halogenandtoast> Ah found it in Data.Monoid
07:39:07 <halogenandtoast> Still want to know if there are any suggestions though
07:40:40 <merijn> There's also Hayoo
07:40:41 <Reisen> Try hayoo instead http://hayoo.fh-wedel.de/
07:41:08 <merijn> halogenandtoast: oh, <> from Monoid being skipped is kinda bad...
07:42:27 <halogenandtoast> Hayoo seems better
07:42:37 <halogenandtoast> as in it solves this problem
07:42:40 <riaqn> Hi, how do I define instance for (Show MVar)?
07:42:54 <c_wraith> riaqn: usually you don't
07:43:06 <riaqn> yeah, but how?
07:43:12 <merijn> riaqn: Why do you want it?
07:43:18 <riaqn> The problem is that one of my adt contains mvar
07:43:18 <c_wraith> riaqn: there's usually a reason if a type in base doesn't have a Show instance
07:43:20 <ocharles> you *could* have Show a => Show (MVar a) with unsafePerformIO, but I wouldn't recommend it
07:43:22 <merijn> riaqn: And what would you expect it to do?
07:43:31 <riaqn> and I'm defining Show for this ADT
07:43:39 <halogenandtoast> instance Show (MVar a) where show _ = "hello"
07:43:41 <ocharles> riaqn: you will probably have to write a custom Show instance
07:43:49 <merijn> riaqn: Well, why not print "<Mvar>" instead of trying to show the MVar?
07:43:54 <zaquest> halogenandtoast, there's command line hoogle utility, it shows Data.Monoid (<>) for me.
07:44:12 <riaqn> good suggestions guys, I can imagine that Show of MVar is impure.
07:44:33 <merijn> riaqn: Well, it depends on whether you're trying to show the MVar or it's contents
07:45:03 <halogenandtoast> zaquest: Good point! I'd much rather do this in the command line
07:45:25 <riaqn> merijn: yeah, I was trying to show the content.
07:45:27 <merijn> halogenandtoast: You can actually configure commandline hoogle to index whatever you want
07:45:37 <riaqn> but now I understand it's safer to just show "MVar"
07:45:53 <halogenandtoast> merijn: My made up programming language Dagon?
07:46:03 <halogenandtoast> The answer might be yes, but the result might not be what i want.
07:46:09 <riaqn> hmm, but how about showing the memory address? that way at least I know if two MVar is at least the same thing.
07:46:17 <merijn> halogenandtoast: I meant which packages you want :)
07:46:24 <halogenandtoast> riaqn: You can look at the Eq instance
07:46:28 <merijn> halogenandtoast: Standard Hoogle indexes only PART of all hackage packages
07:46:46 <halogenandtoast> riaqn: instance Eq (MVar a) where (MVar mvar1#) == (MVar mvar2#) = isTrue# (sameMVar# mvar1# mvar2#)
07:46:46 <merijn> halogenandtoast: The local install you can configure to index all packages you want, including ones not covered in regular Hoogle
07:46:53 <halogenandtoast> there be same dank code
07:47:11 <riaqn> halogenandtoast: the problem is that I'm not interested in the equality of two specific MVars.
07:47:24 <riaqn> but instead, in general, I hope to spot the equlity if there is one.
07:47:33 <riaqn> when I'm showing the ADT.
07:48:03 <halogenandtoast> given `data MVar a = MVar (MVar# RealWorld a)` I don't know that you can...
07:48:09 <halogenandtoast> but I'm bad at this
07:48:44 <merijn> *can* you do it, yes, but it will involve very brittle, dangerous and ugly code :)
07:48:58 <riaqn> merijn: yeah I understand. any hint?
07:49:05 <merijn> I mean, there's not a lot you *can't* do with GHC haskell, including lots of horrifically dangerous things
07:49:24 <halogenandtoast> merijn: you have my attention.
07:49:31 <merijn> Presumably you can get an Addr# from MVar# which you can (potentially via Ptr) turn into integer and print
07:49:34 <riaqn> to be honest I don't understand why MVar just doesn't include the Show instance which prints the address.
07:49:40 <riaqn> should make perfect sense.
07:50:06 <merijn> riaqn: Because generally Show is expected to output syntactically valid Haskell
07:50:16 <riaqn> ahh I see.
07:50:31 <riaqn> merijn: so any working code? I know nothing about low-level details of GHC
07:50:38 <merijn> halogenandtoast: Well, first, disclaimer: Lots of stuff in here is horrifically dangerous and can instantly remove all the safety Haskell gives you, so...Here there be dragons
07:50:47 <merijn> halogenandtoast: But, have a look at GHC.Prim: https://hackage.haskell.org/package/ghc-prim-0.4.0.0/candidate/docs/GHC-Prim.html
07:51:05 <merijn> halogenandtoast: If you like low level C/ASM stuff, there's lots of cool stuff there :)
07:51:40 <halogenandtoast> merijn: Oh nice, I always wondered where this stuff lived, but never took the time to find it.
07:51:47 <halogenandtoast> I like compilers/interpreters
07:52:01 <halogenandtoast> so this aspect of haskell was interesting to me (but not enough to look it up apparently)
07:52:19 <merijn> halogenandtoast: Oh, in that case there's also an excellent intro paper to how you can compile Haskell
07:53:13 <halogenandtoast> is that GHC-Prim page huge, because Chrome chokes on it
07:53:23 <merijn> halogenandtoast: The STG paper provides a (by now somewhat outdated) explanation of how one can compile a lazy functional language to a normal machine: http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.53.3729&rep=rep1&type=pdf
07:53:25 <halogenandtoast> sorry I meant the source
07:53:50 <merijn> halogenandtoast: The source is huge yes, but it does open fine in Chrome for me
07:54:14 <merijn> halogenandtoast: That paper requires only minimal Haskell knowledge and a little bit of familiarity with C/asm, callstacks, etc. won't hurt
07:54:45 <merijn> It's a bit dated compared to actual GHC, but it's good starting point
07:55:04 <halogenandtoast> merijn: Thanks I'll give it a read
08:25:26 <_deepfire> given a cabal file that defines both a library, and an executable that depends on it -- what makes cabal recompile the library-exposed modules the second time for the executable?
08:25:39 <ogrady> Alright, now I have a similar problem to before, but I need to bind a whole list of monadic values. I imagined something like http://lpaste.net/353599 would do the trick, but apparently not.
08:27:27 <merijn> _deepfire: You probably have the library and executable source in the same directory?
08:28:18 <merijn> _deepfire: GHC doesn't realise it's supposed to use the exports from the library when a file is doing "import Foo" in a directory that contains Foo
08:28:52 <merijn> _deepfire: The solution is to move the library and/or executable to a different sub directory and specifying a hs-source-dir (or whatever the right field name was)
08:29:55 <_deepfire> merijn: you are right, indeed
08:34:26 <_deepfire> merijn: it worked like a charm!
08:34:34 <_deepfire> merijn: thank you!
08:35:16 <merijn> _deepfire: np :)
08:40:10 <_deepfire> now if only ghc-plugin-natnormalise didn't cause spurious recompiles due to https://ghc.haskell.org/trac/ghc/ticket/12567 ...
08:40:21 <halogenandtoast> ogrady: what is the data constructor for Bar there?
08:41:00 <merijn> ogrady: Needs more types
08:41:11 <merijn> ogrady: I have no idea what the type of everything there is
08:41:35 <merijn> What's 'x', 'xs', 'Bar' and 'somethingMonadic'?
08:41:45 <ogrady> Well, maybe it would help more if I'd post something that actually works: http://lpaste.net/353600
08:42:03 <ogrady> Works and all. But I think that again this could be a one-liner.
08:42:05 <halogenandtoast> O_o
08:42:15 <halogenandtoast> why do you hate me
08:42:26 <ogrady> I don't tho! D:
08:42:42 <halogenandtoast> says he doesn't hate me, uses ττ
08:43:05 <merijn> ogrady: Isn't it just "Q.TyFun <$> mapM ττ ts <*> ττ t"?
08:43:08 <ogrady> That's actually two τs. :D
08:43:42 <halogenandtoast> merijn:  it is
08:44:56 <halogenandtoast> ogrady: I have no idea what a τ is so I'm already convinced you don't like me.
08:45:07 <halogenandtoast> If I can't type it with my keyboard currently, I don't want it.
08:45:57 <ogrady> Ah, yes, works great. Thanks! I have to read up more on those weirdly named functions. halogenandtoast welcome to my world where I have to figure out why on earth things are named "<*>". D:
08:46:22 <halogenandtoast> That just the infix version of apply
08:46:26 <monochrom> Inspired by Star War spaceships.
08:46:31 <merijn> ogrady: Not really any specific reason for that name, honestly. It's an operator mostly since that reads nicely
08:47:21 <halogenandtoast> merijn: that and it works well with <* and *>
08:47:26 <ogrady> halogenandtoast: It's a tau and actually makes sense in my context. My boss is kinda in love with unicode and the such. Didn't bother to rename it in the paste as I didn't think it would be a problem.
08:47:34 <halogenandtoast> well in distinguishing them...
08:47:53 <halogenandtoast> ogrady: I looked it up, it's overloaded
08:48:12 <halogenandtoast> 7 definitions for mathematics, and 9 in Physics
08:48:21 <halogenandtoast> because f both of those fields :p
08:48:28 <ogrady> merijn: that I get. And it probably really reads nicer than a fully fledged word. But it really gives me a hard time when I have that backwards lookup of "now which operator did that thing again..."
08:48:43 <merijn> ogrady: That's why we have Hoogle :)
08:48:55 <halogenandtoast> ogrady: You will use <$> and <*> so often that will quickly go away
08:48:59 <merijn> @hoogle f (a -> b) -> f a -> f b
08:49:08 <lambdabot> Control.Monad.Compat (>>=) :: m a -> (a -> m b) -> m b
08:49:08 <lambdabot> Data.GI.Base.ShortPrelude (>>=) :: m a -> (a -> m b) -> m b
08:49:08 <lambdabot> Monad (>>=) :: m a -> (a -> m b) -> m b
08:49:16 <merijn> But yeah, Applicative is so common you will know it off the top of your head
08:49:23 <merijn> That's...unhelpful, lambdabot
08:49:26 <halogenandtoast> lol
08:49:28 <ogrady> Huh, right. I could have entered the signature there. Didn't even occur to me.
08:49:30 <halogenandtoast> perfect example!
08:49:51 <ogrady> ...well.
08:50:11 --- mode: shapr set -o shapr
08:50:21 <halogenandtoast> honestly step 1, write those two type signatures on a piece of paper next to you
08:50:28 <halogenandtoast> step 2, look at paper
08:51:09 <halogenandtoast> Sounds dumb, works very well when you are learning
08:51:31 <halogenandtoast> Also... wait until you get to lenses
08:51:40 <ogrady> now, where do I fit "fear-vomit uncontrollably and procrastinate for half an hour" in there?
08:52:16 <halogenandtoast> ogrady: when you don't have one of those two type signatures
08:53:08 <shapr> halogenandtoast: I have a bunch of those dumb but helpful tricks.
08:54:18 <halogenandtoast> Okay I should really both walk my dog and then go to sleep
08:54:23 <halogenandtoast> it's almost 1 am here.
08:54:29 <shapr> I should do real work, it's almost noon here
08:54:42 <halogenandtoast> shapr: Nah, real work is for 1am
08:54:51 <shapr> psh, I wish
08:55:06 <orion> shapr: What do you do?
08:55:22 <shapr> orion: I write Python for pindrop.com
08:56:07 <halogenandtoast> shapr: my sympathies, unless you like python, in which case... "cool"
08:56:38 <shapr> I'd rather be writing Haskell
08:56:45 <merijn> shapr: Story of my life
08:56:57 <merijn> shapr: I thought I'd safe time by using python libraries
08:57:05 <shapr> But that's why I stay up late, to write Haskell code :-)
08:57:11 <merijn> shapr: Long story short as of next week I'm rewriting all this python into Haskell :p
08:57:17 <shapr> merijn: sounds great!
08:57:19 <halogenandtoast> shapr: I have the same problem, except I write ruby instead of python
08:57:36 <shapr> Hopefully I can jump to a Haskell job soon.
08:59:27 <halogenandtoast> I tried starting my own company initially in rails, rewrote it in haskell, got stuck, rewrote it in elixir, and then finally gave up again and rewrote it in rails
08:59:42 <shapr> halogenandtoast: what got stuck?
08:59:52 <shapr> I'd be interested in what could improve Haskell
09:00:18 <halogenandtoast> shapr: I believed haskell to be the correct technical choice, but it was hard to do things like nested forms with associated data.
09:00:54 <halogenandtoast> Mainly because Yesod wanted them to be type safe
09:00:55 <shapr> I haven't done any recent webdev with Haskell, I should fix that.
09:01:20 <halogenandtoast> shapr: if you want to see a simple app example in Yesod, I always enjoy touting https://github.com/halogenandtoast/nhk-reader-haskell
09:01:31 <orion> merijn / shapr: What percentage of people in this channel do you think do Haskell professionally?
09:01:35 <merijn> halogenandtoast: How comfortable with Haskell? (i.e. I have a fun pointer, but it won't make sense if you're still like complete beginner)
09:01:40 <Cale> shapr: Be sure to have a look at Reflex-DOM :)
09:01:51 <shapr> halogenandtoast: ah, I've seen that before. But I still can't read any of it :-(
09:01:58 <merijn> orion: Honestly, no real clue
09:02:09 <Cale> https://www.youtube.com/watch?v=dOy7zIk3IUI
09:02:18 <shapr> orion: I'd guess at least 25%, there are quite a few Haskell jobs
09:02:25 <halogenandtoast> merijn: I'm probably in the middle. I can solve a lot of problem until they get into libraries I haven't used...
09:02:34 <merijn> shapr: True, OTOH a lot of people with Haskell jobs aren't here :)
09:02:54 <merijn> halogenandtoast: If you like type safety and web development (and also a lack of documentation :p) you should have a look at Ur/Web
09:02:59 <shapr> merijn: yes, also that
09:03:07 <merijn> halogenandtoast: http://www.impredicative.com/ur/
09:03:14 <halogenandtoast> merijn: I looked at it, I needed better/more examples
09:03:21 <orion> shapr: I just applied to a Haskell job and got rejected. :(
09:03:38 <shapr> orion: have you written a bunch of Haskell?
09:03:51 <orion> shapr: Yes.
09:03:53 <shapr> My most recent Haskell inerview asked me what libraries I've created and/or maintained.
09:03:58 <halogenandtoast> merijn: I looked at http://www.impredicative.com/ur/todomvc/ for example
09:04:08 <shapr> orion: Is your Haskell source up on github?
09:04:16 <orion> shapr: https://github.com/centromere
09:04:54 <shapr> orion: In that case, apply for more Haskell jobs?
09:05:03 <orion> I will.
09:05:08 <merijn> Where did you interview?
09:05:12 <orion> merijn: Takt.
09:05:51 <orion> The company was going to be using Haskell to work with artificial intelligence. I was very sad to have missed that opportunity.
09:06:08 <shapr> orion: there are more opportunities!
09:06:30 <ystael> this seems like a good time to mention my company (in Boston) is looking for one more back end developer, we have a mix of Python and Haskell
09:07:30 <halogenandtoast> ystael: I used to live in Boston
09:07:40 <orion> ystael: On site?
09:07:54 <halogenandtoast> as in I lived in Boston last year.
09:07:55 <ystael> orion: Yes, local only for the dev team for now, sorry
09:08:06 <ertes> what's the clean way to get GHC 8 on debian 8?
09:08:16 <ertes> the not-compiling-yourself way
09:08:25 <halogenandtoast> ertes: step 1) install a better OS
09:08:30 <halogenandtoast> I kid
09:08:49 <orion> ystael: May I PM you?
09:08:56 <halogenandtoast> ystael: Is your company one I would have heard of?
09:08:56 <ystael> sure
09:09:13 <MarcelineVQ> ertes: iirc, there's an unstable package manager option for newer things, e.g. the list here  https://packages.debian.org/search?keywords=ghc
09:09:16 <ertes> halogenandtoast: i'm one nuisance away from installing nix and bypassing apt entirely
09:09:26 <ystael> halogenandtoast: Maybe not, it's a relatively young startup: http://www.tvisioninsights.com/
09:09:38 <MarcelineVQ> er, or, is the name the debian flavor?
09:10:14 <halogenandtoast> ystael: ... you have a japanese website?
09:10:49 <halogenandtoast> I ask because I live in Tokyo
09:11:21 <ystael> We have a Japanese partner company, yes, but the tech team is all in Boston
09:11:33 <halogenandtoast> I see
09:11:43 <bennofs> ertes: I have idea but http://downloads.haskell.org/debian/ sounds promising?
09:12:10 <bennofs> s/idea/no idea
09:13:11 <ertes> well, every clean way seems to imply adding sources for another debian version
09:13:23 <halogenandtoast> Oh well, I'm not moving back to the US any time soon.
09:13:50 <bennofs> ertes: that page says "Debian 8"
09:13:56 <halogenandtoast> You guys can't seem to keep your president in line. I'm fine here with my prime minister and emperor
09:14:08 <ertes> oh, wait
09:14:11 <merijn> orion: Also, are you willing to relocate?
09:14:12 <ertes> that's a haskell-only source
09:14:16 <ertes> bennofs: thanks!
09:14:52 <orion> merijn: I live in New Hampshire. I am unwilling to relocate at this time.
09:14:58 <fizbin> Is there any way to express the constraint "This type constructor F needs to have an Ord instance for (F b) whenever b has an Ord instance"?
09:15:42 <merijn> orion: Ah, because Standard Chartered is basically always hiring people in Singapore, I think. But that doesn't help if moving is not an option :)
09:15:42 <erisco> F :: Ord b => b -> F b  perhaps?
09:15:49 <halogenandtoast> orion: NH, that's a tough sell, I can't imagine a lot of Hakell going on there.
09:16:06 <bennofs> fizbin: sounds like something that'd only be possible with the `constraints` package and working with constraints explictly
09:16:29 <orion> halogenandtoast: That's why working remotely is key. I save thousands of dollars by not needing to drive in to work every day.
09:16:32 <bennofs> fizbin: hmm or wait. How about f :: (forall b. Ord b => Ord (F b))
09:16:43 <bennofs> fizbin: that should work
09:16:49 <orion> And living in a huge city like Boston is stressful and sucks the joy out of life.
09:16:50 <halogenandtoast> orion: I ride a train, or work from home with my job, it's just not haskell... yet
09:17:13 <halogenandtoast> orion: everyone likes different things
09:17:17 <halogenandtoast> Tokyo is my dream city
09:17:18 <fizbin> bennofs: Huh. Maybe.
09:17:19 <erisco> I don't know what that syntax means oO
09:17:45 <bennofs> erisco: It means: given an Ord instance for b, I can give you an Ord instance for F b
09:18:09 <lyxia> it's not Haskell though
09:18:31 <erisco> bennofs, but you have put Ord (F b) in a position where a type is expected
09:18:56 <halogenandtoast> erisco: don't worry, I think you need the ExistentialQuantification language extension
09:19:04 <fizbin> bennofs: Yeah, I don't understand how to make that syntax work.
09:19:05 <halogenandtoast> so you might not have seen/used it before
09:19:07 <erisco> what you can do is  f :: Ord b => (Ord (F b) => r) -> r
09:19:07 <bennofs> hmm not sure, I swear I've seen something like that
09:19:12 <bennofs> erisco: ah right
09:19:22 <halogenandtoast> fizbin: you need to use the ExistentialQuantification language extension.
09:19:40 <fizbin> erisco: Except how do I put that as a constraint on a function's input types?
09:19:41 <bennofs> halogenandtoast: don't think it'll work even with that ext
09:19:46 <halogenandtoast> probably not
09:19:56 <erisco> fizbin, f is a function, so I am not sure what you're asking
09:20:30 <bennofs> fizbin: you could do: (forall b. Ord b => Dict (F b))
09:20:30 <lyxia> fizbin: constraints has a type (:-), such that a value of type (Ord b :- Ord (F b)) represents the constraint you want. You have to pattern match on it explicitly when you want to use it though.
09:20:46 <bennofs> fizbin: where Dict is from the `constraints` package
09:21:15 <fizbin> What I want is something like: myFunction :: forall b, gr, f. (MyDynGraph gr, Ord b, (forall q. Ord q => Ord (f q)), Functor f) => ...
09:21:33 <ertes> f :: (forall a. Ord a => Dict (F a)) -> …
09:21:37 <ertes> something like that?
09:21:41 <ertes> whoops
09:21:46 <ertes> f :: (forall a. Ord a => Dict (Ord (F a))) -> …
09:21:48 <bennofs> fizbin: yes, you'd need to write that as: (...) => (forall a. Ord a => Dict (Ord a)) -> ...
09:22:12 <bennofs> fizbin: and call it like: myFunction Dict
09:22:49 <ertes> or better:
09:22:56 <ertes> f :: (forall a. Ord a => proxy a -> Dict (Ord (F a))) -> …
09:23:20 <bennofs> ertes: why's that better?
09:23:32 <fizbin> bennofs: That doesn't make sense to me; I don't understand what "Ord a" means as a type.
09:23:42 <ertes> bennofs: makes using that function nicer =)
09:23:45 <fizbin> I know what "Ord a" means as a type constraint.
09:24:04 <bennofs> fizbin: it's the ConstraintKinds extension, which allows using constraints in types
09:24:08 <ertes> f liftOrd = case liftOrd (Proxy :: Proxy a) of Dict -> …
09:24:30 <erisco> I assume Dict does not take a type, it takes a constraint
09:24:35 <ertes> or even:  f liftOrd x = case liftOrd (pure x) of Dict -> …
09:24:38 <bennofs> fizbin: you can do stuff like: data Foo c where Foo :: c => Foo c
09:24:47 <bennofs> fizbin: where c has kind Constraint
09:25:42 <ertes> fizbin: Dict can only be constructed when the required constraint is satisfied (i.e. the instance is in scope, or a type equality actually holds)
09:26:08 <ertes> fizbin: whenever you pattern-match on that Dict, you get that constraint to the RHS of "->" by virtue of type refinement
09:26:25 <erisco> virtuous type refinement
09:26:40 <ertes> case myDict of Dict -> {- the constraint is satisfied here -}
09:29:34 <ertes> fizbin: note that the forall variant is basically equivalent to requiring:  instance (Ord a) => Ord (F a)
09:29:59 <fizbin> Which is what I actually wanted to require.
09:30:36 <ertes> do you abstract over F?
09:31:22 <fizbin> I do. What I actually need is Ord (f (SomeAnnoyinglyComplicatedTypeIdRatherNotBurdenCallersWith))
09:31:32 <tabaqui1> what's is a current status of cabal/stack test modules?
09:31:44 <merijn> God, I wish Python has 1) Monoids and 2) monoid instance for functions...
09:31:55 <tabaqui1> I want to write test-suite, but detailed-0.9 looks a little bit old for me
09:32:19 <erisco> it sounds like you want Python to have type classes
09:32:34 <ertes> it sounds like you want to write haskell instead =)
09:32:55 <tabaqui1> and documentation for both types (+ exitcode-stdio) is confusing
09:33:06 <merijn> ertes: I do :(
09:33:12 <erisco> can't you dynamically extend types with magic getters? maybe that is another language
09:33:55 <fizbin> One can do "this object now behaves sort of like a function" magic with python __call__ methods.
09:33:57 <erisco> you can define <> to lookup a predefined attribute on the operands
09:34:01 <erisco> where this attribute is the implementation
09:34:07 <merijn> ertes: I guess I'll handcode a hacky monoid :\
09:34:10 <erisco> or you can keep a global table of type to implementation
09:34:39 <fizbin> merijn: You can even override __add__ and use "+" for your monoid's operation.
09:34:59 <erisco> gross
09:35:34 <erisco> every time a programmer overloads + with a function that is not associative and commutative a kitten dies
09:36:12 <fizbin> erisco: So, every time + gets used for string concatenation?
09:36:14 <ertes> merijn: i can't imagine how that would be remotely as convenient as in haskell
09:36:22 * erisco throws up a little
09:36:33 <ertes> even if i ignore the fact that you don't get infix operators
09:36:48 <fizbin> I mean, + as string concatenation is really, really common.
09:36:57 <merijn> ertes: It's not, but I don't have time to rewrite everything in Haskell before the paper deadline, sadly :)
09:37:45 <ertes> well, i suppose you could use instance arguments or even the global table erisco mentioned
09:37:56 <ertes> at least python does support functions
09:38:25 <erisco> mempty is an issue because you don't get any inferred type information
09:39:02 <erisco> but you can have it take a type as an argument, or however Python does that
09:41:26 <fizbin> But I'll point out that an advantage of making + your monoid operation (with __add__) is that then "sum" is mconcat.
09:45:58 <erisco> sounds like duck type programming
09:46:07 <erisco> I guess you're being Pythonic
09:48:42 <erisco> fizbin, do you know the rules, by the way?
09:49:54 <fizbin> "the" rules? That's awfully broad.
09:50:53 <ski> @quote the.rules
09:50:54 <lambdabot> sarah says: "But I don't _want_ functional programming!" -- Sarah Peyton Jones, age 11, upon hearing the rules of Go
09:51:53 <erisco> fizbin, I thought Kirk maybe told you
09:53:14 <fizbin> erisco: That's with two "z"s. Common mistake.
09:53:57 <erisco> I object, because he didn't write it out, he just spoke the word
09:55:56 * ski . o O ( "... of misfortune" )
09:55:57 <centril> stack build is giving me:  .stack-work\dist\ca59d0ab\build\JAA\JAA-tmp\Normalizations.o:fake:(.data+0x98): undefined reference to `DATX021726zm0zi1zi0zi0zm2MQgTHUfheZZ7igIDVIIrIF_NormziNormM_unique_closure'
09:56:27 <centril> `gcc.exe' failed in phase `Linker'. (Exit code: 1)
09:57:25 <lpaste_> Centril pasted “stack undefined reference” at http://lpaste.net/353603
09:57:54 <MarcelineVQ> centril: did you forget to add a module to exposed-modules or other-modules?
09:58:09 <centril> MarcelineVQ: probably
09:58:23 <centril> That error message needs to be improved tho =)
10:00:08 <centril> MarcelineVQ: thanks, that worked
10:01:03 <hits1911> I have main = interact $ (show . f . read). The function "f" does the processing of input and returns a data. Is there a simpler way to do this like without show and read etc. For instance, main = X f ?
10:02:34 <Cale> hits1911: Well, if you lose the show and read, then f will be expected to take and produce a String
10:08:20 <hits1911> Couldn't be a function as foo :: (a -> b) -> IO (). Reading the input and feeding it to the function it takes as argument, converting the result to String and so on.
10:08:38 <Cale> hits1911: You could of course define one
10:09:16 <Cale> foo :: (Read a, Show b) => (a -> b) -> IO ()
10:09:32 <Cale> foo f = interact $ show . f . read
10:10:49 <hits1911> Cale: looks simple enough. thank you.
10:19:22 <erisco> that looks scary
10:25:11 <rps_>  I've been learning Haskell for about 3 months now. It's a lot of fun learn the language and I really enjoy reading the papers about the theory behind the language.
10:25:22 <rps_> But I get discouraged about its practicality for me. After 3 months, I still have problems thinking about how to program something that's useful. 
10:25:48 <rps_> What was the "hump" that you got over where you felt like you can program things that are useful? 
10:28:27 <cocreature> rps_: for me it was quite simple: reduce the amount of time reading and just write some code :)
10:28:30 <lep-delete> you don't learn programming by reading only
10:28:42 <koala_man> rps_: for me it was writing things that are useful, even if they didn't leverage Haskell much. I kept seeing ways things could be improved, and I still do. 
10:29:30 <cocreature> it’s easy to fall into the trap of reading and reading and never writing code because Haskell is sufficiently different from other languages that doing a bit of up-front reading is usually a good idea
10:32:42 <rps_> Yeah, I feel like I'm in that reading trap, ha
10:33:04 <cocreature> I’ve fallen into that trap myself :)
10:34:02 <rps_> I'll usually write something, get a compile error, and then read about why the compiler wouldn't allow that for a half hour
10:35:16 <ezyang> I wonder if CS did it all again, what we call "Set" should really be "PowerSet" 
10:35:18 <rps_> Even if it's reading through documentation for a library, I find myself hitting a wall of understanding
10:36:25 <rps_> I'll just try writing more code. If I have any specific questions, I'll come back here and ask them.
10:36:29 <rps_> Thanks for the suggestion
10:37:47 <ski> ezyang : as in `Data.Set.Set' ?
10:38:06 <ezyang> yeah 
10:38:26 <ezyang> or maybe it's OK to name types after "individual examples" of the construction in question 
10:39:06 <ski> "an `Integer'"
10:39:36 <ski> (as opposed to the set of `integers'. iirc they used that convention in Pascal ?)
10:39:36 <ezyang> touche 
10:40:04 <ski> it could still be `Subset Integer', though
10:40:26 <ezyang> Well, {1,2,3} is certainly "a set of integers" 
10:40:39 <ski> a subset, i'd say :)
10:40:52 <ski> (material vs. structural sets)
10:44:30 <Apocalis_> I've a monad stack like StateT k (StateT p (LoggingT (ExceptT e IO))), and I'd like to convert the concrete stack to an mtl constrained monad. How can I represent the two state monads?
10:45:19 <ezyang> "Poorly" 
10:45:55 <ezyang> you might consider the technique in http://blog.sigfpe.com/2010/02/tagging-monad-transformer-layers.html 
10:46:01 <Apocalis_> my thought was to combine them into MonadState (k,p) and just Lens into the part I'm interested in
10:46:06 <ezyang> another possibility is to combine the two state transformers together to StateT (k, p) 
10:51:45 <dolio> The answer is, in a sense, always that you used named references of some sort.
10:52:09 <dolio> With multiple StateTs, you're using a sort of de Bruijn notation.
10:52:21 <monochrom> Yes, you may actually be better off with (MonadState (k,p) m, MonadLogging m, MonadError e m, MonadIO m)
10:52:38 <dolio> With a compound state your references are the projection functions, or lenses, or something like that.
10:53:42 <dolio> In something like ST you can allocate new references dynamically.
10:55:34 <dolio> Some extensible effects stuff might allow you to use the type of the state as the reference 'name' (one cell per type), but I don't think that's actually a very good idea.
10:56:32 <kadoban> Is there a function for "choose exactly k values from a list" (or a range) in all ways, similar to how permutations works, except ... not permutations.
10:57:05 <mohsen_> What does /= operator do?
10:57:20 <kadoban> mohsen_: It's "not equal", the opposite of ==
10:57:22 <shapr> kadoban: how would your thing be differnt from permutations?
10:57:30 <shapr> > 1 /= 1
10:57:34 <lambdabot>  False
10:57:35 <ski> @src (/=)
10:57:36 <lambdabot> x /= y = not (x == y)
10:57:38 <shapr> > 1 == 1
10:57:41 <lambdabot>  True
10:57:57 <shapr> hej Einwq, god morgon
10:58:14 <kadoban> shapr: Because the elements of the output list are exactly k elements long, not the same length as the original list. I can of course write that in terms of permutations, but it's pretty awfully inefficient
10:58:31 <kadoban> I can write it directly too I guess, but if I don't have to ...
10:58:47 <dolio> I don't know of any predefined function that does it.
10:58:57 <mohsen_> Thanks guys
10:59:09 <kadoban> Alrighty, thanks.
10:59:11 * ski would try using `StateT [a] []'
10:59:17 <mofasa_> IS there any way to figure out what pattern(s) is missing in a non-exhaustive pattern match? 
10:59:45 <ezyang> mofasa_: Usually it's obvious by inspection 
10:59:54 <kadoban> ski: Hmm, I'll give that a try.
10:59:59 <glguy> mofasa_: Often the answer is in the next line of the error message
11:00:00 <shapr> mofasa_: you could add an underscore pattern at the end, and have that call error with the output
11:00:00 <mofasa_> ezyang: usually ..
11:00:10 <ezyang> paste it? :) 
11:00:15 <glguy> (if warnings are turned on)
11:00:26 <shapr> mofasa_: foo a@_ = error $ "did not expect " <> show a
11:00:40 <glguy> Don't even need the @_
11:00:55 <shapr> oh right
11:01:03 <ertes> mofasa_: if you use -W or -Wall, GHC will tell you which patterns are missing
11:01:32 <ski> kadoban : nondeterministically decide whether to use or discard the next element. if you know the input length beforehand, you can also prune when there's not enough remaining elements
11:01:59 <kadoban> Yeah, seems like it makes sense
11:03:33 <mofasa_> How to compile a non-stack project with Stack and use compiler args? `stack ghc MyFile.hs` works but `stack ghc -- MyFile.hs -Wall` gives no output at all
11:04:59 <kadoban> stack ghc -- --make -Wall MyFiles.hs    should work, though 'stack ghc' is rarely needed. Is this a cabal-install project? You should usually do 'stack init' and then 'stack build'
11:05:37 <shapr> burdges: jeff?
11:05:47 <mofasa_> It's just a couple of lonely hs files (school homework) without external dependencies 
11:06:05 <shapr> In that case, kadoban's --make suggestion is best
11:06:17 <ertes> mofasa_: also you could just use GHC
11:06:31 <ertes> ghc -Wall blah.hs
11:06:33 <shapr> Apocalisp: your clone was here earlier asking about monad transformers :-P
11:06:53 <shapr> some guy named Apocalis_
11:06:56 <mohsen_> How am I supposed to report a typo in lyah?
11:07:01 <Apocalisp> don't indulge him
11:07:15 <mofasa_> kadoban: That gives no output either. The files are probably created but there's no terminal output (errors or warnings) even with Wall
11:07:17 <glguy> mohsen_: I don't think you are
11:07:22 <shapr> Apocalisp: :-)
11:07:32 <ezyang> mofasa_: Add -fforce-recomp? 
11:07:34 <mohsen_> glguy: There is no way to contact the writer
11:07:37 <mohsen_> ?
11:07:55 <okeuday_bak> anyone have any information building with cabal using local files (no remote use)?
11:08:06 <mofasa_> ezyang: Thanks, that did it!
11:08:07 <kadoban> mohsen_: LYAH is pretty old, and AFAIK hasn't been updated in a *long* time. Though I could be wrong.
11:08:19 <glguy> okeuday_bak: Yeah, someone has that information
11:08:26 <ezyang> mofasa_: A long standing annoyance with warnings is they only get emitted if you actually need to build the file in question 
11:09:10 <okeuday_bak> glguy: is there a good place to look? it seems like the ghc compilation may be doing this, but it doesn't really attempt to show the path
11:09:20 <Apocalisp> shapr: one of me tells only lies, the other asks only insincere questions
11:09:44 <shapr> Apocalisp: and I have to guess which? This sounds like a logic puzzle I could solve with Haskell.
11:10:03 <shapr> mohsen_: BONUS500 was active here on #haskell when writing LYAH, but hasn't been seen since then.
11:10:20 <mohsen_> I see
11:10:37 <mohsen_> Do you guys know which version of Haskell was this guy describing when writing the book?
11:11:12 <mohsen_> I think I could have used a more up to date book:p, but unfortunately I'm on chapter 8 :P
11:11:41 <Einwq> Godmorgon shapr :)
11:11:57 <centril> Einwq: godmorgon Einwq
11:12:05 <Einwq> godmorgon centril 
11:12:40 <centril> main :: IO () ; main = putStrLn "godmorgon!"
11:13:39 <centril> > putStrLn "godmorgon!"
11:13:42 <lambdabot>  <IO ()>
11:13:52 <centril> lambdabot: stupid...
11:13:52 <Apocalisp> god eftermiddag
11:14:10 <centril> Apocalisp: lambdabot vägrar...
11:14:19 <kadoban> > "centril: smrt..."
11:14:22 <lambdabot>  "centril: smrt..."
11:14:43 <cocreature> mohsen_: I wouldn’t worry too much about it. iirc the last time I looked almost everything still applies to today’s haskell
11:14:56 <schell> what’s the difference between uniqueness types and linear types?
11:16:19 <centril> schell: "In computing, a unique type guarantees that an object is used in a single-threaded way, with at most a single reference to it. If a value has a unique type, a function applied to it can be optimized to update the value in-place in the object code. Such in-place updates improve the efficiency of functional languages while maintaining referential transparency. Unique types can also be used to
11:16:21 <johnw> maybe ... http://lambda-the-ultimate.org/node/1548
11:16:21 <centril> integrate functional and imperative programming."
11:16:23 <centril> "The term is often used interchangeably with linear type, although often what is being discussed is technically uniqueness typing, as actual linear typing allows a non-linear value to be "cast" to a linear form, while still retaining multiple references to it. Uniqueness guarantees that a value has no other references to it, while linearity guarantees that no more references can be made to a value.[2]"
11:16:32 <Apocalisp> centril: lambdabot gav dig whnf av programmet :)
11:17:09 <mohsen_> cocreature: Hmmm
11:17:11 <Apocalisp> eller var det nf
11:17:35 <schell> centril, johnw: ah! thank you guys
11:17:49 <Netwolf> jfn
11:17:50 <centril> schell: https://en.wikipedia.org/wiki/Uniqueness_type#Relationship_to_linear_typing
11:19:34 <shapr> mohsen_: I like haskellbook.com, it's very up to date, but it's also $60
11:20:14 <schell> my interest is due to http://blog.tweag.io/posts/2017-03-13-linear-types.html, and the fact that idris has uniqueness types
11:20:26 <schell> i’m wondering how different they are in practice
11:20:34 <schell> (i’ll have to use both to find out)
11:27:54 <monochrom> kadoban: http://hackage.haskell.org/package/permutation-0.5.0.5/docs/Data-Choose.html may help you.
11:28:18 <monochrom> The library name is "permutation" but half of it is combination (n choose k).
11:29:52 <kadoban> Nice, ya that looks like exactly what I was looking for
11:32:14 <ertes> schell: i'd be happy, if we had at least one of them
11:32:33 <ertes> reading anything about uniqueness types or linear types only makes me feel depressed
11:33:20 <schell> ertes: were uniqueness types removed from idris? or do they not work well?
11:33:22 <schell> http://docs.idris-lang.org/en/latest/reference/uniqueness-types.html
11:33:38 <ertes> schell: i'm talking about haskell
11:33:52 <schell> oh! either as in unique or linear :)
11:33:56 <ertes> haven't used idris beyond hello world
11:33:57 <schell> i see
11:35:23 <schell> well the article i linked above makes it seem like linear types are “close”
11:35:43 <schell> though i hope they don’t intend to use that unicode “lolly” symbol
11:35:49 <dolio> schell: The difference is how the property is checked.
11:36:11 <dolio> A value with a unique type has not been shared, and if it gets shared, it will no longer have a unique type.
11:36:33 <dolio> A value with a linear type may not be further shared.
11:36:47 <dolio> But it may already be shared.
11:37:18 <schell> interesting, so the two systems overlap but they’re not the same
11:37:35 <dolio> Also linear doesn't allow you discard the value, either, whereas uniqueness typing doesn't typically care about that part.
11:38:01 <c_wraith> do languages with linear types often have a sink function?
11:38:07 <schell> hrm, that makes me think linear typing is better for resource management then
11:40:20 <dolio> Depending on what you want to do, you may be able to accomplish your goal with either scheme.
11:41:32 <dolio> For instance, Clean uses uniqueness types to tighten up the world-passing 'model' of I/O.
11:42:33 <nshepperd_> Affine types let you discard values, right?
11:43:03 <c_wraith> yes, affine is 0 or 1 use
11:44:11 <AWizzArd> Let’s say I have an instance of data Foo = { key1 :: T1, key2 :: T2, …, keyn :: Tn }  –  Can I use pattern matching to directly access key2, but at the same time have a name for the whole Foo instance?
11:45:05 <mohsen_> shapr: Isn't it a bit expensive? it is, at least in my country's currency.
11:45:37 <ski> AWizzArd : use `@'-patterns
11:46:49 <AWizzArd> ski: aah good, that works.
11:47:00 <mohsen_> "span is kind of like takeWhile, only it returns a pair of lists." Is this pair of lists in the form of a tuple?
11:47:18 <dolio> schell: Which you might think woudl be a better use case for linear types.
11:48:06 <dolio> But, if the only way to continue with your program is always to produce another unique value to pass on, it's kind of the same as having things linear.
11:49:02 * schell is digesting this
11:51:07 <mauke> :t span
11:51:10 <lambdabot> (a -> Bool) -> [a] -> ([a], [a])
11:52:05 <dolio> It's kind of like how existential things can be replaced by universals and vice versa.
11:52:17 <dolio> Because the difference depends on whether you are producing or consuming them.
12:02:13 <shapr> mohsen_: yeah, but if you want to learn Haskell with a recent book, it's worth the money.
12:03:30 <monochrom> It is not the only recent book. (And "best book" depends on you, too, not just the books.) But all recent books cost you money.
12:05:14 <monochrom> (As for worth, that mainly depends on you. The demand-price law implies that value means how desperate you are.)
12:12:21 <mohsen_> shapr: In my currency its almost 1/3 of the salary of a primary school teacher
12:12:28 <ertes> i would really like to review that book at some point
12:12:35 <mohsen_> monthly salary*
12:12:43 <ertes> but i wouldn't pay $59 to do it
12:13:48 <ertes> mohsen_: these lecture notes are free and highly practical with lots of exercises: https://www.seas.upenn.edu/~cis194/spring13/lectures.html
12:14:08 <jle`> AWizzArd: by the way, 'instance' means something else in Haskell than you are thinking of
12:14:31 <ertes> and i like its "explain, but don't hold their hand" approach
12:15:35 <mohsen_> ertes: Thanks
12:16:22 <jle`> the author has been understanding of financial situations of haskell learners in the past mohsen_ 
12:16:32 <jle`> if you contact them directly you might be able to get a discounted price
12:17:51 <bcfdigtco> I just finished those exercises this week. Can confirm—they're very useful. They don't go very far though.
12:18:05 <bcfdigtco> I personally would like to get more experience with building a monad stack for my application.
12:18:12 <jle`> i know that they both care more abut teaching haskell than about making money, and the price is mostly to support themselves during the writing process
12:18:23 <jle`> so they would probably be happy to help :)
12:19:06 <ertes> this is subjective, but i believe monad transformers are by far the most abused abstraction in haskell
12:19:41 <bcfdigtco> @ertes Oh? Can you elaborate?
12:19:42 <lambdabot> Unknown command, try @list
12:19:49 <ertes> there is hardly ever a reason to have an "application monad", for example
12:19:49 <bcfdigtco> ertes: Oh? Can you elaborate?
12:20:12 <ertes> and transformers are far more satisfying and useful, if you use them in a short-lived manner
12:20:34 <bcfdigtco> Yeah, when I see application-level monad stacks, they feel like global state, but clunkier.
12:21:17 <ertes> it's not a philosophical point though, but quite a practical one:  transformers suffer a lot from the expression problem
12:22:44 <mohsen_> jle`: No its probably not expensive for someone that lives in europ or america, it becomes expensive when it's shipped to third world countries, which I'm from one of them, but my brother lives in america, I can ask him to buy me this book.
12:23:36 <mohsen_> He comes home every now and often:)
12:24:07 <haskellnewb> hello guys, i am need of some help with generators and filters
12:25:55 <Akii> haskellnewb: just go ahead and ask
12:26:23 <Akii> mohsen_: just contact bytemyapp, he's lurking on IRC in #haskell-beginners or on twitter
12:28:58 <kaol> How come ghc wants to deduce (Bounded a0) and not use Bounded a in this? http://lpaste.net/353609
12:29:12 <haskellnewb> Ok, following: i had to write a filter which will select the element of a list which has a distance to its following element of <= some small value.. now i want to use this filter with pairs of numbers (Double, Double). The selector code is here: http://pastebin.com/jUFj0p2K
12:29:38 <ertes> reading the sample…  something bothers me immediately: its disrespect for haskell.org, and its aggressive promotion of stack and stackage
12:30:45 <monochrom> ertes: sample of haskellbook.com?
12:30:49 <ertes> yes
12:30:59 <michalrus> I find myself defining a lot of `newtype A = A { toText :: Text } deriving (Show, Eq)`… Can this somehow be made less verbose?
12:30:59 <monochrom> Ah, I think I agree with you.
12:33:05 <monochrom> haskellnewb: Line 2's "a" is unrelated to line 1's "a".
12:34:41 <haskellnewb> monochrom: i think you meant kaol?
12:34:42 <monochrom> It will be hard to do what you want. You will need to jump into a small rabbit hole.
12:34:52 <monochrom> Oh! Sorry, yes.
12:34:55 <haskellnewb> i have no a in lne 2 ^^
12:35:06 <haskellnewb> No problem
12:35:09 <monochrom> kaol: Line 2's "a" is unrelated to line 1's "a". It will be hard to do what you want. You will need to jump into a small rabbit hole.
12:35:39 <monochrom> Look for both "ScopedTypeVariables" and "proxy".
12:36:48 <kaol> Ok, I'll look into those. My full code is quite a bit longer but I think it's the same issue I got with this two liner. Thanks.
12:37:54 <monochrom> I think the salient feature is "(a lot of constraints on type variable t) => (but t doesn't appear here)".
12:38:54 <monochrom> That is disallowed. So you have to work around with the "proxy" idea: "(constraints on type var t) => p t -> (t doesn't have to appear here)".
12:39:37 <monochrom> And then you need line 1's "t" sync with the function body's "t", which is what ScopedTypeVariables does.
12:39:47 <jle`> mohsen_: in your specific situation it could be considered prohibitively expensive, so there's no harm asking :)
13:34:57 <eiriksfa> anyone here got some time to help out a newbie?
13:35:51 <Cale> Probably
13:35:58 <monochrom> No guarantee.
13:35:59 <eiriksfa> ^.^
13:36:02 <Cale> Best just to ask about what you need help with
13:36:06 <Lazersmoke> ^
13:36:41 <eiriksfa> well, I'm trying to learn haskell, and thought it would be a decent idea to use codeingame as a learning tool
13:37:53 <eiriksfa> and while looking over one of the challanges I believe I would have been able to solve it pretty quick, if I had the input in the form of an [Int], but using an input stream is sort of difficult when you know nothing about Monads
13:38:38 <eiriksfa> and I would sort of like to wait a bit before learning about it as well honestly
13:38:59 <monochrom> No Monad necessary for using [Int].
13:39:13 <Lazersmoke> what was the input format if it wasn't [Int]?
13:39:24 <eiriksfa> [IO Int]
13:39:46 <monochrom> OK, read my http://www.vex.net/~trebla/haskell/IO.xhtml
13:40:45 <eiriksfa> okay, thanks, will read that one first, might come back with more questions after testing
13:40:46 <napping> how did you get a [IO Int]?
13:40:51 <eiriksfa> replicateM 5 $ do / input_line <- getLine / let ei = read input_line :: Int / return (ei)
13:41:00 <eiriksfa> where '/' is a linebreak
13:41:02 <Lazersmoke> hmm that's a bit of an odd type. you can use `sequence` to help you out if you just need a quick fix
13:41:04 <Lazersmoke> http://hackage.haskell.org/package/base-4.9.1.0/docs/Data-Traversable.html#v:sequence
13:43:11 <napping> Isn't that IO [Int]?
13:44:01 <Lazersmoke> yeah it should be: `replicateM :: Applicative m => Int -> m a -> m [a]`
13:44:10 <Lazersmoke> so the list should be on the inside
13:44:40 <eiriksfa> oh, yea, sorry, it's an IO [Int]
13:46:17 <Lazersmoke> btw, whenever you have something like `do {x <- whatever; let fx = f x; return fx}`, it's the same as `fmap f whatever` or `f <$> whatever`
13:49:15 <napping> Does ghc try to optimize the implementation of match expressions much? compiler/deSugar/Match.hs doesn't seem to be using column heuristics or anything
14:13:16 <lep-delete> i think you have to be careful with re-ordering colums wrt. lazyness
14:13:18 <lep-delete> afair
14:21:36 <ogkloo> Hi #haskell, I'm trying to install Eta from source, but every time I run stack setup (installed from this: https://docs.haskellstack.org/en/stable/install_and_upgrade/, version 1.4.0), I get "stack will use a locally installed ghc..." and then quits. Is this normal? Sorry, I'm kinda new to stack. 
14:24:18 <Lazersmoke> ogkloo that is normal; stack setup is not how you build from source, though
14:24:39 <Lazersmoke> you probably want to cd to the directory and do "stack build"
14:25:00 <Lazersmoke> or "stack install" if you want it copied to an executable directory
14:25:44 <ogkloo> Lazersmoke: thank you, I ran their install script but it spits out a lot of errors, but I think that's on the eta part of it. 
14:28:25 <Lazersmoke> yeah its almost certainly on eta's end
14:28:40 <Lazersmoke> they have a huge custom build script: https://github.com/typelead/eta/blob/master/shake/Build.hs
14:29:35 <ogkloo> yeah iirc their documentary is due for another update soon so I probably just got into it at an unlucky time. Now I'm getting file permission errors, so I'm just gonna chown a lot of things and hope.
14:31:46 <mpickering> napping: Exactly what kind of case expressions do you mean?
14:32:07 <mpickering> It does do some optimisations
14:32:56 <napping> I was specifically looking a5t maranget's papers
14:33:47 <napping> Maybe some things like this: http://pauillac.inria.fr/~maranget/papers/opat/
14:34:15 <napping> maybe it does some things like this, though I didn't notice anything that looks like keeping a summary of the information known when backtracking
14:35:34 <napping> or the column ordering heuristics like in “Compiling Pattern Matching to Good Decision Trees”
14:35:47 <napping> http://moscova.inria.fr/~maranget/papers/ml05e-maranget.pdf
14:37:15 <dolio> napping: Some of the things that latter paper does are incorrect in Haskell.
14:38:11 <napping> I'm not surprised if some of the details would have to change, but I doubt laziness generally removes all choice
14:39:28 <napping> Isn't it just that you would always be forced match on a column whose first row has a constructor pattern ?
14:40:15 <dolio> No, some of the matrix splitting is subtly incorrect, as I recall.
14:41:44 <napping> How is that? I can see a problem if you force something before it's actually required
14:41:50 <dolio> There was a talk about rewriting the match compiler in GHC a bit ago that had an example, I'll see if I can find it.
14:49:37 <dolio> napping: So, I think the example is...
14:49:55 <dolio> `f _ False = 1 ; f True False = 2 ; f _ _ = 3`
14:51:15 <dolio> And the compiler in that paper will erroneously never evaluate the first argument.
14:51:38 <dolio> In the case of the second argument being True.
14:52:07 <dolio> But that is incompatible with the Haskell report's specification of how pattern matching works.
14:52:17 <dolio> Which says each case gets tried in order.
14:52:30 <dolio> So `f undefined True` should blow up.
14:53:11 <napping> does it really specify the order?
14:53:30 <napping> that just seems to require forcing some more things at the end of the match
14:53:42 <monochrom> Haskell Report specifies strictness. It specifies that "f xxx True" is strict in xxx.
14:53:49 <dolio> The answer must be as if you tried them in order.
14:54:09 <dolio> It doesn't matter how you actually do it as long as you get the same answer.
14:54:34 <monochrom> Yeah, you need to bottom out, despite optimizations and shuffling.
14:54:36 <dolio> But if you are careless, you will forget that you have to be strict in the first argument if the second argument is True.
14:54:59 <napping> ok, but that doesn't seem like a deep problem
14:55:22 <monochrom> OTOH you could propose to the Haskell Prime committee to relax this.
14:55:38 <monochrom> But then ETA is approx 10 years. :)
14:55:50 <napping> the definitions of necessity and exhaustiveness from the paper would have to be adjusted for a non-strict language anyway
14:56:23 <dolio> https://people.cs.kuleuven.be/~george.karachalias/papers/p424-karachalias.pdf
14:56:55 <dolio> That is the paper that describes how the pattern match compiler is currently implemented.
14:57:02 <dolio> I think.
14:57:46 <napping> ah, that seems likely
14:58:04 <dolio> Anyhow, I wrote a pattern match compiler based on the paper you linked, modified in the way I thought was required for laziness (the choice of what to split on). And the result is wrong. :)
14:58:38 <dolio> Because it thinks that second case is redundant, and I didn't realize it isn't when modifying for laziness.
14:58:42 <napping> I'm looking into implementing one for a non-strict rewriting case
14:59:33 <napping> I was just looking at compilers and wondering how much GHC would optimize things
15:00:47 <dolio> You also have to decide what you think "optimized" is.
15:01:20 <dolio> That splitting trees paper optimizes for fewest necessary cases, but at the cost of duplicating code.
15:01:24 <napping> in my case it will be performance of a program totally dominated by matching
15:01:59 <dolio> As I recall.
15:02:08 <napping> I hoped to find more papers talking about some combinations of decision trees and backtracking, but I haven't found any
15:02:20 <dolio> But it's possible for optimizing for smallest code size to be better, I think.
15:02:52 <napping> Well, yes, minimum expected depth isn't necessarily the same as speed
15:03:46 <napping> But I doubt the absolute smallest code will be optimal
15:04:12 <monochrom> Clearly, the smallest code is a self-extracting exe... :)
15:04:22 <monochrom> self-decompressing, even
15:04:40 <napping> Think i-cache here
15:05:25 <erisco> there's no free lunch, and stuff
15:06:05 <dolio> Or maybe there's some order that would be better for branch prediction for your particular problem, and that blows away doing redundant work or something.
15:06:39 <dolio> Which probably wouldn't be worked out by the 'optimal' splitting tree.
15:06:45 <napping> Why not?
15:07:02 <napping> well, for some notion of 'optimal' that doesn't take into account the actual distribution, sure
15:07:06 <dolio> Right.
15:07:17 <napping> but that's certainly something I can profile
15:07:37 <erisco> but then your machine may be different than another
15:07:37 <napping> There's no reason to suspect that never duplicating code will get the best performance here
15:08:10 <dolio> Branch prediction is probably a more realistic example than code size.
15:08:51 <napping> I do suspect that leaving some rows with wildcards to be handled by backtracking might be better than turning everything into a pure decision tree
15:09:31 <napping> although that does remind me of BDDs, where the optimization problem gets a lot trickier if you allow repeated tests
15:10:00 <napping> Like with code size, I expect it would mostly be a question of not exceeding branch predictor size
15:10:45 <Tuplanolla> Saner processor architectures will save us.
15:11:15 <napping> if there are few enough branches and enough time to warm up, having separate jump instructions for matching a position in different contexts are probably more predicatable
15:12:03 <napping> I'm also not terribly concerned about compilation time, at least for a fully-optimized "release" build
15:12:41 <erisco> if they make these techniques transparent then they'll just come up with another set of opaque ones
15:12:46 <erisco> how else do they compete
15:13:51 <napping> Tuplanolla: save us from what?
15:14:27 <Tuplanolla> Save us from unpredictable optimizations.
15:15:25 <ezyang> linear types for guaranteed otpimization is really cool :) 
15:15:36 <napping> I'm not too worried about anything unpredictable
15:27:59 <hpc> ezyang: i was actually thinking using linear types to make a FFI that understands rust
15:28:06 <hpc> far better than the current FFI understands C
15:35:36 <jle`> weird that adding a layer of indirection (in the form of a strict-field data wrapper) made my program a little faster
15:35:41 <jle`> i wonder if it's just noise
15:36:05 <jle`> better run my benchmarks a few more times
15:46:18 <centril> Is there a IOT (IO Transformer) monad ?
15:47:05 <johnw> centril: what would it's base transformer ever be?
15:47:20 <johnw> err, base moned
15:47:31 <Cale> Well, anything, presumably
15:47:31 <centril> johnw: that's a good question
15:47:58 <centril> I guess  newtype IOT m a = m (IO a)   wouldn't make much sense...
15:48:06 <Cale> In principle, such a thing could exist, but it would require a different approach to implementing IO
15:48:17 <Cale> If IO were implemented, for instance, as a free monad
15:48:25 <johnw> you'd need to be able to write this function m (IO (m (IO a))), which I don't think you can
15:48:30 <Cale> Then IOT would make sense as a corresponding FreeT
15:48:40 <johnw> -> m (IO a)
15:48:51 <Cale> Yeah, that wouldn't be a valid approach
15:49:02 <napping> you need a distribution function like m (IO a) -> IO (m a)
15:49:09 <centril> how about  IOT m a = IO (m a) ?
15:49:17 <Cale> no, that still doesn't help
15:49:24 <johnw> napping: which I guess does work for some m, like (,) b
15:49:26 <Cale> You need to actually know something about IO
15:49:32 <Cale> in order to be able to do this
15:49:38 <Cale> it can't work opaquely
15:49:40 <napping> I suppose that might sometimes be weaker than MonadIO
15:49:56 <Cale> and since IO in Haskell is an opaque type, you're out of luck
15:50:18 <Cale> If you only need *certain* IO actions, then check out FreeT
15:50:36 <centril> johnw: why exactly is  :: m (IO (m (IO a))) ->  m (IO a)   needed?
15:50:44 <Cale> :t join
15:50:47 <lambdabot> Monad m => m (m a) -> m a
15:50:52 <centril> oh shit
15:51:06 <centril> didn't see that it was join
15:51:33 <centril> Cale: yeah - if you cant write join then no dice
15:51:44 <napping> Cale: why do you say "need to know something about IO"?
15:52:08 <Cale> napping: I mean, it's not true that for all monads, M and N, that the composite of M and N is a monad.
15:52:12 <napping> sure
15:52:18 <Cale> There's no generic way to do it
15:52:39 <Cale> So, if you don't assume something special about IO, that is, it's effectively an arbitrary monad, you're not going to have any luck.
15:52:48 <napping> ah, it can't be a MonadTrans instance, no
15:53:00 <johnw> the most generic condition under which it applies is if you can say: forall a, n (m (n a)) -> m (n a), for some Monad m and some Applicative n
15:53:06 <Cale> There could be a reasonable IOT in principle though
15:54:08 <centril> Cale: would it be a helpful addition ?
15:54:10 <napping> But you can require something more than Monad m for your instance Monad (IOT m)
15:54:10 <centril> is it motivated?
15:54:14 <Cale> (effectively something like a free monad transformer, for a functor which explains what all the IO primitives are)
15:54:43 <napping> centril: I suspect MonadIO covers most of what you might want
15:54:44 <Cale> centril: I wouldn't expect it to be especially useful either
15:55:26 <centril> napping: =) in my case tho, Im using IO as base, so it was just an academic question
15:55:34 <centril> (or Identity as base)
15:56:47 <johnw> I wouldn't mind seeing FixT f m
15:57:10 <Cale> However, there would certainly be an advantage to having IO not be opaque
15:57:31 <centril> Cale: how could IO not be opaque ?
15:57:35 <Cale> It would actually be really cool to be able to take arbitrary IO actions and inspect what they were going to do before running them
15:57:44 <centril> given that RealWorld is opaque... ?
15:57:53 <Cale> You wouldn't use RealWorld
15:58:22 <Cale> The RealWorld thing is just a hack to get GHC's dependency analysis to keep the order of evaluation of a bunch of impure functions straight.
15:58:23 <centril> Cale: then how can you model arbitrary IO without an interface that constrains performance considerably for IO ?
15:58:48 <napping> allow hurting performance?
15:59:11 <Cale> Well, you'd make good performance an open question
15:59:16 <Cale> Maybe not impossible
15:59:22 <napping> Cale: you probably couldn't inspect too far
15:59:30 <napping> before hitting a lambda
15:59:34 <Cale> Right, but you could always inspect the next thing to do
15:59:49 <napping> you could make a free monad with syscalls as actions or something
15:59:51 <Cale> and transform the action so that you get to inspect the thing after
15:59:52 <centril> wouldn't you need a to have a constructor for every primitive IO operation? which would require a biiiig list ?
15:59:53 <napping> maybe a bit too OS-specific
16:00:03 <Cale> centril: Probably not that big.
16:00:08 <centril> (maybe not so big)
16:00:18 <Cale> You could have a few really generic ones
16:00:29 <centril> Cale: the more you have the better the performance I guess
16:00:33 <Cale> I think Idris does it, iirc.
16:00:44 <Cale> Could be wrong, but you might want to look
16:00:47 <centril> the more specific you can be when it comes to operating system operations, the better
16:01:22 <centril> and operating systems still have a lot & different set of operations
16:01:31 <centril> differing*
16:01:47 <napping> usually no more than 256 syscalls, right?
16:02:10 <centril> Cale: interesting, I've been meaning to take a closer look at Idris
16:02:29 <centril> napping: have you seen the syscalls in windows? so many headers...
16:02:37 <centril> how do you efficiently model arbitrary FFI ?
16:03:41 <napping> you might have a more opaque type there, like a "ForeignSymbol args result" and an action to call a foreign function
16:04:04 <centril> napping: right, still less opaque I guess
16:04:25 <napping> and there it's more a question of making it extensible
16:04:28 <centril> than letting entire IO be opaque
16:04:33 <centril> napping: exactly
16:04:50 <napping> and maybe making it harder to create new ill-typed values
16:04:50 <centril> much problems, tricky tricky
16:05:03 <centril> also probable :P
16:05:06 <napping> there could still be functions for getting the symbol name or address or whatever
16:07:32 <centril> right
16:40:28 <jle`> hi all
16:40:34 <jle`> why isn't there a MonadIO instance for Proxy
16:40:45 <jle`> it follows all of the laws
16:40:54 <jle`> that is all i wanted to say
16:44:13 <scope> hey all, I have a quick question as a haskell noobie if anyone could help me out.
16:44:43 <jle`> scope: ask your question, you don't need permission :)
16:44:49 <centril> scope: shoot!
16:45:23 <scope> So, I have a function "distance" that takes in arguments: (x1,y1) (x2,y2), and I'm trying to access the arguments within the definition.
16:45:44 <scope> I keep getting type mismatch errors, and I'm guessing it has something to do with the parameters being in tuples?
16:45:53 <jle`> hard to say without seeing the error
16:45:54 <ezyang> paste some code 
16:46:02 <MarcelineVQ> @lpaste
16:46:03 <lambdabot> Haskell pastebin: http://lpaste.net/
16:46:05 <centril> scope: if you can, paste your code @ http://lpaste.net/
16:46:09 <jle`> by 'hard' i mean 'more or less impossible' :)
16:46:13 <centril> MarcelineVQ: hah :D
16:46:15 <scope> sure one sec
16:46:33 <scope> http://lpaste.net/6107602198248554496
16:46:59 <Koterpillar> aaaand the error?
16:47:08 <scope> when I try to set it equal to just "x1" or any of the other arguments I get errors. I just need to know how to access those arguments.
16:47:10 <scope> one sec
16:47:23 <glguy> don't forget to wrap the error in <spoiler> tags
16:47:42 <jle`> the error is probably that you don't have anything on the right side of the equals sign
16:47:44 <Koterpillar> you're promising to give back any b that's a Floating; x1 is not b, it's a
16:47:53 <geekosaur> scope, the reason you cant just returb one of the parameters is ... that
16:48:03 <geekosaur> type conversion is NOT automatic in haskell
16:48:09 <jle`> distnace (x1, y1) (x2, y2) = (you need something on this side)
16:48:12 <scope> well when I try to input the actual equation for euclidean distance it does the same
16:48:13 <geekosaur> (except for literals, but that's soemthing of a compiler hack)
16:48:29 <jle`> i doubt it gives the same error
16:48:36 <geekosaur> yes, you need to coerce your a-s to b-s at some point
16:48:48 <geekosaur> or decide what you actually meant with the type
16:48:49 <scope> for instance if I do = sqrt (x1 - y1)^2 + (x2 - y2)^2 I get the same error
16:48:58 <glguy> :t sqrt
16:49:00 <lambdabot> Floating a => a -> a
16:49:09 <jle`> scope: the result is the same type as the items in the inputs
16:49:14 <jle`> so you don't want Point a -> Point a -> b
16:49:18 <jle`> you want Point a -> Point a -> a
16:49:31 <glguy> scope: Separate problem is that you probably meant to write: sqrt ((x1 - y1)^2 + (x2 - y2)^2)
16:49:44 <geekosaur> is there some reason you have that Real constraint?
16:49:49 <scope> As I said I'm extremely new to Haskell. I've tried it that way as well glguy
16:49:58 <scope> that's just how the function stub was given to me
16:50:25 <glguy> scope: Like I said, it's a separate problem from your type problem. You need parentheses for sqrt to span the whole sum
16:50:54 <scope> here I'll paste my code again in a second
16:50:55 <jle`> scope: you take in an (a, a) and you return something that's the same type as the things inside the tuple
16:51:06 <scope> so how do I go about fixing that?
16:51:12 <jle`> scope: so the type of the thing you return is 'a'
16:51:14 <jle`> not 'b'
16:51:22 <jle`> `Point a -> Point a -> a` should work
16:51:32 <jle`> `Point a -> Point a -> b` means that the result isn't the same type as the tuple's contents
16:51:38 <jle`> or well, not necessarily the same type
16:51:54 <jle`> but in your case, the thing in the tuples is the same type as the thing you're returning
16:52:23 <scope> I'm being told it's because sqrt takes in a float but I'm giving it a real
16:52:43 <jle`> Real isn't a type, so that's not quite an accurate explanation
16:52:44 <geekosaur> yes
16:52:49 <geekosaur> or, well, sort of.
16:53:08 <geekosaur> it takes a type with a Floating instance, you give it one which is only knwon to have a Real instance
16:53:08 <jle`> but if you fix it to be Floating a => Point a -> Point a -> a, it should work
16:53:24 <scope> so a friend is saying realToFrac should fix it?
16:54:03 <jle`> we're not quite sure what you want to fix yet exactly because you haven't shown us the code, so it's hard to say
16:54:06 <lpaste_> glguy annotated “No title” with “No title (annotation)” at http://lpaste.net/6107602198248554496#a353616
16:54:09 <geekosaur> that gives you a type with a Fractional instance. not all such types are known to have Floating instances. (Rational, for example)
16:54:42 <jle`> but from inferring from what you are saying, it should work as Floating a => Point a -> Point a -> a
16:55:06 <jle`> but, it's difficult to say exactly because we aren't sure what the code is
16:55:28 <jle`> h:268
16:55:45 <Welkin> h265
16:55:47 <scope> jle one sec
16:55:56 <glguy> If it's the case that you're required to maintain the original type, then you can insert a realToFrac between sqrt and its argument
16:56:47 <scope> this doesn't quite work either http://lpaste.net/5629341131524276224
16:56:53 <scope> glguy tried what you said
16:57:14 <scope> "could not deduce (Floating (a -> b)) arising from a use of 'sqrt'
16:57:36 <glguy> scope: You still have to use Haskell function application syntax, not literally control-v the word realToFrac into the line
16:57:53 <glguy> sqrt (realToFrac ( ...
16:58:29 <scope> is that not what I did though...?
16:58:32 <glguy> scope: Then you have the problem that you're not computing distances
16:58:38 <glguy> you've got your xs and ys crossed
16:58:43 <glguy> no, you forgot the parentheses
16:59:00 <glguy> so you're using realToFrac as the argument to sqrt
16:59:19 <scope> wait the whole thing is encapsulated in parentheses though
16:59:36 <scope> sqrt realToFrac((x1 - y1)^2 + (x2 - y2)^2)
16:59:43 <scope> OH
16:59:45 <scope> shit
16:59:46 <scope> wow
16:59:50 <scope> I see what you mean sorry
16:59:56 <jle`> yeah, that means that you're applying the function sqrt to realToFrac
17:00:12 <jle`> and square rooting a function usually isn't what you want :o
17:00:39 <Welkin> jle`: what's the square root of the sun?
17:00:45 <scope> this is still not working and giving me a type mismatch error again sqrt(realToFrac((x1 - y1)^2 + (x2 - y2)^2))
17:01:37 <Koterpillar> scope: while you're at it, what's x1 - y1?
17:01:45 <glguy> scope: It's hard to guess what you're doing wrong
17:01:47 <jle`> scope: you still haven't pasted the error
17:01:52 <MarcelineVQ> use your paste, that way you can include the error and people don't have to ask what your type signature is with that line otherwise
17:01:57 <glguy> you have to show us errors and actual code you're using to generate the errors
17:02:12 <jle`> the error is the first thing we asked for heh, and it the single most useful thing for helping you
17:02:34 <scope> can't copy it directly from cmd
17:02:43 <jle`> hm...maybe screenshot?
17:02:51 <scope> one sec
17:03:04 <glguy> scope: Then figure out how to fix your computer so you can copy text and then come back and we can help
17:03:15 <jle`> i'm not just joking, heh, if we had seen an error from the beginning then the answer would have been extremely easy and fast :)
17:03:51 <jle`> that's how much of a difference it makes :3
17:04:17 <scope> http://i.imgur.com/ifGElwZ.png
17:04:44 <scope> and the code http://lpaste.net/4367931914116399104
17:04:56 <Koterpillar> scope: right-click CMD window and select "Select" and then "Copy" to copy.
17:05:06 <scope> right clicking does nothing
17:05:14 <jle`> so the problem is that the function's type and the type signature don't match.  which one do you want to fix?
17:05:24 <jle`> do you want to fix the type signature to match the function, or the function to match the type signature?
17:05:37 <scope> I can't change the function stub, only what comes after the =
17:05:48 <jle`> so you can't change the type signature?
17:05:52 <scope> yes
17:05:59 <jle`> then the problem is that 'x1 :: a', but it wants a 'b'
17:06:11 <jle`> so you can use realToFrac to convert x1 from an 'a' to a 'b'
17:06:23 <scope> but that's what I've done
17:06:33 <scope> sqrt(realToFrac((x1 - x2)^2 + (y1 - y2)^2))
17:06:40 <jle`> the eerror isn't from sqDistance
17:06:44 <jle`> the error you gave us is from distance
17:06:47 <glguy> scope: It looks like the problem is you didn't save your file
17:06:49 <scope> holy fuck
17:06:50 <scope> I'm an idiot
17:06:55 <scope> guys I apologize
17:06:55 <jle`> sqDistance should probably be ok
17:06:55 <glguy> ah, that
17:07:00 <jle`> no problem :)
17:07:02 <jle`> see, the error helps :D
17:07:13 <scope> ok loaded fine
17:07:14 <scope> wow
17:07:30 <scope> I had typed the sqrt function under a separate function I haven't completed yet
17:07:53 <scope> thanks guys
17:08:22 <jle`> glad everything worked out :)
17:08:37 <scope> Me too haha I've been banging my head against my keyboard for the last hour
17:08:51 <scope> haskell is confusing for someone that only knows OOP languages
17:10:07 <geekosaur> btw, you should probably stop that habit of removing the spaces between a function and its parameters
17:10:21 <geekosaur> it happens to work like languages you are used to as long as there is only one parameter
17:10:25 <geekosaur> > div 5 3
17:10:29 <lambdabot>  1
17:10:46 <scope> yeah exactly, that's what I've been reading in LYAH geekosaur
17:10:52 <scope> throwing me off
17:15:41 <Welkin> a bridge?
17:23:54 <tmciver> Hey folks. I'm working on a toy project to implement a simple blockchain and I thought using Hashable for hashing a block seemed like a good solution but I'm wondering what the hashing algorithm is or if it's even the same across instances.  Looked a bit at the instance for Bytestring; it ultimately calls a C function "c_hashCString" but I don't know what that does. I don't suppose I can choose a hashing 
17:24:00 <tmciver> algorithm, can I?
17:24:18 <tmciver> Or perhaps using Hashable isn't a good solution here if I want to be able to parameterize the algorithm used.
17:24:48 <peddie> @hackage hashabler
17:24:49 <lambdabot> http://hackage.haskell.org/package/hashabler
17:25:54 <tmciver> peddie: Thanks! that looks promising.
17:35:48 <michalrus> What’s the best way to unapply newtype? Say, I have `newtype LastName = LastName Text`. How to get this Text better than `let (LastName t) = ln in t`? Or how do I get uppercased LastName? (And what if it wasn’t string in case someone suggests IsString!)
17:36:50 <Boomerang> newtype LastName = LastName { getLastName :: Text }
17:37:10 <michalrus> Boomerang: yeah, but then I’m getting conflicts like this one:
17:37:12 <michalrus> newtype A = A { toText :: Text } ; newtype B = B { toText :: Text }
17:37:12 <michalrus> xs = [ A "1", A "2", A "3" ]
17:37:12 <michalrus> ys = toText <$> xs
17:37:19 <michalrus> Ambiguous toText…
17:37:33 <michalrus> (With DuplicateRecordFields, that is.)
17:37:35 <Koterpillar> michalrus: use fromA and fromB instead
17:37:59 <Koterpillar> newtype A = A { fromA :: Text }
17:38:09 <Koterpillar> sometimes unA or runA are used
17:38:55 <michalrus> Even if the name isn’t A, but something from the depths of *business* like SchemaConfigurationListVisitorErrorListener?
17:39:04 <michalrus> fromSchemaConfigurationListVisitorErrorListener?
17:39:39 <Koterpillar> SchemaConfigurationListVisitorErrorListener is awful by itself anyway
17:39:45 <Koterpillar> but, yes
17:39:45 * michalrus nods
17:39:49 <michalrus> Oookay. :)
17:39:54 <michalrus> Thanks!
17:41:53 <Boomerang> michalrus: if you really need a uniform getText you could create a GetText type class with a getText function and have instance of that class for all your newtypes A, B, C... I don't know if this is a good pattern for large prjects though
17:42:33 <michalrus> That crossed my mind, too… But so verbose. :’
17:43:05 <Boomerang> It's not too bad
17:43:05 <Koterpillar> not at usage site
17:43:24 <Boomerang> class GetText a where getText :: a -> Text
17:43:33 <Boomerang> instance GetText A where getText = fromA
17:44:19 <michalrus> instance GetText A where getText a = let (A t) = a in t
17:44:20 <michalrus> :p
17:44:39 <michalrus> Hmmm.
17:44:48 <michalrus> instance GetText A where getText (A t) = t
17:45:04 <michalrus> I dunno. :’(
17:46:36 <michalrus> I wonder if there is enough information available for a compiler plugin to implement `unnewtype` or `mapnewtype`
17:47:00 <michalrus> toUpper `mapnewtype` (A "xyz") == A "XYZ"
17:47:34 <michalrus> Interesting that nobody needed it. I’m clearly doing something wrong here. =)
17:47:41 <Boomerang> michalrus: you could derive Functor for your newtype
17:47:57 <michalrus> But it’d need to be * -> *, right?
17:48:04 <michalrus> A Text is just *
17:48:08 <Koterpillar> you can use Generic
17:48:32 <michalrus> I’ll read about that one, then! Thank you. (:
17:48:49 <Koterpillar> but if you have so many newtypes with the same shape and you want to use them the same way, why are they different?
17:49:04 <geekosaur> michalrus, there's also a standalone package (newtype) and stuff in lens (Iso iirc?)
17:49:47 <michalrus> Koterpillar: good point, I don’t know. I just wanted to toUpper one of them and probably went too far in my imagination…
17:49:55 <michalrus> geekosaur: I’ll check them out, too, thank you!
17:52:59 <geekosaur> oh, also: if you want to distinguish Foo Int from Int in the type system, but still do math on it, consider GeneralizedNewtypeDeriving and deriving (Num)
17:53:01 <geekosaur> etc.
17:53:26 <michalrus> Yes, I want exactly that! :) :) Thank you!
17:53:27 <geekosaur> which indeed makes the compiler do the wrapping/unwrapping for you
17:53:58 <dopey_> hey yalls, network programming question. im using the Warp library to run a small proxy and I'm wondering if it's possible to access the socket currently handling the request from the request handler (router in Warp terminology i believe).
17:54:22 <dopey_> with access to the socket I would be able to query the user of the process making the request, which is my ultimate goal.
17:55:37 <Koterpillar> that's assuming the user is on the same machine?
17:55:53 <dopey_> correct. this is local so I'm sure of that part
17:58:14 <scope> another question for you all: I have some functions that find the distance between two points and the closer pair (coordinate-wise) between two pairs of points. I'm now trying to find the closest pair of points from a list of points. I'm having trouble figuring out how to do this.
18:07:52 <pacak> scope: minimumBy blah $ do
18:07:53 <pacak> p1 <- points
18:07:53 <pacak> p2 <- points
18:07:53 <pacak> guard $ p1 /= p2
18:07:53 <pacak> return (p1, p2)
18:08:51 <mudri> Hi. I'm trying to make a type class instance where the type has a number k in it, and the instance needs k at the value level.
18:09:02 <lpaste_> mudri pasted “No title” at http://lpaste.net/353619
18:09:42 <mudri> ^ this is the obvious thing I wrote, but k is not in scope for the ⟨take k⟩ expressions.
18:10:29 <robertkennedy> https://www.4clojure.com/problem/106
18:10:35 <mudri> I'm not really sure what else to try. I'm familiar with normal dependent types, but not the Haskell variety.
18:12:03 <robertkennedy> Traveling from 1 -> 4137 I get 1.5 ms for answer, 5 ms for a version that saves the path. Does that seem orders of magnitude high?
18:14:29 <geekosaur> mudri, I think you want KnownNat?
18:15:18 <MarcelineVQ> robertkennedy: are you doing this in haskell? is there a goal ms?
18:15:18 <geekosaur> (ghc doesn't actually have dependent types as such. you have some limited ability to reflect between types and values.)
18:15:42 <mudri> geekosaur: I'll take a look...
18:16:12 <mudri> (And where do I recognise you from?)
18:16:43 <MarcelineVQ> mudri: this talk about the current state of depdendent types in ghc was quite interesting, though I'm not sure how appicable to your problem
18:16:52 <MarcelineVQ> *this talk https://www.youtube.com/watch?v=P4Io2CRpwyg
18:17:05 <geekosaur> #xmonad, probably :)
18:17:18 <mudri> Oh yeah, that was just the other day.
18:23:22 <robertkennedy> MarcelineVQ: yeah, we have an fp club at my work. Speed is the goal
18:30:09 <kadoban> robertkennedy: What are you doing, BFS?
18:32:01 <kadoban> robertkennedy: Hmm ... what's the input sizes and time limits on these things, I guess it doesn't tell you?
18:39:03 <robertkennedy> I'm doing a fold on `F IntSet IntSet` (visited, new). But it doesn't allow for much parallelism. Sparse adjacency matrices seem better, but youd want an unbounded matrix space
18:40:27 <robertkennedy> No one at my company has got `123456 -> 234567`. Indeed, I have the quickest solution so far. 
18:49:47 <halogenandtoast> join #ur
18:49:53 <halogenandtoast> sorry :(
18:50:55 <centril> Cale: If IO wasn't transparent, we could possibly also do: Comonad IO  (unless it is represented as a state monad in which case you still cant)
18:51:04 <centril> or: unsafePerformIO :P
18:51:37 <edwardk> centril: IO or OI as a comonad is unsound given the presence of strength in our language
18:52:08 <centril> edwardk: it was a "joke! ;)
18:52:42 <edwardk> i mention it because it has been raised "seriously" before http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.46.5169&rep=rep1&type=pdf
18:52:53 <centril> oh :P
18:52:55 <edwardk> and i want to be clear that it gives a problem =)
18:53:36 <centril> edwardk: could IO possibly be a WriterT RealWorld a  instead of StateT RealWorld a  ?
18:54:09 <edwardk> WriterT is kind of a damn mess, i presume you want to be able to pass and listen? what is the monoid?
18:54:23 <edwardk> if you don't want pass/listen and just want tell, then how do you readLine?
18:54:34 <Welkin> I thought Writer could only append, not modify?
18:54:46 <edwardk> :t Control.Monad.Writer.pass
18:54:48 <lambdabot> MonadWriter w m => m (a, w -> w) -> m a
18:54:52 <edwardk> :t Control.Monad.Writer.listen
18:54:54 <lambdabot> MonadWriter w m => m a -> m (a, w)
18:55:02 <geekosaur> append is a modification, just a restricted one
18:55:06 <edwardk> those kinda play hell with it
18:55:13 <edwardk> as they are partially "handlers"
18:55:23 <centril> if not, since StateT s a  is not a comonad, it makes sense that IO cant be comonad
18:55:30 <centril> edwardk: the monoid is "here be dragons"
18:56:26 <edwardk> StateT s a is not a comonad, but it arises by composing the two halves of an adjunction that happens to live in hask (, s) -| (->) s    to get    s -> (a, s)
18:56:38 <edwardk> if you compose them the other way you get (s -> a, s)
18:56:41 <edwardk> which is the store comonad
18:57:01 <edwardk> (# RealWorld# -> a, RealWorld #) doesn't make sense as such though
18:57:46 <edwardk> er (# State# RealWorld -> a, State# RealWorld #)
18:57:48 <centril> edwardk: im pulling a Fermat: "i have a proof" in the margins
18:59:21 <centril> edwardk: damn, category is really awesome for pulling new concepts out like "magic"
18:59:32 <centril> I clearly need to learn it much better
19:04:01 <robertkennedy> :t (# 3 , True #)
19:04:04 <lambdabot> Num t => (# t, Bool #)
19:18:18 <vaibhavsagar> is there a trick to getting stack to build an executable with debugging symbols?
19:22:15 <edwardk> is hackage down?
19:26:14 <Rotaerk_> website at least doesn't look down to me
19:28:42 <pacak> edwardk: works for me
19:37:38 <lpaste_> tswett pasted “pkg-config could not be found” at http://lpaste.net/353621
19:38:24 <tswett_to_go> Hi everyone. I'm trying to run the test suite for haskell-cpython under Windows, and I'm getting an error message. See the lpaste link above.
19:38:29 <geekosaur> pkg-config has to come from your system package manager
19:38:39 <geekosaur> on Windows, that may be a tall order...
19:38:46 <tswett_to_go> Yup.
19:39:53 <geekosaur> although, you should presumably have some kind of mingw/msys/cygwin around
19:40:06 <geekosaur> since I think it's required for ghc on windows
19:40:33 <tswett_to_go> Unsurprisingly, pkg-config isn't in the Windows Store. :)
19:40:56 <tswett_to_go> I saw some Stack Exchange answer saying that one popular way to get pkg-config is to just install GTK+.
19:41:10 <geekosaur> I think that way lies pain
19:41:24 <tswett_to_go> And the GTK+ website said you could use msys2 to install it, but didn't explain how.
19:41:43 <tswett_to_go> So I looked at another Stack Exchange answer which said to run such-and-such pacman commands. And I successfully installed *something*.
19:41:47 <geekosaur> pkg-config is roughly the C/C++ equivalent of ghc-pkg. programs have to register their libraries with it.
19:41:52 <tswett_to_go> But whatever it was, it didn't seem to provide pkg-config.
19:42:18 <geekosaur> if you are using libraries that are not from msys2 or whatever, they will not know about or use pkg-confgig
19:42:43 <tswett_to_go> Makes sense.
19:42:44 <geekosaur> are you running frm cmd.exe, or from powershell, or from an msys2 shell?
19:42:55 <tswett_to_go> I'm running cabal from cmd.exe.
19:43:13 <geekosaur> you should probably be using the latter (msys2 programs can run from cmd.exe but it takes a bit of fiddling)
19:43:31 <tswett_to_go> I'll give it a shot.
19:44:28 <tswett_to_go> "bash: cabal: command not found" Right... that's not hard to get around.
19:45:15 <tswett_to_go> "cabal.exe: The program 'ghc' version >=6.4 is required but it could not be found."
19:45:20 <tswett_to_go> I don't like the way this is going. :D
19:45:41 <geekosaur> likely need to add the haskell platform bin path to your bash $PATH
19:46:17 <geekosaur> C:\Program Files\Haskell Platform\8.0.2\bin\ but I don't recall how msys2 bash wants you to say that
19:46:24 <geekosaur> (probably won;t work as a windows path)
19:47:05 <lpaste_> tswett revised “pkg-config could not be found”: “pkg-config could not be found” at http://lpaste.net/353621
19:47:15 <tswett_to_go> I got the pkg-config could not be found error again.
19:47:24 <tswett_to_go> I'm kind of relieved. :D
19:52:00 <tswett_to_go> http://stackoverflow.com/a/25605631 "A alternative without glib dependency is pkg-config-lite.  Extract pkg-config.exe from the archive and put it in your path."
19:52:03 <tswett_to_go> Sounds easy enough.
19:56:00 <k0m> set chat.*
19:56:27 <edwardk> haddock: internal error: Ix{Int}.index: Index (1280) out of range ((0,437))  -- has anyone encountered this one before?
20:00:00 <kshukla> Can I have a data definition inside a let expression?
20:00:29 <Koterpillar> AFAIK no
20:00:49 <geekosaur> no
20:00:55 <pacak> kshukla: Nope.
20:00:55 <kshukla> ... and in a where clause?
20:00:59 <geekosaur> no
20:01:00 <pacak> And nope.
20:01:01 <edwardk> kshukla: no to both
20:01:06 <kshukla> thanks
20:01:20 <edwardk> well, technically inside the module Foo where ... is inside a where clause ;)
20:02:15 <tswett_to_go> module Foo where rownum <= 100;
20:03:37 <tswett_to_go> Anyway, looks like cabal was pacified by installing pkg-config-lite. I don't think pkg-config-lite actually *works* the way cabal wants it to.
20:03:46 <tswett_to_go> But cabal doesn't seem to actually care that it doesn't work. :)
20:09:09 <tswett_to_go> "cabal: The pkg-config package 'python-3.5' is required but it could not be found." Yeah... I was kind of afraid of that.
20:09:39 <tswett_to_go> This is while running it in an environment where running "python" gives you Python 3.5.2.
20:09:57 <tswett_to_go> Which is supposedly the exact version of Python that this version of haskell-cpython expects.
20:10:08 <Koterpillar> tswett_to_go: well, that's possible even without Windows in the mix, because you can have the binaries but not headers
20:10:32 <tswett_to_go> Koterpillar: ah, right. If this were Linux, I'd have to install the -devel packages, right?
20:10:36 <Koterpillar> tswett_to_go: e.g. on a Debian system you'd install python-dev to get pkg-config... yes
20:10:43 <tswett_to_go> Yup.
20:13:26 <tswett_to_go> Looks like I have them. They're in C:\Users\tanne\Anaconda3\envs\keras-tf\include.
20:13:30 <tswett_to_go> At least, that's where I have *one* set. :)
20:14:14 <tswett_to_go> I've got another set in C:\Users\tanne\Anaconda3\pkgs\python-3.5.2-0\include...
20:14:31 <tswett_to_go> Something I haven't tried is actually running the real Python 3.5.2 Windows installer.
20:16:43 <tswett_to_go> No... I *have* run the real Python 3.5.2 Windows installer. That put the include files in C:\Users\tanne\AppData\Local\Programs\Python\Python35\include.
20:17:42 <geekosaur> tswett_to_go, as I said earlier: Windows native programs do not know about or use pkg-config
20:17:57 <tswett_to_go> Oh right... you said they have to register somehow?
20:18:34 <geekosaur> The libraries may well be there, but the Haskell package you are trying to install told cbal to use pkg-config to find the libraries. pkg-config does not know where to find libraries for a Python installation that did not register its libraries with pkg-config, because it is a native Windows package
20:18:50 <tswett_to_go> Right, right.
20:19:12 <geekosaur> pkg-config is a unix thing, not a windows thing. msys2 has it but that's because msys2 pretends to be unix
20:20:34 <geekosaur> but msys2 pkg-config only knows about msys2 libraries that register with it
20:22:07 <Koterpillar> is there python for msys2?
20:23:32 <tswett_to_go> I wonder if haskell-cpython is even capable of using Python out of %PATH%, then, because I've been using Anaconda, and it uses %PATH% to tell the shell which python to use.
20:24:21 <Koterpillar> python on %PATH% is a binary
20:24:24 <Koterpillar> so the answer is no
20:24:30 <Koterpillar> because it needs python the library
20:24:47 <tswett_to_go> Ohhh. Yeah, I should have thought of that.
20:25:14 <Koterpillar> s/binary/executable/
20:25:49 <tswett_to_go> I find myself yearning for the familiar comfort of the .NET Framework, where the only difference between an EXE and a DLL is that you can double-click an EXE and it does something.
20:27:51 <tswett_to_go> This is making me wonder if there's some better interoperability solution out there.
20:28:33 <tswett_to_go> Maybe there's some Python library I can use to expose a module as a web service, and then a Haskell library that will call that web service.
20:28:47 <tswett_to_go> I just have to use Windows Communication Foundation to... uh...
20:29:03 <tswett_to_go> I've really been using .NET too much. :)
20:29:49 <Koterpillar> tswett_to_go: reverse engineer multiprocessing or celery?
20:31:09 <tswett_to_go> Hmmm. A benefit of a network-based solution is that I'd be able to do the Haskell part under Linux.
20:32:08 <Koterpillar> I'd definitely look into celery protocol
20:32:29 <Koterpillar> (IDK what random parts fall off Python on Windows, though)
20:41:23 <platz> anyone use concurrent-output?  curious how the stm-in-anger approach works out
21:03:44 <tswett_to_go> I'm going to give SOAP a shot. That's Definitely Not a Bad Idea At All.
21:06:25 <tswett_to_go> I'm gonna hit the sack. Night, everyone.
21:24:59 <jle`> is there any way to double up on type family dependencies
21:25:06 <jle`> type Fam a b = c | c -> a, c -> b ?
21:33:48 <MarcelineVQ> type familiy Fam a b = c | c -> a b     maybe
21:45:07 <halogenandtoast> MarcelineVQ: really... https://github.com/MarcelineVQ/marcelinevq.github.io/blob/master/index.html#L1
21:47:40 <halogenandtoast> I want to rewrite my personal website at some point in Haskell
21:48:25 <halogenandtoast> it sucks at the moment as I'm just using ghost as a blogging platform (and I don't love JavaScript).
21:48:34 <halogenandtoast> Considering using Hakyll
21:49:47 <tippenei1> ^ would recommend
21:50:28 <tippenein> there are plenty of good examples around and the documentation is sufficient
21:58:30 <jle`> halogenandtoast: fwiw my blog is in hakyll + purescript
22:02:30 <halogenandtoast> jle` link?
22:05:03 <jle`> http://blog.jle.im
22:05:14 <jle`> i even wrote a post about the transition/rewrite if you're interested
22:05:31 <jle`> but to be fair, i rewrote it from scotty, another haskell library lol
22:06:32 <halogenandtoast> jle`: Looks nice, I'll check it out
22:24:11 <MarcelineVQ> halogenandtoast: what :>
22:27:16 <halogenandtoast> MarcelineVQ: I was expecting something useful/interesting, was dissappointed.
22:27:44 <MarcelineVQ> oh no I don't make useful things, I'd have to get payed if I did that
22:32:49 <MarcelineVQ> hopefully there's something interesting around there though :>
22:45:53 <halogenandtoast> MarcelineVQ: I stopped investigating at that point
