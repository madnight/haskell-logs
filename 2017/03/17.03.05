00:03:44 <Cale> mbw: There's no convention -- Ix lets you choose whatever bounds make the most sense for your application.
00:04:02 <Cale> (if you want to start an array at 137, you can do that)
00:04:29 <Cale> 0 would usually be preferred, all else being equal though
00:10:24 <spatial> http://pastebin.com/LxzCpQgE I have errors in this code.
00:10:42 <spatial> Trying a State Monad to store a global array. 
00:11:20 <spatial> storearray "value-table" ( newArray (512,512) 0 )         has a problem.
00:14:33 <spatial> I guess the pattern will work if I remove the errors.
00:18:11 <ferlif> ciao
00:19:21 <mbw> Cale: Ok, that's good to know.
00:25:17 <cocreature> mbw: these days https://hackage.haskell.org/package/vector is arguably the most common implementation of arrays and it uses 0 based indices
00:34:34 <roundhouse> hi, how can I reference a type of the sourrounding environment? If I have "f :: (Monad m) => m ();  f = g;   where g :: m ()...) I get an error that the the monad of g m1 can't be matched with the one of f.
00:49:27 <spatial> http://pastebin.com/mQcJJ4f5 I've changed and now the last function 'BoardState' has errors. Why ?
00:49:53 <spatial> * Couldn't match type `(,) (Maybe (IOArray Int Int))' with `IO'
01:01:42 <cocreature> spatial: putmutablearray first calls "newArray" so the do block has to be of type IO a for some a, but then it calls storearray which is of type State … … but State and IO are not the same thing
01:02:15 <cocreature> roundhouse: enable ScopedTypeVariables and change the signature of f to "f :: forall m. (Monad m) => m ()"
01:04:13 <roundhouse> cocreature: Thank you, I'll have to read up on that extension
01:06:07 <spatial> Should that be split into two ?
01:07:08 <roundhouse> cocreature: Exactly what I was looking for :)
01:35:57 <spatial> Should I split putmutablearray = do {                         arr <- newArray (512,512) 0 ;                        storearray "value-table" arr                      } into two ?
01:37:08 <spatial> The idea is to store an array using the State Monad. And read and write.
01:40:13 <spatial> Can I see an example that correctly does what I am doing http://pastebin.com/mQcJJ4f5?
02:50:47 <Danny_> Anyone on?
02:51:23 <int-e> ...
02:51:58 <suppi> ..
02:52:42 <Xnuk> .
02:58:30 <dyreshark>  
03:10:50 <aregidor> hi
03:12:38 <eSko> https://www.youtube.com/watch?v=ZFxqjZ2H9yE
03:14:15 <aregidor> somebody knows what's the problem with this program? http://pastebin.com/fzwk41Zp
03:14:21 <aregidor> I obtain:
03:14:24 <aregidor> a.hs:9:21:
03:14:26 <aregidor>     Couldn't match expected type `String -> String'
03:14:28 <aregidor>            against inferred type `[Char]'
03:14:30 <aregidor>     Probable cause: `showString' is applied to too many arguments
03:14:32 <aregidor>     In the first argument of `Endo', namely `(showString t)'
03:14:34 <aregidor>     In the expression: Endo (showString t)
03:26:37 <Xnuk> :t Endo
03:26:41 <lambdabot> (a -> a) -> Endo a
03:27:13 <Xnuk> :t showString
03:27:16 <lambdabot> String -> ShowS
03:27:52 <Xnuk> so (a -> a) is ShowS, which is String -> String
03:28:05 <Xnuk> so you'll get Endo String
03:28:07 <Xnuk> aregidor: 
03:28:21 <aregidor> Xnuk: yes
03:28:28 <aregidor> mmm
03:28:50 <aregidor> aaah, ok
03:29:01 <aregidor> thanks, Xnuk 
04:09:57 <kuribas> How do I skip an expression in the ghci debugger?  :force doesn't seem to work...
04:10:16 <kuribas> I am using :step to step through the expression.
04:11:12 <kuribas> Also why can I not inspect the whole environment in the debugger?
04:11:32 <kuribas> It only allows me to inspect variables in the expression under focus.
04:28:03 <abhiroop> Can anyone tell me how haskell STM or STM in general deals with Reentrancy?
04:29:11 <hpc> it doesn't
04:29:21 <hpc> look at the docs for unsafeSTMToIO
04:29:39 <hpc> rather, https://hackage.haskell.org/package/base-4.9.1.0/docs/GHC-Conc.html#v:unsafeIOToSTM
04:30:28 <hpc> also https://hackage.haskell.org/package/base-4.9.1.0/docs/GHC-Conc.html#v:atomically
04:37:11 <dramforever> abhiroop: STM actions are always reentrant, as long as you don't use 'unsafeIOToSTM' &friends
04:39:14 <abhiroop> dramforever: "STM actions are always reentrant" -> Could you please elaborate on this?
04:39:50 <abhiroop> In fact 'unsafeIOToSTM' which hpc pointed seems to be the only thing handling reentrancy
04:49:48 <dramforever> abhiroop: What things can be non-reentrant?
04:50:29 <dramforever> Well, writeTVar, you can think of those writes as batched all the way to completion
04:50:58 <dramforever> And the changes are applied only if non of the results of the reads changed
04:51:10 <dramforever> It's like a super CAS loop
04:51:55 <abhiroop> dramforever: yes I am aware of the working of STM transactions
04:52:25 <abhiroop> In fact I was going through the composable transactions paper by SPJ, Simon Marlow et al when I was wondering about reentrancy
04:52:39 <abhiroop> No where in the paper they discuss reentrancy
04:52:55 <abhiroop> "What things can be non-reentrant?" -> Well any pure function
04:53:00 <dramforever> ?
04:54:12 <abhiroop> I just want to clarify my definition of reentrancy
04:54:17 <dramforever> abhiroop: Can you give an example of where this is a problem?
04:54:46 <abhiroop> When a concurrent object itself actively yields without being preempted by the scheduler
04:55:13 <abhiroop> and talks to another cncurrent object
04:55:38 <dramforever> Huh
04:55:45 <abhiroop> which reenter the control flow back to the original concurrent object
04:55:57 <dramforever> "concurrent object" -> like thread?
04:55:59 <abhiroop> So obj A -> obj B -> obj A
04:56:17 <abhiroop> Isn't that reentrancy
04:56:29 <abhiroop> A TVar
04:56:48 <dramforever> Data doesn't have control flow don't they
04:57:00 <dramforever> s/don't/does
04:57:12 <dramforever> Damn I can't English
04:57:29 <abhiroop> Yes you are right
04:57:31 <dramforever> abhiroop: What do you mean by reentering the control flow back to some piece of data?
04:57:49 <abhiroop> Actually let me try to reframe my thoughts
04:57:59 <abhiroop> As you were telling
04:58:02 <abhiroop> A thread
04:58:09 <abhiroop> yes the control flow of a thread
04:58:22 <abhiroop> So Thread 1 -> Thread 2 -> Thread 1
04:58:32 <abhiroop> Is that reentrancy?
04:58:38 <dramforever> Yes it is
04:58:42 <dramforever> it goes like this:
04:58:43 <abhiroop> Cool
04:58:52 <dramforever> We have a TVar holding 1
04:59:09 <abhiroop> so any form of communication between the threads where there is yielding of control
04:59:15 <dramforever> Thread1 reads it, gets 1, but before the STM action completes, we switch to Thread2
04:59:18 <abhiroop> How do I get that to work?
04:59:44 <dramforever> Oh wait, *without* being preempted
04:59:52 <abhiroop> "we switch to Thread2" -> you mean the scheduler
05:00:14 <abhiroop> Oh wait, *without* being preempted -> EXACTLY
05:00:22 <dramforever> abhiroop: You can't really do that in STM
05:00:30 <dramforever> You have to do that in IO
05:00:44 <dramforever> STM transactions are meant to be small and quick
05:00:59 <abhiroop> and so use https://hackage.haskell.org/package/base-4.9.1.0/docs/GHC-Conc.html#v:unsafeIOToSTM
05:01:19 <abhiroop> ?
05:01:35 <dramforever> abhiroop: The third bullet point in that
05:01:39 <dramforever> That's the problem, I suppose
05:02:14 <abhiroop> Yes this "Invariants that you expect to be true throughout your program may not be true inside a transaction, due to the way transactions are implemented."
05:02:35 <dramforever> So it doesn't handle the thing you call reentrancy
05:02:41 <dramforever> (I would call it 'coroutine')
05:02:44 <abhiroop> I am very used to lock based concurrency and using Reentrant locks
05:02:55 <abhiroop> "(I would call it 'coroutine')" -> Yes
05:03:03 <abhiroop> Thanks dramforever
05:03:31 <spatial> putmutablearray = do {                        arr <- newArray (512,512) 0 ;                        storearray "value-table" arr                      } IO and IOArray Int Int    Should I split into two ?
05:04:00 <dramforever> abhiroop: When I use STM I send messages between threads through stuff like TChan
05:04:09 <zeawee> C
05:04:10 <dramforever> Not 'tell the other thread to work' directly
05:04:29 <abhiroop> Oh..
05:04:46 <abhiroop> Well actually thats what I was getting at
05:05:01 <abhiroop> how do you solve for cases which involves reentrancy
05:05:14 <spatial> Anyone can suggest error fixes for my code http://pastebin.com/mQcJJ4f5 ?
05:05:34 <dramforever> abhiroop: That makes me wonder
05:05:41 <dramforever> Why are you using two threads?
05:05:59 <abhiroop> Well actually no I am not.
05:06:21 <dramforever> Then, huh?
05:06:25 <abhiroop> Like I said I was reading the paper Composable Transactions and wondering about handling reentrancy
05:06:29 <abhiroop> :)
05:06:38 <dramforever> Well
05:07:04 <dramforever> That's like reading a baking tutorial and asking 'What about the bacon'?
05:07:08 <contiver_> is there a way to get a list of constructors from a data type? I'm aware that if constructors take a different amount of parameters, then the list wouldn't be homogeneous and it would usually not be possible. But in my case it's a bunch of unary constructors, so I thought maybe there is a work around.
05:07:12 <dramforever> '? -> ?'
05:07:35 <abhiroop> yeah true :)
05:07:53 <contiver_> Tried with Data.Data and Data.Typeable, but dataTypeConstrs gives a list of [Constr], not what I'm looking for :/
05:09:11 <abhiroop> dramforever: But I guess its not very difficult to think about cases of reentrancy
05:09:16 <abhiroop> On the top of my mind
05:09:35 <abhiroop> some mutually recursive function operating in a multi threaded environment
05:09:39 <contiver_> I need to list the constructors for an Arbitrary instance, and would prefer to avoid repeating them (to keep a single source of truth)
05:15:43 <melancholiac> why does ghc package is so big (1146.92 MiB)?
05:20:44 <bjobjo> quick and stupid question: does GHC only consider 8 spaces valid indentation? I can't seem to make my nested where's work with 4.
05:22:47 <spatial> IO ( IOArray Int Int) to IOArray Int Int     Get newArray and store in Map Is that possible ?
05:24:06 <Fendor> bjobjo, if i'm right in memory, it doesn't matter as long the indentations match up with the other lines
05:24:12 <Fendor> so 4 should be fine, 2 should be fine
05:24:16 <Fendor> never tried 3 
05:24:17 <Fendor> oder one
05:24:43 <bjobjo> that's weird, I believe my editor has been set up with soft tabs everywhere, but I'll have to check with vim or something
05:25:33 <Fendor> do manual spaces, then youll see whats the problem
05:26:11 <bjobjo> looks all right in vim too, all spaces everywhere (I've had troubles with mixed tabs/spaces before)
05:26:43 <contiver_> bjobjo, if you can show us the code, we might be able to find out why.
05:27:01 <bjobjo> one sec
05:28:27 <lpaste_> bjobjo pasted “nested where indentation issues” at http://lpaste.net/353233
05:29:19 <contiver_> bjobjo, if I'm not mistaken, you need to indent the 2nd where past the 1st one
05:29:36 <bjobjo> oh, so since where is 5 chars, 4 spaces is not enough?
05:30:01 <Tuplanolla> This also applies to statement-let, bjobjo.
05:31:04 <contiver_> bjobjo, my understanding is that the column for the first where's definitions starts where mapOperatingSystem starts
05:31:17 <hexagoxel> bjobjo: the "mapOS .." defines the indentation level for the where-decls. But the second where goes left of that.
05:31:21 <contiver_> not sure if it would work just below it, but probably a single space after it, works.
05:31:36 <hexagoxel> ^
05:32:25 <hexagoxel> you can decrease overall indentation by newline after first where.
05:32:56 <contiver_> also, you can avoid the second where. Just define both functions under the first one, it should also work, and is cleaner (IMO).
05:33:24 <bjobjo> all right, let me try it out a bit
05:33:27 <bjobjo> thanks all :)
05:34:20 <lpaste_> hexagoxel annotated “nested where indentation issues” with “nested where indentation issues (annotation)” at http://lpaste.net/353233#a353234
05:35:11 <bjobjo> in this particular case, skipping the second where certainly looks better
05:57:51 <Squarism> Did not thing order of declaration didnt matter in haskell? like if i declare A after B, where A is used i should not get an error?
05:57:58 <Squarism> think
05:57:59 <bollu> what is a cute library for pretty printing?
05:58:56 <Theophane> Squarism: I don't think so. Due to lazyness, if you don't have to use B before A is declared, it will work
06:02:18 <Squarism> Theophane, here (http://lpaste.net/353236) i get a compile error on line 28 "Not in scope: type constructor or class ‘OAuthProviderId’" ..which is declared on line 157
06:02:59 <Theophane> okay
06:03:44 <pavonia> Squarism: I think this is due to the use of TH
06:04:03 <Squarism> pavonia, oh ok. 
06:04:17 <mniip> Theophane, laziness is unrelated
06:04:39 <Theophane> ok
06:04:42 <Squarism> pavonia, is there any workaround - sure i could move stuff - but it would be nice to keep things in their sections
06:05:20 <pavonia> I'm not aware of one
06:06:26 <ertes> Squarism: generate the lenses *after* you have defined all types
06:06:38 <Squarism> oh ok
06:07:18 <Squarism> ertes, btw - thanks for your stubborn questioning. I followed your path and arrived at greatness! =D
06:07:28 <ertes> great =)
06:08:31 <ertes> BTW, another option is not to use TH and write the lenses yourself…  that option gives you the opportunity to document your lenses, too =)
06:12:14 <ertes> Squarism: regarding TH: imagine that in every line that uses top-level TH there is a "can't look ahead past here" barrier…  that's why you should always define your types first when using makeLenses
06:13:01 <Squarism> sounds like extra work spiced with extra work on the not most prioritized issue at hand =D
06:13:45 <Squarism> i understand. Lenses last it will be
06:14:11 <Squarism> it seems it fixed the problem too btw.
06:16:34 <ertes> Squarism: yeah, makeLenses is just inconvenient enough that i tend not to use it most of the time =)
06:17:04 <ertes> would be nice to have a restricted subset of TH that doesn't ruin lookahead
06:30:51 <lyxia> just wait for a Generic implementation of lenses
06:31:07 <piyush-kurur> any one with access to openbsd + GHC
06:31:47 <lyxia> Squarism: see http://lpaste.net/353163
06:34:15 <Squarism> lyxia, thats beyond my current level. It guess ill have to experiance some real problems with makeLenses first =D
06:34:38 <Squarism> ...before looking for alternatives
06:43:23 <cocreature> Bob131: wl-pprint-text is pretty nice
06:44:25 <cocreature> eh that was for bollu but they already left
06:49:35 <ertes> proposal: let's rename 'liftIO' to 'io' =)
06:49:53 <johnw> ertes: easy to do as a local function
06:50:16 <ertes> sure
06:50:32 <ertes> but a first-hand definition has soooooooooooo many advantages, you know
06:50:51 <ertes> like being first-hand
06:50:53 <ertes> and having advantages
06:51:22 <cocreature> I don’t think that’s a well founded definition of the advantages it provides
06:51:52 <ertes> if you think corecursively it is =)
06:52:46 <cocreature> are corecursive definitions also called „well-founded“?
07:03:07 <johnw> cocreature: I'm not seeing that used in the literature for the case of corecursion
07:03:47 <johnw> in Coq we just talk about the guardedness condition
07:09:09 <lyxia> which is a heuristic for productivity
07:11:42 <xubunto> is it possible to map a prefix expression such as div?
07:12:11 <Rembane> xubunto: Map it to what?
07:12:12 <johnw> lyxia: well, it's a conservative heuristic, and not just "probably productive"
07:12:25 <xubunto> Rembane: 2 values
07:12:57 <Rembane> xubunto: Yes. In a number of ways, for instance: zipWith div [1..10] [10,9..1]
07:13:11 <Rembane> xubunto: Or: map (`div` 10) [1..]
07:13:30 <xubunto> what about (map . map)"
07:14:12 <tomboy64> isn't it map (div 10) [1..]?
07:14:29 <xubunto> tomboy64: trying to see if there is a way to do only div
07:15:00 <tomboy64> xubunto: "only div"?
07:15:19 <xubunto> tomboy64: not div 10, only div
07:15:30 <tomboy64> map it to what?
07:16:01 <ertes> is there a way to convert an at-most-one-Traversal into an IndexPreservingTraversal?  writing an IndexPreservingTraversal directly is pretty awkward
07:16:02 <xubunto> tomboy64: 2 lists
07:16:43 <tomboy64> xubunto: map (\x -> map (\y -> div x y) ylist) xlist
07:17:08 <Rembane> tomboy64: If you run div 10, you will divide 10 with something, if you use (`div` 10) you will divide something with ten.
07:17:16 <tomboy64> or [ z | div x y, x <- xlist, y <- ylist ]
07:17:37 <tomboy64> errr
07:17:46 <ertes> xubunto: what are your inputs, and what is the desired result?
07:18:05 <tomboy64> no that can't be right
07:18:29 <xubunto> ertes: i would love to be able to do map div [1,2,3] [4,5,6]
07:18:31 <tomboy64> ertes: 2 lists. he either wants zipWith or something to create a 2d-field
07:18:41 <int-e> tomboy64: did you mean [div x y | x <- xlist, y <- ylist]?
07:18:50 <tomboy64> int-e: exactly
07:19:04 <xubunto> int-e: that is list comp right?
07:19:05 <int-e> you could use applicatives: div <$> xlist <*> ylist
07:19:11 <int-e> xubunto: yes
07:19:46 <ertes> xubunto: and what's the desired result?
07:20:02 <ertes> there are a number of options
07:20:07 <xubunto> ertes: int-e got it
07:20:11 <lyxia> johnw: could we say guardedness is to productivity as well-foundedness is to termination?
07:20:32 <xubunto> i wanted to see if i could use <$> and <*> with a prefix method to better understand how it works
07:22:16 <johnw> lyxia: in Coq that is entirely true.  Terminating functions must destruct their argument down to a base case (proven by a well-founded relation), and Productive functions must always construct new layers around subsequent calls (I'm not sure if a means exists, though, to prove this by a relation that represents a greatest fixed point)
07:22:43 <johnw> corecursion is certainly less mature than recursion
07:23:35 <johnw> (er, in Coq)
07:23:50 <johnw> I think if it were used more, it would have better support
07:24:28 <lyxia> I see. Thanks!
07:26:33 <ertes> hmm, -XMultiWayIf doesn't work in arrow notation…  great =/
07:26:51 * ertes resorts to the (case () of _ | …) hack
07:33:34 <ertes> there has to be a nicer way to write this: https://gist.github.com/esoeylemez/5dffd42b4fee7f8591c8fddf778830c5
07:34:15 <ertes> (i have traversals with more than two cases, so the 'case' is just for demonstration purposes)
07:35:36 <ertes> i thought of using ArrowMonad, but there is no obvious way to use it that would actually be nicer than this
07:46:53 <bollu> isn't the non-commutativity of monad transformers a huge pain?
07:47:12 <johnw> bollu: you mean, in general?
07:47:15 <bollu> yes
07:47:25 <johnw> bollu: some are commutative (like ReaderT, with any monad)
07:47:29 <johnw> no, no particular pain
07:47:41 <bollu> I see
07:47:49 <Rembane> It's less than you might think. :)
07:48:22 <bollu> johnw: I've been using State + Error, which don't commute. I was wondering what would happen if I start adding things like Cont
07:48:31 <bollu> johnw: reasoning seems hard
07:48:54 <johnw> State + Error just has outright different semantics than Error + State.  It's a feature that you can chose the meaning that is most appropriate.
07:49:23 <bollu> johnw: isn't that what "don't commute" means? :) semantics don't match if you flip them?
07:49:25 <johnw> ContT is a bit of a special beast; it introduces a couple restrictions that most other transformers don't have
07:49:39 <bollu> johnw: hm, I see. I have been told that ListT is also hard to "get right?
07:49:42 <Tuplanolla> How pleasant are noncommutative monads to use in mtl style?
07:49:42 <bollu> "*
07:49:43 <johnw> bollu: well, in that case, commutativity would mean eliminating information
07:49:48 <bollu> johnw: yeah
07:50:00 <Tuplanolla> I've never tried that.
07:50:02 <johnw> ListT isn't all that hard to get right, it's just that the naive version isn't right at all
07:50:04 <bollu> johnw: is there some way to systematically derive like, the, "commutator" of two monads?
07:50:31 <johnw> bollu: no
07:50:33 <bollu> johnw: like, in the group theory sense of the word, I can abelianise a group by finding the commutator subgroup, right?
07:50:36 <bollu> oh, that's sad
07:51:30 <cocreature> Tuplanolla: it’s a bit weird since your semantics now change depending on how you instantiate the type class constraints
07:51:44 <bollu> if I have a StateT s Either e a, and I have a "Left e", how do I raise it into the StateT? "lift" doesn't seem to be doing the trick
07:52:18 <johnw> make a combinator called "left"
07:52:34 <bollu> do I get it by default with mtl?
07:52:35 <Tuplanolla> I can imagine, cocreature. It feels like pushing an unnecessary choice to the user.
07:52:51 <johnw> left e = StateT $ \_ -> Left e
07:53:01 <johnw> bollu: I don't think so
07:53:10 <johnw> mtl doesn't really give you combinators specific to certain combinations
07:53:12 <bollu> hm, OK, thanks :)
07:53:55 <cocreature> wait why does lift not work?
07:54:02 <johnw> yeah, I'm wondering that now too
07:54:07 <cocreature> :t lift :: Either e a -> StateT s (Either e) a
07:54:10 <lambdabot> Either e a -> StateT s (Either e) a
07:54:15 <cocreature> works just fine
07:54:51 <Tuplanolla> One other thing that bugs me is using `bracket` and friends with mtl style.
07:54:58 <xubunto> how would I get a file with <$> and <*> to compile?
07:55:03 <Tuplanolla> You have to choose an order for that.
07:55:27 <cocreature> xubunto: I don’t understand that question. do you have some specific error?
07:55:38 <xubunto> cocreature: not in scope
07:55:47 <cocreature> xubunto: import Control.Applicative
07:56:03 <cocreature> or use a newer ghc, 8.0 should have them in the Prelude iirc
07:56:14 <Tuplanolla> Even 7.10 does, cocreature.
07:56:24 <bollu> johnw: well fuck, turns out I wanted ExceptT e State s a
07:56:30 <johnw> bollu: haha
07:56:30 <cocreature> Tuplanolla: ah nice, I wasn’t sure when that was introduced
07:56:30 <bollu> johnw: I misinterpreted the way they compose :P
07:56:37 <johnw> bollu: don't worry, that happens to all of us
07:56:44 <Tuplanolla> I'm still stuck in 7-land here.
07:56:49 <johnw> the composition is somewhat the inverse of the execution
07:56:53 <bollu> yeah
07:56:55 <bollu> just noticed xD
07:56:59 <johnw> ExceptT on the "outside" means that it's the most immediate effect
07:57:03 <cocreature> bollu: in that case the function you’re looking for is called "hoistEither"
07:57:22 <bollu> cocreature: I see, thank you
07:57:28 <cocreature> it’s in the errors package iirc
07:57:52 <bollu> cocreature: interestingly enough, this is the first time I have decided to use lens in a full blown fashing
07:58:05 <bollu> cocreature: it's fun, seeing how a "throw everything together" sort of codebase works out
07:58:12 <bollu> everything = mtl + lens + other stuff
07:58:13 <johnw> bollu: are you in the SF bay area by any chance?
07:58:24 <bollu> johnw: naw, India :) undergrad
07:58:27 <xubunto> cocreature: tyvm
07:58:29 <bollu> johnw: why?
07:58:29 <johnw> I'm going to be giving a talk on "pratical lensing" at BayHac
07:58:34 <bollu> ooh, that is quite cool
07:58:46 <johnw> like, a totally non-theory, "this is how we use lenses to get stuff done at my job" type of presentation
07:58:59 <johnw> since we use lenses in everything we do
07:59:11 <cocreature> bollu: oh btw you mentioned that you’re coming to zurich right? will you be at zurihac?
07:59:14 <bollu> johnw: I have actually been trying to understand the theory. I dislike treating haskell libraries as libraries, they usually have some super pretty theory
07:59:18 <Tuplanolla> Does it involve `RankNTypes`, johnw?
07:59:24 <bollu> cocreature: I am considering it. I will have to ask my professor!
07:59:37 <bollu> cocreature: I'll be at ETH, so I'm not sure how far away it is
07:59:38 <johnw> Tuplanolla: at most I'm going to mention ALens as a way to avoid that requirement
07:59:54 <bollu> johnw: will there be a video recording? I would love to watch it 
07:59:58 <bollu> johnw: of the talk that is
08:00:04 <johnw> Tuplanolla: however, my upcoming talk on in the south bay on quantification will cover RankNTypes in detail
08:00:08 <johnw> bollu: I think so
08:00:42 <Tuplanolla> To me that extension is a sign that I'm lensing too hard and need to stop, johnw.
08:00:48 <johnw> haha
08:01:04 <bollu> cocreature: I am registering, what the hell, might as well :)
08:01:09 <bollu> cocreature: will you be there?
08:01:11 <johnw> I don't often treat lenses as values in my work use of lens
08:01:14 <cocreature> bollu: looking forward to meeting you there!
08:01:17 <johnw> sometimes, but not often
08:01:24 <bollu> cocreature: you too :D
08:03:33 <ertes> Tuplanolla: uhh…  why?
08:04:03 <ertes> RankNTypes is mostly a convenience feature with lenses
08:04:32 <Tuplanolla> It means I'm spending more times making functions from lenses to lenses than doing useful things, ertes.
08:04:54 <ertes> ah =)
08:05:12 <ertes> you don't need RankNTypes for that though
08:05:49 <johnw> wouldn't he if the function were Lens' s a -> Lens' t b?
08:05:57 <ertes> if you change the type signature of your function, it may become more efficient, and you may get rid of that indicator, so you can keep lensing happily =)
08:06:43 <ertes> johnw: i think most of the time you can work with LensLike and not use RankNTypes
08:07:19 <ertes> at least for the use cases that come to my mind
08:07:33 <cocreature> johnw: I don’t think you can avoid enabling RankNTypes by the use of a type synonym or can you?
08:08:08 <johnw> cocreature: well, you could use LensLike, or unfold the type aliases and share the constraint
08:09:08 <Tuplanolla> What if you want to use an argument lens over more than one functor?
08:09:09 <johnw> i.e.,: foo :: forall f. Functor f => ((a -> f a) -> s -> f s) -> (b -> f b) -> t -> f t
08:09:37 <johnw> in fact, if you get used to writing lenses as plain functions, you can create them without even importing lens
08:10:46 <Tuplanolla> The lens equivalent of `\ p fs xs -> (p fs) (p xs)`.
08:55:11 <nshepperd_> Tuplanolla: ALens / cloneLens i guess
08:56:15 <Tuplanolla> Not in Microlens unfortunately.
08:59:12 * hexagoxel replaces `mp >>= \x -> go $ (\g -> g $ f x) <$> rest` with `go rest >>= \g -> g . f <$> mp`, and has spent way too much time on that change.
09:00:09 <hexagoxel> encoding functions of arbitrary arity in a free applicative requires strangely reversed order of effects..
09:00:55 <spaceghost[m]> No uses el nombre de nagorno-karabakh en vano clint.
09:01:04 <johnw> ... go $ ($ f) <$> mp <*> rest ...?
09:01:15 <johnw> no, (($) . f)
09:01:26 <johnw> haha, future readers will hate you either way
09:01:55 <hexagoxel> exactly :D
09:02:05 <johnw> do x <- mp; g <- rest; go (g (f x))
09:02:34 <hexagoxel> you are optimizing the replaced variant btw.
09:03:01 <hexagoxel> do g <- go rest; p <- mp; return (g (f p))
09:05:03 <johnw> yeah, I'd rather read that
09:05:37 <johnw> of course, if we had idris we could so: return $ !(go rest) (f !p)
09:05:42 <johnw> s/so/say
09:05:52 <hexagoxel> if you have a rough idea what the function is supposed to do, do-vs-pointfree does not change too much. If you don't, then either won't make sense.
09:05:54 <johnw> err, f $mp
09:05:56 <johnw> f !mp
09:08:00 <lpaste_> hexagoxel pasted “context, just for fun” at http://lpaste.net/353240
09:08:22 <hexagoxel> "<- eqT ->" is such a tease, visually.
09:09:30 <Gurkenglas> hexagoxel, why isnt the "step f rest $" in line 4 instead?
09:09:32 <johnw> why lambdacase and not just two definitions?  It would be the same exact size
09:10:23 <hexagoxel> more importantly, i think i can use runAp.
09:10:42 <bollu1> if I have a lens into a small part of my state, how do I set it inside a State monad?
09:10:51 <Gurkenglas> The whole thing looks like just a monadic catamorphism, um, I think the thing that defines free monads?
09:10:53 <tsahyt> I've been puzzling over this for a while now. Given an (r -> (b,d)) -> (r -> (c,d)), I'd like to construct an (r -> b, d) -> (r -> c, d). Is this even at all possible?
09:12:01 <Gurkenglas> :exf ((r -> (b,d)) -> (r -> (c,d))) -> ((r -> b, d) -> (r -> c, d))
09:12:03 <tsahyt> the use case here is that I'm trying to write an ArrowLoop instance for something. I've got one version that type checks, but doesn't work in practice, and since my arrows underneath are just specialized functions, I thought I could reuse the instance for (->) somehow
09:13:19 <tsahyt> @djinn ((r -> (b,d)) -> (r -> (c,d)) -> ((r -> b, d) -> (r -> c, d))
09:13:19 <lambdabot> Cannot parse command
09:13:27 <hexagoxel> @djinn ((r -> (b,d)) -> (r -> (c,d))) -> ((r -> b, d) -> (r -> c, d))
09:13:27 <lambdabot> f a (b, c) =
09:13:27 <lambdabot>     (\ d ->
09:13:28 <lambdabot>      case a (\ _ -> (b d, c)) d of
09:13:28 <lambdabot>      (e, _) -> e,
09:13:28 <lambdabot>      c)
09:13:41 <tsahyt> that went quick
09:14:03 <Gurkenglas> *looks on hackage* oh yes runAp, lets race to who gets that implemented :D
09:14:28 <tsahyt> runAp?
09:16:11 * hexagoxel gets doubts that runAp would work
09:16:24 <tsahyt> @hoogle runAp
09:16:27 <lambdabot> Control.Applicative.Free runAp :: Applicative g => (forall x . f x -> g x) -> Ap f a -> g a
09:16:28 <lambdabot> Control.Applicative.Free.Final runAp :: Applicative g => (forall x . f x -> g x) -> Ap f a -> g a
09:16:28 <lambdabot> Control.Applicative.Trans.Free runAp :: Applicative g => (forall x . f x -> g x) -> Ap f a -> g a
09:18:18 <tsahyt> is there an offline version of djinn somewhere? I think it could be useful to bind this into vim
09:18:41 <hexagoxel> Gurkenglas: i think i make use of the fact that output is a free monad.
09:18:47 <bollu> how do you deal with State / StateT *without* lens?
09:18:50 <hexagoxel> @hackage djinn
09:18:51 <lambdabot> http://hackage.haskell.org/package/djinn
09:18:54 <bollu> isn't it a pain to set particular fields?
09:19:11 <bollu> I've just started using "lens", and it seems super neat
09:19:46 <tsahyt> thanks
09:22:41 <zennist> quick question: does 'cabal sandbox' uses ghci in its building phase?
09:22:59 <hexagoxel> no
09:23:07 <hexagoxel> it uses ghc.
09:23:08 <zennist> I'm getting build errors which look like ghc is trying to load code into ghci - however there is no *TemplateHaskell* enabled or used in my code
09:24:57 <slack1256> anybody know other blogpost of detecting space leaks at writing time like the ones from ezyang?
09:25:58 <johnw> you've read Neil's right?
09:26:19 <slack1256> yep, his trick is the best I know for detecting leaks at runtime
09:26:36 <slack1256> yet my confidence falters that I don't have a good model for writing time
09:26:46 <johnw> oh, writing time
09:27:25 <Gurkenglas> (Oh hey hexagoxel uses f for step so it's a little more tangled but I guess I'll try extracting the recursion scheme)
09:27:36 <slack1256> (I got this app that has a event loop for network events, runtime testing requires mocking stuff and I want to avoid it)
09:31:21 <johnw> it's hard to always know, but things to look out for: (1) calling other functions within a "case", (2) thunks whose result is much smaller than the data they're computed from, (3) creating structures whose spine is strict, but whose contents are not, (4) using tuples too much (very typical way of causing thunks to occur in places where they might not otherwise, as a special case of #3), (5) recursion from within a lambda, (6) expecting
09:31:21 <johnw> State s to be strict in 's', ...
09:36:51 <slack1256> I've been thinking the relationship between the call and the called lately. A big problem is that how memory depends in the intereaction between the two, the cost model is not local
09:37:13 <slack1256> but we can make this simpler if we restrict the functions allowed to `call`
09:37:37 <slack1256> this would be like okasaki analysis of queue being restricted to certain functions
09:37:44 <slack1256> yet I don't know if this is naive
09:40:41 <ph88> maybe stupid question but when i have list in the form of tuples of 2, so   (elem1, (elem2, ())  then how do i find the last occurance of a value ?
09:41:36 <johnw> ph88: You'd need to encode this pattern as a data type, so that you can make use of type recursion, and then write a recursive function
09:41:37 <slack1256> ph88: actually that is a great idea, that exactly is what the Free ADT does
09:42:14 <johnw> well, and lists
09:42:24 <johnw> since what he wrote is the same as Free ((,) a) () ~ [a]
09:42:28 <ph88> johnw, it's already a data type .. but i need 2 functions then one for searching and one for the thing i really want ?
09:42:40 <johnw> ph88: I don't understand
09:43:27 <ph88> johnw, well let's say i have (1, (3, (2, 0))) and i want to change the highest number to 10
09:43:47 <johnw> why do you want to encode a list like this?
09:43:59 <ph88> this is about GHC.Generics
09:44:10 <ph88> :*:
09:45:15 <ph88> so maybe one function that traverse over the list and gives me the index of the highest number, and then another function to traverse again and give back the same list with the number at the index changed to 10 ?
09:45:53 <ph88> i don't have any better ideas
09:46:44 <johnw> I don't understand why these two steps need to be separated
09:46:56 <johnw> I feel like I don't have the full picture
09:47:16 <ph88> what else can i tell you ?
09:50:51 <lpaste_> glguy pasted “starting point for ph88” at http://lpaste.net/353242
09:51:10 <ph88> nice module name
09:51:11 <glguy> You can use that same class to update by value or index
09:51:25 <ph88> oh lens ^^
09:51:51 <johnw> glguy is also allowing a arbitrary tree structure,
09:52:03 <johnw> so (((1, 3), 2), 0) would be allowed too
09:52:37 <ph88> ye
09:52:46 <ph88> but what about changing the value of the highest to 10 ?
09:53:48 <glguy> *Ph88> itoListOf (indexing ints) (1::Int,(3::Int,(2::Int,0::Int)))
09:53:48 <glguy> [(0,1),(1,3),(2,2),(3,0)]
09:54:24 <glguy> *Ph88> set (elementOf (indexing ints) 2) 20 (1::Int,(3::Int,(2::Int,0::Int)))
09:54:24 <glguy> (1,(3,(20,0)))
09:54:31 <glguy> You can build stuff like that
09:54:47 <ph88> set, is that lens ?
09:54:51 <glguy> yeah
09:55:14 <ph88> maybe best to do it without lens ?
09:55:24 <glguy> It's not really worth doing in general
09:55:34 <glguy> but if you're going to do it, let's not make it harder than we need to :)
09:55:53 <ph88> what do you mean it's not worth doing ?
09:57:44 <glguy> Working with trees of tuples instead of a more appropriate type for the operations at hand?
09:58:32 * ski . o O ( `data List a t = Here t | Add (List a (a,t))' )
09:58:54 <monochrom> I think dependent type fans would be thrilled. A tree type that tells you the value's tree shape, like a vector type that tells you the value's length (which is vector shape).
09:58:57 <ph88> ooh that
10:00:30 * ski . o O ( `data Tree a k = Leaf (k a) | Branch (Tree a (\t0 -> Tree a (\t1 -> k (t0,t1))))' )
10:03:55 <ph88> glguy, why did you made a typeclass for it ?
10:04:13 <ph88> oh i think i know why actually ^^
10:14:59 <ph88> does someone know a function like Control.Lens.Fold.findOf that returns the rightmost element that matches the predicate ?
10:19:33 <zennist> i finally figured out why ghc is using ghci on compile phase when i'm not using template haskell - i have some ANN annotations....
10:19:46 <Gurkenglas> ph88, lastOf combined with filtered?
10:20:35 <ph88> i'll try it Gurkenglas 
10:23:05 <ertes> is there a way with 'zoom' to access the current index of an indexed traversal?
10:26:35 <ph88> Gurkenglas, can i use filtered as is or do i need to combine it with a function to do the traversal ?
10:26:46 <Gurkenglas> :t filtered
10:26:49 <lambdabot> (Choice p, Applicative f) => (a -> Bool) -> Optic' p f a a
10:27:10 <ph88> hmz
10:28:14 <Gurkenglas> That specializes to (a -> Bool) -> Fold' a a.
10:29:37 <ph88> i don't know where to call that function
10:29:52 <ph88> i have now   lastOf ints (1::Int,(3::Int,(2::Int,0::Int)))   Just 0
10:30:02 <ph88> this seems to work
10:30:36 <ph88> but lastOf does not take an argument that matches the type of filtered
10:30:42 <glguy> lastOf (ints . filtered odd)
10:31:19 <ph88> lastOf (ints . filtered (\x -> x == 3)) (1::Int,(3::Int,(2::Int,0::Int)))
10:31:20 <ph88> oh ye nice
10:34:08 <glguy> filtered (==3)  is   only 3
10:34:37 <glguy> err, no, I think I'm wrong there
10:35:56 <glguy> It's similar: *Ph88> lengthOf (ints . only 3) (1::Int,(3::Int,(2::Int,0::Int)))
10:35:56 <glguy> 1
10:36:11 <ph88> how can i not just get the last element but get the entire structure back with the last element that matches the predicate ?
10:36:17 <saurabhnanda> Is it possible to have a "functional dependency" of sorts between type-variables in a function signature, eg runQuery :: (haskells -> columns) => Connection -> Query columns -> IO [haskells]
10:36:49 <ph88> i mean i want to modify the last element that matches the predicate, but get the entire structure back with that one element modified
10:41:36 <ertes> saurabhnanda: how would that be resolved?
10:42:05 <ertes> saurabhnanda: you could use a type family, of course
10:42:29 <saurabhnanda> ertes: I'm not actually sure. I'm trying to say if `haskells` is inferred by the compiler (based on usage), then there should be only one type of `columns` that the compiler can infer.
10:42:45 <bollu> saurabhnanda: can you not use an actual functional dependency?
10:42:51 <ertes> saurabhnanda: the compiler still needs to actually infer it
10:42:53 <saurabhnanda> ertes: and btw, haskells & columns can very well be record types.
10:43:12 <ertes> saurabhnanda: so you need an explicit function, e.g. a type family
10:43:21 <saurabhnanda> bollu: functional dependencies are only on type-classes, right?
10:43:45 <lyxia> saurabhnanda: you can define a type synonym
10:43:47 <ertes> type family Columns haskells
10:43:55 <lyxia> that ^
10:43:57 <glguy> ph88: You can use 'holesOf' to get a view of an element in the structure and a way to put it back
10:44:21 <Athas> Grrr, I disagree with hlint that '&&' is better than 'and'.
10:44:23 <ertes> runQuery :: Connection -> Query (Columns haskells) -> IO [haskells]
10:44:28 <saurabhnanda> is the other way around easier? columns -> haskells?
10:44:29 <ertes> saurabhnanda: like that
10:44:31 <Athas> Whatever.  The computer gets its way!
10:44:36 <bollu> ertes: can you force a type family to be injective?
10:45:17 <ertes> bollu: yes, since…  uh…  was it 7.10 or 8.0?
10:45:27 <ertes> in any case you can use -XTypeFamilyDependencies
10:45:38 <bollu> ertes: I see, cool
10:45:43 <ph88> glguy, documentation mentions   peek at what the structure would be like with an edited result
10:45:46 <saurabhnanda> ertes: interesting. Can you write a type-family such that you "map"  a -> b, c -> d, and then (a, c) -> (b, d) happens automagically?
10:46:09 <ph88> peek has no documentation only type signature   peek :: s -> w a -> a
10:46:11 <saurabhnanda> what is an injective type family?
10:46:25 <ertes> saurabhnanda: not sure what you mean…  a type synonym family is pretty much a type function, but with some restrictions
10:46:39 <cocreature> saurabhnanda: injective means that there are no two inputs which map to the same outputs
10:46:43 <ph88> how can i use holesOf to first search an element in a structure, then view it, modify it, and then put it back ?
10:46:48 <glguy> ph88: if you don't understand the types you can just try out the two argument ordering s
10:47:16 <glguy> ph88, you can 'extract' to see the current value
10:47:20 <ertes> saurabhnanda: injectivity lets the compiler decide the argument from the result…  think of fundeps in both directions
10:47:28 <saurabhnanda> ertes: Columns PGInt4 = Int64; Columns PGText = Text; and then this happens automagically ==> Columns (PGInt4, PGText) = (Int64, Text)
10:48:01 <ph88> how can i search when i can only see the current value ?
10:48:18 <ph88> this stuff is totally new to me :|
10:48:32 <ertes> saurabhnanda: type instance Columns (a, b) = (Columns a, Columns b)
10:48:32 <johnw> > [1,2,3,4] & traverse.filtered (==3) .~ 5
10:48:33 <glguy> just play with it a bit in ghci
10:48:37 <lambdabot>  [1,2,5,4]
10:48:45 <johnw> > [1,2,3,4] & _last .~ 5
10:48:46 <saurabhnanda> ertes: but do I need to define that manually
10:48:49 <lambdabot>  [1,2,3,5]
10:48:53 <ertes> saurabhnanda: yes, of course
10:48:55 <saurabhnanda> ertes: because that would not scale for the problem I have in mind
10:49:03 <glguy> or figure out what it is you don't understand specifically and I'll try to answer
10:49:09 <ertes> saurabhnanda: tuples don't scale in general
10:49:30 <saurabhnanda> ertes: scale != performance scaling. 
10:49:40 <ertes> saurabhnanda: but 2-tuples can be nested arbitrarily
10:50:41 <bollu> saurabhnanda: you can define the instances the way ertes showed for n-tuples as well
10:50:56 <bollu> saurabhnanda: though I'm not sure I interpreted your question right
10:51:09 <ertes> Columns ((a, b), (c, d)) = (Columns (a, b), Columns (c, d)) = ((Columns a, Columns b), (Columns c, Columns d))
10:51:33 <saurabhnanda> I"m trying to come up with a solution where I define the mappings between PG types and Haskell types in one place, and then I can combine them in any record or tuple type without having to write boilerplate for that specific record or tuple type.
10:52:05 <saurabhnanda> or the standard answer to that is any other API related to tuples, right?
10:52:10 <ertes> saurabhnanda: i don't know why you need a type *mapping* there, but regardless, generics might solve your problem
10:52:16 <saurabhnanda> write shitloads of them up to 64 tuples?
10:52:33 <bollu> saurabhnanda: why are you getting those many tuples in the first place?
10:52:35 <saurabhnanda> Column (a, b) = (Column a, Column b)
10:52:48 <saurabhnanda> Column (a, b, c) = (Column a, Column b, Column c)
10:52:52 <saurabhnanda> and so on... till 64
10:52:59 <saurabhnanda> bollu: SQL queries
10:53:07 <ertes> saurabhnanda: why do you get those tuples?
10:53:12 <bollu> saurabhnanda: you can use some template haskell
10:53:14 <cocreature> sounds like you want to generate instances using generics
10:53:29 <bollu> cocreature: GHC.Generic?
10:53:32 <saurabhnanda> Full context = I'm trying to simplify Opaleye :)
10:53:39 <ertes> yes, if anything, generics is probably the best answer, but a better answer is not to create those tuples in the first place
10:53:59 <bollu> saurabhnanda: ohh, right, you had asked about profunctor in Opaleye the other day right?
10:54:04 <saurabhnanda> tomjaguarpaw: is around here?
10:54:07 <cocreature> bollu: or generics-sop or one of the other generics libraries
10:54:14 <saurabhnanda> bollu: yep!
10:54:24 <cocreature> but you can’t magically make up instances without defining them somehow
10:55:07 <saurabhnanda> so, I guess "scaling" the type-families to tuples is simple. Define them for 64 tuples in the core library and be done with it. Profunctors have also done that. Every single library that deals with tuples does that.
10:55:14 <saurabhnanda> but with record-types it's a different problem.
10:55:15 <bollu> saurabhnanda: tangential question: do you always get the results of SQL queries as tuples? can you not get them as a record type or something
10:55:30 <saurabhnanda> which is where we are stuck with a bit of TH.
10:55:59 <saurabhnanda> bollu: getting them with record types makes the problem even harder, no?
10:56:02 <bollu> saurabhnanda: you can write a function that does (a -> b -> c -> d) to (PGtype a) -> (PGType b) -> (PGType c) -> (PGType d) by using the "printf" trick I think
10:56:18 <davean> bollu: That generally requires template haskell or a wrapper
10:56:22 <bollu> davean: ah
10:56:34 <bollu> davean: I assumed the "printf" style trick + type families could work. 
10:56:49 <davean> bollu: the problem is you don't "know" what the query is returning persay
10:56:50 <ph88> glguy, maybe there is a tutorial somewhere to get started? i never worked with lens before
10:56:57 <ph88> i saw a video about get and set though
10:57:11 <bollu> davean: I'm not sure what you mean by that
10:57:21 <davean> bollu: you've got a miss-match problem where you don't have a typed return value from the DB
10:57:48 <bollu> davean: but this is happening inside haskell right? where queries are haskell functions? 
10:57:59 <davean> bollu: no, the problem is its external
10:58:07 <davean> so typing the return of a query is just hard
10:58:13 <bollu> davean: ah, OK, I'm missing this bit of context
10:58:42 <davean> you're interacting with a remote API with very little guarrentee about what it'll hand you back
10:58:55 <davean> It tends to be consistent but underdefined
10:59:14 <davean> so, the TH approch is "lets look at the DB, assume it doesn't change, and generate code that matches what we see"
10:59:24 <davean> which of course breaks, rather hard, if something DOES change
10:59:32 <bollu> hm
10:59:52 <saurabhnanda> davean: so the problem is not at that step
11:00:08 <saurabhnanda> davean: we've already assumed what the columns are; and what their types are
11:00:17 <davean> saurabhnanda: ah, I missed that
11:00:30 <thoughtpolice> davean: I have no idea what you mean. Opaleye already assumes the DB matches the schema; that is a completely independent problem. You are already relying on instance selection; the question is whether you can guide instance selection further so that it not only picks the right column results, but further gives you the right Haskell results.
11:00:40 <saurabhnanda> davean: now, after we've done composing all the complicated SQL queries dealing with (Column x) types; we want to convert them to Haskell types easily
11:00:49 <davean> thoughtpolice: I think I missed something
11:00:56 <thoughtpolice> I think. Either way I definitely think there's a way to do this in Opaleye, but I'm not sure what it would look like.
11:01:01 <saurabhnanda> which is where the idea of functional dependency between (columns -> haskells)
11:01:17 <thoughtpolice> davean: Yeah. (Relatedly, I actually _do_ want to combine Opaleye with a TH-level schema check, though...)
11:01:32 <saurabhnanda> thoughtpolice: we're working on that with opaleye-helpers
11:02:01 <thoughtpolice> saurabhnanda: Link?
11:02:03 <bollu> saurabhnanda: so, you also want to convert the "Column x" types to record types?
11:02:06 <saurabhnanda> thoughtpolice: taking a page out of the HRR handbook. Use TH to look at the schema and generate all the Opaleye boilerplate.
11:02:31 <benzrf> so this is closed, but i'm having this exact issue https://ghc.haskell.org/trac/ghc/ticket/12216
11:02:46 <saurabhnanda> thoughtpolice: https://github.com/vacationlabs/opaleye-helpers -- heavy WIP. Developing alongside a production app to make sure it fits real-world requirements.
11:03:09 <benzrf> am i just on an eight-month-old version of ghc...?
11:03:24 <saurabhnanda> but we still hate the fact that everything in Opaleye needs a type signature because of the way it's structured.
11:03:46 <thoughtpolice> benzrf: It was reported in 8.0.1, but there is no indication in the ticket it was merged to the stable branch. It is probably not in 8.0.2, if that's what you're using.
11:03:48 <davean> benzrf: what version are you on?
11:03:51 <saurabhnanda> From https://www.stackage.org/haddock/lts-7.14/opaleye-0.5.2.2/Opaleye-RunQuery.html#v:runQuery -- runQuery's use of the Default typeclass means that the compiler will have trouble inferring types. It is strongly recommended that you provide full type signatures when using runQuery.
11:03:53 <benzrf> oh
11:04:00 <benzrf> oh damn i'm still on 8.0.1... that's very strange
11:04:07 <benzrf> did .2 only come out recently?
11:04:27 <davean> benzrf: Jan
11:04:27 <thoughtpolice> Yes, a few weeks ago.
11:04:30 <benzrf> aha
11:04:31 <thoughtpolice> Or, yes.
11:04:32 <benzrf> oops!
11:04:37 <davean> Jan 11th to be specific
11:04:38 <maerwald> you're so retro :p 
11:04:40 * benzrf updates his nix expressions
11:04:59 <ph88> if holesOf returns a list of the structure, what is the dual function that creates a structure back from the list ?
11:05:18 <bollu> saurabhnanda: where are the record types here?
11:05:29 <thoughtpolice> benzrf: No, it actually looks like it was fixed in the 8.0.x branch. So if you update, you should be OK.
11:05:38 <benzrf> cool!
11:05:43 <thoughtpolice> The ticket just got lost in the ether, I suppose.
11:06:42 <saurabhnanda> thoughtpolice: https://github.com/vacationlabs/opaleye-helpers/pull/1/files#diff-04c6e90faac2675aa89e2176d2eec7d8 -- check the README here
11:07:16 <saurabhnanda> bollu: so the `haskells` type can be a record if you want. But that forces you to define these weird typeclass instances
11:07:28 <tsahyt> after many more hours of trying I'm starting to think that this thing doesn't have a valid ArrowLoop instance
11:07:33 <thoughtpolice> saurabhnanda: Thanks! I'm was hoping someone was already going down this path. (I don't really use or write TH very often)
11:07:39 <tsahyt> I now have two that typecheck
11:07:47 <bollu> saurabhnanda: I see
11:07:50 <tsahyt> but don't seem to ever terminate even for a simple example
11:07:58 <tsahyt> ertes: are you around?
11:09:41 <ertes> tsahyt: pong
11:11:21 <tsahyt> ertes: I've been tearing my hair out over implementing an ArrowLoop instance, and since you've written at least two libraries with arrow interfaces I thought you might know more. I've got a Wave a type which is the same as Word64 -> a. On top of that I have a newtype for Wave a -> Wave b. Since waves are a functor, its image forms a category, the arrows of which I want to model. But I can't figure out how to
11:11:23 <tsahyt> implement loop without it just recursing endlessly
11:12:00 <tsahyt> the reason why I want an arrow interface here is because it's the closest to the dataflow diagrams that are ubiquitous in DSP literature, so I'd just like to try how far that takes me
11:13:02 <tsahyt> I was thinking that since those are just functions, it should be pretty straight-forward to just adopt the ArrowLoop instance from (->) but that turned out not to work either
11:14:45 <tsahyt> so I guess my question is really whether you can give me some pointers as to how this would work, or whether it can work at all
11:17:07 <ertes> tsahyt: paste?
11:19:11 <ertes> tsahyt: BTW, your reasoning as to why you want an arrow interface is misguided
11:19:36 <tsahyt> hmm, lpaste is being slow. hold on
11:19:53 <ertes> the arrow interface is objectively inferiour to the monadic interface…  it's not something you'd want, but rather something you can't do without in some cases
11:20:12 <ertes> *inferior
11:20:34 <tsahyt> http://sprunge.us/edZg?hs
11:20:54 <tsahyt> nevermind the second type parameter to Wave in the WaveA definition. I was sloppy removing the irrelevant part
11:21:12 <tsahyt> (Waves are also parameterized over a sample rate parameter)
11:22:06 <ertes> tsahyt: how about (type WaveA r a b = Wave r a -> Wave r b)?
11:22:34 <ertes> and:  type Wave = (->)
11:22:36 <tsahyt> I've thought about that, but then I always get the wave as a whole when using <- in arrow notation I think?
11:22:52 <tsahyt> and about the type synonym for wave, I'd really rather not do that. I've got many things depending on the first parameter being words
11:22:55 <ertes> you don't use arrow notation…  you use 'let'
11:23:06 <ertes> well
11:23:14 <ertes> type Wave = (->) Word64
11:23:27 <tsahyt> yes, but then I lose the type parameter, which is quite crucial at other points
11:23:43 <ertes> well, then…  type Wave = (->)
11:23:44 <ertes> =)
11:23:51 <tsahyt> no I mean the r
11:23:54 <ertes> yes
11:24:03 <ertes> oh, r is really just phantom?
11:24:18 <tsahyt> yes, newtype Wave (r :: Nat) a = ...
11:24:30 <tsahyt> I must make sure not to mix waves of different sample rates
11:25:16 <ertes> i see…  at least i'd replace WaveA by simply using (->)
11:26:31 <tsahyt> I've thought about that. It'd at least save me from some worries. but this whole thing also sparked my curiosity as to how a proper ArrowLoop instance for the existing type would look like.
11:26:44 <ertes> you're just forcing yourself to use a much noisier syntax and slower code
11:27:13 <tsahyt> why slower? newtypes should be free, shouldn't they?
11:27:39 <ertes> ArrowLoop for functions is pretty straightforward, and you're basically just writing a version of that with some wrapping/unwrapping
11:27:48 <ertes> newtypes are free, but the arrow interface is not
11:28:14 <tsahyt> right I hadn't thought of that
11:28:26 <ertes> it requires explicit side channels most of the time, which means lots and lots of tuple building and pattern-matching
11:28:42 <ertes> that's why you have stuff like 'first' and (***)
11:28:45 <tsahyt> but all I've been trying to do was to adapt the ArrowLoop (->) instance to WaveA, which never terminated even for simple examples
11:29:30 <ertes> try to write this, if you're curious:  loopFunc :: ((a, r) -> (b, r)) -> a -> b
11:29:46 <tsahyt> I have, and that works
11:30:22 * ski . o O ( trace )
11:32:30 <tsahyt> ertes: when specializing loop to Wave a -> Wave b, I get (Wave a, r) -> (Wave b, r) -> Wave a -> Wave b. but for WaveA the type is slightly different. After the newtype unwrapping it's (Wave (b,d) -> Wave (c,d)) -> Wave b -> Wave c
11:33:18 <benzrf> @djinn ((a, r) -> (b, r)) -> a -> b
11:33:19 <lambdabot> -- f cannot be realized.
11:33:22 <benzrf> i didn't think it could!
11:33:26 <benzrf> hmmmmm
11:33:52 <tsahyt> :t \f b -> let (c,d) = f (b,d) in c
11:33:53 <johnw> btw, that's awfully close to what ArrowLoop does
11:33:55 <lambdabot> ((t1, t2) -> (t, t2)) -> t1 -> t
11:34:13 <johnw> and tsahyt's defintion is awfully close to the instance for (->) :)
11:34:23 <tsahyt> johnw: iirc it's exactly the same
11:34:26 <tsahyt> up to naming anyhow
11:34:46 <benzrf> oh, cute
11:35:04 <johnw> tsahyt: oh nice, exactly exactly
11:35:10 <tsahyt> johnw: well I've been looking at it a lot today
11:35:16 <johnw> I still want to know what the ArrowLoop instance for free arrows should be
11:35:31 <tsahyt> well I still want to know what the instance should be for my type :/
11:35:41 <tsahyt> but I guess I'll just give up and use the type synonym instead
11:36:06 <tsahyt> it should have just been some unwrapping, but oh well
11:36:14 <johnw> tsahyt: pastie
11:36:26 <tsahyt> http://sprunge.us/edZg?hs
11:36:46 <tsahyt> this is what I ended up with. it ends up producing infinite loops for examples that really should work
11:37:02 <tsahyt> interestingly enough, it does not even bring up CPU usage while it does so
11:37:42 <johnw> what you pasted has some hard errors in it
11:37:45 <tsahyt> johnw: in case you're wondering, there's an additional phantom parameter to Wave, which I forgot to remove in some places
11:37:47 <johnw> newtype WaveA a b = WaveA { process :: Wave r a -> Wave r b } ?
11:37:53 <tsahyt> yes, wait I'll add them back in
11:38:04 <johnw> that's ok, my mayfly attention span just died
11:38:55 <tsahyt> http://sprunge.us/bAhI?hs
11:42:18 <ertes> > let (x, y) = undefined in ()
11:42:23 <lambdabot>  ()
11:42:41 <ertes> tsahyt: as far as i see your 'loop' implementation is correct
11:43:16 <ertes> tsahyt: the only potential for error i see there is excess strictness, but i can't see any
11:44:30 <ertes> however, semantically speaking it may not exactly do what you think it does:  given (loop f), at each point in time the input wave of 'f' is a wave that has as its second component the feedback value *at every point in time*
11:44:49 <ertes> the feedback value of that point in time that is
11:45:39 <ertes> that's what your fmap does:  it takes a wave and attaches a *constant* second component
11:46:16 <ertes> but it's only constant in that particular point in time…  in the next frame it will be a different constant that is attached to the whole wave
11:47:30 <tsahyt> that's what I've been reading from the types, and it's been a major source of confusion. But I suppose it really isn't what I want.
11:47:42 <tsahyt> when using the type synonym instead, this changes as far as I can see
11:48:47 <ertes> IMO you shouldn't use the type synonym either
11:48:49 <ertes> just use functions
11:54:02 <tsahyt> but that would be exactly the same semantically
11:54:23 <tsahyt> I'd just be giving a name to the most central thing in the library
11:55:21 <ertes> tsahyt: the main difference is that with WaveA's 'loop' you're using value recursion on *samples*, not *waves*
11:56:27 <ertes> which means: time becomes relevant, and you need to deal with waves *at each point in time*
11:56:39 <tsahyt> well now I'm confused again. this of course always gets used with a delay, which offsets a wave by 1 sample, providing a default value to fill the now empty start. when I want to determine the final value after some recursive transformation, I thought I'd want to recurse back over the samples
11:57:37 <ertes> you need to delay the WaveA, not the Wave…  delaying the Wave is pointless, because the feedback value is constant over the whole wave
11:58:08 <tsahyt> that explains a lot
11:58:59 <tsahyt> how would I do that though? at this point I'm just asking to give me peace of mind.
11:59:25 <tsahyt> I've checked and there are no additional instances that I've defined on WaveA that don't exist on (->), so I guess I'll switch to that then
12:00:09 <ertes> ideally you wouldn't do it and just use value recursion normally, which means that you can delay the Wave:  let w = f (delay w')
12:00:16 <ertes> whoops
12:00:22 <ertes> let w = f (delay w)
12:07:02 <nbro> Hi
12:08:24 <nbro> I’ve a question. I have a main module where I had not specified the IO action main was not defined and ghc was complaining about this
12:08:38 <nbro> but file is not really going to be used as a standalone app
12:08:59 <davean> nbro: then is it a library?
12:09:02 <davean> nbro: declare it as such
12:09:04 <nbro> so, in these cases, is there a conventional way to define IO main?
12:09:23 <mauke> what else are you going to use a main module for?
12:09:25 <davean> Either having an IO main makes sense or it doesn't
12:09:28 <nbro> well, the file name is lower case and it must remain like that (specifications)
12:09:33 <mauke> what
12:09:56 <davean> if its an executable it has an main, if its not it doesn't
12:10:12 <davean> the concept of an executable without a main is contradictory, without a main it can't be run
12:10:20 <nbro> I’m not saying that
12:10:32 <nbro> I’m not saying that I don’t want to define main
12:10:47 <nbro> I’m just asking you how would you define it in my case
12:10:56 <mauke> I don't understand what "your case" is
12:12:47 <davean> nbro: "Not going to be used as a standalone app" <-- definitionally a library?`
12:12:54 <nbro> mauke: I didn’t have the time to study more Haskell since the last time, but here’s the thing… I understood that with main :: IO () we’re defining the type of main
12:13:28 <mauke> yes
12:13:29 <cocreature> so you need to name your file main.hs but it can’t be the main module?
12:13:33 <nbro> davean: not REALLY going to be used, sorry for not being precise enough
12:13:43 <bollu> does anyone know of a large-scale app that uses the free monad for DSL design pattern
12:14:02 <nbro> with that I mean that it can either simply be a file which is loaded into ghci
12:14:04 <Tuplanolla> You write `module Main where main = ...` into `Main.hs` and put the name of the executable you want in the Cabal file, nbro.
12:14:09 <nbro> or compiled
12:14:27 <davean> nbro: so ... don't definate it as the Main module, or don't tell GHC to compile it as a library
12:14:29 <mauke> ghc -c yourfile.hs IIRC
12:14:38 <kuribas> How can I stop the ghci debugger from entering an expression?
12:14:56 <davean> nbro: "loaded into GHCi but not run as an executable" is a type of library
12:16:41 <nbro> davean: yeah, but the point is that this an assignment and they have not specified if they are going to compile the file or simply load it in ghci, and this is the reason why I’m asking you “nonsensical” things
12:16:56 <nbro> so I was just wondering the best way according to you
12:17:02 <nbro> given my situation
12:17:11 <kuribas> If that's not possible the ghci debugger is pretty useless...
12:17:12 <davean> nbro: have it do whatever you want it to do?
12:17:28 <Tuplanolla> Contact the authors, nbro. We couldn't possibly guess.
12:18:01 <monochrom> "will load in ghci" does not resolve the ambiguity between library and executable.
12:18:15 <davean> nbro: either you have a thing you want main to do, or you don't. If you don't, don't define a main, its not an executable. If you do, define a main and declare it to do what you want.
12:18:27 <monochrom> For all you know they are going to enter ":main" which requires an executable-track file.
12:18:44 <monochrom> err, s/are/may be/
12:19:15 <monochrom> And then at some point you realize that it is a false dichotomy.
12:19:37 <monochrom> You go ask them "do you want main or not?" and code up accordingly.
12:22:16 <nbro> so, essentially, I want it to be compiled and at the same time I don’t need it to be compiled
12:22:41 <nbro> I think
12:23:14 <nbro> Tuplanolla: if I use your method “module Main where main =“ it says “parse error (possibly incorrect indentation or mismatched brackets)” while compiling
12:23:29 <nbro> I’ve indendented all lines of code and comments
12:23:32 <davean> nbro: Theres no problem compiling a file thats not an executable
12:23:34 <nbro> not sure why it still claims
12:23:41 <davean> nbro: are you missing a "do"?
12:23:46 <mauke> nbro: did you put something after the '='?
12:24:00 <mauke> because just 'main =' is a syntax error
12:24:08 <monochrom> Where can we read the assignment verbatim, and where can we read your code verbatim?
12:24:53 <monochrom> Statistics show that 80% of students overlook 20% of the assignment text. This is known as the 80-20 rule.
12:24:56 <lpaste_> Tuplanolla pasted “Main Module” at http://lpaste.net/353244
12:25:02 <nbro> I know these problems are stupid and are due because I’ve still not learned
12:25:07 <nbro> but I didn’t have time
12:25:13 <ph88> anyone know some good examples how to use holesOf, lastOf and filtered from lens ?
12:25:15 <nbro> so that’s why a lot of stupid questions come here
12:25:17 <mauke> nbro: what does the assignment actually say?
12:25:41 <nbro> mauke: there are some exercises, it’s not important
12:25:44 <nbro> the assignment is finished
12:25:49 <mauke> nbro: it is important
12:25:58 <mauke> since you're apparently struggling with it
12:26:07 <mauke> and not telling us what the constraints actually are
12:26:17 <nbro> mauke: not really
12:26:18 <monochrom> If it is finished, we can all go home now.
12:26:29 <nbro> Haskell is not difficult as people like to rate it
12:26:31 <nbro> IMO
12:26:44 <nbro> I simply just spent only 3 hours reading
12:27:33 <nbro> but I would have concrete questions, if you want to answer...
12:27:43 <bollu> nbro: haskell isn't hard, just different IMO
12:27:52 <nbro> yeah, indeed
12:27:52 <bollu> nbro: yes, go on, what is your question?
12:27:59 <mauke> I had a concrete question, but apparently you don't want to answer it
12:28:03 <bollu> nbro: it's just that it is _so different_ that it is mind bending :P
12:28:18 <bollu> nbro: I feel quite dumb 90% of the time with haskell and I love it ^_^
12:28:48 <monochrom> There was probably no assignment in the first place.
12:29:13 <nbro> usually you define a module as follows “module NameOfModule where …”
12:29:31 <mauke> haskell eschews assignments. it was probably a binding
12:29:46 <bollu> mauke: lol
12:30:00 <nbro> if it’s main, I also need to set main, so in the case suggested by “Tuplenolla” he/she did “module Main where main = putStrLn "Works for me"“
12:31:14 <nbro> my question is
12:31:45 <nbro> why exactly do we need to set main? 
12:32:10 <bollu> nbro: what are you trying to do?
12:32:16 <monochrom> It is required for an executable.
12:32:31 <hpc> main is the thing that is run
12:32:44 <hpc> when you compile and run a haskell program
12:32:46 <c_wraith> nbro: it's the same thing as main in C
12:32:50 <hpc> (or just about any sort of program)
12:32:51 <monochrom> Similarly why do some python files have __main__? (Or whatever it's called.)
12:33:04 <c_wraith> nbro: you have to tell the compiler where the program starts *somehow*
12:33:12 <hpc> python executes in the top-level scope
12:33:14 <bollu> monochrom: that is quite different though
12:33:22 <monochrom> Ah OK.
12:33:23 <nbro> or another question would be: what kind o expressions (or statements?) are allowed to be in the main definition? Are there some restrictions?
12:33:25 <c_wraith> nbro: the convention is that it's the IO action named main in the module named main
12:33:28 <hpc> there's a magic __main__ variable in every scope that says if that's the module that's being executed
12:33:30 <c_wraith> err, the module is named Main
12:33:35 <bollu> monochrom: __main__ is used to control what happens when you import a module
12:33:52 <c_wraith> nbro: any value with a type unifying with IO a can be main
12:34:09 <c_wraith> nbro: however, it's usually good to make it IO (), as that can prevent some bugs
12:34:30 <hpc> this means the behavior of a module is different if you import it vs running it, imports can produce side effects even without bringing anything into scope, and imports are order-dependent
12:35:18 <hpc> using main avoids a lot of those misfeatures
12:35:18 <bollu> hpc: I had once worked on a codebase that was un-testable since it depended on everything being imported in some order. writing unit tests against modules was a no-op
12:35:22 <hpc> (and IO prevents even more)
12:35:32 <monochrom> Haha this is great. Haskell main is for executables. Python __main__ is for libraries.
12:35:35 <bollu> hpc: it was hilariously sad
12:36:14 <hpc> monochrom: yeah, python is one of my least favorite languages
12:36:15 <AndreasK> If seen python __main__ used as entry point for applications as well often enough
12:36:27 <hpc> i could probably go on for hours, but it wouldn't belong here and i have other things to do ;)
12:37:43 <Tuplanolla> When you don't, the world needs a Python critique that doesn't focus on indentation, hpc.
12:38:08 <c_wraith> I think anyone who's used python can provide that critique.
12:38:48 <monochrom> I only critique the official Python tutorial of using fibonacci in an example. :)
12:38:57 <monochrom> of? for?
12:39:13 <c_wraith> english is hard, let's go haskelling. :)
12:39:20 <monochrom> @quote monochrom fibonacci.*natur
12:39:20 <lambdabot> monochrom says: the fibonacci sequence is everywhere in nature, for example haskell tutorials and python tutorials
12:39:26 <bollu> lol
12:39:31 <bollu> that is hilarious
12:39:36 <monochrom> :)
12:39:51 <hpc> i miss some of the old quotes
12:40:07 <bollu> hpc: such as?
12:40:09 <hpc> majestic stereo, especially
12:40:12 <lolisa> Hi, so in haskell we can do memo by constructing infinite trie.
12:40:14 <c_wraith> is that one gone?
12:40:20 <hpc> @quote majestic.stereo
12:40:21 <lambdabot> monochrom says: Welcome to #haskell, where @remember's are in majestic stereo!
12:40:30 <bollu> I don't geddit
12:40:31 <hpc> oh, it's still there in some form at least
12:40:38 <lolisa> However can we modifty it so it work on infinite data type?
12:41:01 <monochrom> lolisa: Infinite list and infinite binary search tree also work.
12:41:04 <hpc> bollu: it used to happen really often, but when people would ask questions here, they would get answers from multiple people almost immediately
12:41:09 <hpc> and those answers would be identical
12:41:19 <nbro> imports need to be specified before the definition of main, right?
12:41:27 <lolisa> Like how?
12:41:28 <hpc> so someone said "welcome to #haskell, where questions are answered in majestic stereo"
12:41:29 <bollu> hpc: heh, I see
12:41:35 <c_wraith> nbro: syntactically, yes.  imports belong before any definitions
12:41:45 <bollu> hpc: I like the haskell community the best
12:41:46 <nbro> ok, thanks!
12:41:48 <bollu> like, best part of hasell
12:41:48 <c_wraith> nbro: module header, imports, declarations
12:42:00 <hpc> eventually the prevailing answering style turned into two people alternating through the same answer
12:42:09 <hpc> and most of the time coming out looking like one coherent explanation
12:42:23 <c_wraith> sometimes we have 4 people. :)
12:42:26 <hpc> so the quote changed to "welcome to #haskell, where questions are answered in contrapunctual fugue"
12:42:43 <bollu> hpc: ooh, that had happened to me. With you, Cale, and merijn IIRC :P
12:42:44 <monochrom> I invented that one.
12:42:46 <Tuplanolla> Distributed lambdabot could handle that.
12:42:52 <bollu> hpc: you were trying to tell me what "higher kinded" was
12:42:57 <bollu> IIRC
12:43:02 <nbro> how do you manage to have time to be here all the day?! lol
12:43:04 <hpc> heh
12:43:07 <bollu> hpc: any other quotes?
12:43:58 <hpc> dunno
12:46:44 <bollu> also, what the hell are the "photontorpedo" quotes IIRC?
12:46:48 <bollu> they were ridiculous
12:46:51 <bollu> @quote photontorpedo
12:46:51 <lambdabot> No quotes match. My mind is going. I can feel it.
12:46:53 <bollu> hm
12:47:01 <c_wraith> protontorpedo
12:47:05 <thoughtpolice> @protontorpedo
12:47:06 <monochrom> They were a troll.
12:47:06 <lambdabot> scheme, lisp, php, python, perl, tcl, al banned
12:47:43 <monochrom> But they became so funny, we created a dedicated lambdabot storage.
12:47:56 <bollu> I see
12:48:00 <bollu> lol
12:48:07 <bollu> @protontorpedo
12:48:07 <lambdabot> and haskell is not a lisp. correct? holy shit then m learning haskell
12:48:16 <bollu> (can I spam?)
12:48:30 <nbro> :t maybe
12:48:33 <lambdabot> b -> (a -> b) -> Maybe a -> b
12:48:34 <monochrom> No, but you can pm lambdabot for more
12:48:35 <nbro> :D
12:48:41 <bollu> ooh, right, thanks
12:53:04 <nbro> hey, guys, I guess this has probably been discussed many times, but what do you haskellers  not like about Haskell? 
12:54:48 <monochrom> I don't like plain text files.
12:54:51 <davean> nbro: I don't like that I can't serialize computations
12:55:17 <bollu> "Shiruka says: the operations with irc://irc.freenode.net:6667/# in GHC gain their speed from the fact that they are executed on the newer and hence superior and faster .NET platform" my god, that is gold
12:55:22 <MarcelineVQ> having to write out all the superclass instances of a given class instance instead of being able to selectively choose what ones I want to over-ride if at all
12:55:49 <stevenxl> i folks. Quick question - how do I turn changeset errors into user-friendly messages?
12:55:51 <stevenxl> For example: `%{title: ["should be at least 3 characters"]}` how does that get transformed into "Title should be at least 3 characters"
12:55:55 <MarcelineVQ> that could be shorter: *boilerplate
12:56:11 <stevenxl> I can certainly write the function myself, but just wondering if there's already a function in ecto i should be using
12:57:00 <bollu> "sum is just the free monoid functor applied to the mediating arrow of the terminality of ()" <- someone explain this to me?
12:57:17 <stevenxl> woops
12:57:20 <stevenxl> sorry wrong chan!
12:57:33 <c_wraith> bollu: sounds like gibberish to me
12:57:39 <bollu> c_wraith: yeah
12:58:04 <xubunto> almost as if someone wanted to sound smart
12:59:56 <bollu> "TacticalGrace says: irc://irc.freenode.net:6667/#haskell in action: discussion about first-year teaching turns into an argument about CT and Kan extensions" I would love for some context on this
13:00:10 <c_wraith> :t getSum . foldMap (const 1)
13:00:13 <lambdabot> (Foldable t, Num c) => t b -> c
13:00:48 <bollu> c_wraith: is that the context?
13:01:08 <c_wraith> No, that's a demonstration of how to actually write sum using a free monoidal approach
13:01:21 <bollu> c_wraith: how is this "free monoid"?
13:01:21 <c_wraith> as foldMap is more or less toFreeMonoid
13:01:57 <ski> @ghc
13:01:57 <lambdabot> Bad eta expand
13:02:00 <c_wraith> bollu: http://comonad.com/reader/2015/free-monoids-in-haskell/
13:02:15 <bollu> c_wraith: ooh, thanks
13:03:40 <dbohdan> I found what looks like another discrepancy in how Haskell's socket Handles behave under Windows and *nix.
13:04:04 <davean> dbohdan: I'm not suprised, which one is this?
13:04:12 <dbohdan> If you kill a lightweight thread waiting on hGetLine on a Handle on *nix, it stops the thread instantly. On Windows, it waits for hGetLine to receive its input.
13:05:06 <dbohdan> http://lpaste.net/1112499561634463744
13:09:34 <bollu> 'dibblego: says: category theory and spring are quite different types of "hard to understand". it is possible to come to understand category theory for example.'
13:10:00 <benzrf> lol
13:10:14 <bollu> this one too: "Coq is a tool for turning ordinary programs into POPL papers"
13:10:20 <benzrf> true
13:12:03 <dbohdan> From what I've seen so far my impression is that you shouldn't use socketToHandle in applications intended to run on both *nix and Windows. Is this reasonable?
13:20:10 <SepakoRayl> yo
13:20:22 <hsk3> yo
13:20:42 <SepakoRayl> guys is anyone familiar with Alex?
13:21:36 <SepakoRayl> I am having a small problem with strictness
13:24:22 <dmwit> ?where justask
13:24:22 <lambdabot> Just ask your question. If somebody knows, they'll answer. If not, they won't, and you'll wait around; it will be no worse than having nobody who wants to claim expertise.
13:24:34 <bollu> "this is like pokemon but with type systems" oh my god, that is gold
13:25:49 <ertes> sounding smart is not that difficult: "inheritance is just an end of products in the category of meta-meetings"
13:27:35 <SepakoRayl> ok here is the thing Alex provides an `alexMonadScan :: Alex result`
13:27:49 <SepakoRayl> how do I format code snippets?
13:28:54 <dmwit> ?where paste
13:28:54 <lambdabot> Haskell pastebin: http://lpaste.net/
13:29:56 <bollu> :t (??)
13:30:02 <lambdabot> Functor f => f (a -> b) -> a -> f b
13:30:10 <bollu> oh, OK
14:28:41 <suica> I'm trying to write a simple regex parser for expressions like "ab(cd|e)*f", but it's recursing infinitely and I can't quite figure out why -- anything obviously incorrect here? http://lpaste.net/353247
14:31:20 <f-a> what is Parser, suica 
14:32:00 <lyxia> suica: you have a loop between p_nonseq, p_alt, p_expr
14:32:55 <suica> sorry, `newtype Parser a = Parser { runParser :: String -> Maybe (a, String) }`
14:33:10 <suica> lyxia: thanks, let me see
14:38:41 <mofasa_> Is there any way to load a module which imports another local module into GHCi without creating a cabal file? E.g. A.hs imports B.hs, then stack repl A.hs yields "Failed to load interface for 'B'"
14:40:47 <lyxia> mofasa_: where are your modules located
14:40:56 <mofasa_> same folder
14:42:12 <lyxia> oh I see, stack is behaving differently from ghci...
14:42:36 <vct> does anyone else use intero with spacemacs?
14:45:50 <suica> lyxia: thanks! one issue I'm having conceptually is how I can make it parse "ab|cd" as `Alt (Seq (Sym 'a') (Sym 'b')) (Seq (Sym 'c') (Sym 'd'))` -- it'll always do the greedy thing where it parses to `Just (Seq "ab", "|cd")` (removing Sym's for clarity), with "|cd" as the unparsed remainder.
14:46:28 <Cale> suica: Add something to the parser which insists that you're at the end
14:46:52 <Cale> oh, hadn't seen your parser type
14:47:10 <Cale> If you use Maybe like that, you can't have backtracking, so it's trickier
14:47:45 <suica> hmm I see
14:47:48 <lyxia> You might be able to reorder your rules to make it work...
14:48:23 <lyxia> flip the two alternatives in expr
14:48:50 <lyxia> oh no, single is in nonseq
14:55:32 <suica> yeah, it's difficult to think about for me -- hard to figure out what limitations are imposed by my parser type
14:58:19 <lyxia> You'll need a way to test whether you're at the end of the string, because you can always append more stuff after a regexp to get a longer regexp
15:26:37 <athan> How's the situation for uploading haddock documentation to hackage? I can do it with Neil Mitchell's `neil` utility, but I think the hyperlinks are off - should I just wait for hackage to do it?
15:26:54 <Welkin> hackage will fail :O
15:26:59 <Welkin> upload it yourself
15:27:06 <athan> u_u right on
15:27:08 <athan> thanks Welkin 
15:30:38 <lyxia> it's working okay now
15:37:33 <robertkennedy> I've started writing a paper, but I have no idea if the research I'm working on is original. How can I feel confident that I'm adding something?
15:38:30 <robertkennedy> Well the research is original; hopefully you know what word I'm looking for. 
15:38:41 <Tuplanolla> It's an eternal problem, robertkennedy.
15:38:50 <monochrom> exhaustive search of the literature.
15:42:41 <robertkennedy> If you don't mind me trying to spark recognition: is there a function `get` and a constructor `:&&:` so `get (True :&&: "test" :&&: 'y') == 'y'` and `get (True :&&: "test" :&&: 'y') == "test"`
15:43:33 <Tuplanolla> I don't get it.
15:43:38 <Koterpillar> robertkennedy: what's the difference between those two expressions?
15:43:39 <monochrom> I think you have typos.
15:45:33 <robertkennedy> I don't. 
15:45:54 <monochrom> Then there is none.
15:46:51 <monochrom> You have a constant c, and ask for get c = 'y' and get c = "test".
15:46:57 <robertkennedy> The first uses `get :: a :&&: b :&&: c -> b` and the second uses `get :: a :&&: b :&&: c -> c`
15:47:15 <monochrom> Ah
15:48:21 <lyxia> what's the trick
15:48:32 <robertkennedy> I've written such a function, `get :: c `Has` a => c -> a`; the paper I've begun to write exploits it a lot. 
15:48:32 <monochrom> Multiple parameter type class.
15:51:17 <robertkennedy> And closed type families, and "advanced overloading", a GHC wiki article I can't find atm
15:52:09 <lyxia> Okay I see.
15:55:32 <robertkennedy> monochrom: what's your feeling in general when seeing multiple parameter type classes? 
16:06:34 <athan> hmm, when quoting type constructors, do the types need to be defined in a different module?
16:06:37 <athan> (using TH)
16:07:00 <athan> I remember that if you intend to use the code generated, you need to import the TH-generated code from a different module
16:07:38 <athan> wait no, my fingers just fooled me x_x dang typos
16:14:49 <fresheyeball> athan: wassap!
16:17:59 <SPKB24> hello
16:18:48 <SPKB24> anyone here?
16:19:15 <SPKB24> exit
16:19:17 <Axman6> a few
16:19:17 <SPKB24> quit
16:19:20 <SPKB24> oh hi
16:19:35 <SPKB24> what are some of the best ways to learn haskell?
16:19:40 <Axman6> there's over a thousand people here at the moment, so aty least a few are probably awake
16:20:03 * metalbot queues religious war theme music
16:20:19 <snow_lemurian> Heyo!
16:21:00 <snow_lemurian> I really recommend Yet Another Haskell Tutorial
16:21:02 <snow_lemurian> Oops
16:21:05 <snow_lemurian> Too late
16:34:51 <mbw> Hello everyone. I am currently working my way through Gabriel Gonzalez' lens tutorial: https://hackage.haskell.org/package/lens-tutorial-1.0.2/docs/Control-Lens-Tutorial.html. He claims that "[...]any Lens' is automatically also a valid Traversal' (since Functor is a superclass of Applicative)." Traversal' has an Applicative constraint, whereas Lens' has a Functor constraint. So this sentence does not make 
16:34:57 <mbw> sense to me, shouldn't it be the other way round? After all, every Applicative Functor is a Functor, but not the other way round. Am I reading this wrong?
16:35:35 <Koterpillar> mbw: lens can take a functor
16:35:48 <Koterpillar> mbw: so if you give them an Applicative, because it's a functor, they'll still work
16:37:12 <mbw> Koterpillar: Ah, so the point is that the constraint applies to the function argument?
16:37:28 <Koterpillar> exactly
16:37:31 <mbw> I think that makes sense.
16:37:40 <Koterpillar> I think it's called "contravariant"
16:37:46 <mbw> This is some nifty stuff.
16:38:21 <monochrom> I don't understand "the constraint applies to the function argument".
16:38:59 <mbw> It's a type synonym for a unary function, the way I see it.
16:39:11 <mbw> type Traversal' a b = forall f . Applicative f => (b -> f b) -> (a -> f a)
16:39:40 <monochrom> That applies the contrait to the type variable f.
16:39:51 * variable waves to monochrom 
16:40:12 <monochrom> Also f appears in the "return type" f a, which is not part of the function argument.
16:40:41 <monochrom> But what you need to think in terms of is Liskov substitutability.
16:41:48 <mbw> I think that may be what confused me in the first place. I was regarding Traversal itself as a Functor.
16:42:00 <mbw> Well it is, since it's a function...
16:43:01 <mbw> What confused me was what I mistakenly read as "x is a Functor => it has to be Applicative as well", which is not true.
16:43:38 <monochrom> "X is also a valid Y" happens when and only when "if I ask you for Y, you can give me X instead and it won't break my assumptions".
16:44:27 <Koterpillar> where's that picture with producer/consumer covariance/contravariance explained with "If you want to (have|dispose of) some X, you give it to Y"?
16:44:47 <monochrom> Suppose I say, I need a sorting algorithm, I will only use it for lists of length 10, and elements are even numbers.
16:45:13 <monochrom> Are you right in supplying me with Prelude.sort, the most general sorting algorithm possible?
16:46:36 <mbw> I sure hope so.
16:47:40 <monochrom> But note that "list of any length => list of length 10" is false. And "the element type is an Ord instance => the elements are even numbers" is also false.
16:49:10 <monochrom> Let's modify my example to be less confusing and more relevant.
16:50:05 <monochrom> I need a sorting algorithm. I will only use it on an element type that is an instance of both Ord and Num. (Ord a, Num a) => [a] -> [a].
16:50:42 <monochrom> Are you right to supply me with Prelude.sort :: (Ord a) => [a] -> [a]?  Note that "Ord a implies (Num a, Ord a)" is false.
16:52:47 <mbw> Assuming the internally used predicate is (<=), I would think so. But Complex might be a special case...
16:53:15 <monochrom> Don't worry about Complex. Not an instance of Ord to begin with.
16:53:20 <mbw> exactly.
16:54:31 <monochrom> OK?  "Ord a implies (Num a, Ord a)" is false, so why can you give me sort of just the Ord constraint, where I "need" both Ord and Num?
16:55:08 <mbw> You didn't say you needed it. You only said that this is what applied to your type.
16:55:18 <monochrom> Yes.
16:56:15 <monochrom> A user of Travesal didn't say they needed Applicative. They only said they would use it with Applicative.
16:56:59 <monochrom> "Functor implies Applicative" is the wrong direction to care about. "Applicative implies Functor" is the correct direction.
16:57:06 <mbw> mbw was inlightened
16:57:11 <mbw> This should be a koan
16:57:25 <monochrom> Just like you would look at "(Ord a, Num a) implies Ord a" in my example.
16:59:00 <mbw> How would you think of this in terms of covariant/contravariant? I only know these terms in the context of functors (and coordinate transformations, but that's another thing...). I know that these terms are used in OOP these days as well, but don't know how practically relevant it is.
16:59:02 <Tuplanolla> You can still think of it as implication if you word it "given `Functor`, I can produce `Applicative`", mbw.
16:59:24 <athan> Is there a GHC flag that shows call stacks when exceptions aren't caught?
16:59:42 <monochrom> contravariant on assumptions (such as type class constraints), covariant on return types.
16:59:43 <athan> I've been wrestling with `callStack` and `currentCallStack` to no avail;
17:00:22 <mbw> Could you elaborate on another (or the same) example, please?
17:03:09 <mbw> Regarding contra-/covariance.
17:03:19 <monochrom> I create a Java class "public abstract class M { public Object f(String x); }". You have written your class "public class W { public String f(Object x) ... }". Can you make W a subclass of M?
17:03:57 <lyxia> athan: the runtime option -xc https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/runtime_control.html#rts-flag--xc
17:04:02 <monochrom> This is the OOP kind of covariance and contravariance. Covariant in return type, contravariant in parameter type.
17:05:08 <mbw> Ok, I have never really programmed in Java. So just so that we're on the same page, all types are subtypes of Object in Java, right?
17:05:16 <monochrom> Yes.
17:05:16 <mbw> (C++ background)
17:05:18 <mbw> ok
17:06:45 <mbw> I would think, W can be instantiated as M. W::f() requires an Object, which a String is. It returns a String, which is an Object, which a caller of M::f() requires. Right?
17:06:53 <monochrom> Yes.
17:07:06 <mbw> I don't know what the "::" equivalent in Java is, though :)
17:07:27 <Koterpillar> dot
17:07:36 <Koterpillar> everything is dots
17:07:45 <mbw> Just like in Haskell.
17:07:47 <mbw>  :/
17:08:27 <monochrom> Therefore you conclude that, as you go from a superclass method to a subclass method, return type can be subclassed (covariant), parameter type can be superclassed (contravariant).
17:09:07 <Koterpillar> https://i.stack.imgur.com/KjDLw.png
17:09:32 <mbw> Is that terminology rigorous, in the category theory sense? Or is it something like "Functor" used to describe function objects?
17:10:48 <monochrom> rigorous.
17:11:27 <dmwit> I object. Terminology cannot be rigorous.
17:12:28 <mbw> Well, rigorous is probably not the right term to use. There's no "dips" on words. But still, the concept of a Functor in Haskell is not quite the same as in OOP languages, for instance.
17:12:44 <mbw> So, maybe ambiguity is the issue, don't know.
17:13:10 <dmwit> I agree with everything you said there. But I still don't know what your question was. =P
17:13:13 <barrucadu> I don't think there's a general OOP usage of "functor", AFAIK the C++ usage is C++ specific
17:13:29 <barrucadu> Maybe C# also uses the term, I don't know
17:14:06 <mbw> Me only having done OOP in C++ should probably confirm your suspicion then.
17:14:52 <barrucadu> Unfortunately, "functor" means a different things in every language which uses it.
17:15:12 <monochrom> Fortunately there has only been 3.
17:15:17 <mbw> Oh, there are more uses of the word?
17:15:21 <monochrom> err, s/has/have/
17:15:39 <dmwit> I suspect monochrom's third is the way ML uses it.
17:15:40 <monochrom> Damn English. Why bother with singular vs plural, therefore countable vs uncountable
17:15:47 <monochrom> Yeah.
17:16:10 <monochrom> And why bother classifying hair as uncountable.
17:16:48 <mbw> If it's becoming less every day, it has to be countable.
17:17:01 <barrucadu> "hair" is a silly word which refers to two different, but very related, things
17:17:08 <barrucadu> Like many English words I suppose
17:17:29 <dmwit> Let's ditch it and use something sensible. Lojban, perhaps
17:17:49 <barrucadu> An individual hair, in which case it is a count noun; and a large collection of hairs, in which case is it not.
17:17:52 <barrucadu> Silly
17:18:25 <mbw> Am I going to become smarter if I keep staring at "Lojban"?
17:18:44 <mbw> What is that?
17:19:04 <barrucadu> A constructed language which aims to be very logical
17:19:05 <monochrom> If you keep staring at something, you will die. (Tautologically.)
17:20:15 <dmwit> Are dieing and becoming smarter mutually exclusive?
17:20:26 <dmwit> dying
17:20:32 <mbw> You'll find out eventually.
17:20:34 <dmwit> I don't like English, too.
17:20:58 <monochrom> No, not mutually exclusive.
17:21:23 <monochrom> Just want to say something I am more sure of :)
17:24:41 <mbw> Man, Haskell really is a deep rabbit hole. I was looking at some HTTP library tutorials, in order to learn some basics. Then I noted that HTTP (the library) seems to work with [Char]. The nice tutorial of wreq lead me to learn lenses first. Which lead me to...
17:25:06 <mbw> I'm probably doing it wrong.
17:25:30 <dmwit> If you haven't typed `unsafe` into your compiler yet, you're probably not doing it wrong.
17:25:59 <dmwit> It's even possible that you're not doing it wrong even though you have typed `unsafe`.
17:26:24 <ertes> mbw: here is an experiment: try to read an interesting article on wikipedia without following a single link
17:26:36 <mbw> haha
17:26:54 <mbw> You got it. 5 new tabs/min.
17:27:13 <mbw> And I suspect firefox works with [Char] as well...
17:28:03 <ertes> haskell has the same effect
17:28:14 <athan> Y_Y I've used $(deriveJSON defaultOptions ...) with an extremely trivial data type, and it fails the `decode (encode x) == Just x` test. Wut do?
17:28:54 <dmwit> The solution depends on the problem.
17:28:58 * dmwit channels monochrom
17:29:16 <monochrom> I like the Y combinator.
17:29:48 <dmwit> mbw: "nearly 25000 (!!) allocations are made for every keystroke in the Omnibox" https://groups.google.com/a/chromium.org/forum/#!msg/chromium-dev/EUqoIz2iFU4/kPZ5ZK0K3gEJ
17:30:10 <athan> shoot, can I not invoke $(..) splices in GHCi?
17:30:19 <monochrom> haha neat
17:31:34 <mbw> oh man
17:33:12 <mbw> The reasons they give seems to imply that some people have no idea what they're doing
17:33:16 <mbw> *seem
17:33:35 <athan> http://lpaste.net/353250 where did I go wrong? :U
17:34:10 <dmwit> mbw: I have a much more sympathetic interpretation: chromium is a big project, with a lot of people working on it, and none of them can hold the entire project in their head at once.
17:35:07 <ertes> athan: probably nowhere…  looks like deriveJSON doesn't handle singleton types properly…  look at the JSON produced
17:35:27 <ertes> might be an empty object
17:36:23 <barrucadu> For types of the form `data Foo = Foo`, I have had the generic aeson stuff produce an empty array, rather than an object.
17:36:37 <barrucadu> Which was a little surprising, as I expected an empty object
17:36:58 <mbw> That may be. On the other hand, there are rules of thumb when to use which data structure, when to preallocate memory etc. The problems they describe seem to stem in part from people being used to program in languages with reference semantics, not value semantics. But to be fair, C++ is a beast to tame.
17:38:55 <mbw> On the other hand I am personally frustrated with the memory footprint of popular software these days. I actually tried to use the Atom editor, only to have to hard reset my machine twice.
17:39:13 <mbw> But it looked so nice...
17:39:26 <mbw> Getting off-topic here I guess.
17:39:49 <MarcelineVQ> atom editor itself? or ghc-mod with atom editor?
17:40:43 <mbw> It was probably in combination with haskell-specific plugins.
17:40:45 <MarcelineVQ> just curious because ghc-mod + stack  = some amazing oom if you're not careful
17:41:59 <mbw> I did want to try for that reason. While my current vim setup works fine, it requires dicipline. Autocompletion with stack does not always work the way I want it to.
17:42:22 <mbw> With TemplateHaskell stuff, you can just forget about it (Yesod...).
17:42:45 <maybefbi> is there such a thing as easily modifiable tree in haskell? i want to do things like swap vertices
17:42:55 <dmwit> athan: The code generated here seems to be producing an object in ToJSON, but expecting an array in FromJSON.
17:42:58 <dmwit> athan: That's probably a bug.
17:43:40 <maybefbi> anyway to swap vertices in Data.Tree is also acceptable
17:43:58 <athan> ertes: really?? that seems off - the {tag: Foo} object should be able to get turned into a `Foo` i reckon
17:44:27 <athan> dmwit: aie yie yie, thank you - I'll file a bug
17:44:54 <chris_c> Hi , i want to load turtle package into GHCI , my system is a brand new install of Debian 8.7.1 , i did the following: # apt-get update && apt-get install haskell-platform (this will install ghc 7.6.3 and cabal 1.20 ) $ cabal update $ cabal install turtle (cabal indicates that the install was successful, it should install turtle to global location.) $ ghci prelude > :l Turtle However, after step 5, ghci could not find turtle , my go
17:45:42 <maybefbi> chris_c, do not use haskell-platform. use haskellstack
17:46:07 <maybefbi> haskell-platform on debian/ubuntu is always outdated beyond hope
17:46:09 <chris_c> hi maybefbi , thanks , let me try
17:46:42 <dmwit> athan: `deriveJSON defaultOptions { sumEncoding = TwoElemArray } ''Foo` works well here.
17:47:18 <dmwit> athan: Also, you may like `-ddump-splices` for further experimentation/debugging as you make `Foo` more exciting.
17:47:51 <chris_c> currently I use Nix to work with ghc and other library , they works fine , could I just use haskell Stack or Nix to upload to Hackage with Cabal?
17:48:22 <chris_c> I found that the hackage tutorial always jump too fast
17:48:47 <dmwit> chris_c: What does `ghc-pkg list turtle` say?
17:49:31 <johnw> chris_c: does this help: cabal2nix --shell . > shell.nix && nix-shell --command 'cabal sdist' && nix-shell --command 'cabal upload dist/$FOO.tar.gz'
17:49:50 <johnw> you'll need cabal2nix and cabal-install installed in your user environment
17:52:44 <chris_c> > dmwit : /nix/store/8vdfwq62v8wd4i25yhw1sv7497g24b1r-ghc-8.0.2-with-packages/lib/ghc-8.0.2/package.conf.d     turtle-1.3.1
17:52:46 <lambdabot>  <hint>:1:9: error: parse error on input ‘/’
17:53:39 <dmwit> chris_c: lol
17:53:51 <dmwit> chris_c: `:m + Turtle`, not `:l Turtle`
17:54:32 <dmwit> chris_c: `:l` is for loading from source. `:m` (or just normal old `import`) is for loading modules from installed packages.
17:54:56 <chris_c> dmwit : thanks , i miss it :)
17:55:30 <chris_c> > johnw : let me save your comment , i need to digest it and review it later 
17:55:33 <lambdabot>  <hint>:1:34: error: parse error on input ‘,’
17:55:41 <chris_c> you guys are helpful
17:56:21 <dmwit> I am *actually* cracking up over here.
17:56:34 <dmwit> We all overlooked this detail and jumped to very complicated alternatives. =P
17:57:18 <dmwit> (Including me! Checking on ghc-pkg was totally unnecessary.)
18:08:39 <athan> sweet, I made a kinda cool websocket RPC dealio
18:08:45 <athan> it's pretty simple if anyone wants to see it
18:09:09 <athan> https://github.com/athanclark/websockets-rpc
18:10:20 <athan> it lets you design a subscription / publication DSL pretty quickly, so you can invoke an RPC on a server, and stream messages back and forth before the routine is finished
18:10:36 <athan> (really useful for progress, tickers, log files, stuff like that)
18:23:30 <jle`> hello all
18:23:46 <jle`> is there any way to invoke haddock and have it build other-modules/internal modules, as well?
18:23:54 <xcmw> What is the best way to convert a lazy byte string from Data.Binary to Text?
18:24:17 <dmwit> What encoding is it in?
18:24:45 <jle`> xcmw: check out the functions in this module http://hackage.haskell.org/package/text-1.2.2.1/docs/Data-Text-Lazy-Encoding.html
18:24:48 <jle`> one of them might be what you want
18:24:53 <xcmw> dmwit: I don't think it has an encoding
18:25:02 <dmwit> I don't think it's Text, then.
18:25:16 <jle`> is it just a bunch of bits?
18:25:33 <dmwit> Also I'm a bit confused about how Data.Binary is playing into things here.
18:25:56 <jle`> it's probably a bytestring that they're getting from functions in Data.Binary
18:26:13 <xcmw> jle`: Yes
18:26:17 <jle`> but yeah, Text is only meant to represent text.  it's not really meant to represent random jumbles of bits
18:26:34 <jle`> if the bytestring doesn't represent text, then you probably don't want Text
18:26:45 <jle`> maybe you want to display it in a nice way, like a base-64 encoding?
18:27:02 <jle`> or a hexadecimal represnetation?
18:27:10 <dmwit> Oh, like, this ByteString is the output of an encoding operation?
18:27:24 <xcmw> jle`: I don't need it to be readable I just need to convert between them
18:27:26 <geekosaur> xcmw, what are you intending to do with this data?
18:27:40 <dmwit> Why do you need to convert between them?
18:27:48 <jle`> that's like asking if you can convert "hello" to an Int
18:28:04 <jle`> text isn't meant to represent anything that isn't text
18:28:50 <xcmw> geekosaur: Store it in localStorage. Which means the data type must be an instance of toJSString and fromJSString
18:29:02 <swampy123> any lens maintainers around? wondering how to go about lifting the upper bound on containers?
18:29:13 <dmwit> swampy123: Perhaps #lens would serve you well.
18:29:19 <jle`> #haskell-lens
18:29:21 <dmwit> err
18:29:28 <swampy123> ah thanks! #lens doesn't exist
18:29:32 <dmwit> There's a lens-specific channel, anyway. Might be #haskell-lens.
18:29:45 <jle`> ##lens is a channel about optometry and optics
18:30:17 <Rotaerk> going there and asking questions about haskell lenses sounds fun
18:30:24 <dmwit> Whoof. I'm experiencing some mighty lag between my laptop and the computer I'm running irssi on. Apologies for slow/late replies.
18:30:51 <geekosaur> JSString is not a class, it is a newtype over String. You must encode your data somehow to something that can be represented as a String
18:31:08 <geekosaur> if it is binary data, consider something like hex or base64
18:31:41 <geekosaur> if it is not textual, neither Text nor String is the right thing to use and you can expect your data to be corrupted if you try to force it
18:32:06 <dmwit> JSString is not a class, but ToJSString/FromJSString are (in GHCJS).
18:32:30 <geekosaur> ah. I asked hayoo but I don; think it handles ghcjs yet
18:32:50 <dmwit> I'll admit I'm kind of surprised by one of: GHCJS supports ByteString, or ToJSString/FromJSString does not supoprt ByteString.
18:33:06 <geekosaur> the same constraint will apply, though; you can't just slam it into a string, or you will get corruption or even rejected as invalid JSON
18:33:30 <geekosaur> you need to encode it into something that is String/Text-safe
18:33:38 <xcmw> geekosaur: decodeUtf8 and encodeUtf8 work from Data-Text-Lazy-Encoding
18:33:45 <dmwit> nooooo
18:33:52 <geekosaur> no, they won;t work for all inpiut data
18:34:02 <geekosaur> btu if you like occasionally losing completely, go ahead
18:34:13 <geekosaur> because you *will* get corruption at some point
18:34:30 <geekosaur> something will apply unicode normalization and *boom*
18:34:43 <dmwit> xcmw: For what it's worth, I find it odd that you are taking such a circuitous route. Why are you making a Binary instance, then trying to convert to Text, then converting to JSString? Why not just directly make instances of ToJSString and FromJSString for your types?
18:35:37 <dmwit> geekosaur: Or even before that, he'll pass in some bytes that aren't valid UTF8.
18:36:01 <geekosaur> depends on exactly how they are abusing those functions
18:36:23 <geekosaur> you can feed binary data to something that encodes iso8859 to utf8
18:36:31 <geekosaur> you might even be able to extract it again if you are lucky
18:37:23 <xcmw> Should I use read and show instead?
18:37:56 <geekosaur> hex or base64
18:38:10 <geekosaur> you seem insistent on trusting the untrustworthy
18:39:25 <xcmw> I will use base64 but is there a specific example of when encodeUtf8 and decodeUft8 fail?
18:41:34 <monochrom> There must be an xkcd for this.
19:11:44 <angerman> So I don't have an alternative instance for Either a b ... oh.
19:12:36 <spatial> createarray :: IO ( IOArray Int Int)           createarray =  do {                    arr <- newArray (512,512) 0;                    return arr               }
19:13:00 <spatial> In imperative lang. I would store that array globally and read and write.
19:13:28 <spatial> I have multiple Haskell functions that have to read and write to that array. How is it done ?
19:13:37 <monochrom> Pass as parameter.
19:14:00 <spatial> Don't want to pass.
19:14:07 <c_wraith> close over it
19:14:56 <spatial> closure ? Treat me gently. I am learning.
19:15:31 <spatial> Struggled with State Monad for that. Didn't work.
19:15:48 <c_wraith> in general, "pass it as a parameter" is correct.  Closing over it just means define all the functions that use it when the array is already in scope.  It's awkward, but it's the only thing you can do other than pass it.
19:16:52 <c_wraith> State is just parameter-passing, by the way.
19:16:57 <ski> (a shorter way to define `createarray' is `createarray = newArray (512,512) 0')
19:19:11 <spatial> ski: Ok
19:20:37 <ski> a process-extent mutable variable is seldom the right thing to do. more commonly one would like different threads, if executing same code, to access different versions ("threadsafe" and all that)
19:21:35 <c_wraith> A process-extent mutable variable is seldom the right thing to do *in any language*, by the way.  It's just as bad of an idea in C as it is in Haskell.  Haskell just makes it hard to do the wrong thing.
19:21:36 <ski> passing in an explicit parameters the things that a function needs to access is usually not that burdensome .. closing can also help
19:22:30 <ski> in case it becomes more burdensome (usually because you have many things you need to pass in), it can often help to bundle in a record, and optionally to hide the passing with `Reader' or `State'
19:24:20 <spatial> ski: Can you point me to an example of 'Reader' or 'State' ? for such arrays
19:26:49 <ski> in the case of references to mutable state, `Reader' (or probably `ReaderT', since you're presumably doing I/O here) would be enough
19:27:37 <ski> the simplest would be to use `ReaderT (IOArray Int Int) IO', if you know that's the only mutable thing you need to access out of the implicit environment
19:28:12 <spatial> Let me try that
19:28:27 <ski> if you might want to add more things in the future (or now already), then probably instead `ReaderT MyMutableStuff IO', `MyMutableStuff' being a record type which has a field of type `IOArray Int Int', and possibly more fields as well
19:28:49 <ski> you can use `ioarr <- ask' in the former case to grab it
19:29:16 <ski> `ioarr <- asks getIOArr' in the latter case, if `getIOArr' is a selector function that extracts that field out of the record
19:30:07 <ski> you'll also need to use `runReaderT' in one (or perhaps a few) place(s), to pass in the initial `IOArray Int Int', after you've created it
19:30:50 <ski> use `liftIO' to be able to call ordinary `IO' actions inside the `ReaderT (...) IO' context
19:34:59 <spatial> Has someone created such an example ?
19:35:21 <c_wraith> ski just spelled out everything
19:35:30 <spatial> Let me search
20:04:15 <zipper> Hey is there like isInfixOf that is case insensitive?
20:04:21 <zipper> A substring search
20:05:46 <dmwit> map toLower x `isInfixOf` map toLower y -- ?
20:05:48 <kadoban> zipper: The usual pattern for that type of thing is: use toLower on both the needle and the haystack
20:06:12 <zipper> hmm
20:07:37 <Koterpillar> weird unicode might mess with you here
20:07:38 <Axman6> there is a case insensitive string type used in some of the HTTP libs which might be useful
20:08:42 <Axman6> yeah you want to be sure this isn't for weird text, like in german the capital for 'ss' is a single character IIRC 
20:09:07 <zipper> Koterpillar: Exactly my issue
20:09:24 <zipper> I want to check whether something is unicode from the content type 
20:09:28 <zipper> Which is bytestring
20:09:30 <zipper> lol
20:09:45 <snow_lemurian> Why not use (<$> toLower) `on` isInfixOf ?
20:09:52 <zipper> There is char8.isInfixOf
20:10:02 <Koterpillar> content-type from an HTTP header?
20:10:07 <Koterpillar> HTTP headers are ASCII-only
20:10:08 <zipper> snow_lemurian: That assumes a string
20:10:15 <zipper> Koterpillar: Oh :)
20:10:23 <zipper> Koterpillar: That clears it all up
20:11:46 <zipper> `decodeASCII` Deprecated: Use `decodeUtf8` instead
20:12:20 <ski> > isLower 'ß'
20:12:23 <lambdabot>  True
20:12:57 <Koterpillar> ski: for completeness, that thingy is available in caps too
20:13:25 <dmwit> zipper: `decodeLatin1` is not deprecated
20:13:35 <dmwit> It covers all of ASCII and a bit more besides.
20:13:55 <dmwit> And unlike UTF8 won't ever fail.
20:14:27 <zipper> Why is charachter encoding so weird :(
20:15:02 <ski> Koterpillar : yeah, i was just looking for it :)
20:15:06 <ski> > isUpper 'ẞ'
20:15:09 <lambdabot>  True
20:15:20 <ski> > toUpper 'ß'  -- however, :/
20:15:20 <kadoban> Because characters are so weird ... because languages are so weird.
20:15:22 <lambdabot>  '\223'
20:15:30 <dmwit> ...because humans are so weird.
20:15:47 <dmwit> It's weird turtles all the way down.
20:16:37 <Axman6> ski: yeah that's the one, thought that was the uppercase char but guess it's the other way
20:17:05 <ski> iirc, it's a ligature of `sz'
20:17:23 <Koterpillar> > toUpper 'ß' == 'ß'
20:17:26 <lambdabot>  True
20:17:31 <ski> aye
20:18:32 <ski> one might have thought that `forall c. isLower c = True => isUpper (toUpper c) = True'
20:19:24 <Axman6> but one would be wrong!
20:19:42 <Welkin> wolud two be wrong?
20:19:55 <Axman6> if n is wrong, n+1 is also wrong
20:20:09 <Axman6> one is the base case
20:20:09 <Welkin> what about n-1?
20:20:19 <Axman6> uh, n-1
20:20:27 <ski> depends ..
20:20:41 <Koterpillar> how do you get lambdabot to print unicode?
20:20:56 <ski> > text "ẞ"
20:20:59 <lambdabot>  ẞ
20:21:09 <ski> > text "ß"
20:21:12 <lambdabot>  ß
20:21:25 <Axman6> :t text
20:21:27 <Sornaensis> > text "°"
20:21:28 <lambdabot> String -> Doc
20:21:29 <lambdabot>  °
20:22:08 <Koterpillar> > text $ filter (\c -> isUpper c && toUpper c /= c) $ [minBound..]
20:22:11 <lambdabot>  ǅǈǋǲ
20:22:21 <Koterpillar> > text $ filter (\c -> isLower c && toLower c /= c) $ [minBound..]
20:22:28 <lambdabot>  Terminated
20:24:17 <ski> that's interesting. upper-lower ligatures
20:24:50 <Koterpillar> they are called title case
20:26:37 <ski> ah, i see
20:26:48 * ski . o O ( <https://en.wikipedia.org/wiki/Small_caps> )
20:26:58 <Koterpillar> not even that
20:36:10 <jle`> can i put latex math into haddock docs?
20:36:39 <jle`> i see this PR https://github.com/haskell/haddock/pull/465 that claims to let you do it, but, i'm not sure how to do actually do it
20:37:46 <jle`> what are the delimiters?
20:37:56 <jle`> it doesn't seem to be in the haddock docs
20:39:55 <zipper> dmwit: I'm afraid that will break later when I try to decode utf8
20:40:02 <zipper> if something sneaky gets past
20:41:14 <MarcelineVQ> jle`: I've not used haddock but this part seems relevant https://github.com/haskell/haddock/pull/465/files#diff-3d298f660a24334a44b167637240db7d
20:42:32 <jle`> hm it looks like docs were added here https://github.com/haskell/haddock/pull/525/files
20:42:38 <jle`> but the official docs as they are hosted online are outdated
20:42:52 <jle`> this PR was merged last june so like i wonder what happened
20:42:54 <jle`> MarcelineVQ: ah thanks!
20:48:30 <turnage> When a Reader monad is defined and the definition calls "ask", how does ask access the Reader's context?
20:51:10 <Axman6> that depends on the particular instance, but for the trivial Reader (r -> a), ask r = r (where ask has type r -> r)
20:51:10 <Koterpillar> turnage: the bind implementation for this monad passes the context to each action, and ask simply returns that passed parameter
20:51:50 <Axman6> for ReaderT, which is essentially r -> m a, it's just ask = ReaderT (\r -> return r)
20:52:50 <turnage> so ask, inside the definition of a reader, has access to the reader's context field?
20:56:10 <turnage> Oh, ask is defined for the Reader class as an action that yields the context? And ask implicitly received the reader as a parameter because it is called inside the Reader definition?
20:56:36 <Welkin> there is `ask` and `asks`
20:58:00 <turnage> I mean ask as in this sample: http://adit.io/posts/2013-06-10-three-useful-monads.html#the-reader-monad
20:59:15 <ski> Koterpillar : well, it's not the same, but it reminded me of that
21:03:04 <turnage> I think my question is basically, how is it that ask can yield different values when it doesn't appear to take any parameters?
21:04:05 <turnage> oh
21:04:07 <turnage> nvm I see
21:04:20 <Koterpillar> You'll see it if you expand the definitions of it and bind
21:04:46 <turnage> thanks for the help Koterpillar; just pulled up the source
21:06:47 <buttons840> can someone help me figure out this type error http://lpaste.net/353255
21:07:37 <buttons840> i thought the two versions of the code (with and without do notation) were equivalent?
21:08:07 <geekosaur> buttons840, suggest you take the do-based one and ask ghci its type
21:08:30 <geekosaur> just for starters
21:08:35 <Koterpillar> buttons840: $ ate your bind
21:08:59 <buttons840> actually, i messed up the error message, let me fix it
21:09:14 <geekosaur> however, the real problem is likely to be what Koterpillar said: ($) is not magical, it scopes as far as it can and this *includes* the (>>=) ... which changes the whole type
21:09:50 <geekosaur> wheras do notation stops it at the ends of the line (modulo indentation for continuation)
21:11:07 <monochrom> @quote monochrom point.free
21:11:07 <lambdabot> monochrom says: "point free" can be decomposed to: "point" refers to ".", "free" refers to using no "$". :)
21:16:37 <lpaste_> Buttons840 pasted “Same error without $ ” at http://lpaste.net/353257
21:16:51 <buttons840> geekosaur: I removed the $ and just used parens and have the same issue: http://lpaste.net/353257
21:17:11 <geekosaur> your parens are wrong
21:17:32 <geekosaur> the =<< goes *outside* the pure
21:17:42 <Koterpillar> you replaced pure . Card with pure applied to Card...
21:18:05 <geekosaur> the paramerter to pure, that is
21:20:53 <buttons840> i had `f = (code here, no type holes)` and got an error saying GHC found [Side] but expected IO Card (Card is a [Side] newtype) -- so I thought adding `pure . Card (same code as before)` here would turn it into the required type?
21:22:18 <Koterpillar> please go through the types of each expression again
21:23:01 <roboguy`> buttons840: note that that is parenthesized `pure . (Card (same code as before))`
21:27:54 <hololeap> is `sequence [Just 1, Just 2, Nothing]` essentially the same thing as to `Just 1 >>= (\_ -> Just 2) >>= (\_ -> Nothing)` ?
21:28:33 <pacak> > sequence [Just 1, Just 2, Nothing]
21:28:36 <lambdabot>  Nothing
21:28:49 <pacak> > sequence [Just 1, Just 2]
21:28:52 <lambdabot>  Just [1,2]
21:29:19 <pacak> hololeap: Not quite. It tries to collect results.
21:30:16 <hololeap> what is a method that essentially chains together monads like (Thing 1 >>= Thing >>= Thing >>= Thing) etc where you can specify the number in the chain or have it run infinitely
21:30:52 <ski> hololeap : use `sequence_' instead, and it's essentially the same
21:30:59 <pacak> :t forever
21:31:01 <lambdabot> Applicative f => f a -> f b
21:31:01 <pacak> :t sequence_
21:31:05 <lambdabot> (Foldable t, Monad m) => t (m a) -> m ()
21:31:13 <ski> @type replicateM_
21:31:14 <pacak> :t replicateM_
21:31:16 <lambdabot> Applicative m => Int -> m a -> m ()
21:31:16 <lambdabot> Applicative m => Int -> m a -> m ()
21:31:37 <hololeap> what if you want to keep the result at the end like a chain of state monads
21:31:53 <ski> "like a chain of state monads" ?
21:31:59 <ski> collect results in a list or what ?
21:32:11 <ski> or pass one intermediate result from one to the next ?
21:32:16 <ski> @type foldM
21:32:18 <lambdabot> (Foldable t, Monad m) => (b -> a -> m b) -> b -> t a -> m b
21:32:29 <dmwit> :t foldr (>=>) return
21:32:31 <lambdabot> (Foldable t, Monad m) => t (c -> m c) -> c -> m c
21:32:58 <dmwit> :t replicateM
21:33:00 <lambdabot> Applicative m => Int -> m a -> m [a]
21:33:04 <dmwit> Really hard to tell what's wanted, to be honest.
21:33:24 <pacak> hololeap: Can you explain your task in a bit more details? An example maybe?
21:33:32 <hololeap> it's not a task
21:33:44 <pacak> Whatever you are trying to achieve
21:33:52 <hololeap> i'm just trying to get a better grasp of some details. should i start at the beginning?
21:34:16 <pacak> Go ahead
21:34:20 <dmwit> hololeap: http://stackoverflow.com/q/40983249/791604 possibly
21:43:37 <buttons840> do { a <- b; c $ d a }  is that the same as  (c $ d) =<< b  ?
21:44:05 <Koterpillar> no
21:44:34 <Koterpillar> it's the same as (c . d) =<< b
21:44:52 <hololeap> essentially, i've been trying to learn how to code a simple interactive interface with state, thus the state monat transformer with IO. i found that you could essentially write an infinite loop with `execStateT (sequence $ repeat (StateT addLine)) 0`
21:45:17 <hololeap> where addLine is a function: Int -> IO (Int, Int)
21:46:48 <dmwit> Alternately: it is the same as `(\a -> c $ d a) =<< b`.
21:46:52 <buttons840> Koterpillar: ok, now I see what you were saying about $ eating my bind
21:48:09 <hololeap> so it's passing the first value through many actions, but what if i want the end value passed to something else? and how could i drop out of the chain while still carrying that value?
21:48:22 <jle`> hello all
21:48:55 <hololeap> for instance somebody typing "exit" would drop out of the chain, but the state would then be written to a file
21:49:04 <jle`> how do i provide documentation for record accessors made from pattern synonyms?
21:49:11 <dmwit> hololeap: Don't use `repeat`.
21:49:42 <buttons840> style question: I have the one liner I wanted (I like to avoid do notation until i know how to write the code without it): `pure . Card . sortOn (\(Side n _) -> n) =<< shuffleM a`  -- is this horrible? should I use do notation instead?
21:50:10 <jle`> `pure . f =<< x` is just fmap f x
21:50:20 <jle`> or f <$> x
21:50:34 <jle`> so `Card . sortOn f <$> shuffleM a`
21:51:46 <buttons840> jle`: i see, ty
21:51:54 <jle`> the ugly part is the lambda with pattern matching
21:52:00 <jle`> but if Side is a record, you can use the record accessor
21:52:29 <buttons840> it is not a record
21:53:19 <buttons840> i know lens would be nice here, but I don't really know it and these small anoyances haven't pushed me to learn it yet
21:53:57 <jle`> well
21:54:05 <jle`> lens itself doesn't really directly help
21:54:26 <jle`> in this case the lens library would give you TH to automatically generate accessors
21:54:48 <jle`> the actual concept of lenses isn't too useful here
21:55:02 <buttons840> lens would let me avoid writting out the lambda through, right?
21:55:19 <buttons840> (not that a small lambda is a huge burden)
21:55:25 <jle`> you can avoid writing out the lambda by writing a helper function
21:55:31 <jle`> getThing (Side n) = n
21:55:43 <dmwit> Am I the only one that things `\(Side n _) -> n` is perfectly readable?
21:55:53 <jle`> the lens *library* offers template haskell that lets you generate the accessor atuomatically
21:56:04 <jle`> but lenses themselves are orthogonal to the issue
21:56:05 <buttons840> true, if I write this lambda multiple times I will break it out into a named function
21:56:14 <dmwit> This does not need fifteen minutes of engineering.
21:56:26 <jle`> dmwit: it's not too bad, but i don't like that the eye jumps in different directions when reading it
21:56:57 <jle`> buttons840: so, lens itself doesn't really offer anything too useful here, and the lens library offers some TH that is very very marginally useful
21:57:19 <jle`> don't worry about it :)
21:58:09 <buttons840> ok, thanks for pointing out that i could use fmap -- that was a useful simplification
21:59:53 <jle`> buttons840: btw, if the type that Side is has the auto-derived Ord instance, sortOn (\(Side n _) -> n) should be somewhat-similar to just 'sort'
21:59:55 <buttons840> hmm, i was reaching for both Applicative and Monad methods, when I could have just used Functor, interesting
22:00:01 <ski> dmwit : not the only one
22:02:32 <ski> hololeap : you could make an `exit' "drop out of the chain", by using exceptions (by which i mean something like `Either'), or continuations (`Cont')
22:02:58 <hololeap> ski: i'm looking at ExceptT right now
22:03:38 <ski> @unmtl StateT s (ErrorT e m) a
22:03:39 <lambdabot> s -> m (Either e (a, s))
22:04:26 <ski> would allow you to stop with a value of type `e', which would be the only result surviving, so if you want to save your state `s' (or part of it), better make it part of `e'
22:04:30 <ski> @unmtl ErrorT e (StateT s m) a
22:04:30 <lambdabot> s -> m (Either e a, s)
22:04:55 <ski> would otoh make the state `s' survive the exception, which might perhaps be handier ..
22:05:01 <hololeap> it's telling me that it's deprecated and to use ExceptT instead :)
22:05:06 <ski> also, don't use `ErrorT', use `ExceptT' :)
22:05:37 <ski> yeah, but `untml' hasn't been updated to recognize `ExceptT', which was why i was using `ErrorT' in the query to it
22:06:54 <ski> hololeap : anyway, this would presumably be a relatively local use of `ExceptT', only used to achieve this effect .. which is fine, imho
22:07:21 <hololeap> ski: what do you mean?
22:07:50 <hololeap> what is untml?
22:08:18 <threshold> How is the return type signature for sieveUO :: Int -> UArray Int Bool ? I see a "do" and a "return" http://rosettacode.org/wiki/Sieve_of_Eratosthenes#Haskell 
22:08:20 <ski> hololeap : anyway, since you were using `execStateT' rather than `evalStateT' or `runStateT', you could use `sequence_' instead of `sequence' since you don't care about the individual results of the actions in the list .. and then you could abbreviate that by `forever'
22:08:26 <ski> @help unmtl
22:08:27 <lambdabot> unroll mtl monads
22:09:07 <hololeap> the help isn't helping me much :p
22:09:38 <hololeap> no idea what that means
22:10:50 <snow_lemurian> Anyone uses Liquid Haskell here?
22:11:08 <ski> @hoogle runSTUArray
22:11:08 <dogweather> i'd like to start ... looking some very concrete examples
22:11:09 <lambdabot> Data.Array.ST runSTUArray :: (forall s . ST s (STUArray s i e)) -> UArray i e
22:11:09 <lambdabot> Data.Array.ST.Safe runSTUArray :: (forall s . ST s (STUArray s i e)) -> UArray i e
22:11:19 <ski> threshold : the `do' is for `ST s'
22:11:54 <dogweather> Liquid Haskell is for specifying a little more about a functions' parameters?
22:12:05 <c_wraith> and return type.
22:12:21 <ski> hololeap : `unmtl' is a lambdabot command for unwrapping a few monad transformers, to remind oneself of issues like whether the state survives an exception or not, with one or the other ordering as above
22:12:54 <snow_lemurian> dogweather: Kind of, it is to have proofs about the type you are using
22:12:55 <ski> (in the case it does not survive, that means that the state is rolled back to what it was when the exception catching construct was entered)
22:13:16 <hololeap> i would have to see it in action
22:13:18 <dogweather> L.H. didn't install directly via `stack install`, so I'm going to come back to it when i have a chance
22:13:51 <ski> hololeap : you've already seen it, scroll up a little bit
22:14:42 <hololeap> my search is only showing 2 instances of "unmtl" in the history
22:15:04 <hololeap> it might be broken :(
22:15:07 <dogweather> Would L.H. help with a "Year" type, which is an Integer constrained to (say) 1800 > y > 2025?
22:15:21 <ski> hololeap : about eleven minutes ago
22:15:56 <dogweather> I'm currently implementing a Year with newtype and a toYear function https://github.com/dogweather/nv-statutes-haskell/blob/master/src/Year.hs
22:16:57 <c_wraith> dogweather: yes, liquidhaskell is good for that.
22:17:35 <c_wraith> dogweather: liquidhaskell adds a type of subtyping called refinement types - you can add predicates about the values the type can take.
22:18:08 <c_wraith> dogweather: it uses an SMT solver to check the refinements, which means it can handle arithmetic predicates nearly automatically
22:21:09 <dogweather> thanks c_wraith. I'm having trouble finding concrete examples of simple cases like Year. Know any?
22:21:51 <dogweather> I'm reading the official introduction, but it spends a lot of time on the implementation details and not much on a finished piece of code
22:22:07 <c_wraith> dogweather: probably because they assume that it's trivial in comparison to the examples they do provide - if you understand the examples presented, you can handle simpler things.
22:22:28 <c_wraith> Hmm.  There is other documentation
22:23:33 <c_wraith> dogweather: have you checked out http://ucsd-progsys.github.io/lh-workshop/ ?
22:24:14 <dogweather> No! I hadn't seen that one - thanks
22:24:46 <hololeap> holy crap that hurts my brain
22:26:21 <hololeap> ski: would you kindly explain to me why s would survive in your second example?
22:26:23 <hololeap> @unmtl ErrorT e (StateT s m) a
22:26:23 <lambdabot> s -> m (Either e a, s)
22:35:49 <spatial> Read and write to array. Is http://pastebin.com/78skkV3u the way to start ?
22:37:03 <qmm> https://stackoverflow.com/questions/4713906/purely-functional-equivalent-of-weakhashmap
22:38:31 <dogweather> c_wraith: it seem like Template Haskell may have some overlap with L.H.?
22:38:59 <c_wraith> dogweather: the only connection I see offhand is that they both run at compile time.
22:39:22 <dogweather> ok, true. i guess i can imagine them being used to solve similar problems
22:39:47 <c_wraith> Possibly.  I haven't considered it.  
22:40:26 <dogweather> i guess actually, a mini-liquid-haskell could be written in template haskell
22:40:51 <c_wraith> it certainly could be
22:41:55 <c_wraith> The main advantage of liquid haskell's current implementation is that it's optional.  Everything is valid Haskell if you compile it without liquid haskell
22:44:49 <Rotaerk> huh, LH looks cool
22:44:54 <c_wraith> though I'd like to see a haskell-like language built from scratch around liquid types.  I hear F* was built around refinement types, but that's more F#-like, and I don't know if it has a solver built in.
22:46:54 <hololeap> the thing i don't understand is, wouldn't a Left value drop out, and in this case, wouldn't that correspond to `e'?
22:48:03 <ski> hololeap : well, in `s -> m (Either e a, s)', regardless of whether we get `Left e', with `e :: e', or `Right a', with `a :: a', we still also get an `s' back
22:49:30 <ski> hololeap : otoh, in `s -> m (Either e (a, s))', either we get one `a' and one `s', or we get only an `e'. in the latter case, the only reasonable thing an exception-catching construct could do is to use the only `s' it knows, the one which was in effect before attempting the "guarded" action, to use as the state to continue with
22:49:33 <hololeap> that leads me to something else i don't understand: in order for us to use Either to "drop out", wouldn't it have to be the outermost monad?
22:49:58 <ski> nah
22:50:31 <hololeap> cuz laziness? :)
22:50:45 <hololeap> that's usually the answer for things i don't understand
22:50:48 <c_wraith> Laziness has nothing to do with it
22:50:49 <ski> no
22:51:09 <ski> consider
22:51:10 <ski>   (>>=) :: StateT s (ExceptT e m) a -> (a -> StateT s (ExceptT e m) b) -> StateT s (ExceptT e m) b
22:51:19 <ski> which desugars to
22:51:48 <ski>   (>>=) :: (s -> m (Either e (a, s))) -> (a -> s -> m (Either e (b, s))) -> s -> m (Either e (b, s))
22:52:16 <ski> the third argument is the initial `s', we pass it to the first argument, get back `m (Either e (a, s))'
22:52:45 <ski> we execute that `m'-action (using `(>>=)' for `m', let's ignore this detail here), result is `Either e (a, s)
22:52:48 <ski> '
22:53:12 <ski> we can only continue with `a -> s -> m (Either e (b, s))' if we have an `a' (and an `s')
22:53:47 <ski> in the `Right' case, we have those, so we get `m (Either e (b, s))' which matches the return type
22:54:32 <ski> in the left case we have only an `e' (call it `e' as well, so that `e :: e'), so we use `return (Left e)', to match the return type, using `return' on `m' here
22:54:54 <hololeap> is that a facet of the monad transformer?
22:55:08 <hololeap> returning if the types don't match up?
22:55:11 <zipper> Brian hurts when I try to transform monads :(
22:55:19 <hololeap> poor brian
22:55:38 <ski> so, in the `Left' case, we skip performing the right argument of `(>>=)', aborting the action sequence, "floating" the exception upwards for e.g. further surrounding `(>>=)' calls (or exception-catching calls) to take care of
22:56:22 <ski> hololeap : with a plain `Either e', the same thing would happen, re short-circuiting
22:56:58 <ski> the only difference with `StateT s (ExceptT e m)' here is (a) we're also passing around a state `s'; (b) we're performing actions in some "underlying" `m' monad
22:57:57 <hololeap> i feel like we're going too far down the rabbit hole of tracing haskell's exceution path. isn't that what functional programming is supposed to get away from? is there a more general pattern that i am missing
22:58:55 <hololeap> or was it me who started going down this rabbit hole to begin with? :)
22:59:25 <ski> (well, execution is not the same as evaluation. what i was describing here was how execution of `StateT s (ExceptT e m)' was defined in terms of ordinary evaluation (involving passing around `s' and short-circuiting alternative `e' results), and execution of `m')
22:59:39 <ski> perhaps a bit :)
23:00:16 <ski> @type catchError
23:00:17 <lambdabot> MonadError e m => m a -> (e -> m a) -> m a
23:00:47 <ski>   catchError :: StateT s (ExceptT e m) a -> (e -> StateT s (ExceptT e m) a) -> StateT s (ExceptT e m) a
23:00:51 <ski> becomes
23:01:17 <ski>   catchError :: (s -> m (Either e (a, s))) -> (e -> s -> m (Either e (a, s))) -> s -> m (Either e (a, s))
23:02:02 <ski> as with `(>>=)', we start by passing the initial state (third argument) to the first argument, getting `m (Either e (a, s))', executing it as an `m'-action (using `(>>=)' for `m') to get `Either e (a, s)'
23:03:01 <ski> if we have `Right' here, we just use `return' to forward this as a result of executing the action made by calling `catchError'
23:03:19 <ski> but if we have `Left', we need now to call `e -> s -> m (Either e (a, s))' with this `e', and an `s'
23:03:27 <ski> but *which* `s' ?
23:03:58 <ski> the first argument, `StateT s (ExceptT e m)', aka `s -> m (Either e (a, s))' has quite possibly computed intermediate states of type `s' internally ..
23:04:09 <ski> .. but there's no way to get at those from this vantage point
23:04:15 <ski> all we have as result is an `e'
23:04:57 <ski> the only `s' we could continue the exception handler `e -> StateT s (ExceptT e m) a', iow `e -> s -> m (Either e (a, s))' with is the initial `s' `catchError', which was fed to the first argument
23:05:24 <ski> i.e. we *roll-back* the state to what it was when entering the exception-catching construct !
23:05:46 <ski> hololeap : makes any sense ?
23:06:54 <hololeap> @unmtl ErrorT (IO ()) (StateT [a] IO) b
23:06:54 <lambdabot> [a] -> IO (Either (IO ()) b, [a])
23:08:05 <hololeap> @unmtl ErrorT () (StateT [a] IO) b
23:08:06 <lambdabot> [a] -> IO (Either () b, [a])
23:09:00 <ski> hololeap : now, if you do the same kind of desugaring with `ExceptT e (StateT s m)', you'll see that in that case `catchError' will get the state when throwing the exception (which might perhaps be violating some invariants perhaps, inbetween safe points when modifying individual parts of the state)
23:09:32 <ski> .. which means that it can continue with that state, instead of reverting
23:10:04 <zipper> Is there a haskell style guide somewhere? One that people follow?
23:10:24 <ski> .. now, this argument is a bit hand-wavy, right. it only suggests that it should be possible to get these two behaviours, by stacking the monad transformers in these two different ways
23:11:08 <ski> .. but it so happens that these are the two behaviours the individual implementations of operations will yield, when combined by stacking in one or the other way
23:11:52 <ski> zipper : someone mentioned <https://github.com/tibbe/haskell-style-guide/blob/master/haskell-style.md>, and it looked at least half-decent, on a quick look
23:12:14 <ski> (though i indent by two spaces)
23:12:37 <hololeap> @unmtl StateT () (ExceptT [a] IO) b
23:12:37 <lambdabot> () -> ExceptT [a] IO (b, ())
23:13:14 <ski> `unmtl' doesn't understand `ExceptT', leaves it intact (and everything "inside" it)
23:13:24 <hololeap> @unmtl StateT () (ErrorT [a] IO) b
23:13:25 <lambdabot> () -> IO (Either [a] (b, ()))
23:14:25 <hololeap> so it just swaps if Either is inside the tuple, or if the tuple is part of Right ...
23:14:45 <hololeap> sorry, my processing time is slow :)
23:15:06 <ski> yes, that's correct
23:15:58 <hololeap> i'm re-reading what you wrote and processing...
23:16:07 <ski> so either the state is always returned, or it's only returned on a right/proper/dexter return (as opposed to left/sinister return, resulting from throwing an exception)
23:16:53 * ski . o O ( `data Vel s d = Sinister s | Dexter d' )
23:17:50 <ski> (.. of course, sometimes "exception" is what you "normally" expect as a result of some processing)
23:18:38 <hololeap> ski is from the u.k.? :) i have never heard of dexter/sinister before, but it apparently has to do with a coat of arms
23:18:54 <ski> "sinister" and "dexter" is latin for "left" and "right"
23:19:19 <hololeap> is this commonly used in C.S.?
23:19:26 <ski> not that i know :)
23:19:41 <hololeap> lol, ok then.
23:20:14 <ski> just trying to make use of preexisting association between "left" and "bad", respectively "right" and "good"
23:20:29 <hololeap> ok, i understand
23:21:02 <hololeap> in other words, abstracting from left/right which don't mean much in this context
23:22:15 <ski> (that in turn presumably comes from when humans started farming, and had to make handed tools, and (simplifying the explanation) so to not have to make both left and right handed tools, only make ones of one kind, which happened to be ones which are most comfortable to use with right hand. as a result, right-handed people survived better)
23:24:40 <zipper> ski: Thankee
23:25:25 <ski> zipper : fwiw, i also use form feeds .. and indent the body of a module :)
23:25:52 <maybefbi> on one hand we have recursion schemers, insisting that recurring part of the type be parametrized so that Fix can hide in there. but on the other hand, libraries like Data.Tree or any recursive type not parametrizing the recursive part of the tree. why is it this way?
23:26:38 <ski> `Fix' is unfortunately a bit awkward to use ..
23:26:49 <maybefbi> hmm yeah
23:27:37 <maybefbi> i guess then recusive schemes will remain an oddity
23:27:37 <ski> (also, `Fix F' doesn't determine `F', meaning that there can be many different ways of, given a type `T', specifying a type `F' such that `T' is iso to `Fix F')
23:28:11 <zipper> ski: You indent the body of a module? Like all your code is indented?
23:28:24 <ski> e.g., given `T' a binary tree, you could choose to have `F' only abstract over right sub-trees
23:28:25 <zipper> You can't be serious.
23:28:29 <zipper> Show me an example ski 
23:28:37 <ski> or have `F' correspond to two layers of a tree, not one
23:29:17 <hololeap> ski: i wonder if the fact that the heart is on the left has anything to do with that
23:29:37 <hololeap> or vice-versa
23:30:05 <hololeap> *the fact that the heart is on the left *in most people*
23:31:53 <maybefbi> ski, ok
23:34:37 <piyush-kurur> question regarding ffi calls in haskell: is it possible to call system calls directly or does one need to wrap it in a C stub function and call the stub function instead
23:34:51 <ski> zipper : <http://lpaste.net/10060>
23:35:40 <ski> hololeap : i dunno. iirc it is possible to have the upper organs reversed without the lower organs, and vice versa
23:42:04 <mniip> piyush-kurur, ffi calls cdecl-declared functions
23:42:18 <mniip> or well, maybe some other calling convention
23:42:27 <mniip> depending on your OS, system calls might or might not be that
23:42:42 <piyush-kurur> mniip: thanks.
23:42:50 <mniip> depending on platform details, even, (think vdso/vsyscall)
23:45:40 <piyush-kurur> I think then it is safer to just wrap it in c.
23:46:18 <piyush-kurur> Wait, in my case I can assume it is linux so may be I can get away with it
23:48:01 <hololeap> @unmtl StateT [a] (ErrorT () IO) b
23:48:01 <lambdabot> [a] -> IO (Either () (b, [a]))
23:56:07 <mniip> piyush-kurur, does the syscall you want to call have a libc wrapper?
23:56:10 <mniip> I'd use that
23:56:54 <piyush-kurur> mniip: it is getrandom and o god what a mess it is
23:57:09 <piyush-kurur> I did not realise it is such a mine field out there
23:58:05 <piyush-kurur> thanks to Ford_Prefect for showing me what a disaster the getrandom on Linux is
