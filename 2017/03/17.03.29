00:00:21 <arctictern> If I do "import Data.List" though, i don't have to specify it
00:00:27 <arctictern> and that's not in base right
00:00:28 <hvr> arctictern: and fwiw, it's only stack that requires you to define packages twice; in cabal you also have the equivalent of a stack.yaml file; it's called cabal.project there; but there you don't have to redundantly specify packages
00:00:59 <hvr> arctictern: Data.List *is* in base
00:01:50 <arctictern> Ah sorry. Got confused between base and prelude
00:02:15 <arctictern> Thanks guys!
00:02:34 <opqdonut> hvr: you don't need to mention pacakges that are in your resolver in the stack.yaml file
00:02:46 <hvr> opqdonut: you still have to mention them via the resolver
00:02:58 <hvr> opqdonut: even though your .cabal file is supposed to specify version bounds
00:03:08 <opqdonut> well, yeah
00:03:22 <opqdonut> if you don't want snapshots don't use stack?
00:03:27 <opqdonut> err resolvers
00:03:35 <hvr> you can use stack w/o any resolver? :-)
00:04:22 <opqdonut> it's easy! just say "cabal build" instead of "stack build" ;)
00:04:27 <arctictern> Quick followup... when I do "ghc-mod check test.hs" outside of a stack project, what directory/ies are looked at to check for supported packages
00:04:30 <hvr> heh
00:04:41 <hvr> opqdonut: at this point, I'd rather say 'cabal new-build' :-)
00:04:48 <opqdonut> fair enough
00:05:55 <arctictern> For example, if I have "import Data.List.Split" in a test.hs, and do "ghc-mod check test.hs", it gives the "Failed to load..." error. Running "stack install split" doesn't fix the error (doesn't affect global packages?) but "cabal install split" does
00:06:14 <arctictern> Does that mean I have to install packages with cabal if I want them to be visible to ghc-mod in any given situation?
00:06:28 <opqdonut> arctictern: you need to run ghc-mod inside the stack environment
00:06:36 <geekosaur> ghc-mod only knows what ghc itself does. stack and cabal both pass ghc extra information, but don't know how to do that for ghc-mod
00:06:45 <hvr> arctictern: 'stack install' installs into some stack sandbox iirc
00:06:52 <geekosaur> except via {cabal|stack} exec
00:07:15 <arctictern> Yea if I run ghc-mod inside the stack environment, it works. But for standalone haskell files, is cabal install necessary?
00:07:41 <geekosaur> yes, because that's the only way a standalone ghc will find them
00:07:49 <hvr> arctictern: yeah, `cabal install` allows you to manage your 'user pkg db' which e.g. `ghc-pkg list` allows you to list
00:07:58 <hvr> arctictern: and which is seen by ghc/ghci et all by default
00:08:05 <geekosaur> ghc is not aware of either cabal or stack sandboxes, it's just a compiler not a project manager
00:08:46 <hvr> geekosaur: to be fair; we have a mechanism in the works that was created for the sake of the the nix-style cabal mode: ghc envs; but there's some issues blocking it
00:09:07 <arctictern> Gotcha, thanks again 
01:06:48 <reactormonk> I'm trying to understand the Monad instance of Free Monad, and I think it would help to have every piece of the Monad instance description annotated - is there a tool for that?
01:08:38 <jle`> annotated in what way
01:08:41 <jle`> with comments?
01:10:09 <reactormonk> jle`, or inline types via :: - both would work.
01:11:47 <merijn> Honestly, Free is just a rose tree generalised to any functor
01:12:06 <merijn> reactormonk: Are you familiar with Rose trees?
01:12:31 <merijn> "data RoseTree a = Tree [RoseTree a] | Leaf a"
01:12:40 <merijn> Replace [] with any functor:
01:13:08 <merijn> "data RoseTree f a = Tree (f (RoseTree a)) | Leaf a"
01:13:28 <merijn> eh
01:13:29 <jle`> reactormonk: i do not know of any such tool, but it sounds like something that might be useful.  for what it's worth, the core language used during haskell compilation (that you can dump) always explicitly specifies the types of all of the polymorphic functions it uses
01:13:34 <merijn> "data RoseTree f a = Tree (f (RoseTree f a)) | Leaf a" obviously
01:13:56 <merijn> Which with a little renaming is:
01:14:13 <merijn> "data Free f a = Free (f (Free f a)) | Pure a
01:14:49 <merijn> Not sure if that helps understanding the Monad instance, though :)
01:15:28 <jle`> maybe it's easier to understand it through join?
01:15:56 <jle`> hm perhaps not easier, but it's an alternative way.
01:16:24 <merijn> Well, for me, the monad instance of Free was easy as "generalised rose tree + monads are trees with grafting" (which explains the monad instance of trees)
01:16:27 <reactormonk> jle`, mainly about the (fmap (>>= free) fun) part
01:16:49 <merijn> reactormonk: https://dl.dropboxusercontent.com/u/828035/Monads/monads.pdf
01:16:52 <jle`> i wonder if looking at the core dump would help at all
01:17:03 <jle`> because the core dump explicitly gives the types it is using for >>= and fmap etc.
01:17:15 <merijn> reactormonk: Do you understand my generalisation of RoseTree?
01:18:22 <merijn> reactormonk: Where is that "(fmap (>>= free) fun)" from?
01:18:50 <jle`> reactormonk: if you mean `Free m >>= f = Free (fmap (>>= f) m)`
01:19:20 <lpaste_> merijn pasted “Free from free package” at http://lpaste.net/354053
01:19:29 <merijn> That looks fairly straightforward?
01:19:54 <jle`> i think they're not sure what instance of Functor is being used for <$>/fmap, and what instance of Monad is being used for the >>= in (>>= f)
01:20:46 <cocreature> reactormonk: I often replace expressions by _ to see t
01:20:50 <cocreature> he type ghc expects
01:20:58 <merijn> reactormonk: Note that the contents of "Free" are "f (Free f a)" <- for some Functor 'f'
01:21:23 <merijn> reactormonk: To apply ">>= f" to every 'Free f a' inside the functor you need to 'fmap' it into 'f'
01:23:20 <merijn> reactormonk: Actually, here's an exercise: Take my "data RoseTree a = Tree [RoseTree a] | Leaf a" and implement a monad instance for it
01:23:42 <merijn> That's a crucial first step
01:25:45 <merijn> And if you get stuck doing that, refer to the link a few lines back of the "Monads are Trees with Grafting" paper, which explains the monad instance of trees :)
01:30:33 <Myrl-saki> " Using partially-defined values, we show that the standard lazy and strict implementations of the state monad do not satisfy the expected laws.
01:30:39 <Myrl-saki> What is partially-defined?
01:30:52 <Myrl-saki> `(undefined, "x")` ?
01:31:35 <merijn> Myrl-saki: Yup
01:32:05 <jle`> are there any monad instances in haskell that actually satisfy the monad laws
01:32:08 <merijn> Some people argue monad laws should preserve definedness (whether something is bottom or not)
01:32:15 <merijn> Other people argue:
01:32:48 <merijn> "Fast and Loose Reasoning is Morally Correct" REEEEEEEEEEEEEEEEEE
01:33:00 <merijn> Relevant paper: https://pdfs.semanticscholar.org/a316/3d9097a87a713f0dd3f154f139e19dcb2a82.pdf
01:33:44 <merijn> Which boils down to "we often pretend our non-total language is actually total and here we give a mathematical argument why that's actually a perfectly reasonable thing to do"
01:44:18 <reactormonk> merijn, it's from https://gist.github.com/6503271cc209ceaa8df2cc83eb0c8162
01:44:46 <reactormonk> merijn, I don't have a concept of the rose tree :-/
01:44:58 <reactormonk> cocreature, ah, nice trick.
01:45:25 <reactormonk> jle`, yeah, I do.
01:45:57 <merijn> reactormonk: rose tree is just a tree with "any number of leafs" rather than a binary tree, which only has two leaves
01:46:05 <jle`> not even Identity is a lawful monad if you consider bottom
01:46:14 <jle`> if we don't have identity then what do we even have
01:46:24 <merijn> jle`: It is if you use the newtype ;)
01:48:31 <ktonga> hey fellas, I know some haskell and now my next step is to get better on real-world haskell, and for that I had this idea of rewriting in haskell the current project I'm working on at $JOB using scala, can't imagine something more real world than that
01:49:11 <ktonga> But the thing is I've implemented it mainly with pure FP patterns when possible but for a few things I dunno how to implement in FP I used actors, despite the fact I dont love them, I have to admit it was pretty easy to use them for solving this particular problem.
01:49:24 <ktonga> Here it is the main problem this project tries to solve: at $JOB we depend on a really shitty chat platform that exposes a polling based rest API, so the main flow is to periodically check for new chats, if any is detected add it to a list of managed chats and start checking for new events like system notifications or visitor text lines. The idea is to hide all that complexity in this app and push the proper events to downstream systems using webhooks. I've 
01:49:25 <ktonga> used two actors for that, one chats manager that does the chats discovering and it manages children actors which each represents a chat doing the event polling and the push to the webhook.
01:49:32 <ktonga> How would you do that in haskell?
01:50:30 <cocreature> ktonga: you can just use one Haskell thread for each actor
01:50:44 <cocreature> ktonga: Haskell has light-weight threads so performance should not be an issue
01:51:07 <ktonga> TBH I'm not worried about perf ATM
01:51:26 <ktonga> just on learning the right way in haskell 
01:52:27 <reactormonk> jle`, ... welcome to scala
01:53:21 <jle`> merijn: i remember a discussion a year or so on this channel about how the Monad instance for Identity in base was broken...but i can't find the counter-example anymore v.v
01:53:31 <jle`> reactormonk: warm welcome :)
01:54:46 <ktonga> cocreature: so actors are like threads but the selling point is that they are even lighter and with better concurrency warranties
01:55:46 <cocreature> ktonga: they are lighter than OS threads, I doubt they are significantly lighter than Haskell threads. I’m not sure what you mean by “better concurrency warranties”
01:55:51 <ktonga> I have a rough idea of how I could do it using FS2 that is an streaming lib in scala
01:56:51 <merijn> I doubt actors are more lightweight than Haskell threads
01:57:01 <merijn> Even Erlang processes weigh more than Haskell threads
01:57:12 <ktonga> nvm, I'm not defending them, I'd prefer to avoid using any similar solution, I was more looking for a less mutable-ish solution 
01:57:41 <merijn> If actors are a good fit, then so are Haskell threads :)
01:58:03 <merijn> But then, like 80% of my haskell code tends to be lots of threads and IO and very little immutable :p
01:58:10 <cocreature> I don’t think threads are worth avoiding
01:58:24 <jle`> haskell makes threads fun again
01:58:31 <cocreature> you can have your pure logic run inside of each thread
01:58:32 <merijn> jle`: s/ again//
01:58:33 <ktonga> :)
01:58:33 <jle`> s/again//
01:58:41 <jle`> heh
01:58:49 <cocreature> but using threads to structure concurrent logic is completely fine
01:59:36 <ktonga> ok sounds good, I'll need to read more about them, is one of many things I've never tried i haskell :)
02:00:26 <ktonga> so raw threads is the way to go? or there is some abstraction there that I sould be aware of?
02:00:31 <merijn> @ask phadej I see you committing to 'bound' on github and I notice the bounds on the github version are newer (i.e. actually work for me), any plans to release a new version soonish?
02:00:31 <lambdabot> Consider it noted.
02:00:42 <merijn> ktonga: Have a look at the modules in Control.Concurrent
02:01:12 <merijn> ktonga: Which give you "forkIO :: IO () -> IO ThreadId" for spawning threads and lots of tools like semaphores, channels, etc. Also have a look at STM
02:03:11 <ktonga> ok, sounds like a lot of work (nice one) already. I think I have something to start with. Will come back with more questions for sure once I start :)
02:05:49 <ktonga> I have been also  recommended to take a look at cloud haskell so I'll check both. it's alway good to have options 
02:07:28 <cocreature> ktonga: you might also be interested in http://chimera.labs.oreilly.com/books/1230000000929/index.html in particular the second part on concurrent haskell
02:08:12 <ertes> helo
02:08:36 <ktonga> cocreature: cool, thanks a lot
02:11:46 <mutablemonkey> Hi
02:11:59 <mutablemonkey> My name is mutable monkey and I am looking for papers about immutable programming and arguments against why statefulness is bad.
02:12:34 <ertes> mutablemonkey: statefulness isn't bad, mutable state is (often) bad
02:13:19 <mutablemonkey> Fair point, my friend.
02:13:28 <mutablemonkey> I would like to know more about that, and things that I can reference.
02:15:50 <ertes> to convince yourself or others?
02:15:51 <roundhouse> hi, if I have a StateMonad with a State `data S = A a | B b`, I'd like to zoom onto A and B. I.e. if the state is (A a), then I'd like to call "f :: StateMonad A m => m ()" and otherwise "g :: StateMonad B m => m()". I think I need prisms for that. Am I on the right track?
02:16:16 <ertes> roundhouse: no, just lenses
02:16:27 <ertes> roundhouse: in fact no, just traversals
02:16:32 <roundhouse> ertes: how do I deal with the sum type?
02:16:42 <mutablemonkey> ertes: A combination of both. I personally think there is a fine line between doing it right and doing it at all.
02:16:56 <ertes> roundhouse: traversals can deal with sums…  if it's a B and you zoom into A, nothing happens
02:17:21 <roundhouse> Ah cool. Can you point me to some example code?
02:17:47 <ertes> > flip execState (Left 5) (zoom _Right (id += 7))
02:17:50 <lambdabot>  Left 5
02:17:54 <ertes> > flip execState (Left 5) (zoom _Left (id += 7))
02:17:57 <lambdabot>  Left 12
02:18:05 <ertes> roundhouse: all prisms are traversals as well
02:18:19 <ertes> > flip execState (Right 5) (zoom traverse (id += 7))
02:18:21 <lambdabot>  Right 12
02:18:37 <lep-delete> :t (+=)
02:18:38 <lambdabot> (Num a, MonadState s m) => ASetter' s a -> a -> m ()
02:18:59 <roundhouse> I see, thanks alot.
02:19:56 <roundhouse> I'll have to think about this and play around with it somewhat.
02:23:24 <ertes> roundhouse: if you zoom into multiple components at once, all of them will change with the same formula
02:24:20 <ertes> > execState (zoom traverse (do _1 += 5; _2 <>= "!")) [(1,"abc"), (2,"def"), (3,"ghi")]
02:24:22 <lambdabot>  [(6,"abc!"),(7,"def!"),(8,"ghi!")]
02:25:10 <roundhouse> ah cool
02:25:24 <ertes> bonus: it only needs a single list traversal at run-time, so zooming into a traversal can have performance benefits, too
02:25:28 <roundhouse> I need to seriously read up on the lens package
02:25:51 <roundhouse> nice, but first I need to get it to compile ;)
02:26:12 <ertes> a traversal is something that points to arbitrarily many components, and a lens is a traversal that points to exactly one component =)
02:26:38 <ertes> a prism is something that points to 0 or 1 components, but also has enough information to *construct* it
02:26:48 <ertes> s/something/a traversal/
02:27:07 <roundhouse> ah I see
02:27:18 <roundhouse> do you have any recommended reading on this stuff?
02:27:29 <jle`> > review _Just 'a'
02:27:32 <lambdabot>  Just 'a'
02:27:40 <ertes> no, i usually teach lens by using a providing exercises
02:27:52 <ertes> s/using a//
02:28:00 <jle`> i liked that lens over tea series
02:28:32 <roundhouse> I'll check that out, thanks
02:28:59 <jle`> but for practical usage, the lens library itself comes with good documentation and examples
02:29:48 <jle`> and that big scary diagram on the main page of the docs is actually a very readable diagram showing the subtyping hierarchy and what functions are usable with what types
02:29:56 <roundhouse> yes, it is just so huge, so sometimes it is hard to know where to look
02:30:12 <roundhouse> also I get scared by the types sometimes
02:30:54 <jle`> for the most part you just need to understand the subtyping hierarchy and the types of the major optics
02:30:56 <ertes> roundhouse: i can give you three exercises that should give you a complete understanding of Lens…  one more exercise to understand Traversal
02:31:01 <jle`> lenses, prisms, traversals, etc.
02:31:17 <Phyx-> 23:46:14 < geekosaur> (and I have no idea how Windows' TerminateProcess shows up in Haskell) <-- the answer is it depends on how you were waiting, but in almost all cases it won't translate into an exception
02:31:25 <roundhouse> ertes: sounds awesome, where can I find those?
02:31:26 <jle`> some of the more scary types in the library is just implementation detail
02:31:43 <ph88> hey guys, i want to use apache tika to process some pdf documents, then i want the results imported into haskell. Would it be better to use the tika CLI or the tika RESTfull service ?
02:31:58 <ertes> roundhouse: here: 1. write a function to map over the left component of a tuple:  mapFst :: (a -> b) -> (a, c) -> (b, c)
02:32:26 <roundhouse> ok, I can do that =)
02:33:04 <roundhouse> mapFst f (x,y) = (f x, y)
02:33:40 <ertes> roundhouse: 2. generalise this function to allow an effectful map:  traverseFst :: (Functor f) => (a -> f b) -> (a, c) -> f (b, c)
02:34:47 <ph88> roundhouse, only chuck norris is allowed to carry that name
02:35:03 <roundhouse> ph88: how do you know I'm not him?
02:35:22 <roundhouse> I guess chuck norris would have no trouble with haskell
02:35:30 <ertes> roundhouse: chuck norris understands lenses better than edwardk
02:35:36 <ertes> so you can't be chuck norris
02:35:41 <roundhouse> damn
02:37:34 <roundhouse> traverseFst f (x,y) = fmap (\z -> (z, y)) (f x)
02:37:42 <roundhouse> might not be the most elegant way
02:37:55 <ertes> roundhouse: correct…  and it's the only way =)
02:38:12 <ertes> now traverseFst happens to be a lens, but i'll explain why
02:38:23 <ertes> @let traverseFst f (x,y) = fmap (\z -> (z, y)) (f x)
02:38:25 <lambdabot>  Defined.
02:38:37 <ertes> > (traverseFst +~ 5) (3, 7)
02:38:39 <lambdabot>  (8,7)
02:38:59 <roundhouse> > :t +~
02:39:01 <lambdabot>  <hint>:1:1: error: parse error on input ‘:’
02:39:11 <roundhouse> > :t (+~)
02:39:13 <lambdabot>  <hint>:1:1: error: parse error on input ‘:’
02:39:21 <kadoban> :t (+~)
02:39:23 <lambdabot> Num a => ASetter s t a a -> a -> s -> t
02:39:27 <roundhouse> thanks
02:39:40 <ertes> roundhouse: if you instantiate traverseFst at f = Identity, you get mapFst behaviour…  in fact you can write mapFst in terms of traverseFst now
02:39:42 <jle`> (+~) :: Num a => Lens' s a -> a -> s -> s
02:40:17 <ertes> roundhouse: exercise 3: can you think of an 'f' that allows you to *extract* the value of the first component rather than changing it?
02:41:35 <kadoban> :t traverseFst
02:41:37 <lambdabot> Functor f => (t2 -> f t1) -> (t2, t) -> f (t1, t)
02:42:36 <jle`> > traverseFst (\_ -> Proxy) (1, 2)
02:42:38 <lambdabot>  Proxy
02:42:39 <jle`> aw shucks
02:46:36 <ertes> jle`: no, you forgot: what's the answer to all questions?
02:47:45 <jle`> ?? :o
02:47:45 <lambdabot>  :o
02:47:54 <ertes> it's ContT!
02:48:26 <ertes> > runCont (traverseFst (cont . const) (3, 5)) undefined
02:48:29 <lambdabot>  3
02:48:31 <jle`> lol
02:48:42 <ertes> roundhouse: (ignore that…  Cont is not the correct answer) =)
02:48:45 <jle`> if i were to do this without knowing the answer i would have used [[spoilers]]
02:49:10 <jle`> click to reveal
02:51:11 <phadej> merijn: I'd like to release bound, but it's up to edward
02:51:49 <merijn> phadej: I already bugged him too :p
02:52:16 <phadej> and IIRC it's still blocked on `free` release too
02:53:39 <phadej> I.e. you cannot use Free XXX as `bound` monad
02:53:43 <phadej> iirc
02:55:28 <phadej> anyhow, I'll do some maintaining tasks
03:01:23 <ph88> would you guys prefer a CLI or REST interface to external utility ?
03:02:35 <roundhouse> ertes: I'm confused, does the f in exercise 3 refer to the functor or the a -> f b?
03:02:50 <ertes> roundhouse: the functor
03:03:32 <ertes> traverseFst :: (Functor f) => (a -> f b) -> (a, c) -> f (b, c)
03:03:45 <ertes> roundhouse: the goal is to return the 'a' from this function
03:03:56 <ertes> so you need to pick an f such that:  f (b, c) ≃ a
03:04:33 <mfukar> ph88 , if it can't be a package, conventional IPC is my next thing to look for
03:04:34 <roundhouse> ok, thanks. I'm a slow thinker ^^
03:04:57 <ertes> roundhouse: take your time
03:05:00 <mfukar> ph88, CLI and REST are near the last things I would try
03:05:27 <ertes> ph88: depends…  why do you need an external interface?
03:05:54 <ph88> i want to use apache tika
03:06:12 <ph88> mfukar, i never used conventional IPC and i'm not sure tika supports it
03:06:30 <ertes> ph88: how is that related?
03:07:03 <ph88> ertes, apache tika offers CLI or REST i want to use it with my haskell app
03:07:29 <ertes> ph88: so your application needs communicate with tika using CLI tools or a REST API?
03:07:38 <ph88> yes i think so
03:07:50 <ertes> ph88: that doesn't mean your application needs to have one itself
03:08:12 <ph88> it will be a command line app where you specify a file or directory then haskell goes to search the files and send them to tika, then the tika result goes back to the app and it puts it in elasticsearch
03:08:27 <ph88> ertes, how so ?
03:08:29 <ertes> ah
03:08:51 <ertes> ph88: is this supposed to be used locally only?
03:09:12 <ph88> yes
03:09:41 <ph88> after the command line tool done it's job and all the documents are in elasticsearch i start the spock web app that presents the documents on a webpage
03:10:05 <ertes> ph88: there are a number of options…  the easiest might be to use something like fsnotify on a directory from your app…  whenever a file pops up there, your app feeds it to tika and deletes it afterward
03:10:23 <ertes> the other option, probably the safer one:  use a unix socket
03:11:26 <ph88> i don't need notification for now .. i have hundreds of documents that need to be imported once
03:11:33 <ph88> very seldomly a new document appears
03:11:50 <ph88> i can worry about that later, but i think in that case someone will upload it through the web app
03:12:52 <ertes> well, one question i'd ask is: does the web app even have to be aware of that?  a separate program could feed documents into tika and elasticsearch
03:13:05 <ph88> yes i'm talking about the separate program
03:13:32 <ph88> import:  pdf -> separate program (CLI) -> tika -> separata program -> elasticsearch
03:13:39 <ph88> reading:  spock -> elasticsearch
03:14:01 <ertes> that sounds reasonable
03:14:21 <merijn> ok, so I have a transformer stack with Except (i.e. Either) as base monad, but I want some operation to use the Validation applicative. Is there an easy way to mix things?
03:14:30 <ph88> ya but for tika i can choose to launch it as command (tika can be CLI)  or i can do REST client in my separate (cli) program
03:16:07 <merijn> I guess I could use mmorph to selectively generalise/degeneralise them?
03:16:25 <knupfer> Should I choose tasty or hspec? What are the disadvantages?
03:16:49 <knupfer> tasty doesn't use a monad, so it seems less convenient but more sound?
03:19:04 <ph88> ertes, just like to know an opinion if it's easier to interface CLI or REST with haskell
03:19:47 <Booba> ertes: Hello! Wanted to kindly ask if there's a chance you might elaborate on your most awesome hangman-game example any time soon?
03:33:04 <ph88> is there a way that i can use "reply" inside the main do-block?  when i use "when" i had to make a sub do-block for things to compile   https://bpaste.net/show/742c535f4546
03:34:04 <geekosaur> you cannot if you are using when, exactly for that reason
03:34:38 <geekosaur> also you need to decide what value reply will have if exists is true
03:35:48 <ph88> you mean theoretically speaking ?  when i was using  if/then/else  instead of   when    or something ?
03:36:35 <geekosaur> if you want reply to be available, it has to have a value
03:38:44 <geekosaur> ...I guess that made no sense to you?
03:38:52 <geekosaur> I am trying to figure out what you think is going on
03:39:51 <geekosaur> you want `reply` to exist outside the constraint of `when (not exists)`. this can only happen if it can be given a value also `when exists`
03:43:38 <ertes> Booba: did you see my summary yesterday?
03:43:59 <ertes> ("yesterday" from my perspective at least)
03:44:06 <geekosaur> @undo do { reply <- something; somethingElse }
03:44:06 <lambdabot> something >>= \ reply -> somethingElse
03:44:11 <Booba> ertes: yes, that gave me some insights, thanks
03:44:36 <ertes> Booba: if you have specific question, i'm happy to answer them
03:44:40 <ertes> *questions
03:45:04 <Booba> ertes: I wanted to ask about the Hangman datatype. I see you defined IsString and Monoid instances. But I cant put my finger on what the two constructor parameters stand for
03:45:37 <Booba> ertes: * of Guess contructor
03:45:46 <erisco> where do I get my hands on this hangman program?
03:45:47 <roundhouse> ertes: I think the `Const a` functor should work. Then traverseFst :: (a -> Const a b) -> (a, c) -> Const a (b, c), and the only sensible implementation of ( a -> Const a b) seems to be `Const` (the constructor), so that in the definition the fmap is ignored.
03:46:53 <ertes> Booba: if a game is (Guess xs f), then it represents a running game with a challenge xs and a continuation function f…  given a guess x, (f x) will be the game updated with that guess
03:47:14 <ertes> Booba: it may be useful to know that 'xs' is purely for presentation purposes, it has no meaning in terms of game logic
03:47:28 <ertes> in this case it's used to communicate the current challenge to the player
03:47:36 <ertes> roundhouse: correct
03:47:49 <ertes> roundhouse: now you can actually write functions like these:
03:48:00 <Booba> ertes: ok, so the challenge is [Maybe a] to represent the correct guesses with Just a, correct?
03:48:09 <ertes> view :: ((a -> Const a b) -> s -> Const a t) -> s -> a
03:48:33 <ertes> over :: ((a -> Identity b) -> s -> Identity t) -> (a -> b) -> s -> t
03:49:11 <erisco> http://community.haskell.org/~ertes/hangman/
03:49:14 <ertes> Booba: correct
03:49:43 <ertes> oh, shit, i forgot about that one =)
03:50:12 <ertes> it's not complete though
03:50:40 <erisco> that's the first Google result
03:52:07 <ph88> this is how i thought would be a good idea to structure this code https://bpaste.net/show/d1b2dd0f4eba however i get an error (which i can solve with   hasFiles <- any doesFileExist paths   )     but now i wonder if this is the right way to structure my code with all these if/then/else  ?
03:52:23 <Booba> ertes: that helps a lot. And what about Hangman type itself. Is there any relation between its type parameters a and b?
03:52:40 <ertes> Booba: apparently i've already written an incomplete tutorial for that in 2015; see erisco's link =)
03:52:52 <roundhouse> ertes: Thanks very much for taking the time to explain me all this.
03:52:56 <_sras_> Is there any way to auto derive FromJSON instances and provide rules on how to transform field names to json keys?
03:53:15 <ertes> Booba: no, i tend to generalise like that to get additional type safety, and it helps me keep things apart
03:53:27 <ph88> eh that fix didn't even work but that's beside the point :/
03:53:28 <phadej> _sras_: there aren't :/
03:53:33 <Booba> ertes: ok, I'll take a look, thanks! Still I can't imagine myself doing problem solving in such way, yet =)
03:53:37 <erisco> ertes, what is the other link?
03:54:18 <ertes> erisco: hmm?
03:54:20 <erisco> and though I am still reading (and it looks interesting), a real-time game can be modeled as a turn-based game
03:54:33 <erisco> well there is some other link Booba is reading
03:54:52 <ertes> so far i've only showed them code
03:54:53 <Booba> erisco: https://raw.githubusercontent.com/esoeylemez/snippets/master/Hangman.hs this one
03:55:04 <ertes> yeah, that
03:55:21 <erisco> the difference between real-time and turn-based is in presentation
03:55:28 <ertes> ("showed"? "shown"?)
03:55:36 <ertes> "shown" i think
03:55:49 <geekosaur> yes
03:55:51 <erisco> I suppose you could describe some difference in the game rules
03:56:11 <erisco> such as a turn-based game offers unlimited time to make an action whereas a real-time game offers limited time to make an action (else defaults to no action)
03:56:26 <erisco> but then if you have a turn-based game with a turn timer that falls apart
03:56:38 <ertes> erisco: well, with real-time games you can embrace the continuum and represent things as FRP behaviours
03:56:49 <ertes> although that also works for turn-based games, i guess
03:57:00 <ph88> is that even possible to use these two functions together?    any :: (a -> Bool) -> [a] -> Bool     doesFileExist :: FilePath -> IO Bool
03:57:01 <erisco> right
03:57:23 <ph88> @src any
03:57:23 <lambdabot> any p = or . map p
03:57:46 <ertes> the current challenge might be a behaviour, and it might change in reponse to a guess event
03:58:00 <erisco> maybe you could make the distinction around human reaction time
03:58:00 <geekosaur> ph88, your first thought was correct but I'm guessing you did it wrong
03:58:49 <ph88> geekosaur, which first though? i think i can not use any  but i have to use  or . mapM_    or something like that
03:59:01 <erisco> in any case, I only meant to point out that in a technical sense they're not all that different, even though presentationally we accept then differently
03:59:15 <geekosaur> not mapM_, that discards results but you need the result
03:59:24 <ph88> mapM
03:59:36 <_sras_> phadej: Won't this work? https://hackage.haskell.org/package/aeson-1.1.1.0/docs/Data-Aeson.html#v:genericParseJSON
03:59:36 <ph88> but i'm right i can't use   any   for IO values ?
03:59:56 <geekosaur> not directly like that
04:00:26 <erisco> another example is tool-assisted speed runs... normally a real-time game yet it is being presented as turn-based
04:00:50 <ertes> erisco: well, this is really just a special case of a pretty generic state machine
04:01:09 <geekosaur> checks <- mapM doesFileExist paths; if not (any checks) then ...
04:01:25 <geekosaur> also why are you using printf wiith a literal string and a dummy parameter instead of putStrLn
04:01:31 <ertes> erisco: data Auto r a b = Done r | Auto (a -> (b, Auto a b))
04:01:39 <merijn> Insert usual complaint against using doesFileExist
04:01:45 <erisco> I have to get through your article still
04:02:06 <erisco> I probably would have made what you're calling a mistake, so I am learning :)
04:02:37 <ph88> geekosaur, sometimes i want to put 2 newlines in the printf ... put i'm still protoyping .. maybe later i will add parameters or if not i can replace it with putStrLn ..  is there any downside to printf except for having to put () ?
04:03:10 <geekosaur> weird errors if you get it wrong, because printf in Haskell is a horrid hack?
04:03:26 <geekosaur> (nasty typeclass hackery that produces confusing errors)
04:03:44 <phadej> _sras_: it will, but you have to write instances still, you cannot say "deriving instance FromJSON MyType using myOpts" or something like tht
04:03:52 <geekosaur> also I don't see why printf "... \n\n" () is preferable to putStrLn "...\n"
04:04:29 <roundhouse> :t _Left
04:04:31 <lambdabot> (Applicative f, Choice p) => p a (f b) -> p (Either a c) (f (Either b c))
04:05:51 <ph88> geekosaur, i replaced the printf but something is not quite right with what you suggested https://bpaste.net/show/e6c73c5a1bc6  i'm still looking into it
04:06:56 <geekosaur> mm, any is the wrong thing there
04:07:12 <geekosaur> :t or
04:07:14 <lambdabot> Foldable t => t Bool -> Bool
04:07:55 <ph88> too bad this syntax is not allowed    isFiles :: [Bool] <- mapM doesFileExist paths
04:08:21 <geekosaur> it is allowed with ScopedTypeVariables, but it will not help
04:08:45 <geekosaur> that's not the problem
04:09:27 <geekosaur> if not (or isFiles) then ...
04:09:56 <erisco> ertes, heh, you could say it is actually an article about monoids and abstract algebra :P
04:13:29 <ertes> erisco: yeah, my articles tend to be like that =)
04:14:11 <ertes> erisco: if you love monoids as much as i do, here is more brain fodder: http://ertes.eu/tutorial/config-monoids.html =)
04:15:44 <cocreature> there is also a functional pearl paper on monoids which is great
04:16:14 <ph88> i have this little snippet of code   mapM_ (\x -> makeAbsolute x >>= putStrLn ) paths     but this still prints directories with .. in them, should i use  canonicalizePath  or am i doing something wrong here ?
04:17:07 <ph88> canonicalizePath  works as expected, i'm just surprised that makeAbsolute doesn't seem to do anything
04:17:09 <ayujup> I'm on Debian Strech, trying to `stack upgrade`. I get tons of 'can not be used when making a shared object; recompile with -fPIC' errors. This is even mentioned in https://github.com/commercialhaskell/stack/blob/master/doc/faq.md. Tried to change to current stackage with ghc 8.0.2, but this doesn't seem to help. Anybody solved this issue?
04:17:33 <ph88> i don't want to follow symbolic links that canonicalizePath does, but i still want the absolute path without .. 
04:17:40 <ayujup> https://github.com/commercialhaskell/stack/blob/master/doc/faq.md#i-get-strange-ld-errors-about-recompiling-with--fpic to be precise
04:17:58 <erisco> ertes, you need a more sophisticated game than Tenderman to really show off what you're getting at
04:18:37 <geekosaur> ph88, makeAbsolute only forces the path to start with /, it does not resolve . or .. within the path. canonicalizePath does that, and it *must* resolve symlinks if you do that
04:19:19 <geekosaur> because you can have a symlink to a directory, and if you follow .. up from it then you are in the parent to the actual directory, not the directory the symlink is in
04:19:20 <erisco> one way to branch is to test if UglyTenderman is won, a Bool predicate, and you've instead changed how Tenderman is defined
04:19:22 <ph88> geekosaur, why must it resolve symbolic links to resolve ..   ?
04:19:25 <ph88> oh ok
04:19:44 <erisco> now we have a constructor for each scene in the game ("scene" is a term I have seen used in game frameworks)
04:19:57 <erisco> so we might have a menu scene, a play scene, a game over scene, etc
04:20:20 <geekosaur> (note that bash will confuse you if you test this there instead of in a program, it's a known wart in bash)
04:20:30 <ph88> geekosaur, is there a function that tries to resolve .. but when it hits a symlink it fails?  so a makeAbsoluteMaybe  ?
04:20:33 <erisco> the addition of the continuation is interesting, but I am not completely sure of it
04:20:51 <geekosaur> ph88, no
04:20:55 <ph88> :(
04:21:08 <ph88> i will keep with canonicalizePath then
04:21:08 <erisco> in one sense it is just another way to store the state
04:21:14 <geekosaur> and if there were, it'd just be multiplying edge cases
04:21:27 <erisco> in the continuation is the complete word, for example
04:21:37 <geekosaur> it is generally best not to try to be clever about paths, they will bite you
04:22:13 <erisco> we could do this differently with, say, Reader or State
04:22:28 <ertes> erisco: no, the idea is that Hangman is an *extension* of Tenderman, and it can be defined without changing Tenderman at all by writing a monoid morphism
04:22:29 <geekosaur> someone will run your program in a mounted smbfs with a reparse point, or in AFS or GFS or ..., and your clever code will do unexpected things
04:22:38 <ertes> erisco: but i never completed that tutorial
04:23:03 <ph88> geekosaur, maybe there is a function that says the path contains a symlink   ?
04:23:16 <geekosaur> ...
04:23:24 <ph88> geekosaur, ok but it's confusing for the user
04:23:27 <geekosaur> I guess being as clever as possible is critical?
04:23:43 <ph88> if there are a lot of ..  in the path then the user will get confused
04:23:49 <geekosaur> what;s more confusing to the user, .. or weird errors for paths that are valid?
04:23:52 <ph88> when the symlinks are resolved the user will also get confused
04:23:59 <ertes> erisco: the next advantage is that you can generalise Tenderman first to cover all kinds of guessing games, then to cover all turn-based games and finally to cover all state machines
04:24:11 <ertes> erisco: and in practice i would generalise *first*
04:24:37 <ph88> geekosaur, i was thinking that in case the path contains no symbolic links or other things that can trip up i will show the canonicalizePath otherwise i will show the absolutePath
04:24:47 <ph88> this will be the most user friendly
04:24:50 <erisco> ertes, well I am not sure what you're committed to then
04:24:55 <geekosaur> you can;t test for an smbfs reparse point
04:25:03 <erisco> ertes, is it how you defined Tenderman or is it the monoid or is it both?
04:25:29 <geekosaur> you can test for ?FS volume mountpoints but you'd have to deal with the filesystem tools not being present on most systems
04:25:34 <ertes> erisco: what do you mean?  and are you asking in the context of the article?
04:25:52 <erisco> what is your opinion at this moment?
04:26:15 <ph88> geekosaur, maybe it would be enough to see what the effect was on the path after it's been processed by the machinery in  canonicalizePath  ?
04:26:18 <geekosaur> you are trying to be "nice" to your users, but you cannot handle all cases, you can't even detect some of those cases
04:26:23 <ertes> erisco: about what?
04:26:48 <ph88> ok i guess i will just show both then :/
04:27:27 <geekosaur> if it's that overridingly important to be clever, just be clever and deal with the fallout when the filesystem is cleverer than you are
04:27:34 <ph88> i mean if the   canonicalizePath  is /my/path    and the absolutePath  is   /my/../my/path  then it' s pointless to show the absolutePath
04:27:50 <geekosaur> it's the wrong thing to do for robustness bt you apparently consider it that important
04:28:39 <ph88> :(
04:28:56 <ph88> i prefer robustness, but this is just very unfriendly
04:29:01 <ph88> for the user
04:30:16 <ph88> i will put it in the manual that it will resolve symlinks and mount points
04:30:54 <ph88> eh reparse point
04:34:39 <ph88> what's a good library to be a REST client ?
04:36:38 <brynedwards> http-conduit
04:37:08 <cocreature> the author of megaparsec also released one relatively recently which looked interesting but I haven’t played around with it
04:37:17 <brynedwards> req ?
04:37:25 <cocreature> https://github.com/mrkkrp/req
04:37:25 <ertes> ph88: if you don't mind first specifying the API on the type level, you can derive a client using servant
04:37:27 <cocreature> yep
04:37:33 <erisco> ertes, on all the stuff before monoids I am saying I am not sure about using this approach over the Ugly one
04:38:02 <ertes> erisco: i would take the algebraic approach most of the time
04:38:08 <erisco> ertes, with the monoids I'd have to think about what the monoid on Ugly is
04:38:27 <erisco> not just what it is, because that is obvious, but what it gives you
04:38:55 <ertes> erisco: no, you first define the game type and the realise that it's a monoid…  you don't start with the intention of creating a monoid
04:39:01 <ertes> it just happens to be one, and you exploit that
04:39:10 <erisco> that isn't what I am saying
04:39:35 <erisco> you began with the premise that "X is the wrong way to do it, do it Y way instead"
04:39:58 <ertes> erisco: well, monoids (and most other structures) give you compositionality and composability
04:39:59 <erisco> only considering the article up to but not including the monoids I am not sure the case is made
04:40:25 <erisco> so if monoids make the case then it has to be that the monoid on Y is better than the monoid on X
04:40:30 <ertes> once you have a monoid you have a compositional API (<>), you get access to a lot of utility functions (foldMap) and composability (product monoids)
04:40:38 <erisco> and by "better" I mean lends better facility to implementing our game
04:40:53 <erisco> you can define a monoid for Ugly
04:40:54 <ertes> later down the line you get extensibility (monoid morphisms) or in other words: you get principled ways to translate from a DSL to another one
04:41:03 <erisco> so you get all those things you are talking about for Ugly
04:41:10 <ertes> ah, now i understand what you mean
04:41:42 <erisco> I am talking about the simple logic of the argument, yes
04:42:12 <ertes> one thing you don't get with Ugly is composition of game logic…  you still need to write a function with full knowledge management
04:42:28 <erisco> and I think the key difference is the inclusion of the continuation
04:42:43 <erisco> because Ugly has nothing about the transitions of state, it is only state
04:42:55 <ertes> yeah, the continuation integrates the game logic into the game state (and in fact makes the actual game state invisible, because it's not relevant to the user)
04:43:07 <erisco> so a monoid on Ugly only composes state, whereas a monoid on non-Ugly also composes transitions
04:43:18 <ertes> also Tenderman provides a safe API by construction…  Ugly is unsafe
04:43:27 <ertes> a user could cheat
04:43:31 <erisco> this is interesting because I ran into something similar when working on UIs
04:43:51 <erisco> I wanted a more robust way to implement the flow of our user interfaces and so I turned to state machines
04:43:55 <spatial> I still have some problem withs recursive functions. Nested
04:43:59 <ertes> oh, speaking of UIs: you can't separate the game logic from the UI without essentially reinventing Tenderman
04:44:11 <erisco> and I realised something similar to what you are talking about
04:44:21 <erisco> wrt state machines
04:44:54 <ph88> Req is an easy-to-use, type-safe, expandable, high-level HTTP library that just works without any fooling around.  -- sounds good :P
04:45:00 <erisco> but I never had it completely ironed out so maybe you have a better solution
04:45:05 <ph88> especially the "just works" part
04:45:21 <ertes> erisco: FRP =)
04:45:50 <erisco> eh, I am not sure that resolves all the questions about state machines one would have
04:46:09 <ertes> no, but it's a good way to manage the state of a UI
04:46:22 <ertes> without actually thinking in terms of state
04:46:25 <erisco> sure, you've got switch and friends, but that is really the only way FRP touches state machines that I can discern
04:46:30 <spatial> I think I need 'let'.
04:46:47 <erisco> well the whole point is to think in terms of state
04:46:49 <erisco> that is the desired model
04:47:02 <cocreature> spatial: I think you need to provide more information if you want us to help you :)
04:47:12 <erisco> the user clicks the button, now it is processing, now it is finished and results are displayed
04:47:48 <ertes> erisco: no, switching only involves a rather trivial form of state…  the way you introduce state is by using what i call event scans:  stepper in reactive-banana, foldDyn* in reflex 0.4, accum* in reflex 0.5, scan* in wires
04:48:01 <spatial> cocreature:Your suggestion. Thanks. It is being tested. http://lpaste.net/354055
04:48:05 <erisco> I said "and friends"
04:48:15 <cocreature> spatial: so what kind of problems are you running into?
04:48:24 <ertes> erisco: switching and event scans are pretty much unrelated concepts
04:48:32 <ertes> except that they are both FRP, i guess =)
04:49:04 <spatial> It does work. numbins is being decremented by both functions. I need to copy using let ?
04:49:09 <erisco> no, they're more related in that, but not in the technical sense of FRP
04:49:14 <erisco> they're more related in application
04:49:25 <erisco> you want a thing that changes when a thing happens
04:49:28 <ertes> erisco: if processing takes real time, the button to start processing is an event that is bound to the real world, and a separate event delivers the result
04:49:39 <erisco> well, switching and scans then fit that vague idea
04:50:35 <cocreature> spatial: I don’t understand that statement. which two functions are you referring to? only loop1 decrements numbins
04:50:40 <ertes> erisco: if the processing happens within the reactive system, then processing is just an event scan
04:51:05 <cocreature> spatial: I guess "loop" decrements nb but then I don’t understand what you expect
04:51:11 <erisco> well, I don't know what to say, other than state machines were relevant for me even with FRP involved
04:51:28 <ertes> erisco: yes, scans *are* state machines
04:51:28 <cocreature> spatial: ah maybe you intend to call "loop1 nb …" instead of "loop1 numbins" in line 6
04:51:30 <erisco> well, it was knock-off FRP
04:51:52 <erisco> and I implemented with a scan, yes! but that is as far as FRP is involved
04:51:55 <spatial> I think they are different. nb and numbins
04:52:30 <ertes> erisco: yes, FRP is more about connecting many such components…  the individual components are fairly boring from FRP's viewpoint
04:52:40 <erisco> the whole thing looks the same except you decorate with Event and Behaviour as appropriate
04:52:42 <ertes> erisco: for example implementing Tenderman with FRP would be pretty pointless
04:52:44 <spatial> Are they both copies of the parameter ?
04:53:00 <cocreature> spatial: by calling "loop1 numbins" you are referring to the initial value of numbins that is passed to playrepeatedly. "nb" is initially set to "numbins" in line 3 but you update it at each iteration of "loop"
04:53:14 <cocreature> spatial: maybe try renaming the parameters so you don’t have name collisions
04:53:32 <cocreature> and then once you’ve figured out how to make that work go back and figure out shadowing
04:53:47 <erisco> my stumbling block wrt state machines was embedding one within another
04:53:53 <ertes> erisco: but then you find yourself implementing a menu to start new games, have multiple games running simultaneously, having a clock ticking with a time limit for the next move, etc.
04:53:56 <ertes> erisco: that's the point when FRP becomes useful
04:54:05 <ertes> in other words: FRP makes this scalable
04:54:08 <erisco> well I don't think FRP had anything to do with it
04:54:36 <merijn> Retry: Anyone here have experience mixing Validation and Either? I have an Either based monad stack that I (in certain places) want to use Validation instead (I'm doing typechecking for some issues I want to collect *all* errors)
04:54:40 <erisco> I was trying to make particular transforms work and I am not sure I ever quite got it right
04:54:50 <erisco> unfortunately the project ended before I was able to get too far on that work
04:54:54 <ertes> erisco: well, most state machine types form some structure:  Applicative, Arrow, etc.
04:54:58 <spatial> cocreature:Think it is alright. Let me test somemore.
04:55:01 <cocreature> merijn: I’ve used Validation at some point. not sure if that counts as experience :)
04:55:05 <merijn> However, there's no really convenient way to do this, apparently? I'm wondering whether anyone has done something like that before
04:55:10 <ertes> erisco: even pipes' Proxy type is in essence a state machine type
04:55:18 <ertes> then "embedding" is really just composition
04:55:22 <ph88> did something change in stack that i now get these messages during install?   Package entropy uses a custom Cabal build, but does not use a custom-setup stanza Not using the explicit setup deps approach based on configuration Strongly recommend fixing the package's cabal file
04:55:33 <merijn> cocreature: I've used Validation before, my specific issue is how to go about mixing Validation and Either/Except, with a lot of boiler plate conversions
04:55:45 <erisco> ertes, I would have to drag out all my notes and code to recall what exactly the issues were
04:55:57 <merijn> cocreature: Since some of my checking is monadic, but others are the same monadic check a bunch of time in parallel
04:56:07 <ertes> erisco: i think i had an automaton tutorial somewhere, which covers this: the concept of local state
04:56:17 <cocreature> merijn: it provides an _Either Iso, does that help avoiding some of the boilerplate conversions?
04:56:18 <dcoutts> ph88: Cabal now supports explicitly declaring Setup.hs script deps in a custom-setup stanza. This is now recommended practice.
04:56:38 <merijn> cocreature: I figure I can use "mmorph" to change the underlying thing, but I'm not sure how costly that
04:56:59 <erisco> ertes, I had a particular definition of state machine and that could have doomed me, I am not sure
04:57:09 <merijn> cocreature: I have "ReaderT Env (Except Error)", basically, so I have to change the validation/either "under" Readert
04:57:19 <geekosaur> ph88: stack also does that, because setup deps are hard to get right otherwise (stack couldn't build recent gtk2hs because of its setup deps, for example)
04:57:34 <ertes> erisco: possibly yeah, but it's really easy to make an automaton type that is composable
04:57:35 <merijn> cocreature: Just seems odd I'm the first one running into this? :)
04:57:47 <erisco> ertes, I will eventually be dragging it out again next time I try to make a UI because all roads were leading in that direction
04:57:47 <ertes> erisco: the 'machines' library has a bunch of those, look in particular at Mealy
04:57:51 <cocreature> merijn: hm I guess I’ve never had a need for it :)
04:58:05 <erisco> I was suddenly able to easily make much more sophisticated UIs once I had this in place
04:58:19 <ertes> erisco: you may have been reinventing AFRP =)
04:58:21 <merijn> Anyway, meeting now, I'll figure something out later :)
04:58:38 <erisco> never heard of it, but I was already using knock-off FRP
04:58:49 <erisco> again, it isn't that relevant to the state machine
04:59:04 <ertes> erisco: wires, yampa, …
04:59:19 <erisco> if you looked at the equivalent state machine without FRP you'd see it is the same thing but with Event and Behaviour decorating a few things
04:59:20 <ertes> erisco: in AFRP the A secretly stands for "automaton" =)
04:59:36 <dcoutts> geekosaur, ph88: sorry, to be clear I meant that Cabal (lib/build system) has this feature, and indeed stack and cabal-install now make use of it and recommend it as good practice so we can track deps properly.
04:59:42 <ertes> erisco: it's literally an automaton framework
05:00:08 <Jinxit> anyone around that has used Earley? got some issues with recursive grammars
05:00:47 <erisco> ertes, so my request is that you finish your article so I can learn of the Hangman morphism
05:00:54 <erisco> ertes, else I'll have to rethink it myself :P
05:01:13 <erisco> plus your generalisations to all state machines, which is what I'm actually interested in
05:02:04 <erisco> ertes, wrt the button and loading example, that was a simple description of a state machine behind many dialogs on our app
05:02:36 <erisco> ertes, many of our dialogs prompted the user for some input, then passed this to some side effectful function, then a result came in some unknown time
05:02:52 <erisco> ertes, so I designed a state machine to handle this general problem
05:03:07 <erisco> made everything much, much easier
05:03:08 <ertes> erisco: i would have solved this with regular FRP
05:03:25 <erisco> it doesn't work well with that alone
05:03:28 <erisco> it was what I already had
05:03:36 <erisco> the problem is that the interface goes through different states
05:04:07 <erisco> so there is the state where you enter input, then the state where it is processing (which should occlude the inputs and display a loader)
05:04:12 <erisco> then a state on completion
05:04:17 <erisco> and also states for errors
05:04:35 <erisco> by having the states it made programming the view trivial
05:04:38 <ertes> doesn't sound like a problem…  it's fairly easy to model that
05:04:45 <erisco> I just branch on the state and show the corresponding view
05:05:12 <erisco> yeah, I made it easy, lol
05:06:12 <erisco> trying to tease these states out of "what does the view model look like it is doing right now" wasn't so easy
05:06:29 <ertes> with FRP i could easily model an application that supports multiple concurrent requests, displaying the current state of all pending requests as well as any results and errors that occurred
05:06:40 <erisco> it also made resuming more straight-forward which is an annoying problem on mobile
05:07:20 <erisco> well, go do it and in such a way that there is nothing resembling a state machine
05:08:10 <erisco> and if you find that too easy then try it in a crippled FRP implementation called Rx
05:09:03 <erisco> where anything involving side effects will make you lose hair
05:11:59 <ertes> erisco: you could also just watch one of ryan trinkle's videos on reflex
05:12:32 <ertes> he does present UIs that do exactly that (posting to twitter, waiting for acknowledgement, etc.)
05:13:42 <ertes> erisco: in some cases you may also find this library useful: https://hackage.haskell.org/package/predictive
05:15:12 <erisco> I spent many months working on this problem
05:15:30 <erisco> for you to not think the solution looks like a state machine then we have very different concepts of state machine
05:15:55 <ertes> erisco: if you look close enough, this code looks like a state machine, too:
05:15:57 <ertes> > [1..]
05:15:59 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
05:16:14 <ertes> "looking like a state machine" is not a useful way to categorise
05:16:30 <erisco> I disagree
05:16:51 <erisco> you're using it yourself
05:17:00 <ertes> in any case, look up his videos…  it's a highly declarative and *easy* way to model what you said
05:17:27 <ertes> the reason is that all this complexity is built into and *hidden* in the reflex library
05:17:50 <erisco> Haskell wasn't an option when I was working
05:18:22 <erisco> hopefully I can use Haskell next time so I'll revisit it then
05:18:22 <ertes> well, that's unfortunate =)
05:18:37 <erisco> but I don't need to be shown simple ways to model an asynchronous request with FRP
05:18:40 <erisco> I've seen that many times
05:20:18 <ertes> i wouldn't think of those examples as "simple", they involve some fairly heavy machinery under the hood
05:20:32 <ertes> but the whole point of it is that they become simple from a programmer viewpoint
05:20:44 <ertes> it's a simple application on the surface, and the code should reflect that
05:21:57 <ertes> the other point is that it scales…  you can add more complexity without going insane
05:25:40 <erisco> reflex-dom is probably neat
05:25:49 <erisco> that is the first thing I tried doing with FRP and ghcjs
05:26:19 <erisco> turns out it is a bit of a bother to manipulate DOM children in just the way you want
05:29:02 <spatial> Do functions execute one after the other as declared ?
05:29:13 <erisco> no, nor do they execute
05:30:10 <erisco> we define things, so we define foo = bar, and we write expressions, and expressions are evaluated
05:30:41 <erisco> there are functions like putStrLn which are special in that they do have an executional component to them
05:30:44 <ertes> erisco: i've never actually used reflex-dom myself, so i wouldn't know…  i only use reflex
05:31:06 <erisco> when those evaluate they produce a side effect
05:31:09 <ertes> erisco: but judging by the things they do with reflex-dom, i'm pretty sure it supports that kind of thing
05:31:13 <spatial> func1 param1 followed by func2 param2. func1 takes some time.
05:31:15 <geekosaur> I am imagining spatial has never seen a compiled language
05:31:23 <geekosaur> only scripts
05:31:39 <geekosaur> meaning, procedural atuffat the top level executing in order
05:31:45 <geekosaur> *stuff at the
05:32:05 <erisco> spatial, what do you mean by "func1 takes some time" ?
05:32:22 <erisco> are we arguing the narrow point of taking time and producing waste heat as being side effects?
05:32:46 <erisco> well, based on your initial question, I don't think so
05:33:26 <spatial> erisco:func1 works on a data structure. func2 should be called after it finishes.
05:34:10 <erisco> that just isn't a thing in Haskell, there are no statements, and what you're describing sounds like statements
05:34:11 <geekosaur> relentlessly procedural
05:34:53 <erisco> geekosaur, sounds like a great T-shirt slogan
05:35:40 <erisco> spatial, if you're new to Haskell we can point you at some learning resources, or if you have specific questions we can answer them here
05:35:47 <ertes> spatial: outside of your development cycle (i.e. in a compiled program) there is only one way to cause things to happen: 'main'
05:35:53 <erisco> but it is a bit lengthy to explain the entire concept of how Haskell programs work
05:36:02 <ertes> spatial: main = do print 1; print 2
05:36:06 <ertes> first print 1, then print 2
05:36:41 <spatial> ertes: do is significant there. You mean ?
05:36:58 <ertes> spatial: do is not relevant, it's just a syntactic convenience
05:37:07 <ertes> the point is that everything your program does starts from 'main'
05:37:10 <erisco> I don't know if showing something that looks vaguely like procedural programming is wise at this stage
05:37:20 <ertes> spatial: for all intents and purposes 'main' *is* your program
05:37:42 <ertes> (do c; d) happens to be the program that first runs the program c, then the program d
05:38:05 <erisco> eh, come on, you know that is misleading
05:38:24 <spatial> ertes: Missing something. My Haskell code has main. Java has main.
05:38:27 <ertes> everything else is just helper definitions that you refer to from main (either directly or indirectly)
05:38:57 <ertes> spatial: yeah, haskell's 'main' is pretty much the same idea as java's 'main'
05:39:38 <ertes> regarding order of operations you need to distinguish between two different things: evaluation (like computing the result of a function) and execution (IO actions)
05:39:42 <spatial> ertes: print 1; print 2   Is that sequential always ?
05:39:59 <ertes> spatial: yes
05:40:04 <erisco> I can't watch, tell me how it ends up
05:41:00 <ertes> spatial: but consider this:  print (2^8 + 3^8)
05:41:11 <ertes> spatial: there is no defined order in which 2^8 and 3^8 will be evaluated
05:41:21 <ertes> the compiler is free to evaluate them in any order or even in parallel
05:41:38 <quchen_> ertes: While you’re here, I have a simple FRP question that I didn’t find a solution to. I tried writing an ASCII/console-based Snake using Reactive-Banana with a simple "ooooo" snake. 
05:41:38 <quchen_> I want to render only if the game state changes, which is periodically, given by a tick event.
05:41:38 <quchen_> The problem now is that I want, on every tick, to advance the snake, and then render the updated snake. So not both rendering and moving can depend on the tick event directly, because then we’d always render a 1-frame-earlier snake, since they’re updated simultaneously.
05:41:55 <spatial> ertes: :-) I am used to Java memory models. Sorry. My question isn't asked properly.
05:42:14 <quchen_> So reacting on one event in two dependent places is something I wasn’t able to solve.
05:42:46 <quchen_> A solution to the problem above is just making the snake an event by fmapping/accumulating the time events, and then rendering on snake events. 
05:43:00 <spatial> Compilers and core architectures realign boundaries.
05:43:22 <spatial> Data races and other races.
05:43:44 <quchen_> But that makes the problem less composable: what if I wanted to draw the snake’s head direction, "ooooo>" or "ooooov"? Then I could not create a snake event anymore, since events don’t combine (only Functor, not Applicative).
05:44:31 <ertes> quchen_: events combine, just not via Applicative
05:45:13 <quchen_> union f event1 event2?
05:45:36 <ertes> quchen_: to combine events you need to choose between intersection and union (unionWith)
05:45:45 <quchen_> But even then, should the snake not be a behavior, rather than an event? The snake is somewhere at all points in time, after all.
05:45:50 <ertes> in fact i don't see a way to take event intersections in r-b, but i may be blind
05:46:12 <quchen_> I don’t recall intersections as well there. unionWith does union, at least.
05:46:13 <ertes> quchen_: the state of the snake is a behaviour, but a change of the snake is actually an event
05:46:17 <erisco> quchen_, ertes can tell you more, but all I have to say on this is that it depends on the semantics
05:46:19 <ertes> quchen_: so it makes sense to have both
05:46:29 <ph88> what does that mean  No instance for (MonadHttp IO) arising from a use of ‘req’  in https://bpaste.net/show/5729dbed12cb
05:46:33 <erisco> quchen_, the usual choice for simultaneous events is to be left-biased
05:46:49 <ertes> spatial: you shouldn't concern yourself with low-level details like that in haskell
05:46:52 <erisco> quchen_, so if you union two events, the left events come first
05:46:53 <geekosaur> ph88, you tried to use something specific to an HTTP monad when you only have IO
05:46:54 <quchen_> ertes: Ah, is that a thing? I thought having x-change-event and x-behavior alongside each other seemed like an antipattern.
05:47:12 <ertes> quchen_: not at all…  in fact in reflex there is a separate type for that =)
05:47:15 <ertes> quchen_: called Dynamic
05:47:28 <quchen_> erisco: unionWith in Banana is parameterized over the combination function
05:47:35 <ertes> it's like a behaviour, but coupled with a change event
05:47:39 <quchen_> unionWith :: (a -> a -> a) -> Event a -> Event a -> Event a
05:47:57 <ph88> geekosaur, in the example i don't see any more code that says anything about the HTTP monad .. it's the same code in  main :: IO ()
05:48:03 <erisco> quchen_, well that leaves even more questions
05:48:09 <quchen_> ertes: Interesting. But let’s suppose we have that. What do we render when the snake updates?
05:48:21 <ertes> quchen_: the snake state behaviour
05:48:22 <quchen_> The snake behaviour? We can’t do that, since that hasn’t updated yet, has it?
05:48:26 <erisco> quchen_, so does it wait for a pair of events to arrive before combining?
05:48:41 <ertes> quchen_: let me check, if r-b supports that
05:48:54 <erisco> quchen_, the simpler union is <|>
05:48:59 <phadej> quchen_: you render a value of "behaviour", if it changes, re-render happens
05:49:22 <geekosaur> ph88, I loaded the page referenced in the paste and now I am checking if there are later versions than 0.2.0 that behave differently
05:49:34 <ertes> quchen_: as far as i can tell it doesn't, so you need to carry the new state of the snake along with the event, so you can use it in 'reactimate'
05:49:48 <geekosaur> hm apparently not
05:50:03 <erisco> this irks me about a lot of FRP-like libs out there
05:50:08 <ertes> quchen_: (it makes sense that it doesn't support that, because otherwise using MonadFix with the Moment* monads would be pretty dangerous)
05:50:11 <erisco> they'll have a function like unionWith and not indicate at all what it means
05:50:21 <erisco> it is ambiguous from the type alone
05:50:32 <ertes> erisco: that's why you read the name, too =)
05:50:43 <erisco> the name doesn't answer it for you either
05:50:58 <erisco> I can assume it is something like <|>, okay fine
05:51:15 <quchen_> Here’s an example event network of some of my clumsy snake event networks, for reference: http://lpaste.net/354056
05:51:37 <geekosaur> ph88, suggest you look at the documentation
05:51:38 <erisco> but it is not clear at all how the combining function is used i.e. what the output event is
05:52:04 <erisco> there at at least two sensible ways it could work
05:52:17 <geekosaur> ph88, look for "Examples" with a little box to the left of it, click the box
05:52:22 <erisco> one is to wait for a pair of events
05:52:27 <Juste1> exit
05:52:31 <spatial> http://lpaste.net/354055 Can playntimes complete before the following 'loop' is executed ? loop waits for the completion ?
05:52:41 <ertes> erisco: are you complaining that r-b is not exhaustively documented?
05:52:51 <erisco> not sure what r-b is
05:52:51 <ph88> geekosaur, yes those examples was what i was talking about
05:52:56 <ertes> erisco: reactive-banana
05:53:05 <geekosaur> ph88, did you see the very top of that section?
05:53:10 <geekosaur> where it talks about boilerplate?
05:53:16 <ph88> geekosaur, yes the import, i have them
05:53:19 <erisco> for functions like these? yes if it is not documented then it is a worthless function to me because I don't know what it does :P
05:53:30 <erisco> would have to boot it up in REPL and figure it out
05:53:33 <geekosaur> not just the import
05:53:44 <geekosaur> you need, in particular, the instance definition
05:53:52 <quchen_> Reactive-Banana has good function, but poor integration, documentation. Many examples in the lib’s own source are outdated as well. :-(
05:54:12 <ph88> geekosaur, i have the instance definition, i have this working in a test project  https://bpaste.net/show/678137ff3dda  still figuring out why it doesn't work in the main project
05:54:14 <ertes> erisco: you're welcome to contribute
05:54:40 <erisco> ertes, you like the passive-aggressive don't you :P
05:54:49 <ph88> ok i just :r again and it works .. don't know what was wrong .. maybe didn't safe file :/
05:55:15 <geekosaur> spatial, it's in IO so it is sequenced
05:55:22 <erisco> unionWith (,) [(t1,x1),(t3,x3)] [(t2,x2),(t4,x4)] == [((t1,x1),(t2,x2)),((t3,x3),(t4,x4))]  that is one possibility
05:55:48 <erisco> unionWith (,) [(t1,x1),(t3,x3)] [(t2,x2),(t4,x4)] == [((t1,x1),(t2,x2)),((t3,x3),(t2,x2)),((t3,x3),(t4,x4))]  is another
05:55:49 <geekosaur> (there is a hidden data dependency injected by the IO monad to ensure things happen in order. in fact, that's *all* the IO Monad instance does.)
05:55:55 <erisco> so which is it? who knows
05:56:16 <spatial> geekosaur: Let me test. I do see something wrong.
05:56:17 <ertes> erisco: only one of those is not a type error
05:56:32 <ertes> actually, no
05:56:35 <ertes> they're both type errors =)
05:56:42 <quchen_> Depends on the type of unionWith.
05:56:58 <ertes> quchen_: the one from r-b
05:57:12 <quchen_> :: (a -> a -> a) -> Event a -> Event a -> Event a
05:57:13 <erisco> this one is a -> a -> a, okay, fair, but some others are not
05:57:26 <erisco> so I'll have to be more clever if this doesn't rule out the problem
05:57:38 <quchen_> Choose (+) instead of (,)
05:57:46 <ertes> erisco: right…  now pick the least clever implementation, and that's the correct one ;)
05:57:51 <erisco> but my general complaint stands even if this example fell apart on me :P
05:58:11 <erisco> ertes, no, it isn't
05:58:19 <quchen_> I’d take a look at reflex if the docs weren’t so scary. :-(
05:58:30 <ertes> quchen_: what docs? =P
05:58:41 <quchen_> Also I’d like to understand why R-B is that limiting. Am I doing something wrong, or is the library?
05:58:45 <erisco> I might be able to be more clever and come up with an example like above, but lets go at a different property
05:58:56 <spatial> Maybe the printf statements aren't displayed properly.
05:58:56 <ertes> quchen_: the host API is severely underdocumented, but luckily you can learn it mostly from the types…  that's how i did it
05:59:04 <quchen_> ertes: The author must have liked the sessions package.
05:59:11 <ertes> quchen_: and if you have any questions, feel free to ask
05:59:46 <geekosaur> spatial, what I see is you only ever invoke loop1 when numbins is 0
05:59:52 <geekosaur> so all it does is print "Finished"
06:00:01 <ertes> quchen_: the regular FRP API should be easy enough though, and is documented to some reasonable degree
06:00:06 <erisco> ertes, (I realise I also forgot to timestamp my 2-tuple events, whoops, but it would take the latest time of course
06:00:34 <quchen_> I thought R-B was very simple. Well, it is, but failing something this fundamental makes me mad, and I’m hoping I can be mad at someone else rather than myself.
06:00:36 <geekosaur> this might be clearer if you hadn't reused the sane bindings later
06:00:44 <erisco> unionWith const [(t1,x1),(t3,x3)] [(t2,x2),(t4,x4)] == [(t1,x1),(t1,x1),(t3,x3),(t3,x3)]
06:01:11 <geekosaur> *same bindings
06:01:14 <spatial> Right. Do I have to use a copy of the bindings using let ?
06:01:18 <erisco> sorry I got that wrong
06:01:25 <ertes> quchen_: with r-b i believe carrying around the snake state with the change event is your best bet
06:01:26 <erisco> unionWith const [(t1,x1),(t3,x3)] [(t2,x2),(t4,x4)] == [(t1,x1),(t2,x1),(t3,x3),(t4,x3)]
06:01:55 <quchen_> ertes: And with reflex it’s all rainbows and unicorns, on the condition I can decypher the spell to invoke them?
06:01:59 <geekosaur> oh, hm, maybe I misread that. it is certainly confusing with the reuse :/
06:02:02 <erisco> unionWith const [(t1,x1),(t3,x3)] [(t2,x2),(t4,x4)] == [(t1,x1),(t2,x2),(t3,x3),(t4,x3)]
06:02:12 <ertes> quchen_: pretty much =)
06:02:18 <quchen_> ertes: Curses.
06:02:25 <ertes> quchen_: http://lpaste.net/159333
06:02:30 <ertes> a very simple example application
06:02:32 <erisco> I'm not making these up (except my first mistake, which doesn't make much sense)
06:02:41 <quchen_> ertes: Hooray, just what I was looking for.
06:02:49 <erisco> they're real ways I could think they merge the events, in conjunction with the combinator
06:02:52 <quchen_> Was about to ask for an example. Such as ummm Snake
06:02:59 <erisco> and I could likely come up with many more
06:03:15 <quchen_> type TickApp t m = (Reflex t, MonadHold t m, MonadSample t m) => Event t UTCTime -> m (Behavior t String)
06:03:17 <quchen_> ಠ_ಠ 
06:03:19 <ertes> quchen_: read "delayUntil 1 t" as "threadDelay 1000000" and ignore the dependency on the timelike library
06:03:55 <ertes> quchen_: for now just think of 't' selecting the reflex implementation (yes, it does support having multiple implementations)
06:04:24 <quchen_> Just like Haskell has »float« just in case someone wants to swap out the Float implementation. Oh wait. :-S
06:04:37 <quchen_> ertes: t = Spider?
06:04:41 <ertes> quchen_: a MonadHold can 'hold', a MonadSample can 'sample', that's the gist
06:04:47 <ertes> yeah
06:05:01 <quchen_> Just like MonadTrans can 'trans'.
06:05:21 <ertes> there is actually a good reason for doing that: testing…  there is a purely functional implementation that implements the semantics, and the Spider implementation is tested against that
06:05:25 <erisco> and despite both those being good guesses I wouldn't be surprised if the real unionWith did something else
06:05:32 <quchen_> ertes: Okay, good point.
06:05:40 <ertes> erisco: there is really a good semantics-related reason for having those two extra classes
06:05:56 <ertes> whoops
06:05:59 <erisco> this is just concerning Event
06:06:00 <ertes> quchen_: that was for you
06:06:07 <erisco> I get there are well-defined semantics
06:06:16 <ertes> erisco: ignore that =)
06:06:29 <erisco> the problem is that when you build on these to define more complicated functions like unionWith I don't know what you're doing
06:06:31 <ertes> quchen_: look at 'push' and 'pull'
06:06:50 <erisco> all I have is "works something like <|>" as a guess
06:07:16 <erisco> so, not a dig at any particular lib, just a general frustration I've had
06:07:32 <ertes> erisco: well, i was serious: someone has to actually write this documentation, and it's not that easy to do
06:08:08 <erisco> it is just exacerbated with FRP more than other subjects, I find
06:08:15 <erisco> i.e. the relationship between the types and semantics
06:08:43 <ertes> i think heinrich has a blog with lots of FRP-related intro material
06:08:45 <erisco> there is so much wiggle room between the two, even when adding an intuition from the function name
06:08:49 <geekosaur> spatial, ok, so I see what it's doing now. what do you see it doing wrong?
06:09:31 <quchen_> ertes: Any further simple examples you could give me?
06:09:35 <erisco> I would be interested in seeing a more sophisticatedly typed FRP where it was clear from types alone how an event merge happens, for example
06:09:49 <erisco> and there are many other properties you may want
06:09:49 <quchen_> ertes: Something to read on the bus :-)
06:10:06 <ertes> quchen_: read the API
06:10:08 <erisco> such as this event produces a bunch of X terms then one Y terms and none after
06:10:36 <ertes> quchen_: the classes Reflex, MonadSample and MonadHold are the primitive classes
06:10:49 <ertes> everything else is defined in terms of them
06:11:19 <ertes> quchen_: also you should learn the dependent-sum and (optionally) the dependent-map libraries when working with reflex
06:11:43 <ExpHP> How can I comfortably extract a multidimensional array from JSON without it looking like the spawn of sin?
06:11:54 <lpaste_> ExpHP pasted “uh-oh-json” at http://lpaste.net/354057
06:12:41 <quchen_> Dependent-sum? As in Σ types?
06:12:43 <ExpHP> notice: although I am using lenses, I am actually a complete noob who's just throwing stuff at the screen till it typechecks
06:12:50 <quchen_> Eh nevermind, that’s a pair.
06:12:50 <ertes> quchen_: almost, yeah
06:13:24 <ertes> quchen_: not full sigma, but the subset of it that haskell's GADTs and type refinement can represent
06:13:34 <quchen_> What’s a dependent sum? A dependent function is Π, a dependent pair is Σ
06:13:49 <ertes> "dependent pair" and "dependent sum" are the same thing
06:13:51 <erisco> ExpHP, you shouldn't play with magic you don't understand; you may hurt yourself
06:13:56 <quchen_> Ah, okay.
06:14:31 <erisco> ExpHP, next minute a passerby starts vomiting slugs and you've got a lawsuit
06:14:33 <ExpHP> erisco true but using Aeson itself is even scarier
06:15:09 <ExpHP> (most of Aeson is centered around the serialization/deserialization of datatypes with typeclasses, which I really would like to avoid)
06:16:00 <puregreen> ExpHP: you can perfectly use it without typeclasses, just write serializing functions by hand using `object`, `array`, etc
06:17:13 <ertes> quchen_: the dependent-map library is optional and honest a bit of a mind-bend as well as horrible to use, but luckily it's possible to avoid having to use it =)
06:18:01 <quchen> Grr, internet broke. Last thing I saw was »sum = pair« from Ertes.
06:18:09 <ertes> quchen: the dependent-map library is optional and honest a bit of a mind-bend as well as horrible to use, but luckily it's possible to avoid having to use it =)
06:18:36 <ertes> you mostly need it for efficiency reasons, but snake won't need it, so feel free to learn it as you need it
06:18:46 <erisco> I want to be told "it gets better" before I spend my time
06:19:12 <ExpHP> I can't find any examples in the Data.Aeson docs of deserializing an array.  They're all examples of objects
06:19:27 <geekosaur> a json object is either a hash or an array
06:19:56 <erisco> like Haskell, it gets better :)
06:20:34 <ExpHP> oh, hm, okay I just found some type parsing combinators in there (withArray, withNumber, etc.).  Maybe this can work...
06:21:51 <erisco> ertes, I tried writing some docs in my own code for such-like functions and it is a PITA to be precise about it
06:22:30 <ph88> how can i put the right HTTP Content-Type based on a file ?
06:23:14 <ertes> erisco: one immediate improvement is to write equations
06:23:57 <ertes> unfortunately to really specify the behaviour of 'unionWith' requires equations in terms of an observation function, which does not exist as a concrete function in the API
06:23:58 <erisco> if there was an established formality for it then it would be easier
06:24:01 <ertes> but it would be good enough as a model
06:24:14 <erisco> I did some things with diagrams
06:24:53 <ertes> observe t (unionWith f xs ys) | occurs t xs, occurs t ys = f <$> observe t xs <*> observe t ys | …
06:24:59 <ertes> something like that
06:26:19 <ertes> 'observe' exists in the semantics, but it can't be implemented for the real thing
06:29:05 <ph88> what's the haskell equivalent of https://secure.php.net/manual/en/function.mime-content-type.php  ?
06:29:22 <Booba> ertes: Is it true to state that the idea behind Tenderman datatype in http://community.haskell.org/~ertes/hangman/ is that games state represents current challenge and possible moves from that point? 
06:29:34 <erisco> this http://hackage.haskell.org/package/acme-php
06:29:38 <ertes> Booba: yes
06:29:42 <merijn> ph88: You want bindings for libmagic, I think?
06:29:46 <Booba> ertes: If so, is there a way to scale this approach to other problems?
06:29:54 <ertes> Booba: yes
06:30:02 <ph88> merijn, libmagic ?
06:30:05 <Booba> ertes: IOW, how do I identify problems that are solvable this wa?
06:30:31 <merijn> ph88: It's a C library for detecting the filetype of a file
06:30:40 <ertes> Booba: i'm running out of time, so i can't explain in depth, but the idea is: Tenderman is really a special case of a more general state machine
06:30:44 <merijn> ph88: Which, judging by the PHP docs you linked is used by PHP too
06:30:55 <ph88> merijn, doesn't neccesarily need to be a C library .. it just need to make as good a choice of MIME type as possible
06:30:56 <ertes> Booba: and there are ways to write composable abstractions for state machines
06:31:01 <erisco> or as ertes complained earlier: state machines can do everything, so they're nothing
06:31:21 <riaqn> Hi, how to represent "a series of operation on an Array"?
06:31:30 <riaqn> like State (Array i a)
06:31:36 <Booba> ertes: I see. I can imagine a state machine as some state and ways do modify it, as in challenge and move in the example.
06:31:52 <erisco> maybe an uncharitable paraphrase :P
06:31:52 <ertes> Booba: yeah, exactly
06:32:05 <ph88> merijn, on line you can also type   file -bi  my_file.txt and it will tell you   text/plain; charset=us-ascii
06:32:07 <Booba> ertes: thanks! That was really helpful!
06:32:16 <merijn> ph88: file uses libmagic
06:32:16 <quchen> riaqn: By composing functions, op3 (op2 (op1 array))
06:32:33 <erisco> <ertes> "looking like a state machine" is not a useful way to categorise
06:32:43 <quchen> riaqn: There’s also the (ST s) type for inplace updates, famously used to implement Quicksort like in C
06:32:47 <riaqn> quchen: don't know if that's what I want...
06:32:59 <quchen> I don’t know whether that’s what you want either :>
06:33:02 <erisco> well I disagreed with that and still do, let me quote the other one
06:33:02 <riaqn> quchen: yes, please tell me more about ST.
06:33:20 <erisco> <ertes> erisco: if you look close enough, this code looks like a state machine, too: [1..]
06:33:36 <quchen> (ST s) is a limited version of IO, with which you can compose impure functions (such as in-place updates) and then seal it, making the entire thing a pure computation.
06:33:36 <riaqn> more specifically, what the type for "run some computation that may modify an Array, and return a"
06:33:37 <Booba> erisco: state machine is a well-known problem, on the other hand, and it is nice to know how you could approach it in haskell
06:33:41 <erisco> yes, you can construe anything into a state machine
06:34:04 <erisco> so if you actively look for state machines it is kind of the "everything looks like a nail" mistake
06:34:35 <ExpHP> okay so apparently this is all I had to do:
06:34:36 <ExpHP> (decode "http://en.wikipedia.org/wiki/Special:Search?go=Go&search=[1,0],[0,1]],[[3,4]") :: Maybe http://en.wikipedia.org/wiki/Special:Search?go=Go&search=[Integer]
06:34:40 <ExpHP> wtf
06:34:44 <ExpHP> that is not what I copied
06:35:06 <erisco> that said, if you have a problem which naturally lends itself to being represented as a directed graph (with whatever labeling) then a state machine may be a convenient model
06:35:19 <ExpHP> (decode "http://en.wikipedia.org/wiki/Special:Search?go=Go&search=[1,0],[0,1]],[[3,4]") :: Maybe http://en.wikipedia.org/wiki/Special:Search?go=Go&search=[Integer]
06:35:29 <ertes> erisco: i think i tried hard enough to communicate my point and failed often enough
06:35:42 <ertes> so i'm not gonna respond to that particular topic anymore
06:35:44 <quchen> > runST (do {ref <- newSTRef 1; modifySTRef' ref (+1); readSTRef ref}) -- This performs an in-place mutable update on the »ref« variable.
06:35:46 <lambdabot>  2
06:35:50 <quchen> riaqn ^
06:36:01 <riaqn> quchen: but the state used has to be initialized in the ST monad? cannot pass in.
06:36:04 <ph88> merijn, do you think i'm better of with the bindings instead of using a haskell package like https://github.com/yesodweb/wai/tree/master/mime-types ?
06:36:05 <erisco> ertes, I am just sharing your points
06:36:20 <ph88> here is another potential package https://github.com/knrafto/email-header
06:36:20 <merijn> ph88: No, I just wasn't aware if that existed
06:36:29 <quchen> riaqn: (ST s) has no state that you can (or may want to) modify, no.
06:36:51 <ertes> erisco: you're misrepresenting them, and acting like a dick along the way as well…  it's irritating and a waste of time
06:36:58 <quchen> riaqn: Vector (Haskell’s array library) has modules to work with mutable arrays. It supports indexing and all the array things.
06:37:03 <quchen> And writing, in particular ;-)
06:37:05 <erisco> ertes, well that's how I understood them, sorry
06:37:14 <merijn> Lens afficionados: Is there a 'preview' which works for Applicatives?
06:37:31 <riaqn> quchen:  yeah, thanks. I want to make it more clear: I'm kind of looking for some faster alternative for (State (IArray i a) x)
06:37:43 <merijn> Basically, I have "preview (ix n) >>= \case" currently, but I would likely to replace that with something that only requires Applicative
06:38:24 <Gurkenglas_> :t preview
06:38:26 <lambdabot> MonadReader s m => Getting (First a) s a -> m (Maybe a)
06:38:48 <Gurkenglas_> You want something that looks like "(MonadReader s m, Applicative f) => Something -> m (f a)"?
06:39:27 <merijn> Gurkenglas_: I have ReaderT over an Applicative
06:39:36 <ExpHP> Okay, now that I think I've taught Konversation to behave:
06:39:45 <ExpHP> this is all I had to do: (decode "[[[1,0],[0,1]],[[3,4]]]") :: Maybe [[[Integer]]]
06:39:48 <Booba> ertes: this reminded me of https://www.infoq.com/articles/webber-rest-workflow, the way they design a REST API is similar: every response represents a current state of your order and carries possible future steps
06:40:03 * ExpHP thanks Konversation for being cooperative this time
06:40:45 <Gurkenglas_> merijn, you want something that looks like "Applicative f => Something -> ReaderT s f a"?
06:41:39 <merijn> Oh, wait, I think I know how to deal with this
06:41:41 <Gurkenglas_> *ReaderT s f (Maybe a), of course
06:42:14 <Gurkenglas_> Glad to help? :P
06:42:25 <ertes> Booba: not sure if that's really comparable (because REST is inherently mutable), but i can't read the full article right now
06:42:35 <riaqn> quchen: thanks.. I think it's just (MArray a e m) => m x
06:43:30 <quchen> λ. V.modify (\vec -> do { a <- VM.read vec  1; b <- VM.read vec 0; VM.write vec 1 b; VM.write vec 0 a }) (V.fromList [1..10])
06:43:47 <quchen> riaqn: That swaps the first two elements of a (mutable) vector inplace.
06:43:50 <merijn> Gurkenglas_: No, I have Validation atm, but it should be possible to convert the Maybe from preview to Validation
06:44:06 <riaqn> quchen: thanks! new stuff learned.
06:44:07 <erisco> Booba, yes it is loosely similar to that
06:44:22 <quchen> riaqn: Array is a bit outdated, I suggest you give Vector a look.
06:44:33 <quchen> But it supports mutable updates as well.
06:44:41 <riaqn> quchen: OK! I will try that.
06:44:59 <quchen> Vector’s modify is pretty much the only function I’ve ever needed ;-)
06:45:08 <erisco> the mutable part of REST is not relevant if we're just talking about a transaction, i.e. something that may lead to a mutation but isn't mutating along the way
06:46:37 <riaqn> quchen: wow, vector seems much more complicated than  Array
06:46:55 <quchen> Really? I think it just has a much richer API. I find it easier to use.
06:46:55 <fendor> no, it is actually quite simple
06:47:09 <riaqn> Is it just an advanced version of Array with more batteries?
06:47:22 <quchen> Yup.
06:47:29 <fendor> riaqn, disagree with this one, since you can only access via int
06:47:38 <erisco> that just means it is power-inefficient
06:47:59 <fendor> but useful
06:48:02 <erisco> vector does give up the parametric indices
06:48:20 <riaqn> ahh, that's not nice.
06:48:21 <erisco> or polymorphic indices, or whatever word is appropriate =\
06:48:40 <quchen> You can use Ix to index a Vector as well.
06:48:41 <riaqn> guess because the implementation utilize some machine optimization?
06:48:46 <fendor> and nested vector dont look nice
06:48:50 <riaqn> so it has to be the machine Int.
06:49:08 <fendor> riaqn, the implementations uses fusion, and can chain several operations into one
06:49:16 <fendor> this is highly optimized
06:49:18 <merijn> Gurkenglas_: Gah, not quite >.< just "preview (ix n)" has my applicative type, so I don't think I can do it >.<
06:49:40 <riaqn> fendor: hmm.. guess for now I will just use Array.
06:49:57 <riaqn> loss of parametricity of Index is not nice.
06:50:12 <fendor> riaqn, it's slower, if you need performance, vector is the right choice
06:50:25 <merijn> Gurkenglas_: Since if I have "ReaderT (Map k v) (Validation e) a" preview produces that type and I can't convert the Maybe, I think
06:50:33 <riaqn> yeah, understand that.
06:50:45 <riaqn> I will see if I need more performance.
06:50:49 <erisco> heck, if you don't care about performance just use a list ^.^
06:51:05 <fendor> riaqn, yes, it should be rather easy to convert the code
06:51:16 <merijn> Or, it might be possible, but not using preview, I need something else
06:51:19 <fendor> erisco, he wants the polymorphic access ^^
06:51:30 <riaqn> well.. MArray to list is not the same complexity when it comes to random access and modification.
06:51:33 <quchen> > Data.Ix.index ((1,1),(4,4)) (2,3) -- The index of (2,3) in coordinates (1..4, 1..4).
06:51:35 <lambdabot>  6
06:51:39 <quchen> Tadaa, non-linear indexing.
06:51:41 <riaqn> but Array and Vector, should be on the same level.
06:52:02 <riaqn> I mean, the big-O notation.
06:52:26 <quchen> Up to a constant that can be greater than the lifetime of the universe in nanoseconds, their performance is equal, exactly.
06:52:35 <fendor> riaqn, vector can optimize certain operations. For example, several map are just fused into one. More efficiently than with normal laziness
06:53:18 <erisco> quchen, shh, how dare you attack the pragmatism of asymptotics!
06:53:50 <riaqn> fendor: so you mean in some cases the optimization factor is unbound?
06:53:50 * quchen has never never seen an asymptotic value so I don’t believe in their usefulness in practice
06:57:35 <fendor> riaqn, well no, the complexity remains, but in practice, the performance can be greatly improved
06:58:27 <fendor> riaqn, from O(4*n) to O(n)
06:58:53 <fendor> for exmaple
06:59:01 <erisco> that's strange, I read the same thing twice there
07:00:21 <quchen> That’s a factor four improvement! It’s not much less linear asymptotically.
07:00:28 <quchen> s/not/now/
07:02:15 <merijn> quchen: Reduction from O(4*n) to O(n) *is* asymptotically better
07:03:00 <quchen> Yes, the first one is more linear.
07:03:10 <opqdonut> merijn: false, O(4*n) = O(n)
07:03:11 <quchen> »Linearer«, in mathematical terms.
07:03:20 <quchen> It’s like linear, but more so.
07:03:33 <quchen> OK I’ll stop ;-)
07:03:51 <merijn> quchen: Prepare to be schooled: "A function 'f' is asymptotically better than a function 'g' if there exist an a value X, such that for every value y >= X, f(X) is better than g(X)"
07:04:20 <opqdonut> merijn: reduction of running time from O(n) to n+o(n) can be thought of as asymptotically better, however
07:04:20 <quchen> I thought I had just seen a big-O there. I must have misread.
07:04:38 <merijn> A function that is 4n vs n is trivially asymptotically better
07:04:50 <opqdonut> merijn: or from 4f(n) to f(n), of course
07:04:52 <merijn> The big O is wrong, yes
07:05:04 <quchen> Functions aren’t 4n. Functions can be element of O(4*n). And iff they are, they are also element of O(n).
07:05:09 <merijn> i.e. O(4*n) is indeed equivalent to O(n)
07:05:14 <riaqn> fendor: OK I see.
07:05:30 <merijn> quchen: But reducing a function from 4 traversals to 1 *is* asymptotically better
07:05:55 <merijn> quchen: Since if it's better for ALL inputs, it's trivially the case that it's better for all inputs >X for some value X
07:06:13 <merijn> People seem to always assume "asymptotically" == change in O class
07:06:31 <merijn> Functions in the same O class can still be asymptotically better
07:06:40 <quchen> We talked about »O«, so I seemed to assume we talked about O classes.
07:07:07 <kuribas> isn't O simply an upper bound?
07:07:12 <merijn> quchen: Well, it's clear that if someone writes O(4*n) their use of O() is garbled, but still understandable
07:07:15 <kuribas> not the lowest upper bound?
07:07:22 <erisco> if I could remember the course it was in I would drag out my notes on the formalisation
07:07:26 <merijn> kuribas: Lower bound
07:07:29 <erisco> but I am sure it varies slightly depending on who you ask =\
07:07:42 <merijn> kuribas: Eh, no upper bound :)
07:07:44 <fendor> guys, youre overreacting :D 
07:07:45 <merijn> you're right
07:07:50 <fendor> *guys and girls
07:08:07 <merijn> erisco: Well, there's actually correct definitions. And various wrong ones found on the internet :)
07:08:23 * quchen now starts measuring voltage in apere because it’s garbled, but still understandable.
07:08:48 <kuribas> fendor: it's a mathematical construct.  If you use it wrongly it becomes meaningless.
07:09:00 <merijn> erisco: If you wanna be factually correct, I recommend grabbing a copy of CLSR
07:09:11 <merijn> @where CLSR --does this exist?
07:09:11 <lambdabot> I know nothing about clsr.
07:09:13 <erisco> merijn, or I can just grab my course notes like I said
07:09:13 <merijn> hmmm
07:09:35 <fendor> kuribas, *sigh* i'm aware that this was not the right notation, it was to explain an example in short
07:09:41 <dolio> CLRS?
07:10:07 <mfukar> saying a f(n) is O(n) and O(4*n) can be technically correct, but only one of those statements is useful
07:10:20 <merijn> dolio: Introduction to Algorithms by Cormen, Leiserson, Rivest, and Stein
07:10:45 <dolio> Right, you had the S and R transposed, though. Although I doubt CLRS is in lambdabot, either.
07:10:55 <merijn> mfukar: Well, no, "O(4*n)" is patently absurd as you cannot have constants in big O notation
07:11:05 <merijn> dolio: Damn, I even googled to check >.>
07:11:16 <merijn> oh, google auto corrected :)
07:11:27 <merijn> Bastards
07:11:28 <mfukar> you have functions. g(n) = c*n is a function.
07:11:45 <dolio> Google lists the authors LSRC, even when you search for CLRS.
07:12:49 <erisco> merijn, I don't actually recall any syntactical issue with O(4*n)
07:12:54 <erisco> merijn, it just washes out the same as O(n)
07:13:11 <fendor> merijn, you can say O(4*n) but normally no one uses it, since it has the same meaning as O(n)
07:13:49 <erisco> you're just sticking any ol' function in there
07:13:53 <fendor> my initial usage was indeed wrong, i should ve used theta(4*n) reduced to theta(n)
07:14:36 <kuribas> O isn't a measure of performance, but of scalability
07:14:55 <fendor> O is a measure of algorithmic complexity
07:15:26 <erisco> kuribas, it is just to be pointed out that the benefits of that scalability may not be observable
07:15:29 <fendor> therefore also for scalability, with inherit impacts on performance
07:16:07 <kuribas> erisco: right, and it depends on the variables used.
07:18:39 <erisco> are there algorithms which become faster the larger the input? hm
07:19:03 <fendor> relatively, yes
07:19:16 <fendor> compared to others
07:19:44 <erisco> I just mean it is somewhat curious that cost functions are monotonically increasing to input size
07:20:13 <erisco> seems obvious but at the same time what is the absurdity of otherwise? I am not so sure
07:20:15 <fendor> well, if you use theta notation, yes, there are functions that get faster
07:23:27 <Gurkenglas_> There are no functions with strictly monotonically decreasing runtime, because you need time to find out how large the input is
07:23:59 <Gurkenglas_> If you don't, you can't act differently for large inputs and larger inputs
07:24:24 <erisco> that seems on track for an answer, but determining the exact size of input is not necessary for all algorithms
07:24:52 <mniip> then you have to detach from the turing machine computation model
07:25:24 <Gurkenglas_> No, there are turing machines that don't look at the size of the input. They just act identically for all inputs with some prefix.
07:25:34 <mniip> that's not useful
07:25:37 <erisco> I mean, for example, binary search
07:25:55 <mniip> yeah, a pointer machine can actually execute sublinear algorithms
07:25:57 <mniip> unlike TM
07:26:13 <Gurkenglas_> It's not useful, but the uselessness of that is a theorem, and that runtimes arent monotonically decreasing follows from that theorem
07:26:37 <mniip> then you need to correct your theorem
07:26:39 <erisco> and the truth seems stronger than monotonically decreasing
07:26:46 <erisco> as I said, it seems to be exclusively monotonically increases
07:26:48 <Gurkenglas_> How does a pointer machine execute sublinear algorithms?
07:26:50 <mniip> There are no functions with strictly monotonically decreasing TM runtime
07:27:15 <mniip> erisco, there are O(1) languages
07:27:25 <mniip> the language of all words, or a finite language
07:27:33 <erisco> that qualifies as monotonically increasing though
07:27:44 <mniip> non-strictly
07:27:50 <erisco> sure
07:27:51 <Gurkenglas_> erisco, an algorithm can take O(n!) time for even n and O(2^n) for odd n
07:27:53 <mniip> also no
07:28:06 <mniip> I'm sure I can come up with an algorithm that goes in a zigzagwise pattern
07:28:24 <mniip> not contrived one too
07:28:47 <erisco> mniip, your "no" is to what?
07:29:01 <mniip> there are non-monotonic algorithms
07:29:22 <Gurkenglas_> Just take that thing where you try to bruteforce whether "even numbers get halved, odd n get 3n+1'd, iterate until at 1" lands at 1. Very zigzaggy.
07:29:22 <erisco> well I think Gurkenglas_ gave a simple one
07:29:40 <erisco> though I'd restate it as True does one algo and False another
07:29:50 <erisco> switch between bogo and merge sort, for example
07:30:09 <erisco> well I guess the Nat is necessary so you can talk about increasing input sizes
07:30:38 <erisco> though maybe something is off if we're just concerned about the evenness or oddness of the number
07:30:50 <erisco> that is what made me reduce to bool
07:31:18 <Gurkenglas_> Actually the argument against strictly monotonically decreasing runtimes is that there are no strictly monotonically decreasing infinite natural sequences. :s
07:31:21 <erisco> Gurkenglas_, Collatz Conjecture
07:32:23 <Gurkenglas_> erisco, sure, but that's not proven, and the bruteforce thingy would disprove it for some n if it's false :P
07:32:41 <erisco> I didn't say it was true oO
07:32:55 <Gurkenglas_> Then whatfor the namedrop?
07:33:09 <erisco> you called it "that thing"
07:33:52 <Gurkenglas_> Coz the reader might not know that name so I just described it in a line or so so ppl dont have to go google to follow the conversation
07:34:46 <erisco> well I rarely know the name of something so I couldn't resist
07:35:38 <erisco> so with an absolute cost I can see quite simply how it may not be monotonically increasing
07:35:50 <erisco> those are good examples
07:36:05 <erisco> then the interesting case is strictly monotonically decreasing as you said
07:38:01 <erisco> Gurkenglas_, ah, I see, because the absurdity is that whatever the initial cost is, by increasing the size of input you reach the contradiction of infinite descent
07:55:52 <teto> is there a way to have a local hoogle return the docstring associated with the search (instead of just the function signature) ?
07:56:35 <dogukan> hi
07:59:02 <dogukan> i am trying to write a function that finds all sub-lists of a given list with two elements, for example, if i give [1,2,3,4,5] to this function, i want to see [[1,2],[1,3],[1,4],[1,5],[2,3],[2,4],[2,5],[3,4],[3,5],[4,5]] as output
07:59:17 <dogukan> i wrote this function subset list = [[x,y] | x <- list, y <- list, x /= y]
07:59:36 <dogukan> but this gives for example both [1,2] and [2,1]
08:00:00 <dogukan> output of my function is [[1,2],[1,3],[1,4],[1,5],[2,1],[2,3],[2,4],[2,5],[3,1],[3,2],[3,4],[3,5],[4,1],[4,2],[4,3],[4,5],[5,1],[5,2],[5,3],[5,4]]
08:00:26 <dogukan> how can i eliminate those unnecessary lists?
08:01:10 <lyxia> don't pick x and y independently.
08:01:26 <lyxia> when you pick x, also get the possible associated y at the same time
08:02:10 <lyxia> > let list = [1..4] in [[x, y] | x : ys <- list, y <- ys]
08:02:12 <lambdabot>  error:
08:02:12 <lambdabot>      • Ambiguous type variable ‘t0’ arising from a use of ‘show_M114171945873...
08:02:12 <lambdabot>        prevents the constraint ‘(Show t0)’ from being solved.
08:02:21 <lyxia> > let list = [1..4 :: Int] in [[x, y] | x : ys <- list, y <- ys]
08:02:24 <lambdabot>  error:
08:02:24 <lambdabot>      • Couldn't match expected type ‘Int’ with actual type ‘[t]’
08:02:24 <lambdabot>      • In the pattern: x : ys
08:02:37 <lyxia> > let list = [1..4 :: Int] in [[x, y] | x : ys <- tails list, y <- ys]
08:02:39 <lambdabot>  [[1,2],[1,3],[1,4],[2,3],[2,4],[3,4]]
08:02:43 <lyxia> phew
08:03:06 <dogukan> oh i liked this bot
08:04:01 <lyxia> Do you not like it anymore?
08:04:45 <dogukan> lol :D i mean this is my first time on this channel and i am impressed with this bot now
08:05:19 <lyxia> jk
08:08:04 <dogukan> lyxia: when i try to run your code, hugs gives "ERROR - Undefined variable "tails"", i am a complete beginner so excuse me if this is a dump problem :D
08:08:36 <geekosaur> @index tails
08:08:36 <lambdabot> GHC.OldList, Data.List, Data.ByteString.Lazy, Data.ByteString.Lazy.Char8, Data.ByteString, Data.ByteString.Char8, Data.Sequence
08:08:55 <geekosaur> you need to import Data.List
08:09:01 <dogukan> oh ok than
08:10:42 <bob_> Hello
08:17:57 <dogukan> @index in
08:17:57 <lambdabot> bzzt
08:18:01 <dogukan> :D
08:18:41 <geekosaur> it's syntax. let {<bindings>} in <expression>
08:19:44 <dogukan> hugs says Syntax error in input (unexpected keyword "in") so tried my chance :P
08:23:42 <dogukan> oh i saw my stupid erros and understood the syntax
08:23:51 <dogukan> thank you everynone
08:24:13 <Myrl-saki> What does Wadler mean about fix? http://ttic.uchicago.edu/~dreyer/course/papers/wadler.pdf
08:26:26 <lyxia> Myrl-saki: is there something more specific you don't understand
08:37:48 <_sras_> I was trying to integrate swagger with my Webapplication in Servant while I get this error http://lpaste.net/2307787169109901312
08:38:24 <_sras_> Any idea what I might be doing wrong?
08:38:51 <fizruk> _sras_: see https://github.com/GetShopTV/swagger2/issues/86
08:41:42 <_sras_> fizruk: Thanks.
08:42:10 <kostja> Hello! I have two local projects A and B, where B depends on A. If I want to load a file from B in ghci, I get the error "Failed to load interface for ... perhaps you haven't installed the dyn libraries for package ..."
08:43:03 <kostja> (I am using nix and Gonzales haskell-nix approach to introduce B to A)
08:51:41 <bollu> cocreature: ping
08:51:47 <cocreature> bollu: pong
08:51:50 <bollu> I need help getting llvm-general running with Stack
08:51:56 <cocreature> bollu: use llvm-hs :P
08:51:57 <bollu> cocreature: also, were you at euroLLVM?
08:52:00 <bollu> cocreature: :P
08:52:05 <cocreature> nope I didn’t have time
08:52:06 <bollu> cocreature: does it have JIT?
08:52:19 <bollu> cocreature: ah, dang. I was hoping to have run into you without knowing it :)
08:52:31 <cocreature> bollu: I’m only half kidding, llvm-general is pretty much dead. just look at the commits. there is a reason we created a fork
08:52:48 <bollu> cocreature: I asked around quite a bit about STG -> haskell. there was a cool talk where they did Java -> LLVM
08:53:13 <cocreature> bollu: stg -> haskell? why would you want to transform stg to haskell?
08:53:21 <bollu> cocreature: we really should talk about this in depth sometime. I'm trying to understand STG fully by doing this: http://github.com/bollu/simplexhc
08:53:25 <bollu> cocreature: STG -> LLVM*
08:53:31 <cocreature> bollu: ah that makes a lot more sense :)
08:53:51 <cocreature> bollu: going back to your question: what problems are you encountering with llvm-general?
08:54:17 <bollu> cocreature: "stack build" does not work out of the box xD I didn't check what is going wrong, hoping you would know
08:54:31 <cocreature> bollu: which branch are you using?
08:54:45 <bollu> cocreature: llvm-general? whatever is on Hackage, I assume
08:54:53 <bollu> cocreature: let me use llvm-hs
08:55:11 <cocreature> bollu: that’s ancient. if you really want to stick to llvm-general at least use the 3.8 or 3.9 branch
08:55:20 <bollu> cocreature: I see
08:55:40 <cocreature> bollu: the first thing is to make sure you are actually using the right LLVM version
08:56:07 <bollu> cocreature: I am on the latest. I run nightly
08:56:25 <bollu> cocreature: is that "too new"?
08:56:45 <cocreature> bollu: yep. llvm-general requires 3.5, llvm-hs requires 4.0
08:57:06 <cocreature> bollu: llvm breaks their API all the time, so there is no way to support multiple versions in one version of the Haskell bindings
08:57:11 <bollu> cocreature: I see
08:57:23 <bollu> cocreature: is there a way to "sandbox" the older llvm only for llvm-hs?
08:57:32 <bollu> cocreature: I really need to run the nightlies for my work stuff
08:57:43 <cocreature> bollu: which os?
08:57:47 <bollu> cocreature: mac os
08:57:51 <geekosaur> build llvm yourself in some nonstandard location?
08:58:08 <bollu> geekosaur: yes, I suppose
08:58:10 <cocreature> just use CMAKE_INSTALL_PREFIX
08:58:15 <bollu> cocreature: ah, OK
08:58:17 <cocreature> and then set PATH appropriately
08:58:36 <bollu> cocreature: so I will need to change $PATH when I am working on this? bummer
08:58:47 <bollu> cocreature: or wait, this is only once for linking?
08:59:36 <cocreature> bollu: only for building & linking llvm-hs/llvm-general
08:59:44 <bollu> cocreature: ah OK
08:59:57 <cocreature> bollu: they look at the output of llvm-config to figure out where your llvm installation lives
09:00:09 <cocreature> bollu: so llvm-config needs to resolve to the right version
09:00:36 <sophiag> is there a library that provides data types for storing lambda expressions? i'm thinking something similar to quoting in lisps and then you could provide the specific type signature when actually applying them in functions.
09:00:45 <cocreature> bollu: fwiw I use those flags to build & install llvm in a custom directory http://sprunge.us/CgjA
09:01:42 <bollu> cocreature: ty
09:02:06 <bollu> cocreature: I am trying to find the correct commit number for llvm 4.0
09:02:12 <bollu> cocreature: any idea where I can find it?
09:02:41 <cocreature> bollu: just download the tarball from the website?
09:03:03 <bollu> cocreature: eh, I suppose.
09:04:25 <cocreature> bollu: I think there is also a release_40 branch in their repo
09:05:20 <bollu> cocreature: cool, thanks :)
09:05:52 <cocreature> bollu: btw what kind of work are you doing that requires nightly llvm?
09:06:44 <bollu> cocreature: I work on Polly
09:06:48 <bollu> cocreature: I recently started :)
09:06:49 <cocreature> oh cool
09:32:37 <tobiasBora> Hello,
09:32:44 <tobiasBora> I've two questions:
09:33:18 <tobiasBora> 1) Between Parser and Regexp, which one is the fastest (or what are the advantages of one over the other)
09:33:52 <tobiasBora> 2) I'm trying to use Parsec to find an email in a text, but I'm having some difficulties
09:34:56 <tobiasBora> For example
09:35:08 <tobiasBora> how could I concatenate two Parser String ?
09:35:18 <tobiasBora> for now I write something like:
09:36:28 <tobiasBora> parseEmailOnly = do {localPart `manyTill` string "@"; many domainPart}
09:36:42 <tobiasBora> with:
09:36:44 <tobiasBora> localPart = satisfy (\c -> isAlphaNum c || c `elem` ".!#$%&'*+-/=?^_`{|}~")
09:36:50 <tobiasBora> domainPart = satisfy (\c -> isAlphaNum c || c `elem` ".-")
09:37:14 <tobiasBora> The thing is that when I do:
09:37:21 <tobiasBora> email <- parseEmailOnly
09:37:22 <cocreature> tobiasBora: you can parse more languages with Parser than you can parse with regex. if regex are sufficient for your application, then I would expect them to be faster but that depends on the exact implementations you’re using
09:37:31 <tobiasBora> I just have the last part "gmail.com"
09:37:57 <Geekingfrog> tobiasBora: because in your parseEmailOnly, only the last parser will be used for the result
09:38:16 <tobiasBora> Geekingfrog: Yes, I understand why, but I don't see how "concatenate" the parser
09:38:41 <Geekingfrog> tobiasBora: a correct version would be: parseEmailOnly = do {local <- localPart; domain <- domainPart; pure (local ++ domain)}
09:39:00 <Geekingfrog> This way you're not discarding the result of the first parser
09:41:21 <tobiasBora> Geekingfrog: I though to this solution but I though it was dirty... Because if I've to many lines, it becomes something like (a ++ b ++ c ++ d ++ e)... Well maybe I could use list concat & monad do deal with that...
09:42:52 <_sras_> How does generics work in Haskell, or what actually happens when I add `deriving (Generic)` at the end of a data type def?
09:43:10 <Squarism> +1
09:43:14 <Geekingfrog> tobiasBora: I usually go first for something which works, and then refine it. concat [a, b, c, d, e] would be a first step indeed.
09:43:38 <tobiasBora> Geekingfrog: Yes sure
09:43:48 <lyxia> _sras_: an instance of Generic is derived, and you can look at it using the -ddump-deriv option
09:44:44 <tobiasBora> Well, now that we have a working version parseEmailOnly
09:45:19 <tobiasBora> I have problems to look for that in the whole text, because many1 seems to be greedy:
09:45:32 <tobiasBora> For now I've something like:
09:45:34 <tobiasBora> many anyChar
09:45:36 <tobiasBora>           email <- parseEmailOnly
09:45:38 <tobiasBora>           many anyChar
09:45:40 <tobiasBora>           eof
09:45:42 <tobiasBora>           return email
09:45:44 <tobiasBora> (forgot the bad indentation)
09:45:50 <Geekingfrog> yeah, many anyChar will eat everything
09:46:23 <tobiasBora> Geekingfrog: Yeah that's the problem. I tought to use something like try, but not sure it's the good way to proceed.
09:47:10 <cocreature> _sras_: basically Generic is just a way to convert a type from & to a representation made up of the types listed at the top of GHC.Generics
09:47:14 <erisco> hrm
09:47:19 <erisco> are bounded arrays not possible with SBV?
09:47:44 <cocreature> erisco: I don’t know about sbv but SMT does not support them so that seems likely
09:47:49 <robkennedy> Is there a way to force fromString to fire at compile time?
09:47:52 <erisco> I see, strange
09:48:13 <cocreature> erisco: usually you work around this by constraining your indices to a fixed range
09:48:24 <erisco> yes that is an option I can use
09:49:30 <cocreature> erisco: I guess if your length is a power of two you could also constraint your index type
09:50:14 <cocreature> erisco: the thing is SMT arrays are really just total functions with the index sort being the domain
09:51:57 <tobiasBora> Geekingfrog: I found this solution that seems to work
09:51:59 <tobiasBora> http://stackoverflow.com/questions/29549435/parsec-how-to-find-matches-within-a-string
09:53:33 <_sras_> cocreature: Is it feasible to write a generic instance for a type, manually?
09:54:16 <Geekingfrog> tobiasBora: that's neat.
09:54:55 <tobiasBora> Geekingfrog: I'll try to do some benchmark to see how fast it is compared with regexp. But anyway, thank you for your help!
09:55:38 <cocreature> _sras_: yes the haddock show how to do that
09:55:48 <cocreature> _sras_: but I don’t know of any reason why you would want to do this
09:55:51 <erisco> cocreature, little confused as to why something like mkSymArray isn't in the lib
09:55:52 <erisco> http://lpaste.net/354067
09:56:16 <erisco> the offered API is a bit strange... really bare bones
09:56:30 <erisco> whereas other facilities are more high level
09:56:48 <Geekingfrog> tobiasBora: you can probably have a more aggressive version than the one in the SO answer, where if the email parser fails, you can skip the whole word (manyTill spaceChar)
09:56:52 <_sras_> cocreature: Need to derive generic instance for a record in which one of the field is a type from an external lib.
09:59:15 <cocreature> _sras_: use standalon deriving
09:59:51 <erisco> mkSymArray @SArray @Word8 [10,20,30]   seems kind of obvious *shrug*
09:59:58 <lyxia> _sras_: The derived Generic representation should work with any type of field
10:11:11 <erisco> cocreature, this will do splendidly... it doesn't support existential arrays but it does support existential indices
10:11:20 <erisco> and I can figure out how to encode my problem that way... at least now I can
10:11:31 <erisco> spent a lot of hours chasing another approach that got too complicated
10:12:39 <erisco> I need to know which propositions satisfy a particular hole
10:13:15 <erisco> thankfully I have a finite list of candidates
10:16:36 <reactormonk> cocreature, _ is pretty helpful, thanks!
10:17:02 <cocreature> reactormonk: yep it’s great! I use it all the time
10:18:04 <Myrl-saki> lyxia: Sorry late reply. I don't understand what he means by "cannot be defined as a term in these systems."
10:20:38 <lyxia> Myrl-saki: You can't write a well-typed lambda term with the type of fix in system F (Girard/Reynold's system).
10:20:41 <shapr> Sometimes I wish I could use type holes in verbal discussions.
10:21:11 <byorgey> shapr: verbal discussions about types?  Or do you mean more metaphorically? =)
10:21:17 <shapr> more metaphorically
10:21:31 <shapr> Mostly when discussing requirements
10:21:56 <shapr> Something like "I need you to fill in this hole with your own information"
10:22:19 <byorgey> I mean, English kind of *does* have type holes.  They are called "pronouns". =)
10:22:23 <byorgey> I see what you mean though.
10:22:42 <shapr> I think lojban has explicit type holes, with mo and ma
10:23:22 <shapr> byorgey: hm, that's a good point
10:23:43 <Myrl-saki> lyxia: I guess that means Haskell isn't System F, what is it then?
10:24:34 <shapr> I always think of type holes as a way of asking GHC questions about my code.
10:24:57 <shapr> So lojban's mo and ma are closest how I use type holes.
10:25:12 <lyxia> Myrl-saki: You can probably get pretty close with system F + fix + data types.
10:25:29 <lyxia> It's probably best to think of Haskell as Haskell though.
10:25:43 <dolio> F doesn't even have all the higher kinds.
10:25:48 <dolio> Just *.
10:26:08 <byorgey> it's like System F omega + fix + data types + type equality constraints.  or something.
10:26:16 <dolio> But Haskell doesn't have all the higher ranks of F without extensions.
10:26:26 <byorgey> ah, true
10:29:19 <dolio> If you have all the ranks, you don't exactly need to add data types, either, because they can be encoded.
10:29:35 <dolio> Depending on whether you consider encodings good enough.
10:30:21 <dolio> Or, I guess having all the ranks doesn't matter. But you have to be impredicative like F and F omega are usually specified to be.
10:31:13 <dolio> They're both important.
10:35:15 <danza> sorry ... the Hackage upload form uses HTTP for username and password?
10:36:43 <byorgey> I thought it uses HTTPS?
10:37:36 <glguy> Yeah, you should use HTTPS  when connecting to it to upload, but you don't have to.
10:38:46 <danza> oh, i see ... thanks +1
10:42:18 <danza> this is also interesting https://github.com/haskell/hackage-server/blob/master/Distribution/Server/Packages/Unpack.hs#L313 ... how are these names decided? And how can i find the top level node my logic belongs to?
10:43:35 <serses> describeLoser user = if user == 'Haskell user' then 'loser' else then 'Not loser' 
10:44:22 <mauke> that's a syntax error
10:45:08 <serses> only a loser would know 
10:45:33 --- mode: ChanServ set +q *!*@46.214.237.86
10:45:53 <mauke> or a compiler
10:46:08 <mauke> there's also a grammar error and a naming error
10:51:30 <danza> regarding my question above, i found a nice reference https://wiki.haskell.org/Hierarchical_module_names
10:53:21 <reactormonk> The eff paper mentions "the (abstract) type Union (r :: [* -> *]) x where the first argument r is a type-level list of effect labels" - how do I write that in haskell?
10:53:29 <reactormonk> that, as in the type Union
10:54:06 <Gurkenglas_> Dont forget the semantic error!
10:55:31 <sophiag> i couldn't find a library that provides a data type for storing lambdas (for similar purposes to quote in lisps) so figure i'll write one myself. given that, i'm wondering how to represent operators in an adt?
10:56:03 <sophiag> i figured i could do something like (Symbol "+"), but that doesn't seem to be correct
10:56:19 <byorgey> sophiag: what do you mean "storing lambdas"?  What do you want to do with the stored lambdas?
10:56:45 <Sonolin> sophiag do you mean like the Endo type?
10:56:49 <sophiag> byorgey: as mentioned, similar to quoting them in lisps
10:57:28 <byorgey> sophiag: can you be more specific?  For what purpose would you quote lambdas in lisps?
10:57:58 <sophiag> so you can store them as data and then unquote them to apply
10:58:01 <reactormonk> sophiag, you could store the underlying system-F, but then you'd need a ghc along to compile it once you load it again
10:58:13 <byorgey> sophiag: Haskell has first-class functions, so you can just store functions in a data type.  You don't need to quote them.
10:58:48 <sophiag> reactormonk: i'm doing this basically to avoid having to do that
10:59:03 <byorgey> > :type [\x -> x + 1, \x -> x*3 + 19, \x -> 2] :: [Int -> Int]    -- a list of functions
10:59:05 <lambdabot>  <hint>:1:1: error: parse error on input ‘:’
10:59:19 <reactormonk> sophiag, you'll need some runtime anyway, unless you wanna go implement your own language with Free or similar
10:59:19 <byorgey> @type [\x -> x + 1, \x -> x*3 + 19, \x -> 2] :: [Int -> Int]    -- a list of functions
10:59:20 <lambdabot> [Int -> Int]
11:00:44 <sophiag> oh, so i can just define a list of functions by using their type signature?
11:00:48 <byorgey> > let myFuns = [\x -> x + 1, \x -> x*3 + 19, \x -> 2] in  map (\f -> f 3) myFuns   -- apply all the functions to the input 3
11:00:50 <lambdabot>  [4,28,2]
11:01:01 <byorgey> you don't even need a type signature, I just included that for illustrative purposes
11:01:13 <byorgey> but using the type signature is probably a good idea.
11:01:33 <sophiag> uh...well otherwise i have no way to define the list
11:02:24 <byorgey> I'm not sure what you mean.  That's not true.  See my example above where I made a list of functions and then applied them all to 3.  There are no type signatures.
11:03:00 <sophiag> data Lambdas = [it's cool don't need anything here]
11:03:08 <sophiag> ^ i imagine that wouldn't work
11:03:23 <byorgey> sophiag: perhaps you mean by using their definitions?  The things that go in the brackets are not type signatures.
11:03:32 <Sonolin> yea type signatures in haskell are mostly optional, and let you specify a specific type
11:03:38 <byorgey> a type signature would be something like  Int -> Int.  What goes in the brackets is something like  \x -> x + 2
11:03:55 <sophiag> so i can have a list of functions with different type signatures?
11:03:59 <lyxia> reactormonk: you can write it as a data family.
11:04:09 <byorgey> sophiag: no, all the elements of a list must be the same type.
11:04:43 <byorgey> now you are going to tell me that you want to have a list of functions with different type signatures.  And I am going to ask you what on earth you would do with such a list if you had it.
11:04:59 <sophiag> no i didn't say that
11:05:03 <byorgey> ok good =)
11:05:09 <Sonolin> sophiag: you can get away with it sometimes using clever "forall", but really you're just limiting what you can do with the resulting functions
11:05:21 <byorgey> I have to go teach a class, but hopefully others can continue to help
11:05:25 <sophiag> YOU said i can define a type of lambdas without specifying their type signature
11:05:28 <sophiag> how would i do that?
11:05:45 <sophiag> data Lambdas = Lambdas [what goes here] 
11:06:13 <Sonolin> well you would have to put a type definition there
11:06:28 <Sonolin> I think he means dynamically declaring lists of functions do *not* need type signatures
11:06:34 <sophiag> Sonolin: you just said it wasn't necessary (twice)
11:06:47 <Myrl-saki> lyxia: Ah. Thanks.
11:09:26 <Sonolin> a type isn't optional when you declare a variable, but it is required when you declare a type (to my knowledge at least)
11:09:35 <Sonolin> *is optional when you declare a variable
11:09:59 <Sonolin> you could do something like this though
11:10:19 <Sonolin> data Lambdas a = Lambdas [a -> a]
11:10:49 <sophiag> hmm ok. i was fine specifying the type 
11:11:00 <sophiag> just asking you to clarify why you repeatedly said that wasn't necessary
11:11:18 <monochrom> I think you are confusing "define a user-defined type" with "give a type annotation".
11:11:36 <Sonolin> sorry, I misunderstood - didn't see the part about you specifically declaring a datatype
11:14:39 <sophiag> Sonolin: it's cool. i liked your idea to use a type variable.
11:15:07 <sophiag> i'm wondering how to use datatypes with arguments in records though?
11:15:59 <sophiag> like if i have "Lambda a = Lambda [a -> Bool]" how to do define the variable in a record?
11:16:34 <monochrom> I don't understand the question. What record do you have in mind?
11:17:14 <sophiag> something like "Foo = Foo { tag :: Maybe String, lambda :: Lambda * }"
11:17:48 <monochrom> OK, data Foo = Foo { tag :: Maybe String, lambda :: Lambda Int }. If you want Int there.
11:17:53 <_sras_> I am trying to use StandaloneDeriving to derive a FromJson instance for a type that is coming from an external lib. Assuming that the 'Email' type is coming from an external lib, how can I make this work?
11:17:55 <_sras_> http://lpaste.net/354074
11:18:07 <sophiag> monochrom: i can't continue to use a variable?
11:18:11 <Sonolin> yea you can also use another type variable in the Foo declaration
11:18:28 <Sonolin> so data Foo a = Foo { lambda :: Lambda a }
11:18:38 <monochrom> Yeah.
11:18:42 <sophiag> ah ok
11:19:40 <sophiag> although i guess then that becomes an issue if i want to have lists of the record where a are different?
11:19:58 <monochrom> Yes.
11:20:09 <sophiag> yeah, that's what i was trying to avoid...
11:20:27 <monochrom> In fact as byorgey said, the issue is not with how to make it possible.
11:20:49 <monochrom> The issue is with, if you gave me such a list, how could I possibly use it.
11:21:23 <sophiag> i have that figured out
11:21:58 <monochrom> OK, how do I use it? For starters, how do I determine the type of the first item?
11:22:09 <sophiag> the first item?
11:22:18 <monochrom> Of the list you gave me.
11:22:24 <sophiag> the first item is a Maybe String
11:22:45 <monochrom> Always?
11:23:31 <monochrom> I am not talking about Foo, you know. I am talking about, let's say, [Foo].
11:23:52 <sophiag> if present it will match with a field in another record and then the type of the bound variable of the lambda will match the lists in that record. if not present then everything will be of the same type, as specified by the lists in the other record
11:24:37 <lyxia> _sras_: use standalone deriving to derive Generic for Email
11:24:41 <monochrom> OK I don't understand any of it.
11:24:54 <lyxia> _sras_: and then just write instance FromJSON Email
11:25:16 <sophiag> monochrom: regardless you said it's not an issue to have a record where i encapsulate the type variable in one field...how do i do that?
11:25:18 <lyxia> _sras_: assuming the generically derived instance is what you actually want.
11:25:52 <monochrom> OK, look up "existential quantification" in the GHC user's guide.
11:26:12 <sophiag> ah, gotcha. thank you
11:26:24 <sophiag> i always wondered what the use case for that was 
11:28:24 <_sras_> lyxia:  Works. Thanks!
11:28:51 <monochrom> And you need to see my http://lpaste.net/165712#a165719 . It shows you why I keep saying the issue is with what can a consumer do.
11:30:17 <monochrom> And you need to see this joke:
11:30:22 <monochrom> @quote monochrom river
11:30:22 <lambdabot> monochrom says: You are to send a boolean, a character, and an integer across the river. The list for transporting across the river can hold 3 items, in fact any number of items you like, but they
11:30:22 <lambdabot> must all be of the same type. On the bright side, after crossing the river, the boolean, the character, and the integer need only be put on show. How many trips do you need? Solution: one trip, [
11:30:22 <lambdabot> show the_boolean, show the_character, show the_integer]
11:35:17 <sophiag> monochrom: as mentioned, they'll be implicitly the same because i'm naming what i'll end up applying it to with the records
11:36:22 <sophiag> the one thing i'm left wondering is how to define an instance of Show for my lambda type
11:36:57 <hexagoxel> are there cases where replacing "do" with "mdo" makes a syntactically valid program invalid?
11:37:29 <monochrom> I think no. But it can change semantics.
11:37:37 <centril> is there a paper somewhere on the computational forms of normalization (Eq a => a -> a,  a -> Maybe a,  a -> (Any, a), ... ) ?
11:38:07 <monochrom> Wait, I actually don't know for sure.
11:38:10 <centril> are there more forms (obvious or not) I should include ?
11:38:27 <lyxia> centril: what is that
11:39:15 <centril> lyxia: the types (i can think of) for reduction steps / normalizations
11:39:19 <monochrom> Ah, yes, here it is: do { x <- aaa; x <- bbb x; ... }.  The semantics is shadowing. Change do to mdo, and you get mfix semantics.
11:39:23 <centril> on a term of type a
11:40:37 <hexagoxel> monochrom: right, thanks.
11:41:38 <monochrom> centril: What is (Any, a) doing there?
11:42:05 <centril> monochrom: determines if normalization has happened or not, if True, then yes, if False, then no
11:42:29 <monochrom> True and False are Bool's, not Any's or a's.
11:42:50 <centril> :t Any
11:42:51 <lambdabot> Bool -> Any
11:43:28 <centril> monochrom: Any is just Bool + (||) as the binary operator
11:43:35 <centril> with False as identity
11:44:28 <monochrom> OK. (Any, a) is equivalent to Either a a, so you will have it on your list too.
11:45:22 <centril> monochrom: yes, but Either a a  is awkward as a monad -  you want "did normalization occur anywhere", not: "did normalization occur everywhere?"
11:46:12 <centril> (I want)
11:46:13 <monochrom> I don't think when I said "Either a a" I had "everywhere" in mind.
11:47:14 <centril> monochrom: right, but isnt it similar enough to   a -> Maybe a   ?
11:47:57 <monochrom> All members of the list are similar enough to a -> Maybe a.
11:48:11 <centril> true
11:48:26 <centril> monochrom: is there some radically different alternative?
11:48:34 <centril> I've perhaps overlooked... ?
11:48:59 <monochrom> I don't know about radical. But I know how to double the list length by simply doing church-encoding.
11:49:53 <monochrom> For example, since a -> Maybe a is on the list, therefore forall r. a -> r -> (a -> r) -> r is also on the list.
11:50:45 <dzdcnfzd> Hey guys! I'm trying to install servant-server, getting the following error: Rule "FromJSONKeyCoerce: fmap id" may never fire           because ‘id’ might inline first
11:51:23 <monochrom> Böhm-Berarducci encoding, actually, as Oleg said. But more people call it Church.
11:51:28 <centril> monochrom: right - but there isnt some very common obvious thing that should be on the list that i've missed?
11:51:34 <dzdcnfzd> http://lpaste.net/354076
11:51:38 <dzdcnfzd> Any advice?
11:52:07 <monochrom> If you allowed non-determinism. But I guess you don't.
11:52:47 <monochrom> My experience is that a -> (Any, a) leads to the least ugly code.
11:53:12 <centril> monochrom: yeah, it was really nice to work with - it feels natural as a monad
11:53:49 <centril> and it's probably (no evidence for this...) a performant form as well - better than  Eq a => a -> a  at least
11:54:40 <monochrom> Actually my experience has only been with a -> Maybe a and it led to ugly code, and I understand why it's ugly, and a -> (Any, a) eliminates that reason.
11:55:31 <centril> monochrom: yeah, we tried  a -> Maybe a   at first, it was horribly littered with manual checks for "did it change?"
11:55:58 <centril> then we went over to  a -> (Any, a) and made all troubles go away
11:56:00 <monochrom> The reason is that in the Nothing case, often I still want the original expression. So now my code has to refer to the input expression all the time. Not very linear dataflow.
11:56:20 <centril> yeah
11:57:24 <MitchellSalad>  
11:57:38 <centril> monochrom: also, with a  a -> m (Any, a)  you get a nice   a -> WriterT Any m a   interface
11:57:40 <monochrom> In retrospect, the Maybe monad says that Nothing stands for "abort mission! abort mission!" so it is totally the opposite of "no news is good news".
11:57:52 <centril> monochrom: right :P
11:58:00 <centril> good analogy
11:58:20 <centril> monochrom: I might even steal it as a quote
11:58:52 <centril> (unfortunately it doesn't fit very well into a bachelors thesis paper ^^)
12:02:17 <monochrom> Well, you can say the same idea in more serious wording and discussion. The main idea is that the semantics of a data type is not just in its possible values, the semantics is in the operations, what >>= will do.
12:02:48 <centril> monochrom: that's the idea =)
12:03:35 <monochrom> OTOH no reason why some humour can't go into a thesis.
12:04:18 <centril> monochrom: tho, "serious" might not as aptly convey the message as your two "quotes"
12:04:40 <centril> monochrom: yeah - is it OK if I use those in some form ?
12:04:48 <monochrom> YES!
12:04:59 <centril> yay
12:05:34 <centril> off I go then, time for some cake
12:05:51 <lpaste_> ExpHP pasted “dumb join” at http://lpaste.net/354077
12:05:57 <ExpHP> ^ is there a way around this join?
12:06:40 <monochrom> Yes, use >>= :)
12:06:57 <ExpHP> Hm, I tried that but I think ran into precedence issues
12:07:09 <monochrom> Use do-notation.
12:07:16 <ExpHP> booo
12:10:15 <monochrom> You cannot stay within Applicative to get this done. I think at the very least you need Arrow. But Monad is much more lightweight than Arrow.
12:12:47 <infandum> If text is "A space efficient, packed, unboxed Unicode text type," why can't I derive an instance of Unboxed Text?
12:13:29 <infandum> sorry, Unbox Text
12:14:01 <monochrom> The sentence only means that individual codepoints are unboxed. Not that the whole thing is unboxed.
12:14:34 <monochrom> Where can I read about Unbox?
12:14:36 <infandum> ah
12:15:09 <lyxia> Is that vector's Unbox
12:16:24 <infandum> I assumed so, but now I don't know
12:16:47 <monochrom> No, actually not individual codepoints either. It uses UTF-16, and individual 16-bit words are unboxed.
12:16:47 <cocreature> infandum: what do you need that instance for?
12:17:19 <monochrom> Anyway, the problem with reasoning by natural language keywords.
12:18:36 <infandum> cocreature: I have a: "newtype ID = ID Text deriving (Unbox)", because I'll have a vector of IDs and I want it to be fast. Then I get the error where Unbox Text cannot be derived.
12:19:17 <monochrom> But "deriving" is only for a few selected classes, such as Eq.
12:19:40 <infandum> I got it from this: http://stackoverflow.com/questions/39275603/automatically-derive-unbox-for-newtype-without-th
12:19:46 <infandum> I guess it's a new feature
12:19:46 <cocreature> infandum: unboxing Text will buy you very little because the actual text storage doesn’t have a fixed length so it can’t be unboxed.
12:20:00 <cocreature> infandum: so at best you’ll unbox the length of the Text in your vector
12:20:04 <ij> I remember seeing an f such that: "Just x `f` Just y = Just x" (or Just y) and Nothing on either side is the identity.
12:20:37 <infandum> cocreature: But the point is that downstream I don't want to keep converting from Boxed to Unboxed and back and forth.
12:20:40 <monochrom> That's going to be Alternative's <|>
12:21:06 <cocreature> infandum: just use normal Text everywhere?
12:21:23 <infandum> cocreature: Sorry? What do you mean?
12:21:27 <cocreature> infandum: unboxing is only likely to make a difference if you can unbox the value completely into your vector
12:21:41 <cocreature> infandum: otherwise you’re better off just using normal boxed vectors
12:22:10 <infandum> cocreature: But what about converting back and forth? I want unboxed elsewhere as it has significant speed boosts, and converting must take some time...
12:22:39 <cocreature> infandum: it doesn’t have a significant speed boost for text, at least I doubt it has in any real application
12:22:51 <infandum> like, fmap (Text -> Int) (Boxed.Vector Text)
12:22:54 <ij> monochrom, Thanks!
12:23:14 <infandum> then I have a boxed vector of ints but I want unboxed for later so I would need to convert
12:23:24 <infandum> for instance
12:23:26 <monochrom> Text -> Int is already pretty non-trivial. You already have a conversion.
12:23:54 <cocreature> infandum: unboxing Text is unlikely to make a difference because the Text data _can’t_ be unboxed
12:24:05 <monochrom> And fmap (Text -> Int) (Boxed.Vector Text) is merely transforming a compact array of pointers to a compact array of numbers.
12:24:07 <infandum> I'm very confused now. I'm just saying that I would like unboxed everywhere because there are some functions that work much faster on unboxed.
12:24:33 <cocreature> infandum: I’m just saying that they don’t work much faster in the case of Text :)
12:24:44 <cocreature> unboxing is not some magic hammer that makes your code faster
12:25:32 <cocreature> infandum: also I’m not even sure what you mean by unboxing Text outside of a vector
12:25:36 <infandum> cocreature: That's understandable, but the only reason I want an unbox instance for text isn't because of text, it's because there are other downstream elements that are unbox instances and are faster.
12:25:39 <monochrom> Oh, I see, fmap preserves array flavour
12:26:05 <monochrom> perhaps don't use fmap, use generate or something
12:26:19 <cocreature> infandum: ah now I understand your point.
12:27:22 <monochrom> In fact, it is very possible that fromList . fmap f . toList is the fastest.
12:29:30 <cocreature> infandum: the stackoverflow post you linked to only talks about deriving an Unbox instance for a _newtype_ of something that _already is_ an instance of Unbox. you can’t derive that instance in general
12:30:02 <infandum> cocreature: Exactly, Text isn't unboxed.
12:30:17 <cocreature> infandum: you should be able to write an instance
12:30:29 <infandum> That might be a little too complicated.
12:31:00 <cocreature> I doubt that
12:31:16 <cocreature> the docs contain an example
12:31:50 <infandum> cocreature: I made one for Maybe and for an ADT I have
12:31:58 <infandum> I'm not familiar with the inner workings of text though
12:32:29 <infandum> monochrom: Not convert . fmap f?
12:32:32 <cocreature> but I also doubt that you will gain any performance by using an Unboxed vector of text. just change to that once it actually makes a difference.
12:33:06 <cocreature> infandum: you don’t need to be familiar with how it works. you just need to know that it’s isomorphic to (Array, Int, Int) and reuse the instance for that
12:33:12 <infandum> cocreature: I just assumed that keeping one vector type throughout the program would be best
12:33:16 <monochrom> Oh! convert exists. Yeah, possibly even better.
12:33:32 <cocreature> infandum: vectors are immutable so mapping over it creates a new vector anyway
12:33:34 <monochrom> No, possibly worse.
12:33:52 <infandum> hmmm
12:33:53 <monochrom> Err, no, I don't know that. They may have enough fusion laws.
12:34:33 <infandum> Okay, so basically whenever I have Prims I should use Unbox and Box for the rest, even when it's acting "on the same array"?
12:34:34 <cocreature> fusion laws don’t help. unboxed vectors don’t have the same space so you can’t reuse them
12:34:42 <monochrom> In all fairness my fromList . map f . toList assumes more fusion laws than convert . fmap f
12:34:49 <infandum> that might be a lot of converting
12:35:38 <glguy> fusion is about not recreating intermediate vectors, not reusing them
12:36:00 <monochrom> No no, cocreature, it's OK, my fromList . map f . toList relies only on eliminating the intermediate list, and convert . fmap f relies only on eliminating the intermediate boxed-array.
12:36:54 <monochrom> We have pretty much accepted that a brand new array is to be created and filled. We are just making sure that nothing else is.
12:37:00 <monochrom> Or hoping.
12:37:54 <infandum> Maybe I should use lists
12:38:02 <infandum> haha
12:38:28 <cocreature> infandum: basically all I’m trying to say is: benchmark before you decide that unboxing Text will help :)
12:38:30 <Jinxit> if i have a (Foo (Bar a)) where both Foo and Bar are applicative, how do i use <*>, <* and *> on Bar?
12:38:31 <monochrom> Do not forget that fmap f . convert is also an option. :)
12:38:42 <monochrom> Err wait, nevermind, not an option.
12:38:52 <cocreature> infandum: if you have trouble writing the instance, I’m happy to help. you can literally reuse most of the example in the haddocks
12:39:31 <Jinxit> sorry, let me rephrase, I have multiple Foo (Bar a)) but i want to work on the -inner- type with <*>
12:40:11 <cocreature> Jinxit: fmap operationOnInnerType
12:40:18 <infandum> monochrom: Why is it not an option?
12:41:30 <cocreature> monochrom: unboxed vectors are not an instance of Functor
12:41:31 <APic> 😎
12:41:36 <monochrom> Because I will type annotate it to show it is: unboxed array of number <--- fmap f <--- unboxed array of text <--- convert boxed array of text
12:41:55 <infandum> cocreature: Interesting... I didn't even realize that
12:42:53 <infandum> cocreature: Wait, why? Shouldn't that be an easy instance to make?
12:43:11 <monochrom> Jinxit: You will need both <*> for the Foo level and the <*> for the Bar level.
12:43:19 <infandum> It's a vector. What makes boxed a functor but not unboxed?
12:43:46 <monochrom> Because you are looking at Boxed a => BoxedVector a
12:43:50 <cocreature> infandum: it’s impossible to make that instance because there is not a polymorphic unboxed vector type. vector uses data families to make it look like it is but that’s not the case
12:43:51 <monochrom> err
12:44:00 <monochrom> Because you are looking at Unboxed a => UnboxedVector a
12:44:02 <Myrl-saki> https://people.mpi-sws.org/~dreyer/tor/papers/wadler.pdf 3.1, how did he go from relations back to types?
12:44:19 <Jinxit> i don't see how to do it with two values, for example Just (Just (+5)) <*> Just (Just 2)
12:44:25 <Jinxit> (except not <*> of course)
12:44:33 <infandum> ah oops
12:44:34 <monochrom> Err nevermind, what cocreature said.
12:45:29 <monochrom> > (<*>) <$> Just (Just (+5)) <*> Just (Just 2)
12:45:32 <lambdabot>  Just (Just 7)
12:45:44 <Jinxit> ohh right
12:45:51 <infandum> cocreature: I don't want to be stupid, but couldn't you just do fmap f v = fromList . fmap f . toList?
12:45:54 <Jinxit> i was overthinking it, thanks
12:46:00 <infandum> fmap f = that is
12:46:04 <monochrom> The 1st <*> is for the inner level. The 2nd <*> is for the outer level. The <$> is also the outer level
12:46:20 <infandum> it isn't ideal, but this is conceptual, not performance
12:46:22 <cocreature> infandum: you literally can’t even write an empty Functor instance
12:46:51 <infandum> yup
12:46:52 <infandum> ok
12:46:53 <infandum> got it
12:46:55 <cocreature> infandum: and even if you could, that would fail because calling "fromList" would require an Unbox instance on b which you might not have
12:47:04 <cocreature> which is what monochrom was trying to explain
12:47:25 <infandum> i see
12:47:43 <cocreature> which is similar to why Set has no Functor instance
12:47:45 <infandum> and I guess there are no restrictions for fmap (a -> b)
12:47:49 <Jinxit> monochrom: is there a simple way to do this for N arguments?
12:48:06 <infandum> makes sense, had a brain moment
12:48:15 <cocreature> brain moments are always good :)
12:48:40 <cocreature> infandum: also I’m sorry if I sounded a bit grumpy before, that was not my intention
12:49:35 <Jinxit> for the first <*> i mean
12:50:02 <infandum> cocreature: No, not at all, you were very helpful.
12:50:34 <infandum> cocreature: Also, that's why map exists for unboxed (and has the constraints)
12:51:04 <cocreature> infandum: exactly!
12:51:36 <monochrom> I think it's like this: (\a b c -> a <*> b <*> c) <$> Just (Just (-)) <*> Just (Just 4) <*> Just (Just 3)
12:51:43 <monochrom> > (\a b c -> a <*> b <*> c) <$> Just (Just (-)) <*> Just (Just 4) <*> Just (Just 3)
12:51:45 <lambdabot>  Just (Just 1)
12:52:37 <monochrom> Equivalently, liftA3 (\a b c -> a <*> b <*> c) (Just (Just (-))) (Just (Just 4)) (Just (Just 3))
12:53:58 <monochrom> Ironically, "lift" is only from the type perspective. From the value perspective it's "descend".
12:54:51 <monochrom> Although, "inner" and "outer" are also from the type perspective only.
12:57:14 <monochrom> Err, I guess not, "[Just 4]" the Maybe type and the Just value are both inner.
12:59:32 <ph88> can anyone help me understand this http error?  https://bpaste.net/show/2b7a5cfb1d15
12:59:55 <ph88> oh shit, i think this is one of those moments where i see the error as i make the paste -___-
12:59:57 <ph88> (watch port)
13:00:18 <cocreature> localhost:9998 is probably not a valid host :)
13:00:43 <monochrom> That too.
13:01:43 <ph88> it's a valid host for sure  " Welcome to the Apache Tika 1.14 Server "
13:03:11 <ph88> it works, beautiful, beautiful
13:03:16 <monochrom> I be damned if DNS suddenly understands "xxx.com:80"
13:04:34 <monochrom> Every DNS software keeps expanding until it contains a web browser.
13:05:56 <ph88> xxx.com your homepage ?
13:06:07 <monochrom> No.
13:06:17 <ph88> j/k :P
13:17:17 <infandum> cocreature: Can I write an instance of Foldable for Unboxed that obeys the rules?
13:18:46 <AWizzArd> If you search for „let generalization” on this page, what does it mean?  http://www.haskellforall.com/2014/10/how-to-desugar-haskell-code.html
13:19:46 <infandum> cocreature: Like, cheat the system without breaking anything?
13:21:23 <lyxia> AWizzArd: https://en.wikipedia.org/wiki/Let_generalization
13:23:33 <AWizzArd> lyxia: oki thanks
13:31:03 <glguy> infandum: You can't write a Foldable instance for unboxed Vector, You need the Unbox constraint to read elements out of the vector
13:39:12 <infandum> glguy: Okay, that's what I feared.
13:44:45 <b_perez> Currently reading through the GHC as a library wiki page. Confused about the DynFlag settings in section 4/ I get errors when I use them in my own code. Why are they using Opt_Cpp, Opt_ImplicitPrelude, Opt_MagicHash?
13:45:02 <b_perez> for reference: https://wiki.haskell.org/GHC/As_a_library
13:45:42 <newguy> Hi while running *cabal configure* I get
13:45:52 <newguy> cabal: At least the following dependencies are missing: tagged >=0.4.4 && <1
13:46:17 <newguy> but on doing cabal install tagged I get
13:46:23 <newguy> cabal: There is no package named 'tagged'.
13:46:38 <newguy> Any help is appreciated 
13:47:16 <mizu_no_oto_work> newguy: "cabal update", "cabal install --dependencies-only"?
13:48:19 <newguy> cabal install --dependencies-only gives me http://lpaste.net/5346536394284072960
13:49:11 <newguy> cabal update returns  "Skipping download: Local and remote files match."
13:49:57 <mizu_no_oto_work> Are you cabal installing stuff globally, out of curiosity?
13:50:14 <newguy> no idea :(
13:50:22 <newguy> I am a newbee in cabal
13:51:34 <mizu_no_oto_work> did you ever run "cabal sandbox init", for example?
13:51:39 <lyxia> newguy: what's in .cabal/packages/hackage.haskell.org/ ? http://stackoverflow.com/questions/30982195/cabal-update-local-and-remote-files-match
13:51:43 <newguy> no
13:51:52 <mizu_no_oto_work> Take a look at http://blog.ezyang.com/2016/05/announcing-cabal-new-build-nix-style-local-builds/
13:52:15 <tobiasBora> Hello,
13:52:50 <mizu_no_oto_work> newguy: Basically, just cabal installing stuff isn't really a great idea, since you have a global database of packages that needs self-consistent versions for everything
13:52:56 <tobiasBora> How would you do using Parsec something like "I would like a string containing this set of char (like letters and dots), but I would like it to end with a letter.
13:53:15 <mizu_no_oto_work> newguy: cabal sandboxes are the old hotness for getting around that
13:54:06 <mizu_no_oto_work> if you got into a weird state, you could just delete the .cabal-sandbox folder everything was built in, in your project
13:54:19 <mizu_no_oto_work> and cabal new-build is the new hotness
13:54:38 <lyxia> tobiasBora: can there be more stuff after the string?
13:54:44 <newguy> k thank you very much
13:55:02 <tobiasBora> lyxia: yes
13:55:17 <tobiasBora> lyxia: Basically I'm trying to find an email in a text
13:56:22 <newguy> now on cabal update I am getting cabal: Codec.Compression.Zlib: premature end of compressed stream
13:56:39 <newguy> I cleared .cabal/packages/hackage.haskell.org/ directory 
13:58:34 <lyxia> tobiasBora: Say the set is letters and dots, then you can start with    some (try (liftA2 (++) <$> many dots <*> some letter))
13:59:42 <ph88> i'm trying to http with bloodhound/elasticsearch anyone know how i can just print the response body ?  https://bpaste.net/show/add1c0d3cfc3
14:01:02 <monochrom> lyxia: That's neat.
14:02:28 <monochrom> Reminds me of the horror days when I needed to prove (0|1)* 0 = (1* 0+)+
14:02:41 <lyxia> :)
14:05:52 <lyxia> ph88: you're using responseBody from the wrong package
14:06:57 <lyxia> ph88: you need https://hackage.haskell.org/package/http-client-0.5.6.1/docs/Network-HTTP-Client.html#v:responseBody
14:09:53 <ph88> i thought i was using that version of responseBody all along o_O
14:10:37 <ph88> ah right i'm using this one https://hackage.haskell.org/package/req-0.2.0/docs/Network-HTTP-Req.html#v:responseBody
14:10:47 <lyxia> That's it.
14:25:58 <Durbley> Does anyone know of a freely available Haskell video lecture series by an established expert that's reasonably complete but accessible to someone with a modest background in math/computer science
14:27:08 <sophiag> Durbley: i like erik meijer's lectures to accompany graham hutton's Programming in Haskell book
14:28:20 <Durbley> thanks sophiag. is this it https://www.youtube.com/watch?v=rlwSBNI9bXE&index=11&list=PLX15ZXZzrWp5l1WkN5VkhmrbVp_ybNFRZ?
14:28:23 <Durbley> https://www.youtube.com/watch?v=rlwSBNI9bXE&index=11&list=PLX15ZXZzrWp5l1WkN5VkhmrbVp_ybNFRZ
14:29:11 <sophiag> yup
14:30:32 <Durbley> sophiag, I don't see much on monads/applicatives?
14:31:12 <monochrom> That would be strange. Erik Meijer was the one who brought monad as LINQ to C#.
14:31:30 <sophiag> that series definitely covers monads
14:31:46 <monochrom> Every time he writes for ACM Queue it's yet another monad tutorial again.
14:32:32 <sophiag> not that many books have a _whole_ lot on applicatives since they were all written prior to 2014 when applicative style became standard
14:32:59 <sophiag> someone told me Programming in Haskell is being updated though so that sounds promising
14:33:04 <Rembane> Burritofest!
14:33:16 <Durbley> I'm looking at lecture 9 where he's talking about IO. But I don't see any other monad examples in other lecture descriptions
14:33:30 <sophiag> "a burrito is a monoid in the category of endofunctors"
14:33:52 <sophiag> Durbley: is that the one on parsers? i haven't watched it all tbh
14:34:08 <Durbley> No. But in this one he did say "we saw monads when we covered parsers"
14:34:18 <Durbley> but based on what he's saying now I don't think it was detailed
14:34:27 <sophiag> ah yeah, ok. so i tihnk that's when he first introduces them
14:35:32 <Durbley> but no State, Reader, Applicatives?
14:35:51 <sophiag> isn't there a list of topics?
14:36:14 <Durbley> as far as I see each video has one but I cant find one list
14:36:25 <Durbley> I tried to go to the homepage in the description but that led to the book you mentioend
14:37:41 <sophiag> yeah, the list of videos isn't that helpful
14:40:22 <Durbley> I downloaded all the slides and skimmed them. I've learned almost all of this already :|
14:40:42 <Durbley> no Reader, State, Applicatives, or further Monad examples
14:42:36 <jle`> can i get stack to output all of the ghc versions in scope?
14:43:18 <kadoban> jle`: "in scope" ? All of the ones it installed you mean? (but if so, no I don't think so)
14:43:59 <jle`> all of the ones it will accept if i did stack build --compiler XX
14:44:32 <kadoban> Oh that, hmm. Not that I know of, but that's a good question.
14:59:24 <dawehner> Hi
14:59:36 <dawehner> Does it make sense to implement applicative for a Map?
14:59:38 <ChaiTRex> hello.
14:59:54 <dawehner> It feels like it could make sense by ignoring the keys?
14:59:56 <Koterpillar> dawehner: can you uphold its laws?
15:00:18 <Koterpillar> ChaiTRex: hello
15:00:40 <dredozubov> dawehner: how would you implement pure?
15:01:07 <Koterpillar> maybe if the key is a monoid...
15:01:13 <dawehner> dredozubov: I guess you indeed can't
15:01:26 <Koterpillar> but then I don't know what use is that
15:01:36 <dawehner> right if key is a monoid it could be just mempty
15:01:53 <Koterpillar> but then you'll have to do cartesian product for bind
15:02:23 <Koterpillar> I mean <*>
15:03:04 <dawehner> Right for <*> you'd probably loose the keys on both sides
15:03:18 <dawehner> ... in case you just deal with the value level
15:03:31 <Koterpillar> no, you use mappend
15:03:46 <Koterpillar> in fact, you have to, if you use mempty for pure
15:04:16 <dawehner> well, what happens if you have the same keys in mappend ?
15:04:58 <Koterpillar> not what you expect
15:05:33 <dawehner> Koterpillar: yeah the more I think about it, the less I think it could be useful (if it would be implementable)
15:05:41 <Koterpillar> liftM2 (+) (M.fromList [("a", 1)]) (M.fromList [("b", 2)]) == M.fromList [("ab", 3)]
15:07:32 <tswett_to_go> Hey there. So I'm writing a package. I'm wondering if I can have a module export a function in such a way that the function can be used by any module inside the package, but not outside the package.
15:07:46 <tswett_to_go> Kind of like the "internal" access modifier in C#.
15:07:53 <pikajude> if you don't export the module sure
15:08:49 <tswett_to_go> Well... that sounds pretty easy. :)
15:08:50 <tswett_to_go> Thanks.
15:09:59 <pikajude> then it's a "package-private" module
15:10:23 <pikajude> don't go too hogwild with private members though
15:10:36 <Renard_Chase> I don't know if this exactly goes here, but when I try to run ' floor ((log 10) * 3) ' in Haskell (and Lua) I get 6, but when I run it through my graphing calculator (or a website that does the same) I get 3, and I don't know what to make of those results
15:10:41 <pikajude> one of the cryptohash libraries exports a newtype wrapper for ByteString but not the constructor itself so you can't get the bytestring out @_@
15:12:09 <geekosaur> Renard_Chase, look for a "ln" function on your graphing calculator
15:12:26 <geekosaur> most calculators default to log base 10; most computers to log base e
15:12:40 <Renard_Chase> Ah, I didn't know that
15:12:43 <Renard_Chase> Thanks
15:13:15 <geekosaur> (ln or logn, ... "natural logarithm")
15:19:53 <ph88> how can i index a document while not supplying an ID ?   https://hackage.haskell.org/package/bloodhound-0.13.0.0/docs/Database-V5-Bloodhound-Client.html#v:indexDocument    https://hackage.haskell.org/package/bloodhound-0.13.0.0/docs/Database-V5-Bloodhound-Types.html#t:DocId
15:20:02 <ph88> "Can be set by the user or created by ES itself."
15:20:09 <dmwit> dawehner: http://hackage.haskell.org/package/total-map is a Map-like that offers an Applicative and Monad instance
15:20:10 <ph88> but the indexDocument function requires i give the id
15:20:31 <dawehner> dmwit: thank you!
15:20:48 <dmwit> dawehner: The instances are "zippy": `liftM2 f m1 m2` aligns matching keys in `m1` and `m2` and applies `f` to their respective values.
15:21:29 <ph88> bitemyapp around ?
15:23:03 <dawehner> dmwit: and it throws away the others?
15:23:49 <dmwit> The maps are total. There are no others. =)
15:25:14 <dmwit> Think of `TMap k v` as just being another in-memory representation of `k -> v`. The instances are "the same" in that regard.
15:26:00 <Koterpillar> then aren't those instances just (a ->) in disguise?
15:26:09 <dmwit> I think I just said that, yes.
15:27:07 <ReinH> Perhaps those instances are equivalent to those of (r ->).
15:27:21 * Koterpillar needs to not selectively read the left part of the chat
15:28:39 <ReinH> It could be the case that the instances of TMap k correspond to those of (k ->).
15:48:25 <dawehner> Thank you for all your help, I need to let this settle for a map
15:48:35 <dawehner> *for a while :)
15:55:06 <Renard_Chase> Any easy way to round a number to the nearest fourth?
15:55:46 <haskull> does UArray not support tuple values? normal array and Vector.Unboxed does :/
15:55:51 <mniip> Renard_Chase, times 4, round, over 4
15:58:21 <geekosaur> haskull, tuples are boxed. Vector.Unboxed may be telling a convenient lie; UArray doesn't tell that lie
15:59:15 <haskull> geekosaur: is my best option to encode it as an int, then?
15:59:23 <haskull> encode the values in the tuple*
15:59:44 <geekosaur> possibly
16:00:47 <geekosaur> Vector is more recent and can take advantage of machinery that Array couldn't and possibly can't; unboxing can be "interesting" to implement
16:01:27 <Renard_Chase> mniip: Thanks
16:22:46 <Squarism> Judging by the issue count the two largest haskell logging frameworks (according to google) haskell users : dont use these or they were perfectly implemented from start?! Any other ideas?
16:45:17 <Conjecture> Is there a way to get a buffer that allows me to write to each element of it once and never again?
16:45:31 <Conjecture> In order
16:56:00 <glguy> That's what ByteString.pack or Vector.fromList effectively
16:56:01 <glguy> do
16:59:03 <ana_> ?src ($)
16:59:03 <lambdabot> f $ x = f x
17:00:47 <ana_> ?src update
17:00:47 <lambdabot> Source not found. Where did you learn to type?
17:01:04 <ana_>  ?src ($)
17:01:04 <glguy> ana_: You can play with lambdabot with private messages, /query lambdabot   and  /msg lambdabot
17:01:20 <ana_> ?src ($)
17:01:20 <lambdabot> f $ x = f x
17:01:28 <ana_> ?src (update)
17:01:28 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
17:01:43 <ana_> ?src (.)
17:01:43 <lambdabot> (f . g) x = f (g x)
17:01:53 <geekosaur> it's not a comprehensive database
17:02:07 <ana_> ?src (Data.Sequence.update)
17:06:00 <ana_> Hi, How to find source code for update function in Data.Sequence
17:06:12 <geekosaur> @where hoogle
17:06:13 <lambdabot> http://haskell.org/hoogle http://fpcomplete.com/hoogle – See also Hayoo, which searches more packages: http://hayoo.fh-wedel.de/
17:06:15 <geekosaur> @where hayoo
17:06:16 <lambdabot> http://hayoo.fh-wedel.de/ -- See also Hoogle: http://haskell.org/hoogle http://fpcomplete.com/hoogle
17:06:59 <ana_> Ok. Thanks I am checking nw. 
17:12:03 <lpaste_> robkennedy pasted “Assert universal constraint?” at http://lpaste.net/354080
17:12:46 <robkennedy> Is there any way to assert that decompose does not need a constraint?
17:12:52 <lyxia> nope
17:17:52 <robkennedy> Is that some sort of `A V -A /= True` logic?
17:21:17 <lyxia> I don't think so. It's due to 1) the open world assumption of type classes 2) preserving parametricity guarantees.
17:21:44 <bitemyapp> ph88: if you have questions about Bloodhound, ask them on Github. IRC is too synchronous.
17:22:25 <Welkin> Bloodhound?
17:22:36 <Welkin> bitemyapp: I haven't seen you around in a long time
17:23:25 <lyxia> robkennedy: a more practical concern is that type class constraints get desugared to an additional parameter. It becomes more difficult to do that if the constraint is not there.
17:24:17 <Welkin> robkennedy: I can't look at your nick without thinking about the kennedy family; rob kennedy was assassinated
17:25:30 <bitemyapp> Welkin: yeah it's great
17:25:39 <lyxia> robkennedy: Parametricity tells you that, ignoring bottoms, the type forall a. a -> a is only inhabited by id. You wouldn't be able to say this if you could erase type classes like that, even if every concrete type had an instance.
17:29:01 <Welkin> bitemyapp: even though I have never used elasticsearch, I might want fulltext search in the future, so I starred it
17:29:31 <dmwit> robkennedy: import GHC.Prim, then ask ghci `:kind! CheckP Any`
17:29:39 <dmwit> robkennedy: (this is a sad situation)
17:31:52 <dmwit> `Any` plays approximately the same role at the type level that `undefined` plays at the value level.
17:32:07 <sophiag> question about haskell asts: if i parse one into type Exp i can match for Literals, but not QOps although they seem to be at the same level. am i missing something and there's actually an intermediate type?
17:32:09 <_sras_> Why doesn't this standalone deriving work? http://lpaste.net/354081
17:33:37 <loorke> Hello. Can you explain me why haskell isn't popular?
17:34:03 <sophiag> loorke: it isn't?
17:35:01 <Welkin> loorke: type /quit
17:35:16 <Koterpillar> Welkin: that's not a good way of explaining
17:35:17 <dmwit> _sras_: Looks like the swagger library implements a custom error when you try to make a ByteString instance of `ToParamSchema` (presumably needed to make an instance for your type).
17:35:45 <Koterpillar> loorke: exercising every day isn't popular either
17:35:49 <dmwit> _sras_: I'm not sure whether the library also offers the newtypes it proposes or whether it's expecting you to write your own, but the advice seems pretty clear cut to me.
17:36:44 <loorke> Koterpillar: Hmm
17:37:05 <_sras_> dmwit: So it is coming from the Generic instance of ToParmSchema, right?
17:37:18 <loorke> Welkin: Thank you, you have explained me :-)
17:37:45 <sophiag> lol
17:38:07 <dmwit> _sras_: In fact, I think you have left off part of the error. From source-diving, I see an additional sentence: "Consider using byteParamSchema or binaryParamSchema templates.".
17:38:54 <dmwit> _sras_: So this almost certainly explains the issue completely. You need to carefully choose one or the other, and this error is pointing that out so it doesn't quietly choose the wrong one for you.
17:39:21 <robkennedy> dmwit: could you spoil what `:kind! CheckP Any` gets?
17:39:24 <_sras_> dmwit: Yes. But what does it mean. Where should I use byteParamSchema or binarayParamSchema?
17:39:36 <dmwit> robkennedy: `CheckP Any = CheckP Any`
17:40:10 <dmwit> _sras_: In your instance of `ToParamSchema Foo`, where `Foo` is your newtype wrapper around `ByteString`. At a guess. I have never used swagger.
17:40:59 <dmwit> robkennedy: Compare `CheckP (P Int Int) = IsP` and `CheckP [Int] = NotP`.
17:41:09 <_sras_> dmwit: Does this mean I have to implement the instance manually?
17:41:23 <dmwit> _sras_: You can browse the documentation for such an instance as easily as I can...
17:42:12 <dmwit> _sras_: Perhaps your question is whether you must not use `Generic` to get the instance for your top-level type.
17:42:14 <_sras_> dmwit: Sure sure. Thankyou.
17:42:26 <dmwit> _sras_: In which case I believe the answer to that is that you should still be able to use `Generic`.
17:46:43 <sophiag> dmwit: do you know much about haskell AST types? i'm trying to match for operators (so type QOp), but getting an error making it seem like the _input_ type (Exp) is wrong even though it's in the same infix expression i can match Literals with
17:48:56 <dmwit> sophiag: You know the drill. Cut down your example to the smallest piece of code that shows the problem, then throw it up on lpaste or hpaste or whatever's in fashion these todays together with the full error you get.
17:49:06 <dmwit> ?paste
17:49:06 <lambdabot> Haskell pastebin: http://lpaste.net/
17:49:10 <dmwit> lpaste, apparently
17:49:31 <dmwit> English is much too imprecise for these kinds of questions.
17:49:40 <sophiag> ha, fair. i always think i can verbally explain it well enough, but most of the time even a past results in miscommunication
17:52:25 <sophiag> dmwit: if you'd be so kind: http://lpaste.net/354083
17:54:13 <dmwit> sophiag: `Lit` is a constructor for `Exp`; `QVarOp` is a constructor for `QOp`.
17:55:36 <sophiag> oh...is there somewhere that lists all these? all i've found is this: https://hackage.haskell.org/package/haskell-src-exts-1.19.1/docs/Language-Haskell-Exts-Build.html
17:56:05 <dmwit> https://hackage.haskell.org/package/haskell-src-exts-1.19.1/docs/Language-Haskell-Exts-Syntax.html
17:56:45 <dmwit> You can discover this for yourself by visiting Hoogle and typing in `Exp`, then clicking the appropriate result.
17:58:15 <sophiag> it's just not entirely clear from the haddock docs
18:01:11 <sophiag> anyway, the confusing part for me is that i'm actually trying to parse both a Literal and QOp out of an Exp since Lambda is a constructor for Exp. so i'm not sure what type signature to use for that function...it needs to start with Exp ->
18:04:49 <dmwit> What is "it" in "it's not clear from the haddocks"?
18:05:32 <sophiag> dmwit: do you see what i mean? that third field you can see in the Lambda AST is of type Exp and that's the argument to my function in both cases. but then the field i actually want to match for now is of type QOp
18:06:17 <dmwit> What is a field? Why do you believe the field you actually want to match for is of type `QOp`?
18:06:45 <sophiag> the Lambda constructor takes three arguments
18:06:54 <sophiag> i'm only dealing with the third
18:07:08 <dmwit> Okay so far.
18:07:38 <sophiag> i want to match for operators...and i believe they're of type QOp because they're wrapped in one of its constructors: QVarOp
18:08:16 <dmwit> Perhaps you should look at what value is in the third argument of your sample value for further guidance.
18:08:27 <dmwit> (Hint: it isn't `QVarOp`.)
18:08:32 <sophiag> Symbol?
18:08:55 <sophiag> that's of type Name
18:08:58 <dmwit> Sorry, this time I was the one that was imprecise. Look in the third argument to `Lambda` in your sample value.
18:09:23 <sophiag> oh, that's of type Exp
18:10:53 <sophiag> "InfixApp l (Exp l) (QOp l) (Exp l)"
18:11:02 <sophiag> that's the third argument to Lambda
18:11:10 * dmwit nods agreeably
18:14:14 <sophiag> i tried using "(Lambda _ _ (_ expr _)" as my argument, but that didn't help...
18:15:19 <dmwit> Hm. Have you done a Haskell tutorial that covers the syntax of data types and pattern matching?
18:15:39 <sophiag> yes, but this is a particularly complicated case
18:16:40 <sophiag> i think i'm thrown off by the fact that i didn't need to unwrap InfixApp in order to match for Lit because the type signature was the same as the whole Lambda
18:17:27 <dmwit> huh?
18:17:54 <sophiag> you saw the function where i matched for the Literal types, right?
18:18:20 <dmwit> `InfixApp` and `Lit` are just different constructors. They're both constructors for the `Exp` type.
18:19:04 <dmwit> The fact that `Lambda` is also a constructor for the `Exp` type isn't really relevant, I don't think.
18:19:11 <sophiag> oh ok
18:19:24 <sophiag> because i'm already pulling out InfixApp in the argument?
18:20:10 <dmwit> You ask "because X?". But normally such questions are of the form "is Y true because X?" or similar. What is Y?
18:20:23 <sophiag> although if i try to have it infer type it guesses Exp
18:20:47 <sophiag> Y is of type Name
18:21:09 <dmwit> "of type Name because I'm already pulling out InfixApp in the argument" doesn't appear to be a sensible question to me.
18:22:07 <dmwit> I kind of want to help, but I'm having a very difficult time understanding what your questions are. I think there's some pretty fundamental (and likely very simple) confusion here that should be easy to clear up, but it's tricky for me to spot what the right guidance is.
18:23:03 <sophiag> well, Lambda is of type Exp...i pull out another type Exp from it...and then I'm trying to match on type Name inside type QOp
18:23:33 <dmwit> First of all: you don't match on types. You match on values.
18:23:51 <monochrom> and data constructors.
18:24:09 <sophiag> yes, but you asked what my question is. my qustion is "what's the appropriate type signature?"
18:24:18 <dmwit> Second: `Lambda` is not of type `Exp`. `Lambda` is a constructor for `Exp`, but its type is `l -> [Pat l] -> Exp l -> Exp l`.
18:25:40 <sophiag> yes, i got that wrong. it's InfixApp that's a constructor for Exp
18:26:12 <sophiag> or rather [Exp 1] -> [QOp 1] -> [Exp 1]
18:26:25 <dmwit> (Those should be ells, not ones.)
18:27:04 <sophiag> ah, thanks
18:27:24 <dmwit> I suspect the type signature you wrote for `parseSymbol` is mostly fine.
18:27:53 <nathyong> I'm trying to run some tests through tasty-quickcheck, and timeouts don't appear to be working for me
18:28:12 <nathyong> I'll paste a small sample -- it only happens when I include the offending function as part of another module
18:29:55 <Conjecture> Thanks glguy. Sorry I took _so_ long
18:31:45 <nathyong> https://gist.github.com/anonymous/182b78c18974b5030c189a0e3b9a50af
18:32:23 <nathyong> Clearly the function will never terminate, and should trigger tasty's timeout
18:32:42 <nathyong> Running with runghc works as expected, but compiling and running the binary continues running forever
18:33:38 <nathyong> Anyone have any idea why this is happening?
18:38:31 <lyxia> It's timing out properly here.
18:39:06 <lyxia> nathyong: what versions of tasty/tasty-hunit are you using
18:39:16 <np356> hello folks, I'm trying to learn conduit and I came across a strange syntax that I have not seen before
18:39:19 <np356> http://lpaste.net/7230414809584369664
18:39:31 <np356> specifically lines 11 -> 16
18:39:48 <Koterpillar> which bit?
18:39:49 <nathyong> lyxia: I'm using the version in stackage lts-8.6
18:39:57 <np356> so I tried to break it down in a smaller function (lines 20-23) but it does nit compile
18:40:08 <np356> I never saw "let x = do ... in x"
18:40:14 <nathyong> also I'm on OSX 10.11
18:40:20 <Koterpillar> > let a = 1:[a] in a
18:40:21 <np356> can someone please explain for me wtf is this syntax?
18:40:22 <lambdabot>  error:
18:40:22 <lambdabot>      • Occurs check: cannot construct the infinite type: a1 ~ [a1]
18:40:22 <lambdabot>      • In the expression: 1 : [a]
18:40:26 <Koterpillar> > let a = 1:a in a
18:40:27 <geekosaur> do produces an expression like any other
18:40:29 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
18:40:36 <nathyong> Should be the latest one, I think.
18:40:39 <Koterpillar> np356: recursion!
18:40:49 <geekosaur> it's just a way to make a local recursive definition that happens to be an IO action
18:40:54 <Koterpillar> np356: what error does your rewrite give?
18:41:10 <np356> but why it doesn't compile in the second isolated case? (lines 20-23) 
18:41:18 <np356> it should keep printing "boom" forever
18:41:20 <np356> right?
18:41:28 <geekosaur> yes, but that means it never produces IO ()
18:41:29 <np356> "Parse error: Last statement in a do-block must be an expression"
18:41:34 <lyxia> np356: you must indent past the let
18:42:01 <np356> lyxia, on line 21?
18:42:12 <lyxia> yes
18:42:18 <geekosaur> however what lyxia says is correct. let alos uses layout
18:42:22 <nathyong> hmm I'll come back to this in an hour or so
18:42:33 <geekosaur> and line 22 is indented for the let bindings, not for the do
18:42:34 <lyxia> nathyong: it's still working here on the same resolver
18:43:08 <nathyong> lyxia: I compiled with `stack exec ghc A.hs && ./A`, did you do so as well?
18:43:29 <geekosaur> specifically any line that is part of the 'do' has to be indented farther than the 'loop' on line 21
18:43:35 <np356> worked, thank you. print needed to be indented past the beginning of "loop"
18:43:49 <np356> I thought that shenanigans like these exist only in python...
18:43:53 <Koterpillar> nathyong: shouldn't that be stack runghc?
18:44:11 <nathyong> Koterpillar: it works with runghc, but doesn't work if I compile it and then run the binary.
18:44:21 <geekosaur> np356, you can have multiple bindings in a let
18:44:51 <lyxia> nathyong: that's what I did
18:44:59 <nathyong> gee
18:45:01 <nathyong> lyxia: OS and setup?
18:45:01 <lpaste_> geekosaur annotated “No title” with “let uses layout too” at http://lpaste.net/7230414809584369664#a354086
18:45:26 <lyxia> nathyong: I'm on Arch
18:45:26 <Koterpillar> nathyong: stack exec falls back to $PATH, e.g. 'stack exec ls'
18:45:40 <Koterpillar> nathyong: 'stack exec ghc' /= 'stack ghc'
18:46:14 <nathyong> doesn't work with that either
18:46:18 <nathyong> I'll test on a Linux system later
18:46:43 <lyxia> I think stack exec ghc is special cased
18:46:44 <nathyong> lyxia: Koterpillar thanks for your help so far
18:47:16 <lyxia> or stack exec is setting up some environment variables
18:47:26 <geekosaur> it does, to override the package path
18:47:37 <geekosaur> it also adds various things to $PATH
18:48:05 <geekosaur> I would be surprised if `stack ghc` were anything but a convenience frontend for `stack exec ghc`
18:48:58 <Koterpillar> but which ghc?
18:49:35 <Koterpillar> ah, PATH is set, so it'll be the right one
18:54:31 <MarcelineVQ> I agree with Koterpillar, stack ghci isn't stack exec -- ghci    so it's hard to say without looking closer whether stack ghc is stack exec -- ghc
18:56:35 <lyxia> "You can use stack exec ghc or stack exec runghc for that. As simple helpers, we also provide the stack ghc and stack runghc commands, for these common cases." stack user guide
18:57:05 <lyxia> ghci is special however
18:58:07 <geekosaur> ^ stack ghci's inspiration is cabal repl which preloads your project into ghci. arguably the problem is stack calling it ghci instead of repl...
18:58:38 <MarcelineVQ> ah, well tbf it is both ghci and repl with the same code to parse either
18:59:05 <geekosaur> repl was added later for cabal-install compatibility, I think?
18:59:06 <MarcelineVQ> with a naming bias towards ghci internally
18:59:30 <geekosaur> I recall early stack not having repl, just ghci
19:03:43 <Welkin> Didn't one of you say you used webpack with purescript?
19:05:00 <robertkennedy> So does any function `f :: forall a. a -> T` need a constraint on a?
19:05:22 <tobiasBora> Hello,
19:05:36 <tobiasBora> Haskell is getting really weird on a Centos 6.8 server
19:05:42 <tobiasBora> For example, if I do
19:05:56 <Welkin> why are you running haskell on a server?
19:05:57 <MarcelineVQ> iiuc then code-wise I see here that stack ghc really is stack exec ghc   just with the opts specialized to be ghc specific
19:06:08 <tobiasBora> putStrLn $ "User : " ++ getName ++ " is not existing"
19:06:09 <Welkin> only run the binary executables on your server
19:06:12 <Welkin> develop locally
19:06:23 <tobiasBora> Welkin: It's till worse
19:06:48 <tobiasBora> Welkin: The executable gives errors like /lib64/libc.so.6: version `GLIBC_2.14' not found (required by prog)
19:07:07 <tobiasBora> (I'm developing on debian sid, maybe that's why)
19:07:32 <tobiasBora> so the line : putStrLn $ "User : " ++ getName ++ " is not existing"
19:07:32 <geekosaur> yes
19:07:44 <tobiasBora> does not gives the same result as
19:07:52 <geekosaur> debian sid will have a much more recent glibc than centos 6
19:08:05 <tobiasBora> putStrLn "User"; putStrLn getName; putStrLn " is not existing"
19:08:27 <geekosaur> that would be expected?
19:08:31 <Welkin> lol
19:08:36 <tobiasBora> indeed, the first version displayes only " is not existing", and put "getName" partly AFTER the string "is not existing"
19:08:58 <geekosaur> uh
19:09:06 <geekosaur> stty sane
19:09:23 <tobiasBora> geekosaur: hum sorry, I mean instead of reading "User toto is not existing", I have something like "not existing.to"
19:09:28 <tobiasBora> I'm using ssh
19:09:38 <tobiasBora> and multicore
19:09:58 <tobiasBora> but the version works great on my debian
19:10:03 <tobiasBora> and actually
19:10:19 <tobiasBora> it should not even say "user not existing", because the user is existing...
19:10:39 <tobiasBora> So there are really strange things that happened, and I can't explain it. It's dark magic!
19:10:45 <geekosaur> actually I want to see that output sent to a file, then cat -v. sounds like something has a \r embedded
19:10:57 <geekosaur> ... did you read that username from the terminal?
19:11:02 <Welkin> LOL
19:11:28 <monochrom> Trust only hex editors. Text editors lie.
19:11:48 <geekosaur> if you did then you definitely want to run 'stty sane' and try it again, because your terminal may be in raw mode
19:11:49 <monochrom> Well, text editors try to protect you from the ugly truth.
19:11:52 <tobiasBora> geekosaur: I read the username from a file, maybe with DOS lines
19:11:59 <geekosaur> DOS lines would do it
19:12:09 <geekosaur> you will need to strip trailing '\r'
19:12:21 <tobiasBora> I'll try to remove them
19:12:40 <geekosaur> so it's looking for toto\r (control-M) and outputting the \r also in the error message
19:12:52 <Welkin> toto?
19:13:01 <Welkin> toto\ro ?
19:13:07 <geekosaur> presumably because the program's not in Kansas any more
19:13:09 <monochrom> heh
19:15:21 <tobiasBora> geekosaur: Hum you are my god
19:15:38 <tobiasBora> I convert the file in unix and it works great
19:15:59 <geekosaur> man, if that's all it takes to become a god...
19:16:01 <robertkennedy> Sorry, does getName have type string?
19:16:05 <tobiasBora> I would spend something like 2 month to debug that!
19:16:19 <sophiag> dmwit: sorry, i got interrupted. what i gathered is that i need to extract the middle term in that function before i try to match for the "+" symbol whereas that wasn't necessary when it was the third term since it was the same type as the whole thing?
19:16:19 <tobiasBora> robertkennedy: yes
19:16:38 <geekosaur> embedded carriage returrns are a think you learn to recognize from that kind of overprinted output
19:16:42 <geekosaur> *thing
19:18:11 <sophiag> or if anyone else wants to take a look...i'm trying to figure out this error parsing the AST of a lambda: http://lpaste.net/354083
19:21:58 <tobiasBora> geekosaur: What is \r supposed to do on linux terminal?
19:22:04 <tobiasBora> I though that it was like nothing
19:22:07 <robertkennedy> My earlier statement that `f :: a -> T` requires a constraint might be disproved by `f = maybe 0 id . listToMaybe . toBits` if toBits didn't have a constraint
19:22:12 <tobiasBora> but it seems it's not...
19:22:42 <robertkennedy> *maybe False id
19:22:47 <geekosaur> tobiasBora, unixlikes convert \r to \n on input and \n to \r\n on output
19:23:00 <geekosaur> which is why the "stty sane" I suggested; it restores that behavior, among others
19:23:27 <monochrom> \r tells the cursor to go back to the left edge of the terminal.
19:23:32 <tobiasBora> But why does the "User" has been deleted if \r is only a newline?
19:23:45 <geekosaur> (line oriented programs behave oddly with `stty -icrnl`. and the output is stairstepped without `stty onlcr`
19:24:08 <geekosaur> tobiasBora, \r reset tho the beginning of the same line, then the rest of the message overwrote it
19:24:22 <geekosaur> *to the
19:25:04 <geekosaur> this is how programs like wget/curl show progress reports for transfers, for each update it writes \r and outputs the latest status
19:25:09 <geekosaur> overwriting the previous one
19:25:49 <geekosaur> or apt-get update, for that matter
19:25:53 <sophiag> geekosaur: i never knew that. clever :)
19:26:01 <monochrom> "working on it" and then 10 seconds later "\rFinished!           " is how a lot of low-tech programs first print "working on it" when it is not done, and overwrite it with "Finished!" when done.
19:27:07 <tobiasBora> Hum...
19:27:21 <MarcelineVQ> is there a goto lib for drawing visual data graphs in haskell? mostly in my case to the screen for debugging purposes. I think these are also called charts
19:27:22 <geekosaur> back when terminals were (loud) printing terminals, you had to output the carriage return and newline separately, and there needed to be a delay during the carriage return or it would start overprinting while the print head was still moving back :)
19:27:24 <tobiasBora> geekosaur: monochrom Ok great thank you!
19:27:44 <tobiasBora> I understand everything better now
19:27:51 <tobiasBora> Now another strange thing:
19:28:47 <sophiag> MarcelineVQ: someone in my local Haskell user group was asking that last weekend. i'm trying to remember what she ended up using
19:28:49 <geekosaur> MarcelineVQ, graphviz package is most common that I've seen
19:28:52 <Conjecture> How easy can C programs use Haskell libraries?
19:29:00 <Conjecture> easily*
19:29:03 <tobiasBora> if my program deal with a small entry, everything is fine
19:29:18 <Conjecture> Do I have to use a complicated interface like the one Python has for that?
19:29:30 <sophiag> MarcelineVQ: i think this: https://hackage.haskell.org/package/Chart
19:29:34 <geekosaur> Conjecture, there's some work involved https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/ffi-chap.html#making-a-haskell-library-that-can-be-called-from-foreign-code
19:30:08 <tobiasBora> but if I take a really big file in input, the CPU loads to 100%, and after a few seconds, I've an error "process stopped" (translated from french)...
19:30:09 <geekosaur> you still have to deal with the fact that haskell has its own runtime that needs to be initialized and deinitialized
19:30:32 <geekosaur> tobiasBora, sounds like you have a memory leak and the out-of-memory killer is getting invoked.
19:30:45 <MarcelineVQ> geekosaur, sophiag: thank you
19:31:07 <sophiag> np
19:31:30 <tobiasBora> geekosaur: Indeed the RAM explodes
19:31:56 <tobiasBora> is there any way to know where I do the memory leaks?
19:32:37 <Conjecture> geekosaur, Is it really slow like the FFI interface for Python?
19:32:52 <Conjecture> Where, when it's not slow it's very slow
19:33:23 <geekosaur> compile with profiling (note you'll need to recompile for profiling any packages you use as well) and run with +RTS -h
19:33:50 <geekosaur> Conjecture, python is interpreted, haskell is compiled to native code. although if you write it wrong it can be slow, it's rarely as slow as an interpreted language
19:34:24 <geekosaur> also the border between C and Haskell will force evaluation (C has no idea what to do with a Haskell lazy value) which will tend to make things get done in a timely manner
19:35:03 <Conjecture> Thanks geekosaur
19:35:08 <geekosaur> tobiasBora, https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/profiling.html#profiling-memory-usage 
19:35:57 <geekosaur> I would then run it with a small file and see if it shows anything accumulating that shouldn't
19:36:19 <geekosaur> don't use the big one, when the program is killed it's a force-kill that won't finish heap profiling properly
19:39:42 <okra_> i'm trying to do bounded enumeration of CFGs (i.e., enumerate all strings using <= k productions). I wrote some code which seems right but behaves weirdly; anyone mind taking a look? http://lpaste.net/354088
19:40:41 <okra_> by "behaves weirdly" i mean "only ever generates digits and the string '1+1'"
19:40:52 <sophiag> geekosaur: since (i think?) you're the one who recommended i use haskell-src-exts, do you have any idea what i'm doing wrong trying to parse this one? http://lpaste.net/354083
19:46:39 <geekosaur> sophiag, the second one is fairly obvious, a QOp is a token not a function
19:47:15 <sophiag> i didn't think it was a function
19:47:51 <sophiag> it's the type of the part of the AST i'm matching
19:48:02 <geekosaur> but you produce Just (+) while claiming tits type is Maybe QOp
19:48:08 <geekosaur> *its type
19:48:15 <geekosaur> grrh where is my typing tonight
19:48:38 <sophiag> is QOp not the type of infix operators?
19:48:53 <geekosaur> infix operators *in the AST*
19:49:11 <geekosaur> not infix operator implementations, which is what (+) in Haskell code gives you
19:49:17 <lyxia> okra_: it's working just fine here
19:49:36 <sophiag> ah ok. that makes sense. i think ghc's error messages were just making me more confused
19:49:41 <geekosaur> QVarOp (UnQual (Symbol "+"))    <-- this is a QOp
19:49:46 <sophiag> yup
19:50:01 <sophiag> so...is (+) actually the type of itself?
19:50:12 <geekosaur> amd that's where the first error comes from, because: Lambda l [Pat l] (Exp l)
19:50:38 <geekosaur> (+) is a function, here inferred with type Integer -> Integer -> Integer
19:50:45 <sophiag> ah ok
19:50:46 <geekosaur> it is not an AST node
19:50:52 <sophiag> that's where that comes from...
19:51:00 <geekosaur> it is the actual implementation, not a syntax tree representation of it
19:51:33 <Koterpillar> (+) is not "+" either
19:52:10 <geekosaur> as for the first error, you have that Lambda I mentioned
19:52:12 <okra_> lyxia: sorry, i'm dumb -- I had a `take 10' in front of everything
19:52:23 <geekosaur> it's going to expect something of the form: InfixApp l (Exp l) (QOp l) (Exp l)
19:52:34 <Gurkenglas_> okra_, I have a simplification, interested in it or want to work on it yourself?
19:52:35 <okra_> appreciate it though
19:52:35 <geekosaur> but you gave it just the QOp
19:52:36 <sophiag> oh, i want to use "Just +" with type (Integer -> Integer -> Integer) to get the infix version, yes?
19:53:08 <geekosaur> I can't tell; I don't know what you are doing with the result of parseSymbol
19:53:08 <lyxia> okra_: :)
19:53:14 <okra_> Gurkenglas_: interested -- what kind of simplification?
19:53:15 <geekosaur> it may be that you don't want the type to be Maybe QOp
19:53:45 <geekosaur> but you probably can't use Maybe (Integer -> Integer -> Integer) because then you can only handle operators that have that type
19:53:47 <sophiag> i changed it to be Maybe (Integer -> Integer -> Integer)
19:54:01 <geekosaur> so you can't handle, say, "/"
19:54:02 <okra_> I guess there's another approach which is more obviously a breadth-first search
19:54:03 <sophiag> but then i changed it to return "Just x"
19:54:06 <geekosaur> or "++"
19:54:27 <sophiag> yup, many infix operators
19:54:48 <sophiag> oh, i'll need a seperate function for the ones that return booleans tho
19:55:00 <geekosaur> you'll need something that can represent all of those, possibly via an ADT. Id not try to use the actual (+) here but an ADT of operator internal representations and then map the internal tag to the actual operator if I need to evaluate later
19:55:29 <geekosaur> also, there are user defined operators
19:55:36 <sophiag> ugh, that's exactly what i was trying to avoid since i realized today i could just store lambdas in a list
19:56:00 <sophiag> i have this: data LambdaType a = LambdaType [a -> Bool]
19:56:17 <sophiag> with ExistentialQuantification for the record it's stored in
19:56:55 <geekosaur> that could be a problem since you can't do much with something under existential quantification
19:57:05 <Gurkenglas_> okra_, lines 14 and 15 are "enumSyms k es = fmap concat $ traverse (enumBounded k) es", and if you pull line 13 into the definition of enumBounded you can eta-reduce and inline enumSyms
19:57:12 <geekosaur> but ... this is a hard problem in general
19:57:17 <sophiag> i figured it would be okay given what i'm using it for
19:57:37 <sophiag> like i know what i'm doing with these and i'll be certain the types match based on matching the other field in the records
19:57:53 <geekosaur> but you have to convince Haskell of that, and that can be tricky
19:57:54 <sophiag> but you may have a point regarding the boolean operators
19:58:25 <sophiag> i'm wondering if i can use type variables for the boolean infix operators, so like (a -> a -> Boolean) ?
19:58:42 <sophiag> oh and maybe a constraint of Eq
19:58:47 <sophiag> Eq and Ord
19:58:51 <sophiag> depending
19:59:05 <sophiag> oh actually i don't need Ord (sorry for talking out loud)
19:59:31 <ChaiTRex> sophiag: Yes.
19:59:33 <ChaiTRex> :t (==)
19:59:34 <lambdabot> Eq a => a -> a -> Bool
19:59:41 <sophiag> :)
19:59:58 <okra_> Gurkenglas_: interesting, that's very neat - thanks!
20:00:04 <sophiag> anyway, i have to get going home to bed...but i'm hoping to get this function at least parsing one operator so i can generalize it tomorrow
20:00:27 <ChaiTRex> sophiag: The only ones that work without constraints are f _ _ = True or f _ _ = False or f _ _ = undefined
20:00:50 <sophiag> that should be fine for my purposes
20:01:24 <sophiag> geekosaur: now that i have the right type signature for that function and switched to returning infix + i'm just getting a weird "parse error" on the last line
20:01:33 <Gurkenglas_> (okra_, also I expect that ekmett's free package can eliminate all explicit recursion there)
20:01:59 <geekosaur> sophiag, can you update your paste?
20:02:06 <okra_> cool, I'll check it out
20:02:20 <sophiag> sure
20:03:03 <okra_> I've read enough about Traversable and Free but never actually used them of my own volition before
20:03:23 <sophiag> geekosaur: http://lpaste.net/354083
20:03:42 <geekosaur> it has to be  Just (+)
20:03:55 <geekosaur> because you're referring to the operator by name, not trying to apply it
20:04:20 <sophiag> oh ok
20:04:37 <geekosaur> `Just +` would be an incomplete addition of Just to something else; if it got past the parse error it'd complain about a missing Num instance for a -> Maybe a
20:04:38 <sophiag> but then i get the type error again...that's why i didn't think that was the problem when i tried it :/
20:04:56 <geekosaur> What's the exact type error now?
20:05:08 <geekosaur> (At a guess, you lost whatever was specializing to Integer or you need to do that yourself
20:05:11 <geekosaur> :t (+)
20:05:13 <lambdabot> Num a => a -> a -> a
20:05:28 <sophiag> " Couldn't match expected type ‘Exp’ with actual type ‘QOp’"
20:05:43 <geekosaur> yes, that's a different error
20:05:48 <geekosaur> I tried to explain that one earlier
20:06:03 <geekosaur> [30 02:49:50] <geekosaur> amd that's where the first error comes from, because: Lambda l [Pat l] (Exp l)
20:06:12 <geekosaur> [30 02:52:00] <geekosaur> it's going to expect something of the form: InfixApp l (Exp l) (QOp l) (Exp l)
20:06:13 <sophiag> oh should it be Exp -> QOp -> Maybe ?
20:06:29 <sophiag> i understood you, but not the implications for the type signature
20:06:40 <geekosaur> you need to extract the QOp from the InfixApp inside the Lambda
20:06:55 <geekosaur> (InfixApp is one of the constructors for Exp)
20:07:08 <sophiag> ah, that's what i thought earlier i just wasn't sure how to do it
20:07:18 <sophiag> i tried adding holes and it kept throwing erros
20:07:24 <sophiag> *rs
20:08:17 <sophiag> i figured it should be something like "(Lambda _ _ (_ expr _))"
20:08:31 <sophiag> or similar in the case or a let 
20:08:43 <geekosaur> possibly: InfixApp _ _ (QVarOp (UnQual (Symbol "+"))) _
20:08:52 <sophiag> ah
20:08:54 <sophiag> lemme try it
20:09:33 <sophiag> :D
20:09:33 <geekosaur> because thelambda doesn;t just have the operator, it's an expression applying the operator (an InfixApp)
20:09:40 <sophiag> except you accidentally gave it four arguments
20:10:08 <sophiag> well InfixApp is a constructor for QOp
20:10:14 <sophiag> or sorry
20:10:17 <geekosaur> no, it's a constructor for Exp
20:10:21 <sophiag> yup
20:10:25 <geekosaur> which is what you pulled out of the Lambda
20:10:30 <sophiag> right
20:10:50 <geekosaur> and the QOp is buried within it
20:10:51 <sophiag> i wonder if i also could have matched it in the argument?
20:10:59 <geekosaur> yes
20:11:18 <sophiag> like (Lambda _ _ (InfixApp _ expr _))?
20:11:24 <geekosaur> the pattern might get a bit painful to work with though; sometimes breaking it up saves your sanity later
20:11:32 <sophiag> true
20:11:41 <sophiag> i still didn't break it up much tho
20:11:42 <geekosaur> something like that, yes
20:12:50 <sophiag> phew
20:12:57 <sophiag> well thanks for the help
20:13:13 <sophiag> working with these ASTs has certainly been a learning experience, but it was the best choise
20:13:16 <sophiag> *choice
20:13:47 <sophiag> i may still use Parsec for the parts that are just strings tho
20:14:11 <sophiag> especially since i'm using a State monad to cons my records together
20:14:36 <sophiag> geekosaur: how's your sinus infection?
20:16:10 <geekosaur> it's not an infection, sadly. it's genetic. if Someone will keep their hands off health care (such as it is) for a few months, it might get surgery
20:17:22 <kadoban> geekosaur: In case you're serious, it's quite unlikely that anything will change with health insurance that quickly. It's usually on the timeframe of at least a year or two.
20:18:14 <geekosaur> surgery's not happening in just a few months either :/ but that was kinda executive summary; it's complex
20:18:28 <sophiag> ah, my mother had the surgery where the scrape out your sinuses to widen them
20:18:44 <sophiag> i think before it was laser and they used a knife on the end of a tube...
20:18:53 <geekosaur> yeh, that's at least part of what needs to happen. have actually needed it for a few decades but previous insurance refused to cover it
20:19:16 <geekosaur> so it's pretty bad now :/
20:19:21 <sophiag> well at least while we have the aca you should be able to have it covered through the independent review board
20:20:19 <sophiag> appeals are pretty fast now so you just go through two of those and then either that board or a fair hearing with a judge. the former seems better since it's just doctors deciding. you basically get your doctor to write a comprehensive letter of medical necessity citing statements by professional bodies on its efficacy and such
20:20:35 <sophiag> (can you tell i have numerous medical issues? lol)
20:20:57 <geekosaur> heh. know thta one, but aside from the sinuses most of mine are neurological
20:21:04 <sophiag> ah me too
20:21:12 <sophiag> Chronic Migraine disorder
20:21:29 <sophiag> i just had botox injected in 31 spots of my face, head and neck
20:21:37 <sophiag> nearly passed out in the middle...
20:22:02 <Welkin> o.o
20:22:15 <sophiag> i tell people chronic pain is why i switched to functional programming. i don't have enough working memory to manage state ;)
20:23:09 <sophiag> anyway, i have to run home and get some sleep. thanks for the help!
20:23:19 <geekosaur> no problem
20:25:13 <Gurkenglas_> okra_, feels like it should end up looking sorta like this http://lpaste.net/354088#a354090
20:26:17 <okra_> Gurkenglas_: that's quite nice; I'll think about that for a bit -- thanks!
20:28:14 <Welkin> sitting in a chair all day doesn't help keep you healthy either
20:28:41 <Welkin> I've been sitting too much lately, especially slouched over, debugging javascript
21:20:51 <lifter> Are Emacs (not Spacemacs) users typically using Intero?
21:21:00 <lifter> Sounds like it's the easiest way to get up and running...
21:23:48 <lifter> (for those using Stack, that is...|
21:27:47 <jmcarthur> I use Spacemacs+Intero, but if I were to go to non-Spacemacs Emacs, I would also go with Intero.
21:29:09 * jao uses intero with plain emacs
21:30:56 <lifter> Nice.
21:55:17 <cocreature> infandum: no, foldr requires an "Unbox" constraint
22:01:35 <vaibhavsagar> what is the process for upgrading containers on Stackage?
22:01:53 <vaibhavsagar> It doesn't look like the maintainers are interested in doing this https://github.com/haskell/containers/issues/420
22:03:04 <kadoban> vaibhavsagar: I believe that every package on stackage is required to have a maintainer, I'd probably check who that is and how to contact them.
22:03:17 <kadoban> Though isn't containers something that comes with GHC? Or am I confused?
22:05:30 <vaibhavsagar> kadoban: it is. Does that mean there's no way to upgrade it in a package set?
22:06:40 <kadoban> I ... don't really know. I'd think it'd have to be tied to the version of GHC that a resolver uses?
22:08:28 <vaibhavsagar> how come NixOS gets the latest version without also using GHC 8.2?
22:23:48 <cocreature> vaibhavsagar: stackage should upgrade containers automatically once no other packages have restrictive bounds
22:24:33 <cocreature> ah no I think kadoban mentioned the important point: containers comes with GHC and iirc stackage does not upgrade these packages without upgrading GHC
22:24:48 <cocreature> despite this being possible for some packages, e.g., containers
22:26:12 <kadoban> vaibhavsagar: If nothing else you could try upgrading it yourself as an extra-dep, I guess.
22:26:34 <kadoban> You can refer to a git repo or whatever, it's pretty painless once you find the weird syntax.
22:26:59 <cocreature> you can also just refer to the hackage release
22:33:44 <kadoban> Oh, right, also that. Much easier.
22:38:06 <vaibhavsagar> I tried this, worked great :)
22:55:46 <fred-fri> how do i shove a function that accepts a String into IO [String]?
22:57:59 <kadoban> :t \f -> fmap (map f)
22:58:00 <lambdabot> Functor f => (a -> b) -> f [a] -> f [b]
22:58:30 <kadoban> fred-fri: That ^
23:06:24 <pavonia> Similar question, is there already a function :: Monad m => m [a] -> (a -> m b) -> m [b]?
23:06:54 <c_wraith>  :t forM
23:07:03 <c_wraith> :t forM
23:07:05 <lambdabot> (Monad m, Traversable t) => t a -> (a -> m b) -> m (t b)
23:07:17 <c_wraith> darned spacebar
23:07:40 <pavonia> That's close but not close enough
23:08:19 <c_wraith> in what way?
23:08:20 <pavonia> :t join . forM
23:08:21 <lambdabot> error:
23:08:21 <lambdabot>     • Occurs check: cannot construct the infinite type:
23:08:21 <lambdabot>         m ~ (->) (a -> m b)
23:08:41 <pavonia> c_wraith: The first argument should be in m too
23:08:53 <c_wraith> ah, missed that
23:09:03 <cocreature> :t fmap fmap fmap join forM
23:09:04 <lambdabot> (Traversable m, Monad m) => m a1 -> (a1 -> m a) -> m a
23:09:38 <cocreature> but it does incur an additional constraint
23:10:05 <c_wraith> that's not quite the same, because you can't use it with m other than []
23:10:32 <cocreature> c_wraith: you can use it with anything that’s Traversable, not only [], right?
23:10:57 <c_wraith> cocreature: actually, it doesn't work at all.  you can't pass an m [a] to that
23:11:07 <cocreature> oh right, silly me
23:11:22 <c_wraith> well, not to get the intended result, anyway
23:11:37 <c_wraith> I mean.. 
23:11:55 <c_wraith> :t \x y -> mapM y =<< x
23:11:56 <lambdabot> (Traversable t, Monad m) => m (t a) -> (a -> m b) -> m (t b)
23:12:10 <c_wraith> it's not quite a single function anymore
23:12:37 <fred-fri> kadoban, cheers. i'm afraid i'm to dumb to figure it out despite your reply. https://pastebin.com/Hkr62f5i
23:13:36 <kadoban> fred-fri: Ah, so "lines" should actually be type [String] there, if that helps (and if I'm not massively confused somehow)
23:13:47 <pavonia> @pl \x y -> mapM y =<< x
23:13:48 <lambdabot> (. mapM) . (>>=)
23:14:05 <kadoban> fred-fri: So you'd probably jsut do uhm  let foo = map someFunc lines
23:14:17 <pavonia> I guess the pointed version is fine too, thanks!
23:15:43 <kadoban> fred-fri: Or if you want to do it in one go, that's possible, but not really preferable I'd say.   (lines <- map someFunc <$> replicateM noOfLines getLine) probably
23:16:17 <jle`> what can i do to get a MonadIO instance for Proxy into the next release of base
23:16:19 <fred-fri> kadoban, oh, my mistake was actually doing foo <- map parse lines instead of just let foo = map parse lines
23:16:29 <fred-fri> where parse is the function that accepts a string
23:16:59 <kadoban> Ah, yep
23:17:16 <fred-fri> in any case, thanks
23:17:38 <kadoban> Anytime
23:17:49 <c_wraith> jle`: email the libraries mailing list.  Include a convincing argument that it's a good idea. :)
23:18:19 <jle`> it's not only a good idea, it's the best idea
23:18:21 <c_wraith> jle`: though it's probably too late to get into the next release if it's controversial at all.
23:18:37 <jle`> thanks :)
23:19:45 <c_wraith> I guess it trivially obeys the laws
23:20:16 <jle`> i consider it the quintessential platonic MonadIO instance
23:20:28 <jle`> that's going to be my pitch, at least
23:21:29 <c_wraith> most people have some expectation that it in addition to obeying the laws, it doesn't discard the IO actions though. :)
23:22:10 <jle`> maybe it can be considered a terminal object in some sense
23:23:09 <cocreature> jle`: do you have any useful applications for that instance?
23:23:38 <jle`> it can be used in the case where you want to suppress IO, maybe
23:23:49 <jle`> if you had a polymorphic `MonadIO m => m a` value
23:23:56 <jle`> you can instantiante m as IO, if you want the effects
23:23:59 <jle`> or m as Proxy, if you don't
23:24:08 <cocreature> you can just not execute the action if you don’t care about the effects :)
23:25:02 <jle`> hm
23:25:18 <jle`> oh, you can use it as the start of a chain of monad transformers
23:25:19 <cocreature> I’m not saying that the instance shouldn’t exist but I kind of doubt it’s ever going to be useful
23:25:27 <jle`> instead of IO
23:25:43 <jle`> to give the stack a MonadIO instance
23:26:02 <jle`> but have it not exeute any IO effects in the process of computation
23:26:31 <jle`> (this one i'm just joking on)
23:27:01 <jle`> `StateT s Proxy` -- it's MonadIO, but suppresses IO effects!
23:27:03 <jle`> ha ha
23:27:14 <cocreature> heh
23:27:25 <jle`> still though >_>
23:27:28 <c_wraith> add ProxyT while you're at it!
23:27:51 <cocreature> now I’m disappointed that ProxyT is not a thing
23:28:07 <jle`> type ProxyT = Tagged   ..?
23:28:16 <c_wraith> nah, Tagged actually carries a value
23:28:23 <c_wraith> ProxyT should have *two* phantom type variables
23:28:36 <c_wraith> If one is good, two is clearly twice as good.
23:28:58 <jle`> instance MonadTrans ProxyT
23:29:00 <cocreature> you don’t even need the Monad instance on the inner monad to provide a Monad instance for ProxyT!
23:29:33 <glguy> StateT s Proxy a suppresses more than the IO effects
23:29:40 <jle`> it'd have a very nice MFunctor instance
23:30:47 <jle`> maybe in a sense we can think of Proxy as a Zero/absorber for composition of monads/functors/applicatives
23:30:53 <raduom> Hi. Is there a package that provides the Free monads, algebras things (including interpreters and algebras composition) for haskell?
23:31:03 <jle`> such that for all x,  x*0 = 0
23:31:19 <raduom> I know there is a free package, but it lacks the compositional aspects.
23:31:24 <jle`> raduom: the free package is the canonical source of that
23:31:27 <Conjecture> The multiplicative property of zero
23:31:39 <jle`> raduom: but composition tools are already in base
23:31:47 <jle`> raduom: base gives you functor products, functor sums, and functor composition
23:31:55 <Conjecture> The multiplicative property of 1 is: for all x, x *1 = x
23:32:08 <jle`> Conjecture: yes, so in this case, Identity is 1, and Proxy is 0
23:32:18 <raduom> ok. thanks.
23:32:22 <jle`> so Proxy needs a MonadIO instance to continue this metaphor
23:32:39 <jle`> and there should be a ProxyT too, of course
23:32:56 <jle`> adding ProxyT anywhere along your monad transformer stack should kill all effects, up and down stream
23:32:56 <Conjecture> jle`, Were you explaining the compiler optimizer or something?
23:33:14 <jle`> Conjecture: i'm talking about the role of Proxy in the composition of functors
23:33:35 <Conjecture> ok
23:34:09 <jle`> Proxy acts as a zero in the sense that x*y*Proxy*z*k = Proxy, and Identity is a one in the sense that x*y*Identity*z*k = x*y*z*k
23:35:00 <jle`> the MonadIO instance for Proxy can be thought of an instance for MonadIO m => ProxyT m
23:35:15 <jle`> so it's perfectly sound
23:35:27 <jle`> or i mean, it's extremely significant
23:35:43 <jle`> in the theory of functor composition.  so it should be in base.
23:35:49 <jle`> ok there's my pitch, thanks for helping me hash it out
23:36:47 <nathyong> OK, I've isolated that bug that I had regarding Tasty's timeouts
23:36:50 <nathyong> https://gist.github.com/anonymous/84e8dee1a0cae6bc4257f58ccba33d43
23:37:08 <nathyong> main = timeout 1000000 (putStrLn (infinite "Hi")) >> return ()
23:37:10 <nathyong>   where infinite x = infinite x
23:37:12 <nathyong> ^ or rather, that
23:37:21 <nathyong> this has been reported to run on Linux, but not on OSX, when compiled
23:38:07 <c_wraith> yeah, I've had issues with that on OS X for a long time
23:38:22 <nathyong> any solutions? This seems like it'd break a lot of stuff
23:38:49 <c_wraith> it seems to have something to do with threadDelay being given a large number as input
23:39:00 <c_wraith> and timeout is implemented in terms of threadDelay
23:39:32 <c_wraith> I worked around it poorly, by figuring out how to give it smaller numbers
23:40:22 <nathyong> ugh, that's not what I wanted to hear... but all right
23:41:33 <c_wraith> hmm.  apparently the thing I ran into was fixed.
23:41:40 <nathyong> Yeah, in 8.2
23:41:43 <nathyong> https://ghc.haskell.org/trac/ghc/ticket/7325
23:42:01 <nathyong> c_wraith: thanks for your help with that though, I'm glad I was able to track it down
23:42:07 <nathyong> it was driving me nuts all afternoon
23:42:15 <Cale> Does it have anything to do with allocation or lack thereof?
23:43:22 <nathyong> Cale: if I change the function to a more 'interesting' function (say, infinite x = infinite (x-1)) then it'll be a little more reliable
23:43:55 <Cale> A little more reliably buggy, or it will always timeout correctly?
23:44:17 <pavonia> Is there a way to re-export an imported function without giving a full export list for that module?
23:45:21 <nathyong> it will timeout correctly, unless the `infinite` function is imported from another module
23:45:29 <nathyong> Cale: ^
23:45:43 <Cale> Interesting.
23:45:57 <Cale> The thing is, timeout presumably kills the action you give it by forking a thread for it to run in, and then throwing an exception at it with killThread
23:46:18 <nathyong> I feel like it's a slightly different bug to the one I linked, though
23:46:23 <Cale> Threads can only receive an asynchronous exception like that when they allocate memory
23:46:38 <nathyong> runtime issue?
23:47:10 <Cale> Well, that's just how the runtime works.
23:47:35 <nathyong> Fair enough, then
23:49:12 <Cale> When you put the function in another module... I'm not really sure why that would make a difference, but if it were compiled differently, I can imagine in some cases that might still result in a loop which doesn't do allocation.
23:50:28 <nathyong> Yeah I was going to inspect the code, but I've got no idea why that would be the case
23:50:46 <Cale> Yeah, maybe try having a look at the output of -ddump-simpl
23:51:02 <Cale> and see what the simplifier has done with your function :)
23:51:07 <nathyong> I'll come back to this after some foo
23:51:08 <nathyong> d
23:53:53 <Cale> nathyong: Ah, yeah, it's clever, it eliminates the number argument altogether, realising that it's dead.
