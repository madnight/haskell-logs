00:09:17 <pavonia> CMCDragonkai: catMaybes <$> count 5 (optional $ satisfy isDigit) or something
00:17:47 <CMCDragonkai> optional gives ReadP (), not Maybe
00:18:35 <CMCDragonkai> i can think of a [parse5, parse4, parse3, parse2, parse1] and then fold with symmetric choice
00:18:53 <CMCDragonkai> actually (<++) choice
00:18:59 <CMCDragonkai> but that seems inefficient
00:19:10 <cocreature> CMCDragonkai: you can probably use "optional" from Control.Applicative which does return a Maybe
00:19:30 <pavonia> ^ Yeah, that's the optional I had in mind
00:19:45 <cocreature> tbh the optional in ReadP seems really weird
00:26:19 <CMCDragonkai> Is this what you are thinking?
00:26:22 <CMCDragonkai> > readP_to_S p "12345"
00:26:24 <lambdabot>  error:
00:26:24 <lambdabot>      Variable not in scope: readP_to_S :: Expr -> [Char] -> t
00:26:25 <CMCDragonkai> [("","12345"),("1","2345"),("1","2345"),("1","2345"),("1","2345"),("1","2345"),("12","345"),("12","345"),("12","345"),("12","345"),("12","345"),("12","345"
00:26:27 <CMCDragonkai> ),("12","345"),("12","345"),("12","345"),("12","345"),("123","45"),("123","45"),("123","45"),("123","45"),("123","45"),("123","45"),("123","45"),("123","45
00:26:29 <CMCDragonkai> "),("123","45"),("123","45"),("1234","5"),("1234","5"),("1234","5"),("1234","5"),("1234","5"),("12345","")]
00:26:31 <CMCDragonkai> it :: [([Char], String)]
00:26:51 <CMCDragonkai> Is there a way to make it greedy?
00:27:00 <CMCDragonkai> Greedy up to say 5
00:28:15 <CMCDragonkai> there's a lot fo repetition there, 1 for each of the rest of the numbers, then 2 for each of the rest of the numbers... etc
00:28:20 <nshepperd_> I would use direct recursion to do liftA2 (:) digit (empty <|> liftA2 (:) digit (...))
00:28:37 <nshepperd_> That way it should avoid any backtracking?
00:33:53 <nshepperd_> Oh, reverse those choices to make it greedy
00:36:07 <CMCDragonkai> nshepperd_: are you referring to your example or the previous example?
00:36:20 <nshepperd_> My example
00:36:46 <CMCDragonkai> is there no way to use just 2 numbers like in regex?
00:37:18 <nshepperd_> You could package this up into a function
00:38:20 <CMCDragonkai> This is what I'm doing now:
00:38:23 <CMCDragonkai> foldr1 (<++) $ fmap (\x -> count x $ satisfy isDigit) [5,4..1]
00:38:41 <CMCDragonkai> > readP_to_S p "123456789"
00:38:43 <CMCDragonkai> [("12345","6789")]
00:38:43 <lambdabot>  error:
00:38:43 <lambdabot>      Variable not in scope: readP_to_S :: Expr -> [Char] -> t
00:40:41 <nshepperd_> upTo 0 _ = pure []; upTo n p = liftA2 (:) p (upTo (n-1) p) <|> pure []
00:42:34 <nshepperd_> between x y p = liftA2 (count x p) (upTo y p between)
00:43:30 <nshepperd_> Er, between x y p = liftA2 (count x p) (upTo (y-x) p between)
00:43:45 <nshepperd_> Something like that
00:44:24 <nshepperd_> To match between 1 and 5 digits first match a digit, then match between 0 and 4 digits
00:44:25 <CMCDragonkai> Oh the upTo is certainly better, but it still gives me
00:44:29 <CMCDragonkai> readP_to_S (upTo 5 digit) "123435456789"
00:44:32 <CMCDragonkai> [("","123435456789"),("1","23435456789"),("12","3435456789"),("123","435456789"),("1234","35456789"),("12343","5456789")]
00:44:48 <CMCDragonkai> As in, I still have then !! 5 to get the the greedy version
00:45:32 <nshepperd_> Hm, that doesn't seem right
00:46:26 <nshepperd_> The greedy option should come first if the <|>s are done in the right order
00:47:17 <reactormonk> I'm trying to follow the free monad definition - https://gist.github.com/55972ba5a1b95077c46ee872679cd169 - I figured getting the type of (>>= k) would be helpful to understand it. How do I get it? Currently using emacs.
00:53:23 <CMCDragonkai> nshepperd_: Your latest one seems pretty much equivalent to: choice $ fmap (\x -> count x $ satisfy isDigit) [5,4..1]
00:53:43 <CMCDragonkai> nshepperd_: Or: choice $ fmap (\x -> count x $ satisfy isDigit) [1..5]
00:54:41 <quchen> reactormonk: »impure« is a terrible name for the other constructor of Free.
00:56:18 <quchen> There’s nothing impure about monads, and nothing impure about bind. »BindFree« would be a better choice, for example.
00:57:30 <Owatch> Hello. 
00:57:47 <Owatch> Is there any way I can instruct haskell how to derive a type I've made? 
00:58:12 <Owatch> I've got a Node with a Point (x,y) and a value (float). I want it to be ordered by Value. 
00:58:39 <cocreature> Owatch: do you want to derive an Ord instance for Point?
00:58:57 <Owatch> I want to derive an Ord instance for Node, based off value. I.E: Order by value
00:59:08 <quchen> There is no way to influence auto-deriving typeclasses.
00:59:11 <Owatch> Not the coordinate of the Node. 
00:59:45 <cocreature> either the autoderived instance works for your application or you have to write one manually
01:00:00 <Owatch> Well I guess I can try to test and see if it picks up what I want. 
01:01:00 <cocreature> if you care about the result of the Ord instance and do not just need an Ord instance to put things in a Map or something like that, write it yourself
01:01:41 <cocreature> it’s only two lines or something like that
01:02:13 <Owatch> Ah, if its that simple then maybe I will. As long as I don't need any non-default packages for it 
01:02:34 <cocreature> you definitely don’t need any packages for that
01:03:10 <cocreature> instance Ord Node where compare (Node val1 _) (Node val2 _) = compare val1 val2
01:03:27 <cocreature> you also want a custom Eq instance in that case.
01:04:50 <quchen> instance Eq Node where a == b = compare a b == EQ
01:04:51 <quchen> :-)
01:04:54 <Owatch> I'm quite new to this all. Do I just include that with my type declarations? 
01:05:49 <Owatch> And does that override deriving (Eq, Ord) or must I remove that line from my Data declaration? 
01:05:57 <cocreature> you must remove that line
01:06:43 <cocreature> and yes you just put this code in the same file as your type declaration
01:07:10 <Owatch> Okay, thank you.
01:07:16 <Owatch> How does the Eq one work? Eq Node where a == b = compare a b == EQ
01:07:34 <Owatch> Doesn't seem to be explicitly picking out the value like in Ord, and comparing them. 
01:07:56 <cocreature> Owatch: it just reuses the Ord instance
01:08:09 <Owatch> Ah okay. 
01:08:09 <quchen> Owatch: When you already know how to order things, you can find out whether two things are equal. You can spell out the equality yourself as well of course.
01:09:39 <quchen> instance Eq Node where Node (a,b) == Node (x,y) = a == x && b == y
01:09:55 <quchen> Like that, for example.
01:10:53 <Owatch> Yeah, that makes sense to me. At least how I would write it right now.
01:53:01 <Owatch> Can the same instance of a type exist in different lists? 
01:53:19 <merijn> Owatch: I'm not sure what you mean by that?
01:53:50 <Owatch> Example: I have a list of Nodes, which I put in a heap. As I extract from the Heap I mark the Node. But it needs to also do the same to the Node in the list. 
01:54:46 <Owatch> I can always search I guess. 
01:56:41 <merijn> Owatch: So you want the change to appear in the heap and the list?
01:57:03 <Owatch> Right. 
01:57:11 <merijn> Owatch: That's not possible at all with standard lists, etc. since the list and it's content is all immutable
01:57:48 <Owatch> Well, each type has a unique (x,y) point in it. So I guess I can search through my list with the one I extracted from the heap, and perform the change on it there. 
01:58:53 <merijn> Owatch: Well, why do you need to maintain the list at all?
01:58:59 <merijn> Owatch: What are you trying to do?
01:59:13 <Owatch> I'm finding a minimum spanning tree. 
01:59:18 <Owatch> Using Prim's algorithm. 
02:00:14 <Owatch> So I need to maintain a heap and a list. As I extract from the heap, I go through the list of all neighbors (AKA, all other nodes since it's a  EMSP) and add those whose current cost is greater than the distance between the extracted node and themselves. 
02:01:23 <Owatch> That involves marking the node I extracted as visited first, so I don't find itself and re-insert it. So I was asking if it would be possible to change a property that would reflect in the list. I guess not. So I'll do a slower search to set it first, then add the neighbors I guess. 
02:01:55 <merijn> Owatch: What representation are you using for the graph? (Also, what's EMSP?)
02:04:11 <Owatch> I'm using a Data type with a Visited flag (Bool), Value (Double), and a Point (x,y) to represent the graph. an EMSP is an MSP where you're computing the closest nodes by Euclidean distance (so straight line). It means there aren't a set amount of neighbors, and every other node is a potential neighbor.
02:04:40 <merijn> This assumes I know what MSP stands for :)
02:06:08 <merijn> I'm also rather unsure of how a point would represent a graph (or, I'm assuming it's supposed to represent a vertex, but I'm not sure how you'd do that using a point unless you have, like, a grid/mesh)
02:06:43 <Owatch> Oh, a list of points represents the graph. 
02:06:57 <Owatch> I just store all points with their coordinates
02:07:25 <Owatch> And that's my Graph. I don't need a grid or mesh. MSP means minimum spanning tree. So find the smallest set of edges that connect all nodes together. 
02:07:34 <Owatch> Or is the least costly in terms of distance. 
02:12:28 <merijn> Owatch: Oh, wait. So you have a collection of points in 2D space which you are treating as a fully-connected graph to compute the minimum spanning tree of
02:12:35 <Owatch> Yes.
02:13:45 <merijn> Honestly, personally I would probably use a mutable vector instead of a list to do this with
02:14:35 <merijn> Mostly because I tend to think a Compressed Sparse Row representation is the One True graph representation if you wanna be fast. Unless you have a small (<1k?) number of points
02:14:58 <Owatch> It can go to several million
02:16:05 <merijn> Actually, I'm not even sure a graph representation is the best way to go here at all. Maybe you want to use a metric tree to more quickly find nearby points
02:24:57 <Owatch> On an off note, are there any indexable lists in haskell?
02:25:55 <merijn> What do you mean by indexable list?
02:46:01 <stephA__> hi. Is there a pro or cons for using forM instead of mapM ? I don't see the difference except the order of the arguments. Am I wrong ?
02:46:20 <merijn> stephA__: They are the same, except for order
02:46:35 <merijn> stephA__: Basically, it depends how you want to partially apply
02:47:40 <lpaste_> merijn pasted “forM vs mapM” at http://lpaste.net/353967
02:47:46 <merijn> stephA__: Compare those two
02:49:06 <stephA__> nice example, thx
02:50:54 <Athas> I find that I use forM for imperative-ish code, and mapM for functional-ish code.
02:56:31 <unit73e> Hey. Does haskell have something equivalent to Scala `Option[String] = request getParameter "name"; name map { _.trim } filter { _.length != 0 } map { _.toUpperCase }` or you just do pattern matching instead?
02:56:54 <merijn> unit73e: Well, that depends on what the hell that does? :)
02:56:59 <yushyin> ^
02:57:58 <unit73e> merijn, it maps and filters if the name is Some[x] (or Just x in case of Haskell)
02:58:22 <merijn> unit73e: And what happens if it's Nothing?
02:58:34 <unit73e> merijn, returns Nothing
02:58:53 <merijn> unit73e: Then it's just "fmap" combined with map/filter, no?
02:59:09 <merijn> > fmap (map (+1)) $ Just [1..10]
02:59:11 <lambdabot>  Just [2,3,4,5,6,7,8,9,10,11]
02:59:13 <unit73e> merijn, hum I guess yeah
02:59:14 <mekeor> use `fmap (map foo . filter bar) x`
02:59:17 <merijn> > fmap (map (+1)) $ Nothing
02:59:19 <lambdabot>  Nothing
02:59:56 <unit73e> cool so that filter map thing just isn't generic
03:00:05 <unit73e> anyway it's this: http://www.scala-lang.org/api/2.12.x/scala/Option.html
03:00:12 <unit73e> in scala
03:00:14 <unit73e> thanks
03:01:03 <unit73e> I'll use that in the Java vs Scala vs Haskell Option thing I'm making :p
03:01:18 <Owatch> merijn: structures where I can access elements by providing an index. 
03:01:29 <Owatch> Like you would in most imperative languages
03:01:36 <merijn> Owatch: You probably want a vector? As in the vector package
03:02:41 <Owatch> Oh nice
03:02:42 <Owatch> Thanks
03:03:43 <unit73e> I find it odd that most languages call it Option, Maybe makes more sense to me. Historical reasons?
03:04:09 <c137> Can someone please recommend me somewhere to start haskell? I asked this in #haskell-beginner, but there was no ans.
03:04:19 <brynedwards> c137: haskellbook.com
03:04:40 <c137> I saw it, but there's no any others?
03:05:17 <unit73e> c137, learn you a haskell?
03:05:35 <unit73e> or real world haskell
03:05:42 <unit73e> I learned with those two
03:05:48 <Owatch> I'll be back later. Goodbye for now! Thanks for the help. 
03:06:40 <c137> OK, thanks brynedwards and unit73e. I saw those sources but did not know which ones are good for pure beginner.
03:07:17 <unit73e> c137, any of those will do IMO. I started with learn you a haskell but I don't see why not start with the other two.
03:07:51 <brynedwards> Another http://www.cs.nott.ac.uk/~pszgmh/pih.html
03:08:29 <brynedwards> I believe all of these are aimed at beginners
03:08:55 <unit73e> c137, BTW don't be scared of Monad. I don't see what's the deal with people being scared with that. I got it very quickly.
03:10:09 <c137> uni73e: Well, I don't even know what it is yet :) but thanks for the remind. 
03:12:57 <yushyin> unit73e: with different preludes you can get a generic map (which will be just fmap) so it is no real gain and I stick to fmap. It’s just a name anyway.
03:18:39 <phz_> hey
03:18:49 <phz_> is there a known abstraction for breaking-folds?
03:19:05 <phz_> something like:
03:19:22 <phz_> foldBreak :: (a -> b -> Maybe a) -> a -> [b] > a
03:19:25 <phz_> foldBreak :: (a -> b -> Maybe a) -> a -> [b] -> a
03:22:58 <barrucadu> What would the semantics of that be? It returns the last `a` for which it was `Just`?
03:23:08 <hexagoxel> could somebody look at [1] and tell me how you end up with l<=0 by adding 1 or 2 each recursive step? [1] http://hackage.haskell.org/package/text-1.2.2.1/docs/src/Data-Text.html#dropWhileEnd
03:30:31 <cocreature> hexagoxel: initially len could be 0 so len - 1 is -1
03:30:53 <hexagoxel> ah, reverseIter returns -1 or -2.
03:31:20 <hexagoxel> sorry, i had been looking at iter.
03:36:45 <unit73e> yushyin, different preludes? I just use the standard one
03:37:03 <unit73e> I don't mind being `fmap`
03:37:25 <yushyin> me neither
03:37:28 <unit73e> Is it common to override the standard prelude?
03:37:32 <hexagoxel> hmm suppose len==1. then i==0, l==1 => we call reverseIter t 0, which accesses A.unsafeIndex arr (off+0) and A.unsafeIndex arr (off-1)
03:37:51 <hexagoxel> the last access is bad, is it not?
03:38:04 <hexagoxel> http://hackage.haskell.org/package/text-1.2.2.1/docs/src/Data-Text-Unsafe.html#reverseIter
03:39:38 <yushyin> unit73e: it’s a matter of taste, I often use BasePrelude, my system ghci also use BasePrelude.
03:40:54 <brynedwards> There's a good guide about custom preludes here http://dev.stephendiehl.com/hask/#prelude
03:42:43 <cocreature> hexagoxel: I think it’s fine assuming your encoding is not screwed up. either the first check will be true then the access is never performed. or it is not but in that case the encoding specifies that there have to be more chars so you can’t be at the end
03:45:18 <kuribas> @hoogle (a -> Maybe b) -> [a] -> Maybe b
03:45:19 <lambdabot> Data.Maybe mapMaybe :: (a -> Maybe b) -> [a] -> [b]
03:45:19 <lambdabot> CorePrelude mapMaybe :: (a -> Maybe b) -> [a] -> [b]
03:45:19 <lambdabot> Agda.Utils.List takeWhileJust :: (a -> Maybe b) -> [a] -> [b]
03:45:54 <cocreature> kuribas: what is that supposed to do?
03:46:16 <kuribas> cocreature: find the first value returning Just
03:47:23 <kuribas> :t \f -> listToMaybe . mapMaybe f
03:47:24 <lambdabot> (a1 -> Maybe a) -> [a1] -> Maybe a
03:47:39 <cocreature> :t \p -> join . find isJust . map p
03:47:41 <lambdabot> (a1 -> Maybe a) -> [a1] -> Maybe a
03:49:26 <kuribas> :t join
03:49:28 <lambdabot> Monad m => m (m a) -> m a
03:50:53 <cocreature> join is just used to smash the two layers of Maybe together
03:53:37 <hexagoxel> cocreature: yeah true, the unsafeIndex should never happen. but why is reverseIter looking at the second byte to determine if there is a 4-byte character?
03:54:04 <cocreature> hexagoxel: I have no idea how utf16 works so I can’t answer that :)
03:58:17 <hexagoxel> cocreature: thanks for looking; utf16 apparently has some property on both words so things are correct. i need to hunt my bug elsewhere.
03:59:05 <cocreature> hexagoxel: if you have some reasonably small testcase I might be able to take a look at the actual bug you’re seeing :)
04:00:34 <hexagoxel> not yet; it is one of the evil, nondeterministic kind.
04:00:58 <cocreature> ah those are annoying, good luck finding it :)
04:04:14 <unit73e> thanks yushyin and brynedwards 
04:05:53 <unit73e> that's actually a pretty nice Prelude
04:06:24 <yushyin> see? now you want a custom prelude too ^^
04:06:38 <tdammers> I have a custom prelude too
04:06:52 <tdammers> wouldn't recommend anyone to use it though
04:06:55 <tdammers> it's too opinionated
04:07:55 <cocreature> I even have a project with a project-specific prelude
04:09:53 <unit73e> yeah I'm going to test these custom preludes. These do fix some things.
04:11:24 <unit73e> protolude seems good enough for me
04:16:39 <tdammers> cocreature: had that too, then factored it out into a package of its own, and that's my custom prelude now
04:16:52 <tdammers> it imports a bunch of data structures, lens, aeson, etc., by default
04:17:54 <lpaste_> merijn pasted “No title” at http://lpaste.net/353970
04:18:08 <merijn> Any suggestions for names of the 2nd field that are less likely to collide with a name I want to use elsewhere?
04:20:39 <Grisha> merijn: kynd?
04:21:09 <cocreature> Grisha: needs more unicode
04:21:18 <cocreature> kγnd
04:21:41 <Grisha> \kappa \gamma \eta \delta
04:21:49 <cocreature> can you use emojis in haskell identifiers?
04:22:16 <merijn> cocreature: Yes, but usually only as operators
04:22:38 <merijn> > generalCategory '💩'
04:22:40 <lambdabot>  OtherSymbol
04:22:49 <cocreature> merijn: ah dang, so you can’t use this here
04:22:51 <merijn> Symbol characters are operator characters
04:22:52 <cocreature> what a shame
04:54:53 <tabaqui1> > True || undefined
04:54:55 <lambdabot>  True
04:55:18 <tabaqui1> > liftA2 (||) (return True) <*> undefined
04:55:20 <lambdabot>  error:
04:55:20 <lambdabot>      • No instance for (Typeable a0)
04:55:20 <lambdabot>          arising from a use of ‘show_M302220984781207142230388’
04:55:30 <tabaqui1> > liftA2 (||) (return True) <*> (return undefined)
04:55:32 <lambdabot>  error:
04:55:32 <lambdabot>      • No instance for (Typeable a0)
04:55:32 <lambdabot>          arising from a use of ‘show_M901012516416212450130425’
04:55:53 <tabaqui1> > liftA2 (||) (return True) <*> (return undefined) :: [Bool]
04:55:55 <lambdabot>  error:
04:55:55 <lambdabot>      • Couldn't match expected type ‘[a0 -> Bool]’
04:55:55 <lambdabot>                    with actual type ‘f0 Bool -> f0 Bool’
04:58:07 <tabaqui1> > liftA2 (||) (return True) undefined
04:58:10 <lambdabot>  error:
04:58:10 <lambdabot>      • Ambiguous type variable ‘f0’ arising from a use of ‘show_M541081117034...
04:58:10 <lambdabot>        prevents the constraint ‘(Show (f0 Bool))’ from being solved.
04:58:16 <tabaqui1> > liftA2 (||) (return True) undefined :: [Bool
04:58:18 <lambdabot>  <hint>:1:45: error:
04:58:18 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
04:58:18 <tabaqui1> > liftA2 (||) (return True) undefined :: [Bool]
04:58:21 <lambdabot>  *Exception: Prelude.undefined
04:58:25 <tabaqui1> yeah, here
04:58:28 <tabaqui1> > liftA2 (||) (return True) undefined :: [Bool]
04:58:31 <lambdabot>  *Exception: Prelude.undefined
04:58:34 <tabaqui1> True || undefined
04:58:44 <tabaqui1> > True || undefined
04:58:46 <lambdabot>  True
05:02:13 <cocreature> tabaqui1: you can send private messages to lambdabot :)
05:05:05 <tabaqui1> cocreature: yeah, sorry
05:05:32 <tabaqui1> there was a little bit quiet
05:06:19 <tabaqui1> I thought that nobody noticed
05:11:34 <tabaqui1> btw, I wanted to ask about lazyness in <*> operator
05:11:50 <tabaqui1> but I think that understand already
05:20:01 <Axman6> it will depend on which Applicative instance you use
05:20:18 <Axman6> > liftA2 (||) (return True) <*> undefined :: Maybe Bool
05:20:20 <lambdabot>  error:
05:20:20 <lambdabot>      • Couldn't match expected type ‘Maybe (a0 -> Bool)’
05:20:20 <lambdabot>                    with actual type ‘f0 Bool -> f0 Bool’
05:20:39 <Axman6> > liftA2 (||) <$> (return True) <*> undefined :: Maybe Bool
05:20:41 <lambdabot>  error:
05:20:41 <lambdabot>      • Couldn't match type ‘f0 Bool’ with ‘Bool’
05:20:41 <lambdabot>        Expected type: Maybe Bool
05:20:52 <Axman6> > (||) <$> (return True) <*> undefined :: Maybe Bool
05:20:53 <merijn> Axman6: liftA2 already does <*>
05:20:55 <lambdabot>  *Exception: Prelude.undefined
05:21:04 <Axman6> yeah -_- it'a late
05:21:12 <Axman6> > (||) <$> (return True) <*> Just undefined :: Maybe Bool
05:21:14 <lambdabot>  Just True
05:27:09 <merijn> hmmm, interesting...
05:27:29 <merijn> -fdefer-typed-holes is making GHC panic...guess I have to finally bite the bullet and upgrade >.<
05:29:00 <cocreature> you can now witness the very rare event of merijn upgrading parts of his software stack
05:30:07 <merijn> cocreature: See, the real question is: Will I update to 7.10.3 or go for 8.0 :p
05:30:34 <cocreature> merijn: obviously 7.10.3. otherwise things would actually change
05:31:12 <merijn> cocreature: Well, I was using the ghcformacosx installer, but that one doesn't seem to have an 8.0 version
05:33:00 <merijn> So then the question is: Can I be arsed to figure out how the hell stack works, or do I just install binary GHC
05:33:50 <nitrix> glguy: srhb merijn Geekingfrog Apologies for my attitude friday in regards to NF/HNF/WHNF.
05:36:38 <nut> how to run a Producer (ResourceT IO) FilePath ? in conduit
05:36:57 <nut> i've tried runConduitRes
05:37:04 <nut> but the type is wrong
05:39:59 <srhb> nitrix: No worries. :)
05:41:29 <nitrix> glguy: srhb merijn Geekingfrog I've always been here with the intention of improving my Haskell skills and I don't want to be associated with that sort of talk. I think ignorance and ego lead to it. I'm taking a step back, especially being more cautious with spreading what I'm not totally confident about.
05:42:24 <srhb> nitrix: Don't worry about getting it wrong every now and then, usually someone will be there to correct it. :)
05:42:32 <srhb> No harm done.
05:42:43 * srhb gets things wrong all the time!
05:43:21 <nitrix> srhb: My reaction to it felt like I was biting the hand that fed me in retrospective.
05:46:17 <tabaqui1> I get "fdReady: msecs != 0, this shouldn't happen[1]    17452 abort (core dumped)" while trying to read data from namedpipe
05:46:35 <tabaqui1> while hWaitForInput precisely
05:46:54 <merijn> cocreature: Well, you'll be pleased to know I'm still stubborn and am installing binary GHC and cabal from scratch, rather than figuring out this new-fangled stack stuff :p
05:47:11 <tabaqui1> why can it happen?
05:47:25 <merijn> tabaqui1: Because bugs happen? :)
05:48:18 <lyxia> nut: use `connect`, you must also provide a consumer/sink.
05:48:19 <tabaqui1> merijn: hm, do you suspect such thing?)
05:48:57 <merijn> tabaqui1: Well clearly it's crashing, so I'd say that's a bug, yes
05:49:23 <tabaqui1> API for dealing with named pipes is poor, if you ask me
05:50:05 <tabaqui1> if you try to hGetLine from pipe, you get an exception
05:50:43 <tabaqui1> but operation must block
05:50:46 <tabaqui1> not failed
05:50:58 <tabaqui1> *fail
05:51:51 <cocreature> merijn: I would be worried about you if you didn’t do this :)
05:52:44 <merijn> cocreature: 5 seconds looking at the user guide it's "prefix everything with stack", "creating huge directory hierarchies", "projects", and "YAML files"
05:59:54 <unknownln> http://m.imgur.com/vme6k3c
05:59:57 <unknownln> Gaaah
06:00:05 <unknownln> Screw you riot
06:00:13 <unknownln> Can't link to the right channel
06:00:27 <yushyin> ^^
06:01:06 <unknownln> Phone + fingers + channels sorted by most recently active = bad time
06:04:25 <ngWalrus> :(
06:07:17 <hexagoxel> how do i convince stack to call ghc so it dumps the preprocessor output?
06:08:00 <hexagoxel> raah i have to look at the -v output of `stack build` to see what wrapper they call, then manually call that wrapper with -v to see how it calls ghc, then call that with modified options that do the dumping?
06:08:02 <hexagoxel> seriously?
06:08:11 <hexagoxel> there's another argument against stack.
06:10:46 <merijn> hexagoxel: Thanks for the validation of my previous decision ;)
06:19:23 <Axman6> hexagoxel: how would you usually get ghc to do that? also, stack's tab completion makes finding those answers a lot easier
06:20:25 <brynedwards> --ghc-options ?
06:21:30 <hexagoxel> it is trivial on neither cabal nor stack, because -E is incompatible with other options.
06:24:56 <tabaqui1> yeah, look
06:25:14 <tabaqui1> H.withFile "/tmp/52169.webengine" H.ReadMode (flip H.hWaitForInput 1000)
06:25:33 <tabaqui1> ghc 8.0.1 - totally blocks, doesn't react at Ctrl-C
06:25:34 <Axman6> hexagoxel: you an always use stack exec ghc -- -E
06:25:38 <Axman6> (I think)
06:25:39 <tabaqui1> ghc 8.0.2 - crashed
06:25:45 <tabaqui1> oops
06:26:07 <tabaqui1> little disclosure
06:26:21 <tabaqui1> H.withFile "regular_file" H.ReadMode (flip H.hWaitForInput 1000)
06:27:06 <tabaqui1> *8.0.1 returns correct result after delay
06:27:41 <tabaqui1> but operation cannot be interrupt before timer expires
06:27:51 <tabaqui1> *interrupted
06:28:18 <hexagoxel> Axman6: s/always/if you use only the defaults in your package. no extensions, no includes, ../
06:44:12 <kaiserAnd> just to know, have you ever been able to use haskell as a selling point at an interview? do companies care about that skill set?
06:47:51 <opqdonut> kaiserAnd: in the interview for my current consulting job they asked me to explain monads, and then asked me to stop afer 5 minutes
06:48:10 <merijn> opqdonut: Oh god...please stop!
06:48:21 <opqdonut> probably would've gotten the job even without that, but it's a fun anecdote
06:48:29 <opqdonut> writing clojure here at the moment, there are no other haskell guys
06:49:28 <kaiserAnd> that's quite surprising, in my experience the only stuff the HR people know is java and that's about it
06:49:28 <Axman6> kaiserAnd: well, we're specifically hiring FP programmers at the moment, so it's a definite plus for us ;)
06:49:37 <merijn> Ah, the fun challenge of figuring out "how the hell can I get my dependencies fixed again" >.>
06:50:09 <Axman6> kaiserAnd: HR people shouldn't be doing interviews for technical roles
06:50:17 <opqdonut> yeah
06:50:56 <kaiserAnd> Axman6: yeah that's true, but that's how stuff works here :p
06:51:36 <merijn> Is there a way to relax a single bound on a package without first unpacking it?
06:52:00 <Axman6> unpacking it would be the easiest way I think
06:52:04 <merijn> bleh
06:52:55 <Axman6> (making modifications to deps is one of the things stack makes quite easy btw, because you can specify where deps live concisely)
06:55:33 <merijn> Axman6: I prefer just patching and fixing Hackage anyway
06:56:13 <ezyang> isn't this what allow-newer is for 
06:56:20 <merijn> ezyang: That relaxes *everything*
06:56:29 <merijn> ezyang: I just want to relax 1 or 2 things
06:56:32 <ezyang> you can target it 
06:56:41 <merijn> ezyang: Well, that's what I was asking :p
06:56:59 <ezyang> http://cabal.readthedocs.io/en/latest/nix-local-build.html#cfg-field-allow-newer 
07:01:45 <merijn> @ask edwardk What's the easiest way to get the bounds of bound (hah!) relaxed? Pull request with changes?
07:01:46 <lambdabot> Consider it noted.
07:08:56 <sphinxo> What's an efficient way to store and traverse  arbitrary sql like tables
07:14:51 * hexagoxel discovers that CPP macros on macOS don't like spaces between function-macro-name and parenthesis for arguments.
07:25:43 <mudri> Hi. I've got preëxisting classes A and B, and I want to say that from any instance of B, we can derive an instance of A. Is that possible?
07:27:03 <merijn> mudri: Only if you never allow any other instances of A
07:28:10 <mudri> merijn: hmm, not likely, given that A is Ord in my case. ;-)
07:28:40 <mudri> I guess it causes too much trouble for instance search.
07:32:24 <cocreature> sphinxo: a database? I’m not sure I understand your question :)
07:39:33 <lampam> protip: don't accidentally have two "packages:" lists in stack.yaml
07:39:41 <lampam> your errors will suddenly make a lot more sense
07:42:00 <Rembane> :D
07:53:13 <kadoban> ExpHP: Hah
08:00:08 <mekeor> #NoteToSelf && #DeMorgan:  Instead of `not a && not b`, better use `not (a || b)` because you avoid 1 `not` and `||` is lazy.
08:03:07 <sproctor-work> Does anyone know if it's possible to specify multiple name options for the same package in pkgconfig-depends? Some versions of linux have lua 5.1 as "lua-5.1" and some have it as just "lua"
08:03:07 <mekeor> mekeor: this is not true. `&&` is lazy, too. e.g. if `not a == false`, `not b` doesn't have to be evaluated
08:05:39 <mekeor> sproctor-work: maybe try asking in #lua, too
08:08:54 <sproctor-work> mekeor: I think it's more of a cabal issue than a Lua issue (other than the fact that Lua distributors can't decide on a consistent naming scheme)
08:11:23 <cocreature> sproctor-work: I thought the job of pkgconfig is to figure this kind of stuff out. e.g. you specify lua53 and then pkgconfig figures out that the lib is called lua
08:15:14 <sproctor-work> cocreature: the pkg-config name for lua is system dependent, apparently. pkg-config --list-all on this computer gives me "lua5.1" and "lua-5.1". elsewhere, it's just "lua" and on my macbook, it's just "lua-5.1"
08:16:00 <cocreature> sproctor-work: ah that sucks. I have both lua and lua53 (but not lua-5.3)
08:16:15 <cocreature> would be way to easy if this was consistent
08:19:08 <sproctor-work> using autoconf, you could do: PKG_CHECK_MODULES([LUA], [lua-5.1],, [PKG_CHECK_MODULES([LUA], [lua = 5.1])])
08:20:59 <robkennedy> If I define `data T a b = T a b`, is it generally better to defined `newtype T a b = T (a,b)` ?
08:21:25 <quchen> It’s pretty much the same.
08:21:36 <robkennedy> Tight
08:21:43 <quchen> Up to pattern matching details, which make a slight difference between data types and newtypes.
08:21:52 <dram_phone> If you want to go from T to tuple and back often the second one can help
08:22:38 <dram_phone> If you always pattern match on {{ T u v }} in the first case and {{ T (u, v) }} in the second case there isn't any real difference
08:22:53 <dram_phone> Because (in a way) data (a, b) = (a, b)
08:23:12 <ertes> robkennedy: you could…  you know…  just use (,) to begin with =)
08:24:01 <ertes> unless you're using T mainly to override instances, in which case i'd go with the newtype variant, mostly because you can use GeneralisedNewtypeDeriving
09:00:13 <sanett> hey folks, I have a lambda expression like lx.x x, is the last x free or bound?
09:01:12 <srhb> sanett: Does that space have special meaning? Is it (\x -> x x) (ie. x applied to x)?
09:01:20 <srhb> sanett: If so, I think you may know the answer? :)(
09:02:30 <sanett> wait... \x.x x and \x.xx are different?
09:03:32 <quchen> Depends on your notation. Please add parentheses to clarify. In normal notation, (λ x. x x) is the same as (λ x. (x x)).
09:04:31 <JonReed> Hi, is there a way to match uppercase character in Attoparsec?
09:08:01 <sanett> I have never been more confused in my life. This article states that lx.xx is the same with (lx.x)x and is thus different from lx.(xx)
09:08:43 <sanett> if it's lx.(xx), I guess the last x is bound?
09:09:06 <sanett> but is (lx.x)x the same with (ly.y)x?
09:09:52 <quchen> »λ x. x« is the same as »λ y. y«, yes. (By α-equivalence.)
09:09:54 <glguy> (λx.x)x and (λy.y)x  will evaluate to the same result
09:10:09 <quchen> AKA renaming bound variables
09:10:37 <JonReed> Nevermind, it does not appear to be a single function for this like it Parsec, one would have to use satisfy in attoparsec for this.
09:10:51 <glguy> (λx.x)x is different from λx.(x x)
09:11:07 <quchen> If the article says that »λ x. x x« is the same as »(λ x. x) x«, then it uses horrible nonstandard notation.
09:11:31 <glguy> Maybe just link the article?
09:11:35 <sanett> where can I find the conventional notation?
09:11:43 <glguy> It could just be that you're misunderstanding what it says
09:11:45 <sanett> it's not written in English
09:13:35 <quchen> λxy.z = λx.(λy.z)   ;   λx.yz = λx.(yz)   ;   fxy = (fx)y
09:14:04 <sanett> so can I say that lambda extends to as far right as it gets until it meets a left parenthesis?
09:14:19 <glguy> No, it extends beyond any (
09:14:58 <quchen> A lambda has scope as long as it can, until it meets a closing parenthesis that wasn’t opened in its body.
09:15:29 <sanett> so it extends to as far as it gets until a ) then?
09:15:56 <glguy> not an arbitrary ), but one that closes a ( to the left of the λ
09:16:21 <sanett> right
09:16:25 <quchen> For example,    λz.λxy.f(xy)z   =   λz.(λx. (λy.(f(xy))z))
09:16:43 <quchen> Here, the closing parenthesis around (xy) does not finish the lambda.
09:17:19 <sanett> yep your example clears that up
09:18:16 <sanett> I'll be back with more questions... Thanks guys.
09:35:41 <_sras_> Is there any resources for learning how to use hasql?
09:40:52 <cocreature> _sras_: iirc I’ve just used the testsuite and the haddocks. I don’t know of a proper tutorial
09:44:01 <_sras_> cocreature: Have you used it? What are its capabilities?
09:47:23 <cocreature> _sras_: yes, I’ve used it but not in a large app. I would say overall it’s quite a nice library and gets the job down. there are however a few limitations: 1. no support for psql notifications (I started working on that at some point but I got busy with other stuff) 2. no direct support for multi-tuple inserts (you can work around this but it is annoying) 3. you quickly run into limitations if you want
09:47:25 <cocreature> to use custom psql types, e.g. arrays of composites are not supported. sadly I don’t know of any Haskell psql library that properly supports this so even if that’s annoying it’s not a reason against hasql
09:49:09 <cocreature> _sras_: and you are generally going to write slightly more code for decoding/encoding rows than you would with postgresql-simple
09:50:34 <_sras_> cocreature: So why should one use hasql over postgresql-simple. Speed?
09:51:41 <cocreature> _sras_: a) you might prefer its API b) speed c) I think it’s slightly better at encoding/decoding custom types but as I said it reaches its limitations very quickly
10:05:10 <squotro> is anybody here?
10:05:37 <lambdabot> Hello.
10:05:40 <ExpHP> hi
10:06:01 <Phyx-> what, lambdabot says hello now?
10:06:17 <ExpHP> @karma+ lambdabot
10:06:17 <lambdabot> lambdabot's karma raised to 34.
10:07:59 <mada> lol
10:12:02 <squotro> hey
10:13:55 <squotro> (
10:15:47 <_sras_> Have any Opaleye users experienced slow query planning for opaleye generated left joins with around 10 tables?
10:19:36 <squotro> oops
10:25:06 <fendor> @karma lambdabot
10:25:06 <lambdabot> lambdabot has a karma of 33
10:30:48 <sphinxo> are there any libraries for doing reversable binary reading/writing?
10:34:33 <geekosaur> binary and cereal; attoparsec is often used when you need to model a state machine (for e.g. a binary network protocol)
10:39:25 <tokage> hello is anybody here? I have a very important meta question.
10:40:15 <mniip> tokage, don't ask to ask
10:41:52 <nitrix> data Phantom a = Phantom; data Foo a = Foo a
10:42:14 <nitrix> Is there a way for Haskell to infer the `a` of Foo based on the phantom `a` of Phantom?
10:42:29 <mniip> what
10:42:36 <nitrix> I have a feeling this is muddy territory.
10:42:43 <mniip> what do you mean
10:42:51 <glguy> nitrix: example :: Phantom a -> Foo a -> Foo a; example _ x = x
10:43:02 <glguy> You can use something like that to relate the two
10:43:22 <nitrix> glguy: err, oh you're right I asked the wrong question.
10:43:45 <nitrix> I jumped the guns, let's see if the problem is still there once I finish this type equality thing.
11:04:07 <nitrix> Wow, that's fascinating. edwardk laid out perfectly lens to support what I'm working on and working with referential data in Haskell in a pure way.
11:04:36 <sphinxo> How might I make loeb work with an input such as  [const [const 1]] 
11:04:58 <nitrix> (Without happing tons of mappings of ids that are O(log n)). I'm back working on it and his work is such ahead of the curve.
11:06:06 <sphinxo> ( what loeb is https://github.com/quchen/articles/blob/master/loeb-moeb.md )
11:07:16 <lyxia> sphinxo: what's wrong with what you wrote
11:08:35 <lyxia> > let loeb f = fix (\x -> fmap ($ x) f) in loeb [const [const 1]]
11:08:37 <lambdabot>  error:
11:08:37 <lambdabot>      • No instance for (Typeable b0)
11:08:37 <lambdabot>          arising from a use of ‘show_M18719631324288613376305’
11:08:44 <lyxia> boo
11:09:12 <lyxia> :t let loeb f = fix (\x -> fmap ($ x) f) in loeb [const [const 1]]
11:09:13 <lambdabot> Num a => [[b -> a]]
11:09:35 <lpsmith> cocreature, well as far as I can see,  postgresql-simple is much better at supporting custom types than hasql.
11:10:11 <lpsmith> Last I checked, you'd have to modify hasql to support extended types.
11:10:19 <sphinxo> so fmap loeb (loeb input)
11:10:34 <lpsmith> postgresql-simple does need support for binary parameters/results though.
11:10:44 <lpsmith> I do admit that.
11:10:49 <sphinxo> thanks lyxia 
11:12:12 <sophiag> is anyone here familiar with haskell-src-exts? i'm trying to figure out how to process the ASTs it returns
11:13:21 <glguy> sophiag: It's possible that someone simply familiar with Haskell would be able to help. Just ask your actual question.
11:13:57 <sophiag> glguy: i feel like the child who doesn't know enough to ask a question :)
11:14:15 <sophiag> for example, when parsing a list it returns: "List [Lit (Char 'a'),Lit (Char 'b'),Lit (Char 'c')]"
11:15:01 <sophiag> let's say i want to covert that into just a list of the chars as it was input?
11:15:04 <sphinxo> lyxia: how would I evaluate [const [const [const 1]]] or an arbitrarily deep data structure?
11:15:35 <pikajude> sophiag: why do you want to convert it to a list of chars?
11:16:01 <pikajude> is that what you get from parsing ['a','b','c']
11:16:29 <sophiag> pikajude: yes. i'm using haskell-src-exts to avoid having to write complicated custom parsers to handle that sort of input
11:16:39 <pikajude> well why are you parsing it
11:16:44 <pikajude> what's the use case
11:17:11 <pikajude> if you want to parse ['a','b','c'] and get a list of chars, i wouldn't use HSE because it's going to give you an AST
11:17:15 <pikajude> which is way more than you need
11:17:45 <sophiag> it was recommended to me yesterday. the use case is i'd like to pass it as an argument to a data constructor
11:17:46 <glguy> Whether or not haskell-src-exts is good, sophiag should be able to process that value to extract a Maybe [Char]
11:18:15 <lyxia> sphinxo: (fmap . fmap) loeb . fmap loeb . loeb
11:18:17 <sophiag> i'm not sure what the "Lit" token means tbh
11:18:47 <pikajude> glguy: sure, just checking if it could be avoided by using a library with less of a kitchen sink
11:18:52 <pikajude> sophiag: Lit means literal
11:19:01 <sophiag> ah ok, tahnks
11:19:02 <glguy> sophiag: It's a constructor for the Exp type: http://hackage.haskell.org/package/haskell-src-exts-1.19.1/docs/Language-Haskell-Exts-Syntax.html#t:Exp
11:19:03 <pikajude> 'a' is a character literal
11:19:44 <pikajude> getChars (List exprs) = mapM (\ expr -> case expr of Lit (Char c) -> Just c; _ -> Nothing) exprs
11:19:47 <pikajude> getChars _ = Nothing
11:19:50 <pikajude> off the top of my head
11:20:53 <sophiag> fwiw i'm also trying out mueval for the same purpose, but am getting an error it can't find an instance of Show (since it prints the output by default) even though i have "deriving (Show)" on the return value of the functions i've been testing
11:21:01 <sphinxo> lyxia: is that as pointfree?
11:21:16 <sphinxo> oops yes
11:21:32 <sphinxo> sorry was not passing in arg correctly
11:22:25 <maerwald> s asi xD
11:25:25 <sophiag> pikajude: thanks for that function! i think i can get the hang of working with these ASTs based on that :)
11:25:41 <pikajude> cool
11:26:16 <sophiag> the other thing confusing me though is i need to parse lambdas, but i get an error "lexical error in string/character literal at character ' '"
11:26:33 <pikajude> that is confusing
11:26:37 <pikajude> what's the code
11:26:50 <sophiag> that's just from trying something like "parseExp "(\x -> x == 0)""
11:27:11 <pikajude> oh you probably need \\ then
11:27:23 <sophiag> oh
11:27:23 <pikajude> because \x isn't valid in a string unless it's followed by some hexadecimal
11:27:29 <sophiag> ah of course
11:27:30 <pikajude> > "\x27"
11:27:32 <lambdabot>  "'"
11:27:52 <pikajude> unlucky that you're using the variable name `x`, the error message probably would have been more helpful otherwise
11:27:54 <sophiag> or actually i thought a backslash was for using quotes?
11:28:04 <pikajude> backslash is for escaping things
11:28:53 <sophiag> right. and because i used the \x it was throwing an error seeing the space
11:28:59 <sophiag> thanks, i never would have put that together
11:30:28 <sophiag> i seem to need a double slash for any variable actually
11:31:18 <pikajude> because you're escaping the \
11:31:34 <sophiag> makes sense
11:31:36 <pikajude> "\\" is how you write \ in a string
11:35:28 <monochrom> The real horror begins when you need to write in Haskell string literal a string that first goes through a unix shell and then to the grep program, and you need grep to looking for the backslash character (literally) followed by the letter n, because you're searching for \n in C source code.
11:36:58 <koala_man> one of the many reasons why system(3) semantics must die
11:36:59 <nitrix> Or executing a system command which is a windows program that connects to a linux machine to run a bash script there with arguments.
11:37:38 <nitrix> I remember some nasty '"\'\\\"\\"'"\''\""" nonsense.
11:38:07 <koala_man> that sounds even worse since Windows processes try to second guess argv 
11:38:37 <nitrix> It's also when I realised that Haskell's ecosystem is missing a great SSH client library.
11:38:58 <nitrix> (Native)
11:51:12 <srk> indeed
11:51:47 <srk> propellor uses socket to talk to ssh client
11:53:57 <cocreature> lpsmith: good point. I think I got a bit further with the builtin parsers in hasql than I got with the builtin ones in postgresql-simple. postgresql-simple is definitely more extensible but writing parsers is really annoying because you need to take escaping in account it gets messy really quickly :)
11:54:22 <cocreature> lpsmith: hasql is mostly bound by the limitations of the binary protocol afaik
11:56:59 <Jello_Raptor> hey all, I need a propagator library and the only one i can find is ekemett's half finished one. I suspect I'll have to write one myself, any suggestions on papers to read to catch up with useful PL theory? I've got Alexi Radul's thesis, the Nominal Adaption paper, and the Observable sharing paper. (latter two from reading ek's code) 
11:57:27 <Jello_Raptor> oh
11:57:32 <Jello_Raptor> edwardk: ping ^
11:58:37 <Jello_Raptor> (it doesn't help that I've been doing electrical engineer for two years and have fallen super behind on PL stuff that hasn't been posted to /r/haskell :/ ) 
12:00:09 <sophiag> pikajude: i'm trying to use one function to parse several types of lists, but am not sure how exactly to do it correctly. would you mind taking a look? http://lpaste.net/353983
12:00:59 <pikajude> well this kinda looks like it's replicating the functionality of what an AST does
12:01:04 <nitrix> foo :: Relation a -> (a -> Relation b) -> Relational b
12:01:18 <nitrix> :: n a -> (a -> n b) -> m b
12:01:31 <pikajude> sophiag: why do you have parseList returning Maybe [HList]
12:01:38 <nitrix> Is there a name or a known idiom for this? I have a type that can only be used by a given monad.
12:02:39 <sophiag> pikajude: well i have that type so i can have a record take lists of multiple types. i suppose you're saying i should just write three different functions to read the ASTs since they're already delimited by type?
12:03:08 <pikajude> well at the moment actually i'm asking why you're returning possibly a list of lists
12:03:16 <pikajude> which is what Maybe [HList] would be
12:03:20 <nitrix> Seems like I can decompose this further to:  n a -> (a -> n b) -> n b,    n b -> m b ?
12:03:26 <nitrix> Maybe n needs to be a monad.
12:03:47 <sphinxo> What's the most efficient way to store [(A,B)] so that I have a function A -> B and B -> A
12:04:19 <sophiag> pikajude: you realize that's not HList from the library, right? it's just an adt i slapped together that's in the paste
12:04:32 <pikajude> uh huh
12:04:34 <sphinxo> like a map that I can lookup both ways
12:04:36 <sophiag> oh i see what you're saying tho. it should just be "Maybe HList"
12:04:37 <pikajude> but HList still contains a list
12:07:31 <lyxia> sphinxo: bimap
12:07:58 <sphinxo> thanks
12:08:04 <sophiag> pikajude: right. it should be the same as [String], [Char], and [Int]
12:08:42 <sphinxo> anything I can do if I know the values will never change? lyxia 
12:08:53 <sphinxo> it's just really a lookup table
12:09:06 <sphinxo> instead of two functions that pattern match
12:09:50 <nitrix> sphinxo: https://hackage.haskell.org/package/bimap-0.3.2/docs/Data-Bimap.html
12:09:53 <nitrix> sphinxo: Something like this?
12:10:33 <sphinxo> Yeah like that, was just wondering if there was anything more optimal since the values will never change at runtime
12:11:06 <nitrix> sphinxo: Maybe you'd want to implement a Bihash instead.
12:11:20 <nitrix> For near O(1) lookups instead of O(log n)
12:12:16 <sphinxo> aToB a = case a of AVariant1 => B1, AVariant2 => B1
12:12:58 <sphinxo> bToA b = case b of B1 => AVariant1, B2 => AVariant2
12:13:19 <sphinxo> ( if I write  the aToB function correctly )
12:13:23 <sphinxo> *wrote
12:13:28 <lyxia> looks like a trie
12:13:49 <sphinxo> how so?
12:14:42 <lyxia> I mean a generalized tree like it appears in http://hackage.haskell.org/package/MemoTrie-0.6.7/docs/Data-MemoTrie.html
12:15:15 <sphinxo> ahh awesome
12:15:24 <lyxia> http://hackage.haskell.org/package/generic-trie-0.3.0.2/docs/Data-GenericTrie.html
12:17:23 <Hi-Angel> Does "fmap print (return 2)" works for anyone? For me it doesn't :/ Besides, the piece of code "fmap print arg2 >>" is a real hog, it uses 10Gb for no reason D:
12:17:55 <monochrom> @type fmap print (return 2)
12:17:56 <lambdabot> Monad f => f (IO ())
12:18:21 <Hi-Angel> Well, it should print "2"
12:18:32 <Hi-Angel> Or anything in the monad
12:18:34 <monochrom> How do you know?
12:18:42 <Hi-Angel> Because it's print
12:18:45 <boxscape> depends on the Monad f, doesn't it?
12:18:58 <monochrom> but there is also fmap, are you ignoring it?
12:19:43 <edwardk> Jello_Raptor: sorry, spent the last year sick and didn't get much done on the propagator front
12:19:51 <monochrom> Also, I just tried it in GHCi, nothing happens, and no consuming 10GB memory.
12:20:02 <Hi-Angel> I don't understand :( How can I print a monad wrapped value
12:20:06 <boxscape> which monad does ghci pick if you type "return 2"?
12:20:23 <boxscape> (without the fmap print I mean)
12:20:42 <Hi-Angel> monochrom: it's in the other code, the thing is that this single line of code takes 10Gb in profiling, and removing the line makes it run easily
12:20:55 <monochrom> I don't actually know, boxscape. However, I get 2 on its own line as output. Maybe IO.
12:20:59 <boxscape> hm, ok
12:21:26 <mizu_no_oto_work> @type sequence (fmap print (return 2))
12:21:28 <lambdabot> (Monad t, Traversable t) => IO (t ())
12:21:28 <dylukes> Greetings!
12:21:37 <monochrom> OK, Hi-Angel, have you considered the possibility that the other 99% of your code is the cause?
12:21:44 <dylukes> So, I'm exploring writing a molecular modeling viewer type program in Haskell... 
12:22:00 <dylukes> and FRP seems a good fit for managing the various time dependent and interdependent attributes of the scene.
12:22:02 <mizu_no_oto_work> Hi-Angel: ^ that works if your monad is also traversable
12:22:09 <dylukes> Any suggestions on a FRP library that is *fast*?
12:22:11 <Hi-Angel> monochrom: yes, so I removed the line to check it out, and turns out this line is the cause
12:22:15 <sphinxo> I'm not sure the memotrie operates on different types? http://lpaste.net/7001204074422992896 <- I want to get rid of the duplication here
12:22:24 <monochrom> OK, problem solved?
12:22:27 <dylukes> Doesn't have to be fantastically complex. RxJs equivalent would be plenty.
12:22:29 <dylukes> Rx*
12:22:56 <ew_> Hello people, https://www.docdroid.net/YLuNgmx/test-equiv-profile.pdf.html
12:23:01 <Hi-Angel> mizu_no_oto_work: I have a simple "IO Double" that I need to print
12:23:03 <lyxia> sphinxo: It can be used as an alternative to Map in a Bimap.
12:23:04 <ew_> Look at my pretty exponential memory graphs
12:23:09 <Hi-Angel> mizu_no_oto_work: It's not traversable
12:23:46 <mizu_no_oto_work> Hi-Angel: If you have an IO Double, you can say "myIODouble >>= print"
12:24:12 <Hi-Angel> mizu_no_oto_work: you're genious!!
12:24:13 <mizu_no_oto_work> or join (fmap print (return 2)), if you prefer
12:24:20 <dylukes> The only thing is, I'm not sure how to nicely use FRP in a dynamic way.
12:24:28 <mizu_no_oto_work> Not sure why you'd prefer the second one, though
12:24:51 <dylukes> Euphoria/Elerea seem interesting to this end.
12:25:52 <mizu_no_oto_work> Hi-Angel: and if you have a function that takes some value and generates an IO Double, you can use "print <=< mkIODouble" to compose them
12:26:09 <sphinxo> How can I remove the duplication here: http://lpaste.net/7001204074422992896
12:26:14 <Hi-Angel> Thank you
12:27:09 <boxscape> looks like ghci doesn't print the result whenever the type is `IO ()' (nothing new about that), or `IO (IO ())', or `IO (IO (IO ()))', and so on
12:27:17 <augur> anyone know how to make Stack REPL less verbose?
12:27:29 <boxscape> I would've expected it to try to print it in every case except the first
12:27:42 <boxscape> (resulting in a missing instance for Show)
12:29:59 <mnoonan> boxscape: weirdly, it prints nothing for IO (IO Int) either
12:30:06 <boxscape> oh
12:30:10 <c_wraith> boxscape, ghci's heuristic is 1) IO () means don't show. 2) unifies with (Show a) => IO a means show the resulting a value. 3) don't print anything 
12:31:01 <c_wraith> boxscape, IO doesn't have a show instance, so nothing is shown in the case of nested IO
12:31:31 <boxscape> ok, that makes sense
12:32:15 <boxscape> but wait, how can you show values of type IO Int if IO doesn't have a show instance
12:32:21 <boxscape> or does ghci do special magic in that case
12:32:27 * FULLC00L666 how to get free Uber Rides. https://youtu.be/YGBscwzn_hU :)
12:32:34 <boxscape> looks like it
12:32:36 --- mode: ChanServ set +o monochrom
12:32:41 --- mode: monochrom set +b *!*@185.86.151.98
12:32:41 --- kick: FULLC00L666 was kicked by monochrom (FULLC00L666)
12:32:45 --- mode: monochrom set -o monochrom
12:32:51 <boxscape> oh
12:32:51 <dylukes> Also, what's the canonical way to build a package from hackage (say, a package of examples) with stack?
12:32:55 <boxscape> I misread your heuristic
12:32:58 <dylukes> copy source, stack init, etc?
12:33:00 <c_wraith> boxscape, it's essentially rewriting to >>= print
12:33:08 <boxscape> ok
12:33:38 <sphinxo> sphinxo: It can be used as an alternative to Map in a Bimap.
12:33:49 <sphinxo> what do you mean lyxia? sorry
12:33:50 <mizu_no_oto_work> Hi-Angel: the problem with "fmap print (return 2)" is that you end up with an "IO (IO ())", which isn't really the type you want.  You can think of that as being a computation that, when run, returns a computation that, when run, returns unit.  join will take an (IO (IO a)) and turn them into an (IO a).  >>= and <=< are equivalent to fmap and join (in that "a >>= f = join $ fmap f a " and "join a =  a >>= id", so you can define whichever's
12:33:50 <mizu_no_oto_work>  easiest directly and derive the missing function)
12:33:51 <c_wraith> boxscape, non-IO is just handled with an implicit print. all the special cases are IO types. 
12:34:01 <boxscape> right, ok. Thank you
12:34:57 <mizu_no_oto_work> As a side question, in what sense is codata "co-" to data?
12:36:27 <monochrom> Whereas "data" is short for "initial, algebraic" and means you focus on constructors, "co-data" is short for "final, co-algebraic" and means you focus on destructors or generators.
12:37:30 <dylukes> Hm.
12:37:42 <dylukes> What to do when stack init can't select a snapshot?
12:37:49 <dylukes> says "GLFW not found" for all of them :\.
12:37:53 <dylukes> Idk why GLFW causes an issue.
12:38:12 <monochrom> For example, given a "codata list", you speak of destructing it into a head and a tail, and you start talking of the possibility that you can destruct the tail and so on ad infinitum, maybe the co-data list doesn't end.
12:40:00 <monochrom> (I don't like "destruct". Maybe "deconstruct" is less violent and more hip. But also harder to type. :) )
12:40:19 <dolio> Observe.
12:40:22 <mauke> nstruct
12:40:36 <monochrom> Oh! Yes "obersve" is so much better.
12:42:18 <dylukes> monochrom what happens when you "observe" and obtain a superposition of states,
12:42:29 <dylukes> and have to specify a gauge to map that superposition to a plain value?
12:42:39 <dylukes> Is this the birth of quantum codata?
12:42:41 <monochrom> Wait, I thought the observing kills the superposition.
12:42:49 <dylukes> That's interpretation.
12:43:06 <dylukes> The concept of "observer" is not in most conversation well defined.
12:44:09 <geekosaur> ob https://www.sciencedaily.com/releases/2017/03/170324192503.htm
12:44:13 <dylukes> monochrom: the uncertainty principle is amusing. When you try to understand the math from common sense, it makes no sense.
12:44:25 <dylukes> When you accept it a priori mathematically as a necessity, it makes perfect sense.
12:44:38 <sophiag> what exactly is the purpose of the BooleanFormula type? i could use something very much like that, except it only allows AND and OR and not negation or equality so it seems i'm stuck using lambdas, which have a more complicated AST
12:45:08 <dylukes> monochrom: There's an often repeated conflation of the observer effect and the uncertainty principle.
12:45:40 <dylukes> The observer effect states that you can't observe a physical system without disrupting it.
12:45:46 <dylukes> The uncertainty principle is much more fundamental.
12:47:41 <dylukes> monochrom: https://hackage.haskell.org/package/QIO-1.3/docs/QIO-QioSyn.html#t:QIO
12:47:44 <dylukes> apparently this has been done already haha.
12:50:23 <nshepperd_> When you observe something, you become a superposition
12:51:09 <nshepperd_> monochrom: in what category are data and codata initial/final?
12:51:09 <dylukes> instructions unclear, path integrated genitals through ceiling fan.  
12:52:02 <monochrom> Given a functor F, have a category of F-algebras, then "data" based on that F is the initial algebra in that category.
12:52:49 <dylukes> I still haven't really connected the semantics of F-algebras to data structures :\.
12:53:48 <monochrom> And for the other one, I forgot whether it's the category of F-algebras again, or you need a category of F-coalgebra, but either way you look at the final object for "co-data"
12:53:49 <dylukes> monochrom but what about F-coalgebras?
12:53:58 <ertes> dylukes: do you understand the idea that recursive data structures can be represented as fixed points of flat ones?
12:54:06 <dylukes> Yup.
12:54:16 <dylukes> So wait,
12:54:48 <monochrom> Oh w00t I do know of a thick paper rabbit hole I can send you down.
12:55:09 <dylukes> What is the word for such a structure ertes?
12:55:19 <dylukes> I know what it is but I want to be precise in my wording.
12:55:26 <dylukes> I usually just think of them as "factored out". 
12:55:30 <dylukes> or free.
12:55:33 <dylukes> in some sense.
12:55:36 <ertes> dylukes: "data structure"?  good question
12:55:36 <dylukes> (imprecise sense*)
12:55:40 <dylukes> No I mean.
12:56:09 <monochrom> http://www.cs.ru.nl/B.Jacobs/PAPERS/JR.pdf  "a tutorial on (co)algebraic and (co)induction"
12:56:21 <dylukes> I'm missing keywords haha.
12:56:26 <monochrom> it's how I became a lost lamb. :)
12:57:54 <monochrom> Interesting data structures are seldom inital algebras or final coalgebras.
13:00:02 <monochrom> For example cons-lists and binary trees are initial algebras, but they never satisfy our insatiable quest for performance (even theoretical big-O performance). No, we must inflict extra restrictions like "search tree" and "balanced" and "finger" etc.
13:01:25 <dylukes> monochrom trying to remember what the word for this is....
13:01:45 <dylukes> okay so
13:02:07 <dylukes> "data List a = Nil | List a" vs "data List f a = Nil | f a"
13:02:18 <dylukes> where the latter can be fixed to get the former.
13:02:25 <monochrom> Yes.
13:02:25 <dylukes> What is the term for the latter, with the f?
13:02:28 <ski> syntax error
13:02:34 <dylukes> ayyy.
13:02:46 <kadoban> ski: xD
13:03:10 <monochrom> It doesn't often get called a name, but when it does, people say "the base functor".
13:03:28 <jle`> that's what it's called in the recursion-schemes library at least
13:03:31 <ertes> dylukes: [a] ≃ Fix ListF  -- solve for ListF (you were close)
13:03:44 <ski> .. except it's not unique
13:03:45 <dylukes> ertes my memory is fuzzy haha.
13:03:57 <jle`> er i meant that as "i know that, at least"
13:04:04 <jle`> http://hackage.haskell.org/package/recursion-schemes-5.0.1/docs/Data-Functor-Foldable.html
13:04:04 <dylukes> I also do not know how to solve for ListF there.
13:04:11 <dylukes> Well, I do.
13:04:15 <monochrom> But more often a paper simply says "Let F be a functor. We now talk about the F-algebras." and therefore it can just keep saying "F".
13:04:15 <dylukes> It's just a congruence I suppose.
13:04:18 <dylukes> I don't know the rules though.
13:04:34 <ski>   ListF a r = 1 + a + a^2 * r
13:04:53 <dylukes> Wait what, why is there a characteristic polynomial?
13:04:58 <dylukes> ;___;
13:05:14 <jle`> that's just the definition of ListF that you gave
13:05:18 <dylukes> monochrom What is the relationship (if any) between "base functor" and initial algebras?
13:05:39 <dylukes> ski: I'm not sure where the a^2 term came from... 
13:06:10 <monochrom> The relationship is exactly the definition of "initial algebra".
13:06:19 <dylukes> Ok, that's what I thought :).
13:06:19 <monochrom> I'm going to pull your leg but:
13:06:24 <dylukes> *poot*
13:06:38 <monochrom> catmorphism :: (F r -> r) -> Meow F -> r
13:06:57 <ertes> dylukes: and i was being stupid:  [a] ≃ Fix (ListF a)
13:06:59 <ertes> of course =)
13:07:01 <ski>   [a]  ≅  μ r. ListF a r  =  μ r. 1 + a + a² · r
13:07:02 <ski> also
13:07:11 <ski>   [a]  ≅  μ r. 1 + a · r
13:07:14 <ski> <ski> .. except it's not unique
13:07:25 <dylukes> I'm not familiar with the notation.
13:07:30 <dylukes>  μ r. in particular.
13:08:05 <ertes> dylukes: type-level fix
13:08:13 <monochrom> Now I have to think up the dual joke for anamorphism.
13:08:22 <ertes> Fix (\r -> 1 + a * r)
13:08:23 <ski> ⌜μ r. ⋯r⋯⌝ is ⌜Mu (λ r. ⋯r⋯)⌝
13:08:31 <dylukes> Wait, how does ListF a r ⇒ 1 + a + a² · r?
13:08:44 <dylukes> I get the basic idea but where'd the a^2 term come from?
13:08:46 <ski> ⌜x + y⌝ is ⌜Either x y⌝
13:08:47 <ertes> dylukes: what is a list?
13:08:57 <ski> ⌜x · y⌝ is ⌜(x,y)⌝
13:09:05 <dylukes> Oh right.
13:09:08 <ski> ⌜x²⌝ is ⌜(x,x)⌝
13:09:13 <ertes> it's either 1 (empty), a (one item), a² (two items), a³ (three items) or …
13:09:44 <dylukes> data List = Nil | Cons a (List a) ⇒ 1 + a * (???)
13:09:44 <ertes> data ListF a x = Nil | Cons1 a x | Cons2 a a x
13:09:57 <ertes> no
13:10:01 <jle`> dylukes: in haskell, List a = Nil | Cons a (List a)
13:10:03 <ertes> data ListF a x = Nil | Singleton a | Cons2 a a x
13:10:08 <ski> yes
13:10:11 <dylukes> the missing "a" was a typo.
13:10:13 <jle`> dylukes: so L x = 1 + (x * L x)
13:10:24 <dylukes> Wat, you've got a singleton and a cons now? 
13:10:26 <ertes> dylukes: this ListF is also a valid solution
13:10:30 <dylukes> I was only considering a much simpler list.
13:10:41 <jle`> we're expanding out your definition
13:10:41 <dylukes> jle` right then solve the recurrence?
13:10:44 <jle`> since it's recursive
13:10:44 <ertes> dylukes: ski is just proving their point that there are infinitely many valid ListFs
13:10:56 <jle`> L(x) = 1+ x L(x)
13:11:02 <dylukes> Sorry getting many explanations at once in slightly different syntax. 
13:11:05 <dylukes> Been a long day :p.
13:11:08 <ski> dylukes : the point is that there's *more* than one way to get a ⌜ListF a⌝ such that ⌜[a]⌝ is iso to ⌜Fix (ListF a)⌝
13:11:08 <jle`> L(x) = 1 + x * (1 + x*L(x))
13:11:17 <dylukes> ⌜?
13:11:29 <jle`> L(x) = 1 + x * (1 + x*(1 + x*L(x)))
13:11:43 <jle`> so after three expansions, L(x) = 1 + x + x*2 + x*3L(x)
13:11:46 <ski> dylukes : one being ⌜ListF a r = 1 + a · r⌝, another being ⌜ListF a r = 1 + a + a² · r⌝
13:11:55 <jle`> er, 1 + x + x^2 + x^3 L(x)
13:12:03 <ertes> dylukes: but in practice you would of course use this one:  data ListF a x = Nil | Cons a x
13:12:09 <dylukes> ski Oh I wasn't following that at all.
13:12:12 <jle`> which says, "a list is either nil (1), or a single item x, or two x's, or three x's and another list
13:12:23 <dylukes> I'm getting a bit overloaded by multiple explanations of different things at once, tbh.
13:12:29 * ski nods
13:12:30 <jle`> alright i'll drop out :)
13:12:35 <dylukes> I was trying to just suss out my own understacking/lack thereof.
13:12:39 <dylukes> Of one concept.
13:12:42 <dylukes> I also don't know this syntax.
13:12:52 <dylukes> ⌜⌝?
13:12:58 <ski> that's just quotation marks
13:13:05 <dylukes> Oh. Never seen those before.
13:13:36 <dylukes> ski ertes Ok I follow.
13:13:41 <boxscape> the symbols in unicode are called "top left corner" and "top right corner"
13:13:46 <dylukes> So what you're saying is (correct me if I'm wrong)
13:13:58 <ertes> dylukes: alright…  now we have a ListF such that:  [a] ≃ Fix (ListF a)
13:14:02 <dylukes> that the recurrence that defined ListF has countable solutions?
13:14:34 <ski> countably many different solutions, yes
13:14:47 <dylukes> That said,
13:15:01 <dylukes> Cons2 a a x ⇒ Cons a (Cons a x)
13:15:08 <ertes> dylukes:  exercise: look at this function: listCata :: (ListF a r -> r) -> Fix (ListF a) -> r
13:15:25 <dylukes> It seems like only the first solution provides (in a very non-rigorous way of putting it) a basis for lists of arbitrary length.
13:15:37 <ertes> dylukes: do you see how this function might be equivalent to foldr?
13:15:46 <dylukes> Lemme stare at it one moment.
13:16:39 <ertes> dylukes: (it doesn't have to be, but of course i'm suggesting that one could write a function with this signature that is equivalent to foldr)
13:16:48 <dylukes> I'm not sure I entirely see it.
13:16:55 <dylukes> Would you mind elaborating a little bit?
13:17:02 <dylukes> I see generally, but not the specific correspondence.
13:17:06 <ertes> ListF a x ≃ 1 + a*x
13:17:08 <ertes> right?
13:17:20 <dylukes> Right.
13:17:29 * ski . o O ( ⌜[a]  ≅  ∀ r. (ListF a r → r) → r⌝ )
13:18:03 <ertes> listCata's type is isomorphic to:  ((1 + a*r) -> r) -> [a] -> r
13:18:06 <ertes> still good?
13:18:23 <dylukes> Yeah, I was actually just typing that out myself haha. 
13:19:17 <dylukes> I'm trying to parse what  (ListF a r -> r) means exactly. 
13:19:30 <dylukes> I'm not clear on, concretely, what returning r means. 
13:19:54 <ertes> ≃ r^(1 + a*r) -> [a] -> r ≃ r^(a*r) * r -> [a] -> r ≃ r^(a*r) -> r -> [a] -> r ≃ (a*r -> r) -> r -> [a] -> r ≃ (a -> r -> r) -> r -> [a] -> r
13:20:08 * ski . o O ( ⌜(x + y) → r  ≅  (a → r) · (y → r)⌝ )
13:20:15 <ertes> write this into your editor and lay it out on multiple lines to see it more clearly
13:20:16 * ski . o O ( ⌜0 → r  ≅  1⌝ )
13:20:32 * ski . o O ( ⌜(x · y) → r  ≅  x → (y → r)⌝ )
13:20:39 * ski . o O ( ⌜1 → r  ≅  r⌝ )
13:21:11 <dylukes> Ok, I follow that.
13:21:18 <dylukes> I was thinking that before, expanding with exponentiation.
13:21:24 <dylukes> what I'm not clear on is what r is.
13:21:39 <ski> (er, ⌜x⌝, not ⌜a⌝, there)
13:21:41 <dylukes> Oh wait, my bad.
13:21:51 <dylukes> I was thinking of r as * → * 
13:21:54 <dylukes> for some reason.
13:21:59 <dylukes> Now I see it.
13:22:03 <dylukes> That explains my confusion!
13:22:20 <dylukes> I need to actually get back into haskell properly. Back when I was here so many years ago I was a greenhorn mathematically.
13:22:22 <dylukes> I still am,
13:22:29 <dylukes> but at least I have some degrees now.
13:22:36 <ertes> dylukes: ok, here is a hypothesis: *any* list function can be written in terms of foldr…  would you believe that?
13:22:45 <dylukes> Despite my algebraic intentions I took a very long detour through analysis.
13:22:58 <dylukes> Ended up in graduate level partial differential equations. That was fun.
13:23:10 <dylukes> I think I'm ready for some algebra palette cleanser though. 
13:23:20 <dylukes> ertes Well yeah.
13:23:43 <dylukes> foldr is, in some sense, uh... it matches the structure of lists. 
13:23:46 <ertes> dylukes: so would it be fair to say that foldr captures the structure of lists entirely?
13:23:50 <ertes> yeah, exactly
13:23:53 <dylukes> Again, imprecise wording but I do get that.
13:24:00 <nitrix> It captures more than lists afaik.
13:24:14 <ertes> so here is another way to define lists:  type List a = forall r. (a -> r -> r) -> r -> r
13:24:26 <ertes> (the church encoding for lists)
13:24:26 <dylukes> It could also capture any arithmetic on the naturals I would imagine.
13:24:39 <ertes> well, naturals are just [()] =)
13:24:45 <dylukes> Er wait, thinking of something else.
13:24:50 <dylukes> But yes.
13:25:00 <nitrix> ertes: Funky. That looks kinda like ShowS.
13:25:17 <dylukes> Can you give any other examples of this phenomenon?
13:25:25 <dylukes> Or foldr capturing the structure of lists, for other structures? 
13:25:28 <dylukes> And what I would call this?
13:25:41 <dylukes> Concepts are great, but they're better with names so I can do research later..
13:25:44 * ski . o O ( ⌜flip listCata  ∷  Mu (ListF a) → (∀ r. (ListF a r → r) → r)⌝ )
13:25:49 <Sonolin> wow nitrix, mind = blown
13:25:51 <ertes> dylukes: data TreeF a x = Leaf a | Branch a x x
13:25:52 * ski . o O ( ⌜λ m ↦ m In  ∷  (∀ r. (ListF a r → r) → r) → Mu (ListF a)⌝ )
13:26:16 <ertes> whoops
13:26:19 <ertes> dylukes: data TreeF a x = Leaf a | Branch x x
13:26:33 <ertes> dylukes: type Tree a = forall r. (r -> r -> r) -> (a -> r) -> r
13:26:52 <dylukes> I follow.
13:26:52 <ertes> more generally:
13:27:16 <nitrix> > shows 42 "x" -- Sonolin constant time concatenation :P
13:27:18 <lambdabot>  "42x"
13:27:23 <dylukes2> Hi. 
13:27:26 <dylukes2> On mobile.
13:27:43 <ertes> type Mu f = forall r. (f r -> r) -> r
13:27:46 <ski> dylukes : "And what I would call this?" -- "catamorphism"
13:27:53 <dylukes> That's what I thought haha.
13:28:00 <dylukes> I thought it was called a bird.
13:28:02 <dylukes> ;)
13:28:05 <ertes> this is the *algebraic* representation, but there is another one
13:28:20 <ski> as in Richard Bird, of "Algebra of Programming", together with Oege de Moor ?
13:28:49 <dylukes> Not familiar with Oege de Moor.
13:28:53 <dylukes> ertes what is the other one?
13:29:00 <dylukes> combinatorial?
13:29:15 <ertes> data Nu f = Nu (s -> f s) s
13:29:20 <ertes> the coalgebraic one
13:29:33 <ertes> the idea is that unfoldr captures the structure of lists just as well as foldr
13:29:41 <dylukes2> Hmm. 
13:29:53 <dylukes2> I guess yeah, unfoldr illustrates how to generate a list. 
13:29:58 <ski> dylukes : also see "To Dissect a Mockingbird: A Graphical Notation for the Lambda Calculus with Animated Reduction" by David C Keenan in 1996-08-27 (through 2014-04-01) at <http://dkeenan.com/Lambda/> for more birds
13:30:00 <ertes> exactly
13:30:05 <ertes> read "s" as "state" =)
13:30:12 <dylukes2> Actually unfoldr seems like it would intuitively make more sense in general. 
13:30:17 <dylukes2> I'm just very used to folding 
13:30:33 <dylukes2> Ski: word
13:30:39 * ski hands ertes an ⌜∃⌝
13:30:47 <ertes> whoops, yeah
13:30:52 <ertes> data Nu f = forall s. Nu (s -> f s) s
13:30:54 <dylukes2> ertes: so is a PRNG basically just an unfold?
13:30:56 <dylukes2> :p
13:31:19 <ertes> it's a list =)
13:31:26 <ertes> you can represent it as a fold or as an unfold
13:31:30 <jle`> :t unfoldr
13:31:32 <lambdabot> (b -> Maybe (a, b)) -> b -> [a]
13:31:42 <dylukes2> How would you represent it as a fold?
13:31:54 <dylukes2> I'm in the mindset of representing some things as folds and others as unfolds.
13:32:03 <dylukes2> I'm not entirely clear on their equivalence. 
13:32:23 <ski> @type System.Random.split
13:32:26 <lambdabot> RandomGen g => g -> (g, g)
13:33:27 <ertes> lrandoms g' f z = let (x, g) = random g' in f x (lrandoms g f z)
13:33:32 <ertes> dylukes2: ^
13:33:49 <jle`> > unfoldr (\g -> Just (System.Random.Split g)) (mkStdGen 34234)
13:33:51 <lambdabot>  error:
13:33:51 <lambdabot>      Not in scope: data constructor ‘System.Random.Split’
13:33:51 <lambdabot>      Perhaps you meant one of these:
13:33:56 <ertes> type List a = forall r. (a -> r -> r) -> r -> r
13:34:03 <ertes> lrandoms :: (Random a, RandomGen g) => g -> List a
13:34:18 <ski> `z' is dead
13:35:22 <ertes> lrandoms g0 f _ = let go g' = let (x, g) = random g' in f x (go g) in go g0
13:35:24 <ertes> ski: better? =P
13:35:28 <dylukes2> ertes I'm not sure I follow the relationship between ListF and Mu 
13:35:33 <dylukes2> Abstractly yes 
13:35:38 <dylukes2> But mathematically no 
13:36:19 <dylukes2> They seem fundamentally different.
13:36:42 <ertes> incoming spam…
13:36:52 <ertes> data ListF a x = Nil | Cons a x
13:36:53 <ertes> type List a = forall r. (ListF a r -> r) -> r -> r
13:36:53 <ertes> lrandoms g0 f _ = let go g' = let (x, g) = random g' in f (Cons x (go g)) in go g0
13:37:00 <ski> ⌜Mu F⌝, aka ⌜μ r. F r⌝, is the least ⌜r⌝ which is iso to ⌜F r⌝
13:37:01 <monochrom> Not much relationship except we use Mu on ListF, "Mu ListF"
13:37:13 <ski> ⌜Nu F⌝, aka ⌜ν r. F r⌝, is the greatest ⌜r⌝ which is iso to ⌜F r⌝
13:37:14 <ertes> oops
13:37:19 <ertes> that was nonsense
13:37:28 <MarcelineVQ> ski: you've upgraded your quotation marks
13:37:36 <ertes> type List a = forall r. (ListF a r -> r) -> r
13:37:36 <ertes> lrandoms g0 f = let go g' = let (x, g) = random g' in f (Cons x (go g)) in go g0
13:37:39 <ski> MarcelineVQ : only with unicode
13:37:40 <ertes> dylukes2: ^
13:37:58 <ski> (and it's not new)
13:38:11 <dylukes2> Er 
13:38:20 <dylukes2> I'm a bit confused by the PRNG thing 
13:38:25 <dylukes2> I just mentioned that off hand. 
13:38:31 <ertes> dylukes2: can you write the empty List?
13:38:38 <dylukes2> Nil
13:38:40 <dylukes2> :p
13:38:41 <ertes> no
13:38:48 <ertes> not the empty ListF, but the empty List
13:39:11 <dylukes2> Isn't that still Nil? Or do you want []?
13:39:20 <ertes> no, Nil is a type error
13:39:25 <dylukes2> I don't think we're on the same page. 
13:39:29 <ertes> nil :: List a
13:39:36 <ertes> nil = _fillThisIn
13:39:37 <monochrom> No no, the forall r. (a -> r -> r) -> r -> r version.
13:39:48 <ertes> remember: type List a = forall r. (ListF a r -> r) -> r
13:39:55 <monochrom> Or that, yeah.
13:40:19 <ski> it should have type ⌜∀ a. List a⌝, iow ⌜∀ a r. (ListF a r → r) → r⌝
13:41:08 <dylukes> I'm still trying to understand the "equivalence" of `data Nu f = forall s. Nu (s -> f s) s' and the algebraic form.
13:41:27 <monochrom> No, that one is going to be co-algebraic.
13:41:33 <ertes> dylukes: start by understanding the algebraic form =)
13:41:43 <ertes> and start that by writing 'nil' ;)
13:41:54 <dylukes> "[16:27:44]  <ertes>	this is the *algebraic* representation, but there is another one"
13:41:58 <dylukes> after that you lost me.
13:42:09 <dylukes> I wasn't sure what you were trying to illustrate, or misunderstood the destination.
13:42:36 <monochrom> Yeah we need to go slower.
13:43:13 <dylukes> I was following fine till then.
13:43:27 <dylukes> I just still don't know why you introduced Nu or what you were trying to illustrate with it.
13:43:35 <ertes> dylukes: i recommend that you ignore that for now
13:43:40 <dylukes> Ok, haha.
13:44:45 <ertes> well, i can explain it in prose:  a (List a) is a function that takes a (ListF a)-algebra and computes a result from it by feeding it the list elements
13:45:21 <ertes> a (ListF a)-algebra is just a function of type (ListF a r -> r), i.e. an object 'r' together with a function of type (ListF a r -> r)
13:45:36 <ertes> to really understand what this means requires that you implement a few examples
13:45:37 <python476> hi
13:45:51 <dopey_> can anyone recommend a guide for calling C functions from haskell code? I have found a number of guides for using the foreign function interface, but nothing recent that steps all the way through compilation. the few articles that I have found with compilation examples seem to be outdated. 
13:45:51 <ertes> start with the simplest: 'nil' =)
13:46:08 <python476> At a meetup someone mentioned monadic bind, yoneda and something named "cailey"; does this ring (sic) a bell to you ?
13:46:47 <ertes> python476: the first one is a common haskell concept, the second one is less common, the third i've never heard before =)
13:46:50 <glguy> python476: http://hackage.haskell.org/package/profunctors-5.2/docs/Data-Profunctor-Cayley.html
13:47:05 <python476> ertes: thanks, glguy thanks even more
13:48:53 <ExpHP> What the... what on earth is a Pastro!?
13:49:11 <ExpHP> These look like names out of a Lord of the rings novel: http://hackage.haskell.org/package/profunctors-5.2/docs/Data-Profunctor-Monad.html#t:ProfunctorFunctor
13:49:23 <ExpHP> (the instances)
13:49:23 <monochrom> I don't know Pastro. But I know Paw Patrol.
13:49:31 <python476> I know Castrol
13:49:48 <ertes> i know Zygohistrol
13:49:54 * ski . o O ( Cryptol )
13:50:06 <monochrom> haha, what have I done
13:50:13 <python476> and people complain about casual Haskell code..
13:50:36 <dylukes> "a (ListF a)-algebra is just a function of type (ListF a r -> r), i.e. an object 'r' together with a function of type (ListF a r -> r)"
13:50:37 <Sornaensis> haskell has some of the most comprehensible names imho
13:50:37 <dylukes> uh wait
13:50:50 <dylukes> Is it (ListF a r -> r)? Or (ListF a r -> r) together with an object r?
13:51:04 <ertes> dylukes: yes =)
13:51:29 <ertes> once you've picked a function of type (ListF a r -> r), you have at the same time picked an 'r'
13:51:33 <python476> installing stack is a bliss
13:51:40 <ski> dylukes : it's (for the functor ⌜ListF a⌝) : a pair of a type ⌜r⌝, and a value of type ⌜ListF a r → r⌝
13:51:41 <monochrom> dylukes, if I write so much as "ListF Int String -> String" then I have already implicitly specified that I want r = String.
13:51:53 <dylukes> I do understand, vaguely, the relationship between base functor types and expressions, and the fixed (whatever the correct word is) types and evaluations of those expressions.
13:52:30 <ertes> dylukes: an F-algebra is an object (here: a type) 'a' together with a morphism (F a -> a) (here: a function)
13:52:39 <ertes> here F = ListF a
13:53:37 <ertes> of course due to type inference you don't need to specify your pick of 'r'…  it will be inferred
13:53:52 <ertes> (usually at least)
13:56:24 <ertes> dylukes: BTW, here is a hint that may help you: there is only one way to write 'nil'
13:56:29 <ertes> just use the types to guide you
13:59:23 <vlnts> is it considered bad style to not use infix with on, mod etc ?
13:59:35 <monochrom> No. Either is fine.
14:00:20 <ExpHP_> I think it's a bit confusing;  if I saw (div 3) I might misread it as division by 3
14:00:56 <ExpHP_> but at the same time that sort of stuff is so rare that it's pretty much always a mistake if I ever do see it
14:01:25 <ExpHP_> er, "that sort of stuff" = "(div 3)"
14:01:54 <dylukes> One moment ertes, I have to run.
14:01:57 <michi7x7> > (div 3) 8
14:01:57 <dylukes> I will come back soon.
14:01:59 <lambdabot>  0
14:02:15 <michi7x7> äh?
14:02:17 <ski> dylukes : in general, for a functor ⌜F⌝, an ⌜F⌝-algebra is a pair ⌜⟨a,c⟩⌝, where ⌜a⌝ is a type and ⌜c⌝ (one can think "construct" or "combine") is a function of type ⌜F a → a⌝
14:02:18 <dylukes> Thanks for all of your help, all of you :).
14:02:24 <ski> dylukes : there is a category whose objects are such pairs, and a morphism from ⌜⟨a,c⟩⌝ to ⌜⟨b,d⟩⌝ (with ⌜a⌝,⌜b⌝ types, and functions ⌜c : F a → a⌝,⌜d : F b → b⌝) consists of a function ⌜f : a → b⌝ such that ⌜d ∘ F f  = f ∘ c⌝, where ⌜F f⌝ in Haskell terms would be ⌜fmap f⌝. the composition on the left here goes ⌜b  ⟵  F b  ⟵  F a⌝, while the one on the right goes ⌜b  ⟵  a  ⟵  F a⌝
14:02:27 <michi7x7> > 8 `div` 3
14:02:29 <lambdabot>  2
14:02:31 <ExpHP_> > (`div` 3) 8
14:02:33 <lambdabot>  2
14:03:23 <ExpHP_> Basically, a lot of operators make most sense when curried oer the second argument first
14:05:04 <monochrom> That is basically failing to see that the other 50% of the people find that the opposite makes most sense.
14:05:48 <monochrom> Even within the same person, half of the time they say "substract 5 by 3, divide 6 by 2", and the other half of the time it's "substract 3 from 5, divide 2 into 6".
14:06:11 <vlnts> I just find it easier reading without infix 
14:06:23 <boxscape> I find it easier typing without infix
14:06:28 <ExpHP> I can count on two hands all the instances where I've had a single number x, and a bunch of numbers I wanted to subtract from x
14:06:42 <monochrom> In fact I just witnessed the Canadian tax forms switch from the latter to the former some 10 years ago.
14:06:48 <ertes> even GHC has trouble sometimes
14:06:55 <ertes> > map (- 3) [1,2,3]
14:06:57 <lambdabot>  error:
14:06:57 <lambdabot>      • Could not deduce (Num a0)
14:06:57 <lambdabot>        from the context: (Num (a -> b), Num a)
14:07:01 <ExpHP> hehe
14:07:06 <boxscape> :t (`div`)
14:07:07 <lambdabot> error: parse error on input ‘)’
14:07:13 <boxscape> I feel like that should convert it back to prefix form :P
14:07:27 <Sornaensis> nothx
14:07:35 <ExpHP> map (flip (-) 3) [1,2,3]
14:07:42 <ExpHP> > map (flip (-) 3) [1,2,3]
14:07:44 <lambdabot>  [-2,-1,0]
14:07:50 <ertes> > map (subtract 3) [1,2,3]
14:07:52 <lambdabot>  [-2,-1,0]
14:08:20 <boxscape> would be much easier if mathematicians hadn't chosen to overload -
14:08:47 <MarcelineVQ> overload?
14:08:56 <ertes> (+) vs. negate
14:09:01 <boxscape> assign two meanings to the same symbol
14:09:07 <ertes> but mathematicians loooooooooove to overload things
14:09:11 <boxscape> that is true
14:09:22 <monochrom> Did you know they overloaded 0 to no end?
14:09:32 <ExpHP> MarcelineVQ: one doesn't put a bar over something to indicate a reciprocal
14:09:40 <ExpHP> oh wait, except material scientists. drat
14:09:55 <monochrom> 0 the number (and don't get me started on whether it's nat, int, rational, real, or complex), 0 the vector, 0 the matrix, 0 the function...
14:10:12 <ertes> well, it's their mempty
14:10:12 <Sornaensis> :t 0
14:10:14 <lambdabot> Num t => t
14:10:25 <ertes> … and rempty and vempty and …
14:10:28 <Sornaensis> :t (<>)
14:10:28 <boxscape> to be fair, they say that nat is a subset of rational, which you don't do in programming languages, which means that the 0 really is the same
14:10:30 <lambdabot> Monoid m => m -> m -> m
14:10:39 <monochrom> They overloaded it so much, though they don't use 1 for the identity matrix, they do use 0 for the zero matrix.
14:10:54 <ExpHP> in physics we very much use 1 for the identity matrix
14:11:00 <ertes> monochrom: huh?  i've seen 1 there
14:11:03 <ExpHP> operator theory and all that shiznaz
14:11:15 <monochrom> Well yeah the other half of the time they use I
14:11:25 <boxscape> the current identity matrix notation isn't great either, it differs from country to country. (Or at least from US to Germany)
14:11:31 * geekosaur has seen both; depends on who's doing it and probably what subdiscipline
14:11:40 <ertes> i have more trouble with physicists, who don't just overload things, but somehow feel the need to invent their own notation for things that were already there as well
14:11:45 <monochrom> whereas for the zero matrix there is no "the other half of the time", it's 0 unanimously.
14:11:47 <ertes> like that bullshit bra-ket notation they use for vectors
14:11:52 <ExpHP> ertes: I resemble that statement
14:12:31 <Sornaensis> have u ever read physicist code?
14:12:38 <monochrom> I can see the beauty or mnemonic in the bra-ket notation.
14:12:38 <ExpHP> it's all fortran
14:12:42 <ExpHP> all of it
14:12:42 <ertes> no, i don't understand fortran
14:12:43 <Sornaensis> I think the last time a physicist read about CS may have been 1979
14:13:06 <ExpHP> all of my colleagues have fortran as the #1 language they want to learn
14:13:07 <geekosaur> "optimist"
14:13:19 <hpc> did you hear that microchips have reached parity with vacuum tubes?
14:14:12 <ertes> monochrom: beauty?  all it does is make the math more mysterious, but physicists love mysteries, too
14:15:20 <boxscape> physicist code https://en.wikipedia.org/wiki/File:FortranCardPROJ039.agr.jpg
14:17:25 <ExpHP> ertes: I must confess I love the shit out of bras and kets.  They can simultaneously represent discrete vectors and continuous functions in real space, and they help let you know when you've made a mistake because then the pointy bits don't match up
14:18:01 <ertes> ExpHP: it's not bras and kets that represent them, it's vector spaces
14:19:24 <ExpHP> I'm not sure, what's the distinction?
14:19:48 <ExpHP> I take them just to be a language for linear algebra
14:20:34 * ExpHP quietly shoves the existing vector and matrix notation for linalg under the rug
14:21:16 <glguy> And in conclusion it's OK to use div in prefix position?
14:21:49 <monochrom> Yes.
14:21:56 <ertes> my problem is this:  |a> is a vector, and <a| is the conjugate of it, which to my mind is applying a conjugation function to |a>:  (|a>)*, but the application is implicit in the notation, which to my mind makes as little sense as the reference types in C++
14:22:13 <monochrom> The only contention is the order of the parameters.
14:23:01 <boxscape> hm, makes me wonder whether perhaps there could be some notation like "div _ 4" for "\x -> div x 4"
14:23:07 <ExpHP> oh come on it's gotta be a little bit better than C++
14:23:09 <boxscape> generalized sections, if you will
14:23:28 <monochrom> Do you accept (`div` 4)?
14:23:37 <boxscape> well, that works for functions with two parameters
14:23:42 <monochrom> Ah.
14:23:42 <boxscape> but not in general
14:23:44 <ExpHP> implicit conjugation beats rule of 5
14:23:54 <ertes> boxscape: not with that syntax at least, unless you want to give up typed holes
14:24:02 <boxscape> ertes: right, that makes sesne
14:24:17 <monochrom> Well, go 2-dimensional, don't just use left and right, use also above and below.
14:24:26 <ExpHP> okay, rule of 5 is something else.  But whatever the new name is for C++'s rle of 3 that isn't really a rule for 3 anymore
14:24:46 <monochrom> You can accomodate generalized sections for up to 8 parameters if you use all 8 corners.
14:24:53 <monochrom> err, sides and corners!
14:24:58 <boxscape> nice
14:25:10 <ertes> Haskell2K
14:25:11 <monochrom> I wonder if you heard of my Einstein notation joke.
14:25:12 <boxscape> why stop at 2 dimensions though
14:25:18 <monochrom> Yeah!
14:25:18 <boxscape> I have not
14:25:37 <ertes> boxscape: because 3-dimensional text editors don't exist yet
14:25:39 <monochrom> Why did Einstein want 4 dimensions? Because he needs more corners for his Einstein notation.
14:25:55 <nshepperd_> Isn't the point that <a|b> gives the inner product of a and b
14:26:03 <serious> foldr const 0 "abc" is actually 'a' `const` ('b' `const` ('c' `const` 0)), why does it fail?
14:26:28 <boxscape> hm. I'm either missing something or it's just not that funny.
14:26:34 <ertes> nshepperd_: (a* · b) does that, too, with a simpler and more consistent notation =)
14:27:04 <serious> foldr (flip const) 0 "abc" does work for some reasons
14:27:21 <ExpHP> ertes: I think the crux of the matter here is that transposed vectors WITHOUT conjugation are completely, 100%, entirely worthless
14:27:30 <ExpHP> ...in physics
14:27:35 <ertes> serious: because your result type is Char
14:27:45 <nshepperd_> ertes: what's (.)
14:27:59 <boxscape> > foldr const 0 [1..4]
14:28:01 <lambdabot>  1
14:28:21 <ertes> serious: foldr _ 0 "abc" = 0
14:28:32 <ertes> nshepperd_: inner product
14:28:46 <monochrom> This is a debate on basically infix notation vs multifix notation.
14:28:56 <veyd> Hello
14:29:21 <veyd> I was here about 6 months ago while I was getting started with Haskell, asking for book resources
14:29:35 <nshepperd_> But the point is to distinguish vectors vs covectors
14:29:42 <kadoban> veyd: Hello. Get recommended anything good?
14:29:43 <veyd> Someone recommended a book to me that was due to have a new edition published soo
14:29:54 <veyd> I'm trying to figure out which bok that was
14:30:00 <boxscape> @where book
14:30:00 <lambdabot> http://haskellbook.com/
14:30:01 <boxscape> I'm guessing
14:30:05 <veyd> no not that one
14:30:07 <boxscape> ok
14:30:10 <veyd> it was a more academic book
14:30:32 <ertes> veyd: http://www.cs.nott.ac.uk/~pszgmh/pih.html
14:30:34 <ertes> this one?
14:30:37 <geekosaur> I'm thinking Hutton's
14:30:53 <veyd> Yep, that's gotta be it
14:30:55 <veyd> thanks!
14:30:58 <geekosaur> since he was complaining about AMP/FTP landing while he was revising it :)
14:31:01 <monochrom> No, I was wrong. This is two debates combined into one, infix notation without Hungarian notation vs multifix notation with Hungarian notation.
14:31:25 <nshepperd_> dot product of |a> with |b> is a type error, 
14:32:19 <nshepperd_> or something like that. I haven't done any physics with those for a while
14:33:08 <serious> ertes: is my foldr expansion not correct?
14:33:16 <ertes> nshepperd_: when i was learning the basics of QM i actually translated all bra-ket notation to regular vector notation and found it easier to understand (and much more convenient to work with, too)
14:33:49 <serious> this one I mean: 'a' `const` ('b' `const` ('c' `const` 0))
14:34:06 <ertes> serious: it's correct, but you're missing the empty case
14:34:20 <ertes> in the empty case 0 is actually going to be the result
14:34:41 <serious> you mean when the list is empty?
14:34:44 <nshepperd_> ertes: basically, since you only ever use (.) together with (*), you compose them together into one operation, called <•|
14:34:56 <ertes> serious: so if the list is non-empty, you want the result to be a Char, but in the empty case you want it to be whatever 0 is
14:35:16 <ertes> and Char is not a Num instance, so i would expect you to get a "no instance" error
14:35:24 <nshepperd_> The result of which is a function vector -> complex (a covector)
14:36:22 <serious> ertes: thanks, I haven't thought 'bout the empty list really!
14:36:43 <monochrom> Today is ertes's emptyness day! :)
14:36:55 <ertes> indeed =)
14:37:09 <monochrom> The empty list is a very powerful debugging tool.
14:37:19 <monochrom> In human society anyway.
14:37:21 <serious> good to know
14:37:44 <ertes> which one?
14:37:50 <ertes> [] or [] or [] or …?
14:38:00 <monochrom> The lot of them!
14:38:11 <serious> is there a difference?
14:38:30 <Sornaensis> :t []
14:38:31 <lambdabot> [t]
14:38:33 <Sornaensis> sensors indicate no
14:38:52 <ertes> > sum ([] :: [Int])
14:38:54 <lambdabot>  0
14:38:55 <ertes> > sum ([] :: [Bool])
14:38:57 <lambdabot>  error:
14:38:57 <lambdabot>      • No instance for (Num Bool) arising from a use of ‘sum’
14:38:57 <lambdabot>      • In the expression: sum ([] :: [Bool])
14:39:01 <ertes> serious: yes
14:39:06 <serious> ah, you mean the polymorphic variable
14:39:25 <ertes> there are infinitely many empty lists, but there is no list of them
14:39:25 <monochrom> In practice it doesn't matter because the real goal is to get people to think it through.
14:39:58 <Sornaensis> > [[],[],[],[]]
14:40:00 <lambdabot>  [[],[],[],[]]
14:40:04 <jle`> there is a "family" of them
14:40:18 <ertes> not a cons-list though, not even an HList
14:46:18 <serious> how are foldr and foldl implemented under the hood? it looks like the first one is a stack and the latter one is a queue
14:46:20 <jle`> well, once you get an HList of all kind-* types, you can just map them
14:46:40 <jle`> serious: how 'under the hood' do you mean
14:46:51 <jle`> like, how are they implemented within haskell?
14:46:56 <jle`> (since they are normal haskell functions)
14:47:03 <jle`> or how this implementation gets compiled in GHC?
14:47:58 <serious> I mean if those are semantically like stack and queue?
14:48:11 <monochrom> No. They are semantically just recursions.
14:48:25 <jle`> oh, you're asking about their semantics, not their implementation?
14:49:03 <monochrom> But you can ask how to perform recursions on our machines. Then a stack is involved. But there is also laziness too, and so a heap is also involved.
14:49:10 <serious> I'm a bit confused, it is more about how they are compiled after all
14:49:23 <jle`> the list type is pretty much equivalent to the 'stack' abstract data type
14:49:26 <jle`> (semantically)
14:50:03 <jle`> so foldl could be seen as popping off items in the stack one-by-one and modifying an accumulator during the process against each new item seen
14:50:06 <serious> it looks like I can implement those with a stack data structure or queue (in case of foldl)
14:50:28 <jle`> well, list *is* a stack data structure
14:50:49 <monochrom> But then you're fine-tuning to the list type, and you don't know how to compile other kinds of code.
14:51:39 <serious> but foldl starts reducing with the first element, no? like "acc f head"
14:52:10 <monochrom> If I define a tree type and write an in-order walk, a post-order walk, and a pre-order walk, how are you going to compile that?
14:52:10 <jle`> yes, foldl pops items off the list and accumulates them one-by-one
14:52:57 <monochrom> And no, because of laziness, foldl starts with reducing the recursive call to foldl.
14:53:08 <jle`> but what i'm talking about ins't really related to the bytecode that is compiled eventually
14:53:16 <Hi-Angel> I can't wrap my head around it. Here's a simple function "foldl' (\acc i -> acc >>= print >> fmap (i+) acc) (return 0) [1..5]" It just sums up a list [1..5] starting with an IO Int, and prints intermediate values. But it prints 31 values! Like, if "acc" turned from IO Int to a list of some kind. I completely ran out of ideas to understand what's wrong in there.
14:54:04 <jle`> Hi-Angel: you do acc twice
14:54:14 <jle`> under each accumulation
14:54:35 <jle`> so you're going to be doing ~ 2^5 prints
14:55:01 <monochrom> Hi-Angel: I recommend simply  myIOInt >>= \x -> print (foldl' (+) x [1..5])
14:55:14 <monochrom> In fact use do-notation.
14:55:21 <Hi-Angel> jle`: I don't see it. I do print once, in "acc >>= print", don't I?
14:56:04 <jle`> Hi-Angel: you do 'acc' twice
14:56:17 <Hi-Angel> monochrom: no, it's a reduced part from another code, where the foldl' is a separate function, and print also a separate one
14:56:18 <jle`> and acc contains printing statements
14:56:22 <monochrom> Oh, you want to print intermediate values too. Then I'll have to think again.
14:56:49 <ertes> jle`: you will never get such an HList
14:57:02 <jle`> Hi-Angel: try unrolling it by hand
14:57:07 <jle`> and getting the full IO action
14:57:49 <jle`> Hi-Angel: 'acc' doesn't just return an item...it also prints stuff too
14:58:13 <jle`> so 'acc >>= print >> fmap (+1) acc' says "do 'acc', which could print stuff, and then print something, and do 'acc' again"
14:58:24 <jle`> so whatever effects 'acc' does is executed twice
14:58:37 <ertes> Hi-Angel: do you see that 'acc' is an action?
14:58:39 <jle`> for IO, fmap doesn't modify the effects
14:58:44 <ertes> it's not the result of an action, but an action itself
14:58:47 <Hi-Angel> I think
14:58:48 <jle`> 'fmap f x' has the same effects as 'x'
14:58:52 <jle`> (for IO)
14:59:05 <jle`> for example, 'fmap length getLine' has the same effects as 'getLine'
14:59:18 <jle`> 'fmap (const 10) (putStrLn "hello")' has the same effects as 'putStrLn "hello"'
14:59:44 <jle`> so, `acc >>= print >> fmap (+1) acc` has the same effects as 'acc >>= print >> acc'
15:00:34 <Hi-Angel> Okay, I think I see. But, does that mean "IO Int" causes a print itself?
15:00:47 <Hi-Angel> I.e. when it's unwrapped in fmap call
15:00:50 <jle`> so, if 'acc' was `putStrLn "hi!"`, then  `acc >>= print >> acc` would be `putStrLn "hi" >>= print >> putStrLn "hi"`
15:01:01 <jle`> Hi-Angel: it doesn't really get 'unwrapped'
15:01:08 <jle`> what you're doing is building up a description of an IO action
15:01:16 <ertes> Hi-Angel: your fold starts with an initial action (return 0) and list item by list item constructs a more and more complex action
15:01:28 <ertes> so the initial action doesn't print
15:01:35 <jle`> an 'IO Int' is a data structure that represents IO actions
15:02:13 <jle`> so what you're doing is building one up bit by bit, and then handing it off to whatever is going to eventually execute it
15:02:23 <ertes> Hi-Angel: foldl' (\currentAction x -> do currentAction >>= print; (+ x) <$> currentAction) (return 0) [1..5]
15:02:27 <Hi-Angel> So, every time I do "fmap", all previous IO actions are being executed once, more, right?
15:02:35 <ertes> no
15:02:37 <jle`> well, fmap doesn't actually trigger any actions
15:02:43 <jle`> fmap doesn't affect actions at all
15:02:57 <jle`> so 'acc >>= print >> acc' does whatever effects in 'acc' *twice*
15:03:03 <ertes> Hi-Angel: you're thinking in side effects, but you should be thinking in first-class actions
15:03:09 <monochrom> But fmap preserves whatever action you said.
15:03:15 <jle`> the fact that you use 'acc' twice in there is what causes the effects to waht happens twice
15:03:48 <jle`> so, if 'acc' prints 'hello", then `acc >>= print >> acc` prints hello twice
15:03:57 <Hi-Angel> I think I see.
15:04:00 <jle`> and also an extraneous something in between
15:04:16 <jle`> yeah, it might help to think of IO actions as just normal data structures, and not magical effect launchers
15:04:17 <ertes> Hi-Angel: acc >>= print >> fmap (+ i) acc  -- this is the action that first executes the action acc, prints its result, then executes the action acc again, changing its result by the function (+ i)
15:04:32 <Hi-Angel> That complicates matters though. How would then I print an intermediate value?
15:04:34 <ertes> note: "is"
15:04:36 <ertes> not "does"
15:04:55 <monochrom> foldl' (\acc x -> acc >>= \a ->  ... now you can use a ...
15:05:08 <jle`> Hi-Angel: you can accumulate the values using scanl, maybe
15:05:23 <jle`> Hi-Angel: but yeah, if you actually unrolled your fold by hand, you'll see where things go wrong
15:05:24 <ertes> Hi-Angel: BTW, you should probably use foldr
15:05:53 <ertes> not probably, but almost certainly =)
15:05:58 <jle`> foldl' (\acc i -> acc >>= print >> fmap (i+) acc) (1:2:[])
15:06:00 <monochrom> Have you read my I/O tutorial? http://www.vex.net/~trebla/haskell/IO.xhtml
15:06:14 <jle`> @src foldl
15:06:15 <lambdabot> foldl f z []     = z
15:06:15 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
15:06:30 <Hi-Angel> Nope. Why foldr though?
15:06:32 <ertes> Hi-Angel: read monochrom's tutorial, and once you're finished read my fold tutorial: http://ertes.eu/tutorial/foldr.html
15:06:37 <Hi-Angel> :D
15:06:58 <ertes> Hi-Angel: because your fold actually builds an action in memory before it can be executed
15:06:58 <jle`> => foldl (\acc i -> acc >>= print >> fmap (1+) acc) (return 0 >>= print >> return 1) (2:[])
15:07:08 <ertes> by using foldr you can have the action executed *during* folding
15:07:20 <jle`> => foldl (\acc i -> ...) ((return 0 >>= print >> return 1) >>= print >> (return 0 >>= print >> return 2) []
15:07:32 <ertes> :t foldr (\x continue -> print x >> continue) (pure ())
15:07:34 <lambdabot> (Show a, Foldable t) => t a -> IO ()
15:07:37 <jle`> => (return 0 >>= print >> return 1) >>= print (return 0 >>= print >> return 2)
15:07:41 <jle`> ^ do you see why this causes three prints?
15:07:43 <ertes> Hi-Angel: this one can print infinite lists
15:07:54 <ertes> foldl' could never print an infinite list
15:08:16 <jle`> because 'acc' is (return 0 >>= print >> return 1), if you did 'acc >>= print >> fmap (i+) acc', you'd get (return 0 >>= print >> return 1) >>= print >> (retunr 0 >>= print >> return 2)
15:08:23 <jle`> and if you did it again, you'd get something that's twice as long
15:08:32 <jle`> s/i+/1+
15:08:34 <ertes> Hi-Angel: my fold tutorial explains it in detail
15:09:00 <monochrom> 15-dimensional curves?! I don't think we ever really did that in Calculus, not even Multivariate Vector Manifold Calculus.
15:09:19 <jle`> foldl yourFunction (return 0) (1:2:3:[])
15:09:28 <monochrom> Also, no smiling graphs in the exam.
15:09:33 <jle`> => foldl yourfunction (return 0 >>= print >> return 1) (2:3:[])
15:09:55 <jle`> => foldl yourfunction ((return 0 >>= print >> return 1) >>= print >> (return 0 >>= print >> return 3)) (3:[])
15:10:02 <ertes> monochrom: then it probably wasn't a machine learning course =)
15:10:16 <monochrom> Oh! I see.
15:10:39 <jle`> => foldl yourfunction (((return 0 >>= print >> return 1) >>= print >> (return 0 >>= print >> return 3))) >>= print >> ((return 0 >>= print >> return 1) >>= print >> (return 0 >>= print >> return 6))) []
15:10:42 <Hi-Angel> I think I got it, IO accumulates the action. I just still don't see how to make it not do it, to print intermediate values. monochrom wrote it, but I don't see.
15:11:07 <ertes> Hi-Angel: read the IO tutorial
15:11:09 <jle`> after three values, there are 7 print statements
15:11:19 <jle`> after 4 there will be 15, and after 5 there will be 31
15:12:35 <monochrom> I can tell an analogy with imperative languages (C or Java or ...)
15:13:17 <jle`> Hi-Angel: if you ever have problems understanding the reuslt of a fold, unrolling it by hand often helps, too :)
15:13:29 <jle`> the unrolling here should have made it clear why the number of prints is what it is
15:13:32 <monochrom> If you wrote "rand(6) + rand(6)" and it gave you an odd number, you wouldn't be saying "I don't understand, I only mean to get one random number and double it!"
15:13:57 <ertes> unfortunately unrolling foldl' is not that easy =)
15:14:12 <Hi-Angel> jle`: well, to understand it I'd need to see that IO accumulates the action, and I didn't know it.
15:14:13 <ertes> unrolling foldr on the other hand is literally trivial: just substitute
15:14:30 <jle`> Hi-Angel: i don't think you'd have to know that...how elese would you have unrolled it?
15:14:41 <jle`> it's basically simple function application
15:14:52 <jle`> there's only one way to unroll (\acc i -> acc >>= print >> fmap (+1) acc)
15:14:57 <jle`> when applied to (return 0)
15:15:07 <jle`> all you have to do is apply the functions blindly :)
15:15:53 <rjg_> hello
15:15:56 <jle`> (\acc i -> acc >>= print >> fmap (+1) acc) (return 0)       -- you don't have to know anything about IO to apply this
15:16:05 <jle`> all you do is substitute 'return 0' where acc is
15:16:29 <jle`> (\acc i -> acc >>= print >> fmap (+1) acc) (return 0 >>= print >> return 1) 
15:16:34 <jle`>  ^ you don't have to know anything about IO to apply that
15:16:52 <jle`> imagine that it's (\x y -> x * 10 + y) 100
15:17:00 <jle`> and just do normal function application :)
15:17:29 <jle`> the nice thing about the IO tpye in haskell is that it works like any other data type with regards to function application, purity etc.
15:17:34 <jle`> there's no magic involved when working with IO
15:17:38 <jle`> it's just like any other pure value
15:17:57 <ertes> foldl' (\acc i -> acc >>= print >> fmap (+ i) acc) (return 0) [1,2,3] = foldl' (\acc i -> acc >>= print >> fmap (+ i) acc) ((\acc i -> acc >>= print >> fmap (+ i) acc) (return 0) 1) [2,3] = foldl' (\acc i -> acc >>= print >> fmap (+ i) acc) (return 0 >>= print >> fmap (+ i) (return 0)) [2,3] = foldl' (\acc i -> acc >>= print >> fmap (+ i) acc) (print 0 >> return 1) [2,3]
15:18:06 <Hi-Angel> jle`: well, the thing is: to me it looked like acc >>= print >> fmap (+1) acc is (return (0+(whatever_is_in_acc). I'd need to know that prints are gets accumulated in IO
15:18:20 <ertes> now this (print 0 >> return 1) becomes the new state
15:18:38 <jle`> Hi-Angel: wait, why?
15:18:50 <jle`> you're sort of assuming things about IO there that don't need to be assumed
15:19:05 <jle`> giving it special treatment, when it should just be treated like a normal value
15:19:31 <jle`> (\acc i -> acc >>= print >> fmap (+1) acc) is a pretty clear function on normal haskell values
15:19:45 <rjg_> does anyone know how a alpha beta algorithm could be implemented in haskell? I thought the loop over the child nodes could be tracked with a foldr but how could I update the alpha and beta values?
15:20:13 <ertes> foldl' (\acc i -> acc >>= print >> fmap (+ i) acc) (print 0 >> return 1) [2,3] = foldl' (\acc i -> acc >>= print >> fmap (+ i) acc) ((print 0 >> return 1) >>= print >> fmap (+ 2) (print 0 >> return 1)) [3]
15:20:21 <monochrom> "whatever_is_in_acc" is what goes wrong. acc is not trying to hide away a simple answer and make you go through hoops to get it.
15:20:30 <Koterpillar> rjg_: pass them as parameters
15:20:42 <jle`> yeah, i think you made some assumptions that IO is more magical than it is
15:20:47 <ertes> Hi-Angel: it is at this point that you see how the prints build up
15:20:50 <jle`> an 'IO Int' is just a normal value
15:20:56 <jle`> just like any other haskell value
15:21:10 <ertes> Hi-Angel: note that i have only done substitutions
15:21:11 <jle`> there isn't many magical "extraction of contents" that goes on
15:21:22 <Hi-Angel> Okay, let me read the unroll again :)
15:21:31 <jle`> `(\acc i -> acc >>= print >> fmap (+1) acc) blahblah`
15:21:33 <rjg_> oh yeah thanks
15:21:33 <ertes> Hi-Angel: what you should be reading is the IO tutorial
15:21:34 <monochrom> For all you know, acc could be asking a user for a number. Do you want to ask the user twice? But that's exactly what "unwrapping" acc twice will get you. Asking the user twice. No, the "unwrapping" idea is all wrong.
15:21:40 <jle`> ^ how would you apply that?
15:21:53 <jle`> it's unambiguously `(\acc i -> blahblah >>= print >> fmap (+1) blahblah)`
15:21:59 <ertes> Hi-Angel: you're making assumptions about IO which lead you nowhere
15:23:22 <jle`> Hi-Angel: in general, if you see `(\x -> ... something involving x) foo`, then all you do is just substitute 'foo' everywhere there is x
15:23:34 <jle`> if you did this with your original fold, you'll see why the printing happens the number of times it does
15:23:45 <jle`> > (\x -> x * 2) 100
15:23:47 <lambdabot>  200
15:23:55 <jle`> ^ in there, wherever x occures in (x * 2), you'd substitute in 100
15:24:28 <rjg_> Koterpillar do you know how you can break out of the foldr when alpha>=beta?
15:24:58 <jle`> rjg_: i am not sure that a foldr is the best way to go about alpha-beta
15:25:04 <jle`> last time i did it i just used explicit recursion
15:25:21 <ertes> @let myNull = foldr (\_ _ -> True) False
15:25:22 <lambdabot>  Defined.
15:25:25 <ertes> > myNull [1..]
15:25:28 <lambdabot>  True
15:25:29 <ertes> hmm
15:25:32 <jle`> it's a pretty straightforward algorithm with just explicit recursion.  it writes itself :)
15:25:33 <ertes> myNotNull i guess
15:25:37 <Koterpillar> rjg_: I agree with jle`, but you surely can if you think about how can you implement, for example, any using fold
15:26:05 <jle`> to answer your specific question we'd have to know more about how exactly you're formulating your alphabeta as a foldr
15:26:20 <monochrom> Write explicit recursion first, then see if you recognize where foldr appears in disguise.
15:26:21 <jle`> but "breaking out" of a foldr is more or less just ignoring the second argument in the accumulating function
15:26:48 <jle`> but yeah, alphabeta is as textbook a case as it gets when talking about explicit recursion functions
15:26:51 <monochrom> And I suspect it is not just list's foldr, there is also tree's catamorphism involved somewhere.
15:26:53 <rjg_> Im trying to fold over the next possible moves and accumulating the highest value
15:27:02 <rjg_> but maybe explicit recursion is better
15:27:12 <ertes> rjg_: in general you just ignore the recursive result
15:27:26 <jle`> rjg_: if you want to select the highest value then you can use maximum or maximumBy
15:28:01 <ertes> > @let myTake n0 xs = foldr (\x go n -> if n > 0 then x : go (n - 1) else []) (const []) xs n0
15:28:02 <jle`> oh, i think i see, i misunderstood
15:28:02 <lambdabot>  <hint>:1:1: error: parse error on input ‘@’
15:28:09 <jle`> you weren't talking about implementing alphabeta using foldr
15:28:12 <ertes> what?
15:28:15 <jle`> but about just finding the maximum of the child nodes
15:28:16 <ertes> @let myTake n0 xs = foldr (\x go n -> if n > 0 then x : go (n - 1) else []) (const []) xs n0
15:28:18 <lambdabot>  Defined.
15:28:26 <ertes> > myTake 10 [1..]
15:28:28 <lambdabot>  [1,2,3,4,5,6,7,8,9,10]
15:28:32 <jle`> yeah, finding the maximum of the child nodes you can just use maximum or maximumBy
15:28:38 <ertes> rjg_: like that
15:29:06 <ertes> rjg_: however, you can't really use the foldr from Foldable like that for tree-shaped types
15:29:10 <jle`> if you want to stop after a certain threshold is found, you can look at the implementation of 'find'
15:29:14 <jle`> @src find
15:29:15 <lambdabot> find p = listToMaybe . filter p
15:29:16 <ertes> you need to construct an actual tree fold
15:29:20 <jle`> oh that's not helpful lol
15:29:33 <jle`> sry
15:30:03 <monochrom> foldr (&&) is a simple example of early quitting.
15:30:23 <monochrom> > foldr (&&) undefined (repeat False)
15:30:26 <lambdabot>  False
15:30:41 <monochrom> I gave it an infinite list. It clearly quitted early.
15:31:00 <ertes> > foldr (const . Just) Nothing [1..]  -- here is another one: listToMaybe
15:31:02 <lambdabot>  Just 1
15:31:29 <monochrom> Yeah, the trick is avoiding evaluation of the 2nd operand.
15:32:04 <kadoban> That's fairly clever, I wouldn't think of foldr for listToMaybe.
15:33:12 <monochrom> Wait, quitted? quit?
15:33:30 <ertes> > foldr (\x ~(ys1, ys2) -> (x:ys2, ys1)) mempty "abcdefg"
15:33:32 <lambdabot>  ("aceg","bdf")
15:33:34 <monochrom> I cutted a big slice of cake for myself...
15:33:59 <boxscape> monochrom: either one
15:34:31 <ertes> kadoban: the reason is probably that you would just use foldr (or even traverse/traverse_) instead of first converting to a Maybe =)
15:34:32 <kadoban> I think both are correct, but "quit" seems way more common currently.
15:35:04 <ertes> :t foldr (\x _ -> print x) (putStrLn "No first element")
15:35:06 <lambdabot> (Show a, Foldable t) => t a -> IO ()
15:35:15 <ExpHP> the regex package has apparently been updated not once, not twice, but three times since I wrote my unit tests yesterday
15:35:19 <kadoban> ertes: Heh, sounds right
15:35:50 <kadoban> That pattern strikes me as novel for myself though, not a pattern I've used before. I'll have to keep it in mind.
15:35:57 <rjg_> but when I use explicit recursion in my negamax I get nested lists
15:41:31 <jle`> if you're having issues still, you can paste your code :)
15:42:51 <ertes> rjg_: you might be interested in my fold tutorial, too: http://ertes.eu/tutorial/foldr.html
15:44:12 <Hi-Angel> jle`: okay, to begin with: foldl' is a strict version, it doesn't build thunks. Anyway, even lazy foldl upon building up thunks doesn't execute anything, including prints. It does it upon consuming, and every thunk consumed once, so every print also should happen once.
15:45:29 <jle`> >> and >>= are pure for IO
15:45:33 <Hi-Angel> If I correctly understood, you're assuming prints are executed upon building thunks, and then once more upon consuming
15:45:35 <jle`> they shouldn't execute anything in either case
15:45:47 <jle`> i'm not assuming prints are executed upon building thunks
15:46:02 <jle`> did you try unfolding the foldl?
15:46:04 <ertes> Hi-Angel: you keep insisting that IO is side-effecting
15:46:16 <ertes> *no* fold will *ever* execute *anything*
15:46:17 <Hi-Angel> I've read your unfold
15:46:22 <jle`> >>= and >> *never* cause side-effects during evaluation
15:46:29 <adarqui> trying to build haskell platform (for 8.0.2) from source, lots of stuff like this: src/OS/Win/WinNsis.hs:90:28: Not in scope: `<$>' .. anyone compile it from source here who maybe has some tips?
15:46:29 <jle`> foldl or foldl'
15:46:43 <jle`> Hi-Angel: do you agree that the unfold i put was correct?
15:46:48 <jle`> if so, you should see that there are 7 print statements
15:46:52 <jle`> in the final IO action
15:47:13 <Hi-Angel> Okay, let me try it myself…
15:47:24 <jle`> 'print' doesn't print anything during evaluation
15:47:54 <jle`> so whether or not you force 'print 1' or not, or if it's built up as a thunk or it, it doesn't evaluate anything
15:47:58 <monochrom> If you do "seq (print 5) ()" you will not see 5 printed.
15:48:17 <adarqui> how do people here install the latest haskell platform on say, ubuntu linux?
15:48:22 <jle`> IO isn't something that fires of effects when it is evaluated
15:48:25 <glguy> monochrom: Maybe 5 is special?
15:48:26 <ertes> Hi-Angel: haskell does not have side effects, not even IO
15:48:44 <jle`> but yes, unfold even the [1,2] case, and you'll see
15:48:57 <monochrom> Yeah! It's my answer to the purpose of Haskell!
15:49:00 <jle`> the [1,2] case when unrolled should resutn in an IO action that has three print statements
15:49:11 <jle`> there is only one way to unroll it...
15:49:15 <jle`> it's impossible to mess up :)
15:49:17 <adarqui> i don't get why the haskell platform site just says, apt-get install haskell-platform .. that's going to give you an OLD version
15:49:37 <ertes> adarqui: i'd install GHC and cabal-install directly
15:49:38 <adarqui> didn't see the "Generic link"
15:49:39 <jle`> the only rule: if you see `(\x -> ... x ...) foo`, then simply replace every occurence of 'x' in the body with 'foo'
15:49:40 <adarqui> maybe that'll help
15:49:53 <monochrom> adarqui: You're right. I ignore that suggestion and go ahead to choose the generic-linux binary.
15:49:58 <adarqui> ertes, ya ive done that b4 but just want the platform
15:50:00 <ertes> adarqui: ("directly" as in directly installing the packages, not the platform package)
15:50:08 <adarqui> monochrom: ya. didn't see the generic section
15:50:15 <adarqui> going to try that.. i imagine that'll be what i need
15:50:29 <jle`> Hi-Angel: don't worry about the fact that 'foo' might have a type 'IO Int'.  it's just normal haskell evaluation.  do it according to the rule i just posted, and you'll see :)
15:51:02 <jle`> if you see `(\x -> ... x ...) foo`, then just replace every occurence of x in the body with 'foo', etc.
15:51:10 <ertes> adarqui: debian-based distributions are known to distribute ridiculously old versions, but on other distributions (arch, gentoo, NixOS) you won't have that problem…  in that case i suggest using the package manger
15:51:11 <ertes> manager
15:51:26 <adarqui> ya
15:51:30 <adarqui> thanks ertes
15:51:54 <adarqui> installing generic now
15:52:17 <jle`> Hi-Angel: once you have unrolled foldl (\acc i -> ...) (return 0) (1:2:[]), then you'll see that the resulting IO action has three print statements.  if it doesn't, come back and let us know what you got
15:52:40 <boxscape> So, I understand why "foldl' (&&) undefined (repeat False)" complains about the undefined. But shouldn't "foldl' (flip (&&)) undefined (repeat False)" unfold to "let a' = False && undefined in a' `seq` foldl' (flip (&&)) a' (repeat False)", where a' evaluates to False, and presumably leading to an infinite loop? Instead it also complains about undefined
15:53:00 <ertes> boxscape: no
15:53:25 <codedmart> What is `'`? I see this `type QuoteDocType = '['CutFile, 'Design]; type BidDocType = '['Bid];` and can I concat QuoteDocType and BidDocType?
15:53:34 <ertes> boxscape: foldl' will always have to traverse the whole list
15:53:39 <ertes> it's defined that way
15:53:44 <jle`> codedmart: it's optional, but '[a,b,c] is a type-level list of types a, b, and c
15:53:49 <jle`> :k '[Int, Bool String]
15:53:50 <boxscape> ertes: but that's what I'm suggesting
15:53:51 <lambdabot> error:
15:53:51 <lambdabot>     • Expecting one fewer argument to ‘Bool’
15:53:51 <lambdabot>       Expected kind ‘* -> *’, but ‘Bool’ has kind ‘*’
15:53:54 <hololeap> codedmart: it's just a alphanum character
15:54:00 <jle`> :k '[Int, Bool, String]
15:54:02 <lambdabot> [*]
15:54:07 <ertes> boxscape: oh, i misread
15:54:07 <boxscape> > foldl' (flip (&&)) undefined (repeat False)
15:54:09 <lambdabot>  *Exception: Prelude.undefined
15:54:13 <jle`> ^ that's a type-level list of things of kind *
15:54:40 <jle`> codedmart: you can concat them if you have a concat/(++) type family defined somewhere
15:55:05 <ertes> foldl' (flip (&&)) undefined (False : xs) = let !x = undefined && False in foldl' (flip (&&)) x xs
15:55:08 <glguy> boxscape: foldl' f z xs is strict in z
15:55:11 <ertes> > undefined && False
15:55:13 <lambdabot>  *Exception: Prelude.undefined
15:55:16 <ertes> boxscape: ^
15:55:20 <boxscape> glguy: ah, I see
15:55:24 <jle`> codedmart: when you write `data Bool = True | False`, it defines a type 'Bool' of kind '*' with two value constructors, True and False
15:55:34 <glguy> > foldl (\_ x -> x) undefined [1,2]
15:55:36 <glguy> > foldl' (\_ x -> x) undefined [1,2]
15:55:36 <lambdabot>  2
15:55:36 <codedmart> jle`hololeap OK thanks?
15:55:38 <lambdabot>  *Exception: Prelude.undefined
15:55:42 <jle`> codedmart: but, you also define a *kind* Bool, with two *type* constructors, 'True and 'False
15:55:58 <codedmart> OK great
15:56:06 <jle`> :k '[ 'True, 'False, 'True ]
15:56:08 <lambdabot> [Bool]
15:56:11 <ertes> > foldl' (\_ x -> x) undefined [1]
15:56:11 <jle`> that's a type-level list of things of kind Bool
15:56:13 <lambdabot>  *Exception: Prelude.undefined
15:56:26 <boxscape> ertes: that alone wouldn't explain it, because (flip (&&)) should get rid of that, but foldl' being strict in the initial value does explain it
15:56:27 <ertes> oh, then my definition is off-by-one
15:56:46 <ertes> boxscape: it does, because (undefined && False) is still undefined
15:56:52 <ertes> oh, no
15:57:01 <ertes> it should be (False && undefined)
15:57:03 <boxscape> > (flip (&&)) undefined False
15:57:05 <lambdabot>  False
15:57:21 <ertes> yeah, sorry
15:57:48 <boxscape> @src foldl'
15:57:48 <lambdabot> foldl' f a []     = a
15:57:48 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
15:57:52 <ertes> i'm a bit surprised that (foldl' f z) is strict in z
15:57:53 <codedmart> jle`: Thanks for the explanation.
15:58:01 <boxscape> this is slightly different from the actual code in ghc then, right?
15:58:05 <jle`> no problem!
15:58:06 <ertes> in fact that one isn't
15:58:13 <jle`> codedmart: the keyword to search for for more details is DataKinds
15:59:02 <ertes> @let myFoldl' f z xs = foldr (\x go s' -> let !s = f s' x in go s) id xs z
15:59:03 <lambdabot>  Defined.
15:59:06 <glguy> ertes, boxscape: In the past foldl' wasn't strict in the initial "accumulator"
15:59:09 <ertes> that's how i would define foldl'
15:59:15 <boxscape> ah
15:59:34 <ertes> > myFoldl' (flip (&&)) undefined [False]
15:59:36 <lambdabot>  False
16:00:28 <boxscape> foldl' f z0 xs = foldr f' id xs z0;  where f' x k z = k $! f z x
16:00:30 <boxscape> is ghc
16:00:45 <glguy> ertes, boxscape: https://mail.haskell.org/pipermail/libraries/2014-November/024065.html
16:01:10 <ertes> boxscape: hmm? that doesn't sound right, if it throws
16:01:22 <boxscape> well, that's the one from Foldable at least
16:01:30 <boxscape> http://hackage.haskell.org/package/base-4.9.1.0/docs/src/Data.Foldable.html#foldl%27
16:02:11 <ertes> hmm, strictness analysis is a good point
16:04:20 <boxscape> > GHC.List.foldl' (flip (&&)) undefined (repeat False)
16:04:22 <lambdabot>  error:
16:04:22 <lambdabot>      Not in scope: ‘GHC.List.foldl'’
16:04:22 <lambdabot>      Perhaps you meant ‘Data.List.foldl'’ (imported from Data.List)
16:04:27 <boxscape> uh
16:04:36 <boxscape> :t GHC.List.foldl'
16:04:38 <lambdabot> (b -> a -> b) -> b -> [a] -> b
16:04:39 <boxscape> ok then
16:05:17 <boxscape> apparently :t uses a different namespace from >
16:05:26 <glguy> :t System.IO.Unsafe.unsafePerformIO
16:05:26 <jle`> @let import qualified GHC.List
16:05:28 <lambdabot>  Defined.
16:05:28 <lambdabot> IO a -> a
16:05:37 <boxscape> > GHC.List.foldl' (flip (&&)) undefined (repeat False)
16:05:40 <lambdabot>  *Exception: Prelude.undefined
16:05:46 <boxscape> neat, didn't know you could import like that
16:05:50 <kadoban>  :t and > are really different namespaces? That sounds like something I would have noticed at some point
16:06:08 <jle`> kadoban: for the reason glguy just showed
16:06:20 <kadoban> Oh, huh.
16:06:26 <jle`> being able to ask for the type of unsafe things is fine but you probably don't want to allow them to be executed
16:06:30 <jle`> er, evaluated
16:06:33 <kadoban> I guess that makes sense ...
16:08:24 <boxscape> @let import qualified System.IO.Unsafe
16:08:27 <lambdabot>  .L.hs:139:1: error:
16:08:27 <lambdabot>      System.IO.Unsafe: Can't be safely imported!
16:08:27 <lambdabot>      The module itself isn't safe.
16:08:29 <boxscape> :(
16:09:33 <boxscape> you don't usually see lambdabot errors with file locations, do you?
16:11:35 <Hi-Angel> jle`: okay, here's my version http://lpaste.net/353992 You told me to not make special assumptions about IO, so I end up with this, and, well, there's no multiple print statements :/
16:14:06 <jle`> Hi-Angel: how come your accumulator magically turned into ()?
16:14:15 <glguy> Hi-Angel: They're missing because you forgot to write them in the accumulator
16:14:54 <jle`> Hi-Angel: the result of (\acc i -> acc >>= print >> fmap (+1) acc) (return 0) 1 isn't ()
16:14:58 <jle`> that ... isn't even the right type, heh
16:15:17 <Hi-Angel> jle`: you mean the "return 0"? Well, I just didn't know what to write in there, because accumulator moved into the argument, so I left a space
16:15:26 <jle`> i meant on line 6
16:15:35 <Hi-Angel> Yes
16:15:58 <jle`> okay, let's try to figure out what the accumulator is
16:16:10 <jle`> (\acc i -> acc >>= print >> fmap (+1) acc) (return 0) 1
16:16:14 <jle`> what is the result of that?
16:16:21 <jle`> remember, substitution
16:16:44 <jle`> if you see (\x y -> .. x ..) foo bar, it means to substitute 'foo' wherever you see x
16:17:03 <Hi-Angel> Here it is 0
16:17:12 <jle`> hm, how did you get zero
16:17:25 <jle`> because...it's not zero
16:17:32 <Hi-Angel> Well, if you mean after the function executed
16:17:35 <Hi-Angel> Then it's 1
16:17:37 <jle`> no, i mean the result
16:17:40 <jle`> the result of the function evaluation
16:17:40 <Hi-Angel> 1
16:17:50 <jle`> not quite
16:17:52 <jle`> let's do it step by step
16:18:03 <jle`> (\acc i -> acc >>= print >> fmap (+1) acc) (return 0) 1
16:18:13 <jle`> (\i -> (return 0) >>= print >> fmap (+i) (return 0)) 1
16:18:25 <jle`> `(return 0) >>= print >> fmap (+1) (return 0)`
16:18:29 <jle`> that's the resulting IO action
16:18:42 <jle`> it's `return 0 >>= print >> fmap (+1) (return 0)`
16:18:47 <jle`> that's your new accumulator
16:18:51 <jle`> its type is `IO Int`
16:19:43 <jle`> you can actually simplify this a bit using the monad laws
16:19:45 <Hi-Angel> I think I see. Let me think a bit.
16:19:48 <jle`> but it's not necessary
16:20:06 <jle`> you can leave it in its full form and then simplify it using monad laws at the end
16:20:42 <jle`> did you see how i got this?
16:20:49 <Hi-Angel> Yes
16:20:51 <jle`> all i did was subsitute 'acc' with (return 0)
16:20:56 <jle`> becaus ethat's how function application works in Haskell
16:21:01 <jle`> and i substituted 'i' with 1
16:21:15 <jle`> the result isn't 0, or 1, or  ()
16:21:35 <jle`> the result is an IO action -- an action that is equivalent to `return 0 >>= print >> fmap (+1) (return 0)`
16:21:44 <jle`> and whose type is IO Int
16:22:04 <jle`> if you didn't know this was IO, and you thought it was just normal values (like ints or bools or strings), this is what you would have done
16:22:33 <jle`> this is the same thing that happens when you do (\acc i -> acc * foo + bar i)
16:22:35 <jle`> etc.
16:23:09 <Hi-Angel> Yeah, no I see, upon taking the next value from the list, I'd end up with the function being executed twice.
16:23:12 <Hi-Angel> *now
16:23:35 <jle`> yup, it's because IO is just a normal data structure.  it's closely related to a tree, actually
16:23:44 <jle`> semantically
16:24:07 <Hi-Angel> I think I see, it's just so unusual. I'm trying to figure out, in what way could I end up like that in another language upon doing foldl
16:24:28 <jle`> actually i think this is the more non-unusual way
16:24:36 <jle`> here, an IO action is just treated like a normal pure value
16:24:47 <jle`> if it were anything different, haskell would be inconsistent in how function application works
16:25:11 <jle`> it's just that we have been accustomed to thinking about IO as magical from other languages
16:25:24 <jle`> so seeing an IO action treated as a normal value is a bit jarring
16:25:39 <Sonolin> jle` how is IO "closely related to a tree"? From my understanding it more closely relates to the State monad, or maybe a list
16:26:12 <jle`> well, you can imagine `>>` as joining two trees
16:26:15 <boxscape> to be fair, IO is still a little bit special because you leave >>= and >> unevaluated, whereas regular functions, like foldr, you can replace by their definition
16:26:33 <jle`> boxscape: not necessarily, if your data type is abstract
16:26:42 <jle`> like IO is
16:26:47 <boxscape> yeah, that makes sense
16:27:23 <jle`> (abstract data types aren't special in haskell; Map, Set, etc. are other common ones)
16:27:33 <jle`> and what you probably mean is that we leave >>=/>> unsimplified
16:27:39 <jle`> but there is simplifcation you can do, from the API
16:28:03 <boxscape> I suppose that is what I mean
16:28:06 <jle`> for example, we could have simplified `return 0 >>= print >> fmap (+1) (return 0)` into an equivalent IO action, based on how the API behaves
16:28:16 <jle`> it's equivalent to `print 0 >> return 1`
16:28:33 <jle`> this would be the same as, say, applying 'fmap' to M.fromList [('a', 1), ('b', 2)]
16:28:58 <jle`> fmap negate (M.fromList [('a', 1), ('b', 2)]) is equivalent to M.fromList [('a', -1), ('b', -2)]
16:29:14 <jle`> but we just know this because we trust the API of Data.Map
16:29:16 <boxscape> ok, I see
16:29:24 <jle`> the actual data type is abstract, who knows what is going on under the hood?
16:29:53 <boxscape> or we could just replace it by this? bindIO (IO m) k = IO (\ s -> case m s of (# new_s, a #) -> unIO (k a) new_s) :P
16:29:56 <jle`> M.fromList [('a', -1), ('b', -2)] might have a completely different internal representation as fmap negate (M.fromList [('a', 1), ('b', 2)])
16:30:07 <boxscape> (the bindIO source)
16:30:16 <jle`> but we treat them as the same because they are abstract data types that respect properties and laws
16:30:42 <jle`> `return 1 >>= print` might be different internally from `print 1`, but we treat them as the same thing because that's how abstract data types work
16:31:38 <jle`> boxscape: i'm not sure if we can actually do that in every case, heh.  we open ourseives to breaking the abstraction when we peak into the implementations of abstract data types
16:31:49 <jle`> s/peak/peek
16:32:02 <boxscape> I can see why that might be the case, yeah
16:33:15 <Hi-Angel> Okay, thanks everyone, I gotta go sleep, I have just 3.5 hours left to.
16:33:32 <jle`> have a nice night!
16:33:58 <Hi-Angel> Good night!
16:34:04 <jle`> ty
16:34:35 <boxscape> actually kind of weird to me that bindIO uses case instead of let for pattern matching on a single possible case
16:35:06 <glguy> The difference is let vs case isn't how any alternatives you get, but to do with strictness
16:35:11 <boxscape> ah, ok
16:36:41 <glguy> which is why it's common to see tuples being used with case:   case xy of (x,y) -> ....
16:37:02 <glguy> even though there's only one possibility
16:38:29 <monochrom> "case undefined of (_, _) -> 5" is going to bottom out. This shows the difference from let. You can use "case undefined of ~(_, _)" to regain the meaning of let.
16:39:03 <boxscape> what's the ~ here?
16:39:19 <boxscape> non-strictness?
16:39:20 <monochrom> And BangPatterns is the greatest invention ever because it completes the symmetry. You can use "let !(_,_) = undefined" to regain the meaning of case. :)
16:39:51 <glguy> boxscape: ~ creates an irrefutable pattern
16:39:54 <monochrom> It is both non-strictness and "assume this will match, look no further"
16:39:58 <boxscape> ok
16:40:39 <monochrom> > case [1,2] of ~[] -> 5; _ -> 6
16:40:41 <lambdabot>  5
16:41:03 <boxscape> ok, so it doesn't even complain if it doesn't work
16:41:11 <boxscape> > let [] = [1,2] in 5
16:41:13 <glguy> boxscape: You might want to search for irrefutable and ~ on this page to learn more https://www.haskell.org/onlinereport/haskell2010/haskellch3.html#x8-580003.17
16:41:13 <lambdabot>  5
16:41:17 <boxscape> thanks
16:41:39 <monochrom> It will complain when I have enough evaluation to expose the lie. But that will be during run time. Not statically checked.
16:41:52 <boxscape> right, that makes sense
16:42:21 <jle`> > case [] of ~[x,y] -> 5
16:42:23 <lambdabot>  5
16:42:25 <jle`> > case [] of ~[x,y] -> x
16:42:28 <lambdabot>  *Exception: <interactive>:(3,1)-(4,22): Irrefutable pattern failed for patte...
16:42:38 <boxscape> it actually doesn't even surprise me that it doesn't complain in let, just not used to seeing it in case :)
16:43:28 <glguy> > case [1,2] of ~[x,3] -> x
16:43:30 <lambdabot>  *Exception: <interactive>:(3,1)-(4,22): Irrefutable pattern failed for patte...
16:43:59 <glguy> Note that once you force evaluation of a name bound by the pattern, the whole pattern has to match
16:44:39 <glguy> > case [1,2] of ~[x,~3] -> x
16:44:41 <lambdabot>  1
16:44:56 <boxscape> > case (1,[]) of ~(a,[2]) -> a
16:44:58 <lambdabot>  *Exception: <interactive>:(3,1)-(4,22): Irrefutable pattern failed for patte...
16:45:02 <boxscape> ok
16:45:12 <monochrom> Yeah, that one is a finer detail on how much to evaluate is enough to trigger real checking.
16:46:03 <monochrom> My http://lpaste.net/100588 shows an extreme example where many intuitions think it shouldn't bottom.
16:46:04 <defanor> i'm looking for a library that would help with writing a very basic http service: it should only process a single request (authentication), with no html composition or anything like that -- so i won't need web framework features, and even snap would be an overkill. could even use it with nginx, and then something for CGI would suffice. what are the minimal (with minimal dependencies) and maintained ones?
16:46:25 <Welkin> defanor: servant
16:46:32 <defanor> Welkin: will check it, thanks
16:46:36 <Sonolin> yea servant is beautiful for API stuff 
16:46:41 <Welkin> it is a library for writint web apis
16:46:48 <Welkin> if you want something low-level, use wai
16:48:15 <boxscape> monochrom: yeah, that's interesting
16:48:38 <jle`> scotty isn't too bad either; it's close in spirit to sinatra or flask if you've ever done web dev in ruby or python
16:48:58 <jle`> but checkout servant if you want to feel the true power of the haskell type system
16:49:32 <jle`> (and this isn't even its final form)
16:49:36 <boxscape> i would've expected it to just go to WHNF wherever it can when it has to check a pattern
16:49:52 <boxscape> and not check past that
16:52:08 <Hi-Angel> That said, I still clueless: how would I print intermediate value in foldl, so that print wasn't executed twice for successive elements in the list?
16:52:26 <ChaiTRex> Hi-Angel: Try scanl
16:52:39 <ChaiTRex> Hi-Angel: It'll give you a list of intermediate results.
16:52:43 <glguy> boxscape: expressions are checked as much as needed, maybe WHNF, maybe more, maybe less
16:52:59 <glguy> (_ : _ : _) will go beyond WHNF, _ will do less
16:53:12 <Hi-Angel> But they'd take memory, whilst I just need to print them
16:53:48 <Cale> Of course, at some point, case expressions are compiled down to case expressions in core, which always match on exactly one constructor at a time.
16:53:53 <jle`> scanl is a good consumer
16:53:58 <jle`> er, producer
16:54:07 <jle`> it won't allocate the intermediate list if you print things as they come i think
16:54:14 <boxscape> glguy: well, in case (1,[[],[]]) of ~(a,[[],[1]]) -> a, it wouldn't *need* to know the contents of the list, would it? and WHNF of the list would be [] : rest, in either case, I think?
16:54:46 <boxscape> you mentioned that it will go beyond WHNF in (_:_:_), but why?
16:55:13 <glguy> boxscape: WHNF of a list only determines if the list is built from a [] or a (:)
16:55:39 <boxscape> Oh, I think I misunderstood you earlier, ok
16:55:52 <Hi-Angel> Okay, thank you.
16:55:57 <boxscape> you're saying it will check the whole pattern, and if WHNF is enough to check the whole pattern, it won't go beyond that?
16:56:12 <boxscape> my point was that it doesn't actually *need* to check the whole pattern to get a
16:56:13 <glguy> [[],[1]] is already in NF, , [] : rest isn't the "WHNF" of that expression
16:56:21 <boxscape> ah, ok
16:56:33 <boxscape> that makes sense
17:07:25 <boxscape> (I still don't understand why it has to check the whole pattern though, just t oget a)
17:08:17 <glguy> It matches the whole pattern because that's how pattern matching is designed to work
17:08:40 <boxscape> I suppose that makes sense
17:08:44 <boxscape> But it could be different?
17:09:24 <glguy> You could make a system where: case [1,2] of [x] -> x == 1   I suppose
17:09:35 <glguy> but that seems less useful than being able to force evaluation
17:09:37 <monochrom> Yes, one could design a language that does a different thing.
17:09:43 <boxscape> ok
17:10:01 <boxscape> I can see why that's more useful, yeah
17:10:12 <boxscape> i.e. why the haskell system is more useful
17:10:46 <monochrom> But Haskell chose this design point, it is a good balance over ease to explain, ease to implement, ease of use.
17:11:07 <boxscape> okay
17:11:14 <boxscape> thanks guys
17:13:08 <boxscape> The problem was that I was just thinking about irrefutable patterns; when I think about patterns in general, it makes a lot of sense that you would want `f [a:_:rest] = a` to only match when the list really does have 2 elements
17:13:40 <boxscape> (at least)
17:15:30 <jle`> boxscape: i think maybe you can see it as ~ is not recursive; it just overrides default behavior for the top level pattern
17:15:39 <jle`> boxscape: you're thinking of ~(a,~[])
17:15:44 <jle`> but by default it's ~(a,[])
17:15:48 <boxscape> yeah, that's a good point
17:15:55 <jle`> if you want the inner layers to also be ~, you have to explicitly use ~
17:16:02 <boxscape> ok, but you can do that?
17:16:13 <boxscape> > case (1,~[[],[]]) of ~(a,[[],[1]]) -> a
17:16:15 <lambdabot>  error:
17:16:15 <lambdabot>      Pattern syntax in expression context: ~[[], []]
17:16:16 <jle`> ~(a,~(b,~(c,~[])))
17:16:21 <boxscape> oops
17:16:28 <boxscape> > case (1,[[],[]]) of ~(a,~[[],[1]]) -> a
17:16:30 <lambdabot>  1
17:16:32 <boxscape> ok, thanks
17:16:34 <jle`> same for bang patterns, too, for let statements
17:16:44 <jle`> !(x,y) only forces the evaluation of the top (,)
17:16:57 <jle`> !(x,y) isn't the same as !(!x,!y)
17:17:02 <boxscape> ok
17:17:03 <jle`> so ~(x,y) isn't the same as ~(~x,~y)
17:19:35 <nshepperd_> How is ~[] different from _? Surely that value will never be "needed"?
17:21:54 <c_wraith> it's not even named, so it can't be 
17:22:58 <c_wraith> jle`, I'm pretty sure ~(x, y) is the same as ~(~x, ~y) 
17:23:26 <jle`> > case (1,[1,2,3]) of ~(x, []) -> x
17:23:28 <lambdabot>  *Exception: <interactive>:(3,1)-(4,22): Irrefutable pattern failed for patte...
17:23:32 <c_wraith> jle`, i don't think irrefutable matches do anything unless applied to a constructor pattern.
17:23:34 <jle`> > case (1,[1,2,3]) of ~(x, ~[]) -> x
17:23:36 <lambdabot>  1
17:23:55 <c_wraith> yes, you're using a constructor pattern in that case. 
17:24:01 <jle`> ah yeah, sorry, it was my abuse of notation
17:24:16 <jle`> i should have meant ~(Pat,Pat) vs. ~(~Pat, ~Pat)
17:24:23 <jle`> s/meant/wrote
17:24:42 <c_wraith> those are different. :) 
17:41:26 <leshow> hello, im having some trouble with do notation i was hoping someone could give me a few pointers. 
17:42:13 <leshow> basically i want to return a string if any character doesnt match, and a map if everything is successful. adding each character to the map and incrementing its value
17:42:19 <leshow> http://lpaste.net/353994
17:43:07 <jle`> leshow: 'x <- xs'
17:43:16 <jle`> you can only do that if xs :: Either String something
17:44:09 <jle`> it looks like do notation doesn't really add that much here
17:44:33 <leshow> i thought you could take each element out of a list like that, ive written an fmap type of thing with do notation before
17:44:42 <jle`> ah yeah, that behavior depends on the monad you're using
17:44:47 <jle`> in this case, 'Either' doesn't have that behavior
17:44:53 <jle`> bind for Either binds the 'Right' result, if there is one
17:45:22 <boxscape> (and the <- notation uses bind)
17:45:41 <jle`> leshow: what behavior do you want?  to fail if there are any failures?
17:45:46 <jle`> you can use forM or mapM for that
17:45:57 <jle`> mapM :: [a] -> (a -> Either e b) -> Either e [b]
17:45:59 <leshow> mapM... like traverse?
17:46:41 <jle`> yupp
17:46:54 <jle`> it might be easier to write using forM/for
17:47:05 <jle`> forM xs $ \x -> do
17:47:14 <jle`>   x' <- isValid x
17:47:17 <leshow> ok. so just to clarify
17:47:26 <lyxia> you still have to accumulate a map
17:47:32 <jle`> oh yes i see
17:47:36 <lyxia> just write a recursive function
17:47:51 <leshow> because im not in the list monad, we're returning Either, I cant do stuff like do { x <- xs; return (f x); }
17:47:52 <lyxia> or you can do it in two steps if you don't care about streaming
17:48:02 <jle`> you can use foldM
17:48:17 <jle`> leshow: you can if xs :: Either String something
17:48:22 <jle`> but not if it's [something]
17:48:35 <jle`> every line on a do block has to be of the same monad
17:48:56 <leshow> ok
17:48:58 <ski> @unmtl StateT (Map Char Int) (Either MyError) ()
17:48:59 <lambdabot> Map Char Int -> Either MyError ((), Map Char Int)
17:50:59 <jle`> :t foldM
17:51:01 <lambdabot> (Monad m, Foldable t) => (b -> a -> m b) -> b -> t a -> m b
17:51:52 <jle`> foldM :: (Map Char Int -> Char -> Either String (Map Char Int)) -> Map Char Int -> [Char] -> Either String (Map Char Int) 
17:55:45 <leshow> ok im trying with traverse/forM 
17:57:30 <jle`> leshow: forM won't quite work with either alone, sorry
17:57:38 <jle`> if you want to take advantage of Either, you can use foldM
17:57:39 <leshow> http://lpaste.net/353994
17:57:50 <leshow> yeah it doesnt the return type ends up being
17:58:01 <leshow> Either String [Map Char Integer]
17:58:02 <jle`> foldM is like foldl, but instead of taking an (b -> a -> b), it takes a (b -> a -> Either String b)
17:58:15 <jle`> for foldr the result can be wahtever your accumulator is
17:58:29 <jle`> if your accumulator is 'Map Char Int', the result will be Either String (Map Char Int)
17:59:27 <jle`> (also for what it's worth i wouldn't use Strings to represent nucleotides)
17:59:53 <leshow> it's not my choice its part of the question
17:59:59 <jle`> ah, how fun :)
18:00:00 <leshow> im not doing anything serious with nucleotides haha
18:00:33 <leshow> out of curiousity what data structure would you choose
18:01:36 <jle`> data Nucleotide = A | C | T | G, or something like that :)
18:02:43 <leshow> Oh I thought you meant something fancy for storing a sequence, hey also one thing 
18:03:00 <leshow> I was really hoping there was a way to do a multiple case on the left hand side
18:03:10 <leshow> 'A' | 'T' | ..
18:03:14 <leshow> of a case expression
18:03:16 <jle`> there isn't quite one
18:03:18 <leshow> is that not possible
18:03:21 <jle`> but you can use a function instead
18:03:32 <jle`> :t (`elem` "ACTG")
18:03:34 <lambdabot> Char -> Bool
18:03:40 <jle`> > 'A' `elem` "ACTG"
18:03:42 <lambdabot>  True
18:03:45 <leshow> right yeah, but there's a cost with that
18:03:50 <jle`> what is the cost?
18:03:56 <leshow> it has to search the list
18:03:58 <jle`> > 'B' `elem` "ACTG"
18:04:00 <lambdabot>  False
18:04:05 <jle`> leshow: do you think the case statement doesn't have to search the cases? :p
18:04:26 <jle`> pattern matching on case statements go from top to bottom
18:04:27 <leshow> i don't know how GHC puts it together
18:04:33 <jle`> so first it checks 'A'
18:04:37 <jle`> then it checks 'T'
18:04:43 <jle`> then 'G', then 'C'
18:04:48 <jle`> well, it's the semantics of pattern matching
18:04:50 <leshow> but if I was writing it in like Rust, I'd assume it'd be faster to match on arms of a case than search a list
18:06:22 <boxscape> was using guards in case statements, like `case 4 of a | even a -> ()` always possible?
18:06:34 <jle`> i believe so
18:06:37 <boxscape> ok
18:06:40 <ezyang> I believe that it was allowed in Haskell98 
18:06:50 <jle`> oh, apparently not, then
18:07:05 <boxscape> does that mean, first allowed, or at least since then allowed?
18:07:07 <leshow> in any case, i got it to work with foldM
18:07:29 <ezyang> at least 
18:07:32 <boxscape> ok
18:07:43 <leshow> http://lpaste.net/edit/353994
18:07:49 <jle`> if you want to be fancy and you're comfortable with monad transformers, you can use StateT (Map Char Int) (ExceptT String [])
18:08:17 <leshow> I've only just started with monad trans so I think ill put that off for now lol
18:08:19 <jle`> in which case it's just a single do block without loops
18:08:43 <leshow> if you want to show me what it looks like im open to that, I just dont think I can write it myself
18:09:03 <jle`> well you caught me in a nerd-snipable mood, so
18:09:10 <leshow> :D
18:12:10 <boxscape> > let a | even a = 4 in a -- this is a bit weird. I would expect this to work like the case statement above, but I'm probably misunderstanding the syntax here
18:12:16 <lambdabot>  mueval-core: Time limit exceeded
18:12:36 <boxscape> > case 4 of a | even a -> a
18:12:38 <lambdabot>  4
18:13:03 <lpaste_> jle` annotated “nucleotide.hs” with “nucleotide.hs (annotation)” at http://lpaste.net/353994#a353998
18:13:20 <jle`> but actually you can use 'guard' in your original version, too
18:13:28 <Koterpillar> > let (a | even a = 4) in a
18:13:30 <lambdabot>  <hint>:1:8: error: parse error on input ‘|’
18:13:51 <leshow> how did you get lpaste_ to post that message to the chat?
18:13:53 <boxscape> that's what I thought my snippet would mean
18:14:00 <jle`> you just have to put the channel name in the channel box
18:14:01 <Koterpillar> leshow: select "channel"
18:14:40 <leshow> jle`, this is cool
18:14:46 <sanett> Hey folks, is \p.\a.\b.p b a \x.\y.x equal to \a.\b.(\x.\y.x) b a?
18:15:12 <jle`> oh sorry i shouldn't use guard if you want a specific error message
18:15:21 <boxscape> > let a | even 3 = 3 in a -- works like I would expect, same with even 4
18:15:21 <jle`> leshow: using guard there would give you left "" in the case of an error
18:15:23 <lambdabot>  *Exception: <interactive>:3:5-18: Non-exhaustive patterns in function a
18:15:50 <boxscape> and yet `let (a | even 3) = 3` produces a parse error
18:15:59 <boxscape> but I guess that makes sense actually
18:16:13 <lpaste_> jle` revised “nucleotide.hs (annotation)”: “nucleotide.hs (annotation)” at http://lpaste.net/353998
18:16:53 <boxscape> but `let a | even a = 3` in a producing an infinite loop doesn't make sense to me
18:17:16 <leshow> so throwE doesnt throw an exception, it returns a Left?
18:17:41 <leshow> and ExceptT is the monad trans for Either?
18:18:43 <Koterpillar> boxscape: you are using the return value (a) in the guard, what did you expect?
18:19:16 <Koterpillar> boxscape: it's equivalent to: let a = if even a then 3 else error "partial" in a
18:19:33 <boxscape> Koterpillar: but am I not doing the same thing that I'm doing in `case 4 of a | even a -> a`?
18:20:17 <Koterpillar> boxscape: no, because here you are doing: (\a -> if even a then a else error "partial") 4
18:20:39 <Koterpillar> `a` on the left side of the guard gets matched with 4 right away
18:20:43 <rotaerk> leshow, Either is really similar to exceptions though; returning left is like throwing because in a sequence of Eithers, returning left short circuits the whole thing
18:20:46 <boxscape> ok
18:21:02 <rotaerk> so the analogy works
18:21:09 <boxscape> I think I get it
18:21:11 <leshow> rotaerk, so is it throwing an exception or returning  a value
18:21:18 <ski> sanett : the usual way to parse `\p.\a.\b.p b a \x.\y.x' is `\p.(\a.(\b.(((p b) a) (\x.(\y.x)))))', but it seems you intended (?) `(\p.(\a.(\b.((p b) a)))) (\x.(\y.x))', which is indeed beta-reduces in one step to `\a.(\b.(((\x.(\y.x)) b) a))', which is your `\a.\b.(\x.\y.x) b a'
18:21:45 <rotaerk> leshow, it's causing a Left to be returned, but it's *analogous* to throwing
18:22:36 <leshow> rotaerk, ok
18:25:45 <tswett_to_go> Going from C# to Haskell, I feel like I have a little bit too much freedom in how to write things. :D
18:25:55 <tswett_to_go> Mind, I knew Haskell *long* before I ever touched C#.
18:29:54 <tswett_to_go> I guess the constant question is how much I want to use combinators and how much I want to use lambdas, do-notation, and all that jazz.
18:34:34 <robertkennedy> sanett: having a hard time type checking that. You're saying that for all p, `p x y const = y?
18:38:46 <robertkennedy> sanett: and generally `p x y f = f x y` if that type checks?
19:02:21 <sanett> so now I have NOT TRUE = (λp.(λa.(λb.((p b) a) (λx.(λy.x)))))
19:02:41 <sanett> how do I deal with ((p b) a) (λx.(λy.x))?
19:05:50 <ski> sanett : i believe you're bracketting it wrong
19:06:29 <sanett> it should probably be (λb.((p b) a) (λx.(λy.x)))
19:18:55 <ski> sanett : nah ..
19:19:03 <sanett> I died.
19:19:30 <sanett> I actually got NOT TRUE = TRUE which is pretty funny
19:21:11 <boxscape> you heard it here first; lambda calculus is inconsistent
19:24:42 <adelbertc> is it in general best practice to always us Text for string-y things? i'm programming against the Pandoc API and noticed it uses the prelude String, but i am doing a bit of string manipulation in it (e.g. calling unlines and lines and doing string matching) and am wondering if i should use Text
19:25:22 <ChaiTRex> adelbertc: If you're dealing with actual text where Unicode matters, I think that's best.
19:26:00 <adelbertc> mm i wouldn't expect much Unicode if at all, im doing something involving parsing code blocks from a markdown document
19:33:20 <Welkin> adelbertc: Text is an optimization
19:33:31 <Welkin> adelbertc: String can work just fine depending on what you are doing
19:33:48 <adelbertc> Welkin: ChaiTRex sounds good, thanks!
20:34:51 <OGLoli> Would anyone happen to know of any online CS lectures / courses that teach from the perspective of functional programming. Instead of the typical teaching CS from a language like C.
20:35:39 <OGLoli> I know of courses that introduce functional programming design later on but that's only in the perspective of there's this and this is how it's different for one class or so.
20:36:22 <OGLoli> I'd like to know if there are any that teach from functional programming style from day 1 till the end of the course.
20:37:06 <dibblego> OGLoli: https://github.com/data61/fp-course/ and once you complete that, you can come and work there, https://www.itnews.com.au/news/data61-opens-new-labs-in-queensland-456275
20:37:35 <boxscape> https://github.com/bitemyapp/learnhaskell/ this includes that course and one more
20:38:10 <Welkin> OGLoli: functional programming is very high level (perspective from mathematics)
20:38:23 <Welkin> you still need to understand the low-level perspective (from hardware)
20:38:27 <dibblego> adelbertc: it's not common practice. You can use libraries to abstract over it, to defer the decision to users e.g. lens
20:38:38 <Welkin> so you will still need to learn c and/or assembly
20:38:46 <adelbertc> dibblego: oh hello :-)
20:38:56 <dibblego> adelbertc: hey mate :)
20:41:30 <OGLoli> Thank you, dibblego and boxscape. I appreciate it. Also welkin I will also be doing that, I would just like to learn the same concepts from different paradigms. I'm currently watching a very informative course by Harvard. The CS50 video course series.
20:53:33 <{emptyset}> is there anywhere good for asking about algorithms?
20:54:02 <{emptyset}> trying to understand a reduction from closure problem to maximum flow
21:07:15 <ackpacket> Hmm.... using Aeson, how can i convert this:  HashMap Text (HashMap Text Double) into an Object?
21:07:36 <ackpacket> Can't find any other way other than transforming everything into Value at each step, but shouldn't it already be compatible?
21:09:22 <thoughtpolice> ackpacket: Just use toJSON. There's an instance for (ToJSON k, ToJSON v) => ToJSON (Hashmap k v)
21:12:55 <ackpacket> thoughtpolice, that gives me a Value, which, passing into a function expecting an Object returns an error of "Couldn't match 'Value' with 'HashMap Text Value', expected type Object actual type Value
21:15:05 <thoughtpolice> ackpacket: You'll need to look at the 'Value' type to make sure it's an "Object" constructor. But there's an easier way, now that I look closer: use Data.HashMap.mapValues (or whatever it's called) with toJSON to turn every Double in the HashMap into a Value. You then have an 'Object', because 'type Object = HashMap Text Value'
21:15:55 <ackpacket> So that converts HashMap Text Double into Value, how do I convert that back later?
21:16:23 <ackpacket> i.e. the reverse of what operation
21:17:19 <thoughtpolice> You have to look at the Value and make sure it is the 'Double' constructor, there is no direct inverse. Technically, if you get a Hashmap Text Value, you don't know what's inside of it. You 'forgot' that you stored Double values in it.
21:19:06 <thoughtpolice> Oh, not 'Double'. It's the 'Number' constructor. And technically you won't get a Double back. You'll get a 'Scientific' which you have to convert to Double, using Data.Scientific.toRealFloat, I suppose.
21:22:31 <hololeap> i'm trying to understand the 'forall' keyword. i am somewhat familiar with set theory and the universal quantifier. can someone help me out?
21:23:33 <hololeap> i'm trying to understand the theory over the actual implementation
21:24:11 <hololeap> what is it signifying and how does that differ from what is usually there?
21:24:33 <hololeap> (in other words, from when there is no forall keyword)
21:26:21 <glguy> hololeap: a normal type signature like   map :: (a -> b) -> [a] -> [b]
21:26:33 <glguy> has an implicit forall at the beginning for all the type variables mentioned
21:26:49 <glguy> so it's equivalent to: map :: forall a b. (a -> b) -> [a] -> [b]
21:27:14 <hololeap> ok
21:29:20 <hololeap> i would think that would be the case. so, it's obviously not the same as the universal quantifier, since that is implicitly there all the time. but some functions don't match up, like `!!`
21:29:41 <hololeap> because `!!` doesn't allow negatives. does that have something to do with my question?
21:29:42 <glguy> It's the universal quantifier
21:29:45 <glguy> no
21:30:07 <glguy> forall lives at the type level
21:30:09 <glguy> :t (!!)
21:30:11 <lambdabot> [a] -> Int -> a
21:30:21 <hololeap> i can't remember the term for it... complete function?
21:30:26 <glguy> explicitly: forall a. [a] -> Int -> a
21:30:28 <dmwit> Why doesn't (!!) match up, and what does "doesn't allow negatives" mean?
21:30:45 <glguy> It means that it doesn't allow negative integer values as arguments at the value level
21:32:07 <glguy> forall introduces new type variables, like 'a'. It doesn't have to do with type constructors like Int, or any of the values of these types
21:32:27 <glguy> It's saying that (!!) has that type forall choices of types 'a' (with kind * in this case)
21:34:52 <hololeap> so what does explicitly writing it do
21:35:48 <dmwit> it makes it explicit
21:35:55 <dmwit> This sounds like a joke, but it's not.
21:36:06 <glguy> In general, it generates an error. If you turn on ExplicitForAll, in that case it does nothing. If you turn on ScopedTypeVariables it makes the named type variables available inside the definition's scope
21:36:23 <dmwit> oh yeah, I forgot about STV
21:36:28 <glguy> It gets more interesting when you don't put the forall next to the ::
21:36:38 <hololeap> how do you turn these on?
21:36:47 <glguy> example :: (forall a. [a] -> [a]) -> Int
21:36:58 <glguy> That requires RankNTypes
21:37:33 <glguy> or you can use forall with ExistentialQuantification:  data Example = forall a. Show a => MkExample a a
21:38:20 <hololeap> isn't putting a restriction in a data header frowned upon?
21:38:39 <glguy> Yeah, also it's not related to what I wrote
21:38:46 <hololeap> ok
21:39:01 <glguy> That would be something like: data Show a => Example a = MkExample a a
21:41:21 <glguy> hololeap: You can add a language pragma to the top of your module: {-# Language ScopedTypeVariables #-}
21:43:01 <hololeap> i think that helps me understand a little better
21:47:06 <hololeap> i didn't understand that none of this was the "vanilla" language. i will go look up those pragmas (and now i know the term). ty
21:57:08 <orion> Is the State Monad thread safe?
21:58:14 <Koterpillar> what do you mean by that?
21:59:04 <dmwit> It is pure, with all the consequences that come with that: thread-safety, but also thread-agnosticism.
21:59:20 <dmwit> If you're thinking you'll get a cheap way to share state between threads, State isn't it.
22:01:02 <dmwit> `State s a` is just a function `s -> (a, s)`.
22:01:36 <orion> My goal is to present a cryptographic API which prevents catastrophic nonce reuse.
22:02:13 <dmwit> I will be impressed if you manage that in Haskell's type system.
22:02:14 <orion> If we had linear types it would suit my use case perfectly, but we don't so...
22:03:01 <dmwit> I'm not even sure if linear types help.
22:03:40 <orion> I think it would: encryptMessage :: ByteString -> CryptoState -> (ByteString, CryptoState)
22:04:58 <orion> let msg = encryptMessage "foo" cs; msg' = encryptMessage "bar" cs <-- if I was using linear types, wouldn't this be unrepresentable?
22:05:55 <dmwit> That could work, if you could suitable restrict the construction of CryptoStates.
22:37:20 <_sras_> Why do funcions in the yaml config module require FromJson instances for the read data?
22:38:06 <jle`> the module from what package
22:38:31 <jle`> _sras_: if it's based on the 'yaml' library, it's because the yaml library is a thin wrapper over aeson
22:38:52 <jle`> it uses the FromJSON instance in order to parse yaml into data types
22:38:57 <_sras_> jle`: Yes. the 'yaml' library.
22:39:12 <jle`> so if you have a FromJSON intsance for your type Foo, it uses it to parse yaml representing Foo into Foo
22:39:39 <jle`> and it uses ToJSON serialize data into yaml
22:40:25 <_sras_> jle`: So the yaml configuration files are supposed to contain json wrapped in yaml?
22:40:55 <jle`> they're supposed to contain yaml
22:41:35 <jle`> but it just uses the information from the 'FromJSON' instance to parse yaml into the type
22:41:45 <jle`> you can imagine type FromYAML = FromJSON
22:41:47 <_sras_> jle`: Oh. Alright. 
22:42:11 <jle`> if a type has a FromJSON instance, it means that it can be parsed from a yaml file
22:43:02 <jle`> if it helps, you can imagine that FromJSON is caled FromYaml
22:43:41 <jle`> the yaml library is kind of "clever" in that it hijacks FromJSON to read yaml files
22:43:57 <jle`> so if you write a FromJSON instance for a type, you can use it to parse that type from json as well as yaml
22:51:06 <_sras_> jle`: Yes. Understood.
22:54:34 <_sras_> jle`: Do you know how I can make the config lib to read a key, like "dev",  "production" from env and return the relavant section from the config file?
22:54:52 <jle`> _sras_: well, the normal way to do it would be to write a data file that represents the configuration
22:55:06 <jle`> and then write a FromJSON/ToJSON instance for it.  this can be done automatically with generics
22:55:20 <jle`> so it's auto-derived
22:55:46 <jle`> but you can also parse the yaml into an Object (nested Map's and Vector's) for ad-hoc usage as well
22:56:24 <jle`> aeson-lens provides a nice way of do nested lookups
22:58:30 <_sras_> jle`: No. I think you got me wrong. I was not asking how to get a key from the config file. I was asking for a way to make the lib read a key, like "dev", "production" from the environment, and use the key to return the corresponding section from the yaml file (which will have the configurations nested under such keys as "dev" "production" etc")
22:59:24 <jle`> sounds like it wouldn't be too complicated
22:59:48 <jle`> you cna always parse a yaml file as a Map
22:59:57 <_sras_> jle`: Yes. It is not. But asking if there is a built in way in the lib for this.
23:00:49 <jle`> i'm not sure exactly what you mean
23:01:24 <jle`> but if you write a quick implementation i might be able to see if it's possible
23:10:50 <cocreature> _sras_: afaik there is no builtin way to do that
23:12:20 <_sras_> cocreature: Yes.
23:16:53 <morolin> Is there a preferred way to compare floats for approximate equality? I see the HUnit-approx package, Data.Eq.Approximate, and Data.AEq from ieee754, but it's not clear to me if I should prefer one over the other.
23:33:18 <ahri> hi, i'm trying to get https://github.com/JoeyEremondi/haskelm to build, but when compiling i get "Not in scope: data constructor ‘FamilyD’", yet PragmaD is there and seems to be defined in the same place judging by https://hackage.haskell.org/package/template-haskell-2.7.0.0/docs/Language-Haskell-TH.html - i'm new to Haskell and haven't touched Template Haskell at all. i'm just trying to get someone 
23:33:24 <ahri> else's project building! do you have any tips for me to investigate?
23:34:28 <ahri> i assumed that it was using a different version of template-haskell so i made the version explicit in the .cabal file: template-haskell >= 2.7.0.0, but that made no difference: the compilation still fails
23:37:00 <glguy> ahri: that author didn't bother with version constraints, but the template-haskell package has changed since this was written
23:37:43 <glguy> so you'll have to figure out the versions yourself. you can't change template-Haskell versions without changing ghc versions
23:38:24 <ahri> ah, that's a great hint! i'll try to figure out what version he was using and go from there
23:38:45 <ahri> and set all the versions, once it's compiling
23:52:57 <ahri> glguy: is there some way i'm missing of correlating the template haskell version (2.10.0.0) back to a ghc version? the only hint i can see is that it depends on base==4.8.* but as i said, i'm new and this doesn't jump out as being tied to a particular GHC version
23:57:49 <cocreature> ahri: base 4.8 is GHC 7.10
