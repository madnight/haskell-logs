00:00:02 <lolisa> I had gone to f-algebra, and it is going sort of quite well. The only problem is, I 'get' the commutative diagram prove much faster than the 'traditional' equational reasoning style proof that I generate alongside in my head.
00:00:39 <lolisa> so should I learn to forget about my old intuition and just do commutative diagram?
00:00:40 <ski> how is that a problem ?
00:01:00 <ski> perhaps learn to more easily translate between the two ?
00:01:33 <lolisa> Yes, those two are options to choose from, and I dont know if keeping the old is useful or not.
00:03:09 <ezyang> nothing wrong with commutative diagrams 
00:03:16 <ski> i don't think the commutative diagram approach itself handles expressing the logic surrounding equations between compositions that well
00:04:21 * ski raises eyebrow
00:05:03 <ski> iirc Freyd and Scedrov used a marker in a polygon to express that the corresponding equation didn't have to hold. then they could e.g. have implications between diagrams involving the same objects and morphisms, though the latter diagram could involve some more as well
00:47:00 <osa1> exporting lenses for a type individually is too much work. that's not possible to do with some TH magic, right?
00:47:13 <jle`> osa1: that's what "classy" lenses are for
00:47:33 <jle`> osa1: it defines lenses for a type as instances of a new typeclass
00:47:38 <jle`> so you just export the typeclass(..)
00:47:56 <jle`> s/instances/methods
00:48:02 <osa1> jle`: which package does that?
00:48:44 <jle`> osa1: http://hackage.haskell.org/package/lens-4.15.1/docs/Control-Lens-TH.html#v:makeClassy
00:48:55 <jle`> it's in the lens package
00:49:11 <jle`> instead of writing `makeLenses`, just write `makeClassy`
00:49:20 <jle`> they're both exported from the same module
00:51:32 <osa1> hmm defining a typeclass and an instance just for exporting purposes doesn't sound nice.
00:51:41 <osa1> it'll also make the error messages worse if I use a lens with imcompatible type
00:51:45 <osa1> e.g. lens for X with Y
00:54:24 <osa1> I know I'll end up using that though :-) thanks jle`
00:54:59 <jle`> no problem!  and yeah i always felt it was more of a hack than anything
00:55:35 <magthe> An emacs question: when adding a package to a .cabal file I sometimes get a completion suggestion and if I then press <RET> I get a lower bound for the version... is there some way to control this behaviour (I'd relly like to get an upper bound too)?
00:56:07 <magthe> Oh, should probably mention that I'm using spacemacs, with intero
01:52:23 <Squarism> Here, what does it mean if a construtor parameter has "!" infront of it like here : https://hackage.haskell.org/package/aeson-0.11.1.2/docs/Data-Aeson.html#t:Value, 
01:52:36 <sbrg> That it's strict
01:52:40 <sbrg> See the BangPatterns extension
01:52:55 <Squarism> ok thanks
01:56:09 <geekosaur> that's not BangPatterns though, it's core Haskell
01:57:19 <Akii> not anymore maybe https://downloads.haskell.org/~ghc/7.8.4/docs/html/users_guide/bang-patterns.html
01:57:30 <geekosaur> but in any case it means any time a value is constructed, that field's value will have seq applied to it so it has been evaluated to the first constructor. (this does not guarantee full strictness, except for "atomic" types like Int)
01:57:47 <merijn> Akii: Hasn't been an extension in years, if ever
01:57:47 <geekosaur> no, BangPattgerns is for use in patterns. use in data constructors is Haskell98
01:57:56 <merijn> Akii: bang patterns is about *patterns*, not constructors
01:57:59 <merijn> Hence, the name
01:58:12 <Akii> merijn: got confused about -XBangPatterns; I only know that from lang extensions
01:59:43 <Akii> so, I also see this bang pattern being used occasionally; when should I use it?
02:00:25 <geekosaur> most common use is when you are deconstructing/pattern matching with let; case and top-level pattern bindings are strict by default
02:00:58 <geekosaur> but let is lazy by default (except, iirc, if you have MonoLocalBinds enabled)
02:02:11 <Akii> geekosaur: and with data constructors?
02:02:13 <geekosaur> hm, either I am misremembering that or it's a related extension
02:02:45 <geekosaur> data constructors are a different issue, any time you build a value with that constructor it will be lazy unless the declaration included a bang on the type
02:03:21 <geekosaur> this is not related to pattern matching: even if you match a value of that type, it's something that already exists so no constructor behavior would be applied to it
02:03:32 <Akii> so `data Foo = Int String` will have `Foo thunk thunk`?
02:03:40 <geekosaur> errrr
02:03:53 <geekosaur> I assume you meant data Foo = Foo Int String, otherwise the value is Int thunk
02:03:59 <Akii> ah yes, sorry
02:04:12 <geekosaur> (remember type and data constructors are in separate namespaces)
02:04:31 <Akii> and with `data Foo = Foo !Int !String` it would evaluate directly
02:04:39 <Akii> (yes, I know; just typo :D)
02:05:00 <Akii> that's very interesting
02:05:36 <Akii> for me that means: if I produce a lot or if I definitely need those values when constructing a data type, I use strict evaluation
02:05:49 <geekosaur> it depends on usage
02:06:15 <geekosaur> if it is often part of a computation that would otherwise end up being discarded much of the time, strictness will cause slowdowns
02:07:11 <Akii> I don't understant
02:07:17 <Akii> understand* xD
02:07:32 <Akii> what's the slowdown; discarding the thunk vs discarding the value?
02:07:50 <Akii> ah yes sorry
02:07:59 <Akii> "strictness will cause slowdowns"
02:08:03 <Akii> somehow read laziness >.<
02:08:07 <Akii> of course ^^
02:08:17 <geekosaur> the thunk ends up part of a value you never reach because something else is doing a take 3 that never reaches it, or something
02:08:26 <geekosaur> so you forced a value to no point
02:08:59 <Akii> generating thunks just uses up more memory then?
02:09:34 <geekosaur> thunks are usually cheap, it's forcing values that is expensive. but it depends on what you do with them, as usual
02:09:50 <Akii> well I had one case where I ended up with 4 GB of thunks
02:09:54 <geekosaur> which is why you really need to profile and not just sprinkle bangs on stuff liek salt
02:09:56 <Akii> that was fun
02:10:05 <Akii> like salt bae xD
02:10:23 <Akii> okay, thanks!
02:10:28 <geekosaur> reasoning about where laziness helps and where it hurts is *hard*
02:11:29 <geekosaur> thunks can consume memory if they stack up in the pattern match stack. heap allocations can consume memory as well. (the foldr/foldl issue)
02:11:51 <geekosaur> one is from too much laziness, the other from being too strict
02:13:38 <geekosaur> and one of the strengths of haskell is laziness lets you specify work that won't be done if it's not needed (e.g. infinite lists) if that's the natural way to express something; strictness will hurt you in this case
02:14:21 <geekosaur> go the "must strict everything!" route and you end up writing Haskell-flavored C instead of Haskell
02:15:02 <geekosaur> because common Haskell idioms and even common Haskell library functions will choke if you are too strict
02:15:19 <Adeon> I also find non-strict semantics a readability benefit
02:15:21 <Akii> other than the one issue (where I expected nothing else) I never had any problems with laziness so far
02:15:31 <Akii> but good to keep in mind; some day I'll run into an issue :D
02:15:34 <Adeon> sometimes I can write expensive computations in a function with confidence none of that will be computed if it turns out they don't need to be
02:29:50 <Aku> Can anybody tell me the difference between newtype Parser a = Parser (String -> [(a,String)]) and type Parser a = String -> [(a,String)] ?
02:30:24 <ski> the former declares a new data type. the latter merely gives a synonym to an existing type
02:31:18 <ski> the former could be made an instance of type classes like `Functor',`Applicative',`Monad'. the latter couldn't
02:31:23 <Aku> To declare a new data type we usually write data Colour = Red | Green 
02:31:50 <ski> yes
02:31:52 <Aku> What's the difference?
02:31:59 <Aku> ski: ?
02:32:08 <ski> `newtype' is a special case of `data', that's handled slightly differently
02:32:13 <dramforever> Aku: newtype only makes a new type not new data
02:32:28 <Aku> dramforever: okay
02:32:30 <dramforever> It's best thought as a compile-time wrapper of another type
02:32:44 <ski> `newtype' is like `type' in that you can only "wrap" one type. also no multiple data constructors
02:32:48 <dramforever> compile-time only
02:33:17 <ski> but it's like `data' in that you have an explicit data constructor, to construct and deconstruct (pattern-match)
02:33:18 <Aku> ohhkay...
02:33:28 <Aku> ya right
02:33:44 <ski> since it's a new type, the "implementation/representation type" and the new type are considered distinct
02:34:21 <Aku> ohhkay
02:34:30 <ski> one can think of the data constructor of a `newtype' as only existing at compile-time, while at run-time a value of the representation type is passed around directly
02:34:32 <Maxdamantus> The only reason it's not just `data` afaik is its special handling of deconstruction.
02:34:32 <Aku> Thanks
02:34:57 <Maxdamantus> (that is, not just a special case of `data`)
02:35:06 <ski> this means that there's no difference between `Parser undefined' and `undefined' (there would be a difference with `data')
02:35:21 <Maxdamantus> Yeah, that.
02:35:44 <ski> also, matching on the pattern `Parser f' will not demand/force any evaluation
02:36:03 <Aku> hm...
02:36:32 <ski> you can probably ignore these finer points for now
02:36:59 <Aku> ya looks like, I need to read more!
02:38:47 <osa1> *sigh* I sometimes think typeclasses like ToJSON, FromField etc. are actually an anti-pattern. it's especially annoying when only typeclass versions of combinators are provided (e.g. (.:))
02:39:11 --- mode: ChanServ set -q *!*@*/ip.202.164.220.226
02:39:13 <osa1> most of the types don't have a canonical JSON, CSV field etc. representation
02:39:57 <merijn> I really hate that people decided JSON was a reasonable format for serialising shit
02:40:12 <Akii> what's wrong with ToJSON?
02:40:14 <merijn> You can't even reliably store an integer in JSON unless you store it as a string, for christ's sake
02:40:26 <merijn> Akii: You mean "what's wrong with JSON?"
02:40:29 <osa1> Akii: like I said, there most types don't have canonical JSON representation
02:40:45 <osa1> but a type can have one instance of a typeclass
02:40:46 <merijn> I'm sure ToJSON is perfectly reasonable, if you are a priori okay with the idiocy that is JSON
02:41:26 <osa1> merijn: is it? I can implement many JSON representations of a type
02:41:54 <Akii> well Aeson does offer a data type representing JSON
02:42:14 <osa1> Akii: like I said, combinators like (.:) only have typeclass version. I can't provide a parser to (.:)
02:42:22 <Freundlich> osa1: But that's the case for most type classes anyway. Sometimes it's also quite annoying (like what should a monoid of natural numbers be?).
02:42:23 <osa1> so I have to implement a newtype
02:42:29 <osa1> Freundlich: agreed
02:42:40 <osa1> IMHO typeclasses should be used less, not more
02:43:13 <ski> "combinators like (.:) only have typeclass version" ?
02:43:52 <osa1> ski: `(.:) :: FromField a => NamedRecord -> ByteString -> Parser a` I need a version of this function that takes a `fromField` function
02:44:05 * ski 's never seen this before
02:44:18 <osa1> it's from cassava but similar functions exist in aeson too
02:44:22 <Akii> this? https://hackage.haskell.org/package/aeson-1.1.0.0/docs/Data-Aeson.html#v:.:
02:44:29 <ski> (as opposed to `(.:) :: (c0 -> c1) -> (a -> b -> c0) -> (a -> b -> c1)')
02:44:56 <Akii> this would allow you to write a parser for Value though, which is instance of FromJSON
02:45:10 <Akii> -would +does
02:46:16 <osa1> Akii: yeah like that function. I need a version of it that takes the parser as argument
03:08:29 <jle`> osa1: i've come to think that ToJSON/FromJSON is a better solution than offering serializers apart from the typeclasses
03:08:35 <jle`> because it enforces a canonical encoding
03:08:55 <jle`> which is important for functions that are polymorphic over all JSON instances
03:09:08 <jle`> kind of like for 'Data.Map' or 'Data.HashMap'
03:09:24 <osa1> those functions can still be polymorphic by getting a parser/serializer parameter instead!
03:09:40 <jle`> yes, if Data.Map was given a comparing function instead, then things would break
03:09:48 <osa1> things worse for CSV instances btw, because even the simplest types like Bool don't have a canonical representation
03:10:03 <jle`> because you have to guaruntee that *every* time someone uses a given Map, you have to use the same comparing function as the one it was created with
03:10:09 <osa1> jle`: not if you use the same function for insertion and lookup
03:10:23 <jle`> yes, you have to give the same function every time
03:10:26 <osa1> jle`: right. I'm willing to do that for CSV/JSON instances.
03:10:49 <jle`> so for JSON, you have to guaruntee that the same decoding parmaeter is used every time you work with it
03:11:15 <jle`> requiring people to pass it in at every single usage site is a sure-fire way to get a bug
03:11:31 <osa1> at least provide both versions of functions then
03:11:44 <osa1> I don't want to maintain this mess of newtypes
03:12:02 <jle`> like if you required people to pass in a comparator function every time you used insert/lookup for Data.Map is a really really fast way to get corrupted maps
03:12:19 <jle`> hopelessly corrupted maps would be inevitable
03:12:35 <osa1> I'm not talking about Ord or Eq or maps
03:12:53 <jle`> it's the same situation here, though
03:13:08 <jle`> ~ the power of analogy ~
03:14:29 <jle`> especially talking about situations where you use multiple modules and multiple executables all working polymorphically with json instances, if you require people to pass in a parser every time, it's an easy way to get data corruption
03:14:34 <tdammers> IMO the most whopping advantage of ToJSON / FromJSON being typeclasses is that you can write generic instances for higher-kinded types without dragging explicit encoders along
03:15:01 <tdammers> pretty much exactly that
03:15:08 <osa1> jle`: it's not the same situation at all. I can have multiple JSON providers that use different formats for the same thing.
03:15:23 <tdammers> osa1: you can still do that, just not through ToJSON / FromJSON
03:15:33 <tdammers> osa1: but you can still provide alternative ser/der explicitly
03:15:39 <osa1> tdammers: not easily. I need newtypes
03:15:55 <tdammers> osa1: not if you bypass the JSON typeclasses
03:16:24 <osa1> it's still a lot harder. like I said above many times, functions like .: need typeclasses
03:16:27 <jle`> osa1: you can have multiple ORd instances for types too.  but the important thing is that you always use the same instance for a given Map value.  and that you always use the same serializer for a given data channel
03:17:18 <jle`> you might have more than one way to serialize something, but the site of serialization and the site of deserialization have to agree on which one to use
03:17:37 <jle`> (like the site of insertion and the site of lookup have to agree on which comparator method to use)
03:17:43 <osa1> btw in languages like OCaml people solve this problem by parameterizing modules with Eq/Ord providers. different instances then get different types (or something like that, I'm not an expert)
03:18:40 <osa1> so lookup is attached to the map. you can only use that lookup function
03:18:51 <osa1> which uses the Ord/Eq etc. provided on initialization
03:18:55 <osa1> anyway
03:19:14 <Squarism> Using different API's ive come to juggle between Data.Text, Data.String, Data.ByteString. But its getting tedious. Is there any of them that "can go"
03:19:26 <osa1> I started to think that most typeclasses suck (and so do APIs that rely on typeclasses heavily)
03:19:49 <Squarism> (..and forgot to mention - the Lazy variants too)
03:19:57 <jle`> it is true that most typeclasses suck
03:20:05 <jle`> it's easier to write a bad typeclass than a good one
03:20:10 <liste> Squarism: Data.String
03:20:25 <jle`> but typeclasses have their specific and narrow set of benefits/use cases
03:20:36 <Squarism> liste, oh ok
03:20:52 <liste> Squarism: it usually has bad performance
03:20:57 <jle`> s/typeclasses have their/the idea of a typeclass has its
03:21:13 <liste> Squarism: Data.Text for text, Data.ByteString for binary data :)
03:21:24 <Squarism> ok!
03:21:28 <tdammers> you could probably get pretty close with -XImplicitParameters
03:22:57 <jle`> Squarism: i've seen libraries like this one https://hackage.haskell.org/package/string-conversions-0.4.0.1/docs/Data-String-Conversions.html
03:23:08 <jle`> but i'm not sure how good of an idea they are
03:23:10 <tdammers> then you could write something like: let ?toJSON = myCustomSerializer in serveJSON someSerializableValue
03:23:16 <angerman> anyone got some avx exercising code handy? 
03:23:32 <tdammers> dynamic binding is ugly though IMO
03:24:44 <Squarism> jle`, haha
03:25:37 <Squarism> I confess on beeing lazy in digging deeper into strings. Performance isnt my biggest concern. So i guess its written for people like me
03:40:47 <dminuoso> Okay, so I've just started with Haskell a short while ago and found myself writing some strange Ruby code. Is this kind of like a Monad what I just did? https://eval.in/749667
03:44:29 <jle`> it looks similar to List
03:44:29 <tdammers> kind of, it seems
03:44:40 <tdammers> but not quite
03:44:51 <tdammers> initialize() is roughly return, and call() is roughly bind
03:44:54 <jle`> and list is indeed a monad, if that counts
03:45:11 <tdammers> however,
03:45:15 <tdammers> :t (>>=)
03:45:18 <lambdabot> Monad m => m a -> (a -> m b) -> m b
03:45:39 <tdammers> whereas call() is closer to :: m a -> a -> m a
03:46:09 <tdammers> m being GuessWhatThisIs, and m a being an instance of that class
03:46:39 <roundhouse> hi, if I have a typeclass with a parametric type family, "class A a where; data A a :: *" and I want to instansiate this class for a type "data B b = { ... }" I'd like to specify the type "data A a = b" but I get an error "Not a dataconstructor 'b'". Any ideas how I can do this?
03:46:41 <jle`> yeah, i wouldn't say that it exports a monadic interface.  just that it's similar to lists, and that list is a monad
03:46:48 <jle`> but doesn't ruby also alrady have arrays?
03:47:22 <jle`> roundhouse: you need to give an ADT a constructor
03:47:40 <dminuoso> Give me a minute to process what has just been said in here before I respond. :)
03:47:43 <jle`> roundhouse: how familiar are you with algebraic data types?
03:47:49 <roundhouse> jle`: somewhat
03:47:58 <roundhouse> jle`: can you recommend a reading?
03:48:19 <jle`> oh wait, this looks more like an issue with data families
03:48:30 <jle`> but yeah, ADT's are something most introduction haskell books teach
03:48:36 <tdammers> it does produce a cartesian product similar to how you'd do it in Haskell using the list monad
03:48:38 <jle`> data Maybe a = Nothing | Just a
03:48:49 <roundhouse> jle`: That I know
03:48:52 <jle`> dminuoso: my answer was that it resembles a monad, but only because it resembles a list, and lists are a monad
03:49:06 <jle`> dminuoso: so if you had shown me ruby arays, i would also say that arrays resemble a monad
03:49:10 <jle`> to the same degree that your example does
03:49:16 <jle`> roundhouse: or how about data Identity a = Identity a
03:49:25 <jle`> do you see why you can't have `data Identity a = a` ?
03:49:29 <jle`> ADT's need constructors
03:50:00 <jle`> for Maybe, you have the Nothing constructor and the Just constructor
03:50:05 <jle`> for Identity, you have the Identity constructor
03:50:11 <jle`> but you can't just plop in data Ident a = a
03:50:12 <roundhouse> ok
03:50:25 <roundhouse> Makes sense
03:50:42 <jle`> ADT's are sums of constructors, so it's data MyADT .. = Constr1 ... | Constr2 ... | Constr3 ...
03:50:48 <Rodenbach> Let’s say I have a function f and 15 callers of it. Now I need to update the signature of f and test it with one of the callers. Is it possible to update just one caller and ask ghc to compile my program anyway, although I know that there are 14 bugs?
03:51:04 <lyxia> roundhouse: did you want a data family or a type synonym family
03:51:11 <jle`> Rodenbach: defer type errors
03:51:14 <jle`> maybe?
03:51:36 <roundhouse> data family if I understand this correctly
03:51:39 <Rodenbach> jle`: okay, a compiler option. Sounds good, thx.
03:52:11 <jle`> roundhouse: data families require you to associate types with a whole new ADT
03:52:21 <jle`> so you can do data A a = MyA b
03:52:37 <roundhouse> Can't I specify a data type of the context?
03:52:45 <lyxia> data (B b) = MyA b actually :)
03:52:58 <lyxia> A (B b)   ughhh
03:53:41 <jle`> so you want to write an instance for the type 'B'?
03:53:50 <jle`> instance A B where ... ?
03:53:57 <roundhouse> https://github.com/r-raymond/purple-muon/blob/master/src/Client/Assets/Generic.hs
03:54:14 <roundhouse> Where I'm trying to implement instance AssetLoader (HashmapLoader a ext) 
03:54:19 <jle`> yeah, data families require you to create a whole new adt with new constructors and everything
03:54:37 <jle`> so if you want it to just point to an old type, can just wrap it in a boring constructor
03:55:00 <roundhouse> ok that might be a good idea
03:55:35 <jle`> the reason why is so that data families are injective
03:55:40 <jle`> so type inference is a lot nicer
03:55:52 <jle`> (as compared to having associated types)
03:56:00 <roundhouse> I see
03:56:14 <jle`> if it was type Asset al :: *, then if you wanted to call 'loadAsset' and gave a 'HashmapLoader a ext'
03:56:17 <roundhouse> I was running into the issue of noninjectivity when I tried to use a type family
03:56:20 <jle`> then it would be ambiguous which instance you'd want
03:56:33 <jle`> because more than one instance of AssetLoader might have type Asset Foo = HashmapLoader a ext
03:56:48 <roundhouse> I see
03:56:56 <jle`> more than one instance of AssetLoader might have the same Asset type, so calling 'loadAsset x' is amgiuous
03:56:58 <lyxia> uh
03:57:11 <roundhouse> thank you very much for explaining this
03:57:14 <jle`> but with data families, the ambiguity goes away
03:57:20 <lyxia> It's not Asset a1 is the type of loadAsset
03:57:29 <jle`> oh
03:57:41 <jle`> sorry, my bad :)
03:57:59 <jle`> but yeah, the idea is that you can't infer what 'a1' is just from seeing 'Asset a1', if Asset is a type family
03:58:20 <jle`> but if Asset is a data family, then a value of type 'Asset a1' is unambiguously associated with a single a1
03:59:20 <jle`> (in the first case, multiple instances might have type Asset Foo = Int, type Asset Bar = Int, type Asset Baz = Int, so if i saw 'Asset a1 ~ Int', i couldn't tell you want a1 was)
03:59:44 <lyxia> Since all type class methods have at least one occurence "a1" in their type which is not part of "Asset a1", type inference is much less of a problem
04:00:19 <Robert__>  takeWhile (/=' ') "This is a sentence"  
04:00:23 <Robert__> Why does this code output "This"
04:00:49 <Ferdirand> that sounds like a reasonable output
04:01:08 <Ferdirand> which part is confusing to you ?
04:01:10 <Robert__> I'm new to haskell, is this the correct IRC channel to be using
04:01:12 <liste> Robert__: what do you expect it to output?
04:01:13 <jle`> Robert__: it takes items from 'This is a sentence', as long as the items are not ' '
04:01:31 <lyxia> roundhouse: if HasmapLoader a ext is to define a as the type of asset, it seems much more convenient to define an associated type synonym family.
04:01:32 <jle`> so it'll take T, then h, then i, then s, but as soon as it sees ' ', it quits
04:01:44 <Robert__> Oh that is, in fact, very logical :) 
04:01:46 <Robert__> my bad
04:02:25 <Robert__> I'm also a bit confused regarding the 'where
04:02:36 <Robert__> so lets say I want to do a takeWhile on a list
04:02:52 <Robert__> how do I make more complicated functions as the condition
04:03:10 <jle`> you can pass in any 'a -> Bool' as your condition
04:03:19 <jle`> so if your condition is complicated, you can define it elsewhere and give it a nice name
04:03:24 <jle`> myPredicate x = ...
04:03:30 <jle`> and then do 'takeWhile myPredicate'
04:04:48 <Robert__> hmm so in what cases would you use the 'where' syntax. 
04:05:32 <Robert__> so something like 'takeWhile myPredicate xs'
04:05:40 <Robert__> followed by 'where myPredicate = ...'
04:05:47 <jle`> that's one way to do it
04:09:20 <Robert__> ok let's say I want the square numbers less than 50, so myPredicate needs to check if the input is a perfect square. 
04:09:36 <Robert__> result = takeWhile (square) [1..50]
04:10:00 <Robert__> then how do I define 'square' using the 'where' notation?
04:11:36 <Rodenbach> I have     data Foo c = Clear c | XYZ      and want to match this bar when Clear wraps an Integer.    bar (Clear (Integer i)) 20 = i+100         <= this doesn’t work. How can I write this pattern?
04:12:22 <ski> Rodenbach : what is the expected type of `bar' ?
04:13:02 <Rodenbach> I want it to return whatever is wrapped by Clear.
04:13:23 <ski> Robert__ : `.. where square n = ..n..', where `..n..' is a boolean condition checking whether `n' is a square ?
04:13:39 <tdammers> Rodenbach: Integer is the name of the type, it's not a term-level constructor
04:13:51 <ski> Rodenbach : how about `bar :: Foo Integer -> Integer -> Integer' ?
04:14:13 <ski> Rodenbach : then `bar (Clear i) 20 = i+100' would work as a definition
04:14:16 <Rodenbach> tdammers: I also tried   bar (Clear (i::Integer)) 10 = i+100
04:14:33 <tdammers> Rodenbach: and what is the error you get?
04:14:42 <lelf> [trifecta/parsers] Why on earth? runUnspaced <$> parseString (Unspaced <$> symbol "x" <* eof) mempty "x " => Success "x"
04:15:03 <Rodenbach> tdammers: Illegal type signature 'Integer'.
04:15:17 <ski> Rodenbach : what is your type signature ?
04:15:53 <ski> to use `i :: Integer' in a pattern like that you need (`PatternSignatures' or) `ScopedTypeVariables', a language extension, enabled
04:15:53 <tdammers> Rodenbach: try attaching a type signature to the entire function, rather than inside the pattern match
04:15:57 <lyxia> Rodenbach: you can't match on types if that's what you're tyring to do
04:16:14 <Rodenbach> lyxia: okay, I think I was trying that.
04:16:21 <Rodenbach> Will think about this then again, thanks.
04:16:40 <tdammers> Rodenbach: what lyxia said; you cannot dispatch on types at runtime, because types are resolved at compile time
04:16:46 <ski> you can't make `bar' behave one way if `i' is an `Integer', and another way if it isn't ..
04:17:00 <lyxia> Rodenbach: you can restrict the type of the function so that the caller can't ever pass something that doesn't wrap an integer.
04:17:07 <ski> .. without resorting to `Typeable, i.e. -- but you probably don't want to reach for that here
04:17:28 <Robert__> :ski yes that makes sense
04:18:00 <ski> Robert__ : also, `takeWhile square [1 .. 50]' will work just fine, without the round brackets
04:18:32 <lyxia> lelf: "symbol" skips trailing whitespace
04:18:45 <Robert__> ok and my mind is pretty blank, how would I implement a boolean to check if an input is square
04:19:29 <jan_path> lyxia: The Unspaced newtype is supposed to disable that behaviour.
04:19:30 <ski> Robert__ : one way would be to iteratively subtract odd integers, until you reach zero or a negative integer
04:20:29 <ski> > scanl (+) 0 [1,3 ..]
04:20:37 <lambdabot>  mueval-core: Time limit exceeded
04:20:40 <Robert__> clever. hm maybe I could just make a list of squares with map (^2) [1..] and see if it's inside
04:20:57 <Robert__> probably quite inefficient lol
04:21:23 <Robert__> then I'd have 'where square x = elem $ map (^2) [1..]'
04:21:25 <Robert__> is that correct?
04:21:29 <ski> > take 16 (scanl (+) 0 [1,3 ..])
04:21:35 <lambdabot>  [0,1,4,9,16,25,36,49,64,81,100,121,144,169,196,225]
04:21:42 <ski> Robert__ : doesn't work for non-squares
04:21:58 <ski> Robert__ : try using `takeWhile' and `null', perhaps ?
04:22:53 <lyxia> jan_path: OH. I see sorry.
04:22:58 <Robert__> what do you mean by 'null'
04:23:02 <Robert__> looking it up on hoogle.
04:23:04 <ski> @src null
04:23:04 <lambdabot> null []    = True
04:23:04 <lambdabot> null (_:_) = False
04:23:05 <lyxia> lelf: you flipped the order of runSpaced and parseString I think.
04:23:36 <Robert__> man that's useful 
04:23:49 <Robert__> I don't understand how I'd use null in this case
04:24:01 <ski> usually pattern-matching is nicer. sometimes `null' is handy
04:24:21 <Robert__> right. Well, thanks for your help m8, I learnt something new about haskell today
04:24:22 <ski> > dropWhile (< 16) (map (^ 2) [0 ..])
04:24:26 <lambdabot>  [16,25,36,49,64,81,100,121,144,169,196,225,256,289,324,361,400,441,484,529,5...
04:24:34 <ski> > dropWhile (< 7) (map (^ 2) [0 ..])
04:24:40 <lambdabot>  [9,16,25,36,49,64,81,100,121,144,169,196,225,256,289,324,361,400,441,484,529...
04:24:57 <ski> in the first case, the list starts with `16', in the second case it doesn't start with `7'
04:24:59 <jan_path> lelf: runUnspaced (symbol "x" *> eof :: Unspaced Parser String)
04:25:35 <Robert__> > takeWhile (<50) $ map (^2) [1..]
04:25:39 <ski> > (takeWhile (<= 16) . dropWhile (< 16) . map (^ 2)) [0 ..]
04:25:41 <lambdabot>  mueval-core: Time limit exceeded
04:25:44 <lambdabot>  [16]
04:25:45 <jan_path> The signature should be `Unspaced Parser ()`
04:25:46 <ski> > (takeWhile (<= 7) . dropWhile (< 7) . map (^ 2)) [0 ..]
04:25:50 <lambdabot>  []
04:26:00 <ski> Robert__ : then you could use `null' on this list ..
04:26:15 <Robert__> ah I understand
04:26:29 <ski> Robert__ : instead of doing a `takeWhile' after the `dropWhile', it might be simpler to just check the first element of the list directly ..
04:26:52 <Robert__> that seems to make sense.
04:26:57 <ski> using `null' was the first thing that came to my mind, re `map (^ 2) [0 ..]'
04:27:14 <jan_path> lelf: Wrapping in Unspaced after using symbol does not do anything. You have to use the symbol of the `Unspaced Parser a' instance.
04:27:21 <ski> (note that i started at `0', not `1', because `0' is also a square)
04:29:56 <lelf> jan_path: ah! thanks!
04:56:01 <Squarism> i just want to pretty print some haskell code for a web page im making. Anyone know a simple / good looking solution to that?
04:57:46 <opqdonut> Squarism: pandoc has haskell syntax hilighting
04:58:38 <opqdonut> e.g. http://pandoc.org/demo/example18a.html
05:03:37 <schismz> hello all
05:06:22 <ertes> pandoc's syntax highlighting for haskell sucks though
05:08:08 <merijn> Is it at least correct? Because the one github uses barfs on lots of things (like DataKinds quotes)
05:10:25 <bennofs1> Squarism: pygments perhaps?
05:11:09 <Squarism> opqdonut, i tried that - but my output was black-n-white and not monospaced
05:11:19 <sbrg> ertes: not in my experience
05:11:19 <Squarism> bennofs1, ok ill check it out
05:11:33 <sbrg> I used pandoc to compile markdown+lhs to pdf and it looked very nice
05:12:23 <Squarism> opqdonut, maybe one needs some .css for it to be complete
05:14:38 <ertes> merijn: i haven't used it on any complicated code
05:15:28 <ertes> but it can't properly tell things apart that are really distinct…  effectively i ended up not using colour at all and just emphasising keywords
05:15:56 <ertes> that's the only thing it gets right for the most part
05:16:40 <cris_> hi all, i uploaded a package to Hackage: https://hackage.haskell.org/package/carbonara-1.0.0/candidate
05:16:50 <ertes> sbrg: this isn't about looks, but about properly parsing and tagging haskell code
05:17:12 <cris_> how could i upload it also to nixpkgs ? could you recommend a nixpkgs upload user guide?
05:17:36 <ertes> cris_: it will be in nixpkgs automatically from the next hackage update cycle forward
05:17:41 <ertes> those happen frequently
05:19:09 <cris_> by the way, other packages in hackages shows the source code after clicking the module name, how do i enable this as well?
05:21:12 <bennofs1> cris_: it will take a will for hackage to build the documentation for your package
05:22:02 <ertes> cris_: could there be a problem with your library?  it doesn't seem to be on hackage properly
05:22:28 <ertes> cris_: there is a warning at the top
05:22:33 <bennofs1> ertes: it's a candidate
05:22:45 <ertes> ah…  i didn't know those existed
05:22:47 <bennofs1> ertes: that warning is harmless
05:23:13 <ertes> cris_: in that case: i don't know if the nixpkgs hackage updater will up candidates
05:23:25 <ertes> *pick up
05:23:54 <bennofs1> cris_: ertes: i don't think it will. it'll pick it up after the candidate is released though
05:24:17 <ertes> of course you can always just use a local haskellPackages override to include your package
05:24:41 <cris_> hi ertes, i m not sure how to resolve the warning , I immitate the structure of "turtle" package
05:24:50 <bennofs1> cris_: the warning is harmless
05:25:34 <ertes> bennofs1: is that hackage's way of saying: "YOU DIDN'T USE "Control" or "Data" or …!!!"?
05:25:38 <bennofs1> cris_: it won't show if the candidate is released
05:25:43 <bennofs1> ertes: yes
05:25:46 <ertes> i see
05:25:53 <cris_> here is my repo is github: https://github.com/szehk/Haskell-Carbonara-Library
05:26:47 <cris_> this is an initial release , it only include very few functions , i already write up a bunch of useful function to interact with mysql and postgresql
05:29:40 <cris_> in hackage, it says that package "candidate" is a new function, so i use it, do you guys know how long it will take to get from "candidate" to real package in hackage?
05:30:49 <lyxia> it's up to you
05:31:08 <ertes> cris_: BTW:  isWeekday d = not (isSaturday d || isSunday d)
05:31:47 <lyxia> cris_: you must release the candidate yourself, I think by following the link "edit package information"
05:31:55 <ertes> isSunday d = toModifiedJulianDay d `mod` 7 == 4
05:32:03 <cris_> ertes: your version is clearer
05:32:31 <ertes> cris_: remember that functions like (==) return a Bool by themselves…  you don't need to guard on it
05:33:05 <lyxia> cris_: there shouldn't be a "dist" directory in your repo
05:34:40 <ertes> cris_: also there are easy ways to abstract most of the functions away, because having separate functions for each day makes them awkward to work with, because you couldn't abstract over the day easily:  isA d d' = toModifiedJulianDay d `mod` 7 == d'
05:34:43 <ertes> d `isA` sunday
05:36:11 <cris_> thanks ertes , i copied down your words and will modify accordingly
05:36:35 <ski>   isSunday,isMonday,isTuesday,isWednesday,isThursday,isFriday,isSaturday :: Day -> Bool
05:36:43 <ski>   [isWednesday,isThursday,isFriday,isSaturday,isSunday,isMonday,isTuesday] = [isDay i | i <- [0 .. 6]]
05:36:50 <ski>     where
05:36:52 <ski>     isDay i day = toModifiedJulianDay day `mod` 7 == i
05:37:49 <cris_> thanks ski
05:38:07 <ertes> personally i wouldn't implement 'isSunday' etc. at all
05:40:07 <lordcirth> Yeah, just use day == 0
05:51:03 <cris_> lyxia: when i use $ cabal sdist  , it will auto create the /dist folder , how do i prevent it from upload to github?
05:52:00 <ertes> cris_: see: man gitignore
06:01:21 <Mike_G> Hi everyone! The question arose when I read sources of Data.Complex. Is it possible to rewrite GHC.<Something> to have type inference not only for integer and real literals, but also for complex ones? Eg (2 + J 3.0) should be (Fractional a => Complex a) and literal "2" be interpreted as (Fractional a => a). J here is type constructor of pure complex number (J x == 0+i*x). Correct me, if I'm knocked in a wrong door.
06:02:23 <ertes> Mike_G: instead of writing (2 + J 3.0) write (2 :+ 3.0)
06:02:48 <ertes> :t 2 :+ 3.0
06:02:50 <lambdabot> Fractional a => Complex a
06:03:13 <Mike_G> I know how to use Data.Complex module. The question is about rebuilding the prelude some way
06:03:45 <Mike_G> just a whim, but interested
06:04:03 <ertes> Mike_G: you could write a pattern synonym J for imaginary numbers, if you want
06:04:14 <ertes> @let pattern J x = 0 :+ x
06:04:16 <lambdabot>  .L.hs:167:9: error: Not in scope: data constructor ‘J’
06:04:26 <bennofs1> :t 2 + (0 :+ 1)
06:04:29 <lambdabot> RealFloat a => Complex a
06:04:38 <bennofs1> :t 2 + (0 :+ 3.0)
06:04:40 <lambdabot> RealFloat a => Complex a
06:05:23 <c_wraith> Mike_G: you could trivially write a data type that worked that way.  It just wouldn't be Data.Complex.Complex
06:05:25 <ertes> or even just a regular function 'i'
06:05:49 <cris_> hi ertes , i have added a .gitignore file to my repo folder , however, after i type $ git commit -am "commit 6" , and also push it again to github , the "dist" folder is still there
06:06:09 <c_wraith> cris_: wrong channel?
06:06:43 <c_wraith> oh, I guess it's related to working on a haskell package.
06:06:47 <ertes> cris_: gitignore doesn't apply to things that are already in the repo, so you need to commit its deletion first…  for more details, there is also a #git channel
06:06:55 <cris_> c_wraith : no , see this: https://github.com/szehk/Haskell-Carbonara-Library
06:07:27 <cris_> thanks
06:07:32 <bennofs1> why would addition of complex numbers require RealFloat? :o
06:07:42 <bennofs1> :t (+) `asAppliedTo` undefined :+ undefined
06:07:44 <lambdabot> RealFloat a => Complex a -> Complex a -> Complex a
06:08:24 <c_wraith> bennofs1: you don't get to apply constraints per-operation.  abs and signum require it, so everything in the class gets it
06:08:56 <bennofs1> c_wraith: oh, forgot that (+) was part of Num...
06:08:56 <ertes> > signum (1 :+ 1)
06:08:59 <lambdabot>  0.7071067811865475 :+ 0.7071067811865475
06:09:05 <ertes> > signum (5 :+ 5)
06:09:08 <lambdabot>  0.7071067811865475 :+ 0.7071067811865475
06:09:17 <ertes> bennofs1: it probably uses 'significand' or something
06:09:34 <c_wraith> there's a sqrt in signum
06:09:38 <c_wraith> :t sqrt
06:09:41 <lambdabot> Floating a => a -> a
06:10:13 <ertes> i could also imagine that it has a few isNaNs here and there
06:10:14 <Claudius1aximus> iirc it also does tricks with exponents to avoid overflow on intermediate values in abs
06:10:20 <c_wraith> Huh.  I can never recall what's in the various numeric classes
06:11:27 <ertes> c_wraith: Floating is like "we have operations that are typically floating-point", while RealFloat, as the name suggests, is: "we fully appreciate that we're floating point" =)
06:11:49 <c_wraith> Oh yes, a totally obvious distinction. :)
06:13:34 <ertes> Real is probably the weirdest class
06:13:37 <ertes> :t toRational
06:13:39 <lambdabot> Real a => a -> Rational
06:13:58 <c_wraith> most misnamed, at least :)
06:16:31 <Mike_G> Thank you. let j x = (0 :+ x) seems very elegant, but what if I wanted something low-level-built-in? E.g. 1+3.2i. Is there a way to make GHC read 3.2i as new complex type?
06:17:04 <Mike_G> and operate complexes globaly
06:17:21 <ski> > let i = 0 :+ 1 in 3.2*i
06:17:26 <lambdabot>  0.0 :+ 3.2
06:17:58 <Mike_G> not 3.2*i but 3.2i
06:18:16 <ski> i don't think so
06:18:45 <ertes> it has a plugin system, but now we're getting into over-engineered-and-less-familiar-to-haskellers territory
06:19:04 <ski> i suppose one could do some TH ..
06:19:13 <ertes> QQ
06:19:38 <Mike_G> i did dig into the GHC.Prim and found some magick hashes # which are seem suitable, but i understood nothing :)
06:21:27 <Mike_G> > [17:18] <ski> i suppose one could do some TH .. - TH?
06:21:32 <lambdabot>  <hint>:1:35: error: parse error on input ‘do’
06:21:43 <ski> Template Haskell
06:21:51 <ski> QuasiQuotation
06:22:36 <tdammers> hmm, I wonder what options there are to make a Haskell host application extensible with plugins at runtime
06:22:49 <Mike_G> Oh. It is not I wanted:) Idea was to rebuild prelude with complexes as general numeric type
06:23:28 <tdammers> so far, my ideas are either dynamically loading libraries with a known binary interface (ugh), or embedding an interpreter for some scripting language
06:24:00 <ski> with <https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#template-haskell-quasi-quotation>, one could probably be able to write something like `[cplx| 1+3.2i |]'
06:24:01 <tdammers> the latter seems more promising, especially since I'd want to be able to sandbox plugins somewhat
06:24:22 <ski> Mike_G : "rebuild prelude with complexes as general numeric type" means ?
06:24:25 <c_wraith> there's hslua for that sort of thing
06:25:25 <tdammers> c_wraith: hmm, yeah, unfortunately the scripting language would then be lua...
06:25:51 <c_wraith> there are far worse choices than lua
06:26:23 <Mike_G> ski, it means that I just wrote: constructions like 3+2.2i are native and handled without any :+ and so on
06:26:28 <tdammers> c_wraith: true
06:27:06 <c_wraith> Mike_G: you can do that if you create your own type.  nothing in prelude needs to change.
06:27:53 <c_wraith> Mike_G: but the ways of doing that are all kind of ugly hacks that end up being worse to work with than what already exists
06:27:54 <Mike_G> how to make GHC interpret 3.2i-like literals as unboxed type?
06:28:07 <c_wraith> literals aren't unboxed types
06:28:23 <Mike_G> they arent, yes
06:29:24 <ski> Mike_G : what you're asking for is more a custom concrete syntax, rather than anything that would have to be specially supported, internally so to speak, in libraries
06:30:39 <merijn> c_wraith: You can write unboxed literals in GHC
06:30:40 <ski> @type 3.2#  -- unboxed literal
06:30:43 <lambdabot> GHC.Prim.Float#
06:31:18 <c_wraith> but that's completely irrelevant to the question
06:34:11 <Reisen> Are there any Prelude imports that I can use that will filter out adjacent duplicates in a traversable?
06:34:34 <Mike_G> I just wonder, if it is possible. It seemed for me, because I figured out that there are built-ins like +# and all other operations are something on the top of *#. Also, do Prelude libs convert 3.2 into 3.2# in its interriors? In order to make machine +#
06:34:38 <merijn> Reisen: "map head . group", I think?
06:34:52 <byorgey> Reisen: no, because Traversables can't be filtered in general.
06:35:08 <merijn> oh, wait, for Traversable
06:35:24 <Reisen> Sorry, merijn that is indeed what I wanted, the traversable was my red herring, ignore that
06:35:25 <Reisen> Thank you
06:35:44 <byorgey> ah, ok, merijn guessed right =)
06:35:58 <Reisen> Yeah, my bad wrong terminology
06:36:02 <byorgey> no worries
06:36:30 <Reisen> Just out of interest though
06:36:39 <Reisen> Why can a traversable not in general be filtered? 
06:36:44 <codedmart> What is the best way to generate random alphanumeric string/text?
06:36:45 <Reisen> Now that It's been mentioned I'm curious
06:36:56 <ski> Mike_G : `3.2', of type `Float', is short for `F# 3.2#', in GHC
06:37:07 <codedmart> There seems to be much differing ways according to google search.
06:37:12 <byorgey> Reisen: because Traversable only lets you do something at each element but you have to keep the same shape.
06:37:26 <byorgey> Reisen: e.g. binary trees are Traversable, but what would it mean to "filter" a binary tree?
06:37:36 <Reisen> Ah, I guess that makes sense, in the sense you couldn't strip off a subtree and fix it without more context
06:37:40 <byorgey> right
06:37:45 <Reisen> Gotcha, seems obvious when put that way
06:37:46 <Reisen> Thanks
06:37:53 <byorgey> Reisen: however, there is http://hackage.haskell.org/package/witherable  ;-)
06:38:05 <merijn> byorgey: You've got work: https://github.com/diagrams/monoid-extras/pull/32 ;)
06:38:21 <byorgey> merijn: thanks =)
06:38:25 <Mike_G> ski : Oh, thank you. I still don't understand how it works and it's a source of my questions:)
06:38:27 <Reisen> byorgey, what fantastic function names
06:38:40 <Reisen> blightM
06:38:53 <byorgey> yes, haha =)
06:39:44 <byorgey> for more fantastic function names, see http://hackage.haskell.org/package/these
06:41:09 <ski> (in general, `3.2' is short for `fromRational 3.2', where `3.2' there is interpreted directly as a `Rational')
06:41:14 <Rodenbach> Is it possible to implement Show for a certain function?
06:41:30 <ski> (similarly, `3' is short for `fromInteger 3', with `3' there being an `Integer')
06:41:36 <byorgey> Rodenbach: what do you mean by "for a certain function"?
06:42:08 <Rodenbach> myAdd a b = a + b       I want to show   [myAdd, myAdd]
06:42:27 <Rodenbach> For this specific function I would like to implement Show. If that is possible.
06:42:32 <tdammers> it is technically possible to implement Show instances for functions, but they won't be lawful
06:42:43 <byorgey> Rodenbach: how would you want to show it?
06:43:24 <Rodenbach> byorgey: as the String   "<myAdd>"
06:43:33 <tdammers> the problem is that your show implementation cannot really look inside the function, because the only things you can do with function values is apply them, and pass them around
06:43:35 <byorgey> Rodenbach: no, that is not possible.
06:43:45 <ski> `myAdd' is indistinguishable from `(+)' itself
06:43:56 <tdammers> neither will give you the function name, nor the implementation details
06:44:07 <ski> function values don't carry around names
06:44:40 <ski> (just like a list like `[2,3,5,7]' doesn't know what names it may be known under, in different parts of the program)
06:44:41 <Rodenbach> I know about ghci’s   :m + Text.Show.Functions
06:44:59 <byorgey> Rodenbach: perhaps you might be interested in doing something like   data MyFunctions = MyAdd | MySub | ...    and then have a list of  [MyAdd, MyAdd]  which you can Show just fine.  Then define an interpreter   MyFunctions -> (Int -> Int -> Int)  or something like that
06:45:00 <Rodenbach> That’s not what I’m looking for. Okay, so I’ll work around it.
06:45:23 <Rodenbach> byorgey: possibly I will do this.
06:45:24 <tdammers> Rodenbach: why do you need this Show instance? What is the problem you are trying to solve?
06:45:45 <Rodenbach> tdammers: I am evolving Programs in a Genetic Programming system that I’m implementing.
06:45:46 <napping> ski: are you sure there's nothing interesting in the info table?
06:46:09 <max3> why doesn't everything derive Show by default?
06:46:19 <Rodenbach> tdammers: and it would be nice to see which functions are part of the genome.
06:46:21 * ski . o O ( `instance (Bounded a,Enum a,Show a,Show b) => Show (a -> b)' )
06:46:44 <napping> Rodenbach: then you will need your own type of syntax trees to actually do the mutuataions
06:46:47 <byorgey> Rodenbach: yes, in that case, I think you almost certainly want to define a data type representing the abstract syntax of your programs, rather than representing them directly as functions
06:46:50 <napping> and those can be Show no problem
06:46:51 <ski> max3 : not everything can be made an instance of `Show' (in a sensible fashion)
06:47:12 <Rodenbach> Oki.
06:47:27 <max3> ski, at worst you could have a memory address
06:47:43 <merijn> max3: You assume functions HAVE a memory address
06:47:54 <byorgey> max3: but the spirit of Show is that it should produce valid Haskell expressions, which could be pasted into ghci
06:48:02 <ski> napping : are info tables in the report ?
06:48:13 <merijn> byorgey: Even if you throw out that assumption it's hard to do sensibly
06:48:21 <Mike_G> Is it possible to make GHC interpret `3.2i' as a value of some new type without Template Haskell?
06:48:28 <byorgey> merijn: oh, I agree
06:48:33 <merijn> Mike_G: If you wrap it in a quasi quoter, yes
06:48:36 <napping> ski: they may be in your implementation
06:48:44 <max3> merijn, ...where else would they exist?
06:49:04 <merijn> max3: Deeply inlined and specialised
06:49:12 <ski> max3 : they could be fused, or otherwise partially evaluated, away
06:49:17 <napping> you didn't say anything about standard
06:49:21 <mbw> I have a question about Bifunctors (and maybe Profunctors). According to the lens tutorial on wikibooks, the Const functor is a "vacuous" functor, since both fmap and contramap amount to id. However you can define a Bifunctor instance, of which bimap/first allow applying altering the Const functor: http://lpaste.net/353288 . Is bimap something entirely different than fmap/contramap? Is there some intuition 
06:49:23 <merijn> max3: The fact that you define a function 'foo', doesn't require such a function to actually exist after compilation
06:49:27 <mbw> behind this?
06:49:35 <merijn> max3: If all uses of 'foo' have been inlined directly in the calling code, then what?
06:49:44 <napping> max3: more simply, the GC can move things so it's trickty to have "A" address
06:50:05 <merijn> napping: That's the fun that gives us "reallyUnsafePtrEquality#" ;)
06:50:14 <max3> fine. excepting functions 
06:50:23 <napping> merijn: precisely!
06:50:32 <merijn> Which honestly isn't nearly as scarily named as it oughta be
06:50:36 <napping> well, maybe some unsafeCoerce and pointer arithmetic too
06:51:05 <merijn> It's up there with accursedUnutterablePerformIO in terms of scariest functions :p
06:51:13 <byorgey> mbw: bimap is closely related to fmap.  I'm not sure I really understand your question.  In particular I don't understand your use of the word 'However'.  The existence of a Bifunctor instance doesn't contradict the existence of Functor etc. instances
06:51:41 <ski> mbw : `Functor' is for functors from `Hask' to `Hask'. `Contravariant' is for functors from `Hask^op' to `Hask'. `Bifunctor' is for functors from `Hask * Hask' to `Hask'
06:51:42 <tdammers> Rodenbach: then I'd go with byorgey's suggestion... encode the possible programs in an AST, and write an interpreter for it
06:51:42 <merijn> max3: Well, for almost all non-functions you can derive Show easily enough. There's some exceptions which are a bit tricky, such as Handle, MVar, TVar, etc.
06:52:18 <max3> merijn, okay so why isn't it done by default is my poitn
06:52:22 <byorgey> merijn: note that every Bifunctor is necessarily also a Functor, since you can just pass 'id' as the first argument to bimap
06:52:35 <byorgey> sorry, that was meant for mbw 
06:52:50 <merijn> mbw: Note that (assuming you're familiar with kind signatures) you have "Bifunctor :: (* -> * -> *) -> Constraint"
06:53:01 <merijn> Vs "Functor :: (* -> *) -> Constraint"
06:53:11 <napping> max3: there's also no syntax for asking not to derive something
06:53:35 <Mike_G> :( The idea was to somehow modify prelude and make complexes available everywhere, in all libraries. (Missusage of /r)
06:53:42 <max3> napping, that doesn't sound like a real impediment 
06:53:58 <ski> sometimes you don't want a derived `Show' instance
06:54:04 <merijn> max3: Maybe library authors don't want to expose their implementation?
06:54:16 <Rodenbach> lol, it’s the first time that I’ve done refactoring in Haskell. Changing the program to show function names took me 50 secs.
06:54:24 <byorgey> Rodenbach: =D
06:54:25 <Rodenbach> Funny, the compiler showed me all places that I had to update.
06:54:28 <mbw> hmm
06:54:46 <byorgey> Rodenbach: yes, that is a very common experience when refactoring
06:54:47 <merijn> Rodenbach: Yes, refactoring with Haskell is really nice :)
06:54:49 <mbw> Is there some law that relates fmap to bimap then?
06:54:49 <c_wraith> Rodenbach: it's almost like that's what Haskell is best at.  Handling changing requirements.
06:55:01 <lyxia> Mike_G: Let's be creative with syntax and make a function i to write (i 3.2)
06:55:09 <byorgey> mbw: fmap = bimap id
06:55:10 <c_wraith> mbw: bimap id f = fmap f
06:55:14 <ski> sometimes you want to write your own, e.g. generating a string representation of an expression evaluating (in the appropriate environment) to a value equivalent to the given one, but not expressed in terms of data constructors, but rather in terms of the exported abstract operations of the module
06:55:33 <c_wraith> I typed it slower because I eta-expanded it! :)
06:55:48 <mbw> ah
06:55:51 <mbw> so bimap = second
06:55:55 <napping> max3: it's not huge, but "deriving Show" is pretty short and there are hardly any other classes that might make sense by default
06:56:00 <mbw> no
06:56:05 <Mike_G> lyxia, already. I use it in my every project with complex numbers, but wanted...:)
06:56:11 <ski> lyxia : ertes suggested that already :)
06:56:13 <mbw> fmap
06:56:23 <lyxia> haha okay
06:56:25 <merijn> mbw: Pretty much
06:56:30 <max3> napping, the problem is adding it after the fact
06:56:30 <tdammers> Rodenbach: now you're spoiled for mainstream languages forever. You're welcome.
06:56:34 <napping> max3: as well as plenty of good reasons not to derive Show, like if you want to write your own, or hide implementation details
06:56:47 <napping> ah, do you know StandaloneDeriving extension?
06:56:55 <max3> no i do not
06:57:16 <napping> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#stand-alone-deriving-declarations
06:57:37 <tdammers> note however that typical uses of standalone deriving create orphan instances
06:57:37 <napping> If you can actually see the entire definition of a type, you can derive stuff later
06:57:42 <mbw> This probably also explains why I can't define contramap in terms of fmap in case of Const, although the implementations look pretty much the same.
06:58:05 <byorgey> merijn: your PR has some kind of conflict?
06:58:27 <merijn> byorgey: It does? I didn't pull from master before submitting it. Lemme check
06:58:42 <mbw> Ok, thanks for clearing things up.
06:58:53 <max3> napping, so the value of this is i can put this in a different place than the definition of the type?
06:59:01 <merijn> byorgey: Oh!
06:59:17 <merijn> byorgey: Yeah, you added documentation comments, which are missing because I didn't update from master
06:59:21 <napping> well, if you want a Show instance for convenience for some type that didn't provide it (your "after the fact")
06:59:25 <byorgey> merijn: ah, I see
06:59:47 <napping> then you can write "deriving instance Show SomeLib.Type
06:59:57 <byorgey> merijn: aren't you the one who wanted me to add those comments? ;-)
07:00:16 <merijn> byorgey: Yes, but I never bothered to pull after writing that initial code :p
07:00:22 <napping> hmm, intero doesn't work with fltkhs?
07:00:27 <merijn> But, apparently I can resolve conflicts on the web
07:00:30 <byorgey> woah, the PR page on github just magically turned green while I was looking at it
07:00:39 <max3> napping, okay but i still have to write it somewhere
07:00:43 <napping> yes
07:01:02 <napping> is that a problem?
07:01:20 <merijn> byorgey: Yeah, I just used the web UI to resolve the conflict in the online editor and then it's just AJAX fanciness
07:02:03 <napping> depending what you want, the :print / :sprint in GHCi might be better
07:02:06 <merijn> The web UI seems to have nuked the trailing newline, not sure if that's important?
07:02:37 <byorgey> merijn: nah, I don't really care about trailing newlines
07:02:50 <byorgey> merijn: thanks again
07:03:00 <Mike_G> Also, the questions of perfomance(eg compared to python) of these complex numbers(3+3*(0:+1)) are not clear.
07:04:28 <merijn> Mike_G: I'm pretty confident in saying that "Haskell complex numbers are probably in cases that don't include numpy, faster than python complex numbers"
07:04:36 <merijn> By like, a large margin
07:05:00 <Mike_G> i meant NumPy.
07:05:17 <merijn> Then "it depends"
07:05:31 <merijn> Because I dunno how numpy works
07:06:08 <shapr> numpy wraps a bunch of C and FORTRAN libs
07:08:57 <Mike_G> It's not clear, then. I have 10^4x10^4 array of complexes to be processed (eg matrix exp). I don't have haskell installed now, but will check prefomance later. If NumPy win, unfortunately I will have to use python instead of haskell :(
07:09:09 <max3> refactoring might be a joy but debugging is the biggest pain i've ever experienced
07:09:25 <byorgey> Mike_G: how are you planning to represent and process the matrix in Haskell?
07:09:30 <tdammers> max3: nah, you just need to use different techniques
07:09:40 <shapr> max3: your project is 'special' in that way
07:09:43 <merijn> Mike_G: Just use hblas?
07:09:49 <Mike_G> Array of complex, suppose
07:09:56 <merijn> Mike_G: That wraps the same C/FORTRAN libraries that NumPy uses :p
07:10:08 <tdammers> max3: step debugging Haskell is a lousy experience, but type checks, assertions, unit tests, property tests, etc., are a lot more powerful in Haskell than in, say, JavaScript
07:10:15 <Mike_G> thanks, will google hblas
07:10:23 <shapr> max3: have you learned about quickcheck?
07:10:31 <byorgey> Mike_G: yeah, I would use the hblas/hmatrix
07:10:50 <merijn> Honestly, debugging haskell isn't THAT much more of a pain than other languages. Biggest issue for me is parsers
07:10:55 <merijn> The rest is pretty easy
07:11:10 <merijn> max3: What's the biggest issue you have with debugging?
07:11:37 <merijn> @quote refreshing.desert
07:11:37 <lambdabot> chromatic says: My productivity increased when Autrijus told me about Haskell's trace function. He called it a refreshing desert in the oasis of referential transparency.
07:11:56 <max3> yes i'm familiar with trace
07:12:07 <max3> especially traceShowM
07:12:39 <max3> this morning it was getting absolutely any kind of signal for why something was failing - i had to add show all the way down the chain of data types
07:12:49 <max3> *i had to derive show
07:12:56 <mbw> trace should've been called kernighan
07:13:20 <max3> tdammers, writing more code to debug existing code seems very counterintuitive to me
07:13:55 <tdammers> max3: the advantage of that extra code you write is that you can repeat the debugging
07:14:31 <mbw> Is there a way to "compile out" traces, like assertions?
07:14:52 <max3> in the spirit of haskell i feel like i can generalize that claim to: the advantage of that ____ you write is that you can repeat the _____
07:14:58 <tdammers> max3: but in this case, I reckon a better strategy would have been either better types, or better unit tests
07:15:37 <tdammers> max3: and yes, that's a very familiar thought - haskell is big on abstractions and automating yourself away without mercy
07:15:51 <max3> yes i know - that's the joke
07:17:58 <Mike_G> Does hmatrix(or hblas) works with arbitrary dimensional complex-valued tensors?
07:20:24 <mbw> I believe Blas3 only includes routines working on matrices.
07:21:47 <mbw> Blas routines are defined roughly like this: Blas1: vector x vector -> _, Blas2: matrix x vector -> _, Blas3: matrix x matrix -> _
07:23:18 <Mike_G> unsuitable :( wanna smth matlab-like
07:23:54 <mbw> I believe Eigen (C++) can work with arbitrary-dimensional tensors by now.
07:24:23 <Mike_G> are there haskell bindings?
07:25:05 <Mike_G> yes^
07:26:12 <mbw> A quick search came up with this https://www.cs.utexas.edu/users/flame/BLISRetreat2015/slides/Devin_BLISRetreat_2015.pdf
07:26:24 <mbw> Might be something in terms of "things to search for"
07:27:21 <mbw> But I am amazed there are Haskell bindings, since Eigen relies heavily on Template Metaprogramming / Expression Templates (compile-time voodoo).
07:31:17 <max3> is there a way to upgrade a package using stack?
07:32:39 <mbw> max3: It should suffice to specify a more current resolver and rebuild, I think.
07:35:04 <jchia_> lens-aeson question. I have a JSON string x = "{\"a\": {\"b\": 1, \"c\": 2}}". I want to extract the list of keys under the top-level "a" key from it, i.e. (Just ["b", "c"] :: Maybe [Text]). How do I do it with lens-aeson? I know how to get a Maybe (HashMap Text Value) using (x ^? key "a" . _Object).
07:45:28 <kuribas> Do you guys search for haskell jobs, or are you happy with C#/Java/C++/Python/Ruby/whatever...?
07:45:58 <shapr> kuribas: I search for Haskell jobs :-P
07:46:13 <kuribas> shapr: did you find them?
07:46:18 <Mike_G> I search, but I'm kinda noob.
07:46:21 <merijn> kuribas: Out of all those only C++ would be marginally acceptable, if it was interesting
07:46:30 <merijn> kuribas: Depends, are you willing to move?
07:46:36 <srk> hehe, I don't search for jobs but I'm also not happy with python anymore :D
07:46:39 <kuribas> merijn: prefer not to...
07:46:57 <kuribas> merijn: I see that there are some jobs in Berlin, that's not too far...
07:47:06 <merijn> kuribas: London?
07:47:15 <kuribas> possibly
07:47:17 <merijn> kuribas: Bunch of banks in London recruiting Haskellers
07:47:23 <Mike_G> There was a haskell vacancy in Singapore 
07:47:27 <merijn> Standard Chartered is also always looking for people in Singapore
07:48:11 <merijn> In London there's Standard Chartered (but, they mostly want people in Singapore, I think?), Barclays is looking for Haskell people (at least, I got emailed about them looking for people to start a Haskell team)
07:48:25 <merijn> Jane Street has an office in London too. It's not Haskell, but ocaml is close enough
07:48:40 <kuribas> merijn: yeah C++ would be ok also...
07:48:59 <kuribas> merijn: But I don't think C++ is good for large scale application development.
07:49:00 <shapr> kuribas: I find 'em, but I need to improve my Haskillz
07:49:20 <kuribas> shapr: you learn as you do it?
07:50:15 <shapr> kuribas: I'm also working at a place that has the best bunch of coworkers I've had, so it's hard to leave.
07:50:27 <kuribas> shapr: what language?
07:50:39 <shapr> Python/Ruby/Go :-/
07:50:59 <shapr> but 1. awesome people 2. company is not spam/military/porn 3. company has funding
07:51:14 <kuribas> shapr: better than Java
07:51:22 <lyxia> jchia_: key "a" . _Object . to HashMap.keys
07:51:40 <shapr> kuribas: yeah, we have some Java code, but I've not had to deal with that.
07:51:51 <shapr> Also, we do some network protocol parsing and I really enjoy that
07:52:22 <kuribas> Aren't there libs for that?
07:52:32 <shapr> not for what we do
07:53:05 <srk> shapr: it's awesome with haskell ;)
07:53:09 <srk> networking/parsing
07:53:13 <srk> protocols
07:53:39 <merijn> kuribas: As for finding jobs, are you on haskell-cafe? Are you on /r/haskell? Are you haskellers.com? Do you follow people on twitter?
07:54:06 * kuribas never used twitter
07:54:21 <shapr> srk: Have you done it? I'd like to write some utility (non-production) code in Haskell, but I HaNS and network-house don't have any SIP support
07:54:25 <merijn> I see job announcements on -cafe and r/haskell semi-regularly. I've been approached via haskellers.com a few times. dons and some other big community people also retweet job openings
07:54:34 <eacameron> I read somewhere that enabling TemplateHaskell for a file means that you must define top-level declarations in dependency order (like in C or Python). Can anyone confirm?
07:54:42 <shapr> What I really want/need is something like scapy in Haskell, where I can load up a pcap, edit the packets, and write out a new pcap.
07:54:48 <merijn> eacameron: Not afaik?
07:55:13 <srk> shapr: I've really enjoyed implementing ZRE recently, hand parsing/packing binary data is very easy - https://git.48.io/zre/blob/master/f/src/Data/ZRE.hs
07:55:44 <kuribas> eacameron: yeah, the order matters.
07:56:04 <napping> eacameron: Sort of - it's not full ordering, just that definitions before a top-level splice don't see definitions after
07:56:06 <eacameron> kuribas: Is that for all declarations or just ones involving TH somehow?
07:56:24 <shapr> srk: oh that's cool!
07:56:46 <jchia_> lyxia: Thanks!
07:56:51 <kuribas> eacameron: I defined some lenses, and I got a strange error message because of the order.
07:57:15 <kuribas> eacameron: only the ones involving TH, or depending on them.
07:57:15 <lyxia> eacameron: toplevel invocations of TH separate definitions, so that those before the invocation don't see those after.
07:58:01 <srk> shapr: it started as a side project to learn networking/protocol parsing and now it's almost production ready :D
07:58:03 <eacameron> kuribas: lyxia: interesting. Does that apply to QuasiQuotes too?
07:58:17 <eacameron> kuribas: lyxia: I.e. *not* using TemplateHaskell extension directly
07:58:51 <kuribas> eacameron: Then it doesn't matter I think...
07:59:59 <napping> eacameron: "Unlike normal declaration splices of the form $(...), declaration quasi-quotes do not cause a declaration group break."
08:00:04 <napping> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#ghc-flag--XQuasiQuotes
08:00:22 <eacameron> napping: Aha! That's the documentation I was looking for!
08:01:27 <napping> But doesn't the Q [Dec] let it inspect the environment?
08:05:54 <lyxia> it does
08:18:43 <napping> so what environment does the quasiquote see?
08:20:22 <Mugwump_> hi everyone :)
08:21:09 <Mugwump_> I wanted to ask something, I heard that Real World Haskell is outdated. Does learn you a haskell is the way to go for learning haskell ?
08:22:29 <Theophane> Mugwump_: they don't server the same purpose
08:22:48 <Theophane> let me find which book I started with
08:23:42 <byorgey> Mugwump_: you might be interested in https://github.com/bitemyapp/learnhaskell/blob/master/README.md
08:23:53 <Theophane> yeah, good link byorgey :)
08:24:01 <Theophane> I think I started with the wikibook
08:24:07 <Theophane> then the Moronuki
08:24:42 <Theophane> and I'm looking forward her 2nd co-book 
08:25:00 <Mugwump_> Ok !
08:25:08 <Mugwump_> Thanks you a lot !
08:25:33 <lyxia> napping: it sees the bindings above itself
08:25:43 <cocreature> real world haskell is still a useful book despite being outdated. but I wouldn’t recommend it as the first book you read
08:27:31 <teto> beginner here, why wouldn't this work  lookForFirstOption :: [String] -> [String]
08:27:33 <teto> lookForFirstOption rlines = return rlines
08:27:53 <merijn> teto: return does NOT do what you think :)
08:28:06 <merijn> teto: Return is 1) not a keyword and 2) not the way functions return values
08:28:49 <merijn> teto: If you wanted a function the immediately returned it's argument, you'd write "lookForFirstOption rlines = rlines"
08:30:44 <teto> merijn: ok thanks got it working, I read the tutorials 2 months ago, then couldn't practice.thanks i got it working
08:35:05 <mbw> I have written a little project, which 1. Probably contains a lot of dead code, and 2. is unnecessarily distributed over 5 modules, where maybe 1-2 would have sufficed. So I want to really shrink it down. What is the most practical way of getting rid of dead code? Explicit module import lists, or do I need explicit export lists as well?
08:35:38 <mbw> Or is there some convenience option for ghc/stack?
08:36:11 <bennofs1> mbw: i think explicit export lists would be enough, no need for explict import lists
08:36:22 <bennofs1> mbw: then ghc's warnings should tell you which functions are unused
08:38:02 <mbw> Ok, I'll try that.
08:38:09 <merijn> mbw: If you compile with -Wall and use explicit export lists for modules you should get warnings
08:40:16 <Mugwump_> So if I'm installing stack, I can't use the cabal packages ?
08:40:17 <mbw> Also, I have some expressions which look like "reduceTerm (TermPD g p d) = TermPD g <$> reduceElement p <*> reduceDiracDelta d", all of which are of type a -> Maybe a. While I could introduce a Reducible class or something, I feel like such a simple pattern should already exists, no?
08:40:18 <mbw> *exist
08:44:25 <byorgey> Mugwump_: no, stack explicitly works with cabal packages
08:47:29 <lyxia> mbw: this is a bit like recursion-schemes, though I'm not sure whether it handles mutually recursive types well.
08:50:47 <mbw> I'll just go with the most obvious solution, without trying to be fancy.
08:54:15 <bobsonu> There's a lot of spam on https://www.haskell.org/news as a result of subscribing to Haskell-Cafe. Who can I report this to?
08:55:41 <lyxia> bobsonu: there's a link to https://github.com/haskell-infra/hl at the bottom
08:56:16 <lyxia> https://github.com/haskell-infra/hl/issues/204
08:57:35 <bobsonu> lyxia: Thanks.
08:58:18 <lyxia> yw
08:59:36 <tabaqui1> is there any lib provided low-level select/poll functions
08:59:45 <tabaqui1> except of epoll and async
09:00:16 <tabaqui1> async based on threaded and gain no additional speed
09:00:46 <tabaqui1> epoll looks suspicios because of short history
09:00:53 <tabaqui1> *suspicious
09:04:50 <ertes> TIL: if Integer is not possible, haskell defaults to Double
09:06:37 <mbw> Ok I tried finding dead code with explicit export lists, and recompiling with Weverything. However, not a single unused-warning came out of that...
09:06:38 <Squarism> can i set requirements on a type class type member?
09:07:31 <tabaqui1> Squarism: usually you don't need it, but you can look at gadt
09:08:23 <tabaqui1> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#datatype-promotion
09:08:30 <Squarism> like : class MyClass a ; type SomeType a deriving (Eq) 
09:08:40 <Squarism> oh forgot where
09:09:00 <tabaqui1> ehm, what do you want?
09:09:30 <mbw> Wait, I probably did it wrong.
09:09:33 <Squarism> That "SomeType a" derives Eq
09:10:21 <mbw> Does finding dead code only work if I export only used functions? That would require me to know which functions are used, and which not, in the first place ...
09:12:14 <glguy> If everything is exported, then everything is used
09:14:19 <mbw> oh man
09:14:53 <mbw> Than it would be more sensible to start with an empty import list, fill it as required and make an export list out of it...
09:15:00 <mbw> This should be automated.
09:24:13 <glguy> Squarism: class Eq (SomeType a) => MyClass a
09:24:45 <Squarism> glguy, oh ok thanks
09:25:06 <EvanR> mbw: there are some IDE plugins that manage that stuff for you
09:25:31 <napping> mbw: there's -ddump-minimal-imports
09:30:49 <mbw> That seems helpful. Manually managing import/export lists seems like a n^2 problem.
09:52:42 <Squarism> if class "Cls z" defines type "MemType z" if i somewhere have a function "f" that takes a type argument "y" that requires a Cls instance. Ie "f :: (Cls b) => b -> Int" . Can i use (MemType b) in the arguments list of f?
09:53:07 <Squarism> ops.. "." after "MemType z"
09:54:41 <Squarism> Something along the lines of :  "f :: (Cls b) => b -> *MemType b* -> Int"
09:55:06 <Squarism> *...* to show idk how to write it
09:56:54 <glguy> What happened when you tried?
10:00:00 <Squarism> "Cls b" defines a method "gimmeMemType :: ... -> MemType b". Compiler complains theres 2 variants of MemType b ( MemType b and MemType b1) around - so cant do operations between them
10:00:29 <Squarism> i tried google i promise
10:00:41 <Forkk> It seems like my ghc is taking an unusually long time compiling, and using more cpu than usual.
10:00:56 <Forkk> I used to be able to compile the entire codebase in the time it takes to compile a single module
10:00:58 <glguy> Squarism: Put your code and error message on lpaste then
10:04:05 <Squarism> Yes i know, my code is horrible - but im learning. http://lpaste.net/353292
10:05:51 <glguy> Squarism: incidentally, Ord (PlayerPos a) implies Eq (PlayerPos a)
10:05:52 <Squarism> Line 140 (in file) == 36 in paste
10:06:25 <Squarism> oh ok
10:09:34 <glguy> Squarism: It's going to be hard to guess since you didn't include many definitions or types. There are two issues to understand with a line like this, however:
10:09:34 <glguy> let faction = ((toPos _gc_gp gc) (_p_faction p)) :: (PlayerPos a)
10:09:55 <glguy> you're saying that faction has the type 'forall a. PlayerPos a'
10:10:18 <suica> has anyone read this post? https://lukepalmer.wordpress.com/2008/05/02/enumerating-a-context-free-language/ the core of it seems to be this function (http://lpaste.net/353293) but I'm seriously struggling to figure out what it's doing
10:10:20 <glguy> 1, that's probably not what you meant and also 2, it won't work if you did meant that because PlayerPos being a type family
10:10:31 <glguy> you won't be able to determine what type 'a' ever is
10:11:16 <glguy> Squarism: Maybe you thought that the 'a' there were the same as the one in the type signature for doEndgame? In that case you'll need to enable ScopedTypeVariables, and add explicit forall a  the the type signature that introduces a
10:12:09 <Squarism> glguy, Yes i thats what i hoped. Thanks for the advice. Ill work on that
10:14:27 <Squarism> glguy, thanks for your advice. Now it works
10:30:17 <kuba-orlik> Hi! I'm trying to create a simple recursive function in Haskel, with two "special cases". Here's what I started with and had already failed: http://pastebin.com/rVCQPj5F  What am I doing wrong?
10:31:16 <byorgey> kuba-orlik: you can't define a function by cases by writing each case on a separate line at the ghci prompt.
10:31:30 <byorgey> kuba-orlik: your second line actually completely redefined a.
10:31:44 <byorgey> kuba-orlik: just put the first two lines in a .hs file and then :load it into ghci.
10:33:07 <kuba-orlik> byorgey: thank you!
10:33:11 <byorgey> sure!
10:36:05 <codedmart> I am seeing this error every so often in development. Doesn't seem to cause problems in production as far as I can tell. `Left thread blocked indefinitely in an MVar operation`. This is a servant api I have been working on. I know this is vague but any initial ideas where to look?
10:38:33 <napping> is "Left" the name of a thread?
10:38:39 <dolio> I don't know servant, but that is GHC detecting some sort of deadlock.
10:38:46 <napping> or an Either constructor?
10:39:01 <dolio> Either threads blocking on each other, or a thread blocking on an empty mvar that's been garbage collected, or something along those lines.
10:39:57 <napping> It sounds like you're catching the exception somehow - it's Control.Exception.BlockedIndefinitelyOnMVar
10:40:00 <dolio> Maybe the way you're setting up your dev environment leads to this.
10:44:15 <sena_kun> hi, guys. I want to quickly start an openshift(redhat's paas) cartridge with haskell(scotty, to be precise), but https://wiki.haskell.org/Web/Cloud#OpenShift - links from here are dead and hence I cannot. What is the current practice of openshift+haskell usage, do I need to set up everything from scratch?
10:46:33 <sena_kun> I mean links to manifests, i.e. https://jenkins-accursoft.rhcloud.com/userContent/scotty.yml
10:49:54 <Forkk> is it possible to profile C code called from haskell? I added -pg to c-options, but it didn't seem to do anything
10:50:42 <novakboskov> what is ".." within constructor in pattern matching and how it's differ from "_"?
10:52:02 <geekosaur> Forkk, you'd need to rebuild ghc with C profiling enabled
10:52:02 <byorgey> novakboskov: I'm not sure what you're referring to, can you give an example?
10:52:07 <davean> Forkk: I don't know a good answer to your question (I've never looked) but you can definately do it with something like oprofile
10:52:21 <Forkk> geekosaur: as in recompile ghc?
10:52:44 <geekosaur> since part of it is implemented by syscalls made by the profiling C runtime
10:53:21 <sena_kun> novakboskov, if you mean something like "Person{..}", then it is an extension. See https://ocharles.org.uk/blog/posts/2014-12-04-record-wildcards.html
10:53:33 <novakboskov> byorgey: for example "tag (Leaf  ..)       = 1" from http://apfelmus.nfshost.com/articles/monoid-fingertree.html
10:54:38 <byorgey> novakboskov: hmm, that is either a typo or it is supposed to indicate that something has been left out.  It is not valid Haskell.
10:54:55 <geekosaur> that is metasyntax, as I read it
10:55:22 <byorgey> yeah, I think you're right.  It means "some other stuff goes here but it doesn't matter what it is"
10:55:26 <geekosaur> as byorgey says, means they left something irrelevant out
10:55:45 <novakboskov> sena_kun: It doesn't look like that but I'll take a look at post
10:56:19 <sena_kun> novakboskov, nope, my answer is incorrect then. :) Please refer to what others said.
10:56:55 <Forkk> so how would one enable C profiling in ghc
10:57:16 <geekosaur> I don't know, since ghc's build system is fairly complex
10:58:01 <novakboskov> byorgey: Thanks! :)
10:58:22 <byorgey> novakboskov: sure!
10:58:31 <byorgey> novakboskov: that is a really cool article, hope you're enjoying it =)
10:58:47 <geekosaur> also I suspect compiled Haskell code will confuse most C profilers, since part of the work is done by profile(3) (profile(2) on non-Linux Unixlikes) and can't distinguish the two
11:00:34 <geekosaur> hm, actually BSDs /OS X look to do something completely different, likely dtrace-related. even more fun.
11:07:36 <kuribas> geekosaur: You want to profile which c functions the c code calls?
11:07:56 <mniip> Cale: *wave*
11:08:11 <kuribas> erm Forkk, not geekosaur 
11:08:12 <Cale> Hey mniip, thanks!
11:08:46 <Cale> I don't know why Sigyn hates me lately.
11:08:46 <Forkk> all I want to profile is my own C code
11:09:17 <Forkk> with the complication that it's not standalone, since it was written to speed up part of a haskell program
11:10:24 <kuribas> Forkk: Could you profile in without haskell?  Perhaps extracting the important bits?
11:10:59 <Forkk> not without writing lots of code
11:11:25 <Forkk> the C code is a virtual machine for a programming language that's mostly implemented in haskell
11:11:53 <Forkk> there's no way of serializing the "bytecode"
11:12:58 <kuribas> why not?
11:24:21 <mniip> Cale, no idea
11:40:31 <kuribas> It seems returning a tuple is quite bad for numerical code.
11:41:05 <kuribas> because haskell holds on to unevaluated thunks.
11:42:42 <napping> are you compiling with optimizations?
11:43:04 <blackdog> kuribas: could make it a strict tuple, a la https://hackage.haskell.org/package/strict-0.3.2/docs/Data-Strict-Tuple.html ?
11:43:46 <kuribas> napping: yes
11:43:56 <Cale> Or just make sure that you cause the evaluation of the parts to happen before forming the pair
11:44:00 <kuribas> blackdog: yeah, now I use `seq`,which works also.
11:44:04 <Cale> yeah
11:44:18 <napping> If the tuple is immediately used by the caller it should be optimized away pretty well
11:44:33 <sternmull> Forkk: Have you tried CodeXL Intel Prallel Studio or something like that? As long as your C code is compiled with debug symbols it should not matter if it is called from haskell or something else.
11:44:37 <kuribas> napping: only if inlined...
11:45:07 <napping> There's also unpacked tuples, but I'm not sure what triggers that
11:45:43 <m4lvin[m]> deleting or overwriting a candidate on hackage seems broken, can someone help?
11:46:02 <shapr> Forkk: make a quickcheck instance for your bytecode, or run it with smallcheck or something?
11:46:04 <Forkk> sternmull: well I'm running Linux, so I don't know if I can use that
11:46:17 <Cale> m4lvin[m]: I probably can't help, but what's going on?
11:46:27 <sternmull> Forkk: Of course. Both are cross platform.
11:47:11 <m4lvin[m]> i uploaded https://hackage.haskell.org/package/HasCacBDD-0.1.0.0/candidate
11:47:39 <m4lvin[m]> now i tried to fix that warning, but it ignores the new tar.gz that i upload
11:48:05 <m4lvin[m]> which is strange, because i did replace the candidate before and then it worked
11:48:06 <ertes> kuribas: you get the best performance by using a strict, monomorphic tuple type
11:48:12 <Cale> Do you see that maintain link at the top?
11:48:26 <Cale> Do those options work for you?
11:48:39 <kuribas> ertes: ok.  What do you recommend?
11:48:39 <ertes> kuribas: alternatively you can use CPS with appropriate inlining
11:48:50 <Cale> Or is that specifically what's not working? :)
11:48:53 <sternmull> Forkk: For a rough idea what takes the most time it often helps to just manually pause the process with gdb and see what is executed at the moment. If you have code that eats 90% of your execution time then you probably will be in this stacktrace.
11:49:10 <kuribas> ertes: unboxed tuples?
11:49:11 <Forkk> fair enough
11:49:23 <m4lvin[m]> yes, and there is a delete link but if i use that button it says package not found, No such package in package index
11:49:32 <ertes> kuribas: strict, monomorphic tuples are unboxed by default in recent GHCs
11:49:59 <Forkk> I'll probably just do that then, since it seems easiest lol
11:50:03 <ertes> unfortunately polymorphic tuples don't seem to work for that, even if the type is statically known
11:50:14 <ertes> which is really unfortunate =)
11:50:16 <dolio> I don't think that's accurate.
11:50:22 <sternmull> its the poor mans sampling profiler :)
11:50:52 <dolio> Unless there have been regressions.
11:51:14 <Cale> m4lvin[m]: If all else fails, probably uploading a new candidate with a different version number will work -- I would hope. But maybe someone closer to the hackage project will have a better idea.
11:52:53 <m4lvin[m]> Cale: ok, I might try that later. I was hoping to avoid bumping the number already before my first release and thought candidates are a safe playground ;-)
11:53:20 <ertes> dolio: talking to me?
11:55:10 <dolio> Yeah. Polymorphic tuples get turned into unboxed tuples.
11:56:51 <ertes> dolio: does that also happen for product types in general?
11:57:14 <dolio> Probably.
11:57:44 <dolio> I guess what might not work is having the contents of those tuples get unboxed.
11:58:40 <ertes> dolio: i'll see if i can verify that, because cocreature made me aware that types as those in the 'linear' package (data V2 a = V2 !a !a) don't get unboxed in general, and a benchmark actually confirmed it
11:59:13 <Cale> m4lvin[m]: I thought so too...
11:59:27 <Cale> m4lvin[m]: Seems odd that you can't just delete it and upload another -- perhaps a bug
12:01:05 <cocreature> ertes: I’m more than happy to be proven wrong here :)
12:01:09 <dolio> ertes: Anyhow, there's a worker-wrapper transform that turns an (a,b) return into an (# a, b #) return and a wrapper from (# a, b #) into (a,b). Then if the wrapper gets inlined it can disappear.
12:01:18 <m4lvin[m]> seems it just does not get deleted, i can still download the tar.gz again ;-)
12:01:48 <dolio> The problem is then that there's no further worker-wrapper that will unbox a and b.
12:01:58 <mbw> > sortOn length [[1..5], [1..4], [1..3]]
12:02:01 <dolio> ertes: Maybe the bangs interfere with that worker-wrapper transform. Not sure.
12:02:01 <lambdabot>  [[1,2,3],[1,2,3,4],[1,2,3,4,5]]
12:02:22 <mbw> How can I do this "the other way round", without applying reverse?
12:05:01 <lyxia> > sortOn (Down . length) [[1..3], [1..4], [1..5]]
12:05:01 <ertes> dolio: yeah, that sounds reasonable…  i wonder if regular non-strict fields would be better, at least for use-cases like most of mine, where i store multiple V2s in an unboxed vector rather than some other structure
12:05:05 <lambdabot>  [[1,2,3,4,5],[1,2,3,4],[1,2,3]]
12:05:20 <kuribas> :t Down
12:05:23 <lambdabot> a -> Down a
12:05:30 <kuribas> neat
12:06:13 <geekosaur> newtype wrapper for Monoid instances that reverses the parameters
12:06:21 <geekosaur> s/reverses/swaps/
12:06:50 <mbw> I haven't gotten that to work :( I tried something like sortOn length (Down <$> ls).
12:07:19 <mbw> What terrible English...
12:07:22 <lyxia> geekosaur: You mean Dual?
12:07:46 <geekosaur> I may have it confused, still working on first coffee. probably ought to back away from kb for a bit
12:08:13 <lyxia> mbw: I just did.
12:08:19 <mbw> > getDual $ sortOn length [[1..5], [1..4], [1..3]]
12:08:23 <lambdabot>  error:
12:08:23 <lambdabot>      • Couldn't match expected type ‘Dual a’
12:08:23 <lambdabot>                    with actual type ‘[[Integer]]’
12:08:37 <mbw> > getDual $ sortOn length (Dual <$> [[1..5], [1..4], [1..3]])
12:08:40 <lambdabot>  error:
12:08:40 <lambdabot>      • Couldn't match expected type ‘Dual a’
12:08:40 <lambdabot>                    with actual type ‘[Dual [Integer]]’
12:08:49 <lyxia> mbw: you want to apply Dual to the thing being compared, i.e., the length.
12:08:58 <lyxia> hence sortOn (Down . length)
12:09:11 <lyxia> Down I mean
12:09:16 <mbw> > fmap getDual $ sortOn length (Dual <$> [[1..5], [1..4], [1..3]])
12:09:19 <mbw> should work.
12:09:20 <lambdabot>  [[1,2,3,4,5],[1,2,3,4],[1,2,3]]
12:09:25 <mbw> But Down is more idiomatic I guess?
12:10:34 <lyxia> sounds like an accident
12:10:39 <lyxia> Dual is not what you want
12:10:49 <lyxia> > fmap getDual $ sortOn length (Dual <$> [[1..3], [1..4], [1..5]])
12:10:53 <lambdabot>  [[1,2,3],[1,2,3,4],[1,2,3,4,5]]
12:11:13 <mbw> oh
12:11:23 <mbw> nasty
12:11:24 <lyxia> > length (Dual [1,2,3])  -- Dual is Foldable.
12:11:30 <lambdabot>  1
12:11:52 <mbw> So how does Down work, does it have a special Ord instance?
12:12:02 <lyxia> yes, it just flips the arguments of compare
12:14:37 <mbw> I better figure out how compare/comparing/sortBy/sortOn/... work. But at least I have a working solution. Thanks!
12:20:38 <mbw> Also, I had to implement a groupBy function, which grouped all occurences of an item, such that concat . group $ "Mississippi" /= "Mississippi", but "Miiiisssspp". There should be a standard way to do this as well, right?
12:20:49 <m4lvin[m]> Cale: Now overwriting works :-) Maybe the old one was just cached somewhere?
12:21:12 <pikajude> mbw: group just uses adjacent elements
12:21:18 <pikajude> you'd want to use a Map or a Set or something for that
12:22:19 <mbw> I need the duplicates, and just need to reorder a list.
12:22:42 <mbw> No matter, it's a one-liner anyway.
12:22:50 <pikajude> if you need to reorder it, just sort
12:23:48 <mbw> How would you apply sort such that sortBy _something "Mississippi" == "Miiiisssspp"?
12:23:57 <mbw> I don't think that will work.
12:24:34 <pikajude> i'm not sure what you're using exactly
12:24:39 <pikajude> but for me, just `sort` works
12:24:43 <pikajude> > sort "Mississippi"
12:24:46 <lambdabot>  "Miiiippssss"
12:25:00 <pikajude> unless you really want the s and the p to be reversed?
12:25:01 <blackdog> he's clearly trying to sort by bendiness
12:25:04 <geekosaur> you want to swap just the klast two?
12:25:10 <geekosaur> or... what is the rule here?
12:25:14 <mbw> lol
12:25:15 <pikajude> that's not really sorting then
12:25:21 <pikajude> you could put a newtype wrapper on Char
12:25:37 <geekosaur> it's sorting, certainly, but not by one of the common rules
12:25:43 <jophish> I think mbw wants to sort on the first index at which an item can be found
12:26:01 <pikajude> that's not really sort either is it
12:26:08 <pikajude> that's group
12:26:31 <geekosaur> yeh
12:26:39 <pikajude> that would be a bit more complicated but i think it would only be a few lines
12:27:00 <kuribas> The profiler says most of the time is spend in modify, but modify is actually optimized away.  How is that possible?
12:27:20 <blackdog> yeah, i think two passes is easiest - dump it into a Map Char Int, then map a function over (uniq str)
12:27:27 <geekosaur> the inlined modify is forcing thunks?
12:27:30 <jophish> > (\l -> sortOn (`elemIndex` l) l) "Mississippi"
12:27:34 <lambdabot>  "Miiiisssspp"
12:27:53 <blackdog> jophish: hahaha, that's cute. slow though, surely?
12:27:59 <blackdog> maybe that doesn't matter.
12:28:03 <jophish> I don't care :D
12:28:22 <mbw> Sorry, that was a type error, I want ["M","iii",...]. What I got is http://lpaste.net/353295, and it works. 
12:28:29 <jophish> D:
12:28:34 <pikajude> map snd . concat . sortBy (comparing (fst . head)) . groupBy ((==) `on` snd) . sortBy (comparing snd) . zip [0..]
12:28:34 <mbw> I just thought that would be a "standard" problem...
12:28:37 <pikajude> it's perfect!
12:28:45 <mbw> haha
12:29:04 <kuribas> geekosaur: maybe?
12:29:06 <jophish> "a →  a →  𝔹", nice
12:29:44 <mbw> That's actually a vim plugin, I turn it off most of the time.
12:29:54 <pikajude> :t sortOn =<< flip elemIndex
12:29:57 <lambdabot> Eq a => [a] -> [a]
12:30:01 <pikajude> there you go. very idiomatic
12:31:16 <Bish> why is list a monad :o
12:31:35 <blackdog> because the instance fulfils the laws
12:31:45 <pikajude> because you can write bind, join, and return
12:31:51 <pikajude> or whatever the laws are
12:32:15 <mbw> Also, list comprehensions can be defined in terms of the monad instance.
12:32:33 <Bish> this stuff is all confusin
12:33:17 <mbw> the sortOn flip elemIndex is pretty, I'll use that. My program is convoluted enough at this point.
12:33:42 <blackdog> Bish: can be when you're thrown into it. Are you comfortable with functor & applicative yet? monad feels a bit more obvious & motivated once you understand them.
12:34:41 <Bish> blackdog: no i am not comfortable at all :D with haskell, but i'd like to
12:34:49 <jophish> Anyway, that's not the list monad, that's the monad instance for (->) e
12:35:26 <jophish> oh, that was probably two unrelated conversations
12:35:52 <geekosaur> Bish, in some ways list is the canonical monad, because it maps directly to the underlying concepts. haskell bind is join . fmap, list join is concat, list fmap is map
12:36:41 <ertes> Bish: why is (+) on Integer a monoid?
12:36:47 <blackdog> Bish: it's probably best to find yourself a book and work through it. i like haskellbook.com, but i'm sure there are other good ones.
12:36:57 <richardcq> Hi guys, I'm having trouble figuring out how to make a function designed to run within the context of the redis monad. Essentially, I just want to loop in the monad with an accumulated list and then bind it from outside the monad, but I can't even figure out what the type of the function is and it's kinda blowing my mind
12:37:56 <Bish> ertes: can rhetorical questions help people understand?
12:38:09 <ertes> Bish: sometimes, but this one is not rhetorical
12:38:10 <Bish> blackdog: maybe i'll have to
12:38:24 <geekosaur> and the list monad is (a) what underlies list comprehensions (b) useful for finding all possible solutions to something (we generally call this usage the "nondeterminism monad")
12:38:32 <ertes> Bish: consider it an actual exercise, even if the answer seems trivial
12:38:37 <Bish> ertes: ofc it is, because you don't want the answer
12:38:38 <geekosaur> or sometimes the "logic monad" --- see LogicT
12:38:45 <ertes> Bish: yes, i do
12:38:47 <Bish> ertes: doesn't make the question non-rhetorical
12:39:17 <ertes> Bish: ok, let's go with it being rhetorical…  in that case the question why [] is a monad is also rhetorical =)
12:40:03 <ertes> Bish: monoids are a simpler example to grasp that kind of abstraction, before you go to monads
12:42:44 <EvanR> functors are even simpler
12:42:51 <ertes> Bish: the most important question about Monoid (the type class) is perhaps: why is it useful?  answer: because there are at least two instances, and because you can abstract over it (e.g. mconcat or foldMap)
12:43:19 <mbw> Functors and Monoids are like Mozart. Too easy for beginners, too hard for the pros.
12:43:43 <Bish> ertes: im not looking for cooler questions, im looking for the answer to my original question, your questions making it worse ;)
12:44:03 <Bish> better question maybe; why can't a list be a "value" like: 1
12:44:24 <ertes> Bish: lists *are* values
12:44:30 <ertes> but the [] type itself isn't
12:44:37 * dminuoso pokes Bish 
12:44:51 <dminuoso> New language to toy with? :-)
12:44:57 <ertes> Bish: but i think you're trying to see more than there is =)
12:45:06 <pikajude> isn't [] a type function, not a type
12:45:15 <Bish> ertes: thanks your answer that one helped already
12:45:30 <ertes> Monad is just like Monoid in that respect: it's a set of laws, it has at least two instances, and you can abstract over it (e.g. replicateM)
12:45:30 <Bish> dminuoso: languages is the most fun thing there is in cs, always in search for the holy grail
12:45:47 <ertes> > replicateM 4 "01"
12:45:50 <Bish> these abstract explanation don't help me (yet)=
12:45:51 <lambdabot>  ["0000","0001","0010","0011","0100","0101","0110","0111","1000","1001","1010...
12:46:05 <pikajude> monoid is very useful
12:46:19 <Bish> i need to be taught these like im stupid, or i will have just to try it out / read a book
12:46:21 <dminuoso> Bish: The holy grail is still Malbolge. If you write a Quine in malbolge you are a true saint.
12:46:27 <mbw> Bish: Do you know what a vector is?
12:46:27 <dminuoso> If you can do it, I become religious.
12:46:55 <Bish> dminuoso: was it that thing that got designed so it IS complicated?
12:47:04 <ertes> dminuoso: malbolge is quite boring actually…  i language that is difficult by design (rather than by arbitrary restrictions) would be lazy k
12:47:04 <pikajude> yeah
12:47:11 <ertes> *a
12:47:38 <dminuoso> Bish: Yes. And it's still not clear whether it's turing complete. ;o
12:48:11 <ertes> malbolge is like the PHP of esoteric programming languages
12:48:16 <Bish> yeah but that is just stupid :D
12:48:47 <pikajude> any sequence of 0s and 1s is a valid jot program
12:50:04 <dminuoso> Bish: Oh actually malbole is not turing complete due to an inherent limitation of supporting only 59049 malbolge instructions for a given program.
12:51:05 <shapr> Bish: have you tried haskellbook.com? It builds from functor to applicative to monad; you may find that easier.
12:53:53 <Bish> shapr: yea i won
12:53:58 <Bish> 't get around that i guess
12:57:35 <maerwald> shapr: is it still non-free?
12:58:02 <shapr> it is, but also totally worth the money.
12:58:34 <maerwald> then I would rather recommend free alternatives that do the same: yorgeys cis course
12:59:12 <shapr> @where cis194
12:59:13 <lambdabot> http://www.seas.upenn.edu/~cis194/spring13/
12:59:42 <shapr> Bish: try this -> http://www.seas.upenn.edu/~cis194/spring13/lectures.html
13:19:53 <sternmull> i start ghci with -fbreak-on-error and run a toy function that results in an exception with :trace. When i then do :list it says "Unable to list source for <unknown>, Try :back then :list". If i do :back and :list then i am "one step away" from the expression that causes the exception. Is there a way to the exact point that caused the exception?
13:22:18 <geekosaur> sternmull, that will happen if the exception happened inside a compiled function (e.g. something from the Prelude)
13:24:41 <sternmull> geekosaur: I let div throw by calling f 3 where "f i = div 100 i : f (i - 1)". And then :history can only show me "i - 1" with i = 1 as last useful thing.
13:26:28 <sternmull> i had expected it to at least tell me that the exception is thrown in "f 0".
13:31:35 <geekosaur> that's what the ":back" is suppsoed to do but sometimes you need to repeat it to get to the right frame
13:32:29 <ertes> could someone recommend a proof assistant that has a somewhat comprehensive real analysis library?  particularly calculus
13:32:45 <sternmull> :back makes sense. But is strange that the most current entry in the history is not valid for :list.
13:32:59 <ertes> axiomatic is good enough
13:39:43 <geekosaur> sternmull, not really, gdb will do the same thing to you if you trap in a libc function
13:40:46 <Sh4pe> Hi all! I'm getting a 'pattern match(es) are overlapped' warning on this piece of code: https://gist.github.com/Sh4pe/e23cd57fdcd32aaab428cc93465f8542
13:40:46 <geekosaur> and depending on optimization level may confuse things even worse (ghci doesn't optimize so at least you don't have to deal with that too). also laziness means (a) things don;t always evaluate the way you expect (b) there is no true call stack (it's graph reduction)
13:41:01 <Sh4pe> Can someone tell me how I can avoid the warning?
13:41:24 <geekosaur> Sh4pe, you can;t match against delim that way, you must use a guard
13:41:35 <geekosaur> it creates a new binding named delim that hides the old one
13:41:39 <geekosaur> it does *not* compare the value
13:42:17 <sternmull> geekosaur: But then i have a stackframe that calls the libc function and see the arguments that are given to it. For my div-example i don't have the "final call of f that calls div".
13:42:26 <Sh4pe> Oh - okay. Can you tell me how I can fix this?
13:42:45 <Sh4pe> (Sorry, my Haskell is not too good ;))
13:43:26 <geekosaur> remove the middle case and use a guard on the last one: | x == delim = concatLeft delim r | otherwise = C.concat [bsa, r]
13:53:11 <SepakoRayl> is there any reason to hold state wen parsing other than error reporting? I was taking a look at Happy and I can't think of any reason to ever keep state for non-error reporting purposes.
13:54:37 <SepakoRayl> I mean it should be possible to retrieve most data by working on the AST
14:00:07 <okeuday_bak> what am I doing wrong at https://github.com/okeuday/erlang_hs/blob/master/src/Foreign/Erlang.hs#L183-L185 with the Monad instance, it gives the error "Couldn't match type `PutMResult b' with `Either Error (Put.PutM b)', Expected type: Result (Put.PutM b), Actual type: PutMResult b"?
14:01:36 <Koterpillar> okeuday_bak: what's the type of k?
14:02:32 <okeuday_bak> Koterpillar: I thought it was PutResult, but I could be wrong, I need to read more about Monads probably
14:02:43 <chilversc> just trying the exercises on the site, and it says to pattern match (10,"abc") to get the letter 'a', so I used let (_,a:_) = (10, "abc") in a but the site has extra parens, (_,(a:_))
14:02:58 <chilversc> is the site just being more explicit or does leaving out the parens change it?
14:03:37 <Koterpillar> okeuday_bak: it is PutResult
14:03:45 <Koterpillar> okeuday_bak: but what is 'k r' then?
14:03:59 <SepakoRayl> nvm got it
14:03:59 <Koterpillar> oh, sorry, 'k r' would be PutResult
14:04:40 <Koterpillar> okeuday_bak: but next on, you're trying to construct PutResult (k r), where (k r) :: PutResult b
14:05:02 <Koterpillar> chilversc: try and find out
14:05:15 <chilversc> I did, I didn't notice a difference
14:05:27 <Koterpillar> then your guess is correct
14:05:29 <okeuday_bak> Koterpillar: yeah, I was attempting to use a Monad instance similar to Either, but that appears to be inappropriate because the Right side is that writer monad
14:06:36 <lyxia> chilversc: it's the same
14:06:36 <Koterpillar> okeuday_bak: is PutM a monad?
14:07:14 <okeuday_bak> Koterpillar: yes, that is my understanding, it is a type of writer monad
14:07:42 <Koterpillar> then yours is EitherT on top of it, right?
14:08:09 <okeuday_bak> Koterpillar: I am not yet using EitherT, should I be instead of Either to avoid problems?
14:08:33 <Koterpillar> you are rewriting EitherT
14:08:39 <okeuday_bak> Koterpillar: k, thanks
14:09:34 <Koterpillar> so either go with the types, or look up how it is implemented
14:10:07 <okeuday_bak> Koterpillar: yeah, I will read more about it and try using it instead
14:15:11 <mbw> Ok this has been bothering me for quite a while now. I have this kind of type hierarchy: http://lpaste.net/353296 . While my program works and does what it should, I'd like to know how to design this kind of stuff better in the future. The problem is that it would've been nice to have been able to derive Functor/Foldable/Traversable for these things. So I would pull some stuff out and bring it into a form 
14:15:17 <mbw> that is parametrically polymorphic on one type variable. However, then I'd have to do some newtyping, probably, in order to make the resulting type signatures easier to work with. If I did it like this, it would be nice to know if there was some reasonable naming convention as well. The other possibility would of course be Lenses, but I've only just started learning about those. So, what would be a 
14:15:23 <mbw> reasonable way to go about this, i.e. how would you refactor this code to make these data structures more "usable"?
14:18:51 <lyxia> your constructors have a lot of overlap
14:19:25 <lyxia> Can you also paste some of the functions on these
14:20:52 <mbw> ok I'll try to find something representative. This might take me a moment, though.
14:24:30 <mbw> Is it ok if I just dump the whole thing? I don't know specifically *where* my life would've been easier, to be honest. This whole thing just feels wrong. It's about ~300 LOC, probably less without import/export lists.
14:25:37 <lyxia> 300 is okay.
14:26:24 <mbw> I'll trim it down and post it.
14:31:26 <lpaste_> lyxia annotated “Types” with “Factored Types” at http://lpaste.net/353296#a353297
14:31:28 <lyxia> mbw: ^
14:32:10 <lyxia> it looks neater but it's not necessarily more convenient depending on what you're doing with these types.
14:32:46 <lyxia> it is DRYer
14:32:51 <Tuplanolla> Is `MonadReader r n => (m a -> n b) -> ReaderT r m a -> n b` a specialization of some common function? I don't see it.
14:32:54 <ertes> mbw: if you abstract over the element type, i'd honestly just use the type argument
14:33:07 <ertes> f :: TEI Label -> TEI Label
14:33:10 <ertes> or even:
14:33:18 <ertes> f :: (Whatever a) => TEI a -> TEI a
14:34:04 <ertes> you probably don't need the actual structure of Label most of the time…  knowing that it's Eq or Ord or … might be enough for many functions
14:34:41 <ertes> more abstraction is also a nice way to make types more documenting and functions less error-prone (due to parametricity)
14:34:41 <mbw> Ok: http://lpaste.net/353298
14:34:59 <lolisa> Hello, so I am writing a example for my library. Are there similar tools to https://github.com/tpolecat/tut in haskell?
14:36:03 <ertes> @let data Label = A | A' | A'' | A''' | B | B' | B'' | B''' deriving (Bounded, Enum, Eq, Ord, Show)
14:36:09 <lambdabot>  Defined.
14:36:13 <ertes> > [minBound..maxBound] :: Label
14:36:16 <lambdabot>  error:
14:36:17 <lambdabot>      • Couldn't match expected type ‘Label’ with actual type ‘[t0]’
14:36:17 <lambdabot>      • In the expression: [minBound .. maxBound] :: Label
14:36:22 <ertes> > [minBound..maxBound] :: [Label]
14:36:26 <lambdabot>  [A,A',A'',A''',B,B',B'',B''']
14:37:31 <mbw> The problem is that the Eq instances are "non-standard", since I make use of some symmetries. Also I find myself converting from tuples to lists and vice-versa a lot.
14:38:45 <mbw> Abstracting over the element type would not work for Term that easily, even in the refactored version lpaste_ suggested.
14:39:10 <ertes> mbw: why not?
14:39:33 <mbw> Wouldn't Term be a multi-param typeclass?
14:39:46 <ertes> class?
14:40:03 <ertes> Term is a type
14:40:30 <mbw> Ah, so you meant abstracting in function signatures only?
14:40:31 <lyxia> lolisa: we have literate haskell
14:40:36 <ertes> whether you need multiple parameters depends on over what you want to abstract
14:41:06 <ertes> data Term a = TermP (TEI a) (MatrixElement a) | …
14:41:08 <lyxia> lolisa: it's not pure markdown though
14:41:21 <ertes> that's Foldable, Functor and Traversable
14:41:30 <mbw> oh
14:41:42 <ertes> (as long as TEI and MatrixElement are)
14:41:48 <mbw> Why didn't I think of that :(
14:42:09 <lolisa> that sounds great. can it generate github markdown?
14:42:36 <mbw> I was thinking strictly along the lines of Term a = TermP a | TermQ a | ...
14:43:19 <ertes> you can probably also write useful Applicative instances for a lot of those types, which gives you zipping
14:43:29 <mbw> hmm..
14:43:35 <ertes> in fact you don't even need to write those yourself, as (<*>) is defined for generic products
14:43:43 <krokodil> can somebody explain to me what this Stack warning means, please?
14:43:44 <krokodil> WARNING: The "pandoc" executable found on the PATH environment variable is /home/krok/.stack/snapshots/x86_64-linux-nopie/lts-8.4/8.0.2/bin/pandoc, and not the version that was just installed.
14:44:19 <mbw> Do you mean tuples (anonymous products)? Or can I derive Applicative?
14:44:42 <mbw> I thought (<*>) was only trivial if I had a Monad instance already.
14:44:57 <lyxia> lolisa: text in literate Haskell is comments by default, and code is in special blocks, either surrounded by LaTeX-style \begin{code}/\end{code} or with lines prefixed by >
14:45:04 <ertes> @let import qualified GHC.Generics as Gen
14:45:07 <lambdabot>  Defined.
14:45:27 <lyxia> lolisa: you can just give it to GHC, and it's pretty straightforward to convert code blocks to whatever format you want
14:45:29 <ertes> @let data V2 a = V2 a a deriving (Eq, Foldable, Functor, Gen.Generic, Ord, Show, Traversable)
14:45:34 <lambdabot>  Defined.
14:45:44 <lolisa> got it. sounds good to me, thx
14:46:15 <ertes> @let instance Applicative V2 where pure = Gen.to . pure; fs <*> xs = Gen.to (Gen.from fs <*> Gen.from xs)
14:46:17 <lambdabot>  .L.hs:197:29: error:
14:46:17 <lambdabot>      • Couldn't match type ‘b’ with ‘a -> b’
14:46:17 <lambdabot>        ‘b’ is a rigid type variable bound by
14:46:50 <ertes> mbw: ^ anyway, this, but correct =)
14:47:31 <mbw> This is great. I haven't learned about Haskell Generics yet.
14:48:29 <mbw> How would you tackle the problem of having to use list functions with tuples, i.e. packing/unpacking ?
14:48:53 <ertes> i don't…  i make sure tuples don't come up
14:53:23 <mbw> Specifically, inside "allPermutations" for example. I have a function called addPrimes, which for a given list of labels, makes sure they are all unique. I found it most reasonable to implement it with a list. But if I had worked with nested lists instead of Lists of tuples, things would've been more error-prone, probably.
14:54:39 <ertes> this is weird…  why didn't the instance work?
14:57:09 <ertes> :t \xs0 -> foldr (\x go xs -> if S.member x xs then False else go (S.insert x xs)) (const True) xs0 mempty
14:57:12 <lambdabot> (Foldable t, Ord a) => t a -> Bool
14:57:26 <ertes> mbw: should return True if unique, False otherwise
15:00:28 <mbw> ertes: The thing I'm doing is more like addPrimes [A,A,A,B,B] = [A,A',A'',B,B'].
15:02:01 <mbw> I just hope I'm not talking about the wrong function here...
15:03:53 <MarcelineVQ> ertes: Generic1 is for * -> *
15:04:38 <ertes> MarcelineVQ: didn't work either, but i'm 100% sure that i've already used the generic (<*>) somewhere
15:04:59 <ertes> maybe i had an instance in scope i didn't realise came from somewhere outside of 'base'
15:05:05 <MarcelineVQ> oh? it worked for me just now :X maybe mine isn't rebuilding fresh
15:05:05 <ertes> perhaps from the generic-deriving library or something
15:05:27 <ertes> OH!
15:05:28 <ertes> d'oh!
15:05:37 <ertes> @let deriving instance Generic1 V2
15:05:40 <lambdabot>  .L.hs:195:19: error:
15:05:40 <lambdabot>      Not in scope: type constructor or class ‘Generic1’
15:05:40 <lambdabot>      Perhaps you meant one of these:
15:05:43 <ertes> @let deriving instance Gen.Generic1 V2
15:05:48 <lambdabot>  Defined.
15:06:01 <ertes> @let instance Applicative V2 where pure = Gen.to1 . pure; fs <*> xs = Gen.to1 (Gen.from1 fs <*> Gen.from1 xs)
15:06:07 <lambdabot>  Defined.
15:06:07 <ertes> there we go =)
15:06:20 <ertes> > pure sin <*> V2 3 5
15:06:26 <lambdabot>  V2 0.1411200080598672 (-0.9589242746631385)
15:07:35 <mbw> Do people use this often? It doesn't look like it's easy.
15:08:07 <ertes> mbw: i use it a lot, mostly to avoid having to write Monoid instances for product types
15:08:18 <lyxia> pure sin   looks evil.
15:08:39 <ertes> (which unfortunately requires the generic-deriving library, because (<>) is not defined genericly)
15:08:43 <ertes> haha
15:09:01 <ertes> perhaps (pure tan) looks more sunny
15:10:23 <mbw> There's always something new to learn. It's a shame they use fortran where I'm at.
15:10:30 <freechips> hey guys
15:10:35 <freechips> is anybody online?
15:10:45 <freechips> ive got a function with matches such as string -> int
15:10:52 <freechips> and id like to extend it in another function
15:11:09 <freechips> so like i have f1 = function "a"->1 | "b"->2 | ....
15:11:25 <MarcelineVQ> I can think of worse things than fortran, that being said it might be fun to write a haskell dsl that compiles to fortran
15:11:26 <freechips> and id like to have f2 = (f1 + "c"->3)
15:11:34 <lyxia> looks like OCaml
15:11:38 <freechips> oh shit
15:11:40 <freechips> sorry guys
15:11:44 <freechips> wrong channel
15:12:16 <MarcelineVQ> You'll be back :>
15:12:20 <freechips> i will
15:12:24 <freechips> but i need ocaml right now
15:12:35 <freechips> im determined to switch to haskell after ocaml
15:12:49 <mbw> MarcelineVQ Fortran can be as nice as any language. But of course you have to read other people's code more often than write your own...
15:13:50 <mbw> I guess on the other hand that clusterf* I posted isn't all that pretty either I guess :)
15:14:22 <ertes> i can read it
15:14:41 <ertes> that makes it good enough, because i ha…  prefer not to read other people's code most of the time =)
15:17:08 <mbw> It's kind of hard to find a middle ground between applying obvious substitutions and maintaining readability. For instance, I'm pretty sure I won't know what reduceTerms does a month from now...
15:21:18 <mbw> Oh and I probably forgot, but thank you guys for your advice!
15:38:07 <Bish> hi, this is not a strict docker question
15:38:25 <Bish> but are new combinations of linux/kernel docker to have a route per docker
15:38:34 <glguy> Oops, this is #haskell
15:38:38 <Bish> oy
15:38:41 <Bish> i thought i typed #docker
15:38:44 <benzrf> :D
15:38:46 <Bish> ./channel #docker
15:39:03 <glguy> the old off-by 4 error
15:39:19 <Bish> nah.. i got kicked immediately :D
15:49:17 <mac10688> So if I want to use ghcjs or purescript with yesod, how would I do this? I would just compile the purescript files and then serve them as static files?
15:49:33 <Koterpillar> mac10688: correct
15:49:52 <mac10688> that's my favorite answer. Thanks Koterpillar 
15:49:56 <paf31> mac10688: I haven't used it, but there is https://hackage.haskell.org/package/yesod-purescript
15:50:49 <Koterpillar> paf31: what does that do? "All things that are "YesodPureScript master", are also this other thing, because they nobody knows, because TH."
15:52:28 <paf31> actually it looks like it hasn't been updated in a while
15:52:41 <paf31> just serve static files :)
15:53:14 <mac10688> lol ok thanks paf31 
16:15:36 <dmwit> sdrodge: (A day late, but...) looks nice!
16:15:57 <sdrodge> dmwit: Thanks :)
16:37:07 <ertes> how do i express the empty constraint?
16:37:51 <ertes> nevermind
16:37:56 <glguy> ()
16:40:16 <ertes> yeah, i tried that, and it didn't work, but my error was elsewhere
16:44:18 <fetter_oml> would someone know a nice way to build a unity vector (e.g. unityVector 5 3 would be [0,0,1,0,0]) with vector in the sense of the Numeric.LinearAlgebra.Data package?
16:45:29 <fetter_oml> my current approach is building one with generate in the Data.Vector sense (which is ugly enough), then calling Data.Vector.toList on it and throwing the result into Numerical.LinearAlgebra.fromList
16:45:37 <fetter_oml> which is ridiculous.
16:50:55 <lyxia> do you mean the hmatrix package?
16:54:18 <lyxia> fetter_oml: the Vector is actually of the Storable kind if you want to go that way
16:55:44 <fetter_oml> lyxia: yes, it seems it is the hmatrix package
16:55:47 <lyxia> fetter_oml: but Numeric.LinearAlgebra.Data.assoc seems to be a way which better respects abstraction boundaries
16:56:06 <fetter_oml> it also says in the description that "1D arrays are storable vectors directly reexported from the vector package.", so I thought it should be easier
16:56:47 <lyxia> Yes, these are the vectors from Data.Vector.Storable
17:00:06 <fetter_oml> lyxia: yes, assoc seems like it should work
17:00:57 <fetter_oml> i will try getting it done with that one
17:01:35 <jle`> fetter_oml: i've called those one hots
17:01:52 <jle`> i think i've done those before in hmatrix, let me see if i can pull up some code
17:01:54 <fetter_oml> (whilst still thinking that a unity vector creation command might not be too luxurious)
17:02:22 <jle`> they're also called canonical basis vectors too in a linear algebra sense
17:02:35 <jle`> (if you're looking for things to google)
17:03:37 <jle`> fetter_oml: if you need all of them at the same time, you can just slice the identity matrix
17:04:10 <jle`> but Data.Vector.Storable.gen might be the best way yeah.
17:04:14 <jle`> s/gen/generate
17:04:52 <jle`> oh, hmatrix exports generate as 'build'
17:05:01 <fetter_oml> slicing ident was my first attempt too, but I dont really see how I should morph a (n,1)-dim matrix to a vector
17:05:18 <jle`> build 5 (\i -> if i == 3 then 1 else 0)
17:05:22 <lyxia> nice
17:05:24 <jle`> build is hmatrix's re-export of generate
17:06:03 <lyxia> The hmatrix docs look quite daunting, I'm not sure why.
17:07:35 <jle`> it's organization is kinda funky
17:07:40 <lyxia> the functions seem properly categorized at a glance
17:08:00 <jle`> maybe it's just that there are so many functions
17:08:24 <fetter_oml> not enough, as one can see :)
17:08:55 <fetter_oml> thanks lyxia and jle`, the build command should suit perfectly
17:09:50 <fetter_oml> thats another (but not the last) hurdle out of the way of some neuronal-network-fun 
17:10:10 <jle`> let me know how it goes :)
17:10:17 <jle`> sounds like a fun project
17:18:18 <fetter_oml> so far nothing major, just trying to fiddle with the hnn-package to learn from the mnist-database (http://yann.lecun.com/exdb/mnist/)
17:19:02 <fetter_oml> but as my last line of haskell code is about 3-5 behind, the work is going rather slow :)
17:19:42 <fetter_oml> 3-5 years*. also, its quite late, goodnight.
17:23:02 <robertkennedy> :t diff
17:23:05 <lambdabot> error:
17:23:05 <lambdabot>     • Variable not in scope: diff
17:23:05 <lambdabot>     • Perhaps you meant ‘dff’ (imported from Data.Graph)
17:31:54 <jchia> I have a module that defines a data and an instance just for its own consumption that I don't want it to export. I think there's no "export hiding". Explicitly listing everything I don't want to hide is verbose. Wrapping the module in another module that re-exports hiding the data and instance seems ugly. Any other ways?
17:35:48 <jchia> I suppose I could put those things I want to hide from export in a nested 'Internal' module.
17:38:53 <Koterpillar> jchia: you can just list everything else you want to export
17:39:02 <Koterpillar> if I understand you right...
17:39:45 <Koterpillar> e.g. if you define DataType and someFunction, why not make it: module Module (someFunction) where...
17:39:46 <jchia> Koterpillar, yeah, and that's quite verbose. E.g. if I have a list of 20 things out of which I want to hide 2. So, I have to explicitly export 18 things.
17:39:52 <jchia> I think I'm going to use an 'Internal' module
17:40:25 <jle`> it's not an ideal solution, but yeah, it's something i've done too
17:40:27 <Koterpillar> oh, sorry, I missed that part in your question. I would still do that, though, because there might be more things you don't want to export
17:40:39 <jle`> but usually i write explicit export lists
17:41:48 <jchia> I'll probably have an explicit export list when the code is more stable
17:52:47 <johnw> jchia: if you use ghc -ddump-minimal-imports Foo.hs, it'll probably get you where you want to be
17:56:31 <Profpatsch> edwardk: I want to hit you https://hackage.haskell.org/package/trifecta-1.6.2.1/docs/Text-Trifecta-Util-It.html
17:57:50 <maybefbi> the GHC output is merely a STG interpreter correct? the haskell runtime included with each executable merely shuffles the STG tree around
17:57:57 <maybefbi> am i correct in saying this?
17:58:22 <benzrf> maybefbi: idk if i'd put it that way
17:58:40 <maybefbi> how would you put it?
17:59:25 <benzrf> well - my understanding is that the reduction process isn't "external" to some graph
17:59:36 <benzrf> rather, the nodes of the graph contain code to be jumped to
17:59:41 <benzrf> or something like that!
17:59:47 <maybefbi> woah hmm
17:59:56 <benzrf> it's a bit like church encoding, i think
18:00:04 <benzrf> (this might be way off, though)
18:01:22 <benzrf> er, maybe rather a pointer to the code you wanna jump to
18:01:27 <benzrf> i believe the actual expressions appearing in the code get compiled to static routines
18:02:28 <benzrf> so if you write something like `case f x of Just n -> n + 1; Nothing -> 0' then part of the output will be a procedure doing... that
18:03:00 <maybefbi> i dont think modern processors allow self modifying code, so im sure we cannot have thunks written in machine code
18:03:21 <maybefbi> so in some sense it has to be an interpreter if it reduces thunks into normal forms
18:03:34 <benzrf> kind of
18:04:16 <benzrf> iirc, a thunk is an allocated object which has a pointer to the code for forcing it - then once forced, it gets modified to isntead be the result value
18:04:45 <benzrf> so we do have a graph of thunks, but the logic of reducing any thunk is directly compiled
18:04:46 <maybefbi> hah thats clever
18:05:19 <benzrf> the nice part is that any given thunk will be the result of an expression physically in the code, so you already know all of the things you'll need to compile
18:05:48 <maybefbi> yeah
18:06:07 <maybefbi> so the runtime is just the bit that converts thunks to point to either the code or the data in non-executable heap
18:06:09 <maybefbi> ?
18:06:41 <maybefbi> also im assuming the garbage collection is also done by the runtime
18:06:42 <benzrf> well, i don't know if i'd call that a "runtime"
18:06:46 <benzrf> the garbage collection, yes
18:07:01 <maybefbi> what is it officially called instead of the runtime
18:07:13 <benzrf> well, maybe it is called the runtime... i don't know the terminology that well
18:07:21 <maybefbi> copy that
18:07:53 <benzrf> but the logic for allocating new thunks and so on could perfectly well be inlined into the compiled expressions
18:08:25 <benzrf> so even if that logic is in a fixed set of functions added to the compiled code, it doesn't precisely feel like "a runtime" to me - maybe i just don't have a good grasp of what the word means
18:09:28 <maybefbi> im trying to imagine how much work went into eta, the ghc compatible haskell for the jvm. i think they just implemented a STG shuffler but i could be wrong
18:09:41 <benzrf> o:
18:10:17 <benzrf> i think 'STG' actually refers to the thing i was describing where you have pointers to the reduction code
18:10:22 <benzrf> (again - i may very well be wrong)
18:11:15 <maybefbi> ok
18:12:25 <Profpatsch> Hm, what’s with parsers drawing in attoparsec AND parsec?
18:12:40 <Profpatsch> That means trifecta always pulls in everything.
18:12:46 <Profpatsch> Also, lenses.
18:12:53 <Profpatsch> That’s a lot of dependencies.
18:12:56 <andrei> Hi, I'd like to submit a package to Stackage but it has an external dependency. What's the way to do this?
18:13:09 <andrei> A non-haskell dependency, so tests will fail
18:17:36 <deepfire> what tricks people use to visualise type family reduction steps?
18:19:11 <maybefbi> :kind!
18:20:09 <robertkennedy> Mine is `:t undefined :: T A B`
18:24:19 <jle`> huh, does that really work?
18:24:36 <jle`> i always just use :kind! ... i don't consider that a trick, though
18:25:00 <jle`> it's the documented way to do it, but it doesn't show reductino steps step-by-step, admittedly
18:32:19 <lyxia> andrei: it seems you just disable the tests/mark them as expected failures
18:32:29 <lyxia> andrei: https://github.com/fpco/stackage/issues/811 for example
18:42:19 <andrei> lyxia: Thanks! I just found that I can request some debian packages to be included in the stackage environment. That should do nicely
18:43:40 <lyxia> oh, that's nice then
18:50:37 <dosequis> hey all - I'm running a QuickCheck test in ghci and wondering if it's possible to get the test data where it failed so that I can play around with it and see what happened - is this possible?
18:53:11 <deepfire> thanks everyone!
18:59:27 <lyxia> dosequis: doesn't it print the generated counterexample?
19:00:11 <dosequis> lyxia: hey thanks for answering. Yes it does. Ideally though, I would want to bind it to a variable somehow, and then manually run some tests on it in the console
19:00:14 <lyxia> there should also be a way to get the seed/size combination out
19:00:44 <dosequis> lyxia: ok yes I saw that in the Result
19:01:10 <dosequis> lyxia: so if I have seen/size, then presumably I can re-generate the data that caused the failure
19:01:34 <lyxia> Right.
19:02:06 <dosequis> ok thanks! this helps
19:02:12 <lyxia> I think there is an open issue about a better api
19:02:20 <lyxia> the problem is it's not clear how that would work
19:02:38 <dosequis> yeah I mean I'm not sure how to proceed 
19:02:42 <lyxia> dosequis: https://github.com/nick8325/quickcheck/issues/117
19:03:21 <dosequis> lyxia: thanks for the link!
19:03:27 <lyxia> oh I had forgotten there's an actual solution
19:07:31 <dosequis> lyxia: yes, I found http://hackage.haskell.org/package/quickcheck-with-counterexamples. Very helpful thanks again!
19:13:58 <lyxia> yw
19:44:48 <johnw> I'm reading http://bentnib.org/interleaving.html, and I'm wondering, how is this not just what FreeT does? (or, rather, an equivalent FixT)
19:49:09 <Cale> johnw: I don't really understand the question -- they talk about the construction of free monads in that paper.
19:52:32 <monochrom> Perhaps the abstract is better rewritten as "FreeT has been in use by practical people for a while. This paper aims to introduce this concept to theorists." :)
19:53:14 <monochrom> (Afterall, functional programmers regularly reading JFP?! Are you kidding me?)
19:54:19 <Cale> Heh, looks like that to me, yeah
19:55:08 <Cale> Also, it's from 2015 -- when did FreeT appear independently?
19:55:29 <Cale> Oh, I guess that would have been a few years earlier
19:56:19 <monochrom> free-0.1.0 was Feb 2011 on hackage.
19:56:28 <monochrom> "initial free"
19:56:36 <haskull> the state monad has 2 args, a value and a state. is it bad to use the state as a separate value, or do i somehow use 2 state monads at the same time? or am i doing something wrong and need to restructure the code?
19:57:26 <monochrom> I don't understand "the state monad has 2 args".
19:57:39 <haskull> i dont know what they're called.. like State Int Int, for example.
19:57:54 <peddie> "s" and "a"
19:57:59 <Cale> haskull: The first is the type of the state which is manipulated during the computation, and the second is the type of the result of the action.
19:58:03 <monochrom> OK, the State type.
19:58:39 <Cale> So what do you mean by "use the state as a separate value"?
19:58:54 <Cale> Perhaps it would help if we could see what your code looks like
19:59:24 <monochrom> Next, I don't understand "use the state as a separate value". But the bottomline is, if your code compiles and gives the right answer, you are doing it right.
19:59:31 <Cale> Note that you can choose any type at all that you like to be the type of state being manipulated, so in particular, it might be a record consisting of a bunch of independent things
20:00:00 <monochrom> Actually maybe I only mean the converse. If your code has a type error or gives the wrong answer, then you have wrong concept.
20:00:45 <monochrom> If you mean, "I will use 'get' all the time and 'put' never", OK it is legal, but then you're better off with Reader.
20:01:41 <haskull> I'm reading from a string, and based on the words in it I want to modify the content of 2 lists.
20:02:12 <haskull> i'm having trouble clarifying as i hardly understand what i'm doing :/
20:03:08 <Cale> haskull: I would usually recommend trying to just write your function without any State monad first, so that you *do* understand it that way, and then if you ended up with a lot of functions of the form s -> (s,a), where you're tupling the result of the function with a new intermediate state, consider using a State monad to clean it up.
20:03:37 <haskull> alright, thanks.
20:03:46 <Cale> From that description, it shouldn't be too hard to imagine using State, but it also might not improve things much, depending on the details
20:04:03 <Cale> You could have a pair of lists as the 's' type
20:04:59 <Cale> But then again, you might just be able to write a function which takes those two lists being manipulated as arguments, and which applies itself to new arguments according to how the lists are to be updated.
20:05:11 <Cale> (does that make sense?)
20:05:49 <Cale> The main way in which variables vary is to be bound to new things when a function is applied to new arguments.
20:06:22 <haskull> the part about tupling the 2 lists makes sense
20:06:27 <haskull> i think it'd work
20:07:38 <Cale> > let f xs ys [] = (xs,ys); f xs ys (u:us) = if even u then f (u:xs) ys us else f xs (u:ys) us in f [] [] [1..10]
20:07:43 <lambdabot>  ([10,8,6,4,2],[9,7,5,3,1])
20:08:40 <Cale> ^^ have a look at how that thing manipulates the lists xs and ys, adding the next element to be processed to one or the other depending on whether it's even.
20:09:41 <haskull> i see. thanks, i think i can figure it out now.
20:17:18 <Ptival> DuplicateRecordFields is weird http://paste.awesom.eu/2GTa
20:17:47 <johnw> Cale: what I mean is, in 2015 what is it adding?
20:18:03 <Ptival> the reason given in the wiki ("we do not infer the type of the argument to determine the datatype, or have any way of deferring the choice to the constraint solver") is disappointing
20:18:08 <johnw> Cale: or is it just clarifying the intersection between FreeT constructions and f-and-m-algebras?
20:40:49 <cris_> hi, i write up some code on dates, could you check if any could be improved? https://github.com/szehk/Haskell-Carbonara-Library/tree/master/src/Data/Carbonara
20:43:11 <EvanR> dayToUnixTime can be done without magic numbers, using Data.Time conversion functions
20:43:40 <cris_> thanks EvanR, let me check
20:44:03 <EvanR> and unixtimeToDay
20:45:01 <EvanR> posixSecondsToUTCTime :: POSIXTime -> UTCTime
20:46:27 <EvanR> POSIXTime is a fractional number of seconds, UTCTime is a Day paired with length of time past midnight
20:47:53 <cris_> thanks EvanR, i ll change it soon , I 'll go to lunch now and reply you guys later
20:48:14 <EvanR> Integer -> POSIXTime is fromInteger, UTCTime -> Day is utctDay
21:06:45 <sssilver> Hey guys, I have this problem where I am a Haskell programmer, I know the language pretty well, have shipped production code in it, can leverage the various language features and all Haskell programs make sense to me
21:07:32 <Cale> Cool problem
21:07:33 <sssilver> however, whenever people start talking about the mathematical aspects of the type system and everything, that stuff just completely flies over my head; I get dazed and confused
21:07:44 <Cale> ah
21:08:15 <pacak> Keep getting dazed and confused, eventually you'll get used to it :)
21:08:27 <Cale> @remember sssilver Hey guys, I have this problem where I am a Haskell programmer, I know the language pretty well, have shipped production code in it, can leverage the various language features and all Haskell programs make sense to me
21:08:28 <lambdabot> I will never forget.
21:09:00 <monochrom> Haha.
21:09:10 <Cale> sssilver: (sorry, that was too perfect, had to take it out of context)
21:09:34 <monochrom> But you are probably just missing some background knowledge.
21:10:01 <Cale> You might try Benjamin Pierce's "Types and Programming Languages" as a start
21:10:11 <sssilver> yes monochrom so I complained about this to a friend who's building compilers at Intel, and he advised I read this book called "Concrete Mathematics"
21:10:29 <subttle> sssilver: Bartosz Milewski has a great video lecture series (still in progress) if that is more your thing..
21:10:33 <Cale> (As a somewhat gentle intro to type theory proper)
21:10:43 <subttle> https://www.youtube.com/playlist?list=PLbgaMIhjbmEnaH_LTkxLI7FMa2HsnawM_
21:10:58 <sssilver> so I started reading it, but every paragraph makes me go "why dafuk am I doing this to myself??" in bewilderment and self loathing
21:11:56 <monochrom> Concrete Mathematics is going to make you an expert in determining whether a certain algorithm's running time is "n^2 + 4n arithmetic operations", and only that.
21:12:22 <monochrom> It still won't tell you about types or catamorphisms.
21:13:39 <monochrom> "But it's a pretty thick book!" you may say. I know right?
21:13:48 <sssilver> the question is, do I really need to understand all of it in order to earn the moral right to feel like an accomplished programmer, when commuting from work to home?
21:14:19 <solrize> sssilver, concrete mathematics is kind of a streamlined and easier version of the stuff in knuth vol 1
21:14:24 <solrize> yes it's a very good book
21:14:49 <monochrom> Well, considering the fact that the typical CS student chose CS because "I flunked highschool algebra and I'm proud of it", you do need a thick book to just reteach highschool algebra (for the purpose of algebraic expressions of running times, but still.)
21:15:02 <solrize> very well worth reading, even if you decide that you won't get much benefit from working thru all the details
21:15:20 <solrize> monochrom, no it's not a rehash of hs algebra :)
21:15:51 <solrize> those concrete running time calculations are usually done with generating functions
21:15:55 <solrize> it was an eye opener
21:16:32 <solrize> he analyze the running time of "find the maximum" (i.e. the obvious linear algorithm) that way
21:16:47 <solrize> at least in taocp vol 1, not sure if that's also in cm
21:16:50 <monochrom> That might be an overkill.
21:17:05 <solrize> well he used it to show the technique, not to find the running time of find the maximum ;)
21:18:30 <monochrom> P.S. Though I said "types" and "catamorphisms" together, do not think that I meant they were covered by the same book. No, they are yet two different books.
21:19:43 <sssilver> how did you guys come to know and understand all this stuff!
21:19:47 <solrize> hmm dunno
21:20:12 <sssilver> you can push a LOT of JSON through TCP using Haskell and still not have to touch any of it
21:20:16 <subttle> sssilver: https://bartoszmilewski.com/2014/10/28/category-theory-for-programmers-the-preface/
21:20:17 <monochrom> "types" being covered by Types and Programming Languages as said (though I wonder if Practical Foundations for Programming Languages is shorter and cheaper). (Also you don't need to finish the whole book.)
21:20:31 <solrize> PFPL is online for free
21:20:39 <solrize> i liked it
21:21:04 <solrize> it was much less detailed than TAPL, but TAPL has a lot of material on subtype systems
21:21:05 <monochrom> "catamorphism" there are some papers and there are other books with category theory inclinations.
21:21:15 <conal> sssilver: I can't tell why you want to learn the math/theory stuff. Maybe it's out of reach because you don't have an intrinsic motivation.
21:21:20 <solrize> which i thought were unstylish around here
21:21:24 <monochrom> Yeah TAPL is big because subtypes.
21:21:58 <sssilver> conal yes it bores me to death :(( but I consciously understand that I should be interested in it
21:22:19 <solrize> i first saw catamorphism in a program derivation (i.e. bird) context i think
21:22:19 <monochrom> But you don't need subtypes for Haskell. And you kind of learn that subtyping is really difficult, so it might be not such a good idea to use it.
21:22:23 <solrize> sssilver, what kind of theory?
21:22:39 <monochrom> Yeah but Bird has a category theory inclination.
21:22:49 <solrize> yeah
21:23:14 <monochrom> The most extreme being Algebra of Programming (now hard to find and expensive). But many Bird papers are not that extreme.
21:23:16 <solrize> for very basic intro the haskell wikibook page about categories is really nice
21:23:23 <solrize> does't say anything about catamorphisms though :)
21:23:35 <conal> sssilver: maybe it's not true that you should be interested. especially if it's for status or self-image ("the moral right to feel like an accomplished programmer"). it doesn't sound fun to learn without a genuine interest.
21:23:43 <monochrom> Ah yea the wikibook is good.
21:24:20 <solrize> the only way to gain the moral right to feel like an accomplished programmer is to write some really good code.  then you'll have accomplished something as a programmer and can feel like you've done that
21:24:35 <solrize> you don't need a ton of theory to write good code
21:24:46 <solrize> but it helps to not be totally ignorant
21:24:50 <solrize> know some theory
21:24:53 <solrize> not necessarily a lot
21:24:58 <solrize> see antirez recent blog
21:25:09 <solrize> http://antirez.com/news/112
21:27:12 <conal> i suspect that most people who are good at math / theory got good at it because they genuinely delight in it, not for status.
21:27:21 <monochrom> I don't worry about people learning useless academic stuff. I do that all the time. I was learning linear algebra (specifically the kind for quantum bits). I am planning to learn Lagrangian and Hamiltonian mechanics soon. Useful for my career? No way. Rabit holes? Yes a multiverse of rabbit holes. It's a hobby, I know that.
21:27:26 <conal> ... and there are a lot of other things to enjoy.
21:29:13 <sssilver> :(
21:30:11 <monochrom> Sure. I just enjoyed The Lego Batman Musical today. Nothing to do with Hermitian matrices, which I also enjoy.
21:31:31 <monochrom> ObHaskell: I did code up some matrix operations (backed by Data.Vector) (naive algorithms) so I didn't always have to multiply matrices by hand.
21:35:45 <spatial> http://pastebin.com/zWZxXiam After the case the varialbles go out of scope
21:36:54 <monochrom> Look at the indentation shown in the paste. It completely explains why.
21:39:41 <haskull> execute :: Operation -> StateT ParseState IO (); cmds :: [Operation]; why can't I do execStateT (do fmap execute cmds) (..)?
21:40:20 <Koterpillar> haskull: you need sequence
21:43:54 <fragamus> hey so what language is all that hacking code written in?
21:44:08 <fragamus> In my imagination it is badass haskell code
21:45:13 <Koterpillar> fragamus: much as you'd want it to, people's toasters aren't that fast on compiling GHC
21:45:57 <fragamus> wait they can hack my toaster damn
21:46:24 <fragamus> what secrets lie in the crumbs at the bottom of my toaster
21:48:41 <haskull> if i keep smashing my head with haskell will i eventually get it, or should i find the patience to read a book?
21:49:44 <Koterpillar> haskull: both are good techniques, try combining them
21:50:33 <CoconutSnail> find a book and smash one's head with it?
21:51:15 <c_wraith> haskull: semi-passive learning was the most effective technique I used.  Hang out here for hours, and whenever a topic came up that interested me, become less passive and ask questions.
21:51:26 <Koterpillar> ^
22:04:22 <haskull> is "Please report this as a GHC bug" a big deal or can i just ignore it?
22:05:41 <Koterpillar> it'll be nice to report if you can minimize the test case
22:05:51 <Koterpillar> (or maybe it's a known bug, but still)
22:06:33 <haskull> i'll try tomorrow, gonna sleep for now.
22:06:46 <haskull> bye, and thanks
22:10:54 <qmm> When using something like Scotty, what is a common way to setup a database connection for the entire app?
22:12:08 <qmm> maybe the question is, how do i pass a reference to a database around
22:12:43 <Koterpillar> no experience with Scotty in particular, but you usually put it inside your base monad
22:13:58 <Koterpillar> aha, same thing, use Web.Scotty.Trans
22:21:31 <_sras_> Is there a program that can convert and HTML string into format of a Lucid template?
22:22:08 <_sras_> s/and/an
22:35:44 <srhb> _sras_: Don't think so.
22:35:48 <spatial> http://pastebin.com/637shj0t Where should that return actually be placed ?
22:36:01 <spatial> Indented
22:36:26 <spatial> parse error on input `return'
22:36:50 <srhb> spatial: It's easier if you rewrite without re-indenting on every line
22:36:51 <Koterpillar> with do notation, you don't have to use 'let .. in'
22:37:44 <spatial> do notation - What ?
22:37:46 <Koterpillar> also, why is this return needed? Could probably have the same function without the Monad constraint
22:38:01 <Koterpillar> spatial: what is the type of this function?
22:38:33 <spatial>  nextstate :: Player -> BoardState -> Int -> BoardState
22:38:34 <srhb> spatial: I don't understand what you're actually trying to do, but here the indentation is fixed at least: http://lpaste.net/1567422115374694400
22:38:41 <Koterpillar> spatial: what is the type of 'return'?
22:39:06 <Koterpillar> spatial: forget about return, you don't need it
22:39:14 <spatial> data BoardState = BoardState { xloc :: [Int],                                oloc :: [Int],                                index :: Int                              }  deriving (Show)
22:39:23 <Koterpillar> :t return
22:39:26 <lambdabot> Monad m => a -> m a
22:40:09 <spatial> Oh what is :t return
22:40:26 <Koterpillar> spatial: return is a function, which you currently don't need
22:40:38 <Koterpillar> spatial: I think this will be a good start: http://lpaste.net/353299
22:41:07 <athan> Is there a way to `cancel` an `async` thread, from within the thread itself?
22:41:13 <athan> like an anonymous cancel?
22:41:33 <spatial> Right.
22:42:14 <Koterpillar> spatial: I suspect you are trying to write your function as, "let's assign X to Y, then let's assign some f(Y) back to Y"
22:42:32 <spatial> Ya OCaml syntax
22:42:50 <Koterpillar> spatial: it helps if you think of it instead as: "The next state of the game (?), if the previous state is this and the move is that, _is_ ..."
22:43:01 <spatial> Converting lisp. Right
22:43:37 <spatial> So return is needed in what situations ?
22:43:57 <spatial> Never ?
22:44:18 <Koterpillar> when you are using monad typeclass, and even then in modern GHC you have 'pure'
22:48:15 <Rotaerk> athan, I haven't really used async in haskell so I'm not sure if my response applies, but I've used something similar in C#...
22:48:39 <Rotaerk> athan, why can't the async thread just end?
22:49:52 <Rotaerk> if you're at a point of execution within that thread where you want to cancel, simply return
22:50:36 <athan> hmm, well Control.Concurrent has myThreadId
22:50:42 <athan> I might just use that and killThread
22:50:50 <athan> (I think async just builds on top of it)
22:51:12 <athan> my only issue is I also used `forever` Rotaerk 
22:51:20 <Rotaerk> I don't understand why you would kill *this thread* though
22:51:37 <Rotaerk> can you replace forever with a condition that changes when ready to end?
22:51:44 <athan> not really :\
22:51:55 <Rotaerk> can you paste?
22:52:24 <athan> foo = async $ forever $ do { ... when bar $ killThread =<< myThreadId }
22:52:30 <athan> I think that should work
22:52:43 <athan> `async` I think intents to be more... structural or osmething
22:53:57 <EvanR> async provides a lot of tedious checks and exception propogation which really streamline the task 
22:54:07 <athan> ahh hm
22:54:23 <EvanR> async lets you directly cancel a task
22:54:41 <EvanR> if you wait for a result and the thread crashes you get the exception
22:55:12 <EvanR> when the thead is spawned, weird asynchronous exception possibilities are handled
22:55:13 <Rotaerk> sounds like the way tasks and await work in C#... you don't get the exception until you wait for the task, even if it actually is thrown long before you await it
22:55:49 <Rotaerk> it just seems unnecessary to me to ... cancel a task from within itself
22:56:01 <Rotaerk> instead just return from it cleanly
22:56:14 <EvanR> killThread throws a ThreadKilled exception to a thread
22:56:28 <athan> :x
22:56:34 <EvanR> so killing yourself is the same thing (or intuitively is the same) as just thowing an exception
22:57:58 <EvanR> throwIO (userError "I'm dead")
22:59:16 <athan> but... async will ignore it unless they are `link`ed... right?
22:59:49 <EvanR> what, if you throw an exception, youre not going to be continuing
22:59:59 <EvanR> :t throwIO
23:00:02 <lambdabot> Exception e => e -> IO a
23:00:08 <EvanR> it returns an "a"
23:00:36 <EvanR> its illogical to continue
23:01:30 <athan> crud, thanks EvanR 
23:02:10 <EvanR> no one may ever know you are dead, but thats another story
23:02:38 <EvanR> but if no one is listening, who cares
23:17:43 <wizard1337> is there a name for the problem of being able to transform imperative code into functional and/or vice versa? how do i find some thoughtful articles on the topic
23:18:53 <Cale> There is a name for the programs which do that sort of work, they're called compilers :)
23:18:53 <peddie> wizard1337: you could start with https://pdfs.semanticscholar.org/7cb9/0be27017772fa441981d3d362741056efd57.pdf
23:23:44 <aces> Hi, complete beginner here, have almost no programming experience. I read that haskell is a great language to start out with and wanted to start with functional programming from scratch. Can anyone point me to a tutorial that is beginner friendly?
23:24:27 <wizard1337> aces: my best advice (as a newb myself) is start writing code and forget about learning more than little bits of the language
23:24:44 <wizard1337> aces: then grow those bits with time
23:25:13 <aces> wizard1337: I don't know much about the basics as of yet. I still need to learn the concepts prior to writing code.
23:25:26 <peddie> @where nicta -- aces
23:25:27 <lambdabot> https://github.com/nicta/course
23:25:41 <peddie> @where cis194  -- aces
23:25:42 <lambdabot> http://www.seas.upenn.edu/~cis194/spring13/
23:27:46 <wizard1337> omg ghci has tab completion :D
23:27:54 <aces> Thank you peddie , having a look.
23:29:09 <wizard1337> and use stack, not cabal
23:29:13 <peddie> aces: good luck and have fun
23:51:31 <wizard1337> why does reid barton work on ghc
23:58:26 <cocreature> why shouldn’t he?
23:59:16 <wizard1337> seems like a bit of a jump from pure math
23:59:53 <cocreature> some people have multiple interests :)
