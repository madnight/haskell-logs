00:01:24 <jle`> i wish i could define local data types
00:01:27 <jle`> one-off ADT's or newtypes
00:01:29 <jle`> that would be nice
00:01:43 <jle`> yes that would be the life
00:01:50 <jle`> i can imagine it now ...
00:03:52 <Eduard_Munteanu> hololeap, you could write addLine directly in StateT s (ExceptT m)
00:04:14 <Eduard_Munteanu> hololeap, if you make use of liftIO
00:05:10 <Eduard_Munteanu> addLine = do { oldState <- get; liftIO $ putStr ("Current state: " ++ show oldState); ... }
00:06:47 <hololeap> Eduard_Munteanu: and would that same method make it easy to "invert" everything so that it is of type :: StateT s (ExceptT e m) a
00:07:05 <hololeap> (this is just a mental exercise, nothing specific)
00:07:37 <hololeap> because that is where i got stuck
00:08:35 <Eduard_Munteanu> hololeap, the type of that can be StateT s (ExceptT e m) a, although more generically it is something like    (MonadState s m, MonadError e m, MonadIO m) => m Something
00:09:21 <hololeap> Eduard_Munteanu: that's cool. i will have to look more into the transformer classes
00:10:51 <Eduard_Munteanu> :t get >>= liftIO . print
00:10:54 <lambdabot> (MonadState a m, MonadIO m, Show a) => m ()
00:11:56 <hololeap> what about "running" the monad in my example. is there a more generic (or "proper") way to do it than `runAddLine = runStateT . runExceptT $ forever addLineT`
00:13:11 <Eduard_Munteanu> hololeap, that's fine, although you usually don't write runners for each monadic function, but you run the big computation somewhere in main for example
00:14:17 <Eduard_Munteanu> e.g. main = runExceptT . (`runStateT` 0) $ do { ... }
00:18:17 <hololeap> (`f` v) is an interesting equivalent to (flip f v) :p 
00:19:27 <hololeap> so you would write the addLine function directly in that do block?
00:20:31 <Eduard_Munteanu> hololeap, I'd write the runStuff invocation directly, addLine can be a separate function
00:23:35 <hololeap> Eduard_Munteanu: thanks. i will try to refactor this example using the new info at some point
01:01:42 <edwardk> centril: if you're doing it recursively and want to repeatedly apply the rewrite to a fixed point if it takes a step then rewriteOf could almost be used, but the fact that plated is going to walk into your :+ makes that awkward. you can write a one off combinator using plated to recurse, match the :+ case, and apply your normalizer in one step though
01:04:01 <_sras_> Using the Lens library, can one do transformations on similar records. Say make a new record from A with only couple of fields differing?
01:04:34 <jle`> you mean define a new type?
01:04:46 <edwardk> centril: walk f (l :+ r) = .. your logic above;  walk f e = fromMaybe r (f r) where r = over plated (walk f) e
01:05:00 <edwardk> centril: or something like that. its a couple of line combinator that does exactly what you want
01:06:14 <MarcelineVQ> "<jle`> i wish i could define local data types" yus, instances too
01:07:40 <jle`> MarcelineVQ: local instances are possible with reflection :O
01:08:00 <MarcelineVQ> type, data, pattern, instance, all seem like useful things to be able to scope
01:08:05 <testx_> can someone explain this? sequenceA [(>3), (<8), even] 7
01:08:21 <jle`> testx_: sequenceA [f,g,h] x = [f x, g x, h x]
01:09:03 <jle`> it uses the Applicative instance for functions
01:09:30 <jle`> is there a specific question you had?
01:11:42 <testx_> jle`: how does it typecheck
01:11:53 <jle`> :t sequenceA
01:11:55 <lambdabot> (Traversable t, Applicative f) => t (f a) -> f (t a)
01:11:59 <testx_> sequence doesn't take 2 arguments
01:12:02 <jle`> t ~ []
01:12:06 <jle`> f ~ (r ->)
01:12:20 <jle`> the Applicative instance is the instance for functions
01:12:41 <jle`> so you get sequenceA :: [r -> a] -> (r -> [a])
01:15:48 <ertes> testx_: how many arguments does 'id' take?
01:16:01 <testx_> 1
01:16:06 <ertes> > id sin 5
01:16:09 <lambdabot>  -0.9589242746631385
01:16:19 <ertes> testx_: do you see why this works?
01:16:29 <testx_> yeah i saw it after i typed
01:16:55 <ertes> id :: a -> a
01:17:02 <ertes> now let a = Double -> Double
01:17:10 <ertes> id :: (Double -> Double) -> Double -> Double
01:17:20 <ertes> now read jle` explanation again
01:19:19 <jle`> testx_: if f, g, and h are functions, then sequenceA [f,g,h] is also a function
01:19:37 <jle`> just like if x y and z are Maybe, then sequence [x,y,z] is a Maybe
01:19:56 <jle`> if x, y, and z are 'IO a', then sequenceA [x,y,z] is IO [a]
01:20:10 <jle`> so if f, g, and h are functions (r -> a), then sequenceA [x,y,z] is a function r -> [a]
01:20:57 <jle`> would it be more helpful to read it as (sequenceA [(> 3), (< 8), even]) 7 ?
01:21:26 <jle`> you're applying the function that `sequenceA [(> 3), (< 8), even]` returns to the number 7
01:22:27 <ertes> testx_: the important thing to keep in mind is that type variables can be instantiated as function types, because haskell doesn't view functions as special for the most part
01:23:00 <ertes> testx_: and the other thing is this rule: for all types A, B and C the notation "A -> B -> C" is equivalent to "A -> (B -> C)"
01:23:19 <Xlaech> now i am confused... i thought "id sin 5" would be invalid, since function application has the strongest binding. e.g (+1) (+) 3 4 does not work. But (+1) $ (+) 3 4 does..
01:23:39 <ertes> Xlaech: id sin 5 = (id sin) 5 = sin 5
01:23:42 <jle`> Xlaech: you are correct in your assumptions about binding
01:23:48 <jle`> id sin 5 is parsed as (id sin) 5
01:23:50 <ertes> Xlaech: there are no infix operators here
01:24:00 <Xlaech> ah i see. Thanks :)
01:24:00 <ertes> (except the invisible application "operator")
01:38:03 <hololeap> is there a way to embed a value into a type, for instance `data Thing a = a [a]; type TestThing = Thing 3 [Int]`
01:38:50 <hololeap> in other words make a constructor that has one of the values static
01:39:14 <liste> hololeap: do you mean "data Thing a = MkThing a [a]" ?
01:39:23 <hololeap> liste: yeah
01:39:42 <hololeap> or in this case "data Thing a = Thing a [a]"
01:40:25 <liste> hololeap: you can have "testThing :: [Int] -> Thing Int; testThing = Thing 3"
01:40:36 <hololeap> nvm
01:40:42 <hololeap> i just realized that same thing :)
01:40:55 <liste> you can't pattern match it though
01:41:27 <hololeap> that's ok for my purposes. i forgot to think of constructors as functions
02:05:04 <_sras_> jle`: Yes. I have a record A. I want a new record B, with most of the fields same as that of A. The new fields in B are functions of a subset of fields from A.
02:05:28 <jle`> yeah, lens wouldn't really help you with that
02:06:08 <_sras_> jle`: Is there anything that can help?
02:06:22 <jle`> you can make B contain an A
02:06:47 <_sras_> jle`: Using lens?
02:07:02 <jle`> no, like, as an ADT
02:07:25 <jle`> data A = MkA { aFoo :: Int, aBar :: Double }
02:07:36 <jle`> er i meant backwards
02:07:53 <jle`> if B has fields 'foo', 'bar'
02:07:59 <jle`> and A has fields 'foo', 'bar', 'baz'
02:08:06 <jle`> then A could just contain a B instead
02:08:42 <jle`> instead of data A = A { aFoo :: Int, aBar :: String, aBaz :: Double } and data B = B { bFoo :: Int, bBar :: String }
02:08:58 <jle`> you could have data A = A { aBSTuff :: B, aBaz :: Double }
02:09:33 <jle`> lens is...more or less completely unrelated to this
02:09:54 <jle`> (by 'more or less completely' i mean 'completely')
02:10:10 <_sras_> jle`: Yes. What is "isomorphic" when it comes to lenses?
02:10:22 <_sras_> I mean, what does it mean?
02:10:38 <merijn> _sras_: isomorphic in math means rough "losslessly convertible"
02:11:01 <jle`> in the context of Haskell, if X and Y are isomorphic, then you can write a function f :: X -> Y and g :: Y -> X
02:11:10 <jle`> and (f . g) = id, and (g . f) = id
02:11:17 <merijn> _sras_: In other words, A and B are isomorphic, if and only iff, every 'A' corresponds to a unique B, and every 'B' corresponds to a unique 'A'
02:11:58 <merijn> eh, "if and only iff" is rather redundant >.>
02:12:37 <jle`> if X and Y are isomorphic then Y is sort of "just another way of encoding" X, kinda
02:12:50 <jle`> the (X -> Y) and (Y -> X) functions are witnesses to that isomorphism
02:12:58 <_sras_> jle`: merijn clear. Thanks.
02:13:13 <jle`> re: lens, the lens library has some nice combinators for composing those witnesses
02:13:59 <jle`> if i have witnsses that X and Y are isomorphic, and witnesses that Y and Z are isomorphic, then i can also make witnesses that X and Z are isomorphic
02:14:56 <_sras_> jle`: What is a "Witness"?
02:14:58 <jle`> the combinators and the encodings of those witnesses are all really convenient and smooth to work with so that's kinda the neat thing, and also that they integrate very well with other things in haskell
02:15:07 <jle`> _sras_: i explained one line above that message
02:15:22 <jle`> but an (X -> Y) and a (Y -> X) functions are witnesses that X and Y are isomorphic
02:15:42 <jle`> like, i know that X and Y are isomorphic if i have functions that can convert between them
02:15:53 <_sras_> You said. those functions are witnesses. But I don't get what you mean by that.
02:15:54 <Zemyla> jle`: What if f . g = id, and f . g . f = f (which is weaker than g . f = id)
02:16:02 <merijn> _sras_: Side note: that definition does not disallow/rule out multiple isomorphisms between a pair 'A' and 'B', for example if I pick 'Integer' and 'Rational' I can define an isomorphism '(/4) :: Integer -> Rational' & '(*4) :: Rational -> Integer', but the same with (/2) and (*2) is obviously just as valid
02:16:19 <jle`> _sras_: you can think of that as me defining a vocabulary word
02:16:23 <jle`> that's what i'm defining "witness" to be
02:16:34 <merijn> _sras_: 'witness' roughly means 'proof'
02:16:42 <Zemyla> Kind of like read and show, except without errors, I'm thinking?
02:16:49 <_sras_> Oh. Alright.
02:16:50 <jle`> i could use another word, floopything, maybe
02:17:11 <jle`> if X and Y are isomorphic, then (X -> Y) and (Y -> X)'s are the floopythings associated with that isomorphism
02:17:20 <_sras_> jle`: :)
02:17:25 <jle`> and lens is a library that lets you manipulate and encode and work with the floopythings very easily :)
02:17:26 <Athas> centril: regarding your Idris and Agda comment tonight, even System F type inference is exponential.
02:35:20 <Habib> How would I simplify this minor monstrosity of an action?: http://lpaste.net/9152924913818927104
02:35:58 <merijn> Habib: Needs more where-clauses
02:36:59 <jle`> you can float out the return, too
02:37:18 <merijn> Habib: Also, what's the type of those things, since the 'maybe' and fromMaybe seems redundant
02:37:51 <Eduard_Munteanu> Habib, mRefererUrl <- header "Referer"; forM mRefererUrl $ \refererUrl -> do ...
02:38:25 <Habib> header "HeaderName" returns an ActionM (Maybe Data.Text,Lazy)
02:38:39 <Eduard_Munteanu> And if you have lots of maybes to chain you might just need MaybeT or the Maybe monad
02:38:43 <Habib> parseURI returns a Maybe URI
02:38:44 <jle`> yeah it looks like you never even use nullURI ?
02:39:05 <Habib> I use nullURI to ensure I get a straight Bool for the if statement
02:39:06 <merijn> Habib: Right, so why don't use the Monad instance of Maybe?
02:39:07 <jle`> at least for refererUrl
02:39:18 <Habib> Monad instance sounds like a good idea.
02:39:28 <qqwy> @src gcd
02:39:28 <lambdabot> gcd 0 0 = error "Prelude.gcd: gcd 0 0 is undefined"
02:39:29 <lambdabot> gcd x y = gcd' (abs x) (abs y)
02:39:29 <lambdabot>    where gcd' a 0 = a
02:39:29 <lambdabot>          gcd' a b = gcd' b (a `rem` b)
02:39:47 <jle`> Habib: btw, f <$> g <$> x = (f . g) <$> x
02:40:10 <Habib> ha, yeah, that makes sense.
02:40:35 <qqwy> Wow, when was the extra clause for gcd 0 0 added? :o
02:40:43 <jle`> so you might be able to simplify your forMaybe stuff easier
02:40:49 <qqwy> I distinctly remember sutumbling about the wrong result of `gcd 0 0' in the past
02:40:54 <qqwy> stumbling*
02:40:57 <jle`> using 'return' for 'Just' is also kind of confusing
02:41:01 <qqwy> Also: Good morning everyone :-)
02:41:06 <jle`> morning :)
02:41:13 <Habib> The return is to wrap it in an ActionM
02:41:20 <jle`> but is it, though?
02:41:30 <jle`> on lines 15, 16?
02:41:42 <jle`> it looks like return is 'Just' there
02:41:52 <Habib> Yeah, my bad.
02:41:56 <lpaste_> merijn annotated “sameHostReferer” with “sameHostReferer initial simplification” at http://lpaste.net/9152924913818927104#a353477
02:41:58 <Habib> Thought you were talking about the last lines.
02:42:06 <merijn> Habib: See that one
02:42:17 <merijn> Not 100% it typechecks, but you get the idea
02:42:29 <_sras_> Is there anyway to make Ghci stop output at the first error?
02:42:51 <Habib> Thanks, merijn.
02:44:49 <jle`> `f <$> Just x` is just `Just (f x)`
02:47:39 <Habib> `return $ Just . fromString . uriPath $ refererUrl` vs `return $ fromString <$> (Just $ uriPath refererUrl)`
02:48:02 <jle`> return $ Just (fromString (uriPath refererUrl))
02:48:09 <Habib> Ugh, brackets.
02:48:14 <jle`> you can float up thje return too
02:48:21 <merijn> I would leave the $ before referrerUrl, but remove the $ after return
02:48:24 <jle`> and just do Just (fromString (uriPath renderUrl))
02:48:41 <Habib> What do you mean by float up? Are you referring to wrapping the whole if statement in a return and removing the two returns?
02:48:43 <merijn> i.e. 'return . Just . fromString . uriPath $ refererUrl'
02:48:43 <jle`> or Just $ fromString (uriPath renderUrl) if you're averse to brackets
02:48:47 <jle`> yes
02:49:10 <jle`> `if x then f y else f g` is the same as f (if x then y else g)
02:49:26 <jle`> s/g/z
02:50:04 <jle`> you can also use guard if that's your fancy
02:50:25 <jle`> if p then Just y else Nothing   => Just y <* guard p
02:51:07 <Habib> I like your idea of floating the return, but it kind of messes with the indentation a little http://lpaste.net/9152924913818927104
02:51:32 <jle`> you do need to indent the then/else, yes
02:51:35 <merijn> Habib: That's solved my fixing your indentation to be less awful ;)
02:51:56 <Habib> Haha, it's true, current indentation is bad, anyway.
02:52:27 <jle`> i'd name the Bool something nice in a let statement
02:52:41 <Habib> mixing lets and wheres.
02:52:57 <jle`> it's a let inside a do block
02:52:59 <jle`> it's pretty common
02:53:01 <lpaste_> merijn annotated “sameHostReferer” with “sameHostReferer simplification round two (annotation)” at http://lpaste.net/9152924913818927104#a353478
02:53:19 <merijn> That's not perfect, but already better
02:53:21 <jle`> let's inside do block are different than let .. in ..'s
02:53:52 <jle`> and then you can do Just (fromString (uriPath refererUrl)) <* guard isValid
02:54:12 <merijn> jle`: I hear people say that, but I don't really see in what way they're diffrent, except for, like a tiny irrelevant syntactic detail?
02:54:50 <Habib> I think that's the best we'll get for now. I hate that refererUrl /= nullURI, as it's essentially a null check that's only there because of the fact that we had to extract the values from their Maybes.
02:55:00 <Habib> It's a sentinel value check.
02:55:09 <jle`> by 'different' there i meant different in that the hueirstics apply differently
02:55:16 <jle`> Habib: you can get rid of that by just using forM, as mentioned earlier
02:55:28 <Habib> Ah, I missed that, let me go back.
02:56:01 <merijn> Habib: Well, you could also handle this by removing the "maybeURI" for referrer and handling this in an explicit case
02:57:08 <Habib> I thought about a case statement when I was initially deciding between case or if, but I figured it wouldn't work (when I looked at the ZVON example).
02:57:36 <jle`> if you get refererUrl before the 'fromMaybe'
02:57:46 <jle`> you can forM :: Maybe a -> (a -> IO b) -> Maybe b
02:58:01 <jle`> that is, if refererUrl is Nothing, then just short-circuit and return Nothing
02:58:08 <jle`> otherwise do stuff on the insides
02:58:27 <jle`> oh but hm, that way you wouldn't be able to return a Nothing further inside
02:58:50 <Habib> But wouldn't the signature have to be something like forM :: Maybe a -> (a -> IO b) -> IO (Maybe b)?
02:59:00 <jle`> yes, you're right, that's a typo on my part
02:59:31 <jle`> but it might not fit perfectly in this situation because you want to be able to further Nothing it all inside the (a -> IO b)
03:00:07 <jle`> so explicit case matching is probably the better way.  unless you want to go all the way and use MaybeT
03:01:45 <Habib> https://www.youtube.com/watch?v=T-sxSd1uwoU&t=1m17s
03:02:22 <lpaste_> jle` annotated “sameHostReferer” with “sameHostReferer simplification round two (MaybeT)” at http://lpaste.net/9152924913818927104#a353480
03:02:32 <jle`> the whole thing actually kinda cleans up nicely w/ MaybeT
03:02:40 <jle`> fsvo nicely
03:03:20 <jle`> because then the guard can go in as a normal MaybeT action
03:04:03 <Habib> I've never understood the SomethingT convention (how it works, anyway).
03:04:09 <jle`> and fromMaybe for the host header was always just a perverted version of <|> anyway
03:04:12 <Habib> I need to understand MaybeT first
03:04:26 <jle`> Habib: are you familiar with newtype wrappers to give things different instances?
03:04:34 <Habib> Yes.
03:04:38 <Habib> But not intimately.
03:04:39 <jle`> like how we can use the 'Sum' newtype wrapper to give Int its own Monoid instance that is addition
03:04:44 <jle`> > Sum 10 <> Sum 11
03:04:47 <lambdabot>  Sum {getSum = 21}
03:04:48 <Habib> I don't use newtype, really.
03:04:48 <jle`> > Product 10 <> Product 11
03:04:52 <lambdabot>  Product {getProduct = 110}
03:05:09 <jle`> by adding a newtype wrapper, we can give things different and sometimes more useful typeclass instances
03:05:11 <Habib> Yes, I understand all that, but I don't use newtype, so I may be rusty.
03:05:20 <hydraz> newtype is good
03:05:28 <jle`> MaybeT is a newtype wrapper that gives us a useful instance in this case
03:06:01 <jle`> it's a 'MaybeT Action a' is a newtype wrapper over 'Action (Maybe a)' that gives us a useful Monad and Alternative instance
03:06:11 <jle`> namely, that >>= respects the Maybeness of everything
03:06:23 <jle`> 'guard' is a short-circuit Nothinger
03:06:27 <jle`> and <|> is "error recovery"
03:06:46 <Habib> Huh, but isn't ActionM just type ActionM = Web.Scotty.Internal.Types.ActionT Data.Text.Internal.Lazy.Text IO
03:06:57 <jle`> maybe, but that isn't too relevant here
03:07:08 <jle`> all we really wanted to do was build an ActionM (Maybe referrer)
03:07:28 <jle`> and MaybeT is a way to build one nicely
03:07:29 <Habib> Okay, I see; I'm just trying to understand what the T convention stands for.
03:07:48 <jle`> ah, the T usually means monad transformer
03:08:06 <jle`> but you don't need to understand monad transformers to use MaybeT as it applies here
03:08:07 <Habib> Ah, okay.
03:08:34 <jle`> basically, normally, for IO, (>>=) :: IO a -> (a -> IO b) -> IO b
03:08:43 <Habib> I think I vaguely understand monad transformers. They transform monads so that you can work across monads, right?
03:08:52 <jle`> MaybeT lets us have a much more interesting instance, (>>=) :: IO (Maybe a) -> (a -> IO (Maybe b)) -> IO (Maybe b)
03:09:04 <jle`> it lets you have a (>>=) that "respects" nothingness
03:09:10 <jle`> and lets you short-circuit your IO actions
03:09:53 <Habib> Okay, and where does `guard` get imported from?
03:10:02 <jle`> Control.Applicative i think?  or Control.Monad
03:10:46 <jle`> guard is "fail here and return Nothing right away if the predicate is False"
03:10:51 <hydraz> Applicative.
03:11:41 <Habib> Yep, I see. BTW, Hoogle says Control.Monad.
03:13:31 <jle`> with `MaybeT Action a`, you're basically working with `Action (Maybe a)`s, except you get nice combinators like <|> and guard and a new '>>='
03:14:01 <ezyang> Do people think that http://hs01.scs.stanford.edu:8000/dist/doc/html/str-sig/Str.html should have a more clear marking saying that this is a signature? 
03:14:01 <jle`> (<|>) :: Action (Maybe a) -> Action (Maybe a) -> Action (Maybe a), now.  guard :: Bool -> Action (Maybe a)     (with the newtype wrapper unwrapped)
03:14:19 <ezyang> If so, where should it be? Str (Signature) in the title? 
03:21:24 <lpaste_> ChewieBeardy pasted “Evalexpr on QuickCheck” at http://lpaste.net/353481
03:21:40 <ChewieBeardy> oh wow, didn't have the time to ask my question :P
03:21:48 <ChewieBeardy> that bot is quicker than me
03:22:23 <ChewieBeardy> anyway, hi guys :D I'm trying to play with QuickCheck, and I was thinking of verifying a simple evalexpr program
03:22:29 <merijn> ChewieBeardy: Right, that property is not really sensible
03:23:08 <ChewieBeardy> yeah, as soon as I thought about building up the arbitrary definition, I realized I'd need to "build up" the associated n along with it, which essentialy was recoding the eval function
03:23:16 <Habib> jle I'm curious, how does guard short-circuit for IO? I can see how it would do it for Maybe, just give back Nothing (which is empty for Alternative Maybe) and all further binds are ineffectual. But what IO action exists where further binds are ineffectual?
03:23:26 <ezyang> raises an exception 
03:23:38 <Habib> Ah, that makes sense.
03:23:41 <jle`> Habib: for IO it raises an exception yes
03:23:44 <ezyang> >> mfail :: IO () 
03:23:45 <merijn> ChewieBeardy: For property based testing (like QuickCheck) you wanna think along the lines of: "prop_add_commutative :: Expr -> Expr -> Bool; prop_add_commutative e1 e2 = eval (Add e1 e2) == eval (Add e2 e1)"
03:23:51 <ezyang> > mfail :: IO () 
03:23:54 <lambdabot>  error:
03:23:54 <lambdabot>      • Variable not in scope: mfail :: IO ()
03:23:55 <lambdabot>      • Perhaps you meant ‘fail’ (imported from Control.Monad.Writer)
03:23:55 <jle`> but for `MaybeT IO`, it returns Nothing
03:24:08 <ezyang> > guard False (return ()) :: IO () 
03:24:08 <Habib> Understood.
03:24:11 <lambdabot>  error:
03:24:11 <lambdabot>      • Couldn't match type ‘()’ with ‘IO ()’
03:24:11 <lambdabot>        Expected type: m0 () -> IO ()
03:24:22 <ezyang> > guard False :: IO () 
03:24:23 <merijn> ChewieBeardy: Naah, don't think along lines of "generate associated 'n'', think along lines of "what properties can I state about just expressions?
03:24:27 <lambdabot>  <IO ()>
03:24:32 <ezyang> sigh :) 
03:24:34 <merijn> i.e., like the commutativity of Add I just gave
03:24:35 <ChewieBeardy> hm I see
03:24:37 <jle`> the behavior of 'guard' is meant to be interpreted alongside the behavior of (>>=)  (and (<|>))
03:25:03 <ChewieBeardy> so properties of the structure, but not properties of the "reduction" of the structure into a value
03:25:05 <merijn> ChewieBeardy: Or how about "sub_prop e1 e2 = eval (Sub e1 e2) == eval e1 - eval e2"?
03:25:29 <jle`> ezyang: do you mean a signature as opposed to an empty data decl?
03:25:51 <ChewieBeardy> those are good ideas, thanks merijn 
03:26:16 <merijn> ChewieBeardy: "equal_sub e = eval (Sub e e) == 0", endless options :)
03:26:31 <ezyang> jle`: I mean signature 
03:26:32 <ChewieBeardy> so a rule of thumb would be to have properties where the structure exists on both sides
03:26:35 <ezyang> as in, Backpack signature 
03:26:43 <ezyang> (taking down server briefly) 
03:26:50 <merijn> ChewieBeardy: I just ruined your rule of thumb with that last suggestion ;)\
03:26:55 <ChewieBeardy> indeed :P
03:27:10 <jle`> yeah, i would normally interpret that an opaque data type if i read it now
03:27:35 <ChewieBeardy> so, would a "leaf case" property like prop_value e@(Value n) n = eval e == n make sense?
03:27:43 <ezyang> new link is http://hs01.scs.stanford.edu:8000/str-sig/dist/doc/html/str-sig/Str.html 
03:27:54 <ezyang> jle`: Sorry, I'm not talking about the Str type; I'm talking about the model header up top 
03:27:59 <ezyang> *module 
03:28:19 <merijn> ChewieBeardy: Well, that's not a valid definition, but "prop_value :: Int -> Bool; prop_value n = eval (Value n) == n" would be reasonable
03:28:47 <merijn> ChewieBeardy: Mainly you just wanna avoid your properties relying on complex relations between your input arguments, like your original example did
03:29:12 <merijn> ChewieBeardy: As you can see, if you start thinking about the rules of expressions you can probably think of a dozen properties based on my suggestions for all of those :)
03:29:24 <ChewieBeardy> yeah, you opened up a whole world for me :D
03:29:26 <ChewieBeardy> thank you so much
03:30:06 <ChewieBeardy> I'm trying to build up a small workshop for colleagues who want to discover functional programming, me included, so this kind of stuff is gonna work wonders
04:06:39 <teshe> hello who is online here
04:09:08 <ph88_> you and 1472 others
04:11:40 <ongy> now it's just 1472 others
04:23:10 <tomboy64> i'm trying to wrap my head around applicative functors, but don't get why https://paste.pound-python.org/show/GiFHYiid1EOlrrwvaBkP/   doesn't work
04:23:20 <tomboy64> could someone enlighten me?
04:24:34 <suppi> tomboy64: why are you using <$>?
04:25:12 <tomboy64> because i am working under the assumption that t will be an IO String?
04:25:22 <tomboy64> is that wrong?
04:25:51 <srhb> tomboy64: getLine is IO String, t is String
04:25:59 <tomboy64> doh
04:26:36 <suppi> t <- getLine; f t is syntactic sugar for getLine >>= \t -> f t
04:26:59 <suppi> check the type of >>= :)
04:27:31 <tomboy64> yes
04:27:39 <tomboy64> ugh
04:29:02 <Cooler> is this ide real? http://simonmar.github.io/bib/papers/vshaskell.pdf
04:29:06 <suppi> you can do: result <- doubleIt <$> getLine :)
04:29:17 <Cooler> they don't give a download link
04:30:50 <suppi> which year is this from? emacs does a lot better than that :)
04:31:12 <tomboy64> thanks. it's beginning to clear up a little.
04:33:49 <suppi> note that <$> is fmap
04:34:00 <tomboy64> yes, that i know
04:34:28 <tomboy64> and i also get the notion it pushes a function into a monad and applies its value
04:35:25 <tabaqui1> #join archlinux
04:35:33 <tabaqui1> oups
04:35:35 <tabaqui1> sorry
04:48:56 <_sras_> Is there a function in lens library that accept a template haskell's Dec, representing a Data type definition, instead of a Name and make lenses for it?
04:51:16 <lyxia> _sras_: _DataD
04:53:25 <_sras_> lyxia: Didn't get you.
04:53:48 <lpaste_> Vzox01 pasted “Can I do anything with Constrs?” at http://lpaste.net/353484
04:54:29 <Vzox01> Hello, everyone! I'm having a problem with understanding whether I can achieve something with syb and Data.Data, I
04:54:45 <Vzox01> I've posted my question here: http://lpaste.net/353484
04:55:26 <ertes> is suppose there is no way to make GHCi support *.hsc files?
04:56:19 <ertes> i need to use a bunch of linux APIs, and it would be nice, if i could hack that support interactively
04:57:49 <merijn> ertes: You can make ghci load object code (I forget how), but that doesn't solve the issue of needing to compile before loading into ghci
04:58:46 <ertes> i wouldn't mind compiling
04:58:54 <lyxia> _sras_: Sorry I totally misunderstood you.
04:59:15 <merijn> ertes: Then consult the GHC manual on how to make ghci load object code
04:59:33 <_sras_> lyxia: It is alright. I got the answer.
05:00:27 <_sras_> lyxia: declareLensesWith :: LensRules -> DecsQ -> DecsQ, was what I was after, I think so.
05:01:11 <ertes> merijn: actually that sounds like a good idea…  GHCi will load *.o automatically, if it's newer than the corresponding source file
05:01:14 <lyxia> _sras_: right
05:07:05 <lyxia> Vzox01: you can use fromConstrM with State
05:08:05 <lyxia> Vzox01: Have you considered GHC.Generics instead though
05:08:17 <lyxia> It's much safer.
05:08:45 <Vzox01> lyxia: no, I don't know anything about Generic programming :) just learning
05:10:05 <lyxia> Vzox01: GHC.Generics is the modern approach to generic programming in Haskell.
05:10:56 <Vzox01> lyxia: alright, I'll research it, thank you! the only other library that I tried was uniplate, but I couldn't find a way to do what I wanted with it
05:12:36 <lyxia> Vzox01: the documentation contains a short tutorial http://hackage.haskell.org/package/base-4.9.1.0/docs/GHC-Generics.html
05:15:22 <tomboy64> suppi, could you help me again? my original intention was to a) get an input (number) which triggers (number) loops of requesting multiple (n) lines of input, which then again should be shoved into a function f to be processed.
05:15:59 <tomboy64> so, using >>= can i chain getLine somehow n times to apply to a function f?
05:17:58 <suppi> not entirely sure i understood that. if you could write a type signature for that it would help :)
05:18:24 <ongy> tomboy64: you may be interested in replicateM
05:19:05 <tomboy64> f :: String -> String -> String -> Int
05:19:21 <tomboy64> with the strings coming from 3 getLine calls
05:19:29 <tomboy64> ongy: looking at it
05:20:09 <dramforever> tomboy64: is '3' from input or constatnt (known in advance)?
05:20:30 <Rembane> tomboy64: Have you checked out repeatM?
05:20:32 <ongy> tomboy64: you can do [String] -> Int, 'String -> String -> String -> Int' states that you need 3 lines already, so why would ask for the linecount befor that?
05:20:32 <tomboy64> 3 is constant
05:20:33 <Rembane> :t repeatM
05:20:37 <lambdabot> error:
05:20:38 <lambdabot>     • Variable not in scope: repeatM
05:20:38 <lambdabot>     • Perhaps you meant one of these:
05:20:40 <Rembane> Bah
05:20:43 <Rembane> :t replicateM
05:20:46 <lambdabot> Applicative m => Int -> m a -> m [a]
05:20:53 <Rembane> tomboy64: I meant replicateM
05:21:27 <tomboy64> ongy: i'm not asking for the linecount before, i'm asking for the repetition of the whole thing, n*(3 linecounts+stdouts)
05:21:43 <ongy> oh, so you want to read n*3 lines after that?
05:21:59 <tomboy64> replicateM seems to do what i want. now lets experiment.
05:22:06 <tomboy64> ongy: correct
05:22:14 <dramforever> f :: String -> String -> String -> Int
05:22:40 <ongy> ah, that still works fine with replicateM, you can put the entirety of getting the 3 lines and then running your function into the argument if you want to
05:22:59 <Rembane> For instance: (read <$> getLine) >>= \n -> replicateM n getLine >>= f
05:23:02 <dramforever> Note: Using replicateM loses information, that the function is called with 3 String's
05:23:37 <dramforever> :t let f = undefined :: String -> String -> String -> Int in liftA3 f getLine getLine getLine
05:23:39 <lambdabot> IO Int
05:23:56 <dramforever> liftA3 f getLine getLine getLine -- This is what I would recommend
05:24:32 <quchen> bitonic: After knowing your nick for umm years, I just found out who you are. And that’s why I always write my nick on my name badges at conferences haha
05:24:55 <merijn> quchen: See, I'm easy to spot at conferences! :p
05:25:15 <merijn> If your nick is your name, there's never any confusion! (Until you have multiple people with the same name...)
05:25:17 <quchen> merijn: I haven’t spotted you on any yet
05:25:36 <merijn> In which cases the David's are a bit overrepresented, I guess :p
05:25:47 <tomboy64> dramforever: hehehe something new to read up about... never got into contact with lift before
05:25:53 <merijn> quchen: I hope to sucker my supervisor into paying for ICFP this year :p
05:25:53 <tomboy64> thanks so far, folks
05:26:06 <dramforever> tomboy64: It's an Applicative thingy
05:26:13 <dramforever> :t liftA3
05:26:18 <lambdabot> Applicative f => (a -> b -> c -> d) -> f a -> f b -> f c -> f d
05:26:26 <dramforever> It's like f <$> getLine <*> getLine <*> getLine
05:26:33 <dramforever> but pre-packaged into one function
05:26:36 <ongy> merijn: merijn is your name?
05:26:41 <merijn> ongy: Yeah
05:26:57 <tomboy64> which is what my original plan was. your latter line.
05:27:05 <ongy> I wonder if people would notice who I am...
05:27:06 <quchen> My name is »quchen«, but my passport lists another name.
05:27:34 <quchen> (That name is also my name, it’s not like I’m trying to hide it. But when people talk about cake in German it’s awkward.)
05:28:46 <ongy> quchen: remind me to bring you some Kuchen if I ever meet you
05:28:59 <quchen> I will! How do I recognize you? :-D
05:30:19 <lyxia> Vzox01: BTW to get Add :: Int -> Command from its constr (= toConstr (Add undefined)):   \n -> fromConstrB (fromJust (cast n)) constr.  The cast is safer than fromConstr . toConstr.
05:30:35 <lyxia> Vzox01: it becomes fairly annoying if your constructor has more fields.
05:32:43 <tomboy64> for later use: is there an easy way to make replicateM strict? e.g., make sure it only continues processing my program when all results are collected?
05:33:18 <dramforever> tomboy64: The e.g. part: yes it does
05:33:39 <dramforever> it's exactly like you said
05:33:46 <tomboy64> nice, thanks!
05:35:11 <ongy> quchen: search for people that have ongy in their name :)
05:36:59 <bitonic> quchen: aha, I did tell you who I am a couple of times though
05:37:00 <quchen> ongy: ZuriHac is my next Haskell conference :-)
05:37:11 <bitonic> But I guess a badge is better
05:37:22 <quchen> bitonic: You did? Ohhhh
05:37:28 <bitonic> quchen: I think so yeah
05:37:37 <bitonic> See you at ZuriHac BTW
05:37:39 <quchen> I’ll show myself out then, in shame :-)
05:37:40 <quchen> Yeah!
05:38:20 <bitonic> Apparently there will be like 300 people lol
05:38:25 <bitonic> Although no sausage and beer for breakfast
05:38:35 <_sras_> What does the `declareLensesWith` function of the lens library include the Record dec passed in as its argument in the output? How to make it stop doing that?
05:38:45 <_sras_> s/What/Why
05:38:57 <quchen> bitonic: Käsefondue for breakfast!
05:39:12 <bitonic> That would be hardcore lol
05:40:00 <quchen> I don’t think Haskell’s type system is strong enough to catch all the bugs a horde of whining full-of-cheese programmers would produce during the day
05:40:13 <bitonic> Cheese mixed with alcohol
05:41:10 <quchen> Not much though. I dare you to get drunk from Käsefondue.
05:46:42 <tdammers> Haskell's type system is strong enough to require a horde of cheese-laden programmers in order to make serious bugs though
05:47:18 <ongy> it's not hard to make bugs
05:47:53 <tdammers> well, that was obviously tongue-in-cheek
05:47:57 <ongy> how many functions are completly defined by their type alone? 'id :: a -> a' I think, anything else?
05:48:21 <quchen> ongy: Lots!
05:48:23 <quchen> :t uncurry
05:48:25 <quchen> :t curry
05:48:26 <lambdabot> (a -> b -> c) -> (a, b) -> c
05:48:28 <lambdabot> ((a, b) -> c) -> a -> b -> c
05:48:30 <quchen> :t const
05:48:30 <tdammers> fmap
05:48:32 <lambdabot> a -> b -> a
05:48:33 <tdammers> (almost)
05:48:59 <quchen> The Functor laws are not in fmap, but they’re critically important, so I don’t think that one counts
05:49:17 <quchen> I think >>= for Cont is also unique
05:49:29 <ongy> oh, right there's a lot
05:49:33 <tdammers> anyway, the grain of truth I was hinting at is that maneuvring yourself into a situation where it's easy to accidentally introduce bugs and not notice them until they're in production is rather difficult in Haskell
05:49:48 <ongy> oh suddenly there's and accidentally :)
05:49:55 <quchen> ((a -> r) -> r) -> (a -> (b -> r) -> r) -> (b -> r) -> r
05:49:57 <tdammers> :)
05:49:59 <quchen> That should be it :-)
05:49:59 <tdammers> yes
05:50:02 <tdammers> that's the "tongue-in-cheek" part
05:52:12 <ongy> continuation monad is great
05:52:49 <quchen> <*> for Reader is unique (= the S combinator)
05:52:57 <quchen> So is K
05:53:08 <quchen> s f g x = f x (g x)
05:53:13 <quchen> k x y = x
05:53:21 <quchen> :t \f g x -> f x (g x)
05:53:23 <lambdabot> (t2 -> t -> t1) -> (t2 -> t) -> t2 -> t1
05:53:26 <quchen> :t \x y -> x
05:53:28 <lambdabot> t -> t1 -> t
05:54:32 <quchen> I’m not sure how to prove that a type has a unique implementation though. (Neither in Haskell-without-⊥ nor in stronger/other type systems.)
05:57:20 <Acer> anyone have the haskell programming from first principles book?
05:58:14 <ongy> when I wanted to make a monad instance that wraps callbacks, I wanted to look up the Continuation monad instance, but I kind of failed doing that, I only found a bunch of transformers, but couldn't really find the source for those either :(
05:58:56 <quchen> ongy: http://www.haskellforall.com/2014/04/how-continuation-monad-works.html
06:00:28 <Acer> need help with the state monad chapter of that book
06:00:40 <Acer> how does this work,   intToDie <$> state (randomR (1, 6))
06:00:51 <quchen> <$> is fmap.
06:01:22 <quchen> So this is equivalent to »do { foo <- state (randomR (1,6)); pure (intToDie foo) }«.
06:01:34 <quchen> (pure = return, if you’re wondering.)
06:02:16 <ongy> quchen: my problem wasn't understanding it, I just didn't find the code I was searching for. https://hackage.haskell.org/package/mtl-2.2.1/docs/src/Control.Monad.Cont.Class.html#MonadCont isn't that helpful
06:03:01 <Acer> quchen, how is fmap using the monadic bind?
06:03:06 <Acer> from the do notation
06:03:12 <ongy> ahh, just found it. I had to search for callCC not for the lifting functions. That makes more sense
06:03:24 <quchen> Acer:    fmap f mx = do { x <- mx; pure (f x) }
06:03:34 <quchen> :t fmap
06:03:37 <lambdabot> Functor f => (a -> b) -> f a -> f b
06:03:46 <quchen> :t \f mx -> do { x <- mx; pure (f x) }
06:03:49 <lambdabot> Monad m => (t -> b) -> m t -> m b
06:04:20 <Acer> quchen, the type class constraint on fmap is Functor not Monad
06:04:33 <Acer> so how can you use bind
06:04:43 <Acer> and return
06:04:45 <quchen> Acer: But every Monad is also a Functor. Just like every Ord is also an Eq.
06:04:54 <quchen> So you can use fmap in every monadic context. :-)
06:05:12 <Acer> what? no we are talking about a functor context
06:05:28 <quchen> :t [fmap, \f mx -> do { x <- mx; pure (f x) }] -- See, they’re compatible. We can put them both into the same list.
06:05:32 <lambdabot> Monad f => [(a -> a1) -> f a -> f a1]
06:06:07 <Acer> when you write the functor instance and implement fmap, you can't use the monadic bind
06:06:11 <quchen> Acer: Oh, I get it, you meant that my do-solution is more special than your <$> solution.
06:06:15 <quchen> That’s correct.
06:06:37 <quchen> But I thought maybe the do-notation helps understanding what happens, assuming your thing is also a monad.
06:06:49 <quchen> If it’s not also a monad, you can’t use do-notation, that’s right.
06:06:55 <quchen> (Up to experimental language extensions)
06:07:28 <Acer> so how did <$> turn into do notation?
06:07:41 <Acer> in intToDie <$> state (randomR (1, 6))
06:07:43 <quchen> (<$>) = fmap, by definition.
06:07:57 <quchen> And if you have a monad, you can implement fmap in terms of it.
06:08:17 <quchen> instance Functor Foo where fmap f mx = do { x <- mx; pure (f x) }
06:08:17 <Acer> no you have to implement functor and applicative first
06:08:34 <quchen> No you don’t. All instances have to be there, but not in order :-)
06:08:39 <Acer> before you implement monad
06:08:49 <quchen> Yup. https://github.com/quchen/articles/blob/master/fbut.md#reversed-type-class-instances
06:09:25 <quchen> Well, nope. Depending on what you mean. Anyway, look at the link above. 
06:10:32 <quchen> Acer: There are plenty of Functor instances in GHC itself that have the default Functor instance I wrote above. Source: I wrote them ;-)
06:11:23 <quchen> Sometimes it’s easy to implement the monad, and then just copy+paste the Functor/Applicative definitions to save some time and thinking.
06:11:51 <quchen> For example, if you have a lawful Monad, you also have a lawful Functor and Applicative if you just use »fmap = liftM, pure = return, <*> = ap«. :-)
06:12:17 <quchen> (The downside is that Functor and Applicative often have more efficient, but semantically equivalent, definitions for fmap etc.)
06:12:39 <Acer> in intToDie <$> state (randomR (1, 6))      is   state (randomR (1,6)) of type
06:13:03 <Acer> State StdGen Int ?
06:13:20 <quchen> Yes, that is plausible.
06:13:57 <quchen> state (randomR (1,6)) carries the generator state, and returns an Int (in range [1,6]) when performed.
06:13:59 <Acer> and it has a function of type  StdGen -> (Int, StdGen) inside it
06:14:11 <quchen> Yes.
06:14:28 <Acer> so how does it make sense to fmap over that?
06:14:45 <Acer> i mean you need 2 fmaps
06:14:59 <Acer> or something
06:15:39 <Acer> one fmap to lift over the State monad and one to lift over the function inside it, since intToDie takes Int as argument
06:16:02 <Acer> in fact that might not be even enough
06:16:18 <quchen> Acer: State is the only functor here, we don’t have to scope »into the function«.
06:16:33 <quchen> Somewhere, there’s a definition of what it means to »fmap over a State«.
06:16:43 <Acer> quchen, intToDie needs a Int
06:17:01 <quchen> Agreed.
06:17:19 <quchen> fmap needs an (a -> b) and an (f a), where f has a Functor instance.
06:17:31 <quchen> (State s) has a Functor instance.
06:17:39 <Acer> if you fmap over the State monad you get the value inside which is a function of type StdGen -> (Int, StdGen)
06:17:44 <Acer> thats not an int
06:17:58 <Acer> so you need to fmap again
06:18:21 <quchen> No, fmap does not »unwrap« the State! fmap for State has type (a -> b) -> State s a -> State s b
06:18:37 <quchen> The purpose of fmap is not having to look into the State at all! :-)
06:18:50 <quchen> It just says »I’ll transform the a to a b there and that’s it«
06:19:48 <quchen> »unwrapping« the State to give you the »StdGen -> (Int, StdGen)« is what »runState« does, but that’s entirely unrelated to monads, it’s a special function that only exists for State.
06:20:30 <Acer> i think i get it
06:20:45 <quchen> fmap :: Functor f => (a -> b) -> f a -> f b. The key realization here is that (State s) is a suitable choice for (f).
06:21:01 <quchen> And then you can stop thinking because it is already baked into the fmap :-D
06:21:27 <quchen> The point of fmap is so you don’t have to worry about mangling the state, passing it on to the right places and what not.
06:21:42 <quchen> You can use State without fmap etc, but it’s a terrible experience of variable twiddling.
06:21:47 <Acer> rollDie' = intToDie <$> state (randomR (1, 6))
06:21:53 <Acer> liftA3 (,,) rollDie rollDie rollDie
06:21:58 <Acer> what about that ^
06:22:44 <quchen> liftA3 is like multi-fmap. fmap takes a unary function and one value; liftA3 takes a ternary function and three values.
06:22:46 <quchen> :t fmap
06:22:48 <quchen> :t liftA3
06:22:50 <lambdabot> Functor f => (a -> b) -> f a -> f b
06:22:53 <lambdabot> Applicative f => (a -> b -> c -> d) -> f a -> f b -> f c -> f d
06:23:07 <quchen> »n-ary fmap« is precisely what Applicative is good for.
06:23:15 <Acer> is f =  StdGen -> 
06:23:16 <quchen> (pure is 0-ary fmap.)
06:23:24 <quchen> f = State StdGen
06:23:31 <Acer> ok
06:23:36 <quchen> f Int = State StdGen Int
06:24:15 <quchen> liftA3 (,,) :: Applicative f => StdGen Int a -> StdGen Int b -> StdGen Int c -> StdGen Int (a,b,c)
06:25:15 <Acer> i think its f Die = State StdGen Die in this case
06:25:26 <Acer> since rollDie' :: State StdGen Die
06:25:56 <quchen> Since State is also a Monad, you can write it using do-notation instead, which I often find a bit clearer.
06:25:56 <quchen> do { x <- rollDie; y <- rollDie; z <- rollDie; pure (x,y,z) }
06:25:58 <quchen> Yup
06:28:52 <Acer> yeah thats way more obvious
06:38:08 <suica> any other collections of problems like https://wiki.haskell.org/H-99:_Ninety-Nine_Haskell_Problems, maybe a bit more difficult?
06:38:43 <codedmart> I am not sure if this makes sense. I am not sure the best way to explain it, but how do you do something along these lines in Haskell: https://gist.github.com/codedmart/5a4e5871b88ec27cc6dc53f7debeda46
06:40:13 <cocreature> suica: hackerrank has a lot of challenges of varying difficulty and you can use haskell for most of them
06:42:01 <cocreature> codedmart: one way is to use "data AnotherPartialOfType = Some | SomePartial SomePartialOfType". whether that makes sense depends on your application. in most cases I would probably just keep the types completely separate and prefix the names to avoid collisions
06:45:15 <codedmart> cocreature: I am writing an Api using Servant and want to only allow certain `SomeType` on certain routes. Not sure I understand how your suggestion would help.
06:47:33 <cocreature> codedmart: if you are using servant, can’t you just use SomeType, DataKinds to get types for each constructor and then have a list of kind [SomeType] that shows the allowed content types?
06:47:49 <cocreature> similar to the list of content types servant uses
06:48:32 <codedmart> @cocreature Possibly, not knowledgable on DataKinds at the moment :). I will look into that.
06:48:33 <lambdabot> Unknown command, try @list
06:49:18 <cocreature> codedmart: you don’t need DataKinds, you can just use "data Some = Some", "data Other = Other", and so on and then have a list of kind [*]
06:49:38 <cocreature> I guess you don’t even need the constructor "data Some" should work
06:50:04 <suica> cocreature: thanks!
06:54:18 <quchen> suica: Write a function that splits a list in two parts of equal length (±1 element) that works even for infinite lists
06:55:01 <quchen> splitHalf [1..] = ([1..], ⊥)
06:55:21 <quchen> splitHalf [1..10] = ([1..5], [6..10])
06:57:48 <quchen> For finite lists,   splitHalf xs = splitAt (length xs `div` 2) xs
06:58:00 <cocreature> that’s a nice exercise :)
07:00:58 <merijn> quchen: Now you have me wondering whether my splitHalf works for that case
07:01:31 <erisco> now split an infinite list in half
07:01:44 <merijn> I don't think it does :\
07:01:57 <Acer> i would expect this to throw an error saying theres no monad instance but thats not the error i get http://lpaste.net/353492
07:02:33 <erisco> what error do you get?
07:02:36 <Acer> http://lpaste.net/353494
07:02:40 <quchen> Type mismatch, I guess
07:02:51 <merijn> Sadly, I don't think I can make my efficient split work for infinite lists
07:03:05 <erisco> splitting infinite lists in half is trivial
07:03:28 <quchen> merijn: What’s your effective split?
07:03:59 <merijn> quchen: Well, not sure if it's actually efficient compared to foldr/build fusion, but it was to demonstrate some simple things anyway: https://gist.github.com/merijn/c163cc106fd245d1cf2e
07:04:48 <erisco> Acer, I suppose it prioritises that error because it finds instances later
07:04:49 <quchen> merijn: Split via DList?
07:05:16 <merijn> quchen: + tortoise and hare, yeah
07:05:31 <quchen> Tortoise and hare is what makes my puzzle work as well
07:05:48 <merijn> quchen: Yeah, if you rip out the DList you can make it work :)
07:06:31 <erisco> Acer, g is a function, remember, so think about what  (a, s) <- g  is
07:06:49 <quchen> Gotta go!
07:08:06 <Acer> erisco, i have seen some cases where they do     value <- function
07:08:48 <erisco> (->)a is a Monad, so you may have seen that used, sure
07:09:00 <Acer> i think its something like    \x -> g x >>= \y -> ...
07:09:19 <erisco> how much do you know about Monad?
07:10:07 <erisco> well I'll make it easier. You don't need anything Monad related to write fmap
07:11:54 <erisco> start this way... fmap f (Moi g) = p  what type does p have?
07:14:00 <Acer>     fmap f (Moi g) = Moi $ \s -> let (a, s) = g s
07:14:01 <Acer>                                  in (f a, s)
07:14:07 <Acer> well that compiles
07:15:51 <Acer> erisco, where do i get runMoi
07:15:57 <Acer> runMoi ((+1) <$> pure 0) 0
07:16:13 <Acer> oh nvm
07:16:40 <erisco> are you following a tutorial? that is a confusing question
07:17:01 <Acer> erisco, i am following the book
07:17:24 <Acer> i get a weird error
07:17:28 <erisco> which book? we don't have just one
07:17:36 <Acer>     * Non type-variable argument in the constraint: Applicative (Moi s)
07:17:52 <Acer> when i do runMoi ((+1) <$> pure 0) 0
07:17:59 <erisco> you need FlexibleContexts or something I imagine. the error message will tell you
07:18:02 <Acer> haskell programming from first principles
07:18:13 <Acer> erisco, yeah it says that
07:18:19 <Acer> whats that about
07:18:21 <sphinxo> is there a name for a function that has all it's arguments applied, yet it hasn't been evaluated yet?
07:19:00 <merijn> sphinxo: Not really, because that's not something observable in Haskell
07:19:02 <erisco> there is an official Haskell spec (called "The Haskell YYYY Language Report"), either 1998 or 2010
07:19:13 <erisco> GHC is a compiler which implements this spec, but it also adds a bunch of features
07:19:33 <erisco> so to get those other features you have to enable them
07:20:08 <sphinxo> ok thanks, what about the name of a function that you map with
07:20:43 <Cale> Nothing special
07:21:08 <sphinxo> functions are functions I guess
07:21:14 <Cale> sphinxo: btw, it can be a little bit unclear what "all its arguments" actually refers to
07:21:37 <erisco> @remember sphinxo functions are functions I guess
07:21:38 <lambdabot> Okay.
07:21:45 <Cale> Every function in Haskell has exactly one parameter, and those which appear to have more are really just producing other functions as their result
07:22:07 <Cale> The compiler may (and does, fairly aggressively) optimise this
07:22:17 <erisco> um, well, there is sort of something like sphinxo is talking about, and that is constructors
07:22:28 <Cale> But conceptually at least, you only ever supply one argument to a function.
07:22:31 <Acer> erisco, whats flexible contexts and why do i need it
07:23:24 <Cale> Acer: FlexibleContexts lets you have things like Ord (Foo String a), where the type being constrained is not simply applied only to type variables in the constraint
07:23:46 <Cale> er, sorry, where the class is not simply being applied to type variables
07:24:05 <erisco> Acer, there are restrictions or omissions in the spec. This makes implementations easier but as GHC evolves it pushes past these boundaries
07:24:17 <Cale> A common example would be something like  MonadState Integer m
07:24:25 <erisco> there are several simplifications to how type classes must be
07:25:23 <erisco> I don't really care about it, so I just enable the extension and move on with life ;)
07:25:27 <Cale> Yeah, the Report is initially very very conservative about type classes, and lots of stuff is separated out into language extensions.
07:25:47 <Cale> FlexibleContexts and FlexibleInstances are no worry in any case
07:25:50 <Acer> i didn't understand that at all
07:26:02 <Rembane> Have type classes in GHC become simpler (or maybe more lax) over time?
07:26:17 <Cale> In fact, FlexibleContexts was just part of GHC's behaviour for many years before anyone noticed that it disagreed with what the Report says
07:26:26 <Acer> do you mean i can have   Functor take an argument of kind *->*->*
07:26:27 <Acer> ?
07:27:00 <Cale> Acer: So, in Haskell 98 or 2010, when you have a constraint on a function, the class must be applied only to type variables
07:27:16 <Cale> So, for example, it would be okay to have something like  (MonadState s m) => ...
07:27:52 <Cale> (Maybe I should take a look at the error you're actually getting so that I can explain it in terms of what you're dealing with)
07:28:13 <Cale> But anyway, if you want to replace that s with a specific type, that wouldn't have been allowed under the original restrictive rules
07:28:34 <Cale> e.g. (MonadState Integer m) => ... would require FlexibleContexts
07:28:39 <Acer> http://lpaste.net/353496
07:28:42 <erisco> if this wasn't an extension feature you wouldn't think twice about it
07:28:58 <Cale> Ahh, yeah
07:29:09 <Cale> You're asking for an Applicative instance for Moi s
07:29:43 <Acer> no i think i am asking for a functor instance
07:29:56 <Acer> runMoi ((+1) <$> pure 0) 0
07:29:58 <Cale> You can write something like  Applicative f  with Haskell 98, but not  Applicative (Moi s)
07:30:03 <erisco> pure is from Applicative
07:30:10 <Acer> oh right
07:30:25 <Cale> ah, and it's an inferred type too, so you didn't write it :)
07:30:48 <Cale> anyway, chances are you just need to write that instance
07:30:54 <Cale> so that the constraint will go away altogether
07:31:17 <Acer> why can't you be specific when writing MonadState s m?
07:31:40 <Cale> It's just that the Report was *extremely* conservative when specifying what you could do with type classes
07:31:50 <Acer> i mean you can write Maybe Int without a problem
07:31:53 <Cale> In fact, even at the time it was written, GHC could handle that
07:32:18 <erisco> spec writers add limitations to make implementations easier
07:32:32 <erisco> that is the why
07:32:36 <Acer> [Int], Maybe Int, Either Int String
07:32:45 <Acer> theres no problem with those
07:32:45 <Cale> Yeah, it's so that if you write a new Haskell compiler, you have a much easier job just getting to the baseline functionality
07:33:03 <Cale> and then you can start implementing extensions one at a time
07:33:07 <merijn> Cale: Flexible* is something I really hope goes away in HaskellPrime
07:33:20 <Cale> merijn: We could probably do without it...
07:33:38 <Cale> I don't know how tricky anyone's ever found implementing FlexibleContexts
07:33:41 <erisco> they just need to bundle them up... didn't we joke it should be -XKmett?
07:33:53 <Cale> Well, there used to be -fglasgow-exts
07:33:54 <Acer> you don't need to enable an extension for those
07:34:07 <Acer> so why do you need an extension for MonadState
07:34:18 <erisco> Acer, if you used those in a context you would
07:34:29 <erisco> there is a difference between contexts and not contexts
07:34:57 <Cale> Acer: Those aren't type classes
07:35:19 <Cale> Acer: If you try to write (Ord String) => ...  (which is a silly, but valid constraint) you'll also run into it
07:36:10 <Cale> Haskell 98 let you apply type functions to anything you wanted still, it's only the use of type classes which are restricted in that way
07:38:44 <sphinxo> what's the "best practices" way to do pretty printing, instances of some typeclass or functions? syntax highlighting using annotations?
07:39:27 <erisco> I haven't heard of a strong preference in that regard
07:39:45 <erisco> on the other hand, if you're writing Show instances you need a license
07:40:01 <Cale> haha
07:40:19 <merijn> sphinxo: What do you mean by pretty printing instances?
07:40:52 <sphinxo> as in instance Pretty <sometype> where ...
07:41:04 <merijn> Right, so defining a pretty printing class
07:41:06 <sphinxo> vs ppLambda, ppVar, 
07:41:09 <Cale> sphinxo: That is a common approach
07:41:21 <merijn> I wrote a custome one for my language, but I assume there's something on Hackage too
07:41:29 <sphinxo> there's plenty
07:41:46 <sphinxo> I think I've decided on annotated-wl-pprint
07:41:49 <Cale> Usually people don't need to make sure they all use the same pretty printing class, since it's usually only consumed at the application level
07:42:04 <sphinxo> over wl-pprint-extras
07:42:25 <merijn> I liked ansi-wl-pprint
07:42:56 <merijn> I vaguely remember quchen working on one?
07:43:00 <merijn> But I might be mistaken
07:43:28 <quchen> merijn: That is correct
07:43:42 <quchen> Well, I did work on it, it’s done, but I didn’t come around to taking over wl-pprint yet
07:44:04 <quchen> Haddock: https://quchen.github.io/ansi-wl-pprint-docdump/wl-pprint-1/index.html
07:44:46 <merijn> I mainly remember because when I saw it, it was supposed to remove my no 1 annoyance with ansi-wl-pprint :p
07:45:08 <merijn> The idiocy that is <$> as not fmap >.<
07:46:00 <c_wraith> Hmm.  >.< is a perfectly valid operator.
07:49:25 <Cale> merijn: I'm pretty sure it predates <$> for fmap
07:49:25 <Cale> At least, some version of it does
07:49:27 <Cale> But yeah, that should probably get changed :P
07:52:18 <ystael> c_wraith: that would be a good name for composition-on-the-error-side, or something :)
08:00:45 <clamchowder> Hello
08:01:58 <Limona> hello
08:02:08 <Limona> is there a nice simple example of haskell
08:02:12 <Limona> without monads and stuff
08:02:41 <tdammers> Limona: what exactly are you looking for? what's your situation?
08:02:52 <Limona> i'm reading the tutorial
08:02:56 <Limona> on wikibooks
08:02:56 <tdammers> which one
08:02:58 <tdammers> ok
08:03:08 <erisco> fac n = product [1..n]
08:03:09 <Limona> and i'd actually like to see some examples of simple haskell programs
08:03:30 <clamchowder> I have no knowledge at all about haskell. I know more popular language like python, C++ etc. But recently I have to write a reader for pandoc, which is written in haskell. My question is: why is pandoc written in haskell? What feature of haskell makes it a better candidate for a document converter?
08:03:37 <erisco> main = putStrLn "Hello Sailor!"
08:03:45 <tdammers> ^ this, pretty much
08:04:05 <tdammers> it's also technically free of monads
08:04:06 <hackal> Hi, I set up dev environment on Windows following https://atom.io/packages/ide-haskell, works fine but I am getting error that it cannot import System.Random. I guess this should be default package right? Do you have any advice on how to solve this issue?
08:04:13 <lyxia> clamchowder: the author probably just likes the language
08:04:53 <merijn> hackal: No, System.Random is from the random package
08:04:55 <tdammers> clamchowder: haskell is quite well suited for writing parsers and compilers, and since pandoc is essentially architected like a compiler, this makes a lot of sense
08:05:53 <merijn> clamchowder: Well, two things people would generally agree Haskell (and ML like languages like Ocaml, F#, etc.) are very good at is: writing parsers and dealing with ASTs
08:05:59 <shapr> Is there anything like Erlang's bit pattern matching in Haskell?
08:06:06 <benzrf> Limona: that's a little like saying "is there a nice simple example of C without functions and stuff"
08:06:08 <erisco> Limona, many of the list functions are basic
08:06:10 <merijn> shapr: Sadly, not as far as I'm aware
08:06:24 <shapr> I want to parse network packets :-/
08:06:31 <erisco> in C you write string functions, in Haskell you write list functions
08:06:39 <benzrf> Limona: monad is the most generally useful interface to the IO type
08:06:43 <shapr> In Haskell, Lens writes you!
08:06:52 <tdammers> shapr: are you a coprogrammer?
08:06:55 <Limona> https://www.schoolofhaskell.com/school/to-infinity-and-beyond/pick-of-the-week/Simple%20examples benzrf 
08:06:56 <Limona> got em
08:07:04 <shapr> tdammers: I turn code into bugs, is that a yes?
08:07:12 <tdammers> shapr: <<loop>>
08:07:16 <benzrf> Limona: that's using the monad interface to the IO type right there...
08:07:23 <erisco> mm, that's good protein
08:07:24 <shapr> tdammers: :-D
08:07:24 <Limona> i know
08:07:28 <Limona> but it's the best i could find
08:07:52 <merijn> clamchowder: I would also argue that refactoring/maintaining big projects (such as pandoc) is much easier in pure languages, so since the author of pandoc (presumably) already knew Haskell, it seems like a rather good fit for the problem
08:08:26 <clamchowder> lyxia, tdammers and merijn: OK thanks.
08:08:28 <tdammers> Limona: don't fear the monad. One, it's a fairly simple abstraction, it's just a very abstract one; and two, you can ignore most of it and, for now, just focus on what bind (>>=) and return mean for the IO type
08:08:29 <erisco> Limona, go through and implement all the functions here https://www.schoolofhaskell.com/school/to-infinity-and-beyond/pick-of-the-week/Simple%20examples#data-list
08:08:43 <clamchowder> merijn: what do you mean by pure language? what is not a pure language?
08:08:57 <hackal> merijn: doing cabal install random says that I already have random-1.1 installed
08:08:59 <tdammers> Limona: that is, pretend that the type of return isn't :: Monad m => a -> m a, but just a -> IO a
08:09:04 <merijn> clamchowder: Pure functional programming means "functions that can't have side-effects"
08:09:04 <Limona> thanks
08:09:33 <benzrf> merijn: i'd go a step further and say "evaluating expressions" in general can't have side effects
08:09:34 <tdammers> Limona: then once you get a feeling for how bind and return work for IO, tackle some other monadic type, e.g. Maybe
08:09:40 <benzrf> merijn: given that there are expression types besides function app
08:09:50 <clamchowder> tdammers: is a pandoc reader a parser or a compiler?
08:10:11 <merijn> clamchowder: You could make a reasonable argument that pandoc is a compiler
08:10:16 <tdammers> clamchowder: it's the parser part of a compiler, which itself is also a compiler... it depends whether you consider the AST an intermediate of the compiler, or its output
08:10:35 <erisco> clamchowder, "not a pure language" includes Java, C#, C, C++, Python, Ruby, PHP, JavaScript
08:11:09 <tdammers> clamchowder: that is, you could say that pandoc as a whole is a a compiler of {input language} -> {output language}, and the pandoc AST is an implementation detail, or you could argue that a Pandoc reader is a compiler of {input_language} -> {pandoc AST}
08:11:11 <shapr> jlouis: What do you think about parsing binary data in Haskell? Anything later/better than your blogpost post?
08:11:31 <merijn> clamchowder: Anyway, as a result Haskell drastically reduces the amount of shared mutable state in your project, making it much easier to keep track of what's going on
08:12:37 <erisco> lets also mention this is not a null language
08:12:50 <tdammers> erisco: we do have bottoms though
08:12:59 <shapr> booty call!
08:14:10 <benzrf> clamchowder: ok, you know how when you write an expression like "3 + int(input('type a number'))" in a language like python, the expression gets evaluated to a result value, and in the process it may cause effects or depend on external factors, like printing thigns out and gathering input from the user?
08:15:05 <clamchowder> benzrf: yes
08:15:07 <benzrf> clamchowder: in haskell, evaluating an expression cannot do that. for example, any expression that results in a number will work exactly the same as just putting the result as a literal
08:15:30 <benzrf> clamchowder: like an expression such as "sin(x) + 4" - you can always replace that with just the result as a literal and it will not change how the program works
08:15:34 <benzrf> this is true of all expressions in haskell
08:15:38 <shapr> @seen jlouis 
08:15:39 <lambdabot> J|ouI$
08:15:41 <shapr> psh
08:16:21 <benzrf> clamchowder: that's what "pure" means
08:16:49 <erisco> well maybe it is a tad more clear if you have two sites in the same context
08:17:11 <erisco> so something like  (getChar(), getChar())  or whatever Python calls reading a character
08:18:20 <erisco> because with sin(x) + 4 your x can change. you can set x = 4 and get one answer and set x = 5 and get another
08:18:21 <clamchowder> benzrf: I don't quite get what you mean, what is 'putting the result as a literal'?
08:19:11 <freeside> shapr: you want to twiddle bits, http://book.realworldhaskell.org/read/code-case-study-parsing-a-binary-data-format.html
08:19:21 <erisco> it is that in the context of x = y, sin(x) + 4 is always the same
08:19:31 <erisco> it is always sin(y) + 4, specifically
08:19:39 <shapr> freeside: are you a member of the atlant freeside hackerspace?
08:19:56 <freeside> i used to live in atlanta, but i'm not a member of the hackerspace there, no
08:20:16 <clamchowder> thanks a lot guys. is there any good resource you can recommend that can teach me writing parser using haskell?
08:20:21 <Cale> Yeah, benzrf, your example isn't great, because that might be inside a lambda which binds x, and so not always evaluate to the same thing ;)
08:20:27 <benzrf> Cale: well. ok
08:20:35 <Cale> Referential transparency is always relative to a particular context
08:20:40 <Cale> But yeah
08:20:45 <freeside> clamchowder: there's a good chapter on parsing in the haskellbook.com
08:20:45 <merijn> clamchowder: Well, do you have any basic Haskell knowledge already?
08:21:21 <benzrf> clamchowder: well, for example - if i have a line of code like "x = print('hello')", then the print call will result in None - but if i replace that, and just say "x = None", then i change what the program does
08:21:27 <benzrf> clamchowder: this can never happen in haskell
08:21:32 <merijn> clamchowder: Real World Haskell has a chapter on Parsec, the exact example have bitrotted a bit over the years, but the underlying principles of how parsec works (and really, how all of the parser combinator libraries in Haskell I know) work hasn't really changed
08:21:33 <erisco> clamchowder, that's the best place to start imo :)
08:21:39 <Cale> The main thing is that there's a clear separation in Haskell between expression evaluation on the one hand -- the process of reducing expressions to values for the purposes of matching patterns -- and execution of IO actions on the other.
08:23:16 <shapr> freeside: I can't find any Haskellers in Atlanta, got any tips?
08:23:24 <Cale> Execution of IO actions can cause your computer to do anything that computers do, and can depend on any number of external factors. But evaluation of expressions is kept separate from that, so if an expression is evaluated twice and the free variables occurring in it are bound to the same things each time, then it'll evaluate the same way, and the only effect this will have is to produce the value which is the result of evaluating the 
08:23:24 <Cale> expression.
08:23:30 <clamchowder> merijn: I have no haskell knowledge at all..
08:23:40 <shapr> clamchowder: ooh, you have an excellent adventure ahead of you!
08:24:38 <Cale> That is, I think, perhaps the most important difference between Haskell and most other languages ready for industrial use.
08:24:51 <benzrf> clamchowder: you may be a little bit shit out of luck if you don't really want to learn haskell, then... the vast majority of mainstream languages have a bunch of fundamental things in common which haskell doesn't have at all, so moving from any of C, python, javascript to haskell is kind of like starting to program over again
08:24:59 <Cale> The type system is also a pretty big deal (and factors into this somewhat as well)
08:25:13 <benzrf> clamchowder: it may be pretty difficult to "just write some code in it without understanding 100% of what you're doing"
08:25:18 <erisco> except some waste heat and time, which some people like to argue about
08:25:36 <Cale> erisco: right :)
08:26:10 <erisco> could be relevant if you depend on spacebar heating
08:26:20 <Cale> There's some places where this abstraction gets broken a little bit too, like with lazy IO primitives.
08:27:58 <Cale> (though one could argue that you already executed an IO action, to really understand the behaviour of programs in the presence of lazy I/O requires an understanding of how evaluation is going to happen -- which is why people shy away from using lazy I/O very much)
08:28:12 <merijn> clamchowder: It'll be rather hard to dive into writing parsers without doing some haskell learning first, since Haskell is rather difficult from most languages you already now (well, unless you know like Ocaml/F#/Swift, then it'll be considerably easier)
08:28:44 <Cale> Parsers are perhaps my favourite thing to write in Haskell though :)
08:28:48 <erisco> I learned with parsers first
08:29:21 <Cale> Yeah, I don't think I really understood what the monad abstraction was about until I'd used Parsec :)
08:30:08 <clamchowder> freeside and merijn: I'll check out the haskellbook.com and the Real World Haskell, thanks for the pointers.
08:30:08 <freeside> shapr: http://lmgtfy.com/?s=d&q=haskell+meetup+atlanta
08:30:23 <erisco> shots fired
08:30:34 <freeside> looks like https://www.meetup.com/Atlanta-Functional-Programming-Meetup/ is what you want
08:30:35 <Cale> clamchowder: http://www.cis.upenn.edu/~cis194/spring13/lectures.html is another nice one to check out
08:30:51 <merijn> clamchowder: I would say Real World Haskell is...not great, for learning Haskell. It's a bit dated and skips over important details, IMO. It serves as a decent reference for some well-known libraries, though
08:31:24 <shapr> freeside: yeah, I started that meetup
08:31:28 <merijn> I've heard good things about Haskell Book (and a small, but very vocal minority who seem to hate it), but I haven't read it
08:31:34 <Cale> I'm not yet really sure what to think about haskellbook.com -- I've heard some good things and some really negative things.
08:31:39 <erisco> what about LYAH?
08:31:47 <freeside> lol ok
08:31:50 <merijn> erisco: Also not great
08:32:02 <Cale> I like Graham Hutton's book
08:32:07 <freeside> what have you heard about haskellbook.com, cale?
08:32:12 <merijn> It was great when it first came out, since the only thing we had was the "Gentle Intro", but...
08:32:17 <Cale> http://www.cs.nott.ac.uk/~pszgmh/pih.html
08:32:18 <merijn> @quote Brend Gentle.Intro
08:32:18 <lambdabot> Brend says: Whoever chose the title "A Gentle Introduction to Haskell" is obviously accustomed to wrestling bears in piranha pits or something.
08:32:23 <freeside> i have gone through it and i can see how it is perhaps too purist for everyone
08:32:27 <erisco> geez, Haskell Book is really trying to sell to the defeated mindset
08:32:51 <freeside> i enjoyed Hutton's book, i also enjoyed the haskellbook.com
08:33:14 <clamchowder> benzrf: I just wanted to write a converter... but I see your point
08:33:35 <erisco> is Christopher Allen an IRCer?
08:33:47 <shapr> yeah, is bitemyapp
08:33:54 <erisco> I recognised the face
08:34:17 <shapr> erisco: what do you mean about defeated mindset?
08:35:08 <merijn> clamchowder: To give some comparison when I say 'Haskell is rather different from most languages you know', I consider Ruby, Python, JavaScript, and Lua to be "basically the same language if you squint a little" :)
08:35:21 <erisco> shapr, just based on the messaging at the top of the page
08:35:22 <clamchowder> Is haskell very mathematical?
08:35:28 <merijn> You can maybe add Java to that list too
08:35:35 <shapr> clamchowder: it can be, if you want to do that
08:35:47 <blackdog> merijn: heh, i've got into so many arguments with that line
08:35:50 <Cale> clamchowder: It doesn't require you to know much mathematics, but it's very mathematical in a particular sense
08:35:54 <orion> clamchowder: All computer science is mathematical.
08:36:01 <erisco> I get it, but I just feel bad reading it :P have some confidence people, it'll be okay
08:36:06 <merijn> clamchowder: Yes, no, maybe. Do we steal some terminology? Yes. Do those abstractions help? Sometimes. Do you require a math background? No.
08:36:07 <blackdog> last friday night at a party: "ruby and python are basically the same'
08:36:14 <blackdog> s/'/"/
08:36:32 <blackdog> response: "WHAT? HAVE YOU NEVER TYPED 'IMPORT THIS'???"
08:36:42 <benzrf> lol
08:36:45 <blackdog> (i'm great fun at parties honest)
08:36:46 <Cale> I would also say that if you enjoy programming in Haskell, you would probably also enjoy proving theorems in mathematics -- the mental process involved is similar.
08:36:46 <shapr> blackdog: wow, harsh
08:36:56 <shapr> blackdog: how's code?
08:37:04 <clamchowder> Is the math in haskell mostly category theory?
08:37:05 <erisco> that's some serious fighting words in those communities to suggest that
08:37:05 <benzrf> merijn: tbh python and javascript actually do have almost identical semantics
08:37:05 <Cale> But the raw knowledge required isn't all that similar
08:37:08 <benzrf> clamchowder: no
08:37:15 <blackdog> shapr: on hiatus, i guess. jobhunting.
08:37:27 <shapr> blackdog: relaxing while you look?
08:37:44 <blackdog> no, not really. it's stressful, i need work to maintain my visa.
08:37:48 <merijn> clamchowder: No, people associating category theory with Haskell is my pet peeve. (And I say this as a haskell fan and someone occasionally trying to learn category theory)
08:37:49 <Cale> clamchowder: There's bits of category theory which we've stomped on a bunch so that it would fit inside the language, but it's safe to ignore category theory :)
08:37:56 <erisco> OO in Ruby is alright but I kinda like how PHP does it more
08:38:03 <freeside> In the introduction to SICP, Perlis wrote: "It is better to have 100 functions operate on one data structure than to have 10 functions operate on 10 data structures." But in Haskell, you can have 100 functions operating on 100 data structures
08:38:06 * erisco ducks
08:38:17 <merijn> clamchowder: I would say knowing category theory, has approximately 0 benefit until you're like already writing expert level Haskell :)
08:38:44 <benzrf> merijn: like seriously, if you look at stuff even like how the object orientation works in javascript and in python, it's shockingly similar
08:38:50 <shapr> blackdog: oh, I forgot about that, that sucks :-(
08:38:51 <merijn> clamchowder: If anything, lambda calculus, type theory and logic are the math fields to look at for Haskell. But even then that's mostly optional
08:38:56 <benzrf> they are honestly almost identical when you strip away the syntax
08:38:58 <tdammers> IMO the main relationship between Haskell and CT is that CT forms the theoretical underpinnings for many of the abstractions used in Haskell, and that makes the language and its idioms very robust, but it doesn't mean that you need to learn CT in order to use Haskell productively
08:39:35 <merijn> tdammers: "many of the abstractions" <- which ones, other than functor? And even that one has been pounded into unrecognisability
08:39:36 <Cale> I think learning category theory is valuable if you want to do it at some point -- especially if you have a more general interest in mathematics -- but it's mostly a diversion from getting things done in Haskell.
08:39:47 <merijn> tdammers: Monad looks nothing like a CT monad
08:39:52 <freeside> you don't need to know Latin and Greek to speak English, but if you happen to be a professional fiction author, that'll really set you apart.
08:39:58 <benzrf> merijn: rephrase bind as join and it does!
08:40:02 <cocreature> the problem is not learning CT, the problem is that people learn CT before they understand how to avoid space leaks because to a beginner it often seems like it more important than it is
08:40:15 <Cale> cocreature: right
08:40:18 <orion> Category theory isn't necessary for Haskell any more than chemistry and heat transfer aren't necessary to drive a car.
08:40:22 <benzrf> ^
08:40:22 <freeside> https://www.youtube.com/watch?v=GmgoPd7VQ9Q&list=PLbgaMIhjbmEnaH_LTkxLI7FMa2HsnawM_&index=20
08:40:27 <merijn> cocreature: Well, my main objection is "learning CT to become better at Haskell" :)
08:40:34 <freeside> "a monad is just a monoid in the category of endofunctors!"
08:40:41 <merijn> cocreature: There's so many more worthwhile investments if the goal is "become better at haskell"
08:40:43 <benzrf> freeside: ok, that phrase is my pet peeve
08:40:49 <benzrf> freeside: "the" category of endofunctors isn't a thing
08:40:57 <benzrf> it's specifically the category of endofunctors on Hask
08:40:59 <tdammers> merijn: I didn't say that Haskell's Monad is literally a CT monad, I said that CT provides theoretical underpinnings
08:41:18 <benzrf> freeside: every category has an associated category of endofunctors, there is no "the" category of endofunctors
08:41:21 <erisco> it is like learning physics in order to learn how to drive
08:41:29 <merijn> Anyway, this kinda gets away from the clamchowder's point of "do I need math" :)
08:41:33 <erisco> they're related, but you can more directly just learn how to drive
08:42:02 <benzrf> honestly i wouldnt even say that category theory is to physics as physics is to driving
08:42:19 <freeside> i'm just quoting some polish dude
08:42:39 <benzrf> i thikn maybe itd be accurate to say that
08:42:50 <benzrf> category theory is unreasonably effective for designing haskell abstractions
08:42:52 <benzrf> :)
08:43:01 <freeside> Hask is not a category! http://math.andrej.com/2016/08/06/hask-is-not-a-category/
08:43:04 * freeside ducks
08:43:05 <benzrf> freeside: shhhhhhh
08:43:10 <benzrf> fast and loose reasoning is morally correct
08:43:12 <benzrf> :}
08:43:14 <okeuday_bak> if two cabal packages contain two files that use the same path, they always will conflict, right?
08:43:41 <freeside> a conflict is just a monoid in the category of file paths!
08:43:51 <benzrf> shoosh
08:43:53 <okeuday_bak> hehe
08:44:20 * benzrf ponders what a monad on a poset category would look like
08:44:23 <glguy> okeuday_bak: Sure, if they actually use the same path then they'll conflict, but what path are you thinking of that is the same?
08:44:29 <nbro> hi guys!
08:44:37 <freeside> guys and gals, bro
08:45:05 <erisco> and a new snowclone was invented
08:45:06 <clamchowder> OK I get it. I'm going to learn some haskell now. Thanks for the discussion :)
08:45:08 <okeuday_bak> glguy: Foreign.Erlang is currently being used by some GPL alpha code and I would like to use my own file for that
08:45:21 <nbro> just to make sure, this is an abstract data type: data MyData = MyData { before :: String, after :: String, something :: Int }, not an algebraic data type, right?
08:45:45 <glguy> okeuday_bak: OK, that's not related to file paths. You can use your own module with that name
08:45:56 <erisco> nbro, things you write with "data" are algebraic data types
08:45:59 <glguy> okeuday_bak: Making your own module won't replace the one that is already being used
08:46:15 <erisco> nbro, abstract data types are ones where you do not have access to the constructors, like Data.Set or Data.Map
08:46:22 <nbro> @erisco what is an abstract data type in Haskell then?
08:46:22 <lambdabot> Unknown command, try @list
08:46:27 <glguy> and if you have a package that depends on both packages that provide that module you'll need to use the PackageImports extension to disambiguate
08:46:38 <nbro> lol, I forgot this lambdabot gets crazy because of the at
08:47:06 <okeuday_bak> glguy: I am not using their Foreign.Erlang module, but I was wondering what would happen if I added their package as a dep, and you are saying that my project module will always be used instead of a dep module, right?
08:47:10 <benzrf> nbro: people normall address in irc using a colon anyway
08:47:21 <freeside> https://www.reddit.com/r/haskell/comments/38grqx/what_is_the_difference_between_an_algebraic_data/cruxgrq/?utm_content=permalink&utm_medium=front&utm_source=reddit&utm_name=haskell
08:47:25 <tdammers> nbro: IRC custom for pinging people is to just write their name. No @ or # or whatever required.
08:47:32 <glguy> okeuday_bak: I'm saying you'll need to use an extension if both modules are available in order to pick one
08:47:47 <tdammers> nbro: or, like this, a colon
08:47:49 <benzrf> bbl
08:48:00 <okeuday_bak> glguy: k, cool, thanks for mentioning the PackageImports, wanted to see if there was a way out of that type of problem
08:48:01 <nbro> erisco: what does it mean to not have access to constructors?
08:48:19 <erisco> nbro, to make an abstract data type you make an algebraic type in a module and then you do not export the constructors
08:48:26 <erisco> nbro, it works the same way as in other languages such as C
08:48:59 <erisco> in C you write the type T in one file and all you expose is the type T *
08:49:11 <nbro> erisco: ok
08:49:43 <nbro> erisco: here https://wiki.haskell.org/Abstract_data_type for example, after reading, I didn’t have a clear idea of the difference between abstract and algebraic dt
08:50:06 <erisco> "An abstract data type is a type with associated operations, but whose representation is hidden."
08:50:12 <erisco> by "representation" they mean the constructors
08:50:25 <nbro> erisco: but they also say: “data Tree a = Nil 
08:50:26 <nbro>             | Node { left  :: Tree a,
08:50:27 <nbro>                      value :: a,
08:50:28 <nbro>                      right :: Tree a }” is a abstract type
08:50:45 <juri_> hlint is smarter than me. \o/!
08:50:49 <erisco> well that's a different sense of the word
08:50:53 <nbro> 2.1
08:51:08 <nbro> erisco: then they should be more careful, IMO
08:51:15 <freeside> agreed
08:51:27 <erisco> I don't know why they follow up with that example actually
08:52:24 <erisco> and saying Integer is abstract is a bit strange, not sure about Float
08:52:47 <erisco> > (\x -> case x of 0 -> "zero"; _ -> "not zero") 1
08:52:50 <lambdabot>  "not zero"
08:53:07 <erisco> > (\x -> case x of 0.0 -> "zero"; _ -> "not zero") 1.0
08:53:10 <lambdabot>  "not zero"
08:53:20 <erisco> they're not abstract
08:53:25 <erisco> the literals are constructors
08:54:37 <erisco> they say at the end of Definition: "In addition, parametrized types can be viewed as a kind of abstract type, because they leave some parts of the data type undefined, or abstract."
08:54:54 <erisco> so they're acknowledging this is a different meaning of "abstract"
08:55:31 <erisco> but not so clearly delineated
08:55:43 <glguy> integer literals are kind of like constructors, but they aren't constructors
08:56:03 <nbro> erisco, but it’s confusing because they do not clearly state that there exist algebraic data types which do not expose data constructors which are actually the abstract data types
08:56:21 <nbro> IMO, it’s confusing and it should be changed
08:56:36 <erisco> nbro, read 2.2 Stack
08:57:10 <nbro> erisco: I read and this is the problem
08:57:16 <nbro> they made this confusing on purpose
08:57:23 <nbro> just to make seem Haskell difficult
08:57:24 <nbro> it’s not
08:57:36 <nbro> they talk about two different concepts with the same names
08:57:40 <nbro> in the same article
08:57:46 <nbro> just to confuse people
08:57:51 <erisco> never assume malice where incompetence will suffice ;)
08:58:10 <freeside> this is a good example of a situation where a strongly typed natural language would have avoided the namespace collision
08:58:34 <erisco> I am just trying to make the joke though. I don't think it is incompetent, but it really didn't need to be the same article
08:59:08 <erisco> it would have been more clear if they have two articles and linked them together as a disambiguation of the word "abstract"
08:59:13 <erisco> which Wikipedia does, for example
08:59:14 <freeside> never attribute to malice what can be explained by excessive abstraction
08:59:25 <nbro> and IMO these concepts should have different names (just because of these situations)
09:00:06 <erisco> well that won't happen nbro as computer science is filled with overloaded terminology
09:00:13 <erisco> just ask what "polymorphic" means
09:00:59 <erisco> Haskell hasn't decided on all of its terminology, it is also just using what is prevalent
09:01:10 <nbro> people could at least put some effort in using different terminology for different things…
09:01:23 <nbro> by the way, regarding my first example, data MyData = MyData { before :: String, after :: String, something :: Int }
09:01:29 <erisco> but this people you speak of is the unorganised masses. it just happens
09:02:08 <nbro> I thought algebraic data types had data constructors, which eventually accept parameters
09:02:10 <erisco> glguy, they are kind of like constructors and kind of not, and so not the best two examples to be using
09:02:22 <glguy> erisco: Constructor is kind of name
09:02:34 <glguy> integer literals are their own thing
09:02:48 <nbro> but in the case of MyData, what is the data constructor?
09:02:57 <glguy> nbro: MyData is a data constructor
09:03:14 <glguy> and also there is a separate constructor at the value level
09:03:22 <glguy> they just happen to be written with the same letters
09:03:30 <erisco> glguy, I don't know really, because if you just defined data Integer = 0 | 1 | 2 | ... I don't know how you'd tell the difference
09:03:34 <glguy> err, both a type constructor and a constructor
09:03:36 <nbro> glguy: if MyData is also a data constructor, then what’s the meaning of the things in the record, that is  { before :: String, after :: String, something :: Int }?
09:03:48 <erisco> then we're just left with a special compiler feature to overload these names for the various types, but that is nothing special
09:04:24 <Tuplanolla> Pattern matching wouldn't impose `Eq`, erisco.
09:04:39 <glguy> erisco: Yeah, you can think of it like that. That's just not what constructor means
09:04:55 <erisco> :t \x -> case x of 0 -> 1
09:04:57 <Tuplanolla> For a general `Num`, that is.
09:04:57 <lambdabot> (Num t, Num a, Eq a) => a -> t
09:05:18 <glguy> nbro: First let's disambiguate and write:  data MyData = MkMyData { before, after :: String, something :: Int }
09:05:30 <glguy> nbro: MyData is now the type constructor, MkMyData is the value constructor
09:05:38 <erisco> that is a reasonable way to distinguish it Tuplanolla
09:05:51 <nbro> glguy: ok, so before MyData was both type and data constructor?!
09:06:09 <glguy> nbro: There are two completely separate namespaces
09:06:16 <glguy> and MyData existed separately in both
09:06:54 <nbro> ok
09:07:22 <freeside> that overloading problem again
09:08:13 <erisco> Tuplanolla, well, I retract that, because we're talking about Integer specifically, and Eq Integer can be dismissed
09:09:25 <Tuplanolla> As noted.
09:09:32 <erisco> so I wouldn't consider it a shining example of an abstract type
09:09:51 <erisco> when you've got Data.Map and Data.Set readily available
09:09:55 <nbro> ok, now if MkMyData is a data constructor, I suppose “before::String, after :: String, something :: Int” are somehow its parameters..?!
09:10:25 <erisco> you can actually dig into those and see how it works
09:11:03 <glguy> nbro: MkMyData is a constructor declared with record syntax. before, after, and something are field labels
09:11:18 <glguy> Because we have those three fields, the type of MkMyData is  'String -> String -> Int -> MyData'
09:12:15 <glguy> and when used as a pattern we can expect it to be applied to 3 other patterns, or to use record syntax as a value and pattern
09:12:48 <nbro> just to make it clearer, can a data type defined with the record syntax as above be defined without the record syntax?
09:12:54 <freeside> this may be a useful case to consider:
09:13:01 <freeside> data MyData1 = MkMyData1 String String
09:13:01 <freeside> data MyData2 = MkMyData2 { before :: String, after :: String }
09:13:01 <freeside> curried = MkMyData2 "foo"
09:14:12 <erisco> record syntax is convenience, but there nothing but a data type underneath
09:14:58 <freeside> once those lines make sense to you, consider this: data MyData3 = MkMyData3a String String | MkMyData3b { bef :: String, aft :: String }
09:15:05 <erisco> having projectors is a common need, and updating fields is a common need, and so there is record syntax
09:15:32 <erisco> you can do everything without it
09:15:43 <freeside> once MyData3 makese senes to you, the first sentence of https://en.wikipedia.org/wiki/Algebraic_data_type#Theory shold also make sense
09:17:18 <erisco> 1 inhabitant, 2 inhabitants, 3 inhabitants, ha ha ha
09:18:01 <raek> as I spend time using boost::optional in my professional journey through C++-land my homesick heart aches longingly for my good old friend Maybe from far away Hanskell-land
09:18:23 <merijn> raek: Write a DSL (in Haskell!) that generates C++ for you!
09:18:57 <freeside> indeed, Hutton's entire book on Haskell doesn't even mention record syntax
09:19:13 <erisco> raek, may you one day not have to visit your variants
09:19:58 <nbro> first of all, it seems there are different ways of declaring data types, and this is already annoying
09:20:44 <erisco> 'when she was still a doctoral student she participated as “math support” in the construction of a small experimental nuclear reactor in Slovenia. One of the physicsts asked her to estimate the value of the harmonic series 1+1/2+1/3+⋯ to four decimals. When she tried to explain the series diverged, he said “that’s ok, let’s just pretend it converges”.'
09:20:47 <nbro> you can declare a data type like this: data Day = Monday | Tuesday | … , whose data constructors do not have fields
09:20:51 <erisco> http://math.andrej.com/2016/08/06/hask-is-not-a-category/   that is gold XD
09:21:02 <nbro> and you can do things like this: data MyData1 = MkMyData1 String String
09:21:38 <nbro> where you could pass around MkMyData1 “sometihng” “else”
09:22:00 <nbro> I mean, why? Why two different ways to use data?
09:22:07 <Cale> nbro: Those are both the same way
09:22:27 <Cale> data Color = RGB Int Int Int | CMYK Double Double Double Double
09:22:31 <Cale> You can combine them
09:22:48 <Cale> In general, a data type may have multiple constructors, and each may have fields
09:23:07 <Cale> (both are zero or more)
09:23:08 <erisco> two different ways to use data? my friend, that is why it is algebraic! :)
09:23:08 <freeside> data Color = RGB { r :: Int, g :: Int, b :: Int } is better than RGB Int Int Int
09:23:23 <Cale> freeside: sure
09:23:46 <Cale> (I didn't expect anyone to actually use that type ;)
09:23:47 <nbro> freeside: you say it’s better because you can refer to r, g and b?
09:24:05 <Cale> Though using record syntax with multiple constructors is awkward
09:24:17 <Cale> Because your field extractors become partial functions
09:24:23 <erisco> unless they share the same field, but yes it is not good
09:24:26 <nbro> so, could we have, say, data Color = RGB { r :: Int, g :: Int, b :: Int } | CMYK {c::Double, m::Double, y::Double, k::Double}?
09:24:32 <Cale> nbro: yeah
09:24:38 <freeside> yes, if one regularly pulls individual r/g/b components out of a pixel, then saying 'r pixel' more convenient than doing a pattern match
09:24:55 <nbro> and also something like this data Color = RGB Int Int Int | CMYK {c::Double, m::Double, y::Double, k::Double}?
09:24:57 <nitrix> nbro: You could but it's dangerous as `r`, `g`, `b`, `c`, `m`, `y` and `k` are now partial functions.
09:25:08 <_sras_> What causes the "Failed to unify types" error?
09:25:18 <erisco> your types do not match
09:25:20 <nitrix> @let data Color = RGB { r :: Int, g :: Int, b :: Int } | CMYK {c::Double, m::Double, y::Double, k::Double}
09:25:21 <Cale> (also you just defined a bunch of functions whose name is a single letter, which is... questionable)
09:25:25 <lambdabot>  Defined.
09:25:39 <nitrix> > c (RGB 0 0 0)
09:25:43 <lambdabot>  error:
09:25:44 <lambdabot>      Ambiguous occurrence ‘c’
09:25:44 <lambdabot>      It could refer to either ‘Debug.SimpleReflect.c’,
09:25:49 <nitrix> > L.c (RGB 0 0 0)
09:25:51 <erisco> single letter function names are not so great because variables often are named with a single letter
09:25:55 <lambdabot>  *Exception: No match in record selector c
09:26:07 <erisco> so if you make a boo boo that'll lead to a confusing error
09:26:32 <Cale> Generally names should increase in length as the scope of the thing being defined increases, and shorten with frequency of use
09:26:59 <nbro> ok
09:27:03 <nitrix> nbro: As you can see with this Exception, partial functions are to be used sparingly.
09:27:04 <erisco> alwaysHereAndNeverUsed
09:27:28 <freeside> that's why I always refer to William Henry Gates III as "Bill"
09:27:42 <erisco> he's on speed dial is he?
09:27:56 <Cale> nbro: But you'll eventually come to feel like every other language's types are lacking -- this ability to define types with multiple constructors is really useful
09:28:12 <Cale> nbro: Consider for example this definition of binary trees holding values of a variable type
09:28:24 <Cale> data Tree a = Tip | Branch a (Tree a) (Tree a)
09:28:25 <nbro> so, in summary, everything defined with data is an algebraic data type… there are algebraic data types which are abstract and those hide the data constructors, somehow to make them super flexible… then we have the record syntax, which is just syntactic sugar for declaring data constructors, so that we can access the fields somehow with partial functions, right?
09:28:25 <nshepperd_> erisco: fun note: if you pretend that sequence converges, you get the euler mascheroni constant, via the Cauchy principle value https://en.m.wikipedia.org/wiki/Riemann_zeta_function
09:28:34 <Cale> i.e. a binary tree is either the empty tree called Tip
09:28:40 <erisco> I can survive with side effects, but lack of sum types is murder
09:28:41 <_sras_> erisco: Doesn't that show up as type mis match error?
09:28:58 <Cale> or it's of the form  Branch x l r  where x is some value (at the root) and l and r are two subtrees of the same type
09:29:03 <nitrix> nbro: data Shape = Triangle Base Height | Circle Radius | Rectangle Width Height
09:29:19 <Cale> e.g. you can now write  Branch 0 (Branch 1 Tip Tip) (Branch 2 Tip Tip) :: Tree Integer
09:29:25 <erisco> _sras_, I cannot remember the specifics. If you paste your code and error we can help
09:29:31 <nitrix> nbro: renderShapes :: [Shape] -> IO ()
09:30:11 <erisco> most languages have anemic sum types which they call "enums"
09:30:16 <_sras_> erisco: It is in a code created by Template haskell. I am not sure the exact code that triggers it.
09:30:20 <nshepperd_> erisco: zeta function can answer such questions as what is 1+2+3+... :)
09:30:31 <Habib_> Anyone know a better name for this effect?
09:30:32 <Habib_> redirectToSameHostRefererOrRoot = redirect =<< fromMaybe General.URL.root <$> sameHostReferer
09:30:42 <nbro> Cale: I understand this example: data Tree a = Tip | Branch a (Tree a) (Tree a)
09:30:43 <_sras_> erisco: this is the full error "Failed to unify types: (ConT Data.Time.LocalTime.LocalTime.LocalTime,ConT DepartureTime)"
09:30:54 <nbro> my problem was related to the record syntax
09:31:20 <Habib_> sameHostReferer returns a (Just referer) that's the same host if it can find it from the header, otherwise Nothing.
09:31:23 <nbro> what the hell is it and what’s the relation between data types declared with record syntax and those without it
09:31:26 <nitrix> Habib_: Wouldn't it be best to just name it "sameHostRefererOrRoot" ?
09:31:39 <erisco> _sras_, I don't know based on just that, sorry
09:31:39 <Cale> nbro: Well, that was aimed at your original examples comparing Day and MyData1
09:31:52 <nitrix> Habib_: This way you can still perform redirections or pass it to other operations, rather than tieing them together?
09:32:29 <nitrix> Habib_: And use `sameHostRefererOrRoot >>= redirect` at your call sites when needed?
09:32:33 <Habib_> nitrix, yeah, I thought about that, but I can't think of any other reason I'd need the referer only from the same host, and it's easy enough to change later if necessary.
09:32:40 <erisco> nbro, do you know what a projector is?
09:32:42 <Cale> nbro: Record syntax just automatically defines functions for extracting the fields, and enables some additional pattern matching (e.g. you can match just some of the fields, and ignore others), as well as record update syntax
09:33:11 <suica> is there a better way to do this toy example point-free: \x y -> show [(x, y)] <---> (show .) . ((:[]) .) . (,) that allows you to contain the first two arguments to the `(,)` segment of the composition?
09:33:25 <Cale> nbro: The underlying type is still the same as one which didn't name its fields, and you can still use the plain non-record syntax with a type that uses it
09:33:27 <Habib_> But I think I might just go that route, just to keep things under 80 lines.
09:33:33 <Habib_> 80 columns*
09:33:54 <nbro> erisco: no, I think
09:33:55 <suica> basically i'm curious if there's a way to do `show . (:[]) . <something here>` where the <something here> consumes two arguments
09:34:01 <nbro> at least in Haskell
09:34:01 <kuribas> suica: I think \x y -> show [(x, y)] is fine
09:34:22 <erisco> suica, you can define (:.) f g x y = f (g x y)
09:34:28 <Cale> nbro: e.g. if I have  data Employee = MkEmployee { name :: String, salary :: Integer }  then I'm still allowed to write  Employee "Bob" 100000
09:34:35 <Cale> oops
09:34:39 <nitrix> suica: (.:) = (.) . (.)
09:34:41 <Cale> nbro: e.g. if I have  data Employee = MkEmployee { name :: String, salary :: Integer }  then I'm still allowed to write  MkEmployee "Bob" 100000
09:34:48 <Cale> ^^ fixed typo :)
09:34:53 <nbro> Cale: ok, thanks for the clarifications
09:34:56 <suica> cool, thanks!
09:35:13 <Cale> nbro: But I may write  MkEmployee { name = "Bob", salary = 100000 }
09:35:35 <erisco> (id ~> id ~> show . (:[])) (,)   is another solution with ~> from TypeCompose
09:35:47 <nitrix> erisco: I think it should be .: not :.
09:35:51 <Cale> and I can write stuff like  giveRaise n empl = empl { salary = salary empl + n }
09:36:11 <centril> edwardk: oisdk handed me this: https://gist.github.com/oisdk/92b43b63ee6aba451d5daf55af528d04
09:36:18 <Cale> Here, salary is automatically defined as a function  Employee -> Integer
09:36:19 <nitrix> erisco: The mnemonic used is that dot represents the amount of arguments .: would be composition a function of one argument with a function of two arguments.
09:36:34 <Cale> and we use it to get the salary of our parameter employee empl
09:36:37 <Cale> and then add n
09:36:38 <kuribas> :t curry (show . (:[]))
09:36:40 <lambdabot> (Show b, Show a) => a -> b -> String
09:36:57 <nbro> Cale: wait, what’s this MkEmployee { name = "Bob", salary = 100000 }? Is it you initializing a value of type Employee so that you can assign to a “variable
09:36:58 <centril> nitrix: what's the (.) . (.) operator called again ?
09:36:59 <nbro> ?
09:37:05 <freeside> if you think of a record as an object, basically you're spelling out the attribute accessor
09:37:09 <Cale> Yeah, that makes a new Employee value
09:37:22 <nitrix> centril: dot ?
09:37:43 <Cale> I could make a definition if I like, but I didn't there
09:37:49 <centril> nitrix: no, not (.)...  (.) . (.)
09:37:50 <MarcelineVQ> nitrix, centril: it's an owl, I swear, nnnnothing else at all
09:37:54 <kuribas> suica: curry (show . (:[])) but I think it obfuscation.
09:38:06 <nbro> @let Employee = DCEmployee String String
09:38:08 <centril> MarcelineVQ: xd xD XD :D
09:38:09 <lambdabot>  .L.hs:170:1: error: Not in scope: data constructor ‘Employee’
09:38:10 <nitrix> centril: Some people say owl, some people say dot. Even though it's three dots.
09:38:24 <centril> nitrix: it wasn't a real question ^^
09:38:24 <Cale> @let data Employee = DCEmployee String String
09:38:27 <lambdabot>  Defined.
09:38:31 <nbro> oh, sorry
09:38:38 <nbro> forgot the “data"
09:38:40 <kuribas> :t singleton
09:38:43 <lambdabot> error:
09:38:43 <lambdabot>     • Variable not in scope: singleton
09:38:43 <lambdabot>     • Perhaps you meant one of these:
09:38:43 <Cale> actually, let's change that
09:38:47 <Cale> @undefine
09:38:47 <lambdabot> Undefined.
09:38:48 <centril> nitrix: it's a: "I know the answer to the question already, but it is awkward to say it..."
09:38:56 <Cale> @let data Employee = DCEmployee String String deriving (Eq, Ord, Show)
09:38:59 <lambdabot>  Defined.
09:39:12 <Cale> There, just a little extra functionality so that we can play with it
09:39:19 <nitrix> centril: I don't know what you know already. I'm just content with answering trying to help. But now it's insulting.
09:39:25 <nbro> @let a = DCEmployee “name” “surname”
09:39:26 <lambdabot> Plugin `eval' failed with: Enum.toEnum{Word8}: tag (8220) is outside of bounds (0,255)
09:39:36 <Cale> what the
09:39:37 <cocreature> nitrix: in https://www.youtube.com/watch?v=seVSlKazsNk it’s called the “blackbird” operator
09:39:37 <centril> nitrix: It was a joke ;)
09:39:49 <Cale> nbro: Oh, you're using curly quotes
09:40:05 <Cale> @let bob = DCEmployee "Bob" "Marley"
09:40:07 <lambdabot>  Defined.
09:40:09 <Cale> > bob
09:40:12 <lambdabot>  DCEmployee "Bob" "Marley"
09:40:28 <Cale> > case bob of DCEmployee name surname -> surname
09:40:33 <lambdabot>  "Marley"
09:40:42 <centril> Cale: damn, with @let you can do wicked n-tuple programming over IRC
09:40:53 <erisco> kuribas, but it is the best solution for exercising the often forgotten specialisation
09:40:54 <nbro> Cale: you have defined before a value using the curly braces, i.e. MkEmployee { name = "Bob", salary = 100000 }, could I also use curly braces for data types not declared with the record syntax?
09:41:05 <centril> cocreature: nice link, thanks
09:41:08 <cocreature> nbro: no
09:41:16 <Cale> nbro: Nope, to use the record syntax, the type has to be defined with it.
09:41:23 <nbro> ok
09:41:41 <Cale> With one exception: you're always allowed to use {} after a constructor to ignore all its fields
09:41:45 <Cale> (when pattern matching)
09:41:56 <centril> suica: http://hackage.haskell.org/package/pointless-fun-1.1.0.6/docs/Data-Function-Pointless.html
09:41:57 <erisco> > id (+) `id` id 1 `id` id 1 -- stop the madness!
09:41:59 <lambdabot>  2
09:42:06 <freeside> wait, cale, can you give an example of that?
09:42:07 <Cale> Sometimes you only care about which constructor something was built with, and not the contents of its fields, which is useful
09:42:17 <MarcelineVQ> erisco: you're going to start one of those fmap avalanches :>
09:42:32 <ph88> in my file i have  ints :: Traversal' a Int  but when i do :t ints in ghci i get  ints :: (Applicative f, HasTokens a) => (Int -> f Int) -> a -> f a  does that mean that Traversal' creates arrows ?
09:42:51 <Cale> > case Just 5 of Nothing -> 0; Just {} -> 1
09:42:55 <lambdabot>  1
09:43:02 <Cale> Of course, with Maybe, that's a bit silly
09:43:05 <nitrix> erisco: id (id (+) `id` id 1 `id` id 1 {- stop the madness! -})
09:43:09 <Cale> But sometimes you have a type with many fields
09:43:21 <centril> freeside: isArray :: AST.Type -> Bool
09:43:38 <Cale> and you want to make a definition which is resilient when you add more :)
09:43:41 <centril> as an example of what Cale wrote
09:44:04 <nbro> it’s kind as useful as the _ when pattern matching with lists then?!
09:44:24 <Cale> Yeah, if you'd otherwise be writing a pattern like Foo _ _ _ _
09:44:31 <Cale> It might be nicer to write Foo {}
09:44:41 <Cale> and you can do that regardless of whether Foo was defined with record syntax
09:44:43 <nbro> nice!
09:44:47 <nbro> I really like Haskell
09:44:50 <freeside> thanks, i did not know that.
09:45:18 <Cale> Yeah, I think I learned that like a year after most of the rest of the language ;)
09:45:45 <centril> nbro: you can also use RecordWildCards and do  Foo {..} to get out the fields in your constructor as variables bound to the names you have in your record
09:45:54 <Cale> One of those cute things you tend to only discover if someone tells you or you read the Report carefully
09:46:22 <nitrix> I believe you can also pattern match on some specific record constructors too.
09:46:31 <Cale> yes
09:46:36 <nitrix> foo Bar { baz = ... } =  ...
09:46:40 <Cale> (but that *will* require record syntax of course)
09:47:04 <Cale> It's a nice way to make definitions somewhat resilient to changes in the data type
09:47:09 <Cale> though that's not always a positive thing
09:47:28 <Cale> Sometimes it's nice to be reminded by the compiler that something might need to change
09:47:28 <centril> nbro: for example:  data Person { age :: Int, name :: String } ...   case p of Person {..} -> putStrLn $ unwords ["Hello", name, ",", "age:", age]
09:47:53 <Cale> Yeah, that's the RecordWildCards extension
09:47:56 <MarcelineVQ> {} is nice with as-patterns, to see if a value is using a specific constructor, and use that value, without caring about what's inside: bar x@Foo{} = functionforFoovalues x
09:48:01 <centril> oops, forgot the  = Person  part
09:48:20 <erisco> nbro, did Cale explain what a projector is?
09:48:28 <centril> MarcelineVQ: you can also combine that with lenses for great success
09:48:35 <Cale> I didn't -- what's a projector? :)
09:48:37 <nitrix> RecordWildCards is neat too, bringing the record fields in scope.
09:48:52 <erisco> I feel like I am being trapped now
09:48:53 <centril> nitrix: it's a bit controversial i've heard... no idea why tho...
09:49:00 <MarcelineVQ> centril: do you have an example of what you mean?
09:49:02 <Cale> A fair number of people are not fans of RecordWildCards, but I think it can look pretty cute if you're simulating OO in Haskell.
09:49:13 <Cale> centril: One reason is that it binds variables without naming them
09:49:27 <centril> MarcelineVQ: do functionforFoovalues inline on x with lenses
09:49:27 <nitrix> foo Bar {..} = baz
09:49:28 <Cale> another is that it implicitly shadows a bunch of definitions while it's at it
09:49:36 <centril> MarcelineVQ: for example in AST traversal
09:49:44 <Cale> So it can be hard to refactor and manipulate code which uses RecordWildCards
09:49:46 <nitrix> Cale: I thought it named them by the name of the record fields o.o ?
09:49:52 <Cale> It does.
09:50:03 <Cale> But the definition of the type might be far away
09:50:19 <nitrix> Oh. Oh you mean it can become really obscure.
09:50:20 <Cale> and if the definition of the type changes, new variables can get bound and shadow other stuff
09:50:20 <centril> Cale: oh, right
09:50:23 <nitrix> Fair point,
09:50:48 <erisco> first I'll make Cale happy (hopefully) and say that a projector is an eliminator for a product type
09:51:00 <Cale> I would normally say "projection"
09:51:07 <centril> Cale: same here
09:51:45 <freeside> you're just projecting
09:52:48 <nbro> another question, if a data type like data TC = DC1 | DC2 is a sum type, what’s a product type (I know it exists this concept, but I would like to hear your explanations)
09:53:12 <erisco> (Int,String) is an example of a product type, a product of Int and String
09:53:20 <monochrom> data P = MkP Int Bool Char  is product of IntxBoolxChar
09:53:51 <ph88> how can i resolve the type ambiguity in this code? https://bpaste.net/show/d0a58220ed48
09:53:52 <erisco> it is what you get in every other language, it is the sum types that are usually missing
09:53:57 <nbro> ah ok
09:54:00 <nbro> as I was thinking
09:54:03 <Cale> nbro: Something like  data Foo = Foo Integer String
09:54:12 <Cale> Is a "product" of Integer and String
09:54:25 <nbro> ok, thanks! Makes sense
09:54:53 <erisco> now for intersection types
09:55:12 <centril> nbro: this might be relevant: http://manishearth.github.io/blog/2017/03/04/what-are-sum-product-and-pi-types/
09:56:28 <centril> nbro: they are called product types because the possible values of (A, B) is the cartesian product of the sets A & B, so A x B
09:57:18 <centril> nbro: sum types are called so because the possible values of  Sum A B  is all values in A + and all in B , so  Either a b = a + b
09:57:40 <erisco> now integrate the Taylor series
09:58:12 <centril> erisco: pi types?
09:58:51 <erisco> there is a particular blog post on ADTs where they derive the list zipper algebraically
10:00:07 <centril> nbro: there are even fractional types, so you can say: T * 1/T = T
10:00:09 <erisco> https://chris-taylor.github.io/blog/2013/02/10/the-algebra-of-algebraic-data-types/
10:00:12 <nbro> centril: yeah, I got that, thanks anyway ;)
10:00:28 <centril> nbro: =)
10:01:01 <centril> erisco: nice =)
10:01:05 <erisco> "What does it mean to subtract, divide or take square roots of types?"
10:01:10 <byorgey> T * 1/T = T ?  Your fractional types behave strangely
10:01:42 <centril> byorgey: whoops :P
10:02:10 <byorgey> also, I wouldn't say "there are fractional types".  No one really knows how to interpret fractions as types.
10:02:19 <centril> byorgey: T * T * 1/T = T, obviously
10:02:24 <byorgey> hehe
10:02:51 <erisco> there is this idea where you introduce an object, like i, that normally can't exist
10:02:59 <centril> byorgey: the interpretation deals with futures and promises
10:03:29 <erisco> and a way of understanding this is you're just inserting a blank
10:03:35 <byorgey> centril: are you referring to this paper  https://www.cs.indiana.edu/~sabry/papers/rational.pdf  ?
10:03:41 <erisco> and you try and eliminate it
10:04:06 <erisco> so you can find a proof where it wasn't necessary at all
10:04:13 <erisco> as far as I understand it anyways, which isn't so much
10:05:02 <byorgey> centril: that paper was never published because it has some major flaws.  The system described in the paper has only trivial models.
10:06:03 <centril> byorgey: :(
10:06:05 <erisco> well you might have 1/T as a multiplicative inverse, why not
10:06:11 <byorgey> I meant what I said: interpreting fractions as types is an open question and an active area of research.
10:06:25 <erisco> the question is if you can find a proof that does not involve 1/T
10:06:48 <erisco> i.e. transform the proof with 1/T to one which does not, for all such proofs
10:06:57 <byorgey> erisco: sure, that's fine.  I was talking specifically about *interpreting fractions as types* themseles.
10:06:59 <erisco> if you can do that then you're safe using 1/T
10:07:01 <centril> byorgey: right, that part I get and agree on
10:07:11 <erisco> right, well, seems like nonsense to me as well :P
10:07:21 <nbro> Haskell is like: once you try it, you feel like the other languages have been designed by an amateur lol
10:07:48 <centril> nbro: I get that feeling every time I move to a more strongly and statically typed language
10:07:50 <nbro> at least the languages that I know, which are quite old
10:08:05 <nbro> Haskell isn’t too young to
10:08:07 <nbro> *too
10:08:33 <freeside> meanwhile, over on #agda ... a similar conversation is happening ...
10:08:51 <erisco> I have wondered how deep the circles go
10:08:57 <centril> nbro: like <random dynamically typed language> => C => Rust, untyped lambda calculus => haskell => agda
10:09:01 <erisco> who is laughing at #agda who isn't merely an equal
10:09:03 <centril> freeside: haha, my thoughts exactly
10:09:50 <erisco> has anyone else had these thoughts? if you can one day stumble on Haskell, and another on say, Coq/Agda/Idris/DT-whatever, could there be yet another mind-blowing thing out there?
10:09:54 <nbro> looking forward to learn Rust
10:09:57 <nbro> :D 
10:10:25 <centril> erisco: in any case, #haskell vs. #agda are just squabbles within Chalmers University of Technology
10:10:39 <taktoa> nbro: that's because most other languages have literally been designed by amateurs, in the sense of being created by people who are not people-who-are-paid-to-study-programming-languages :^)
10:11:22 <centril> taktoa: hmm... well... don't know if that applies to C & C++
10:11:25 <freeside> don't all such recursive relations find a fixpoint in category theory?
10:11:49 <taktoa> centril: yeah, the problem with those was being designed too early
10:11:50 <centril> freeside: i cant parse that statement
10:12:23 <centril> taktoa: by early, do you mean: "in a time where computer resources were a fraction of what they are today" ?
10:12:24 <freeside> i mean the ultimate "mind-blowing thing out there" is category theory
10:12:49 <erisco> somewhere high in the Himalayas are a secretive organisation of computer scientists who already know if P=NP, and whether braces and semicolons are better than whitespace
10:12:49 <taktoa> centril: that and "a time where knowledge of computer science was a fraction of what it is now"
10:13:11 <taktoa> C was designed before the HM type inference algorithm was known
10:13:16 <Tuplanolla> Lisp has been around since 1958.
10:13:21 <centril> taktoa: hmm... well... what about C++ ?
10:13:25 <nbro> even though I think it’s not fair to compare, say, Rust to C++
10:14:01 <centril> nbro: Rust is a modern language with lessons from the recent decades, unlike Go, which is a regression
10:14:05 <nbro> It’s normal that future languages will be better than the ones we currently have
10:14:17 <nbro> centril: exactly
10:14:19 <centril> nbro: no... that is just not true...
10:14:34 <nbro> centril: I’m not saying all of them
10:14:37 <centril> nbro: Go is a prime example of a future language being worse than something before it
10:14:44 <erisco> I say bring back column sensitive syntax
10:14:52 <nbro> centril: I intended that we’re going to learn from the past mistakes
10:15:02 <centril> nbro: yes, at least some of us ;)
10:15:20 <taktoa> centril: C++ was designed in the early 1980s, and HM was unknown-enough in 1985 that Damas independently published his PhD thesis on the algorithm in that year
10:15:44 <erisco> poor soul
10:16:33 <centril> nbro: others prefer the route: "learning a complex language takes too much time, so I'll write code that will move all bugs to runtime instead of dealing with them at compile time"
10:16:57 <erisco> move fast, break things
10:16:58 <nbro> centril: lol, who said that?
10:17:05 <centril> nbro: these people make Dijkstra roll over in his grave
10:17:23 <centril> nbro: the inventors of Go, paraphrased
10:17:37 <okeuday_bak> is Data.Monoid imported by default like Prelude in GHC 7.10.3
10:17:39 <okeuday_bak> ?
10:17:41 <freeside> Richard Gabriel: "Worse is better!" Go: "Hold my beer."
10:17:54 <shapr> Richard Gabriel: "Better is Worse!"
10:17:59 <centril> okeuday_bak: try to use (<>) w/o importing Data.Monoid
10:18:11 <glguy> okeuday_bak: No, Data.Monoid isn't imported by Prelude in 7.10.3 nor in the current 8.0.2
10:18:21 <taktoa> I mean modern type theory was invented (for mathematics) by Martin-Lof in 1972 so my limit for blaming people for not knowing How To Do Type Systems™ is the year 2000
10:18:57 <okeuday_bak> centril: why shouldn't I import it though?
10:19:09 <taktoa> or maybe the mid 90s
10:19:11 <centril> okeuday_bak: you have to import it
10:19:16 <centril> okeuday_bak: to use (<>)
10:19:28 <centril> taktoa: why 1972 and 2000, why are these 2 years related?
10:19:39 <centril> seems arbitrary
10:19:43 <taktoa> centril: 2000 is arbitrary
10:19:51 <centril> 1972 is not, obviously
10:19:58 <taktoa> I'm merely justifying the line I've drawn in the sand
10:20:03 <taktoa> 30 years seems reasonable
10:20:13 <centril> taktoa: right, 30 years is a bit much tho...
10:20:18 <centril> 10 years seems reasonable
10:20:21 <erisco> in the sands of time, how poetic
10:20:42 <centril> taktoa: language designers should be aware in max 5 years - programmers in general maybe 20 years
10:20:43 <freeside> you need about 10 years for a generation of grad students to catch up with the literature, and then another 10 years for those grad students to become professors
10:21:02 <freeside> those professors share the ideas, and then you need another 10 years for the students under those professors to move those ideas into industry
10:21:16 <freeside> then you need another 10 years for the commercial implementation to mature and become popular
10:21:23 <freeside> so, total T = 40y
10:21:43 <centril> freeside: is that an after-the-fact rationalization ?
10:21:51 <erisco> and 10 years to wake up, 10 years to shower and get dressed, 10 years to eat breakfast
10:22:04 <taktoa> freeside: I think it's more like 5 years for each of those stages
10:22:10 <centril> erisco: waking up takes minimum of 20 years.
10:22:31 <taktoa> especially because T = 40y would imply that dependent types should be mature and popular by now :P
10:22:55 <mbw> So I've been trying to work my way through tekmo's talk about beautiful folds: https://github.com/Gabriel439/slides/blob/master/munihac/foldmap.md#applying-applicatives . The example with "average = (/) <$> sum <*> product" is supposed to be efficient, however for me there seems to be a slowdown of several orders of magnitude, compared to the hand-written average. This is what I wrote: 
10:23:01 <taktoa> wait I got the direction of the inequality wrong lol
10:23:01 <mbw> http://lpaste.net/353498 . Note that I had to modify it somewhat because of Semigroup. Given the compiler output from "-Weverything", i.e. the warnings about non-inlineable functions from Data.Monoid/Data.Semigroup, and the profiler output (I can't make read Core), what should I conclude is the reason for this? 
10:23:28 <centril> taktoa: interestingly, Rust "recently" moved away from H&M
10:23:56 <erisco> mbw, are you compiling with -O2 ?
10:24:17 <mbw> Yes.
10:24:25 <taktoa> well HM is the only reasonable basis for a type system, but the actual HM typechecking algorithm is old hat by now
10:25:04 <mbw> I'd use -fllvm, but it seems GHC only supports it till 3.7. Still, this is way slower than what tekmo claims in his talk/slides.
10:25:16 <erisco> mbw, in that case I authorise you to employ -O3, everyone brace yourselves
10:25:29 <taktoa> in particular, there have been two developments: 1. SMT solvers got fast enough to be interesting in the early 2000s and 2. bidirectional typechecking is a lot more appealing of a way to implement a type inference algorithm
10:25:37 <mbw> I thought -O3 didn't exist!?
10:25:40 <okeuday_bak> centril: thanks
10:26:14 <mbw> Doesn't seem to make much of a difference.
10:26:19 <centril> taktoa: bidirectional typechecking involves?
10:26:43 <taktoa> watch Conor McBride's talk "Worldly Type Systems"
10:27:11 <centril> taktoa: thanks
10:27:17 <taktoa> np
10:27:21 <mmaruseacph2> suppose I have a f :: MoandError CustomError m => m a and want to use it where I need a f :: IO a. I'm getting a "cannot match IOException with CustomError" at the moment. Is there a way to map between the two? Or just ignore the CustomError, as here I don't care about it
10:27:31 <centril> taktoa: <3 Connor McBride and his rant about unicode in the Agda standard library
10:27:39 <mmaruseacph2> s/MoandError/MonadError
10:27:46 <centril> "No fucking unicode!"
10:28:14 <erisco> should get him and Linus in a room together
10:28:30 <centril> taktoa: https://twitter.com/pigworker/status/764410137884909568
10:28:55 <centril> erisco: hah, Torvalds is in a league of his own...
10:29:55 <okeuday_bak> centril: I don't understand why GHC 7.10.3 doesn't want me to import mempty from Data.Monoid, it is fine with 8.0.1
10:30:04 <erisco> "Computer Science is a science only when we're desperate. When we're getting it right, it's easier than that." -- Conor McBride
10:31:10 <mbw> Is there a clean way to inline functions from base, which ghc doesn't "want" to inline, i.e. can't be specialized automatically?
10:31:11 <centril> erisco: "NVIDIA, Fuck you!" -- Linus Torvalds
10:32:11 <erisco> after spending a month in lecture on the subject, and writing an essay, I think this one sentence says it all
10:32:13 <okeuday_bak> "The import of ‘mempty’ from module ‘Data.Monoid’ is redundant" why does this happen in GHC 7.10.3?
10:33:16 <centril> okeuday_bak: dont know about mempty... but (<>) conflicts with Data.Semigroup iirc
10:33:47 <okeuday_bak> centril: the import of (<>) is working for me, it seems
10:34:16 <erisco> I can't understand the unicode hate though... set up a compose key
10:34:30 <centril> okeuday_bak:  λ> :t (<>)   ==> error in ghci
10:34:46 <centril> :t (<>)
10:34:48 <lambdabot> Monoid m => m -> m -> m
10:34:53 <centril> meh
10:34:58 <erisco> → looks so much nicer than ->, and is easily typed
10:35:10 <erisco> λ better than \, ⇒ better than =>, and so on
10:35:55 <centril> erisco: because hitting the key for latex => unicode, + then writing  "to" takes more time than  ->
10:35:58 <okeuday_bak> centril: k, so it may make sense to define my own, but still that requires me to be able to import from Data.Monoid, I am attempting to be selective about my imports but it seems that GHC is angered by this
10:36:13 <centril> okeuday_bak: why are you selective about your imports ?
10:36:16 <schell> hi all - i’m having a hell of a time tracking down a <<loop>>
10:36:29 <erisco> centril, for me it is three keystrokes, so an extra cost of one
10:36:35 <okeuday_bak> centril: just to be clear about what is coming from where and make things less ambiguous
10:37:01 <erisco> there are some annoying ones like ⊆ but it is doable
10:37:09 <centril> okeuday_bak: just do:   import Data.Monoid ((<>), mzero)
10:37:11 <schell> it seems i have some code that runs fine in my executable cabal project, but when i move it into my library it errs with <<loop>>
10:37:18 <erisco> and it is a satisfying result
10:37:19 <schell> have you guys ever run into this?
10:37:32 <centril> okeuday_bak: always be explicit about imported functions and data types, it's a good thumb-rule
10:37:37 <schell> my intuition is that laziness should be the same regardless of where the code lives
10:37:59 <centril> erisco: it also makes writing code that much more editor-dependent
10:38:19 <centril> erisco: without an editor that can do this for you, you become dependent on copy pasting symbols
10:38:30 <erisco> does it? *shrug* I just have software that runs between the keyboard and application
10:38:44 <centril> erisco: what do you do if all you are stuck with is nano on a headless server?
10:39:02 <erisco> well I still have no issues because of how my software works, it is not editor dependent
10:39:07 <okeuday_bak> centril: mzero doesn't appear to exist though, at least in older versions
10:39:16 <centril> okeuday_bak: oops... mempty
10:39:46 <centril> λ> :t mzero
10:39:46 <erisco> if all you had was an editor dependent solution then I can see why that'd suck
10:39:48 <centril> mzero :: MonadPlus m => m a
10:40:20 <okeuday_bak> centril: yeah, I am doing "import Data.Monoid ((<>),mempty)" but then GHC 7.10.3 says "The import of ‘mempty’ from module ‘Data.Monoid’ is redundant"
10:40:23 <centril> erisco: hmm.. software between keyboard and app seems fragile... it has to only do this for certain apps
10:40:47 <centril> okeuday_bak: ok, so do   import Prelude hiding (mempty) if you want to be specific
10:41:05 <centril> okeuday_bak: I would just do  import Data.Monoid ((<>)) and use mempty from Prelude
10:41:15 <okeuday_bak> centril: k, i c, I didn't realize mempty was in Prelude too
10:41:22 <erisco> centril, I don't know, I didn't implement it, but yes there has to be support from the OS to facilitate this
10:41:24 <centril> okeuday_bak: it is, but (<>) is not
10:41:30 <okeuday_bak> centril: k, thanks
10:41:52 <erisco> you have to register your process to take over keyboard input after a particular key is pressed
10:41:55 <erisco> or some trigger like that
10:42:05 <erisco> obviously the OS has features like this for things like sticky keys (joy!)
10:42:19 <erisco> and alt+ctrl+del and so on
10:42:30 <centril> erisco: this feels like super brittle if you do this via SSH... how is the middle-keyboard-hook software going to know that a certain "app" is running in the terminal over SSH?
10:42:46 <erisco> what does a certain app have to do with it?
10:42:51 <osa1> any persistent users here? how do I specify default value of a `[Text]` column in a table? `default` syntax uses backend-specific syntax but I don't know how is `[Text]` translated to SQL types!
10:43:22 <erisco> you press the compose key, now the compose software intercepts all keyboard input until it yields
10:43:42 <erisco> you type your compose sequence and the compose software sends the effective character as though the keyboard sent it
10:44:17 <centril> erisco: I only want to translate  keyboard input of  <unicode-start-trigger>+latex-command-name iff the target of the input is an editor for haskell, for example
10:44:34 <erisco> I don't know why you'd want that, but okay
10:45:05 <centril> erisco: well... otherwise the <unicode-start-trigger> would do this for all applications...
10:45:15 <erisco> yes, that is the point
10:45:43 <centril> don't know if I'm comfortable with relinquishing a key on my board to just this
10:46:01 <erisco> a single key that can enable hundreds of new characters?
10:46:22 <centril> erisco: I don't have many keys that are strategically and egonomically placed
10:46:44 <centril> you can't just pick any key anywhere on the keyboard, it has to be close to WASD + Ctrl + Shift + space
10:47:06 <erisco> I use caps lock
10:47:07 <freeside> https://www.jwz.org/blog/2016/09/searching-for-finally-got-my-emacs-setup-just-how-i-like-it-yields-excellent-results/
10:47:10 <shapr> centril: custom input mode in emacs?
10:47:17 <centril> shapr: fuck emacs...
10:47:37 <shapr> centril: be nice
10:47:39 <shapr> or else
10:47:48 --- mode: ChanServ set +o shapr
10:47:52 <centril> shapr: right... "I don't like emacs"
10:47:54 <centril> =)
10:48:00 <shapr> centril: see, that's perfectly fine
10:48:30 <centril> shapr: I blame Conor McBrides wonderful use of language ^,-
10:48:33 <shapr> I don't have Swedish keys on my keyboard, but swedish-postfix works great for me.
10:48:49 <shapr> centril: Conor is certainly expressive.
10:49:02 <centril> <3 eufemisms
10:49:03 <neophytes> Hello friends,I am receiving an error with the following source code: http://pastebin.com/rSixQLgt of  The IO action ‘main’ is not defined in module ‘Main’. How can I go about fixing it? I assume Haskell needs a main method, but I don't know how to define one
10:49:23 <centril> shapr: swedish-postfix?
10:49:50 <erisco> neophytes, if you are just toying around remove your module declaration
10:50:06 <neophytes> what is a module declaration exactly? haha
10:50:12 <shapr> centril: yeah, it's an input method for emacs that lets me compose aa -> å for example
10:50:14 <erisco> the line that begins "module ..."
10:50:30 <centril> shapr: oh, writing swedish a lot ?
10:51:00 <koala_man> neophytes: if you want to be able to type in "double 4" and things like that interactively, use ghci instead of ghc
10:51:04 <neophytes> The only other Haskell file I have has the source code: main = putStrLn "Hello world!"
10:51:34 <neophytes> ok
10:52:42 <shapr> centril: I do write a decent chunk of Swedish, yes.
10:52:52 <shapr> centril: I'm just saying, there are other options for unicode input
10:53:22 <centril> shapr: so you're a swede?
10:53:45 <centril> (I wonder how many % of #haskell are Swedish, and how much overrepresentation there is)
10:54:02 <shapr> Nah, I'm from Alabama. Where are you from?
10:54:23 <Rembane> Några stycken.
10:54:45 <shapr> telia.com suggests Sweden, but that's not always true
10:54:56 <centril> shapr: Sweden, Gothenburg, @ Chalmers University of Technology, the capital of haskell, agda, etc. =)
10:55:19 <Phillemann> Can I listen on a specific host using scotty (e.g. localhost instead of 0.0.0.0)? I just see a port.
10:56:08 <centril> shapr: I've heard haskell is more popular in Europe while OCaml is more popular in the states... is there any truth to that?
10:56:35 <t7> anyone use an auto source formatter for haskell?
10:57:37 <shapr> centril: I'm not convinced. OCaml is originally from INRIA, so it's certainly popular in France.
10:57:52 <shapr> centril: I also don't have a huge pile of usage statistics, so it's hard to say.
10:58:00 <centril> shapr: right =)
10:58:16 <mbw> Ok I just noticed something. I get decent performance when I define a Monoid instance for my data type only. However, when I follow GHC's advice and define Semigroup as well, with Monoid.mappend = (<>), this results in a significant slowdown.
10:58:29 <shapr> t7: already using https://github.com/jaspervdj/stylish-haskell ?
10:59:04 <centril> shapr: Coq as well - but Thierry Coquand moved to Chalmers
10:59:05 <shapr> centril: but I've met a pile of Haskell users in Boston and other US cities; but not here in Atlanta
10:59:16 <shapr> centril: right, that's a good point
10:59:35 <centril> He's a nice lecturer
10:59:46 <mmaruseacph2> How can I use a `f :: MonadError CustomError m => m a` as a `IO a`? I'm getting a `cannot match IOException with CustomError` at the moment. 
11:01:21 <monochrom> Perhaps you should make it MonadError IOException m?
11:01:23 <centril> mmaruseacph2: you have to actually run the specific f and get out some representation that you can convert to an IO a
11:01:36 <shapr> centril: oh, lucky you! I've met and chatted with Aarne Ranta, John Hughes and a bunch of other Chalmers people, but not recently.
11:02:52 <neophytes> My source code is simply: main::IO ()  double x = x + x quadruple x = double (double x) -- I get the following error:   The type signature for ‘main’ lacks an accompanying binding. What should I do to fix it?
11:03:03 <neophytes> I guess I'll use ghci but I'd like to get experience with ghc
11:03:04 <centril> shapr: anecdote about Aarne Ranta: he let people write exams in the PLT course in like 7+ languages...
11:03:05 <monochrom> define mina.
11:03:09 <monochrom> err, define main.
11:03:12 <shapr> centril: wow! cool
11:03:19 <neophytes> how do you go about defining main?
11:03:31 <monochrom> main = print "hello world"
11:03:40 <geekosaur> mhw, I think Semigroup's <> is missing some optimization RULES that Monoid's has; this is a matter of the ecosystem catching up with recent ghc
11:03:41 <monochrom> or whatever code you want main to run.
11:03:45 <centril> shapr: tho he wasn't the examinator for this year tho
11:03:52 <shapr> centril: I used Rant's GF to write a Swedish teaching webapp at one point, it would construct random sentences and ask for the match in either Swedish or English
11:04:14 <neophytes> ok so like this? main  = double x = x + x quadruple x = double (double x)
11:04:22 <geekosaur> it may be somewhat improved in the upcoming 8.2, because Semigroup is better integrated in general; but the current Monoid v Semigroup setup is rather hacky and nobody likes it much, aside from that it mostly maintains backward compatibility
11:04:27 <monochrom> No, that will be a syntax error.
11:04:35 <neophytes> then I don't know what to do
11:04:35 <mmaruseacph2> monochrom: I wish I could do that
11:04:46 <freeside> shapr: i'm planning to learn GF ... is that code available online anywhere?
11:04:50 <mmaruseacph2> centril: thanks, going to try it
11:04:50 <monochrom> What do you want the main program to do?
11:04:51 <erisco> main is just another definition in your program, like double and quadruple
11:04:51 <centril> shapr: hmm... how does that work given that natural languages are non-formal and stochastic in nature?
11:05:18 <neophytes> I want the main program to execute: double x = x + x quadruple x = double (double x)
11:05:26 <neophytes> so I can then compile the program and run commands
11:05:28 <monochrom> No, that makes no sense.
11:05:40 <freeside> so say main = quadruple
11:05:44 <shapr> freeside: I think it's gone forever, but it's really easy to do once you understand GF
11:05:47 <geekosaur> centril, they still have some fairly well defined rules (just, odd ones sometimes)
11:05:48 <monochrom> That will be a type error.
11:05:49 <freeside> with the appropriate decorations
11:06:03 <neophytes> so I can do things like  take (double 2) [1,2,3,4,5,6]
11:06:05 <centril> geekosaur: depends on the language... some are highly irregular
11:06:07 <neophytes> ok freeside 
11:06:23 <monochrom> That is really something for the REPL.
11:06:24 <erisco> what you want to do is forget about main and just load it in ghci, if you want to do that
11:06:33 <neophytes> ok
11:06:37 <shapr> centril: GF supports a subset of natural language that fits into the dependently typed setup Ranta put together, but it has a surprisingly large range
11:06:39 <neophytes> ill forget trying ti compile it then
11:06:53 <erisco> ghc is for making executables, ghci is for interacting with definitions
11:06:56 <centril> shapr: cool
11:06:58 <geekosaur> yes, but for English at least you can cover a large number of question cases with just verb inversion. I couldn't say how Swedish works
11:06:59 <neophytes> ok
11:07:15 <shapr> iirc, I think GF even handles some of the Indian subcontinent languages that have a separate word structure for single/double/triple/many
11:08:08 <geekosaur> (verb inversion:  "foo does work" -> "does foo work?" this sometimes requires expanding a verbed adjective into a helper verb + adjective, as one would normally say "foo works" here, but that too is highly formulaic in many cases)
11:08:33 <centril> geekosaur: "Jag kommer springa." - "Kommer jag springa?"
11:08:44 <geekosaur> er, s/adjective/adjectival verb/ except that's not the right term)
11:09:14 <geekosaur> heh. I am actually not that surprised because Swedish and ENglish descend from a common North Germanic root
11:09:22 <mbw> geekosaur: Ok, I guess that at least saves me from asking about this on SO, which I would've done otherwise. I will assume this to be a known problem from now on.
11:09:27 <geekosaur> (English got some Germanic-tainted French mixed in though :)
11:09:35 <centril> geekosaur: english grammar is highly scandinavianized
11:09:39 <erisco> you can throw a question mark on anything and make it a question?
11:10:04 <geekosaur> verb inversion is usually involved although you'll often notie ESL folks omitting it because their languages don't do that
11:10:04 <jle`> yes you can?
11:10:05 <erisco> because minimally you end up with "is this statement true"?
11:10:23 <geekosaur> (note folks from India in particular but also that that uncommon among Romance language speakers)
11:10:43 <geekosaur> also English is fleible enough that you can usually understand the intent even if ti's not grammatically correct
11:11:12 <shapr> t7: have you tried/seen hindent and/or stylish-haskell ?
11:11:14 <geekosaur> but this is #haskell not #linguistics, so.
11:11:26 <shapr> but it could be #linguistics if we all install GF :-P
11:11:33 <t7> shapr: nope i will check them out
11:11:35 <erisco> just talk about attribute grammar parsers
11:11:58 <freeside> neophytes: because the customer is always right, what you want is probably something like:    import System.Environment; double x = x + x; quadruple = double . double; main = do myargs <- getArgs; print $ quadruple $ read $ head myargs
11:12:08 <monochrom> I know exactly what to say on this. :)
11:12:33 <shapr> freeside: ooh, good answer
11:12:39 <centril> geekosaur: English = Anglo-frisian, roman invasion (latin nouns), viking invasion (scandinavian grammar + nouns like Phil Coul-son), french invasion (nouns), invading everyone else   (in chronological order)
11:12:56 <geekosaur> yep
11:13:00 <centril> geekosaur: english grammar was highly simplified by vikings
11:13:13 <geekosaur> but you can do a surprising amount just with the anglo-saxon subset
11:13:15 <shapr> freeside: I'll dig through and see if I can find my GF translation tutor, but I just deleted a huge pile of my Haskell source code from 99-2005 so it may be gone forever.
11:13:27 <monochrom> http://spl.smugmug.com/Humor/Lambdacats/i-7QXhZMR
11:13:31 <geekosaur> which is easily understood by Swedish speakers for some reason :p
11:13:51 <shapr> Mind you, I also found a copy of edwardk's Lir project and two games written by others, so that made the code spelunking worthwhile.
11:14:05 <neophytes> import System.Environment; double x = x + x; quadruple = double . double; main = do myargs <- getArgs; print $ quadruple $ read $ head myargs
11:14:10 <centril> geekosaur: hmm... I think I wouldn't understand the anglo-frisian settlers in England
11:14:10 <shapr> I found a crack attack clone (curry attack) and a pacman game in Haskell.
11:14:14 <freeside> shapr: oh, bummer. well, thanks for the offer!
11:14:18 <neophytes> wow that looks complicated
11:14:19 <neophytes> lol
11:14:24 <neophytes> ill stick with ghci for now
11:14:27 <freeside> i'm sure i will just pick it up as i go along.
11:14:31 <monochrom> Oh, this one is simpler: http://spl.smugmug.com/Humor/Lambdacats/i-NLLt4fx
11:14:31 <geekosaur> centril, likely but you're not talking to them :)
11:14:39 <neophytes> I'm trying to get used to to doing some toy problems 
11:14:41 <edwardk> shapr: i've thrown out so many different low level intermediate representations over the years i have no idea which one you have =)
11:14:41 <centril> geekosaur: reading text as well
11:15:05 <shapr> edwardk: this was the beginning of your x86_64 -> x86_64 recompiler project from 2008
11:15:12 <shapr> edwardk: do you have a more recent version?
11:15:13 <Cale> neophytes: You should try keeping (at least) two windows open: one with your text editor with a .hs file open in it, and the other with ghci open to that same .hs file
11:15:13 <edwardk> ah
11:15:28 <Cale> neophytes: whenever you save your changes, type :r in ghci to reload them and try them out
11:15:32 <edwardk> shapr: https://github.com/ekmett/jitplusplus <- this thing?
11:15:45 <neophytes> ok @ Cale
11:15:45 <edwardk> i should redo that in modern c++
11:16:02 <geekosaur> for practical purposes you can subfdivide modern English into Anglo-Saxon, Norman French overlay, and later additions from everywhere. The Anglo-Saxon and French subsets are substantial duplicates of each other, so you can say quite a lot with either one
11:16:22 <shapr> edwardk: yeah, but this version was entirely Haskell
11:16:31 <edwardk> ah
11:16:38 <centril> neophytes: one thing you can try is  hole-driven-development: http://matthew.brecknell.net/post/hole-driven-haskell/
11:16:40 <shapr> That is, the version I found in my ~/src/haskell/Lir/ dir
11:17:07 <shapr> edwardk: it even says I helped you get around a prickly bit of the code, and that doesn't seem very likely :-P
11:17:13 <edwardk> probably with a nanojit style backwards assembler code emission thing?
11:17:24 <geekosaur> even edwardk had to start somewhere :p
11:17:43 <neophytes> 'k
11:17:48 * neophytes back to programming
11:17:50 <centril> geekosaur: I think the changes from the viking invasions make English quite different than say German...
11:18:06 <edwardk> shapr: well, at one point you actually did know haskell ;)
11:18:10 * edwardk ducks
11:18:30 <geekosaur> English isn't a lot like South German at all; what it has from that actually came via the Normans
11:18:54 <geekosaur> the preserved Anglo-Saxon influence is highly Scandinavian
11:19:26 <centril> geekosaur: Wouldn't English grammar structure be more similar to German had the vikings not invaded?
11:19:35 <Phillemann> I'm not sure how to best google this, so: Is there any modern haskell extension for defining record field accessors so that they don't clash with other functions/accessors?
11:19:48 <shapr> edwardk: yeah, I'm trying to reinstall Haskell in my brain
11:20:07 <centril> Phillemann: https://ghc.haskell.org/trac/ghc/wiki/Records/OverloadedRecordFields/DuplicateRecordFields
11:20:27 <geekosaur> Phillemann, no extension as such yet althouh DuplicateRecordFields gets you partway there. you generally do that with a lens package currently (not necessarily full ekmett lens)
11:20:48 <geekosaur> OverloadedRecordFields is still in development; more of it will be in 8.2 but it'll stll be incomplete
11:20:49 <Phillemann> How would I do that with lenses?
11:21:04 <nbro> hi guys gain!
11:21:04 <Phillemann> I know about makeLenses, but does that help with name clashes?
11:21:06 <nbro> *again
11:21:10 <geekosaur> yes
11:21:16 <geekosaur> because it makes typeclass instances
11:21:26 <nbro> I’m implementing a GapBuffer data type and I’ve defined it as follows 
11:21:28 <nbro> data GapBuffer = GapBuffer { text :: String, cursor :: Int } deriving (Show)
11:21:33 <nbro> what do you think about it?
11:21:44 <monochrom> There is no gap. :)
11:21:46 <nbro> I’m required only to derive Show
11:21:54 <centril> geekosaur: edwardk went full Lens. Never go full lens!
11:21:55 <geekosaur> roughly, instance Has (some_representation_of_a_field_name) MyRecordType where ...
11:21:59 <nbro> :D
11:22:30 <Phillemann> geekosaur: Isn't that makeClassy?
11:22:30 <geekosaur> depending on the lens package, that representation may be a Symbol (type level String, sort of) or some token derived from the field name
11:22:31 <edwardk> nbro: gap buffers are usually defined with two buffers that are easily appended/prepended to.
11:22:55 <nbro> yeah
11:23:03 <edwardk> nbro: e.g. data GapBuffer = GapBuffer { reversedPrefix :: String, suffix :: String } -- now you can move the cursor in O(n) for distance n
11:23:05 <geekosaur> Phillemann, yes, isnt makeLenses the generic interface that also works for deriving accessors for other ADTs and such?
11:23:13 <nbro> but in case of Haskell it may be more convient just to keep track of the cursor
11:23:17 <Phillemann> In any case, don't I have to define the record field accessors anyway? As in "data Foo = Foo { _x :: X }", which then again clashes.
11:23:22 <geekosaur> ekmett lens is not limited to recird fields the way e.g. fclabels is
11:23:45 <edwardk> back (GapBuffer (f:fs) rs) = GapBuffer fs (f:rs); back g = g
11:23:54 <monochrom> No, String = [Char] is a singly linked list and it takes forever to "where is the 100th item?"
11:24:00 <geekosaur> yoju do need to decladre them specially but that can incllude arbitrary prefixes to disambiguate
11:24:09 <edwardk> nbro: the point of a gapbuffer is O(1) update at the cursor. your structure is O(n) to update at the cursor
11:24:12 <geekosaur> you may have to tell it what prefix scheme you are using
11:24:23 * geekosaur sighs, gets more coffee
11:24:43 <edwardk> its basically a 1-finger tree
11:24:48 <monochrom> Not to mention that the [] API is actually pretty cumbersome for tasks like "I want to insert something between the 100th and 101th items"
11:24:48 <edwardk> or a fingered list
11:25:11 <nbro> edwardk: why would it be  O(n), because I would need to create another GapBuffer when updating the cursor?
11:25:18 <erisco> "here's the 100th character!" "great, can you also get me the 99th?" *groan*
11:25:34 <centril> geekosaur: I'd say the most important diff btw french & german vs. english & swedish is that in french, verbs are conjucated by the subject, like: "j'ai, tu as, nous avons" which they are not in english: "I have, you have, we have" ... with the exception of "I am"
11:25:43 <edwardk> nbro: inserting a character at the nth position in a string takes O(n) work
11:26:02 <nbro> edwardk: oh, didn’t think about it
11:26:07 <monochrom> Locating the nth position already takes that much time.
11:26:22 <geekosaur> nbro, you need to traverse and split the Text at the cursor point. a gap buffer stores it split at the cursor, so you trade move cost (which amortizes somewhat) for fast insert at the cursor which is the most common case
11:26:34 <nbro> and the reason is that I’ve been implemeting only functions that require me to update the cursor
11:26:42 <edwardk> insert 0 c xs = c:xs; insert n c (x:xs) = x:insert (n-1) c xs; insert n c [] = ... whatever you want to do here
11:27:15 <geekosaur> if moving is much more common than insertion, or insertion can be done in bulk operations (insert large string instead of insert character) then your representation can be better
11:28:05 <edwardk> gapbuffer gives you O(1) access to the cursor, in exchange for O(n) cursor moves. finger trees give you O(log (min(k,n- k)) access to any element.
11:28:42 <mpickering> Does anyone know if there are plans for munihac again this year?
11:28:54 <edwardk> in theory, though the space story is bad, a 3 finger tree represented by somehting like data GapSeq = Gap (Seq Char) (Seq Char)  -- using Data.Sequences gives you O(1) update at the cursor, and O(log n) moves
11:29:45 <edwardk> a mutable gap buffer is used though because the reads/writes are sequential and have nice cache coherence / branch prediction
11:30:00 <centril> btw... does all allocation done by GHC happen on the heap, or are parts done on the stack? for example when you do strict evaluation ...
11:30:10 <edwardk> so making a big memory buffer, and just sliding the content to the bottom/top of it is often quite a performance win if you don't need persistence
11:30:20 <centril> (the code generated by GHC... not in GHC itself...)
11:30:37 <edwardk> centril: a lot of strict stuff happens on the stack for Int#'s and the like
11:31:01 <edwardk> and once the code is determined to be strict, ghc is good at optimizing that stuff
11:32:05 <centril> edwardk: right, but in general, if GHC can't determine that something is strict, it must live on the heap ?
11:32:24 <monochrom> Still, a list node is still on the heap, even if it is a strict list you coded up yourself.
11:32:45 <edwardk> in general yes
11:33:13 <centril> monochrom: if it is a linked list yes, but not if it is sequential (and has a size known at compile time)
11:33:21 <centril> edwardk: thanks, that makes sense =)
11:33:33 <edwardk> centril: array types etc. get allocated out on the heap too
11:33:40 <monochrom> That is also force. Even GHC's built-in bytearray is on the heap.
11:33:46 <monochrom> s/force/false/
11:34:32 <centril> edwardk: so there is no way to get a sequential array on the stack ? why not ?
11:34:33 <monochrom> The cause of the whole big fuss about "boxed type != lifted type"
11:34:47 <edwardk> An Array# in GHC is a pointer to an object that lives on the heap that holds pointers to other objects. a ByteArray# lives out on the heap and holds onto a bunch of bytes that can represent other stuff
11:36:18 <centril> edwardk: didn't know that, thanks
11:36:48 <edwardk> centril: in theory you might come up with some form of stack frame tweak to hold onto big flat arrays of bytes or stack pointers, then tweak the compiler to desugar the construction of an array that doesn't leak out of scope anywhere in the following code, followed by the deallocation of the array after doing a bunch of mutations to it to put the array on
11:36:48 <edwardk> the stack, and change the stack representation to look enough like the haskell array rep to proceed, but nobody ever bothered.
11:37:04 <edwardk> heap allocations are about the same price as a stack allocation, both are just pointer bumps
11:37:30 <edwardk> haskell arrays aren't c arrays
11:37:48 <edwardk> a c array has a fixed size. haskell arrays carry their size
11:37:53 <monochrom> If you write so much as "data X = MkX {-# UNPACK #-} !Int {-# UNPACK #-} !Char", you still have your MkX node on the heap not stack.
11:38:04 <edwardk> we can't 'inline' arrays in a c like fashion into data types either.
11:38:19 <Cale> Also if we're talking about Array, a Haskell array can have elements which are defined recursively in terms of one another, and which get evaluated lazily.
11:38:29 <centril> Also... Does referential transparency in a language like haskell require garbage collection? So you can't have an FP language + manual memory control ?
11:38:44 <edwardk> centril: laziness without gc is quite difficult to define meaningfully
11:38:45 <monochrom> Could you write your own Haskell compiler that puts it on the stack? Yes. Does GHC do this? No. Why? No one has bothered yet.
11:39:02 <Cale> centril: Note that the Haskell FFI does have operations for managing memory explicitly -- you can do your own memory management, you just have to do it in IO.
11:39:03 <centril> edwardk: but for a strict fp language
11:39:37 <edwardk> you can write in c++ with lambdas today in a strict language without gc
11:39:39 <centril> Cale: right 0)
11:39:52 <edwardk> its awkward as hell and you have to be very careful about capturing references vs. values
11:40:09 <monochrom> What if you bothered? Answer: You would find that you would spend so much effort on escape analysis and the benchmark would not be much better than GHC.
11:40:13 <edwardk> so any other language you come up with will have to be very explicit about object lifetimes and ownership of data
11:40:41 <monochrom> Because you ought to look at what "heap allocation" looks like in GHC-generated code.
11:40:53 <centril> monochrom: im not interested for performance... im interested for real-timeness, i.e: GC pauses are a no-no in some applications
11:40:56 <_sras_> What sort of mixup can result in a "Failure to unify types" error?
11:41:07 <edwardk> centril: gc pauses aren't mandatory in gc'd languages.
11:41:11 <edwardk> there are realtime collectors
11:41:15 <monochrom> Ah OK.
11:41:18 <edwardk> ghc doesn't have one
11:41:22 <edwardk> but they are implementable
11:41:43 <centril> edwardk: ah, interesting!
11:41:51 <cocreature> _sras_: as the error message already says: your types don’t match up. if you provide some code, we might be able to help you more :)
11:42:14 <t7> >tfw unreadble code but it typechecks :/
11:42:19 <edwardk> you can write a fully concurrent collector along the lines of c4 in which the mutator and collector can proceed at the same time, gc's like metronome showed you can hit good realtime guarantees
11:42:28 <monochrom> Still, GHC has uprooted the conventional wisdom about heap-stack tradeoff. For GHC, stack is a heap object.
11:42:37 <edwardk> ghc isn't engineered that way, as it doesn't come without a cost
11:42:57 <edwardk> a c4 style gc requires a _read barrier_ and in a pure fp setting, reads far far outweigh writes
11:43:35 <centril> edwardk: btw... Rust =)
11:43:36 <_sras_> cocreature: But why does this message show instead of the  usual "type does not match" error?
11:44:00 <edwardk> centril: rust exists. it doesn't solve any problem i actually have in practice, and has a turing complete type checker, but it exists, yes.
11:44:29 <nbro> is there a way to pass only one value to a data constructor which accepts only one? Reason: I need a second field as a support to the “public” field…
11:44:40 <cocreature> _sras_: probably because one of the types contains a type variable instead of a concrete type or something like that
11:44:46 <monochrom> Yikes read barrier. Why would anyone want that?!
11:44:47 <nbro> *which accepts two
11:45:03 <cocreature> nbro: what do you expect to happen in that case?
11:45:07 <centril> edwardk: I was referring to being explicit about object lifetimes - that is was Rust does
11:45:09 <edwardk> monochrom: i've got a sketch of a design for a haskell compiler that actually would exploit such a design, but its messy
11:45:17 <cocreature> you can partially apply data constructors but I think that’s not what you are trying to do
11:45:30 <monochrom> It's like "my program spends 90% of its time zeroing my memory buffers, so read barriers are OK!"
11:46:06 <Cale> centril: It's also worth noting that from the point of view of Haskell code, it's pretty much inappropriate to think of GHC's stack as a call stack.
11:46:31 <geekosaur> nbro, I think I need an example (I *think* you have a think in your problem description) but my fgirst guess is you want a smart constructor aka a function that does the actual construction
11:46:33 <Cale> It primarily consists of pattern matches waiting for their scrutinee to be sufficiently evaluated to match a pattern
11:46:40 <geekosaur> and then not export the data constructor
11:46:46 <edwardk> centril: yes, it has all sorts of ways to deal with loaning objects around to deal with nice disciplined stack-like usage. sadly the kinds of things you get with laziness tends not to follow such a structure, as evidenced by how jhc's region inference never worked out. so for haskell like code its kinda useless. and for c++-like code, i write enough of it
11:46:46 <edwardk> and manage my object lifetimes in a stylized enough manner than i literally never encounter the kinds of bugs rust is designed to prevent in my own code
11:47:03 <nbro> never mind
11:47:04 <centril> Cale: well, what about strict-only evaluation in haskell ?
11:47:09 <nbro> I think it wouldn’t work in all cases
11:47:17 <edwardk> so i'm left with no place to use rust. i can write c++ with a ton of notatonal baggage to fix a class of errors i don't experience
11:47:22 <nbro> ...
11:47:30 <Cale> centril: Well, that just adds yet more matches to functions.
11:47:40 <edwardk> with less useful templates which fix a class of errors and provide code reuse i _do_ use ;)
11:48:12 <Cale> centril: At some level, it's all turned into case expressions
11:48:28 <Cale> and those case expressions control the stack
11:49:15 <edwardk> monochrom: the self-healing read barrier stuff actually works out pretty well in terms of fixing up the asymptotics of concurrent gc, the problem with the write-barrier approach arises in pathological cases where the gc and the mutator keep tripping over each other
11:49:16 <geekosaur> centril, strict evaluation or no, haskell is still graph reduction not linear execution
11:49:51 <centril> edwardk: you're a very smart guy & you are not everyone ;) memory unsafety is probably the #1 source of bugs when writing C & C++ for most applications
11:50:15 <Cale> Also, I strongly question the value of that extension -- it's usually going to be unhelpful imo.
11:50:28 <centril> Cale: what extension?
11:50:29 <ReinH> Cale: can we call it a graph reduction stack?
11:50:46 <Cale> centril: The one which strictifies everything
11:50:47 <monochrom> I just call it "stack".
11:51:19 <monochrom> Also it could be "call stack" but you have to change the meaning of "call".
11:51:36 <centril> Cale: oh that one... I haven't used it... If I care about RTS, I drop into Rust
11:52:20 <centril> Wel... I haven't done any non-university stuff with haskell yet, so...
11:52:53 <nbro> question: if have a data type defined with the record syntax, like data MyData = MyData {f1::String, f2::String}, apparently f1 and f2 are functions (as someone told me before)… what’s exactly the scope of this functions?
11:53:09 <geekosaur> same as any other function defined in that source file
11:53:12 <edwardk> centril: sure. lots of people pass stuff by reference and don't think about object lifetimes. i'm just careful to think of it as meaning the same thing as the sort of 'loan's i can do in rust and never claim ownership of passed pointers/references. instead requiring unique_ptr or shared_ptr discipline for anything that involves ownership transfer. modern
11:53:12 <edwardk> c++11+ encourages this pattern. valgrind, etc. are pretty darn good at catching when you violate it. the ecosystem there has had a long time to figure out how to live with its demons. ;)
11:53:31 <monochrom> Consider "case sin 5 of 0 -> ...". We gosub to the evaluation of sin 5, then return to continue the pattern matching. The case expression calls sin 5, then sin 5 finishes and returns to the case expression. The call stores how to return to the case expression. If you understand this sense of call, you can say "call stack".
11:53:39 <edwardk> centril: but lots of c/c++ is written by people who have no idea what they are doing
11:53:51 <nbro> geekosaur: ok, I thought they could be somehow special… 
11:54:05 <geekosaur> in particular you control its export by its name, iirc the function is not exported with the constructor (but the *label* is, that is for use as part of the constructor instead of for retrieving the field value)
11:54:08 <monochrom> But why overcommit yourself? Just say "stack". No one will misunderstand that you're dissuading from cabal. :)
11:54:42 <monochrom> Yikes, s/The call stores/The stack stores/
11:54:52 <geekosaur> you do need to keep the two separate, but an easy way to do that (sigh) is that labels are not first class --- they can only be used in specific circumstances and you can't replace them with bindings
11:55:19 <EvanR> bet you didnt know about this https://en.wikipedia.org/wiki/Metamonad
11:55:22 <geekosaur> example: record update syntax someRecord { label = value } -- the label must be literal and is not a function or etc.
11:55:50 <centril> edwardk: I'd say that concurrent imperative programs are complicated enough that it is very easy for even proficient C++ programmers to make mistakes... Just look at the flaws in Firefox that Rust just erases
11:56:25 <monochrom> Yikes, termites eat metamonads.
11:57:00 <centril> who's idea was it to call it stack... yikes...
11:57:35 <centril> one has to think of the googlability of names
11:57:35 <monochrom> Well it's probably inspired by the "full-stack developer" kind of "stack".
11:58:09 <geekosaur> centril, nobody thought about that with c++. or c# for that matter
11:58:22 <ph88_> can anyone help with resolving the type ambiguity in this code? https://bpaste.net/show/d0a58220ed48
11:58:31 <srhb> centril: Try using Nix or NixOS.
11:58:38 <centril> haha... googleability is an actual word... https://en.wiktionary.org/wiki/googleability
11:58:43 <srhb> centril: No google can save you there...
11:58:46 <monochrom> Haha
11:58:57 <edwardk> Firefox has very complicated object lifetimes, complicated by almost-directly exposing their internals to javascript. A huge fraction of their complexity and leaks arise from the completely over-complicated clusterfuck that is xpcom that they use to glue everything together. For a project like firefox? Where you're mixing GC'd user controlled stuff and
11:58:57 <edwardk> random COM-like objects with awful reference counting? Replacing as much of that as humanly possible with something like rust? Huge win. Why? What it is replacing is a poorly thought out, overly engineered abomination.
11:59:39 <centril> edwardk: forgot about XPCOM :p
11:59:42 <ReinH> (if you're really bad at reference counting, letting a computer do it for you is a big win)
12:00:23 <edwardk> centril: long long ago, i once wrote a web server that used the guts of the xpcom objects in firefox to do the content serving ;)
12:00:24 <srhb> Speaking about resources, tweag.io posed a blag on the linear types paper. http://blog.tweag.io/posts/2017-03-13-linear-types.html (in case that wasn't what spurred this discussion)
12:00:33 <edwardk> well, it was mozilla still at the time
12:01:09 <centril> srhb: it wasn't, it was sparked by a question regarding if and how GHC uses the stack
12:01:10 <edwardk> srhb: i'm somewhat dubious, just because of how many standard compiler optimizations linear types stomp all over.
12:01:41 <srhb> edwardk: I admit I haven't considered much how it interacts with things that aren't linearly typed. it seems exciting if it can be compartmentalized though.
12:01:42 <edwardk> srhb: but i'll happily be proven wrong by people deriving actual benefit from this stuff if it ever helps something
12:01:54 <lyxia> ph88_: "eot" does not occur in "Traversal' a Int"
12:02:03 <srhb> edwardk: Obviously the dream is noGC $ linearlyDo ... :-P
12:02:06 <edwardk> srhb: things like lambda lifting / lambda lowering mess with linearity
12:02:18 <MarcelineVQ>  EvanR: I've no retortamonad for that
12:03:21 <srhb> edwardk: Maybe the optimism is premature... :)
12:03:21 <edwardk> so far its basially a proof of concept showing that you could tweak some parts of the compiler to at least type check linearity, but there is no actual derived benefit in the compiled objects yet just that you can say things more directly this way.
12:03:34 <centril> this is the best thing about IRC - being handed awesome papers and talks
12:04:20 <edwardk> if you want to just type check stuff with linear types for an edsl, etc. jeff polakow has a way of encoding a dsl with linear types and to get ghc to typecheck it, i think oleg et al have another way to encode it, etc.
12:04:21 <srhb> edwardk: But even without the potential allocation strategies, this could prove problematic for regular typing?
12:04:46 <edwardk> srhb: you can encode dsls with linear types today in haskell. the encoding is rather more baroque
12:04:48 <srhb> edwardk: Yes, I saw the Kiselyov in passing.
12:05:18 <edwardk> http://functorial.com/Embedding-a-Full-Linear-Lambda-Calculus-in-Haskell/linearlam.pdf
12:05:21 <srhb> I suppose the whole question is whether it integrates. if it does, it's pretty awesome, even without special allocation strategies.
12:05:24 <edwardk> that is jeff's version
12:05:29 <srhb> edwardk: Thanks!
12:05:54 <edwardk> i used something similar for a quantum computing EDSL i showed at a summer school a few years back
12:06:09 <edwardk> so i could ensure affine use of all my qubits
12:06:43 <srhb> Related to Quipper?
12:06:43 <edwardk> made it nice and easy to ensure i had unitary operators
12:07:12 <edwardk> mine was more an exercise in showing off finally tagless encodings and how to build edsls out of things like free and codensity
12:07:20 * srhb nods
12:07:26 <edwardk> since at the time we didn't know about reflection without remorse
12:07:35 <edwardk> and codensity was the one hammer i had to fix up the asymptotics of free
12:08:15 <srhb> When all you've got is a codensity comonad, every problem looks like ???
12:08:41 <monochrom> a potential victim of the continuation passing style :)
12:08:44 <srhb> :-)
12:09:22 <edwardk> https://github.com/ekmett/dsl2011/blob/master/VectorSpace.hs i think was the demo edsl without linearity, then we did an exercise during the class of building up a lib in the oleg/ken style.
12:09:38 <edwardk> it was a 3 day workshop.
12:09:54 <edwardk> this was one of a dozen or so examples
12:10:44 <edwardk> https://github.com/ekmett/dsl2011/blob/master/QM.hs is one artifact i had lyng around. i don't remember if its what we started the finally tagless form with, or what we ended the session with
12:10:58 <nitrix> srhb: a hammer.
12:11:45 <ReinH> srhb: I believe you are looking for "Kan extension".
12:12:31 <shapr> I filed one of those on my taxes, and it make the IRS cry.
12:12:59 <ph88> lyxia, good tip thx, i will continue fixing some more errors
12:13:42 <srhb> edwardk: I can't even imagine going through that even in a 3 day workshop. I think I need to reread the papers. :)
12:14:37 <edwardk> srhb: i'm a grueling taskmaster =)
12:14:58 <srhb> edwardk: Ah, then it's a piece of cake ;-)
12:15:15 <ystael> shapr: bahaha
12:19:09 <Zemyla> Hmm, edwardk, a question about your adjunctions package.
12:20:00 <edwardk> Zemyla: shoot
12:22:00 <Zemyla> Would including something along the lines of liftEqRep :: (Traversable f, Representable f) => (a -> b -> Bool) -> f a -> f b -> Bool, and similarly for liftCompareRep, be useful?
12:22:30 <Zemyla> Actually, those just need Foldable, not Traversable.
12:23:46 <freeside> IHNJ,IJLS "Grothendieck bifibration"
12:24:46 <shapr> freeside: what's the IHNJ and IJLS? My first thought was myers-briggs, but that's not it.
12:25:44 <freeside> i have no joke, i just like saying
12:26:22 <amf> is there any way to use applicative style with a data types record fields? i have a rather large structure and id like to use the record names as hints
12:27:14 <Zemyla> liftEqRep :: (Foldable f, Representable f) => (a -> b -> Bool) -> f a -> f b -> Bool; liftEqRep eq = \fa fb -> foldr (&&) True $ mzipWithRep eq fa fb
12:27:37 <AppAraat> hello, I'm trying to run a little Haskell program but I have no idea where to start. I downloaded it here - https://github.com/tensor5/flAccurateRip - and I tried doing "ghc -o flaccurate Setup.hs" but it doesn't seem to accept any input.
12:28:27 <freeside> amf: https://ocharles.org.uk/blog/posts/2014-12-04-record-wildcards.html ?
12:28:44 <amf> AppAraat: cabal sandbox init && cabal install
12:29:18 <shapr> amf: already familiar with lenses?
12:29:31 <Zemyla> liftCompareRep :: (Foldable f, Representable f) => (a -> b -> Ordering) -> f a -> f b -> Ordering; liftCompareRep cmp = let { cmbC EQ b = b; cmbC a _ = a } in \fa fb -> foldr cmbC EQ $ mzipWithRep cmp fa fb
12:29:43 <AppAraat> amf: cabal: unrecognised command: sandbox (try --help)
12:29:54 <amf> shapr: somewhat...
12:31:11 <amf> AppAraat: likely on an old version of cabal. download stack ( haskellstack.org ) and do "stack init"
12:31:53 <Zemyla> Also, edwardk, pureRep could probably be changed to pureRep :: (Distributive f) => a -> f a; pureRep a = fmap getConst $ distribute $ Const a
12:32:10 <shapr> amf: I use lens to easily grab fields from records: https://hackage.haskell.org/package/lens-tutorial-1.0.2/docs/Control-Lens-Tutorial.html and https://github.com/shapr/tmuxmarta/blob/master/src/Lib.hs
12:32:12 <AppAraat> amf: ok I'll try that, thanks.
12:32:34 <sigrlami> hey folks, I'm using yesod and yesod-job-queue library that exposes only simple context (MonadBaseControl IO m, MonadIO m), how can I add MonadLogger without chaning library? I want to use logInfo, logError inside jobs 
12:33:58 <shapr> amf: does my answer relate to your question at all? :-)
12:34:47 <amf> shapr: not really... i want something like: Blah <$> _someField = whatever <*> _otherField = pure Nothing
12:35:00 <edwardk> Zemyla: the pureRep thing is cute. the Foldable bit may be a bit underdetermined, as Foldable doesn't guarantee it hits all the 'a's in the structure, technically
12:35:15 <edwardk> Zemyla: sorry that reply took so long . real life is intervening
12:35:29 <Zemyla> edwardk: Requiring Traversable would, though.
12:35:31 <nbro> lol, implemented correctly a “render” function for a GapBuffer using the two buffers style at the first attempt
12:35:38 <nbro> render :: GapBuffer -> String
12:35:40 <nbro> render GapBuffer {before = [], after=val} = val
12:35:41 <freeside> yay you did it
12:35:42 <nbro> render b = render GapBuffer {before=tail (before b), after=head (before b) : after b } 
12:36:07 <nbro> loooool
12:36:14 <shapr> amf: you're constructing Blah with values from a record?
12:36:18 <edwardk> Zemyla: yeah traversable is definitely sound
12:36:43 <edwardk> nbro: keep in mind the before buffer should be reversed
12:36:56 <edwardk> so its more like render (GapBuffer as bs) = reverse as ++ bs
12:36:57 <nbro> edwardk: it is indeed
12:37:01 <nbro> the way I implemented
12:37:10 <nbro> it
12:37:20 <ph88> i have 3 errors here and i don't understand any of them, could someone take a look ?  https://bpaste.net/show/1166c0594a67
12:37:39 <amf> shapr: no, i want to label the positions so its clear what is being used
12:37:44 <nbro> edwardk: for example, a moveLeftCursor function looks like this: moveLeft b = if atStart b || atEnd b then b else GapBuffer {before = head (after b) : before b, after = tail (after b)}
12:38:48 <edwardk> why does moving left have a problem with being at the end?
12:38:54 <edwardk> it should just be one or the other
12:39:55 <nbro> edwardk: I don’t want it to give an error, but just to return the GapBuffer unchanged if the second list is empty, since you would not be able to move left anymore
12:40:58 <edwardk> foo (GapBuffer (f:fs) bs) = GapBuffer fs (f:bs); foo g = g  -- moves 'backwards'
12:41:17 <edwardk> foo (GapBuffer fs (b:bs)) = GapBuffer (b:fs) bs; foo g = g -- moves 'forwards'
12:42:03 <edwardk> the foo g = g handles the 'already at start' case for moving backwards, and the already at end case for moving forward
12:42:47 <nbro> if you have a GapBuffer like this GapBuffer {before=“”, after=“”}, if I didn’t have the check atEnd b (which in this case returns also true), I would do some tails or heads on empty lists
12:43:24 <edwardk> shouldn't
12:43:31 <edwardk> ee the thing i showed above? 
12:43:48 <edwardk> it only took the head off of f:fs, then consed onto bs
12:44:02 <edwardk> only one list got 'head/tail'ed or pattern matched in this case
12:44:11 <edwardk> the other is only ever consed onto
12:44:13 <edwardk> check your logic
12:44:21 <edwardk> consing onto an empty list is safe
12:44:37 <edwardk> gotta go
12:44:54 <nbro> ok, I will save this conversation and I will check later, because now I have to leave … :D
12:45:12 <nbro> edwardk: thanks again!
12:45:23 <shapr> amf: did you look at freeside's suggest of record wildcards?
12:50:29 <zcourts> Any got (and willing to share) or know of a script available that can parse the output of ghc --show-packages - I'm linking to GHC, including Haskell in a C++ app using cmake to find GHC and its libraries but can't suss the best way to do it. Found the --show-packages arg which seems to have all the info. 
12:51:33 <ph88> zcourts, sounds like a cool project !
12:52:02 <geekosaur> zcourts, I think you want to look at ghc-pkg
12:52:21 <amf> i did... not what im after.. im fairly certain its not possible, which is fine
12:52:34 <zcourts> ph88: It is! Having lots of fun wit this
12:52:35 <geekosaur> ghc-pkg list --simple-output --names-only
12:52:43 <zcourts> geekosaur: thanks, I'll have a look at that
12:52:53 <ph88> zcourts, why you use c++ too ?
12:53:02 <geekosaur> actually I think you just want ghc-pkg dump
12:53:08 <geekosaur> which should give you easily parsed output
12:53:24 <geekosaur> fsvo easily parsed...
12:53:46 <zcourts> awesome, thanks geekosaur
12:53:51 <geekosaur> actually it's not that bad to parse, certainly easier than what the ghc version vomited agt me
12:54:14 <geekosaur> eitjher one string on the same line as the key, or an indented list without commas etc. following
12:54:52 <zcourts> ph88 huge code base already in C++. Using Haskell DSL and want "Sparks"
12:55:20 <ph88> Sparks ?
12:55:28 <zcourts> geekosaur: looks more manageable. Thanks
12:57:03 <zcourts> ph88 forkIO basically
13:06:53 <sphinxo> How can I use nest from https://hackage.haskell.org/package/ansi-wl-pprint-0.6.7.3/docs/Text-PrettyPrint-ANSI-Leijen.html with parens to do http://lpaste.net/6147885718719954944
13:06:58 <sphinxo> ( the latter one )
13:07:22 <sphinxo> oh and the <+> is mean't to be <$>
13:20:22 <mbw> Earlier today I noticed a slowdown when defining a Monoid via Semigroup (GHC 8.0.1/2) compared to just Monoid. geekosaur noted that Semigroup probably hasn't been given appropriate pragmas yet, since it's a fairly new addition to base, and that the situation might improve with GHC 8.2. Still, how could I confirm that this is a problem already recognized by GHC devs? Would there be a corresponding bug ticket, 
13:20:28 <mbw> or is there another page dedicated to this kinda stuff?
13:21:25 <Cale> mbw: What kind of slowdown do you mean? How did you write the Monoid instance?
13:21:36 <heArtbreakers> My batt 3% only
13:22:19 <Cale> Which pragmas was geekosaur talking about?
13:24:41 <sphinxo> given [a,b,c...] how can I do a <$> b <$> c
13:24:55 <sphinxo> fold?
13:25:01 <Cale> sphinxo: How do you expect that to typecheck?
13:25:20 <heArtbreakers> Using zelbra
13:25:24 <sphinxo> bad example, for a list of the same type
13:25:48 <Cale> But yeah, that kind of thing would be a foldr or foldl depending on the way you'd like the association to go
13:25:58 <heArtbreakers> Cya later
13:26:17 <Cale> (and if you want foldl, probably you really want foldl')
13:26:18 <mbw> Cale: Ok, I scrolled back and he was referring to RULES. I'll paste the example I was running.
13:27:20 <Cale> I was unaware of any RULES for Monoid to begin with
13:27:48 <Cale> mbw: It's possible that something is preventing your instance from inlining
13:28:02 <Cale> But yeah, paste it and let's take a look
13:29:21 <ph88> could someone take a look at this paste https://bpaste.net/show/1166c0594a67 ?? on those errors i get a mismatch on actual type and expected type, but i don't understand why those types are expected
13:30:05 <Cale> "Actual type: f this" lol
13:30:29 <ph88> lolol
13:30:41 <ph88> hadn't seen that one yet xD
13:31:15 <Cale> Well, unfold the definition of Traversal' if you want to make any sense of this
13:31:27 <ph88> what do you mean unfold ?
13:32:03 <Cale> type Traversal' s a = Traversal s s a a
13:32:08 <Cale> type Traversal s t a b = forall f. Applicative f => (a -> f b) -> s -> f t
13:32:38 <Cale> We're attempting to write an instance for  EotTerminal (Either this next)
13:32:56 <Cale> class EotTerminal eot where
13:32:56 <Cale>   eotTerminal :: Traversal' eot Int
13:33:20 <Cale> So  eotTerminal :: Traversal eot eot Int Int
13:33:43 <unclechu> hey guys, can i force `hlint` to read `default-extensions` from *.cabal file?
13:33:51 <Cale> and  eotTerminal :: forall f. (Int -> f Int) -> eot -> f eot
13:34:02 <Cale> and in this case, eot = Either this next
13:34:13 <unclechu> it shows me irrelevant parsing errors because some of extensions specified as `default-extensions` in cabal-file
13:34:46 <Cale> So the type of eotTerminal in the instance is  eotTerminal :: forall f. (Int -> f Int) -> Either this next -> f (Either this next)
13:35:09 <ph88> oh that's what you mean with unfold is go from TH to normal haskell ?
13:35:14 <ph88> Traversal'  is TH right ?
13:35:18 <Cale> There's no TH here
13:35:20 <ph88> oh
13:35:22 <Cale> That's just a type synonym
13:35:53 <Cale> unclechu: My solution to this is just to never ever use default-extensions
13:36:06 <Cale> unclechu: This has a lot of other benefits
13:36:13 <mbw> ok here it is: http://lpaste.net/954950385871618048
13:37:01 <ph88> Cale, i'm not sure which type i would want here
13:37:08 <mbw> This is the version using Semigroup, which is eliminated easily, if you want to compare it with Monoid-only-performance.
13:37:34 <Cale> mbw: btw, -O3 is out of range -O2 is the highest optimisation level
13:37:52 <Cale> (it will fix that for you though -- at one point it used to just ignore the flag)
13:37:55 <mbw> Yeah I thought so, too, however someone suggested I better use it :/
13:38:15 <kuribas> I found it does more optimizations with -O2
13:38:17 <mbw> But I did try it with -O2 as well, for the record.
13:38:20 <ph88> Cale, in other words, i'm not sure if i should change the actual type or change the expectation of the type
13:38:36 <erisco> I was being jocular
13:39:03 <Cale> ph88: You probably want Left <$> eotTerminal f fields
13:39:09 <mbw> k, my bad
13:39:44 <ph88> Cale, ok i believe you but how do you get this idea ?
13:40:04 <Cale> ph88: Well, what's the type of eotTerminal f fields?
13:40:16 <Cale> (if you don't know, the compiler error tells you)
13:40:32 <Cale> (but you should probably think it through for yourself)
13:40:35 <ph88> f this   lol
13:40:39 <Cale> right
13:40:51 <Cale> and you want something of type  f (Either this next)  right?
13:41:12 <Cale> So that suggests that we ought to fmap Left over what you've got there
13:41:22 <Cale> at least, that's the most obvious thing to do
13:41:55 <ph88> where you say "right?" i wasn't sure about that either, so that's why i was asking where you get that idea (it's probably right though)
13:42:06 <ph88> ok i guess it aint that obvious to me
13:42:29 <ph88> that still leaves the last error of line 128
13:42:46 <Cale> ph88: Well, if I gave you something of type A, and asked you to give me something of type Either A B, you would probably guess to apply Left, yeah?
13:43:14 <Cale> mbw: I'll try some stuff in a moment, but maybe try adding {-# INLINEABLE ... #-} pragmas to the method implementations in your instances
13:43:49 <Cale> Er, or should it be {-# INLINE ... #-} ?
13:43:50 <Cale> I dunno
13:44:12 <ph88> yeah ok, i guess it flows naturally from the given type of eot
13:44:32 <mbw> Me neither, I don't have that much experience with pragma-pased optimization yet.
13:44:42 <ph88> Couldn't match type ‘f’ with ‘(->) ()’  is that second thing a function that takes an argument and returns void ?
13:44:45 <Cale> https://downloads.haskell.org/~ghc/latest/docs/html/libraries/base-4.9.0.0/src/GHC-Base.html#instance%20Monoid%20%5ba%5d -- see here for an example
13:44:59 <mbw> ok
13:45:06 <mbw> Let's do this!
13:45:22 <Cale> ph88: That second thing is (->) partially applied to ()
13:45:59 <ph88> oh is this a type level thing ?
13:46:04 <Cale> Yeah
13:46:40 <Cale> I don't know where you're getting that, so I can't tell you why it's telling you that, but it looks like maybe you're giving an additional argument of type () to something
13:46:41 <dolio> Cale, mbw: `mappend = (<>)` can't inline, it isn't saturated.
13:46:42 <ph88> so instead of id i probably need some lens thing ?
13:46:57 <dolio> (<>) can't inline, that is.
13:47:19 <mbw> Ok, adding INLINE to everything makes it fast.
13:47:28 <mbw> To all instance implementations, that is.
13:47:35 <Cale> nice, but see also dolio's comment
13:47:55 <dolio> Known calls to `mappend` could inline into `(<>)`.
13:47:57 <mbw> The warnings about MonoidSum/SemigroupSum not being specializable persist.
13:48:01 <ph88> Cale, what do you mean "i don't know where you're getting that", what's that? The inspiration of the code i'm trying to fix is right about it in code piece 1 and code piece 2
13:48:15 <Cale> ph88: I mean, that specific type error
13:48:40 <ph88> it's in line 58 of the paste
13:48:47 <ph88> i put line numbers near the code
13:48:56 <mbw> dolio: What does "not saturated" mean?
13:49:02 <ph88> but the line numbers of the paste don't line up with the line numbers of the error message
13:49:16 <Cale> mbw: Not applied to as many arguments as it could be
13:50:05 <Cale> ph88: oh, I see
13:50:11 <mbw> In the sense of being used in a curried context?
13:50:34 <Cale> ph88: Well, again, what's the type of eotTerminal supposed to be here?
13:51:30 <ph88> Cale, i think still the same type as you told me before   eotTerminal :: forall f. (Int -> f Int) -> eot -> f eot   where eot is Either this next
13:51:40 <Cale> nope, eot is something else now
13:51:45 <Cale> eot is ()
13:52:00 <Cale> So it's  forall f. (Int -> f Int) -> () -> f ()
13:52:02 <Cale> right?
13:52:08 <ph88> ye
13:52:13 <ph88> so maybe   f <$> ()  ?
13:52:16 <ph88> i will try it
13:52:52 <ph88> hhmm no    Actual type: f (f Int)
13:53:29 <ph88> this  Int  is not good
13:53:50 <ph88> here   eotTerminal :: forall f. (Int -> f Int) -> eot -> f eot    Int needs to change to something else i think
13:54:05 <Cale> Well, there are some things you could do. A simple one would just be to produce the empty traversal and have the right hand side be  pure ()
13:54:18 <ph88> i was trying to make a type hole but i couldn't do it on a class
13:54:53 <Cale> The question is, what Int values does () have in it?
13:54:57 <ph88> ok it compiles now, but i'm pretty sure that   Int   i put there is nonsense
13:55:06 <Cale> Might be.
13:55:21 <Cale> I have no idea what the intention of the code is
13:55:41 <ph88> it's a library to work with GHC.Generics combined with Lens traversal
13:56:01 <ph88> i think () is suppose to denote the end of the data constructor fields
13:56:33 <ph88> if i wouldn't be generating Ints, but a list instead then in that spot i should put the empty list
13:56:39 <ph88> or with Ints maybe a 0
13:56:54 <ph88> eh i forgot the word for it, something about monoids, 1 sec
13:57:12 <ph88> mempty
13:57:13 <ph88> ye
13:57:28 <Cale> You certainly could do something like  eotTerminal f () = () <$ f 0
13:57:39 <ph88> i was using this eot code before on a pretty printer so i put there P.empty  for the empty Doc
13:57:46 <Cale> Probably unhelpful though -- not a very good traversal that
13:58:37 <ph88> maybe this type signature  eotTerminal :: Traversal' eot Int  should change to  eotTerminal :: Traversal' eot eot
13:58:56 <ph88> because i don't want Int .. i just put Int there because i couldn't make a type hole
13:59:15 <Cale> I don't understand what you mean by type hole there.
13:59:20 <ph88> _
13:59:35 <Cale> You want the compiler to decide for you what type your class method should have in general?
13:59:35 <ph88> sometimes i put that in function signatures and GHC infers the type
13:59:36 <merijn> ph88: Type hole as in PartialTypeSignatures, or typed hole?
14:00:10 <ph88> i tried to put _ there to let the compiler throw an error and tell me what the expected type should be, so i can put the correct type there
14:00:11 <Cale> Yeah, that's not going to fly -- you really need to figure out what it is that you want. :)
14:00:32 <ph88> how can i find out ?
14:00:49 <Cale> Well, you can find out by starting with code that doesn't involve type classes at all
14:01:15 <Cale> and abstracting over an actual pattern that has come up
14:01:28 <ph88> the tutorial says i must use type classes
14:01:43 <Cale> w... which tutorial is this?
14:01:56 <ph88> there is one serialization example and one deserialization example https://generics-eot.readthedocs.io/en/latest/tutorial.html
14:02:54 <ph88> i don't need to go to Int's .. i'm just trying to make a generic function that can be used with Lens for traversing
14:03:13 <dolio> mbw: Your definition of `(<>)` had two arguments to the left of the =, but your use in `mappend` had 0.
14:03:22 <Cale> Well, traversing fields of *what type*?
14:05:02 <ph88> Cale, lots of types https://bpaste.net/show/2576c10d7cf4 that's why i use GHC.Generics so i can traverse on the Rep resentation
14:05:31 <ph88> i can use fromEot and toEot 
14:06:28 <mbw> dolio: So it would make a difference if I wrote mappend x y = (<>) x y?
14:07:12 <mbw> Also, -ddump-inlinings seems to suggest that mappend and (<>) were inlined, but maybe I am reading that wrong.
14:07:26 <ph88> fromEot :: (Rep a ~ M1 D c f, EotLib.HasConstructorsG f, Datatype c, Generic a, generics-eot-0.2.1.1:Generics.Eot.Datatype.GenericConstructors f) =>  EotLib.EotG (Rep a) -> a
14:07:51 <ph88> i think i will be traversing on the   Rep a  
14:08:00 <ph88>  EotLib.EotG (Rep a)  i mean
14:08:07 <dolio> mbw: Yes, it would make a difference with respect to the definition of (<>) getting inlined into the definition of mappend.
14:09:37 <dolio> In your example it might not matter, because `mappend` might get inlined to `(<>)` which is saturated and can itself inline.
14:10:45 <dolio> The former would be the difference between defining things directly in Monoid vs. Semigroup, though.
14:11:05 <mbw> This all seems very finicky.
14:12:49 <fuzzy_id> heya, i want to do a version bump in haproxy from 1.7.2 to 1.7.3. shall i do commits and pull requests on the master branch?
14:12:52 <ReinH> GHC optimizations can be finicky.
14:13:11 <fuzzy_id> the nix manual says to avoid working on it…
14:15:03 <mbw> Still, a structured approach must be possible. From a productivity perspective (i.e. before resorting to reading Core/asm), which dump files are the most conlusive and should be checked first?
14:15:08 <ReinH> fuzzy_id: is... that a Haskell question?
14:16:15 <mbw> After all, profiling output only gives you a naughty list...
14:16:51 <fuzzy_id> ah, sorry!
14:16:54 <fuzzy_id> wrong channel
14:18:45 <nilof> Question: I'm trying to make a Heap typeclass with a default instance of monofoldable, but the compiler complains about overlapping instances even for things which are not heaps
14:18:51 <nilof> Here's ny current conde
14:18:53 <nilof> http://lpaste.net/353502
14:19:14 <merijn> nilof: Honestly, heaps don't sound like a good candidate for a typeclass
14:19:18 <mauke> there's no such thing as a default instance
14:21:00 <hereForMatrices> hi, I'm messing around with a matrix I've defined, newtype Matrix a = Mat ((Int, Int), (Int, Int) -> a) and had questions about a function I'm trying to apply. I don't understand why it's not working. 
14:21:45 <nilof> I can implement a heap typeclass just fine, and Okasaki does it as well in his book, I just want to define an instance of monofoldable
14:22:08 <nilof> without having to duplicate my code for every different kind of heap
14:24:22 <sphinxo> How can I make happy show what it has parsed so far, when it errors?
14:25:11 <nilof> the code itself works fine, but the MonoFoldable instance messes with other code that uses MonoFoldable
14:26:26 <mbw> hereForMatrices: People would quite possibly be able to help you with your actual questions... You can post some sample code here: http://lpaste.net/new/haskell
14:27:45 <hereForMatrices> Thanks mbw, I'm pasting it now
14:28:37 <merijn> nilof: Well yes, what you want isn't really possible
14:29:03 <lpaste_> HereForMatrices pasted “matrix ” at http://lpaste.net/353503
14:29:42 <hereForMatrices> Oh cool, there's a bot! I keep getting errors regarding the where on the pointwiseApply function
14:30:20 <merijn> hereForMatrices: Could you lpaste the errors too? :p
14:30:31 <Koterpillar> hereForMatrices: what are the types of r1 and r2?
14:30:52 <hereForMatrices> r1 and r2 should both be of type a
14:30:55 <merijn> hereForMatrices: Oh, actually I already see the error
14:31:06 <merijn> hereForMatrices: Line 16 and 19
14:31:09 <lpaste_> HereForMatrices revised “matrix ”: “matrix ” at http://lpaste.net/353503
14:31:10 <merijn> :t '+'
14:31:13 <lambdabot> Char
14:31:16 <merijn> Char is not a function
14:31:27 <Koterpillar> hereForMatrices: they are not
14:31:30 <freeside> i am not a function. i am a FREE MAN!
14:31:40 <merijn> hereForMatrices: Presumably you meant (+)?
14:31:42 <merijn> :t (+)
14:31:43 <Koterpillar> hereForMatrices: in Mat ((x1, y1), r2), r2 :: (Int, Int) -> a
14:31:46 <lambdabot> Num a => a -> a -> a
14:32:06 <hereForMatrices> Wait, Koterpillar, I'm not sure I understand
14:32:08 <sphinxo> any guides on debugging happy parsers?
14:32:23 <nilof> What if I use template Haskell? If I declare instances for concrete types the code will always be the same, the only difference is that the Argument "Heap h" at the top would be replaced with "LeftistHeap h", "BinomialHeap h", etc
14:32:32 <Koterpillar> hereForMatrices: (Mat((x,y), r1))
14:32:38 <Koterpillar> hereForMatrices: what is the type of r1?
14:33:02 <merijn> nilof: I would start of first questioning why Heap is a typeclass, rather than a datatype
14:33:34 <nilof> Because it abstracts over different types of heaps, and can have many different implementations
14:34:26 <lpaste_> HereForMatrices revised “matrix ”: “matrix ” at http://lpaste.net/353503
14:34:57 <hereForMatrices> the error I'm unsure how to understand or interpret - which is why I don't know how to answer your question Kot - is the one related to line 12
14:35:04 <hereForMatrices> the where in the pointwiseApply function
14:35:21 <Koterpillar> hereForMatrices: this is precisely what I'm trying to explain
14:35:24 <merijn> hereForMatrices: 'r2 :: (Int, Int) -> a'
14:35:32 <merijn> hereForMatrices: But you're applying r1 to it
14:35:42 <merijn> And 'r1 :: (Int, Int) -> a' too
14:35:45 <Koterpillar> hereForMatrices: r1 and r2 are both functions from coordinates to values
14:35:47 <merijn> So that doesn't typecheck
14:36:00 <hereForMatrices> Ohhhhhhhh
14:36:00 <hereForMatrices> ohh
14:36:01 <hereForMatrices> oh
14:36:03 <Koterpillar> hereForMatrices: so you can't apply r1 to r2, nor op to any of them
14:37:16 <nilof> That and Okasaki implements a heap typeclass in the Haskell code appendix of his purely functional data structures book
14:38:18 <merijn> nilof: I'm not saying you can't, I'm just saying it's not a great idea, as that kinda use of typeclasses generally doesn't do what you want as well as you'd hope. As evidenced by the imposibility of writing a "default" monofoldable
14:38:53 <mbw> hereForMatrix: Are you using an editor setup that lets you see things like hlint and ghc-mod? I found these kind of tools quite helpful when starting out. Also being able to inspect the types, either in your editor, or ghci, is helpful when writing polymorphic code.
14:39:26 <hereForMatrices> no, I've just been on notepad++ 
14:39:30 <hereForMatrices> I'll look at hlint though
14:39:56 <maerwald> I find hlint highly useless, most of the suggestions are odd and opinionated
14:40:35 <maerwald> when it comes to pointfree vs pointful style, it assumes those things are the same, which they are not
14:41:01 <mbw> hlint is more for "best practices", like obvious simplifications. However, in my vim setup I find it very helpful to auto-expand pattern matches, insert types etc. But many of those "fancy things" are of course a matter of taste.
14:41:06 <nilof> But I can see myself wanting to do something similar for a lot of problems, like making a default applicative instance for all monads
14:41:45 <hereForMatrices> yeah, I generally find those things helpful
14:42:18 <hereForMatrices> I'm just on spring break, and figured I'd mess around, I found problems from an old lecturer at the college I go to, and I've been working through them 
14:42:33 <hereForMatrices> would changing the where to this, resolve the issue?
14:42:35 <hereForMatrices>    where f (Mat((x1, r1))  (Mat(x2, r2)) = (Mat ((x,y), (op ((r1 x1) (r2 x2)))))
14:42:53 <hereForMatrices> that way, x1, and x2 are the tuples, and r1 and r2 are the functions which get applied to that tuple 
14:43:11 <merijn> hereForMatrices:  I would assume x1 and x2 are sizes?
14:43:47 <Koterpillar> hereForMatrices: it won't anyway, you need a _function_ as the last element
14:44:25 <Koterpillar> hereForMatrices: [hint] maybe start writing it like Mat ((_, _), \(x, y) -> _)
14:45:36 <hereForMatrices> thank you for the help Koterpillar, I'm going to try that, and some other thigns
14:45:48 <hereForMatrices> things*
14:46:19 <freeside> good luck
14:46:29 <freeside> if you give up, http://lpaste.net/353507 has the answer
14:47:47 <Koterpillar> freeside: well, if you go there, why not just make Matrix an instance?
14:48:14 <freeside> i don't know! i didn't think about it. i did it on autopilot.
14:48:41 <freeside> it compiles. ship it!
14:58:02 <markani> is this the general help channel?
14:58:18 <freeside> no, that would be lmgtfy.com
14:58:30 <kadoban> markani: For haskell, yes
14:58:57 <Koterpillar> this is the general channel for the Haskell programming language
15:00:01 <freeside> you ask one question, you get three answers.
15:00:07 <freeside> satisfaction guaranteed or your money back!
15:00:17 <ongy> they left already
15:00:40 <freeside> and we don't even care if you stick around to hear them!
15:01:02 <hereForMatrices> Well, I didn't get it to compile, and after seeing the solution freeside, I hadn't seen the $ or * used outside of learn you a haskell, and I never messed with them
15:01:14 <freeside> yeah, the applicative thing is super mindblowing
15:01:29 <Squarism> So does haddock require all exposed modules to have documentation? 
15:01:31 <freeside> this might help: https://twitter.com/mengwong/status/841408199332880384
15:01:40 <Koterpillar> hereForMatrices: warning: <$> is not $, and <*> is not *
15:03:00 <lyxia> Squarism: it's not required, just strongly recommended
15:03:13 <jle`> haddock really doesn't require anything
15:03:31 <mbw> hereForMatrices: https://github.com/bitemyapp/learnhaskell also has a nice collection of materials, next to the Wiki and the other usual places.
15:03:33 <Squarism> ....As i need my testsuite to have access to big parts of the codebase i exposed most of it. And now haddock wants dock for stuff i dont even planned on exposing
15:03:42 <freeside> i'm guessing that what you want with the pointwiseAppply is to run both r1 and r2 on the new matrix (which just so happens to be the first matrix), and combine the result using whatever operator was specified by add/sub?
15:03:57 <jle`> Squarism: haddock will warn you about undocumented unexposed modules
15:04:15 <jle`> but i'm pretty sure it doesn't require them to be documented
15:04:33 <freeside> as you can see from my tweet, the X <$> Y <*> Z magic will run both Y and Z on the input, and then run X on the result, which seems like what you want
15:05:24 <kuribas> The reader monad is the most abused monad...
15:05:36 <kuribas> it's obfuscation device #1
15:06:17 <freeside> haskellbook.com's chapter on Reader does a very patient job working you through it
15:06:27 <jle`> indeed Reader has few actual real purposes outside of pedagogy
15:07:03 <Squarism> jle`, lyxia : This is my output running "stack build --haddock" : http://lpaste.net/353508
15:07:09 <Squarism> looks like it fails?!
15:07:11 <jle`> it's useful for teaching but there aren't really many situations where it is the most effective tool
15:07:13 <Squarism> ...because of missing
15:07:15 <Squarism> docs
15:07:37 <geekosaur> re earlier: the RULES wouldn''t be on Monoid /per se/ but on things like folds
15:08:00 <jle`> Squarism: i hvaen't seen that beore, but i suspect that it doesn't have to do with missing docs
15:08:15 <jle`> it's just a coincidence that the error happens right after the warnings for missing headers
15:08:38 <jle`> that's my guess, at least
15:08:43 <merijn> jle`: I kinda like Reader...
15:08:56 <jle`> who doesn't like reader, it's so cute
15:08:56 <merijn> jle`: Or did you mean as opposed to ReaderT?
15:09:02 <jle`> as opposed to ReaderT, yes
15:09:03 <lyxia> Squarism: parse error on input ‘-- | GameStarted’
15:09:13 <jle`> ReaderT is pretty useful :)
15:09:22 * geekosaur back from store, will likely be unstable for the next hour :/ wheeeeeee...
15:09:26 <sphinxo> Hi, is anyone here good at spotting the sources of happy shift/reduce conflicts?
15:09:49 <freeside> "but Reader is just a ReaderT wrapped around an Identity monad" (sung to the melody of "but a monad is just a monoid in the category of endofunctors")
15:10:03 <Squarism> lyxia, good catch!
15:10:05 <Squarism> thanks
15:10:13 <jle`> s/wrapped around an/applied to
15:10:32 <jle`> but yeah
15:10:58 <lyxia> sphinxo: have you tried looking at the output of happy -i
15:11:31 <sphinxo> yes, and I see which state it is
15:11:46 <geekosaur> actually I find happy's version of that much worse than AT&T yacc's
15:11:50 <freeside> nodnod
15:12:17 <sphinxo> http://lpaste.net/8643826338391654400 is the output, state 97 is the one I need to fix
15:13:18 <geekosaur> one of the reasons is that, before the state transition table is a state definition table that helps tie the source to the state table for inspection. last time I looked at happy diagnostic output it lacked that table, making it harder to map a state transition back to the source
15:13:29 <sphinxo> http://lpaste.net/1023912210432262144 is my .y ( the relevant parts )
15:13:45 <freeside> trifecta does a good job with that sort of thing
15:13:58 <sphinxo> it's somewhere in 
15:13:58 <geekosaur> (and they're cross-referenced with respect to shift/reduce and reduce/reduce conflicts, making it even easier) 
15:14:00 <sphinxo> func :: { Func }
15:14:27 <jle`> i was in a situation earlier when i really wanted linear types
15:14:31 <jle`> but we did not have them
15:14:35 <jle`> now i am sold on their utility
15:15:17 <jle`> it's funny how i didn't realize how much i needed them until i heard about them
15:15:32 <jle`> the thing about learning haskell is that it makes you greedy for more language features v.v
15:16:50 <sphinxo> can anyone spot what is wrong in my grammer? for state 97
15:19:26 <geekosaur> sphinxo, I *think* the real problem is that it can't tell when something is an empty list(param) followed by nonempty list(sexp)
15:19:41 <geekosaur> or something related to that
15:20:07 <geekosaur> basically there's too much "optional" going on, between name being optional and lists being possibly empty
15:20:30 <sphinxo> why might it fail on both nonempty?
15:20:40 <geekosaur> that's the case it wouyld handle
15:21:12 <geekosaur> the case it will mishandle is empty param list + sexp list that has cases that can be confused with param list
15:21:35 <Zemyla> edwardk: I figured out how to do liftReadsPrecRep.
15:21:36 <geekosaur> in actual lisp, the param list is mandatory (but can be nil/()) for this reason
15:21:55 <MarcelineVQ> jle`: what was your use case?
15:22:21 <infinity0> is there a typeclass that defines a "swappable" monad somewhere
15:22:29 <jle`> infinity0: what is a swappable monad
15:22:38 <merijn> infinity0: What do you mean by swappable?
15:22:43 <synthetica> Do you mean "Traversable"?
15:22:43 <Zemyla> liftReadsPrecRep :: (Traversable f, Distributive f) => (Int -> ReadS a) -> String -> Int -> ReadS (f a); liftReadsPrecRep ra nm = readsData $ readsUnaryWith (\p -> St.runStateT $ traverse getConst $ distribute $ Const $ St.StateT $ ra p) nm id
15:22:44 <infinity0> class Monad m => SwappableMonad m where swap :: Monad n => m (n a) -> n (m a)
15:23:01 <synthetica> infinity0: Thtat's basically Traversable.
15:23:08 <synthetica> *That's
15:23:08 <infinity0> ah, ok thanks
15:23:09 <jle`> that's Traversable, and it only requires a Functor constraint
15:23:19 <jle`> not everything has to be a monad :o
15:23:32 <jle`> ( useful types  ...                      ....  ( monads )  )
15:23:33 <synthetica> :o
15:23:36 <jle`> (my venn diagram)
15:23:37 <infinity0> i was just reading up on composing monads and this "swap" function came up so was wondering if there was already a typeclass for it
15:24:01 <jle`> oh, in that case, Traversable won't do
15:24:10 <jle`> Traversable's swapping (sequence) doesn't preserve Monad laws
15:24:20 <infinity0> ah ok
15:24:35 <jle`> the one that does is called Distributive
15:24:51 <jle`> but distributive functors are much more rare than traversable functors
15:25:27 <infinity0> i see
15:25:37 <infinity0> it says "dual of traversable", interesting
15:26:07 <synthetica> So, I have this datatype representing a sort of binary search tree, defined as follows: `data Sequ elem = Nil | OCons (Sequ (Pair elem)) | ICons elem (Sequ (Pair elem))`. I'm trying to implement Foldable for it, but is there a better way than just extracting the first element over and over? 
15:26:09 <jle`> yeah.  the difference here is that 'distribute''s laws are enough to prove that the composition of the two monads is itself a monad
15:26:20 <jle`> but traversable's laws are much weaker
15:26:23 <Zemyla> If a Functor f is Distributive, then it's saying that f is equivalent to (->) e.
15:26:40 <jle`> MarcelineVQ: in my case it was less resource management and more for guiding my program writing
15:27:25 <infinity0> oh man i need to pick up category theory again, last time i tried getting into it i stopped just before adjoints, still have no idea what those are
15:27:55 <infinity0> just about managed to realise preorder = directed graph, partial order = acyclic directed graph, sort of
15:28:20 <harwiltz> Hello all. I'm trying to make a simple poker game in Haskell. So far I've defined a bunch of data, for example I've defined Cards and Decks, and a Table which is just a [Deck]. Would it make sense to make a Monad called PokerGame which takes a Table and a Deck parameter (the deck being the overall game deck, not just someone's hand), to somewhat automate the process of removing cards from the deck and
15:28:22 <harwiltz> updating the players' hands?
15:28:25 <jle`> synthetica: you can derive Foldable
15:28:33 <synthetica> Wait, seriously? 
15:28:45 <jle`> yes, it's the "obvious" instance
15:28:52 <synthetica> (It's for a homework assignment, so I'm feeling like that would be... Cheating)
15:29:12 <jle`> it is likely that it would not be looked upon positively
15:29:17 <jle`> if that's the situation :)
15:29:24 <infinity0> harwiltz: sounds like the state monad would do what you need
15:29:55 <jle`> harwiltz: if you used State, the usefulness is that you can easily compose "card-removing" actions and sequence them one after the other
15:30:03 <jle`> and use it with mapM, sequence, etc.
15:30:07 <harwiltz> infinity0: Cool. Say I wanted to do this though, as an excercise to learn monads, would it be an appropriate approach?
15:30:18 <jle`> it would be good exerise to learn about State
15:30:24 <jle`> not sure about monads in general
15:30:47 <jle`> it wouldn't hurt though :)
15:30:56 <infinity0> first examples i find are useful to motivate the general concept later yeah
15:31:06 <infinity0> i can't understand abstract stuff without at least having 2-3 examples, then it's much much easier
15:31:10 <harwiltz> jle`: Ah, alright. Out of curiosity, since I'm having trouble understand the applications of monads, how often do you (or the average haskell programmer) create your own Monads?
15:31:27 <infinity0> harwiltz: for card games, a probability distribution is also a monad
15:31:48 <merijn> harwiltz: You don't "create" monads, you simply realise some of your datatypes already are :)
15:31:55 <infinity0> ProbDist a = [(num, a)] with the nums adding up to one, you can define >>= on it for practise if you like
15:32:00 <synthetica> jle`: But I'll look into the algoritm for deriving it, probably could write it down myself then
15:32:05 <harwiltz> infinity0: So I should be defining some sort of shuffling activity within a monad?
15:32:17 <merijn> harwiltz: The same way you don't set out to "create a Functor", you write a datatype, then later realise it IS a Functor and then you implement fmap :)
15:32:23 <harwiltz> infinity0: Oh, cool. Thanks. I'm gonna do that
15:32:23 <jle`> harwiltz: it's not quite "within a monad", it's with the State type
15:32:40 <jle`> harwiltz: the Monad typeclass just lets you uese State in monad-polymorphic functions like mapM and friends
15:32:53 <harwiltz> merijn: Yeah, you're right. But I don't know much about functor's either ;)
15:32:53 <infinity0> harwiltz: it's useful if you're modelling "all possible games" e.g. to figure out a strategy, but if you're just coding a game engine then it's probably not so useful
15:33:11 <Zemyla> infinity0: The nums don't need to add up to 1, even.
15:33:20 <infinity0> since you'd only use one result of the shuffle rather than modelling a distribution over all possible shuffles
15:33:25 <jle`> harwiltz: i recommend not thinking about State as a platonic ideal of monads, and that doing stuff with state is doing stuff with monads
15:33:32 <harwiltz> infinity0: Yeah, I guess I don't really need that then
15:33:33 <jle`> harwiltz: State is a useful *type* for composing stateful actions
15:34:01 <jle`> for example, if you had a function `Deck -> (Card, Deck)` that drew a card from a deck and returned a modified deck
15:34:05 <infinity0> i think if you're starting off monads, practising with state is a fine way to start and there's no need to confuse the newbie with abstract talk about "it's not general enough"
15:34:10 <harwiltz> jle`: Ah, I see. How often do haskell programmers define monads though?
15:34:16 <jle`> and you wanted to do it twice
15:34:37 <jle`> you can use the State type to help you turn a `Deck -> (Card, Deck)` into a Deck -> (Card, Deck)` tha does the same thing twice
15:34:43 <harwiltz> jle`: Thats exactly what I'm trying to do
15:34:55 <jle`> the fact that it's a monad doesn't let you do that
15:35:05 <harwiltz> jle`: Oh, ok
15:35:05 <jle`> it's the power of the specific State type
15:35:12 <jle`> like, Int lets you add together integers
15:35:15 <jle`> that's feature of the Int type
15:35:40 <infinity0> if you structure your code using the state monad, you will figure out which parts of your card logic is "monadic" and which is specific to your card game
15:35:42 <harwiltz> jle`: But isn't State's power possible because its a monad?
15:35:46 <jle`> no
15:35:51 <harwiltz> Oh. Haha
15:35:53 <infinity0> it'll be easier to understand if you do the code yourself, rather than having others try to explain it to you
15:35:57 <jle`> well, you might have the causality backwards
15:36:01 <harwiltz> infinity0: Yeah, that's true
15:36:16 <harwiltz> jle`: It's a monad because it's powerful?
15:36:17 <jle`> the fact that it's a monad doesn't have much to do with how useful it is
15:36:54 <jle`> it's a useful type that is useful on its own.  the fact that it's a monad is a coincidence
15:37:13 <harwiltz> jle`: Ok, but doesn't the monad part allow you to sequence actions?
15:37:33 <c_wraith> I mean.. Proxy is a monad, and Proxy is useful only for its phantom type. 
15:37:42 <infinity0> the point is things don't have features "because it's a monad", it's the other way round
15:37:44 <jle`> it's not quite "it's a monad, so poof, you can sequence actions."
15:37:45 <merijn> Lemme jump in and recommend Wadler's original Monad paper
15:37:53 <jle`> harwiltz: but, State is something that you can sequence
15:37:54 <infinity0> the fact that it has a particular feature, is why it is called "a monad"
15:38:24 <harwiltz> Oh God. I'm so confused now, I'll stop and try to learn state before I completely make a fool of myself here ;)
15:38:45 <infinity0> :)
15:38:58 <merijn> harwiltz: Wadler wrote a nice paper on a recurring patterns and showing what it is
15:39:02 <merijn> harwiltz: http://roman-dushkin.narod.ru/files/fp__philip_wadler_001.pdf
15:39:40 <harwiltz> merijn: Cool, thanks. I'm gonna read that
15:40:32 <freeside> also, video avilable https://yow.eventer.com/yow-2013-1080/the-first-monad-tutorial-by-phillip-wadler-1359
15:41:00 <harwiltz> freeside: Oh nice, thanks!
15:41:03 <jle`> harwiltz: being a monad doesn't allow you to sequence it;  it's a type that has a sequencing operation.  that operation is a part of the type and its API
15:42:09 <harwiltz> jle`: Ok, I'm starting to see that now. I think what's at the root of all my confusion is that I've heard so much about how great Monads are, I can understand the characteristic monad functions and the rules, but I just don't understand the practical part
15:42:39 <harwiltz> Anyway, thanks jle`, infinity0 , merijn, freeside. I gotta go eat dinner now, seeya around
15:42:49 <freeside> eat a burrito.
15:42:53 <jle`> i do recommend forgetting the hype :)
15:42:53 <merijn> harwiltz: Monad syndrome is generally overthinking this whole monad business :)
15:43:27 <jle`> day to day, when you use a type, you use it because of its specific usages.  not because it's a monad or a monoid or whatever
15:43:28 <infinity0> harwiltz: the practical aspect is a common pattern you can use to better understand stuff you didn't realise was actually related before
15:43:29 <merijn> harwiltz: When you look at it, there's honestly just not that much there. It's just that what's there is a very convenient reoccurring pattern
15:43:37 <infinity0> then you can use these common patterns to understand new stuff more easily
15:43:51 <jle`> like when i use Int, i don't use it because it has a Show instance, or because it has an Ord instance
15:43:53 <freeside> if you want to be a traditionalist, spend five years learning higher math, especially category theory, then write a tutorial of your own about how monads are trivially understood assuming you have five years of higher math 
15:43:55 <jle`> i just use it because i need integers.
15:44:04 <infinity0> the pattern itself is not "super" impressive in the sense that they already exist elsewhere and you've already done them, just not in a way that makes it obvious you've done the same pattern 10 times
15:44:35 <jle`> when i use State, i don't use it because i need a Monad.  i use it because i need to keep track and sequence stateful actions
15:45:34 <freeside> it's a bit like the realization, "oh my god, every person i have ever dated is deep down similar in some essential way that was not obvious to me but obvious to all my friends, but each of my friends explained it to me a different way"
15:45:46 <jle`> when i use lists, i don't use it because I need a Monad, or because i need a Monoid, or because i need an Ord or an Eq...i use it because lists are useful for keeping track of things in
15:47:24 <robertkennedy> When I write a function like `a -> (a,b)` I think I'm supposed to wrap it in a Monad. Which Monad?
15:47:40 <jle`> you...don't need to wrap it in anything...
15:47:54 <jle`> it's a perfectly fine function
15:48:21 <jle`> don't let anyone tell you you're supposed to wrap it in anything, heh
15:48:23 <mbw> robertkennedy: ^This, but also why should you be 'supposed' to do anything?
15:48:29 <freeside> enemy of the State
15:48:52 <Cale> robertkennedy: You *could* make that into State a b
15:49:12 <Cale> robertkennedy: But it's only of any value if you're chaining the a's together in a particular way
15:50:00 <jle`> sort of like, if you want to use Int with 'Writer', you can wrap it in a 'Sum' to give it a Monoid instance
15:50:07 <jle`> > foldMap Sum [1,2,3]
15:50:10 <lambdabot>  Sum {getSum = 6}
15:50:16 <jle`> but to just use Int's normally, you don't need to wrap it in Sum
15:50:28 <jle`> you only need to wrap it in Sum if you want to use it as a monoid and be able to mappend it
15:50:40 <robertkennedy> Sorry, yeah I am chaining them together - each function consumes some elements of a list
15:50:52 <freeside> http://krisnair.com/post/23954404803/think-like-a-mathematician
15:53:01 <jle`> robertkennedy: then yeah, wrapping an (s -> (a, s)) in 'State' gives you a pretty convenient way of sequencing them
15:53:23 <jle`> then you can do fun stuff like replicateM
15:54:04 <jle`> `recpliateM n (state f)` will "chain" your (s -> (a, s)) n times
15:55:36 <jle`> sequence [state f, state g, state h] will chain all of the (s -> (a, s))'s f, g, and h
16:00:40 <d34df00d> Hi!
16:01:22 <d34df00d> Is it possible to apply a polymorphic function in Uniplate's transformBi on every element that satisfies the function type requirements?
16:01:54 <d34df00d> Along the lines of this:
16:02:00 <d34df00d> http://bpaste.net/show/5f81a8acd13f
16:04:44 <d34df00d> This approach fails with
16:04:47 <d34df00d> http://bpaste.net/show/eca8eacd5495
16:06:16 <Squarism> can you instruct haddock to link to hackage for libraries that are published there?
16:11:53 <jdelreal> Got some colleagues wondering in Haskell how one would say/pronounce (what to call it): '>>>'
16:12:00 <jdelreal> ?
16:12:39 <jle`> it's commonly used as function composition
16:12:39 <johnw> compose
16:12:55 <jle`> 'composed with', maybe, but the order is a bit ambiguous
16:13:19 <jle`> f . g is called "f composed with g", but f . g is g >>> f, so
16:13:27 <freeside> you should stammer it out, like co-co-compose
16:13:44 <int-e> d34df00d: basically the answer is no. the fundamental difficulty is that there's no support for finding/constructing a type class instance given a TypeRep. From an abstract perspective, the fact that type classes are open plays a role here.
16:13:48 <jdelreal> One says: "andThen"
16:13:54 <jdelreal> ?
16:13:57 <jle`> but the reason why we have operators is because sometimes they're more meaningful than the corresponding words
16:14:06 <jle`> andThen is commonly used for >>
16:14:09 <jle`> s/meaningful/expressive
16:14:18 <jdelreal> :-)
16:14:24 <jle`> in some situations, at least.
16:14:59 <jle`> i've heard people say 'piped into'
16:14:59 <freeside> if > is "greater than", then >>> should be "greatest than". like, the greatest. absolutely the greatest operator. ask anybody. they'll tell you. just the greatest. we're gonna make operators great again.
16:15:06 <jle`> >>> is somewhat related to unix pipes
16:15:11 <Cale> Well, if it's reasonable to pronounce f . g as "f following g" then perhaps f >>> g might be pronounced "f preceding g" :)
16:15:22 <n1> instead of "composed with" one can say "after" or "following"
16:15:31 <n1> as Cale  so rightly points out one second before me :)
16:19:34 <d34df00d> int-e: what options do I have? I've heard using Data/Typeable for Uniplate is not the only option, would it help? Would something like geniplate (never used it) help? And, from the abstract perspective, let's say I enable DataKinds and define my class as `class Smth (a :: Indexer)`. Would that (abstractly) work?
16:20:21 <d34df00d> The reason I'm asking is that I'd like to enumerate the types supporting/subject to a given operation just once.
16:25:22 <jle`> types are erased at runtime, so you'd have to find a way to carry around a runtime witness
16:25:37 <jle`> like using Typeable
16:26:47 <d34df00d> Yeah, but my types are already Typeable (as is one of the ways of working with Uniplate).
16:28:09 <jle`> in terms of typeable, you could pattern match on specific types and gain the instances for those specific types
16:28:23 <jle`> but you can't really do it for "any instance of class X"
16:28:49 <jle`> but if you know that thre are only a fixed set of instances for your typeclass, you can enumerate over all of those types
16:30:11 <jle`> there's just no way of finding an instance "in general" at runtime
16:31:40 <jle`> if you enumerate over each possible type explicitly, though, then GHC will gladly give you the proper instance.
16:35:52 <ReinH> "backwards-composed"
16:36:49 <johnw> I like that GHC keeps coming up with ideas that make me excited for the next version; now I want to play with linear typing :)
16:45:03 <c_wraith> only a year away.. 
16:45:17 <c_wraith> Oh, hey.. what's the 8.2 release schedule look like? 
16:45:46 <hpc> wait ghc is getting linear typing?
16:46:39 <johnw> hpc: http://blog.tweag.io/posts/2017-03-13-linear-types.html
16:46:45 <hpc> feature request: rust FFI that understands its type system
16:46:52 <hpc> (which has elements of affine types)
16:48:18 <hpc> also i have to agree with johnw here
16:48:30 <hpc> i didn't think i could be excited for anything less than full dependent types in a new ghc
16:48:35 <hpc> but this is pretty cool
16:49:14 <c_wraith> I'm still excited about compact regions. 
16:55:03 <mhealy> hello, all
16:57:25 <michalrus> Can I somehow explicitly reference *this* module? Let’s say I define `error = 5` in it, but it clashes with `Prelude.error`. How can I reference `This.error`? But not having to write `MyApp.Some.FQ.Module.Name.error`.
16:59:17 <geekosaur> there is no shorthand for the current module name
16:59:23 <YongJoon> you can hide a method of `Prelude` or not importing `Prelude` implictly.
16:59:26 <Koterpillar> michalrus: import qualified MyApp.Some.FQ.Module.Name as F?
16:59:42 <geekosaur> but you can import Prelude hiding (error)
16:59:55 <michalrus> Aw, very nice solutions! Thank you, all. :)
17:00:32 <michalrus> Also, this question might be silly, but should we generally *not* be using the built-in Prelude?
17:00:45 <YongJoon> You can write `{-# LANGUAGE NoImplicitPrelude #-}`
17:00:53 <michalrus> Yes, yes, that’s what I’m asking about!
17:00:54 <jle`> i usually use the built in prelude
17:00:55 <michalrus> Is it common?
17:01:03 <michalrus> Mhmmm.
17:01:07 <jle`> some people (or projects/teams) use custom preludes
17:01:20 <jle`> there's a bunch of custom prelude libraries on hackage, but i've never found it super necessary
17:01:23 <YongJoon> Some libraries also use this like Yesod or etc.
17:01:39 <YongJoon> I've seen this but never used yet
17:01:46 <michalrus> Okay, thank you. =)
17:03:10 <michalrus> And… as it got a bit more devopsey… can I somehow make the build fail if some function/symbol is used? Like, for instance, ban System.IO.Unsafe.*?
17:03:35 <YongJoon> you can use `undefined`
17:03:44 <michalrus> I could always use grep, but fully-qualified names seem better.
17:04:12 <YongJoon> I'm sorry this is not for failing for build.
17:04:36 <michalrus> Hmmm. YongJoon, could you elaborate some more? :P I don’t get that.
17:04:40 <michalrus> Ah!
17:04:47 <jle`> there's -XSafe and -fwarn-unsafe
17:04:56 <jle`> but that just warns you about a general class of unsafe packages
17:05:03 <jle`> and it might include some usfeul packages
17:05:06 <michalrus> Mhmmm.
17:05:18 <michalrus> What if I wanted to ban X.Y.Z.t explicitly? :)
17:05:42 <geekosaur> WARNING pragma + -Werror? but that won't ban qualified vs. unqualified
17:06:06 <geekosaur> th eonly way to do that is to nto import it. some people use a separate Internals module for such things
17:06:37 <michalrus> Mhmmm, okay! Thank you. :)
17:07:06 <YongJoon> Not good approach, but how about to use CPP?
17:07:22 <JamEngulfer> I'm trying to generate a list of the coordinate pairs in a grid up to n by n. The functino
17:07:26 <JamEngulfer> *whoops
17:07:33 <michalrus> Hm, maybe a compiler plugin would be able to do this? I definitely don’t know anything about GHC innards, but it seems like a plugin might have access to fully-qualified names of symbols in AST.
17:07:54 <michalrus> CPP is C pre-processor?
17:08:09 <jle`> ghc-mod will probably give you qualified names
17:08:13 <mzabani> hey everyone! I'm having some issues with an (MVar a) that is passed around: it seems like different code sees different values.. (I'm using this to escape from a monad transformer).. what could this be?
17:08:16 <YongJoon> Yes, you can use it by `{-# LANGUAGE CPP-#}`.
17:08:17 <michalrus> Oh, nice!
17:08:40 <michalrus> (In Scala, there’s Wartremover compiler plugin that does exactly that, among other things.)
17:08:41 <Rotaerk> I always confuse CPP with C++, since C++ file extension is cpp
17:08:59 <Welkin> not CCCP?
17:09:12 <michalrus> OK. *takes notes* I’ll investigate this further on my own! Thank you all once more!
17:09:17 <jle`> mzabani: can you show a reproducable example?
17:09:33 * Welkin pulls a rabbit out of jle`'s hat
17:09:35 <JamEngulfer> I'm trying to generate a list of the coordinate pairs in a grid up to n by n. The function signature is "grid :: Int -> [(Int, Int)]" and I currently have "grid n = [(n,n) | n <- [1..n]]", but that's not working properly. I can't seem to get a second axis generator in there without getting a variable out of scope error
17:09:43 <MarcelineVQ> michalrus: if you know what things you want to fail to compile on why not just hide those things. import Some.Module hiding (neonDemons)
17:09:43 * Welkin watches the rabbit reproduce
17:09:54 <mzabani> jle`: there's quite a bit of code, let me try to take the parts that matter into a snippet
17:10:11 <Welkin> it asexually creates clones
17:10:35 <michalrus> MarcelineVQ: I wouldn’t bother if I was working on my own, but with many people, it seems better when the machine is doing as much CR as possible. =P
17:11:54 <YongJoon> You used duplicated n. How about `grid n = [(m,m)|m <- [1..n]]?
17:12:12 <lpaste_> mzabani pasted “Escaping from my monad” at http://lpaste.net/353510
17:12:45 <mzabani> jle`: there it is.. I'm not sure it's enough, so just let me know if you need more!
17:12:48 <Welkin> sounds like an emo punk album
17:13:08 <jle`> is f a function?
17:13:24 <YongJoon> I'm sorry. it should be `grid n = [(m,l)|m<-[1..n],l<-[1..n]]`.
17:13:29 <jle`> if f returns IO, then you can just use liftIO
17:13:51 <jle`> if TunnelT is MonadIO, then liftIO :: IO a -> TunnelT m a
17:13:51 <JamEngulfer> YongJoon: What the hell? I did exactly that earlier and it just told me my variables were out of scope. Now your version works fine
17:14:52 <JamEngulfer> Well, either way, thanks for the help!
17:15:37 <YongJoon> ^_^!
17:17:27 <mzabani> jle`: don't I need to do the inverse? Have something that gives me TunnelT m a -> IO a?
17:17:34 <Koterpillar> mzabani: how would that help?
17:17:53 <Koterpillar> mzabani: you have IO, you need TunnelT
17:21:31 <mzabani> I need to implement http-client's Connection's send and receive functions, which run in IO. However, my implementation uses functions that run only in TunnelT (and TunnelT requires a PendingConnection to be created). Sorry, but I still don't understand what you're suggesting..
17:22:18 <nbro> edwardk: you were right, I had a bug in the moveLeft and moveRight functions…
17:23:44 <nbro> one question guys
17:24:51 <nbro> if I declare a data type using the record syntax as follows “data MyData = MyData {myfield :: String, mySecondField :: String }”, when I create a value of this data type, do I always need to specify the name of the fields when inializing them?
17:25:01 <nbro> @let data MyData = MyData {myfield :: String, mySecondField :: String }
17:25:03 <lambdabot>  Defined.
17:25:27 <nbro> MyData {“”, “”}
17:25:49 <Koterpillar> > MyData "" ""
17:25:52 <lambdabot>  error:
17:25:52 <lambdabot>      • No instance for (Show MyData)
17:25:52 <lambdabot>          arising from a use of ‘show_M674606865184440269819466’
17:25:58 <Koterpillar> well, you get the idea
17:26:53 <nbro> @undefine
17:26:53 <lambdabot> Undefined.
17:27:04 <nbro> @let data MyData = MyData {myfield :: String, mySecondField :: String } deriving (Show)
17:27:07 <lambdabot>  Defined.
17:27:18 <nbro> MyData { “”, “”}
17:27:26 <nbro> > MyData { “”, “”}
17:27:29 <lambdabot>  <hint>:1:10: error: lexical error at character '\8220'
17:27:32 <Welkin> smart quotes :)
17:28:05 <Koterpillar> > MyData "" ""
17:28:06 <Welkin> you forgot the double prime marks
17:28:08 <lambdabot>  MyData {myfield = "", mySecondField = ""}
17:28:22 <Welkin> > MyData "“”" "“”"
17:28:25 <lambdabot>  MyData {myfield = "\8220\8221", mySecondField = "\8220\8221"}
17:30:10 <nbro> Welkin: what do you mean that I forgot “double prime marks”?
17:30:35 <Welkin> nbro: it looks like your irc client is converting your ascii quotes into unicode quotes
17:30:49 <Welkin> the ascii quotes are actualy "double prime" marks
17:31:01 <nbro> ""
17:31:03 <nbro> ok
17:31:05 <nbro> I changed it
17:31:06 <nbro> lol
17:31:13 <nbro> the encoding
17:31:25 <nbro> > MyData {??, ??}
17:31:27 <nbro> lol
17:31:28 <Welkin> you should be able to use unicode
17:31:28 <lambdabot>  <hint>:1:9: error: parse error on input ‘??’
17:31:41 <Welkin> there should be a setting to convert quotes to smart quotes
17:31:44 <Welkin> turn that off
17:31:51 <Welkin> keep unicode encoding on
17:31:53 <nbro> Welkin: I was using unicode before, now I changed it to Western ASCII
17:31:59 <Koterpillar> > MyData { "a", "b" }
17:32:02 <Welkin> that's a bad solution
17:32:02 <lambdabot>  <hint>:1:10: error: parse error on input ‘"’
17:32:09 <Koterpillar> no, that's not the correct syntax
17:32:20 <Koterpillar> either use field names, or MyData "a" "b"
17:33:08 <nbro> can I not use record syntax to create a value of a data type that was declared with record syntax?
17:33:17 <nbro> ?hello?
17:33:18 <lambdabot> Unknown command, try @list
17:33:19 <nbro> nope
17:33:25 <Koterpillar> you can
17:33:32 <nbro> “hell"
17:33:41 <Koterpillar> > MyData { myfield = "a", mySecondField = "b" }
17:33:44 <lambdabot>  MyData {myfield = "a", mySecondField = "b"}
17:33:56 <Koterpillar> > [MyData { myfield = "a", mySecondField = "b" }, MyData "c" "d"]
17:33:59 <lambdabot>  [MyData {myfield = "a", mySecondField = "b"},MyData {myfield = "c", mySecond...
17:34:17 <mzabani> Koterpillar: don't I need something like unlift?
17:34:38 <Koterpillar> mzabani: no, you need lift
17:34:40 <nbro> because someone said before that I couldn’t, so I was searching for shorter way to create values…
17:35:19 <nbro> btw, is it correct to say that this is a value MyData {myfield = "a", mySecondField = “b”}?
17:35:40 <mzabani> Koterpillar: wouldn't I need TunnelT m a to be MonadIO m for that?
17:36:13 <mzabani> oh, just lift, not liftIO
17:36:14 <Welkin> nbro: MyData is a data constructor (a function)
17:36:23 <nbro> I know
17:36:34 <Welkin> once it is fully applied (you give it all of the parameters that it can accept) then it becomes a value
17:36:51 <nbro> but I’m wondering what’s the correct terminology for this concrete  “thing” MyData {myfield = "a", mySecondField = "b"}?
17:37:05 <Koterpillar> mzabani: yes, liftIO, I meant lift as a generic term. But I thought it already is a MonadIO?
17:37:13 <nbro> Welkin: ok
17:37:41 <nbro> whereas, e.g., when you do something like “Just Int”, this is a concrete type, right?
17:37:56 <Welkin> yes
17:38:01 <nbro> ok
17:38:06 <Welkin> if you mean by "concrete type" it has kind *
17:38:16 <Welkin> :k Just
17:38:19 <lambdabot> a -> Maybe a
17:38:24 <freeside> uh, you mean "Maybe Int", or "Just 5", but not "Just Int"
17:38:37 <Welkin> er yes
17:38:41 <Welkin> :k Maybe
17:38:42 <freeside> the first is a concrete type, the second is a ...
17:38:43 <lambdabot> * -> *
17:38:45 <Welkin> :k Maybe Int
17:38:47 <lambdabot> *
17:38:57 <Welkin> Just is a data constructor
17:39:30 <nbro> :t "asdasdasdasdas"
17:39:33 <lambdabot> [Char]
17:39:34 <mzabani> Koterpillar: sorry, let me correct myself: I did write instance MonadIO m => MonadIO (TunnelT m)
17:39:39 <nbro> no more stupid quotes
17:39:41 <nbro> lol
17:39:49 <nbro> *annoying
17:39:53 <nbro> :D
17:40:00 <Welkin> nbro: what client are you using?
17:40:21 <Koterpillar> mzabani: then you have liftIO :: MonadIO m => IO m -> TunnelT m 
17:40:22 <nbro> Colloquy
17:40:24 <nbro> you?
17:40:26 <Welkin> ew...
17:40:33 <Welkin> I tried that for a minute
17:40:48 <Welkin> I use terminal-based irc clients like irssi, erc (and tried weechat, which is okay)
17:41:18 <nbro> Welkin: I know Just is a data constructor
17:41:40 <nbro> but I?m wondering what?s the correct terminology for Just Int
17:41:52 <nbro> '
17:41:55 <nbro> I’m 
17:41:57 <nbro> ok
17:41:58 <nbro> lol
17:42:24 <Welkin> nbro: a value
17:42:26 <nbro> Welkin: I will one of those maybe tomorrow ;)
17:42:27 <Welkin> er
17:42:31 <Welkin> Just Int is not anything
17:42:35 <Welkin> it doesn't make sense
17:42:39 <Welkin> `Just 5` makes sense
17:42:40 <nbro> wait
17:42:54 <Welkin> Int is a type
17:42:56 <freeside> it's an expression. after it gets evaluated, it becomes a value.
17:43:03 <Welkin> Just requires a value, not a type
17:43:10 <Welkin> types and values exist in different spaces
17:43:17 <nbro> suppose you define a function with the following signature: my_f :: Maybe Int -> Int
17:43:36 <lpaste_> mzabani revised “Escaping from my monad”: “Escaping from my monad” at http://lpaste.net/353510
17:43:39 <nbro> :t my_f :: Maybe Int -> Int
17:43:42 <lambdabot> error:
17:43:42 <lambdabot>     Variable not in scope: my_f :: Maybe Int -> Int
17:43:47 <Welkin> :t Just :: Int -> Maybe Int
17:43:49 <lambdabot> Int -> Maybe Int
17:43:55 <Koterpillar> :t undefined :: Maybe Int -> Int
17:43:57 <lambdabot> Maybe Int -> Int
17:44:03 <Welkin> lol
17:44:19 <nbro> ok...
17:44:29 <nbro> in my example
17:44:38 <Zemyla> Actually, Just Int does make sense in certain contexts.
17:44:39 <Zemyla> :t Proxy :: Proxy (Just Int)
17:44:42 <lambdabot> Proxy ('Just Int)
17:44:51 <nbro> you can pass to my_f either a Just SOME_NUMBER or nothing
17:45:01 <mzabani> Koterpillar: I may not be explaining myself well enough (I'm a noob :P), would you mind looking at my corrected code to see what I want to achieve?
17:45:15 <Koterpillar> mzabani: so you want to _return_ a function like that?
17:45:17 <nbro> isn’t there a way to refer to this particular Just Int, since the compiler already knows it’s going to be a Just Int
17:45:35 <Koterpillar> nbro: case statement?
17:46:29 <Koterpillar> mzabani: I don't understand the purpose anymore, though.
17:46:56 <mzabani> Koterpillar: yes... precisely!
17:47:41 <nbro> let x = [1..]
17:47:47 <nbro> nope
17:47:57 <mzabani> I need to teach http-client to send its data through a custom built websockets tunnel that I created.. my tunnel's api consists of a runTunnelT function, so everything needs to run inside TunnelT..
17:48:07 <nbro> > let x = [1..]
17:48:09 <lambdabot>  <no location info>: error: not an expression: ‘let x = [1..]’
17:48:19 * nbro @let x = [1..]
17:48:20 <Welkin> mzabani: lol, teach it? Like teaching a dog to do tricks?
17:48:39 <mzabani> Welkin: lol sorry for the words I chose...
17:48:46 <nbro> thanks again! :D
17:48:58 <mzabani> give it functions that do sending and receiving of data, basically
17:49:37 <Koterpillar> I don't think TunnelT will help you with that
17:49:46 <mzabani> the things is: everytime http-client calls the function I gave it it needs to update the TunnelT's internal structures, without running inside it
17:50:46 <mzabani> Koterpillar: hmm what can I do?
17:53:12 <Lazersmoke> mzabani: Does `managerModifyRequest :: Request -> IO Request` do what you want?
17:53:33 <Lazersmoke> (used with `managerModifyResponse :: Response BodyReader -> IO (Response BodyReader)`)
17:54:42 <that_dude> :D
17:56:13 <mzabani> Lazersmoke: I guess it could, though I still have to implement ManagerSettings' functions (which is where the trouble lies)
18:09:15 <freeside> :load ch29a
18:09:22 <freeside> ahem, sorry, wrong buffer
18:09:57 <freeside> for a moment there you all looked like ghci
18:11:30 <lyxia> target 'ch29a' is not a module name or a source file
18:11:56 <freeside> haha
18:12:10 <mbw> What is the conventional way of testing compiled "runner" executables with space leaks, without danger of the machine thrashing? Restricting heap usage via +RTS?
18:12:32 <Koterpillar> rlimit?
18:12:54 <monochrom> I recommend +RTS
18:13:21 <pacak> +RTS. Also it helps to avoid introducing space leaks.
18:13:36 <mbw> So +RTS -HSomething?
18:13:58 <pacak> -M something
18:14:27 <monochrom> +RTS -H100M for 100MB.
18:14:27 <mbw> ah right, -H is minimum heap size :/
18:15:26 <monochrom> Don't forget "-rtsopts" at link time (at the latest).
18:15:37 <Tuplanolla> I think M is actually MiB.
18:15:49 <mbw> monochrom: According to the ghc manual, -H does not put a limit on heap size.
18:15:49 <pacak> Tuplanolla: Close enuf.
18:17:04 <mbw> It seems -M<Bytes> is it.
18:17:08 <mbw> Ok I'll try that, thankx.
18:17:19 <mbw> *thanks
18:17:26 <monochrom> Oh! Ooops, typo, I meant -M100M
18:18:36 <mbw> Alright, time to learn me sum Core.
18:18:58 <pacak> learning sum stg can be nice as well.
18:19:19 <MarcelineVQ> Tuplanolla: yes
18:20:06 <mbw> Sturzkampfgeschwader?
18:20:46 <mbw> or what is stg
18:21:17 <geekosaur> @google spineless tagless g machine
18:21:18 <lambdabot> https://www.dcc.fc.up.pt/~pbv/aulas/linguagens/peytonjones92implementing.pdf
18:21:28 <pacak> -ddump-stg
18:21:54 <geekosaur> the graph reduction engine used by ghc, and the "language" that compiles into graphs for it
18:24:26 <mbw> Skimming over the paper, it does read like Core a little
18:24:43 <mbw> or rather very much
18:24:53 <freeside> it's turtles, all the way down!
18:25:19 <MarcelineVQ> part of the way it's elephants
18:25:30 <geekosaur> yes, Core is supposed to be fairly close to STG
18:25:47 <mbw> It never ceases to amaze on how many abstraction levels you can work with Haskell
18:26:59 <mbw> On that thought, is there some way to use inline-assembly as well?
18:27:22 <pacak> foreign import primop
18:27:40 <geekosaur> not so far as I know but someone could probably do something similar to inline-c
18:28:06 <pacak> I'm using it to process data with AVX instructions
18:28:46 <geekosaur> have you been following https://mail.haskell.org/pipermail/ghc-devs/2017-March/013899.html ?
18:29:17 <geekosaur> still in the planning phase (and soliciting contributors/help)
18:29:42 <pacak> I'm trying to read all the mails where Edward gets involved.
18:29:48 <mbw> How do you manage alignment?
18:30:12 <geekosaur> you mean layout? use an editor with half a brain :)
18:30:51 <geekosaur> nvi can do it with some pain. I personally run emacs (but see /nick :) others use atom or sublime edit with haskell support
18:30:53 <pacak> mbw: I don't. There is some slight overhead, but even with that AVX code is better than anything I was able to write in haskell
18:31:08 <geekosaur> oh, wrong algnment :p
18:31:13 <mbw> haha
18:31:46 <monochrom> How does /nick tell me about your editor?
18:32:15 <fnordmeister> You can usually just tell.
18:33:09 <geekosaur> it tells you I'm of an age to think emacs is a reasonable editor :p
18:33:31 <pacak> emacs is a reasonable OS that lacks a decent text editor...
18:33:47 <MarcelineVQ> does it? your nick might show more to you than to others :>
18:33:55 <monochrom> No, emacs lack of concurrency makes it an unreasonable OS, at the level of DOS.
18:33:59 <freeside> on the unreasonable editorness of emacs
18:34:12 <mbw> Why would layout be a pain? I usually spend more time thinking than writing, so even having to align (now the other one) expressions by hand wouldn't be much of a burden...
18:34:48 <freeside> safe spaces. they're all the rage.
18:34:57 <mbw> Still, Emacs Lisp is probably way nicer than Vimscript...
18:35:33 <mbw> And Python2 vs. Python3
18:39:51 <okeuday_bak> indenting haskell code with 4 spaces is normal, right?
18:40:03 <geekosaur> I don't think there's really a normal
18:40:14 <okeuday_bak> k :-)
18:40:15 <freeside> if you're lawful good, 4 is fine
18:40:17 <mbw> According to Linus, 4 Spaces is a meme
18:40:22 <freeside> it all really depends on your alignment
18:40:31 <pacak> Look at base or ghc source code
18:40:40 <okeuday_bak> yeah, good point
18:40:49 <kadoban> I tend to use 2 or 3
18:41:13 <Koterpillar> hindent thinks it's 2 and I'm not arguing
18:41:17 <pacak> 3????? O_O
18:41:47 <mbw> I thought 2 was a fixed-size fortran thing
18:42:18 <kadoban> 2 gets a little hard to see the difference of sometimes, 4 seems like too much. So 3 *shrug*
18:42:24 <kadoban> I probably use 2 more though
18:42:39 <Tuplanolla> Two is nice, because it forms a square with 1:2 aspect ratio fonts.
18:50:48 <fresheyeball> is there better syntax for this?
18:50:53 <fresheyeball> class Schema t => DefaultPredicate (t :: SchemaType) where
18:50:54 <fresheyeball>     type DefaultPredicateType t :: PredicateType
18:54:02 <Rotaerk> what's SchemaType from?
18:54:27 <Rotaerk> not familiar with that kind
19:11:07 <okeuday_bak> if you have constructors (from data) in some module that are exported, how do you export them in a different module you have imported them into?
19:11:38 <okeuday_bak> do you have to make values with the same name, to allow you to export them, like making extra functions?
19:16:02 <okeuday_bak> nm, think I found how to do it
19:16:24 <geekosaur> you can just export them, qualified if that's how you imported them, Type(..)
19:16:46 <geekosaur> they will be named by other imports as if fdefined in your module (i.e. it can't tell you reexported them from elsewhere)
19:19:53 <DataComputist> Is stack broken in macOS 10.12.3?
19:20:05 <DataComputist> $ stack setup
19:20:05 <DataComputist> dyld: malformed mach-o: load commands size (34520) > 32768
19:20:05 <DataComputist> [1]    95440 abort      stack setup
19:22:01 <geekosaur> I don't know if stack has been updated with the fix to that (also requires newer ghc and newer Cabal library)
19:23:08 <geekosaur> (stack is especially likely to run into it but it's a general Sierra issue)
19:23:49 <tmciver> Hey all. I'm trying to run the tests for cryptonite (https://github.com/haskell-crypto/cryptonite) which does not use stack, but after running `cabal install` followed by `cabal test`, it complains that all of the tasty related dependencies are missing. Also, doing `cabal install --dependencies-only` didn't have any effect. Any ideas?
19:24:15 <geekosaur> cabal install --enable-tests
19:24:30 <geekosaur> (iirc)
19:24:49 <tmciver> geekosaur: Let me try.
19:24:51 <geekosaur> ...yes
19:25:12 <geekosaur> if you omit that it ignores the tests and their dependencies
19:25:30 <tmciver> Doing something . . . :)
19:27:41 <davean> tmciver: Also, you don't have to install it to test it
19:28:10 <tmciver> I had earlier tried `cabal configure --enable-tests` which I had seen here: https://www.haskell.org/cabal/users-guide/developing-packages.html#test-suites but that also did not seem to work.
19:28:54 <tmciver> davean: right, because `cabal install` does not install deps, it install the app locally, correct?
19:31:10 <tmciver> geekosaur: Worked. Thanks!
19:32:52 <davean> tmciver: install installs it to your system
19:32:57 <davean> tmciver: you probably want "build"
19:33:56 <davean> tmciver: I mean, install also installs any dependencies to the system
19:34:15 <davean> cabal install is similar to make install
19:34:21 <davean> which *also* builds it
19:34:25 <davean> but theres no reason to install it to test it
19:35:19 <tmciver> davean: Got it. Thanks. I think the minimun that I needed to run tests in this case was `cabal install --enable-tests`, `cabal test`.
19:37:54 <geekosaur> sometyimes install is needed for testing to work, if getDataFileName etc. is in play, because support for that in an un-installed program is an  utter hack
19:40:12 <davean> geekosaur: sometimes, but rarely
20:05:14 <sssilver> hey guys, how much useful information would one derive out of a core dump of a Haskell program?
20:07:03 <sanett> hey folks, what are some good books and online tutes for learning haskell?
20:07:26 <sssilver> sanett http://learnyouahaskell.com is what I started with and since then I loved it so much that I purchased it at least 10 time
20:07:28 <sssilver> *times
20:07:45 <sssilver> some people say it's crap, but I think it's marvelous
20:07:54 <sssilver> those people are also often not fun at parties
20:08:08 <sssilver> (shots fired)
20:08:12 <sanett> lol
20:08:21 <Welkin> it's a fun book to read, like a comic book
20:08:28 <sanett> thanks that's exactly what i was expecting
20:08:40 <Welkin> but it's not a great learning resource beyond the superficial aspects of the language
20:08:42 <geekosaur> sssilver, not very much currently (this changed slightly in 8.0.x and should change a bit more in 8.2.x, but Haskell programs are very different from C/C++ and debuggers typically don't handle them well)
20:08:58 <the|auriscope> I've read LYAH and I'm currently going through Haskell Programming (from first principles)
20:09:13 <the|auriscope> LYAH was fun but I feel like I'm learning a lot more from the latter
20:09:25 <geekosaur> basically you are trying to debug an STG graph, not linear code. in theory someone could come up with some gdb helpers to dump STG nodes, but afaik nobody has
20:09:26 <sssilver> sanett let me put it this way, that book was sufficient for me (as a seasoned programmer) to go from zero to a system in production that works to this day
20:09:28 <Welkin> in haskell, you are always learning something new
20:09:30 <sanett> LYAH is an introductory book
20:09:39 <Welkin> and your perspective/opinions will change with time
20:09:57 <geekosaur> LYAH is good for self-starters, otherwise it's a 2-hour movie trailer
20:10:07 <MarcelineVQ> geekosaur, sssilver: are you guys talking about the same core
20:10:32 <sssilver> I'm talking about the contents of process memory at the time of a crash
20:10:46 <MarcelineVQ> sounds like you are then :>
20:11:20 <davean> sssilver: what do you have in production?
20:12:47 <sssilver> davean a small web service that takes input from SQS, transforms it, and generates JSON
20:13:05 <sssilver> davean and does so very correctly, if that makes sense :D :D
20:14:22 <sssilver> > [22:12:56] okuu:	jaziz: Because higher-order functions are so useless.
20:14:25 <lambdabot>  <hint>:1:78: error:
20:14:25 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
20:14:36 <sssilver> lambdabot don't bother lol
21:01:57 <jle`> it'd be nice if there was an EndoM
21:02:19 <jle`> data EndoM m a = EndoM { appEndoM :: a -> m a }
21:02:24 <jle`> with appropriate monoid instances
21:08:57 <johnw> jle`: type EndoM m a = Endo (Kleisli m a a)?
21:11:06 <jle`> yes, but the monoid instance
21:12:21 <buttons840> https://hackage.haskell.org/package/Spock-0.12.0.0/docs/Web-Spock.html#v:spock -- the type signature of the spock function looks weird to me, it looks like the SpockM portion of it takes 4 type arguments, but the very next line on that page shows SpockM as taking only 3 type arguments?
21:12:50 <jle`> it's partial application
21:13:09 <jle`> @let type MyMaybe = Maybe
21:13:12 <lambdabot>  Defined.
21:13:22 <jle`> :t undefined :: MyMaybe Int -> Bool
21:13:26 <lambdabot> MyMaybe Int -> Bool
21:13:46 <jle`> maybe a bad example
21:13:55 <jle`> @let type EitherString = Either String
21:13:58 <lambdabot>  Defined.
21:14:08 <jle`> :t undefined :: EitherString Int -> Bool
21:14:10 <lambdabot> EitherString Int -> Bool
21:14:25 <johnw> jle`: n/m, what I wrote makes no sense anyway
21:14:41 <buttons840> it's a partial application of what? how is it a partial application if there is an extra type argument?
21:14:56 <buttons840> i could see missing an argument being a partial application, but not an extra
21:15:00 <Koterpillar> :k Either
21:15:02 <lambdabot> * -> * -> *
21:15:30 <jle`> buttons840: do you understand --
21:15:34 <geekosaur> buttons840, most monad-context things like that take one more parameter which is the current result type
21:15:38 <geekosaur> for example IO a
21:15:47 <jle`> @let foo x = (+) x
21:15:48 <lambdabot>  Defined.
21:15:51 <jle`> > foo 10 3
21:15:55 <lambdabot>  13
21:15:59 <geekosaur> here we have SpockM with 3 parameters, but actually 4:  so we say something like SpockM ()
21:16:02 <jle`> i defined foo to take only 1 argument explicitly
21:16:06 <jle`> but i called it with two arguments
21:16:10 <geekosaur> to get the complete type
21:16:27 <jle`> it's a partial application of the SpockCtxM type
21:16:28 <geekosaur> partial type application is permitted as long as it is *always* resolved after expansion, as it is here
21:16:55 <buttons840> the source code says "type SpockM conn sess st = SpockCtxM () conn sess st" and "type SpockCtxM ctx conn sess st = SpockCtxT ctx (WebStateM conn sess st)" -- i don't see where theres room for partial application
21:17:27 <jle`> buttons840: SpockCtxT takes three arguments
21:17:35 <jle`> it's being partially applied to ctx and (WebStateM conn sess st)
21:17:41 <geekosaur> you have to look for SpockCtxT which is 3 argments
21:17:49 <geekosaur> of which 2 are provided, just as with SpockM
21:18:05 <geekosaur> because you would include an additional argument for the result type of a monadic computation
21:18:13 <buttons840> ok, T != M   :)
21:18:16 <jle`> SpockCtxT is being partially applied
21:18:29 <buttons840> err, T /= M
21:18:33 <geekosaur> data SpockCtxT ctx m a
21:18:54 <geekosaur> but this provides only ctx and m, and same for the other aliases. "a" must be supplied at use time of each of these types
21:19:04 <geekosaur> so SpockM String, or SpockM (), or ,..
21:19:53 <jle`> it might help to look at the kinds too; SpockCtxT :: * -> (* -> *) -> * -> *
21:20:13 <jle`> so SpockCtxT ctx (WebStateM conn sess st) :: * -> *
21:21:00 <buttons840> ok, so SpockCtxM is a partially applied SpockCtxT, and SpockM is reorder of arguments for SpockCtxM ?
21:21:16 <geekosaur> more or less, yes
21:21:24 <geekosaur> or adding an additional component you usually don't care about
21:21:37 <geekosaur> (Parsec does the same thing since almost nobody uses the user state it can carry)
21:23:26 <geekosaur> in fact I think it also uses the same partial application trick, not mentioning the "a" at the end for the result
21:24:11 <geekosaur> so in the end you talk about e.g. Parser String, but the tyvar for the String is not mentioned in any of the type aliases
21:24:33 <geekosaur> er, type variable ("tyvar" is ghc internal shorthand)
21:28:24 <Welkin> anyone use purescript here?
21:28:41 <Welkin> do you use pulp or webpack as the build tool?
21:29:40 <jle`> i use pulp
21:30:48 <Koterpillar> Welkin: webpack
21:30:56 <buttons840> jle`: you aske me, "do you understand --". Were you asking about my grammar when I use dashes?
21:31:34 <jle`> oh no, i was talking about the next line
21:31:41 <buttons840> or just a typo? no worries either way
21:31:46 <buttons840> ok :)
21:31:48 <jle`> maybe i tshould have been "-->" or "--v", heh
21:43:50 <Xnuk> @hoogle ByteString -> String
21:43:54 <lambdabot> Data.ByteString.Char8 pack :: String -> ByteString
21:43:54 <lambdabot> Data.ByteString.Lazy.UTF8 fromString :: String -> ByteString
21:43:54 <lambdabot> Data.ByteString.UTF8 fromString :: String -> ByteString
21:44:42 <jle`> Xnuk: you should decode as Text
21:44:48 <jle`> using the Data.Text.Encoding module
21:44:55 <jle`> and then use unpack from Data.Text
21:45:35 <Xnuk> I know but I'm so lazy
21:46:14 <Axman6> there should be an unpack function in Data.ByteString{.Lazy}.Char8, but that will assume ASCII encoding, which you may not want
21:46:53 <jle`> :t T.unpack . T.decodeUtf8
21:46:56 <lambdabot> BSC.ByteString -> String
21:47:25 <jle`> :t fmap T.unpack . T.decodeUtf8     -- if you want to catch encoding errors
21:47:27 <lambdabot> error:
21:47:27 <lambdabot>     • Couldn't match type ‘Text’ with ‘f Text’
21:47:27 <lambdabot>       Expected type: BSC.ByteString -> f Text
21:47:38 <jle`> :t fmap T.unpack . T.decodeUtf8'
21:47:40 <lambdabot> BSC.ByteString -> Either Data.Text.Encoding.Error.UnicodeException String
21:48:50 <jle`> is T.unpack . T.decodeUtf8 too much to type ... ?
21:49:16 <pacak> jle`: You also need to import more stuff
21:52:20 <Xnuk> Just converted from ByteString stream to Text stream and problem solved
21:53:25 <buttons840> in spock, what is the context? is it a type that is "carried through" a single request-response cycle?
21:53:50 <geekosaur> the context is likely a connection
21:54:18 <geekosaur> also any cached resources you might use, such as databases or logging
21:54:57 <buttons840> "SpockCtxM ctx conn sess st" -- there's apparently a context, connection, session, and state
21:56:08 <buttons840> the connection uses a resource pool and is holding my database connections (though the resource pool can hold anything i suppose), web sessions are well understood, and the application state is a global state for the entire server -- i don't know what the context is though
21:57:22 <buttons840> geekosaur: do you still think the context is a connection? any idea how it differs from the "connection" type parameter?
21:58:32 <geekosaur> I have no idea what it is now
21:58:49 <geekosaur> because inside Spock.Core things generally use type SpockT = SpockCtxT ()
21:59:03 <geekosaur> so it's usually unit meaning "unused"...
21:59:22 <buttons840> yeah, i was noticing that just now -- looks like it's probably for internal use?
21:59:24 <geekosaur> suggest you ask the developer(s)
22:02:32 <buttons840> ok, this article explains contexts: https://www.spock.li/2015/08/23/taking_authentication_to_the_next_level.html (in case of any interested observers)
22:07:49 <Cale> Haha, the font used in Spock's logo is vaguely reminiscent of Star Wars
22:24:35 <Welkin> Cale: wrong sci-fi epic?
22:24:51 <Welkin> lol, you are right
22:24:55 <Welkin> that must be a new logo
22:25:01 <Welkin> I don't remember that a couple months ago
22:26:47 <geekosaur> maybe just to psych Paramount lawyers or something
22:42:00 <sanitypassing> hi, people from ##math suggested I ask here: can anyone recommend undergraduate-friend papers on lambda calculus beta reduction strategies? 
23:05:17 <Axman6> sanitypassing: hmm, I'm surprised there isn't more info on the lambda calculus wikipedia page
23:07:45 <ahri> hi, i'm learning haskell by writing a bomberman clone. i was representing the "Board" as a [[Cell]] but as i need to change elements within that 2D list, i'm refactoring towards a (Seq (Seq Cell)) instead. that's going alright (especially with Views... man, that's awesome!) however my Show instance was: intercalate "\n" $ convertCellsToChars cells. what should my refactoring strategy be in order to go from 
23:07:46 <johnw> how can I serve raw JSON in servant?  That is, instead of having a data type Foo that I serve with Get '[JSON] Foo, I have a block of JSON text (that I've not decoded), that I just want to serve directly.  If I serve it as Get '[JSON] Text, then servant escapes the JSON, making it invalid.  Do I need to use an OctetStream?
23:07:51 <ahri> (Seq (Seq Cell)) to something "Show"able? i want to keep it reasonably performant as i want to use this function to display my game on the linux console. should i just "toList" it or is there a more nuanced approach i should take?
23:08:01 <Axman6> sanitypassing: http://www.cs.cornell.edu/courses/cs6110/2014sp/Handouts/Sestoft.pdf touches on some different strategies
23:09:10 <Axman6> ahri: I would just use toList . fmap toList unless you have evidence that that is slowing your code down
23:09:30 <ahri> (i'm vaguely aware of the alternatives to String such as Text and ByteString but i've never used them and don't know if they're relevant to what i'm doing)
23:09:42 <Axman6> johnw: you just use Get '[JSON] Value
23:09:53 <johnw> thx, trying now
23:09:54 <Axman6> (where Value is the Aeson Value type)
23:10:02 <ahri> Axman6: cool, i've not done any testing yet, i just didn't want to do anything obviously stupid!
23:10:31 <sanitypassing> thanks, I'll take a look at that now
23:11:37 <Welkin> Cale: /quit
23:11:44 <Welkin> lol oops
23:11:59 <Axman6> hey, that's not nice
23:25:01 <nbtiwires> hello
23:26:01 <liste> hello nbtiwires 
23:26:08 <nbtiwires> I've built yesod sample following http://www.yesodweb.com/page/quickstart on ubuntu 14.04
23:26:37 <nbtiwires> but when I run stack exec -- yesod devel -p 3333, I'm getting "Executable named nix-shell not found on path"
23:26:48 <nbtiwires> I cannot install nix, is there way to disable it?
23:28:38 <nbtiwires> Also I have nix: enable: false in ~/.stack/config.yaml
23:29:20 <nbtiwires> it didn't help
23:31:08 <Axman6> hmm, you might try #haskell-stack
23:36:03 <nbtiwires> thx Axman6
