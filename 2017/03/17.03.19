00:03:45 <mbw> kshukla: Since you want to do the direct recursion approach, this would be something along the lines of this: http://lpaste.net/353702
00:04:01 <_sras_> How can I make the functions in a where binding available to all functions bodies?
00:04:38 <Cale> _sras_: Move them out of the where binding to the top level?
00:04:54 <mbw> _sras_: If I understood you correctly, either what Cale said, or replace pattern matching with a case expression.
00:05:07 <mbw> If you want the helper function to stay local
00:05:08 <mbw> .
00:05:35 <mbw> case expressions are uglier of course.
00:05:43 <Cale> Note that the things defined in the where clause will scope over multiple guards
00:06:19 <Cale> It's just that they have access to the variables bound on the left hand side of the equation, and so it doesn't make sense for them to scope over multiple parts of a function declaration
00:06:40 <_sras_> Cale: Yes. Right.
00:07:14 <_sras_> mbw: Case expressiosn cannot work if I have multiple arguments, right?
00:07:20 <mbw> Also, you can still treat a top-level function as a helper function. If you're inside a module, just don't export it.
00:07:49 <kshukla> Sorry, I am new to haskell, but what does `IO [String]` in `fillList :: [String] -> IO [String]` mean. I have only seen `IO ()`.
00:08:08 <mbw> No problem. Read it like this:
00:08:17 <mbw> filList takes one argument, a list of strings.
00:09:12 <mbw> The result of which is a generalized notion of a "computation", i.e. not a pure function, which 1. Returns a result value of type [String], and 2. produces some side-effects captured by "IO".
00:10:06 <mbw> _sras_: In case e of ... , 'e' can be any valid haskell expression. It's not like a switch statement in C, for instance, which can only test for integral values.
00:10:18 <mbw> Or maybe I misunderstood your question.
00:10:32 <Rotaerk> kshukla, the () in IO () is a type too, just one for which there is only a single possible value.  it's used when there's nothing meaningful to return
00:10:42 <_sras_> mbw: Yes. In case of multiple arguments, I can use a tuple..right?
00:11:17 <Cale> I would rather say that a value of type IO [String] is a description of some stuff which could be done, and at the end of doing that stuff, you would get a [String] as the result
00:11:21 <mbw> _sras_: Maybe it would be easiest if you pasted a concrete example.
00:12:02 <Cale> If it helps, the difference between IO [String] and [String] is like the difference between the program /bin/ls and a listing of files in your home directory
00:13:29 <Cale> For example, getLine :: IO String is a value which describes how to get a line of text from the terminal (or stdin, if you prefer)
00:14:10 <mbw> That of course assumes that kshukla already knows about non-strict evaluation...
00:14:21 <Cale> Evaluating this description won't do much.
00:14:43 <Cale> It has to be executed, which is separate from evaluation, in order for anything to happen.
00:14:48 <Rotaerk> I usually read "IO x" as "an IO action that, when executed, produces an x"
00:14:54 <Cale> right
00:15:31 <Cale> When a compiled program is run, the action you define called main will be executed, and in turn, it will usually be built up from smaller actions.
00:15:54 <Cale> If you type an IO action at the ghci prompt, ghci will notice that it's an IO action and execute it for you as well.
00:16:03 <Cale> (and it will also print the result, if it knows how)
00:17:02 <Rotaerk> kshukla, make sense or have you been thoroughly confused?
00:17:49 <Cale> But yeah, it's important to realise that this execution (carrying out the effects described by IO actions) is separate from evaluation (a process of reducing expressions to values, typically so that patterns can be matched).
00:18:18 <kshukla> return type is IO [String], but you are returning a [String] ?
00:18:36 <Cale> kshukla: Well, your function is producing an IO [String] when applied
00:18:55 <Cale> But that result of type IO [String] is itself a program, which when executed, will result in a [String]
00:19:14 <Rotaerk> IO [String] is the "return type" of the function, but [String] is the "return type" of the IO [String] itself
00:19:15 <Cale> and that program can cause your computer to do anything that computers can do
00:19:41 <Cale> Whereas the function can do nothing more than to compute its result (which is that program)
00:19:47 <Rotaerk> i.e. evaluation of the function produces an IO [String], and execution of that action produces a [String]
00:20:13 <mbw> In list' <- fillList [], I "bind" the result to list'. I can do this only inside another IO action. If I would've written let list' = fillList [], list' would've been of type IO [String].
00:20:36 <kshukla> @mbw in your program in your `if` you are returning `strings` which if of type [String]
00:20:36 <lambdabot> Maybe you meant: yow msg bf
00:20:54 <Cale> Yeah, inside a do-block, the statement  v <- x  means "execute the action x, and call its result v"
00:21:14 <Cale> If x :: IO t, then v :: t, and v will be usable throughout the rest of the do-block.
00:21:14 <Rotaerk> "but only when the whole do block is, itself, executed"
00:21:29 <Cale> Right, the do-block as a whole will itself be another one of these actions
00:21:35 <mbw> Yes, but its "return strings", not just strings.
00:21:48 <Rotaerk> not necessarily
00:21:59 <mbw> Without the return, it would be a type mismatch. 
00:22:23 <mbw> :t return
00:22:25 <lambdabot> Monad m => a -> m a
00:22:37 <Rotaerk> well I just mean, the last part of the do block doesn't have to be a return
00:22:39 <kshukla> OIC. So return is like an implicit type cast?
00:23:00 <mbw> i.e. take strings, and put them into IO. And like Rotaerk said, I don't have to do this in the else branch.
00:23:11 <Cale> return v is the action which does nothing except to, well, produce v as its result
00:23:13 <mbw> noo....
00:23:50 <Rotaerk> yea just because it's an IO "action" doesn't mean it necessarily *does* something, just that it might, depending on how it's defined
00:24:00 <Cale> return is a function of type a -> IO a here (actually its type is a bit more general than that, but for the sake of IO actions, that's its type)
00:24:41 <Cale> Oh, should have mentioned: the result of the do-block is the result of the last action in it
00:25:02 <kshukla> ah... right
00:25:09 <Cale> So, when return v gets executed at the end of the do-block, the whole combined action returns v.
00:25:59 <Rotaerk> if you have:  do { x <- getLine; return x; }  you can simplify that to:  do { getLine; }  and further to just:  getLine
00:25:59 <mbw> I could've written x <- fillList ...; return x. But then I would just "get x out of IO and put it right back in", so to say.
00:26:20 <Cale> Rotaerk: also you don't need semicolons at the end like that ;)
00:26:34 <Cale> (semicolon is a separator rather than a terminator)
00:26:36 <Rotaerk> oh :P I never use single line do blocks in actual code
00:27:04 <_sras_> While makeing a type class how can I mark the minimal required function definitons to make a valid instance?
00:27:36 <mbw> {#- MINIMAL fun1 -#}.
00:27:37 <Cale> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#minimal-pragma
00:27:38 <robkennedy> Is there a different function for `fix f x = if f x == x then x else fix f (f x)`?
00:27:44 <Cale> _sras_: ^^
00:27:46 <mbw> If I didn't screw up the braces.
00:27:47 <kshukla> @mbw why doesn't else require a return in your program?
00:27:47 <lambdabot> Maybe you meant: yow msg bf
00:28:13 <mbw> For the exact reason Rotaerk just gave, and me one line above.
00:28:51 <ezyang> robkennedy: Not int he stdlib, I'm pretty sure 
00:28:55 <ezyang> :t iterate 
00:28:57 <lambdabot> (a -> a) -> a -> [a]
00:29:24 <Cale> kshukla: The result of a do-block is the result of the last action in it -- return is just a function which happens to produce a boring action.
00:29:39 <Rotaerk> isn't fix usually defined as:  fix f = let x = f x in x
00:29:49 <_sras_> mbw: Please take a look here http://lpaste.net/353703 . What I am trying to do is to move the bottom functions into the local scope of the instance definition.
00:29:52 <mbw> In fillList arg = something, something is of type IO [String]. Which is exactly the type of fillList arg2 in the else branch.
00:29:53 <Cale> Rotaerk: yes
00:30:19 <Cale> robkennedy's fix is a different function though
00:30:53 <robkennedy> Yeah I know that fix isn't the functions name
00:31:01 <Rotaerk> k
00:31:29 <kshukla> OK, so last expression in a do block should be of type IO (a) and return just makes that `a` an `IO a`?
00:31:52 <Cale> yeah
00:32:29 <Cale> return takes a value, and builds the action which does nothing except to have that value as its result
00:33:36 <Rotaerk> kshukla, if the thing you want to return in your do block is the result of the last action in your do block, you can just end it with that action; you really just need return if the result is *not* that of the last action
00:33:45 <Cale> right
00:33:46 <robkennedy> :t \f x -> let ys = iterate f x in fst $ filter (uncurry (==)) $ zip ys (tail ys)
00:33:48 <lambdabot> error:
00:33:48 <lambdabot>     • Couldn't match expected type ‘(a, b0)’
00:33:48 <lambdabot>                   with actual type ‘[(a1, a1)]’
00:34:34 <robkennedy> `fst . head`. I see what you meant
00:34:56 <Rotaerk> kshukla, do { putStrLn "Type something..."; getLine }  -- no return necessary... the result of the do block is whatever line is returned by getLine
00:35:40 <Rotaerk> but if I wanted to, say, get two lines and combine them or something, then I can do this:  do { x <- getLine; y <- getLine; return (x ++ y) }
00:35:43 <robkennedy> How does ghc decide between what gets b's and what gets a3's? 
00:36:05 <Cale> robkennedy: It tries to use the variables which occur in your explicit type signatures
00:36:21 <Cale> robkennedy: But if it has to invent variable names while typechecking, it's not very creative
00:36:35 <Cale> It tends to just append numbers
00:36:56 <_sras_> kshukla: I don't know if this helps, but the 'return a' just calls the 'return' method in what ever monad instance you are in. So if you do 'return 5::Maybe Int' you get a 'Just 5'
00:37:15 <Cale> (we hadn't yet mentioned monads)
00:38:22 <Rotaerk> yea it's best not to graduate to the monad abstraction until *after* he's got some specific instances down...
00:39:00 <Cale> Still, it might be worth explaining the do-notation in terms of (>>=)
00:39:05 <Cale> Some people like that :)
00:39:18 <Cale> There's an operation:
00:39:27 <Cale> (>>=) :: IO a -> (a -> IO b) -> IO b
00:39:29 <mbw> _sras_: Kinda hard to do the refactoring when all the types are missing :(
00:40:16 <Cale> which, given some action x :: IO a  and a function  f :: a -> IO b  gives you the action x >>= f :: IO b which when executed will first execute x, and then apply f to its result to figure out what to do next
00:40:23 <_sras_> mbw: all types are missing?
00:40:51 <Cale> i.e. if the result of executing x was v, then it will execute the action f v
00:40:56 <mbw> DepartureTime, DateWidget, ...
00:41:00 <Cale> and produce the result of that as its own
00:41:19 <Cale> do-notation is really syntactic sugar for using a bunch of (>>=)'s
00:41:41 <Cale> In particular,  do { v <- x; <stmts> } = x >>= (\v -> do { <stmts> })
00:42:06 <ezyang> Man, newtype wrapping unwrapping is such a pain 
00:42:11 <Cale> and  do { x ; <stmts> } = x >>= \_ -> do { <stmts> } -- i.e. we discard the result of x
00:42:14 <ezyang> I wish generic programming worked for this sort of thing 
00:42:36 <Cale> and  do { let { <decls> } ; <stmts> } = let { <decls> } in do { <stmts> }
00:42:49 <Cale> and finally, as a base case,  do { x } = x
00:44:44 <_sras_> mbw: is that better http://lpaste.net/353703 ?
00:45:24 <mbw> Ok, I'll take a look at it. Might take a moment though, since I have a splitting headache :(
00:45:48 <jgt1> 🤒
00:46:03 <Cale> kshukla: A monad is just a type M which, like IO, has operations of the right shape: return :: a -> M a, and (>>=) :: M a -> (a -> M b) -> M b  (and these have to satisfy a few conditions) -- it turns up this pattern is common in functional programming, so we abstract over it to save ourselves from writing some common functions again and again.
00:46:47 <mbw> _sras_: There's still a lot of stuff missing. I would feel uncomfortable giving advice without being able to get it to typecheck...
00:47:12 <mbw> Day, FormatTime, LocalTime.
00:48:07 <mbw> Are monads still taught in terms of return?
00:48:17 <Cale> Yes?
00:48:36 <mbw> Because of Functor/Applicative/Monad I mean
00:48:39 <Cale> Rather than what?
00:48:45 <mbw> Just bind
00:48:59 <Cale> Oh, well, it's worth characterising them this way
00:49:05 <mbw> On the other hand, it makes sense of course. Otherwise you'd have to include Applicative.
00:49:14 <Cale> because you can go back and pick up Functor and Applicative for free
00:49:30 <Cale> fmap = liftM
00:49:36 <Cale> pure = return
00:49:39 <Cale> (<*>) = ap
00:49:53 <_sras_> mbw: Those are all from the `time` package...
00:50:01 <Cale> Or, well, perhaps I should have written out the definitions of liftM and ap in-place there :)
00:50:04 <mbw> _sras_: Ok.
00:50:12 <_sras_> mbw: https://hackage.haskell.org/package/time-1.8.0.1/docs/Data-Time-Format.html
00:51:09 <Cale> Applicative is kind of a fancier abstraction in my head -- it has a slightly lower power/weight ratio than Monad (at least in my opinion). Functor is worth introducing early though.
00:51:27 <_sras_> mbw: https://downloads.haskell.org/~ghc/7.0.3/docs/html/libraries/time-1.2.0.3/Data-Time-Calendar.html#t:Day
00:53:08 <mbw> _sras_: And you want ALL of those function to go into the instance declaration?
00:53:35 <_sras_> mbw: not into, but would be nice if I can limit their scope to it.
00:54:04 <mbw> Cale: I actually found it easier to grok monads comming from applicative (and reading papers :/). Functor -> Monad is kind of a leap.
00:54:39 <Cale> Well, everyone is different
00:55:07 <Rotaerk> nah, some people are more equal than others
00:56:01 <Cale> On the face of it though, I would expect that Applicative would be about as hard to pick up as Monad would be
00:56:17 <ubsan_> ertes: I tried to rewrite the C++ version to use compile-time evaluation
00:56:41 <Cale> Mainly because the sets of available examples of each are about the same
00:56:42 <ubsan_> turns out, clang doesn't like that big of arrays :P
00:56:57 <ubsan_> > constexpr evaluation hit maximum step limit; possible infinite loop?
00:56:59 <lambdabot>  <hint>:1:44: error: parse error on input ‘;’
01:22:33 <cocreature> does anybody know what stackage’s policy is for adding packages that depend on foreign libraries?
01:23:30 <ezyang> your best bet is probably to search in the issue tracker? 
01:24:02 <cocreature> ezyang: I tried that but so far I did not find anything useful
01:24:23 <cocreature> I guess I’ll just try to add a package and see if they complain :)
01:24:38 <ezyang> "...forgiveness...blah blah blah..." 
01:26:03 <mbw> _sras_: K I've been shuffling things around etc. I think the most sensible way would be to let toDateWidget accept an additional argument, maybe something like data WidgetCfg = Full | NotSoFull, and let the typeclass just have one method. Then you'll just have one function that has to pattern match, which could be done via case expressions and one local function definition. Maybe I'm missing something, but I 
01:26:09 <mbw> think other approaches would be too "clever". On the other hand I am probably missing a lot of context here :)
01:26:41 <_sras_> mbw: Yes. That is what I figured as well...
01:29:47 <mbw> Then on the otherhand, this will be just isomorphic to toDateWidget' :)
01:30:41 <mbw> i.e. if I flip the arguments and have toDateWidget :: Cfg -> a -> DateWidget, then toDateWidget Full = toDateWidget' True, etc.
01:31:00 <mbw> I think you're just cleverly duplicating logic with these two methods.
01:32:34 <mbw> You can just let toDateWidget' accept a Cfg instead of a bool and inline it. Or you don't use Cfg, but bool. Then it's more or less already there.
01:33:22 <mbw> I'd personally go with a dedicated type. Then match in a case expression and reuse the locally defined function
01:34:11 <mbw> You can of let one class method call the other, but I'd find that confusing.
01:38:58 <mbw> Cale: About Applicative. I've found it very logical to consider it a necessary extention to Functor, i.e. fmap with binary/ternary/etc. functions. But on the other hand, I've never really _had_ to consider it a generalization of Monad, since I haven't been using Haskell for that long.
01:44:01 <Cale> mbw: I suppose I usually think of  liftA2 f x y  as usually meaning something like  do u <- x; v <- y; return (f u v)
01:44:57 <Cale> Or  x <*> y  as meaning  do f <- x; v <- y; return (f v)
01:45:09 <Cale> Of course, that breaks down when the thing isn't actually a monad
01:48:23 <mbw> I like that aspect that from the container perspective, you have something like parallelism for fmap, concurrency for liftA2/3/..., and serial execution for bind. Even with the instance for ((->) r), it kinda shows how the "imperative style" trains you in thinking serially. Of course this doesn't hold for the general case, but I kind of found that insightful when first learning about it.
01:50:39 <mbw> The general case being non-commutative monads.
01:50:48 <mbw> Or some other subtlety.
01:52:09 <jondot> hello
01:52:28 <mbw> hi
01:53:17 <mbw> *sequencially
01:53:36 <jondot> im trying to understand where the terminology of FP comes from. for example, option/just/either/lift/map/zip and so on. i understand that much of this is from category theory but i'm trying to understand where did it first meet with programming practically?
01:54:00 <Cale> none of that comes from category theory
01:54:08 <jondot> was it haskell that first made the theory into programming practically?
01:54:20 <Cale> It comes from older functional programming which was mostly done in lisp
01:54:38 <Cale> Though Either is a Haskell thing. It was usually called Option in earlier MLs
01:54:39 <jondot> but lisp was not statically typed? i thought ML would be a root of these...
01:55:08 <Cale> Lisp had map, and I think zip as well
01:55:35 <jondot> yes, that's true. i'm still chasing to find the first paper / publication that mentions this
01:56:35 <Cale> Actually, "lift" I would say is probably from mathematics, though we use it in Haskell in ways that are not *quite* the same as the relevant mathematicians use it, though in general I doubt they'd have any trouble with our usage.
01:56:57 <jondot> Cale: so my challenge is to find where was the first time that lift appeared and in which programming language
01:57:39 <Cale> That's an easier question if you say which lift you mean
01:57:59 <jondot> the one that takes a function and lifts it to use Option, say.
01:58:06 <Cale> If it's the one for monad transformers, that would be Haskell, because monad transformers are an invention of Haskell programmers.
01:58:15 <Cale> mm
01:58:21 <Cale> Which language uses it that way?
01:58:30 <jondot> scala is one
01:58:40 <jgt> hey folks
01:58:48 <jondot> you can lift Math.abs to take option and return option
01:58:58 <Cale> Well, lift is a term used throughout mathematics in various ways, some technical, others not
01:59:05 <jondot> right
01:59:06 <jgt> is there a way to write this case without it being indented so far? http://sprunge.us/CZcj
01:59:16 <Cale> But usually with a sense of taking something specific and bringing it into a more general context.
02:00:05 <mbw> > fmap (abs) (Just (-3))
02:00:07 <lambdabot>  Just 3
02:00:10 <mbw> like this?
02:00:23 <jondot> Cale: so I can ask this question from a different point of view. let's say you wanted to build and new functional programming language. how would you say 'yes this is the API i need'. would you survey a bunch of FP languages and copy the API?
02:00:53 <Cale> Perhaps the canonical example coming from topology, where you have a fibration with a "base space" and a "total space", and then you might speak of "lifting" maps defined on the base space to the total space
02:01:23 <jondot> Cale: i'm guessing Clojure took a lot from Scheme/Lisp, but did they? or were there a bunch of publications that describe various APIs that they decided to follow?
02:01:25 <Cale> jondot: Depends on my reason for defining a new programming language
02:02:22 <Cale> Also, most names are somewhat arbitrary -- it's probably more important to decide what concepts you want first, and then what names you'll give them.
02:02:56 <jondot> Cale: well, how about introducing FP into a new language. So, Swift for example. Let's say you want to extend the standard library and make it FP happy.
02:03:03 <Rembane> Take the names from the domain.
02:03:13 <jondot> Cale: and where are these concepts rooted at?
02:03:43 <Cale> Well, the concepts are rooted in a particular way of thinking about and breaking down problems.
02:03:51 <jondot> BTW i can find plenty of papers covering Lisp, and covering the root concepts, without knowing Lisp or scheme or clojure. however I can't find any for ML type languages
02:04:33 <jondot> (that are based on category theory more profoundly than lispy languages because of types)
02:04:33 <Cale> I guess one place to start would be "Types and Programming Languages" by Benjamin Pierce
02:04:43 <jondot> aha1
02:04:51 <jondot> yeap that's one book on my buy list
02:05:55 <kadoban> Is it accurate to say it's based on CT? My wording would be that it took a concept or two, mostly Monads, and that's about it
02:06:01 <Cale> If you want a mathematically abstract version of typed functional programming, you might look to type theories such as System F and Martin-Löf type theory
02:06:08 <Cale> and the calculus of constructions
02:06:31 <Cale> kadoban: Yeah, well, products and sums before that
02:06:47 <Cale> But it's hard to *really* say that's the influence of category theory
02:06:52 <Koterpillar> How do I pronounce SYB?
02:07:03 <Cale> "Scrap Your Boilerplate"
02:07:07 <kadoban> Hmm
02:07:11 <Cale> Or "ess wye bee"
02:08:02 <Koterpillar> thanks
02:08:20 <Cale> There's certainly a fundamental sort of connection between logic, category theory, and type theory
02:08:48 <Cale> (and then functional programming as an application of type theory)
02:09:12 <jondot> and i'm looking for the series of publications that flushes that connection out :)
02:09:19 <Cale> and it's hard to pick apart which of these three was responsible for originating any particular idea
02:09:32 <jondot> i get a stronger feeling i need to look around publications dealing with ML
02:09:32 <Cale> because as soon as you can say something in one of them, you can probably say it in the others
02:09:53 <Cale> So, the connection I'm referring to is called the Curry-Howard correspondence
02:10:52 <Cale> In logic, if you know that A implies B, and you know that A, then you can conclude B
02:11:13 <Cale> In lambda calculus, if you have f: A -> B, and you have x: A, then you can form  f x: B
02:12:03 <Cale> In logic, if you want to prove A implies B, then you start by assuming A, and attempt to conclude B, and if you're successful, by natural induction, conclude A implies B
02:13:04 <Cale> If lambda calculus, if you want to construct a term of type A -> B, then you start by introducing a variable (x:A), and attempt to construct a term y:B, and if you're successful, then you may form the lambda term (\x -> y) : A -> B
02:14:18 <Cale> Similar characterisations can be given for the connectives, with "and" corresponding to the pair type (its introduction rule corresponding to the data constructor for pairs, and elimination rules the projections to the components)
02:14:55 <Cale> and "or" corresponding to Either, with its introduction rules corresponding to the Left and Right constructors, and its elimination rule corresponding to well, the function we call 'either' in Haskell.
02:14:58 <Cale> :t either
02:14:59 <lambdabot> (a -> c) -> (b -> c) -> Either a b -> c
02:15:48 <Cale> (If we can conclude c from a, and we can conclude c from b, then we may conclude c from a \/ b)
02:16:56 <jondot> Cale: interesting
02:17:00 <Cale> and these things correspond to various concepts in category theory as well: implications and function types correspond additionally to exponential objects
02:17:11 <Cale> "and" and product types to product objects
02:17:22 <Cale> "or" and sum types to coproducts
02:18:20 <Cale> (which are also called sums in category theory)
02:19:08 <jondot> so both lambda calculus and category are accessible, yet how did they make it into a programming language, and which one was the first?
02:19:12 <jondot> was it miranda?
02:20:11 <Cale> Well, lambda calculus, even before electronic computers when it was a sort of notation for logical proofs, always had a notion of "reduction" or "simplification" of proofs, which we'd now think of as "evaluation"
02:20:52 <Cale> as for how it came into programming, well, untyped lambda calculus was an inspiration to introducing lambda to lisp.
02:20:58 <Cale> I don't know if there's anything earlier than that.
02:21:23 <Cale> and then the typed side of things came first with ML, so far as I'm aware
02:23:08 <louispan> Hi all, I've been creating yet another GUI framework which is now in a stable state. Please have a look and let me know what you think:
02:23:09 <louispan> https://www.reddit.com/r/haskell/comments/6099gw/yet_another_gui_framework_glazier_glazierreact/
02:23:47 <Cale> There was, it seems, a bit of a renaissance of type theory and lambda calculus which went on in the 1970's though, in parallel between logicians and computer scientists
02:23:55 <Cale> https://en.wikipedia.org/wiki/System_F
02:24:01 <Cale> "System F was discovered independently by logician Jean-Yves Girard (1972) and computer scientist John C. Reynolds (1974)."
02:24:25 <jondot> Cale: i'm tracing it now to SASL
02:24:29 <Cale> I don't know how I quite feel about that characterisation of what occurred, but something close enough :)
02:24:41 <Cale> and at nearly the same time...
02:24:52 <louispan> The todo mvc example can be played with here: https://louispan.github.io/glazier-react-examples/ Only 170kb of gzipped javascript (including React)
02:25:45 <Cale> https://en.wikipedia.org/wiki/Intuitionistic_type_theory
02:26:08 <jondot> you get some of the terms here, in 'prelude' https://web.archive.org/web/20150402133901/http://www.eis.mdx.ac.uk/staffpages/dat/saslman.pdf
02:26:19 <jondot> it's amazing how 'prelude' meant nothing to me until now
02:27:02 <Cale> which traces its roots back to much earlier intuitionistic logic of Brouwer and Heyting and Kolmogorov that goes back to the 1920s
02:27:51 <Cale> Oh, yeah, Turner would be another guy I shouldn't neglect to mention :)
02:28:46 <Cale> and Landin, with his "The Next 700 Programming Languages"
02:28:54 <Cale> http://www.cs.cmu.edu/~crary/819-f09/Landin66.pdf
02:29:44 <Cale> and his language ISWIM, which was never implemented on a computer, but influence the design of a lot of functional programming languages
02:29:52 <Cale> d*
02:31:45 <Cale> That was in 1966, and he has where clauses and an equational sort of notation which got put into SASL and ML
02:31:49 <Cale> (and Haskell, of course)
02:32:38 <Cale> Turner was also responsible for Miranda, of which Haskell started out as sort of an open source clone :)
02:33:06 <kadoban> I've never heard that last part of that sentence before, that's a bit amusing.
02:35:10 <Cale> Well, I'm being a little glib about it, but that's not an entirely unfair characterisation :)
02:36:20 <jophish> ertes: It certainly worked well enough for me to get an example program running when vulkan was first out
02:36:31 <Cale> I guess the programming language theory researchers got a little tired of putting "Miranda is a trademark of Research Software Ltd." in all their papers
02:36:42 <kadoban> Hah
02:37:02 <jophish> however the spec has moved on since then and I'd guess that it no longer parses
02:37:16 <jophish> (probably just a handful of minor issues though)
02:38:03 <Cale> https://www.cs.kent.ac.uk/people/staff/dat/miranda/Overview.html -- if you have a look at the syntax, it would take a moment to realise that it's not Haskell -- the type signatures would give it away, and data declarations
02:39:14 <kadoban> Wow, I didn't know they looked so very similar
02:41:38 <jgt> hey folks, how can I go from a `Maybe Text` to a `Maybe Int`? I was thinking to `fmap readMaybe`, but this results in a `Maybe (Maybe Int)`. Do I need a monad here to unwrap the inner Maybe?
02:43:05 <mbw> jgt: I don't think that this return type is unreasonable, since reading can fail. You should be able to just pattern match. Especially if you're already inside the "Just case" of Maybe Text.
02:43:18 <mbw> In which case it would be just Maybe Int.
02:43:54 <kadoban> jgt: You can indeed use maybe, either by using "join" on that result, or by using >>= in the first place instead of fmap + join
02:44:00 <jgt> yeah, I understood the part where reading could fail
02:44:12 <jgt> I could do it the case way, but it might be a bit ugly
02:44:17 <kadoban> s/indeed use maybe/indeed use Monad/
02:44:35 <jgt> kadoban: how would that look? I can't quite see it in my head
02:45:34 <kadoban> :t (>>=)
02:45:35 <lambdabot> Monad m => m a -> (a -> m b) -> m b
02:46:03 <kadoban> So,     theValue >>= readMaybe    looks like the right puzzle connection
02:46:22 <kadoban> Where   theValue :: Maybe Text
02:46:33 <jgt> oh!
02:46:38 <jgt> yeah, that totally works
02:46:45 <ngc24> Hello need some help ~ How do I read an arbitrary number of lines till some delim from stdin and store it in a list? To use forM I need to know the number of lines.
02:46:48 <jgt> thank you :)
02:47:02 <kadoban> Anytime
02:48:02 <Cale> ngc24: You might just write a recursive loop
02:49:04 <Cale> ngc24: loop xs = do x <- getLine; if isMyDelimiter x then return (reverse xs) else loop (x:xs)
02:49:30 <ngc24> Cale: Thanks!!
02:50:17 <jgt> > Just "123" >>= readMaybe
02:50:20 <lambdabot>  error:
02:50:20 <lambdabot>      Variable not in scope: readMaybe :: [Char] -> Maybe b
02:50:49 <jgt> > Just "123" >>= Text.Read.readMaybe
02:50:51 <lambdabot>  error:
02:50:51 <lambdabot>      Not in scope: ‘Text.Read.readMaybe’
02:50:51 <lambdabot>      No module named ‘Text.Read’ is imported.
02:50:56 <jgt> :(
02:51:21 <kadoban> Ya, lambdabot doesn't have everything, and I always have a hard time guessing what name it'd be under for some stuff it does
02:51:56 <jgt> well when I run it locally with Text.Read imported, `Just "123" >>= readMaybe` evaluates to `Nothing`
02:52:00 <jgt> and I'm not sure why
02:52:08 <geekosaur> ExtendedDefaultRules
02:52:18 <geekosaur> you didn't give it a type, so it defaulted the type to ()
02:52:29 <Iskungen> is porting code to haskell a good obfuscation method?
02:52:50 <kadoban> Only if your target "audience" doesn't know haskell I suppose
02:52:52 <Cale> Iskungen: Except when it's a good clarification method
02:53:35 <Cale> Iskungen: I've actually translated obfuscated C code to Haskell in a fairly mechanical way so that I'd be able to reason about its behaviour a bit more clearly and figure out what it was doing.
02:53:49 <jgt> geekosaur: Ah! Right you are. Thank you!
02:54:15 <jgt> I wish the compiler errors were a little more hand-holdy like Elm
02:56:07 <jgt> god damn my code ends up being beautiful with monads
02:56:42 <jgt> I have a lot of deeply nested case statements, where I'm usually breaking apart Eithers in my code
02:56:49 <jgt> so good to see that kind of thing fall away
02:56:52 <Cale> Just starting out having one function per point of control, with function parameters for each of the variables in scope, and then having the functions apply each other to new arguments according to the control flow and updates to variables
02:57:03 <kadoban> jgt: Yeah, they're *really* nice for that
02:57:13 <Cale> and that gives you a mess of equations, and you can start simplifying like highschool algebra
02:57:30 <Cale> until you hopefully end up with something that is actually comprehensible
02:59:04 <jgt> how my little bit of code looks now: http://sprunge.us/giSa
02:59:24 <jgt> is that idiomatic? Or would a Real Haskeller™ do it different?
02:59:58 <Cale> I would use =<< but that's personal preference
03:01:17 <jgt> Cale: how? I haven't used that operator before
03:01:30 <Cale> x >>= f  is the same thing as  f =<< x
03:01:35 <jgt> ah
03:01:58 <jgt> oh, it didn't type check because again I didn't specify the types
03:02:28 <Cale> didn't you?
03:04:01 <jgt> Cale: this is what I got back: http://sprunge.us/eeiG
03:04:55 <jgt> maybe I'm using a different listToMaybe
03:05:48 <Cale> Ah, I see
03:06:05 <Cale> You just need something in there to do some reading like on the other side
03:06:27 <Cale> listToMaybe wants a list of things
03:07:46 <jgt> oh, I have to unpack that Text first into a String
03:07:55 <jgt> because I want a list of Chars
03:08:41 <Cale> ah
03:08:49 <Cale> I missed that type Category = Char
03:10:22 <jgt> how do I unload Prelude from ghci?
03:14:13 <int-e> jgt: does import Prelude ()  (or perhaps  import qualifed Prelude) achieve what you need?
03:15:05 <int-e> jgt: if you want to remove prelude completely (because of class instances or perhaps rebindable syntax) I think you need to start ghci with -XNoImplicitPrelude
03:16:01 <int-e> jgt: oh this seems to work as well: :set -XNoImplicitPrelude, then :reload
03:17:24 <jgt> thanks!
03:17:45 <jgt> and now I realised that it was getting Prelude from some other module which explicitly imports it
03:24:04 <jgt> wonderful; this all works http://sprunge.us/ZJSR
03:24:20 <jgt> except I can't toJSON a ByteString, but that's expected, and is the next thing to do
03:40:33 <n123> hello all - I have this annoying issue trying to install hsffig: $ cabal install hsffig => http://sprunge.us/RiKE ???
03:40:56 <n123> any clue anybody what the problem could be ?
03:45:05 <cocreature> n123: hsffig depends on an ancient version of parsec that does not support GHC 8.0
03:45:34 <n123> ... so there is currently no FFI in haskell  ??
03:46:10 <n123> or is there another tool that I am not aware of ?
03:46:29 <cocreature> you don’t need any tool for doing ffi. C ffi is part of the haskell standard
03:47:10 <cocreature> I’m not sure if there is an up2date tool for autogenerating bindings based on headers
03:47:28 <n123> there is no mention of the tool being deprecated at https://wiki.haskell.org/FFI_imports_packaging_utility
03:47:29 <cocreature> there are various tool that simplify writing ffi bindings by reading the headers such as c2hs
03:47:47 <n123> aha
03:48:07 <jgt> what technique should I use to get rid of this deep nesting? http://sprunge.us/hgXf
03:48:10 <cocreature> n123: well it’s a wiki. if nobody feels like updating it, it’s not going to be updated :)
03:48:37 <jgt> I'm thinking perhaps EitherT? Or someone else maybe hinted at “kleisli arrows”, but I have no idea what that is
03:48:47 <n123> "This page was last modified on 13 September 2013, at 23:51" --- aha
03:49:06 <n123> all right thanks
03:50:52 <jgt> I've read https://ocharles.org.uk/blog/posts/2012-07-24-in-praise-of-EitherT.html but I didn't *quite* get it
03:51:23 <cocreature> n123: iirc https://wiki.haskell.org/Foreign_Function_Interface is fairly good at explaining how FFI works
03:52:23 <cocreature> jgt: do you know how you would remove that nesting if there was no IO involved?
03:54:31 <jgt> cocreature: I don't *know*, but I *think* I chain all the Eithers together with a bunch of >>=s
03:54:46 <cocreature> jgt: right or using do notation
03:55:02 <jgt> cocreature: sure
03:55:24 <jgt> cocreature: but am I right in thinking (and extrapolating from your question), that it doesn't quite work the same inside an IO?
03:55:50 <cocreature> jgt: so you can use >>= for Either  and you can use >>= to sequence several actions. the problem you are experiencing here is that you have "IO (Either a b)" to somehow combine the effects of >>= on IO and >>= on Either
03:56:15 <cocreature> jgt: ExceptT (which for some reason is what we call EitherT these days) is exactly that
03:56:41 <Cale> http://www.cse.unsw.edu.au/~chak/haskell/ffi/ffi/ffi.html -- the FFI portion of the Report is also quite readable (even compared to the rest of the Report)
03:56:53 <cocreature> ExceptT IO (Either a) b is just a wrapper around IO (Either a b)
03:58:22 <jgt> cocreature: https://www.schoolofhaskell.com/user/commercial/content/exceptions-best-practices#exceptt-io-anti-pattern
03:58:26 <jgt> > It is almost always wrong to wrap an ExceptT, EitherT, or ErrorT around an IO-based transformer stack.
03:58:28 <lambdabot>  <hint>:1:45: error: parse error on input ‘,’
03:58:31 <jgt> is that relevant here?
03:58:53 <jgt> sorry lambdabot; confused markdown blockquote and lambdabot expression
03:59:20 <cocreature> jgt: not really. the point of that article is that it might make sense to replace Either with exceptions. but if you are already using something of the form IO (Either a b) then using ExceptT is fine
04:02:51 <jgt> cocreature: what would my exception type be?
04:04:36 <cocreature> jgt: that’s up to you to decide. something that expresses the failure conditions appropriately. I don’t know when zrevrange fails
04:05:22 <jgt> cocreature: can I give it something meaningless until I know better?
04:06:57 <cocreature> jgt: sure, you just need something that is an instance of Exception
04:12:16 <jgt> ugh. This is complicated. I'll come back to it after I've read up a bit more on monad transformers
04:14:06 <cocreature> jgt: if you can provide a small code sample that compiles, I can transform it to ExceptT for you if you think that’s helpful. it’s just a bit hard to do this without being able to compile it since I’ll definitely screw up the types :)
04:14:50 <jgt> cocreature: I'm not sure I can; it's part of a Yesod app, so it's not quite so self contained
04:15:01 <jgt> I'll give you this module though
04:15:18 <jgt> cocreature: this almost works: http://sprunge.us/SRSU
04:15:34 <jgt> what doesn't work is doing toJSON on a ByteString, but that's expected
04:17:04 <cocreature> alright, give me a few minutes
04:17:35 <jgt> but actually changing that line to `return $ toJSON $ show companies` makes it compile, even if the result is nonsense
04:20:18 <ggVGc> are you saying if it compiles it's not actually correct anyway?
04:20:18 <ggVGc> heresy
04:20:49 <jgt> 😅
04:21:28 <jgt> ok, it's not totally nonsense, it's just overly wrapped/escaped
04:21:45 <jgt> which I'll take over ‘undefined is not a function’ any day
04:24:36 <patc> Need help - How do I display every n-th element of a list, say I need to display every 4-th eleemnt?
04:27:35 <cocreature> jgt: http://lpaste.net/353710
04:28:21 <cocreature> jgt: the fact that hedis requires that you work in RedisCtx instead of plain IO slightly complicates things since you need to define the necessary instances for RedisCtx and MonadRedis
04:31:36 <jgt> cocreature: oh wow, that's much more concise!
04:31:41 <jgt> thank you so much!
04:31:55 <cocreature> np
05:01:56 <halogenandtoast> Any suggestions for starting a yesod app with an elm frontend? Is elm-yesod the way to go... it seems outdated.
05:49:15 <phils_> what is the best book for learning haskell
05:51:02 <hpc> @where learnhaskell
05:51:03 <lambdabot> https://github.com/bitemyapp/learnhaskell
05:51:46 <hpc> ^ this is a meta-resource that might help
05:52:16 <hpc> there's two major resources that it does not mention iirc
05:52:18 <hpc> @where lyah
05:52:18 <lambdabot> http://www.learnyouahaskell.com/
05:52:19 <hpc> @where rwh
05:52:19 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
05:52:37 <hpc> i learned from lyah, but it does have a few issues like lack of exercises
05:53:02 <hpc> RWH has a thorough second half, but you most likely will want to use CIS194 for learning the language itself
05:53:27 <sphinxo> say I'm making a library for some extra string utils, how should I namespace it? Data.String.<something> ?
05:54:24 <matchwood> Hi all, looking for a little guidance on how packages are versioned and distributed - I'm a little confused particularly by this: https://hackage.haskell.org/package/mtl-2.2.1
05:54:35 <matchwood> The hackage package version is 2.2.1
05:54:59 <matchwood> With dependencies transformers (>=0.4 && <0.6)
05:55:02 <Theophane> sphinxo: if it works on the [Char] type, yeah better prefix it with Data.String.YourLib =)
05:55:46 <matchwood> but if you look at the .cabal in the source package https://hackage.haskell.org/package/mtl-2.2.1/src/mtl.cabal it specifies build-depends: base < 6, transformers == 0.4.* 
05:56:18 <matchwood> Similarly, in the git repo https://github.com/ekmett/mtl the change in transformers dependencies also goes along with a bump in version to 2.2.2
05:56:23 <matchwood> So something weird is going on. 
05:57:32 <matchwood> (the context for this is I'm trying to hack together a version of ghcjs that works for stack lts-8.0, so I need repo refs for a version of mtl that matches that one on hackage - i.e. version 2.2.1 but with expanded transformers depedency)
05:57:43 <matchwood> Anyone know where hackage / stackage is getting that from?
05:59:07 <cocreature> matchwood: you can make revisions to a cabal file directly without uploading a new version. you are pointing at the original cabal file, the updated one is https://hackage.haskell.org/package/mtl-2.2.1/mtl.cabal
06:00:06 <matchwood> cocreature: when you say that, do you mean that the package authors on hackage can do that?
06:00:14 <cocreature> matchwood: yep
06:00:40 <matchwood> ok, so there is no necessary relationship between the git source of a package and the contents of the package on hackage or elsewhere?
06:02:01 <cocreature> matchwood: you don’t even need revisions to cabal files for there to be no relation. if you upload a package you upload a tarball including among other things a cabal file and the source url contained in that is used as the git source shown on hackage. but nothing enforces that this is even an url that exists
06:02:06 <cocreature> it’s just useful metadata
06:02:21 <maerwald> matchwood: it's bad practice of maintainers, that's all
06:04:18 <matchwood> ok thanks, that all makes sense (even if confusing) - I knew that the source url was not necessarily related but I assumed that if there was an active github repo for it then it would reflect the state of the package on hackage...
06:05:04 <matchwood> Can any file be revised for hackage or is it just the cabal file?
06:05:10 <cocreature> only cabal files
06:05:28 <cocreature> the main motivation is that you can bump upper bounds if your package builds against a newer version without any changes
06:06:04 <matchwood> cocreature: ok I hoped it was that, otherwise things could get very messy!
06:06:31 <cocreature> yeah
06:06:54 <cocreature> tbh it’s already slightly messy but it’s also quite convenient to be able to bump bounds without having to do a new release each time
06:08:25 <matchwood> Yeah, except in the cases that other code relies on the git source directly! In any case ghcjs-boot is setup to patch packages, so I can simply add a patch that bumps the upper bounds
06:09:34 <matchwood> not really an issue, just wanted to be sure that I understood what was going on with hackage etc so I could be sure it would be using the same underlying code in the package
06:10:44 <halogenandtoast> hmm channel seems active now, so maybe I'll try asking again. Does anyone have any suggestions for writing a yesod/elm app (or snap/elm, or whatever).
06:10:57 <matchwood> though tying hackage /stackage packages transparently to vc commits would be nice!
06:13:06 <matchwood> halogenandtoast: I'm not sure what you mean by suggestions? As in, resources for learning how to do it?
06:19:38 <halogenandtoast> matchwood: more like, is there a good way to integrate them for example there is elm-yesod but it looks like it hasn't been updated in a long time
06:26:56 <matchwood> halogenandtoast: ah a common story. I can't help with that sadly, but I will say that the current energy of front-end haskell integration seems to be in ghcjs and stuff like reflex-frp rather than in haskell-like languages
06:32:35 <jgt> is there a way I can map a bunch of substitutions over some bytestring? So like `f "foo baz" [("foo", "bar"), ("baz", "qux")] ==> "bar qux"`?
06:37:21 <jgt> looks like I can compose together a whole bunch of Data.List.Utils.replace functions
06:53:07 <halogenandtoast> matchwood: as thanks, I'm wondering if I should just build two different apps then, the elm front-end and the haskell-backend/api
06:53:38 <halogenandtoast> Deployment becomes a pain though
06:54:24 <matchwood> halogenandtoast: Is there any particular reason you wouldn't want to go down the ghcjs route?
06:54:56 <matchwood> halogenandtoast: also you might be interested in this https://github.com/mattjbray/servant-elm#readme
06:55:18 <matchwood> servant is an awesome type safe routing / serving library
06:55:29 <halogenandtoast> I like and want to use Elm. I want to use the reactive functional programming setup.
06:55:38 <matchwood> http://haskell-servant.readthedocs.io/en/stable/
06:59:07 <matchwood> halogenandtoast: fair enough! Definitely worth looking into servant though  - that integration with elm is pretty new so should hopefully be suitable
06:59:37 <halogenandtoast> I'll try and look in to it
07:05:03 <stevenxl> I folks. I am doing an exercise where I have to redefining map f in terms of foldr. 
07:05:26 <stevenxl> This is my thought process and my result.
07:05:41 <stevenxl> Can someone help me figure out if there are any glaring holes in my understanding of this:
07:05:42 <stevenxl> https://gist.github.com/StevenXL/1592c92f6a32b97ff9c0e381237ca005
07:07:16 <stevenxl> Also, it is possible for me to check my answer in GHCi?
07:07:18 <lyxia> that's good
07:07:49 <lyxia> > map (>= 0) [1, -1, -1, -1, 1 :: Int]
07:07:51 <lambdabot>  [True,False,False,False,True]
07:08:18 <stevenxl> lyxia: thank you!
07:08:26 <lyxia> > (\f xs -> foldr (\h t -> f h : t) [] xs) (>= 0) [1, -1, -1, -1, 1 :: Int]
07:08:28 <lambdabot>  [True,False,False,False,True]
07:09:19 <lyxia> stevenxl: does checking like that work for you ^
07:10:36 <stevenxl> Yes, I see what you mean. Thank you. Would typing map f = foldr (\x rst -> f x ++ rst) [] into ghci and not getting an error back be enough? Would ghci throw an error if that answer was wrong?
07:11:38 <stevenxl> I see what you mean though. Run both the map version and the foldr definition and ensure the results are the same.
07:11:52 <lyxia> that wouldn't be sufficient
07:12:02 <lyxia> it just defines a function named map
07:12:17 <stevenxl> OK. Thank you. I'll stick with checking the results then. 
07:12:21 <stevenxl> ;-)
07:12:37 <lyxia> the fact that it typechecks does give you some level of assurance but it's not complete
07:13:19 <lyxia> :t \f -> foldr ((:) . f) []
07:13:20 <lambdabot> Foldable t => (a1 -> a) -> t a1 -> [a]
07:43:09 <spatial> let result = (y == fromIntegral( round y)) should return True if y is 0,5 ?
07:43:18 <spatial> False
07:43:57 <spatial> I get True. I think.
07:45:31 <lyxia> > round 0.5
07:45:34 <lambdabot>  0
07:45:55 <lyxia> That's not equal to 0.5
07:47:41 <spatial> I am trying to do this http://clhs.lisp.se/Body/f_inte_1.htm
07:48:47 <spatial> lyxia: You mean that code will return False if it is 0.5?
07:50:45 <lyxia> Yeah
07:59:06 <unknownln> > map round [0.5, 1.5, 2.5, 3.5]
07:59:08 <lambdabot>  [0,2,2,4]
07:59:09 <halogenandtoast> So this is probably impossible, but there isn't a function in Haskell the recurses with the same exact arguments is there?
07:59:30 <halogenandtoast> for instance is the user selected an invalid option and I want to make them chose again.
07:59:40 <halogenandtoast> s/is the user/if the user/
08:00:08 <unknownln> You can do that, it'd just be in IO
08:00:26 <halogenandtoast> I'm already in IO
08:00:50 <unknownln> Read a line, if it's right call a different function, otherwise call the function you're in again with the same arguments
08:00:59 <halogenandtoast> unknownln: yes
08:01:25 <unknownln> I'm saying that's what you should do :p
08:01:34 <unknownln> Let me get to a computer, I can write an example
08:01:41 <halogenandtoast> unknownln: Oh I'm doing that
08:01:59 <halogenandtoast> I just wondered if there was a "magical" way to recurse without having to pass that options
08:02:02 <halogenandtoast> basically
08:02:05 <unknownln> Oh, then what's the problem?
08:02:18 <halogenandtoast> maybe (myFun arg1 arg2) return maybeVal -> maybe magicFunc return maybeVal
08:02:22 <unknownln> Yeah there is
08:02:48 <unknownln> One sec
08:03:47 <mauke> just give your body a name
08:04:44 <mauke> myFun arg1 arg2 = magicFunc where magicFunc = do ...
08:05:34 <unknownln> https://hastebin.com/ejubahowux.hs for an extended example
08:06:03 <halogenandtoast> right, makes sense
08:06:41 <mauke> myFun arg1 arg2 = fix $ \magicFunc -> do ...
08:07:20 <halogenandtoast> mauke: yeah I knew about fix, didn't think to appy it here
08:07:41 <unknownln> wow, I always forget about fix
08:09:35 <orion> Is it legitimate for me to call "Maybe a" a co-product of Unit and a?
08:09:48 <cocreature> orion: sure
08:12:01 <glguy> halogenandtoast: It's common to see: f x y = go where go z = ...
08:13:04 <halogenandtoast> glguy: yeah
08:13:10 <halogenandtoast> thanks!
08:28:09 <centril> with stack ghci, after changing the dependencies in <xyz..>.cabal , how do I reload with these dependencies ?
08:28:19 <centril> so that I dont have to quit ghci first
08:28:39 <cocreature> centril: I don’t think you can.
08:28:44 <centril> cocreature: :/
08:29:01 <centril> cocreature: what about doing it with :!  ?
08:29:09 <centril> (to execute arbitrary shell commands)
08:29:18 <cocreature> I don’t see how that helps
08:29:22 <centril> crap
08:29:33 <cocreature> if you just added a package you might be able to get away with ":set -package packagename"
08:29:52 <cocreature> but I don’t know if you can remove packages this way
08:29:57 <centril> cocreature: ill try that - since it is mostly the cause
08:30:13 <centril> cocreature: i very rarely remove packages, it is mostly adding a package after a branching or something
08:30:24 <cocreature> you will also need to build the package, i.e., run "stack build" before you execute that
08:30:55 <centril> right, atm I just pop out of stack ghci and then reenter it
08:31:43 <centril> I guess I could alias an action to  1) stack build 2) :set -package <name>
08:44:50 <Athas> Is there a way for a Haskell program to ask the runtime never to use more than one thread for garbage collection?
08:44:56 <Athas> The overhead of parallel GC is pretty silly.
08:53:22 <c_wraith> Athas: yes, you can disable parallel gc
08:53:44 <Athas> c_wraith: how so?
08:53:59 <c_wraith> Some RTS option or another.
08:54:43 <c_wraith> looks like -qg turns off parallel gc
08:55:43 <Athas> Right, but I don't want to do this with an RTS option.  I want the program itself to disable parallel GC (without the user having to care about it).
08:55:51 <Athas> I guess I can modify the build flags, though.
08:55:59 <mauke> shell script wrapper
08:56:24 <chewzerita> Is there any way to make an Applicative instance of a tree? `data Tree a = Empty | Node a (Tree a) (Tree a)` I am following the learn you a haskell book, but I can't seem to figure this out
08:56:45 <c_wraith> chewzerita: you can!  What difficulty are you having?
08:56:58 <chewzerita> I'll show you what I have so far..
08:56:59 <Athas> I'm already using -with-rtsopts=-N, and I guess I can add -with-rtsopts=-qg to that.
08:57:19 <halogenandtoast> Which of these is more idiomatic?
08:57:26 <lpaste_> halogenandtoast pasted “Idiomatic.hs” at http://lpaste.net/353713
08:58:07 <chewzerita> @c_wraith I have the functor instance done: fmap _ Empty = Empty, fmap f (Node x a b) = Node (f x) (fmap f a) (fmap f b)
08:58:07 <lambdabot> Unknown command, try @list
08:58:10 <c_wraith> halogenandtoast: both are pretty common.  I don't think I'd prefer one over the other.
08:58:40 <c_wraith> chewzerita: can you put code on lpaste.net ?   It's much easier to read formatted there.
08:58:54 <chewzerita> @c_wraith sure, that sounds better
08:58:54 <lambdabot> Unknown command, try @list
08:59:05 <Welkin> chewzerita: don't prefix names with @ on IRC
08:59:09 <Welkin> just type the name alone
08:59:15 <Athas> Is there a way to share Ghc-Options between several Executable-targets in a .cabal file?
08:59:38 <Welkin> chewzerita: otherwise you will trigger lambdabot 
08:59:57 <halogenandtoast> c_wraith: thanks, not the answer I was hoping for, but an answer none the less.
09:00:40 <MarcelineVQ> it's good new though, if you were hoping for one specifically then you can just use that one
09:00:54 <spatial> IO (BoardState,IOArray Int Double)  How to get BoardState if return type is this ?
09:01:15 <spatial> Can I unwrap it ?
09:01:18 <Athas> spatial: pattern-matching.
09:01:22 <mauke> spatial: only locally
09:01:22 <chewzerita> c_wraith: http://lpaste.net/353714
09:01:27 <halogenandtoast> MarcelineVQ: I wasn't hoping for one in particular, I just wanted one to be preferential
09:01:36 <Athas> (the_boardstate, _) <- theComputationProducingThatPair
09:01:37 <mauke> spatial: do { (bs, _) <- stuff; ... }
09:02:11 <halogenandtoast> chewzerita: x a and b aren't the same types, so I assume you can't call the same f on them
09:02:30 <halogenandtoast> x is an a, but a and b are Tree a
09:02:44 <MarcelineVQ> Athas: possibly somewhere in new features, not that I know of though, some people use hpack for that https://github.com/sol/hpack#readme
09:03:04 <c_wraith> chewzerita: hah.  oops.  I was totally wrong.  There's no simple way to make that Applicative.  (I was thinking about Traversable for some reason.)
09:03:30 <c_wraith> chewzerita: The problem you're running into is that you have no guarantee the trees will be the same shape, and no obvious right thing to do when they aren't, right?
09:03:44 <chewzerita> c_wraith: that makes sense
09:04:05 <halogenandtoast> chewzerita: ignore me, I derped on fmap
09:04:11 <Athas> MarcelineVQ: thanks, looks like that's the most reasonable option.  I have seven executable targets by now and the hand-maintenance is getting to be a bit much...
09:05:06 <chewzerita> c_wraith: does that mean this tree is only a functor?
09:06:25 <c_wraith> chewzerita: Well, it's certainly a Functor.  I'm not 100% sure you *can't* create an Applicative instance, but it certainly isn't an obvious thing
09:07:08 <chewzerita> c_wraith: alright, thanks for the help. I'm having great fun learning this language
09:07:50 <c_wraith> chewzerita: actually, I *can* create an Applicative instance, kind of like the Applicative instance for ZipList - but it's weird and probably not something you'd want to use. :)
09:08:22 <c_wraith> chewzerita: I'll write it up quickly and you can see why I call it weird. :)
09:08:40 <mauke> it would be easier with a different type of tree
09:08:57 <mauke> data LTree a = Leaf a | Node (LTree a) (LTree a)
09:10:22 <halogenandtoast> mauke: doesn't that still need an Empty?
09:11:19 <mauke> does it?
09:11:27 <chewzerita> mauke: I acually had the same tree before. I did make an Applicative instance for it
09:12:02 <halogenandtoast> mauke: How would you represent a tree with no nodes or values?
09:12:12 <mauke> I wouldn't
09:12:26 <chewzerita> mauke: but it wasn't really a tree because the nodes didn't have values in them, only the leafs
09:12:33 <halogenandtoast> What about a tree with only a left, but no right?
09:12:38 <orion> I'm watching a video lecture series on category theory for Haskell programmers. The speaker said that all data are functions and all functions are data. How is a data type a function?
09:12:39 <mauke> halogenandtoast: nope
09:12:49 <halogenandtoast> mauke: I don't like your tree
09:12:49 <Welkin> orion: it's not
09:12:54 <mauke> orion: the speaker is wrong
09:13:03 <mauke> halogenandtoast: but it's a monad
09:13:25 <halogenandtoast> I've learned that not all things that are monads are useful, and not all things that are useful are monads
09:13:38 <orion> Oh wow
09:13:38 <MarcelineVQ> chewzerita: What section is this exercise in?
09:13:58 <c_wraith> chewzerita: http://lpaste.net/353716
09:14:17 <orion> Welkin / mauke: His name is Bartosz Milewski.
09:14:49 <c_wraith> chewzerita: the only reason that works is because pure creates an infinite tree
09:14:55 <c_wraith> chewzerita: which is a bit silly
09:15:40 <chewzerita> MarcelineVQ: http://learnyouahaskell.com/functors-applicative-functors-and-monoids http://learnyouahaskell.com/making-our-own-types-and-typeclasses#recursive-data-structures
09:15:50 <Welkin> orion: 1 is not a function
09:15:58 <halogenandtoast> c_wraith: you don't need to do that
09:16:00 <Welkin> orion: neither is "hello"
09:16:04 <chewzerita> MarcelineVQ: it shows up in two sections
09:16:08 <MarcelineVQ> chewzerita: thank you
09:16:19 <c_wraith> halogenandtoast: how else do you satisfy the applicative laws?
09:17:04 <jgt> is there a better way to write this function? http://sprunge.us/FSiP
09:17:06 <halogenandtoast> c_wraith: annotated, but I might be breaking a law
09:17:11 <jgt> I feel like that function shouldn't even exist
09:17:15 <halogenandtoast> if I am, I'm interested in which one.
09:17:18 <Welkin> jgt: lol sprunge? Use lpaste :D
09:17:21 <Welkin> @lpaste
09:17:21 <lambdabot> Haskell pastebin: http://lpaste.net/
09:17:22 <chewzerita> c_wraith: why did you do "let result = X in result" instead of just "X"
09:17:40 <halogenandtoast> jgt: you could use `either`
09:17:41 <c_wraith> halogenandtoast: your example breaks pure id <*> x = x
09:17:44 <jgt> Welkin: I have sprunge hooked up to my command line so I can just send it stuff from vim
09:17:49 <mauke> :t either (const []) id
09:17:51 <lambdabot> Either b [t] -> [t]
09:17:57 <jgt> halogenandtoast: I thought I could, but I'm not quite sure how
09:17:59 <jgt> ohhh…
09:18:01 <jgt> right
09:18:05 <c_wraith> chewzerita: because the expression X uses result internally
09:18:08 <halogenandtoast> everyoe forgets const
09:18:19 <mauke> :t either (pure []) id
09:18:21 <lambdabot> Either a [t] -> [t]
09:18:36 <chewzerita> c_wraith: that is what makes is infinite, I get it now
09:18:44 <jgt> thanks folks
09:18:53 <c_wraith> chewzerita: exactly
09:19:04 <mauke> :t either (pure (fail [])) ask
09:19:06 <lambdabot> Monad m => Either a (m a1) -> m a1
09:19:09 <halogenandtoast> c_wraith: thanks I'll try it out
09:19:41 <chewzerita> c_wraith: Thanks a ton!
09:19:52 <c_wraith> chewzerita: you're welcome.
09:21:19 <JoeyAdams> I've been largely out of the Haskell loop for a few years.  The Haskell website offers 3 options for installing (Minimal, Stack, or Platform).  Would Platform typically be recommended for people new to Haskell who want to learn, while Stack would be a better choice for more advanced users who already have projects with dependencies they want to maintain?
09:21:43 <orion> Welkin: https://youtu.be/EO86S2EZssc?t=47m18s <-- "The distinction between a function and a data type is weak."
09:22:00 <halogenandtoast> JoeyAdams: I'd suggest stack no matter what
09:22:06 <Theophane> JoeyAdams: I'm not an advanced user, but I think Stack is the best option
09:22:40 <bxc> stack is easy enough to start with and is going to put you in the right place when you want to level up
09:22:41 <halogenandtoast> But I'm a huge derp who doesn't get his applicative laws correct.
09:23:14 <orion> And at 48:38 he says, "So, data are really functions. Functions are really data. There really is no hard core distinction."
09:23:40 <orion> bxc: What would "leveling up" consist of?
09:24:48 <halogenandtoast> orion: That could be true in lamdba calculus right?
09:25:42 <orion> halogenandtoast: Except the speaker is talking about Haskell.
09:26:49 <cocreature> orion: I think haskell as a language has a hard distinction. something of type a -> b is a function, everything else is not
09:27:06 <cocreature> orion: he seems to be arguing that computationally data and functions are similar
09:27:17 <halogenandtoast> c_wraith: can you explain how that infinite expansion of pure works
09:27:23 <halogenandtoast> I can't seem to wrap my head around it
09:28:00 <c_wraith> halogenandtoast: it creates a Node whose child pointers point to itself.
09:28:10 <c_wraith> halogenandtoast: in memory, it actually is a circular structure.
09:29:02 <bxc> orion: starting to use the stuff that stack does well - mostly in my practical use that is fiddling with different library versions and having it rebuild right with one command
09:29:40 <c_wraith> halogenandtoast: so whenever you get one of the child values, you are actually getting the same value
09:30:17 <JoeyAdams> On Stackage, they have "snapshots" like this one: https://www.stackage.org/nightly-2017-03-19 .  Is it possible to download a manifest of the snapshot as a text file?
09:30:27 <c_wraith> halogenandtoast: the general approach is called knot-tying, if you want to look into it further.
09:30:29 <halogenandtoast> c_wraith: okay so `print $ (pure 1 :: Tree Int)` results in terribleness then
09:30:50 <c_wraith> halogenandtoast: well, it "works" in some sense.  How long *should* it take to print an infinite value? :)
09:31:00 <bxc> JoeyAdams: so that you can write your own bad implementation of stack? Someone had a tool on r/haskell recently that did something in that direction recently, but I can't remmeber offhand
09:31:09 <c_wraith> halogenandtoast: but yes, it will never finish printing it
09:32:13 <c_wraith> halogenandtoast: I need to run now.  Lots of people can help with knot-tying, though
09:32:20 <JoeyAdams> I was just curious, really.  Seeing a big yaml file of the whole snapshot would help me understand what exactly goes into a Stack "snapshot" (though I might be mixing up Stack and Stackage).
09:32:56 <halogenandtoast> c_wraith: no problem, thanks for the help
09:38:02 <erisco> ertes, there is way too much hype about undecidability
09:38:54 <erisco> oh it is undecidable, guess we have to do something else
09:39:30 <erisco> well no, you just can't have one program that solves everything
09:39:42 <erisco> that is just one exclusion in a sea of possibilities
09:40:55 <erisco> the real answer is, that is what we do as programmers all the time
09:41:10 <erisco> there is no one program to solve everything and so we have to take smaller programs and stick them together in new ways
09:41:45 <erisco> if automation was the only solution then fine, alright, but I don't think it usually is
09:42:02 <maerwald> in what context are you arguing?
09:42:19 <erisco> I am replying to what ertes said 14 hours ago
10:02:29 <mangobo> http://pastebin.com/dcRHhZc8 could someone help me with thw invariant for the while loop? i know it should hold for every iteration, but not sure which one would work for this function
10:03:16 <Welkin> mangobo: that isn't haskell
10:04:00 <halogenandtoast> Any good way to debug when I get crazy output with `Undefined symbols for architecture x86_64`
10:04:15 <Welkin> halogenandtoast: linker error
10:04:31 <Welkin> you probably need to include the libraries you are using with the -l flag
10:04:34 <Welkin> how are you bulding?
10:04:36 <Welkin> building*
10:04:40 <halogenandtoast> `stack build`
10:04:47 <Welkin> what does your build command look like?
10:04:48 <Athas> Hm, hpack seems really good.  Much nicer than Cabal.
10:04:57 <Theophane> mangobo: the hell is that language?
10:06:00 <halogenandtoast> Welkin: I'm not sure what you're asking for
10:06:12 <halogenandtoast> Do you mean this: `/Users/matthew-mongeau/.stack/setup-exe-cache/x86_64-osx/Cabal-simple_mPHDZzAJ_1.24.2.0_ghc-8.0.2 --builddir=.stack-work/dist/x86_64-osx/Cabal-1.24.2.0 build lib:battleline exe:battleline --ghc-options " -ddump-hi -ddump-to-file"`
10:06:14 <Welkin> halogenandtoast: the actual command that gets run `ghc ...`
10:06:30 <Welkin> I've encountered this issue before when compiling c with opengl/sdl
10:07:14 <Welkin> halogenandtoast: any external libs you are using?
10:07:28 <halogenandtoast> No just a lib I wrote in my project
10:07:58 <halogenandtoast> So I have a lib + exec stup
10:11:04 <halogenandtoast> Welkin: looks like I wasn't exporting a module
10:11:07 <halogenandtoast> womp womp
10:11:50 <Welkin> I was just going to ask if you included all of the files
10:11:50 <Welkin> lol
10:12:03 <Welkin> I know there is an actual way to debug this using `ld`
10:12:12 <Welkin> geekosaur showed me a while back when I ran into trouble
10:15:48 <bxc> i fairly regularly get linker problems with stack with an old lts (3.20) that are cleared away with a `stack clean`. I've never delved into what causes it though
10:16:09 <bxc> or rather it wasn't apparent in the ten mins or so I spent on it
10:30:41 <halogenandtoast> Is there something that already does this: `replace old new = map (\x -> if x == old then new else x)
10:38:46 <liste> @hoogle Eq a => a -> a -> [a] -> [a]
10:38:47 <lambdabot> Network.CGI.Protocol replace :: Eq a => a -> a -> [a] -> [a]
10:38:47 <lambdabot> Data.List.Utils replace :: Eq a => [a] -> [a] -> [a] -> [a]
10:38:47 <lambdabot> Data.String.Utils replace :: Eq a => [a] -> [a] -> [a] -> [a]
10:39:18 <liste> ^ halogenandtoast so apparently not in base
10:40:48 <halogenandtoast> Oh well
10:42:19 <michalrus> How can I force `hlint` to be run at each `stack build`? (:
10:42:47 <Gurkenglas> :t each . from (non ?old) %~ (<|> Just ?new)
10:42:48 <lambdabot> (?old::a, ?new::a, Eq a, Each s t a a) => s -> t
10:43:12 <michalrus> But just `stack build`, not `stack install hlint` (polluting global ~/.local/bin…) and `stack build --exec 'hlint src'`…
10:43:14 <bollu> :t from
10:43:16 <lambdabot> (Functor f, Profunctor p) => AnIso s t a b -> p t (f s) -> p b (f a)
10:43:21 <bollu> Gurkenglas: example use of "from"?
10:44:58 <Gurkenglas> How about a property? from (iso f g) == iso g f
10:46:40 <liste> michalrus: see "Static Analysis" here http://taylor.fausak.me/2014/03/04/haskeleton-a-haskell-project-skeleton/
10:46:50 <michalrus> liste: thank you!
10:47:09 <liste> michalrus: you're welcome
10:48:11 <lpaste_> halogenandtoast pasted “Update.hs” at http://lpaste.net/353719
10:48:15 <halogenandtoast> Any ideas on how to make that better ^^
10:48:21 <halogenandtoast> in particular I don't like the duplication in the case
10:55:33 <lyxia> halogenandtoast: first overwire the common fields in the where clause
10:56:20 <lpaste_> lyxia annotated “Update.hs” with “Update.hs (annotation)” at http://lpaste.net/353719#a353720
10:57:30 <halogenandtoast> lyxia: Right, not sure why I didn't think of that
10:57:33 <halogenandtoast> I plan tiredness
10:57:41 <halogenandtoast> s/plan/blame/
10:57:46 <halogenandtoast> O_o
10:57:55 <lyxia> I can see that :D
10:58:07 <halogenandtoast> In all fairness, it's 3am here.
11:19:11 <halogenandtoast> is there any way to combine this   let (cards, deck') = draw 7 deck; let (cards', deck'') = draw 7 deck'
11:19:22 <halogenandtoast> so that I get (cards, cards', deck'') as the result
11:19:45 <erisco> let ... in let ... in ...
11:19:58 <erisco> which simplifies to  let ... ... in ...
11:20:44 <halogenandtoast> Hmm I was hoping to do something super crazy like (,,) <$> draw 7 <*> draw 7 deck
11:20:47 <halogenandtoast> I know that doesn't work
11:20:55 <halogenandtoast> but that's the structure I was hoping for
11:21:47 <Rotaerk> halogenandtoast, if you treated it as State Deck T, you could do:  do { cards <- draw 7; cards' <- draw 7; ... }
11:21:49 <geekosaur> that pattern is closer to a state monad
11:22:17 <erisco> :t unfoldr
11:22:19 <lambdabot> (b -> Maybe (a, b)) -> b -> [a]
11:22:57 <halogenandtoast> hmm I've never use the state monad
11:23:04 <nshepperd> runState ((,,) <$> draw 7 <*> draw 7) deck
11:23:06 <halogenandtoast> I'd assume I'd need some function like `runDeck` then?
11:23:12 <halogenandtoast> runState
11:23:23 <erisco> well the state monad is not going to help much
11:24:07 <erisco> oh I misunderstood, the state is the deck, not the cards
11:24:49 <Rotaerk> also I should've said State Deck a; I used T like this was C# >_>
11:25:10 <halogenandtoast> Rotaerk: tis alright, I understood
11:27:43 <Rotaerk> draw would change from a Int -> Deck -> ([Card], Deck)  to a  Int -> State Deck [Card]
11:30:01 <erisco> then you want it to be SNat n -> Deck m -> (Deck (m :-: n), [Card])
11:30:10 <erisco> where are my manners
11:30:16 <erisco> then you want it to be SNat n -> Deck m -> (Deck (m :-: n), Vec n Card)
11:30:52 <halogenandtoast> O_o
11:31:19 <halogenandtoast> That quickly went from something I thought I could understand to something out of my league
11:31:41 <erisco> but then you realise you can't implement that because you forgot m >= n
11:32:10 <erisco> so you add n :<=: m to the parameters
11:33:22 <erisco> halogenandtoast, it adds how many cards are in the deck and how many you draw to the types
11:35:21 <halogenandtoast> erisco: that sounds awesome, and I really want to get to the point where I understand that, but I don't think I understand enough to make runState ((,,) <$> draw 7 <*> draw 7) deck work
11:35:31 <halogenandtoast> pending it's even possible to make that work
11:35:37 <erisco> I was joking
11:35:57 <erisco> you can do it, but I wouldn't consider it practical, not in Haskell anyways
11:38:20 <robertkennedy> @hoogle Int -> [Bool]
11:38:20 <lambdabot> Music.Theory.Bjorklund iseq :: [Bool] -> [Int]
11:38:20 <lambdabot> Data.List.HT lengthAtLeast :: Int -> [a] -> Bool
11:38:20 <lambdabot> Data.Edison.Seq.ListSeq inBounds :: Int -> [a] -> Bool
11:41:30 <erisco> hm, that's not even everything you'd want to say either
11:41:37 <erisco> you want to also have that the drawn cards come from the deck
11:49:55 <halogenandtoast> erisco: You can do it! Show me your types!
11:50:21 <erisco> uh, well you need singleton lists
11:50:44 <halogenandtoast> *sigh* how do I get this line to compile!   let (cards, cards', deck'') = runState ((,,) <$> draw 7 <*> draw 7) deck
11:51:01 <halogenandtoast> Couldn't match expected type ‘(t2, t1, t)’ with actual type ‘(c0 -> ([Card], [Card], c0), Deck)’
11:51:15 <halogenandtoast> I'm not even sure how to read that error
11:51:41 <erisco> the pattern on the left has type (t2, t1, t)
11:51:55 <Welkin> it expects a tuple
11:51:55 <erisco> the thing on the right has type (c0 -> ([Card], [Card], c0), Deck)
11:51:59 <Welkin> you have a tripple, to start
11:52:04 <Welkin> triple*
11:52:12 <Rotaerk> try:  let (cards, cards') = runState ((,) <$> draw 7 <*> draw 7) deck
11:52:20 <erisco> tuples are not just pairs
11:52:21 <Rotaerk> err
11:52:26 <bollu> erisco: ?
11:52:30 <Rotaerk> let ((cards, cards'), deck') = ...
11:52:37 <erisco> (,,) constructs a tuple
11:52:45 <erisco> they are 2-tuples, 3-tuples, and so on
11:53:01 <Rotaerk> it's the wrong tuple; it should be (,) since he's only collecting two sets of cards
11:53:17 <erisco> yes, it is, I am just rectifying the terminology
11:53:27 <Rotaerk> k
11:54:00 <halogenandtoast> Rotaerk: yes after fixing (,) and the left hand side it works, now I guess I should pay attention to how to read that error
11:54:19 <halogenandtoast> erisco: right, I'm aware of n-tuples
11:54:49 <halogenandtoast> okay yup
11:54:52 <halogenandtoast> I can read it now
11:55:59 <dmwit_> robertkennedy: Possibly:
11:56:02 <dmwit_> :t showIntAtBase
11:56:04 <lambdabot> (Show a, Integral a) => a -> (Int -> Char) -> a -> ShowS
11:56:17 <dmwit> robertkennedy: But it depends on what you want that function to do, really.
11:56:26 <halogenandtoast> so holy crap, I've used the State monad and it works, (and by works I mean it compiles)
11:56:34 <dmwit> robertkennedy: Or you might like the `Bits` instance for `Int`.
11:56:48 <halogenandtoast> and it actually works
11:56:50 <halogenandtoast> what a lovely day
11:57:31 <halogenandtoast> thans Rotaerk, erisco, Welkin, and others
11:57:40 <halogenandtoast> *thanks
11:57:51 <Rotaerk> np
11:59:15 <halogenandtoast> okay it's 4am, I should probably sleep since that's something humans need to do usually
12:00:13 <Rotaerk> you mean you don't get sufficient rejuvenation from using haskell?
12:00:23 <halogenandtoast> Apparently not
12:00:38 <halogenandtoast> I'm so tired I feel like I'm slightly drunk without having drank.
12:02:37 <Jello_Raptor> I am an idiot >_< I keep on using `flip mapM` as an idiom in my code and had no idea `forM` existed
12:02:54 <lyxia> for is even shorter
12:03:12 <monochrom> To be fair, forM requires one more import.
12:04:10 <bollu> lyxia: for gives applicative power right, forM is monadic?
12:04:18 <monochrom> @type for
12:04:20 <lambdabot> (Applicative f, Traversable t) => t a -> (a -> f b) -> f (t b)
12:04:27 <monochrom> yeah
12:05:04 <Jello_Raptor> but the monad constraint is an artifical restriction 
12:05:11 <monochrom> forM doesn't need all of monadic power.
12:05:34 <Tuplanolla> Does `ApplicativeDo` work yet?
12:06:23 <lyxia> It does work
12:07:58 <Jello_Raptor> oh it's in GHC 8 now 
12:08:04 * Jello_Raptor goes to turn it on in his cabal files 
12:08:46 <Tuplanolla> I ask, because when it was introduced a simple use of `$` broke it.
12:09:05 <Jello_Raptor> mmm? 
12:09:05 <lyxia> okay well this is still "broken"
12:09:21 * Jello_Raptor comments out those lines 
12:09:25 <Jello_Raptor> how is it broken? 
12:09:34 <centril> For a record data type for which Show is derived, is it possible to get an alternate function (to show) which yields a result as-if the data type were not a record ?
12:09:36 <Jello_Raptor> or more accurately how does "$" break it? 
12:09:45 <centril> and by get i mean: i dont want to write it myself
12:10:06 <lyxia> so to use applicative your program must look like this do { a <- stuff ; b <- stuff ; return (f a b) }
12:10:30 <lyxia> Jello_Raptor: but if you write return $ f a b instead it doesn't desugar the way you expect it to
12:10:42 <Jello_Raptor> ahh :/ 
12:10:43 <Tuplanolla> :t \ m -> do {x <- m; pure $ x} -- So this was inferred as not applicative, Jello_Raptor.
12:10:44 <lambdabot> Monad m => m b -> m b
12:10:54 <centril> I always avoid using return
12:11:10 <mohsen_> Hi. I define 3 functions as : let f 0 = "zero" , let f 1 = "one", let f x = "unknown"
12:11:12 <Welkin> why?
12:11:19 <mohsen_> But whatever I input I get unknown
12:11:37 <mohsen_> No matter if I use _ instead of x
12:11:41 <Welkin> mohsen_: you are writing it wrong
12:11:41 <centril> Welkin: pure is both shorter, to the point and relaxes constraints
12:11:48 <lyxia> it's a pretty minor annoyance though.
12:12:14 <Tuplanolla> How so, lyxia? It fails for other such combinators too.
12:12:16 <Welkin> > let f 0 = "zero"; f 1 = "one"; f x = "unknown" in f 0
12:12:18 <lambdabot>  "zero"
12:13:28 <mohsen_> Why doesn't it work that way in ghci?
12:13:50 <Welkin> mohsen_: it does
12:13:58 <Welkin> let creates a temporary binding
12:14:02 <barrucadu> I find how heavily ApplicativeDo is based on your code being of a certain form pretty unsatisfactory, but I have no idea how hard doing it "properly" (so that any do-block which could be Applicative is) would be
12:14:08 <Welkin> if oyu want to define a function, write it in a file the proper way
12:14:25 <Welkin> and use `:load` to load the file in ghci
12:14:28 <orion> If I have a function f :: Int -> Bool, for all intents and purposes, could I consider f to be a functor from the "Int" category (where each integer is an object) to the Bool category (where True and False are objects)?
12:14:56 <Athas> Has anyone here switched from .cabal files to package.yaml, and what were your experiences?
12:15:01 <mohsen_> Welkin: You mean when I define a function using let in ghci, then I define the same function again with a different pattern, always the last one is known? 
12:15:09 <orion> Athas: Yes, many times, and it's worth it.
12:15:14 <centril> Athas: package.yaml ?
12:15:18 <orion> centril: hpack
12:15:23 <barrucadu> orion: That could be the object function of a functor, but functors also map morphisms.
12:15:32 <Athas> orion: that was also my impression, but nothing's ever so painless in packaging, so now I'm wondering what I missed!
12:15:45 <barrucadu> So you'd also need a function :: (Int -> Int) -> (Bool -> Bool), which preserved id and composition
12:15:51 <centril> oh cool
12:15:52 <Athas> centril: from hpack.  It's another format for describing Haskell packages.  In essence, it's a .cabal file generator.
12:16:00 <centril> i dislike .yaml tho
12:16:11 <Athas> Yeah, .yaml isn't my favourite either.  But it's better than .cabal!
12:16:19 <centril> Athas: yeah, thats true
12:16:25 <Athas> I'm willing to accept the colour of this bikeshed, because at least it does not leak.
12:16:51 <centril> Athas: do i have to have both stack.yaml and package.yaml then ?
12:16:57 <Welkin> Athas: "what colour is your bikeshed", the best-selling novel by Athas
12:16:57 <orion> centril: Yes.
12:17:00 <mohsen_> Welkin: Nevermind got my answer, thanks.
12:17:25 <centril> Welkin: is it about Wadler's Law ?
12:17:50 <centril> https://wiki.haskell.org/Wadler%27s_Law
12:17:56 <lyxia> Tuplanolla: Doesn't return (...) look just fine
12:17:58 <orion> barrucadu: What if in the source category ("Int") I had no morphisms between distinct objects? I only had the identity morphism.
12:19:02 <barrucadu> orion: Then I guess you could say that the arrow function of the funtor is implicit and just use `id`, but my category-fu is pretty weak so I don't know if that argument actually holds up
12:20:06 <centril> so I can always write  prettify :: String -> String ; prettify str = case parseExp str of ParseOk r -> prettyPrint res ; ParseFailed {} -> str        --- which at least gives me indented records when used
12:20:12 <centril> but it still has the record names...
12:20:16 <centril> how do I get rid of them ?
12:20:39 <Welkin> centril: write your own pretty printer?
12:20:56 <Welkin> there may be an option somewhere
12:21:18 <centril> Welkin: well, I'm short on time
12:21:46 <Welkin> why would you want to get rid of the field names?
12:21:54 <Welkin> how would you know what data you are looking at?
12:22:06 <centril> Welkin: because: verbose output when debugging
12:22:31 <centril> I just want to show a record data type as a plain data type
12:22:41 <centril> + indentation would be nice
12:23:01 <Welkin> centril: writing your own functions would be easy
12:23:18 <Welkin> throw together a parsec parser that operates on the output of "Show"
12:23:52 <Welkin> just remove everything after a comma and before a colon
12:24:16 <centril> Welkin: that simple ?
12:24:34 <centril> well, I guess I have to watch out for strings as well
12:24:38 <Welkin> it might be a little more work than that
12:24:41 <Welkin> but that's the basic idea
12:25:05 <Welkin> or you could operate on the pretty printer output instead
12:25:28 <centril> Welkin: indentation I know how to fix
12:25:46 <centril> Welkin: there isn't any existing package for this?
12:26:25 <Welkin> centril: there are lots of pretty printers
12:26:29 <Welkin> some may have options
12:26:47 <centril> Welkin: right - the one I know of is haskell-src
12:27:00 <centril> maybe you can point me in the right direction?
12:27:56 <joneshf-laptop> Didn't there used to be an `intercalate` or `intersperse` in `Data.Foldable`?
12:28:40 <centril> joneshf-laptop: Data.List
12:28:44 <centril> :h intercalate
12:29:36 <Welkin> intercalate *and* intersperse
12:29:42 <joneshf-laptop> So there wasn't one that only needed `Foldable f` not specifically list?
12:30:06 <help2103980> hello kind people
12:30:11 <help2103980> may I ask a question?
12:30:15 <help2103980> very basic one
12:30:27 <help2103980> since I just started today
12:30:29 <joneshf-laptop> Oh no, I'm thinking of PureScript.
12:30:30 <centril> joneshf-laptop: what does intersperse mean for an arbitrary Foldable ?
12:30:30 <joneshf-laptop> Sorry.
12:30:36 <centril> and not just lists
12:30:47 <centril> help2103980: shoot
12:30:55 <joneshf-laptop> centril, I never know which one is which, between `intercalate` and `intersperse`.
12:30:59 <help2103980> thanks @centril 
12:31:18 <help2103980> so I have a list like so [1,1,1,1]
12:31:19 <Welkin> help2103980: no @ prefix
12:31:39 <centril> joneshf-laptop: intercalate = concat . intersperse
12:31:43 <help2103980> i just want to increase the first value by one, the second by two, and so on
12:31:56 <help2103980> to obtain [2,3,4,5]
12:31:59 <dmwit> > zipWith (+) [1..] [1,1,1,1]
12:32:02 <lambdabot>  [2,3,4,5]
12:32:04 <Welkin> > zipWith (+) [1,1,1,1] [1..]
12:32:06 <Welkin> lol
12:32:06 <lambdabot>  [2,3,4,5]
12:32:10 <help2103980> lol
12:32:19 <help2103980> you people rock
12:32:22 <centril> Welkin: dude, lazy language
12:32:31 <centril> duuuude
12:32:31 <joneshf-laptop> centril, well you can definitely `intercalate` for an arbitrary `Foldable f`: https://pursuit.purescript.org/packages/purescript-foldable-traversable/2.2.0/docs/Data.Foldable#v:intercalate
12:32:56 <help2103980> I'll go and read about zipWith
12:32:59 <help2103980> thanks mates
12:33:39 <joneshf-laptop> centril, I just mixed up the languages, no worries!
12:34:19 <centril> joneshf-laptop: right, using a monoid
12:34:27 <centril> you could also use join perhaps
12:34:39 <centril> depending on semantics
12:35:39 <centril> help2103980: note: with zipWith [1..] xs    where xs is a list, zipWith uses as many elements from [1..] as xs has
12:35:51 <centril> since it is a lazy infinite list
12:35:58 <centril> but:
12:36:18 <centril> > zipWith (+) [1, 2] [3]
12:36:20 <lambdabot>  [4]
12:37:29 <centril> help2103980: the length of the resulting list will be:  min(length(first), length(second))
12:37:53 <dmwit> > let sum = head . zipWith (+) [18] in sum [1,5,10,3]
12:37:55 <lambdabot>  19
12:38:15 <dmwit> > 1 + 5 + 10 + 3
12:38:17 <lambdabot>  19
12:38:21 <Guest_> Debating implementing a Pymol clone in Haskell as a long term project.
12:39:58 <dylukes> One of the biggest issues I have with Pymol is the inability to go through a series of edits. 
12:40:13 <dylukes> Does anyone have any suggested reading on persistent data structures with history?
12:41:44 <dylukes> Naive approach would be to just keep a list of states but, wondering if there's any interesting reading on better approaches.
12:42:12 <Rembane> dylukes: How are you going to use the data structure?
12:42:37 <dylukes> It's mostly a lot of settings, as well as some state which is used to generate a scene graph.
12:43:12 <Rembane> So you will always iterate through the whole data structure?
12:43:35 <dylukes> I'd like to update parts of the scene when their related parts of the underlying descriptive state change only when necessary, but yes, I'd probably just opt out early of the parts that don't need to be looked at.
12:44:10 <dylukes> There may be more than one renderer also. 
12:44:15 <dylukes> But that should be a distinct concern. 
12:45:06 <Rembane> I'd say, go for a list until things become slow.
12:45:20 <help2103980> I'm sorry people, but maybe my case is something else. I actually need to turn [[1,1,1],[1,1,1]] into [[2,2,2],[3,3,3]] 
12:45:42 <ph88^> hi help2103980 
12:45:43 <help2103980> adding 1 to every element of the first list and adding 2 to every element of the second list
12:45:57 <help2103980> hi ph88^ 
12:46:05 <dylukes> Rembane I was thinking something like having ReaderT for accessing that state, 
12:46:06 <ph88^> seems like you are not adding, but changing
12:46:11 <dmwit> help2103980: Use `map` in addition to `zipWith`, then.
12:46:21 <dmwit> help2103980: I encourage you to give it a shot before folks here give spoilers.
12:46:26 <dylukes> and just having an "markUndoPoint" function that stores a continuation in the state (session, really).
12:46:29 <dmwit> Show us what you tried and we can help you understand the error messages. ;-)
12:46:48 <dylukes> So then undo would be in a very literal sense rolling back the program, which would make things a bit easier.
12:46:52 <help2103980> yep dylukes
12:46:58 <orion> In this article: https://en.wikiversity.org/wiki/Introduction_to_Category_Theory/Monoids#Monoids they say, "For every pair of arrows f,g in M, the composition g .∘f of arrows is also in M" What does it mean to be *in* M? M is an abstract categorical object. How could there ever be any notion of "in"?
12:47:04 <Rembane> dylukes: Do you have a lot of functions accessing the state, so it becomes cumbersome to send it explicitly in an argument?
12:47:12 <dylukes> What do you mean?
12:47:13 <help2103980> I'm aware of map, which I was using in Python as well
12:47:21 <dylukes> Well, maybe.
12:47:41 <dylukes> I would probably just use ReaderT off the bat because I prefer a descriptive transformer stack to a lot of parameters. 
12:47:44 <help2103980> but my problem was exactly storing the iteration state
12:47:57 <dmwit> orion: Without looking: presumably M is an object in the category, and "in M" means the arrow has type M -> M.
12:48:02 <dmwit> orion: Now I will look at the link.
12:48:27 <Rembane> dylukes: You could build yourself a transformer stack if that does what you want. I'd go for the naive approach until it's too slow or I got tired of threading arguments.
12:48:40 <dylukes> I could just mix ReaderT and ContT and add extra "undo" and "redo" functions.
12:48:44 <dmwit> orion: Yes, that is what they mean.
12:48:47 <dylukes> I have a feeling it's going to get slow very quickly :).
12:48:47 <tomboy64> i have a [[Int]] and i need to find the first repetition of [Int], meaning i need both indices. how would i accomplish this the smartest way?
12:48:51 <dylukes> Er, not slow.
12:48:57 <dylukes> It's going to get frustrating to thread arguments quickly.
12:49:10 <tomboy64> my current algorithm is currently working with iterate and getting big quickly.
12:49:11 <help2103980> ok folks, I'll try mixing map and zipWith
12:49:16 <dmwit> orion: Additionally, the associativity/identity laws come "for free" just by M being an object in a category.
12:49:26 <help2103980> hope to solve it, thanks for now
12:49:49 <dmwit> orion: ...as does the first property that arrows are closed under composition, in fact.
12:50:03 <dmwit> orion: I don't like this intro. It's very sloppy.
12:50:06 <orion> dmwit: But isn't an arrow from M -> M just the identity morphism?
12:50:21 <dmwit> orion: No, there can be many non-identity morphisms with that type.
12:50:52 <orion> But isn't the arrow originating at M and looping back to M?
12:51:05 <dmwit> orion: e.g. in the category of sets as objects and functions as arrows, the set {0, 1} has the arrow {(0,1), (1,0)} as a non-identity endomorphism.
12:51:28 <dmwit> orion: (Or in Haskell notation, this is `Bool` with `not`.)
12:51:45 <dmwit> ?quickcheck \x -> not x == id x -- no way!
12:51:45 <lambdabot> Unknown command, try @list
12:51:55 <dmwit> ?check \x -> not x == id x -- no way!
12:51:57 <lambdabot>  <hint>:1:53: error:
12:51:57 <lambdabot>  parse error (possibly incorrect indentation or mismatched brackets)
12:52:07 <dmwit> ...huh
12:52:34 <dmwit> I guess it doesn't like comments.
12:52:35 <dylukes> undo m = do { cont ← some lenses to get continuation; local (id cont) m }
12:52:38 <dylukes> Rembane
12:52:43 <dylukes> in theory very simple.
12:53:13 <dylukes> Having a usable stack would be more helpful though.
12:53:19 <orion> dmwit: Yes, I realize that (not x) is not the same as (id x). But if I drew this pictorally, I would see a dot labeled M and an arrow originating at M and looping back to M.
12:53:20 <dylukes> Also for a history panel.
12:53:35 <dmwit> orion: What is "this" in that sentence?
12:53:36 <dylukes> (I could also then store some descriptive information about the change.)
12:53:40 <dylukes> (Explicit > Implicit)
12:54:34 <orion> dmwit: If I drew a picture of the "not" morphism and the "id" morphism on M.
12:54:37 <Rembane> dylukes: Seems like a working solution.
12:54:55 <orion> dmwit: Visually, they would be indistinguishable.
12:55:03 <dmwit> orion: I don't think that's what you would see. I think you would see a dot labeled M and *two* arrows originating at M and looping back to M.
12:55:22 <orion> dmwit: err, yes. There would be two, and the labels would be interchangable.
12:55:28 <dmwit> One arrow would be labeled `id` and the other arrow would be labeled `not`.
12:55:34 <dmwit> Why would the labels be interchangeable?
12:55:46 <orion> Because they both start at M and and at M.
12:55:50 <dmwit> So what?
12:55:58 <orion> So the labels are interchangable.
12:56:00 <dmwit> No.
12:56:22 <dmwit> Or: what does "interchangeable" mean?
12:56:57 <orion> It means that if I drew it on a whiteboard, I could erase both "id" and "not", and write "not" where "id" was and "id" where "not" was and still be correct/valid.
12:57:00 <help2103980> ph88^, may I send you a private message, so I won't flood the main discussion?
12:57:13 <dmwit> orion: Okay. What do you conclude from that?
12:58:08 <orion> dmwit: That without knowing the "implementation details" of the category (that we're talking about Hask), there's nothing more I can say.
12:58:20 <Welkin> `id` is literally the identity function
12:58:44 <dmwit> orion: Okay. I admit I'm a bit lost. Do you now understand the text at the link, or is there still a question? If so, what is the question?
12:59:30 <orion> dmwit: I am trying to grok category theory, and I think I am just verbally spewing thoughts as they enter my head without any filter.
12:59:49 <orion> So, I don't think there are any more questions at this time. Thank you. :)
13:01:07 <nshepperd_> orion: but a category isn't just a directed graph, it also has properties like the result of composition of arrows
13:01:22 <nshepperd_> That lets you distinguish not and id
13:01:47 <ph88^> help2103980, sure
13:01:49 <nshepperd_> because not . id = not
13:04:32 <nshepperd_> I guess you draw things like that as diagrams
13:04:50 <orion> nshepperd_: Is it true that without knowing the "semantics" of the category involved, it's impossible to come to any useful conclusions about a given diagram?
13:04:59 <dmwit> Yes, if you drew the diagram orion described, a CT expert would probably be confused because that diagram does not commute. =P
13:05:12 <nshepperd_> Like a triangle diagram with not on two sides and id on the other
13:05:17 <centril> Welkin: so I found  hscolour (Language.Haskell.HsColour)  and  pretty-simple (Text.Pretty.Simple)  for pretty printing  expressions with indentation and colour... any preference ? (anyone else is free to answer)
13:05:22 <nshepperd_> Or something, i dunno
13:05:59 <dmwit> orion: I think you have painted yourself into a corner. Probably the answer to that question will be "you are about to define semantics as being the information you need to know to draw conclusions about a given diagram".
13:06:08 <orion> ha
13:06:12 <orion> You might be right.
13:09:22 <nshepperd_> orion: I'm not sure what that means. A category consists of (1) some objects (2) some arrows, including an identity arrow for each object and (3) an associative composition operator that respects the identities
13:09:54 <nshepperd_> The composition properties are an essential part of the category. Not anything extra
13:09:56 <implementation> does someone know more details about "brkPrefix" and "brkSuffix" in text-icu (haddocks just say "Prefix of the current break.")? what can I assume about their results? how do they differ from brkBreak and how long is the prefix/suffix?
13:12:45 <dmwit> Have you tried looking at the source?
13:18:28 <knupfer> Are there plans to provide string operations for Symbol?
13:19:06 <dmwit> Let  me say that another, less passive-aggressive way (sorry about that). I don't know the answer, and it's possible that nobody who's hanging around does either. It might be time to check the source and try to work it out from first principles.
13:19:40 <knupfer> ?
13:19:54 <dmwit> knupfer: That was aimed at implementation, not you. =P
13:19:59 <dmwit> You just happened to step into the crossfire.
13:20:31 <knupfer> Ah ok :)
13:20:54 <knupfer> I'm trying to write a parsing lib which defines it's grammar on the typelevel
13:21:08 <knupfer> so it's inspectable and optimizable at compiletime
13:26:36 <mpiechotka> @pl \(a, b) -> ((flip (,) b) +++ (flip (,) b)) a
13:26:36 <lambdabot> uncurry (flip (ap ((+++) . flip (,)) (flip (,))))
13:27:04 <erisco> :t (+++)
13:27:06 <lambdabot> ArrowChoice a => a b c -> a b' c' -> a (Either b b') (Either c c')
13:33:22 <orion> dmwit / nshepperd_: If (g . f) != (f . g) does that mean that, by definition, f and g are not isomorphic?
13:33:44 <orion> Conversely, if (g . f) != (f . g), does that mean that f and g are, always and forever, isomorphic?
13:33:52 <orion> s/!=/==
13:33:53 <laudiacay> / 5
13:34:06 <monochrom> knupfer: While I can feel that type-level something will help, I doubt that it is going to be type-level string. If anything it ought to be type-level tree or something.
13:35:13 <ph88^> hi guys, i'm trying to combine 2 functions see line 67 at https://bpaste.net/show/32a57e8e2a6a but i get an error which i don't understand, can someone help me a little bit and give some advice about this ?
13:36:33 <c_wraith> ph88^, that just is telling you that you haven't enabled either of the extensions that enable ~ constraints 
13:36:44 <dmwit> orion: isomorphism is a statement about objects, not arrows
13:38:15 <erisco> mpiechotka, uncurry (flip ((+++) <$> flip (,) <*> flip (,)))
13:38:46 <erisco> I thought  uncurry (flip (join (+++) . flip (,)))  at first but this is a subtle trap
13:38:56 <orion> dmwit: Ah.
13:39:09 <orion> Yes, very true. That resolves it, thanks.
13:40:28 <mpiechotka> erisco: Thanks
13:42:29 <erisco> this time @pl was just about there. only needed some name changes
13:55:06 <ph88_> c_wraith, ah yes you are right, when i try it in ghci it works https://bpaste.net/show/d8ca13d7f50e  however the infered type is rather complicated, and i'm not sure what i should put in my source file
14:07:36 <wing22> hi, anyone have tried any gui work in haskell
14:08:44 <ph88_> hi wing22 
14:09:03 <ph88_> wing22, how would you feel using electron for gui ?
14:09:31 <ph88_> c_wraith, i updated that paste a little bit to make things more clear, i'm trying to find the right type to put in my file but the type expansion confuses me  https://bpaste.net/show/fc2411004aaf
14:10:04 <ph88_> that is the infered type is not enough and i have to put a type signature on that function, but i don't know what it should be
14:10:20 <wing22> atom electorn ? nay, i'm running away from js
14:11:21 <ph88_> wing22, any toolkit you have in mind ? or you want to do native OS api ?
14:12:05 <ph88_> wing22, there are a lot of languages that compile to javascript, do you don't have to write JS. For example you can do haskell + electron and purescript .. seems like an excellent combo to me
14:14:15 <ph88_> wing22, maybe this helps https://wiki.haskell.org/Applications_and_libraries/GUI_libraries
14:15:46 <wing22> acutully i have simple gui written in F# and I want to port it
14:17:00 <ph88_> sounds like a nice project :)
14:17:21 <ph88_> wing22, just for my own curiosity .. how did you like F# and why are you porting the app ?
14:18:41 <wing22> f# good, haskell better :) *** as language only ***
14:18:56 <ph88_> i have to go, be back later
14:19:12 <wing22> thank you ph88_
14:20:39 <centril> has anyone used the  pretty-simple  package ? (Text.Pretty.Simple)
14:21:01 <centril> it's supposed to colourize the stuff, but it is not - at least not in my terminal
14:21:38 <centril> it says "ANSI escape codes" tho, so it should work
14:27:49 <lyxia> centril: I can see colors
14:28:12 <lyxia> centril: my strings are blue
14:28:29 <centril> lyxia: weird... hscolour manages to print with colour for me tho
14:28:40 <centril> using: Language.Haskell.HsColour.TTY
14:29:27 <centril> lyxia: my terminal is cmd.exe (windows)
14:29:38 <deech> Hi all, had a question about GHC's garbage collection. By default does GHC only start cleaning up once the heap has reached a certain size or is it always by time?
14:30:03 <shanemikel> Ryan Trinkle did an amazing job packaging his reflex-platform with Nix.  I really wish projects like GHCJS had more folks working on usability points like this...
14:44:05 <ddellacosta> I have a feeling someone on here knows the answer to this: where can I go to read about the provenance of this usage of "morally correct?" http://www.cse.chalmers.se/~nad/publications/danielsson-et-al-popl2006.html
14:45:14 <ddellacosta> I often see this usage in PLT discussions, but I don't have any significant math or philosophy background that would help me effectively understand this usage
14:45:15 <davean> ddellacosta: fast and lose reasoning, its a paper
14:45:30 <geekosaur> deech, both. More precisely, a gc is done during the next allocation if the heap (or nursery, for minor gc) is overfull, or if the timer has gone off
14:45:51 <davean> ddellacosta: oh, you already see that paper
14:46:04 <davean> ddellacosta: "morally" isn't a technical thing persay
14:46:08 <ddellacosta> davean: are you saying the paper I linked to is exactly the origin of the usage of "morally correct" in PLT discussions?
14:46:09 <geekosaur> ddellacosta, I think the whole title is deliberately informal and a bit over the top
14:46:21 <ddellacosta> geekosaur, davean, that's helpful
14:46:41 <ddellacosta> I thought that perhaps there was a precise meaning when used in a compsci/math/type theory context that I was missing entirely
14:46:44 <geekosaur> and it wouldn't surprise me if that paper indeed introduced the usage. Not all mathematics or CS is stuffy academics
14:47:12 <ddellacosta> oh sure, it's more just that I'm ignorant enough that I don't know when I've encountered an informal term or something in the lexicon
14:47:16 <geekosaur> (cf. "generalized abstract nonsense" for CT)
14:47:21 <ddellacosta> right, gotcha
14:48:12 <davean> geekosaur: Sometimes we call generalized abstract nonsense catagory theory but thats just when we get tired of such a long name
14:48:22 <geekosaur> :)
14:48:28 <ddellacosta> ha
14:49:30 <davean> ddellacosta: If you read that paper, I think you'll get a sense of the usage though
14:49:57 <ddellacosta> davean: I'll give it a shot! Thanks so much to you and geekosaur for the help, that clarified things a lot
14:50:21 <Phyx-> centril: I assume you're on Windows 10 then? or have something like ANSICON installed?
14:51:19 <deech> geekosaur: So should I worry that my app's RAM usage went from 11 -> 40 MB over the course of 3-4 minutes of usage?
14:52:03 <geekosaur> deech, that suggests to me you are having too much stuff held active, not a problem with gc but a problem with letting stuff be eligible for gc
14:52:14 <geekosaur> excessive sharing can cause itg
14:52:32 <davean> deech: link to your app's code?
14:53:16 <c_wraith> It's also worth noting whether the usage keeps growing.  It's possible that there's some shared structure that isn't fully evaluated at first, but does have a finite maximum size
14:55:11 <deech> davean: It's https://github.com/deech/fltkhs-fluid-demos/blob/master/src/Tree.fl which gets pre-processed into Haskell. It's not ideal for reproducing since it also uses a C++ library.
14:55:43 <deech> geekosaur: Do you mean there are too many object in scope?
14:56:11 <c_wraith> deech: well, held by (potentially-unevaluated) objects in scope
14:56:18 <geekosaur> ^
14:56:40 * geekosaur was writing that but c_wraith got there first...
14:56:56 <c_wraith> I got there first despite airplane lag? :)
14:57:09 <davean> deech: I was hoping it was small and Haskelly enough I could review its sharing and strictness and other properties efficiently, but I see it is not :)
14:58:07 * geekosaur is trying to multitask
14:58:17 <geekosaur> being short on sleep, this is a bit slower than usual
14:58:43 <c_wraith> deech: if there's FFI involved, you could also have a real, old-fashioned memory leak in the allocations it does.  Or on the native side.
14:59:48 <deech> davean: Thanks for offering, though!
15:15:29 <centril> Phyx-: yes, win10
16:13:32 <orion> Are all co-products algebraic sum types?
16:14:21 <Koterpillar> Up to isomorphism
16:19:48 <orion> Great, thanks.
16:56:37 <clmg> Is there any way to ignore a maybe value with a lens?
16:57:03 <clmg> I want to say `if a^.b^.c then foo`
16:57:20 <clmg> but a b and c are all maybes
16:57:36 <clmg> I want the case in which they are Just
16:57:41 <clmg> otherwise do nothing
16:58:06 <lyxia> what is foo
16:58:18 <clmg> operation in c
16:58:18 <clmg>  
16:58:20 <clmg> on*
16:58:33 <benzrf> clmg: perhaps you want _Just
16:58:34 <dolio> b and c are Maybe (Lens ...)?
16:59:06 <clmg> but I'd need so many nester case statements case a of Just ... case b of Just...
16:59:27 <benzrf> what are the types precisely
16:59:46 <clmg> custom data types
17:00:27 <benzrf> but what are the types of a b c
17:00:48 <clmg> Split, Split and Window
17:01:16 <clmg> I'm looking for a split where its left window name == "ident"
17:01:17 <benzrf> then how are you using them with (^.)
17:01:37 <clmg> benzrf: they are lenses I suppose
17:01:58 <c_wraith> clmg: to "ignore" a Maybe, you need to accept the fact that there can be no target.  at that point, you aren't working with lenses anymore.  Traversals, perhaps.
17:02:10 <clmg> c_wraith: I'm doing a traversal already
17:02:16 <benzrf> clmg: wait, so are they lenses or are they Splits
17:02:20 <clmg> I'm traversing over splits
17:02:22 <c_wraith> clmg: in which case, ^. is the wrong operator
17:02:38 <clmg> c_wraith: which other operator?
17:02:41 <c_wraith> clmg: You'd want ^? or ^..
17:04:30 <benzrf> clmg: wait, so are they lenses or are they Splits
17:05:48 <sphinxo> How would this be best written in haskell? "for item in items: if someFn(item): return True"
17:06:01 <clmg> benzrf: they must be lenses
17:06:08 <c_wraith> sphinxo: any someFn items
17:06:11 <c_wraith> :t any
17:06:12 <lambdabot> Foldable t => (a -> Bool) -> t a -> Bool
17:06:15 <sphinxo> sweet
17:06:40 <c_wraith> > any even [1,3,7]
17:06:43 <lambdabot>  False
17:06:53 <c_wraith> > any even [1,3,4,7, undefined]
17:06:55 <lambdabot>  True
17:07:08 <benzrf> clmg: then... what type are they?
17:08:06 <clmg> benzrf: bro idk
17:08:11 <Cale> > any (> 100) [1..]
17:08:13 <lambdabot>  True
17:08:19 <benzrf> o_o
17:08:29 <lyxia> that was weird
17:08:55 <Tuplanolla> He's a repeat offender, benzrf.
17:09:36 <Tuplanolla> He comes around to ask vague questions every couple of weeks.
17:10:12 <Cale> It's always a little weird when someone joins IRC just to ask one question and then closes it. :P
17:10:28 <Tuplanolla> It's a good chance to practice advanced mind reading.
17:14:41 <tobiasBora> Hello,
17:14:59 <tobiasBora> I've a problem with my haskell install.
17:15:25 <tobiasBora> When I run a program with runhaskell, it works without any problem,
17:15:54 <redmq> how do i add a vector to the last part row of a matrix using ekmett's linear?
17:17:17 <mniip> I wonder if edwardk knows :p
17:18:00 <tobiasBora> but if I use the "ghc" program, if fails: http://pastebin.com/ZGU4uiyd
17:18:09 <tobiasBora> the main error is /usr/bin/ld: final link failed: Nonrepresentable section on output
17:18:49 <tobiasBora> I'm running the last haskell version (The Glorious Glasgow Haskell Compilation System, version 8.0.2)
17:19:34 <tobiasBora> installed in my Debian sid, using the install-linux script available online.
17:19:37 <geekosaur> 8.0.2 should have that fixed, I thought
17:21:15 <tobiasBora> geekosaur: Well... I have this problem, I can confirm you!
17:21:18 <redmq> mniip: i'll just construct a matrix with the vector as the last component
17:21:26 <redmq> jw if there was a faster approach
17:21:52 <redmq> *more concise
17:22:32 <geekosaur> yeh, I'm a bit confused by this. there was a rash of such reports when debian switched over to PIE, but building a new ghc on such debian installations should detect and configure correctly for it
17:23:47 <geekosaur> What is this install-linux script?
17:24:21 <tobiasBora> geekosaur: the one taken from the haskell-platform website, in the section general linux
17:24:48 <geekosaur> I am wondering if it's installing a binary ghc built for a non-PIE debian, in which case you would see this
17:25:04 <geekosaur> that would presumably be a haskell-platform bug
17:25:05 <edwardk> mniip: ?
17:25:07 * edwardk tunes in
17:25:23 <geekosaur> [20 00:15:32] <redmq> how do i add a vector to the last part row of a matrix using ekmett's linear?
17:25:53 <edwardk> myMatrix & _z +~ V3 1 2 3  or whatever
17:26:03 <edwardk> if you want to add to a column use column _z
17:27:39 <redmq> edwardk: hah, thanks :)
17:28:22 <edwardk> replace _z with whatever lens you have for the appropriate basis element
17:30:00 <tobiasBora> geekosaur: So how should I install haskell? The debian sid package is 3 years old...
17:31:50 <Cale> tobiasBora: See if just installing the GHC binary from https://www.haskell.org/ghc/download_ghc_8_0_2 works
17:34:48 <centril> is there some sort of monadic sorting in any hackage lib ? (can always write my own, but...)
17:35:07 <Cale> tobiasBora: Another approach would be to install stack and use that to install GHC.
17:35:19 <centril> like:   (a -> a -> m Bool) -> [a] -> m [a]
17:38:17 <Cale> centril: There's apparently a sortByM in the package monadlist
17:38:41 <centril> Cale: thanks - hoogle was failing me :/
17:39:33 <Cale> It doesn't appear to be a very actively maintained package
17:39:34 <kadoban> sortByM, that sounds like an interesting function
17:39:37 <Cale> But you could steal the code
17:40:11 <centril> Cale: it's for a bachelor thesis, so it's never going to be executed in production anyways (lol...)
17:40:23 <kadoban> I wonder if anything sane happens if you use like  \_ _ -> [True, False]
17:40:26 <centril> i am free to pull whatever dependencies I like ^^
17:41:02 <centril> kadoban: [True, False] as what? in the comparator ?
17:41:13 <centril> still has to be  a -> a -> m Ordering
17:41:15 <Cale> Well, it's (a -> a -> m Ordering)
17:41:18 <Cale> yeah
17:41:23 <Cale> But that should be good enough :)
17:41:33 <kadoban> Oh, I was looking at the other type sig
17:41:34 <centril> Cale: yes, it is exactly what i need
17:41:42 <centril> I already had   a -> a -> Ordering
17:41:49 <Cale> (\_ _ -> [LT, EQ, GT])
17:42:15 <kadoban> Right
17:42:36 <centril> oh - that's funky
17:42:41 <Cale> find isSorted (sortByM (\_ _ -> [LT, EQ, GT]) xs)
17:42:54 <kadoban> Is that like bogosort? Or maybe worse somehow?
17:43:15 <kadoban> It's probably like ... exploring every leaf of the decision tree, I guess ... or even more, maybe even the impossible ones.
17:45:24 <kadoban> I wonder what the real uses of that thing are. All I can think of that'd be practical would be ... using IO or something and sorting indexes or something by whatever they refer to, maybe from a file. Or maybe Writer and recording what comparisons get done? But that doesn't sound very useful.
17:45:46 <centril> Cale: there is also:  https://unknownparallel.wordpress.com/2012/07/03/using-monadic-effects-to-reverse-a-merge-sort/
17:45:49 <kadoban> Or Maybe could make sense possibly
17:45:49 <sphinxo> What's the best way to walk through a list  eg: given "abcde" call some function with "a" "bcde" then "ab" "cde" and so on?
17:46:11 <centril> kadoban: uses for monadic sorting ?
17:46:14 <kadoban> Ya
17:46:52 <centril> kadoban: well... I am writing a normalizer which sorts variables by types - my monad is isomorphic to  (Any, a)
17:47:16 <Cale> I really wish that Data.List had a few more things along those lines... it's not hard to write of course...
17:47:48 <kadoban> centril: Hmm, interesting
17:47:49 <centril> the side-effectful comparator is used to notify that things have changed if x > y
17:47:52 <Koterpillar> > let splits xs = zip (inits xs) (tails xs) in splits "hello"
17:47:54 <lambdabot>  [("","hello"),("h","ello"),("he","llo"),("hel","lo"),("hell","o"),("hello","")]
17:47:59 <centril> since normal form is x < y
17:48:14 <sphinxo> Koterpillar: Thanks!
17:48:15 <Koterpillar> sphinxo: a more efficient version is possibly in Data.List.Split
17:48:26 <Cale> sphinxo: one thing I often find myself using is:
17:48:31 <Cale> select [] = []
17:48:45 <centril> Cale: which one would you pick,  Control.Monad.ListM,  or the one in the blogpost ?
17:48:57 <centril> the package has more functions, so it could be more useful over time
17:49:00 <Cale> select (x:xs) = (x,xs) : [(y,x:ys) | (y,ys) <- select xs]
17:49:02 <centril> but i cant tell which one is the better sort
17:49:33 <centril> both seem to be variants of mergesort
17:49:49 <c_wraith> My favorite sort is idsort.  It's O(1), with the precondition that the input is sorted.
17:49:54 <kadoban> Cale: Is that ... a list of pairs of single-item + rest-of-list ?
17:50:06 <Cale> centril: I wouldn't bother with the package anyway, that code is just getting copied in, since I have zero confidence in that package.
17:50:23 <Koterpillar> > let select (x:xs) = (x,xs) : [(y,x:ys) | (y,ys) <- select xs] in select "hello"
17:50:25 <lambdabot>  [('h',"ello"),('e',"hllo"),('l',"helo"),('l',"helo"),('o',"hell")*Exception:...
17:50:27 <centril> c_wraith: don't we all love that sort
17:50:30 <Cale> kadoban: yeah
17:50:33 <kadoban> Neat
17:50:35 <centril> Cale: how come ?
17:50:43 <c_wraith> Koterpillar: the base case is necessary
17:50:46 <Koterpillar> o hell, exception
17:50:52 <Koterpillar> I like it
17:50:53 <Cale> centril: It hasn't been updated since 2011
17:51:01 <Cale> centril: and has no documentation
17:51:06 <centril> Cale: oh, right
17:51:08 <centril> :P
17:51:11 <Cale> and nothing depends on it
17:51:18 <centril> oh right
17:51:23 <centril> and the license is AllRightsReserved
17:51:29 <centril> i cant even copy the code
17:51:32 <centril> how sad
17:51:35 <Cale> Well, lol
17:51:41 <kadoban> Ugh, that's annoying
17:51:48 <Cale> The code is just the code from GHC's Data.List anyway
17:52:04 <Cale> with some liftM2's and whatnot jammed in
17:52:08 <centril> oh...
17:52:14 <centril> then it can't be AllRightsReserved
17:52:28 <centril> or... depends on the GHC license i guess
17:52:37 <Cale> It's only AllRightsReserved because the user didn't bother setting a license.
17:52:42 <centril> ah
17:53:04 <centril> well, that is too bad... it was going to get us as a dependency, but nope
17:53:58 <Cale> I mean, they could claim copyright, but I don't think they could actually defend it
17:54:33 <centril> Cale: well, if GHC isnt GPL or MPL you can do pretty much anything given attribution
17:56:07 <kadoban> Anything except claim copyright on something you didn't really do anything with, AFAIK
17:56:37 <centril> kadoban: well, if GHC has a permissive license, and you modify its source, you can claim copyright
17:56:47 <centril> on the modified parts
17:57:23 <kadoban> Only if the modification is non-trivial, IIUC. But yeah
17:57:25 <centril> given that it is "original" enough
17:57:43 <centril> kadoban: I'd say Control.Monad.ListM qualifies
17:58:03 <kadoban> You could very well be right, I didn't look at the code side-by-side.
17:58:51 <centril> hmm... the code in: https://unknownparallel.wordpress.com/2012/07/03/using-monadic-effects-to-reverse-a-merge-sort/   is it also AllRightsReserved ?
17:59:28 <Cale> I don't think you could argue successfully that it required sufficient nontrivial effort to be copyrightable as an extension of the work which was already in GHC
17:59:50 <kadoban> centril: I don't see a license :-/ You could ask though
17:59:51 <Cale> It could have been constructed mechanically.
18:00:33 <centril> Cale: maybe not to a seasoned haskller, but... it's not trivial to be a seasoned haskeler
18:00:38 <halogenandtoast> It's probably best to consult a copyright lawyer
18:00:51 <centril> kadoban: ah, it's here anyways: http://stackoverflow.com/questions/11469806/haskell-sort-list-with-impure-function
18:00:55 <Cale> I wouldn't bother.
18:01:04 <Cale> Also, are you even distributing the code?
18:01:09 <centril> and stuff published on SO is not AllRightsReserved
18:01:25 <centril> Cale: our stuff is public on GitHub under GPL2+
18:01:30 <kadoban> Is SO content explicitly licensed? I wasn't aware of that
18:01:31 <centril> so yes
18:01:41 <Cale> Oh, wait a minute
18:01:51 <Cale> Where do you see AllRightsReserved?
18:02:01 <Cale> monadlist is marked BSD3
18:02:26 <centril> https://hackage.haskell.org/package/monadlist-0.0.2/docs/src/Control-Monad-ListM.html
18:02:31 <centril> file header
18:02:40 <Cale> http://hackage.haskell.org/package/monadlist-0.0.2
18:02:47 <Cale> License	BSD3
18:02:53 <centril> that is hella confusing
18:02:59 <centril> I guess it is BSD3 then
18:03:09 <kadoban> There is even a license file too. But yeah, I have no idea how that'd work if it's contradictory, heh.
18:03:09 <Cale> It's a shitty package, and nobody's going to care
18:03:59 <centril> kadoban: https://meta.stackexchange.com/questions/271080/the-mit-license-clarity-on-using-code-on-stack-overflow-and-stack-exchange
18:05:24 <kadoban> centril: Nice, that's good to know
18:05:33 <centril> =)
18:06:00 <kadoban> Thanks for that. I know in the past I've skipped SO code for license issues. I wonder if I just never noticed it was actually licensed, or if that's changed in the meantime.
18:06:35 <centril> TL; DR:   after 2016 it is MIT licensed,   before it is CC-BY-SA
18:06:46 <centril> it was*
18:07:25 <kadoban> That's funny, it sounds like it's MIT with optional attribution, unless the copyright holder requests? Kinda funny.
18:07:46 <centril> kadoban: its basically a move from copyleft to permissible
18:21:44 <lifter> I'd like to use spacemacs for Haskell dev but I'm confused where to start. What do I need to do to configure spacemacs for Haskell dev?
18:22:02 <Koterpillar> lifter: it should work OOB
18:22:43 <Koterpillar> lifter: I only needed to add this: https://github.com/koterpillar/desktop/blob/master/dotfiles/spacemacs#L53
18:23:52 <lifter> Koterpillar: You didn't have to paste the code found here anywhere? https://commercialhaskell.github.io/intero/
18:34:06 <geekosaur> intero is an alternative
18:34:59 <geekosaur> there are some who will assert that it is a necessity, but it is not
18:36:08 <lifter> I guess I'll start by trying spacemacs out of the box then.
18:47:58 <mac10688>   reactimate $ fmap print eWorld
18:48:12 <mac10688> anyone know how I can go about combining clearScreen :: IO()
18:48:16 <mac10688> with the function print?
18:48:28 <mac10688> :t print
18:48:30 <lambdabot> Show a => a -> IO ()
18:48:55 <mac10688> :import System.Console.ANSI
18:49:09 <mac10688> wait I think I might have this
18:52:25 <Koterpillar> lifter: no
18:52:49 <Koterpillar> lifter: spacemacs will activate intero and that hook automatically
18:53:14 <lifter> Cool yeah it seemed to download some intero stuff when I first opened a Haskell file
18:53:45 <centril> Cale: damn it, the sortByM thingy was an unstable sort :(
18:54:29 <Cale> Well, if things compare as Eq, they really ought to be equal :P
18:55:03 <Cale> But yeah, I suppose you'll have to get a stable sort and do the same kind of thing to it
18:55:34 <centril> sortByM (\a b -> pure Prelude.EQ) [1,2,3]   got me  [3,2,1]
18:55:47 <Cale> reasonable
18:55:58 <Koterpillar> centril: how did that compile?
18:56:13 <Koterpillar> oh, sorry, ignore
18:56:52 <Cale> btw, what monad are you using?
18:57:29 <centril> Cale: newtype NormT m (a :: *) = NormT { _runNormT :: WriterT Unique m a }
18:57:42 <Guest35804> I might be stating the obvious here, but I would convert the list to [(1, 0), (2, 1), (3, 2)], where (, i) is the list index, and then make the comparator use a thenBy on the index so that Ordering is semantic.
18:57:43 <centril> Cale: Unique == Any
18:59:12 <centril> Guest35804: right, if they are equal, take the first index
18:59:25 <centril> seems like a hack tho
18:59:53 <Guest35804> I think it's a fairly straightfoward definition of stability.
19:00:29 <centril> Guest35804: well yes, but it's a hack in the sense that you are using an unstable sort for a stable sort
19:00:42 <centril> stable sorts are optimized for stable sorts, and unstable for unstable
19:00:56 <Guest35804> oh, yeah, I'm with you there
19:01:26 <centril> Cale: fortunately, the sort in monadlist is stable
19:03:06 <Cale> centril: You're writing a bunch of stuff while sorting?
19:03:28 <centril> Cale: yes, im conditionally flipping the Any
19:11:02 <sophiag> anyone have time to answer an annoying cabal question? it's failing at installing a package i need as a dependency...
19:12:00 <Koterpillar> ask the question
19:12:01 <Cale> It may help if you give more details than that :)
19:12:16 <pacak> Don't asks to ask...
19:12:30 <sophiag> i know :) just tried that several times when the channel was busy and got no response
19:12:56 <Koterpillar> I'm sure if someone knew, they'd jump in
19:13:07 <sophiag> it's failing at installing pcre-light due to not being abel to find pkg-config. i need it as a dependency for ghc-core
19:13:17 <Koterpillar> OS?
19:13:22 <sophiag> nix
19:13:41 <Koterpillar> pass
19:14:13 <sophiag> i'm not sure if this is related, but i have stack installed as well but can't set it up because it fails at installing ghc after download :/
19:14:41 <Cale> It's not in nixpkgs?
19:14:53 <sophiag> ghc?
19:15:04 <Cale> pcre-light
19:15:06 <sophiag> i have both haskell-platform and stack installed
19:15:08 <sophiag> oh
19:15:13 <sophiag> hmm, i didn't think abou tthat
19:15:57 <Cale> I just added it to my reflex-platform config, and it installed fine from the cache
19:16:02 <Cale> So it's probably in there :)
19:16:11 <sophiag> there's regular pcre listed in nix packages
19:16:25 <sophiag> i figured this was haskell specific th
19:16:29 <sophiag> *tbh
19:18:47 <Koterpillar> pkg-config isn't haskell-specific
19:19:53 <sophiag> hmm, yeah i put pcre in my nix config and rebuilt and am getting the same error :(
19:20:30 <sophiag> makes sense since it was always failing during the configuration step
19:20:38 <Cale> https://raw.githubusercontent.com/NixOS/nixpkgs/master/pkgs/development/haskell-modules/hackage-packages.nix
19:20:43 <Cale> search for "pcre-light"
19:20:50 <Cale> It's in there
19:21:34 <Cale> (search with quotes)
19:21:40 <sophiag> Cale: cool, thanks! i haven't actually had to put any haskell packages in my nix config yet
19:21:49 <sophiag> i thought you were referring to the regular pcre
19:21:52 <nshepperd> sophiag: have you tried installing pkg-config
19:22:24 <Cale> It seems like it's setting libraryPkgconfigDepends
19:22:36 <Cale> which might trigger the installation of pkg-config as necessary
19:22:56 <Cale> I don't actually know
19:25:14 <sophiag> nshepperd: i just added pkg-config and pcre as well, but cabal is still telline me i'm misisng pcre. i wonder if this means i need to reboot :/
19:25:21 <Cale> sophiag: Oh, I guess I assumed you'd actually be building Haskell stuff using nix, if you're crazy enough to be using nixos as your desktop already :)
19:25:32 <sophiag> i am using nixos
19:25:50 <sophiag> but did not assume i'd be using nix to install haskell packages
19:26:06 <Cale> Ah, well, there's pretty good support for doing that
19:26:12 <Cale> It's what we use where I work
19:26:38 <Cale> You can sidestep the entire debate between stack and cabal-install
19:26:50 <sophiag> that would be great :)
19:27:25 <sophiag> can you link me to something with the syntax? i assume it's similar to installing emacs packages, which i do use nix for
19:27:32 <Cale> There's a program called cabal2nix which will construct a nix expression for a cabal project
19:28:27 <Cale> https://github.com/NixOS/cabal2nix -- the readme here shows how to use it
19:29:09 <sophiag> oh, it's listed under nix packages anyway
19:29:13 <Cale> yeah
19:29:33 <Cale> So you can write your .cabal file as usual
19:29:42 <Cale> and then  cabal2nix . > default.nix
19:31:06 <sophiag> woah...i just found the part of the nix manual on haskell and apparently i can have hoogle cli?
19:31:18 <Cale> yeah
19:32:07 <sophiag> but the section on haskell packages is all done imperatively. do you not just put them in your config?
19:32:44 <Cale> Well, usually you just have your own project depend on them
19:33:18 <Cale> and just use nix-build to build
19:33:44 <sophiag> right, like this is the first package (ghc-core) i'm having to actually install with this setup for obvious reasons
19:33:50 <Cale> But I'm like the least competent nix user ever
19:34:05 <Cale> Since I just rely on my coworkers to know what the heck is going on there :)
19:34:54 <Cale> (I don't use nixos myself, just the package manager for building our projects)
19:34:59 <sophiag> ah ok
19:35:28 <sophiag> i'm pretty new to it, but after switching between three machines in as many months it's definitely worth the learning curve
19:36:26 <sophiag> do you at least know if the syntax in that github file you linked me to is what i'd throw in my config for packages i need to install manually?
19:37:11 <Cale> You mean, if you want them to be globally available?
19:37:59 <sophiag> yeah, and just declaratively so i don't have to think about this again
19:38:36 <Cale> Like, if you're building your project with nix, all you have to do is add the dependencies to your .cabal file, rerun cabal2nix, and it'll make you a derivation for building the project, and nix will make sure all the right stuff is installed when it builds for you.
19:38:55 <Cale> So you wouldn't normally need very much to be installed globally
19:39:17 <sophiag> oh i see
19:39:34 <sophiag> i'm surprised there's not a way to shift that from .cabal to configuration.nix
19:39:48 <sophiag> there may be, but at least it doesn't seem to be the standard way to do things
19:39:57 <Cale> I'm sure there's some way, I just don't have any idea what I'm doing
19:40:25 <Cale> There's probably some haskellPackages thing you can set somewhere
19:41:15 <sophiag> that's exactly what i was thinking
19:41:30 <sophiag> (also tbh i've never edited .cabal directly)
19:42:34 <Cale> https://nixos.org/releases/nixpkgs/nixpkgs-17.03pre91860.124f25b/manual/#how-to-install-haskell-packages
19:43:31 <sophiag> i'm already reading that, but as mentioned it's all done imperatively which is a bit odd
19:43:54 <Cale> I think that implies you can just install them like any other package
19:44:06 <Cale> But add "haskellPackages." on the front of the name
19:44:23 <sophiag> oh really?
19:44:37 <sophiag> because they've already been ran through cabal2nix i suppose?
19:44:51 <sophiag> and i mean to ask, is that the case for that list you linked me to?
19:44:56 <Cale> Yeah, that's what that giant .nix file I linked you was
19:45:59 <centril> If I have a   Traversal' a [b]   and  Traversal' b c   how do i compose these ?
19:46:27 <centril> my lens-fu needs improvement
19:47:12 <lyxia> put a    . traverse .    in the middle
19:47:35 <centril> lyxia: oh, that is so neat
19:47:37 <centril> thanks
19:48:43 <sophiag> Cale: it seems i can bypass that if i just use the snippet in the manual and list packages directly tho. the only thing i'm confused about is it says to put it in ~/.nixpkgs/config.nix and i'd rather keep everything in /etc/nixos/configuration.nix
19:49:14 <Cale> sophiag: I guess the expectation is that you don't really need that stuff globally.
19:51:09 <sophiag> it's not that i want it globally, but that i'm using this for my personal box and would prefer to only have one config file. for example, some people have a separate one for emacs whereas i put it directly in configuration.nix
19:51:45 <Cale> ohhh
19:51:57 <Cale> There might be a problem with just installing things separately... I'm not sure
19:52:18 <Cale> er, wait
19:52:24 <Cale> I dunno, maybe it's fine
19:52:31 <sophiag> well, the syntax in ~/.nixpkgs/config.nix is not that different. i think i can adjust it
19:52:37 <Cale> Well, there's this ghcWithPackages thing
19:53:00 <Cale> which takes a list of packages to install
19:53:13 <Cale> Maybe that's just the packages to install globally in the GHC sense.
19:53:24 <sophiag> yeah, that's what i'm talking about anyway
19:53:39 <sophiag> just putting it in a different file instead
19:53:59 <sophiag> the manual says the same with emacs and someone in #nixos recommended i just put it in configruation.nix as well
19:54:12 <sophiag> yikes, my typos are nuts today
20:03:38 <sophiag> Cale: ugh...so rebuilding nix seemed to go fine, but apparently that snipped didn't work since now i don't even have cabal
20:03:55 <sophiag> i'm still using ghci in emacs tho...
20:15:44 <Cale> sophiag: perhaps https://www.youtube.com/watch?v=G9yiJ7d5LeI will be helpful...
20:16:58 <sophiag> interesting, thanks. i'll take a look. someone on #nixos is helping me with this simple rebuild for now tho
20:21:57 <centril> is the order of transformation in doing    transformMOf uniplate   deterministic?
20:23:17 <Cale> centril: It had better be
20:23:46 <centril> Cale: cause it seems to me that it isnt :/
20:24:38 <centril> Cale: so I have:  [Stmt] -> WriterT [Stmt] [Stmt]   - and in this I'm filtering out some statements and putting in the writer and keeping others
20:25:12 <centril> and doing this with transformMOf uniplate
20:25:57 <centril> then Im running the writer and checking if the statements collected in the writer is a prefix of the one given to me
20:26:09 <centril> but it doesnt seem to preserve order
20:27:13 <Cale> But is it the same order every time?
20:28:46 <centril> Cale: the first time, the statements are taken, so it wont be a prefix, but the output of the first run when run with the same normalizer is then given back in a different order
20:28:48 <centril> ill try with a third time and see what happens
20:32:35 <centril> Cale: [a, [b], c] -> [b, c, a] -> [a, c, b] -> [b, c, a]
20:33:05 <centril> (variable names, and scopes)
20:33:35 <Cale> huh.
20:34:09 <Cale> I wouldn't expect the order in which items are traversed by uniplate to be any different if repeated.
20:34:15 <sophiag> Cale: thanks for the help. turns out all i was missing was including myHaskellEnv in my pkg list
20:34:22 <Cale> ah
20:34:25 <Cale> cool
20:34:26 <centril> Cale: i must be doing some epic fuckup
20:35:28 <Cale> centril: You were the one that was doing weird monadic sorting stuff that I didn't properly make sense of earlier?
20:35:42 <centril> Cale: that one worked out fine
20:35:42 <Cale> ah, yeah
20:35:45 <Cale> hmm
20:35:53 <centril> this is a different normalization for moving statements to the top
20:35:54 <sophiag> although not ghc-core doesn't seem to be working as expected based on the tiny README...it says i just pass it the haskell file, but seems it's looking for an executable?
20:36:25 <Cale> ghc-core should mimic ghc in its behaviour
20:36:38 <Cale> It literally just runs ghc with some additional options and colours the output
20:36:53 <sophiag> oh, i see
20:37:08 <Cale> Specifically -ddump-simpl
20:37:14 <sophiag> that's not how the examples on hackage make it seem: https://hackage.haskell.org/package/ghc-core
20:37:37 <sophiag> -ddump-simple is what i want to see the colorized core output?
20:37:50 <lpaste_> Centril pasted “uniplate is being weird” at http://lpaste.net/353729
20:37:59 <centril> Cale: ^ hopefully you can follow
20:38:08 <Cale> -ddump-simpl is a flag to GHC to make it output the core after the simplifier runs
20:38:26 <Cale> It won't print it colourfully, or put it in a pager
20:40:21 <Cale> Oh, ghc-core also has a nix package
20:40:35 <Cale> I was able to install it and it works
20:41:03 <sophiag> i have it installed, but it doesn't take a -o flag like ghc
20:41:11 <Cale> oh, it won't
20:41:19 <sophiag> and even passing ghc -ddump-simpl isn't outputting anything...
20:41:22 <Cale> It's not going to produce any executable output
20:41:30 <sophiag> right, that part confused me
20:41:38 <sophiag> it still seems to want an executable name tho
20:41:44 <Cale> hm?
20:41:52 <Cale> How are you running it?
20:42:11 <sophiag> the example says just run it like: ghc-core A.hs
20:42:14 <sophiag> but that doesn't work
20:42:30 <Cale> It works on the program I tried it on :)
20:42:36 <sophiag> hmmm
20:42:38 <Cale> What error exactly?
20:42:41 <sophiag> i get "ghc-core: less -R: rawSystem: runInteractiveProcess: exec: does not exist (No such file or directory)"
20:42:48 <Cale> ohh
20:42:58 <Cale> apparently you don't have less?
20:43:20 <Cale> and nix didn't know that less is secretly a dependency of ghc-core
20:43:46 <sophiag> oh...
20:43:55 <Cale> Or maybe that's not the problem? Hard to tell.
20:44:24 <sophiag> welp, rebuilding now
20:44:50 <sophiag> nah, that's not the problem
20:44:51 <centril> Cale: also tried with tinplate instead of uniplate - problem persists :/
20:45:12 <Cale> centril: I strongly suspect it's not the traversal's fault
20:45:24 <centril> Cale: yes, i suspect so to
20:45:26 <Cale> oh, you pasted stuff
20:45:30 * Cale looks
20:45:31 <centril> yeah
20:45:46 <centril> i stripped some stuff i can paste if you want
20:45:52 <centril> but then you have a wall of code ^^
20:46:03 <Koterpillar> sophiag: is someone trying to execute ["less -R"] instead of ["less", "-R"]?
20:46:05 <Cale> Well, it's really hard to tell what that does
20:46:18 <centril> Cale: i get that =)
20:46:45 <centril> Cale: normEvery =  transformMOf uniplate
20:47:01 <sophiag> Koterpillar: "someone" would be ghc-core so idk
20:47:25 <Cale> centril: There's no way that this function could be producing different results for the same input
20:47:26 <sophiag> i just tried running it manually and it works fine
20:47:39 <Cale> centril: It's a pure function on lists of Stmts
20:48:19 <Cale> centril: It produces a Writer action, Writer is just glorified (,)
20:48:32 <centril> Cale: i know i know =)
20:48:49 <centril> Cale: added another statement to make sure i understand what it is doing
20:48:56 <centril> and: it is reversing the list every time
20:49:09 <centril> why... i dont know
20:49:16 <Cale> How are you testing it?
20:49:29 <Cale> Are you just applying vdSteal to the same argument multiple times?
20:49:49 <Cale> Or is other stuff going on? Are you sure you're passing it the exact same argument?
20:50:18 <centril> Cale: I parse some java code => AST => and then I run execVDTop on the top level ast
20:50:32 <Cale> Well, execVDTop involves IO somehow
20:50:38 <Cale> So it might do lots of stuff
20:50:50 <Cale> Get a suitable argument for vdSteal and test it in isolation
20:51:10 <centril> Cale: right - tho... execVDTop just prints stuff ;)
20:51:15 <centril> the io is just for debugging
20:51:22 <centril> but ill do that
20:53:10 <centril> Cale: getting the suitable argument was really easy since i printed the stuff out anyways 
20:53:12 <centril> :D
20:54:32 <Cale> So, what do you get, is it misbehaving still?
20:55:41 <centril> Cale: so the first time it reverses the list, second time it behaves as id, third: id, ...
20:56:11 <centril> hcPrint $ (vdSteal  >=> vdSteal  ) fixture
20:56:38 <Cale> that's... not what I asked for
20:57:00 <Cale> But okay, that's very different from what I thought you were talking about
20:57:35 <centril> Cale: which was?
20:57:46 <Cale> I just meant evaluate the expression multiple times
20:57:54 <Cale> I thought you were saying it wasn't deterministic
20:58:10 <Cale> even though it should be a pure computation
20:58:14 <centril> oh, well, i did that too
20:58:21 <centril> it is deterministic
20:58:24 <Cale> okay
20:58:55 <Cale> Well, even for a pure function f, it shouldn't be surprising if f . f = f -- that happens a fair amount
20:59:12 <Cale> For example, a function which sorts a list has that property
21:00:02 <centril> right, i dont think the problem really lies in vdSteal other than it reversing the list
21:00:23 <centril> well, if you reverse on every time, that is a problem
21:03:06 <centril> Cale: right, so if i reverse the output i get from vdSteal (in the writer monoid) it works 
21:03:40 <centril> why uniplate / tinplate gives me a reversed list i dont know
21:06:58 <sophiag> ugh, i'm still super confused by this error from ghc-core when i can literally run the same command it's failing on fine. doesn't help that there's pretty much no documentation on it
21:08:05 <Koterpillar> sophiag: is it not finding "less" or is it not finding "less -R" as a single command?
21:08:14 <Koterpillar> (strace will tell)
21:08:53 <Cale> Koterpillar: I would be surprised if it were just broken, because it works on my machine
21:09:26 <sophiag> google seems to say it's related to how i installed everything with nix
21:10:13 <sophiag> Koterpillar: what exactly am i looking for in the output from strace? it's quite long...
21:10:27 <Koterpillar> some kind of exec that fails
21:10:40 <Koterpillar> you will need these parameters to strace: -e trace=process -f
21:11:40 <buttons840> Here's a web app I'm building wih Spock. I'm new and wondering if anyone sees any glaring issues with it? http://lpaste.net/353730
21:12:03 <centril> > runWriter $ (transformMOf uniplate $ filterM $ \x -> tell [x] >> pure False) [1,2,3]
21:12:05 <lambdabot>  ([],[3,2,1])
21:12:09 <sophiag> Koterpillar: as expected it's "less -R" not "less" "-R" (the latter made no sense to me tbh)
21:12:11 <centril> Cale: ^
21:12:26 <Koterpillar> sophiag: show the relevant line?
21:13:30 <centril> runWriter $ (filterM $ \x -> tell [x] >> pure False) [1,2,3]
21:13:34 <centril> > runWriter $ (filterM $ \x -> tell [x] >> pure False) [1,2,3]
21:13:36 <lambdabot>  ([],[1,2,3])
21:13:49 <sophiag> there are a bunch of lines, but they're all basically like this: "[pid  3998] execve("/home/sophia/bin/less -R", ["less -R", "/tmp/ghc-core-XXXX18042893838469"...], [/* 71 vars */]) = -1 ENOENT (No such file or directory)"
21:14:13 <sophiag> so it appears the exec it can't find is not less, but actually the output from ghc?
21:15:24 <pacak> Suppose I'm trying to apply some transformation on a product type. For most fields there is a property `Monoid b => Proxy a -> b, for some it must be `Monoid b => a -> b`. At the end I'm trying to get monoidal sum of every field but trying to perform as much of computation on compile time as possible. What would be the most intelligent approach? (ghc will calculate foo :: Int -> Int, foo x = 1 + x + 2 as 2 additions, not 1).
21:15:55 <geekosaur> sophiag, you have an option in the pathname
21:16:23 <Koterpillar> sophiag: that program is broken
21:16:31 <Koterpillar> sophiag: ghc-core or what was it
21:16:31 <geekosaur> it is looking for a file literally named "/home/sophia/bin/less -R", with embedded space
21:16:50 <Koterpillar> sophiag: _maybe_ you can trick it with setting PAGER (?) to just 'less', but not likely
21:16:58 <Koterpillar> I would trail its code for "less -R"
21:17:03 <geekosaur> it may be parsing an environment variable expecting it to be a pathname, when it is actually a shell command
21:18:20 <sophiag> ugh
21:19:32 <sophiag> there is an open issue related to using PAGER: https://github.com/shachaf/ghc-core/issues/3
21:20:16 <geekosaur> hack: drop a script which does `exec less -R "$@"` somewhere and put the path to that in $PAGER
21:20:38 <geekosaur> (...just don't name the script "less" :)
21:20:39 <Koterpillar> hack^2: name the script "less -R" (with a space)
21:21:03 <geekosaur> heh. that'd work too :)
21:22:57 <sophiag> i can't tell whether this was fixed here: https://github.com/shachaf/ghc-core/commit/630196adf0bebf073328325302453ef1c409fd9a
21:24:12 <geekosaur> looks like it is, yes
21:24:50 <geekosaur> switched from rawSystem (which directly exec()s what it's handed) to createProcess with a shell-based command specification
21:25:22 <sophiag> ok, so stupid question...but how exactly do i bypass this using PAGER?
21:25:41 <geekosaur> the hack I mentioned above
21:26:07 <geekosaur> instead of putting the option you want in $PAGER, make a script which runs the real pager with that option and set $PAGER to point to that script
21:26:31 <lpaste_> mymosh pasted “No module named ‘Char’ is imported.” at http://lpaste.net/353731
21:26:52 <sophiag> oh, i wasn't certain i actually had to go that route
21:27:12 <geekosaur> until thatcommit you pointed to lands in a release, it's probably the easiest solution
21:27:27 <mymosh> Hello, does anyone know what is causing this error? http://lpaste.net/353731
21:27:35 <geekosaur> mymosh: the module "Char" is from Haskell98 without hierarchical libraries
21:27:42 <sophiag> i couldn't tell whether that had been solved yet...seems not since the issue is still open
21:27:47 <geekosaur> it's Data.Char these days
21:28:04 <mymosh> geekosaur Thanks!
21:28:19 <mymosh> Trying to learn Haskell by following https://en.wikibooks.org/wiki/Yet_Another_Haskell_Tutorial/
21:28:22 <geekosaur> sophiag, if you were to reinstall ghc-core from the git repo instead of from hackage, you would have a fixed version
21:28:33 <mymosh> Looks like it might be out of date then.
21:28:35 <geekosaur> yeh, parts of the wiki are heavily bitrotted
21:28:40 <sophiag> ah
21:29:47 <sophiag> i'm just trying not to do imperative configurations like that because then when i switch systems i'll inevitably forget how to replicate them...
21:30:24 <sophiag> one thing that's odd is i don't seem to even have cabal-install after switching my nix config...
22:05:18 <dfeuer> edwardk?
23:39:14 <ertes> Cale, sophiag: nixpkgs includes everything from hackage…  the haskell package set is generated automatically from a script
23:40:05 <dfeuer> FYI:  (unsafeCoerce unsafeCoerce) is unsafe.
23:40:20 <ubsan_> dfeuer: I'm absolutely shocked :P
23:40:34 <dfeuer> ubsan_: I just crashed the compiler with it :P
23:40:44 * ubsan_ continues to be shocked
23:40:46 <ubsan_> :P
23:40:50 <dfeuer> Pfff.
23:41:09 <ubsan_> wait, like, ICE?
23:41:15 <ubsan_> oooh, bug report time!
23:41:16 <ubsan_> :D
23:41:28 <dfeuer> ICE?
23:41:51 <ubsan_> internal compiler error
23:41:55 <sophiag> ertes: thanks. i figured out the config. now just having trouble running ghc-core, which i'm suspicious may be nix specific...
23:41:58 <ubsan_> it means, basically, a compiler crash
23:42:00 <dfeuer> Yeah, one of those. Ticket #13458.
23:42:22 <dfeuer> Night all.
23:42:29 <ubsan_> o/
23:42:46 <dfeuer> ubsan_: http://ghc.haskell.org/trac/ghc/ticket/13458
23:43:29 <dfeuer> It's pretty bogus code, but that's supposed to get caught by the type checker.
23:44:15 <dmwit_> inb4 wontfix
23:44:49 <dmwit> "I turned off the type checker and the type checker didn't save me." uh... okay
23:44:56 <dfeuer> unsafeCoerce id also breaks there...
23:46:03 <dfeuer> dmwit: unsafeCoerce is supposed to be able to produce runtime memory corruption and such fun.
23:46:13 <dfeuer> It's not supposed to be able to produce compile-time crashes.
23:46:30 <dmwit> Yeah, we'll see. Perhaps crashing the compiler is serious enough to pay attention to.
23:46:44 <dmwit> as you say =)
23:47:15 <dfeuer> Crashing the compiler is a much less important bug than crashing the runtime, but it's a question of whose fault it is...
23:47:49 <geekosaur> I... *think* something related to this has been discussed recently? Something about unsafeCoerce not getting along with RuntimeRep?
23:48:12 <dfeuer> Worst sort of bug, generally is "Incorrect result at runtime". Those are the real nightmares....
23:48:24 <geekosaur> wait no, that;s the internal version. that level shouldn't be exposed by the non=-# one
23:48:45 <geekosaur> (right. typing gone. should be in bed...)
23:48:56 <dfeuer> geekosaur: I think the issue is that even a representation polymorphic function has a type of kind *.
23:49:08 <dfeuer> So unsafeCoerce is happy. But then when it inlines,
23:49:18 <dfeuer> unsafeCoerce# gets unhappy in core lint.
