00:00:23 <ahri> ok, cool. um... was that obvious in some way? it might be useful to me in future to be able to figure this out myself!
00:03:15 <jle`> it's kind of arbitrary, but there's a table associating ghc's with their corresponding base
00:03:31 <jle`> https://wiki.haskell.org/Base_package
00:03:52 <jle`> and here's a table i use for other libraries that come packaged with ghc as well https://ghc.haskell.org/trac/ghc/wiki/Commentary/Libraries/VersionHistory
00:06:02 <jle`> so all of those ghc's are tied to the corresponding versions of those libraries i believe
00:07:21 <ahri> thanks, that's really helpful!
00:07:40 <jle`> no problem! this is what i use myself when i have to trudge through versioning problems
00:34:49 <roundhouse> hi guys, I have a function that produces elements of type `a`. Depending on `a` I need one or more inputs. I tried modelling this via "data A a b = A { prod :: b -> a }" and my hope was that putting b to () this would erase the input of prod. However this seems to not work. Do you have a hint what would be a better way to do this?
00:38:31 <mpickering> roundhouse: Can you describe what you are actually trying to do?
00:40:18 <jle`> roundhouse: what do you mean by 'erase' ?
00:40:33 <jle`> it is true that 'A a ()' is isomorphic to ()
00:40:50 <jle`> er sorry, A () b is isomorphic to ()
00:40:57 <roundhouse> mpickering: I want to abstract over asset loading. An assetloader gets a filename and loads the asset "a". But some assets need extra information, e.g. a font needs to know the size which to load
00:40:58 <jle`> A a () is isomorphic to 'a'
00:42:07 <roundhouse> jle`: erase in the sense: if b == () then prod :: a, otherwise prod :: b -> a
00:42:32 <jle`> oh, er, that seems kind of magical
00:42:33 <roundhouse> I was hoping prod :: () -> a would be treated as prod :: a
00:42:51 <roundhouse> there being only one value for that type
00:42:57 <jle`> haskell doesn't automatically coerce types like that, heh
00:42:58 <roundhouse> (if I understand () correctly)
00:43:20 <jle`> `() -> a` is a different type than 'a', even though they are isomorphic (up to bottom)
00:43:28 <phz_> <3
00:43:41 <phz_> jle`: and () is isomorphic to a -> () 
00:43:51 <jle`> roundhouse: but yeah, haskell doesn't automatically coerce values like that
00:44:03 <jle`> () isn't magical, either, it's just a normal type
00:44:10 <roundhouse> damn
00:44:15 <jle`> you can get the 'a' out of an '() -> a' by applying it to ()
00:44:22 <roundhouse> any idea how I can modell my original problem?
00:44:26 <roundhouse> yeah
00:44:35 <jle`> @let stuff :: () -> Int; stuff () = 10
00:44:37 <lambdabot>  Defined.
00:44:39 <roundhouse> but that clutters all function calls that don't need the extra argument
00:44:39 <jle`> > stuff ()
00:44:41 <lambdabot>  10
00:44:49 <phz_> roundhouse: I’ve done that
00:44:52 <phz_> your problem
00:44:53 <phz_> see:
00:45:13 <phz_> https://github.com/phaazon/spectra/blob/master/src/resource.rs#L17
00:45:17 <jle`> well, you can write a function that converts any `() -> a` into an `a`
00:45:19 <phz_> in Haskell, it’d be a simple typeclass
00:45:22 <phz_> and associated types as well
00:45:23 <jle`> as a higher-order function
00:45:50 <phz_> if you don’t need arguments at loading, you just set type Args = ();
00:46:29 <roundhouse> ok, but then I have to call load with "()" all the time, correct?
00:46:41 <mpickering> what is the purpose of this abstraction because it seems like you could define "data AssetLoader a b = AssetLoader (a -> b)"
00:46:51 <phz_> roundhouse: yeah
00:46:58 <phz_> but you can add a special method for that case :)
00:47:00 <phz_> like load_ ;)
00:47:01 <mpickering> and you have  function "loadAsset :: AssetLoader a b -> a -> b"
00:47:05 <roundhouse> jle`: I guess that works
00:47:07 <jle`> you can also abstract over the application as well; loadFoo :: A a b -> (b -> a), loadFoo_ :: A a () -> a
00:47:27 <jle`> loadFoo_ (A f) = f ()
00:47:40 <roundhouse> mpickering: assetloader has more stuff, this is just the issue I ran into. It e.g. also saves the assets
00:48:17 <mpickering> I don't advise doing anything complicated with type classes
00:48:22 <jle`> you can also write bIsUnit :: (() -> a) -> a
00:48:34 <phz_> I’d say use type classes
00:48:45 <roundhouse> I actually have atype class right now
00:48:52 <roundhouse> but it is way to complicated
00:48:53 <phz_> it’s typically the right ad-hoc situation type classes will help you solve in a great and flexible way
00:49:01 <jle`> but, writing a spcial case for b ~ () is definitely a route that a lot of people and libraries take
00:49:20 <jle`> it's roughtly equivalent to runStateT vs. runState
00:49:33 <jle`> runState being a special case of runStateT when m ~ Identity
00:49:35 <phz_> jle`: for Identity
00:49:35 <roundhouse> https://github.com/r-raymond/purple-muon/blob/master/src/Client/Assets/Generic.hs
00:49:38 <phz_> yep.
00:49:40 <roundhouse> is the current type class
00:50:01 <roundhouse> but I'd like to remove it for a simple data type
00:50:19 <roundhouse> thanks, I'll just implement some helpers for the special case ()
00:51:33 <jle`> it's not the cleanest method but it's simple enough
00:52:11 <jle`> and used pretty widely
00:52:19 <roundhouse> cool
00:52:38 <roundhouse> I'll have to read more source code of other people
00:53:47 <jle`> to be clear, i don't mean necessarily that special-casing () is common, just that special-casing the situation where specific types are used in type parameters is common
00:54:16 <jle`> like how you have `runStateT :: StateT s m a -> s -> m (a, s)`
00:54:39 <jle`> but in the case where m is Identity, transformers offers a special-case convenience function, runState :: StateT s Identity a -> s -> (a, s)
00:54:58 <roundhouse> I see
00:55:22 <roundhouse> thanks again!
00:55:25 <jle`> no problem!
01:30:35 <ertes> helo
02:39:08 <soupy> are parentheses in lambda calc primitive?
02:39:46 <soupy> When I want to say \xyz.xy(xz) ; can I somehow define it without using parentheses anywhere?
02:40:21 <soupy> I mean, it seems like a let..in construct, but shouldn't that be stated as a primitive?
02:42:49 <Saizan> the way i think of it is that a lambda calculus term is a tree, and the parentheses are just a way to write that tree as a flat string
02:44:15 <soupy> Saizan: saying "it's a tree" sounds equivalent to "you can use parentheses" - can you perhaps unpack that further?
02:45:28 <soupy> also, would that mean that parentheses are exactly what allow branching then?
02:45:47 <soupy> Is lambda calc without parentheses completely trivial and boring?
02:46:39 <Saizan> i'd say grouping rather than branching
02:47:06 <Saizan> and yeah, you're pretty limited without parentheses
02:47:57 <soupy> is there a precise way to say what I'm limited to, perhaps context sensitive grammars or something like that?
02:48:59 <Saizan> a simple way would be to always require parentheses, around each lambda and each application
02:49:16 <Saizan> soupy: are you familiar with haskell?
02:49:52 <Saizan> btw, i hate that most books don't put spaces, it's much more readable if you write \x y z. x y (x z)
02:49:57 * ski . o O ( polish notation )
02:50:21 <soupy> yes, sure
02:50:27 * Saizan blames latex's math mode
02:50:46 * ski . o O ( `\ x \ y \ z @ @ x y @ x z' )
02:51:00 <Saizan> soupy: parentheses in LC are used just like in haskell
02:51:20 <soupy> uh, that's like putting the cart before the horse
02:51:24 <soupy> don't you think?
02:52:13 <Saizan> nope, because there are haskell implementations which you can use to test your terms
02:53:56 <soupy> I mean, it doesn't help to denote the expressive power of 'LC w/o parentheses' concisely, which is all I'm asking, really.
02:55:11 * ski . o O ( `data Expr = Var Ident | Abs Ident Expr | App Expr Expr; display :: Expr -> String; display (Var i) = displayIdent i; display (Abs i0 e1) = "\\" ++ displayIdent i0 ++ display e1; display (App e e0) = "@" ++ display e ++ display e1' -- no brackets. parser is an exercise )
02:55:38 <Saizan> soupy: oh, i didn't get you were asking that
02:55:46 <Saizan> soupy: i don't know
02:56:10 <soupy> haha, ok thanks, it's more of a cstheory question than a Haskell question anyway
03:13:46 <augur> whats the current best way to get a haskell app running on a server?
03:14:55 <lep-delete> i for one just statically compile
03:17:56 <mekeor> i guess, you don't want to compile it on the server, huh?
03:21:28 <orion> augur: I compile my Haskell programs and link them statically against musl.
03:21:48 <augur> orion: oh?
03:22:00 <augur> lep-delete: hows that?
03:22:34 <augur> mekeor: i'm investigating how to do that, but i'm not very familiar with the tools for that stuff
03:23:13 <Rembane> orion: Do you have a writeup for how to do that?
03:27:39 <ertes> augur: i mostly use nix to build docker containers these days
03:28:38 <ertes> augur: if that's not possible, i use nix to extract the closure and just send a tar.gz of it to the target host
03:28:50 <ertes> closures are self-contained
03:28:56 <augur> i wish i understood what this means :(
03:29:38 <orion> Rembane: I don't have a formal writeup, no. I use docker for everything: https://github.com/centromere/ghc-musl-bootstrap
03:30:27 <ertes> augur: after you have built a haskell package using nix, you get a "derivation", a directory in the nix store that holds your package…  the "closure" of that derivation is the set of nix store paths that your package needs…  everything from glibc and all haskell libraries to the derivation itself
03:30:51 <ertes> augur: you can just feed that list into 'tar' to get a package that you can extract on the target host, and it will just work (assuming same architecture)
03:32:14 <Rembane> orion: Informal works, git repo works even better. Thank you! :)
03:57:28 <Booba> Hello dear haskellers. I am a not-so-beginner haskeller now. I am somewhat comfortable in monads and monad transformers and wanted to find out how do I design my own monads to encapsulate the effects I am interested in. For example, I've been looking at haskell chat example https://wiki.haskell.org/Implement_a_chat_server and was able to figure it out. I understand how and why it waorks. But I don't see how could I refactor this?
03:58:18 <Booba> I mean, how do I extract Chat into a separate module, how do I posiibly make it use conduit, elerea or pipes, for intance? Could anyone point me to a guide on how to desgin my own API's?
04:04:13 <ertes> Booba: most people probably shouldn't create their own monads
04:04:30 <ertes> if all you need is a bunch of effects you can interpret in a certain way, free monads are often a good way to go
04:05:10 <ertes> but if all you do in the end is to translate those effects into ones already captured by other monads, you should have just used the other monads to begin with
04:07:00 <Booba> ertes: thanks for your reply. I hear what you say and I agree, I guess. Maybe I am looking for a way to unambiguate some effects. Or how do I figure out a correct data type for my needs.
04:07:41 <Booba> ertes: Going back to chat example. I see it as a a type that is able to handle Socket type in a specific way: send and receive messages in a certain way. How do I design that?
04:07:51 <ertes> Booba: by writing code and then improving it
04:08:02 <ertes> by talking to other haskell programmers
04:08:03 <ertes> etc.
04:08:54 <ertes> i don't think there is such a design guide anywhere, and also there is often not one true solution, but many different approaches with unique characteristics
04:09:29 <Booba> ertes: right. I've written a chat exactly as in the example. How do I improve it to be a reusable module itself? The original example does not introduce any data types. I have a feeling that I could introduce couple of useful ones.
04:10:35 <ertes> Booba: the chat example is not that interesting to be honest…  there aren't too many ways to improve it
04:11:01 <Booba> ertes: so you're saying that I, most probably, should be looking for making any monads/transformers. Maybe I'd better be designins some sort of State and functions on modifying/reading it?
04:11:02 <ertes> one improvement i would do is to switch to stream processing (e.g. pipes)
04:11:06 <nulldata> Hey
04:11:21 <Booba> ertes: should not*
04:11:40 <ertes> Booba: you should first make the application more interesting…  more complex that is
04:11:46 <nulldata> Is there any way to reference an associated type of a type class in a function signature outside the type class definition?
04:12:10 <ertes> Booba: the current one doesn't even have any state worth mentioning…  all its state is already captured by concurrency
04:12:30 <ertes> Booba: perhaps turn it into a stateful networked game first
04:12:43 <Booba> ertes: I can see that. For instance, I want to add rooms to a chat. So that any user can create/remove/enter/leave rooms
04:13:17 <Booba> ertes: oh, a game is a good one. 
04:13:49 <ertes> Booba: you could switch to stream processing along the way
04:14:15 <ertes> nulldata: what do you mean?  once defined you can use the AT anywhere
04:14:46 <Booba> ertes: I imagine that the game would have its own state, right? So it is a data type that hides this state and exposes functions that represent participants turns and actions. Every function might modify state in a certain way.
04:14:49 <nulldata> ertes: Kinda like this: https://ctxt.io/2/AAAA0LlFEg
04:15:22 <Booba> ertes: Doesn't it looks like some sort of state transformer monad? Or I am misreading the purpose of transformers?
04:15:23 <geekosaur> nulldata, it needs the type parameter
04:15:58 <geekosaur> you want (Var a)
04:16:09 <ertes> Booba: you won't be able to use state monads a lot, because the state is shared between client threads
04:16:17 <ertes> Booba: but here is your first abstraction: STM
04:16:21 <nulldata> So: `liveness :: Liveable a => Block a -> [LivenessBlock (Var a)]`?
04:16:31 <geekosaur> yes
04:16:35 <nulldata> Ah, thanks!
04:17:57 <Booba> ertes: Ok. Do I get it right that the need for STM comes from the fact that I have green threads processing my connections?
04:18:32 <ertes> Booba: no, STM is an abstraction for transactional mutable variables
04:18:47 <ertes> there is no *need* to use it
04:19:54 <ertes> Booba: you should probably read The Book
04:19:56 <ertes> http://chimera.labs.oreilly.com/books/1230000000929/
04:20:13 <Booba> ertes: Ok, thanks. I'll dive into that, then.
04:20:16 <Booba> ertes++
04:20:22 <ertes> particularly the concurrency part
04:20:44 <ertes> so from chapter 7 onward
04:24:35 <Booba> ertes: I imagine my game API looking like this http://lpaste.net/354006. So there is a Game data type that is a Monad, am I right? Or this is a not a good way do design a module?
04:25:18 <ertes> Booba: i suggest that you don't try to model an "application monad"
04:25:23 <ertes> just use IO
04:25:43 <ertes> and where applicable Consumer/Producer/Pipe over IO
04:26:36 <ertes> (or whatever your favourite streaming abstraction calls them)
04:27:54 <Booba> ertes: I can do that, or at least, I'll try. But I wonder what the next step might be? How do I generalize that? How do I hide the fact that I use IO underneath?
04:28:16 <ertes> Booba: first try to come up with a valid reason why you would want to hide it
04:28:34 <ertes> "IO is evil" is not a valid reason =)
04:28:54 <Booba> ertes: what I am trying to say is, how do I expose only those effects that I want to a potential module consumer?
04:29:36 <ertes> Booba: you will find ways to design a domain-specific language that simply only allows correct APIs
04:29:48 <ertes> until then you can just not export certain parts of your module
04:30:11 <ertes> Booba: if you want, i can give you an exercise
04:30:17 <Booba> ertes: I'd love to!
04:30:43 <ertes> Booba: write the classic game of hangman, just a simple command line program that communicates via stdin and stdout
04:31:12 <ertes> don't even limit the number of guesses the player has, just let them guess until they have all the letters
04:31:44 <ertes> once you have it, i will show you many ways to improve it (none of which involve monads) =)
04:31:53 <Booba> ertes: like this one https://en.wikipedia.org/wiki/Hangman_(game) ?
04:32:02 <ertes> yeah, exactly
04:32:37 <ertes> display "_____ _____", ask for a letter, fill in the blanks: "__ll_ ___l_"
04:32:54 <ertes> ask again, until the phrase is complete
04:33:18 <Booba> ertes: Ok, I'm on it, then. I thank you for your effort so much!
04:38:15 <ski> @where PCPH
04:38:15 <lambdabot> http://community.haskell.org/~simonmar/pcph/
04:38:37 <ski> @where+ PCPH "Parallel and Concurrent Programming in Haskell" by Simon Marlow in 2013 at <http://community.haskell.org/~simonmar/pcph/>,<http://chimera.labs.oreilly.com/books/1230000000929/>
04:38:38 <lambdabot> I will never forget.
04:41:49 <ertes> where+ TheBook …
04:41:50 <ertes> =)
04:57:27 <ph88> can someone recommend a package for handling server side for single-page-app ?
04:57:34 <ph88> maybe a REST package
04:57:44 <brynedwards> ph88: servant, Spock, scotty
04:58:55 <ph88> what are the differences between those 3 ?
05:00:04 <brynedwards> servant is more focused on API features, the other two are more generic lightweight web frameworks
05:00:17 <ph88> what do you mean API features ?
05:00:23 <brynedwards> Spock is based on scotty, it has some more features like a DB helper
05:00:54 <cocreature> servant also uses significantly more typelevel magic
05:01:09 <ph88> is that a good thing? :P
05:01:35 <cocreature> that depends on your point of view :)
05:01:42 <ph88> i don't have one yet :/
05:01:52 <cocreature> then try it out and decide for yourself :)
05:02:01 <ph88> servant seems a bit more mainstream
05:02:05 <ph88> maybe i should go with that
05:02:05 <brynedwards> Check out servant's tutorial http://haskell-servant.readthedocs.io/en/stable/tutorial/index.html
05:02:13 <ph88> i saw it mentioned more often and it has more commits
05:02:16 <quchen> ph88: There are multiple talks by Alex Thiemann about Spock, e.g. from last year’s ZuriHac
05:02:23 <quchen> ph88: (he’s the author)
05:02:30 <ertes> ph88: they are all fairly popular
05:02:54 <ph88> ok i try spock
05:03:11 <ertes> ph88: scotty and spock are just much simpler, but servant has some type-driven features they lack
05:03:44 <ertes> particularly for people who would like to derive clients and servers from the same piece of code
05:04:00 <ertes> so if you plan to use GHCJS for your frontend, servant is probably the best option
05:05:17 <ph88> probably elm or otherwise purescript
05:07:18 <cocreature> I just wish servant stopped using ExceptT :/
05:09:56 <ph88> so i compile the spock app and run it and it's a webserve r?
05:10:07 <cocreature> ph88: yep
05:10:19 <cocreature> ph88: it’s the same for pretty much all Haskell web frameworks
05:10:44 <ph88> how can i let it do work on the CLI ?  for the user i need the webinterface but i want to do some tasks with CLI
05:10:59 <ph88> import files should happen from CLI, view files from webinterface
05:11:23 <ph88> or should i let the compiler make 2 binaries for that ?
05:14:45 <cocreature> unless you have a good reason for embedding a cli and a webserver in in the same executable, I would use separate executables
05:14:56 <ph88> ok
05:15:41 <ertes> ph88: you can either have a (web?) API used by a separate CLI program, or you can fire up a CLI thread
05:15:43 <ph88> would it be a good idea to put the two executables in the same project or is it better to create separate stack projects ?
05:16:26 <ph88> a CLI thread ?
05:16:47 <gguy> Is there a fundamental reason why type literals are kinds? Currently I can embed string information into datatype like this: 'type CRLF = Proxy "\r\n"' but I'd rather do this: 'type CRLF = "\r\n"'
05:16:51 <ertes> ph88: if you want the executables to be in separate cabal packages, you probably need three packages: a common API package, a server package and a client package
05:17:17 <ph88> ertes,  i like to keep it as simple as possible, quick n dirty
05:17:35 <cocreature> gguy: type CRLF = "\r\n" should work just fine
05:17:42 <ertes> gguy: there is no value of type "\r\n", so you need the proxy (or explicit type signatures) to pass the type information around
05:17:59 <cocreature> gguy: they are not also not kinds. their kind is Symbol
05:18:02 <ertes> gguy: otherwise you would have to type:  f (Proxy :: Proxy CRLF)
05:18:18 <ertes> with the first verison you can type:  f (Proxy :: CRLF)
05:18:49 <ertes> ph88: it's up to you…  you can write a package that includes a library and two executables that use that library
05:19:30 <ph88> ertes, a library ? you mean a haskell module file ?
05:19:40 <ertes> ph88: a 'library' section
05:19:53 <ph88> in the cabal file ?
05:19:57 <ertes> yes
05:20:17 <gguy> cocreature: Symbol, yes... I'm still getting my head around that :)
05:20:34 <ph88> how do i find out how i can make the cabal file so that it has a library and two executables that use that library ?
05:21:08 <ertes> ph88: here is my project skeleton: https://github.com/esoeylemez/skeleton/blob/skeleton/skeleton.cabal
05:21:16 <cocreature> ph88: https://cabal.readthedocs.io/en/latest/developing-packages.html#developing-packages read the cabal docs :)
05:21:36 <cocreature> ph88: https://cabal.readthedocs.io/en/latest/developing-packages.html#example-a-package-containing-a-library-and-executable-programs is an example of exactly that
05:21:45 <ph88> ertes, how does this compare with the CLI thread option on difficulty of coding ?
05:21:57 <gguy> ertes: sure yes I'm using Proxy at the moment, I was just hoping I'd missed some work around to allow Strings as types
05:22:06 <ph88> cocreature, ok thx i read the docs
05:22:07 <ertes> ph88: the separate executable option definitely needs more engineering
05:22:25 <ertes> because you can't just access the state of the running thread, but you need to design an actual run-time API for communication
05:22:34 <ph88> ertes, ok let's not go with the separate executable option then :/
05:22:37 <cocreature> gguy: I’m repeating myself but they _are_ types. 'type Foo = "foo"' works just fine
05:22:53 <msl09> hello I have a question about type class instances
05:22:58 <cocreature> gguy: if it doesn’t you might need to enable DataKinds or upgrade GHC
05:23:01 <ph88> how do i find out how the option works with the separate CLI thread ?
05:23:09 <msl09> in learn you a haskell http://learnyouahaskell.com/making-our-own-types-and-typeclasses#typeclasses-102
05:23:19 <gguy> sure cocreature it works
05:23:33 <ph88> msl09, go ahead
05:23:33 <gguy> I probably shouldn't use that example
05:23:37 <ertes> ph88: well, have the web server in a separate thread, and let your main thread be the CLI
05:23:47 <gguy> data CRLF = CRLF "\r\n"
05:23:58 <msl09> it is said that this eq instance declaration is invalid:
05:23:59 <msl09> instance Eq (Maybe m) where       Just x == Just y = x == y       Nothing == Nothing = True       _ == _ = False  
05:24:26 <ertes> msl09: you say x == y, where x and y are of type 'm'
05:24:33 <ertes> but there is no Eq constraint on 'm'
05:24:39 <cocreature> gguy: that fails because the _kind_ of "\r\n" is Symbol but a data declaration expects things of kind *
05:24:40 <msl09> yeah
05:24:57 <ertes> msl09: instance (Eq a) => Eq (Maybe a) where …
05:25:20 <ertes> msl09: values of type (Maybe a) can only be compared, if values of type 'a' can be compared
05:25:23 <cocreature> that error message is really confusing.
05:25:39 <msl09> but doesn't a Just x == Just y = x == y implies that x and y must be instances of Eq?
05:25:44 <gguy> cocreature: yes which is a feature of datakinds, was hoping there was a seperate extension that was of kind *
05:26:09 <ertes> msl09: no, they *need* the type of x and y to be Eq
05:26:10 <cocreature> gguy: what do you expect data CRLF = CRLF "\r\n" to do? what should the constructor store?
05:26:11 <gguy> but I guess that would be confusing
05:26:20 <gguy> nothing
05:26:21 <ertes> msl09: but your instance is claiming that no Eq on 'm' is necessary
05:26:42 <ertes> msl09: example:
05:26:44 <ertes> blah :: a
05:26:46 <ertes> blah = 5
05:26:51 <ph88> msl09, you should let haskell know that logically when you want to compare some stuff inside Maybe  that the stuff inside can be compare in the first place. So   Eq m   says that  m  is everything that has a compare function (implemented by the Eq type class)   and then in    Eq (Maybe m)    m can not by EVERYTHING anymore, it can only be everything THAT CAN BE COMPARED
05:27:16 <ertes> msl09: the type signature claims that 'blah' can be *anything*, but then it requires 'a' to be a Num instance
05:27:37 <geekosaur> msl09, when you specify a type for something, it overrides type inference and is considered the final authority. so if it does not specify Eq m =>, it is saying that m does not need an Eq instance.
05:27:53 <asthasr> Are there any good articles about how practical servant is versus more traditional (i.e. not type-level) frameworks? Or perhaps in other contexts where TL programming is used vs. a more traditional alternative
05:28:06 <asthasr> I don't feel that I have a really good grasp of the benefits of type level programming, so I'm interested.
05:28:15 <ph88> msl09, yes you are right that   ==   implies that x and y must be able to be compared, but for some reasons you must be explicit about this. This is a design choice of GHC that this is not automatically accepted
05:28:56 <msl09> I think I undestand geekosaur definition
05:29:05 <ertes> msl09: type sigantures aren't automatically augmented by extra information from the actual definition
05:29:12 <ertes> so if you say (blah :: a), then you mean it
05:29:14 <msl09> ic
05:29:16 <ertes> blah can be anything
05:29:18 <gguy> cocreature: I'm deriving parsers using GHC generics from data types where "instance (KnownSymbol a) => Parser (Proxy a) where parser = parseString $ symbolVal (Proxy :: Proxy a) "
05:29:39 <ertes> and the compiler disagrees, because it actually checks the definition against your type signature
05:30:21 <ph88> ertes, when i start that program (with cli and web thread) i guess i want it to go run the webserver .. but then how do i enter CLI commands? in a REPL like fashion? normally CLI are just one-off commands and the program terminates after each command
05:30:58 <geekosaur> you can have it listen for commands from some other channel, or you can have the CLI connect to the web server and send commands that way
05:31:08 <nulldata> Hey, how would I go about constraining an associated type (For example making sure it's Eq)?
05:31:10 <geekosaur> usually for a web server the latter is easier
05:31:18 <gguy> cocreature: then using ghc generics I can parser the "or" case e.g. 'data LineEnd = CRLF (Proxy "\r\n") | LF (Proxy "\n")'
05:31:40 <gguy> anyways, just an idea i want to play out to completion... using proxy makes things abit messy
05:31:41 <cocreature> gguy: I think what you really want is singletons for Symbols instead of the weird KnownSymbol stuff & proxies. I’ve wanted this myself several times so I can definitely empathize with that feeling :)
05:31:58 <ph88> geekosaur, just asking where the commands from the other channel should come from ..  i know i want to type them in my terminal .. other than that not sure
05:32:39 <gguy> yeah, I went the singletons route but the instances bloated the code out to be more bloated then I'd hoped
05:33:20 <ph88> msl09, type classes can be used for what is known as generic programming in other languages, it took me a while before i figured that out .. just saying cuz that info is not in LYAH
05:33:21 <ertes> ph88: if you want the program to be batch-style, you *need* an API
05:33:38 <ertes> ph88: note that you can have both the web server functionality and the command-line API in the same executable
05:33:40 <cocreature> gguy: it’s kind of annoying how we have all those fancy features but using them can become painful quite quickly
05:33:56 <migimunz> Hi everyone. I'm writing a parsec parser for a toy haskell-like language for fun, and I'm having a bit of trouble with indentation. I can't get a parser to stop parsing when the next line is "dedented", it attempts to continue parsing greedily. Here's a short example if someone can take a look: https://gist.github.com/migimunz/3fc30b6b6a4005626edfe745844b65fb
05:34:13 <ph88> ertes, but if the web server is running should i launch another process of the same executable ?
05:34:24 <ph88> not sure what you mean with batch-style
05:34:28 <msl09> ph88, geekosaur, ertes does that mean that there is no type inference for type declarations?
05:34:47 <ertes> ph88: let's say your executable is named 'blah'
05:34:59 <ertes> ph88: then you can have a "blah daemon" command that runs the actual web server
05:35:14 <gguy> cocreature: the real goal is I want to rewrite an application that parses binary, can reproduce the binary, and also produce that in HTML form
05:35:18 <ph88> msl09, the types are infered but the constraints are not infered as far as i know
05:35:21 <ertes> and then you can have "blah quit" that perhaps connects to some unix socket created by the daemon and tells it to quit through a JSON API
05:35:57 <ertes> msl09: as geekosaur said, inference does not apply if you write a type signature, and for instance you *always* write a full instance head
05:36:07 <ertes> msl09: so for instances you *must* be explicit about the constraints
05:36:14 <ph88> msl09, another thing i found out later is that the  =>  notation is very closely related to logic programming, it wouldn't hurt to read this page for example  http://www.learnprolognow.org/lpnpage.php?pagetype=html&pageid=lpn-htmlse1  and then realise that  =>  is VERY closely related
05:36:31 <ertes> msl09: it's not that inference doesn't infer it (it could), but that inference isn't used at all
05:36:36 <geekosaur> msl09, there's an extension in ghc8 that allows partial type signatures with missing parts inferred. I would recommend against using it unless you fully understand the type system
05:36:44 <lyxia> migimunz: can you give us more context.
05:37:16 <migimunz> lyxia, I can paste the whole thing sure, I just hoped that gave a minimal example. Sec
05:37:27 <msl09> geekosaur: actually I just wanted to know what to watch out for :]
05:37:29 <ph88> ertes, ah so communicate through unix pipes ?  but then it's still 2 processes and not CLI thread right ?
05:37:34 <geekosaur> ph88, unless your system can deal with changes made from outside such that the CLI can do things by itseldf (this is uncommon and highly error-prone), your CLI *must* send commands to the server
05:37:48 <migimunz> lyxia, here it is: https://gist.github.com/migimunz/dcfa6a2f85ce46003bda75d52bfec04d
05:38:02 <ertes> ph88: yes
05:38:06 <gguy> cocreature: I already have the application in a working state but it's a pain to maintain both parsers, printers, and html generators. Not to mention the filtering etc I want to do. GHC generics gets me closer since I can generate a generic HTML version of the data (then just style with css). But the parser is abit trickier to define using instances in some generic way since every singleton is a separate instance
05:38:10 <ertes> ph88: and more likely sockets, not pipes
05:38:13 <migimunz> I'd also appreciate any other advice you can give, I've read in places that Parsec is no longer actively developed and that there are other alternatives like megaparsec or attoparsec, but I don't really have much experience
05:38:46 <ph88> ertes, ok it seems simple .. but i'm still curious .. how would the CLI thread option work ?
05:38:49 <ertes> ph88: keep in mind that by using unix sockets you give up portability to some systems (e.g. windows)
05:38:52 <gguy> cocreature: anyways thanks for the help... that's my rant for the night
05:39:17 <ertes> ph88: well, with the CLI thread the idea is that your program starts the server and the provides a REPL during its run-time
05:39:48 <lyxia> migimunz: that's better
05:40:30 <geekosaur> ph88, note that that means your program does not run as a daemon, it starts up the web server component and then issues a prompt on the terminal you started it from. if you don;t start it from a terminal, you can't use its prompt
05:40:40 <migimunz> lyxia, thing is, I get why it's doing it - I have a many1 that attempts to parse type or var names greedily, and that just consumes whatever it can until it says "oh wait, this isn't a type/var, and isn't properly indented"
05:40:49 <ertes> ph88: something like this: main = withDB … $ \db -> withAsync server $ \s -> repl `finally` (cancel s >> wait s)
05:40:54 <migimunz> wish I could express "until dedent" somehow
05:40:56 <ph88> migimunz, i investigated a bit on megaparsec and attoparsec, attoparsec is better for things that are generated by a machine (such as export scripts or APIs) and megaparsec better for human written things (like source code) .. because attoparsec is much faster but it can not track the position in the source very well
05:41:57 <migimunz> ph88 I'll check out megaparsec as well. I don't mind scarce docs that much, but with these it's sometimes impossible to tell what functions do just by looking at the types
05:42:30 <ph88> ertes, ah yes ok so i have 3 options,   2 executables, 1 executable run multiple times, 1 executables with threading ... i think the second option might be the most simple one
05:42:39 <ertes> migimunz: if you don't mind scarce docs, have a look at trifecta as well =)
05:42:54 <geekosaur> ph88, it's not necessarily easier, it can be much harder
05:43:19 <ertes> ph88: in terms of engineering simplicity the third option is definitely the easiest one
05:43:25 <geekosaur> do the two instances running each have to know about any changes the other has made? if so, that second solution will be much harder
05:43:30 <geekosaur> and much easier to get wrong
05:43:43 <cocreature> ph88: do you have some database or some other external data store?
05:43:54 <ph88> yes elasticsearch and maybe sqlite if i need it
05:43:58 <cocreature> then it’s pretty easy to have multiple executables because you don’t need to reinvent ipc
05:44:04 <ph88> ok
05:44:07 <migimunz> ertes, checking it out, thanks :D
05:44:16 <cocreature> just have both applications write/read to a database and everything should be fine
05:44:32 <ph88> so i read the section in the cabal manual to make 2 executables and then do the stuff on elasticsearch
05:44:37 <ph88> ok
05:44:38 <ertes> ph88: BTW, if your commands only need to do data changes, then having a separate executable is not only easy, but in fact preferred
05:44:44 <ph88> ok
05:44:49 <ertes> ph88: because it doesn't actually need to know anything about the running web server
05:44:55 <ph88> yeah
05:45:16 <ertes> of course you can still get this wrong, if the web server and the CLI disagree on data consistency
05:45:31 <nulldata> How would I go about constraining an associated type (For example making sure it's Eq)?
05:45:57 <ertes> nulldata: instance (Eq (F a)) => C a where type F a = …
05:48:57 <ph88> migimunz, shouldn't parseTypeDeclaration fail when sameOrIndented fails ? why do you think it tries another time with many1 ?
05:48:58 <nulldata> ertres: Uhn, how about for a associated type in a type class (https://ctxt.io/2/AAAA0EUhEg) or am I misunderstanding your snippet?
05:49:43 <geekosaur> what part of that snippet is confusing you?
05:50:06 <geekosaur> instance Eq (Var a) => Liveable a where type Var a; ...
05:50:28 <nulldata> Oh I see
05:50:28 <geekosaur> (you no longer need the (:: *) because the Eq instance forces that)
05:51:28 <lyxia> migimunz: you don't ever set the level of reference
05:51:39 <lyxia> do you?
05:52:34 <migimunz> lyxia, I thought withPos does that
05:53:35 <nulldata> So like this? (https://ctxt.io/2/AAAAAK4MFA)
05:53:35 <migimunz> ph88: it does fail, but also says unexpected '=' on line 7, column 3
05:53:36 <migimunz> that's what had me confused
05:54:08 <lyxia> oh I'm blind.
05:54:12 <gguy> oh, anyone know of any haskell that defines all (or most) singletons for all the chars?
05:54:30 <geekosaur> hm, actually I wonder if that's true still
05:54:33 <geekosaur> :k Eq
05:54:34 <lambdabot> * -> Constraint
05:54:41 <geekosaur> ok
05:54:54 <migimunz> lyxia, to be honest I don't really know how indentation based languages are supposed to be parsed - when I used to do it manually a long time ago, I made my tokenizer emit separate INDENT and DEDENT tokens, which is probably not an ideal approach
05:55:20 <migimunz> then I just treated them like regular tokens in the parser, but that was a lot less complicated language as well
05:55:31 <codedmart> Is there an extension or a way to do somethin like this? https://gist.github.com/codedmart/b768414e5025de7625819066ff58f4ec
05:55:32 <ph88> migimunz, when it fails you need it to backtrack on the parts that it had already consumed. So when you expect  ABC  and you have ABDD  then it eats  AB and leaves you with DD  then the next parser is confused why it starts with DD and not  ABDD    so look for "try" function
05:55:52 <nulldata> Well what I posted is not right, I get a syntax error..
05:55:53 <lyxia> migimunz: you're setting the reference at the start of the line though
05:56:14 <migimunz> ph88: hm, I did leave off try for the last alternative
05:56:18 <ph88> migimunz, i think identation is tracked within the state of the parser, but i'm not sure
05:56:26 <migimunz> ph88: it is, yeah
05:56:35 <ph88> migimunz,    many1 $ try myParser         maybe this
05:56:47 <migimunz> lyxia, yeah, I don't necessarily want it to be indented past the data keyword, just mode than the start of the line
05:56:53 <geekosaur> codedmart, you would not normally use case for that, case is about structure not values
05:56:53 <migimunz> ph88 thanks, trying it now!
05:57:27 <geekosaur> codedmart, if you want to do that, use guards
05:57:49 <geekosaur> don't try to twist case expressions to do values instead of structure
05:57:55 <migimunz> ph88: nope, same thing :/
05:57:57 <codedmart> geekosaur: Good point I guess I was overlooking that.
05:57:59 <codedmart> Thanks!
05:58:23 <migimunz> reading megaparsec docs too, there's a blog post claiming that it has support for indentation based languages, should probably investigate
05:58:43 <migimunz> or should stop being lazy and read the actual source of the parser to understand what's going on under the hood
05:59:09 <lyxia> migimunz: change line 110 to fields <- (sameOrIndented *> (simpleTypeExpr <|> nestedTypeExpr)) `sepBy` spaces
05:59:55 <lyxia> this checks in every field whether you're still in the same block
06:00:00 <migimunz> lyxia, thank you! That worked, now I just have to figure out why
06:00:02 <migimunz> aah
06:02:02 <migimunz> lyxia, oh I see what you mean, it basically does the sameOrIndented check for every separated element and discards the ()
06:02:09 <migimunz> thanks a lot lyxia, ph88
06:09:27 <lpaste_> gguy pasted “StateT Int Parser Trace” at http://lpaste.net/354012
06:10:12 <gguy> migimunz: if you give up on using something existing you could always just store the indent info in StateT (code above)
06:10:33 <gguy> migimunz: that's some code I have using attoparsec
06:11:04 <gguy> not for indent ofcourse, but could mold to your need
06:22:22 <migimunz> gguy: I was hoping to avoid having to do that by picking up a library that does exactly that sort of thing for me - unfortunately, using it proved a bit trickier
06:22:31 <migimunz> well, coupled with the fact that I'm not all that familiar with Parsec
06:25:35 <Phillemann> Is there a haskell type for HTML data? I'd like to create HTML programmatically and convert it to a bytestring (or something) later.
06:25:52 <Phillemann> I mean, not in the Prelude, of course.
06:27:10 <ezyang> There's xhtml 
06:27:23 <ezyang> that's an old library. There are newer ones too, I think 
06:27:59 <ahihi> @hackage lucid
06:27:59 <lambdabot> http://hackage.haskell.org/package/lucid
06:28:25 <Phillemann> Ah, thanks.
06:33:14 <lush_> hey everyone, is there a nixos user here?
06:33:55 <gguy> lush_: I'm a nixos noob :)
06:34:12 <lush_> gguy: me too I installed it yesterday ^^
06:34:30 <gguy> haha, good luck
06:34:31 <rom1504> you only had one question, it has been answered
06:34:34 <lush_> gguy: I don't really get how I should start haskell projects using cabal + nix-shell.. have you got some advice? :-D
06:34:50 <rom1504> :d
06:35:20 <lush_> gguy: to be more precisely I thought about playing around with hakyll and start a little website where I can toy with its features
06:36:15 <gguy> lush_: yes, there are a few different ways people do it, but for the most part nix replaces vast amounts of what you might use cabal for
06:37:48 <gguy> basically when I want to bring up an environment to compile I do a "cabal2nix --shell > shell.nix; nix-shell" if i typeds that correctly
06:38:13 <gguy> hakyll... 2 secs let me look
06:38:29 <lush_> gguy: so you start a project and add a cabal file etc first and then use cabal2nix to get it running with nix-shell?
06:39:51 <gguy> yes, nix-shell paths all the required dependencies listed in the shell.nix file (which were derived from the cabal file)
06:40:40 <gguy> the trickiest part will be getting your favorite ide working... if you use emacs you might find it easier
06:41:56 <lush_> so I start "a usual cabal" project with cabal files etc and then let that get translated through cabal2nix? 
06:42:02 <lush_> how about atom? :-D
06:42:48 <gguy> lush_: did  you work out how to install hakyll in nixos?
06:46:37 <gguy> lush_: don't know about atom
06:46:54 <gguy> lush_: yes create a cabal file as normal and run cabal2nix
06:47:40 <gguy> lush_: eventually you will get to the stage where u think it's wise to not use cabal at all, which is true, but editor will like it better when there is a cabal file
06:48:41 <gguy> lush_: if you want to install directly to your envionment you can run: nix-env -f "<nixpkgs>" -iA haskellPackages.hakyll
06:52:21 <lush_> gguy: I thought that I could set up nix-shell to download ghc, hakyll etc just within that sandbox?
06:53:02 <gguy> yep absolutely
06:53:50 <lush_> gguy: so I start that like: nix-shell -p haskellPackages.hakyll ?
06:55:24 <gguy> lush_: yep
06:55:51 <gguy> lush_: can add atom in there too etc
06:56:24 <lush_> gguy: and then I've got ghc etc in there as well. Can I start like this and when I realize that I need another packages as well just "reenter" that environment through the same command with the package added?
06:56:56 <gguy> lush_: sure
06:57:05 <lush_> alright cool thanks man
06:57:17 <msl09> I have another newbie question
06:57:24 <gguy> lush_: good luck :)
06:57:37 <msl09> when learning about Functors I mistyped a statement
06:57:43 <msl09> Prelude> fmap (*2) Just(1)
06:57:51 <Booba> ertes: Hi, here's what I came up with http://lpaste.net/354013
06:57:53 <KorriX> Hello! - Is there a way to get a type-level list of all function argument types? For example if f :: Int -> Char -> Bool I'd like to get '[Int, Char] on the type level
06:58:06 <msl09> and ghci yelled at me "Non type-variable argument in the constraint: Num (Maybe t)"
06:58:16 <Cale> msl09: right.
06:58:22 <msl09> what does ghc believes I trying to do?
06:58:33 <Cale> Because that'd be ((*2) . Just) 1
06:58:52 <Cale> You're using the Functor instance for (->) e
06:59:04 <Cale> fmap :: (a -> b) -> (e -> a) -> (e -> b)
06:59:06 <Cale> in that instance
06:59:14 <vaibhavsagar> hey, I have a question about a free monad thing: http://lpaste.net/9158315209444556800
06:59:15 <msl09> I was actually trying to do "fmap (*2) (Just 3)"
06:59:15 <Cale> and that's just function composition
06:59:21 <Cale> yeah
06:59:40 <Cale> So, it complained at you because what you wrote is equivalent to (Just 3) * 2
06:59:52 <msl09> hmm
07:00:32 <msl09> huh
07:00:44 <Cale> > fmap (*10) (+5) 1
07:00:46 <lambdabot>  60
07:01:02 <Cale> > fmap reverse (map toUpper) "hello"
07:01:04 <lambdabot>  "OLLEH"
07:01:30 <Cale> fmap can specialise to function composition
07:01:38 <Akii> vaibhavsagar: change `value` to `Maybe value` in line 7?
07:01:41 <ertes> Booba: does it work?
07:01:48 <Booba> ertes: it does
07:02:16 <Booba> ertes: running on Haskell2010
07:02:21 <ertes> Booba: great =)
07:02:54 <Akii> vaibhavsagar: or `set "ref2" (Just v)`
07:03:10 <ertes> Booba: right now i'm too busy, but i can offer you to help you improve it interactively later, or i can just show you my variant and explain it later
07:03:36 <lush_> gguy: I'm still a little bit confused. in #nixos they told me that I don't need to install cabal at all (I think) and only use it within a nix-shell
07:03:58 <lush_> gguy: so I really write down a .cabal manually to start and then give that to cabal2nix
07:04:08 <Booba> ertes: I'd like to see yours and try to figure out your thought process while you are busy
07:04:09 <vaibhavsagar> Akii: I didn't realise it was that simple :)
07:04:24 <ertes> lush_: if you pass --shell to cabal2nix, it will generate an expression that is compatible with nix-shell and nix-build
07:04:37 <ertes> Booba: https://github.com/esoeylemez/snippets/blob/master/Hangman.hs
07:04:38 <Akii> vaibhavsagar: pretty neat and compact example, thanks for that
07:04:53 <Booba> ertes: Thanks a lot!
07:05:52 <ertes> Booba: high-level explanation: a hangman game is either a game that is already won (Won), or something that presents a challenge and expects a guess (Guess)…  hangman games turn out to be a monoid, so they can be composed from single-character games (singleton)
07:06:02 <lush_> ertes: ok ty
07:06:23 <ertes> Booba: and then there is an interpreter that actually runs the game and interacts with the user
07:06:26 <ertes> hangmanStdio
07:11:30 <ertes> Booba: this approach is: 1. compositional (hangman games are constructed by composition), 2. composable (games are first-class), 3. extensible (games form a monoid and there are monoid morphisms to and from it), 4. separation of concerns (game logic vs. user interface)
07:21:42 <Booba> ertes: to start a game I have to run hangmanStdio parametrized with functions to parse/serialize from user input and a constructed single ton that knows how to figure out wether a games is won?
07:24:19 <ertes> Booba: hangmanStdio abstracts over a parser, a printer and a game
07:24:42 <ertes> hangmanStdio_ (fromString "Hello World")
07:27:19 <ertes> and that's just short-hand for:  hangmanStdio_ (char 'H' <> char 'e' <> char 'l' <> …)
07:52:04 <Booba> ertes: I can't [ut my finger on what Guess contructor second parameter stand for?
07:58:31 <[k-> from what I can make out of it, it's a lambda that checks if a given input is correct
07:59:18 <[k-> and return a new game state?
08:00:57 <infandum> Let's say I have a function with "do" syntax. After each binding, I want to print "step 2" then "step 3" etc. How can I have it print when the binding actually finishes? I assume I would have to lose laziness then.
08:03:24 <phz_> hey, imagine I have several packages which I’d like to generate the doc and put all of them in a centralized place (haddock)
08:03:28 <phz_> how can I do that with stack?
08:03:35 <phz_> I invoke stack haddock on all projects
08:03:37 <phz_> then…? :)
08:04:54 <Geekingfrog> phz_: create a stack project with all those projects as dependency and run stack haddock on this project ?
08:07:18 <brynedwards> To view the docs: cd $(stack path --snapshot-doc-root)
08:15:29 <cocreature> infandum: just insert a print statement on the next line?
08:17:54 <bjs> infandum: do you have code that isn't working that you tried?
08:22:57 <phz_> Geekingfrog: brillant :D
08:26:22 <robertkennedy> Why is the state Monad `a -> (b,a)` vice `a -> (a,b)`?
08:27:01 <glguy> robertkennedy: It's arbitrary, it works to implement it either way.
08:27:34 <glguy> and the difference isn't distinguishable to the user of the State type
08:30:19 <robertkennedy> Sure, but with the other version you have `fmap = fmap . fmap`, which seems like enough reason to prefer it if there is no other convenience from the actual rep
08:31:04 <msl09> ghc complains about this type declaration "func :: (b->c) Either a b -> Either a c"
08:31:11 <glguy> Yeah, that's handy, but it doesn't really matter since you don't have to implement fmap manually for it
08:31:25 <rotaerk> msl09, yes, that's a bad type signature
08:31:28 <glguy> msl09: You can't apply the type (b->c) to Either
08:31:57 <msl09> aw frigg
08:32:01 <msl09> I forgot an arrow
08:32:05 <msl09> sorry guys
08:35:38 <NickHu> Just wondering, do many people here use halcyon for deployment? I went to look at the tutorial but it's dated two years ago...
08:38:47 <ExpHP> I require somebody well-versed in magical runes
08:38:57 <ExpHP> I had a script which looks like this:
08:39:06 <ExpHP> stack runghc --package=hex Shakefile.hs "$@"
08:39:17 <ExpHP> ...and now I want it to have stack traces
08:40:21 <ExpHP> I think my furthest attempt so far involves two scripts;
08:40:43 <ExpHP> stack exec --package=hex -- runghc -f the-other-script Shakefile.hs -- "$@"
08:41:13 <ExpHP> where "the-other-script" is: ghc -prof -with-rtsopts=-xc "$@"
08:41:39 <ExpHP> but this complains about hex being a hidden package, as if I weren't using stack exec
08:41:50 <ExpHP> _/o\_
08:42:37 <ExpHP> (pretty much any layer I remove from that script sandwhich results in the rts opts going to the wrong thing)
08:44:47 <Reisen> I'm trying to derive JSON on an associated data family, but I get template haskell errors: deriveJSON ''(Foo X)
08:44:58 <Reisen> Is there a trick to work around this?
08:45:17 <Reisen> Seems it expects a name but the space in the data family screws with this
08:46:16 <glguy> Reisen: Try using deriveJSON on the data constructor for your data family instance
08:47:16 <Reisen> glguy there's several, will it get me something equivelent just doing deriveJSON ''XA; deriveJSON ''XB?
08:47:35 <glguy> I don't know. The documentation says "Generates a ToJSON instance declaration for the given data type or data family instance constructor."
08:47:39 <infandum> cocreature: That works? I get things at wrong times though. For instance, it might print "step 2" and "step 3" even though the process inbetween did not finish. I would need to create an example though.
08:47:51 <Reisen> glguy, I see, let me try it out
08:48:42 <cocreature> infandum: it depends on what you mean by “finished”. you’re probably right that an example would help at this point
08:51:16 <Reisen> glguy that worked, that is insanely unintuitive though, but nice to have a solution
08:52:04 <glguy> The data constructors are the only names that uniquely identify the particular data family instance, so I'd say it makes a lot of sense to use them for that. I'm glad the docs were right
08:53:02 <Reisen> It makes sense why it needs to work that way, It's just a bit unclear looking at a piece of source code that says "deriveJson 'User" and expect it to derive JSON for the entire data family for a set of user types
08:54:21 <Reisen> data X = X {..}   deriveJSON 'X is OK,     data X = Fst | Snd | Third    deriveJSON 'Fst, less obvious
09:01:10 <infandum> cocreature: Okay nevermind, I just didn't time the functions correctly.
09:17:04 <Geekingfrog> Is there a lifted version of Data.Conduit.BracketP the same way there is a lifted version of bracket?
09:18:20 <Faucelme> A DSL-related doubt. Are "tagless interpreters" the same thing as "intrinsic encodings", described here: http://okmij.org/ftp/formalizations/#intrinsic
09:19:22 <Faucelme> also here: https://people.mpi-sws.org/~gil/publications/typedsyntaxfull.pdf
09:24:59 <ExpHP> So after a 30 minute reinstall of aeson with profiling enabled, here's my beautiful stack trace:
09:25:01 <ExpHP> ^C^CShakefile: out of memory
09:26:21 <cocreature> ExpHP: beautiful! you should print and frame this!
09:28:50 <kadoban> ExpHP: hah
09:30:47 <NickHu> How do you pass environment variables to stack exec?
09:31:46 <ExpHP> cocreature: http://imgur.com/a/Eavlg
09:37:34 <robertkennedy> > mapM (\n -> [n..n+2]) [1..3]
09:37:36 <lambdabot>  [[1,2,3],[1,2,4],[1,2,5],[1,3,3],[1,3,4],[1,3,5],[1,4,3],[1,4,4],[1,4,5],[2,...
09:38:05 <robertkennedy> What do those represent?
09:38:53 <robertkennedy> Oh, it's like each value for 1 with each value for 2 with each for 3. Got it
10:12:51 <Tre> Hey all
10:13:32 <mmachenry> Hi
10:13:47 <Tre> how are you?
10:13:54 <mmachenry> Good you?
10:14:03 <Tre> Good thanks :P
10:14:18 <Tre> Just getting into Irc
10:14:33 <mmachenry> Welcome. Are you already into Haskell?
10:15:15 <Tre> Just started getting into that aswell
10:15:19 <Tre> :P
10:15:29 <mmachenry> Enjoy!
10:15:39 <Tre> Thanks :P
10:23:28 <infandum> cocreature: NO! I was right! It
10:23:56 <infandum> It's the laziness issue I think: 'x = sum [1..1000000 (big number)]'
10:24:18 <infandum> 'do { print "hi"; y <- return (x + 3); print "man"; return y }'
10:24:34 <infandum> That will print "hi" and "man" even though x was not evaluated
10:25:06 <infandum> so y would not be evaluated and thus it looks like return y takes a long time but in reality x is what takes a long time.
10:29:26 <glguy> That's right 'y <- return (x + 3)' just binds the unevaluated expression 'x + 3' to the name 'y'
10:29:32 <infandum>  I understand now what the problem is, but now I don't know how to fix it. Is there a way to tell the user what "step" in a do function the program is at?
10:29:42 <cocreature> infandum: well that’s how lazyness works. if you want to force the evaluation you can do so using "evaluate" and maybe some deepseq
10:29:45 <infandum> glguy: Yeah, that's now my issue
10:30:03 <Squarism> anyone got some recomendation if you just want simple variable text-file-templating 
10:30:21 <infandum> cocreature: I'm unsure about that though, because I don't know if it's worth sacrificing performance just to let the user know the current step.
10:30:29 <infandum> (or memory)
10:31:00 <cocreature> infandum: that’s probably a decision you’ll have to make for yourself :)
10:31:05 <infandum> :(
10:31:35 <ExpHP> x_x okay, I've stuck traces literally everywhere I can in my program and I still can't figure out where it's getting stuck in a loop
10:31:40 <infandum> cocreature: Then how do programs like System.ProgressBar work? Would they just print out the entire bar at the end? It must have a use case I'm missing.
10:33:20 <cocreature> infandum: IO will be executed immediately (unless you play dirty tricks) so you can just call "incProgress" somewhere in your program and the progressbar will update
10:34:16 <infandum> cocreature: Ah, ok. I have that to test but it hasn't reached that point yet. I guess I'll need another location for it. Will progress bar slow down the program significantly?
10:34:54 <cocreature> infandum: that depends on way too many factors too answer that question generally
10:35:19 <cocreature> how often do you update it? what kind of calculations does your program perform? …
10:35:55 <cocreature> in most cases I doubt it will significantly slow down your program but if you update the progressbar too often things will slow down
10:36:01 <MarcelineVQ> ExpHP: is it on github?
10:36:29 <infandum> ah. It would print on each increment even though the rounded percentage is the same?
10:37:42 <cocreature> dunno, I haven’t looked at the implementation
10:37:57 <ExpHP> MarcelineVQ not currently
10:38:30 <ExpHP> I could throw something up but it'd probably take too much effort for others to get it running :P
10:39:17 <ExpHP> Hmmmm though I guess the solution to that is the same solution that would help debug it: Minimize it
10:39:19 <MarcelineVQ> ah alrighty, did you want help? because the middle ground is showing code :>
10:39:21 <infandum> cocreature: OK, thanks for your help!
10:40:30 <ExpHP> I guess this is like walking into the DMV without one's diver's license
10:40:34 <MarcelineVQ> people respond best to a question,  "Can anyone tell me why my program loops when I do <the thing that loops>? Here's the runnable code." will get you pretty quick answers around here
10:40:45 <johnw> ExpHP: :)
10:40:58 <Disavowed> Morning all. Tackling 99 Haskell Problems and was wondering: does anyone know of a repo somewhere that has unit tests for all of them? If not, I'll build it myself, but I thought I'd save the work if I could!
10:41:10 <ExpHP> Problem is it's a script that shells out to three half dozen python and bash scripts
10:41:25 <ExpHP> I rewrote it in haskell because I couldn't stand bash any more :)
10:41:46 <frontendloader> Disavowed: think what you're looking for there is integration tests
10:41:52 <ExpHP> aye aye aye guess I'll have to figure something out
10:41:56 <MarcelineVQ> ExpHP: Alrighty then minimizing it like you mentioned sounds like a great starting point
10:41:59 <frontendloader> all you wanna test is the input/output of a compiled program right?
10:48:42 <ExpHP> actually I guess I was hoping for the magic command that tells me where all the hot lines of code are so I can see where it's spinning
10:49:28 <ExpHP> or I guess, "hot CAFs", as it were
10:55:06 <ExpHP> hm yeah as I feared, the Module.prof file is only written when the program finishes, since it's a summary
10:59:02 <Sornaensis> what is the best function
10:59:36 <Gurkenglas_> Is there a neater way to write "\x m -> state $ \s -> fromMaybe (x, s) $ runState m s"?
10:59:47 <ExpHP> undefined; it'll give you anything, and ask for nothing in return (yet it will take what you give it!)
11:00:33 <Squarism> CAnt i just load my "lib" in ghci? It keeps asking for executable?
11:00:42 <Gurkenglas_> absurd; it'll give you anything without even halting, provided you can produce a value from the empty set
11:00:48 <Gurkenglas_> *hanging
11:00:55 <mauke> Sornaensis: fmap fix pure
11:01:20 <ExpHP> ah yes that's a good one.  Gotta love absurd for being total
11:02:49 <t7> @hoogle Data.Set.Set (Data.Set.Set a) -> Data.Set.Set a
11:02:49 <lambdabot> Data.Set splitRoot :: Set a -> [Set a]
11:02:49 <lambdabot> Data.Set.Internal splitRoot :: Set a -> [Set a]
11:02:49 <lambdabot> Data.Set.Monad singleton :: Ord a => a -> Set a
11:02:59 <Sornaensis> mauke: id?
11:03:01 <t7> how is this not a function 
11:03:49 <lep-delete> :t mconcat
11:03:51 <lambdabot> Monoid a => [a] -> a
11:04:13 <t7> tfw haskell prelude is not generic enough
11:04:20 <lep-delete> :t toList
11:04:21 <lambdabot> error:
11:04:22 <lambdabot>     Ambiguous occurrence ‘toList’
11:04:22 <lambdabot>     It could refer to either ‘F.toList’,
11:04:32 <lep-delete> :t Data.Foldable.toList
11:04:33 <lambdabot> Foldable t => t a -> [a]
11:05:12 <t7> my code is already full of toList and fromList
11:05:17 <t7> disgusting 
11:05:20 <lep-delete> :t join
11:05:22 <lambdabot> Monad m => m (m a) -> m a
11:05:30 <t7> is Set a monad
11:05:37 <t7> i did look for Set.join :P 
11:05:38 <lep-delete> not in haskell
11:05:39 <mauke> no
11:05:41 <t7> wrong location
11:05:49 <t7> ah bummer
11:05:52 <lep-delete> :hoogle IMonad
11:07:34 <mizu_no_oto_work> t7: note that (Set a) is both a Monoid (if a is Ord) and Foldable
11:07:34 <mizu_no_oto_work> :t fold
11:07:36 <lambdabot> (Monoid m, Foldable t) => t m -> m
11:08:04 <t7> huh
11:08:07 <lep-delete> there it is
11:08:19 <t7> awesome
11:08:58 <mizu_no_oto_work> Hoogle is a bit unfortunate in that it doesn't track down applicable typeclass functions.
11:09:48 <Gurkenglas_> Doesn't return any type signatures more general than the one asked for either
11:10:08 <mizu_no_oto_work> t7: Set is a monoid under union, if that's what you want
11:10:33 <mizu_no_oto_work> So that's the union of every set in there
11:10:34 <mauke> @hoogle Int -> String
11:10:34 <lambdabot> System.Console.ANSI cursorUpCode :: Int -> String
11:10:34 <lambdabot> System.Console.ANSI cursorDownCode :: Int -> String
11:10:34 <lambdabot> System.Console.ANSI cursorForwardCode :: Int -> String
11:10:45 <t7> mizu_no_oto_work: thats exactly what i want
11:12:13 <cocreature> wow that’s a really bad hoogle response
11:13:34 <mizu_no_oto_work> t7: you could use newtypes to make a monoid instance like 'FinitelyEnumerable a => Monoid (SetIntersection a)', but I don't think that's on hackage anywhere
11:13:46 <mizu_no_oto_work> Also, it's not the most useful monoid
11:13:59 <t7> i will make a github pull request on the ghc mirror
11:14:09 <mizu_no_oto_work> since you really don't want to make a set of every Int or Double
11:14:14 <mizu_no_oto_work> but it might sometimes be useful
11:16:28 <mizu_no_oto_work> You'd want to be dealing with types with only a few inhabitants, like an enum of some sort or maybe a Word8.
11:16:53 <t7> why
11:17:01 <mizu_no_oto_work> Since the identity for intersection is the set with every value of that type
11:17:31 <t7> i though we were doing union
11:17:36 <mizu_no_oto_work> That's why the standard library has Set as a monoid under union, not intersection
11:17:49 <t7> ah
11:17:53 <t7> gotya
11:18:01 <mizu_no_oto_work> But you could write a library for the set intersection monoid
11:18:10 <Gurkenglas_> Sounds like it should be a semigroup instead
11:18:25 <mizu_no_oto_work> The semigroup is much more useful, yeah.
11:18:59 <mizu_no_oto_work> The intersection monoid is also probably not what you want if you're folding, either.
11:19:35 <mizu_no_oto_work> If you have a non-empty set of sets, you'd get everything that's in all of them.  If you have no sets, you have every element, ever
11:20:02 <Gurkenglas_> You could get around the finite-enumerability-restriction by giving the set an extra constructor to stand for the full set, but that's just the general construction of a monoid from a semigroup
11:20:13 <Gurkenglas_> -giving the set +giving Set
11:22:44 <EvanR> a set with every value of that type
11:23:40 <EvanR> this only makes sense for certain types
11:24:05 <Sornaensis> :t on
11:24:06 <lambdabot> (b -> b -> c) -> (a -> b) -> a -> a -> c
11:26:18 <EvanR> cantor, etc called that a totality
11:38:03 <ExpHP> IT'S ALIVE!
11:38:13 <t7> im kinda into unit testing haskell now
11:38:16 <t7> its my thing
11:38:54 <ExpHP> on my machine, haskell is calling python and bash calling c++ all in one big great code mess
11:39:05 <ExpHP> and it works
11:39:13 <ExpHP> it is doing the physics
11:39:34 <ExpHP> ...uh oh
11:39:39 <supersimmetria> hi, guys
11:39:56 <supersimmetria> is 'A Gentle Introduction to Haskell, Version 98' still relevant?
11:40:07 <ExpHP> scratch that, it *was* doing the physics
11:40:27 <ertes> supersimmetria: hardly
11:40:49 <supersimmetria> ertes, are you ironic/sarcastic?
11:41:42 <ertes> supersimmetria: no, haskell has evolved since that one was written, and also it's not "gentle" in the sense one might think
11:42:16 <supersimmetria> ertes, what is the best book to learn haskell if you dont know functional programming at all?
11:43:14 <supersimmetria> i know programming
11:43:14 <ExpHP> this is where I more or less started: http://learnyouahaskell.com/introduction
11:43:42 <supersimmetria> ExpHP, and when you needed more info where did you look?
11:43:47 <MarcelineVQ> supersimmetria: My own response for that would be  http://haskellbook.com/  &  irc
11:43:56 <ExpHP> supersimmetria: the wiki
11:44:00 <ertes> supersimmetria: that's a good question
11:44:27 <ExpHP> there are some pages on the wiki that do leave "excercises to the reader"
11:44:30 <ertes> supersimmetria: so far the only book i might like i haven't actually read myself, so this is a blind suggestion: http://www.cs.nott.ac.uk/~pszgmh/pih.html
11:44:31 <ExpHP> :)
11:44:58 <Owatch> Hello. 
11:45:16 <ExpHP> howdy
11:45:16 <ertes> supersimmetria: it has good reviews from people i respect
11:45:39 <supersimmetria> i dont wanna learn solely haskell, i wanna get a good grasp of functional programming too
11:45:46 <Darwin226> So, an unboxed vector of pairs is implemented as a pair of vectors. Is there a way to get the sequential behavior where elements are just put one after another?
11:45:56 <Darwin226> this seems better for the cache
11:46:19 <ertes> supersimmetria: the way you do FP actually depends a lot on the language…  FP is more a set of related techniques based on functions
11:46:55 <ertes> supersimmetria: for example in scheme you wouldn't start by constructing an infinite data structure and then transforming it
11:47:15 <ExpHP> supersimmetria: actually, I came in having learned a lot of functional techniques alrady from imperative languages
11:47:25 <ExpHP> most modern languages now have lambdas and etc
11:47:36 <ertes> yes, but none of them really support FP
11:48:11 <ertes> it's not a matter of supporting lambdas
11:48:28 <ExpHP> to me it's kind of a fuzzy distinction
11:48:49 <greymalkin> ertes: I disagree, FP is a programmer feature as much as a language feature. Any language which can support functions (or something equivalent) as first-class citizens can be used as FP.
11:48:50 <ExpHP> rust has a lot in common with haskell despite being very clearly not a functional language
11:49:34 <greymalkin> Myself, I didn't grok monads until I found myself accidentally writing one in Java to solve a problem that I was having with (what I thought of then as) a "pipeline problem"
11:49:57 <ertes> greymalkin: JS has that, right?  try doing serious FP in JS and not bang your head against the table
11:50:06 <ertes> things like syntax matter
11:50:46 <ExpHP> EmcaScript 6 is doing quite a lot to help make FP in JS more comfortable
11:50:58 <t7> ertes: it has Object.assign
11:51:07 <t7> which is better record updating than haskell
11:51:16 <greymalkin> ertes: Yes, there are features to languages which make FP simpler, less verbose, more complete, etc. But building an understanding of FP with a traditionally imperative language is not impossible.
11:51:20 <ExpHP> There's some nasty corners where oh, suddenly you need parentheses here or there due to some grammatical ambiguity; but it's not the worst thing ever
11:51:45 <supersimmetria> do you code only in haskell?
11:52:04 <Clint> i wish
11:52:07 <Sonolin> yea modern JS is actually pretty nice, at least compared to other modern imperative languages
11:52:20 <ertes> t7: so?
11:52:30 <t7> so nerrr
11:52:34 <ertes> t7: i don't care what *imperative* features JS has ;)
11:52:37 <greymalkin> I would rather never program in anything but haskell -- but that's more because the language spoils you by its brevity and expressiveness
11:52:42 <rotaerk> Sonolin, meh; no type system -> garbage
11:52:52 <Sonolin> true, that is a definite flaw
11:52:55 <ExpHP> I mostly program in python, actually
11:52:59 <t7> ertes: Object.assign is immutable, and an expression :|
11:53:04 <rotaerk> of the mainstream languages, I generally prefer C#
11:53:09 <t7> nothing imperative about that 
11:53:12 <Sonolin> I suppose I was mostly thinking of other dynamic languages
11:53:16 <maerwald> greymalkin: most people say that because they're working on their own codebase only. That quickly changes once you're working with otuer haskellers codebase, because expressiveness comes with a price
11:53:17 <ExpHP> (this is because I've been using python for long enough to know all its warts)
11:53:20 <ertes> t7: oh, well…  in that case my response is lenses =)
11:53:42 <t7> ertes: lenses are too hard without type holes
11:53:51 <ertes> t7: huh?
11:53:58 <ertes> what do you mean?
11:53:58 <t7> like agda
11:54:12 <cocreature> lenses also don’t easily allow for updating multiple fields at once
11:54:30 <ertes> cocreature: Lens' X (Y, Z)
11:54:37 <cocreature> t7: we have those in Haskell!
11:54:40 <greymalkin> maerwald: Every time you grab something from hackage/stackage you're working with someone else's code.  I've found that the libraries I end up using in haskell are best documented by the language itself, rather than the actual documentation. But that may just be me.
11:54:40 <wing> hi everyone, i'm looking for gui expert for small project, anyone intersted?
11:54:51 <ertes> cocreature: or, when applicable: Traversal' X Y
11:54:54 <cocreature> ertes: yeah but you can’t construct that from two separate lenses in general
11:54:54 <t7> cocreature: not with auto solve etc :D
11:54:57 <maerwald> greymalkin: I strongly disagree on that
11:55:22 <ertes> cocreature: i've never tried, but are you sure?  i bet at least some fairly generic special cases are well possible
11:55:24 <maerwald> greymalkin: and no, you're just working with API, not with implementation details
11:56:12 <cocreature> ertes: the problem is that they can overlap and in that case the resulting lens would violate the laws.
11:56:14 <maerwald> I like to write haskell, I don't like to read it though, because everyone does things differently, pretty much
11:56:25 <ertes> cocreature: and if not, i don't mind doing (l1 %~ f) . (l2 &~ g)
11:56:50 <ertes> cocreature: true
11:57:11 <cocreature> ertes: oh sure in most cases it’s not a problem, but if you are updating 5 fields or more it gets annoying
11:57:24 <ertes> cocreature: use a state monad with 'zoom'
11:57:29 <supersimmetria> if i want to understand fully haskell actions, what should i read?
11:57:29 <greymalkin> maerwald: We'll have to agree to disagree here, I find myself delving into the "how" (implementation) as often as the "why" (api) and coming away with a clearer understanding in haskell than I do in other languages.
11:57:50 <ertes> supersimmetria: first learn the basics of the language, then read this: https://www.vex.net/~trebla/haskell/IO.xhtml
11:57:51 <ExpHP> I'm with maerwald.  The cost of highly factored code is that we don't "think" factored
11:57:53 <greymalkin> Perhaps because of the "easier to reason about" that is touted so often.
11:58:12 <cocreature> ertes: I still haven’t figured out how to use zoom properly. it doesn’t work with MonadState so I would need to write all my code against a fixed monad and that seems annoying
11:58:14 <ertes> supersimmetria: (i'm assuming that by "actions" you mean "IO actions")
11:58:14 <ExpHP> highly factored /abstractions/ are cool, but highly factored implementations take time to digest
11:58:29 <maerwald> ExpHP: yeah, it's a little bit like maths... the thing a mathematician comes up with in the end is not what one would _intuitively_ come up with. It's forged.
11:58:31 <greymalkin> I just have to remember that haskell is more information-dense than other languages.  It's a breeze to read java, but the verbosity detracts from the overall picture.
11:58:44 <ertes> cocreature: just use narrow runState/runStateT
11:58:54 <blackdog> right, you know what's going on in the small, but the large is a total mystery
11:59:00 <cocreature> ertes: I don’t see how that helps?
11:59:01 <blackdog> (with java)
11:59:03 <ertes> cocreature: or in fact most likely execStateT
11:59:08 <supersimmetria> ertes, are there non-IO actions too?
11:59:36 <ertes> cocreature: well, you have a value 'x' that you want to update:  x' = execState (… zoom …) x
11:59:45 <ertes> use State only for that purpose
11:59:49 <ertes> you can use it anywher
11:59:51 <ertes> anywhere
12:00:03 <ertes> supersimmetria: yeah
12:00:08 <cocreature> ertes: well that assumes that I have state that is only local
12:00:22 <ertes> cocreature: if you have non-local state, use StateT instead of State
12:00:34 <supersimmetria> ertes, what should i read to understand non-IO actions too?
12:00:44 <ertes> cocreature: StateT local (State nonLocal)
12:00:50 <cocreature> ertes: that’s exactly what I’m talking about. I then want to use MonadState instead of programming against a fixed StateT and then I can’t use zoom
12:01:06 <maerwald> greymalkin: the density is not the problem, it's the disconnection of intuition and final expression
12:01:23 <ertes> cocreature: let's say you're writing a ((MonadState nonLocal m) => m ())
12:01:29 <ertes> just use StateT for the local one there
12:01:44 <ertes> or at least the parts where you want to use 'zoom'
12:02:11 <cocreature> ertes: what I want is to plug in some "MonadState smallerPartOfNonLocal m => m ()" into that bigger context
12:02:54 <ertes> cocreature: that requires some plumbing, but it's really minor plumbing
12:03:26 <ExpHP> supersimmetria: perhaps you can clarify what you meant by in your original question when you said "haskell actions"
12:03:26 <cocreature> ertes: I don’t think it is. the last time I looked into it I found several issues in the lens repo stating that it’s not possible to use zoom in a polymorphic context
12:03:32 <ertes> in any case the answer is to use StateT over MonadState, if you want to zoom and still keep the generality of MonadState
12:03:51 <cocreature> e.g. https://github.com/ekmett/lens/issues/316
12:04:17 <supersimmetria> ExpHP, i just read that in order to print to screen, haskell action is needed
12:04:28 <ExpHP> ah
12:04:46 <supersimmetria> i wanna understand haskell action not io action
12:05:05 <ExpHP> supersimmetria: I don't think the phrase "haskell action" usually means anything :)
12:05:24 <supersimmetria> im a noob, have mercy, ExpHP 
12:05:32 <ExpHP> I know :P
12:05:44 <ertes> cocreature: let me write a short example
12:05:46 <napping> as much as it means anything, an "IO action" is what you need for printing to the screen
12:05:55 <ertes> cocreature: i think i'm not communicating what i mean properly =)
12:05:57 <napping> like, putStrLn "Hello World" :: IO ()
12:06:15 <cocreature> ertes: or I failing to communicate what my problem is :)
12:06:18 <ExpHP> supersimmetria: I'm not sure what ertes meant when he said there are "non-IO" actions.  Generally speaking, to print to screen in haskell, you need IO
12:06:19 <supersimmetria> napping, i just want to go as deep as possible
12:06:25 <napping> anything with a type like IO a can be called an IO action
12:06:26 <nitrix> cocreature: MAybe you want `use` ?
12:06:51 <nitrix> cocreature: I remember doing `gets` on MonadState and then `view` from lens and someone told me to look at `use` from lens.
12:07:11 <napping> Because it's like a description of something to do - you can put it in a datastructure or pass it around for a bit before actually "running" it
12:07:22 <supersimmetria> im not afraid to go deep, i cant stop at 'io action is needed to print to screen'
12:07:29 <cocreature> nitrix: I don’t want to read a part of the state. I want to embed something that modifies part of the state in a larger state
12:07:35 <napping> like, main = do let sayHi = putStrLn "Hello"; sayHi; sayHi
12:08:09 <nitrix> cocreature: Isn't `state` sufficient for this?
12:08:11 <napping> will print two lines - as an expression (putStrLn "Hello") doesn't print something and then return ()
12:08:17 <nitrix> cocreature: state of MonadState ?
12:08:28 <supersimmetria> napping, how did you learn haskell?
12:08:35 <cocreature> nitrix: no? that uses the exact same state
12:08:42 <cocreature> nitrix: are you familiar with what "zoom" gives you?
12:08:49 <nitrix> cocreature: Oh I see what you have in mind.
12:08:54 <napping> supersimmetria: long ago. I read the "Gentle Introduction to Haskell"
12:09:05 <cocreature> "zoom" is exactly what I want. the only problem is that it doesn’t work properly inside of a MonadState context
12:09:12 <nitrix> cocreature: So a zoomed lens on the state which lets you only change that part of the state focused by a lens?
12:09:21 <supersimmetria> napping, how obsolete is 'gentle introduction'?
12:09:23 <cocreature> nitrix: exactly
12:09:33 <napping> also, how "gentle" is it
12:09:37 <nitrix> cocreature: Yet it'll update the state as a whole? I've done that before; I wonder how I did it.
12:09:55 <supersimmetria> napping, i care only about how obsolete it is
12:10:01 <napping> but it's not really obsolete, definitely if you want to get deep into the basics of the language
12:10:30 <nitrix> cocreature: I think I ended up with a wrapper for `modify . zoom`
12:10:31 <cocreature> nitrix: yep that’s what I’m after. but the important part is really that I want to do this without forcing some concrete monad transformer stack. otherwise "zoom" works beautifully
12:10:35 <napping> It won't tell you anything about what libraries are good these days, but it has a lot about the language
12:10:50 <supersimmetria> napping, is there a more relevant contemporary equivalent to 'gentle introduction'?
12:11:08 <napping> I don't know
12:11:18 <nitrix> cocreature: I'm not sure but I think it should be doable to implement an instance for ZoomLike.
12:11:24 <ExpHP> supersimmetria: #haskell-beginners may also be able to help more.
12:11:39 <napping> You could take a look at this chapter and see if it's at a useful level https://www.haskell.org/tutorial/io.html
12:11:44 <supersimmetria> ExpHP, ok, sorry, i forgot about it
12:11:52 <nitrix> cocreature: Sorry, Zoom type class, LensLike'
12:12:27 <cocreature> nitrix: the problem is that without a concrete monad transformer stack it is unclear what instance should be applied
12:12:36 <nitrix> cocreature: https://hackage.haskell.org/package/Chart-1.1/docs/Control-Lens-Zoom.html
12:12:51 <nitrix> cocreature: class (Zoomed m ~ Zoomed n, MonadState s m, MonadState t n) => Zoom m n s t | m -> s, n -> t, m t -> n, n s -> m where
12:13:00 <cocreature> nitrix: yeah I’m familiar with that
12:13:26 <nitrix> cocreature: Ah nevermind it's making the stateful computation happen in a MonadState
12:13:34 <nitrix> My grep failed :P
12:13:55 <cocreature> there is https://stackoverflow.com/questions/30827838/how-do-i-use-zoom-with-a-monadstate-constraint-of-a-newtype but iirc it didn’t work in my case but I forgot why
12:13:59 <cocreature> maybe I should give it another shot
12:14:30 <ertes> cocreature: https://gist.github.com/esoeylemez/22e4a8a11c64cf73fa486b1b07825b7a
12:14:54 <nitrix> cocreature: https://github.com/ekmett/lens/issues/316
12:15:16 <nitrix> ertes: asStateT, that's a meh hack :P
12:15:33 <ertes> cocreature: of course another option would be to add a Zoom constraint, but i can see why you wouldn't want to do that =)
12:15:45 <ertes> nitrix: i don't really consider it a hack =)
12:17:11 <nitrix> In the end, you end up with some helper for `modify . zoom`. edward seems to say in the issue on github that the types cannot allow it currently.
12:17:14 <cocreature> ertes: ah that actually looks pretty reasonable
12:17:56 <ertes> cocreature: the only caveat is that you might switch to a different StateT flavour (e.g. lazy → strict), but that gives you the opportunity to pick the one that best fits your update action
12:18:11 <cocreature> yeah that’s not too bad
12:19:10 <Owatch> Why can't I use a `where` in a `do` statement? 
12:19:36 <Owatch> I.E. in my main I've got my final line: print (if a > 1 then a else 0) where a = ...
12:19:40 <cocreature> Owatch: because the haskell standard says so :)
12:20:14 <ertes> Owatch: 'where' always belongs to an equation, so if that do-block is within a function clause you can use it
12:20:21 <ertes> Owatch: f x = do … where …
12:20:45 <geekosaur> Owatch, where is part of declaration syntax, because that way it can scope over any guards in the pattern
12:20:50 <ertes> Owatch: you can use 'let' (without 'in') within 'do' though
12:21:35 <Owatch> I guess I'll assign the result with let before, then print.
12:22:55 <ertes> Owatch: i would suggest using 'max', but it's off by one =)
12:23:20 <ertes> > map (max 0) [-10, -1, 0, 1, 2]
12:23:22 <lambdabot>  [0,0,0,1,2]
12:23:54 <ertes> … literally
12:24:13 <Owatch> Uh well. Not exactly in my case. 
12:24:29 <Owatch> I need 1 to always be 0. 
12:25:05 <ertes> as in 1 = 0?
12:25:48 <ertes> > let 1 = 0 in 1 + 1
12:25:50 <lambdabot>  0
12:25:56 <rotaerk> lol
12:27:08 <ExpHP> ... huh, that isn't what ghc says...
12:27:14 <ExpHP> ghc*i*
12:27:41 <wing> why even it compiles
12:28:01 <ertes> ExpHP: :seti -XAllowIncorrectEquations
12:28:12 <ExpHP> *snrk*
12:28:35 <ExpHP> oh you liar!
12:28:46 <ExpHP> :F
12:29:03 * ExpHP walks away with lambdabot
12:29:54 <boxscape> shouldn't that result in a non-exhaustive pattern error, because 0 can't be pattern matched to 1? at least without extensions
12:30:15 <ertes> i messed with lambdabot in /query =)
12:30:23 <ertes> @let import Prelude hiding (Num(..))
12:30:26 <lambdabot>  Defined.
12:30:28 <ertes> @let _ + _ = 0
12:30:29 <lambdabot>  Defined.
12:30:35 <boxscape> I mean just regularly in ghci
12:30:35 <ExpHP> so the puppet master reveals his strings!
12:30:39 <ertes> > let 1 = 0 in 1 + 1
12:30:41 <lambdabot>  0
12:30:42 <ertes> @undef
12:30:42 <lambdabot> Undefined.
12:31:07 <ertes> boxscape: 'let'-bound patterns are irrefutable by default
12:31:12 <ertes> > let !1 = 0 in ()
12:31:14 <lambdabot>  *Exception: <interactive>:3:5-10: Irrefutable pattern failed for pattern 1
12:31:17 <boxscape> right, I still need to get used to irrefutable patterns
12:31:35 <boxscape> > let f ~3 = 4 in f 4 -- I would've expected this to fail as well
12:31:37 <lambdabot>  4
12:31:42 <ertes> on the lambdas are strict
12:31:48 <ertes> > (\1 -> ()) 0
12:31:51 <lambdabot>  *Exception: <interactive>:3:2-9: Non-exhaustive patterns in lambda
12:32:04 <ertes> *on the other hand
12:32:16 <boxscape> oh, nevermind
12:32:21 <boxscape> it never tries to match it, obviously
12:32:34 <ExpHP> > case 1 of 0 -> error "party time"
12:32:36 <lambdabot>  *Exception: <interactive>:(3,1)-(4,22): Non-exhaustive patterns in case
12:32:37 <ertes> yeah, you don't actually use it
12:33:07 <ertes> > let f x@(~3) = x `seq` () in f 4
12:33:10 <lambdabot>  ()
12:33:14 <ertes> huh?
12:33:35 <orion> https://www.reddit.com/r/haskell/comments/61zs2l/regarding_dsls_what_are_the_recommended_use_cases -- "The initial encoding approach is more flexible and amenable to optimization (e.g. if you want to analyze your Free program and rewrite/optimize it before interpreting it)" Does anyone know how to do this?
12:33:37 <boxscape> let f ~(x@(3)) = x `seq` () in f 4
12:33:39 <boxscape> > let f ~(x@(3)) = x `seq` () in f 4
12:33:41 <ExpHP> > case 1 of ~0 -> error "party time"
12:33:41 <lambdabot>  *Exception: <interactive>:3:5-27: Irrefutable pattern failed for pattern x@(3)
12:33:42 <orion> Or, does anyone know of any examples of this being done?
12:33:43 <lambdabot>  *Exception: party time
12:33:58 <boxscape> ertes: you made the inner pattern irrefutable instead of the whole pattern
12:34:41 <wing> any gui expert here?
12:35:25 <johnw> wing: I don't think anyone will admit to that without knowing what they're getting into...
12:36:39 <ertes> orion: i'll use FreeT vs. FT:  usually you would construct as FT and at the very end convert to FreeT, if at all
12:37:14 <Owatch> Can I prematurely end a do block? I.E: if (...) then print 0 and return ? 
12:37:20 <ertes> orion: you really only need FreeT, if you want to suspend the interpreter and have a first-class representation of "the rest of the action"
12:37:20 <ertes> for all other cases you can just interpret FT directly
12:37:44 <greymalkin> What is the '~' used for in type signatures?
12:37:51 <lyxia> Owatch: if (...) then print 0 else continue
12:37:53 <ertes> Owatch: ending prematurely is an effect
12:38:17 <ertes> greymalkin: equality constraints
12:38:27 <ertes> > () :: (Int ~ Int) => ()
12:38:29 <lambdabot>  ()
12:38:31 <ertes> > () :: (Int ~ Bool) => ()
12:38:33 <lambdabot>  error:
12:38:33 <lambdabot>      Couldn't match type ‘Int’ with ‘Bool’ arising from a use of ‘it’
12:38:43 <boxscape> Owatch: you can start a new do block in the else branch
12:39:11 <orion> ertes: What if one of my optimizations is, "If you see OperationA followed by OperationB, replace it with OperationC" How exactly do I go about "looking ahead" at arbitrary instructions, and then make changes to the program?
12:39:12 <wing> johnw: fine,  i have f# gui to be ported, i dont know any of haskell gui tools/libraries
12:39:17 <greymalkin> ertes: thank you. I can google the words from here :)
12:40:56 <Owatch> boxscape: Thank you!
12:41:03 <boxscape> Owatch: (something like this: http://lpaste.net/354027)
12:41:04 <Owatch> That did what I wanted
12:41:07 <boxscape> ok, good
12:42:01 <Owatch> IO is confusing with Haskell
12:43:04 <ertes> orion: that's not the kind of optimisation that the encoding gives you…  rewriting can be done with both FreeT and FT, although the latter is more mind-bending
12:44:03 <ertes> Owatch: https://www.vex.net/~trebla/haskell/IO.xhtml
12:44:23 <Owatch> Thank you
12:45:23 <ertes> or: why ending prematurely means something entirely different from returning from a procedure in most other languages =)
12:47:52 <EvanR> "deep into the basics"
12:48:07 <EvanR> only in haskell baby
12:48:18 <orion> ertes: So if I use FreeT or FT, I can arbitrarily inspect and rewrite programs using whatever rules I want?
12:48:42 <ertes> orion: yes, but
12:48:54 <c_wraith> orion, well, not arbitrarily. you only get visibility into them while interpreting them. 
12:49:20 <ertes> orion: the problem with both FreeT and FT is that interpreting causes effects
12:49:32 <ertes> optimisation requires interpretation
12:49:39 <ertes> if you don't want that, you need to use Free/F
12:50:18 <orion> If you're interpreting, doesn't that preclude you from looking "ahead" at future instructions within the interpreter?
12:50:31 <c_wraith> even those require interpreting to inspect. 
12:50:40 <c_wraith> it's the nature of Monad. 
12:50:53 <ertes> orion: you can't look deeper into a (FreeT F M) without causing M effects
12:51:19 <c_wraith> when effects are chosen at runtime, you need to run it to see what effects it chooses. 
12:51:34 <EvanR> nice chiasmus
12:53:30 <orion> Makes sense. So if I want to inspect/rewrite a program without interpreting it, I must use Free/F?
12:53:50 <ertes> orion: or some other structure
12:53:58 <ertes> free applicatives and free arrows come to mind
12:54:11 <hexagoxel> Owatch: if your control flow is more complex and you end up with too many nested ifs, there are abstractions that really give you "early return". But I'd consider those options only when ifs become annoying.
12:55:04 <orion> ertes: Do you know of any examples of arbitrarily rewriting a Free/F program?
12:55:39 <ertes> orion: not really, but it should be fairly straightforward…  an optimiser is really just a kind of interpreter
12:55:57 <ertes> one that returns a new Free expression instead of some final result
12:57:16 <hexagoxel> TF = "tagless final" here, right?
12:57:42 <orion> ertes: It would seem to me that for certain things I want to do, I would need to interpret the entire Free expression -- collecting each operation in to a list along the way -- and then at the very last moment consider the entire List for the transformations I want to apply, then create a new Free expression.
12:58:19 <ertes> orion: actually the rewrites you can do are fairly limited…  you can't actually descend deeper into an expression
12:58:30 <ertes> that's inherent in the nature of monads
12:58:39 <ertes> blame (>>=)
13:00:06 <johnw> orion: another alternative to free arrows is to translate your program into the language of closed cartesian category
13:00:19 * hexagoxel meant to ask FT=finally tagless
13:00:37 <ertes> hexagoxel: it's more liky F-transformer =)
13:00:51 <ertes> State → StateT, F → FT
13:00:51 <johnw> orion: I just happen to be reading this paper as we speak, for a project at work that needs to do static analysis and optimization of effect-bearing programs: http://conal.net/papers/compiling-to-categories
13:01:21 <johnw> I think FT refers to the church encoded FreeT from the 'free' package
13:01:29 <ertes> it does
13:01:52 <hexagoxel> ah, thanks.
13:02:36 <ertes> also i think it's an initial encoding, but i'm not sure…  it's definitely an algebraic encoding, not a coalgebraic one
13:02:55 <johnw> ertes: which one is an initial encoding?
13:03:08 <ertes> F and FT
13:03:14 <Owatch> Can you treat a Vector like a list in haskell? 
13:03:19 <Owatch> I.E:   (x:xs) 
13:03:24 <johnw> they are both final, ala Church
13:03:27 <ertes> type List a = forall r. (a -> r -> r) -> r -> r
13:03:34 <ertes> FT is to FreeT what List is to []
13:03:57 <averroes> hi everyone
13:04:04 <ertes> johnw: do you have an example of an initial encoding?  i'm not entirely sure what it means
13:04:18 <johnw> data Free f a = Pure a | Free (f (Free f a)) is initial
13:04:34 <averroes> I am run this ghci (*) <$> (Just 5)
13:04:45 <averroes> getting an error error:     • No instance for (Show (a0 -> a0)) arising from a use of ‘print’
13:04:50 <ertes> ah, so it's not related to whether it's algebgraic or coalgebraic
13:04:58 <johnw> newtype Free f a = Free (forall r. (a -> r) -> (f r -> r) -> r) is final
13:04:58 <boxscape> averroes: what would you expect to get?
13:05:12 <Cale> Owatch: Well, you can't match it against the pattern (x:xs), that would be a type error. However, you probably could write a function Vector a -> Maybe (a, Vector a)
13:05:21 <averroes> boxscape: it should return maybe type
13:05:25 <Cale> (and then pattern match the result of that)
13:05:26 <averroes> Just (+5)
13:05:36 <boxscape> averroes: then what does the (*) do in that case?
13:05:48 <boxscape> oh, or did you mean (*5)?
13:05:52 <Owatch> Damn, okay. :( 
13:05:57 <johnw> funny, I was just discussing initial vs. final related to Free earlier today on reddit
13:06:00 <averroes> yes
13:06:05 <averroes> sorry typo
13:06:12 <Cale> Owatch: However, doing so will negate nearly all of the performance benefit of using Vector in the first place.
13:06:26 <boxscape> averroes: that's what it's doing; haskell just doesn't know how to actually print out (*5), because functions don't have instances of Show
13:06:28 <Cale> Owatch: If you're going to take something apart as if it's a list, it might as well be a list.
13:06:35 <boxscape> :t (*) <$> (Just 5)
13:06:37 <lambdabot> Num a => Maybe (a -> a)
13:06:38 <Owatch> I need the indexing capability
13:06:43 <ertes> johnw: well, it's a mundane topic, i guess
13:06:45 <Owatch> But I also need to remove what I index
13:07:07 <averroes> weird ghci is complaining 
13:07:14 <Owatch> It's frustrating because I can't find a way to do it. 
13:07:14 <johnw> ertes: https://www.reddit.com/r/haskell/comments/61zs2l/regarding_dsls_what_are_the_recommended_use_cases/
13:07:24 <ertes> johnw: i saw that one earlier =)
13:07:29 <boxscape> averroes: if you try :t (*) <$> (Just 5)   (with the :t) ghci should not complain
13:07:43 <Cale> Owatch: well, you can use take and drop
13:08:00 <averroes> hm I see 
13:08:03 <averroes> (*) <$> (Just 5) <*> (Just 3)
13:08:05 <Owatch> In another language like C I'd just mark visited indices as visited and move on.
13:08:12 <johnw> ertes: lots of comments added in the thread that clarifies final vs. initial
13:08:13 <averroes> returns Just 15 as expected 
13:08:14 <boxscape> > (*) <$> (Just 5) <*> (Just 3)
13:08:16 <lambdabot>  Just 15
13:08:16 <boxscape> yup
13:08:20 <Cale> Owatch: What are you actually implementing?
13:08:29 <averroes> thanks I was freaking out for nothing I guess
13:08:36 <orion> johnw: Thanks. My use case is that I need to perform transformations on already existing programs -- rewrite the expression based on certain rules. You think representing my language as a CCC will allow this?
13:08:42 <Cale> Owatch: Most of the time if I have to keep track of which graph vertices I've visited, I just accumulate them in a Set.
13:08:58 <Owatch> I'm trying to implement a program that iterates down a vector. At each index, it visits the index pointed to by the value of that index. 
13:09:00 <averroes> boxscape: Thank you buddy
13:09:05 <johnw> orion: the basis of Conal's paper is that you can take straight Haskell and convert it to a CCC, and then from there use choice-of-category to apply an interpretation
13:09:08 <Owatch> I.E: Index 1 has 5 in it, so go to 5. 
13:09:12 <boxscape> you're welcome
13:09:21 <nitrix> Are the forkIOs inside a forkOS guaranteed to happen on the same OS thread?
13:09:31 <Owatch> I then continue until I've finished a cycle, and mark each visited index as visited along the way. 
13:09:38 <ertes> nitrix: no
13:09:40 <johnw> orion: this allows you, for example, to write circuits using regular Haskell functions, rather than requiring a custom circuit-building DSL
13:09:58 <ertes> nitrix: also forkIO vs. forkOS is really only meaningful in the context of FFI calls
13:10:01 <Cale> Owatch: Okay, yeah, use a Data.Set to keep track of the indices which you've visited.
13:10:20 <nitrix> ertes: I'm aware. I'm working with SDL which has local thread storage.
13:10:53 <nitrix> ertes: Is there a way for me to have multiple threads that are guaranteed to all run on the same OS thread?
13:10:55 <ertes> nitrix: note that the main thread is bound by default, so if forkIO within forkOS would be bound, you could only ever create bound threads
13:11:07 <nitrix> ertes: Unless you're using GHCi.
13:11:09 <ertes> nitrix: there is forkOn
13:11:19 <ertes> but i'm not sure if it does exactly that
13:11:28 <nitrix> ertes: I found a bug where with GHCi, the main thread isn't bound (checked with isCurrentThreadBound)
13:12:01 <orion> johnw: That's pretty cool, although it doesn't seem all that different from Free, where you keep the program the same and simply provide a different interpreter.
13:12:31 <ertes> nitrix: even with :main?
13:12:36 <nitrix> ertes: Mhh, forkOn seems to be about processors capabilities rather than OS threads.
13:12:44 <nitrix> ertes: Not sure for :main, checking.
13:13:15 <Cale> .oO(If people spent half the time just implementing their DSL that they spent on discussing which variant of free monad to program it with, they could just do everything by hand and be done in less time.)
13:13:44 <geekosaur> sounds like most of programming :p
13:13:54 <nitrix> ertes: Both `main` and `:main` gives False.
13:13:56 <ertes> nitrix: i guess if you really want to be safe, you should create a single thread via forkOS and throw actions at it
13:13:58 <nitrix> ertes: (under GHCi)
13:14:06 <ertes> nitrix: good to know
13:14:21 <thoughtpolice> nitrix: GHCi always launches computations in a new thread by default, FWIW, so it very well may not be a bug. You can disable this behavior with -fno-ghci-sandbox (but it will cause things like the GHCi debugger to stop working)
13:14:32 <thoughtpolice> I can't recall exactly why this is in place (i.e. the real reason), but there it is.
13:14:37 <Owatch> Alright, I guess I can use a set. Then check if it's already in it. 
13:14:53 <nitrix> thoughtpolice: Good to know.
13:14:53 <thoughtpolice> Unless you already turned it off or something, then it's almost definitely a bug.
13:14:53 <Cale> Owatch: Yep!
13:15:38 <Cale> Owatch: Given that your set is full of Int values, you may also try IntSet and see if that affects performance, but usually it is quite irrelevant.
13:15:50 <nitrix> ertes: Yeah I'll run my main in a forkOS thread all the time for extra safety, but the question becomes, am I able to forkIO different things (like polling for event, drawing to screen, etc) for my game, within the same OS thread.
13:15:54 <Cale> (they have the same interface as well, so it's easy to try both)
13:16:31 <ertes> nitrix: no, different forkOS threads aren't guaranteed to run on the same OS thread
13:16:40 <ertes> and i don't see a way to do that
13:17:33 <nitrix> ertes: I'm trying to separate window drawing and window even polling into two independent threads so that one doesn't slow donw the other, but SDL mendates me that they need to both have access to thread local storage and happen from the same OS thread.
13:17:53 <ertes> nitrix: well, OpenGL and SDL don't actually need to run on the same OS thread
13:18:19 <ertes> so that would work with separate forkOS threads
13:18:35 <nitrix> ertes: SDL_WaitEvent has to open in the thread that initialized the video rendering :/
13:18:40 <nitrix> *happen
13:18:56 <geekosaur> that requirement sounds contradictory
13:19:09 <geekosaur> "don't slow each other down" "must have access to the same thread local storage"
13:19:28 <ertes> nitrix: does SDL's video initialisation actually involve OpenGL?
13:19:39 <ertes> you may want to ask in #SDL
13:19:41 <nitrix> ertes: It can.
13:19:58 <ertes> but yeah, that sounds weird
13:20:07 <ertes> but i guess most SDL applications don't actually use SDL_WaitEvent
13:20:08 <Owatch> Hopefully just normal Set should be okay for now
13:20:22 <nitrix> So people normally poll events between frames being rendered? That just seems odd to me.
13:20:42 <ertes> nitrix: do you want to stop rendering when no events are occurring?
13:21:16 <ertes> nitrix: usually you would read all pending events, process them, draw a frame, repeat
13:22:08 <nitrix> ertes: So far, my vision is to poll for events in a blocking manner, feed the events to the game engine asynchronously, the game engine does whatever it wants, periodically it has a snapshot of the game to render, which is given to the render thread to render.
13:22:20 <nitrix> ertes: When nothing needs to be rendered, that thread should just wait.
13:23:17 <ertes> nitrix: then why don't you just wait on the same thread?
13:23:26 <nitrix> The problem with my original model is that I can't both have blocking events and render based on an MVar change, if they're both done by the same OS thread.
13:23:52 <ertes> well, this is really ugly, but one option is to push SDL events onto the queue
13:24:03 <nitrix> ertes: If I'm blocking on waiting for events, I can't be waiting on the mvar change for the snapshot to render o.<
13:24:07 <hexagoxel> nitrix: afaik sdl supports opengl context sharing. that might allow you to move a large part of rendering to another thread. not sure though.
13:24:55 <nitrix> ertes: I was tempted to do that. User events, but our haskell sdl2 lib has poor Raw handling of custom sdl user events.
13:25:06 <nitrix> It's my fallback option :/
13:26:14 <nitrix> ertes: See the issue? I can't even poll for events between frames either, because if there's no render updates, I'll accumulate events and deadlock again.
13:26:52 <nitrix> It's very, very hard to make a game engine with SDL and haskell that doesn't wastefully poll events or render frames.
13:27:05 <nitrix> :(
13:27:06 <ertes> nitrix: there is one more option, which is only slightly dirty: poll for events and process them…  when there is no event, wait for an MVar
13:27:31 <nitrix> ertes: What if the MVar doesn't come?
13:27:48 <ertes> right, forget that
13:27:56 <nitrix> ertes: If there were no events, the game will have very little reasons to update the render MVar.
13:28:11 <ertes> what is the MVar?  game state?
13:28:17 <nitrix> ertes: Yup.
13:28:32 <nitrix> My Game money is entirely pure, the renderer lives in IO.
13:28:36 <nitrix> *monad.
13:28:44 <ertes> hehe
13:28:45 <EvanR> timing passing is not an event!
13:28:59 <EvanR> zeno proved it
13:29:01 <ertes> nitrix: why the MVar?  why not just have a stateful game loop with event waiting?
13:30:42 <nitrix> ertes: Is it problematic? Because I liked the idea that the game engine can struggle computing something yet can still receive more events. Heck, maybe if the events are not too related, maybe it's possible to have the game engine compute things asynchronously.
13:30:52 <johnw> orion: Free's utility comes from overloading do-notation, combining with "smart constructors" (i.e., functions that call liftF behind the scenes), and maybe even pattern synonyms to make destruction nicer. But you're still effectively hand-coding what could be done automatically by compiling your functional program directly to sufficiently representative category.
13:31:00 <Owatch> How can I insert nothing into Data.Set ? 
13:31:05 <Owatch> I want to return after adding some stuff/ 
13:31:13 <Owatch> But Data.Set.empty gets added to the set. 
13:31:31 <johnw> Owatch: using mappend instead of insert?
13:31:39 <Owatch> No using insert. 
13:31:49 <johnw> i meant, maybe *use* mappend instead of insert :)
13:32:13 <Owatch> Oh. 
13:32:21 <ertes> nitrix: library developers really need to stop using thread-local storage
13:32:32 <Owatch> Can't see that in the Data.Set page. 
13:32:36 <orion> johnw: I don't understand that statement. What do you mean by "hand-coding"? What process is happening automatically that I would have to do myself?
13:32:38 <nitrix> ertes: I agree. The bane of every C program :P
13:32:44 <ExpHP> @index mappend
13:32:44 <lambdabot> Data.Monoid, Prelude, System.Console.Terminfo.Base, System.Console.Terminfo
13:32:50 <ertes> nitrix: i don't even really understand *why* they do it
13:32:57 <EvanR> how do you even use thread local storage
13:33:26 <EvanR> ive never noticed an api for that
13:34:03 <johnw> orion: so, with Free you define your algebra, then your type wrapper: type Grammar = Free Myalg, then your constructors for building Grammar terms, etc., etc.  This is all machinery you have to write, every time.  I'd been thinking about using TH to automate it; but now I'm realizing that if all you want is reification of the program to allow separate analysis and interpretation, perhaps this CCC approach is just the ticket.
13:34:07 <mizu_no_oto_work> Owatch: mappend is from Monoid
13:34:57 <EvanR> johnw: which CCC approach? link?
13:35:12 <mizu_no_oto_work> Owatch: it's the same as Set.union, though, for the Set instance of Monoid
13:35:14 <johnw> EvanR: http://conal.net/papers/compiling-to-categories
13:35:25 <EvanR> thanks
13:35:26 <nitrix> ertes: I just had an idea.
13:35:39 <ertes> "i'm not gonna use SDL" =)
13:35:49 <mizu_no_oto_work> Owatch: where the idea is that instead of inserting items, you union the set with either a set with a single item or the empty set
13:36:09 <nitrix> ertes: I can make the game logic, and the game renderer their own thread, than the main thread which is OS bound, will just be dispatching channel messages back and forth between threads.
13:36:22 <Owatch> Ah, using union and returning Data.Set.empty as a base case will work I think
13:36:33 <nitrix> ertes: errr no.
13:36:36 <nitrix> But I'm close.
13:36:47 <ertes> nitrix: is your game logic pure?
13:36:52 <nitrix> ertes: IT is.
13:36:56 <boxscape> is there a difference between mappend and union for Data.Set?
13:37:07 <boxscape> oh nevermind
13:37:12 <boxscape> mizu already said no
13:37:23 <ertes> nitrix: because pure haskell parallelism doesn't interfere with SDL/OpenGL
13:37:32 <ertes> so you wouldn't need to use concurrency
13:37:52 <nitrix> ertes: What if it isn't pure?
13:38:03 <nitrix> I doubt it'll stay for for long :S
13:38:08 <nitrix> pure*
13:38:12 <ertes> nitrix: then you can still use parallelism =)
13:38:27 <ertes> or use concurrency locally
13:39:29 <Cale> boxscape: There should be, but no.
13:39:38 <boxscape> why should there be?
13:40:20 <Cale> Because it would be far more useful in practice usually to have the lifting instance Semigroup m => Monoid (Set m)
13:40:27 <glguy> Cale: Were you thinking of Map?
13:40:36 <Cale> Also for Map
13:40:42 <Cale> er, hm
13:40:47 <boxscape> I see
13:40:55 <Cale> Actually, no, I'm being silly
13:41:07 <boxscape> so no it should be the same?
13:41:09 <Cale> I guess you only get collisions on equal elements anyhow
13:41:13 <Cale> So it would be a little weird
13:41:21 <boxscape> yeah
13:41:44 <glguy> There's a question of how the Monoid instance for  Map k v should work, should mappend be: union (left-biased union) or unionWith (<>)
13:41:47 <Cale> In Map's case you don't combine keys in any way, after all
13:42:10 <Cale> Well, there is technically a question of what to do with colliding keys, but not one that anyone usually cares about :)
13:44:05 <BernhardPosselt> how do you formulate this in FP: while(elem = elem.parent) ...
13:44:27 <rotaerk> in what context? what's elem and parent exactly?
13:44:29 <Cale> That's not a complete thought, I'm not sure how to translate it
13:44:37 <BernhardPosselt> its an html element
13:44:41 <BernhardPosselt> div for instance
13:44:46 <BernhardPosselt> basically search upwards
13:44:50 <BernhardPosselt> and stop if you found something
13:45:16 <ertes> BernhardPosselt: you leave a level of recursion
13:45:22 <Cale> Well, do you have a parent function? You might produce a list of the parents of the element, and dropWhile some condition
13:45:32 <c_wraith> BernhardPosselt, in general, you work at a higher level of abstraction than a while loop. so we want to know what the goal is more than the code you'd use to write it. 
13:45:34 <Cale> e.g. using iterate
13:45:42 <Cale> Or just plain recursion
13:46:06 <Cale> Loops can generally turn into lists in some way
13:46:12 <BernhardPosselt> right
13:46:44 <BernhardPosselt> i also thought of creating the full dom path to the root
13:46:58 <BernhardPosselt> but that seems expensive (at least in non lazy languages)
13:47:57 <BernhardPosselt> maybe making it lazy would make sense
13:48:05 <BernhardPosselt> like creating an iterator
13:48:06 <Cale> Well, the whole mechanism of turning loops into lists is very much a lazy-evaluation sort of idiom.
13:49:09 <Cale> If you don't have lazy evaluation, you're more likely just to do some recursion
13:50:03 <BernhardPosselt> if you have tail recursion :D
13:50:26 <Cale> BernhardPosselt: There's always something you can do to translate an imperative program to a functional one: all the local mutable variables become function parameters, and all the points of control become functions, and you have the result of each function be the function for the next point of control, applied to the new values of the mutable variables.
13:50:32 <BernhardPosselt> i mean general element depth should not be that high to overflow the stack
13:51:02 <Cale> I'm assuming that whether imperative or functional, your language implementation doesn't suck.
13:51:10 <BernhardPosselt> its js :D
13:51:16 <sophiag> hi. i just have some simple question about using data constructors with Maybe. here's my code: http://lpaste.net/354029 . i'm wondering why i can't compile any of the first three functions with my type constructors, so for example "Maybe SList" instead of "Maybe [String]." also why i'm getting the error in the paste when trying to compose them using (<*>) 
13:51:38 <Cale> ah, in that case, you'll need to do some awful trampolining shenanigans if you want to translate
13:51:44 <BernhardPosselt> right
13:51:55 <Cale> Might as well just use GHCJS ;)
13:52:03 <BernhardPosselt> i mean theres TCO but only safari supports it
13:52:08 <benzrf> sophiag: what type is exprs?
13:52:19 <geekosaur> sophiag, a data constructor is a value, not a type
13:52:29 <geekosaur> you can't say Maybe True either
13:52:35 <geekosaur> you can say Maybe Bool
13:52:39 <benzrf> whoops
13:52:41 <BernhardPosselt> Cale: i mean there's also purescript but its tricky for new contributors if you work on it together
13:52:46 <benzrf> right ,heh
13:52:54 <sophiag> benzrf: it's type Exp from ASTs returned by haskell-src-exts
13:52:58 <benzrf> o
13:53:00 <glguy> sophiag: You seem to be misunderstanding <*>
13:53:02 <glguy> :t (<*>)
13:53:04 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
13:53:11 <glguy> but you have: parseSList a <*> parseCList a
13:53:29 <glguy> sophiag: parseSList a :: Maybe [String]
13:53:53 <glguy> sophiag: and so when you're using <*>, then f is Maybe and  (a->b) and [String] can't match
13:54:31 <sophiag> glguy: i thought if you're using <*> with Maybe then it only returns the one that returns Just?
13:54:39 <glguy> no
13:54:48 <glguy> That's more like <|>
13:55:02 <glguy> But that's not going to work here either because your types still don't match
13:55:21 <sophiag> wouldn't i need to make them an applicative instance to use the choice combinator?
13:55:28 <glguy> parseSList a :: Maybe [String], parseCList a :: Maybe [Char], and parseIList a :: Maybe [Integer]
13:55:36 <glguy> [String] , [Char] , and [Integer] don't match
13:55:55 <glguy> You need to use your HList type
13:56:00 <bjs> sophiag: you need to apply your HList contructors to the values inside the Maybe for that to work
13:56:10 <glguy> SList <$> parseSList a <|> CList <$> parseCList a <|> ...
13:56:41 <glguy> which looks like this with explicit parentheses: (SList <$> parseSList a) <|> (CList <$> parseCList a) <|> ...
13:56:45 <sophiag> can't i use the constructors inside the functions themselves? that's what i was trying to do initially
13:56:49 <Owatch> I'm not sure why, but haskell is telling me there is a problem with this line: visited :: Integer -> Integer -> Vector v -> Set s -> Set s
13:57:11 <glguy> Owatch: You can paste your whole code to http://lpaste.net
13:57:13 <Owatch> It states: "Couldn't match type ‘s’ with ‘Integer’" 
13:57:32 <bjs> Owatch: you'll need to paste the full code :)
13:57:51 <sophiag> glguy: when you suggested type signatures like "parseSList a :: Maybe [String]" are you also suggesting i use an argument for the function?
13:57:57 <Owatch> http://lpaste.net/354031
13:58:01 <Owatch> Got it. 
13:58:09 <Owatch> That is the function. Do you want the whole program? 
13:58:11 <sophiag> *an argument other than the one already
13:58:12 <glguy> sophiag: I wasn't suggesting anything, I was telling you that those were the types
13:58:47 <sophiag> well, those functions compile now...just (i think) not the way i want them to
13:58:56 <glguy> Owatch: If you want to insert an Integer into a set, then the type of the set needs to be 'Set Integer'
13:59:11 <glguy> and not 'Set s' which suggests that a set of any type at all will do
13:59:35 <bjs> Owatch: you're inserting j (an Integer) into s (a Set Integer) so your types need to be (Set Integer) to type check
14:00:15 <geekosaur> Owatch, a type signature is exact, and tells a caller what it can expect. if you advertise "Set s" then you are saying "the caller can pick any s", not "I can pick some s (and here picked Integer)"
14:00:49 <Owatch> Okay, switched it for both Vector and Set. Cleared the errors! 
14:01:18 <nitrix> What's the main difference between forkIO and async?
14:01:33 <nitrix> Minor the API, do they operationally work the same?
14:01:33 <bjs> Owatch: i don't think your Vector was as strict, you could've removed the type signature and used GHCi to see what it infers as the type :)
14:01:40 <bjs> Owatch: i do that sometimes when I get type errors
14:01:52 <glguy> nitrix: async is forkIO + some extra stuff to help you get the final result or error at the end
14:02:19 <nitrix> Okay great :D
14:03:34 <Owatch> Well, aside from really annoying conversions between Int and Integer all my errors are gone. 
14:03:46 <Owatch> There's no way the program will work though. So I guess now it's debug time. :( 
14:03:55 <Owatch> Thanks for helping me solve those!
14:06:39 <sophiag> thanks everyone, i got that snippet working. i'm still wondering, though, just as a design issue whether it's wise to use fromJust like that since it assumes one of the functions will return a Just type. and i don't have <?> for error handling as in Parsec, right?
14:07:23 <bjs> Owatch: conversions between Int and Integer are always annoying :)
14:08:38 <BernhardPosselt> Cale: found http://caniuse.com/#search=closest
14:08:52 <BernhardPosselt> tried various examples, all ugly
14:10:58 <Cale> BernhardPosselt: What are you doing that requires that?
14:11:35 <BernhardPosselt> find a form group element that has an input field, starting from the input field
14:11:37 <Cale> BernhardPosselt: I guess I live in a world where absolutely every DOM node was put there by my program, and I would usually statically know the answer to questions of that sort.
14:12:13 <BernhardPosselt> right, you could use a framework where your template language handles that thing for you
14:12:23 <Cale> We use reflex-dom
14:12:41 <BernhardPosselt> however i dont yet want to go that way since mixing serverside and clientside templating is awkward
14:12:49 <Owatch> Great, vector.internal.check error.
14:12:57 <Owatch> Guess I'll have to try this another day.
14:12:58 <Cale> (and no templating at all)
14:13:40 <BernhardPosselt> looks a bit like elm :)
14:13:52 <Cale> It's like elm, except with FRP that doesn't suck
14:14:38 <dmwit_> sophiag: Like what? Generally fromJust is a bit scary, especially if you don't think you've proved that the value will be a Just.
14:15:18 <BernhardPosselt> tbh i think thats the only sensible approach to templating :)
14:15:21 <BernhardPosselt> make it typesafe
14:15:28 <BernhardPosselt> prevents XSS entirely
14:15:40 <Cale> (I have to agree with Elm's decision to move away from their FRP system, because they lacked a lot of the stuff that is needed in order to really make FRP practical for larger applications.)
14:16:24 <sophiag> dmwit_: i was thinking either something like maybe (the function) that will return 0 if the type is Nothing or something like how parsec allows error messages with <?>
14:16:26 <Cale> Yeah
14:17:00 <dmwit> sophiag: I have no context, so your clarification hasn't helped me much.
14:17:09 <Cale> BernhardPosselt: Not to mention that we never have to worry about JSON being out of sync between our frontend and backend, because the code which defines the types and instances used in communication is shared.
14:17:40 <BernhardPosselt> its the 90ies re-invented (view models :D)
14:17:50 <sophiag> dmwit: i'm saying just for error handling (because as you mentioned, you're often not certain one function is guaranteed to return Just)
14:17:50 <Cale> and we can do stuff like compiling our frontend to native ARM code for running on mobile devices
14:18:10 <Cale> That gives a really nice performance boost :)
14:18:12 <sophiag> although i'm not sure that even matters now...i'm passing these to a record where one of the fields is Maybe (because it's optional) so it seems the record itself needs to be wrapped in a Maybe as well?
14:19:26 <Cale> (mind you, right now Android and iOS both require a bit of hackery to get going...)
14:20:23 <dmwit> sophiag: If you post some concrete code to debate, we might be able to say more. At the moment the only advice I feel qualified to give for the information I've gotten from you is "if you're not sure, don't call fromJust".
14:21:12 <sophiag> dmwit: ok cool. i'll kill two bird with one stone that way :)
14:21:49 <Cale> sophiag: and if you *do* ever feel tempted to use fromJust/head and the like, one thing I can recommend is to instead use a pattern matching lambda
14:21:57 <Cale> > (\(Just x) -> x) Nothing
14:22:00 <lambdabot>  *Exception: <interactive>:3:2-15: Non-exhaustive patterns in lambda
14:22:07 <Cale> ^^ when it fails, you get a source location
14:22:51 <sophiag> Cale: this is for a parser, so that's not the type of error handling i'm talking about :)
14:24:33 <Cale> Yeah, fromJust is for those cases where you expect Nothing to be physically impossible.
14:25:33 <sophiag> dmwit & Cale: here's my code http://lpaste.net/354029
14:26:29 <sophiag> you can see the function i was referring to commented out, but then i dropped fromJust and had it return the Amb record as Maybe because it wouldn't compile otherwise (although i'm still getting that odd error)
14:26:33 <Cale> oh!
14:26:42 <Cale> Well, you're actually going in the other direction there
14:27:01 <Cale> setTaggedValue wants a Maybe String, but what you have, tag, is a String
14:27:17 <Cale> So you can just apply Just
14:27:25 <sophiag> but the function parseString returns Maybe String
14:27:35 <sophiag> that's what confused me
14:27:53 <Cale> Well, you're using Maybe as a monad there.
14:28:10 <sophiag> it still returns something like "Just "foo""
14:28:18 <Cale> If parseString t is Nothing, then the whole do-block there is Nothing
14:28:37 <Cale> and if it's Just x, then tag = x
14:28:47 <sophiag> huh, ok
14:29:00 <sophiag> i was just thrown because when i run it in ghc it prints "Just "x""
14:29:09 <sophiag> *ghci
14:29:20 <Cale> When you run parseString?
14:29:24 <sophiag> yes
14:29:26 <Cale> Yes, that's expected.
14:29:44 <sophiag> but it still doesn't mean it's return a vale of type Maybe?
14:29:55 <sophiag> just that it's inside the Maybe monad?
14:30:16 <Cale> It's a value of type Maybe String
14:30:44 <sophiag> so then why is it saying it's of type [Char] (or String)?!
14:30:55 <Cale> Well, in a do-block for the monad M
14:30:59 <Cale> If you have x :: M t
14:31:03 <Cale> and you write  v <- x
14:31:07 <Cale> then v :: t
14:31:13 <sophiag> and outside of that the maybe is unwrapped?
14:31:35 <Cale> and the whole do-block then has type M s for some s (it'll have the same type as the type of the last action in it)
14:31:44 <Cale> So, here, parseString t :: Maybe String
14:31:48 <Cale> So  tag :: String
14:31:49 <sophiag> that's super confusing to me. i never would have thought that without you explaining it
14:32:17 <glguy> For some of this stuff you won't be able to guess how it works, you'll have to read a Haskell tutorial or some kind
14:32:39 <sophiag> tbh this may have even been in Learn You and i just forgot it
14:32:53 <Cale> The Monad instance for Maybe is handy when you have a bunch of possibly-failing operations and you want to write something which will fail if any of them fails.
14:32:58 <Cale> For example...
14:33:06 <sophiag> anyway...now that i have that sorted out i'm back to wanting parseList to *not* be in side a Maybe monad, meaning the error handling issue is still at hand
14:33:27 <sophiag> so that version i commented out wrt to what you were discussing earlier
14:34:03 <Cale> > let dict = [(0,1), (1,3), (2,2), (3,4)] in do x <- lookup 0 dict; y <- lookup x dict; z <- lookup y dict; return (x,y,z)
14:34:06 <lambdabot>  Just (1,3,4)
14:34:15 <glguy> There's no "inside Maybe monad", there's just values that have type 'Maybe something'
14:34:19 <Cale> > let dict = [(0,1), (1,3), (2,2), (3,4)] in do x <- lookup 0 dict; y <- lookup x dict; z <- lookup y dict; w <- lookup z dict; return (x,y,z,w)
14:34:21 <lambdabot>  Nothing
14:34:27 <robkennedy> Are there existing rewrite rules that make multiple lookups in a do block or an Applicative single pass?
14:34:28 <Disavowed> frontendloader: Thank you!
14:34:58 <Cale> sophiag: Well, perhaps you don't want to use do-notation at all.
14:35:21 <sophiag> Cale: but even tho lamdbabot prints "Just (1,3,4)" if you were to pass that to another function then it would simply be "(1,3,4)." that's what i find confusing
14:35:30 <Cale> hm?
14:35:53 <Cale> If we were to pass the whole do-block to another function, it would be equal to Just (1,3,4)
14:36:03 <sophiag> again, i have parseString returning Maybe String, yet i still need to apply Just to it in parseAmbTagged
14:36:32 <geekosaur> sophiag, if you are working in the Maybe monad then (>>=) (or do's <-) will process the Maybe
14:36:33 <Cale> Maybe just use let?
14:36:42 <Cale> let tag = parseString t in ...
14:36:58 <Cale> Then if parseString t = Nothing, you'll have tag = Nothing
14:36:59 <sophiag> geekosaur: that's what i was asking earlier when i said "inside the monad." thanks
14:37:02 <geekosaur> and yes, to avoid it use let instead
14:37:16 <Cale> tag <- parseString t doesn't mean "let tag be equal to parseString t"
14:38:46 <Cale> It means "let tag be the result of 'running' parseString t" -- and what it means to run it depends on the monad in question -- in the case of Maybe, it means that if parseString t is Nothing, we give up and the whole do-block is Nothing, and if it's Just x, then the result is x.
14:39:48 <sophiag> Cale: i get it. i'm wondering now why parseAmb and parseAmbTagged are expecting Amb to be Maybe...also the error handling question i originally asked
14:40:47 <Cale> Well, you said they would produce a Maybe result, and you used operations which got you there...
14:41:37 <Cale> Note, you might have just written  parseAmbTagged t v = do val <- parseList v; return (setTaggedValue (parseString t) val)
14:41:50 <Cale> which would be different from what you wrote there
14:42:11 <Cale> and that would mean the same thing as:
14:42:42 <Cale> parseAmbTagged t v = case parseList v of Nothing -> Nothing; Just val -> Just (setTaggedValue (parseString t) val)
14:42:49 <sophiag> well i changed it to "parseAmbeTagged :: Exp -> Exp -> Amb" now that you explained what's going on with parseString
14:43:21 <Cale> Well, what should it produce when parseList v = Nothing?
14:43:45 <Cale> If you give it that type, it still needs to produce a result of type Amb in that case.
14:43:47 <sophiag> i think you're confusing two distinct questions
14:43:47 <sophiag> the error handling question, again, is about the function specifically marked with a comment
14:44:07 <sophiag> parseList v cannot equal Nothing...
14:44:15 <Cale> er
14:44:19 <sophiag> it's not in the Maybe monad
14:44:28 <Cale> I see  parseList :: Exp -> Maybe HList
14:44:39 <Cale> Is that not what you wanted? It seems sensible to me.
14:44:51 <sophiag> yes, and this is the fourth time i'm politely mentioning that i'm switching back to the version commented out
14:44:57 <Cale> oh, sorry
14:45:04 <Cale> okay
14:45:15 <Cale> Well, then you now can't write val <- parseList v
14:45:32 <sophiag> why?
14:45:35 <Cale> Because parseList v isn't an action in any monad, so that doesn't make sense.
14:45:59 <athan> Can stack generate haddocks for executables?
14:46:00 <sophiag> oh, that's why you suggested case instead of do?
14:46:12 <Cale> That was why I suggested let instead of do
14:46:25 <Cale> The case was just translating what the do actually meant.
14:46:37 <sophiag> two let statements?
14:47:00 <Cale> let tag = parseString t
14:47:06 <Cale>     val = parseList v
14:47:11 <sophiag> i'm also still getting an eror with "tag <- Just $ parseSring t"
14:47:16 <Cale>  in setTaggedValue tag val
14:47:23 <sophiag> ah ok
14:47:33 <sophiag> except parseString needs to be Just
14:47:40 <Cale> Well, that should work, and be the same as  let tag = parseString t
14:48:24 <Cale> However, nobody would tend to write that, in the midst of a do-block, you can use let without the 'in' portion to define things that scope over the remainder of the do-block
14:49:22 <sophiag> yeah i got rid of the do block
14:49:24 <Squarism> is there any way to change "CWD" in ghci wo unloading modules. I just wanna mimic "code as if executed from directory X"
14:49:40 <Cale> sophiag: Seems sensible if you don't want to produce a Maybe result.
14:49:56 <sophiag> and you're saying since i'm not using a monad comprehension then i no longer need to apply Just to the output of parseString
14:50:01 <Cale> Squarism: I believe there's something like setCurrentDirectory
14:50:03 <geekosaur> :!cd
14:50:08 <geekosaur> er no
14:50:09 <geekosaur> :cd
14:50:11 <Cale> oh, right, there's also that
14:50:14 <Cale> hah
14:50:15 <geekosaur> :!cd might work on windows though
14:50:21 <Squarism> :cd unloads all loaded modules
14:50:28 * geekosaur needs to watch those fingermacros, he knows better than that
14:50:30 <Squarism> and it seems i cant import them again
14:50:35 <Cale> sophiag: Right, you wouldn't.
14:50:58 <sophiag> Cale: ok...still wrapping my head around that, but it's been a good learning experience :)
14:51:23 <geekosaur> "Note: changing directories causes all currently loaded modules to be unloaded. This is because the search path is usually expressed using relative directories, and changing the search path in the middle of a session is not supported."
14:51:26 <sophiag> so now i'm just left with wondering about fromJust and the Nothing case. i really wish i could just use something like <?> from Parsec to supply an error message
14:51:42 <geekosaur> you would have to change to absolute search path within ghci 
14:51:46 <Cale> sophiag: You could just case
14:51:59 <Cale> @src fromJust
14:52:00 <lambdabot> fromJust Nothing  = undefined
14:52:00 <lambdabot> fromJust (Just x) = x
14:52:17 <Cale> another way to write that would be
14:52:23 <Cale> fromJust m = case m of
14:52:27 <Cale>   Nothing -> undefined
14:52:31 <Cale>   Just x -> x
14:52:36 <nitrix> Do I understand this right that killThread will always be able to stop a thread, unless it is blocked on an MVar or a foreign call?
14:53:13 <sophiag> Cale: you're saying to use the case expression on all those arguments?
14:53:22 <geekosaur> nitrix, there's a hacky way to make it stop when in a foreign call, but you can't rely on it
14:53:27 <geekosaur> (think about it)
14:54:07 <sophiag> or just override the regular fromJust i guess?
14:54:24 <Cale> sophiag: Either way
14:54:25 <nitrix> geekosaur: Looks like I can avoid it for now, but what's the wacky way?
14:54:58 <geekosaur> nitrix, https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/ffi-chap.html#interruptible-foreign-calls
14:55:44 <geekosaur> the problem is C doesn't have the concept of critical sections, so there is no guarantee you wouldn't be leaving some library data (including libc, think malloc() etc.) in an inconsistent state
14:55:58 <nitrix> geekosaur: Gotcha.
14:56:34 <nitrix> geekosaur: So if it's ever used, it has to be as a force quit mechanism as undefined behavior ensues.
14:56:39 <geekosaur> yes
14:56:40 <Cale> nitrix: Another exception to add to that list would be if the thread you're trying to kill is in a non-allocating loop.
14:57:11 <nitrix> How about the MVar part, can one interrupt a thread blocked on it?
14:57:21 <Cale> yes
14:57:54 <nitrix> But then I risk other threads being deadlocked on writes, if the one a killed was a reader?
14:58:14 <nitrix> (I guess the other around amounts to the same problem)
14:58:22 <nitrix> *way
14:58:33 <Cale> In fact, if the garbage collector collects the last other instance of the MVar, it will send the exception to kill your thread itself.
14:59:11 <nitrix> So if I kill thread A (reader), thread B (writer) will simply die since it's dead locked?
14:59:42 <Cale> Yeah, it'll get a "thread blocked indefinitely on MVar" exception.
14:59:56 <sophiag> Cale: if i overload fromJust then the problem is i have it returning a string as an erorr message in response to Nothing, but need it to be of type Maybe HList -> HList
15:00:04 <nitrix> Okay. Just being sure. I'll obviously try to do things proper here.
15:00:25 <Cale> sophiag: Did you want to produce a result of type Either String HList?
15:00:30 <athan> would anyone here happen to know how to hyperlink haddocks relatively, or with a custom base url? http://stackoverflow.com/questions/43080693/haddock-relative-hyperlinking
15:00:37 <oats> hello, can I paste 4 lines of code here?
15:00:49 <Cale> sophiag: Or did you want your whole program to just die immediately with a message?
15:00:50 <athan> oats: please use lpaste.net :)
15:01:06 <nitrix> ertes: So far I have the main event thread, a logic thread, a render thread, a network thread and a timer thread.
15:01:42 <nitrix> ertes: It works all great, no lag, no shenanigans, very "clean" with MVar, TChan and MSampleVar :)
15:01:44 <sophiag> Cale: not the whole program, but the parse that uses it yes...i'd like it ot just return an error message rathe than creating a useless record
15:02:00 <oats> in this main function, why does the program wait for input before printing the first line? https://ptpb.pw/0_Jm/haskell
15:02:05 <Cale> Right, then probably you want the result to have type Either String HList
15:02:26 <nitrix> ertes: The part to figure out is when the logic thread needs to communicate to the main thread that it needs to quit, but I think I'll hack that by pushing an even in the SDL queue.
15:02:32 <Cale> oats: Line buffering
15:02:35 <nitrix> ertes: And pretend the user is closing the window :)
15:03:13 <nitrix> Making progress :] !
15:03:15 <Cale> oats: You'll need to import System.IO and  hFlush stdout  after the putStr, because otherwise, line buffering will wait for a complete line before writing to the terminal.
15:03:37 <Cale> You can also turn off line buffering (at the cost of some performance) if this is an inconvenience
15:03:41 <oats> Cale: gotcha, thanks!
15:03:45 <Cale> hSetBuffering stdout NoBuffering
15:08:33 <sophiag> Cale usine Maybe HList -> Either String HList
15:08:57 <sophiag> oops...was going to say it now expects different types from the cases. do i need to add constructors?
15:31:19 <athan> Joke's on me, haddock hyperlinks are already relative u_u
15:34:46 <dopey_> Is there a recommended way of "cleaning up" when a process is being killed? I've got a C file handle as well as some malloc'ed variables that I probably want to free before the process actually dies.
15:41:15 <johnw> dopey_: bracket
15:41:56 <johnw> if lexical scoping doesn't work for you, then resourcet or pipes-safe
15:42:40 <dopey_> taking a look. googling turned up MVar() as an alternative too
15:42:54 <johnw> MVar won't free a file handle, though
15:44:51 <dopey_> I figured that I would just call fclose() once the MVar is tripped 
15:45:16 <geekosaur> depends on how it's being killed, actually. if it's a unix signal other than SIGINT then bracket won't help because it doesn't translate to an exception
15:45:51 <Cale> sophiag: Did you figure it out?
15:46:25 <sophiag> Cale: i was just about to ask again! i got distracted with something else...so no: http://lpaste.net/354029
15:46:36 <geekosaur> (and I have no idea how Windows' TerminateProcess shows up in Haskell)
15:47:42 <Cale> sophiag: Well, you'll probably want to rename that from fromJust to something else, but all you need to do is apply Left to the error string, and Right to the successful value.
15:47:45 <dopey_> I assume it would normally be sigint or w/e the signal would be for when a process runs into a code exception (im just running a warp server)
15:48:15 <geekosaur> code exception would be a haskell exception not a signal
15:48:32 <geekosaur> but "being killed" normally means from an external source of some kind
15:48:33 <sophiag> ah ok
15:49:18 <dopey_> gotcha, I think I wanna cover both of those scenarios in this case
15:49:20 <Cale> sophiag: As it happens  Either e  is also a monad, it's similar to Maybe, but where you get the first error (Left) value which occurs
15:49:39 <Cale> sophiag: and if none occur, you get Right of the final result
15:50:02 <sophiag> right. i suppose i could have looked up the constructors
15:50:04 <Cale> > do x <- Right 3; y <- Right 10; return (x + y) :: Either String Integer
15:50:06 <lambdabot>  Right 13
15:50:14 <Cale> > do x <- Left "oops!"; y <- Right 10; return (x + y) :: Either String Integer
15:50:16 <lambdabot>  Left "oops!"
15:50:31 <Cale> Can be useful instead of deeply nested cases.
15:51:09 <sophiag> although now the function i apply it in isn't matching the return value...do i need to use a constructor there?
15:51:21 <Cale> What are you getting?
15:51:36 <sophiag> it expects type HList and is getting Either HList String
15:51:55 <Cale> It should be  Either String HList  btw
15:51:58 <sophiag> it almost seems like i've passed the buck on the whole error handling situation
15:52:03 <Cale> By convention, Left is always the error
15:52:09 <sophiag> oh ok. that's good to know
15:52:36 <Cale> Well, you've enriched your error information with a message, whereas before, you had Nothing which just meant "something went wrong"
15:53:00 <sophiag> i could still go that route i suppose
15:53:45 <sophiag> hmmm...yeah actually i think that makes more sense
15:54:09 <sophiag> otherwise it just seems like i'm propogating the error through everything and not sure how to eventually handle it
15:54:24 <sophiag> so now i have Nothing just returning undefined
15:56:13 <sophiag> welp, before i deal with the more complicated record type i suppose it's time to actually set up IO and have it store the Amb record in a state monad
16:59:23 <ExpHP> I am tempted to replace all of my imports of Turtle with the following: https://gist.github.com/ExpHP/16244a04abe9a3810b4172611aeeea29
16:59:42 <ExpHP> I can't imagine why I feel so strongly about argument order
17:01:31 <ExpHP> That's a lie, I CAN imagine why: currying
17:07:54 <Cale> ExpHP: Why the PackageImports?
17:09:00 <ExpHP> oh, I just do that everywhere
17:09:14 <ExpHP> makes it easier to remember what packages to install when moving things around
17:09:52 <ExpHP> (in other words, because copy paste >_>)
17:12:59 <Cale> ExpHP: There's often a bit of competition between the order in which currying suggests is best (i.e. most frequently changing arguments last), and the order in which it's convenient to write long expressions (longest argument last)
17:13:51 <ExpHP> This particular case would seem to be a slam dunk for me though, because you never want to use a shell twice
17:13:57 <ExpHP> (because it would end up running twice)
17:15:33 <ExpHP> I think the actual motivation behind this argument order is to feel more natural in imperative-looking code
17:16:33 <ExpHP> Then again all the examples in the tutorial have an embedded expressino for the shell (https://hackage.haskell.org/package/turtle-1.3.2/docs/Turtle-Tutorial.html)
17:17:13 <ExpHP> oops, no wait, never mind, I just remembered the actual reason, which I discovered earlier
17:17:56 <ExpHP> (it's because a Shell is a newtype around FoldM, so foldIO just pretty much takes after the record field method)
17:18:15 <Cale> Yeah, I don't really know -- given that you can't just write a function in place of the Fold/FoldM, the reason isn't so that you can hang ... $ \x -> ... off the end
17:19:14 <Cale> (and it's not a Monad, so you also can't have a do-expression there)
17:19:39 <ExpHP> see what I mean?  Square peg, round hole :)
17:20:09 <Cale> (but on the other hand, Shell *is*)
17:28:21 <c_wraith> > do () 
17:28:23 <lambdabot>  ()
17:28:40 <c_wraith> sometimes no monad needed. just to confuse things. 
17:29:24 <ExpHP> > (error "not party time") <$> ()
17:29:27 <lambdabot>  error:
17:29:27 <lambdabot>      • Couldn't match expected type ‘f a0’ with actual type ‘()’
17:29:27 <lambdabot>      • In the second argument of ‘(<$>)’, namely ‘()’
17:29:40 <ExpHP> > :i ()
17:29:42 <lambdabot>  <hint>:1:1: error: parse error on input ‘:’
17:29:51 <ExpHP> @halp
17:29:52 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
17:30:03 <robkennedy> Lambdabot lacks :i
17:30:07 * ExpHP goes to bug lambdabot in query
17:30:26 <geekosaur> lambdabot is not ghci, it doesn't do :i
17:30:40 <boxscape> @undo do ()
17:30:40 <lambdabot> ()
17:31:40 <ExpHP> what is going on there to make that work?  since () isn't a monad
17:31:59 <geekosaur> do notation is mechyanically translated. it doesn;t actually care about monads
17:32:06 <boxscape> do x is just replaced with x by the compiler
17:32:09 <geekosaur> the typechecker cares about monads after the translation is done
17:32:12 <ExpHP> ...oh
17:32:13 <boxscape> https://www.haskell.org/onlinereport/exps.html
17:32:21 <boxscape> 3.14
17:32:29 <geekosaur> (or about applicatives if you have ApplicativeDo enabled)
17:32:33 <ExpHP> hm, but it checks that all the types match on each line?
17:32:41 <ExpHP> oh wait, nvm :)
17:33:17 <geekosaur> actually I suspect it has to care about types with ApplicativeDo because the translation is much different
17:33:31 <c_wraith> or just that there are functions named >> and >>= in scope if you are using rebindable syntax 
17:33:34 <boxscape> I do believe they need to do something to have the error messages display the correct file location after desugaring
17:34:19 <geekosaur> well, desugaring is done at the AST level so that's already a problem (and already handled)
17:34:36 <boxscape> ah, I see
17:34:37 <geekosaur> that is, the initial AST from the parser has "do" nodes in it
17:40:04 <_m_ryan> hi anyone yesod dev here?
17:40:19 <robkennedy> Is a lisp more than a Monad on source code? By which I mean a function `lisp :: [Expression] -> Either Value [Expression]` and `eval :: State -> Expression -> (State,[Expression])`
17:41:11 <robkennedy> _m_ryan: I've used Yesod, but it's extremely opinionated for Haskell so I stopped. May be able to help if you have a question. 
17:41:41 <_m_ryan> yes i don have robkennedy, 
17:41:50 <_m_ryan>  i do have a custom form it has checkbox and select with multiple so i was expecting a list of data on my handler in post method.
17:42:03 <Koterpillar> robkennedy: you've described every interpreter ever
17:42:17 <_m_ryan> can you help me about it?
17:42:51 <robkennedy> Koterpillar: idk how would you describe a lisp vice Haskell?
17:43:12 <_m_ryan> i'm a noob ok yesod haskell so don't have much idea about
17:43:28 <Welkin> lol, hello _m_ryan 
17:43:46 <_m_ryan> hi Welkin :)
17:43:51 <robkennedy> Haskell does not inject terms to be evaluated. Actually I'd push back on that: most programming languages do not need the possibility for consuming a word to add words 
17:44:05 <Koterpillar> robkennedy: if you define Expression differently, this can be, for example, Python
17:44:37 <Koterpillar> robkennedy: btw, it's not [Expression] but S Expression Expression
17:49:28 <robkennedy> I should not be so bold to attempt to type Lisps. But, if you interpret a python program, and begin by interpreting every word in it, you will still interpret the program (modulo promises for words to be defined). In contrast, a Lisp injects new words into its source code. That is my understanding - is it flawed
17:50:05 <robkennedy> *injects new words as it is evaluated
17:50:14 <Welkin> lisp is an ast
17:50:23 <Koterpillar> To my memory, Lisp is an imperative language that doesn't modify the _source_ but construct new expressions in memory
17:50:38 <Koterpillar> Python can do that too as it has 'eval'
17:50:40 <Welkin> the myth of lisp being "functional" seems to continue
17:50:57 <Welkin> only scheme is functional D:<
17:51:16 <Koterpillar> Welkin: it has imperative semantics too
17:51:28 <Welkin> Koterpillar: yes
17:51:29 <robkennedy> Welkin: do you dispute the premise of clojure?
17:51:37 <Koterpillar> robkennedy: do you have an example of a Lisp program injecting new words into its source code?
17:52:27 <Koterpillar> robkennedy: or a definition of bind in your Lisp monad, I'm curious to see where do the extra Expressions end up
17:52:59 <johnw> does anyone happen to have a clone of megacz's ghc-hetmet code?
17:54:50 <robkennedy> Koterpillar: no; a friend asked me the difference between clojure and Haskell, and I tried to describe the idea of "compile the whole program" vs "a program whose compilation is equivalent to it's execution"; a difference I understand​, and which makes sense as a dichotomy, and whose only example I could imagine was a program which injected source code
17:55:47 <Koterpillar> robkennedy: compilation is merely an optimisation
17:55:54 <robkennedy> My clojure coworker brags about homoiconicity, which I am unimpressed by, but seems possibly unique given the description
17:56:19 <robkennedy> Koterpillar: that's not right
17:56:20 <Koterpillar> robkennedy: you can build an interpreter for Clojure, and compiler for both Scheme and your hypothetical "injecting source code" language
17:56:22 <Welkin> there is more to the difference between the two than *that* O.o
17:56:28 <Welkin> you never even mentioned the type system?
17:58:23 <robkennedy> Welkin: sure, there are many differences. What if the distinguishing features of clojure vs python vs Haskell ? Yeah static typing is nice, but it's not unique (nor is dynamic typing)
17:59:01 <Koterpillar> anyway, Lisp doesn't modify its own source any more than Python
17:59:12 <robkennedy> I did mention typing; it's not attractive to physicists
17:59:21 <robkennedy> (who don't code)
17:59:24 <Welkin> robkennedy: the other two languages you listed there do not have an advanced type system
17:59:24 <davean> Koterpillar: Uh?
18:00:02 <davean> Koterpillar: I've regularly done far deeper modifications in lisps then python has any ways I know of of describing short of bytecode reinterpritation
18:00:22 <robkennedy> Welkin: sorry, I mean: assuming you have justified both python and Haskell, how do you justify Lisps?
18:01:24 <robkennedy> Koterpillar: python 3.5 eval isn't magic
18:01:34 <davean> It isn't even CLOSE
18:02:38 <Koterpillar> well, sorry, you can't do meaningful _modifications_ to Python code, but you can _replace_ functions and such with monkey-patching
18:02:56 <davean> Koterpillar: sure, but how do I know how thsoe functions worked in the first place?
18:03:06 <Koterpillar> you don't, they are all black boxes to you
18:03:09 <Koterpillar> Lisp wins here
18:03:09 <davean> its not even a shadow of it
18:03:28 <davean> python has nothing even comparable to lisp's self-modification
18:03:30 <robkennedy> Koterpillar: at some point you're saying "eval is Turing complete"
18:03:42 <Koterpillar> I didn't mean that, let me rephrase
18:04:06 <davean> I can't do a single thing I've actually used lisp's homoiconicity to accomplish in python
18:04:10 <davean> not a single thing!
18:04:28 <Koterpillar> both Python and Lisp have facilities to inspect and modify the currently running program in memory. Lisp can go deeper thanks to its extremely simple AST.
18:04:52 <sophiag> quick question: if i
18:05:02 <Koterpillar> sophiag: that was super quick :)
18:05:11 <ExpHP> gosh darned enter keys
18:05:15 <sophiag> ha. sorry getting used to new keyboard :p
18:06:13 <sophiag> anyways...if i define a data type and use "deriving (Show)" i still need to provide Show as a type constraint to use it, right? for example, if i want to print to ghci?
18:06:25 <davean> sophiag: yes
18:06:32 <Koterpillar> Both Python and Lisp can be compiled or interpreted, so whether compilation is execution or not is irrelevant.
18:06:40 <davean> If you ahve a type variable, you have to know what that type variable supports
18:06:44 <Welkin> sophiag: to use it? What do you mean?
18:06:46 <Koterpillar> sophiag: no
18:06:58 <Koterpillar> sophiag: only if it has parameters
18:06:58 <sophiag> wait...yes, no?
18:07:05 <Welkin> constraints are on the functions
18:07:07 <davean> Koterpillar: I mean, what can't be considered that?
18:07:18 <davean> Koterpillar: I mean, you can say the same thing about C or ASM
18:07:22 <Welkin> as long as the data you apply them to support the type classes required, you don't provide any other information
18:07:34 <robkennedy> sophiag: depends. Ie `data T a = T Int deriving Show` probably doesn't need `Show a`
18:07:35 <Koterpillar> davean: that was my original point to robkennedy - defining an eval so generic describes every interpreter, not just Lisp
18:07:50 <sophiag> it does not have parameters, but ghci still is giving me that error "Now instance for (Show (..))"
18:08:08 <Koterpillar> show what you've defined
18:08:27 <sophiag> and i'm unsure the syntax for using it as a constraint given i'm not using type variables in the signatures of the functions
18:08:41 <Koterpillar> maybe you're showing a different thing?
18:08:43 <sophiag> Koterpillar: like this "data Amb = Amb { tag :: Maybe String, value :: HList } deriving (Show)"
18:09:10 <robkennedy> Koterpillar: that seems like exactly the statement "eval is Turing complete"
18:09:14 <sophiag> and then i have functions of type (Exp -> Amb) and (Exp -> Exp -> Amb)
18:09:40 <ExpHP> I don't suppose HList implements Show?
18:09:49 <sophiag> ExpHP: it does
18:10:22 <Koterpillar> robkennedy: which is correct and not specific to Lisp. Where does that extra [Expression] go?
18:10:26 <ExpHP> ...that's wild
18:10:31 <Koterpillar> sophiag: what's your error message?
18:10:31 <MarcelineVQ> what does the error actually say
18:11:16 <sophiag> oh, actually HList prints...
18:11:18 <sophiag> hmm
18:11:30 <sophiag> but the record using it does not
18:12:12 <sophiag> Koterpillar: "No instance for (Show (Exp -> Amb)) arising from a use of ‘print’"
18:12:21 <ExpHP> Oh
18:12:35 <ExpHP> Look: You're printing a function
18:12:40 <sophiag> yes
18:12:42 <Welkin> lol
18:12:47 <Welkin> you can't print a function
18:12:52 <sophiag> so does that mean i _do_ need the constraint?
18:12:57 <sophiag> wait...i just can't?
18:13:01 <Welkin> if you want to, you need to define a Show instance for it
18:13:04 <ExpHP> apply the function to a value
18:13:13 <sophiag> Welkin: that was my question to begin with!
18:13:14 <Welkin> but then, what should it be?
18:13:20 <ExpHP> (or perhaps I should ask, is there some reason you havent?)
18:13:21 <Welkin> it could be anything
18:13:40 <sophiag> haven't defined Show as a constraint?
18:13:48 <Welkin> what?
18:13:50 <Welkin> no
18:14:06 <Welkin> print requires a Show instance
18:14:19 <Welkin> you could have ghc derive it for you automatically or define it yourself
18:14:25 <sophiag> whether i needed a show instance was my original question
18:14:28 <Welkin> in this case, ghc doesn't know what to do because it is a function
18:14:31 <Welkin> how do you print a function?
18:14:32 <sophiag> someone said yes, another said no
18:14:45 <Koterpillar> you don't need it to print that record
18:14:45 <sophiag> i've been leaving you guys to work out which one is the correct answer. lol
18:14:51 <Koterpillar> but you aren't printing that record
18:14:52 <Welkin> what does printing a function even mean?
18:14:54 <Koterpillar> you are printing a function
18:15:08 <sophiag> i'm printing the return value of that function
18:15:15 <Welkin> sophiag: obviously not, though
18:15:17 <tobiasBora> Hello,
18:15:21 <tobiasBora> I wrote something like:
18:15:23 <tobiasBora> sum <$> forM lastMedias $ \node ->
18:15:25 <tobiasBora>     (node .: "likes") >>= (.: "count")
18:15:29 <Koterpillar> show the code where you're trying to do that?
18:15:57 <tobiasBora> However it does no work because of priority of operators I think
18:16:17 <tobiasBora> If I for the forM .... between parents it works
18:16:39 <tobiasBora> so what is the haskell solution to write this without ugly parents ?
18:16:43 <ExpHP> tobiasBora: yeah, $ is lowest precedence so it will occur before <$>
18:16:51 <ExpHP> (I mean after)
18:16:59 <ExpHP> fmap sum $
18:17:16 <tobiasBora> ExpHP: So I can't use the beautiful operator <$> here
18:17:20 <sophiag> Koterpillar: http://lpaste.net/354047
18:17:30 <robkennedy> Koterpillar: the statement "a Turing complete sublanguage of language A replicates language B" is trivial. Originally I hoped to say something like `lispStep :: (State,Expression) -> (State,[Expression])`, vice ie a python compiler, which might be written `compileStep :: (State,Expression) -> State`
18:17:41 <ExpHP> tobiasBora: tragically, I think so
18:17:50 <tobiasBora> Ohh :(
18:17:53 <tobiasBora> Thank you!
18:17:54 <ExpHP> (at least that's how I handle it)
18:18:15 <sophiag> (not getting involved in this Lisp discussion...i'm trying to move on with my life and learn Haskell...lol)
18:19:31 <Koterpillar> robkennedy: I think the type of your lispStep is wrong, and the right type is closer to compileStep (and Python). Where does the second part of the result go?
18:21:01 <Koterpillar> sophiag: where are you calling 'show'?
18:21:05 <ExpHP> sophiag: and for full measure, the lines you're putting in ghci?
18:23:11 <sophiag> i'm not calling show
18:23:15 <Koterpillar> robkennedy: where Lisp is different from, let's pick a better scapegoat, C, is that State = Map String Expression (or some approximation of such), whereas if you wanted to represent C, best you could do would be  State = [Byte]
18:23:21 <sophiag> i'm just testing functions in ghci
18:23:34 <Koterpillar> sophiag: what expression gives you the error?
18:24:01 <sophiag> "parseList $ fromParseResult $ parseExp "[1, 2, 5]"" returns "IList [1,2,5]"
18:24:40 <sophiag> "parseAmbTagged $ fromParseResult $ parseExp "foo [1, 2, 5]"" throws the error
18:24:59 <Koterpillar> parseAmbTagged has two arguments
18:25:01 <Koterpillar> you gave it one
18:25:17 <tobiasBora> :t msum
18:25:18 <lambdabot> (MonadPlus m, Foldable t) => t (m a) -> m a
18:25:22 <tobiasBora> :t fmap
18:25:24 <lambdabot> Functor f => (a -> b) -> f a -> f b
18:25:26 <Koterpillar> sophiag: try this: ":t parseAmbTagged $ fromParseResult $ parseExp "foo [1, 2, 5]""
18:25:34 <tobiasBora> :t fmap sum
18:25:36 <lambdabot> (Num b, Foldable t, Functor f) => f (t b) -> f b
18:26:08 <robkennedy> Into the next evaluation of lispStep, of course! Contrast `lispCompile s (x:xs) = case lispStep s x of {(s',es) -> lispCompile s' (es ++ xs)}` with `pythonCompile s (e:es) = pythonCompile (compileStep s e) es`
18:26:15 <tobiasBora> I don't understand why "fmap sum" works, but not "msum"...
18:26:33 <sophiag> Koterpillar: seems i need to rewrite the function
18:26:37 <sophiag> :p
18:26:43 <sophiag> parseAmb works
18:26:54 <sophiag> sorry for the waste :p
18:27:23 <ExpHP> sophiag: perhaps not
18:27:25 <Koterpillar> robkennedy: I don't know of any Lisp function that would return a non-empty [Expression] list, can you give an example?
18:27:46 <robkennedy> Koterpillar: (3)?
18:27:50 <ExpHP> sophiag: can you call parseAmbTagged with two arguments?
18:28:08 <sophiag> ExpH: that's besides the point...it's meant to parse an AST
18:28:24 <sophiag> so i need to use one argument and match for different types
18:28:24 <Koterpillar> robkennedy: what is that supposed to do?
18:28:38 <robkennedy> Return the value 4
18:28:38 <ExpHP> oh, then yeah
18:28:49 <robkennedy> Wow.... I meant 3
18:29:15 <Koterpillar> robkennedy: not in any Lisp I know will (3) return the value 3 instead of complaining that 3 isn't a function
18:30:03 <Koterpillar> robkennedy: i.e. (+ 1 2) has _result_ 3, which is output to the console if you're in a REPL, but doesn't _modify the source_
18:30:51 <Koterpillar> robkennedy: def will update the name table (see my definition of state), but even then the function body isn't executed until called.
18:31:01 <robkennedy> Koterpillar: let's not hide ourselves . (if True (3) 2) returns 3
18:32:29 <Koterpillar> robkennedy: you can do that without the second output of lispCompile, by having this, at some point, call if :: Expression -> Expression -> Lisp
18:32:42 <Koterpillar> robkennedy: are you trying to build a stack machine?
18:33:59 <Koterpillar> that will actually work, but again, not just in Lisp
18:34:56 <robkennedy> No, I'm trying to explain to a physics PhD why Lisps are not on the same axis as static vs dynamic typing
18:35:12 <Koterpillar> which is correct
18:35:13 <Koterpillar> afk
18:40:41 <Welkin> robkennedy: why cares?
18:40:48 <Welkin> who*
18:41:04 <Welkin> let them think whatever they want
18:41:15 <Welkin> they aren't even a programmer
18:42:11 <robkennedy> I care. I'd hope that the difference between Lisps and Haskell and python exists as more than historical accident. 
18:45:18 <robkennedy> Moreover, the discrepancies I describe do exist - whether or not the object I've called Lisps correspond with actual Lisps, they do correspond to actual evaluation strategies. 
18:53:31 <boxscape> sometimes it feels like you should be able to do something like `(if p then x :) xs` instead of `if p then x : xs else xs`... although of course that doesn't make that much sense
18:53:44 <mikeplus64> anyone got ghc-vis (or equivalent) workong for ghc 8.0.2?
18:54:38 <robkennedy> boxscape: I use `(if p x then (x:) else id)` for those cases
18:54:51 <boxscape> robkennedy: ah, yeah, that doesn't look too bad
18:55:41 <geekosaur> if sections?
18:55:45 <boxscape> @pl \xs -> if p then x : xs else xs
18:55:45 <lambdabot> if' p =<< (x :)
18:55:48 * geekosaur wonders how badly that would mess up parsers :)
18:56:29 <boxscape> (if' p =<< (x :)) xs is actually visually speaking remarkably close to what I wrote above
18:56:47 <robkennedy> : if'
18:56:52 <ExpHP> if you have a Maybe you can do   maybe xs (:xs) x
18:56:52 <geekosaur> except if' doesn't exist as such
18:56:55 <geekosaur> there is bool through
18:56:57 <robkennedy> :t if'
18:56:58 <boxscape> right, I know
18:56:58 <lambdabot> error:
18:56:59 <lambdabot>     • Variable not in scope: if'
18:56:59 <lambdabot>     • Perhaps you meant ‘f'’ (imported from Debug.SimpleReflect)
18:57:05 <Welkin> seems like a useless extension
18:57:11 <Welkin> this isn't code golf
18:57:39 <boxscape> Welkin: are you talking about if'?
18:57:39 <geekosaur> :t \p x xs -> bool (x:) id p xs
18:57:41 <lambdabot> Bool -> a -> [a] -> [a]
18:57:59 <Welkin> what is wrong with `if p then x : xs else xs`?
18:58:11 <Welkin> it's clear, short, and does what you expect
18:59:03 <boxscape> well, sure, but it just kind of.. looks like you ought to be able to take out the xs. Nothing really wrong with it
19:01:51 <robertkennedy> You're right boxscape. What you want, from what I've seen, is `f p (x:xs) = (if p x then (x:) else id) $ f p xs`
19:01:57 <ExpHP> is there no languge extension for where clauses in do blocks?
19:02:34 <boxscape> robertkennedy: yeah, I can definitely see myself using something like that in a few cases
19:02:38 <robertkennedy> What I've written is filter, but it generalizes nicely. 
19:02:41 <Cale> ExpHP: What would that look like?
19:02:52 <ExpHP> idunno, you tell me
19:03:09 <ExpHP> O:)
19:03:19 <robertkennedy> boxscape: yeah, I give that idiom as a Haskell user, not expert
19:03:26 <Cale> ExpHP: where clauses normally exist so that they can scope over multiple guards, but do-expressions don't have guards...
19:03:41 <robertkennedy> I've also used the idiom and felt wrong about it
19:03:50 <ExpHP> I just want something to scope over one line right now
19:03:58 <Cale> You can use let
19:04:27 <Cale> (or even let/in)
19:05:09 <boxscape> `where` is just desugared into `let ... in` anyway, so if you think you can do it with where, you ought to be able to do it with `let ... in`, especially if you don't have guards
19:05:12 <ExpHP> Cale: I can't quite picture where it would go: https://gist.github.com/ExpHP/38d5fc777d8b165fd2286c5db134358e
19:06:13 <ExpHP> er, that's also inside a do block
19:06:37 <ExpHP> basically I don't want to disturb the margin for the first line
19:09:38 <ExpHP> (updated gist to give slightly better idea)
19:11:45 <boxscape> ExpHP: I'm not sure if I have a good enough idea, but I still don't see why you couldn't just use `let` inside the do-Block in `act` instead of writing it into the where-Block
19:12:18 <robertkennedy> In the Vector documentation, they use `<1,2,3> :: Vector Int`. In SPJ's dph talks, he uses `[:1,2,3:] :: Array Int`. I've failed to use either syntax. How do I stop failing?
19:12:27 <ExpHP> boxscape, just because it's noisy
19:12:34 <ExpHP> boxscape: But perhaps I'm too picky
19:13:13 <boxscape> maybe if you write it with let and post it someone can suggest a way to make it less noisy, or maybe not, I don't know
19:14:11 <ExpHP> the thing is they're helper functions, and 'let' makes them look at a glance like they're values
19:14:41 <boxscape> functions *are* values :P
19:14:49 <ExpHP> I knew somebody would say that
19:14:56 <ExpHP> you know what I mean :P
19:15:07 <boxscape> alright, yeah, I know..
19:16:14 <ExpHP> of course I could also move them to global scope at the bottom of the file, but I also hate polluting the namespace
19:16:25 <ExpHP> more local bindings = easier to see their purpose
19:16:47 <Cale> what do you want to define?
19:16:50 <lyxia> robertkennedy: I don't think you can actually use such notation.
19:16:52 <ExpHP> but again I guess I'm fretting over small details at this point
19:17:00 <Cale> Did you try just putting the definitions there?
19:17:04 <Cale> I think it'll work
19:17:35 <ExpHP> Cale of course I could; question isn't whether it will work, it's whether or not I'll enjoy reading the code later
19:17:38 <lyxia> robertkennedy: quasiquotes can get you somewhat close, you just don't get to choose the brackets
19:17:42 <ExpHP> "wtf is dquote"
19:17:45 <ExpHP> "oh there it is"
19:18:17 <Cale> If it's within a few lines of where it's used, there won't be a problem no matter what you do
19:18:58 <ExpHP> Cale: if you mean the bottom of the file/end of the do block, that is hardly the full source code :P
19:19:05 <robertkennedy> lyxia: dang. How do you interact with dph? Vector.fromList isn't awful, but I can't figure out how to access `sumP`
19:19:42 <ExpHP> But anyways: There's really no language extension?
19:19:45 * ExpHP puppy dog eyes
19:20:15 <Cale> You want a where which does what?
19:20:38 <ExpHP> which can be attached to a line in a do block
19:20:39 <Cale> Scopes over an entire do-block?
19:20:45 <Cale> or, just one line?
19:20:52 <Cale> You can have a line which is
19:20:59 <Cale> let <decls> in <expr>
19:21:23 <lyxia> robertkennedy: Isn't sumP a repa thing
19:21:26 <ExpHP> > let in ()
19:21:28 <lambdabot>  ()
19:22:05 <Cale> lyxia: sumP was a dph thing before it was a repa thing. repa is sort of inspired by dph.
19:22:36 <Cale> Repa basically is dph but without the *nested* data parallelism.
19:22:54 <Cale> Well, and then with a bunch of other ideas layered on
19:22:56 <Cale> :)
19:23:03 <ExpHP> > do { let in x where x = 3; }
19:23:05 <lambdabot>  <hint>:1:15: error: parse error on input ‘where’
19:23:20 <Cale> > do { let x = 3 in Just x }
19:23:22 <lambdabot>  Just 3
19:23:23 <lyxia> Is that [:a:] notation actually a thing then?
19:23:34 <robertkennedy> Please say yes
19:23:53 <lyxia> robertkennedy: looks like there is a ParallelArrays extention
19:24:02 <Cale> Uhh, I don't know if they ever actually got it to the point of implementing the parallel array comprehension syntax
19:24:08 <Cale> maybe?
19:24:13 <ExpHP> > x where x = 3
19:24:15 <lambdabot>  <hint>:1:3: error: parse error on input ‘where’
19:24:21 <ExpHP> ohhhhhhhh
19:24:47 <ExpHP> where's aren't attached to expressions, are they >_>
19:24:47 <boxscape> robertkennedy: and ParallelListComp
19:25:06 <lyxia> robertkennedy: Oh! Indeed this is enabled by ParallelArrays.
19:25:21 <robertkennedy> SPJ mentions in many talks to email him about use requests for DPH, but I get starstruck by MC Frontalot so I havent
19:26:03 <robertkennedy> lyxia: gold struck. Finally a reason to use -Odph over -O2?
19:26:04 <Cale> He's very friendly, and I'm sure he'd be interested to know that people are still interested in it.
19:26:16 <boxscape> ExpHP: in case you're interested, this page tells you exactly how `where` is translated into `let ... in` https://www.haskell.org/onlinereport/decls.html
19:26:51 <Cale> ExpHP: Yeah, where clauses are part of the syntax of declarations usually.
19:27:39 <Cale> Actually, I believe with one exception being that they're also part of the syntax of case expressions, so that you can have where clauses that scope over a bunch of the guards in a case expression (and have the bound variables in scope)
19:28:29 <lyxia> robertkennedy: it's well hidden, the GHC user guide doesn't mention this extension, but says DPH is highly experimental and points to https://wiki.haskell.org/GHC/Data_Parallel_Haskell
19:28:29 <boxscape> Cale: I believe in `case` they are just part of the pattern binding, which makes them part of a declaration again
19:28:39 <Cale> https://www.haskell.org/onlinereport/exps.html#case
19:28:45 <ExpHP> thanks for the link boxscape
19:29:04 <Cale> The "where decls" there as part of the syntax of alternatives.
19:29:45 <boxscape> ah, yeah
19:30:02 <robertkennedy> lyxia: none of the source they mention compile with stack LTS that support ghc 8, and ApplicativeDo is too good to backtrack, unfortunately
19:30:24 <Cale> > case Just 5 of { Nothing -> 0; Just x | y > 10 -> y; otherwise -> y^2 where y = 2*x }
19:30:27 <lambdabot>  y
19:30:43 <boxscape> but it's still part of the pattern binding, isn't it? at least if you look at it after the "shorthand" has been resolved
19:30:47 <Cale> oops!
19:30:49 <Cale> haha
19:31:00 <Cale> > case Just 5 of { Nothing -> 0; Just x | y > 10 -> y | otherwise -> y^2 where y = 2*x }
19:31:00 <lyxia> robertkennedy: 7.4 is quite old indeed
19:31:02 <lambdabot>  100
19:31:04 <boxscape> well, part of the match, I should say
19:31:05 <Cale> there we are
19:31:13 <Cale> used a ; where I wanted a |
19:31:27 <Cale> and y was in scope from lambdabot
19:31:32 <boxscape> > y
19:31:34 <lambdabot>  y
19:31:38 <boxscape> > testing
19:31:39 <Cale> :t y
19:31:41 <lambdabot>  error:
19:31:41 <lambdabot>      • Variable not in scope: testing
19:31:41 <lambdabot>      • Perhaps you meant one of these:
19:31:41 <lambdabot> Expr
19:31:48 <Cale> x + y + z
19:31:50 <Cale> > x + y + z
19:31:52 <lambdabot>  x + y + z
19:31:56 <Cale> > x^6
19:31:58 <lambdabot>  x * x * (x * x) * (x * x)
19:32:03 <boxscape> that's neat
19:32:03 <Welkin> lol
19:32:16 <boxscape> weird parenthesizing rules though
19:32:40 <Cale> Not so weird, it's associated like that -- (^) uses square and multiply
19:32:50 <boxscape> ah, ok
19:32:51 <robertkennedy> After SPJ, Philip​ Wadler, and the elusive Simon Marlow, who's talks should I turn to for study? Edward Kmett has great subject lectures, and I'm starting to study those. What names come to mind for Feynman-esque depth?
19:33:04 <robertkennedy> *whose
19:33:41 <Cale> robertkennedy: Do you have the specific SPJ video about pudding combinators? :D
19:34:08 <Cale> http://ulf.wiger.net/weblog/2008/02/29/simon-peyton-jones-composing-contracts-an-adventure-in-financial-engineering/
19:34:08 <robertkennedy> Pudding? Not yet, hyped to watch it!
19:35:28 <robertkennedy> Oh shit at Clearwater Analytics, where I am our Haskell guy, this is the one paper I've seen global CC'd from the CTO who had never heard of Haskell
19:35:31 <ExpHP> "How to fit pudding in just 9 constructors"
19:36:08 <Cale> Conal Elliott, who just joined the channel, also has some rather good talks and demos :)
19:36:42 <peddie> robertkennedy: Oleg Kiselyov http://okmij.org/ftp/
19:36:46 <Cale> https://www.youtube.com/watch?v=bmKYiUOEo2A -- perhaps this one? :)
19:37:20 <peddie> robertkennedy: actually I misread the question, Oleg does not have a lot of talks.  but feynmanesque depth sounds like oleg papers to me
19:37:41 <conal> Cale: thanks for the plug
19:38:09 <Cale> :D
19:40:34 <robertkennedy> peddie: sounds perfect to me. Simon Marlow lacks breath, but you can still take note of his hesitations etc
19:43:05 <peddie> robertkennedy: have fun!
19:44:07 <Cale> What other really good talks... ah I remember really enjoying this talk by dcoutts on Cloud Haskell https://skillsmatter.com/skillscasts/3523-cloud-haskell
19:44:32 <robertkennedy> Cale: I'm a data analyst at a financial company, and this paper (contracts) is the basis for our developer orientation lecture
19:44:35 <Cale> Unfortunately, they've conveniently added a login wall since it went up, but accounts are free at least.
19:45:09 <Cale> I might also plug my own boss' talk about reflex and reflex-dom :) https://www.youtube.com/watch?v=dOy7zIk3IUI
19:48:05 <robertkennedy> I like skillsmatter. Speaking of which, is the London LambdaCon hype? What are your most hyped Haskell conventions?
19:48:31 <Welkin> lambdaconf and strange loop?
19:49:34 <Welkin> there is some kind of developer conference happening in my city this week, but it's all .net and microsoft crap o.o
19:57:53 <Cale> O
19:57:56 <Cale> oops
20:02:16 <Cale> I haven't been to so many different things yet. I went to Compose, and that was fun. Also, the Boston Hackathon, which was pretty laid back and I had a lot of good chats there.
20:02:38 <Cale> I'm considering attending BayHac coming up right now
20:04:17 <Cale> I'd originally had a plan to go visit a friend in Melbourne a while back, and that fell through. Maybe if we're able to resuscitate that plan, I can connect through BayHac to Melbourne, and then attend LambdaJam in Sydney on my way back in May :D
20:11:13 <boxscape> > x^y -- why does this happen?
20:11:19 <lambdabot>  mueval-core: Time limit exceeded
20:11:42 <Koterpillar> :t x
20:11:43 <lambdabot> Expr
20:19:07 <glguy> :t (^)
20:19:08 <lambdabot> (Num a, Integral b) => a -> b -> a
20:19:54 <glguy> http://hackage.haskell.org/package/base-4.9.1.0/docs/src/GHC.Real.html#%5E
20:20:07 <glguy> Expr has a bunch of bogus instances that are handy for the simplest cases
20:20:29 <glguy> But in the case of (^) the instances result in evaluation never completing
20:20:52 <glguy> > (10 < x, x < y, y > x)
20:20:54 <lambdabot>  (True,True,True)
20:21:28 <glguy> It's useful for simple examples like:
20:21:34 <glguy> > sum [x,y,z]
20:21:36 <lambdabot>  0 + x + y + z
20:22:23 <glguy> > S.fromList [x,y,z,x,y,z]
20:22:26 <lambdabot>  fromList [x,y,z]
20:23:30 <Cale> > foldr f z [1,2,3]
20:23:32 <lambdabot>  f 1 (f 2 (f 3 z))
20:24:25 <boxscape> hm, I see
20:25:05 <boxscape> > take x [1..5]
20:25:07 <lambdabot>  error:
20:25:07 <lambdabot>      • Couldn't match expected type ‘Int’ with actual type ‘Expr’
20:25:07 <lambdabot>      • In the first argument of ‘take’, namely ‘x’
20:25:27 <boxscape> that does make sense as well
20:25:31 <Cale> Yeah, you can't actually do anything which meaningfully relies on the value of the variables.
20:25:49 <Cale> They're just glorified strings with a bunch of instances
20:26:09 <Cale> The function-y ones are a bit more than that, but not by too much
20:26:11 <Cale> :t f
20:26:12 <lambdabot> FromExpr a => a
20:26:21 <Cale> :t f :: Expr -> Expr
20:26:22 <lambdabot> Expr -> Expr
20:26:31 <Cale> > f x
20:26:34 <lambdabot>  error:
20:26:34 <lambdabot>      • Ambiguous type variable ‘a0’ arising from a use of ‘show_M670384748145...
20:26:34 <lambdabot>        prevents the constraint ‘(Show a0)’ from being solved.
20:26:38 <Cale> > f x :: Expr
20:26:40 <lambdabot>  f x
20:27:22 <boxscape> oh, different letters have different types?
20:27:26 <boxscape> :t o
20:27:28 <lambdabot> error:
20:27:28 <lambdabot>     Ambiguous occurrence ‘o’
20:27:28 <lambdabot>     It could refer to either ‘Debug.SimpleReflect.o’,
20:27:36 <Cale> iirc, f, g, h were the generalised ones
20:27:37 <Cale> :t o
20:27:39 <lambdabot> error:
20:27:39 <lambdabot>     Ambiguous occurrence ‘o’
20:27:39 <lambdabot>     It could refer to either ‘Debug.SimpleReflect.o’,
20:27:39 <Cale> oh
20:27:42 <Cale> hah
20:27:45 <Cale> :t s
20:27:46 <lambdabot> Expr
20:27:50 <boxscape> ok
20:39:08 <boxscape> > reduction (1+2*(3+4)) -- the package is pretty neat in general
20:39:10 <lambdabot>  [1 + 2 * (3 + 4),1 + 2 * 7,1 + 14,15]
21:06:39 <halogenandtoast> Is there a nicer way to do: if x `elem` xs then x else '_'
21:20:13 <[k-_> maybe '_' id (find x xs) or bool '_' x (x `elem` xs)
21:20:31 <[k-_> or fromMaybe '_' (find x xs)
21:21:26 <[k-_> oh, oops I remembered the type signature of find wrongly :p
21:23:28 <[k-_> i think the way you did it would be the best way
21:39:29 <_sras_> What are the compiler options that can help to reduce the size of the resulting executable?
21:43:09 <jle`> halogenandtoast: hangman game? :)
21:43:53 <srhb> _sras_: I don't know of any that don't change the functionality. you could strip the executable afterwards though.
21:44:07 <srhb> "Don't change functionality" -- as in static vs dynamic.
21:46:34 <halogenandtoast> jle`: How did you guess?
21:46:41 <halogenandtoast> The '_' gave it away?
21:46:58 <jle`> it's the whole function
21:47:09 <jle`> i've written it countless times but only for my many hangman re-implementations lol
21:47:23 <Cale> -fno-code is pretty good at reducing size ;)
21:47:43 <halogenandtoast> jle`: yeah that's fair
21:47:50 <halogenandtoast> checking the logs for the answers
21:48:08 <jle`> i also assign hangman as a homework assignment so i see it a lot too :)
21:48:24 <halogenandtoast> Yeah I assigned it as "homework" for ruby
21:48:29 <halogenandtoast> and decided to write it in Haskell
21:48:48 <jle`> hangman is a project i recommend a lot for haskell because it's something that you can write so many different ways
21:49:07 <jle`> once you learn more concepts
21:49:30 <jle`> so if you implement it one way now, it's likely that you'll do it another way in a few months
21:49:41 <halogenandtoast> jle`: True, here is my first pass: https://gist.github.com/halogenandtoast/86675d429b918fc70db6bb2778a17d7e
21:50:40 <jle`> nice :)
21:52:00 <halogenandtoast> Thanks
21:52:16 <halogenandtoast> I'm sure there are things I could do better
21:52:24 <halogenandtoast> but it's simple enough
21:52:56 <jle`> it's already pretty clean :)
21:53:19 <jle`> the classic recursive game loop
21:53:34 <halogenandtoast> Yeah that's my go to.
21:53:42 <halogenandtoast> A few of the patterns in here I reuse a lot
21:53:53 <halogenandtoast> For instance in almost all my command line games, I implement `ask`
21:54:41 <halogenandtoast> And I often do main = getArgs >>= run
21:55:04 <halogenandtoast> to pattern match on args nicely
21:55:57 <jle`> you can learn a lot about someone by looking at how they implement hangman
21:57:00 <jle`> reminds me of https://www.willamette.edu/~fruehr/haskell/evolution.html
21:58:45 <halogenandtoast> Ha, yeah, I sometimes wonder which category I fall in.
22:01:23 <johnw> halogenandtoast: one with identity and composition, I hope
22:04:35 <vinskystra> anyone here? what book do you reccommend, I have experience in C
22:04:48 <vinskystra> and also python, but not in the OOP aspects of it
22:05:05 <Cale> _sras_: But more seriously, try asking around in #ghc for help with code size. There were some issues we were having with code size, and -- well, I hesitate a little to comment on this because I was only overhearing things that were going on -- but it sounded like some stuff related to removal of dead code wasn't working quite as intended.
22:05:15 <kadoban> vinskystra: Thankfully, lack of OO experience probably won't matter. I like http://haskellbook.com/ a lot
22:05:41 <jle`> the more OOP experience you have, the harder time you'll have learning haskell
22:05:49 <_sras_> Cale: It is not a big deal. Just checking if there is some "low hanging stuff" regarding this...
22:06:32 <halogenandtoast> jle`: I don't think that has to be a true statement
22:06:56 <jle`> i suppose it's not strictly monotonic
22:07:13 <halogenandtoast> But I came from OOP and had a hard time at first
22:07:25 <halogenandtoast> but that's because I focused too much on trivial things
22:07:26 <halogenandtoast> like Monads
22:08:00 <Cale> _sras_: For us, it was temporarily a big deal, as it had to do with code size limits on Apple's iOS app store -- we sidestepped the issue by figuring out how to increase the version number on some things in order to qualify for a newer limit.
22:08:12 <vinskystra> thanks a lot!
22:08:22 <Cale> _sras_: but ultimately we'd like to get the actual issue fixed :P
22:09:00 <spatial> http://lpaste.net/354050 Converting this to haskell. How many loops are there ? Anyone can explain ?
22:09:24 <spatial> I am not a lisp coder
22:09:49 <jle`> i am not a lisping man, but ctrl+f loop reveals 4 matches
22:10:57 <spatial> I mean I understand haskell and just converted a 300 line lisp program to haskell. Wasn't too difficult. Just asking.
22:11:46 <spatial> There is a loop in finally ?
22:11:47 <Cale> I would normally be able to help you, but the presence of the loop macro means I would have to guess a little at what the code means. Some Common Lispers really love it, but I always avoided that thing.
22:13:08 <spatial> finally is called after the repeat and first loop finishes. Right ?
22:14:15 <Cale> http://www.lispworks.com/documentation/lw51/CLHS/Body/06_a.htm might be helpful...
22:14:28 <spatial> Can't I just add a last statement at the end instead of finally ?
22:16:28 <Cale> I think finally is meant to be what happens once the loop is about to complete, but with all the stuff that's initialised by the loop still in scope
22:17:34 <Cale> For example here you have that array which is brought into scope by the loop construct, so you can't do what you're doing in the finally after the loop, because that would no longer be available.
22:17:44 <spatial> Yes. I use Java finally. Any other easy lisp to replace that ?
22:19:13 <spatial> Cale: I will read that link too.
22:20:39 <spatial_> Any equivalent of finally in lisp ?
22:20:53 <spatial_> Converting some lisp.
22:21:04 <spatial_> I mean in haskell.
22:21:25 <Cale> Uh, well, Haskell doesn't have anything remotely like the loop macro. You'd have to translate the intent of the code.
22:22:24 <Cale> (well, it could if someone was crazy enough to implement something like it using Template Haskell, but that's unlikely)
22:23:02 <spatial> Let me try.
22:23:06 <Cale> Anyway, it just means you need to do some extra stuff at the end of the loop
22:24:52 <Cale> I don't really know what this code is meant to compute, so it's hard to offer suggestions about how to translate it
22:59:52 <spatial> When is init called in http://lpaste.net/354050 ? For every repeat ?
23:00:54 <spatial> Oh Intended for lispers
23:04:03 <b_perez> #haskell
23:07:55 <b_perez> Hi all, first time on this channel. I've been messing around with the ghc api and am trying to use it to parse a haskell program and get type info about various expressions in this parsed program. Any tips? The api has been sorta hard to get into
23:14:55 <geekosaur> it is difficult, yes. there are examples out there (see for example ghc-mod and intero), and also some simplified interfaces that may be sufficient for some use cases (see for example the hint package)
23:17:53 <b_perez> thanks! hint looks really nice. I'm basically trying to parse a program and modify all expressions in the program with a certain type.
23:22:37 <cocreature> b_perez: you might also be interested in ghc-exactprint, in particular, https://hackage.haskell.org/package/ghc-exactprint-0.5.3.0/docs/Language-Haskell-GHC-ExactPrint.html#v:parseModule.
23:31:37 <spatial> Parse error at 2nd 'where' http://lpaste.net/354051. What could be wrong ?
23:32:02 <spatial> Don't see any other error in spacemacs.
23:35:48 <cocreature> spatial: you can only use "where" on a definition and the call to "loop1" is not a definition
23:36:05 <cocreature> definition meaning something with an equality sign in between :)
23:37:10 <cocreature> spatial: you can use a "where" clause on the definition of "loop"
23:37:41 <cocreature> or use "let"
23:38:12 <spatial> I was trying to define another nested function.
23:38:48 <cocreature> you can nest it by putting it on the definition of "loop"
23:38:56 <cocreature> you can’t nest it inside the first guard
23:39:43 <spatial> Sorry. Didn't get. 
23:39:59 <cocreature> let me make an example
23:40:06 <spatial> You mean loop1 has to be defined beforehand.
23:40:55 <lpaste_> cocreature annotated “No title” with “No title (annotation)” at http://lpaste.net/354051#a354052
23:42:12 <spatial> Ok. Thanks.
23:42:42 <cocreature> spatial: arguably you should split up your definition into multiple clearly separated top-level definitions once you reach that level of nesting but that’s a matter of taste
23:44:37 <spatial> cocreature: Should be more functional. Yes
23:52:26 <Gurkenglas_> (Warning: Code golf. Had not expected that eta-reducing f would make a difference in the runtime there http://lpaste.net/2677038667326816256 )
23:52:56 <Gurkenglas_> (After all f is only called like 15 times with the provided inputs)
23:56:32 <arctictern> Hey guys, newcomer here. I have a few questions about stack if anyone cares to answer
23:56:58 <arctictern> Long story short, when I setup a new stack project and try to do "import Data.List.Split", stack build fails with the following error: Failed to load interface for ‘Data.List.Split’
23:56:58 <arctictern>     It is a member of the hidden package ‘split-0.2.3.1’.
23:58:22 <arctictern> This is w/o modifying stack.yaml or myproject.cabal. I can get it to work by adding extra dependencies to those files, but I'm confused as to why that's necessary. It looks like the snapshot I'm using (8.6) has the Data.List.Split module. So why should I need to explicitly add it to my config?
23:58:59 <opqdonut> arctictern: you don't need to add it to stack.yaml, but you do need to add it to myproject.cabal
23:59:04 <geekosaur> yes, because anything not specified is hidden. you can have multiple versions of packages, or packages that export the same module namespace
23:59:05 <hvr> arctictern: because stack.yaml is a project config
23:59:15 <hvr> arctictern: while myproject.cabal is actually a package config
23:59:24 <opqdonut> arctictern: stack defines which packages are available in the sense that can be used. cabal defines which packages are visible in your project
23:59:43 <geekosaur> so you must specify what packages (and ideally versions) provide the ones you want to use
23:59:54 <arctictern> Ok that makes sense 
